{"id":468036,"title":"24｜树：如何设计一个树形组件？","content":"<p>你好，我是大圣。</p><p>上一讲，我们一起学习了弹窗组件的设计与实现，这类组件的主要特点是需要渲染在最外层body标签之内，并且还需要支持JavaScript动态创建和调用组件。相信学完上一讲，你不但会对弹窗类组件的实现加深理解，也会对TDD模式更有心得。</p><p>除了弹窗组件，树形组件我们在前端开发中经常用到，所以今天我就跟你聊一下树形组件的设计思路跟实现细节。</p><h2>组件功能分析</h2><p>我们进入<a href=\"https://e3.shengxinjing.cn/#/component/tree\">Element3的Tree组件文档页面</a>，现在我们对Vue的组件如何设计和实现已经很熟悉了，我重点挑跟之前组件设计不同的地方为你讲解。</p><p>在设计新组件的时候，我们需要重点考虑的就是树形组件和之前我们之前的Container、Button、Notification有什么区别。树形组件的主要特点是可以无限层级、这种需求在日常工作和生活中其实很常见，比如后台管理系统的菜单管理、文件夹管理、生物分类、思维导图等等。</p><p><img src=\"https://static001.geekbang.org/resource/image/0y/f6/0yy86b867a51890c7ea1ebbaf11f90f6.png?wh=1814x744\" alt=\"图片\"></p><p>根据上图所示，我们可以先拆解出树形组件的功能需求。</p><p>首先，树形组件的节点可以无限展开，父节点可以展开和收起节点，并且每一个节点有一个复选框，可以切换当前节点和所有子节点的选择状态。另外，同一级所有节点选中的时候，父节点也能自动选中。</p><!-- [[[read_end]]] --><p>下面的代码是Element3的Tree组件使用方式，所有的节点配置都是一个data对象实现的。每个节点里的label用来显示文本；expaned显示是否展开；checked用来决定复选框选中列表，data数据内部的children属性用来配置子节点数组，子节点的数据结构和父节点相同，可以递归实现。</p><pre><code class=\"language-javascript\">&lt;el-tree\n  :data=\"data\"\n  show-checkbox\n  v-model:expanded=\"expandedList\"\n  v-model:checked=\"checkedList\"\n  :defaultNodeKey=\"defaultNodeKey\"\n&gt;\n&lt;/el-tree&gt;\n&lt;script&gt;\n  export default {\n    data() {\n      return {\n        expandedList: [4, 5],\n        checkedList: [5],\n        data: [\n          {\n            id: 1,\n            label: '一级 1',\n            children: [\n              {\n                id: 4,\n                label: '二级 1-1',\n                children: [\n                  {\n                    id: 9,\n                    label: '三级 1-1-1'\n                  },\n                  {\n                    id: 10,\n                    label: '三级 1-1-2'\n                  }\n                ]\n              }\n            ]\n          },\n          {\n            id: 2,\n            label: '一级 2',\n            children: [\n              {\n                id: 5,\n                label: '二级 2-1'\n              },\n              {\n                id: 6,\n                label: '二级 2-2'\n              }\n            ]\n          }\n        ],\n        defaultNodeKey: {\n          childNodes: 'children',\n          label: 'label'\n        }\n      }\n    }\n  }\n  \n&lt;/script&gt;\n\n</code></pre><h2>递归组件</h2><p>这里父节点和子节点的样式操作完全一致，并且可以无限嵌套，这种需求需要组件递归来实现，也就是组件内部渲染自己渲染自己。</p><p>想要搞定递归组件，我们需要先明确什么是递归，递归的概念也是我们前端进阶过程中必须要掌握的知识点。</p><p>前端的场景中，树这个数据结构出现的频率非常高，浏览器渲染的页面是Dom树，我们内部管理的是虚拟Dom树，<strong>树形结构是一种天然适合递归的数据结构</strong>。</p><p>我们先来做一个算法题感受一下，我们来到<a href=\"https://leetcode-cn.com/problems/invert-binary-tree\">leetcode第226题反转二叉树</a>，题目的描述很简单，就是把属性结构反转，下面是题目的描述：</p><blockquote>\n<p>每一个节点的val属性代表显示的数字，left指向左节点，right指向右节点，如何实现invertTree去反转这一个二叉树，也就是所有节点的left和right互换位置呢？</p>\n</blockquote><pre><code class=\"language-javascript\">\n输入     \n     4\n   /   \\\n  2     7\n / \\   / \\\n1   3 6   9\n输出\n     4\n   /   \\\n  7     2\n / \\   / \\\n9   6 3   1\n节点的构造函数\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n</code></pre><p>输入的左右位置正好相反，而且每个节点的结构都相同，这就是非常适合递归的场景。递归的时候，我们首先需要思考递归的核心逻辑如何实现，这里就是两个节点如何交换，然后就是递归的终止条件，否则递归函数就会进入死循环。</p><p>下面的代码中，设置invertTree函数的终止条件是root是null的时候，也就是如果节点不存在的时候不需要反转。这里我们只用了一行解构赋值的代码就实现了，值得注意的是右边的代码中我们递归调用了inverTree去递归执行，最终实现了整棵树的反转。</p><pre><code class=\"language-javascript\">var invertTree = function(root) {\n  // 递归 终止条件\n  if(root==null) {\n    return root\n  }\n  // 递归的逻辑\n  [root.left, root.right] = [invertTree(root.right), invertTree(root.left)]\n  return root\n}\n</code></pre><p>树形组件的数据结构内部的children可以无限嵌套，处理这种数据结构，就需要使用递归的算法思想。有了上面这个算法题的基础后，我们后面再学习树形组件如何实现就能更加顺畅了。</p><h2>组件实现</h2><p>首先我们进入到Element3的tree文件夹内部，然后找到tree.vue文件。tree.vue 是组件的入口容器，用于接收和处理数据，并将数据传递给 TreeNode.vue；TreeNode.vue 负责渲染树形组件的选择框、标题和递归渲染子元素。</p><p>在下面的代码中，我们提供了el-tree的容器，还导入了el-tree-node进行渲染。tree.vue通过provide向所有子元素提供tree的数据，通过useExpand判断树形结构的展开状态，并且用到了watchEffect去向组件外部通知update:expanded事件。</p><pre><code class=\"language-javascript\">&lt;template&gt;\n  &lt;div class=\"el-tree\"&gt;\n    &lt;el-tree-node v-for=\"child in tree.root.childNodes\" :node=\"child\" :key=\"child.id\"&gt;&lt;/el-tree-node&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport ElTreeNode from './TreeNode.vue'\nconst instance = getCurrentInstance()\nconst tree = new Tree(props.data, props.defaultNodeKey, {\n  asyncLoadFn: props.asyncLoadFn,\n  isAsync: props.async\n})\nconst state = reactive({\n  tree\n})\nprovide('elTree', instance)\nuseTab()\nuseExpand(props, state)\n\nfunction useExpand(props, state) {\n  const instance = getCurrentInstance()\n  const { emit } = instance\n\n  if (props.defaultExpandAll) {\n    state.tree.expandAll()\n  }\n\n  watchEffect(() =&gt; {\n    emit('update:expanded', state.tree.expanded)\n  })\n\n  watchEffect(() =&gt; {\n    state.tree.setExpandedByIdList(props.expanded, true)\n  })\n\n  onMounted(() =&gt; {\n    state.tree.root.expand(true)\n  })\n}\n  \n\n&lt;/script&gt;\n</code></pre><p>然后我们进入到Tree.Node.vue文件中，tree-node组件是树组件的核心，一个TreeNode组件包含四个部分：展开按钮、文本的多选框、每个节点的标题和递归的children子节点。</p><p>我们先来看 TreeNode.vue 的模板基本结构，可以把下面的div标签分成四个部分：el-tree-node__content负责每个树节点的渲染，第一个span就是渲染展开符；el-checkbox组件负责显示复选框，并且绑定了node.isChecked属性；el-node__contentn负责渲染树节点的标题；el-tree__children负责递归渲染el-tree-node节点，组件内部渲染自己，这就是组件递归的写法。</p><pre><code class=\"language-xml\">&lt;div\n    v-show=\"node.isVisable\"\n    class=\"el-tree-node\"\n    :class=\"{\n      'is-expanded': node.isExpanded,\n      'is-current': elTree.proxy.dragState.current === node,\n      'is-checked': node.isChecked,\n    }\"\n    role=\"TreeNode\"\n    ref=\"TreeNode\"\n    :id=\"'TreeNode' + node.id\"\n    @click.stop=\"onClickNode\"\n  &gt;\n    &lt;div class=\"el-tree-node__content\"&gt; \n      &lt;span\n        :class=\"[\n          { expanded: node.isExpanded, 'is-leaf': node.isLeaf },\n          'el-tree-node__expand-icon',\n          elTree.props.iconClass\n        ]\"\n        @click.stop=\"\n          node.isLeaf ||\n            (elTree.props.accordion ? node.collapse() : node.expand())\n        \"&gt;\n      &lt;/span&gt;\n      &lt;el-checkbox\n        v-if=\"elTree.props.showCheckbox\"\n        :modelValue=\"node.isChecked\"\n        @update:modelValue=\"onChangeCheckbox\"\n        @click=\"elTree.emit('check', node, node.isChecked, $event)\"\n      &gt;\n      &lt;/el-checkbox&gt;\n      &lt;el-node-content\n        class=\"el-tree-node__label\"\n        :node=\"node\"\n      &gt;&lt;/el-node-content&gt;\n    &lt;/div&gt;\n      &lt;div\n        class=\"el-tree-node__children\"\n        v-show=\"node.isExpanded\"\n        v-if=\"!elTree.props.renderAfterExpand || node.isRendered\"\n        role=\"group\"\n        :aria-expanded=\"node.isExpanded\"\n      &gt;\n        &lt;el-tree-node\n          v-for=\"child in node.childNodes\"\n          :key=\"child.id\"\n          :node=\"child\"\n        &gt;\n        &lt;/el-tree-node&gt;\n      &lt;/div&gt;\n  &lt;/div&gt;\n</code></pre><p>然后我们看下tree-node中我们需要处理的数据有哪些。下面的代码中，我们先通过inject注入tree组件最完成的配置。然后在点击节点的时候，通过判断elTree的全局配置，去决定点击之后的切换功能，并且在展开和checkbox切换的同时，通过emit对父组件触发事件。</p><pre><code class=\"language-javascript\">const elTree = inject('elTree')\nconst onClickNode = (e) =&gt; {\n  !elTree.props.expandOnClickNode ||\n    props.node.isLeaf ||\n    (elTree.props.accordion ? props.node.collapse() : props.node.expand())\n\n  !elTree.props.checkOnClickNode ||\n    props.node.setChecked(undefined, elTree.props.checkStrictly)\n\n  elTree.emit('node-click', props.node, e)\n  elTree.emit('current-change', props.node, e)\n  props.node.isExpanded\n    ? elTree.emit('node-expand', props.node, e)\n    : elTree.emit('node-collapse', props.node, e)\n}\n\nconst onChangeCheckbox = (e) =&gt; {\n  props.node.setChecked(undefined, elTree.props.checkStrictly)\n  elTree.emit('check-change', props.node, e)\n}\n</code></pre><p>\b<br>\n到这里，树结构的渲染其实就结束了。</p><p>但是有些场景我们需要对树节点的渲染内容进行自定。比如后面这段代码，我们在节点的右侧加上append和delete操作按钮，这种需求在菜单树的管理中很常见。</p><p>这个时候我们节点需要支持内容的自定义，然后我们注册了el-node-content组件。这个组件使用起来非常简单，由于我们还需要支持节点的自定义渲染，所以要把这部分抽离成组件。当slots.default为函数的时候，返回函数的执行内容；或者传递的renderContent是函数的话，也要返回函数执行的结果。</p><pre><code class=\"language-javascript\">import { TreeNode } from './entity/TreeNode'\nimport { inject, h } from 'vue'\n\nrender(ctx) {\n  const elTree = inject('elTree')\n  if (typeof elTree.slots.default === 'function') {\n    return elTree.slots.default({ node: ctx.node, data: ctx.node.data.raw })\n  } else if (typeof elTree.props.renderContent === 'function') {\n    return elTree.props.renderContent({\n      node: ctx.node,\n      data: ctx.node.data.raw\n    })\n  }\n\n  return h('span', ctx.node.label)\n}\n</code></pre><p>这样，用户就可以利用render-content属性传递一个函数的方式，去实现内容的自定义渲染。</p><p>我们还是结合代码例子做理解，下面的代码中用了render-content的方式返回树形结构的渲染结果，render-content传递的函数内部会根据node和data数据，返回对应的标题，并且新增了两个el-button组件。</p><pre><code class=\"language-xml\">&lt;div class=\"custom-tree-container\"&gt;\n  &lt;div class=\"block\"&gt;\n    &lt;p&gt;使用 render-content&lt;/p&gt;\n    &lt;el-tree\n      :data=\"data1\"\n      show-checkbox\n      default-expand-all\n      :expand-on-click-node=\"false\"\n      :render-content=\"renderContent\"\n    &gt;\n    &lt;/el-tree&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n&lt;script&gt;\nfunction renderContent({ node, data }) {\n  return (\n    &lt;span class=\"custom-tree-node\"&gt;\n      &lt;span&gt;{data.label}&lt;/span&gt;\n      &lt;span&gt;\n        &lt;el-button\n          size=\"mini\"\n          type=\"text\"\n          onClick={() =&gt; this.append(node, data)}\n        &gt;\n          Append\n        &lt;/el-button&gt;\n        &lt;el-button\n          size=\"mini\"\n          type=\"text\"\n          onClick={() =&gt; this.remove(node, data)}\n        &gt;\n          Delete\n        &lt;/el-button&gt;\n      &lt;/span&gt;\n    &lt;/span&gt;\n  )\n}\n&lt;/script&gt;\n</code></pre><p>上面的代码会渲染出下面的示意图的效果。<br>\n<img src=\"https://static001.geekbang.org/resource/image/ce/59/cef8cb4d740cfcc0984e546761e33b59.png?wh=1800x940\" alt=\"图片\"></p><p>最后，我们还可以对树实现更多操作方式的支持。</p><p>比如我们可以支持树形结构的拖拽修改、可以把任何任意节点拖拽到其他树形内部、修改整个树形结构的内容。想要实现这些功能，我们就需要监听节点的drag-over、drag-leave等拖拽事件，在drop事件执行的时候，把拖拽的节点数据，复制给拖拽的节点中完成修改即可。这部分代码，同学们可以自行去Element3拓展学习。</p><h2>总结</h2><p>今天的主要内容就讲完啦，我们来总结一下今天学到的内容吧。</p><p>首先我们分析了树形组件的设计需求、我们需要递归组件的形式去实现树形节点的无限嵌套，然后我们通过算法题的形式掌握了递归的概念，这个概念在Vue组件中也是一样的，每个组件返回name后，可以通过这个name在组件内部来调用自己，这样就可以很轻松地实现Tree组件。</p><p>tree组件具体要分成三个组件进行实现。最外层的tree组件负责整个树组件的容器，内部会通过provide方法为子元素提供全局的配置和操作方法。每个tree的配置中的title、expanded、checked树形作为树组件显示的主体内容。children是一个深层嵌套的数组，我们需要用递归组件的方式渲染出完成的树，tree内部的tree-node组件就负责递归渲染出完成的树形结构。</p><p>最后，我们想支持树节点的自定义渲染，这就需要在teree-node内部定制tree-node-content组件，用来渲染用户传递的render-content或者默认的插槽函数。</p><p>树形数据在我们日常开发项目中也很常见，菜单、城市选择、权限等数据都很适合树形结构，学会树形结构的处理，能很好地帮助我们在日常开发中应对更复杂的需求。</p><h2>思考题</h2><p>最后留一个思考题吧。我们的树形组件现在是全部节点的渲染，如果我们有1000个节点要渲染，如何对这个树形节点做性能优化呢？</p><p>欢迎你在评论区分享你的答案，也欢迎你把这一讲的内容分享给你的同事和朋友们，我们下一讲再见。</p>","comments":[{"had_liked":false,"id":326515,"user_name":"一个自闭的人","can_delete":false,"product_type":"c1","uid":1283806,"ip_address":"","ucode":"55CD5FD82670B8","user_header":"https://static001.geekbang.org/account/avatar/00/13/96/de/cc26d1eb.jpg","comment_is_top":false,"comment_ctime":1639550772,"is_pvip":false,"replies":[{"id":"118635","content":"你好，这一讲主要是演示和剖析element3源码，后面会有ts组件库的加餐的","user_name":"作者回复","comment_id":326515,"uid":"1003715","ip_address":"","utype":1,"ctime":1639578498,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"23114387252","product_id":100094401,"comment_content":"element3源码阅读和分析 -.-|||","like_count":6,"discussions":[{"author":{"id":1003715,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/50/c3/0aa50246.jpg","nickname":"花果山大圣","note":"","ucode":"25C0A36D628037","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539026,"discussion_content":"你好，这一讲主要是演示和剖析element3源码，后面会有ts组件库的加餐的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639578498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329405,"user_name":"Geek_d9cd5a","can_delete":false,"product_type":"c1","uid":2840187,"ip_address":"","ucode":"478B33A0CB7075","user_header":"","comment_is_top":false,"comment_ctime":1641338501,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10231273093","product_id":100094401,"comment_content":"大圣老师，能不能加个餐，讲一下虚拟列表","like_count":3},{"had_liked":false,"id":331230,"user_name":"ll","can_delete":false,"product_type":"c1","uid":1296458,"ip_address":"","ucode":"57C5DAC5B51036","user_header":"https://static001.geekbang.org/account/avatar/00/13/c8/4a/3a322856.jpg","comment_is_top":false,"comment_ctime":1642494178,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5937461474","product_id":100094401,"comment_content":"关于思考题：<br>节点渲染的逻辑 v-for=“child in tree.root.childNode”，如果 childNode 的 length, 这里假设 n=10000。这就是渲染问题的产生的原因，因为 n 的数量不 “合理”，什么是合理的 n，显示区域中能容纳 childNode 的数量就是 n 的合理数量。<br>解决方案：<br>1. v-for=“child in deQue”， 这里deQue是个“双端队列”，容量 n 共通过 显示高度&#47;treeNode 高度算出。<br>2. 通过监听显示区域的 “scroll position” 操作进出 deQue 的数据节点。<br>大概就是这么个思路。","like_count":2},{"had_liked":false,"id":327638,"user_name":"KLonILo","can_delete":false,"product_type":"c1","uid":1711330,"ip_address":"","ucode":"C5874B2E6F7653","user_header":"https://static001.geekbang.org/account/avatar/00/1a/1c/e2/8048fff4.jpg","comment_is_top":false,"comment_ctime":1640218963,"is_pvip":false,"replies":[{"id":"119284","content":"可以辅助一下github上的代码看下Element3的代码","user_name":"作者回复","comment_id":327638,"uid":"1003715","ip_address":"","utype":1,"ctime":1640229571,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"5935186259","product_id":100094401,"comment_content":"最近几讲，我得0.75倍速还得停下来自己看几遍还看不懂，听个大概吧","like_count":2,"discussions":[{"author":{"id":1003715,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/50/c3/0aa50246.jpg","nickname":"花果山大圣","note":"","ucode":"25C0A36D628037","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541009,"discussion_content":"可以辅助一下github上的代码看下Element3的代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640229571,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326796,"user_name":"亮","can_delete":false,"product_type":"c1","uid":2832280,"ip_address":"","ucode":"37DACBB8221C50","user_header":"https://static001.geekbang.org/account/avatar/00/2b/37/98/f889105a.jpg","comment_is_top":false,"comment_ctime":1639703471,"is_pvip":true,"replies":[{"id":"118770","content":"我没咋用过element-plus，不过碰见node_modules报错的，首先要做的就是去github 提issue，重要bug维护者会优先修复发版，如果不行的话，就把这个框架从github fork一份到本地，通过npm link的方式维护<br>直接调试node_modules不是特别建议，哪怕现在解决了问题，也需要吧代码维护到git里，并且后续作者修复了还没法合并","user_name":"作者回复","comment_id":326796,"uid":"1003715","ip_address":"","utype":1,"ctime":1639791838,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"5934670767","product_id":100094401,"comment_content":"在引入一个组件后， node_moudules 报错， 比如vue3.0引入element-plus后会报一些 类似这样的错误：Uncaught Error: Cannot find module &#39;vue&#39; at webpackMissingModule (app.js:formatted:2896) at Module..&#47;src&#47;main.js；   网上找了一遍也没找到能的解决方法， 遇到这种情况， 应该从哪些方面入手呢， 直接调试node_modules吗？","like_count":1,"discussions":[{"author":{"id":1003715,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/50/c3/0aa50246.jpg","nickname":"花果山大圣","note":"","ucode":"25C0A36D628037","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539619,"discussion_content":"我没咋用过element-plus，不过碰见node_modules报错的，首先要做的就是去github 提issue，重要bug维护者会优先修复发版，如果不行的话，就把这个框架从github fork一份到本地，通过npm link的方式维护\n直接调试node_modules不是特别建议，哪怕现在解决了问题，也需要吧代码维护到git里，并且后续作者修复了还没法合并","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639791838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332206,"user_name":"把西红柿变成番茄_o","can_delete":false,"product_type":"c1","uid":1784508,"ip_address":"","ucode":"A57BF0C4E81AEC","user_header":"https://static001.geekbang.org/account/avatar/00/1b/3a/bc/0854fd72.jpg","comment_is_top":false,"comment_ctime":1643095659,"is_pvip":false,"replies":[{"id":"121369","content":"可以具体说说你疑惑的问题不～","user_name":"编辑回复","comment_id":332206,"uid":"1501385","ip_address":"","utype":2,"ctime":1643097792,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1643095659","product_id":100094401,"comment_content":"这几节完了啊，对于新手全听不懂，对于高手估计都会了吧，有点尴尬","like_count":0,"discussions":[{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548246,"discussion_content":"可以具体说说你疑惑的问题不～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643097792,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":8}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330272,"user_name":"Hurrah! 🔥","can_delete":false,"product_type":"c1","uid":2828932,"ip_address":"","ucode":"FA81F671506F1A","user_header":"https://static001.geekbang.org/account/avatar/00/2b/2a/84/26530aac.jpg","comment_is_top":false,"comment_ctime":1641889536,"is_pvip":false,"replies":[{"id":"120843","content":"你好，Tree的代码在这里<br>https:&#47;&#47;github.com&#47;hug-sun&#47;element3&#47;blob&#47;master&#47;packages&#47;element3&#47;packages&#47;tree&#47;Tree.vue","user_name":"作者回复","comment_id":330272,"uid":"1003715","ip_address":"","utype":1,"ctime":1642338654,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1641889536","product_id":100094401,"comment_content":"请问，这个部分代码在哪里？","like_count":0,"discussions":[{"author":{"id":1003715,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/50/c3/0aa50246.jpg","nickname":"花果山大圣","note":"","ucode":"25C0A36D628037","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546546,"discussion_content":"你好，Tree的代码在这里\nhttps://github.com/hug-sun/element3/blob/master/packages/element3/packages/tree/Tree.vue","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642338654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326424,"user_name":"费城的二鹏","can_delete":false,"product_type":"c1","uid":1101293,"ip_address":"","ucode":"DE768A0CC3053D","user_header":"https://static001.geekbang.org/account/avatar/00/10/cd/ed/825d84ee.jpg","comment_is_top":false,"comment_ctime":1639527758,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639527758","product_id":100094401,"comment_content":"如果渲染节点比较多，可以考虑重用节点，用屏幕区域的少量节点复用的方式，随着滚动动态展示对应节点。","like_count":0},{"had_liked":false,"id":326419,"user_name":"海阔天空","can_delete":false,"product_type":"c1","uid":1327016,"ip_address":"","ucode":"16C87A0052A08B","user_header":"https://static001.geekbang.org/account/avatar/00/14/3f/a8/8da58e53.jpg","comment_is_top":false,"comment_ctime":1639525521,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639525521","product_id":100094401,"comment_content":"树形组件在实际项目中懒加载的模式用得比较多。teree-node 内部定制 tree-node-content 组件基本上可以满足我们对树的操作了。","like_count":1},{"had_liked":false,"id":326417,"user_name":"joker","can_delete":false,"product_type":"c1","uid":1501088,"ip_address":"","ucode":"4305206A1FE5EC","user_header":"https://static001.geekbang.org/account/avatar/00/16/e7/a0/9a962a74.jpg","comment_is_top":false,"comment_ctime":1639524641,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1639524641","product_id":100094401,"comment_content":"能不能加个餐～讲讲简历","like_count":0}]}