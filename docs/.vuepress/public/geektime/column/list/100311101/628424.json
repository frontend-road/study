{"id":628424,"title":"29｜前台页面的渲染方式：如何设计前台页面的渲染策略？","content":"<p>你好，我是杨文坚。</p><p>经过前面几节课的学习，在运营搭建平台的页面功能维度中，我们完成了页面发布流程和页面回滚措施，可以放心地把页面发布到生产环境，提供给让外部客户使用。下一步，就是进行前台页面的渲染操作了，这也是运营搭建平台中，页面功能维度的最后一个环节——“页面渲染方式”。</p><p>可能你会有困惑，之前我们学过的“<a href=\"https://time.geekbang.org/column/article/626898\">页面的编译和运行</a>”里，也讲了页面渲染策略，为什么还有一节课讲解“页面渲染方式”呢？</p><p>有这个疑问很正常，因为我们之前学的都是一些分散的技术点，比如Vue.js的服务端渲染、Vue.js组件的多种模块格式等等，这些技术散点都是你的知识储备。今天，我们就要把这些知识储备，通过实际项目应用实践，有机结合起来，应用到搭建平台的前台场景中。</p><p>那么“页面渲染方式”这个页面维度的功能模块，在前台服务上，我们如何进行设计和实现呢？</p><h2>1. 设计前台页面的链接</h2><p>页面渲染的第一件事，就是在要在浏览器输入页面的URL，也就是页面的链接，所以我们今天第一件事就是设计页面的链接。</p><p>前台页面的链接，是面向外部用户的，考虑到用户的传播和使用，我们要尽量让链接简单一些，后续生成的链接二维码图片也会精简一些。</p><p>一般我们会这么设计URL。</p><pre><code class=\"language-markdown\">/*\n&nbsp;https://${域名}/p/${页面uuid}\n&nbsp;例如：\n*/\nhttps://xxx.xx/p/10001000-aaaa-bbbb-cccc-ddddeeee0000\n</code></pre><!-- [[[read_end]]] --><p>你可能会觉得页面uuid太长了，导致URL太长，影响页面链接传播效果。我们可以换种uuid生成方式，在后台服务创建页面生成uuid时候，换一种简单的随机字符串生成方法。</p><p>例如，随机生成只有英文和数字的短字符串。</p><pre><code class=\"language-typescript\">// 随机生成字符串，包括0-9a-z的短字符串内容\nMath.random().toString(36).substring(2)\n</code></pre><p>但是，如果业务搭建页面非常频繁，生产出来页面的数量非常庞大，用比较复杂的uuid还是很有必要。因为复杂的uuid能避免重复，从而避免带来数据操作的污染或者干扰。</p><p><strong>要特别注意，URL里不能用页面在数据库的自增数字id。</strong>因为自增数字id容易被“灰黑产”利用，“灰黑产”可以按自增数字拼接页面URL，用“爬虫”抓取所有页面内容。这也算是一种变相的“拖库”行为，容易造成大量页面数据泄露。</p><p>现在，我们有了页面URL，客户就可以在浏览里通过URL访问页面了，那么接下来就要进入页面渲染环节了。</p><h2>2. 设计前台页面的浏览器端渲染</h2><p>我们之前学过Vue.js页面的浏览器端渲染（客户端渲染）和服务端渲染原理，CSR和SSR。页面大部分功能，都是基于浏览器端渲染来实现的，服务端渲染的作用更多是减少白屏时间和支持SEO。</p><p>所以，我们优先做浏览器端渲染的技术设计和实现。</p><p>首先，回顾一下“<a href=\"https://time.geekbang.org/column/article/620893\">物料组件多种模块格式</a>”和“<a href=\"https://time.geekbang.org/column/article/626898\">页面编译和运行</a>”这两节课，我们可以总结出三种浏览器端渲染方式。</p><ul>\n<li>Bundle文件渲染</li>\n<li>基于ESM模块的动态加载渲染</li>\n<li>基于AMD模块的动态加载渲染</li>\n</ul><p>接下来结合前面学过的知识点，我们基于前台服务，从前端到服务端，设计这三种浏览器端渲染的技术方案。</p><p>第一个浏览器渲染方式是Bundle文件渲染。</p><p><img src=\"https://static001.geekbang.org/resource/image/d4/6b/d464f7a0e13efe57008207b5dab81a6b.jpg?wh=4000x2678\" alt=\"\"></p><p>我画了步骤图，Bundle文件渲染分成四步。</p><ul>\n<li>第一步：浏览器发起前台服务请求。</li>\n<li>第二步：服务器接受请求，解析出页面uuid。</li>\n<li>第三步：数据库查找页面数据，判断页面是否存在，如果存在就拼接对应的HTML结果。</li>\n<li>第四步：浏览器执行和渲染服务端响应回来的HTML结果。</li>\n</ul><p>第二个浏览器渲染方式是ESM动态渲染方式。</p><p><img src=\"https://static001.geekbang.org/resource/image/60/76/605617c9722dd89cf6eede85778d6576.jpg?wh=4000x2678\" alt=\"\"></p><p>Bundle文件渲染分成五个步骤。</p><ul>\n<li>第一步：浏览器发起前台服务请求。</li>\n<li>第二步：服务器接受请求，解析出页面uuid。</li>\n<li>第三步：数据库查找页面数据，判断页面是否存在，如果存在就把页面数据埋在HTML全局变量中。</li>\n<li>第四步：浏览器执行和渲染服务端响应回来的HTML结果。</li>\n<li>第五步：运行ESM运行时来异步加载ESM模块，动态加载物料渲染页面。</li>\n</ul><p>第三个浏览器渲染方式，AMD动态渲染方式，具体步骤和ESM基本一样，只是在最后一步中，动态加载物料组件资源的方式，从纯ESM动态加载渲染，变成基于RequireJS，加载AMD物料组件模块，进行动态渲染。</p><p>有了三种浏览器端渲染方式，接下来就要灵活利用这三种渲染方式，构建页面渲染策略。</p><p>还记得我们之前设计的“页面渲染策略”吗？当时的策略是优先进行Bundle文件渲染，提升用户体验，如果页面报错导致不可用，就进入降级渲染逻辑，按客户浏览器的兼容情况选择ESM或AMD的渲染方式。</p><p>今天我们就来实际实现一下。</p><h2>3. 做前台渲染测试的落地实现</h2><p>根据之前课程页面渲染策略的理论技术方案，进入降级渲染逻辑的部分，我稍作调整，画了一张步骤图。</p><p><img src=\"https://static001.geekbang.org/resource/image/a2/c0/a2bbeb3075c99f32e797be6d758e4dc0.jpg?wh=4000x2678\" alt=\"\"></p><p>渲染策略分成三个步骤。</p><ul>\n<li>第一步：默认Bundle文件渲染，监听页面错误异常。</li>\n<li>第二步：渲染提示用户，选择是否降级渲染。</li>\n<li>第三步：根据浏览器环境，选择ESM或AMD渲染方式。</li>\n</ul><p>第一步，默认Bundle文件渲染，监听页面错误异常。<strong>核心操作是要监听页面错误，我们可以分成“Vue.js应用内部错误”和“其它错误”。</strong></p><p>在Vue.js应用的内部，可以通过Vue.js官方提供的API（app.config.errorHandler）来捕获错误异常。</p><pre><code class=\"language-typescript\">app.config.errorHandler = (err, instance, info) =&gt; {\n&nbsp; console.log('捕获到Vue.js内部报错: ', err);\n&nbsp; // 处理后续的页面降级处理&nbsp;\n}\n</code></pre><p>其它错误，可以通过监听window的错误事件。</p><pre><code class=\"language-typescript\">window.addEventListener('error', (err) =&gt; {\n&nbsp; console.log('捕获到其它报错: ', err);\n&nbsp; // 处理后续的页面降级处理&nbsp;\n});\n</code></pre><p>第二步，渲染出错误提示，让客户选择是否要降级。看课程代码案例的截图。</p><p><img src=\"https://static001.geekbang.org/resource/image/8d/c4/8da6e34d5ace7747b20bd60d04cdd2c4.png?wh=1920x890\" alt=\"图片\"></p><p>你可能会有疑问，<strong>为什么要让客户自行选择降级呢？为什么不能直接用代码处理强制降级呢？</strong></p><p>这是因为客户遇到页面出现错误的时候，程序员不一定能第一时间得到反馈和处理问题。与此同时，客户遇到页面错误后，不一定影响页面主要功能的使用，这时候强制降级可能会适得其反。</p><p>第三步，根据浏览器兼容情况，选择和执行ESM或AMD的渲染方式，对物料组件逐个动态加载，以及隔离组件独立渲染。</p><p>如何判断页面是否支持ESM呢？这里我们可以基于impormap，来用执行import操作，检测是否支持ESM模块。</p><pre><code class=\"language-typescript\">// packages/portal-server/src/public/static/page-helper.js\nlet canSupportESM = true;\ntry {\n  // 用import()动态加载importmap指向的vue模块\n  import('vue').then(() =&gt; {\n    canSupportESM = true;\n  }).catch((err) =&gt; {\n    console.warn(err);    \n    // 如果出错，就证明当前不支持ESM\n    canSupportESM = false;\n  });\n} catch (err) {\n  console.warn(err);  \n  // 如果出错，就证明当前不支持ESM\n  canSupportESM = false;\n}\n</code></pre><p>课程案例是直接在第二步时候就判断降级选择方案，然后生成对应的URL，提供给用户触发降级渲染页面时，跳转到降级页面使用。</p><p>进行页面降级跳转的时候，进入ESM或AMD降级渲染的页面链接，这个链接其实跟原来的Bundle渲染页面是同一个URL路径Path，只不过携带的参数不同。然后，服务端根据这个参数做对应的服务端处理，输出相应渲染方式的HTML代码，携带不同的JS和CSS静态资源链接。</p><p>你可以看对应截图。同一个页面URL的Bundle渲染结果。</p><p><img src=\"https://static001.geekbang.org/resource/image/66/5c/66e62a843660583461af27295769d35c.png?wh=1920x1109\" alt=\"图片\"></p><p>基于同一个页面URL路径，带上参数“runModule=amd”的渲染结果。</p><p><img src=\"https://static001.geekbang.org/resource/image/37/47/3730c47c03581df0cb1ab1c44f683e47.png?wh=1920x1109\" alt=\"图片\"></p><p>基于同一个页面URL路径，带上参数“runModule=esm”的渲染结果。</p><p><img src=\"https://static001.geekbang.org/resource/image/48/8f/48eccc3bdf7e1c6a2b0d672de1b4008f.png?wh=1920x1202\" alt=\"图片\"></p><p>现在，我们完成了浏览器渲染和页面渲染策略的技术实现。接下来就要进入页面的服务端渲染了。</p><h2>4. 设计和实现前台页面的服务端渲染</h2><p>服务端渲染主要是解决白屏等待问题和SEO需求，其中，最重要的是SEO需求。所以做服务端渲染之前，我们要考虑是否有SEO需求，如果有需求，就要必须要用服务端渲染。</p><p>回忆我们学过的Vue.js服务端渲染，我重新画了一张技术步骤图。</p><p><img src=\"https://static001.geekbang.org/resource/image/e7/e3/e7c2a8cdca2f3349520433b040be6ae3.jpg?wh=4000x2678\" alt=\"\"></p><p>服务端渲染可以分成四个步骤。</p><ul>\n<li>第一步，浏览器发起前台服务请求。</li>\n<li>第二步，服务器接受请求，解析出页面uuid。</li>\n<li>第三步，数据库查找页面数据，根据页面布局数据，获取物料组件的CommonJS模块，将其动态编译组装成页面HTML字符串。</li>\n<li>第四步，浏览器执行和渲染服务端响应回来的HTML结果。</li>\n</ul><p>具体技术实现我们已经学过了，就不再重复（定制化服务端渲染的实现，你可以查看代码案例，在目录：packages/portal-server/src/service/page-app.ts）。</p><p>前面提到，有SEO需求，我们必须选择用服务端渲染。那么页面白屏等待问题，就不是选择服务端渲染的必要条件吗？答案是否定的，服务端渲染可以解决白屏等待时间，但是不一定能完全解决，因为服务端渲染存在一些隐患。</p><h2>服务端渲染存在哪些隐患</h2><p>课程中，我们用的是Node.js来开发项目的服务端功能。那么基于Node.js在服务端，做运营搭建平台的服务端渲染，会有哪些隐患呢？</p><p>首先，页面是由物料组件组成的，而且物料组件不是固定的，是动态的。所以每次做服务端渲染，都需要在Node.js环境里做动态的组件编译，生成HTML结果。</p><p>其次，一个页面可以存在多个物料，可能几个，可能几十个。那么Node.js服务在组装页面HTML代码的时候，就要对每个物料Vue.js组件，传入组件的数据源，编译成HTML代码。这个编译过程是外部客户访问页面时候进行的，也需要时间执行操作。页面使用物料一旦变多，服务端动态编译HTML时间就变长。</p><p>所以，这也是我们刚刚说的<strong>“服务端渲染可以解决白屏等待时间，但是不一定能完全解决”，反而可能因为编译物料组件过多，白屏时间更长</strong>。</p><p>总的来说，Node.js做Vue.js的全栈服务，可能存在的隐患大致可以分成三点。</p><ul>\n<li>编译复杂组件耗性能。Node.js服务，处理复杂物料组件，比较耗性能。</li>\n<li>组装编译页面耗性能。如果页面布局复杂，物料组件依赖太多，Node.js处理页面的时候，会占用较多的CPU和内存性能。</li>\n<li>服务端运行Vue.js不可预测的错误。物料组件的CommonJS模块格式，不一定能百分百在Node.js服务端处理成HTML，可能组件里存在浏览器API的使用，导致在服务器运行时候中报错。</li>\n</ul><p>不过，解决办法也是有的，这三点隐患其实<strong>都指向一个问题，客户访问页面的时候，要动态“编译组件成HTML”和“组装页面成HTML”</strong>，所以，我们可以前置这个步骤，放在后台服务中，在页面发布流程中，就把页面的服务端HTML直接编译出来，放到CDN给前台服务使用。</p><p>具体实现思路也很简单。</p><p>解决动态编译组件耗Node.js性能问题，可以在后台服务发布流程中，前置编译成HTML文件，发布到CDN或其他静态资源服务上，前台渲染直接使用这个已经编译好的HTML。解决动态组装页面耗Node.js性能，也可以按照同样的物料组件的方式，前置编译HTML文件结果。</p><h2>总结</h2><p>今天我们围绕着“页面的渲染方式”，学习了如何在客户视角实现搭建页面的渲染。</p><p>首先，我们整合了三种页面渲染方式：Bundle文件渲染、基于ESM模块的动态加载渲染和基于AMD模块的动态加载渲染。</p><p>在具体实现方案上，页面渲染，优先使用Bundle渲染，如果出现异常，就提醒客户，让客户自行选择是否降级处理。“让客户选择降级”是一种折中的方案，不是绝对方案。你在实际工作中，可以根据自己业务需求，选择是折中方案或者强制降级方案。</p><p>另外，服务端渲染不是万能的，不能绝对解决白屏等待问题。服务端渲染的隐患，基本来自Vue.js组件编译HTML的操作过程，比较难发现，也很难根除，所以，最好解决办法是把隐患前置到“企业内部页面发布阶段”，前置服务端编译组件成HTML的过程，及早发现问题和解决问题。</p><p>你应该能发现，今天讲的很多技术方案都是基于以往课程里学过的技术点。其实，技术的成长，就是要依靠长期的“技术储备”和“技术实践”。当你遇到任何技术问题，都能想到使用以前学过的“技术点”，并且比以前更加得心应手地设计技术方案，实现技术功能。那么恭喜你，你的技术已经得到成长了。</p><h2>思考题</h2><p>课程中，前台服务的浏览器端渲染和服务端渲染，都是基于Node.js服务的。假设随着业务发展，我们要对前后台服务架构进行分离，面向客户的前台服务要变成Java开发和维护，面向内部员工的后台保持用Node.js。</p><p>那么如何保证服务端渲染的功能，从Node.js环境平滑转换支持Java服务端的服务端渲染？</p><p>期待看到你的思考，参与讨论。我们下节课见。</p><h3><a href=\"https://github.com/FE-star/vue3-course/tree/main/chapter/29-30\">完整的代码在这里</a></h3>","neighbors":{"left":{"article_title":"28｜前台页面版本化管理：如何实现搭建页面的迭代策略？","id":626944},"right":{"article_title":"30｜前台页面的性能优化：如何实现前台页面的性能优化？","id":628441}},"comments":[{"had_liked":false,"id":368713,"user_name":"Akili","can_delete":false,"product_type":"c1","uid":1388437,"ip_address":"云南","ucode":"286D58069F7D86","user_header":"https://static001.geekbang.org/account/avatar/00/15/2f/95/db8dedde.jpg","comment_is_top":false,"comment_ctime":1676608292,"is_pvip":false,"replies":[{"id":134952,"content":"您好，后台管理的前端开发，可以先分析出重复工作内容，然后用技术工具化的方式解决。比如：\n1. 如果是经常重复开发表单，可以抽象出一个公共的动态表单组件，输入JSON就能按照自己业务逻辑渲染表单。\n2. 如果是经常重复开发新页面，新应用，可以抽象出通用的页面和应用的生成脚本，定制一个CLI工具，用脚本方式批量来生产代码。\n\n解决重复工作，核心是要找出重复的规律，用技术手段来实现重复逻辑。","user_name":"作者回复","user_name_real":"编辑","uid":3217031,"ctime":1678524059,"ip_address":"浙江","comment_id":368713,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"老师，请教一个问题，我们现在涉及的都是后台管理系统开发，遇到的问题就是一直在重复的工作，对自己也没有提升，有没有什么方案避免这样的工作方式？谢谢你","like_count":0,"discussions":[{"author":{"id":3217031,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TZnA0PlXExlp9byxOxCeOG6ia0ykwfpxqAq2vslTzL1z5ibTBsgf1nYx0bUXgrOTnSOnmdXQZZibYx9tRSPHFjibPQ/132","nickname":"文坚老师","note":"","ucode":"4E0C838B2A3725","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608569,"discussion_content":"您好，后台管理的前端开发，可以先分析出重复工作内容，然后用技术工具化的方式解决。比如：\n1. 如果是经常重复开发表单，可以抽象出一个公共的动态表单组件，输入JSON就能按照自己业务逻辑渲染表单。\n2. 如果是经常重复开发新页面，新应用，可以抽象出通用的页面和应用的生成脚本，定制一个CLI工具，用脚本方式批量来生产代码。\n\n解决重复工作，核心是要找出重复的规律，用技术手段来实现重复逻辑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678524059,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1388437,"avatar":"https://static001.geekbang.org/account/avatar/00/15/2f/95/db8dedde.jpg","nickname":"Akili","note":"","ucode":"286D58069F7D86","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":3217031,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TZnA0PlXExlp9byxOxCeOG6ia0ykwfpxqAq2vslTzL1z5ibTBsgf1nYx0bUXgrOTnSOnmdXQZZibYx9tRSPHFjibPQ/132","nickname":"文坚老师","note":"","ucode":"4E0C838B2A3725","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":608805,"discussion_content":"谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678673824,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":608569,"ip_address":"云南","group_id":0},"score":608805,"extra":""}]},{"author":{"id":1354850,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ac/62/37912d51.jpg","nickname":"东方奇骥","note":"","ucode":"DEE7085F7E55A4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608405,"discussion_content":"做个低代码搭建啊，配置化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678430564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1388437,"avatar":"https://static001.geekbang.org/account/avatar/00/15/2f/95/db8dedde.jpg","nickname":"Akili","note":"","ucode":"286D58069F7D86","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1354850,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ac/62/37912d51.jpg","nickname":"东方奇骥","note":"","ucode":"DEE7085F7E55A4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608806,"discussion_content":"谢谢您\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678673844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":608405,"ip_address":"云南","group_id":0},"score":608806,"extra":""}]}]},{"had_liked":false,"id":394703,"user_name":"ifelse","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1727772209,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":3,"score":2,"product_id":100311101,"comment_content":"学习打卡","like_count":0},{"had_liked":false,"id":391506,"user_name":"Geek_12e8fd","can_delete":false,"product_type":"c1","uid":2728813,"ip_address":"浙江","ucode":"4BC4A879CB5AFE","user_header":"","comment_is_top":false,"comment_ctime":1718351677,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"在将前台服务的服务端渲染从 Node.js 平滑转换到 Java 服务端时，需要确保渲染逻辑、数据模型、模板引擎以及可能的缓存机制都能在新的环境中得到支持。以下是一些关键的步骤和考虑因素：\n\n分析现有服务端渲染逻辑：\n理解当前 Node.js 服务端渲染的工作流程，包括数据准备、模板渲染、缓存等。\n确定哪些部分可以直接移植到 Java，哪些部分需要重写或调整。\n选择或开发 Java 中的模板引擎：\nNode.js 中常用的模板引擎如 Pug（Jade）、EJS、Nunjucks 等在 Java 中可能没有直接对应的实现。\n你可能需要选择一个现有的 Java 模板引擎，如 Thymeleaf、FreeMarker、Velocity 等，或者开发一个自定义的模板引擎来匹配现有的模板语法。\n数据模型与接口对齐：\n确保 Java 后端与 Node.js 后端使用相同的数据模型，或者至少能够提供相同的数据接口。\n可能需要对现有的 API 进行调整，以便 Java 后端能够访问所需的数据。\n实现服务端渲染逻辑：\n在 Java 后端中重写或实现服务端渲染逻辑。\n这可能包括数据获取、模板渲染、错误处理等部分。\n缓存机制：\n如果 Node.js 后端使用了缓存来提高性能，确保 Java 后端也实现了类似的缓存机制。\n可以考虑使用 Redis、Memcached 或其他缓存解决方案来共享缓存数据。\n测试与部署：\n在开发过程中进行详细的测试，确保新的 Java 后端能够正确地渲染页面并与前端交互。\n逐步部署新的 Java 后端，并监控生产环境中的性能和用户反馈。\n持续集成与持续部署（CI&#47;CD）：\n建立或更新 CI&#47;CD 流程，以便能够快速、可靠地部署新的 Java 后端。\n文档与培训：\n编写详细的文档，解释新的 Java 后端的工作原理、配置选项以及维护指南。\n对开发团队进行培训，确保他们熟悉新的后端架构和工作流程。\n监控与日志记录：\n实施监控和日志记录机制，以便能够及时发现和解决问题。\n确保新的 Java 后端与现有的监控和日志记录系统兼容。\n性能优化：\n在将服务端渲染迁移到 Java 后端后，可能需要进行性能优化以确保与 Node.js 后端相当的性能。\n这可能包括调整 JVM 设置、优化数据库访问、使用异步处理等技术。\n安全性考虑：\n确保新的 Java 后端遵循最佳的安全实践，包括输入验证、防止跨站脚本攻击（XSS）、跨站请求伪造（CSRF）等。\n通过遵循这些步骤和考虑因素，你可以将服务端渲染功能从 Node.js 平滑转换到 Java 服务端。需要注意的是，这个过程可能需要一定的时间和资源投入，因此建议在进行迁移之前进行充分的规划和准备。","like_count":0}]}