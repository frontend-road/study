{"id":464659,"title":"22 | 压测平台：如何解决 GoReplay 动态数据关联？","content":"<p>你好，我是高楼。</p><p>在第 6 讲，我们说过目前主流的流量回放工具都无法轻易解决 session 的问题，所以从系统安全的角度来说，工具需要做对应的改造。</p><p>这节课，我们来聊一下 GoReplay 如何通过改造解决回放过程中动态数据关联的问题。</p><h2>关联是什么？</h2><p>我们可以把关联简单地理解为把服务端返回的某个值，传递给后续的调用使用。我们可以在很多场景用到它。举个例子，我们常见的“Session ID”就是一个典型的需要关联的数据。它需要在交互过程中标识一个客户端身份，这个身份要在后续的调用中一直存在，否则服务端就不认识这个客户端了。</p><p>对每一个性能测试工具来说，关联是应该具备的基本功能，GoReplay 也不例外。</p><p>但是有很多新手同学对关联的逻辑并不是十分理解，甚至有人觉得关联和参数化（流量数据）是一样的，因为它们用的都是动态的数据，并且关联过来的数据也可以用到参数化（流量数据）中。其实，这二者还是有所不同的，因为关联的数据后续脚本中会用到，但参数化就不会。</p><p>现在有很多全链路压测都是由单接口基准创建的，这样一来，关联就用得比较少。因为接口级的基准场景都是一发一收就结束了，不需要将数据保存下来再发送出去。</p><p>那么正常情况下，什么样的场景需要关联呢？一般情况下， 它们需要满足下面几个条件：</p><!-- [[[read_end]]] --><ol>\n<li>数据是由服务器端生成的；</li>\n<li>数据在每一次请求时都是动态变化的；</li>\n<li>数据在后续的请求中需要再发送出去。</li>\n</ol><p>你可以通过这张示意图加深一下理解：</p><p><img src=\"https://static001.geekbang.org/resource/image/6f/62/6f28747510866b140821bfd83ea9bb62.jpg?wh=1264x802\" alt=\"图片\"></p><p>好了，我们知道了关联的基本概念和适用场景，那么在 GoReplay 中又如何改造呢？</p><p>作为一款流量回放工具，我们知道GoReplay的核心原理就是基于流量文件去倍数回放请求。很显然，这个流量文件是个死的东西，是不能动态参数数据的，那么，我们又该怎么办呢？</p><p>这时候，我们就需要搬出 GoReplay 的中间件了。</p><h2>中间件是什么？</h2><p><a href=\"https://github.com/buger/goreplay/wiki/middleware\">中间件</a>（ <a href=\"https://github.com/buger/goreplay/wiki/middleware\">Middleware</a> ）是一个在 STDIN（标准输入） 接收请求、响应 payload （有效请求负载）并在 STDOUT（标准输出） 发出修改请求的程序。你可以在中间件上实现任何自定义逻辑，比如认证、复杂的重写和筛选请求等。</p><p>通过传入 Middleware 参数，我们可以发送命令给 GoReplay，GoReplay 会拉起一个进程执行这个命令。在录制过程中，GoReplay 通过获取进程的 STDIN 和 STDOUT 与输入输出插件进程进行通信，中间件内部逻辑为 STDERR，数据流向大致如下：</p><pre><code class=\"language-bash\">                   Original request      +--------------+\n+-------------+----------STDIN----------&gt;+              |\n|  Gor input  |                          |  Middleware  |\n+-------------+----------STDIN----------&gt;+              |\n                   Original response     +------+---+---+\n                                                |   ^\n+-------------+    Modified request             v   |\n| Gor output  +&lt;---------STDOUT-----------------+   |\n+-----+-------+                                     |\n      |                                             |\n      |            Replayed response                |\n      +------------------STDIN-----------------&gt;----+\n</code></pre><p>需要注意的是，如果希望记录原始响应和回放响应，不要忘记添加 <strong>– output-http-track-response</strong> 和 <strong>– input-raw-track-response</strong> 参数。</p><p>GoReplay 支持用任何语言编写中间件的协议，同时中间件程序还需要格外注意一点，就是中间件和 Gor 的所有通信都是异步，因此，我们不能保证原始请求和响应消息会一个接一个地出现。如果业务逻辑依赖于原始响应或回放响应，那么中间件应用程序就应该处理好状态，也就是要做好动态数据的处理动作。</p><p>为了简化中间件的功能实现，官方为 <a href=\"https://github.com/buger/goreplay/tree/master/middleware\">node.js </a>和 Go (即将推出)提供了包。</p><h2>如何使用中间件？</h2><p>那么，应该怎样使用中间件呢？</p><p>下面就是一个简单的使用 bash echo 中间件的示例，我们用它来打印对应的 payload 类型：</p><pre><code>#!/usr/bin/env bash\n#\n# `xxd` utility included into vim-common package\n# It allow hex decoding/encoding\n# \n# This example may broke if you request contains `null` string, you may consider using pipes instead.\n# See: https://github.com/buger/gor/issues/309\n# \n\nfunction log {\n    # Logging to stderr, because stdout/stdin used for data transfer\n    # 记录到 stderr，因 为 stdout/stdin 用于数据传输\n    &gt;&amp;2 echo &quot;[DEBUG][ECHO] $1&quot;\n}\n\nwhile read line; do\n    decoded=$(echo -e &quot;$line&quot; | xxd -r -p)\n\n    header=$(echo -e &quot;$decoded&quot; | head -n +1)\n    payload=$(echo -e &quot;$decoded&quot; | tail -n +2)\n\n    encoded=$(echo -e &quot;$header\\n$payload&quot; | xxd -p | tr -d &quot;\\\\n&quot;)\n\n    log &quot;&quot;\n    log &quot;===================================&quot;\n\n    case ${header:0:1} in\n    &quot;1&quot;)\n        log &quot;Request type: Request&quot;\n        ;;\n    &quot;2&quot;)\n        log &quot;Request type: Original Response&quot;\n        ;;\n    &quot;3&quot;)\n        log &quot;Request type: Replayed Response&quot;\n        ;;\n    *)\n        log &quot;Unknown request type $header&quot;\n    esac\n    echo &quot;$encoded&quot;\n\n    log &quot;===================================&quot;\n\n    log &quot;Original data: $line&quot;\n    log &quot;Decoded request: $decoded&quot;\n    log &quot;Encoded data: $encoded&quot;\ndone;\n</code></pre><p>这里我们使用【会员登录接口】来做演示。</p><p><img src=\"https://static001.geekbang.org/resource/image/yy/18/yy0d0a5afb7e1a295c0e10b94b989518.png?wh=1282x941\" alt=\"图片\"></p><p>首先，通过指定 Middleware 可执行文件的命令，也就是使用 Middleware 参数在 GoReplay 启用中间件功能：</p><pre><code class=\"language-bash\"> sudo ./goreplay --input-raw :8081 --middleware \"./echo.sh\" --output-http \"http://staging.server\"\n</code></pre><p>接下来，我们通过 Postman 对【会员登录】接口做一次测试。</p><p><img src=\"https://static001.geekbang.org/resource/image/0c/c4/0cd47ef4bfd1b47513bc36d312db33c4.png?wh=633x479\" alt=\"图片\"></p><p>通过控制台我们看到，中间件程序已经成功把经过的流量信息全部打印出来了。</p><pre><code class=\"language-bash\">Interface: en0 . BPF Filter: ((tcp dst port 8081) and (dst host fe80::8f6:ee40:ebd1:bec or dst host 192.168.3.58))\nInterface: awdl0 . BPF Filter: ((tcp dst port 8081) and (dst host fe80::50a5:ceff:feeb:47e3))\nInterface: llw0 . BPF Filter: ((tcp dst port 8081) and (dst host fe80::50a5:ceff:feeb:47e3))\nInterface: utun0 . BPF Filter: ((tcp dst port 8081) and (dst host fe80::d9a3:ab1b:f8e4:4de))\nInterface: utun1 . BPF Filter: ((tcp dst port 8081) and (dst host fe80::c2a0:19a0:9d9d:6699))\nInterface: utun2 . BPF Filter: ((tcp dst port 8081) and (dst host fe80::771:4985:8642:7857))\nInterface: utun3 . BPF Filter: ((tcp dst port 8081) and (dst host fe80::4a93:e598:6e37:37b3))\nInterface: lo0 . BPF Filter: ((tcp dst port 8081) and (dst host 127.0.0.1 or dst host ::1 or dst host fe80::1))\n2021/11/14 17:16:34 [PPID 8021 and PID 8022] Version:1.3.0\n[DEBUG][ECHO] \n[DEBUG][ECHO] ===================================\n[DEBUG][ECHO] Request type: Request\n[DEBUG][ECHO] ===================================\n[DEBUG][ECHO] Original data: 3120636239663166393130303030303030313535353939393337203136333638383133393937363036333730303020300a504f5354202f61646d696e2f6c6f67696e20485454502f312e310d0a436f6e74656e742d547970653a206170706c69636174696f6e2f6a736f6e0d0a417574686f72697a6174696f6e3a20747275650d0a557365722d4167656e743a20506f73746d616e52756e74696d652f372e32382e340d0a4163636570743a202a2f2a0d0a506f73746d616e2d546f6b656e3a2034666132356536622d666434362d346539362d386166362d6636633562613066303033660d0a486f73743a206c6f63616c686f73743a383038310d0a4163636570742d456e636f64696e673a20677a69702c206465666c6174652c2062720d0a436f6e6e656374696f6e3a206b6565702d616c6976650d0a436f6e74656e742d4c656e6774683a2035320d0a0d0a7b0a202020202270617373776f7264223a2022313233343536222c0a2020202022757365726e616d65223a202274657374220a7d\n[DEBUG][ECHO] Decoded request: 1 cb9f1f910000000155599937 1636881399760637000 0\nPOST /admin/login HTTP/1.1\nContent-Type: application/json\nAuthorization: true\nUser-Agent: PostmanRuntime/7.28.4\nAccept: */*\nPostman-Token: 4fa25e6b-fd46-4e96-8af6-f6c5ba0f003f\nHost: localhost:8081\nAccept-Encoding: gzip, deflate, br\nConnection: keep-alive\nContent-Length: 52\n\n{\n    \"password\": \"123456\",\n    \"username\": \"test\"\n}\n[DEBUG][ECHO] Encoded data: 3120636239663166393130303030303030313535353939393337203136333638383133393937363036333730303020300a504f5354202f61646d696e2f6c6f67696e20485454502f312e310d0a436f6e74656e742d547970653a206170706c69636174696f6e2f6a736f6e0d0a417574686f72697a6174696f6e3a20747275650d0a557365722d4167656e743a20506f73746d616e52756e74696d652f372e32382e340d0a4163636570743a202a2f2a0d0a506f73746d616e2d546f6b656e3a2034666132356536622d666434362d346539362d386166362d6636633562613066303033660d0a486f73743a206c6f63616c686f73743a383038310d0a4163636570742d456e636f64696e673a20677a69702c206465666c6174652c2062720d0a436f6e6e656374696f6e3a206b6565702d616c6976650d0a436f6e74656e742d4c656e6774683a2035320d0a0d0a7b0a202020202270617373776f7264223a2022313233343536222c0a2020202022757365726e616d65223a202274657374220a7d0a\n</code></pre><p>到这里，我们已经了解了中间件的基本功能和使用方法，接下来我们回到这节课的主题，如何实现关联操作？</p><h2>如何实现回放关联？</h2><p>这里我们引入“会员登录”和“查询所有后台资源分类”两个接口为例。</p><p>你可以先看看这张整体的请求交互示意图：</p><p><img src=\"https://static001.geekbang.org/resource/image/8d/ce/8da2fa743c61455yyd80f63ebe1e18ce.jpg?wh=1424x1953\" alt=\"图片\"></p><ul>\n<li>会员登录</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/yy/18/yy0d0a5afb7e1a295c0e10b94b989518.png?wh=1282x941\" alt=\"图片\"></p><ul>\n<li>查询所有后台资源分类</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/1a/d8/1a1dbcd1f3eb0566308bfed7fa03efd8.png?wh=1296x754\" alt=\"图片\"></p><p>我们知道 token 是有时效的，如果失效，那么二次请求服务端校验就会失败。如下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/b2/96/b20756aca3d9886966984da4096ee596.png?wh=1244x795\" alt=\"图片\"></p><p>下面我们具体来演示下如何解决token关联的问题。</p><p>第一步，创建一个流量录制的命令：</p><pre><code class=\"language-shell\">#!/bin/bash\n\nPORT=\"8081\"\nOUT_FILE=\"request.gor\"\n\nsudo ./goreplay --input-raw :$PORT --output-file=$OUT_FILE  -output-file-append --input-raw-track-response --prettify-http\n</code></pre><p>录制下的流量文件如下：</p><pre><code class=\"language-shell\">1 d1ae1f9100000001e404ee86 1635588156669182000 0\nPOST /admin/login HTTP/1.1\nContent-Type: application/json\nAuthorization: true\nUser-Agent: PostmanRuntime/7.28.4\nAccept: */*\nPostman-Token: 480f15ca-53df-44fd-8980-5e9118b2107e\nHost: localhost:8081\nAccept-Encoding: gzip, deflate, br\nConnection: keep-alive\nContent-Length: 52\n\n{\n    \"password\": \"123456\",\n    \"username\": \"test\"\n}\n\n🐵🙈🙉\n2 d1ae1f9100000001e404ee86 1635588156828973000 458000\nHTTP/1.1 200 \nContent-Length: 254\nVary: Origin\nVary: Access-Control-Request-Method\nVary: Access-Control-Request-Headers\nX-Content-Type-Options: nosniff\nX-XSS-Protection: 1; mode=block\nCache-Control: no-cache, no-store, max-age=0, must-revalidate\nPragma: no-cache\nExpires: 0\nX-Frame-Options: DENY\nContent-Type: application/json\nDate: Sat, 30 Oct 2021 10:02:36 GMT\nKeep-Alive: timeout=60\nConnection: keep-alive\n\n{\"code\":200,\"message\":\"操作成功\",\"data\":{\"tokenHead\":\"\",\"token\":\"eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ0ZXN0IiwiY3JlYXRlZCI6MTYzNTU4ODE1Njc5NCwiZXhwIjoxNjM1NTg4MjE2fQ.-wsZa0gijz2KfCF-eAYK1Tt-pd_vw2_LShShlIDCQOsHjOZZlGl8yX2MncZlO9St_oPj1JdBaERjfEU6iu12qw\"}}\n\n\n\n🐵🙈🙉\n1 d1ae1f9100000001e405029a 1635588192031592000 0\nGET /resource/listAll HTTP/1.1\ntoken: eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ0ZXN0IiwiY3JlYXRlZCI6MTYzNTU4ODE1Njc5NCwiZXhwIjoxNjM1NTg4MjE2fQ.-wsZa0gijz2KfCF-eAYK1Tt-pd_vw2_LShShlIDCQOsHjOZZlGl8yX2MncZlO9St_oPj1JdBaERjfEU6iu12qw\nUser-Agent: PostmanRuntime/7.28.4\nAccept: */*\nPostman-Token: 4bc2152e-dbd4-4b2a-b880-72ed5ee4303a\nHost: localhost:8081\nAccept-Encoding: gzip, deflate, br\nConnection: keep-alive\n\n🐵🙈🙉\n2 d1ae1f9100000001e405029a 1635588192064563000 1084000\nHTTP/1.1 200 \nContent-Length: 3997\nVary: Origin\nVary: Access-Control-Request-Method\nVary: Access-Control-Request-Headers\nX-Content-Type-Options: nosniff\nX-XSS-Protection: 1; mode=block\nCache-Control: no-cache, no-store, max-age=0, must-revalidate\nPragma: no-cache\nExpires: 0\nX-Frame-Options: DENY\nContent-Type: application/json\nDate: Sat, 30 Oct 2021 10:03:12 GMT\nKeep-Alive: timeout=60\nConnection: keep-alive\n\n{\"code\":200,\"message\":\"操作成功\",\"data\":[{\"id\":1,\"createTime\":\"2020-02-04T09:04:55.000+00:00\",\"name\":\"商品品牌管理\",\"url\":\"/brand/**\",\"description\":null,\"categoryId\":1},{\"id\":2,\"createTime\":\"2020-02-04T09:05:35.000+00:00\",\"name\":\"商品属性分类管理\",\"url\":\"/productAttribute/**\",\"description\":null,\"categoryId\":1},{\"id\":3,\"createTime\":\"2020-02-04T09:06:13.000+00:00\",\"name\":\"商品属性管理\",\"url\":\"/productAttribute/**\",\"description\":null,\"categoryId\":1},{\"id\":4,\"createTime\":\"2020-02-04T09:07:15.000+00:00\",\"name\":\"商品分类管理\",\"url\":\"/productCategory/**\",\"description\":null,\"categoryId\":1},{\"id\":5,\"createTime\":\"2020-02-04T09:09:16.000+00:00\",\"name\":\"商品管理\",\"url\":\"/product/**\",\"description\":null,\"categoryId\":1},{\"id\":6,\"createTime\":\"2020-02-04T09:09:53.000+00:00\",\"name\":\"商品库存管理\",\"url\":\"/sku/**\",\"description\":null,\"categoryId\":1},{\"id\":8,\"createTime\":\"2020-02-05T06:43:37.000+00:00\",\"name\":\"订单管理\",\"url\":\"/order/**\",\"description\":\"\",\"categoryId\":2},{\"id\":9,\"createTime\":\"2020-02-05T06:44:22.000+00:00\",\"name\":\" 订单退货申请管理\",\"url\":\"/returnApply/**\",\"description\":\"\",\"categoryId\":2},{\"id\":10,\"createTime\":\"2020-02-05T06:45:08.000+00:00\",\"name\":\"退货原因管理\",\"url\":\"/returnReason/**\",\"description\":\"\",\"categoryId\":2},{\"id\":11,\"createTime\":\"2020-02-05T06:45:43.000+00:00\",\"name\":\"订单设置管理\",\"url\":\"/orderSetting/**\",\"description\":\"\",\"categoryId\":2},{\"id\":12,\"createTime\":\"2020-02-05T06:46:23.000+00:00\",\"name\":\"收货地址管理\",\"url\":\"/companyAddress/**\",\"description\":\"\",\"categoryId\":2},{\"id\":13,\"createTime\":\"2020-02-07T08:37:22.000+00:00\",\"name\":\"优惠券管理\",\"url\":\"/coupon/**\",\"description\":\"\",\"categoryId\":3},{\"id\":14,\"createTime\":\"2020-02-07T08:37:59.000+00:00\",\"name\":\"优惠券领取记录管理\",\"url\":\"/couponHistory/**\",\"description\":\"\",\"categoryId\":3},{\"id\":15,\"createTime\":\"2020-02-07T08:38:28.000+00:00\",\"name\":\"限时购活动管理\",\"url\":\"/flash/**\",\"description\":\"\",\"categoryId\":3},{\"id\":16,\"createTime\":\"2020-02-07T08:38:59.000+00:00\",\"name\":\"限时购商品关系管理\",\"url\":\"/flashProductRelation/**\",\"description\":\"\",\"categoryId\":3},{\"id\":17,\"createTime\":\"2020-02-07T08:39:22.000+00:00\",\"name\":\"限时购场次管理\",\"url\":\"/flashSession/**\",\"description\":\"\",\"categoryId\":3},{\"id\":18,\"createTime\":\"2020-02-07T08:40:07.000+00:00\",\"name\":\"首页轮播广告管理\",\"url\":\"/home/advertise/**\",\"description\":\"\",\"categoryId\":3},{\"id\":19,\"createTime\":\"2020-02-07T08:40:34.000+00:00\",\"name\":\"首页品牌管理\",\"url\":\"/home/brand/**\",\"description\":\"\",\"categoryId\":3},{\"id\":20,\"createTime\":\"2020-02-07T08:41:06.000+00:00\",\"name\":\"首页新品管理\",\"url\":\"/home/newProduct/**\",\"description\":\"\",\"categoryId\":3},{\"id\":21,\"createTime\":\"2020-02-07T08:42:16.000+00:00\",\"name\":\"首页人气推荐管理\",\"url\":\"/home/recommendProduct/**\",\"description\":\"\",\"categoryId\":3},{\"id\":22,\"createTime\":\"2020-02-07T08:42:48.000+00:00\",\"name\":\"首页专题推荐管理\",\"url\":\"/home/recommendSubject/**\",\"description\":\"\",\"categoryId\":3},{\"id\":23,\"createTime\":\"2020-02-07T08:44:56.000+00:00\",\"name\":\" 商品优选管理\",\"url\":\"/prefrenceArea/**\",\"description\":\"\",\"categoryId\":5},{\"id\":24,\"createTime\":\"2020-02-07T08:45:39.000+00:00\",\"name\":\"商品专题管理\",\"url\":\"/subject/**\",\"description\":\"\",\"categoryId\":5},{\"id\":25,\"createTime\":\"2020-02-07T08:47:34.000+00:00\",\"name\":\"后台用户管理\",\"url\":\"/admin/**\",\"description\":\"\",\"categoryId\":4},{\"id\":26,\"createTime\":\"2020-02-07T08:48:24.000+00:00\",\"name\":\"后台用户角色管理\",\"url\":\"/role/**\",\"description\":\"\",\"categoryId\":4},{\"id\":27,\"createTime\":\"2020-02-07T08:48:48.000+00:00\",\"name\":\"后台菜单管理\",\"url\":\"/menu/**\",\"description\":\"\",\"categoryId\":4},{\"id\":28,\"createTime\":\"2020-02-07T08:49:18.000+00:00\",\"name\":\"后台资源分类管理\",\"url\":\"/resourceCategory/**\",\"description\":\"\",\"categoryId\":4},{\"id\":29,\"createTime\":\"2020-02-07T08:49:45.000+00:00\",\"name\":\"后台资源管理\",\"url\":\"/resource/**\",\"description\":\"\",\"categoryId\":4}]}\n🐵🙈🙉\n</code></pre><p>第二步，创建一个流量回放 Shell 脚本。</p><pre><code class=\"language-shell\">#!/bin/bash\n## Usage: ./replay.sh\n\nOUTPUT=\"http://127.0.0.1:8081\"\nINPUT_FILE=\"requests.gor\"\n\nsudo ./goreplay --input-file $INPUT_FILE --input-file-loop --output-http=$OUTPUT --prettify-http --output-http-track-response --output-stdout\n</code></pre><p>第三步，我们尝试进行一次回放操作。</p><p><img src=\"https://static001.geekbang.org/resource/image/c8/e4/c8e10a5c7b6621cc54d4971b217959e4.png?wh=750x355\" alt=\"图片\"></p><p>等待一会，我们看到回放的【查询所有后台资源分类】接口已经失败了，提示 token 失效了。</p><p>要怎么解决这个问题呢？</p><p>在这种情况下，我们需要实时将来自录制的 token 关联到来自回放响应的 token 上 ，然后使用关联的 token 修改回放的请求。我们使用 GoReplay 存储库中的这个方便的<a href=\"https://github.com/buger/goreplay/blob/master/examples/middleware/token_modifier.go\">示例</a>进行扩展。</p><p>所涉及的基本算法你可以看看下面这张图片。<br>\n<img src=\"https://static001.geekbang.org/resource/image/c0/00/c0b9bd3a17b2d34f0ec2d4e1ea5f0e00.jpg?wh=1920x1040\" alt=\"\"></p><p>因为原始服务器没有预定义的token，而回放服务器有自己的token，它不能与原始服务器同步。所以不使用中间件或者中间件只使用请求有效 payload，都会使得token失效。</p><p>为了解决这个问题，我们的中间件应该考虑回放和源服务器的响应，存储’ originalToken -&gt; replayedToken '别名，并使用此 token 重写所有请求以使用回放别名。</p><p>顺着这个思路，我们看下第四步，创建 token 关联中间件程序。</p><pre><code class=\"language-go\">package main\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"github.com/bitly/go-simplejson\"\n\t\"github.com/buger/goreplay/proto\"\n\t\"os\"\n)\n\n// requestID -&gt; originalToken\n// 请求 ID -&gt; 原始 Token\nvar originalTokens map[string][]byte\n\n// originalToken -&gt; replayedToken\n// 原始 Token -&gt; 回放 Token\nvar tokenAliases map[string][]byte\n\nvar json_data interface{}\n\n\n\nfunc main() {\n\toriginalTokens = make(map[string][]byte)\n\ttokenAliases = make(map[string][]byte)\n\n\tscanner := bufio.NewScanner(os.Stdin)\n\n\tfor scanner.Scan() {\n\t\tencoded := scanner.Bytes()\n\t\tbuf := make([]byte, len(encoded)/2)\n\t\thex.Decode(buf, encoded)\n\n\t\tprocess(buf)\n\t}\n}\n\nfunc process(buf []byte) {\n\t// First byte indicate payload type, possible values:\n\t//  1 - Request\n\t//  2 - Response\n\t//  3 - ReplayedResponse\n\t// 第一个字节表示有效负载类型，可能的值:\n\t// 1 - 请求\n\t// 2 - 响应\n\t// 3 - 回放响应\n\tpayloadType := buf[0]\n\theaderSize := bytes.IndexByte(buf, '\\n') + 1\n\theader := buf[:headerSize-1]\n\n\t// Header contains space separated values of: request type, request id, and request start time (or round-trip time for responses)\n\t// Header 包含空格分隔的值:请求类型，请求 id，请求开始时间(或响应的往返时间)\n\tmeta := bytes.Split(header, []byte(\" \"))\n\t\n    // For each request you should receive 3 payloads (request, response, replayed response) with same request id\n\t// 对于每个请求，你应该收到 3 个有效负载(request, response, replayed response)，具有相同的请求 id\n\treqID := string(meta[1])\n\tpayload := buf[headerSize:]\n\n\tDebug(\"Received payload:\", string(buf))\n\n\tswitch payloadType {\n\tcase '1': // Request\n\t\tif bytes.Equal(proto.Path(payload), []byte(\"/admin/login\")) {\n\t\t\toriginalTokens[reqID] = []byte{}\n\t\t\tDebug(\"Found token request:\", reqID)\n\t\t} else {\n\t\t\t//token, vs, _ := proto.PathParam(payload, []byte(\"token\")) //取到回放响应的 token 值\n\t\t\ttoken := proto.Header(payload, []byte(\"token\")) //取到原始的 token 值\n\n\t\t\tDebug(\"Received token:\", string(token))\n\n\t\t\tif len(token) != 0 { // If there is GET token param\n\t\t\t\tDebug(\"If there is GET token param\")\n\t\t\t\tDebug(\"tokenAliases\", tokenAliases)\n\t\t\t\tif alias, ok := tokenAliases[string(token)]; ok { \t\t//检查要替换的 token 值是否存在\n\t\t\t\t\tDebug(\"Received alias\")\n\t\t\t\t\t// Rewrite original token to alias\n\t\t\t\t\tpayload = proto.SetHeader(payload, []byte(\"token\"), alias)  //将原始的 token 替换成回放的 token\n\n\t\t\t\t\t// Copy modified payload to our buffer\n\t\t\t\t\tbuf = append(buf[:headerSize], payload...)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Emitting data back\n\t\tos.Stdout.Write(encode(buf)) //重写请求准备发往回放服务\n\tcase '2': // Original response\n\t\tif _, ok := originalTokens[reqID]; ok {\n\t\t\tjsonObject, err := simplejson.NewJson([]byte(proto.Body(payload)))\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(err)\n\t\t\t}\n\n\t\t\tresult := jsonObject.Get(\"data\")\n\t\t\ttoken := result.Get(\"token\")\n\t\t\tsecureToken:=token\n\n\t\t\tf ,_:=secureToken.Bytes()\n\n\t\t\toriginalTokens[reqID] = f\n\t\t\tDebug(\"Remember origial token:\", f)\n\n\t\t}\n\tcase '3': // Replayed response\n\t\tif originalToken, ok := originalTokens[reqID]; ok {\n\t\t\tdelete(originalTokens, reqID)\n\n\n\n\t\t\tjsonObject, err := simplejson.NewJson([]byte(proto.Body(payload)))\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(err)\n\t\t\t}\n\t\t\tresult := jsonObject.Get(\"data\")\n\t\t\ttoken := result.Get(\"token\")\n\t\t\tf ,_:=token.Bytes()\n\t\t\ttokenAliases[string(originalToken)] = f //拿到现在的 token 值用来替换掉过去的 token 值\n\n\t\t\tDebug(\"Create alias for new token token, was:\", string(originalToken), \"now:\", string(f))\n\t\t}\n\t}\n}\n\nfunc encode(buf []byte) []byte {\n\tdst := make([]byte, len(buf)*2+1)\n\thex.Encode(dst, buf)\n\tdst[len(dst)-1] = '\\n'\n\n\treturn dst\n}\n\nfunc Debug(args ...interface{}) {\n\tif os.Getenv(\"GOR_TEST\") == \"\" { // if we are not testing\n\t\tfmt.Fprint(os.Stderr, \"[DEBUG][TOKEN-MOD] \")\n\t\tfmt.Fprintln(os.Stderr, args...)\n\t}\n\n}\n</code></pre><p>我们可以使用 process 函数异步处理原始请求或回放响应从而重新设置 token。由于 GoReplay 的每个三元组（请求、响应、回放响应）共享一个请求 ID，因此到达中间件的第一个响应可以将它的 token 关联到请求 ID。当第二个响应到达时，我们就可以访问两个 token了。我们可以将原始 token 关联到回放的 token，并能够一一对应（因为第二个响应类型也可用）。</p><p>好了，这样中间件就写完了，我们一起来测试一下。</p><p>我们先创建一个运行中间件的 Shell 脚本 middleware_wrapper.sh。</p><pre><code class=\"language-bash\">#!/bin/bash\ngo run token_modifier.go\n</code></pre><p>第二步，修改启动回放的 Shell 脚本 replay.sh。</p><pre><code class=\"language-bash\">#!/bin/bash\n## Usage: ./replay.sh\n\nOUTPUT=\"http://127.0.0.1:8081\"\nMIDDLEWARE=\"./middleware_wrapper.sh\"\nINPUT_FILE=\"requests.gor\"\n\nsudo ./goreplay --input-file $INPUT_FILE --input-file-loop --output-http=$OUTPUT --middleware $MIDDLEWARE --prettify-http --output-http-track-response --output-stdout\n</code></pre><p>最后一步，我们就要紧盯运行控制台了。</p><ul>\n<li>登录接口实时返回的 token。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/c4/90/c4a97041689054c34c2b721a48ecd190.png?wh=1881x695\" alt=\"图片\"></p><ul>\n<li>【查询所有后台资源分类】接口，可以看到已经成功替换到回放响应的 token了。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/de/98/de4c63d1d179f2b5b4804e5febac1898.png?wh=750x386\" alt=\"图片\"></p><ul>\n<li>【查询所有后台资源分类】接口，回放响应的数据也是正常的。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/55/24/55b26162d5dacaa39a0a161d5f83f124.png?wh=750x321\" alt=\"图片\"></p><ul>\n<li>服务端日志显示正常。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/71/yy/71e8fd0b45f03d5861c1debe0cd504yy.png?wh=599x348\" alt=\"图片\"></p><p>好了，到这里，我们的动态数据关联功能就已经实现了。</p><h2>总结</h2><p>好了，这节课就讲到这里。刚才，我们一起梳理了关联的基本概念、 GoReplay 中间件（ Middleware ）原理、常用的用法。我们还通过例子演示了GoReplay 如何通过扩展 Middleware 做到关联功能。实际上，我们可以在中间件上实现任何自定义逻辑，比如认证、复杂的重写和筛选请求等。</p><p>下一节课，我们将进入具体的分布式改造环节，我会通过案例演示如何做分布式平台改造工作。</p><h2>课后题</h2><p>学完这节课，请你思考两个问题：</p><ol>\n<li>你有没有使用过 Middleware，谈谈你对 Middleware 应用的一些心得吧！</li>\n<li>相比 JMeter，你觉得 GoReplay 关联的难度在什么地方？</li>\n</ol><p>欢迎你在留言区与我交流讨论。当然了，你也可以把这节课分享给你身边的朋友，他们的一些想法或许会让你有更大的收获。我们下节课见！</p>","neighbors":{"left":{"article_title":"21 | 压测平台：高效搭建 GoReplay 压测平台","id":463560},"right":{"article_title":"23 | 压测平台：如何改造对象存储和性能监控？","id":465623}},"comments":[]}