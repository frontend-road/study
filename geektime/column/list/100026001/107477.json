{"id":107477,"title":"37 | 高速缓存（上）：“4毫秒”究竟值多少钱？","content":"<p>在这一节内容开始之前，我们先来看一个3行的小程序。你可以猜一猜，这个程序里的循环1和循环2，运行所花费的时间会差多少？你可以先思考几分钟，然后再看我下面的解释。</p><pre><code>int[] arr = new int[64 * 1024 * 1024];\n\n\n// 循环1\nfor (int i = 0; i &lt; arr.length; i++) arr[i] *= 3;\n\n\n// 循环2\nfor (int i = 0; i &lt; arr.length; i += 16) arr[i] *= 3\n</code></pre><p>在这段Java程序中，我们首先构造了一个64×1024×1024大小的整型数组。在循环1里，我们遍历整个数组，将数组中每一项的值变成了原来的3倍；在循环2里，我们每隔16个索引访问一个数组元素，将这一项的值变成了原来的3倍。</p><p>按道理来说，循环2只访问循环1中1/16的数组元素，只进行了循环1中1/16的乘法计算，那循环2花费的时间应该是循环1的1/16左右。但是实际上，循环1在我的电脑上运行需要50毫秒，循环2只需要46毫秒。这两个循环花费时间之差在15%之内。</p><p>为什么会有这15%的差异呢？这和我们今天要讲的CPU Cache有关。之前我们看到了内存和硬盘之间存在的巨大性能差异。在CPU眼里，内存也慢得不行。于是，聪明的工程师们就在CPU里面嵌入了CPU Cache（高速缓存），来解决这一问题。</p><h2>我们为什么需要高速缓存?</h2><p>按照<a href=\"https://zh.wikipedia.org/wiki/%E6%91%A9%E5%B0%94%E5%AE%9A%E5%BE%8B\">摩尔定律</a>，CPU的访问速度每18个月便会翻一番，相当于每年增长60%。内存的访问速度虽然也在不断增长，却远没有这么快，每年只增长7%左右。而这两个增长速度的差异，使得CPU性能和内存访问性能的差距不断拉大。到今天来看，一次内存的访问，大约需要120个CPU Cycle，这也意味着，在今天，CPU和内存的访问速度已经有了120倍的差距。</p><!-- [[[read_end]]] --><p>如果拿我们现实生活来打个比方的话，CPU的速度好比风驰电掣的高铁，每小时350公里，然而，它却只能等着旁边腿脚不太灵便的老太太，也就是内存，以每小时3公里的速度缓慢步行。因为CPU需要执行的指令、需要访问的数据，都在这个速度不到自己1%的内存里。</p><p><img src=\"https://static001.geekbang.org/resource/image/4f/4b/4fc459f42a67d3949402865a998bf34b.png?wh=1142*607\" alt=\"\"></p><center><span class=\"reference\">随着时间变迁，CPU和内存之间的性能差距越来越大</span></center><p>为了弥补两者之间的性能差异，我们能真实地把CPU的性能提升用起来，而不是让它在那儿空转，我们在现代CPU中引入了高速缓存。</p><p>从CPU Cache被加入到现有的CPU里开始，内存中的指令、数据，会被加载到L1-L3 Cache中，而不是直接由CPU访问内存去拿。在95%的情况下，CPU都只需要访问L1-L3 Cache，从里面读取指令和数据，而无需访问内存。要注意的是，这里我们说的CPU Cache或者L1/L3 Cache，不是一个单纯的、概念上的缓存（比如之前我们说的拿内存作为硬盘的缓存），而是指特定的由SRAM组成的物理芯片。</p><p>这里是一张Intel CPU的放大照片。这里面大片的长方形芯片，就是这个CPU使用的20MB的L3 Cache。</p><p><img src=\"https://static001.geekbang.org/resource/image/c1/15/c1dc0e3453f469fc4607557dab9d5215.jpg?wh=1142*1147\" alt=\"\"></p><center><span class=\"reference\">现代CPU中大量的空间已经被SRAM占据，图中用红色框出的部分就是CPU的L3 Cache芯片</span></center><p>在这一讲一开始的程序里，运行程序的时间主要花在了将对应的数据从内存中读取出来，加载到CPU Cache里。CPU从内存中读取数据到CPU Cache的过程中，是一小块一小块来读取数据的，而不是按照单个数组元素来读取数据的。这样一小块一小块的数据，在CPU Cache里面，我们把它叫作Cache Line（缓存块）。</p><p>在我们日常使用的Intel服务器或者PC里，Cache Line的大小通常是64字节。而在上面的循环2里面，我们每隔16个整型数计算一次，16个整型数正好是64个字节。于是，循环1和循环2，需要把同样数量的Cache Line数据从内存中读取到CPU Cache中，最终两个程序花费的时间就差别不大了。</p><p>知道了为什么需要CPU Cache，接下来，我们就来看一看，CPU究竟是如何访问CPU Cache的，以及CPU Cache是如何组织数据，使得CPU可以找到自己想要访问的数据的。因为Cache作为“缓存”的意思，在很多别的存储设备里面都会用到。为了避免你混淆，在表示抽象的“缓存“概念时，用中文的“缓存”；如果是CPU Cache，我会用“高速缓存“或者英文的“Cache”，来表示。</p><h2>Cache的数据结构和读取过程是什么样的？</h2><p>现代CPU进行数据读取的时候，无论数据是否已经存储在Cache中，CPU始终会首先访问Cache。只有当CPU在Cache中找不到数据的时候，才会去访问内存，并将读取到的数据写入Cache之中。当时间局部性原理起作用后，这个最近刚刚被访问的数据，会很快再次被访问。而Cache的访问速度远远快于内存，这样，CPU花在等待内存访问上的时间就大大变短了。</p><p><img src=\"https://static001.geekbang.org/resource/image/3a/cc/3a6fcfd1155e03f4f2781dbb6ddaf6cc.png?wh=1142*579\" alt=\"\"></p><p>这样的访问机制，和我们自己在开发应用系统的时候，“使用内存作为硬盘的缓存”的逻辑是一样的。在各类基准测试（Benchmark）和实际应用场景中，CPU Cache的命中率通常能达到95%以上。</p><p>问题来了，CPU如何知道要访问的内存数据，存储在Cache的哪个位置呢？接下来，我就从最基本的<strong>直接映射Cache</strong>（Direct Mapped Cache）说起，带你来看整个Cache的数据结构和访问逻辑。</p><p>在开头的3行小程序里我说过，CPU访问内存数据，是一小块一小块数据来读取的。对于读取内存中的数据，我们首先拿到的是数据所在的<strong>内存块</strong>（Block）的地址。而直接映射Cache采用的策略，就是确保任何一个内存块的地址，始终映射到一个固定的CPU Cache地址（Cache Line）。而这个映射关系，通常用mod运算（求余运算）来实现。下面我举个例子帮你理解一下。</p><p>比如说，我们的主内存被分成0～31号这样32个块。我们一共有8个缓存块。用户想要访问第21号内存块。如果21号内存块内容在缓存块中的话，它一定在5号缓存块（21 mod 8 = 5）中。</p><p><img src=\"https://static001.geekbang.org/resource/image/52/22/522eade51bbfad19fd25eb4f3ce80f22.png?wh=1142*793\" alt=\"\"></p><center><span class=\"reference\">Cache采用mod的方式，把内存块映射到对应的CPU Cache中</span></center><p>实际计算中，有一个小小的技巧，通常我们会把缓存块的数量设置成2的N次方。这样在计算取模的时候，可以直接取地址的低N位，也就是二进制里面的后几位。比如这里的8个缓存块，就是2的3次方。那么，在对21取模的时候，可以对21的2进制表示10101取地址的低三位，也就是101，对应的5，就是对应的缓存块地址。</p><p><img src=\"https://static001.geekbang.org/resource/image/ca/80/caadd2728b5cfcd2bd704103570f3a80.png?wh=1142*762\" alt=\"\"></p><p>取Block地址的低位，就能得到对应的Cache Line地址，除了21号内存块外，13号、5号等很多内存块的数据，都对应着5号缓存块中。既然如此，假如现在CPU想要读取21号内存块，在读取到5号缓存块的时候，我们怎么知道里面的数据，究竟是不是21号对应的数据呢？同样，建议你借助现有知识，先自己思考一下，然后再看我下面的分析，这样会印象比较深刻。</p><p>这个时候，在对应的缓存块中，我们会存储一个<strong>组标记</strong>（Tag）。这个组标记会记录，当前缓存块内存储的数据对应的内存块，而缓存块本身的地址表示访问地址的低N位。就像上面的例子，21的低3位101，缓存块本身的地址已经涵盖了对应的信息、对应的组标记，我们只需要记录21剩余的高2位的信息，也就是10就可以了。</p><p>除了组标记信息之外，缓存块中还有两个数据。一个自然是从主内存中加载来的实际存放的数据，另一个是<strong>有效位</strong>（valid bit）。啥是有效位呢？它其实就是用来标记，对应的缓存块中的数据是否是有效的，确保不是机器刚刚启动时候的空数据。如果有效位是0，无论其中的组标记和Cache Line里的数据内容是什么，CPU都不会管这些数据，而要直接访问内存，重新加载数据。</p><p>CPU在读取数据的时候，并不是要读取一整个Block，而是读取一个他需要的数据片段。这样的数据，我们叫作CPU里的一个字（Word）。具体是哪个字，就用这个字在整个Block里面的位置来决定。这个位置，我们叫作偏移量（Offset）。</p><p>总结一下，<strong>一个内存的访问地址，最终包括高位代表的组标记、低位代表的索引，以及在对应的Data Block中定位对应字的位置偏移量。</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/13/d4/1313fe1e4eb3b5c949284c8b215af8d4.png?wh=1142*638\" alt=\"\"></p><center><span class=\"reference\">内存地址到Cache Line的关系</span></center><p>而内存地址对应到Cache里的数据结构，则多了一个有效位和对应的数据，由“<strong>索引 + 有效位</strong>  <strong>+ 组标记 + 数据</strong>”组成。如果内存中的数据已经在CPU Cache里了，那一个内存地址的访问，就会经历这样4个步骤：</p><ol>\n<li>根据内存地址的低位，计算在Cache中的索引；</li>\n<li>判断有效位，确认Cache中的数据是有效的；</li>\n<li>对比内存访问地址的高位，和Cache中的组标记，确认Cache中的数据就是我们要访问的内存数据，从Cache Line中读取到对应的数据块（Data Block）；</li>\n<li>根据内存地址的Offset位，从Data Block中，读取希望读取到的字。</li>\n</ol><p>如果在2、3这两个步骤中，CPU发现，Cache中的数据并不是要访问的内存地址的数据，那CPU就会访问内存，并把对应的Block Data更新到Cache Line中，同时更新对应的有效位和组标记的数据。</p><p>好了，讲到这里，相信你明白现代CPU，是如何通过直接映射Cache，来定位一个内存访问地址在Cache中的位置了。其实，除了直接映射Cache之外，我们常见的缓存放置策略还有全相连Cache（Fully Associative Cache）、组相连Cache（Set Associative Cache）。这几种策略的数据结构都是相似的，理解了最简单的直接映射Cache，其他的策略你很容易就能理解了。</p><h2>减少4毫秒，公司挣了多少钱?</h2><p>刚才我花了很多篇幅，讲了CPU和内存之间的性能差异，以及我们如何通过CPU Cache来尽可能解决这两者之间的性能鸿沟。你可能要问了，这样做的意义和价值究竟是什么？毕竟，一次内存的访问，只不过需要100纳秒而已。1秒钟时间内，足有1000万个100纳秒。别着急，我们先来看一个故事。</p><p>2008年，一家叫作Spread Networks的通信公司花费3亿美元，做了一个光缆建设项目。目标是建设一条从芝加哥到新泽西，总长1331公里的光缆线路。建设这条线路的目的，其实是为了将两地之间原有的网络访问延时，从17毫秒降低到13毫秒。</p><p>你可能会说，仅仅缩短了4毫秒时间啊，却花费3个亿，真的值吗？为这4毫秒时间买单的，其实是一批高频交易公司。它们以5年1400万美元的价格，使用这条线路。利用这短短的4毫秒的时间优势，这些公司通过高性能的计算机程序，在芝加哥和新泽西两地的交易所进行高频套利，以获得每年以10亿美元计的利润。现在你还觉得这个不值得吗？</p><p>其实，只要350微秒的差异，就足够高频交易公司用来进行无风险套利了。而350微秒，如果用来进行100纳秒一次的内存访问，大约只够进行3500次。而引入CPU Cache之后，我们可以进行的数据访问次数，提升了数十倍，使得各种交易策略成为可能。</p><h2>总结延伸</h2><p>很多时候，程序的性能瓶颈，来自使用DRAM芯片的内存访问速度。</p><p>根据摩尔定律，自上世纪80年代以来，CPU和内存的性能鸿沟越拉越大。于是，现代CPU的设计者们，直接在CPU中嵌入了使用更高性能的SRAM芯片的Cache，来弥补这一性能差异。通过巧妙地将内存地址，拆分成“索引+组标记+偏移量”的方式，使得我们可以将很大的内存地址，映射到很小的CPU Cache地址里。而CPU Cache带来的毫秒乃至微秒级别的性能差异，又能带来巨大的商业利益，十多年前的高频交易行业就是最好的例子。</p><p>在搞清楚从内存加载数据到Cache，以及从Cache里读取到想要的数据之后，我们又要面临一个新的挑战了。CPU不仅要读数据，还需要写数据，我们不能只把数据写入到Cache里面就结束了。下一讲，我们就来仔细讲讲，CPU要写入数据的时候，怎么既不牺牲性能，又能保证数据的一致性。</p><h2>推荐阅读</h2><p>如果你学有余力，这里有两篇文章推荐给你阅读。</p><p>如果想深入了解CPU和内存之间的访问性能，你可以阅读<a href=\"https://people.freebsd.org/~lstewart/articles/cpumemory.pdf\">What Every Programmer Should Know About Memory</a>。</p><p>现代CPU已经很少使用直接映射Cache了，通常用的是组相连Cache（set associative cache），想要了解组相连Cache，你可以阅读《计算机组成与设计：硬件/软件接口》的5.4.1小节。</p><h2>课后思考</h2><p>对于二维数组的访问，按行迭代和按列迭代的访问性能是一样的吗？你可以写一个程序测试一下，并思考一下原因。</p><p>欢迎把你思考的结果写在留言区。如果觉得有收获，你也可以把这篇文章分享给你的朋友，和他一起讨论和学习。</p>","comments":[{"had_liked":false,"id":164678,"user_name":"王加武","can_delete":false,"product_type":"c1","uid":1665471,"ip_address":"","ucode":"DDCFE578C6C428","user_header":"https://static001.geekbang.org/account/avatar/00/19/69/bf/50a824a4.jpg","comment_is_top":false,"comment_ctime":1577071192,"is_pvip":false,"replies":[{"id":"68137","content":"Hash同学，<br><br>你好，理解正确！","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1580651141,"ip_address":"","comment_id":164678,"utype":1}],"discussion_count":4,"race_medal":0,"score":"216325435992","product_id":100026001,"comment_content":"我的电脑测试的结果<br> int[][] arr = new int[10000][10000];<br>按行迭代——<br>280毫秒<br>按列迭代——<br>1180毫秒<br><br>分析原因——<br>1、首选数组的存储方式是连续的，在内存中是按照行来存储的，遍历的时候也是一个一个的往后遍历<br><br>2、根据老师讲的，CPU从内存读取数据到CPU Cache ，是按照一小块一小块的方式读取的，它的物理内存是连续的，几乎是同行不同列，如果说我们是按照列来迭代的话，那么就会导致存储快无法使用，我们就不得不从内存中读取数据，而在内存中直接读取数据和从高速缓存中直接读取数据的效率那可不是一般的差距，所以说按照行来迭代话，我们就可以很好的利用的数据块，从高速缓存中来读取数据，从而所花费的时间也就比按照列来迭代所花费的时间少！<br><br>这是我的见解，有不对的地方，还望老师指正！<br>","like_count":51,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478862,"discussion_content":"Hash同学，\n\n你好，理解正确！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580651141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2415283,"avatar":"https://static001.geekbang.org/account/avatar/00/24/da/b3/35859560.jpg","nickname":"Ciao🌚","note":"","ucode":"B048EC8A4A4D77","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349722,"discussion_content":"hmmm 怎么我跑着 按列迭代反而快呢。。。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1613480993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2354332,"avatar":"https://static001.geekbang.org/account/avatar/00/23/ec/9c/b4acd768.jpg","nickname":"Sarah","note":"","ucode":"FDC8A0D30EAE28","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379568,"discussion_content":"我用C#试的二维数组：\n按行迭代399ms,\n按列迭代826ms","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623985055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1297523,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cc/73/9c41a7ee.jpg","nickname":"雷蒙德张","note":"","ucode":"0104F5818EA7F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290763,"discussion_content":"按照CSAPP第六章的解释，按行迭代的步长为1, 按列迭代的步长是列的N倍，因此更耗时","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594601602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115233,"user_name":"斐波那契","can_delete":false,"product_type":"c1","uid":1464006,"ip_address":"","ucode":"85E2EBC01392B1","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/c6/0b449bc6.jpg","comment_is_top":false,"comment_ctime":1563514468,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"117527631460","product_id":100026001,"comment_content":"一般二维数组在内存中存放是按行优先存放的 所以在加载数据时候就会把一行数据加载进cache里 这样cache的命中率就大大提高 如果按列迭代 cache就很难名字从而cpu就要经常从内存中读数据 如果数据量不大的话两种方式可能没什么感觉 一旦数据量很大的话按行迭代的速度就能感觉出来了","like_count":27,"discussions":[{"author":{"id":1484184,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","nickname":"djfhchdh","note":"","ucode":"E71D75328CE398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2398,"discussion_content":"按照行迭代，恰好符合空间局部性","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1563537416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137056,"user_name":"前端西瓜哥","can_delete":false,"product_type":"c1","uid":1248576,"ip_address":"","ucode":"150130C34CD1C1","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/40/f70e5653.jpg","comment_is_top":false,"comment_ctime":1569586725,"is_pvip":false,"replies":[{"id":"52596","content":"Fstar同学你好，<br><br>37和38讲里讲了怎么做组相连的缓存加载过程，后面的MESI协议部分里也有怎么做写入的高速缓存同步问题，可以仔细看一下。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1569650765,"ip_address":"","comment_id":137056,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23044423205","product_id":100026001,"comment_content":"有点像哈希表。那如果读取的多个内存数据的地址都指向同一个缓存块怎么办？直接覆盖掉？","like_count":5,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468921,"discussion_content":"Fstar同学你好，\n\n37和38讲里讲了怎么做组相连的缓存加载过程，后面的MESI协议部分里也有怎么做写入的高速缓存同步问题，可以仔细看一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569650765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134642,"user_name":"小先生","can_delete":false,"product_type":"c1","uid":1055214,"ip_address":"","ucode":"E5F2052E0323C0","user_header":"https://static001.geekbang.org/account/avatar/00/10/19/ee/e395a35e.jpg","comment_is_top":false,"comment_ctime":1568884933,"is_pvip":false,"replies":[{"id":"52619","content":"小先生同学，<br><br>你好，偏移量是在内存地址的访问请求里的，并不会存在映射关系里，不需要预先存啊。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1569656113,"ip_address":"","comment_id":134642,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18748754117","product_id":100026001,"comment_content":"我有个疑问：<br>内存中读取数据，也是按照一块一块来的。<br>那一个内存地址是怎么存储对应字的位置偏移量。那它得存多少偏移量啊？","like_count":4,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467841,"discussion_content":"小先生同学，\n\n你好，偏移量是在内存地址的访问请求里的，并不会存在映射关系里，不需要预先存啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569656113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1250807,"avatar":"https://static001.geekbang.org/account/avatar/00/13/15/f7/744720a2.jpg","nickname":"DriveMan_邱佳源","note":"","ucode":"A4C83BF07DEE7A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":20030,"discussion_content":"cpu读取内存数据，是以页4kb为单位来读写的，cache从内存读取才是一块一块的，每块以64bit为单位","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1569250141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1361746,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c7/52/c5adf218.jpg","nickname":"喜欢地球的阿培同学","note":"","ucode":"5F97037585F857","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1250807,"avatar":"https://static001.geekbang.org/account/avatar/00/13/15/f7/744720a2.jpg","nickname":"DriveMan_邱佳源","note":"","ucode":"A4C83BF07DEE7A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347229,"discussion_content":"好像不对啊， Linux 会默认以页4kb 为单位管理内存，但是CPU读取内存数据，不是以页4kb为单位进行读取。而是以Cache line(64bit)为单位进行读取的，具体读多少，并不确定啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612178700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":20030,"ip_address":""},"score":347229,"extra":""}]}]},{"had_liked":false,"id":256946,"user_name":"尼古拉斯","can_delete":false,"product_type":"c1","uid":2026074,"ip_address":"","ucode":"82EE35B505C09A","user_header":"","comment_is_top":false,"comment_ctime":1603790665,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14488692553","product_id":100026001,"comment_content":"8个缓存块 应该是cake line 0 到cake line 7 途中多了一个cake line 8","like_count":4},{"had_liked":false,"id":283833,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1615950115,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10205884707","product_id":100026001,"comment_content":"我们为什么需要高速缓存?<br>CPU 的速度好比风驰电掣的高铁，而内存像脚不太灵便的老太太，速度不匹配<br>Cache 的数据结构和读取过程是什么样的<br>   现代 CPU 进行数据读取的时候，无论数据是否已经存储在 Cache 中，CPU 始终会首先访问 Cache。只有当 CPU 在 Cache 中找不到数据的时候，才会去访问内存，并将读取到的数据写入 Cache 之中<br><br>   缓存放置策略<br>    1) 通过直接映射Cache，<br>        CPU访问内存数据，是一小块一小块数据来读取的。对于读取内存中的数据，我们首先拿到的是数据所在的内存块（Block）的地址。而直接映射Cache采用的策略，就是确保任何一个内存块的地址，始终映射到一个固定的CPU Cache地址（Cache Line）。而这个映射关系，通常用 mod 运算（求余运算）来实现。<br>    比如说，我们的主内存被分成 0～31 号这样 32 个块。我们一共有 8 个缓存块。用户想要访问第 21 号内存块。如果 21 号内存块内容在缓存块中的话，它一定在 5 号缓存块（21 mod 8 = 5）中<br>    一个内存的访问地址，最终包括高位代表的组标记、低位代表的索引，以及在对应的Data Block中定位对应字的位置偏移量<br><br>2) 全相连 Cache（Fully Associative Cache）、<br> 一个快可以放置在cache中的任何位置，但是在检索cache中所有项，为了使检索更加有效，它是由一个与cache中每个项都相关的比较器并行完成，这些比较器加大了硬件开下，因而全相连只适合块较少的cache<br>3) 组相连 Cache（Set Associative Cache）<br>     介于直接映射和全相连之间的设计是组相连，在组相连cache中，每个块可被放置的位置数是固定的。每个块有n个位置可放的cache被称作为n路组相连cache。一个n路组相联cache由很多个组构成，每个组中有n块，根据索引域，存储器中的每个块对应到cache中唯一组，并且可以放在这个组中的任何一个位置上。","like_count":2},{"had_liked":false,"id":226332,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1592039627,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10181974219","product_id":100026001,"comment_content":"细细品来，真有味","like_count":2},{"had_liked":false,"id":138250,"user_name":"coldpark","can_delete":false,"product_type":"c1","uid":1058331,"ip_address":"","ucode":"D1B0F343B384F8","user_header":"https://static001.geekbang.org/account/avatar/00/10/26/1b/4caf36bd.jpg","comment_is_top":false,"comment_ctime":1570114126,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10160048718","product_id":100026001,"comment_content":"请问如果5号高速缓存块要同时存储5和21号内存的数据，组标记怎么填写呢？","like_count":2,"discussions":[{"author":{"id":1147711,"avatar":"https://static001.geekbang.org/account/avatar/00/11/83/3f/bc2ea80d.jpg","nickname":"陌.寒哲","note":"","ucode":"B7079FF211D712","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":94853,"discussion_content":"不能同时存储，存储一个新的，旧的就备覆盖了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576994966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115529,"user_name":"Geek_JaneJane","can_delete":false,"product_type":"c1","uid":1483298,"ip_address":"","ucode":"E1AE83FE46CB96","user_header":"","comment_is_top":false,"comment_ctime":1563612950,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"10153547542","product_id":100026001,"comment_content":"请问徐老师，为什么我在Python上执行3行小程序不是那个效果呢？<br>```<br>import time<br><br>a = [0]*64*1024*1024<br>start = int(time.time()*1000)<br>for i in range(0, len(a)):<br>    a[i] *= 3<br>print &#39;1,&#39;, int(time.time()*1000) - start<br><br>start = int(time.time()*1000)<br>for j in range(0, len(a), 16):<br>    a[j] *= 3<br>print &#39;2,&#39;, int(time.time()*1000) - start<br><br>输出：<br>1, 11804<br>2, 538<br><br>```","like_count":2,"discussions":[{"author":{"id":1266043,"avatar":"https://static001.geekbang.org/account/avatar/00/13/51/7b/191a2112.jpg","nickname":"愤怒的虾干","note":"","ucode":"CEBD1B2BE7BCEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84434,"discussion_content":"Java中int[]是数组，是在内存中分配的连续区域，所以测试有效。Python里估计是链表，不是连续的空间，所以结果就和遍历的数量有关了吧，换Java试试？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576497211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2354332,"avatar":"https://static001.geekbang.org/account/avatar/00/23/ec/9c/b4acd768.jpg","nickname":"Sarah","note":"","ucode":"FDC8A0D30EAE28","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379564,"discussion_content":"我在C#中测试结果是：202ms，70ms，相差也很大，流汗~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623983561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1265741,"avatar":"https://static001.geekbang.org/account/avatar/00/13/50/4d/392f969b.jpg","nickname":"蒋旺Foo","note":"","ucode":"4325AB9674975C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4357,"discussion_content":"你可以把循环1与循环2分开运行试一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565334610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1483298,"avatar":"","nickname":"Geek_JaneJane","note":"","ucode":"E1AE83FE46CB96","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1265741,"avatar":"https://static001.geekbang.org/account/avatar/00/13/50/4d/392f969b.jpg","nickname":"蒋旺Foo","note":"","ucode":"4325AB9674975C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":15126,"discussion_content":"您好，谢谢您的评论，但是我分开运行了还是不行，基本上就是16倍的关系。而不是相差很小的那种。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568806611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4357,"ip_address":""},"score":15126,"extra":""}]}]},{"had_liked":false,"id":115473,"user_name":"alexgzh","can_delete":false,"product_type":"c1","uid":1476632,"ip_address":"","ucode":"EE3228511C8B9B","user_header":"https://static001.geekbang.org/account/avatar/00/16/88/18/a88cdaf5.jpg","comment_is_top":false,"comment_ctime":1563596624,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10153531216","product_id":100026001,"comment_content":"分語言, 有的語言二維數組按照行來存, 例如C++ A[2][2] 存放是A[0][0] A[0][1] 存第一行。A[1][0] A[1][1] 存第二行，按照行迭代的方式快。Fortran按照列來存，按照列迭代快。","like_count":2,"discussions":[{"author":{"id":1052528,"avatar":"https://static001.geekbang.org/account/avatar/00/10/0f/70/c8680841.jpg","nickname":"Joe Black","note":"","ucode":"21FE222A286445","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161951,"discussion_content":"好像matlab也是按照列存的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580949865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252264,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1602217774,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5897185070","product_id":100026001,"comment_content":"按行迭代刚好匹配空间局部性原理，因此性能更好","like_count":1},{"had_liked":false,"id":216804,"user_name":"devil","can_delete":false,"product_type":"c1","uid":1259625,"ip_address":"","ucode":"BB6090411BAA23","user_header":"https://static001.geekbang.org/account/avatar/00/13/38/69/864569a4.jpg","comment_is_top":false,"comment_ctime":1589346324,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5884313620","product_id":100026001,"comment_content":"cache line映射是根据物理地址还是虚拟地址？","like_count":1,"discussions":[{"author":{"id":1009527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/77/c1310aad.jpg","nickname":"剑衣清风","note":"","ucode":"470CD81F6612F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333671,"discussion_content":"有三种，VIVT、VIPT、PIPT，具体的可以可以参考下 https://zhuanlan.zhihu.com/p/107096130?tdsourcetag=s_pctim_aiomsg","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1607589993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1029376,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b5/00/4093f39a.jpg","nickname":"杨赛","note":"","ucode":"E26AF8930F78E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381416,"discussion_content":"虚拟地址,最终有mmu转成物理地址. ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625044957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1810189,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/ZHw73tgCqGKhvticUWGRz4icgicu4hFWfKtacoFJeItH7maNuNUmjnEgDTJvOibwUWgGV0p6guNPibMVWDV4BUmEmlA/132","nickname":"Ethan","note":"","ucode":"75F613D58909DB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300949,"discussion_content":"我觉得是虚拟地址，CPU读取内存的时候用的是虚拟地址，然后映射到CPU Cache的中也当然是虚拟地址","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598337568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215826,"user_name":"曙光","can_delete":false,"product_type":"c1","uid":1476450,"ip_address":"","ucode":"04D65BF7F19845","user_header":"https://static001.geekbang.org/account/avatar/00/16/87/62/f99b5b05.jpg","comment_is_top":false,"comment_ctime":1589112138,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5884079434","product_id":100026001,"comment_content":"&quot;Cache Line 的大小通常是 64 字节。而在上面的循环 2 里面，我们每隔 16 个整型数计算一次，16 个整型数正好是 64 个字节。于是，循环 1 和循环 2，需要把同样数量的 Cache Line 数据从内存中读取到 CPU Cache 中，最终两个程序花费的时间就差别不大了。&quot;<br>-------------------------<br>Cache 里的数据结构，多了一个有效位和对应的数据，由“索引 + 有效位 + 组标记 + 数据”，如果说cache line内保存64字节都是数据，“索引 ”是cache line的索引，那“有效位 + 组标记 ”存放在哪呢？是不是说一个cache line不能存放64字节的数据？ <br>我的理解是64字节是data block的大小，所以一个cache line会大于64字节","like_count":1,"discussions":[{"author":{"id":1254093,"avatar":"https://static001.geekbang.org/account/avatar/00/13/22/cd/d8a5eedf.jpg","nickname":"任颖新","note":"","ucode":"00442DC59B4F83","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583259,"discussion_content":"同样有这个疑问，64字节是否包含有效位和组标记，觉得应该是不包含才对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660003920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142797,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1571537890,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5866505186","product_id":100026001,"comment_content":"老师 那volatile的作用 是不是就是把cache中的有效位 置为0了呢？ <br><br>恳请老师解答！ 谢谢老师！","like_count":1,"discussions":[{"author":{"id":1149084,"avatar":"https://static001.geekbang.org/account/avatar/00/11/88/9c/cbc463e6.jpg","nickname":"仰望星空","note":"","ucode":"A9E46C9FDB3275","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296890,"discussion_content":"这种说法不对，CPU要访问volatile关键字修饰的数据，直接忽略Cache的存在，直接从内存中获取","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596696179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1001893,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","nickname":"小文同学","note":"","ucode":"48F2AEB989C12A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":258257,"discussion_content":"volatile 的作用并没有这么简单。要保证多个CPU对某个地址的变量数据一致，volatile 修饰了w地址，要保证w地址有两个特性：\n1、缓存锁定。就是要放置CPU同时对w地址进行修改。\n2、多CPU的高速缓存失效。这就是 volatile ，这是一种 CPU 缓存一致性协议实现。\n我可能说得不完全对，可以参考一下《Java 并发编程之美》P10页 方腾飞著","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588671017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1310798,"avatar":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","nickname":"吴小智","note":"","ucode":"C7C9F58B5C9F7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40527,"discussion_content":"+1 ，希望老师解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572229879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138244,"user_name":"J.D.Chi","can_delete":false,"product_type":"c1","uid":1035855,"ip_address":"","ucode":"34812AEF95C7AB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ce/4f/3a89d29a.jpg","comment_is_top":false,"comment_ctime":1570112535,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5865079831","product_id":100026001,"comment_content":"图里 Cache Line 0 ~ Cache Line 8 不是 9 个内存块吗？","like_count":1,"discussions":[{"author":{"id":1147453,"avatar":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","nickname":"忆水寒","note":"","ucode":"E3F86BD8AA8903","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312615,"discussion_content":"老师手误，没注意到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602748563,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1476675,"avatar":"https://static001.geekbang.org/account/avatar/00/16/88/43/31641bf0.jpg","nickname":"布朗老熊","note":"","ucode":"A8AF82550AFF9C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":207073,"discussion_content":"07","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584458959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1012528,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/73/30/fd602742.jpg","nickname":"大马猴","note":"","ucode":"E3482CBDF43CDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73808,"discussion_content":"你知道的太多了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575597924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120387,"user_name":"Giacomo","can_delete":false,"product_type":"c1","uid":1478055,"ip_address":"","ucode":"BE5B1E68BCDBB3","user_header":"https://static001.geekbang.org/account/avatar/00/16/8d/a7/2176bbc5.jpg","comment_is_top":false,"comment_ctime":1564863575,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5859830871","product_id":100026001,"comment_content":"老师我想问一下，我记得之前我们学过，内存里有分段和分页，那这里的分块和之前的页有没有什么关系？","like_count":1,"discussions":[{"author":{"id":1250807,"avatar":"https://static001.geekbang.org/account/avatar/00/13/15/f7/744720a2.jpg","nickname":"DriveMan_邱佳源","note":"","ucode":"A4C83BF07DEE7A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":20028,"discussion_content":"内存里的最小存储单位是页大小为4k，这里的分块是cache访问内存的最小单位一块64bit","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1569249796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1478055,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8d/a7/2176bbc5.jpg","nickname":"Giacomo","note":"","ucode":"BE5B1E68BCDBB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1250807,"avatar":"https://static001.geekbang.org/account/avatar/00/13/15/f7/744720a2.jpg","nickname":"DriveMan_邱佳源","note":"","ucode":"A4C83BF07DEE7A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":26420,"discussion_content":"那这个块也是页里面被分好的内存区域咯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570601856,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":20028,"ip_address":""},"score":26420,"extra":""}]}]},{"had_liked":false,"id":356835,"user_name":"Geek_beb011","can_delete":false,"product_type":"c1","uid":1371637,"ip_address":"湖北","ucode":"A6C50FF0200020","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epZFcPycr00N0OqicmnhvESmxG9n8icZJwFRd7QJLRkxYJlRSiaXr6xSsIo8b9OyhoickRUqA2aKspH7Q/132","comment_is_top":false,"comment_ctime":1662626109,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662626109","product_id":100026001,"comment_content":"Cache Line的内存大小应该要等于Block吧？","like_count":0},{"had_liked":false,"id":324313,"user_name":"颜如玉","can_delete":false,"product_type":"c1","uid":2856239,"ip_address":"","ucode":"C55FDAE3559054","user_header":"https://static001.geekbang.org/account/avatar/00/2b/95/2f/d88950a1.jpg","comment_is_top":false,"comment_ctime":1638367273,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638367273","product_id":100026001,"comment_content":"Cache缓存的如果是地址，那么不是同样需要访问内存嘛？这样Cache快在哪里呢？<br>","like_count":0},{"had_liked":false,"id":317897,"user_name":"赵旭圆","can_delete":false,"product_type":"c1","uid":2763465,"ip_address":"","ucode":"32B1FF87B69AF9","user_header":"https://static001.geekbang.org/account/avatar/00/2a/2a/c9/52bbbfc7.jpg","comment_is_top":false,"comment_ctime":1635042515,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635042515","product_id":100026001,"comment_content":"对比内存访问地址的高位，和 Cache 中的组标记，确认 Cache 中的数据就是我们要访问的内存数据，从 Cache Line 中读取到对应的数据块（Data Block）<br>cache line 64kb 中找不到要偏移的数据怎么处理？","like_count":0},{"had_liked":false,"id":311514,"user_name":"Geek_f4fb8b","can_delete":false,"product_type":"c1","uid":2756819,"ip_address":"","ucode":"32114B90BF7060","user_header":"","comment_is_top":false,"comment_ctime":1631264453,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631264453","product_id":100026001,"comment_content":"func TestIterateArr(t *testing.T) {<br>\tarr := new([10000][10000]int)<br><br>\tret := 0<br>\tstart := time.Now()<br>\tfor i, _ := range arr {<br>\t\tfor j, _ := range arr[i] {<br>\t\t\tret += arr[i][j]<br>\t\t}<br>\t}<br>\tfmt.Printf(&quot;line time spent:%f\\n&quot;, time.Since(start).Seconds())<br><br>\tstart2 := time.Now()<br>\tfor i, _ := range arr {<br>\t\tfor j, _ := range arr[i] {<br>\t\t\tret += arr[j][i]<br>\t\t}<br>\t}<br>\tfmt.Printf(&quot;column time spent:%f\\n&quot;, time.Since(start2).Seconds())<br>}<br>=== RUN   TestIterateArr<br>line time spent:0.027328<br>column time spent:0.026382<br>--- PASS: TestIterateArr (0.06s)<br>差别不大?","like_count":0},{"had_liked":false,"id":280260,"user_name":"红薯板栗","can_delete":false,"product_type":"c1","uid":2413071,"ip_address":"","ucode":"236BE91291A575","user_header":"https://static001.geekbang.org/account/avatar/00/24/d2/0f/8f14c85b.jpg","comment_is_top":false,"comment_ctime":1614145032,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614145032","product_id":100026001,"comment_content":"数组在内存中按行连续存储，从内存中读取数据到cpu cache按block读取。如果是按行迭代能增加CPU cache的命中率，空间局部利用率高","like_count":0},{"had_liked":false,"id":272981,"user_name":"今夜秋风和","can_delete":false,"product_type":"c1","uid":1434066,"ip_address":"","ucode":"453C8197FFC81D","user_header":"https://static001.geekbang.org/account/avatar/00/15/e1/d2/42ad2c87.jpg","comment_is_top":false,"comment_ctime":1610376253,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610376253","product_id":100026001,"comment_content":"cacheline 的有效位指的是当前每个所加载的内存块的数据是否有效的码，如果有多个内存块，则每个内存块都有自己的有效位标记","like_count":0},{"had_liked":false,"id":240720,"user_name":"Eleven","can_delete":false,"product_type":"c1","uid":1168452,"ip_address":"","ucode":"FB4A0C8CA732BE","user_header":"https://static001.geekbang.org/account/avatar/00/11/d4/44/0ec958f4.jpg","comment_is_top":false,"comment_ctime":1597044683,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597044683","product_id":100026001,"comment_content":"这个时候，在对应的缓存块中，我们会存储一个组标记（Tag）。这个组标记会记录，当前缓存块内存储的数据对应的内存块，而缓存块本身的地址表示访问地址的低 N 位。就像上面的例子，21 的低 3 位 101，缓存块本身的地址已经涵盖了对应的信息、对应的组标记，我们只需要记录 21 剩余的高 2 位的信息，也就是 10 就可以了。<br><br>这段话最后的顿号和逗号是不是有问题？<br>应该改成：<br>缓存块本身的地址已经涵盖了对应的信息，对应的组标记我们只需要记录 21 剩余的高 2 位的信息，也就是 10 就可以了。<br><br>会害死人的！看半天总觉得不对！","like_count":0},{"had_liked":false,"id":222429,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1590805007,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590805007","product_id":100026001,"comment_content":"按行遍历，可以将每次加载到cache中的数据块遍历完之后，再加载数组在内存中的下一个内存块。<br>按列遍历，每次将加载到cache中的数据块只遍历一个元素，而不是像按列遍历一样从头至尾遍历完所有行元素，就需要加载下一个列元素所在的行在内存中的物理块。<br>这样，每个行就要加载这个行所对应的行元素个数次，将时间完全浪费在了数据不断重复的从内存加载到cache上。从而导致：列遍历的时间在大量元素的情况下，远远高于行遍历。","like_count":0},{"had_liked":false,"id":197430,"user_name":"雷刚","can_delete":false,"product_type":"c1","uid":1655725,"ip_address":"","ucode":"115FE2BE1AAB61","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/pTD8nS0SsORKiaRD3wB0NK9Bpd0wFnPWtYLPfBRBhvZ68iaJErMlM2NNSeEibwQfY7GReILSIYZXfT9o8iaicibcyw3g/132","comment_is_top":false,"comment_ctime":1585377320,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585377320","product_id":100026001,"comment_content":"要想确定一个内存地址在缓存中的映射关系，主要是确定索引号和偏移量。 CPU Cache 直接映射类似 HashMap，也是通过求余来建立映射关系，当然也无法避免哈希碰撞。CPU 判断这是不是我们想要访问的数据时，最简单的办法当然是在缓存中存储完整真实的物理内存地址，但这样太浪费空间了，CPU 做了一个折中，用高位代表组标记，低位代表索引号。最终通过 &quot;索引 + 组标记 + 偏移量&quot; 来建立映射关系。","like_count":0},{"had_liked":false,"id":186092,"user_name":"三件事","can_delete":false,"product_type":"c1","uid":1055819,"ip_address":"","ucode":"BCC867C8961A24","user_header":"https://static001.geekbang.org/account/avatar/00/10/1c/4b/2e5df06f.jpg","comment_is_top":false,"comment_ctime":1583755348,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1583755348","product_id":100026001,"comment_content":"“而在上面的循环 2 里面，我们每隔 16 个整型数计算一次，16 个整型数正好是 64 个字节。于是，循环 1 和循环 2，需要把同样数量的 Cache Line 数据从内存中读取到 CPU Cache 中，最终两个程序花费的时间就差别不大了。”<br><br>没太明白为啥16个整型数正好是64个字节，就会两个程序花费的时间差别不大了？","like_count":0,"discussions":[{"author":{"id":1441830,"avatar":"https://static001.geekbang.org/account/avatar/00/16/00/26/a80010f0.jpg","nickname":"JL","note":"","ucode":"07BD8069AE2CBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":240059,"discussion_content":"&#34;16个整型数正好是64个字节&#34;, 64bytes 正好是cache line的大小。每次都是按cache line 为单位load的，所以 跳跃一个int 和 跳跃16个int，对于cpu来说都是 load 一个cache line， 所以时间大致相同。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587322324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1730160,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/O3Uf8dibBnKKzibgEhvvKs9vic0dBavSJzn79fZVtH0AxcUT09bvOAYvr2f7vecmwiao7BBGgE5p8lXHSoBMdmQuBw/132","nickname":"赵","note":"","ucode":"EAC4390FD95EF9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1441830,"avatar":"https://static001.geekbang.org/account/avatar/00/16/00/26/a80010f0.jpg","nickname":"JL","note":"","ucode":"07BD8069AE2CBD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312595,"discussion_content":"按照你的意思来说，我感觉跳跃1~16个int，对于CPU都是没有区别的，只有超过16个int，CPU  load  的 cache line  数量才会减少，不知道我理解的是否正确？ ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602743622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":240059,"ip_address":""},"score":312595,"extra":""},{"author":{"id":1441830,"avatar":"https://static001.geekbang.org/account/avatar/00/16/00/26/a80010f0.jpg","nickname":"JL","note":"","ucode":"07BD8069AE2CBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1730160,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/O3Uf8dibBnKKzibgEhvvKs9vic0dBavSJzn79fZVtH0AxcUT09bvOAYvr2f7vecmwiao7BBGgE5p8lXHSoBMdmQuBw/132","nickname":"赵","note":"","ucode":"EAC4390FD95EF9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327383,"discussion_content":"不记得背景是什么了。 效率提高是因为 cacheline load一次 能处理多个int 还是 每次load cachheline 只能处理一个int。 如果连续两个int 跨度过大 肯定是要load 两次，如果 两个int紧挨着，那很可能load 一次就够了。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605815676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312595,"ip_address":""},"score":327383,"extra":""}]}]},{"had_liked":false,"id":182805,"user_name":"深水蓝","can_delete":false,"product_type":"c1","uid":1637933,"ip_address":"","ucode":"3E3B195DE54DE1","user_header":"https://static001.geekbang.org/account/avatar/00/18/fe/2d/e23fc6ee.jpg","comment_is_top":false,"comment_ctime":1582868903,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1582868903","product_id":100026001,"comment_content":"其实为什么内存的发展速度一直都比CPU的发展速度慢呢？而且也随着CPU的快速发展，CPU的速度远远快与内存的时候，为什么不能继续增加内存的通道数呢？甚至在一条内存的接口中实现多条内存通道。","like_count":0,"discussions":[{"author":{"id":1009527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/77/c1310aad.jpg","nickname":"剑衣清风","note":"","ucode":"470CD81F6612F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333672,"discussion_content":"可以看看 NUMA","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607590284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179552,"user_name":"Geek_aa8017","can_delete":false,"product_type":"c1","uid":1748911,"ip_address":"","ucode":"286195887103C2","user_header":"","comment_is_top":false,"comment_ctime":1582030508,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1582030508","product_id":100026001,"comment_content":"高速缓存每次都是从内存中读取一个块的数据，这个块有64字节，假如一个整型是4个字节，那么这个块可以放16个数，读完这16个数时高速缓存才会又去内存读下一个块吗？","like_count":0,"discussions":[{"author":{"id":1149084,"avatar":"https://static001.geekbang.org/account/avatar/00/11/88/9c/cbc463e6.jpg","nickname":"仰望星空","note":"","ucode":"A9E46C9FDB3275","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296892,"discussion_content":"是的，当读完后CPU核再从Cache中获取数据时会发生Cache Miss，这时会从内存中重新读取64字节的数据到Cache中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596696476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163427,"user_name":"once","can_delete":false,"product_type":"c1","uid":1453187,"ip_address":"","ucode":"033281FC1DAB37","user_header":"https://static001.geekbang.org/account/avatar/00/16/2c/83/f85ba9cd.jpg","comment_is_top":false,"comment_ctime":1576720115,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576720115","product_id":100026001,"comment_content":"老师你好 第17章中你对cpu cycle的定义是        所以我们一般把从内存里面读取一条指令的最短时间，称为 CPU 周期。           但是这章里说内存访问一般需要120个cpu cycle。感觉我对cpu周期的概念又含糊不清了","like_count":0},{"had_liked":false,"id":143614,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1571744661,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1571744661","product_id":100026001,"comment_content":"讲的非常透彻赞。<br>课后习题，由于二维数组在内存中是按照行存放的。按行遍历，下一条数据大概率在Cache line中，因而耗时较短。<br>public class ArrCacheLineTest {<br>    public static void main(String[] args){<br>        int[][] arr = new int[6400][6400];<br>        long start = System.currentTimeMillis();<br>        int sum = 0;<br>        for(int i=0; i&lt;arr.length; i++){<br>            for(int j=0; j&lt;arr[i].length; j++){<br>               sum += arr[i][j];<br>            }<br>        }<br>        &#47;&#47;31ms, 由于数据是按照行放的，按行遍历，下一条数据大概在Cache line中，因而耗时较短。<br>        System.out.println(&quot;sum &quot;+ sum  +&quot; time =&quot;+(System.currentTimeMillis() - start));<br>        for(int i=0; i&lt;arr.length; i++){<br>            for(int j=0; j&lt;arr[i].length; j++){<br>                sum += arr[j][i];<br>            }<br>        }<br>        &#47;&#47;1610<br>        System.out.println(&quot;sum &quot;+ sum  +&quot; time =&quot;+(System.currentTimeMillis() - start));<br>    }<br>}","like_count":1,"discussions":[{"author":{"id":1136133,"avatar":"https://static001.geekbang.org/account/avatar/00/11/56/05/152830ea.jpg","nickname":"空亦非空","note":"","ucode":"6F144ADA082550","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590203,"discussion_content":"谢谢分享","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665614325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130208,"user_name":"活的潇洒","can_delete":false,"product_type":"c1","uid":1238830,"ip_address":"","ucode":"666C30CA894754","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/2e/1522a7d6.jpg","comment_is_top":false,"comment_ctime":1567403709,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1567403709","product_id":100026001,"comment_content":"“对自己狠一点，发现还是有潜力可挖”<br><br>day37 天笔记：https:&#47;&#47;www.cnblogs.com&#47;luoahong&#47;p&#47;11359393.html","like_count":0,"discussions":[{"author":{"id":1012528,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/73/30/fd602742.jpg","nickname":"大马猴","note":"","ucode":"E3482CBDF43CDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71996,"discussion_content":"农夫山泉啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575467966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2119325,"avatar":"https://static001.geekbang.org/account/avatar/00/20/56/9d/4b2a7d29.jpg","nickname":"ryanxw","note":"","ucode":"0B91EAC8D06EED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1012528,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/73/30/fd602742.jpg","nickname":"大马猴","note":"","ucode":"E3482CBDF43CDE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":533255,"discussion_content":"这个人属实是有点问题，每章都照搬，不知道图啥，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637825580,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":71996,"ip_address":""},"score":533255,"extra":"{\"user_type\":1}"}]}]},{"had_liked":false,"id":129988,"user_name":"焰火","can_delete":false,"product_type":"c1","uid":1244606,"ip_address":"","ucode":"D3353B386DE3B5","user_header":"https://static001.geekbang.org/account/avatar/00/12/fd/be/079c78c7.jpg","comment_is_top":false,"comment_ctime":1567347755,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1567347755","product_id":100026001,"comment_content":"精妙~~","like_count":0},{"had_liked":false,"id":115449,"user_name":"coder","can_delete":false,"product_type":"c1","uid":1399673,"ip_address":"","ucode":"929E3FFD14EFC8","user_header":"https://static001.geekbang.org/account/avatar/00/15/5b/79/d55044ac.jpg","comment_is_top":false,"comment_ctime":1563590518,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563590518","product_id":100026001,"comment_content":"徐老师，你好，请教您一个问题：对于指令跟数据分开的哈弗架构，数据cache按照文中提的那几种方式很好理解，<br>那么指令cache也是按照全相联，组相联的方式管理的吗？","like_count":0},{"had_liked":false,"id":115415,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1563584621,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1563584621","product_id":100026001,"comment_content":"按行，1，空间局部性。2，提高使用cache line命中率<br>时间就是金钱！！！","like_count":0},{"had_liked":false,"id":115247,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1563517837,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1563517837","product_id":100026001,"comment_content":"老师你好，内存地址的表示形式可以说一下吗，不是还有操作系统的虚拟内存地址吗，这一块是怎么直接映射的？","like_count":0,"discussions":[{"author":{"id":1484184,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","nickname":"djfhchdh","note":"","ucode":"E71D75328CE398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2397,"discussion_content":"我感觉这里的内存地址应该是物理地址了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563537271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115236,"user_name":"gigglesun","can_delete":false,"product_type":"c1","uid":1012912,"ip_address":"","ucode":"7AE6C7DCE06063","user_header":"","comment_is_top":false,"comment_ctime":1563515750,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563515750","product_id":100026001,"comment_content":"比如我有一个int变量的地址，假设是32位，去取它的值，怎么从缓存获得？这个过程是什么，感觉缺了offset的信息呀","like_count":0},{"had_liked":false,"id":115191,"user_name":"humor","can_delete":false,"product_type":"c1","uid":1181867,"ip_address":"","ucode":"9B48C4C7BEC92C","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/ab/caec7bca.jpg","comment_is_top":false,"comment_ctime":1563504680,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563504680","product_id":100026001,"comment_content":"按行快，按行可以充分利用CPU cache一次加载的内存，按列的话CPU cache利用率比较低。一次加载16个整数，速度大概相差16倍吧","like_count":0},{"had_liked":false,"id":115180,"user_name":"Linuxer","can_delete":false,"product_type":"c1","uid":1153978,"ip_address":"","ucode":"272D9D8089C3D6","user_header":"https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg","comment_is_top":false,"comment_ctime":1563504032,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563504032","product_id":100026001,"comment_content":"有一个问题请教，要表示cache的索引和偏移3个位不够啊，至少要七位啊","like_count":0},{"had_liked":false,"id":115169,"user_name":"Linuxer","can_delete":false,"product_type":"c1","uid":1153978,"ip_address":"","ucode":"272D9D8089C3D6","user_header":"https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg","comment_is_top":false,"comment_ctime":1563502658,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563502658","product_id":100026001,"comment_content":"一行一行处理，高速缓存命中率更高吧","like_count":0},{"had_liked":false,"id":115092,"user_name":"安排","can_delete":false,"product_type":"c1","uid":1260026,"ip_address":"","ucode":"F78CFA9624CAEF","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg","comment_is_top":false,"comment_ctime":1563493775,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563493775","product_id":100026001,"comment_content":"cache和mmu位置关系是怎么样的？哪个在前哪个在后？","like_count":1}]}