{"id":100105,"title":"15 | Python对象的比较、拷贝","content":"<p>你好，我是景霄。</p><p>在前面的学习中，我们其实已经接触到了很多  Python对象比较和复制的例子，比如下面这个，判断a和b是否相等的if语句：</p><pre><code>if a == b:\n    ...\n</code></pre><p>再比如第二个例子，这里l2就是l1的拷贝。</p><pre><code>l1 = [1, 2, 3]\nl2 = list(l1)\n</code></pre><p>但你可能并不清楚，这些语句的背后发生了什么。比如，</p><ul>\n<li>l2是l1的浅拷贝（shallow copy）还是深度拷贝（deep copy）呢？</li>\n<li><code>a == b</code>是比较两个对象的值相等，还是两个对象完全相等呢？</li>\n</ul><p>关于这些的种种知识，我希望通过这节课的学习，让你有个全面的了解。</p><h2><code>'=='</code> VS <code>'is'</code></h2><p>等于（==）和is是Python中对象比较常用的两种方式。简单来说，<code>'=='</code>操作符比较对象之间的值是否相等，比如下面的例子，表示比较变量a和b所指向的值是否相等。</p><pre><code>a == b\n</code></pre><p>而<code>'is'</code>操作符比较的是对象的身份标识是否相等，即它们是否是同一个对象，是否指向同一个内存地址。</p><p>在Python中，每个对象的身份标识，都能通过函数id(object)获得。因此，<code>'is'</code>操作符，相当于比较对象之间的ID是否相等，我们来看下面的例子：</p><pre><code>a = 10\nb = 10\n\na == b\nTrue\n\nid(a)\n4427562448\n\nid(b)\n4427562448\n\na is b\nTrue\n</code></pre><p>这里，首先Python会为10这个值开辟一块内存，然后变量a和b同时指向这块内存区域，即a和b都是指向10这个变量，因此a和b的值相等，id也相等，<code>a == b</code>和<code>a is b</code>都返回True。</p><!-- [[[read_end]]] --><p>不过，需要注意，对于整型数字来说，以上<code>a is b</code>为True的结论，只适用于-5到256范围内的数字。比如下面这个例子：</p><pre><code>a = 257\nb = 257\n\na == b\nTrue\n\nid(a)\n4473417552\n\nid(b)\n4473417584\n\na is b\nFalse\n</code></pre><p>这里我们把257同时赋值给了a和b，可以看到<code>a == b</code>仍然返回True，因为a和b指向的值相等。但奇怪的是，<code>a is b</code>返回了false，并且我们发现，a和b的ID不一样了，这是为什么呢？</p><p>事实上，出于对性能优化的考虑，Python内部会对-5到256的整型维持一个数组，起到一个缓存的作用。这样，每次你试图创建一个-5到256范围内的整型数字时，Python都会从这个数组中返回相对应的引用，而不是重新开辟一块新的内存空间。</p><p>但是，如果整型数字超过了这个范围，比如上述例子中的257，Python则会为两个257开辟两块内存区域，因此a和b的ID不一样，<code>a is b</code>就会返回False了。</p><p>通常来说，在实际工作中，当我们比较变量时，使用<code>'=='</code>的次数会比<code>'is'</code>多得多，因为我们一般更关心两个变量的值，而不是它们内部的存储地址。但是，当我们比较一个变量与一个单例（singleton）时，通常会使用<code>'is'</code>。一个典型的例子，就是检查一个变量是否为None：</p><pre><code>if a is None:\n      ...\n\nif a is not None:\n      ...\n</code></pre><p>这里注意，比较操作符<code>'is'</code>的速度效率，通常要优于<code>'=='</code>。因为<code>'is'</code>操作符不能被重载，这样，Python就不需要去寻找，程序中是否有其他地方重载了比较操作符，并去调用。执行比较操作符<code>'is'</code>，就仅仅是比较两个变量的ID而已。</p><p>但是<code>'=='</code>操作符却不同，执行<code>a == b</code>相当于是去执行<code>a.__eq__(b)</code>，而Python大部分的数据类型都会去重载<code>__eq__</code>这个函数，其内部的处理通常会复杂一些。比如，对于列表，<code>__eq__</code>函数会去遍历列表中的元素，比较它们的顺序和值是否相等。</p><p>不过，对于不可变（immutable）的变量，如果我们之前用<code>'=='</code>或者<code>'is'</code>比较过，结果是不是就一直不变了呢？</p><p>答案自然是否定的。我们来看下面一个例子：</p><pre><code>t1 = (1, 2, [3, 4])\nt2 = (1, 2, [3, 4])\nt1 == t2\nTrue\n\nt1[-1].append(5)\nt1 == t2\nFalse\n</code></pre><p>我们知道元组是不可变的，但元组可以嵌套，它里面的元素可以是列表类型，列表是可变的，所以如果我们修改了元组中的某个可变元素，那么元组本身也就改变了，之前用<code>'is'</code>或者<code>'=='</code>操作符取得的结果，可能就不适用了。</p><p>这一点，你在日常写程序时一定要注意，在必要的地方请不要省略条件检查。</p><h2>浅拷贝和深度拷贝</h2><p>接下来，我们一起来看看Python中的浅拷贝（shallow copy）和深度拷贝（deep copy）。</p><p>对于这两个熟悉的操作，我并不想一上来先抛概念让你死记硬背来区分，我们不妨先从它们的操作方法说起，通过代码来理解两者的不同。</p><p>先来看浅拷贝。常见的浅拷贝的方法，是使用数据类型本身的构造器，比如下面两个例子：</p><pre><code>l1 = [1, 2, 3]\nl2 = list(l1)\n\nl2\n[1, 2, 3]\n\nl1 == l2\nTrue\n\nl1 is l2\nFalse\n\ns1 = set([1, 2, 3])\ns2 = set(s1)\n\ns2\n{1, 2, 3}\n\ns1 == s2\nTrue\n\ns1 is s2\nFalse\n</code></pre><p>这里，l2就是l1的浅拷贝，s2是s1的浅拷贝。当然，对于可变的序列，我们还可以通过切片操作符<code>':'</code>完成浅拷贝，比如下面这个列表的例子：</p><pre><code>l1 = [1, 2, 3]\nl2 = l1[:]\n\nl1 == l2\nTrue\n\nl1 is l2\nFalse\n</code></pre><p>当然，Python中也提供了相对应的函数copy.copy()，适用于任何数据类型：</p><pre><code>import copy\nl1 = [1, 2, 3]\nl2 = copy.copy(l1)\n</code></pre><p>不过，需要注意的是，对于元组，使用tuple()或者切片操作符<code>':'</code>不会创建一份浅拷贝，相反，它会返回一个指向相同元组的引用：</p><pre><code>t1 = (1, 2, 3)\nt2 = tuple(t1)\n\nt1 == t2\nTrue\n\nt1 is t2\nTrue\n</code></pre><p>这里，元组(1, 2, 3)只被创建一次，t1和t2同时指向这个元组。</p><p>到这里，对于浅拷贝你应该很清楚了。浅拷贝，是指重新分配一块内存，创建一个新的对象，里面的元素是原对象中子对象的引用。因此，如果原对象中的元素不可变，那倒无所谓；但如果元素可变，浅拷贝通常会带来一些副作用，尤其需要注意。我们来看下面的例子：</p><pre><code>l1 = [[1, 2], (30, 40)]\nl2 = list(l1)\nl1.append(100)\nl1[0].append(3)\n\nl1\n[[1, 2, 3], (30, 40), 100]\n\nl2\n[[1, 2, 3], (30, 40)]\n\nl1[1] += (50, 60)\nl1\n[[1, 2, 3], (30, 40, 50, 60), 100]\n\nl2\n[[1, 2, 3], (30, 40)]\n</code></pre><p>这个例子中，我们首先初始化了一个列表l1，里面的元素是一个列表和一个元组；然后对l1执行浅拷贝，赋予l2。因为浅拷贝里的元素是对原对象元素的引用，因此l2中的元素和l1指向同一个列表和元组对象。</p><p>接着往下看。<code>l1.append(100)</code>，表示对l1的列表新增元素100。这个操作不会对l2产生任何影响，因为l2和l1作为整体是两个不同的对象，并不共享内存地址。操作过后l2不变，l1会发生改变：</p><pre><code>[[1, 2, 3], (30, 40), 100]\n</code></pre><p>再来看，<code>l1[0].append(3)</code>，这里表示对l1中的第一个列表新增元素3。因为l2是l1的浅拷贝，l2中的第一个元素和l1中的第一个元素，共同指向同一个列表，因此l2中的第一个列表也会相对应的新增元素3。操作后l1和l2都会改变：</p><pre><code>l1: [[1, 2, 3], (30, 40), 100]\nl2: [[1, 2, 3], (30, 40)]\n</code></pre><p>最后是<code>l1[1] += (50, 60)</code>，因为元组是不可变的，这里表示对l1中的第二个元组拼接，然后重新创建了一个新元组作为l1中的第二个元素，而l2中没有引用新元组，因此l2并不受影响。操作后l2不变，l1发生改变：</p><pre><code>l1: [[1, 2, 3], (30, 40, 50, 60), 100]\n</code></pre><p>通过这个例子，你可以很清楚地看到使用浅拷贝可能带来的副作用。因此，如果我们想避免这种副作用，完整地拷贝一个对象，你就得使用深度拷贝。</p><p>所谓深度拷贝，是指重新分配一块内存，创建一个新的对象，并且将原对象中的元素，以递归的方式，通过创建新的子对象拷贝到新对象中。因此，新对象和原对象没有任何关联。</p><p>Python中以copy.deepcopy()来实现对象的深度拷贝。比如上述例子写成下面的形式，就是深度拷贝：</p><pre><code>import copy\nl1 = [[1, 2], (30, 40)]\nl2 = copy.deepcopy(l1)\nl1.append(100)\nl1[0].append(3)\n\nl1\n[[1, 2, 3], (30, 40), 100]\n\nl2 \n[[1, 2], (30, 40)]\n</code></pre><p>我们可以看到，无论l1如何变化，l2都不变。因为此时的l1和l2完全独立，没有任何联系。</p><p>不过，深度拷贝也不是完美的，往往也会带来一系列问题。如果被拷贝对象中存在指向自身的引用，那么程序很容易陷入无限循环：</p><pre><code>import copy\nx = [1]\nx.append(x)\n\nx\n[1, [...]]\n\ny = copy.deepcopy(x)\ny\n[1, [...]]\n</code></pre><p>上面这个例子，列表x中有指向自身的引用，因此x是一个无限嵌套的列表。但是我们发现深度拷贝x到y后，程序并没有出现stack overflow的现象。这是为什么呢？</p><p>其实，这是因为深度拷贝函数deepcopy中会维护一个字典，记录已经拷贝的对象与其ID。拷贝过程中，如果字典里已经存储了将要拷贝的对象，则会从字典直接返回，我们来看相对应的源码就能明白：</p><pre><code>def deepcopy(x, memo=None, _nil=[]):\n    &quot;&quot;&quot;Deep copy operation on arbitrary Python objects.\n    \t\n\tSee the module's __doc__ string for more info.\n\t&quot;&quot;&quot;\n\t\n    if memo is None:\n        memo = {}\n    d = id(x) # 查询被拷贝对象x的id\n\ty = memo.get(d, _nil) # 查询字典里是否已经存储了该对象\n\tif y is not _nil:\n\t    return y # 如果字典里已经存储了将要拷贝的对象，则直接返回\n        ...    \n</code></pre><h2>总结</h2><p>今天这节课，我们一起学习了Python中对象的比较和拷贝，主要有下面几个重点内容。</p><ul>\n<li>比较操作符<code>'=='</code>表示比较对象间的值是否相等，而<code>'is'</code>表示比较对象的标识是否相等，即它们是否指向同一个内存地址。</li>\n<li>比较操作符<code>'is'</code>效率优于<code>'=='</code>，因为<code>'is'</code>操作符无法被重载，执行<code>'is'</code>操作只是简单的获取对象的ID，并进行比较；而<code>'=='</code>操作符则会递归地遍历对象的所有值，并逐一比较。</li>\n<li>浅拷贝中的元素，是原对象中子对象的引用，因此，如果原对象中的元素是可变的，改变其也会影响拷贝后的对象，存在一定的副作用。</li>\n<li>深度拷贝则会递归地拷贝原对象中的每一个子对象，因此拷贝后的对象和原对象互不相关。另外，深度拷贝中会维护一个字典，记录已经拷贝的对象及其ID，来提高效率并防止无限递归的发生。</li>\n</ul><h2>思考题</h2><p>最后，我为你留下一道思考题。这节课我曾用深度拷贝，拷贝过一个无限嵌套的列表。那么。当我们用等于操作符<code>'=='</code>进行比较时，输出会是什么呢？是True或者False还是其他？为什么呢？建议你先自己动脑想一想，然后再实际跑一下代码，来检验你的猜想。</p><pre><code>import copy\nx = [1]\nx.append(x)\n\ny = copy.deepcopy(x)\n\n# 以下命令的输出是？\nx == y\n</code></pre><p>欢迎在留言区写下你的答案和学习感想，也欢迎你把这篇文章分享给你的同事、朋友。我们一起交流，一起进步。</p><p></p>","comments":[{"had_liked":false,"id":104438,"user_name":"Jingxiao","can_delete":false,"product_type":"c1","uid":1259521,"ip_address":"","ucode":"EB966BB87132F6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","comment_is_top":true,"comment_ctime":1560754280,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"9.223372429257601e+18","product_id":100026901,"comment_content":"关于思考题：<br>SCAR说的很对，程序会报错：&#39;RecursionError: maximum recursion depth exceeded in comparison&#39;。因为x是一个无限嵌套的列表，y深度拷贝x也是一个无限嵌套的列表，理论上x==y应该返回True，但是x==y内部执行是会递归遍历列表x和y中每一个元素的值，由于x和y是无限嵌套的，因此会stack overflow，报错","like_count":92},{"had_liked":false,"id":102754,"user_name":"SCAR","can_delete":false,"product_type":"c1","uid":1031209,"ip_address":"","ucode":"38C0927FA3C5FC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bc/29/022905e6.jpg","comment_is_top":false,"comment_ctime":1560301902,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"688755069262","product_id":100026901,"comment_content":"应该会出错，因为x是一个无限嵌套的列表，y深拷贝于x，按道理来讲 x == y应该是True的，但进行比较操作符“==”的时候，&#39;==&#39;操作符则会递归地遍历对象的所有值，并逐一比较。而python为了防止栈崩溃，递归的层数是要限定的，不会无休下去，所以到了限定的层数，python解释器会跳出错误。执行了一下代码，也的确是跳出了 RecursionError: maximum recursion depth exceeded in comparison。<br>之前课中做阶乘的例子，如果大于一定的整数，也是会出现递归错误，究其原因也是python的递归层数是有限定的。<br>def factorial(n):<br>    return 1 if n &lt;=1 else n*factorial(n-1)<br>factorial(5000)<br>RecursionError: maximum recursion depth exceeded in comparison<br>在sys模块中有个方法可以得到递归的层数:<br>import sys<br>sys.getrecursionlimit()<br>3000<br>当然你也可以重新设定递归的层数：<br>sys.setrecursionlimit(10000)<br>那是不是可以设定无穷大呢？理论上可以，但你的程序崩溃也是一定的，我的mac内存是16G，如果把递归层数设定到1百万，大概跑到35000层左右，我的服务就挂了。<br>","like_count":161,"discussions":[{"author":{"id":1922298,"avatar":"","nickname":"patience","note":"","ucode":"46BEA083F550A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283462,"discussion_content":"我的递归层数才1000，可能是电脑配置没你的好，所以自动把递归层数放低了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592277470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1009002,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/65/6a/be36c108.jpg","nickname":"ikel","note":"","ucode":"1D5CE7803C1C2B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1922298,"avatar":"","nickname":"patience","note":"","ucode":"46BEA083F550A8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318292,"discussion_content":"我8G内存也是1000","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603699747,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":283462,"ip_address":""},"score":318292,"extra":""},{"author":{"id":2330010,"avatar":"https://static001.geekbang.org/account/avatar/00/23/8d/9a/775d059d.jpg","nickname":"长空","note":"","ucode":"8D430138246651","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1922298,"avatar":"","nickname":"patience","note":"","ucode":"46BEA083F550A8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344538,"discussion_content":"我32G内存才996，应该是python解释器设置的，和电脑配置没啥关系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611493200,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":283462,"ip_address":""},"score":344538,"extra":""}]}]},{"had_liked":false,"id":111744,"user_name":"瞳梦","can_delete":false,"product_type":"c1","uid":1596386,"ip_address":"","ucode":"A86FC44F6321BD","user_header":"","comment_is_top":false,"comment_ctime":1562593511,"is_pvip":false,"discussion_count":11,"race_medal":0,"score":"469714028775","product_id":100026901,"comment_content":"这节没讲好，其实可以简单归纳的：<br>一、赋值:<br><br>在 Python 中，对象的赋值就是简单的对象引用，这点和 C++不同<br><br> <br><br>二、浅拷贝(shallow copy):<br><br> <br><br>浅拷贝会创建新对象，其内容非原对象本身的引用，而是原对象内第一层对象的引用。浅拷贝有三种形式:切片操作、工厂函数、copy 模块中的 copy 函数。<br><br><br>三、深拷贝(deep copy):<br><br>深拷贝只有一种形式，copy 模块中的 deepcopy()函数。深拷贝和浅拷贝对应，深拷贝拷贝了对象的所有元素，包括多层嵌套的元素。因此，它的时间和空间开销要高。<br><br><br>四、拷贝的注意点:<br><br> <br><br>1、对于非容器类型，如数字、字符，以及其他的“原子”类型，没有拷贝一说，产生的都是原对象的引用。<br>2、如果元组变量值包含原子类型对象，即使采用了深拷贝，也只能得到浅拷贝。","like_count":109,"discussions":[{"author":{"id":2281842,"avatar":"","nickname":"Geek_97cfce","note":"","ucode":"4FA103B707B78D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330901,"discussion_content":"一堂課，兩個老師，受益匪淺，謝了兄台","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1606728163,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1450337,"avatar":"https://static001.geekbang.org/account/avatar/00/16/21/61/c914065c.jpg","nickname":"哇哦","note":"","ucode":"FA99F044FCBF26","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":164957,"discussion_content":"“如果元组变量值包含原子类型对象，即使采用了深拷贝，也只能得到浅拷贝。”，那文中的“t1 = (1, 2, 3) t2 = tuple(t1)”算是什么拷贝呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581242816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1928176,"avatar":"","nickname":"qjmykb-001","note":"","ucode":"F23519F8386F59","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1450337,"avatar":"https://static001.geekbang.org/account/avatar/00/16/21/61/c914065c.jpg","nickname":"哇哦","note":"","ucode":"FA99F044FCBF26","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":315291,"discussion_content":"这是使用的工厂函数，应该算是浅拷贝的操作，但是它并不会返回一份浅拷贝，而是返回一个指向相同元组的引用；用下面的例子感受一下：\n    # 元组包含原子类型对象，任何拷贝都失效，只会返回指向相同元组的引用\n    t1 = (1, 2, 3)\n    # t2 = tuple(t1)\n    # t2 = copy.copy(t1)\n    t2 = copy.deepcopy(t1)\n    print(id(t1))\n    print(id(t2))\n    print(t1 == t2)\n    print(t1 is t2)\n\n    # 元组不包含原子类型对象时，深拷贝生效，浅拷贝还是返回指向相同元组的引用\n    t1 = ([1], [2], [3])\n    # t2 = tuple(t1)\n    # t2 = copy.copy(t1)\n    t2 = copy.deepcopy(t1)\n    print(id(t1))\n    print(id(t2))\n    print(t1 == t2)\n    print(t1 is t2)\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1603260912,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":164957,"ip_address":""},"score":315291,"extra":""},{"author":{"id":1525981,"avatar":"https://static001.geekbang.org/account/avatar/00/17/48/dd/259bfbf3.jpg","nickname":"突击坚持","note":"","ucode":"7E1C9D305668A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1450337,"avatar":"https://static001.geekbang.org/account/avatar/00/16/21/61/c914065c.jpg","nickname":"哇哦","note":"","ucode":"FA99F044FCBF26","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403188,"discussion_content":"1.只要没有可变的部分，不用讨论深浅拷贝没有意义(任何原子都不可变，整体就不可变，深复制的意义就没了啊！，并且还多占一份内存)，直接指向对应的引用就好了。\n2.t2 = tuple(t1),这个相当于实例化了一个新的tuple对象再复制给t2,t1只是tuple类实例所需要的一个必须参数，不涉及复制不复制的。\n不知道理解的对不对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634028864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":164957,"ip_address":""},"score":403188,"extra":""}]},{"author":{"id":1265734,"avatar":"https://static001.geekbang.org/account/avatar/00/13/50/46/eca5ab3f.jpg","nickname":"lonn","note":"","ucode":"24FA7E2E16FDD0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553917,"discussion_content":"赞  这老师有点没有清楚","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646133144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1621658,"avatar":"https://static001.geekbang.org/account/avatar/00/18/be/9a/b0b89be3.jpg","nickname":"不动声色满心澎湃","note":"","ucode":"80D8F9E49AF7C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332490,"discussion_content":"这一章，确实讲的不好，看着都觉得绕","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607239695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645602,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/22/e9b0d2b7.jpg","nickname":"Hunter-0x07","note":"","ucode":"F55F31DBB3EE4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330064,"discussion_content":"总结的可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606522634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1257546,"avatar":"https://static001.geekbang.org/account/avatar/00/13/30/4a/8be4b8d3.jpg","nickname":"Gospel","note":"","ucode":"C399412DF3FFE1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293535,"discussion_content":"大佬厉害。尝试了一下，如果是x是一个整型数字1000，y深拷贝了x之后，“==”和“is”的结果都是true，原子类型深浅拷贝结果一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595569727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1281141,"avatar":"https://static001.geekbang.org/account/avatar/00/13/8c/75/cf6bf22d.jpg","nickname":"zhangliqun","note":"","ucode":"95F920A079713A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263935,"discussion_content":"厉害 了，兄嘚\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589267749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1346293,"avatar":"https://static001.geekbang.org/account/avatar/00/14/8a/f5/79cb92fb.jpg","nickname":"陈川","note":"","ucode":"A37B7EEAF40BDA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":131376,"discussion_content":"明白了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578838855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1265071,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4d/af/40db8d4a.jpg","nickname":"呲着牙的野狼","note":"","ucode":"FA586CD4C5C4CD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":82771,"discussion_content":"厉害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576377856,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103015,"user_name":"yshan","can_delete":false,"product_type":"c1","uid":1136788,"ip_address":"","ucode":"A2ECDCDA52B8EE","user_header":"https://static001.geekbang.org/account/avatar/00/11/58/94/c8bc2b59.jpg","comment_is_top":false,"comment_ctime":1560349175,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"285028190711","product_id":100026901,"comment_content":"浅拷贝，不可变的不可变，可变的依旧可变<br>深拷贝，都不可变","like_count":66},{"had_liked":false,"id":102968,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1138652,"ip_address":"","ucode":"8DE0C2FD586EFF","user_header":"https://static001.geekbang.org/account/avatar/00/11/5f/dc/1e1f28b4.jpg","comment_is_top":false,"comment_ctime":1560339819,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"74574783851","product_id":100026901,"comment_content":"x.append(x)为什么会产生无限嵌套的列表呢？","like_count":16,"discussions":[{"author":{"id":1526614,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4b/56/6e4fa81b.jpg","nickname":"Leo","note":"","ucode":"A8C97D54966476","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4230,"discussion_content":"一开始x只有一个元素，[1]，调用append方法时，长度会加1，并准备将新元素写入，x变成[1, [新元素]]，但这个新元素是x自身，x现在已经是[1, [新元素]]，于是你把x放到第一个新元素的位置，x就从[1, [新元素] ] 就变成了[1, [1, [新元素]]]，此时新元素指向的依然是x，所以总会有个新元素。","likes_number":37,"is_delete":false,"is_hidden":false,"ctime":1565244063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1219179,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9a/6b/e8ef2989.jpg","nickname":"云蝈蝈","note":"","ucode":"19B1597DB49819","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294475,"discussion_content":"[1, [1,[1,[1,[1,[1,....]]]]]]  应该是这样吧，最外层长度就是2","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1595900548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1284190,"avatar":"https://static001.geekbang.org/account/avatar/00/13/98/5e/2e697cc4.jpg","nickname":"小小","note":"","ucode":"3046A928FE0076","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40966,"discussion_content":"因为嵌套的是自身，所以对嵌套中任意一级的元素进行修改时，基本元素也就跟着改变.","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1572313221,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102781,"user_name":"hlz-123","can_delete":false,"product_type":"c1","uid":1433586,"ip_address":"","ucode":"B7E5EF0C260BD2","user_header":"","comment_is_top":false,"comment_ctime":1560304598,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"53099912150","product_id":100026901,"comment_content":"# 以下命令的输出是？<br>x == y<br>1. 出现如下错误信息，推测原因是x与y的列表进行一项一项比较，因无限嵌套，导致递归深度失败。<br>   RecursionError: maximum recursion depth exceeded in comparison<br>2. 两个问题，需要老师解答<br>    既然是无限嵌套，为什么x.append(x)没有报错？<br>    运行len(x),结果为2,更是不可理解<br>  <br>","like_count":12,"discussions":[{"author":{"id":1252353,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1c/01/5aaaf5b6.jpg","nickname":"Ben","note":"","ucode":"70351D4FAE47F7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":166,"discussion_content":"列表是可变变量, 存储的一个内存地址引用, 内存中的情况只是在列表对应的内存中追加了一个地址, 这个地址指向哪里不重要\nfor i in x: print(id(i))\nid(x)","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1561211229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102815,"user_name":"张丽娜","can_delete":false,"product_type":"c1","uid":1032331,"ip_address":"","ucode":"D70CFF68E72DAF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c0/8b/0371baee.jpg","comment_is_top":false,"comment_ctime":1560308219,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"48804948475","product_id":100026901,"comment_content":"a = 257<br>b = 257<br>print(id(a))<br>print(id(b))<br>在pycharm中运行结果中一致","like_count":11,"discussions":[{"author":{"id":1013493,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/76/f5/e3f5bd8d.jpg","nickname":"宝仔","note":"","ucode":"A0F17DFF99DB21","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":29373,"discussion_content":"你在Pycharm中运行这段代码是属于同一个代码块，如果对代码块的概念不太了解可以去网上查一下。Python出于对性能的考虑，但凡是不可变对象，在同一个代码块中的对象，只有是值相同的对象，就不会重复创建，而是直接引用已经存在的对象","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1570765959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1524154,"avatar":"https://static001.geekbang.org/account/avatar/00/17/41/ba/ae028565.jpg","nickname":"YqY","note":"","ucode":"73FB936045DCB9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4137,"discussion_content":"你在python解释器里面运行就不会相等","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1565160746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1203396,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5c/c4/3d879507.jpg","nickname":"liuwyfly","note":"","ucode":"B1C3821E9B20E3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40833,"discussion_content":"pycharm，python 3.6\na=-6\nb=-6\nid(a) 和 id(b) 是不一样的\n如果是正数\nid(a) 和 id(b) 是一样的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572274156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1447393,"avatar":"https://static001.geekbang.org/account/avatar/00/16/15/e1/d199f33f.jpg","nickname":"Wesley","note":"","ucode":"C7CBB2ADDA38AA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7600,"discussion_content":"pycharm有特殊优化机制","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567582206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105452,"user_name":"🍎🍎","can_delete":false,"product_type":"c1","uid":1545949,"ip_address":"","ucode":"21C4F1D74ADD87","user_header":"https://static001.geekbang.org/account/avatar/00/17/96/dd/0fb7667d.jpg","comment_is_top":false,"comment_ctime":1561003313,"is_pvip":false,"replies":[{"id":"48267","content":"笔记做的很好","user_name":"作者回复","user_name_real":"Jingxiao","uid":"1259521","ctime":1567150839,"ip_address":"","comment_id":105452,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27330807089","product_id":100026901,"comment_content":"小结：<br>1.  ‘==’ 用于比较值的大小，‘is’用于比较对象的内存地址是否相同，指向同一个内存地址<br><br>2.  对与整数型，范围在（-5 ~ 256 ）之间的整形数，‘==’ 与 ‘is’ 结果相同，原因在于python建立了一个数组缓存，创建对象时直接引用缓存<br><br>3.  浅拷贝：定义：重新分配一片内存，生成新的对象，里面的元素是原对象中子对象的引用。<br>                  生成方法： 可以通过数据构造器（list、set）完成浅拷贝，对于可变序列可以使用切片完成浅拷贝，对于元组而言，tupletuple()和切片不创建浅拷贝，指向相同元组的引用，还可以使用import copy, 使用copy.copy()来进行浅拷贝。<br>                浅拷贝是对元素的引用，所以对于子对象，如果子对象是不可变，没有影响，如果是可变的序列，会带来一些影响<br><br>4.  深拷贝，重新分配一块内存，创建一个新的对象，将原对象中的元素以递归的方式全部拷贝。深拷贝中会维持一个字典，记录已经拷贝的对象以及对象的ID，防止出现无限递归。","like_count":6,"discussions":[{"author":{"id":1259521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","nickname":"Jingxiao","note":"","ucode":"EB966BB87132F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454690,"discussion_content":"笔记做的很好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567150839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102767,"user_name":"随风の","can_delete":false,"product_type":"c1","uid":1307306,"ip_address":"","ucode":"50C25386889CC9","user_header":"https://static001.geekbang.org/account/avatar/00/13/f2/aa/47f2e37d.jpg","comment_is_top":false,"comment_ctime":1560303017,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27330106793","product_id":100026901,"comment_content":"看到文章中对于元组的拷贝, 这里进行一下补充~.  某些情况浅&#47;深拷贝会失效: <br>import copy<br><br>x = 1<br>y = copy.deepcopy(x)<br>x is y  # failed<br>True<br><br>x = &#39;1&#39;<br>y = copy.deepcopy(x)<br>x is y # failed<br>True<br><br>x = (1)<br>y = copy.deepcopy(x)<br>x is y  # failed<br>True<br><br>x = (1,[])<br>y = copy.deepcopy(x)<br>x is y  # succeed<br>False<br><br>当对数值、字符串、仅包含数值&#47;字符串的元组进行浅&#47;深拷贝会失效。 也就是文中所提到的,  会返回一个指向相同数值、字符串、元组的引用~","like_count":6},{"had_liked":false,"id":104769,"user_name":"Dynasterran","can_delete":false,"product_type":"c1","uid":1555793,"ip_address":"","ucode":"C465502F7A0E5F","user_header":"","comment_is_top":false,"comment_ctime":1560831145,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14445733033","product_id":100026901,"comment_content":"没看源码，猜的：<br>1. 为什么 len(x) 是 2。<br>&gt;&gt; x = [1]<br>&gt;&gt; id(x)<br>4378931848<br>&gt;&gt; x.append(x)<br>&gt;&gt; id(x)<br>4378931848<br>&gt;&gt; id(x[0])<br>4304870656<br>&gt;&gt; id(x[1])<br>4378931848<br>&gt;&gt; x[1] is x<br>True<br>&gt;&gt; len(x)<br>2<br><br>2. 为什么 x == y 会报错。<br>‘==’ 搜到 x[1] 时发现 x[1] 指向一个列表 x&#39;，又去遍历这个列表 x&#39; 的每个值，然后发现这个列表里的 x&#39;[1] 又指向一个列表 x&#39;&#39;, ... 实际上 x, x&#39;, x&#39;&#39; 都是同一个，无限循环。","like_count":3},{"had_liked":false,"id":102897,"user_name":"Jon徐","can_delete":false,"product_type":"c1","uid":1206774,"ip_address":"","ucode":"D203B6848C1D9C","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/f6/40c497a3.jpg","comment_is_top":false,"comment_ctime":1560323929,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14445225817","product_id":100026901,"comment_content":"a = 258<br>b = 258<br>在python解释器中使用id查看确实内存地址不同，但是使用vs code同样也是python解释器，内存地址是相同的。<br><br>思考题中 x 是循环嵌套的列表，比较时超过了递归限制报错<br>","like_count":3,"discussions":[{"author":{"id":1268609,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epbyHPGNLu9sDQOs1V6brMcDwia55pyIlP9n62oO6IYS6kIFDnOSON4ugSeBSy6WhDUnYyJC6vtnHQ/132","nickname":"lcqbug","note":"","ucode":"08FA17F21BCEC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261796,"discussion_content":"估计是缓存的数据量不同，python原生解释器只缓存到256","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589007769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102820,"user_name":"明月","can_delete":false,"product_type":"c1","uid":1476588,"ip_address":"","ucode":"D3C649B954A519","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJayib1ZcRfOaoLsdsWZokiaO5tLAdC4uNAicQJRIVXrz9fIchib7QwXibnRrsJaoh5TUlia7faUf36g8Bw/132","comment_is_top":false,"comment_ctime":1560308850,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14445210738","product_id":100026901,"comment_content":"我的x超过256的还是is或者==为true 不知道是不是版本和机器的原因 我的是python3.5.3","like_count":3,"discussions":[{"author":{"id":1524154,"avatar":"https://static001.geekbang.org/account/avatar/00/17/41/ba/ae028565.jpg","nickname":"YqY","note":"","ucode":"73FB936045DCB9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4138,"discussion_content":"你直接在python解释器里运行，不要用pycharm","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1565160800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108249,"user_name":"小池","can_delete":false,"product_type":"c1","uid":1004685,"ip_address":"","ucode":"A1D798A6803FAF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/8d/9081c227.jpg","comment_is_top":false,"comment_ctime":1561705184,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10151639776","product_id":100026901,"comment_content":"x.append(x)会产生递归是因为list对象的append方法本质上是在list末尾追加x的引用，而不是直接添加x指向的实例。但为什么这样不会报栈溢出呢？请问老师，python支持[1, [...]]这种写法的机制是什么？","like_count":2,"discussions":[{"author":{"id":2299599,"avatar":"","nickname":"Geek_150e29","note":"","ucode":"474A435867AEF0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333365,"discussion_content":"我猜这里实际只占了两块内存，第一块内存存的是指向数字1的地址，第二块内存存的是指向第一块内存的首地址","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607507534,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102984,"user_name":"路伴友行","can_delete":false,"product_type":"c1","uid":1506974,"ip_address":"","ucode":"96B54B7EEAEDAD","user_header":"https://static001.geekbang.org/account/avatar/00/16/fe/9e/8165b0a0.jpg","comment_is_top":false,"comment_ctime":1560341874,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10150276466","product_id":100026901,"comment_content":"这样看就明白了：<br>print(id(x[1][1]))<br>print(id(x[1][1][1][1][1][1][1][1]))<br>x 和 y 各自形成了一个闭环","like_count":2},{"had_liked":false,"id":102842,"user_name":"Hoo-Ah","can_delete":false,"product_type":"c1","uid":1306913,"ip_address":"","ucode":"823093A6C7DEE7","user_header":"https://static001.geekbang.org/account/avatar/00/13/f1/21/52e8267b.jpg","comment_is_top":false,"comment_ctime":1560311917,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10150246509","product_id":100026901,"comment_content":"使用列表append自身的时候，没有报递归深度达到最大值的错误，然后我看了list类append方法的源码，里面有这句话Note: new_allocated won&#39;t overflow because the largest possible value is PY_SSIZE_T_MAX * (9 &#47; 8) + 6 which always fits in a size_t. 翻译过来就是新的重载方法不会溢出。使用深拷贝也不会溢出，看源码没看懂。出现错误的原因是因为使用了“==”操作符，因为该操作符会递归的比较里面的值。","like_count":2},{"had_liked":false,"id":102667,"user_name":"KaitoShy","can_delete":false,"product_type":"c1","uid":1038415,"ip_address":"","ucode":"E2E2E9BD3F5048","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d8/4f/65abc6f0.jpg","comment_is_top":false,"comment_ctime":1560293389,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"10150227981","product_id":100026901,"comment_content":"有几个问题：<br>1）a = 257<br>b = 257<br>print(id(a))<br>print(id(b))<br>---------<br>4526886832<br>4526886832 这个和环境有关么？我用VsCode编辑运行和jupter运行的结果不一致。juterNotebook返回的不一样的","like_count":2,"discussions":[{"author":{"id":1524154,"avatar":"https://static001.geekbang.org/account/avatar/00/17/41/ba/ae028565.jpg","nickname":"YqY","note":"","ucode":"73FB936045DCB9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4139,"discussion_content":"pycharm不准确，要在python解释器直接运行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565161006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1268548,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5b/44/dda21bb2.jpg","nickname":"SDH1777","note":"","ucode":"F7336D6C4B1E77","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2669,"discussion_content":"我用pycharm 返回一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563851516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1303713,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e4/a1/178387da.jpg","nickname":"25ma","note":"","ucode":"AB5435B9DB52C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":654,"discussion_content":"我也是使用pycharm 返回值是一样的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561889142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1041031,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/hcuW3Hibz2Yl68OjRUQ2AIEnTjI0ylGOSAdmgOEpTYgel3hdJiaq1QJ2cFIjRO6Jv8xyTwBjR9SyQ17HMr77eZPQ/132","nickname":"michel","note":"","ucode":"9BF44FA89F3B62","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":257,"discussion_content":"是的，可以理解为变量的地址，每次运行都可能不一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561363324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102656,"user_name":"pyhhou","can_delete":false,"product_type":"c1","uid":1256496,"ip_address":"","ucode":"31EF8D50CF91A5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ibZVAmmdAibBeVpUjzwId8ibgRzNk7fkuR5pgVicB5mFSjjmt2eNadlykVLKCyGA0GxGffbhqLsHnhDRgyzxcKUhjg/132","comment_is_top":false,"comment_ctime":1560276177,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10150210769","product_id":100026901,"comment_content":"思考题：<br>一开始猜想是 print True，因为当 x append 自身的时候，程序是没有报错的，返回的结果是：[1, [...]]，我想程序既然没有报错，则 [...] 表示的应该是对应的一个最大限度的值，只是这里它没有将其表示出来；当我们 deepcopy 的时候 y 获得了同样的结果，表示深度拷贝成功；用 == 来比较两个 list 其实是比较里面的值是否相等，所以应该返回 True。<br><br>当然尝试的结果是报错 “RecursionError: maximum recursion depth exceeded in comparison”，我想应该是内部的比较函数递归比较的时候递归深度过长，也就是列表的递归嵌套超过了其限度","like_count":2},{"had_liked":false,"id":105461,"user_name":"lllong33","can_delete":false,"product_type":"c1","uid":1528751,"ip_address":"","ucode":"5D012385994C3D","user_header":"https://static001.geekbang.org/account/avatar/00/17/53/af/e5bf5d08.jpg","comment_is_top":false,"comment_ctime":1561005998,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5855973294","product_id":100026901,"comment_content":"两个注意点，<br>a,b = 257,257 这种写法，引用的同一个地址，a is b 返回True，猜想是由于内部优化了，<br><br>深拷贝中，对不可变的元素，会直接引用<br>import copy<br>l1 = [[1,2],(3,4),[257,258]]<br>l2 = copy.deepcopy(l1)<br>print([id(i) for i in l1], [id(i) for i in l2], , sep=&#39;\\n&#39;)<br>print([id(i) for j in l1 for i in j], [id(i) for j in l2 for i in j], sep=&#39;\\n&#39;)  # 这里地址都相同","like_count":1,"discussions":[{"author":{"id":1051873,"avatar":"https://static001.geekbang.org/account/avatar/00/10/0c/e1/f663213e.jpg","nickname":"拾掇拾掇","note":"","ucode":"D775F374C2A1D3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":169791,"discussion_content":"你用python自带解释器看看，a is b会不会是True","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581646237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105144,"user_name":"converse✪","can_delete":false,"product_type":"c1","uid":1433812,"ip_address":"","ucode":"0CC4C24A6458B6","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/d4/bdd3ed27.jpg","comment_is_top":false,"comment_ctime":1560929368,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5855896664","product_id":100026901,"comment_content":"https:&#47;&#47;i.loli.net&#47;2019&#47;06&#47;19&#47;5d09e0647377872742.png 我画了一个关于浅拷贝的理解。老师看是否合适？此外，求解答为什么会出现x的无限递归？还有为什么len(x)是2","like_count":1},{"had_liked":false,"id":102862,"user_name":"程序员人生","can_delete":false,"product_type":"c1","uid":1113668,"ip_address":"","ucode":"C5C5073D89AAA2","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/44/3e3040ac.jpg","comment_is_top":false,"comment_ctime":1560316114,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5855283410","product_id":100026901,"comment_content":"1，没有执行代码的时候，觉得会打印True<br>2，执行了代码以后，如评论一样RecursionError: maximum recursion depth exceeded in comparison，递归层次过深<br>3，然后把代码 x.append(x) 注释掉，程序就正常返回True。也就是说问题在这行代码上。<br>4，网上search了一下，x.append(x)会产生一个无限嵌套列表（评论也有这么说），y深拷贝了x，也就是y拷贝了每一个x的自对象。<br>5，而==操作符会递归遍历对象所有值，所以出现了递归过深的错误。<br>不知道我的分析对不对？请老师指点","like_count":1},{"had_liked":false,"id":102660,"user_name":"farFlight","can_delete":false,"product_type":"c1","uid":1245211,"ip_address":"","ucode":"B0872D3ECBEC38","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83epbRibsic15KXfGEN3SSjnLhXGyhK2Uyrj5ibBJsKAjicNqtafDaQOLH4xpSJRZD1vmibFPJER1ySmwP9A/132","comment_is_top":false,"comment_ctime":1560288075,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5855255371","product_id":100026901,"comment_content":"deepcopy创建一个新的对象，并且将原对象中的元素，以递归的方式，通过创建新的子对象拷贝到新对象中。因此&#39;x == y&#39;会无限递归对比，出现stack overflow。<br><br>实际运行：<br>x == y<br>Traceback (most recent call last):<br>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;<br>RecursionError: maximum recursion depth exceeded in comparison<br>","like_count":1},{"had_liked":false,"id":355962,"user_name":"晁生贵","can_delete":false,"product_type":"c1","uid":2974279,"ip_address":"广东","ucode":"53EF39358E2BEE","user_header":"","comment_is_top":false,"comment_ctime":1661871384,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661871384","product_id":100026901,"comment_content":"<br>用== 比较实际是执行两个列表的 a.__eq__(b)，底层比较两个列表的数据及引用的值。列表是无线嵌套数据所以会报错（RecursionError: maximum recursion depth exceeded in comparison），超过最大队列深度。<br>","like_count":0},{"had_liked":false,"id":347582,"user_name":"sudo rm -rf *","can_delete":false,"product_type":"c1","uid":2253946,"ip_address":"","ucode":"8373B3478926AD","user_header":"https://static001.geekbang.org/account/avatar/00/22/64/7a/90284972.jpg","comment_is_top":false,"comment_ctime":1654169347,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654169347","product_id":100026901,"comment_content":"1","like_count":0},{"had_liked":false,"id":338081,"user_name":"后乐","can_delete":false,"product_type":"c1","uid":1264163,"ip_address":"","ucode":"058A631CA1A56B","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/23/74bf8518.jpg","comment_is_top":false,"comment_ctime":1647270517,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1647270517","product_id":100026901,"comment_content":"2022&#47;03&#47;14 第2遍 ✅","like_count":0},{"had_liked":false,"id":312411,"user_name":"TheOne","can_delete":false,"product_type":"c1","uid":1582134,"ip_address":"","ucode":"2A359780156A8B","user_header":"https://static001.geekbang.org/account/avatar/00/18/24/36/1c4af368.jpg","comment_is_top":false,"comment_ctime":1631791987,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631791987","product_id":100026901,"comment_content":"浅拷贝：如果是嵌套对象，只复制最外层，里层的对象全部是引用<br>深拷贝：全部复制，除了不可变对象","like_count":0},{"had_liked":false,"id":309816,"user_name":"Geek_f6bfca","can_delete":false,"product_type":"c1","uid":1664242,"ip_address":"","ucode":"94C85F1FC21ABB","user_header":"","comment_is_top":false,"comment_ctime":1630339721,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630339721","product_id":100026901,"comment_content":"# https:&#47;&#47;www.runoob.com&#47;w3cnote&#47;python-understanding-dict-copy-shallow-or-deep.html 参考菜鸟教程<br><br>l1 = [[1, 2], (30, 40)]<br>l2 = list(l1) #浅拷贝(拷贝父对象，不会拷贝对象的内部的子对象), l2 和 l1 是一个独立的对象，但他们的子对象还是指向统一对象（是引用）<br><br>print(l1)<br>print(l2)<br>print(id(l1))<br>print(id(l2))<br><br>l1.append(100)<br>print(&#39;第1次&#39;)<br>print(l1) # 修改对象l1 ，内存指向 [[1, 2], (30, 40), 100] 这个新对象<br>print(l2) # l2 拷贝原始对象的父对象，内存仍然指向 [[1, 2], (30, 40)]<br>print(id(l1))<br>print(id(l2))<br><br><br>l1[0].append(3)<br>print(&#39;第2次&#39;)<br>print(l1) # 修改对象 l1 中的子对象，内存指向 [[1, 2, 3], (30, 40), 100]<br>print(l2) # l2 拷贝原始对象的父对象；但子对象是可变类型，浅复制的前提下， l1 和 l2 指向同一个子对象 [1, 2, 3]<br>print(id(l1))<br>print(id(l2))<br><br>l1[1] += (50, 60)<br>print(&#39;第3次&#39;)<br>print(l1) # 修改对象 l1 中的子对象，内存指向 [[1, 2, 3], (30, 40, 50, 60), 100]<br>print(l2) # l2 拷贝原始对象的父对象； 子对象1是可变类型， 指向同一个对象 [1, 2, 3]； 子对象2是不可变类型， l1 和 l2 指向不同的子对象 ,分别为(30, 40, 50, 60)，(30, 40)<br>print(id(l1))<br>print(id(l2))<br>","like_count":0},{"had_liked":false,"id":308573,"user_name":"Geek_984982","can_delete":false,"product_type":"c1","uid":2739558,"ip_address":"","ucode":"73041C5BA589BC","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKbqPZibwA4Pom4M1ePJ7n8lhJm1OoU58icJNzdjwibAorIpWT5g3ZHUROuLIJ1r5ZBGYVOkkhJW4ia5A/132","comment_is_top":false,"comment_ctime":1629687779,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629687779","product_id":100026901,"comment_content":"x.append(x) 可能是个bug，大家需要多注意下，有时候我们可能希望这样x.append(copy.copy(x)) ","like_count":0},{"had_liked":false,"id":305975,"user_name":"一叶障目","can_delete":false,"product_type":"c1","uid":1152039,"ip_address":"","ucode":"3F214222ED147F","user_header":"https://static001.geekbang.org/account/avatar/00/11/94/27/88529d1f.jpg","comment_is_top":false,"comment_ctime":1628253432,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1628253432","product_id":100026901,"comment_content":"64位机器，python3，两个都是True<br>a = 257<br>b = 257<br>print(a==b)<br>print(a is b)","like_count":0,"discussions":[{"author":{"id":2669560,"avatar":"","nickname":"nobugs,noerros","note":"","ucode":"26B02E441164A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389452,"discussion_content":"在 idea 和在 jupyter 里得到两个不同的结果，是不是和编译器有关","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629280555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":293684,"user_name":"恐龙时代111","can_delete":false,"product_type":"c1","uid":1267455,"ip_address":"","ucode":"F7D92B75EBE92E","user_header":"https://static001.geekbang.org/account/avatar/00/13/56/ff/b5962d96.jpg","comment_is_top":false,"comment_ctime":1621491335,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621491335","product_id":100026901,"comment_content":"老师，为什么现在用python3，对于大于256的整型，赋值给两个变量，依旧内存地址是一样的，比如：<br>a = 260<br>b = 260<br>print(id(a))<br>print(id(b))<br>打印的值都是<br>2291085043696<br>2291085043696","like_count":0},{"had_liked":false,"id":274789,"user_name":"Jacky","can_delete":false,"product_type":"c1","uid":1387735,"ip_address":"","ucode":"B259184BC9E7B7","user_header":"https://static001.geekbang.org/account/avatar/00/15/2c/d7/5b1b09fd.jpg","comment_is_top":false,"comment_ctime":1611157132,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1611157132","product_id":100026901,"comment_content":"额，老师，您的deepcopy 源代码能发一下网址吗？我一直很好奇python一些函数的 c代码实现，但是找不到 源代码。谢谢。","like_count":0},{"had_liked":false,"id":260557,"user_name":"苏慕茗San","can_delete":false,"product_type":"c1","uid":1983745,"ip_address":"","ucode":"1A10835880EA02","user_header":"https://static001.geekbang.org/account/avatar/00/1e/45/01/61f9781c.jpg","comment_is_top":false,"comment_ctime":1605059882,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1605059882","product_id":100026901,"comment_content":"事实上，出于对性能优化的考虑，Python 内部会对 -5 到 256 的整型维持一个数组，起到一个缓存的作用。这样，每次你试图创建一个 -5 到 256 范围内的整型数字时，Python 都会从这个数组中返回相对应的引用，而不是重新开辟一块新的内存空间。<br>据我验证, 这个结论不正确, 即使超过256的值is依然相等的","like_count":0},{"had_liked":false,"id":250893,"user_name":"朱春来","can_delete":false,"product_type":"c1","uid":1371051,"ip_address":"","ucode":"3EF236B95F23AC","user_header":"https://static001.geekbang.org/account/avatar/00/14/eb/ab/a1b9aac5.jpg","comment_is_top":false,"comment_ctime":1601274543,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601274543","product_id":100026901,"comment_content":"关于整数缓存（-5，256）超出后，会创建两个不同的对象。测试使用了如下代码段，在python console和执行python执行脚本时结果不一样。<br><br>python console，符合预期，认为是两个不同的对象<br>python text.py，不符合预期，认为是同一个对象<br><br>请问这是什么原因呢？<br><br>附：代码片段<br>a = 300<br>b = 300<br>print(a is b)","like_count":0},{"had_liked":false,"id":245076,"user_name":"瑞哲","can_delete":false,"product_type":"c1","uid":1502093,"ip_address":"","ucode":"9F170728A055AD","user_header":"https://static001.geekbang.org/account/avatar/00/16/eb/8d/8ee78d3d.jpg","comment_is_top":false,"comment_ctime":1598807715,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598807715","product_id":100026901,"comment_content":"RecursionError: maximum recursion depth exceeded in comparison","like_count":0},{"had_liked":false,"id":238502,"user_name":"凯","can_delete":false,"product_type":"c1","uid":1405256,"ip_address":"","ucode":"60DB11CF72C7B0","user_header":"https://static001.geekbang.org/account/avatar/00/15/71/48/44df7f4e.jpg","comment_is_top":false,"comment_ctime":1596185448,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596185448","product_id":100026901,"comment_content":"再来看，l1[0].append(3)，这里表示对 l1 中的第一个列表新增元素 3。因为 l2 是 l1 的浅拷贝，l2 中的第一个元素和 l1 中的第一个元素，共同指向同一个列表，因此 l2 中的第一个列表也会相对应的新增元素 3。操作后 l1 和 l2 都会改变<br><br><br>=========================================================<br><br>原因： l1[0] 和l2[0] 纸箱的内存地址是一样的，指向同一个数组，所以l1【0】 变化，l2【0】也变化，<br><br><br>有一个疑问：<br>a = 1     b = 1    a和b的内存地址指向同一个，如果给a赋值2，a的指向就变了，能不能直接修改a对应的内存地址的变量，让a、b同时改变。","like_count":0},{"had_liked":false,"id":237451,"user_name":"Run","can_delete":false,"product_type":"c1","uid":1371941,"ip_address":"","ucode":"6738D2F36ACFF6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLMDBq7lqg9ZasC4f21R0axKJRVCBImPKlQF8yOicLLXIsNgsZxsVyN1mbvFOL6eVPluTNgJofwZeA/132","comment_is_top":false,"comment_ctime":1595834050,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595834050","product_id":100026901,"comment_content":"l1 = [1, 2, 3]<br>l2 = list(l1)  # 深拷贝,开辟了新的内存来存储<br>l3 = l1  # 浅拷贝,只拷贝了引用<br>l2[0] = 3<br>print(l1)<br>l3[0] = 4<br>print(l1)","like_count":0},{"had_liked":false,"id":237448,"user_name":"Run","can_delete":false,"product_type":"c1","uid":1371941,"ip_address":"","ucode":"6738D2F36ACFF6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLMDBq7lqg9ZasC4f21R0axKJRVCBImPKlQF8yOicLLXIsNgsZxsVyN1mbvFOL6eVPluTNgJofwZeA/132","comment_is_top":false,"comment_ctime":1595833944,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595833944","product_id":100026901,"comment_content":"有点难受,深拷贝,难道不是开辟了新的内存来存储,浅拷贝,难道不是只拷贝了引用(内存地址)吗","like_count":0},{"had_liked":false,"id":230290,"user_name":"youaresherlock","can_delete":false,"product_type":"c1","uid":1281550,"ip_address":"","ucode":"B4D379C6B50DD4","user_header":"https://static001.geekbang.org/account/avatar/00/13/8e/0e/3fbc418d.jpg","comment_is_top":false,"comment_ctime":1593338494,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593338494","product_id":100026901,"comment_content":"为什么在PycharmIDE中小整数对象池[-5,256]范围不适用了，用的都是同一个解释器，在python shell中符合,但在Pycharm中id都是相同的","like_count":0},{"had_liked":false,"id":226700,"user_name":"patience","can_delete":false,"product_type":"c1","uid":1922298,"ip_address":"","ucode":"46BEA083F550A8","user_header":"","comment_is_top":false,"comment_ctime":1592187316,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592187316","product_id":100026901,"comment_content":"老师，我用的是python3.6，不知道为什么把a和b都赋值为500，a和b的id值都是相等的，是版本导致内存数组的范围扩大了嘛？","like_count":0},{"had_liked":false,"id":225183,"user_name":"胜杰","can_delete":false,"product_type":"c1","uid":1052863,"ip_address":"","ucode":"401806B1660784","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bf/a3a3c6d0.jpg","comment_is_top":false,"comment_ctime":1591676882,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591676882","product_id":100026901,"comment_content":"==: 比较的是两个变量的值是否相等<br>is: 比较的是两个变量的值存放的内存地址是否相等, 也就是他俩对于内存地址的引用是否相等.<br><br>浅拷贝: 重新分配一块内存, 创建一个新的变量, 里面的元素是原对象中子对象的引用. 原对象中可变元素变化后, 新对象因为引用的同一块内存空间所以发生变化. 原对象中不可变元素变化后, 新对象由于不是同样的内存空间, 所以不发生变化.<br>深拷贝: 重新分配一块内存, 创建一个新的变量, 将原对象中的所有元素递归拷贝到新的变量中.","like_count":0},{"had_liked":false,"id":222821,"user_name":"ruicore","can_delete":false,"product_type":"c1","uid":1237301,"ip_address":"","ucode":"D637B7A1446880","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/35/94c1d4c9.jpg","comment_is_top":false,"comment_ctime":1590920157,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1590920157","product_id":100026901,"comment_content":"1. 现在的版本，Python3.7 之后，数字好像只有一份了，所以取 id，会拿到一样的结果。<br><br>x = [0],<br><br>x.append(x) 可以理解为当前 x 的状态是：x = [0, x自身的地址]，所以 len（x） == 2","like_count":0,"discussions":[{"author":{"id":1018685,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/3d/0c3a2fd4.jpg","nickname":"偶尔复活下","note":"","ucode":"18B1D525CD50D3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388819,"discussion_content":"在python解释器里是不一样的，可能pycharm或其他开发工具做过优化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628998168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220459,"user_name":"ShmilyVidian","can_delete":false,"product_type":"c1","uid":1177103,"ip_address":"","ucode":"2B2485B48B8D33","user_header":"https://static001.geekbang.org/account/avatar/00/11/f6/0f/0499db2c.jpg","comment_is_top":false,"comment_ctime":1590246269,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590246269","product_id":100026901,"comment_content":"为什么x.append(x)无线循环就可以运行？","like_count":0},{"had_liked":false,"id":215514,"user_name":"lcqbug","can_delete":false,"product_type":"c1","uid":1268609,"ip_address":"","ucode":"08FA17F21BCEC5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epbyHPGNLu9sDQOs1V6brMcDwia55pyIlP9n62oO6IYS6kIFDnOSON4ugSeBSy6WhDUnYyJC6vtnHQ/132","comment_is_top":false,"comment_ctime":1589007581,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589007581","product_id":100026901,"comment_content":"老师，请教一个python单例的问题，没有找到应该在哪个章节下提问，所以在此提问。python的单例模式怎么写最好呢？","like_count":0},{"had_liked":false,"id":200598,"user_name":"aajidian","can_delete":false,"product_type":"c1","uid":1911735,"ip_address":"","ucode":"6A75185730C6D6","user_header":"https://static001.geekbang.org/account/avatar/00/1d/2b/b7/2d5ade67.jpg","comment_is_top":false,"comment_ctime":1585622318,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585622318","product_id":100026901,"comment_content":"请教一下老师和各位同学，<br>&gt;&gt;&gt; b = &#39;aaaaaasdqweqeqweeq&#39;<br>&gt;&gt;&gt; a = &#39;aaaaaasdqweqeqweeq&#39;<br>&gt;&gt;&gt; a == b<br>True<br>&gt;&gt;&gt; a is b<br>True<br><br>当声明a的时候为什么这个字符串不会另外申请一块内存<br><br>而文中的例子<br>a = 257<br>b = 257<br>a == b<br>True<br>a is b<br>False<br><br>257这个数值就需要另外开辟一块内存呢？","like_count":0},{"had_liked":false,"id":193898,"user_name":"Geek_04e22a","can_delete":false,"product_type":"c1","uid":1184505,"ip_address":"","ucode":"B64FF12EA28BA6","user_header":"https://static001.geekbang.org/account/avatar/00/12/12/f9/7e6e3ac6.jpg","comment_is_top":false,"comment_ctime":1584978572,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584978572","product_id":100026901,"comment_content":"思考题：堆栈溢出异常<br>&#39;==&#39;操作符会递归的遍历对象的所有值，并逐一比较，因为x、y的每一个对象的值相等，并且都是无限循环，所以会堆栈溢出。","like_count":0},{"had_liked":false,"id":193242,"user_name":"Geek_27","can_delete":false,"product_type":"c1","uid":1925957,"ip_address":"","ucode":"908A4172A219BA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL7ZOCns481Zl7VeRk9IdHrAYF8ZpKBJ9LLUaRn7qGoibdZpwzhRmRlGRQBbFVx914qg2p5jZPozDg/132","comment_is_top":false,"comment_ctime":1584886667,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584886667","product_id":100026901,"comment_content":"还是觉得自己有些不足","like_count":0},{"had_liked":false,"id":187924,"user_name":"王大华","can_delete":false,"product_type":"c1","uid":1163590,"ip_address":"","ucode":"7AD5C4B8E93B0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/c1/46/a81f7402.jpg","comment_is_top":false,"comment_ctime":1584278838,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584278838","product_id":100026901,"comment_content":"会摆报错，具体可以参考原文<br>执行a == b相当于是去执行a.__eq__(b)，而 Python 大部分的数据类型都会去重载__eq__这个函数，其内部的处理通常会复杂一些。比如，对于列表，__eq__函数会去遍历列表中的元素，比较它们的顺序和值是否相等。","like_count":0},{"had_liked":false,"id":171509,"user_name":"abin","can_delete":false,"product_type":"c1","uid":1042860,"ip_address":"","ucode":"2A03C554AFC80E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e9/ac/a0d4a510.jpg","comment_is_top":false,"comment_ctime":1578957438,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1578957438","product_id":100026901,"comment_content":"In [227]: x = [ 5678, &#39;abcd&#39;, (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;), None, [&#39;c&#39;,&#39;d&#39;], {7899, 3333} ]<br><br>In [228]: y = copy.deepcopy(x)<br><br>In [229]: [ id(e) for e in x ]<br>Out[229]:<br>[1476285141296,<br> 1476287399920,<br> 1476279051832,<br> 140735866354912,<br> 1476285187848,<br> 1476267835912]<br><br>In [230]: [ id(e) for e in y ]<br>Out[230]:<br>[1476285141296,<br> 1476287399920,<br> 1476279051832,<br> 140735866354912,<br> 1476292482696,<br> 1476267836584]<br><br>我自己做实验的时候，发现深拷贝的时候，列表中不可变对象的元素id没有变化，只有可变对象的id发生了变化，我的理解是只有可变对象进行了重新生成，而不可变对象还是引用。<br>不知道我的操作有问题，还是理解有问题？","like_count":0,"discussions":[{"author":{"id":1051873,"avatar":"https://static001.geekbang.org/account/avatar/00/10/0c/e1/f663213e.jpg","nickname":"拾掇拾掇","note":"","ucode":"D775F374C2A1D3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":169798,"discussion_content":"我猜想对于不可变对象的操作，都会生成新的对象替代，所以python对此就有了优化不会对不可变对象进行操作了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581646499,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162402,"user_name":"酸葡萄","can_delete":false,"product_type":"c1","uid":1154146,"ip_address":"","ucode":"9D059C4FB327C0","user_header":"https://static001.geekbang.org/account/avatar/00/11/9c/62/f625b2bb.jpg","comment_is_top":false,"comment_ctime":1576509673,"is_pvip":false,"replies":[{"id":"62991","content":"浅拷贝会重新分配一块内存，因此l1 == l2会返回false","user_name":"作者回复","user_name_real":"Jingxiao","uid":"1259521","ctime":1577190492,"ip_address":"","comment_id":162402,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1576509673","product_id":100026901,"comment_content":"老师 你好 浅拷贝指向的应该也不是同一块内存吧，如果是的话为什么 is 在浅拷贝中会返回False呢？<br>is比较的不是地址吗？比如下面的例子<br><br><br>l1 = [1, 2, 3]<br>l2 = l1[:]<br><br>l1 == l2<br>True<br><br>l1 is l2<br>False","like_count":0,"discussions":[{"author":{"id":1259521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","nickname":"Jingxiao","note":"","ucode":"EB966BB87132F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478038,"discussion_content":"浅拷贝会重新分配一块内存，因此l1 == l2会返回false","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577190492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1154146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9c/62/f625b2bb.jpg","nickname":"酸葡萄","note":"","ucode":"9D059C4FB327C0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":102619,"discussion_content":"C++里浅拷贝只拷贝指针，结果是多个指针指向同一块内存。python里浅拷贝也拷贝内存了，那深拷贝呢？深拷贝和浅拷贝还有什么区别呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577357053,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1051873,"avatar":"https://static001.geekbang.org/account/avatar/00/10/0c/e1/f663213e.jpg","nickname":"拾掇拾掇","note":"","ucode":"D775F374C2A1D3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1154146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9c/62/f625b2bb.jpg","nickname":"酸葡萄","note":"","ucode":"9D059C4FB327C0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":169800,"discussion_content":"我这样理解：浅拷贝是第一层拷贝；深拷贝是递归的全部拷贝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581646568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":102619,"ip_address":""},"score":169800,"extra":""}]}]},{"had_liked":false,"id":151893,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1573807449,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1573807449","product_id":100026901,"comment_content":"python里的比较分为比较内容(==) ， 和比较地址（is）.<br>拷贝分为浅拷贝和深拷贝。浅拷贝只是把对象第一层的引用拷贝了一遍。深拷贝则遍历整个对象图，把所有的引用都拷贝出来，同时拷贝过的对象不会再次处理。","like_count":0,"discussions":[{"author":{"id":1051873,"avatar":"https://static001.geekbang.org/account/avatar/00/10/0c/e1/f663213e.jpg","nickname":"拾掇拾掇","note":"","ucode":"D775F374C2A1D3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":169804,"discussion_content":"深拷贝以递归的方式，通过创建新的子对象拷贝到新对象中。注意是创建新的子对象而不是引用，引用的话还是跟浅拷贝没区别了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581646734,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151891,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1573807287,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573807287","product_id":100026901,"comment_content":"思考题<br>原以为结果是ture, 毕竟 is 必定相等。<br>结果试验了一下<br>RecursionError: maximum recursion depth exceeded in comparison<br>Python 是不会检查是否已经引用同一对象了","like_count":0},{"had_liked":false,"id":150483,"user_name":"mercy","can_delete":false,"product_type":"c1","uid":1022225,"ip_address":"","ucode":"0843ACF5C72A17","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/11/9f09be94.jpg","comment_is_top":false,"comment_ctime":1573543780,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573543780","product_id":100026901,"comment_content":"思考题：我用浅拷贝，并不会出现深拷贝的问题。为什么，明明都是无限递归","like_count":0},{"had_liked":false,"id":145444,"user_name":"liuwyfly","can_delete":false,"product_type":"c1","uid":1203396,"ip_address":"","ucode":"B1C3821E9B20E3","user_header":"https://static001.geekbang.org/account/avatar/00/12/5c/c4/3d879507.jpg","comment_is_top":false,"comment_ctime":1572274207,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572274207","product_id":100026901,"comment_content":"pycharm，python 3.6<br>a=-6<br>b=-6<br>id(a) 和 id(b) 是不一样的<br>如果是正数<br>id(a) 和 id(b) 是一样的","like_count":0},{"had_liked":false,"id":139709,"user_name":"扶幽","can_delete":false,"product_type":"c1","uid":1322612,"ip_address":"","ucode":"1400EDFF8970D3","user_header":"https://static001.geekbang.org/account/avatar/00/14/2e/74/88c613e0.jpg","comment_is_top":false,"comment_ctime":1570709776,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570709776","product_id":100026901,"comment_content":"学到了","like_count":0},{"had_liked":false,"id":138105,"user_name":"自由民","can_delete":false,"product_type":"c1","uid":1346236,"ip_address":"","ucode":"435C67531697F1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/bc/cb39ed38.jpg","comment_is_top":false,"comment_ctime":1570024796,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570024796","product_id":100026901,"comment_content":"&quot;==&quot;比较对象之间的值是否相等。(比较变量存储的值)<br>&quot;is&quot;是比较对象的身份标志是否相等。(比较对象的地址是否相等，即指针。)<br>还是拿c来做对比吧，浅拷贝指复制对象的指针，复制后的对象与原对象指向同一内存地址，改变一个可能会对另一个产生影响。深拷贝指把原对象的所有元素都完整复制到新对象中，二者内存地址不一样，完全互不影响。<br>思考题:<br>深拷贝，二者内存地址不一样，值由于deepcopy的返回值与原对象不一样，因此用==和is都是False.<br>实际测试结果，==直接报错(递归深度太深)，is是False。说明执行==是调用了对象的相关函数的，然后递归调用……","like_count":0},{"had_liked":false,"id":130551,"user_name":"牧野静风","can_delete":false,"product_type":"c1","uid":1311629,"ip_address":"","ucode":"FB5963F97C23AA","user_header":"https://static001.geekbang.org/account/avatar/00/14/03/8d/38a98dc6.jpg","comment_is_top":false,"comment_ctime":1567482090,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567482090","product_id":100026901,"comment_content":"想问下老师浅拷贝，深度拷贝实际应用中需要怎么用，","like_count":0},{"had_liked":false,"id":127148,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1566569358,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566569358","product_id":100026901,"comment_content":"没跑代码之前，我推测应该是True，因为深度拷贝会递归拷贝每一个子对象，而==操作符又是比较每个对象的内容，因此应该是True，但是跑了代码之后，却是报错，我分析出错的原因可能是：因为x是一个无限嵌套的列表，深度拷贝后y也是一个无限嵌套列表，两者作比较，也是无限递归地对每一个子对象的内容比较，这样肯定就超出了系统的最大递归层次，导致失败。","like_count":0},{"had_liked":false,"id":125496,"user_name":"Fargo","can_delete":false,"product_type":"c1","uid":1018174,"ip_address":"","ucode":"434FC4C5D61750","user_header":"https://static001.geekbang.org/account/avatar/00/0f/89/3e/1976b66f.jpg","comment_is_top":false,"comment_ctime":1566194244,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566194244","product_id":100026901,"comment_content":"a = 300<br>b = 300<br>a is b 在pyhton的IDE内返回 false<br>a is b 在pycharm中  返回的是True<br>在 pycharm 中 &gt;0的不限整数小数都为True","like_count":0},{"had_liked":false,"id":122027,"user_name":"Nick","can_delete":false,"product_type":"c1","uid":1621048,"ip_address":"","ucode":"F6AF580DC1DCBB","user_header":"https://static001.geekbang.org/account/avatar/00/18/bc/38/de0b8d90.jpg","comment_is_top":false,"comment_ctime":1565271466,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565271466","product_id":100026901,"comment_content":"老师您好，我想请教一个问题，可能和这节的主题并没太大关系，是我在看deepcopy源码时遇到的。deepcopy.py中有这么一个函数：<br>def _deepcopy_list(x, memo, deepcopy=deepcopy):<br>    y = []<br>    memo[id(x)] = y<br>    append = y.append<br>    for a in x:<br>        append(deepcopy(a, memo))<br>    return y<br><br>这里面有一句append=y.append,所以后面的append(deepcopy(a, memo))实际上应该就相当于y.append(deepcopy(a, memo))。我想知道append=y.append的目的是什么呢？我之前在看其他一些包的源码时也经常看到这种写法，不懂是为什么。烦请老师不吝赐教。<br>","like_count":0},{"had_liked":false,"id":121393,"user_name":"beiler","can_delete":false,"product_type":"c1","uid":1192989,"ip_address":"","ucode":"0A62FE86617486","user_header":"https://static001.geekbang.org/account/avatar/00/12/34/1d/169cd800.jpg","comment_is_top":false,"comment_ctime":1565133544,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565133544","product_id":100026901,"comment_content":"按理说，第三行代码就该崩了…","like_count":0},{"had_liked":false,"id":117682,"user_name":"至尊宝","can_delete":false,"product_type":"c1","uid":1389537,"ip_address":"","ucode":"DA24D200054026","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqPljnIrvyGQyBhJ3lnqJPGmvO6HrD4MzhjSerjNEiagic6QjGeSIR8AG0F8OoxYGMFWjQrE4ZInxJQ/132","comment_is_top":false,"comment_ctime":1564110576,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564110576","product_id":100026901,"comment_content":"1. ‘==’ 用于比较值的大小，‘is’用于比较对象的内存地址是否相同，指向同一个内存地址<br><br>2. 对与整数型，范围在（-5 ~ 256 ）之间的整形数，‘==’ 与 ‘is’ 结果相同，原因在于python建立了一个数组缓存，创建对象时直接引用缓存<br><br>3. 浅拷贝：定义：重新分配一片内存，生成新的对象，里面的元素是原对象中子对象的引用。<br>                  生成方法： 可以通过数据构造器（list、set）完成浅拷贝，对于可变序列可以使用切片完成浅拷贝，对于元组而言，tupletuple()和切片不创建浅拷贝，指向相同元组的引用，还可以使用import copy, 使用copy.copy()来进行浅拷贝。<br>                浅拷贝是对元素的引用，所以对于子对象，如果子对象是不可变，没有影响，如果是可变的序列，会带来一些影响<br><br>4. 深拷贝，重新分配一块内存，创建一个新的对象，将原对象中的元素以递归的方式全部拷贝。深拷贝中会维持一个字典，记录已经拷贝的对象以及对象的ID，防止出现无限递归。","like_count":0},{"had_liked":false,"id":110680,"user_name":"lllong33","can_delete":false,"product_type":"c1","uid":1528751,"ip_address":"","ucode":"5D012385994C3D","user_header":"https://static001.geekbang.org/account/avatar/00/17/53/af/e5bf5d08.jpg","comment_is_top":false,"comment_ctime":1562313811,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562313811","product_id":100026901,"comment_content":"有个疑惑（天马星空的思绪），可能会有 地址相同，值不同的情况嘛?","like_count":0},{"had_liked":false,"id":109717,"user_name":"且听疯吟","can_delete":false,"product_type":"c1","uid":1159459,"ip_address":"","ucode":"B010B16E5465F4","user_header":"https://static001.geekbang.org/account/avatar/00/11/b1/23/5df1f341.jpg","comment_is_top":false,"comment_ctime":1562081710,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562081710","product_id":100026901,"comment_content":"试了试 提示<br>Traceback (most recent call last):<br>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;<br>RecursionError: maximum recursion depth exceeded in comparison<br>肯定是会递归比较array中的每个元素是否相等。","like_count":0},{"had_liked":false,"id":107362,"user_name":"响雨","can_delete":false,"product_type":"c1","uid":1581705,"ip_address":"","ucode":"C5FB3A3BC68F92","user_header":"https://static001.geekbang.org/account/avatar/00/18/22/89/73397ccb.jpg","comment_is_top":false,"comment_ctime":1561518994,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561518994","product_id":100026901,"comment_content":"为什么浅拷贝 x.append(x) 的y，运行x==y就是True ? <br>为什么x.append(x)能够产生一个无限递归的列表？<br>还望老师解答。<br>深拷贝是因为递归深度的原因报错。<br>","like_count":0},{"had_liked":false,"id":106207,"user_name":"梨花菜","can_delete":false,"product_type":"c1","uid":1319819,"ip_address":"","ucode":"07E102D780558C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/ia0vkBCfcXjmSFLtpdSvGEcOO5wn7CCTiaxwZzySJX8msuuZSYDVM40wdTCSLlzCeG6jEWqZcZUOlwlY7CVDK9NA/132","comment_is_top":false,"comment_ctime":1561207162,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1561207162","product_id":100026901,"comment_content":" L1 = [1,2,3] # 定义列表L1<br>L2 = L1 # L2是L1的浅拷贝<br>&gt;&gt;&gt; L1 == L2<br>True<br>&gt;&gt;&gt; L1 is L2<br>True<br>这些都是正常。<br>因为False<br>&gt;&gt;&gt; id(L1)<br>13816256<br>&gt;&gt;&gt; id(L2)<br>13816256<br><br>&gt;&gt;&gt; L3 = list(L1) # L3是L1的浅拷贝<br>&gt;&gt;&gt; L1 == L3<br>True<br><br>&gt;&gt;&gt; L1 is L3 #这个不明白。<br>False<br>&gt;&gt;&gt; id(L3) # L3是浅拷贝，为什么id不一样 <br>13816336<br><br><br><br>","like_count":0,"discussions":[{"author":{"id":1051873,"avatar":"https://static001.geekbang.org/account/avatar/00/10/0c/e1/f663213e.jpg","nickname":"拾掇拾掇","note":"","ucode":"D775F374C2A1D3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":169816,"discussion_content":"L2 = L1就是把L1的引用给了L2，所以L1 is L2是True，L2不是L1的浅拷贝;L3 = list(L1)才是浅拷贝，创建新的对象把L2的里面的引用都拷贝了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581647691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2320032,"avatar":"https://static001.geekbang.org/account/avatar/00/23/66/a0/c00fb984.jpg","nickname":"你说呢","note":"","ucode":"860F6FED5EFF15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351935,"discussion_content":"你还是没有理解浅拷贝与深拷贝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614521477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1405256,"avatar":"https://static001.geekbang.org/account/avatar/00/15/71/48/44df7f4e.jpg","nickname":"凯","note":"","ucode":"60DB11CF72C7B0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295405,"discussion_content":"我也方类似的错误","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596184570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104732,"user_name":"蚂蚁","can_delete":false,"product_type":"c1","uid":1220962,"ip_address":"","ucode":"4F5C47F21307D9","user_header":"https://static001.geekbang.org/account/avatar/00/12/a1/62/80a864b5.jpg","comment_is_top":false,"comment_ctime":1560823723,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1560823723","product_id":100026901,"comment_content":"为什么是（-5，256）呢？不是（-10，257）或者其他呢？是作者随便定的吗？","like_count":0,"discussions":[{"author":{"id":1051873,"avatar":"https://static001.geekbang.org/account/avatar/00/10/0c/e1/f663213e.jpg","nickname":"拾掇拾掇","note":"","ucode":"D775F374C2A1D3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":169817,"discussion_content":"你需要学习计算机组成和C语言就能知道为什么了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581647735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1524154,"avatar":"https://static001.geekbang.org/account/avatar/00/17/41/ba/ae028565.jpg","nickname":"YqY","note":"","ucode":"73FB936045DCB9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4140,"discussion_content":"你可以问问龟叔","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565161464,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104441,"user_name":"周平","can_delete":false,"product_type":"c1","uid":1047936,"ip_address":"","ucode":"CA1869B139A4F6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fd/80/52763d62.jpg","comment_is_top":false,"comment_ctime":1560755314,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560755314","product_id":100026901,"comment_content":"思考题：出现了RecursionError: maximum recursion depth exceeded in comparison，<br>很奇怪len(x)与len(y)都是2，不是说无限嵌套吗？希望老师能解释解释","like_count":0},{"had_liked":false,"id":103466,"user_name":"小侠龙旋风","can_delete":false,"product_type":"c1","uid":1126441,"ip_address":"","ucode":"073F3924A99835","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/29/d6816ebf.jpg","comment_is_top":false,"comment_ctime":1560441983,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1560441983","product_id":100026901,"comment_content":"1.比较操作符&#39;is&#39;的速度效率，通常要优于&#39;==&#39;。因为&#39;is&#39;操作符不能被重载，这样，Python 就不需要去寻找，程序中是否有其他地方重载了比较操作符，并去调用。执行比较操作符&#39;is&#39;，就仅仅是比较两个变量的 ID 而已。<br>2.list的切片和list()构造函数都是常见的浅拷贝；<br>另外，import copy调用copy.copy(xxx)同样也能做到浅拷贝。<br>tuple是个例外，浅拷贝不会重新分配内存，结果会指向同一份引用，id比较返回True。<br>这是因为上节课中所说的，Python对tuple的缓存优化导致的现象吗？<br>3.文中说到，“深度拷贝...将原对象中的元素，以递归的方式，通过...”。<br>关于deepcopy源码，我是这样理解的：<br>因为Python的递归深度是有限的，超出递归深度会引发RuntimeError异常，为了防止这种不必要的拷贝，做了查询字典检查已存对象的判断。<br><br>思考题：<br>&gt;&gt;&gt; import copy<br>&gt;&gt;&gt; x = [1]<br>&gt;&gt;&gt; x.append(x)<br>&gt;&gt;&gt; x<br>[1, [...]]<br>&gt;&gt;&gt; y=copy.deepcopy(x)<br>&gt;&gt;&gt; x==y<br>Traceback (most recent call last):<br>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;<br>RecursionError: maximum recursion depth exceeded in comparison","like_count":0,"discussions":[{"author":{"id":1051873,"avatar":"https://static001.geekbang.org/account/avatar/00/10/0c/e1/f663213e.jpg","nickname":"拾掇拾掇","note":"","ucode":"D775F374C2A1D3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":169818,"discussion_content":"我猜想tuple例外的原因是因为tuple为不可变对象，对于不可变对象的改变都会创建新对象的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581647980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103416,"user_name":"Lone","can_delete":false,"product_type":"c1","uid":1543230,"ip_address":"","ucode":"7EDE7F9407F1BF","user_header":"https://static001.geekbang.org/account/avatar/00/17/8c/3e/b4ae5ae2.jpg","comment_is_top":false,"comment_ctime":1560430765,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560430765","product_id":100026901,"comment_content":"浅拷贝的例子 让我想起了《流畅的Python》","like_count":0},{"had_liked":false,"id":103362,"user_name":"Wing·三金","can_delete":false,"product_type":"c1","uid":1341402,"ip_address":"","ucode":"6B9F5822C3717F","user_header":"https://static001.geekbang.org/account/avatar/00/14/77/da/54c663f3.jpg","comment_is_top":false,"comment_ctime":1560420461,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560420461","product_id":100026901,"comment_content":"# == VS is<br>- == 符号调用的是 __eq__ 函数，用于递归地比较对象之间的值是否相等<br>- is 的结果取决于 id，即是否指向同一对象<br>- is 操作符无法重载，速度快；== 操作符每次使用 Python 内部需要寻找是否有其他地方重载了比较操作符，而且重载一般会伴随着更复杂的比较处理操作<br><br>## 特殊情况<br>- 出于对性能优化的考虑，-5~256 的整型数字在首次创建时会开辟数组型的缓存，以便重复返回相同的引用<br>```python<br>a = 10<br>b = 10<br>a == b # True<br>a is b # True<br><br>a = 257<br>b = 257<br>a == b # True<br>a is b # False<br>```<br>- 比较变量与单例（Singleton）时通常使用 is，如 if a is None<br>- 通常对于不可变的变量，==&#47;is 的结果是固定的，但是如果子变量是可变的（如 (1,2, [3, 4]) ），那么有可能改变变量<br>```python<br>t1 = (1, [2, 3])<br>t2 = (1, [2, 3])<br>t1 == t2 # True<br><br>t1[1].append(5)<br>t1 == t2 # False<br>```<br><br># 浅拷贝 VS 深拷贝<br>- 浅拷贝重新分配一块内存并创建新对象，但只拷贝对子对象的引用<br>- 深拷贝同样分配新的内存，但是递归地对子对象都分配新的内存，保证不会与原对象“藕断丝连”<br>- 浅拷贝方式：list&#47;set&#47;dict&#47;tuple; :（切片）; copy.copy()<br>```python<br>l1 = [1, 2]<br>l2 = list(l1)<br>l1 == l2 # True<br>l1 is l2 # False<br><br>s1 = {1, 2}<br>s2 = set(s1)<br>s1 == s2 # True<br>s1 is s2 # False<br><br>l1 = [1, 2]<br>l2 = l1[:]<br>l1 == l2 # True<br>l1 is l2 # False<br><br>import copy<br>l1 = [1, 2]<br>l2 = copy.copy(l1)<br>```<br>- 子对象可变时，最好用 copy.deepcopy()<br>```python<br># shallow<br>l1 = [[1, 2], (30, )]<br>l2 = list(l1)<br>l1.append(100) # 对 l2 无影响<br>l1[0].append(3) # 对 l2 有影响！<br>l1[1] += (50, ) # + 表示元组拼接，对 l2 无影响<br><br># deep<br>import copy<br>l1 = [[1, 2], (30, )]<br>l2 = copy.deepcopy(l1) # 任意操作，能互相伤害算我输<br>```<br><br>## 特殊情况<br>- 对于 tuple，使用 tuple() 或切片不会创建浅拷贝<br>```python<br>t1 = (1, 2)<br>t2 = tuple(t1)<br>t1 == t2 # True<br>t1 is t2 # True!!!<br>```<br>- 对于深度拷贝，如果被拷贝对象中存在指向自身的引用，拷贝容易造成无限循环<br>```python<br>x = [1]<br>x.append(x) # x = [1, [...]]<br><br>y = copy.deepcopy(x) # y = [1, [...]]<br><br># 上面这一步事实上不会出现 stack overflow 或程序运行停不下来的情况，why?<br># 原因是 deepcopy 会维护一个字典用于记录已经拷贝的【对象+id】，若字典中已经存储了将要拷贝的对象则直接从字典返回<br><br>x is y # False<br>x == y # RecursionError: maximum recursion depth exceeded in comparison<br><br>z = x<br>z is x # True<br>```","like_count":0},{"had_liked":false,"id":103259,"user_name":"code2","can_delete":false,"product_type":"c1","uid":1281792,"ip_address":"","ucode":"BBA5748FB6A01C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/8OPzdpDraQMvCNWAicicDt54sDaIYJZicBLfMyibXVs4V0ZibEdkZlbzxxL7aGpRoeyvibag5LaAaaGKSdwYQMY2hUrQ/132","comment_is_top":false,"comment_ctime":1560405791,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560405791","product_id":100026901,"comment_content":"递归不能拷贝？","like_count":0},{"had_liked":false,"id":103258,"user_name":"程序员人生","can_delete":false,"product_type":"c1","uid":1113668,"ip_address":"","ucode":"C5C5073D89AAA2","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/44/3e3040ac.jpg","comment_is_top":false,"comment_ctime":1560405504,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560405504","product_id":100026901,"comment_content":"def example2():<br>    print(&#39;example2&#39;)<br>    c = 257<br>    d = 257<br><br>    print(c==d)<br>    print(c is d)<br>    print(id(c))<br>    print(id(d))<br><br>example2（）<br><br>执行结果：<br>example2<br>True<br>True<br>2224777146224<br>2224777146224<br><br>老师，老师，为什么这段代码的执行效果跟文章里面的不一样？？<br>python3.7.2 pycharm","like_count":0},{"had_liked":false,"id":103220,"user_name":"大斌","can_delete":false,"product_type":"c1","uid":1002183,"ip_address":"","ucode":"1434C2B0A29135","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/c7/ec18673b.jpg","comment_is_top":false,"comment_ctime":1560398715,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560398715","product_id":100026901,"comment_content":"超出递归深度，报错：RecursionError: maximum recursion depth exceeded in comparison","like_count":0},{"had_liked":false,"id":102994,"user_name":"NG","can_delete":false,"product_type":"c1","uid":1356009,"ip_address":"","ucode":"7CF4CCE677BB55","user_header":"https://static001.geekbang.org/account/avatar/00/14/b0/e9/d72b9674.jpg","comment_is_top":false,"comment_ctime":1560345663,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560345663","product_id":100026901,"comment_content":"运行代码时报错。原因是进行&quot;==&quot;时需要递归对比每一个元素，该循环是一个无限循环（无限个元素）。然而python专门设置的一种机制用来防止无限递归造成Python溢出崩溃，换句话说不能遍历比较到所有值，所以报错“RecursionError: maximum recursion depth exceeded in comparison”","like_count":0},{"had_liked":false,"id":102872,"user_name":"Linux命令手册","can_delete":false,"product_type":"c1","uid":1069291,"ip_address":"","ucode":"F80776F9F53337","user_header":"https://static001.geekbang.org/account/avatar/00/10/50/eb/a1a2cf00.jpg","comment_is_top":false,"comment_ctime":1560318396,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560318396","product_id":100026901,"comment_content":"if y is not _nil：<br>老师，请问这是什么意思呢，_nil是个list，为什么不用y not in _nil?","like_count":0},{"had_liked":false,"id":102866,"user_name":"John Si","can_delete":false,"product_type":"c1","uid":1526611,"ip_address":"","ucode":"705B90724A4BD4","user_header":"https://static001.geekbang.org/account/avatar/00/17/4b/53/67c08006.jpg","comment_is_top":false,"comment_ctime":1560317563,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560317563","product_id":100026901,"comment_content":"由于 &#39;==&#39; 是递归地遍历对象的所有值，并一一比较，而x, y 对像均是一个无限嵌套列表，所以会进行无数次比较，故会出现stack overflow 错误","like_count":0}]}