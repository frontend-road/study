{"id":89461,"title":"19 | CountDownLatch和CyclicBarrier：如何让多线程步调一致？","content":"<p>前几天老板突然匆匆忙忙过来，说对账系统最近越来越慢了，能不能快速优化一下。我了解了对账系统的业务后，发现还是挺简单的，用户通过在线商城下单，会生成电子订单，保存在订单库；之后物流会生成派送单给用户发货，派送单保存在派送单库。为了防止漏派送或者重复派送，对账系统每天还会校验是否存在异常订单。</p><p>对账系统的处理逻辑很简单，你可以参考下面的对账系统流程图。目前对账系统的处理逻辑是首先查询订单，然后查询派送单，之后对比订单和派送单，将差异写入差异库。</p><p><img src=\"https://static001.geekbang.org/resource/image/06/fe/068418bdc371b8a1b4b740428a3b3ffe.png?wh=1142*626\" alt=\"\"></p><center><span class=\"reference\">对账系统流程图</span></center><p>对账系统的代码抽象之后，也很简单，核心代码如下，就是在一个单线程里面循环查询订单、派送单，然后执行对账，最后将写入差异库。</p><pre><code>while(存在未对账订单){\n  // 查询未对账订单\n  pos = getPOrders();\n  // 查询派送单\n  dos = getDOrders();\n  // 执行对账操作\n  diff = check(pos, dos);\n  // 差异写入差异库\n  save(diff);\n} \n</code></pre><h2>利用并行优化对账系统</h2><p>老板要我优化性能，那我就首先要找到这个对账系统的瓶颈所在。</p><p>目前的对账系统，由于订单量和派送单量巨大，所以查询未对账订单getPOrders()和查询派送单getDOrders()相对较慢，那有没有办法快速优化一下呢？目前对账系统是单线程执行的，图形化后是下图这个样子。对于串行化的系统，优化性能首先想到的是能否<strong>利用多线程并行处理</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/cd/a5/cd997c259e4165c046e79e766abfe2a5.png?wh=1142*507\" alt=\"\"></p><center><span class=\"reference\">对账系统单线程执行示意图</span></center><p>所以，这里你应该能够看出来这个对账系统里的瓶颈：查询未对账订单getPOrders()和查询派送单getDOrders()是否可以并行处理呢？显然是可以的，因为这两个操作并没有先后顺序的依赖。这两个最耗时的操作并行之后，执行过程如下图所示。对比一下单线程的执行示意图，你会发现同等时间里，并行执行的吞吐量近乎单线程的2倍，优化效果还是相对明显的。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/a5/3b/a563c39ece918578ad2ff33ab5f3743b.png?wh=1142*567\" alt=\"\"></p><center><span class=\"reference\">对账系统并行执行示意图</span></center><p>思路有了，下面我们再来看看如何用代码实现。在下面的代码中，我们创建了两个线程T1和T2，并行执行查询未对账订单getPOrders()和查询派送单getDOrders()这两个操作。在主线程中执行对账操作check()和差异写入save()两个操作。不过需要注意的是：主线程需要等待线程T1和T2执行完才能执行check()和save()这两个操作，为此我们通过调用T1.join()和T2.join()来实现等待，当T1和T2线程退出时，调用T1.join()和T2.join()的主线程就会从阻塞态被唤醒，从而执行之后的check()和save()。</p><pre><code>while(存在未对账订单){\n  // 查询未对账订单\n  Thread T1 = new Thread(()-&gt;{\n    pos = getPOrders();\n  });\n  T1.start();\n  // 查询派送单\n  Thread T2 = new Thread(()-&gt;{\n    dos = getDOrders();\n  });\n  T2.start();\n  // 等待T1、T2结束\n  T1.join();\n  T2.join();\n  // 执行对账操作\n  diff = check(pos, dos);\n  // 差异写入差异库\n  save(diff);\n} \n</code></pre><h2>用CountDownLatch实现线程等待</h2><p>经过上面的优化之后，基本上可以跟老板汇报收工了，但还是有点美中不足，相信你也发现了，while循环里面每次都会创建新的线程，而创建线程可是个耗时的操作。所以最好是创建出来的线程能够循环利用，估计这时你已经想到线程池了，是的，线程池就能解决这个问题。</p><p>而下面的代码就是用线程池优化后的：我们首先创建了一个固定大小为2的线程池，之后在while循环里重复利用。一切看上去都很顺利，但是有个问题好像无解了，那就是主线程如何知道getPOrders()和getDOrders()这两个操作什么时候执行完。前面主线程通过调用线程T1和T2的join()方法来等待线程T1和T2退出，但是在线程池的方案里，线程根本就不会退出，所以join()方法已经失效了。</p><pre><code>// 创建2个线程的线程池\nExecutor executor = \n  Executors.newFixedThreadPool(2);\nwhile(存在未对账订单){\n  // 查询未对账订单\n  executor.execute(()-&gt; {\n    pos = getPOrders();\n  });\n  // 查询派送单\n  executor.execute(()-&gt; {\n    dos = getDOrders();\n  });\n  \n  /* ？？如何实现等待？？*/\n  \n  // 执行对账操作\n  diff = check(pos, dos);\n  // 差异写入差异库\n  save(diff);\n}   \n</code></pre><p>那如何解决这个问题呢？你可以开动脑筋想出很多办法，最直接的办法是弄一个计数器，初始值设置成2，当执行完<code>pos = getPOrders();</code>这个操作之后将计数器减1，执行完<code>dos = getDOrders();</code>之后也将计数器减1，在主线程里，等待计数器等于0；当计数器等于0时，说明这两个查询操作执行完了。等待计数器等于0其实就是一个条件变量，用管程实现起来也很简单。</p><p>不过我并不建议你在实际项目中去实现上面的方案，因为Java并发包里已经提供了实现类似功能的工具类：<strong>CountDownLatch</strong>，我们直接使用就可以了。下面的代码示例中，在while循环里面，我们首先创建了一个CountDownLatch，计数器的初始值等于2，之后在<code>pos = getPOrders();</code>和<code>dos = getDOrders();</code>两条语句的后面对计数器执行减1操作，这个对计数器减1的操作是通过调用 <code>latch.countDown();</code> 来实现的。在主线程中，我们通过调用 <code>latch.await()</code> 来实现对计数器等于0的等待。</p><pre><code>// 创建2个线程的线程池\nExecutor executor = \n  Executors.newFixedThreadPool(2);\nwhile(存在未对账订单){\n  // 计数器初始化为2\n  CountDownLatch latch = \n    new CountDownLatch(2);\n  // 查询未对账订单\n  executor.execute(()-&gt; {\n    pos = getPOrders();\n    latch.countDown();\n  });\n  // 查询派送单\n  executor.execute(()-&gt; {\n    dos = getDOrders();\n    latch.countDown();\n  });\n  \n  // 等待两个查询操作结束\n  latch.await();\n  \n  // 执行对账操作\n  diff = check(pos, dos);\n  // 差异写入差异库\n  save(diff);\n}\n</code></pre><h2>进一步优化性能</h2><p>经过上面的重重优化之后，长出一口气，终于可以交付了。不过在交付之前还需要再次审视一番，看看还有没有优化的余地，仔细看还是有的。</p><p>前面我们将getPOrders()和getDOrders()这两个查询操作并行了，但这两个查询操作和对账操作check()、save()之间还是串行的。很显然，这两个查询操作和对账操作也是可以并行的，也就是说，在执行对账操作的时候，可以同时去执行下一轮的查询操作，这个过程可以形象化地表述为下面这幅示意图。</p><p><img src=\"https://static001.geekbang.org/resource/image/e6/8b/e663d90f49d9666e618ac1370ccca58b.png?wh=1142*624\" alt=\"\"></p><center><span class=\"reference\">完全并行执行示意图</span></center><p>那接下来我们再来思考一下如何实现这步优化，两次查询操作能够和对账操作并行，对账操作还依赖查询操作的结果，这明显有点生产者-消费者的意思，两次查询操作是生产者，对账操作是消费者。既然是生产者-消费者模型，那就需要有个队列，来保存生产者生产的数据，而消费者则从这个队列消费数据。</p><p>不过针对对账这个项目，我设计了两个队列，并且两个队列的元素之间还有对应关系。具体如下图所示，订单查询操作将订单查询结果插入订单队列，派送单查询操作将派送单插入派送单队列，这两个队列的元素之间是有一一对应的关系的。两个队列的好处是，对账操作可以每次从订单队列出一个元素，从派送单队列出一个元素，然后对这两个元素执行对账操作，这样数据一定不会乱掉。</p><p><img src=\"https://static001.geekbang.org/resource/image/22/da/22e8ba1c04a3bc2605b98376ed6832da.png?wh=1142*453\" alt=\"\"></p><center><span class=\"reference\">双队列示意图</span></center><p>下面再来看如何用双队列来实现完全的并行。一个最直接的想法是：一个线程T1执行订单的查询工作，一个线程T2执行派送单的查询工作，当线程T1和T2都各自生产完1条数据的时候，通知线程T3执行对账操作。这个想法虽看上去简单，但其实还隐藏着一个条件，那就是线程T1和线程T2的工作要步调一致，不能一个跑得太快，一个跑得太慢，只有这样才能做到各自生产完1条数据的时候，通知线程T3。</p><p>下面这幅图形象地描述了上面的意图：线程T1和线程T2只有都生产完1条数据的时候，才能一起向下执行，也就是说，线程T1和线程T2要互相等待，步调要一致；同时当线程T1和T2都生产完一条数据的时候，还要能够通知线程T3执行对账操作。</p><p><img src=\"https://static001.geekbang.org/resource/image/65/ad/6593a10a393d9310a8f864730f7426ad.png?wh=1142*569\" alt=\"\"></p><center><span class=\"reference\">同步执行示意图</span></center><h2>用CyclicBarrier实现线程同步</h2><p>下面我们就来实现上面提到的方案。这个方案的难点有两个：一个是线程T1和T2要做到步调一致，另一个是要能够通知到线程T3。</p><p>你依然可以利用一个计数器来解决这两个难点，计数器初始化为2，线程T1和T2生产完一条数据都将计数器减1，如果计数器大于0则线程T1或者T2等待。如果计数器等于0，则通知线程T3，并唤醒等待的线程T1或者T2，与此同时，将计数器重置为2，这样线程T1和线程T2生产下一条数据的时候就可以继续使用这个计数器了。</p><p>同样，还是建议你不要在实际项目中这么做，因为Java并发包里也已经提供了相关的工具类：<strong>CyclicBarrier</strong>。在下面的代码中，我们首先创建了一个计数器初始值为2的CyclicBarrier，你需要注意的是创建CyclicBarrier的时候，我们还传入了一个回调函数，当计数器减到0的时候，会调用这个回调函数。</p><p>线程T1负责查询订单，当查出一条时，调用 <code>barrier.await()</code> 来将计数器减1，同时等待计数器变成0；线程T2负责查询派送单，当查出一条时，也调用 <code>barrier.await()</code> 来将计数器减1，同时等待计数器变成0；当T1和T2都调用 <code>barrier.await()</code> 的时候，计数器会减到0，此时T1和T2就可以执行下一条语句了，同时会调用barrier的回调函数来执行对账操作。</p><p>非常值得一提的是，CyclicBarrier的计数器有自动重置的功能，当减到0的时候，会自动重置你设置的初始值。这个功能用起来实在是太方便了。</p><pre><code>// 订单队列\nVector&lt;P&gt; pos;\n// 派送单队列\nVector&lt;D&gt; dos;\n// 执行回调的线程池 \nExecutor executor = \n  Executors.newFixedThreadPool(1);\nfinal CyclicBarrier barrier =\n  new CyclicBarrier(2, ()-&gt;{\n    executor.execute(()-&gt;check());\n  });\n  \nvoid check(){\n  P p = pos.remove(0);\n  D d = dos.remove(0);\n  // 执行对账操作\n  diff = check(p, d);\n  // 差异写入差异库\n  save(diff);\n}\n  \nvoid checkAll(){\n  // 循环查询订单库\n  Thread T1 = new Thread(()-&gt;{\n    while(存在未对账订单){\n      // 查询订单库\n      pos.add(getPOrders());\n      // 等待\n      barrier.await();\n    }\n  });\n  T1.start();  \n  // 循环查询运单库\n  Thread T2 = new Thread(()-&gt;{\n    while(存在未对账订单){\n      // 查询运单库\n      dos.add(getDOrders());\n      // 等待\n      barrier.await();\n    }\n  });\n  T2.start();\n}\n</code></pre><h2>总结</h2><p>CountDownLatch和CyclicBarrier是Java并发包提供的两个非常易用的线程同步工具类，这两个工具类用法的区别在这里还是有必要再强调一下：<strong>CountDownLatch主要用来解决一个线程等待多个线程的场景</strong>，可以类比旅游团团长要等待所有的游客到齐才能去下一个景点；而<strong>CyclicBarrier是一组线程之间互相等待</strong>，更像是几个驴友之间不离不弃。除此之外CountDownLatch的计数器是不能循环利用的，也就是说一旦计数器减到0，再有线程调用await()，该线程会直接通过。但<strong>CyclicBarrier的计数器是可以循环利用的</strong>，而且具备自动重置的功能，一旦计数器减到0会自动重置到你设置的初始值。除此之外，CyclicBarrier还可以设置回调函数，可以说是功能丰富。</p><p>本章的示例代码中有两处用到了线程池，你现在只需要大概了解即可，因为线程池相关的知识咱们专栏后面还会有详细介绍。另外，线程池提供了Future特性，我们也可以利用Future特性来实现线程之间的等待，这个后面我们也会详细介绍。</p><h2>课后思考</h2><p>本章最后的示例代码中，CyclicBarrier的回调函数我们使用了一个固定大小的线程池，你觉得是否有必要呢？</p><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><p></p>","comments":[{"had_liked":false,"id":84859,"user_name":"探索无止境","can_delete":false,"product_type":"c1","uid":1044178,"ip_address":"","ucode":"91D2A9907DFA79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/d2/7024431c.jpg","comment_is_top":false,"comment_ctime":1554939974,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1036642058310","product_id":100023901,"comment_content":"今天的文章很精彩，有案例有递进，一气呵成！设置线程池为单个线程可以保证对账的操作按顺序执行","like_count":242,"discussions":[{"author":{"id":1134574,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4f/ee/bd08cfab.jpg","nickname":"一魄","note":"","ucode":"71541125D4AA5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385875,"discussion_content":"看完不仅学习了 CountDownLatch、CyclicBarrier，同时还学习了老师思考问题的清晰递进方式。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1627309253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97035,"user_name":"张申傲","can_delete":false,"product_type":"c1","uid":1182372,"ip_address":"","ucode":"22D46BC529BA8A","user_header":"https://static001.geekbang.org/account/avatar/00/12/0a/a4/828a431f.jpg","comment_is_top":false,"comment_ctime":1558575132,"is_pvip":true,"replies":[{"id":"34747","content":"👍","user_name":"作者回复","comment_id":97035,"uid":"1269969","ip_address":"","utype":1,"ctime":1558616437,"user_name_real":"王宝令"}],"discussion_count":12,"race_medal":2,"score":"1002285955100","product_id":100023901,"comment_content":"我觉得老师的问题其实是两个:<br>1.为啥要用线程池，而不是在回调函数中直接调用？<br>2.线程池为啥使用单线程的？<br><br>我的考虑:<br>1.使用线程池是为了异步操作，否则回掉函数是同步调用的，也就是本次对账操作执行完才能进行下一轮的检查。<br>2.线程数量固定为1，防止了多线程并发导致的数据不一致，因为订单和派送单是两个队列，只有单线程去两个队列中取消息才不会出现消息不匹配的问题。","like_count":233,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451104,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558616437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1512642,"avatar":"https://static001.geekbang.org/account/avatar/00/17/14/c2/46ebe3a0.jpg","nickname":"侧耳倾听","note":"","ucode":"5BF2A2440B54F0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":241947,"discussion_content":"补充一句，线程池为1是为了保证check的原子性，更深层面是当线程池为空的时候，从线程池取线程的动作会等待，实现了任务的排队","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1587451538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1494622,"avatar":"https://static001.geekbang.org/account/avatar/00/16/ce/5e/b103d538.jpg","nickname":"大明猩","note":"","ucode":"61D330B42AE3C4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":397475,"discussion_content":"考虑的第一点不对吧，使用线程池不是为了避免反复创建对账线程吗，我验证了一下，确实是线程池的那一个线程来回执行所有的对账，这样的话就是为了避免创建线程的开销了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632626277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1035999,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ce/df/3e24aa5b.jpg","nickname":"吃到140","note":"","ucode":"1862A57AB4C173","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342409,"discussion_content":"秀\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610676287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135604,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/f4/e277325d.jpg","nickname":"bin.chen","note":"","ucode":"5BA49358AB8A1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275519,"discussion_content":"但是这样会造成生产过剩的情况--还能在继续优化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590723346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1447904,"avatar":"https://static001.geekbang.org/account/avatar/00/16/17/e0/018a06cd.jpg","nickname":"RedHair","note":"","ucode":"9E68A6BC7C178E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1135604,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/f4/e277325d.jpg","nickname":"bin.chen","note":"","ucode":"5BA49358AB8A1A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278885,"discussion_content":"期待你后期学习得更棒之后，来补上你的优化方案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591251597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":275519,"ip_address":""},"score":278885,"extra":""}]},{"author":{"id":1098600,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c3/68/63fabc34.jpg","nickname":"流氓兔","note":"","ucode":"1A6AC1177BC17E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219117,"discussion_content":"这个回调函数不可以传递参数？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585736459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1297299,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cb/93/61e0a8c9.jpg","nickname":"ChoviWu","note":"","ucode":"C4B598A8FA2BFD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":196319,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583334999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1400824,"avatar":"https://static001.geekbang.org/account/avatar/00/15/5f/f8/65b36d40.jpg","nickname":"苏子泛舟","note":"","ucode":"72D7EC471196CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":184145,"discussion_content":"🉑️","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582548113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1566569,"avatar":"https://static001.geekbang.org/account/avatar/00/17/e7/69/0c426b52.jpg","nickname":"刘易宁","note":"","ucode":"EE337683D08B9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64619,"discussion_content":"厉害厉害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574951787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":16540,"discussion_content":"太强了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568899367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111870,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK2Az5uTh9ZGVA7yQCj1BXtXuicPRkvJicA97AoN9xX3bnPcUYglTMXJeZeoVbPQeJA7ICvQhR3KQ0w/132","nickname":"日不落帝国","note":"","ucode":"6A11ABBD8AC438","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6476,"discussion_content":"学习学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566916457,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85384,"user_name":"J.M.Liu","can_delete":false,"product_type":"c1","uid":1200037,"ip_address":"","ucode":"B2CB84B8E923A6","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/a5/71358d7b.jpg","comment_is_top":false,"comment_ctime":1555049914,"is_pvip":false,"replies":[{"id":"30800","content":"好问题，CyclicBarrier的回调函数执行在一个回合里最后执行await()的线程上，而且同步调用回调函数check()，调用完check之后，才会开始第二回合。所以check如果不另开一线程异步执行，就起不到性能优化的作用了。","user_name":"作者回复","comment_id":85384,"uid":"1269969","ip_address":"","utype":1,"ctime":1555170669,"user_name_real":"王宝令"}],"discussion_count":7,"race_medal":0,"score":"727404522938","product_id":100023901,"comment_content":"老师，CyclicBarrier的回调函数在哪个线程执行啊？主线程吗？比如这里的最后一段代码中，循环会在回调的时候阻塞吗？<br>如果是这样的话，那check函数岂不是可以直接作为回调函数了呀，并不需要线程池了啊","like_count":169,"discussions":[{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366067,"discussion_content":"CyclicBarrier构造函数最后一句performed by the last thread entering the barrier. 由最后一个进入栅栏的线程执行。\n\nCreates a new {@code CyclicBarrier} that will trip when the\ngiven number of parties (threads) are waiting upon it, and which\nwill execute the given barrier action when the barrier is tripped,\nperformed by the last thread entering the barrier.","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1617953257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446650,"discussion_content":"好问题，CyclicBarrier的回调函数执行在一个回合里最后执行await()的线程上，而且同步调用回调函数check()，调用完check之后，才会开始第二回合。所以check如果不另开一线程异步执行，就起不到性能优化的作用了。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1555170669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1346215,"avatar":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","nickname":"William","note":"","ucode":"55F5D9DEE485B1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386928,"discussion_content":"mark:\n使用线程池的作用：在本次回调方法（对账）执行的时候， 即可开始下一次的查询操作了。\n如果不使用的话，那么需要等待本次对账执行完毕， 才能继续查询操作。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1627896208,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133545,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJQyCFqdkJB97EXF7VVO1n0nRZUmxfWwDicJMmupDdDia7VnPkLSJicFyEe28eUtZamH9uprtBJ4Ojjw/132","nickname":"qhj","note":"","ucode":"A9A9370BB2EE0E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303740,"discussion_content":"如果不开另一线程异步执行的话，当回调函数在线程T1上执行时，那么线程T2是被阻塞吗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599366940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2308075,"avatar":"","nickname":"Geek_89e362","note":"","ucode":"E596C2CFE1CFAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1133545,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJQyCFqdkJB97EXF7VVO1n0nRZUmxfWwDicJMmupDdDia7VnPkLSJicFyEe28eUtZamH9uprtBJ4Ojjw/132","nickname":"qhj","note":"","ucode":"A9A9370BB2EE0E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327202,"discussion_content":"会阻塞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605767261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":303740,"ip_address":""},"score":327202,"extra":""}]},{"author":{"id":3067096,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/cc/d8/6cdd4b15.jpg","nickname":"一如往常i","note":"","ucode":"C9A5AEA38B3E97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586603,"discussion_content":"作者牛逼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662370601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖南"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2924187,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/SluScDGqnhBNwmOQ774QEzuXiazk8Ab7ng8xCT81gunl9Hls9oibwB4AibCDxDtZwTe4mEib5QiaLXUqMv8iceXicXSYg/132","nickname":"Geek_080ce7","note":"","ucode":"C74D97C84983B9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577341,"discussion_content":"所以就是4个线程是吧  ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656041844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84886,"user_name":"undifined","can_delete":false,"product_type":"c1","uid":1068920,"ip_address":"","ucode":"449CB4CD2DC089","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/78/c3d8ecb0.jpg","comment_is_top":false,"comment_ctime":1554943230,"is_pvip":false,"replies":[{"id":"30489","content":"对，👍👍👍<br>","user_name":"作者回复","comment_id":84886,"uid":"1269969","ip_address":"","utype":1,"ctime":1554945342,"user_name_real":"王宝令"}],"discussion_count":4,"race_medal":0,"score":"336562392318","product_id":100023901,"comment_content":"线程池大小为1是必要的，如果设置为多个，有可能会两个线程 A 和 B 同时查询，A 的订单先返回，B 的派送单先返回，造成队列中的数据不匹配；所以1个线程实现生产数据串行执行，保证数据安全<br><br>如果用Future 的话可以更方便一些：<br><br>        CompletableFuture&lt;List&gt; pOrderFuture = CompletableFuture.supplyAsync(this::getPOrders);<br>        CompletableFuture&lt;List&gt; dOrderFuture = CompletableFuture.supplyAsync(this::getDOrders);<br>        pOrderFuture.thenCombine(dOrderFuture, this::check)<br>                    .thenAccept(this::save);<br><br>老师这样理解对吗，谢谢老师<br>","like_count":78,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446487,"discussion_content":"对，👍👍👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554945342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296432,"discussion_content":"不会造成队列中的数据不匹配吧，应该是保证check的顺序性和原子性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596541412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1367048,"avatar":"https://static001.geekbang.org/account/avatar/00/14/dc/08/64f5ab52.jpg","nickname":"陈斌","note":"","ucode":"B639AB5F6AA03D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346904,"discussion_content":"会的，理由如下：\n     线程A先执行到P p = pos.remove(0); 还未执行 D d = dos.remove(0); 然后A被剥夺了CPU使用权。\n     而线程B执行了 P p = pos.remove(0); 和D  d = dos.remove(0); \n     此时就会有问题，B把原来属于A的d拿走了。A也只能拿到属于B的d了。 ","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1612095722,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":296432,"ip_address":""},"score":346904,"extra":""},{"author":{"id":1109640,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ee/88/a890b41e.jpg","nickname":"chris","note":"","ucode":"6663E3E09457E3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1367048,"avatar":"https://static001.geekbang.org/account/avatar/00/14/dc/08/64f5ab52.jpg","nickname":"陈斌","note":"","ucode":"B639AB5F6AA03D","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":570698,"discussion_content":"解释得通透👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651884057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":346904,"ip_address":""},"score":570698,"extra":""}]}]},{"had_liked":false,"id":85656,"user_name":"曾轼麟","can_delete":false,"product_type":"c1","uid":1451391,"ip_address":"","ucode":"D418371AC11270","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/7f/473d5a77.jpg","comment_is_top":false,"comment_ctime":1555163539,"is_pvip":false,"replies":[{"id":"30793","content":"好建议，所有的阻塞操作，都需要设置超时时间，这是个很好的习惯。","user_name":"作者回复","comment_id":85656,"uid":"1269969","ip_address":"","utype":1,"ctime":1555169526,"user_name_real":"王宝令"}],"discussion_count":3,"race_medal":0,"score":"267843135891","product_id":100023901,"comment_content":"老师推荐您使用ThreadPoolExecutor去实现线程池，并且实现里面的RejectedExecutionHandler和ThreadFactory，这样可以方便当调用订单查询和派送单查询的时候出现full gc的时候 dump文件 可以快速定位出现问题的线程是哪个业务线程，如果是CountDownLatch，建议设置超时时间，避免由于业务死锁没有调用countDown()导致现线程睡死的情况","like_count":62,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446753,"discussion_content":"好建议，所有的阻塞操作，都需要设置超时时间，这是个很好的习惯。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555169526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1686903,"avatar":"https://static001.geekbang.org/account/avatar/00/19/bd/77/72676290.jpg","nickname":"cd","note":"","ucode":"AE95F4288A7978","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":270945,"discussion_content":"看不太懂你的意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590070376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1451391,"avatar":"https://static001.geekbang.org/account/avatar/00/16/25/7f/473d5a77.jpg","nickname":"曾轼麟","note":"","ucode":"D418371AC11270","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1686903,"avatar":"https://static001.geekbang.org/account/avatar/00/19/bd/77/72676290.jpg","nickname":"cd","note":"","ucode":"AE95F4288A7978","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327287,"discussion_content":"线程尽量自己指定一个名字，不然默认的名字在查询线程堆栈的时候不好理解，其次是线程池任务队列需要使用有界的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1605784240,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":270945,"ip_address":""},"score":327287,"extra":""}]}]},{"had_liked":false,"id":85044,"user_name":"空知","can_delete":false,"product_type":"c1","uid":1013283,"ip_address":"","ucode":"C448E98238DD36","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/23/31e5e984.jpg","comment_is_top":false,"comment_ctime":1554965747,"is_pvip":false,"replies":[{"id":"30512","content":"所以才需要线程池来异步执行回调函数，你一不小心把答案找到了😂","user_name":"作者回复","comment_id":85044,"uid":"1269969","ip_address":"","utype":1,"ctime":1554984459,"user_name_real":"王宝令"}],"discussion_count":7,"race_medal":0,"score":"263547970803","product_id":100023901,"comment_content":"老师,关于CyclicBarrier回调函数,请教下<br>自己写了个 CyclicBarrier的例子,回调函数总是在计数器归0时候执行,但是线程T1 T2要等回调函数执行结束之后才会再次执行...看了下CyclicBarrier 的源码,当内部计数器 index == 0时候, <br><br>final Runnable command = barrierCommand;<br>                    <br>if (command != null)<br>                        <br>\tcommand.run();<br>没有开启子线程吧.也就是说 对账还是同步执行的,结束之后才是下一次的查询","like_count":61,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446539,"discussion_content":"所以才需要线程池来异步执行回调函数，你一不小心把答案找到了😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554984459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1644104,"avatar":"https://static001.geekbang.org/account/avatar/00/19/16/48/09493874.jpg","nickname":"茶没喝完","note":"","ucode":"D72D88C42A1258","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351970,"discussion_content":"最后一个到达barrier的线程来同步执行回调函数","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1614532351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2963434,"avatar":"","nickname":"Geek_94fa0e","note":"","ucode":"15BC7D4E130E80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1644104,"avatar":"https://static001.geekbang.org/account/avatar/00/19/16/48/09493874.jpg","nickname":"茶没喝完","note":"","ucode":"D72D88C42A1258","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561051,"discussion_content":"//回调函数内容是 异步起一个线程池 来执行任务","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649518596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":351970,"ip_address":""},"score":561051,"extra":""}]},{"author":{"id":1306315,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ee/cb/4bd24e0f.jpg","nickname":"官人","note":"","ucode":"ECEF55B08E252B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537353,"discussion_content":"这个比较有意思 是直接调用Runnable的run方法 而不是通过Thread.start方法 看见Runnable以为是在回调开启一个线程执行 当时还纳闷呢 为啥还要在回调里面在放一个线程执行 看完代码一脸懵逼 直接掉用run()","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1639041172,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1323652,"avatar":"","nickname":"sibyl","note":"","ucode":"0D142011860D69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290217,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594379393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018354,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/89/f2/abb7bfe3.jpg","nickname":"聪聪","note":"","ucode":"CD6DFE3A15F003","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":254146,"discussion_content":"牛逼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588297968,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1297299,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cb/93/61e0a8c9.jpg","nickname":"ChoviWu","note":"","ucode":"C4B598A8FA2BFD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":196338,"discussion_content":"从源码角度来找答案，厉害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583335284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84838,"user_name":"西西弗与卡夫卡","can_delete":false,"product_type":"c1","uid":1001710,"ip_address":"","ucode":"B4C27B8335B76A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/ee/872ad07e.jpg","comment_is_top":false,"comment_ctime":1554917676,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"134698903852","product_id":100023901,"comment_content":"回调中的线程池用单线程是为了确保从两个队列取数时可以一对一获取，避免错乱。比如说，如果有两个线程，则可能出现线程1获取PO1，线程获取PO2和DO1，线程获取DO2的乱序。<br><br>其实线程池改成多线程也可以，要把两个remove(0)放到一个同步块中","like_count":31,"discussions":[{"author":{"id":2963434,"avatar":"","nickname":"Geek_94fa0e","note":"","ucode":"15BC7D4E130E80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561052,"discussion_content":"yes","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649518690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84928,"user_name":"波波","can_delete":false,"product_type":"c1","uid":1155827,"ip_address":"","ucode":"4344D9F4486D42","user_header":"https://static001.geekbang.org/account/avatar/00/11/a2/f3/aa504fa6.jpg","comment_is_top":false,"comment_ctime":1554946204,"is_pvip":false,"replies":[{"id":"30621","content":"有这种可能，还能oom<br>","user_name":"作者回复","comment_id":84928,"uid":"1269969","ip_address":"","utype":1,"ctime":1555067865,"user_name_real":"王宝令"}],"discussion_count":7,"race_medal":0,"score":"108929128604","product_id":100023901,"comment_content":"思考题中，如果生产者比较快，消费者比较慢，生产者通知的时候，消费者还在对账，这个时候会怎么处理？会不会导致消费者错失通知，导致队列满了，但是消费者却没有收到通知。","like_count":25,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446499,"discussion_content":"有这种可能，还能oom\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555067865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1131027,"avatar":"https://static001.geekbang.org/account/avatar/00/11/42/13/860e176a.jpg","nickname":"外国肉夹馍","note":"","ucode":"00BADDCFEA92B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337764,"discussion_content":"所以这时候回调函数中应该只把数据分别取出来，然后分发给其他线程处理。而不是取完后还在本线程处理。\n也就是把取数和处理，两步分开。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1609071882,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1139128,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJh4fE4WryeIpjKCYB7TuWS2IEFV0paiaZt3hSh8jrPZRD8cvalPWndTv1VbdDiaEKibY0IgGGPEMbCw/132","nickname":"刘聪为","note":"","ucode":"8DFDCA7B37D04E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1131027,"avatar":"https://static001.geekbang.org/account/avatar/00/11/42/13/860e176a.jpg","nickname":"外国肉夹馍","note":"","ucode":"00BADDCFEA92B8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387039,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627958161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":337764,"ip_address":""},"score":387039,"extra":""}]},{"author":{"id":1112124,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f8/3c/29d8afd7.jpg","nickname":"@","note":"","ucode":"9FB1632E6C98E4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286249,"discussion_content":"所以，多线程的消费是可以的，但需要注意获取两个队列的数据和移除首部数据需要同步","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593094241,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1252400,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1c/30/7b1f17c2.jpg","nickname":"_kejin","note":"","ucode":"4183B9AB435C8B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3680,"discussion_content":"还有一种可能，第一次消费者执行速度很快，而线程a和b两个生产者线程速度不一致，导致消费者对帐出现很多差错队列，因为只有一半的数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564706396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1564179,"avatar":"https://static001.geekbang.org/account/avatar/00/17/de/13/af1324a0.jpg","nickname":"Lee","note":"","ucode":"E36B56BCC3B0D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1252400,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1c/30/7b1f17c2.jpg","nickname":"_kejin","note":"","ucode":"4183B9AB435C8B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3701,"discussion_content":"不会呀，生产者的2个线程都会调用await()方法，只有计数器都减为0了消费者线程才会执行","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1564723032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3680,"ip_address":""},"score":3701,"extra":""},{"author":{"id":1687656,"avatar":"https://static001.geekbang.org/account/avatar/00/19/c0/68/314e8306.jpg","nickname":"威先森","note":"","ucode":"5F445C6832274B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1252400,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1c/30/7b1f17c2.jpg","nickname":"_kejin","note":"","ucode":"4183B9AB435C8B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363915,"discussion_content":"这种情况不会出现的，a,b消费者线程返回的时间是以ab中最慢的一条为准的。快的会等慢的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617325741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3680,"ip_address":""},"score":363915,"extra":""}]}]},{"had_liked":false,"id":84880,"user_name":"nanquanmama","can_delete":false,"product_type":"c1","uid":1023100,"ip_address":"","ucode":"799C2E0F841FB0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9c/7c/408c2a0b.jpg","comment_is_top":false,"comment_ctime":1554942775,"is_pvip":false,"replies":[{"id":"30492","content":"放到不同的类里，这方面传统的面向对象可以解决，lambda也能解决，这个模块的最后几章能解决你说的这个问题，但是更复杂的场景还得自己设计<br>","user_name":"作者回复","comment_id":84880,"uid":"1269969","ip_address":"","utype":1,"ctime":1554945772,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"78864354103","product_id":100023901,"comment_content":"最后的那个例子，业务逻辑的部分已经变得很不直观，并发控制的逻辑掩盖住了业务逻辑。请问一下老师，实际项目开发中，并发控制逻辑如何做，才能和业务逻辑分离出来？","like_count":18,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446484,"discussion_content":"放到不同的类里，这方面传统的面向对象可以解决，lambda也能解决，这个模块的最后几章能解决你说的这个问题，但是更复杂的场景还得自己设计\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554945772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85447,"user_name":"... ...","can_delete":false,"product_type":"c1","uid":1312354,"ip_address":"","ucode":"E214CAA6349A60","user_header":"https://static001.geekbang.org/account/avatar/00/14/06/62/898449d3.jpg","comment_is_top":false,"comment_ctime":1555061418,"is_pvip":false,"replies":[{"id":"30619","content":"会<br>","user_name":"作者回复","comment_id":85447,"uid":"1269969","ip_address":"","utype":1,"ctime":1555065403,"user_name_real":"王宝令"}],"discussion_count":3,"race_medal":0,"score":"74569505450","product_id":100023901,"comment_content":"追问：如果线程池是单线程的话。那假如生产者速度快运check函数执行时间。那是不是就会出现堵塞情况了。久而久之，是不是会出现队列内存溢出","like_count":17,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446670,"discussion_content":"会\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555065403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1464183,"avatar":"https://static001.geekbang.org/account/avatar/00/16/57/77/ad6b2b8b.jpg","nickname":"桃花河逆流而上","note":"","ucode":"A88A60296743CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301165,"discussion_content":"感觉对于此案例，可仅需要在消息队列中预先保留几个消息即可，比如可在 T1 T2 线程添加判断，如果队列长度大于4，那么可以线程sleep等待","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598430631,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1537341,"avatar":"https://static001.geekbang.org/account/avatar/00/17/75/3d/71ad2330.jpg","nickname":"在路上","note":"","ucode":"C68778C04D61DF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285775,"discussion_content":"慎用无界队列","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592928435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103621,"user_name":"Adam","can_delete":false,"product_type":"c1","uid":1517838,"ip_address":"","ucode":"965DCD693E752B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK36t2flfxhzKygfLfdIHbK99M9D9w3v3bwAHUibJSFAs1ibswf7hbhkqL321k5SUjfiaWkkHeRBlibNA/132","comment_is_top":false,"comment_ctime":1560478180,"is_pvip":false,"replies":[{"id":"37542","content":"方案上基本都是限流","user_name":"作者回复","comment_id":103621,"uid":"1269969","ip_address":"","utype":1,"ctime":1560511912,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"61690020324","product_id":100023901,"comment_content":"如果生产者比较快，消费者check还没对账完 会不会照成 队列越来越多 最后内存溢出了 ，有没有什么好的方案解决呢？","like_count":14,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453943,"discussion_content":"方案上基本都是限流","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560511912,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90924,"user_name":"xuery","can_delete":false,"product_type":"c1","uid":1027584,"ip_address":"","ucode":"F461B61BE06131","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/00/025f37e7.jpg","comment_is_top":false,"comment_ctime":1556725619,"is_pvip":true,"replies":[{"id":"32614","content":"多个线程有这个可能，所以线程池用的是单线程的","user_name":"作者回复","comment_id":90924,"uid":"1269969","ip_address":"","utype":1,"ctime":1556756488,"user_name_real":"王宝令"}],"discussion_count":2,"race_medal":0,"score":"57391300467","product_id":100023901,"comment_content":"有，如果为线程池有多个线程，则由于check()函数里面的两个remove并不是原子操作，可能导致消费错乱。假设订单队列中有P1，P2；派送队列中有D1,D2；两个线程T1,T2同时执行check，可能出现T1消费到P1,D2，T2消费到P2，D1，就是T1先执行pos.remove(0), 而后T2执行pos.remove(0);dos.remov(0);然后T1才执行dos.remove(0)的场景","like_count":13,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448726,"discussion_content":"多个线程有这个可能，所以线程池用的是单线程的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556756488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4183,"discussion_content":"虽然实验不好做，但是从理论上来看如果不是单个线程池的话会存在这种问题","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565193586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85085,"user_name":"木偶人King","can_delete":false,"product_type":"c1","uid":1028805,"ip_address":"","ucode":"0BDCA51E6F0B76","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b2/c5/6ae0be56.jpg","comment_is_top":false,"comment_ctime":1554975087,"is_pvip":false,"replies":[{"id":"30505","content":"反正也不会反复创建，用不用都没关系<br>","user_name":"作者回复","comment_id":85085,"uid":"1269969","ip_address":"","utype":1,"ctime":1554983861,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"57389549935","product_id":100023901,"comment_content":"老师，最后checkAll（） 这里为什么new 了两个Thread  而不是使用线程池<br><br><br>","like_count":13,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446553,"discussion_content":"反正也不会反复创建，用不用都没关系\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554983861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84998,"user_name":"iron_man","can_delete":false,"product_type":"c1","uid":1099883,"ip_address":"","ucode":"C0053A59442910","user_header":"https://static001.geekbang.org/account/avatar/00/10/c8/6b/0f3876ef.jpg","comment_is_top":false,"comment_ctime":1554953964,"is_pvip":false,"replies":[{"id":"30846","content":"回调函数执行完之后才会唤醒等待的线程。","user_name":"作者回复","comment_id":84998,"uid":"1269969","ip_address":"","utype":1,"ctime":1555241675,"user_name_real":"王宝令"}],"discussion_count":2,"race_medal":0,"score":"57389528812","product_id":100023901,"comment_content":"王老师，cyclicbarrier，具体是在什么时候清零计数器呢？是在所有线程await返回后还是在回调函数调用后？await和回掉函数的调用顺序是怎样的","like_count":13,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446525,"discussion_content":"回调函数执行完之后才会唤醒等待的线程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555241675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366089,"discussion_content":"应该是先清零，再执行回调，最后唤醒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617957577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85174,"user_name":"王盛武","can_delete":false,"product_type":"c1","uid":1182516,"ip_address":"","ucode":"DE7EF246D3DCE8","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/34/f41d73a4.jpg","comment_is_top":false,"comment_ctime":1554994382,"is_pvip":false,"replies":[{"id":"30589","content":"一次多取几个然后批量执行，这个办法非常实用！","user_name":"作者回复","comment_id":85174,"uid":"1269969","ip_address":"","utype":1,"ctime":1554998986,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"53094601934","product_id":100023901,"comment_content":"undefind同学的意思差不多对。                         只有一个线程的线程池，是因为，订单队列和派单队列读取数据存在竞态条件。 如果要开多个线程，则需要一个lock进行同步那两个remove方法。    个人推荐的思路是，如果生产者速度比消费者快的情况下，放入一个双向的阻塞队列尾部，每次从双向队列头部取两个对象，根据对象属性来区别订单类型，也能开多个线程进行check操作。  但本文业务里check速度很快，所以这个场景只需要开1个线程的线程池是合理的。","like_count":12,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446582,"discussion_content":"一次多取几个然后批量执行，这个办法非常实用！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554998986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87234,"user_name":"aguan(^･ｪ･^)","can_delete":false,"product_type":"c1","uid":1107177,"ip_address":"","ucode":"04833EF2D18E1A","user_header":"https://static001.geekbang.org/account/avatar/00/10/e4/e9/0dd3829f.jpg","comment_is_top":false,"comment_ctime":1555551596,"is_pvip":false,"replies":[{"id":"31552","content":"一一是一组和一组等价，check的时候也是批量操作。没有就就放一个空对象做占位就可以了<br>","user_name":"作者回复","comment_id":87234,"uid":"1269969","ip_address":"","utype":1,"ctime":1555676028,"user_name_real":"王宝令"}],"discussion_count":2,"race_medal":0,"score":"48800191852","product_id":100023901,"comment_content":"老师，问一个业务逻辑的问题，在从两个队列中分别取订单和派送单的做比较的时候，怎么保证这订单和派送单是一一对应的关系呢？如果派送单有漏单，那如何对账比较取结果时的数据是一一对应关系？","like_count":11,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447359,"discussion_content":"一一是一组和一组等价，check的时候也是批量操作。没有就就放一个空对象做占位就可以了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555676028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1670763,"avatar":"https://static001.geekbang.org/account/avatar/00/19/7e/6b/36fc4516.jpg","nickname":"FIRE","note":"","ucode":"85861D990FB3AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294673,"discussion_content":"我也是这个疑问,终于看到有人问了,批量操作可以不用频繁查库,效率高.如果订单表和派送表查询的大部分不一致就不能对账了吧?只能拿订单号去查派送表.我之前做过支付的对账,因为是实时的,所以按天查询就能使两边的数据基本一致.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595953289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136214,"user_name":"王莹","can_delete":false,"product_type":"c1","uid":1203920,"ip_address":"","ucode":"0A6F91068A13E8","user_header":"https://static001.geekbang.org/account/avatar/00/12/5e/d0/e676ac19.jpg","comment_is_top":false,"comment_ctime":1569386340,"is_pvip":false,"replies":[{"id":"52329","content":"👍","user_name":"作者回复","comment_id":136214,"uid":"1269969","ip_address":"","utype":1,"ctime":1569464487,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"44519059300","product_id":100023901,"comment_content":"1.回调处理交给新开辟的线程执行，让当前处理继续进行，无需等待<br>2.使用线程池解决新开辟线程创建和销毁的开销问题<br>3.单线程使得两个队列的出队无需同步","like_count":10,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468510,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569464487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85025,"user_name":"月马穿关","can_delete":false,"product_type":"c1","uid":1338088,"ip_address":"","ucode":"2CE20CA1EB827D","user_header":"https://static001.geekbang.org/account/avatar/00/14/6a/e8/4bb87c34.jpg","comment_is_top":false,"comment_ctime":1554960279,"is_pvip":false,"replies":[{"id":"30514","content":"👍<br>","user_name":"作者回复","comment_id":85025,"uid":"1269969","ip_address":"","utype":1,"ctime":1554984539,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"44504633239","product_id":100023901,"comment_content":"感谢老师，一直不太明白什么时候用CyclicBarrier，今天看到案例了，刚看到join那段我想到了CompletableFuture<br><br>","like_count":10,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446534,"discussion_content":"👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554984539,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96262,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1558368705,"is_pvip":false,"replies":[{"id":"34570","content":"查询数据库一定是批量查询的，先把订单的id查出来，然后用这些id就能并行查了，cyclicbarrier能循环利用，用起来更简单，你可以用countdownlatch实现一下，就知道他们的区别了","user_name":"作者回复","comment_id":96262,"uid":"1269969","ip_address":"","utype":1,"ctime":1558448784,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"31623139777","product_id":100023901,"comment_content":"老师，您好！我有几个疑问：<br><br>1. 文章里提到：获取订单 getPOrders() 和获取派送订 getDOrders() 是相互独立、互不依赖的。<br>我们的订单系统通过 MQ 与派送系统进行数据交互，并且一个订单有可能生成多个派送单（仓库不同，拆单），想了好久，也没想到比较好的方式实现订单和派送单的查询操作可以并行处理。<br>如果每次只筛选过去一个小时未对账的订单，和过去一小时的派送单，当存在漏生成派送单时，系统发现不了（不知道是漏生成派送单，还是 MQ 没消费）。<br><br>2. 文章第二种方案，线程池多生成一个线程，专门用来处理 ( check &amp; save )，也能够实现查询和对账并行处理。因此不太能理解“一个线程等待多个线程”和“一组线程之间的相互等待”的区别。感觉 CountDownLatch 和 CyclicBarrier 都是 (check &amp; save) 线程在等待 getPOrders 和 getDOrders 线程。<br><br>3.文章最后一种方案，每次只查询一条改成一次查多条，这样可以减少查询的次数。check 的时候，也批量处理，吞吐量是不是会好一点吖。<br><br>谢谢老师！！","like_count":7,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450800,"discussion_content":"查询数据库一定是批量查询的，先把订单的id查出来，然后用这些id就能并行查了，cyclicbarrier能循环利用，用起来更简单，你可以用countdownlatch实现一下，就知道他们的区别了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558448784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84999,"user_name":"crazypokerk","can_delete":false,"product_type":"c1","uid":1158383,"ip_address":"","ucode":"9AAD5D9726E503","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/ef/494f56c3.jpg","comment_is_top":false,"comment_ctime":1554954170,"is_pvip":false,"replies":[{"id":"30596","content":"是的","user_name":"作者回复","comment_id":84999,"uid":"1269969","ip_address":"","utype":1,"ctime":1554999469,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"31619725242","product_id":100023901,"comment_content":"请教一下老师，上面说的将CyclicBarrier计数器初始值设为2，假如当T1先执行完，然后执行await时减1，此时计数器为1大于0，等待，然后T2执行await时再减1，此时计数器为0，则唤醒T3执行，与此同时，将计数器重置为2，T1、T2继续开始执行，以此循环往复，可以这样理解吗？","like_count":7,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446526,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554999469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117408,"user_name":"Asanz","can_delete":false,"product_type":"c1","uid":1005200,"ip_address":"","ucode":"430AB7ED59EE3F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/56/90/be01bb8d.jpg","comment_is_top":false,"comment_ctime":1564042210,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27333845986","product_id":100023901,"comment_content":"最后的代码段看了好几遍并没有发现checkAll()方法被调用啊😂","like_count":6},{"had_liked":false,"id":84831,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1554914142,"is_pvip":true,"replies":[{"id":"30622","content":"👍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555068063,"ip_address":"","comment_id":84831,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27324717918","product_id":100023901,"comment_content":"而且其实可以直接single线程池的，但是最好不要Executors提供的线程池，都有弊端，最好自定义线程池","like_count":6,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446463,"discussion_content":"👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555068063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96983,"user_name":"南北少卿","can_delete":false,"product_type":"c1","uid":1018958,"ip_address":"","ucode":"DFCC59F2BBD8CE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/4e/b81969fa.jpg","comment_is_top":false,"comment_ctime":1558569813,"is_pvip":false,"replies":[{"id":"34749","content":"可以，大部分场景都是你说的这种","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558616841,"ip_address":"","comment_id":96983,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23033406293","product_id":100023901,"comment_content":"CountDownLatch可以理解成主线程等待其他线程吗","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451089,"discussion_content":"可以，大部分场景都是你说的这种","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558616841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1098504,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c3/08/28c327d0.jpg","nickname":"冰河时代","note":"","ucode":"F4375FB7CE4FD4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293186,"discussion_content":"个人理解：大多数情况下我们在Tomcat等容器的线程池中，当前的主线程是Tomcat线程池的一条线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595471529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84927,"user_name":"IT小白","can_delete":false,"product_type":"c1","uid":1442053,"ip_address":"","ucode":"CD51B309AE4D29","user_header":"https://static001.geekbang.org/account/avatar/00/16/01/05/6435d2ef.jpg","comment_is_top":false,"comment_ctime":1554946167,"is_pvip":false,"replies":[{"id":"30518","content":"瓶颈在数据库，只要能让数据库性能发挥出来基本就是最优方案了。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554985382,"ip_address":"","comment_id":84927,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23029782647","product_id":100023901,"comment_content":"这个示例确实将这两个工具类的使用讲清楚了，但是对于这个具体业务这么改造是不合理的。因为整个对账过程里的所有操作必须是原子的，这么拆分到多个线程里执行，这个原子性的保证相对来说比较复杂，示例中也没有考虑。我觉得这里的性能优化可以很简单，比如：搞一组线程，将所有订单平均分摊到这一组线程上，所有线程并行对账，每个线程做的活都一样～ 注意每个线程维护独立的数据库连接～","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446498,"discussion_content":"瓶颈在数据库，只要能让数据库性能发挥出来基本就是最优方案了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554985382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158675,"user_name":"Ron","can_delete":false,"product_type":"c1","uid":1159044,"ip_address":"","ucode":"EE78756918FA0A","user_header":"https://static001.geekbang.org/account/avatar/00/11/af/84/c65b43fb.jpg","comment_is_top":false,"comment_ctime":1575430968,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14460332856","product_id":100023901,"comment_content":"checkAll方法执行开始后，<br>T1线程开始，查询到满足条件的数据，pos累加1，然后进入等待，这时候计数器从2减到1，T2开始执行<br>T2线程开始，查询到满足条件的数据，dos累加1，然后进入等待，这时候计数器从1减到0，满足回调函数触发条件，开始执行check方法<br>实际上，无论，pos还是dos 最多只会包含一条数据<br>在回调函数里如果没有设定线程池数量为1，就会导致多线程执行check方法，使得执行结果会超出预期<br>故需要限定线程池数量为1，保证当前时间有且只有一个线程执行check方法。","like_count":3},{"had_liked":false,"id":123243,"user_name":"Geek_446679","can_delete":false,"product_type":"c1","uid":1594164,"ip_address":"","ucode":"63076108F267E7","user_header":"","comment_is_top":false,"comment_ctime":1565652278,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14450554166","product_id":100023901,"comment_content":"你好，最后一个例子怎么保证一个P一个D，成对拿到结果，即count减到0时，不是拿到了两个P，导致check的时候，一个队列为空，一个队列有两个。","like_count":3,"discussions":[{"author":{"id":1445156,"avatar":"https://static001.geekbang.org/account/avatar/00/16/0d/24/b07de4f2.jpg","nickname":"WhoAmI","note":"","ucode":"58588E643EB842","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296651,"discussion_content":"1.阻塞当前线程 2.remove(0) 这两个就保证了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596614033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84910,"user_name":"冲鸭","can_delete":false,"product_type":"c1","uid":1115945,"ip_address":"","ucode":"0EF69B02188A73","user_header":"https://static001.geekbang.org/account/avatar/00/11/07/29/e5537b9e.jpg","comment_is_top":false,"comment_ctime":1554944793,"is_pvip":false,"replies":[{"id":"30662","content":"不会，如果计数器＞1，调用await的线程就阻塞了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555118607,"ip_address":"","comment_id":84910,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14439846681","product_id":100023901,"comment_content":"会出现计数器被同一个线程减到0的情况吗？","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446493,"discussion_content":"不会，如果计数器＞1，调用await的线程就阻塞了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555118607,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84856,"user_name":"邋遢的流浪剑客","can_delete":false,"product_type":"c1","uid":1260881,"ip_address":"","ucode":"32AF6F9070506D","user_header":"https://static001.geekbang.org/account/avatar/00/13/3d/51/9723276c.jpg","comment_is_top":false,"comment_ctime":1554938539,"is_pvip":false,"replies":[{"id":"31317","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555511672,"ip_address":"","comment_id":84856,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14439840427","product_id":100023901,"comment_content":"使用了固定大小为1的线程池，check方法是非线程安全的，让它串行执行","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446471,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555511672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84828,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1554913784,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14439815672","product_id":100023901,"comment_content":"有一定的必要，因为CyclicBarrier是可以重制的，所以如果不用线程池的话，每次都需要新建线程，浪费资源。也不知道对不对，请大佬指点","like_count":3},{"had_liked":false,"id":129938,"user_name":"王亚娇","can_delete":false,"product_type":"c1","uid":1447156,"ip_address":"","ucode":"16E5314E2205E8","user_header":"https://static001.geekbang.org/account/avatar/00/16/14/f4/53c0c002.jpg","comment_is_top":false,"comment_ctime":1567330179,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10157264771","product_id":100023901,"comment_content":"文中对cyclicbarrier的表述有些问题，它和countdownlatch有一个最大的区别是它是加计数的，加到指定值会重置为零，不是减到零重置为指定值","like_count":2,"discussions":[{"author":{"id":1466840,"avatar":"https://static001.geekbang.org/account/avatar/00/16/61/d8/3bc19bff.jpg","nickname":"恋在那时","note":"","ucode":"7F026B4B708C7D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285560,"discussion_content":"老师讲的是对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592880723,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85566,"user_name":"头晕的小骚年","can_delete":false,"product_type":"c1","uid":1234200,"ip_address":"","ucode":"EDA4B89BAA33F1","user_header":"https://static001.geekbang.org/account/avatar/00/12/d5/18/7f3b1af2.jpg","comment_is_top":false,"comment_ctime":1555125079,"is_pvip":false,"replies":[{"id":"30764","content":"所以check方法的执行是通过线程池异步执行的，如果同步执行，就没有效果，课后思考题就涉及到这一点","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555166749,"ip_address":"","comment_id":85566,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10145059671","product_id":100023901,"comment_content":"查询订单库和查询运单库会使订单队列和派送单队列各多一个数据，也会把CyclicBarrier计数器的值变为0，然后触发线程池里的check方法，执行对账操作，check方法是消费者，会消费一个数据。是不是check方法执行完后，线程才能继续查询订单库和运单库，让生产者生产数据？如果是这样的话，订单队列和派送单队列不是最多只能各有一个数据吗？这样的话，能达到优化性能的目的吗？","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446717,"discussion_content":"所以check方法的执行是通过线程池异步执行的，如果同步执行，就没有效果，课后思考题就涉及到这一点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555166749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84844,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1554933987,"is_pvip":false,"replies":[{"id":"30481","content":"是的<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554943423,"ip_address":"","comment_id":84844,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10144868579","product_id":100023901,"comment_content":"CyclicBarrier那段代码只要调用一次checkAll（）方法就会一直执行了吧？里边的每次循环都会在计数器等于0的时候自动回调check（）方法对账，然后两个线程分别进行下一次循环。","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446467,"discussion_content":"是的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554943423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84843,"user_name":"magict4","can_delete":false,"product_type":"c1","uid":1043789,"ip_address":"","ucode":"CB6F063D881AAC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/4d/1d1a1a00.jpg","comment_is_top":false,"comment_ctime":1554933089,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10144867681","product_id":100023901,"comment_content":"&gt; 另外，线程池提供了 Future 特性，我们也可以利用 Fu...<br><br>挺期待老师可以讲讲什么时候用 Future.get()，什么时候用 CountDownLatch 来等待线程完成。","like_count":2},{"had_liked":false,"id":287248,"user_name":"xiong","can_delete":false,"product_type":"c1","uid":1099375,"ip_address":"","ucode":"C1BFD9EF96372F","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/6f/ac3003fa.jpg","comment_is_top":false,"comment_ctime":1617855114,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5912822410","product_id":100023901,"comment_content":"仅仅讲了下两个类的使用意义何在？","like_count":1},{"had_liked":false,"id":286969,"user_name":"xiong","can_delete":false,"product_type":"c1","uid":1099375,"ip_address":"","ucode":"C1BFD9EF96372F","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/6f/ac3003fa.jpg","comment_is_top":false,"comment_ctime":1617709564,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5912676860","product_id":100023901,"comment_content":"老师讲了这么多的并发工具类，但底层依赖的AbstractQueuedSynchronizer 不讲一下吗","like_count":1},{"had_liked":false,"id":163249,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1576675704,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5871643000","product_id":100023901,"comment_content":"很好奇，订单和派送单之间没有对应关系吗？还是在每次查订单和派送单之前都会传入一个唯一标识？<br>","like_count":1,"discussions":[{"author":{"id":1250907,"avatar":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","nickname":"Monday","note":"","ucode":"77B9BACC783598","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87650,"discussion_content":"我看差了，确实是先有唯一标识再分别查询订单和派送单","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576676333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142857,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1571563820,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5866531116","product_id":100023901,"comment_content":"感觉这两个最大的区别就是栅栏可以支持通知(这个通知和最后一个await的线程保持同步)，并且支持重置(这个重置是执行完通知之后立刻重置，唤醒之前等待的线程)，最重要的是，线程之间可以相互等待，如果用countdownlatch，是不会相互等待的，有可能第一个线程就把计数器减成0了，所以线程之间的步调不一致了。","like_count":1},{"had_liked":false,"id":132861,"user_name":"Geek_bbbda3","can_delete":false,"product_type":"c1","uid":1504651,"ip_address":"","ucode":"737394CE472C21","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKNDKOCoZvCqoYVM1t97Q77QPLmRBGvOLYzFsh8073RicycoIuwGrIsCXpAFEyVBOxcyE3Ih1mr6Vw/132","comment_is_top":false,"comment_ctime":1568254357,"is_pvip":false,"replies":[{"id":"50907","content":"可以在回调中先执行remove，没有必要设置多个线程","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1568272642,"ip_address":"","comment_id":132861,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5863221653","product_id":100023901,"comment_content":"老师，在回调中先执行remove，在丢给线程池执行对账，该线程池设置多个线程，是否可以？<br>    Executor executor = Executors.newFixedThreadPool(10); <br>    final CyclicBarrier barrier =<br>            new CyclicBarrier(2, () -&gt; {<br>                P p = pos.remove(0);<br>                D d = dos.remove(0);<br>                executor.execute(() -&gt; check(p, d));<br>            });","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467150,"discussion_content":"可以在回调中先执行remove，没有必要设置多个线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568272642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1504651,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKNDKOCoZvCqoYVM1t97Q77QPLmRBGvOLYzFsh8073RicycoIuwGrIsCXpAFEyVBOxcyE3Ih1mr6Vw/132","nickname":"Geek_bbbda3","note":"","ucode":"737394CE472C21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296972,"discussion_content":"设置多个线程还是有效果的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596719749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129548,"user_name":"全村的希望","can_delete":false,"product_type":"c1","uid":1590482,"ip_address":"","ucode":"91B456FEFF85B5","user_header":"https://static001.geekbang.org/account/avatar/00/18/44/d2/a36c09bd.jpg","comment_is_top":false,"comment_ctime":1567152691,"is_pvip":true,"replies":[{"id":"48665","content":"你说的这种情况，t1的barrier.await第一次就阻塞了，不会调用两次","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1567469694,"ip_address":"","comment_id":129548,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5862119987","product_id":100023901,"comment_content":"如果线程t2在查询运单库的时候执行很慢，在没有调用t2方法的barrier.await()时，而t1的while循环查询了两次订单库调用了两次barrier.await()的情况时，是不是也会执行check方法","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465537,"discussion_content":"你说的这种情况，t1的barrier.await第一次就阻塞了，不会调用两次","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567469694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129227,"user_name":" 臣馟飞扬","can_delete":false,"product_type":"c1","uid":1116188,"ip_address":"","ucode":"F2F882B7678055","user_header":"https://static001.geekbang.org/account/avatar/00/11/08/1c/ef15e661.jpg","comment_is_top":false,"comment_ctime":1567065930,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5862033226","product_id":100023901,"comment_content":"感觉CyclicBarrier主要就是靠将回调函数设计为异步的才做到完全异步了，否则效果基本跟CountDownLatch没啥区别","like_count":1},{"had_liked":false,"id":115006,"user_name":"雪浪","can_delete":false,"product_type":"c1","uid":1541538,"ip_address":"","ucode":"CB33F2F8418557","user_header":"https://static001.geekbang.org/account/avatar/00/17/85/a2/dbeeb6c4.jpg","comment_is_top":false,"comment_ctime":1563450795,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5858418091","product_id":100023901,"comment_content":"还有一点差异没讲到 对于countDownLatch 每个子线程 执行countDown()方法之后，还会继续往下执行,countDown()方法的作用只是告诉主线程，需要执行的任务已经执行完成。而CyclicBarrier就不同了，子线程执行await()方法后，不会再继续执行，直到所有子线程执行完 打开屏障，子线程才会继续执行","like_count":1},{"had_liked":false,"id":99935,"user_name":"盐多必失","can_delete":false,"product_type":"c1","uid":1218415,"ip_address":"","ucode":"B9DBB12E0D1D74","user_header":"https://static001.geekbang.org/account/avatar/00/12/97/6f/4cd459f2.jpg","comment_is_top":false,"comment_ctime":1559361180,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5854328476","product_id":100023901,"comment_content":"老师，现实场景会不会有比如订单到了1 2 3 4 5 6 7 8 9 10 而对账单由于2丢失了 就是 1 3 4 5 ……10 由于check是一条条的对比，那样由于丢失一条后造成后面的记录全部都错了啊，这种怎么处理？谢谢","like_count":1,"discussions":[{"author":{"id":1596283,"avatar":"https://static001.geekbang.org/account/avatar/00/18/5b/7b/5bfd35eb.jpg","nickname":"Geek_db7d4d","note":"","ucode":"6A359E4E1E33F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1672,"discussion_content":"对于整个对比订单和派送单的场景怎么对应的，完全不理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562807984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90088,"user_name":"Vincent","can_delete":false,"product_type":"c1","uid":1135159,"ip_address":"","ucode":"CD8B84A57A6A0C","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/37/13b4c8aa.jpg","comment_is_top":false,"comment_ctime":1556412898,"is_pvip":false,"replies":[{"id":"32298","content":"两个队列入的步调和出的步调是一致的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556427172,"ip_address":"","comment_id":90088,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5851380194","product_id":100023901,"comment_content":"你好，我想问下你怎么保证双队列元素之间的一一对应关系，你这个是两个不同的查询","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448384,"discussion_content":"两个队列入的步调和出的步调是一致的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556427172,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89144,"user_name":"佑儿","can_delete":false,"product_type":"c1","uid":1226196,"ip_address":"","ucode":"0629888E7A5E16","user_header":"https://static001.geekbang.org/account/avatar/00/12/b5/d4/3bd5b77b.jpg","comment_is_top":false,"comment_ctime":1556090788,"is_pvip":false,"replies":[{"id":"31944","content":"👍👍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556112696,"ip_address":"","comment_id":89144,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5851058084","product_id":100023901,"comment_content":"看了源码，再结合本篇文章，对CyclicBarrier的理解更加深刻了。<br>回调函数调用的时机为最终使计数器为0的线程，然后再唤醒所有阻塞的线程，（见nextGeneration()）<br>private int dowait(boolean timed, long nanos)<br>        throws InterruptedException, BrokenBarrierException,<br>               TimeoutException {<br>        final ReentrantLock lock = this.lock;<br>        lock.lock();<br>        try {<br>\t\t\t.........省略<br>            int index = --count;<br>            if (index == 0) {  &#47;&#47; tripped<br>                boolean ranAction = false;<br>                try {<br>                    final Runnable command = barrierCommand;<br>                    if (command != null)<br>                        command.run();<br>                    ranAction = true;<br>                    nextGeneration();&#47;&#47; 唤醒所有阻塞的线程，并自动重置count<br>                    return 0;<br>                } finally {<br>                    if (!ranAction)<br>                        breakBarrier();<br>                }<br>            }<br><br>            &#47;&#47; loop until tripped, broken, interrupted, or timed out<br>            for (;;) {<br>                try {<br>                    if (!timed)<br>                        trip.await();&#47;&#47;阻塞线程<br>                    else if (nanos &gt; 0L)<br>                        nanos = trip.awaitNanos(nanos);<br>                } catch (InterruptedException ie) {<br>\t\t\t\t\t.....省略<br>            }<br>        } finally {<br>            lock.unlock();<br>        }<br>    }","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448036,"discussion_content":"👍👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556112696,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86734,"user_name":"没看懂啊","can_delete":false,"product_type":"c1","uid":1366238,"ip_address":"","ucode":"5D0ADAE83288FC","user_header":"https://static001.geekbang.org/account/avatar/00/14/d8/de/6d18cc7a.jpg","comment_is_top":false,"comment_ctime":1555439284,"is_pvip":false,"replies":[{"id":"31308","content":"有可能t1拿到订单0，派送单1。t2拿到订单1，派送单0，这样数据就乱了。多个线程访问两个共享变量，会有并发问题。<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555510840,"ip_address":"","comment_id":86734,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5850406580","product_id":100023901,"comment_content":"如果最后的线程池有两个线程，会有什么问题？老师能举个例子吗？想了好久没想出来啊，有点折磨人","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447143,"discussion_content":"有可能t1拿到订单0，派送单1。t2拿到订单1，派送单0，这样数据就乱了。多个线程访问两个共享变量，会有并发问题。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555510840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85843,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1555254671,"is_pvip":false,"replies":[{"id":"30893","content":"那我得先讲线程池","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555295474,"ip_address":"","comment_id":85843,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5850221967","product_id":100023901,"comment_content":"为什么cycliyBarrier 中不用大小为3的线程池","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446834,"discussion_content":"那我得先讲线程池","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555295474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85813,"user_name":"姜小白","can_delete":false,"product_type":"c1","uid":1449131,"ip_address":"","ucode":"83B2D2A9FA295D","user_header":"https://static001.geekbang.org/account/avatar/00/16/1c/ab/23816951.jpg","comment_is_top":false,"comment_ctime":1555245429,"is_pvip":false,"replies":[{"id":"30856","content":"火焰金精！！！多谢多谢！","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555247771,"ip_address":"","comment_id":85813,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5850212725","product_id":100023901,"comment_content":"老师，你的最后一个例子代码中，T1.start()之前，对于T1的定义，是不是少了一个&quot;<br>)&quot;，还有T2也是。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446822,"discussion_content":"火焰金精！！！多谢多谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555247771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85723,"user_name":"橘子不酸","can_delete":false,"product_type":"c1","uid":1181036,"ip_address":"","ucode":"0CF042909D27C2","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/6c/5166b0ea.jpg","comment_is_top":false,"comment_ctime":1555213385,"is_pvip":false,"replies":[{"id":"30843","content":"barrierAction是同步执行，只有执行完才会开启下一轮。 所以用一个单线程的线程池，既能解决同步的性能问题，也能解决数据的一致性问题。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555240781,"ip_address":"","comment_id":85723,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5850180681","product_id":100023901,"comment_content":"老师，barrier的 barrierAction是不是最后一个线程进入后就会执行，如果这个时候之前进入的线程还没有执行完的话，在这个应用场景下，对账是不是有问题。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446781,"discussion_content":"barrierAction是同步执行，只有执行完才会开启下一轮。 所以用一个单线程的线程池，既能解决同步的性能问题，也能解决数据的一致性问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555240781,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85443,"user_name":"... ...","can_delete":false,"product_type":"c1","uid":1312354,"ip_address":"","ucode":"E214CAA6349A60","user_header":"https://static001.geekbang.org/account/avatar/00/14/06/62/898449d3.jpg","comment_is_top":false,"comment_ctime":1555061149,"is_pvip":false,"replies":[{"id":"30799","content":"一个线程是因为check会很快执行完，所以没必要搞多个线程，多个线程还需要考虑数据同步问题。<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555170186,"ip_address":"","comment_id":85443,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5850028445","product_id":100023901,"comment_content":"我觉得没有这个必要的，线程池可以设置为多个线程的线程池。因为当barrier计算器等于0的时候才会执行check啊。执行check的瞬间就会执行remove操作。当有执行第2次回调的时候，第一次回调函数的remove操作然到还没执行完吗！所以我觉得check函数的后续如果没有涉及到共享资源的操作情况下。是可以设置多个线程的线程池的。老师，我这样理解有问题吗？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446669,"discussion_content":"一个线程是因为check会很快执行完，所以没必要搞多个线程，多个线程还需要考虑数据同步问题。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555170186,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85206,"user_name":"Geek_515b9e","can_delete":false,"product_type":"c1","uid":1335734,"ip_address":"","ucode":"2D041B7679A2AF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/dlj3u0jzg1gmCSxZ6daxUhhjtjmgqIwdOyalaEXYDYyQxibOsQdTrKFPPRs2I2XCHoehNaYUPrIffia9ZnR9efqQ/132","comment_is_top":false,"comment_ctime":1555001244,"is_pvip":false,"replies":[{"id":"30845","content":"如果异步执行回调（例如我们用了线程池），生产者就不会等待。如果是同步（不创建新线程）回调。生产者会等待，因为CyclicBarrier不会开启下一轮","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555241455,"ip_address":"","comment_id":85206,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5849968540","product_id":100023901,"comment_content":"老师<br>我想问一下，如果CyclicBarrier的回调执行比较慢，他的生产者会等待回调嘛，还是生产者存单一个队列里面。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446593,"discussion_content":"如果异步执行回调（例如我们用了线程池），生产者就不会等待。如果是同步（不创建新线程）回调。生产者会等待，因为CyclicBarrier不会开启下一轮","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555241455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85105,"user_name":"心中无剑","can_delete":false,"product_type":"c1","uid":1479311,"ip_address":"","ucode":"85C27AC7523EE4","user_header":"https://static001.geekbang.org/account/avatar/00/16/92/8f/0378e325.jpg","comment_is_top":false,"comment_ctime":1554981421,"is_pvip":false,"replies":[{"id":"30520","content":"catch住所有异常写日志，回头分析原因，委托线程池，线程执行的基本都这个思路","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554987156,"ip_address":"","comment_id":85105,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5849948717","product_id":100023901,"comment_content":"王老师，save(diff)发生异常怎么办，","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446560,"discussion_content":"catch住所有异常写日志，回头分析原因，委托线程池，线程执行的基本都这个思路","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554987156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85056,"user_name":"退而结网","can_delete":false,"product_type":"c1","uid":1126394,"ip_address":"","ucode":"48C99264CC3A5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/2f/fa/191049df.jpg","comment_is_top":false,"comment_ctime":1554968587,"is_pvip":false,"replies":[{"id":"30591","content":"都是批量查询数据库的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554999120,"ip_address":"","comment_id":85056,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5849935883","product_id":100023901,"comment_content":"老师和各位同学，请问while后面那个（存在未对账订单）是怎么去判断？每一次都去查库的话是不是性能也有问题？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446543,"discussion_content":"都是批量查询数据库的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554999120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1670763,"avatar":"https://static001.geekbang.org/account/avatar/00/19/7e/6b/36fc4516.jpg","nickname":"FIRE","note":"","ucode":"85861D990FB3AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294682,"discussion_content":"我跟你的疑问也一样,我写了个自增的,所以最后是吧vector都加满了......","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595954018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85015,"user_name":"郑晨Cc","can_delete":false,"product_type":"c1","uid":1324942,"ip_address":"","ucode":"57146E444D6329","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/8e/cf0b4575.jpg","comment_is_top":false,"comment_ctime":1554956587,"is_pvip":false,"replies":[{"id":"30595","content":"能坚持的现在也不易，互点互点","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554999443,"ip_address":"","comment_id":85015,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5849923883","product_id":100023901,"comment_content":"countdownlatch 和cyclicbarrier 之前就了解过 不过理解的不深入 老师今天的讲解案例个使用的类比很精彩 让我有一种醍醐灌顶的感觉 给老师点个赞","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446530,"discussion_content":"能坚持的现在也不易，互点互点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554999443,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84958,"user_name":"影子传说","can_delete":false,"product_type":"c1","uid":1031636,"ip_address":"","ucode":"371B72BB5CCB5E","user_header":"","comment_is_top":false,"comment_ctime":1554949523,"is_pvip":false,"replies":[{"id":"30516","content":"触类旁通了👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554984922,"ip_address":"","comment_id":84958,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5849916819","product_id":100023901,"comment_content":"老师讲的这个跟cpu流水线思想很相似啊","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446509,"discussion_content":"触类旁通了👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554984922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84901,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1554944165,"is_pvip":false,"replies":[{"id":"30488","content":"找bug,重新来过😂<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554945213,"ip_address":"","comment_id":84901,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5849911461","product_id":100023901,"comment_content":"想问一下老师如果在CyclicBarrier的例子中, checkAll()方法抛出异常了怎么办?","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446492,"discussion_content":"找bug,重新来过😂\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554945213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84855,"user_name":"CRT","can_delete":false,"product_type":"c1","uid":1442864,"ip_address":"","ucode":"59F5C8C0674ADC","user_header":"https://static001.geekbang.org/account/avatar/00/16/04/30/7f2cb8e3.jpg","comment_is_top":false,"comment_ctime":1554938455,"is_pvip":false,"replies":[{"id":"31828","content":"我也这么考虑的<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556029517,"ip_address":"","comment_id":84855,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5849905751","product_id":100023901,"comment_content":"关于思考题。由上图看到check操作耗时比较少的，所以理论上单线程可以完成任务，不会造成队列阻塞，设置线程池为1即可，同时也防止出现多线程调用check。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446470,"discussion_content":"我也这么考虑的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556029517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360011,"user_name":"梅子黄时雨","can_delete":false,"product_type":"c1","uid":1015938,"ip_address":"上海","ucode":"9F788D09C2E9E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/82/3c21b30c.jpg","comment_is_top":false,"comment_ctime":1666137032,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666137032","product_id":100023901,"comment_content":"学习了。","like_count":0},{"had_liked":false,"id":356411,"user_name":"小晨","can_delete":false,"product_type":"c1","uid":1477754,"ip_address":"江苏","ucode":"C95BC5211A5741","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/7a/5ee20222.jpg","comment_is_top":false,"comment_ctime":1662282350,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1662282350","product_id":100023901,"comment_content":" 下面这代码，我原意是t1和t2交替打印，但他为什么会连续打印俩次t1或t2？<br> public static void main(String[] args) throws ExecutionException, InterruptedException {<br>        CyclicBarrier cyclicBarrier = new CyclicBarrier(2);<br>        new Thread(() -&gt; {<br>            while (true) {<br>                    System.out.println(&quot;t1&quot;);<br>                    cyclicBarrier.await();<br>            }<br>        }, &quot;t1&quot;).start();<br><br><br>        new Thread(() -&gt; {<br>            while (true) {<br>                   System.out.println(&quot;t2&quot;);<br>                    cyclicBarrier.await();<br>            }<br>        }, &quot;t2&quot;).start();<br><br>        Thread.sleep(10000);<br>    }","like_count":0},{"had_liked":false,"id":353815,"user_name":"killeroppo","can_delete":false,"product_type":"c1","uid":1815768,"ip_address":"广东","ucode":"C167BA07268273","user_header":"https://static001.geekbang.org/account/avatar/00/1b/b4/d8/67a31275.jpg","comment_is_top":false,"comment_ctime":1659837371,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1659837371","product_id":100023901,"comment_content":"老师 最后一版的while循环里是不是也可以改成线程池？增加线程复用","like_count":0},{"had_liked":false,"id":348062,"user_name":"HooYa","can_delete":false,"product_type":"c1","uid":1640517,"ip_address":"","ucode":"43F3577E7D939A","user_header":"https://static001.geekbang.org/account/avatar/00/19/08/45/62ff43de.jpg","comment_is_top":false,"comment_ctime":1654697581,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654697581","product_id":100023901,"comment_content":"有必要为1 因为如果多个 并且不加锁的话，会有原子性问题。假如有两个 t1 t2。t1 pos.remove 之后被中断。t2 执行了pos.remove 和 dos. remove 就会数据没有对齐。","like_count":0},{"had_liked":false,"id":347029,"user_name":"sili0816","can_delete":false,"product_type":"c1","uid":2338682,"ip_address":"","ucode":"BBFC03F0D033AE","user_header":"https://static001.geekbang.org/account/avatar/00/23/af/7a/753f3e1d.jpg","comment_is_top":false,"comment_ctime":1653634408,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653634408","product_id":100023901,"comment_content":"用synchronized wait notify 能不能实现同样的效果呢，他们和CountDownLatch 区别是什么呢？","like_count":0},{"had_liked":false,"id":346581,"user_name":"董昌强","can_delete":false,"product_type":"c1","uid":1213322,"ip_address":"","ucode":"0803D7E3ABD3FD","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/8a/7c7df3b3.jpg","comment_is_top":false,"comment_ctime":1653261448,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1653261448","product_id":100023901,"comment_content":"1、最后例子代码的check 方法中，从订单库和派单库两个队列中取数据加上  sychronized 同步，线程池是不是可以不只一个了 ？<br>2、两个线程分别查订单库和派单库，业务上需要查同一批订单 id 才行，很难独立查，有啥好思路 ？","like_count":0},{"had_liked":false,"id":345845,"user_name":"学习学个屁","can_delete":false,"product_type":"c1","uid":1049017,"ip_address":"","ucode":"DF2D61E6FB2FCE","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","comment_is_top":false,"comment_ctime":1652627678,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652627678","product_id":100023901,"comment_content":"其实也可以不适用 CyclicBarrier 使用异步编程 CompletableFuture","like_count":0},{"had_liked":false,"id":345843,"user_name":"学习学个屁","can_delete":false,"product_type":"c1","uid":1049017,"ip_address":"","ucode":"DF2D61E6FB2FCE","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","comment_is_top":false,"comment_ctime":1652627542,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652627542","product_id":100023901,"comment_content":"还是有必要的，处理完后，通知异步操作，可以提高处理的吞吐量。","like_count":0},{"had_liked":false,"id":342598,"user_name":"Curiosity","can_delete":false,"product_type":"c1","uid":1879290,"ip_address":"","ucode":"A6732CAE6CBE8E","user_header":"https://static001.geekbang.org/account/avatar/00/1c/ac/fa/a32099e7.jpg","comment_is_top":false,"comment_ctime":1650359581,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650359581","product_id":100023901,"comment_content":"这样解决多线程消费可以吗   <br>private final Executor executorSave = Executors.newFixedThreadPool(10);<br>    public  void check() {<br>        P p = pos.remove(0);<br>      D d = dos.remove(0);<br>        executorSave.execute(()-&gt;{<br>        &#47;&#47; 执行对账操作<br>  diff = check(p, d);<br>  &#47;&#47; 差异写入差异库<br>  save(diff);<br>        });<br><br><br>    }<br>","like_count":0},{"had_liked":false,"id":342594,"user_name":"Curiosity","can_delete":false,"product_type":"c1","uid":1879290,"ip_address":"","ucode":"A6732CAE6CBE8E","user_header":"https://static001.geekbang.org/account/avatar/00/1c/ac/fa/a32099e7.jpg","comment_is_top":false,"comment_ctime":1650359223,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650359223","product_id":100023901,"comment_content":"提问：CyclicBarrier方案，check中执行的 remove操作，与 t1，t2的生产操作是否存在问题<br>加入 check操作执行pos.remove(0) 的时候 t2 此时执行 dos.add(getDOrders()); 是没有问题的吧，这时候数据还是一一对应的么","like_count":0},{"had_liked":false,"id":340977,"user_name":"键盘上的魔术","can_delete":false,"product_type":"c1","uid":2697700,"ip_address":"","ucode":"A731D721FB8D3A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/LFJZ4x47rvShGhsePLIxc8EzdlBxAmVAIjJ2FQZ4NEpo8E4JCZQEOb2NIfOuiaQLL6Otkt7W3Rmu6Tv3AkgYdRA/132","comment_is_top":false,"comment_ctime":1649251732,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649251732","product_id":100023901,"comment_content":"老师，问个业务逻辑相关的问题， CyclicBarrier这个例子里getPOrders()和getDOrders()返回的是单个对象？ 之前的例子这两个方法返回的都是List？ 这地方看的有点怪","like_count":0},{"had_liked":false,"id":316223,"user_name":"卢","can_delete":false,"product_type":"c1","uid":1542037,"ip_address":"","ucode":"B6A9F41AEE348C","user_header":"https://static001.geekbang.org/account/avatar/00/17/87/95/cba0a896.jpg","comment_is_top":false,"comment_ctime":1634206085,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634206085","product_id":100023901,"comment_content":"这个案例实在太棒了，很通俗易懂","like_count":0},{"had_liked":false,"id":306388,"user_name":"study的程序员","can_delete":false,"product_type":"c1","uid":1023101,"ip_address":"","ucode":"E5AE9037D24429","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9c/7d/774e07f9.jpg","comment_is_top":false,"comment_ctime":1628522090,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628522090","product_id":100023901,"comment_content":"RejectedExecutionHandler defaultHandler =  new AbortPolicy();<br>默认拒绝策略丢弃，生产者速度远大于消费者会导致任务丢弃，虽然两个vector中数据不丢，但是check会减少","like_count":0},{"had_liked":false,"id":297826,"user_name":"王成","can_delete":false,"product_type":"c1","uid":1441460,"ip_address":"","ucode":"29765BBCD3B8B2","user_header":"https://static001.geekbang.org/account/avatar/00/15/fe/b4/6902ac00.jpg","comment_is_top":false,"comment_ctime":1623806348,"is_pvip":false,"replies":[{"id":"108800","content":"用单线程是为了避免并发问题，而且单线程也够了。当然了，很多方案都能解决这里的并发问题。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1624967487,"ip_address":"","comment_id":297826,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1623806348","product_id":100023901,"comment_content":"老师，我说下我的看法<br>1.首先，为了防止线程阻塞，所以使用另外的线程来执行check操作<br>2.其次，线程池中单线程的目的，其实就是为了保证两个队列的remove(0)是原子的（不知道这么表述对不对啊），多个线程会在两个remove（0）之间发生线程切换，导致check的两个对象其实不是一个订单的情况<br>3.其实，我认为可以使用线程池包含多个线程的办法，只要把两个remove（0）操作单独封装一个方法，并且用锁保证原子性即可。这样的好处是即使check方法慢，只要线程池中线程整体处理check的速度能赶上add的速度，也可以保证系统不会出大问题，减少出现oom的几率<br><br>不知道这样理解对不对，希望老师指导一下","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521942,"discussion_content":"用单线程是为了避免并发问题，而且单线程也够了。当然了，很多方案都能解决这里的并发问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624967487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1023101,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9c/7d/774e07f9.jpg","nickname":"study的程序员","note":"","ucode":"E5AE9037D24429","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387997,"discussion_content":"如果生产速度远大于消费速度，你这更容易oom，因为额外多了很多block的线程。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628522303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":297167,"user_name":"宋柯仰","can_delete":false,"product_type":"c1","uid":1422296,"ip_address":"","ucode":"50FB61E3E9DAF8","user_header":"https://static001.geekbang.org/account/avatar/00/15/b3/d8/c56e0f0b.jpg","comment_is_top":false,"comment_ctime":1623337418,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623337418","product_id":100023901,"comment_content":"CyclicBarrier的回调函数里起线程应该是有坑的吧，这时候下一轮直接开始了，往其中一个队列加入元素，回调线程就有可能从两个队列拿到不对应的元素了嘛？","like_count":0},{"had_liked":false,"id":296742,"user_name":"Niverkk","can_delete":false,"product_type":"c1","uid":2179875,"ip_address":"","ucode":"F9220C10107E44","user_header":"https://static001.geekbang.org/account/avatar/00/21/43/23/d98fb8f7.jpg","comment_is_top":false,"comment_ctime":1623141047,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1623141047","product_id":100023901,"comment_content":"if (index == 0) {  &#47;&#47; tripped<br>    boolean ranAction = false;<br>    try {<br>        final Runnable command = barrierCommand;<br>        if (command != null)<br>            command.run();<br>        ranAction = true;<br>        nextGeneration();<br>        return 0;<br>    } finally {<br>        if (!ranAction)<br>            breakBarrier();<br>    }<br>}<br><br>根据源码可知，使用最后一个线程同步调用Runnable的run方法，会阻塞下次的查询","like_count":0},{"had_liked":false,"id":290359,"user_name":"夕阳武士","can_delete":false,"product_type":"c1","uid":1480522,"ip_address":"","ucode":"DDCF11F69CDAB5","user_header":"https://static001.geekbang.org/account/avatar/00/16/97/4a/0da51831.jpg","comment_is_top":false,"comment_ctime":1619514393,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619514393","product_id":100023901,"comment_content":"照着写个demo验证一下<br>public class ProductConsumer {<br>    private int x = 0;<br>    private int y = 0;<br>    public void addX() {<br>        System.out.println(&quot;x的值：&quot; + x);<br>        x++;<br>    }<br>    public void addY() {<br>        System.out.println(&quot;y的值：&quot; + y);<br>        y++;<br>    }<br><br>    public int getResult() {<br>        System.out.println(&quot;得到最终结果：x=&quot; + x + &quot;，y=&quot; + y);<br>        return 0;<br>    }<br><br><br>    public static void main(String[] args) {<br>        ProductConsumer productConsumer = new ProductConsumer();<br>        ExecutorService executorService = Executors.newFixedThreadPool(1);<br>        CyclicBarrier barrier = new CyclicBarrier(2, () -&gt; {<br>            executorService.execute(() -&gt; {<br>                productConsumer.getResult();<br>            });<br>        });<br>        Thread t1 = new Thread(() -&gt; {<br>            for (int i = 0; i &lt; 1000; i++) {<br>                try {<br>                    productConsumer.addX();<br>                    barrier.await();<br>                } catch (InterruptedException e) {<br>                    e.printStackTrace();<br>                } catch (BrokenBarrierException e) {<br>                    e.printStackTrace();<br>                }<br>            }<br>        });<br>        Thread t2 = new Thread(() -&gt; {<br>            for (int i = 0; i &lt; 1000; i++) {<br>                try {<br>                    productConsumer.addY();<br>                    barrier.await();<br>                } catch (InterruptedException e) {<br>                    e.printStackTrace();<br>                } catch (BrokenBarrierException e) {<br>                    e.printStackTrace();<br>                }<br>            }<br>        });<br>        t1.start();<br>        t2.start();<br>    }<br>}<br><br>输出结果：<br>x的值：0<br>y的值：0<br>y的值：1<br>得到最终结果：x=1，y=2<br>x的值：1<br>x的值：2<br>。。。。。。。。。<br>得到最终结果：x=992，y=992<br>x的值：992<br>x的值：993<br>y的值：993<br>得到最终结果：x=994，y=993<br>x的值：994<br>y的值：994<br>得到最终结果：x=994，y=994<br>x的值：995<br>y的值：995<br>得到最终结果：x=995，y=995<br>x的值：996<br>y的值：996<br>得到最终结果：x=996，y=996<br>x的值：997<br>y的值：997<br>得到最终结果：x=997，y=997<br>x的值：998<br>y的值：998<br>得到最终结果：x=998，y=998<br>得到最终结果：x=999，y=999<br>x的值：999<br>y的值：999<br>得到最终结果：x=1000，y=1000<br>从执行结果看，是同步的。","like_count":0},{"had_liked":false,"id":290062,"user_name":"孤傲的虎王","can_delete":false,"product_type":"c1","uid":2536451,"ip_address":"","ucode":"FE9B90D6EEBAFB","user_header":"https://static001.geekbang.org/account/avatar/00/26/b4/03/677fd301.jpg","comment_is_top":false,"comment_ctime":1619342926,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619342926","product_id":100023901,"comment_content":"精彩，实习项目也有一个很相似的落库场景，垃圾项目一下子就能包装了呀，太爽了","like_count":0},{"had_liked":false,"id":287461,"user_name":"时光守护者-基兰","can_delete":false,"product_type":"c1","uid":1554995,"ip_address":"","ucode":"F0B0887B1979D2","user_header":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","comment_is_top":false,"comment_ctime":1617959845,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617959845","product_id":100023901,"comment_content":"老师回复下：<br>我看最后一个线程执行完 --count，回调函数后，执行nextGeneration，nextGeneration里会去执行trip.signalAll()，那是最后一个线程唤醒之前等待的线程吗？<br><br>源码：<br>int index = --count;<br>            if (index == 0) {  &#47;&#47; tripped<br>                boolean ranAction = false;<br>                try {<br>                    final Runnable command = barrierCommand;<br>                    if (command != null)<br>                        command.run();<br>                    ranAction = true;<br>                    nextGeneration();<br>                    return 0;<br>                } finally {<br>                    if (!ranAction)<br>                        breakBarrier();<br>                }<br>            }","like_count":0},{"had_liked":false,"id":285770,"user_name":"Laughing","can_delete":false,"product_type":"c1","uid":1002134,"ip_address":"","ucode":"F68F1E000CA800","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/96/99466a06.jpg","comment_is_top":false,"comment_ctime":1617007224,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617007224","product_id":100023901,"comment_content":"有必要，如果每次都new都需要向系统进行申请资源，必定有CPU的消耗。除此之外，可控的线程池是系统可控的基础。","like_count":0},{"had_liked":false,"id":282474,"user_name":"Geek_aa23b7","can_delete":false,"product_type":"c1","uid":2461872,"ip_address":"","ucode":"DD89F30A04D5CC","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL23Wicb0gO9RIXrRzpettuEYaSHLicA2LgRz3X7Npiagf1R4aB9bmePt1TY006z63ngKzhEONZvOsfw/132","comment_is_top":false,"comment_ctime":1615270771,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615270771","product_id":100023901,"comment_content":"老师你好，学习了您的课程获益匪浅，针对课后思考我有以下见解，CyclicBarrier例子似乎是存在问题的，check方法用单线程的方式保证串行，但是check方法和T1、T2方法是仍然是并行的，那两个队列就存在线程安全问题。要真正保证线程安全可以把check方法对队列的处理 p = pos.remove(0);<br>                D d = dos.remove(0); 放到CyclicBarrier中。这样就保证了两个队列的线程安全，同时check方法也不存在线程安全问题了，线程池的线程数量也就可以根据真实情景做调整。final CyclicBarrier barrier =<br>            new CyclicBarrier(2, ()-&gt;{<br>                P p = pos.remove(0);<br>                D d = dos.remove(0);<br>                executor.execute(()-&gt;{<br>                    check(p,d);<br>                });<br>            });<br><br>    void check(p, d){<br>        &#47;&#47; 执行对账操作<br>        diff = check(p, d);<br>        &#47;&#47; 差异写入差异库<br>        save(diff);<br>    }","like_count":0},{"had_liked":false,"id":281588,"user_name":"俺能学个啥","can_delete":false,"product_type":"c1","uid":1026742,"ip_address":"","ucode":"30740C5B58774C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/b6/46a5bbf3.jpg","comment_is_top":false,"comment_ctime":1614820726,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614820726","product_id":100023901,"comment_content":"固定大小线程池只是限制了创建的最多线程数，但阻塞队列仍是无界的，如果生产速度远远大于消费速度，依然会造成OOM，可以使用自定义的线程池构造一个有界的阻塞队列","like_count":0},{"had_liked":false,"id":268650,"user_name":"张洋","can_delete":false,"product_type":"c1","uid":1182914,"ip_address":"","ucode":"549BE5DEEF8417","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/c2/bad34a50.jpg","comment_is_top":false,"comment_ctime":1608282646,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1608282646","product_id":100023901,"comment_content":"老师，我验证了一下 CyclicBarrier 的回调函数，用的其实是执行任务最后一个技术的线程来执行的，所以再加一个线程池是不是显得没有必要了。","like_count":0},{"had_liked":false,"id":262562,"user_name":"Geek_89e362","can_delete":false,"product_type":"c1","uid":2308075,"ip_address":"","ucode":"E596C2CFE1CFAF","user_header":"","comment_is_top":false,"comment_ctime":1605769551,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605769551","product_id":100023901,"comment_content":"直接改成多线程应该是会出现线程安全问题的，因为 check方法中的  P p = pos.remove(0);  D d = dos.remove(0); 两个存在竞态条件。改成多线程加个锁应该就可以了。<br>比如：<br>Lock lock = new ReentrantLock(true);<br>void check(){ <br>     P p = null;<br>\t D d = null;<br>     lock.lock();<br>\t try{<br>\t   p = pos.remove(0); <br>\t   d = dos.remove(0); <br>\t }finally{<br>\t   lock.unlock();<br>\t }\t<br>\t &#47;&#47; 执行对账操作  <br>\t diff = check(p, d);  <br>\t &#47;&#47; 差异写入差异库  <br>\t save(diff);<br> }","like_count":0},{"had_liked":false,"id":251118,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1601368092,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1601368092","product_id":100023901,"comment_content":"有必要使用线程池，一是保证消费者是异步进行，二是单个线程能保证remove操作时线程安全的","like_count":0},{"had_liked":false,"id":237857,"user_name":"再续啸傲","can_delete":false,"product_type":"c1","uid":1360184,"ip_address":"","ucode":"912987A17DCA92","user_header":"https://static001.geekbang.org/account/avatar/00/14/c1/38/e45bbb6b.jpg","comment_is_top":false,"comment_ctime":1595987457,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595987457","product_id":100023901,"comment_content":"如果是生产者-消费者模式，是否可以考虑使用SingleThreadExecutor呢？","like_count":0},{"had_liked":false,"id":230691,"user_name":"小乙哥","can_delete":false,"product_type":"c1","uid":1063308,"ip_address":"","ucode":"C77E79BEA0C325","user_header":"https://static001.geekbang.org/account/avatar/00/10/39/8c/089525aa.jpg","comment_is_top":false,"comment_ctime":1593458831,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593458831","product_id":100023901,"comment_content":"CyclicBarrier的例子有个最大的问题是，生产者如果有一个线程(比如，T1)异常导致数据没有写入队列，而另一个线程T2正常写入数据到队列。会导致消费线程消费数据错序。","like_count":0},{"had_liked":false,"id":225400,"user_name":"发哥","can_delete":false,"product_type":"c1","uid":1281495,"ip_address":"","ucode":"E2BA6621422D08","user_header":"https://static001.geekbang.org/account/avatar/00/13/8d/d7/eeceb2d5.jpg","comment_is_top":false,"comment_ctime":1591750968,"is_pvip":false,"replies":[{"id":"83406","content":"T1和T2可以并行","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1592125999,"ip_address":"","comment_id":225400,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591750968","product_id":100023901,"comment_content":"老师，前面在还没使用线程池优化的时候，用T1. join()，T2. join()进行等待，这里是不是没有并行的效果，我的理解还是单线程执行的效果，不知道我的理解对不对？麻烦老师解答，谢谢","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497835,"discussion_content":"T1和T2可以并行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592125999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223179,"user_name":"ξ！","can_delete":false,"product_type":"c1","uid":1636657,"ip_address":"","ucode":"F9797D21EBE10E","user_header":"https://static001.geekbang.org/account/avatar/00/18/f9/31/b75cc6d5.jpg","comment_is_top":false,"comment_ctime":1591016385,"is_pvip":false,"replies":[{"id":"112072","content":"没办法保证所有线程事务都回滚","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1630132489,"ip_address":"","comment_id":223179,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591016385","product_id":100023901,"comment_content":"老师，栅栏可以使所有线程共享事务状态么，怎么保证一个线程需要回滚的话所有线程的事务都回滚啊，没有思路啊…","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497043,"discussion_content":"没办法保证所有线程事务都回滚","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630132489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222006,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1590654951,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590654951","product_id":100023901,"comment_content":"老师，我用CyclicBarrier模拟了下，work3方法等work1和work2执行完之后再回调work3，但是发现work3没执行，是怎么回事呀？CountDownLatch是可以的<br><br>public class CyclicBarrierDemo {<br>    &#47;&#47;执行回调的线程池<br>    private Executor executor = Executors.newFixedThreadPool(1);<br><br>    @Test<br>    public void test() {<br>        CyclicBarrier barrier = new CyclicBarrier(2, () -&gt; {<br>            executor.execute(() -&gt; {<br>                work3();<br>            });<br>        });<br><br>        new Thread(() -&gt; {<br>            work();<br>            try {<br>                &#47;&#47;等待<br>                barrier.await();<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            } catch (BrokenBarrierException e) {<br>                e.printStackTrace();<br>            }<br>        }).start();<br><br>        new Thread(() -&gt; {<br>            work2();<br>            try {<br>                &#47;&#47;等待<br>                barrier.await();<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            } catch (BrokenBarrierException e) {<br>                e.printStackTrace();<br>            }<br>        }).start();<br><br><br>    }<br><br><br>    public void work() {<br>        for (int i = 0; i &lt; 100; i++) {<br>            System.out.println(&quot;乌龟跑了[&quot; + i + &quot;]米&quot;);<br>        }<br>    }<br><br>    public void work2() {<br>        for (int i = 0; i &lt; 100; i++) {<br>            System.out.println(&quot;兔子跑了[&quot; + i + &quot;]米&quot;);<br>        }<br>    }<br><br>    public void work3() {<br>        for (int i = 0; i &lt; 100; i++) {<br>            System.out.println(&quot;上帝跑了[&quot; + i + &quot;]米&quot;);<br>        }<br>    }<br><br><br>}","like_count":0},{"had_liked":false,"id":217797,"user_name":"kimoti","can_delete":false,"product_type":"c1","uid":1897671,"ip_address":"","ucode":"0A78077408C2B1","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f4/c7/037235c9.jpg","comment_is_top":false,"comment_ctime":1589615271,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589615271","product_id":100023901,"comment_content":"请教老师假如这个回调函数不用线程池去执行check方法的话，也就是同步调用check方法的话，循环查询订单库和循环查询运单库的线程会被阻塞吗？<br><br>或者说假如上一轮的check函数未执行完成，这一轮的check函数会等上一轮的check函数执行完成之后再执行吗?","like_count":0},{"had_liked":false,"id":217780,"user_name":"kimoti","can_delete":false,"product_type":"c1","uid":1897671,"ip_address":"","ucode":"0A78077408C2B1","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f4/c7/037235c9.jpg","comment_is_top":false,"comment_ctime":1589612131,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589612131","product_id":100023901,"comment_content":"感觉老师这个对账系统设计的很精妙","like_count":0},{"had_liked":false,"id":211133,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1587900183,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587900183","product_id":100023901,"comment_content":"单线程的线程池保证了ckeck时能够避免并发数据安全，同时将同步转成异步处理。","like_count":0},{"had_liked":false,"id":206685,"user_name":"你存在～我脑海里","can_delete":false,"product_type":"c1","uid":1786377,"ip_address":"","ucode":"3E06D047764062","user_header":"https://static001.geekbang.org/account/avatar/00/1b/42/09/8cfa5a76.jpg","comment_is_top":false,"comment_ctime":1586917138,"is_pvip":false,"replies":[{"id":"77815","content":"可以","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1587346580,"ip_address":"","comment_id":206685,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586917138","product_id":100023901,"comment_content":"1.请问最后的代码，查询订单库和派单库在while里面每次创建新的线程，这里是否可以也用线程池来复用线程呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491865,"discussion_content":"可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587346580,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203373,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1274787,"ip_address":"","ucode":"C233DF1D224EC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","comment_is_top":false,"comment_ctime":1586180770,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1586180770","product_id":100023901,"comment_content":"实际使用中线程池如何创建？<br> @Bean(&quot;feedExecutor&quot;)<br>    public Executor feedExecutor() {<br>        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();<br>        executor.setCorePoolSize(8);<br>        executor.setMaxPoolSize(20);<br>        executor.setQueueCapacity(1000);<br>        executor.setKeepAliveSeconds(100);<br>        executor.setThreadNamePrefix(&quot;feed-executor-&quot;);<br>        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());<br>        return executor;<br>    }<br><br>使用这种方法创建后，CountDownLatch和Async如何结合使用？","like_count":0},{"had_liked":false,"id":187297,"user_name":"凯","can_delete":false,"product_type":"c1","uid":1670995,"ip_address":"","ucode":"BFEA3EE7393B80","user_header":"https://static001.geekbang.org/account/avatar/00/19/7f/53/a9ae31ce.jpg","comment_is_top":false,"comment_ctime":1584077478,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584077478","product_id":100023901,"comment_content":"有个疑问 对账的时候 为什么能确保订单里面取得一条与派送里面取得一条是对应的","like_count":0},{"had_liked":false,"id":166205,"user_name":"Cv","can_delete":false,"product_type":"c1","uid":1062797,"ip_address":"","ucode":"C77CE172B5AA28","user_header":"","comment_is_top":false,"comment_ctime":1577415496,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577415496","product_id":100023901,"comment_content":"一个想法: 如果不使用2个队列,而是封装成一个队列的话, 那么check的线程池大小就可以扩大不必是1个, 在get比check快的情况下, 性能可以进一步提升","like_count":0},{"had_liked":false,"id":163445,"user_name":"特雷西皮皮","can_delete":false,"product_type":"c1","uid":1564539,"ip_address":"","ucode":"0BE139A55157F0","user_header":"https://static001.geekbang.org/account/avatar/00/17/df/7b/4ad93869.jpg","comment_is_top":false,"comment_ctime":1576722859,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576722859","product_id":100023901,"comment_content":"目前看讲的最好的一篇。","like_count":0},{"had_liked":false,"id":160476,"user_name":"Wanderlust","can_delete":false,"product_type":"c1","uid":1014854,"ip_address":"","ucode":"F004489DC0E168","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7c/46/89b60401.jpg","comment_is_top":false,"comment_ctime":1575958637,"is_pvip":false,"replies":[{"id":"61363","content":"加日志应该就可以","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1576072523,"ip_address":"","comment_id":160476,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1575958637","product_id":100023901,"comment_content":"老师您好！这篇文章层层递进，易于理解，非常喜欢！想问下如何写测试来验证以上几个版本的执行顺序正如图片中所画的？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477386,"discussion_content":"加日志应该就可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576072523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153433,"user_name":"朕爱吾妃","can_delete":false,"product_type":"c1","uid":1733692,"ip_address":"","ucode":"B10EB69934F9E2","user_header":"https://static001.geekbang.org/account/avatar/00/1a/74/3c/da79d2a1.jpg","comment_is_top":false,"comment_ctime":1574235270,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574235270","product_id":100023901,"comment_content":"茅塞顿开，在做手头的项目的时候，通常一个HTTP请求里会执行多个SQL语句，然后将查询结果进行赋值或拼接，往往这些SQL都是依赖第一个sql执行结果，而后面的SQL彼此之间没有依赖关系，那么完全可以多线程进行操作，然后等所有线程执行完毕或是去队列中去结果都可以实现SQL执行完毕后的赋值和拼接的操作。<br>再来回答思考题，假如不是1线程，是2个线程，那么第一个线程先返回订单结果，第二个线程先返回的是派送的结果，结果这两个匹配上了，直接对账，这样最终结果就错了","like_count":0},{"had_liked":false,"id":148131,"user_name":"Joker","can_delete":false,"product_type":"c1","uid":1156592,"ip_address":"","ucode":"126AF848001A1E","user_header":"https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg","comment_is_top":false,"comment_ctime":1572945904,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572945904","product_id":100023901,"comment_content":"如果多线程，队列里面有两个数据，t1先执行，到了取了在pos队列remove（0），然后切到t2一下子就pos队列remove（0），dos队列remove（0），然后就发生订单和派送单是两个本来就不同的两个数据的情况了。<br>因为这里有可能查的速度比校对的速度还要快，所以用多线程有可能出现上面这种情况。","like_count":0},{"had_liked":false,"id":146979,"user_name":"张德","can_delete":false,"product_type":"c1","uid":1101929,"ip_address":"","ucode":"31FE63E8725EFC","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/69/5dbdc245.jpg","comment_is_top":false,"comment_ctime":1572750607,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572750607","product_id":100023901,"comment_content":"再看老师的专栏  感觉有不一样的东西","like_count":0},{"had_liked":false,"id":144500,"user_name":"ty_young","can_delete":false,"product_type":"c1","uid":1284337,"ip_address":"","ucode":"EB1D5DB0AE7B33","user_header":"","comment_is_top":false,"comment_ctime":1571961034,"is_pvip":false,"replies":[{"id":"55721","content":"😄","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1571976107,"ip_address":"","comment_id":144500,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571961034","product_id":100023901,"comment_content":"讲得好，又来读一遍😁","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471973,"discussion_content":"😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571976107,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136963,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1569567417,"is_pvip":true,"replies":[{"id":"52708","content":"并发之外的要看具体场景，我们就不纠结这个了😄","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1569667817,"ip_address":"","comment_id":136963,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569567417","product_id":100023901,"comment_content":"有个并发之外的问题，老师实现的时候是如何保证订单队列和派送队列的按序一一对应的？我理解的是这两个队列都是并发无序的，虽然他们之间存在对应关系，但是每次都取队列头元素并保持一一对应，那一个跑得快，一个跑得慢，不是需要阻塞其中一个等待吗？我觉得可以使用hash的思路来存储两个队列的元素，有什么不对的地方，还请老师指教","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468882,"discussion_content":"并发之外的要看具体场景，我们就不纠结这个了😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569667817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136750,"user_name":"王伟","can_delete":false,"product_type":"c1","uid":1445561,"ip_address":"","ucode":"22D0188425E839","user_header":"https://static001.geekbang.org/account/avatar/00/16/0e/b9/7866f19d.jpg","comment_is_top":false,"comment_ctime":1569502293,"is_pvip":false,"replies":[{"id":"53616","content":"建议出现问题的时候dump线程看看，也可以dump内存，这样更容易找到问题","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1570581227,"ip_address":"","comment_id":136750,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569502293","product_id":100023901,"comment_content":"老师你好,我这边使用CountDownLatch碰到一个问题,使用计数器,来保证同步订单的线程执行完毕后,在执行后续逻辑,但是有的时候会阻塞在await()方法处,导致后续逻辑无法进行,能帮忙分析下吧.代码如下:<br>        &#47;&#47;创建一个计数器<br>        final CountDownLatch latch = new CountDownLatch(mataData.size());<br>        &#47;&#47;处理单个订单<br>        for(final EbsOrdersDO ebsOrdersDO : mataData){<br>            executor.submit(new Runnable() {<br>                @Override<br>                public void run() {<br>                    try {<br>                        singleOrderProcess(merchantNum, ebsOrdersDO.getPlatformOrderId());<br>                        &#47;&#47;订单处理成功数+1<br>                        redisHandle.hincrement(progressKey,successKey,1);<br>                    } catch (Throwable e) {<br>                        LOG.error(&quot;&gt;&gt;订单确认收货执行失败..orderId:&quot; + ebsOrdersDO.getPlatformOrderId() + e);<br>                        &#47;&#47;订单处理失败数+1<br>                        redisHandle.hincrement(progressKey,failKey,1);<br>                    }finally {<br>                        if(latch !=null){<br>                            latch.countDown();<br>                        }<br>                    }<br><br>                }<br>            });<br>        }<br>        &#47;&#47;当前线程池消费完了，再继续跑，避免队列堆积过多导致内存溢出,改用计数器的方式判断任务是否执行结束<br>        try {<br>            latch.await();<br>            String completeKey =  MerchantConstants.SYNC_ORDER_KEY + merchantNum+&quot;:complete&quot;;","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468785,"discussion_content":"建议出现问题的时候dump线程看看，也可以dump内存，这样更容易找到问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570581227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134536,"user_name":"静水流深","can_delete":false,"product_type":"c1","uid":1339724,"ip_address":"","ucode":"644F05EFBD2E7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/4c/2cefec07.jpg","comment_is_top":false,"comment_ctime":1568861026,"is_pvip":false,"replies":[{"id":"51656","content":"那就再看一会儿😄","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1568896623,"ip_address":"","comment_id":134536,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568861026","product_id":100023901,"comment_content":"这篇文章，真的看得我爱不释手。大赞。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467795,"discussion_content":"那就再看一会儿😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568896623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130472,"user_name":"dpzain","can_delete":false,"product_type":"c1","uid":1510874,"ip_address":"","ucode":"AA069519176892","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTINb3EmV5q6ytNWclxke1OicbEAw4ZSmibSCrNGZPDCnAjsGDwG3jJQcuEwAcFRffBQouXFEaERQbfw/132","comment_is_top":false,"comment_ctime":1567471536,"is_pvip":false,"replies":[{"id":"48829","content":"高可用属于分布式计算的范畴，这个问题有点开阔","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1567500021,"ip_address":"","comment_id":130472,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567471536","product_id":100023901,"comment_content":"你好  老师，如果真是业务代码  怎么保证双队列的高可用用呢   怎么容错？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465970,"discussion_content":"高可用属于分布式计算的范畴，这个问题有点开阔","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567500021,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130311,"user_name":"静水流深","can_delete":false,"product_type":"c1","uid":1339724,"ip_address":"","ucode":"644F05EFBD2E7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/4c/2cefec07.jpg","comment_is_top":false,"comment_ctime":1567422703,"is_pvip":false,"replies":[{"id":"48631","content":"使用简单","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1567426609,"ip_address":"","comment_id":130311,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567422703","product_id":100023901,"comment_content":"老师怎么那么喜欢用Vector?","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465899,"discussion_content":"使用简单","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567426609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129168,"user_name":"鹏飞天下","can_delete":false,"product_type":"c1","uid":1101792,"ip_address":"","ucode":"EB9FFD9FE64A4C","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/e0/f6819d03.jpg","comment_is_top":false,"comment_ctime":1567054192,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567054192","product_id":100023901,"comment_content":"个人感觉到用单个线程只是我们理论上避免并发，针对这个业务是根本不存在的，首先他需要获取到订单数据和运单数据这是前提，以后再check，check第一步就是remove所以非常之快，并且在下一次check的时候是等待获取订单和运单之后，这时间足够让他remove完了，所以设置多线程没有问题","like_count":0},{"had_liked":false,"id":128326,"user_name":"探索无止境","can_delete":false,"product_type":"c1","uid":1044178,"ip_address":"","ucode":"91D2A9907DFA79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/d2/7024431c.jpg","comment_is_top":false,"comment_ctime":1566870942,"is_pvip":false,"replies":[{"id":"47603","content":"每次对账都＋1就可以了，这个故事为的是说明并发问题，没必要纠结业务","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1566881011,"ip_address":"","comment_id":128326,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566870942","product_id":100023901,"comment_content":"老师你好，案例中的“存在未对账订单”这个条件怎么写的？我的理解是订单有一个状态字段，如果状态值为0，表示未对账，如果是这样，那么完成对账之后，还需要去更新这批订单的状态，而是每次查出来的订单应该是一个集合，而不是一个对象，不知道理解对不对？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464897,"discussion_content":"每次对账都＋1就可以了，这个故事为的是说明并发问题，没必要纠结业务","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566881011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124980,"user_name":"给心来块冰块","can_delete":false,"product_type":"c1","uid":1063689,"ip_address":"","ucode":"7AFB56581782A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/09/2cf074a7.jpg","comment_is_top":false,"comment_ctime":1566032414,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1566032414","product_id":100023901,"comment_content":"我的看法是一个线程可以瞒住对账操作需要的线程池，如果设置多个是否会有线程切换和资源浪费的问题，如果不设置的话每一次的对账操作都要利用匿名内部类的方式创建一个线程，造成线程频繁创建、销毁，使jvm频繁向操作系统申请一个本地线程，频繁gc,不知道是否是这样，请老师讲解线程的创建、jvm、gc是个什么过程","like_count":0},{"had_liked":false,"id":124976,"user_name":"给心来块冰块","can_delete":false,"product_type":"c1","uid":1063689,"ip_address":"","ucode":"7AFB56581782A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/09/2cf074a7.jpg","comment_is_top":false,"comment_ctime":1566031395,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1566031395","product_id":100023901,"comment_content":"关于线程池的设置之前老师有讲过要根据具体的业务类型和硬件CPU的核数进行设置，是否可以任务的个数设置线程池的大小","like_count":0},{"had_liked":false,"id":121841,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1565232132,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565232132","product_id":100023901,"comment_content":"老师我模拟你的程序，发现运行的时候有BrokenBarrierException，麻烦老师解答下：<br>public class CyclicBarrierTest03 {<br><br><br>    public static void main(String[] args) {<br><br>        ExecutorService executor = Executors.newFixedThreadPool(1);<br><br>        final CyclicBarrier barrier = new CyclicBarrier(2, () -&gt; {<br>            check();<br>        });<br><br>        checkAll(barrier);<br><br>    }<br><br>    public static void check() {<br>        System.out.println(&quot;开始对账 线程名称为&quot; + Thread.currentThread().getName());<br>    }<br><br>    public static void checkAll(CyclicBarrier barrier) {<br>        Thread t1 = new Thread(() -&gt; {<br>            while (true) {<br>                System.out.println(&quot;&lt;--------查询订单库 线程名称为&quot; + Thread.currentThread().getName());<br>                try {<br>                    barrier.await();<br>                } catch (InterruptedException e) {<br>                    e.printStackTrace();<br>                } catch (BrokenBarrierException e) {<br>                    e.printStackTrace();<br>                }<br>            }<br><br>        });<br>        t1.start();<br><br>        Thread t2 = new Thread(() -&gt; {<br>            while (true) {<br>                System.out.println(&quot;--------&gt;查询运单库 线程名称为&quot; + Thread.currentThread().getName());<br>                try {<br>                    barrier.await();<br>                } catch (InterruptedException e) {<br>                    e.printStackTrace();<br>                } catch (BrokenBarrierException e) {<br>                    e.printStackTrace();<br>                }<br>            }<br>        });<br>        t2.start();<br>    }<br>}<br><br>运行完成后会抛出BrokenBarrierException异常！barrier是是什么被broken掉的？？？？","like_count":0},{"had_liked":false,"id":121149,"user_name":"一堆崽崽","can_delete":false,"product_type":"c1","uid":1141798,"ip_address":"","ucode":"CBA84542220B63","user_header":"https://static001.geekbang.org/account/avatar/00/11/6c/26/d09d6fc5.jpg","comment_is_top":false,"comment_ctime":1565065719,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565065719","product_id":100023901,"comment_content":"在使用CountDown的场景下，如果其中一个子线程超时，那么这个子线程在什么时候会释放掉。如果，子线程出现超时的情况比较多，那么线程池出现线程池满，那么这种情况如何处理","like_count":0},{"had_liked":false,"id":119561,"user_name":"Shine","can_delete":false,"product_type":"c1","uid":1022568,"ip_address":"","ucode":"C8C617B87C63C7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9a/68/92caeed6.jpg","comment_is_top":false,"comment_ctime":1564626245,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564626245","product_id":100023901,"comment_content":"线程池就一个线程，订单获取线程和派送单获取线程没法做到异步执行了吧？","like_count":0},{"had_liked":false,"id":117476,"user_name":"SIGHOR","can_delete":false,"product_type":"c1","uid":1439360,"ip_address":"","ucode":"411F85A8FD3DE1","user_header":"https://static001.geekbang.org/account/avatar/00/15/f6/80/830de85d.jpg","comment_is_top":false,"comment_ctime":1564056098,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564056098","product_id":100023901,"comment_content":"设置一个线程是为了防止barrier.await()分几个线程执行，比如t1 后barrier1-1=1,t2 后barrier2-1=1,那么t1,t2可能都在等待了","like_count":0},{"had_liked":false,"id":117274,"user_name":"知易行难","can_delete":false,"product_type":"c1","uid":1005731,"ip_address":"","ucode":"BEE371CF596708","user_header":"https://static001.geekbang.org/account/avatar/00/0f/58/a3/1b270564.jpg","comment_is_top":false,"comment_ctime":1564017892,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564017892","product_id":100023901,"comment_content":"真出现这种问题，首先想到的肯定是优化查询语句，而不是提高并行度","like_count":0},{"had_liked":false,"id":116776,"user_name":"allean","can_delete":false,"product_type":"c1","uid":1051470,"ip_address":"","ucode":"A0D2DB4F219EAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/0b/4e/fd946cb2.jpg","comment_is_top":false,"comment_ctime":1563925376,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563925376","product_id":100023901,"comment_content":"精彩！看的非常畅快，感谢~","like_count":0},{"had_liked":false,"id":115190,"user_name":"君君","can_delete":false,"product_type":"c1","uid":1054285,"ip_address":"","ucode":"E2FA7EEB2C936B","user_header":"https://static001.geekbang.org/account/avatar/00/10/16/4d/55e2eb36.jpg","comment_is_top":false,"comment_ctime":1563504668,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1563504668","product_id":100023901,"comment_content":"CountDownLatch 和 CyclicBarrier 可以混用么","like_count":0},{"had_liked":false,"id":113993,"user_name":"飘呀飘的小叶子","can_delete":false,"product_type":"c1","uid":1398591,"ip_address":"","ucode":"D662116E38B212","user_header":"https://static001.geekbang.org/account/avatar/00/15/57/3f/0009a20f.jpg","comment_is_top":false,"comment_ctime":1563201086,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563201086","product_id":100023901,"comment_content":"使用线程池是将check异步执行不影响订单库和云单库的查询，设置为1就相当于同步下的锁，后来的只能在等待队列等待，能防止订单库查询太快而check太慢导致数据不一致，例如第一次check才执行到P p = pos.remove(0);后来的check已经执行完了，因此后来的check反而先执行了D d = dos.remove(0);而这个数据理应是第一次check的。","like_count":0},{"had_liked":false,"id":110492,"user_name":"心如止水、","can_delete":false,"product_type":"c1","uid":1107126,"ip_address":"","ucode":"8D801DECDA88BA","user_header":"https://static001.geekbang.org/account/avatar/00/10/e4/b6/49b8a39d.jpg","comment_is_top":false,"comment_ctime":1562287755,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562287755","product_id":100023901,"comment_content":"超时时间是不是一旦设置了，万一还没走完岂不是出现脏数据了？","like_count":0},{"had_liked":false,"id":110417,"user_name":"13761642169","can_delete":false,"product_type":"c1","uid":1232334,"ip_address":"","ucode":"68137695FC2120","user_header":"","comment_is_top":false,"comment_ctime":1562252261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562252261","product_id":100023901,"comment_content":"文章太精彩了","like_count":0},{"had_liked":false,"id":107677,"user_name":"龙行秀","can_delete":false,"product_type":"c1","uid":1351066,"ip_address":"","ucode":"2DA088D199EA9D","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/9a/7f064a9f.jpg","comment_is_top":false,"comment_ctime":1561595920,"is_pvip":false,"replies":[{"id":"38938","content":"会","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1561596606,"ip_address":"","comment_id":107677,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561595920","product_id":100023901,"comment_content":"举例中<br>T1.join();<br>T2.join();<br>T1的join不会阻塞当前主线程嘛？<br>","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455623,"discussion_content":"会","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561596606,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106013,"user_name":"王藝明","can_delete":false,"product_type":"c1","uid":1546333,"ip_address":"","ucode":"374D68B8D3FAFC","user_header":"https://static001.geekbang.org/account/avatar/00/17/98/5d/8e91b338.jpg","comment_is_top":false,"comment_ctime":1561127078,"is_pvip":false,"replies":[{"id":"38345","content":"办法有很多，目标是一致的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1561160897,"ip_address":"","comment_id":106013,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561127078","product_id":100023901,"comment_content":"感觉也可以用两个阻塞队列？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454914,"discussion_content":"办法有很多，目标是一致的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561160897,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105720,"user_name":"招财","can_delete":false,"product_type":"c1","uid":1249970,"ip_address":"","ucode":"8A6781148A9932","user_header":"https://static001.geekbang.org/account/avatar/00/13/12/b2/3fb9a4a1.jpg","comment_is_top":false,"comment_ctime":1561078531,"is_pvip":false,"replies":[{"id":"38281","content":"得看场景","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1561092919,"ip_address":"","comment_id":105720,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561078531","product_id":100023901,"comment_content":"老师，这些并发容器，和读锁写锁相比较起来，哪一种性能更好呢","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454785,"discussion_content":"得看场景","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561092919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103618,"user_name":"Adam","can_delete":false,"product_type":"c1","uid":1517838,"ip_address":"","ucode":"965DCD693E752B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK36t2flfxhzKygfLfdIHbK99M9D9w3v3bwAHUibJSFAs1ibswf7hbhkqL321k5SUjfiaWkkHeRBlibNA/132","comment_is_top":false,"comment_ctime":1560477804,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560477804","product_id":100023901,"comment_content":"设置为1 应该是为了在check中保证单线程去两个不同的队列取数据保证数据安全 不然可能会导致check两个队列的取数据不一致有问题","like_count":0},{"had_liked":false,"id":103148,"user_name":"何妨","can_delete":false,"product_type":"c1","uid":1385377,"ip_address":"","ucode":"EC3983BFF7992A","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","comment_is_top":false,"comment_ctime":1560387946,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560387946","product_id":100023901,"comment_content":"我想问最后一个代码例子在查询的时候为什么不用线程池了呢","like_count":0},{"had_liked":false,"id":100003,"user_name":"阿辉","can_delete":false,"product_type":"c1","uid":1266788,"ip_address":"","ucode":"A7EF42A10E2599","user_header":"https://static001.geekbang.org/account/avatar/00/13/54/64/8f3d000a.jpg","comment_is_top":false,"comment_ctime":1559383878,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559383878","product_id":100023901,"comment_content":"查询订单与查询派送单做不到并行吧","like_count":0},{"had_liked":false,"id":99903,"user_name":"sean👿","can_delete":false,"product_type":"c1","uid":1040670,"ip_address":"","ucode":"88BEBC620C0713","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e1/1e/1327891b.jpg","comment_is_top":false,"comment_ctime":1559355948,"is_pvip":false,"replies":[{"id":"36137","content":"PPT😂","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1559542066,"ip_address":"","comment_id":99903,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559355948","product_id":100023901,"comment_content":" 问个题外的问题，老师是用什么软件来画什么的图的呢","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452315,"discussion_content":"PPT😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559542066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99231,"user_name":"linsen","can_delete":false,"product_type":"c1","uid":1187010,"ip_address":"","ucode":"1DBBBA0988DB63","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/05Wiazxo0OS5w9KdJ4OQAe3ezwaCXNY4DGoE0noPFzXtUhOGejgGKFR6WmMxr0KcEGOSahnjbOwxPSib88h0E6zA/132","comment_is_top":false,"comment_ctime":1559179944,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559179944","product_id":100023901,"comment_content":"为什么大家都说如果线程池大小不为1的话会取到错乱的数据呢，我的理解是由于CyclicBarrier的控制，这两个队列放入元素的步调应该是一致的，只有两个队列都放入了一个元素，才会执行回调函数，只有回调函数执行完成之后才会唤醒两个往队列放入元素的线程，不会造成一个队列里面的元素多放了，一个队列里面的元素少放的场景啊，求解答","like_count":0},{"had_liked":false,"id":96651,"user_name":"Geek_e6f3ec","can_delete":false,"product_type":"c1","uid":1360738,"ip_address":"","ucode":"A0ACE49CD3F9BB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotuhVFN9phZnUxxXueAm8rDDibjIkj0L8W7VojYRpSeXwHtDSgLW3SdrNjMQy0AcOUuMmTAQSyO3g/132","comment_is_top":false,"comment_ctime":1558484459,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1558484459","product_id":100023901,"comment_content":"看了undifined的评论有一点理解， 如果装返回单的是queue队列线程池可以有多个吗？","like_count":0},{"had_liked":false,"id":96098,"user_name":"小小少年","can_delete":false,"product_type":"c1","uid":1446717,"ip_address":"","ucode":"BCBEC92B9DFA85","user_header":"https://static001.geekbang.org/account/avatar/00/16/13/3d/63bab08c.jpg","comment_is_top":false,"comment_ctime":1558329824,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558329824","product_id":100023901,"comment_content":"这篇写的真的好","like_count":0},{"had_liked":false,"id":90119,"user_name":"正义柔情永在","can_delete":false,"product_type":"c1","uid":1385762,"ip_address":"","ucode":"41BAA3827C8FF5","user_header":"https://static001.geekbang.org/account/avatar/00/15/25/22/80bb0990.jpg","comment_is_top":false,"comment_ctime":1556419462,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556419462","product_id":100023901,"comment_content":"这篇文章举的事例特别符合开发过程中的许多场景.非常精彩,受教了","like_count":0},{"had_liked":false,"id":87499,"user_name":"悟空","can_delete":false,"product_type":"c1","uid":1451125,"ip_address":"","ucode":"F9DFBA74B35B40","user_header":"https://static001.geekbang.org/account/avatar/00/16/24/75/808ac160.jpg","comment_is_top":false,"comment_ctime":1555628688,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555628688","product_id":100023901,"comment_content":"消费的速度与生产的速度匹配。<br>如果这个值设置成固定的2会造成消费者线程的浪费。<br>如果是一个非固定的线程池，实际也只有一个线程在运行","like_count":0},{"had_liked":false,"id":87475,"user_name":"JGOS","can_delete":false,"product_type":"c1","uid":1237592,"ip_address":"","ucode":"46A905A169408F","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/58/2468a5e9.jpg","comment_is_top":false,"comment_ctime":1555603495,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555603495","product_id":100023901,"comment_content":"老师讲的真的好！","like_count":0},{"had_liked":false,"id":85908,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1555290997,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555290997","product_id":100023901,"comment_content":"日常打卡，期待老师后续更精彩的讲解！","like_count":0},{"had_liked":false,"id":85454,"user_name":"Corner","can_delete":false,"product_type":"c1","uid":1446316,"ip_address":"","ucode":"7862D593172536","user_header":"https://static001.geekbang.org/account/avatar/00/16/11/ac/9cc5e692.jpg","comment_is_top":false,"comment_ctime":1555063317,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555063317","product_id":100023901,"comment_content":"订单队列和派送单队列取值那里能否加一个锁呢？这样就可以保证多线程需要操作两个队列的不同步问题了。","like_count":0},{"had_liked":false,"id":85121,"user_name":"八戒","can_delete":false,"product_type":"c1","uid":1113109,"ip_address":"","ucode":"15774D7D5F1E53","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/15/a1f83883.jpg","comment_is_top":false,"comment_ctime":1554984505,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554984505","product_id":100023901,"comment_content":"我不太赞同“undifined”同学的说法。此处的线程池是用来执行check()方法，和订单、派送单的查询没有关系，所以我的观点是固定线程池没有必要。","like_count":0},{"had_liked":false,"id":85083,"user_name":"道","can_delete":false,"product_type":"c1","uid":1324160,"ip_address":"","ucode":"851A0AD751D317","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/80/30e9ae41.jpg","comment_is_top":false,"comment_ctime":1554974841,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554974841","product_id":100023901,"comment_content":"就这个题目而言，我觉得需要一个固定为一的线程。对账操作是通过回调进行的。虽然从时间上讲，对账回调肯定是有先后顺序，毕竟是按照两个线程都查完数据这个顺序调用回调函数。但是这样，回调逻辑就是多线程的，没有顺序。不能指望业务来保证吧。。。。。我们要假定回调调用的时机不确定<br><br>有想过对回调函数加锁，这样能保证顺序。应该也可以","like_count":0},{"had_liked":false,"id":85052,"user_name":"Smile","can_delete":false,"product_type":"c1","uid":1125189,"ip_address":"","ucode":"0617032294DC43","user_header":"https://static001.geekbang.org/account/avatar/00/11/2b/45/e8f64725.jpg","comment_is_top":false,"comment_ctime":1554967692,"is_pvip":false,"replies":[{"id":"30507","content":"只允许一个线程执行checkall","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554984294,"ip_address":"","comment_id":85052,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554967692","product_id":100023901,"comment_content":"文章很生动，但是有几个问题想请教一下老师，都是对于最后的案例：<br>1. 如果有两个线程都执行，checkall方法，假如两个线程都执行完了doOrder 方法，这样调用回调函数，就会存在队列dos中没有数据的问题，不知道理解是否正确，解决方法，是在类中定义一个由两个线程的固定线程池以及对checkall方法进行加锁，当一个线程获取到了线程池之后，另外一个线程只能等到释放后才能使用，这样保证了两个队列中数据的同步<br><br>对于思考题，有必要的，感觉和我形容的问题是一样的，通过线程池来约束，只有一个线程来执行回调方法，不会存在并发问题","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446541,"discussion_content":"只允许一个线程执行checkall","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554984294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85027,"user_name":"张天屹","can_delete":false,"product_type":"c1","uid":1477612,"ip_address":"","ucode":"8BD6BD6DCF0F4F","user_header":"https://static001.geekbang.org/account/avatar/00/16/8b/ec/dc03f5ad.jpg","comment_is_top":false,"comment_ctime":1554962103,"is_pvip":false,"replies":[{"id":"30593","content":"AQS太底层了，了解它对于应用来说基本没影响，这个专栏定位还是比较初级的。现在市面上有很多书，都讲的挺好的。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554999358,"ip_address":"","comment_id":85027,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554962103","product_id":100023901,"comment_content":"老师，我看CyclicBarrier源码比较简单，就是个lock+condition<br>CountDownLatch却是实现了AQS，后面会专门讲一讲AQS吗","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446535,"discussion_content":"AQS太底层了，了解它对于应用来说基本没影响，这个专栏定位还是比较初级的。现在市面上有很多书，都讲的挺好的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554999358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85026,"user_name":"ack","can_delete":false,"product_type":"c1","uid":1440912,"ip_address":"","ucode":"69CA1233EEA8E2","user_header":"https://static001.geekbang.org/account/avatar/00/15/fc/90/c9df0459.jpg","comment_is_top":false,"comment_ctime":1554960481,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554960481","product_id":100023901,"comment_content":"需要，不然多线程并发调用remove的话，不能保证一对一取出数据","like_count":0},{"had_liked":false,"id":85019,"user_name":"拒绝","can_delete":false,"product_type":"c1","uid":1335155,"ip_address":"","ucode":"CB0264C4D3FE17","user_header":"https://static001.geekbang.org/account/avatar/00/14/5f/73/bb3dc468.jpg","comment_is_top":false,"comment_ctime":1554958002,"is_pvip":false,"replies":[{"id":"30517","content":"不会反复创建，同时为了讲起来方便","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554985148,"ip_address":"","comment_id":85019,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554958002","product_id":100023901,"comment_content":"老师，为什么checkAll（）中的线程不使用线程池呢","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446532,"discussion_content":"不会反复创建，同时为了讲起来方便","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554985148,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84971,"user_name":"Mr.Wood","can_delete":false,"product_type":"c1","uid":1482206,"ip_address":"","ucode":"348E13CFCEDC3D","user_header":"https://static001.geekbang.org/account/avatar/00/16/9d/de/1b946a63.jpg","comment_is_top":false,"comment_ctime":1554950461,"is_pvip":false,"replies":[{"id":"30515","content":"效率还是要看并行度","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554984766,"ip_address":"","comment_id":84971,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554950461","product_id":100023901,"comment_content":"我觉得效率还不是最高的，使用阻塞队列的话，在check()处进行并发处理，效率应该可以更高。当然，这样的话每次从2个队列中弹数据出来必须保证同步操作，并且同步块中必须保持检查2个队列的大小是否一致。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446513,"discussion_content":"效率还是要看并行度","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554984766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84949,"user_name":"晓杰","can_delete":false,"product_type":"c1","uid":1441546,"ip_address":"","ucode":"1174C88EEBF8A6","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","comment_is_top":false,"comment_ctime":1554948779,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554948779","product_id":100023901,"comment_content":"有必要，因为线程T1，T2和T3必须一一对应，才能保证顺序不会错乱，如果使用的不是固定一个线程的线程池，可能会导致多个线程一起执行check方法，这样从队列里面取出的订单可能不是一一对应的","like_count":0},{"had_liked":false,"id":84926,"user_name":"Lemon","can_delete":false,"product_type":"c1","uid":1155474,"ip_address":"","ucode":"FED3B7D2931152","user_header":"https://static001.geekbang.org/account/avatar/00/11/a1/92/ad27079c.jpg","comment_is_top":false,"comment_ctime":1554946154,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554946154","product_id":100023901,"comment_content":"今天的分享有意思👏<br>有意义，避免重复创建线程","like_count":0},{"had_liked":false,"id":84925,"user_name":"甄的猛士","can_delete":false,"product_type":"c1","uid":1066343,"ip_address":"","ucode":"1BACE91A1F77FE","user_header":"https://static001.geekbang.org/account/avatar/00/10/45/67/d96a32a0.jpg","comment_is_top":false,"comment_ctime":1554945913,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554945913","product_id":100023901,"comment_content":"今天课程思路清晰，容易理解接受。值得学习这个课程思路","like_count":0},{"had_liked":false,"id":84918,"user_name":"君哥聊技术","can_delete":false,"product_type":"c1","uid":1325816,"ip_address":"","ucode":"2C9A22BCE4C79E","user_header":"https://static001.geekbang.org/account/avatar/00/14/3a/f8/c1a939e7.jpg","comment_is_top":false,"comment_ctime":1554945356,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554945356","product_id":100023901,"comment_content":"赞成西西弗与卡·的观点","like_count":0},{"had_liked":false,"id":84917,"user_name":"周治慧","can_delete":false,"product_type":"c1","uid":1335293,"ip_address":"","ucode":"7D56C4E66BEE17","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKR3ibELhjgVicCNShZCBwvaDxibnzibggG4wUzVkS2mkDxUBZyIs87nDEdJ7PiahJBVoZcuhQ84RxAziag/132","comment_is_top":false,"comment_ctime":1554945341,"is_pvip":false,"replies":[{"id":"30847","content":"源头都是订单，派送单都有一个外键是订单ID，都是用订单ID查，所以不存在同一区间的问题","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555241945,"ip_address":"","comment_id":84917,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554945341","product_id":100023901,"comment_content":"订单队列和派送队列在比对数据的过程中可能是134 1234这样就不是remove（0）的操作了。还有个问题请教一下老师，当每天需要对账的订单和派送队列数据都较大的时候，怎么合适的分批量取出id都在同一个区间的数据去对账。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446494,"discussion_content":"源头都是订单，派送单都有一个外键是订单ID，都是用订单ID查，所以不存在同一区间的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555241945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84914,"user_name":"zhangtnty","can_delete":false,"product_type":"c1","uid":1180553,"ip_address":"","ucode":"3C9A14BD7CF432","user_header":"https://static001.geekbang.org/account/avatar/00/12/03/89/e1621a01.jpg","comment_is_top":false,"comment_ctime":1554945113,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554945113","product_id":100023901,"comment_content":"王老师好，今天分享有实际案例和解决方法流程，期待以后分享都可以解决案例方式。<br>对于题中的线程池1还是有必要。如果是多个线程池，可能会出现出队的乱序。能解决出队乱序，就得阻塞部分线程，效率应该还是在伯仲之间。","like_count":0},{"had_liked":false,"id":84892,"user_name":"一道阳光","can_delete":false,"product_type":"c1","uid":1239557,"ip_address":"","ucode":"F35207CCCEC6E2","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/05/c0d8014d.jpg","comment_is_top":false,"comment_ctime":1554943416,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554943416","product_id":100023901,"comment_content":"有必要，避免消费者线程多次创建，消耗资源。","like_count":0},{"had_liked":false,"id":84878,"user_name":"张德","can_delete":false,"product_type":"c1","uid":1101929,"ip_address":"","ucode":"31FE63E8725EFC","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/69/5dbdc245.jpg","comment_is_top":false,"comment_ctime":1554942706,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554942706","product_id":100023901,"comment_content":"感觉今天的这个场景真棒  感觉又学到了好多  每次我都是听三遍左右才能理解😊","like_count":0},{"had_liked":false,"id":84877,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1554942694,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554942694","product_id":100023901,"comment_content":"我感觉用CyclicBarrier用一个固定大小的线程池好像没啥用, 直接主线程执行一下不就可以了, 因为从订单表和运单表中取出的数据的操作已经用单独线程实现了.","like_count":0},{"had_liked":false,"id":84874,"user_name":"罗洲","can_delete":false,"product_type":"c1","uid":1263417,"ip_address":"","ucode":"68133E38A25C17","user_header":"https://static001.geekbang.org/account/avatar/00/13/47/39/0ce1aa62.jpg","comment_is_top":false,"comment_ctime":1554942451,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554942451","product_id":100023901,"comment_content":"有必要限制只有一个线程的线程池，主要是为了回调函数的线程安全，因为对于check 方法本身来说并不是线程安全的，虽然有vector 来保证队列中的操作是线程安全的，但是有可能造成两个队列取出数据不同步的情况，如果用了单线程串行可以避免这个问题。","like_count":0},{"had_liked":false,"id":84868,"user_name":"心中无剑","can_delete":false,"product_type":"c1","uid":1479311,"ip_address":"","ucode":"85C27AC7523EE4","user_header":"https://static001.geekbang.org/account/avatar/00/16/92/8f/0378e325.jpg","comment_is_top":false,"comment_ctime":1554941870,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554941870","product_id":100023901,"comment_content":"我在想，回调采用固定线程池，并且设置核心数是1。原因也许跟 save(diff) 有关，为了保证数据一致性。save操作失败后，事务回滚吗？ 一条线程一个事务，不然save这一步如果发生异常，怎么保证原子性呢","like_count":0},{"had_liked":false,"id":84849,"user_name":"杨春鹏","can_delete":false,"product_type":"c1","uid":1172056,"ip_address":"","ucode":"518F38232F97B5","user_header":"https://static001.geekbang.org/account/avatar/00/11/e2/58/8c8897c8.jpg","comment_is_top":false,"comment_ctime":1554935342,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554935342","product_id":100023901,"comment_content":"为什么最后一种情况的线程池的线程数量是1呢？","like_count":0}]}