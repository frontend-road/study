{"id":80388,"title":"55 | 算法实战（四）：剖析微服务接口鉴权限流背后的数据结构和算法","content":"<p>微服务是最近几年才兴起的概念。简单点讲，就是把复杂的大应用，解耦拆分成几个小的应用。这样做的好处有很多。比如，这样有利于团队组织架构的拆分，毕竟团队越大协作的难度越大；再比如，每个应用都可以独立运维，独立扩容，独立上线，各个应用之间互不影响。不用像原来那样，一个小功能上线，整个大应用都要重新发布。</p><p>不过，有利就有弊。大应用拆分成微服务之后，服务之间的调用关系变得更复杂，平台的整体复杂熵升高，出错的概率、debug问题的难度都高了好几个数量级。所以，为了解决这些问题，服务治理便成了微服务的一个技术重点。</p><p>所谓服务治理，简单点讲，就是管理微服务，保证平台整体正常、平稳地运行。服务治理涉及的内容比较多，比如鉴权、限流、降级、熔断、监控告警等等。这些服务治理功能的实现，底层依赖大量的数据结构和算法。今天，我就拿其中的鉴权和限流这两个功能，来带你看看，它们的实现过程中都要用到哪些数据结构和算法。</p><h2>鉴权背景介绍</h2><p>以防你之前可能对微服务没有太多了解，所以我对鉴权的背景做了简化。</p><p>假设我们有一个微服务叫用户服务（User Service）。它提供很多用户相关的接口，比如获取用户信息、注册、登录等，给公司内部的其他应用使用。但是，并不是公司内部所有应用，都可以访问这个用户服务，也并不是每个有访问权限的应用，都可以访问用户服务的所有接口。</p><!-- [[[read_end]]] --><p>我举了一个例子给你讲解一下，你可以看我画的这幅图。这里面，只有A、B、C、D四个应用可以访问用户服务，并且，每个应用只能访问用户服务的部分接口。</p><p><img src=\"https://static001.geekbang.org/resource/image/1a/3d/1a574c209ab80e2dcdc9a52479d4f73d.jpg?wh=1142*684\" alt=\"\"></p><p>要实现接口鉴权功能，我们需要事先将应用对接口的访问权限规则设置好。当某个应用访问其中一个接口的时候，我们就可以拿应用的请求URL，在规则中进行匹配。如果匹配成功，就说明允许访问；如果没有可以匹配的规则，那就说明这个应用没有这个接口的访问权限，我们就拒绝服务。</p><h2>如何实现快速鉴权？</h2><p>接口的格式有很多，有类似Dubbo这样的RPC接口，也有类似Spring Cloud这样的HTTP接口。不同接口的鉴权实现方式是类似的，我这里主要拿HTTP接口给你讲解。</p><p>鉴权的原理比较简单、好理解。那具体到实现层面，我们该用什么数据结构来存储规则呢？用户请求URL在规则中快速匹配，又该用什么样的算法呢？</p><p>实际上，不同的规则和匹配模式，对应的数据结构和匹配算法也是不一样的。所以，关于这个问题，我继续细化为三个更加详细的需求给你讲解。</p><h3>1.如何实现精确匹配规则？</h3><p>我们先来看最简单的一种匹配模式。只有当请求URL跟规则中配置的某个接口精确匹配时，这个请求才会被接受、处理。为了方便你理解，我举了一个例子，你可以看一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/19/d1/19355363fa47c116edfd7d2ea57af4d1.jpg?wh=1142*856\" alt=\"\"></p><p>不同的应用对应不同的规则集合。我们可以采用散列表来存储这种对应关系。我这里着重讲下，每个应用对应的规则集合，该如何存储和匹配。</p><p>针对这种匹配模式，我们可以将每个应用对应的权限规则，存储在一个字符串数组中。当用户请求到来时，我们拿用户的请求URL，在这个字符串数组中逐一匹配，匹配的算法就是我们之前学过的字符串匹配算法（比如KMP、BM、BF等）。</p><p>规则不会经常变动，所以，为了加快匹配速度，我们可以按照字符串的大小给规则排序，把它组织成有序数组这种数据结构。当要查找某个URL能否匹配其中某条规则的时候，我们可以采用二分查找算法，在有序数组中进行匹配。</p><p>而二分查找算法的时间复杂度是O(logn)（n表示规则的个数），这比起时间复杂度是O(n)的顺序遍历快了很多。对于规则中接口长度比较长，并且鉴权功能调用量非常大的情况，这种优化方法带来的性能提升还是非常可观的 。</p><h3>2.如何实现前缀匹配规则？</h3><p>我们再来看一种稍微复杂的匹配模式。只要某条规则可以匹配请求URL的前缀，我们就说这条规则能够跟这个请求URL匹配。同样，为了方便你理解这种匹配模式，我还是举一个例子说明一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/66/fe/662c4ffb278fedf842f0dffa465673fe.jpg?wh=1142*755\" alt=\"\"></p><p>不同的应用对应不同的规则集合。我们采用散列表来存储这种对应关系。我着重讲一下，每个应用的规则集合，最适合用什么样的数据结构来存储。</p><p>在<a href=\"https://time.geekbang.org/column/article/72414\">Trie树</a>那节，我们讲到，Trie树非常适合用来做前缀匹配。所以，针对这个需求，我们可以将每个用户的规则集合，组织成Trie树这种数据结构。</p><p>不过，Trie树中的每个节点不是存储单个字符，而是存储接口被“/”分割之后的子目录（比如“/user/name”被分割为“user”“name”两个子目录）。因为规则并不会经常变动，所以，在Trie树中，我们可以把每个节点的子节点们，组织成有序数组这种数据结构。在匹配的过程中，我们可以利用二分查找算法，决定从一个节点应该跳到哪一个子节点。</p><p><img src=\"https://static001.geekbang.org/resource/image/69/b9/691d7f056fe48b8598f6f86568212db9.jpg?wh=1142*529\" alt=\"\"></p><h3>3.如何实现模糊匹配规则？</h3><p>如果我们的规则更加复杂，规则中包含通配符，比如“**”表示匹配任意多个子目录，“*”表示匹配任意一个子目录。只要用户请求URL可以跟某条规则模糊匹配，我们就说这条规则适用于这个请求。为了方便你理解，我举一个例子来解释一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/f7/32/f756e2fef50776442be41e48d7aa5532.jpg?wh=1142*756\" alt=\"\"></p><p>不同的应用对应不同的规则集合。我们还是采用散列表来存储这种对应关系。这点我们刚才讲过了，这里不再重复说了。我们着重看下，每个用户对应的规则集合，该用什么数据结构来存储？针对这种包含通配符的模糊匹配，我们又该使用什么算法来实现呢？</p><p>还记得我们在<a href=\"https://time.geekbang.org/column/article/74287\">回溯算法</a>那节讲的正则表达式的例子吗？我们可以借助正则表达式那个例子的解决思路，来解决这个问题。我们采用回溯算法，拿请求URL跟每条规则逐一进行模糊匹配。如何用回溯算法进行模糊匹配，这部分我就不重复讲了。你如果忘记了，可以回到相应章节复习一下。</p><p>不过，这个解决思路的时间复杂度是非常高的。我们需要拿每一个规则，跟请求URL匹配一遍。那有没有办法可以继续优化一下呢？</p><p>实际上，我们可以结合实际情况，挖掘出这样一个隐形的条件，那就是，并不是每条规则都包含通配符，包含通配符的只是少数。于是，我们可以把不包含通配符的规则和包含通配符的规则分开处理。</p><p>我们把不包含通配符的规则，组织成有序数组或者Trie树（具体组织成什么结构，视具体的需求而定，是精确匹配，就组织成有序数组，是前缀匹配，就组织成Trie树），而这一部分匹配就会非常高效。剩下的是少数包含通配符的规则，我们只要把它们简单存储在一个数组中就可以了。尽管匹配起来会比较慢，但是毕竟这种规则比较少，所以这种方法也是可以接受的。</p><p>当接收到一个请求URL之后，我们可以先在不包含通配符的有序数组或者Trie树中查找。如果能够匹配，就不需要继续在通配符规则中匹配了；如果不能匹配，就继续在通配符规则中查找匹配。</p><h2>限流背景介绍</h2><p>讲完了鉴权的实现思路，我们再来看一下限流。</p><p>所谓限流，顾名思义，就是对接口调用的频率进行限制。比如每秒钟不能超过100次调用，超过之后，我们就拒绝服务。限流的原理听起来非常简单，但它在很多场景中，发挥着重要的作用。比如在秒杀、大促、双11、618等场景中，限流已经成为了保证系统平稳运行的一种标配的技术解决方案。</p><p>按照不同的限流粒度，限流可以分为很多种类型。比如给每个接口限制不同的访问频率，或者给所有接口限制总的访问频率，又或者更细粒度地限制某个应用对某个接口的访问频率等等。</p><p>不同粒度的限流功能的实现思路都差不多，所以，我今天主要针对限制所有接口总的访问频率这样一个限流需求来讲解。其他粒度限流需求的实现思路，你可以自己思考。</p><h2>如何实现精准限流？</h2><p>最简单的限流算法叫<strong>固定时间窗口限流算法</strong>。这种算法是如何工作的呢？首先我们需要选定一个时间起点，之后每当有接口请求到来，我们就将计数器加一。如果在当前时间窗口内，根据限流规则（比如每秒钟最大允许100次访问请求），出现累加访问次数超过限流值的情况时，我们就拒绝后续的访问请求。当进入下一个时间窗口之后，计数器就清零重新计数。</p><p><img src=\"https://static001.geekbang.org/resource/image/cd/3a/cd1343d3f0f09c9eba7fb6387f01b63a.jpg?wh=1142*763\" alt=\"\"></p><p>这种基于固定时间窗口的限流算法的缺点是，限流策略过于粗略，无法应对两个时间窗口临界时间内的突发流量。这是怎么回事呢？我举一个例子给你解释一下。</p><p>假设我们的限流规则是，每秒钟不能超过100次接口请求。第一个1s时间窗口内，100次接口请求都集中在最后10ms内。在第二个1s的时间窗口内，100次接口请求都集中在最开始的10ms内。虽然两个时间窗口内流量都符合限流要求（≤100个请求），但在两个时间窗口临界的20ms内，会集中有200次接口请求。固定时间窗口限流算法并不能对这种情况做限制，所以，集中在这20ms内的200次请求就有可能压垮系统。</p><p><img src=\"https://static001.geekbang.org/resource/image/e7/30/e712a0d49aaf0218d3760c7a5f9fdc30.jpg?wh=1142*538\" alt=\"\"></p><p>为了解决这个问题，我们可以对固定时间窗口限流算法稍加改造。我们可以限制任意时间窗口（比如1s）内，接口请求数都不能超过某个阈值（ 比如100次）。因此，相对于固定时间窗口限流算法，这个算法叫<strong>滑动时间窗口限流算法</strong>。</p><p>流量经过滑动时间窗口限流算法整形之后，可以保证任意一个1s的时间窗口内，都不会超过最大允许的限流值，从流量曲线上来看会更加平滑。那具体到实现层面，我们该如何来做呢？</p><p>我们假设限流的规则是，在任意1s内，接口的请求次数都不能大于K次。我们就维护一个大小为K+1的循环队列，用来记录1s内到来的请求。注意，这里循环队列的大小等于限流次数加一，因为循环队列存储数据时会浪费一个存储单元。</p><p>当有新的请求到来时，我们将与这个新请求的时间间隔超过1s的请求，从队列中删除。然后，我们再来看循环队列中是否有空闲位置。如果有，则把新请求存储在队列尾部（tail指针所指的位置）；如果没有，则说明这1秒内的请求次数已经超过了限流值K，所以这个请求被拒绝服务。</p><p>为了方便你理解，我举一个例子，给你解释一下。在这个例子中，我们假设限流的规则是，任意1s内，接口的请求次数都不能大于6次。</p><p><img src=\"https://static001.geekbang.org/resource/image/74/79/748a2b39a068563d48837677016b8c79.jpg?wh=1142*856\" alt=\"\"></p><p>即便滑动时间窗口限流算法可以保证任意时间窗口内，接口请求次数都不会超过最大限流值，但是仍然不能防止，在细时间粒度上访问过于集中的问题。</p><p>比如我刚刚举的那个例子，第一个1s的时间窗口内，100次请求都集中在最后10ms中，也就是说，基于时间窗口的限流算法，不管是固定时间窗口还是滑动时间窗口，只能在选定的时间粒度上限流，对选定时间粒度内的更加细粒度的访问频率不做限制。</p><p>实际上，针对这个问题，还有很多更加平滑的限流算法，比如令牌桶算法、漏桶算法等。如果感兴趣，你可以自己去研究一下。</p><h2>总结引申</h2><p>今天，我们讲解了跟微服务相关的接口鉴权和限流功能的实现思路。现在，我稍微总结一下。</p><p>关于鉴权，我们讲了三种不同的规则匹配模式。不管是哪种匹配模式，我们都可以用散列表来存储不同应用对应的不同规则集合。对于每个应用的规则集合的存储，三种匹配模式使用不同的数据结构。</p><p>对于第一种精确匹配模式，我们利用有序数组来存储每个应用的规则集合，并且通过二分查找和字符串匹配算法，来匹配请求URL与规则。对于第二种前缀匹配模式，我们利用Trie树来存储每个应用的规则集合。对于第三种模糊匹配模式，我们采用普通的数组来存储包含通配符的规则，通过回溯算法，来进行请求URL与规则的匹配。</p><p>关于限流，我们讲了两种限流算法，第一种是固定时间窗口限流算法，第二种是滑动时间窗口限流算法。对于滑动时间窗口限流算法，我们用了之前学习过的循环队列来实现。比起固定时间窗口限流算法，它对流量的整形效果更好，流量更加平滑。</p><p>从今天的学习中，我们也可以看出，对于基础架构工程师来说，如果不精通数据结构和算法，我们就很难开发出性能卓越的基础架构、中间件。这其实就体现了数据结构和算法的重要性。</p><h2>课后思考</h2><ol>\n<li>\n<p>除了用循环队列来实现滑动时间窗口限流算法之外，我们是否还可以用其他数据结构来实现呢？请对比一下这些数据结构跟循环队列在解决这个问题时的优劣之处。</p>\n</li>\n<li>\n<p>分析一下鉴权那部分内容中，前缀匹配算法的时间复杂度和空间复杂度。</p>\n</li>\n</ol><hr><p><span class=\"orange\">最后，有个消息提前通知你一下。本节是专栏的倒数第二节课了，不知道学到现在，你掌握得怎么样呢？为了帮你复习巩固，做到真正掌握这些知识，我针对专栏涉及的数据结构和算法，精心编制了一套练习题。从正月初一到初七，每天发布一篇。你要做好准备哦！</span></p>","comments":[{"had_liked":false,"id":64924,"user_name":"suke","can_delete":false,"product_type":"c1","uid":1007753,"ip_address":"","ucode":"C0287C31A4F45B","user_header":"","comment_is_top":true,"comment_ctime":1548979594,"is_pvip":false,"replies":[{"id":"23014","content":"这是我之前开源的限流框架，你可以看看，比较详细了。而且里面还有一篇我发到infoq上的文章，讲设计思路。<br>https:&#47;&#47;github.com&#47;wangzheng0822&#47;ratelimiter4j","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1548989656,"ip_address":"","comment_id":64924,"utype":1}],"discussion_count":12,"race_medal":0,"score":"9.2233722617421005e+18","product_id":100017301,"comment_content":"老师能对限流相关的算法和数据结构多讲一讲么","like_count":51,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438235,"discussion_content":"这是我之前开源的限流框架，你可以看看，比较详细了。而且里面还有一篇我发到infoq上的文章，讲设计思路。\nhttps://github.com/wangzheng0822/ratelimiter4j","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1548989656,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1049819,"avatar":"https://static001.geekbang.org/account/avatar/00/10/04/db/a4945f8f.jpg","nickname":"zidy","note":"","ucode":"B457947FDF9540","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585342,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661493720,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2027259,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/ee/fb/d5265897.jpg","nickname":"王杰","note":"","ucode":"663050BB20C230","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581625,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658891965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042507,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/4b/57fa0e34.jpg","nickname":"brianway","note":"","ucode":"E05738C88829C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580452,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658192463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121857,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DSKSsTZWSAG9Nib7fdNfvt68bpMf1vwMXGN8icyqoq3JK3qWw5wXWTzWtpMpeXicOQCE0gticw7nqO7a3OvChPJujw/132","nickname":"逍遥纨绔","note":"","ucode":"9866257A6E448C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557790,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647960827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1346215,"avatar":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","nickname":"William","note":"","ucode":"55F5D9DEE485B1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340778,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610155167,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333955,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607679330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1250922,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIzGGthScz54sECZJKX3lgyjCATkgrvSt5N3eOsYB34jibCr3SkAX88QaZ5IVmME9Ec7VdkQGwRSPw/132","nickname":"哈哈哈","note":"","ucode":"8AC20A1C9C7DF8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308849,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601095907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1260026,"avatar":"https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg","nickname":"安排","note":"","ucode":"F78CFA9624CAEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295982,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596420447,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1004953,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/55/99/4bdadfd3.jpg","nickname":"Chloe","note":"","ucode":"C4848ED5B35752","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269012,"discussion_content":"赞infoQ的文章！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589856936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1205485,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJUhJakYu4BI7eFnheKDdibDjZqz32ia2rhN0Jz5YoR1ZRlDrLcFNr4MJnPg3WiaxaocWotOANeqsBibw/132","nickname":"小白","note":"","ucode":"862EA133563634","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":262575,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589114525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1258401,"avatar":"https://static001.geekbang.org/account/avatar/00/13/33/a1/f3835f01.jpg","nickname":"社会猪","note":"","ucode":"CFF5EA7F247373","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":14701,"discussion_content":"sss","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568777451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82047,"user_name":"Flash","can_delete":false,"product_type":"c1","uid":1236163,"ip_address":"","ucode":"E285075C9E0B02","user_header":"https://static001.geekbang.org/account/avatar/00/12/dc/c3/e4ba51d5.jpg","comment_is_top":false,"comment_ctime":1554109640,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"177647768776","product_id":100017301,"comment_content":"思考题1：可以用优先级队列（根据请求时间构建小顶堆），最早的请求时间的放在堆顶。然后每次进来一个请求，就判断这个时间跟堆顶的时间差是否小于1S，并且堆的大小小于请求限制的次数，如果是就插入队列，如果不是，就限制。","like_count":42,"discussions":[{"author":{"id":1616622,"avatar":"https://static001.geekbang.org/account/avatar/00/18/aa/ee/15c328ca.jpg","nickname":"ɴɪᴋᴇʀ","note":"","ucode":"DB7D92CBB5FD15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312669,"discussion_content":"队列本身用的就是按时间顺序进行插入的，存储的也是请求插入的时间，再用优先级队列(小顶堆)进行堆化难道不是多此一举吗，还是是我想错了？","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1602765001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1616622,"avatar":"https://static001.geekbang.org/account/avatar/00/18/aa/ee/15c328ca.jpg","nickname":"ɴɪᴋᴇʀ","note":"","ucode":"DB7D92CBB5FD15","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333956,"discussion_content":"多此一举。简单问题，特意高级化","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1607679440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312669,"ip_address":""},"score":333956,"extra":""},{"author":{"id":1298380,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cf/cc/8de5007b.jpg","nickname":"徐改","note":"","ucode":"82276A584AC602","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384927,"discussion_content":"用队列可以实现滑动时间窗口算法，我猜应该是当队列满的时候，在删除大于1s的数据后，要将队列进行搬移，从队列尾部移动到队列头部，这样才能腾出空间存放新的请求。而搬移数据这个过程的时间复杂度是O(n)，但是堆在删除数据后重新堆化的时间复杂度是O(logn)。可能从这点来看，使用堆的效率会好一点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626796263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":333956,"ip_address":""},"score":384927,"extra":""},{"author":{"id":1244845,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fe/ad/7fa85a7d.jpg","nickname":"放飞心情","note":"","ucode":"75A2192D91D86C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1298380,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cf/cc/8de5007b.jpg","nickname":"徐改","note":"","ucode":"82276A584AC602","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391307,"discussion_content":"循环队列不需要搬移数据","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1630395969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":384927,"ip_address":""},"score":391307,"extra":""}]},{"author":{"id":1811087,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/vTr4UOVYokmk00jic0Mn3diaPhxYeYmjic6wibl80YFaNiazDFtYvgQXUBc4eN1qgmXuRUwDOmzHJr4MCnEuMYDdTaA/132","nickname":"Geek_eae1bf","note":"","ucode":"79A8DEA3960D86","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312314,"discussion_content":"若当前请求的时间和堆顶的时间差大于1s时，此时不是限制当前请求的插入而应该是将堆顶的请求删除再插入当前请求，随后进行堆化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602660802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64916,"user_name":"Billylin","can_delete":false,"product_type":"c1","uid":1004016,"ip_address":"","ucode":"BEA692CEEAC6CF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/51/f0/d1142758.jpg","comment_is_top":false,"comment_ctime":1548959765,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"164757717013","product_id":100017301,"comment_content":"春节还想着加福利，这是一种什么精神。","like_count":39,"discussions":[{"author":{"id":1258401,"avatar":"https://static001.geekbang.org/account/avatar/00/13/33/a1/f3835f01.jpg","nickname":"社会猪","note":"","ucode":"CFF5EA7F247373","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":14682,"discussion_content":"fcf","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568776704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85002,"user_name":"xuery","can_delete":false,"product_type":"c1","uid":1027584,"ip_address":"","ucode":"F461B61BE06131","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/00/025f37e7.jpg","comment_is_top":false,"comment_ctime":1554954564,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"108929136964","product_id":100017301,"comment_content":"1. 还可以采用双向链表，每次请求往链表尾插入一个时间，插入之前先从链表头删除一秒之前的节点，之后看下链表的size是否大于等于N，大于等于N则拒绝本次访问，否则允许本次访问并插入链表尾；占用的空间比循环链表要大<br>2. 假设有n个规则，每个规则的单词个数平均为m，则时间复杂度为O(m*logn), 空间复杂度O(n*m)<br>时间复杂度分析下：平均搜索m层，每一层最多有n个单词，由于是采用有序数组存储，查找时间复杂度为O(logn),所以总的时间复杂度为O(m*logn)<br>","like_count":26,"discussions":[{"author":{"id":1298380,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cf/cc/8de5007b.jpg","nickname":"徐改","note":"","ucode":"82276A584AC602","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384924,"discussion_content":"针对解答1，我想请教下：如果当前链表的size已经大于等于N的话，那么接下来该怎么办？难道是一直拒绝服务吗？是不是这个时候就要想办法将链表尾部的数据往前搬到链表头？这部分往前搬动数据的操作的时间复杂度好像是O(n^)？使用双向链表是为了可以检索前驱跟后继，那我如果用线性数组呢？是不是也能达到同样的效果？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626795305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":68539,"user_name":"Williamzhang","can_delete":false,"product_type":"c1","uid":1148759,"ip_address":"","ucode":"C016AE5DE39F4E","user_header":"https://static001.geekbang.org/account/avatar/00/11/87/57/e28ba87b.jpg","comment_is_top":false,"comment_ctime":1550540308,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"104629755412","product_id":100017301,"comment_content":"感觉限流的思想中可以参考一下tcp的拥塞控制算法","like_count":25,"discussions":[{"author":{"id":2668694,"avatar":"https://static001.geekbang.org/account/avatar/00/28/b8/96/716ba431.jpg","nickname":"苏成","note":"","ucode":"80A8E7B243DD73","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572397,"discussion_content":"应该是流量控制吧，不过TCP流量控制也是使用的滑动窗口， TCP拥塞控制是为了防止网络情况不好的情况之下，自己反复重传又加剧拥塞，拥塞控制算法慢启动和拥塞控制都是改变自身窗口大小，限流的话是禁止反复访问的客户端。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1652769675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76861,"user_name":"DigDeeply","can_delete":false,"product_type":"c1","uid":1239008,"ip_address":"","ucode":"113F4D755A1FEC","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/e0/33521e13.jpg","comment_is_top":false,"comment_ctime":1552731716,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"53092339268","product_id":100017301,"comment_content":"思考题1<br>还可以使用一个固定大小的小顶堆，以时间戳作为排序依据。<br>每次有请求时相当于要在小顶堆内插入数据，如果堆顶数据的时间跟本次时间差距小于1s，且堆已满的情况下，不允许继续插入。每次插入数据的时候，删除1s外的数据，重新排序，确定新的堆顶。<br>不过感觉跟循环队列比，都是劣势；插入数据，删除数据，时间复杂度都要更高。而且每次删除数据后还要重新排序一遍确定新的堆顶。","like_count":12},{"had_liked":false,"id":67682,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1550222076,"is_pvip":false,"replies":[{"id":"25410","content":"小数据量的情况下，散列表在存储和匹配上并不一定比二分查找高呢","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551233031,"ip_address":"","comment_id":67682,"utype":1}],"discussion_count":1,"race_medal":0,"score":"48794862332","product_id":100017301,"comment_content":"鉴权的精确匹配用散列表的时间复杂度是O(1)，比顺序匹配O(n)和二分查找的效率都高啊。为什么不选用呢？","like_count":12,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439325,"discussion_content":"小数据量的情况下，散列表在存储和匹配上并不一定比二分查找高呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551233031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64976,"user_name":"Ray","can_delete":false,"product_type":"c1","uid":1099864,"ip_address":"","ucode":"3D2012363A9B8A","user_header":"https://static001.geekbang.org/account/avatar/00/10/c8/58/35b4090d.jpg","comment_is_top":false,"comment_ctime":1548989667,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"44498662627","product_id":100017301,"comment_content":"读您的文章就是一种享受!!!","like_count":10},{"had_liked":false,"id":65610,"user_name":"青铜5 周群力","can_delete":false,"product_type":"c1","uid":1111965,"ip_address":"","ucode":"EA80B442EC8A68","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/9d/c7295d17.jpg","comment_is_top":false,"comment_ctime":1549503357,"is_pvip":false,"replies":[{"id":"24283","content":"hash set对于小数据量也不一定比有序数组效率高呢。毕竟hash set还要计算哈希值、处理冲突等。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550541844,"ip_address":"","comment_id":65610,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40204209021","product_id":100017301,"comment_content":"请教老师一个问题哈，为啥鉴权算法里，每个应用的规则要放到有序数组呢，放hash set会更好吧?<br>比如一个应用有两个规则:&#47;user&#47;a和&#47;user&#47;b，把这俩规则放hash set岂不是时间复杂度更低、更好呢","like_count":10,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438519,"discussion_content":"hash set对于小数据量也不一定比有序数组效率高呢。毕竟hash set还要计算哈希值、处理冲突等。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1550541844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64925,"user_name":"金龟","can_delete":false,"product_type":"c1","uid":1228500,"ip_address":"","ucode":"1C7D35C8AE8D9D","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/d4/ff1c1319.jpg","comment_is_top":false,"comment_ctime":1548980104,"is_pvip":false,"replies":[{"id":"24302","content":"更细时间粒度的理解是这样的：比如你限制的是100次&#47;s，那具体到10ms（更细时间粒度）是多少，你就无法限制了。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550543004,"ip_address":"","comment_id":64925,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27318783880","product_id":100017301,"comment_content":"老师，文章里你说了这一句话&#39;只能在选定的时间粒度上限流，对选定时间粒度内的更加细粒度的访问频率不做限制。&#39;这里更加细粒度代表什么意思，我觉得已经解决了，最初时间窗口的问题呀。比如如果我限流5qps，那循环队列（元素内存时间）只留tail指针，只是要增加每次tail前进之前用当前时间和后一个元素时间进行一个差指，大于1秒前进，小于一秒拒绝请求。","like_count":6,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438236,"discussion_content":"更细时间粒度的理解是这样的：比如你限制的是100次/s，那具体到10ms（更细时间粒度）是多少，你就无法限制了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550543004,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94054,"user_name":"懒猫","can_delete":false,"product_type":"c1","uid":1206544,"ip_address":"","ucode":"B4B567A11B491D","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/10/275ae749.jpg","comment_is_top":false,"comment_ctime":1557710831,"is_pvip":false,"replies":[{"id":"33704","content":"1. 存放的是uri字符串<br>2. 用字典序来排序<br>3. 比较两个字符串大小的算法你应该知道吧","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1557791858,"ip_address":"","comment_id":94054,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23032547311","product_id":100017301,"comment_content":"请教老师，鉴权那一部分如何用有序数组做二分查找呢，数组里存放的都是uri中的单词吗？在数组中怎么排序？字典序？这里的二分比较时怎么比较大小呢","like_count":6,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449895,"discussion_content":"1. 存放的是uri字符串\n2. 用字典序来排序\n3. 比较两个字符串大小的算法你应该知道吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557791858,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95662,"user_name":"wjh_all_in","can_delete":false,"product_type":"c1","uid":1501209,"ip_address":"","ucode":"0480A53AD46C97","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIC2Ww3swYiaMalnpA1f87xgzV8Hs1Y27M2CbNQqgR27Il72hibXn5FvhU7mbr3XKsxYDZdjY4GMDbg/132","comment_is_top":false,"comment_ctime":1558136706,"is_pvip":false,"replies":[{"id":"34391","content":"课程github上有详细的介绍文档，如果感兴趣可以去看下","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1558339165,"ip_address":"","comment_id":95662,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14443038594","product_id":100017301,"comment_content":"请问一下，滑动窗口限流策略，清除过期数据的时机是新请求到达，这个是基于单位ms内不会有很大的并发的考虑吗？如果像淘宝这样的大流量电商，是不是需要更低精度的时间，不然清除数据的耗时，可能会使接口性能变差","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450547,"discussion_content":"课程github上有详细的介绍文档，如果感兴趣可以去看下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558339165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65077,"user_name":"何欢","can_delete":false,"product_type":"c1","uid":1230675,"ip_address":"","ucode":"518313CB5F9116","user_header":"https://static001.geekbang.org/account/avatar/00/12/c7/53/a8b9ac81.jpg","comment_is_top":false,"comment_ctime":1549025572,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14433927460","product_id":100017301,"comment_content":"给老师点个赞，敬业精神值得学习，春节期间也是给自己充电的好时期，加油。","like_count":3},{"had_liked":false,"id":177131,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1581299146,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10171233738","product_id":100017301,"comment_content":"所谓服务治理涉及的内容比较多，比如鉴权、限流、降级、熔断、监控告警等等。这些服务治理功能的实现，底层依赖大量的数据结构和算法鉴权背景介绍<br><br>要实现接口鉴权功能，需要事先将应用对接口的访问权限规则设置好。当某个应用访问其中一个接口的时候，就可以拿应用的请求 URL，在规则中进行匹配。根据匹配成功与否，判断是否响应访问。<br><br>如何实现快速鉴权？该用什么数据结构来存储规则？用户请求 URL 在规则中快速匹配，又该用什么样的算法呢？<br><br>1. 如何实现精确匹配规则？<br>只有当请求 URL 跟规则中配置的某个接口精确匹配时，这个请求才会被接受、处理<br><br>\t* 不同的应用对应不同的规则集合。可以采用散列表来存储这种对应关系<br><br>\t\t* 可以将每个应用对应的权限规则，存储在一个字符串数组中。拿用户的请求 URL，在这个数组中逐一匹配<br>\t\t* 规则不会经常变动，所以按照字符串的大小给规则排序加快匹配速度，把它组织成有序数组这种数据结构。当要查找某个 URL 能否匹配时，采用二分查找算法，在有序数组中进行匹配。<br><br>2. 如何实现前缀匹配规则？<br>只要某条规则可以匹配请求 URL 的前缀，就认为这条规则能够跟这个请求 URL 匹配<br><br>\t* 不同的应用对应不同的规则集合。采用散列表来存储这种对应关系<br><br>\t\t* Trie 树非常适合用来做前缀匹配。所以将每个用户的规则集合组织成 Trie 树<br>\t\t* Trie 树中的每个节点存储接口被“&#47;”分割之后的子目录<br>\t\t* 因为规则并不会经常变动，所以把每个节点的子节点们，组织成有序数组，利用二分查找算法匹配，决定从一个节点应该跳到哪一个子节点<br><br><br>3. 如何实现模糊匹配规则？<br>如果规则中包含通配符，只要用户请求 URL 可以跟某条规则模糊匹配，就判定这条规则适用于这个请求<br><br>不同的应用对应不同的规则集合。还是采用散列表来存储这种对应关系<br>\t* 采用回溯算法，拿请求 URL 跟每条规则逐一进行模糊匹配，但在回溯算法复杂度较高<br>\t* 实际上并不是每条规则都包含通配符，包含通配符的只是少数，可以把不包含通配符的规则和包含通配符的规则分开处理<br><br>\t\t* 把不包含通配符的规则，组织成有序数组或者 Trie 树，这一部分匹配就会非常高效<br>\t\t* 少数包含通配符的规则，只要把它们简单存储在一个数组中。但是这种规则比较少，所以匹配起来会比较慢也是可以接受的<br><br>\t* 当接收到一个请求，可以先在不包含通配符的有序数组或者 Trie 树中查找。<br><br>限流背景介绍<br>\t* 所谓限流，就是对接口调用的频率进行限制，限流已成为保证系统平稳运行的一种标配的技术解决方案<br>\t* 按照不同的限流粒度，限流可以分为很多种类型。如给每个接口限制不同的访问频率，或者给所有接口限制总的访问频率，又或者更细粒度地限制某个应用对某个接口的访问频率等等。<br><br>如何实现精准限流？<br>最简单的限流算法：固定时间窗口限流算法<br>\t* 首先选定一个时间起点，之后每当有接口请求到来，就将计数器加一<br>\t* 如果在当前时间窗口内，根据限流规则（比如每秒钟最大允许 100 次访问请求），出现累加访问次数超过限流值的情况时，就拒绝后续的访问请求。<br>\t* 当进入下一个时间窗口之后，计数器就清零重新计数。<br>\t* 缺点：限流策略过于粗略，无法应对两个时间窗口临界时间内的突发流量<br><br>滑动时间窗口限流算法可以限制任意时间窗口（比如 1s）内，接口请求数都不能超过某个阈值（ 比如 100 次）<br>假设限流的规则是在任意 1s 内，接口的请求次数都不能大于 K 次<br>\t* 维护一个大小为 K+1 的循环队列记录 1s 内到来的请求。因为循环队列存储数据时会浪费一个存储单元，循环队列的大小等于限流次数加一<br>\t* 当有新的请求到来时，将与这个新请求的时间间隔超过 1s 的请求，从队列中删除。<br>\t* 然后检查循环队列中是否有空闲位置。如果有，则把新请求存储在队列尾部（tail 指针所指的位置）；如果没有就拒绝服务<br>\t* 即便滑动时间窗口限流算法可以保证任意时间窗口内，接口请求次数都不会超过最大限流值，但是仍然不能防止，在细时间粒度上访问过于集中的问题<br>\t* 基于时间窗口的限流算法，不管是固定时间窗口还是滑动时间窗口，只能在选定的时间粒度上限流，对选定时间粒度内的更加细粒度的访问频率不做限制。<br>","like_count":2},{"had_liked":false,"id":65092,"user_name":"水果刀","can_delete":false,"product_type":"c1","uid":1236586,"ip_address":"","ucode":"CA787A086DAB70","user_header":"https://static001.geekbang.org/account/avatar/00/12/de/6a/4db4a75e.jpg","comment_is_top":false,"comment_ctime":1549035982,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10138970574","product_id":100017301,"comment_content":"立个flag，正月初一到正月初七每天都做老师的题……","like_count":2},{"had_liked":false,"id":65063,"user_name":"言希","can_delete":false,"product_type":"c1","uid":1154218,"ip_address":"","ucode":"D7F80B86BCAF2E","user_header":"https://static001.geekbang.org/account/avatar/00/11/9c/aa/6f780187.jpg","comment_is_top":false,"comment_ctime":1549016286,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10138950878","product_id":100017301,"comment_content":"老师用心了","like_count":2},{"had_liked":false,"id":64987,"user_name":"向羽","can_delete":false,"product_type":"c1","uid":1101960,"ip_address":"","ucode":"34BE6BF3EB8041","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/88/d9a55425.jpg","comment_is_top":false,"comment_ctime":1548992332,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10138926924","product_id":100017301,"comment_content":"太棒了，给老师点赞👍","like_count":2},{"had_liked":false,"id":64946,"user_name":"失火的夏天","can_delete":false,"product_type":"c1","uid":1241770,"ip_address":"","ucode":"10C6E66EB2A65F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","comment_is_top":false,"comment_ctime":1548982977,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10138917569","product_id":100017301,"comment_content":"思考题1用链表应该也可以吧(是否循环感觉都无所谓，只要有头尾指针就行了)，不过感觉是换汤不换药，核心思想和队列基本一模一样。","like_count":2},{"had_liked":false,"id":64935,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1548981484,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10138916076","product_id":100017301,"comment_content":"给老师点赞","like_count":2},{"had_liked":false,"id":64932,"user_name":"lianlian","can_delete":false,"product_type":"c1","uid":1298468,"ip_address":"","ucode":"79B48B38259097","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJOc0n02eNKflX5ey4TYl1NBfb0kicc20AgayEAGDYylalqHnLTeqMnaJ2iaZsLVmqEo0T0YViadU9Ig/132","comment_is_top":false,"comment_ctime":1548981234,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10138915826","product_id":100017301,"comment_content":"哇，老师优秀又热心(✪▽✪)，期待老师的题目(๑˙ー˙๑)","like_count":2},{"had_liked":false,"id":170106,"user_name":"失火的夏天","can_delete":false,"product_type":"c1","uid":1241770,"ip_address":"","ucode":"10C6E66EB2A65F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","comment_is_top":false,"comment_ctime":1578532361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5873499657","product_id":100017301,"comment_content":"重新来留个言，循环队列也可以用跳表或者红黑树来实现，跳表有前后指针，以long类型的时间作为索引，找到比当前k少一秒的元素（索引查找或者直接便利都可以），然后之前的元素也能删掉了。是否加入跳表就看size是否达到了k，有就加入，没有就拒绝。<br><br>红黑树同样以long类型的时间作为索引key，找到比新元素少一秒的key，红黑树天生就有一个可以找到floorkey(也就是小于等于查找元素的key)，然后依次找到其前驱节点，依次删除。查找前驱节点会比跳表的直接遍历要慢一点。<br><br>不过红黑树和跳表天生的有序性，也是实现这样一个限流容器的思路。","like_count":1},{"had_liked":false,"id":122519,"user_name":"Knight²º¹⁸","can_delete":false,"product_type":"c1","uid":1089754,"ip_address":"","ucode":"BDCB830B6A730F","user_header":"https://static001.geekbang.org/account/avatar/00/10/a0/da/4f50f1b2.jpg","comment_is_top":false,"comment_ctime":1565414183,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5860381479","product_id":100017301,"comment_content":"前些去面试，其中架构篇就让我实现一个企业级的分布式限流框架。","like_count":1,"discussions":[{"author":{"id":1082785,"avatar":"https://static001.geekbang.org/account/avatar/00/10/85/a1/2442332c.jpg","nickname":"郭俊杰","note":"","ucode":"D328E5738A4413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":253521,"discussion_content":"那老师讲的这个平滑限流方案算企业级的吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588240395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1196864,"avatar":"https://static001.geekbang.org/account/avatar/00/12/43/40/e7ef18de.jpg","nickname":"嘉一","note":"","ucode":"8D16BD0B75B019","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":35805,"discussion_content":"你面试的是什么岗位？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571306263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1082785,"avatar":"https://static001.geekbang.org/account/avatar/00/10/85/a1/2442332c.jpg","nickname":"郭俊杰","note":"","ucode":"D328E5738A4413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1196864,"avatar":"https://static001.geekbang.org/account/avatar/00/12/43/40/e7ef18de.jpg","nickname":"嘉一","note":"","ucode":"8D16BD0B75B019","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":253520,"discussion_content":"架构师呗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588240352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":35805,"ip_address":""},"score":253520,"extra":""}]}]},{"had_liked":false,"id":102547,"user_name":"Tattoo","can_delete":false,"product_type":"c1","uid":1036503,"ip_address":"","ucode":"CE926AC8582C96","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d0/d7/a09ef784.jpg","comment_is_top":false,"comment_ctime":1560248815,"is_pvip":true,"replies":[{"id":"37272","content":"散列表本身就有解决冲突的机制的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560382100,"ip_address":"","comment_id":102547,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5855216111","product_id":100017301,"comment_content":"“不同的应用对应不同的规则集合。我们可以采用散列表来存储这种对。。。”，这里如果匹配规则很多的话，不会发生很多的冲突的吗？<br><br>","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453472,"discussion_content":"散列表本身就有解决冲突的机制的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560382100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83030,"user_name":"Xie Yifeng","can_delete":false,"product_type":"c1","uid":1066338,"ip_address":"","ucode":"58E6FFA66818E5","user_header":"https://static001.geekbang.org/account/avatar/00/10/45/62/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1554377062,"is_pvip":false,"replies":[{"id":"30239","content":"可以把参数拼到url中 或者重新设计鉴权规则","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1554680194,"ip_address":"","comment_id":83030,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5849344358","product_id":100017301,"comment_content":"想问下如何对接口做数据域权限检验。比如调用方有权限调用查询项目接口，但是对于请求参数，如项目ID，鉴权系统能够判断调用者是否有权限访问这个项目。","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445824,"discussion_content":"可以把参数拼到url中 或者重新设计鉴权规则","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554680194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65221,"user_name":"Joker","can_delete":false,"product_type":"c1","uid":1156592,"ip_address":"","ucode":"126AF848001A1E","user_header":"https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg","comment_is_top":false,"comment_ctime":1549121093,"is_pvip":false,"replies":[{"id":"23122","content":"哈哈 看来会给你惊喜了","user_name":"编辑回复","user_name_real":"王锦","uid":"1058895","ctime":1549121978,"ip_address":"","comment_id":65221,"utype":2}],"discussion_count":1,"race_medal":0,"score":"5844088389","product_id":100017301,"comment_content":"期待老师的题目，最近也在刷LeetCode，结合的效果肯定好！！！","like_count":1,"discussions":[{"author":{"id":1058895,"avatar":"https://static001.geekbang.org/account/avatar/00/10/28/4f/48e48553.jpg","nickname":"@阿锦啊","note":"","ucode":"3C5F00333D7174","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438363,"discussion_content":"哈哈 看来会给你惊喜了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549121978,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65164,"user_name":"halo","can_delete":false,"product_type":"c1","uid":1138057,"ip_address":"","ucode":"782892605CC855","user_header":"https://static001.geekbang.org/account/avatar/00/11/5d/89/93b837d6.jpg","comment_is_top":false,"comment_ctime":1549081895,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5844049191","product_id":100017301,"comment_content":"一直跟着走，回头再看几遍，真心赞","like_count":1},{"had_liked":false,"id":64962,"user_name":"牧民牛仔","can_delete":false,"product_type":"c1","uid":1247561,"ip_address":"","ucode":"1CC29B7129B207","user_header":"https://static001.geekbang.org/account/avatar/00/13/09/49/8bc5e315.jpg","comment_is_top":false,"comment_ctime":1548986077,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5843953373","product_id":100017301,"comment_content":"春节加餐，每天一份习题大礼包","like_count":1},{"had_liked":false,"id":332975,"user_name":"简单猫","can_delete":false,"product_type":"c1","uid":1866485,"ip_address":"","ucode":"EA027D4C344E25","user_header":"https://static001.geekbang.org/account/avatar/00/1c/7a/f5/54a5084b.jpg","comment_is_top":false,"comment_ctime":1643904794,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643904794","product_id":100017301,"comment_content":"问题1 <br>链表 size小于k 直接add到链表尾部<br>链表已经满了 就判第一个节点 和 当前数据的时间是否超过1秒 超过就删除 头节点指向下一个节点<br>如果小于1 直接丢弃请求<br><br>问题2 trie树 <br>节点为路径 时间复杂度o(n)<br><br><br>&lt;令牌桶&gt; 其实就和连接池类似<br>只不过这里的连接池 的连接只能使用一次<br>然后比如1秒1处理100个连接<br>我每10毫秒生成一个放到连接池里<br>就能平滑的限流 <br>缺点应该是看运气 先来的也不一定拿到令牌<br><br>&lt;漏桶法&gt;<br>类似桶 只要桶里有空间 就一直放进去<br>另外一边桶底出水 按服务器处理速度来放水 只要漏桶没满 就可以一直注入水<br><br>感觉这个和我想的第一种解决方法类似","like_count":1},{"had_liked":false,"id":320162,"user_name":"郑小鹿","can_delete":false,"product_type":"c1","uid":1186808,"ip_address":"","ucode":"E8AF63B4CFCD6E","user_header":"https://static001.geekbang.org/account/avatar/00/12/1b/f8/01e7fc0e.jpg","comment_is_top":false,"comment_ctime":1636103197,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1636103197","product_id":100017301,"comment_content":"有新的请求到来时，我们将与这个新请求的时间间隔超过 1s 的请求，从队列中删除。<br>如何计算时间间隔？","like_count":0},{"had_liked":false,"id":309925,"user_name":"放飞心情","can_delete":false,"product_type":"c1","uid":1244845,"ip_address":"","ucode":"75A2192D91D86C","user_header":"https://static001.geekbang.org/account/avatar/00/12/fe/ad/7fa85a7d.jpg","comment_is_top":false,"comment_ctime":1630396365,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630396365","product_id":100017301,"comment_content":"鉴权那一部分用有序数组是否可以稍微调整为每个uri的hash code的有序数组，比较当前uri是否与在有序数组时可以将当前uri计算hash code，在有序数组中使用二分查找方案","like_count":0},{"had_liked":false,"id":296323,"user_name":"vv_test","can_delete":false,"product_type":"c1","uid":1685884,"ip_address":"","ucode":"1D164B2F034E2B","user_header":"https://static001.geekbang.org/account/avatar/00/19/b9/7c/afe6f1eb.jpg","comment_is_top":false,"comment_ctime":1622899086,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622899086","product_id":100017301,"comment_content":"滑动限流，redis的有序集合也是可以解决，那么这样看来跳表也是可以处理的。以请求时间戳作为score.保留1s内的请求量。","like_count":0},{"had_liked":false,"id":292436,"user_name":"布兰特","can_delete":false,"product_type":"c1","uid":1526892,"ip_address":"","ucode":"EE3316C188EC3C","user_header":"https://static001.geekbang.org/account/avatar/00/17/4c/6c/11fb0f1d.jpg","comment_is_top":false,"comment_ctime":1620821247,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1620821247","product_id":100017301,"comment_content":"这节真是佩服的五体投地","like_count":0},{"had_liked":false,"id":284935,"user_name":"小彬","can_delete":false,"product_type":"c1","uid":2063911,"ip_address":"","ucode":"8688FD8E7BAA4F","user_header":"https://static001.geekbang.org/account/avatar/00/1f/7e/27/c2502abf.jpg","comment_is_top":false,"comment_ctime":1616550754,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616550754","product_id":100017301,"comment_content":"使用有限队列，尾进首出。进之前先看看是否有出的。","like_count":0},{"had_liked":false,"id":240515,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1596956397,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596956397","product_id":100017301,"comment_content":"思考题1：除了用循环队列，还可以用链表和数组实现窗口限流。采用链表，需要在每个节点中额外存储链表指针，还要维护一个节点计数器，用来判断链表长度是否超过限定的频次，因此采用链表，存储效率较低；采用数组，在队列满时，需要把队列元素移动到空闲位置，操作效率较低。<br><br>思考题2：鉴权的前缀匹配复杂度：参照Trie树的复杂度分析，把规则中每一个用&#47;分隔的部分看在是Trie树的一个节点，查找一个有K个节点的URL请求，其时间复杂度O(K)，由于各节点分布在Trie树的多个层中，每一层的子节点数目都不一定，假设每一层的最大子节点数目为n，则时间复杂度还要加上在最多子节点数目所在层按二分查找算法来查找节点的时间，因此，总的时间复杂度是O(K + logn)，空间复杂度是把规则中的子节点拆分再去除重复节点后的节点数目。","like_count":0},{"had_liked":false,"id":233167,"user_name":"哈哈","can_delete":false,"product_type":"c1","uid":2009015,"ip_address":"","ucode":"7D9BA546B49627","user_header":"","comment_is_top":false,"comment_ctime":1594254816,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1594254816","product_id":100017301,"comment_content":" 循环队列中为什么在队列满的时候将head的请求移除，这样先发出请求的反而没有机会被处理？是这样吗","like_count":0,"discussions":[{"author":{"id":1162159,"avatar":"https://static001.geekbang.org/account/avatar/00/11/bb/af/2624cc07.jpg","nickname":"looper","note":"","ucode":"899D50A315BCAE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308123,"discussion_content":"head只是请求记录，head只要能进这个队列就代表已经在处理或者已经处理好了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600850515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221821,"user_name":"默默","can_delete":false,"product_type":"c1","uid":1006635,"ip_address":"","ucode":"AF798B9D327F24","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/2b/8b771383.jpg","comment_is_top":false,"comment_ctime":1590595667,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590595667","product_id":100017301,"comment_content":"问题一：可以使用带有头结点、尾结点和链表长度的链表，当新的请求到来时，从头开始删除与新请求时间超过1s的结点，更新链表的头结点和长度，当链表长度小于限流值时，接受新请求，并插入链表尾部，更新尾结点和长度，否则拒绝请求，不跟新链表。当请求比较少时，链表结点数比较少，比较省空间。由于是链表结构，不能很好利用CPU缓存。","like_count":0},{"had_liked":false,"id":217755,"user_name":"鱼丸粗面","can_delete":false,"product_type":"c1","uid":1785016,"ip_address":"","ucode":"B2F3F75B0D1422","user_header":"https://static001.geekbang.org/account/avatar/00/1b/3c/b8/9489387c.jpg","comment_is_top":false,"comment_ctime":1589602481,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589602481","product_id":100017301,"comment_content":"1、循环队列来实现滑动时间窗口限流算法在前一周期的请求过期以后才释放流量，在请求量很大的时候流量很集中容易出现波峰，令牌桶无时不刻在释放令牌所以可以更平滑<br>2、设前缀有k个，路径有n个分段，用二分查找关键词时间复杂度为O(logk)，则整体时间复杂度为O(nlogk)，空间复杂度根据前缀相同程度在O(n)-O(nk)之间","like_count":0},{"had_liked":false,"id":205513,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1586660765,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586660765","product_id":100017301,"comment_content":"在讲解鉴权的例子当中虽然把需求说明白了，但是没有把实现的思路说明白。例如对于精确匹配的情况一会儿说采用散列来存储，一会儿又来说采取有序数组来实现，感觉很乱；对于前缀匹配的情况，此时Trie树中的每个节点的数据结构是什么样的呢？；对于模糊匹配的情况，“不同的应用对应不同的规则集合。我们还是采用散列表来存储这种对应关系。这点我们刚才讲过了，这里不再重复说了。”怎么理解呢？","like_count":0},{"had_liked":false,"id":205508,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1586658097,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586658097","product_id":100017301,"comment_content":"实现模糊匹配的图感觉没看懂。有序数组是怎么存储的呢？","like_count":0},{"had_liked":false,"id":195816,"user_name":"thinker","can_delete":false,"product_type":"c1","uid":1107762,"ip_address":"","ucode":"1D9ECA03A28931","user_header":"https://static001.geekbang.org/account/avatar/00/10/e7/32/82939538.jpg","comment_is_top":false,"comment_ctime":1585216599,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585216599","product_id":100017301,"comment_content":"漏桶限制的是速率，限制速度<br>令牌桶限制的时间段内的数量，限制总量","like_count":1},{"had_liked":false,"id":195814,"user_name":"thinker","can_delete":false,"product_type":"c1","uid":1107762,"ip_address":"","ucode":"1D9ECA03A28931","user_header":"https://static001.geekbang.org/account/avatar/00/10/e7/32/82939538.jpg","comment_is_top":false,"comment_ctime":1585216536,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585216536","product_id":100017301,"comment_content":"鉴权：<br>主要使用的数据结构是散列表 + 数组<br>主要使用的算法是：<br>精确匹配：二分查找<br>前缀匹配：Trie树<br>模糊匹配：回溯<br><br>限流：<br>1、固定时间窗口<br>2、滑动时间窗口<br><br>漏桶算法<br>令牌桶 ","like_count":0},{"had_liked":false,"id":174214,"user_name":"梦想的优惠券","can_delete":false,"product_type":"c1","uid":1257418,"ip_address":"","ucode":"D3B44F6C618CA7","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/ca/cbce6e94.jpg","comment_is_top":false,"comment_ctime":1580092336,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1580092336","product_id":100017301,"comment_content":"打卡<br>","like_count":0},{"had_liked":false,"id":164484,"user_name":"+@+","can_delete":false,"product_type":"c1","uid":1137873,"ip_address":"","ucode":"58067127007683","user_header":"https://static001.geekbang.org/account/avatar/00/11/5c/d1/9bdd6906.jpg","comment_is_top":false,"comment_ctime":1577004802,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1577004802","product_id":100017301,"comment_content":"3. 如何实现模糊匹配规则？  这个题目上面的那个图  是不是有问题  base  detail？","like_count":0,"discussions":[{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":229495,"discussion_content":"实现模糊匹配的图感觉没看懂。有序数组是怎么存储的呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586658090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122861,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1565560312,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1565560312","product_id":100017301,"comment_content":"思考题二<br>鉴权的前缀匹配算法用了trie树，匹配的时间复杂度就是O（n），空间复杂度比较高，对于没有优化过的trie树，假设字母表长度是m，树的高度是h，复杂度是指数级的O(m^(h+1))","like_count":0,"discussions":[{"author":{"id":1082785,"avatar":"https://static001.geekbang.org/account/avatar/00/10/85/a1/2442332c.jpg","nickname":"郭俊杰","note":"","ucode":"D328E5738A4413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":253518,"discussion_content":"这空间复杂度，把整个trie树都计算啦？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588240290,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122860,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1565559864,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565559864","product_id":100017301,"comment_content":"思考题一<br>限流的思路和LRU相似，可以用老师提过的哈希表和双向链表组合的方法处理，这种方法比循环队列的好处是提供了快速查询功能，但是实现更复杂一些。","like_count":0}]}