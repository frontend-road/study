{"id":786123,"title":"29｜泛型基本概念和泛型工具","content":"","comments":[{"had_liked":false,"id":392809,"user_name":"云中行走","can_delete":false,"product_type":"c3","uid":1798511,"ip_address":"陕西","ucode":"99C0EF21FCF6B3","user_header":"https://static001.geekbang.org/account/avatar/00/1b/71/6f/0193d484.jpg","comment_is_top":false,"comment_ctime":1721836220,"is_pvip":false,"replies":[{"id":142709,"content":"你的理解是正确的，这也是做这种分类的主要目的和依据。另外补充一点，“泛型声明”其实是静态声明，与传统的C++中的“模板（泛型）”在语义上是一致的，这是它能反推的根本原因。\n\n泛型工具中的两种分类比较特别，一般的资料中都不这么分的。它们的相同之处在于“求值”，或称为计算的、动态的。我是为了后面讲其它类型的方便而把它们分成声明与转换的两类。声明性的泛型工具返回的结果与它声明的类型一致，这样也就可以反推了（例如Record）。这一点我觉得你也注意到了。\n\n至于Partial主要是它不是一个“已有的类型概念”，所以没分到声明中，同样的还有Required和Readonly。事实上，在语义上它更像一个修饰词，例如：\n```\ntype PartialRecord&lt;T, R&gt; = Partial&lt;Record&lt;T, R&gt;&gt;;\n```\n\n是“声明一个类型”，还是“对类型加以计算”，才是分类的关键。有些东西正好在这二者的边界上，就比较模糊。Partial&lt;X&gt;是“声明了X成员的可选性质”，还是“对X的性质施加了计算”呢？都对呵，视角不同呵。","user_name":"作者回复","user_name_real":"作者","uid":1521669,"ctime":1721888239,"ip_address":"江苏","comment_id":392809,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"我的理解和问题：\n我理解的文中提到的声明和求值的区别是：声明\n● 范型声明(声明)是在已有的结构中使用范型，使得已有结构更高阶，类型更通用，提升了原有结构的抽象层级，如接口范型，函数范型。\n● 工具类型(声明)首先是用type类型声明的，方便后面写表达式类型，把范型变量放置到表达式类型中，这样得到的仍待是是一个原有结构更加通用的结构，保持了范型参数的自身的完整性\n● 范型工具也是用type声明的，不过内部可以对范型变量做转换或处理，是用来对求输入的类型进行特定操作，以得到一个新的类型。\n老师在文中提到的“范型声明”应该是输入类型和输出类型具有一致的结构，上述的范型声明和工具类型，显然是符合的，表现为 实例化后的类型 extends 范型类型&lt;infer x&gt;, 此时的x即为实例化时的范型参数，\n按此逻辑，求值的范型工具，就没有上述的反推范型参数的表现，如老师提到的toUnion 范型工具，就无法反推，但其中老师把内置的Partial也归类到求值的范型工具中，但实际仍可反推，是不是说明有些范型工具也是具有一致结构的呢？","like_count":4,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":648626,"discussion_content":"你的理解是正确的，这也是做这种分类的主要目的和依据。另外补充一点，“泛型声明”其实是静态声明，与传统的C++中的“模板（泛型）”在语义上是一致的，这是它能反推的根本原因。\n\n泛型工具中的两种分类比较特别，一般的资料中都不这么分的。它们的相同之处在于“求值”，或称为计算的、动态的。我是为了后面讲其它类型的方便而把它们分成声明与转换的两类。声明性的泛型工具返回的结果与它声明的类型一致，这样也就可以反推了（例如Record）。这一点我觉得你也注意到了。\n\n至于Partial主要是它不是一个“已有的类型概念”，所以没分到声明中，同样的还有Required和Readonly。事实上，在语义上它更像一个修饰词，例如：\n```\ntype PartialRecord<T, R> = Partial<Record<T, R>>;\n```\n\n是“声明一个类型”，还是“对类型加以计算”，才是分类的关键。有些东西正好在这二者的边界上，就比较模糊。Partial<X>是“声明了X成员的可选性质”，还是“对X的性质施加了计算”呢？都对呵，视角不同呵。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1721888239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]}]}