{"id":481359,"title":"加餐｜宏编程（上）：用最“笨”的方式撰写宏","content":"<p>你好，我是陈天。</p><p>学过上一讲，相信你现在应该理解为什么在课程的<a href=\"https://time.geekbang.org/column/article/414478\">第 6 讲</a>我们说，宏的本质其实很简单，抛开 quote/unquote，宏编程主要的工作就是把一棵语法树转换成另一颗语法树，而这个转换的过程深入下去，不过就是数据结构到数据结构的转换。</p><p>那在Rust里宏到底是如何做到转换的呢？</p><p>接下来，我们就一起尝试构建声明宏和过程宏。希望你能从自己撰写的过程中，感受构建宏的过程中做数据转换的思路和方法，掌握了这个方法，你可以应对几乎所有和宏编程有关的问题。</p><h2>如何构建声明宏</h2><p>首先看声明宏是如何创建的。</p><p>我们 <code>cargo new macros --lib</code> 创建一个新的项目，然后在新生成的项目下，创建 examples 目录，添加 examples/rule.rs（<a href=\"https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=13d255537f5bae59fb83a205373b1ff7\">代码</a>）：</p><pre><code class=\"language-rust\">#[macro_export]\nmacro_rules! my_vec {\n    // 没带任何参数的 my_vec，我们创建一个空的 vec\n    () =&gt; {\n        std::vec::Vec::new()\n    };\n    // 处理 my_vec![1, 2, 3, 4]\n    ($($el:expr),*) =&gt; ({\n        let mut v = std::vec::Vec::new();\n        $(v.push($el);)*\n        v\n    });\n    // 处理 my_vec![0; 10]\n    ($el:expr; $n:expr) =&gt; {\n        std::vec::from_elem($el, $n)\n    }\n}\n\nfn main() {\n    let mut v = my_vec![];\n    v.push(1);\n    // 调用时可以使用 [], (), {}\n    let _v = my_vec!(1, 2, 3, 4);\n    let _v = my_vec![1, 2, 3, 4];\n    let v = my_vec! {1, 2, 3, 4};\n    println!(\"{:?}\", v);\n\n    println!(\"{:?}\", v);\n    //\n    let v = my_vec![1; 10];\n    println!(\"{:?}\", v);\n}\n</code></pre><!-- [[[read_end]]] --><p>上一讲我们说过对于声明宏可以用 <code>macro_rules!</code> 生成。macro_rules 使用模式匹配，所以你可以提供多个匹配条件以及匹配后对应执行的代码块。</p><p>看这段代码，我们写了3个匹配的rules。</p><p>第一个 <code>() =&gt; (std::vec::Vec::new())</code> 很好理解，如果没有传入任何参数，就创建一个新的 Vec。注意，由于宏要在调用的地方展开，我们无法预测调用者的环境是否已经做了相关的 use，所以我们使用的代码最好带着完整的命名空间。</p><p><strong>这第二个匹配条件 <code>($($el:expr),*)</code>，需要详细介绍一下</strong>。</p><p>在声明宏中，条件捕获的参数使用 $ 开头的标识符来声明。每个参数都需要提供类型，这里 expr 代表表达式，所以 <code>$el:expr</code> 是说把匹配到的表达式命名为 <code>$el</code>。<code>$(...),*</code> 告诉编译器可以匹配任意多个以逗号分隔的表达式，然后捕获到的每一个表达式可以用 <code>$el</code> 来访问。</p><p>由于匹配的时候匹配到一个 <code>$(...)*</code> （我们可以不管分隔符），在执行的代码块中，我们也要相应地使用 <code>$(...)*</code> 展开。所以这句 <code>$(v.push($el);)*</code> 相当于匹配出多少个 <code>$el</code>就展开多少句 push 语句。</p><p>理解了第二个匹配条件，第三个就很好理解了：如果传入用冒号分隔的两个表达式，那么会用 from_element 构建 Vec。</p><p>在使用声明宏时，我们需要为参数明确类型，哪些类型可用也整理在这里了：</p><ul>\n<li><code>item</code>，比如一个函数、结构体、模块等。</li>\n<li><code>block</code>，代码块。比如一系列由花括号包裹的表达式和语句。</li>\n<li><code>stmt</code>，语句。比如一个赋值语句。</li>\n<li><code>pat</code>，模式。</li>\n<li><code>expr</code>，表达式。刚才的例子使用过了。</li>\n<li><code>ty</code>，类型。比如 Vec。</li>\n<li><code>ident</code>，标识符。比如一个变量名。</li>\n<li><code>path</code>，路径。比如：<code>foo</code>、<code>::std::mem::replace</code>、<code>transmute::&lt;_,&nbsp;int&gt;</code>。</li>\n<li><code>meta</code>，元数据。一般是在 <code>#[...]</code>&nbsp;和&nbsp;<code>#![...]</code>&nbsp;属性内部的数据。</li>\n<li><code>tt</code>，单个的 token 树。</li>\n<li><code>vis</code>，可能为空的一个&nbsp;<code>Visibility</code>&nbsp;修饰符。比如 pub、pub(crate)。</li>\n</ul><p>声明宏构建起来很简单，<strong>只要遵循它的基本语法，你可以很快把一个函数或者一些重复的语句片段转换成声明宏</strong>。</p><p>比如在处理 pipeline 时，我经常会根据某个返回 Result 的表达式的结果，做下面代码里这样的 match，使其在出错时返回 PipelineError 这个 enum 而非 Result：</p><pre><code class=\"language-rust\">match result {\n    Ok(v) =&gt; v,\n    Err(e) =&gt; {\n        return pipeline::PlugResult::Err {\n            ctx,\n            err: pipeline::PipelineError::Internal(e.to_string()),\n        }\n    }\n}\n</code></pre><p>但是这种写法，在同一个函数内，可能会反复出现，我们又无法用函数将其封装，所以我们可以用声明宏来实现，可以大大简化代码：</p><pre><code class=\"language-rust\">#[macro_export]\nmacro_rules! try_with {\n    ($ctx:ident, $exp:expr) =&gt; {\n        match $exp {\n            Ok(v) =&gt; v,\n            Err(e) =&gt; {\n                return pipeline::PlugResult::Err {\n                    ctx: $ctx,\n                    err: pipeline::PipelineError::Internal(e.to_string()),\n                }\n            }\n        }\n    };\n}\n</code></pre><h2>如何构建过程宏</h2><p>接下来我们讲讲如何构建过程宏。</p><p>过程宏要比声明宏要复杂很多，不过无论是哪一种过程宏，<strong>本质都是一样的，都涉及要把输入的 TokenStream 处理成输出的 TokenStream</strong>。</p><p>要构建过程宏，你需要单独构建一个 crate，在 Cargo.toml 中添加 proc-macro 的声明：</p><pre><code class=\"language-rust\">[lib]\nproc-macro = true\n</code></pre><p>这样，编译器才允许你使用 <code>#[proc_macro]</code> 相关的宏。所以我们先在今天这堂课生成的 crate 的 Cargo.toml 中添加这个声明，然后在 <a href=\"http://lib.rs\">lib.rs</a> 里写入如下代码：</p><pre><code class=\"language-rust\">use proc_macro::TokenStream;\n\n#[proc_macro]\npub fn query(input: TokenStream) -&gt; TokenStream {\n    println!(\"{:#?}\", input);\n    \"fn hello() { println!(\\\\\"Hello world!\\\\\"); }\"\n        .parse()\n        .unwrap()\n}\n</code></pre><p>这段代码首先声明了它是一个 proc_macro，并且是最基本的、函数式的过程宏。</p><p>使用者可以通过 <code>query!(...)</code> 来调用。我们打印传入的 <a href=\"https://doc.rust-lang.org/proc_macro/struct.TokenStream.html\">TokenStream</a>，然后把一段包含在字符串中的代码解析成 TokenStream 返回。这里可以非常方便地用字符串的 parse() 方法来获得 TokenStream，是因为 TokenStream 实现了 <a href=\"https://doc.rust-lang.org/std/str/trait.FromStr.html\">FromStr</a> trait，感谢Rust。</p><p>好，明白这段代码做了什么，我们写个例子尝试使用一下，来创建 examples/query.rs，并写入代码：</p><pre><code class=\"language-rust\">use macros::query;\n\nfn main() {\n    query!(SELECT * FROM users WHERE age &gt; 10);\n}\n</code></pre><p>可以看到，尽管 <code>SELECT * FROM user WHERE age &gt; 10</code> 不是一个合法的 Rust 语法，但 Rust 的词法分析器还是把它解析成了 TokenStream，提供给 query 宏。</p><p>运行 <code>cargo run --example query</code>，看 query 宏对输入 TokenStream 的打印：</p><pre><code class=\"language-rust\">TokenStream [\n    Ident {\n        ident: \"SELECT\",\n        span: #0 bytes(43..49),\n    },\n    Punct {\n        ch: '*',\n        spacing: Alone,\n        span: #0 bytes(50..51),\n    },\n    Ident {\n        ident: \"FROM\",\n        span: #0 bytes(52..56),\n    },\n    Ident {\n        ident: \"users\",\n        span: #0 bytes(57..62),\n    },\n    Ident {\n        ident: \"WHERE\",\n        span: #0 bytes(63..68),\n    },\n    Ident {\n        ident: \"age\",\n        span: #0 bytes(69..72),\n    },\n    Punct {\n        ch: '&gt;',\n        spacing: Alone,\n        span: #0 bytes(73..74),\n    },\n    Literal {\n        kind: Integer,\n        symbol: \"10\",\n        suffix: None,\n        span: #0 bytes(75..77),\n    },\n]\n</code></pre><p>这里面，TokenStream 是一个 Iterator，里面包含一系列的 <a href=\"https://doc.rust-lang.org/proc_macro/enum.TokenTree.html\">TokenTree</a>：</p><pre><code class=\"language-rust\">pub enum TokenTree {\n    Group(Group),\n    Ident(Ident),\n    Punct(Punct),\n    Literal(Literal),\n}\n</code></pre><p>后三个分别是 Ident（标识符）、Punct（标点符号）和 Literal（字面量）。这里的Group（组），是因为如果你的代码中包含括号，比如<code>{} [] &lt;&gt; ()</code> ，那么内部的内容会被分析成一个 Group（组）。你也可以试试把例子中对 <code>query!</code> 的调用改成这个样子：</p><pre><code class=\"language-rust\">query!(SELECT * FROM users u JOIN (SELECT * from profiles p) WHERE u.id = p.id and u.age &gt; 10);\n</code></pre><p>再运行一下 <code>cargo run --example query</code>，看看现在的 TokenStream 长什么样子，是否包含 Group。</p><p>好，现在我们对输入的 TokenStream 有了一个概念，那么，输出的 TokenStream 有什么用呢？我们的 <code>query!</code> 宏返回了一个 <code>hello()</code> 函数的 TokenStream，这个函数真的可以直接调用么？</p><p>你可以试试在 main() 里加入对 hello() 的调用，再次运行这个 example，可以看到久违的 “Hello world!” 打印。</p><p>恭喜你！你的第一个过程宏就完成了！</p><p>虽然这并不是什么了不起的结果，但是通过它，我们认识到了过程宏的基本写法，以及TokenStream / TokenTree 的基本结构。</p><p>接下来，我们就尝试实现一个派生宏，这是过程宏的三类宏中对大家最有意义的一类，也是工作中如果需要写过程宏主要会用到的宏类型。</p><h2>如何构建派生宏</h2><p>我们期望构建一个 Builder 派生宏，实现 <a href=\"https://github.com/dtolnay/proc-macro-workshop\">proc-macro-workshop</a> 里<a href=\"https://github.com/dtolnay/proc-macro-workshop/blob/master/builder/tests/06-optional-field.rs\">如下需求</a>（proc-macro-workshop是 Rust 大牛 David Tolnay 为帮助大家更好地学习宏编程构建的练习）：</p><pre><code class=\"language-rust\">#[derive(Builder)]\npub struct Command {\n    executable: String,\n    args: Vec&lt;String&gt;,\n    env: Vec&lt;String&gt;,\n    current_dir: Option&lt;String&gt;,\n}\n\nfn main() {\n    let command = Command::builder()\n        .executable(\"cargo\".to_owned())\n        .args(vec![\"build\".to_owned(), \"--release\".to_owned()])\n        .env(vec![])\n        .build()\n        .unwrap();\n    assert!(command.current_dir.is_none());\n\n    let command = Command::builder()\n        .executable(\"cargo\".to_owned())\n        .args(vec![\"build\".to_owned(), \"--release\".to_owned()])\n        .env(vec![])\n        .current_dir(\"..\".to_owned())\n        .build()\n        .unwrap();\n    assert!(command.current_dir.is_some());\n}\n</code></pre><p>可以看到，我们仅仅是为 Command 这个结构提供了 Builder 宏，就让它支持 builder() 方法，返回了一个 CommandBuilder 结构，这个结构有若干个和 Command 内部每个域名字相同的方法，我们可以链式调用这些方法，最后 build() 出一个 Command 结构。</p><p>我们创建一个 examples/command.rs，把这部分代码添加进去。显然，它是无法编译通过的。下面先来手工撰写对应的代码，看看一个完整的、能够让 main() 正确运行的代码长什么样子：</p><pre><code class=\"language-rust\">#[allow(dead_code)]\n#[derive(Debug)]\npub struct Command {\n    executable: String,\n    args: Vec&lt;String&gt;,\n    env: Vec&lt;String&gt;,\n    current_dir: Option&lt;String&gt;,\n}\n\n#[derive(Debug, Default)]\npub struct CommandBuilder {\n    executable: Option&lt;String&gt;,\n    args: Option&lt;Vec&lt;String&gt;&gt;,\n    env: Option&lt;Vec&lt;String&gt;&gt;,\n    current_dir: Option&lt;String&gt;,\n}\n\nimpl Command {\n    pub fn builder() -&gt; CommandBuilder {\n        Default::default()\n    }\n}\n\nimpl CommandBuilder {\n    pub fn executable(mut self, v: String) -&gt; Self {\n        self.executable = Some(v.to_owned());\n        self\n    }\n\n    pub fn args(mut self, v: Vec&lt;String&gt;) -&gt; Self {\n        self.args = Some(v.to_owned());\n        self\n    }\n\n    pub fn env(mut self, v: Vec&lt;String&gt;) -&gt; Self {\n        self.env = Some(v.to_owned());\n        self\n    }\n\n    pub fn current_dir(mut self, v: String) -&gt; Self {\n        self.current_dir = Some(v.to_owned());\n        self\n    }\n\n    pub fn build(mut self) -&gt; Result&lt;Command, &amp;'static str&gt; {\n        Ok(Command {\n            executable: self.executable.take().ok_or(\"executable must be set\")?,\n            args: self.args.take().ok_or(\"args must be set\")?,\n            env: self.env.take().ok_or(\"env must be set\")?,\n            current_dir: self.current_dir.take(),\n        })\n    }\n}\n\nfn main() {\n    let command = Command::builder()\n        .executable(\"cargo\".to_owned())\n        .args(vec![\"build\".to_owned(), \"--release\".to_owned()])\n        .env(vec![])\n        .build()\n        .unwrap();\n    assert!(command.current_dir.is_none());\n\n    let command = Command::builder()\n        .executable(\"cargo\".to_owned())\n        .args(vec![\"build\".to_owned(), \"--release\".to_owned()])\n        .env(vec![])\n        .current_dir(\"..\".to_owned())\n        .build()\n        .unwrap();\n    assert!(command.current_dir.is_some());\n    println!(\"{:?}\", command);\n} \n</code></pre><p>这个代码很简单，基本就是照着 main() 中的使用方法，一个函数一个函数手写出来的，你可以看到代码中很多重复的部分，尤其是 CommandBuilder 里的方法，这是我们可以用宏来自动生成的。</p><p>那怎么生成这样的代码呢？显然，我们要把输入的 TokenStream抽取出来，也就是把在 struct 的定义内部，每个域的名字及其类型都抽出来，然后生成对应的方法代码。</p><p><strong>如果把代码看做是字符串的话，不难想象到，实际上就是要通过一个模板和对应的数据，生成我们想要的结果</strong>。用模板生成 HTML，想必各位都不陌生，但通过模板生成 Rust 代码，估计你是第一次。</p><p>有了这个思路，我们尝试着用 <a href=\"https://jinja.palletsprojects.com/en/3.0.x/\">jinja</a> 写一个生成 CommandBuilder 结构的模板。在 Rust 里，我们有 <a href=\"https://github.com/djc/askama\">askma</a> 这个非常高效的库来处理 jinja。模板大概长这个样子：</p><pre><code class=\"language-rust\">#[derive(Debug, Default)]\npub struct {{ builder_name }} {\n    {% for field in fields %}\n    {{ field.name }}: Option&lt;{{ field.ty }}&gt;,\n    {% endfor %}\n}\n</code></pre><p>这里的 fileds / builder_name 是我们要传入的参数，每个 field 还需要 name 和 ty 两个属性，分别对应 field 的名字和类型。我们也可以为这个结构生成方法：</p><pre><code class=\"language-rust\">impl {{ builder_name }} {\n    {% for field in fields %}\n    pub fn {{ field.name }}(mut self, v: impl Into&lt;{{ field.ty }}&gt;) -&gt; {{ builder_name }} {\n        self.{{ field.name }} = Some(v.into());\n        self\n    }\n    {% endfor %}\n\n    pub fn build(self) -&gt; Result&lt;{{ name }}, &amp;'static str&gt; {\n        Ok({{ name }} {\n            {% for field in fields %}\n            {% if field.optional %}\n            {{ field.name }}: self.{{ field.name }},\n            {% else %}\n            {{ field.name }}: self.{{ field.name }}.ok_or(\"Build failed: missing {{ field.name }}\")?,\n            {% endif %}\n            {% endfor %}\n        })\n    }\n}\n</code></pre><p>对于原本是 Option&lt;T&gt; 类型的域，要避免生成 Option&lt;Option<t>&gt;，我们需要把是否是 Option 单独抽取出来，如果是 Option&lt;T&gt;，那么 ty 就是 T。所以，field 还需要一个属性 optional。</t></p><p>有了这个思路，我们可以构建自己的数据结构来描述 Field：</p><pre><code class=\"language-rust\">#[derive(Debug, Default)]\nstruct Fd {\n    name: String,\n    ty: String,\n    optional: bool,\n}\n</code></pre><p><strong>当我们有了模板，又定义好了为模板提供数据的结构，接下来要处理的核心问题就是：如何从 TokenStream 中抽取出来我们想要的信息</strong>？</p><p>带着这个问题，我们在 <a href=\"http://lib.rs\">lib.rs</a> 里添加一个 derive macro，把 input 打印出来：</p><pre><code class=\"language-rust\">#[proc_macro_derive(RawBuilder)]\npub fn derive_raw_builder(input: TokenStream) -&gt; TokenStream {\n    println!(\"{:#?}\", input);\n    TokenStream::default()\n}\n</code></pre><p>对于 derive macro，要使用 <code>proce_macro_derive</code> 这个宏。我们把这个 derive macro 命名为 RawBuilder。在 examples/command.rs 中，我们修改 Command 结构，使其使用 RawBuilder（注意要 use macros::RawBuilder）：</p><pre><code class=\"language-rust\">use macros::RawBuilder;\n\n#[allow(dead_code)]\n#[derive(Debug, RawBuilder)]\npub struct Command {\n    ...\n}\n</code></pre><p>运行这个 example 后，我们会看到一大片 TokenStream 的打印（比较长这里就不贴了），仔细阅读这个打印，可以看到：</p><ul>\n<li>首先有一个 Group，包含了 <code>#[allow(dead_code)]</code> 属性的信息。因为我们现在拿到的 derive 下的信息，所以所有不属于 <code>#[derive(...)]</code> 的属性，都会被放入 TokenStream 中。</li>\n<li>之后是 pub / struct / Command 三个 ident。</li>\n<li>随后又是一个 Group，包含了每个 field 的信息。我们看到，field 之间用逗号这个 Punct 分隔，field 的名字和类型又是通过冒号这个 Punct 分隔。而类型，可能是一个 Ident，如 String，或者一系列 Ident / Punct，如 Vec / &lt; / String / &gt;。</li>\n</ul><p><strong>我们要做的就是，把这个 TokenStream 中的 struct 名字，以及每个 field 的名字和类型拿出来</strong>。如果类型是 Option&lt;T&gt;，那么把 T 拿出来，把 optional 设置为 true。</p><p>好，有了这个思路，来写代码。首先在 Cargo.toml 中引入一些依赖：</p><pre><code class=\"language-rust\">[dependencies]\nanyhow = \"1\"\naskama = \"0.11\" # 处理 jinjia 模板，模板需要放在和 src 平行的 templates 目录下\n</code></pre><p>akama 要求模板放在和 src 平行的 templates 目录下，创建这个目录，然后写入 templates/builder.j2：</p><pre><code class=\"language-rust\">impl {{ name }} {\n    pub fn builder() -&gt; {{ builder_name }} {\n        Default::default()\n    }\n}\n\n#[derive(Debug, Default)]\npub struct {{ builder_name }} {\n    {% for field in fields %}\n        {{ field.name }}: Option&lt;{{ field.ty }}&gt;,\n    {% endfor %}\n}\n\nimpl {{ builder_name }} {\n    {% for field in fields %}\n    pub fn {{ field.name }}(mut self, v: impl Into&lt;{{ field.ty }}&gt;) -&gt; {{ builder_name }} {\n        self.{{ field.name }} = Some(v.into());\n        self\n    }\n    {% endfor %}\n\n    pub fn build(self) -&gt; Result&lt;{{ name }}, &amp;'static str&gt; {\n        Ok({{ name }} {\n            {% for field in fields %}\n                {% if field.optional %}\n                {{ field.name }}: self.{{ field.name }},\n                {% else %}\n                {{ field.name }}: self.{{ field.name }}.ok_or(\"Build failed: missing {{ field.name }}\")?,\n                {% endif %}\n            {% endfor %}\n        })\n    }\n}\n</code></pre><p>然后创建 src/raw_builder.rs（记得在 <a href=\"http://lib.rs\">lib.rs</a> 中引入），写入代码，这段代码我加了详细的注释，你可以对着打印出来的 TokenStream和刚才的分析，相信不难理解。</p><pre><code class=\"language-rust\">use anyhow::Result;\nuse askama::Template;\nuse proc_macro::{Ident, TokenStream, TokenTree};\nuse std::collections::VecDeque;\n\n/// 处理 jinja 模板的数据结构，在模板中我们使用了 name / builder_name / fields\n#[derive(Template)]\n#[template(path = \"builder.j2\", escape = \"none\")]\npub struct BuilderContext {\n    name: String,\n    builder_name: String,\n    fields: Vec&lt;Fd&gt;,\n}\n\n/// 描述 struct 的每个 field\n#[derive(Debug, Default)]\nstruct Fd {\n    name: String,\n    ty: String,\n    optional: bool,\n}\n\nimpl Fd {\n    /// name 和 field 都是通过冒号 Punct 切分出来的 TokenTree 切片\n    pub fn new(name: &amp;[TokenTree], ty: &amp;[TokenTree]) -&gt; Self {\n        // 把类似 Ident(\"Option\"), Punct('&lt;'), Ident(\"String\"), Punct('&gt;) 的 ty\n        // 收集成一个 String 列表，如 vec![\"Option\", \"&lt;\", \"String\", \"&gt;\"]\n        let ty = ty\n            .iter()\n            .map(|v| match v {\n                TokenTree::Ident(n) =&gt; n.to_string(),\n                TokenTree::Punct(p) =&gt; p.as_char().to_string(),\n                e =&gt; panic!(\"Expect ident, got {:?}\", e),\n            })\n            .collect::&lt;Vec&lt;_&gt;&gt;();\n        // 冒号前最后一个 TokenTree 是 field 的名字\n        // 比如：executable: String,\n        // 注意这里不应该用 name[0]，因为有可能是 pub executable: String\n        // 甚至，带 attributes 的 field，\n        // 比如：#[builder(hello = world)] pub executable: String\n        match name.last() {\n            Some(TokenTree::Ident(name)) =&gt; {\n                // 如果 ty 第 0 项是 Option，那么从第二项取到倒数第一项\n                // 取完后上面的例子中的 ty 会变成 [\"String\"]，optiona = true\n                let (ty, optional) = if ty[0].as_str() == \"Option\" {\n                    (&amp;ty[2..ty.len() - 1], true)\n                } else {\n                    (&amp;ty[..], false)\n                };\n                Self {\n                    name: name.to_string(),\n                    ty: ty.join(\"\"), // 把 ty join 成字符串\n                    optional,\n                }\n            }\n            e =&gt; panic!(\"Expect ident, got {:?}\", e),\n        }\n    }\n}\n\nimpl BuilderContext {\n    /// 从 TokenStream 中提取信息，构建 BuilderContext\n    fn new(input: TokenStream) -&gt; Self {\n        let (name, input) = split(input);\n        let fields = get_struct_fields(input);\n        Self {\n            builder_name: format!(\"{}Builder\", name),\n            name: name.to_string(),\n            fields,\n        }\n    }\n\n    /// 把模板渲染成字符串代码\n    pub fn render(input: TokenStream) -&gt; Result&lt;String&gt; {\n        let template = Self::new(input);\n        Ok(template.render()?)\n    }\n}\n\n/// 把 TokenStream 分出 struct 的名字，和包含 fields 的 TokenStream\nfn split(input: TokenStream) -&gt; (Ident, TokenStream) {\n    let mut input = input.into_iter().collect::&lt;VecDeque&lt;_&gt;&gt;();\n    // 一直往后找，找到 struct 停下来\n    while let Some(item) = input.pop_front() {\n        if let TokenTree::Ident(v) = item {\n            if v.to_string() == \"struct\" {\n                break;\n            }\n        }\n    }\n\n    // struct 后面，应该是 struct name\n    let ident;\n    if let Some(TokenTree::Ident(v)) = input.pop_front() {\n        ident = v;\n    } else {\n        panic!(\"Didn't find struct name\");\n    }\n\n    // struct 后面可能还有若干 TokenTree，我们不管，一路找到第一个 Group\n    let mut group = None;\n    for item in input {\n        if let TokenTree::Group(g) = item {\n            group = Some(g);\n            break;\n        }\n    }\n\n    (ident, group.expect(\"Didn't find field group\").stream())\n}\n\n/// 从包含 fields 的 TokenStream 中切出来一个个 Fd\nfn get_struct_fields(input: TokenStream) -&gt; Vec&lt;Fd&gt; {\n    let input = input.into_iter().collect::&lt;Vec&lt;_&gt;&gt;();\n    input\n        .split(|v| match v {\n            // 先用 ',' 切出来一个个包含 field 所有信息的 &amp;[TokenTree]\n            TokenTree::Punct(p) =&gt; p.as_char() == ',',\n            _ =&gt; false,\n        })\n        .map(|tokens| {\n            tokens\n                .split(|v| match v {\n                    // 再用 ':' 把 &amp;[TokenTree] 切成 [&amp;[TokenTree], &amp;[TokenTree]]\n                    // 它们分别对应名字和类型\n                    TokenTree::Punct(p) =&gt; p.as_char() == ':',\n                    _ =&gt; false,\n                })\n                .collect::&lt;Vec&lt;_&gt;&gt;()\n        })\n        // 正常情况下，应该得到 [&amp;[TokenTree], &amp;[TokenTree]]，对于切出来长度不为 2 的统统过滤掉\n        .filter(|tokens| tokens.len() == 2)\n        // 使用 Fd::new 创建出每个 Fd\n        .map(|tokens| Fd::new(tokens[0], &amp;tokens[1]))\n        .collect()\n}\n</code></pre><p>核心的就是 get_struct_fields() 方法，如果你觉得难懂，可以想想如果你要把一个 <code>a=1,b=2</code> 的字符串切成 <code>[[a, 1], [b, 2]]</code> 该怎么做，就很容易理解了。</p><p>好，完成了把 TokenStream 转换成 BuilderContext 的代码，<strong>接下来就是在 proc_macro 中使用这个结构以及它的 render 方法</strong>。我们把 <a href=\"http://lib.rs\">lib.rs</a> 中的代码修改一下（注意添加相关的 use）：</p><pre><code class=\"language-rust\">#[proc_macro_derive(RawBuilder)]\npub fn derive_raw_builder(input: TokenStream) -&gt; TokenStream {\n    BuilderContext::render(input).unwrap().parse().unwrap()\n}\n</code></pre><p>保存后，你立刻会发现，VS Code 抱怨 examples/command.rs 编译不过，因为里面有重复的数据结构和方法的定义。我们把之前手工生成的代码全部删掉，只保留：</p><pre><code class=\"language-rust\">use macros::RawBuilder;\n\n#[allow(dead_code)]\n#[derive(Debug, RawBuilder)]\npub struct Command {\n    executable: String,\n    args: Vec&lt;String&gt;,\n    env: Vec&lt;String&gt;,\n    current_dir: Option&lt;String&gt;,\n}\n\nfn main() {\n    let command = Command::builder()\n        .executable(\"cargo\".to_owned())\n        .args(vec![\"build\".to_owned(), \"--release\".to_owned()])\n        .env(vec![])\n        .build()\n        .unwrap();\n    assert!(command.current_dir.is_none());\n\n    let command = Command::builder()\n        .executable(\"cargo\".to_owned())\n        .args(vec![\"build\".to_owned(), \"--release\".to_owned()])\n        .env(vec![])\n        .current_dir(\"..\".to_owned())\n        .build()\n        .unwrap();\n    assert!(command.current_dir.is_some());\n    println!(\"{:?}\", command);\n}\n</code></pre><p>运行之，我们撰写的 RawBuilder 宏起作用了！代码运行一切正常！</p><h2>小结</h2><p>这一讲我们简单介绍了 Rust 宏编程的能力，并撰写了一个声明宏 my_vec! 和一个派生宏 RawBuilder。通过自己手写，核心就是要理解清楚宏做数据转换的方法：如何从 TokenStream 中抽取需要的数据，然后生成包含目标代码的字符串，最后再把字符串转换成 TokenStream。</p><p>在构建 RawBuilder 的过程中，我们还了解了 TokenStream 和 TokenTree，虽然这两个数据结构是 Rust 下的结构，但是 token stream / token tree 这样的概念是每个支持宏的语言共有的，如果你理解了 Rust 的宏编程，那么学习其他语言的宏编程就很容易了。</p><p>在手写的过程中，你可能会觉得宏编程过于繁琐，这是因为解析 TokenStream 是一个苦力活，要和各种各样的情况打交道，如果处理不好，就很容易出错。</p><p>那在Rust生态下有没有人已经做过这个苦力活了呢？我们下节课继续……</p><h3>思考题</h3><p>最后出个思考题给你练练手。工作中，有很多场景我们需要通过第三方的 schema 来生成 Rust 数据结构，比如 protobuf 的定义到 Rust struct/enum 的转换。这些转换如果手工撰写的话，是纯粹的体力活，我们可以通过宏来简化这个操作。</p><p>假设你的公司维护了大量的 openapi v3 spec，需要你通过它来生成 Rust 类型，比如这里的 schema 定义（<a href=\"https://gist.github.com/danielflower/5c5ae8a46a0a49aee508690c19b33ada#file-petstore-json-L833-L869\">来源</a>）：</p><pre><code class=\"language-rust\">{\n  \"type\": \"object\",\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\",\n      \"format\": \"int64\"\n    },\n    \"petId\": {\n      \"type\": \"integer\",\n      \"format\": \"int64\"\n    },\n    \"quantity\": {\n      \"type\": \"integer\",\n      \"format\": \"int32\"\n    },\n    \"shipDate\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"status\": {\n      \"type\": \"string\",\n      \"description\": \"Order Status\",\n      \"enum\": [\n        \"placed\",\n        \"approved\",\n        \"delivered\"\n      ]\n    },\n    \"complete\": {\n      \"type\": \"boolean\",\n      \"default\": false\n    }\n  },\n  \"xml\": {\n    \"name\": \"Order\"\n  }\n}\n</code></pre><p>你可以试着使用今天所学内容，撰写一个 <code>generate!</code> 宏，接受一个包含 schema 定义的文件名，生成 schema。如果你遇到问题卡壳了，可以参考B站上我live coding的<a href=\"https://www.bilibili.com/video/BV1Za411q7LQ/\">视频</a>。</p><p>欢迎在留言区讨论你的想法，如果觉得有收获，也欢迎你分享给身边的朋友，邀他一起讨论。我们下节课见。</p>","comments":[{"had_liked":false,"id":332156,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1643074502,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10233009094","product_id":100085301,"comment_content":"值！","like_count":2},{"had_liked":false,"id":336884,"user_name":"记事本","can_delete":false,"product_type":"c1","uid":1401568,"ip_address":"","ucode":"FA942636EE0CC8","user_header":"https://static001.geekbang.org/account/avatar/00/15/62/e0/d2ff52da.jpg","comment_is_top":false,"comment_ctime":1646447888,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646447888","product_id":100085301,"comment_content":"陈老师，无法识别use proc_macro::{TokenStream} unresolved import 克隆你仓库的代码都一样<br>","like_count":0},{"had_liked":false,"id":336873,"user_name":"记事本","can_delete":false,"product_type":"c1","uid":1401568,"ip_address":"","ucode":"FA942636EE0CC8","user_header":"https://static001.geekbang.org/account/avatar/00/15/62/e0/d2ff52da.jpg","comment_is_top":false,"comment_ctime":1646444308,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646444308","product_id":100085301,"comment_content":"清楚","like_count":0}]}