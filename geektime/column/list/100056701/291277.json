{"id":291277,"title":"21 | 缓冲区：一个可能引发“惨案”的地方","content":"<p>你好，我是蒋德钧。今天，我们一起来学习下Redis中缓冲区的用法。</p><p>缓冲区的功能其实很简单，主要就是用一块内存空间来暂时存放命令数据，以免出现因为数据和命令的处理速度慢于发送速度而导致的数据丢失和性能问题。但因为缓冲区的内存空间有限，如果往里面写入数据的速度持续地大于从里面读取数据的速度，就会导致缓冲区需要越来越多的内存来暂存数据。当缓冲区占用的内存超出了设定的上限阈值时，就会出现缓冲区溢出。</p><p>如果发生了溢出，就会丢数据了。那是不是不给缓冲区的大小设置上限，就可以了呢？显然不是，随着累积的数据越来越多，缓冲区占用内存空间越来越大，一旦耗尽了Redis实例所在机器的可用内存，就会导致Redis实例崩溃。</p><p>所以毫不夸张地说，缓冲区是用来避免请求或数据丢失的惨案的，但也只有用对了，才能真正起到“避免”的作用。</p><p>我们知道，Redis是典型的client-server架构，所有的操作命令都需要通过客户端发送给服务器端。所以，缓冲区在Redis中的一个主要应用场景，就是在客户端和服务器端之间进行通信时，用来暂存客户端发送的命令数据，或者是服务器端返回给客户端的数据结果。此外，缓冲区的另一个主要应用场景，是在主从节点间进行数据同步时，用来暂存主节点接收的写命令和数据。</p><!-- [[[read_end]]] --><p>这节课，我们就分别聊聊服务器端和客户端、主从集群间的缓冲区溢出问题，以及应对方案。</p><h2>客户端输入和输出缓冲区</h2><p>我们先来看看服务器端和客户端之间的缓冲区。</p><p>为了避免客户端和服务器端的请求发送和处理速度不匹配，服务器端给每个连接的客户端都设置了一个输入缓冲区和输出缓冲区，我们称之为客户端输入缓冲区和输出缓冲区。</p><p>输入缓冲区会先把客户端发送过来的命令暂存起来，Redis主线程再从输入缓冲区中读取命令，进行处理。当Redis主线程处理完数据后，会把结果写入到输出缓冲区，再通过输出缓冲区返回给客户端，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/b8/e4/b86be61e91bd7ca207989c220991fce4.jpg?wh=2725*1849\" alt=\"\"></p><p>下面，我们就分别学习下输入缓冲区和输出缓冲区发生溢出的情况，以及相应的应对方案。</p><h3>如何应对输入缓冲区溢出？</h3><p>我们前面已经分析过了，输入缓冲区就是用来暂存客户端发送的请求命令的，所以可能导致溢出的情况主要是下面两种：</p><ul>\n<li>写入了bigkey，比如一下子写入了多个百万级别的集合类型数据；</li>\n<li>服务器端处理请求的速度过慢，例如，Redis主线程出现了间歇性阻塞，无法及时处理正常发送的请求，导致客户端发送的请求在缓冲区越积越多。</li>\n</ul><p>接下来，我们就从<strong>如何查看输入缓冲区的内存使用情况，<strong>以及</strong>如何避免溢出</strong>这两个问题出发，来继续学习吧。</p><p>要查看和服务器端相连的每个客户端对输入缓冲区的使用情况，我们可以<strong>使用CLIENT LIST命令</strong>：</p><pre><code>CLIENT LIST\nid=5 addr=127.0.0.1:50487 fd=9 name= age=4 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=client\n</code></pre><p>CLIENT命令返回的信息虽然很多，但我们只需要重点关注两类信息就可以了。</p><p>一类是与服务器端连接的客户端的信息。这个案例展示的是一个客户端的输入缓冲区情况，如果有多个客户端，输出结果中的addr会显示不同客户端的IP和端口号。</p><p>另一类是与输入缓冲区相关的三个参数：</p><ul>\n<li>cmd，表示客户端最新执行的命令。这个例子中执行的是CLIENT命令。</li>\n<li>qbuf，表示输入缓冲区已经使用的大小。这个例子中的CLIENT命令已使用了26字节大小的缓冲区。</li>\n<li>qbuf-free，表示输入缓冲区尚未使用的大小。这个例子中的CLIENT命令还可以使用32742字节的缓冲区。qbuf和qbuf-free的总和就是，Redis服务器端当前为已连接的这个客户端分配的缓冲区总大小。这个例子中总共分配了 26 + 32742 = 32768字节，也就是32KB的缓冲区。</li>\n</ul><p>有了CLIENT LIST命令，我们就可以通过输出结果来判断客户端输入缓冲区的内存占用情况了。如果qbuf很大，而同时qbuf-free很小，就要引起注意了，因为这时候输入缓冲区已经占用了很多内存，而且没有什么空闲空间了。此时，客户端再写入大量命令的话，就会引起客户端输入缓冲区溢出，Redis的处理办法就是把客户端连接关闭，结果就是业务程序无法进行数据存取了。</p><p>通常情况下，Redis服务器端不止服务一个客户端，当多个客户端连接占用的内存总量，超过了Redis的maxmemory配置项时（例如4GB），就会触发Redis进行数据淘汰。一旦数据被淘汰出Redis，再要访问这部分数据，就需要去后端数据库读取，这就降低了业务应用的访问性能。此外，更糟糕的是，如果使用多个客户端，导致Redis内存占用过大，也会导致内存溢出（out-of-memory）问题，进而会引起Redis崩溃，给业务应用造成严重影响。</p><p>所以，我们必须得想办法避免输入缓冲区溢出。<strong>我们可以从两个角度去考虑如何避免，一是把缓冲区调大，二是从数据命令的发送和处理速度入手。</strong></p><p>我们先看看，到底有没有办法通过参数调整输入缓冲区的大小呢？答案是没有。</p><p>Redis的客户端输入缓冲区大小的上限阈值，在代码中就设定为了1GB。也就是说，Redis服务器端允许为每个客户端最多暂存1GB的命令和数据。1GB的大小，对于一般的生产环境已经是比较合适的了。一方面，这个大小对于处理绝大部分客户端的请求已经够用了；另一方面，如果再大的话，Redis就有可能因为客户端占用了过多的内存资源而崩溃。</p><p>所以，Redis并没有提供参数让我们调节客户端输入缓冲区的大小。如果要避免输入缓冲区溢出，那我们就只能从数据命令的发送和处理速度入手，也就是前面提到的避免客户端写入bigkey，以及避免Redis主线程阻塞。</p><p>接下来，我们再来看看输出缓冲区的溢出问题。</p><h3>如何应对输出缓冲区溢出？</h3><p>Redis的输出缓冲区暂存的是Redis主线程要返回给客户端的数据。一般来说，主线程返回给客户端的数据，既有简单且大小固定的OK响应（例如，执行SET命令）或报错信息，也有大小不固定的、包含具体数据的执行结果（例如，执行HGET命令）。</p><p>因此，Redis为每个客户端设置的输出缓冲区也包括两部分：一部分，是一个大小为16KB的固定缓冲空间，用来暂存OK响应和出错信息；另一部分，是一个可以动态增加的缓冲空间，用来暂存大小可变的响应结果。</p><p><strong>那什么情况下会发生输出缓冲区溢出呢？</strong> 我为你总结了三种：</p><ul>\n<li>服务器端返回bigkey的大量结果；</li>\n<li>执行了MONITOR命令；</li>\n<li>缓冲区大小设置得不合理。</li>\n</ul><p>其中，bigkey原本就会占用大量的内存空间，所以服务器端返回的结果包含bigkey，必然会影响输出缓冲区。接下来，我们就重点看下，执行MONITOR命令和设置缓冲区大小这两种情况吧。</p><p>MONITOR命令是用来监测Redis执行的。执行这个命令之后，就会持续输出监测到的各个命令操作，如下所示：</p><pre><code>MONITOR\nOK\n1600617456.437129 [0 127.0.0.1:50487] &quot;COMMAND&quot;\n1600617477.289667 [0 127.0.0.1:50487] &quot;info&quot; &quot;memory&quot;\n</code></pre><p>到这里，你有没有看出什么问题呢？MONITOR的输出结果会持续占用输出缓冲区，并越占越多，最后的结果就是发生溢出。所以，我要给你一个小建议：<strong>MONITOR命令主要用在调试环境中，不要在线上生产环境中持续使用MONITOR</strong>。当然，如果在线上环境中偶尔使用MONITOR检查Redis的命令执行情况，是没问题的。</p><p><strong>接下来，我们看下输出缓冲区大小设置的问题</strong>。和输入缓冲区不同，我们可以通过client-output-buffer-limit配置项，来设置缓冲区的大小。具体设置的内容包括两方面：</p><ul>\n<li>设置缓冲区大小的上限阈值；</li>\n<li>设置输出缓冲区持续写入数据的数量上限阈值，和持续写入数据的时间的上限阈值。</li>\n</ul><p>在具体使用client-output-buffer-limit来设置缓冲区大小的时候，我们需要先区分下客户端的类型。</p><p>对于和Redis实例进行交互的应用程序来说，主要使用两类客户端和Redis服务器端交互，分别是常规和Redis服务器端进行读写命令交互的普通客户端，以及订阅了Redis频道的订阅客户端。此外，在Redis主从集群中，主节点上也有一类客户端（从节点客户端）用来和从节点进行数据同步，我会在介绍主从集群中的缓冲区时，向你具体介绍。</p><p>当我们给普通客户端设置缓冲区大小时，通常可以在Redis配置文件中进行这样的设置：</p><pre><code>client-output-buffer-limit normal 0 0 0\n</code></pre><p>其中，normal表示当前设置的是普通客户端，第1个0设置的是缓冲区大小限制，第2个0和第3个0分别表示缓冲区持续写入量限制和持续写入时间限制。</p><p>对于普通客户端来说，它每发送完一个请求，会等到请求结果返回后，再发送下一个请求，这种发送方式称为阻塞式发送。在这种情况下，如果不是读取体量特别大的bigkey，服务器端的输出缓冲区一般不会被阻塞的。</p><p>所以，我们通常把普通客户端的缓冲区大小限制，以及持续写入量限制、持续写入时间限制都设置为0，也就是不做限制。</p><p>对于订阅客户端来说，一旦订阅的Redis频道有消息了，服务器端都会通过输出缓冲区把消息发给客户端。所以，订阅客户端和服务器间的消息发送方式，不属于阻塞式发送。不过，如果频道消息较多的话，也会占用较多的输出缓冲区空间。</p><p>因此，我们会给订阅客户端设置缓冲区大小限制、缓冲区持续写入量限制，以及持续写入时间限制，可以在Redis配置文件中这样设置：</p><pre><code>client-output-buffer-limit pubsub 8mb 2mb 60\n</code></pre><p>其中，pubsub参数表示当前是对订阅客户端进行设置；8mb表示输出缓冲区的大小上限为8MB，一旦实际占用的缓冲区大小要超过8MB，服务器端就会直接关闭客户端的连接；2mb和60表示，如果连续60秒内对输出缓冲区的写入量超过2MB的话，服务器端也会关闭客户端连接。</p><p>好了，我们来总结下如何应对输出缓冲区溢出：</p><ul>\n<li>避免bigkey操作返回大量数据结果；</li>\n<li>避免在线上环境中持续使用MONITOR命令。</li>\n<li>使用client-output-buffer-limit设置合理的缓冲区大小上限，或是缓冲区连续写入时间和写入量上限。</li>\n</ul><p>以上就是关于客户端缓冲区，我们要重点掌握的内容了。我们继续看看在主从集群间使用缓冲区，需要注意什么问题。</p><h2>主从集群中的缓冲区</h2><p>主从集群间的数据复制包括全量复制和增量复制两种。全量复制是同步所有数据，而增量复制只会把主从库网络断连期间主库收到的命令，同步给从库。无论在哪种形式的复制中，为了保证主从节点的数据一致，都会用到缓冲区。但是，这两种复制场景下的缓冲区，在溢出影响和大小设置方面并不一样。所以，我们分别来学习下吧。</p><h3>复制缓冲区的溢出问题</h3><p>在全量复制过程中，主节点在向从节点传输RDB文件的同时，会继续接收客户端发送的写命令请求。这些写命令就会先保存在复制缓冲区中，等RDB文件传输完成后，再发送给从节点去执行。主节点上会为每个从节点都维护一个复制缓冲区，来保证主从节点间的数据同步。</p><p><img src=\"https://static001.geekbang.org/resource/image/a3/7a/a39cd9a9f62c547e2069e6977239de7a.jpg?wh=2614*1572\" alt=\"\"></p><p>所以，如果在全量复制时，从节点接收和加载RDB较慢，同时主节点接收到了大量的写命令，写命令在复制缓冲区中就会越积越多，最终导致溢出。</p><p>其实，主节点上的复制缓冲区，本质上也是一个用于和从节点连接的客户端（我们称之为从节点客户端），使用的输出缓冲区。复制缓冲区一旦发生溢出，主节点也会直接关闭和从节点进行复制操作的连接，导致全量复制失败。那如何避免复制缓冲区发生溢出呢？</p><p>一方面，我们可以控制主节点保存的数据量大小。按通常的使用经验，我们会把主节点的数据量控制在2~4GB，这样可以让全量同步执行得更快些，避免复制缓冲区累积过多命令。</p><p>另一方面，我们可以使用client-output-buffer-limit配置项，来设置合理的复制缓冲区大小。设置的依据，就是主节点的数据量大小、主节点的写负载压力和主节点本身的内存大小。</p><p>我们通过一个具体的例子，来学习下具体怎么设置。在主节点执行如下命令：</p><pre><code>config set client-output-buffer-limit slave 512mb 128mb 60\n</code></pre><p>其中，slave参数表明该配置项是针对复制缓冲区的。512mb代表将缓冲区大小的上限设置为512MB；128mb和60代表的设置是，如果连续60秒内的写入量超过128MB的话，也会触发缓冲区溢出。</p><p>我们再继续看看这个设置对我们有啥用。假设一条写命令数据是1KB，那么，复制缓冲区可以累积512K条（512MB/1KB = 512K）写命令。同时，主节点在全量复制期间，可以承受的写命令速率上限是2000条/s（128MB/1KB/60 约等于2000）。</p><p>这样一来，我们就得到了一种方法：在实际应用中设置复制缓冲区的大小时，可以根据写命令数据的大小和应用的实际负载情况（也就是写命令速率），来粗略估计缓冲区中会累积的写命令数据量；然后，再和所设置的复制缓冲区大小进行比较，判断设置的缓冲区大小是否足够支撑累积的写命令数据量。</p><p>关于复制缓冲区，我们还会遇到一个问题。主节点上复制缓冲区的内存开销，会是每个从节点客户端输出缓冲区占用内存的总和。如果集群中的从节点数非常多的话，主节点的内存开销就会非常大。所以，我们还必须得控制和主节点连接的从节点个数，不要使用大规模的主从集群。</p><p>好了，我们先总结一下这部分的内容。为了避免复制缓冲区累积过多命令造成溢出，引发全量复制失败，我们可以控制主节点保存的数据量大小，并设置合理的复制缓冲区大小。同时，我们需要控制从节点的数量，来避免主节点中复制缓冲区占用过多内存的问题。</p><h3>复制积压缓冲区的溢出问题</h3><p>接下来，我们再来看下增量复制时使用的缓冲区，这个缓冲区称为复制积压缓冲区。</p><p>主节点在把接收到的写命令同步给从节点时，同时会把这些写命令写入复制积压缓冲区。一旦从节点发生网络闪断，再次和主节点恢复连接后，从节点就会从复制积压缓冲区中，读取断连期间主节点接收到的写命令，进而进行增量同步，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/ae/8f/aedc9b41b31860e283c5d140bdb3318f.jpg?wh=2609*1195\" alt=\"\"></p><p>看到这里你是不是感觉有些熟悉？没错，我们在<a href=\"https://time.geekbang.org/column/article/272852\">第6讲</a>时已经学过复制积压缓冲区了，只不过我当时告诉你的是它的英文名字repl_backlog_buffer。所以这一讲，我们从缓冲区溢出的角度再来回顾下两个重点：复制积压缓冲区溢出的影响，以及如何应对复制积压缓冲区的溢出问题。</p><p>首先，复制积压缓冲区是一个大小有限的环形缓冲区。当主节点把复制积压缓冲区写满后，会覆盖缓冲区中的旧命令数据。如果从节点还没有同步这些旧命令数据，就会造成主从节点间重新开始执行全量复制。</p><p>其次，为了应对复制积压缓冲区的溢出问题，我们可以调整复制积压缓冲区的大小，也就是设置repl_backlog_size这个参数的值。具体的调整依据，你可以再看下<a href=\"https://time.geekbang.org/column/article/272852\">第6讲</a>中提供的repl_backlog_size大小的计算依据。</p><h2>小结</h2><p>这节课，我们一起学习了Redis中使用的缓冲区。使用缓冲区以后，当命令数据的接收方处理速度跟不上发送方的发送速度时，缓冲区可以避免命令数据的丢失。</p><p>按照缓冲区的用途，例如是用于客户端通信还是用于主从节点复制，我把缓冲区分成了客户端的输入和输出缓冲区，以及主从集群中主节点上的复制缓冲区和复制积压缓冲区。这样学习的好处是，你可以很清楚Redis中到底有哪些地方使用了缓冲区，那么在排查问题的时候，就可以快速找到方向——从客户端和服务器端的通信过程以及主从节点的复制过程中分析原因。</p><p>现在，从缓冲区溢出对Redis的影响的角度，我再把这四个缓冲区分成两类做个总结。</p><ul>\n<li>缓冲区溢出导致网络连接关闭：普通客户端、订阅客户端，以及从节点客户端，它们使用的缓冲区，本质上都是Redis客户端和服务器端之间，或是主从节点之间为了传输命令数据而维护的。这些缓冲区一旦发生溢出，处理机制都是直接把客户端和服务器端的连接，或是主从节点间的连接关闭。网络连接关闭造成的直接影响，就是业务程序无法读写Redis，或者是主从节点全量同步失败，需要重新执行。</li>\n<li>缓冲区溢出导致命令数据丢失：主节点上的复制积压缓冲区属于环形缓冲区，一旦发生溢出，新写入的命令数据就会覆盖旧的命令数据，导致旧命令数据的丢失，进而导致主从节点重新进行全量复制。</li>\n</ul><p>从本质上看，缓冲区溢出，无非就是三个原因：命令数据发送过快过大；命令数据处理较慢；缓冲区空间过小。明白了这个，我们就可以有针对性地拿出应对策略了。</p><ul>\n<li>针对命令数据发送过快过大的问题，对于普通客户端来说可以避免bigkey，而对于复制缓冲区来说，就是避免过大的RDB文件。</li>\n<li>针对命令数据处理较慢的问题，解决方案就是减少Redis主线程上的阻塞操作，例如使用异步的删除操作。</li>\n<li>针对缓冲区空间过小的问题，解决方案就是使用client-output-buffer-limit配置项设置合理的输出缓冲区、复制缓冲区和复制积压缓冲区大小。当然，我们不要忘了，输入缓冲区的大小默认是固定的，我们无法通过配置来修改它，除非直接去修改Redis源码。</li>\n</ul><p>有了上面这些应对方法，我相信你在实际应用时，就可以避免缓冲区溢出带来的命令数据丢失、Redis崩溃的这些“惨案”了。</p><h2>每课一问</h2><p>最后，我给你提个小问题吧。</p><p>在这节课上，我们提到Redis采用了client-server架构，服务器端会为每个客户端维护输入、输出缓冲区。那么，应用程序和Redis实例交互时，应用程序中使用的客户端需要使用缓冲区吗？如果使用的话，对Redis的性能和内存使用会有影响吗？</p><p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得今天的内容对你有所帮助，也欢迎你分享给你的朋友或同事，我们下节课见。</p>","comments":[{"had_liked":false,"id":250791,"user_name":"Kaito","can_delete":false,"product_type":"c1","uid":1020042,"ip_address":"","ucode":"79775FA35A95F2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","comment_is_top":false,"comment_ctime":1601222769,"is_pvip":true,"discussion_count":37,"race_medal":0,"score":"1247141738609","product_id":100056701,"comment_content":"应用程序和Redis实例交互时，应用程序中使用的客户端需要使用缓冲区吗？如果使用的话，对Redis的性能和内存使用有什么影响？<br><br>客户端需要使用缓冲区，好处如下。<br><br>1、客户端和服务端交互，一般都会制定一个交互协议，客户端给服务端发数据时，都会按照这个协议把数据拼装好，然后写到客户端buffer中，客户端再一次性把buffer数据写到操作系统的网络缓冲区中，最后由操作系统发送给服务端。这样服务端就能从网络缓冲区中读取到一整块数据，然后按照协议解析数据即可。使用buffer发送数据会比一个个发送数据到服务端效率要高很多。<br><br>2、客户端还可以使用Pipeline批量发送命令到服务端，以提高访问性能。不使用Pipeline时，客户端是发送一个命令、读取一次结果。而使用Pipeline时，客户端先把一批命令暂存到buffer中，然后一次性把buffer中的命令发送到服务端，服务端处理多个命令后批量返回结果，这样做的好处是可以减少来回网络IO的次数，降低延迟，提高访问性能。当然，Redis服务端的buffer内存也会相应增长，可以控制好Pipeline命令的数量防止buffer超限。<br><br>缓冲区其实无处不在，客户端缓冲区、服务端缓冲区、操作系统网络缓冲区等等，凡是进行数据交互的两端，一般都会利用缓冲区来降低两端速度不匹配的影响。没有缓冲区，就好比一个个工人搬运货物到目的地，每个工人不仅成本高，而且运输效率低。而有了缓冲区后，相当于把这些货物先装到一个集装箱里，然后以集装箱为单位，开车运送到目的地，这样既降低了成本，又提高了运输效率。缓冲区相当于把需要运送的零散数据，进行一块块规整化，然后分批运输。<br><br>另外，关于Redis服务端为客户端分配的输出缓冲区，我想补充一点：主库上的从库输出缓冲区（slave client-output-buffer）是不计算在Redis使用的总内存中的，也就是说主从同步延迟，数据积压在主库上的从库输出缓冲区中，这个缓冲区内存占用变大，不会超过maxmemory导致淘汰数据。只有普通客户端和订阅客户端的输出缓冲区内存增长，超过maxmemory时，才会淘汰数据。","like_count":291,"discussions":[{"author":{"id":1001893,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","nickname":"小文同学","note":"","ucode":"48F2AEB989C12A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309371,"discussion_content":"“而使用Pipeline时，客户端先把一批命令暂存到buffer中，然后一次性把buffer中的命令发送到服务端，服务端处理多个命令后批量返回结果，这样做的好处是可以减少来回网络IO的次数，降低延迟，提高访问性能。当然，Redis服务端的buffer内存也会相应增长，可以控制好Pipeline命令的数量防止buffer超限。” \n谢谢提点，在不了解 Redis 原理，我还真的是没考虑过 pipeline 的过度使用会导致 buffer 缓存超限。","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1601273790,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1784022,"avatar":"","nickname":"pippin","note":"","ucode":"F7619FCE24D481","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321027,"discussion_content":"主库上的从库输出缓冲区（slave client-output-buffer）这个是不是主库和从库断开了链接，这个缓冲区就会被释放。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1604535032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1784022,"avatar":"","nickname":"pippin","note":"","ucode":"F7619FCE24D481","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321037,"discussion_content":"是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604536131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":321027,"ip_address":""},"score":321037,"extra":""},{"author":{"id":1148422,"avatar":"https://static001.geekbang.org/account/avatar/00/11/86/06/72b01bb7.jpg","nickname":"美美","note":"","ucode":"44CC95C45AF345","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":334815,"discussion_content":"那客户端什么时候能再次连呢？是自动重连还是有随机等待重呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607997504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":321037,"ip_address":""},"score":334815,"extra":""},{"author":{"id":1336951,"avatar":"https://static001.geekbang.org/account/avatar/00/14/66/77/194ba21d.jpg","nickname":"lzh","note":"","ucode":"C3D83DF4230109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1148422,"avatar":"https://static001.geekbang.org/account/avatar/00/11/86/06/72b01bb7.jpg","nickname":"美美","note":"","ucode":"44CC95C45AF345","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357628,"discussion_content":"这个取决业务代码怎么写的吧……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615823755,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":334815,"ip_address":""},"score":357628,"extra":""}]},{"author":{"id":1046714,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","nickname":"约书亚","note":"","ucode":"81EA27ADD9EC1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346746,"discussion_content":"之前一直以为slave的输出缓冲区也算进maxmemory中，不过我更相信你的结论。\nrepl_backlog应该算进maxmemory中吧？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1612056753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1046714,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","nickname":"约书亚","note":"","ucode":"81EA27ADD9EC1A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346769,"discussion_content":"repl_backlog算。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612060351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":346746,"ip_address":""},"score":346769,"extra":""}]},{"author":{"id":1170843,"avatar":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","nickname":"yyl","note":"","ucode":"1741DACDFCA9AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327689,"discussion_content":"pipeline的使用应该也存在缓冲区溢出的风险吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605915227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1170843,"avatar":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","nickname":"yyl","note":"","ucode":"1741DACDFCA9AF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327695,"discussion_content":"存在，所以pipeline也不能过大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605919117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":327689,"ip_address":""},"score":327695,"extra":""},{"author":{"id":1780797,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/2c/3d/0bd58aa4.jpg","nickname":"Em","note":"","ucode":"32012A5C603C8A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1170843,"avatar":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","nickname":"yyl","note":"","ucode":"1741DACDFCA9AF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577574,"discussion_content":"pipeline肯定是增大缓冲区溢出风险啊....  节省网络io的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656210697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":327689,"ip_address":""},"score":577574,"extra":""}]},{"author":{"id":1393004,"avatar":"https://static001.geekbang.org/account/avatar/00/15/41/6c/687c5dfb.jpg","nickname":"叶子。","note":"","ucode":"3EF2CC36F0D09A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309370,"discussion_content":"大佬 可否讲讲数据淘汰和之前的swap之间是啥关系啊？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1601273528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1001893,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","nickname":"小文同学","note":"","ucode":"48F2AEB989C12A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1393004,"avatar":"https://static001.geekbang.org/account/avatar/00/15/41/6c/687c5dfb.jpg","nickname":"叶子。","note":"","ucode":"3EF2CC36F0D09A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309372,"discussion_content":"我来尝试解释一下：\nswap 是操作系统层面的功能。操作系统会先 进程 提供一个虚拟内存，在虚拟内存里，64bit的系统总，可以有 2^64的寻址空间。也就是进程可以有 2^64 的内存。但实际上物理主机一般只有16G，为了保证给进程的 2^64 空间的承诺，这个时候就有一部分的数据需要被交换到磁盘。这个过程就是 swap，因为涉及到磁盘 I/O ，我们会尽量避免使用 swap ，以免进程性能低下。详细可以参考《深入理解计算机系统》虚拟内存篇章。\n\n数据淘汰，则是 Redis 自身的设置。譬如说设置到 4GB，则 Redis 数据达到 4GB 时，就会触发数据淘汰机制，保证进程使用的不会超限。\n\n简而言之，swap 是操作系统的概念，为了虚拟内存的承诺；数据淘汰是 Redis 自己的配置，为了限制自己的内存消耗。","likes_number":21,"is_delete":false,"is_hidden":false,"ctime":1601274216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":309370,"ip_address":""},"score":309372,"extra":""}]},{"author":{"id":1314995,"avatar":"https://static001.geekbang.org/account/avatar/00/14/10/b3/9492c0f3.jpg","nickname":"daoguang","note":"","ucode":"C56DA16DCA2D64","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591926,"discussion_content":"&#34;我想补充一点：主库上的从库输出缓冲区（slave client-output-buffer）是不计算在Redis使用的总内存中的，也就是说主从同步延迟，数据积压在主库上的从库输出缓冲区中，这个缓冲区内存占用变大，不会超过maxmemory导致淘汰数据。只有普通客户端和订阅客户端的输出缓冲区内存增长，超过maxmemory时，才会淘汰数据。&#34;\n\n我不知道你说的版本，我们线上测试下来，当做bgsave时，实例可用内存指标是伴随下降的。我们4和6版本都是这样。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666936029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3201606,"avatar":"","nickname":"Geek_c5eb91","note":"","ucode":"650C7D09442F51","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591055,"discussion_content":"大佬，牛逼，我看不懂。就是精彩","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666252874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江西"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2313353,"avatar":"https://static001.geekbang.org/account/avatar/00/23/4c/89/82a3ee04.jpg","nickname":"going","note":"","ucode":"3AA83F9B07BE8B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583527,"discussion_content":"maxmemory指的是服务端内存占用吗，不是还有REDIS存储的数据部分吗？缓冲区的大小是怎么能超过maxmemory的？是在这个期间发生了swap吗，所有存储的数据都置换到磁盘中了？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660181991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2184325,"avatar":"https://static001.geekbang.org/account/avatar/00/21/54/85/ab5148ce.jpg","nickname":"duckman","note":"","ucode":"0184C26C4B6C1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561935,"discussion_content":"所以可以确定的是：如果客户端处理不及时，redis服务端的client-output-buffer就会被迫积攒数据。如果client-output-buffer已满，但是redis服务端所执行的命令(如: keys *)还没有完成，那么redis此时会“报错”？然后终止执行？。 redis 制定的 RESP 协议是一个 “数据协议”，本身并不含 控制 的部分。所以 控制报文发送速率 还是 4层的TCP在做。由此，如果客户端处理不及时，那么redis服务端也会受很大的影响。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649749917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2649276,"avatar":"https://static001.geekbang.org/account/avatar/00/28/6c/bc/f751786b.jpg","nickname":"Leo","note":"","ucode":"CEBAD9CDCFC2A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559110,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648611949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1415619,"avatar":"https://static001.geekbang.org/account/avatar/00/15/99/c3/e4f408d4.jpg","nickname":"陌兮","note":"","ucode":"00CE47CAECD5CD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553544,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645960087,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1542586,"avatar":"https://static001.geekbang.org/account/avatar/00/17/89/ba/009ee13c.jpg","nickname":"霍霍","note":"","ucode":"A483D42AD7F72D","race_medal":2,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387925,"discussion_content":"跟着老师加上开神，事半功倍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628498898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377358,"discussion_content":"应用程序的客户端通常是不需要缓冲区 因为往往我们会用池化技术来缓存连接。我们通常更关注请求的延迟 而不是命令的缓冲。因为redis使用场景大多数是低时延而不是高吞吐。\n看了下jedis处理 ：\n1. 普通连接是当场生成一个outputstream 这显然是阻塞型的\n2.clusterPool 这一步取的是池里的连接 也没有缓存\n3.只有显式使用pipelined才会缓存命令","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622613538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377366,"discussion_content":"别只看应用层，再往下挖一层看看？把数据通过网络发出去，不会一个字节一个字节发吧？","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1622617698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":377358,"ip_address":""},"score":377366,"extra":""},{"author":{"id":2105175,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/40ab8h1zbSUZmzxARyicDuXECYwtQNDd9jxAbys5LMnVLJMmibTCHd1icrRZMnMSvTJ27UdITA0439hAaVIxcOkGQ/132","nickname":"Geek_72b9a7","note":"","ucode":"4C26B79F9F15A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":388430,"discussion_content":"缓存确实无处不在","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628760777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":377366,"ip_address":""},"score":388430,"extra":""},{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560605,"discussion_content":"补充：\nhttps://time.geekbang.org/column/article/310347\n假设单个实例每秒能支撑 8 万请求操作（8 万 QPS），每个主实例配置 1 个从实例，那么，400~ 500 个实例可支持 1600 万~2000 万 QPS（200/250 个主实例 *8 万 QPS=1600/2000 万 QPS），这个吞吐量性能可以满足不少业务应用的需求。\n\n备注：\n个人没有做过测试，或者看到其他权威测试数据，生产环境中没有看过相关监控数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649403257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":377358,"ip_address":""},"score":560605,"extra":""}]},{"author":{"id":1415619,"avatar":"https://static001.geekbang.org/account/avatar/00/15/99/c3/e4f408d4.jpg","nickname":"陌兮","note":"","ucode":"00CE47CAECD5CD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359897,"discussion_content":"大佬，请问这样的话，是不是会存在redis还没有到maxmemory的限制就出现OOM的可能？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616323626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1929712,"avatar":"","nickname":"Geek_aa296b","note":"","ucode":"056E035092C3E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334770,"discussion_content":"各位大牛，是有额外的线程来处理输入输出缓冲区吗，否则，是主线程处理的话，主线程阻塞的时候，客户端的数据是如何到输入缓冲区的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607962974,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1977474,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/2c/82/98e2b82a.jpg","nickname":"Reborn 2.0","note":"","ucode":"BA506E7455D91C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324306,"discussion_content":"你好, 我想问一下复制缓冲区(replication_buffer)在全量复制完成之后命令也同步完了还会存在么?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605089309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":7,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1977474,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/2c/82/98e2b82a.jpg","nickname":"Reborn 2.0","note":"","ucode":"BA506E7455D91C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324314,"discussion_content":"存在，全量和增量同步都用这个buffer。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1605090617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":324306,"ip_address":""},"score":324314,"extra":""},{"author":{"id":1602239,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKyobcyicicCQoldZofsS36xrjA2R2hk2F89pu1hCqwjlRaRG4xKkgCicZibEVdOwpfN5rWjEchrsxicSQ/132","nickname":"Geek_e8d55e","note":"","ucode":"5F13626B0E1E45","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":336410,"discussion_content":"增量同步时，增量数据是在复制积压缓冲区中，那难道是先从复制积压缓冲区复制到复制缓冲区，然后再发送给从库？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608565769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":324314,"ip_address":""},"score":336410,"extra":""},{"author":{"id":1346215,"avatar":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","nickname":"William","note":"","ucode":"55F5D9DEE485B1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1602239,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKyobcyicicCQoldZofsS36xrjA2R2hk2F89pu1hCqwjlRaRG4xKkgCicZibEVdOwpfN5rWjEchrsxicSQ/132","nickname":"Geek_e8d55e","note":"","ucode":"5F13626B0E1E45","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348320,"discussion_content":"同样有此疑问。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612512122,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":336410,"ip_address":""},"score":348320,"extra":""}]},{"author":{"id":1397058,"avatar":"https://static001.geekbang.org/account/avatar/00/15/51/42/47808b22.jpg","nickname":"HALOXIAO","note":"","ucode":"8EC17EC85EF2D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":317905,"discussion_content":"有一些想问的，既然它是给每个客户端一个buffer，那么应该只有一次性发送超出它buffer的数据的情况下才会发生溢出吧，不然服务器处理的时候客户端不应该是一直等待的么，那么这种情况应该是不会发生缓冲区溢出吧?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603615248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2911084,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/6b/6c/3e80afaf.jpg","nickname":"HappyHasson","note":"","ucode":"B84CC43E349CFA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1397058,"avatar":"https://static001.geekbang.org/account/avatar/00/15/51/42/47808b22.jpg","nickname":"HALOXIAO","note":"","ucode":"8EC17EC85EF2D4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555340,"discussion_content":"一个客户端有多个连接，这些连接可以同时发消息","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646876820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":317905,"ip_address":""},"score":555340,"extra":""}]},{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"一步","note":"","ucode":"73CEA468CE70C3","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":313242,"discussion_content":"请教个问题啊：对于每个客户端连接的输入缓冲区的大小是在链接建立的时候就分配好的吗？ 如果是，那么 redis 服务端是怎么知道该给这个客户端连接分配多少输入缓冲区的大小呢？ ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603010516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1589952,"avatar":"https://static001.geekbang.org/account/avatar/00/18/42/c0/cdd5346c.jpg","nickname":"柱星同学","note":"","ucode":"7417F0B1834353","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311847,"discussion_content":"解释得非常通透易懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602505534,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":255073,"user_name":"馒头超人","can_delete":false,"product_type":"c1","uid":1032089,"ip_address":"","ucode":"68E430EFD12B9F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bf/99/0681e343.jpg","comment_is_top":false,"comment_ctime":1603262644,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"53142870196","product_id":100056701,"comment_content":"有几个问题希望老师帮忙解答一下<br>1、TCP已经有读写缓冲区，redis为何还要单独维护读写缓冲区，两者的作用看起来是一致的<br>2、缓冲区类似队列，读写变成异步，主线程跟缓冲区交互，是什么线程负责缓冲区跟tcp的数据同步<br>","like_count":13,"discussions":[{"author":{"id":1043475,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","nickname":"neohope","note":"","ucode":"C0268F6E7E2B6E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347875,"discussion_content":"1、TCP的缓冲区是运行在Ring0内核态，这部分是内核和网卡驱动控制的，应用程序控制不到，而内核和网卡驱动，是不会关心发送接收了什么内容的，更不会有应用层面的收发控制策略。2、而redis的缓冲区运行在Ring3，只关心应用层需要做什么策略，是不太关心TCP层面做了什么东西的。3、redis数据与TCP发生读写，是通过内核来调度的，网卡收到数据后，发送中断告知内核数据来了，内核将数据搬送到Redis的应用层内存，然后告诉redis数据来了，redis就收到通知，可以读取数据了。","likes_number":39,"is_delete":false,"is_hidden":false,"ctime":1612348949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1781893,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/30/85/14c2f16c.jpg","nickname":"石小","note":"","ucode":"4258C686F289A6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324142,"discussion_content":"tcp的缓冲区是系统内核维护的，负责tcp的可靠传输，确认机制，窗口大小，流量控制和拥塞控制等都需要缓冲区。redis的缓冲区是redis自己用，用于client-server机制，就是老师讲的。redis主线程发送数据时就是把自己缓存区的数据拷贝到内核的tcp缓冲区，之后由内核负责发送数据到网卡，内核是通过epoll机制知道有数据要发送的。","likes_number":23,"is_delete":false,"is_hidden":false,"ctime":1605061294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1631251,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/44U5iamHyAHCkv45SmYovu8ZXd2GLsEB3osiaIQL5yzkYJKbCISW2SIXZndzyibmN1ST44Goz0g2vA5XZ9VyYX9YA/132","nickname":"ost111","note":"","ucode":"C30E8799448371","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376806,"discussion_content":"tcp 的缓冲区面向的是网络的不可靠，redis 的缓冲区面向的是程序处理性能的不可靠","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1622359025,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1297630,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","nickname":"剑八","note":"","ucode":"0A09F41DB8A4E7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383489,"discussion_content":"两者解决的虽然都是速率不一致，缓冲问题。\ntcp缓存解决的是客户端和服务端的网络以及处理速度问题，这个更偏向于网络速率缓冲。这部分是一个全局的配置，修改后对于这台宿主机上的应用都会生效。\nredis的缓存则是解决redis服务器的处理速度与客户端的发送速度的问题。这部分redis应用是可以修改的。可以只针对这个redis应用进度修改。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1626127438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1583740,"avatar":"https://static001.geekbang.org/account/avatar/00/18/2a/7c/0d6a87c4.jpg","nickname":"dandy","note":"","ucode":"5EE976FCBD9215","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391606,"discussion_content":"其实不然，正常多线程的服务处理，都会有个队列，来保存接收的套接字。之后交给work线程来处理。所以redis一样也会，创建一个client保存客户端的状态信息，之后放到list队列处理","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1630549104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2420294,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ee/46/7d65ae37.jpg","nickname":"木几丶","note":"","ucode":"FFDB958DA64F8C","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585494,"discussion_content":"我来补充下 : )\n1、其他朋友说了很多了，我觉得根本问题就是tcp缓冲区是内核态，Redis是用户态\n2、6.0以前是还是主线程，6.0以后如果开启了多IO线程，那就是IO线程+主线程。\n6.0以前，主线程会反复循环地执行以下几个步骤：\n1、将写缓冲区写到socket（如果有）\n2、epoll_wait等待事件\n3、读数据到缓冲区\n4、处理请求\n5、写数据到缓冲区\n6.0以后也是这样的事件循环，只是读数据到缓冲区和写数据到socket由额外的IO线程和主线程共同完成","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661599371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"福建"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1929712,"avatar":"","nickname":"Geek_aa296b","note":"","ucode":"056E035092C3E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334768,"discussion_content":"这个问题怎么理解呢，我也很困惑，是有额外的线程吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607962729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2184325,"avatar":"https://static001.geekbang.org/account/avatar/00/21/54/85/ab5148ce.jpg","nickname":"duckman","note":"","ucode":"0184C26C4B6C1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1929712,"avatar":"","nickname":"Geek_aa296b","note":"","ucode":"056E035092C3E6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561938,"discussion_content":"不是额外的线程在做这件事，而是周期性的刷。管他是刷磁盘，还是刷到socket中。反正都是 FD(file descriptor)，都是调用 write(系统调用)，都是可以被 epoll_wait IO multiplexing 管理的。所以这样一看，就统一了，干净了许多。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649750334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":334768,"ip_address":""},"score":561938,"extra":""}]}]},{"had_liked":false,"id":267970,"user_name":"Geek_aa296b","can_delete":false,"product_type":"c1","uid":1929712,"ip_address":"","ucode":"056E035092C3E6","user_header":"","comment_is_top":false,"comment_ctime":1608013081,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27377816857","product_id":100056701,"comment_content":"各位大牛，是有额外的线程来处理 输入输出缓冲区吗，否则，是主线程处理的话，主线程阻塞的时候，客户端的数据是如何到输入缓冲区的？","like_count":7,"discussions":[{"author":{"id":1196293,"avatar":"https://static001.geekbang.org/account/avatar/00/12/41/05/5ba603f2.jpg","nickname":"小李子","note":"","ucode":"C5593E33CA6F4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340993,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610251135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":306874,"user_name":"Geek_72b9a7","can_delete":false,"product_type":"c1","uid":2105175,"ip_address":"","ucode":"4C26B79F9F15A9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/40ab8h1zbSUZmzxARyicDuXECYwtQNDd9jxAbys5LMnVLJMmibTCHd1icrRZMnMSvTJ27UdITA0439hAaVIxcOkGQ/132","comment_is_top":false,"comment_ctime":1628759930,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14513661818","product_id":100056701,"comment_content":"这个坑踩得很深，分享一个计算repl大小的脚本。https:&#47;&#47;blog.csdn.net&#47;MyySophia&#47;article&#47;details&#47;107126459","like_count":3},{"had_liked":false,"id":282713,"user_name":"张凯","can_delete":false,"product_type":"c1","uid":1136254,"ip_address":"","ucode":"27566AD22CCAA1","user_header":"https://static001.geekbang.org/account/avatar/00/11/56/7e/64730c47.jpg","comment_is_top":false,"comment_ctime":1615373013,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10205307605","product_id":100056701,"comment_content":"qbuf=0 qbuf-free=0 这是什么情况导致的？","like_count":3},{"had_liked":false,"id":260725,"user_name":"Reborn 2.0","can_delete":false,"product_type":"c1","uid":1977474,"ip_address":"","ucode":"BA506E7455D91C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/2c/82/98e2b82a.jpg","comment_is_top":false,"comment_ctime":1605089323,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10195023915","product_id":100056701,"comment_content":"老师, 我想问一下复制缓冲区(replication_buffer)在全量复制完成之后命令也同步完了还会存在么?","like_count":2,"discussions":[{"author":{"id":1016575,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/82/ff/00e7614e.jpg","nickname":"robyy","note":"","ucode":"773337C9942A7F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349846,"discussion_content":"存在，增量和全量同步都是用这个缓冲区给从库发送数据/命令","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1613575710,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1977474,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/2c/82/98e2b82a.jpg","nickname":"Reborn 2.0","note":"","ucode":"BA506E7455D91C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1016575,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/82/ff/00e7614e.jpg","nickname":"robyy","note":"","ucode":"773337C9942A7F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351287,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614228627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":349846,"ip_address":""},"score":351287,"extra":""}]}]},{"had_liked":false,"id":285515,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1616853532,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"5911820828","product_id":100056701,"comment_content":"Redis 原本就是当做缓存在用，然后它又有自己的缓冲区，果然是应了那句话，在计算机领域，没有什么问题是加一层缓存解决不了的。<br><br>直接跳到课后问题，应用程序和 Redis 实例交互时，应用程序客户端应该也会使用缓冲区，对于 Redis 的性能和内存同样会有影响。如果不想造成缓冲区溢出那么也需要设置合理的缓冲区参数，以及设置合理的读写速率。<br><br>课后题的解答主要靠课代表 @Kaito","like_count":1},{"had_liked":false,"id":255068,"user_name":"馒头超人","can_delete":false,"product_type":"c1","uid":1032089,"ip_address":"","ucode":"68E430EFD12B9F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bf/99/0681e343.jpg","comment_is_top":false,"comment_ctime":1603262149,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5898229445","product_id":100056701,"comment_content":"有几个疑问希望老师帮忙解答：<br>1、tcp已经有读写缓冲区， redis 为何还要再单独维护读写缓冲区，两者的作用看起来是一样的","like_count":1,"discussions":[{"author":{"id":2675954,"avatar":"https://static001.geekbang.org/account/avatar/00/28/d4/f2/3c0bfa0e.jpg","nickname":"赴","note":"","ucode":"D47B3179BE3950","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391631,"discussion_content":"redis缓冲区算是应用程序缓冲区，tcp算是内核缓存区，本质还是很大区别的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630558939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1246178,"avatar":"https://static001.geekbang.org/account/avatar/00/13/03/e2/5768d26e.jpg","nickname":"inrtyx","note":"","ucode":"81CD18FF34ABAB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380204,"discussion_content":"这位同学一看就是网宿的架构师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624372509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2326907,"avatar":"","nickname":"Geek_bbd494","note":"","ucode":"148EA9397207A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343007,"discussion_content":"redis维护缓冲区有减少网络请求的功效，批量传输的效率更高","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610898770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":251011,"user_name":"yeek","can_delete":false,"product_type":"c1","uid":1020629,"ip_address":"","ucode":"A1C71023113CB9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/d5/699384a0.jpg","comment_is_top":false,"comment_ctime":1601307335,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"5896274631","product_id":100056701,"comment_content":"服务器端处理请求的速度过慢，例如，Redis 主线程出现了间歇性阻塞，无法及时处理正常发送的请求，导致客户端发送的请求在缓冲区越积越多。<br><br><br>这句话有点没理解，redis大部分请求是阻塞的，对客户端来说需要等待服务器的相应结果，虽然相应结果不一定有用，但这样的情况，redis服务端如果处理请求较慢，那么客户端输入缓冲区应该是当前请求一直在hold吧？服务器处理慢会导致等待的客户端变多，整体积压的输入缓冲变多，但对单个缓冲区来说，溢出应该不是主要的吧？<br><br>不知道上述理解是否正确……","like_count":1,"discussions":[{"author":{"id":1196293,"avatar":"https://static001.geekbang.org/account/avatar/00/12/41/05/5ba603f2.jpg","nickname":"小李子","note":"","ucode":"C5593E33CA6F4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340992,"discussion_content":"如果单个客户端，多线程并发请求呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610251048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1113737,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","nickname":"xuanyuan","note":"","ucode":"1EC79B9372868F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339388,"discussion_content":"我的理解也是1、对于 bigkey 是客户端一边发送，服务端一边接收，流式处理，如果服务端阻塞，客户端就会缓存大量数据导致溢出，如果服务端没有阻塞，客户端就不会溢出。2、多个客户端导致输入缓冲区溢出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609655456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1589208,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTITcwicqBDYzXtLibUtian172tPs7rJpqG1Vab4oGjnguA9ziaYjDCILSGaS6qRiakvRdUEhdmSG0BGPKw/132","nickname":"大饶Raysir","note":"","ucode":"0AFA191420A30D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312552,"discussion_content":"这一点我也不理解，单个缓冲区只阻塞了当前请求的话，应该不会出现单个输入缓冲区积压的情况。按照老师的描述，感觉只有\n1. 当主从数据同步的时候，主节点无法处理写请求才会在输入缓冲区里积压写请求\n2.操作bigkey时，输入的命令数据大小太大，导致输入缓存区积压\n其他还有什么场景会出现输入缓冲区积压呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602732017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1436839,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ec/a7/7d44c655.jpg","nickname":"snailshen","note":"","ucode":"C4875C476649B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309654,"discussion_content":"这个我也有点没理解，抛开阻塞不说，如果客户端传过来一个大key，大于32k，这个时候客户端缓冲区流溢出了吗？还有如果不溢出，那么报文不完整，redis如何处理这个请求呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601379717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342681,"user_name":"Geek_0bba55","can_delete":false,"product_type":"c1","uid":2088137,"ip_address":"","ucode":"3B647E1EB3C707","user_header":"","comment_is_top":false,"comment_ctime":1650418149,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1650418149","product_id":100056701,"comment_content":"既然有了复制缓冲区，为什么要加一个复制积压缓冲区？<br>为什么复制积压缓冲区溢出，要重新全量同步，不从AOF增加读取，或者用磁盘保存增量命令","like_count":0,"discussions":[{"author":{"id":2689761,"avatar":"http://thirdwx.qlogo.cn/mmopen/PiajxSqBRaEJLDMld4aYzzV2PLM5pcxScBGUwERs3B6BWUq1pAZlSgSGPOe6nTchWwO6FQweVHdvGC0QicT5Fc2g/132","nickname":"liujunsheng","note":"","ucode":"F433DEFBD4EBD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586971,"discussion_content":"replication buffer（复制缓冲区）\nRedis和客户端通信也好，和从库通信也好，Redis都需要给分配一个 内存buffer进行数据交互，客户端是一个client，从库也是一个client，我们每个client连上Redis后，Redis都会分配一个client buffer，所有数据交互都是通过这个buffer进行的：Redis先把数据写到这个buffer中，然后再把buffer中的数据发到client socket中再通过网络发送出去，这样就完成了数据交互。所以主从在增量同步时，从库作为一个client，也会分配一个buffer，只不过这个buffer专门用来传播用户的写命令到从库，保证主从数据一致，通常把它叫做replication buffer。\nreplication buffer用于主从节点间数据的批量交互。所有主从同步的数据都是要经过这个buffer的，无论全量同步还是增量同步。主节点为各个从节点分别创建一个缓冲区，由于各个从节点的处理能力差异，各个缓冲区数据可能不同。\n\nrepl_backlog_buffer（复制积压缓冲区）\n它是为了从库断开之后，如何找到主从差异数据而设计的环形缓冲区，从而避免全量同步带来的性能开销。如果从库断开时间太久，repl_backlog_buffer环形缓冲区被主库的写命令覆盖了，那么从库连上主库后只能乖乖地进行一次全量同步，所以repl_backlog_buffer配置尽量大一些，可以降低主从断开后全量同步的概率。而在repl_backlog_buffer中找主从差异的数据后，如何发给从库呢？这就用到了replication buffer。\nrepl_backlog_buffer用于主从间的增量同步。主节点只有一个repl_backlog_buffer缓冲区，各个从节点的offset偏移量都是相对该缓冲区而言的。\nrepl_backlog_buffer这个缓冲只在主从重连时才起作用，在主从连接正常时，即使master覆盖了slave的数据也没关系，应为数据都在replication_buffer里，只要replication_buffer没溢出，等slave消费完了replication_buffer，slave_offset也追上去了，只有等到主从重连时才会用到repl_backlog_buffer做判断，正常情况下repl_backlog_buffer只是一直循环写。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1662633789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2420294,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ee/46/7d65ae37.jpg","nickname":"木几丶","note":"","ucode":"FFDB958DA64F8C","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585540,"discussion_content":"1、当出现断线重连，复制缓冲区没有历史数据，为了避免全量同步所以要复制积压缓冲区\n2、我个人认为有两个原因：\n    (1)  官方版Redis AOF中没有存offset，即使有，AOF rewrite以后也没了。\n    (2)  假设存了offset，在redis 7.0的multi AOF出来之前，要在AOF文件中找到offset的位置并将后续命令读到内存涉及到很多磁盘IO，不如直接将内存的数据发出去来得快\n\n实际上，百度在multi AOF出来以后就做了这方面优化，就是在AOF中存offset，断线重连时先从缓冲区同步，没有则从AOF同步，还是没有才是全量同步","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661670686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"福建"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325888,"user_name":"欢少の不忘初心","can_delete":false,"product_type":"c1","uid":2563344,"ip_address":"","ucode":"9A7ABCC07682C2","user_header":"https://static001.geekbang.org/account/avatar/00/27/1d/10/a73d63ba.jpg","comment_is_top":false,"comment_ctime":1639213864,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1639213864","product_id":100056701,"comment_content":"Redis的 输入输出缓冲区  在客户端还是服务端啊","like_count":0,"discussions":[{"author":{"id":2346917,"avatar":"https://static001.geekbang.org/account/avatar/00/23/cf/a5/5224b297.jpg","nickname":"cafe babe","note":"","ucode":"6205DF67AD86F8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581115,"discussion_content":"服务端啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658504341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307340,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1629036017,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629036017","product_id":100056701,"comment_content":"可以模仿Kafka那样,攒一波发送,减少交互,但如果需要即使消息处理的数据的话,缓冲可能误了大事","like_count":0},{"had_liked":false,"id":304399,"user_name":"Steven","can_delete":false,"product_type":"c1","uid":1253652,"ip_address":"","ucode":"3FE64459842015","user_header":"https://static001.geekbang.org/account/avatar/00/13/21/14/423a821f.jpg","comment_is_top":false,"comment_ctime":1627386982,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627386982","product_id":100056701,"comment_content":"老师这里“全量复制、增量复制”，“复制”容易造成误解，改为“同步”就好了。而且官方文档里就是”synchronization “。","like_count":0},{"had_liked":false,"id":301067,"user_name":"bigben","can_delete":false,"product_type":"c1","uid":1169313,"ip_address":"","ucode":"DBD15A6C8E2590","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJkeOAC8k7aPMfQZ4ickiavpfR9mTQs1wGhGtIicotzAoszE5qkLfFTabkDU2E39ovSgoibJ1IiaLXtGicg/132","comment_is_top":false,"comment_ctime":1625504105,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625504105","product_id":100056701,"comment_content":"客户端lettuce就有缓冲区吧","like_count":0},{"had_liked":false,"id":295827,"user_name":"凯文小猪","can_delete":false,"product_type":"c1","uid":1980201,"ip_address":"","ucode":"36D8AD0229547F","user_header":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","comment_is_top":false,"comment_ctime":1622613480,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622613480","product_id":100056701,"comment_content":"应用程序的客户端通常是不需要缓冲区 因为往往我们会用池化技术来缓存连接。我们通常更关注请求的延迟 而不是命令的缓冲。因为redis使用场景大多数是低时延而不是高吞吐。<br>看了下jedis处理 ：<br>1. 普通连接是当场生成一个outputstream 这显然是阻塞型的<br>2.clusterPool 这一步取的是池里的连接 也没有缓存<br>3.只有显式使用pipelined才会缓存命令","like_count":0},{"had_liked":false,"id":295406,"user_name":"悟空聊架构","can_delete":false,"product_type":"c1","uid":1123163,"ip_address":"","ucode":"C2F482A0CF8AF1","user_header":"https://static001.geekbang.org/account/avatar/00/11/23/5b/983408b9.jpg","comment_is_top":false,"comment_ctime":1622419654,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1622419654","product_id":100056701,"comment_content":"这篇讲解得很清晰，赞！","like_count":0},{"had_liked":false,"id":293231,"user_name":"HUNTER","can_delete":false,"product_type":"c1","uid":1114579,"ip_address":"","ucode":"184725E9ED0E2C","user_header":"https://static001.geekbang.org/account/avatar/00/11/01/d3/5cbaeb95.jpg","comment_is_top":false,"comment_ctime":1621298867,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621298867","product_id":100056701,"comment_content":"AOF缓冲区和AOF重写缓冲区会溢出吗，可以调整大小吗","like_count":0},{"had_liked":false,"id":289280,"user_name":"呼啦啦~","can_delete":false,"product_type":"c1","uid":1281850,"ip_address":"","ucode":"7E5BAB3E2BB37F","user_header":"https://static001.geekbang.org/account/avatar/00/13/8f/3a/b15e7392.jpg","comment_is_top":false,"comment_ctime":1618967584,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618967584","product_id":100056701,"comment_content":"redis负责IO和业务处理的线程，是同一个线程。怎么会有缓冲区的存在呢？<br><br>如果有缓冲区的存在，那么放数据进入缓冲区的，是一个线程，从缓冲区读取数据执行的，又是另一个线程了。不符合redis单线程的设计。<br>对redis缓冲区不是很理解，请指教。","like_count":0},{"had_liked":false,"id":274130,"user_name":"张天屹","can_delete":false,"product_type":"c1","uid":1477612,"ip_address":"","ucode":"8BD6BD6DCF0F4F","user_header":"https://static001.geekbang.org/account/avatar/00/16/8b/ec/dc03f5ad.jpg","comment_is_top":false,"comment_ctime":1610868519,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1610868519","product_id":100056701,"comment_content":"文中提到缓冲区溢出会丢失数据，真的会吗，redis应该是会直接断连客户端返回失败吧","like_count":0,"discussions":[{"author":{"id":1006735,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5c/8f/551b5624.jpg","nickname":"小可","note":"","ucode":"8834AF621FA67D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348114,"discussion_content":"既然都溢出了，当然是没有存下，丢失了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612429595,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253996,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1603010390,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1603010390","product_id":100056701,"comment_content":"对于每个客户端连接的输入缓冲区的大小是在链接建立的时候就分配好的吗？ 还是可以后面动态调节的？","like_count":0},{"had_liked":false,"id":252876,"user_name":"xueyuan","can_delete":false,"product_type":"c1","uid":1128121,"ip_address":"","ucode":"3DE20A723EBAFE","user_header":"https://static001.geekbang.org/account/avatar/00/11/36/b9/3b28f67c.jpg","comment_is_top":false,"comment_ctime":1602505306,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602505306","product_id":100056701,"comment_content":"使用pipline，减少client数目。","like_count":0},{"had_liked":false,"id":251126,"user_name":"无名小卒","can_delete":false,"product_type":"c1","uid":1315896,"ip_address":"","ucode":"795E6FB2708AA7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eovyv4gkXvhZdQuP5ibAibAuia1GxDJjImvq5qjSGtO7sfcK4uX9arwAMIZmOHAaHIMFdOJDjE9LZrtw/132","comment_is_top":false,"comment_ctime":1601370966,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601370966","product_id":100056701,"comment_content":"蒋老师的课程很深入，学到了很多底层redis知识，迫不及待的想看下面的章节，如果能更新快一点就更好了。催更啦😂！","like_count":0},{"had_liked":false,"id":251016,"user_name":"yeek","can_delete":false,"product_type":"c1","uid":1020629,"ip_address":"","ucode":"A1C71023113CB9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/d5/699384a0.jpg","comment_is_top":false,"comment_ctime":1601308230,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601308230","product_id":100056701,"comment_content":"从节点客户端输出缓冲区会用来传输rdb文件吗？如果会的话，该设置项的大小，是参考rdb文件大小吧？这可能是所有缓冲区中实际可能使用的最大缓冲区了","like_count":0},{"had_liked":false,"id":251015,"user_name":"yeek","can_delete":false,"product_type":"c1","uid":1020629,"ip_address":"","ucode":"A1C71023113CB9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/d5/699384a0.jpg","comment_is_top":false,"comment_ctime":1601307729,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601307729","product_id":100056701,"comment_content":"输出缓冲区，动态增加的部分，会产生内存碎片吗？何时回收呢？增加后会有机会缩小吗？","like_count":0},{"had_liked":false,"id":250974,"user_name":"脱缰的野马__","can_delete":false,"product_type":"c1","uid":1447569,"ip_address":"","ucode":"D5F993E7232C61","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/WtHCCMoLJ2DvzqQwPYZyj2RlN7eibTLMHDMTSO4xIKjfKR1Eh9L98AMkkZY7FmegWyGLahRQJ5ibPzeeFtfpeSow/132","comment_is_top":false,"comment_ctime":1601295806,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601295806","product_id":100056701,"comment_content":"老师你好，在讲主从全量复制的时候，如果发生复制缓冲区溢出会导致全量复制失败，这个失败是指全部失败还是指rdb文件剩余部分同步复制失败，因为我知道的是每次从节点连接上主节点时会把当前对rdb复制偏移量给到主节点，主节点再判断是否重新全量复制还是从收到的偏移量位置开始复制","like_count":0},{"had_liked":false,"id":250921,"user_name":"漫步oo0云端","can_delete":false,"product_type":"c1","uid":1427152,"ip_address":"","ucode":"4906095751D7B0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eppZl39m2knwLH6PIia5YQTOWSOTGhy8ZZAutUIrxKOYFCtLLLYb1OZvIVVLzL7Y8eglKFe4Sib9D7g/132","comment_is_top":false,"comment_ctime":1601282244,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601282244","product_id":100056701,"comment_content":"我发现redis2.8版本执行CLIENT LIST，没有 qbuf 和 qbuf-free 这两个值。","like_count":0}]}