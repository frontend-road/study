{"id":209494,"title":"01 | 使用了并发工具类库，线程安全就高枕无忧了吗？","content":"<p>你好，我是朱晔。作为课程的第一讲，我今天要和你聊聊使用并发工具类库相关的话题。</p><p>在代码审核讨论的时候，我们有时会听到有关线程安全和并发工具的一些片面的观点和结论，比如“把HashMap改为ConcurrentHashMap，就可以解决并发问题了呀”“要不我们试试无锁的CopyOnWriteArrayList吧，性能更好”。事实上，这些说法都不太准确。</p><p>的确，为了方便开发者进行多线程编程，现代编程语言会提供各种并发工具类。但如果我们没有充分了解它们的使用场景、解决的问题，以及最佳实践的话，盲目使用就可能会导致一些坑，小则损失性能，大则无法确保多线程情况下业务逻辑的正确性。</p><p>我需要先说明下，这里的并发工具类是指用来解决多线程环境下并发问题的工具类库。一般而言并发工具包括同步器和容器两大类，业务代码中使用并发容器的情况会多一些，我今天分享的例子也会侧重并发容器。</p><p>接下来，我们就看看在使用并发工具时，最常遇到哪些坑，以及如何解决、避免这些坑吧。</p><h2>没有意识到线程重用导致用户信息错乱的Bug</h2><p>之前有业务同学和我反馈，在生产上遇到一个诡异的问题，有时获取到的用户信息是别人的。查看代码后，我发现他使用了ThreadLocal来缓存获取到的用户信息。</p><!-- [[[read_end]]] --><p>我们知道，ThreadLocal适用于变量在线程间隔离，而在方法或类间共享的场景。如果用户信息的获取比较昂贵（比如从数据库查询用户信息），那么在ThreadLocal中缓存数据是比较合适的做法。但，这么做为什么会出现用户信息错乱的Bug呢？</p><p>我们看一个具体的案例吧。</p><p>使用Spring Boot创建一个Web应用程序，使用ThreadLocal存放一个Integer的值，来暂且代表需要在线程中保存的用户信息，这个值初始是null。在业务逻辑中，我先从ThreadLocal获取一次值，然后把外部传入的参数设置到ThreadLocal中，来模拟从当前上下文获取到用户信息的逻辑，随后再获取一次值，最后输出两次获得的值和线程名称。</p><pre><code>private static final ThreadLocal&lt;Integer&gt; currentUser = ThreadLocal.withInitial(() -&gt; null);\n\n\n@GetMapping(&quot;wrong&quot;)\npublic Map wrong(@RequestParam(&quot;userId&quot;) Integer userId) {\n    //设置用户信息之前先查询一次ThreadLocal中的用户信息\n    String before  = Thread.currentThread().getName() + &quot;:&quot; + currentUser.get();\n    //设置用户信息到ThreadLocal\n    currentUser.set(userId);\n    //设置用户信息之后再查询一次ThreadLocal中的用户信息\n    String after  = Thread.currentThread().getName() + &quot;:&quot; + currentUser.get();\n    //汇总输出两次查询结果\n    Map result = new HashMap();\n    result.put(&quot;before&quot;, before);\n    result.put(&quot;after&quot;, after);\n    return result;\n}\n\n</code></pre><p>按理说，在设置用户信息之前第一次获取的值始终应该是null，但我们要意识到，程序运行在Tomcat中，执行程序的线程是Tomcat的工作线程，而Tomcat的工作线程是基于线程池的。</p><p><strong>顾名思义，线程池会重用固定的几个线程，一旦线程重用，那么很可能首次从ThreadLocal获取的值是之前其他用户的请求遗留的值。这时，ThreadLocal中的用户信息就是其他用户的信息。</strong></p><p>为了更快地重现这个问题，我在配置文件中设置一下Tomcat的参数，把工作线程池最大线程数设置为1，这样始终是同一个线程在处理请求：</p><pre><code>server.tomcat.max-threads=1\n</code></pre><p>运行程序后先让用户1来请求接口，可以看到第一和第二次获取到用户ID分别是null和1，符合预期：<br>\n<img src=\"https://static001.geekbang.org/resource/image/4b/30/4b8f38415d03423132c7a3608ebe2430.png?wh=1038*330\" alt=\"\"></p><p>随后用户2来请求接口，这次就出现了Bug，第一和第二次获取到用户ID分别是1和2，显然第一次获取到了用户1的信息，原因就是Tomcat的线程池重用了线程。从图中可以看到，两次请求的线程都是同一个线程：http-nio-8080-exec-1。</p><p><img src=\"https://static001.geekbang.org/resource/image/a9/db/a9ccd42716d807687b3acff9a0baf2db.png?wh=1042*332\" alt=\"\"></p><p>这个例子告诉我们，在写业务代码时，首先要理解代码会跑在什么线程上：</p><ul>\n<li>我们可能会抱怨学多线程没用，因为代码里没有开启使用多线程。但其实，可能只是我们没有意识到，在Tomcat这种Web服务器下跑的业务代码，本来就运行在一个多线程环境（否则接口也不可能支持这么高的并发），<strong>并不能认为没有显式开启多线程就不会有线程安全问题</strong>。</li>\n<li>因为线程的创建比较昂贵，所以Web服务器往往会使用线程池来处理请求，这就意味着线程会被重用。这时，<strong>使用类似ThreadLocal工具来存放一些数据时，需要特别注意在代码运行完后，显式地去清空设置的数据</strong>。如果在代码中使用了自定义的线程池，也同样会遇到这个问题。</li>\n</ul><p>理解了这个知识点后，我们修正这段代码的方案是，在代码的finally代码块中，显式清除ThreadLocal中的数据。这样一来，新的请求过来即使使用了之前的线程也不会获取到错误的用户信息了。修正后的代码如下：</p><pre><code>@GetMapping(&quot;right&quot;)\npublic Map right(@RequestParam(&quot;userId&quot;) Integer userId) {\n    String before  = Thread.currentThread().getName() + &quot;:&quot; + currentUser.get();\n    currentUser.set(userId);\n    try {\n        String after = Thread.currentThread().getName() + &quot;:&quot; + currentUser.get();\n        Map result = new HashMap();\n        result.put(&quot;before&quot;, before);\n        result.put(&quot;after&quot;, after);\n        return result;\n    } finally {\n        //在finally代码块中删除ThreadLocal中的数据，确保数据不串\n        currentUser.remove();\n    }\n}\n</code></pre><p>重新运行程序可以验证，再也不会出现第一次查询用户信息查询到之前用户请求的Bug：</p><p><img src=\"https://static001.geekbang.org/resource/image/0d/cc/0dfe40fca441b58d491fc799d120a7cc.png?wh=1028*332\" alt=\"\"></p><p>ThreadLocal是利用独占资源的方式，来解决线程安全问题，那如果我们确实需要有资源在线程之间共享，应该怎么办呢？这时，我们可能就需要用到线程安全的容器了。</p><h2>使用了线程安全的并发工具，并不代表解决了所有线程安全问题</h2><p>JDK 1.5后推出的ConcurrentHashMap，是一个高性能的线程安全的哈希表容器。“线程安全”这四个字特别容易让人误解，因为<strong>ConcurrentHashMap只能保证提供的原子性读写操作是线程安全的。</strong></p><p>我在相当多的业务代码中看到过这个误区，比如下面这个场景。有一个含900个元素的Map，现在再补充100个元素进去，这个补充操作由10个线程并发进行。开发人员误以为使用了ConcurrentHashMap就不会有线程安全问题，于是不加思索地写出了下面的代码：在每一个线程的代码逻辑中先通过size方法拿到当前元素数量，计算ConcurrentHashMap目前还需要补充多少元素，并在日志中输出了这个值，然后通过putAll方法把缺少的元素添加进去。</p><p>为方便观察问题，我们输出了这个Map一开始和最后的元素个数。</p><pre><code>//线程个数\nprivate static int THREAD_COUNT = 10;\n//总元素数量\nprivate static int ITEM_COUNT = 1000;\n\n//帮助方法，用来获得一个指定元素数量模拟数据的ConcurrentHashMap\nprivate ConcurrentHashMap&lt;String, Long&gt; getData(int count) {\n    return LongStream.rangeClosed(1, count)\n            .boxed()\n            .collect(Collectors.toConcurrentMap(i -&gt; UUID.randomUUID().toString(), Function.identity(),\n                    (o1, o2) -&gt; o1, ConcurrentHashMap::new));\n}\n\n@GetMapping(&quot;wrong&quot;)\npublic String wrong() throws InterruptedException {\n    ConcurrentHashMap&lt;String, Long&gt; concurrentHashMap = getData(ITEM_COUNT - 100);\n    //初始900个元素\n    log.info(&quot;init size:{}&quot;, concurrentHashMap.size());\n\n    ForkJoinPool forkJoinPool = new ForkJoinPool(THREAD_COUNT);\n    //使用线程池并发处理逻辑\n    forkJoinPool.execute(() -&gt; IntStream.rangeClosed(1, 10).parallel().forEach(i -&gt; {\n        //查询还需要补充多少个元素\n        int gap = ITEM_COUNT - concurrentHashMap.size();\n        log.info(&quot;gap size:{}&quot;, gap);\n        //补充元素\n        concurrentHashMap.putAll(getData(gap));\n    }));\n    //等待所有任务完成\n    forkJoinPool.shutdown();\n    forkJoinPool.awaitTermination(1, TimeUnit.HOURS);\n    //最后元素个数会是1000吗？\n    log.info(&quot;finish size:{}&quot;, concurrentHashMap.size());\n    return &quot;OK&quot;;\n}\n\n</code></pre><p>访问接口后程序输出的日志内容如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/2e/70/2eaf5cd1b910b2678aca15fee6144070.png?wh=1918*580\" alt=\"\"></p><p>从日志中可以看到：</p><ul>\n<li>初始大小900符合预期，还需要填充100个元素。</li>\n<li>worker1线程查询到当前需要填充的元素为36，竟然还不是100的倍数。</li>\n<li>worker13线程查询到需要填充的元素数是负的，显然已经过度填充了。</li>\n<li>最后HashMap的总项目数是1536，显然不符合填充满1000的预期。</li>\n</ul><p>针对这个场景，我们可以举一个形象的例子。ConcurrentHashMap就像是一个大篮子，现在这个篮子里有900个桔子，我们期望把这个篮子装满1000个桔子，也就是再装100个桔子。有10个工人来干这件事儿，大家先后到岗后会计算还需要补多少个桔子进去，最后把桔子装入篮子。</p><p>ConcurrentHashMap这个篮子本身，可以确保多个工人在装东西进去时，不会相互影响干扰，但无法确保工人A看到还需要装100个桔子但是还未装的时候，工人B就看不到篮子中的桔子数量。更值得注意的是，你往这个篮子装100个桔子的操作不是原子性的，在别人看来可能会有一个瞬间篮子里有964个桔子，还需要补36个桔子。</p><p>回到ConcurrentHashMap，我们需要注意<strong>ConcurrentHashMap对外提供的方法或能力的限制</strong>：</p><ul>\n<li>使用了ConcurrentHashMap，不代表对它的多个操作之间的状态是一致的，是没有其他线程在操作它的，如果需要确保需要手动加锁。</li>\n<li>诸如size、isEmpty和containsValue等聚合方法，在并发情况下可能会反映ConcurrentHashMap的中间状态。因此在并发情况下，这些方法的返回值只能用作参考，而不能用于流程控制。显然，利用size方法计算差异值，是一个流程控制。</li>\n<li>诸如putAll这样的聚合方法也不能确保原子性，在putAll的过程中去获取数据可能会获取到部分数据。</li>\n</ul><p>代码的修改方案很简单，整段逻辑加锁即可：</p><pre><code>@GetMapping(&quot;right&quot;)\npublic String right() throws InterruptedException {\n    ConcurrentHashMap&lt;String, Long&gt; concurrentHashMap = getData(ITEM_COUNT - 100);\n    log.info(&quot;init size:{}&quot;, concurrentHashMap.size());\n\n\n    ForkJoinPool forkJoinPool = new ForkJoinPool(THREAD_COUNT);\n    forkJoinPool.execute(() -&gt; IntStream.rangeClosed(1, 10).parallel().forEach(i -&gt; {\n        //下面的这段复合逻辑需要锁一下这个ConcurrentHashMap\n        synchronized (concurrentHashMap) {\n            int gap = ITEM_COUNT - concurrentHashMap.size();\n            log.info(&quot;gap size:{}&quot;, gap);\n            concurrentHashMap.putAll(getData(gap));\n        }\n    }));\n    forkJoinPool.shutdown();\n    forkJoinPool.awaitTermination(1, TimeUnit.HOURS);\n\n\n    log.info(&quot;finish size:{}&quot;, concurrentHashMap.size());\n    return &quot;OK&quot;;\n}\n</code></pre><p>重新调用接口，程序的日志输出结果符合预期：</p><p><img src=\"https://static001.geekbang.org/resource/image/11/b8/1151b5b87f27073725060b76c56d95b8.png?wh=1910*556\" alt=\"\"></p><p>可以看到，只有一个线程查询到了需要补100个元素，其他9个线程查询到不需要补元素，最后Map大小为1000。</p><p>到了这里，你可能又要问了，使用ConcurrentHashMap全程加锁，还不如使用普通的HashMap呢。</p><p>其实不完全是这样。</p><p>ConcurrentHashMap提供了一些原子性的简单复合逻辑方法，用好这些方法就可以发挥其威力。这就引申出代码中常见的另一个问题：在使用一些类库提供的高级工具类时，开发人员可能还是按照旧的方式去使用这些新类，因为没有使用其特性，所以无法发挥其威力。</p><h2>没有充分了解并发工具的特性，从而无法发挥其威力</h2><p>我们来看一个使用Map来统计Key出现次数的场景吧，这个逻辑在业务代码中非常常见。</p><ul>\n<li>使用ConcurrentHashMap来统计，Key的范围是10。</li>\n<li>使用最多10个并发，循环操作1000万次，每次操作累加随机的Key。</li>\n<li>如果Key不存在的话，首次设置值为1。</li>\n</ul><p>代码如下：</p><pre><code>//循环次数\nprivate static int LOOP_COUNT = 10000000;\n//线程数量\nprivate static int THREAD_COUNT = 10;\n//元素数量\nprivate static int ITEM_COUNT = 10;\nprivate Map&lt;String, Long&gt; normaluse() throws InterruptedException {\n    ConcurrentHashMap&lt;String, Long&gt; freqs = new ConcurrentHashMap&lt;&gt;(ITEM_COUNT);\n    ForkJoinPool forkJoinPool = new ForkJoinPool(THREAD_COUNT);\n    forkJoinPool.execute(() -&gt; IntStream.rangeClosed(1, LOOP_COUNT).parallel().forEach(i -&gt; {\n        //获得一个随机的Key\n        String key = &quot;item&quot; + ThreadLocalRandom.current().nextInt(ITEM_COUNT);\n                synchronized (freqs) {      \n                    if (freqs.containsKey(key)) {\n                        //Key存在则+1\n                        freqs.put(key, freqs.get(key) + 1);\n                    } else {\n                        //Key不存在则初始化为1\n                        freqs.put(key, 1L);\n                    }\n                }\n            }\n    ));\n    forkJoinPool.shutdown();\n    forkJoinPool.awaitTermination(1, TimeUnit.HOURS);\n    return freqs;\n}\n</code></pre><p>我们吸取之前的教训，直接通过锁的方式锁住Map，然后做判断、读取现在的累计值、加1、保存累加后值的逻辑。这段代码在功能上没有问题，但无法充分发挥ConcurrentHashMap的威力，改进后的代码如下：</p><pre><code>private Map&lt;String, Long&gt; gooduse() throws InterruptedException {\n    ConcurrentHashMap&lt;String, LongAdder&gt; freqs = new ConcurrentHashMap&lt;&gt;(ITEM_COUNT);\n    ForkJoinPool forkJoinPool = new ForkJoinPool(THREAD_COUNT);\n    forkJoinPool.execute(() -&gt; IntStream.rangeClosed(1, LOOP_COUNT).parallel().forEach(i -&gt; {\n        String key = &quot;item&quot; + ThreadLocalRandom.current().nextInt(ITEM_COUNT);\n                //利用computeIfAbsent()方法来实例化LongAdder，然后利用LongAdder来进行线程安全计数\n                freqs.computeIfAbsent(key, k -&gt; new LongAdder()).increment();\n            }\n    ));\n    forkJoinPool.shutdown();\n    forkJoinPool.awaitTermination(1, TimeUnit.HOURS);\n    //因为我们的Value是LongAdder而不是Long，所以需要做一次转换才能返回\n    return freqs.entrySet().stream()\n            .collect(Collectors.toMap(\n                    e -&gt; e.getKey(),\n                    e -&gt; e.getValue().longValue())\n            );\n}\n</code></pre><p>在这段改进后的代码中，我们巧妙利用了下面两点：</p><ul>\n<li>使用ConcurrentHashMap的原子性方法computeIfAbsent来做复合逻辑操作，判断Key是否存在Value，如果不存在则把Lambda表达式运行后的结果放入Map作为Value，也就是新创建一个LongAdder对象，最后返回Value。</li>\n<li>由于computeIfAbsent方法返回的Value是LongAdder，是一个线程安全的累加器，因此可以直接调用其increment方法进行累加。</li>\n</ul><p><strong>这样在确保线程安全的情况下达到极致性能，把之前7行代码替换为了1行。</strong></p><p>我们通过一个简单的测试比较一下修改前后两段代码的性能：</p><pre><code>@GetMapping(&quot;good&quot;)\npublic String good() throws InterruptedException {\n    StopWatch stopWatch = new StopWatch();\n    stopWatch.start(&quot;normaluse&quot;);\n    Map&lt;String, Long&gt; normaluse = normaluse();\n    stopWatch.stop();\n    //校验元素数量\n    Assert.isTrue(normaluse.size() == ITEM_COUNT, &quot;normaluse size error&quot;);\n    //校验累计总数    \n    Assert.isTrue(normaluse.entrySet().stream()\n                    .mapToLong(item -&gt; item.getValue()).reduce(0, Long::sum) == LOOP_COUNT\n            , &quot;normaluse count error&quot;);\n    stopWatch.start(&quot;gooduse&quot;);\n    Map&lt;String, Long&gt; gooduse = gooduse();\n    stopWatch.stop();\n    Assert.isTrue(gooduse.size() == ITEM_COUNT, &quot;gooduse size error&quot;);\n    Assert.isTrue(gooduse.entrySet().stream()\n                    .mapToLong(item -&gt; item.getValue())\n                    .reduce(0, Long::sum) == LOOP_COUNT\n            , &quot;gooduse count error&quot;);\n    log.info(stopWatch.prettyPrint());\n    return &quot;OK&quot;;\n}\n</code></pre><p>这段测试代码并无特殊之处，使用StopWatch来测试两段代码的性能，最后跟了一个断言判断Map中元素的个数以及所有Value的和，是否符合预期来校验代码的正确性。测试结果如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/75/3a/751d484ecd8c3114c15588e7fff3263a.png?wh=922*254\" alt=\"\"></p><p>可以看到，<strong>优化后的代码，相比使用锁来操作ConcurrentHashMap的方式，性能提升了10倍</strong>。</p><p>你可能会问，computeIfAbsent为什么如此高效呢？</p><p>答案就在源码最核心的部分，也就是Java自带的Unsafe实现的CAS。它在虚拟机层面确保了写入数据的原子性，比加锁的效率高得多：</p><pre><code>    static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i,\n                                        Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) {\n        return U.compareAndSetObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);\n    }\n</code></pre><p>像ConcurrentHashMap这样的高级并发工具的确提供了一些高级API，只有充分了解其特性才能最大化其威力，而不能因为其足够高级、酷炫盲目使用。</p><h2>没有认清并发工具的使用场景，因而导致性能问题</h2><p>除了ConcurrentHashMap这样通用的并发工具类之外，我们的工具包中还有些针对特殊场景实现的生面孔。一般来说，针对通用场景的通用解决方案，在所有场景下性能都还可以，属于“万金油”；而针对特殊场景的特殊实现，会有比通用解决方案更高的性能，但一定要在它针对的场景下使用，否则可能会产生性能问题甚至是Bug。</p><p>之前在排查一个生产性能问题时，我们发现一段简单的非数据库操作的业务逻辑，消耗了超出预期的时间，在修改数据时操作本地缓存比回写数据库慢许多。查看代码发现，开发同学使用了CopyOnWriteArrayList来缓存大量的数据，而数据变化又比较频繁。</p><p>CopyOnWrite是一个时髦的技术，不管是Linux还是Redis都会用到。<strong>在Java中，CopyOnWriteArrayList虽然是一个线程安全的ArrayList，但因为其实现方式是，每次修改数据时都会复制一份数据出来，所以有明显的适用场景，即读多写少或者说希望无锁读的场景。</strong></p><p>如果我们要使用CopyOnWriteArrayList，那一定是因为场景需要而不是因为足够酷炫。如果读写比例均衡或者有大量写操作的话，使用CopyOnWriteArrayList的性能会非常糟糕。</p><p>我们写一段测试代码，来比较下使用CopyOnWriteArrayList和普通加锁方式ArrayList的读写性能吧。在这段代码中我们针对并发读和并发写分别写了一个测试方法，测试两者一定次数的写或读操作的耗时。</p><pre><code>//测试并发写的性能\n@GetMapping(&quot;write&quot;)\npublic Map testWrite() {\n    List&lt;Integer&gt; copyOnWriteArrayList = new CopyOnWriteArrayList&lt;&gt;();\n    List&lt;Integer&gt; synchronizedList = Collections.synchronizedList(new ArrayList&lt;&gt;());\n    StopWatch stopWatch = new StopWatch();\n    int loopCount = 100000;\n    stopWatch.start(&quot;Write:copyOnWriteArrayList&quot;);\n    //循环100000次并发往CopyOnWriteArrayList写入随机元素\n    IntStream.rangeClosed(1, loopCount).parallel().forEach(__ -&gt; copyOnWriteArrayList.add(ThreadLocalRandom.current().nextInt(loopCount)));\n    stopWatch.stop();\n    stopWatch.start(&quot;Write:synchronizedList&quot;);\n    //循环100000次并发往加锁的ArrayList写入随机元素\n    IntStream.rangeClosed(1, loopCount).parallel().forEach(__ -&gt; synchronizedList.add(ThreadLocalRandom.current().nextInt(loopCount)));\n    stopWatch.stop();\n    log.info(stopWatch.prettyPrint());\n    Map result = new HashMap();\n    result.put(&quot;copyOnWriteArrayList&quot;, copyOnWriteArrayList.size());\n    result.put(&quot;synchronizedList&quot;, synchronizedList.size());\n    return result;\n}\n\n//帮助方法用来填充List\nprivate void addAll(List&lt;Integer&gt; list) {\n    list.addAll(IntStream.rangeClosed(1, 1000000).boxed().collect(Collectors.toList()));\n}\n\n//测试并发读的性能\n@GetMapping(&quot;read&quot;)\npublic Map testRead() {\n    //创建两个测试对象\n    List&lt;Integer&gt; copyOnWriteArrayList = new CopyOnWriteArrayList&lt;&gt;();\n    List&lt;Integer&gt; synchronizedList = Collections.synchronizedList(new ArrayList&lt;&gt;());\n    //填充数据   \n    addAll(copyOnWriteArrayList);\n    addAll(synchronizedList);\n    StopWatch stopWatch = new StopWatch();\n    int loopCount = 1000000;\n    int count = copyOnWriteArrayList.size();\n    stopWatch.start(&quot;Read:copyOnWriteArrayList&quot;);\n    //循环1000000次并发从CopyOnWriteArrayList随机查询元素\n    IntStream.rangeClosed(1, loopCount).parallel().forEach(__ -&gt; copyOnWriteArrayList.get(ThreadLocalRandom.current().nextInt(count)));\n    stopWatch.stop();\n    stopWatch.start(&quot;Read:synchronizedList&quot;);\n    //循环1000000次并发从加锁的ArrayList随机查询元素\n    IntStream.range(0, loopCount).parallel().forEach(__ -&gt; synchronizedList.get(ThreadLocalRandom.current().nextInt(count)));\n    stopWatch.stop();\n    log.info(stopWatch.prettyPrint());\n    Map result = new HashMap();\n    result.put(&quot;copyOnWriteArrayList&quot;, copyOnWriteArrayList.size());\n    result.put(&quot;synchronizedList&quot;, synchronizedList.size());\n    return result;\n}\n</code></pre><p>运行程序可以看到，<strong>大量写的场景（10万次add操作），</strong><strong>CopyOnWriteArray几乎比同步的ArrayList慢一百倍</strong>：</p><p><img src=\"https://static001.geekbang.org/resource/image/97/b4/9789fe2019a1267b7883606b60e498b4.png?wh=940*252\" alt=\"\"></p><p>而在大量读的场景下（100万次get操作），CopyOnWriteArray又比同步的ArrayList快五倍以上：</p><p><img src=\"https://static001.geekbang.org/resource/image/30/36/30ba652fb3295c58b03f51de0a132436.png?wh=970*270\" alt=\"\"></p><p>你可能会问，为何在大量写的场景下，CopyOnWriteArrayList会这么慢呢？</p><p>答案就在源码中。以add方法为例，每次add时，都会用Arrays.copyOf创建一个新数组，频繁add时内存的申请释放消耗会很大：</p><pre><code>    /**\n     * Appends the specified element to the end of this list.\n     *\n     * @param e element to be appended to this list\n     * @return {@code true} (as specified by {@link Collection#add})\n     */\n    public boolean add(E e) {\n        synchronized (lock) {\n            Object[] elements = getArray();\n            int len = elements.length;\n            Object[] newElements = Arrays.copyOf(elements, len + 1);\n            newElements[len] = e;\n            setArray(newElements);\n            return true;\n        }\n    }\n</code></pre><h2>重点回顾</h2><p>今天，我主要与你分享了，开发人员使用并发工具来解决线程安全问题时容易犯的四类错。</p><p>一是，只知道使用并发工具，但并不清楚当前线程的来龙去脉，解决多线程问题却不了解线程。比如，使用ThreadLocal来缓存数据，以为ThreadLocal在线程之间做了隔离不会有线程安全问题，没想到线程重用导致数据串了。请务必记得，在业务逻辑结束之前清理ThreadLocal中的数据。</p><p>二是，误以为使用了并发工具就可以解决一切线程安全问题，期望通过把线程不安全的类替换为线程安全的类来一键解决问题。比如，认为使用了ConcurrentHashMap就可以解决线程安全问题，没对复合逻辑加锁导致业务逻辑错误。如果你希望在一整段业务逻辑中，对容器的操作都保持整体一致性的话，需要加锁处理。</p><p>三是，没有充分了解并发工具的特性，还是按照老方式使用新工具导致无法发挥其性能。比如，使用了ConcurrentHashMap，但没有充分利用其提供的基于CAS安全的方法，还是使用锁的方式来实现逻辑。你可以阅读一下<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html\">ConcurrentHashMap的文档</a>，看一下相关原子性操作API是否可以满足业务需求，如果可以则优先考虑使用。</p><p>四是，没有了解清楚工具的适用场景，在不合适的场景下使用了错误的工具导致性能更差。比如，没有理解CopyOnWriteArrayList的适用场景，把它用在了读写均衡或者大量写操作的场景下，导致性能问题。对于这种场景，你可以考虑是用普通的List。</p><p>其实，这四类坑之所以容易踩到，原因可以归结为，我们在使用并发工具的时候，并没有充分理解其可能存在的问题、适用场景等。所以最后，<strong>我还要和你分享两点建议</strong>：</p><ol>\n<li>一定要认真阅读官方文档（比如Oracle JDK文档）。充分阅读官方文档，理解工具的适用场景及其API的用法，并做一些小实验。了解之后再去使用，就可以避免大部分坑。</li>\n<li>如果你的代码运行在多线程环境下，那么就会有并发问题，并发问题不那么容易重现，可能需要使用压力测试模拟并发场景，来发现其中的Bug或性能问题。</li>\n</ol><p>今天用到的代码，我都放在了GitHub上，你可以点击<a href=\"https://github.com/JosephZhu1983/java-common-mistakes\">这个链接</a>查看。</p><h2>思考与讨论</h2><ol>\n<li>今天我们多次用到了ThreadLocalRandom，你觉得是否可以把它的实例设置到静态变量中，在多线程情况下重用呢？</li>\n<li>ConcurrentHashMap还提供了putIfAbsent方法，你能否通过查阅<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html\">JDK文档</a>，说说computeIfAbsent和putIfAbsent方法的区别？</li>\n</ol><p>你在使用并发工具时，还遇到过其他坑吗？我是朱晔，欢迎在评论区与我留言分享你的想法，也欢迎你把这篇文章分享给你的朋友或同事，一起交流。</p>","neighbors":{"left":{"article_title":"开篇词 | 业务代码真的会有这么多坑？","id":209108},"right":{"article_title":"02 | 代码加锁：不要让“锁”事成为烦心事","id":209520}},"comments":[{"had_liked":false,"id":186418,"user_name":"broccoli","can_delete":false,"product_type":"c1","uid":1901830,"ip_address":"","ucode":"A166E2112EFEEA","user_header":"https://static001.geekbang.org/account/avatar/00/1d/05/06/12476afb.jpg","comment_is_top":true,"comment_ctime":1583842431,"is_pvip":false,"replies":[{"id":"72004","content":"说的非常细非常好<br><br>computeIfAbsent和putIfAbsent区别是三点：<br>1、当Key存在的时候，如果Value获取比较昂贵的话，putIfAbsent就白白浪费时间在获取这个昂贵的Value上（这个点特别注意）<br>2、Key不存在的时候，putIfAbsent返回null，小心空指针，而computeIfAbsent返回计算后的值<br>3、当Key不存在的时候，putIfAbsent允许put null进去，而computeIfAbsent不能，之后进行containsKey查询是有区别的（当然了，此条针对HashMap，ConcurrentHashMap不允许put null value进去）","user_name":"作者回复","comment_id":186418,"uid":"1001470","ip_address":"","utype":1,"ctime":1583844794,"user_name_real":"朱晔"}],"discussion_count":8,"race_medal":0,"score":"9.2233724206907003e+18","product_id":100047701,"comment_content":"尝试回答一下思考题：<br>- 1. 先说结论：不可以，结果是除了初始化 ThreadLocalRandom 的主线程获取的随机值是无模式的（调用者不可预测下个返回值，满足我们对伪随机的要求）之外，其他线程获得随机值都不是相互独立的（本质上来说，是因为他们用于生成随机数的种子 seed 的值可预测的，为 i*gamma，其中 i 是当前线程调用随机数生成方法次数，而 gamma 是 ThreadLocalRandom 类的一个 long 静态字段值）。例如，一个有趣的现象是，所有非初始化 ThreadLocalRandom 实例的线程如果调用相同次数的 nextInt() 方法，他们得到的随机数串是完全相同的。<br>造成这样现象的原因在于，ThreadLocalRandom 类维护了一个类单例字段，线程通过调用 ThreadLocalRandom#current() 方法来获取 ThreadLocalRandom 单例，然后以线程维护的实例字段 threadLocalRandomSeed 为种子生成下一个随机数和下一个种子值。<br>那么既然是单例模式，为什么多线程共用主线程初始化的实例就会出问题呢。问题就在于 current 方法，线程在调用 current() 方法的时候，会根据用每个线程的 thread 的一个实例字段 threadLocalRandomProbe 是否为 0 来判断是否当前线程实例是否为第一次调用随机数生成方法，从而决定是否要给当前线程初始化一个随机的 threadLocalRandomSeed 种子值。因此，如果其他线程绕过 current 方法直接调用随机数方法，那么它的种子值就是 0, 1*gamma, 2*gamma... 因此也就是可预测的了。<br><br>- 2. 两个方法的区别除了其他同学在评论区提出的参数类型不同以及抛出异常类型不同之外，在文中示例选择 CIA 而不选择 PIA 的原因（以及老师为什么点出来的原因）在于他们在面对 absent key值上的区别：<br>  - CIA 根据 mappingFunction 返回的值插入键值对，然后返回这个新值<br>  - 而 PIA 是插入 KV 对后，返回 null 值<br><br>因此，如果我们将文中的 CIA 替换成 PIA，如果插入的是 absent key 会抛出空指针异常。其实，在我看来文中示例用 PIA 也不是不行，只要改成先 PIA，然后再去 get(key) 获取那个原子类型 long 然后再自增就 ok 了。（不确定对错，还请老师指正）<br>那么老师为什么没有这么写呢？<br>  - 一是每调用一次这些方法都伴随着一次片段锁的获取与释放，显然 PIA 方法性能要差<br>  - （二就是不够优雅，老师嫌字多...）","like_count":90,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486746,"discussion_content":"说的非常细非常好\n\ncomputeIfAbsent和putIfAbsent区别是三点：\n1、当Key存在的时候，如果Value获取比较昂贵的话，putIfAbsent就白白浪费时间在获取这个昂贵的Value上（这个点特别注意）\n2、Key不存在的时候，putIfAbsent返回null，小心空指针，而computeIfAbsent返回计算后的值\n3、当Key不存在的时候，putIfAbsent允许put null进去，而computeIfAbsent不能，之后进行containsKey查询是有区别的（当然了，此条针对HashMap，ConcurrentHashMap不允许put null value进去）","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1583844794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2154820,"avatar":"https://static001.geekbang.org/account/avatar/00/20/e1/44/8f26fe96.jpg","nickname":"雨后晴天","note":"","ucode":"6A0D13AC5DFB3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310297,"discussion_content":"当Key存在的时候，如果Value获取比较昂贵的话，putIfAbsent就白白浪费时间在获取这个昂贵的Value上。老师，这一点要怎么理解？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601736508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":2403780,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ad/c4/49dfb810.jpg","nickname":"EEE","note":"","ucode":"C8D07F7F0B6EFB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2154820,"avatar":"https://static001.geekbang.org/account/avatar/00/20/e1/44/8f26fe96.jpg","nickname":"雨后晴天","note":"","ucode":"6A0D13AC5DFB3A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341228,"discussion_content":"因为putIfAbsent返回旧值，computeIfAbsent是新值","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1610356496,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":310297,"ip_address":""},"score":341228,"extra":""},{"author":{"id":2450893,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/L8EpqHoAnmvkzCIsdOkv5QvhIzu5tMaF2FDusXShqukv5ZBkS8DbicWaErjnYydibiaqBrs70wQ8P6axvC2FbWpbQ/132","nickname":"Geek_d3928c","note":"","ucode":"7CB09FD1F7CB23","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2403780,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ad/c4/49dfb810.jpg","nickname":"EEE","note":"","ucode":"C8D07F7F0B6EFB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590414,"discussion_content":"既然旧值为NULL，为什么还存在获取Value时间浪费呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665726959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":341228,"ip_address":"浙江"},"score":590414,"extra":""},{"author":{"id":1320117,"avatar":"https://static001.geekbang.org/account/avatar/00/14/24/b5/c62b9027.jpg","nickname":"夜猫~_~","note":"","ucode":"1D2291C659901D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2450893,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/L8EpqHoAnmvkzCIsdOkv5QvhIzu5tMaF2FDusXShqukv5ZBkS8DbicWaErjnYydibiaqBrs70wQ8P6axvC2FbWpbQ/132","nickname":"Geek_d3928c","note":"","ucode":"7CB09FD1F7CB23","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":592135,"discussion_content":"这个方法是指定的 key 存在，返回和这个 key 值对应的 value, 如果所指定的 key 不存在，则返回 null","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667141105,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":590414,"ip_address":"陕西"},"score":592135,"extra":""}]},{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":207913,"discussion_content":"因为这是ConcurrentHashMap，HashMap可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584525119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1104576,"avatar":"https://static001.geekbang.org/account/avatar/00/10/da/c0/9fc31f2d.jpg","nickname":"初心","note":"","ucode":"C090A1723E3474","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":205783,"discussion_content":"老师， 我看源码，这两个都是不能put value= null 呢？求解释 ，谢谢！\n代码片段如下：\n public V putIfAbsent(K key, V value) {\n        return putVal(key, value, true);\n    }\n final V putVal(K key, V value, boolean onlyIfAbsent) {\n        if (key == null || value == null) throw new NullPointerException();","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584341749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1992424,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep3sqfTQey7eKYgGibLnAvaNj9k8gVvIYKVADicOA3DxmXZcDrAkeM8iaJLruiblmEVUr3q2LOVLvYicTw/132","nickname":"郑先生","note":"","ucode":"AA0BA751C4F132","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1104576,"avatar":"https://static001.geekbang.org/account/avatar/00/10/da/c0/9fc31f2d.jpg","nickname":"初心","note":"","ucode":"C090A1723E3474","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":272080,"discussion_content":"老师不是说了，HashMap可以，ConcurrentHashMap不允许put null value进去，你看看HashMap的源码应该是可以为null","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590244195,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":205783,"ip_address":""},"score":272080,"extra":""}]}]},{"had_liked":false,"id":188408,"user_name":"何岸康","can_delete":false,"product_type":"c1","uid":1444317,"ip_address":"","ucode":"F24898244A170D","user_header":"https://static001.geekbang.org/account/avatar/00/16/09/dd/02c73bd3.jpg","comment_is_top":true,"comment_ctime":1584350912,"is_pvip":false,"replies":[{"id":"72692","content":"非常完美的回答","user_name":"作者回复","comment_id":188408,"uid":"1001470","ip_address":"","utype":1,"ctime":1584351886,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"9.2233722961371996e+18","product_id":100047701,"comment_content":"问题一：不可以。ThreadLocalRandom文档里写了Usages of this class should typically be of the form:ThreadLocalRandom.current().nextX(...)} (where X is Int, Long, etc)。<br>ThreadLocalRandom类中只封装了一些公用的方法，种子存放在各个线程中。<br>ThreadLocalRandom中存放一个单例的instance，调用current()方法返回这个instance，每个线程首次调用current()方法时，会在各个线程中初始化seed和probe。<br>nextX(）方法会调用nextSeed()，在其中使用各个线程中的种子，计算下一个种子并保存（UNSAFE.getLong(t, SEED) + GAMMA）。<br>所以，如果使用静态变量，直接调用nextX()方法就跳过了各个线程初始化的步骤，只会在每次调用nextSeed()时来更新种子。<br><br>问题二<br>1.参数不一样，putIfAbsent是值，computeIfAbsent是mappingFunction<br>2.返回值不一样，putIfAbsent是之前的值，computeIfAbsent是现在的值<br>3.putIfAbsent可以存入null，computeIfAbsent计算结果是null只会返回null，不会写入。","like_count":61,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487400,"discussion_content":"非常完美的回答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584351886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186376,"user_name":"Wiggle Wiggle","can_delete":false,"product_type":"c1","uid":1036052,"ip_address":"","ucode":"EFE746551BA998","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cf/14/384258ba.jpg","comment_is_top":true,"comment_ctime":1583831750,"is_pvip":false,"replies":[{"id":"71973","content":"基本原理是，current()的时候初始化一个初始化种子到线程，每次nextseed再使用之前的种子生成新的种子：<br>UNSAFE.putLong(t = Thread.currentThread(), SEED,<br>                       r = UNSAFE.getLong(t, SEED) + GAMMA);<br>如果你通过主线程调用一次current生成一个ThreadLocalRandom的实例保存起来，那么其它线程来获取种子的时候必然取不到初始种子，必须是每一个线程自己用的时候初始化一个种子到线程，你可以在nextSeed设置一个断点看看：<br>UNSAFE.getLong(Thread.currentThread(),SEED);","user_name":"作者回复","comment_id":186376,"uid":"1001470","ip_address":"","utype":1,"ctime":1583836055,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"9.2233720899782001e+18","product_id":100047701,"comment_content":"关于 ThreadLocalRandom，其目的是为了避免多线程共享 Random 时竟态条件下性能差的问题（我认为关键在于 Random#nextSeed 方法中使用自旋保证线程安全，而自旋在面对高并发时性能差），官方文档上说正确用法是 ThreadLocalRandom.current().nextX(...)，但是没说设置为 static 的话会发生什么，我想进一步研究一下，就去看了一下源码，不知道理解对不对，请老师指正：ThreadLocalRandom#nextSeed 方法中用到了 UnSafe，这块我不了解，但是我没有看到任何保证线程安全的代码，如果并发调用的话会导致无法预料的问题。","like_count":12,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486734,"discussion_content":"基本原理是，current()的时候初始化一个初始化种子到线程，每次nextseed再使用之前的种子生成新的种子：\nUNSAFE.putLong(t = Thread.currentThread(), SEED,\n                       r = UNSAFE.getLong(t, SEED) + GAMMA);\n如果你通过主线程调用一次current生成一个ThreadLocalRandom的实例保存起来，那么其它线程来获取种子的时候必然取不到初始种子，必须是每一个线程自己用的时候初始化一个种子到线程，你可以在nextSeed设置一个断点看看：\nUNSAFE.getLong(Thread.currentThread(),SEED);","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583836055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186116,"user_name":"le","can_delete":false,"product_type":"c1","uid":1607997,"ip_address":"","ucode":"76370C23E98362","user_header":"https://static001.geekbang.org/account/avatar/00/18/89/3d/3703c52f.jpg","comment_is_top":false,"comment_ctime":1583760146,"is_pvip":false,"replies":[{"id":"71900","content":"controller向dao传值没有必要，ThreadLocal可以理解为绑定到线程的Map，相同线程的不同逻辑需要共享数据（但又无法通过传值来共享数据），或为了避免相同线程重复创建对象希望重用数据，可以考虑使用ThreadLocal","user_name":"作者回复","comment_id":186116,"uid":"1001470","ip_address":"","utype":1,"ctime":1583764080,"user_name_real":"朱晔"}],"discussion_count":8,"race_medal":0,"score":"117547877138","product_id":100047701,"comment_content":"我有一点不太明白,那ThreadLocal的意义呢? 难得是在特定情况下?如:没有用线程池?或者是不想写参数传递值? 用ThreadLocal 从controller传递到dao中 一个请求结束之前给他把值 清空吗(小白一个...求大佬解答)","like_count":27,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486630,"discussion_content":"controller向dao传值没有必要，ThreadLocal可以理解为绑定到线程的Map，相同线程的不同逻辑需要共享数据（但又无法通过传值来共享数据），或为了避免相同线程重复创建对象希望重用数据，可以考虑使用ThreadLocal","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583764080,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1600994,"avatar":"https://static001.geekbang.org/account/avatar/00/18/6d/e2/5bf3c7c7.jpg","nickname":"以芢","note":"","ucode":"ABA00BD8F2C17D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296985,"discussion_content":"感觉你是刚接触web开发，dao作为数据库的访问层，一般只在方法上显示传值，而ThreadLocal则是线程执行的时候，“隐式”传值；个人觉得，你不用纠结。你可以理解成当前线程执行的时候，如果有些数据，就像老师说的登录信息这种，你在整体的业务实现上，比较复杂，或者链路比较长，一层层传递比较麻烦等等，需要线程共享数据，或者传参，或者说调用链路上的通用数据，你可以考虑使用ThreadLocal来持有。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1596723289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1130115,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3e/83/4dae491a.jpg","nickname":"薛文曜","note":"","ucode":"C3582FB52BD8A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":244665,"discussion_content":"其实通常来说不需要用finally，只要保证request进来时set了Threadlocal就行。比如在spring security filter中设置用户信息。我们之前确实出现过类似的问题，对于允许匿名访问的接口，没有把ThreadLocal设置为null，倒是service里能读到用户信息","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587619918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1593289,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","nickname":"编程界的小学生","note":"","ucode":"4A5BE9A5E877FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":201157,"discussion_content":"恕小弟直言，用法不会的真没办法。此课程针对的是找坑，填坑。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583763385,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1048525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ff/cd/9c44f2d5.jpg","nickname":"Mong狗","note":"","ucode":"9DF0D65D75984E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1593289,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","nickname":"编程界的小学生","note":"","ucode":"4A5BE9A5E877FA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206533,"discussion_content":"老师讲的这个坑不就是用法不对么？我也觉的虽然最终加上finally可以解决问题，但是没啥意义，每次还要重新获取用户信息。所以正确的使用场景是啥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584412394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":201157,"ip_address":""},"score":206533,"extra":""},{"author":{"id":1593289,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","nickname":"编程界的小学生","note":"","ucode":"4A5BE9A5E877FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1048525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ff/cd/9c44f2d5.jpg","nickname":"Mong狗","note":"","ucode":"9DF0D65D75984E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206834,"discussion_content":"没看懂你说的。用完finally释放。下次在需要用的话就是其他线程了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584449227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":206533,"ip_address":""},"score":206834,"extra":""},{"author":{"id":2425470,"avatar":"","nickname":"Geek_04e210","note":"","ucode":"8E43D8F563B670","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1048525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ff/cd/9c44f2d5.jpg","nickname":"Mong狗","note":"","ucode":"9DF0D65D75984E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348937,"discussion_content":"单个线程处处都可以用到的？反正这个同学用的地方不对。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612787134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":206533,"ip_address":""},"score":348937,"extra":""}]},{"author":{"id":1464006,"avatar":"https://static001.geekbang.org/account/avatar/00/16/56/c6/0b449bc6.jpg","nickname":"斐波那契","note":"","ucode":"85E2EBC01392B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212509,"discussion_content":"不用那么纠结 老师只是举个例子 不是说一定要这么做 重点是 在你使用threadlocal的时候要注意使用它的线程问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584975407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186311,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1583824103,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"104663039207","product_id":100047701,"comment_content":"第一节就已经收获颇丰了，吾尝终日而思矣，不如须臾之所学也。","like_count":24},{"had_liked":false,"id":186070,"user_name":"汝林外史","can_delete":false,"product_type":"c1","uid":1188906,"ip_address":"","ucode":"3C66C0F0537A99","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/2a/33441e2b.jpg","comment_is_top":false,"comment_ctime":1583749988,"is_pvip":false,"replies":[{"id":"71886","content":"专栏会有一篇加餐来介绍","user_name":"作者回复","comment_id":186070,"uid":"1001470","ip_address":"","utype":1,"ctime":1583754164,"user_name_real":"朱晔"}],"discussion_count":8,"race_medal":0,"score":"78893161316","product_id":100047701,"comment_content":"老师的文章真的是最贴近开发实际，绝对超值。看您代码中都是用的lambda表达式，我工作中都不知道怎么应用，请问老师针对lambda表达式应该怎么深入学习呢？","like_count":18,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486610,"discussion_content":"专栏会有一篇加餐来介绍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583754164,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1139455,"avatar":"https://static001.geekbang.org/account/avatar/00/11/62/ff/f71034e9.jpg","nickname":"悟空WuKong","note":"","ucode":"49AFD2B048C1BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286584,"discussion_content":"《java8实战》","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1593235220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1154992,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9f/b0/85b17023.jpg","nickname":"Xu","note":"","ucode":"9A40B23C8D3D87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":202553,"discussion_content":"lambda落到JVM上还是匿名内部类，如楼上所说，只是语法糖。 但是在代码中可以看做是一个单独函数代表了一种行为","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1583932578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1188906,"avatar":"https://static001.geekbang.org/account/avatar/00/12/24/2a/33441e2b.jpg","nickname":"汝林外史","note":"","ucode":"3C66C0F0537A99","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1154992,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9f/b0/85b17023.jpg","nickname":"Xu","note":"","ucode":"9A40B23C8D3D87","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":203275,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584020538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":202553,"ip_address":""},"score":203275,"extra":""}]},{"author":{"id":1239557,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ea/05/c0d8014d.jpg","nickname":"一道阳光","note":"","ucode":"F35207CCCEC6E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":201806,"discussion_content":"这个我现在正在学，感觉很简单，他只是java的语法糖，但字节码跟之前的还是一样的。我还做了笔记，有道云笔记，要的话，可以共享给你","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1583840673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1188906,"avatar":"https://static001.geekbang.org/account/avatar/00/12/24/2a/33441e2b.jpg","nickname":"汝林外史","note":"","ucode":"3C66C0F0537A99","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1239557,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ea/05/c0d8014d.jpg","nickname":"一道阳光","note":"","ucode":"F35207CCCEC6E2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":203274,"discussion_content":"是不是主要就靠多用多练才行","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584020515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":201806,"ip_address":""},"score":203274,"extra":""}]},{"author":{"id":1014691,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/a3/82b2a73e.jpg","nickname":"黑暗浪子","note":"","ucode":"FBB8C24EBEC5BB","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":201370,"discussion_content":"推荐一套函数编程系列的书。目前有Java，scala和JavaScript三本。如果我没记错的话，微信读书里有scala那本","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583772003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2063532,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7c/ac/482c6eb4.jpg","nickname":"老徐","note":"","ucode":"34566E3D28620C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532885,"discussion_content":"java的lambda表达式就是一个对象, 里面的方法被重写了,就这样子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637724993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186292,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1583820837,"is_pvip":true,"replies":[{"id":"71960","content":"👍🏻","user_name":"作者回复","comment_id":186292,"uid":"1001470","ip_address":"","utype":1,"ctime":1583822951,"user_name_real":"朱晔"}],"discussion_count":2,"race_medal":0,"score":"74598264869","product_id":100047701,"comment_content":"试着回答下问题：<br>1、ThreadLocalRandom，不能使用静态变量，因为在初始化的时候，通过Unsafe把seed和当前线程绑定了，在多线程情况下，只有主线程和seed绑定了，其他线程在获取seed的时候就是有问题的；<br>2、computeIfAbsent的value是接受一个Function，而putIfAbsent是是接受一个具体的value，所以computeIfAbsent的使用应该是非常灵活的。","like_count":17,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486708,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583822951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2152306,"avatar":"https://static001.geekbang.org/account/avatar/00/20/d7/72/cbef720d.jpg","nickname":"鲁鸣","note":"","ucode":"974BA3C3E64630","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307701,"discussion_content":"这种情况下，有个疑问，为什么不直接把putIfAbsent干掉呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600738281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188423,"user_name":"Daizl","can_delete":false,"product_type":"c1","uid":1067435,"ip_address":"","ucode":"0A6FE684E857AB","user_header":"https://static001.geekbang.org/account/avatar/00/10/49/ab/6fde4a46.jpg","comment_is_top":false,"comment_ctime":1584352734,"is_pvip":false,"replies":[{"id":"72696","content":"举例：<br>容器：ConcurrentHashMap、ConcurrentSkipListMap、CopyOnWriteArrayList、ConcurrentSkipListSet<br>同步器：CountDownLatch、Semaphore、CyclicBarrier、Phaser、Exchanger","user_name":"作者回复","comment_id":188423,"uid":"1001470","ip_address":"","utype":1,"ctime":1584353498,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"66008862174","product_id":100047701,"comment_content":"老师，一般而言并发工具包括同步器和容器两大类，这2大类没太明白怎么区分的。","like_count":16,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487406,"discussion_content":"举例：\n容器：ConcurrentHashMap、ConcurrentSkipListMap、CopyOnWriteArrayList、ConcurrentSkipListSet\n同步器：CountDownLatch、Semaphore、CyclicBarrier、Phaser、Exchanger","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584353498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186130,"user_name":"编程界的小学生","can_delete":false,"product_type":"c1","uid":1593289,"ip_address":"","ucode":"4A5BE9A5E877FA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","comment_is_top":false,"comment_ctime":1583763290,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"44533436250","product_id":100047701,"comment_content":"看完这篇文章才恍然大悟ThreadLocal内存泄露原来是线程池线程复用导致的。","like_count":10,"discussions":[{"author":{"id":2040650,"avatar":"","nickname":"Geek_8b9f15","note":"","ucode":"7BA71BC75E8E33","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284638,"discussion_content":"如果当前线程被回收，threadLocal自然会被回收，因为他是弱引用，是否gc依赖于当前线程的强引用。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592574853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1041865,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e5/c9/1061582b.jpg","nickname":"skying","note":"","ucode":"E7CFF50AB64BB1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":204128,"discussion_content":"@编程界的小学生,你好 ，我理解不是 线程池复用导致的内存泄露吧，是其中保存的值 没有及时回收导致的吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584114617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1593289,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","nickname":"编程界的小学生","note":"","ucode":"4A5BE9A5E877FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1041865,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e5/c9/1061582b.jpg","nickname":"skying","note":"","ucode":"E7CFF50AB64BB1","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":204500,"discussion_content":"我理解是的，线程池的线程不会回收导致根节点一直存在。gc不会判断为可回收对象。而不用线程池的话线程结束就回收了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584182975,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":204128,"ip_address":""},"score":204500,"extra":""}]}]},{"had_liked":false,"id":186088,"user_name":"Jialin","can_delete":false,"product_type":"c1","uid":1112955,"ip_address":"","ucode":"12583269732A75","user_header":"https://static001.geekbang.org/account/avatar/00/10/fb/7b/2d4b38fb.jpg","comment_is_top":false,"comment_ctime":1583754297,"is_pvip":false,"replies":[{"id":"71890","content":"问题1不太对，ThreadLocalRandom的正确使用方式是ThreadLocalRandom.current().nextX(...)，不能在多线程之间共享ThreadLocalRandom","user_name":"作者回复","comment_id":186088,"uid":"1001470","ip_address":"","utype":1,"ctime":1583761473,"user_name_real":"朱晔"}],"discussion_count":3,"race_medal":0,"score":"40238459961","product_id":100047701,"comment_content":"问题1:ThreadLocalRandom 是 ThreadLocal 类和 Random 类的组合，ThreadLocal的出现就是为了解决多线程访问一个变量时候需要进行同步的问题，让每一个线程拷贝一份变量，每个线程对变量进行操作时候实际是操作自己本地内存里面的拷贝，从而避免了对共享变量进行同步，ThreadLocalRandom的实现也是这个原理，解决了Random类在多线程下多个线程竞争内部唯一的原子性种子变量而导致大量线程自旋重试的不足，因此，类似于ThreadLocal，ThreadLocalRandom的实例也可以设置成静态变量。<br>问题2:<br>public V computeIfAbsent(K key, Function&lt;? super K,? extends V&gt; mappingFunction)此方法首先判断缓存map中是否存在指定key的值，如果不存在，会自动调用mappingFunction(key)计算key的value，然后将key = value放入到缓存Map，如果mappingFunction(key)返回的值为null或抛出异常，则不会有记录存入map。<br>public V putIfAbsent(K key, V value)此方法如果不存在（新的entry），那么会向map中添加该键值对，并返回null。如果已经存在，那么不会覆盖已有的值，直接返回已经存在的值。<br>相同点：两者均是指定的key不存在其对应的value时，进行操作，指定的key存在对应的value时，直接返回value。<br>不同点：<br>线程安全性：putIfAbsent线程非安全，computeIfAbsent线程安全；<br>返回值：指定key对应的value不存在时，putIfAbsent进行设置并返回null，computeIfAbsent进行计算并返回新值；<br>异常类型：putIfAbsent可能抛出NullPointerException，computeIfAbsent除了NullPointerException，还存在IllegalStateException（）和RuntimeException异常","like_count":9,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486619,"discussion_content":"问题1不太对，ThreadLocalRandom的正确使用方式是ThreadLocalRandom.current().nextX(...)，不能在多线程之间共享ThreadLocalRandom","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583761473,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214337,"discussion_content":"是的，这位同学的回答不太对，merge、compute、computeIfAbsent、putIfAbsent这些单一API都是线程安全（原子性）的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585184073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1046172,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f6/9c/b457a937.jpg","nickname":"不能扮演天使","note":"","ucode":"9922330BFF7FFB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212977,"discussion_content":"putIfAbsent本身是原子操作，怎么能说该方法是线程不安全呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585038805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187888,"user_name":"L.","can_delete":false,"product_type":"c1","uid":1181647,"ip_address":"","ucode":"46A2F679C094E8","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/cf/b0d6fe74.jpg","comment_is_top":false,"comment_ctime":1584265798,"is_pvip":false,"replies":[{"id":"72518","content":"线程安全是指多线程访问的操作ConcurrentHashMap，并不会出现状态不一致，数据错乱，异常等问题。<br><br>原子性在于两个方面：<br><br>第一，ConcurrentHashMap提供的那些针对单一Key读写的API可以认为是线程安全的，但是诸如putAll这种涉及到多个Key的操作，并发读取可能无法确保读取到完整的数据。<br>第二，ConcurrentHashMap只能确保提供的API是线程安全的，但是使用者组合使用多个API，ConcurrentHashMap无法从内部确保使用过程中的状态一致。","user_name":"作者回复","comment_id":187888,"uid":"1001470","ip_address":"","utype":1,"ctime":1584273751,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"35944004166","product_id":100047701,"comment_content":"老师您好，ConcurrentHashMap 只能保证提供的原子性读写操作是线程安全的。能否替小白通俗的解释下 怎么理解这句话的原子性与线程安全？谢谢。","like_count":8,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487283,"discussion_content":"线程安全是指多线程访问的操作ConcurrentHashMap，并不会出现状态不一致，数据错乱，异常等问题。\n\n原子性在于两个方面：\n\n第一，ConcurrentHashMap提供的那些针对单一Key读写的API可以认为是线程安全的，但是诸如putAll这种涉及到多个Key的操作，并发读取可能无法确保读取到完整的数据。\n第二，ConcurrentHashMap只能确保提供的API是线程安全的，但是使用者组合使用多个API，ConcurrentHashMap无法从内部确保使用过程中的状态一致。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584273751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186582,"user_name":"hellojd","can_delete":false,"product_type":"c1","uid":1341697,"ip_address":"","ucode":"4E51807AE7E472","user_header":"https://static001.geekbang.org/account/avatar/00/14/79/01/e71510dc.jpg","comment_is_top":false,"comment_ctime":1583888475,"is_pvip":false,"replies":[{"id":"72044","content":"为了性能，Random用到了compareAndSet + synchronized来解决线程安全问题，虽然可以使用ThreadLocal&lt;Random&gt;来避免竞争，但是无法避免synchronized&#47;compareAndSet带来的开销。考虑到性能还是建议替换使用ThreadLocalRandom（有3倍以上提升），这不是ThreadLocal包装后的Random，而是真正的使用ThreadLocal机制重新实现的Random。","user_name":"作者回复","comment_id":186582,"uid":"1001470","ip_address":"","utype":1,"ctime":1583894324,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"35943626843","product_id":100047701,"comment_content":"ThreadLocalRandom  的使用场景是啥？第一次听说。感觉是为了解决random随机数生成的线程安全问题。线程间传值用TheadLocal就够了","like_count":8,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486804,"discussion_content":"为了性能，Random用到了compareAndSet + synchronized来解决线程安全问题，虽然可以使用ThreadLocal&amp;lt;Random&amp;gt;来避免竞争，但是无法避免synchronized/compareAndSet带来的开销。考虑到性能还是建议替换使用ThreadLocalRandom（有3倍以上提升），这不是ThreadLocal包装后的Random，而是真正的使用ThreadLocal机制重新实现的Random。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583894324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186087,"user_name":"若镜O","can_delete":false,"product_type":"c1","uid":1517354,"ip_address":"","ucode":"6C4D7CA063B387","user_header":"https://static001.geekbang.org/account/avatar/00/17/27/2a/a914cd3f.jpg","comment_is_top":false,"comment_ctime":1583753305,"is_pvip":false,"replies":[{"id":"71887","content":"谢谢","user_name":"作者回复","comment_id":186087,"uid":"1001470","ip_address":"","utype":1,"ctime":1583760824,"user_name_real":"朱晔"}],"discussion_count":2,"race_medal":0,"score":"35943491673","product_id":100047701,"comment_content":"super实战性 ，多谢老师的精心整理..","like_count":8,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486618,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583760824,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1125560,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2c/b8/fcaca637.jpg","nickname":"郭硕","note":"","ucode":"DE7B8F1AEF4087","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381470,"discussion_content":"从来没遇到实战性如此强的教程，分析的非常深入，感谢作者。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625068158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186731,"user_name":"向前走","can_delete":false,"product_type":"c1","uid":1112651,"ip_address":"","ucode":"8956E92DCEFB60","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/4b/c385f755.jpg","comment_is_top":false,"comment_ctime":1583914110,"is_pvip":false,"replies":[{"id":"72065","content":"所谓线程安全问题，只有多线程访问操作共享的资源才会有问题。通常CRUD，获取到的数据，只是局部变量或者是在方法之间串联传递（Controller&#47;Service&#47;Repository），至始至终只有一个线程在操作这些数据，也就是Web服务的工作线程，除非你把这些数据又提及到一个线程池或一个线程去处理。<br><br>当这些list是类的字段的时候就要小心了，尤其是当类又是Bean可能成为单例的话就要更小心了，字段被多个线程并发访问都可能有线程安全问题。<br><br>业务代码一般都是直肠子的CRUD，并且三层架构都是无状态的，如果Controller&#47;Service是有状态的，或是你使用了线程池做一些异步处理，那么需要小心多线程问题。","user_name":"作者回复","comment_id":186731,"uid":"1001470","ip_address":"","utype":1,"ctime":1583916423,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"31648685182","product_id":100047701,"comment_content":"今天终于知道我们平常没有写Thread,或者线程池,其实它工作在Tomcat的容器下,其实它也是在多线程的环境下,也需要注意多线程下的一些线程安全问题。<br>老师,我想问下下面的两个问题<br>1.我们平常在1个方法里,读取mysql的某个表的list数据的时候,在方法里面,用ArrayList来接收,这样会有问题么？<br>   我的理解是首先它在方法里,方法执行时是以栈帧的形式入栈出栈的,栈上面的是线程私有的,所以它是线程安全的,我只是读取,没有修改,那只会不同时候查询出来的数据不一致,可能有新增的数据<br>2.如果在问题1获取到的数据库列表数据里,进行一些添加和删除操作列表元素,比如我获取到数据库列表的数据后,要加一排合计字段到list中,这样它还是线程安全的么？<br>    是不是只有在类上定义的成员变量,（各种共享资源)如数组,map,list,然后在某个方法里去操作这个共享的集合时才会存在线程安全问题呢<br>不知道我的理解是不是正确呢,辛苦老师了","like_count":7,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486856,"discussion_content":"所谓线程安全问题，只有多线程访问操作共享的资源才会有问题。通常CRUD，获取到的数据，只是局部变量或者是在方法之间串联传递（Controller/Service/Repository），至始至终只有一个线程在操作这些数据，也就是Web服务的工作线程，除非你把这些数据又提及到一个线程池或一个线程去处理。\n\n当这些list是类的字段的时候就要小心了，尤其是当类又是Bean可能成为单例的话就要更小心了，字段被多个线程并发访问都可能有线程安全问题。\n\n业务代码一般都是直肠子的CRUD，并且三层架构都是无状态的，如果Controller/Service是有状态的，或是你使用了线程池做一些异步处理，那么需要小心多线程问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583916423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187456,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1584113519,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23058949999","product_id":100047701,"comment_content":"lambda看起来真的是起劲。要好好补补课。","like_count":6},{"had_liked":false,"id":189527,"user_name":"yihang","can_delete":false,"product_type":"c1","uid":1012361,"ip_address":"","ucode":"A5506F085D1793","user_header":"https://static001.geekbang.org/account/avatar/00/0f/72/89/1a83120a.jpg","comment_is_top":false,"comment_ctime":1584525169,"is_pvip":false,"replies":[{"id":"73026","content":"嗯，锁开销在这里不是主要问题，并发下ThreadLocalRandom会比ThreadLocal&lt;Random&gt;性能好不少，估计在3到8倍左右，既然性能更高就没必要用后者，至于为什么前者会更快你可以继续研究一下<br><br>我想了一下，使用ThreadLocal&lt;Random&gt;其实是两个过程，先是从ThreadLocal获得Random，这个开销其实不少的，而ThreadLocalRandom是直接使用unsafe从thread上去拿信息的，2步变为1步，这个开销不得不考虑","user_name":"作者回复","comment_id":189527,"uid":"1001470","ip_address":"","utype":1,"ctime":1584526846,"user_name_real":"朱晔"}],"discussion_count":4,"race_medal":0,"score":"18764394353","product_id":100047701,"comment_content":"还是有疑问❓看了Random源码，只有setSeed方法加了synchronized，而它只会在实现类并非Random类时才会调用（139行），那么这同步开销从何而来？只有next方法是用了cas。","like_count":4,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487723,"discussion_content":"嗯，锁开销在这里不是主要问题，并发下ThreadLocalRandom会比ThreadLocal&amp;lt;Random&amp;gt;性能好不少，估计在3到8倍左右，既然性能更高就没必要用后者，至于为什么前者会更快你可以继续研究一下\n\n我想了一下，使用ThreadLocal&amp;lt;Random&amp;gt;其实是两个过程，先是从ThreadLocal获得Random，这个开销其实不少的，而ThreadLocalRandom是直接使用unsafe从thread上去拿信息的，2步变为1步，这个开销不得不考虑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584526846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1012361,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/72/89/1a83120a.jpg","nickname":"yihang","note":"","ucode":"A5506F085D1793","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209100,"discussion_content":"好的，非常感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584609750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1012361,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/72/89/1a83120a.jpg","nickname":"yihang","note":"","ucode":"A5506F085D1793","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":208199,"discussion_content":"经过简单测试，性能确实比ThreadLocal +Random快很多。但查阅了一些文章，有的说性能提升来自于方法 inline ，有的说来自于 @contented消除伪共享，，我把jit关掉后仍有1倍左右性能差距，暂时不知道怎么去验证究竟哪一项对性能提升影响较大…","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584539008,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1012361,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/72/89/1a83120a.jpg","nickname":"yihang","note":"","ucode":"A5506F085D1793","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":207944,"discussion_content":"好的，谢谢，我再研究一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584526947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187487,"user_name":"刘大明","can_delete":false,"product_type":"c1","uid":1035081,"ip_address":"","ucode":"83C063FBD9BF2B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/49/0b9ffc8e.jpg","comment_is_top":false,"comment_ctime":1584143430,"is_pvip":false,"replies":[{"id":"72356","content":"1. 所有并发工具全部自己做一遍实验，写一下demo<br>2. 需要时间，下周的加餐我会再来介绍一下lambda的学习","user_name":"作者回复","comment_id":187487,"uid":"1001470","ip_address":"","utype":1,"ctime":1584146875,"user_name_real":"朱晔"}],"discussion_count":4,"race_medal":0,"score":"18764012614","product_id":100047701,"comment_content":"今天早上5点起来,配置老师的环境,实际的跑一遍老师的代码.学到很多.而且也看到了自己很多知识点的欠缺.<br>1.很多并发知识并不知道怎么用,怎么学呢?<br>2.怎么像老师一样熟练学lambda表达式.<br>希望跟着老师专栏学习的同时,也能好好补一下其他的知识点.","like_count":4,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487119,"discussion_content":"1. 所有并发工具全部自己做一遍实验，写一下demo\n2. 需要时间，下周的加餐我会再来介绍一下lambda的学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584146875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1910554,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLQaWXfpntwPsfE7fSYicU9mfIhEhcu7cBflRNFR2iaKDQswEtWz3iaLj3n2ia76rUrWLUpyE2BQNoXug/132","nickname":"howie","note":"","ucode":"75063AB9638A8A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":207068,"discussion_content":"我的项目跑不起来，不知道怎样配置呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584458803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1035081,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cb/49/0b9ffc8e.jpg","nickname":"刘大明","note":"","ucode":"83C063FBD9BF2B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1910554,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLQaWXfpntwPsfE7fSYicU9mfIhEhcu7cBflRNFR2iaKDQswEtWz3iaLj3n2ia76rUrWLUpyE2BQNoXug/132","nickname":"howie","note":"","ucode":"75063AB9638A8A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":207771,"discussion_content":"注释配置文件里面的信息，注释pom文件相应的包。注释docker compose文件","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584513422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":207068,"ip_address":""},"score":207771,"extra":""}]},{"author":{"id":1035081,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cb/49/0b9ffc8e.jpg","nickname":"刘大明","note":"","ucode":"83C063FBD9BF2B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":204226,"discussion_content":"好的。谢谢老师指点。确实需要自己实际操作一遍才能知道那些工具怎么用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584146949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186165,"user_name":"小氘","can_delete":false,"product_type":"c1","uid":1622109,"ip_address":"","ucode":"DA55B9A02D9EE0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erPMtAfnQdpx1yOZQ2ic7icqUs3tvibEjUXQMUXKiaakyuIho6k6vmdl46nrdWjXIjPIRg9Pmco00tR5w/132","comment_is_top":false,"comment_ctime":1583768460,"is_pvip":false,"replies":[{"id":"71927","content":"👍🏻","user_name":"作者回复","comment_id":186165,"uid":"1001470","ip_address":"","utype":1,"ctime":1583807592,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"18763637644","product_id":100047701,"comment_content":"课后思考题：<br>1 不能。ThreadLocalRandom的用法是每个线程各用各的，官方文档说ThreadLocalRandom.current().nextX(...)这么用就不会导致在多线程之间共享。<br>2 他们都是原子操作，都会根据key的存在情况做后续操作，putIfAbsent不会对value处理，computeIfAbsent的第二个参数是Function接口可做的更多。","like_count":4,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486654,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583807592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186059,"user_name":"听雨","can_delete":false,"product_type":"c1","uid":1254493,"ip_address":"","ucode":"252754F9FCFF0C","user_header":"https://static001.geekbang.org/account/avatar/00/13/24/5d/65e61dcb.jpg","comment_is_top":false,"comment_ctime":1583747519,"is_pvip":false,"replies":[{"id":"71882","content":"看一下tabAt方法，其使用Unsafe的getObjectVolatile直接读取内存数据","user_name":"作者回复","comment_id":186059,"uid":"1001470","ip_address":"","utype":1,"ctime":1583752798,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"18763616703","product_id":100047701,"comment_content":"ConcurrentHashMap怎么保证内部数组元素的可见性呢，我看源码里只用volatile修饰了table，但是volatile也保证不了数组里面元素的可见性呀，还请老师解惑！","like_count":4,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486603,"discussion_content":"看一下tabAt方法，其使用Unsafe的getObjectVolatile直接读取内存数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583752798,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203296,"user_name":"syp","can_delete":false,"product_type":"c1","uid":1744207,"ip_address":"","ucode":"6BD6EC19039E88","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9d/4f/4c12de43.jpg","comment_is_top":false,"comment_ctime":1586167906,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14471069794","product_id":100047701,"comment_content":"把所有评论和老师的解答全看了一遍竟然有了更深的理解，正所谓授业解惑👍","like_count":3},{"had_liked":false,"id":193852,"user_name":"justin","can_delete":false,"product_type":"c1","uid":1178721,"ip_address":"","ucode":"8EEB37B7914975","user_header":"https://static001.geekbang.org/account/avatar/00/11/fc/61/241b5c75.jpg","comment_is_top":false,"comment_ctime":1584973823,"is_pvip":false,"replies":[{"id":"73874","content":"还是看项目的需求，如果只是CRUD项目的话，就像你说的，三层都是无状态直通数据库，缓存和锁都是分布式的。如果开发一些有状态的服务，比如批处理任务或基础服务，那么有需要线程安全的HashMap的地方就可以替换为ConcurrentHashMap。","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1585013964,"ip_address":"","comment_id":193852,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14469875711","product_id":100047701,"comment_content":"老师，咨询下，就是现在基本都是分布式的环境，加锁平时也是用分布式锁，像juc中的一些工具如ConcurrentHashMap这些如何在当前环境中发挥作用。","like_count":3,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488681,"discussion_content":"还是看项目的需求，如果只是CRUD项目的话，就像你说的，三层都是无状态直通数据库，缓存和锁都是分布式的。如果开发一些有状态的服务，比如批处理任务或基础服务，那么有需要线程安全的HashMap的地方就可以替换为ConcurrentHashMap。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585013964,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191331,"user_name":"丁乐洪","can_delete":false,"product_type":"c1","uid":1264392,"ip_address":"","ucode":"549CE57AB20B49","user_header":"https://static001.geekbang.org/account/avatar/00/13/4b/08/52954cd7.jpg","comment_is_top":false,"comment_ctime":1584764079,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14469665967","product_id":100047701,"comment_content":"对concurrenthashmap有了深入了解了，下次要在实战中多多应用","like_count":3},{"had_liked":false,"id":189264,"user_name":"看不到de颜色","can_delete":false,"product_type":"c1","uid":1162714,"ip_address":"","ucode":"88348CCAE81931","user_header":"https://static001.geekbang.org/account/avatar/00/11/bd/da/3d76ea74.jpg","comment_is_top":false,"comment_ctime":1584494424,"is_pvip":false,"replies":[{"id":"72995","content":"ArrayList要确保线程安全需要上锁，CopyOnWriteArrayList读取的时候不需要锁，肯定不能比","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584498041,"ip_address":"","comment_id":189264,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14469396312","product_id":100047701,"comment_content":"有一点疑惑，还请老师解答。为什么在纯读取环境下CopyOnWrite会比ArrayList快5倍。我理解在纯读取并发场景下CopyOnWrite就退化成一个普通的ArrayList不是吗。","like_count":3,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487655,"discussion_content":"ArrayList要确保线程安全需要上锁，CopyOnWriteArrayList读取的时候不需要锁，肯定不能比","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584498041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1965236,"avatar":"","nickname":"Geek_c703f7","note":"","ucode":"0D49860F83534E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283743,"discussion_content":"ArrayList读取的时候为何要上锁？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592355606,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1045090,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f2/62/f873cd8f.jpg","nickname":"tongmin_tsai","note":"","ucode":"D9423E770D5846","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1965236,"avatar":"","nickname":"Geek_c703f7","note":"","ucode":"0D49860F83534E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291872,"discussion_content":"可以看看Collections.synchronizedList的源码，最终转换为SynchronizedRandomAccessList，public E get(int index) {\n            synchronized (mutex) {return list.get(index);}\n        }","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594982241,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":283743,"ip_address":""},"score":291872,"extra":""}]}]},{"had_liked":false,"id":187091,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1584010742,"is_pvip":false,"replies":[{"id":"72175","content":"都是公共库，如果网络问题的话，可以想办法找一个更快的国内镜像","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584013375,"ip_address":"","comment_id":187091,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14468912630","product_id":100047701,"comment_content":"很多依赖包都下载不下来，链接的代码","like_count":3,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486986,"discussion_content":"都是公共库，如果网络问题的话，可以想办法找一个更快的国内镜像","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584013375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186606,"user_name":"喵喵喵","can_delete":false,"product_type":"c1","uid":1211713,"ip_address":"","ucode":"E3AD8BF42E19DF","user_header":"https://static001.geekbang.org/account/avatar/00/12/7d/41/3c5b770b.jpg","comment_is_top":false,"comment_ctime":1583890871,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14468792759","product_id":100047701,"comment_content":"打卡～","like_count":3},{"had_liked":false,"id":186551,"user_name":"innocent","can_delete":false,"product_type":"c1","uid":1197455,"ip_address":"","ucode":"368659A0DDE7E4","user_header":"https://static001.geekbang.org/account/avatar/00/12/45/8f/a56b2214.jpg","comment_is_top":false,"comment_ctime":1583866417,"is_pvip":false,"replies":[{"id":"72041","content":"：）","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1583891435,"ip_address":"","comment_id":186551,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14468768305","product_id":100047701,"comment_content":"突然想到之前面试官问我在使用线程池情况下，ThreadLocal会出现什么问题","like_count":3,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486800,"discussion_content":"：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583891435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186398,"user_name":"hhhh","can_delete":false,"product_type":"c1","uid":1256101,"ip_address":"","ucode":"9E87017424B382","user_header":"https://static001.geekbang.org/account/avatar/00/13/2a/a5/625c0a2e.jpg","comment_is_top":false,"comment_ctime":1583836198,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14468738086","product_id":100047701,"comment_content":"1. 不能哦，参考jdk文档，它的使用方式是ThreadLocalRandom.current().nextX(...) ，current()方法用来获取当前线程对象的ThreadLocalRandom变量，如果将其声明为静态变量，意味着所有线程使用某一个线程的ThreadLocalRandom，违背这个类的使用原则。<br>2. putIfAbsent(key, value)与computeIfAbsent(key, value)的区别在于，前者提供值，后者提供计算该值的方法，后者灵活性更好一些","like_count":3},{"had_liked":false,"id":221375,"user_name":"MrCreep","can_delete":false,"product_type":"c1","uid":1026641,"ip_address":"","ucode":"E5F481B82BE3E9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/FIP7jdV0a9XzhP0ezpmDs5gCOCcIBicfYnIo9WiczG2WsmxBkvicv6ZDEOVPDHjsa5pnPzIonjYo4YYficK4WdwiaHg/132","comment_is_top":false,"comment_ctime":1590484783,"is_pvip":false,"replies":[{"id":"81651","content":"非常好，不过你这里的双重检查写的有点问题，第二次需要重新取一下：<br><br>ForkJoinPool forkJoinPool = new ForkJoinPool(THREAD_COUNT);<br>        forkJoinPool.execute(() -&gt; IntStream.rangeClosed(1, LOOP_COUNT).parallel().forEach(i -&gt; {<br>                    String key = &quot;item&quot; + ThreadLocalRandom.current().nextInt(ITEM_COUNT);<br>                    LongAdder adder = freqs.get(key);<br>                    if (adder == null) {<br>                        synchronized (freqs) {<br>                            adder = freqs.get(key);<br>                            if (adder == null) {<br>                                adder = new LongAdder();<br>                                freqs.put(key, adder);<br>                            }<br>                        }<br>                    }<br>                    adder.increment();<br>                }<br>        ));<br><br>这种方式对于这个ITEM_COUNT很小的特定场景是更快的做法（缺点是代码会繁琐点），毕竟双重检查的方式只是首次Key不存在的时候会锁一下。当ITEM_COUNT和LOOP_COUNT差距没有那么大的时候，这种写法没有明显优势，因为这个时候靠不上太多LongAdder的加速。<br><br>比如：<br>private static int LOOP_COUNT = 100000000;<br>    private static int THREAD_COUNT = 100;<br>    private static int ITEM_COUNT = 10000000;","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1590490707,"ip_address":"","comment_id":221375,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10180419375","product_id":100047701,"comment_content":"关于ConcurrentHashMap的case，我觉得快的原因并不是CAS的效率，而是锁的代码块和用到了LongAdder。<br><br>如果改成下面那样，同样是用synchronized加锁，他的运行速度更快<br>        ConcurrentHashMap&lt;String, LongAdder&gt; freqs = new ConcurrentHashMap&lt;&gt;(ITEM_COUNT);<br>        ForkJoinPool forkJoinPool = new ForkJoinPool(THREAD_COUNT);<br>        forkJoinPool.execute(() -&gt; IntStream.rangeClosed(1, LOOP_COUNT).parallel().forEach(i -&gt; {<br>                    &#47;&#47;获得一个随机的Key<br>                    String key = &quot;item&quot; + ThreadLocalRandom.current().nextInt(ITEM_COUNT);<br>                    LongAdder adder = freqs.get(key);<br>                    if (adder == null) {<br>                        synchronized (freqs) {<br>                            if (adder == null) {<br>                                adder = new LongAdder();<br>                                freqs.put(key, adder);<br>                            }<br>                        }<br>                    }<br>                    adder.increment();<br>                }<br>        ));<br>        forkJoinPool.shutdown();<br>        forkJoinPool.awaitTermination(1, TimeUnit.HOURS);<br>        return freqs;","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496439,"discussion_content":"非常好，不过你这里的双重检查写的有点问题，第二次需要重新取一下：\n\nForkJoinPool forkJoinPool = new ForkJoinPool(THREAD_COUNT);\n        forkJoinPool.execute(() -&amp;gt; IntStream.rangeClosed(1, LOOP_COUNT).parallel().forEach(i -&amp;gt; {\n                    String key = &amp;quot;item&amp;quot; + ThreadLocalRandom.current().nextInt(ITEM_COUNT);\n                    LongAdder adder = freqs.get(key);\n                    if (adder == null) {\n                        synchronized (freqs) {\n                            adder = freqs.get(key);\n                            if (adder == null) {\n                                adder = new LongAdder();\n                                freqs.put(key, adder);\n                            }\n                        }\n                    }\n                    adder.increment();\n                }\n        ));\n\n这种方式对于这个ITEM_COUNT很小的特定场景是更快的做法（缺点是代码会繁琐点），毕竟双重检查的方式只是首次Key不存在的时候会锁一下。当ITEM_COUNT和LOOP_COUNT差距没有那么大的时候，这种写法没有明显优势，因为这个时候靠不上太多LongAdder的加速。\n\n比如：\nprivate static int LOOP_COUNT = 100000000;\n    private static int THREAD_COUNT = 100;\n    private static int ITEM_COUNT = 10000000;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590490707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":194250,"user_name":"不能扮演天使","can_delete":false,"product_type":"c1","uid":1046172,"ip_address":"","ucode":"9922330BFF7FFB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f6/9c/b457a937.jpg","comment_is_top":false,"comment_ctime":1585041577,"is_pvip":false,"replies":[{"id":"73984","content":"1、merge、compute、computeIfAbsent、putIfAbsent这些单一API都是线程安全（原子性）的<br>2、freqs.computeIfAbsent(key, k -&gt; new LongAdder()).increment(); Map中保存的是LongAdder（是一个引用，并不是一个值），并不是说increment()后再put回去，而是直接操作这个线程安全的LongAdder","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1585046011,"ip_address":"","comment_id":194250,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10174976169","product_id":100047701,"comment_content":"老师，看评论区有人说putIfAbsent不是线程安全，putIfAbsent和put同样调用putVal方法，有对node进行synchronized是原子的吧；还有freqs.computeIfAbsent(key, k -&gt; new LongAdder()).increment();这种写法computeIfAbsent已经操作完了再进行increment会回填到map?为啥会有这种写法？虽然试了下这样写确实填入的是increment后的值；还望老师解答","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488791,"discussion_content":"1、merge、compute、computeIfAbsent、putIfAbsent这些单一API都是线程安全（原子性）的\n2、freqs.computeIfAbsent(key, k -&amp;gt; new LongAdder()).increment(); Map中保存的是LongAdder（是一个引用，并不是一个值），并不是说increment()后再put回去，而是直接操作这个线程安全的LongAdder","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585046011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191649,"user_name":"丁乐洪","can_delete":false,"product_type":"c1","uid":1264392,"ip_address":"","ucode":"549CE57AB20B49","user_header":"https://static001.geekbang.org/account/avatar/00/13/4b/08/52954cd7.jpg","comment_is_top":false,"comment_ctime":1584786672,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10174721264","product_id":100047701,"comment_content":"ThreadLocal里的资源只能给当前线程用，不能被别的线程读到。<br>ThreadLocal值应该是使用完后清除吧，没使用就清除就成了无效保存。","like_count":2},{"had_liked":false,"id":191324,"user_name":"丁乐洪","can_delete":false,"product_type":"c1","uid":1264392,"ip_address":"","ucode":"549CE57AB20B49","user_header":"https://static001.geekbang.org/account/avatar/00/13/4b/08/52954cd7.jpg","comment_is_top":false,"comment_ctime":1584763515,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10174698107","product_id":100047701,"comment_content":"只会使用工具，不知原理是个大问题","like_count":2},{"had_liked":false,"id":189620,"user_name":"W","can_delete":false,"product_type":"c1","uid":1921315,"ip_address":"","ucode":"9434684DE2EFFB","user_header":"https://static001.geekbang.org/account/avatar/00/1d/51/23/36bc8745.jpg","comment_is_top":false,"comment_ctime":1584534799,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10174469391","product_id":100047701,"comment_content":"对线程的了解又多了一点","like_count":2},{"had_liked":false,"id":189520,"user_name":"yihang","can_delete":false,"product_type":"c1","uid":1012361,"ip_address":"","ucode":"A5506F085D1793","user_header":"https://static001.geekbang.org/account/avatar/00/0f/72/89/1a83120a.jpg","comment_is_top":false,"comment_ctime":1584524574,"is_pvip":false,"replies":[{"id":"73024","content":"可以看下置顶我的回复","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584524751,"ip_address":"","comment_id":189520,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10174459166","product_id":100047701,"comment_content":"对于思考题第一题，看了源码，有以下疑问🤔️：如果每个线程创建自己的 random 对象，那么不就没有cas竞争，效果上等价于 threadLocalRandom了么？","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487718,"discussion_content":"可以看下置顶我的回复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584524751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189024,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1274787,"ip_address":"","ucode":"C233DF1D224EC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","comment_is_top":false,"comment_ctime":1584447294,"is_pvip":true,"replies":[{"id":"72908","content":"感谢分享","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584448867,"ip_address":"","comment_id":189024,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10174381886","product_id":100047701,"comment_content":"遇到过一个坑，项目是获取流水ID，接口用流水ID去排序了，误以为流水ID是先产生的就会小点，测试环境是单服务应用，生产是集群模式，结果到生产出来了莫名其妙的bug,没有弄清楚sequence table的生成逻辑，其实是预先分配，按照某个步长新增的，不同机器服务产生ID的大小和产生ID的时间没有绝对的关联。老师说的用某个东西一定要弄明白里面的逻辑或者使用场景，否则就会拿生产问题买教训。","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487592,"discussion_content":"感谢分享","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584448867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188514,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1584363468,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10174298060","product_id":100047701,"comment_content":"老师不仅并发编程牛，还是个lambda高手，虚心学习","like_count":2},{"had_liked":false,"id":188400,"user_name":"程序员小跃","can_delete":false,"product_type":"c1","uid":1015483,"ip_address":"","ucode":"25BB96E0791A60","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","comment_is_top":false,"comment_ctime":1584350035,"is_pvip":true,"replies":[{"id":"72691","content":"：）","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584350799,"ip_address":"","comment_id":188400,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10174284627","product_id":100047701,"comment_content":"老师举的几个例子，我仿佛一个个都想对号入座，你文章说的有些人，不就是我么。<br><br>这门课一上来就给我这么大的感受，受教了。我平时真的是一股脑来就用线程安全的容器，不管三七二十一，现在明白，还得专门针对功能，专门应对呀<br><br>","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487395,"discussion_content":"：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584350799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188335,"user_name":"婷","can_delete":false,"product_type":"c1","uid":1612372,"ip_address":"","ucode":"1264B8F777B7CD","user_header":"https://static001.geekbang.org/account/avatar/00/18/9a/54/5d51fda4.jpg","comment_is_top":false,"comment_ctime":1584342270,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10174276862","product_id":100047701,"comment_content":"学起来很带劲 非常感谢老师","like_count":2},{"had_liked":false,"id":187910,"user_name":"Xfactor","can_delete":false,"product_type":"c1","uid":1441947,"ip_address":"","ucode":"E40E89CD43ABBC","user_header":"https://static001.geekbang.org/account/avatar/00/16/00/9b/45c97204.jpg","comment_is_top":false,"comment_ctime":1584275749,"is_pvip":true,"replies":[{"id":"72536","content":"这里的IntStream.rangeClosed(1, 10).parallel().forEach...这行代码本身就是模拟一个并发环境。对于这个例子，其实可以不用这么写，我们需要的只是模拟10个并发来操作concurrenthashmap，可以改写为直接通过forkJoinPool.execute（或者是普通线程池也行）来提交10个修改任务，或者就是启10个线程也行，都是一样的效果","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584282026,"ip_address":"","comment_id":187910,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10174210341","product_id":100047701,"comment_content":"new ForkJoinPool(THREAD_COUNT) 这个地方创建了10个线程缓存起来，forkJoinPool.execute(）里面写具体的并发逻辑代是不是就可以了？为什么还有IntStream.rangeClosed(1, 10).parallel().forEach这个，不是太明白代码的意思，还请老师指教？","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487291,"discussion_content":"这里的IntStream.rangeClosed(1, 10).parallel().forEach...这行代码本身就是模拟一个并发环境。对于这个例子，其实可以不用这么写，我们需要的只是模拟10个并发来操作concurrenthashmap，可以改写为直接通过forkJoinPool.execute（或者是普通线程池也行）来提交10个修改任务，或者就是启10个线程也行，都是一样的效果","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584282026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187601,"user_name":"Mr wind","can_delete":false,"product_type":"c1","uid":1217874,"ip_address":"","ucode":"484F02D1962239","user_header":"https://static001.geekbang.org/account/avatar/00/12/95/52/ad190682.jpg","comment_is_top":false,"comment_ctime":1584169605,"is_pvip":false,"replies":[{"id":"72415","content":"对于controller没有区别，ThreadLocal的最佳实践是static的，文档也有提到：<br>ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).<br>我改下代码","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584185407,"ip_address":"","comment_id":187601,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10174104197","product_id":100047701,"comment_content":"谢谢老师，我看有些地方别人用ThreadLocal是使用的static，private final static ThreadLocal&lt;Integer&gt; ，当然在老师的例子中controller中spring管理下本身是单例，那么成员变量ThreadLocal也是单例的。虽然两者看起来都是符合单例的。不过问一下老师这两种用法有什么区别吗","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487162,"discussion_content":"对于controller没有区别，ThreadLocal的最佳实践是static的，文档也有提到：\nThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).\n我改下代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584185407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187461,"user_name":"better","can_delete":false,"product_type":"c1","uid":1257750,"ip_address":"","ucode":"2B9BCCED753D7F","user_header":"https://static001.geekbang.org/account/avatar/00/13/31/16/f2269e73.jpg","comment_is_top":false,"comment_ctime":1584115155,"is_pvip":true,"replies":[{"id":"72355","content":"加油","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584146826,"ip_address":"","comment_id":187461,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10174049747","product_id":100047701,"comment_content":"学习感悟：<br>终于把第一篇文章学习完了，边看边做笔记，文章中所有的示例代码也都跟着敲了一遍，但是没去IDE里运行起来，争取后面在本地中搭建一个工程来跑这些示例代码，自己实践一遍，看看运行结果是否和老师文章中的相同，这样也能加深一下这些知识点的印象。<br><br>另外就是代码中用到了lambda表达式的知识，正好是我的一个知识盲区，第一遍示例代码跟下来还有些看不太明白的代码，这两天找时间学习一下相关的lambda的知识，然后再回过头来看一遍示例代码，争取弄懂，我觉得这就好比在工作中，用到什么技术，就补什么技术一样的道理，对于后面的文章遇到的不懂的技术点或代码，也采取同样的思路。<br><br>最后就是感叹老师的专栏，真的实战性非常强。去年年底的时候就期待极客时间今年的专栏偏实战一点，到了今年，真的明显感受到了实战性提高了不少，感谢极客时间，也感谢老师","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487112,"discussion_content":"加油","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584146826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187226,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1584065177,"is_pvip":false,"replies":[{"id":"72269","content":"docker-compose先要up，项目起不起来就是这些外部依赖没有启动，可以先注释pom中所有涉及到es、rabbitmq的依赖","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584073820,"ip_address":"","comment_id":187226,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10173999769","product_id":100047701,"comment_content":"注释了docker-compose.yml还有properties群架文件还是单独启动不起来，去做监控检测，es,rabbitmq,这是什么情况","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487035,"discussion_content":"docker-compose先要up，项目起不起来就是这些外部依赖没有启动，可以先注释pom中所有涉及到es、rabbitmq的依赖","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584073820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187140,"user_name":"Minasix","can_delete":false,"product_type":"c1","uid":1795474,"ip_address":"","ucode":"6252A1A4A18799","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqMib1RDh7yMjERiaFvmay128fZw7EWOvUgL08WaxvxtrqBFqjezOTurR1ZnHbicAdiaCy5uwfQJwZicCg/132","comment_is_top":false,"comment_ctime":1584024509,"is_pvip":true,"replies":[{"id":"72226","content":"谢谢支持","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584059232,"ip_address":"","comment_id":187140,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10173959101","product_id":100047701,"comment_content":"老师太强了，绝对超值的好课","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487006,"discussion_content":"谢谢支持","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584059232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186414,"user_name":"终结者999号","can_delete":false,"product_type":"c1","uid":1055854,"ip_address":"","ucode":"33ADE61580B6DD","user_header":"https://static001.geekbang.org/account/avatar/00/10/1c/6e/6c5f5734.jpg","comment_is_top":false,"comment_ctime":1583841248,"is_pvip":true,"replies":[{"id":"71998","content":"的确是写错了","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1583843463,"ip_address":"","comment_id":186414,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10173775840","product_id":100047701,"comment_content":"老师，您好，关于ConcurrentHashMap的例子中：<br>使用 ConcurrentHashMap 来统计，Key 的范围是 10。<br>这里的key的范围应该是0-1000吧<br>我看您的代码中描述的","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486744,"discussion_content":"的确是写错了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583843463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186412,"user_name":"一道阳光","can_delete":false,"product_type":"c1","uid":1239557,"ip_address":"","ucode":"F35207CCCEC6E2","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/05/c0d8014d.jpg","comment_is_top":false,"comment_ctime":1583840529,"is_pvip":false,"replies":[{"id":"72009","content":"不行，请注意文档中的这句话『Bear in mind that the results of aggregate status methods including size, isEmpty, and containsValue are typically useful only when a map is not undergoing concurrent updates in other threads. Otherwise the results of these methods reflect transient states that may be adequate for monitoring or estimation purposes, but not for program control.』","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1583845964,"ip_address":"","comment_id":186412,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10173775121","product_id":100047701,"comment_content":"currenthashmap中锁的时间太长了，建议把putall方法移出去。我们只要控制补充size在多线程下是准确的就ok，本来想进一步优化，把补充的size设置成原子类，但发现map. size方法的统计类似于longadder，累加计数单元。这个不是原子花操作，估计计算的时候有问题。但后来想我们的synchronized优化后，感觉是轻量级锁，这样线程交替运行也不会有多大性能损耗。不知道说的正不正确","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486743,"discussion_content":"不行，请注意文档中的这句话『Bear in mind that the results of aggregate status methods including size, isEmpty, and containsValue are typically useful only when a map is not undergoing concurrent updates in other threads. Otherwise the results of these methods reflect transient states that may be adequate for monitoring or estimation purposes, but not for program control.』","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583845964,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186395,"user_name":"kyl","can_delete":false,"product_type":"c1","uid":1406090,"ip_address":"","ucode":"DBDFD0FEB5A135","user_header":"https://static001.geekbang.org/account/avatar/00/15/74/8a/d5b0cf30.jpg","comment_is_top":false,"comment_ctime":1583834552,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10173769144","product_id":100047701,"comment_content":"课程非常棒，很贴合实际。","like_count":2},{"had_liked":false,"id":186208,"user_name":"徐云天","can_delete":false,"product_type":"c1","uid":1212091,"ip_address":"","ucode":"D48DBF0B3C2CA3","user_header":"https://static001.geekbang.org/account/avatar/00/12/7e/bb/019c18fc.jpg","comment_is_top":false,"comment_ctime":1583800166,"is_pvip":false,"replies":[{"id":"71925","content":"清的目的是一可以防止内存泄露，二可以防止其它线程拿到不属于这个线程的资源，ThreadLocal里的资源只能给当前线程用，不能被别的线程读到。但是不代表完全没有用。","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1583807497,"ip_address":"","comment_id":186208,"utype":1}],"discussion_count":4,"race_medal":0,"score":"10173734758","product_id":100047701,"comment_content":"那个threadlocal用完把它值清了，还用它干嘛，不是多此一举么？","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486676,"discussion_content":"清的目的是一可以防止内存泄露，二可以防止其它线程拿到不属于这个线程的资源，ThreadLocal里的资源只能给当前线程用，不能被别的线程读到。但是不代表完全没有用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583807497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1045090,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f2/62/f873cd8f.jpg","nickname":"tongmin_tsai","note":"","ucode":"D9423E770D5846","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291874,"discussion_content":"如果用spring security的话，UserDetails loadUserByUsername(String username) throws UsernameNotFoundException，如果在这个方法里面，你需要传递额外的参数，传不过去，这时可以使用ThreadLocal来传","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594982611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066046,"avatar":"https://static001.geekbang.org/account/avatar/00/10/44/3e/493e73fa.jpg","nickname":"灰太狼","note":"","ucode":"C17DD5D5ED9DC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":227465,"discussion_content":"示例代码相对简单，实际业务会调用各种业务方法，所有业务完成之后必须清除，防止下一个访问的线程是重用的出现错误数据。示例代码是模拟了业务","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586494411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066046,"avatar":"https://static001.geekbang.org/account/avatar/00/10/44/3e/493e73fa.jpg","nickname":"灰太狼","note":"","ucode":"C17DD5D5ED9DC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":227461,"discussion_content":"老师说的很在理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586494208,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186170,"user_name":"泛岁月的涟漪","can_delete":false,"product_type":"c1","uid":1104605,"ip_address":"","ucode":"1C27878EFBD3CC","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/dd/c9735ee8.jpg","comment_is_top":false,"comment_ctime":1583770108,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10173704700","product_id":100047701,"comment_content":"刚工作第一个月就遇到了ThreadLocal重用的问题，在设置用户信息之前使用ThreadLocal获取当前用户信息导致获取到的用户信息不对","like_count":2},{"had_liked":false,"id":226377,"user_name":"天天向上","can_delete":false,"product_type":"c1","uid":1242455,"ip_address":"","ucode":"0CCCA6F4DCC480","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg","comment_is_top":false,"comment_ctime":1592056015,"is_pvip":false,"replies":[{"id":"83372","content":"ThreadLocalMap的key就是ThreadLocal，如果ThreadLocal还在，ThreadLocalMap的key怎么会回收呢，弱引用只是说没有其它强引用的时候gc后可以回收对象，不代表能忽略其它强引用","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1592097354,"ip_address":"","comment_id":226377,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5887023311","product_id":100047701,"comment_content":"ThreadLocal中的ThreadLocalMap的key不是弱引用吗，如果set之后，经历了GC，那么再get是否就get不到了？<br>老师回复: 不会，Thread还引用着ThreadLocal<br>我的疑问是，虽然Thread还引用着ThreadLocal，但是ThreadLocalMap的key都被回收了，那get怎么还能get到它的value呢。<br>","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498219,"discussion_content":"ThreadLocalMap的key就是ThreadLocal，如果ThreadLocal还在，ThreadLocalMap的key怎么会回收呢，弱引用只是说没有其它强引用的时候gc后可以回收对象，不代表能忽略其它强引用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592097354,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220115,"user_name":"荒川之主","can_delete":false,"product_type":"c1","uid":2000330,"ip_address":"","ucode":"12724B4B37BEB5","user_header":"https://static001.geekbang.org/account/avatar/00/1e/85/ca/e6003d08.jpg","comment_is_top":false,"comment_ctime":1590159823,"is_pvip":false,"replies":[{"id":"81266","content":"感谢认可","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1590191727,"ip_address":"","comment_id":220115,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5885127119","product_id":100047701,"comment_content":"买的最值的一门课","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496049,"discussion_content":"感谢认可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590191727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213948,"user_name":"Eric","can_delete":false,"product_type":"c1","uid":1053498,"ip_address":"","ucode":"59752A51A382A6","user_header":"https://static001.geekbang.org/account/avatar/00/10/13/3a/b0454322.jpg","comment_is_top":false,"comment_ctime":1588596989,"is_pvip":false,"replies":[{"id":"79255","content":"😀","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1588598914,"ip_address":"","comment_id":213948,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5883564285","product_id":100047701,"comment_content":"这个专栏应该是Java工程师 最爱看的了，哈哈","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493908,"discussion_content":"😀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588598914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208354,"user_name":"小李讲源码","can_delete":false,"product_type":"c1","uid":1107484,"ip_address":"","ucode":"2573037D7C82C8","user_header":"https://static001.geekbang.org/account/avatar/00/10/e6/1c/9d3744ee.jpg","comment_is_top":false,"comment_ctime":1587344405,"is_pvip":true,"replies":[{"id":"77812","content":"欢迎点赞转发","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1587346040,"ip_address":"","comment_id":208354,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5882311701","product_id":100047701,"comment_content":"老师讲的真好，让我重拾起学习的乐趣。谢谢！<br><br>我学习Java没有系统的学习过多线程，因为觉得晦涩，在业务开发中用的很少，因为量小。但是阅读完这篇内容，其实多线程无处不在，我们使用的web容器等都会用到。而且并发工具也不能盲目使用，要了解应用场景，再去用它。","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492432,"discussion_content":"欢迎点赞转发","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587346040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202612,"user_name":"Hugas Chan 🎭","can_delete":false,"product_type":"c1","uid":1597153,"ip_address":"","ucode":"10AEBC72784970","user_header":"https://static001.geekbang.org/account/avatar/00/18/5e/e1/261664f8.jpg","comment_is_top":false,"comment_ctime":1586015272,"is_pvip":false,"replies":[{"id":"75728","content":"这么理解容易绕进去，ThreadLocal共享数据不是确保存取数据的时候线程相同，而是每一个线程只能存取自己的那份数据，代码是由线程执行的","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1586046761,"ip_address":"","comment_id":202612,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5880982568","product_id":100047701,"comment_content":"老师我想问下，通过ThreadLocal来共享数据怎么保证是相同线程。小白求解","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490631,"discussion_content":"这么理解容易绕进去，ThreadLocal共享数据不是确保存取数据的时候线程相同，而是每一个线程只能存取自己的那份数据，代码是由线程执行的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586046761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1053498,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/3a/b0454322.jpg","nickname":"Eric","note":"","ucode":"59752A51A382A6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":257686,"discussion_content":"可以看一下TreadLocal的实现 我理解是用线程号做Key ，每次取值时，根据自己的当前线程号去拿value，所以叫ThreadLocal，这类其实并不是“要把数据作为资源跨线程分享出去”","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588599824,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2026247,"avatar":"","nickname":"Geek_GuangCheng","note":"","ucode":"8B34BE9B687478","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311606,"discussion_content":"线程的局部变量, 高并发场景下确保自己用自己的数据, 用完就删除缓存的数据, 然后还给线程池..是这么理解的吗?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602417417,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":197612,"user_name":"刘成","can_delete":false,"product_type":"c1","uid":1352662,"ip_address":"","ucode":"F1ED0EB840FFA6","user_header":"https://static001.geekbang.org/account/avatar/00/14/a3/d6/c0d0cb25.jpg","comment_is_top":false,"comment_ctime":1585387804,"is_pvip":false,"replies":[{"id":"74605","content":"是，课程受篇幅能传达的知识点是有限的，大家相互讨论是最好的","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1585389186,"ip_address":"","comment_id":197612,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5880355100","product_id":100047701,"comment_content":"每次课程看评论都能有课程外的收获啊","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489560,"discussion_content":"是，课程受篇幅能传达的知识点是有限的，大家相互讨论是最好的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585389186,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":195419,"user_name":"知行合一","can_delete":false,"product_type":"c1","uid":1090784,"ip_address":"","ucode":"563C4A71D80DA1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJwQvLGE4dMsF4JU0svW3DtGbodpjskbY65FdwF13JdtBYZfgL2IXHlHrdejWzHdjT0RibEIfib4QYA/132","comment_is_top":false,"comment_ctime":1585186995,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880154291","product_id":100047701,"comment_content":"答案就在源码最核心的部分，也就是 Java 自带的 Unsafe 实现的 CAS。它在虚拟机层面确保了写入数据的原子性，比加锁的效率高得多：<br><br>CPU层面确保吧？","like_count":1},{"had_liked":false,"id":192038,"user_name":"Geek_3b1096","can_delete":false,"product_type":"c1","uid":1549364,"ip_address":"","ucode":"A6BD92B79B3632","user_header":"","comment_is_top":false,"comment_ctime":1584823526,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879790822","product_id":100047701,"comment_content":"写得真好非常感谢","like_count":1},{"had_liked":false,"id":189230,"user_name":"howie","can_delete":false,"product_type":"c1","uid":1910554,"ip_address":"","ucode":"75063AB9638A8A","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLQaWXfpntwPsfE7fSYicU9mfIhEhcu7cBflRNFR2iaKDQswEtWz3iaLj3n2ia76rUrWLUpyE2BQNoXug/132","comment_is_top":false,"comment_ctime":1584491358,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879458654","product_id":100047701,"comment_content":"我发现ThreadLocal在同一个服务器访问多次，打印地址都是一样的，相当于指向的堆内容是一致的，如果每次不及时清理数据，后面的访问会使用前一次的堆信息","like_count":1},{"had_liked":false,"id":187278,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1584073207,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879040503","product_id":100047701,"comment_content":"ThreadLocal.remove是移除设置之前的值，不是移除当前设置的值","like_count":1},{"had_liked":false,"id":186540,"user_name":"谢波","can_delete":false,"product_type":"c1","uid":1789648,"ip_address":"","ucode":"B5AB634D725D4D","user_header":"https://static001.geekbang.org/account/avatar/00/1b/4e/d0/671cb32c.jpg","comment_is_top":false,"comment_ctime":1583861851,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878829147","product_id":100047701,"comment_content":"干货，暂无感想，来日讨论","like_count":1},{"had_liked":false,"id":186273,"user_name":"道常","can_delete":false,"product_type":"c1","uid":1036221,"ip_address":"","ucode":"3D5060A360D226","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cf/bd/3a62f836.jpg","comment_is_top":false,"comment_ctime":1583813722,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878781018","product_id":100047701,"comment_content":"threadlocal在tomcat中使用时对每次请求用lanjie器等方式进行处理可能不容易犯错，也不容易产生文中说的问题","like_count":1},{"had_liked":false,"id":186226,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1583804882,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878772178","product_id":100047701,"comment_content":"通过代码和测试结果，来读并发的实例，说实话有些吃力。<br>如果可以的话，希望能带上几张图示。。。","like_count":1},{"had_liked":false,"id":186125,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1583762677,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878729973","product_id":100047701,"comment_content":"学习了，感谢老师。","like_count":1},{"had_liked":false,"id":356246,"user_name":"在雨中","can_delete":false,"product_type":"c1","uid":1188220,"ip_address":"江西","ucode":"C4A0B725C8A009","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/7c/940627a7.jpg","comment_is_top":false,"comment_ctime":1662084052,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1662084052","product_id":100047701,"comment_content":"建议在preHandle()最前面和afterCompletion()都执行一下threadLocal.remove()","like_count":0},{"had_liked":false,"id":349154,"user_name":"Geek_d3928c","can_delete":false,"product_type":"c1","uid":2450893,"ip_address":"","ucode":"7CB09FD1F7CB23","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/L8EpqHoAnmvkzCIsdOkv5QvhIzu5tMaF2FDusXShqukv5ZBkS8DbicWaErjnYydibiaqBrs70wQ8P6axvC2FbWpbQ/132","comment_is_top":false,"comment_ctime":1655776376,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655776376","product_id":100047701,"comment_content":"&#47;&#47;等待所有任务完成<br>    forkJoinPool.shutdown();<br>    forkJoinPool.awaitTermination(1, TimeUnit.HOURS);<br>这两行可以换一下位置吗？？？","like_count":0},{"had_liked":false,"id":347226,"user_name":"Bumblebee","can_delete":false,"product_type":"c1","uid":2051293,"ip_address":"","ucode":"B879C8A511D08D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","comment_is_top":false,"comment_ctime":1653828463,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1653828463","product_id":100047701,"comment_content":"今日收获<br><br>① 使用ThreadLocal要注意线程复用问题；<br><br>② 使用并发工具要注意其提供的api组合使用线程安全问题；<br><br><br>","like_count":0},{"had_liked":false,"id":337294,"user_name":"无言的约定","can_delete":false,"product_type":"c1","uid":1128953,"ip_address":"","ucode":"5E8046EB6B7956","user_header":"https://static001.geekbang.org/account/avatar/00/11/39/f9/acfb9a48.jpg","comment_is_top":false,"comment_ctime":1646737192,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646737192","product_id":100047701,"comment_content":"freqs.computeIfAbsent(key, k -&gt; new LongAdder()).increment();   这个地方的increment()是不是有问题？在代码里报错了","like_count":0},{"had_liked":false,"id":336551,"user_name":"技术是伙伴","can_delete":false,"product_type":"c1","uid":1641193,"ip_address":"","ucode":"3B38709BC88C8C","user_header":"https://static001.geekbang.org/account/avatar/00/19/0a/e9/6fad9109.jpg","comment_is_top":false,"comment_ctime":1646210187,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646210187","product_id":100047701,"comment_content":"为老师点赞，第一篇就很赞","like_count":0},{"had_liked":false,"id":334255,"user_name":"子夜枯灯","can_delete":false,"product_type":"c1","uid":1359678,"ip_address":"","ucode":"5D84BFE7832038","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/3e/cdc36608.jpg","comment_is_top":false,"comment_ctime":1644829576,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644829576","product_id":100047701,"comment_content":"手敲代码复习Class01  收获很大","like_count":0},{"had_liked":false,"id":330884,"user_name":"宗离","can_delete":false,"product_type":"c1","uid":1333717,"ip_address":"","ucode":"1176BE01F1B83D","user_header":"https://static001.geekbang.org/account/avatar/00/14/59/d5/c726c523.jpg","comment_is_top":false,"comment_ctime":1642247315,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1642247315","product_id":100047701,"comment_content":"并发工具使用好，首先明其原理，知其使用场景和缺点。","like_count":0},{"had_liked":false,"id":330056,"user_name":"新生\\","can_delete":false,"product_type":"c1","uid":1202160,"ip_address":"","ucode":"212978C88E242E","user_header":"https://static001.geekbang.org/account/avatar/00/12/57/f0/f6155d5f.jpg","comment_is_top":false,"comment_ctime":1641778822,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641778822","product_id":100047701,"comment_content":"诸如 size、isEmpty 和 containsValue 等聚合方法  这里面的聚合方法是什么意思呀","like_count":0},{"had_liked":false,"id":328363,"user_name":"lidashuang","can_delete":false,"product_type":"c1","uid":1104850,"ip_address":"","ucode":"560ABE8032760E","user_header":"https://static001.geekbang.org/account/avatar/00/10/db/d2/e29f8834.jpg","comment_is_top":false,"comment_ctime":1640689811,"is_pvip":false,"replies":[{"id":"119591","content":"The parallelism level indicates how many threads or CPUs you want to work concurrently on on tasks passed to the ForkJoinPool....","user_name":"作者回复","user_name_real":"编辑","uid":"1001470","ctime":1640701874,"ip_address":"","comment_id":328363,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640689811","product_id":100047701,"comment_content":"```<br>    public ForkJoinPool(int parallelism) {<br>        this(parallelism, defaultForkJoinWorkerThreadFactory, null, false,<br>             0, MAX_CAP, 1, null, DEFAULT_KEEPALIVE, TimeUnit.MILLISECONDS);<br>    }<br><br>```<br><br>ForkJoinPool 的第一个参数 是 parallelism 不是 threadCount","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542285,"discussion_content":"The parallelism level indicates how many threads or CPUs you want to work concurrently on on tasks passed to the ForkJoinPool....","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640701874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328068,"user_name":"晨鼠","can_delete":false,"product_type":"c1","uid":1269019,"ip_address":"","ucode":"91B4E53D61C3F7","user_header":"https://static001.geekbang.org/account/avatar/00/13/5d/1b/dd403905.jpg","comment_is_top":false,"comment_ctime":1640514745,"is_pvip":false,"replies":[{"id":"119482","content":"https:&#47;&#47;stackoverflow.com&#47;questions&#47;5483047&#47;why-is-creating-a-thread-said-to-be-expensive","user_name":"作者回复","user_name_real":"编辑","uid":"1001470","ctime":1640577571,"ip_address":"","comment_id":328068,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640514745","product_id":100047701,"comment_content":"老师在文中提到：线程的创建很昂贵，那么到底有多少成本呢？可否详细解答一下","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541835,"discussion_content":"https://stackoverflow.com/questions/5483047/why-is-creating-a-thread-said-to-be-expensive","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640577572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325276,"user_name":"MAPLES","can_delete":false,"product_type":"c1","uid":1440002,"ip_address":"","ucode":"71B37E8E00DA2A","user_header":"https://static001.geekbang.org/account/avatar/00/15/f9/02/ea8161ce.jpg","comment_is_top":false,"comment_ctime":1638888838,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638888838","product_id":100047701,"comment_content":"感觉老师写的stream流好陌生","like_count":0},{"had_liked":false,"id":319918,"user_name":"study的程序员","can_delete":false,"product_type":"c1","uid":1023101,"ip_address":"","ucode":"E5AE9037D24429","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9c/7d/774e07f9.jpg","comment_is_top":false,"comment_ctime":1636008758,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636008758","product_id":100047701,"comment_content":"当Key存在的时候，如果Value获取比较昂贵的话，putIfAbsent就白白浪费时间在获取这个昂贵的Value上。这点不理解，是不是写错了？应该是computeIfAbsent才会浪费计算吧？计算出来的value没有用","like_count":0},{"had_liked":false,"id":314033,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1632814115,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632814115","product_id":100047701,"comment_content":"课程很棒，物超所值。<br>课程代码里的多个异步任务List&lt;Future&gt; 方式还可以直接用CompletionService。<br><br>    private static void test3() {<br>        StopWatch stopWatch = new StopWatch();<br>        stopWatch.start();<br>        BlockingQueue&lt;Future&lt;Integer&gt;&gt; bq = new LinkedBlockingQueue&lt;&gt;(10);<br>        CompletionService&lt;Integer&gt; cs = new ExecutorCompletionService&lt;&gt;(threadPool, bq);<br>        IntStream.rangeClosed(1, 4).forEach(i -&gt; cs.submit(getAsyncTask(i)));<br>        List&lt;Integer&gt; result = IntStream.rangeClosed(1, 4).mapToObj(__ -&gt; {<br>            try {<br>                &#47;&#47; take() 方法会阻塞直至任务完成<br>                &#47;&#47; return cs.take().get();<br>                return cs.poll(1, TimeUnit.SECONDS).get();<br>            } catch (Exception e) {<br>                e.printStackTrace();<br>                return -1;<br>            }<br>        }).collect(Collectors.toList());<br>        stopWatch.stop();<br>        log.info(&quot;result {} took {} ms&quot;, result, stopWatch.getLastTaskTimeMillis());<br>    }","like_count":0},{"had_liked":false,"id":314023,"user_name":"空间","can_delete":false,"product_type":"c1","uid":2786166,"ip_address":"","ucode":"97EE37243861C9","user_header":"https://static001.geekbang.org/account/avatar/00/2a/83/76/ac5eb361.jpg","comment_is_top":false,"comment_ctime":1632810768,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632810768","product_id":100047701,"comment_content":"老师问个问题，CopyOnWriteArrayList既然是写慢读快，那在现实业务中，数据终究是要先写再读的，难不成CopyOnWriteArrayList的使用场景都是数据先预加载好的前提下，再用于读操作吗？","like_count":0},{"had_liked":false,"id":309651,"user_name":"聆世冷暖","can_delete":false,"product_type":"c1","uid":1378524,"ip_address":"","ucode":"509C9FCC146136","user_header":"https://static001.geekbang.org/account/avatar/00/15/08/dc/c88e97b3.jpg","comment_is_top":false,"comment_ctime":1630290481,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630290481","product_id":100047701,"comment_content":"第一种情况应该推荐使用 Spring 里的 Session 封装就不会用这个问题了，也不用手动 remove。ThreadLocal 还会有父子线程数据传递问题。用  Session 不会出现","like_count":0},{"had_liked":false,"id":305337,"user_name":"Geek_067891","can_delete":false,"product_type":"c1","uid":1703315,"ip_address":"","ucode":"E136AB0F3B9138","user_header":"","comment_is_top":false,"comment_ctime":1627911283,"is_pvip":false,"replies":[{"id":"110465","content":"读多写少或者说希望无锁读的场景","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1627969688,"ip_address":"","comment_id":305337,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1627911283","product_id":100047701,"comment_content":"在我的经历中没有想到有需要用到CopyOnWriteList的场景，老师可以讲个你碰到过的具体业务场景不？","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524355,"discussion_content":"读多写少或者说希望无锁读的场景","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627969688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":302544,"user_name":"Sylo Tsui","can_delete":false,"product_type":"c1","uid":1664064,"ip_address":"","ucode":"20B93DC2FFC9F5","user_header":"https://static001.geekbang.org/account/avatar/00/19/64/40/1b426b23.jpg","comment_is_top":false,"comment_ctime":1626255183,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626255183","product_id":100047701,"comment_content":"concurrentHashMap.computeIfAbsent 在jdk1.8.0_261之前，对于相同key的操作会造成死锁，261版本之后已经修复了这个问题。","like_count":0},{"had_liked":false,"id":285331,"user_name":"商俊帅","can_delete":false,"product_type":"c1","uid":1762053,"ip_address":"","ucode":"91FA160CE63335","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJrZb9pm07aich12LiaxoS0uKLFaz2XyU7ZjGcvlq5wdCUoJic2dvvHlMzemOOVrVz8NXPUbsnbPnrpw/132","comment_is_top":false,"comment_ctime":1616743019,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616743019","product_id":100047701,"comment_content":"感谢老师！！！","like_count":0},{"had_liked":false,"id":283963,"user_name":"续费专用","can_delete":false,"product_type":"c1","uid":2028938,"ip_address":"","ucode":"1B585A131B64B4","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f5/8a/dc9a23a1.jpg","comment_is_top":false,"comment_ctime":1616012322,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616012322","product_id":100047701,"comment_content":"代码中用的ForkJoinPool有意义，只是使用其中一个线程，不直接使用当前线程呢 ","like_count":0},{"had_liked":false,"id":277246,"user_name":"青蛙煮水喝","can_delete":false,"product_type":"c1","uid":2419852,"ip_address":"","ucode":"20F4F3B8F70E70","user_header":"","comment_is_top":false,"comment_ctime":1612330596,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612330596","product_id":100047701,"comment_content":"豁然开朗，收获颇丰，需要仔细研究练习几次才有感觉；","like_count":0},{"had_liked":false,"id":277014,"user_name":"Geek_a3e3a4","can_delete":false,"product_type":"c1","uid":2389023,"ip_address":"","ucode":"59440973159791","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELicBncJ1vZYic7y6HvrOvM0ZQxAyQbFf9FDmkibRkPeSRKiasd6oicVmXhgoiaaWgjFoZFr21cF4lmI6Pw/132","comment_is_top":false,"comment_ctime":1612233011,"is_pvip":false,"replies":[{"id":"100524","content":"__ 只是随便命名一个不关注的参数","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1612246236,"ip_address":"","comment_id":277014,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1612233011","product_id":100047701,"comment_content":"foreach（__   那两个下划线 还有这种语法  什么意思？","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514900,"discussion_content":"__ 只是随便命名一个不关注的参数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612246236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":269342,"user_name":"不着调...","can_delete":false,"product_type":"c1","uid":1669651,"ip_address":"","ucode":"00317809789C3F","user_header":"https://static001.geekbang.org/account/avatar/00/19/7a/13/3102cd23.jpg","comment_is_top":false,"comment_ctime":1608617389,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608617389","product_id":100047701,"comment_content":"确实学到了，不错哦","like_count":0},{"had_liked":false,"id":269129,"user_name":"迪米乌格斯","can_delete":false,"product_type":"c1","uid":2378309,"ip_address":"","ucode":"1D4393746DCBCE","user_header":"https://static001.geekbang.org/account/avatar/00/24/4a/45/e048531a.jpg","comment_is_top":false,"comment_ctime":1608534761,"is_pvip":false,"replies":[{"id":"97623","content":"嗯，后续文章也是这样，这些文章不仅仅是介绍技术点，更多是10+年积累我的一些总结，或者说意识上的东西<br><br>帮忙多转发，大家都反馈收获不错，但是课程销量不高，希望更多人看到<br><br>","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1608549563,"ip_address":"","comment_id":269129,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1608534761","product_id":100047701,"comment_content":"评论看下来之后对文本内容有了更深的理解.<br>Java从业者最喜欢看的文章没有之一,而且在这的人几乎都在专注学习,好多年没有体验过这种学习的快乐了,感谢老师!","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512159,"discussion_content":"嗯，后续文章也是这样，这些文章不仅仅是介绍技术点，更多是10+年积累我的一些总结，或者说意识上的东西\n\n帮忙多转发，大家都反馈收获不错，但是课程销量不高，希望更多人看到\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608549563,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262261,"user_name":"Exler","can_delete":false,"product_type":"c1","uid":1140830,"ip_address":"","ucode":"41E5FCD39698D2","user_header":"https://static001.geekbang.org/account/avatar/00/11/68/5e/5676ece1.jpg","comment_is_top":false,"comment_ctime":1605680426,"is_pvip":false,"replies":[{"id":"95233","content":"并行走自定义池","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1605748814,"ip_address":"","comment_id":262261,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605680426","product_id":100047701,"comment_content":"forkJoinPool.execute(() -&gt; IntStream.rangeClosed(1, LOOP_COUNT).parallel().forEach(i-&gt;{})<br>想要问下各位大神们，这一句parallel已经是并行for循环了，forkJoinPool的作用是什么？","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509756,"discussion_content":"并行走自定义池","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605748814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":255788,"user_name":"jackaroo","can_delete":false,"product_type":"c1","uid":1759857,"ip_address":"","ucode":"020E2C55E84B30","user_header":"https://static001.geekbang.org/account/avatar/00/1a/da/71/e5f6d565.jpg","comment_is_top":false,"comment_ctime":1603432371,"is_pvip":false,"replies":[{"id":"93288","content":"jdk文档","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1603536225,"ip_address":"","comment_id":255788,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603432371","product_id":100047701,"comment_content":"老师好，确认下文中说putAll（）方法是非原子性的聚合方法，这个方法我们平时大量使用到，会有什么问题，怎么测试看它是不是原子性的，源码没太看懂","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507836,"discussion_content":"jdk文档","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603536225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":255070,"user_name":"Janenesome","can_delete":false,"product_type":"c1","uid":1276572,"ip_address":"","ucode":"15D2673CC31D9D","user_header":"https://static001.geekbang.org/account/avatar/00/13/7a/9c/a4bc748d.jpg","comment_is_top":false,"comment_ctime":1603262492,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603262492","product_id":100047701,"comment_content":"谢谢老师，以前使用 ThreadLocal，都会说时候记得清理资源，可是并没有说为什么，这篇文章里让我知其所以然了。<br><br>ConcurrentHashMap 的文档和源码还没有去仔细读过，的确是一直还在按照老方式来使用，受教了，这就回去马上改。","like_count":0},{"had_liked":false,"id":253616,"user_name":"JoJi","can_delete":false,"product_type":"c1","uid":2066986,"ip_address":"","ucode":"B88997A80E76AC","user_header":"https://static001.geekbang.org/account/avatar/00/1f/8a/2a/f94db4dc.jpg","comment_is_top":false,"comment_ctime":1602812837,"is_pvip":false,"replies":[{"id":"92648","content":"不是","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1602835073,"ip_address":"","comment_id":253616,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1602812837","product_id":100047701,"comment_content":"老师，ConcurrentHashMap的第一个例子，可以理解成可见性的问题吗？","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507125,"discussion_content":"不是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602835073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2066986,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/8a/2a/f94db4dc.jpg","nickname":"JoJi","note":"","ucode":"B88997A80E76AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":313012,"discussion_content":"concurrentHashMap只能保障原子操作的线程安全，而putAll是聚合操作，非原子操作。是这样理解的吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602910818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250202,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1101762,"ip_address":"","ucode":"003700A99A910B","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/c2/a5b3ceaf.jpg","comment_is_top":false,"comment_ctime":1600988668,"is_pvip":false,"replies":[{"id":"91668","content":"可以看下课后答疑文章  不是在finally中清除 这没有意义 是在请求结束后清","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1601033153,"ip_address":"","comment_id":250202,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1600988668","product_id":100047701,"comment_content":"老师好, 第一个案例, 关于 ThreadLocal 错用的问题, 我有个疑惑:<br>在多线程并发访问的情况下, 如果在 finally 代码块清除当前线程的用户信息之前, 有新的线程使用相同的用户 id 查用户信息, 那么这个线程得到的还是原来的线程中的用户信息, 这样仍旧没解决不同线程中数据乱串的问题吧.","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506148,"discussion_content":"可以看下课后答疑文章  不是在finally中清除 这没有意义 是在请求结束后清","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601033153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":242749,"user_name":"黄常凯","can_delete":false,"product_type":"c1","uid":1450651,"ip_address":"","ucode":"A8D40EA8EB6BFD","user_header":"https://static001.geekbang.org/account/avatar/00/16/22/9b/4486d287.jpg","comment_is_top":false,"comment_ctime":1597830649,"is_pvip":false,"replies":[{"id":"89642","content":"去掉pom中相关依赖即可","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1597988265,"ip_address":"","comment_id":242749,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1597830649","product_id":100047701,"comment_content":"我用的windows没有装docker，所以项目启动不起来，请问老师怎样可以只启动这一章的项目呢","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504086,"discussion_content":"去掉pom中相关依赖即可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597988265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":242493,"user_name":"止","can_delete":false,"product_type":"c1","uid":2094764,"ip_address":"","ucode":"F50C04AD088DBF","user_header":"https://static001.geekbang.org/account/avatar/00/1f/f6/ac/4c02ab18.jpg","comment_is_top":false,"comment_ctime":1597741962,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597741962","product_id":100047701,"comment_content":"都是大牛啊 ，我这看了好几遍，亲自试验了 才知道这两个问题的结果<br>","like_count":0},{"had_liked":false,"id":240658,"user_name":"张鑫","can_delete":false,"product_type":"c1","uid":1166695,"ip_address":"","ucode":"3CE5B1077184B2","user_header":"https://static001.geekbang.org/account/avatar/00/11/cd/67/23fab87a.jpg","comment_is_top":false,"comment_ctime":1597028048,"is_pvip":true,"replies":[{"id":"88845","content":"不明白问题是啥意思","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1597038098,"ip_address":"","comment_id":240658,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1597028048","product_id":100047701,"comment_content":"老师，tomcat也是多线程来执行我们的业务代码，可以这么理解么，是不是所有场景下都尽量使用ThreadLocalRandom呢？还是我们自己写了多线程处理的代码，其实有时候对tomcat多线程和业务自己的多线程感觉理解不清楚","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503515,"discussion_content":"不明白问题是啥意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597038098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239866,"user_name":"Geek_fe5e8a","can_delete":false,"product_type":"c1","uid":2103563,"ip_address":"","ucode":"B4CC300397BD6A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/dgox0m94vr6w2Vxk0N6651pyL5wKWicqgwIxU9iahlIn5LKeFfQJDjzUoQKM8WNibS7Yuxyulmic1Xxfia5ibFc6ia0Hw/132","comment_is_top":false,"comment_ctime":1596679635,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596679635","product_id":100047701,"comment_content":"老师,我用postman模拟并发请求为什么重现不了课程中的错误呢?模拟真正并发除了并行流还有哪些实现方式?谢谢老师","like_count":0},{"had_liked":false,"id":239431,"user_name":"Geek_fe5e8a","can_delete":false,"product_type":"c1","uid":2103563,"ip_address":"","ucode":"B4CC300397BD6A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/dgox0m94vr6w2Vxk0N6651pyL5wKWicqgwIxU9iahlIn5LKeFfQJDjzUoQKM8WNibS7Yuxyulmic1Xxfia5ibFc6ia0Hw/132","comment_is_top":false,"comment_ctime":1596530227,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596530227","product_id":100047701,"comment_content":"老师讲的特别好,受益匪浅","like_count":0},{"had_liked":false,"id":238080,"user_name":"码农Kevin亮","can_delete":false,"product_type":"c1","uid":1116630,"ip_address":"","ucode":"D34562461CA0A1","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/d6/5f366427.jpg","comment_is_top":false,"comment_ctime":1596067923,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596067923","product_id":100047701,"comment_content":"为什么要用ThreadLocal而不直接用session?这个设计没交代背景。","like_count":0},{"had_liked":false,"id":230786,"user_name":"max","can_delete":false,"product_type":"c1","uid":1773471,"ip_address":"","ucode":"91DDE86511DCDC","user_header":"https://static001.geekbang.org/account/avatar/00/1b/0f/9f/caae319d.jpg","comment_is_top":false,"comment_ctime":1593491964,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593491964","product_id":100047701,"comment_content":"第一篇就有我踩过的坑了，感觉很亲切","like_count":0},{"had_liked":false,"id":226333,"user_name":"天天向上","can_delete":false,"product_type":"c1","uid":1242455,"ip_address":"","ucode":"0CCCA6F4DCC480","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg","comment_is_top":false,"comment_ctime":1592039660,"is_pvip":false,"replies":[{"id":"83353","content":"不会，Thread还引用着ThreadLocal","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1592053621,"ip_address":"","comment_id":226333,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1592039660","product_id":100047701,"comment_content":"ThreadLocal中的ThreadLocalMap的key不是弱引用吗，如果set之后，经历了GC，那么再get是否就get不到了？","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498198,"discussion_content":"不会，Thread还引用着ThreadLocal","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592053621,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221564,"user_name":"闻人","can_delete":false,"product_type":"c1","uid":1102584,"ip_address":"","ucode":"E4970C0D944243","user_header":"https://static001.geekbang.org/account/avatar/00/10/d2/f8/d5006178.jpg","comment_is_top":false,"comment_ctime":1590541766,"is_pvip":true,"replies":[{"id":"81716","content":"putIfAbsent是原子的","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1590550457,"ip_address":"","comment_id":221564,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1590541766","product_id":100047701,"comment_content":"1. 不能；<br>2. putIfAbsent 非原子操作，相当于 contain 和 put 组合","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496495,"discussion_content":"putIfAbsent是原子的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590550457,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1102584,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d2/f8/d5006178.jpg","nickname":"闻人","note":"","ucode":"E4970C0D944243","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274364,"discussion_content":"看漏了，感谢老师指正","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590574612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220017,"user_name":"梅子黄时雨","can_delete":false,"product_type":"c1","uid":1015938,"ip_address":"","ucode":"9F788D09C2E9E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/82/3c21b30c.jpg","comment_is_top":false,"comment_ctime":1590135927,"is_pvip":false,"replies":[{"id":"81214","content":"没错","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1590142916,"ip_address":"","comment_id":220017,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590135927","product_id":100047701,"comment_content":"深入理解使用工具的原理，与合理的场景","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496025,"discussion_content":"没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590142916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207324,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1587048346,"is_pvip":true,"replies":[{"id":"77472","content":"如果设置ThreadLocal的时机晚于获取，那么还是有可能错乱的。<br><br>可以自定义HandlerInterceptorAdapter，在preHandle的时候去设置ThreadLocal，在afterCompletion时去remove。","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1587090437,"ip_address":"","comment_id":207324,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587048346","product_id":100047701,"comment_content":"老师您好，以前接触过通过threadlocal来存储当前用户信息。但一般都是请求进来就会把当前存在Redis缓存的用户信息放入threadlocal中，之后用到直接从threadlocal中取。<br><br>每次请求到重新放了信息，按道理是不会有取错的现象，但这边如果没有做remove，感觉会导致线程池中的空闲线程有内存泄漏的现象。<br><br>而且这种场景下应该什么时候进行remove呢？<br>我想的是是否可以在拦截器或网关中当请求处理完成后进行remove，从而防止内存泄漏","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492085,"discussion_content":"如果设置ThreadLocal的时机晚于获取，那么还是有可能错乱的。\n\n可以自定义HandlerInterceptorAdapter，在preHandle的时候去设置ThreadLocal，在afterCompletion时去remove。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587090437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205663,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1274787,"ip_address":"","ucode":"C233DF1D224EC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","comment_is_top":false,"comment_ctime":1586698416,"is_pvip":true,"replies":[{"id":"76852","content":"我并没有完全理解你TD0001接口的逻辑，给你几个建议：<br><br>1、如果你并不需要知道异步流程的结果，直接把任务提交给线程池执行即可，不用去等待结果，这样就不会让主线程等待<br>2、异步逻辑中也有多个异步逻辑，其实完全可以把下一层的异步逻辑打平，直接由主线程提交多个异步逻辑到线程池（比如发送消息给多人）<br>3、我们说使用线程池异步处理的作用，主要是并行化，也就是主流程处理其他任务的时候异步任务可以并行处理，或者是多个任务并行处理<br>4、如果外围异步流程很多很复杂，并且主流程又不关心异步处理的结果，不建议用线程池处理，而是把任务提交到MQ，然后由专门的消息服务来发消息，缓存服务设置缓存，缓存服务计算缓存","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1586700930,"ip_address":"","comment_id":205663,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1586698416","product_id":100047701,"comment_content":"老师好，有个问题需要请教下：<br><br>我们系统TD0001接口被调用完成入库后，后续有几个操作：<br><br>1、放置数据至缓存<br>2、发送消息盒子<br><br>这两个操作是异步的：<br>1、操作涉及到三个缓存操作及对缓存的计算，1中这三个操作其实也是异步的<br>2、发消息盒子时候是给若干个用户发送消息，彼此是不干扰的，目前调用接口给每个用户发送是异步的，通过线程池和future处理<br><br>我的问题是：<br>因为TD0001接口是双向请求响应接口，通信是通过webService和IBM MQ，TD0001接口被调用只是往系统入库保存一条交易记录而已，<br>下游不关心后续的1、2操作，若等到1、2操作完成后，下游系统会等待超时。<br>所以我想把上述1-1，1-2，1-3，2中的操作均异步完成<br>特殊的情况，2这个大的操作是异步的，2中的给多个用户发送消息盒子也是异步的（消息中心没有批量给调用的接口，业务要求用户收到消息有一定的实时要求）<br>2中异步调用中还有异步调用，这个用线程池和Future如何处理？<br>或者说这种场景如何处理，老师有什么好的建议嘛？<br><br>","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491547,"discussion_content":"我并没有完全理解你TD0001接口的逻辑，给你几个建议：\n\n1、如果你并不需要知道异步流程的结果，直接把任务提交给线程池执行即可，不用去等待结果，这样就不会让主线程等待\n2、异步逻辑中也有多个异步逻辑，其实完全可以把下一层的异步逻辑打平，直接由主线程提交多个异步逻辑到线程池（比如发送消息给多人）\n3、我们说使用线程池异步处理的作用，主要是并行化，也就是主流程处理其他任务的时候异步任务可以并行处理，或者是多个任务并行处理\n4、如果外围异步流程很多很复杂，并且主流程又不关心异步处理的结果，不建议用线程池处理，而是把任务提交到MQ，然后由专门的消息服务来发消息，缓存服务设置缓存，缓存服务计算缓存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586700930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1274787,"avatar":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","nickname":"Michael","note":"","ucode":"C233DF1D224EC1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":230196,"discussion_content":"TD0001接口仅仅保存一条记录而已，保存成功后，即可执行后续异步操作，不关心后续异步执行的结果.\n感谢老师耐心的解答，明白老师的意思了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586735469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204946,"user_name":"灰太狼","can_delete":false,"product_type":"c1","uid":1066046,"ip_address":"","ucode":"C17DD5D5ED9DC5","user_header":"https://static001.geekbang.org/account/avatar/00/10/44/3e/493e73fa.jpg","comment_is_top":false,"comment_ctime":1586497917,"is_pvip":false,"replies":[{"id":"76584","content":"ok","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1586500668,"ip_address":"","comment_id":204946,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586497917","product_id":100047701,"comment_content":"实验出错误结果了，谢谢老师，收货良多","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491332,"discussion_content":"ok","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586500668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204943,"user_name":"灰太狼","can_delete":false,"product_type":"c1","uid":1066046,"ip_address":"","ucode":"C17DD5D5ED9DC5","user_header":"https://static001.geekbang.org/account/avatar/00/10/44/3e/493e73fa.jpg","comment_is_top":false,"comment_ctime":1586497375,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586497375","product_id":100047701,"comment_content":"老师，我实验了那个1000的没有同步的，也是用的concurrenthashmap，每次都能拿到正确的结果，查看concurrenthashmap的putall源代码，看到有synchronized(f)","like_count":0},{"had_liked":false,"id":204932,"user_name":"灰太狼","can_delete":false,"product_type":"c1","uid":1066046,"ip_address":"","ucode":"C17DD5D5ED9DC5","user_header":"https://static001.geekbang.org/account/avatar/00/10/44/3e/493e73fa.jpg","comment_is_top":false,"comment_ctime":1586494074,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586494074","product_id":100047701,"comment_content":"我们项目使用interceptor在请求处理结束后清除ThreadLocal的数据，避免清除代码散落在不同地方","like_count":0},{"had_liked":false,"id":203371,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1274787,"ip_address":"","ucode":"C233DF1D224EC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","comment_is_top":false,"comment_ctime":1586180602,"is_pvip":true,"replies":[{"id":"76031","content":"你概念上有点混了，两种模式：<br><br>1、主线程统一收集结果，适用于希望单一任务设置超时<br><br>private static void test1(){<br>        long begin = System.currentTimeMillis();<br>        List&lt;Future&lt;Integer&gt;&gt; futures = IntStream.rangeClosed(1,4)<br>                .mapToObj(i-&gt;threadPool.submit(getAsyncTask(i)))<br>                .collect(Collectors.toList());<br>        List&lt;Integer&gt; result = futures.stream().map(future-&gt; {<br>            try {<br>                return future.get();<br>            } catch (Exception e) {<br>                e.printStackTrace();<br>                return -1;<br>            }<br>        }).collect(Collectors.toList());<br>        log.info(&quot;result {} took {} ms&quot;, result, System.currentTimeMillis() - begin);<br>    }<br><br>    private static Callable&lt;Integer&gt; getAsyncTask(int i){<br>        return ()-&gt; {<br>            TimeUnit.SECONDS.sleep(i);<br>            return i;<br>        };<br>    }<br><br><br>2、子线程自己添加结果，适用于希望整体有一个等待超时<br><br>private static void test2(){<br>        long begin = System.currentTimeMillis();<br>        int count = 4;<br>        List&lt;Integer&gt; result = new ArrayList&lt;&gt;(count);<br>        CountDownLatch countDownLatch = new CountDownLatch(count);<br>        IntStream.rangeClosed(1,count).forEach(i-&gt; threadPool.execute(executeAsyncTask(i,countDownLatch, result)));<br>        try {<br>            countDownLatch.await(3, TimeUnit.SECONDS);<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        log.info(&quot;result {} took {} ms&quot;, result, System.currentTimeMillis() - begin);<br>    }<br><br>    private static Runnable executeAsyncTask(int i, CountDownLatch countDownLatch, List&lt;Integer&gt; result){<br>        return ()-&gt; {<br>            try {<br>                TimeUnit.SECONDS.sleep(i);<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>            synchronized (result) {<br>                result.add(i);<br>            }<br>            countDownLatch.countDown();<br>        };<br>    }","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1586219090,"ip_address":"","comment_id":203371,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1586180602","product_id":100047701,"comment_content":"老师好！遇到一个问题，一个接口中的数据，前五步中的动作没有依赖关系，前五部执行完成后，将数据汇总得到最终的结果，想利用线程池和CountDownLatch进行处理，示例如下：<br>线程池：<br> @Bean(&quot;feedExecutor&quot;)<br>    public Executor feedExecutor() {<br>        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();<br>        executor.setCorePoolSize(8);<br>        executor.setMaxPoolSize(20);<br>        executor.setQueueCapacity(1000);<br>        executor.setKeepAliveSeconds(100);<br>        executor.setThreadNamePrefix(&quot;feed-executor-&quot;);<br>        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());<br>        return executor;<br>    }<br><br>List&lt;Feed&gt; feedList = new ArrayList&lt;&gt;();<br>        CountDownLatch latch = new CountDownLatch(4);<br>        executor.execute(() -&gt; {<br>            Future&lt;List&lt;Feed&gt;&gt; future = feedAsynQueryService.queryFeedList1();<br>            List&lt;Feed&gt; feeds = future.get(10, TimeUnit.SECONDS);<br>            latch.countDown();<br>        });<br><br>         executor.execute(() -&gt; {<br>            Future&lt;List&lt;Feed&gt;&gt; future = feedAsynQueryService.queryFeedList2();<br>            List&lt;Feed&gt; feeds = future.get(10, TimeUnit.SECONDS);<br>            latch.countDown();<br>        });<br>         executor.execute(() -&gt; {<br>            Future&lt;List&lt;Feed&gt;&gt; future = feedAsynQueryService.queryFeedList3();<br>            List&lt;Feed&gt; feeds = future.get(10, TimeUnit.SECONDS);<br>            latch.countDown();<br>        });<br>        executor.execute(() -&gt; {<br>            Future&lt;List&lt;Feed&gt;&gt; future = feedAsynQueryService.queryFeedList4();<br>            List&lt;Feed&gt; feeds = future.get(10, TimeUnit.SECONDS);<br>            latch.countDown();<br>        });<br>        latch.await();<br>        synchronized (feedList) {<br>            feedList.addAll(feedList1);<br>            feedList.addAll(feedList2);<br>        }<br><br>但是这面执行的时候一直报错","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490848,"discussion_content":"你概念上有点混了，两种模式：\n\n1、主线程统一收集结果，适用于希望单一任务设置超时\n\nprivate static void test1(){\n        long begin = System.currentTimeMillis();\n        List&amp;lt;Future&amp;lt;Integer&amp;gt;&amp;gt; futures = IntStream.rangeClosed(1,4)\n                .mapToObj(i-&amp;gt;threadPool.submit(getAsyncTask(i)))\n                .collect(Collectors.toList());\n        List&amp;lt;Integer&amp;gt; result = futures.stream().map(future-&amp;gt; {\n            try {\n                return future.get();\n            } catch (Exception e) {\n                e.printStackTrace();\n                return -1;\n            }\n        }).collect(Collectors.toList());\n        log.info(&amp;quot;result {} took {} ms&amp;quot;, result, System.currentTimeMillis() - begin);\n    }\n\n    private static Callable&amp;lt;Integer&amp;gt; getAsyncTask(int i){\n        return ()-&amp;gt; {\n            TimeUnit.SECONDS.sleep(i);\n            return i;\n        };\n    }\n\n\n2、子线程自己添加结果，适用于希望整体有一个等待超时\n\nprivate static void test2(){\n        long begin = System.currentTimeMillis();\n        int count = 4;\n        List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(count);\n        CountDownLatch countDownLatch = new CountDownLatch(count);\n        IntStream.rangeClosed(1,count).forEach(i-&amp;gt; threadPool.execute(executeAsyncTask(i,countDownLatch, result)));\n        try {\n            countDownLatch.await(3, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        log.info(&amp;quot;result {} took {} ms&amp;quot;, result, System.currentTimeMillis() - begin);\n    }\n\n    private static Runnable executeAsyncTask(int i, CountDownLatch countDownLatch, List&amp;lt;Integer&amp;gt; result){\n        return ()-&amp;gt; {\n            try {\n                TimeUnit.SECONDS.sleep(i);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            synchronized (result) {\n                result.add(i);\n            }\n            countDownL","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586219090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1274787,"avatar":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","nickname":"Michael","note":"","ucode":"C233DF1D224EC1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223363,"discussion_content":"一下明白了，谢谢老师耐心解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586219887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1132448,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/a0/f12115b7.jpg","nickname":"Sam.张朝","note":"","ucode":"FB20554D94B250","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1274787,"avatar":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","nickname":"Michael","note":"","ucode":"C233DF1D224EC1","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":279772,"discussion_content":"看不懂，能力好弱","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591413592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":223363,"ip_address":""},"score":279772,"extra":""}]}]}]}