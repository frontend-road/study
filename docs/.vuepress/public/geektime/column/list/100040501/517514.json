{"id":517514,"title":"37｜参数传递的正确方法和模板的二进制膨胀","content":"<p>你好，我是吴咏炜。</p><p>上一讲我们讨论的视图类型的对象，通常和内置类型的对象一样，是使用传值的方式来进行传参的。这种方式非常简单，也是比较推荐的 C++ 的做法，但这种方式存在对对象类型的限制。在对象比较大的时候，或者可能比较大的时候，按值传参就可能有性能问题。这包括了大部分的函数模板，除非你能预知用来实例化模板的参数。此外，还有很多对象可能是不可复制、甚至不可移动的，显然，这些对象你也不可能按值传参。此时，你就只能使用引用或指针来传参了。</p><h2>参数传递的方式</h2><p>函数的参数有入参、出参和出入参之分。入参是最常见的情况，意味着一个参数是让函数来使用的。出参表示一个参数是函数来写的，它必须是一个引用或指针，在现代 C++ 里已经较少推荐，因为返回对象（包括结构体、<code>pair</code>、<code>tuple</code> 等）往往可导致更加清晰、更加安全、同时性能也不下降的代码。出入参是一种中间情况，参数会被函数同时读和写。它也是引用或指针，常常是一个序列的对象（如 <code>vector</code> 和 <code>string</code>），里面本来就有内容，并在函数执行的过程中让函数继续往里添加内容。</p><p>对于现代 C++，非可选的出参和出入参通常使用引用方式，这样的代码写起来会更加方便。而可选的出参和出入参则一般使用指针方式，可以用空指针表示这个参数不被使用。而入参的情况就复杂多了：</p><!-- [[[read_end]]] --><ul>\n<li>如果一个入参是不可选，且它的类型为内置类型或小对象（可按两个指针的大小作初步估算），应当使用值传参的方式（<code>Obj obj</code>）：数字类型、指针类型、视图类型一般会使用这种方式。</li>\n<li>如果一个入参是不可选的，默认可使用 const 左值引用的方式（<code>const Obj&amp; obj</code>）：容器、大对象和堆上分配内存的对象一般会使用这种方式。</li>\n<li>如果一个入参是可选的，则可以使用指针传参，使用空指针表示这个参数不存在（<code>Obj* ptr</code> 或 <code>const Obj* ptr</code>）。</li>\n<li>如果一个入参是不可选、移动友好的，且在函数中需要产生一个拷贝，那可以使用值方式传参（<code>Obj obj</code>）。</li>\n</ul><p>前三种情况都比较直白，应该只有最后一种需要说明一下。使用值传参的典型情况是构造函数、赋值运算符和利用入参构造新对象的函数。我们在<a href=\"https://time.geekbang.org/column/article/169263\">第 2 讲</a>就给出过使用值传参的赋值运算符的例子。这里，我再举一个构造函数来说明一下。如果我们需要传递一个字符串给构造函数，让构造函数把它作为成员变量存下来以供后续使用和更改，那我们这个参数使用 <code>string</code> 就挺合适：</p><pre><code class=\"language-cpp\">class Obj {\npublic:\n  explicit Obj(string name)\n    : name_(move(name)) {}\n  …\n\nprivate:\n  string name_;\n};\n</code></pre><p>这样写的话，如果我们传递一个左值 <code>string</code> 给 <code>Obj</code> 构造函数的话，编译器会产生一次拷贝和一次移动，把名字写到 <code>name_</code> 里，比使用 <code>const string&amp;</code> 作为参数类型多一次移动。它的优点是当 <code>string</code> 是一个临时对象的时候（包括用户传递字符串字面量的情况），<code>Obj</code> 的构造函数会通过两次移动把名字写到 <code>name_</code> 里。这时候，如果我们使用的是 <code>const string&amp;</code> 的话，临时构造出来的 <code>string</code> 对象就不能被移动，而是白白地构造和析构了，浪费。</p><p>当然，入参也可以是右值引用，但这对于普通的函数（移动构造函数、移动赋值运算符之外）就很少见了，因为大部分情况下没有必要要求入参必须是个临时对象。同时提供左值引用和右值引用的重载是一种可能性，但除了在追求极致优化的基础库里，一般并不值得这么做。</p><p>上面说的情况都是参数类型（<code>Obj</code>）已知的情况。对于函数模板，参数类型本身可能是一个模板参数。这种情况下，我们又应该如何处理呢？</p><h3>转发引用</h3><p>实际上，基本原则跟上面仍然是类似的，除了我们需要把参数继续往下传到另外一个函数去、并且我们不知道这个参数会如何被使用的情况。这时，我们通常会使用转发引用。</p><p>转发引用的一个典型形式是在 <code>make_unique</code>、<code>make_shared</code>、<code>emplace</code> 等函数或方法里传递未知数量和类型的参数，如：</p><pre><code class=\"language-cpp\">template &lt;typename T,\n          typename... Args&gt;\nauto make_unique(Args&amp;&amp;... args)\n{\n  return unique_ptr&lt;T&gt;(\n    new T(forward&lt;Args&gt;(args)...));\n}\n</code></pre><p>刨除不常见的 const 右值的情况，我们来具体分析一下常见的三种场景（先限定单参数的情况）：</p><ul>\n<li>当给定的参数是 const 左值（如 <code>const Obj&amp;</code>）时，<code>Args</code> 被推导为 <code>const Obj&amp;</code>，这样，在引用坍缩后，<code>Args&amp;&amp;</code> 仍然是 <code>const Obj&amp;</code>。</li>\n<li>当给定的参数是非 const 左值（如 <code>Obj&amp;</code>）时，<code>Args</code> 被推导为 <code>Obj&amp;</code>，这样，在引用坍缩后，<code>Args&amp;&amp;</code> 仍然是 <code>Obj&amp;</code>。</li>\n<li>当给定的参数是右值（如 <code>Obj&amp;&amp;</code>）时，<code>Args</code> 被推导为 <code>Obj</code>，这样，<code>Args&amp;&amp;</code> 当然仍保持为 <code>Obj&amp;&amp;</code>。</li>\n</ul><p>回顾一下，我们这里要使用 <code>forward</code> 的原因是，所有的变量都是左值，因此，如果我们要保持“右值性”，就得使用强制类型转换。<code>forward</code> 所做的事情，本质上就是 <code>static_cast&lt;Args&amp;&amp;&gt;(args)</code>，右值被转换成右值引用（xvalue），左值仍保持为左值引用（由于引用坍缩）。</p><p>一般而言，转发引用之后总会跟着 <code>forward</code> 的使用。反过来，如果转发引用后面没有 <code>forward</code> 的话，则是非常可疑的（ranges 是一种常见的例外）<span class=\"orange\">[1]</span>。</p><h3>auto&amp;&amp;</h3><p>转发引用的另外一种常见用法是 <code>auto&amp;&amp;</code>。可能的场景有：</p><ul>\n<li>在变量声明中使用</li>\n<li>在泛型 lambda 表达式中使用</li>\n<li>在 C++20 的函数模板参数声明中使用</li>\n</ul><p>我们可以写：</p><pre><code class=\"language-cpp\">auto&amp;&amp; x = …;\n</code></pre><p>我们可以写：</p><pre><code class=\"language-cpp\">for (auto&amp;&amp; item : rng) {\n  …\n}\n</code></pre><p>我们也可以写：</p><pre><code class=\"language-cpp\">auto lambda = [](auto&amp;&amp; x,\n                 auto&amp;&amp; y) {\n  // 处理并返回\n};\n</code></pre><p>到了 C++20，我们还可以写：</p><pre><code class=\"language-cpp\">auto process(auto&amp;&amp; x, auto&amp;&amp; y)\n{\n  // 处理并返回\n}\n</code></pre><p>这么写着还真方便啊，也不用管参数是不是 const，及到底是左值还是右值了。爽。</p><h3>转发引用的问题</h3><p>如果你真这么觉得的话，那你显然忘了我刚写的这句话了：</p><blockquote>\n<p>一般而言，转发引用之后总会跟着 <code>forward</code> 的使用。反过来，如果转发引用后面没有 <code>forward</code> 的话，则是非常可疑的（ranges 是一种常见的例外）。</p>\n</blockquote><p>我们先抛开不谈语义问题（毕竟，如果没有副作用，语义不正确在某些时候也是可以接受的……），看看这么写有什么实际问题。</p><p>拿泛型 lambda 表达式那个例子来说，它本质上相当于下面的函数对象定义：</p><pre><code class=\"language-cpp\">struct Unnamed {\n  template &lt;typename T1,\n            typename T2&gt;\n  auto operator()(T1&amp;&amp; x,\n                  T2&amp;&amp; y) const\n  {\n    // 处理并返回\n  }\n} lambda;\n</code></pre><p>粗粗一看，似乎也没什么问题，是吧？</p><p>假设我们有下面的变量定义：</p><pre><code class=\"language-cpp\">int n;\nlong long lln;\nspan&lt;const int&gt; sp;\n</code></pre><p>问题来了：下面的表达式会产生多少个不同的特化（实例化结果）？</p><pre><code class=\"language-cpp\">lambda(n, lln);\nlambda(lln, n);\nlambda(n, 1);\nlambda(n, sp[0]);\nlambda(sp[0], lln);\n</code></pre><p>问题实际不难，我们只需要按照推导规则把参数类型一一填进去即可：</p><pre><code class=\"language-cpp\">Unnamed::operator()&lt;int&amp;, long long&amp;&gt;;\nUnnamed::operator()&lt;long long&amp;, int&amp;&gt;;\nUnnamed::operator()&lt;int&amp;, int&gt;;\nUnnamed::operator()&lt;int&amp;, const int&amp;&gt;;\nUnnamed::operator()&lt;const int&amp;, long long&amp;&gt;;\n</code></pre><p>所有的情况都是不同的，所以有五种不同的特化！这就意味着，至少从理论上来说，这五种不同的使用方式可能会产生五份不同的二进制代码。</p><h3>避免不必要的转发引用</h3><p>那这是不是真的会成为一个问题呢？这……取决于具体情况，尤其取决于代码是不是可以被良好地内联。作为一般的指导原则，消除不必要的特化是最简单的处理方式。</p><p>就我们目前这个具体例子来说，假设我们不修改入参 <code>x</code> 和 <code>y</code>，我们有两种不同的处理方式：</p><ul>\n<li>如果我们的参数只会是内置类型（如上面用到的 <code>int</code>、<code>long long</code> 等），我们可以按值传参</li>\n<li>如果我们对参数类型和大小无法确定，那使用 const 引用会是一个不错的选择</li>\n</ul><p>如果把这个例子的 <code>auto&amp;&amp;</code> 改一下：</p><pre><code class=\"language-cpp\">auto lambda = [](const auto&amp; x,\n                 const auto&amp; y) {\n  // 处理并返回\n};\n</code></pre><p>那我们至少可以把上面的五种特化缩减到三种了：</p><pre><code class=\"language-cpp\">Unnamed::operator()&lt;int, long long&gt;;\nUnnamed::operator()&lt;long long, int&gt;;\nUnnamed::operator()&lt;int, int&gt;;\n</code></pre><p>注意，我主要想说明的是我们应当避免不必要的转发引用，而不是避免所有的转发引用。特别是，如果你在 <code>auto&amp;&amp;</code> 后面需要使用 <code>forward</code> 来进行转发的话（类似于 <code>forward&lt;decltype(x)&gt;(x)</code>），那转发引用的使用通常是合适的。</p><h2>模板的二进制膨胀</h2><p>模板在带来方便和性能的同时，也可能使代码产生膨胀，这是一个需要权衡的问题。我们上一讲讲到的视图类型，实际上既可能消减二进制代码，也可能增加二进制代码。</p><p>对于像 <code>span</code> 这样的类型，它明显可以消减二进制代码。如果我们的 <code>print</code> 函数的定义改成：</p><pre><code class=\"language-cpp\">template &lt;typename T&gt;\nvoid print(const T&amp; rng)\n{\n  for (const auto&amp; n : rng) {\n    cout &lt;&lt; n &lt;&lt; ' ';\n  }\n  cout &lt;&lt; '\\n';\n}\n</code></pre><p>那它显然可以工作，而且还非常灵活。但是，现在当我们传递 <code>vector&lt;int&gt;</code>、<code>array&lt;int, 5&gt;</code>、<code>array&lt;int, 8&gt;</code>、<code>int[5]</code>、<code>int[8]</code> 时，那就是五种不同的特化了。如果由于任何原因 <code>print</code> 不能内联的话，我们就会生成约五倍数量的二进制代码。</p><p>而像 <code>elements_view</code> 这样的类型就反过来潜在可能会增加二进制代码。相信你目前已经能理解这个问题，我就不展开了。不过，相对其他一些不使用视图类型的方案，它在易用性和性能方面的提升，很可能大大超过了潜在的二进制膨胀的危害。</p><h3>通过退化消减二进制膨胀</h3><p>某些二进制膨胀问题不太好解决，有一些则是很容易解决的。在像传递 <code>char[8]</code>、<code>int[5]</code> 这样的参数的场景，使用指针或者 <code>span</code>（即指针加长度）往往是一种很好的替换方案。下面，我们再来看一个很具体的例子，如何高效地实现一个通用的日志函数的传参。</p><p>为了高效地传递大对象，日志函数的对外接口可能长下面这个样子：</p><pre><code class=\"language-cpp\">template &lt;typename... Args&gt;\nvoid log(log_level,\n         const Args&amp;... args);\n</code></pre><p>这里，我们用 const 左值引用传参，规避了前面说的不同引用类型的参数会带来的额外特化。但这里我们还会遇到一个常见问题：字面量 <code>\"hello\"</code> 和 <code>\"world\"</code> 被视作同一类型——<code>const char[6]</code>——但它们和 <code>\"hi\"</code>——<code>const char[3]</code>——就不是同一类型了。这时候，我们需要非引用方式传参时候的退化行为，把 <code>const char</code> 数组当作 <code>const char*</code> 处理。</p><p>我们可以简单地把目前的这个 <code>log</code> 函数模板重命名为 <code>log_impl</code>，而新增一个简单转发的 <code>log</code> 函数模板：</p><pre><code class=\"language-cpp\">template &lt;typename... Args&gt;\nvoid log(log_level level,\n         const Args&amp;... args)\n{\n  log_impl(level,\n           try_decay(args)...);\n}\n</code></pre><p>这个函数够简单，一般可以内联。即使不能内联，它会带来的额外膨胀也非常小。所以，我们只需要专心实现 <code>try_decay</code> 就行了。</p><p>这里，我们就有一定的自由度来选择到底该怎么做了。我目前的策略是这样的：</p><ul>\n<li>对于可以退化为 <code>const char*</code> 的类型，强制类型转换成 <code>const char*</code></li>\n<li>对于其他数组类型，将其转变为 <code>span</code></li>\n<li>其他情况直接完美转发</li>\n</ul><p>代码如下：</p><pre><code class=\"language-cpp\">template &lt;typename T&gt;\nconstexpr decltype(auto)\ntry_decay(T&amp;&amp; value)\n{\n  using decayed_type = decay_t&lt;T&gt;;\n  using remove_ref_type =\n    remove_reference_t&lt;T&gt;;\n  if constexpr (\n    is_same_v&lt;decayed_type,\n              const char*&gt;) {\n    return decayed_type(value);\n  } else if constexpr (\n    is_array_v&lt;remove_ref_type&gt;) {\n    return span&lt;remove_extent_t&lt;\n      remove_ref_type&gt;&gt;(value);\n  } else {\n    return forward&lt;T&gt;(value);\n  }\n}\n</code></pre><p>需要注意一下，使用转发引用的函数都潜在存在此类问题。所以，在 C++11 开始的新时代里，也并不是使用 <code>emplace_back</code> 一定比 <code>push_back</code> 更好，即使你正确使用、没有犯低级错误 <span class=\"orange\">[2]</span>。</p><h3>通过公共基类消减二进制膨胀</h3><p>除了参数类型，还有一种常见的优化类模板方法的办法，就是抽取公共基类。</p><p>类模板里通常有很多方法，一般总有些是跟模板参数相关的。但是，也常常可能存在一些方法，跟模板参数没有任何关系，或者很容易就能改造成没有关系。这类方法也是模板二进制膨胀的来源之一。</p><p>想象一下，类模板 <code>Obj&lt;T&gt;</code> 里有方法 <code>CommonMethod()</code>。当我们用不同的类型，如 <code>int</code> 和 <code>char</code>，去实例化的时候，我们就可能会编译产生方法 <code>Obj&lt;int&gt;::CommonMethod()</code> 和 <code>Obj&lt;char&gt;::CommonMethod()</code>。这是两个无关的成员函数，因此编译器一般不会为你进行优化。在你每次实例化时，编译器都会在需要用到 <code>CommonMethod</code> 时提供一份新的代码，而不会看到不同的 <code>CommonMethod</code> 实际是一样的。我们需要显式地告诉编译器，不同的 <code>CommonMethod</code> 实际上是同一份。一种通行的做法，就是把这样的方法放到一个公用的非模板基类里去。如下所示：</p><pre><code class=\"language-cpp\">class ObjBase {\npublic:\n  void CommonMethod();\n};\n\ntemplate &lt;typename T&gt;\nclass Obj : private ObjBase {\npublic:\n  // 如果 CommonMethod 是一个 Obj\n  // 需要暴露的方法\n  using ObjBase::CommonMethod;\n  …\n};\n</code></pre><p><code>Obj</code> 私有继承 <code>ObjBase</code>，这是一种实现继承关系。我们让 <code>Obj</code> 可以使用 <code>ObjBase</code> 的数据成员和方法，但不允许别人通过一个 <code>ObjBase</code> 的引用或指针来访问 <code>Obj</code>。如果 <code>CommonMethod</code> 原来是一个私有方法，那 <code>Obj</code> 现在直接使用就可以了；如果 <code>CommonMethod</code> 原来是一个公开或保护方法，那我们需要在合适的位置使用 <code>using</code> 来确保它能被调用者或子类使用。</p><p>某些标准库实现里的模板类就会使用这种方法来进行优化。</p><h2>内容小结</h2><p>本讲我讨论了两个相关问题：如何传递参数，如何减少模板的二进制膨胀。使用合适的引用方式，并合理使用退化，可以让我们产出既灵活又小巧的代码。</p><h2>课后思考</h2><p>如果一个函数的调用者应该持有一个 <code>unique_ptr</code>，函数的参数应该怎么写？</p><p>为什么目前的 <code>try_decay</code> 里面需要使用 <code>remove_reference_t</code>？两个用到的地方如果直接使用 <code>T</code> 会发生什么后果？</p><p>期待你的思考，如有任何疑问，我们留言区见！</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Arthur O’Dwyer, “‘Universal reference’ or ‘forward reference’?”. <a href=\"https://quuxplusone.github.io/blog/2022/02/02/look-what-they-need/\">https://quuxplusone.github.io/blog/2022/02/02/look-what-they-need/</a></span></p><p><span class=\"reference\">[2] Arthur O’Dwyer, “Don’t blindly prefer <code>emplace_back</code> to <code>push_back</code>”. <a href=\"https://quuxplusone.github.io/blog/2021/03/03/push-back-emplace-back/\">https://quuxplusone.github.io/blog/2021/03/03/push-back-emplace-back/</a></span></p>","comments":[{"had_liked":false,"id":373104,"user_name":"罗 乾 林","can_delete":false,"product_type":"c1","uid":1188222,"ip_address":"上海","ucode":"D0406F95176ABA","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/7e/fb725950.jpg","comment_is_top":false,"comment_ctime":1682045873,"is_pvip":false,"replies":[{"id":136428,"content":"1. 参考第 41 讲。一般不建议用 const unique_ptr&amp; 传参。\n\n2. 正确。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1682691024,"ip_address":"上海","comment_id":373104,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"课后思考:\n1.const std::unique_ptr&lt;A&gt; &amp;\n2.如果传入参数为数组,T类型推导将为数组的引用,is_array_v&lt;T&gt;结果为false,因为此时T为引用.\nremove_extent_t&lt;T&gt;结果仍然是数组的引用,span这里编译不通过","like_count":1},{"had_liked":false,"id":396074,"user_name":"light","can_delete":false,"product_type":"c1","uid":2086274,"ip_address":"新加坡","ucode":"89F876C59A7046","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/W2O5VwL8wN6VIGPGCHIBIM1ageY2ic0kJpnRAD3I1BYkE8I2tkUef6AZOicwDm30PqgKR75bsWDicicEZvMf0ULLYQ/132","comment_is_top":false,"comment_ctime":1732943059,"is_pvip":false,"replies":[{"id":143804,"content":"你的第三种用法并不推荐，因为传参使用智能指针只在传递所有权时有意义，而3的形式并不能。去掉const后，用unique_ptr&lt;T&gt;*或unique_ptr&lt;T&gt;&amp;则有意义，意味着让被调用的函数修改这个指针。\n\n第41讲和我的下面这个知乎回答你也可以参考一下：\n\nhttps:&#47;&#47;www.zhihu.com&#47;question&#47;534389744&#47;answer&#47;2500052393","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1733112268,"ip_address":"上海","comment_id":396074,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"unique_ptr传参可以有三种：\n1. 直接按值接收unique_ptr\nvoid func(std::unique_ptr&lt;int&gt; ptr) {}\n2.按右值引用接收unique_ptr\nvoid func(std::unique_ptr&lt;int&gt;&amp;&amp; ptr) {}\n3.通过const引用接收指向unique_ptr的指针\nvoid someFunction(const std::unique_ptr&lt;int&gt;* ptr) {}\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632108,"discussion_content":"请直接参考第 41 讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700476687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":394574,"user_name":"淡漠落寞","can_delete":false,"product_type":"c1","uid":1049550,"ip_address":"北京","ucode":"17FF0A02D13098","user_header":"https://static001.geekbang.org/account/avatar/00/10/03/ce/ec3b8de9.jpg","comment_is_top":false,"comment_ctime":1727195760,"is_pvip":false,"replies":[{"id":143378,"content":"我们有span和模板两种情况。如果考虑内联膨胀的话，span也不占优势了。如果不能内联，用模板的五种情况有五份代码，而span只有一份。\n\n主要还是跟什么比的问题。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1728573873,"ip_address":"上海","comment_id":394574,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"&quot;如果由于任何原因 print 不能内联的话，我们就会生成约五倍数量的二进制代码&quot;\n吴老师，请问如果print内联的话，是会比不内联造成更大的二进制膨胀吧？例如print调用了100次，如果内联了会展开100次，但是如果是不内联，在这个case下只会产生5个特化的代码而已","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":652277,"discussion_content":"我们有span和模板两种情况。如果考虑内联膨胀的话，span也不占优势了。如果不能内联，用模板的五种情况有五份代码，而span只有一份。\n\n主要还是跟什么比的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1728573873,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384128,"user_name":"李云龙","can_delete":false,"product_type":"c1","uid":3201926,"ip_address":"美国","ucode":"785924B16BE788","user_header":"https://static001.geekbang.org/account/avatar/00/30/db/86/51ec4c41.jpg","comment_is_top":false,"comment_ctime":1700379919,"is_pvip":false,"replies":[{"id":140142,"content":"请直接参考第 41 讲。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1700476687,"ip_address":"上海","comment_id":384128,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"由于unique_ptr不支持复制，那么使用 unique_ptr&lt;T&gt;&amp; 作为函数的传入传出参数比较合适。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632108,"discussion_content":"请直接参考第 41 讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700476687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":379444,"user_name":"coming","can_delete":false,"product_type":"c1","uid":1262181,"ip_address":"上海","ucode":"7625CE61D9A2D2","user_header":"https://static001.geekbang.org/account/avatar/00/13/42/65/5bfd0a65.jpg","comment_is_top":false,"comment_ctime":1691982138,"is_pvip":false,"replies":[{"id":138243,"content":"泛型lambda表达式在第16讲介绍，不过当时确实讲得比较简单。需要记住的是 它本质上是具有 operator() 成员函数模板的类的函数对象。对于这个例子，相当于如下的 operator()：\n\ntemplate &lt;typename T, typename U&gt;\nauto operator()(const T&amp; x, const U&amp; y)\n{\n  …\n}\n\n然后就是普通的模板参数匹配和推导了。这样是不是好理解一点？","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1692056430,"ip_address":"上海","comment_id":379444,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"#include &lt;span&gt;\n\nint main() {\n    auto lambda = [](const auto&amp; x, const auto&amp; y) {\n        &#47;&#47; 处理并返回\n    };\n\n    int n;\n    long long lln;\n    std::span&lt;const int&gt; sp;\n\n    lambda(n, lln);\n    lambda(lln, n);\n    lambda(n, 1);\n    lambda(n, sp[0]);\n    lambda(sp[0], lln);\n\n    return 0;\n}\n我使用https:&#47;&#47;cppinsights.io&#47;s&#47;a77543e0, 确认是实例化了三个\n    #ifdef INSIGHTS_USE_TEMPLATE\n    template&lt;&gt;\n    inline &#47;*constexpr *&#47; void operator()&lt;int, long long&gt;(const int &amp; x, const long long &amp; y) const\n    {\n    }\n    #endif\n    \n    \n    #ifdef INSIGHTS_USE_TEMPLATE\n    template&lt;&gt;\n    inline &#47;*constexpr *&#47; void operator()&lt;long long, int&gt;(const long long &amp; x, const int &amp; y) const\n    {\n    }\n    #endif\n    \n    \n    #ifdef INSIGHTS_USE_TEMPLATE\n    template&lt;&gt;\n    inline &#47;*constexpr *&#47; void operator()&lt;int, int&gt;(const int &amp; x, const int &amp; y) const\n    {\n    }\n    #endif\n\n老师能说下, 哪一讲,讲了这个推导规则吗? 我有点懵","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":625668,"discussion_content":"泛型lambda表达式在第16讲介绍，不过当时确实讲得比较简单。需要记住的是 它本质上是具有 operator() 成员函数模板的类的函数对象。对于这个例子，相当于如下的 operator()：\n\ntemplate &lt;typename T, typename U&gt;\nauto operator()(const T&amp; x, const U&amp; y)\n{\n  …\n}\n\n然后就是普通的模板参数匹配和推导了。这样是不是好理解一点？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1692056430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1262181,"avatar":"https://static001.geekbang.org/account/avatar/00/13/42/65/5bfd0a65.jpg","nickname":"coming","note":"","ucode":"7625CE61D9A2D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":625673,"discussion_content":"谢谢老师了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1692062704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":625668,"ip_address":"上海","group_id":0},"score":625673,"extra":""}]},{"author":{"id":1262181,"avatar":"https://static001.geekbang.org/account/avatar/00/13/42/65/5bfd0a65.jpg","nickname":"coming","note":"","ucode":"7625CE61D9A2D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":625625,"discussion_content":"好像是隐式转换int-&gt;const int&amp; 合并了两种情况吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1691998033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":373104,"user_name":"罗 乾 林","can_delete":false,"product_type":"c1","uid":1188222,"ip_address":"上海","ucode":"D0406F95176ABA","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/7e/fb725950.jpg","comment_is_top":false,"comment_ctime":1682045873,"is_pvip":false,"replies":[{"id":136428,"content":"1. 参考第 41 讲。一般不建议用 const unique_ptr&amp; 传参。\n\n2. 正确。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1682691024,"ip_address":"上海","comment_id":373104,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"课后思考:\n1.const std::unique_ptr&lt;A&gt; &amp;\n2.如果传入参数为数组,T类型推导将为数组的引用,is_array_v&lt;T&gt;结果为false,因为此时T为引用.\nremove_extent_t&lt;T&gt;结果仍然是数组的引用,span这里编译不通过","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":616305,"discussion_content":"1. 参考第 41 讲。一般不建议用 const unique_ptr&amp; 传参。\n\n2. 正确。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1682691024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1188222,"avatar":"https://static001.geekbang.org/account/avatar/00/12/21/7e/fb725950.jpg","nickname":"罗 乾 林","note":"","ucode":"D0406F95176ABA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":616518,"discussion_content":"我是这样理解的：如果使用std::unique_ptr以值的形式传递参数，必定要使用std::move，不符合题目“函数的调用者应该持有一个 unique_ptr”的要求。望老师指正","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1682901658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":616305,"ip_address":"四川","group_id":0},"score":616518,"extra":""}]},{"author":{"id":2004587,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIOKHyDXN8YMQnM4HromAic1IAkkyAS1Gj3Bic2sVtzjHgv1rjDSuyVJZUq7XmMNWbrFa2m2wVgo5hQ/132","nickname":"wayne","note":"","ucode":"B732B2D19451A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":618049,"discussion_content":"1. 参数可以是裸指针，用 .get() 的方式传入","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1684060629,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":396074,"user_name":"light","can_delete":false,"product_type":"c1","uid":2086274,"ip_address":"新加坡","ucode":"89F876C59A7046","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/W2O5VwL8wN6VIGPGCHIBIM1ageY2ic0kJpnRAD3I1BYkE8I2tkUef6AZOicwDm30PqgKR75bsWDicicEZvMf0ULLYQ/132","comment_is_top":false,"comment_ctime":1732943059,"is_pvip":false,"replies":[{"id":143804,"content":"你的第三种用法并不推荐，因为传参使用智能指针只在传递所有权时有意义，而3的形式并不能。去掉const后，用unique_ptr&lt;T&gt;*或unique_ptr&lt;T&gt;&amp;则有意义，意味着让被调用的函数修改这个指针。\n\n第41讲和我的下面这个知乎回答你也可以参考一下：\n\nhttps:&#47;&#47;www.zhihu.com&#47;question&#47;534389744&#47;answer&#47;2500052393","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1733112268,"ip_address":"上海","comment_id":396074,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"unique_ptr传参可以有三种：\n1. 直接按值接收unique_ptr\nvoid func(std::unique_ptr&lt;int&gt; ptr) {}\n2.按右值引用接收unique_ptr\nvoid func(std::unique_ptr&lt;int&gt;&amp;&amp; ptr) {}\n3.通过const引用接收指向unique_ptr的指针\nvoid someFunction(const std::unique_ptr&lt;int&gt;* ptr) {}\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":654614,"discussion_content":"你的第三种用法并不推荐，因为传参使用智能指针只在传递所有权时有意义，而3的形式并不能。去掉const后，用unique_ptr&lt;T&gt;*或unique_ptr&lt;T&gt;&amp;则有意义，意味着让被调用的函数修改这个指针。\n\n第41讲和我的下面这个知乎回答你也可以参考一下：\n\nhttps://www.zhihu.com/question/534389744/answer/2500052393","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1733112268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":394574,"user_name":"淡漠落寞","can_delete":false,"product_type":"c1","uid":1049550,"ip_address":"北京","ucode":"17FF0A02D13098","user_header":"https://static001.geekbang.org/account/avatar/00/10/03/ce/ec3b8de9.jpg","comment_is_top":false,"comment_ctime":1727195760,"is_pvip":false,"replies":[{"id":143378,"content":"我们有span和模板两种情况。如果考虑内联膨胀的话，span也不占优势了。如果不能内联，用模板的五种情况有五份代码，而span只有一份。\n\n主要还是跟什么比的问题。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1728573873,"ip_address":"上海","comment_id":394574,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"&quot;如果由于任何原因 print 不能内联的话，我们就会生成约五倍数量的二进制代码&quot;\n吴老师，请问如果print内联的话，是会比不内联造成更大的二进制膨胀吧？例如print调用了100次，如果内联了会展开100次，但是如果是不内联，在这个case下只会产生5个特化的代码而已","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":652277,"discussion_content":"我们有span和模板两种情况。如果考虑内联膨胀的话，span也不占优势了。如果不能内联，用模板的五种情况有五份代码，而span只有一份。\n\n主要还是跟什么比的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1728573873,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384128,"user_name":"李云龙","can_delete":false,"product_type":"c1","uid":3201926,"ip_address":"美国","ucode":"785924B16BE788","user_header":"https://static001.geekbang.org/account/avatar/00/30/db/86/51ec4c41.jpg","comment_is_top":false,"comment_ctime":1700379919,"is_pvip":false,"replies":[{"id":140142,"content":"请直接参考第 41 讲。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1700476687,"ip_address":"上海","comment_id":384128,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"由于unique_ptr不支持复制，那么使用 unique_ptr&lt;T&gt;&amp; 作为函数的传入传出参数比较合适。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":616305,"discussion_content":"1. 参考第 41 讲。一般不建议用 const unique_ptr&amp; 传参。\n\n2. 正确。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1682691024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1188222,"avatar":"https://static001.geekbang.org/account/avatar/00/12/21/7e/fb725950.jpg","nickname":"罗 乾 林","note":"","ucode":"D0406F95176ABA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":616518,"discussion_content":"我是这样理解的：如果使用std::unique_ptr以值的形式传递参数，必定要使用std::move，不符合题目“函数的调用者应该持有一个 unique_ptr”的要求。望老师指正","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1682901658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":616305,"ip_address":"四川","group_id":0},"score":616518,"extra":""}]},{"author":{"id":2004587,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIOKHyDXN8YMQnM4HromAic1IAkkyAS1Gj3Bic2sVtzjHgv1rjDSuyVJZUq7XmMNWbrFa2m2wVgo5hQ/132","nickname":"wayne","note":"","ucode":"B732B2D19451A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":618049,"discussion_content":"1. 参数可以是裸指针，用 .get() 的方式传入","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1684060629,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":379444,"user_name":"coming","can_delete":false,"product_type":"c1","uid":1262181,"ip_address":"上海","ucode":"7625CE61D9A2D2","user_header":"https://static001.geekbang.org/account/avatar/00/13/42/65/5bfd0a65.jpg","comment_is_top":false,"comment_ctime":1691982138,"is_pvip":false,"replies":[{"id":138243,"content":"泛型lambda表达式在第16讲介绍，不过当时确实讲得比较简单。需要记住的是 它本质上是具有 operator() 成员函数模板的类的函数对象。对于这个例子，相当于如下的 operator()：\n\ntemplate &lt;typename T, typename U&gt;\nauto operator()(const T&amp; x, const U&amp; y)\n{\n  …\n}\n\n然后就是普通的模板参数匹配和推导了。这样是不是好理解一点？","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1692056430,"ip_address":"上海","comment_id":379444,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"#include &lt;span&gt;\n\nint main() {\n    auto lambda = [](const auto&amp; x, const auto&amp; y) {\n        &#47;&#47; 处理并返回\n    };\n\n    int n;\n    long long lln;\n    std::span&lt;const int&gt; sp;\n\n    lambda(n, lln);\n    lambda(lln, n);\n    lambda(n, 1);\n    lambda(n, sp[0]);\n    lambda(sp[0], lln);\n\n    return 0;\n}\n我使用https:&#47;&#47;cppinsights.io&#47;s&#47;a77543e0, 确认是实例化了三个\n    #ifdef INSIGHTS_USE_TEMPLATE\n    template&lt;&gt;\n    inline &#47;*constexpr *&#47; void operator()&lt;int, long long&gt;(const int &amp; x, const long long &amp; y) const\n    {\n    }\n    #endif\n    \n    \n    #ifdef INSIGHTS_USE_TEMPLATE\n    template&lt;&gt;\n    inline &#47;*constexpr *&#47; void operator()&lt;long long, int&gt;(const long long &amp; x, const int &amp; y) const\n    {\n    }\n    #endif\n    \n    \n    #ifdef INSIGHTS_USE_TEMPLATE\n    template&lt;&gt;\n    inline &#47;*constexpr *&#47; void operator()&lt;int, int&gt;(const int &amp; x, const int &amp; y) const\n    {\n    }\n    #endif\n\n老师能说下, 哪一讲,讲了这个推导规则吗? 我有点懵","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":654614,"discussion_content":"你的第三种用法并不推荐，因为传参使用智能指针只在传递所有权时有意义，而3的形式并不能。去掉const后，用unique_ptr&lt;T&gt;*或unique_ptr&lt;T&gt;&amp;则有意义，意味着让被调用的函数修改这个指针。\n\n第41讲和我的下面这个知乎回答你也可以参考一下：\n\nhttps://www.zhihu.com/question/534389744/answer/2500052393","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1733112268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]}]}