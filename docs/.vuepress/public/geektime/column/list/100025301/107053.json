{"id":107053,"title":"34 | Amazon热销榜Beam Pipeline实战","content":"<p>你好，我是蔡元楠。</p><p>今天我要与你分享的主题是“Amazon热销榜Beam Pipeline实战”。</p><p>两个月前，亚马逊（Amazon）宣布将关闭中国国内电商业务的消息你一定还记忆犹新。虽然亚马逊遗憾离场，但它依然是目前全球市值最高的电商公司。</p><p>作为美国最大的一家网络电子商务公司，亚马逊的总部位于华盛顿州的西雅图。类似于BAT在国内的地位，亚马逊也是北美互联网FAANG五大巨头之一，其他四个分别是Facebook、Apple、Netflix和Google。</p><p>亚马逊的热销商品系统就如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/df/b0/dff4faae3353f26d7e413a0c1f7983b0.png?wh=1576*758\" alt=\"\"></p><p>当我搜索“攀岩鞋”时，搜索结果的第三个被打上了“热销商品”的标签，这样能帮助消费者快速做出购买决策。</p><p>当我点击这个“Best Seller”的标签时，我可以浏览“攀岩鞋”这个商品分类中浏览销量最高的前100个商品。</p><p><img src=\"https://static001.geekbang.org/resource/image/a7/4c/a7a0b8187b1caf1b31fcda87720e494c.png?wh=1788*1262\" alt=\"\"></p><p>这些贴心的功能都是由热销商品系统实现的。</p><p>这一讲我们就来看看在这样的热销商品系统中，怎样应用之前所学的Beam数据处理技术吧。今天，我们主要会解决一个热销商品系统数据处理架构中的这几个问题：</p><ol>\n<li>怎样用批处理计算基础的热销商品列表、热销商品的存储和serving设计？</li>\n<li>怎样设计每小时更新的热销榜单？</li>\n<li>怎样设计商品去重处理流水线和怎样根据商品在售状态过滤热销商品？</li>\n<li>怎样按不同的商品门类生成榜单？</li>\n</ol><!-- [[[read_end]]] --><h3>1.怎样用批处理计算基础的热销商品列表、热销商品的存储和serving设计？</h3><p>我们先来看最简单的问题设置，怎样用批处理计算基础的热销商品列表。</p><p>假设你的电商网站销售着10亿件商品，并且已经跟踪了网站的销售记录：商品id和购买时间 {product_id, timestamp}，整个交易记录是1000亿行数据，TB级。举个例子，假设我们的数据是这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/bd/9d/bdafa7f74c568c107c38317e0a1a669d.png?wh=1031*582\" alt=\"\"></p><p>我们可以把热销榜按 product_id 排名为：1，2，3。</p><p>你现在有没有觉得这个问题似曾相识呢？的确，我们在<a href=\"https://time.geekbang.org/column/article/91125\">第3讲“大规模数据初体验”</a>中用这个例子引出了数据处理框架设计的基本需求。</p><p>这一讲中，我们会从这个基本问题设置开始，逐步深入探索。</p><p>在第3讲中，我们把我们的数据处理流程分成了两个步骤，分别是：</p><ol>\n<li>统计每个商品的销量</li>\n<li>找出销量前K</li>\n</ol><p>我们先来看第一个步骤的统计商品销量应该如何在Beam中实现。我们在第3讲中是画了这样的计算集群的示意图：</p><p><img src=\"https://static001.geekbang.org/resource/image/8e/8a/8eeff3376743e886d5f2d481ca8ddb8a.jpg?wh=1626*1018\" alt=\"\"></p><p>如果你暂时没有思路的话，我们不妨试试换一个角度来思考这个问题。</p><p>统计商品的销量，换句话说，其实就是计算同样的商品id在我们的销售记录数据库中出现了多少次。这有没有让你联想到什么呢？没错，就是我们在<a href=\"https://time.geekbang.org/column/article/105324\">第31讲</a>中讲到的WordCount例子。WordCount是统计同样的单词出现的次数，而商品销量就是统计同样的商品id出现的次数。</p><p>所以，我们完全可以用WordCount中的部分代码解决商品销量统计的这部分数据处理逻辑。</p><p>在WordCount中，我们用words.apply(Count.perElement())把一个分词后的PCollection转换成了“单词为key，count为value”的一个key/value组合。</p><p>在这里呢，我们同样使用salesRecords.apply(Count.perElement())把一个商品id的PCollection转换成“key为商品id，value为count”的key/value组合。</p><p>Java</p><pre><code>// WordCount的统计词频步骤\nwordCount = words.apply(Count.perElement())\n\n// 我们这里的统计销量步骤\nsalesCount = salesRecords.apply(Count.perElement())\n</code></pre><p>解决了统计每个商品的销量步骤，我们再来看看怎样统计销量前K的商品。在第3讲中，我们是画了一个计算集群来解决这个问题。</p><p><img src=\"https://static001.geekbang.org/resource/image/38/fc/38933e25ca315bd56321753573d5bbfc.jpg?wh=1616*1010\" alt=\"\"></p><p>但是Beam提供了很好的API供我们使用。我们可以使用Top() 这个Transform。</p><p>Top接受的第一个参数就是我们这里的K，也就是我们最终要输出的前几个元素。我们需要实现的是一个Java Comparator interface。</p><p>Java</p><pre><code>PCollection&lt;KV&lt;String, Long&gt;&gt; topK =\n      salesCount.apply(Top.of(K, new Comparator&lt;KV&lt;String, Long&gt;&gt;() {\n          @Override\n          public int compare(KV&lt;String, Long&gt; a, KV&lt;String, Long&gt; b) {\n            return b.getValue.compareTo(a.getValue());\n          }\n      }));\n</code></pre><p>到这里，销量前K的产品就已经被计算出来了。</p><p>和所有数据处理流水线一样，我们需要的是一个完整的系统。那么你就不能仅仅满足于计算出结果，必须要考虑你的数据处理结果将怎样被使用。在本文开头的截图中，你能看到，热销商品都被打上了“Best Seller”的标签，点击“Best Seller”标签我们还能看到完整的热销榜单。</p><p>那么你可以考虑两种serving的方案。</p><p>一种是把热销商品的结果存储在一个单独的数据库中。但是在serving时候，你需要把商品搜索结果和热销商品结果进行交叉查询。如果搜索结果存在于热销商品数据库中，你就在返回的搜索结果元素中把它标注成“Best Seller”。</p><p>另一个可能不太灵活，就是把热销商品的结果写回原来的商品数据库中。如果是热销商品，你就在“是热销商品”这一列做标记。这种方案的缺点是每次更新热销结果后，都要去原来的数据库进行大量更新，不仅要把新成为热销的商品进行标记，还要将落选商品的标记去除。</p><p>两种serving方案的选择影响了你对于数据处理输出的业务需求。相应的，你可以把输出的前K销量产品使用Pipeline output输出到一个单独数据库，也可以统一更新所有数据库中的商品。</p><h3>2.怎样设计每小时更新的热销榜单？</h3><p>在设计完基础的热销商品处理系统后，我们注意到在Amazon的热销榜上有一行小字 “Updated hourly”，也就是“每小时更新”。的确，热销商品往往是有时效性的。去年热销的iPhone X今年就变成了iPhone XS。Amazon选择了以小时为单位更新热销榜单确实是合理的产品设计。</p><p>那么怎样用Beam实现这种定时更新的数据处理系统呢？</p><p>可能你在看到“时间”这个关键词的时候，就马上联想到了第32讲介绍的Beam Window。确实，用基于Window的流处理模式是一个值得考虑的方案。我在这里故意把问题设置得比较模糊。其实是因为这需要取决于具体的业务需求，实际上你也可以选择批处理或者流处理的方式。</p><p>我们先从简单的批处理模式开始。</p><p>在处理工程问题时，我们都是先看最简单的方案能否支撑起来业务需求，避免为了体现工程难度而故意将系统复杂化。采用批处理的方式的话，我们可以每隔一个小时运行一遍上一个小标题中的基础版热销商品系统，也就是部署成cron job的模式。</p><p>但你要注意，如果我们不修改代码的话，每一次运行都会计算目前为止所有销售的商品。如果这不是你的业务需求，你可以在批处理的数据输入步骤中，根据你的销售记录表的时间戳来筛选想要计算的时间段。比如，你可以设置成每一次运行都只计算从运行时间前6个月到该运行时间为止。</p><p>其实，批处理的模式已经能解决我们目前为止的大部分业务需求。但有时候我们不得不去使用流处理。比如，如果存储销售记录的团队和你属于不同的部门，你没有权限去直接读取他们的数据库，他们部门只对外分享一个Pub/Sub的消息队列。这时候就是流处理应用的绝佳场景。</p><p>不知道你还记不记得第33讲中我提到过，在Streaming版本的WordCount中监听一个Kafka消息队列的例子。同样的，这时候你可以订阅来自这个部门的销售消息。</p><p>Java</p><pre><code>pipeline\n    .apply(KafkaIO.&lt;String, Long&gt;read()\n       .withBootstrapServers(&quot;broker_1:9092,broker_2:9092&quot;)\n       .withTopic(&quot;sales_record&quot;)  // use withTopics(List&lt;String&gt;) to read from multiple topics.\n       .withKeyDeserializer(StringDeserializer.class)\n       .withValueDeserializer(StringDeserializer.class)\n       .withLogAppendTime()\n    )\n</code></pre><p>之后你可以为你的输入PCollection添加窗口，和WordCount一样。不过这时候你很有可能需要滑动窗口，因为你的窗口是每小时移动一次。</p><p>Java</p><pre><code>PCollection&lt;String&gt; windowedProductIds = input\n  .apply(Window.&lt;String&gt;into(\n    SlidingWindows.of(Duration.standardMonths(options.getWindowSize()))));\n</code></pre><h3>3.怎样设计商品去重处理流水线和怎样根据商品在售状态过滤热销商品？</h3><p>通过前面的内容，我们已经设计出了能够每小时更新的热销榜单。但不知道你有没有注意到，其实我们之前的问题设置是过于简化了，忽略了很多现实而重要的问题，比如：</p><ul>\n<li>怎样处理退货的商品？</li>\n<li>怎样处理店家因为收到差评故意把商品下架换个马甲重新上架？</li>\n<li>怎样处理那些虽然曾经热销但是现在已经不再出售的商品？</li>\n</ul><p>这些问题都需要使用第28讲中介绍的Pipeline的基本设计模式：过滤模式。</p><p><img src=\"https://static001.geekbang.org/resource/image/47/0f/47498fc9b2d41c59ffb286d84c4f220f.jpg?wh=1674*1244\" alt=\"\"></p><p>我们这个案例中所需要的过滤条件是：</p><ul>\n<li>把退货的商品销量减去</li>\n<li>把重复的商品销量进行叠加</li>\n<li>将在售商品过滤出来</li>\n</ul><p>一起来想想这些过滤条件应该怎么实现吧。</p><p>对于退货商品，我们可以把所有退货的记录挑出来进行统计。同样对于每一个商品id，如果我们把出售的计数减去退货的计数就可以得到成功销售的计数。</p><p>而事实上，实际交易系统对于商品状态的跟踪会详细得多，每一个订单最终落在退货状态还是成功销售状态都可以在交易数据库中查询得到。我们可以把这个封装在isSuccessfulSale()方法中。</p><p>重复的商品在一个成熟的交易系统中一般会有另外一个去重的数据处理流水线。它能根据商品描述、商品图片等推测重复的商品。我们假设在我们系统中已经有了product_unique_id这样一个记录，那么我们只要把之前进行统计的product_id替换成统计product_unique_id就行了。</p><p>过滤在售的商品可能有多种实现方式，取决于你的小组有没有权限读取所需的数据库。</p><p>假如你可以读取一个商品状态的数据库列，那你可以直接根据 [商品状态=在售] 这样的判断条件进行过滤。假如你不能读取商品状态，那你可能需要查询在售的商品中是否有你的这个商品id来进行判断。但在这一讲中，我们先忽略实现细节，把这个过滤逻辑封装在isInStock()方法中。</p><p>最终我们的过滤处理步骤会是类似下面这样的。只有同时满足isSuccessfulSale()和isInStock()的product_unique_id，才会被我们后续的销量统计步骤所计算。</p><p>Java</p><pre><code>PCollection&lt;Product&gt; productCollection = ...;\n\nPCollection&lt;Product&gt; qualifiedProductCollection = productCollection\n  .apply(“uniqueProductTransform”, Distinct.withRepresentativeValueFn(\n      new SerializableFunction&lt;Product, Long&gt;() {\n        @Override\n        public Long apply(Product input) {\n          return input.productUniqueId();\n        }\n      }).withRepresentativeType(TypeDescriptor.of(Long.class))\n  )\n    .apply(&quot;filterProductTransform&quot;, ParDo.of(new DoFn&lt;Product, Product&gt;(){\n    @ProcessElement\n    public void processElement(ProcessContext c) {\n      if (isSuccessfulSale(c.element()) &amp;&amp; isInStockc.element())) {\n        c.output(c.element());\n      }\n    }\n  }));\n</code></pre><h3>4.怎样按不同的商品门类生成榜单？</h3><p>我们还注意到亚马逊的热销榜是按照不同的商品种类的。也就说每一个商品分类都有自己的榜单。这是很合理的业务设计，因为你不可能会去把飞机的销量和手机的销量相比，手机可能人手一个，飞机无法人手一个。</p><p>这时候我们在第28讲所学的分离模式设计就能大显身手了。分离模式把一个PCollection按照类别分离成了几个小的子PCollection。</p><p><img src=\"https://static001.geekbang.org/resource/image/c5/85/c5d84c2aab2e02cc6e1d2e9f7c40e185.jpg?wh=1902*936\" alt=\"\"></p><p>在这个案例里，我们也需要对商品进行分离。</p><p>与经典的分离模式不同，我们这里每一个商品可能都属于多个类别。比如一双鞋子，它可能既归类为“户外”，也归类为“潮鞋”。还记得分离模式在Beam中怎么实现吗？没错就是使用output tag。我们先要为每一种分类定义tag，比如刚才说的outdoorTag和fashionTag。再把相应的商品输出进对应的tag中。示例如下：</p><p>Java</p><pre><code>// 首先定义每一个output的tag\nfinal TupleTag&lt;Product&gt; outdoorTag = new TupleTag&lt;Product&gt;(){};\nfinal TupleTag&lt;Product&gt; fashionTag = new TupleTag&lt;Product&gt;(){};\n\nPCollection&lt;Product&gt; salesCollection = ...;\n\nPCollectionTuple mixedCollection =\n    userCollection.apply(ParDo\n        .of(new DoFn&lt;Product, Product&gt;() {\n          @ProcessElement\n          public void processElement(ProcessContext c) {\n            if (isOutdoorProduct(c.element())) {\n              c.output(c.element());\n            } else if (isFashionProduct(c.element())) {\n              c.output(fashionTag, c.element());\n\t        }\n          }\n        })\n        .withOutputTags(outdoorTag, TupleTagList.of(fashionTag)));\n\n// 分离出不同的商品分类\nmixedCollection.get(outdoorTag).apply(...);\n\nmixedCollection.get(fashionTag).apply(...);\n</code></pre><h2>小结</h2><p>这一讲我们从基础商品排行榜系统出发，利用到了之前学的数据处理设计模式和Beam编程方法。</p><p>同时，探索了以批处理计算为基础的热销商品列表。我们设计了每小时更新的热销榜单、商品去重处理流水线，根据商品在售状态过滤出热销商品，并按不同的商品门类生成榜单。</p><h2>思考题</h2><p>一个商品排名系统中还有太多需要解决的工程问题，你觉得哪些也可以利用大规模数据处理技术设计解决？</p><p>欢迎你把答案写在留言区，与我和其他同学一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。</p><p></p>","neighbors":{"left":{"article_title":"33 | 横看成岭侧成峰：再战Streaming WordCount","id":106491},"right":{"article_title":"35 | Facebook游戏实时流处理Beam Pipeline实战（上）","id":107529}},"comments":[{"had_liked":false,"id":113645,"user_name":"Ming","can_delete":false,"product_type":"c1","uid":1516011,"ip_address":"","ucode":"69BB73B8AB7E3F","user_header":"https://static001.geekbang.org/account/avatar/00/17/21/eb/bb2e7a3b.jpg","comment_is_top":false,"comment_ctime":1563104103,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40217809767","product_id":100025301,"comment_content":"本讲是这个课程中信息量最高的文章之一 👍👍👍 <br><br>不过我相信具体实现中的细节应该还有很多。不知道作者有没有机会分享一下常见的实现误区和pitfall？<br><br>除此之外，不知道文章说的这些方案在并发的能力上如何？假如有adhoc+并发的大数据场景，常见的大数据方案似乎在成本上都很高。这算是个大数据上的固有(intrinsic)难题嚒？","like_count":10},{"had_liked":false,"id":113496,"user_name":"YZJ","can_delete":false,"product_type":"c1","uid":1260810,"ip_address":"","ucode":"88B2A495A33197","user_header":"https://static001.geekbang.org/account/avatar/00/13/3d/0a/5f2a9a4c.jpg","comment_is_top":false,"comment_ctime":1563032452,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14447934340","product_id":100025301,"comment_content":"有人看明白为啥要用Distinct.withRepresentativeValueFn了么， 我理解就是个普通的转换，将productId转成producetUniqueId, 为什么要用Distinct呢？<br>","like_count":3,"discussions":[{"author":{"id":1503644,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIlfPxNV992tuuic57ehdqaSQMUlWZH5JJ7RGVUW32U2rDOl4ialRbRqfFy4H2YbCNy1Zg0HL4zzlmA/132","nickname":"Loic","note":"","ucode":"E594167599123A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353472,"discussion_content":"看起来是去重避免重复计算？这段代码应该是针对第三点去掉非在售商品做的处理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615167523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187934,"user_name":"Fiery","can_delete":false,"product_type":"c1","uid":1897610,"ip_address":"","ucode":"CDB000687A6B14","user_header":"","comment_is_top":false,"comment_ctime":1584279672,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10174214264","product_id":100025301,"comment_content":"&quot;按不同的商品门类生成榜单&quot;这个部分，文章只是简单说了一下怎么用API而已，但是实际使用中商品门类非常之多，如何使用合理的方案处理Amazon上千种门类，上万种商品（每种商品可能属于多个门类）的实时销量在pipeline中批量处理的情况？还请仔细讲一下，毕竟是“实战”不是只是过家家的toy app。","like_count":3},{"had_liked":false,"id":133912,"user_name":"楚天行","can_delete":false,"product_type":"c1","uid":1100648,"ip_address":"","ucode":"B4DD986060ECD4","user_header":"https://static001.geekbang.org/account/avatar/00/10/cb/68/d8a4f907.jpg","comment_is_top":false,"comment_ctime":1568696508,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"10158631100","product_id":100025301,"comment_content":"老师你好，这里有两点疑问：<br>（1）isSuccessfulSale 和 inStock，不能总是去交易系统实时去查的吧？这样开销会很大。<br>（2）是否可以最后在处理这个状态？虽然是最后被合并后的值，这样只需要很少的调用次数就可以实现了效果","like_count":2,"discussions":[{"author":{"id":1897610,"avatar":"","nickname":"Fiery","note":"","ucode":"CDB000687A6B14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":204832,"discussion_content":"退货这个感觉还是最好把退货事件filter出来然后单独求count，然后和sale的count做stream join好一些吧，但是stream join都是有watermark和时效性限制的，否则内存压力太大了，总不能设定join的有效时长成退货期限的30天90天这样吧？还是说因为只是存产品的count所以生产中的大规模集群真的是这么搞的?","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584230949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1100648,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cb/68/d8a4f907.jpg","nickname":"楚天行","note":"","ucode":"B4DD986060ECD4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1897610,"avatar":"","nickname":"Fiery","note":"","ucode":"CDB000687A6B14","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":243517,"discussion_content":"难","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587547317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":204832,"ip_address":""},"score":243517,"extra":""}]}]},{"had_liked":false,"id":119417,"user_name":"_yiunia##远","can_delete":false,"product_type":"c1","uid":1138369,"ip_address":"","ucode":"AF508C3D0EB954","user_header":"https://static001.geekbang.org/account/avatar/00/11/5e/c1/cd721d46.jpg","comment_is_top":false,"comment_ctime":1564582504,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5859549800","product_id":100025301,"comment_content":"“怎样设计每小时更新的热销榜单”<br>滑动窗口一小时滚动一次，而数据流在一直拉取，这段时间内的数据都是存在内存里么？不会爆掉么？还是另外有聚合的逻辑","like_count":1},{"had_liked":false,"id":117105,"user_name":"李孟","can_delete":false,"product_type":"c1","uid":1006768,"ip_address":"","ucode":"AD2349CB12F130","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/b0/77e5f8c8.jpg","comment_is_top":false,"comment_ctime":1563968863,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1563968863","product_id":100025301,"comment_content":"老师我想问下， PCollection&lt;String&gt;这个种懒加载出来的集合怎么转存成临时的list集合？","like_count":0},{"had_liked":false,"id":114460,"user_name":"Tim","can_delete":false,"product_type":"c1","uid":1393323,"ip_address":"","ucode":"A3ECD9832D630D","user_header":"https://static001.geekbang.org/account/avatar/00/15/42/ab/75fb1cd6.jpg","comment_is_top":false,"comment_ctime":1563322283,"is_pvip":false,"replies":[{"id":"42081","content":"👍","user_name":"作者回复","user_name_real":"廿七","uid":"1386753","ctime":1563514964,"ip_address":"","comment_id":114460,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563322283","product_id":100025301,"comment_content":"总算追上进度了，mark下～整理点疑问继续追加过来～","like_count":0,"discussions":[{"author":{"id":1386753,"avatar":"https://static001.geekbang.org/account/avatar/00/15/29/01/20caec2f.jpg","nickname":"Yeon","note":"","ucode":"ED3549F94EB36E","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458673,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563514964,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]}]}