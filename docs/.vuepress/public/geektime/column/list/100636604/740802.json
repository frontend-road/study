{"id":740802,"title":"第 3 章 基本数据类型","content":"\n<blockquote>\n<p>之所以世界上有很多很多类型的书，是因为世界上有很多很多类型的人，而每个人都在追求不同类型的知识。</p>\n<p style=\"text-align: right\">——Lemony Snicket</p>\n</blockquote>\n<p>&nbsp;</p>\n<p>在很大程度上，可以说 Rust 语言就是围绕其类型来设计的。Rust 对高性能代码的支持，源自它能让开发人员选择最适合当前场景的数据表示法，并在简单性和成本之间进行合理的权衡。Rust 的内存和线程安全保障也依赖于其类型系统的健全性，而 Rust 的灵活性则源于其泛型类型和特型。</p>\n<p>本章涵盖了 Rust 用以表示值的基本数据类型。这些源代码级类型都有其对应的机器级表示法，具有可预测的成本和性能。尽管 Rust 无法保证会完全按你的要求去表示各项事物，但只有当它确信能做出可靠的改进时才会谨慎地偏离你的原始要求。</p>\n<p>与 JavaScript 或 Python 等动态类型语言相比，Rust 需要你提前做出更多规划。你必须明确写出各个函数参数和返回值的类型、结构体字段以及一些其他结构体。然而，Rust 的以下两个特性让这项工作比你预想的要轻松一点儿。</p>\n<ul>\n<li><p>基于已明确写出的类型，Rust 的<strong>类型推断</strong>会帮你推断出剩下的大部分类型。实际上，对于给定的变量或表达式，通常只会有一种恰当的类型，在这种情况下，Rust 允许你省略类型。例如，你可以明确写出函数中的每一种类型，如下所示。</p><!-- [[[read_end]]] -->\n<pre class=\"code-rows\"><code>fn build_vector() -&gt; Vec&lt;i16&gt; {\n    let mut v: Vec&lt;i16&gt; = Vec::&lt;i16&gt;::new();\n    v.push(10i16);\n    v.push(20i16);\n    v\n}</code></pre>\n<p>但这既凌乱又啰唆。既然已知函数的返回类型，那么显然 <code>v</code> 只能是一个 <code>Vec&lt;i16&gt;</code>，也就是 16 位有符号整数的向量，其他类型都不行。由此可知该向量的每个元素都必须是 <code>i16</code>。这正是 Rust 的类型推断所擅长的那种推理方式，这样一来，你可以将上述代码改写成下面这样。</p>\n<pre class=\"code-rows\"><code>fn build_vector() -&gt; Vec&lt;i16&gt; {\n    let mut v = Vec::new();\n    v.push(10);\n    v.push(20);\n    v\n}</code></pre>\n<p>这两个定义是完全等效的，无论采用哪种方式，Rust 都会生成相同的机器码。类型推断让 Rust 具备了与动态类型语言相近的易读性，并且仍然能在编译期捕获类型错误。</p>\n<p>&nbsp;</p>\n</li>\n<li><p>函数可以是<strong>泛型</strong>的：单个函数就可以处理许多不同类型的值。</p>\n<p>在 Python 和 JavaScript 中，所有函数都天生如此：函数可以对任何具备该函数所要求的属性和方法的值进行操作。（这就是通常称为<strong>鸭子类型</strong>的特征：如果它叫得像鸭子，走路像鸭子，那它就是鸭子。）但也正是这种灵活性让这些语言很难及早发现类型错误，而测试通常是发现此类错误的唯一途径。Rust 的泛型函数为该语言提供了一定程度的灵活性，而且仍然能在编译期捕获所有的类型错误。</p>\n<p>虽然泛型函数更灵活，但其效率仍然与非泛型函数一样高。相较于编写能处理所有整数的泛型函数，为每种整数编写一个专用的 <code>sum</code> 函数并没有性能方面的内在优势。第 11 章会详细讨论泛型函数。</p>\n</li>\n</ul>\n<p>本章的其余部分自下向上介绍了 Rust 的一些类型，从简单的数值类型（如整数和浮点值）开始，转而介绍包含更多数据的类型：Box、元组（tuple）、数组和字符串。</p>\n<p>接下来是你将在 Rust 中看到的各种类型的摘要。表 3-1 展示了 Rust 的原始类型、标准库中一些最常见的类型以及一些用户定义类型的示例。</p>\n<p><strong>表 3-1：Rust 中的类型示例</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>类型</p></th>\n<th><p>说明</p></th>\n<th><p>值</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>i8</code>、<code>i16</code>、<code>i32</code>、<code>i64</code>、<code>i128</code>、<code>u8</code>、<code>u16</code>、<code>u32</code>、<code>u64</code>、<code>u128</code></p></td>\n<td><p>给定位宽的有符号整数和无符号整数</p></td>\n<td><p><code>42</code>、<code>-5i8</code>、<code>0x400u16</code>、<code>0o100i16</code>、<code>20_922_789_888_000u64</code>、<code>b'*'</code>（<code>u8</code> 字节字面量）</p></td>\n</tr>\n<tr>\n<td><p><code>isize</code>、<code>usize</code></p></td>\n<td><p>与机器字（32 位或 64 位）一样大的有符号整数和无符号整数</p></td>\n<td><p><code>137</code>、<code>-0b0101_0010isize</code>、<code>0xffff_fc00usize</code></p></td>\n</tr>\n<tr>\n<td><p><code>f32</code>、<code>f64</code></p></td>\n<td><p>单精度 IEEE 浮点数和双精度 IEEE 浮点数</p></td>\n<td><p><code>1.61803</code>、<code>3.14f32</code>、<code>6.0221e23f64</code></p></td>\n</tr>\n<tr>\n<td><p><code>bool</code></p></td>\n<td><p>布尔值</p></td>\n<td><p><code>true</code>、<code>false</code></p></td>\n</tr>\n<tr>\n<td><p><code>char</code></p></td>\n<td><p>Unicode 字符，32 位宽（4 字节）</p></td>\n<td><p><code>'*'</code>、<code>'\\n'</code>、<code>' 字 '</code>、<code>'\\x7f'</code>、<code>'\\u'</code></p></td>\n</tr>\n<tr>\n<td><p><code>(char, u8, i32)</code></p></td>\n<td><p>元组，允许混合类型</p></td>\n<td><p><code>('%', 0x7f, -1)</code></p></td>\n</tr>\n<tr>\n<td><p><code>()</code></p></td>\n<td><p>“单元”（空元组）</p></td>\n<td><p><code>()</code></p></td>\n</tr>\n<tr>\n<td><p><code>struct S { x: f32, y: f32 }</code></p></td>\n<td><p>具名字段型结构体</p></td>\n<td><p><code>S { x: 120.0, y: 209.0}</code></p></td>\n</tr>\n<tr>\n<td><p><code>struct T(i32, char);</code></p></td>\n<td><p>元组型结构体</p></td>\n<td><p><code>T (120, 'X')</code></p></td>\n</tr>\n<tr>\n<td><p><code>struct E;</code></p></td>\n<td><p>单元型结构体，无字段</p></td>\n<td><p><code>E</code></p></td>\n</tr>\n<tr>\n<td><p><code>enum Attend { OnTime, Late(u32)}</code></p></td>\n<td><p>枚举，或代数数据类型</p></td>\n<td><p><code>Attend::Late(5)</code>、<code>Attend::OnTime</code></p></td>\n</tr>\n<tr>\n<td><p><code>Box&lt;Attend&gt;</code></p></td>\n<td><p><code>Box</code>：指向堆中值的拥有型指针</p></td>\n<td><p><code>Box::new(Late(15))</code></p></td>\n</tr>\n<tr>\n<td><p><code>&amp;i32</code>、<code>&amp;mut i32</code></p></td>\n<td><p>共享引用和可变引用：非拥有型指针，其生命周期不能超出引用目标</p></td>\n<td><p><code>&amp;s.y</code>、<code>&amp;mut v</code></p></td>\n</tr>\n<tr>\n<td><p><code>String</code></p></td>\n<td><p>UTF-8 字符串，动态分配大小</p></td>\n<td><p><code>\" ラ一メン : ramen\".to_string()</code></p></td>\n</tr>\n<tr>\n<td><p><code>&amp;str</code></p></td>\n<td><p>对 <code>str</code> 的引用：指向 UTF-8 文本的非拥有型指针</p></td>\n<td><p><code>\" そば : soba\"</code>、<code>&amp;s[0..12]</code></p></td>\n</tr>\n<tr>\n<td><p><code>[f64; 4]</code>、<code>[u8; 256]</code></p></td>\n<td><p>数组，固定长度，其元素类型都相同</p></td>\n<td><p><code>[1.0, 0.0, 0.0, 1.0]</code>、<code>[b' '; 256]</code></p></td>\n</tr>\n<tr>\n<td><p><code>Vec&lt;f64&gt;</code></p></td>\n<td><p>向量，可变长度，其元素类型都相同</p></td>\n<td><p><code>vec![0.367, 2.718, 7.389]</code></p></td>\n</tr>\n<tr>\n<td><p><code>&amp;[u8]</code>、<code>*mut [u8]</code></p></td>\n<td><p>对切片（数组或向量某一部分）的引用，包含指针和长度</p></td>\n<td><p><code>&amp;v[10..20]</code>、<code>&amp;mut a[..]</code></p></td>\n</tr>\n<tr>\n<td><p><code>Option&lt;&amp;str&gt;</code></p></td>\n<td><p>可选值：或者为 <code>None</code>（无值），或者为 <code>Some(v)</code>（有值，其值为 <code>v</code>）</p></td>\n<td><p><code>Some(\"Dr.\"), None</code></p></td>\n</tr>\n<tr>\n<td><p><code>Result&lt;u64, Error&gt;</code></p></td>\n<td><p>可能失败的操作结果：或者为成功值 <code>Ok(v)</code>，或者为错误值 <code>Err(e)</code></p></td>\n<td><p><code>Ok(4096), Err(Error::last_os_error())</code></p></td>\n</tr>\n<tr>\n<td><p><code>&amp;dyn Any</code>、<code>&amp;mut dyn Read</code></p></td>\n<td><p>特型对象，是对任何实现了一组给定方法的值的引用</p></td>\n<td><p><code>value as &amp;dyn Any</code>、<code>&amp;mut file as &amp;mut dyn Read</code></p></td>\n</tr>\n<tr>\n<td><p><code>fn(&amp;str) -&gt; bool</code></p></td>\n<td><p>函数指针</p></td>\n<td><p><code>str::is_empty</code></p></td>\n</tr>\n<tr>\n<td><p>（闭包类型没有显式书写形式）</p></td>\n<td><p>闭包</p></td>\n<td><p><code>|a, b| a * a + b * b</code></p></td>\n</tr>\n</tbody>\n</table>\n<p>本章会对上述大多数类型进行介绍，但以下类型除外。</p>\n<ul>\n<li>结构体（<code>struct</code>）类型（参见第 9 章）。</li>\n<li>枚举类型（参见第 10 章）。</li>\n<li>特型对象（参见第 11 章）。</li>\n<li>函数和闭包类型（参见第 14 章）。</li>\n<li><code>String</code> 和 <code>&amp;str</code> 的更多细节（参见第 17 章）。</li>\n</ul>\n<h2 id=\"nav_point_41\">3.1　固定宽度的数值类型</h2>\n<p>Rust 类型系统的根基是一组固定宽度的数值类型，选用这些类型是为了匹配几乎所有现代处理器都已直接在硬件中实现的类型。</p>\n<p>固定宽度的数值类型可能会溢出或丢失精度，但它们足以满足大多数应用程序的需求，并且要比任意精度整数和精确有理数等表示法快数千倍。如果需要后面提到的那些类型的数值的表示法，可以到 <code>num</code> crate 中找到它们。</p>\n<p>Rust 中数值类型的名称都遵循着一种统一的模式，也就是以“位”数表明它们的宽度，以前缀表明它们的用法，如表 3-2 所示。</p>\n<p><strong>表 3-2：Rust 数值类型</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>大小（位）</p></th>\n<th><p>无符号整数</p></th>\n<th><p>有符号整数</p></th>\n<th><p>浮点数</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>8</code></p></td>\n<td><p><code>u8</code></p></td>\n<td><p><code>i8</code></p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p><code>16</code></p></td>\n<td><p><code>u16</code></p></td>\n<td><p><code>i16</code></p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p><code>32</code></p></td>\n<td><p><code>u32</code></p></td>\n<td><p><code>i32</code></p></td>\n<td><p><code>f32</code></p></td>\n</tr>\n<tr>\n<td><p><code>64</code></p></td>\n<td><p><code>u64</code></p></td>\n<td><p><code>i64</code></p></td>\n<td><p><code>f64</code></p></td>\n</tr>\n<tr>\n<td><p><code>128</code></p></td>\n<td><p><code>u128</code></p></td>\n<td><p><code>i128</code></p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p>机器字</p></td>\n<td><p><code>usize</code></p></td>\n<td><p><code>isize</code></p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n</tbody>\n</table>\n<p>在这里，<strong>机器字</strong>是一个值，其大小等于运行此代码的机器上“地址”的大小，可能是 32 位，也可能是 64 位。</p>\n<h3 id=\"nav_point_42\">3.1.1　整型</h3>\n<p>Rust 的无符号整型会使用它们的完整范围来表示正值和 0，如表 3-3 所示。</p>\n<p><strong>表 3-3：Rust 无符号整型</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>类型</p></th>\n<th><p>范围</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>u8</code></p></td>\n<td><p>0 到 2<sup>8</sup>-1（0 到 255）</p></td>\n</tr>\n<tr>\n<td><p><code>u16</code></p></td>\n<td><p>0 到 2<sup>16</sup>-1（0 到 65 535）</p></td>\n</tr>\n<tr>\n<td><p><code>u32</code></p></td>\n<td><p>0 到 2<sup>32</sup>-1（0 到 4 294 967 295）</p></td>\n</tr>\n<tr>\n<td><p><code>u64</code></p></td>\n<td><p>0 到 2<sup>64</sup>-1（0 到 18 446 744 073 709 551 615 或 1844 京）</p></td>\n</tr>\n<tr>\n<td><p><code>u128</code></p></td>\n<td><p>0 到 2<sup>128</sup>-1（0 到大约 3.4×10<sup>38</sup>）</p></td>\n</tr>\n<tr>\n<td><p><code>usize</code></p></td>\n<td><p>0 到 2<sup>32</sup>-1 或 2<sup>64</sup>-1</p></td>\n</tr>\n</tbody>\n</table>\n<p>Rust 的有符号整型会使用二进制补码表示，使用与相应的无符号类型相同的位模式来覆盖正值和负值的范围，如表 3-4 所示。</p>\n<p><strong>表 3-4：Rust 有符号整型</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>类型</p></th>\n<th><p>范围</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>i8</code></p></td>\n<td><p>-2<sup>7</sup> 到 2<sup>7</sup>-1（-128 到 127）</p></td>\n</tr>\n<tr>\n<td><p><code>i16</code></p></td>\n<td><p>-2<sup>15</sup> 到 2<sup>15</sup>-1（-32 768 到 32 767）</p></td>\n</tr>\n<tr>\n<td><p><code>i32</code></p></td>\n<td><p>-2<sup>31</sup> 到 2<sup>31</sup>-1（-2 147 483 648 到 2 147 483 647）</p></td>\n</tr>\n<tr>\n<td><p><code>i64</code></p></td>\n<td><p>-2<sup>63</sup> 到 2<sup>63</sup>-1（-9 223 372 036 854 775 808 到 9 223 372 036 854 775 807）</p></td>\n</tr>\n<tr>\n<td><p><code>i128</code></p></td>\n<td><p>-2<sup>127</sup> 到 2<sup>127</sup>-1（大约-1.7×10<sup>38</sup> 到 +1.7×10<sup>38</sup>）</p></td>\n</tr>\n<tr>\n<td><p><code>isize</code></p></td>\n<td><p>-2<sup>31</sup> 到 2<sup>31</sup>-1 或-2<sup>63</sup> 到 2<sup>63</sup>-1</p></td>\n</tr>\n</tbody>\n</table>\n<p>Rust 会使用 <code>u8</code> 类型作为字节值。例如，从二进制文件或套接字中读取数据时会产生一个 <code>u8</code> 值构成的流。</p>\n<p>与 C 和 C++ 不同，Rust 会把字符视为与数值截然不同的类型：<code>char</code> 既不是 <code>u8</code>，也不是 <code>u32</code>（尽管它确实有 32 位长）。稍后 3.3 节会详细讲解 Rust 的 <code>char</code> 类型。</p>\n<p><code>usize</code> 类型和 <code>isize</code> 类型类似于 C 和 C++ 中的 <code>size_t</code> 和 <code>ptrdiff_t</code>。它们的精度与目标机器上地址空间的大小保持一致，即在 32 位架构上是 32 位长，在 64 位架构上则是 64 位长。Rust 要求数组索引是 <code>usize</code> 值。用来表示数组或向量大小或某些数据结构中元素数量的值通常也是 <code>usize</code> 类型。</p>\n<p>Rust 中的整型字面量可以带上一个后缀来指示它们的类型：<code>42u8</code> 是 <code>u8</code> 类型，<code>1729isize</code> 是 <code>isize</code> 类型。如果整型字面量没有带类型后缀，那么 Rust 就会延迟确定其类型，直到找出一处足以认定其类型的使用代码，比如存储在特定类型的变量中、传给期待特定类型的函数、与具有特定类型的另一个值进行比较，等等。最后，如果有多种候选类型，那么 Rust 就会默认使用 <code>i32</code>（如果是候选类型之一的话）。如果无法认定类型，那么 Rust 就会将此歧义报告为错误。</p>\n<p>前缀 <code>0x</code>、<code>0o</code> 和 <code>0b</code> 分别表示十六进制字面量、八进制字面量和二进制字面量。</p>\n<p>为了让长数值更易读，可以在数字之间任意插入下划线。例如，可以将 <code>u32</code> 的最大值写为 <code>4_294_967_295</code>。下划线的具体位置无关紧要，因此也可以将十六进制数或二进制数按 4 位数字而非 3 位数字进行分组（如 <code>0xffff_ffff</code>），或分隔开数字的类型后缀（如 <code>127_u8</code>）。表 3-5 中展示了整型字面量的一些示例。</p>\n<p><strong>表 3-5：整型字面量示例</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>字面量</p></th>\n<th><p>类型</p></th>\n<th><p>十进制值</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>116i8</code></p></td>\n<td><p><code>i8</code></p></td>\n<td><p><code>116</code></p></td>\n</tr>\n<tr>\n<td><p><code>0xcafeu32</code></p></td>\n<td><p><code>u32</code></p></td>\n<td><p><code>51966</code></p></td>\n</tr>\n<tr>\n<td><p><code>0b0010_1010</code></p></td>\n<td><p>推断</p></td>\n<td><p><code>42</code></p></td>\n</tr>\n<tr>\n<td><p><code>0o106</code></p></td>\n<td><p>推断</p></td>\n<td><p><code>70</code></p></td>\n</tr>\n</tbody>\n</table>\n<p>尽管数值类型和 <code>char</code> 类型是不同的，但 Rust 确实为 <code>u8</code> 值提供了<strong>字节字面量</strong>。与字符字面量类似，<code>b'X'</code> 表示以字符 <code>X</code> 的 ASCII 码作为 <code>u8</code> 值。例如，由于 <code>A</code> 的 ASCII 码是 65，因此字面量 <code>b'A'</code> 和 <code>65u8</code> 完全等效。只有 ASCII 字符才能出现在字节字面量中。</p>\n<p>有几个字符不能简单地放在单引号后面，因为那样在语法上会有歧义或难以阅读。表 3-6 中的字符只能以反斜杠开头的替代符号来书写。</p>\n<p><strong>表 3-6：需要替代符号的字符</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>字符</p></th>\n<th><p>字节字面量</p></th>\n<th><p>等效的数值</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>单引号（<code>'</code>）</p></td>\n<td><p><code>b'\\''</code></p></td>\n<td><p><code>39u8</code></p></td>\n</tr>\n<tr>\n<td><p>反斜杠（<code>\\</code>）</p></td>\n<td><p><code>b'\\\\'</code></p></td>\n<td><p><code>92u8</code></p></td>\n</tr>\n<tr>\n<td><p>换行（<code>lf</code>）</p></td>\n<td><p><code>b'\\n'</code></p></td>\n<td><p><code>10u8</code></p></td>\n</tr>\n<tr>\n<td><p>回车（<code>cr</code>）</p></td>\n<td><p><code>b'\\r'</code></p></td>\n<td><p><code>13u8</code></p></td>\n</tr>\n<tr>\n<td><p>制表符（<code>tab</code>）</p></td>\n<td><p><code>b'\\t'</code></p></td>\n<td><p><code>9u8</code></p></td>\n</tr>\n</tbody>\n</table>\n<p>对于难于书写或阅读的字符，可以将其编码改为十六进制。这种字节字面量形如 <code>b'\\xHH'</code>，其中 <code>HH</code> 是任意两位十六进制数，表示值为 <code>HH</code> 的字节。例如，你可以将 ASCII 控制字符 <code>escape</code> 的字节字面量写成 <code>b'\\x1b'</code>，因为 <code>escape</code> 的 ASCII 码为 27，即十六进制的 1B。由于字节字面量只是 <code>u8</code> 值的表示法之一，因此还应该考虑使用一个整型字面量是否更易读：只有当你要强调该值表示的是 ASCII 码时，才应该使用 <code>b'\\x1b'</code> 而不是简单明了的 27。</p>\n<p>可以使用 <code>as</code> 运算符将一种整型转换为另一种整型。6.14 节会详细讲解类型转换的原理，这里先举一些例子：</p>\n<pre>\nassert_eq!(   10_i8  as u16,    10_u16); // 范围内转换\nassert_eq!( 2525_u16 as i16,  2525_i16); // 范围内转换\n\nassert_eq!(   -1_i16 as i32,    -1_i32); // 带符号扩展\nassert_eq!(65535_u16 as i32, 65535_i32); // 填零扩展\n\n// 超出目标范围的转换生成的值等于原始值对2<sup>N</sup>取模的值，\n// 其中N是按位算的目标宽度。有时这也称为“截断”\nassert_eq!( 1000_i16 as  u8,   232_u8);\nassert_eq!(65535_u32 as i16,    -1_i16);\n\nassert_eq!(   -1_i8  as u8,    255_u8);\nassert_eq!(  255_u8  as i8,     -1_i8);\n</pre>\n\n<p>标准库提供了一些运算，可以像整型的方法一样使用。例如：</p>\n<pre class=\"code-rows\"><code>assert_eq!(2_u16.pow(4), 16);            // 求幂\nassert_eq!((-4_i32).abs(), 4);           // 求绝对值\nassert_eq!(0b101101_u8.count_ones(), 4); // 求二进制1的个数</code></pre>\n<p>可以在在线文档中找到这些内容。但请注意，该文档在“<code>i32</code>（原始类型）”和此类型的专有模块（搜索“<code>std::i32</code>”）下的单独页面中分别含有此类型的信息。</p>\n<p>在实际编码中，通常不必像刚才那样写出类型后缀，因为其上下文将决定类型。但是，如果没有类型后缀且无法决定类型，那么错误消息可能会令人惊讶。例如，以下代码无法编译：</p>\n<pre class=\"code-rows\"><code>println!(\"{}\", (-4).abs());</code></pre>\n<p>Rust 会报错：</p>\n<pre class=\"code-rows\"><code>error: can't call method `abs` on ambiguous numeric type ``</code></pre>\n<p>这令人不解：明明所有的有符号整型都有一个 <code>abs</code> 方法，那么问题出在哪里呢？出于技术原因，Rust 在调用类型本身的方法之前必须确切地知道一个值属于哪种整型。只有在解析完所有方法调用后类型仍然不明确的时候，才会默认为 <code>i32</code>，但这里并没有其他方法可供解析，因此 Rust 提供不了帮助。解决方案是加上后缀或使用特定类型的函数来明确写出希望的类型：</p>\n<pre class=\"code-rows\"><code>println!(\"{}\", (-4_i32).abs());\nprintln!(\"{}\", i32::abs(-4));</code></pre>\n<p>请注意，方法调用的优先级高于一元前缀运算符，因此在将方法应用于负值时要小心。如果第一个语句中 <code>-4_i32</code> 周围没有圆括号，则 <code>-4_i32.abs()</code> 会先针对正值 <code>4</code> 调用 <code>abs</code> 方法，生成正值 <code>4</code>，再根据负号取负，得到 <code>-4</code>。</p>\n<h3 id=\"nav_point_43\">3.1.2　检查算法、回绕算法、饱和算法和溢出算法</h3>\n<p>当整型算术运算溢出时，Rust 在调试构建中会出现 panic。而在发布构建中，运算会<strong>回绕</strong>：它生成的值等于“数学意义上正确的结果”对“值类型范围”取模的值。（在任何情况下都不会像 C 和 C++ 中那样出现“溢出未定义”的行为。）</p>\n<p>例如，以下代码在调试构建中会出现 panic：</p>\n<pre class=\"code-rows\"><code>let mut i = 1;\nloop {\n    i *= 10; // panic：试图进行可能溢出的乘法（但只会在调试构建中出现）\n}</code></pre>\n<p>在发布构建中，此乘法会返回负数，并且循环会无限运行。</p>\n<p>如果这种默认行为不是你想要的，则整型提供的某些方法可以让你准确地阐明自己期望的行为。例如，在任意构建中都会出现下列 panic：</p>\n<pre class=\"code-rows\"><code>let mut i: i32 = 1;\nloop {\n    // panic：乘法溢出（在任意构建中出现）\n    i = i.checked_mul(10).expect(\"multiplication overflowed\");\n}</code></pre>\n<p>这些整型算术方法分为 4 大类。</p>\n<ul>\n<li><p><strong>检查</strong>运算会返回结果的 <code>Option</code> 值：如果数学意义上正确的结果可以表示为该类型的值，那么就为 <code>Some(v)</code>，否则为 <code>None</code>。</p>\n<pre>\n// 10与20之和可以表示为u8\nassert_eq!(10_u8.checked_add(20), Some(30));\n\n// 很遗憾，100与200之和不能表示为u8\nassert_eq!(100_u8.checked_add(200), None);\n\n// 做加法。如果溢出，则会出现panic\nlet sum = x.checked_add(y).unwrap();\n\n// 奇怪的是，在某种特殊情况下，带符号的除法也会溢出。\n// 带符号的n位类型可以表示-2<sup>n-1</sup>，但不足以表示2<sup>n-1</sup>\nassert_eq!((-128_i8).checked_div(-1), None);\n</pre>\n\n<p>&nbsp;</p>\n</li>\n<li><p><strong>回绕</strong>运算会返回与“数学意义上正确的结果”对“值类型范围”取模的值相等的值。</p>\n<pre>\n// 第一个结果可以表示为u16，第二个则不能，所以会得到250000 对2<sup>16</sup>的模\nassert_eq!(100_u16.wrapping_mul(200), 20000);\nassert_eq!(500_u16.wrapping_mul(500), 53392);\n\n// 对有符号类型的运算可能会回绕为负值\nassert_eq!(500_i16.wrapping_mul(500), -12144);\n\n// 在移位运算中，移位距离会在值的大小范围内回绕，\n// 所以在16位类型中移动17位就相当于移动了1位\nassert_eq!(5_i16.wrapping_shl(17), 10);\n</pre>\n\n</li>\n</ul>\n<p>如前所述，这就是普通算术运算符在发布构建中的行为。这些方法的优点是它们在所有构建中的行为方式都是相同的。</p>\n<ul>\n<li><p><strong>饱和</strong>运算会返回最接近“数学意义上正确结果”的可表达值。换句话说，结果“紧贴着”该类型可表达的最大值和最小值。</p>\n<pre class=\"code-rows\"><code>assert_eq!(32760_i16.saturating_add(10), 32767);\nassert_eq!((-32760_i16).saturating_sub(10), -32768);</code></pre>\n<p>不存在饱和除法<span class=\"comment-number\">1</span>、饱和求余法<span class=\"comment-number\">2</span>或饱和位移法<span class=\"comment-number\">3</span>。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>溢出</strong>运算会返回一个元组 <code>(result, overflowed)</code>，其中 <code>result</code> 是函数的回绕版本所返回的内容，而 <code>overflowed</code> 是一个布尔值，指示是否发生过溢出。</p>\n<pre class=\"code-rows\"><code>assert_eq!(255_u8.overflowing_sub(2), (253, false));\nassert_eq!(255_u8.overflowing_add(2), (1, true));</code></pre>\n<p><code>overflowing_shl</code> 和 <code>overflowing_shr</code> 稍微偏离了这种模式：只有当移位距离与类型本身的位宽一样大或比其更大时，它们才会为 <code>overflowed</code> 返回 <code>true</code>。实际应用的移位数是所请求的移位数对类型位宽取模的结果。</p>\n<pre class=\"code-rows\"><code>// 移动17位对`u16`来说太大了，而17对16取模就是1\nassert_eq!(5_u16.overflowing_shl(17), (10, true));</code></pre>\n</li>\n</ul>\n\n\n\n<p>前缀 <code>checked_</code>、<code>wrapping_</code>、<code>saturating_</code> 或 <code>overflowing_</code> 后面可以跟着的运算名称如表 3-7 所示。</p>\n<p><strong>表 3-7：运算名称</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>运算</p></th>\n<th><p>名称后缀</p></th>\n<th><p>例子</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>加法</p></td>\n<td><p><code>add</code></p></td>\n<td><p><code>100_i8.checked_add(27) == Some(127)</code></p></td>\n</tr>\n<tr>\n<td><p>减法</p></td>\n<td><p><code>sub</code></p></td>\n<td><p><code>10_u8.checked_sub(11) == None</code></p></td>\n</tr>\n<tr>\n<td><p>乘法</p></td>\n<td><p><code>mul</code></p></td>\n<td><p><code>128_u8.saturating_mul(3) == 255</code></p></td>\n</tr>\n<tr>\n<td><p>除法</p></td>\n<td><p><code>div</code></p></td>\n<td><p><code>64_u16.wrapping_div(8) == 8</code></p></td>\n</tr>\n<tr>\n<td><p>求余</p></td>\n<td><p><code>rem</code></p></td>\n<td><p><code>(-32768_i16).wrapping_rem(-1) == 0</code></p></td>\n</tr>\n<tr>\n<td><p>取负</p></td>\n<td><p><code>neg</code></p></td>\n<td><p><code>(-128_i8).checked_neg() == None</code></p></td>\n</tr>\n<tr>\n<td><p>绝对值</p></td>\n<td><p><code>abs</code></p></td>\n<td><p><code>(-32768_i16).wrapping_abs() == -32768</code></p></td>\n</tr>\n<tr>\n<td><p>求幂</p></td>\n<td><p><code>pow</code></p></td>\n<td><p><code>3_u8.checked_pow(4) == Some(81)</code></p></td>\n</tr>\n<tr>\n<td><p>按位左移</p></td>\n<td><p><code>shl</code></p></td>\n<td><p><code>10_u32.wrapping_shl(34) == 40</code></p></td>\n</tr>\n<tr>\n<td><p>按位右移</p></td>\n<td><p><code>shr</code></p></td>\n<td><p><code>40_u64.wrapping_shr(66) == 10</code></p></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"nav_point_44\">3.1.3　浮点类型</h3>\n<p>Rust 提供了 IEEE 单精度浮点类型和 IEEE 双精度浮点类型。这些类型包括正无穷大和负无穷大、不同的正零值和负零值，以及<strong>非数值</strong>。如表 3-8 所示。</p>\n<p><strong>表 3-8：IEEE 单精度浮点类型和 IEEE 双精度浮点类型</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>类型</p></th>\n<th><p>精度</p></th>\n<th><p>范围</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>f32</code></p></td>\n<td><p>IEEE 单精度（至少 6 位小数）</p></td>\n<td><p>大约 -3.4 × 10<sup>38</sup> 至 +3.4 × 10<sup>38</sup></p></td>\n</tr>\n<tr>\n<td><p><code>f64</code></p></td>\n<td><p>IEEE 双精度（至少 15 位小数）</p></td>\n<td><p>大约 -1.8 × 10<sup>308</sup> 至 +1.8 × 10<sup>308</sup></p></td>\n</tr>\n</tbody>\n</table>\n<p>Rust 的 <code>f32</code> 和 <code>f64</code> 分别对应于 C 和 C++（在支持 IEEE 浮点的实现中）以及 Java（始终使用 IEEE 浮点）中的 <code>float</code> 类型和 <code>double</code> 类型。</p>\n<p>浮点字面量的一般化形式如图 3-1 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00818.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 3-1：浮点字面量</strong></p>\n<p>浮点数中整数部分之后的每个部分都是可选的，但必须至少存在小数部分、指数或类型后缀这三者中的一个，以将其与整型字面量区分开来。小数部分可以仅由一个单独的小数点组成，因此 <code>5.</code> 也是有效的浮点常量。</p>\n<p>如果浮点字面量缺少类型后缀，那么 Rust 就会检查上下文以查看值的使用方式，这与整型字面量非常相似。如果它最终发现这两种浮点类型都适合，就会默认选择 <code>f64</code>。</p>\n<p>为了便于类型推断，Rust 会将整型字面量和浮点字面量视为不同的大类：它永远不会把整型字面量推断为浮点类型，反之亦然。表 3-9 展示了浮点字面量的一些示例。</p>\n<p><strong>表 3-9：浮点字面量的例子</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>字面量</p></th>\n<th><p>类型</p></th>\n<th><p>数学值</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>-1.5625</code></p></td>\n<td><p>自动推断</p></td>\n<td><p>−(1<sup>9</sup>/<sub>16</sub>)</p></td>\n</tr>\n<tr>\n<td><p><code>2.</code></p></td>\n<td><p>自动推断</p></td>\n<td><p>2</p></td>\n</tr>\n<tr>\n<td><p><code>0.25</code></p></td>\n<td><p>自动推断</p></td>\n<td><p>¼</p></td>\n</tr>\n<tr>\n<td><p><code>1e4</code></p></td>\n<td><p>自动推断</p></td>\n<td><p>10 000</p></td>\n</tr>\n<tr>\n<td><p><code>40f32</code></p></td>\n<td><p><code>f32</code></p></td>\n<td><p>40</p></td>\n</tr>\n<tr>\n<td><p><code>9.109_383_56e-31f64</code></p></td>\n<td><p><code>f64</code></p></td>\n<td><p>大约 9.109 383 56 × 10<sup>-31</sup></p></td>\n</tr>\n</tbody>\n</table>\n<p><code>f32</code> 类型和 <code>f64</code> 类型具有 IEEE 要求的一些特殊值的关联常量，比如 <code>INFINITY</code>（无穷大）、<code>NEG_INFINITY</code>（负无穷大）、<code>NAN</code>（非数值）以及 <code>MIN</code>（最小有限值）和 <code>MAX</code>（最大有限值）：</p>\n<pre class=\"code-rows\"><code>assert!((-1. / f32::INFINITY).is_sign_negative());\nassert_eq!(-f32::MIN, f32::MAX);</code></pre>\n<p><code>f32</code> 类型和 <code>f64</code> 类型提供了完备的数学计算方法，比如 <code>2f64.sqrt()</code> 就是 <code>2</code> 的双精度平方根。下面是一些例子：</p>\n<pre class=\"code-rows\"><code>assert_eq!(5f32.sqrt() * 5f32.sqrt(), 5.); // 按IEEE的规定，它精确等于5.0\nassert_eq!((-1.01f64).floor(), -2.0);</code></pre>\n<p>再次提醒，方法调用的优先级高于前缀运算符，因此在对负值进行方法调用时，请务必正确地加上圆括号。</p>\n<p><code>std::f32::consts</code> 模块和 <code>std::f64::consts</code> 模块提供了各种常用的数学常量，比如 <code>E</code>、<code>PI</code> 和 <code>2</code> 的平方根。</p>\n<p>在搜索文档时，请记住这两种类型本身都有名为“<code>f32</code>（原始类型）”和“<code>f64</code>（原始类型）”的页面，以及每种类型的单独模块 <code>std::f32</code> 和 <code>std::f64</code>。</p>\n<p>与整数一样，通常不必在实际代码中写出浮点字面量的类型后缀，但如果你想这么做，那么将类型放在字面量或函数上就可以：</p>\n<pre class=\"code-rows\"><code>println!(\"{}\", (2.0_f64).sqrt());\nprintln!(\"{}\", f64::sqrt(2.0));</code></pre>\n<p>与 C 和 C++ 不同，Rust 几乎不会执行任何隐式的数值转换。如果函数需要 <code>f64</code> 参数，则传入 <code>i32</code> 型参数是错误的。事实上，Rust 甚至不会隐式地将 <code>i16</code> 值转换为 <code>i32</code> 值，虽然每个 <code>i16</code> 值都必然在 <code>i32</code> 范围内。不过，你随时可以用 <code>as</code> 运算符写出<strong>显式</strong>转换：<code>i as f64</code> 或 <code>x as i32</code>。</p>\n<p>缺少隐式转换有时会让 Rust 表达式比类似的 C 或 C++ 代码更冗长。然而，隐式整数转换有着导致错误和安全漏洞的大量“前科”，特别是在用这种整数表示内存中某些内容的大小时，很可能发生意外溢出。根据以往的经验，Rust 这种要求明确写出数值类型转换的行为，会提醒我们注意到一些可能错过的问题。</p>\n<p>6.14 节会解释各种类型转换的确切行为。</p>\n<h2 id=\"nav_point_45\">3.2　布尔类型</h2>\n<p>Rust 的布尔类型 <code>bool</code> 具有此类型常用的两个值 <code>true</code> 和 <code>false</code>。<code>==</code>、<code>&lt;</code> 等比较运算符会生成 <code>bool</code> 结果，比如 <code>2 &lt; 5</code> 的值为 <code>true</code>。</p>\n<p>许多语言对在要求布尔值的上下文中使用其他类型的值持宽松态度，比如 C 和 C++ 会把字符、整数、浮点数和指针隐式转换成布尔值，因此它们可以直接用作 <code>if</code> 语句或 <code>while</code> 语句中的条件。Python 允许在布尔上下文中使用字符串、列表、字典甚至 <code>Set</code>，如果这些值是非空的，则将它们视为 <code>true</code>。然而，Rust 非常严格：像 <code>if</code> 和 <code>while</code> 这样的控制结构要求它们的条件必须是 <code>bool</code> 表达式，短路逻辑运算符 <code>&amp;&amp;</code> 和 <code>||</code> 也是如此。你必须写成 <code>if x != 0 { ... }</code>，而不能只写成 <code>if x { ... }</code>。</p>\n<p>Rust 的 <code>as</code> 运算符可以将 <code>bool</code> 值转换为整型：</p>\n<pre class=\"code-rows\"><code>assert_eq!(false as i32, 0);\nassert_eq!(true  as i32, 1);</code></pre>\n<p>但是，<code>as</code> 无法进行另一个方向（从数值类型到 bool）的转换。相反，你必须显式地写出比较表达式，比如 <code>x != 0</code>。</p>\n<p>尽管 <code>bool</code> 只需要用一个位来表示，但 Rust 在内存中会使用整字节来表示 <code>bool</code> 值，因此可以创建指向它的指针。</p>\n<h2 id=\"nav_point_46\">3.3　字符</h2>\n<p>Rust 的字符类型 <code>char</code> 会以 <code>32</code> 位值表示单个 Unicode 字符。</p>\n<p>Rust 会对单独的字符使用 <code>char</code> 类型，但对字符串和文本流使用 <code>UTF-8</code> 编码。因此，<code>String</code> 会将其文本表示为 UTF-8 字节序列，而不是字符数组。</p>\n<p>字符字面量是用单引号括起来的字符，比如 <code>'8'</code> 或 <code>'!'</code>。还可以使用全角 Unicode 字符：<code>' 錆 '</code> 是一个 <code>char</code> 字面量，表示日文汉字中的 sabi（rust）。</p>\n<p>与字节字面量一样，有些字符需要用反斜杠转义，如表 3-10 所示。</p>\n<p><strong>表 3-10：需要用反斜杠转义的字符</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>字符</p></th>\n<th><p>Rust 字符字面量</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>单引号（<code>'</code>）</p></td>\n<td><p><code>'\\''</code></p></td>\n</tr>\n<tr>\n<td><p>反斜杠（<code>\\</code>）</p></td>\n<td><p><code>'\\\\'</code></p></td>\n</tr>\n<tr>\n<td><p>换行（<code>lf</code>）</p></td>\n<td><p><code>'\\n'</code></p></td>\n</tr>\n<tr>\n<td><p>回车（<code>cr</code>）</p></td>\n<td><p><code>'\\r'</code></p></td>\n</tr>\n<tr>\n<td><p>制表（<code>tab</code>）</p></td>\n<td><p><code>'\\t'</code></p></td>\n</tr>\n</tbody>\n</table>\n<p>如果你愿意，还可以用十六进制写出字符的 Unicode 码点。</p>\n<ul>\n<li>如果字符的码点在 U+0000 到 U+007F 范围内（也就是说，如果它是从 ASCII 字符集中提取的），就可以把字符写为 <code>'\\xHH'</code>，其中 <code>HH</code> 是两个十六进制数。例如，字符字面量 <code>'*'</code> 和 <code>'\\x2A'</code> 是等效的，因为字符 <code>*</code> 的码点是 42 或十六进制的 2A。</li>\n<li>可以将任何 Unicode 字符写为 <code>'\\u'</code> 形式，其中 <code>HHHHHH</code> 是最多 6 个十六进制数，可以像往常一样用下划线进行分组。例如，字符字面量 <code>'\\u'</code> 表示字符“ಠ”，这是 Unicode 中用于表示反对的卡纳达语字符“ಠ_ಠ”。同样的字面量也可以简写成 <code>'ಠ'</code>。</li>\n</ul>\n<p><code>char</code> 总是包含 0x0000 到 0xD7FF 或 0xE000 到 0x10FFFF 范围内的 Unicode 码点。<code>char</code> 永远不会是“半代用区”中的码点（0xD800 到 0xDFFF 范围内的码点，它们不能单独使用）或 Unicode 码点空间之外的值（大于 0x10FFFF 的值）。Rust 使用类型系统和动态检查来确保 <code>char</code> 值始终在允许的范围内。</p>\n<p>Rust 不会在 <code>char</code> 和任何其他类型之间进行隐式转换。可以使用 <code>as</code> 转换运算符将 <code>char</code> 转换为整型，对于小于 <code>32</code> 位的类型，该字符值的高位会被截断：</p>\n<pre class=\"code-rows\"><code>assert_eq!('*' as i32, 42);\nassert_eq!('ಠ' as u16, 0xca0);\nassert_eq!('ಠ' as i8, -0x60); // U+0CA0截断到8位，有符号</code></pre>\n<p>从另一个方向来看，<code>u8</code> 是唯一能通过 <code>as</code> 运算符转换为 <code>char</code> 的类型，因为 Rust 刻意让 <code>as</code> 运算符只执行开销极低且可靠的转换，但是除 <code>u8</code> 之外的每个整型都可能包含 Unicode 码点之外的值，所以这些转换都要做运行期检查。作为替代方案，标准库函数 <code>std::char::from_u32</code> 可以接受任何 <code>u32</code> 值并返回一个 <code>Option&lt;char&gt;</code>：如果此 <code>u32</code> 不是允许的 Unicode 码点，那么 <code>from_u32</code> 就会返回 <code>None</code>，否则，它会返回 <code>Some(c)</code>，其中 <code>c</code> 是转换成 <code>char</code> 后的结果。</p>\n<p>标准库为字符提供了一些有用的方法，你可以在“<code>char</code>（原始类型）”和模块“<code>std::char</code>”下的在线文档中找到这些方法。</p>\n<pre class=\"code-rows\"><code>assert_eq!('*'.is_alphabetic(), false);\nassert_eq!('β'.is_alphabetic(), true);\nassert_eq!('8'.to_digit(10), Some(8));\nassert_eq!('ಠ'.len_utf8(), 3);\nassert_eq!(std::char::from_digit(2, 10), Some('2'));</code></pre>\n<p>孤立的字符自然不如字符串和文本流那么有用。3.7 节会讲解 Rust 的标准 <code>String</code> 类型和文本处理。</p>\n<h2 id=\"nav_point_47\">3.4　元组</h2>\n<p><strong>元组</strong>是各种类型值的值对或三元组、四元组、五元组等（因此称为 <strong><em>n</em>-元组</strong>或<strong>元组</strong>）。可以将元组编写为一个元素序列，用逗号隔开并包裹在一对圆括号中。例如，<code>(\"Brazil\", 1985)</code> 是一个元组，其第一个元素是一个静态分配的字符串，第二个元素是一个整数，它的类型是 <code>(&amp;str, i32)</code>。给定一个元组值 <code>t</code>，可以通过 <code>t.0</code>、<code>t.1</code> 等访问其元素。</p>\n<p>元组有点儿类似于数组，即这两种类型都表示值的有序序列。许多编程语言混用或结合了这两个概念，但在 Rust 中，它们是截然不同的。一方面，元组的每个元素可以有不同的类型，而数组的元素必须都是相同的类型。另一方面，元组只允许用常量作为索引，比如 <code>t.4</code>。不能通过写成 <code>t.i</code> 或 <code>t[i]</code> 的形式来获取第 <code>i</code> 个元素。</p>\n<p>Rust 代码通常会用元组类型从一个函数返回多个值。例如，字符串切片上的 <code>split_at</code> 方法会将字符串分成两半并返回它们，其声明如下所示：</p>\n<pre class=\"code-rows\"><code>fn split_at(&amp;self, mid: usize) -&gt; (&amp;str, &amp;str);</code></pre>\n<p>返回类型 <code>(&amp;str, &amp;str)</code> 是两个字符串切片构成的元组。可以用模式匹配语法将返回值的每个元素赋值给不同的变量：</p>\n<pre class=\"code-rows\"><code>let text = \"I see the eigenvalue in thine eye\";\nlet (head, tail) = text.split_at(21);\nassert_eq!(head, \"I see the eigenvalue \");\nassert_eq!(tail, \"in thine eye\");</code></pre>\n<p>这样比其等效写法更易读：</p>\n<pre class=\"code-rows\"><code>let text = \"I see the eigenvalue in thine eye\";\nlet temp = text.split_at(21);\nlet head = temp.0;\nlet tail = temp.1;\nassert_eq!(head, \"I see the eigenvalue \");\nassert_eq!(tail, \"in thine eye\");</code></pre>\n<p>你还会看到元组被用作一种超级小巧的结构体类型。例如，在第 2 章的曼德博程序中，我们要将图像的宽度和高度传给绘制它的函数并将其写入磁盘。为此可以声明一个具有 <code>width</code> 成员和 <code>height</code> 成员的结构体，但对如此显而易见的事情来说，这种写法相当烦琐，所以我们只用了一个元组：</p>\n<pre class=\"code-rows\"><code>/// 把`pixels`缓冲区（其尺寸由`bounds`给出）写入名为`filename`的文件中\nfn write_image(filename: &amp;str, pixels: &amp;[u8], bounds: (usize, usize))\n    -&gt; Result&lt;(), std::io::Error&gt;\n{ ... }</code></pre>\n<p><code>bounds</code> 参数的类型是 <code>(usize, usize)</code>，这是一个包含两个 <code>usize</code> 值的元组。当然也可以写成单独的 <code>width</code> 参数和 <code>height</code> 参数，并且最终的机器码也基本一样。但重点在于思路的清晰度。应该把大小看作一个值，而不是两个，使用元组能更准确地记述这种意图。</p>\n<p>另一种常用的元组类型是零元组 <code>()</code>。传统上，这叫作<strong>单元类型</strong>，因为此类型只有一个值，写作 <code>()</code>。当无法携带任何有意义的值但其上下文仍然要求传入某种类型时，Rust 就会使用单元类型。</p>\n<p>例如，不返回值的函数的返回类型为 <code>()</code>。标准库的 <code>std::mem::swap</code> 函数就没有任何有意义的返回值，它只会交换两个参数的值。<code>std::mem::swap</code> 的声明如下所示：</p>\n<pre class=\"code-rows\"><code>fn swap&lt;T&gt;(x: &amp;mut T, y: &amp;mut T);</code></pre>\n<p>这个 <code>&lt;T&gt;</code> 意味着 <code>swap</code> 是<strong>泛型</strong>的：可以将对任意类型 <code>T</code> 的值的引用传给它。但此签名完全省略了 <code>swap</code> 的返回类型，它是以下完整写法的简写形式：</p>\n<pre class=\"code-rows\"><code>fn swap&lt;T&gt;(x: &amp;mut T, y: &amp;mut T) -&gt; ();</code></pre>\n<p>类似地，前面提到过的 <code>write_image</code> 示例的返回类型是 <code>Result&lt;(), std::io::Error&gt;</code>，这意味着该函数在出错时会返回一个 <code>std::io::Error</code> 值，但成功时不会返回任何值。</p>\n<p>如果你愿意，可以在元组的最后一个元素之后跟上一个逗号：类型 <code>(&amp;str, i32,)</code> 和 <code>(&amp;str, i32)</code> 是等效的，表达式 <code>(\"Brazil\", 1985,)</code> 和 <code>(\"Brazil\", 1985)</code> 是等效的。Rust 始终允许在所有能用逗号的地方（函数参数、数组、结构体和枚举定义，等等）添加额外的尾随逗号。这对人类读者来说可能很奇怪，不过一旦在多行列表末尾添加或移除了条目（entry），在显示差异时就会更容易阅读。</p>\n<p>为了保持一致性，甚至有包含单个值的元组。字面量 <code>(\"lonely hearts\",)</code> 就是一个包含单个字符串的元组，它的类型是 <code>(&amp;str,)</code>。在这里，值后面的逗号是必需的，以用于区分单值元组和简单的括号表达式。</p>\n<h2 id=\"nav_point_48\">3.5　指针类型</h2>\n<p>Rust 有多种表示内存地址的类型。</p>\n<p>这是 Rust 和大多数具有垃圾回收功能的语言之间一个重大的差异。在 Java 中，如果 <code>class Rectangle</code> 包含字段 <code>Vector2D upperLeft;</code>，那么 <code>upperLeft</code> 就是对另一个单独创建的 <code>Vector2D</code> 对象的引用。在 Java 中，一个对象永远不会包含其他对象的实际内容。</p>\n<p>但 Rust 不一样。该语言旨在帮你将内存分配保持在最低限度。默认情况下值会嵌套。值 <code>((0, 0), (1440, 900))</code> 会存储为 4 个相邻的整数。如果将它存储在一个局部变量中，则会得到 4 倍于整数宽度的局部变量。堆中没有分配任何内容。</p>\n<p>这可以帮我们高效利用内存，但代价是，当 Rust 程序需要让一些值指向其他值时，必须显式使用指针类型。好消息是，当使用这些指针类型时，安全的 Rust 会对其进行约束，以消除未定义的行为，因此指针在 Rust 中比在 C++ 中更容易正确使用。</p>\n<p>接下来将讨论 3 种指针类型：引用、Box 和不安全指针。</p>\n<h3 id=\"nav_point_49\">3.5.1　引用</h3>\n<p><code>&amp;String</code> 类型的值（读作“ref String”）是对 <code>String</code> 值的引用，<code>&amp;i32</code> 是对 <code>i32</code> 的引用，以此类推。</p>\n<p>最简单的方式是将引用视为 Rust 中的基本指针类型。在运行期间，对 <code>i32</code> 的引用是一个保存着 <code>i32</code> 地址的机器字，这个地址可能位于栈或堆中。表达式 <code>&amp;x</code> 会生成一个对 <code>x</code> 的引用，在 Rust 术语中，我们会说它<strong>借用了对 <em>x</em> 的引用</strong>。给定一个引用 <code>r</code>，表达式 <code>*r</code> 会引用 <code>r</code> 指向的值。它们非常像 <code>C</code> 和 <code>C++</code> 中的 <code>&amp;</code> 运算符和 <code>*</code> 运算符，并且和 C 中的指针一样，当超出作用域时引用不会自动释放任何资源。</p>\n<p>然而，与 C 指针不同，Rust 的引用永远不会为空：在安全的 Rust 中根本没有办法生成空引用。与 C 不同，Rust 会跟踪值的所有权和生命周期，因此早在编译期间就排除了悬空指针、双重释放和指针失效等错误。</p>\n<p>Rust 引用有两种形式。</p>\n<blockquote>\n<p><code>&amp;T</code></p>\n</blockquote>\n<p>一个不可变的共享引用。你可以同时拥有多个对给定值的共享引用，但它们是只读的：禁止修改它们所指向的值，就像 C 中的 <code>const T*</code> 一样。</p>\n<blockquote>\n<p><code>&amp;mut T</code></p>\n</blockquote>\n<p>一个可变的、独占的引用。你可以读取和修改它指向的值，就像 C 中的 <code>T*</code> 一样。但是只要该引用还存在，就不能对该值有任何类型的其他引用。事实上，访问该值的唯一途径就是使用这个可变引用。</p>\n<p>Rust 利用共享引用和可变引用之间的“二选一”机制来强制执行“单个写入者<strong>或</strong>多个读取者”规则：你或者独占读写一个值，或者让任意数量的读取者共享，但二者只能选择其一。这种由编译期检查强制执行的“二选一”规则是 Rust 安全保障的核心。第 5 章会解释 Rust 的安全引用的使用规则。</p>\n<h3 id=\"nav_point_50\">3.5.2　Box</h3>\n<p>在堆中分配值的最简单方式是使用 <code>Box::new</code>：</p>\n<pre class=\"code-rows\"><code>let t = (12, \"eggs\");\nlet b = Box::new(t);  // 在堆中分配一个元组</code></pre>\n<p><code>t</code> 的类型是 <code>(i32, &amp;str)</code>，所以 <code>b</code> 的类型是 <code>Box&lt;(i32, &amp;str)&gt;</code>。对 <code>Box::new</code> 的调用会分配足够的内存以在堆上容纳此元组。当 <code>b</code> 超出作用域时，内存会立即被释放，除非 <code>b</code> 已被<strong>移动</strong>（move），比如返回它。移动对于 Rust 处理在堆上分配的值的方式至关重要，第 4 章会对此进行详细解释。</p>\n<h3 id=\"nav_point_51\">3.5.3　裸指针</h3>\n<p>Rust 也有裸指针类型 <code>*mut T</code> 和 <code>*const T</code>。裸指针实际上和 C++ 中的指针很像。使用裸指针是不安全的，因为 Rust 不会跟踪它指向的内容。例如，裸指针可能为空，或者它们可能指向已释放的内存或现在包含不同类型的值。C++ 的所有经典指针错误都可能“借尸还魂”。</p>\n<p>但是，你只能在 <code>unsafe</code> 块中对裸指针解引用（dereference）。<code>unsafe</code> 块是 Rust 高级语言特性中的可选机制，其安全性取决于你自己。如果代码中没有 <code>unsafe</code> 块（或者虽然有但编写正确），那么本书中强调的安全保证就仍然有效。有关详细信息，请参阅第 22 章。</p>\n<h2 id=\"nav_point_52\">3.6　数组、向量和切片</h2>\n<p>Rust 用 3 种类型来表示内存中的值序列。</p>\n<ul>\n<li>类型 <code>[T; N]</code> 表示 <code>N</code> 个值的数组，每个值的类型为 <code>T</code>。数组的大小是在编译期就已确定的常量，并且是类型的一部分，不能追加新元素或缩小数组。</li>\n<li>类型 <code>Vec&lt;T&gt;</code> 可称为 <strong>T 的向量</strong>，它是一个动态分配且可增长的 <code>T</code> 类型的值序列。向量的元素存在于堆中，因此可以随意调整向量的大小：压入新元素、追加其他向量、删除元素等。</li>\n<li>类型 <code>&amp;[T]</code> 和 <code>&amp;mut [T]</code> 可称为 <strong>T 的共享切片</strong>和 <strong>T 的可变切片</strong>，它们是对一系列元素的引用，这些元素是某个其他值（比如数组或向量）的一部分。可以将切片视为指向其第一个元素的指针，以及从该点开始允许访问的元素数量的计数。可变切片 <code>&amp;mut [T]</code> 允许读取元素和修改元素，但不能共享；共享切片 <code>&amp;[T]</code> 允许在多个读取者之间共享访问权限，但不允许修改元素。</li>\n</ul>\n<p>给定这 3 种类型中任意一种类型的值 <code>v</code>，表达式 <code>v.len()</code> 都会给出 <code>v</code> 中的元素数，而 <code>v[i]</code> 引用的是 <code>v</code> 的第 <code>i</code> 个元素。<code>v</code> 的第一个元素是 <code>v[0]</code>，最后一个元素是 <code>v[v.len() - 1]</code>。Rust 总是会检查 <code>i</code> 是否在这个范围内，如果没在，则此表达式会出现 panic。<code>v</code> 的长度可能为 0，在这种情况下，任何对其进行索引的尝试都会出现 panic。<code>i</code> 的类型必须是 <code>usize</code>，不能使用任何其他整型作为索引。</p>\n<h3 id=\"nav_point_53\">3.6.1　数组</h3>\n<p>编写数组值的方法有好几种，其中最简单的方法是在方括号内写入一系列值：</p>\n<pre class=\"code-rows\"><code>let lazy_caterer: [u32; 6] = [1, 2, 4, 7, 11, 16];\nlet taxonomy = [\"Animalia\", \"Arthropoda\", \"Insecta\"];\n\nassert_eq!(lazy_caterer[3], 7);\nassert_eq!(taxonomy.len(), 3);</code></pre>\n<p>对于要填充一些值的长数组的常见情况，可以写成 <code>[<i>V</i>; <i>N</i>]</code>，其中 <em><code>V</code></em> 是每个元素的值，<em><code>N</code></em> 是长度。例如，<code>[true; 10000]</code> 是一个包含 10 000 个 <code>bool</code> 元素的数组，其内容全为 <code>true</code>：</p>\n<pre class=\"code-rows\"><code>let mut sieve = [true; 10000];\nfor i in 2..100 {\n    if sieve[i] {\n        let mut j = i * i;\n        while j &lt; 10000 {\n            sieve[j] = false;\n            j += i;\n        }\n    }\n}\n\nassert!(sieve[211]);\nassert!(!sieve[9876]);</code></pre>\n<p>你会看到用来声明固定大小缓冲区的语法：<code>[0u8; 1024]</code>，它是一个 1 KB 的缓冲区，用 0 填充。Rust 没有任何能定义未初始化数组的写法。（一般来说，Rust 会确保代码永远无法访问任何种类的未初始化值。）</p>\n<p>数组的长度是其类型的一部分，并会在编译期固定下来。如果 <code>n</code> 是变量，则不能写成 <code>[true; n]</code> 以期得到一个包含 <code>n</code> 个元素的数组。当你需要一个长度在运行期可变的数组时（通常都是这样），请改用向量。</p>\n<p>你在数组上看到的那些实用方法（遍历元素、搜索、排序、填充、过滤等）都是作为切片而非数组的方法提供的。但是 Rust 在搜索各种方法时会隐式地将对数组的引用转换为切片，因此可以直接在数组上调用任何切片方法：</p>\n<pre class=\"code-rows\"><code>let mut chaos = [3, 5, 4, 1, 2];\nchaos.sort();\nassert_eq!(chaos, [1, 2, 3, 4, 5]);</code></pre>\n<p>在这里，<code>sort</code> 方法实际上是在切片上定义的，但由于它是通过引用获取的操作目标，因此 Rust 会隐式地生成一个引用整个数组的 <code>&amp;mut [i32]</code> 切片，并将其传给 <code>sort</code> 来进行操作。其实前面提到过的 <code>len</code> 方法也是切片的方法之一。3.6.3 节会更详细地介绍切片。</p>\n<h3 id=\"nav_point_54\">3.6.2　向量</h3>\n<p>向量 <code>Vec&lt;T&gt;</code> 是一个可调整大小的 <code>T</code> 类型元素的数组，它是在堆上分配的。</p>\n<p>创建向量的方法有好几种，其中最简单的方法是使用 <code>vec!</code> 宏，它为我们提供了一个看起来非常像数组字面量的向量语法：</p>\n<pre class=\"code-rows\"><code>let mut primes = vec![2, 3, 5, 7];\nassert_eq!(primes.iter().product::&lt;i32&gt;(), 210);</code></pre>\n<p>当然，这仍然是一个向量，而不是数组，所以可以动态地向它添加元素：</p>\n<pre class=\"code-rows\"><code>primes.push(11);\nprimes.push(13);\nassert_eq!(primes.iter().product::&lt;i32&gt;(), 30030);</code></pre>\n<p>还可以通过将给定值重复一定次数来构建向量，可以再次使用模仿数组字面量的语法：</p>\n<pre class=\"code-rows\"><code>fn new_pixel_buffer(rows: usize, cols: usize) -&gt; Vec&lt;u8&gt; {\n    vec![0; rows * cols]\n}</code></pre>\n<p><code>vec!</code> 宏相当于调用 <code>Vec::new</code> 来创建一个新的空向量，然后将元素压入其中，这是另一种惯用法：</p>\n<pre class=\"code-rows\"><code>let mut pal = Vec::new();\npal.push(\"step\");\npal.push(\"on\");\npal.push(\"no\");\npal.push(\"pets\");\nassert_eq!(pal, vec![\"step\", \"on\", \"no\", \"pets\"]);</code></pre>\n<p>还有一种可能性是从迭代器生成的值构建一个向量：</p>\n<pre class=\"code-rows\"><code>let v: Vec&lt;i32&gt; = (0..5).collect();\nassert_eq!(v, [0, 1, 2, 3, 4]);</code></pre>\n<p>使用 <code>collect</code> 时，通常要指定类型（正如此处给 <code>v</code> 声明了类型），因为它可以构建出不同种类的集合，而不仅仅是向量。通过指定 <code>v</code> 的类型，我们明确表达了自己想要哪种集合。</p>\n<p>与数组一样，可以对向量使用切片的方法：</p>\n<pre class=\"code-rows\"><code>// 回文！\nlet mut palindrome = vec![\"a man\", \"a plan\", \"a canal\", \"panama\"];\npalindrome.reverse();\n// 固然合理，但不符合预期：\nassert_eq!(palindrome, vec![\"panama\", \"a canal\", \"a plan\", \"a man\"]);</code></pre>\n<p>在这里，<code>reverse</code> 方法实际上是在切片上定义的，但是此调用会隐式地从此向量中借用一个 <code>&amp;mut [&amp;str]</code> 切片并在其上调用 <code>reverse</code>。</p>\n<p><code>Vec</code> 是 Rust 的基本数据类型，它几乎可以用在任何需要动态大小的列表的地方，所以还有许多其他方法可以构建新向量或扩展现有向量。第 16 章会介绍这些方法。</p>\n<p><code>Vec&lt;T&gt;</code> 由 3 个值组成：指向元素在堆中分配的缓冲区（该缓冲区由 <code>Vec&lt;T&gt;</code> 创建并拥有）的指针、缓冲区能够存储的元素数量，以及它现在实际包含的数量（也就是它的长度）。当缓冲区达到其最大容量时，往向量中添加另一个元素需要分配一个更大的缓冲区，将当前内容复制到其中，更新向量的指针和容量以指向新缓冲区，最后释放旧缓冲区。</p>\n<p>如果事先知道向量所需的元素数量，就可以调用 <code>Vec::with_capacity</code> 而不是 <code>Vec::new</code> 来创建一个向量，它的缓冲区足够大，可以从一开始就容纳所有元素。然后，可以逐个将元素添加到此向量中，而不会导致任何重新分配。<code>vec!</code> 宏就使用了这样的技巧，因为它知道最终向量将包含多少个元素。请注意，这只会确定向量的初始大小，如果大小超出了你的预估，则向量仍然会正常扩大其存储空间。</p>\n<p>许多库函数会寻求使用 <code>Vec::with_capacity</code> 而非 <code>Vec::new</code> 的机会。例如，在 <code>collect</code> 示例中，迭代器 <code>0..5</code> 预先知道它将产生 5 个值，并且 <code>collect</code> 函数会利用这一点以正确的容量来预分配它返回的向量。第 15 章会介绍其工作原理。</p>\n<p>向量的 <code>len</code> 方法会返回它现在包含的元素数，而 <code>capacity</code> 方法则会返回在不重新分配的情况下可以容纳的元素数：</p>\n<pre class=\"code-rows\"><code>let mut v = Vec::with_capacity(2);\nassert_eq!(v.len(), 0);\nassert_eq!(v.capacity(), 2);\n\nv.push(1);\nv.push(2);\nassert_eq!(v.len(), 2);\nassert_eq!(v.capacity(), 2);\n\nv.push(3);\nassert_eq!(v.len(), 3);\n// 通常会打印出\"capacity is now 4\":\nprintln!(\"capacity is now {}\", v.capacity());</code></pre>\n<p>最后打印出的容量不能保证恰好是 <code>4</code>，但至少大于等于 <code>3</code>，因为此向量包含 3 个值。</p>\n<p>可以在向量中任意位置插入元素和移除元素，不过这些操作会将受影响位置之后的所有元素向前或向后移动，因此如果向量很长就可能很慢：</p>\n<pre class=\"code-rows\"><code>let mut v = vec![10, 20, 30, 40, 50];\n\n// 在索引为3的元素处插入35\nv.insert(3, 35);\nassert_eq!(v, [10, 20, 30, 35, 40, 50]);\n\n// 移除索引为1的元素\nv.remove(1);\nassert_eq!(v, [10, 30, 35, 40, 50]);</code></pre>\n<p>可以使用 <code>pop</code> 方法移除最后一个元素并将其返回。更准确地说，从 <code>Vec&lt;T&gt;</code> 中弹出一个值会返回 <code>Option&lt;T&gt;</code>：如果向量已经为空则为 <code>None</code>，如果其最后一个元素为 <code>v</code> 则为 <code>Some(v)</code>。</p>\n<pre class=\"code-rows\"><code>let mut v = vec![\"Snow Puff\", \"Glass Gem\"];\nassert_eq!(v.pop(), Some(\"Glass Gem\"));\nassert_eq!(v.pop(), Some(\"Snow Puff\"));\nassert_eq!(v.pop(), None);</code></pre>\n<p>可以使用 <code>for</code> 循环遍历向量：</p>\n<pre class=\"code-rows\"><code>// 将命令行参数作为字符串的向量\nlet languages: Vec&lt;String&gt; = std::env::args().skip(1).collect();\nfor l in languages {\n    println!(\"{}: {}\", l,\n             if l.len() % 2 == 0 {\n                 \"functional\"\n             } else {\n                 \"imperative\"\n             });\n}</code></pre>\n<p>以编程语言列表为参数运行本程序就可以说明这个问题：</p>\n<pre class=\"code-rows\"><code>$ cargo run Lisp Scheme C C++ Fortran\n   Compiling proglangs v0.1.0 (/home/jimb/rust/proglangs)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.36s\n     Running `target/debug/proglangs Lisp Scheme C C++ Fortran`\nLisp: functional\nScheme: functional\nC: imperative\nC++: imperative\nFortran: imperative\n$</code></pre>\n<p>终于可以对术语<strong>函数式语言</strong>做一个令人满意的定义了。</p>\n<p>虽然扮演着基础角色，但 <code>Vec</code> 仍然是 Rust 中定义的普通类型，而没有内置在语言中。第 22 章会介绍实现这些类型所需的技术。</p>\n<h3 id=\"nav_point_55\">3.6.3　切片</h3>\n<p>切片（写作不指定长度的 <code>[T]</code>）是数组或向量中的一个区域。由于切片可以是任意长度，因此它不能直接存储在变量中或作为函数参数进行传递。切片总是通过引用传递。</p>\n<p>对切片的引用是一个<strong>胖指针</strong>：一个双字值，包括指向切片第一个元素的指针和切片中元素的数量。</p>\n<p>假设你运行以下代码：</p>\n<pre class=\"code-rows\"><code>let v: Vec&lt;f64&gt; = vec![0.0,  0.707,  1.0,  0.707];\nlet a: [f64; 4] =     [0.0, -0.707, -1.0, -0.707];\n\nlet sv: &amp;[f64] = &amp;v;\nlet sa: &amp;[f64] = &amp;a;</code></pre>\n<p>在最后两行中，Rust 自动把 <code>&amp;Vec&lt;f64&gt;</code> 的引用和 <code>&amp;[f64; 4]</code> 的引用转换成了直接指向数据的切片引用。</p>\n<p>最后，内存布局如图 3-2 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00819.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 3-2：内存中的向量 <code>v</code> 和数组 <code>a</code> 分别被切片 <code>sa</code> 和 <code>sv</code> 引用</strong></p>\n<p>普通引用是指向单个值的非拥有型指针，而对切片的引用是指向内存中一系列连续值的非拥有型指针。如果要写一个对数组或向量进行操作的函数，那么切片引用就是不错的选择。例如，下面是打印一段数值的函数，每行一个：</p>\n<pre class=\"code-rows\"><code>fn print(n: &amp;[f64]) {\n    for elt in n {\n        println!(\"{}\", elt);\n    }\n}\n\nprint(&amp;a);  // 打印数组\nprint(&amp;v);  // 打印向量</code></pre>\n<p>因为此函数以切片引用为参数，所以也可以给它传入向量或数组。事实上，你以为属于向量或数组的许多方法其实是在切片上定义的，比如会对元素序列进行排序或反转的 <code>sort</code> 方法和 <code>reverse</code> 方法实际上是切片类型 <code>[T]</code> 上的方法。</p>\n<p>你可以使用范围值对数组或向量进行索引，以获取一个切片的引用，该引用既可以指向数组或向量，也可以指向一个既有切片：</p>\n<pre class=\"code-rows\"><code>print(&amp;v[0..2]);    // 打印v的前两个元素\nprint(&amp;a[2..]);     // 打印从a[2]开始的元素\nprint(&amp;sv[1..3]);   // 打印v[1]和v[2]</code></pre>\n<p>与普通数组访问一样，Rust 会检查索引是否有效。尝试借用超出数据末尾的切片会导致 panic。</p>\n<p>由于切片几乎总是出现在引用符号之后，因此通常只将 <code>&amp;[T]</code> 或 <code>&amp;str</code> 之类的类型称为“切片”，使用较短的名称来表示更常见的概念。</p>\n<h2 id=\"nav_point_56\">3.7　字符串类型</h2>\n<p>熟悉 C++ 的程序员应该还记得该语言中有两种字符串类型。字符串字面量的指针类型为 <code>const char *</code>。标准库还提供了一个 <code>std::string</code> 类，用于在运行期动态创建字符串。</p>\n<p>Rust 中也有类似的设计。本节将首先展示所有编写字符串字面量的方法，然后介绍 Rust 的两种字符串类型。第 17 章会介绍有关字符串和文本处理的更多信息。</p>\n<h3 id=\"nav_point_57\">3.7.1　字符串字面量</h3>\n<p>字符串字面量要用双引号括起来，它们使用与 <code>char</code> 字面量相同的反斜杠转义序列：</p>\n<pre class=\"code-rows\"><code>let speech = \"\\\"Ouch!\\\" said the well.\\n\";</code></pre>\n<p>但与 <code>char</code> 字面量不同，在字符串字面量中单引号不需要用反斜杠转义，而双引号需要。</p>\n<p>一个字符串可能跨越多行：</p>\n<pre class=\"code-rows\"><code>println!(\"In the room the women come and go,\n    Singing of Mount Abora\");</code></pre>\n<p>该字符串字面量中的换行符是字符串的一部分，因此也会包含在输出中。第 2 行开头的空格也是如此。</p>\n<p>如果字符串的一行以反斜杠结尾，那么就会丢弃其后的换行符和前导空格：</p>\n<pre class=\"code-rows\"><code>println!(\"It was a bright, cold day in April, and \\\n    there were four of us—\\\n    more or less.\");</code></pre>\n<p>这会打印出单行文本。该字符串在“<code>and</code>”和“<code>there</code>”之间会有一个空格，因为在本程序中，第一个反斜杠之前有一个空格，而在破折号和“<code>more</code>”之间则没有空格。</p>\n<p>在少数情况下，需要双写字符串中的每一个反斜杠，这让人不胜其烦。（经典的例子是正则表达式和 Windows 路径。）对于这些情况，Rust 提供了<strong>原始字符串</strong>。原始字符串用小写字母 r 进行标记。原始字符串中的所有反斜杠和空白字符都会逐字包含在字符串中。原始字符串不识别任何转义序列：</p>\n<pre class=\"code-rows\"><code>let default_win_install_path = r\"C:\\Program Files\\Gorillas\";\n\nlet pattern = Regex::new(r\"\\d+(\\.\\d+)*\");</code></pre>\n<p>不能简单地在双引号前面放置一个反斜杠来包含原始字符串——别忘了，前面说过它<strong>不识别</strong>转义序列。但是，仍有办法解决。可以在原始字符串的开头和结尾添加 # 标记：</p>\n<pre class=\"code-rows\"><code>println!(r###\"\n    This raw string started with 'r###\"'.\n    Therefore it does not end until we reach a quote mark ('\"')\n    followed immediately by three pound signs ('###'):\n\"###);</code></pre>\n<p>可以根据需要添加任意多个井号，以标明原始字符串的结束位置。<span class=\"comment-number\">4</span></p>\n\n<h3 id=\"nav_point_58\">3.7.2　字节串</h3>\n<p>带有 <code>b</code> 前缀的字符串字面量都是<strong>字节串</strong>。这样的字节串是 <code>u8</code> 值（字节）的切片而不是 Unicode 文本：</p>\n<pre class=\"code-rows\"><code>let method = b\"GET\";\nassert_eq!(method, &amp;[b'G', b'E', b'T']);</code></pre>\n<p><code>method</code> 的类型是 <code>&amp;[u8; 3]</code>：它是对 3 字节数组的引用，没有刚刚讨论过的任何字符串方法，最像字符串的地方就是其书写语法，仅此而已。</p>\n<p>字节串可以使用前面展示过的所有其他的字符串语法：可以跨越多行、可以使用转义序列、可以使用反斜杠来连接行等。不过原始字节串要以 <code>br\"</code> 开头。</p>\n<p>字节串不能包含任意 Unicode 字符，它们只能使用 ASCII 和 <code>\\xHH</code> 转义序列。</p>\n<h3 id=\"nav_point_59\">3.7.3　内存中的字符串</h3>\n<p>Rust 字符串是 Unicode 字符序列，但它们并没有以 <code>char</code> 数组的形式存储在内存中，而是使用了 UTF-8（一种可变宽度编码）的形式。字符串中的每个 ASCII 字符都会存储在单字节中，而其他字符会占用多字节。</p>\n<p>图 3-3 展示了由以下代码创建的 <code>String</code> 值和 <code>&amp;str</code> 值。</p>\n<pre class=\"code-rows\"><code>let noodles = \"noodles\".to_string();\nlet oodles = &amp;noodles[1..];\nlet poodles = \"ಠ_ಠ\";</code></pre>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00820.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 3-3：<code>String</code>、<code>&amp;str</code> 和 <code>str</code></strong></p>\n<p><code>String</code> 有一个可以调整大小的缓冲区，其中包含 UTF-8 文本。缓冲区是在堆上分配的，因此它可以根据需要或请求来调整大小。在示例中，<code>noodles</code> 是一个 <code>String</code>，它拥有一个 8 字节的缓冲区，其中 7 字节正在使用中。可以将 <code>String</code> 视为 <code>Vec&lt;u8&gt;</code>，它可以保证包含格式良好的 UTF-8，实际上，<code>String</code> 就是这样实现的。</p>\n<p><code>&amp;str</code>（发音为 /stɜːr/ 或 string slice）是对别人拥有的一系列 UTF-8 文本的引用，即它“借用”了这个文本。在示例中，<code>oodles</code> 是对 <code>noodles</code> 拥有的文本的最后 6 字节的一个 <code>&amp;str</code> 引用，因此它表示文本“oodles”。与其他切片引用一样，<code>&amp;str</code> 也是一个胖指针，包含实际数据的地址及其长度。可以认为 <code>&amp;str</code> 就是 <code>&amp;[u8]</code>，但它能保证包含的是格式良好的 UTF-8。</p>\n<p>字符串字面量是指预分配文本的 <code>&amp;str</code>，它通常与程序的机器码一起存储在只读内存区。在前面的示例中，<code>poodles</code> 是一个字符串字面量，指向一块 7 字节的内存，它在程序开始执行时就已创建并一直存续到程序退出。</p>\n<p><code>String</code> 或 <code>&amp;str</code> 的 <code>.len()</code> 方法会返回其长度。这个长度以字节而不是字符为单位：</p>\n<pre class=\"code-rows\"><code>assert_eq!(\"ಠ_ಠ\".len(), 7);\nassert_eq!(\"ಠ_ಠ\".chars().count(), 3);</code></pre>\n<p>不能修改 <code>&amp;str</code>：</p>\n<pre class=\"code-rows\"><code>let mut s = \"hello\";\ns[0] = 'c';    // 错误：无法修改`&amp;str`，并给出错误原因\ns.push('\\n');  // 错误：`&amp;str`引用上没有找到名为`push`的方法</code></pre>\n<p>要在运行期创建新字符串，可以使用 <code>String</code>。</p>\n<p><code>&amp;mut str</code> 类型确实存在，但它没什么用，因为对 UTF-8 的几乎所有操作都会更改其字节总长度，但切片不能重新分配其引用目标的缓冲区。事实上，<code>&amp;mut str</code> 上唯一可用的操作是 <code>make_ascii_uppercase</code> 和 <code>make_ascii_lowercase</code>，根据定义，它们会就地修改文本并且只影响单字节字符。</p>\n<h3 id=\"nav_point_60\">3.7.4　<code>String</code></h3>\n<p><code>&amp;str</code> 非常像 <code>&amp;[T]</code>，是一个指向某些数据的胖指针。而 <code>String</code> 则类似于 <code>Vec&lt;T&gt;</code>，如表 3-11 所示。</p>\n<p><strong>表 3-11：<code>Vec&lt;T&gt;</code> 与 <code>String</code> 对比</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>&nbsp;</p></th>\n<th><p><code>Vec&lt;T&gt;</code></p></th>\n<th><p><code>String</code></p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>自动释放缓冲区</p></td>\n<td><p>是</p></td>\n<td><p>是</p></td>\n</tr>\n<tr>\n<td><p>可增长</p></td>\n<td><p>是</p></td>\n<td><p>是</p></td>\n</tr>\n<tr>\n<td><p>类型关联函数 <code>::new()</code> 和 <code>::with_capacity()</code></p></td>\n<td><p>是</p></td>\n<td><p>是</p></td>\n</tr>\n<tr>\n<td><p><code>.reserve()</code> 方法和 <code>.capacity()</code> 方法</p></td>\n<td><p>是</p></td>\n<td><p>是</p></td>\n</tr>\n<tr>\n<td><p><code>.push()</code> 方法和 <code>.pop()</code> 方法</p></td>\n<td><p>是</p></td>\n<td><p>是</p></td>\n</tr>\n<tr>\n<td><p>范围语法 <code>v[start..stop]</code></p></td>\n<td><p>是，返回 <code>&amp;[T]</code></p></td>\n<td><p>是，返回 <code>&amp;str</code></p></td>\n</tr>\n<tr>\n<td><p>自动转换</p></td>\n<td><p><code>&amp;Vec&lt;T&gt;</code> 到 <code>&amp;[T]</code></p></td>\n<td><p><code>&amp;String</code> 到 <code>&amp;str</code></p></td>\n</tr>\n<tr>\n<td><p>继承的方法</p></td>\n<td><p>来自 <code>&amp;[T]</code></p></td>\n<td><p>来自 <code>&amp;str</code></p></td>\n</tr>\n</tbody>\n</table>\n<p>与 <code>Vec</code> 一样，每个 <code>String</code> 都在堆上分配了自己的缓冲区，不会与任何其他 <code>String</code> 共享。当 <code>String</code> 变量超出作用域时，缓冲区将自动释放，除非这个 <code>String</code> 已经被移动。</p>\n<p>以下是创建 <code>String</code> 的几种方法。</p>\n<ul>\n<li><p><code>.to_string()</code> 方法会将 <code>&amp;str</code> 转换为 <code>String</code>。这会复制此字符串。</p>\n<pre class=\"code-rows\"><code>let error_message = \"too many pets\".to_string();</code></pre>\n<p><code>.to_owned()</code> 方法会做同样的事，也会以同样的方式使用。这种命名风格也适用于另一些类型，第 13 章中会讨论。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><code>format!()</code> 宏的工作方式与 <code>println!()</code> 类似，但它会返回一个新的 <code>String</code>，而不是将文本写入标准输出，并且不会在末尾自动添加换行符。</p>\n<pre class=\"code-rows\"><code>assert_eq!(format!(\"{}°{:02}′{:02}″N\", 24, 5, 23),\n           \"24°05′23″N\".to_string());</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p>字符串的数组、切片和向量都有两个方法（<code>.concat()</code> 和 <code>.join(sep)</code>），它们会从许多字符串中形成一个新的 <code>String</code>。</p>\n<pre class=\"code-rows\"><code>let bits = vec![\"veni\", \"vidi\", \"vici\"];\nassert_eq!(bits.concat(), \"venividivici\");\nassert_eq!(bits.join(\", \"), \"veni, vidi, vici\");</code></pre>\n</li>\n</ul>\n<p>有时要选择是使用 <code>&amp;str</code> 类型还是使用 <code>String</code> 类型。第 5 章会详细讨论这个问题。这里仅指出一点：<code>&amp;str</code> 可以引用任意字符串的任意切片，无论它是字符串字面量（存储在可执行文件中）还是 <code>String</code>（在运行期分配和释放）。这意味着如果希望允许调用者传递任何一种字符串，那么 <code>&amp;str</code> 更适合作为函数参数。</p>\n<h3 id=\"nav_point_61\">3.7.5　使用字符串</h3>\n<p>字符串支持 <code>==</code> 运算符和 <code>!=</code> 运算符。如果两个字符串以相同的顺序包含相同的字符（无论是否指向内存中的相同位置），则认为它们是相等的：</p>\n<pre class=\"code-rows\"><code>assert!(\"ONE\".to_lowercase() == \"one\");</code></pre>\n<p>字符串还支持比较运算符 <code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code> 和 <code>&gt;=</code>，以及许多有用的方法和函数，你可以在“<code>str</code>（原始类型）”或“<code>std::str</code>”模块下的在线文档中找到它们（或直接翻到第 17 章）。下面是一些例子：</p>\n<pre class=\"code-rows\"><code>assert!(\"peanut\".contains(\"nut\"));\nassert_eq!(\"ಠ_ಠ\".replace(\"ಠ\", \"■\"), \"■_■\");\nassert_eq!(\"    clean\\n\".trim(), \"clean\");\n\nfor word in \"veni, vidi, vici\".split(\", \") {\n    assert!(word.starts_with(\"v\"));\n}</code></pre>\n<p>要记住，考虑到 Unicode 的性质，简单的逐字符比较<strong>并不</strong>总能给出预期的答案。例如，Rust 字符串 <code>\"th\\u\"</code> 和 <code>\"the\\u\"</code> 都是 <code>thé</code>（在法语中是“茶”的意思）的有效 Unicode 表示。Unicode 规定它们应该以相同的方式显示和处理，但 Rust 会将它们视为两个完全不同的字符串。类似地，Rust 的排序运算符（如 <code>&lt;</code>）也使用基于字符码点值的简单字典顺序。这种排序方式只能说近似于在用户的语言和文化环境中对文本的正确排序方式。<span class=\"comment-number\">5</span>第 17 章会更详细地讨论这些问题。</p>\n\n<h3 id=\"nav_point_62\">3.7.6　其他类似字符串的类型</h3>\n<p>Rust 保证字符串是有效的 UTF-8。有时程序确实需要处理<strong>并非</strong>有效 Unicode 的字符串。这种情况通常发生在 Rust 程序不得不与不强制执行此类规则的其他系统进行互操作时，例如，在大多数操作系统中，很容易创建一个名字不符合 Unicode 规则的文件。当 Rust 程序遇到这种文件名时应该怎么办呢？</p>\n<p>Rust 的解决方案是为这些情况提供一些类似字符串的类型。</p>\n<ul>\n<li>对于 Unicode 文本，坚持使用 <code>String</code> 和 <code>&amp;str</code>。</li>\n<li>当使用文件名时，请改用 <code>std::path::PathBuf</code> 和 <code>&amp;Path</code>。</li>\n<li>当处理根本不是 UTF-8 编码的二进制数据时，请使用 <code>Vec&lt;u8&gt;</code> 和 <code>&amp;[u8]</code>。</li>\n<li>当使用操作系统提供的原生形式的环境变量名和命令行参数时，请使用 <code>OsString</code> 和 <code>&amp;OsStr</code>。</li>\n<li>当和使用 <code>null</code> 结尾字符串的 C 语言库进行互操作时，请使用 <code>std::ffi::CString</code> 和 <code>&amp;CStr</code>。</li>\n</ul>\n<h2 id=\"nav_point_63\">3.8　类型别名</h2>\n<p>与 C++ 中的 <code>typedef</code> 用法类似，可以使用 <code>type</code> 关键字来为现有类型声明一个新名称：</p>\n<pre class=\"code-rows\"><code>type Bytes = Vec&lt;u8&gt;;</code></pre>\n<p>这里声明的类型 <code>Bytes</code> 就是这种特定 <code>Vec</code> 的简写形式。</p>\n<pre class=\"code-rows\"><code>fn decode(data: &amp;Bytes) {\n    ...\n}</code></pre>\n<h2 id=\"nav_point_64\">3.9　前路展望</h2>\n<p>类型是 Rust 的核心部分。接下来本书会继续讨论类型并引入一些新的类型。特别是，Rust 的用户定义类型赋予了该语言很多特色，因为各种方法都是在此基础上定义的。用户定义类型共有 3 种，我们将用连续 3 章（第 9 章、第 10 章和第 11 章）介绍它们。</p>\n<p>函数和闭包都有自己的类型，第 14 章中会介绍。构成标准库的类型贯穿全书。例如，第 16 章会介绍标准的集合类型。</p>\n<p>不过，所有这些都还得再等等。在继续前进之前，我们必须先着手处理 Rust 安全规则的核心概念。</p>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 2 章 Rust 导览(2)","id":740801},"right":{"article_title":"第 4 章 所有权与移动 ","id":740803}},"comments":[{"had_liked":false,"id":387113,"user_name":"怀揣梦想的学渣","can_delete":false,"product_type":"c1","uid":1916685,"ip_address":"山东","ucode":"2349B9F4F6FDE3","user_header":"https://static001.geekbang.org/account/avatar/00/1d/3f/0d/1e8dbb2c.jpg","comment_is_top":false,"comment_ctime":1706511135,"is_pvip":true,"replies":null,"discussion_count":2,"race_medal":0,"score":2,"product_id":100636604,"comment_content":"如果没有其他编程语言基础，直接看这本书，还是比较痛苦的","like_count":1,"discussions":[{"author":{"id":1203049,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5b/69/7ace1ddb.jpg","nickname":"独钓寒江","note":"","ucode":"2C81906FD88C8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":641082,"discussion_content":"同感，老说c 和 c++，天然地觉得读者已这些。不过这本书已经比其它Rust入门作品好多了","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1712151212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2992138,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/a8/0a/791d0f5e.jpg","nickname":"Nolan","note":"","ucode":"5AD365C5154F0E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":648905,"discussion_content":"是的，需要对各个数据类型的内存模型有所了解。可以先看后面的章节，看看一些示例，回头再啃这一节","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1722388969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}