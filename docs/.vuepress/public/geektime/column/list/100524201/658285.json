{"id":658285,"title":"40｜串的朴素模式匹配算法：暴力但容易理解","content":"<p>你好，我是王健伟。</p><p>前面我们在讲串的基本操作的时候，你一定发现了，我们没有提到在一个字符串中寻找子串的问题。这个寻找操作，不仅是这种数据结构中所要面对的最常见的算法，更是最重要的算法之一。这节课，我们就专门来看一看，怎么去找到这个子串。</p><h2>问题的提出</h2><p>对于一个串“abdecdefg”，如果希望在其中寻找“def”这个串，这个问题其实就相当于在一个主串（“abdecdefg”）中寻找一个子串（“def”）并返回该子串位置。这种子串的定位操作通常称为串的<strong>模式匹配</strong>。其中子串也被称为<strong>模式串</strong>。这里注意，因为是在主串中寻找子串，所以显然主串的长度不应该小于子串。</p><p>串的模式匹配算法有很多，比如朴素模式匹配算法（BF）、Rabin-Karp（RK）算法、KMP算法、Boyer-Moore（BM）算法（常用于文本编辑器中，grep命令中）等，我们会挑选两种常用的算法（BF、KMP）进行讲解。</p><p>通常来讲，我们可以通过调用前面编写的串中的StrCmp()、SubString()操作接口（方法）实现子串定位操作，但这节课，我们不依赖于串的任何其他操作接口来实现子串的定位操作，这里要实现的是串的朴素（简单）模式匹配算法。这个算法就是对主串的每个字符作为子串的开头与子串进行匹配。</p><!-- [[[read_end]]] --><p><strong>串的朴素模式匹配算法</strong>也叫BF（Brute Force）算法或暴力匹配算法，实现相对简单，容易理解，算法执行效率不高但使用频率较高。</p><p>这里我们把子串（模式串）的长度记为m，主串长度记为n。串的朴素模式匹配算法的思想是：在主串中检查开始位置分别是0、1、2……n-m并且长度为m的n-m+1个子串，看有没有跟子串匹配的。</p><p>我们还是尝试描述一下实现子串定位操作的详细步骤，如图1所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/22/ab/22c7b7c097d55ac721a52e75de0e88ab.jpg?wh=1490x606\" alt=\"\" title=\"图1 串的朴素模式匹配算法【开始状态】\"></p><ul>\n<li>开始时，先设置两根指针point1和point2，分别指向主串和子串的开始地址，也就是下标0的位置。</li>\n<li>接着，开始主串和子串逐个字符的比较。子串中当前指针point2指向的字符是d，不等于主串中当前指针point1指向的字符a。所以主串中的指针point1指向下一个字符b。但是，该字符也不等于point2指向的字符d。所以主串中的指针point1继续指向下一个字符d，发现point1和ponit2指向的字符相同，都是d。如图2所示：</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/bd/fe/bd19yya4c36cbd1a46ddfb28c88497fe.jpg?wh=1569x616\" alt=\"\" title=\"图2 串的朴素模式匹配算法【步骤1】\"></p><ul>\n<li>\n<p>之后，让point1和point2指针指向各自串的下一个字符位置，point1指向了字符e，point2指向了字符e，比较point1和point2指向的字符，发现point1和point2指向的字符相同。</p>\n</li>\n<li>\n<p>让point1和point2指针指向各自串的下一个字符位置，point1指向了字符c，point2指向了字符f，比较point1和point2指向的字符，发现point1和point2指向的字符不同。如图3所示：<br>\n<img src=\"https://static001.geekbang.org/resource/image/77/07/77a66bb02255573bbd1a735byyd88a07.jpg?wh=1643x598\" alt=\"\" title=\"图3 串的朴素模式匹配算法【步骤2】\"></p>\n</li>\n<li>\n<p>继续让子串指针point2返回到开始字符d的位置。而point1要回退（回溯）来指向下标为3的位置（相当于子串右移了一个位置）。因为point1原来是从下标为2的位置开始与point2比较的。比较图4的两幅子图可以发现，<strong>比较的过程其实也就是子串不断右移与主串对应位置字符比较的过程</strong>：</p>\n</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/cb/bd/cbb0a9e7a34f9c1a967c81edeb1c98bd.jpg?wh=2693x748\" alt=\"\" title=\"图4 串的朴素模式匹配算法【步骤3】\"></p><ul>\n<li>比较point1和point2指向的字符，发现point1和point2指向的字符不同，point1指向下一个字符c（下标4的位置）。</li>\n<li>比较point1和point2指向的字符，发现point1和point2指向的字符不同，point1指向下一个字符d（下标5的位置）。如图5所示：</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/17/05/17262c9c50fe028b6f1c13a034b25505.jpg?wh=1468x634\" alt=\"\" title=\"图5 串的朴素模式匹配算法【步骤4】\"></p><ul>\n<li>比较point1和point2指向的字符，发现point1和point2指向的字符相同，都是d。</li>\n<li>让point1和point2指针指向各自串的下一个字符位置，继续比较point1和point2指向的字符，发现point1和point2指向的字符相同，都是e。</li>\n<li>让point1和point2指针指向各自串的下一个字符位置，继续比较point1和point2指向的字符，发现point1和point2指向的字符相同，都是f。</li>\n<li>此时point2指针已经达到了子串的末尾，比较完毕，在主串中返回和子串第一个字符d对应的字符的下标位置——5。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/7f/22/7f60b2d3dfff8411168e2aece813ba22.jpg?wh=1505x630\" alt=\"\" title=\"图6 串的朴素模式匹配算法【步骤5，注意指针最后停留位置】\"></p><h2>代码的实现</h2><p>在前面的采用定长数组存储结构实现的MySString类中增加朴素模式匹配算法接口。下面是实现代码。</p><pre><code class=\"language-plain\">//朴素模式匹配算法接口，返回子串中第一个字符在主串中的下标，如果没找到子串，则返回-1\nint StrIndex(const MySString&amp; substr,int pos = 0) //默认从位置0开始匹配子串\n{\n\tif (length &lt; substr.length) //主串还没子串长，那不可能找到\n\t\treturn -1;\n\t\t\n\tint point1 = pos, point2 = 0;\n\twhile (ch[point1] != '\\0' &amp;&amp; substr.ch[point2] != '\\0')\n\t{\n\t\tif (ch[point1] == substr.ch[point2])\n\t\t{\n\t\t\t//两个指针都向后走\n\t\t\tpoint1++;\n\t\t\tpoint2++;\n\t\t}\n\t\telse //两者不同\n\t\t{\n\t\t\t//两个指针都恢复到该恢复的位置\n\t\t\tpoint1 = point1 - point2 + 1;\n\t\t\tpoint2 = 0; //子串指针恢复到0，不管原来是多少\n\t\t}\n\t} //end while\n\t\n\tif (substr.ch[point2] == '\\0')\n\t{\n\t\t//找到了子串\n\t\treturn point1 - point2;\n\t}\n\treturn -1;\n}\n</code></pre><p>在main主函数中继续增加测试代码。</p><pre><code class=\"language-plain\">//朴素模式匹配算法接口，返回子串中第一个字符在主串中的下标，如果没找到子串，则返回-1\nMySString mys10, mys11;\nmys10.StrAssign(\"abdecdefg\");//主串\nmys11.StrAssign(\"def\"); //子串\ncout &lt;&lt;\"StrIndex()结果为\"&lt;&lt; mys10.StrIndex(mys11) &lt;&lt; endl;\n</code></pre><p>新增代码执行结果如下：<br>\n<img src=\"https://static001.geekbang.org/resource/image/1d/b6/1d516b00e13b7ba57e3db7225f8034b6.jpg?wh=2482x106\" alt=\"\"></p><p>因为子串长度为m，主串长度为n，所以匹配成功的最好情况时间复杂度为O(m)，此时子串的内容正好位于主串的开头。如图7所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/47/c5/47286c8d65a8083908d9f1c0eae28cc5.jpg?wh=1524x611\" alt=\"\" title=\"图7 匹配成功的最好情况时间复杂度为O(m)\"></p><p>如果没找到子串，比较好的情况是子串的第一个字符就与主串中的字符不匹配，那么匹配失败的最好情况时间复杂度应该为O(n-m+1)=O(n-m)，考虑到一般n的值远大于m，所以=O(n)。如图8所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/d0/25/d01dc62b68f16a2722f0770bf7a34c25.jpg?wh=1513x597\" alt=\"\" title=\"图8 匹配失败的最好情况时间复杂度为O(n)\"></p><p>看一看匹配成功的最坏情况时间复杂度（也可以看作是匹配失败的最坏情况时间复杂度），如图9所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/df/5e/dfc855yy4e5aef352ayybc0bd3e0c55e.jpg?wh=1500x621\" alt=\"\" title=\"图9 匹配成功/失败的最坏情况时间复杂度为O(n*m)\"></p><p>从图9不难看到，每个子串的前m-1个字符都和主串中的字符匹配，只有第m个字符不匹配。也就是每次都要比较子串中的前2个字符a，比较到子串中的第3个字符b时，发现和主串不匹配。而后point1指针必须要回退“子串长度+1”这么多的位置，再次和子串开头字符a进行比较……如此反复。可以看到，直到匹配成功或者匹配失败最多需要对比(n-m+1)<em>m = n</em>m-$m^{2}$+m次，因为一般n的值远大于m，所以n<em>m-$m^{2}$+m写成大O形式就是O(n</em>m)这样的最坏情况时间复杂度。</p><p>话说回来，找到子串之后到底可以干什么呢？这里我们可以进一步增加一个替换接口StrReplace()——<strong>在主串中找到子串，然后把这个子串替换成另一个子串</strong>。而且要求是不管主串中有多少个这样的子串，都应该被替换掉。</p><p>比如主串的内容是abcdeabcde，要求将其中所有的cd替换成mno，那么替换后的主串内容为abmnoeabmnoe。具体实现代码如下：</p><pre><code class=\"language-plain\">//串替换，主串中遇到内容为substr1的子串，全部替换成substr2子串\nvoid StrReplace(const MySString&amp; substr1, const MySString&amp; substr2)\n{\n\tint idx = -1;\n\tint pos = 0;\n\tint addlength = int(substr2.length) - int(substr1.length);&nbsp;\n\twhile (pos &lt; length)\n\t{\n\t\tidx = StrIndex(substr1, pos);\n\t\tif (idx == -1)\n\t\t\treturn; //不存在substr1这样的子串，无需替换直接返回\n\t\t\n\t\t//能否替换，取决于空间是否够\n\t\tif (addlength &gt; 0)\n\t\t{\n\t\t\t//被替换成的子串更长，要判断保存空间是否够\n\t\t\tif (length + addlength &gt;= MAX_LEN)\n\t\t\t\treturn; //空间不够，不能替换成新内容\n\t\t}\n\t\t\t\n\t\tStrDelete(idx, int(substr1.length));&nbsp; //删除老子串\n\t\tStrInsert(idx, substr2); //插入新子串\n\t\t\n\t\t//位置应该向后走，跳过被替换的子串部分内容\n\t\tpos = idx + (int)(substr2.length);\n\t} //end while\n\treturn;\n}\n</code></pre><p>在main主函数中继续增加如下测试代码：</p><pre><code class=\"language-plain\">//串替换，主串中遇到内容为substr1的，全部替换成substr2\nMySString mys12, substr1, substr2;\nmys12.StrAssign(\"abcdeabcde\");\ncout &lt;&lt;\"mys12替换前的结果为\"&lt;&lt; mys12.ch &lt;&lt; endl;\nsubstr1.StrAssign(\"cd\");\nsubstr2.StrAssign(\"mno\");\nmys12.StrReplace(substr1, substr2);\ncout &lt;&lt;\"mys12替换后的结果为\"&lt;&lt; mys12.ch &lt;&lt; endl;\n</code></pre><p>新增代码执行结果如下：<br>\n<img src=\"https://static001.geekbang.org/resource/image/3b/68/3bf2d39dc3e29e73fb6f98c43cdce968.jpg?wh=2454x188\" alt=\"\"></p><p>串的朴素模式匹配算法虽然执行效率不高，但仍旧比较常用，因为大部分情况下主串和子串都不会太长，而且相信你也感觉到了，这个算法的思想相对简单，代码实现也不难，不容易出错。</p><h2>小结</h2><p>本节我带你学习了在一个在串中寻找子串的算法——串的朴素模式匹配算法。</p><p>这个算法是对主串的每个字符作为子串的开头，以此来尝试查找子串在主串中第一次出现的位置。我们将子串的长度记为m，主串长度记为n。串的朴素模式匹配算法的思想是在主串中检查开始位置分别是0、1、2……n-m并且长度为m的n-m+1个子串，看有没有跟子串匹配的。</p><p>接下来，我们还详细学习了串的朴素模式匹配算法的匹配步骤。因为子串长度为m，主串长度为n，所以匹配成功的最好情况时间复杂度为O(m)，匹配失败的最好情况时间复杂度一般为O(n)。匹配成功的最坏情况时间复杂度是O(n*m)。</p><p>此外，我还带你实现了子串替换接口StrReplace()的源代码编写，用于在主串中找到子串，然后把这个子串替换成另一个子串。</p><h2>思考题</h2><p>请用串的朴素模式匹配算法实现如下问题：给定一个主串和一个子串，找出主串中所有与子串匹配的位置。</p><p>欢迎你在留言区和我交流。如果觉得有所收获，也可以把课程分享课更多的朋友一起学习进步！我们下节课见！</p>","neighbors":{"left":{"article_title":"39｜串的顺序和链式存储结构：定长数组与动态数组","id":656843},"right":{"article_title":"41｜串的KMP模式匹配算法观察：理解困难","id":659200}},"comments":[{"had_liked":false,"id":381765,"user_name":"Tiger","can_delete":false,"product_type":"c1","uid":1903781,"ip_address":"北京","ucode":"BFD74BFE539A8A","user_header":"https://static001.geekbang.org/account/avatar/00/1d/0c/a5/0bbfd5e7.jpg","comment_is_top":false,"comment_ctime":1695824416,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100524201,"comment_content":"老师您好，文章中图9后面那一段，“而后 point1 指针必须要回退“子串长度 +1”这么多的位置”，point1指针应该要回退“子串长度-2”那么多位置。","like_count":0}]}