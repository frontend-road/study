{"id":154687,"title":"17 | 源码剖析：Netty对keepalive与idle监测的支持","content":"<p><strong>课件和Demo地址</strong><br>\n<a href=\"https://gitee.com/geektime-geekbang/geek_netty\">https://gitee.com/geektime-geekbang/geek_netty</a></p>","comments":[{"had_liked":false,"id":155372,"user_name":"冬渐暖","can_delete":false,"product_type":"c3","uid":1586800,"ip_address":"","ucode":"907E41AAE9A36C","user_header":"https://static001.geekbang.org/account/avatar/00/18/36/70/00122b24.jpg","comment_is_top":false,"comment_ctime":1574682923,"is_pvip":false,"replies":[{"id":59710,"content":"全部读下来，没找到你的问题，也没发现哪里不对，所以:正解！","user_name":"作者回复","user_name_real":"Geek_9bc307","uid":1638649,"ctime":1574737009,"ip_address":"","comment_id":155372,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"设置keepalive参数的流程:有个用于接收连接的后续处理ServerBootstrapAcceptor，把选项设置到消息里面去（不同的io实现不同）\n\n开启keepalive的    NioChannelOption和普通的ChannelOption的区别\nNioChannelOption会优先根据jdk版本是否大于7和请求是否为NioChannelOption，如果是的话就通过NioChannelOption.setOption来设置(调用jdk的设置方法，当然，其中也包括规避jdk的一些bug版本来用自己的，这个也对应了开始章节讲的：netty的思想是解决不了的就绕过)，不是的话就通过父类老方法来set(要一个一个的if else你的入参是什么类型的)\n\nidle检测\n\nidle有三个状态：没有数据收(READER_IDLE),没有数据发送(WRTIER_IDLE),收和发都没有(ALL_IDLE)。总之跟idle状态相关的（比如event、handle）  一定有这三个状态，只是具体的类型不同\n\n关于idle事件的状态，又根据这个状态是否为第一次来把上面的三个状态分成6个，是第一次的话就在名字前面加个FIREST_，不是就不加\n\nidle检测核心是触发event   是通过定时任务轮询看是否有空闲并且写ing或者成功（会跟踪这个进度，通过比较哈希以及上一次待发送字节数是否不等于这次的字节数），不是idle话就再建一个定时任务\n","like_count":11,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475732,"discussion_content":"全部读下来，没找到你的问题，也没发现哪里不对，所以:正解！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574737009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205583,"user_name":"Ricky Fung","can_delete":false,"product_type":"c3","uid":1051363,"ip_address":"","ucode":"7AEA1F8EC4A088","user_header":"https://static001.geekbang.org/account/avatar/00/10/0a/e3/9637bfdb.jpg","comment_is_top":false,"comment_ctime":1586678501,"is_pvip":false,"replies":[{"id":79678,"content":"    option和childoption是设置不同socket channel的，分别服务于ServerSocketChannel和SocketChannel。\n    之所以用了child前缀作为区分，是因为服务的channel有父子关系（前者产生后者: SocketChannel = serverSocketChannel.accept();）。\n    他们都在channel初始化时使用，具体而言。前者是在启动服务时，后者是在创建连接时，但是这里有个问题是，就是可以设置的option是共享的，这就导致，一些参数（例如io.netty.channel.ChannelOption#SO_BACKLOG，\n）仅仅对serversocketchannel有效，但是可能会不小心设置给socketchannel。例如本应该是.option(ChannelOption.SO_BACKLOG, 100)，却不小心写成了.childOption(ChannelOption.SO_BACKLOG, 100)，这样的话，会发生什么？实际上并没有报错，只是后期使用时，可能无法生效，可以说是一个隐蔽的坑。这里要注意下。\n所以你的问题，总结下就是：设置的参数服务目标不同，且应该根据不同的目标选择参数，当然这些参数有一些是都可以设置的，有一些却是专有的。上面的例子也说了。","user_name":"作者回复","user_name_real":"stroller","uid":1638649,"ctime":1588980567,"ip_address":"","comment_id":205583,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"请教一下 option 和 childOption 设置的参数有何不同呢？","like_count":7,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491520,"discussion_content":"    option和childoption是设置不同socket channel的，分别服务于ServerSocketChannel和SocketChannel。\n    之所以用了child前缀作为区分，是因为服务的channel有父子关系（前者产生后者: SocketChannel = serverSocketChannel.accept();）。\n    他们都在channel初始化时使用，具体而言。前者是在启动服务时，后者是在创建连接时，但是这里有个问题是，就是可以设置的option是共享的，这就导致，一些参数（例如io.netty.channel.ChannelOption#SO_BACKLOG，\n）仅仅对serversocketchannel有效，但是可能会不小心设置给socketchannel。例如本应该是.option(ChannelOption.SO_BACKLOG, 100)，却不小心写成了.childOption(ChannelOption.SO_BACKLOG, 100)，这样的话，会发生什么？实际上并没有报错，只是后期使用时，可能无法生效，可以说是一个隐蔽的坑。这里要注意下。\n所以你的问题，总结下就是：设置的参数服务目标不同，且应该根据不同的目标选择参数，当然这些参数有一些是都可以设置的，有一些却是专有的。上面的例子也说了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588980567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169008,"user_name":"torres","can_delete":false,"product_type":"c3","uid":1108761,"ip_address":"","ucode":"34DABCFC7B74EA","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/19/76b0b98c.jpg","comment_is_top":false,"comment_ctime":1578236920,"is_pvip":false,"replies":[{"id":65560,"content":"配合方式有很多种，你这种是可以的，而且很多也这么做，然后不管哪种，只要收发消息都需要编解码，所以才是统一的(不然不就不是消息的一种了么？)，你在案例中可能没有看到显示编解码，而是直接写出了消息。那是因为这个写的过程经过了之前写的二对编解码器了，所以都会做的，也应该做的。","user_name":"作者回复","user_name_real":"stroller","uid":1638649,"ctime":1578274293,"ip_address":"","comment_id":169008,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师，两点问题请教一下\n1.如果想idle和keepalive配合使用，是否是需要在处理idle事件时进行编码，向客服端去发送对应的keepalive请求？\n2.客户端是否要对我发送的keepalive请求进行回复，没有回复是否视为连接失效，直接断开？（此处服务端和客户端是否都要进行相应的编码？）","like_count":2,"discussions":[{"author":{"id":1024294,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","nickname":"null","note":"","ucode":"F9039EFED6B55D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":316199,"discussion_content":"层主的“编码”，是指“编写代码”吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603373969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143989,"user_name":"加载中……","can_delete":false,"product_type":"c3","uid":1366948,"ip_address":"","ucode":"3E59A0A0784D0A","user_header":"https://static001.geekbang.org/account/avatar/00/14/db/a4/191be6ad.jpg","comment_is_top":false,"comment_ctime":1571821454,"is_pvip":false,"replies":[{"id":59383,"content":"问题1：对的；问题2：也对，但是问题2的（1）你写反了吧？observeOutput = true。这里补充说下，这么大的文件，应该用chunk的方式那写了，否则容易OOM的。","user_name":"作者回复","user_name_real":"Geek_9bc307","uid":1638649,"ctime":1574518852,"ip_address":"","comment_id":143989,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师好，有个疑问请教下，如下：\n一、netty使用IdleStateHandler类做idle监测\n1、对于读idle监测，IdleStateHandler的子类ReadTimeoutHandler会触发ReadTimeoutException异常，自定义的handler感知到这个异常可以做一些处理操作。\n2、对于写idle监测，\na、如果observeOutput为false, 只有写入缓冲区成功 才算有写操作。\nb、如果observeOutput为true，只要有写的意图 就算 有写操作，写意图包括：①写了，但缓冲区满了，没写成功 ②写了一个大数据，写确实在动，但没有完成。\n这里些疑问：\n如果有个场景：调用write方法写入了一个4个G的文件(一时半会写不完，假如每次只能写1k到缓冲区) \n问题一：这对应的是b.②情况么？\n问题二：如果observeOutput为false, 是要把4G都写入完缓冲区才算有写操作？\n\n我先说下我的理解：\n问题一：不知道\n问题二：\n1、如果observeOutput为false，虽然发送的是4个G数据，只要有n字节(n&gt;0)写入成功 都算有写操作.\n2、如果发送的是4个G的数据，判断在一段时间内有没有全部把4G写完，是WriteTimeoutHandler干的事情。","like_count":2,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471769,"discussion_content":"问题1：对的；问题2：也对，但是问题2的（1）你写反了吧？observeOutput = true。这里补充说下，这么大的文件，应该用chunk的方式那写了，否则容易OOM的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574518852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146191,"user_name":"nomoshen","can_delete":false,"product_type":"c3","uid":1043083,"ip_address":"","ucode":"7EA7C4FECFA7C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ea/8b/613c162e.jpg","comment_is_top":false,"comment_ctime":1572451054,"is_pvip":false,"replies":[{"id":56569,"content":"会的，如果你设置idle监测的时间低于你的keepalive时间，然后没数据，就会监测到空闲后就关闭连接，就是你说的情况，所以一般把空闲监测的时间设置的比keepalive大，这样就好了。当然这里说的都是应用层keepalive.你说的那个tcp层的keepalive对应用层的idle监测并没用，idle监测是应用层在做，它看的是应用层有没有数据，而不是tcp层的，另外idle监测主要是保护系统的，优化系统的，所以连接正常也可能触发的","user_name":"作者回复","user_name_real":"Geek_9bc307","uid":1638649,"ctime":1572540347,"ip_address":"","comment_id":146191,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师我有一点不明白；keepalive其实本质也是用来检测链路是否正常，而idle检测看起来也是用来检测链路是否正常；tcp的keepalive是在7200s之后如果没有数据就进行发送，那会不会在之前idle就已经被触发然后断掉连接呢？ 这块没怎么搞明白？","like_count":1,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472746,"discussion_content":"会的，如果你设置idle监测的时间低于你的keepalive时间，然后没数据，就会监测到空闲后就关闭连接，就是你说的情况，所以一般把空闲监测的时间设置的比keepalive大，这样就好了。当然这里说的都是应用层keepalive.你说的那个tcp层的keepalive对应用层的idle监测并没用，idle监测是应用层在做，它看的是应用层有没有数据，而不是tcp层的，另外idle监测主要是保护系统的，优化系统的，所以连接正常也可能触发的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572540347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153979,"user_name":"姚远","can_delete":false,"product_type":"c3","uid":1680082,"ip_address":"","ucode":"AB278EF7581440","user_header":"https://static001.geekbang.org/account/avatar/00/19/a2/d2/1d1ae570.jpg","comment_is_top":false,"comment_ctime":1574341236,"is_pvip":false,"replies":[{"id":59154,"content":"这个在第六章的dubbo那节都会讲到，这里先简单说下: 1 dubbo用了二个版本，有二个文件夹 2 是的，它的客户端用idle来触发keepalive了，server端的idle直接断连，两个配合一起用","user_name":"作者回复","user_name_real":"Geek_9bc307","uid":1638649,"ctime":1574352095,"ip_address":"","comment_id":153979,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师您好 最近在看dubbo源码。发现dubbo最新的release使用的还是netty3～～为什么呢。还有dubbo实现了一个keepalive的handler 对应netty来说就是业务层的keepalive了吧。\n","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475343,"discussion_content":"这个在第六章的dubbo那节都会讲到，这里先简单说下: 1 dubbo用了二个版本，有二个文件夹 2 是的，它的客户端用idle来触发keepalive了，server端的idle直接断连，两个配合一起用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574352095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146185,"user_name":"shinee_x_X","can_delete":false,"product_type":"c3","uid":1605962,"ip_address":"","ucode":"98529C77B052AC","user_header":"https://static001.geekbang.org/account/avatar/00/18/81/4a/dcc563fb.jpg","comment_is_top":false,"comment_ctime":1572449015,"is_pvip":false,"replies":[{"id":56571,"content":"因为应用层的keeplive属于应用层，而且每个协议，除了那些流行的外，大多是我们自己的内部写的应用，都不同，所以他不知道我们怎么定义我们的keepalive，所以他不好提供通用的实现什么的，所以我们自己要去实现keepalive.","user_name":"作者回复","user_name_real":"Geek_9bc307","uid":1638649,"ctime":1572540726,"ip_address":"","comment_id":146185,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师，前一节课不是说tcp  keepalive不好吗，怎么netty不在应用层用keepalive","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472742,"discussion_content":"因为应用层的keeplive属于应用层，而且每个协议，除了那些流行的外，大多是我们自己的内部写的应用，都不同，所以他不知道我们怎么定义我们的keepalive，所以他不好提供通用的实现什么的，所以我们自己要去实现keepalive.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572540726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1605962,"avatar":"https://static001.geekbang.org/account/avatar/00/18/81/4a/dcc563fb.jpg","nickname":"shinee_x_X","note":"","ucode":"98529C77B052AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42122,"discussion_content":"所以netty也是在tcp实现keepalive吗，那ping和pong的探测不是从应用层发的吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572592879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144713,"user_name":"Gary","can_delete":false,"product_type":"c3","uid":1218372,"ip_address":"","ucode":"12265D6A578113","user_header":"https://static001.geekbang.org/account/avatar/00/12/97/44/3929e620.jpg","comment_is_top":false,"comment_ctime":1572006221,"is_pvip":false,"replies":[{"id":55841,"content":"一般就特别简单的数据。比如ping pong字符这种都可以，原则就是简单数据量小。对端一般都要处理下，但比如只想服务器看看有没有请求过来，不考虑客户端，那也可以不处理，但是作为完整性，最好还是要处理的，这样所有消息定义都是一来一回清晰","user_name":"作者回复","user_name_real":"Geek_9bc307","uid":1638649,"ctime":1572061322,"ip_address":"","comment_id":144713,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师你好，keepalive发送的是什么数据来探测的，需要对端做处理吗？","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472079,"discussion_content":"一般就特别简单的数据。比如ping pong字符这种都可以，原则就是简单数据量小。对端一般都要处理下，但比如只想服务器看看有没有请求过来，不考虑客户端，那也可以不处理，但是作为完整性，最好还是要处理的，这样所有消息定义都是一来一回清晰","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572061322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1108761,"avatar":"https://static001.geekbang.org/account/avatar/00/10/eb/19/76b0b98c.jpg","nickname":"torres","note":"","ucode":"34DABCFC7B74EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":119596,"discussion_content":"老师，如果对端没有做处理，服务器是否就认为对端已经下线，会强制关闭链接？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578233815,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144083,"user_name":"鱼向北游","can_delete":false,"product_type":"c3","uid":1439908,"ip_address":"","ucode":"580EC7DCE57E9A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/IPdZZXuHVMibwfZWmm7NiawzeEFGsaRoWjhuN99iaoj5amcRkiaOePo6rH1KJ3jictmNlic4OibkF4I20vOGfwDqcBxfA/132","comment_is_top":false,"comment_ctime":1571841441,"is_pvip":false,"replies":[{"id":55674,"content":"但是原文前面是no data.意思没有读，也没有写，用你说的表达肯定也行，就要换句表达了，二个本质都是一个意思，类似 双重否定等于肯定","user_name":"作者回复","user_name_real":"Geek_9bc307","uid":1638649,"ctime":1571923224,"ip_address":"","comment_id":144083,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"idlestate 那里的all 我看注释写的是either or 这个的意思不是或者。。或者。。么，意思是写idle或者读idle，如果是并且的关系应该是用neither nor呀","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471807,"discussion_content":"但是原文前面是no data.意思没有读，也没有写，用你说的表达肯定也行，就要换句表达了，二个本质都是一个意思，类似 双重否定等于肯定","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571923224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":255571,"user_name":"null","can_delete":false,"product_type":"c3","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1603374769,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师，请教一下 idle 和 keepalive 的关系：\n1. idle_time 后，进入 idle 状态，然后发keepalive探测包，最后关闭连接。\n2. 发 keepalive 探测包，7200+75*9之后，再过一段时间 idle_time，就进入 idle 状态，触发 idle_event 关闭连接。\n\n学习16节时，我理解它俩的关系如第1点描述那样。\n但是学习了17节，它俩的关系又好像第2点那样。\n\n有点犯迷糊了，望老师回复，谢谢！","like_count":2,"discussions":[{"author":{"id":1670039,"avatar":"https://static001.geekbang.org/account/avatar/00/19/7b/97/950082a4.jpg","nickname":"fish","note":"","ucode":"EBC306460F2962","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360985,"discussion_content":"应该是第一种，idel存在是不需要一直keepalive，只有idel时才开始keepalive","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1616574474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345979,"user_name":"卷毛","can_delete":false,"product_type":"c3","uid":1762439,"ip_address":"","ucode":"B53D459BB63025","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e4/87/fa7438da.jpg","comment_is_top":false,"comment_ctime":1652748858,"is_pvip":false,"replies":null,"discussion_count":2,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"没有讲明白为什么：serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, true); 存在但无效。\n\n看下来，其实两种方式都是有效的。","like_count":0,"discussions":[{"author":{"id":2527977,"avatar":"https://static001.geekbang.org/account/avatar/00/26/92/e9/cfb01b05.jpg","nickname":"Aaron","note":"","ucode":"5B31F3923707C5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610833,"discussion_content":"serverBootstrap.childOption 设置的是和客户端做连接的 SocketChannel，\n之前说的是视频里的说的是 .option(ChannelOption.SO_KEEPALIVE,true) 存在但是无效，对应的也就是 ServerSocketChannel 的设置，而 Linux 系统 TCP keepalive\n默认关闭 所以当然是设置无效的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679795900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1762439,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e4/87/fa7438da.jpg","nickname":"卷毛","note":"","ucode":"B53D459BB63025","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2527977,"avatar":"https://static001.geekbang.org/account/avatar/00/26/92/e9/cfb01b05.jpg","nickname":"Aaron","note":"","ucode":"5B31F3923707C5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":611972,"discussion_content":"默认开启吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680444098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":610833,"ip_address":"浙江","group_id":0},"score":611972,"extra":""}]}]},{"had_liked":false,"id":327396,"user_name":"Mong狗","can_delete":false,"product_type":"c3","uid":1048525,"ip_address":"","ucode":"9DF0D65D75984E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ff/cd/9c44f2d5.jpg","comment_is_top":false,"comment_ctime":1640097896,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":2,"score":3,"product_id":100036701,"comment_content":"老师好，1、childOption设置的keepAlive 是让tcp层的keepalive生效么？2、idle监测到客户端channel空闲了，那发送了一个keepalive且不关闭链接, 那假如客户端不响应的话，那idle检测仍旧能够检测到，这个时候是否可以通过判断事件是否是否次触发来决定是否关闭连接而不是再次发送keepalive心跳呢？","like_count":0},{"had_liked":false,"id":288916,"user_name":"cxdhjx","can_delete":false,"product_type":"c3","uid":2292690,"ip_address":"","ucode":"FF13B4B75611C3","user_header":"","comment_is_top":false,"comment_ctime":1618762720,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"netty 服务端 和客户端如果网络掉线后，如何进行重连？","like_count":0},{"had_liked":false,"id":241763,"user_name":"一道阳光","can_delete":false,"product_type":"c3","uid":1239557,"ip_address":"","ucode":"F35207CCCEC6E2","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/05/c0d8014d.jpg","comment_is_top":false,"comment_ctime":1597414491,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"不理解nextDelay &lt;= 0是空闲，不是大于0吗？","like_count":0,"discussions":[{"author":{"id":1284840,"avatar":"https://static001.geekbang.org/account/avatar/00/13/9a/e8/fca2d451.jpg","nickname":"小超","note":"","ucode":"AB7442EB6A1F9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300079,"discussion_content":"超过指定的空闲时间了，就自然小于0了，比如你设置的空闲时间是10秒，当前的纳秒（假设100） - 上一次发生读写时间的时间（80） = 间隔时间（20），那么10（空闲时间）- 20（间隔时间）= -10","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597931014,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190977,"user_name":"Geek_bbbda3","can_delete":false,"product_type":"c3","uid":1504651,"ip_address":"","ucode":"737394CE472C21","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKNDKOCoZvCqoYVM1t97Q77QPLmRBGvOLYzFsh8073RicycoIuwGrIsCXpAFEyVBOxcyE3Ih1mr6Vw/132","comment_is_top":false,"comment_ctime":1584715517,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"有个地方不理解：hasOutputChanged中为什么要判断first？","like_count":0}]}