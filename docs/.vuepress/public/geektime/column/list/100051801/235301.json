{"id":235301,"title":"05 | 面向对象编程：怎样才能写出一个“好”的类？","content":"<p>你好，我是Chrono。</p><p>如果按照前几节课的惯例，今天应该是讲运行阶段的。但是，运行阶段跟前面的编码、预处理和编译阶段不同，它是动态的、实时的，内外部环境非常复杂，CPU、内存、磁盘、信号、网络套接字……各种资源交织在一起，可谓千变万化（正如我在<a href=\"https://time.geekbang.org/column/article/231454\">第1节课</a>里所说，每一个阶段的差异都非常大）。</p><p>解决这个阶段面临的问题已经不是编程技术了，更多的是要依靠各种调试、分析、日志工具，比如GDB、Valgrind、Systemtap等。</p><p>所以，我觉得把这些运行阶段的工具、技巧放在课程前面不是太合适，咱们还是往后延一延，等把C++的核心知识点都学完了，再来看它比较好。</p><p>那么，今天要和你聊哪些内容呢？</p><p>我想了想，还是讲讲“面向对象编程”（Object Oriented Programming）吧。毕竟，它是C++诞生之初“安身立命”的看家本领，也是C++的核心编程范式。</p><p>不管我们是否喜欢，“面向对象”早就已经成为了编程界的共识和主流。C++、Java、Python等流行的语言，无一不支持面向对象编程，而像Pascal、BASIC、PHP那样早期面向过程的语言，在发展过程中也都增加了对它的支持，新出的Go、Swift、Rust就更不用说了。</p><!-- [[[read_end]]] --><p>毫无疑问，<strong>掌握“面向对象编程”是现在程序员的基本素养</strong>。但落到实际开发时，每个人对它的理解程度却有深有浅，应用的水平也有高有低，有的人设计出的类精致灵活，而有的人设计出来的却是粗糙笨重。</p><p>细想起来，“面向对象”里面可以研究的地方实在是太多了。那么，到底“面向对象”的精髓是什么？怎样才能用好它？怎样才能写出一个称得上是“好”的类呢？</p><p>所以，今天我就从设计思想、实现原则和编码准则这几个角度谈谈我对它的体会心得，以及在C++里应用的一些经验技巧，帮你写出更高效、更安全、更灵活的类。（在第19、20课，我还会具体讲解，到时候你可以参考下。）</p><h2>设计思想</h2><p>首先要说的是，虽然很多语言都内建语法支持面向对象编程，但它本质上是一种设计思想、方法，与语言细节无关，要点是<strong>抽象</strong>（Abstraction）和<strong>封装</strong>（Encapsulation）。</p><p>掌握了这种代码之外的思考方式，就可以“高屋建瓴”，站在更高的维度上去设计程序，不会被语言、语法所限制。</p><p>所以，即使是像C这样“纯”面向过程的编程语言，也能够应用面向对象的思想，以struct实现抽象和封装，得到良好的程序结构。</p><p>面向对象编程的基本出发点是“对现实世界的模拟”，把问题中的实体抽象出来，封装为程序里的类和对象，这样就在计算机里为现实问题建立了一个“虚拟模型”。</p><p>然后以这个模型为基础不断演化，继续抽象对象之间的关系和通信，再用更多的对象去描述、模拟……直到最后，就形成了一个由许多互相联系的对象构成的系统。</p><p>把这个系统设计出来、用代码实现出来，就是“面向对象编程”了。</p><p>不过，因为现实世界非常复杂，“面向对象编程”作为一种工程方法，是不可能完美模拟的，纯粹的面向对象也有一些缺陷，其中最明显的就是“继承”。</p><p>“继承”的本意是重用代码，表述类型的从属关系（Is-A），但它却不能与现实完全对应，所以用起来就会出现很多意外情况。</p><p>比如那个著名的长方形的例子。Rectangle表示长方形，Square继承Rectangle，表示正方形。现在问题就来了，这个关系在数学中是正确的，但表示为代码却不太正确。长方形可以用成员函数单独变更长宽，但正方形却不行，长和宽必须同时变更。</p><p>还有那个同样著名的鸟类的例子。基类Bird有个Fly方法，所有的鸟类都应该继承它。但企鹅、鸵鸟这样的鸟类却不会飞，实现它们就必须改写Fly方法。</p><p>各种编程语言为此都加上了一些“补丁”，像C++就有“多态”“虚函数”“重载”，虽然解决了“继承”的问题，但也使代码复杂化了，一定程度上扭曲了“面向对象”的本意。</p><h2>实现原则</h2><p>说了些“高大上”的理论，是不是有点犯迷糊？没关系，下面，我就在C++里细化一下。</p><p>就像我刚才说的，“面向对象编程”的关键点是“抽象”和“封装”，而“继承”“多态”并不是核心，只能算是附加品。</p><p>所以，我建议你在设计类的时候<strong>尽量少用继承和虚函数</strong>。</p><p>特别的，如果完全没有继承关系，就可以让对象不必承受“父辈的重担”（父类成员、虚表等额外开销），轻装前行，更小更快。没有隐含的重用代码也会降低耦合度，让类更独立，更容易理解。</p><p>还有，把“继承”切割出去之后，可以避免去记忆、实施那一大堆难懂的相关规则，比如public/protected/private继承方式的区别、多重继承、纯虚接口类、虚析构函数，还可以绕过动态转型、对象切片、函数重载等很多危险的陷阱，减少冗余代码，提高代码的健壮性。</p><p>如果非要用继承不可，那么我觉得一定要<strong>控制继承的层次</strong>，用UML画个类体系的示意图来辅助检查。如果继承深度超过三层，就说明有点“过度设计”了，需要考虑用组合关系替代继承关系，或者改用模板和泛型。</p><p><img src=\"https://static001.geekbang.org/resource/image/14/d5/145780476bd0beb148e5e130c2336ed5.jpg?wh=4950*3935\" alt=\"\"></p><p>在设计类接口的时候，我们也要让类尽量简单、“短小精悍”，<strong>只负责单一的功能</strong>。</p><p>如果很多功能混在了一起，出现了“万能类”“意大利面条类”（有时候也叫God Class），就要应用设计模式、重构等知识，把大类拆分成多个各负其责的小类。</p><p>我还看到过很多人有一种不好的习惯，就是喜欢在类内部定义一些嵌套类，美其名曰“高内聚”。但恰恰相反，这些内部类反而与上级类形成了强耦合关系，也是另一种形式的“万能类”。</p><p>其实，这本来是名字空间该做的事情，用类来实现就有点“越权”了。正确的做法应该是，<strong>定义一个新的名字空间，把内部类都“提”到外面，降低原来类的耦合度和复杂度</strong>。</p><h2>编码准则</h2><p>有了这些实现原则，下面我再来讲几个编码时的细节，从安全和性能方面帮你改善类的代码。</p><p>C++11新增了一个特殊的标识符“<strong>final</strong>”（注意，它不是关键字），把它用于类定义，就可以显式地禁用继承，防止其他人有意或者无意地产生派生类。无论是对人还是对编译器，效果都非常好，我建议你一定要积极使用。</p><pre><code>class DemoClass final    // 禁止任何人继承我\n{ ... };\n</code></pre><p>在必须使用继承的场合，建议你<strong>只使用public继承，避免使用virtual、protected</strong>，因为它们会让父类与子类的关系变得难以捉摸，带来很多麻烦。当到达继承体系底层时，也要及时使用“final”，终止继承关系。</p><pre><code>class Interface        // 接口类定义，没有final，可以被继承\n{ ... };           \n\nclass Implement final : // 实现类，final禁止再被继承\n      public Interface    // 只用public继承\n{ ... };\n</code></pre><p>C++里类的四大函数你一定知道吧，它们是构造函数、析构函数、拷贝构造函数、拷贝赋值函数。C++11因为引入了右值（Rvalue）和转移（Move），又多出了两大函数：<strong>转移构造函数</strong>和<strong>转移赋值函数</strong>。所以，在现代C++里，一个类总是会有六大基本函数：<strong>三个构造</strong>、<strong>两个赋值</strong>、<strong>一个析构</strong>。</p><p>好在C++编译器会自动为我们生成这些函数的默认实现，省去我们重复编写的时间和精力。但我建议，对于比较重要的构造函数和析构函数，应该用“<strong>= default</strong>”的形式，明确地告诉编译器（和代码阅读者）：“应该实现这个函数，但我不想自己写。”这样编译器就得到了明确的指示，可以做更好的优化。</p><pre><code>class DemoClass final \n{\npublic:\n    DemoClass() = default;  // 明确告诉编译器，使用默认实现\n   ~DemoClass() = default;  // 明确告诉编译器，使用默认实现\n};\n</code></pre><p>这种“= default”是C++11新增的专门用于六大基本函数的用法，相似的，还有一种“<strong>= delete</strong>”的形式。它表示<strong>明确地禁用某个函数形式</strong>，而且不限于构造/析构，可以用于任何函数（成员函数、自由函数）。</p><p>比如说，如果你想要禁止对象拷贝，就可以用这种语法显式地把拷贝构造和拷贝赋值“delete”掉，让外界无法调用。</p><pre><code>class DemoClass final \n{\npublic:\n    DemoClass(const DemoClass&amp;) = delete;              // 禁止拷贝构造\n    DemoClass&amp; operator=(const DemoClass&amp;) = delete;  // 禁止拷贝赋值\n};\n</code></pre><p>因为C++有隐式构造和隐式转型的规则，如果你的类里有单参数的构造函数，或者是转型操作符函数，为了防止意外的类型转换，保证安全，就要使用“<strong>explicit</strong>”将这些函数标记为“显式”。</p><pre><code>class DemoClass final \n{\npublic:\n    explicit DemoClass(const string_type&amp; str)  // 显式单参构造函数\n    { ... }\n\n    explicit operator bool()                  // 显式转型为bool\n    { ... }\n};\n</code></pre><h2>常用技巧</h2><p>C++11里还有很多能够让类更优雅的新特性，这里我从“投入产出比”的角度出发，挑出了三个我最喜欢的特性，给你介绍一下，让你不用花太多力气就能很好地改善代码质量。</p><p>第一个是“<strong>委托构造</strong>”（delegating constructor）。</p><p>如果你的类有多个不同形式的构造函数，为了初始化成员肯定会有大量的重复代码。为了避免重复，常见的做法是把公共的部分提取出来，放到一个init()函数里，然后构造函数再去调用。这种方法虽然可行，但<strong>效率和可读性较差</strong>，毕竟init()不是真正的构造函数。</p><p>在C++11里，你就可以使用“委托构造”的新特性，一个构造函数直接调用另一个构造函数，把构造工作“委托”出去，既简单又高效。</p><pre><code>class DemoDelegating final\n{\nprivate:\n    int a;                              // 成员变量\npublic:\n    DemoDelegating(int x) : a(x)        // 基本的构造函数\n    {}  \n\n    DemoDelegating() :                 // 无参数的构造函数\n        DemoDelegating(0)               // 给出默认值，委托给第一个构造函数\n    {}  \n\n    DemoDelegating(const string&amp; s) : // 字符串参数构造函数\n        DemoDelegating(stoi(s))        // 转换成整数，再委托给第一个构造函数\n    {}  \n};\n</code></pre><p>第二个是“<strong>成员变量初始化</strong>”（In-class member initializer）。</p><p>如果你的类有很多成员变量，那么在写构造函数的时候就比较麻烦，必须写出一长串的名字来逐个初始化，不仅不美观，更危险的是，容易“手抖”，遗漏成员，造成未初始化的隐患。</p><p>而在C++11里，你可以在类里声明变量的同时给它赋值，实现初始化，这样<strong>不但简单清晰，也消除了隐患。</strong></p><pre><code>class DemoInit final                  // 有很多成员变量的类\n{\nprivate:\n    int                 a = 0;        // 整数成员，赋值初始化\n    string              s = &quot;hello&quot;;  // 字符串成员，赋值初始化\n    vector&lt;int&gt;         v{1, 2, 3};   // 容器成员，使用花括号的初始化列表\npublic:\n    DemoInit() = default;             // 默认构造函数\n   ~DemoInit() = default;             // 默认析构函数\npublic:\n    DemoInit(int x) : a(x) {}         // 可以单独初始化成员，其他用默认值\n};\n\n</code></pre><p>第三个是“<strong>类型别名</strong>”（Type Alias）。</p><p>C++11扩展了关键字using的用法，增加了typedef的能力，可以定义类型别名。它的格式与typedef正好相反，别名在左边，原名在右边，是标准的赋值形式，所以易写易读。</p><pre><code>using uint_t = unsigned int;        // using别名\ntypedef unsigned int uint_t；      // 等价的typedef\n\n</code></pre><p>在写类的时候，我们经常会用到很多外部类型，比如标准库里的string、vector，还有其他的第三方库和自定义类型。这些名字通常都很长（特别是带上名字空间、模板参数），书写起来很不方便，这个时候我们就可以在类里面用using给它们起别名，不仅简化了名字，同时还能增强可读性。</p><pre><code>class DemoClass final\n{\npublic:\n    using this_type         = DemoClass;          // 给自己也起个别名\n    using kafka_conf_type   = KafkaConfig;        // 外部类起别名\n\npublic:\n    using string_type   = std::string;            // 字符串类型别名\n    using uint32_type   = uint32_t;              // 整数类型别名\n\n    using set_type      = std::set&lt;int&gt;;          // 集合类型别名\n    using vector_type   = std::vector&lt;std::string&gt;;// 容器类型别名\n\nprivate:\n    string_type     m_name  = &quot;tom&quot;;              // 使用类型别名声明变量\n    uint32_type     m_age   = 23;                  // 使用类型别名声明变量\n    set_type        m_books;                      // 使用类型别名声明变量\n\nprivate:\n    kafka_conf_type m_conf;                       // 使用类型别名声明变量\n};\n</code></pre><p>类型别名不仅能够让代码规范整齐，而且因为引入了这个“语法层面的宏定义”，将来在维护时还可以随意改换成其他的类型。比如，把字符串改成string_view（C++17里的字符串只读视图），把集合类型改成unordered_set，只要变动别名定义就行了，原代码不需要做任何改动。</p><h2>小结</h2><p>今天我们谈了“面向对象编程”，这节课的内容也比较多，我划一下重点。</p><ol>\n<li>“面向对象编程”是一种设计思想，要点是“抽象”和“封装”，“继承”“多态”是衍生出的特性，不完全符合现实世界。</li>\n<li>在C++里应当少用继承和虚函数，降低对象的成本，绕过那些难懂易错的陷阱。</li>\n<li>使用特殊标识符“final”可以禁止类被继承，简化类的层次关系。</li>\n<li>类有六大基本函数，对于重要的构造/析构函数，可以使用“= default”来显式要求编译器使用默认实现。</li>\n<li>“委托构造”和“成员变量初始化”特性可以让创建对象的工作更加轻松。</li>\n<li>使用using或typedef可以为类型起别名，既能够简化代码，还能够适应将来的变化。</li>\n</ol><p>所谓“仁者见仁智者见智”，今天我讲的也只能算是我自己的经验、体会。到底要怎么用，你还是要看自己的实际情况，千万不要完全照搬。</p><h2>课下作业</h2><p>这次的课下作业时间，我给你留两个思考题：</p><ol>\n<li>你对“面向对象编程”有哪些认识，是否赞同这节课的观点？（希望你大胆地说出来，如果意见有分歧，那也很正常，我们一起讨论。）</li>\n<li>你觉得应用这节课讲到的准则和技巧能否写出一个“好”的类，还缺什么吗？</li>\n</ol><p>欢迎你在留言区写下你的思考和答案，如果觉得今天的内容对你有所帮助，也欢迎分享给你的朋友。我们下节课见。</p><p><img src=\"https://static001.geekbang.org/resource/image/67/b3/6739782414607164bdbe20fca7fd5fb3.jpg?wh=2000*2535\" alt=\"\"></p>","neighbors":{"left":{"article_title":"04 | 编译阶段能做什么：属性和静态断言","id":235295},"right":{"article_title":"06 | auto/decltype：为什么要有自动类型推导？","id":237964}},"comments":[{"had_liked":false,"id":217682,"user_name":"lckfa李钊","can_delete":false,"product_type":"c1","uid":1356899,"ip_address":"","ucode":"AD13D205104AA6","user_header":"https://static001.geekbang.org/account/avatar/00/14/b4/63/84960032.jpg","comment_is_top":false,"comment_ctime":1589584578,"is_pvip":false,"replies":[{"id":"80521","content":"<br>1.我的理解，抽象就是“建模”，用类在代码里建立一个现实对象的映射。<br><br>2.设计模式更强调对象组合，而不是继承，类模式很少。<br><br>3.继承是一种“硬”代码复用，关系比较强，不如组合灵活，我建议少用。当然这还是要建立在对继承等特性有比较深刻认识的基础上。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589601901,"ip_address":"","comment_id":217682,"utype":1}],"discussion_count":2,"race_medal":0,"score":"126143636162","product_id":100051801,"comment_content":"关于老师的思考题，我个人的想法是本节的知识点还不足以写一个好的类，文中编码准则和常用技巧里的介绍只是在编码层面给出了建议，但是缺少方法论。少用继承，多用组合，这个建议可以再扩展深入点，比如有的鸟不会飞的例子，其实可以将Fly从Bird类抽离出来，将Fly实现成一个独立的接口类，和Bird类进行组合。<br>另外既然面向对象的核心是 抽象 和封装，封装可以不言自明，但是抽象是个啥，没有言明，抽象具体到编码里，其实还是需要虚基类和继承语法的。<br>总而言之，本篇基本是术，而缺少道的深度，所以看罢全文，我还是写不出一个“好”的类。<br>当然，缺少设计模式思维才是写好一个类最大的障碍，设计模式大部分都是要基于继承关系的，所以老师提到的少用继承，我想并不是说继承不好，而是别使用很多层次的继承，造成不必要的风险和维护难度吧。","like_count":29,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495219,"discussion_content":"\n1.我的理解，抽象就是“建模”，用类在代码里建立一个现实对象的映射。\n\n2.设计模式更强调对象组合，而不是继承，类模式很少。\n\n3.继承是一种“硬”代码复用，关系比较强，不如组合灵活，我建议少用。当然这还是要建立在对继承等特性有比较深刻认识的基础上。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589601901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2004988,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/97/fc/0ca13c5c.jpg","nickname":"xGdl","note":"","ucode":"5ADD896F62A2B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":272270,"discussion_content":"我觉得在继承这块还是golang更好吧，耦合更低","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590281775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224617,"user_name":"甘俊","can_delete":false,"product_type":"c1","uid":1501325,"ip_address":"","ucode":"A6B9541EC2B1AD","user_header":"https://static001.geekbang.org/account/avatar/00/16/e8/8d/41fb5da7.jpg","comment_is_top":false,"comment_ctime":1591478072,"is_pvip":false,"replies":[{"id":"82685","content":"比如说，有个构造函数A(int x)，那么，A a = 1，这里就会有一个隐式构造。大多数时候这个不是问题，但有的时候会导致意外的转换。<br><br>使用explicit可以禁止隐式转换，防止意外错误，总是显式的构造，更加安全。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591496412,"ip_address":"","comment_id":224617,"utype":1}],"discussion_count":5,"race_medal":1,"score":"83195856696","product_id":100051801,"comment_content":"老师您好，这一段有点没看明白，能举个例子体现explicit的作用么？<br><br>因为 C++ 有隐式构造和隐式转型的规则，如果你的类里有单参数的构造函数，或者是转型操作符函数，为了防止意外的类型转换，保证安全，就要使用“explicit”将这些函数标记为“显式”。","like_count":19,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497542,"discussion_content":"比如说，有个构造函数A(int x)，那么，A a = 1，这里就会有一个隐式构造。大多数时候这个不是问题，但有的时候会导致意外的转换。\n\n使用explicit可以禁止隐式转换，防止意外错误，总是显式的构造，更加安全。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591496412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376079,"discussion_content":"一般单参构造才会有加explicit的必要，一味都加就有点画蛇添足、语法噪音的感觉了。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1621950854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2706400,"avatar":"https://static001.geekbang.org/account/avatar/00/29/4b/e0/0fa53fed.jpg","nickname":"木须柄","note":"","ucode":"54E4CB194B693F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400603,"discussion_content":"关于 explict 对单参构造函数的用处\n假设有个 Time 类如下\nclass Time {\npublic:\n    Time(int s) :  hour(0), min(0), sec(s);\n    int hour;\n    int min;\n    int sec;\n}\n可以看到此时有个单参的传入整型的构造函数\n\n再随便定义一个传入 Time 类的函数\nvoid func(Time a) {\n    return;\n}\n\n如果不用 explict 禁用隐式转换，则以下代码则会让人很困惑\nint a = 10\nTime t = a;  // 隐式转换的数值拷贝\nfunc(a)        // 函数参数传入的隐式转换","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1633346436,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133195,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/ibpASCYk5eF1lAEbJ3TSI0fuMtiaVDb7dNuBZDRPL6QjEict8Wrb8iax2OibbEBxSs4bicCYf3yMEkGmXB2b2UVypaIg/132","nickname":"woo","note":"","ucode":"3076FEA9A60DBC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353055,"discussion_content":"那是不是在构造函数的时候都加上explicit也没有什么问题？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614976752,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1286781,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a2/7d/674f97cc.jpg","nickname":"EastWind","note":"","ucode":"24AD259AFB6A9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1133195,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/ibpASCYk5eF1lAEbJ3TSI0fuMtiaVDb7dNuBZDRPL6QjEict8Wrb8iax2OibbEBxSs4bicCYf3yMEkGmXB2b2UVypaIg/132","nickname":"woo","note":"","ucode":"3076FEA9A60DBC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542211,"discussion_content":"一般来说单参才有这种转换。多参是需要显示调用的构造传参的。全加有点烂用了。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1640683820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":353055,"ip_address":""},"score":542211,"extra":""}]}]},{"had_liked":false,"id":217692,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1053390,"ip_address":"","ucode":"ABB3F1A63E102A","user_header":"https://static001.geekbang.org/account/avatar/00/10/12/ce/a8c8b5e8.jpg","comment_is_top":false,"comment_ctime":1589591264,"is_pvip":false,"replies":[{"id":"80518","content":"因为C++继承C，而C这么做是有历史原因的，当时的计算机性能弱内存小，头和实现分离才方便处理。<br><br>现在的计算机性能大幅度提升，所以这种方式也就没有太多必要了，我建议尽量用hpp的方式，和其他语言保持一致。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589601387,"ip_address":"","comment_id":217692,"utype":1}],"discussion_count":9,"race_medal":0,"score":"66014100704","product_id":100051801,"comment_content":"老师讲的很实用，读完很有收获，赞。小贴士里面提到的5，耳目一新，确实很有道理，其他语言如Java、C#、Python的源码文件都是一种类型，只有咱们c++是头文件和实现文件。曾经有Java同事跟我闲聊，你们C++这个头文件啊，鸡肋，我楞了一下，思考了几秒钟，竟然没有反驳的理由。","like_count":15,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495222,"discussion_content":"因为C++继承C，而C这么做是有历史原因的，当时的计算机性能弱内存小，头和实现分离才方便处理。\n\n现在的计算机性能大幅度提升，所以这种方式也就没有太多必要了，我建议尽量用hpp的方式，和其他语言保持一致。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589601387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268393,"discussion_content":"hpp就相当于是实现文件了，对外提供接口可以再写一个单独的h文件，相当于forward声明。\n","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1589768330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1370959,"avatar":"https://static001.geekbang.org/account/avatar/00/14/eb/4f/6a97b1cd.jpg","nickname":"猪小擎","note":"","ucode":"D9552746AE3327","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581999,"discussion_content":"说h鸡肋是因为他不理解什么叫做编译，什么叫做链接，java，python这样更高级的语言当然也不需要知道这些。\n如果把原来的h和cpp分离的方式都用hpp替换。比如i.h包含大量定义和声明，a.cpp,和b.cpp都包含i.h ,a.cpp和b.cpp的编译是单独进行的，i.h里的保护不会起作用，这个时候对i.h里的函数定义就进行了两次编译，产物为a.o 和 b.o，进行链接时，链接器肯定能解除重复定义的问题，起码是浪费了编译时间，和链接器解决重复定义的时间。template 的cpp文件，他连自己要被怎么用什么样的类型调用都不知道，自然没法单独编译，所有有了hpp，声明和定义都需要在一起。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659111936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2271867,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/E73UicmpgFiaZW4SOTGaxoIk9PWue54neNcfsicz7HOxJUucep4jSMyeMMruLNcIlxsE330qOFMacaEQ9Vz4zXJyg/132","nickname":"Mari","note":"","ucode":"5260C80C8B6AD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547930,"discussion_content":".h 和 .hpp 有什么区别？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642941725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2875594,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/e0/ca/adfaa551.jpg","nickname":"孙新","note":"","ucode":"A80038A479B943","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544326,"discussion_content":"可能是用惯了头文件，如果想一目了然这个类有什么，头文件还确实比hpp方便一些，hpp还得折叠去找，特别在linux下，一大片，这里有啥都不知道。或者说还得借用一些工具。比较麻烦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641470259,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2004988,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/97/fc/0ca13c5c.jpg","nickname":"xGdl","note":"","ucode":"5ADD896F62A2B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":272269,"discussion_content":"hpp可以实现模板，其次hpp可以延迟定义，在相互引用的环境下还是挺有用的叭","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590281706,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1061517,"avatar":"https://static001.geekbang.org/account/avatar/00/10/32/8d/91cd624b.jpg","nickname":"幻境之桥","note":"","ucode":"F9F4DD94CB554E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267894,"discussion_content":"一个 hpp 确实是方便很多，不过这样怎么处理对外提供 sdk 的情况呢，很多时候只会提供头文件和动静态库的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589706396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1286781,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a2/7d/674f97cc.jpg","nickname":"EastWind","note":"","ucode":"24AD259AFB6A9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1061517,"avatar":"https://static001.geekbang.org/account/avatar/00/10/32/8d/91cd624b.jpg","nickname":"幻境之桥","note":"","ucode":"F9F4DD94CB554E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542209,"discussion_content":"纯开源项目和公司内部项目没必要，闭源项目，又需要提供给第三方调用才需要分开头文件，隐藏实现文件。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1640683406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":267894,"ip_address":""},"score":542209,"extra":""}]},{"author":{"id":1911734,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJ3JolohrbOzj79fviaD1O3ibMKhFFhiaH2DqgwWy0IK6PpZ3Gjgib8xiaJcypVpXAnNKvRuX7lg5vibEg/132","nickname":"Geek_bc5665","note":"","ucode":"A7D378323A80D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267778,"discussion_content":"hpp的方式是什么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589686797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240417,"user_name":"_smile滴水C","can_delete":false,"product_type":"c1","uid":1151967,"ip_address":"","ucode":"DA7474D8931C62","user_header":"https://static001.geekbang.org/account/avatar/00/11/93/df/5500fc5b.jpg","comment_is_top":false,"comment_ctime":1596896140,"is_pvip":false,"replies":[{"id":"88821","content":"头文件会被多个源文件包含，所以在头文件里声明变量就会导致变量被定义了多份，导致编译错误。<br><br>但头文件里的类只是定义&#47;声明，并不是实体，所以类的成员变量是没有任务问题的。<br><br>回答的可能不是太准确，有不清楚的地方可以再问。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1597021484,"ip_address":"","comment_id":240417,"utype":1}],"discussion_count":6,"race_medal":0,"score":"40251601804","product_id":100051801,"comment_content":"课程让我醍醐灌顶，请教下老师关于成员变量初始化的问题，记得以前启蒙老师反复强调不要试图在头文件分配内存给变量赋值，至今为止任不明白为何？难道为了include的时候不会有额外内存开销吗？","like_count":9,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503439,"discussion_content":"头文件会被多个源文件包含，所以在头文件里声明变量就会导致变量被定义了多份，导致编译错误。\n\n但头文件里的类只是定义/声明，并不是实体，所以类的成员变量是没有任务问题的。\n\n回答的可能不是太准确，有不清楚的地方可以再问。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597021484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2812489,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/ea/49/bad4f278.jpg","nickname":"暮光","note":"","ucode":"A2E1F64DBCBA6E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":410171,"discussion_content":"追加评论：为啥不采用构造函数初始化列表的形式给成员变量赋值，而是在构造函数体内赋值？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635607699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1286781,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a2/7d/674f97cc.jpg","nickname":"EastWind","note":"","ucode":"24AD259AFB6A9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2812489,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/ea/49/bad4f278.jpg","nickname":"暮光","note":"","ucode":"A2E1F64DBCBA6E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542219,"discussion_content":"两者区别不大。只是有定义未被始化的引用类型成员或常量成员时，必须用初始化列表。构造体内赋值没法解决这2个问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640684928,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":410171,"ip_address":""},"score":542219,"extra":""}]},{"author":{"id":1165201,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7mAt63VrbLZPHpeZxSc4IlBYswQSnaAB5wGePaGFDehgiaNfIxI1SJ5yIHIlmVk8hsw0RaoaSCPA/132","nickname":"Stephen","note":"","ucode":"0D49223E6CB7B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383422,"discussion_content":"类并非实体,在它实例化之前,成员变量的初始化就没有占用内存,可以这样理解吗?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626090372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2747806,"avatar":"","nickname":"Geek_40ec15","note":"","ucode":"A75A9D552002A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1165201,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7mAt63VrbLZPHpeZxSc4IlBYswQSnaAB5wGePaGFDehgiaNfIxI1SJ5yIHIlmVk8hsw0RaoaSCPA/132","nickname":"Stephen","note":"","ucode":"0D49223E6CB7B1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390906,"discussion_content":"在类实例化之前，不存在成员变量的初始化，而仅仅是声明，只有在实例化一个类对象时，才会去做成员变量的初始化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630133907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":383422,"ip_address":""},"score":390906,"extra":""},{"author":{"id":1165201,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7mAt63VrbLZPHpeZxSc4IlBYswQSnaAB5wGePaGFDehgiaNfIxI1SJ5yIHIlmVk8hsw0RaoaSCPA/132","nickname":"Stephen","note":"","ucode":"0D49223E6CB7B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2747806,"avatar":"","nickname":"Geek_40ec15","note":"","ucode":"A75A9D552002A3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391044,"discussion_content":"好的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630243889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":390906,"ip_address":""},"score":391044,"extra":""}]}]},{"had_liked":false,"id":219403,"user_name":"robonix","can_delete":false,"product_type":"c1","uid":1212323,"ip_address":"","ucode":"866EC82EDA455B","user_header":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","comment_is_top":false,"comment_ctime":1590022977,"is_pvip":false,"replies":[{"id":"81041","content":"大概就是这样<br>~~~<br>namespace xxx {<br><br>class inner_class {...};<br>class big_class {...};<br><br>}<br>~~~","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1590024470,"ip_address":"","comment_id":219403,"utype":1}],"discussion_count":3,"race_medal":0,"score":"40244728641","product_id":100051801,"comment_content":"定义一个新的名字空间，把内部类都“提”到外面，降低原来类的耦合度和复杂度。老师，这句话没看懂，能加一个简单的代码示例吗？","like_count":9,"discussions":[{"author":{"id":1286781,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a2/7d/674f97cc.jpg","nickname":"EastWind","note":"","ucode":"24AD259AFB6A9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542215,"discussion_content":"本质就是不要使用内部类，降低耦合。除非内部类非常简单，没有单独设计的意义，其他地方根本不会用到它。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640684060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495800,"discussion_content":"大概就是这样\n~~~\nnamespace xxx {\n\nclass inner_class {...};\nclass big_class {...};\n\n}\n~~~","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590024470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1055296,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/40/f10493ef.jpg","nickname":"中山浪子","note":"","ucode":"25D0F8462473D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291751,"discussion_content":"其实意思就是不要使用嵌套类，尽量分离出来，单独放到一个独立的namespace里，降低耦合","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594946494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217756,"user_name":"軟件賺硬幣","can_delete":false,"product_type":"c1","uid":1736543,"ip_address":"","ucode":"0BB619B53A3046","user_header":"https://static001.geekbang.org/account/avatar/00/1a/7f/5f/1d82812f.jpg","comment_is_top":false,"comment_ctime":1589603725,"is_pvip":false,"replies":[{"id":"80530","content":"现实中有很多深层次继承的例子，但不是说这就是好的，实际上iostream就被很多人批评过。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589610471,"ip_address":"","comment_id":217756,"utype":1}],"discussion_count":3,"race_medal":0,"score":"35949342093","product_id":100051801,"comment_content":"罗老师，我看标准库和boost库很多继承都超过3层哦。比如iostream里面的，ios_base到ios，再到istream，再到iostream（同时继承ostream），再到fstream。用了三四层继承和虚继承（多重继承）","like_count":8,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495253,"discussion_content":"现实中有很多深层次继承的例子，但不是说这就是好的，实际上iostream就被很多人批评过。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589610471,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2016358,"avatar":"","nickname":"MaxXu","note":"","ucode":"8E8684E11E2705","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281293,"discussion_content":"iostream 继承链好像是标准库中唯一一个涉及多重继承的继承链，而且多重继承关系会大大降低各方面的效率（包括时间、空间），对于效率问题，且不说多继承，即使单继承的继承链的深度也会逐渐加重程序的效率，因为构造每个派生类都是要先构造其直接基类，且不说上面的层层间接基类；析构也是一个道理。而我们知道在OOP 编程中，构造和析构成本是影响程序效率的一个很重要因素。所以，罗老师说得不无道理，但无可反驳，单继承、多继承也是OOP实际应用的一个无可避免的常用特性。综上所述，继承的特性是面向对象的一个无可反驳的重要特性，我觉得还是要根据实际情况来应用，而且这是建立在知其然的前提上。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1591706468,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2875594,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/e0/ca/adfaa551.jpg","nickname":"孙新","note":"","ucode":"A80038A479B943","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544327,"discussion_content":"我看有人说，批评boost的人实际是没看懂boost。我看boost是费劲，那漫天的模板。还有cpprest代码也同样风格。nginx感觉就不那么生涩了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641470398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217728,"user_name":"Eglinux","can_delete":false,"product_type":"c1","uid":1187353,"ip_address":"","ucode":"4AAB9940789442","user_header":"https://static001.geekbang.org/account/avatar/00/12/1e/19/17245c59.jpg","comment_is_top":false,"comment_ctime":1589597510,"is_pvip":false,"replies":[{"id":"80512","content":"是的，但是否内联是由编译器决定的，通常只有小的函数才会内联，大的函数不会内联，因为反而成本高不划算。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589600922,"ip_address":"","comment_id":217728,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35949335878","product_id":100051801,"comment_content":"在 .h 中将类的定义和实现写在一起，这样不是默认所有成员函数都内联了吗？","like_count":8,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495240,"discussion_content":"是的，但是否内联是由编译器决定的，通常只有小的函数才会内联，大的函数不会内联，因为反而成本高不划算。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589600922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217714,"user_name":"嵇斌","can_delete":false,"product_type":"c1","uid":1047812,"ip_address":"","ucode":"C9422C3F8A7B23","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fd/04/89cc31ab.jpg","comment_is_top":false,"comment_ctime":1589595143,"is_pvip":false,"replies":[{"id":"80520","content":"现在C++有很多工具，比如智能指针，可以在外部帮着管理资源，还有对象池模式，集中申请释放。<br><br>所以RAII还是要看情况，当然，如果资源确实是与类强相关，那么就用RAII自己管理。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589601637,"ip_address":"","comment_id":217714,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31654366215","product_id":100051801,"comment_content":"1. 面向对象的首要原则 SRP，单一职责原则。这一点特别赞同。另外就是慎用继承，尽量使用组合去实现。分享一个小故事，之前因为代码要写单元测试，使用到了Google Mock，一开始以为 只有虚类才没被Mock，导致很多完全没有必要使用virtual的类使用了virtual，直到有一天看了文档：https:&#47;&#47;github.com&#47;google&#47;googletest&#47;blob&#47;master&#47;googlemock&#47;docs&#47;cook_book.md#mocking-non-virtual-methods-mockingnonvirtualmethods 恍然大悟。<br><br>2. 类的设计最好遵循RAII，即在构造时完成资源的初始化。但是我觉可能Chrono可能会在后续内存管理的课程中讲这个。","like_count":7,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495231,"discussion_content":"现在C++有很多工具，比如智能指针，可以在外部帮着管理资源，还有对象池模式，集中申请释放。\n\n所以RAII还是要看情况，当然，如果资源确实是与类强相关，那么就用RAII自己管理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589601637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262323,"user_name":"58","can_delete":false,"product_type":"c1","uid":2065350,"ip_address":"","ucode":"8878A128290945","user_header":"","comment_is_top":false,"comment_ctime":1605692584,"is_pvip":false,"replies":[{"id":"95234","content":"别名需要控制使用范围，也就是作用域，不能是全局的，而是限制在类或者函数内部，在一个特定的上下文里它才能发挥作用。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1605750263,"ip_address":"","comment_id":262323,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18785561768","product_id":100051801,"comment_content":"using set_type = std::set; 类似这种真的不建议，如果用多了，反而不容易阅读代码。","like_count":4,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509783,"discussion_content":"别名需要控制使用范围，也就是作用域，不能是全局的，而是限制在类或者函数内部，在一个特定的上下文里它才能发挥作用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605750263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217696,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1589591676,"is_pvip":false,"replies":[{"id":"80517","content":"说的很好。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589601278,"ip_address":"","comment_id":217696,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18769460860","product_id":100051801,"comment_content":"1.cpp中的面向对象是建立在封装，继承和多态上。其中继承和动态多态强相关。很多情况下类的继承应该是is-a，has-a的算是类的组合。<br>2. 好的类个人认为应该可以表意。从设计上需要考虑类的几个构造是否都需要，从继承上考虑是否有作为基类的可能。","like_count":4,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495223,"discussion_content":"说的很好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589601278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225845,"user_name":"怪兽","can_delete":false,"product_type":"c1","uid":1324007,"ip_address":"","ucode":"3342C55CB83B08","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/e7/145be2f9.jpg","comment_is_top":false,"comment_ctime":1591871417,"is_pvip":false,"replies":[{"id":"83204","content":"不要用分离的方式，直接在类定义里写函数体，就像java、C#那样。<br><br>class A<br>{<br>public:<br>    void test()<br>    {....}<br>}<br><br>我个人不是太推荐在现代C++里使用声明和定义分离的方式。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591879818,"ip_address":"","comment_id":225845,"utype":1}],"discussion_count":5,"race_medal":0,"score":"10181806009","product_id":100051801,"comment_content":"老师，有个问题，能否在.h文件中实现成员函数的定义？我这么做后，又在多个cpp文件include该.h文件，编译提示链接错误。如果我真想这么做，有什么办法解决链接错误呢？例如：<br>class Class_name<br>{<br>public:<br>\tvoid test();<br>};<br><br>void Class_name::test()<br>{<br>}","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498015,"discussion_content":"不要用分离的方式，直接在类定义里写函数体，就像java、C#那样。\n\nclass A\n{\npublic:\n    void test()\n    {....}\n}\n\n我个人不是太推荐在现代C++里使用声明和定义分离的方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591879818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2790875,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/kHoDdV15McW26tMCNnU8GSsUib9UWboAjVSe4nop5nPVt7qZNcUicCic3W50uaDHj0ibupXQtpvOUG4YaomBqHicVmg/132","nickname":"KingOfDark","note":"","ucode":"F13D3A1287495B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544606,"discussion_content":"对于大型项目来说，为了加快编译效率，一般还是会采用声明和定义分离的形式吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641602612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327150,"discussion_content":"有现代的编译器和强大的cpu，这些都不是问题，你看其他语言都没有分离，一样挺好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605755123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2063643,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7d/1b/3ba74238.jpg","nickname":"阳光","note":"","ucode":"CB661F655BC0E4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":353077,"discussion_content":"其实这个应该是没有include guard 导致的重定义问题。不是声明和定义分离的问题，当然直接在类内写函数体，会被编译器内联，不会有这样的问题。但是如果是对外暴漏的库或接口。对于别人来说 分离更容易阅读","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1614996073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":327150,"ip_address":""},"score":353077,"extra":""}]},{"author":{"id":1216924,"avatar":"https://static001.geekbang.org/account/avatar/00/12/91/9c/3d630e3a.jpg","nickname":"萌萌岛主","note":"","ucode":"B749FBB922E396","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302787,"discussion_content":"这个不太好吧，我想引用这个类，会把这个类里面使用的hpp都包含进来，会影响编译效率的。还是用分离的方式把","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599030921,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220664,"user_name":"Eason Tai","can_delete":false,"product_type":"c1","uid":1200676,"ip_address":"","ucode":"4707577CC9C9E9","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/24/bd63c4de.jpg","comment_is_top":false,"comment_ctime":1590306125,"is_pvip":false,"replies":[{"id":"81421","content":"是的，这大概是借鉴了一点java吧，用public、private来分组不同的逻辑段落，增强可读性。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1590327984,"ip_address":"","comment_id":220664,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10180240717","product_id":100051801,"comment_content":"有个小问题，为什么要在一些类里面多次书写 public 和 private 关键字呢？是增加可读性或者强调什么嘛？","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496206,"discussion_content":"是的，这大概是借鉴了一点java吧，用public、private来分组不同的逻辑段落，增强可读性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590327984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218822,"user_name":"EncodedStar","can_delete":false,"product_type":"c1","uid":1504234,"ip_address":"","ucode":"03958CA7DDD6AE","user_header":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","comment_is_top":false,"comment_ctime":1589880575,"is_pvip":false,"replies":[{"id":"80898","content":"说的很好，赞！","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589927130,"ip_address":"","comment_id":218822,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10179815167","product_id":100051801,"comment_content":"C++之所以难，就是因为限制他的比较少，没有很多条条框框，可以任意的发挥。于是各种人写出的代码各不同。随着时代发展，代码逐渐工程化，大家都需要分工合作不互相影响，就开始提倡一些设计模式，和规范代码编程。像大家提到的单例模式，“多用组合少用继承”，都是老师说到的“好”的类表现。C++11 新添加很多功能也是为了让代码更加可读可维护提供方法，这样的方法自然会得到热爱C++同学的赞同","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495587,"discussion_content":"说的很好，赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589927130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218716,"user_name":"中年男子","can_delete":false,"product_type":"c1","uid":1039204,"ip_address":"","ucode":"027C86B3370150","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","comment_is_top":false,"comment_ctime":1589858291,"is_pvip":true,"replies":[{"id":"80822","content":"<br>1.嵌套类我建议少用，不要过度用，必要的时候也是可以用的。但这种情况是不是再考虑重新设计一下。<br><br>2.hpp也是头文件，不要用using namespace和全局变量，它应该是一个“纯类”。<br><br>3.可以参考一下boost，它里面都是hpp。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589860178,"ip_address":"","comment_id":218716,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10179792883","product_id":100051801,"comment_content":"看到您说嵌套类可以提出来用名字空间解决，这么说就是完全不使用嵌套类了？<br>前段时间我写过一个private嵌套类，目的是不想被别人看见并使用。这种情况虽然也能用名字空间解决，但感觉不如private 来的直接，还请解惑。<br><br>另外一个问题就是 hpp， hpp的优点用更少的文件来传达意图，用起来也简便，<br>不考虑动态库， hpp其实也有不少缺点，需要注意很多细节，比如 redefine、名字空间污染、全局变量， 老师有考虑写一篇加餐来总结一下如何更好的使用的hpp文件吗？","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495552,"discussion_content":"\n1.嵌套类我建议少用，不要过度用，必要的时候也是可以用的。但这种情况是不是再考虑重新设计一下。\n\n2.hpp也是头文件，不要用using namespace和全局变量，它应该是一个“纯类”。\n\n3.可以参考一下boost，它里面都是hpp。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589860178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218259,"user_name":"java2c++","can_delete":false,"product_type":"c1","uid":1460660,"ip_address":"","ucode":"C4F8C3D7B1A910","user_header":"","comment_is_top":false,"comment_ctime":1589766430,"is_pvip":false,"replies":[{"id":"80716","content":"这个要看怎么用了。<br><br>我说的是在类内部定义别名，控制别名的作用域，如果在外部定义别名就是另外一回事了。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589770681,"ip_address":"","comment_id":218259,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10179701022","product_id":100051801,"comment_content":"老师好，这一点我不太赞同“使用 using 或 typedef 可以为类型起别名，既能够简化代码，还能够适应将来的变化。” 类型别名看似简化代码，实际上增加了阅读代码的难度，最近看公司c++老系统里一个系统里同一个类搞出好几个别名，太影响阅读效率了<br>","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495409,"discussion_content":"这个要看怎么用了。\n\n我说的是在类内部定义别名，控制别名的作用域，如果在外部定义别名就是另外一回事了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589770681,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2788228,"avatar":"","nickname":"Geek_7a7173","note":"","ucode":"B061B0D48F3FCC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411670,"discussion_content":"linux内核规范里面就严禁使用typedef来命别名，这样会导致丢失信息","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635970902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1994848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/TXAUcbHlPbyEibtUB2STNgmOb6oQdO8nKuA9nnhuI76Ccv2U5Vgxfp8YxvGeKQP8k47ULBwVGglH4DibOzH8Qfeg/132","nickname":"IAmLinGe","note":"","ucode":"9DCDA0FA5CF2B0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286518,"discussion_content":"在类的内部起别名还是比较常见且实用的，可以看看C++ primer plus，书中代码实例就有这种用法，可以看代码复用那一章。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593199686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218094,"user_name":"被讨厌的勇气","can_delete":false,"product_type":"c1","uid":1547913,"ip_address":"","ucode":"AE3B3CA27D91A2","user_header":"https://static001.geekbang.org/account/avatar/00/17/9e/89/6e9c05d6.jpg","comment_is_top":false,"comment_ctime":1589713210,"is_pvip":false,"replies":[{"id":"80657","content":"我觉得在现在主流的cpu上，差异应该不大。可以看一下标准库，全是头文件，可见标准委员会对这个也是有信心的。<br><br>如果还是不放心，可以做一下测试，但可能只有超大项目才能测试出差异来。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589717474,"ip_address":"","comment_id":218094,"utype":1}],"discussion_count":4,"race_medal":0,"score":"10179647802","product_id":100051801,"comment_content":"将声明与实现放在同一个.hpp文件中，会不会降低编译速度？仅include声明，和include声明和实现对编译速度有什么影响？","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495351,"discussion_content":"我觉得在现在主流的cpu上，差异应该不大。可以看一下标准库，全是头文件，可见标准委员会对这个也是有信心的。\n\n如果还是不放心，可以做一下测试，但可能只有超大项目才能测试出差异来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589717474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1526601,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4b/49/bbaefe0b.jpg","nickname":"混合栈","note":"","ucode":"2C24B213D8C92A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281649,"discussion_content":"to 作者，标准库把实现写在头文件里是因为标准库是模板实现，模板需要在编译期展开，必须暴露出来给使用方，所以必须在头文件里。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1591784196,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327151,"discussion_content":"现在也有很多纯header的C++库，用起来方便是这种方式的关注点。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605755186,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1165201,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7mAt63VrbLZPHpeZxSc4IlBYswQSnaAB5wGePaGFDehgiaNfIxI1SJ5yIHIlmVk8hsw0RaoaSCPA/132","nickname":"Stephen","note":"","ucode":"0D49223E6CB7B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383420,"discussion_content":"是的,在包含模板时,需要包含模板的实现文件,这一点和普通的函数不同.不过不知道为何这样设计.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626089857,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217721,"user_name":"Confidant.","can_delete":false,"product_type":"c1","uid":1660039,"ip_address":"","ucode":"6E137F863906B0","user_header":"https://static001.geekbang.org/account/avatar/00/19/54/87/3b1f9de4.jpg","comment_is_top":false,"comment_ctime":1589596699,"is_pvip":false,"replies":[{"id":"80514","content":"用virtual就要用跟它相关的一大堆特性了，属于比较“纯”的面向对象。<br><br>但在现代C++里，可以用泛型来达到类似的效果，而且性能更高。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589601084,"ip_address":"","comment_id":217721,"utype":1}],"discussion_count":4,"race_medal":0,"score":"10179531291","product_id":100051801,"comment_content":"我正在学习设计模式里面的思想，刚觉得virtul帮我们设计类省了很多事情，纯虚基类还是很有必要的，这样可以在二进制层面复用代码，把链接推迟到运行时期，避免了我们在修改代码的时候，牵一发而动全身","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495235,"discussion_content":"用virtual就要用跟它相关的一大堆特性了，属于比较“纯”的面向对象。\n\n但在现代C++里，可以用泛型来达到类似的效果，而且性能更高。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589601084,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1512537,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/aFAYPyw7ywC1xE9h1qibnTBwtWn2ClJqlicy5cMomhZVaruMyqSq76wMkS279mUaGhrLGwWo9ZnW0WCWfmMovlXw/132","nickname":"木瓜777","note":"","ucode":"FC52A499AF6374","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268270,"discussion_content":"范型对编码能力要求比较高吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589758965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1039197,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/5d/a09da7d5.jpg","nickname":"高鹏gaopeng","note":"","ucode":"64281052E4C288","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267430,"discussion_content":"那泛型如何实现依赖倒置呢， 是定义一interface, 具体实现使用泛型达到目的？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589640316,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1286781,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a2/7d/674f97cc.jpg","nickname":"EastWind","note":"","ucode":"24AD259AFB6A9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542226,"discussion_content":"virtual就类似java里的接口定义，java就推荐用接口。c++模板属于编译阶段的特性，性能好但编程更复杂。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640685614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217688,"user_name":"阿鼎","can_delete":false,"product_type":"c1","uid":1042634,"ip_address":"","ucode":"EE763513563F50","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e8/ca/2a7cc193.jpg","comment_is_top":false,"comment_ctime":1589589303,"is_pvip":false,"replies":[{"id":"80519","content":"对，有的时候用function会比虚函数、抽象类更灵活，这就是对象组合，也是策略模式。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589601432,"ip_address":"","comment_id":217688,"utype":1}],"discussion_count":4,"race_medal":0,"score":"10179523895","product_id":100051801,"comment_content":"我的体会，设计模式，是为了应对变化，大量使用继承，绕来绕去，不如直接把可能变化的地方，用funtion&amp;bind来的直接。","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495220,"discussion_content":"对，有的时候用function会比虚函数、抽象类更灵活，这就是对象组合，也是策略模式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589601432,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268395,"discussion_content":"std::move是赋值的时候转移所有权用的，单纯调用没意义\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589768427,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1990935,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJe382cSgjJjM6icHquQ4jUtHrBGDibYhLjIMNUYiapKMHMlMgoyWI9OzkpibRqmNeO5pAiaOqycCzyUvQ/132","nickname":"Geek_094d56","note":"","ucode":"D4F27A39B3011C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267722,"discussion_content":"罗老师 ：  vector<int> data; std::move(data),这个move对data好像没什么作用，不知道怎么理解这个std::move的作用，谢谢 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589680793,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1039204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","nickname":"中年男子","note":"","ucode":"027C86B3370150","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1990935,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJe382cSgjJjM6icHquQ4jUtHrBGDibYhLjIMNUYiapKMHMlMgoyWI9OzkpibRqmNeO5pAiaOqycCzyUvQ/132","nickname":"Geek_094d56","note":"","ucode":"D4F27A39B3011C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269025,"discussion_content":"std::move 是转义所有权，move 并不是真的move，而是转化成右值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589857847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":267722,"ip_address":""},"score":269025,"extra":""}]}]},{"had_liked":false,"id":245304,"user_name":"宇天飞","can_delete":false,"product_type":"c1","uid":1126444,"ip_address":"","ucode":"3FB37D1E2DAA61","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/2c/06375913.jpg","comment_is_top":false,"comment_ctime":1598888785,"is_pvip":true,"replies":[{"id":"90216","content":"面向对象的话题很大，课下作业只是提出了一个思考的方向，目的是不要埋头编码，多思考一下代码之上的东西。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1598921875,"ip_address":"","comment_id":245304,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5893856081","product_id":100051801,"comment_content":"你对“面向对象编程”有哪些认识，是否赞同这节课的观点？（希望你大胆地说出来，如果意见有分歧，那也很正常，我们一起讨论。）<br>1、挺有意思的观点，特别是不建议对继承和多态的使用。“抽象”和“封装”是重点。而用组合来替代。<br>2、应用设计模式、重构等知识，把大类拆分成多个各负其责的小类。这个点让我对设计模式和重构有了进一步理解。<br><br>你觉得应用这节课讲到的准则和技巧能否写出一个“好”的类，还缺什么吗？<br>可以","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504841,"discussion_content":"面向对象的话题很大，课下作业只是提出了一个思考的方向，目的是不要埋头编码，多思考一下代码之上的东西。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598921875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":243527,"user_name":"yuchen","can_delete":false,"product_type":"c1","uid":1605025,"ip_address":"","ucode":"D4B55B57D218CB","user_header":"https://static001.geekbang.org/account/avatar/00/18/7d/a1/46c5293c.jpg","comment_is_top":false,"comment_ctime":1598170056,"is_pvip":false,"replies":[{"id":"89733","content":"就是让类都成为名字空间里的“全局类”，而不要使用“类中类”“嵌套类”，这样类结构更清晰，利于复用和重构。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1598183258,"ip_address":"","comment_id":243527,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5893137352","product_id":100051801,"comment_content":"您好！“定义一个新的名字空间，把内部类都“提”到外面，降低原来类的耦合度和复杂度”，这个能具体说说吗？","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504316,"discussion_content":"就是让类都成为名字空间里的“全局类”，而不要使用“类中类”“嵌套类”，这样类结构更清晰，利于复用和重构。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598183258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235215,"user_name":"中山浪子","can_delete":false,"product_type":"c1","uid":1055296,"ip_address":"","ucode":"25D0F8462473D3","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/40/f10493ef.jpg","comment_is_top":false,"comment_ctime":1594946188,"is_pvip":false,"replies":[{"id":"86838","content":"当然不会了，这就相当于一个普通的函数调用，都是在这一个对象身上完成的，标准委员会不可能没有考虑过这点，你放心。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1594946987,"ip_address":"","comment_id":235215,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5889913484","product_id":100051801,"comment_content":"老师，委托构造的时候，对象obj初始化时候调用构造函数A，然后委托给构造函数B去初始化，这个过程会不会多产生一个obj的临时对象？","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501642,"discussion_content":"当然不会了，这就相当于一个普通的函数调用，都是在这一个对象身上完成的，标准委员会不可能没有考虑过这点，你放心。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594946987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230551,"user_name":"Simon","can_delete":false,"product_type":"c1","uid":1914504,"ip_address":"","ucode":"A8A2E3E57BD029","user_header":"https://static001.geekbang.org/account/avatar/00/1d/36/88/20b6a6ee.jpg","comment_is_top":false,"comment_ctime":1593415793,"is_pvip":true,"replies":[{"id":"85091","content":"因为它就是类自己，所以可以在类作用域里完全等价替代，比如用在委托构造函数、内部子类型、模板类型再定义等。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1593423614,"ip_address":"","comment_id":230551,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5888383089","product_id":100051801,"comment_content":"类内别名：this_type，这个会用在什么时机？","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499933,"discussion_content":"因为它就是类自己，所以可以在类作用域里完全等价替代，比如用在委托构造函数、内部子类型、模板类型再定义等。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593423614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224550,"user_name":"屈肖东","can_delete":false,"product_type":"c1","uid":1995346,"ip_address":"","ucode":"A6E2250A3CFEA5","user_header":"https://static001.geekbang.org/account/avatar/00/1e/72/52/8e81daf1.jpg","comment_is_top":false,"comment_ctime":1591439375,"is_pvip":false,"replies":[{"id":"82663","content":"在类里面定义自己的类型别名还是有很多好处的，让别名局部化，更有意义。<br><br>而且在定义成员变量的时候，是不能用auto的，类型别名可以简化代码，减少重复提高可读性。<br><br>可以参考一下课程里的代码，再和不用别名的形式对比一下。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591446448,"ip_address":"","comment_id":224550,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5886406671","product_id":100051801,"comment_content":"在类型别名里，感觉都很鸡肋，正常的名称大家普遍更能够接受，非要起一个别名，反而可能会影响代码的可读性。而且c++11本来就支持使用auto，感觉起别名大多数时候都没什么意义","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497520,"discussion_content":"在类里面定义自己的类型别名还是有很多好处的，让别名局部化，更有意义。\n\n而且在定义成员变量的时候，是不能用auto的，类型别名可以简化代码，减少重复提高可读性。\n\n可以参考一下课程里的代码，再和不用别名的形式对比一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591446448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223640,"user_name":"陈英桂","can_delete":false,"product_type":"c1","uid":1100348,"ip_address":"","ucode":"06E8DEE42DA82E","user_header":"https://static001.geekbang.org/account/avatar/00/10/ca/3c/f6e7ebf1.jpg","comment_is_top":false,"comment_ctime":1591147095,"is_pvip":false,"replies":[{"id":"82371","content":"动态库可以单独提供一个forward声明的头文件，不包含实现。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591152769,"ip_address":"","comment_id":223640,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5886114391","product_id":100051801,"comment_content":"在 .h 中将类的定义和实现写在一起，这样子如果做成动态库，那不是没有隐藏细节？头文件里的类的定义只是说明这类的格式","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497195,"discussion_content":"动态库可以单独提供一个forward声明的头文件，不包含实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591152769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223226,"user_name":"怪兽","can_delete":false,"product_type":"c1","uid":1324007,"ip_address":"","ucode":"3342C55CB83B08","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/e7/145be2f9.jpg","comment_is_top":false,"comment_ctime":1591023759,"is_pvip":false,"replies":[{"id":"82263","content":"好像c++20是这样的。<br><br>但这些太底层、细节了，我觉得这样容易弄混的特性还是少用慎用。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591059803,"ip_address":"","comment_id":223226,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5885991055","product_id":100051801,"comment_content":"老师，我有个疑惑，C++2.0开始，我记得构造函数不管是单参数还是多参数，只要不加explicit修饰都会隐式转换的吧？例如：<br>class DemoInit final <br>{<br>public:<br>\tDemoInit(int a, int b)<br>\t{\t}<br>};<br><br>auto g_lmd = [](const DemoInit&amp; demo) {};<br>g_lmd({ 1, 2 });","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497064,"discussion_content":"好像c++20是这样的。\n\n但这些太底层、细节了，我觉得这样容易弄混的特性还是少用慎用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591059803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221816,"user_name":"Geek_54b85f","can_delete":false,"product_type":"c1","uid":2001149,"ip_address":"","ucode":"FF58D9E43A620B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIAr4sRyiaCCLSyLU8BDcaibRFIHja96mrNhxK6BSsbXIC3QXMQmtTj6Wvc5xw1BwgvdMDdRLLiaPX5w/132","comment_is_top":false,"comment_ctime":1590595306,"is_pvip":false,"replies":[{"id":"81772","content":"这个话题比较大，一下子说不清。<br><br>我觉得，首先要深刻理解设计模式，改继承为组合。然后，就可以利用泛型&#47;模板了，把类型“参数化”。<br><br>可惜的是关于泛型编程没有经典书籍和指导原则，只能自己在实际中多摸索，看标准库和好的开源项目是一个比较不错的办法，借鉴它们的成功经验。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1590617175,"ip_address":"","comment_id":221816,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5885562602","product_id":100051801,"comment_content":"之前是从写java临时转到C++开发的，面向对象和抽象类的概念一直深入人心，导致项目里大量用了纯虚类和虚函数，现在也觉得过于冗余厚重，老师能否将讲下如何用模版和组合的方式改造这种陈旧的设计呢？谢谢！","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496580,"discussion_content":"这个话题比较大，一下子说不清。\n\n我觉得，首先要深刻理解设计模式，改继承为组合。然后，就可以利用泛型/模板了，把类型“参数化”。\n\n可惜的是关于泛型编程没有经典书籍和指导原则，只能自己在实际中多摸索，看标准库和好的开源项目是一个比较不错的办法，借鉴它们的成功经验。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590617175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220201,"user_name":"Raysuner","can_delete":false,"product_type":"c1","uid":1958141,"ip_address":"","ucode":"96A1E5216793EC","user_header":"https://static001.geekbang.org/account/avatar/00/1d/e0/fd/096bf697.jpg","comment_is_top":false,"comment_ctime":1590202915,"is_pvip":false,"replies":[{"id":"81296","content":"学习C++，还有任何编程语言，都要有适当的实践，不然就只是“花架子”。<br><br>可以看一些开源项目，从中领会这些设计原则。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1590214252,"ip_address":"","comment_id":220201,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5885170211","product_id":100051801,"comment_content":"本菜鸟表示老师讲的很好，但我还是没有什么具体的思路能写出好的类。老师的方法经过提炼总结，对经验丰富的人员应该比较有帮助，但我还比较缺乏经验，显得有些笼统，希望老师以后能谈谈到底怎么用这个术，什么情况下用这个术","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496081,"discussion_content":"学习C++，还有任何编程语言，都要有适当的实践，不然就只是“花架子”。\n\n可以看一些开源项目，从中领会这些设计原则。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590214252,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220068,"user_name":"sugar","can_delete":false,"product_type":"c1","uid":1167046,"ip_address":"","ucode":"454538FF253B5F","user_header":"https://static001.geekbang.org/account/avatar/00/11/ce/c6/958212b5.jpg","comment_is_top":false,"comment_ctime":1590147153,"is_pvip":false,"replies":[{"id":"81216","content":"实话实说，这些都是C++“玩剩下的”。<br><br>原因就是多重继承还有普通的继承太重，所以用接口继承就很轻。<br><br>接口继承算是面向对象的典型用法了，在Java、Go这样的“纯”面向对象语言里也是唯一的解法（很多年前的认识，现在也许不一样），但C++还可以用泛型，所以更灵活。<br><br>喜欢Java、Go在C++里这么用当然没问题，但也应该再看看泛型编程、函数式编程，可能会“柳暗花明”。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1590150581,"ip_address":"","comment_id":220068,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5885114449","product_id":100051801,"comment_content":"老师讲的都是干货，先赞一个。这些东西能感觉到是老师的实际经验得来，我在书上是学不到的。 想问下，老师能否也谈谈其他编程语言里在oop方面推出的interface，这个东西似乎比class继承要轻和低耦，golang甚至直接干掉了继承 只允许借口实现，老师能谈谈看法吗","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496035,"discussion_content":"实话实说，这些都是C++“玩剩下的”。\n\n原因就是多重继承还有普通的继承太重，所以用接口继承就很轻。\n\n接口继承算是面向对象的典型用法了，在Java、Go这样的“纯”面向对象语言里也是唯一的解法（很多年前的认识，现在也许不一样），但C++还可以用泛型，所以更灵活。\n\n喜欢Java、Go在C++里这么用当然没问题，但也应该再看看泛型编程、函数式编程，可能会“柳暗花明”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590150581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219475,"user_name":"Tintin","can_delete":false,"product_type":"c1","uid":1230604,"ip_address":"","ucode":"53936A3C6A6D20","user_header":"https://static001.geekbang.org/account/avatar/00/12/c7/0c/8e7f1a85.jpg","comment_is_top":false,"comment_ctime":1590029447,"is_pvip":false,"replies":[{"id":"81066","content":"目前C++主要做系统编程，比较偏底层，不像做应用那么范围广。可以去招聘网站上看看，C++职位都有哪些，再决定是否转。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1590037182,"ip_address":"","comment_id":219475,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5884996743","product_id":100051801,"comment_content":"另外想请教老师，想转行做C++的话，主要可以做哪些方面的事情呢？","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495821,"discussion_content":"目前C++主要做系统编程，比较偏底层，不像做应用那么范围广。可以去招聘网站上看看，C++职位都有哪些，再决定是否转。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590037182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219473,"user_name":"Tintin","can_delete":false,"product_type":"c1","uid":1230604,"ip_address":"","ucode":"53936A3C6A6D20","user_header":"https://static001.geekbang.org/account/avatar/00/12/c7/0c/8e7f1a85.jpg","comment_is_top":false,"comment_ctime":1590029393,"is_pvip":false,"replies":[{"id":"81067","content":"是的，这个模板类的技术限制。<br><br>但hpp不一定非要是模板类，任何类都可以，我觉得可以更好地组织源码，项目更干净。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1590037248,"ip_address":"","comment_id":219473,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5884996689","product_id":100051801,"comment_content":"标准库都放在.hpp里面我理解是不是因为大部分都是模版类的原因？","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495820,"discussion_content":"是的，这个模板类的技术限制。\n\n但hpp不一定非要是模板类，任何类都可以，我觉得可以更好地组织源码，项目更干净。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590037248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217722,"user_name":"亮","can_delete":false,"product_type":"c1","uid":1244779,"ip_address":"","ucode":"8D97C79DF7D7F1","user_header":"https://static001.geekbang.org/account/avatar/00/12/fe/6b/81b2e40a.jpg","comment_is_top":false,"comment_ctime":1589596762,"is_pvip":false,"replies":[{"id":"80513","content":"直接用struct，和class一样。<br><br>我的是意思是不要再用C的typedef方法来定义结构体的别名了，没有必要。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589600970,"ip_address":"","comment_id":217722,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5884564058","product_id":100051801,"comment_content":"课外小贴士的2应该怎么来定义结构体更好？","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495236,"discussion_content":"直接用struct，和class一样。\n\n我的是意思是不要再用C的typedef方法来定义结构体的别名了，没有必要。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589600970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271512,"discussion_content":"C语言里struct是二等公民，必须要用“struct xxx”，比较麻烦，所以用typedef来简化。\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1590150884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1175570,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f0/12/89b7c95a.jpg","nickname":"卡皮","note":"","ucode":"20A8D19DD91AE7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269564,"discussion_content":"这个也是没想明白的，为什么定义的时候给它两个名字","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589910041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359822,"user_name":"ZL","can_delete":false,"product_type":"c1","uid":2903840,"ip_address":"北京","ucode":"AFCE96FE909F46","user_header":"","comment_is_top":false,"comment_ctime":1665934016,"is_pvip":false,"replies":[{"id":"130898","content":"great!","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1665984753,"ip_address":"北京","comment_id":359822,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1665934016","product_id":100051801,"comment_content":"虽然面向对象编程是一种很好的设计思想，但是具体实现起来还是尤为困难，就算C++说是面向对象的三大特征：封装，继承，多态都用上，也不一定能设计出一个好的类。<br>为什么这样说，因为继承就代表了代码有依赖，有从属关系，违背了低耦合这一特征。<br>个人实现原则:<br>尽量少用继承和虚函数。<br>控制继承的层次。<br>接口设计要短小精悍，只负责单一功能。<br>定义一个新的名字空间，把内部类都提到外面，降低原来类的耦合度和复杂度。<br>等。。。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590664,"discussion_content":"great!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665984753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":353067,"user_name":"猪小擎","can_delete":false,"product_type":"c1","uid":1370959,"ip_address":"北京","ucode":"D9552746AE3327","user_header":"https://static001.geekbang.org/account/avatar/00/14/eb/4f/6a97b1cd.jpg","comment_is_top":false,"comment_ctime":1659111365,"is_pvip":true,"replies":[{"id":"128428","content":"说的很好。","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1659335758,"ip_address":"北京","comment_id":353067,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1659111365","product_id":100051801,"comment_content":"Rust不是面向对象语言，GO，c都不是。struct interface，trait，不是定义面向对象的标志，class 才是。我不是cpp老手，我感觉hpp是包含template的的才会定义叫hpp，tempalte没法h和cpp文件混合。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582240,"discussion_content":"说的很好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659335758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":349911,"user_name":"痴痴笑笑(Bruce)","can_delete":false,"product_type":"c1","uid":1355659,"ip_address":"","ucode":"569D7B23A91130","user_header":"https://static001.geekbang.org/account/avatar/00/14/af/8b/0a2fdaa4.jpg","comment_is_top":false,"comment_ctime":1656422247,"is_pvip":true,"replies":[{"id":"127359","content":"这个只是个人观点，求同存异。","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1656471833,"ip_address":"","comment_id":349911,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1656422247","product_id":100051801,"comment_content":"继承层次大于3就算过度设计，有点武断了。大型产品里边的hierachy很多是超过三层的","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578015,"discussion_content":"这个只是个人观点，求同存异。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656471833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347693,"user_name":"liy","can_delete":false,"product_type":"c1","uid":1322151,"ip_address":"","ucode":"ACE2C473DBA19F","user_header":"https://static001.geekbang.org/account/avatar/00/14/2c/a7/7f702c49.jpg","comment_is_top":false,"comment_ctime":1654319525,"is_pvip":true,"replies":[{"id":"126768","content":"init是一个普通函数，是初始化对象后再调用。而构造函数是特殊函数，只会在构造的时候调用。","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1654414533,"ip_address":"","comment_id":347693,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1654319525","product_id":100051801,"comment_content":"本章对我最大的收获就是就是对设计模式有了更深的理解，非科班，几年C++，对不少好代码的写法有经验积累但一直没有理论依据，以往对设计模式的理解浮于表面空中楼阁，现在总算是在现实扎根了。<br>求问老师：为什么init()写法比构造函数的写法效率低，都是两层函数调用啊，这个底层知识匮乏所以不理解，请老师指点下","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574865,"discussion_content":"init是一个普通函数，是初始化对象后再调用。而构造函数是特殊函数，只会在构造的时候调用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654414533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343045,"user_name":"娃哈哈","can_delete":false,"product_type":"c1","uid":2981739,"ip_address":"","ucode":"355EADE8479480","user_header":"https://static001.geekbang.org/account/avatar/00/2d/7f/6b/83236a96.jpg","comment_is_top":false,"comment_ctime":1650609034,"is_pvip":false,"replies":[{"id":"125315","content":"一家之言，勿怪。<br><br>而且C++非常自由，风格可以任意选择，可能在Qt里就是强调用继承，那用它工作也只能适应它的风格了。<br><br>如果多看C++标准库，就会发现继承用的非常少，更强调组合。","user_name":"作者回复","user_name_real":"作者","uid":"1181974","ctime":1650678879,"ip_address":"","comment_id":343045,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1650609034","product_id":100051801,"comment_content":"干了小半年Qt继承深入我心，老师说继承只是个附带的，心塞了。。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566407,"discussion_content":"一家之言，勿怪。\n\n而且C++非常自由，风格可以任意选择，可能在Qt里就是强调用继承，那用它工作也只能适应它的风格了。\n\n如果多看C++标准库，就会发现继承用的非常少，更强调组合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650678879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335016,"user_name":"虫二","can_delete":false,"product_type":"c1","uid":2853225,"ip_address":"","ucode":"97F206EC537A11","user_header":"https://static001.geekbang.org/account/avatar/00/2b/89/69/58ca1946.jpg","comment_is_top":false,"comment_ctime":1645256532,"is_pvip":true,"replies":[{"id":"122372","content":"可以用设计模式，比如策略模式、装饰模式等等。","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1645327126,"ip_address":"","comment_id":335016,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1645256532","product_id":100051801,"comment_content":"老师，那既然要减少继承。怎么实现多个类似类，是相似的，但是存在小功能上的不同呢。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552151,"discussion_content":"可以用设计模式，比如策略模式、装饰模式等等。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645327126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322715,"user_name":"Slience-0°C","can_delete":false,"product_type":"c1","uid":1151612,"ip_address":"","ucode":"B50665EC6A80F5","user_header":"https://static001.geekbang.org/account/avatar/00/11/92/7c/12c571b6.jpg","comment_is_top":false,"comment_ctime":1637563709,"is_pvip":false,"replies":[{"id":"117198","content":"目前这样是可以的。<br><br>不过到了C++20，有了模块机制，在cpp里其实也是可以用export导出的。","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1637634594,"ip_address":"","comment_id":322715,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1637563709","product_id":100051801,"comment_content":"如果有些类，不想对外暴露实现，是不是声明和实现都放在cpp文件内部？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532524,"discussion_content":"目前这样是可以的。\n\n不过到了C++20，有了模块机制，在cpp里其实也是可以用export导出的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637634594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322190,"user_name":"没事莫慌冠","can_delete":false,"product_type":"c1","uid":1070095,"ip_address":"","ucode":"D4C3176E16798E","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/0f/fe690e3c.jpg","comment_is_top":false,"comment_ctime":1637226728,"is_pvip":false,"replies":[{"id":"116985","content":"各种编程范式都有各自的优势，不存在互相取代的事情。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1637241733,"ip_address":"","comment_id":322190,"utype":1}],"discussion_count":0,"race_medal":0,"score":"1637226728","product_id":100051801,"comment_content":"之后面向数据的设计会代替面向对象的设计吗？用过ECS后，感觉代码修改和维护起来确实更简单。<br>","like_count":0},{"had_liked":false,"id":319150,"user_name":"Kevin","can_delete":false,"product_type":"c1","uid":2763179,"ip_address":"","ucode":"3588850B3370C8","user_header":"https://static001.geekbang.org/account/avatar/00/2a/29/ab/59a6e437.jpg","comment_is_top":false,"comment_ctime":1635641839,"is_pvip":true,"replies":[{"id":"115706","content":"旧势力太强大，没办法，我也遇到过这样的情形，为了团队协作还是忍忍吧。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1635665673,"ip_address":"","comment_id":319150,"utype":1}],"discussion_count":1,"race_medal":5,"score":"1635641839","product_id":100051801,"comment_content":"老师提供的都是宝贵的实战经验，不过就算只是列出了最少的一个子集，我已经感觉蛮复杂了，C++还真是让人又爱又怕呀。<br><br>最后一点hpp实现整个类，我个人是深有体会并且一直在用的，很喜欢这种一个文件的方式。但是团队里边不认同，拒绝使用这种方式。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529518,"discussion_content":"旧势力太强大，没办法，我也遇到过这样的情形，为了团队协作还是忍忍吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635665673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313585,"user_name":"于小咸","can_delete":false,"product_type":"c1","uid":1640946,"ip_address":"","ucode":"833D5E92016430","user_header":"https://static001.geekbang.org/account/avatar/00/19/09/f2/6ed195f4.jpg","comment_is_top":false,"comment_ctime":1632537723,"is_pvip":false,"replies":[{"id":"113593","content":"不会的，现在C++标准库也都是头文件的形式，我们自己写的那些hpp和标准库根本不是一个量级，所以完全不需要担心。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1632561537,"ip_address":"","comment_id":313585,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1632537723","product_id":100051801,"comment_content":"如果过多使用hpp，会不会导致代码体积变大，编译变慢呢？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527402,"discussion_content":"不会的，现在C++标准库也都是头文件的形式，我们自己写的那些hpp和标准库根本不是一个量级，所以完全不需要担心。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632561537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":302002,"user_name":"Stephen","can_delete":false,"product_type":"c1","uid":1165201,"ip_address":"","ucode":"0D49223E6CB7B1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7mAt63VrbLZPHpeZxSc4IlBYswQSnaAB5wGePaGFDehgiaNfIxI1SJ5yIHIlmVk8hsw0RaoaSCPA/132","comment_is_top":false,"comment_ctime":1626014086,"is_pvip":false,"replies":[{"id":"109277","content":"纯虚函数定义接口，而是不是实现功能，这个是比较传统的面向对象编程手法了。<br><br>在java等语言里这种方式是标准做法，但在C++里可以有其他的替代形式，例如泛型。<br><br>不能说提倡不提倡，只能说是按自己的喜好和习惯吧，不过我个人是不太推荐在现代C++里用纯虚函数的。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1626054092,"ip_address":"","comment_id":302002,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1626014086","product_id":100051801,"comment_content":"老师您好，纯虚函数常用来实现接口的功能，这种用法值得提倡吗？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523149,"discussion_content":"纯虚函数定义接口，而是不是实现功能，这个是比较传统的面向对象编程手法了。\n\n在java等语言里这种方式是标准做法，但在C++里可以有其他的替代形式，例如泛型。\n\n不能说提倡不提倡，只能说是按自己的喜好和习惯吧，不过我个人是不太推荐在现代C++里用纯虚函数的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626054092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1165201,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7mAt63VrbLZPHpeZxSc4IlBYswQSnaAB5wGePaGFDehgiaNfIxI1SJ5yIHIlmVk8hsw0RaoaSCPA/132","nickname":"Stephen","note":"","ucode":"0D49223E6CB7B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383423,"discussion_content":"好的，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626090477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294440,"user_name":"奋斗","can_delete":false,"product_type":"c1","uid":2047392,"ip_address":"","ucode":"C84C2D030ACA51","user_header":"https://static001.geekbang.org/account/avatar/00/1f/3d/a0/acf6b165.jpg","comment_is_top":false,"comment_ctime":1621943481,"is_pvip":false,"replies":[{"id":"106837","content":"是的，不是说层次多就一定不好，但确实带来了可读性差、难以维护的缺点。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1621950679,"ip_address":"","comment_id":294440,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1621943481","product_id":100051801,"comment_content":"看了很多框架，比如陈硕的muduo、蘑菇街开源的teamtalk、sogou开源的workflow都用到很多继承和多态。继承层次越深，看的越懵逼","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520656,"discussion_content":"是的，不是说层次多就一定不好，但确实带来了可读性差、难以维护的缺点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621950679,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281526,"user_name":"企鹅君需要充电","can_delete":false,"product_type":"c1","uid":1858704,"ip_address":"","ucode":"EAD2F1C4A73363","user_header":"","comment_is_top":false,"comment_ctime":1614774536,"is_pvip":false,"replies":[{"id":"102222","content":"<br>1.既然提到设计模式，那就应该知道，GOF就在提倡尽量多用组合少用继承。继承的缺点是很容易被“滥用”，导致难以维护的类体系，而组合可以达到同样的效果，而且更灵活。<br>这方面也可以再参考一下lua、go等其他语言。<br><br>2.说的很对。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1614820776,"ip_address":"","comment_id":281526,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1614774536","product_id":100051801,"comment_content":"1、我觉得“面向对象”的核心是理解“抽象”和“继承&#47;派生”，在学习了一些设计模式知识后，好的设计大多通过恰当的继承关系，简化逻辑还提高可读性，当时让我眼前一亮，对文中让大家尽量不用继承的说法我保持怀疑；<br>2、要写出好的类，最开始就应该学会分析问题需求，例如通过uml图，拆分功能和关系等等，从类和对象实例的名称就能理解主要逻辑","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516430,"discussion_content":"\n1.既然提到设计模式，那就应该知道，GOF就在提倡尽量多用组合少用继承。继承的缺点是很容易被“滥用”，导致难以维护的类体系，而组合可以达到同样的效果，而且更灵活。\n这方面也可以再参考一下lua、go等其他语言。\n\n2.说的很对。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614820776,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1858704,"avatar":"","nickname":"企鹅君需要充电","note":"","ucode":"EAD2F1C4A73363","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352697,"discussion_content":"感谢耐心回复，设计模式刚开始学习理解不深，会继续深入思考\n#似乎没有继续回复作者功能？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614821209,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":276713,"user_name":"程序员班吉","can_delete":false,"product_type":"c1","uid":1478098,"ip_address":"","ucode":"BD48CF7649609A","user_header":"https://static001.geekbang.org/account/avatar/00/16/8d/d2/8a6be8d8.jpg","comment_is_top":false,"comment_ctime":1612086623,"is_pvip":false,"replies":[{"id":"100442","content":"对，多看看其他语言，可以学习它们好的编程范式，再用到C++里。<br><br>C++支持多种编程范式，面向接口在C++里可以有很多实现方式，比如多重继承（但不推荐），我个人觉得面向接口编程其实就是泛型编程的一种使用方式。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1612141666,"ip_address":"","comment_id":276713,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1612086623","product_id":100051801,"comment_content":"老师提到的将过多的继承拆解转而使用组合模式的方法，在go语言里面也是有同样的思想，比如go语言里鼓励使用多个小接口组合复杂的功能。<br>老师没有在课程里提到面向接口编程，不知道老师对面向接口编程是怎么看待的？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514798,"discussion_content":"对，多看看其他语言，可以学习它们好的编程范式，再用到C++里。\n\nC++支持多种编程范式，面向接口在C++里可以有很多实现方式，比如多重继承（但不推荐），我个人觉得面向接口编程其实就是泛型编程的一种使用方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612141666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250708,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1027861,"ip_address":"","ucode":"A5409ACD6C2DB2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/af/15/ff56a8bf.jpg","comment_is_top":false,"comment_ctime":1601199933,"is_pvip":false,"replies":[{"id":"91754","content":"理论上是这样的，但编译器会处理好这个问题，删除冗余，最终只保留一个实现，我们不需要担心。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1601201355,"ip_address":"","comment_id":250708,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1601199933","product_id":100051801,"comment_content":"老师，你好，如果声明和定义都写在一个文件里，会不会导致每个include这个类的其他类在编译时将这个类整个包含过去，这样不就导致这个类编译出了多份，岂不是多了很多冗余？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506267,"discussion_content":"理论上是这样的，但编译器会处理好这个问题，删除冗余，最终只保留一个实现，我们不需要担心。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601201355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237155,"user_name":"prowu","can_delete":false,"product_type":"c1","uid":1000532,"ip_address":"","ucode":"F7866D8DEA0FBB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/54/7e40e592.jpg","comment_is_top":false,"comment_ctime":1595692758,"is_pvip":false,"replies":[{"id":"87663","content":"forward声明的头文件就是没有实现代码的类，相当于完整hpp的简化版，不一定要用pimpl。<br><br>我个人认为pimpl应该是用在cpp里。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1595771981,"ip_address":"","comment_id":237155,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1595692758","product_id":100051801,"comment_content":"看评论中多次提到建议使用hpp, 如果接口就使用forward声明的头文件，这个头文件是怎么定义的？是使用pimpl吗？这样中间在转一层是不是有点多余了？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502318,"discussion_content":"forward声明的头文件就是没有实现代码的类，相当于完整hpp的简化版，不一定要用pimpl。\n\n我个人认为pimpl应该是用在cpp里。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595771981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2831233,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/33/81/3693f4d9.jpg","nickname":"坚定的抢手","note":"","ucode":"E5A5EC6196C518","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570836,"discussion_content":"这个forward声明的头文件是没用的？实际不参与编译吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651934136,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233625,"user_name":"谷鱼","can_delete":false,"product_type":"c1","uid":1004052,"ip_address":"","ucode":"F22DB0C0269829","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/14/397145a4.jpg","comment_is_top":false,"comment_ctime":1594369977,"is_pvip":false,"replies":[{"id":"86223","content":"是的，要用好面向对象不是一件容易的事情。<br><br>Python、php的脚本语言特性，决定了代码编写会比较随意，要写完全的面向对象就比较累。而C++自身对面向对象就有所规范，所以写起来会容易一点。<br><br>继续努力吧，可以再参考后面的设计模式两讲。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1594371721,"ip_address":"","comment_id":233625,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1594369977","product_id":100051801,"comment_content":"面向对象是一种思想，主要考虑抽象和封装，我认同。既然是一种思想，必然有很多规范来执行，才能形成稳定可用的编程代码。<br><br>利用文中说到的一些方法，目前还在学习c++.不过在python php 这种脚本语言来说，构建好的对象的成本还是有点高，不仅仅是需要本身的限制，也是需要很多良好的规范，这些都是思维层次和良好的经验。面向对象，经常用到，但是真的做到完全的好用的，还需要更多的内容。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501112,"discussion_content":"是的，要用好面向对象不是一件容易的事情。\n\nPython、php的脚本语言特性，决定了代码编写会比较随意，要写完全的面向对象就比较累。而C++自身对面向对象就有所规范，所以写起来会容易一点。\n\n继续努力吧，可以再参考后面的设计模式两讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594371721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232823,"user_name":"海漩涡","can_delete":false,"product_type":"c1","uid":1426798,"ip_address":"","ucode":"4963172386B1A7","user_header":"https://static001.geekbang.org/account/avatar/00/15/c5/6e/604ec5d4.jpg","comment_is_top":false,"comment_ctime":1594124313,"is_pvip":false,"replies":[{"id":"85947","content":"我也有同感，但换个角度来看，太“纯粹”的语言也不是什么好事，C++一直追求的是工程上的实用，而不是学术上的纯粹。<br><br>好在C++不会强迫我们做这做那，在里面挑出自己喜欢的就好了。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1594169423,"ip_address":"","comment_id":232823,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1594124313","product_id":100051801,"comment_content":"c++的这些特性很繁琐，感觉污染了这个语言","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500779,"discussion_content":"我也有同感，但换个角度来看，太“纯粹”的语言也不是什么好事，C++一直追求的是工程上的实用，而不是学术上的纯粹。\n\n好在C++不会强迫我们做这做那，在里面挑出自己喜欢的就好了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594169423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226312,"user_name":"熊出没","can_delete":false,"product_type":"c1","uid":1145377,"ip_address":"","ucode":"6E39230CC87808","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/21/a33cc944.jpg","comment_is_top":false,"comment_ctime":1592033246,"is_pvip":true,"replies":[{"id":"83341","content":"<br>1.任何语言都可以应用面向对象编程思想，但不一定要用到继承和多态，比如用C里的struct就可以实现抽象和封装。<br>当然了，这个也是我的个人见解，大家可以畅所欲言，讨论多了认识也就深刻了。<br><br>2.说的很好，可以参考后面的设计模式的课程。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1592039779,"ip_address":"","comment_id":226312,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1592033246","product_id":100051801,"comment_content":"思考题个人的想法：<br>1、“抽象”与“封装”赞成是核心思想。“继承”“多态”是衍生特性？这点不太认同，多年的实践，确实认为优先使用“组合”而非“继承”，因为继承很容易带来代码结构的复杂性。“多态”为保证运行期接口的重用性，在设计模式中有重要的作用；<br>2、文中提到”职责单一“性，在面向对象还有另外的设计原则：”开闭“”依赖倒置“”接口分离“”最少知道“”替换“","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498185,"discussion_content":"\n1.任何语言都可以应用面向对象编程思想，但不一定要用到继承和多态，比如用C里的struct就可以实现抽象和封装。\n当然了，这个也是我的个人见解，大家可以畅所欲言，讨论多了认识也就深刻了。\n\n2.说的很好，可以参考后面的设计模式的课程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592039779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225904,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1217554,"ip_address":"","ucode":"C5A540BC5A60B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/94/12/15558f28.jpg","comment_is_top":false,"comment_ctime":1591886669,"is_pvip":false,"replies":[{"id":"83249","content":"看一下轻松话题一吧，推荐《设计模式》。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591924289,"ip_address":"","comment_id":225904,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1591886669","product_id":100051801,"comment_content":"老师，我想请教下关于抽象和封装的思想有什么推荐的书吗？设计模式是否就是这个思想的实践呢？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498036,"discussion_content":"看一下轻松话题一吧，推荐《设计模式》。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591924289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1055296,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/40/f10493ef.jpg","nickname":"中山浪子","note":"","ucode":"25D0F8462473D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291753,"discussion_content":"轻松愉悦的看《大话设计模式》《head first设计模式》《设计模式》","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594946769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225831,"user_name":"Simon","can_delete":false,"product_type":"c1","uid":1914504,"ip_address":"","ucode":"A8A2E3E57BD029","user_header":"https://static001.geekbang.org/account/avatar/00/1d/36/88/20b6a6ee.jpg","comment_is_top":false,"comment_ctime":1591868672,"is_pvip":true,"replies":[{"id":"83201","content":"那就说明设计出了问题，既然类是final的，就不应该被继承，是否应该多回想一下当初的意图。<br><br>并不一定非要用继承来复用代码，对象组合的方式更灵活。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591879517,"ip_address":"","comment_id":225831,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591868672","product_id":100051801,"comment_content":"推荐多用final。如果一个类用了final修饰，发现最后需要被继承，咋办？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498010,"discussion_content":"那就说明设计出了问题，既然类是final的，就不应该被继承，是否应该多回想一下当初的意图。\n\n并不一定非要用继承来复用代码，对象组合的方式更灵活。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591879517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221936,"user_name":"TC128","can_delete":false,"product_type":"c1","uid":1993621,"ip_address":"","ucode":"C5FF12BB7406FB","user_header":"","comment_is_top":false,"comment_ctime":1590636450,"is_pvip":false,"replies":[{"id":"81830","content":"像适配器、桥接这样的模式，可以使用泛型（鸭子类型）来组合对象，也可以用std::function来存储调用的的函数、lambda表达式。<br><br>我觉得要根据实际情况去设计、挑选工具，现在泛型还没有那种比较成熟，能拿来就用的模式。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1590653126,"ip_address":"","comment_id":221936,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1590636450","product_id":100051801,"comment_content":"老师，请教个问题。前几天刚刚学习了设计模式，里面有个“接口倒置原则”要用到虚函数，那不用虚函数这个原则这实现呢？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496617,"discussion_content":"像适配器、桥接这样的模式，可以使用泛型（鸭子类型）来组合对象，也可以用std::function来存储调用的的函数、lambda表达式。\n\n我觉得要根据实际情况去设计、挑选工具，现在泛型还没有那种比较成熟，能拿来就用的模式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590653126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194004,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoFQrP5qpDng4QwEph7tpYFpticD0ibxPHFm17mWkZ35KBfQs2qXNxXUFicgicPqHPbyiaPW1VPJSo4W9w/132","nickname":"Geek_1b1900","note":"","ucode":"A60A44F9C8A14B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380447,"discussion_content":"鸭子类型是什么意思?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624506342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221302,"user_name":"钟健鑫","can_delete":false,"product_type":"c1","uid":1030484,"ip_address":"","ucode":"0844E9D566B337","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b9/54/f663068d.jpg","comment_is_top":false,"comment_ctime":1590466680,"is_pvip":false,"replies":[{"id":"81620","content":"这点确实有很多争议，大家多讨论才能认识的更清楚。<br><br>你说的有一点很对，C和其他语言也能实现抽象和封装。但这个也是面向对象，它并不是限于某种语言的，并不是说面向过程的语言就不能应用面向对象的范式，所以我觉得这才是面向对象的核心。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1590469742,"ip_address":"","comment_id":221302,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590466680","product_id":100051801,"comment_content":"“面向对象编程”是一种设计思想，要点是“抽象”和“封装”，“继承”“多态”是衍生出的特性，不完全符合现实世界。<br><br>这一点不认同，抽象和封装 在面向对象范式中恰恰不是核心，因为C和其它语言都能做到，而对于OO来说 通过多态实现泛化，让系统能支持扩展点处的易扩充 才是核心","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496418,"discussion_content":"这点确实有很多争议，大家多讨论才能认识的更清楚。\n\n你说的有一点很对，C和其他语言也能实现抽象和封装。但这个也是面向对象，它并不是限于某种语言的，并不是说面向过程的语言就不能应用面向对象的范式，所以我觉得这才是面向对象的核心。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590469742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221072,"user_name":"Seven","can_delete":false,"product_type":"c1","uid":1656378,"ip_address":"","ucode":"6F502CDCAD7A79","user_header":"https://static001.geekbang.org/account/avatar/00/19/46/3a/35d9cc02.jpg","comment_is_top":false,"comment_ctime":1590397898,"is_pvip":false,"replies":[{"id":"81583","content":"thanks，后面的课程也要努力。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1590454419,"ip_address":"","comment_id":221072,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590397898","product_id":100051801,"comment_content":"这节课我喜欢😍","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496316,"discussion_content":"thanks，后面的课程也要努力。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590454419,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219954,"user_name":"丶","can_delete":false,"product_type":"c1","uid":2004796,"ip_address":"","ucode":"19900715915112","user_header":"https://static001.geekbang.org/account/avatar/00/1e/97/3c/3a0130fa.jpg","comment_is_top":false,"comment_ctime":1590124845,"is_pvip":false,"replies":[{"id":"81187","content":"<br>1.继承和多态有用，但用多了有害，我认为在C++里是old style。当然我也不会强制不使用，只是不建议使用。<br><br>2.设计模式不一定非要用继承和多态，只用简单的对象体系，加上组合、泛型也可以实现。<br>","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1590128479,"ip_address":"","comment_id":219954,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590124845","product_id":100051801,"comment_content":"个人感觉cpp中的继承和多态还是很重要的，不能因为繁杂就不去尝试。cpp的面试过程中多态是必聊的项目，只要理解了静态多态和动态多态，就没那么复杂了。一个好类的实现是离不开设计模式的辅助，从业两年，虽然设计模式没有搞太清楚，但还是可以从一个公司的项目中看出个边边角角的。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496007,"discussion_content":"\n1.继承和多态有用，但用多了有害，我认为在C++里是old style。当然我也不会强制不使用，只是不建议使用。\n\n2.设计模式不一定非要用继承和多态，只用简单的对象体系，加上组合、泛型也可以实现。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590128479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219189,"user_name":"蓝配鸡","can_delete":false,"product_type":"c1","uid":1348738,"ip_address":"","ucode":"C79A7CA8885B7C","user_header":"https://static001.geekbang.org/account/avatar/00/14/94/82/d0a417ba.jpg","comment_is_top":false,"comment_ctime":1589963844,"is_pvip":false,"replies":[{"id":"80967","content":"看后面的轻松话题吧，里面有几本强力推荐的书。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589965384,"ip_address":"","comment_id":219189,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1589963844","product_id":100051801,"comment_content":"老师有没有推荐的面向对象的书? ","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495707,"discussion_content":"看后面的轻松话题吧，里面有几本强力推荐的书。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589965384,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1348738,"avatar":"https://static001.geekbang.org/account/avatar/00/14/94/82/d0a417ba.jpg","nickname":"蓝配鸡","note":"","ucode":"C79A7CA8885B7C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":270752,"discussion_content":"买了设计模式， 谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590048027,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218909,"user_name":"拉普达","can_delete":false,"product_type":"c1","uid":1930686,"ip_address":"","ucode":"0E524C0D99B2A0","user_header":"https://static001.geekbang.org/account/avatar/00/1d/75/be/6f3ab95e.jpg","comment_is_top":false,"comment_ctime":1589897352,"is_pvip":false,"replies":[{"id":"80917","content":"C++支持多种编程范式，用好对象组合，再加上泛型，完全可以不使用虚函数。<br><br>使用虚函数应该还是从Java里来的思维定式。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589936733,"ip_address":"","comment_id":218909,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589897352","product_id":100051801,"comment_content":"多用组合，少用继承，确实可以较好实现solid原则，但是，虚函数还是少不了要用吧","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495622,"discussion_content":"C++支持多种编程范式，用好对象组合，再加上泛型，完全可以不使用虚函数。\n\n使用虚函数应该还是从Java里来的思维定式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589936733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218881,"user_name":"yelin","can_delete":false,"product_type":"c1","uid":1416262,"ip_address":"","ucode":"4341B2F4C513FE","user_header":"https://static001.geekbang.org/account/avatar/00/15/9c/46/a2c1a99f.jpg","comment_is_top":false,"comment_ctime":1589892460,"is_pvip":false,"replies":[{"id":"80919","content":"继承和多态用多了就会发现好处多于麻烦，把面向对象弄的简单点，结合其他范式，就能写出更干净整洁的代码。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589936807,"ip_address":"","comment_id":218881,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589892460","product_id":100051801,"comment_content":"赞啊，今天才发现C++11的这么多特性这么方便，平时都是玩的啥子，学习了。<br><br>很认同老师说的面向对象的核心是抽象和封装，继承和多态这都是实现手段，实际上繁复的语法和定义，劝退了不知道多少人，同样的面向对象语言，不同实现真的差异很大啊","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495611,"discussion_content":"继承和多态用多了就会发现好处多于麻烦，把面向对象弄的简单点，结合其他范式，就能写出更干净整洁的代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589936807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218793,"user_name":"nuo-promise","can_delete":false,"product_type":"c1","uid":1116668,"ip_address":"","ucode":"39C48245330A35","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/fc/6f53d426.jpg","comment_is_top":false,"comment_ctime":1589876164,"is_pvip":false,"replies":[{"id":"80929","content":"专栏的定位就是开发落地，比较“接地气”，不会讲太多高深的知识，否则很容易“自high”。<br><br>如果有什么需求可以提，我尽量解答。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589937072,"ip_address":"","comment_id":218793,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1589876164","product_id":100051801,"comment_content":" 老师讲的 都是比较基本的 平时用的多的知识点。如果都学懂 也是对C++ 有个比较系统的认识。很适合初学者(稍微有点基础的)","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495576,"discussion_content":"专栏的定位就是开发落地，比较“接地气”，不会讲太多高深的知识，否则很容易“自high”。\n\n如果有什么需求可以提，我尽量解答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589937072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218283,"user_name":"二杠一","can_delete":false,"product_type":"c1","uid":1141324,"ip_address":"","ucode":"040C9A30E7ADF4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/dDk3WicuUbhvcb4R8PD0YiaFteqQvC4UpXHw4chKLDKB0qaOGeCxBJ3nfiaNZAyVQmAgesyE2MvABydxg6gic29j5w/132","comment_is_top":false,"comment_ctime":1589771299,"is_pvip":true,"replies":[{"id":"80736","content":"我认为不会，因为现在的标准库也都是头文件的形式，而且hpp其实就是cpp。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589776868,"ip_address":"","comment_id":218283,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589771299","product_id":100051801,"comment_content":"老师好，写成一个.hpp文件是不是会增加编译成本呢？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495419,"discussion_content":"我认为不会，因为现在的标准库也都是头文件的形式，而且hpp其实就是cpp。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589776868,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218267,"user_name":"java2c++","can_delete":false,"product_type":"c1","uid":1460660,"ip_address":"","ucode":"C4F8C3D7B1A910","user_header":"","comment_is_top":false,"comment_ctime":1589767490,"is_pvip":false,"replies":[{"id":"80715","content":"这也是一个很好的方式，统一编程风格。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589770612,"ip_address":"","comment_id":218267,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589767490","product_id":100051801,"comment_content":"课后作业题2: 建议遵循“约定大于配置”的思想，形成一个圈子（可以是c++生态也可以是公司一个部门）的编码风格","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495412,"discussion_content":"这也是一个很好的方式，统一编程风格。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589770612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218201,"user_name":"silverhawk","can_delete":false,"product_type":"c1","uid":1018649,"ip_address":"","ucode":"BFBC8AF32868DA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8b/19/a15d060d.jpg","comment_is_top":false,"comment_ctime":1589750422,"is_pvip":false,"replies":[{"id":"80693","content":"C++是自由的语言，不对这个做任何限制，可以这么写，但现在一般都不推荐用深层次继承，用泛型更好。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589763383,"ip_address":"","comment_id":218201,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589750422","product_id":100051801,"comment_content":"Java 转C++程序员，一般看Java的都是6-10层的继承，尤其很多abstract，很多知识为了支持Generic，不知道C++里面是不是也很多这样的。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495379,"discussion_content":"C++是自由的语言，不对这个做任何限制，可以这么写，但现在一般都不推荐用深层次继承，用泛型更好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589763383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218068,"user_name":"GeekFans007","can_delete":false,"product_type":"c1","uid":1742728,"ip_address":"","ucode":"84EA11EA4F6BE3","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ZVBHghNC7xdFWcxmITooA2gchPmXGictiaDQiaCeTiavgB1MUxCESeIdptlggeSo7jdMp2xkRGffLadI2bI3ib6Awaw/132","comment_is_top":false,"comment_ctime":1589707119,"is_pvip":false,"replies":[{"id":"80655","content":"是的，http和stream是两个不同的子系统，虽然可以同时运行，但无法直接通信。<br><br>目前还没有解决方案，只能在外面用Redis了。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589717323,"ip_address":"","comment_id":218068,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589707119","product_id":100051801,"comment_content":"罗老师，请教一个OpenResty的问题。一个OpenResty可以同时运行HTTP服务和TCP服务吗？如果可以它们之间用什么通讯呢？我知道在您的书中《OpenResty完全开发指南》说了不可以用共享内存 ","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495342,"discussion_content":"是的，http和stream是两个不同的子系统，虽然可以同时运行，但无法直接通信。\n\n目前还没有解决方案，只能在外面用Redis了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589717323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217933,"user_name":"出卖灵魂的教练Kerry","can_delete":false,"product_type":"c1","uid":1807943,"ip_address":"","ucode":"8C64517DA556FE","user_header":"https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg","comment_is_top":false,"comment_ctime":1589673066,"is_pvip":true,"replies":[{"id":"80567","content":"各人的理解不同吧，我是从编程理念来说的，如果从编程语言来说，多态那就是它的核心了。<br><br>这个不像数学、物理，没有绝对的对错。<br><br>注意设计模式是95年成书的，那个时候主要的范式就是面向对象，所以利用多态是理所当然的。<br><br>","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589678412,"ip_address":"","comment_id":217933,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589673066","product_id":100051801,"comment_content":"老师你好，之前李智慧老师在《后端技术面试38讲》第16讲提过一句，设计模式的精髓在于对面向对象编程特性之一——多态的灵活应用，而多态正是面向对象编程的本质所在。和老师今天说的多态是面向对象的附加功能，是否有矛盾呢？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495295,"discussion_content":"各人的理解不同吧，我是从编程理念来说的，如果从编程语言来说，多态那就是它的核心了。\n\n这个不像数学、物理，没有绝对的对错。\n\n注意设计模式是95年成书的，那个时候主要的范式就是面向对象，所以利用多态是理所当然的。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589678412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217839,"user_name":"出卖灵魂的教练Kerry","can_delete":false,"product_type":"c1","uid":1807943,"ip_address":"","ucode":"8C64517DA556FE","user_header":"https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg","comment_is_top":false,"comment_ctime":1589625990,"is_pvip":true,"replies":[{"id":"80563","content":"这个说法我头一次听说，构造两次，这不符合C++的语义吧，我觉得应该是其他的原因。<br><br>初始化函数的问题主要是效率，先构造完成再初始化，比直接构造多了一点成本。<br><br>可以把构造和启动线程的动作分开试试。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589671015,"ip_address":"","comment_id":217839,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1589625990","product_id":100051801,"comment_content":"我之前看过不要在构造函数初始化，而是写一个函数初始化，在适当的时候调用初始化函数，说有时候构造函数会调用多次。我之前也遇到过一次，在构造函数中启动线程，构造函数缺执行两次，所以开启了两个线程。这种适当时候调用初始化函数对吗？老师有更好的方法吗？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495273,"discussion_content":"这个说法我头一次听说，构造两次，这不符合C++的语义吧，我觉得应该是其他的原因。\n\n初始化函数的问题主要是效率，先构造完成再初始化，比直接构造多了一点成本。\n\n可以把构造和启动线程的动作分开试试。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589671015,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1039204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","nickname":"中年男子","note":"","ucode":"027C86B3370150","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269015,"discussion_content":"构造两次，我也是第一次听过，两次说明了有两个实例，直接在构造函数断点看一下，至于启动线程的动作要不要在构造函数中做，要看你这个类的用途，是每个实例都要启动新的线程， 还是针对类至启动一个线程， 这是实现上的区别了。要结合场景","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589856968,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1994308,"avatar":"","nickname":"catkin","note":"","ucode":"DC123F1074434F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":270748,"discussion_content":"可能临时对象构造执行了一次导致的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590047425,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217806,"user_name":"无为而立","can_delete":false,"product_type":"c1","uid":2003887,"ip_address":"","ucode":"A74526BF43A077","user_header":"https://static001.geekbang.org/account/avatar/00/1e/93/af/54e2a654.jpg","comment_is_top":false,"comment_ctime":1589616828,"is_pvip":false,"replies":[{"id":"80564","content":"nice。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589671024,"ip_address":"","comment_id":217806,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589616828","product_id":100051801,"comment_content":"赞同老师讲的基本原则，我自己觉得分层（封装）和抽象是基本的思想。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495266,"discussion_content":"nice。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589671024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217772,"user_name":"Luke","can_delete":false,"product_type":"c1","uid":1010819,"ip_address":"","ucode":"8368A63185356D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6c/83/48e528cb.jpg","comment_is_top":false,"comment_ctime":1589610155,"is_pvip":false,"replies":[{"id":"80566","content":"很多坑确实只有自己走过才知道，面向对象非常强大，但只有深度使用后才会知道它的不足，尤其是C++这种多范式的语言，要掌握好这些范式该怎么适当使用只能在实践中积累经验。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589671153,"ip_address":"","comment_id":217772,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589610155","product_id":100051801,"comment_content":"赞同少用继承和虚函数，降低运行成本。学C++是从面向对象入手的，《C++高级程序语言设计》，大量篇幅介绍类、封装、虚函数、多态等概念。再加上在早年工作中使用JAVA较多，导致了过度使用了面向对象，一上手就是封装成类。<br><br>后来慢慢领悟到，如果解决问题的领域知识不复杂，完全没有必要去抽象系统的各个实体，可能直接以面向过程更直接高效，减少不必要的因为使用类相关特性带来的开销。特别是持有面向对象编程思想要比面向过程更高级就很可笑，虽然，我一度也有这种想法。（摊手）<br>","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495258,"discussion_content":"很多坑确实只有自己走过才知道，面向对象非常强大，但只有深度使用后才会知道它的不足，尤其是C++这种多范式的语言，要掌握好这些范式该怎么适当使用只能在实践中积累经验。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589671153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217757,"user_name":"milley","can_delete":false,"product_type":"c1","uid":1001175,"ip_address":"","ucode":"8C95F693644CDE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/46/d7/00e99ebb.jpg","comment_is_top":false,"comment_ctime":1589603971,"is_pvip":false,"replies":[{"id":"80529","content":"这样的代码确实比较头疼，尽量推动重构吧。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589610407,"ip_address":"","comment_id":217757,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589603971","product_id":100051801,"comment_content":"话说我平时工作中看到的代码不说三层，六七层是有了，不看log和单步根本不知道能进哪个方法。不知道对于这种情况老师有什么建议？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495254,"discussion_content":"这样的代码确实比较头疼，尽量推动重构吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589610407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}