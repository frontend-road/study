{"id":802682,"title":"07｜应用：为什么说控制逻辑才是C语言自动判题系统的核心","content":"<p>你好，我是金伟。</p><p>上节课我们重点介绍了C语言自动判题系统的程序设计和提示词工程。如果说提示词占到这个项目的50%，那应用逻辑的开发则是另外50%。之所以有这么大的应用逻辑工作，本质还是由于大模型存在幻觉问题，在C语言自动判题系统这个场景下不能保证100%准确，只能靠控制逻辑来增强可靠性。</p><p>在这个项目中，让我印象最深的就是C语言作业对比功能的实现，这个功能经历了多次迭代才驯服大模型，类似的例子还有多个，我会在这节课一一分析出来。</p><p>为了让你更好地理解，让我们先从C语言自动判题系统的用户交互设计开始说。</p><h2>用户交互设计</h2><p>根据上一节课的程序设计原则，我将C语言自动判题系统分为了两个部分，分别是题库模块和判题模块。其中，题库模块负责利用AI自动化配置题库，判题模块负责利用AI，在题库基础上判学生的作业题，再给他们评分。</p><h3>题库模块设计</h3><p>我来梳理一下题库模块的设计，它的输入是现有系统的题干，输出是借助AI整理完成的题库，从下面的示意图里能看到，这个题库里还包含了题目的答案、命令行答案、案例以及运行结果。整体思想是借助AI提高题库内容的生产效率，先由AI一步步生成题库内容，最终再由老师修改并确定AI生成的内容，从而保证题库信息的准确性。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/0f/54/0feee5b5232ed3438b2e171156575254.png?wh=1920x1157\" alt=\"图片\"></p><p>也就是说，这个交互的核心流程分为4步，分别是生成答案、生成命令行答案、生成case用例和生成运行结果。前面步骤生成的结果决定了后面步骤的结果，因此需要用户依次检查、确定每一步的生成结果。核心流程的前3步借助AI生成内容，第4步则采用传统应用程序。</p><p><img src=\"https://static001.geekbang.org/resource/image/b9/5f/b9f5f22b567cc3318f51d79f418ee75f.png?wh=1920x454\" alt=\"图片\"></p><p>题库模块确认的标准答案和case用例，都会在接下来的判题模块里用到。</p><h3>判题模块设计</h3><p>判题模块的设计思路仍然是借助AI辅助判题，最终由老师确认结果。一个典型的例子就是让老师随时可以修改学生的答案，以便根据实际情况修正对学生作业的评估。</p><p>判题模块分为两个核心流程，分别是单个学生判题和一次性判题。</p><p>交互设计如下图。</p><p><img src=\"https://static001.geekbang.org/resource/image/0b/9c/0b3b7f30931493799yya26106519dc9c.png?wh=1920x1429\" alt=\"图片\"></p><p>一次性判题的逻辑是用当前规则对所有学生依次自动判题，运行过程中不需要人工监督，内部则是依次运行单个学生判题流程。而单个学生的判题流程也是全自动的，运行过程不需要人工干预。</p><p>显然，判题模块的挑战在于每个学生，每一道题都可能不一样，容易漏判和误判。我们的解决方案是让用户先对部分学生运行单个学生判题流程，根据结果调整其中某一道题的判题规则，确认之后再运行一次性判题。</p><p><img src=\"https://static001.geekbang.org/resource/image/43/b4/43b66db38a6d6785ac7918961ce6a7b4.png?wh=1920x673\" alt=\"图片\"></p><p>当然这个模块的实际细节更多，我们慢慢来，不着急。</p><p>有了交互设计和上一节课的基本提示词，就可以开始编写应用程序来实现整个系统了。</p><h2>如何用AI写代码？</h2><p>很多人可能会想，既然已经有了核心提示词和用户交互的详细设计，那是不是把这些信息给AI，就可以完整实现整套系统了？</p><p>理论上确实如此。你想想看，每一步的输入输出都详细设计清楚了，有了这些信息，AI完全有能力输出整套系统代码。</p><p>实际情况并非如此。用大模型写代码和用大模型生成其他内容一样，往往是“不靠谱”的，需要控制才能达到商用级别。</p><p>我们先回顾一下上一节课提到的核心提示词。</p><p><img src=\"https://static001.geekbang.org/resource/image/9e/51/9eb286a0e7fcd4a5a76bd7afa3de1f51.png?wh=1920x714\" alt=\"图片\"></p><p>结合这节课的交互设计，可以发现，每一个用户交互正好对应一个提示词，相当于我们的系统已经设计到函数这个级别了，接下来要做的就是让AI按每个函数要求写出代码，程序员根据AI生成的代码做测试，然后进一步完善这个函数。</p><p><img src=\"https://static001.geekbang.org/resource/image/8b/d2/8b3bfcec985aa762eb6ecf114dce8bd2.png?wh=1920x674\" alt=\"图片\"></p><p>为了说明这个过程，我来举一个典型的例子。虽然这个例子不是本节课的代码，但它具有很强的参考意义。</p><p>假设我现在的需求是用 <code>pytube</code> 模块实现视频的下载和分割，每30s分割一个视频并保存。可以用下面简单的提示词让AI生成代码。</p><pre><code class=\"language-plain\">请你帮我写一段python代码，作用是用pytube模块自动下载视频并用按每30s分割，单独保存\n注意最后一段不够30s也要保存下来。\n</code></pre><p>生成的核心代码如下。</p><pre><code class=\"language-plain\"># 分割视频v1\ndef split_video(input_path, segment_length=30):\n    video = VideoFileClip(input_path)\n    duration = video.duration\n    basename, ext = os.path.splitext(input_path)\n    segments = []\n\n\n    for start in range(0, int(duration), segment_length):\n        end = min(start + segment_length, duration)\n        segment = video.subclip(start, end)\n        segment_filename = f\"{basename}_part{start//segment_length + 1}{ext}\"\n        segment.write_videofile(segment_filename, codec=\"libx264\", audio_codec=\"aac\")\n        segments.append(segment_filename)\n    \n    return segments\n</code></pre><p>我们直接运行这段代码发现效果很好，没有任何bug。然而当我的需求发生变化时，比如我希望分割时间按我提供时间序列来进行，类似 <code>\"20,50,70,120..\"</code> 这样按设定的秒数分割，把提示词和版本1的代码提交给AI，生成的代码经过多次修改仍然达不到预期的效果。</p><pre><code class=\"language-plain\"># 分割视频v2\ndef split_video(input_path, segment_lengths=[30]):\n    video = VideoFileClip(input_path)\n    duration = video.duration\n    basename, ext = os.path.splitext(input_path)\n    segments = []\n\n\n    start = 0\n    for i, segment_length in enumerate(segment_lengths):\n        print(segment_length)\n        while start &lt; duration:\n            end = min(segment_length, duration)\n            segment = video.subclip(start, end)\n            segment_filename = f\"{basename}_part{i + 1}_{start}-{end}{ext}\"\n            segment.write_videofile(segment_filename, codec=\"libx264\", audio_codec=\"aac\")\n            segments.append(segment_filename)\n            start += segment_length\n            break\n    \n    return segments\n</code></pre><p>注意，这个V2版本的视频分割代码中，第18行的 <code>break</code> 是我手工添加的，因为AI生成的逻辑一直无法解决多次循环的问题，所以最终还是程序员出手才解决了这个bug。</p><p>C语言自动判题系统里用AI编写函数的过程过于简单，在此不一一说明。但你现在一定能理解，用程序调整、控制大模型的逻辑并达到商用级别，是整个项目里的重中之重。</p><h2>控制大模型的经验</h2><p>如果回顾整个项目的开发经验，整个开发过程中我做得更多的是大模型和应用逻辑的权衡工作。这句话要怎么理解呢？我想回顾一些典型的例子，这样更有助于你理解清楚AI程序开发的这个特性。</p><h3>问题1：不稳定的输出格式</h3><p>应用程序和大模型是一个机机交互过程，机机交互和人机交互有所不同，最典型的就是机机交互要求大模型的输出具备一定格式，这样才方便程序后续读取内容。</p><p>例如上节课里的 <code>QUESTION_TO_ANSWER</code> 提示词。</p><pre><code class=\"language-plain\">QUESTION_TO_ANSWER: \"\"\"\n... ...\n注意C语言程序输出要有明确的分隔符，以便后续我提取，格式如下：\n$$$start$$$\nC语言程序\n$$$end$$$\n\"\"\"\n</code></pre><p>这是题干生成答案应用的提示词，其中 <code>$$$start$$$</code> 和 <code>$$$end$$$</code> 是希望大模型输出的分隔符，但实际运行过程中，输出总有一定的几率不受这个规则控制，它不按预定义的格式输出，喜欢自己添加一些额外说明，或偷偷更换分隔符，所以最终还是需要写程序控制。</p><pre><code class=\"language-plain\">c_language_answer = extract_text_between_markers(c_language_answer, \"```c\", \"```\")\n</code></pre><p>就像这段处理代码显示的那样，大模型实际输出用的是 ````c` 和 ````` 这两个分割符。在大模型应用里，更常见的就是json格式输出，同样需要先用代码检测json格式的合法性，再进一步处理其他逻辑。</p><h3>问题2：case生成的教训</h3><p>再看 <code>答案生成判例</code> 应用里的问题，它使用的是上一节课提到的 <code>ANSWER_TO_TEST_CASE</code> 提示词，实际运行结果发现，大模型总是生成很多极端的case。</p><p>例如下面的输出。</p><pre><code class=\"language-plain\">用例1 用例1分值： 10 5\n用例2 用例2分值： 10 15\n用例3 用例3分值： 10 20\n用例4 用例4分值： 10 25\n... ...\n</code></pre><p>在这个case的输出里，第一个参数10是输入的总长度，第二个参数是分割的长度。但是从用例2开始，分割长度已经超过总长度，明显不合理。这些用例确实是一些极端边界，但是我们可以想象，在判题场景里，每道题不一样，而老师希望考察学生的点也比较主观，尝试调整 <code>ANSWER_TO_TEST_CASE</code> 提示词也也没办法完成这些个性化的需求。</p><p>最后我采用的方法是将这个AI输出作为参考，而非直接使用。这里得到的经验是什么呢？是<strong>我们可以在AI程序设计阶段评估AI的能力界限，从而设定边界，降低对AI的预期。</strong></p><p>正如这个项目里的另外一个例子，在题库系统运行答案获得结果的环节，系统设计时直接采用gcc来运行代码的方案，而没有用AI直接运用C程序。这就是一个很好的边界设计。</p><pre><code class=\"language-plain\">#编译C代码\ntry:\n    subprocess.run(['gcc', '-std=c99', c_file_path, '-o', 'compiled_program', \"-lm\"], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\nexcept subprocess.CalledProcessError as e:\n... ...\n</code></pre><h3>命令行的优化与权衡</h3><p>在命令行生成的应用里，也能很好地体现这种边界设计的经验。对学生作业C语言程序，一开始我们用命令行提示词 <code>ANSWER_TO_COMMAND_LINE</code> 去处理学生作业。</p><pre><code class=\"language-plain\">ANSWER_TO_COMMAND_LINE: \"\"\"\n我在做一个判题系统，下面是答案的C语言程序，要求把输入变量的输入方式有键盘输入改为命令行接收输入，其他任何语句一个字母都不要改，printf(\"\\\\n\") 不要改成 printf(\"\\n\")\n注意：你可以从答案C语言里找所有scanf函数，并且全部替换为命令行输入方式，一个也不能遗漏\n\n\n下面是答案C语言程序:\n\\\"\\\"\\\"\n{程序}\n\\\"\\\"\\\"\n\n\n换行符要用 \"\\\\n\" 输出\n注意C语言程序输出要有明确的分隔符，以便后续我提取，例如：\n$$$start$$$\nC语言程序\n$$$end$$$\n\"\"\"\n</code></pre><p>你可以看到这个提示词里 <code>其他任何语句一个字母都不要改</code> 之类的限定条件，但实际结果是什么呢？实际运行过程中，学生作业的命令行修正没有问题，但是学生作业原有的错误却也被自动修改了。这显然不是我们要的。</p><p>于是我修改了设计，只让AI解决args参数判断这个小问题，最后仍然用程序控制来做剩余的工作。</p><pre><code class=\"language-plain\">DECOMPOSE_HOMEWORK: \"\"\"\n... ..\n输出所有的参数名字和每个参数的argv,以及变量类型就行，下面例子的x,y,z就是学生作业里的输入参数变量名字，int表示整型,string表示字符串类型，float表示浮点型,例子：\n\"x\": \"argv[1],int\",\n\"y\": \"argv[2],string\"\n\"z\": \"argv[3],float\"\n\n\n输出是一个json串即可，不要任何额外说明和代码。\n        \"\"\"\n</code></pre><p>也就是用 <code>DECOMPOSE_HOMEWORK</code> 这个提示示词，大模型可以把学生作业里的参数识别得非常准确，现在则用程序代码实现控制逻辑，将学生作业的args参数部分做对应的修改，实现方法如下。</p><pre><code class=\"language-plain\">#参数替换程序\ndef replace_argv(c_code, argv):\n    \n    lines = c_code.split(\"\\n\")\n    last_line = \"\"\n\n\n    for line in lines:\n        iput = \"\"\n\n\n        if line.find(\"scanf(\") &gt;=0 or line.find(\"fgets(\") &gt;=0:\n            for k in argv.keys():\n                v = argv[k]\n                print(k,v)\n                v,t = v.split(\",\")\n                if t == \"int\": #对参数单独替换\n                    v = \"atoi(\" + v + \")\"\n                ... ...\n            \n            i = c_code.find(line)\n            c_code = c_code[:i] + iput + c_code[i+len(line):]  \n            \n    ... ...\n    return c_code\n</code></pre><p>这个案例也可以得到一些经验，是什么呢？<strong>在</strong> <strong>AI</strong> <strong>开发中遇到一个复杂问题的时候，不一定要将问题全部交给</strong> <strong>AI</strong> <strong>解决，可以拆解为多个任务，让</strong> <strong>AI</strong> <strong>完成合适的子任务即可。</strong></p><h3>核心逻辑和交互的迭代</h3><p>这个项目的 <code>结果比对</code> 应用是最复杂的。比如实际运行过程中，用于结果比对的 <code>EVALUATE_RESULT</code> 提示词总是对数字完全相同但文字描述略有不同的结果存在误判，怎么修改都无法解决这个问题。最终，我们还是使用了一个程序控制逻辑来解决这个常见问题。</p><p>看下下面的代码。</p><pre><code class=\"language-plain\">##二次判题（保证完全一致的不判错）\ndef judgement2(answer_result, homework_result, pan_result_code):\n    ... ...\n    for case in answer_result.keys():\n        if diff2(answer_result[case]['运行结果'], homework_result[case]['运行结果']):\n            pan_result_code[case]['结果'] = '正确'\n            pan_result_code[case]['错误说明'] = '无'\n</code></pre><p>注意，在上述 <code>judgement2</code> 控制代码逻辑里，我直接使用了 <code>diff2</code> 来判断两个输出的核心数据是不是一致。</p><p>实际上我们发现误判情况无法避免，那怎么办呢？最终的解决方案是引入一个判题策略的可定制机制，修改提示词 <code>EVALUATE_RESULT</code> 加入如下部分。</p><pre><code class=\"language-plain\">EVALUATE_RESULT: \"\"\"\n你的角色是一个判断学生作业的系统，你根据下面数据直接判断结果，不要写程序，\n... ...\n\n\n补充规则如下：\n\\\"\\\"\\\"\n{补充规则}\n\\\"\\\"\\\"\n\n\n\n\n以补充规则优先，你直接根据数据按规则自己判断，不要输出程序，不要有任何代码\n\n\n... ...\n\"\"\"\n</code></pre><p>提示词里的 <code>补充规则</code> 就是让老师可以对每个题目制作自己的正向-负向判题规则，再修改提示词的生成代码，之后加入如下代码逻辑，就能实现正负向规则嵌入。</p><pre><code class=\"language-plain\">prompt = (get_prompt(EVALUATE_RESULT, {\"答案输出\": result, '补充规则':rule}))\n</code></pre><p>反映到操作交互界面，则是加入一个判题规则的可定制交互。</p><p><img src=\"https://static001.geekbang.org/resource/image/31/c8/31fba46ed69dab192575f4cdceee39c8.png?wh=1920x1647\" alt=\"图片\"></p><p>正如图中的例子，老师可以将 <code>所有输出里包含字母 abc 的都判定为正确</code> 之类类的规则插入到判题规则中，最终效果很好。</p><p>老师真正的判题流程就是，先人工判定若干学生作业，根据这些学生的情况获得这次作业常见的问题修改规则，最后再一键运行。获得整体excel结果后查看，根据结果回来改判部分学生作业，最后人工评分。</p><p><img src=\"https://static001.geekbang.org/resource/image/8c/4d/8c0d7ab136374cb08b3d3987d13bf64d.png?wh=1920x714\" alt=\"图片\"></p><p>不要看这个流程里有很多的控制逻辑，其实相比原有的业务操作流程，这个逻辑已经可以做到10倍的效率提升了。不过注意，这里的一次性判题，实际系统设定每道题只能运行一次，为什么呢？这其实涉及大模型应用里的一个关键问题：成本考量。</p><h3>成本考量与权衡</h3><p>其实多次全量运行对老师来说也不一定就方便，不如花一点成本，先让判题规则的适用性更广泛，这样批量运行成功率反而提高了。</p><p>除了这个设计，其实在用户交互的每个步骤里，都对大模型结果做了缓存，对于有前后关系的结果，除非前置条件改变，否则尽量不让大模型重复生成，题库模块和判题模块都是这样。</p><p>你可能注意到了，<strong>要真正用好大模型的能力，每一个应用交互的程序和提示词都是需要良好配合，程序控制逻辑需要给AI提示词“兜底”，才能实现整体应用的可靠性。</strong></p><h2>运营情况小记</h2><p>系统最终提交老师运营之后，老师效率提升明显，整体效率提升了10倍左右。</p><p>老师尤其满意的是系统给了足够多的人工干预接口。换言之，就是让老师在原有流程和AI应用流程之间做到了完全无缝衔接，对于很多AI功能，既可以使用AI的结果，也支持人工修改。在题库和判题规则逐渐人工参与完善的情况下，后续系统的效率会有更多提高。</p><h2>小结</h2><p>C语言自动判题系统的真实开发和运行过程给了我们很多启示。其中最重要的启示就是<strong>大模型AI应用开发在大多数场景下，程序逻辑<strong><strong>控制</strong></strong>才是核心，仅仅靠提示词很难产生可靠的应用。</strong></p><p>如果我们把上节课的提示词看做一个文科生，那这节课提到的各种程序控制逻辑则更像一个理科生。C语言自动判题系统的运行结果表明，只有文科生和理科生精准地配合，才能让系统达到商用级别。这个理科生具体的能力包括输出异常的控制处理，配合大模型分解复杂任务，对大模型的精准控制纠偏，实现成本控制等等。</p><p>最后我想补充一点，其实C语言自动判题系统用户交互上的设计也非常重要，最成功的一个设计是通过全流程的人工干预支持，达到和原有流程的无缝对接，达到了效率和可用性的平衡。</p><h2>思考题</h2><p>在真实C语言学生作业中，往往有一些类似拼写错误的常见错误，老师希望这类错误帮学生做一些修复，这个问题可以用AI应用解决吗？怎么解决？</p><p>欢迎你在留言区和我交流。如果觉得有所收获，也可以把课程分享给更多的朋友一起学习。我们下节课见！</p><p><a href=\"https://jsj.top/f/hm26hN\">&gt;&gt;戳此加入课程交流群</a></p>","comments":[{"had_liked":false,"id":393685,"user_name":"连瑞龙","can_delete":false,"product_type":"c1","uid":1898112,"ip_address":"北京","ucode":"E0D3C3D4FCB7C9","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f6/80/85ec2c2a.jpg","comment_is_top":false,"comment_ctime":1724577650,"is_pvip":false,"replies":[{"id":143000,"content":"👍👍👍","user_name":"作者回复","user_name_real":"编辑","uid":1763517,"ctime":1725176839,"ip_address":"北京","comment_id":393685,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100786301,"comment_content":"其实这两节课下来，我们大模型落地实战中的体会和老师是一样的。客户有时候想要用大模型解决所有问题，流程全自动，结果自评判，这本身很不现实。要要让客户正确的认识大模型，认识AI。AI 更多的是对人的增强而不是替代，在整体流程中加入AI来让系统更好的运转，做好AI和程序控制的平衡非常关键，既要充分利用AI的智能性，也好利用程序执行的可靠性和准确性。","like_count":4,"discussions":[{"author":{"id":1763517,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e8/bd/62169942.jpg","nickname":"金伟","note":"","ucode":"C0393789836F21","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":650516,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1725176839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3920101,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/d0/e5/0a3ee17c.jpg","nickname":"kevin","note":"","ucode":"19E83C631DF25E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651142,"discussion_content":"是呀，我也是，提了加群申请，也是没人理","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1726279201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3919568,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM4AialjpfHosIJxEFFYjC1ZNxNlzs7Nm0UoeJAxTdeowJ2ePKqDrePuQZfCxibW2df6jYyTPibNdL8jQ/132","nickname":"Geek_1c33d5","note":"","ucode":"53B596EF89D4D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651085,"discussion_content":"请问这个代码如何领取的？要求加群，能不能给出直接的群名群号让我们加，联系客服加群，不知道为什么几个小时过去了都没有人理的。建议老师直接把群号写在帖子里头，让别人直接加嘛。不用加那个客服的微信啊，这个客服根本就半天半天不反馈，也不回复任何信息","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1726199255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3920101,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/d0/e5/0a3ee17c.jpg","nickname":"kevin","note":"","ucode":"19E83C631DF25E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651143,"discussion_content":"感觉代码跑不通呀，没有详细的说明","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1726280179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":395148,"user_name":"小猪猪猪蛋","can_delete":false,"product_type":"c1","uid":2702408,"ip_address":"北京","ucode":"5117C35B4FA1C9","user_header":"https://static001.geekbang.org/account/avatar/00/29/3c/48/38f84bbc.jpg","comment_is_top":false,"comment_ctime":1729590264,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100786301,"comment_content":"太强了，原理+实践","like_count":0}]}