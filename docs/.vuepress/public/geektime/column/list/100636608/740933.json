{"id":740933,"title":"1.3 背包、队列和栈","content":"\n<p><strong>许多基础数据类型</strong>都和对象的<strong>集合</strong>有关。具体来说，数据类型的值就是一组对象的集合，所有操作都是关于添加、删除或是访问集合中的对象。在本节中，我们将学习三种这样的数据类型，分别是<strong>背包</strong>（Bag）、<strong>队列</strong>（Queue）和<strong>栈</strong>（Stack）。它们的不同之处在于删除或者访问对象的顺序不同。</p>\n<p>背包、队列和栈数据类型都非常基础并且应用广泛。我们在本书的各种实现中也会不断用到它们。除了这些应用以外，本节中的实现和用例代码也展示了我们开发数据结构和算法的一般方式。</p>\n<p>本节的第一个目标是说明我们对集合中的对象的表示方式将直接影响各种操作的效率。对于集合来说，我们将会设计适于表示一组对象的数据结构并高效地实现所需的方法。</p>\n<p>本节的第二个目标是介绍<strong>泛型</strong>和<strong>迭代</strong>。它们都是简单的 Java 概念，但能极大地简化用例代码。它们是高级的编程语言机制，虽然对于算法的理解并不是必需的，但有了它们我们能够写出更加清晰、简洁和优美的用例（以及算法的实现）代码。</p>\n<p>本节的第三个目标是介绍并说明<strong>链式</strong>数据结构的重要性，特别是经典数据结构<strong>链表</strong>，有了它我们才能高效地实现背包、队列和栈。理解链表是学习各种算法和数据结构中最关键的第一步。</p>\n<p>对于这三种数据结构，我们都会学习其 API 和用例，然后再讨论数据类型的值的所有可能的表示方法以及各种操作的实现。这种模式会在全书中反复出现（且数据结构会越来越复杂）。这里的实现是下文所有实现的模板，值得仔细研究。</p><!-- [[[read_end]]] -->\n<h3 id=\"nav_point_37\">1.3.1　API</h3>\n<p>照例，我们对集合型的抽象数据类型的讨论从定义它们的 API 开始，如表 1.3.1 所示。每份 API 都含有一个无参数的构造函数、一个向集合中添加单个元素的方法、一个测试集合是否为空的方法和一个返回集合大小的方法。<code>Stack</code> 和 <code>Queue</code> 都含有一个能够删除集合中的特定元素的方法。除了这些基本内容之外，我们将在以下几节中解释这几份 API 反映出的两种 Java 特性：<strong>泛型</strong>与<strong>迭代</strong>。</p>\n<p><strong>表 1.3.1　泛型可迭代的基础集合数据类型的 API</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td colspan=\"2\"><b>背包</b></td></tr>\n<tr><td colspan=\"2\"><code>public class <b>Bag&lt;Item&gt;</b> implements Iterable&lt;Item&gt;\n</code></td></tr><tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bag()</code></td><td>创建一个空背包</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;add(Item item)</code></td><td>添加一个元素</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;isEmpty()</code></td><td>背包是否为空</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;size()</code></td><td>背包中的元素数量</td></tr>\n<tr><td colspan=\"2\"><b>先进先出（FIFO）队列</b></td></tr>\n<tr><td colspan=\"2\"><code>public class <b>Queue&lt;Item&gt;</b> implements Iterable&lt;Item&gt;\n</code></td></tr><tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Queue()</code></td><td>创建空队列</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;enqueue(Item item)</code></td><td>添加一个元素</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Item&nbsp;&nbsp;dequeue()</code></td><td>删除最早添加的元素</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;isEmpty()</code></td><td>队列是否为空</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;size()-队列中的元素数量\n</code></td></tr><tr><td colspan=\"2\"><b>下压（后进先出，LIFO）栈</b></td></tr>\n<tr><td colspan=\"2\"><code>public class <b>Stack&lt;Item&gt;</b> implements Iterable&lt;Item&gt;\n</code></td></tr><tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack()</code></td><td>创建一个空栈</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;push(Item item)</code></td><td>添加一个元素</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Item&nbsp;&nbsp;pop()</code></td><td>删除最近添加的元素</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;isEmpty()</code></td><td>栈是否为空</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;size()</code></td><td>栈中的元素数量</td></tr>\n</table>\n\n<h4>1.3.1.1　泛型</h4>\n<p>集合类的抽象数据类型的一个关键特性是我们应该可以用它们存储任意类型的数据。一种特别的 Java 机制能够做到这一点，它被称为<strong>泛型</strong>，也叫做<strong>参数化类型</strong>。泛型对编程语言的影响非常深刻，许多语言并没有这种机制（包括早期版本的 Java）。在这里我们对泛型的使用仅限于一点额外的 Java 语法，非常容易理解。在每份 API 中，类名后的<code>&lt;Item&gt;</code> 记号将 <code>Item</code> 定义为一个<strong>类型参数</strong>，它是一个象征性的占位符，表示的是用例将会使用的某种具体数据类型。可以将<code>Stack&lt;Item&gt;</code> 理解为<strong>某种元素的栈</strong>。在实现 <code>Stack</code> 时，我们并不知道 <code>Item</code> 的具体类型，但用例可以用我们的栈处理任意类型的数据，甚至是在我们的实现之后才出现的数据类型。在创建栈时，用例会提供一种具体的数据类型：我们可以将<code>Item</code> 替换为<strong>任意</strong>引用数据类型（<code>Item</code> 出现的每个地方都是如此）。这种能力正是我们所需要的。例如，可以编写如下代码来用栈处理 <code>String</code> 对象：</p>\n<pre class=\"code-rows\"><code>Stack&lt;String&gt; stack = new Stack&lt;String&gt;();\nstack.push(\"Test\");\n...\nString next = stack.pop();</code></pre>\n<p>并在以下代码中使用队列处理 Date 对象：</p>\n<pre class=\"code-rows\"><code>Queue&lt;Date&gt; queue = new Queue&lt;Date&gt;();\nqueue.enqueue(new Date(12, 31, 1999));\n...\nDate next = queue.dequeue();</code></pre>\n<p>如果你尝试向 <code>stack</code> 变量中添加一个 <code>Date</code> 对象（或是任何其他非 <code>String</code> 类型的数据）或者向 <code>queue</code> 变量中添加一个 <code>String</code> 对象（或是任何其他非 <code>Date</code> 类型的数据），你会得到一个编译时错误。如果没有泛型，我们必须为需要收集的每种数据类型定义（并实现）不同的 API。有了泛型，我们只需要一份 API（和一次实现）就能够处理所有类型的数据，甚至是在未来定义的数据类型。你很快将会看到，使用泛型的用例代码很容易理解和调试，因此全书中我们都会用到它。</p>\n<h4>1.3.1.2　自动装箱</h4>\n<p>类型参数必须被实例化为<strong>引用</strong>类型，因此 Java 有一种特殊机制来使泛型代码能够处理原始数据类型。我们还记得 Java 的封装类型都是原始数据类型所对应的引用类型：<code>Boolean</code>、<code>Byte</code>、<code>Character</code>、<code>Double</code>、<code>Float</code>、<code>Integer</code>、<code>Long</code> 和 <code>Short</code> 分别对应着 <code>boolean</code>、<code>byte</code>、<code>char</code>、<code>double</code>、<code>float</code>、<code>int</code>、<code>long</code> 和 <code>short</code>。在处理赋值语句、方法的参数和算术或逻辑表达式时，Java 会自动在引用类型和对应的原始数据类型之间进行转换。在这里，这种转换有助于我们同时使用泛型和原始数据类型。例如：</p>\n<pre class=\"code-rows\"><code>Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();\nstack.push(17);      // 自动装箱 (int -&gt; Integer)\nint i = stack.pop(); // 自动拆箱 (Integer -&gt; int)</code></pre>\n<p>自动将一个原始数据类型转换为一个封装类型被称为<strong>自动装箱</strong>，自动将一个封装类型转换为一个原始数据类型被称为<strong>自动拆箱</strong>。在这个例子中，当我们将一个原始类型的值 <code>17</code> 传递给<code>push()</code> 方法时，Java 将它的类型自动转换（自动装箱）为 <code>Integer</code>。<code>pop()</code> 方法返回了一个 <code>Integer</code> 类型的值，Java 在将它赋予变量 <code>i</code> 之前将它的类型自动转换（自动拆箱）为了 <code>int</code>。</p>\n<h4>1.3.1.3　可迭代的集合类型</h4>\n<p>对于许多应用场景，用例的要求只是用某种方式处理集合中的每个元素，或者叫做<strong>迭代访问</strong>集合中的所有元素。这种模式非常重要，在 Java 和其他许多语言中它都是一级语言特性（不只是库，编程语言本身就含有特殊的机制来支持它）。有了它，我们能够写出清晰简洁的代码且不依赖于集合类型的具体实现。例如，假设用例在<code>Queue</code> 中维护一个交易集合，如下：</p>\n<pre class=\"code-rows\"><code>Queue&lt;Transaction&gt; collection = new Queue&lt;Transaction&gt;();</code></pre>\n<p>如果集合是可迭代的，用例用一行语句即可打印出交易的列表：</p>\n<pre class=\"code-rows\"><code>for (Transaction t : collection)\n{  StdOut.println(t);  }</code></pre>\n<p>这种语法叫做<code>foreach</code> 语句：可以将<code>for</code> 语句看做<strong>对于集合中的每个交易</strong> <code>t(foreach)</code>，<strong>执行以下代码段</strong>。这段用例代码不需要知道集合的表示或实现的任何细节，它只想逐个处理集合中的元素。相同的<code>for</code> 语句也可以处理交易的<code>Bag</code> 对象或是任何可迭代的集合。很难想象还有比这更加清晰和简洁的代码。你将会看到，支持这种迭代需要在实现中添加额外的代码，但这些工作是值得的。</p>\n<p>有趣的是，<code>Stack</code> 和 <code>Queue</code> 的 API 的唯一不同之处只是它们的名称和方法名。这让我们认识到无法简单地通过一列方法的签名说明一个数据类型的所有特点。在这里，只有自然语言的描述才能说明选择被删除元素（或是在 <code>foreach</code> 语句中下一个被处理的元素）的规则。这些规则的差异是 API 的重要组成部分，而且显然对用例代码的开发十分重要。</p>\n<h4>1.3.1.4　背包</h4>\n<p><strong>背包</strong>是一种不支持从中删除元素的集合数据类型——它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素（用例也可以检查背包是否为空或者获取背包中元素的数量）。迭代的顺序不确定且与用例无关。要理解背包的概念，可以想象一个非常喜欢收集弹子球的人。他将所有的弹子球都放在一个背包里，一次一个，并且会不时在所有的弹子球中寻找某一颗拥有某种特点的弹子球。使用<code>Bag</code> 的API，用例可以将元素添加进背包并根据需要随时使用 <code>foreach</code> 语句访问所有的元素。用例也可以使用栈或是队列，但使用 <code>Bag</code> 可以说明元素的处理顺序不重要。下面代码框所示的 <code>Stats</code> 类是 <code>Bag</code> 的一个典型用例。它的任务是简单地计算标准输入中的所有 doub<code>l</code>e 值的平均值和样本标准差。如果标准输入中有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个数字，那么平均值为它们的和除以 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" />，样本标准差为每个值和平均值之差的平方之和除以 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00799.gif\" alt=\"N-1\" inline-img=\"true\" /> 之后的平方根。在这些计算中，数的计算顺序和结果无关，因此我们将它们保存在一个 <code>Bag</code> 对象中并使用 <code>foreach</code> 语法来计算每个和。<strong>注意</strong>：不需要保存所有的数也可以计算标准差（就像我们在 <code>Accumulator</code> 中计算平均值那样——请见练习 1.2.18）。用 <code>Bag</code> 对象保存所有数字是更复杂的统计计算所必需的。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00869.gif\" alt=\"\" width=\"40%\" style=\"width: 40%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 1.3.1　背包的操作</strong></p>\n<p>以下代码框列出的是常用的背包用例。</p>\n<p><strong>背包的典型用例</strong></p>\n<pre class=\"code-rows\"><code>public class Stats\n{\n   public static void main(String[] args)\n   {\n      Bag&lt;Double&gt; numbers = new Bag&lt;Double&gt;();\n\n      while (!StdIn.isEmpty())\n         numbers.add(StdIn.readDouble());\n      int N = numbers.size();\n\n      double sum = 0.0;\n      for (double x : numbers)\n         sum += x;\n      double mean = sum/N;\n\n      sum = 0.0;\n      for (double x : numbers)\n         sum += (x - mean)*(x - mean);\n      double std = Math.sqrt(sum/(N-1));\n\n      StdOut.printf(\"Mean: %.2f\\n\", mean);\n      StdOut.printf(\"Std dev: %.2f\\n\", std);\n   }\n}</code></pre>\n<p><strong>使用方法</strong></p>\n<pre class=\"code-rows\"><code>% java Stats\n100\n99\n101\n120\n98\n107\n109\n81\n101\n90\n\nMean: 100.60\nStd dev: 10.51</code></pre>\n<h4>1.3.1.5　先进先出队列</h4>\n<p><strong>先进先出队列</strong>（或简称<strong>队列</strong>）是一种基于<strong>先进先出</strong>（FIFO）策略的集合类型，如图 1.3.2 所示。按照任务产生的顺序完成它们的策略我们每天都会遇到：在剧院门前排队的人们、在收费站前排队的汽车或是计算机上某种软件中等待处理的任务。任何服务性策略的基本原则都是公平。在提到公平时大多数人的第一个想法就是应该优先服务等待最久的人，这正是先进先出策略的准则。队列是许多日常现象的自然模型，它也是无数应用程序的核心。当用例使用<code>foreach</code> 语句迭代访问队列中的元素时，元素的处理顺序就是它们被添加到队列中的顺序。在应用程序中使用队列的主要原因是在用集合保存元素的同时<strong>保存它们的相对顺序</strong>：使它们入列顺序和出列顺序相同。例如，下页的用例是我们的<code>In</code> 类的静态方法 <code>readInts()</code> 的一种实现。这个方法为用例解决的问题是<strong>用例无需预先知道文件的大小</strong>即可将文件中的所有整数<strong>读入</strong>一个数组中。我们首先将所有的整数<strong>读入</strong>队列中，然后使用 <code>Queue</code> 的 <code>size()</code> 方法得到所需数组的大小，创建数组并将队列中的所有整数<strong>移动</strong>到数组中。队列之所以合适是因为它能够将整数按照文件中的顺序放入数组中（如果该顺序并不重要，也可以使用 <code>Bag</code> 对象）。这段代码使用了自动装箱和拆箱来转换用例中的 <code>int</code> 原始数据类型和队列的 <code>Integer</code> 封装类型。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00870.gif\" alt=\"\" width=\"65%\" style=\"width: 65%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 1.3.2　一个典型的先进先出队列</strong></p>\n<pre class=\"code-rows\"><code>public static int[] readInts(String\nname)\n{\n   In in = new In(name);\n   Queue&lt;Integer&gt; q = new\nQueue&lt;Integer&gt;();\n   while (!in.isEmpty())\n       q.enqueue(in.readInt());\n\n   int N = q.size();\n   int[] a = new int[N];\n   for (int i = 0; i &lt; N; i++)\n      a[i] = q.dequeue();\n   return a;\n}</code></pre>\n<p style=\"text-align: center\"><code>Queue</code> 的用例</p>\n<h4>1.3.1.6　下压栈</h4>\n<p><strong>下压栈</strong>（或简称<strong>栈</strong>）是一种基于<strong>后进先出</strong>（LIFO）策略的集合类型，如图 1.3.3 所示。当你的邮件在桌上放成一叠时，使用的就是栈。新邮件来到时你将它们放在最上面，当你有空时你会一封一封地从上到下阅读它们。现在人们应付的纸质品比以前少得多，但计算机上的许多常用程序遵循相同的组织原则。例如，许多人仍然用栈的方式存放电子邮件——在收信时将邮件压入（push）最顶端，在取信时从最顶端将它们弹出（pop），且第一封一定是最新的邮件（后进，先出）。这种策略的好处是我们能够及时看到感兴趣的邮件，坏处是如果你不把栈清空，某些较早的邮件可能永远也不会被阅读。你在网上冲浪时很可能会遇到栈的另一个例子。点击一个超链接，浏览器会显示一个新的页面（并将它压入一个栈）。你可以不断点击超链接并访问新页面，但总是可以通过点击“回退”按钮重新访问以前的页面（从栈中弹出）。栈的后进先出策略正好能够提供你所需要的行为。当用例使用 <code>foreach</code> 语句迭代遍历栈中的元素时，元素的处理顺序和它们被压入的顺序正好<strong>相反</strong>。在应用程序中使用栈迭代器的一个典型原因是在用集合保存元素的同时<strong>颠倒</strong>它们的相对顺序。例如，右侧的用例 <code>Reverse</code> 将会把标准输入中的所有整数逆序排列，同样它也无需预先知道整数的多少。在计算机领域，栈具有基础而深远的影响，下一节我们会仔细研究一个例子，以说明栈的重要性。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00871.gif\" alt=\"\" width=\"65%\" style=\"width: 65%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 1.3.3　下压栈的操作</strong></p>\n<pre class=\"code-rows\"><code>public class Reverse\n{\n   public static void main(String[] args)\n   {\n      Stack&lt;Integer&gt; stack;\n      stack = new Stack&lt;Integer&gt;();\n      while (!StdIn.isEmpty())\n         stack.push(StdIn.readInt());\n\n      for (int i : stack)\n         StdOut.println(i);\n   }\n}</code></pre>\n<p style=\"text-align: center\"><code>Stack</code> 的用例</p>\n<h4>1.3.1.7　算术表达式求值</h4>\n<p>我们要学习的另一个栈用例同时也是展示泛型的应用的一个经典例子。我们在 1.1 节中最初学习的几个程序之一就是用来计算算术表达式的值的，例如：</p>\n<pre class=\"code-rows\"><code>( 1 + ( ( 2 + 3 ) * ( 4 * 5 ) ) )</code></pre>\n<p>如果将 <code>4</code> 乘以 <code>5</code>，把 <code>3</code> 加上 <code>2</code>，取它们的积然后加 <code>1</code>，就得到了 <code>101</code>。但 Java 系统是如何完成这些运算的呢？不需要研究 Java 系统的构造细节，我们也可以编写一个 Java 程序来解决这个问题。它接受一个输入字符串（表达式）并输出表达式的值。为了简化问题，首先来看一下这份明确的递归定义：<strong>算术表达式</strong>可能是一个数，或者是由一个左括号、一个算术表达式、一个运算符、另一个算术表达式和一个右括号组成的表达式。简单起见，这里定义的是<strong>未省略括号</strong>的算术表达式，它明确地说明了所有运算符的操作数——你可能更熟悉形如 <code>1 + 2 * 3</code> 的表达式，省略了括号，而采用优先级规则。我们将要学习的简单机制也能处理优先级规则，但在这里我们不想把问题复杂化。为了突出重点，我们支持最常见的二元运算符 <code>*</code>、<code>+</code>、<code>-</code> 和 <code>/</code>，以及只接受一个参数的平方根运算符 <code>sqrt</code>。我们也可以轻易支持更多数量和种类的运算符来计算多种大家熟悉的数学表达式，包括三角函数、指数和对数函数。我们的重点在于如何解析由括号、运算符和数字组成的字符串，并按照正确的顺序完成各种初级算术运算操作。如何才能够得到一个（由字符串表示的）算术表达式的值呢？E.W.Dijkstra 在 20 世纪 60 年代发明了一个非常简单的算法，用两个栈（一个用于保存运算符，一个用于保存操作数）完成了这个任务，其实现过程见下页，求值算法的轨迹如图 1.3.4 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00872.gif\" alt=\"\" width=\"58%\" style=\"width: 58%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 1.3.4　Dijkstra 的双栈算术表达式求值算法的轨迹</strong></p>\n<p>表达式由括号、运算符和操作数（数字）组成。我们根据以下 4 种情况从左到右逐个将这些实体送入栈处理：</p>\n<ul>\n<li>将<strong>操作数</strong>压入操作数栈；</li>\n<li>将<strong>运算符</strong>压入运算符栈；</li>\n<li>忽略<strong>左</strong>括号；</li>\n<li>在遇到<strong>右</strong>括号时，弹出一个运算符，弹出所需数量的操作数，并将运算符和操作数的运算结果压入操作数栈。</li>\n</ul>\n<p>在处理完最后一个右括号之后，操作数栈上只会有一个值，它就是表达式的值。这种方法乍一看有些难以理解，但要证明它能够计算得到正确的值很简单：每当算法遇到一个被括号包围并由一个运算符和两个操作数组成的子表达式时，它都将运算符和操作数的计算结果压入操作数栈。这样的结果就好像在输入中用这个值代替了该子表达式，因此用这个值代替子表达式得到的结果和原表达式相同。我们可以反复应用这个规律并得到一个最终值。例如，用该算法计算以下表达式得到的结果都是相同的：</p>\n<pre class=\"code-rows\"><code>( 1 + ( ( 2 + 3 ) * ( 4 * 5 ) ) )\n( 1 + ( 5 * ( 4 * 5 ) ) )\n( 1 + ( 5 * 20 ) )\n( 1 + 100 )\n101</code></pre>\n<p>本页中的 <code>Evaluate</code> 类是该算法的一个实现。这段代码是一个简单的“解释器”：一个能够解释给定字符串所表达的运算并计算得到结果的程序。</p>\n<blockquote>\n<p><strong>Dijkstra 的双栈算术表达式求值算法</strong></p>\n<pre class=\"code-rows\"><code>public class Evaluate\n{\n   public static void main(String[] args)\n   {\n      Stack&lt;String&gt; ops  = new Stack&lt;String&gt;();\n      Stack&lt;Double&gt; vals = new Stack&lt;Double&gt;();\n      while (!StdIn.isEmpty())\n      {  // 读取字符，如果是运算符则压入栈\n         String s = StdIn.readString();\n         if      (s.equals(\"(\"))               ;\n         else if (s.equals(\"+\"))    ops.push(s);\n         else if (s.equals(\"-\"))    ops.push(s);\n         else if (s.equals(\"*\"))    ops.push(s);\n         else if (s.equals(\"/\"))    ops.push(s);\n         else if (s.equals(\"sqrt\")) ops.push(s);\n         else if (s.equals(\")\"))\n         {  // 如果字符为\")\"，弹出运算符和操作数，计算结果并压入栈\n            String op = ops.pop();\n            double v = vals.pop();\n            if      (op.equals(\"+\"))    v = vals.pop() + v;\n            else if (op.equals(\"-\"))    v = vals.pop() - v;\n            else if (op.equals(\"*\"))    v = vals.pop() * v;\n            else if (op.equals(\"/\"))    v = vals.pop() / v;\n            else if (op.equals(\"sqrt\")) v = Math.sqrt(v);\n            vals.push(v);\n         }  // 如果字符既非运算符也不是括号，将它作为double 值压入栈\n         else vals.push(Double.parseDouble(s));\n      }\n      StdOut.println(vals.pop());\n   }\n}</code></pre>\n<p>这段 <code>Stack</code> 的用例使用了两个栈来计算表达式的值。它展示了一种重要的计算模型：将一个字符串解释为一段程序并执行该程序得到结果。有了泛型，我们只需实现 <code>Stack</code> 一次即可使用 <code>String</code> 值的栈和 <code>Double</code> 值的栈。简单起见，这段代码假设表达式没有省略任何括号，数字和字符均以空白字符相隔。</p>\n<pre class=\"code-rows\"><code>% java Evaluate\n( 1 + ( ( 2 + 3 ) * ( 4 * 5 ) ) )\n101.0\n\n% java Evaluate\n( ( 1 + sqrt ( 5.0 ) ) / 2.0 )\n1.618033988749895</code></pre>\n</blockquote>\n<h3 id=\"nav_point_38\">1.3.2　集合类数据类型的实现</h3>\n<p>在讨论 <code>Bag</code>、<code>Stack</code> 和 <code>Queue</code> 的实现之前，我们会先给出一个简单而经典的实现，然后讨论它的改进并得到表 1.3.1 中的 API 的所有实现。</p>\n<h4>1.3.2.1　定容栈</h4>\n<p>作为热身，我们先来看一种表示容量固定的字符串栈的抽象数据类型，如表 1.3.2 所示。它的 API 和 <code>Stack</code> 的 API 有所不同：它只能处理 <code>String</code> 值，它要求用例指定一个容量且不支持迭代。实现一份 API 的第一步就是<strong>选择数据的表示方式</strong>。对于 <code>FixedCapacityStackOfStrings</code>，我们显然可以选择 <code>String</code> 数组。由此我们可以得到表 1.3.2 中底部的实现，它已经是简单得不能再简单了（每个方法都只有一行）。它的实例变量为一个用于保存栈中的元素的数组<code>a[]</code>，和一个用于保存栈中的元素数量的整数<code>N</code>。要删除一个元素，我们将 <code>N</code> 减 <code>1</code> 并返回 <code>a[N]</code>。要添加一个元素，我们将 <code>a[N]</code> 设为新元素并将 <code>N</code> 加 <code>1</code>。这些操作能够保证以下性质：</p>\n<p><strong>表 1.3.2　一种表示定容字符串栈的抽象数据类型</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td rowspan=\"6\"><code><b>API</b></code></td><td colspan=\"2\"><code>public class <b>FixedCapacityStackOfStrings</b></code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FixedCapacityStackOfStrings(int cap)</code></td><td>创建一个容量为 <code>cap</code> 的空栈</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;&nbsp;push(String item)</code></td><td>添加一个字符串</td></tr>\n<tr><td><code>&nbsp;&nbsp;String&nbsp;&nbsp;&nbsp;pop()</code></td><td>删除最近添加的字符串</td></tr>\n<tr><td><code>&nbsp;boolean&nbsp;&nbsp;&nbsp;isEmpty()</code></td><td>栈是否为空</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;size()</code></td><td>栈中的字符串数量</td></tr>\n<tr><td colspan=\"3\"><b>测试用例</b><br /><pre>public static void main(String[] args)<br />{<br />   FixedCapacityStackOfStrings s;<br />   s = new FixedCapacityStackOfStrings(100);<br />   while (!StdIn.isEmpty())<br />   {<br />      String item = StdIn.readString();<br />      if (!item.equals(\"-\"))<br />           s.push(item);<br />      else if (!s.isEmpty()) StdOut.print(s.pop() + \" \");<br />   }<br />   StdOut.println(\"(\" + s.size() + \" left on stack)\");<br />}</pre><br /><b>使用方法</b><br /><pre>% more tobe.txt<br />to be or not to - be - - that - - - is<br />% java FixedCapacityStackOfStrings &lt; tobe.txt<br />to be not that or be (2 left on stack)</pre><br /><b>数据类型的实现</b><br /><pre>public class FixedCapacityStackOfStrings<br />{<br />   private String[] a; // stack entries<br />   private int N;      // size<br />   public FixedCapacityStackOfStrings(int cap)<br />   {  a = new String[cap];  }<br />   public boolean isEmpty() {  return N == 0; }<br />   public int size()        {  return N; }<br />   public void push(String item)<br />   {  a[N++] = item; }<br />   public String pop()<br />   {  return a[--N]; }<br />}</pre></td></tr>\n</table>\n\n<ul>\n<li>数组中的元素顺序和它们被插入的顺序相同；</li>\n<li>当 <code>N</code> 为 0 时栈为空；</li>\n<li>栈的顶部位于 <code>a[N-1]</code>（如果栈非空）。</li>\n</ul>\n<p>和以前一样，用恒等式的方式思考这些条件是检验实现正常工作的最简单的方式。<strong>请你务必完全理解这个实现</strong>。做到这一点的最好方法是检验一系列操作中栈内容的轨迹，如表 1.3.3 所示。测试用例会从标准输入读取多个字符串并将它们压入一个栈，当遇到 - 时它会将栈的内容弹出并打印结果。这种实现的主要性能特点是<code>push</code> 和 <code>pop</code> 操作所需的时间独立于栈的长度。许多应用会因为这种简洁性而选择它。但几个缺点限制了它作为通用工具的潜力，我们要改进的也是这一点。经过一些修改（以及 Java 语言机制的一些帮助），我们就能给出一个适用性更加广泛的实现。这些努力是值得的，因为这个实现是本书中其他许多更强大的抽象数据类型的模板。</p>\n<p><strong>表 1.3.3　FixedCapacityStackOfStrings 的测试用例的轨迹</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td rowspan=\"2\">StdIn<br />(<i>push</i>)</td><td rowspan=\"2\">StdOut<br />(<i>pop</i>)</td><td rowspan=\"2\"><code>N</code></td><td colspan=\"5\"><code>a[]</code></td></tr>\n<tr><td><code>0</code></td><td><code>1</code></td><td><code>2</code></td><td><code>3</code></td><td><code>4</code></td></tr>\n<tr><td></td><td></td><td><code>0</code></td><td></td><td></td><td></td><td></td><td></td></tr>\n<tr><td><code>to</code></td><td></td><td><code>1</code></td><td><code>to</code></td><td></td><td></td><td></td><td></td></tr>\n<tr><td><code>be</code></td><td></td><td><code>2</code></td><td><code>to</code></td><td><code>be</code></td><td></td><td></td><td></td></tr>\n<tr><td><code>or</code></td><td></td><td><code>3</code></td><td><code>to</code></td><td><code>be</code></td><td><code>or</code></td><td></td><td></td></tr>\n<tr><td><code>not</code></td><td></td><td><code>4</code></td><td><code>to</code></td><td><code>be</code></td><td><code>or</code></td><td><code>not</code></td><td></td></tr>\n<tr><td><code>to</code></td><td></td><td><code>5</code></td><td><code>to</code></td><td><code>be</code></td><td><code>or</code></td><td><code>not</code></td><td><code>to</code></td></tr>\n<tr><td>-</td><td><code>to</code></td><td><code>4</code></td><td><code>to</code></td><td><code>be</code></td><td><code>or</code></td><td><code>not</code></td><td><code style=\"color: #9fa0a0\">to</code></td></tr>\n<tr><td><code>be</code></td><td></td><td><code>5</code></td><td><code>to</code></td><td><code>be</code></td><td><code>or</code></td><td><code>not</code></td><td><code>be</code></td></tr>\n<tr><td>-</td><td><code>be</code></td><td><code>4</code></td><td><code>to</code></td><td><code>be</code></td><td><code>or</code></td><td><code>not</code></td><td><code style=\"color: #9fa0a0\">be</code></td></tr>\n<tr><td>-</td><td><code>not</code></td><td><code>3</code></td><td><code>to</code></td><td><code>be</code></td><td><code>or</code></td><td><code style=\"color: #9fa0a0\">not</code></td><td><code style=\"color: #9fa0a0\">be</code></td></tr>\n<tr><td><code>that</code></td><td></td><td><code>4</code></td><td><code>to</code></td><td><code>be</code></td><td><code>or</code></td><td><code>that</code></td><td><code style=\"color: #9fa0a0\">be</code></td></tr>\n<tr><td>-</td><td><code>that</code></td><td><code>3</code></td><td><code>to</code></td><td><code>be</code></td><td><code>or</code></td><td><code style=\"color: #9fa0a0\">that</code></td><td><code style=\"color: #9fa0a0\">be</code></td></tr>\n<tr><td>-</td><td><code>or</code></td><td><code>2</code></td><td><code>to</code></td><td><code>be</code></td><td><code style=\"color: #9fa0a0\">or</code></td><td><code style=\"color: #9fa0a0\">that</code></td><td><code style=\"color: #9fa0a0\">be</code></td></tr>\n<tr><td>-</td><td><code>be</code></td><td><code>1</code></td><td><code>to</code></td><td><code style=\"color: #9fa0a0\">be</code></td><td><code style=\"color: #9fa0a0\">or</code></td><td><code style=\"color: #9fa0a0\">that</code></td><td><code style=\"color: #9fa0a0\">be</code></td></tr>\n<tr><td><code>is</code></td><td></td><td><code>2</code></td><td><code>to</code></td><td><code>is</code></td><td><code style=\"color: #9fa0a0\">or</code></td><td><code style=\"color: #9fa0a0\">not</code></td><td><code style=\"color: #9fa0a0\">to</code></td></tr>\n</table>\n\n<h4>1.3.2.2　泛型</h4>\n<p><code>FixedCapacityStackOfStrings</code> 的第一个缺点是它只能处理 <code>String</code> 对象。如果需要一个 <code>double</code> 值的栈，你就需要用类似的代码实现另一个类，也就是把所有的 <code>String</code> 都替换为 <code>double</code>。这还算简单，但如果我们需要 <code>Transaction</code> 类型的栈或者 <code>Date</code> 类型的队列等，情况就很棘手了。如 1.3.1.1 节的讨论所示，Java 的参数类型（泛型）就是专门用来解决这个问题的，而且我们也看过了几个用例的代码（请见 1.3.1.4 节、1.3.1.5 节、1.3.1.6 节和 1.3.1.7 节）。但<strong>如何才能实现一个泛型的栈呢</strong>？表 1.3.4 中的代码展示了实现的细节。它实现了一个 <code>FixedCapacityStack</code> 类，该类和 <code>FixedCapacityStackOfStrings</code> 类的区别仅在于加粗部分的代码——我们把所有的 <code>String</code> 都替换为 <code>Item</code>（一个地方除外，会在稍后讨论）并用下面这行代码声明了该类：</p>\n<pre class=\"code-rows\"><code>public class FixedCapacityStack&lt;Item&gt;</code></pre>\n<p>Item 是一个<strong>类型参数</strong>，用于表示用例将会使用的某种具体类型的象征性的占位符。可以将 <code>FixedCapacityStack&lt;Item&gt;</code> 理解为<strong>某种元素的栈</strong>，这正是我们想要的。在实现 <code>FixedCapacityStack</code> 时，我们并不知道 <code>Item</code> 的实际类型，但用例只要能在创建栈时提供具体的数据类型，它就能用栈处理任意数据类型。实际的类型必须是引用类型，但用例可以依靠自动装箱将原始数据类型转换为相应的封装类型。Java 会使用类型参数 <code>Item</code> 来检查类型不匹配的错误——尽管具体的数据类型还不知道，赋予 <code>Item</code> 类型变量的值也必须是 <code>Item</code> 类型的，等等。在这里有一个细节非常重要：我们希望用以下代码在 <code>FixedCapacityStack</code> 的构造函数的实现中创建一个泛型的数组：</p>\n<pre class=\"code-rows\"><code>a = new Item[cap];</code></pre>\n<p>由于某些历史和技术原因（不在本书讲解范围之内），<strong>创建泛型数组在 Java 中是不允许的</strong>。我们需要使用类型转换：</p>\n<pre class=\"code-rows\"><code>a = (Item[]) new Object[cap];</code></pre>\n<p>这段代码才能够达到我们所期望的效果（但 Java 编译器会给出一条警告，不过可以忽略它），我们在本书中会一直使用这种方式（Java 系统库中类似抽象数据类型的实现中也使用了相同的方式）。</p>\n<p><strong>表 1.3.4　一种表示泛型定容栈的抽象数据类型</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td rowspan=\"6\"><code><b>API</b></code></td><td colspan=\"2\"><code>public class <b>FixedCapacityStack</b>&lt;Item&gt;</code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FixedCapacityStack(int cap)</code></td><td>创建一个容量为 <code>cap</code> 的空栈</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;&nbsp;push(<b>Item</b> item)</code></td><td>添加一个元素</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Item</b>&nbsp;&nbsp;&nbsp;pop()</code></td><td>删除最近添加的元素</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;&nbsp;isEmpty()</code></td><td>栈是否为空</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;size()</code></td><td>栈中的元素数量</td></tr>\n<tr><td colspan=\"3\"><b>测试用例</b><br /><pre>public static void main(String[] args)<br />{<br />   FixedCapacityStack<b>&lt;String&gt;</b> s;<br />   s = new FixedCapacityStack<b>&lt;String&gt;</b>(100);<br />   while (!StdIn.isEmpty())<br />   {<br />      String item = StdIn.readString();<br />      if (!item.equals(\"-\"))<br />           s.push(item);<br />      else if (!s.isEmpty()) StdOut.print(s.pop() + \" \");<br />   }<br />   StdOut.println(\"(\" + s.size() + \" left on stack)\");<br />}</pre><br /><b>使用方法</b><br /><pre>% more tobe.txt<br />to be or not to - be - - that - - - is<br />% java FixedCapacityStack &lt; tobe.txt<br />to be not that or be (2 left on stack)</pre><br /><b>数据类型的实现</b><br /><pre>public class FixedCapacityStack<b>&lt;Item&gt;</b><br />{<br />   private <b>Item</b>[] a;   // stack entries<br />   private int N;      // size<br />   public FixedCapacityStack(int cap)<br />   {  a = <b>(Item[]) new Object</b>[cap];  }<br />   public boolean isEmpty() {  return N == 0; }<br />   public int size()        {  return N; }<br />   public void push(<b>Item</b> item)<br />   {  a[N++] = item; }<br />   public <b>Item</b> pop()<br />   {  return a[--N]; }<br />}</pre></td></tr>\n</table>\n\n<h4>1.3.2.3　调整数组大小</h4>\n<p>选择用数组表示栈内容意味着用例必须预先估计栈的最大容量。在 Java 中，数组一旦创建，其大小是无法改变的，因此栈使用的空间只能是这个最大容量的一部分。选择大容量的用例在栈为空或几乎为空时会浪费大量的内存。例如，一个交易系统可能会涉及数十亿笔交易和数千个交易的集合。即使这种系统一般都会限制每笔交易只能出现在一个集合中，但用例必须保证所有集合都有能力保存所有的交易。另一方面，如果集合变得比数组更大那么用例有可能<strong>溢出</strong>。为此，<code>push()</code> 方法需要在代码中检测栈是否已满，我们的 API 中也应该含有一个 <code>isFull()</code> 方法来允许用例检测栈是否已满。我们在此省略了它的实现代码，因为我们希望用例从处理栈已满的问题中解脱出来，如我们的原始 <code>Stack</code> API 所示。因此，我们修改了数组的实现，动态调整数组<code>a[]</code> 的大小，使得它既足以保存所有元素，又不至于浪费过多的空间。实际上，完成这些目标非常简单。首先，实现一个方法将栈移动到另一个大小不同的数组中：</p>\n<pre class=\"code-rows\"><code>private void resize(int max)\n{  // 将大小为N &lt; = max 的栈移动到一个新的大小为max 的数组中\n   Item[] temp = (Item[]) new Object[max];\n   for (int i = 0; i &lt; N; i++)\n   temp[i] = a[i];\n   a = temp;\n}</code></pre>\n<p>现在，在<code>push()</code> 中，检查数组是否太小。具体来说，我们会通过检查栈大小 <code>N</code> 和数组大小 <code>a.length</code> 是否相等来检查数组是否能够容纳新的元素。如果没有多余的空间，我们会将数组的长度<strong>加倍</strong>。然后就可以和从前一样用 <code>a[N++] = item</code> 插入新元素了：</p>\n<pre class=\"code-rows\"><code>public void push(Item item)\n{  // 将元素压入栈顶\n   if (N == a.length) resize(2*a.length);\n   a[N++] = item;\n}</code></pre>\n<p>类似，在 <code>pop()</code> 中，首先删除栈顶的元素，然后如果数组太大我们就将它的长度<strong>减半</strong>。只要稍加思考，你就明白正确的检测条件是栈大小是否小于<strong>数组的四分之一</strong>。在数组长度被减半之后，它的状态约为半满，在下次需要改变数组大小之前仍然能够进行多次 <code>push()</code> 和 <code>pop()</code> 操作。</p>\n<pre class=\"code-rows\"><code>public Item pop()\n{  // 从栈顶删除元素\n   Item item = a[--N];\n   a[N] = null;  // 避免对象游离（请见下节）\n   if (N &gt; 0 &amp;&amp; N == a.length/4) resize(a.length/2);\n   return item;\n}</code></pre>\n<p>在这个实现中，栈永远不会溢出，使用率也永远不会低于四分之一（除非栈为空，那种情况下数组的大小为 1）。我们会在 1.4 节中详细分析这种实现方法的性能特点。</p>\n<p><code>push()</code> 和 <code>pop()</code> 操作中数组大小调整的轨迹见表 1.3.5。</p>\n<p><strong>表 1.3.5　一系列 <code>push()</code> 和 <code>pop()</code> 操作中数组大小调整的轨迹</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td rowspan=\"2\"><code>push()</code></td><td rowspan=\"2\"><code>pop()</code></td><td rowspan=\"2\"><code>N</code></td><td rowspan=\"2\"><code>a.length</code></td><td colspan=\"8\"><code>a[]</code></td></tr>\n<tr><td><code>0</code></td><td><code>1</code></td><td><code>2</code></td><td><code>3</code></td><td><code>4</code></td><td><code>5</code></td><td><code>6</code></td><td><code>7</code></td></tr>\n<tr><td></td><td></td><td><code>0</code></td><td><code>1</code></td><td><code>null</code></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td></tr>\n<tr><td><code>to</code></td><td></td><td><code>1</code></td><td><code style=\"color: #9fa0a0\">1</code></td><td><code>to</code></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td></tr>\n<tr><td><code>be</code></td><td></td><td><code>2</code></td><td><code>2</code></td><td><code style=\"color: #9fa0a0\">to</code></td><td><code>be</code></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td></tr>\n<tr><td><code>or</code></td><td></td><td><code>3</code></td><td><code>4</code></td><td><code style=\"color: #9fa0a0\">to</code></td><td><code style=\"color: #9fa0a0\">be</code></td><td><code>or</code></td><td><code>null</code></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td></tr>\n<tr><td><code>not</code></td><td></td><td><code>4</code></td><td><code style=\"color: #9fa0a0\">4</code></td><td><code style=\"color: #9fa0a0\">to</code></td><td><code style=\"color: #9fa0a0\">be</code></td><td><code style=\"color: #9fa0a0\">or</code></td><td><code>not</code></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td></tr>\n<tr><td><code>to</code></td><td></td><td><code>5</code></td><td><code>8</code></td><td><code style=\"color: #9fa0a0\">to</code></td><td><code style=\"color: #9fa0a0\">be</code></td><td><code style=\"color: #9fa0a0\">or</code></td><td><code style=\"color: #9fa0a0\">not</code></td><td><code>to</code></td><td><code>null</code></td><td><code>null</code></td><td><code>null</code></td></tr>\n<tr><td>-</td><td><code>to</code></td><td><code>4</code></td><td><code style=\"color: #9fa0a0\">8</code></td><td><code style=\"color: #9fa0a0\">to</code></td><td><code style=\"color: #9fa0a0\">be</code></td><td><code style=\"color: #9fa0a0\">or</code></td><td><code style=\"color: #9fa0a0\">not</code></td><td><code>null</code></td><td><code style=\"color: #9fa0a0\">null</code></td><td><code style=\"color: #9fa0a0\">null</code></td><td><code style=\"color: #9fa0a0\">null</code></td></tr>\n<tr><td><code>be</code></td><td></td><td><code>5</code></td><td><code style=\"color: #9fa0a0\">8</code></td><td><code style=\"color: #9fa0a0\">to</code></td><td><code style=\"color: #9fa0a0\">be</code></td><td><code style=\"color: #9fa0a0\">or</code></td><td><code style=\"color: #9fa0a0\">not</code></td><td><code>be</code></td><td><code style=\"color: #9fa0a0\">null</code></td><td><code style=\"color: #9fa0a0\">null</code></td><td><code style=\"color: #9fa0a0\">null</code></td></tr>\n<tr><td>-</td><td><code>be</code></td><td><code>4</code></td><td><code style=\"color: #9fa0a0\">8</code></td><td><code style=\"color: #9fa0a0\">to</code></td><td><code style=\"color: #9fa0a0\">be</code></td><td><code style=\"color: #9fa0a0\">or</code></td><td><code style=\"color: #9fa0a0\">not</code></td><td><code>null</code></td><td><code style=\"color: #9fa0a0\">null</code></td><td><code style=\"color: #9fa0a0\">null</code></td><td><code style=\"color: #9fa0a0\">null</code></td></tr>\n<tr><td>-</td><td><code>not</code></td><td><code>3</code></td><td><code style=\"color: #9fa0a0\">8</code></td><td><code style=\"color: #9fa0a0\">to</code></td><td><code style=\"color: #9fa0a0\">be</code></td><td><code style=\"color: #9fa0a0\">or</code></td><td><code>null</code></td><td><code style=\"color: #9fa0a0\">null</code></td><td><code style=\"color: #9fa0a0\">null</code></td><td><code style=\"color: #9fa0a0\">null</code></td><td><code style=\"color: #9fa0a0\">null</code></td></tr>\n<tr><td><code>that</code></td><td></td><td><code>4</code></td><td><code style=\"color: #9fa0a0\">8</code></td><td><code style=\"color: #9fa0a0\">to</code></td><td><code style=\"color: #9fa0a0\">be</code></td><td><code style=\"color: #9fa0a0\">or</code></td><td><code>that</code></td><td><code style=\"color: #9fa0a0\">null</code></td><td><code style=\"color: #9fa0a0\">null</code></td><td><code style=\"color: #9fa0a0\">null</code></td><td><code style=\"color: #9fa0a0\">null</code></td></tr>\n<tr><td>-</td><td><code>that</code></td><td><code>3</code></td><td><code style=\"color: #9fa0a0\">8</code></td><td><code style=\"color: #9fa0a0\">to</code></td><td><code style=\"color: #9fa0a0\">be</code></td><td><code style=\"color: #9fa0a0\">or</code></td><td><code>null</code></td><td><code style=\"color: #9fa0a0\">null</code></td><td><code style=\"color: #9fa0a0\">null</code></td><td><code style=\"color: #9fa0a0\">null</code></td><td><code style=\"color: #9fa0a0\">null</code></td></tr>\n<tr><td>-</td><td><code>or</code></td><td><code>2</code></td><td><code>4</code></td><td><code style=\"color: #9fa0a0\">to</code></td><td><code style=\"color: #9fa0a0\">be</code></td><td><code>null</code></td><td><code>null</code></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td></tr>\n<tr><td>-</td><td><code>be</code></td><td><code>1</code></td><td><code>2</code></td><td><code style=\"color: #9fa0a0\">to</code></td><td><code>null</code></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td></tr>\n<tr><td><code>is</code></td><td></td><td><code>2</code></td><td><code style=\"color: #9fa0a0\">2</code></td><td><code style=\"color: #9fa0a0\">to</code></td><td><code>is</code></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td><td style=\"background-color: #c9c9ca\"></td></tr>\n</table>\n\n<h4>1.3.2.4　对象游离</h4>\n<p>Java 的垃圾收集策略是回收所有无法被访问的对象的内存。在我们对 <code>pop()</code> 的实现中，被弹出的元素的引用仍然存在于数组中。这个元素实际上已经是一个<strong>孤儿</strong>了——它永远也不会再被访问了，但 Java 的垃圾收集器没法知道这一点，除非该引用被覆盖。即使用例已经不再需要这个元素了，数组中的引用仍然可以让它继续存在。这种情况（保存一个不需要的对象的引用）称为<strong>游离</strong>。在这里，避免对象游离很容易，只需将被弹出的数组元素的值设为 <code>null</code> 即可，这将覆盖无用的引用并使系统可以在用例使用完被弹出的元素后回收它的内存。</p>\n<h4>1.3.2.5　迭代</h4>\n<p>本节开头已经提过，集合类数据类型的基本操作之一就是，能够使用 Java 的 <code>foreach</code> 语句通过<strong>迭代</strong>遍历并处理集合中的每个元素。这种方式的代码既清晰又简洁，且不依赖于集合数据类型的具体实现。在讨论迭代的实现之前，我们先看一段能够打印出一个字符串集合中的所有元素的用例代码：</p>\n<pre class=\"code-rows\"><code>Stack&lt;String&gt; collection = new Stack&lt;String&gt;();\n...\nfor (String s : collection)\n   StdOut.println(s);\n...</code></pre>\n<p>这里，<code>foreach</code> 语句只是 <code>while</code> 语句的一种简写方式（就好像 <code>for</code> 语句一样）。它本质上和以下 <code>while</code> 语句是等价的：</p>\n<pre class=\"code-rows\"><code>Iterator&lt;String&gt; i = collection.iterator();\nwhile (i.hasNext())\n{\n   String s = i.next();\n   StdOut.println(s);\n}</code></pre>\n<p>这段代码展示了一些在任意可迭代的集合数据类型中我们都需要实现的东西：</p>\n<ul>\n<li>集合数据类型必须实现一个 <code>iterator()</code> 方法并返回一个 <code>Iterator</code> 对象；</li>\n<li><code>Iterator</code> 类必须包含两个方法：<code>hasNext()</code>（返回一个布尔值）和<code>next()</code>（返回集合中的一个泛型元素）。</li>\n</ul>\n<p>在 Java 中，我们使用接口机制来指定一个类所必须实现的方法（请见 1.2.5.4 节）。对于可迭代的集合数据类型，Java 已经为我们定义了所需的接口。要使一个类可迭代，第一步就是在它的声明中加入 <code>implements Iterable&lt;Item&gt;</code>，对应的接口（即 java.lang.Iterable）为：</p>\n<pre class=\"code-rows\"><code>public interface Iterable&lt;Item&gt;\n{\n   Iterator&lt;Item&gt; iterator();\n}</code></pre>\n<p>然后在类中添加一个方法 <code>iterator()</code> 并返回一个迭代器 <code>Iterator&lt;Item&gt;</code>。迭代器都是泛型的，因此我们可以使用参数类型 <code>Item</code> 来帮助用例遍历它们指定的任意类型的对象。对于一直使用的数组表示法，我们需要逆序迭代遍历这个数组，因此我们将迭代器命名为 <code>ReverseArrayIterator</code>，并添加了以下方法：</p>\n<pre class=\"code-rows\"><code>public Iterator&lt;Item&gt; iterator()\n{  return new ReverseArrayIterator();  }</code></pre>\n<p>迭代器是什么？它是一个实现了 <code>hasNext()</code> 和 <code>next()</code> 方法的类的对象，由以下接口所定义（即 java.util.Iterator）：</p>\n<pre class=\"code-rows\"><code>public interface Iterator&lt;Item&gt;\n{\n    boolean hasNext();\n    Item next();\n    void remove();\n}</code></pre>\n<p>尽管接口指定了一个<code>remove()</code> 方法，但在本书中<code>remove()</code> 方法总为空，因为我们希望避免在迭代中穿插能够修改数据结构的操作。对于 <code>ReverseArrayIterator</code>，这些方法都只需要一行代码，它们实现在栈类的一个嵌套类中：</p>\n<pre class=\"code-rows\"><code>private class ReverseArrayIterator implements Iterator&lt;Item&gt;\n{\n   private int i = N;\n\n   public boolean hasNext() {  return i &gt; 0;   }\n   public Item next()       {  return a[--i];  }\n   public void remove()     {                  }\n}</code></pre>\n<p>请注意，嵌套类可以访问包含它的类的实例变量，在这里就是<code>a[]</code> 和<code>N</code>（这也是我们使用嵌套类实现迭代器的主要原因）。从技术角度来说，为了和 <code>Iterator</code> 的结构保持一致，我们应该在两种情况下抛出异常：如果用例调用了 <code>remove()</code> 则抛出<code>UnsupportedOperationException</code>，如果用例在调用<code>next()</code> 时<code>i</code> 为 0 则抛出<code>NoSuchElementException</code>。因为我们只会在<code>foreach</code> 语法中使用迭代器，这些情况都不会出现，所以我们省略了这部分代码。还剩下一个非常重要的细节，我们需要在程序的开头加上下面这条语句：</p>\n<pre class=\"code-rows\"><code>import java.util.Iterator;</code></pre>\n<p>因为（某些历史原因）<code>Iterator</code> 不在java.lang 中（尽管 <code>Iterable</code> <strong>是</strong> java.lang 的一部分）。现在，使用 <code>foreach</code> 处理该类的用例能够得到的行为和使用普通的 <code>for</code> 循环访问数组一样，但它无须知道数据的表示方法是数组（即实现细节）。对于我们在本书中学习的和 Java 库中所包含的所有类似于集合的基础数据类型的实现，这一点非常重要。例如，<strong>我们无需改变任何用例代码</strong>就可以随意切换不同的表示方法。更重要的是，从用例的角度来来说，<strong>无需知晓类的实现细节</strong>用例也能使用迭代。</p>\n<p>算法 1.1 是 <code>Stack</code> API 的一种能够动态改变数组大小的实现。用例能够创建任意类型数据的栈，并支持用例用 <code>foreach</code> 语句按照后进先出的顺序迭代访问所有栈元素。这个实现的基础是 Java 的语言特性，包括 <code>Iterable</code> 和 <code>Iterator</code>，但我们没有必要深究这些特性的细节，因为代码本身并不复杂，并且可以用做其他集合数据类型的实现的模板。</p>\n<p>例如，我们在实现 <code>Queue</code> 的 API 时，可以使用两个实例变量作为索引，一个变量 <code>head</code> 指向队列的开头，一个变量 <code>tail</code> 指向队列的结尾，如表 1.3.6 所示。在删除一个元素时，使用 <code>head</code> 访问它并将 <code>head</code> 加 1；在插入一个元素时，使用 <code>tail</code> 保存它并将 <code>tail</code> 加 1。如果某个索引在增加之后越过了数组的边界则将它重置为 0。实现检查队列是否为空、是否充满并需要调整数组大小的细节是一项有趣而又实用的编程练习（请见练习 1.3.14）。</p>\n<p><strong>表 1.3.6　ResizingArrayQueue 的测试用例的轨迹</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><th rowspan=\"2\">StdIn<br />(入列)</th><th rowspan=\"2\">StdOut<br />(出列)</th><td rowspan=\"2\"><code>N</code></td><td rowspan=\"2\"><code>head</code></td><td rowspan=\"2\"><code>tail</code></td><td colspan=\"8\"><code>a[]</code></td></tr>\n<tr><td><code>0</code></td><td><code>1</code></td><td><code>2</code></td><td><code>3</code></td><td><code>4</code></td><td><code>5</code></td><td><code>6</code></td><td><code>7</code></td></tr>\n<tr><td></td><td></td><td><code>5</code></td><td><code>0</code></td><td><code>5</code></td><td><code>to</code></td><td><code>be</code></td><td><code>or</code></td><td><code>not</code></td><td><code>to</code></td><td></td><td></td><td></td></tr>\n<tr><td>-</td><td><code>to</code></td><td><code>4</code></td><td><code>1</code></td><td><code>5</code></td><td><code style=\"color: #9fa0a0\">to</code></td><td><code>be</code></td><td><code>or</code></td><td><code>not</code></td><td><code>to</code></td><td></td><td></td><td></td></tr>\n<tr><td><code>be</code></td><td></td><td><code>5</code></td><td><code>1</code></td><td><code>6</code></td><td><code style=\"color: #9fa0a0\">to</code></td><td><code>be</code></td><td><code>or</code></td><td><code>not</code></td><td><code>to</code></td><td><code>be</code></td><td></td><td></td></tr>\n<tr><td>-</td><td><code>be</code></td><td><code>4</code></td><td><code>2</code></td><td><code>6</code></td><td><code style=\"color: #9fa0a0\">to</code></td><td><code style=\"color: #9fa0a0\">be</code></td><td><code>or</code></td><td><code>not</code></td><td><code>to</code></td><td><code>be</code></td><td></td><td></td></tr>\n<tr><td>-</td><td><code>or</code></td><td><code>3</code></td><td><code>3</code></td><td><code>6</code></td><td><code style=\"color: #9fa0a0\">to</code></td><td><code style=\"color: #9fa0a0\">be</code></td><td><code style=\"color: #9fa0a0\">or</code></td><td><code>not</code></td><td><code>to</code></td><td><code>be</code></td><td></td><td></td></tr>\n</table>\n\n<p>在算法的学习中，算法 1.1 十分重要，因为它几乎（但还没有）达到了任意集合类数据类型的实现的最佳性能：</p>\n<ul>\n<li>每项操作的用时都与集合大小无关；</li>\n<li>空间需求总是不超过集合大小乘以一个常数。</li>\n</ul>\n<p><code>ResizingArrayStack</code> 的缺点在于某些 <code>push()</code> 和 <code>pop()</code> 操作会调整数组的大小：这项操作的耗时和栈大小成正比。下面，我们将学习一种克服该缺陷的方法，使用一种完全不同的方式来组织数据。</p>\n<blockquote>\n<p><strong>算法 1.1　下压（LIFO）栈（能够动态调整数组大小的实现）</strong></p>\n<pre class=\"code-rows\"><code>import java.util.Iterator;\npublic class ResizingArrayStack&lt;Item&gt; implements Iterable&lt;Item&gt;\n{\n   private Item[] a = (Item[]) new Object[1];  // 栈元素\n   private int N = 0;                          // 元素数量\n   public boolean isEmpty()  {  return N == 0; }\n   public int size()         {  return N;      }\n   private void resize(int max)\n   {  // 将栈移动到一个大小为max 的新数组\n      Item[] temp = (Item[]) new Object[max];\n      for (int i = 0; i &lt; N; i++)\n         temp[i] = a[i];\n      a = temp;\n   }\n   public void push(Item item)\n   {  // 将元素添加到栈顶\n      if (N == a.length) resize(2*a.length);\n      a[N++] = item;\n   }\n   public Item pop()\n   {  // 从栈顶删除元素\n      Item item = a[--N];\n      a[N] = null;  // 避免对象游离（请见1.3.2.4 节）\n      if (N &gt; 0 &amp;&amp; N == a.length/4) resize(a.length/2);\n      return item;\n   }\n   public Iterator&lt;Item&gt; iterator()\n    {  return new ReverseArrayIterator();  }\n   private class ReverseArrayIterator implements Iterator&lt;Item&gt;\n   {  // 支持后进先出的迭代\n      private int i = N;\n      public boolean hasNext() {  return i &gt; 0;   }\n      public    Item next()    {  return a[--i];  }\n      public    void remove()  {                  }\n   }\n}</code></pre>\n<p>这份泛型的可迭代的 <code>Stack</code> API 的实现是所有集合类抽象数据类型实现的模板。它将所有元素保存在数组中，并动态调整数组的大小以保持数组大小和栈大小之比小于一个常数。</p>\n</blockquote>\n<h3 id=\"nav_point_39\">1.3.3　链表</h3>\n<p>现在我们来学习一种基础数据结构的使用，它是在集合类的抽象数据类型实现中表示数据的合适选择。这是我们构造非 Java 直接支持的数据结构的第一个例子。我们的实现将成为本书中其他更加复杂的数据结构的构造代码的模板。所以请仔细阅读本节，即使你已经使用过链表。</p>\n<blockquote>\n<p><strong>定义</strong>。链表是一种递归的数据结构，它或者为空（<code>null</code>），或者是含有泛型元素的结点和指向另一个链表的引用。</p>\n</blockquote>\n<p>在这个定义中，<strong>结点</strong>是一个可能含有任意类型数据的抽象实体，它所包含的指向结点的应用显示了它在构造链表之中的作用。和递归程序一样，递归数据结构的概念一开始也令人费解，但其实它的简洁性赋予了它巨大的价值。</p>\n<h4>1.3.3.1　结点记录</h4>\n<p>在面向对象编程中，实现链表并不困难。我们首先用一个<strong>嵌套类</strong>来定义结点的抽象数据类型：</p>\n<pre class=\"code-rows\"><code>private class Node\n{\n   Item item;\n   Node next;\n}</code></pre>\n<p>一个 <code>Node</code> 对象含有两个实例变量，类型分别为 <code>Item</code>（参数类型）和 <code>Node</code>。我们会在需要使用 <code>Node</code> 类的类中定义它并将它标记为 <code>private</code>，因为它不是为用例准备的。和任意数据类型一样，我们通过<code>new Node()</code> 触发（无参数的）构造函数来创建一个<code>Node</code> 类型的对象。调用的结果是一个指向 <code>Node</code> 对象的引用，它的实例变量均被初始化为 <code>null</code>。<code>Item</code> 是一个占位符，表示我们希望用链表处理的任意数据类型（我们将会使用 Java 的泛型使之表示任意引用类型）；<code>Node</code> 类型的实例变量显示了这种数据结构的链式本质。为了强调我们在组织数据时只使用了 <code>Node</code> 类，我们没有定义任何方法且会在代码中直接引用实例变量：如果 <code>first</code> 是一个指向某个 <code>Node</code> 对象的变量，我们可以使用 <code>first.item</code> 和 <code>first.next</code> 访问它的实例变量。这种类型的类有时也被称为<strong>记录</strong>。它们实现的不是抽象数据类型，因为我们会直接使用其实例变量。但是在我们的实现中，<code>Node</code> 和它的用例代码都会被封装在相同的类中且无法被该类的用例访问，所以我们仍然能够享受数据抽象的好处。</p>\n<h4>1.3.3.2　构造链表</h4>\n<p>现在，根据递归定义，我们只需要一个 <code>Node</code> 类型的变量就能表示一条链表，只要保证它的值是 <code>null</code> 或者指向另一个 <code>Node</code> 对象且该对象的 <code>next</code> 域指向了另一条链表即可。例如，要构造一条含有元素<code>to</code>、<code>be</code> 和 <code>or</code> 的链表，我们首先为每个元素创造一个结点：</p>\n<pre class=\"code-rows\"><code>Node first  = new Node();\nNode second = new Node();\nNode third  = new Node();</code></pre>\n<p>并将每个结点的 <code>item</code> 域设为所需的值（简单起见，我们假设在这些例子中 <code>Item</code> 为 <code>String</code>）：</p>\n<pre class=\"code-rows\"><code>first.item  = \"to\";\nsecond.item = \"be\";\nthird.item  = \"or\";</code></pre>\n<p>然后设置 <code>next</code> 域来构造链表：</p>\n<pre class=\"code-rows\"><code>first.next  = second;\nsecond.next = third;</code></pre>\n<p>（注意：<code>third.next</code> 仍然是 <code>null</code>，即对象创建时它被初始化的值。）结果是，<code>third</code> 是一条链表（它是一个结点的引用，该结点指向 <code>null</code>，即一个空链表），<code>second</code> 也是一条链表（它是一个结点的引用，且该结点含有一个指向 <code>third</code> 的引用，而 <code>third</code> 是一条链表），<code>first</code> 也是一条链表（它是一个结点的引用，且该结点含有一个指向 <code>second</code> 的引用，而 <code>second</code> 是一条链表）。图 1.3.5 所示的代码以不同的顺序完成了这些赋值语句。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00873.gif\" alt=\"\" width=\"60%\" style=\"width: 60%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 1.3.5　用链接构造一条链表</strong></p>\n<p><strong>链表表示的是一列元素</strong>。在我们刚刚考察过的例子中，<code>first</code> 表示的序列是 <code>to</code>、<code>be</code>、<code>or</code>。我们也可以用一个数组来表示一列元素。例如，可以用以下数组表示同一列字符串：</p>\n<pre class=\"code-rows\"><code>String[] s = { \"to\", \"be\", \"or\" };</code></pre>\n<p>不同之处在于，在链表中向序列插入元素或是从序列中删除元素都更方便。下面，我们来学习完成这些任务的代码。</p>\n<p>在追踪使用链表和其他链式结构的代码时，我们会使用可视化表示方法：</p>\n<ul>\n<li>用长方形表示对象；</li>\n<li>将实例变量的值写在长方形中；</li>\n<li>用指向被引用对象的箭头表示引用关系。</li>\n</ul>\n<p>这种表示方式抓住了链表的关键特性。方便起见，我们用术语<strong>链接</strong>表示对结点的引用。简单起见，当元素的值为字符串时（如我们的例子所示），我们会将字符串写在长方形之内，而非使用 1.2 节中所讨论的更准确的方式表示字符串对象和字符数组。这种可视化的表示方式使我们能够将注意力集中在链表上。</p>\n<h4>1.3.3.3　在表头插入结点</h4>\n<p>首先，假设你希望向一条链表中插入一个新的结点。最容易做到这一点的地方就是链表的开头。例如，要在首结点为<code>first</code> 的给定链表开头插入字符串<code>not</code>，我们先将<code>first</code> 保存在<code>oldfirst</code> 中，然后将一个新结点赋予 <code>first</code>，并将它的 <code>item</code> 域设为 <code>not</code>，<code>next</code> 域设为 <code>oldfirst</code>。以上过程如图 1.3.6 所示。这段在链表开头插入一个结点的代码只需要几行赋值语句，所以它所需的时间和链表的长度无关。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00874.gif\" alt=\"\" width=\"75%\" style=\"width: 75%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 1.3.6　在链表的开头插入一个新结点</strong></p>\n<h4>1.3.3.4　从表头删除结点</h4>\n<p>接下来，假设你希望删除一条链表的首结点。这个操作更简单：只需将 <code>first</code> 指向 <code>first.next</code> 即可。一般来说你可能会希望在赋值之前得到该元素的值，因为一旦改变了 <code>first</code> 的值，就再也无法访问它曾经指向的结点了。曾经的结点对象变成了一个孤儿，Java 的内存管理系统最终将回收它所占用的内存。和以前一样，这个操作只含有一条赋值语句，因此它的运行时间和链表的长度无关。此过程如图 1.3.7 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00875.gif\" alt=\"\" width=\"65%\" style=\"width: 65%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 1.3.7　删除链表的首结点</strong></p>\n<h4>1.3.3.5　在表尾插入结点</h4>\n<p>如何才能在链表的<strong>尾部</strong>添加一个新结点？要完成这个任务，我们需要一个指向链表最后一个结点的链接，因为该结点的链接必须被修改并指向一个含有新元素的新结点。我们不能在链表代码中草率地决定维护一个额外的链接，因为每个修改链表的操作都需要添加检查是否要修改该变量（以及作出相应修改）的代码。例如，我们刚刚讨论过的删除链表首结点的代码就可能改变指向链表的尾结点的引用，因为当链表中只有一个结点时，它既是首结点又是尾结点！另外，这段代码也无法处理链表为空的情况（它会使用空链接）。类似这些情况的细节使链表代码特别难以调试。在链表结尾插入新结点的过程如图 1.3.8 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00876.gif\" alt=\"\" width=\"75%\" style=\"width: 75%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 1.3.8　在链表的结尾插入一个新结点</strong></p>\n<h4>1.3.3.6　其他位置的插入和删除操作</h4>\n<p>总的来说，我们已经展示了在链表中如何通过若干指令实现以下操作，其中我们可以通过<code>first</code> 链接访问链表的首结点并通过 <code>last</code> 链接访问链表的尾结点：</p>\n<ul>\n<li>在表头插入结点；</li>\n<li>从表头删除结点；</li>\n<li>在表尾插入结点。</li>\n</ul>\n<p>其他操作，例如以下几种，就不那么容易实现了：</p>\n<ul>\n<li>删除指定的结点；</li>\n<li>在指定结点前插入一个新结点。</li>\n</ul>\n<p>例如，我们怎样才能删除链表的尾结点呢？<code>last</code> 链接帮不上忙，因为我们需要将链表尾结点的前一个结点中的链接（它指向的正是 <code>last</code>）值改为 <code>null</code>。在缺少其他信息的情况下，唯一的解决办法就是遍历整条链表并找出指向 <code>last</code> 的结点（请见下文以及练习 1.3.19）。这种解决方案并不是我们想要的，因为它所需的时间和链表的长度成正比。实现任意插入和删除操作的标准解决方案是使用<strong>双向链表</strong>，其中每个结点都含有两个链接，分别指向不同的方向。我们将实现这些操作的代码留做练习（请见练习 1.3.31）。我们的所有实现都不需要双向链表。</p>\n<h4>1.3.3.7　遍历</h4>\n<p>要访问一个数组中的所有元素，我们会使用如下代码来循环处理 <code>a[]</code> 中的所有元素：</p>\n<pre class=\"code-rows\"><code>for (int i = 0; i &lt; N; i++)\n{\n   // 处理a[i]\n}</code></pre>\n<p>访问链表中的所有元素也有一个对应的方式：将循环的索引变量 <code>x</code> 初始化为链表的首结点，然后通过 <code>x.item</code> 访问和 <code>x</code> 相关联的元素，并将 <code>x</code> 设为 <code>x.next</code> 来访问链表中的下一个结点，如此反复直到 <code>x</code> 为 <code>null</code> 为止（这说明我们已经到达了链表的结尾）。这个过程被称为链表的<strong>遍历</strong>，可以用以下循环处理链表的每个结点的代码简洁表达，其中 <code>first</code> 指向链表的首结点：</p>\n<pre class=\"code-rows\"><code>for (Node x = first; x != null; x = x.next)\n{\n   // 处理x.item\n}</code></pre>\n<p>这种方式和迭代遍历一个数组中的所有元素的标准方式一样自然。在我们的实现中，它是迭代器使用的基本方式，它使用例能够迭代访问链表的所有元素而无需知道链表的实现细节。</p>\n<h4>1.3.3.8　栈的实现</h4>\n<p>有了这些预备知识，给出我们的<code>Stack</code> API 的实现就很简单了，如 94 页的算法 1.2 所示。它将栈保存为一条链表，栈的顶部即为表头，实例变量 <code>first</code> 指向栈顶。这样，当使用 <code>push()</code> 压入一个元素时，我们会按照 1.3.3.3 节所讨论的代码将该元素添加在表头；当使用<code>pop()</code> 删除一个元素时，我们会按照 1.3.3.4 节讨论的代码将该元素从表头删除。要实现 <code>size()</code> 方法，我们用实例变量 <code>N</code> 保存元素的个数，在压入元素时将 <code>N</code> 加 1，在弹出元素时将 <code>N</code> 减 1。要实现 <code>isEmpty()</code> 方法，只需检查 <code>first</code> 是否为 <code>null</code>（或者可以检查 <code>N</code> 是否为 0）。该实现使用了泛型的 <code>Item</code>——你可以认为类名后的 <code>&lt;Item&gt;</code> 表示的是实现中所出现的所有 <code>Item</code> 都会替换为用例所提供的任意数据类型的名称（请见 1.3.2.2 节）。我们暂时省略了关于迭代的代码并将它们留到算法 1.4 中继续讨论。图 1.3.9 显示了我们所常用的测试用例的轨迹（测试用例代码放在了图后面）。链表的使用达到了我们的最优设计目标：</p>\n<ul>\n<li>它可以处理任意类型的数据；</li>\n<li>所需的空间总是和集合的大小成正比；</li>\n<li>操作所需的时间总是和集合的大小无关。</li>\n</ul>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00877.gif\" alt=\"\" width=\"80%\" style=\"width: 80%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 1.3.9　<code>stack</code> 的开发用例的轨迹</strong></p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00878.gif\" alt=\"\" width=\"85%\" style=\"width: 85%\" /></p>\n<p style=\"text-align: center\"><code>Stack</code> 的测试用例</p>\n<p>这份实现是我们对许多<strong>算法</strong>的实现的原型。它定义了链表<strong>数据结构</strong>并实现了供用例使用的方法 <code>push()</code> 和<code>pop()</code>，仅用了少量代码就取得了所期望的效果。算法和数据结构是相辅相成的。在本例中，算法的实现代码很简单，但数据结构的性质却并不简单，我们用了好几页纸来说明这些性质。这种数据结构的定义和算法的实现的相互作用很常见，也是本书中我们对抽象数据类型的实现重点。</p>\n<blockquote>\n<p><strong>算法 1.2　下压堆栈（链表实现）</strong></p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00879.gif\" alt=\"\" width=\"90%\" style=\"width: 90%\" /></p>\n<p>这份泛型的<code>Stack</code> 实现的基础是链表数据结构。它可以用于创建任意数据类型的栈。要支持迭代，请添加算法1.4中为<code>Bag</code>数据类型给出的加粗部分的代码。</p>\n<pre class=\"code-rows\"><code>% more tobe.txt\nto be or not to - be - - that - - - is\n\n% java Stack &lt; tobe.txt\nto be not that or be (2 left on stack)</code></pre>\n</blockquote>\n<h4>1.3.3.9　队列的实现</h4>\n<p>基于链表数据结构实现 <code>Queue</code> API 也很简单，如算法 1.3 所示。它将队列表示为一条从最早插入的元素到最近插入的元素的链表，实例变量 <code>first</code> 指向队列的开头，实例变量<code>last</code> 指向队列的结尾。这样，要将一个元素入列（<code>enqueue()</code>），我们就将它添加到表尾（请见图 1.3.8 中讨论的代码，但是在链表为空时需要将 <code>first</code> 和 <code>last</code> 都指向新结点）；要将一个元素出列（<code>dequeue()</code>），我们就删除表头的结点（代码和<code>Stack</code> 的<code>pop()</code> 方法相同，只是当链表为空时需要更新<code>last</code> 的值）。<code>size()</code> 和 <code>isEmpty()</code> 方法的实现和 <code>Stack</code> 相同。和 <code>Stack</code> 一样，<code>Queue</code> 的实现也使用了泛型参数 <code>Item</code>。这里我们省略了支持迭代的代码并将它们留到算法 1.4 中继续讨论。下面所示的是一个开发用例，它和我们在<code>Stack</code> 中使用的用例很相似，它的轨迹如算法 1.3 所示。<code>Queue</code> 的实现使用的<strong>数据结构</strong>和 <code>Stack</code> 相同——链表，但它实现了不同的添加和删除元素的<strong>算法</strong>，这也是用例所看到的后进先出和先进后出的区别所在。和刚才一样，我们用链表达到了最优设计目标：它可以处理任意类型的数据，所需的空间总是和集合的大小成正比，操作所需的时间总是和集合的大小无关。<span class=\"comment-number\">1</span></p>\n\n<pre class=\"code-rows\"><code>public static void main(String[] args)\n{  // 创建一个队列并操作字符串入列或出列\n\n   Queue&lt;String&gt; q = new Queue&lt;String&gt;();\n\n   while (!StdIn.isEmpty())\n   {\n      String item = StdIn.readString();\n      if (!item.equals(\"-\"))\n           q.enqueue(item);\n      else if (!q.isEmpty()) StdOut.print(q.dequeue() + \" \");\n   }\n\n   StdOut.println(\"(\" + q.size() + \" left on queue)\");\n}</code></pre>\n<p style=\"text-align: center\"><code>Queue</code> 的测试用例</p>\n<pre class=\"code-rows\"><code>% more tobe.txt\nto be or not to - be - - that - - - is\n\n% java Queue &lt; tobe.txt\nto be or not to be (2 left on queue)</code></pre>\n<blockquote>\n<p><strong>算法 1.3　先进先出队列</strong></p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00880.gif\" alt=\"\" width=\"90%\" style=\"width: 90%\" /></p>\n<p>这份泛型的<code>Queue</code> 实现的基础是链表数据结构。它可以用于创建任意数据类型的队列。要支持迭代，请添加算法 1.4 中为<code>Bag</code> 数据类型给出的加粗部分的代码。</p>\n</blockquote>\n<p><code>Queue</code> 的开发用例的轨迹如图 1.3.10 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00881.gif\" alt=\"\" width=\"80%\" style=\"width: 80%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 1.3.10　<code>Queue</code> 的开发用例的轨迹</strong></p>\n<p>在结构化存储数据集时，<strong>链表是数组的一种重要的替代方式</strong>。这种替代方案已经有数十年的历史。事实上，编程语言历史上的一块里程碑就是 McCathy 在 20 世纪 50 年代发明的 LISP 语言，而链表则是这种语言组织程序和数据的主要结构。在练习中你会发现，链表编程也会遇到各种问题，且调试十分困难。在现代编程语言中，安全指针、自动垃圾回收（请见 1.2 节答疑部分）和抽象数据类型的使用使我们能够将链表处理的代码封装在若干个类中，正如本文所述。</p>\n<h4>1.3.3.10　背包的实现</h4>\n<p>用链表数据结构实现我们的 <code>Bag</code> API 只需要将 <code>Stack</code> 中的 <code>push()</code> 改名为 <code>add()</code>，并去掉 <code>pop()</code> 的实现即可，如算法 1.4 所示（也可以用相同的方法实现 <code>Queue</code>，但需要的代码更多）。在这份实现中，加粗部分的代码可以通过遍历链表使 <code>Stack</code>、<code>Queue</code> 和 <code>Bag</code> 变为可迭代的。对于 <code>Stack</code>，链表的访问顺序是后进先出；对于 <code>Queue</code>，链表的访问顺序是先进先出；对于 <code>Bag</code>，它正好也是后进先出的顺序，但顺序在这里并不重要。如算法 1.4 中加粗部分的代码所示，要在集合数据类型中实现迭代，第一步就是要添加下面这行代码，这样我们的代码才能引用 Java 的 Iterator 接口：</p>\n<pre class=\"code-rows\"><code>import java.util.Iterator;</code></pre>\n<p>第二步是在类的声明中添加这行代码，它保证了类必然会提供一个 <code>iterator()</code> 方法：</p>\n<pre class=\"code-rows\"><code>implements Iterable&lt;Item&gt;</code></pre>\n<p><code>iterator()</code> 方法本身只是简单地从实现了 Iterator 接口的类中返回一个对象：</p>\n<pre class=\"code-rows\"><code>public Iterator&lt;Item&gt; iterator()\n{  return new ListIterator(); }</code></pre>\n<p>这段代码保证了类必然会实现方法<code>hasNext()</code>、<code>next()</code> 和 <code>remove()</code> 供用例的 <code>foreach</code> 语法使用。要实现这些方法，算法 1.4 中的嵌套类 <code>ListIterator</code> 维护了一个实例变量 <code>current</code> 来记录链表的当前结点。<code>hasNext()</code> 方法会检测 <code>current</code> 是否为 <code>null</code>，<code>next()</code> 方法会保存当前元素的引用，将 <code>current</code> 变量指向链表中的下个结点并返回所保存的引用。</p>\n<blockquote>\n<p><strong>算法 1.4　背包</strong></p>\n<pre class=\"code-rows\"><code>import java.util.Iterator;\npublic class Bag&lt;Item&gt; implements Iterable&lt;Item&gt;\n{\n   private Node first;  // 链表的首结点\n   private class Node\n   {\n       Item item;\n       Node next;\n   }\n   public void add(Item item)\n   {  // 和Stack 的push() 方法完全相同\n      Node oldfirst = first;\n      first = new Node();\n      first.item = item;\n      first.next = oldfirst;\n   }\n   public Iterator&lt;Item&gt; iterator()\n   {  return new ListIterator();  }\n   private class ListIterator implements Iterator&lt;Item&gt;\n   {\n       private Node current = first;\n       public boolean hasNext()\n       {  return current != null;  }\n       public void remove() { }\n       public Item next()\n       {\n           Item item = current.item;\n           current = current.next;\n           return item;\n       }\n   }\n}</code></pre>\n<p>这份 <code>Bag</code> 的实现维护了一条链表，用于保存所有通过 <code>add()</code> 添加的元素。<code>size()</code> 和 <code>isEmpty()</code> 方法的代码和 <code>Stack</code> 中的完全相同，因此在此处省略。迭代器会遍历链表并将当前结点保存在 <code>current</code> 变量中。我们可以将加粗的代码添加到算法 1.2 和算法 1.3 中使 <code>Stack</code> 和 <code>Queue</code> 变为可迭代的，因为它们背后的数据结构是相同的，只是 <code>Stack</code> 和 <code>Queue</code> 的链表访问顺序分别是后进先出和先进先出而已。</p>\n</blockquote>\n<h3 id=\"nav_point_40\">1.3.4　综述</h3>\n<p>在本节中，我们所学习的支持泛型和迭代的背包、队列和栈的实现所提供的抽象使我们能够编写简洁的用例程序来操作对象的集合。深入理解这些抽象数据类型非常重要，这是我们研究算法和数据结构的开始。原因有三：第一，我们将以这些数据类型为基石构造本书中的其他更高级的数据结构；第二，它们展示了数据结构和算法的关系以及同时满足多个有可能相互冲突的性能目标时所要面对的挑战；第三，我们将要学习的若干算法的实现重点就是需要其中的抽象数据类型能够支持对对象集合的强大操作，这些实现正是我们的起点。</p>\n<p><strong>数据结构</strong></p>\n<p>我们现在拥有两种表示对象集合的方式，即数组和链表（如表 1.3.7 所示）。Java 内置了数组，链表也很容易使用 Java 的标准方法实现。两者都非常基础，常常被称为<strong>顺序存储</strong>和<strong>链式存储</strong>。在本书后面部分，我们会在各种抽象数据类型的实现中将多种方式结归并扩展这些基本的数据结构。其中一种重要的扩展就是各种含有多个链接的数据结构。例如，3.2 节和 3.3 节的重点就是被称为<strong>二叉树</strong>的数据结构，它由含有<strong>两个</strong>链接的结点组成。另一个重要的扩展是<strong>复合型</strong>的数据结构：我们可以使用背包存储栈，用队列存储数组，等等。例如，第 4 章的主题是图，我们可以用数组的背包表示它。用这种方式很容易定义任意复杂的数据结构，而我们重点研究抽象数据类型的一个重要原因就是试图控制这种复杂度。</p>\n<p><strong>表 1.3.7　基础数据结构</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>数据结构</p></th>\n<th><p>优点</p></th>\n<th><p>缺点</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>数组</p></td>\n<td><p>通过索引可以直接访问任意元素</p></td>\n<td><p>在初始化时就需要知道元素的数量</p></td>\n</tr>\n<tr>\n<td><p>链表</p></td>\n<td><p>使用的空间大小和元素数量成正比</p></td>\n<td><p>需要通过引用访问任意元素</p></td>\n</tr>\n</tbody>\n</table>\n<p>我们在本节中研究<strong>背包</strong>、<strong>队列</strong>和<strong>栈</strong>时描述数据结构和算法的方式是全书的原型（本书中的数据结构示例见表 1.3.8）。在研究一个新的应用领域时，我们将会按照以下步骤识别目标并使用数据抽象解决问题：</p>\n<ul>\n<li>定义 API；</li>\n<li>根据特定的应用场景开发用例代码；</li>\n<li>描述一种数据结构（一组值的表示），并在 API 所对应的抽象数据类型的实现中根据它定义类的<strong>实例变量</strong>；</li>\n<li>描述算法（实现一组操作的方式），并根据它实现类中的<strong>实例方法</strong>；</li>\n<li>分析算法的性能特点。</li>\n</ul>\n<p>在下一节中，我们会详细研究最后一步，因为它常常能够决定哪种算法和实现才是解决现实应用问题的最佳选择。</p>\n<p><strong>表 1.3.8　本书所给出的数据结构举例</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>数据结构</p></th>\n<th><p>章节</p></th>\n<th><p>抽象数据类型</p></th>\n<th><p>数据表示</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>父链接树</p></td>\n<td><p>1.5</p></td>\n<td><p><code>UnionFind</code></p></td>\n<td><p>整型数组</p></td>\n</tr>\n<tr>\n<td><p>二分查找树</p></td>\n<td><p>3.2、3.3</p></td>\n<td><p><code>BST</code></p></td>\n<td><p>含有两个链接的结点</p></td>\n</tr>\n<tr>\n<td><p>字符串</p></td>\n<td><p>5.1</p></td>\n<td><p><code>String</code></p></td>\n<td><p>数组、偏移量和长度</p></td>\n</tr>\n<tr>\n<td><p>二叉堆</p></td>\n<td><p>2.4</p></td>\n<td><p><code>PQ</code></p></td>\n<td><p>对象数组</p></td>\n</tr>\n<tr>\n<td><p>散列表（拉链法）</p></td>\n<td><p>3.4</p></td>\n<td><p><code>SeparateChainingHashST</code></p></td>\n<td><p>链表数组</p></td>\n</tr>\n<tr>\n<td><p>散列表（线性探测法）</p></td>\n<td><p>3.4</p></td>\n<td><p><code>LinearProbingHashST</code></p></td>\n<td><p>两个对象数组</p></td>\n</tr>\n<tr>\n<td><p>图的邻接链表</p></td>\n<td><p>4.1、4.2</p></td>\n<td><p><code>Graph</code></p></td>\n<td><p><code>Bag</code> 对象的数组</p></td>\n</tr>\n<tr>\n<td><p>单词查找树</p></td>\n<td><p>5.2</p></td>\n<td><p><code>TrieST</code></p></td>\n<td><p>含有链接数组的结点</p></td>\n</tr>\n<tr>\n<td><p>三向单词查找树</p></td>\n<td><p>5.3</p></td>\n<td><p><code>TST</code></p></td>\n<td><p>含有三个链接的结点</p></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"nav_point_41\">答疑</h3>\n<p><strong>问</strong>　并不是所有编程语言都支持泛型，甚至 Java 的早期版本也不支持。有其他替代方案吗？</p>\n<p><strong>答</strong>　如正文所述，一种替代方法是为每种类型的数据都实现一个不同的集合数据类型。另一种方法是构造一个 <code>Object</code> 对象的栈，并在用例中使用 <code>pop()</code> 时将得到的对象转换为所需的数据类型。这种方式的问题在于类型不匹配错误只能在运行时发现。而在泛型中，如果你的代码将错误类型的对象压入栈中，比如这样：</p>\n<pre class=\"code-rows\"><code>Stack&lt;Apple&gt; stack = new Stack&lt;Apple&gt;();\nApple  a = new Apple();\n...\nOrange b = new Orange();\n...\nstack.push(a);\n...\nstack.push(b);     // 编译时错误</code></pre>\n<p>　会得到一个编译时错误：</p>\n<pre class=\"code-rows\"><code>push(Apple) in Stack&lt;Apple&gt; cannot be applied to (Orange)</code></pre>\n<p>　能够在编译时发现错误足以说服我们使用泛型。</p>\n<p><strong>问</strong>　为什么 Java 不允许泛型数组？</p>\n<p><strong>答</strong>　专家们仍然在争论这一点。你可能也需要成为专家才能理解它！对于初学者，请先了解<strong>共变数组</strong>（covariant array）和<strong>类型擦除</strong>（type erasure）。</p>\n<p><strong>问</strong>　如何才能创建一个字符串栈的数组？</p>\n<p><strong>答</strong>　使用类型转换，比如：</p>\n<pre class=\"code-rows\"><code>Stack&lt;String&gt;[] a = (Stack&lt;String&gt;[]) new Stack[N];</code></pre>\n<p>　<strong>警告</strong>：这段类型转换的用例代码和 1.3.2.2 节所示的有所不同。你可能会以为需要使用<code>Object</code> 而非 <code>Stack</code>。在使用泛型时，Java 会在编译时检查类型的安全性，但会在运行时抛弃所有这些信息。因此在运行时语句右侧就变成了<code>Stack&lt;Object&gt;[]</code> 或者只剩下了 <code>Stack[]</code>，因此我们必须将它们转化为 <code>Stack&lt;String&gt;[]</code>。</p>\n<p><strong>问</strong>　在栈为空时调用 <code>pop()</code> 会发生什么？</p>\n<p><strong>答</strong>　这取决于实现。对于我们在算法 1.2 中给出的实现，你会得到一个 <code>NullPointerException</code> 异常。对于我们在本书的网站上给出的实现，我们会抛出一个运行时异常以帮助用户定位错误。一般来说，在应用广泛的代码中这类检查越多越好。</p>\n<p><strong>问</strong>　既然有了链表，为什么还要学习如何调整数组的大小？</p>\n<p><strong>答</strong>　我们还将会学习若干抽象数据类型的示例实现，它们需要使用数组来实现一些链表难以实现的操作。<code>ResizingArrayStack</code> 是控制它们的内存使用的样板。</p>\n<p><strong>问</strong>　为什么将 <code>Node</code> 声明为嵌套类？为什么使用 <code>private</code> ？</p>\n<p><strong>答</strong>　将 <code>Node</code> 声明为私有的嵌套类之后，我们可以将<code>Node</code> 的方法和实例变量的访问范围限制在包含它的类中。私有嵌套类的一个特点是只有包含它的类能够直接访问它的实例变量，因此无需将它的实例变量声明为<code>public</code> 或是 <code>private</code>。专业背景较强的读者<strong>注意</strong>：非静态的嵌套类也被称为<strong>内部</strong>类，因此从技术上来说我们的<code>Node</code> 类也是内部类，尽管非泛型的类也可以是静态的。</p>\n<p><strong>问</strong>　当我输入 <code>javac Stack.java</code> 编译算法 1.2 和其他程序时，我发现了 Stack.class 和 Stack$Node.class 两个文件。第二个文件是做什么用的？</p>\n<p><strong>答</strong>　第二个文件是为内部类 <code>Node</code> 创建的。Java 的命名规则会使用 <code>$</code> 分隔外部类和内部类。</p>\n<p><strong>问</strong>　Java 标准库中有栈和队列吗？</p>\n<p><strong>答</strong>　有，也没有。Java 有一个内置的库，叫做 java.util.Stack，但你需要栈的时候请不要使用它。它新增了几个一般不属于栈的方法，例如获取第 <code>i</code> 个元素。它还允许从栈底添加元素（而非栈顶），所以它可以被当做队列使用！尽管拥有这些额外的操作看起来可能很有用，但它们其实是累赘。我们使用某种数据类型不仅仅是为了获得我们能够想象的各种操作，也是为了准确地指定我们所需要的操作。这么做的主要好处在于系统能够防止我们执行一些意外的操作。java.util.Stack 的 API 是<strong>宽接口</strong>的一个典型例子，我们通常会极力避免出现这种情况。</p>\n<p><strong>问</strong>　是否允许用例向栈或队列中添加空（<code>null</code>）元素？</p>\n<p><strong>答</strong>　在 Java 中实现集合类数据类型时这个问题是很常见的。我们的实现（以及 Java 的栈和队列库）允许插入 <code>null</code> 值。</p>\n<p><strong>问</strong>　如果用例在迭代中调用 <code>push()</code> 或者 <code>pop()</code>，<code>Stack</code> 的迭代器应该怎么办？</p>\n<p><strong>答</strong>　作为一个<strong>快速出错</strong>的迭代器，它应该立即抛出一个<code>java.util.ConcurrentModificationException</code> 异常。请见练习 1.3.50。</p>\n<p><strong>问</strong>　我们能够用 <code>foreach</code> 循环访问数组吗？</p>\n<p><strong>答</strong>　可以（尽管数组没有实现 <code>Iterable</code> 接口）。以下代码将会打印所有命令行参数：</p>\n<pre class=\"code-rows\"><code>public static void main(String[] args)\n{  for (String s : args) StdOut.println(s);  }</code></pre>\n<p><strong>问</strong>　我们能够用 <code>foreach</code> 循环访问字符串吗？</p>\n<p><strong>答</strong>　不行，<code>String</code> 没有实现 <code>Iterable</code> 接口。</p>\n<p><strong>问</strong>　为什么不实现一个单独的 <code>Collection</code> 数据类型并实现添加元素、删除最近插入的元素、删除最早插入的元素、删除随机元素、迭代、返回集合元素数量和其他我们可能需要的方法？这样我们就能在一个类中实现所有这些方法并可以应用于各种用例。</p>\n<p><strong>答</strong>　再次强调一遍，这又是一个<strong>宽接口</strong>的例子。Java 在<code>java.util.ArrayList</code> 和<code>java.util.LinkedList</code> 类中实现了类似的设计。避免使用它们的一个原因是这样无法保证高效实现所有这些方法。在本书中，我们总是以 API 作为设计高效算法和数据结构的起点，而设计只含有几个操作的接口显然比设计含有许多操作的接口更简单。我们坚持窄接口的另一个原因是它们能够限制用例的行为，这将使用例代码更加易懂。如果一段用例代码使用 <code>Stack&lt;String&gt;</code>，而另一段用例代码使用 <code>Queue&lt;Transaction&gt;</code>，我们就可以知道后进先出的访问顺序对于前者很重要，而先进先出的访问顺序对于后者很重要。</p>\n<h3 id=\"nav_point_42\">练习</h3>\n<p><strong>1.3.1</strong>　为 <code>FixedCapacityStackOfStrings</code> 添加一个方法 <code>isFull()</code>。</p>\n<p><strong>1.3.2</strong>　给定以下输入，<code>java Stack</code> 的输出是什么？</p>\n<pre class=\"code-rows\"><code>it was - the best - of times - - - it was - the - -</code></pre>\n<p><strong>1.3.3</strong>　假设某个用例程序会进行一系列入栈和出栈的混合栈操作。入栈操作会将整数 0 到 9 按顺序压入栈；出栈操作会打印出返回值。下面哪种序列是<strong>不可能</strong>产生的？</p>\n<p>　a. <code>4 3 2 1 0 9 8 7 6 5</code></p>\n<p>　b. <code>4 6 8 7 5 3 2 9 0 1</code></p>\n<p>　c. <code>2 5 6 7 4 8 9 3 1 0</code></p>\n<p>　d. <code>4 3 2 1 0 5 6 7 8 9</code></p>\n<p>　e. <code>1 2 3 4 5 6 9 8 7 0</code></p>\n<p>　f. <code>0 4 6 5 3 8 1 7 2 9</code></p>\n<p>　g. <code>1 4 7 9 8 6 5 3 0 2</code></p>\n<p>　h. <code>2 1 4 3 6 5 8 7 9 0</code></p>\n<p><strong>1.3.4</strong>　编写一个 Stack 的用例 Parentheses，从标准输入中读取一个文本流并使用栈判定其中的括号是否配对完整。例如，对于 <code>[()]{}{[()()]()}</code> 程序应该打印 <code>true</code>，对于 <code>[(])</code> 则打印 <code>false</code>。</p>\n<p><strong>1.3.5</strong>　当 <code>N</code> 为 <code>50</code> 时下面这段代码会打印什么？从较高的抽象层次描述给定正整数 <code>N</code> 时这段代码的行为。</p>\n<pre class=\"code-rows\"><code>Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();\nwhile (N &gt; 0)\n{\n   stack.push(N % 2);\n   N = N / 2;\n}\nfor (int d : stack) StdOut.print(d);\nStdOut.println();</code></pre>\n<p>　<strong>答</strong>：打印 <code>N</code> 的二进制表示（当 <code>N</code> 为 <code>50</code> 时打印 <code>110010</code>）。</p>\n<p><strong>1.3.6</strong>　下面这段代码对队列 <code>q</code> 进行了什么操作？</p>\n<pre class=\"code-rows\"><code>Stack&lt;String&gt; stack = new Stack&lt;String&gt;();\nwhile (!q.isEmpty())\n   stack.push(q.dequeue());\nwhile (!stack.isEmpty())\n   q.enqueue(stack.pop());</code></pre>\n<p><strong>1.3.7</strong>　为 <code>Stack</code> 添加一个方法 <code>peek()</code>，返回栈中最近添加的元素（而不弹出它）。</p>\n<p><strong>1.3.8</strong>　给定以下输入，给出 <code>DoublingStackOfStrings</code> 的数组的内容和大小。</p>\n<pre class=\"code-rows\"><code>it was - the best - of times - - - it was - the - -</code></pre>\n<p><strong>1.3.9</strong>　编写一段程序，从标准输入得到一个缺少左括号的表达式并打印出补全括号之后的中序表达式。例如，给定输入：</p>\n<pre class=\"code-rows\"><code>1 + 2 ) * 3 - 4 ) * 5 - 6 ) ) )</code></pre>\n<p>　你的程序应该输出：</p>\n<pre class=\"code-rows\"><code>( ( 1 + 2 ) * ( ( 3 - 4 ) * ( 5 - 6 ) ) )</code></pre>\n<p><strong>1.3.10</strong>　编写一个过滤器 <code>InfixToPostfix</code>，将算术表达式由中序表达式转为后序表达式。</p>\n<p><strong>1.3.11</strong>　编写一段程序 EvaluatePostfix，从标准输入中得到一个后序表达式，求值并打印结果（将上一题的程序中得到的输出用管道传递给这一段程序可以得到和 <code>Evaluate</code> 相同的行为）。</p>\n<p><strong>1.3.12</strong>　编写一个可迭代的 Stack <strong>用例</strong>，它含有一个静态的<code>copy()</code> 方法，接受一个字符串的栈作为参数并返回该栈的一个副本。<strong>注意</strong>：这种能力是迭代器价值的一个重要体现，因为有了它我们无需改变基本 API 就能够实现这种功能。</p>\n<p><strong>1.3.13</strong>　假设某个用例程序会进行一系列<strong>入列</strong>和<strong>出列</strong>的混合队列操作。入列操作会将整数 0 到 9 按顺序插入队列；出列操作会打印出返回值。下面哪种序列是<strong>不可能</strong>产生的？</p>\n<p>　a. <code>0 1 2 3 4 5 6 7 8 9</code></p>\n<p>　b. <code>4 6 8 7 5 3 2 9 0 1</code></p>\n<p>　c. <code>2 5 6 7 4 8 9 3 1 0</code></p>\n<p>　d. <code>4 3 2 1 0 5 6 7 8 9</code></p>\n<p><strong>1.3.14</strong>　编写一个类 <code>ResizingArrayQueueOfStrings</code>，使用定长数组实现队列的抽象，然后扩展实现，使用调整数组的方法突破大小的限制。</p>\n<p><strong>1.3.15</strong>　编写一个 <code>Queue</code> 的用例，接受一个命令行参数 <code>k</code> 并打印出标准输入中的倒数第 <code>k</code> 个字符串（假设标准输入中至少有 <code>k</code> 个字符串）。</p>\n<p><strong>1.3.16</strong>　使用 1.3.1.5 节中的 <code>readInts()</code> 作为模板为 <code>Date</code> 编写一个静态方法 <code>readDates()</code>，从标准输入中读取由练习 1.2.19 的表格所指定的格式的多个日期并返回一个它们的数组。</p>\n<p><strong>1.3.17</strong>　为 <code>Transaction</code> 类完成练习 1.3.16。</p>\n<h3 id=\"nav_point_43\">链表练习</h3>\n<p><strong>这部分练习是专门针对链表的。建议：使用正文中所述的可视化表达方式画图</strong>。</p>\n<p><strong>1.3.18</strong>　假设 <code>x</code> 是一条链表的某个结点且不是尾结点。下面这条语句的效果是什么？</p>\n<pre class=\"code-rows\"><code>x.next = x.next.next;</code></pre>\n<p>　<strong>答</strong>：删除 <code>x</code> 的后续结点。</p>\n<p><strong>1.3.19</strong>　给出一段代码，删除链表的尾结点，其中链表的首结点为 <code>first</code>。</p>\n<p><strong>1.3.20</strong>　编写一个方法 <code>delete()</code>，接受一个 <code>int</code> 参数 <code>k</code>，删除链表的第 <code>k</code> 个元素（如果它存在的话）。</p>\n<p><strong>1.3.21</strong>　编写一个方法 <code>find()</code>，接受一条链表和一个字符串 <code>key</code> 作为参数。如果链表中的某个结点的 <code>item</code> 域的值为 <code>key</code>，则方法返回 <code>true</code>，否则返回 <code>false</code>。</p>\n<p><strong>1.3.22</strong>　假设 <code>x</code> 是一条链表中的某个结点，下面这段代码做了什么？</p>\n<pre class=\"code-rows\"><code>t.next = x.next;\nx.next = t;</code></pre>\n<p>　<strong>答</strong>：插入结点 <code>t</code> 并使它成为 <code>x</code> 的后续结点。</p>\n<p><strong>1.3.23</strong>　为什么下面这段代码和上一道题中的代码效果不同？</p>\n<pre class=\"code-rows\"><code>x.next = t;\nt.next = x.next;</code></pre>\n<p>　<strong>答</strong>：在更新 <code>t.next</code> 时，<code>x.next</code> 已经不再指向 <code>x</code> 的后续结点，而是指向 <code>t</code> 本身！</p>\n<p><strong>1.3.24</strong>　编写一个方法 <code>removeAfter()</code>，接受一个链表结点作为参数并删除该结点的后续结点（如果参数结点或参数结点的后续结点为空则什么也不做）。</p>\n<p><strong>1.3.25</strong>　编写一个方法<code>insertAfter()</code>，接受两个链表结点作为参数，将第二个结点插入链表并使之成为第一个结点的后续结点（如果两个参数为空则什么也不做）。</p>\n<p><strong>1.3.26</strong>　编写一个方法 <code>remove()</code>，接受一条链表和一个字符串 <code>key</code> 作为参数，删除链表中所有 <code>item</code> 域为 <code>key</code> 的结点。</p>\n<p><strong>1.3.27</strong>　编写一个方法<code>max()</code>，接受一条链表的首结点作为参数，返回链表中键最大的节点的值。假设所有键均为正整数，如果链表为空则返回 0。</p>\n<p><strong>1.3.28</strong>　用递归的方法解答上一道练习。</p>\n<p><strong>1.3.29</strong>　用<strong>环形</strong>链表实现<code>Queue</code>。环形链表也是一条链表，只是没有任何结点的链接为空，且只要链表非空则 <code>last.next</code> 的值为 <code>first</code>。只能使用一个 <code>Node</code> 类型的实例变量（<code>last</code>）。</p>\n<p><strong>1.3.30</strong>　编写一个函数，接受一条链表的首结点作为参数，（破坏性地）将链表反转并返回结果链表的首结点。</p>\n<p>　<strong>迭代方式的解答</strong>：为了完成这个任务，我们需要记录链表中三个连续的结点：<code>reverse</code>、<code>first</code> 和 <code>second</code>。在每轮迭代中，我们从原链表中提取结点 <code>first</code> 并将它插入到逆链表的开头。我们需要一直保持 <code>first</code> 指向原链表中所有剩余结点的首结点，<code>second</code> 指向原链表中所有剩余结点的第二个结点，<code>reverse</code> 指向结果链表中的首结点。</p>\n<pre class=\"code-rows\"><code>public Node reverse(Node x)\n{\n   Node first   = x;\n   Node reverse = null;\n   while (first != null)\n   {\n      Node second = first.next;\n      first.next  = reverse;\n      reverse     = first;\n      first       = second;\n   }\n   return reverse;\n}</code></pre>\n<p>　在编写和链表相关的代码时，我们必须小心处理异常情况（链表为空或是只有一个或两个结点）和边界情况（处理首尾结点）。它们通常比处理正常情况要困难得多。</p>\n<p>　<strong>递归解答</strong>：假设链表含有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个结点，我们先递归颠倒最后 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00799.gif\" alt=\"N-1\" inline-img=\"true\" /> 个结点，然后小心地将原链表中的首结点插入到结果链表的末端。</p>\n<pre class=\"code-rows\"><code>public Node reverse(Node first)\n{\n   if (first == null) return null;\n   if (first.next == null) return first;\n   Node second = first.next;\n   Node rest = reverse(second);\n   second.next = first;\n   first.next  = null;\n   return rest;\n}</code></pre>\n<p><strong>1.3.31</strong>　实现一个嵌套类 <code>DoubleNode</code> 用来构造双向链表，其中每个结点都含有一个指向前驱元素的引用和一项指向后续元素的引用（如果不存在则为 <code>null</code>）。为以下任务实现若干静态方法：在表头插入结点、在表尾插入结点、从表头删除结点、从表尾删除结点、在指定结点之前插入新结点、在指定结点之后插入新结点、删除指定结点。</p>\n<h3 id=\"nav_point_44\">提高题</h3>\n<p><strong>1.3.32</strong>　<code>Steque</code>。一个以栈为目标的队列（或称 <code>steque</code>），是一种支持 <code>push</code>、<code>pop</code> 和 <code>enqueue</code> 操作的数据类型。为这种抽象数据类型定义一份 API 并给出一份基于链表的实现。<span class=\"comment-number\">2</span></p>\n\n<p><strong>1.3.33</strong>　<code>Deque</code>。一个双向队列（或者称为 deque）和栈或队列类似，但它同时支持在两端添加或删除元素。<code>Deque</code> 能够存储一组元素并支持表 1.3.9 中的 API：</p>\n<p>　<strong>表 1.3.9　泛型双向队列的 API</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td colspan=\"2\"><code>public class <b>Deque</b>&lt;Item&gt; implements Iterable&lt;Item&gt;</code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deque()</code></td><td>创建空双向队列</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;&nbsp;isEmpty()</code></td><td>双向队列是否为空</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;size()</code></td><td>双向队列中的元素数量</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;&nbsp;pushLeft(Item item)</code></td><td>向左端添加一个新元素</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;&nbsp;pushRight(Item item)</code></td><td>向右端添加一个新元素</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Item&nbsp;&nbsp;&nbsp;popLeft()</code></td><td>从左端删除一个元素</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Item&nbsp;&nbsp;&nbsp;popRight()</code></td><td>从右端删除一个元素</td></tr>\n</table>\n\n<p>　编写一个使用双向链表实现这份 API 的 <code>Deque</code> 类，以及一个使用动态数组调整实现这份 API 的 <code>ResizingArrayDeque</code> 类。</p>\n<p><strong>1.3.34</strong>　<strong>随机背包</strong>。<strong>随机背包</strong>能够存储一组元素并支持表 1.3.10 中的 API：</p>\n<p>　<strong>表 1.3.10　泛型随机背包的 API</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td colspan=\"2\"><code>public class <b>RandomBag</b>&lt;Item&gt; implements Iterable&lt;Item&gt;</code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RandomBag()</code></td><td>创建一个空随机背包</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;&nbsp;isEmpty()</code></td><td>背包是否为空</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;size()</code></td><td>背包中的元素数量</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;&nbsp;add(Item item)</code></td><td>添加一个元素</td></tr>\n</table>\n\n<p>　编写一个<code>RandomBag</code> 类来实现这份API。请注意，除了形容词<strong>随机</strong>之外，这份API 和 <code>Bag</code> 的API 是相同的，这意味着迭代应该<strong>随机访问</strong>背包中的所有元素（对于每次迭代，所有的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00845.gif\" alt=\"N!\" inline-img=\"true\" /> 种排列出现的可能性均相同）。<strong>提示</strong>：用数组保存所有元素并在迭代器的构造函数中随机打乱它们的顺序。</p>\n<p><strong>1.3.35</strong>　<strong>随机队列</strong>。<strong>随机队列</strong>能够存储一组元素并支持表 1.3.11 中的 API：</p>\n<p>　<strong>表 1.3.11　泛型随机队列的 API</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td colspan=\"2\"><code>public class <b>RandomQueue</b>&lt;Item&gt;</code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RandomQueue()</code></td><td>创建一条空的随机队列</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;&nbsp;isEmpty()</code></td><td>队列是否为空</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;&nbsp;enqueue(Item item)</code></td><td>添加一个元素</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Item&nbsp;&nbsp;&nbsp;dequeue()</code></td><td>删除并随机返回一个元素（取样且不放回）</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Item&nbsp;&nbsp;&nbsp;sample()</code></td><td>随机返回一个元素但不删除它（取样且放回）</td></tr>\n</table>\n\n<p>　编写一个 <code>RandomQueue</code> 类来实现这份 API。<strong>提示</strong>：使用（能够动态调整大小的）数组表示数据。删除一个元素时，随机交换某个元素（索引在 <code>0</code> 和 <code>N-1</code> 之间）和末位元素（索引为<code>N-1</code>）的位置，然后像 <code>ResizingArrayStack</code> 一样删除并返回末位元素。编写一个用例，使用 <code>RandomQueue&lt;Card&gt;</code> 在桥牌中发牌（每人 13 张）。</p>\n<p><strong>1.3.36</strong>　<strong>随机迭代器</strong>。为上一题中的<code>RandomQueue&lt;Item&gt;</code> 编写一个迭代器，随机返回队列中的所有元素。</p>\n<p><strong>1.3.37</strong>　<code>Josephus</code> 问题。在这个古老的问题中，<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个身陷绝境的人一致同意通过以下方式减少生存人数。他们围坐成一圈（位置记为 0 到 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00799.gif\" alt=\"N-1\" inline-img=\"true\" />）并从第一个人开始报数，报到 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00801.gif\" alt=\"M\" inline-img=\"true\" /> 的人会被杀死，直到最后一个人留下来。传说中 Josephus 找到了不会被杀死的位置。编写一个 <code>Queue</code> 的用例 Josephus，从命令行接受<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 和<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00801.gif\" alt=\"M\" inline-img=\"true\" /> 并打印出人们被杀死的顺序（这也将显示Josephus 在圈中的位置）。</p>\n<pre class=\"code-rows\"><code>% java Josephus 7 2\n1 3 5 0 4 2 6</code></pre>\n<p><strong>1.3.38</strong>　<strong>删除第 k 个元素</strong>。实现一个类并支持表 1.3.12 中的 API：</p>\n<p><strong>表 1.3.12　泛型一般队列的 API</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td colspan=\"2\"><code>public class <b>GeneralizedQueue</b>&lt;Item&gt;</code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GeneralizedQueue()</code></td><td>创建一条空队列</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;&nbsp;isEmpty()</code></td><td>队列是否为空</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;&nbsp;insert(Item x)</code></td><td>添加一个元素</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Item&nbsp;&nbsp;&nbsp;delete(int k)</code></td><td>删除并返回最早插入的第 <code>k</code> 个元素</td></tr>\n</table>\n\n<p>　首先用数组实现该数据类型，然后用链表实现该数据类型。<strong>注意</strong>：我们在第 3 章中介绍的算法和数据结构可以保证 <code>insert()</code> 和 <code>delete()</code> 的实现所需的运行时间和和队列中的元素数量成对数关系——请见练习 3.5.27。</p>\n<p><strong>1.3.39</strong>　<strong>环形缓冲区</strong>。环形缓冲区，又称为环形队列，是一种定长为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的先进先出的数据结构。它在进程间的异步数据传输或记录日志文件时十分有用。当缓冲区为空时，消费者会在数据存入缓冲区前等待；当缓冲区满时，生产者会等待将数据存入缓冲区。为<code>RingBuffer</code> 设计一份API 并用（回环）数组将其实现。</p>\n<p><strong>1.3.40</strong>　<strong>前移编码</strong>。从标准输入读取一串字符，使用链表保存这些字符并清除重复字符。当你读取了一个从未见过的字符时，将它插入表头。当你读取了一个重复的字符时，将它从链表中删去并再次插入表头。将你的程序命名为 MoveToFront：它实现了著名的<strong>前移编码</strong>策略，这种策略假设最近访问过的元素很可能会再次访问，因此可以用于缓存、数据压缩等许多场景。</p>\n<p><strong>1.3.41</strong>　<strong>复制队列</strong>。编写一个新的构造函数，使以下代码</p>\n<pre class=\"code-rows\"><code>Queue&lt;Item&gt; r = new Queue&lt;Item&gt;(q);</code></pre>\n<p>　得到的 <code>r</code> 指向队列 <code>q</code> 的一个新的独立的副本。可以对 <code>q</code> 或 <code>r</code> 进行任意入列或出列操作但它们不会相互影响。<strong>提示</strong>：从<code>q</code> 中取出所有元素再将它们插入 <code>q</code> 和 <code>r</code>。</p>\n<p><strong>1.3.42</strong>　<strong>复制栈</strong>。为基于链表实现的栈编写一个新的构造函数，使以下代码</p>\n<pre class=\"code-rows\"><code>Stack&lt;Item&gt; t = new Stack&lt;Item&gt;(s);</code></pre>\n<p>　得到的 <code>t</code> 指向栈 <code>s</code> 的一个新的独立的副本。</p>\n<p><strong>1.3.43</strong>　<strong>文件列表</strong>。文件夹就是一列文件和文件夹的列表。编写一个程序，从命令行接受一个文件夹名作为参数，打印出该文件夹下的所有文件并用递归的方式在所有子文件夹的名下（缩进）列出其下的所有文件。<strong>提示</strong>：使用队列，并参考 java.io.File。</p>\n<p><strong>1.3.44</strong>　<strong>文本编辑器的缓冲区</strong>。为文本编辑器的缓冲区设计一种数据类型并实现表 1.3.13 中的 API。</p>\n<p>　<strong>表 1.3.13　文本缓冲区的 API</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td colspan=\"2\"><code>Public class <b>Buffer</b></code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Buffer()</code></td><td>创建一块空缓冲区</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;&nbsp;insert(char c)</code></td><td>在光标位置插入字符 <code>c</code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;&nbsp;&nbsp;delete()</code></td><td>删除并返回光标位置的字符</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;&nbsp;left(int k)</code></td><td>将光标向左移动 <code>k</code> 个位置</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;&nbsp;right(int k)</code></td><td>将光标向右移动 <code>k</code> 个位置</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;size()</code></td><td>缓冲区中的字符数量\n</td></tr></table>\n\n<p>　<strong>提示</strong>：使用两个栈。</p>\n<p><strong>1.3.45</strong>　<strong>栈的可生成性</strong>。假设我们的栈测试用例将会进行一系列混合的入栈和出栈操作，序列中的整数<code>0,1,...,N-1</code>（按此先后顺序排列）表示入栈操作，<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个减号表示出栈操作。设计一个算法，判定给定的混合序列是否会使数组向下溢出（你所使用的空间量与 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 无关，即不能用某种数据结构存储所有整数）。设计一个线性时间的算法判定我们的测试用例能否产生某个给定的排列（这取决于<strong>出栈</strong>操作指令的出现位置）。</p>\n<p>　<strong>解答</strong>：除非对于某个整数 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00842.gif\" alt=\"k\" inline-img=\"true\" />，前 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00842.gif\" alt=\"k\" inline-img=\"true\" /> 次出栈操作会在前 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00842.gif\" alt=\"k\" inline-img=\"true\" /> 次入栈操作前完成，否则栈不会向下溢出。如果某个排列可以产生，那么它产生的方式一定是唯一的：如果输出排列中的下一个整数在栈顶，则将它弹出，否则将它压入栈之中。</p>\n<p><strong>1.3.46</strong>　<strong>栈可生成性问题中禁止出现的排列</strong>。若三元组(a,b,c) 中a&lt;b&lt;c 且c 最先被弹出，a 第二，b 第三（c 和 a 以及 a 和 b 之间可以间隔其他整数），那么当且仅当排列中不含这样的三元组时（如上题所述的）栈才可能生成它。</p>\n<p>　<strong>部分解答</strong>：设有一个这样的三元组(a,b,c)。c 会在a 和b 之前被弹出，但 a 和b 会在c 之前被压入。因此，当 c 被压入时，a 和 b 都已经在栈之中了。所以，a 不可能在 b 之前被弹出。</p>\n<p><strong>1.3.47</strong>　<strong>可连接的队列、栈或steque</strong>。为队列、栈或steque（请见练习 1.3.32）添加一个能够（破坏性地）连接两个同类对象的额外操作<code>catenation</code>。</p>\n<p><strong>1.3.48</strong>　<strong>双向队列与栈</strong>。用一个双向队列实现两个栈，保证每个栈操作只需要常数次的双向队列操作（请见练习 1.3.33）。</p>\n<p><strong>1.3.49</strong>　<strong>栈与队列</strong>。用有限个栈实现一个队列，保证每个队列操作（在最坏情况下）都只需要常数次的栈操作。<strong>警告</strong>：非常难！</p>\n<p><strong>1.3.50</strong>　<strong>快速出错的迭代器</strong>。修改 <code>Stack</code> 的迭代器代码，确保一旦用例在迭代器中（通过<code>push()</code> 或<code>pop()</code> 操作）修改集合数据就抛出一个<code>java.util.ConcurrentModificationException</code> 异常。<strong>解答</strong>：用一个计数器记录 <code>push()</code> 和 <code>pop()</code> 操作的次数。在创建迭代器时，将该值记录到 <code>Iterator</code> 的一个实例变量中。在每次调用<code>hasNext()</code> 和<code>next()</code> 之前，检查该值是否发生了变化，如果变化则抛出异常。</p>\n","neighbors":{"left":{"article_title":"1.2 数据抽象","id":740932},"right":{"article_title":"1.4 算法分析","id":740934}},"comments":[]}