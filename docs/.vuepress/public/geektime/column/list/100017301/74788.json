{"id":74788,"title":"40 | 初识动态规划：如何巧妙解决“双十一”购物时的凑单问题？","content":"<p>淘宝的“双十一”购物节有各种促销活动，比如“满200元减50元”。假设你女朋友的购物车中有n个（n&gt;100）想买的商品，她希望从里面选几个，在凑够满减条件的前提下，让选出来的商品价格总和最大程度地接近满减条件（200元），这样就可以极大限度地“薅羊毛”。作为程序员的你，能不能编个代码来帮她搞定呢？</p><p>要想高效地解决这个问题，就要用到我们今天讲的动态规划（Dynamic Programming）。</p><h2>动态规划学习路线</h2><p>动态规划比较适合用来求解最优问题，比如求最大值、最小值等等。它可以非常显著地降低时间复杂度，提高代码的执行效率。不过，它也是出了名的难学。它的主要学习难点跟递归类似，那就是，求解问题的过程不太符合人类常规的思维方式。对于新手来说，要想入门确实不容易。不过，等你掌握了之后，你会发现，实际上并没有想象中那么难。</p><p>为了让你更容易理解动态规划，我分了三节给你讲解。这三节分别是，初识动态规划、动态规划理论、动态规划实战。</p><p>第一节，我会通过两个非常经典的动态规划问题模型，向你展示我们为什么需要动态规划，以及动态规划解题方法是如何演化出来的。实际上，你只要掌握了这两个例子的解决思路，对于其他很多动态规划问题，你都可以套用类似的思路来解决。</p><!-- [[[read_end]]] --><p>第二节，我会总结动态规划适合解决的问题的特征，以及动态规划解题思路。除此之外，我还会将贪心、分治、回溯、动态规划这四种算法思想放在一起，对比分析它们各自的特点以及适用的场景。</p><p>第三节，我会教你应用第二节讲的动态规划理论知识，实战解决三个非常经典的动态规划问题，加深你对理论的理解。弄懂了这三节中的例子，对于动态规划这个知识点，你就算是入门了。</p><h2>0-1背包问题</h2><p>我在讲贪心算法、回溯算法的时候，多次讲到背包问题。今天，我们依旧拿这个问题来举例。</p><p>对于一组不同重量、不可分割的物品，我们需要选择一些装入背包，在满足背包最大重量限制的前提下，背包中物品总重量的最大值是多少呢？</p><p>关于这个问题，我们上一节讲了回溯的解决方法，也就是穷举搜索所有可能的装法，然后找出满足条件的最大值。不过，回溯算法的复杂度比较高，是指数级别的。那有没有什么规律，可以有效降低时间复杂度呢？我们一起来看看。</p><pre><code>// 回溯算法实现。注意：我把输入的变量都定义成了成员变量。\nprivate int maxW = Integer.MIN_VALUE; // 结果放到maxW中\nprivate int[] weight = {2，2，4，6，3};  // 物品重量\nprivate int n = 5; // 物品个数\nprivate int w = 9; // 背包承受的最大重量\npublic void f(int i, int cw) { // 调用f(0, 0)\n  if (cw == w || i == n) { // cw==w表示装满了，i==n表示物品都考察完了\n    if (cw &gt; maxW) maxW = cw;\n    return;\n  }\n  f(i+1, cw); // 选择不装第i个物品\n  if (cw + weight[i] &lt;= w) {\n    f(i+1,cw + weight[i]); // 选择装第i个物品\n  }\n}\n</code></pre><p>规律是不是不好找？那我们就举个例子、画个图看看。我们假设背包的最大承载重量是9。我们有5个不同的物品，每个物品的重量分别是2，2，4，6，3。如果我们把这个例子的回溯求解过程，用递归树画出来，就是下面这个样子：</p><p><img src=\"https://static001.geekbang.org/resource/image/42/ea/42ca6cec4ad034fc3e5c0605fbacecea.jpg?wh=1142*748\" alt=\"\"></p><p>递归树中的每个节点表示一种状态，我们用（i, cw）来表示。其中，i表示将要决策第几个物品是否装入背包，cw表示当前背包中物品的总重量。比如，（2，2）表示我们将要决策第2个物品是否装入背包，在决策前，背包中物品的总重量是2。</p><p>从递归树中，你应该能会发现，有些子问题的求解是重复的，比如图中f(2, 2)和f(3,4)都被重复计算了两次。我们可以借助<a href=\"https://time.geekbang.org/column/article/41440\">递归</a>那一节讲的“备忘录”的解决方式，记录已经计算好的f(i, cw)，当再次计算到重复的f(i, cw)的时候，可以直接从备忘录中取出来用，就不用再递归计算了，这样就可以避免冗余计算。</p><pre><code>private int maxW = Integer.MIN_VALUE; // 结果放到maxW中\nprivate int[] weight = {2，2，4，6，3};  // 物品重量\nprivate int n = 5; // 物品个数\nprivate int w = 9; // 背包承受的最大重量\nprivate boolean[][] mem = new boolean[5][10]; // 备忘录，默认值false\npublic void f(int i, int cw) { // 调用f(0, 0)\n  if (cw == w || i == n) { // cw==w表示装满了，i==n表示物品都考察完了\n    if (cw &gt; maxW) maxW = cw;\n    return;\n  }\n  if (mem[i][cw]) return; // 重复状态\n  mem[i][cw] = true; // 记录(i, cw)这个状态\n  f(i+1, cw); // 选择不装第i个物品\n  if (cw + weight[i] &lt;= w) {\n    f(i+1,cw + weight[i]); // 选择装第i个物品\n  }\n}\n</code></pre><p>这种解决方法非常好。实际上，它已经跟动态规划的执行效率基本上没有差别。但是，多一种方法就多一种解决思路，我们现在来看看动态规划是怎么做的。</p><p>我们把整个求解过程分为n个阶段，每个阶段会决策一个物品是否放到背包中。每个物品决策（放入或者不放入背包）完之后，背包中的物品的重量会有多种情况，也就是说，会达到多种不同的状态，对应到递归树中，就是有很多不同的节点。</p><p>我们把每一层重复的状态（节点）合并，只记录不同的状态，然后基于上一层的状态集合，来推导下一层的状态集合。我们可以通过合并每一层重复的状态，这样就保证每一层不同状态的个数都不会超过w个（w表示背包的承载重量），也就是例子中的9。于是，我们就成功避免了每层状态个数的指数级增长。</p><p>我们用一个二维数组states[n][w+1]，来记录每层可以达到的不同状态。</p><p>第0个（下标从0开始编号）物品的重量是2，要么装入背包，要么不装入背包，决策完之后，会对应背包的两种状态，背包中物品的总重量是0或者2。我们用states[0][0]=true和states[0][2]=true来表示这两种状态。</p><p>第1个物品的重量也是2，基于之前的背包状态，在这个物品决策完之后，不同的状态有3个，背包中物品总重量分别是0(0+0)，2(0+2 or 2+0)，4(2+2)。我们用states[1][0]=true，states[1][2]=true，states[1][4]=true来表示这三种状态。</p><p>以此类推，直到考察完所有的物品后，整个states状态数组就都计算好了。我把整个计算的过程画了出来，你可以看看。图中0表示false，1表示true。我们只需要在最后一层，找一个值为true的最接近w（这里是9）的值，就是背包中物品总重量的最大值。</p><p><img src=\"https://static001.geekbang.org/resource/image/aa/b5/aaf51df520ea6b8056f4e62aed81a5b5.jpg?wh=1142*709\" alt=\"\"><img src=\"https://static001.geekbang.org/resource/image/bb/7e/bbbb934247219db8299bd46dba9dd47e.jpg?wh=1142*440\" alt=\"\"></p><p>文字描述可能还不够清楚。我把上面的过程，翻译成代码，你可以结合着一块看下。</p><pre><code>weight:物品重量，n:物品个数，w:背包可承载重量\npublic int knapsack(int[] weight, int n, int w) {\n  boolean[][] states = new boolean[n][w+1]; // 默认值false\n  states[0][0] = true;  // 第一行的数据要特殊处理，可以利用哨兵优化\n  if (weight[0] &lt;= w) {\n    states[0][weight[0]] = true;\n  }\n  for (int i = 1; i &lt; n; ++i) { // 动态规划状态转移\n    for (int j = 0; j &lt;= w; ++j) {// 不把第i个物品放入背包\n      if (states[i-1][j] == true) states[i][j] = states[i-1][j];\n    }\n    for (int j = 0; j &lt;= w-weight[i]; ++j) {//把第i个物品放入背包\n      if (states[i-1][j]==true) states[i][j+weight[i]] = true;\n    }\n  }\n  for (int i = w; i &gt;= 0; --i) { // 输出结果\n    if (states[n-1][i] == true) return i;\n  }\n  return 0;\n}\n</code></pre><p>实际上，这就是一种用动态规划解决问题的思路。我们把问题分解为多个阶段，每个阶段对应一个决策。我们记录每一个阶段可达的状态集合（去掉重复的），然后通过当前阶段的状态集合，来推导下一个阶段的状态集合，动态地往前推进。这也是动态规划这个名字的由来，你可以自己体会一下，是不是还挺形象的？</p><p>前面我们讲到，用回溯算法解决这个问题的时间复杂度O(2^n)，是指数级的。那动态规划解决方案的时间复杂度是多少呢？我来分析一下。</p><p>这个代码的时间复杂度非常好分析，耗时最多的部分就是代码中的两层for循环，所以时间复杂度是O(n*w)。n表示物品个数，w表示背包可以承载的总重量。</p><p>从理论上讲，指数级的时间复杂度肯定要比O(n*w)高很多，但是为了让你有更加深刻的感受，我来举一个例子给你比较一下。</p><p>我们假设有10000个物品，重量分布在1到15000之间，背包可以承载的总重量是30000。如果我们用回溯算法解决，用具体的数值表示出时间复杂度，就是2^10000，这是一个相当大的一个数字。如果我们用动态规划解决，用具体的数值表示出时间复杂度，就是10000*30000。虽然看起来也很大，但是和2^10000比起来，要小太多了。</p><p>尽管动态规划的执行效率比较高，但是就刚刚的代码实现来说，我们需要额外申请一个n乘以w+1的二维数组，对空间的消耗比较多。所以，有时候，我们会说，动态规划是一种空间换时间的解决思路。你可能要问了，有什么办法可以降低空间消耗吗？</p><p>实际上，我们只需要一个大小为w+1的一维数组就可以解决这个问题。动态规划状态转移的过程，都可以基于这个一维数组来操作。具体的代码实现我贴在这里，你可以仔细看下。</p><pre><code>public static int knapsack2(int[] items, int n, int w) {\n  boolean[] states = new boolean[w+1]; // 默认值false\n  states[0] = true;  // 第一行的数据要特殊处理，可以利用哨兵优化\n  if (items[0] &lt;= w) {\n    states[items[0]] = true;\n  }\n  for (int i = 1; i &lt; n; ++i) { // 动态规划\n    for (int j = w-items[i]; j &gt;= 0; --j) {//把第i个物品放入背包\n      if (states[j]==true) states[j+items[i]] = true;\n    }\n  }\n  for (int i = w; i &gt;= 0; --i) { // 输出结果\n    if (states[i] == true) return i;\n  }\n  return 0;\n}\n\n</code></pre><p>这里我特别强调一下代码中的第8行，j需要从大到小来处理。如果我们按照j从小到大处理的话，会出现for循环重复计算的问题。你可以自己想一想，这里我就不详细说了。</p><h2>0-1背包问题升级版</h2><p>我们继续升级难度。我改造了一下刚刚的背包问题。你看这个问题又该如何用动态规划解决？</p><p>我们刚刚讲的背包问题，只涉及背包重量和物品重量。我们现在引入物品价值这一变量。对于一组不同重量、不同价值、不可分割的物品，我们选择将某些物品装入背包，在满足背包最大重量限制的前提下，背包中可装入物品的总价值最大是多少呢？</p><p>这个问题依旧可以用回溯算法来解决。这个问题并不复杂，所以具体的实现思路，我就不用文字描述了，直接给你看代码。</p><pre><code>private int maxV = Integer.MIN_VALUE; // 结果放到maxV中\nprivate int[] items = {2，2，4，6，3};  // 物品的重量\nprivate int[] value = {3，4，8，9，6}; // 物品的价值\nprivate int n = 5; // 物品个数\nprivate int w = 9; // 背包承受的最大重量\npublic void f(int i, int cw, int cv) { // 调用f(0, 0, 0)\n  if (cw == w || i == n) { // cw==w表示装满了，i==n表示物品都考察完了\n    if (cv &gt; maxV) maxV = cv;\n    return;\n  }\n  f(i+1, cw, cv); // 选择不装第i个物品\n  if (cw + weight[i] &lt;= w) {\n    f(i+1,cw+weight[i], cv+value[i]); // 选择装第i个物品\n  }\n}\n</code></pre><p>针对上面的代码，我们还是照例画出递归树。在递归树中，每个节点表示一个状态。现在我们需要3个变量（i, cw, cv）来表示一个状态。其中，i表示即将要决策第i个物品是否装入背包，cw表示当前背包中物品的总重量，cv表示当前背包中物品的总价值。</p><p><img src=\"https://static001.geekbang.org/resource/image/bf/3f/bf0aa18f367db1b8dfd392906cb5693f.jpg?wh=1142*730\" alt=\"\"></p><p>我们发现，在递归树中，有几个节点的i和cw是完全相同的，比如f(2,2,4)和f(2,2,3)。在背包中物品总重量一样的情况下，f(2,2,4)这种状态对应的物品总价值更大，我们可以舍弃f(2,2,3)这种状态，只需要沿着f(2,2,4)这条决策路线继续往下决策就可以。</p><p>也就是说，对于(i, cw)相同的不同状态，那我们只需要保留cv值最大的那个，继续递归处理，其他状态不予考虑。</p><p>思路说完了，但是代码如何实现呢？如果用回溯算法，这个问题就没法再用“备忘录”解决了。所以，我们就需要换一种思路，看看动态规划是不是更容易解决这个问题？</p><p>我们还是把整个求解过程分为n个阶段，每个阶段会决策一个物品是否放到背包中。每个阶段决策完之后，背包中的物品的总重量以及总价值，会有多种情况，也就是会达到多种不同的状态。</p><p>我们用一个二维数组states[n][w+1]，来记录每层可以达到的不同状态。不过这里数组存储的值不再是boolean类型的了，而是当前状态对应的最大总价值。我们把每一层中(i, cw)重复的状态（节点）合并，只记录cv值最大的那个状态，然后基于这些状态来推导下一层的状态。</p><p>我们把这个动态规划的过程翻译成代码，就是下面这个样子：</p><pre><code>public static int knapsack3(int[] weight, int[] value, int n, int w) {\n  int[][] states = new int[n][w+1];\n  for (int i = 0; i &lt; n; ++i) { // 初始化states\n    for (int j = 0; j &lt; w+1; ++j) {\n      states[i][j] = -1;\n    }\n  }\n  states[0][0] = 0;\n  if (weight[0] &lt;= w) {\n    states[0][weight[0]] = value[0];\n  }\n  for (int i = 1; i &lt; n; ++i) { //动态规划，状态转移\n    for (int j = 0; j &lt;= w; ++j) { // 不选择第i个物品\n      if (states[i-1][j] &gt;= 0) states[i][j] = states[i-1][j];\n    }\n    for (int j = 0; j &lt;= w-weight[i]; ++j) { // 选择第i个物品\n      if (states[i-1][j] &gt;= 0) {\n        int v = states[i-1][j] + value[i];\n        if (v &gt; states[i][j+weight[i]]) {\n          states[i][j+weight[i]] = v;\n        }\n      }\n    }\n  }\n  // 找出最大值\n  int maxvalue = -1;\n  for (int j = 0; j &lt;= w; ++j) {\n    if (states[n-1][j] &gt; maxvalue) maxvalue = states[n-1][j];\n  }\n  return maxvalue;\n}\n</code></pre><p>关于这个问题的时间、空间复杂度的分析，跟上一个例子大同小异，所以我就不赘述了。我直接给出答案，时间复杂度是O(n*w)，空间复杂度也是O(n*w)。跟上一个例子类似，空间复杂度也是可以优化的，你可以自己写一下。</p><h2>解答开篇</h2><p>掌握了今天讲的两个问题之后，你是不是觉得，开篇的问题很简单？</p><p>对于这个问题，你当然可以利用回溯算法，穷举所有的排列组合，看大于等于200并且最接近200的组合是哪一个？但是，这样效率太低了点，时间复杂度非常高，是指数级的。当n很大的时候，可能“双十一”已经结束了，你的代码还没有运行出结果，这显然会让你在女朋友心中的形象大大减分。</p><p>实际上，它跟第一个例子中讲的0-1背包问题很像，只不过是把“重量”换成了“价格”而已。购物车中有n个商品。我们针对每个商品都决策是否购买。每次决策之后，对应不同的状态集合。我们还是用一个二维数组states[n][x]，来记录每次决策之后所有可达的状态。不过，这里的x值是多少呢？</p><p>0-1背包问题中，我们找的是小于等于w的最大值，x就是背包的最大承载重量w+1。对于这个问题来说，我们要找的是大于等于200（满减条件）的值中最小的，所以就不能设置为200加1了。就这个实际的问题而言，如果要购买的物品的总价格超过200太多，比如1000，那这个羊毛“薅”得就没有太大意义了。所以，我们可以限定x值为1001。</p><p>不过，这个问题不仅要求大于等于200的总价格中的最小的，我们还要找出这个最小总价格对应都要购买哪些商品。实际上，我们可以利用states数组，倒推出这个被选择的商品序列。我先把代码写出来，待会再照着代码给你解释。</p><pre><code>// items商品价格，n商品个数, w表示满减条件，比如200\npublic static void double11advance(int[] items, int n, int w) {\n  boolean[][] states = new boolean[n][3*w+1];//超过3倍就没有薅羊毛的价值了\n  states[0][0] = true;  // 第一行的数据要特殊处理\n  if (items[0] &lt;= 3*w) {\n    states[0][items[0]] = true;\n  }\n  for (int i = 1; i &lt; n; ++i) { // 动态规划\n    for (int j = 0; j &lt;= 3*w; ++j) {// 不购买第i个商品\n      if (states[i-1][j] == true) states[i][j] = states[i-1][j];\n    }\n    for (int j = 0; j &lt;= 3*w-items[i]; ++j) {//购买第i个商品\n      if (states[i-1][j]==true) states[i][j+items[i]] = true;\n    }\n  }\n\n  int j;\n  for (j = w; j &lt; 3*w+1; ++j) { \n    if (states[n-1][j] == true) break; // 输出结果大于等于w的最小值\n  }\n  if (j == 3*w+1) return; // 没有可行解\n  for (int i = n-1; i &gt;= 1; --i) { // i表示二维数组中的行，j表示列\n    if(j-items[i] &gt;= 0 &amp;&amp; states[i-1][j-items[i]] == true) {\n      System.out.print(items[i] + &quot; &quot;); // 购买这个商品\n      j = j - items[i];\n    } // else 没有购买这个商品，j不变。\n  }\n  if (j != 0) System.out.print(items[0]);\n}\n</code></pre><p>代码的前半部分跟0-1背包问题没有什么不同，我们着重看后半部分，看它是如何打印出选择购买哪些商品的。</p><p>状态(i, j)只有可能从(i-1, j)或者(i-1, j-value[i])两个状态推导过来。所以，我们就检查这两个状态是否是可达的，也就是states[i-1][j]或者states[i-1][j-value[i]]是否是true。</p><p>如果states[i-1][j]可达，就说明我们没有选择购买第i个商品，如果states[i-1][j-value[i]]可达，那就说明我们选择了购买第i个商品。我们从中选择一个可达的状态（如果两个都可达，就随意选择一个），然后，继续迭代地考察其他商品是否有选择购买。</p><h2>内容小结</h2><p>动态规划的第一节到此就讲完了。内容比较多，你可能需要多一点时间来消化。为了帮助你有的放矢地学习，我来强调一下，今天你应该掌握的重点内容。</p><p>今天的内容不涉及动态规划的理论，我通过两个例子，给你展示了动态规划是如何解决问题的，并且一点一点详细给你讲解了动态规划解决问题的思路。这两个例子都是非常经典的动态规划问题，只要你真正搞懂这两个问题，基本上动态规划已经入门一半了。所以，你要多花点时间，真正弄懂这两个问题。</p><p>从例子中，你应该能发现，大部分动态规划能解决的问题，都可以通过回溯算法来解决，只不过回溯算法解决起来效率比较低，时间复杂度是指数级的。动态规划算法，在执行效率方面，要高很多。尽管执行效率提高了，但是动态规划的空间复杂度也提高了，所以，很多时候，我们会说，动态规划是一种空间换时间的算法思想。</p><p>我前面也说了，今天的内容并不涉及理论的知识。这两个例子的分析过程，我并没有涉及任何高深的理论方面的东西。而且，我个人觉得，贪心、分治、回溯、动态规划，这四个算法思想有关的理论知识，大部分都是“后验性”的，也就是说，在解决问题的过程中，我们往往是先想到如何用某个算法思想解决问题，然后才用算法理论知识，去验证这个算法思想解决问题的正确性。所以，你大可不必过于急于寻求动态规划的理论知识。</p><h2>课后思考</h2><p>“杨辉三角”不知道你听说过吗？我们现在对它进行一些改造。每个位置的数字可以随意填写，经过某个数字只能到达下面一层相邻的两个数字。</p><p>假设你站在第一层，往下移动，我们把移动到最底层所经过的所有数字之和，定义为路径的长度。请你编程求出从最高层移动到最底层的最短路径长度。</p><p><img src=\"https://static001.geekbang.org/resource/image/f7/cc/f756eade65a5da08e7c0f1e93f9f20cc.jpg?wh=1142*568\" alt=\"\"></p><p>欢迎留言和我分享，也欢迎点击“<span class=\"orange\">请朋友读</span>”，把今天的内容分享给你的好友，和他一起讨论、学习。</p>","comments":[{"had_liked":false,"id":55408,"user_name":"zixuan","can_delete":false,"product_type":"c1","uid":1131300,"ip_address":"","ucode":"C72920DD05B074","user_header":"https://static001.geekbang.org/account/avatar/00/11/43/24/3f9f7c70.jpg","comment_is_top":false,"comment_ctime":1546163867,"is_pvip":false,"discussion_count":19,"race_medal":0,"score":"3699513005723","product_id":100017301,"comment_content":"贪心：一条路走到黑，就一次机会，只能哪边看着顺眼走哪边<br>回溯：一条路走到黑，无数次重来的机会，还怕我走不出来 (Snapshot View)<br>动态规划：拥有上帝视角，手握无数平行宇宙的历史存档， 同时发展出无数个未来 (Versioned Archive View)","like_count":862,"discussions":[{"author":{"id":1130942,"avatar":"https://static001.geekbang.org/account/avatar/00/11/41/be/4893497a.jpg","nickname":"野猪佩奇","note":"","ucode":"B1803FFE251E1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24049,"discussion_content":"蝴蝶效应是不错，不过还有一部更适合的电影，更契合回溯主题，《明日边缘》，看完秒懂回溯了","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1569988566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84659,"discussion_content":"是的，老师在将动态规划之前，有一个回溯的优化版本；就是 数组去重；\n\n而动态规划 就是用了数组存储每一层的可达状态 来实现天生去重。。。。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1576503834,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1130407,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3f/a7/a378347f.jpg","nickname":"qzq","note":"","ucode":"334B5E522EBF1C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2929,"discussion_content":"课没听太明白，莫非回溯算法是穷举？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1564041829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1127742,"avatar":"https://static001.geekbang.org/account/avatar/00/11/35/3e/ce183821.jpg","nickname":"yanglas","note":"","ucode":"7D196091E194A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1130407,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3f/a7/a378347f.jpg","nickname":"qzq","note":"","ucode":"334B5E522EBF1C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3465,"discussion_content":"回溯就是穷举。不过递归就会导致很多重复计算。动态规划利用数组解决重复计算的问题（空间换时间）。","likes_number":25,"is_delete":false,"is_hidden":false,"ctime":1564498978,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2929,"ip_address":""},"score":3465,"extra":""},{"author":{"id":2113150,"avatar":"https://static001.geekbang.org/account/avatar/00/20/3e/7e/3dac54fa.jpg","nickname":"曾益达","note":"","ucode":"AC20D6F5EF01C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1130407,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3f/a7/a378347f.jpg","nickname":"qzq","note":"","ucode":"334B5E522EBF1C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298195,"discussion_content":"回溯其实就是穷举（暴力），你可以把它写成n个for循环的形式，就看出来是暴力穷举了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597217201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2929,"ip_address":""},"score":298195,"extra":""}]},{"author":{"id":1849703,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/39/67/2477b20e.jpg","nickname":"瑞哥","note":"","ucode":"3AE6DCDAE5844F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367253,"discussion_content":"牛b","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1618305941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1591223,"avatar":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","nickname":"JerryZhu","note":"","ucode":"76850CD45786C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307619,"discussion_content":"我特么哭了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600698339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1054598,"avatar":"https://static001.geekbang.org/account/avatar/00/10/17/86/416f772e.jpg","nickname":"shelldon","note":"","ucode":"BF8FE102D6DD1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":201674,"discussion_content":"太形象了！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583823429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1067720,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4a/c8/7679cd2a.jpg","nickname":"冬青树","note":"","ucode":"3DC219F6EE3046","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":533362,"discussion_content":"Nice","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637845702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2103542,"avatar":"https://static001.geekbang.org/account/avatar/00/20/18/f6/db57fef1.jpg","nickname":"WSZ","note":"","ucode":"AB092B48C52D47","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530560,"discussion_content":"你可真秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637105881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2708005,"avatar":"https://static001.geekbang.org/account/avatar/00/29/52/25/185763e4.jpg","nickname":"薇尔莉特","note":"","ucode":"1465A6F3005CA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389886,"discussion_content":"动态规划：世界线变动+世界线收束","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629464660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1625340,"avatar":"https://static001.geekbang.org/account/avatar/00/18/cc/fc/92646317.jpg","nickname":"骑着驴读着书的谢小夕","note":"","ucode":"56F0A469B630A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349363,"discussion_content":"神了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613133997,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1751242,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/b8/ca/93b716f7.jpg","nickname":"洪兴掌管一代","note":"","ucode":"4B22C0B99A60F1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336556,"discussion_content":"epiphany!!!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608624677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1196502,"avatar":"https://static001.geekbang.org/account/avatar/00/12/41/d6/84449200.jpg","nickname":"Lss","note":"","ucode":"BF908BF0D731FE","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323654,"discussion_content":"厉害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604978608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1211896,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7d/f8/1ee5514d.jpg","nickname":"来风","note":"","ucode":"A9470EE0E322D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308415,"discussion_content":"厉害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600946325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1324314,"avatar":"https://static001.geekbang.org/account/avatar/00/14/35/1a/9fa38dc9.jpg","nickname":"子瞻","note":"","ucode":"5C26FF10934534","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306948,"discussion_content":"牛批0","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600425671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2036705,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/13/e1/6939ae4f.jpg","nickname":"knight劉先生","note":"","ucode":"CEE9BFC8D3D969","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291886,"discussion_content":"nice","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594986195,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215194,"discussion_content":"这个总结神了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585299444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1448864,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1b/a0/7c7d1b4a.jpg","nickname":"徐帅","note":"","ucode":"BDF904280E2330","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":160279,"discussion_content":"课后习题答案：杨辉三角链接：https://www.cnblogs.com/workharder/p/12258559.html","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580784064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":53993,"user_name":"🌀🐑hfy🐣","can_delete":false,"product_type":"c1","uid":1254367,"ip_address":"","ucode":"8A7E4BDC46CB35","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/df/367f2c75.jpg","comment_is_top":false,"comment_ctime":1545784617,"is_pvip":false,"discussion_count":11,"race_medal":0,"score":"602841206057","product_id":100017301,"comment_content":"首先得有个女朋友","like_count":140,"discussions":[{"author":{"id":1134861,"avatar":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","nickname":"James","note":"","ucode":"48B0F2A334D1C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42693,"discussion_content":"我已经有了,在床上🐶","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1572753909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1357303,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKg3ia2DDFuGLZRtHw6to43icxKyia1eHbxTUh1CY1dSuTp5WmQN01A1aLAia1lkaR8EAkXD4h76n8Bog/132","nickname":"Hxd","note":"","ucode":"B8B04AA5738CC9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1134861,"avatar":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","nickname":"James","note":"","ucode":"48B0F2A334D1C1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52867,"discussion_content":"好了好了，大家都知道了，可以折叠起来了","likes_number":14,"is_delete":false,"is_hidden":false,"ctime":1574089054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":42693,"ip_address":""},"score":52867,"extra":""},{"author":{"id":1447569,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/WtHCCMoLJ2DvzqQwPYZyj2RlN7eibTLMHDMTSO4xIKjfKR1Eh9L98AMkkZY7FmegWyGLahRQJ5ibPzeeFtfpeSow/132","nickname":"脱缰的野马__","note":"","ucode":"D5F993E7232C61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1357303,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKg3ia2DDFuGLZRtHw6to43icxKyia1eHbxTUh1CY1dSuTp5WmQN01A1aLAia1lkaR8EAkXD4h76n8Bog/132","nickname":"Hxd","note":"","ucode":"B8B04AA5738CC9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":104456,"discussion_content":"看样子女朋友有一个多月快两个月了，应该开始漏气了吧~","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1577435557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":52867,"ip_address":""},"score":104456,"extra":""}]},{"author":{"id":1529858,"avatar":"https://static001.geekbang.org/account/avatar/00/17/58/02/2b7ccf09.jpg","nickname":"民工597","note":"","ucode":"DB6857E21E9318","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38571,"discussion_content":"人家说了是假设","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571804973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2962599,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/34/a7/52c4ea60.jpg","nickname":"年少挽滑稽世无双","note":"","ucode":"793DCBDE25A07B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577404,"discussion_content":"破防了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656074795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1658432,"avatar":"https://static001.geekbang.org/account/avatar/00/19/4e/40/d1f0e812.jpg","nickname":"李岷遥要坚持要自律！","note":"","ucode":"C50AD55FDECD8A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392740,"discussion_content":"其次你得给她清100+购物车","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631107752,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2068721,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/90/f1/7f2b5e16.jpg","nickname":"CHN-Lee-玉米","note":"","ucode":"0A53080F38F229","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310705,"discussion_content":"女朋友的购物车中有>100个想买的商品","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602000974,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1459289,"avatar":"https://static001.geekbang.org/account/avatar/00/16/44/59/9cc7d8cd.jpg","nickname":"毛成方","note":"","ucode":"DFBF3D464D8D7C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297770,"discussion_content":"6666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597051923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1919541,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/4a/35/66caeed9.jpg","nickname":"完美坚持","note":"","ucode":"AE0261D8DDEF64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284765,"discussion_content":"shi时刻准备好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592631003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2009311,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/SiciaNKibn60SjA50TsTEtO09DoRA57UozylHmKckZXkJmNiaShSC0BIP6TdZC6cAphuEzmuxMHWwvpYN8P7kKb8eA/132","nickname":"TheStarBoys","note":"","ucode":"9A6D70482F9212","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282686,"discussion_content":"学Java的快来new个对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592044937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1013060,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/75/44/71005991.jpg","nickname":"sunshine","note":"","ucode":"9E6E85BF71588E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":195329,"discussion_content":"陈独秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583253541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":53998,"user_name":"茴香根","can_delete":false,"product_type":"c1","uid":1316111,"ip_address":"","ucode":"B91C00B72077F1","user_header":"https://static001.geekbang.org/account/avatar/00/14/15/0f/954be2db.jpg","comment_is_top":false,"comment_ctime":1545785058,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"581366370018","product_id":100017301,"comment_content":"我理解的动态规划，就是从全遍历的递归树为出发点，广度优先遍历，在遍历完每一层之后对每层结果进行合并（结果相同的）或舍弃（已经超出限制条件的），确保下一层遍历的数量不会超过限定条件数完W，通过这个操作达到大大减少不必要遍历的目的。<br>在空间复杂度优化上，通过在计算中只保留最优结果的目的重复利用内存空间。","like_count":136,"discussions":[{"author":{"id":1373857,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f6/a1/debef255.jpg","nickname":"爱的神","note":"","ucode":"780400297FB83A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367193,"discussion_content":"哇，你这个思路很棒，有种茅塞顿开的感觉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618286641,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56316,"user_name":"郭霖","can_delete":false,"product_type":"c1","uid":1114433,"ip_address":"","ucode":"C2ADA402806514","user_header":"https://static001.geekbang.org/account/avatar/00/11/01/41/72237894.jpg","comment_is_top":false,"comment_ctime":1546420440,"is_pvip":false,"discussion_count":13,"race_medal":0,"score":"435338117336","product_id":100017301,"comment_content":"王争老师动态规划讲得确实精彩，就是课后练习没有答案，有时候解不出来会很难受。我是看了下一篇文章的讲解然后明白了这篇文章的课后习题解法，这里分享一下吧，希望对大家有帮助。<br><br>int[][] matrix = {{5},{7,8},{2,3,4},{4,9,6,1},{2,7,9,4,5}};<br><br>public int yanghuiTriangle(int[][] matrix) {<br>    int[][] state = new int[matrix.length][matrix.length];<br>    state[0][0] = matrix[0][0];<br>    for (int i = 1; i &lt; matrix.length; i++) {<br>        for (int j = 0; j &lt; matrix[i].length; j++) {<br>            if (j == 0) state[i][j] = state[i - 1][j] + matrix[i][j];<br>            else if (j == matrix[i].length - 1) state[i][j] = state[i - 1][j - 1] + matrix[i][j];<br>            else {<br>                int top1 = state[i - 1][j - 1];<br>                int top2 = state[i - 1][j];<br>                state[i][j] = Math.min(top1, top2) + matrix[i][j];<br>            }<br>        }<br>    }<br>    int minDis = Integer.MAX_VALUE;<br>    for (int i = 0; i &lt; matrix[matrix.length - 1].length; i++) {<br>        int distance = state[matrix.length - 1][i];<br>        if (distance &lt; minDis) minDis = distance;<br>    }<br>    return minDis;<br>}","like_count":101,"discussions":[{"author":{"id":1136529,"avatar":"https://static001.geekbang.org/account/avatar/00/11/57/91/3a082914.jpg","nickname":"葡萄有点酸","note":"","ucode":"51C3CE1E685D8E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46025,"discussion_content":"这个我觉得倒推，即从底部往顶部递推计算会更好些，且空间消耗可以进一步优化，代码也更简洁些，具体代码如下：\n\npublic int yanghuiTriangle(int[][] matrix) {\n    int length = matrix.length;\n    // 用于存储每一层的状态\n    int[] min = new int[length + 1];\n    for (int i = length - 1; i >= 0; i--) {\n        int[] rawNums = matrix[i];\n        int rowLength = rawNums.length;\n        for (int j = 0; j < rowLength; j++) {\n            min[j] = Math.min(min[j], min[j + 1]) + rawNums[j];\n        }\n    }\n    return min[0];\n}\n","likes_number":25,"is_delete":false,"is_hidden":false,"ctime":1573112649,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1191730,"avatar":"https://static001.geekbang.org/account/avatar/00/12/2f/32/db8e5674.jpg","nickname":"杨军","note":"","ucode":"43C1636CF69A9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1136529,"avatar":"https://static001.geekbang.org/account/avatar/00/11/57/91/3a082914.jpg","nickname":"葡萄有点酸","note":"","ucode":"51C3CE1E685D8E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319792,"discussion_content":"很强兄弟，这个思路nice","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604121240,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":46025,"ip_address":""},"score":319792,"extra":""},{"author":{"id":1925466,"avatar":"","nickname":"周兴佳","note":"","ucode":"E5F941019F1D2E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1136529,"avatar":"https://static001.geekbang.org/account/avatar/00/11/57/91/3a082914.jpg","nickname":"葡萄有点酸","note":"","ucode":"51C3CE1E685D8E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379547,"discussion_content":"666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623950181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":46025,"ip_address":""},"score":379547,"extra":""},{"author":{"id":1461687,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLoxyegHarElcAbXdl9FaOMXcOibOOEgWgFMiakL2q7guxcqMqkUQBib1zldFS56hr61Y8zhlO3Rs8Hg/132","nickname":"Geek__f5e47e0e2519","note":"","ucode":"FE1EBAF59233CA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1136529,"avatar":"https://static001.geekbang.org/account/avatar/00/11/57/91/3a082914.jpg","nickname":"葡萄有点酸","note":"","ucode":"51C3CE1E685D8E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389046,"discussion_content":"        for (int j = 0; j < rowLength; j++) {\n            min[j] = Math.min(min[j], min[j + 1]) + rawNums[j]; 这个里面的min[j + 1]有可能超范围吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629102573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":46025,"ip_address":""},"score":389046,"extra":""}]},{"author":{"id":1448864,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1b/a0/7c7d1b4a.jpg","nickname":"徐帅","note":"","ucode":"BDF904280E2330","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":160324,"discussion_content":"有个优化点：每层for循环的第一个和最后一个只计算了一次，而中间的才进行多次min运算，可以把每层第一个和最后一个拿到for循环的上一层，这样减少循环中if else的判断。https://www.cnblogs.com/workharder/p/12258559.html","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1580787342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1385483,"avatar":"https://static001.geekbang.org/account/avatar/00/15/24/0b/8690964e.jpg","nickname":"或许","note":"","ucode":"97D14FAB1F239C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":68984,"discussion_content":"膜拜一下Android大神","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1575249547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1098637,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c3/8d/214ad614.jpg","nickname":"朱坤","note":"","ucode":"65224DA2456EAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158092,"discussion_content":"哇，偶遇郭霖老师，想不到郭老师也在看这门课，且思路与郭老师完全一致。。好兴奋，我给个 JS 实现：\n\n\nfunction main() {\n    const triangle = [\n        [5],\n        [7, 8],\n        [2, 3, 4],\n        [4, 9, 6, 1],\n        [2, 7, 9, 4, 5]\n    ];\n    const result = [];\n    result[0] = [ triangle[0][0] ];\n\n    for(let i = 1; i<triangle.length; i++) {\n        result[i] = [];\n        for(let j = 0; j<i+1; j++) {\n            let min;\n            if (j === 0) {// 最左边节点\n                min = result[i-1][j];\n            } else if (j == i) { // 最右边节点\n                min = result[i-1][j-1];\n            } else {\n                min = Math.min(result[i-1][j-1], result[i-1][j]);\n            }\n            result[i][j] = triangle[i][j] + min;\n        }\n    }\n    \n    const pathA = result[result.length - 1];\n    \n    let minL = Number.MAX_SAFE_INTEGER;\n    for (let i = 0; i <= pathA.length; i++) {\n        if (pathA[i] < minL) {\n            minL = pathA[i];\n        }\n    }\n    console.log(minL);\n}\nmain();","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1580550334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134861,"avatar":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","nickname":"James","note":"","ucode":"48B0F2A334D1C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42722,"discussion_content":"第一行代码???","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1572760612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1652366,"avatar":"https://static001.geekbang.org/account/avatar/00/19/36/8e/22c236d6.jpg","nickname":"wardseptember","note":"","ucode":"872320C858B2C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":31268,"discussion_content":"安卓开发大佬？久仰久仰","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1570892452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1503113,"avatar":"https://static001.geekbang.org/account/avatar/00/16/ef/89/8c73a24d.jpg","nickname":"Chen","note":"","ucode":"C1128558AB5BC4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":47000,"discussion_content":"哇，这里也能碰到大佬，小Android一枚","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573256671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1640973,"avatar":"https://static001.geekbang.org/account/avatar/00/19/0a/0d/7bac5bcb.jpg","nickname":"maybe","note":"","ucode":"2C0D1D26853DB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":107705,"discussion_content":"膜拜膜拜","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577601315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84665,"discussion_content":"纳尼？打卡打卡，我看完下一节课 再来看这个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576503953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":54016,"user_name":"P@tricK","can_delete":false,"product_type":"c1","uid":1233716,"ip_address":"","ucode":"293B2B3261A793","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/34/5dee4f70.jpg","comment_is_top":false,"comment_ctime":1545786729,"is_pvip":false,"replies":[{"id":"19653","content":"👍 说的没错","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545825955,"ip_address":"","comment_id":54016,"utype":1}],"discussion_count":11,"race_medal":0,"score":"246358922601","product_id":100017301,"comment_content":"老师你这个只能精确到元，女朋友羊毛精说要求精确到0.01元，时间空间复杂度增大100倍🐶","like_count":57,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434326,"discussion_content":"👍 说的没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545825955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1517095,"avatar":"https://static001.geekbang.org/account/avatar/00/17/26/27/a4abd984.jpg","nickname":"kango","note":"","ucode":"3D740DB0CE94F7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":143114,"discussion_content":"这种情况下就换个女朋友会降低复杂度！","likes_number":31,"is_delete":false,"is_hidden":false,"ctime":1579490785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1135024,"avatar":"https://static001.geekbang.org/account/avatar/00/11/51/b0/d32c895d.jpg","nickname":"熊能","note":"","ucode":"1019EA97062AC7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1517095,"avatar":"https://static001.geekbang.org/account/avatar/00/17/26/27/a4abd984.jpg","nickname":"kango","note":"","ucode":"3D740DB0CE94F7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569797,"discussion_content":"天秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651558138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":143114,"ip_address":""},"score":569797,"extra":""}]},{"author":{"id":1067637,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4a/75/ec7cdc05.jpg","nickname":"贾洪强","note":"","ucode":"92A7CE918CE309","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":238747,"discussion_content":"我在看的时候也在想这个问题，也许可以先取整到1，然后得到一个区间，在这个区间里再算分级别的，这样复杂度是2倍","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587227115,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1447569,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/WtHCCMoLJ2DvzqQwPYZyj2RlN7eibTLMHDMTSO4xIKjfKR1Eh9L98AMkkZY7FmegWyGLahRQJ5ibPzeeFtfpeSow/132","nickname":"脱缰的野马__","note":"","ucode":"D5F993E7232C61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":104457,"discussion_content":"你女朋友有点皮！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577435637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1244845,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fe/ad/7fa85a7d.jpg","nickname":"放飞心情","note":"","ucode":"75A2192D91D86C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387163,"discussion_content":"题意主要求能满足满减的条件，没必要很精确，如果有小数，可以舍掉小数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628028010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1335403,"avatar":"https://static001.geekbang.org/account/avatar/00/14/60/6b/907a9557.jpg","nickname":"unlock","note":"","ucode":"9B1F899B960A20","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309003,"discussion_content":"同问，如何处理大数比如价格都是：25874698元这种样子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601168746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005661,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/58/5d/8de7f8dc.jpg","nickname":"爱新觉罗老流氓","note":"","ucode":"B13AC4DA358C15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":222250,"discussion_content":"价格先乘以100，再算","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586104333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1069206,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/96/18612c89.jpg","nickname":"克","note":"","ucode":"6DDFBB05E0F4E9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":113833,"discussion_content":"哈哈 不过实际问题往往不需要那么精确。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577935459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1200867,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/e3/594f7e34.jpg","nickname":"杨超越","note":"","ucode":"D115EDC04B6E1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":47730,"discussion_content":"为啥会增大100倍？应该是一样的啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573399135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1200867,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/e3/594f7e34.jpg","nickname":"杨超越","note":"","ucode":"D115EDC04B6E1F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84670,"discussion_content":"em 每一层可达的状态集合 不是整数级别了。。是 0.01了啊\n那不就是 x 100了吗。。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1576504065,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":47730,"ip_address":""},"score":84670,"extra":""}]}]},{"had_liked":false,"id":54529,"user_name":"失火的夏天","can_delete":false,"product_type":"c1","uid":1241770,"ip_address":"","ucode":"10C6E66EB2A65F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","comment_is_top":false,"comment_ctime":1545892110,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"156164714766","product_id":100017301,"comment_content":"杨辉三角的动态规划转移方程是：S[i][j] = min(S[i-1][j],S[i-1][j-1]) + a[i][j]。<br>其中a表示到这个点的value值，S表示到a[i][j]这个点的最短路径值。<br>这里没有做边界条件限制，只是列出一个方程通式。边界条件需要在代码里具体处理。个人感觉动态规划的思想关键在于如何列出动态规划方程，有了方程，代码基本就是水到渠成了。","like_count":36,"discussions":[{"author":{"id":1850206,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/AyUEibEbicwMib9XSYFxDd13rIj5xMLCAwlEogd1c2bwW7Dwof0AQkRaSS5FrEK0Cg0s36ZnVZK2GW37WlVjzbydQ/132","nickname":"a解code","note":"","ucode":"A9DA207611BF78","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362237,"discussion_content":"往上 往下，都可以走 哈哈，一个是网上收敛，一个是向下不泛滥收敛，往上收，最后只有一个顶峰值，往下收，会有n个值，最后还得选一个，都可以做。哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616899529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1850206,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/AyUEibEbicwMib9XSYFxDd13rIj5xMLCAwlEogd1c2bwW7Dwof0AQkRaSS5FrEK0Cg0s36ZnVZK2GW37WlVjzbydQ/132","nickname":"a解code","note":"","ucode":"A9DA207611BF78","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362232,"discussion_content":"s[i][j]=min(s[i+1][j],s[i+1][j+1])+a[i][j],我个人认为 应该是下往上走，交流交流","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616899112,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":55007,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1545999933,"is_pvip":false,"replies":[{"id":"20251","content":"不着急你慢慢学就是了 不用非得跟的那么紧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1546418274,"ip_address":"","comment_id":55007,"utype":1}],"discussion_count":5,"race_medal":0,"score":"117510116925","product_id":100017301,"comment_content":"1、这里我特别强调一下代码中的第 6 行，j 需要从大到小来处理。<br>这里自己写代码调试完才恍然大悟，第i轮循环中新设置的值会干扰到后面的设值。<br><br>2、特别感谢争哥今天让其他的课程的老师来客串了一节课，让我有了更多的时间学习本节。<br>","like_count":27,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434647,"discussion_content":"不着急你慢慢学就是了 不用非得跟的那么紧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546418274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1006261,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5a/b5/f667f610.jpg","nickname":"shaomeng","note":"","ucode":"BB9EA8B684A035","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":10045,"discussion_content":"是的，比如 j = 0, item[i] = 5, w=10，如果正向循环，j=0 时会设置 state[5] = true, 而当遍历至 j=5时，由于 state[5]=true，会设置 state[10] = true，但是实际上将 5 这个重量使用了两次，所以导致了重量的重复使用","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1568258763,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2029015,"avatar":"","nickname":"小钢炮","note":"","ucode":"676C4CCF3CCD0D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1006261,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5a/b5/f667f610.jpg","nickname":"shaomeng","note":"","ucode":"BB9EA8B684A035","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":396361,"discussion_content":"为什么从大到小就不会导致重量的重复使用呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632412595,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":10045,"ip_address":""},"score":396361,"extra":""},{"author":{"id":2227642,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/EibiawvG4UwoTOcibiaf51LoTDs2vqfqTcQZqnKUhg6Ojko1DqKct6r7SnVbs7zdaMKF5aEfjtfDkg4mH3kBfvQp3Q/132","nickname":"dadnotorc","note":"","ucode":"727E8EF29591A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2029015,"avatar":"","nickname":"小钢炮","note":"","ucode":"676C4CCF3CCD0D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537216,"discussion_content":"从大到小来处理, 保证了在state数组上, 我们是从后往前更新. 后者的值不会影响到前者","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638987215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":396361,"ip_address":""},"score":537216,"extra":""}]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84693,"discussion_content":"“第i轮循环中新设置的值会干扰到后面的设值” ？？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576504749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":54940,"user_name":"feifei","can_delete":false,"product_type":"c1","uid":1105431,"ip_address":"","ucode":"B1F8AE3AD82C51","user_header":"https://static001.geekbang.org/account/avatar/00/10/de/17/75e2b624.jpg","comment_is_top":false,"comment_ctime":1545985795,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"91740299011","product_id":100017301,"comment_content":"这个动态规划学习了三天了，把老师的代码都手练了一遍，感觉对动态规划有点感觉了！然后在写这个课后题，我也练了一遍，我练了这么多，但我觉得动态规则这个最重要的是每层可达的状态这个怎么计算的，这是重点，我开始的时候，用纸和笔，把老师的第一例子，中的状态都画了出来，然后再来看代码，感觉很有帮助！<br><br>杨晖三角的代码我我也贴出来，希望对其他童鞋有帮助，老师，也麻烦你帮忙看下，看我的实现是否存在问题，谢谢！<br><br>由于这个限制，限制长度，没有贴出来倒推出路径，可查看我的git<br>https:&#47;&#47;github.com&#47;kkzfl22&#47;datastruct&#47;blob&#47;master&#47;src&#47;main&#47;java&#47;com&#47;liujun&#47;datastruct&#47;algorithm&#47;dynamicProgramming&#47;triangle&#47;Triangle.java<br><br><br>int[][] status = new int[triangles.length][triangles[triangles.length - 1].length];<br><br>    int startPoint = triangles.length - 1;<br>    int maxpoint = triangles[triangles.length - 1].length;<br><br>    &#47;&#47; 初始化相关的数据<br>    for (int i = 0; i &lt;= startPoint; i++) {<br>      for (int j = 0; j &lt; maxpoint; j++) {<br>        status[i][j] = -1;<br>      }<br>    }<br><br>    &#47;&#47; 初始化杨晖三解的第一个顶点<br>    status[0][startPoint] = triangles[0][startPoint];<br><br>    &#47;&#47; 开始求解第二个三角形顶点<br>    &#47;&#47; 按层级遍历<br>    for (int i = 1; i &lt;= startPoint; i++) {<br>      &#47;&#47; 加入当前的位置节点<br>      int currIndex = 0;<br>      while (currIndex &lt; maxpoint) {<br>        if (status[i - 1][currIndex] &gt; 0) {<br>          &#47;&#47; 计算左节点<br>          int leftValue = status[i - 1][currIndex] + triangles[i][currIndex - 1];<br><br>          &#47;&#47; 1,检查当前左节点是否已经设置，如果没有，则直接设置<br>          if (status[i][currIndex - 1] == -1) {<br>            status[i][currIndex - 1] = leftValue;<br>          } else {<br>            if (leftValue &lt; status[i][currIndex - 1]) {<br>              status[i][currIndex - 1] = leftValue;<br>            }<br>          }<br>          &#47;&#47; 计算右节点<br>          int rightValue = status[i - 1][currIndex] + triangles[i][currIndex + 1];<br><br>          if (status[i][currIndex + 1] == -1) {<br>            status[i][currIndex + 1] = rightValue;<br>          }<br>          currIndex++;<br>        }<br>        currIndex++;<br>      }<br>    }<br><br>    int minValue = Integer.MAX_VALUE;<br>    for (int i = 0; i &lt; maxpoint; i++) {<br>      if (minValue &gt; status[startPoint][i] &amp;&amp; status[startPoint][i] != -1) {<br>        minValue = status[startPoint][i];<br>      }<br>    }<br>    System.out.println(&quot;最短路径结果为:&quot; + minValue);<br><br>","like_count":21},{"had_liked":false,"id":55052,"user_name":"煦暖","can_delete":false,"product_type":"c1","uid":1245418,"ip_address":"","ucode":"96D0B236C4148A","user_header":"https://static001.geekbang.org/account/avatar/00/13/00/ea/6ad346c1.jpg","comment_is_top":false,"comment_ctime":1546011226,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"83150389850","product_id":100017301,"comment_content":"老师你好，您在专栏里提到好几次哨兵，啥时候给我们讲解一下呢？","like_count":20,"discussions":[{"author":{"id":1240802,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ee/e2/23e44221.jpg","nickname":"余熙","note":"","ucode":"7F98DCFB899CB7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363388,"discussion_content":"哨兵 就是把边界条件提前算出来，放置 for 代码块前面，这样就不用在每次for循环里，判断前端的边界条件","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1617185304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":322679,"discussion_content":"原理容易。以前的也容易理解。这一节的试试？和所有节的代码试试？这一节我还没有想出来。只想到用0行0列做边界，故实际的情况是，计算结果相比现在代码，行列都需要+1，i===>i+1, j===>j+1 相当于增加了0行0列。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604798925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1547763,"avatar":"https://static001.geekbang.org/account/avatar/00/17/9d/f3/3f6dd32b.jpg","nickname":"叶紫真","note":"","ucode":"9CD7567FDB7F1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279850,"discussion_content":"哨兵比较简单,Google一下就行了,理解其含义","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591432998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1080985,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7e/99/c4302030.jpg","nickname":"Khirye","note":"","ucode":"6C54C126FA54B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":244802,"discussion_content":"前面的课不好好看🐶","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587632539,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1511436,"avatar":"https://static001.geekbang.org/account/avatar/00/17/10/0c/0064aadd.jpg","nickname":"Banana คิดถึง","note":"","ucode":"9C412BD1A6684A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1080985,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7e/99/c4302030.jpg","nickname":"Khirye","note":"","ucode":"6C54C126FA54B8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":245564,"discussion_content":"能不能把哨兵优化后的贴出来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587686541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":244802,"ip_address":""},"score":245564,"extra":""}]},{"author":{"id":1597156,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erObO6EFRxGTlldp4LDHG7ZJK8iarHYTydh8gj8ib60PQwCdtLP6EPTkmoFO7yaoXetDhwkFIeAMzfg/132","nickname":"路漫漫","note":"","ucode":"09565AADAFA337","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2249,"discussion_content":"讲队列的时候有讲哨兵\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563412654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1511436,"avatar":"https://static001.geekbang.org/account/avatar/00/17/10/0c/0064aadd.jpg","nickname":"Banana คิดถึง","note":"","ucode":"9C412BD1A6684A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1597156,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erObO6EFRxGTlldp4LDHG7ZJK8iarHYTydh8gj8ib60PQwCdtLP6EPTkmoFO7yaoXetDhwkFIeAMzfg/132","nickname":"路漫漫","note":"","ucode":"09565AADAFA337","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":245566,"discussion_content":"能不能把哨兵优化后的代码贴出来\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587686564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2249,"ip_address":""},"score":245566,"extra":""}]}]},{"had_liked":false,"id":57112,"user_name":"不上进的码农","can_delete":false,"product_type":"c1","uid":1248890,"ip_address":"","ucode":"D0594DDDD1C5AE","user_header":"https://static001.geekbang.org/account/avatar/00/13/0e/7a/31328704.jpg","comment_is_top":false,"comment_ctime":1546651676,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"65971161116","product_id":100017301,"comment_content":"关于课后杨辉三角最短路径的问题，应该用动态规划的两种方式都可以实现。1，状态转移，和背包问题升级版类似，同样使用二维数组记录，一维表示行，二维表示列，值保存最短路径，两种途径到达同一节点，我们只保存路径最短的值，然后一行一行遍历完，最后把最后一行进行排序，选择最小的即可。需要注意的是，在生成二维数组的时候最好是每行遍历生成，如第一行只有一个，第二行两个，这样可以节省一半的空间。2，方程转移，也就是从下往上来，每一个节点只有上层的两个节点能到达，也就是(i,j)节点，要么途径(i-1,j-1)节点,要么途径(i-1,j)节点，那么选择二者的最小值加上当前节点的数字，就是当前节点的最小值了，最后把最后一行排序选最小就OK了","like_count":15},{"had_liked":false,"id":67637,"user_name":"阿崔cxr","can_delete":false,"product_type":"c1","uid":1177565,"ip_address":"","ucode":"26E2C7D96306A4","user_header":"https://static001.geekbang.org/account/avatar/00/11/f7/dd/c85f2065.jpg","comment_is_top":false,"comment_ctime":1550214908,"is_pvip":false,"replies":[{"id":"25409","content":"👍  你还得把我文章里涉及的所有题目都搞明白、会默写才算入门呢","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551233002,"ip_address":"","comment_id":67637,"utype":1}],"discussion_count":2,"race_medal":0,"score":"48794855164","product_id":100017301,"comment_content":"老师，这是我基于理解动态规划之后写出的优化版斐波那契数列，是否算是动态规划入门了 - -<br>function faibonacci(n) {<br>    &#47;&#47;可以基于动态规划的思想去优化<br>    &#47;&#47;存储每一个步骤的值，然后推导出之后的值<br>    let hash = {};<br>    const calcu = (n) =&gt; {<br>        if (n === 1 || n === 2) return 1;<br>        let a = hash[n - 1] || calcu(n - 1);<br>        let b = hash[n - 2] || calcu(n - 2);<br>        return a + b;<br>    }<br>    for (let i = 1; i &lt;= n; i++) {<br>        hash[i] = calcu(i)<br>    }<br>    return hash[n]<br>}","like_count":11,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439294,"discussion_content":"👍  你还得把我文章里涉及的所有题目都搞明白、会默写才算入门呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551233002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1250922,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIzGGthScz54sECZJKX3lgyjCATkgrvSt5N3eOsYB34jibCr3SkAX88QaZ5IVmME9Ec7VdkQGwRSPw/132","nickname":"哈哈哈","note":"","ucode":"8AC20A1C9C7DF8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305725,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600070055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72533,"user_name":"G.S.K","can_delete":false,"product_type":"c1","uid":1222966,"ip_address":"","ucode":"88217F9289EB48","user_header":"https://static001.geekbang.org/account/avatar/00/12/a9/36/d054c979.jpg","comment_is_top":false,"comment_ctime":1551665483,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"44501338443","product_id":100017301,"comment_content":"关于knapsack2函数<br>1 states表示当前背包总重量所有可能取值的集合<br>2 如果将第i个物品放入背包，我们需要在当前背包总重量的所有取值中，找到小于等于j的（j=w-items[i]）<br>3 为什么第6行j需要从大到小来处理？因为循环的目的是在当前背包总重量的所有可能取值中，找到小于等于j的，如果j从小到大来处理，states[j+items[i]] = true;这个赋值会影响后续的处理<br>public static int knapsack2(int[] items, int n, int w) {<br>  boolean[] states = new boolean[w+1]; &#47;&#47; 默认值 false<br>  states[0] = true;  &#47;&#47; 第一行的数据要特殊处理，可以利用哨兵优化<br>  states[items[0]] = true;<br>  for (int i = 1; i &lt; n; ++i) { &#47;&#47; 动态规划<br>    for (int j = w-items[i]; j &gt;= 0; --j) {&#47;&#47; 把第 i 个物品放入背包<br>      if (states[j]==true) states[j+items[i]] = true;<br>    }<br>  }<br>  for (int i = w; i &gt;= 0; --i) { &#47;&#47; 输出结果<br>    if (states[i] == true) return i;<br>  }<br>  return 0;<br>}<br>","like_count":10,"discussions":[{"author":{"id":1571460,"avatar":"https://static001.geekbang.org/account/avatar/00/17/fa/84/f01d203a.jpg","nickname":"Simple life","note":"","ucode":"1902D7F72FB43F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":230731,"discussion_content":"补充一下，循环从大到小是因为， states[j+items[i]] 如果从小到大的相加的话，可能同一个物品会判断两次，因为item[i]是固定的，相加的值是由j来决定，如果从小到大，j+item[i]得出一个值a，然后后面继续循环到item[i]可能会循环到a这个位置，然后判断味true后，再进行j+items[i]相加，这样同一个i就重复相加了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586767424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1136329,"avatar":"https://static001.geekbang.org/account/avatar/00/11/56/c9/7b3cd3e0.jpg","nickname":"马振","note":"","ucode":"94234F533219C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79278,"discussion_content":"自己写的时候遇到相同问题了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576071848,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":54182,"user_name":"小虾米","can_delete":false,"product_type":"c1","uid":1005528,"ip_address":"","ucode":"F543987A7FAB20","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/d8/425e1b0a.jpg","comment_is_top":false,"comment_ctime":1545801531,"is_pvip":false,"replies":[{"id":"19650","content":"是的 我改下","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545825916,"ip_address":"","comment_id":54182,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44495474491","product_id":100017301,"comment_content":"老师，倒数第二段的代码(背包升级版)的12行的if条件判断是不是写错了","like_count":10,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434385,"discussion_content":"是的 我改下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545825916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":70334,"user_name":"黄均鹏","can_delete":false,"product_type":"c1","uid":1131636,"ip_address":"","ucode":"27F852817B9B98","user_header":"https://static001.geekbang.org/account/avatar/00/11/44/74/f98299ee.jpg","comment_is_top":false,"comment_ctime":1551077954,"is_pvip":false,"replies":[{"id":"25194","content":"男朋友也可以的：）","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551147433,"ip_address":"","comment_id":70334,"utype":1}],"discussion_count":2,"race_medal":0,"score":"40205783618","product_id":100017301,"comment_content":"解开这道题的前提是首先得先有个女朋友","like_count":9,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440569,"discussion_content":"男朋友也可以的：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551147433,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194572,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3a/4c/b6200773.jpg","nickname":"一步","note":"","ucode":"FBFAE23E8E48B7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305401,"discussion_content":"楼上皮一下很开心：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599909426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":149154,"user_name":"指尖流逝","can_delete":false,"product_type":"c1","uid":1005381,"ip_address":"","ucode":"417009F674FAF1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/45/c418ea5c.jpg","comment_is_top":false,"comment_ctime":1573171139,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35932909507","product_id":100017301,"comment_content":"基础太差，0 - 1背包问题的动态规划解法，琢磨了很久。贴下我理解的注释<br><br>```java<br>public int knapsack(int[] weight, int n, int w) {<br>        &#47;&#47; 0 ~ w中重量结果<br>        boolean[][] states = new boolean[n][w+1];<br><br>        states[0][0] = true;<br>        if (weight[0] &lt;= w) {<br>            states[0][weight[0]] = true;<br>        }<br><br>        &#47;&#47; 考察 1 ~ n - 1 个物品<br>        for (int i = 1; i &lt; n; i++) {<br>            &#47;&#47; 0 ~ w 种重量结果<br>            for (int j = 0; j &lt;= w; j++) {<br>                &#47;&#47; 不装第i个物品，决策时重量保持原有重量状态<br>                if (states[i - 1][j]) {<br>                    states[i][j] = states[i - 1][j];<br>                }<br>            }<br>            &#47;&#47; j &lt;= w - weight[i] 约束最大重量（即 j + weight[i] &lt;= w)<br>            for (int j = 0; j &lt;= w - weight[i]; j++) {<br>                &#47;&#47; 装第i个物品，决策时重量 = 原有重量状态 + 第i个物品重量<br>                if (states[i - 1][j]) {<br>                    states[i][j + weight[i]] = true;<br>                }<br>            }<br>        }<br>        &#47;&#47; 从最后的状态中，取最接近w的值<br>        for (int i = w; i &gt;= 0; i--) {<br>            if (states[n - 1][i]) {<br>                return i;<br>            }<br>        }<br>        return 0;<br>    }<br>```","like_count":8},{"had_liked":false,"id":54555,"user_name":"像玉一样的石头","can_delete":false,"product_type":"c1","uid":1182375,"ip_address":"","ucode":"FD00F1B56AADE8","user_header":"https://static001.geekbang.org/account/avatar/00/12/0a/a7/ebc40b7c.jpg","comment_is_top":false,"comment_ctime":1545899902,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"31610670974","product_id":100017301,"comment_content":"老师，请教个问题，想了好久不知道该如何求解<br>关于汇率方面的，比如手里有100人民币，设计一个汇率转换的环，比如人民币-》美元-》日元-》韩元-》人民币，兑换一圈后，手里的钱一直在增加，这个问题该如何求解呢","like_count":7,"discussions":[{"author":{"id":2029015,"avatar":"","nickname":"小钢炮","note":"","ucode":"676C4CCF3CCD0D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":396376,"discussion_content":"钱生钱，牛逼","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1632412913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2157088,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/8hpHcicHDzYN0TqL1SRZ8Zq8TWtgnofYcTAQw7ibicY6umqsJ4onCqJyxBLHl94XcWH4tyxKxGcMHiaZEZjnSbjvag/132","nickname":"clelo4","note":"","ucode":"F57CB21CA13A4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348372,"discussion_content":"哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612529075,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":60868,"user_name":"王者归来","can_delete":false,"product_type":"c1","uid":1349051,"ip_address":"","ucode":"7518431E647410","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Dyic3CxSFwI4wsNTia2UzqaQL2pENLp8rRkNgBaCzr82BSMibegfnfYQbTCYOMXicZymXAqIk8zf1neUFeicmyxnFXw/132","comment_is_top":false,"comment_ctime":1547565168,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27317368944","product_id":100017301,"comment_content":"动态规划虽然难懂，每天坚持看一点，今天放下心来看终于明白了许多，一定要拿下","like_count":6},{"had_liked":false,"id":54975,"user_name":"任悦","can_delete":false,"product_type":"c1","uid":1241960,"ip_address":"","ucode":"9D2F99C058056B","user_header":"https://static001.geekbang.org/account/avatar/00/12/f3/68/726a8c3d.jpg","comment_is_top":false,"comment_ctime":1545990542,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27315794318","product_id":100017301,"comment_content":"思考题这个杨辉三角有点巧了，最短路径就是最左边一列","like_count":6},{"had_liked":false,"id":226525,"user_name":"xk_","can_delete":false,"product_type":"c1","uid":1514305,"ip_address":"","ucode":"DFE1AC38EA78A7","user_header":"https://static001.geekbang.org/account/avatar/00/17/1b/41/dbb7d785.jpg","comment_is_top":false,"comment_ctime":1592128331,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"23066964811","product_id":100017301,"comment_content":"“这里我特别强调一下代码中的第 8 行，j 需要从大到小来处理。”<br>如果从小到大处理： stat[ j&#39; + weight[i]] 的赋值为 ture，那么当 j++ 遍历到 j&#39;+weight[i] 这个值。就为ture，重复计算了。<br>从大到小处理，较大的 stat[ j + weight[i]] 的值， 影响不到  j-- 后面的。<br><br>这个小细节学习了。","like_count":5,"discussions":[{"author":{"id":2113150,"avatar":"https://static001.geekbang.org/account/avatar/00/20/3e/7e/3dac54fa.jpg","nickname":"曾益达","note":"","ucode":"AC20D6F5EF01C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298906,"discussion_content":"会影响结果的，自己实现几个题就知道了，很妙的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597471956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1245294,"avatar":"https://static001.geekbang.org/account/avatar/00/13/00/6e/11362a1e.jpg","nickname":"感动超人","note":"","ucode":"DDBFE64A9DB28D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291856,"discussion_content":"\npublic class DynamicProgramOrder {\n\n\n    // j 从大到小循环\n    public static int knapsack2(int[] items, int n, int w) {\n        boolean[] states = new boolean[w+1]; // 默认值false\n        states[0] = true;  // 第一行的数据要特殊处理，可以利用哨兵优化\n        if (items[0] <= w) {\n            states[items[0]] = true;\n        }\n        for (int i = 1; i < n; ++i) { // 动态规划\n            for (int j = w-items[i]; j >= 0; --j) {//把第i个物品放入背包\n                if (states[j]==true) states[j+items[i]] = true;\n            }\n        }\n        for (int i = w; i >= 0; --i) { // 输出结果\n            if (states[i] == true) return i;\n        }\n        return 0;\n    }\n\n    // j 从小到大循环\n    public static int knapsack1(int[] items, int n, int w) {\n        boolean[] states = new boolean[w+1]; // 默认值false\n        states[0] = true;  // 第一行的数据要特殊处理，可以利用哨兵优化\n        if (items[0] <= w) {\n            states[items[0]] = true;\n        }\n        for (int i = 1; i < n; ++i) { // 动态规划\n            for (int j = 0; j <= w-items[i]; j++) {//把第i个物品放入背包\n                if (states[j]==true) states[j+items[i]] = true;\n            }\n        }\n        for (int i = w; i >= 0; --i) { // 输出结果\n            if (states[i] == true) return i;\n        }\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        DynamicProgramOrder dpo = new DynamicProgramOrder();\n        int[] a = {1,31,2};\n        System.out.println(&#34;j 从大到小&#34;+dpo.knapsack2(a,3,76));\n        System.out.println(&#34;==========================&#34;);\n        System.out.println(&#34;j 从小到大&#34; + dpo.knapsack1(a,3,76));\n    }\n\n\n}\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594976495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1099324,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c6/3c/8ab9deb0.jpg","nickname":"@许还真","note":"","ucode":"6D754D5AE44CEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283994,"discussion_content":"但不会影响结果吧 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592409866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1514305,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1b/41/dbb7d785.jpg","nickname":"xk_","note":"","ucode":"DFE1AC38EA78A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1099324,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c6/3c/8ab9deb0.jpg","nickname":"@许还真","note":"","ucode":"6D754D5AE44CEC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285493,"discussion_content":"不会\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592843007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":283994,"ip_address":""},"score":285493,"extra":""},{"author":{"id":1099324,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c6/3c/8ab9deb0.jpg","nickname":"@许还真","note":"","ucode":"6D754D5AE44CEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1514305,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1b/41/dbb7d785.jpg","nickname":"xk_","note":"","ucode":"DFE1AC38EA78A7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286975,"discussion_content":"Get","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593337688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":285493,"ip_address":""},"score":286975,"extra":""},{"author":{"id":1245294,"avatar":"https://static001.geekbang.org/account/avatar/00/13/00/6e/11362a1e.jpg","nickname":"感动超人","note":"","ucode":"DDBFE64A9DB28D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1099324,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c6/3c/8ab9deb0.jpg","nickname":"@许还真","note":"","ucode":"6D754D5AE44CEC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291855,"discussion_content":"是会影响结果的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594976355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":286975,"ip_address":""},"score":291855,"extra":""}]}]},{"had_liked":false,"id":154813,"user_name":"乾坤瞬间","can_delete":false,"product_type":"c1","uid":1683130,"ip_address":"","ucode":"15BDCF29CBF8EB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","comment_is_top":false,"comment_ctime":1574572190,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18754441374","product_id":100017301,"comment_content":"通过老师的讲解我有如下体会<br>第一动态规划问题可以不用递归，而且可以用比较简单朴素的标记就可以解决问题<br>第二 动态规划的解题思路会包含多个阶段，这个阶段与层数密切相关<br>第三 动态规划是一种每个阶段都会受到前面阶段的影响，也就是有别于分而治之的思想的一个重要，分治思想是在每一个阶段分解成不同一问题来求解。而动态规划的核心是想到一种状态，比状态根据不同问题会有不同表示，目前累积问题可以用状态能够很好地表示，使得每个阶段的状态尽量地满足求解的问题的期望值<br>第四 动态规划只是一种思想，不收数据结构限制，可以使用任何一种能够在空间时间复杂度都较为完美的方案来写<br><br>因此杨辉三角变形问题可以用如下表示<br>1，阶段划分，杨辉三角有多少层，就有多少阶段，对应到编码实现上就会有多少次for循环<br>2，状态的定义，先根据题目假设，期望总路线的距离总和最小，所以我们可以假设算法到达没层的距离都是最小值，此时的状态就是到达没一层的距离值作为状态进行保留，打个比方，看第三层的第二个元素3的上一层的左右两个节点的状态，分别是12(5+7),13(5+8)因此我们把12作为这个元素状态的前状态值作为计算，因此，第三层的第二元素所对应的状态值为15(12+3)，依次类推，在最后一层的状态中找到最小的值最为最小距离<br><br>我觉得如果杨辉三角的节点存储的是一棵树，而且每个树的节点都包含父亲节点列表，那么我们可以可以用更加快捷的方式去计算状态值，保存到当前树的节点中，这样编写代码非常方便，而不用局限于数组的坐标运算了","like_count":4},{"had_liked":false,"id":87699,"user_name":"mαnajay","can_delete":false,"product_type":"c1","uid":1067450,"ip_address":"","ucode":"6DE9FBD1BEC8AD","user_header":"https://static001.geekbang.org/account/avatar/00/10/49/ba/23c9246a.jpg","comment_is_top":false,"comment_ctime":1555663731,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18735532915","product_id":100017301,"comment_content":"记录一下自己的 swift 版本一维数组动态规划装东西<br>&#47;*<br> *<br> * 动态规划<br> <br> * 注意  Source 里面应该是 public, 运行时才不好报错<br> **&#47;<br>public struct DynamicProgramming {<br>    init() {<br>    }<br>    <br>    public static func knapsack2(_ items: Array&lt;Int&gt;, _ maxWeight: Int ) -&gt; Void {<br>        let count = items.count<br>        var states = Array&lt;Bool&gt;.init(repeating: false, count: count + 1)<br>        &#47;&#47; 首个没有放入<br>        states[0] = true<br>        &#47;&#47; 首个放入了<br>        states[items[0]] = true<br>        for i in 1..&lt;count { &#47;&#47; 动态规划<br>            &#47;&#47; 从去除已经计算过重量的最大的重量开始算起i, 把第 i 个物品放入背包<br>            for j in 0 ... (maxWeight - items[i]) {&#47;&#47; 除了第 i 个物品, 剩余重量,如果有计算过的, 那么再加上第 i 个物品, 记录此时总重量的状态<br>                if (states[j] == true) {<br>                    let total = j + items[i]<br>                    states[total] = true<br>                }<br>            }<br>        }<br>        for v in (0 ... maxWeight).reversed() {<br>            if states[v] {<br>                print(&quot;maxWeight index: \\(v)&quot;)<br>                break<br>            }<br>        }<br>    }<br>}<br>","like_count":4},{"had_liked":false,"id":64594,"user_name":"德尼","can_delete":false,"product_type":"c1","uid":1328081,"ip_address":"","ucode":"04D3836994EDF8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/8rNWRmZ2slWlXZNFJiakMBo8zTTXCw1egz8tPia3JTmxCpP9wsPU7ABSG0PiboeEiaIyLQoTnQN3Jd7ibscdpRyEIAg/132","comment_is_top":false,"comment_ctime":1548832205,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18728701389","product_id":100017301,"comment_content":"解答开篇代码的19行那的判断为什么是 j==-1？在上面的循环中假设从 w 到 3*w+1 没有可解的话，那么 j 的结果不应该是 3*w+2 吗？","like_count":4},{"had_liked":false,"id":63973,"user_name":"不凉青年","can_delete":false,"product_type":"c1","uid":1238519,"ip_address":"","ucode":"305A5D92CAD98F","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/f7/70ae6368.jpg","comment_is_top":false,"comment_ctime":1548634909,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18728504093","product_id":100017301,"comment_content":"这节讲解超厉害","like_count":4},{"had_liked":false,"id":54014,"user_name":"家","can_delete":false,"product_type":"c1","uid":1239284,"ip_address":"","ucode":"CA3597C948E9CF","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/f4/d1fcfa4d.jpg","comment_is_top":false,"comment_ctime":1545786345,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18725655529","product_id":100017301,"comment_content":"是不是可以从下往上递推，每个节点都选择下一层能到的两个节点中最小的一个和本身相加，加到根节点应该就是最小值。","like_count":4},{"had_liked":false,"id":133846,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1568683456,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14453585344","product_id":100017301,"comment_content":"对于文章中的题目要是有个验证环境就更好了，就像leetcode那种","like_count":3},{"had_liked":false,"id":119252,"user_name":"柳志焕","can_delete":false,"product_type":"c1","uid":1235940,"ip_address":"","ucode":"42375930DC2AA0","user_header":"https://static001.geekbang.org/account/avatar/00/12/db/e4/a1b45d79.jpg","comment_is_top":false,"comment_ctime":1564544147,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14449446035","product_id":100017301,"comment_content":"1. 回溯法 <br>private static int minValue = Integer.MAX_VALUE;<br>    &#47;*调用 triangle(0,0,0,matrix,5)*&#47;<br>    public void triangle(int i, int j, int dist, int[][] matrix, int n) {<br>        dist += matrix[i][j];<br>        if(i == n-1) {<br>            if(minValue &gt; dist) minValue = dist;<br>            return;<br>        }<br>        triangle(i+1,j,dist,matrix,n);<br>        triangle(i+1,j+1,dist,matrix,n);<br><br>    }<br>2. 动态规划：<br>public int minDistDpTriangle(int[][] matrix, int n) {<br><br>        int[][] states = new int[n][];<br>        for(int i = 0; i&lt;n; i++) {<br>            states[i] = new int[i+1];<br>        }<br>        &#47;&#47; 初始化第一列<br>        int sum = 0;<br>        for(int i = 0; i&lt; n; i++) {<br>            sum += matrix[i][0];<br>            states[i][0] = sum;<br>        }<br>        sum = 0;<br>        for(int i = 0,j=0; i&lt;n; i++,j++) {<br>            sum += matrix[i][j];<br>            states[i][j] = sum;<br>        }<br>        for(int i = 2; i&lt; n; i++) {<br>            for(int j = 1; j&lt; states[i].length -1; j++){<br>                states[i][j] = matrix[i][j] + Math.min(states[i-1][j],states[i-1][j-1]);<br>            }<br>        }<br>        int minValue = Integer.MAX_VALUE;<br>        for(int j = 0; j&lt; n; j++) {<br>            if(states[n-1][j] &lt; minValue) minValue = states[n-1][j];<br>        }<br>        return minValue;<br>    }","like_count":3},{"had_liked":false,"id":58353,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1547043566,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14431945454","product_id":100017301,"comment_content":"思考题，杨辉三角，思路（Java版）：<br>记入参的数据结构是List&lt;List&lt;Integer&gt;&gt; list<br>状态转移方程为f(i,j)=list.get(i).get(j)+min(list.get(i - 1).get(j - 1)),list.get(i-1).get(j))<br>注意：需要注意数组越界问题。<br>","like_count":3},{"had_liked":false,"id":54207,"user_name":"blacknhole","can_delete":false,"product_type":"c1","uid":1098286,"ip_address":"","ucode":"271682FFE28F25","user_header":"https://static001.geekbang.org/account/avatar/00/10/c2/2e/c4a527d9.jpg","comment_is_top":false,"comment_ctime":1545806420,"is_pvip":false,"replies":[{"id":"19649","content":"是的 我改下 感谢","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545825843,"ip_address":"","comment_id":54207,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14430708308","product_id":100017301,"comment_content":"有个疑问：<br>解答开篇的示例代码中，for (int j = 0; j &lt;= w; ++j) {...} 和 for (int j = 0; j &lt;= w-items[i]; ++j) {...} 的循环条件是不是有问题啊，应分别为 j &lt;= 3 * w 和 j &lt;= 3 * w - items[i] 吧？","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434393,"discussion_content":"是的 我改下 感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545825843,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":279039,"user_name":"xxx","can_delete":false,"product_type":"c1","uid":1356978,"ip_address":"","ucode":"E78B1F15BC10F7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIcLjatV3GHdibZXCTIgL1X2A7jpByIeLH3Zyia8KXdT4JRcicmVSgq5ekRHCFCFenMqicsAwaWYibHkTw/132","comment_is_top":false,"comment_ctime":1613562580,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10203497172","product_id":100017301,"comment_content":"哦！我又知道了！回溯算法时间复杂度之所以那么大，是因为每种情况都使用了递归，就像阶梯问题一样，会有大量的重复调用。而动态规划通过记录下状态，相同的状态只需要调用一次即可，而且使用的是循环，不是递归。","like_count":2},{"had_liked":false,"id":201821,"user_name":"zapup","can_delete":false,"product_type":"c1","uid":1397351,"ip_address":"","ucode":"388D6BB5D7B137","user_header":"https://static001.geekbang.org/account/avatar/00/15/52/67/fcba0967.jpg","comment_is_top":false,"comment_ctime":1585840439,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10175775031","product_id":100017301,"comment_content":"“当 n 很大时”…纠结钱包的可能就是我了XD 所以…必须要学好啊！😄","like_count":2},{"had_liked":false,"id":81280,"user_name":"草长莺飞","can_delete":false,"product_type":"c1","uid":1243108,"ip_address":"","ucode":"7A281E8DB11BBB","user_header":"https://static001.geekbang.org/account/avatar/00/12/f7/e4/c8cfca11.jpg","comment_is_top":false,"comment_ctime":1553848014,"is_pvip":false,"replies":[{"id":"29630","content":"你说的哪个代码啊？","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1554031439,"ip_address":"","comment_id":81280,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10143782606","product_id":100017301,"comment_content":"老师这是我看了你的思路后自己写的代码，后面看了你的代码。有个地方就是放置与不放的地方就可以写在一个for循环中为什么要写两个for循环呢","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445138,"discussion_content":"你说的哪个代码啊？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554031439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1170925,"avatar":"https://static001.geekbang.org/account/avatar/00/11/dd/ed/e6eed95e.jpg","nickname":"Flying","note":"","ucode":"CA3DCE897F2013","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359203,"discussion_content":"我也是这样想的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616137962,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":54265,"user_name":"@","can_delete":false,"product_type":"c1","uid":1249561,"ip_address":"","ucode":"EC3932BC1E9137","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/19/e9b052dd.jpg","comment_is_top":false,"comment_ctime":1545818330,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10135752922","product_id":100017301,"comment_content":"第三部分的代码，第11行是不是有问题？根据代码推不出states[4][3]=true???","like_count":2},{"had_liked":false,"id":264420,"user_name":"平凡之路","can_delete":false,"product_type":"c1","uid":1669273,"ip_address":"","ucode":"96CE12339BD5FD","user_header":"https://static001.geekbang.org/account/avatar/00/19/78/99/6060eb2d.jpg","comment_is_top":false,"comment_ctime":1606461518,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5901428814","product_id":100017301,"comment_content":"老师，您好，knapsack2怎么理解装和不装的问题呢？","like_count":1},{"had_liked":false,"id":261527,"user_name":"hao","can_delete":false,"product_type":"c1","uid":1148845,"ip_address":"","ucode":"997F2B57E2F556","user_header":"https://static001.geekbang.org/account/avatar/00/11/87/ad/50a85a04.jpg","comment_is_top":false,"comment_ctime":1605374068,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5900341364","product_id":100017301,"comment_content":"states  <br> 英  [steɪts]   美  [steɪts]<br><br>n. 州，国家（state的复数形式）<br>vt. 声明（state的第三人称单数形式）；陈述","like_count":1},{"had_liked":false,"id":250605,"user_name":"unlock","can_delete":false,"product_type":"c1","uid":1335403,"ip_address":"","ucode":"9B1F899B960A20","user_header":"https://static001.geekbang.org/account/avatar/00/14/60/6b/907a9557.jpg","comment_is_top":false,"comment_ctime":1601168372,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5896135668","product_id":100017301,"comment_content":"如果商品的价格是非常大且非整数，要怎么来搞呢？比如价钱是100000.5元，如果把价格都乘10变为整数，那申请的临时空间会变的非常大，这个怎么解决呢","like_count":1},{"had_liked":false,"id":236903,"user_name":"🐬🐬🐬","can_delete":false,"product_type":"c1","uid":1155214,"ip_address":"","ucode":"6585F8B8ADC43E","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/8e/919dee01.jpg","comment_is_top":false,"comment_ctime":1595580602,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5890547898","product_id":100017301,"comment_content":"杨辉三角用二维数组表示：<br><br>let yang = [[5],[7,8],[2,3,4],[4,9,6,1],[2,7,9,4,5]]<br><br>以下为代码实现：<br>const getMinPath = (yang) =&gt; {<br>    let a = [] &#47;&#47; 存储杨辉三角对应节点走过路径的和的最小值<br>    for(let i = 0; i &lt; yang.length; i++) {<br>        a[i] = []<br>        for(let j = 0; j &lt; i + 1; j++) {<br>            if(i === 0) { &#47;&#47; 第一层直接赋值<br>                a[i][j] = yang[i][j]<br>            } else if (i === 1) { &#47;&#47; 第二层直接叠加第一层的值<br>                a[i][j] = yang[i][j] + a[i-1][0]<br>            } else if(i &gt; 1) {<br>                if(j === 0) {<br>                    a[i][j] = a[i-1][0] + yang[i][j] <br>                } else if(j === i) {<br>                    a[i][j] = a[i - 1][j-1] + yang[i][j]<br>                } else { &#47;&#47; 从第三层开始 除头尾节点 其余节点都有两个值 每次只保留最小的那个即可<br>                    let left = a[i - 1][j - 1] + yang[i][j]<br>                    let right = a[i - 1][j] + yang[i][j]<br>                    a[i][j] = Math.min(left,right)<br>                }<br>            }<br>        }<br>    }<br>    let s = yang.length - 1 &#47;&#47; 获取最后一层<br>    let minPath = a[s][0];<br>    for (let i = 0; i &lt; yang.length; i++) { &#47;&#47; 最后一层为之前走过的路径之和 直接在这一层找最小值即可<br>        minPath = Math.min(a[s][i], minPath)<br>    }<br>    return minPath<br>}<br><br>const res = getMinPath(yang)<br>console.log(res) 结果为20","like_count":1},{"had_liked":false,"id":232615,"user_name":"xk_","can_delete":false,"product_type":"c1","uid":1514305,"ip_address":"","ucode":"DFE1AC38EA78A7","user_header":"https://static001.geekbang.org/account/avatar/00/17/1b/41/dbb7d785.jpg","comment_is_top":false,"comment_ctime":1594050428,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5889017724","product_id":100017301,"comment_content":"课后题：<br>状态转移表法，并做了空间优化<br>z为原始表格<br>d是路径和<br>i是行数<br>j是列数<br>f( i, j, d(i - 1, j - 1) + z[i][j] ) -&gt; f( i+1, j, d(i, j) + z[i+1][j] ),f( i+1, j+1, d(i, j) + z[i+1][j+1] )<br>...<br>当有相同状态f(x,y)的时候求min()<br><br><br> int[][] yangHuiTriangle = {{5}, {7, 8}, {2, 3, 4}, {4, 9, 6, 1}, {2, 7, 9, 4, 5}};<br> void dynamic2(int[][] triangle, int n) {<br>        int[] res = new int[n];<br>        res[0] = triangle[0][0];<br>        for (int i = 1; i &lt; n; i++) {<br>            &#47;&#47; 倒着遍历，取一个上一层的j，置空，就不会影响遍历了。<br>            for (int j = i - 1; j &gt;= 0; j--) {<br>                &#47;&#47;上一层的<br>                int up = res[j];<br>                res[j] = 0; &#47;&#47;因为是上一层的，所以置空<br>                int t_j = triangle[i][j];<br>                &#47;&#47; f(i,j)<br>                if (res[j] == 0 || res[j] &gt; up + t_j)<br>                    res[j] = up + t_j;<br>                t_j = triangle[i][j + 1];<br>                &#47;&#47; f(i,j+1)<br>                if (res[j + 1] == 0 || res[j] &gt; up + t_j) {<br>                    res[j + 1] = up + t_j;<br>                }<br>            }<br>             System.out.println(Arrays.toString(res));<br>             System.out.println(&quot;===========&quot;);<br>        }<br>        int min = Integer.MAX_VALUE;<br>        for (int i : res) {<br>            if (i &lt; min) min = i;<br>        }<br>        System.out.println(min);<br>    }","like_count":1},{"had_liked":false,"id":122862,"user_name":"CathyLin","can_delete":false,"product_type":"c1","uid":1240546,"ip_address":"","ucode":"F7CDFF5E1A235F","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/e2/0e1c6c5a.jpg","comment_is_top":false,"comment_ctime":1565560336,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5860527632","product_id":100017301,"comment_content":"课后思考 (用了两种方法):<br>首先最重要的是定义好子问题<br>1. 定义 dp[i][j] 为 从第一层走到第 i 层第 j 列所花费的最小数字之和。<br>dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + val[i][j];  (注意 j=0 的特殊情况)<br>初始化边界条件: dp[0][0] = val[0][0];<br>这个是从上往下构建的方法，可以用迭代的方式来实现。<br>最后要在最后一行中找 dp[n-1][j] 最小的值。<br><br>2. 定义 dp[i][j] 为从第 i 行的第 j 列走到起点第 0 行第 0 列的最小数字之和。<br>dp[i][j] = min(dp[i+1][j-1], dp[i+1][j]) + val[i][j]; (也要注意 j=0 的特殊情况)<br>结束条件:<br>初始化最后一行的 dp[n-1][j] = val[n-1][j]<br>因为这个是从下往上构建答案的方法，用迭代也可以实现。<br>最后 return dp[0][0] 就是答案。","like_count":1},{"had_liked":false,"id":122226,"user_name":"青青子衿","can_delete":false,"product_type":"c1","uid":1438102,"ip_address":"","ucode":"4A388A3BA70C29","user_header":"https://static001.geekbang.org/account/avatar/00/15/f1/96/9571fa3d.jpg","comment_is_top":false,"comment_ctime":1565319108,"is_pvip":false,"replies":[{"id":"45695","content":"貌似不行，你这个算法本身就不对，你这个是贪心，而且没法求最优解","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1565909255,"ip_address":"","comment_id":122226,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5860286404","product_id":100017301,"comment_content":"杨辉三角的题目是不是可以这样想，顶层最短路径=顶层节点值+第二层最短路径的最小值，依次类推，使用递归方法？如果这样做的话这个算法到底是分治算法还是动态规划算法？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462159,"discussion_content":"貌似不行，你这个算法本身就不对，你这个是贪心，而且没法求最优解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565909255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1438102,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f1/96/9571fa3d.jpg","nickname":"青青子衿","note":"","ucode":"4A388A3BA70C29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5060,"discussion_content":"是的，是我想错了，多谢老师指点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565918564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114641,"user_name":"的的喀喀湖","can_delete":false,"product_type":"c1","uid":1137138,"ip_address":"","ucode":"E95301D913F115","user_header":"https://static001.geekbang.org/account/avatar/00/11/59/f2/ef476ddc.jpg","comment_is_top":false,"comment_ctime":1563355019,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5858322315","product_id":100017301,"comment_content":"精彩，受益匪浅，之前看了很多动态规划文章，看不懂，这篇终于看明白了，算是简单入门了","like_count":1},{"had_liked":false,"id":91273,"user_name":"好人","can_delete":false,"product_type":"c1","uid":1439552,"ip_address":"","ucode":"8BA995A57F7E1A","user_header":"https://static001.geekbang.org/account/avatar/00/15/f7/40/cba812dc.jpg","comment_is_top":false,"comment_ctime":1556960467,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5851927763","product_id":100017301,"comment_content":"话不多说，总之感谢，有点感觉了。","like_count":1},{"had_liked":false,"id":82296,"user_name":"挠头侠","can_delete":false,"product_type":"c1","uid":1150474,"ip_address":"","ucode":"F96966832E2252","user_header":"https://static001.geekbang.org/account/avatar/00/11/8e/0a/31ec5392.jpg","comment_is_top":false,"comment_ctime":1554178132,"is_pvip":false,"replies":[{"id":"30237","content":"我去看下 多谢指出","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1554680047,"ip_address":"","comment_id":82296,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5849145428","product_id":100017301,"comment_content":"老师 您给的github上的python01背包动态回归的代码 我将您背包升级问题的重量和价值导入，输出的最大价值不应该是18吗，可是给出的代码输出是17是不是有误呀。","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445544,"discussion_content":"我去看下 多谢指出","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554680047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81608,"user_name":"SnowsonZ","can_delete":false,"product_type":"c1","uid":1446972,"ip_address":"","ucode":"5AF76D55CCDC8F","user_header":"https://static001.geekbang.org/account/avatar/00/16/14/3c/d6be29f3.jpg","comment_is_top":false,"comment_ctime":1553961115,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5848928411","product_id":100017301,"comment_content":"1. 背包问题降低空间复杂度的算法中：j必须从大到小的，debug可以清楚看到。<br>若j从小到大，情况如下（w=9）：<br>初始states数组标记为true的元素下表是0， 2<br>第一次循环结束后，states的情况是0，2，4，6<br>...<br>可以看到，在第一次循环中，当j=4时， 会造成state[j + items[1]] = states[4 + 2] = true,下表为6的标志位在本次循环不应该为true，即若j从小到大，会造成前面的计算结果影响后面的计算，所以j只能从大到小。<br><br>2. 有一个问题，在购物的例子中，最后求购买哪些商品时，老师给的例子中，循环中没有包括第一个商品，即数组中下表为0的商品，而是在循环结束时，单独判断了一次，不太清楚老师这样做的原因是什么。希望老师解答一下。谢谢。","like_count":1,"discussions":[{"author":{"id":2029015,"avatar":"","nickname":"小钢炮","note":"","ucode":"676C4CCF3CCD0D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":396382,"discussion_content":"因为for循环是从i=1开始的，（循环中有state[i-1]）。所以需要单独考虑第一个商品","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632413443,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1236556,"avatar":"https://static001.geekbang.org/account/avatar/00/12/de/4c/a51ece16.jpg","nickname":"刘润森","note":"","ucode":"84101C670A6747","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304769,"discussion_content":"崔大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599660234,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1050777,"avatar":"https://static001.geekbang.org/account/avatar/00/10/08/99/6ab45a2f.jpg","nickname":"小时候可鲜啦","note":"","ucode":"C88B3EDF758230","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302934,"discussion_content":"那是因为第一行是特殊处理的，status[0][0]为true，但是并没有买第一个商品。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599092451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64596,"user_name":"德尼","can_delete":false,"product_type":"c1","uid":1328081,"ip_address":"","ucode":"04D3836994EDF8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/8rNWRmZ2slWlXZNFJiakMBo8zTTXCw1egz8tPia3JTmxCpP9wsPU7ABSG0PiboeEiaIyLQoTnQN3Jd7ibscdpRyEIAg/132","comment_is_top":false,"comment_ctime":1548832293,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5843799589","product_id":100017301,"comment_content":"说错了，j 最后应该是 3*w+1.","like_count":1},{"had_liked":false,"id":54590,"user_name":"©™","can_delete":false,"product_type":"c1","uid":1024962,"ip_address":"","ucode":"766C79DEFA2887","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a3/c2/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1545907975,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5840875271","product_id":100017301,"comment_content":"哪位老铁用python实现一下？","like_count":1},{"had_liked":false,"id":359617,"user_name":"111","can_delete":false,"product_type":"c1","uid":3109487,"ip_address":"北京","ucode":"D6E8E83A118A3E","user_header":"https://static001.geekbang.org/account/avatar/00/2f/72/6f/44c10658.jpg","comment_is_top":false,"comment_ctime":1665708966,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665708966","product_id":100017301,"comment_content":"动态规划有点像贪心，但是比贪心的考虑要更全面，因为每次更新都是拿之前的最优解，而贪心是拿到当前最优解，就相当于动归永远比当前多走一步。","like_count":0},{"had_liked":false,"id":357301,"user_name":"tanatang","can_delete":false,"product_type":"c1","uid":2349826,"ip_address":"四川","ucode":"7526705D25959A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/FhibmYQUzY7ibPac8Id5PwbibqCbvj5rWibeQhEyvYguc9pvPNUciaQydicrUjJKkhhp1s2AgfP7LRTZA8zqaa82yC8g/132","comment_is_top":false,"comment_ctime":1663144111,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1663144111","product_id":100017301,"comment_content":"课后思考题：<br>int minRoute(int[] datas)<br>{<br>\tif(datas == null || datas.count() == 0)<br>\t{<br>\t\treturn 0;<br>\t}<br>\tint count = datas.count();<br>\tList&lt;int&gt; levelminroutes = new List&lt;int&gt;();<br>\tlevelminroutes.Add(datas[0]);<br><br>\tint level = 2;<br>\tint lastindex = 0;<br>\tint sparecount = count - 1;<br><br>\twhile(sparecount &gt;= level)<br>\t{<br>\t\tsparecount -= level;<br><br>\t\tList&lt;int&gt; lastlevel = new List&lt;int&gt;(levelminroutes);<br>\t\tlevelminroutes[0] = lastlevel[0] + datas[lastindex + 1];<br>\t\tfor(int i=1; i&lt; level - 1; i++)<br>\t\t{<br>\t\t\tlevelminroutes[i] = min(lastlevel[i-1], lastlevel[i]) + datas[lastindex + 1 + i];<br>\t\t}<br>\t\tlevelminroutes.Add(lastlevel[level-2] + datas[lastindex + level]);<br>\t}<br>\treturn levelminroutes.Min();<br>}","like_count":0},{"had_liked":false,"id":352958,"user_name":"陈斌","can_delete":false,"product_type":"c1","uid":1149402,"ip_address":"陕西","ucode":"AD6933D125C930","user_header":"https://static001.geekbang.org/account/avatar/00/11/89/da/136cdca6.jpg","comment_is_top":false,"comment_ctime":1659054990,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659054990","product_id":100017301,"comment_content":"还是被老师套路了，杨辉三角就是为了引出下一节的理论。一开始还以为不用数组列出可能值，就不是动态规划。最后发现杨辉三角的推导过程符合动态规划三个特征。","like_count":0},{"had_liked":false,"id":352956,"user_name":"陈斌","can_delete":false,"product_type":"c1","uid":1149402,"ip_address":"陕西","ucode":"AD6933D125C930","user_header":"https://static001.geekbang.org/account/avatar/00/11/89/da/136cdca6.jpg","comment_is_top":false,"comment_ctime":1659054467,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659054467","product_id":100017301,"comment_content":"不用动态规划也可以，每个父节点有两个子节点，其最短路径肯定经过其合值最小的子节点。所以从叶子节点往上遍历，那个叶子节点跟父节点的和更小，用和替换父节点，逐层往上就可以找到结果他。","like_count":0},{"had_liked":false,"id":352262,"user_name":"方向感","can_delete":false,"product_type":"c1","uid":2860883,"ip_address":"","ucode":"0A59AEC0BF8293","user_header":"https://static001.geekbang.org/account/avatar/00/2b/a7/53/ff180c83.jpg","comment_is_top":false,"comment_ctime":1658487145,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658487145","product_id":100017301,"comment_content":"public int minDist(List&lt;List&lt;Integer&gt;&gt; list) {<br>        List&lt;Integer&gt; minList = list.get(list.size() - 1);<br>        int[] min = new int[minList.size()];<br>        for (int i=0;i&lt;minList.size();++i) {<br>            min[i] = minList.get(i);<br>        }<br><br>        for (int i=list.size()-2;i&gt;=0;--i) {<br>            for (int j=0;j&lt;list.get(i).size();++j) {<br>                min[j] = list.get(i).get(j) + Math.min(min[j],min[j+1]);<br>            }<br>        }<br>        return min[0];<br>    }","like_count":0},{"had_liked":false,"id":351140,"user_name":"w","can_delete":false,"product_type":"c1","uid":2706487,"ip_address":"","ucode":"CE4230DB2C4398","user_header":"https://static001.geekbang.org/account/avatar/00/29/4c/37/b6626a2d.jpg","comment_is_top":false,"comment_ctime":1657545119,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1657545119","product_id":100017301,"comment_content":"贴个go由底至顶的代码<br>func min(a int, b int) int {<br>\tif a &lt; b {<br>\t\treturn a<br>\t}<br>\treturn b<br>}<br><br>func minimumTotal(triangle [][]int) int {<br>\tn := len(triangle)<br>\tlist := make([]int, n)<br>\tcopy(list, triangle[n-1])<br>\tfor row := n - 2; row &gt;= 0; row-- {<br>\t\tfor column := 0; column &lt;= row; column++ {<br>\t\t\tlist[column] = min(list[column], list[column+1]) + triangle[row][column]<br>\t\t}<br>\t}<br>\treturn list[0]<br>}","like_count":0},{"had_liked":false,"id":350925,"user_name":"方向感","can_delete":false,"product_type":"c1","uid":2860883,"ip_address":"","ucode":"0A59AEC0BF8293","user_header":"https://static001.geekbang.org/account/avatar/00/2b/a7/53/ff180c83.jpg","comment_is_top":false,"comment_ctime":1657351050,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657351050","product_id":100017301,"comment_content":"课后题：<br>public void shortestPath(int[][] arr) {<br>        int[][] result = new int[arr.length][arr.length];<br>        for (int i=0;i&lt;arr.length;++i) {<br>            for (int j=0;j&lt;arr.length;++j) {<br>                result[i][j] = -1;<br>            }<br>        }<br>        &#47;&#47;哨兵<br>        result[0][0] = arr[0][0];<br><br>        for (int i=1;i&lt;arr.length;++i) {<br>            for (int j=0;j&lt;arr.length;++j) {<br>                int val = arr[i][j];<br>                if (j == 0) {<br>                    result[i][j] = result[i-1][j] + val;<br>                }else {<br>                    if (result[i-1][j] == -1) {<br>                        result[i][j] = result[i-1][j-1] + val;<br>                        break;<br>                    }else {<br>                        result[i][j] = Math.min(result[i-1][j-1],result[i-1][j]) + val;<br>                    }<br>                }<br>            }<br>        }<br><br>        int min = result[arr.length -1][0];<br>        for (int i = 1;i&lt;arr.length;++i) {<br>            if (result[arr.length-1][i] &lt; min) min = result[arr.length-1][i];<br>        }<br>        System.out.println(&quot;最短路径:&quot;+min);<br>    }","like_count":0},{"had_liked":false,"id":344949,"user_name":"苏成","can_delete":false,"product_type":"c1","uid":2668694,"ip_address":"","ucode":"80A8E7B243DD73","user_header":"https://static001.geekbang.org/account/avatar/00/28/b8/96/716ba431.jpg","comment_is_top":false,"comment_ctime":1651892148,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1651892148","product_id":100017301,"comment_content":"&#47; 这个是从上到下的使用dp解决杨辉三角<br>    &#47;&#47; state[i][j] = min( state[i-1][j], state[i-1][j-1]) + matrix[i][j]<br>    public int yangHuiTriangle(int[][] matrix){<br>        int n = matrix.length;<br>        int[][] state = new int[n][n];<br>        state[0][0] = matrix[0][0];<br>        for( int i = 1; i &lt; n; i++ ){<br>            for( int j = 0; j &lt;= i; j++ ) {<br>                if (j == 0)                        &#47;&#47; 初始化第一列<br>                    state[i][0] = state[i - 1][0] + matrix[i][0];<br>                else if (j == i)<br>                    state[i][j] = state[i-1][j-1] + matrix[i][j];<br>                else<br>                    state[i][j] = matrix[i][j] + Math.min(state[i-1][j-1], state[i-1][j]);<br>            }<br>        }<br>        int min = Integer.MAX_VALUE;<br>        for( int i = 0; i &lt; n; i++){<br>            if( state[n-1][i] &lt; min )<br>                min = state[n-1][i];<br>        }<br>        return min;<br>    }<br>","like_count":0},{"had_liked":false,"id":338597,"user_name":"W了个C","can_delete":false,"product_type":"c1","uid":1282410,"ip_address":"","ucode":"4E2348D1B94B47","user_header":"https://static001.geekbang.org/account/avatar/00/13/91/6a/70438732.jpg","comment_is_top":false,"comment_ctime":1647589285,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647589285","product_id":100017301,"comment_content":"一会items 一会weight......<br>变量名能统一吗?","like_count":0},{"had_liked":false,"id":338443,"user_name":"Today","can_delete":false,"product_type":"c1","uid":1235000,"ip_address":"","ucode":"4FA397F0BD8C6E","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/38/41027bda.jpg","comment_is_top":false,"comment_ctime":1647505218,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647505218","product_id":100017301,"comment_content":"本节学习到了动态规划可以用来解决一些典型背包类问题：<br>1. 动规代码是在回溯复杂度过高上进行的优化<br>2. 利用数组等容器枚举所有的可达状态，比如 dp[i][j] = x; i 可以表示次数状态，j可以表示选择的每件“物品”状态，x 可以表示通过 i 和 j 得到的状态值，这样重复的状态会合并在一起<br>3. 状态转移公式是写递归的重要一环（在评论区学习到），一般就首次状态先填入，之后的状态寻找一些规律。<br>思考题做了回溯 和 动态规划的两种，数据量大动态规划的优势还是挺大的，写的磕磕绊绊，继续下一章学习","like_count":0},{"had_liked":false,"id":336797,"user_name":"Geek_36bc16","can_delete":false,"product_type":"c1","uid":2934025,"ip_address":"","ucode":"371FA1B2C29DF3","user_header":"","comment_is_top":false,"comment_ctime":1646375061,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646375061","product_id":100017301,"comment_content":"笑死我了 笔记比讲课的讲的都好","like_count":0},{"had_liked":false,"id":335127,"user_name":"快乐少年郎","can_delete":false,"product_type":"c1","uid":1488186,"ip_address":"","ucode":"A6DF373FEB50F7","user_header":"https://static001.geekbang.org/account/avatar/00/16/b5/3a/9f2e0d8e.jpg","comment_is_top":false,"comment_ctime":1645348982,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645348982","product_id":100017301,"comment_content":"输出最短路径值和最短路径的节点，更有利于理解。比如自顶向下输出到达该点的最短路径和的杨辉三角：<br>(5) <br>(12) 13 <br>(14) 15 17       <br>(18) 23 21 18    <br>(20) 25 30 22 23 <br>那么第4层中可以得出最短路径为20.<br>以下用C#实现：<br>int[,] matrix = new int[5,5]{{5,0,0,0,0},{7,8,0,0,0},{2,3,4,0,0},{4,9,6,1,0},{2,7,9,4,5}};<br>public void yanghuiTriangle()<br>    {<br>        int n = 5;<br>        int[,] state = new int[n,n];<br>        state[0,0] = matrix[0,0];<br>        for (int i=1;i&lt;n;i++)<br>        {<br>            int jLen = i+1;<br>            for (int j=0;j&lt;jLen;j++)<br>            {<br>                if (j==0) {state[i,j] = state[i-1,j]+matrix[i,j];  }<br>else if(j==jLen-1) {state[i,j] = state[i-1,j-1]+matrix[i,j];} <br>else {<br>                    state[i,j] = Math.Min(state[i-1,j-1], state[i-1,j])+matrix[i,j];<br>                }<br>            }<br>        }<br>        int minDistance = state[n-1,0];<br>        int k = 0;<br>        for (int i=1;i&lt;n;i++)<br>        {<br>            if (minDistance&gt;state[n-1,i])<br>            {<br>                minDistance = state[n-1,i];<br>                k = i;<br>            }<br>        }<br>        int count = minDistance;<br>        int[] step = new int[n];<br>        step[n-1] = k;<br>        for (int i=n-1;i&gt;0;i--)<br>        {<br>            int kLen = i+1;<br>            if (k == 0) {<br>                k = 0;<br>            } else if (k==kLen) {<br>                k = kLen-1;<br>            } else {<br>                count = state[i,k]-matrix[i,k];<br>                if (state[i-1,k-1] == count)  k = k-1;<br>            }<br>            step[i-1] = k;<br>        }<br>        for (int i=0;i&lt;n;i++)<br>        {<br>            int jLen = i+1;<br>            for (int j=0;j&lt;jLen;j++)<br>            {<br>                if (j==step[i])<br>                {<br>                    Console.Write(&quot;(&quot;+state[i,j]+&quot;)&quot;+&quot; &quot;);<br>                } else<br>                {<br>                    Console.Write(state[i,j]+&quot; &quot;);<br>                }<br>                if (j==jLen-1) { Console.Write(&quot;\\n&quot;);}<br>            }<br>        }<br>        Console.WriteLine(&quot;minDistance:&quot;+minDistance);<br>    }","like_count":0},{"had_liked":false,"id":332939,"user_name":"Geek_72a577","can_delete":false,"product_type":"c1","uid":2079111,"ip_address":"","ucode":"B3E8C57D24DE52","user_header":"","comment_is_top":false,"comment_ctime":1643857153,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643857153","product_id":100017301,"comment_content":"0&#47;1背包问题的重复子问题，同样是f(3,3)，对于第四个选择的物品, 如果当前价值不同，总价值也不同。这种情况是重复子问题吗？","like_count":0},{"had_liked":false,"id":331222,"user_name":"Hunter_Dark","can_delete":false,"product_type":"c1","uid":1342279,"ip_address":"","ucode":"3A07CCBC250B69","user_header":"https://static001.geekbang.org/account/avatar/00/14/7b/47/96dad3ff.jpg","comment_is_top":false,"comment_ctime":1642490475,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1642490475","product_id":100017301,"comment_content":"这个女朋友购物车问题，是不是有隐含的限制条件：每个价格商品限购一件？@王争","like_count":0},{"had_liked":false,"id":324343,"user_name":"诗言","can_delete":false,"product_type":"c1","uid":2220790,"ip_address":"","ucode":"5F65C74EF9F837","user_header":"https://static001.geekbang.org/account/avatar/00/21/e2/f6/04584a17.jpg","comment_is_top":false,"comment_ctime":1638376895,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1638376895","product_id":100017301,"comment_content":"有人吗 回溯算法 是不是漏了一行 在选择装第i个物品时 就得记录状态吧<br>public void f(int i, int cw, int cv) { &#47;&#47; 调用f(0, 0, 0) if (cw == w || i == n) { &#47;&#47; cw==w表示装满了，i==n表示物品都考察完了 if (cv &gt; maxV) maxV = cv; return; } f(i+1, cw, cv); &#47;&#47; 选择不装第i个物品 if (cw + weight[i] &lt;= w) { 这个地方需要补上 mem[i][cw+weight[i] = True; f(i+1,cw+weight[i], cv+value[i]); &#47;&#47; 选择装第i个物品 }}","like_count":0},{"had_liked":false,"id":316123,"user_name":"Miki","can_delete":false,"product_type":"c1","uid":1712219,"ip_address":"","ucode":"09C0E4E0641CDF","user_header":"https://static001.geekbang.org/account/avatar/00/1a/20/5b/05516921.jpg","comment_is_top":false,"comment_ctime":1634171347,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634171347","product_id":100017301,"comment_content":"背包问题用递归的方式做是否更简单呢，不用填写所有table的状态<br>public class PackageDemo {<br>    boolean[] table;<br>    int maxWeight;<br>    public void knapsack(int[] items, int maxWeight) {<br>        this.maxWeight = maxWeight;<br>        table = new boolean[maxWeight+1];<br>        table[0] = true;<br>        if(items[0] &lt;= maxWeight){<br>            table[items[0]] = true;<br>            helper(0,items[0],items,maxWeight);<br>        }<br>        helper(0,0,items,maxWeight);<br>        for (int i = maxWeight; i &gt;= 0; i--) {<br>            if(table[i]){<br>                System.out.println(&quot;maxWeight=&quot;+i);<br>                break;<br>            }<br>        }<br>    }<br><br>    private void helper(int item, int curWeight, int[] items, int maxWeight) {<br>        if(item == items.length-1 || curWeight == maxWeight){<br>            return;<br>        }<br>        helper(item+1,curWeight,items,maxWeight);<br>        int next = curWeight+items[item+1];<br>        if(next &lt;= maxWeight){<br>            table[next] = true;<br>            helper(item+1,next,items,maxWeight);<br>        }<br>    }<br><br>    public static void main(String[] args) {<br>        PackageDemo packageDemo = new PackageDemo();<br>        packageDemo.knapsack(new int[]{3,3,9},10);<br>    }<br>}","like_count":0},{"had_liked":false,"id":307418,"user_name":"光影","can_delete":false,"product_type":"c1","uid":2316356,"ip_address":"","ucode":"BC45F2082AA7E5","user_header":"https://static001.geekbang.org/account/avatar/00/23/58/44/5f918b86.jpg","comment_is_top":false,"comment_ctime":1629092055,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629092055","product_id":100017301,"comment_content":"课后题杨辉三角 实际上是最短路径的变种，区别是杨辉三角仅左下三角有值<br><br>手机不好编辑，小伙伴可以出来格式化<br>public static void main(String[] args) {        int[][] items = new int[][]{{1},{2,3},{4,5,6},{7,8,9,10}};        minDist(items);    }    public static void minDist(int[][] items) {        &#47;&#47;矩阵最后一行的元素个数        int lastRow = items[items.length - 1].length;        &#47;&#47; 记录下杨晖三角的状态,只使用左下半边的三角        int[][] status = new int[lastRow][lastRow];        &#47;&#47;矩阵的行数-1        int row = items.length;        &#47;&#47;处理第一行，和第一列的数据        int sum = 0;        for (int i = 0; i &lt; row; i++) {            sum += items[i][0];            status[i][0] = sum;        }        &#47;&#47;从第二行开始处理        for (int i = 1; i &lt; row; i++) {&#47;&#47;第几行            for (int","like_count":0},{"had_liked":false,"id":301527,"user_name":"🤪HappyJoo","can_delete":false,"product_type":"c1","uid":1234591,"ip_address":"","ucode":"96E1858F06BABA","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/9f/0213e8a0.jpg","comment_is_top":false,"comment_ctime":1625728636,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1625728636","product_id":100017301,"comment_content":"w,cw,n,这些简写真的会死人的","like_count":0,"discussions":[{"author":{"id":1028673,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b2/41/d9dcc7ef.jpg","nickname":"希夷","note":"","ucode":"2E3E86AC7A19EC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544244,"discussion_content":"w = weight,cw = currentWeight,n = num","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641447937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":298072,"user_name":"海崖","can_delete":false,"product_type":"c1","uid":2552745,"ip_address":"","ucode":"9D42E0B0D30A56","user_header":"https://static001.geekbang.org/account/avatar/00/26/f3/a9/bb9d8450.jpg","comment_is_top":false,"comment_ctime":1623900745,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623900745","product_id":100017301,"comment_content":"叮~打卡","like_count":0},{"had_liked":false,"id":293971,"user_name":"行走的","can_delete":false,"product_type":"c1","uid":1108788,"ip_address":"","ucode":"04772A8A1FF2B4","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/34/cd310e69.jpg","comment_is_top":false,"comment_ctime":1621660887,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621660887","product_id":100017301,"comment_content":"再次复习，终于看明白了一些。<br>杨辉三角解答：<br>#include &lt;stdio.h&gt;<br><br>int states[5][5] = {0};<br><br>int main()<br>{<br>    int n = 5;<br>    int items[5][5]= {{5}, {7, 8}, {2, 3, 4}, {4, 9, 6, 1}, {2, 7, 9, 4, 5}};<br>    int minV = 65535;<br><br>    states[0][0] = 5;<br>    for(int row = 1; row &lt; 5; row++)<br>    {<br>        for(int column = 0; column &lt; 5; column++)<br>        {<br>            if(states[row-1][column])<br>            {<br>                states[row][column] = states[row-1][column] + items[row][column];<br>            }<br>            if(column+1 &lt; n)<br>            {<br>                if(states[row-1][column])<br>                {<br>                    states[row][column+1] = states[row-1][column] + items[row][column+1];<br>                }<br>            }<br>        }<br>    }<br><br>    for(int col = 0; col &lt; 5; col++)<br>    {<br>        if(minV &gt; states[n-1][col])<br>        {<br>            minV = states[n-1][col];<br>        }<br>    }<br>    printf(&quot;minV: %d\\n&quot;, minV);<br>    return 0;<br>}","like_count":0},{"had_liked":false,"id":292950,"user_name":"徐改","can_delete":false,"product_type":"c1","uid":1298380,"ip_address":"","ucode":"82276A584AC602","user_header":"https://static001.geekbang.org/account/avatar/00/13/cf/cc/8de5007b.jpg","comment_is_top":false,"comment_ctime":1621091261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621091261","product_id":100017301,"comment_content":"关于杨辉三角问题，我用Go写出了回溯版的解法，这种解法有个缺点，会出现不必要的计算，因为对于同一层的节点，如果之前经过这一层的时候所走过的路径的权值比此次经过这一次所走过的路径的权值还要小，那么其实就可以跳过当前节点，往下一个节点去尝试，以下是算法：<br>type Node struct {<br>\tval int<br>\tleft *Node<br>\tright *Node<br>}<br>var minV = -1<br>&#47;*<br>i 表示当前位于第几层<br>h 表示一共有多少层<br>cv 表示目前走过的路径的权值<br>node 表示准备要走的节点<br>*&#47;<br>func shortestRoute(i, h, cv int, node *Node) {<br>\tcv += node.val<br>\tif node.left != nil {<br>\t\tshortestRoute(i + 1, h, cv, node.left)<br>\t}<br>\tif node.right != nil {<br>\t\tshortestRoute(i + 1, h, cv, node.right)<br>\t}<br>\tif i == h {<br>\t\tif minV == -1 {<br>\t\t\tminV = cv<br>\t\t} else if minV &gt; cv {<br>\t\t\tminV = cv<br>\t\t}<br>\t}<br>}<br>调用的时候这样调用：\t<br>node_5_1 := Node{8, nil, nil}<br>node_5_2 := Node{7, nil, nil}<br>node_5_3 := Node{9, nil, nil}<br>node_5_4 := Node{4, nil, nil}<br>node_5_5 := Node{5, nil, nil}<br>node_4_1 := Node{4, &amp;node_5_1, &amp;node_5_2}<br>node_4_2 := Node{9, &amp;node_5_2, &amp;node_5_3}<br>node_4_3 := Node{6, &amp;node_5_3, &amp;node_5_4}<br>node_4_4 := Node{1, &amp;node_5_4, &amp;node_5_5}<br>node_3_1 := Node{2, &amp;node_4_1, &amp;node_4_2}<br>node_3_2 := Node{3, &amp;node_4_2, &amp;node_4_3}<br>node_3_3 := Node{4, &amp;node_4_3, &amp;node_4_4}<br>node_2_1 := Node{7, &amp;node_3_1, &amp;node_3_2}<br>node_2_2 := Node{8, &amp;node_3_2, &amp;node_3_3}<br>node_1_1 := Node{5, &amp;node_2_1, &amp;node_2_2}<br>shortestRoute(1, 5, 0, &amp;node_1_1)","like_count":0},{"had_liked":false,"id":292103,"user_name":"何柄融","can_delete":false,"product_type":"c1","uid":1398884,"ip_address":"","ucode":"A4C165D1EE3726","user_header":"https://static001.geekbang.org/account/avatar/00/15/58/64/b715d45a.jpg","comment_is_top":false,"comment_ctime":1620693258,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620693258","product_id":100017301,"comment_content":"备忘录算法这里<br>  if (mem[i][cw]) return; &#47;&#47; 重复状态  <br>mem[i][cw] = true; &#47;&#47; 记录(i, cw)这个状态  <br>f(i+1, cw); &#47;&#47; 选择不装第i个物品<br>我觉得这里的顺序有问题，下标也有问题，这里准备是要计算i+1的，为啥要去判断i的啊。<br>其次，我觉得应该是先判断是否有i+1的，然后计算i+1的，接着再存储i+1的，<br>这样才符合这种判断--计算--处理 的备忘录算法的逻辑啊。  不知道我哪里搞错了，求各位大佬指教！","like_count":0},{"had_liked":false,"id":289042,"user_name":"致良知","can_delete":false,"product_type":"c1","uid":2113915,"ip_address":"","ucode":"73C722E31B726A","user_header":"https://static001.geekbang.org/account/avatar/00/20/41/7b/cda2e622.jpg","comment_is_top":false,"comment_ctime":1618826670,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618826670","product_id":100017301,"comment_content":"为什大家总是喜欢 java写实现","like_count":0},{"had_liked":false,"id":286780,"user_name":"你好，阳光","can_delete":false,"product_type":"c1","uid":2145095,"ip_address":"","ucode":"1A2F487C57F7D9","user_header":"https://static001.geekbang.org/account/avatar/00/20/bb/47/b60ae3eb.jpg","comment_is_top":false,"comment_ctime":1617592077,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617592077","product_id":100017301,"comment_content":"&#47;&#47; 输入数据<br>let input = [[5], [7,8], [2,3,4], [4,9,6,1], [2,7,9,4,5]]<br>let minSum = Infinity<br>&#47;&#47; 解1：回溯（递归）<br>&#47;*<br>@param: i——层数索引<br>@param: j——层内索引<br>@param: cumSum——累积和<br>*&#47;<br>function shortestPathRecur(i, j, cumSum) {<br>  if(i === input.length) {<br>    if(cumSum &lt; minSum)<br>      minSum = cumSum<br>      return <br>  }<br>  shortestPathRecur(i+1, j, cumSum+input[i][j])<br>  shortestPathRecur(i+1, j+1, cumSum+input[i][j])<br>}<br>shortestPathRecur(0, 0, 0)<br>console.log(minSum)<br>&#47;&#47; 解2：动态规划填表法，设状态state[i][j]表示第i步之后第j个状态的最短路径长，则state[i][j] = min(state[i-1][j], state[i-1][j+1]) + input[i][j]<br>function shortestPathDP() {<br>  let m = input.length<br>  let state = new Array(m).fill(null)<br>  for(let i=0; i&lt;m; ++i) {<br>    state[i] = new Array(input[i].length).fill(Infinity)<br>  }<br>  &#47;&#47; 初始化状态<br>  state[0][0] = input[0][0]<br>  for(let i=1; i&lt;m; ++i) {<br>    for(let j=0; j&lt;input[i].length; ++j) {<br>      if(j === 0)<br>        state[i][j] = state[i-1][j] + input[i][j]<br>      else if(j === input[i].length-1) <br>        state[i][j] = state[i-1][j-1] + input[i][j] <br>      else<br>        state[i][j] = Math.min(state[i-1][j-1], state[i-1][j]) + input[i][j]<br>    }<br>  } <br>  &#47;&#47; 找出最短路径<br>  for(let j=0; j&lt;input[m-1].length; ++j) {<br>    if(state[m-1][j] &lt; minSum)<br>      minSum = state[m-1][j]<br>  } <br>  return minSum<br>}","like_count":0},{"had_liked":false,"id":284012,"user_name":"Geek_37e443","can_delete":false,"product_type":"c1","uid":1749669,"ip_address":"","ucode":"C9587FEE5DCDFB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ocO2yEY7sAxJnyAXONj2gxRhgPn1MDWvwvAysVruqicM9b8prkUiaT3ATcibuI1Z5OrFvicKM4icbZWdlqz2ViasLRrw/132","comment_is_top":false,"comment_ctime":1616037217,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616037217","product_id":100017301,"comment_content":"有个问题，我知道背包能装的最大价值是多少，我怎么知道装法是怎样的呢。动态规划算法怎么解决这个呢","like_count":0},{"had_liked":false,"id":282827,"user_name":"KangShan","can_delete":false,"product_type":"c1","uid":1082000,"ip_address":"","ucode":"07497A7AC92238","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/90/e4a08b0e.jpg","comment_is_top":false,"comment_ctime":1615429996,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615429996","product_id":100017301,"comment_content":"课后,直接将三角转成二叉树,每一层直接用数组存放,每层节点数量=2的深度次方,每个节点值=上一层结果+三角结构当前节点数.构建完成后,遍历最后一层节点值找到最小值,再根据此节点下标按层推导父节点下标,父节点下标=当前下标&#47;2.","like_count":0},{"had_liked":false,"id":282156,"user_name":"曲终人散","can_delete":false,"product_type":"c1","uid":1656661,"ip_address":"","ucode":"C13FBB0565F13E","user_header":"https://static001.geekbang.org/account/avatar/00/19/47/55/d87881a9.jpg","comment_is_top":false,"comment_ctime":1615109578,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1615109578","product_id":100017301,"comment_content":"动态规划和贪心都只能求出一个解，怎样才能求出所有的解呀。","like_count":0,"discussions":[{"author":{"id":1238166,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/96/a5d775e9.jpg","nickname":"牧凉","note":"","ucode":"1F57A16E37C668","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384861,"discussion_content":"回溯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626775305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281070,"user_name":"罗耀龙@坐忘","can_delete":false,"product_type":"c1","uid":1917663,"ip_address":"","ucode":"3CEA258DE7F3C7","user_header":"https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg","comment_is_top":false,"comment_ctime":1614572730,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1614572730","product_id":100017301,"comment_content":"茶艺师学编程<br><br>思考题<br>int* getRow(int rowIdx, int* retS){<br>  *retS = rowIdx+1;<br>  int nR = rowIdx + 1, idx = 0, **ret = (int**)malloc(sizeof(int*)* 2); <br>  for(int i = 0; i&lt;2; i++)<br>  {<br>    ret[i] = (int*)malloc(sizeof(int)* nR);<br>    memset(ret[i], 0, sizeof(int)*nR);   <br>  }<br><br>  for(int i = 0; i&lt;nR; i++, idx^=1)<br>    for(int j=0; j&lt;i+1; j++)<br>      if(j == 0 || j == i)  ret[idx][j] = 1;<br>      else                  ret[idx][j] = ret[idx^1][j-1] + ret[idx^1][j];<br>  return ret[idx^1];<br>}<br>","like_count":0},{"had_liked":false,"id":280736,"user_name":"lipsum","can_delete":false,"product_type":"c1","uid":1231831,"ip_address":"","ucode":"2353F027E06D3B","user_header":"https://static001.geekbang.org/account/avatar/00/12/cb/d7/5efb6c6c.jpg","comment_is_top":false,"comment_ctime":1614331294,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614331294","product_id":100017301,"comment_content":"&#47;&#47; go语言写法，把首尾节点取出来单独算，可以减少中间判断<br><br>package main<br><br>import (<br>\t&quot;fmt&quot;<br>\t&quot;math&quot;<br>)<br><br>var commodity = [][]int{<br>\t[]int{5},<br>\t[]int{7, 8},<br>\t[]int{2, 3, 4},<br>\t[]int{4, 9, 6, 1},<br>\t[]int{2, 7, 9, 4, 5},<br>}<br><br>func main() {<br>\tfor i := 1; i &lt; len(commodity); i++ {<br>\t\t&#47;&#47; left node<br>\t\tcommodity[i][0] += commodity[i-1][0]<br>\t\t&#47;&#47; middle node<br>\t\tfor j := 1; j &lt; len(commodity[i])-1; j++ {<br>\t\t\tleft := commodity[i][j] + commodity[i-1][j-1]<br>\t\t\tright := commodity[i][j] + commodity[i-1][j]<br>\t\t\tif left &gt; right {<br>\t\t\t\tcommodity[i][j] = right<br>\t\t\t} else {<br>\t\t\t\tcommodity[i][j] = left<br>\t\t\t}<br>\t\t}<br>\t\t&#47;&#47; right node<br>\t\tcommodity[i][len(commodity[i])-1] += commodity[i-1][len(commodity[i-1])-1]<br>\t}<br><br>\tmin := math.MaxInt64<br>\tl := len(commodity) - 1<br>\tfor i := 0; i &lt; len(commodity[l]); i++ {<br>\t\tif min &gt; commodity[l][i] {<br>\t\t\tmin = commodity[l][i]<br>\t\t}<br>\t}<br>\tfmt.Println(min)<br>}<br>","like_count":0},{"had_liked":false,"id":278835,"user_name":"xxx","can_delete":false,"product_type":"c1","uid":1356978,"ip_address":"","ucode":"E78B1F15BC10F7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIcLjatV3GHdibZXCTIgL1X2A7jpByIeLH3Zyia8KXdT4JRcicmVSgq5ekRHCFCFenMqicsAwaWYibHkTw/132","comment_is_top":false,"comment_ctime":1613377150,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613377150","product_id":100017301,"comment_content":"结合贪心算法和回溯算法，更好的理解了动态规划的特点。我们使用空间存储状态，赋予初始条件，找到动态规划方程，求出最优解。0-1背包问题中使用一维数组代码中从大到小遍历的原因是，如果从小到大遍历，比如放置第一个物品时（重量为2），当j=0时，states[j]为true时，我们会把states[2]置为true，继续遍历到j=2时，这时states[2]为true了，也就是本轮遍历的赋值影响到自己了。","like_count":0},{"had_liked":false,"id":278546,"user_name":"Allan","can_delete":false,"product_type":"c1","uid":1310388,"ip_address":"","ucode":"8DA4DBECC2C45C","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","comment_is_top":false,"comment_ctime":1613038348,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613038348","product_id":100017301,"comment_content":"动态规划：解决最优方案，最大值，最小值问题。就是递归问题，通过记录重复问题，回溯找到最后的最佳值。","like_count":0},{"had_liked":false,"id":274864,"user_name":"石小","can_delete":false,"product_type":"c1","uid":1781893,"ip_address":"","ucode":"4258C686F289A6","user_header":"https://static001.geekbang.org/account/avatar/00/1b/30/85/14c2f16c.jpg","comment_is_top":false,"comment_ctime":1611199202,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611199202","product_id":100017301,"comment_content":"老师讲的这种方法不容易理解，可以定义f(i,w)为当前的容量为w放完第i个后可能打到的最大重量，那么状态转移方程就是:情况一，当w大于i的重量:f(i,w)=max{f(i-1,w),f(i-1,w-i的重量)+i的重量}，情况二，当w小于i的重量：f(i,w)=f(i-1,w)，这种情况对应i放不进去。定义边界为对于任意的i,j满足f（i,0）=f(0,j)=0","like_count":0},{"had_liked":false,"id":271487,"user_name":"二狗子","can_delete":false,"product_type":"c1","uid":1546629,"ip_address":"","ucode":"0D6C5854D2B437","user_header":"https://static001.geekbang.org/account/avatar/00/17/99/85/4a139a96.jpg","comment_is_top":false,"comment_ctime":1609663760,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609663760","product_id":100017301,"comment_content":"每一层都决策走左还是走右，二维数组 state 记录累计长度，合并相同状态的的节点。最后从0开始循环找最短路径。","like_count":0},{"had_liked":false,"id":270311,"user_name":"simple_孙","can_delete":false,"product_type":"c1","uid":1873629,"ip_address":"","ucode":"A77203E242D652","user_header":"https://static001.geekbang.org/account/avatar/00/1c/96/dd/1620a744.jpg","comment_is_top":false,"comment_ctime":1609060124,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609060124","product_id":100017301,"comment_content":"现在活动一般都是每满多少减多少<br>实际操作一般是先看看必买的有多少钱，然后再往上凑一个最接近的满减倍数<br>如果是没啥必买的又想买买买，可以用文中的方法，不过文中的3倍可以定义成一个变量，方便调整","like_count":0},{"had_liked":false,"id":268353,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1608167095,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608167095","product_id":100017301,"comment_content":"&#47;**  敲一遍课后题，脑子清晰多了。<br>     * 递归树<br>     *                                                      f(0,0,5)<br>     *<br>     *<br>     *                          f(1,0,12)                                           f(1,1,14)<br>     *<br>     *          f(2,0,14)                   f(2,1,15)                   f(2,1,17)                    f(2,2,18)<br>     *<br>     * f(3,0,18)     f(3,1,23)      f(3,1,24)     f(3,2,21)     f(3,2,26)     f(3,3,23)      f(3,3,24)     f(3,4,19)<br>     *<br>     * 可以看到有很多f(i,j)相同的的节点，这些节点我们只需要保留较小的分支即可。<br>     *<br>     * 所以我们可以据此画出状态树<br>     * i&#47;j│ 0   1   2   3   4<br>     * ————————————————————————————<br>     *  0 │ 5<br>     *  1 │ 12  14<br>     *  2 │ 14      18<br>     *  3 │ 18          19<br>     *  4 │ 26              20<br>     *<br>     *  上面首先画出一直选左节点或者右节点的状态。<br>     *  空余部分的状态，我们可知，每个节点(i,j) 是从节点(i-1,j-1) 或者(i-1,j)推导而来。我们只需要选择<br>     *  Min((i-1,j-1),(i-1,j)) 较小的一个值加上当前节点的值就是该节点的状态。据此补全状态表：<br>     * i&#47;j│ 0   1   2   3   4<br>     *  ————————————————————————————<br>     *  0 │ 5<br>     *  1 │ 12  14<br>     *  2 │ 14  15  18<br>     *  3 │ 18  23  21  19<br>     *  4 │ 26  25  23  20  20<br>     *<br>     *  最后只需要在最后一行找到最小值。<br>     * @param n<br>     * @param matrix<br>     * int[][] matrix = new int[][]{{5},{7,9},{2,3,4},{4,9,6,1},{8,7,2,1,1}};<br>     * @return<br>     *&#47;<br>    public static int dyYanHui(int n,int[][]matrix){<br>        int[][]stats = new int[n][n];<br>        int sum = 0;<br>        &#47;&#47;1.先处理一直选左节点的情况<br>        for(int i = 0;i&lt;n;++i){<br>            sum += matrix[i][0];<br>            stats[i][0] = sum;<br>        }<br>        sum = 5;<br>        &#47;&#47;2.先处理一直选右节点的情况<br>        for(int i = 1;i&lt;n;++i){<br>            sum += matrix[i][i];<br>            stats[i][i] = sum;<br>        }<br>        &#47;&#47;3.剩余状态推导<br>        for(int i=2;i&lt;n;++i){<br>            for(int j=1;j&lt;i;++j){<br>                stats[i][j] = matrix[i][j]+Math.min(stats[i-1][j-1],stats[i-1][j]);<br>            }<br>        }<br>        &#47;&#47;4.选出最小值<br>        int min = Integer.MAX_VALUE;<br>        for(int i=0;i&lt;n;++i){<br>            if(stats[n-1][i]&lt;min)min = stats[n-1][i];<br>        }<br>        return min;<br>    }","like_count":0},{"had_liked":false,"id":263026,"user_name":"guihehans","can_delete":false,"product_type":"c1","uid":2111472,"ip_address":"","ucode":"836B4C7390E7F5","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKnF0VhzEIvZNWDTiaewBa7IjQOlicgq1uOeLlwBLGtibf4mPPFjSTPmNeHqpiaNQm6fhQialJVOLfDRfw/132","comment_is_top":false,"comment_ctime":1605951560,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605951560","product_id":100017301,"comment_content":"老师购物车满减的输出物品段，我的理解是其实这只是解空间的item[n-1]选中一种解吧，实际上每个物品（pick&#47;not pick)<br>会有2^n 方种方案，具体不会这么多但潜在的组合会要检查这么多才是全部解吧","like_count":0},{"had_liked":false,"id":259944,"user_name":"拉布拉多","can_delete":false,"product_type":"c1","uid":1204353,"ip_address":"","ucode":"637A88D9F29F57","user_header":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","comment_is_top":false,"comment_ctime":1604893527,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604893527","product_id":100017301,"comment_content":"代码中 i==n &#47;&#47;代表考察完了所有商品。因i从0开始，应该是i==n-1吧？","like_count":0},{"had_liked":false,"id":259635,"user_name":"拉布拉多","can_delete":false,"product_type":"c1","uid":1204353,"ip_address":"","ucode":"637A88D9F29F57","user_header":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","comment_is_top":false,"comment_ctime":1604798709,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604798709","product_id":100017301,"comment_content":"第一个题目变形一下：给出重量，求出最大重量和对应的一个商品组合选择？和所有的商品组合选择？","like_count":0},{"had_liked":false,"id":253220,"user_name":"王世林","can_delete":false,"product_type":"c1","uid":1076155,"ip_address":"","ucode":"2BB56D0FD71417","user_header":"https://static001.geekbang.org/account/avatar/00/10/6b/bb/10aaf123.jpg","comment_is_top":false,"comment_ctime":1602655152,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602655152","product_id":100017301,"comment_content":"杨辉三角问题我觉得更适合用回溯算法，根节点到到任意节点只有一条路径","like_count":0},{"had_liked":false,"id":252200,"user_name":"叶紫真","can_delete":false,"product_type":"c1","uid":1547763,"ip_address":"","ucode":"9CD7567FDB7F1F","user_header":"https://static001.geekbang.org/account/avatar/00/17/9d/f3/3f6dd32b.jpg","comment_is_top":false,"comment_ctime":1602175111,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602175111","product_id":100017301,"comment_content":"这个杨辉三角的节点位置作为状态值,当到达该节点时,如果发现该节点曾经达到过,则比较路径值,如果没有原来的小就返回,如果更加小就替换向下继续递归","like_count":0},{"had_liked":false,"id":251958,"user_name":"CHN-Lee-玉米","can_delete":false,"product_type":"c1","uid":2068721,"ip_address":"","ucode":"0A53080F38F229","user_header":"https://static001.geekbang.org/account/avatar/00/1f/90/f1/7f2b5e16.jpg","comment_is_top":false,"comment_ctime":1602000942,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602000942","product_id":100017301,"comment_content":"女朋友的购物车中有n个想买的商品（n&gt;100）哈哈哈哈哈哈哈哈","like_count":0},{"had_liked":false,"id":250053,"user_name":"^_^","can_delete":false,"product_type":"c1","uid":2021212,"ip_address":"","ucode":"301EE75D170771","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/MdmRMTV2IwvQZF2IO0G0CFWbKxT9CIibmcdicS3J4SmrA4P1e36jCwyXZpia06ItwP4GibGnCrPJHicBbd5y9libTpiaA/132","comment_is_top":false,"comment_ctime":1600916024,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600916024","product_id":100017301,"comment_content":"内容小结上的这一段是不是写反了？<br>如果 states[i-1][j]可达，就说明我们没有选择购买第 i 个商品，如果 states[i-1][j-value[i]]可达，那就说明我们选择了购买第 i 个商品。<br>如果states[i-1][j]可达则states[i-1][j-value[i]]一定可达，因为j&gt;=j-value[i]。为什么是states[i-1][j-value[i]]可达说明选择了第i个商品呢","like_count":0},{"had_liked":false,"id":249580,"user_name":"JerryZhu","can_delete":false,"product_type":"c1","uid":1591223,"ip_address":"","ucode":"76850CD45786C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","comment_is_top":false,"comment_ctime":1600697965,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600697965","product_id":100017301,"comment_content":"为啥我第一反应这个杨辉三角用贪心去写。。 每次都比较 左右 拿个小 往哪走。。 虽然可能并不一定是最优或者说满足条件的最小路径 ","like_count":0},{"had_liked":false,"id":249578,"user_name":"JerryZhu","can_delete":false,"product_type":"c1","uid":1591223,"ip_address":"","ucode":"76850CD45786C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","comment_is_top":false,"comment_ctime":1600696996,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600696996","product_id":100017301,"comment_content":"public static int knapsack4(int[] weight, int[] value, int n, int w) {<br>        int[] states = new int[w + 1];<br>        &#47;&#47; 初始化states, 默认所有价值为 -1<br>        for (int j = 0; j &lt; w + 1; ++j) {<br>            states[j] = -1;<br>        }<br>        &#47;&#47; 初始化0 数组值<br>        states[0] = 0;<br>        if (weight[0] &lt;= w) {<br>            states[weight[0]] = value[0];<br>        }<br>        &#47;&#47;动态规划，状态转移<br>        for (int i = 1; i &lt; n; ++i) {<br>            for (int j = w - weight[i]; j &gt;= 0; --j) { &#47;&#47; 选择第i个物品<br>                if (states[j] &gt;= 0) {<br>                    int v = states[j] + value[i];<br>                    if (v &gt; states[j + weight[i]]) {<br>                        states[j + weight[i]] = v;<br>                    }<br>                }<br>            }<br>        }<br>        &#47;&#47; 找出最大值<br>        int maxvalue = -1;<br>        for (int j = 0; j &lt;= w; ++j) {<br>            if (states[j] &gt; maxvalue) {<br>                maxvalue = states[j];<br>            }<br>        }<br>        return maxvalue;<br>    }","like_count":0},{"had_liked":false,"id":244441,"user_name":"渊จุ๊บ","can_delete":false,"product_type":"c1","uid":1530295,"ip_address":"","ucode":"E3A2C1E89EB576","user_header":"https://static001.geekbang.org/account/avatar/00/17/59/b7/9db9c657.jpg","comment_is_top":false,"comment_ctime":1598518739,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598518739","product_id":100017301,"comment_content":"思考题（语言Golang）：<br>func yanghuiTriangleC(t [][]int, level int) {<br>\tn := (level+1)*level&#47;2<br>\t&#47;&#47; 空间复杂度O(n)<br>\tstates := make([]int, n)<br>\tstates[0] = t[0][0]<br>\tp := 0<br><br>\t&#47;&#47; 动态规划计算最短路径，时间复杂度O(n)<br>\tfor l := 1; l &lt; level; l++ {<br>\t\t&#47;&#47; 判断是否符合要求<br>\t\tif len(t[l]) &gt;= l+1 {<br>\t\t\tfor i := 0; i &lt; l+1; i++ {<br>\t\t\t\tp++<br>                left := -1<br>                right := -1<br>\t\t\t\tif i &gt; 0 {<br>\t\t\t\t\tleft = t[l][i] + states[p-l-1]<br>\t\t\t\t}<br>\t\t\t\tif i &lt; l {<br>\t\t\t\t\tright = t[l][i] + states[p-l]<br>\t\t\t\t}<br>\t\t\t\tif left &lt; 0 {<br>\t\t\t\t\tstates[p] = right<br>\t\t\t\t} else if right &lt; 0 {<br>\t\t\t\t\tstates[p] = left<br>\t\t\t\t} else {<br>\t\t\t\t\tif left &lt; right {<br>\t\t\t\t\t\tstates[p] = left<br>\t\t\t\t\t} else {<br>\t\t\t\t\t\tstates[p] = right<br>\t\t\t\t\t}<br>\t\t\t\t}<br>\t\t\t}<br>\t\t} else {<br>\t\t\tfmt.Printf(&quot;第%d层数据量少于%d个，无法计算&quot;, l+1, l+1)<br>\t\t\treturn<br>\t\t}<br>\t}<br><br>\tm := n-1<br>\tminInt := states[m]<br>\t&#47;&#47; 搜索路径最小值<br>\tfor j := 1; j &lt; level; j++ {<br>\t\ttmp := states[n-1-j]<br>\t\tif tmp &lt; minInt {<br>\t\t\tminInt = tmp<br>\t\t\tm = n-1-j<br>\t\t}<br>\t}<br><br>\troute := make([]int, level)<br>\troute[level-1] = m-n+level<br>\troute[0] = 0<br>\t&#47;&#47; 计算路径<br>\tfor r := level-1; r &gt; 1; r-- {<br>\t\tleftI := -1<br>\t\trightI := -1<br>\t\tif route[r] &gt; 0 {<br>\t\t\tleftI = m - r - 1<br>\t\t}<br>\t\tif route[r] &lt; r {<br>\t\t\trightI = m - r<br>\t\t}<br><br>\t\tif leftI &lt; 0 {<br>\t\t\tm = rightI<br>\t\t} else if rightI &lt; 0 {<br>\t\t\tm = leftI<br>\t\t} else {<br>\t\t\tif states[leftI] &lt; states[rightI] {<br>\t\t\t\tm = leftI<br>\t\t\t} else {<br>\t\t\t\tm = rightI<br>\t\t\t}<br>\t\t}<br>\t\troute[r-1] = m-(r*(r-1)&#47;2)<br>\t}<br><br>\t&#47;&#47; 打印结果，时间复杂度O(n)<br>\tprintTriangleC(t, level, route, minInt)<br>\t&#47;&#47; 总时间&#47;空间复杂度O(n≈level^2)<br>}<br><br>func printTriangleC(t [][]int, level int, route []int, minInt int) {<br>\tfor l, i := range route {<br>\t\tfor b := 0; b &lt; level-1-l; b++ {<br>\t\t\tfmt.Printf(&quot;  &quot;)<br>\t\t}<br>\t\tfor j := 0; j &lt; l+1; j++ {<br>\t\t\tif j == i {<br>\t\t\t\tfmt.Printf(&quot;*%d&quot;, t[l][j])<br>\t\t\t} else {<br>\t\t\t\tfmt.Printf(&quot; %d&quot;, t[l][j])<br>\t\t\t}<br>\t\t\tif j &lt; l {<br>\t\t\t\tfmt.Printf(&quot;  &quot;)<br>\t\t\t} else {<br>\t\t\t\tfmt.Println()<br>\t\t\t}<br>\t\t}<br>\t}<br>\tfmt.Println(&quot;最短路径为：&quot;, minInt)<br>}<br><br>func TestYanghuiTriangleC(t *testing.T) {<br>\ttri := [][]int{{5}, {7, 8}, {2, 3, 4}, {4, 2, 6, 5}, {9, 7, 9, 4, 5}, {1, 2, 3, 4, 5, 6}, {7, 6, 5, 4, 3, 2, 1}}<br>\tyanghuiTriangleC(tri, len(tri))<br>}<br>由于字数有限就不打印结果了","like_count":0},{"had_liked":false,"id":243415,"user_name":"GGL","can_delete":false,"product_type":"c1","uid":1215892,"ip_address":"","ucode":"AED10B8248D1E7","user_header":"https://static001.geekbang.org/account/avatar/00/12/8d/94/150dfe78.jpg","comment_is_top":false,"comment_ctime":1598099563,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598099563","product_id":100017301,"comment_content":"购物车购买商品倒推会存在问题，试了一个例子：购物车商品价格：[68, 64, 32, 41, 88]，优惠券价值200，按照承受价格为300求解(1.5倍)，求解得到的价格范围为：[205, 220, 225, 229, 252, 261, 293]，然后在计算229和261的时候，由于路径很相似，导致出现问题<br>可使用优惠券购买最优惠价格范围为: 205, 对应购买的商品为: [68, 64, 32, 41, 0](205)<br>可使用优惠券购买最优惠价格范围为: 220, 对应购买的商品为: [68, 0, 32, 0, 88](188)<br>可使用优惠券购买最优惠价格范围为: 225, 对应购买的商品为: [0, 64, 32, 41, 88](225)<br>可使用优惠券购买最优惠价格范围为: 229, 对应购买的商品为: [68, 0, 32, 41, 88](229)<br>可使用优惠券购买最优惠价格范围为: 252, 对应购买的商品为: [68, 64, 32, 0, 88](252)<br>可使用优惠券购买最优惠价格范围为: 261, 对应购买的商品为: [68, 0, 32, 41, 88](229)<br>可使用优惠券购买最优惠价格范围为: 293, 对应购买的商品为: [68, 64, 32, 41, 88](293)<br><br>261价格实际对应商品应为：[68, 64, 0, 41, 88]，在倒推计算第三个物品是否加入时，决策结果为是，导致出现问题。","like_count":0},{"had_liked":false,"id":243138,"user_name":"刘育飞","can_delete":false,"product_type":"c1","uid":1363642,"ip_address":"","ucode":"06600614E898CC","user_header":"https://static001.geekbang.org/account/avatar/00/14/ce/ba/f73555c7.jpg","comment_is_top":false,"comment_ctime":1597974275,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1597974275","product_id":100017301,"comment_content":"求老师帮忙解答，一个物品 n个仓库 需要不同的数量，以及有m个仓库 有不同的库存可以提供，一个仓可以给的多个仓配货，但是 一个仓的库存只能全部由一个仓里调出，求仓库最大满足数，比如最多全部仓都满足，并且求出调配方案","like_count":0},{"had_liked":false,"id":241746,"user_name":"曾益达","can_delete":false,"product_type":"c1","uid":2113150,"ip_address":"","ucode":"AC20D6F5EF01C4","user_header":"https://static001.geekbang.org/account/avatar/00/20/3e/7e/3dac54fa.jpg","comment_is_top":false,"comment_ctime":1597408478,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597408478","product_id":100017301,"comment_content":"老师求解，为啥给女朋友省钱那个题，用一位数组就解出来不对了呢？代码如下：<br>int girlLove(int items[], int n, int w) {<br>    bool states[w + 10];<br>    memset(states, false, sizeof(states));<br>    &#47;&#47; 第一行的数据要特殊处理<br>    states[0] = true;<br>    if (items[0] &lt;= 3 * w)<br>        states[items[0]] = true;<br><br>    for (int i = 1; i &lt; n; ++i) {<br>        for (int j = 0; j &lt;= w + 10 - items[i]; ++j)<br>            &#47;&#47;购买第i个商品<br>            if (states[j]){<br>                states[j+items[i]] = true;<br>                cout&lt;&lt;j+items[i]&lt;&lt;endl;<br>            }<br>    }<br>    int j;<br>    for (j = w; j &lt; w + 10; ++j) {<br>        &#47;&#47; 输出结果大于等于w的最小值<br>        if (states[j] == true)<br>            return j;<br>    }<br>    &#47;&#47; 没有可行解<br>    if (j == w + 10+1)<br>        return -1;<br>}","like_count":0},{"had_liked":false,"id":241205,"user_name":"Kermit Sun","can_delete":false,"product_type":"c1","uid":1245430,"ip_address":"","ucode":"9B0560FB228629","user_header":"https://static001.geekbang.org/account/avatar/00/13/00/f6/f6cf138c.jpg","comment_is_top":false,"comment_ctime":1597215891,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597215891","product_id":100017301,"comment_content":"杨辉三角如果从下往上推的话应该就是动态规划，每次舍弃一半，从上往下推就是穷举了","like_count":0},{"had_liked":false,"id":238072,"user_name":"大数据都来学算法了","can_delete":false,"product_type":"c1","uid":2080414,"ip_address":"","ucode":"21A350D0FE9B18","user_header":"","comment_is_top":false,"comment_ctime":1596065117,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596065117","product_id":100017301,"comment_content":"回溯版本的0-1问题，递归退出条件是否需要改成 if (cw &gt;= w || i == n )","like_count":0},{"had_liked":false,"id":238071,"user_name":"大数据都来学算法了","can_delete":false,"product_type":"c1","uid":2080414,"ip_address":"","ucode":"21A350D0FE9B18","user_header":"","comment_is_top":false,"comment_ctime":1596064892,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1596064892","product_id":100017301,"comment_content":"0-1背包问题，为啥不是cw&gt;=w , 而是cw==w，万一装了下一个大于了呢？岂不是不能退出方法","like_count":0,"discussions":[{"author":{"id":2241471,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erqHQZANVl9eaPTx4kVv0BNLGWNKa3ib4HnOrDMwicribfw5J4NW2QibpZj79pjicB2UffJnY2Tp1abmuQ/132","nickname":"LICHENSM","note":"","ucode":"4906C027C59500","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327567,"discussion_content":"你多看看吧... CW = W都装满了, 为什么还要装下一个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605863256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235377,"user_name":"狼的诱惑","can_delete":false,"product_type":"c1","uid":1257043,"ip_address":"","ucode":"AE89DFC5963C42","user_header":"https://static001.geekbang.org/account/avatar/00/13/2e/53/bf62683f.jpg","comment_is_top":false,"comment_ctime":1594988210,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594988210","product_id":100017301,"comment_content":"争哥，我来请教个真实需求问题 ，一直没有思路<br><br>商品A 50元<br>商品B 30元<br>商品C 20元<br><br>劵1 ，60元  能用商品AB<br>劵2，10元  能用商品BC<br>劵3，30元  能用商品A<br><br>如何达到最优解？？<br>商品A用  劵3抵扣30元+劵1抵扣20元。<br>商品B用 劵1抵扣30元。<br>商品C用 劵2抵扣10元。<br>一共抵扣90元","like_count":0},{"had_liked":false,"id":235336,"user_name":"感动超人","can_delete":false,"product_type":"c1","uid":1245294,"ip_address":"","ucode":"DDBFE64A9DB28D","user_header":"https://static001.geekbang.org/account/avatar/00/13/00/6e/11362a1e.jpg","comment_is_top":false,"comment_ctime":1594977927,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594977927","product_id":100017301,"comment_content":"特别强调一下代码中的第 8 行，j 需要从大到小来处理。如果我们按照 j 从小到大处理的话，会出现 for 循环重复计算的问题<br><br>不知道多少同学看到这会有疑问,翻了翻评议,没有看到有人解答这问题,写一下自己的理解<br><br>1. j-- 遍历(正确的遍历)<br><br>for (int j = w-items[i]; j &gt;= 0; --j) {&#47;&#47;把第i个物品放入背包<br>                if (states[j]==true) states[j+items[i]] = true;<br>    }<br><br> if (states[j]==true) states[j+items[i]] = true; <br> j&#39;+items[i]会指向 states[j&#39;] 后面的位置, j--接着遍历,<br>j&#39;&#39; j&#39;&#39;&#39;  不会 == j&#39;+items[i] <br><br>2. j++遍历 (错误的遍历)<br>for (int j = 0; j &lt;= w-items[i]; j++) {&#47;&#47;把第i个物品放入背包<br>                if (states[j]==true) states[j+items[i]] = true;<br>            }<br> if (states[j]==true) states[j+items[i]] = true; <br> j&#39;+items[i]会指向 states[j&#39;] 后面的位置,<br> j++接着遍历,j&#39;&#39; j&#39;&#39;&#39; ... w-weight[i] 可能 == j&#39;+items[i] <br><br>最后给个测试用例可以证明 j++ 遍历是有问题的<br>items[] = {1,31,2}<br>public static int knapsack1(int[] items, int 3, int 89) {}","like_count":0},{"had_liked":false,"id":234290,"user_name":"性林的木木","can_delete":false,"product_type":"c1","uid":2048047,"ip_address":"","ucode":"BFB36D0B8BF66E","user_header":"https://static001.geekbang.org/account/avatar/00/1f/40/2f/574f8de5.jpg","comment_is_top":false,"comment_ctime":1594633305,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594633305","product_id":100017301,"comment_content":"背包升级问题，在应用回溯算法时，可以借用备忘录，不过当后函数的value值比前函数大时，就没用了<br>public void f(int i, int cw, int cv) {<br>     if (cw == w || i == n ) {<br>            if (cw &gt; maxW) maxW = cw ;<br>            return;<br>     }<br>     if (men[i][cw] &gt; cv) return;  &#47;&#47;当前标记数组的cv值大于当前cv值时，则可返回不计算<br>     men[i][cw] = cv;<br>    f(i+1, cw, cv);<br>    if (cw + weight[i] &lt; w) {<br>          f(i+1, cw+weight[i], cv+value[i]);<br>   }<br>}<br>","like_count":0},{"had_liked":false,"id":232819,"user_name":"豪曹","can_delete":false,"product_type":"c1","uid":1106109,"ip_address":"","ucode":"93C1CE47B74899","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/bd/3abd26fd.jpg","comment_is_top":false,"comment_ctime":1594123962,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594123962","product_id":100017301,"comment_content":"回溯算法就是深度优先<br>动态规划就是广度优先","like_count":0},{"had_liked":false,"id":232816,"user_name":"豪曹","can_delete":false,"product_type":"c1","uid":1106109,"ip_address":"","ucode":"93C1CE47B74899","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/bd/3abd26fd.jpg","comment_is_top":false,"comment_ctime":1594123679,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594123679","product_id":100017301,"comment_content":"回溯算法就是深度优先<br>动态规划就是广度优先<br>感觉真的很像","like_count":0},{"had_liked":false,"id":228372,"user_name":"恶魔果实","can_delete":false,"product_type":"c1","uid":1962297,"ip_address":"","ucode":"691CD833C984AC","user_header":"https://static001.geekbang.org/account/avatar/00/1d/f1/39/b0960780.jpg","comment_is_top":false,"comment_ctime":1592650875,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592650875","product_id":100017301,"comment_content":"如果一句话概括贪心算法和动态规划的区别，会是什么？","like_count":0},{"had_liked":false,"id":225951,"user_name":"颇忒妥","can_delete":false,"product_type":"c1","uid":1026448,"ip_address":"","ucode":"AA86AD1049BC2E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a9/90/0c5ed3d9.jpg","comment_is_top":false,"comment_ctime":1591918274,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591918274","product_id":100017301,"comment_content":"最后那个反推凑单方案的思路<br>就是看当前阶段的解是否包含本商品，怎么判断？<br>如果包含，那么存在 前一阶段的解+当前商品=当前阶段的解<br>也就是 前一阶段的解=当前阶段的解-当前商品<br>那么问题就变成看前一阶段的解是否存在，如果不不在，那么就说明当前阶段的解里不包含本商品","like_count":0},{"had_liked":false,"id":225946,"user_name":"颇忒妥","can_delete":false,"product_type":"c1","uid":1026448,"ip_address":"","ucode":"AA86AD1049BC2E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a9/90/0c5ed3d9.jpg","comment_is_top":false,"comment_ctime":1591917296,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591917296","product_id":100017301,"comment_content":"和下篇的走棋盘差不多，弄一个n*n的矩阵，一根右上到左下的对角线把棋盘分成两半，把三角的值填到左半部分。<br>初始化第一行，a[0][i]+=a[0][i-1]<br>初始化第一列，a[j][0]+=a[j-1][0]<br>因为只能只能往下或者往右，所以每个格子的最短路径<br>a[i][j]=min(a[i][j-1], a[i-1][j])+a[i][j] <br>遍历完矩阵的左半部分后，遍历对角线，取得最小值","like_count":0},{"had_liked":false,"id":225519,"user_name":"Pork Face","can_delete":false,"product_type":"c1","uid":1796308,"ip_address":"","ucode":"00DD34AC117004","user_header":"https://static001.geekbang.org/account/avatar/00/1b/68/d4/33193c30.jpg","comment_is_top":false,"comment_ctime":1591775470,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591775470","product_id":100017301,"comment_content":"我：听话，双十一咱不剁手<br>女朋友：分手，再见！","like_count":0},{"had_liked":false,"id":222840,"user_name":"kaiser","can_delete":false,"product_type":"c1","uid":1390375,"ip_address":"","ucode":"F9438786E9A57B","user_header":"https://static001.geekbang.org/account/avatar/00/15/37/27/b023ada7.jpg","comment_is_top":false,"comment_ctime":1590924936,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590924936","product_id":100017301,"comment_content":"我写了杨辉三角问题的动态规划解题方法，以及生成杨辉三角树、打印杨辉三角树信息。<br>https:&#47;&#47;github.com&#47;kaisesai&#47;datastructures_algorithm&#47;blob&#47;master&#47;src&#47;main&#47;java&#47;com&#47;liukai&#47;datastructure&#47;ch_40_dynamicprogramming&#47;YangHuiSanJiao.java","like_count":0},{"had_liked":false,"id":220615,"user_name":"SkyLaker","can_delete":false,"product_type":"c1","uid":1504668,"ip_address":"","ucode":"F535B34161520A","user_header":"https://static001.geekbang.org/account/avatar/00/16/f5/9c/c6fe0ffb.jpg","comment_is_top":false,"comment_ctime":1590294669,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590294669","product_id":100017301,"comment_content":"&#47;**<br> * 利用状态表求解<br> * @param triangle “杨辉三角”对应的二维数组，一维代表每一层，二维代表每一行数字<br> * @return 最高层到最底层的最短路径<br> *&#47;<br>public static int dpStatesTable(int[][] triangle) {<br>\t&#47;&#47; 1、定义状态表<br>\t&#47;&#47; 行代表每一层<br>\t&#47;&#47; 列代表层的数字最大个数，用最底层数字个数作为列<br>\t&#47;&#47; 值代表当前数字选择后最短路径<br>\tint[][] states = new int[triangle.length][triangle.length];<br><br>\t&#47;&#47; 2、开始填表<br>\t&#47;&#47; 初始化第一层<br>\tstates[0][0] = triangle[0][0];<br><br>\t&#47;&#47; 第二层开始依赖前一层处理<br>\tfor(int c = 1; c &lt; triangle.length; c++) {<br>\t\tfor(int k = 0; k &lt; triangle[c].length; k++) {<br>\t\t\t&#47;&#47; 当前层最右边数字索引<br>\t\t\tint rightIndex = triangle[c].length - 1;<br><br>\t\t\tif(0 == k) {<br>\t\t\t\t&#47;&#47; 最左边的数字最短路径就是上一个最左数字已有路径和加上当前数字<br>\t\t\t\tstates[c][0] = states[c - 1][0] + triangle[c][0];<br>\t\t\t}<br>\t\t\telse if(k == rightIndex) {<br>\t\t\t\t&#47;&#47; 上一层最右边数字索引<br>\t\t\t\tint upRightIndex = triangle[c-1].length - 1;<br>\t\t\t\t&#47;&#47; 最右边数字最短路径就是上一个最右边数字已有路径和加上当前数字<br>\t\t\t\tstates[c][rightIndex] = states[c-1][upRightIndex] + triangle[c][rightIndex];<br>\t\t\t}<br>\t\t\telse {<br>\t\t\t\t&#47;&#47; 如果是中间数字，那么 最短路径 = 上一层相连的两个数 字中的最短一个路径 + 当前数字<br>\t\t\t\tint upLeft = states[c-1][k-1];<br>\t\t\t\tint upRight = states[c-1][k];<br>\t\t\t\tstates[c][k] = Math.min(upLeft, upRight) + triangle[c][k];<br>\t\t\t}<br>\t\t}<br>\t}<br><br>\t&#47;&#47; 3、得到最优解<br>\t&#47;&#47; 这里状态表最后一层的数据就是最底层每个数字的最短路径，<br>\t&#47;&#47; 那么对于整个三角来说，最短路径就是这些最短路径中的最小值<br>\tint bottomRow = states.length - 1;<br>\tint min = states[bottomRow][0];<br>\tfor(int i = 0; i &lt; states[bottomRow].length; i++) {<br>\t\tif(states[bottomRow][i] &lt; min) {<br>\t\t\tmin = states[bottomRow][i];<br>\t\t}<br>\t}<br>\treturn min;<br>}","like_count":0},{"had_liked":false,"id":220297,"user_name":"懒猫","can_delete":false,"product_type":"c1","uid":1206544,"ip_address":"","ucode":"B4B567A11B491D","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/10/275ae749.jpg","comment_is_top":false,"comment_ctime":1590221657,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590221657","product_id":100017301,"comment_content":"0-1背包回溯法求出拼凑w的【所有可能解】（golang实现）<br>var (<br>    res  [][]int<br>    path []int<br>)<br>func getSolution(weight []int, state [][]bool, n, i, cw int, path []int, res [][]int) [][]int {<br>\tif i == 0 &amp;&amp; cw == 0 {<br>\t\ttemp := make([]int, len(path))<br>\t\tcopy(temp, path)<br>\t\tres = append(res, path)<br>\t\treturn res<br>\t}<br><br>\tif !state[i][cw] {<br>\t\treturn res<br>\t}<br><br>\tif i &gt; 0 {<br>\t\tif state[i-1][cw] { &#47;&#47; 没有选第i件物品<br>\t\t\tres = getSolution(weight, state, n, i-1, cw, path, res)<br>\t\t}<br>\t\tif cw-weight[i] &gt;= 0 &amp;&amp; state[i-1][cw-weight[i]] { &#47;&#47; 选择了第i件物品<br>\t\t\tpath = append(path, i)<br>\t\t\tres = getSolution(weight, state, n, i-1, cw-weight[i], path, res)<br>\t\t\tpath = path[:len(path)-1]<br>\t\t}<br>\t} else if i == 0 &amp;&amp; cw &gt; 0 { &#47;&#47; state第0行例外检查下有没有可能添加weight中第0件物品<br>\t\tif cw-weight[i] &gt;= 0 &amp;&amp; state[i][cw-weight[i]] {<br>\t\t\tpath = append(path, i)<br>\t\t\tres = getSolution(weight, state, n, i, cw-weight[i], path, res)<br>\t\t\tpath = path[:len(path)-1]<br>\t\t}<br>\t}<br>\treturn res<br>}<br>&#47;&#47; 调用getSolution，maxw为动归得到最大重量值，返回数组为weight数组中物品的下标<br>res = getSolution(weight, state, len(weight), len(weight)-1, maxw, path, res)<br>fmt.Printf(&quot;solution\\n&quot;)<br>for _, sol := range res {<br>\tfmt.Printf(&quot;%v\\n&quot;, sol)<br>}<br>输出：<br>solution<br>[4 2 0]<br>[4 2 1]<br>[4 3]","like_count":0},{"had_liked":false,"id":220263,"user_name":"Geek_bc9a30","can_delete":false,"product_type":"c1","uid":1998616,"ip_address":"","ucode":"EC8E9A394760F0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJxo2MIrX4Soibpp7fTr1icAablzzlYG9cI3kh3147gmojfmJL6TL8PKWENIb0ic4N5V5KiaiceibcaKkOw/132","comment_is_top":false,"comment_ctime":1590217450,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590217450","product_id":100017301,"comment_content":"写一个伪代码，请大家和老师指正<br>def SearchMin(root):<br>    if root == None:<br>        return 0<br>    return min( SearchMin(root.left), SearchMin(root.right) ) + root.val","like_count":0},{"had_liked":false,"id":219410,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1590023971,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1590023971","product_id":100017301,"comment_content":"看了动态规划的第一篇，再看之前的回溯算法，似乎就简单了一些。特别是在文中对于背包问题的反复演示。<br><br>文中那个背包问题的状态图看起来非常清晰易懂，如果按图索骥，那么用动态规划来写似乎也就不是什么难题了。<br><br>学习了留言里面 @郭霖 老师对于课后题杨辉三角的解答，一开始还觉得为什么只考虑上一行左侧的节点 state[i-1][j-1]，而没有考虑右侧的。后来画了一下二维数组的矩阵，就明白了。<br><br>动态规划的题目很多，后面还有两节课，继续练习。","like_count":0},{"had_liked":false,"id":217624,"user_name":"默默","can_delete":false,"product_type":"c1","uid":1006635,"ip_address":"","ucode":"AF798B9D327F24","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/2b/8b771383.jpg","comment_is_top":false,"comment_ctime":1589550452,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589550452","product_id":100017301,"comment_content":"记录每个节点从根节点到自身的最短路径，下一层节点在上一层节点的最短路径上加上当前层距离。查询最后一层节点，选出最短的那个路径。","like_count":0},{"had_liked":false,"id":217585,"user_name":"isobelar","can_delete":false,"product_type":"c1","uid":1318394,"ip_address":"","ucode":"58CE4061984B43","user_header":"https://static001.geekbang.org/account/avatar/00/14/1d/fa/b81c89c3.jpg","comment_is_top":false,"comment_ctime":1589538466,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589538466","product_id":100017301,"comment_content":"knapsack3求最大值的背包问题空间复杂度进行了优化，knapsack4算法的空间复杂度现在是O(W)。<br>public static int knapsack4(int[] weight, int[] value, int n, int w) {<br>  int[] states = new int[w+1];<br>  for (int j = 0; j &lt; w+1; ++j) { &#47;&#47; 初始化states<br>      states[j] = 0;<br>  }<br>  <br>  for (int i = 0; i &lt; n; ++i) { &#47;&#47; 选择第i个物品<br>    for (int j = w; j &gt;= 0; --j) { &#47;&#47; 动态规划，状态转移<br>      if (weight[i] &lt;= j) {<br>        states[j] = max{states[j], states[j-weight[i]] + value[i]};<br>      }<br>    }<br>  }<br>  &#47;&#47; 找出最大值<br>  return states[-1];<br>}","like_count":0},{"had_liked":false,"id":217205,"user_name":"Allan","can_delete":false,"product_type":"c1","uid":1310388,"ip_address":"","ucode":"8DA4DBECC2C45C","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","comment_is_top":false,"comment_ctime":1589439862,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589439862","product_id":100017301,"comment_content":"60天攻克算法打卡行动第32天<br><br>学习内容 ：初识动态规划：如何巧妙解决“双十一”购物时的凑单问题？（一）<br><br>动态规划的基础知识非常重要，我们把它分为2个部分进行学习。今天先来学习第一部分：<br>动态规划基础和01的背包问题基础版。<br><br>1.如何学习动态规划<br>求解最优问题<br>2.0-1背包问题基础版<br>问题：选择不装第i个物品是什么意思？为什么不装？<br>把问题分解为多个阶段，每个阶段对应一个决策。我们记录每一个阶段可达的状态集合（去重复的），然后通过当前阶段的状态集合，来推导下一个阶段的集合，动态地往前推进。空间换时间的解决思路。<br><br>课后题：<br>1、把多有情况都跑一遍 对比所有的结果大小<br>需要一个状态位置，标示不能重复。也是跑完所有结果比大小","like_count":0},{"had_liked":false,"id":216027,"user_name":"聂旋","can_delete":false,"product_type":"c1","uid":1193784,"ip_address":"","ucode":"40061E5AFDA99C","user_header":"https://static001.geekbang.org/account/avatar/00/12/37/38/5a3b72d4.jpg","comment_is_top":false,"comment_ctime":1589171012,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589171012","product_id":100017301,"comment_content":"反反复复看了几遍，个人认为几个关键点。<br>1.首先分阶段，每个阶段对应什么操作。<br>2.确定二维数组，横纵坐标各代表什么，元素值表示什么状态。  （一般是题目要求的目标）<br>3. 确定限制条件和终止条件。<br>4.确定哪些部分是可以重复利用。<br>通过限制条件和重复的部分，减少计算量。<br>5.  利用回溯算法或状态转移方程方法 来实现。<br>","like_count":0},{"had_liked":false,"id":215831,"user_name":"Geek_6ab543","can_delete":false,"product_type":"c1","uid":1463375,"ip_address":"","ucode":"28B5F1C24CFDB4","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83epcv7bwuNrRfTax8PbT7MONAZVUHwenpbibQppk8YwxMUJXGQ8bICEAcTqFGzwJF93Tmntao1qCq7Q/132","comment_is_top":false,"comment_ctime":1589112820,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589112820","product_id":100017301,"comment_content":"文章里面解决的是满200减50（只有一张券）的最优媷羊毛问题。现实中双11，更多的是【每】满200减50吧。。。购物车里面 总价值可能是1000元，需要反复提交多次 最靠近200的订单。每一单和每一单之间，应该还是有点关系的。<br><br>我能想到的是，不管每一单和每一单的关系，用贪心，嵌套动态规划。<br>但如果要考虑每一单和每一单之间的影响，比如动态规划 嵌套动态规划，我感觉会复杂很多...太烧脑了...","like_count":0},{"had_liked":false,"id":215678,"user_name":"鱼丸粗面","can_delete":false,"product_type":"c1","uid":1785016,"ip_address":"","ucode":"B2F3F75B0D1422","user_header":"https://static001.geekbang.org/account/avatar/00/1b/3c/b8/9489387c.jpg","comment_is_top":false,"comment_ctime":1589076574,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589076574","product_id":100017301,"comment_content":"最后一题用递归和动态规划分别实现<br>&#47;**<br> * |          5<br> * |        7   8<br> * |      2   3   4<br> * |    4   9   6   1<br> * |  2   7   9   4   5<br> *<br> * @author colby<br> * @date 2020&#47;5&#47;10 9:03<br> *&#47;<br>public class PascalTriangle {<br><br>    &#47;**<br>     * 杨辉三角是一个满二叉树<br>     * 用数组来表示<br>     * 动态规划实现<br>     *&#47;<br>    public static int minLen(int[] dist) {<br>        &#47;&#47; 到达当前下标的最短路径<br>        int[] minArr = new int[dist.length];<br>        &#47;&#47; 第 1 层特殊处理<br>        minArr[0] = dist[0];<br>        for (int i = 1; i &lt; dist.length; i++) {<br>            &#47;&#47; lp 左父节点 rp右父节点<br>            int layer = layer(i), lp = i - layer, rp = i - layer + 1;<br>            boolean lpExist = lp &gt;= 0 &amp;&amp; layer(lp) == layer - 1;<br>            boolean rpExist = layer(rp) == layer - 1;<br>            if (lpExist &amp;&amp; rpExist) {<br>                minArr[i] = Math.min(minArr[lp], minArr[rp]) + dist[i];<br>            } else {<br>                minArr[i] = minArr[lpExist ? lp : rp] + dist[i];<br>            }<br>        }<br><br>        int min = Integer.MAX_VALUE;<br>        int maxLayer = layer(minArr.length - 1);<br>        for (int i = minArr.length - maxLayer; i &lt; minArr.length; i++) {<br>            min = Math.min(min, minArr[i]);<br>        }<br><br>        return min;<br>    }<br><br>    &#47;**<br>     * 递归实现<br>     *&#47;<br>    public static int minLenRecur(int[] dist, int i) {<br>        &#47;&#47; 左子节点下标等与 i + layer<br>        int layer = layer(i), l = i + layer, r = i + layer + 1;<br>        if (l &gt; dist.length || r &gt; dist.length) {<br>            return dist[i];<br>        }<br>        return Math.min(minLenRecur(dist, l), minLenRecur(dist, r)) + dist[i];<br>    }<br><br>    &#47;**<br>     * 下标 i 在所在层<br>     *&#47;<br>    public static int layer(int i) {<br>        &#47;&#47; total 也等于下一层的开始的下标<br>        int total = 1, layer = 1;<br>        while (total &lt;= i) {<br>            layer++;<br>            total += layer;<br>        }<br>        return layer;<br>    }<br>    public static void main(String[] args) {<br>        int[] dist = {5, 7, 8, 2, 3, 4, 4, 9, 6, 1, 2, 7, 9, 4, 5};<br>        System.out.println(minLenRecur(dist, 0));<br>        System.out.println(minLen(dist));<br>    }<br>}","like_count":0},{"had_liked":false,"id":214157,"user_name":"何磊","can_delete":false,"product_type":"c1","uid":1047604,"ip_address":"","ucode":"78934C3ED4A342","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/34/c733b116.jpg","comment_is_top":false,"comment_ctime":1588668450,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588668450","product_id":100017301,"comment_content":"不把第i个物品放入背包，其实就是i与i-1保持一致。<br><br>```<br>for j := 0; j &lt;= wP; j++ {<br>    states[i][j] = states[i-1][j]<br>}<br>```<br>这样写是不是更好理解？","like_count":0},{"had_liked":false,"id":213430,"user_name":"华仔","can_delete":false,"product_type":"c1","uid":1299543,"ip_address":"","ucode":"F794510431C343","user_header":"https://static001.geekbang.org/account/avatar/00/13/d4/57/b0a11ae5.jpg","comment_is_top":false,"comment_ctime":1588411747,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588411747","product_id":100017301,"comment_content":"老师，有个问题，给女朋友算购物车那个，如果直接算一下当前购物车的总值x，然后反过来，从x开始往下减商品，减到大于等于200为止，这样是不是思路简单些也能实现，只是之前算小于等于，现在算大于等于","like_count":0},{"had_liked":false,"id":208758,"user_name":"王木公","can_delete":false,"product_type":"c1","uid":1014550,"ip_address":"","ucode":"F049AEBFA0338D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/16/ca250e8c.jpg","comment_is_top":false,"comment_ctime":1587433021,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587433021","product_id":100017301,"comment_content":"我也上一个Swift版本，二维数组实现动态规划01背包问题代码<br><br>static var states: [[Bool]] = [[Bool]].init(repeating: [Bool].init(repeating: false, count: 10), count: 5)<br>    static func zhuang3() {<br>        &#47;&#47; 先对第一个物品做特殊处理<br>        &#47;&#47; 不装<br>        states[0][0] = true<br>        &#47;&#47; 装<br>        states[0][array[0]] = true<br>        <br>        &#47;&#47; 从第二个物品到结束<br>        for i in 1..&lt;array.count {<br>            for j in 0...capacity {<br>                &#47;&#47; 只用关注前面已装或未装的<br>                if states[i - 1][j] {<br>                    &#47;&#47; 当前i物品，不装的状态<br>                    states[i][j] = true<br>                    &#47;&#47; 当前i物品，装的状态<br>                    if j + array[i] &lt;= capacity {<br>                        states[i][j + array[i]] = true<br>                    }<br>                }<br>            }<br>        }<br>        <br>        &#47;&#47;按行输出结果集<br>        for i in 0..&lt;array.count {<br>            for j in 0...capacity {<br>                print(states[i][j], terminator: &quot; &quot;)<br>            }<br>            print(&quot;&quot;)<br>        }<br>    }","like_count":0},{"had_liked":false,"id":207924,"user_name":"喻茂","can_delete":false,"product_type":"c1","uid":1318661,"ip_address":"","ucode":"C8BD8086A17365","user_header":"https://static001.geekbang.org/account/avatar/00/14/1f/05/8a06692e.jpg","comment_is_top":false,"comment_ctime":1587217458,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587217458","product_id":100017301,"comment_content":"&lt;?php<br>$weight = [2,2,4,6,3];&#47;&#47; 各物品重量数组<br>$value = [3,4,8,9,6]; &#47;&#47; 各物品价格数组<br>$n = 5; &#47;&#47; 物品总数<br>$w = 9;&#47;&#47; 背包承载的最大质量<br>function knapsack3($weight,$value,$n,$w) {<br>\t$states = []; &#47;&#47; 二维数组，下标分别是这是判断第几个商品，当前的总质量<br>\t&#47;&#47; 不选第0个商品<br>\t$states[0][0] = 0;<br>\t&#47;&#47; 选第0个商品<br>\tif ($weight[0] &lt;= $w) {<br>\t\t$states[0][$weight[0]] = $value[0];<br>\t}<br>\t<br>\tfor ($i = 1; $i &lt; $n;$i++) {<br>\t\t&#47;&#47; 不选择第i个商品<br>\t\tfor ($j=0;$j&lt;=$w;$j++) {<br>\t\t\tif(isset($states[$i-1][$j])) {<br>\t\t\t\t$states[$i][$j] = $states[$i-1][$j];<br>\t\t\t}<br>\t\t}<br>\t\t<br>\t\t&#47;&#47; 选择第i个商品<br>\t\tfor($j=0;$j&lt;=$w-$weight[$i];$j++) {<br>\t\t\tif(isset($states[$i-1][$j])) {<br>\t\t\t\t$v = $states[$i-1][$j] + $value[$i];<br>\t\t\t\tif (!isset($states[$i][$j+$weight[$i]]) ||<br>\t\t\t\t($v &gt;$states[$i][$j+$weight[$i]] )) {<br>\t\t\t\t\t$states[$i][$j+$weight[$i]] = $v;<br>\t\t\t\t}<br>\t\t\t}<br>\t\t}<br>\t\t<br>\t\t<br>\t}<br>\t&#47;&#47; 找出最大值<br>\treturn max($states[$n-1]);<br>}<br><br>echo knapsack3($weight,$value,$n,$w);","like_count":0},{"had_liked":false,"id":206374,"user_name":"Simple life","can_delete":false,"product_type":"c1","uid":1571460,"ip_address":"","ucode":"1902D7F72FB43F","user_header":"https://static001.geekbang.org/account/avatar/00/17/fa/84/f01d203a.jpg","comment_is_top":false,"comment_ctime":1586849966,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586849966","product_id":100017301,"comment_content":"杨辉三角<br> public static void alg(int[][] matrix){<br>          int[][] state = new int[matrix.length][matrix.length];<br>          state[0][0] = matrix[0][0];<br><br>        for (int i = 1; i &lt; matrix.length; i++) {<br>            for (int j = 0; j &lt; matrix[i].length; j++) {<br>                int min = Integer.MAX_VALUE;<br>                if (j - 1 &gt;= 0) {<br>                    min = Math.min(min,state[i-1][j-1]);<br>                }<br>                if (j &lt;= matrix[i].length - 2) {<br>                    min = Math.min(min,state[i-1][j]);<br>                }<br>                state[i][j] = min + matrix[i][j];<br>            }<br>        }<br>        int max = Integer.MAX_VALUE;<br>        for (int i = 0; i &lt; state[matrix.length - 1].length; i++) {<br>            max = Math.min(max,state[matrix.length - 1][i]);<br>        }<br>        System.out.println(max);<br>    }<br><br>    public static void main(String[] args) {<br>        int[][] matrix = {{5},{7,8},{2,3,4},{4,9,6,1},{2,7,9,4,5}};<br>        YangHuiTriangle.alg(matrix);<br>    }","like_count":0},{"had_liked":false,"id":206316,"user_name":"4567890","can_delete":false,"product_type":"c1","uid":1133055,"ip_address":"","ucode":"23BC97FD1DADF0","user_header":"https://static001.geekbang.org/account/avatar/00/11/49/ff/34a47dca.jpg","comment_is_top":false,"comment_ctime":1586838332,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586838332","product_id":100017301,"comment_content":"课后思考的代码：<br>   <br> private static int yanghuiTriangle(int[][] triangle){<br>        if(triangle==null||triangle.length==0){<br>            return 0;<br>        }<br>        int[] dp = new int[triangle.length];<br>        dp[0] = triangle[0][0];<br>        <br>        for(int i=1;i&lt;triangle.length;i++){<br>            for(int j=i;j&gt;=0;j--){<br>                    if(j==i){<br>                        dp[j] = dp[j-1]+triangle[i][j];<br>                    }else if(j==0){<br>                        dp[0] = dp[0]+triangle[i][j];<br>                    }else{<br>                        dp[j]= Math.min(dp[j],dp[j-1])+triangle[i][j];<br>                    }<br>            }<br>        }<br>        Arrays.sort(dp);<br>    return dp[0];<br>    }","like_count":0},{"had_liked":false,"id":206279,"user_name":"Simple life","can_delete":false,"product_type":"c1","uid":1571460,"ip_address":"","ucode":"1902D7F72FB43F","user_header":"https://static001.geekbang.org/account/avatar/00/17/fa/84/f01d203a.jpg","comment_is_top":false,"comment_ctime":1586833942,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586833942","product_id":100017301,"comment_content":"从大到小那个问题，如果是要像购物车那样遍历出来所选的物品，则该数组需要有序，如果无序只能找到结果值，如果按老是方法遍历则无法正常遍历出来","like_count":0},{"had_liked":false,"id":203679,"user_name":"StringTek","can_delete":false,"product_type":"c1","uid":1397201,"ip_address":"","ucode":"BC65D8522FAAA4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI7IxtBQbciclaJc5CcN5dz4Fia0r6XGCTEP3j02pprZYYQCNTtny1geWzn4uRULfCeaXkcFacS5V7Q/132","comment_is_top":false,"comment_ctime":1586254148,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586254148","product_id":100017301,"comment_content":"import java.util.Scanner;<br><br>public class TriangleDP {<br>    public static void main(String[] args) {<br>        int n;<br>        int ans=Integer.MAX_VALUE;<br>        Scanner scanner=new Scanner(System.in);<br>        n=scanner.nextInt();<br>        int[][] matrix=new int[n+1][];<br>        int[][] dp=new int[n+1][];<br>        dp[0]=new int[]{0,0};<br>        matrix[0]=new int[]{0,0};<br>        for(int i=1;i&lt;=n;i++){<br>            matrix[i]=new int[i+1];<br>            dp[i]=new int[i+1];<br>        }<br>        for(int i=1;i&lt;=n;i++){<br>            for(int j=1;j&lt;=i;j++){<br>                matrix[i][j]=scanner.nextInt();<br>            }<br>        }<br>        for(int i=1;i&lt;=n;i++){<br>            dp[i][1]=dp[i-1][1]+matrix[i][1];<br>            dp[i][matrix[i].length-1]=dp[i-1][matrix[i-1].length-1]+matrix[i][matrix[i].length-1];<br>        }<br>        ans=Math.min(ans,Math.min(dp[n][1],dp[n][matrix[n].length-1]));<br>        for(int i=2;i&lt;=n;i++){<br>            for(int j=2;j&lt;i;j++){<br>                dp[i][j]=Math.min(dp[i-1][j-1],dp[i-1][j])+matrix[i][j];<br>                if(i==n){<br>                    ans=Math.min(ans,dp[i][j]);<br>                }<br>            }<br>        }<br>        System.out.println(ans);<br>    }<br>}<br>","like_count":0},{"had_liked":false,"id":203165,"user_name":"JY","can_delete":false,"product_type":"c1","uid":1645413,"ip_address":"","ucode":"54DF39E40C0F20","user_header":"https://wx.qlogo.cn/mmopen/vi_32/OWO43KiahibaWnZWkEzXfNQCAqAvVNia44HLxzaNbPKZxiaic3ameJ72dLros26ibxuCL1B5pl7MRlOVrqutNsTOXegQ/132","comment_is_top":false,"comment_ctime":1586146343,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586146343","product_id":100017301,"comment_content":"let items = [, 5, 7, 8, 2, 3, 4, 4, 9, 6, 1, 2, 7, 9, 4, 5];&#47;&#47;前面补一个空白元素，方便下标计算;<br>let n = items.length; &#47;&#47;15;<br>let h = 5; &#47;&#47;通过(h*(h+1))&#47;2 = 15, h = 5;<br>let yangHuiSum = (items, n, h) =&gt; {<br>    let state = [];<br>    state[1] = items[1]; &#47;&#47;第一个元素特殊处理;<br>    for (let i = 1; i &lt; h; ++i) {<br>        let tempN = (i * (i + 1)) &#47; 2; &#47;&#47;得到每一层最后一个元素的下标，此元素往前h个元素都在h层<br>        for (let j = tempN; j &gt;= tempN - (i - 1); --j) {<br>            state[j + i] = state[j] + items[j + i]; &#47;&#47;每层的每一个元素的结果加到下一层的相邻两个节点上，从右往左开始；<br>            if (!state[j + i + 1]) {<br>                state[j + i + 1] = state[j] + items[j + i + 1]<br>            } else if (state[j + i + 1] &gt; state[j] + items[j + i + 1]) { &#47;&#47;节点结果取较小的；<br>                state[j + i + 1] = state[j] + items[j + i + 1]<br>            }<br>        }<br>    }<br>    let min = state[n - 1];<br>    let count = 0;<br>    for (let i = n - 2; i &gt;= n - h; --i) {<br>        if (state[i] &lt;= min) {<br>            min = state[i]; &#47;&#47;获得最小路径总数；<br>            count = i; &#47;&#47;获得最后一层结果的下标；<br>        }<br>    }<br>    console.log(min);<br>    let arr = [];<br>    for (let i = h; i &gt;= 1; --i) {<br>        arr.unshift(items[count]);<br>        if (min - items[count] === state[count - i]) {<br>            min = state[count - i];<br>            count = count - i;<br>        } else if (min - items[count] === state[count - i + 1]) {<br>            min = state[count - i + 1];<br>            count = count - i + 1;<br>        }<br>    }<br>    console.log(arr);<br>};<br>yangHuiSum(items, n, h);","like_count":0},{"had_liked":false,"id":202634,"user_name":"爱新觉罗老流氓","can_delete":false,"product_type":"c1","uid":1005661,"ip_address":"","ucode":"B13AC4DA358C15","user_header":"https://static001.geekbang.org/account/avatar/00/0f/58/5d/8de7f8dc.jpg","comment_is_top":false,"comment_ctime":1586020367,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1586020367","product_id":100017301,"comment_content":"为什么用一维数组后，j 递减，就不会重复计算呢？？？根据考察结果，j 递增或递减，计算都会发生重复...<br><br>本题中物品重量为 2,2,4,6,3。经第3-6行代码决策第0个物品的状态后，目前 states[0]=states[2]=true; 假设 j 从小到大递增的话，即 int j=0,<br>决策第1个物品时，有 2 次计算 states[0+2]=true 和 states[2+2]=true;——有 1 次重复计算<br>决策第2个物品时，有 3 次计算 states[0+4]=true、states[2+4]=true 和 states[4+4]=true;——有 1 次重复计算<br>决策第3个物品时，有 2 次计算 states[0+6]=true、states[2+6]=true;——有 2 次重复计算<br>决策第4个物品时，有 ？ 次计算 states[0+3]=true、states[2+3]=true、states[4+3]=true、states[6+3]=true;——无重复计算<br>...<br><br>如果我们让 j 从大到小递减，观察一下计算过程：<br>经第3-6行代码决策第0个物品的状态后，目前 states[0]=states[2]=true; <br>假设 j 从大到小递减，即 int j = w - items[i],<br>决策第1个物品时，j 从 7 开始递减，有 2 次计算 states[2+2]=true 和 states[0+2]=true; ——有 1 次重复计算<br>决策第2个物品时，j 从 5 开始递减，有 3 次计算 states[4+4]=true 、 states[2+4]=true 和 states[0+4]=true;——有 1 次重复计算<br>决策第3个物品时，j 从 3 开始递减，有 2 次计算 states[2+6]=true 和 states[0+6]=true;——有 2 次重复计算<br>决策第4个物品时，j 从 6 开始递减，有 4 次计算 states[6+3]=true、states[4+3]=true、states[2+3]=true 和 states[0+3]=true——无重复计算<br><br>可见让 j 递增或递减，计算时的重复次数并没有什么不同？？？","like_count":0,"discussions":[{"author":{"id":1151854,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/THkFNC52F0kYs2XI1fwxOvCck0Pibwnia4z6fzCPMRg2qYQLlt57qW4caJZ6uj9lWROc7t1OHFmIdKmiaEIP2GXpg/132","nickname":"isaac","note":"","ucode":"62ACA5B9A44D1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":242085,"discussion_content":"其实不应该理解成重复计算，而是应该理解成错误计算。从小到大的方式，计算小值的时候，很可能提前更新了后面的值，导致j递增到那个值的时候，进行了运算，本来是不应该运行的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587464440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202572,"user_name":"爱新觉罗老流氓","can_delete":false,"product_type":"c1","uid":1005661,"ip_address":"","ucode":"B13AC4DA358C15","user_header":"https://static001.geekbang.org/account/avatar/00/0f/58/5d/8de7f8dc.jpg","comment_is_top":false,"comment_ctime":1586009438,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586009438","product_id":100017301,"comment_content":"第一个动态规划的代码，对第10行代码分析：<br>第10行：if (states[i-1][j] == true)，这个判断的作用是检查 states 二维数组中 [i-1] 对应的这一行（上一个物品的行）状态中哪一个为 true，为 true 的就是上一个物品（第 i-1 个）被处理（决策）后的状态标记。然后根据上一行的状态，在第10行我们做的是决策 i 物品不放入背包，所以重量增加为 0，因此直接标记状态 states[i][j] = states[i-1][j];","like_count":0},{"had_liked":false,"id":202335,"user_name":"爱新觉罗老流氓","can_delete":false,"product_type":"c1","uid":1005661,"ip_address":"","ucode":"B13AC4DA358C15","user_header":"https://static001.geekbang.org/account/avatar/00/0f/58/5d/8de7f8dc.jpg","comment_is_top":false,"comment_ctime":1585970856,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585970856","product_id":100017301,"comment_content":"总觉得第一个递归树画得有问题，f(1,0) 能理解，f(1,2) 怎么来的，没考察第1个之前背包就有重量为 2 的物品了？？？","like_count":0},{"had_liked":false,"id":201629,"user_name":"蜗牛","can_delete":false,"product_type":"c1","uid":1086220,"ip_address":"","ucode":"01CC18F12E556D","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/0c/0a6a0d5e.jpg","comment_is_top":false,"comment_ctime":1585814314,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585814314","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":200703,"user_name":"看不见的城市","can_delete":false,"product_type":"c1","uid":1905705,"ip_address":"","ucode":"A33F894543C90F","user_header":"https://static001.geekbang.org/account/avatar/00/1d/14/29/48ad4b9d.jpg","comment_is_top":false,"comment_ctime":1585640523,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585640523","product_id":100017301,"comment_content":"用回溯算法：public void yang(int[] items, int value, int i, int p, int k) {<br>        if (i &gt;= ((k + 1) * k) &gt;&gt; 1) {<br>            if (value &lt; minValue) minValue = value;<br>            return;<br>        }<br>        yang(items, value + items[i], i + p, p + 1, k);<br>        yang(items, value + items[i + 1], i + p + 1, p + 1, k);<br>    }<br>动态规划就复杂了","like_count":0},{"had_liked":false,"id":199462,"user_name":"余向华","can_delete":false,"product_type":"c1","uid":1119778,"ip_address":"","ucode":"263773616D2C83","user_header":"https://static001.geekbang.org/account/avatar/00/11/16/22/2205cf0a.jpg","comment_is_top":false,"comment_ctime":1585489670,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585489670","product_id":100017301,"comment_content":"讲得真好","like_count":0},{"had_liked":false,"id":196849,"user_name":"彭纪程","can_delete":false,"product_type":"c1","uid":1682468,"ip_address":"","ucode":"F9222D72E791C8","user_header":"https://static001.geekbang.org/account/avatar/00/19/ac/24/0684a141.jpg","comment_is_top":false,"comment_ctime":1585318109,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585318109","product_id":100017301,"comment_content":"Python：<br>def calculate(list):<br>    n = len(list)<br>    states = [([0]*n)for i in range(n)]<br>    sum_left_line = 0<br>    for i in range(n):<br>        states[i][0] = list[i][0] + sum_left_line<br>        sum_left_line = states[i][0]<br>    print(states)<br>    sum_right_line = 0<br>    for i in range(n):<br>        states[i][i] = list[i][i] + sum_right_line<br>        sum_right_line = states[i][i]<br>    print(states)<br>    for i in range(2, n):<br>        for j in range(1,i):<br>            states[i][j] = min(states[i-1][j-1], states[i-1][j]) + list[i][j]<br>    print(states)<br>    min_value = states[n-1][0]<br>    for each in range(n):<br>        min_value = min(states[n-1][each], min_value)<br>    return min_value<br><br>print(calculate([[5],[7,8],[2,3,4],[4,9,6,1],[2,7,9,4,5]]))","like_count":0},{"had_liked":false,"id":196638,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1585299400,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585299400","product_id":100017301,"comment_content":"看的时间断断续续加起来将近四个小时，总算是看明白了！在没有看明白之前之前也听同事说起过这个算法，一直抱有敬畏的态度，没有信心来看这个算法，打算直接省略本节的课程。但是心有不甘，于是聚精会神跟着老师的思路走，一边阅读一边思考，结果效果还不错，至少看明白这个算法的思路了。不得不说，算法确实是博大精深啊！发明类似这样烧脑算法的人更是神人。","like_count":0},{"had_liked":false,"id":196558,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1585293033,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585293033","product_id":100017301,"comment_content":"对于“对于 (i, cw) 相同的不同状态，那我们只需要保留 cv 值最大的那个”的情况，这里说没法用备忘录进行解决，我认为可以用啊，可以用一个map来存储这个信息，其中key为i+&quot;&quot;+cw，值为cv，每次调用f函数之前先查询这个map中是否已经存在这个key，若不存在的话继续往下执行；若存在的话，获取对应的cv的值若cv的值比当前的值小的话，更新map中的cv值为该值，并且程序继续执行，若cv的值比当前的值小的话，返回。<br>老师指点我的思路是否正确。","like_count":0},{"had_liked":false,"id":186413,"user_name":"雷刚","can_delete":false,"product_type":"c1","uid":1655725,"ip_address":"","ucode":"115FE2BE1AAB61","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/pTD8nS0SsORKiaRD3wB0NK9Bpd0wFnPWtYLPfBRBhvZ68iaJErMlM2NNSeEibwQfY7GReILSIYZXfT9o8iaicibcyw3g/132","comment_is_top":false,"comment_ctime":1583840920,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583840920","product_id":100017301,"comment_content":"平常看到的动态规划代码都不复杂，一般都在方法的参数中传入一个 resolved 的 HashMap 变量，将已经求解的结果缓存起来。只是刚开始看别人的源码时，觉得有点奇怪，查了一下资料才知道是动态规划。","like_count":0},{"had_liked":false,"id":186304,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1583822591,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583822591","product_id":100017301,"comment_content":"今天 先总结一下 动态规划的知识<br>主要是为了解决回溯算法时间复杂度过高的问题 指数级别 虽然我们也可以用备忘录方式 优化一下，但是对于状态更多的情况下 不太好用 所以动态规划登场了<br>虽然这一节没有讲理论<br>但是我觉得动态规划就是 把一个大问题 分为n个阶段 每个阶段求出最优解 然后通过上一阶段的最优解 推导出这一阶段的最优解<br>让我感觉和分治和贪心有点类似 只是贪心算法处理的是当前最优<br>针对于文中的提问 优化空间复杂度 代码如下  针对杨晖三角我已经想好了用完全二叉树 就是之前讲的堆的方式储存代码还未实现 就先上优化空间复杂度的代码 <br>vector&lt;int&gt; items = { 2,2,4,6,3 };  &#47;&#47;物品重量<br>7 vector&lt;int&gt; value = { 3,4,8,9,6 };  &#47;&#47;物品价值<br>8 const int count = 5;        &#47;&#47;物品最大数量为5<br>9 const int w = 9;            &#47;&#47;背包所能承受的最大重量为9<br>10 <br>11 &#47;&#47;题目要求在满足背包最大重量前提下 物品的价值最高<br>  12 <br>  13 int<br>  14 main( int argc, char* argv[] ) {<br>  15     vector&lt;int&gt; states(w+1, 0);     &#47;&#47;dp状态为 当前重量的情况下 所能达到的最大价值<br>  16     &#47;&#47;初始化第一个<br>  17     states[0] = 0;<br>  18     &#47;&#47;放入第一个道<br> 19     states[items[0]] = value[0];<br> 20 <br> 21 <br> 22 <br> 23     for ( int i = 1; i &lt; count; ++i ) {<br> 24 <br> 25         &#47;&#47;考虑不放的情况<br> 26         for ( int j = 0; j &lt;= w - items[i]; ++j ) {<br> 27             if ( states[j] &gt; 0 ) {<br> 28                 states[j+items[i]] = states[j];<br> 29             }<br> 30         }<br> 31 <br> 32         for ( int j = 0; j &lt;= w - items[i]; ++j ) {<br> 33             if ( states[j] + value[i] &gt; states[j+items[i]] ) {<br> 34                 states[j+items[i]] = states[j] + value[i];<br> 35             }<br> 36         }<br> 37     }<br> 38     printf( &quot;max value:%d\\n&quot;, states[w] );<br> 39 <br> 40 }","like_count":0},{"had_liked":false,"id":185025,"user_name":"一","can_delete":false,"product_type":"c1","uid":1603640,"ip_address":"","ucode":"BCC6241C4CC6D1","user_header":"https://static001.geekbang.org/account/avatar/00/18/78/38/da3959cc.jpg","comment_is_top":false,"comment_ctime":1583466966,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583466966","product_id":100017301,"comment_content":"假如双11结束了 我的代码还没有写完。。。。","like_count":0},{"had_liked":false,"id":181189,"user_name":"Zed","can_delete":false,"product_type":"c1","uid":1344997,"ip_address":"","ucode":"0B1BF15DFB050C","user_header":"https://static001.geekbang.org/account/avatar/00/14/85/e5/eedb0528.jpg","comment_is_top":false,"comment_ctime":1582514990,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1582514990","product_id":100017301,"comment_content":"😵","like_count":0},{"had_liked":false,"id":181091,"user_name":"1024","can_delete":false,"product_type":"c1","uid":1086407,"ip_address":"","ucode":"DCC31F6EC54F43","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/c7/86352ccc.jpg","comment_is_top":false,"comment_ctime":1582473142,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582473142","product_id":100017301,"comment_content":"升级版的背包问题，动态规划解法，当中这部分代码，不单纯是为了减少重复状态，实际上是防止对stateV[i][j + weight[i]] 这个元素的复写，造成结果偏小。所以对这个元素的赋值都要判断是否大于前值<br>```<br>if (stateV[i - 1][j] &gt;= 0) {<br>                    int v = stateV[i - 1][j] + value[i];<br>                    if (v &gt; stateV[i][j + weight[i]]) {<br>                        stateV[i][j + weight[i]] = v;<br>                    }<br>                }<br>```","like_count":0},{"had_liked":false,"id":180109,"user_name":"czriven","can_delete":false,"product_type":"c1","uid":1116737,"ip_address":"","ucode":"112CDBF6D0219A","user_header":"https://static001.geekbang.org/account/avatar/00/11/0a/41/19018754.jpg","comment_is_top":false,"comment_ctime":1582189420,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582189420","product_id":100017301,"comment_content":"思考题就是lc 120题","like_count":0},{"had_liked":false,"id":174744,"user_name":"倡印","can_delete":false,"product_type":"c1","uid":1455958,"ip_address":"","ucode":"4F53AA5D017D89","user_header":"https://static001.geekbang.org/account/avatar/00/16/37/56/11068390.jpg","comment_is_top":false,"comment_ctime":1580368760,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580368760","product_id":100017301,"comment_content":"0-1背包重量问题就像是一个在二维坐标求解的问题。<br>0-1背包最大价格问题就像在一个三维坐标系中求z轴最高的是哪个点。<br>但是我不明白 0-1最大价格问题中<br><br>但是我发现 动态规划也只是一系列最优选项中的一个(特别是当items很多时候)，根据代码的写法来看，首先会考虑items[n-1]的数据 所以这也只是一些列选择中的一个。<br><br>不知道我的理解对不对 大神们指导下吧","like_count":0},{"had_liked":false,"id":174616,"user_name":"不归橙","can_delete":false,"product_type":"c1","uid":1319969,"ip_address":"","ucode":"4F3D84E9395F61","user_header":"https://static001.geekbang.org/account/avatar/00/14/24/21/90b748a2.jpg","comment_is_top":false,"comment_ctime":1580296598,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1580296598","product_id":100017301,"comment_content":"杨辉三角变形问题，将其旋转之后再用0补充，动态规划之后再取最小值？<br>5  7  2  4  2<br>8  3  9  7  0<br>4  6  9  0  0<br>1   4  0  0  0<br>5  0  0  0  0","like_count":0},{"had_liked":false,"id":173030,"user_name":"Richie","can_delete":false,"product_type":"c1","uid":1019588,"ip_address":"","ucode":"12314EF0347693","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/c4/8d1150f3.jpg","comment_is_top":false,"comment_ctime":1579413207,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579413207","product_id":100017301,"comment_content":"从文中的例子可以看出，回溯和动态规划都需要提前知道问题的解空间，否则我们的算法就无法实施了，比如双十一凑单的例子，如果我们不限定x的最大值，那就没法使用动态规划来解了。","like_count":0},{"had_liked":false,"id":172180,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1579102154,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1579102154","product_id":100017301,"comment_content":"态规划学习路线<br>\t\t1，动态规划比较适合用来求解最优问题，比如求最大值，最小值等。可以非常显著地降低时间复杂度，提高的执行效率。<br>\t<br>\t0-1背包问题<br>\t <br>\t使用回溯算法：<br>使用回溯法复杂度比较高，是指数级别的，规律不好找。递归树中的每个节点表是一种状态，我们用（I,cw）来表示。其中，i表示将要决策第几个物品是否要装入背包，cw表示当前背包中物品的总重量。如（2,2）表示我们将要决策第2个物品是否要装入背包，在决策前，背包中的物品总重量是2。<br><br>从递归树中，可发现有些子问题的求解是重复的，如图中f(2,2)和f(3,4)都被重复计算了两次。我们可借助“备忘录”的解决方式，记录已经计算好的f(I,cw)，当再次计算到重复的f(I,cw)的时候，可以直接从备忘录中取出来用，就不用在递归计算了，这样就可以避免冗余计算。<br><br>\t使用动态规划算法：<br>\t\t把整个求解过程分为n个阶段，每个阶段会决策一个物品是否放置到背包中。每个物品决策（放入或者不放入背包）完之后，背包中的物品的重量会有很都情况，会达到多种不同的状态，对应到递归树中，就是很多不同的节点。<br>\t把每一层重复的状态（节点）合并，只记录不同的状态，然后基于上一层的状态集合，来推导下一层的状态集合。我们可以通过合并每一层重复的状态，这样就保证每一层不同状态的个数都不会超过w个（w表示背包的承载重量），这就避免了每层状态个数的指数级增长。<br>\t用一个二维数组states[n],[w+1]，来记录每层可以达到的不同状态<br>\t<br>\t第0个（下标从0开始编号）物品的重量是2，要么转入背包，要么不装入背包，决策完之后，会对应背包的两种状态，背包中物品的总重量是0或者2。我们用states[0][0]=true和states[0][2]=true来表示这两种转态。<br>\t第1个物品的重量也是2，基于之前的背包状态，在这个物品决策完之后，不同的状态有3个，背包中物品总重量分别是0(0+0)，2(0+2 or 2+0)，4(2+2)。我们用states[1][0]=true，states[1][2]=true，states[1][4]=true来表示这三种状态。<br> <br> <br>\t<br>\t用回溯算法解决这个问题的时间复杂度O(2^n)，是指数级的。动态规划方案的时间复杂度是O(n*w)。n表是物品个数，w表是背包可以承载的总重量。<br>\t尽管动态规划的执行效率比较高，但是我们需要额外申请一个n乘以w+1的二维数组，对空间消耗比较多。所以动态规划是一种空间换时间的解决思路。<br>\t但实际上，只需要一个大小为w+1的一维数组就可以解决这个问题。动态规划状态转移的过程，都可以基于这个一维数组来操作。<br>\t<br>0-1背包问题升级版<br>\t基础的背包问题，只涉及背包的重量和物品重量，现在引入物品价值这个一个变量。对于一组不同重量，不同价值，不可分割的物品，在满足背包最大重量限制的前提下，背包中可装入物品的总价值最大是多少？<br>\t采用回溯算法：<br> <br>在递归树中，每个节点表示一个状态，需要3个变量（I，cw，cv）来表示一个状态。其中，i表示即将要决策第i个物品是否装入背包，cw表示当前背包中物品的总重量，cv表示总价值。<br>在递归树中，有几个节点的i和cw是完全相同的，比如f(2,2,4)和f(2,2,3)。在背包中物品总重量一样的情况下，f(2,2,4)这种状态对应的物品总价值更大，可以舍弃f(2,2,3)这种状态，只需要沿着f(2,2,4),这条策略线继续往下决策就可以<br>即对于（I,cw）相同的不同状态，我们只需要保留cv值最大的那个，继续递归处理，其他状态不予考虑。<br><br>采用动态规划算法：<br>还是把整个求解过程分为n个状态，每个阶段会决策一个物品是否放到背包中。每个决策完之后，背包中的物品的总重量以及总价值，会有多种情况，也就是会达到多种不同的状态。<br>用一个二维数组states[n][w+1]，来记录每层可以达到的不同状态。不过这里数组存储的值不在是boolean类型的了，而且当前状态对应的最大总价值，我们把每一层中（I,cw）重复的状态（节点）合并，只记录了cv值最大的那个状态，然后基于这些状态来推导下一层的状态。<br><br>","like_count":0},{"had_liked":false,"id":171481,"user_name":"supermouse","can_delete":false,"product_type":"c1","uid":1321860,"ip_address":"","ucode":"88072D5F881827","user_header":"https://static001.geekbang.org/account/avatar/00/14/2b/84/07f0c0d6.jpg","comment_is_top":false,"comment_ctime":1578928787,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578928787","product_id":100017301,"comment_content":"请问老师，01背包问题的升级版可以用动态规划+一维数组求解吗？","like_count":0},{"had_liked":false,"id":171356,"user_name":"Allen_","can_delete":false,"product_type":"c1","uid":1677187,"ip_address":"","ucode":"CA5E00E4644CD5","user_header":"https://static001.geekbang.org/account/avatar/00/19/97/83/845b48e2.jpg","comment_is_top":false,"comment_ctime":1578907323,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578907323","product_id":100017301,"comment_content":"老师的这个动态规划解法和我平常解法不一样。自己觉得我的这种解法要稍微优雅一些，分享分享。<br><br>def knapSack(items, n, w):<br>  <br><br>  dp = [[0 for _ in range(3*w + 1)] for _ in range(n)]<br><br>  for i in range(n):<br><br>      for j in range(3*w + 1):<br><br>          dp[i][j] = max(dp[i-1][j-items[i]] + items[i], dp[i-1][j])<br><br><br>  return max(dp[-1])<br>          <br><br><br><br>","like_count":0},{"had_liked":false,"id":170924,"user_name":"huguo","can_delete":false,"product_type":"c1","uid":1330333,"ip_address":"","ucode":"418B04E2AB13EB","user_header":"https://static001.geekbang.org/account/avatar/00/14/4c/9d/601b1949.jpg","comment_is_top":false,"comment_ctime":1578761717,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578761717","product_id":100017301,"comment_content":"贪心就是局部最优可以推广到全局最优的过程","like_count":0},{"had_liked":false,"id":170201,"user_name":"SteveYang","can_delete":false,"product_type":"c1","uid":1754829,"ip_address":"","ucode":"C42BCA4F40A9EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKCbnOvEatUN4ysE2cl6zJNoAJVXXuQVhicQ1jxh6Z2Towrmmc1I6PndaicuQQ0RyyJPyJQicv4tSib9Q/132","comment_is_top":false,"comment_ctime":1578548660,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578548660","product_id":100017301,"comment_content":"课后杨辉三角问题可以用动态规划的转移方程实现，S[i][j] = min(S[i-1][j],S[i-1][j-1]) + a[i][j]","like_count":0},{"had_liked":false,"id":168941,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1578221160,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578221160","product_id":100017301,"comment_content":"我用Python写了一个程序，代码如下：<br><br># 杨辉三角数组<br>YH = [[5],[7,8],[2,3,4],[4,9,6,1],[2,7,9,4,5]]<br>path = {(0,0): [YH[0][0]]}<br><br># 找出某个节点的左上和右上邻接节点<br>def searchup(row, col):<br>    global YH<br>    urow = row - 1<br>    lcol = col - 1<br>    rcol = col<br><br>    ld = rd = None<br>    ln = rn = None<br><br>    # 左上邻接点存在<br>    if urow &gt;=0 and lcol &gt;= 0:<br>        ld = YH[urow][lcol]<br>        ln = (urow, lcol)<br>    <br>    # 右上邻接点存在<br>    if urow &gt;=0 and rcol &lt;= urow:<br>        rd = YH[urow][rcol]<br>        rn = (urow, rcol)<br><br>    return ld,rd,ln, rn<br><br># 查找杨辉三角的最短路径<br>def findpath():<br>    global YH<br>    global path<br><br>    for row in range(1,len(YH)):<br>        for col in range(len(YH[row])):<br>            ld,rd,ln,rn = searchup(row, col)<br><br>            # 从左上和右上节点均可到达本节点，则只保留最短路径的节点<br>            if ln is not None and rn is not None:<br><br>                ldata = YH[row][col] + ld<br>                rdata = YH[row][col] + rd<br>                tnode = None<br>                tdata = None<br><br>                if ldata &lt; rdata:<br>                    tdata = ldata<br>                    tnode = ln<br>                else:<br>                    tdata = rdata<br>                    tnode = rn<br>                <br>            # 只有左上节点可达<br>            elif ln is not None and rn is None:<br>                tdata = YH[row][col] + ld<br>                tnode = ln<br><br>            # 只有右上节点可达<br>            elif rn is not None and ln is None:<br>                tdata = YH[row][col] + rd<br>                tnode = rn<br><br>            # 记录到达本节点的最短路径及路径长<br>            path[(row,col)] = path[tnode].copy()<br>            path[(row,col)].append(YH[row][col])<br>            YH[row][col] = tdata<br><br>    # 从最后一行中找到最短路径<br>    lastrow = len(YH) - 1<br>    min_node = None<br>    min_len = None<br><br>    for col in range(len(YH[lastrow])):<br>        if min_node is None or YH[lastrow][col] &lt; min_len:<br>            min_len = YH[lastrow][col]<br>            min_node = (lastrow,col)<br><br>    # 输出最短路径<br>    print(&#39;最短路径长度={}&#39;.format(min_len))<br>    print(&#39;最短路径为：{}&#39;.format(&#39;--&gt;&#39;.join([str(x) for x in path[min_node]])))<br><br>if __name__ == &#39;__main__&#39;:<br>    findpath()<br>","like_count":0},{"had_liked":false,"id":167525,"user_name":"那样的月色","can_delete":false,"product_type":"c1","uid":1237353,"ip_address":"","ucode":"23B1298C465D2C","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/69/0db70c84.jpg","comment_is_top":false,"comment_ctime":1577848286,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577848286","product_id":100017301,"comment_content":"回溯背包的解题思路还是看不明白，，，就算有注释也看不明白 😢","like_count":0},{"had_liked":false,"id":167292,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1577757447,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577757447","product_id":100017301,"comment_content":"0-1背包的状态是由背包容量，待选择的物品对应的向量两个参数决定的。动态规划法的背后其实是对这两个变量作递归。例如，初始问题中，对于最后一个物品是否选择，就规约为两个子问题，第一个子问题，待选择物品向量减一维，背包容量也减少相应的容量。第二个子问题，待选择物品向量减一维，背包容量不变，这两个问题和原问题相同，但是规模变小，这就开启了递归过程，在过程中记录已经算过的量，再规定初值，整个递归过程就可以顺利进行。动态规划法可以看作是高维的递归问题。","like_count":0},{"had_liked":false,"id":165928,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1577345765,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577345765","product_id":100017301,"comment_content":"动态规划法很像带缓存的多维数学归纳法，也就是一个多维函数可以递归写成相同函数但是某个维度的参数较小的运算结果，这样就可以层层分解下去，最终求解问题。","like_count":0},{"had_liked":false,"id":165776,"user_name":"梦想的优惠券","can_delete":false,"product_type":"c1","uid":1257418,"ip_address":"","ucode":"D3B44F6C618CA7","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/ca/cbce6e94.jpg","comment_is_top":false,"comment_ctime":1577321053,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1577321053","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":165293,"user_name":"lji","can_delete":false,"product_type":"c1","uid":1724244,"ip_address":"","ucode":"5791B86037F129","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/zxrG3SKctHcdRcCw5Z3W5Ur0Opaziaj6r6otPpmzZrdIFf5Ref5dyEZQALa7DXn3ViaeWiaTiaeghQA4R5ib8x74JYg/132","comment_is_top":false,"comment_ctime":1577194891,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1577194891","product_id":100017301,"comment_content":"<br>weight: 物品重量，n: 物品个数，w: 背包可承载重量<br>public int knapsack(int[] weight, int n, int w) {<br>  boolean[][] states = new boolean[n][w+1]; &#47;&#47; 默认值 false<br>  states[0][0] = true;  &#47;&#47; 第一行的数据要特殊处理，可以利用哨兵优化<br>  if (weight[0] &lt;= w) {<br>    states[0][weight[0]] = true;<br>  }<br>  for (int i = 1; i &lt; n; ++i) { &#47;&#47; 动态规划状态转移<br>    for (int j = 0; j &lt;= w; ++j) {&#47;&#47; 不把第 i 个物品放入背包<br>      if (states[i-1][j] == true) states[i][j] = states[i-1][j];<br>    }<br>    for (int j = 0; j &lt;= w-weight[i]; ++j) {&#47;&#47; 把第 i 个物品放入背包<br>      if (states[i-1][j]==true) states[i][j+weight[i]] = true;<br>    }<br>  }<br>  for (int i = w; i &gt;= 0; --i) { &#47;&#47; 输出结果<br>    if (states[n-1][i] == true) return i;<br>  }<br>  return 0;<br>}<br>这里的最后for (int i = w; i &gt;= 0; --i) 应该for (int i = n; i &gt;= 0; --i) 。<br>","like_count":0},{"had_liked":false,"id":164803,"user_name":"W.G.Ma","can_delete":false,"product_type":"c1","uid":1349798,"ip_address":"","ucode":"3518F2058023F4","user_header":"https://static001.geekbang.org/account/avatar/00/14/98/a6/41394d63.jpg","comment_is_top":false,"comment_ctime":1577093361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577093361","product_id":100017301,"comment_content":"回溯算法<br>private int[][] matrix = {{5},{7,8},{2,3,4},{4,9,6,1},{2,7,9,4,5}};<br>private int lineCount = 5;<br>private int minPath = Integer.MAX_VALUE;<br>public void huisu(int line, int y, int val) {<br><br>        if (line == lineCount - 1) {<br>            int tmpVal = val + matrix[line][y];<br>            if (tmpVal &lt; minPath) {<br>                minPath = tmpVal;<br>            }<br>            return;<br>        }<br>        huisu(line + 1, y, val + matrix[line][y]);<br>        huisu(line + 1, y + 1, val + matrix[line][y]);<br><br>    }","like_count":0},{"had_liked":false,"id":160970,"user_name":"马振","can_delete":false,"product_type":"c1","uid":1136329,"ip_address":"","ucode":"94234F533219C1","user_header":"https://static001.geekbang.org/account/avatar/00/11/56/c9/7b3cd3e0.jpg","comment_is_top":false,"comment_ctime":1576071729,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576071729","product_id":100017301,"comment_content":"分享一个1-0背包的错误写法，感觉这错误很经典<br>    public static int  findBackPackNew(int[] item, int maxWeight){<br><br>        int itemNum = item.length;<br>        &#47;&#47; 如果int[i][j]=true;表示取到第i个item时，重量可以为j<br>        boolean[] state= new boolean[maxWeight+1];<br>        &#47;&#47; 初始化<br>        state[0] = true;<br>        if(item[0] &lt; maxWeight){<br>            state[item[0]]=true;<br>        }<br><br>        for(int i =1; i&lt;itemNum; i++){<br>            &#47;&#47; 错误写法<br>&#47;&#47;            for(int j=0; j&lt;=maxWeight; j++){<br>&#47;&#47;                if(state[j]){<br>&#47;&#47;                    &#47;&#47; 存在bug，第一个item(值为3)后，0 3为true，<br>&#47;&#47;                    &#47;&#47; 第二个item(值为2)，先是j=0，所以新增2为true 然后在j=2的时候，会再次加2，4为true，此时明显2被加了两次是不正确的<br>&#47;&#47;                    &#47;&#47; 解决方案，就是在上面j的遍历进行递减遍历，因为值肯定是大于零的<br>&#47;&#47;                    if(j + item[i] &lt;= maxWeight){<br>&#47;&#47;                        state[j+item[i]] = true;<br>&#47;&#47;                        System.out.println(&quot;o&quot;);<br>&#47;&#47;                    }<br>&#47;&#47;                }<br>&#47;&#47;            }<br>            &#47;&#47; 正确且简介<br>            for(int j=maxWeight-item[i]; j&gt;=0; j--){<br>                if(state[j]){<br>                    state[j+item[i]] = true;<br>                }<br>            }<br>        }<br><br>        for(int i=maxWeight; i&gt;0; i-- ){<br>            if(state[i]){<br>                return i;<br>            }<br>        }<br>        return 0;<br>    }","like_count":0},{"had_liked":false,"id":159049,"user_name":"Geek_b25f99","can_delete":false,"product_type":"c1","uid":1661456,"ip_address":"","ucode":"6F7BEAB2C31528","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epYAmnyHBCVY7YicTF3IXa39mvVTuyum9yicPyFG5amXuo6R2QOTicX0iaXLicH8CTktC7XHruv81ichgkg/132","comment_is_top":false,"comment_ctime":1575525537,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575525537","product_id":100017301,"comment_content":"0-1背包问题，二维数据保存state.状态时代码的12行，j理论是应该从大到小的，因为需要找到小于w-items[i]的j的取值是哪些状态转移过来的，因为是二维数据不会出现覆盖情况所以，代码j可以直接从小到大，这也就是为啥用一维数组保存状态优化的时候，j从大到小的原因了。","like_count":0},{"had_liked":false,"id":156688,"user_name":"18811790716","can_delete":false,"product_type":"c1","uid":1235310,"ip_address":"","ucode":"E9BF67EB8D45A4","user_header":"https://static001.geekbang.org/account/avatar/00/12/d9/6e/4e3f7eba.jpg","comment_is_top":false,"comment_ctime":1574935658,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574935658","product_id":100017301,"comment_content":"带memo的回溯算法  <br>if (mem[i][cw]) return; &#47;&#47; 重复状态 <br>mem[i][cw] = true; &#47;&#47; 记录(i, cw)这个状态    <br>这个是不是有问题啊？ <br><br>我这边用python实现的要放在 f函数的最后才行","like_count":0},{"had_liked":false,"id":154834,"user_name":"Geek_b57cd1","can_delete":false,"product_type":"c1","uid":1737903,"ip_address":"","ucode":"74D7E5C4269399","user_header":"","comment_is_top":false,"comment_ctime":1574576983,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574576983","product_id":100017301,"comment_content":"“我们用（i, cw）来表示。其中，i 表示将要决策第几个物品是否装入背包，cw 表示当前背包中物品的总重量。比如，（2，2）表示我们将要决策第 2 个物品是否装入背包，在决策前，背包中物品的总重量是 2。” 我怎么理解是 f(2,2) 这个过程是决定第3(数组下标是2)个物品是否装入背包，决策前背包的总重量是2。","like_count":0},{"had_liked":false,"id":152907,"user_name":"Ethan","can_delete":false,"product_type":"c1","uid":1246139,"ip_address":"","ucode":"ED197A378EE91B","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/bb/c5f139cc.jpg","comment_is_top":false,"comment_ctime":1574122502,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574122502","product_id":100017301,"comment_content":"愣是看了三遍才看懂，豁然开朗。","like_count":0},{"had_liked":false,"id":151247,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1573691406,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1573691406","product_id":100017301,"comment_content":"复习一波，之前课后题没写出来，继续往前学，这次复习终于可以独立写出来了。为自己鼓掌，啪啪啪啪！https:&#47;&#47;github.com&#47;gdhucoder&#47;Algorithms4&#47;blob&#47;master&#47;geekbang&#47;ALGO&#47;u40&#47;review3&#47;YangHui.java","like_count":0},{"had_liked":false,"id":148934,"user_name":"葡萄有点酸","can_delete":false,"product_type":"c1","uid":1136529,"ip_address":"","ucode":"51C3CE1E685D8E","user_header":"https://static001.geekbang.org/account/avatar/00/11/57/91/3a082914.jpg","comment_is_top":false,"comment_ctime":1573112815,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573112815","product_id":100017301,"comment_content":"课后思考题用动态规划最适合不过了，但这个题可以从底部到顶部倒推演绎，对于我个人来说更有助于理解。<br>public int yanghuiTriangle(int[][] matrix) {<br>    int length = matrix.length;<br>    int[] min = new int[length + 1];<br>    for (int i = length - 1; i &gt;= 0; i--) {<br>        int[] rawNums = matrix[i];<br>        int rowLength = rawNums.length;<br>        for (int j = 0; j &lt; rowLength; j++) {<br>            min[j] = Math.min(min[j], min[j + 1]) + rawNums[j];<br>        }<br>    }<br>    return min[0];<br>}","like_count":0},{"had_liked":false,"id":145440,"user_name":"一身菜味","can_delete":false,"product_type":"c1","uid":1131509,"ip_address":"","ucode":"D86FF6DE4C040F","user_header":"https://static001.geekbang.org/account/avatar/00/11/43/f5/41ead8d2.jpg","comment_is_top":false,"comment_ctime":1572273569,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572273569","product_id":100017301,"comment_content":"实际上双十一购买的时候比这个还要复杂，因为不仅仅是要看买的东西最多，还得看性价比（优惠幅度大，满减叠加互斥等问题），哈哈哈","like_count":0},{"had_liked":false,"id":142210,"user_name":"丁丁历险记","can_delete":false,"product_type":"c1","uid":1661704,"ip_address":"","ucode":"A43829E454C067","user_header":"https://static001.geekbang.org/account/avatar/00/19/5b/08/b0b0db05.jpg","comment_is_top":false,"comment_ctime":1571312907,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571312907","product_id":100017301,"comment_content":"蒙b 好几天了","like_count":0},{"had_liked":false,"id":141814,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1571230252,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571230252","product_id":100017301,"comment_content":"不容易，还是慢慢啃下来","like_count":0},{"had_liked":false,"id":141666,"user_name":"Eric","can_delete":false,"product_type":"c1","uid":1575571,"ip_address":"","ucode":"7EB511C384BD7B","user_header":"https://static001.geekbang.org/account/avatar/00/18/0a/93/a189ec16.jpg","comment_is_top":false,"comment_ctime":1571209606,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571209606","product_id":100017301,"comment_content":"老师，我有一个疑问，就是解答开篇的代码那部分，假设最后一个商品与倒数第二个商品的价格一样，而且数组最后一行和倒数第二行数据是一样的，算法只会算作购买了靠后的那个商品对吧","like_count":0},{"had_liked":false,"id":141654,"user_name":"Eric","can_delete":false,"product_type":"c1","uid":1575571,"ip_address":"","ucode":"7EB511C384BD7B","user_header":"https://static001.geekbang.org/account/avatar/00/18/0a/93/a189ec16.jpg","comment_is_top":false,"comment_ctime":1571207847,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571207847","product_id":100017301,"comment_content":"背包问题升级版降低空间复杂度的实现<br><br>public int MAX_PRICE = Integer.MIN_VALUE;<br>    public void func1(int[] items_weight,int[] items_price,int weight){<br>        int[] tmp = new int[weight + 1];<br>        tmp[0] = 0;<br>        if (items_weight[0] &lt;= weight){<br>            tmp[items_weight[0]] = items_price[0];<br>        }<br><br>        for (int i = 1;i &lt; items_weight.length; i++){<br>            for (int j = weight - items_weight[i]; j &gt;= 0; j--){<br>                if (tmp[j] &gt; 0){<br>                    if (tmp[j + items_weight[i]] &lt; tmp[j] + items_price[i]){<br>                        tmp[j + items_weight[i]] = tmp[j] + items_price[i];<br>                    }<br>                }<br>            }<br>        }<br><br>        for (int j = tmp.length - 1; j &gt;= 0; j++){<br>            if (MAX_PRICE &lt; tmp[j]){<br>                MAX_PRICE = tmp[j];<br>                return;<br>            }<br>        }<br>    }","like_count":0},{"had_liked":false,"id":139120,"user_name":"Jincc","can_delete":false,"product_type":"c1","uid":1455772,"ip_address":"","ucode":"FD49816E6BC1C9","user_header":"https://static001.geekbang.org/account/avatar/00/16/36/9c/127a7426.jpg","comment_is_top":false,"comment_ctime":1570549286,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570549286","product_id":100017301,"comment_content":"习题大家可以参考解法https:&#47;&#47;github.com&#47;jincc&#47;iOS-Algorithm&#47;blob&#47;master&#47;dp&#47;pascals_triangle.h，里面包含回溯和动态规划","like_count":0},{"had_liked":false,"id":138079,"user_name":"shoren","can_delete":false,"product_type":"c1","uid":1490650,"ip_address":"","ucode":"33B41D060ACCFC","user_header":"https://static001.geekbang.org/account/avatar/00/16/be/da/00304ce4.jpg","comment_is_top":false,"comment_ctime":1570011514,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570011514","product_id":100017301,"comment_content":"找不到前面的留言了，直接这里继续留言吧。<br>为什么要判断前一次的状态呢？ 前一次状态为true或者大于0，说明前一次是一个有效的状态，在有效状态之上操作才有意义。","like_count":0},{"had_liked":false,"id":138077,"user_name":"shoren","can_delete":false,"product_type":"c1","uid":1490650,"ip_address":"","ucode":"33B41D060ACCFC","user_header":"https://static001.geekbang.org/account/avatar/00/16/be/da/00304ce4.jpg","comment_is_top":false,"comment_ctime":1570010845,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570010845","product_id":100017301,"comment_content":"请问下，在处理不放入第i物品时，总是加一个判断： if (states[i-1][j] &gt;= 0) states[i][j] = states[i-1][j]; 为什么不直接写states[i][j] = states[i-1][j];呢？","like_count":0},{"had_liked":false,"id":138071,"user_name":"JustDoDT","can_delete":false,"product_type":"c1","uid":1127175,"ip_address":"","ucode":"6AF0B80F00EAEF","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/07/8f351609.jpg","comment_is_top":false,"comment_ctime":1570008819,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570008819","product_id":100017301,"comment_content":"这一段不知道我看懂了没？<br>原文：<br>如果 states[i-1][j] 可达，就说明我们没有选择购买第 i 个商品，如果 states[i-1][j-value[i]] 可达，那就说明我们选择了购买第 i 个商品。我们从中选择一个可达的状态（如果两个都可达，就随意选择一个），然后，继续迭代地考察其他商品是否有选择购买。<br>我的理解：<br>选择购买第i个商品的赋值在不选择后面执行，所以当j == j - value[i] 时会出现两者都可达的情况","like_count":0},{"had_liked":false,"id":137952,"user_name":"(Kelen)","can_delete":false,"product_type":"c1","uid":1241185,"ip_address":"","ucode":"C8578DB62E3B2D","user_header":"https://static001.geekbang.org/account/avatar/00/12/f0/61/fedca2e9.jpg","comment_is_top":false,"comment_ctime":1569936285,"is_pvip":false,"replies":[{"id":"53990","content":"好像没问题的。递归树和后面的递推公式你要分开看，并不是很一致。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1570748390,"ip_address":"","comment_id":137952,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569936285","product_id":100017301,"comment_content":"递归树那个图说法是不是由点问题啊，f(2,2)，代表应该是如果决定第二个放进去，2是放入的后的重量，而不是文中的放入前的重量","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469322,"discussion_content":"好像没问题的。递归树和后面的递推公式你要分开看，并不是很一致。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570748390,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136237,"user_name":"junjun","can_delete":false,"product_type":"c1","uid":1547322,"ip_address":"","ucode":"1F7EE146B9BE04","user_header":"https://static001.geekbang.org/account/avatar/00/17/9c/3a/bfd73920.jpg","comment_is_top":false,"comment_ctime":1569393148,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569393148","product_id":100017301,"comment_content":"动态规划就是根据n-1的状态找到状态转移公式，然后转移到下一层","like_count":0},{"had_liked":false,"id":136032,"user_name":"一个工匠","can_delete":false,"product_type":"c1","uid":1038449,"ip_address":"","ucode":"2168BA6F926074","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d8/71/d6f79534.jpg","comment_is_top":false,"comment_ctime":1569334165,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1569334165","product_id":100017301,"comment_content":"刚看到杨辉三角，我感觉我不可能写出来。看了下一章，以及一些评论，我决定试试。果然写出来了。","like_count":0},{"had_liked":false,"id":135028,"user_name":"saber","can_delete":false,"product_type":"c1","uid":1193468,"ip_address":"","ucode":"D02F8D129DB41C","user_header":"https://static001.geekbang.org/account/avatar/00/12/35/fc/6d3e0035.jpg","comment_is_top":false,"comment_ctime":1568981819,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568981819","product_id":100017301,"comment_content":"花费 2 天时间，终于把本节中除了杨辉三角形问题全部用 c++ 代码自己实现一遍。包括 0-1 背包（最大重量、最大价值）、双 11 购物。我觉得我写的代码更能够让初学者看懂。<br>本节中老师在最后打印了双 11 中对应最小价格需要购买哪些物品，我自己实现过程中，除了双 11 这个问题需要购买哪些物品，还实现了 0-1 背包问题需要购买哪些物品。有一点自创的是，我把满足条件的所有情况全部打印出来了，举个例子，也就是说，双 11 问题中对应 200 元这个问题，我把所有能够得到 200 元的物品组合全部通过回溯方法找出来了。<br>我的实现代码如下链接<br>https:&#47;&#47;github.com&#47;saber&#47;algorithm&#47;blob&#47;master&#47;src&#47;dynamic_programming&#47;dynamic_program.hpp<br>","like_count":0},{"had_liked":false,"id":133171,"user_name":"任重道远","can_delete":false,"product_type":"c1","uid":1325715,"ip_address":"","ucode":"BDA98B670E70D7","user_header":"https://static001.geekbang.org/account/avatar/00/14/3a/93/2d4f2988.jpg","comment_is_top":false,"comment_ctime":1568428617,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568428617","product_id":100017301,"comment_content":"解动态规划有啥好套路吗？比如迪杰斯特拉这种求最短路径，会一种了，其他的我都会了","like_count":0},{"had_liked":false,"id":132957,"user_name":"Jo","can_delete":false,"product_type":"c1","uid":1233748,"ip_address":"","ucode":"0EF4D66963C112","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/peVXJxibHW5xicV0o87BniaV31KSDaT9SibhQd1VH1lpgmwc77nezp81n3amCzjYhT5jOpw6sfOxXGajzyL1cZjeZw/132","comment_is_top":false,"comment_ctime":1568283705,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568283705","product_id":100017301,"comment_content":"杨辉三角动态规划实现思路，考虑到每一层元素都比上一层多1个，可以预先申请个长度等于最后一层元素个数的状态数组；逐层处理时，正好用上从后往前的思路，保证不会覆盖掉前面的状态。Golang实现如下：<br>package main<br>import &quot;fmt&quot;<br>func main() {<br>\ttri := [][]int{<br>\t\t{1},<br>\t\t{1, 2},<br>\t\t{6, 5, 2},<br>\t}<br>\tmin := pascalTriangle(tri)<br>\tfmt.Println(min)<br>}<br><br>func pascalTriangle(tri [][]int) (min int) {<br>\tif len(tri) == 0 || len(tri[0]) == 0 {<br>\t\treturn 0<br>\t}<br>\t&#47;&#47; 状态数组：每层比上一层多1个元素，处理是从后往前，正好不会覆盖掉前面的状态<br>\tstates := make([]int, len(tri[len(tri)-1]))<br>\tstates[0] = tri[0][0]<br><br>\tfor i := 1; i &lt; len(tri); i++ {<br>\t\tindex := len(tri[i]) - 1<br>\t\tfor j := index; j &gt;= 0; j-- { &#47;&#47; 注意：这里从后往前，每一层都比上一层多1个元素，保证不会覆盖上一层的状态<br>\t\t\tif j == index { &#47;&#47; 每行最后的节点<br>\t\t\t\tstates[j] = tri[i][j] + states[j-1]<br>\t\t\t} else if j == 0 { &#47;&#47; 每行第1个节点<br>\t\t\t\tstates[j] = tri[i][j] + states[j]<br>\t\t\t} else {<br>\t\t\t\tstates[j] = tri[i][j] + getMin(states[j], states[j-1])<br>\t\t\t}<br><br>\t\t\tif i == len(tri)-1 { &#47;&#47; 最后一行时，边处理就边计算最小值<br>\t\t\t\tif j == index {<br>\t\t\t\t\tmin = states[j]<br>\t\t\t\t} else {<br>\t\t\t\t\tmin = getMin(states[j], min)<br>\t\t\t\t}<br>\t\t\t}<br>\t\t}<br>\t}<br><br>\treturn min<br>}<br><br>func getMin(a, b int) int {<br>\tif a &gt; b {<br>\t\treturn b<br>\t} else {<br>\t\treturn a<br>\t}<br>}","like_count":0},{"had_liked":false,"id":129555,"user_name":"李冲","can_delete":false,"product_type":"c1","uid":1254530,"ip_address":"","ucode":"C8C12308B0FDDA","user_header":"https://static001.geekbang.org/account/avatar/00/13/24/82/b5808a60.jpg","comment_is_top":false,"comment_ctime":1567153618,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567153618","product_id":100017301,"comment_content":"对于思考题CanLin的看法有特色，自底向上更简洁<br><br>package main<br><br>import (<br>\t&quot;fmt&quot;<br>)<br><br>func min(x int, y int) int {<br>\tif x &lt; y {<br>\t\treturn x<br>\t} else {<br>\t\treturn y<br>\t}<br>}<br><br>func LevelSearch(matrix [][]int) int {<br>\tlevels := len(matrix)<br>\tfor level := levels - 1; level &gt; 0; level-- {<br>\t\tfor item := 0; item &lt; len(matrix[level])-1; item++ {<br>\t\t\tmatrix[level-1][item] += min(matrix[level][item], matrix[level][item+1])<br>\t\t}<br>\t}<br><br>\treturn matrix[0][0]<br>}<br><br>func main() {<br>\tfmt.Println(&quot;Welcome to the playground!&quot;)<br>\tmatrix := [][]int{<br>\t\t{5},<br>\t\t{7, 8},<br>\t\t{2, 3, 4},<br>\t\t{4, 9, 6, 1},<br>\t\t{2, 7, 9, 4, 5}}<br>\tfmt.Println(&quot;Search the shortest path via level, get result:&quot;, LevelSearch(matrix))<br>}","like_count":0},{"had_liked":false,"id":128924,"user_name":"Henry Liao","can_delete":false,"product_type":"c1","uid":1635174,"ip_address":"","ucode":"EA8407D15E2CC6","user_header":"https://static001.geekbang.org/account/avatar/00/18/f3/66/5d7ba082.jpg","comment_is_top":false,"comment_ctime":1566984571,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566984571","product_id":100017301,"comment_content":"用二叉树表示背包问题的地方，没说明左节点表示不放物品，右节点表示放物品，第一眼表示没看懂","like_count":0},{"had_liked":false,"id":122798,"user_name":"凉凉","can_delete":false,"product_type":"c1","uid":1325256,"ip_address":"","ucode":"FCCF976E41EF71","user_header":"https://static001.geekbang.org/account/avatar/00/14/38/c8/972a5024.jpg","comment_is_top":false,"comment_ctime":1565527806,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1565527806","product_id":100017301,"comment_content":"public static int knapsack2(int[] items, int n, int w) {<br>  boolean[] states = new boolean[w+1]; &#47;&#47; 默认值 false<br>  states[0] = true;  &#47;&#47; 第一行的数据要特殊处理，可以利用哨兵优化<br>  if (items[0] &lt;= w) {<br>    states[items[0]] = true;<br>  }<br>  for (int i = 1; i &lt; n; ++i) { &#47;&#47; 动态规划<br>    for (int j = w-items[i]; j &gt;= 0; --j) {&#47;&#47; 把第 i 个物品放入背包<br>      if (states[j]==true) states[j+items[i]] = true;<br>    }<br>  }<br>  for (int i = w; i &gt;= 0; --i) { &#47;&#47; 输出结果<br>    if (states[i] == true) return i;<br>  }<br>  return 0;<br>}<br><br>争哥啊，，后学晚辈问个问题，，用一维数组这个为啥只考虑把第 i 个物品放入背包，不放的情况为啥不用考虑，，搞不懂","like_count":0,"discussions":[{"author":{"id":1068361,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","nickname":"明翼","note":"","ucode":"E77F86BEB3D5C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":26533,"discussion_content":"我也觉得有问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570606683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122737,"user_name":"Geek_86533a","can_delete":false,"product_type":"c1","uid":1610333,"ip_address":"","ucode":"6961C429E8953A","user_header":"","comment_is_top":false,"comment_ctime":1565509559,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1565509559","product_id":100017301,"comment_content":"杨辉三角：<br>class Solution:<br>    def f(self, values, n):<br>        state = [[0]*n for _ in range(n)]<br>        state[0][0] = values[0][0]<br>        for i in range(1,n):<br>            for j in range(len(values[i])):<br>                if j == 0:<br>                    state[i][j] = state[i-1][j] + values[i][0]<br>                elif j == len(values[i]) - 1:<br>                    state[i][j] = state[i-1][j-1] + values[i][j]<br>                else:<br>                    state[i][j] = min(state[i-1][j-1], state[i-1][j]) + values[i][j]<br>        return min(state[n-1])","like_count":0,"discussions":[{"author":{"id":1108788,"avatar":"https://static001.geekbang.org/account/avatar/00/10/eb/34/cd310e69.jpg","nickname":"行走的","note":"","ucode":"04772A8A1FF2B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":44136,"discussion_content":"这个答案的运行结果应该是错误的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572934701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121563,"user_name":"青青子衿","can_delete":false,"product_type":"c1","uid":1438102,"ip_address":"","ucode":"4A388A3BA70C29","user_header":"https://static001.geekbang.org/account/avatar/00/15/f1/96/9571fa3d.jpg","comment_is_top":false,"comment_ctime":1565159232,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565159232","product_id":100017301,"comment_content":"好好学，不然要掉队","like_count":0},{"had_liked":false,"id":118519,"user_name":"古德150","can_delete":false,"product_type":"c1","uid":1435745,"ip_address":"","ucode":"05B3D7D96484C0","user_header":"https://static001.geekbang.org/account/avatar/00/15/e8/61/d3ab500c.jpg","comment_is_top":false,"comment_ctime":1564380085,"is_pvip":false,"replies":[{"id":"43667","content":"double的话，可以乘以一个10^k，转化成整数处理","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1564529972,"ip_address":"","comment_id":118519,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564380085","product_id":100017301,"comment_content":"老师我想问下关于01背包的问题，如果物品重量与背包可承受重量都不是整数，比如double类型的该如何解决呢？或者说有什么方法可以减少空间复杂度呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460439,"discussion_content":"double的话，可以乘以一个10^k，转化成整数处理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564529972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118284,"user_name":"高山仰止","can_delete":false,"product_type":"c1","uid":1190305,"ip_address":"","ucode":"8C2E839345E734","user_header":"https://static001.geekbang.org/account/avatar/00/12/29/a1/220b99b6.jpg","comment_is_top":false,"comment_ctime":1564309039,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564309039","product_id":100017301,"comment_content":"老师你好！个人觉得对于只要输出最终结果(即0-1背包问题)的最优解问题，DP状态数组的空间复杂度都可以优化成O(W)，而对于需要输出选择的商品(即双11购物问题)，DP状态数组的空间复杂度O(n*w)。","like_count":0},{"had_liked":false,"id":117978,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1564202644,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564202644","product_id":100017301,"comment_content":"这是一个递归问题，下面一层的只依赖于上一层的结果，可以按层扫描，每个元素是一个二选一的计算，然后加上自己就得出当前的最小路径。","like_count":0},{"had_liked":false,"id":113880,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1563178317,"is_pvip":false,"replies":[{"id":"41569","content":"因为超过w就没有意义了，因为我们背包只能放w重量","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1563232940,"ip_address":"","comment_id":113880,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563178317","product_id":100017301,"comment_content":"去掉重复状态后，为什么每一层的状态个数会不超过w呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458418,"discussion_content":"因为超过w就没有意义了，因为我们背包只能放w重量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563232940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113411,"user_name":"苦行僧","can_delete":false,"product_type":"c1","uid":1055334,"ip_address":"","ucode":"726024A9A9CF44","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/66/2d9db9ed.jpg","comment_is_top":false,"comment_ctime":1563000418,"is_pvip":false,"replies":[{"id":"41565","content":"可以去看下算法导论，有公式证明，比较复杂。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1563232576,"ip_address":"","comment_id":113411,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563000418","product_id":100017301,"comment_content":"如何验证动态规划的正确性","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458209,"discussion_content":"可以去看下算法导论，有公式证明，比较复杂。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563232576,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113340,"user_name":"Aaaaaaaaaaayou","can_delete":false,"product_type":"c1","uid":1073601,"ip_address":"","ucode":"67BA315B87587D","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/c1/93031a2a.jpg","comment_is_top":false,"comment_ctime":1562979987,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562979987","product_id":100017301,"comment_content":"课后习题应该需要一个三维数组来保存中间结果是吧","like_count":0},{"had_liked":false,"id":113253,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1562924756,"is_pvip":false,"replies":[{"id":"41566","content":"因为已经计算过了，所以就不需要再递归计算了。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1563232705,"ip_address":"","comment_id":113253,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562924756","product_id":100017301,"comment_content":"if (mem[i][cw]) return; &#47;&#47; 重复状态<br>直接return就代表从备记录中取出了，这里看得不太明白","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458133,"discussion_content":"因为已经计算过了，所以就不需要再递归计算了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563232705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111037,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1562427678,"is_pvip":false,"replies":[{"id":"40680","content":"实际上，你可以自己举一个例子，然后填一下表看下，就自然明白了。文字描述起来非常费劲呢。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1562632044,"ip_address":"","comment_id":111037,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1562427678","product_id":100017301,"comment_content":"前面强调第8行代码要从大到小（没有想明白），避免重复计算；后面同样情况为什么又采用了从小到大的方式呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457191,"discussion_content":"实际上，你可以自己举一个例子，然后填一下表看下，就自然明白了。文字描述起来非常费劲呢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562632044,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1112747,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","nickname":"李小四","note":"","ucode":"2A766BE16B276B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9409,"discussion_content":"班门弄斧一下，我也是看了几次才弄懂：从小到大处理，有这样一种可能：比如我们要遍历[0,1,2,3,4,5]这几个值，如果从小到大遍历，很可能遍历第0个会修改第2个的值，那么遍历到第二个的时候，就使用了修改过的值来计算，这样就出错了，从大到小不会有这个问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568166158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1189638,"avatar":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","nickname":"色即是空","note":"","ucode":"46B8975ED087B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":13517,"discussion_content":"只能说每一层优化都有具体的细节需求，精妙的算法+完美细节","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568683018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107342,"user_name":"吾爱有三","can_delete":false,"product_type":"c1","uid":1138007,"ip_address":"","ucode":"FC5B32E36CE249","user_header":"https://static001.geekbang.org/account/avatar/00/11/5d/57/82f1a3d4.jpg","comment_is_top":false,"comment_ctime":1561516580,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1561516580","product_id":100017301,"comment_content":"去掉重复状态后，为什么每一层的状态个数会不超过w呢？","like_count":0,"discussions":[{"author":{"id":1022247,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","nickname":"阿卡牛","note":"","ucode":"0BC43A904C3199","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2009,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563178279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106391,"user_name":"菜鸡程序员","can_delete":false,"product_type":"c1","uid":1308074,"ip_address":"","ucode":"F1DFEC2343FE25","user_header":"https://static001.geekbang.org/account/avatar/00/13/f5/aa/5d520017.jpg","comment_is_top":false,"comment_ctime":1561290035,"is_pvip":false,"replies":[{"id":"38634","content":"也可以的，你可以搜下dp+滚动数组。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1561419415,"ip_address":"","comment_id":106391,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561290035","product_id":100017301,"comment_content":"计算0-1背包总价值最大，是不是也可以使用一维int数组来存储价值，初始化也为-1。每次比较，将大的价值放进去，最后遍历。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455076,"discussion_content":"也可以的，你可以搜下dp+滚动数组。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561419415,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105888,"user_name":"杨升","can_delete":false,"product_type":"c1","uid":1451053,"ip_address":"","ucode":"51A0E6B58099A9","user_header":"https://static001.geekbang.org/account/avatar/00/16/24/2d/0e176c91.jpg","comment_is_top":false,"comment_ctime":1561099821,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561099821","product_id":100017301,"comment_content":"写一个C++的课后作业吧<br>#include&lt;iostream&gt;<br>using namespace std;<br><br>int matrix[5][5] = { { 5 },{ 7,8 },{ 2,3,4 },{ 4,9,6,1 },{ 2,7,9,4,5 } };<br><br>void main()<br>{<br>\tint status[5][8];<br>\tstatus[0][0] = 5;<br>\tfor (int i = 1;i &lt; 5;i++)<br>\t{<br>\t\tfor (int j = 0;j &lt;=i;j++)<br>\t\t{<br>\t\t\t\tif(j==0)<br>\t\t\t\t\tstatus[i][j] = status[i - 1][j] + matrix[i][j];<br>\t\t\t\telse if (j &gt; 0 &amp;&amp; j &lt; i)<br>\t\t\t\t{<br>\t\t\t\t\tint v = status[i - 1][j] + matrix[i][j];<br>\t\t\t\t\tint w = status[i - 1][j - 1] + matrix[i][j];<br>\t\t\t\t\tif (v &lt; w)<br>\t\t\t\t\t\tstatus[i][j] = v;<br>\t\t\t\t\telse<br>\t\t\t\t\t\tstatus[i][j] = w;<br>\t\t\t\t}<br>\t\t\t\telse if (j == i)<br>\t\t\t\t\tstatus[i][j] = status[i - 1][j - 1] + matrix[i][j];<br>\t\t}<br>\t}<br>\tint min = status[4][0];<br>\tfor (int w = 1;w &lt; 5;w++)<br>\t{<br>\t\tif (status[4][w] &lt; min)<br>\t\t\tmin = status[4][w];<br>\t}<br>\tcout &lt;&lt; min &lt;&lt; endl;<br>\tsystem(&quot;pause&quot;);<br>}<br>","like_count":0},{"had_liked":false,"id":104139,"user_name":"daniel","can_delete":false,"product_type":"c1","uid":1370456,"ip_address":"","ucode":"3516AF7F9A4DEA","user_header":"https://static001.geekbang.org/account/avatar/00/14/e9/58/397a4ab2.jpg","comment_is_top":false,"comment_ctime":1560663569,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560663569","product_id":100017301,"comment_content":"&#47;&#47;背包升级问题：使用一维数组解决，swift<br>&#47;&#47;重量<br>let weights = [2,2,4,6,3]<br>&#47;&#47;价值<br>let values = [3,4,8,9,6]<br>let n = 5<br>let w = 9<br>&#47;&#47;在满足背包重量的前提下，达到最大价值(注意以价值为准)<br>func maxValueWith1DArray()<br>{<br>    &#47;&#47;用-1表示没访问过的节点<br>    var status = [Int].init(repeating: -1, count: w+1)<br>    &#47;&#47;哨兵节点<br>    status[weights[0]] = values[0]<br>    status[0] = 0<br>    for i in 0..&lt;n {<br>        <br>        let k = w-weights[i]<br>        &#47;&#47;防止物品过重，使用w-goods[i]<br>        for j in 0...w-weights[i] {<br>            &#47;&#47;判断是否可以在此叠加物品<br>            if status[k-j] &gt;= 0<br>            {<br>                &#47;&#47;如果比原有价值大，就覆盖原有值<br>                if status[k-j] + values[i] &gt; status[k-j+weights[i]]<br>                {<br>                     status[k-j+weights[i]] = status[k-j] + values[i]<br>                }<br>            }<br>        }<br>    }<br>    &#47;&#47;这时候整个status的情况 [0, -1, 4, 6, 8, 10, 12, 14, 15, 18] -1表示没访问过,18是最大值并且可以装得下<br>    print(status.last)<br>}<br><br>maxValueWith1DArray()<br>","like_count":0},{"had_liked":false,"id":103903,"user_name":"daniel","can_delete":false,"product_type":"c1","uid":1370456,"ip_address":"","ucode":"3516AF7F9A4DEA","user_header":"https://static001.geekbang.org/account/avatar/00/14/e9/58/397a4ab2.jpg","comment_is_top":false,"comment_ctime":1560562182,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560562182","product_id":100017301,"comment_content":"Swift 三角形最短路径实现，从后往前走，省去比较多操作<br>func minimumTotal(_ triangle: [[Int]]) -&gt; Int {<br>    <br>    var tri = triangle<br>    <br>    for i in 0..&lt;triangle.count-1 {<br>        var j = triangle.count - 2<br>        <br>        j -= i<br>        <br>        for k in 0..&lt;triangle[j].count<br>        {<br>            tri[j][k] += min(tri[j+1][k], tri[j+1][k+1])<br>        }<br>    }<br>    <br>    return tri[0][0]<br>    <br>}<br><br>minimumTotal(<br>[<br>[2],<br>[3,4],<br>[6,5,7],<br>[4,1,8,3]<br>])","like_count":0},{"had_liked":false,"id":99407,"user_name":"张伯毅","can_delete":false,"product_type":"c1","uid":1099929,"ip_address":"","ucode":"E9EAF5ECFE32C7","user_header":"https://static001.geekbang.org/account/avatar/00/10/c8/99/22d2a6a7.jpg","comment_is_top":false,"comment_ctime":1559208325,"is_pvip":false,"replies":[{"id":"35861","content":"是第8行，不好意思，因为中间改过一次代码。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559352787,"ip_address":"","comment_id":99407,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559208325","product_id":100017301,"comment_content":"这里我特别强调一下代码中的第 6 行，j 需要从大到小来处理。如果我们按照 j 从小到大处理的话，会出现 for 循环重复计算的问题。你可以自己想一想，这里我就不详细说了。<br><br><br>这个应该是第 8 行吧","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452095,"discussion_content":"是第8行，不好意思，因为中间改过一次代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559352787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96929,"user_name":"么么","can_delete":false,"product_type":"c1","uid":1391251,"ip_address":"","ucode":"1424F9F71F2452","user_header":"https://static001.geekbang.org/account/avatar/00/15/3a/93/56a99549.jpg","comment_is_top":false,"comment_ctime":1558537835,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558537835","product_id":100017301,"comment_content":"课后思考提go语言的实现：<br><br>func getMinValue(items [][]int, n int) int {<br>\t&#47;&#47; 初始化 备忘录<br>\tstates := make([][]int, n)<br>\tfor i := range states {<br>\t\tstates[i] = make([]int, i+1)<br>\t}<br><br>\tfor i := range states {<br>\t\tfor j := range states[i] {<br>\t\t\tstates[i][j] = math.MaxInt16<br>\t\t}<br>\t}<br><br>\t&#47;&#47; 初始化第一层的状态<br>\tstates[0][0] = items[0][0]<br><br>\tfor i := 1; i &lt; n; i++ {<br>\t\tfor j := 0; j &lt;= i; j++ { &#47;&#47; 遍历每一层<br>\t\t\t&#47;&#47; 取左上角的值<br>\t\t\tif j-1 &gt;= 0 {<br>\t\t\t\tstates[i][j] = states[i-1][j-1] + items[i][j]<br>\t\t\t}<br>\t\t\t&#47;&#47; 取正上方的值<br>\t\t\tif j &lt; i {<br>\t\t\t\ttv := states[i-1][j] + items[i][j] &#47;&#47; 比较左上角和右上角的值谁更小<br>\t\t\t\tif tv &lt; states[i][j] {<br>\t\t\t\t\tstates[i][j] = tv<br>\t\t\t\t}<br>\t\t\t}<br>\t\t}<br>\t}<br><br>\t&#47;&#47; 获取最底层的最小值就是结果<br>\tminV := math.MaxInt16<br>\tfor i := 0; i &lt; n; i++ {<br>\t\tif states[n-1][i] &lt; minV {<br>\t\t\tminV = states[n-1][i]<br>\t\t}<br>\t}<br><br>\treturn minV<br>}<br><br>var (<br>\titems = [][]int{{5}, {7, 8}, {2, 3, 4}, {4, 9, 6, 1}, {2, 7, 9, 4, 5}}<br>\tn     = 5<br>)<br><br>func Test_triangle(t *testing.T) {<br>\tminV := getMinValue(items, n)<br>\tt.Log(minV)<br>}<br><br><br>主要是确定状态转化方程： f(i, j, w) = min(f(i-1, j-1, w), f(i-1, j, w)) + weight(i, j)，就是说某一个点的值，只会被两个依赖影响，即，左上角（i-1, j-1）的值，和正上方(i-1, j)这两个值，这里需要判断是否存在这两个节点，通过取这两个点的较小值然后加上当前节点的权重就可以了。","like_count":0},{"had_liked":false,"id":95524,"user_name":"小黄鸡","can_delete":false,"product_type":"c1","uid":1052618,"ip_address":"","ucode":"9497430EB4CDAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/0f/ca/532d8e8e.jpg","comment_is_top":false,"comment_ctime":1558076047,"is_pvip":false,"replies":[{"id":"34387","content":"文章中有解答呀的，看最后一个代码","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1558338985,"ip_address":"","comment_id":95524,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558076047","product_id":100017301,"comment_content":"对于上面矩阵图解4个物品，背包不能超重9公斤。我们怎么去求正好等于9的所有物品路径呢？栈的思路？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450496,"discussion_content":"文章中有解答呀的，看最后一个代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558338985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94947,"user_name":"天下行走","can_delete":false,"product_type":"c1","uid":1462449,"ip_address":"","ucode":"73A4CD8BB91235","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLfrbMvhKQYhxP6ziaHaj4KUNRzst8u7BZsWUsazK8oTLXcNH6sDGITl6icy3IiaGFe9Iiae12LuTrF1g/132","comment_is_top":false,"comment_ctime":1557927733,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557927733","product_id":100017301,"comment_content":"思考题这个用常规递归求解是不是更好理解","like_count":0},{"had_liked":false,"id":92830,"user_name":"liubin","can_delete":false,"product_type":"c1","uid":1211347,"ip_address":"","ucode":"C6D3AD396C3678","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/d3/dc56895b.jpg","comment_is_top":false,"comment_ctime":1557333147,"is_pvip":false,"replies":[{"id":"33866","content":"是的，都可以，假设成多少都行","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1557882550,"ip_address":"","comment_id":92830,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557333147","product_id":100017301,"comment_content":"争哥，文章中解答开篇部分这句话“我们可以限定 x 值为 1001”，在代码中j的阈值不是3*w吗？这句话的1001应该是601吧？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449395,"discussion_content":"是的，都可以，假设成多少都行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557882550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90283,"user_name":"蔡雪钧","can_delete":false,"product_type":"c1","uid":1206104,"ip_address":"","ucode":"87875F639999F0","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/58/960b71b7.jpg","comment_is_top":false,"comment_ctime":1556465931,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1556465931","product_id":100017301,"comment_content":"leetcode 120, 上来就是 medium 级别的...","like_count":0},{"had_liked":false,"id":88803,"user_name":"南北少卿","can_delete":false,"product_type":"c1","uid":1018958,"ip_address":"","ucode":"DFCC59F2BBD8CE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/4e/b81969fa.jpg","comment_is_top":false,"comment_ctime":1556003821,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556003821","product_id":100017301,"comment_content":"f(i+1, cw); &#47;&#47; 选择不装第 i 个物品<br>这个怎么都想不明白啊?","like_count":0},{"had_liked":false,"id":88247,"user_name":"小新村小学扛霸子","can_delete":false,"product_type":"c1","uid":1250309,"ip_address":"","ucode":"BECFAB70A68C9F","user_header":"https://static001.geekbang.org/account/avatar/00/13/14/05/5f46ffa6.jpg","comment_is_top":false,"comment_ctime":1555901212,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555901212","product_id":100017301,"comment_content":" &#47;&#47;杨辉三角<br>    public static void yanghui(int[][] w, int n){<br>        int[][] states = new int[n][n];<br>        states[0][0] = w[0][0];<br>        for (int i=1; i&lt;n; i++){<br>            states[i][0] =  states[i-1][0] + w[i][0];<br>        }<br>        for (int i=1; i&lt;n; i++){<br>            for (int j=1; j&lt;=i; j++){<br>                if (i==j)  states[i][j] = states[i-1][j-1] + w[i][j];<br>                else  states[i][j] = w[i][j] + Math.min(states[i-1][j-1],states[i-1][j]);<br>            }<br>        }<br>        int minDist = Integer.MAX_VALUE;<br>        for (int j=0; j&lt;n; j++){<br>            if(states[n-1][j] &lt; minDist)  minDist = states[n-1][j];<br>        }<br>        System.out.println(minDist);<br>    }<br><br>    public static void main(String[] args) {<br>        int[][] w = {{5},{7,8},{7,3,4},{4,9,6,1},{2,7,9,4,5}};<br>        yanghui(w,w.length);<br>    }","like_count":0},{"had_liked":false,"id":87861,"user_name":"小新村小学扛霸子","can_delete":false,"product_type":"c1","uid":1250309,"ip_address":"","ucode":"BECFAB70A68C9F","user_header":"https://static001.geekbang.org/account/avatar/00/13/14/05/5f46ffa6.jpg","comment_is_top":false,"comment_ctime":1555735326,"is_pvip":false,"replies":[{"id":"31651","content":"我看也没问题","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1555804861,"ip_address":"","comment_id":87861,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555735326","product_id":100017301,"comment_content":" for (int i=1; i&lt;n; i++){<br>            for (int j=0; j&lt;=w; j++){<br>                if (states[i-1][j]) {<br>                    states[i][j] = true;   &#47;&#47;不装进背包<br>                    if (j+items[i]&lt;=w) states[i][j+items[i]] = true;  &#47;&#47;装进背包<br>                }<br>            }<br>        }<br>老师能说说为什么装进背包和不装进背包不能防在一起吗，看了半天没发现这样有什么问题啊。。。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447627,"discussion_content":"我看也没问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555804861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87762,"user_name":"小新村小学扛霸子","can_delete":false,"product_type":"c1","uid":1250309,"ip_address":"","ucode":"BECFAB70A68C9F","user_header":"https://static001.geekbang.org/account/avatar/00/13/14/05/5f46ffa6.jpg","comment_is_top":false,"comment_ctime":1555685465,"is_pvip":false,"replies":[{"id":"31591","content":"不好放一块","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1555717899,"ip_address":"","comment_id":87762,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555685465","product_id":100017301,"comment_content":"放背包和不放背包写在一个for循环里可以吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447589,"discussion_content":"不好放一块","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555717899,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87155,"user_name":"朱东旭","can_delete":false,"product_type":"c1","uid":1242338,"ip_address":"","ucode":"C48DD620A63868","user_header":"https://static001.geekbang.org/account/avatar/00/12/f4/e2/dbc4a5f2.jpg","comment_is_top":false,"comment_ctime":1555518385,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555518385","product_id":100017301,"comment_content":"帮女朋友购物问题很可能有多个最优解，这里只能打印出一个最优解。","like_count":0},{"had_liked":false,"id":85780,"user_name":"风雪夜归人","can_delete":false,"product_type":"c1","uid":1440527,"ip_address":"","ucode":"7F611C3D9FD951","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q79HDNx5mGo5Wr4ibCr4yeGlnrBWNTTiaUTVCt4uoFNPO45BZY8ngZ9vAhIwzWXregNe09Ca8C5cibu471CcxS8mw/132","comment_is_top":false,"comment_ctime":1555230996,"is_pvip":false,"replies":[{"id":"31005","content":"mem[i][cw]本身存储的是这个状态是否是可达的，true表示可达，已经计算过了。cw本身就表示当前状态背包中的物品总重量，所以不需要返回什么值的。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1555380123,"ip_address":"","comment_id":85780,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1555230996","product_id":100017301,"comment_content":"在文中说回溯法时，记录已经计算好的 f(i, cw)，当再次计算到重复的 f(i, cw) 的时候，可以直接从备忘录中取出来用，但是在代码中mem[i][cw] 为true时，直接return，没有返回任何值，请问这是为啥，<br><br><br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446807,"discussion_content":"mem[i][cw]本身存储的是这个状态是否是可达的，true表示可达，已经计算过了。cw本身就表示当前状态背包中的物品总重量，所以不需要返回什么值的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555380123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1661456,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epYAmnyHBCVY7YicTF3IXa39mvVTuyum9yicPyFG5amXuo6R2QOTicX0iaXLicH8CTktC7XHruv81ichgkg/132","nickname":"Geek_b25f99","note":"","ucode":"6F7BEAB2C31528","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72750,"discussion_content":"重复状态，选择一个就好，所以遇到重复状态了，直接return结束这个状态的路线，不需要返回啥值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575523724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83117,"user_name":"子夜2104","can_delete":false,"product_type":"c1","uid":1070286,"ip_address":"","ucode":"C4FF54AEA6002F","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/ce/92029d2f.jpg","comment_is_top":false,"comment_ctime":1554429578,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554429578","product_id":100017301,"comment_content":"老师讲的动态规划真是精彩！<br>一步一步推导，能知道每一步为什么这么做，特别是先自己手动写一遍，然后翻译成代码，这种方式又让人回到了，当初解数学题的感觉，哈哈哈","like_count":0},{"had_liked":false,"id":81278,"user_name":"草长莺飞","can_delete":false,"product_type":"c1","uid":1243108,"ip_address":"","ucode":"7A281E8DB11BBB","user_header":"https://static001.geekbang.org/account/avatar/00/12/f7/e4/c8cfca11.jpg","comment_is_top":false,"comment_ctime":1553847948,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553847948","product_id":100017301,"comment_content":"&#47;**<br> * @author caopengflying<br> * @time 2019&#47;3&#47;29 15:23<br> * @descprit 01背包问题<br> * 一个背包最大容纳重量为9kg<br> * 现在有5个物品物品的重量一次为2,2,4,6,3，<br> * 请问这个包能装这些物品的最大重量是多少<br> *<br> *&#47;<br><br>public class OneAndTwoPackage {<br>    public static int WEIGHT_MAX = 20;&#47;&#47;最大重量<br><br>    public static void main(String[] args) {<br>        int[] weightList = {7,2,3,6,1}; &#47;&#47;每个物品的重量<br>        dynamicPlan(weightList, 5);<br>    }<br>    &#47;**<br>     *<br>     * @param weightList  物品重量<br>     * @param num 物品个数<br>     * @return<br>     *&#47;<br>    public static int dynamicPlan(int[] weightList, int num){<br>        &#47;&#47;解决这个问题的思路就是<br>        &#47;**<br>         * 每个物品都有两种选择，后一种基于前一种的可能会有更多的选择，将所有的可能列举并记录总重量<br>         * 第一个 有两种可能  放 总重量为2 不放为0<br>         * 第二个 有三种可能 放 2,4  不放0,2 总共为0,2,4<br>         * 第三个  有5种可能         放 4,6,8 不放 0,2,4<br>         *&#47;<br>        boolean[][] weightFlag = new boolean[num][WEIGHT_MAX+1];&#47;&#47;初始化所有的标记默认为false<br>        weightFlag[0][0] = true;<br>        for (int i = 0; i &lt; num; i++) {<br>            &#47;&#47;寻找上一层可能，如果是第一层则将放置该物品的下标设置为true<br>            &#47;&#47;如果不是第一层，则将该层已经设置为true的下标设为true 并把值取出与上一层的位置加和设置为true<br>            if (0 &lt;= i-1){<br>                boolean[] preWeight = weightFlag[i-1];<br>                for (int i1 = 0; i1 &lt; WEIGHT_MAX; i1++) {<br>                    if (preWeight[i1]){<br>                        &#47;&#47;不放<br>                        weightFlag[i][i1] = true;<br>                        &#47;&#47;放<br>                        int weight = weightList[i] + i1;<br>                        if (weight &lt;= WEIGHT_MAX)<br>                        weightFlag[i][weight] = true;<br>                    }<br>                }<br>            }else {<br>                weightFlag[i][weightList[i]] = true;<br>            }<br>        }<br>        &#47;&#47;最后一层，的最大值即为最大重量<br>            for (int j = WEIGHT_MAX; j &gt;=0 ; j--) {<br>                if (weightFlag[num-1][j]){<br>                   return j;<br>                }<br>        }<br>        return 0;<br>    }<br>}","like_count":0},{"had_liked":false,"id":78915,"user_name":"cc","can_delete":false,"product_type":"c1","uid":1239833,"ip_address":"","ucode":"AA1B8EA613E3A9","user_header":"https://static001.geekbang.org/account/avatar/00/12/eb/19/19e706a5.jpg","comment_is_top":false,"comment_ctime":1553297483,"is_pvip":false,"replies":[{"id":"28850","content":"👍 我改下 多谢","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1553386848,"ip_address":"","comment_id":78915,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553297483","product_id":100017301,"comment_content":"states[items[0]] = true;<br><br>老师，上面的代码可能不够严谨，需要做下逻辑加固  <br>if(items[0]] &lt;= w){<br>    states[items[0]] = true;<br>}","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444287,"discussion_content":"👍 我改下 多谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553386848,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78466,"user_name":"百分之99","can_delete":false,"product_type":"c1","uid":1357867,"ip_address":"","ucode":"3075C948F5F2DC","user_header":"","comment_is_top":false,"comment_ctime":1553154550,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553154550","product_id":100017301,"comment_content":"动态规划不错，就是最后把终极选择的一一列举，这一步有没有办法简化到以前的过程中呢？","like_count":0},{"had_liked":false,"id":78073,"user_name":"风雪夜归人","can_delete":false,"product_type":"c1","uid":1440527,"ip_address":"","ucode":"7F611C3D9FD951","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q79HDNx5mGo5Wr4ibCr4yeGlnrBWNTTiaUTVCt4uoFNPO45BZY8ngZ9vAhIwzWXregNe09Ca8C5cibu471CcxS8mw/132","comment_is_top":false,"comment_ctime":1553067269,"is_pvip":false,"replies":[{"id":"28477","content":"要用个数组记录下","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1553072334,"ip_address":"","comment_id":78073,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553067269","product_id":100017301,"comment_content":"老师，回溯法怎么才能找出是哪几个值组成了最大值呢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443958,"discussion_content":"要用个数组记录下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553072334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77032,"user_name":"猪猪男孩","can_delete":false,"product_type":"c1","uid":1461246,"ip_address":"","ucode":"E853E29182C6B5","user_header":"https://static001.geekbang.org/account/avatar/00/16/4b/fe/048ad222.jpg","comment_is_top":false,"comment_ctime":1552811313,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552811313","product_id":100017301,"comment_content":"def minPath(nums):<br>    if not nums:<br>        return 0<br>    n = len(nums)<br>    f1 = nums[n-1]<br>    i = n-2<br>    while i &gt;= 0:<br>        f2 = []<br>        for j in range(len(f1)-1):<br>            f2.append(min(f1[j],f1[j+1]))<br>        <br>        f1 = []<br>        for j in range(len(f2)):<br>            f1.append(nums[i][j]+f2[j])<br>        i -= 1<br>    return f1[0]<br><br>nums = \\<br>[<br>[1],<br>[3,2],<br>[6,5,4],<br>[10,9,8,7],<br>[15,14,13,12,11]<br>]<br>不知道对不对","like_count":0},{"had_liked":false,"id":76836,"user_name":"天二","can_delete":false,"product_type":"c1","uid":1100092,"ip_address":"","ucode":"F03EF223F2A4AE","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/3c/7d9b3baa.jpg","comment_is_top":false,"comment_ctime":1552723375,"is_pvip":false,"replies":[{"id":"28116","content":"👍 可以的。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1552875371,"ip_address":"","comment_id":76836,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552723375","product_id":100017301,"comment_content":"老师 薅羊毛的问题 输出代码可以是下面的吗？<br>    for (int i = n - 1; i &gt;= 1; --i) { &#47;&#47; i 表示二维数组中的行，j 表示列<br>            if (j &gt;= 0 &amp;&amp; states[i][j] == true) {<br>                System.out.print(items[i] + &quot; &quot;); &#47;&#47; 购买这个商品<br>                j = j - items[i];<br>            } &#47;&#47; else 没有购买这个商品，j 不变。<br>        }<br>就是直接判断(i,j)是不是true，然后决定是否输出","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443462,"discussion_content":"👍 可以的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552875371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76281,"user_name":"xuery","can_delete":false,"product_type":"c1","uid":1027584,"ip_address":"","ucode":"F461B61BE06131","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/00/025f37e7.jpg","comment_is_top":false,"comment_ctime":1552566321,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1552566321","product_id":100017301,"comment_content":"每一题都自己动手写一遍，会有不一样的收获","like_count":0},{"had_liked":false,"id":73846,"user_name":"Tesnado","can_delete":false,"product_type":"c1","uid":1251931,"ip_address":"","ucode":"44F015D8C63621","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/O6qftWBakkgFQYYlYgToU6HZOLawOFM2ynIQwMfRvX5620GYG9kFTys6dBdXIiazicovWBGG57NhFuctlaH97Lbg/132","comment_is_top":false,"comment_ctime":1552014945,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552014945","product_id":100017301,"comment_content":"旋转一下当成矩阵，然后d(i,j)=min(d(i-1,j),d(i,j-1))。当然，边界要另外判断处理下。","like_count":0},{"had_liked":false,"id":73673,"user_name":"淤白","can_delete":false,"product_type":"c1","uid":1206503,"ip_address":"","ucode":"D1E65DC40DAF68","user_header":"https://static001.geekbang.org/account/avatar/00/12/68/e7/ee47d0e2.jpg","comment_is_top":false,"comment_ctime":1551954704,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551954704","product_id":100017301,"comment_content":"慢慢跟进度，发个课后习题：<br>\tint h = 5;<br>\tint[][] nums = {{5},{7,8},{2,3,4},{4,9,6,1},{2,7,9,4,5}};<br>\tpublic int minValue() {<br>\t\tint[][] sums = new int[h][h];<br>\t\tsums[0][0] = nums[0][0];<br>\t\tfor (int i = 1; i &lt; h; i++) {<br>\t\t\tfor (int j = 0; j &lt; i; j++) {<br>\t\t\t\tint tmp = sums[i-1][j] + nums[i][j];<br>\t\t\t\tif (sums[i][j] &gt; 0) {<br>\t\t\t\t\tsums[i][j] = Math.min(tmp, sums[i][j]);<br>\t\t\t\t} else {<br>\t\t\t\t\tsums[i][j] = tmp;<br>\t\t\t\t}<br>\t\t\t\t<br>\t\t\t\ttmp = sums[i-1][j] + nums[i][j+1];<br>\t\t\t\tif (sums[i][j+1] &gt; 0) {<br>\t\t\t\t\tsums[i][j+1] = Math.min(tmp, sums[i][j+1]);<br>\t\t\t\t} else {<br>\t\t\t\t\tsums[i][j+1] = tmp;<br>\t\t\t\t}<br>\t\t\t}<br>\t\t}<br>\t\t<br>\t\tint min = Integer.MAX_VALUE;<br>\t\tfor (int i = 0; i &lt; h; i++) {<br>\t\t\tmin = Math.min(min, sums[h-1][i]);<br>\t\t}<br>\t\tSystem.err.println(min);<br>\t\treturn min;<br>\t}","like_count":0},{"had_liked":false,"id":73114,"user_name":"随便写","can_delete":false,"product_type":"c1","uid":1358659,"ip_address":"","ucode":"16551CCDB0D71A","user_header":"https://static001.geekbang.org/account/avatar/00/14/bb/43/0fde5e26.jpg","comment_is_top":false,"comment_ctime":1551800891,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551800891","product_id":100017301,"comment_content":"杨辉三角解法：<br>public static int yangTriangle(int [][]yang){<br>        int minValue = Integer.MAX_VALUE;<br>        int length = yang.length;<br>        int [][]states = new int[length][length];<br>        for (int i = 0; i &lt; length; i++) {<br>            for (int j = 0; j &lt; length ; j++) {<br>                states[i][j] = Integer.MAX_VALUE;<br>            }<br>        }<br>        states[0][0] = yang[0][0];<br>        for (int i = 1; i &lt; length; i++) {<br>            for (int j = i; j &gt;= 0; j--) {<br>                if (states[i-1][j] &lt; Integer.MAX_VALUE){<br>                    int min = states[i-1][j] + yang[i][j];<br>                    if (min &lt; states[i][j]){<br>                        states[i][j] = min;<br>                    }<br>                }<br><br>            }<br>            for (int j = i-1; j &gt;= 0; j--) {<br>                if (states[i-1][j] &lt; Integer.MAX_VALUE){<br>                    int min = states[i-1][j] + yang[i][j+1];<br>                    if (min &lt; states[i][j+1]){<br>                        states[i][j+1] = min;<br>                    }<br>                }<br>            }<br>        }<br>        for (int i = length-1; i &gt;= 0 ; i--) {<br>            if (minValue &gt; states[length-1][i]){<br>                minValue = states[length-1][i];<br>            }<br>        }<br>        return minValue;<br>    }","like_count":0},{"had_liked":false,"id":72917,"user_name":"increasingly","can_delete":false,"product_type":"c1","uid":1261809,"ip_address":"","ucode":"B12C734C736F79","user_header":"","comment_is_top":false,"comment_ctime":1551754811,"is_pvip":false,"replies":[{"id":"26806","content":"是的，稍后改正一下，抱歉啊","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551925962,"ip_address":"","comment_id":72917,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551754811","product_id":100017301,"comment_content":"请问老师，解答开篇代码的第19行，j等于-1说明没有可行解，可是，j不可能等于-1啊，不应该是j==3*w+1吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441827,"discussion_content":"是的，稍后改正一下，抱歉啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551925962,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72733,"user_name":"且听疯吟","can_delete":false,"product_type":"c1","uid":1159459,"ip_address":"","ucode":"B010B16E5465F4","user_header":"https://static001.geekbang.org/account/avatar/00/11/b1/23/5df1f341.jpg","comment_is_top":false,"comment_ctime":1551707166,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551707166","product_id":100017301,"comment_content":"动态规划的核心是找出递推公式，所有的动态规划基本上都这套路，但是核心在于怎么想办法找出递推公式，代码实现倒是不太难。","like_count":0},{"had_liked":false,"id":72569,"user_name":"菜菜","can_delete":false,"product_type":"c1","uid":1243536,"ip_address":"","ucode":"888AC33663B774","user_header":"https://static001.geekbang.org/account/avatar/00/12/f9/90/f90903e5.jpg","comment_is_top":false,"comment_ctime":1551669111,"is_pvip":false,"replies":[{"id":"26800","content":"是的，写错了，我改下，抱歉啊","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551924745,"ip_address":"","comment_id":72569,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551669111","product_id":100017301,"comment_content":"解答开篇代码的第19行，j等于-1说明没有可行解，可是，j不可能等于-1啊，应该是j==3*w+1吧？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441642,"discussion_content":"是的，写错了，我改下，抱歉啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551924745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":67337,"user_name":"随风","can_delete":false,"product_type":"c1","uid":1250040,"ip_address":"","ucode":"2883C362D6C2B4","user_header":"https://static001.geekbang.org/account/avatar/00/13/12/f8/888a9b9d.jpg","comment_is_top":false,"comment_ctime":1550132192,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550132192","product_id":100017301,"comment_content":"思考题实现(用的是下节讲到的状态转移方程）<br>public class DynYHTriangle {<br><br>\tprivate static int [][] trangle1 = {<br>             {5},<br>           {7 , 8},<br>         {2,  3,  4},<br>       {4,  9,  6, 1},<br>     {2  ,7,  9,  4, 5}<br>\t};<br>\tprivate static int minPath = Integer.MAX_VALUE;<br>\tpublic static void getMinPath(int trangle[][], int level) {<br>\t\tstep(1, trangle[0][0], 0, trangle, level);<br>\t}<br>\t&#47;**<br>\t * <br>\t * @param curStep  阶段<br>\t * @param curPath  当前阶段进过的值<br>\t * @param n        从上一层的第几个过来的<br>\t * @param trangle  三角数组<br>\t * @param level    三角层数<br>\t *&#47;<br>\tpublic static void step(int curStep, int curPath , int n,int trangle[][], int level) {<br>\t\tif(level == curStep) {<br>\t\t\tminPath = Math.min(minPath, curPath);<br>\t\t\treturn;<br>\t\t}<br>\t\tstep(curStep+1, curPath+(trangle[curStep][n]), n, trangle, level);<br>\t\tstep(curStep+1, curPath+(trangle[curStep][n+1]), n+1, trangle, level);<br>\t}<br>\t<br>\tpublic static void main(String arg[]) {<br>\t\tgetMinPath(trangle1, 3);<br>\t\tSystem.out.println(minPath);<br>\t}<br>}","like_count":0},{"had_liked":false,"id":67310,"user_name":"Max","can_delete":false,"product_type":"c1","uid":1004825,"ip_address":"","ucode":"B0B928CF0D6AFF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/19/673d0a17.jpg","comment_is_top":false,"comment_ctime":1550128503,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550128503","product_id":100017301,"comment_content":"背包一维数组里面states[items[0]] = true是默认第一个元素也就是第一个物品放进去吗","like_count":0},{"had_liked":false,"id":67256,"user_name":"花仙子","can_delete":false,"product_type":"c1","uid":1249216,"ip_address":"","ucode":"9840BF416F1F0F","user_header":"https://static001.geekbang.org/account/avatar/00/13/0f/c0/e6151cce.jpg","comment_is_top":false,"comment_ctime":1550115985,"is_pvip":false,"replies":[{"id":"25404","content":"可以的，就是不能用滚动数组那种节省空间的实现方法了。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551232661,"ip_address":"","comment_id":67256,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1550115985","product_id":100017301,"comment_content":"老师，我想用个背包记录最终的选择情况，这种动态规划能记录吗？我试了一下好像不行","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439117,"discussion_content":"可以的，就是不能用滚动数组那种节省空间的实现方法了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551232661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":66096,"user_name":"freesia","can_delete":false,"product_type":"c1","uid":1207824,"ip_address":"","ucode":"FC37B0B796958E","user_header":"https://static001.geekbang.org/account/avatar/00/12/6e/10/05f19719.jpg","comment_is_top":false,"comment_ctime":1549876810,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549876810","product_id":100017301,"comment_content":"升级版的背包问题，用回溯法加记事本也可以解决吧？记事本里记录最大值就可以，每一步决策前看一下记事本，如果小于记录的最大值了就放弃后续决策，如果大于就更新记事本，继续当前决策。","like_count":0},{"had_liked":false,"id":64759,"user_name":"李靖峰","can_delete":false,"product_type":"c1","uid":1139247,"ip_address":"","ucode":"AA4DE3E91A1FFA","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/2f/6fe8ee9e.jpg","comment_is_top":false,"comment_ctime":1548901807,"is_pvip":false,"replies":[{"id":"24638","content":"你说的没错。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550728178,"ip_address":"","comment_id":64759,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1548901807","product_id":100017301,"comment_content":"老师，如果需要倒推购买的商品，是不是就无法通过一维数组优化空间复杂度了","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438164,"discussion_content":"你说的没错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550728178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64179,"user_name":"王者归来","can_delete":false,"product_type":"c1","uid":1349051,"ip_address":"","ucode":"7518431E647410","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Dyic3CxSFwI4wsNTia2UzqaQL2pENLp8rRkNgBaCzr82BSMibegfnfYQbTCYOMXicZymXAqIk8zf1neUFeicmyxnFXw/132","comment_is_top":false,"comment_ctime":1548686348,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548686348","product_id":100017301,"comment_content":"递归执行过程真是烧脑，还是动态规划合适人思维","like_count":0},{"had_liked":false,"id":59596,"user_name":"猫头鹰爱拿铁","can_delete":false,"product_type":"c1","uid":1105958,"ip_address":"","ucode":"24266B58968428","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/26/4942a09e.jpg","comment_is_top":false,"comment_ctime":1547390798,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1547390798","product_id":100017301,"comment_content":"看了10多天的动态规划，开始觉得特别难，后来把老师的例子都好好写了几遍，习题做了几遍，应该算是入门了。交个迟来的作业。<br>public int shortestPathLength(int[][] triangle) {<br>\t\tint minDist = Integer.MAX_VALUE;<br>\t\tint[][] result = new int[triangle.length][triangle.length];<br>\t\tresult[0][0] = triangle[0][0];<br>\t\tfor (int i = 1; i &lt; triangle.length; i++) {<br>\t\t\tresult[i][0] = result[i - 1][0] + triangle[i][0];<br>\t\t\tresult[i][i] = result[i - 1][i - 1] + triangle[i][i];<br>\t\t\tfor (int k = 1; k &lt; i; k++) {<br>\t\t\t\tresult[i][k] = Math.min(result[i - 1][k - 1], result[i - 1][k])<br>\t\t\t\t\t\t+ triangle[i][k];<br>\t\t\t}<br>\t\t}<br>\t\tint lastRow = triangle.length - 1;<br>\t\tfor (int j = 0; j &lt;= lastRow; j++) {<br>\t\t\tif (minDist &gt; result[lastRow][j]) {<br>\t\t\t\tminDist = result[lastRow][j];<br>\t\t\t}<br>\t\t}<br>\t\treturn minDist;<br>\t}","like_count":0},{"had_liked":false,"id":59193,"user_name":"Alexis何春光","can_delete":false,"product_type":"c1","uid":1181149,"ip_address":"","ucode":"614570FAE3B56A","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/dd/b201cf13.jpg","comment_is_top":false,"comment_ctime":1547321468,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547321468","product_id":100017301,"comment_content":"到算法阶段感觉就变难了。。。。","like_count":0},{"had_liked":false,"id":58285,"user_name":"馒头","can_delete":false,"product_type":"c1","uid":1137876,"ip_address":"","ucode":"01864DBAAC54A5","user_header":"https://static001.geekbang.org/account/avatar/00/11/5c/d4/56b687c5.jpg","comment_is_top":false,"comment_ctime":1547026717,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547026717","product_id":100017301,"comment_content":"三角问题：<br>结构我当成一个链表俩来看，只能去下面，我看成左或者右。<br>决策就是 next 的左右选择，最后返回总路程，然后跟minvalue做对比，留下小的。<br>不知道对不对。","like_count":0},{"had_liked":false,"id":58145,"user_name":"郝大全","can_delete":false,"product_type":"c1","uid":1064678,"ip_address":"","ucode":"9351DC6E18DDE4","user_header":"https://static001.geekbang.org/account/avatar/00/10/3e/e6/3c35f6d9.jpg","comment_is_top":false,"comment_ctime":1547002251,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547002251","product_id":100017301,"comment_content":"照着老师的图跟着又默画了一遍，代码又默敲了一遍，发现一个小问题：<br>老师的代码是不是没有考虑边界问题？<br>例如背包问题最后一段代码，<br>如果items := [3,2,1,6] n=4, w=1,会报错的。<br><br>动态规划三篇文章快学了一周了，还是有点小迷糊....<br><br><br><br>","like_count":0},{"had_liked":false,"id":57894,"user_name":"辰陌","can_delete":false,"product_type":"c1","uid":1245043,"ip_address":"","ucode":"961C874D36C958","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/73/8c64ed7f.jpg","comment_is_top":false,"comment_ctime":1546936914,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546936914","product_id":100017301,"comment_content":"我觉得如果看文字还是不好理解的话，也可以参考一下算法图解这一块的内容，那个写的更好理解，但是可能不去老师这个成体系。","like_count":0},{"had_liked":false,"id":57798,"user_name":"我不吃甜食","can_delete":false,"product_type":"c1","uid":1086808,"ip_address":"","ucode":"1718E6D78F2852","user_header":"https://static001.geekbang.org/account/avatar/00/10/95/58/95e9507d.jpg","comment_is_top":false,"comment_ctime":1546913255,"is_pvip":false,"replies":[{"id":"21856","content":"当我们考察完第i个物品之后，如果背包重量是w（一个确定值），那第i个物品是装进去了还是没装进去呢？我们并不知道。但是，如果装进去的价值对应的背包总价值是v1，没装进去对应的背包总价值v2，那肯定选择v2了。<br><br>你之所以不怎么理解，主要原因是：这是一个递归的公式。有点反着思考的意思。<br><br>这也是对于初学者来说，状态转移方程最不好理解的地方。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1547709423,"ip_address":"","comment_id":57798,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1546913255","product_id":100017301,"comment_content":"老师，有个问题一直没太明白，希望帮忙解答一下；当第i个物品能放入的时候，要比较不放和放后的价值哪个大。这里如果选择放入第i个物品，为啥还要比呢？多放一个物品，价值难道还会减小？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435766,"discussion_content":"当我们考察完第i个物品之后，如果背包重量是w（一个确定值），那第i个物品是装进去了还是没装进去呢？我们并不知道。但是，如果装进去的价值对应的背包总价值是v1，没装进去对应的背包总价值v2，那肯定选择v2了。\n\n你之所以不怎么理解，主要原因是：这是一个递归的公式。有点反着思考的意思。\n\n这也是对于初学者来说，状态转移方程最不好理解的地方。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547709423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1108788,"avatar":"https://static001.geekbang.org/account/avatar/00/10/eb/34/cd310e69.jpg","nickname":"行走的","note":"","ucode":"04772A8A1FF2B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":43952,"discussion_content":"为何就“肯定选择v2了”？还是讲的不明白！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572918837,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57640,"user_name":"Geek_41d472","can_delete":false,"product_type":"c1","uid":1247965,"ip_address":"","ucode":"DEC2B6329460CF","user_header":"https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg","comment_is_top":false,"comment_ctime":1546857075,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546857075","product_id":100017301,"comment_content":"帮女朋友薅羊毛的代码实现，只能用666来形容了……","like_count":0},{"had_liked":false,"id":57105,"user_name":"想当上帝的司机","can_delete":false,"product_type":"c1","uid":1239378,"ip_address":"","ucode":"D8251388854911","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/52/f07e9001.jpg","comment_is_top":false,"comment_ctime":1546647947,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546647947","product_id":100017301,"comment_content":"用两个5*5的数组，一个存放数据datas，一个存放状态states,datas里每一个元素的左元素是下一行的这个位置减一，右元素是加1，第一行的比较特殊要计算好放到数组中间，然后就是跟有价值的背包问题一样，只不过是走左边还是右边，stats里的值存的是目前为止的路径长度，每次走一种情况加1","like_count":0},{"had_liked":false,"id":56627,"user_name":"Tenderness","can_delete":false,"product_type":"c1","uid":1124304,"ip_address":"","ucode":"840A6104972502","user_header":"https://static001.geekbang.org/account/avatar/00/11/27/d0/7e18e9a2.jpg","comment_is_top":false,"comment_ctime":1546510163,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546510163","product_id":100017301,"comment_content":"\tpublic static int distance(int[][] data){\t<br>             &#47;&#47;1.非空判断<br>\t\t&#47;&#47;2.构造矩阵(不必要空间需要节省) 初始化 temp[i][j] 代表顶层走到i j 位置的最短路径<br>\t\tint[][] temp= new int[data.length][data[data.length -1].length];<br>\t\t&#47;&#47;3.构造边界<br>\t\tfor(int i = 0;i&lt;data.length;i++) {<br>\t\t\ttemp[i][0] = data[i][0];<br>\t\t}<br>\t\t&#47;&#47;4.构造最短路径数据集合<br>\t\tfor(int i = 1;i&lt;data.length;i++) {<br>\t\t\tfor(int j = 1;j&lt;data[i].length;j++) {<br>\t\t\t\ttemp[i][j] = Math.min(data[i-1][j], data[i][j-1]) + data[i][j];<br>\t\t\t}<br>\t\t}<br>\t\t&#47;&#47;5.求解最短路径，最短路径在最后一行中找<br>\t\t&#47;&#47;多少行<br>\t\tint n = data.length;<br>\t\t&#47;&#47;多少列<br>\t\tint m = data[data.length -1].length;<br>\t\tint distance = Integer.MAX_VALUE;<br>\t\tfor(int i = m-1;i&gt;=0;--i) {<br>\t\t\tif(temp[n-1][i] &lt; distance) {<br>\t\t\t\tdistance = temp[n-1][i];<br>\t\t\t}<br>\t\t}<br>\t\treturn distance;<br>\t}","like_count":0},{"had_liked":false,"id":56599,"user_name":"郝大全","can_delete":false,"product_type":"c1","uid":1064678,"ip_address":"","ucode":"9351DC6E18DDE4","user_header":"https://static001.geekbang.org/account/avatar/00/10/3e/e6/3c35f6d9.jpg","comment_is_top":false,"comment_ctime":1546503687,"is_pvip":false,"replies":[{"id":"20484","content":"我改下 不好意思 ","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1546566282,"ip_address":"","comment_id":56599,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546503687","product_id":100017301,"comment_content":"第一个动态规划代码第三行：&quot;boolean[][] c =boolean[n][w+1]; &#47;&#47; 默认值 false&quot;<br>变量应该是states,不是c<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435138,"discussion_content":"我改下 不好意思 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546566282,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56592,"user_name":"这么写的闫","can_delete":false,"product_type":"c1","uid":1246059,"ip_address":"","ucode":"95B0D1E1A094C8","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/6b/f31d4538.jpg","comment_is_top":false,"comment_ctime":1546501926,"is_pvip":false,"replies":[{"id":"20485","content":"最后输出的i表示最大重量","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1546566360,"ip_address":"","comment_id":56592,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546501926","product_id":100017301,"comment_content":"“0-1 背包问题升级版”上面的代码段11行，输出结果为什么是“return i”？<br><br>没看明白这个操作是什么意思，求老师指点","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435136,"discussion_content":"最后输出的i表示最大重量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546566360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56349,"user_name":"Tsingxu","can_delete":false,"product_type":"c1","uid":1283254,"ip_address":"","ucode":"B88273B62319FA","user_header":"https://static001.geekbang.org/account/avatar/00/13/94/b6/88ee3707.jpg","comment_is_top":false,"comment_ctime":1546427336,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546427336","product_id":100017301,"comment_content":"关于背包升级为有价值区别的题中，如果用一维数组存储的话，我是这样写的（PHP）：<br>function knapsack4($weight, $value, $n, $w)<br>{<br>    for ($i = 0; $i &lt;= $w; $i++) {<br>        $states[$i] = -1;<br>    }<br>    $states[0] = 0;<br>    $states[$weight[0]] = $value[0];<br><br>    for ($i = 1; $i &lt; $n; $i++) {<br>        for ($j = $w - $weight[$i]; $j &gt;= 0; $j--) {<br>            if ($states[$j] &amp;&amp; $j + $weight[$i] &lt;= $w) {<br>                if ($weight[$i] == $j &amp;&amp; $value[$i] &gt; $states[$j]) $states[$j] = $value[$i];<br>                else $states[$j + $weight[$i]] = $states[$j] + $value[$i];<br>            }<br>        }<br>    }<br><br>    $maxValue = 0;<br>    for ($i = $w; $i &gt;= 0; $i--) {<br>        if ($states[$i] &gt; $maxValue) $maxValue = $states[$i];<br>    }<br><br>    return $maxValue;<br>}<br><br>虽然答案是一样的，但不知求解过程是否正确","like_count":0},{"had_liked":false,"id":56251,"user_name":"易波","can_delete":false,"product_type":"c1","uid":1326041,"ip_address":"","ucode":"9BE193B1633F51","user_header":"https://static001.geekbang.org/account/avatar/00/14/3b/d9/085772ea.jpg","comment_is_top":false,"comment_ctime":1546411793,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546411793","product_id":100017301,"comment_content":"老师你好，关于动态规划第一段代码（函数：public int knapsack(int[] weight, int n, int w)<br>中，第5行，需要加上判断条件if ( weight[0] &lt;= w ),避免数组越界，瑕不掩玉，老师讲解的非常好，思路清晰，受益匪浅！","like_count":0},{"had_liked":false,"id":55797,"user_name":"你好旅行者","can_delete":false,"product_type":"c1","uid":1154101,"ip_address":"","ucode":"5C72A428DC28F3","user_header":"https://static001.geekbang.org/account/avatar/00/11/9c/35/9dc79371.jpg","comment_is_top":false,"comment_ctime":1546311308,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546311308","product_id":100017301,"comment_content":"最近在学概率图模型，忽然觉得动态规划和图模型挺像的。当前状态依赖于上一个状态","like_count":0},{"had_liked":false,"id":55262,"user_name":"Kudo","can_delete":false,"product_type":"c1","uid":1036948,"ip_address":"","ucode":"21965914B72AEB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d2/94/8bd217f1.jpg","comment_is_top":false,"comment_ctime":1546081017,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546081017","product_id":100017301,"comment_content":"0-1背包python实现：<br><br>def backpack(items, w):<br>    &#39;&#39;&#39; <br>    # items: python list of item weights<br>    # w: upper limit weight the backpack can load<br>    &#39;&#39;&#39;<br>    states = [False] * (w + 1) # initialize list with len w+1<br>    states[0] = True; states[items[0]] = True # first row<br>    for i in items[1:]: # traverse from index 1<br>        for j in range(w-i,-1,-1): # traverse from back to front<br>            if states[j] == True:<br>                states[j+i] = True<br>                <br>    for i in range(w,-1,-1): # output max weight <br>        if states[i] == True:<br>            print(i)<br>            break<br>    <br># how to use<br>items = [2, 2, 4, 6, 3]<br>backpack(items, 9)","like_count":0},{"had_liked":false,"id":55212,"user_name":"Goku","can_delete":false,"product_type":"c1","uid":1031868,"ip_address":"","ucode":"8008F3BB10E609","user_header":"https://static001.geekbang.org/account/avatar/00/0f/be/bc/62d402da.jpg","comment_is_top":false,"comment_ctime":1546067152,"is_pvip":true,"replies":[{"id":"20248","content":"😄 很多问题都可以抽象成这些模型 所以才被人总结出来了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1546418090,"ip_address":"","comment_id":55212,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546067152","product_id":100017301,"comment_content":"请教老师一个问题：您觉得为什么会有这些奇怪数据结构呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434700,"discussion_content":"😄 很多问题都可以抽象成这些模型 所以才被人总结出来了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546418090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":54750,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1545959310,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545959310","product_id":100017301,"comment_content":"看都可以看懂 但是自己根本写不出来 尤其是动态规划的那个数组","like_count":0},{"had_liked":false,"id":54630,"user_name":"Monster","can_delete":false,"product_type":"c1","uid":1257029,"ip_address":"","ucode":"31F7F86DD50A1D","user_header":"https://static001.geekbang.org/account/avatar/00/13/2e/45/d4039dd3.jpg","comment_is_top":false,"comment_ctime":1545918338,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545918338","product_id":100017301,"comment_content":"老师 states定义为boolean类型， if (states[i-1][j] == true)  可以简写为  if (states[i-1][j]) ","like_count":0},{"had_liked":false,"id":54612,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1545913869,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545913869","product_id":100017301,"comment_content":"哨兵 这块方便指导下吗","like_count":0},{"had_liked":false,"id":54575,"user_name":"Wu","can_delete":false,"product_type":"c1","uid":1043198,"ip_address":"","ucode":"808D2CC6E4D2AD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ea/fe/05d933ac.jpg","comment_is_top":false,"comment_ctime":1545903257,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545903257","product_id":100017301,"comment_content":"0-1背包升级版的代码实现中， 第12 行的if (states[i][j] &gt;= 0) 的条件不需要吧。<br>加上这个条件，下一个的值没有办法从上一个转化过来<br>请老师检查一下<br>","like_count":0},{"had_liked":false,"id":54505,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1545884515,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545884515","product_id":100017301,"comment_content":"5-7-2-4-2是最小的路径","like_count":0},{"had_liked":false,"id":54504,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1545884474,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545884474","product_id":100017301,"comment_content":"这里面可以使用贪心算法解决，每次取最小的，查找对应的作用节点对应的最小值，然后依次递推下去","like_count":0},{"had_liked":false,"id":54487,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1545881435,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545881435","product_id":100017301,"comment_content":"回溯算法，思想很好理解，但是代码哪里体现了回溯的？","like_count":0},{"had_liked":false,"id":54427,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1545869806,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545869806","product_id":100017301,"comment_content":"首先得有钱，然后有女朋友，有女朋友没钱也没得买","like_count":0},{"had_liked":false,"id":54359,"user_name":"小蘑菇丢丢","can_delete":false,"product_type":"c1","uid":1246341,"ip_address":"","ucode":"E88BE7E07D7A0E","user_header":"","comment_is_top":false,"comment_ctime":1545834612,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545834612","product_id":100017301,"comment_content":"比如，（2，2）表示我们将要决策第 2 个物品是否装入背包，在决策前，背包中物品的总重量是 2。我理解的这个不是决策后的总重量是2？","like_count":0},{"had_liked":false,"id":54353,"user_name":"纯洁的憎恶","can_delete":false,"product_type":"c1","uid":1130512,"ip_address":"","ucode":"5E9757DE6F45DF","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/10/b6bf3c3c.jpg","comment_is_top":false,"comment_ctime":1545833892,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1545833892","product_id":100017301,"comment_content":"上学的时候就没搞懂动态规划，现在指望一天就学会也是有点不现实。今天的内容除了一维数组的0-1背包动态规划代码没看太明白，其他理解起来倒是不难，可是如果让我独立把代码写出来还是很困难，包括回溯算法也是，也许是因为递归与动态规划都太反直觉了吧？<br><br>动态规划把整个计算过程（如递归树）分成若干阶段，每个阶段会有若干种状态，其中存在重复的状态，于是可以通过合并每个阶段重复状态的方式，大大降低计算复杂度。并且下一个阶段的状态可以通过上一阶段的结果计算出来。当计算到最后一个阶段后，就可以得到想要的结果了。如果通过递归树来分析动态规划的算法复杂度，那么动态规划相当于把递归树每一层需要计算的节点数量限定在一个相对较小的范围，比如n，这样每层最多计算n次，那么总的计算复杂度就是每层节点数✖️树的深度h，即O（n*h）。这样理解对么？","like_count":0},{"had_liked":false,"id":54319,"user_name":"程序员联盟","can_delete":false,"product_type":"c1","uid":1018781,"ip_address":"","ucode":"5BB1E4050BBFF2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8b/9d/30c79c4b.jpg","comment_is_top":false,"comment_ctime":1545827880,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545827880","product_id":100017301,"comment_content":"动态规划真是太帅了","like_count":0},{"had_liked":false,"id":54272,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1545819549,"is_pvip":false,"replies":[{"id":"19641","content":"状态转移。j不变 就说明重量没增加 就说明东西没放进去","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545824703,"ip_address":"","comment_id":54272,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545819549","product_id":100017301,"comment_content":"  for (int j = 0; j &lt;= w; ++j) {&#47;&#47; 不把第 i 个物品放入背包<br>                if (states[i-1][j] == true) states[i][j] = states[i-1][j];<br>            }<br>            for (int j = 0; j &lt;= w-weight[i]; ++j) {&#47;&#47; 把第 i 个物品放入背包<br>                if (states[i-1][j]==true) states[i][j+weight[i]] = true;<br>            }<br>这两句不大明白为什么表示，不把dii个物品背包，比如<br>    if (states[i-1][j] == true) states[i][j] = states[i-1][j]; 这个赋值的时候不是会把所有的情况都列出来，包括i放入和不放入都添加进去。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434413,"discussion_content":"状态转移。j不变 就说明重量没增加 就说明东西没放进去","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545824703,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":54269,"user_name":"『LHCY』","can_delete":false,"product_type":"c1","uid":1188449,"ip_address":"","ucode":"A8B5E0467B5F25","user_header":"https://static001.geekbang.org/account/avatar/00/12/22/61/bbfb2d4a.jpg","comment_is_top":false,"comment_ctime":1545818828,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545818828","product_id":100017301,"comment_content":"思考题<br>用数组存储每一层<br>[1]<br>[2,3]<br>[2,3,4]<br>二维数组 [i][j] i代表行，j代表第几个元素，值为到达第i行，第j个元素时的最小路径。<br>[0][0]是第一个数组的元素1<br>从第二行开始，每次取[i-1][j]和[i-1][j-1]加上[i,j]，把小的存起来，注意数组越界处理，最后一行就是到达每个元素的最短路径，超遍历一遍得到总得最小路径","like_count":0},{"had_liked":false,"id":54268,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1545818595,"is_pvip":false,"replies":[{"id":"19638","content":"=n怎么理解呢","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545824623,"ip_address":"","comment_id":54268,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545818595","product_id":100017301,"comment_content":"for (int i = 1; i &lt; n; ++i) {<br><br>这里面的不是i&lt;=n?","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434412,"discussion_content":"=n怎么理解呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545824623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":54263,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1545818172,"is_pvip":false,"replies":[{"id":"19639","content":"不然代码没法写啊","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545824649,"ip_address":"","comment_id":54263,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545818172","product_id":100017301,"comment_content":"为什么第一行要特殊处理?","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434411,"discussion_content":"不然代码没法写啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545824649,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":54248,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1545815459,"is_pvip":false,"replies":[{"id":"19644","content":"cw值没变 你可以对比下面那行 f（i+1，cw+...）","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545825365,"ip_address":"","comment_id":54248,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545815459","product_id":100017301,"comment_content":"f(i+1, cw); &#47;&#47; 选择不装第 i 个物品<br>这个为什么表示不选择第i个物品，表示是否装入i+1个，前面i个已经装入进去了不可以？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434407,"discussion_content":"cw值没变 你可以对比下面那行 f（i+1，cw+...）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545825365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":54232,"user_name":"Monster","can_delete":false,"product_type":"c1","uid":1257029,"ip_address":"","ucode":"31F7F86DD50A1D","user_header":"https://static001.geekbang.org/account/avatar/00/13/2e/45/d4039dd3.jpg","comment_is_top":false,"comment_ctime":1545812230,"is_pvip":false,"replies":[{"id":"19670","content":"可以多练练写递归代码  回过头去重新看下递归那一节","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545828925,"ip_address":"","comment_id":54232,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545812230","product_id":100017301,"comment_content":"老师，我的基础有点不太好，我在调试0-1背包回溯算法的解法时，这个地方不太明白，第11行入栈5次后，i=物品数量，maxV=放入背包数量，第9行return后，为什么i的值 i=物品数量-1","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434400,"discussion_content":"可以多练练写递归代码  回过头去重新看下递归那一节","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545828925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":54223,"user_name":"白了少年头","can_delete":false,"product_type":"c1","uid":1053084,"ip_address":"","ucode":"A65E00E05B23BA","user_header":"https://static001.geekbang.org/account/avatar/00/10/11/9c/4fd6ebe0.jpg","comment_is_top":false,"comment_ctime":1545809726,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545809726","product_id":100017301,"comment_content":"老师帮忙看下我写的程序思路对不对好吗？<br>def yanghui_triangle(items, n):<br>    # 从第二行开始动态规划<br>    for i in range(1, n):<br>        for j in range(len(items[i])):<br>            # 当前行第一个元素<br>            if j == 0:<br>                items[i][j] += items[i-1][j]<br>            # 当前行最后一个元素<br>            elif j == len(items[i]) - 1:<br>                items[i][j] += items[i-1][j-1]<br>            # 取上一行较小的元素相加<br>            else:<br>                items[i][j] += items[i-1][j-1] if items[i-1][j-1] &lt; items[i-1][j] else items[i-1][j]<br>    # 输出最小值<br>    min_value = items[n-1][0]<br>    for i in range(1, len(items[n-1])):<br>        if items[n-1][i] &lt; min_value:<br>            min_value = items[n-1][i]<br>    print(min_value)<br><br>def test():<br>    items = [<br>        [5],<br>        [7, 8],<br>        [2, 3, 4],<br>        [4, 9, 6, 1],<br>        [2, 7, 9, 4, 5]<br>    ]<br>    yanghui_triangle(items, 5)<br><br>if __name__ == &#39;__main__&#39;:<br>    test()","like_count":0},{"had_liked":false,"id":54069,"user_name":"crazyone","can_delete":false,"product_type":"c1","uid":1115042,"ip_address":"","ucode":"705E34642E41F5","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/a2/ceb37046.jpg","comment_is_top":false,"comment_ctime":1545790890,"is_pvip":false,"replies":[{"id":"19651","content":"对","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545825932,"ip_address":"","comment_id":54069,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545790890","product_id":100017301,"comment_content":"动态规划求价值最大的，在不选择第i个物品下的if条件判断应该是if (states[i-1][j] &gt;= 0)吧","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434345,"discussion_content":"对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545825932,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":54024,"user_name":"Pan^yu","can_delete":false,"product_type":"c1","uid":1235771,"ip_address":"","ucode":"28F983B58A9EC2","user_header":"https://static001.geekbang.org/account/avatar/00/12/db/3b/e56ff0a9.jpg","comment_is_top":false,"comment_ctime":1545787283,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545787283","product_id":100017301,"comment_content":"课后习题：<br>1.以层数为限制条件<br>2.初始化两个Set，存放最短路径值，一个存上一层的值，一个存当前层的值，当前层遍历完时，当前层Set覆盖上层<br>3.初始化两个list，存放当前层的每个节点值，一个存上层，一个存当前层，当前层遍历完时，当前层list覆盖上层<br>4.循环遍历，遍历条件为上层list，每个节点的下层只能多两个，所以当前层节点个数为上层两倍，而且节点值都可以取随机数<br>5.最后从最底层的Set中取出最小的值","like_count":0},{"had_liked":false,"id":54019,"user_name":"在路边鼓掌的人","can_delete":false,"product_type":"c1","uid":1342023,"ip_address":"","ucode":"BC1388BA330CD5","user_header":"https://static001.geekbang.org/account/avatar/00/14/7a/47/d9090056.jpg","comment_is_top":false,"comment_ctime":1545787030,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1545787030","product_id":100017301,"comment_content":"个人觉得第一个例子中求背包中物品总重量的最大值可以不用动态规划，可以用求sum closest的问题,可以先对数据排序，然后设定一个滑动窗口求最接近的值，总体的时间复杂度是nlogn，要比动态规划的时间复杂度和空间复杂度低一些。","like_count":0},{"had_liked":false,"id":53997,"user_name":"皇家救星","can_delete":false,"product_type":"c1","uid":1326106,"ip_address":"","ucode":"89F1274A3835FE","user_header":"https://static001.geekbang.org/account/avatar/00/14/3c/1a/1806ef25.jpg","comment_is_top":false,"comment_ctime":1545784954,"is_pvip":false,"replies":[{"id":"19673","content":"貌似没有 有的类似决策树哈","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545829211,"ip_address":"","comment_id":53997,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545784954","product_id":100017301,"comment_content":"有个问题，像这种递归函数是否检查存在重叠，用画图方式方法确实很直观。但是画这种图，有没有什么技巧呢？有工具可以辅助生成吗","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434318,"discussion_content":"貌似没有 有的类似决策树哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545829211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":53975,"user_name":"棋圣","can_delete":false,"product_type":"c1","uid":1350617,"ip_address":"","ucode":"F14B942A2D0905","user_header":"https://static001.geekbang.org/account/avatar/00/14/9b/d9/d8214c4f.jpg","comment_is_top":false,"comment_ctime":1545783715,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545783715","product_id":100017301,"comment_content":"很棒","like_count":0}]}