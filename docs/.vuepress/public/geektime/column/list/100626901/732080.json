{"id":732080,"title":"答疑课堂（一）｜第一章Rust基础篇思考题答案","content":"<p><span class=\"reference\"></span>你好，我是Mike。</p><p>恭喜你学完前两章的内容了，基础篇和进阶篇一共有20讲，每一讲的内容都很重要，算是你入门Rust的重要基础，所以一定要多读几遍，争取学透。为了让你学思结合，我们在每节课的最后设计了对应的思考题，这节课我们就来处理这些问题。</p><p>我也看到很多同学在课程的后面回答了这些问题，此外还有一些其他的问题，提得也很精彩，所以我挑出一并放在这里，希望能为你解惑，对你有所启发，话不多说，我们马上开始吧！</p><p>做完思考题再来看答案会更有收获。</p><h2><strong>基础篇</strong></h2><h3><a href=\"https://time.geekbang.org/column/article/718865?utm_campaign=geektime_search&utm_content=geektime_search&utm_medium=geektime_search&utm_source=geektime_search&utm_term=geektime_search\">01｜快速入门：Rust 中有哪些你不得不了解的基础语法？</a></h3><h4>思考题</h4><ul>\n<li>Rust 中能否实现类似 JS 中的 number 这种通用的数字类型呢？</li>\n<li>Rust 中能否实现 Python 中那种无限大小的数字类型呢？</li>\n</ul><h4>答案</h4><p>在 Rust 中，有多种数字类型，包括有符号和无符号整数、浮点数、复数等。和 JS 中的 number 类型相似，Rust 中的数字类型也支持基本的数学运算，例如加减乘除和取模等。不过，和 JS 的 number 不同，Rust 的数字类型都具有固定的位数，这意味着不同的数字类型有不同的取值范围。</p><p>此外，Rust 中的数值类型需要在编译时就确定它们的类型和大小，这些类型可以通过使用 Rust 内置的类型注解，或是灵活的小数点和后缀表示法来声明。而 crates.io 上有 num crate 可以用来表示通用的数字类型，具体是通过trait机制来实现的。</p><!-- [[[read_end]]] --><p>关于实现 Python 中无限大小的数字类型，Rust 不直接支持这个特性，但可以通过使用第三方库来实现。常用的第三方库包括 rug 和 num-bigint 等，它们提供了实现高精度计算的数据类型和函数，使 Rust 可以处理更大的整数和浮点数。这些库采用的是类似于 Python 的动态内存分配和存储机制，能够进行几乎无限大小的数字计算。</p><h3><a href=\"https://time.geekbang.org/column/article/718916?utm_campaign=geektime_search&utm_content=geektime_search&utm_medium=geektime_search&utm_source=geektime_search&utm_term=geektime_search\">02｜所有权（上）：Rust 如何管理程序中的资源？</a></h3><h4>思考题</h4><ol>\n<li>下面的示例将输出什么？</li>\n</ol><pre><code class=\"language-plain\">fn main() {\n&nbsp; &nbsp; let s = \"I am a superman.\".to_string();\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; for i in 1..10 {\n&nbsp; &nbsp; &nbsp; &nbsp; let tmp_s = s;\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"s is {}\", tmp_s);\n&nbsp; &nbsp; }\n}\n</code></pre><ol start=\"2\">\n<li>一个由固定尺寸类型组成的结构体变量，如下面示例中的Point类型，在赋值给另一个变量时，采用的移动方式还是复制方式？</li>\n</ol><pre><code class=\"language-plain\">struct Point {\n  x: i64,\n  y: i64,\n  z: i64\n}\n</code></pre><h4>答案</h4><ol>\n<li>无法通过编译，可以将第 5 行代码修改为：let tmp_s = s.clone();。</li>\n</ol><p>修改后如下：</p><pre><code class=\"language-plain\">fn main() {\n    let s = \"I am a superman.\".to_string();\n    \n    for _ in 1..10 {\n        let tmp_s = s.clone();\n        println!(\"s is {}\", tmp_s);\n    }\n}\n</code></pre><ol start=\"2\">\n<li>由于 Point 没有实现 Copy trait，所以在赋值过程中会产生 Move。如果结构体实现了 Copy trait，则会进行复制而不是移动。</li>\n</ol><p><span class=\"reference\">答案来自二夕Thrower 和 Forest</span></p><h3><a href=\"https://time.geekbang.org/column/article/720128?utm_campaign=geektime_search&utm_content=geektime_search&utm_medium=geektime_search&utm_source=geektime_search&utm_term=geektime_search\">03｜所有权（下）：Rust 中借用与引用的规则是怎样的？</a></h3><h4>思考题</h4><ol>\n<li>请思考，为何在不可变引用存在的情况下（只是读操作），原所有权变量也无法写入？</li>\n</ol><pre><code class=\"language-plain\">fn main() {\n&nbsp; &nbsp; let mut a: u32 = 10;\n&nbsp; &nbsp; let b = &amp;a;\n&nbsp; &nbsp; a = 20;\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; println!(\"{}\", b);\n}\n</code></pre><ol start=\"2\">\n<li>请回答，可变引用复制的时候，为什么不允许copy，而是move？</li>\n</ol><h4>答案</h4><ol>\n<li>\n<p>不可变引用的作用域跨越了所有权变量的写入过程，意味着同一个作用域同时存在可变引用和不可变引用，编译器为了防止读取错误，不能通过编译。可以把a = 20放到引用之前，即可编译通过。</p>\n</li>\n<li>\n<p>可变引用如果可以Copy，就违反了可变引用不能同时存在的规则，因此只能Move。</p>\n</li>\n</ol><p>不可变借用，从字面理解就是借出去了就不能变了，所以既然保证不变了，那这样的借用当然可以被借出去N次（原变量不可变是只限于在借出去的变量的有效生命周期内）。可变借用就是借出去随时有被改变的可能，在同一生命周期内借出去多次，有不确定性的被改变的风险，尤其在多线程中，所以就只让你借出去一次，既然存在有不确定性的被修改的可能，那这个时期肯定就不会让你再有不可以变借用了（因为随时会改变了，不可变借用本身也就不成立了）。Rust这个逻辑看似很繁杂，实则逻辑环环相扣清晰很符合常规。</p><p><span class=\"reference\">答案来自Andylinge和Citroen</span></p><h3><a href=\"https://time.geekbang.org/column/article/720426?utm_campaign=geektime_search&utm_content=geektime_search&utm_medium=geektime_search&utm_source=geektime_search&utm_term=geektime_search\">04｜字符串：对号入座，字符串其实没那么可怕！</a></h3><h4>思考题</h4><p><code>chars</code> 函数是定义在 str 上的，为什么 String 类型能直接调用 str 上定义的方法？实际上 str 上所有的方法，String 都能调用，请问这是为什么呢？</p><h4>答案</h4><p>因此在String上实现了Deref trait，target为str。</p><p>另外补充一些字符串相关知识点。</p><p>Rust中 <code>char</code>是用于存放unicode单个字符的类型（固定4个字节）。String类型只能放在堆上，通过引用所有权的形式和变量绑定，它的存储方式不是简单的char数组，而是utf8编码的字节序列，所以单独取这个序列的某一段切片，不一定能解析出具体的字符（程序里的 <code>String[a..b]</code>，这里的a和b已经是经过特殊处理的保证截取的有效性）。</p><pre><code class=\"language-plain\">fn main() {\n    let s = \"abcdefghijk\".to_string();\n    let a = &amp;s[..5];\n\n    let s = \"我爱中国\".to_string();\n    let a = &amp;s[..5];\n}\n     Running `target/debug/playground`\nthread 'main' panicked at src/main.rs:7:15:\nbyte index 5 is not a char boundary; it is inside '爱' (bytes 3..6) of `我爱中国`\n</code></pre><p>如果能取得有效的序列片段那就是str类型，但是程序里凡是用到绑定str类型变量的地方，则必须都是引用形式存在的（&amp;str），因为str是引用的原始片段的那段真实数据，而&amp;str类型是一个FatPointer，它包括引用目标的起始地址和长度，所以str和&amp;str是完全两个不同的概念。</p><p>u8就是一个存储0到255大小的类型，因为一个字节就是8位，所以[u8, N]可以看做是程序的任何类型数据的二进制表示形式。</p><p><span class=\"reference\">答案来自 Citroen</span></p><h3><a href=\"https://time.geekbang.org/column/article/720991?utm_campaign=geektime_search&utm_content=geektime_search&utm_medium=geektime_search&utm_source=geektime_search&utm_term=geektime_search\">05｜复合类型（上）：结构体与面向对象特性</a></h3><h4>思考题</h4><p>可以给 i8 类型做 impl 吗？</p><h4>答案</h4><p>基本数据类型无法实现impl，不过我们可以通过 trait给基本数据类型添加操作的方式来实现。</p><pre><code class=\"language-plain\">trait Operate {\n  fn plus(self) -&gt; Self;\n}\n\nimpl Operate for i8 {\n    fn plus(self) -&gt; Self {\n        self + self\n    }\n}\n\nfn main() {\n    let  a = 1i8;\n    println!(\"{}\",a.plus());\n}\n</code></pre><p>另外可以用newtype模式对 <code>i8</code> 封装一下，再impl。</p><p><span class=\"reference\">答案来自下雨天和约书亚</span></p><h3><a href=\"https://time.geekbang.org/column/article/720999?utm_campaign=geektime_search&utm_content=geektime_search&utm_medium=geektime_search&utm_source=geektime_search&utm_term=geektime_search\">06｜复合类型（下）：枚举与模式匹配</a></h3><h4>思考题</h4><p>match 表达式的各个分支中，如果有不同的返回类型的情况，应该如何处理？</p><h4>答案</h4><p>作为静态类型语言，match 返回的类型必须在编译期就被确定，也就意味着 match 必须返回相同的类型。在这个前提下，如果要返回不同的类型，那么切入点就只能是：“返回同一个类型，但是这个类型能表示（承载）不同的类型”，那就只能是本节课讲的枚举 enum 了。</p><pre><code class=\"language-rust\">enum Number {\n    Int(i32),\n    Float(f64),\n    None\n}\n\nfn get_number(condition: i32) -&gt; Number {\n    match condition {\n        1 =&gt; Number::Int(10),\n        2 =&gt; Number::Float(3.14),\n        _ =&gt; Number::None\n    }\n}\n\nfn main() {\n    let value = get_number(1);\n    match value {\n        Number::Int(i) =&gt; println!(\"int {}\", i),\n        Number::Float(f) =&gt; println!(\"float {}\", f),\n        Number::None =&gt; println!(\"not number\"),\n    }\n\n    let value = get_number(2);\n    match value {\n        Number::Int(i) =&gt; println!(\"int {}\", i),\n        Number::Float(f) =&gt; println!(\"float {}\", f),\n        Number::None =&gt; println!(\"not number\"),\n    }\n\n    let value = get_number(3);\n    match value {\n        Number::Int(i) =&gt; println!(\"int {}\", i),\n        Number::Float(f) =&gt; println!(\"float {}\", f),\n        Number::None =&gt; println!(\"not number\"),\n    }\n}\n</code></pre><p><span class=\"reference\">答案来自-Hedon 🍭</span></p><h3><a href=\"https://time.geekbang.org/column/article/722240?utm_campaign=geektime_search&utm_content=geektime_search&utm_medium=geektime_search&utm_source=geektime_search&utm_term=geektime_search\">07｜类型与类型参数：如何给 Rust 小助手提供更多信息？</a></h3><h4>思考题</h4><p>如果你给某个泛型实现了一个方法，那么还能为它的一个具化类型再实现同样的方法吗？</p><h4>答案</h4><p>“为泛型实现了一个方法，能否再为具化类型实现一个同名方法”，取决于这个泛型能否表示相应的具化类型。比如为泛型 T 和 String 实现了相同的方法，由于 T 没有施加任何约束，它可以代表 String。那么当调用方法时，对于具化类型 String 来说，要调用哪一个呢？因此会出现歧义，编译器会报错：方法被重复定义了。</p><p>但如果给泛型 T 施加了一个 Copy 约束，要求 T 必须实现了 Copy trait，那么就不会报错了，因为此时 T 代表不了 String，所以调用方法不会出现歧义。但如果再为 <code>i32</code> 实现一个同名方法就会报错了，因为 <code>i32</code> 实现了 Copy，它可以被 T 表示。</p><p><span class=\"reference\">答案来自古明地觉</span></p><h3><a href=\"https://time.geekbang.org/column/article/722702?utm_campaign=geektime_search&utm_content=geektime_search&utm_medium=geektime_search&utm_source=geektime_search&utm_term=geektime_search\">08｜Option、Result、迭代器及实际类型中所有权问题</a></h3><h4>思考题</h4><p>你可以用同样的思路去研究一下，看看如何拿到 HashMap 中值的所有权。<a href=\"https://doc.rust-lang.org/std/collections/struct.HashMap.html\">https://doc.rust-lang.org/std/collections/struct.HashMap.html</a></p><h4>答案</h4><p>HashMap实现了 <code>into_iter()</code>，因此可以用for语句获取其所有权。</p><pre><code class=\"language-plain\">for (k, v) in myhash { //`myhash` moved due to this implicit call to `.into_iter()`\n    // todo:\n    // 这里会获得v的所有权，并且消耗掉myhash\n}\n\nprintln!(\"{:?}\", myhash); //value borrowed here after move\n</code></pre><p><span class=\"reference\">答案来自PEtFiSh和Ransang</span></p><h3><a href=\"https://time.geekbang.org/column/article/723496?utm_campaign=geektime_search&utm_content=geektime_search&utm_medium=geektime_search&utm_source=geektime_search&utm_term=geektime_search\">09｜初识Trait：协议约束与能力配置</a></h3><h4>思考题</h4><p>如果你学习或者了解过 Java、C++ 等面向对象语言的话，可以聊一聊 trait 的依赖和 OOP 继承的区别在哪里。</p><h4>答案</h4><p>trait 的依赖：小明要听从数学老师，语文老师，英语老师的话。老师之间是平等关系，多个依赖平等，最小依赖选择自己喜欢的功能。</p><p>OOP 继承：小明要听他爸、他爷爷、他曾祖父的话。继承之间存在父子关系，继承过来一堆破属性和方法，也许根本不是自己想要的，还要负重前行。</p><p><span class=\"reference\">答案来自下雨天</span></p><h3><a href=\"https://time.geekbang.org/column/article/724776?utm_campaign=geektime_search&utm_content=geektime_search&utm_medium=geektime_search&utm_source=geektime_search&utm_term=geektime_search\">10｜再探Trait：Trait + 类型 = Rust 的大脑</a></h3><h4>思考题</h4><p>请谈谈在函数参数中传入 <code>&dyn TraitA</code> 与 <code>Box</code>&nbsp;两种类型的区别。</p><h4>答案</h4><p>Rust生命周期的独特设计，导致了该语言需要设计一些处理方式应对特殊情况，比如生命周期的标注（主要是给编译器进行代码处理时的提示）。事实上，我们在日常开发中应该避免一些陷入复杂情况的方式：比如，传入参数都用引用（borrow），传出结果都应该是owner。Rust也为我们提供了处理各种情况的工具。所以，一般来说，我们应该在传入参数的时候用 <code>&dyn T</code>，传出结果用 <code>Box&lt;dyn T&gt;</code>。</p><p>此外，<code>&dyn TraitA</code> 没有所有权，而 <code>Box&lt;dyn TraitA&gt;</code> 有所有权。<code>&dyn TraitA</code> 是借用，Box 会转移所有权。</p><p>通过下面的程序可以测试出来：</p><pre><code class=\"language-plain\">fn doit3(t1: &amp;dyn TraitA, t2: Box) {\n     println!(\"{:?}\", t1);\n     println!(\"{:?}\", t2)\n }\nfn main() {\n     let a = AType;\n     let b = BType;\n     doit3(&amp;a, Box::new(b));\n     println!(\"{:?}\", a);\n     println!(\"{:?}\", b);\n }\n输出：\nerror[E0382]: borrow of moved value: b\n   --&gt; examples/trait_object.rs:29:22\n    |\n 26 |     let b = BType;\n    |         - move occurs because b has type BType, which does not implement the Copy trait\n 27 |     doit3(&amp;a, Box::new(b));\n    |                        - value moved here\n 28 |     println!(\"{:?}\", a);\n 29 |     println!(\"{:?}\", b);\n    |                      ^ value borrowed here after move\n</code></pre><p><span class=\"reference\">答案来自哄哄、鸠摩智和-Hedon 🍭</span></p><h3><a href=\"https://time.geekbang.org/column/article/724942?utm_campaign=geektime_search&utm_content=geektime_search&utm_medium=geektime_search&utm_source=geektime_search&utm_term=geektime_search\">11｜常见 Trait 解析：标准库中的常用 Trait 应该怎么用？</a></h3><h4>思考题</h4><p>请举例说明 Deref 与 AsRef&nbsp;的区别。</p><h4>答案</h4><p>在 Rust 中，Deref 和 AsRef 都是与引用相关的 trait，它们可以使某些类型在使用时具有类似于指针的行为，但它们的具体用途有所不同。</p><p><strong>Deref trait 通常与智能指针一起使用</strong>。当我们编写 Rust 代码时，分配在堆上的值通常不是通过拷贝的方式传递或返回，而是通过使用指向它们的指针（智能指针）来传递或返回。Deref trait 可以强制将智能指针转换成指针，从而可以使用类似于 * 操作符这样的解引用语法访问指针指向的值。例如：</p><pre><code class=\"language-plain\">struct MyInt(i32);\n\nimpl Deref for MyInt {\n    type Target = i32;\n\n    fn deref(&amp;self) -&gt; &amp;Self::Target {\n        &amp;self.0\n    }\n}\n\nfn main() {\n    let my_int = MyInt(42);\n    assert_eq!(*my_int, 42);\n}\n</code></pre><p>在上面的代码中，我们定义了一个 <code>MyInt</code> 结构体，它包含一个 i32 类型的值。我们实现了 Deref trait，并指定了目标类型为 i32。我们在 <code>deref</code> 方法中返回了 <code>self.0</code>，即指向 <code>MyInt</code> 中的 i32 值的引用。这样，我们就可以在 <code>main</code> 函数中使用 <code>*my_int</code> 访问这个 i32 值。</p><p>相比之下，<strong>AsRef trait 更加通用</strong>。它只是将类型的引用转换为其他类型的引用。一种常见的用途是将各种字符串类型统一转换为&amp;str类型。例如：</p><pre><code class=\"language-plain\">fn do_something&lt;T: AsRef&lt;str&gt;&gt;(input: T) {\n    let bytes = input.as_ref().as_bytes();\n    // Do something with the bytes...\n}\n\nfn main() {\n    let my_str = \"hello\".to_string();\n    do_something(my_str);\n}\n</code></pre><p>在上面的代码中，我们定义了一个 <code>do_something</code> 函数，它接受任何实现了 <code>AsRef&lt;str&gt;</code> trait 的值。在函数内部，我们首先使用 <code>as_ref</code> 方法将输入值转换为 <code>&amp;str</code> 类型，然后使用 <code>as_bytes</code> 方法将 <code>&amp;str</code> 类型转换为 <code>&amp;[u8]</code> 类型。这样，我们就可以在函数中使用字节数组操作 <code>bytes</code> 了。在 <code>main</code> 函数中，我们传递了一个所有权字符串，它在函数中，使用 as_ref() 转换成了<code>&amp;str</code> 类型。</p><p>好了，以上就是我们第一章基础篇的思考题与答案，希望你对照着答案看一下自己的思路对不对，如果你有不同的见解，也欢迎你在评论区分享出来，我们一起讨论。我们下节课再见！</p>","comments":[{"had_liked":false,"id":384933,"user_name":"不忘初心","can_delete":false,"product_type":"c1","uid":3737491,"ip_address":"四川","ucode":"8262D42405F4E2","user_header":"https://static001.geekbang.org/account/avatar/00/39/07/93/710c7ee2.jpg","comment_is_top":false,"comment_ctime":1701825554,"is_pvip":false,"replies":[{"id":140378,"content":"是的","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1701919623,"ip_address":"重庆","comment_id":384933,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"可以给 i8 类型做 impl 吗？基本数据类型无法实现 impl. \n准确点说, 应该是自身crate之外的都无法直接impl, 但可以impl trait","like_count":2,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633233,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1701919623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385211,"user_name":"thanks","can_delete":false,"product_type":"c1","uid":1614812,"ip_address":"北京","ucode":"61F917FEBE4501","user_header":"https://static001.geekbang.org/account/avatar/00/18/a3/dc/9df4f5a0.jpg","comment_is_top":false,"comment_ctime":1702285954,"is_pvip":false,"replies":[{"id":140449,"content":"举个示例，字符串String如果在存在不可变借用的情况下，原所有权变量可写的话，比如增长这个字符串，可能会导致底层存储这个字符串的内存重新分配，这时，这个字符串在堆中的地址就变了。这个时候，基于这个String得到的&amp;slice 会指向原来的地址，导致内存访问出错。所以rust禁止了不可变引用存在的情况下的原所有权变量的修改。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1702609409,"ip_address":"重庆","comment_id":385211,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"03｜所有权（下）：Rust 中借用与引用的规则是怎样的？\n第一个问题，从现象看是 rust 的规则不允许这么写，但是不允许这么写的原因是为啥","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633766,"discussion_content":"举个示例，字符串String如果在存在不可变借用的情况下，原所有权变量可写的话，比如增长这个字符串，可能会导致底层存储这个字符串的内存重新分配，这时，这个字符串在堆中的地址就变了。这个时候，基于这个String得到的&amp;slice 会指向原来的地址，导致内存访问出错。所以rust禁止了不可变引用存在的情况下的原所有权变量的修改。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702609409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384932,"user_name":"伯阳","can_delete":false,"product_type":"c1","uid":1596631,"ip_address":"北京","ucode":"DBDC8735AA54AD","user_header":"https://static001.geekbang.org/account/avatar/00/18/5c/d7/3b92bb0d.jpg","comment_is_top":false,"comment_ctime":1701813447,"is_pvip":false,"replies":[{"id":140377,"content":"tokio有讲，很多","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1701919604,"ip_address":"重庆","comment_id":384932,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"多刷两遍，期待老师的实战课程，能讲讲tikio么，老师","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633232,"discussion_content":"tokio有讲，很多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1701919604,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384928,"user_name":"Distance","can_delete":false,"product_type":"c1","uid":1109780,"ip_address":"北京","ucode":"B30FAFE1F64D3D","user_header":"https://static001.geekbang.org/account/avatar/00/10/ef/14/83867b58.jpg","comment_is_top":false,"comment_ctime":1701792458,"is_pvip":false,"replies":[{"id":140376,"content":"先回顾一下，夯实下基础。哈哈","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1701919588,"ip_address":"重庆","comment_id":384928,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"啊这 按照大纲今天不应该是 axum 嘛，我还以为这周 axum 能更完😂","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633231,"discussion_content":"先回顾一下，夯实下基础。哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1701919588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1027167,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ac/5f/894761f8.jpg","nickname":"十八哥","note":"","ucode":"C0130252F97814","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633186,"discussion_content":"加餐不好嘛👀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1701874124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"天津","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":395374,"user_name":"知足","can_delete":false,"product_type":"c1","uid":4017296,"ip_address":"北京","ucode":"27061A7B1C218F","user_header":"https://static001.geekbang.org/account/avatar/00/3d/4c/90/00336164.jpg","comment_is_top":false,"comment_ctime":1730470087,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"impl&lt;T: Display + Copy&gt; Point&lt;T&gt; {\n    fn print(&amp;self) {\n        println!(&quot;x&quot;);\n    }\n}\n\nimpl Point&lt;String&gt; {\n    fn print(&amp;self) {\n        println!(&quot;NotDisplay: x: {}, y: {}&quot;, self.x, self.y);\n    }\n}\n\n这样还是不行：\nerror[E0592]: duplicate definitions with name `print`\n  --&gt; src&#47;main.rs:13:5\n   |\n13 |     fn print(&amp;self) {\n   |     ^^^^^^^^^^^^^^^ duplicate definitions for `print`\n...\n19 |     fn print(&amp;self) {\n   |     --------------- other definition for `print`\n   |\n   = note: upstream crates may add a new impl of trait `std::marker::Copy` for type `std::string::String` in future versions","like_count":0}]}