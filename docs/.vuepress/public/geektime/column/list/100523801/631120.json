{"id":631120,"title":"期中周｜期中测试题，你做对了么？","content":"<p>你好，我是卢誉声。</p><p>为了帮助你巩固知识，提升能力，期中周我给你出了一道实战题目，基于课程里的代码扩展现有协程框架，实现高级任务调度。题目描述你可以通过<a href=\"https://time.geekbang.org/column/article/629373\">这个链接</a>回顾。</p><p>这一讲，我会把参考代码和解题思路公布出来。</p><h2>答案解析</h2><p>既然要在现有代码上增加功能，我们就有必要先熟悉原有架构，再决定在哪个模块或哪个层面上追加功能。</p><p>通过分析，可以发现任务的执行与调度是通过asyncpp.task模块实现的。同时，我们又是在为现有框架提供高优先级调度的能力。因此，新增的模块应该是供asyncpp.task使用的。</p><p>基于这样的考虑，我们在原有的架构基础上，追加了一个high performance（asyncpp.hp）模块，供asyncpp.task模块实现高性能的线程调度。补充后的架构图是后面这样。</p><p><img src=\"https://static001.geekbang.org/resource/image/4e/95/4e0fbf132067b48443fa86edc915e195.jpg?wh=2900x1980\" alt=\"\"></p><p>从图中可以看到，asyncpp.task模块引用了asyncpp.hp模块。新的模块提供了高优先级线程调度和管理的能力。</p><p>我们来看一下具体实现。首先是:task子模块。</p><pre><code class=\"language-c++\">export module asyncpp.hp:task;\n\nimport asyncpp.core;\nimport &lt;functional&gt;;\nimport &lt;vector&gt;;\nimport &lt;mutex&gt;;\n\nnamespace asyncpp::hp {\n\nexport struct AsyncHpTask {\n&nbsp; &nbsp; using ResumeHandler = std::function&lt;void()&gt;;\n&nbsp; &nbsp; using TaskHandler = std::function&lt;void()&gt;;\n\n&nbsp; &nbsp; // 协程唤醒函数\n&nbsp; &nbsp; ResumeHandler resumeHandler;\n&nbsp; &nbsp; // 计算任务函数\n&nbsp; &nbsp; TaskHandler taskHandler;\n};\n\nexport class AsyncHpTaskQueue {\npublic:\n&nbsp; &nbsp; static AsyncHpTaskQueue&amp; getInstance();\n\n&nbsp; &nbsp; void enqueue(const AsyncHpTask&amp; item) {\n&nbsp; &nbsp; &nbsp; &nbsp; std::lock_guard&lt;std::mutex&gt; guard(_queueMutex);\n\n&nbsp; &nbsp; &nbsp; &nbsp; _queue.push_back(item);\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; bool dequeue(AsyncHpTask* item) {\n&nbsp; &nbsp; &nbsp; &nbsp; std::lock_guard&lt;std::mutex&gt; guard(_queueMutex);\n\n&nbsp; &nbsp; &nbsp; &nbsp; if (_queue.size() == 0) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n\n&nbsp; &nbsp; &nbsp; &nbsp; *item = _queue.back();\n&nbsp; &nbsp; &nbsp; &nbsp; _queue.pop_back();\n\n&nbsp; &nbsp; &nbsp; &nbsp; return true;\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; size_t getSize() const {\n&nbsp; &nbsp; &nbsp; &nbsp; return _queue.size();\n&nbsp; &nbsp; }\n\nprivate:\n&nbsp; &nbsp; // 高性能计算任务队列\n&nbsp; &nbsp; std::vector&lt;AsyncHpTask&gt; _queue;\n&nbsp; &nbsp; // 高性能计算任务队列互斥锁，用于实现线程同步，确保队列操作的线程安全\n&nbsp; &nbsp; std::mutex _queueMutex;\n};\n\nAsyncHpTaskQueue&amp; AsyncHpTaskQueue::getInstance() {\n&nbsp; &nbsp; static AsyncHpTaskQueue queue;\n\n&nbsp; &nbsp; return queue;\n}\n\n}\n</code></pre><!-- [[[read_end]]] --><p>这部分代码跟之前的asyncpp.io:task基本相同，唯一区别是调度的任务类型不同，用于处理高性能计算任务。</p><p>接下来的重点是:loop的实现。</p><pre><code class=\"language-c++\">module;\n\n#ifndef _WINDOWS_\n#include &lt;Windows.h&gt;\n#endif // _WINDOWS_\n\nexport module asyncpp.hp:loop;\n\nimport :task;\nimport asyncpp.task.queue;\n\nimport &lt;thread&gt;;\nimport &lt;chrono&gt;;\nimport &lt;thread&gt;;\nimport &lt;functional&gt;;\n\nnamespace asyncpp::hp {\n&nbsp; &nbsp; export class AsyncHpLoop {\n&nbsp; &nbsp; public:\n&nbsp; &nbsp; &nbsp; &nbsp; // 常量，定义了任务循环的等待间隔时间（单位为毫秒）\n&nbsp; &nbsp; &nbsp; &nbsp; static const int32_t SLEEP_MS = 100;\n\n&nbsp; &nbsp; &nbsp; &nbsp; static AsyncHpLoop&amp; start();\n\n&nbsp; &nbsp; private:\n&nbsp; &nbsp; &nbsp; &nbsp; // 支持单例模式，将其定义为private，防止外部调用构造函数\n&nbsp; &nbsp; &nbsp; &nbsp; AsyncHpLoop() {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _thread = std::jthread(std::bind(&amp;AsyncHpLoop::loopMain, this));\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; auto nativeWorkerHandle = _thread.native_handle();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ::SetThreadPriority(nativeWorkerHandle, THREAD_PRIORITY_HIGHEST);\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; // 支持单例模式，通过delete修饰符说明拷贝构造函数不可调用\n&nbsp; &nbsp; &nbsp; &nbsp; AsyncHpLoop(const AsyncHpLoop&amp;) = delete;\n&nbsp; &nbsp; &nbsp; &nbsp; // 支持单例模式，通过delete修饰符说明赋值操作符不可调用\n&nbsp; &nbsp; &nbsp; &nbsp; AsyncHpLoop&amp; operator=(const AsyncHpLoop&amp;) = delete;\n\n&nbsp; &nbsp; &nbsp; &nbsp; void loopExecution() {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AsyncHpTask opItem;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!AsyncHpTaskQueue::getInstance().dequeue(&amp;opItem)) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opItem.taskHandler();\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; auto&amp; asyncEventQueue = asyncpp::task::AsyncTaskQueue::getInstance();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; asyncEventQueue.enqueue({\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .handler = opItem.resumeHandler\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; });\n&nbsp; &nbsp; &nbsp; &nbsp; }\n\n&nbsp; &nbsp; &nbsp; &nbsp; void loopMain() {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (true) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loopExecution();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(SLEEP_MS));\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n\n&nbsp; &nbsp; &nbsp; &nbsp; // jthread对象，为高性能计算线程，jthread让该线程结束之前整个进程都不会结束\n&nbsp; &nbsp; &nbsp; &nbsp; std::jthread _thread;\n&nbsp; &nbsp; };\n\n&nbsp; &nbsp; AsyncHpLoop&amp; AsyncHpLoop::start() {\n&nbsp; &nbsp; &nbsp; &nbsp; static AsyncHpLoop ioLoop;\n\n&nbsp; &nbsp; &nbsp; &nbsp; return ioLoop;\n&nbsp; &nbsp; }\n}\n</code></pre><p>我们在这段代码里不仅使用jthread，还在AsyncHpLoop构造函数中使用了native_handle，设置了线程优先级，用于高性能的任务调度。</p><p>最后，我们在asyncpp.task:asyncify中，使用了新的模块。</p><pre><code class=\"language-c++\">export module asyncpp.task:asyncify;\n\nexport import asyncpp.task.queue;\nexport import :loop;\nexport import :coroutine;\n\nimport asyncpp.core;\nimport asyncpp.hp;\n\nnamespace asyncpp::task {\n&nbsp; &nbsp; using asyncpp::core::Invocable;\n\n&nbsp; &nbsp; // 默认的AsyncTaskSuspender（当任务函数返回类型不为void时）\n&nbsp; &nbsp; template &lt;typename ResultType&gt;\n&nbsp; &nbsp; void defaultAsyncAwaitableSuspend(\n&nbsp; &nbsp; &nbsp; &nbsp; Awaitable&lt;ResultType&gt;* awaitable,\n&nbsp; &nbsp; &nbsp; &nbsp; AsyncTaskResumer resumer,\n&nbsp; &nbsp; &nbsp; &nbsp; CoroutineHandle&amp; h\n&nbsp; &nbsp; ) {\n&nbsp; &nbsp; &nbsp; &nbsp; auto&amp; asyncTaskQueue = AsyncTaskQueue::getInstance();\n&nbsp; &nbsp; &nbsp; &nbsp; asyncTaskQueue.enqueue({\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .handler = [resumer, awaitable] {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; awaitable-&gt;_taskResult = awaitable-&gt;_taskHandler();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resumer();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; });\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; // 默认的AsyncTaskSuspender（当任务函数返回类型为void时）\n&nbsp; &nbsp; template &lt;&gt;\n&nbsp; &nbsp; void defaultAsyncAwaitableSuspend&lt;void&gt;(\n&nbsp; &nbsp; &nbsp; &nbsp; Awaitable&lt;void&gt;* awaitable,\n&nbsp; &nbsp; &nbsp; &nbsp; AsyncTaskResumer resumer,\n&nbsp; &nbsp; &nbsp; &nbsp; CoroutineHandle&amp; h\n&nbsp; &nbsp; ) {\n&nbsp; &nbsp; &nbsp; &nbsp; auto&amp; asyncTaskQueue = AsyncTaskQueue::getInstance();\n&nbsp; &nbsp; &nbsp; &nbsp; asyncTaskQueue.enqueue({\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .handler = [resumer, awaitable] {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; awaitable-&gt;_taskHandler();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resumer();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; });\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; template &lt;typename ResultType&gt;\n&nbsp; &nbsp; void hpAsyncAwaitableSuspend(\n&nbsp; &nbsp; &nbsp; &nbsp; Awaitable&lt;ResultType&gt;* awaitable,\n&nbsp; &nbsp; &nbsp; &nbsp; AsyncTaskResumer resumer,\n&nbsp; &nbsp; &nbsp; &nbsp; CoroutineHandle&amp; h\n&nbsp; &nbsp; ) {\n&nbsp; &nbsp; &nbsp; &nbsp; asyncpp::hp::AsyncHpTask operationItem{\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .resumeHandler = [h] {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; h.resume();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .taskHandler = [awaitable]() {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; awaitable-&gt;_taskResult = awaitable-&gt;_taskHandler();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; };\n\n&nbsp; &nbsp; &nbsp; &nbsp; asyncpp::hp::AsyncHpTaskQueue::getInstance().enqueue(operationItem);\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; export template &lt;Invocable T&gt;\n&nbsp; &nbsp; auto asyncify(\n&nbsp; &nbsp; &nbsp; &nbsp; T taskHandler,\n&nbsp; &nbsp; &nbsp; &nbsp; AsyncTaskSuspender&lt;std::invoke_result_t&lt;T&gt;&gt; suspender =\n&nbsp; &nbsp; &nbsp; &nbsp; defaultAsyncAwaitableSuspend&lt;std::invoke_result_t&lt;T&gt;&gt;\n&nbsp; &nbsp; ) {\n&nbsp; &nbsp; &nbsp; &nbsp; return Awaitable&lt;std::invoke_result_t&lt;T&gt;&gt;{\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ._taskHandler = taskHandler,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ._suspender = suspender\n&nbsp; &nbsp; &nbsp; &nbsp; };\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; export template &lt;Invocable T&gt;\n&nbsp; &nbsp; auto asyncify(\n&nbsp; &nbsp; &nbsp; &nbsp; T taskHandler,\n&nbsp; &nbsp; &nbsp; &nbsp; bool highPriority\n&nbsp; &nbsp; ) {\n&nbsp; &nbsp; &nbsp; &nbsp; if (highPriority) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Awaitable&lt;std::invoke_result_t&lt;T&gt;&gt;{\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ._taskHandler = taskHandler,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ._suspender = hpAsyncAwaitableSuspend&lt;std::invoke_result_t&lt;T&gt;&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; };\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; return Awaitable&lt;std::invoke_result_t&lt;T&gt;&gt;{\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ._taskHandler = taskHandler,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ._suspender = defaultAsyncAwaitableSuspend&lt;std::invoke_result_t&lt;T&gt;&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; };\n&nbsp; &nbsp; }\n}\n</code></pre><p>你可以先关注一下第8行代码，这里我们导入了hp模块的符号。接着，还在第46行实现了hpAsyncAwaitableSuspend，用于实现高性能版本的调度。</p><p>最后，我们在第76行实现了类似于之前的asyncify工具，用于将一个普通的函数f转换成一个返回Awaitable对象的函数asyncF。通过这个分区实现的工具，可以让库的用户更容易使用coroutine。</p><p>这道题目的源代码，你可以从<a href=\"https://github.com/samblg/cpp20-plus-indepth/tree/main/mid_term_exam_sol\">这里</a>获取。</p><p>期中周即将告一段落，你可以再利用周末时间温习一下之前所学。有不明白的地方欢迎和我在留言区交流，下周我们继续回到课程主线，继续学习C++ Ranges的用法，敬请期待。</p>","neighbors":{"left":{"article_title":"期中周｜扩展现有协程框架，实现高级任务调度","id":629373},"right":{"article_title":"11｜Ranges（一）：数据序列处理的新工具","id":627909}},"comments":[{"had_liked":false,"id":385271,"user_name":"Family mission","can_delete":false,"product_type":"c1","uid":2710729,"ip_address":"上海","ucode":"10D4D65520FE0D","user_header":"https://static001.geekbang.org/account/avatar/00/29/5c/c9/f1b053f2.jpg","comment_is_top":false,"comment_ctime":1702369624,"is_pvip":false,"replies":[{"id":140432,"content":"这部分应该是没问题的，\n36行是defaultAsyncAwaitableSuspend，也就是非高性能任务的业务逻辑，所以调用的是AsyncTaskQueue::getInstance\n60行是hpAsyncAwaitableSuspend，也就是高性能任务的业务逻辑，所以调用的是asyncpp::hp::AsyncHpTaskQueue::getInstance","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1702442106,"ip_address":"上海","comment_id":385271,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"感觉asyncpp.task:asyncify 模块中36行使用单例模式构造AsyncHpTaskQueue而不是AsyncTaskQueue::getInstance()，写错了吧","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633658,"discussion_content":"这部分应该是没问题的，\n36行是defaultAsyncAwaitableSuspend，也就是非高性能任务的业务逻辑，所以调用的是AsyncTaskQueue::getInstance\n60行是hpAsyncAwaitableSuspend，也就是高性能任务的业务逻辑，所以调用的是asyncpp::hp::AsyncHpTaskQueue::getInstance","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702442106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]}]}