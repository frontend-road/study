{"id":238486,"title":"07 | const/volatile/mutable：常量/变量究竟是怎么回事？","content":"<p>你好，我是Chrono。</p><p>上节课我讲了自动类型推导，提到auto推导出的类型可以附加const、volatile修饰（通常合称为“cv修饰符”）。别看就这么两个关键字，里面的“门道”其实挺多的，用好了可以让你的代码更安全、运行得更快。今天我就来说说它们俩，以及比较少见的另一个关键字mutable。</p><h2>const与volatile</h2><p>先来看<strong>const</strong>吧，你一定对它很熟悉了。正如它的字面含义，表示“常量”。最简单的用法就是，<strong>定义程序用到的数字、字符串常量，代替宏定义</strong>。</p><pre><code>const int MAX_LEN       = 1024;\nconst std::string NAME  = &quot;metroid&quot;;\n</code></pre><p>但如果我们从C++程序的生命周期角度来看的话，就会发现，它和宏定义还是有本质区别的：<strong>const定义的常量在预处理阶段并不存在，而是直到运行阶段才会出现</strong>。</p><p>所以，准确地说，它实际上是运行时的“变量”，只不过不允许修改，是“只读”的（read only），叫“只读变量”更合适。</p><p>既然它是“变量”，那么，使用指针获取地址，再“强制”写入也是可以的。但这种做法破坏了“常量性”，绝对不提倡。这里，我只是给你做一个示范性质的实验，还要用到另外一个关键字volatile。</p><pre><code>// 需要加上volatile修饰，运行时才能看到效果\nconst volatile int MAX_LEN  = 1024;\n\nauto ptr = (int*)(&amp;MAX_LEN);\n*ptr = 2048;\ncout &lt;&lt; MAX_LEN &lt;&lt; endl;      // 输出2048\n</code></pre><p>可以看到，这段代码最开始定义的常数是1024，但是输出的却是2048。</p><!-- [[[read_end]]] --><p>你可能注意到了，const后面多出了一个volatile的修饰，它是这段代码的关键。如果没有这个volatile，那么，即使用指针得到了常量的地址，并且尝试进行了各种修改，但输出的仍然会是常数1024。</p><p>这是为什么呢？</p><p>因为“真正的常数”对于计算机来说有特殊意义，它是绝对不变的，所以编译器就要想各种办法去优化。</p><p>const常量虽然不是“真正的常数”，但在大多数情况下，它都可以被认为是常数，在运行期间不会改变。编译器看到const定义，就会采取一些优化手段，比如把所有const常量出现的地方都替换成原始值。</p><p>所以，对于没有volatile修饰的const常量来说，虽然你用指针改了常量的值，但这个值在运行阶段根本没有用到，因为它在编译阶段就被优化掉了。</p><p>现在就来看看<strong>volatile</strong>的作用。</p><p>它的含义是“不稳定的”“易变的”，在C++里，表示变量的值可能会以“难以察觉”的方式被修改（比如操作系统信号、外界其他的代码），所以要禁止编译器做任何形式的优化，每次使用的时候都必须“老老实实”地去取值。</p><p>现在，再去看刚才的那段示例代码，你就应该明白了。MAX_LEN虽然是个“只读变量”，但加上了volatile修饰，就表示它不稳定，可能会悄悄地改变。编译器在生成二进制机器码的时候，不会再去做那些可能有副作用的优化，而是用最“保守”的方式去使用MAX_LEN。</p><p>也就是说，编译器不会再把MAX_LEN替换为1024，而是去内存里取值（而它已经通过指针被强制修改了）。所以，这段代码最后输出的是2048，而不是最初的1024。</p><p>看到这里，你是不是也被const和volatile这两个关键字的表面意思迷惑了呢？我的建议是，你最好把const理解成read only（虽然是“只读”，但在运行阶段没有什么是不可以改变的，也可以强制写入），把变量标记成const可以让编译器做更好的优化。</p><p>而volatile会禁止编译器做优化，所以除非必要，应当少用volatile，这也是你几乎很少在代码里见到它的原因，我也建议你最好不要用（除非你真的知道变量会如何被“悄悄地”改变）。</p><h2>基本的const用法</h2><p>作为一个类型修饰符，const的用途非常多，除了我刚才提到的修饰变量外，下面我再带你看看它的常量引用、常量指针等其他用法。而volatile因为比较“危险”，我就不再多说了。</p><p>在C++里，除了最基本的值类型，还有引用类型和指针类型，它们加上const就成了<strong>常量引用</strong>和<strong>常量指针</strong>：</p><pre><code>int x = 100;\n\nconst int&amp; rx = x;\nconst int* px = &amp;x;\n</code></pre><p>const &amp;被称为<strong>万能引用</strong>，也就是说，它可以引用任何类型，即不管是值、指针、左引用还是右引用，它都能“照单全收”。</p><p>而且，它还会给变量附加上const特性，这样“变量”就成了“常量”，只能读、禁止写。编译器会帮你检查出所有对它的写操作，发出警告，在编译阶段防止有意或者无意的修改。这样一来，const常量用起来就非常安全了。</p><p>因此，<strong>在设计函数的时候，我建议你尽可能地使用它作为入口参数，一来保证效率，二来保证安全</strong>。</p><p>const用于指针的情况会略微复杂一点。常见的用法是，const放在声明的最左边，表示指向常量的指针。这个其实很好理解，指针指向的是一个“只读变量”，不允许修改：</p><pre><code>string name = &quot;uncharted&quot;;\nconst string* ps1 = &amp;name; // 指向常量\n*ps1 = &quot;spiderman&quot;;        // 错误，不允许修改\n</code></pre><p>另外一种比较“恶心”的用法是，const在“*”的右边，表示指针不能被修改，而指向的变量可以被修改：</p><pre><code>string* const ps2 = &amp;name;  // 指向变量，但指针本身不能被修改\n*ps2 = &quot;spiderman&quot;;        // 正确，允许修改\n</code></pre><p>再进一步，那就是“*”两边都有const，你看看是什么意思呢：</p><pre><code>const string* const ps3 = &amp;name;  // 很难看懂\n\n</code></pre><p>实话实说，我对const在“*”后面的用法“深恶痛绝”，每次看到这种形式，脑子里都会“绕一下”，实在是太难理解了，似乎感觉到了代码作者“深深的恶意”。</p><p>还是那句名言：“代码是给人看的，而不是给机器看的。”</p><p>所以，我从来不用“* const”的形式，也建议你最好不要用，而且这种形式在实际开发时也确实没有多大作用（除非你想“炫技”）。如果真有必要，也最好换成其他实现方式，让代码好懂一点，将来的代码维护者会感谢你的。</p><h2>与类相关的const用法</h2><p>刚才说的const用法都是面向过程的，在面向对象里，const也很有用。</p><p>定义const成员变量很简单，但你用过const成员函数吗？像这样：</p><pre><code>class DemoClass final\n{\nprivate:\n    const long  MAX_SIZE = 256;    // const成员变量\n    int         m_value;           // 成员变量\npublic:\n    int get_value() const        // const成员函数\n    {\n        return m_value;\n    }\n};\n</code></pre><p>注意，这里const的用法有点特别。它被放在了函数的后面，表示这个函数是一个“常量”。（如果在前面，就代表返回值是const int）</p><p>“const成员函数”的意思并不是说函数不可修改。实际上，在C++里，函数并不是变量（lambda表达式除外），所以，“只读”对于函数来说没有任何意义。它的真正含义是：函数的执行过程是const的，不会修改对象的状态（即成员变量），也就是说，<strong>成员函数是一个“只读操作”</strong>。</p><p>听起来有点平淡无奇吧，但如果你把它和刚才讲的“常量引用”“常量指针”结合起来，就不一样了。</p><p>因为“常量引用”“常量指针”关联的对象是只读、不可修改的，那么也就意味着，对它的任何操作也应该是只读、不可修改的，否则就无法保证它的安全性。所以，编译器会检查const对象相关的代码，如果成员函数不是const，就不允许调用。</p><p>这其实也是对“常量”语义的一个自然延伸，既然对象是const，那么它所有的相关操作也必然是const。同样，保证了安全之后，编译器确认对象不会变，也可以去做更好的优化。</p><p>看到这里，你会不会觉得常量引用、常量指针、常量函数这些概念有些“绕”呢？别担心，我给你总结了一个表格，看了它，以后你写代码的时候就不会晕了。</p><p><img src=\"https://static001.geekbang.org/resource/image/ed/99/ed894e66f2ee7a651aca07dffbff2799.jpg?wh=3488*1469\" alt=\"\"></p><p>这方面你还可以借鉴一下标准库，比如vector，它的empty()、size()、capacity()等查看基本属性的操作都是const的，而reserve()、clear()、erase()则是非const的。</p><h2>关键字mutable</h2><p>说到这里，就要牵扯出另一个关键字“<strong>mutable</strong>”了。</p><p>mutable与volatile的字面含义有点像，但用法、效果却大相径庭。volatile可以用来修饰任何变量，而mutable却只能修饰类里面的成员变量，表示变量即使是在const对象里，也是可以修改的。</p><p>换句话说，就是标记为mutable的成员不会改变对象的状态，也就是不影响对象的常量性，所以允许const成员函数改写mutable成员变量。</p><p>你是不是有些奇怪：“这个mutable好像有点‘多此一举’啊，它有什么用呢？”</p><p>在我看来，mutable像是C++给const对象打的一个“补丁”，让它部分可变。因为对象与普通的int、double不同，内部会有很多成员变量来表示状态，但因为“封装”特性，外界只能看到一部分状态，判断对象是否const应该由这些外部可观测的状态特征来决定。</p><p>比如说，对象内部用到了一个mutex来保证线程安全，或者有一个缓冲区来暂存数据，再或者有一个原子变量做引用计数……这些属于内部的私有实现细节，外面看不到，变与不变不会改变外界看到的常量性。这时，如果const成员函数不允许修改它们，就有点说不过去了。</p><p>所以，<strong>对于这些有特殊作用的成员变量，你可以给它加上mutable修饰，解除const的限制，让任何成员函数都可以操作它</strong>。</p><pre><code>class DemoClass final\n{\nprivate:\n    mutable mutex_type  m_mutex;    // mutable成员变量\npublic:\n    void save_data() const          // const成员函数\n    {\n        // do someting with m_mutex\n    }\n};\n\n</code></pre><p>不过要当心，mutable也不要乱用，太多的mutable就丧失了const的好处。在设计类的时候，我们一定要仔细考虑，和volatile一样要少用、慎用。</p><h2>小结</h2><p>好了，今天我和你聊了const、volatile、mutable这三个关键字，在这里简单小结一下。</p><p>1.const</p><ul>\n<li>它是一个类型修饰符，可以给任何对象附加上“只读”属性，保证安全；</li>\n<li>它可以修饰引用和指针，“const &amp;”可以引用任何类型，是函数入口参数的最佳类型；</li>\n<li>它还可以修饰成员函数，表示函数是“只读”的，const对象只能调用const成员函数。</li>\n</ul><p>2.volatile</p><p>它表示变量可能会被“不被察觉”地修改，禁止编译器优化，影响性能，应当少用。</p><p>3.mutable</p><p>它用来修饰成员变量，允许const成员函数修改，mutable变量的变化不影响对象的常量性，但要小心不要误用损坏对象。</p><p>你今后再写类的时候，就要认真想一想，哪些操作改变了内部状态，哪些操作没改变内部状态，对于只读的函数，就要加上const修饰。写错了也不用怕，编译器会帮你检查出来。</p><p>总之就是一句话：<strong>尽可能多用const，让代码更安全。</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/f0/b8/f011dc96ff693faa4d763ea36bdc67b8.jpg?wh=2250*1786\" alt=\"\"></p><p>这在多线程编程时尤其有用，让编译器帮你检查对象的所有操作，把“只读”属性持续传递出去，避免有害的副作用。</p><h2>课下作业</h2><p>最后是课下作业时间，给你留两个思考题：</p><ol>\n<li>学完了这节课，你觉得今后应该怎么用const呢？</li>\n<li>给函数的返回值加上const，也就是说返回一个常量对象，有什么好处？</li>\n</ol><p>欢迎你在留言区写下你的思考和答案，如果觉得文章对你有所帮助，也欢迎把文章分享给你的朋友，我们下节课见。</p><p><img src=\"https://static001.geekbang.org/resource/image/bd/dd/bdd9bb369fcbe65a8c879f37995a77dd.jpg?wh=2000*3156\" alt=\"\"></p>","neighbors":{"left":{"article_title":"06 | auto/decltype：为什么要有自动类型推导？","id":237964},"right":{"article_title":"08 | smart_ptr：智能指针到底“智能”在哪里？","id":239580}},"comments":[{"had_liked":false,"id":219442,"user_name":"无止境","can_delete":false,"product_type":"c1","uid":1803806,"ip_address":"","ucode":"AF77F78452E55B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/86/1e/a222129c.jpg","comment_is_top":false,"comment_ctime":1590026225,"is_pvip":false,"replies":[{"id":"81054","content":"简单来说，指针是内存地址，引用是变量别名，指针可以是空，而引用不能为空。","user_name":"作者回复","comment_id":219442,"uid":"1181974","ip_address":"","utype":1,"ctime":1590029069,"user_name_real":"chrono"}],"discussion_count":8,"race_medal":0,"score":"156208848881","product_id":100051801,"comment_content":"c++的指针和引用有啥区别老师？","like_count":36,"discussions":[{"author":{"id":1147699,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ8mLDfR5oBkDE2TF7z3c2HZibnN2vewrPvDm0WHTTGazu63wcUqX68y0WO4lZz9ibJzVhJzz9rzgdQ/132","nickname":"小查","note":"","ucode":"A40C2453147EAC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291719,"discussion_content":"C++编译器在编译的过程中使用指针常量作为引用的内部实现。Type&amp; name 等效 Type* const name","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1594914945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1328689,"avatar":"https://static001.geekbang.org/account/avatar/00/14/46/31/cb061c09.jpg","nickname":"陈小龙 Cheney","note":"","ucode":"4B721FE4DDB2F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1147699,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ8mLDfR5oBkDE2TF7z3c2HZibnN2vewrPvDm0WHTTGazu63wcUqX68y0WO4lZz9ibJzVhJzz9rzgdQ/132","nickname":"小查","note":"","ucode":"A40C2453147EAC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304596,"discussion_content":"这个是正解了, 就是一个不可改变指向的指针(constant pointer). 然后编译的时候所有的name都会被当成*name来处理. 因此对这个别名赋值就会改变原本输入参数变量的值.","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599623050,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291719,"ip_address":""},"score":304596,"extra":""},{"author":{"id":2212228,"avatar":"https://static001.geekbang.org/account/avatar/00/21/c1/84/80306d0c.jpg","nickname":"不喜欢三分钟热度的我！","note":"","ucode":"7CA76FDC683384","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1147699,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ8mLDfR5oBkDE2TF7z3c2HZibnN2vewrPvDm0WHTTGazu63wcUqX68y0WO4lZz9ibJzVhJzz9rzgdQ/132","nickname":"小查","note":"","ucode":"A40C2453147EAC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366282,"discussion_content":"按你这么说，引用也占4个内存单元？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618021071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291719,"ip_address":""},"score":366282,"extra":""}]},{"author":{"id":2417723,"avatar":"https://static001.geekbang.org/account/avatar/00/24/e4/3b/f1b9d6bf.jpg","nickname":"蔡俊贤","note":"","ucode":"A856D094E3F4A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377755,"discussion_content":"引用的底层就是指针实现的，为了提高指针的易用性，引用对指针进行了封装，增加了指向不可变和自动解引用的特性，这也是为什么引用必须初始化(因为const变量必须初始化)和引用称作别名(因为会自动解引用)的原因，","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1622809667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1286781,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a2/7d/674f97cc.jpg","nickname":"EastWind","note":"","ucode":"24AD259AFB6A9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2417723,"avatar":"https://static001.geekbang.org/account/avatar/00/24/e4/3b/f1b9d6bf.jpg","nickname":"蔡俊贤","note":"","ucode":"A856D094E3F4A3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542513,"discussion_content":"java就是这样的。java引用的本质就是指针，不可变指针。java对外概念上没有指针，只有引用。实际上就是不可变指针。内部报错会有空指针异常。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640770577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":377755,"ip_address":""},"score":542513,"extra":""}]},{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495809,"discussion_content":"简单来说，指针是内存地址，引用是变量别名，指针可以是空，而引用不能为空。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590029069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2003887,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/93/af/54e2a654.jpg","nickname":"无为而立","note":"","ucode":"A74526BF43A077","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271426,"discussion_content":"指针可以做运算，引用不行","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590135444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1286781,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a2/7d/674f97cc.jpg","nickname":"EastWind","note":"","ucode":"24AD259AFB6A9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2003887,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/93/af/54e2a654.jpg","nickname":"无为而立","note":"","ucode":"A74526BF43A077","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542519,"discussion_content":"引用本质上就是指针实现，引用说得就是引用变量地址，解引用就是把地址存放的值解出来。引用就是指针加两个功能:1.限制指针地址不可修改，2.实现自动解引用。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640771496,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":271426,"ip_address":""},"score":542519,"extra":""}]}]},{"had_liked":false,"id":227251,"user_name":"Bluebuger","can_delete":false,"product_type":"c1","uid":1994088,"ip_address":"","ucode":"946EE346371D8A","user_header":"https://static001.geekbang.org/account/avatar/00/1e/6d/68/e40b3300.jpg","comment_is_top":false,"comment_ctime":1592325403,"is_pvip":false,"replies":[{"id":"83755","content":"对，volatile在底层开发的时候用的比较多，一般做上层应用开发、比如服务器、UI就很少用了。","user_name":"作者回复","comment_id":227251,"uid":"1181974","ip_address":"","utype":1,"ctime":1592356997,"user_name_real":"罗剑锋"}],"discussion_count":2,"race_medal":0,"score":"70311802139","product_id":100051801,"comment_content":"volatile 在底层用的多，驱动、裸机开发这类。由于外部硬件设备，有部分处理器设计时候直接映射的内存地址，所以除了软件可以修改，硬件可能修改，所以需要让编译器不去优化这样的变量，必须从源头重新取值。","like_count":16,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498552,"discussion_content":"对，volatile在底层开发的时候用的比较多，一般做上层应用开发、比如服务器、UI就很少用了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592356997,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1006764,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5c/ac/8a0392fd.jpg","nickname":"晚辈曾阿牛","note":"","ucode":"012B16AE8A64FB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588346,"discussion_content":"十分感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663679555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219976,"user_name":"EncodedStar","can_delete":false,"product_type":"c1","uid":1504234,"ip_address":"","ucode":"03958CA7DDD6AE","user_header":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","comment_is_top":false,"comment_ctime":1590129841,"is_pvip":false,"replies":[{"id":"81207","content":"这个是一个通用准则，但对于int、double这样小而简单的类型就有点“重”，int这样的内建类型可以直接用const T。<br><br>Boost库里有一个call_traits，它可以推导出最佳类型。","user_name":"作者回复","comment_id":219976,"uid":"1181974","ip_address":"","utype":1,"ctime":1590134902,"user_name_real":"chrono"}],"discussion_count":1,"race_medal":0,"score":"53129737393","product_id":100051801,"comment_content":"用好const 记住文章中的“ “const &amp;”可以引用任何类型，是函数入口参数的最佳类型” 是重点","like_count":12,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496012,"discussion_content":"这个是一个通用准则，但对于int、double这样小而简单的类型就有点“重”，int这样的内建类型可以直接用const T。\n\nBoost库里有一个call_traits，它可以推导出最佳类型。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590134902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294454,"user_name":"奋斗","can_delete":false,"product_type":"c1","uid":2047392,"ip_address":"","ucode":"C84C2D030ACA51","user_header":"https://static001.geekbang.org/account/avatar/00/1f/3d/a0/acf6b165.jpg","comment_is_top":false,"comment_ctime":1621948432,"is_pvip":false,"replies":[{"id":"106846","content":"总结的非常好，awsome。","user_name":"作者回复","comment_id":294454,"uid":"1181974","ip_address":"","utype":1,"ctime":1621986701,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"35981686800","product_id":100051801,"comment_content":"《1》volitate： cpu每次读取数据的时候，如果寄存器或者三级缓存中有该值，则直接使用，所以此时如果内存中的值被改变，值不会改变。如果加上volitate每次绕过寄存器和缓存直接从内存读取，此时内存中的值已经改变了。<br>《2》mutable： 1、在lambal表达式中，如果捕获按值捕获，但是在函数体中想要修改，可以使用mutable<br>2、多线程环境下如果某个成员函数，比如int get_count() const { }，返回类中某个成员数量，势必会进行加锁保护变量达到线程安全，此时声明mutex必须是mutable的。<br>int get_count() const {<br>    std::lock_guard&lt;std::mutex&gt; lock(m)<br>    return count;<br>}<br>在声明mutable  std::mutex m; 需要加 mutable","like_count":8,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520661,"discussion_content":"总结的非常好，awsome。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621986701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239384,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1512432,"ip_address":"","ucode":"0665F3AD23890F","user_header":"https://static001.geekbang.org/account/avatar/00/17/13/f0/ce1a26be.jpg","comment_is_top":false,"comment_ctime":1596518467,"is_pvip":false,"replies":[{"id":"88420","content":"说得很好，一定不要把其他语言的经验简单地套用到C&#47;C++里，特别是volatile这个关键字，差异非常大。","user_name":"作者回复","comment_id":239384,"uid":"1181974","ip_address":"","utype":1,"ctime":1596521479,"user_name_real":"罗剑锋"}],"discussion_count":2,"race_medal":0,"score":"31661289539","product_id":100051801,"comment_content":"C++ 中volatile 关键字, 我感觉最关键的是要知道, 他根本不构成 同步语义, 多线程编程中要杜绝使用. <br>记得之前看过一个资料, volatile 从C++ 标准中出现的原因是 为了解决 &quot;硬件映射到内存上...&quot; 的问题, 也就是说 一般的开发者, 根本不会涉及到这一块. <br><br>java 中 volatile 和 C++ 中的 volatile 还不一样, java 中的volatile 是构成 happen-before的, 是可以使用在多线程编程当中的","like_count":7,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503087,"discussion_content":"说得很好，一定不要把其他语言的经验简单地套用到C/C++里，特别是volatile这个关键字，差异非常大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596521479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2777781,"avatar":"","nickname":"Geek_ff06e5","note":"","ucode":"1F62837088F68D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":397053,"discussion_content":"在多线程中加volatile关键字会在编译到汇编代码时能看到这个变量的寄存器操作 不加volatile直接没有了 编译器优化了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632551332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238550,"user_name":"Stephen","can_delete":false,"product_type":"c1","uid":1165201,"ip_address":"","ucode":"0D49223E6CB7B1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7mAt63VrbLZPHpeZxSc4IlBYswQSnaAB5wGePaGFDehgiaNfIxI1SJ5yIHIlmVk8hsw0RaoaSCPA/132","comment_is_top":false,"comment_ctime":1596196794,"is_pvip":false,"replies":[{"id":"88274","content":"是的，const常量本质上是变量，那么必然就是在运行阶段分配内存才能出现。<br><br>但现在很多时候编译器会对const常量做优化，允许在编译阶段使用，但必须要说这并不是const常量的本意。","user_name":"作者回复","comment_id":238550,"uid":"1181974","ip_address":"","utype":1,"ctime":1596416689,"user_name_real":"罗剑锋"}],"discussion_count":2,"race_medal":0,"score":"31660967866","product_id":100051801,"comment_content":"&quot;const 定义的常量在预处理阶段并不存在，而是直到运行阶段才会出现。&quot;,老师,那编译阶段它也没有出现吗?","like_count":7,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502784,"discussion_content":"是的，const常量本质上是变量，那么必然就是在运行阶段分配内存才能出现。\n\n但现在很多时候编译器会对const常量做优化，允许在编译阶段使用，但必须要说这并不是const常量的本意。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596416689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1165201,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7mAt63VrbLZPHpeZxSc4IlBYswQSnaAB5wGePaGFDehgiaNfIxI1SJ5yIHIlmVk8hsw0RaoaSCPA/132","nickname":"Stephen","note":"","ucode":"0D49223E6CB7B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296409,"discussion_content":"谢谢ヾ(≧∇≦谢谢≧∇≦)ノ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596533916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246868,"user_name":"IMBFD","can_delete":false,"product_type":"c1","uid":2149899,"ip_address":"","ucode":"2E7B3D01C537A0","user_header":"https://static001.geekbang.org/account/avatar/00/20/ce/0b/b1e244e6.jpg","comment_is_top":false,"comment_ctime":1599495441,"is_pvip":false,"replies":[{"id":"90701","content":"单从成员函数的形式上来看，是看不到this指针的，我怕这么说会让有的同学更糊涂，所以就先简单地说一下，把详细的解释放在了小贴士里。","user_name":"作者回复","comment_id":246868,"uid":"1181974","ip_address":"","utype":1,"ctime":1599526613,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"14484397329","product_id":100051801,"comment_content":"前辈在const函数那里为什么不说明其实是const修饰了this呢？这样就很好解释了","like_count":3,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505249,"discussion_content":"单从成员函数的形式上来看，是看不到this指针的，我怕这么说会让有的同学更糊涂，所以就先简单地说一下，把详细的解释放在了小贴士里。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599526613,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245344,"user_name":"宇天飞","can_delete":false,"product_type":"c1","uid":1126444,"ip_address":"","ucode":"3FB37D1E2DAA61","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/2c/06375913.jpg","comment_is_top":false,"comment_ctime":1598920728,"is_pvip":true,"replies":[{"id":"90218","content":"学习的进展很快啊，不过还是要适当保持节奏，留一点思考的时间，欲速则不达。","user_name":"作者回复","comment_id":245344,"uid":"1181974","ip_address":"","utype":1,"ctime":1598922183,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"14483822616","product_id":100051801,"comment_content":"学完了这节课，你觉得今后应该怎么用 const 呢？<br>1、修饰常量、成员变量、成员函数<br>2、修饰类的时候注意const成员以及可变成员<br><br>给函数的返回值加上 const，也就是说返回一个常量对象，有什么好处？<br>使用更方便，防止意外修改","like_count":3,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504859,"discussion_content":"学习的进展很快啊，不过还是要适当保持节奏，留一点思考的时间，欲速则不达。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598922183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219501,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1590032907,"is_pvip":false,"replies":[{"id":"81064","content":"说的挺好的，其实在effective 里对const也花了很多的篇幅，用好const真的能够让代码更安全。","user_name":"作者回复","comment_id":219501,"uid":"1181974","ip_address":"","utype":1,"ctime":1590037076,"user_name_real":"chrono"}],"discussion_count":1,"race_medal":0,"score":"14474934795","product_id":100051801,"comment_content":"1. effecttive里主要的用处就是const替换define，const成员函数，const &amp;入参<br>2.返回常量对象就是实际上保持了内部状态的不可变。不受外部影响，实际上也是不希望外部改变对象","like_count":3,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495829,"discussion_content":"说的挺好的，其实在effective 里对const也花了很多的篇幅，用好const真的能够让代码更安全。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590037076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314724,"user_name":"木须柄","can_delete":false,"product_type":"c1","uid":2706400,"ip_address":"","ucode":"54E4CB194B693F","user_header":"https://static001.geekbang.org/account/avatar/00/29/4b/e0/0fa53fed.jpg","comment_is_top":false,"comment_ctime":1633356499,"is_pvip":false,"replies":[{"id":"114005","content":"在T&amp;&amp;出现之前，const&amp;的确是万能引用，不过自从C++11新增了右值，“万能”的这个头衔就只能“让贤”了，笑。","user_name":"作者回复","comment_id":314724,"uid":"1181974","ip_address":"","utype":1,"ctime":1633437713,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"10223291091","product_id":100051801,"comment_content":"万能引用 (universal reference) 一般是指在函数模板时传入的 &quot;T&amp;&amp;&quot; 这种形参形式，主要作用是用来同时匹配左值和右值实参的传入，这里我觉得罗老师更多是借用了这个概念，主旨是为了说明 &quot;const &amp;&quot; 使用的广泛性","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527773,"discussion_content":"在T&amp;amp;&amp;amp;出现之前，const&amp;amp;的确是万能引用，不过自从C++11新增了右值，“万能”的这个头衔就只能“让贤”了，笑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633437713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223915,"user_name":"陈英桂","can_delete":false,"product_type":"c1","uid":1100348,"ip_address":"","ucode":"06E8DEE42DA82E","user_header":"https://static001.geekbang.org/account/avatar/00/10/ca/3c/f6e7ebf1.jpg","comment_is_top":false,"comment_ctime":1591232119,"is_pvip":false,"replies":[{"id":"82441","content":"<br>1.说的的很对。<br><br>2.const返回值可以强制函数的调用者无法修改，让外界用起来更安全。","user_name":"作者回复","comment_id":223915,"uid":"1181974","ip_address":"","utype":1,"ctime":1591234314,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"10181166711","product_id":100051801,"comment_content":"1、函数的入参，返回值还有变量的定义根据实际的情况，使用const来保证变量值只可以读，不可以修改。STL的迭代器也有const和非const，使用迭代器如果没有修改操作，尽量使用const版本的迭代器。<br>2、函数的返回值总const，表示返回值只可以读","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497298,"discussion_content":"\n1.说的的很对。\n\n2.const返回值可以强制函数的调用者无法修改，让外界用起来更安全。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591234314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219711,"user_name":"韩泽文","can_delete":false,"product_type":"c1","uid":1180856,"ip_address":"","ucode":"B580FA6784D3A7","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/b8/22516d1a.jpg","comment_is_top":false,"comment_ctime":1590068549,"is_pvip":false,"replies":[{"id":"81159","content":"我记得const最早是C++使用的，后来被借进了C。<br><br>const常量其实就是变量，没有内存页标记这种机制，只是编译器会做检查，运行时不会有约束。<br><br>","user_name":"作者回复","comment_id":219711,"uid":"1181974","ip_address":"","utype":1,"ctime":1590108814,"user_name_real":"chrono"}],"discussion_count":1,"race_medal":0,"score":"10180003141","product_id":100051801,"comment_content":"我之前的理解好像与这个有偏差：<br>const变量在未被优化时是分配到内存中，该内存页表标记为只读，不可写。 程序执行过程中尝试修改该内存就会页出错。<br>同样的，const在编译阶段能够起到 安全作用，凡是同一个编译单元(同一个cc文件尝试修改它就会报错)<br>上面提到的编译错误其实可以躲避编译器检查的，一般的定义时标注为const，另一cc文件引用时没有const，并且有修改操作，编译不报错的！<br>以上是c语言的理解，不知道有没有问题，<br>Cpp会对const变量符号修饰吗？","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495915,"discussion_content":"我记得const最早是C++使用的，后来被借进了C。\n\nconst常量其实就是变量，没有内存页标记这种机制，只是编译器会做检查，运行时不会有约束。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590108814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359782,"user_name":"Loca..","can_delete":false,"product_type":"c1","uid":3198947,"ip_address":"北京","ucode":"CCC2E48916F0F7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/BUJPBATdJ5PiaPbSPJjzfgwCvSu6QOmQSC1GY7At4spmhzO5xaxwTuVAkKrVxom0NkJclnULUqMdPlhdfpiaxEXw/132","comment_is_top":false,"comment_ctime":1665892550,"is_pvip":false,"replies":[{"id":"130887","content":"const在理论上只能在运行阶段出现，但现实情况是很多编译器为它做了特别的优化，而且因为const不变，在泛型和模板元编程里也可以在编译期使用。<br>但编译阶段的常量正确来说应该用constexpr来声明。","user_name":"作者回复","comment_id":359782,"uid":"1181974","ip_address":"北京","utype":1,"ctime":1665914550,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1665892550","product_id":100051801,"comment_content":"我有一个问题，1.既然const在运行阶段才出现，那么文章后面所说的，对没有用volatile的const常量即使指针修改了值，他还是没用，因为在编译阶段被优化了，一个运行阶段才出现的值，怎么会在编译阶段被优化。所以我的问题是，const是不是在编译阶段就已经出现了呢","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590608,"discussion_content":"const在理论上只能在运行阶段出现，但现实情况是很多编译器为它做了特别的优化，而且因为const不变，在泛型和模板元编程里也可以在编译期使用。\n但编译阶段的常量正确来说应该用constexpr来声明。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665914550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347611,"user_name":"搬铁少年ai","can_delete":false,"product_type":"c1","uid":1031045,"ip_address":"","ucode":"01D4A830A088D7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bb/85/191eea69.jpg","comment_is_top":false,"comment_ctime":1654224216,"is_pvip":false,"replies":[{"id":"126767","content":"对的，一般来说返回const&amp;是最常见的用法。","user_name":"作者回复","comment_id":347611,"uid":"1181974","ip_address":"","utype":1,"ctime":1654414454,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1654224216","product_id":100051801,"comment_content":"函数返回值如果是return by value 就没必要加const了，除非返回的是一个引用。那可不可以不返回引用就直接返回一个值呢？可能具体情况还要具体看。多数情况应该没必要","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574864,"discussion_content":"对的，一般来说返回const&amp;是最常见的用法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654414454,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347471,"user_name":"Kermit","can_delete":false,"product_type":"c1","uid":1397288,"ip_address":"","ucode":"6C0F2F5B4319DD","user_header":"https://static001.geekbang.org/account/avatar/00/15/52/28/58d7fe3d.jpg","comment_is_top":false,"comment_ctime":1654064687,"is_pvip":false,"replies":[{"id":"126690","content":"个人意见，指针的用法对人的思维是种折磨，所以很多其他语言也都避免指针。<br><br>C++延续了C，指针不能不用，但还是少用，尽量让人能够理解。<br><br>* const用起来没问题，但日后的维护，别人看就不好说了。","user_name":"作者回复","comment_id":347471,"uid":"1181974","ip_address":"","utype":1,"ctime":1654086208,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1654064687","product_id":100051801,"comment_content":"（我对 const 在“*”后面的用法“深恶痛绝”，每次看到这种形式，脑子里都会“绕一下”，实在是太难理解了，似乎感觉到了代码作者“深深的恶意”）<br>这句话我遇到一些case，比如 Object* const obj_; 后续一个方法会对Object 对象的属性进行update，这里是不是 使用* const 会更好点，因为毕竟还是要对obj进行数据update。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574496,"discussion_content":"个人意见，指针的用法对人的思维是种折磨，所以很多其他语言也都避免指针。\n\nC++延续了C，指针不能不用，但还是少用，尽量让人能够理解。\n\n* const用起来没问题，但日后的维护，别人看就不好说了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654086208,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310489,"user_name":"王兵","can_delete":false,"product_type":"c1","uid":1619231,"ip_address":"","ucode":"73764DF6E2AA69","user_header":"https://static001.geekbang.org/account/avatar/00/18/b5/1f/2b2dfb2e.jpg","comment_is_top":false,"comment_ctime":1630676966,"is_pvip":false,"replies":[{"id":"112498","content":"返回值是const就显式地表示不能被修改，调用者拿到结果后只能做常量应用。<br><br>像这里返回const int，就意味着函数调用后出来的就是一个常量值，不是变量，可以避免一些意外的副作用。<br><br>另外，在c++17&#47;20之后，返回const int的函数还可以用在编译期编程里，而不仅局限在运行时。","user_name":"作者回复","comment_id":310489,"uid":"1181974","ip_address":"","utype":1,"ctime":1630730638,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"1630676966","product_id":100051801,"comment_content":"公司里的c++代码的类成员函数有很多都是const int之类的基础类型函数返回值，一直不理解为啥要加const。个人理解没有任何意义。之前一直做c开发，对c++不太了解，望老师解惑。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526249,"discussion_content":"返回值是const就显式地表示不能被修改，调用者拿到结果后只能做常量应用。\n\n像这里返回const int，就意味着函数调用后出来的就是一个常量值，不是变量，可以避免一些意外的副作用。\n\n另外，在c++17/20之后，返回const int的函数还可以用在编译期编程里，而不仅局限在运行时。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630730638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240023,"user_name":"张飞Dear","can_delete":false,"product_type":"c1","uid":2004589,"ip_address":"","ucode":"EECEDF12DC7EB9","user_header":"https://static001.geekbang.org/account/avatar/00/1e/96/6d/85723167.jpg","comment_is_top":false,"comment_ctime":1596717974,"is_pvip":false,"replies":[{"id":"88640","content":"说得很好。","user_name":"作者回复","comment_id":240023,"uid":"1181974","ip_address":"","utype":1,"ctime":1596761929,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"1596717974","product_id":100051801,"comment_content":"1，<br>（1）定义函数入口参数，尽量多的用const， 对于一些输入参数 可以直接使用const &amp; 万能引用来做入口。 <br>（2）在类中定义一些const 函数，让编译器更好的优化。<br>（3）多用const 来定义一些常量，少用 #define 来定义常量，让代码更安全。<br>2，返回常量对象，只读状态，不让外界进行操作。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503310,"discussion_content":"说得很好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596761929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233393,"user_name":"怪兽","can_delete":false,"product_type":"c1","uid":1324007,"ip_address":"","ucode":"3342C55CB83B08","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/e7/145be2f9.jpg","comment_is_top":false,"comment_ctime":1594306547,"is_pvip":false,"replies":[{"id":"86146","content":"<br>1，加k是有些公司的命名风格，k大概是const的简化吧。<br><br>2.理解基本正确，constexpr还可以用在编译期计算，实现编译期函数、模板元编程。","user_name":"作者回复","comment_id":233393,"uid":"1181974","ip_address":"","utype":1,"ctime":1594343096,"user_name_real":"罗剑锋"}],"discussion_count":2,"race_medal":0,"score":"1594306547","product_id":100051801,"comment_content":"1. 常量的名称都是大写，但前面加k前缀表。这是什么风格？为什么是k？<br>2. constexpr关键字是表示编译阶段的常量，而const表示运行时期的常量，只不过被编译器优化了，是这样理解吗？const和constexpr还有什么区别吗？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501007,"discussion_content":"\n1，加k是有些公司的命名风格，k大概是const的简化吧。\n\n2.理解基本正确，constexpr还可以用在编译期计算，实现编译期函数、模板元编程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594343096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2212228,"avatar":"https://static001.geekbang.org/account/avatar/00/21/c1/84/80306d0c.jpg","nickname":"不喜欢三分钟热度的我！","note":"","ucode":"7CA76FDC683384","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366293,"discussion_content":"k前缀我好像在哪见过，说是keep的简写","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618022307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225556,"user_name":"itsiam","can_delete":false,"product_type":"c1","uid":1463316,"ip_address":"","ucode":"839F58E7C88F13","user_header":"https://static001.geekbang.org/account/avatar/00/16/54/14/ca4a1ae9.jpg","comment_is_top":false,"comment_ctime":1591785376,"is_pvip":false,"replies":[{"id":"83100","content":"对，这样外界用起来更加安全，给出去也放心。","user_name":"作者回复","comment_id":225556,"uid":"1181974","ip_address":"","utype":1,"ctime":1591790972,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"1591785376","product_id":100051801,"comment_content":"给函数返回值加const， 返回常量对象，可以保证改实例的成员变量不被修改。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497894,"discussion_content":"对，这样外界用起来更加安全，给出去也放心。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591790972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220918,"user_name":"沉淀的梦想","can_delete":false,"product_type":"c1","uid":1177315,"ip_address":"","ucode":"BCB7C26F9D214B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg","comment_is_top":false,"comment_ctime":1590336628,"is_pvip":false,"replies":[{"id":"81456","content":"“万能引用”也要类型对才行，你的函数入口是const int&amp;，而传入的是int*，这两个类型不匹配，那就肯定是不行的。<br><br>C++对类型的检查比较严格，这方面确实还要再学习了解一下。","user_name":"作者回复","comment_id":220918,"uid":"1181974","ip_address":"","utype":1,"ctime":1590367940,"user_name_real":"chrono"}],"discussion_count":4,"race_medal":0,"score":"1590336628","product_id":100051801,"comment_content":"不太理解老师所说的 `const &amp;`  万能引用，写了个 demo 发现编译不不过啊：<br><br>```<br>int test(const int&amp; any) {<br><br>}<br><br>int main() {<br>    int a = 2;<br>    &#47;&#47; error: invalid conversion from ‘int*’ to ‘int’<br>    test(&amp;a);<br>}<br>```<br><br>因为本人工作中写的语言不是 c++，出于兴趣来学习的，问题可能有点小白，老师见谅。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496265,"discussion_content":"“万能引用”也要类型对才行，你的函数入口是const int&amp;amp;，而传入的是int*，这两个类型不匹配，那就肯定是不行的。\n\nC++对类型的检查比较严格，这方面确实还要再学习了解一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590367940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1441830,"avatar":"https://static001.geekbang.org/account/avatar/00/16/00/26/a80010f0.jpg","nickname":"JL","note":"","ucode":"07BD8069AE2CBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279792,"discussion_content":"直接传入 a 就行了。 test（a）\n&amp;a 指的是 a的地址 所以就是一个指针了。\nint* p_a = &amp;a;  // 指针\nint&amp; a1 = a;     // 引用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591416600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1212323,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","nickname":"robonix","note":"","ucode":"866EC82EDA455B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274383,"discussion_content":"那么该如何去写，才能引用一个指针类型呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590578011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1441830,"avatar":"https://static001.geekbang.org/account/avatar/00/16/00/26/a80010f0.jpg","nickname":"JL","note":"","ucode":"07BD8069AE2CBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1212323,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","nickname":"robonix","note":"","ucode":"866EC82EDA455B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279793,"discussion_content":"int test(const int* a)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591416642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":274383,"ip_address":""},"score":279793,"extra":""}]}]},{"had_liked":false,"id":220651,"user_name":"汪zZ","can_delete":false,"product_type":"c1","uid":1234757,"ip_address":"","ucode":"8B93062A683902","user_header":"https://static001.geekbang.org/account/avatar/00/12/d7/45/d1621188.jpg","comment_is_top":false,"comment_ctime":1590304408,"is_pvip":true,"replies":[{"id":"81422","content":"不知道是哪个学校的学弟，见笑了。<br><br>const的用法比较零散，但又的确很重要，所以很有必要特别说一下。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1590328074,"ip_address":"","comment_id":220651,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1590304408","product_id":100051801,"comment_content":"突然发现是学长啊。<br>感觉C++ Primer挺好的，如果看得过程中留意变量定义，会归纳出const的用法的，其实照着书上的例子好好的理解为什么用const，什么时候用，也就懂了。当然老师你归纳得也非常好。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496202,"discussion_content":"不知道是哪个学校的学弟，见笑了。\n\nconst的用法比较零散，但又的确很重要，所以很有必要特别说一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590328074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220530,"user_name":"xGdl","can_delete":false,"product_type":"c1","uid":2004988,"ip_address":"","ucode":"5ADD896F62A2B8","user_header":"https://static001.geekbang.org/account/avatar/00/1e/97/fc/0ca13c5c.jpg","comment_is_top":false,"comment_ctime":1590282905,"is_pvip":false,"replies":[{"id":"81427","content":"<br>1.*const用法仔细阅读也能理解，但这需要花费不少力气，我希望的是代码尽量让人轻松阅读，不是所有人都能或者愿意掌握复杂的指针用法的。<br><br>2.看C++应该看标准，尽量不要依赖编译器，volatile本身不具有原子性，应该用atomic库。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1590328413,"ip_address":"","comment_id":220530,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1590282905","product_id":100051801,"comment_content":"对于const，存在常量折叠，老师所说的readonly非常到位，但对于const前后的*，只需要掌握类型的读取规则其实也就很简单《c++语法详解》，左结合优先即可。<br><br>volatile修饰，阻止编译器优化，听说在msvc具有原子保证，而gcc不保证。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496169,"discussion_content":"\n1.*const用法仔细阅读也能理解，但这需要花费不少力气，我希望的是代码尽量让人轻松阅读，不是所有人都能或者愿意掌握复杂的指针用法的。\n\n2.看C++应该看标准，尽量不要依赖编译器，volatile本身不具有原子性，应该用atomic库。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590328413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2004988,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/97/fc/0ca13c5c.jpg","nickname":"xGdl","note":"","ucode":"5ADD896F62A2B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279000,"discussion_content":"是的，atomic真香，不过我不喜欢内存屏障这个词。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591271098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220301,"user_name":"silverhawk","can_delete":false,"product_type":"c1","uid":1018649,"ip_address":"","ucode":"BFBC8AF32868DA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8b/19/a15d060d.jpg","comment_is_top":false,"comment_ctime":1590221790,"is_pvip":false,"replies":[{"id":"81317","content":"说的很好，我还见过const char * const * const，太可怕了。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1590230711,"ip_address":"","comment_id":220301,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590221790","product_id":100051801,"comment_content":" const 那个左右是遗传自C的那个左右法则，写代码时候也深恶痛绝，尤其是几层嵌套的const，最好加个括号一目了然。另外volatile也是经常需要跟硬件打交道的地方比较多，比如某个寄存器的值，可能程序不会修改但是被硬件中段信号修改，不过这些现在C++用不太到 了","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496116,"discussion_content":"说的很好，我还见过const char * const * const，太可怕了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590230711,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220105,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1590158218,"is_pvip":false,"replies":[{"id":"81284","content":"int func(const T&amp; x )，这样，无论x是什么类型，都可以接受，而且在函数体里不会被改变。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1590204409,"ip_address":"","comment_id":220105,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1590158218","product_id":100051801,"comment_content":"&quot;它可以修饰引用和指针，“const &amp;”可以引用任何类型，是函数入口参数的最佳类型&quot;<br><br>不太理解这个，能麻烦举个例子吗？<br><br>谢谢！","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496047,"discussion_content":"int func(const T&amp;amp; x )，这样，无论x是什么类型，都可以接受，而且在函数体里不会被改变。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590204409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2041484,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/kUgXE9azak3lmKM5h1icdNLSW5xoM0vKcEHibmN9YuianC11ibdaqicyZMUicTZVEweGtb9HUPeCCvIbmBPIBvibBkWBA/132","nickname":"Geek_a5d0ae","note":"","ucode":"FFA0C9FE8A39D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301146,"discussion_content":"非const常量和const常量都可以绑定到const引用上，但const常量不能绑定到非const常量上。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598424205,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219864,"user_name":"java2c++","can_delete":false,"product_type":"c1","uid":1460660,"ip_address":"","ucode":"C4F8C3D7B1A910","user_header":"","comment_is_top":false,"comment_ctime":1590111932,"is_pvip":false,"replies":[{"id":"81168","content":"前半句说的比较对，后面我觉得有点问题。<br><br>const常量不一定会在编译阶段做替换，这个不是标准里规定的，只是很多编译器都这么做来实现优化，不能把这种做法当成是必然。<br><br>const常量还是应该理解成运行时只读的变量。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1590117433,"ip_address":"","comment_id":219864,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590111932","product_id":100051801,"comment_content":"1.成员变量采用const代替宏定义define，功效有点类似于Java的final关键字，目的只是为了编译环节进行替换","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495970,"discussion_content":"前半句说的比较对，后面我觉得有点问题。\n\nconst常量不一定会在编译阶段做替换，这个不是标准里规定的，只是很多编译器都这么做来实现优化，不能把这种做法当成是必然。\n\nconst常量还是应该理解成运行时只读的变量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590117433,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219698,"user_name":"蓝配鸡","can_delete":false,"product_type":"c1","uid":1348738,"ip_address":"","ucode":"C79A7CA8885B7C","user_header":"https://static001.geekbang.org/account/avatar/00/14/94/82/d0a417ba.jpg","comment_is_top":false,"comment_ctime":1590066116,"is_pvip":false,"replies":[{"id":"81156","content":"读C++多，那可以试着自己改写优化一下这些代码。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1590108627,"ip_address":"","comment_id":219698,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1590066116","product_id":100051801,"comment_content":"拿什么练手呢...工作中读C++较多， 写的少。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495908,"discussion_content":"读C++多，那可以试着自己改写优化一下这些代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590108627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1441830,"avatar":"https://static001.geekbang.org/account/avatar/00/16/00/26/a80010f0.jpg","nickname":"JL","note":"","ucode":"07BD8069AE2CBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279795,"discussion_content":"可以拿cpp 刷题。感觉刷题是熟练一门语言的很高效的方法之一","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591416746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219394,"user_name":"lckfa李钊","can_delete":false,"product_type":"c1","uid":1356899,"ip_address":"","ucode":"AD13D205104AA6","user_header":"https://static001.geekbang.org/account/avatar/00/14/b4/63/84960032.jpg","comment_is_top":false,"comment_ctime":1590021900,"is_pvip":false,"replies":[{"id":"81038","content":"说得挺好的。<br><br>返回const对象，就能保证它是安全不会被改变的，限制了它的内外部影响。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1590022814,"ip_address":"","comment_id":219394,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590021900","product_id":100051801,"comment_content":"在所有能使用const的地方使用const，增强代码的健壮性，使用多了，你未必看到它的好，但是它确实在那里发挥着作用，这样的回答有点人云亦云了。<br>返回一个常量对象，最直接的作用是保证在函数返回时无法直接修改这个对象，比如 funcret()++ ，这种代码会在编译器失败，可以起到保护对象的作用。其他的好处需要老师指点下了<br>","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495795,"discussion_content":"说得挺好的。\n\n返回const对象，就能保证它是安全不会被改变的，限制了它的内外部影响。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590022814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}