{"id":741044,"title":"第 19 章 MySQL Replication配置","content":"\n<p>MySQL Replication又称“AB复制”或者“主从复制”，它主要用于MySQL的实时备份或者读写分离。在配置之前先做一下准备工作：配置两台MySQL服务器，或者在一台服务器上配置两个端口。在本章的试验中，阿铭就是在一台服务器上运行两个MySQL。</p>\n<h2 id=\"nav_point_367\">19.1 配置MySQL服务</h2>\n<p>配置MySQL服务的详细步骤请参考14.1节，阿铭在这里只写出简要步骤。假如你已经根据14.1节搭建好了一个MySQL，使用的是3306端口，那么下面再搭建一个3307端口的MySQL，方法如下：</p>\n<pre class=\"code-rows\"><code># cd /usr/local/\n# cp -r mysql mysql_2\n# cd mysql_2\n# cp /etc/my.cnf ./my.cnf\n# vim ./my.cnf // 修改为如下内容\nlog_bin = aminglinux2\nbasedir = /usr/local/mysql_2\ndatadir = /data/mysql2\nport = 3307\nserver_id = 129\nsocket = /tmp/mysql2.sock\n# ./bin/mysqld --defaults-file=./my.cnf --initialize --user=mysql</code></pre>\n<p>初始化时会有一些<code>warning</code>，不用关注，只要没有<code>error</code>信息就说明初始化成功了，同时我们会看到一个临时密码：</p>\n<pre class=\"code-rows\"><code>[Note] A temporary password is generated for root@localhost: WkCTkeQE2/zp</code></pre>\n<p>先记录一下这个密码，后面需要使用该临时密码，然后修改一个新密码。下面启动该MySQL：</p>\n<pre class=\"code-rows\"><code># cp support-files/mysql.server /etc/init.d/mysqld2\n# vim /etc/init.d/mysqld2</code></pre>\n<p>需要更改的地方有：</p>\n<pre class=\"code-rows\"><code>basedir=/usr/local/mysql_2\ndatadir=/data/mysql2\nmysqld_pid_file_path=$datadir/mysql.pid\n$bindir/mysqld_safe --defaults-file=\"basedir/my.cnf\" --datadir=\"$datadir\" --pid-file=\"$mysqld_pid_file_path\" $other_args &gt;/dev/null &amp;</code></pre>\n<p>最后一行为启动命令，增加了<code>--defaults</code>参数，若不增加此参数，则不能正确找到mysql_2的配置文件。</p>\n<p>然后启动两个MySQL：</p>\n<pre class=\"code-rows\"><code># /etc/init.d/mysqld start // 若之前的MySQL已经启动，则不用执行该步骤\n# /etc/init.d/mysqld2 start</code></pre>\n<p>到此，阿铭已经在一个Linux上启动了两个MySQL，检查命令如下所示：</p>\n<pre class=\"code-rows\"><code># netstat -lnp |grep mysql\ntcp6 0 0 :::3306 :::* LISTEN 68934/mysqld\ntcp6 0 0 :::3307 :::* LISTEN 73724/mysqld\nunix 2 [ ACC ] STREAM LISTENING 240004 68934/mysqld /tmp/mysql.sock\nunix 2 [ ACC ] STREAM LISTENING 271861 73724/mysqld /tmp/mysql2.sock</code></pre>\n<h2 id=\"nav_point_368\">19.2 配置Replication</h2>\n<p>阿铭打算把3307端口的MySQL作为master（主），而把3306的MySQL作为slave（从）。为了让试验更加接近生产环境，阿铭先在master上创建一个库<code>aming</code>，如下所示：</p><!-- [[[read_end]]] -->\n<pre class=\"code-rows\"><code># mysqladmin -uroot -S/tmp/mysql2.sock -p'WkCTkeQE2/zp' password 'aming123' // 修改密码\n# mysql -uroot -S/tmp/mysql2.sock –p'aming123'\nmysql: [Warning] Using a password on the command line interface can be insecure.\nWelcome to the MySQL monitor. Commands end with ; or \\g.\nYour MySQL connection id is 5\nServer version: 5.7.29-log MySQL Community Server (GPL)\n\nCopyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.\n\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\nmysql&gt; create database aming;\nQuery OK, 1 row affected (0.00 sec)\nmysql&gt; quit\nBye</code></pre>\n<p>其中，<code>-S</code>（大写字母）后面指定MySQL的socket文件路径，这也是登录MySQL的一种方法。因为阿铭在一台服务器上运行了两个MySQL端口，所以用<code>-S</code>这样的方法来区分。</p>\n<p>然后把<code>mysql</code>库的数据复制给<code>aming</code>库，如下所示：</p>\n<pre class=\"code-rows\"><code># mysqldump -uroot -S/tmp/mysql2.sock -p'aming123' mysql &gt; /tmp/aming.sql\n# mysql -uroot -S/tmp/mysql2.sock -p'aming123' aming &lt; /tmp/aming.sql</code></pre>\n<h3 id=\"nav_point_369\">19.2.1 设置master（主）</h3>\n<p>在上面的操作过程中，阿铭已经将mysql_2的配置文件设置过相关的参数，如果你的没有设置，请添加：</p>\n<pre class=\"code-rows\"><code>server-id=129\nlog_bin=aminglinux2</code></pre>\n<p>另外，还有两个参数你可以选择性地使用，如下所示：</p>\n<pre class=\"code-rows\"><code>binlog-do-db=databasename1,databasename2\nbinlog-ignore-db=databasename1,databasename2</code></pre>\n<p>其中，<code>binlog-do-db=</code>定义需要复制的数据库，多个数据库用英文逗号分隔；<code>binlog-ignore-db=</code>定义不需要复制的数据库，这两个参数用其中一个即可。</p>\n<p>如果修改过配置文件，需要重启MySQL服务。重启服务的方法如下：</p>\n<pre class=\"code-rows\"><code># /etc/init.d/mysqld2 restart</code></pre>\n<p>重新登录mysql2，然后创建一个用来实现主从的用户，如下所示：</p>\n<pre class=\"code-rows\"><code># mysql -uroot -S/tmp/mysql2.sock -p'aming123'\nmysql&gt; grant replication slave on *.* to 'repl'@'127.0.0.1' identified by '123lalala';\nmysql&gt; flush privileges;</code></pre>\n<p>这里的<code>repl</code>是为slave（从）端设置的访问master（主）端的用户，也就是要完成主从复制的用户，其密码为123lalala，这里的127.0.0.1为slave的IP（因为阿铭配置的master和slave都在本机）。第二条命令<code>flush privileges</code>将内存数据写入磁盘，这样刚刚创建的用户和权限才能生效。下面的操作将锁定数据库写操作：</p>\n<pre class=\"code-rows\"><code>mysql&gt; flush tables with read lock;</code></pre>\n<p>下面的操作用于查看<code>master</code>的状态：</p>\n<pre class=\"code-rows\"><code>mysql&gt; show master status;</code></pre>\n<p>这些数据是要记录的，一会儿要在slave端用到：</p>\n<pre class=\"code-rows\"><code>+------------------+---------+------------+-----------------+------------------+\n| File |Position |Binlog_Do_DB|Binlog_Ignore_DB |Executed_Gtid_Set |\n+------------------+---------+------------+-----------------+------------------+\n|aminglinux2.000003| 445 | | | |\n+------------------+---------+------------+-----------------+------------------+</code></pre>\n<h3 id=\"nav_point_370\">19.2.2 设置slave（从）</h3>\n<p>首先修改slave端的配置文件my.cnf，执行如下命令：</p>\n<pre class=\"code-rows\"><code># vim /etc/my.cnf</code></pre>\n<p>找到<code>server_id =</code>，将之设置成和<code>master</code>不一样的数字，若一样，则会导致后面的操作不成功。另外在slave端，你也可以选择性地增加如下两行，对应master端增加的两行：</p>\n<pre class=\"code-rows\"><code>replicate-do-db=databasename1,databasename2\nreplicate-ignore-db=databasename1,databasename2</code></pre>\n<p>保存修改后重启slave，执行如下命令：</p>\n<pre class=\"code-rows\"><code># /etc/init.d/mysqld restart</code></pre>\n<p>然后复制master上<code>aming</code>库的数据到slave上。因为master和slave都在一台服务器上，所以操作起来很简单。如果在不同的机器上，就需要远程复制了（使用<code>scp</code>或者<code>rsync</code>）。首先备份master上的aming库：</p>\n<pre class=\"code-rows\"><code># mysqldump -uroot -S/tmp/mysql2.sock -p'aming123' aming &gt; /tmp/aming2.sql\n# mysql -uroot -S/tmp/mysql.sock -p'aming123' -e \"create database aming\"\n# mysql -uroot -S/tmp/mysql.sock -p'aming123' aming&lt; /tmp/aming2.sql</code></pre>\n<p>上面的第二行中，阿铭使用了<code>-e</code>选项，它用来把MySQL的命令写到shell命令行下，其格式为：<code>-e\"commond\"</code>。<code>-e</code>选项很实用，阿铭经常使用，请熟记。</p>\n<p>复制完数据后，就需要在slave上配置了，如下所示：</p>\n<pre class=\"code-rows\"><code># mysql -uroot -S/tmp/mysql.sock -p'aming123'\nmysql&gt; stop slave;\nmysql&gt; change master to master_host='127.0.0.1',\nmaster_port=3307, master_user='repl',\nmaster_password='123lalala',\nmaster_log_file='aminglinux2.000003',\nmaster_log_pos=445;\nmysql&gt; start slave;</code></pre>\n<p>需要说明一下：<code>change master</code>这个命令是一大条，打完逗号后可以按回车，直到你打分号才算结束。其中，<code>master_log_file</code>和<code>master_log_pos</code>是在前面使用<code>show master status</code>命令所查到的数据。执行完这一步后，需要在master上执行下面一步（建议打开两个终端，分别连接两个MySQL）：</p>\n<pre class=\"code-rows\"><code># mysql -uroot -S/tmp/mysql2.sock -p'aming123' -e \"unlock tables\"</code></pre>\n<p>然后在slave端查看slave的状态，执行如下命令：</p>\n<pre class=\"code-rows\"><code>mysql&gt; show slave status\\G</code></pre>\n<p>确认以下两项参数都为<code>Yes</code>，如下所示：</p>\n<pre class=\"code-rows\"><code>Slave_IO_Running: Yes\nSlave_SQL_Running: Yes</code></pre>\n<p>还需要关注的地方有：</p>\n<pre class=\"code-rows\"><code>Seconds_Behind_Master: 0 // 为主从复制延迟的时间\nLast_IO_Errno: 0\nLast_IO_Error:\nLast_SQL_Errno: 0\nLast_SQL_Error:</code></pre>\n<p>如果主从不正常了，需要看这里的<code>error</code>信息。</p>\n<h2 id=\"nav_point_371\">19.3 测试主从</h2>\n<p>在master上执行如下命令：</p>\n<pre class=\"code-rows\"><code># mysql -uroot -S/tmp/mysql2.sock -p'aming123' aming\nmysql&gt; select count(*) from db;\n+----------+\n| count(*) |\n+----------+\n| 2 |\n+----------+\nmysql&gt; truncate table db;\nmysql&gt; select count(*) from db;\n\n+----------+\n| count(*) |\n+----------+\n| 0 |\n+----------+</code></pre>\n<p>这样就清空了<code>aming.db</code>表的数据。下面查看slave上该表的数据，执行如下命令：</p>\n<pre class=\"code-rows\"><code># mysql -uroot -S/tmp/mysql.sock –p'aming123' aming\nmysql&gt; select count(*) from db;\n+----------+\n| count(*) |\n+----------+\n| 0 |\n+----------+</code></pre>\n<p>slave上该表的数据也被清空了，但好像不太明显，我们不妨在master上继续删除<code>db</code>表，如下所示：</p>\n<pre class=\"code-rows\"><code>mysql&gt; drop table db;\nQuery OK, 0 rows affected (0.00 sec)</code></pre>\n<p>再从slave端查看：</p>\n<pre class=\"code-rows\"><code>mysql&gt; select * from db;\nERROR 1146 (42S02): Table 'aming.db' doesn't exist</code></pre>\n<p>这次很明显了，<code>db</code>表已经不存在。主从配置虽然很简单，但这种机制非常脆弱，一旦我们不小心在slave上写了数据，那么主从复制也就被破坏了。另外，如果要重启master，务必要先关闭slave，即在slave上执行<code>slave stop</code>命令，然后去重启master的MySQL服务，否则主从复制很有可能就会中断。当然，重启master后，我们还需要执行<code>start slave</code>命令开启主从复制的服务。</p>\n<h2 id=\"nav_point_372\">19.4 课后习题</h2>\n<p>(1) MySQL Replication模式主要应用于什么场景呢？</p>\n<p>(2) 在一台服务器上同时配置两个MySQL服务，如果已经配置完一个，配置另一个时如何更改监听端口？</p>\n<p>(3) 如果想让MySQL开机启动，需要把启动命令放到哪个文件下？</p>\n<p>(4) 在master配置文件中，都修改了哪几个配置选项？</p>\n<p>(5) 如何给MySQL设置root密码？</p>\n<p>(6) 配置Replication模式时，在master上需要给slave授予什么样的权限？</p>\n<p>(7) MySQL的哪一个选项可以不进入MySQL的命令控制台，而使用SQL语句操作？</p>\n<p>(8) 如何在slave上查看主从复制是否正常？</p>\n<p>(9) Replication模式下，如果想重启master，必须先对slave做什么？</p>\n\n<br style=\"page-break-after:always\" />","comments":[]}