{"id":740939,"title":"2.4 优先队列","content":"\n<p>许多应用程序都需要处理有序的元素，但不一定要求它们全部有序，或是不一定要一次就将它们排序。很多情况下我们会收集一些元素，处理当前键值最大的元素，然后再收集更多的元素，再处理当前键值最大的元素，如此这般。例如，你可能有一台能够同时运行多个应用程序的电脑（或者手机）。这是通过为每个应用程序的事件分配一个优先级，并总是处理下一个优先级最高的事件来实现的。例如，绝大多数手机分配给来电的优先级都会比游戏程序的高。</p>\n<p>在这种情况下，一个合适的数据结构应该支持两种操作：<strong>删除最大元素</strong>和<strong>插入元素</strong>。这种数据类型叫做<strong>优先队列</strong>。优先队列的使用和队列（删除最老的元素）以及栈（删除最新的元素）类似，但高效地实现它则更有挑战性。</p>\n<p>在本节中，简单地讨论优先队列的基本表现形式（其一或者两种操作都能在线性时间内完成）之后，我们会学习基于<strong>二叉堆</strong>数据结构的一种优先队列的经典实现方法，用数组保存元素并按照一定条件排序，以实现高效地（对数级别的）<strong>删除最大元素</strong>和<strong>插入元素操作</strong>。</p>\n<p>优先队列的一些重要的应用场景包括模拟系统，其中事件的键即为发生的时间，而系统需要按照时间顺序处理所有事件；任务调度，其中键值对应的优先级决定了应该首先执行哪些任务；数值计算，键值代表计算错误，而我们需要按照键值指定的顺序来修正它们。在第 6 章中我们会学习一个具体的例子，展示优先队列在粒子碰撞模拟中的应用。</p><!-- [[[read_end]]] -->\n<p>通过插入一列元素然后一个个地删掉其中最小的元素，我们可以用优先队列实现排序算法。一种名为<strong>堆排序</strong>的重要排序算法也来自于基于堆的优先队列的实现。稍后在本书中我们会学习如何用优先队列构造其他算法。在第 4 章中我们会看到优先队列如何恰到好处地抽象若干重要的图搜索算法；在第 5 章中，我们将使用本节所示的方法开发出一种数据压缩算法。这些只是优先队列作为算法设计工具所起到的举足轻重的作用的一部分例子。</p>\n<h3 id=\"nav_point_98\">2.4.1　API</h3>\n<p>优先队列是一种<strong>抽象数据类型</strong>（请见 1.2 节），它表示了一组值和对这些值的操作，它的抽象层使我们能够方便地将应用程序（用例）和我们将在本节中学习的各种具体实现隔离开来。和 1.2 节一样，我们会详细定义一组应用程序编程接口（API）来为数据结构的用例提供足够的信息（参见表 2.4.1）。优先队列最重要的操作就是<strong>删除最大元素</strong>和<strong>插入元素</strong>，所以我们会把精力集中在它们身上。删除最大元素的方法名为 <code>delMax()</code>，插入元素的方法名为 <code>insert()</code>。按照惯例，我们只会通过辅助函数 <code>less()</code> 来比较两个元素，和排序算法一样。如果允许重复元素，<strong>最大</strong>表示的是所有最大元素之一。为了将 API 定义完整，我们还需要加入构造函数（和我们在栈以及队列中使用的类似）和一个<strong>空队列测试方法</strong>。为了保证灵活性，我们在实现中使用了泛型，将实现了 <code>Comparable</code> 接口的数据的类型作为参数 <code>Key</code>。这使得我们可以不必再区别元素和元素的键，对数据类型和算法的描述也将更加清晰和简洁。例如，我们将用“最大元素”代替“最大键值”或是“键值最大的元素”。</p>\n<p><strong>表 2.4.1　泛型优先队列的 API</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td colspan=\"2\"><code>public class&nbsp;&nbsp;<b>MaxPQ</b>&lt;Key extends Comparable&lt;Key&gt;&gt;</code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MaxPQ()</code></td><td>创建一个优先队列</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MaxPQ(int max)</code></td><td>创建一个初始容量为 <code>max</code> 的优先队列</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MaxPQ(Key[] a)</code></td><td>用 <code>a[]</code> 中的元素创建一个优先队列</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void Insert(Key v)</code></td><td>向优先队列中插入一个元素</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key max()</code></td><td>返回最大元素</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key delMax()</code></td><td>删除并返回最大元素</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean isEmpty()</code></td><td>返回队列是否为空</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size()</code></td><td>返回优先队列中的元素个数</td></tr>\n</table>\n\n<p>为了用例代码的方便，API 包含的三个构造函数使得用例可以构造指定大小的优先队列（还可以用给定的一个数组将其初始化）。为了使用例代码更加清晰，我们会在适当的地方使用另一个类 <code>MinPQ</code>。它和 <code>MaxPQ</code> 类似，只是含有一个 <code>delMin()</code> 方法来删除并返回队列中键值最小的那个元素。<code>MaxPQ</code> 的任意实现都能很容易地转化为 <code>MinPQ</code> 的实现，反之亦然，只需要改变一下 <code>less()</code> 比较的方向即可。</p>\n<p><strong>优先队列的调用示例</strong></p>\n<p>为了展示优先队列的抽象模型的价值，考虑以下问题：输入 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个字符串，每个字符串都对映着一个整数，你的任务就是从中找出最大的（或是最小的）<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00801.gif\" alt=\"M\" inline-img=\"true\" /> 个整数（及其关联的字符串）。这些输入可能是金融事务，你需要从中找出最大的那些；或是农产品中的杀虫剂含量，这时你需要从中找出最小的那些；或是服务请求、科学实验的结果，或是其他应用。在某些应用场景中，输入量可能非常巨大，甚至可以认为输入是无限的。解决这个问题的一种方法是将输入排序然后从中找出 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00801.gif\" alt=\"M\" inline-img=\"true\" /> 个最大的元素，但我们已经说明输入将会非常庞大。另一种方法是将每个新的输入和已知的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00801.gif\" alt=\"M\" inline-img=\"true\" /> 个最大元素比较，但除非 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00801.gif\" alt=\"M\" inline-img=\"true\" /> 较小，否则这种比较的代价会非常高昂。只要我们能够高效地实现 <code>insert()</code> 和 <code>delMin()</code>，下面的<strong>优先队列用例</strong>中调用了 <code>MinPQ</code> 的 <code>TopM</code> 就能使用优先队列解决这个问题，这就是本节中我们的目标。在现代基础性计算环境中超大的输入 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 非常常见，这些实现使我们能够解决以前缺乏足够资源去解决的问题，如表 2.4.2 所示。</p>\n<p><strong>表 2.4.2　从 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个输入中找到最大的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00801.gif\" alt=\"M\" inline-img=\"true\" /> 个元素所需成本</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><th rowspan=\"2\">示例</th><th colspan=\"2\">增长的数量级</th></tr>\n<tr><th>时间</th><th>空间</th></tr>\n<tr><td>排序算法的用例</td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00918.gif\" /></td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" /></td></tr>\n<tr><td>调用初级实现的优先队列</td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01213.gif\" /></td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00801.gif\" /></td></tr>\n<tr><td>调用基于堆实现的优先队列</td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01214.gif\" /></td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00801.gif\" /></td></tr>\n</table>\n\n<blockquote>\n<p><strong>一个优先队列的用例</strong></p>\n<pre class=\"code-rows\"><code>public class TopM\n{\n   public static void main(String[] args)\n   {  // 打印输入流中最大的M行\n      int M = Integer.parseInt(args[0]);\n      MinPQ&lt;Transaction&gt; pq = new MinPQ&lt;Transaction&gt;(M+1);\n      while (StdIn.hasNextLine())\n      {  // 为下一行输入创建一个元素并放入优先队列中\n         pq.insert(new Transaction(StdIn.readLine()));\n         if (pq.size() &gt; M)\n         pq.delMin();        // 如果优先队列中存在M+1个元素则删除其中最小的元素\n      }  // 最大的M个元素都在优先队列中\n\n      Stack&lt;Transaction&gt; stack = new Stack&lt;Transaction&gt;();\n      while (!pq.isEmpty()) stack.push(pq.delMin());\n      for (Transaction t : stack) StdOut.println(t);\n   }\n}</code></pre>\n<p>从命令行输入一个整数 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00801.gif\" alt=\"M\" inline-img=\"true\" /> 从输入流获得一系列字符串，输入流的每一行表示一个交易。这段代码调用了 MinPQ 并会打印数字最大的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00801.gif\" alt=\"M\" inline-img=\"true\" /> 行。它用到了 <code>Transaction</code> 类（请见表 1.2.6、练习 1.2.19 和练习 2.1.21），构造了一个用数字作为键的优先队列。当优先队列的大小超过 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00801.gif\" alt=\"M\" inline-img=\"true\" /> 时就删掉其中最小的元素。处理完所有交易，优先队列中存放着以增序排列的最大的 M 个交易，然后这段代码将它们放入到一个栈中，遍历这个栈以颠倒它们的顺序，从而将它们按降序打印出来。</p>\n<pre class=\"code-rows\"><code>% more tinyBatch.txt\nTuring      6/17/1990   644.08\nvonNeumann  3/26/2002  4121.85\nDijkstra    8/22/2007  2678.40\nvonNeumann  1/11/1999  4409.74\nDijkstra   11/18/1995   837.42\nHoare       5/10/1993  3229.27\nvonNeumann  2/12/1994  4732.35\nHoare       8/18/1992  4381.21\nTuring      1/11/2002    66.10\nThompson    2/27/2000  4747.08\nTuring      2/11/1991  2156.86\nHoare       8/12/2003  1025.70\nvonNeumann 10/13/1993  2520.97\nDijkstra    9/10/2000   708.95\nTuring     10/12/1993  3532.36\nHoare       2/10/2005  4050.20</code></pre>\n<p>　</p>\n<pre class=\"code-rows\"><code>% java TopM 5 &lt; tinyBatch.txt\nThompson    2/27/2000  4747.08\nvonNeumann  2/12/1994  4732.35\nvonNeumann  1/11/1999  4409.74\nHoare       8/18/1992  4381.21\nvonNeumann  3/26/2002  4121.85</code></pre>\n</blockquote>\n<h3 id=\"nav_point_99\">2.4.2　初级实现</h3>\n<p>我们在第 1 章中讨论过的 4 种基础数据结构是实现优先队列的起点。我们可以使用有序或无序的数组或链表。在队列较小时，大量使用两种主要操作之一时，或是所操作元素的顺序已知时，它们十分有用。因为这些实现相对简单，我们在这里只给出文字描述并将实现代码作为练习（请见练习 2.4.3）。</p>\n<h4>2.4.2.1　数组实现（无序）</h4>\n<p>或许实现优先队列的最简单方法就是基于 2.1 节中下压栈的代码。<code>insert()</code> 方法的代码和栈的 <code>push()</code> 方法完全一样。要实现删除最大元素，我们可以添加一段类似于选择排序的内循环的代码，将最大元素和边界元素交换然后删除它，和我们对栈的 <code>pop()</code> 方法的实现一样。和栈类似，我们也可以加入调整数组大小的代码来保证数据结构中至少含有四分之一的元素而又永远不会溢出。</p>\n<h4>2.4.2.2　数组实现（有序）</h4>\n<p>另一种方法就是在 <code>insert()</code> 方法中添加代码，将所有较大的元素向右边移动一格以使数组保持有序（和插入排序一样）。这样，最大的元素总会在数组的一边，优先队列的<strong>删除最大元素操作</strong>就和栈的 <code>pop()</code> 操作一样了。</p>\n<h4>2.4.2.3　链表表示法</h4>\n<p>和刚才类似，我们可以用基于链表的下压栈的代码作为基础，而后可以选择修改 <code>pop()</code> 来找到并返回最大元素，或是修改 <code>push()</code> 来保证所有元素为<strong>逆序</strong>并用 <code>pop()</code> 来删除并返回链表的首元素（也就是最大的元素）。</p>\n<p>使用无序序列是解决这个问题的<strong>惰性</strong>方法，我们仅在必要的时候才会采取行动（找出最大元素）；使用有序序列则是解决问题的<strong>积极</strong>方法，因为我们会尽可能未雨绸缪（在插入元素时就保持列表有序），使后续操作更高效。</p>\n<p>实现栈或是队列与实现优先队列的最大不同在于对性能的要求。对于栈和队列，我们的实现能够在<strong>常数</strong>时间内完成所有操作；而对于优先队列，我们刚刚讨论过的所有初级实现中，<strong>插入元素</strong>和<strong>删除最大元素</strong>这两个操作之一在最坏情况下需要<strong>线性</strong>时间来完成（如表 2.4.3 所示）。我们接下来要讨论的基于数据结构<strong>堆</strong>的实现能够保证这两种操作都能更快地执行。</p>\n<p><strong>表 2.4.3　优先队列的各种实现在最坏情况下运行时间的增长数量级</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>数据结构</p></th>\n<th><p>插入元素</p></th>\n<th><p>删除最大元素</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>有序数组</p></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /></p></td>\n<td><p>1</p></td>\n</tr>\n<tr>\n<td><p>无序数组</p></td>\n<td><p>1</p></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /></p></td>\n</tr>\n<tr>\n<td><p>堆</p></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00917.gif\" alt=\"\\log N\" inline-img=\"true\" /></p></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00917.gif\" alt=\"\\log N\" inline-img=\"true\" /></p></td>\n</tr>\n<tr>\n<td><p>理想情况</p></td>\n<td><p>1</p></td>\n<td><p>1</p></td>\n</tr>\n</tbody>\n</table>\n<p>在一个优先队列上执行的一系列操作如表 2.4.4 所示。</p>\n<p><strong>表 2.4.4　在一个优先队列上执行的一系列操作</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>操作</p></th>\n<th><p>参数</p></th>\n<th><p>返回值</p></th>\n<th><p>大小</p></th>\n<th><p>内容（无序）</p></th>\n<th><p>内容（有序）</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>插入元素</p></td>\n<td><p><code>P</code></p></td>\n<td><p>&nbsp;</p></td>\n<td><p><code>1</code></p></td>\n<td><p><strong><code>P</code></strong></p></td>\n<td><p><strong><code>P</code></strong></p></td>\n</tr>\n<tr>\n<td><p>插入元素</p></td>\n<td><p><code>Q</code></p></td>\n<td><p>&nbsp;</p></td>\n<td><p><code>2</code></p></td>\n<td><p><code>P&nbsp;&nbsp;<b>Q</b></code></p></td>\n<td><p><code>P&nbsp;&nbsp;<b>Q</b></code></p></td>\n</tr>\n<tr>\n<td><p>插入元素</p></td>\n<td><p><code>E</code></p></td>\n<td><p>&nbsp;</p></td>\n<td><p><code>3</code></p></td>\n<td><p><code>P&nbsp;&nbsp;Q&nbsp;&nbsp;<b>E</b></code></p></td>\n<td><p><code><b>E</b>&nbsp;&nbsp;P&nbsp;&nbsp;Q</code></p></td>\n</tr>\n<tr>\n<td><p>删除最大元素</p></td>\n<td><p>&nbsp;</p></td>\n<td><p><strong><code>Q</code></strong></p></td>\n<td><p><code>2</code></p></td>\n<td><p><code>P&nbsp;&nbsp;E</code></p></td>\n<td><p><code>E&nbsp;&nbsp;P</code></p></td>\n</tr>\n<tr>\n<td><p>插入元素</p></td>\n<td><p><code>X</code></p></td>\n<td><p>&nbsp;</p></td>\n<td><p><code>3</code></p></td>\n<td><p><code>P&nbsp;&nbsp;E&nbsp;&nbsp;<b>X</b></code></p></td>\n<td><p><code>E&nbsp;&nbsp;P&nbsp;&nbsp;<b>X</b></code></p></td>\n</tr>\n<tr>\n<td><p>插入元素</p></td>\n<td><p><code>A</code></p></td>\n<td><p>&nbsp;</p></td>\n<td><p><code>4</code></p></td>\n<td><p><code>P&nbsp;&nbsp;E&nbsp;&nbsp;X&nbsp;&nbsp;<b>A</b></code></p></td>\n<td><p><code><b>A</b>&nbsp;&nbsp;E&nbsp;&nbsp;P&nbsp;&nbsp;X</code></p></td>\n</tr>\n<tr>\n<td><p>插入元素</p></td>\n<td><p><code>M</code></p></td>\n<td><p>&nbsp;</p></td>\n<td><p><code>5</code></p></td>\n<td><p><code>P&nbsp;&nbsp;E&nbsp;&nbsp;X&nbsp;&nbsp;A&nbsp;&nbsp;<b>M</b></code></p></td>\n<td><p><code>A&nbsp;&nbsp;E&nbsp;&nbsp;<b>M</b>&nbsp;&nbsp;P&nbsp;&nbsp;X</code></p></td>\n</tr>\n<tr>\n<td><p>删除最大元素</p></td>\n<td><p>&nbsp;</p></td>\n<td><p><strong><code>X</code></strong></p></td>\n<td><p><code>4</code></p></td>\n<td><p><code>P&nbsp;&nbsp;E&nbsp;&nbsp;M&nbsp;&nbsp;A</code></p></td>\n<td><p><code>A&nbsp;E&nbsp;&nbsp;M&nbsp;&nbsp;P</code></p></td>\n</tr>\n<tr>\n<td><p>插入元素</p></td>\n<td><p><code>P</code></p></td>\n<td><p>&nbsp;</p></td>\n<td><p><code>5</code></p></td>\n<td><p><code>P&nbsp;&nbsp;E&nbsp;&nbsp;M&nbsp;&nbsp;A&nbsp;&nbsp;<b>P</b></code></p></td>\n<td><p><code>A&nbsp;&nbsp;E&nbsp;&nbsp;M&nbsp;&nbsp;P&nbsp;&nbsp;<b>P</b></code></p></td>\n</tr>\n<tr>\n<td><p>插入元素</p></td>\n<td><p><code>L</code></p></td>\n<td><p>&nbsp;</p></td>\n<td><p><code>6</code></p></td>\n<td><p><code>P&nbsp;&nbsp;E&nbsp;&nbsp;M&nbsp;&nbsp;A&nbsp;&nbsp;P&nbsp;&nbsp;<b>L</b></code></p></td>\n<td><p><code>A&nbsp;&nbsp;E&nbsp;&nbsp;<b>L</b>&nbsp;&nbsp;M&nbsp;&nbsp;P&nbsp;&nbsp;<b>P</b>\n\n</code></p></td></tr><tr>\n<td><p>插入元素</p></td>\n<td><p><code>E</code></p></td>\n<td><p>&nbsp;</p></td>\n<td><p><code>7</code></p></td>\n<td><p><code>P&nbsp;&nbsp;E&nbsp;&nbsp;M&nbsp;&nbsp;A&nbsp;&nbsp;P&nbsp;&nbsp;L&nbsp;&nbsp;<b>E</b></code></p></td>\n<td><p><code>A&nbsp;&nbsp;E&nbsp;&nbsp;<b>E</b>&nbsp;&nbsp;L&nbsp;&nbsp;M&nbsp;&nbsp;<b>P</b>&nbsp;&nbsp;<b>P</b></code></p></td>\n</tr>\n<tr>\n<td><p>删除最大元素</p></td>\n<td><p>&nbsp;</p></td>\n<td><p><strong><code>P</code></strong></p></td>\n<td><p><code>6</code></p></td>\n<td><p><code>E&nbsp;&nbsp;E&nbsp;&nbsp;M&nbsp;&nbsp;A&nbsp;&nbsp;P&nbsp;&nbsp;L</code></p></td>\n<td><p><code>A&nbsp;&nbsp;E&nbsp;&nbsp;E&nbsp;&nbsp;L&nbsp;&nbsp;M&nbsp;&nbsp;<b>P</b></code></p></td>\n</tr>\n\n</tbody></table>\n<h3 id=\"nav_point_100\">2.4.3　堆的定义</h3>\n<p>数据结构<strong>二叉堆</strong>能够很好地实现优先队列的基本操作。在二叉堆的数组中，每个元素都要保证大于等于另两个特定位置的元素。相应地，这些位置的元素又至少要大于等于数组中的另两个元素，以此类推。如果我们将所有元素画成一棵二叉树，将每个较大元素和两个较小的元素用边连接就可以很容易看出这种结构。</p>\n<blockquote>\n<p><strong>定义</strong>。当一棵二叉树的每个结点都大于等于它的两个子结点时，它被称为<strong>堆有序</strong>。</p>\n</blockquote>\n<p>相应地，在堆有序的二叉树中，每个结点都小于等于它的父结点（如果有的话）。从任意结点向上，我们都能得到一列非递减的元素；从任意结点向下，我们都能得到一列非递增的元素。特别地：</p>\n<blockquote>\n<p><strong>命题 O</strong>。根结点是堆有序的二叉树中的最大结点。</p>\n<p><strong>证明</strong>。根据树的性质归纳可得。</p>\n</blockquote>\n<p><strong>二叉堆表示法</strong></p>\n<p>如果我们用指针来表示堆有序的二叉树，那么每个元素都需要三个指针来找到它的上下结点（父结点和两个子结点各需要一个）。但如图 2.4.1 所示，如果我们使用完全二叉树，表达就会变得特别方便。要画出这样一棵完全二叉树，可以先定下根结点，然后一层一层地由上向下、从左至右，在每个结点的下方连接两个更小的结点，直至将 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个结点全部连接完毕。完全二叉树只用数组而不需要指针就可以表示。具体方法就是将二叉树的结点按照<strong>层级顺序</strong>放入数组中，根结点在位置 1，它的子结点在位置 2 和 3，而子结点的子结点则分别在位置 4、5、6 和 7，以此类推。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01215.gif\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 2.4.1　一棵堆有序的完全二叉树</strong></p>\n<blockquote>\n<p><strong>定义</strong>。<strong>二叉堆</strong>是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级储存（不使用数组的第一个位置）。</p>\n</blockquote>\n<p>（简单起见，在下文中我们将<strong>二叉堆</strong>简称为<strong>堆</strong>）在一个堆中，位置 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00842.gif\" alt=\"k\" inline-img=\"true\" /> 的结点的父结点的位置为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01216.gif\" alt=\"\\lfloor k/2\\rfloor\" inline-img=\"true\" />，而它的两个子结点的位置则分别为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01217.gif\" alt=\"2k\" inline-img=\"true\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01218.gif\" alt=\"2k+1\" inline-img=\"true\" />。这样在不使用指针的情况下（我们在第 3 章中讨论二叉树时会用到它们）我们也可以通过计算数组的索引在树中上下移动：从 <code>a[k]</code> 向上一层就令 <code>k</code> 等于 <code>k/2</code>，向下一层则令 <code>k</code> 等于 <code>2k</code> 或 <code>2k+1</code>。</p>\n<p>用数组（堆）实现的完全二叉树的结构是很严格的，但它的灵活性已经足以让我们高效地实现优先队列。用它们我们将能实现对数级别的<strong>插入元素</strong>和<strong>删除最大元素</strong>的操作。利用在数组中无需指针即可沿树上下移动的便利和以下性质，算法保证了对数复杂度的性能。</p>\n<blockquote>\n<p><strong>命题 P</strong>。一棵大小为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的完全二叉树的高度为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01219.gif\" alt=\"\\left\\lfloor\\lg N\\right\\rfloor\" inline-img=\"true\" />。</p>\n<p><strong>证明</strong>。通过归纳很容易可以证明这一点，且当 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 达到 2 的幂时树的高度会加 1。</p>\n</blockquote>\n<p>堆的表示如图 2.4.2 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01220.gif\" alt=\"\" width=\"70%\" style=\"width: 70%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 2.4.2　堆的表示</strong></p>\n<h3 id=\"nav_point_101\">2.4.4　堆的算法</h3>\n<p>我们用长度为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01015.gif\" alt=\"N+1\" inline-img=\"true\" /> 的私有数组 <code>pq[]</code> 来表示一个大小为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的堆，我们不会使用 <code>pq[0]</code>，堆元素放在 <code>pq[1]</code> 至 <code>pq[N]</code> 中。在排序算法中，我们只通过私有辅助函数 <code>less()</code> 和 <code>exch()</code> 来访问元素，但因为所有的元素都在数组 <code>pq[]</code> 中，我们在 2.4.4.2 节中会使用更加紧凑的实现方式，不再将数组作为参数传递。堆的操作会首先进行一些简单的改动，打破堆的状态，然后再遍历堆并按照要求将堆的状态恢复。我们称这个过程叫做<strong>堆的有序化</strong>（reheapifying）。</p>\n<pre class=\"code-rows\"><code>private boolean less(int i, int j)\n{  return pq[i].compareTo(pq[j]) &lt; 0;  }\n\nprivate void exch(int i, int j)\n{  Key t = pq[i]; pq[i] = pq[j]; pq[j] = t;  }</code></pre>\n<p style=\"text-align: center\">堆实现的比较和交换方法</p>\n<p>堆实现的比较和交换方法如右上方的代码框所示。</p>\n<p>在有序化的过程中我们会遇到两种情况。当某个结点的优先级上升（或是在堆底加入一个新的元素）时，我们需要<strong>由下至上</strong>恢复堆的顺序。当某个结点的优先级下降（例如，将根结点替换为一个较小的元素）时，我们需要<strong>由上至下</strong>恢复堆的顺序。首先，我们会学习如何实现这两种辅助操作，然后再用它们实现<strong>插入元素</strong>和<strong>删除最大元素</strong>的操作。</p>\n<h4>2.4.4.1　由下至上的堆有序化（上浮）</h4>\n<pre class=\"code-rows\"><code>private void swim(int k)\n{\n   while (k &gt; 1 &amp;&amp; less(k/2, k))\n   {\n      exch(k/2, k);\n      k = k/2;\n   }\n}</code></pre>\n<p style=\"text-align: center\">由下至上的堆有序化（上浮）的实现</p>\n<p>如果堆的有序状态因为某个结点变得比它的父结点更大而被打破，那么我们就需要通过交换它和它的父结点来修复堆。交换后，这个结点比它的两个子结点都大（一个是曾经的父结点，另一个比它更小，因为它是曾经父结点的子结点），但这个结点仍然可能比它现在的父结点更大。我们可以一遍遍地用同样的办法恢复秩序，将这个结点不断向上移动直到我们遇到了一个更大的父结点。只要记住位置 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00842.gif\" alt=\"k\" inline-img=\"true\" /> 的结点的父结点的位置是 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01216.gif\" alt=\"\\lfloor k/2\\rfloor\" inline-img=\"true\" />，这个过程实现起来很简单。<code>swim()</code> 方法中的循环可以保证只有位置 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00842.gif\" alt=\"k\" inline-img=\"true\" /> 上的结点大于它的父结点时堆的有序状态才会被打破。因此只要该结点不再大于它的父结点，堆的有序状态就恢复了。至于方法名，当一个结点太大的时候它需要<strong>浮</strong>（swim）到堆的更高层。由下至上的堆有序化的实现代码如右上方所示。</p>\n<p>图 2.4.3 展示的是由下至上的堆有序化示意图。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01221.gif\" alt=\"\" width=\"60%\" style=\"width: 60%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 2.4.3　由下至上的堆有序化（上浮）</strong></p>\n<h4>2.4.4.2　由上至下的堆有序化（下沉）</h4>\n<p>如果堆的有序状态因为某个结点变得比它的两个子结点或是其中之一更小了而被打破了，那么我们可以通过将它和它的两个子结点中的较大者交换来恢复堆。交换可能会在子结点处继续打破堆的有序状态，因此我们需要不断地用相同的方式将其修复，将结点向下移动直到它的子结点都比它更小或是到达了堆的底部。由位置为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00842.gif\" alt=\"k\" inline-img=\"true\" /> 的结点的子结点位于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01217.gif\" alt=\"2k\" inline-img=\"true\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01218.gif\" alt=\"2k+1\" inline-img=\"true\" /> 可以直接得到对应的代码。至于方法名，由上至下的堆有序化的示意图及实现代码分别见图 2.4.4 和下页的代码框。当一个结点太小的时候它需要<strong>沉</strong>（sink）到堆的更低层。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01222.gif\" alt=\"\" width=\"45%\" style=\"width: 45%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 2.4.4　由上至下的堆有序化（下沉）</strong></p>\n<p>如果我们把堆想象成一个严密的黑社会组织，每个子结点都表示一个下属（父结点则表示它的直接上级），那么这些操作就可以得到很有趣的解释。<code>swim()</code> 表示一个很有能力的新人加入组织并被逐级提升（将能力不够的上级踩在脚下），直到他遇到了一个更强的领导。<code>sink()</code> 则类似于整个社团的领导退休并被外来者取代之后，如果他的下属比他更厉害，他们的角色就会交换，这种交换会持续下去直到他的能力比其下属都强为止。这些理想化的情景在现实生活中可能很罕见，但它们能够帮助你理解堆的这些基本行为。</p>\n<p><code>sink()</code> 和 <code>swim()</code> 方法是高效实现优先队列 API 的基础，原因如下（具体的实现请见算法 2.6）。</p>\n<pre class=\"code-rows\"><code>private void sink(int k)\n{\n   while (2*k &lt;= N)\n   {\n      int j = 2*k;\n      if (j &lt; N &amp;&amp; less(j, j+1)) j++;\n      if (!less(k, j)) break;\n      exch(k, j);\n      k = j;\n   }\n}\n\n</code></pre>\n<p style=\"text-align: center\">由上至下的堆有序化（下沉）的实现</p>\n<p><strong>插入元素</strong>。我们将新元素加到数组末尾，增加堆的大小并让这个新元素上浮到合适的位置（如图 2.4.5 左半部分所示）。</p>\n<p><strong>删除最大元素</strong>。我们从数组顶端删去最大的元素并将数组的最后一个元素放到顶端，减小堆的大小并让这个元素下沉到合适的位置（如图 2.4.5 右半部分所示）。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01223.gif\" alt=\"\" width=\"90%\" style=\"width: 90%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 2.4.5　堆的操作</strong></p>\n<p>算法 2.6 解决了我们在本节开始时提出的一个基本问题：它对优先队列 API 的实现能够保证<strong>插入元素</strong>和<strong>删除最大元素</strong>这两个操作的用时和队列的大小仅成对数关系。</p>\n<blockquote>\n<p><strong>算法 2.6　基于堆的优先队列</strong></p>\n<pre class=\"code-rows\"><code>public class MaxPQ&lt;Key extends Comparable&lt;Key&gt;&gt;\n{\n   private Key[] pq;             // 基于堆的完全按二叉树\n   private int N = 0;            // 存储于pq[1..N]中，pq[0]没有使用\n\n   public MaxPQ(int maxN)\n   {  pq = (Key[]) new Comparable[maxN+1];  }\n\n   public boolean isEmpty()\n   {  return N == 0;  }\n\n   public int size()\n   {  return N;  }\n\n   public void insert(Key v)\n   {\n      pq[++N] = v;\n      swim(N);\n   }\n\n   public Key delMax()\n   {\n      Key max = pq[1];           // 从根结点得到最大元素\n      exch(1, N--);              // 将其和最后一个结点交换\n      pq[N+1] = null;            // 防止对象游离\n      sink(1);                   // 恢复堆的有序性\n      return max;\n   }\n\n   // 辅助方法的实现请见本节前面的代码框\n   private boolean less(int i, int j)\n   private void exch(int i, int j)\n   private void swim(int k)\n   private void sink(int k)\n}</code></pre>\n<p>优先队列由一个基于堆的完全二叉树表示，存储于数组 <code>pq[1..N]</code> 中，<code>pq[0]</code> 没有使用。在 <code>insert()</code> 中，我们将 <code>N</code> 加一并把新元素添加在数组最后，然后用 <code>swim()</code> 恢复堆的秩序。在 <code>delMax()</code> 中，我们从 <code>pq[1]</code> 中得到需要返回的元素，然后将 <code>pq[N]</code> 移动到 <code>pq[1]</code>，将 <code>N</code> 减一并用 <code>sink()</code> 恢复堆的秩序。同时我们还将不再使用的 <code>pq[N+1]</code> 设为 <code>null</code>，以便系统回收它所占用的空间。和以前一样（请见 1.3 节），这里省略了动态调整数组大小的代码。其他的构造函数请见练习 2.4.19。</p>\n</blockquote>\n<p>　</p>\n<blockquote>\n<p><strong>命题 Q</strong>。对于一个含有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个元素的基于堆的优先队列，<strong>插入元素</strong>操作只需不超过（<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00913.gif\" alt=\"\\lg N+1\" inline-img=\"true\" />）次比较，<strong>删除最大元素</strong>的操作需要不超过 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01224.gif\" alt=\"2\\lg N\" inline-img=\"true\" /> 次比较。</p>\n<p><strong>证明</strong>。由命题 P 可知，两种操作都需要在根结点和堆底之间移动元素，而路径的长度不超过 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00915.gif\" alt=\"\\lg N\" inline-img=\"true\" />。对于路径上的每个结点，<strong>删除最大元素</strong>需要两次比较（除了堆底元素），一次用来找出较大的子结点，一次用来确定该子结点是否需要上浮。</p>\n</blockquote>\n<p>对于需要大量混杂的插入和删除最大元素操作的典型应用来说，命题 Q 意味着一个重要的性能突破，总结请见表 2.4.3。使用有序或是无序数组的优先队列的初级实现总是需要线性时间来完成其中一种操作，但基于堆的实现则能够保证在对数时间内完成它们。这种差别使得我们能够解决以前无法解决的问题。</p>\n<h4>2.4.4.3　多叉堆</h4>\n<p>基于用数组表示的完全三叉树构造堆并修改相应的代码并不困难。对于数组中 1 至 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个元素，位置 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00842.gif\" alt=\"k\" inline-img=\"true\" /> 的结点大于等于位于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01225.gif\" alt=\"3k-1\" inline-img=\"true\" />、<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01226.gif\" alt=\"3k\" inline-img=\"true\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01227.gif\" alt=\"3k+1\" inline-img=\"true\" /> 的结点，小于等于位于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01228.gif\" alt=\"\\lfloor (k+1)/3\\rfloor\" inline-img=\"true\" /> 的结点。甚至对于给定的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01229.gif\" alt=\"d\" inline-img=\"true\" />，将其修改为任意的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01229.gif\" alt=\"d\" inline-img=\"true\" /> 叉树也并不困难。我们需要在树高（<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01230.gif\" alt=\"\\log_dN\" inline-img=\"true\" />）和在每个结点的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01229.gif\" alt=\"d\" inline-img=\"true\" /> 个子结点找到最大者的代价之间找到折中，这取决于实现的细节以及不同操作的预期相对频繁程度。</p>\n<p>堆上的优先队列操作如图 2.4.6 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01231.gif\" alt=\"\" width=\"50%\" style=\"width: 50%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 2.4.6　在堆上的优先队列操作</strong></p>\n<h4>2.4.4.4　调整数组大小</h4>\n<p>我们可以添加一个没有参数的构造函数，在 <code>insert()</code> 中添加将数组长度加倍的代码，在 <code>delMax()</code> 中添加将数组长度减半的代码，就像在 1.3 节中的栈那样。这样，算法的用例就无需关注各种队列大小的限制。当优先队列的数组大小可以调整、队列长度可以是任意值时，<strong>命题 Q</strong> 指出的对数时间复杂度上限就只是针对一般性的队列长度 N 而言了（请见练习 2.4.22）。</p>\n<h4>2.4.4.5　元素的不可变性</h4>\n<p>优先队列存储了用例创建的对象，但同时假设用例代码不会改变它们（改变它们就可能打破堆的有序性）。我们可以将这个假设转化为强制条件，但程序员通常不会这么做，因为增加代码的复杂性会降低性能。</p>\n<h4>2.4.4.6　索引优先队列</h4>\n<p>在很多应用中，允许用例引用已经进入优先队列中的元素是有必要的。做到这一点的一种简单方法是给每个元素一个<strong>索引</strong>。另外，一种常见的情况是用例已经有了总量为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的多个元素，而且可能还同时使用了多个（平行）数组来存储这些元素的信息。此时，其他无关的用例代码可能已经在使用一个整数索引来引用这些元素了。这些考虑引导我们设计了表 2.4.5 中的 API。</p>\n<p><strong>表 2.4.5　关联索引的泛型优先队列的 API</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td colspan=\"2\"><code>public class&nbsp;&nbsp;<b>IndexMinPQ</b>&lt;Item extends Comparable&lt;Item&gt;&gt;</code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IndexMinPQ(int maxN)</code></td><td>创建一个最大容量为 <code>maxN</code> 的优先队列，索引的取值范围为 0 至 <code>maxN-1</code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;insert(int k, Item item)</code></td><td>插入一个元素，将它和索引 <code>k</code> 相关联</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;change(int k, Item item)</code></td><td>将索引为 <code>k</code> 的元素设为 <code>item</code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;contains(int k)</code></td><td>是否存在索引为 <code>k</code> 的元素</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;delete(int k)</code></td><td>删去索引 <code>k</code> 及其相关联的元素</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Item&nbsp;&nbsp;min()</code></td><td>返回最小元素</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;minIndex()</code></td><td>返回最小元素的索引</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;delMin()</code></td><td>删除最小元素并返回它的索引</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;isEmpty()</code></td><td>优先队列是否为空</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;size()</code></td><td>优先队列中的元素数量</td></tr>\n</table>\n\n<p>理解这种数据结构的一个较好方法是将它看成一个能够快速访问其中最小元素的数组。事实上它还要更好——它能够快速访问数组的一个特定子集中的最小元素（指所有被插入的元素）。换句话说，可以将名为 <code>pq</code> 的 <code>IndexMinPQ</code> 类优先队列看做数组 <code>pq[0..N-1]</code> 中的一部分元素的代表。将 <code>pq.insert(k, item)</code> 看做将 <code>k</code> 加入这个子集并使 <code>pq[k] = item</code>，<code>pq.change(k, item)</code> 则代表令 <code>pq[k]=item</code>。这两种操作没有改变其他操作所依赖的数据结构，其中最重要的就是 <code>delMin()</code>（删除最小元素并返回它的索引）和 <code>change()</code>（改变数据结构中的某个元素的索引——即 <code>pq[i]=item</code>）。这些操作在许多应用中都很重要并且依赖于对元素的引用（索引）。练习 2.4.33 说明了如何用较少的代码将算法 2.6 扩展为极高效的索引优先队列。一般来说，当堆发生变化时，我们会用下沉（元素减小时）或上浮（元素变大时）操作来恢复堆的有序性。在这些操作中，我们可以用索引查找元素。能够定位堆中的任意元素也使我们能够在 API 中加入一个 <code>delete()</code> 操作。</p>\n<blockquote>\n<p><strong>命题 Q（续）</strong>。在一个大小为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的索引优先队列中，插入元素（insert）、改变优先级（change）、删除（delete）和删除最小元素（remove the minimum）操作所需的比较次数和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00917.gif\" alt=\"\\log N\" inline-img=\"true\" /> 成正比（如表 2.4.6 所示）。</p>\n<p><strong>证明</strong>。已知堆中所有路径最长即为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00914.gif\" alt=\"\\sim\\lg N\" inline-img=\"true\" />，从代码中很容易得到这个结论。</p>\n</blockquote>\n<p><strong>表 2.4.6　含有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个元素的基于堆的索引优先队列所有操作在最坏情况下的成本</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>操作</p></th>\n<th><p>比较次数的增长数量级</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>insert()</code></p></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00917.gif\" alt=\"\\log N\" inline-img=\"true\" /></p></td>\n</tr>\n<tr>\n<td><p><code>change()</code></p></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00917.gif\" alt=\"\\log N\" inline-img=\"true\" /></p></td>\n</tr>\n<tr>\n<td><p><code>contains()</code></p></td>\n<td><p>1</p></td>\n</tr>\n<tr>\n<td><p><code>delete()</code></p></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00917.gif\" alt=\"\\log N\" inline-img=\"true\" /></p></td>\n</tr>\n<tr>\n<td><p><code>min()</code></p></td>\n<td><p>1</p></td>\n</tr>\n<tr>\n<td><p><code>minIndex()</code></p></td>\n<td><p>1</p></td>\n</tr>\n<tr>\n<td><p><code>delMin()</code></p></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00917.gif\" alt=\"\\log N\" inline-img=\"true\" /></p></td>\n</tr>\n</tbody>\n</table>\n<p>这段讨论针对的是找出最小元素的队列；和以前一样，我们也在本书网站上实现了一个找出最大元素的版本 IndexMaxPQ。</p>\n<h4>2.4.4.7　索引优先队列用例</h4>\n<p>下面的用例调用了 IndexMinPQ 的代码 <code>Multiway</code> 解决了<strong>多向归并</strong>问题：它将多个有序的输入流归并成一个有序的输出流。许多应用中都会遇到这个问题。输入可能来自于多种科学仪器的输出（按时间排序），或是来自多个音乐或电影网站的信息列表（按名称或艺术家名字排序），或是商业交易（按账号或时间排序），或者其他。如果有足够的空间，你可以把它们简单地读入一个数组并排序，但如果用了优先队列，<strong>无论输入有多长</strong>你都可以把它们全部读入并排序。</p>\n<blockquote>\n<p><strong>使用优先队列的多向归并</strong></p>\n<pre class=\"code-rows\"><code>public class Multiway\n{\n   public static void merge(In[] streams)\n   {\n      int N = streams.length;\n      IndexMinPQ&lt;String&gt; pq = new IndexMinPQ&lt;String&gt;(N);\n\n      for (int i = 0; i &lt; N; i++)\n         if (!streams[i].isEmpty())\n             pq.insert(i, streams[i].readString());\n\n      while (!pq.isEmpty())\n      {\n         StdOut.println(pq.min());\n         int i = pq.delMin();\n\n         if (!streams[i].isEmpty())\n             pq.insert(i, streams[i].readString());\n      }\n   }\n\n   public static void main(String[] args)\n   {\n     int N = args.length;\n     In[] streams = new In[N];\n     for (int i = 0; i &lt; N; i++)\n         streams[i] = new In(args[i]);\n     merge(streams);\n   }\n}</code></pre>\n<p>这段代码调用了 IndexMinPQ 来将作为命令行参数输入的多行有序字符串归并为一行有序的输出（请见正文）。每个输入流的索引都关联着一个元素（输入中的下个字符串）。初始化之后，代码进入一个循环，删除并打印出队列中最小的字符串，然后将该输入的下一个字符串添加为一个元素。为了节约，下面将所有的输出排在了一行——实际输出应该是一个字符串一行。</p>\n<pre class=\"code-rows\"><code>% more m1.txt\nA B C F G I I Z\n% more m2.txt\nB D H P Q Q\n% more m3.txt\nA B E F J N</code></pre>\n<p>　</p>\n<pre class=\"code-rows\"><code>% java Multiway m1.txt m2.txt m3.txt\nA A B B B C D E F F G H I I J N P Q Q Z</code></pre>\n</blockquote>\n<h3 id=\"nav_point_102\">2.4.5　堆排序</h3>\n<p>我们可以把任意优先队列变成一种排序方法。将所有元素插入一个查找最小元素的优先队列，然后再重复调用<strong>删除最小元素</strong>的操作来将它们按顺序删去。用无序数组实现的优先队列这么做相当于进行一次插入排序。用基于堆的优先队列这样做等同于哪种排序？一种全新的排序方法！下面我们就用堆来实现一种经典而优雅的排序算法——<strong>堆排序</strong>。</p>\n<p>堆排序可以分为两个阶段。在<strong>堆的构造</strong>阶段中，我们将原始数组重新组织安排进一个堆中；然后在<strong>下沉排序</strong>阶段，我们从堆中按递减顺序取出所有元素并得到排序结果。为了和我们已经学习过的代码保持一致，我们将使用一个面向最大元素的优先队列并重复删除最大元素。为了排序的需要，我们不再将优先队列的具体表示隐藏，并将直接使用 <code>swim()</code> 和 <code>sink()</code> 操作。这样我们在排序时就可以将需要排序的数组本身作为堆，因此无需任何额外空间。</p>\n<h4>2.4.5.1　堆的构造</h4>\n<p>由 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个给定的元素构造一个堆有多难？我们当然可以在与 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00918.gif\" alt=\"N\\log N\" inline-img=\"true\" /> 成正比的时间内完成这项任务，只需从左至右遍历数组，用 <code>swim()</code> 保证扫描指针左侧的所有元素已经是一棵堆有序的完全树即可，就像连续向优先队列中插入元素一样。一个更聪明更高效的办法是从右至左用 <code>sink()</code> 函数构造子堆。数组的每个位置都已经是一个子堆的根结点了，<code>sink()</code> 对于这些子堆也适用。如果一个结点的两个子结点都已经是堆了，那么在该结点上调用 <code>sink()</code> 可以将它们变成一个堆。这个过程会递归地建立起堆的秩序。开始时我们只需要扫描数组中的一半元素，因为我们可以跳过大小为 1 的子堆。最后我们在位置 1 上调用 <code>sink()</code> 方法，扫描结束。在排序的第一阶段，堆的构造方法和我们的想象有所不同，因为它的目标是产生一个堆有序的结果，其中最大元素位于数组的开头（次大的元素在附近），而非期望的把最大元素放到最后。</p>\n<blockquote>\n<p><strong>命题 R</strong>。用下沉操作由 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个元素构造堆只需少于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01046.gif\" alt=\"2N\" inline-img=\"true\" /> 次比较以及少于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 次交换。</p>\n<p><strong>证明</strong>。观察可知，构造过程中处理的堆都较小。例如，要构造一个 127 个元素的堆，我们会处理 32 个大小为 3 的堆，16 个大小为 7 的堆，8 个大小为 15 的堆，4 个大小为 31 的堆，2 个大小为 63 的堆和 1 个大小为 127 的堆，因此（最坏情况下）需要 32×1 + 16×2 + 8×3 + 4×4 + 2×5 + 1×6 = 120 次交换（以及两倍的比较）。完整证明请见练习 2.4.20。</p>\n</blockquote>\n<p>堆排序的实现过程如算法 2.7 所示。</p>\n<blockquote>\n<p><strong>算法 2.7　堆排序</strong></p>\n<pre class=\"code-rows\"><code>public static void sort(Comparable[] a)\n{\n   int N = a.length;\n   for (int k = N/2; k &gt;= 1; k--)\n      sink(a, k, N);\n   while (N &gt; 1)\n   {\n      exch(a, 1, N--);\n      sink(a, 1, N);\n   }\n}</code></pre>\n<p>这段代码用 <code>sink()</code> 方法将 <code>a[1]</code> 到 <code>a[N]</code> 的元素排序（<code>sink()</code> 被修改过，以 <code>a[]</code> 和 <code>N</code> 作为参数）。<code>for</code> 循环构造了堆，然后 <code>while</code> 循环将最大的元素 <code>a[1]</code> 和 <code>a[N]</code> 交换并修复了堆，如此重复直到堆变空。将 <code>exch()</code> 和 <code>less()</code> 的实现中的索引减一即可得到和其他排序算法一致的实现（将 <code>a[0]</code> 至 <code>a[N-1]</code> 排序）。堆排序具体流程示意图显示在图 2.4.7 中。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01232.gif\" alt=\"\" width=\"70%\" style=\"width: 70%\" /></p>\n<p><strong>堆排序的轨迹（每次下沉后的数组内容）</strong></p>\n</blockquote>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01233.jpeg\" alt=\"\" width=\"90%\" style=\"width: 90%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 2.4.7　堆排序：堆的构造（左）和下沉排序（右）</strong></p>\n<h4>2.4.5.2　下沉排序</h4>\n<p>堆排序的主要工作都是在第二阶段完成的。这里我们将堆中的最大元素删除，然后放入堆缩小后数组中空出的位置。这个过程和选择排序有些类似（按照降序而非升序取出所有元素），但所需的比较要少得多，因为堆提供了一种从未排序部分找到最大元素的有效方法。</p>\n<blockquote>\n<p><strong>命题 S</strong>。将 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个元素排序，堆排序只需少于（<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01234.gif\" alt=\"2N\\lg N+2N\" inline-img=\"true\" />）次比较（以及一半次数的交换）。</p>\n<p><strong>证明</strong>。<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01046.gif\" alt=\"2N\" inline-img=\"true\" /> 项来自于堆的构造（见命题 R）。<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01235.gif\" alt=\"2N\\lg N\" inline-img=\"true\" /> 项来自于每次下沉操作最大可能需要 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01224.gif\" alt=\"2\\lg N\" inline-img=\"true\" /> 次比较（见命题 P 与命题 Q）。</p>\n</blockquote>\n<p>算法 2.7 完整地实现了这些思想，也就是经典的<strong>堆排序</strong>算法。它的发明人是 J. W. J. Williams，并由 R. W. Floyd 在 1964 年改进。尽管这段程序中循环的任务各不同（第一段循环构造堆，第二段循环在下沉排序中销毁堆），它们都是基于 <code>sink()</code> 方法。我们将该实现和优先队列的 API 独立开来是为了突出这个排序算法的简洁性（<code>sort()</code> 方法只需 8 行代码，<code>sink()</code> 函数 8 行），并使其可以嵌入其他代码之中。</p>\n<p>和以前一样，通过研究可视轨迹（如图 2.4.8 所示）我们可以深入了解算法的操作。一开始算法的行为似乎杂乱无章，因为随着堆的构建较大的元素都被移动到了数组的开头，但接下来算法的行为看起来就和选择排序一模一样了（除了它比较的次数少得多）。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01236.jpeg\" alt=\"\" width=\"50%\" style=\"width: 50%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 2.4.8　堆排序的可视轨迹</strong></p>\n<p>和我们学过的其他算法一样，很多人都研究过许多改进基于堆的优先队列的实现和堆排序的方法。我们这里简要地看看其中之一。</p>\n<h4>2.4.5.3　先下沉后上浮</h4>\n<p>大多数在下沉排序期间重新插入堆的元素会被直接加入到堆底。Floyd 在 1964 年观察发现，我们正好可以通过免去检查元素是否到达正确位置来节省时间。在下沉中总是直接提升较大的子结点直至到达堆底，然后再使元素上浮到正确的位置。这个想法几乎可以将比较次数减少一半——接近了归并排序所需的比较次数（随机数组）。这种方法需要额外的空间，因此在实际应用中只有当比较操作代价较高时才有用（例如，当我们在将字符串或者其他键值较长类型的元素进行排序时）。</p>\n<p><strong>堆排序在排序复杂性的研究中有着重要的地位</strong>，因为它是我们所知的唯一能够同时最优地利用空间和时间的方法——在最坏的情况下它也能保证使用 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01237.gif\" alt=\"\\sim2N\\lg N\" inline-img=\"true\" /> 次比较和恒定的额外空间。当空间十分紧张的时候（例如在嵌入式系统或低成本的移动设备中）它很流行，因为它只用几行就能实现（甚至机器码也是）较好的性能。但现代系统的许多应用很少使用它，因为它无法利用缓存。数组元素很少和相邻的其他元素进行比较，因此缓存未命中的次数要远远高于大多数比较都在相邻元素间进行的算法，如快速排序、归并排序，甚至是希尔排序。</p>\n<p>另一方面，用堆实现的优先队列在现代应用程序中越来越重要，因为它能在<strong>插入操作</strong>和<strong>删除最大元素操作</strong>混合的动态场景中保证对数级别的运行时间。我们会在本书后续章节见到更多的例子。</p>\n<h3 id=\"nav_point_103\">答疑</h3>\n<p><strong>问</strong>　我还是不明白优先队列是做什么用的。为什么我们不直接把元素排序然后再一个个地引用有序数组中的元素？</p>\n<p><strong>答</strong>　在某些数据处理的例子里，比如 <code>TopM</code> 和 <code>Multiway</code>，总数据量太大，无法排序（甚至无法全部装进内存）。如果你需要从 10 亿个元素中选出最大的十个，你真的想把一个 10 亿规模的数组排序吗？但有了优先队列，你就只用一个能存储十个元素的队列即可。在其他的例子中，我们甚至无法同时获取所有的数据，因此只能先从优先队列中取出并处理一部分，然后再根据结果决定是否向优先队列中添加更多的数据。</p>\n<p><strong>问</strong>　为什么不像我们在其他排序算法中那样使用 <code>Comparable</code> 接口，而在 MaxPQ 中使用泛型的 <code>Item</code> 呢？</p>\n<p><strong>答</strong>　这么做的话 <code>delMax()</code> 的用例就需要将返回值转换为某种具体的类型，比如 <code>String</code>。一般来说，应该尽量避免在用例中进行类型转换。</p>\n<p><strong>问</strong>　为什么在堆的表示中不使用 <code>a[0]</code> ？</p>\n<p><strong>答</strong>　这么做可以稍稍简化计算。实现从 0 开始的堆并不困难，<code>a[0]</code> 的子结点是 <code>a[1]</code> 和 <code>a[2]</code>，<code>a[1]</code> 的子结点是 <code>a[3]</code> 和 <code>a[4]</code>，<code>a[2]</code> 的子结点是 <code>a[5]</code> 和 <code>a[6]</code>，以此类推。但大多数程序员更喜欢我们的简单方法。另外，将 <code>a[0]</code> 的值用作哨兵（作为 <code>a[1]</code> 的父结点）在某些堆的应用中很有用。</p>\n<p><strong>问</strong>　在我看来，在堆排序中构造堆时，逐个向堆中添加元素比 2.4.5.1 节中描述的由底向上的复杂方法更简单。为什么要这么做？</p>\n<p><strong>答</strong>　对于一个排序算法来说，这么做能够快上 20%，而且所需的代码更少（不会用到 <code>swim()</code> 函数）。理解算法的难度并不一定与它的简洁性或者效率相关。</p>\n<p><strong>问</strong>　如果我去掉 MaxPQ 的实现中的 <code>extends Comparable&lt;Key&gt;</code> 这句话会怎样？</p>\n<p><strong>答</strong>　和以前一样，回答这类问题的最简单的办法就是你自己直接试试。如果这么做 MaxPQ 会报出一个编译错误：</p>\n<pre class=\"code-rows\"><code>MaxPQ.java:21: cannot find symbol\nsymbol  : method compareTo(Item)</code></pre>\n<p>　Java 这样告诉你它不知道 <code>Item</code> 对象的 <code>compareTo()</code> 方法，因为你没有声明 <code>Item extends Comparable&lt;Item&gt;</code>。</p>\n<h3 id=\"nav_point_104\">练习</h3>\n<p><strong>2.4.1</strong>　用序列 <code>P R I O * R * * I * T * Y * * * Q U E * * * U * E</code> （字母表示<strong>插入元</strong>素，星号表示<strong>删除最大元素</strong>）操作一个初始为空的优先队列。给出每次<strong>删除最大元素</strong>返回的字符。</p>\n<p><strong>2.4.2</strong>　分析以下说法：要实现在常数时间找到<strong>最大元素</strong>，为何不用一个栈或队列，然后记录已插入的最大元素并在找出最大元素时返回它的值？</p>\n<p><strong>2.4.3</strong>　用以下数据结构实现优先队列，支持<strong>插入元素</strong>和<strong>删除最大元素</strong>的操作：无序数组、有序数组、无序链表和链表。将你的 4 种实现中每种操作在最坏情况下的运行时间上下限制成一张表格。</p>\n<p><strong>2.4.4</strong>　一个按降序排列的数组也是一个面向最大元素的堆吗？</p>\n<p><strong>2.4.5</strong>　将 E A S Y Q U E S T I O N 顺序插入一个面向最大元素的堆中，给出结果。</p>\n<p><strong>2.4.6</strong>　按照练习 2.4.1 的规则，用序列 <code>P R I O * R * * I * T * Y * * * Q U E * * * U * E</code> 操作一个初始为空的面向最大元素的堆，给出每次操作后堆的内容。</p>\n<p><strong>2.4.7</strong>　在堆中，最大的元素一定在位置 1 上，第二大的元素一定在位置 2 或者 3 上。对于一个大小为 31 的堆，给出第 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00842.gif\" alt=\"k\" inline-img=\"true\" /> 大的元素可能出现的位置和不可能出现的位置，其中 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01238.gif\" alt=\"k=2\" inline-img=\"true\" />、3、4（设元素值不重复）。</p>\n<p><strong>2.4.8</strong>　回答上一道练习中第 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00842.gif\" alt=\"k\" inline-img=\"true\" /> <strong>小</strong>元素的可能和不可能的位置。</p>\n<p><strong>2.4.9</strong>　给出 <code>A B C D E</code> 五个元素可能构造出来的所有堆，然后给出 <code>A A A B B</code> 这五个元素可能构造出来的所有堆。</p>\n<p><strong>2.4.10</strong>　假设我们不想浪费堆有序的数组 <code>pq[]</code> 中的那个位置，将最大的元素放在 <code>pq[0]</code>，它的子结点放在 <code>pq[1]</code> 和 <code>pq[2]</code>，以此类推。<code>pq[k]</code> 的父结点和子结点在哪里？</p>\n<p><strong>2.4.11</strong>　如果你的应用中有大量的<strong>插入元素</strong>的操作，但只有若干<strong>删除最大元素</strong>操作，哪种优先队列的实现方法更有效：堆、无序数组、有序数组？</p>\n<p><strong>2.4.12</strong>　如果你的应用场景中大量的找出<strong>最大元素</strong>的操作，但<strong>插入元素</strong>和<strong>删除最大元素</strong>操作相对较少，哪种优先队列的实现方法更有效：堆、无序数组、有序数组？</p>\n<p><strong>2.4.13</strong>　想办法在 <code>sink()</code> 中避免检查 <code>j &lt; N</code>。</p>\n<p><strong>2.4.14</strong>　对于没有重复元素的大小为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的堆，一次删除最大元素的操作中最少要交换几个元素？构造一个能够达到这个交换次数的大小为 15 的堆。连续两次<strong>删除最大元素</strong>呢？三次呢？</p>\n<p><strong>2.4.15</strong>　设计一个程序，在线性时间内检测数组 <code>pq[]</code> 是否是一个面向最小元素的堆。</p>\n<p><strong>2.4.16</strong>　对于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01239.gif\" alt=\"N=32\" inline-img=\"true\" />，构造数组使得堆排序使用的比较次数最多以及最少。</p>\n<p><strong>2.4.17</strong>　证明：构造大小为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00842.gif\" alt=\"k\" inline-img=\"true\" /> 的面向最小元素的优先队列，然后进行 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01240.gif\" alt=\"N-k\" inline-img=\"true\" /> 次替换最小元素操作（<strong>删除最小元素</strong>后再<strong>插入元素</strong>）后，<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个元素中的前 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00842.gif\" alt=\"k\" inline-img=\"true\" /> 大元素均会留在优先队列中。</p>\n<p><strong>2.4.18</strong>　在 MaxPQ 中，如果一个用例使用 <code>insert()</code> 插入了一个比队列中的所有元素都大的新元素，随后立即调用 <code>delMax()</code>。假设没有重复元素，此时的堆和进行这些操作之前的堆完全相同吗？进行两次 <code>insert()</code>（第一次插入一个比队列所有元素都大的元素，第二次插入一个更大的元素）操作接两次 <code>delMax()</code> 操作呢？</p>\n<p><strong>2.4.19</strong>　实现 MaxPQ 的一个构造函数，接受一个数组作为参数。使用正文 2.4.5.1 节中所述的自底向上的方法构造堆。</p>\n<p><strong>2.4.20</strong>　证明：基于下沉的堆构造方法使用的比较次数小于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01046.gif\" alt=\"2N\" inline-img=\"true\" />，交换次数小于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" />。</p>\n<h3 id=\"nav_point_105\">提高题</h3>\n<p><strong>2.4.21</strong>　<strong>基础数据结构</strong>。说明如何使用优先队列实现第 1 章中的栈、队列和随机队列这几种数据结构。</p>\n<p><strong>2.4.22</strong>　<strong>调整数组大小</strong>。在 MaxPQ 中加入调整数组大小的代码，并和命题 Q 一样证明对于一般性长度为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的队列其数组访问的上限。</p>\n<p><strong>2.4.23</strong>　<strong>Multiway 的堆</strong>。只考虑比较的成本且假设找到 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01113.gif\" alt=\"t\" inline-img=\"true\" /> 个元素中的最大者需要 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01113.gif\" alt=\"t\" inline-img=\"true\" /> 次比较，在堆排序中使用 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01113.gif\" alt=\"t\" inline-img=\"true\" /> 向堆的情况下找出使比较次数 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00960.gif\" alt=\"N\\lg N\" inline-img=\"true\" /> 的系数最小的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01113.gif\" alt=\"t\" inline-img=\"true\" /> 值。首先，假设使用的是一个简单通用的 <code>sink()</code> 方法；其次，假设 Floyd 方法在内循环中每轮可以节省一次比较。</p>\n<p><strong>2.4.24</strong>　<strong>使用链接的优先队列</strong>。用堆有序的二叉树实现一个优先队列，但使用链表结构代替数组。每个结点都需要三个链接：两个向下，一个向上。你的实现即使在无法预知队列大小的情况下也能保证优先队列的基本操作所需的时间为对数级别。</p>\n<p><strong>2.4.25</strong>　<strong>计算数论</strong>。编写程序 CubeSum.java，在不使用额外空间的条件下，按大小顺序打印所有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01241.gif\" alt=\"a^3+b^3\" inline-img=\"true\" /> 的结果，其中 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00805.gif\" alt=\"a\" inline-img=\"true\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00806.gif\" alt=\"b\" inline-img=\"true\" /> 为 0 至 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 之间的整数。也就是说，不要全部计算 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00912.gif\" alt=\"N^2\" inline-img=\"true\" /> 个和然后排序，而是创建一个最小优先队列，初始状态为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01242.gif\" alt=\"(0^3,0,0),(1^3,1,0),(2^3,2,0),\\cdots,(N^3,N,0)\" inline-img=\"true\" />。这样只要优先队列非空，删除并打印最小的元素 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01243.gif\" alt=\"(i^3+j^3,i,j)\" inline-img=\"true\" />。然后如果 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01244.gif\" alt=\"j&lt;N\" inline-img=\"true\" />，插入元素 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01245.gif\" alt=\"(i^3+(j+1)^3,i,j+1)\" inline-img=\"true\" />。用这段程序找出 0 到 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00849.gif\" alt=\"10^6\" inline-img=\"true\" /> 之间所有满足 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01246.gif\" alt=\"a^3+b^3=c^3+d^3\" inline-img=\"true\" /> 的不同整数 a,b,c,d。</p>\n<p><strong>2.4.26</strong>　<strong>无需交换的堆</strong>。因为 <code>sink()</code> 和 <code>swim()</code> 中都用到了初级函数 <code>exch()</code>，所以所有元素都被多加载并存储了一次。回避这种低效方式，用插入排序给出新的实现（请见练习 2.1.25）。</p>\n<p><strong>2.4.27</strong>　<strong>找出最小元素</strong>。在 MaxPQ 中加入一个 <code>min()</code> 方法。你的实现所需的时间和空间都应该是常数。</p>\n<p><strong>2.4.28</strong>　<strong>选择过滤</strong>。编写一个 TopM 的用例，从标准输入读入坐标 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01247.gif\" alt=\"(x,y,z)\" inline-img=\"true\" />，从命令行得到值 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00801.gif\" alt=\"M\" inline-img=\"true\" />，然后打印出距离原点的欧几里得距离最小的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00801.gif\" alt=\"M\" inline-img=\"true\" /> 个点。在 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01248.gif\" alt=\"N=10^8\" inline-img=\"true\" /> 且 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01249.gif\" alt=\"M=10^4\" inline-img=\"true\" /> 时，预计程序的运行时间。</p>\n<p><strong>2.4.29</strong>　<strong>同时面向最大和最小元素的优先队列</strong>。设计一个数据类型，支持如下操作：<strong>插入元素</strong>、<strong>删除最大元素</strong>、<strong>删除最小元素</strong>（所需时间均为对数级别），以及<strong>找到最大元素</strong>、<strong>找到最小元素</strong>（所需时间均为常数级别）。<strong>提示</strong>：用两个堆。</p>\n<p><strong>2.4.30</strong>　<strong>动态中位数查找</strong>。设计一个数据类型，支持在对数时间内插入元素，常数时间内<strong>找到中位数</strong>并在对数时间内<strong>删除中位数</strong>。<strong>提示</strong>：用一个面向最大元素的堆再用一个面向最小元素的堆。</p>\n<p><strong>2.4.31</strong>　<strong>快速插入</strong>。用基于比较的方式实现 MinPQ 的 API，使得插入元素需要 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01250.gif\" alt=\"\\sim\\log\\log N\" inline-img=\"true\" /> 次比较，删除最小元素需要 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01251.gif\" alt=\"\\sim2\\log N\" inline-img=\"true\" /> 次比较。<strong>提示</strong>：在 <code>swim()</code> 方法中用二分查找来寻找祖先结点。</p>\n<p><strong>2.4.32</strong>　<strong>下界</strong>。请证明，不存在一个基于比较的对 MinPQ 的 API 的实现能够使得<strong>插入元素</strong>和<strong>删除最小元素</strong>的操作都保证只使用 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01252.gif\" alt=\"\\sim N\\log\\log N\" inline-img=\"true\" /> 次比较。</p>\n<p><strong>2.4.33</strong>　<strong>索引优先队列的实现</strong>。按照 2.4.4.6 节的描述修改算法 2.6 来实现索引优先队列 API 中的基本操作：</p>\n<p>使用 <code>pq[]</code> 保存索引，添加一个数组 <code>keys[]</code> 来保存元素，再添加一个数组 <code>qp[]</code> 来保存 <code>pq[]</code> 的逆序——<code>qp[i]</code> 的值是 <code>i</code> 在 <code>pq[]</code> 中的位置（即索引 <code>j</code>，<code>pq[j]=i</code>）。修改算法 2.6 的代码来维护这些数据结构。若 <code>i</code> 不在队列之中，则总是令 <code>qp[i] = -1</code> 并添加一个方法 <code>contains()</code> 来检测这种情况。你需要修改辅助函数 <code>exch()</code> 和 <code>less()</code>，但不需要修改 <code>sink()</code> 和 <code>swim()</code>。</p>\n<p>　<strong>部分答案</strong>：</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01253.gif\" alt=\"\" width=\"70%\" style=\"width: 70%\" /></p>\n<p><strong>2.4.34</strong>　<strong>索引优先队列的实现（附加操作）</strong>。向练习 2.4.33 的实现中添加 <code>minIndex()</code>、<code>change()</code> 和 <code>delete()</code> 方法。</p>\n<p>　<strong>解答</strong>：</p>\n<pre class=\"code-rows\"><code>public int minIndex()\n\n{  return pq[1];  }\n\npublic void change(int k, Key Key)\n{\n   keys[k] = key;\n   swim(qp[k]);\n   sink(qp[k]);\n}\n\npublic void delete(int k)\n{\n   int index = qp[k];\n   exch(index, N--);\n   swim(index);\n   sink(index);\n   keys[k] = null;\n   qp[k] = -1;\n}</code></pre>\n<p><strong>2.4.35</strong>　<strong>离散概率分布的取样</strong>。编写一个 <code>Sample</code> 类，其构造函数接受一个 <code>double</code> 类型的数组 <code>p[]</code> 作为参数并支持以下操作：<code>random()</code>——返回任意索引 <code>i</code> 及其概率 <code>p[i]/T</code>（<code>T</code> 是 <code>p[]</code> 中所有元素之和）；<code>change(i, v)</code>——将 <code>p[i]</code> 的值修改为 <code>v</code>。<strong>提示</strong>：使用完全二叉树，每个结点对应一个权重 <code>p[i]</code>。在每个结点记录其下子树的权重之和。为了产生一个随机的索引，取 <code>0</code> 到 <code>T</code> 之间的一个随机数并根据各个结点的权重之和来判断沿着哪条子树搜索下去。在更新 <code>p[i]</code> 时，同时更新从根结点到 <code>i</code> 的路径上的所有结点。不要像堆的实现那样显式使用指针。</p>\n<h3 id=\"nav_point_106\">实验题</h3>\n<p><strong>2.4.36</strong>　<strong>性能测试 I</strong>。编写一个性能测试用例，用<strong>插入元素</strong>操作填满一个优先队列，然后用<strong>删除最大元素</strong>操作删去一半元素，再用<strong>插入元素</strong>操作填满优先队列，再用<strong>删除最大元素</strong>操作删去所有元素。用一列随机的长短不同的元素多次重复以上过程，测量每次运行的用时，打印平均用时或是将其绘制成图表。</p>\n<p><strong>2.4.37</strong>　<strong>性能测试 II</strong>。编写一个性能测试用例，用<strong>插入元素</strong>操作填满一个优先队列，然后在一秒钟之内尽可能多地连续反复调用<strong>删除最大元素</strong>和<strong>插入元素</strong>的操作。用一列随机的长短不同的元素多次重复以上过程，将程序能够完成的<strong>删除最大元素</strong>操作的平均次数打印出来或是绘成图表。</p>\n<p><strong>2.4.38</strong>　<strong>练习测试</strong>。编写一个练习用例，用算法 2.6 中实现的优先队列的接口方法处理实际应用中可能出现的高难度或是极端情况。例如，元素已经有序、元素全部逆序、元素全部相同或是所有元素只有两个值。</p>\n<p><strong>2.4.39</strong>　<strong>构造函数的代价</strong>。对于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00846.gif\" alt=\"N=10^3\" inline-img=\"true\" />、<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00849.gif\" alt=\"10^6\" inline-img=\"true\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01092.gif\" alt=\"10^9\" inline-img=\"true\" />，根据经验判断堆排序时构造堆占总耗时的比例。</p>\n<p><strong>2.4.40</strong>　<strong>Floyd 方法</strong>。根据正文中 Floyd 的先沉后浮思想实现堆排序。对于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00846.gif\" alt=\"N=10^3\" inline-img=\"true\" />、<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00849.gif\" alt=\"10^6\" inline-img=\"true\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01092.gif\" alt=\"10^9\" inline-img=\"true\" /> 大小的随机不重复数组，记录你的程序所使用的比较次数和标准实现所使用的比较次数。</p>\n<p><strong>2.4.41</strong>　<strong>Multiway 堆</strong>。根据正文中的描述实现基于完全堆有序的三叉树和四叉树的堆排序。对于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00846.gif\" alt=\"N=10^3\" inline-img=\"true\" />、<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00849.gif\" alt=\"10^6\" inline-img=\"true\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01092.gif\" alt=\"10^9\" inline-img=\"true\" /> 大小的随机不重复数组，记录你的程序所使用的比较次数和标准实现所使用的比较次数。</p>\n<p><strong>2.4.42</strong>　<strong>堆的前序表示</strong>。用前序法而非级别表示一棵堆有序的树，并基于此实现堆排序。对于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00846.gif\" alt=\"N=10^3\" inline-img=\"true\" />、<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00849.gif\" alt=\"10^6\" inline-img=\"true\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01092.gif\" alt=\"10^9\" inline-img=\"true\" /> 大小的随机不重复数组，记录你的程序所使用的比较次数和标准实现所使用的比较次数。</p>\n","comments":[]}