{"id":810868,"title":"18｜读懂MySQL中的执行计划（下）","content":"<p>接上一讲</p><h3>POSSIBLE_KEYS</h3><p>possible_keys列显示查询单元能使用range、ref等访问路径访问的索引。执行计划最终选择的索引在keys列显示。是否使用索引，以及使用哪个索引，取决于优化器对各种访问方式的成本评估，还跟表连接的顺序和连接算法也有关系。</p><p>下面这个例子中，t1表的possible_keys有索引idx_abc，但是当t1表作为驱动表时，就无法使用索引idx_abc。</p><pre><code class=\"language-plain\">mysql&gt; explain select * from tab t1, tab t2 where t1.a = t2.a and t1.b = t2.b;\n\n\n+----+-------------+-------+------+---------------+---------+---------+-------------------+------+----------+-------+\n| id | select_type | table | type | possible_keys | key&nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| rows | filtered | Extra |\n+----+-------------+-------+------+---------------+---------+---------+-------------------+------+----------+-------+\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | t1&nbsp; &nbsp; | ALL&nbsp; | idx_abc&nbsp; &nbsp; &nbsp; &nbsp;| NULL&nbsp; &nbsp; | NULL&nbsp; &nbsp; | NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 9913 |&nbsp; &nbsp;100.00 | NULL&nbsp; |\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | t2&nbsp; &nbsp; | ref&nbsp; | idx_abc&nbsp; &nbsp; &nbsp; &nbsp;| idx_abc | 8&nbsp; &nbsp; &nbsp; &nbsp;| rep.t1.a,rep.t1.b |&nbsp; &nbsp; 1 |&nbsp; &nbsp;100.00 | NULL&nbsp; |\n+----+-------------+-------+------+---------------+---------+---------+-------------------+------+----------+-------+\n</code></pre><!-- [[[read_end]]] --><h3>KEY</h3><p>key列显示执行计划实际使用的索引。如果key列为NULL，则说明查询单元没有使用索引。对于index_merge访问路径，key列中会显示多个索引。</p><h3>KEY_LEN</h3><p>key_len列显示执行计划使用到的索引列的总长度。根据key_len可以推算出执行计划使用到了索引中的哪几个字段。key_len根据索引字段的类型和字段是否为空计算得到。对于字符类型如varchar、char，key_len为字符数乘以单个字符的最大可能字节数。对于每个可变长类型如varchar，key_len额外加2。对于每个可以为空的字段，key_len额外加1。</p><pre><code class=\"language-plain\"> create table t_k(\n     a varchar(20), \n     b char(20), \n     key idx_a(a,b)\n) engine=innodb charset=utf8mb4;\n\n\n\n\nmysql&gt; explain select * from t_k where  a='x';\n+----+-------------+-------+------+---------------+-------+---------+-------+------+----------+-------------+\n| id | select_type | table | type | possible_keys | key&nbsp; &nbsp;| key_len | ref&nbsp; &nbsp;| rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp;|\n+----+-------------+-------+------+---------------+-------+---------+-------+------+----------+-------------+\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | t_k&nbsp; &nbsp;| ref&nbsp; | idx_a&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| idx_a | 83&nbsp; &nbsp; &nbsp; | const |&nbsp; &nbsp; 1 |&nbsp; &nbsp;100.00 | Using index |\n+----+-------------+-------+------+---------------+-------+---------+-------+------+----------+-------------+\n\n\n\n\nmysql&gt; explain select * from t_k where  a='x' and b='x';\n\n\n+----+-------------+-------+------+---------------+-------+---------+-------------+------+----------+--------------------------+\n| id | select_type | table | type | possible_keys | key&nbsp; &nbsp;| key_len | ref&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n+----+-------------+-------+------+---------------+-------+---------+-------------+------+----------+--------------------------+\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | t_k&nbsp; &nbsp;| ref&nbsp; | idx_a&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| idx_a | 164&nbsp; &nbsp; &nbsp;| const,const |&nbsp; &nbsp; 1 |&nbsp; &nbsp;100.00 | Using where; Using index |\n+----+-------------+-------+------+---------------+-------+---------+-------------+------+----------+--------------------------+\n</code></pre><p>上面这个例子中，SQL 1使用索引中的字段a，字段A的类型为varchar(20)，字符集为utf8mb4，key_len为20 * 4 + 2 + 1 = 83。</p><p>SQL 2使用到了字段A和B，字段A的key_len为83，字段B的key_len为20 * 4 + 1 = 81，整体Key_len为字段A和字段B相加164。</p><h3>REF</h3><p>ref列显示用来进行索引查找的值，ref的取值可能是以下几种情况：</p><ul>\n<li>\n<p>const：使用常量匹配</p>\n</li>\n<li>\n<p>db.tab.c：使用驱动表的某个字段匹配</p>\n</li>\n<li>\n<p>func：使用某个函数的计算结果匹配。可以在执行explain后使用show warnings命令查看转换后的SQL。</p>\n</li>\n</ul><h3>ROWS</h3><p>查询单元需要访问的记录数。对于InnoDB引擎，这里的记录数是一个预估的行数，跟实际执行过程中真实访问的记录数可能会有一些差异。对于全表扫描和全索引扫描，这里的行数从统计信息中获取。对于索引访问（type为ref或range），rows通过访问索引评估得到，或通过索引的统计信息计算得到。对应派生表，rows通过一些规则评估得到。</p><p>一般来说，rows越大，说明查询单元需要访问的记录数越多，执行时间越长。</p><h3>FILTERED</h3><p>filtered字段单位为百分比，取值范围为0-100，表示经过where子句中的条件过滤后，满足条件的记录数相对于rows列中显示的行数所占的百分比。使用公示rows * filtered / 100可以得到优化器预估的查询单元返回的记录数。如果当前的查询单元作为驱动表，那么这里的记录数还决定了被驱动的查询单元需要执行多次。</p><p>优化器中有一系列固定的规则来计算filtered的取值。你可以在分析表（analyze table）的时候给字段添加直方图，使优化器能更精确地计算filtered。参数optimizer_switch中的选项condition_fanout_filter用来控制是否开启条件过滤。</p><h3>EXTRA</h3><p>Extra列中显示了执行计划额外的一些重要信息。</p><ul>\n<li>using where</li>\n</ul><p>如果访问路径为ALL或index，Extra中没用using where，说明查询需要读取整个表或索引的数据。</p><ul>\n<li>Range checked for each record (index map: 0x n)</li>\n</ul><p>如果Extra中出现了“Range checked for each record”，那么查询的性能很可能不太好。这里index map是索引编号的位图信息。</p><pre><code class=\"language-plain\">mysql&gt; explain select * from tab a, tab b where  a.id &gt; b.id and a.c &gt; b.c;\n\n\n+----+-------------+-------+------+---------------+------+---------+------+------+----------+------------------------------------------------+\n| id | select_type | table | type | possible_keys | key&nbsp; | key_len | ref&nbsp; | rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n+----+-------------+-------+------+---------------+------+---------+------+------+----------+------------------------------------------------+\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | a&nbsp; &nbsp; &nbsp;| ALL&nbsp; | PRIMARY&nbsp; &nbsp; &nbsp; &nbsp;| NULL | NULL&nbsp; &nbsp; | NULL | 9913 |&nbsp; &nbsp;100.00 | NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | b&nbsp; &nbsp; &nbsp;| ALL&nbsp; | PRIMARY&nbsp; &nbsp; &nbsp; &nbsp;| NULL | NULL&nbsp; &nbsp; | NULL | 9913 |&nbsp; &nbsp; 11.11 | Range checked for each record (index map: 0x1) |\n+----+-------------+-------+------+---------------+------+---------+------+------+----------+------------------------------------------------+\n</code></pre><ul>\n<li>Using index; Using temporary</li>\n</ul><p>Extra中出现Using temporary，说明用到了临时表。</p><pre><code class=\"language-plain\">mysql&gt; explain select b,a,count(*) from  tab group by b,a;\n\n\n+----+-------------+-------+-------+---------------+---------+---------+------+------+----------+------------------------------+\n| id | select_type | table | type&nbsp; | possible_keys | key&nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; | rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n+----+-------------+-------+-------+---------------+---------+---------+------+------+----------+------------------------------+\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | tab&nbsp; &nbsp;| index | idx_abc&nbsp; &nbsp; &nbsp; &nbsp;| idx_abc | 12&nbsp; &nbsp; &nbsp; | NULL | 9913 |&nbsp; &nbsp;100.00 | Using index; Using temporary |\n+----+-------------+-------+-------+---------------+---------+---------+------+------+----------+------------------------------+\n</code></pre><ul>\n<li>Using index for skip scan</li>\n</ul><p>查询条件没有传入索引的前缀字段，又用到了覆盖索引时，MySQL可能会使用skip scan。如果前缀列的唯一值很低，skip scan也可能会有不错的性能。</p><pre><code class=\"language-plain\">mysql&gt; explain select c from tab where b=1;\n\n\n+----+-------------+-------+-------+---------------+---------+---------+------+------+----------+----------------------------------------+\n| id | select_type | table | type&nbsp; | possible_keys | key&nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; | rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n+----+-------------+-------+-------+---------------+---------+---------+------+------+----------+----------------------------------------+\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | tab&nbsp; &nbsp;| range | idx_abc&nbsp; &nbsp; &nbsp; &nbsp;| idx_abc | 8&nbsp; &nbsp; &nbsp; &nbsp;| NULL |&nbsp; 991 |&nbsp; &nbsp;100.00 | Using where; Using index for skip scan |\n+----+-------------+-------+-------+---------------+---------+---------+------+------+----------+----------------------------------------+\n</code></pre><ul>\n<li>Using index</li>\n</ul><p>使用了覆盖索引，也就是查询中所有列都包含在索引中。</p><ul>\n<li>no matching row in const table</li>\n</ul><p>说明表里面不存在满足条件的记录。</p><pre><code class=\"language-plain\">mysql&gt; explain select * from tab where id = 12345;\n\n\n+----+-------------+-------------+---------------+------+---------+------+------+----------+--------------------------------+\n| id | select_type | table&nbsp; type | possible_keys | key&nbsp; | key_len | ref&nbsp; | rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n+----+-------------+-------------+---------------+------+---------+------+------+----------+--------------------------------+\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | NULL&nbsp; &nbsp;NULL | NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | NULL | NULL&nbsp; &nbsp; | NULL | NULL |&nbsp; &nbsp; &nbsp;NULL | no matching row in const table |\n+----+-------------+-------------+---------------+------+---------+------+------+----------+--------------------------------+\n</code></pre><ul>\n<li>Using index for group-by</li>\n</ul><pre><code class=\"language-plain\">mysql&gt; explain select a, min(b) from tab group by a;\n\n\n+----+-------------+-------+-------+---------------+---------+---------+------+------+----------+--------------------------+\n| id | select_type | table | type&nbsp; | possible_keys | key&nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; | rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n+----+-------------+-------+-------+---------------+---------+---------+------+------+----------+--------------------------+\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | tab&nbsp; &nbsp;| range | idx_abc&nbsp; &nbsp; &nbsp; &nbsp;| idx_abc | 4&nbsp; &nbsp; &nbsp; &nbsp;| NULL |&nbsp; &nbsp; 4 |&nbsp; &nbsp;100.00 | Using index for group-by |\n+----+-------------+-------+-------+---------------+---------+---------+------+------+----------+--------------------------+\n</code></pre><ul>\n<li>LooseScan</li>\n</ul><p>LooseScan，以及FirstMatch、Start temporary、End temporary，都是子查询自动改写为表连接后的执行方式，我们在后续的子查询这一讲中再具体介绍。</p><pre><code class=\"language-plain\">mysql&gt; set optimizer_switch='materialization=off';\nQuery OK, 0 rows affected (0.01 sec)\n\n\nmysql&gt; explain select * from tab ta \n  where a=1 and c in (select a from tab tb);\n\n\n+----+-------------+-------+-------+---------------+---------+---------+-------+------+----------+------------------------+\n| id | select_type | table | type&nbsp; | possible_keys | key&nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; &nbsp;| rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n+----+-------------+-------+-------+---------------+---------+---------+-------+------+----------+------------------------+\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | tb&nbsp; &nbsp; | index | idx_abc&nbsp; &nbsp; &nbsp; &nbsp;| idx_abc | 12&nbsp; &nbsp; &nbsp; | NULL&nbsp; | 9913 |&nbsp; &nbsp; &nbsp;0.03 | Using index; LooseScan |\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | ta&nbsp; &nbsp; | ref&nbsp; &nbsp;| idx_abc&nbsp; &nbsp; &nbsp; &nbsp;| idx_abc | 4&nbsp; &nbsp; &nbsp; &nbsp;| const | 3333 |&nbsp; &nbsp; 10.00 | Using index condition&nbsp; |\n+----+-------------+-------+-------+---------------+---------+---------+-------+------+----------+------------------------+\n</code></pre><ul>\n<li>FirstMatch(ta)</li>\n</ul><pre><code class=\"language-plain\">mysql&gt; set optimizer_switch='materialization=off';\nQuery OK, 0 rows affected (0.01 sec)\n\n\nmysql&gt; explain select * from tab ta where a=1 and c in (select c from tab tb);\n+----+-------------+-------+-------+---------------+---------+---------+-------+------+----------+-------------------------------------------------------------------------+\n| id | select_type | table | type&nbsp; | possible_keys | key&nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; &nbsp;| rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|\n+----+-------------+-------+-------+---------------+---------+---------+-------+------+----------+-------------------------------------------------------------------------+\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | ta&nbsp; &nbsp; | ref&nbsp; &nbsp;| idx_abc&nbsp; &nbsp; &nbsp; &nbsp;| idx_abc | 4&nbsp; &nbsp; &nbsp; &nbsp;| const | 3333 |&nbsp; &nbsp;100.00 | NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | tb&nbsp; &nbsp; | index | NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | idx_abc | 12&nbsp; &nbsp; &nbsp; | NULL&nbsp; | 9913 |&nbsp; &nbsp; 10.00 | Using where; Using index; FirstMatch(ta); Using join buffer (hash join) |\n+----+-------------+-------+-------+---------------+---------+---------+-------+------+----------+-------------------------------------------------------------------------+\n</code></pre><ul>\n<li>Start temporary, End temporary</li>\n</ul><pre><code class=\"language-plain\">mysql&gt; set optimizer_switch='materialization=off';\nQuery OK, 0 rows affected (0.01 sec)\n\n\nmysql&gt; explain select * from tab ta where id in (select b from tab tb where b &lt; 10);\n\n\n+----+-------------+-------+--------+---------------+---------+---------+----------+------+----------+-------------------------------------------+\n| id | select_type | table | type&nbsp; &nbsp;| possible_keys | key&nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; &nbsp; &nbsp; | rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|\n+----+-------------+-------+--------+---------------+---------+---------+----------+------+----------+-------------------------------------------+\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | tb&nbsp; &nbsp; | index&nbsp; | NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | idx_abc | 12&nbsp; &nbsp; &nbsp; | NULL&nbsp; &nbsp; &nbsp;| 9913 |&nbsp; &nbsp; 33.33 | Using where; Using index; Start temporary |\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | ta&nbsp; &nbsp; | eq_ref | PRIMARY&nbsp; &nbsp; &nbsp; &nbsp;| PRIMARY | 4&nbsp; &nbsp; &nbsp; &nbsp;| rep.tb.b |&nbsp; &nbsp; 1 |&nbsp; &nbsp;100.00 | End temporary&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|\n+----+-------------+-------+--------+---------------+---------+---------+----------+------+----------+-------------------------------------------+\n</code></pre><ul>\n<li>Using index condition</li>\n</ul><p>使用到了索引下推条件。</p><pre><code class=\"language-plain\">mysql&gt; explain select * from tab where a=1 and c=1;\n\n\n+----+-------------+-------+------+---------------+---------+---------+-------+------+----------+-----------------------+\n| id | select_type | table | type | possible_keys | key&nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; &nbsp;| rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|\n+----+-------------+-------+------+---------------+---------+---------+-------+------+----------+-----------------------+\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | tab&nbsp; &nbsp;| ref&nbsp; | idx_abc&nbsp; &nbsp; &nbsp; &nbsp;| idx_abc | 4&nbsp; &nbsp; &nbsp; &nbsp;| const | 3333 |&nbsp; &nbsp; 10.00 | Using index condition |\n+----+-------------+-------+------+---------------+---------+---------+-------+------+----------+-----------------------+\n</code></pre><ul>\n<li>Using filesort</li>\n</ul><p>说明查询需要排序。</p><pre><code class=\"language-plain\">mysql&gt; explain select * from tab order by b;\n\n\n+----+-------------+-------+------+---------------+------+---------+------+------+----------+----------------+\n| id | select_type | table | type | possible_keys | key&nbsp; | key_len | ref&nbsp; | rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n+----+-------------+-------+------+---------------+------+---------+------+------+----------+----------------+\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | tab&nbsp; &nbsp;| ALL&nbsp; | NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | NULL | NULL&nbsp; &nbsp; | NULL | 9913 |&nbsp; &nbsp;100.00 | Using filesort |\n+----+-------------+-------+------+---------------+------+---------+------+------+----------+----------------+\n</code></pre><ul>\n<li>Using join buffer (hash join)</li>\n</ul><p>被驱动表缺少合适的索引时，MySQL会考虑使用Hash连接算法。</p><pre><code class=\"language-plain\">mysql&gt; explain select * from tab t1, tab t2 where t1.a = 1 and t1.c=t2.c;\n\n\n+----+-------------+-------+------+---------------+---------+---------+-------+------+----------+--------------------------------------------+\n| id | select_type | table | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra                                      |\n+----+-------------+-------+------+---------------+---------+---------+-------+------+----------+--------------------------------------------+\n|  1 | SIMPLE      | t1    | ref  | idx_abc       | idx_abc | 4       | const | 3333 |   100.00 | NULL                                       |\n|  1 | SIMPLE      | t2    | ALL  | NULL          | NULL    | NULL    | NULL  | 9913 |    10.00 | Using where; Using join buffer (hash join) |\n+----+-------------+-------+------+---------------+---------+---------+-------+------+----------+--------------------------------------------+\n</code></pre><ul>\n<li>Using join buffer (Batched Key Access)</li>\n</ul><p>表关联时，使用了BKA优化。和MRR类似，BKA也是为了减少查询的随机IO的数量。</p><pre><code class=\"language-plain\">mysql&gt; explain select /*+ BKA(tb) */ * \n  from tab ta, tab tb where ta.a = tb.a;\n\n\n+----+-------------+-------+------+---------------+---------+---------+----------+------+----------+----------------------------------------+\n| id | select_type | table | type | possible_keys | key&nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; &nbsp; &nbsp; | rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n+----+-------------+-------+------+---------------+---------+---------+----------+------+----------+----------------------------------------+\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | ta&nbsp; &nbsp; | ALL&nbsp; | idx_abc&nbsp; &nbsp; &nbsp; &nbsp;| NULL&nbsp; &nbsp; | NULL&nbsp; &nbsp; | NULL&nbsp; &nbsp; &nbsp;| 9913 |&nbsp; &nbsp;100.00 | NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | tb&nbsp; &nbsp; | ref&nbsp; | idx_abc&nbsp; &nbsp; &nbsp; &nbsp;| idx_abc | 4&nbsp; &nbsp; &nbsp; &nbsp;| rep.ta.a | 3304 |&nbsp; &nbsp;100.00 | Using join buffer (Batched Key Access) |\n+----+-------------+-------+------+---------------+---------+---------+----------+------+----------+----------------------------------------+\n</code></pre><ul>\n<li>Using MRR</li>\n</ul><p>查询使用了MRR（Multi-Range Read），MRR主要是为了减少回表查询数据时随机IO的数量。下面这个例子中使用了BKA提示，强制优化器使用MRR。</p><pre><code class=\"language-plain\">mysql&gt; explain select /*+ BKA(tab) */ * \n  from tab \n  where a=1 and b in (1,2,3);\n\n\n+----+-------------+-------+-------+---------------+---------+---------+------+------+----------+----------------------------------+\n| id | select_type | table | type&nbsp; | possible_keys | key&nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; | rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n+----+-------------+-------+-------+---------------+---------+---------+------+------+----------+----------------------------------+\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | tab&nbsp; &nbsp;| range | idx_abc&nbsp; &nbsp; &nbsp; &nbsp;| idx_abc | 8&nbsp; &nbsp; &nbsp; &nbsp;| NULL |&nbsp; &nbsp; 3 |&nbsp; &nbsp;100.00 | Using index condition; Using MRR |\n+----+-------------+-------+-------+---------------+---------+---------+------+------+----------+----------------------------------+\n</code></pre><ul>\n<li>Using sort_union(…), Using union(…), Using intersect(…)</li>\n</ul><pre><code class=\"language-plain\">mysql&gt; explain select * \n  from t_merge \n  where b=2 and c=2 and d=1;\n+----+-------------+---------+-------------+---------------+---------------+---------+------+------+----------+---------------------------------------------+\n| id | select_type | table&nbsp; &nbsp;| type&nbsp; &nbsp; &nbsp; &nbsp; | possible_keys | key&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; | rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|\n+----+-------------+---------+-------------+---------------+---------------+---------+------+------+----------+---------------------------------------------+\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | t_merge | index_merge | idx_bd,idx_cd | idx_cd,idx_bd | 8,8&nbsp; &nbsp; &nbsp;| NULL |&nbsp; &nbsp; 2 |&nbsp; &nbsp; 66.99 | Using intersect(idx_cd,idx_bd); Using where |\n+----+-------------+---------+-------------+---------------+---------------+---------+------+------+----------+---------------------------------------------+\n\n\n\n\nmysql&gt; explain select * \n  from t_merge \n  where (b=2 and d=1) or (c=2 and d=1);\n+----+-------------+---------+-------------+---------------+---------------+---------+------+------+----------+-----------------------------------------+\n| id | select_type | table&nbsp; &nbsp;| type&nbsp; &nbsp; &nbsp; &nbsp; | possible_keys | key&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; | rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|\n+----+-------------+---------+-------------+---------------+---------------+---------+------+------+----------+-----------------------------------------+\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | t_merge | index_merge | idx_bd,idx_cd | idx_bd,idx_cd | 8,8&nbsp; &nbsp; &nbsp;| NULL |&nbsp; 108 |&nbsp; &nbsp;100.00 | Using union(idx_bd,idx_cd); Using where |\n+----+-------------+---------+-------------+---------------+---------------+---------+------+------+----------+-----------------------------------------+\n\n\n\n\nmysql&gt; explain select * \n  from t_merge \n  where (b=2 and d between 1 and 2) or (d=1 and c=2);\n+----+-------------+---------+-------------+---------------+---------------+---------+------+------+----------+----------------------------------------------+\n| id | select_type | table&nbsp; &nbsp;| type&nbsp; &nbsp; &nbsp; &nbsp; | possible_keys | key&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| key_len | ref&nbsp; | rows | filtered | Extra&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n+----+-------------+---------+-------------+---------------+---------------+---------+------+------+----------+----------------------------------------------+\n|&nbsp; 1 | SIMPLE&nbsp; &nbsp; &nbsp; | t_merge | index_merge | idx_bd,idx_cd | idx_bd,idx_cd | 8,8&nbsp; &nbsp; &nbsp;| NULL |&nbsp; 165 |&nbsp; &nbsp;100.00 | Using sort_union(idx_bd,idx_cd); Using where |\n+----+-------------+---------+-------------+---------------+---------------+---------+------+------+----------+----------------------------------------------+\n</code></pre><h2>总结</h2><p>出于完整性的考虑，这一讲中我们使用了四十多个SQL语句，演示并解释了MySQL执行计划的各种输出。在实际工作中，一般也不会遇到这里的每一种情况。</p><p>执行计划有几个信息要重点关注：</p><ul>\n<li>\n<p>通过ID、SELECT_TYPE、TABLE这几列可以了解语句整体的连接、嵌套结构。</p>\n</li>\n<li>\n<p>TYPE列为ref、range时，才是我们平时说的用到了索引。type为index时，实际上是使用了全索引扫描。</p>\n</li>\n<li>\n<p>ROWS列是优化器评估的需要从到存储引擎里访问的记录的数量，这个数量对性能有直接的影响。</p>\n</li>\n<li>\n<p>EXTRA列里面提供了执行计划的额外信息，对这里出现的内容要有大致的了解。</p>\n</li>\n</ul><p>你也可以使用FORMAT=TREE，以树的形式显示执行计划，有时候这样可能会更直观。</p><h2>思考题</h2><p>这一讲中有这么一个SQL：</p><pre><code class=\"language-plain\">select id, a, (select avg(b) from tab where a=t1.a) from tab t1;\n</code></pre><p>在我们的测试表中，字段A的唯一值有三个，所以理论上，最优的情况下只需要将3个不同的A的值分别传入子查询中（select avg(b) from tab where a = t1.a），并将计算结果缓存起来，这样子查询只需要执行3次。</p><p>MariaDB实际上就有这样的处理，因此在执行上面这个SQL时，速度比较快。</p><pre><code class=\"language-plain\">mariadb&gt; select id, a, (select avg(b) from tab where a=t1.a) from tab t1 order by id;\n+------+---+---------------------------------------+\n| id   | a | (select avg(b) from tab where a=t1.a) |\n+------+---+---------------------------------------+\n|    0 | 0 |                             4999.5000 |\n|    1 | 1 |                             4999.0000 |\n|    2 | 2 |                             5000.0000 |\n......\n| 9999 | 0 |                             4999.5000 |\n+------+---+---------------------------------------+\n10000 rows in set (0.01 sec)\n</code></pre><p>但是MySQL中，同样的表结构和数据，配置一样的服务器，执行这个SQL时，执行时间是好几个数量级。</p><pre><code class=\"language-plain\">mysql&gt; select id, a, (select avg(b) from tab where a=t1.a) from tab t1 order by id;\n+------+------+---------------------------------------+\n| id   | a    | (select avg(b) from tab where a=t1.a) |\n+------+------+---------------------------------------+\n|    0 |    0 |                             4999.5000 |\n|    1 |    1 |                             4999.0000 |\n|    2 |    2 |                             5000.0000 |\n......\n| 9999 |    0 |                             4999.5000 |\n+------+------+---------------------------------------+\n10000 rows in set (4 min 17.90 sec)\n</code></pre><p>对于这种情况，你会怎么解决呢？</p><p>期待你的思考，欢迎在留言区中与我交流。如果今天的课程让你有所收获，也欢迎转发给有需要的朋友。我们下节课再见！</p>","comments":[{"had_liked":false,"id":394653,"user_name":"Shelly","can_delete":false,"product_type":"c1","uid":2422713,"ip_address":"美国","ucode":"75BA35C2737EA6","user_header":"https://static001.geekbang.org/account/avatar/00/24/f7/b9/f2eec64e.jpg","comment_is_top":false,"comment_ctime":1727430128,"is_pvip":false,"replies":[{"id":143283,"content":"就这个SQL，这样改性能也能提升很多。不过建议使用内连接。改成外连接，SQL的含义有区别，虽然在这里执行结果是一样的。\n\n如果要指定表连接的顺序，可以用STRAIGHT_JOIN。\n\n","user_name":"作者回复","user_name_real":"编辑","uid":3898827,"ctime":1727686530,"ip_address":"浙江","comment_id":394653,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100799401,"comment_content":"思考题： \nSELECT   \n    t1.id, \n    t1.a, \n    t2.avg_b \nFROM \n    tab t1   \nRIGHT JOIN \n    (SELECT \n        a, \n        AVG(b) AS avg_b \n     FROM \n        tab     \n     GROUP BY \n        a) t2 \nON\n    t1.a = t2.a \nORDER BY \n    t1.id;\n这么写会生成临时表，被驱动表t1被扫描三次","like_count":1,"discussions":[{"author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651905,"discussion_content":"就这个SQL，这样改性能也能提升很多。不过建议使用内连接。改成外连接，SQL的含义有区别，虽然在这里执行结果是一样的。\n\n如果要指定表连接的顺序，可以用STRAIGHT_JOIN。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1727686530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":394650,"user_name":"123","can_delete":false,"product_type":"c1","uid":2662872,"ip_address":"浙江","ucode":"5A343B568B9524","user_header":"https://static001.geekbang.org/account/avatar/00/28/a1/d8/42252c48.jpg","comment_is_top":false,"comment_ctime":1727423401,"is_pvip":false,"replies":[{"id":143275,"content":"我理解是在优化阶段就把表给替换掉了。对比下这面例子中的2个SQL，第一个SQL，形式上是表连接，但是看执行计划，实际上是单表查询了。\n\ncreate table t1(\n\tid int not null, \n\ta int not null, \n\tb int not null, \n\tc int, \n\tprimary key(id), \n\tunique key uk_a(a),\n\tkey idx_b(b)\n)engine=innodb;\n\ncreate table t2(\n\tid int not null, \n\ta int not null, \n\tb int not null, \n\tc int, \n\tprimary key(id), \n    key udx_c(c)\n)engine=innodb;\n\ninsert into t1(id, a,b,c) values(100, 1000, 1000, 10);\ninsert into t1(id, a,b,c) values(200, 2000, 2000, 10);\ninsert into t1(id, a,b,c) values(300, 3000, 3000, 10);\n\ninsert into t2(id, a,b,c)  values(101, 101, 201, 10);\ninsert into t2(id, a,b,c)  values(102, 102, 202, 10);\ninsert into t2(id, a,b,c)  values(103, 103, 203, 10);\n\nexplain format=tree select * from t1, t2 where t1.a=1000 and t2.c=t1.c\\G\n\nEXPLAIN: \n-&gt; Index lookup on t2 using udx_c (c=&#39;10&#39;)  (cost=0.80 rows=3)\n\n\nexplain format=tree select * from t1, t2 where t1.b=1000 and t2.c=t1.c\\G\n\nEXPLAIN: \n-&gt; Nested loop inner join  (cost=0.70 rows=1)\n    -&gt; Filter: (t1.c is not null)  (cost=0.35 rows=1)\n        -&gt; Index lookup on t1 using idx_b (b=1000)  (cost=0.35 rows=1)\n    -&gt; Index lookup on t2 using udx_c (c=t1.c)  (cost=0.35 rows=1)","user_name":"作者回复","user_name_real":"编辑","uid":3898827,"ctime":1727570933,"ip_address":"浙江","comment_id":394650,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100799401,"comment_content":"老师，文中说到“const 表示查询最多返回 1 行记录。对主键或唯一索引的所有字段都使用常量等值匹配时，type 为 const。优化器会将 type 为 const 的查询单元直接替换为常量表。”这个常量表具体指什么，是如何产生的？该主键索引的查询到的值不也是需要通过B+树层级扫描链接获取到吗？","like_count":1,"discussions":[{"author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651847,"discussion_content":"我理解是在优化阶段就把表给替换掉了。对比下这面例子中的2个SQL，第一个SQL，形式上是表连接，但是看执行计划，实际上是单表查询了。\n\ncreate table t1(\n\tid int not null, \n\ta int not null, \n\tb int not null, \n\tc int, \n\tprimary key(id), \n\tunique key uk_a(a),\n\tkey idx_b(b)\n)engine=innodb;\n\ncreate table t2(\n\tid int not null, \n\ta int not null, \n\tb int not null, \n\tc int, \n\tprimary key(id), \n    key udx_c(c)\n)engine=innodb;\n\ninsert into t1(id, a,b,c) values(100, 1000, 1000, 10);\ninsert into t1(id, a,b,c) values(200, 2000, 2000, 10);\ninsert into t1(id, a,b,c) values(300, 3000, 3000, 10);\n\ninsert into t2(id, a,b,c)  values(101, 101, 201, 10);\ninsert into t2(id, a,b,c)  values(102, 102, 202, 10);\ninsert into t2(id, a,b,c)  values(103, 103, 203, 10);\n\nexplain format=tree select * from t1, t2 where t1.a=1000 and t2.c=t1.c\\G\n\nEXPLAIN: \n-&gt; Index lookup on t2 using udx_c (c=&#39;10&#39;)  (cost=0.80 rows=3)\n\n\nexplain format=tree select * from t1, t2 where t1.b=1000 and t2.c=t1.c\\G\n\nEXPLAIN: \n-&gt; Nested loop inner join  (cost=0.70 rows=1)\n    -&gt; Filter: (t1.c is not null)  (cost=0.35 rows=1)\n        -&gt; Index lookup on t1 using idx_b (b=1000)  (cost=0.35 rows=1)\n    -&gt; Index lookup on t2 using udx_c (c=t1.c)  (cost=0.35 rows=1)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1727570933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":394642,"user_name":"叶明","can_delete":false,"product_type":"c1","uid":1412429,"ip_address":"江苏","ucode":"D0B4B7660DA766","user_header":"https://static001.geekbang.org/account/avatar/00/15/8d/4d/992070e8.jpg","comment_is_top":false,"comment_ctime":1727407712,"is_pvip":false,"replies":[{"id":143254,"content":"这样改效果不错👍","user_name":"作者回复","user_name_real":"编辑","uid":3898827,"ctime":1727421424,"ip_address":"浙江","comment_id":394642,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100799401,"comment_content":"思考题\n将子查询改为联表查询，先聚合后 join,避免对表中每行记录都进行聚合计算\n  \nselect\n  t1.id,\n  t1.a,\n  t2.avg_b\nfrom\n  tab t1\n  inner join (\n    select\n      a,\n      avg(b) avg_b\n    from\n      tab\n    group by\n      a\n  ) t2 on t1.a = t2.a\norder by\n  id;\n\n10000 rows in set (0.04 sec)","like_count":0,"discussions":[{"author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651779,"discussion_content":"这样改效果不错👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1727421424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]}]}