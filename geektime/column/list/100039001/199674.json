{"id":199674,"title":"46 | 建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式","content":"<p>上两节课中，我们学习了工厂模式，讲了工厂模式的应用场景，并带你实现了一个简单的DI容器。今天，我们再来学习另外一个比较常用的创建型设计模式，<strong>Builder模式</strong>，中文翻译为<strong>建造者模式</strong>或者<strong>构建者模式</strong>，也有人叫它<strong>生成器模式</strong>。</p><p>实际上，建造者模式的原理和代码实现非常简单，掌握起来并不难，难点在于应用场景。比如，你有没有考虑过这样几个问题：直接使用构造函数或者配合set方法就能创建对象，为什么还需要建造者模式来创建呢？建造者模式和工厂模式都可以创建对象，那它们两个的区别在哪里呢？</p><p>话不多说，带着上面两个问题，让我们开始今天的学习吧！</p><h2>为什么需要建造者模式？</h2><p>在平时的开发中，创建一个对象最常用的方式是，使用new关键字调用类的构造函数来完成。我的问题是，什么情况下这种方式就不适用了，就需要采用建造者模式来创建对象呢？你可以先思考一下，下面我通过一个例子来带你看一下。</p><p>假设有这样一道设计面试题：我们需要定义一个资源池配置类ResourcePoolConfig。这里的资源池，你可以简单理解为线程池、连接池、对象池等。在这个资源池配置类中，有以下几个成员变量，也就是可配置项。现在，请你编写代码实现这个ResourcePoolConfig类。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/21/59/21f970b7c0d6b5afa6aa09ca14f55059.jpg?wh=2463*936\" alt=\"\"></p><p>只要你稍微有点开发经验，那实现这样一个类对你来说并不是件难事。最常见、最容易想到的实现思路如下代码所示。因为maxTotal、maxIdle、minIdle不是必填变量，所以在创建ResourcePoolConfig对象的时候，我们通过往构造函数中，给这几个参数传递null值，来表示使用默认值。</p><pre><code>public class ResourcePoolConfig {\n  private static final int DEFAULT_MAX_TOTAL = 8;\n  private static final int DEFAULT_MAX_IDLE = 8;\n  private static final int DEFAULT_MIN_IDLE = 0;\n\n  private String name;\n  private int maxTotal = DEFAULT_MAX_TOTAL;\n  private int maxIdle = DEFAULT_MAX_IDLE;\n  private int minIdle = DEFAULT_MIN_IDLE;\n\n  public ResourcePoolConfig(String name, Integer maxTotal, Integer maxIdle, Integer minIdle) {\n    if (StringUtils.isBlank(name)) {\n      throw new IllegalArgumentException(&quot;name should not be empty.&quot;);\n    }\n    this.name = name;\n\n    if (maxTotal != null) {\n      if (maxTotal &lt;= 0) {\n        throw new IllegalArgumentException(&quot;maxTotal should be positive.&quot;);\n      }\n      this.maxTotal = maxTotal;\n    }\n\n    if (maxIdle != null) {\n      if (maxIdle &lt; 0) {\n        throw new IllegalArgumentException(&quot;maxIdle should not be negative.&quot;);\n      }\n      this.maxIdle = maxIdle;\n    }\n\n    if (minIdle != null) {\n      if (minIdle &lt; 0) {\n        throw new IllegalArgumentException(&quot;minIdle should not be negative.&quot;);\n      }\n      this.minIdle = minIdle;\n    }\n  }\n  //...省略getter方法...\n}\n</code></pre><p>现在，ResourcePoolConfig只有4个可配置项，对应到构造函数中，也只有4个参数，参数的个数不多。但是，如果可配置项逐渐增多，变成了8个、10个，甚至更多，那继续沿用现在的设计思路，构造函数的参数列表会变得很长，代码在可读性和易用性上都会变差。在使用构造函数的时候，我们就容易搞错各参数的顺序，传递进错误的参数值，导致非常隐蔽的bug。</p><pre><code>// 参数太多，导致可读性差、参数可能传递错误\nResourcePoolConfig config = new ResourcePoolConfig(&quot;dbconnectionpool&quot;, 16, null, 8, null, false , true, 10, 20，false， true);\n</code></pre><p>解决这个问题的办法你应该也已经想到了，那就是用set()函数来给成员变量赋值，以替代冗长的构造函数。我们直接看代码，具体如下所示。其中，配置项name是必填的，所以我们把它放到构造函数中设置，强制创建类对象的时候就要填写。其他配置项maxTotal、maxIdle、minIdle都不是必填的，所以我们通过set()函数来设置，让使用者自主选择填写或者不填写。</p><pre><code>public class ResourcePoolConfig {\n  private static final int DEFAULT_MAX_TOTAL = 8;\n  private static final int DEFAULT_MAX_IDLE = 8;\n  private static final int DEFAULT_MIN_IDLE = 0;\n\n  private String name;\n  private int maxTotal = DEFAULT_MAX_TOTAL;\n  private int maxIdle = DEFAULT_MAX_IDLE;\n  private int minIdle = DEFAULT_MIN_IDLE;\n  \n  public ResourcePoolConfig(String name) {\n    if (StringUtils.isBlank(name)) {\n      throw new IllegalArgumentException(&quot;name should not be empty.&quot;);\n    }\n    this.name = name;\n  }\n\n  public void setMaxTotal(int maxTotal) {\n    if (maxTotal &lt;= 0) {\n      throw new IllegalArgumentException(&quot;maxTotal should be positive.&quot;);\n    }\n    this.maxTotal = maxTotal;\n  }\n\n  public void setMaxIdle(int maxIdle) {\n    if (maxIdle &lt; 0) {\n      throw new IllegalArgumentException(&quot;maxIdle should not be negative.&quot;);\n    }\n    this.maxIdle = maxIdle;\n  }\n\n  public void setMinIdle(int minIdle) {\n    if (minIdle &lt; 0) {\n      throw new IllegalArgumentException(&quot;minIdle should not be negative.&quot;);\n    }\n    this.minIdle = minIdle;\n  }\n  //...省略getter方法...\n}\n</code></pre><p>接下来，我们来看新的ResourcePoolConfig类该如何使用。我写了一个示例代码，如下所示。没有了冗长的函数调用和参数列表，代码在可读性和易用性上提高了很多。</p><pre><code>// ResourcePoolConfig使用举例\nResourcePoolConfig config = new ResourcePoolConfig(&quot;dbconnectionpool&quot;);\nconfig.setMaxTotal(16);\nconfig.setMaxIdle(8);\n</code></pre><p>至此，我们仍然没有用到建造者模式，通过构造函数设置必填项，通过set()方法设置可选配置项，就能实现我们的设计需求。如果我们把问题的难度再加大点，比如，还需要解决下面这三个问题，那现在的设计思路就不能满足了。</p><ul>\n<li>我们刚刚讲到，name是必填的，所以，我们把它放到构造函数中，强制创建对象的时候就设置。如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填项也通过set()方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了。</li>\n<li>除此之外，假设配置项之间有一定的依赖关系，比如，如果用户设置了maxTotal、maxIdle、minIdle其中一个，就必须显式地设置另外两个；或者配置项之间有一定的约束条件，比如，maxIdle和minIdle要小于等于maxTotal。如果我们继续使用现在的设计思路，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了。</li>\n<li>如果我们希望ResourcePoolConfig类对象是不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值。要实现这个功能，我们就不能在ResourcePoolConfig类中暴露set()方法。</li>\n</ul><p>为了解决这些问题，建造者模式就派上用场了。</p><p>我们可以把校验逻辑放置到Builder类中，先创建建造者，并且通过set()方法设置建造者的变量值，然后在使用build()方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。除此之外，我们把ResourcePoolConfig的构造函数改为private私有权限。这样我们就只能通过建造者来创建ResourcePoolConfig类对象。并且，ResourcePoolConfig没有提供任何set()方法，这样我们创建出来的对象就是不可变对象了。</p><p>我们用建造者模式重新实现了上面的需求，具体的代码如下所示：</p><pre><code>public class ResourcePoolConfig {\n  private String name;\n  private int maxTotal;\n  private int maxIdle;\n  private int minIdle;\n\n  private ResourcePoolConfig(Builder builder) {\n    this.name = builder.name;\n    this.maxTotal = builder.maxTotal;\n    this.maxIdle = builder.maxIdle;\n    this.minIdle = builder.minIdle;\n  }\n  //...省略getter方法...\n\n  //我们将Builder类设计成了ResourcePoolConfig的内部类。\n  //我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。\n  public static class Builder {\n    private static final int DEFAULT_MAX_TOTAL = 8;\n    private static final int DEFAULT_MAX_IDLE = 8;\n    private static final int DEFAULT_MIN_IDLE = 0;\n\n    private String name;\n    private int maxTotal = DEFAULT_MAX_TOTAL;\n    private int maxIdle = DEFAULT_MAX_IDLE;\n    private int minIdle = DEFAULT_MIN_IDLE;\n\n    public ResourcePoolConfig build() {\n      // 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等\n      if (StringUtils.isBlank(name)) {\n        throw new IllegalArgumentException(&quot;...&quot;);\n      }\n      if (maxIdle &gt; maxTotal) {\n        throw new IllegalArgumentException(&quot;...&quot;);\n      }\n      if (minIdle &gt; maxTotal || minIdle &gt; maxIdle) {\n        throw new IllegalArgumentException(&quot;...&quot;);\n      }\n\n      return new ResourcePoolConfig(this);\n    }\n\n    public Builder setName(String name) {\n      if (StringUtils.isBlank(name)) {\n        throw new IllegalArgumentException(&quot;...&quot;);\n      }\n      this.name = name;\n      return this;\n    }\n\n    public Builder setMaxTotal(int maxTotal) {\n      if (maxTotal &lt;= 0) {\n        throw new IllegalArgumentException(&quot;...&quot;);\n      }\n      this.maxTotal = maxTotal;\n      return this;\n    }\n\n    public Builder setMaxIdle(int maxIdle) {\n      if (maxIdle &lt; 0) {\n        throw new IllegalArgumentException(&quot;...&quot;);\n      }\n      this.maxIdle = maxIdle;\n      return this;\n    }\n\n    public Builder setMinIdle(int minIdle) {\n      if (minIdle &lt; 0) {\n        throw new IllegalArgumentException(&quot;...&quot;);\n      }\n      this.minIdle = minIdle;\n      return this;\n    }\n  }\n}\n\n// 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdle\nResourcePoolConfig config = new ResourcePoolConfig.Builder()\n        .setName(&quot;dbconnectionpool&quot;)\n        .setMaxTotal(16)\n        .setMaxIdle(10)\n        .setMinIdle(12)\n        .build();\n</code></pre><p>\b</p><p>实际上，使用建造者模式创建对象，还能避免对象存在无效状态。我再举个例子解释一下。比如我们定义了一个长方形类，如果不使用建造者模式，采用先创建后set的方式，那就会导致在第一个set之后，对象处于无效状态。具体代码如下所示：</p><pre><code>Rectangle r = new Rectange(); // r is invalid\nr.setWidth(2); // r is invalid\nr.setHeight(3); // r is valid\n</code></pre><p>为了避免这种无效状态的存在，我们就需要使用构造函数一次性初始化好所有的成员变量。如果构造函数参数过多，我们就需要考虑使用建造者模式，先设置建造者的变量，然后再一次性地创建对象，让对象一直处于有效状态。</p><p>实际上，如果我们并不是很关心对象是否有短暂的无效状态，也不是太在意对象是否是可变的。比如，对象只是用来映射数据库读出来的数据，那我们直接暴露set()方法来设置类的成员变量值是完全没问题的。而且，使用建造者模式来构建对象，代码实际上是有点重复的，ResourcePoolConfig类中的成员变量，要在Builder类中重新再定义一遍。</p><h2>与工厂模式有何区别？</h2><p>从上面的讲解中，我们可以看出，建造者模式是让建造者类来负责对象的创建工作。上一节课中讲到的工厂模式，是由工厂类来负责对象创建的工作。那它们之间有什么区别呢？</p><p>实际上，工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。</p><p>网上有一个经典的例子很好地解释了两者的区别。</p><p>顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。</p><p>实际上，我们也不要太学院派，非得把工厂模式、建造者模式分得那么清楚，我们需要知道的是，每个模式为什么这么设计，能解决什么问题。<strong>只有了解了这些最本质的东西，我们才能不生搬硬套，才能灵活应用，甚至可以混用各种模式创造出新的模式，来解决特定场景的问题。</strong></p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>建造者模式的原理和实现比较简单，重点是掌握应用场景，避免过度使用。</p><p>如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合set()方法来解决。但是，如果存在下面情况中的任意一种，我们就要考虑使用建造者模式了。</p><ul>\n<li>我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填属性通过set()方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。</li>\n<li>如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合set()方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。</li>\n<li>如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露set()方法。构造函数配合set()方法来设置属性值的方式就不适用了。</li>\n</ul><p>除此之外，在今天的讲解中，我们还对比了工厂模式和建造者模式的区别。工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。</p><h2>课堂讨论</h2><p>在下面的ConstructorArg类中，当isRef为true的时候，arg表示String类型的refBeanId，type不需要设置；当isRef为false的时候，arg、type都需要设置。请根据这个需求，完善ConstructorArg类。</p><pre><code> public class ConstructorArg {\n    private boolean isRef;\n    private Class type;\n    private Object arg;\n    // TODO: 待完善...\n  }\n</code></pre><p>欢迎留言和我分享你的想法，如果有收获，你也可以把这篇文章分享给你的朋友。</p>","comments":[{"had_liked":false,"id":179112,"user_name":"webmin","can_delete":false,"product_type":"c1","uid":1047014,"ip_address":"","ucode":"98B0CA882454E8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/e6/47742988.jpg","comment_is_top":false,"comment_ctime":1581918811,"is_pvip":true,"discussion_count":13,"race_medal":0,"score":"461143419483","product_id":100039001,"comment_content":"public class ConstructorArg {<br>    private boolean isRef;<br>    private Class type;<br>    private Object arg;<br><br>    public boolean isRef() {<br>        return isRef;<br>    }<br><br>    public Class getType() {<br>        return type;<br>    }<br><br>    public Object getArg() {<br>        return arg;<br>    }<br><br>    private ConstructorArg(Builder builder) {<br>        this.isRef = builder.isRef;<br>        this.type = builder.type;<br>        this.arg = builder.arg;<br>    }<br><br>    public static class Builder {<br>        private boolean isRef;<br>        private Class type;<br>        private Object arg;<br><br>        public ConstructorArg build() {<br>            if(isRef &amp;&amp; type != null) {<br>                throw new IllegalArgumentException(&quot;...&quot;);<br>            }<br><br>            if (!isRef &amp;&amp; type == null) {<br>                throw new IllegalArgumentException(&quot;...&quot;);<br>            }<br><br>            if (this.isRef &amp;&amp; (arg != null &amp;&amp; arg.getClass() != String.class)) {<br>                throw new IllegalArgumentException(&quot;...&quot;);<br>            }<br><br>            if (!this.isRef &amp;&amp; arg == null) {<br>                throw new IllegalArgumentException(&quot;...&quot;);<br>            }<br><br>            return new ConstructorArg(this);<br>        }<br><br>        public Builder setRef(boolean ref) {<br>            if(ref &amp;&amp; this.type != null) {<br>                throw new IllegalArgumentException(&quot;...&quot;);<br>            }<br>            this.isRef = ref;<br>            return this;<br>        }<br><br>        public Builder setType(Class type) {<br>            if (this.isRef || type == null) {<br>                throw new IllegalArgumentException(&quot;...&quot;);<br>            }<br>            this.type = type;<br>            return this;<br>        }<br><br>        public Builder setArg(Object arg) {<br>            if (this.isRef &amp;&amp; (arg != null &amp;&amp; arg.getClass() != String.class)) {<br>                throw new IllegalArgumentException(&quot;...&quot;);<br>            }<br><br>            if (!this.isRef &amp;&amp; arg == null) {<br>                throw new IllegalArgumentException(&quot;...&quot;);<br>            }<br>            this.arg = arg;<br>            return this;<br>        }<br>    }<br>}","like_count":107,"discussions":[{"author":{"id":1206787,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6a/03/cb597311.jpg","nickname":"远心","note":"","ucode":"1157202C315655","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52964,"discussion_content":"哈哈哈，这个我也注意到了，后面我想了下，应该是：人类认知世界的方法是 OO 的，但执行行动的方式却是 PO 的。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1574114713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205013,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1586507634,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"422493302642","product_id":100039001,"comment_content":"简单理解就是：工厂模式是根据不同的条件生成不同Class的对象，构建者模式是根据不同参数生成一个class的不同对象。","like_count":98,"discussions":[{"author":{"id":1435246,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e6/6e/062da5e4.jpg","nickname":"肥而不腻","note":"","ucode":"3E6786A82A6DD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52647,"discussion_content":"trade off就很洋气了，😃","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574076106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179180,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1581932418,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"229215199106","product_id":100039001,"comment_content":"打卡<br>一、使用场景：<br>1）类的构造函数必填属性很多，通过set设置，没有办法校验必填属性<br>2）如果类的属性之间有一定的依赖关系，构造函数配合set方式，无法进行依赖关系和约束条件校验<br>3）需要创建不可变对象，不能暴露set方法。<br>（前提是需要传递很多的属性，如果属性很少，可以不需要建造者模式）<br>二、实现方式：<br>把构造函数定义为private，定义public static class Builder 内部类，通过Builder 类的set方法设置属性，调用build方法创建对象。<br><br>三、和工厂模式的区别：<br>1）工厂模式：创建不同的同一类型对象（集成同一个父类或是接口的一组子类），由给定的参数来创建哪种类型的对象；<br>2）建造者模式：创建一种类型的复杂对象，通过很多可设置参数，“定制化”的创建对象","like_count":53,"discussions":[{"author":{"id":1640974,"avatar":"","nickname":"大风","note":"","ucode":"583873CCAA2A67","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":354992,"discussion_content":"关于和工厂模式的区别，我再补充一点：两者都会由调用方来传入参数，不同点在于工厂模式中的参数的功能是为要创建的对象指明目标类型，而在建造者模式中的参数则关注的是为要创建的对象本身的成员传递值。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1615373669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1218665,"avatar":"https://static001.geekbang.org/account/avatar/00/12/98/69/5a1c6620.jpg","nickname":"cosz3","note":"","ucode":"B9023D4A088CF2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381548,"discussion_content":"我觉得还是从 SOILD 原则来解释，理由更充分一些。这些场景不是必须使用建造者，也有别的方法可以代替？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625124123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1099329,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c6/41/b868f086.jpg","nickname":"小确幸","note":"","ucode":"C090505CB2DB69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340069,"discussion_content":"感觉build类中，很多属性要与建造的类相同（因为要传递很多属性）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609896880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1161271,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","nickname":"不似旧日","note":"","ucode":"DF4C5E3AB9570C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":183830,"discussion_content":"不错，棒棒哒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582522510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179045,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1581903428,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"181970529860","product_id":100039001,"comment_content":"课堂讨论题：<br><br>&#47;**<br> * 在下面的 ConstructorArg 类中，<br> * 当 isRef 为 true 的时候，arg 表示 String 类型的 refBeanId，type 不需要设置；<br> * 当 isRef 为 false 的时候，arg、type 都需要设置<br> *<br> * @author javaadu<br> *&#47;<br>public class ConstructorArg {<br>    private boolean isRef;<br>    private Class type;<br>    private Object arg;<br><br>    private ConstructorArg(Builder builder) {<br>        this.isRef = builder.isRef;<br>        this.type = builder.type;<br>        this.arg = builder.arg;<br>    }<br><br>    public static class Builder {<br>        private boolean isRef;<br>        private Class type;<br>        private Object arg;<br><br>        public ConstructorArg build() {<br>            if (arg == null) {<br>                throw new IllegalArgumentException(&quot;arg必须设置&quot;);<br>            }<br>            if (isRef) {<br>                if (!(arg instanceof String)) {<br>                    throw new IllegalArgumentException(&quot;arg必须为String类型的对象&quot;);<br>                }<br>            } else {<br>                if (type == null) {<br>                    throw new IllegalArgumentException(&quot;arg必须设置&quot;);<br>                }<br>            }<br><br>            return new ConstructorArg(this)<br>        }<br><br>        public Builder setRef(boolean ref) {<br>            isRef = ref;<br>            return this;<br>        }<br><br>        public Builder setArg(Object arg) {<br>            this.arg = arg;<br>            return this;<br>        }<br><br>        public Builder setType(Class type) {<br>            this.type = type;<br>            return this;<br>        }<br>    }<br>}","like_count":42},{"had_liked":false,"id":212210,"user_name":"zhengyu.nie","can_delete":false,"product_type":"c1","uid":1541669,"ip_address":"","ucode":"FFE0377D323E46","user_header":"https://static001.geekbang.org/account/avatar/00/17/86/25/25ded6c3.jpg","comment_is_top":false,"comment_ctime":1588075378,"is_pvip":true,"replies":[{"id":"78922","content":"👍","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1588129584,"ip_address":"","comment_id":212210,"utype":1}],"discussion_count":2,"race_medal":0,"score":"173386767218","product_id":100039001,"comment_content":"依赖关系（Dependencies）、合法校验（Preconditions）、不可变（Immutable）。<br>争哥这几个描述很精准！<br>借着思路延伸一下的话，很多库和设计都是以上这些理念的。<br>比如com.google.guava的校验、不可变集合，多线程设计模式中的Immutable模式、保护性拷贝（其中又可以分深浅api），java.lang.String的不可变设计。还有关于类状态的控制，还有Effective Java中类创建这一章中对于构造方法、set方法、Builder构建、枚举、静态工厂方法构建等对比，像Guava Lists、Sets、Maps、ImmutableList这种创建方式现在也很主流了","like_count":40,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493454,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588129584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2277251,"avatar":"https://static001.geekbang.org/account/avatar/00/22/bf/83/c83be5a3.jpg","nickname":"eHackyd","note":"","ucode":"E6E7994FBDF0A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":589718,"discussion_content":"争哥，发现网上很多blog和你讲的builder的实现方式是不同的，如https://blog.csdn.net/jason0539/article/details/44992733和https://blog.csdn.net/carson_ho/article/details/54910597，这两篇都算高阅读的blog有说服力，他们都写了builder中涉及4个角色。能否说明下，我感觉他们说的也算builder的一种？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665282515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":493454,"ip_address":"广东"},"score":589718,"extra":""}]}]},{"had_liked":false,"id":185330,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1583562750,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"74598006782","product_id":100039001,"comment_content":"说说自己读了 Builder 模式的最大感悟：<br>1、Builder 模式可以保证对象的状态。<br>2、Builder 模式可以把对象的构造鉴定逻辑写在Builder类中，保证了类的简洁。<br><br>平时普普通通地使用 lombok 生成 Builder，应该更加深入地了解一下。","like_count":17},{"had_liked":false,"id":179269,"user_name":"黄林晴","can_delete":false,"product_type":"c1","uid":1362631,"ip_address":"","ucode":"B15C38AECDA88F","user_header":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","comment_is_top":false,"comment_ctime":1581948723,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"48826588979","product_id":100039001,"comment_content":"打卡~<br>最近半年用的最多的就是Builder模式了","like_count":11,"discussions":[{"author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294088,"discussion_content":"你有没有感觉老师说的建造者模式和GOF的不一样？\n老师侧重点不是构建和表示分离，也无法用同一个builder创建不同的对象。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1595777159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2277251,"avatar":"https://static001.geekbang.org/account/avatar/00/22/bf/83/c83be5a3.jpg","nickname":"eHackyd","note":"","ucode":"E6E7994FBDF0A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589714,"discussion_content":"好像网上很多blog和这里讲的都不同，比如https://blog.csdn.net/jason0539/article/details/44992733，应该就是你说的gof中的builder，但我没看过gof里的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665281156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":294088,"ip_address":"广东"},"score":589714,"extra":""}]}]},{"had_liked":false,"id":179094,"user_name":"王涛","can_delete":false,"product_type":"c1","uid":1556838,"ip_address":"","ucode":"0A9ACC370F112D","user_header":"https://static001.geekbang.org/account/avatar/00/17/c1/66/e8dfeef4.jpg","comment_is_top":false,"comment_ctime":1581912321,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35941650689","product_id":100039001,"comment_content":"最近，在学习本专栏的过程中。<br>逐渐体会到“知其然，更知其所以然”的感觉<br>","like_count":8},{"had_liked":false,"id":179268,"user_name":"啦啦啦","can_delete":false,"product_type":"c1","uid":1131687,"ip_address":"","ucode":"6B12EC90A62525","user_header":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","comment_is_top":false,"comment_ctime":1581948702,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31646719774","product_id":100039001,"comment_content":"用php实现了一个<br>&lt;?php<br>class ResourcePoolConfig{<br>    private $maxTotal;<br>    private $maxIdle;<br>    private $minIdle;<br>    public function __construct(build $build)<br>    {<br>        $this-&gt;maxTotal = $build-&gt;maxTotal;<br>        $this-&gt;maxIdle = $build-&gt;maxIdle;<br>        $this-&gt;minIdle = $build-&gt;minIdle;<br>        echo &#39;maxTotal&#39;.$this-&gt;maxTotal;<br>        echo &#39;&lt;br &#47;&gt;&#39;;<br>        echo &#39;maxIdle&#39;.$this-&gt;maxIdle;<br>        echo &#39;&lt;br &#47;&gt;&#39;;<br>        echo &#39;minIdle&#39;.$this-&gt;minIdle;<br>        echo &#39;&lt;br &#47;&gt;&#39;;<br>    }<br>}<br><br>class Builder{<br>    public $maxTotal;<br>    public $maxIdle;<br>    public $minIdle;<br>    public function noodleValidate(){<br>        if($this-&gt;maxIdle&gt;$this-&gt;maxTotal){<br>            throw new Exception(&quot;maxIdle抛出异常&quot;);<br>        }<br>        if($this-&gt;minIdle&gt;$this-&gt;maxTotal){<br>            throw new Exception(&quot;minIdle抛出异常&quot;);<br>        }<br>    }<br><br>    public function setMaxTotal($value=20){<br>        $this-&gt;maxTotal = $value;<br>        return $this;<br>    }<br><br>    public function setMaxIdle($value=10){<br>        $this-&gt;maxIdle = $value;<br>        return $this;<br>    }<br><br>    public function setMinIdle($value=10){<br>        $this-&gt;minIdle = $value;<br>        return $this;<br>    }<br>}<br><br>$b = new Builder();<br>$b-&gt;setMaxTotal(5)-&gt;setMaxIdle()-&gt;setMinIdle()-&gt;noodleValidate();<br>new ResourcePoolConfig($b);","like_count":7},{"had_liked":false,"id":179089,"user_name":"Ken张云忠","can_delete":false,"product_type":"c1","uid":1134288,"ip_address":"","ucode":"D0BAC9FC17DE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","comment_is_top":false,"comment_ctime":1581910909,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"31646681981","product_id":100039001,"comment_content":"public class ConstructorArg {<br>    private boolean isRef;<br>    private Class type;<br>    private Object arg;<br>    public ConstructorArg(ConstructorArgBuilder builder) {<br>        this.isRef = builder.isRef;<br>        this.type = builder.type;<br>        this.arg = builder.arg;<br>    }<br>    public static class ConstructorArgBuilder {<br>        private boolean isRef;<br>        private Class type;<br>        private Object arg;<br>        public ConstructorArg builder() {<br>            if (arg == null) {<br>                throw new IllegalArgumentException(&quot;arg should not be null&quot;);<br>            }<br>            if (isRef == true) {<br>                if (arg instanceof String) {<br>                    type = String.class;<br>                } else {<br>                    throw  new IllegalArgumentException(&quot;when isRef is true,arg should be String type&quot;);<br>                }<br>            } else {<br>                type = arg.getClass();<br>            }<br>            return new ConstructorArg(this);<br>        }<br>        public ConstructorArgBuilder(boolean isRef) {<br>            this.isRef = isRef;<br>        }<br>        public ConstructorArgBuilder setArg(Object arg) {<br>            this.arg = arg;<br>            return this;<br>        }<br>    }<br>}<br> &#47;&#47; use case<br>ConstructorArg constructorArg = new ConstructorArgBuilder(true).setArg(0).builder();<br>ConstructorArg constructorArg1 = new ConstructorArgBuilder(false).setArg(1).builder();","like_count":7,"discussions":[{"author":{"id":2859716,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/a2/c4/11cf22de.jpg","nickname":"....","note":"","ucode":"A3D57E87F15227","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537075,"discussion_content":" if (isRef == true)  很nice","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638951126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2277321,"avatar":"https://static001.geekbang.org/account/avatar/00/22/bf/c9/7f23f3ec.jpg","nickname":"momo","note":"","ucode":"00DB6D76B7B25A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380367,"discussion_content":"你的调用方式出错了吧，应该是外部类.内部类吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624456777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238866,"user_name":"业余爱好者","can_delete":false,"product_type":"c1","uid":1482915,"ip_address":"","ucode":"A890935A982988","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","comment_is_top":false,"comment_ctime":1596348129,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27366151905","product_id":100039001,"comment_content":"创建型模式的作用在于，将对象“获取”（没有用创建）的过程独立出来，形成单独的类。这在获取复杂或者有特殊需求的对象时可以更好的体现单一职责原则---我负责拿到（ready to use）对象,你只管使用就可以了。你不需要关系我是不是懒加载之类的问题。<br><br>一个可以使用的对象，它的意义绝不单单是new一下就完事了，还有一系列其他的考量。<br>如果要求一个类只有一个全局唯一的对象，如基本不变化的配置信息类，这就是单例模式。如何控制只有一个对象，当然是拦截掉所有其他创建对象的路径，只留下一条路---使用类唯一的静态方法获取对象。这就是为什么，单例一般都要求将构造方法私有化。（spring的单例bean其实只是一种单例的约定，你完全可以自己new一个。）单例模式还设计到懒加载的问题，不过由于只有一个访问入口，处理起来比较简单。<br><br>工厂模式就比较纯粹了，工厂的意义就是在于获取一个对象。简单工工厂类如果是无状态的话，完全可以使用静态方法的形式，没有必要每创建一个对象都先弄个完全一样的工厂出来。<br>当需要有根据不同情况创建不同子类的时候，如果分支不多的话，完全可以使用if else,不过也可以考虑使用多态。不同的情况创建不同的工厂，将相应子类各异的创建逻辑分开。这就是工厂方法。<br>而如果是创建一个产品系列的话，就使用抽象工厂模式。<br><br>建造者用于处理创建参数过多的情形，同时可以校验参数，避免对象创建过程中的不一致状态。<br><br>原型用于快速拷贝一个对象。","like_count":6},{"had_liked":false,"id":193485,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1584917382,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"27354721158","product_id":100039001,"comment_content":"“如果我们并不是很关心对象是否有短暂的无效状态”<br><br>中间短暂的无效状态会怎么样呢？没理解。是在多线程下会有问题吗？如果是，如果是类对象，这本身一组操作就应该加锁，如果是方法内部不存在线程安全问题，所以没理解短暂的无效状态会怎么样<br><br><br>","like_count":6,"discussions":[{"author":{"id":1640974,"avatar":"","nickname":"大风","note":"","ucode":"583873CCAA2A67","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":354995,"discussion_content":"我理解这里的短暂的无效状态是指比如例子中的长方形，比如只传入了一个长的值而没有传入宽的值，这时，这个长方形如果被构造出来的话，宽会是默认值0，那就是一个无效状态。之后再通过set方法设置对象宽的值，这时长宽都是有效意义的就算是从短暂的无效状态变为有效状态了。而这种短暂的无效状态有的场景也是不可接受的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1615374051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1401217,"avatar":"https://static001.geekbang.org/account/avatar/00/15/61/81/9e34165b.jpg","nickname":"rovernerd","note":"","ucode":"C8620AAF0E4920","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1640974,"avatar":"","nickname":"大风","note":"","ucode":"583873CCAA2A67","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376710,"discussion_content":"比如说哪些场景？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622288754,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":354995,"ip_address":""},"score":376710,"extra":""}]}]},{"had_liked":false,"id":185337,"user_name":"1024","can_delete":false,"product_type":"c1","uid":1086407,"ip_address":"","ucode":"DCC31F6EC54F43","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/c7/86352ccc.jpg","comment_is_top":false,"comment_ctime":1583564061,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"27353367837","product_id":100039001,"comment_content":"做了一下课后题，和其他同学的答案比较了下，还是有些疑惑，疑惑在属性的判断逻辑是放在Builder的setAttr()内还是放在build()内<br>个人认为：<br>setAttr()放属性自己的逻辑判断，比如不要为null，不能大于或小于某个常量<br>build()方法放多个属性间的校验逻辑，因为调用builde()时，属性都set完成，这时候才有机会通过builde()来全局考虑所有属性的逻辑。<br>基于此，我的答案如下<br>public class ConstructorArg {<br>    private boolean isRef;<br>    private Class type;<br>    private Object arg;<br><br>    private ConstructorArg(Builder builder) {<br>        this.isRef = builder.isRef;<br>        this.type = builder.type;<br>        this.arg = builder.arg;<br>    }<br>    &#47;&#47; 省略getter方法<br><br>    public static class Builder {<br>        private Object arg;<br>        private Class type;<br>        private boolean isRef;<br><br>        private ConstructorArg build() {<br>            if (isRef) {<br>                if (!(arg instanceof String)) {<br>                    &#47;&#47;这里refBeanId是ConstructorArg吗？只是判断了下arg类型是否为String<br>                    throw new IllegalArgumentException(&quot;当 isRef 为 true 的时候，arg 表示 String 类型refBeanId&quot;);<br>                }<br>                if (type != null) {<br>                    throw new IllegalArgumentException(&quot;当 isRef 为 true 的时候，type 不需要设置&quot;);<br>                }<br>            }<br>            if (!isRef) {<br>                if (arg == null || type == null) {<br>                    throw new IllegalArgumentException(&quot;当 isRef 为 false 的时候，arg、type 都需要设置&quot;);<br>                }<br>            }<br>            return new ConstructorArg(this);<br>        }<br><br>        public Builder setRef(boolean ref) {<br>            isRef = ref;<br>            return this;<br>        }<br><br>        public Builder setArg(Object arg) {<br>            this.arg = arg;<br>            return this;<br>        }<br><br>        public Builder setType(Class type) {<br>            this.type = type;<br>            return this;<br>        }<br>    }<br>public static void main(String[] args) {<br>        ConstructorArg.Builder builder = new ConstructorArg.Builder();<br>&#47;&#47;        java.lang.IllegalArgumentException: 当 isRef 为 true 的时候，arg 表示 String 类型refBeanId<br>        builder.setRef(true).setArg(1).build();<br>    }","like_count":6,"discussions":[{"author":{"id":1438860,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","nickname":"子房","note":"","ucode":"CB05938C248BB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342065,"discussion_content":"校验属性的必要性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610589454,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1438860,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","nickname":"子房","note":"","ucode":"CB05938C248BB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342064,"discussion_content":"可以在 build 方法进来抽象一个对属性校验方法， checkAttributeIfNecessary() ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610589430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181148,"user_name":"何妨","can_delete":false,"product_type":"c1","uid":1385377,"ip_address":"","ucode":"EC3983BFF7992A","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","comment_is_top":false,"comment_ctime":1582506628,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27352310404","product_id":100039001,"comment_content":"建造者模式:用于已知类创建，创建构造复杂需校验参数的类<br>工厂模式:用于未知类创建，根据传入参数创建相似的类处理不同逻辑","like_count":6},{"had_liked":false,"id":179056,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1581905336,"is_pvip":false,"discussion_count":1,"race_medal":1,"score":"23056741816","product_id":100039001,"comment_content":"课后讨论题：<br><br> public class ConstructorArg {<br>    private boolean isRef;<br>    private Class type;<br>    private Object arg;<br>    &#47;&#47; TODO: 待完善...<br><br>    private ConstructorArg(Builder builder) {<br>        this.isRef = builder.isRef;<br>        this.type  = builder.type;<br>        this.arg   = builder.arg;<br>    }<br><br>    public static class Builder {<br>        private boolean isRef;<br>        private Class type;<br>        private Object arg;<br><br>        public ConstructorArg build() {<br>            if (!isRef) {<br>                if (type == null || arg == null){<br>                    throw new IllegalArgumentException(&quot;type and arg must be set when isRef is false&quot;)<br>                }<br>            } else {<br>                if (!(arg instanceof String)) {<br>                    throw new IllegalArgumentException(&quot;arg must be a String instance when isRef is true&quot;)<br>                }<br>            }<br>            return new ConstructorArg(this);<br>        }<br>    }<br><br>    public Builder setIsRef(boolean isRef){<br>        this.isRef = isRef;<br>        return this;<br>    }<br><br>    public Builder setType(Class type) {<br>        this.type = type;<br>        return this;<br>    }<br><br>    public Builder setObject(Object arg) {<br>        this.arg = arg;<br>        return this;<br>    }<br>  }<br><br>  &#47;&#47;use case<br>  ConstructorArg ca = ConstructorArg.Builder()<br>        .setIfRef(false)<br>        .setType(Integer)<br>        .setObject(2)<br>        .build();","like_count":5,"discussions":[{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":249732,"discussion_content":"稍有问题：\npackage worktest;\n\npublic class ConstructorArg {\n    private boolean isRef;\n    private Class type;\n    private Object arg;\n    // TODO: 待完善...\n\n    private ConstructorArg(Builder builder) {\n        this.isRef = builder.isRef;\n        this.type = builder.type;\n        this.arg = builder.arg;\n    }\n\n    public static class Builder {\n        private boolean isRef;\n        private Class type;\n        private Object arg;\n\n        public ConstructorArg build() {\n            if (!isRef) {\n                if (type == null || arg == null) {\n                    throw new IllegalArgumentException(&#34;type and arg must be set when isRef is false&#34;);\n                }\n            } else {\n                if (!(arg instanceof String)) {\n                    throw new IllegalArgumentException(&#34;arg must be a String instance when isRef is true&#34;);\n                }\n            }\n            return new ConstructorArg(this);\n        }\n\n        public Builder setIsRef(boolean isRef) {\n            this.isRef = isRef;\n            return this;\n        }\n\n        public Builder setType(Class type) {\n            this.type = type;\n            return this;\n        }\n\n        public Builder setObject(Object arg) {\n            this.arg = arg;\n            return this;\n        }\n    }\n\n    public static void main(String[] args) {\n        ConstructorArg ca = new ConstructorArg.Builder().setIsRef(false).setType(String.class).setObject(2).build();\n        System.out.println(ca);\n    }\n  }","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587957325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219579,"user_name":"苏暮沉觞","can_delete":false,"product_type":"c1","uid":1577580,"ip_address":"","ucode":"532B816D4EF47B","user_header":"https://static001.geekbang.org/account/avatar/00/18/12/6c/61a598e9.jpg","comment_is_top":false,"comment_ctime":1590046712,"is_pvip":false,"replies":[{"id":"86621","content":"在真实的项目里，大部分都是用我说的这种实现方式吧。你说的监工、抽象builder、具体builder的实现方式，有具体的例子吗？","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1594783425,"ip_address":"","comment_id":219579,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18769915896","product_id":100039001,"comment_content":"       小争哥，我在学习建造者模式的时候，发现传统的构建者模式写法跟文中的不太一样，传统的构建者模式存在监工，抽象Builder，具体Builder，产品类。可以通过不同的具体Builder，创建对应的产品类。而你在文章中的设计模式的写法，在某些文章中，被称为变种的构造者模式。<br>       我比较了一下两种方式，感觉传统的构建者模式需要提前定义好你要生产的产品对应的属性，而文中这种方法则是在构建产品时，自己动态的设置产品属性，虽然说这种方法更加灵活，但是侵入性更高。<br>      那么考虑到以后需求变更，是不是应该是用传统的构建者模式呢？不然要是资源池对应的参数变了，就要修改业务代码中的参数了。","like_count":4,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495859,"discussion_content":"在真实的项目里，大部分都是用我说的这种实现方式吧。你说的监工、抽象builder、具体builder的实现方式，有具体的例子吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594783425,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179028,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1581894231,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18761763415","product_id":100039001,"comment_content":"建造者模式核心代码:<br>ResourcePoolConfig config = new ResourcePoolConfig.Builder()<br>        .setName(&quot;dbconnectionpool&quot;)<br>        .setMaxTotal(16)<br>        .setMaxIdle(10)<br>        .setMinIdle(12)<br>        .build();","like_count":4,"discussions":[{"author":{"id":1640974,"avatar":"","nickname":"大风","note":"","ucode":"583873CCAA2A67","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":355006,"discussion_content":"是啊，短短的几行调用方的代码，体现出来被调用方的精良设计。高内聚低破坏性，还不缺少灵活性。算是开闭原则的经典范例了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615374806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179147,"user_name":"PHP是世界上最好的需要","can_delete":false,"product_type":"c1","uid":1655326,"ip_address":"","ucode":"EE23A54B831D17","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIma3PJUyqDEQKt40nEh3Jt840af6hKnuK8k8dIscm43EUzJwLvynbxRnvO9Ivibv7KssUSqoBdY1w/132","comment_is_top":false,"comment_ctime":1581926847,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"14466828735","product_id":100039001,"comment_content":"总感觉只是把校验逻辑挪到了bulder 里。没直观的感觉到builder 的有点呢。老师~","like_count":3,"discussions":[{"author":{"id":1395471,"avatar":"https://static001.geekbang.org/account/avatar/00/15/4b/0f/bd953c47.jpg","nickname":"韩小告","note":"","ucode":"6C601339A6F3EE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":182573,"discussion_content":"一点个人的心得体会哈。可以参考下传统的建造者模式；传统的建造者模式中有一层Director的封装，主要用来处理依赖关系、约束条件的客制化，如果有需求变更，只需要更改Director中的建造过程，或者创建新的Director派生类，能满足开闭原则，这个应该是他的优势吧。 可能说的不正确哈～ 我只是个小白。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1582436927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1395471,"avatar":"https://static001.geekbang.org/account/avatar/00/15/4b/0f/bd953c47.jpg","nickname":"韩小告","note":"","ucode":"6C601339A6F3EE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294093,"discussion_content":"我的理解是，在传统的建造者模式中。builder负责提供构建对象需要的原材料，director负责将这些材料组装成对象的过程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595777588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":182573,"ip_address":""},"score":294093,"extra":""}]},{"author":{"id":1387712,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N6yjnrLnMW4XVSkBr3f0N3F962l35b5j0kib9VSlAqqbf6iaoCPicL1WnJ9KjgT4egQ7A2G0Zx3OayaK4yuoZrUVA/132","nickname":"worthto","note":"","ucode":"41D7ABBBD2E7FF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":264596,"discussion_content":"个人看法，构造者模式方便他人，麻烦自己。其优点不在于建造者模式本身看起来多牛逼或者代码多简洁，而在于调用构造者模式的代码简洁明了，可以使用.setter().settter().settter()...builder() 这种方式。正如文档中提到的，建造者模式解决了三个问题：构造参数过多，构造参数之间存在的依赖关系，参数内部是final的情况，如果类的构建有以上三点要求，就考虑使用建造者模式。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589335952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1640974,"avatar":"","nickname":"大风","note":"","ucode":"583873CCAA2A67","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1387712,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N6yjnrLnMW4XVSkBr3f0N3F962l35b5j0kib9VSlAqqbf6iaoCPicL1WnJ9KjgT4egQ7A2G0Zx3OayaK4yuoZrUVA/132","nickname":"worthto","note":"","ucode":"41D7ABBBD2E7FF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":355004,"discussion_content":"看设计模式还有从自己和他人的解度啊？其实一定要这么看的话，它对调用方来说很方便；对被调用方来说体现出来设计的内聚性和灵活性了，谁也不想设计一个自己的业务对象被调用方随意破坏或业务模型死绑的无法配置的东西。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1615374624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":264596,"ip_address":""},"score":355004,"extra":""}]},{"author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294090,"discussion_content":"感觉老师说的建造者模式和GOF的不一样？\n老师侧重点不是构建和表示分离，也无法用同一个builder创建不同的对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595777301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1640974,"avatar":"","nickname":"大风","note":"","ucode":"583873CCAA2A67","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":354999,"discussion_content":"再结合工厂就可以创建不同对象了。这里大师只是为了最一针见血的指出单独针对建造者模式的最核心关注点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615374219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":294090,"ip_address":""},"score":354999,"extra":""}]}]},{"had_liked":false,"id":179051,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1581904391,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14466806279","product_id":100039001,"comment_content":"当在开发中需要创建一个具体的对象，如果必填属性很多，属性存在复杂的校验和属性之间存在依赖关系，可以使用建造者模式来避免类的构造函数参数列表过长，导致可读性差，不易使用的问题。建造者模式可以将类的构造方法私有，不提供类的setter方法，因此可以创建一个不变的对象。同时在某些场景下将属性构造好可以解决类的无效状态。<br>使用思路：把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者的变量值，然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。除此之外，我们把主类的构造函数为了private 私有权限，只能通过建造者来创建 类对象，并且主类没有提供任何 set() 方法，这样创建出来的对象就是不可变对象了。","like_count":3},{"had_liked":false,"id":267221,"user_name":"zaab","can_delete":false,"product_type":"c1","uid":1683063,"ip_address":"","ucode":"EE846895FF0C85","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/QYKSUV20DMgBHAPLfgngdw4N8FHRCSBLCJueVRu9Ya1Ba2x4icx70zoVVFOZtG1K6TkHj5CFbuztQhRFyCjWXHQ/132","comment_is_top":false,"comment_ctime":1607653001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10197587593","product_id":100039001,"comment_content":"写得真好，之前看了几次不知道建造者模式的作用，不知道为啥看了一下这篇我就理解了。。","like_count":2},{"had_liked":false,"id":200994,"user_name":"Riley","can_delete":false,"product_type":"c1","uid":1106990,"ip_address":"","ucode":"73470984DBB8E0","user_header":"https://static001.geekbang.org/account/avatar/00/10/e4/2e/899a8fa2.jpg","comment_is_top":false,"comment_ctime":1585703691,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10175638283","product_id":100039001,"comment_content":"1、请问lombox中@builder思想是不是来自建造者模式的思想？<br>2、 还有网上很多人不建议用lombox插件，请问你对此有何建议？","like_count":2,"discussions":[{"author":{"id":1541669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/86/25/25ded6c3.jpg","nickname":"zhengyu.nie","note":"","ucode":"FFE0377D323E46","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":251216,"discussion_content":"1.lombok的builder注解，生成的就是builder内部类，跟文中的builder就是同一个东西。\n2.建议不使用lombok的原因有几点：\n·依赖idea插件\n·破坏封装性\n·jdk升级可能会有兼容问题\n·@Data之类的话会有多余代码生成\n·有些注解生成的内容不确定可能会有坑\n\n基于以上几点，你想清楚都能cover住，或者没那么严格的要求，或者出了问题你很快能改能定位，那你就随便用，这个东西很灵活的，不必纠结，它的本质是利用JSR 269注解处理机制编译期间生成代码，也有很多同类型的三方库，比如Selma、MapStruct。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1588074121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179025,"user_name":"LJK","can_delete":false,"product_type":"c1","uid":1199213,"ip_address":"","ucode":"12B2441099FF1D","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/6d/c20f2d5a.jpg","comment_is_top":false,"comment_ctime":1581879694,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"10171814286","product_id":100039001,"comment_content":"感觉课后思考题的arguments逻辑判断相对复杂，再加上想尝试一下建造者模式，所以抛砖引玉，给一个Python的尝试，有一个困惑是对于Python这种语言，如何避免对用户暴露在调用builder之前build方法之前初始化的ConstructorArg对象？<br><br>class ConstructorArg(object):<br>    def __init__(self, isRef):  #如何避免暴露这个实例对象？<br>        self.isRef = isRef<br>        self.type = None<br>        self.arg = None<br>    <br>    def __repr__(self):<br>        string = f&quot;isRef:  {self.isRef}\\n&quot; + \\<br>                 f&quot;type:   {self.type}\\n&quot; + \\<br>                 f&quot;arg:    {self.arg}\\n&quot;<br>        return string<br><br>    class ConstructorArgBuilder(object):<br>        def __init__(self, isRef):<br>            self.constructorArg = ConstructorArg(isRef)<br><br>        def addType(self, typeObj):<br>            self.constructorArg.type = typeObj<br>            return self<br><br>        def addArg(self, argObj):<br>            self.constructorArg.arg = argObj<br>            return self<br><br>        def build(self):<br>            if self.constructorArg.isRef:<br>                if self.constructorArg.type is None:<br>                    raise Exception(&quot;type cannot be None when isRef&quot;)<br>                elif not isinstance(self.constructorArg.type, str):<br>                    raise Exception(&quot;type must be string when isRef&quot;)<br>            elif not self.constructorArg.isRef:<br>                if self.constructorArg.type is None:<br>                    raise Exception(&quot;type cannot be None when not isRef&quot;)<br>                if self.constructorArg.arg is None:<br>                    raise Exception(&quot;arg cannot be None when not isRef&quot;)<br>            return self.constructorArg","like_count":2,"discussions":[{"author":{"id":1437581,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ5lDDMYy9zfaWXJiayKVlwXpCrTKJM9cl2MrVSM4PcUDstIOb6SVQDwlialwFIuvHXibxE0lLFFicgsQ/132","nickname":"heima","note":"","ucode":"8E6138EFE8499B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587860,"discussion_content":"简单的实现：\n\nclass ConstructorArg:\n    def __init__(self, is_ref, arg, type_=None):\n        if is_ref:\n            if not isinstance(arg, str):\n                raise Exception(&#39;arg type must be str when is_ref is True&#39;)\n        else:\n            if type_ is None or arg is None:\n                raise Exception(&#39;arg and type_ value must not be None when is_ref is False&#39;)\n\n        self.__is_ref = is_ref\n        self.__type = type_\n        self.__arg = arg\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1663323584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1437581,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ5lDDMYy9zfaWXJiayKVlwXpCrTKJM9cl2MrVSM4PcUDstIOb6SVQDwlialwFIuvHXibxE0lLFFicgsQ/132","nickname":"heima","note":"","ucode":"8E6138EFE8499B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587858,"discussion_content":"个人认为，对于Python来说绝大多数情况是不需要builder模式的。\nPython支持传入参数名 和 默认值的支持，一定程度上就解决了builder模式要解决的问题，这大概也是为什么几乎在Python中看不到builder模式的使用。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1663323457,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1266043,"avatar":"https://static001.geekbang.org/account/avatar/00/13/51/7b/191a2112.jpg","nickname":"愤怒的虾干","note":"","ucode":"CEBD1B2BE7BCEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283619,"discussion_content":"class ConstructorArg(object):\n\n    class ConstructorArgBuilder(object):\n\n        def addIsRef(self, isRef):\n            self.isRef = isRef\n            return self\n\n        def addType(self, typeObj):\n            self.type = typeObj\n            return self\n\n        def addArg(self, argObj):\n            self.arg = argObj\n            return self\n\n        def build(self):\n            if self.isRef:\n                if self.type is None:\n                    raise Exception(&#34;type cannot be None when isRef&#34;)\n                elif not isinstance(self.type, str):\n                    raise Exception(&#34;type must be string when isRef&#34;)\n            elif not self.isRef:\n                if self.type is None:\n                    raise Exception(&#34;type cannot be None when not isRef&#34;)\n                if self.arg is None:\n                    raise Exception(&#34;arg cannot be None when not isRef&#34;)\n            return ConstructorArg(self)\n\n    builder = ConstructorArgBuilder()\n\n    def __init__(self, bulder: ConstructorArgBuilder):  # 如何避免暴露这个实例对象？\n        self.isRef = bulder.isRef\n        self.type = bulder.type\n        self.arg = bulder.arg\n\n    def __repr__(self):\n        string = f&#34;isRef: {self.isRef}\\n&#34; + \\\n                 f&#34;type: {self.type}\\n&#34; + \\\n                 f&#34;arg: {self.arg}\\n&#34;\n        return string\n\n重构了下，感觉这样比较好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592312386,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321548,"user_name":"Geek_00e01b","can_delete":false,"product_type":"c1","uid":1597071,"ip_address":"","ucode":"BC76A83B53D0EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLe9iavda8ia7vNkbMVEHsCKs43l6U6HGWibiaxxKd9PuiaYu5wRedicC96PLicZ9VIh0ic5Jg8YHPrta3IAQ/132","comment_is_top":false,"comment_ctime":1636944112,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5931911408","product_id":100039001,"comment_content":"对于没有内部类机制的编程语言，就没那么友好了。需要单独为需要创建对象的类创建一个builder类。而且，也是因为单独创建了一个类，所以需要创建对象的类的构造函数没办法变为private","like_count":1},{"had_liked":false,"id":320540,"user_name":"charmsongo","can_delete":false,"product_type":"c1","uid":1609051,"ip_address":"","ucode":"4FBEE716E93A1A","user_header":"https://static001.geekbang.org/account/avatar/00/18/8d/5b/383a49e4.jpg","comment_is_top":false,"comment_ctime":1636373016,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5931340312","product_id":100039001,"comment_content":"总结<br>1、为什么需要建造者模式？<br>\t成员变量过多，变量赋值逻辑判断复杂，就需要考虑使用建造者模式，先设置建造者的变量，然后再一次性地创建对象<br>\t避免对象存在无效状态<br>\t缺点是，会有重复代码，成员变量，要在 Builder 类中重新再定义一遍。<br>2、与工厂模式有何区别？<br>\t工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。<br>\t建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。<br>\t简单理解就是：工厂模式是根据不同的条件生成不同Class的对象，构建者模式是根据不同参数生成一个class的不同对象。","like_count":1},{"had_liked":false,"id":296867,"user_name":"小江爱学术","can_delete":false,"product_type":"c1","uid":2628601,"ip_address":"","ucode":"554F40C6627AF4","user_header":"https://static001.geekbang.org/account/avatar/00/28/1b/f9/018197f1.jpg","comment_is_top":false,"comment_ctime":1623206851,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5918174147","product_id":100039001,"comment_content":"&#47;**<br> * 构造者模式demo: ConstructorArg<br> *&#47;<br>public class ConstructorArg {<br>    private boolean isRef;<br>    private Class type;<br>    private Object arg;<br><br>    private ConstructorArg(boolean isRef, Class type, Object arg) {<br>        this.isRef = isRef;<br>        this.type = type;<br>        this.arg = arg;<br>    }<br><br>    public static class Builder {<br>        private boolean isRef;<br>        private Class type;<br>        private Object arg;<br><br>        public ConstructorArg build() throws Exception {<br>            if (isValidParams()) {<br>                return new ConstructorArg(isRef, type, arg);<br>            }<br>            throw new Exception(&quot;params invalid&quot;);<br>        }<br><br>        public Builder setIsRef(boolean isRef) {<br>            this.isRef = isRef;<br>            return this;<br>        }<br><br>        public Builder setType(Class type) {<br>            this.type = type;<br>            return this;<br>        }<br><br>        public Builder setObject(Object arg) {<br>            this.arg = arg;<br>            return this;<br>        }<br><br>        private boolean isValidParams() {<br>            if (isRef &amp;&amp; arg instanceof String) {<br>                return true;<br>            }<br>            if (!isRef &amp;&amp; arg != null &amp;&amp; type != null) {<br>                return true;<br>            }<br>            return false;<br>        }<br>    }<br>}","like_count":1},{"had_liked":false,"id":273438,"user_name":"子房","can_delete":false,"product_type":"c1","uid":1438860,"ip_address":"","ucode":"CB05938C248BB3","user_header":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","comment_is_top":false,"comment_ctime":1610595518,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5905562814","product_id":100039001,"comment_content":"多回头看， 发现以前写的代码，学完后可以设计的更好","like_count":1},{"had_liked":false,"id":268218,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1608103605,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5903070901","product_id":100039001,"comment_content":"之前说的工厂模式，是通过工厂来创建多种相关的对象。而建造者模式，是通过建造者来创建单个复杂参数和依赖的对象。<br>看起来设计模式也符合单一功能原则嘛。每一个模式解决一个清晰的问题，也怪不得有那么多个设计模式。如果说设计原则与思想是“道”，那设计模式就是应用在具体问题上的“术”。<br>了解设计模式的作用，重要的是能认识它解决的问题，编码过程中预见自己可能遇到的问题，让自己不至于多做无用功。","like_count":1},{"had_liked":false,"id":254598,"user_name":"小学生","can_delete":false,"product_type":"c1","uid":1063291,"ip_address":"","ucode":"2DE2E6555C9A5F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKhABWsNOGReVBNqwYCn52ibbaog3AWU6lPRARibCkibhlNf885vaQPQ8n37ic4wFr7HMBw2wRLcpYkcw/132","comment_is_top":false,"comment_ctime":1603155186,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5898122482","product_id":100039001,"comment_content":"参数搞成一个类，传入构造函数是否也可以解决参数过长+校验的问题？","like_count":1},{"had_liked":false,"id":243456,"user_name":"写代码的","can_delete":false,"product_type":"c1","uid":2085090,"ip_address":"","ucode":"F58186409A3D65","user_header":"https://static001.geekbang.org/account/avatar/00/1f/d0/e2/1d00c079.jpg","comment_is_top":false,"comment_ctime":1598119596,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5893086892","product_id":100039001,"comment_content":"参数多的时候、参数有可选和必选之分的时候适合使用建造者模式。我觉得必填的参数可以作为 Builder 的构造函数传入，这样一眼就看出这是必填项；而可选的参数通过 Builder 类的 set 方法传进去。单个参数的校验放在 set 方法里做；多个参数之间约束关系的校验放在 build 方法里去做。","like_count":1,"discussions":[{"author":{"id":1252813,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1d/cd/3819726f.jpg","nickname":"徐同学呀","note":"","ucode":"03383EE820514D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383540,"discussion_content":"good","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626152193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238266,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/d017438c.jpg","comment_is_top":false,"comment_ctime":1596106246,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"5891073542","product_id":100039001,"comment_content":"工厂模式和建造者模式字面上也好理解和区别，工厂生产的肯定是产成品，建造者模式是在产品，是可以定制的。在使用场景上可以简单按照参数的复杂性来判断，当参数个数大于5且创建的对象比较复杂建议使用工厂模式，如果参数大于5个但是对象比较简单使用建造者模式。","like_count":1,"discussions":[{"author":{"id":1252813,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1d/cd/3819726f.jpg","nickname":"徐同学呀","note":"","ucode":"03383EE820514D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383544,"discussion_content":"你后面的说法不仅反了  还有问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626152436,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235459,"user_name":"天天向上卡索","can_delete":false,"product_type":"c1","uid":1009850,"ip_address":"","ucode":"E3724C3B39BD3F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/68/ba/c0cf8bf3.jpg","comment_is_top":false,"comment_ctime":1595044633,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5890011929","product_id":100039001,"comment_content":"在 .net core 大量使用了 builder 模式代码","like_count":1},{"had_liked":false,"id":230159,"user_name":"somenzz","can_delete":false,"product_type":"c1","uid":1187197,"ip_address":"","ucode":"EA59A170DF8910","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/7d/368df396.jpg","comment_is_top":false,"comment_ctime":1593297009,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5888264305","product_id":100039001,"comment_content":"学习了，没看到这个之前，觉得构造函数参数多了以后，再加上校验，很容易出现 bug，维护起来真的麻烦，这节课非常受益。","like_count":1},{"had_liked":false,"id":228717,"user_name":"悠南","can_delete":false,"product_type":"c1","uid":1193711,"ip_address":"","ucode":"333665DB7CFDD6","user_header":"https://static001.geekbang.org/account/avatar/00/12/36/ef/83c2a743.jpg","comment_is_top":false,"comment_ctime":1592793957,"is_pvip":false,"replies":[{"id":"86620","content":"内部类可以直接调用外部类的成员和方法，包括private的吧","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1594783194,"ip_address":"","comment_id":228717,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5887761253","product_id":100039001,"comment_content":"你这建造者模式代码，看不懂，构造方法私有了，怎么来的Builder 方法","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499161,"discussion_content":"内部类可以直接调用外部类的成员和方法，包括private的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594783194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289713,"discussion_content":"你JAVA基础不过关啊，外部类构造方法私有但内部类是公有的，内部类的构造方法可以调用外部类的私有构造方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594188222,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225618,"user_name":"Shanks-王冲","can_delete":false,"product_type":"c1","uid":1042983,"ip_address":"","ucode":"C4B90A17850E20","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ea/27/a3737d61.jpg","comment_is_top":false,"comment_ctime":1591800694,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5886767990","product_id":100039001,"comment_content":"有if判断初始化，我就想到了钩子hook","like_count":1},{"had_liked":false,"id":192520,"user_name":"嘻哈","can_delete":false,"product_type":"c1","uid":1402535,"ip_address":"","ucode":"AEE1512822A399","user_header":"https://static001.geekbang.org/account/avatar/00/15/66/a7/5b7a7523.jpg","comment_is_top":false,"comment_ctime":1584857000,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879824296","product_id":100039001,"comment_content":"求指正！<br>public class ConstructorArg {<br>    private boolean isRef;<br>    private Class type;<br>    private Object arg;<br><br>    private ConstructorArg(boolean isRef, Class type, Object arg) {<br>        this.isRef = isRef;<br>        this.type = type;<br>        this.arg = arg;<br>    }<br>    public static class ConstructorArgBuilder {<br>        private boolean isRef;<br>        private Class type;<br>        private Object arg;<br><br>        public ConstructorArgBuilder isRef(boolean isRef) {<br>            this.isRef = isRef;<br>            return this;<br>        }<br><br>        public ConstructorArgBuilder type(Class type) {<br>            this.type = type;<br>            return this;<br>        }<br><br>        public ConstructorArgBuilder arg(Object arg) {<br>            this.arg = arg;<br>            return this;<br>        }<br><br>        public ConstructorArg builder() {<br>            if (isRef) {<br>                type = String.class;<br>            } else if (type == null) {<br>                throw new IllegalArgumentException(&quot;...&quot;);<br>            }<br>            if (arg == null || type != arg.getClass()) {<br>                throw new IllegalArgumentException(&quot;...&quot;);<br>            }<br>            return new ConstructorArg(isRef, type, arg);<br>        }<br>    }<br>}","like_count":1},{"had_liked":false,"id":189848,"user_name":"不学不行啊","can_delete":false,"product_type":"c1","uid":1335474,"ip_address":"","ucode":"69368165141C2D","user_header":"https://static001.geekbang.org/account/avatar/00/14/60/b2/ccebcb71.jpg","comment_is_top":false,"comment_ctime":1584576997,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879544293","product_id":100039001,"comment_content":"GOOd","like_count":1},{"had_liked":false,"id":189449,"user_name":"空白昵称","can_delete":false,"product_type":"c1","uid":1433815,"ip_address":"","ucode":"91F50CA25102AB","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/d7/744bd8c3.jpg","comment_is_top":false,"comment_ctime":1584517363,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879484659","product_id":100039001,"comment_content":"以上老师举的餐厅的例子很形象👍，另外都是一些汉堡、披散，奶酪... 是不是经常在国外？😹🤪","like_count":1},{"had_liked":false,"id":182221,"user_name":"不谈","can_delete":false,"product_type":"c1","uid":1156936,"ip_address":"","ucode":"2E18977EAC5E5E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTItaas8rpvXb70zfjMetkEuYeLH0rI348MCaKqyn9HAbGZsdCKibLTnfGEBMbwQLBOhPMROcVBk9vA/132","comment_is_top":false,"comment_ctime":1582730327,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5877697623","product_id":100039001,"comment_content":"终于理解什么时候需要使用建造者模式了！！！泪奔。。。感谢老师","like_count":1},{"had_liked":false,"id":180936,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1582446755,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5877414051","product_id":100039001,"comment_content":"设计模式_46:<br># 作业<br>```<br>    public void build () {<br>        if (isRef &amp;&amp; arg == null) throw new IllegalArgumentException(&quot;...&quot;);<br>        <br>        if (isRef &amp;&amp; !arg instanceof String) throw new IllegalArgumentException(&quot;...&quot;);<br>        <br>        if (!isRef &amp;&amp; arg == null) throw new IllegalArgumentException(&quot;...&quot;);<br>        <br>        if (!isRef &amp;&amp; type == null) throw new IllegalArgumentException(&quot;...&quot;);<br>        <br>        if (!isRef &amp;&amp; !arg instanceof type) throw new IllegalArgumentException(&quot;...&quot;);<br>        &#47;&#47;...<br>    }<br>```<br><br># 感想<br>一直不是很清楚哪种场景必须用*Builder*模式，常常感觉用不用都可以。今天的总结的四个因素非常认同(请原谅我复读机了)：<br>\t- 必须的参数太多，构造函数太长<br>\t- 成员之间有依赖关系，需要一个地方来检测(也就是*build()*方法内)<br>\t- 想实现final效果<br>\t- 避免对象的无效状态","like_count":1},{"had_liked":false,"id":179682,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1582078166,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5877045462","product_id":100039001,"comment_content":"在Netty中的ServerBootstrap也是通过建造者模式设置参数的，我在项目中也会使用建造者模式设置参数。","like_count":1,"discussions":[{"author":{"id":1322366,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2d/7e/335a9b9d.jpg","nickname":"🐝null","note":"","ucode":"16F5E4965F8D5D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":313214,"discussion_content":"我觉得接口和抽象类都可以解决复用和抽象的问题。谁说抽象问题就要用接口不能用抽象类呢，复用问题就要用抽象类不能用接口呢？\n文中也说了很多语言没有接口的概念，JAVA也可以用抽象类来模拟接口。 把抽象类理解成接口也没有毛病。\n两者的区别关键在于抽象类表示的is-a关系，例如FileInputStearm和PipleInputStearm都是InputStearm。\n而接口表示的是has-a，也就是具有某种能力，例如Compareable接口表示可排序，Serializable接口表示可序列化。\n为什么接口可以实现多个，而抽象类不行？我认为接口has-a表示的是具有某种能力或功能，是更细粒度的。比如某个抽象类同时实现Compareable和Serializable表示这个类同时具有两种能力。","likes_number":19,"is_delete":false,"is_hidden":false,"ctime":1603003392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1691500,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cf/6c/87faa554.jpg","nickname":"MoeRookie","note":"","ucode":"E860D73EE91F00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1322366,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2d/7e/335a9b9d.jpg","nickname":"🐝null","note":"","ucode":"16F5E4965F8D5D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":322842,"discussion_content":"流弊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604828644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":313214,"ip_address":""},"score":322842,"extra":""},{"author":{"id":1211244,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7b/6c/4b814030.jpg","nickname":"秋叶","note":"","ucode":"09E44247A0962B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1322366,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2d/7e/335a9b9d.jpg","nickname":"🐝null","note":"","ucode":"16F5E4965F8D5D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350860,"discussion_content":"就好像技能可以有很多种，但爸爸只能有一个(๑˃̵ᴗ˂̵)","likes_number":15,"is_delete":false,"is_hidden":false,"ctime":1614053109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":313214,"ip_address":""},"score":350860,"extra":""},{"author":{"id":2475056,"avatar":"https://static001.geekbang.org/account/avatar/00/25/c4/30/711b03e5.jpg","nickname":"Geek_Candice","note":"","ucode":"0F2CBCF624F905","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1211244,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7b/6c/4b814030.jpg","nickname":"秋叶","note":"","ucode":"09E44247A0962B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405655,"discussion_content":"妙啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634613172,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":350860,"ip_address":""},"score":405655,"extra":""}]},{"author":{"id":1912872,"avatar":"","nickname":"雨做的云","note":"","ucode":"93C3EB71B79B70","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":230819,"discussion_content":"你说的对，作者的的文章是基于JDK1.8之前的版本，default是1.8以后才有的，另外静态方法、接口嵌套、枚举都没错，是允许的；实现类只需要实现接口所有的抽象方法，而非所有的方法，因为default方法是不需要强制实现的","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1586774972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2043699,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/2f/33/e4c24b31.jpg","nickname":"第三人称","note":"","ucode":"5A8245FF04CA63","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329005,"discussion_content":"接口可以实例化","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1606296572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1200660,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/14/cb118a61.jpg","nickname":"键舞飞扬","note":"","ucode":"4EC7A8D2E7AC78","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342062,"discussion_content":"C#接口可以包含属性","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610589269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1811277,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a3/4d/59390ba9.jpg","nickname":"排骨","note":"","ucode":"A413CF46211E1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1200660,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/14/cb118a61.jpg","nickname":"键舞飞扬","note":"","ucode":"4EC7A8D2E7AC78","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586883,"discussion_content":"c#的属性实则方法吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662554095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":342062,"ip_address":"中国香港"},"score":586883,"extra":""}]},{"author":{"id":1145502,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJdUGdEj3R25CrYqibPibYibibRicqUfyL4aTTPbMagyywjKMhXGZE37RTe7lEdvC4DibvtYpzg8zXvt9HQ/132","nickname":"Fun","note":"","ucode":"5D89BA4C678785","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55338,"discussion_content":"# day 10\n继续学习抽象类和接口的概念。放到C语言的话，抽象类和结构体都只能通过函数指针来实现，多态的话就指针强转吧。初步的直接理解，晚点下班再重新学习一遍。先打卡占座。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574350372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53821,"discussion_content":"接口里所有的方法都在public的吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574221915,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53829,"discussion_content":"是的，可以不用写public，默认就是public","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574222883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53821,"ip_address":""},"score":53829,"extra":""},{"author":{"id":1359518,"avatar":"https://static001.geekbang.org/account/avatar/00/14/be/9e/3a542996.jpg","nickname":"liuxing5","note":"","ucode":"C2ED58AF619585","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":304939,"discussion_content":"默认是default，包内可以访问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599718274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53829,"ip_address":""},"score":304939,"extra":""},{"author":{"id":1598067,"avatar":"https://static001.geekbang.org/account/avatar/00/18/62/73/3a0caacc.jpg","nickname":"倔强知足","note":"","ucode":"4178E2AC4DA964","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1359518,"avatar":"https://static001.geekbang.org/account/avatar/00/14/be/9e/3a542996.jpg","nickname":"liuxing5","note":"","ucode":"C2ED58AF619585","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":317755,"discussion_content":"是public,接口中的默认和普通类中的默认不一样","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603597445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":304939,"ip_address":""},"score":317755,"extra":""}]},{"author":{"id":1237399,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e1/97/fec494f2.jpg","nickname":"大大。","note":"","ucode":"A6716E46264AC4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53718,"discussion_content":"我有一个问题哈，inputstream和socket都有close方法，就算没有closeable接口，他们两个类都实现close方法，这样影响什么呢？或者说你抽出来一个close方法有什么意义？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574211737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1161200,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b7/f0/a570f68a.jpg","nickname":"wang","note":"","ucode":"5D569805C6A923","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1237399,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e1/97/fec494f2.jpg","nickname":"大大。","note":"","ucode":"A6716E46264AC4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53770,"discussion_content":"接口是规范，就是强制你必须实现close方法，还有基于接口编程的好处就是， jdk7的 try-with-resource ","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1574214650,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53718,"ip_address":""},"score":53770,"extra":""},{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1237399,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e1/97/fec494f2.jpg","nickname":"大大。","note":"","ucode":"A6716E46264AC4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53789,"discussion_content":"首先，谢谢你提的问题！我的回答也可能不准确，希望大家多多补充。\n第一、close一般要做释放资源之类的工作。自己实现一个类如链接、读写、操作流，自己实现close方法时，可能会忘了写这个方法，进而没有释放资源。\n第二、java中closeable接口继承于java1.7之后的autocolseable接口。支持try-with-resource语法。如果我们自己实现这个方法的话，就会不支持这种语法。需要手动的做关闭释放资源？那么岂不是要写更多的代码？\n第三、历史原因：java中closeable接口是一个旧的接口，如果我们要实现一个close功能建议实现autocolseable接口，它抛出的是Exception异常，比closeable接口抛出的IOException更宽泛。\n第四、抽象层面：什么行为定义成接口中的方法，或者抽象类中的方法这个涉及到对面向对象的理解，人和人可能不一样。这个方面我没有什么设计经验，希望各位补充。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1574216456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53718,"ip_address":""},"score":53789,"extra":""},{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1161200,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b7/f0/a570f68a.jpg","nickname":"wang","note":"","ucode":"5D569805C6A923","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53791,"discussion_content":"谢谢补充！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574216538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53770,"ip_address":""},"score":53791,"extra":""}]},{"author":{"id":1042114,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLu7SYgsvC9IY5AicAlCtoMGj7znhgo6IZu51XTFxPasFrJr3WPPqusBBicC0rJ3U2la6JRd3qWse1w/132","nickname":"dragon","note":"","ucode":"FC8AB417A9E110","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576644,"discussion_content":"优秀的课代表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655721733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2699218,"avatar":"","nickname":"Geek_279849","note":"","ucode":"FC6A3514FC955C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552813,"discussion_content":"嵌套的接口啥时候会实现呢？jdk有具体例子吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645602765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2029129,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f6/49/e4284e3c.jpg","nickname":"马鹏威","note":"","ucode":"802589E800C098","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290317,"discussion_content":"课代表，总结的好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594424501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1327497,"avatar":"https://static001.geekbang.org/account/avatar/00/14/41/89/77d3e613.jpg","nickname":"bookchan","note":"","ucode":"6C40EEAC767E25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221539,"discussion_content":"作者说：接口不能包含属性（也就是成员变量）。\n接口只能声明方法，方法不能包含代码实现。\n类实现接口的时候，必须实现接口中声明的所有方法。  你说的是必须抽象方法，这里有出入吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586013236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2028943,"avatar":"","nickname":"Geek9625","note":"","ucode":"8110B0DE0432E1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1327497,"avatar":"https://static001.geekbang.org/account/avatar/00/14/41/89/77d3e613.jpg","nickname":"bookchan","note":"","ucode":"6C40EEAC767E25","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299478,"discussion_content":"这个我查过文档，我理解所有未被实现的方法都是可以叫做抽象方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597714854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":221539,"ip_address":""},"score":299478,"extra":""}]},{"author":{"id":1476696,"avatar":"https://static001.geekbang.org/account/avatar/00/16/88/58/3e19586a.jpg","nickname":"晓双","note":"","ucode":"59CA9DB77697D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209808,"discussion_content":"这种嵌套定义有什么含义？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584674583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1759533,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d9/2d/8d6c496c.jpg","nickname":"哈蜜瓜","note":"","ucode":"80D12AA70A9DCC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64149,"discussion_content":"考虑换岗么😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574939281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1759533,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d9/2d/8d6c496c.jpg","nickname":"哈蜜瓜","note":"","ucode":"80D12AA70A9DCC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64257,"discussion_content":"我现在是研三的学生，找工作ing","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1574943440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":64149,"ip_address":""},"score":64257,"extra":""}]},{"author":{"id":1237399,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e1/97/fec494f2.jpg","nickname":"大大。","note":"","ucode":"A6716E46264AC4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53721,"discussion_content":"就算不实现closeable接口，两个类自己实现close方法，又有什么弊端？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574211804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1441908,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIA11wHDEjzm6TypVhPnp4QJRX65a5JRibYFG2NSicvEFZzZ9hUKMic7zsLcZIKbU4Rwk9viciaLibuAQrQ/132","nickname":"liujianyu","note":"","ucode":"F65D5C09B9F583","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1237399,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e1/97/fec494f2.jpg","nickname":"大大。","note":"","ucode":"A6716E46264AC4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56534,"discussion_content":"如果自己实现在需要使用close方法的地方就会耦合到具体的实现上，通过接口定义的话就可以使用多态的特性，不会耦合到具体的实现上，扩展性更强","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1574495543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53721,"ip_address":""},"score":56534,"extra":""},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1237399,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e1/97/fec494f2.jpg","nickname":"大大。","note":"","ucode":"A6716E46264AC4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85432,"discussion_content":"实现closeable接口是显示标明子类可以被close，好处有：1. 配合里式替换原则，可以写出低耦合实现的代码 2.可以轻易筛选出所有支持被close的类，DI时非常有用 3.通过closeable接口就可得知被close时的行为准则是什么，这里是close方法，而且实现类强制要实现，避免了遗漏 4. 消除二义性，比如两个子类都要实现close方法，但方法签名是什么？返回类型是什么？有了接口，访问限定符、返回值、方法名、参数列表都已经定死了，不能篡改，这样就没有了二义性","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1576546274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53721,"ip_address":""},"score":85432,"extra":""}]}]},{"had_liked":false,"id":179563,"user_name":"Joker","can_delete":false,"product_type":"c1","uid":1156592,"ip_address":"","ucode":"126AF848001A1E","user_header":"https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg","comment_is_top":false,"comment_ctime":1582032063,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5876999359","product_id":100039001,"comment_content":"工厂模式是饭店点菜，得到的成品，而构造者模式是吃自助火锅，要吃什么，吃多少，都要自己决定。","like_count":1},{"had_liked":false,"id":179496,"user_name":"岁月神偷","can_delete":false,"product_type":"c1","uid":1484111,"ip_address":"","ucode":"BA851259EA1F71","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/4f/592d00f2.jpg","comment_is_top":false,"comment_ctime":1582016192,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5876983488","product_id":100039001,"comment_content":"争哥，我真的急死了要，你写的特别好，每次看完都有种醍醐灌顶的感觉，追你的文章比追剧还爽，真希望现在就能看到后面所有的文章，哈哈哈","like_count":1,"discussions":[{"author":{"id":1196864,"avatar":"https://static001.geekbang.org/account/avatar/00/12/43/40/e7ef18de.jpg","nickname":"嘉一","note":"","ucode":"8D16BD0B75B019","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":231879,"discussion_content":"这马屁拍的好啊，哈哈哈","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1586835605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179370,"user_name":"君哥聊技术","can_delete":false,"product_type":"c1","uid":1325816,"ip_address":"","ucode":"2C9A22BCE4C79E","user_header":"https://static001.geekbang.org/account/avatar/00/14/3a/f8/c1a939e7.jpg","comment_is_top":false,"comment_ctime":1581991807,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5876959103","product_id":100039001,"comment_content":"课后思考题<br>public class ConstructorArg {<br><br>    private boolean isRef;<br>    private Class type;<br>    private Object arg;<br><br>    private ConstructorArg(Builder builder){<br>        this.isRef = builder.isRef;<br>        this.type = builder.type;<br>        this.arg = builder.arg;<br>    }<br><br>    public static class Builder{<br><br>        private boolean isRef;<br>        private Class type;<br>        private Object arg;<br><br>        public Builder(boolean isRef){<br>            this.isRef = isRef;<br>        }<br><br>        public ConstructorArg build(){<br>            return new ConstructorArg(this);<br>        }<br><br>        public Builder setType(Class type) {<br>            if (!isRef &amp;&amp; null == type){<br>                throw new IllegalArgumentException(&quot;type must be not null&quot;);<br>            }<br>            this.type = type;<br>            return this;<br>        }<br><br>        public Builder setArg(Object arg) {<br>            if (isRef &amp;&amp; !(arg instanceof String)){<br>                throw new IllegalArgumentException(&quot;arg must be type of String&quot;);<br>            }<br><br>            if (!isRef &amp;&amp; null == arg){<br>                throw new IllegalArgumentException(&quot;arg must be not null&quot;);<br>            }<br>            this.arg = arg;<br>            return this;<br>        }<br>    }<br><br>    public static void main(String args[]){<br>        ConstructorArg constructorArg = new ConstructorArg.Builder(true).setArg(&quot;123&quot;).build();<br>    }<br>}","like_count":1},{"had_liked":false,"id":179082,"user_name":"Algo","can_delete":false,"product_type":"c1","uid":1119682,"ip_address":"","ucode":"D7B6D147F793E8","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/c2/cd8052c8.jpg","comment_is_top":false,"comment_ctime":1581910482,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5876877778","product_id":100039001,"comment_content":"package com.acacia.leetcode.huahua.questions;<br><br>public class ConstructorArg {<br>    private boolean isRef;<br>    private Class type;<br>    private Object arg;<br><br>    private ConstructorArg(Builder builder){<br>        this.isRef = builder.isRef;<br>        this.type = builder.type;<br>        this.arg = builder.arg;<br>    }<br><br>    public static class Builder{<br>        private final static Class TYPE_STRING = String.class;<br>        private final static Object ARG_STRING = &quot;String&quot;;<br><br>        private boolean isRef;<br>        private Class type;<br>        private Object arg;<br><br>        public ConstructorArg build(){<br>            if (isRef == true){<br>                this.type = TYPE_STRING;<br>                this.arg = ARG_STRING;<br>                return new ConstructorArg(this);<br>            }else {<br>                return new ConstructorArg(this);<br>            }<br>        }<br><br>        public Builder setRef(boolean ref) {<br>            this.isRef = ref;<br>            return this;<br>        }<br><br>        public Builder setType(Class type) {<br>&#47;&#47;            if (!type.isMemberClass()){<br>&#47;&#47;                throw new IllegalArgumentException(&quot;failed class name&quot;);<br>&#47;&#47;            }<br>            this.type = type;<br>            return this;<br>        }<br><br>        public Builder setArg(Object arg) {<br>            if (arg == null){<br>                throw new IllegalArgumentException(&quot;can not be null&quot;);<br>            }<br>            this.arg = arg;<br>            return this;<br>        }<br>    }<br><br>    public static void main(String[] args) {<br>        ConstructorArg arg = new ConstructorArg.Builder().setRef(true).build();<br>        System.out.println(arg.type);<br>        System.out.println(arg.arg);<br>        ConstructorArg arg1 = new ConstructorArg.Builder().setArg(false).setType(Integer.class).setArg(2).build();<br>        System.out.println(arg1.type);<br>        System.out.println(arg1.arg);<br>    }<br>}<br><br><br><br>","like_count":1},{"had_liked":false,"id":179070,"user_name":"cricket1981","can_delete":false,"product_type":"c1","uid":1001715,"ip_address":"","ucode":"758262F5958DA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/f3/f1034ffd.jpg","comment_is_top":false,"comment_ctime":1581907521,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5876874817","product_id":100039001,"comment_content":"public class ConstructorArg {<br><br>    private boolean isRef;<br>    private Class type;<br>    private Object arg;<br><br>    private ConstructorArg(Builder builder) {<br>        this.isRef = builder.isRef;<br>        this.type = builder.type;<br>        this.arg = builder.arg;<br>    }<br><br>    public boolean getIsRef() {<br>        return isRef;<br>    }<br><br>    public Class getType() {<br>        return type;<br>    }<br><br>    public Object getArg() {<br>        return arg;<br>    }<br><br>    public static class Builder {<br><br>        private boolean isRef;<br>        private Class type;<br>        private Object arg;<br><br>        public ConstructorArg build() {<br>            if (arg == null) {<br>                throw new IllegalArgumentException(&quot;The value of parameter `arg` should be provided.&quot;);<br>            }<br>            if (!this.isRef &amp;&amp; type == null) {<br>                throw new IllegalArgumentException(&quot;The value of parameter `type` should be provided if `isRef` == false.&quot;);<br>            }<br>            return new ConstructorArg(this);<br>        }<br><br>        public Builder setRef(boolean isRef) {<br>            this.isRef = isRef;<br>            return this;<br>        }<br><br>        public Builder setType(Class type) {<br>            this.type = type;<br>            return this;<br>        }<br><br>        public Builder setArg(Object arg) {<br>            this.arg = arg;<br>            return this;<br>        }<br>    }<br><br>}<br><br>用法：<br>ConstructorArg constructorArg1 = new ConstructorArg.Builder()<br>        .setArg(&quot;rateCounter&quot;)<br>        .setRef(true)<br>        .build();<br><br>ConstructorArg constructorArg2 = new ConstructorArg.Builder()<br>        .setArg(&quot;127.0.0.1&quot;)<br>        .setType(String.class)<br>        .setRef(false)<br>        .build();","like_count":1},{"had_liked":false,"id":360559,"user_name":"徐志超-Klaus","can_delete":false,"product_type":"c1","uid":2343086,"ip_address":"北京","ucode":"CF26B39965F2A2","user_header":"https://static001.geekbang.org/account/avatar/00/23/c0/ae/e5e62510.jpg","comment_is_top":false,"comment_ctime":1666661126,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1666661126","product_id":100039001,"comment_content":"争哥你好。如果 建造者 对象 有is a关系，怎么做继承呢？试了半天写不出来，子类的builder类该怎么写呢？","like_count":0,"discussions":[{"author":{"id":2343086,"avatar":"https://static001.geekbang.org/account/avatar/00/23/c0/ae/e5e62510.jpg","nickname":"徐志超-Klaus","note":"","ucode":"CF26B39965F2A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591572,"discussion_content":"问题在于，子类Builder的继承调用 父类Builder类里setXxx方法返回的 this 是父类，然后链式调用的时候会报错；问题只有动手试过才知道，想当然是不行的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666665381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357348,"user_name":"简单猫","can_delete":false,"product_type":"c1","uid":1866485,"ip_address":"江西","ucode":"EA027D4C344E25","user_header":"https://static001.geekbang.org/account/avatar/00/1c/7a/f5/54a5084b.jpg","comment_is_top":false,"comment_ctime":1663169500,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663169500","product_id":100039001,"comment_content":"工厂模式:不同参数，生成不同的对象。无序<br><br><br>建造者模式:不同参数，生成同一个对象。<br><br>一般构造模式还有构造顺序的要求。<br>例如车:先创建车架，创建发动机，车身上安装发动机，创建大灯，车身安卓大灯。","like_count":0},{"had_liked":false,"id":353722,"user_name":"R","can_delete":false,"product_type":"c1","uid":2172520,"ip_address":"河北","ucode":"3721FC8C8DE174","user_header":"https://static001.geekbang.org/account/avatar/00/21/26/68/b86dc4df.jpg","comment_is_top":false,"comment_ctime":1659697241,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1659697241","product_id":100039001,"comment_content":"&#47;**<br> * ref 为 true 的时候，arg 表示 String 类型的 refBeanId，type 不需要设置；<br> * 当 isRef 为 false 的时候，arg、type 都需要设置。<br> * 请根据这个需求，完善 ConstructorArg 类。<br> *&#47;<br>@Getter<br>@ToString<br>public class ConstructorArg {<br><br>    private final boolean ref;<br><br>    private final Class&lt;?&gt; type;<br><br>    private final Object arg;<br><br>    private ConstructorArg(Builder builder) {<br>        this.ref = builder.ref;<br>        this.type = builder.type;<br>        this.arg = builder.arg;<br>    }<br><br>    public static Builder withRef(boolean isRef) {<br>        return new Builder().ref(isRef);<br>    }<br><br>    @Getter<br>    public static class Builder {<br><br>        private boolean ref;<br><br>        private Class&lt;?&gt; type;<br><br>        private Object arg;<br><br>        public Builder ref(boolean isRef) {<br>            this.ref = isRef;<br>            return this;<br>        }<br><br>        public Builder type(Class&lt;?&gt; clazz) {<br>            if (isRef()) {<br>                throw new IllegalArgumentException(&quot;ref = &quot; + isRef() + &quot; 不需要设置 type&quot;);<br>            }<br>            this.type = clazz;<br>            return this;<br>        }<br><br>        public Builder arg(Object arg) {<br>            if (isRef()) {<br>                if (!(arg instanceof String)) {<br>                    throw new IllegalArgumentException(&quot;ref = &quot; + isRef() + &quot; arg 类型需要是 java.lang.String&quot;);<br>                }<br>            }<br>            this.arg = arg;<br>            return this;<br>        }<br><br>        public ConstructorArg build() {<br>            if (!isRef()) {<br>                if (type == null || arg == null) {<br>                    throw new IllegalArgumentException(&quot;ref = &quot; + isRef() + &quot;, type、arg 必须指定&quot;);<br>                }<br>            } else {<br>                if (arg == null) {<br>                    throw new IllegalArgumentException(&quot;arg 必须指定, 不能为空&quot;);<br>                }<br>            }<br>            return new ConstructorArg(this);<br>        }<br>    }<br>}","like_count":0},{"had_liked":false,"id":353430,"user_name":"英雄","can_delete":false,"product_type":"c1","uid":1546612,"ip_address":"四川","ucode":"D1033C83C6CDE9","user_header":"https://static001.geekbang.org/account/avatar/00/17/99/74/0203bf17.jpg","comment_is_top":false,"comment_ctime":1659433043,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659433043","product_id":100039001,"comment_content":"我记得前面有一节课，评论区老哥说不要使用这种方法调用链、、、","like_count":0},{"had_liked":false,"id":350117,"user_name":"cheng_yc","can_delete":false,"product_type":"c1","uid":2856263,"ip_address":"","ucode":"6DE872A6AEC42E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqFjqX19XHS5npsnSrrxibLQU9b0zMb3AzmdribYdEOFrXCyh7dJRF8g8MUibWfbMM8K7fA46AZib75SQ/132","comment_is_top":false,"comment_ctime":1656579790,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1656579790","product_id":100039001,"comment_content":"public class ConstructorArg {<br><br>    private boolean isRef;<br><br>    private Class type;<br><br>    private Object arg;<br><br>    private ConstructorArg(Builder builder) {<br>        this.isRef = builder.isRef;<br>        this.type = builder.type;<br>        this.arg = builder.arg;<br>    }<br><br>    public static Builder build() {<br>        return new Builder();<br>    }<br><br>    public static class Builder {<br><br>        private boolean isRef;<br><br>        private Class type;<br><br>        private Object arg;<br><br>        public Builder() {<br>        }<br><br>        public Builder setRef(boolean ref) {<br>            isRef = ref;<br>            return this;<br>        }<br><br>        public Builder setType(Class type) {<br>            this.type = type;<br>            return this;<br>        }<br><br>        public Builder setArg(Object arg) {<br>            this.arg = arg;<br>            return this;<br>        }<br><br>        public ConstructorArg builder() {<br>            if (this.isRef) {<br>                if (!(this.arg instanceof String)) {<br>                    throw new IllegalArgumentException(&quot;the isRef is true, this.arg is not type of string&quot;);<br>                }<br>            } else {<br>                if (this.arg == null || this.type == null) {<br>                    throw new IllegalArgumentException(&quot;the isRef is false, the arg must not null or type must not null&quot;);<br>                }<br>            }<br>            return new ConstructorArg(this);<br>        }<br><br>    }<br><br>    public static void main(String[] args) {<br>        System.out.println(ConstructorArg.build().setRef(false).setArg(&quot;aaaa&quot;).builder());<br>    }<br><br><br>}<br>","like_count":0},{"had_liked":false,"id":348816,"user_name":"Nax","can_delete":false,"product_type":"c1","uid":2957116,"ip_address":"","ucode":"3B1F5274B4E3CC","user_header":"","comment_is_top":false,"comment_ctime":1655433211,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655433211","product_id":100039001,"comment_content":"建造者模式是通过引入一个Builder类，隐藏了待建造类的set接口，将对象的生成时机延迟到参数配置完成之后。主要用于解决构造参数列表冗长、参数间存在依赖、对象状态无效等问题","like_count":0},{"had_liked":false,"id":344688,"user_name":"Geek_7e0e83","can_delete":false,"product_type":"c1","uid":2142423,"ip_address":"","ucode":"554DEE2AAAE33C","user_header":"","comment_is_top":false,"comment_ctime":1651723520,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651723520","product_id":100039001,"comment_content":"课堂作业上传到GitHub了，感兴趣的小伙伴可以看一下<br>https:&#47;&#47;github.com&#47;yukunqi&#47;designPattern&#47;tree&#47;master&#47;src&#47;main&#47;java&#47;com&#47;builder","like_count":0},{"had_liked":false,"id":340143,"user_name":"千锤百炼领悟之极限","can_delete":false,"product_type":"c1","uid":1744257,"ip_address":"","ucode":"224B5CF2101716","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9d/81/d748b7eb.jpg","comment_is_top":false,"comment_ctime":1648625692,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648625692","product_id":100039001,"comment_content":"适合使用建造者模式的场景<br>1.必填属性过多，不适合在构造函数中设置。<br>2.属性间有依赖关系或约束条件。<br>3.创建不可变对象，不适合提供set方法设置属性。<br><br>建造者模式与工厂模式区别<br>工厂模式是创建不同但是相关类型的对象，由给定的参数确定创建哪种类型的对象。<br><br>建造者模式是创建一种类型的复杂对象，由可选参数定制化地创建不同对象。","like_count":0},{"had_liked":false,"id":337912,"user_name":"Super~琪琪","can_delete":false,"product_type":"c1","uid":1039225,"ip_address":"","ucode":"5A0FCD19B24EAF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/79/9426c6ce.jpg","comment_is_top":false,"comment_ctime":1647157320,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1647157320","product_id":100039001,"comment_content":"想用到设计模式，其实还是需要自己业务有这种场景。能体会到为什么要使用设计模式。","like_count":0},{"had_liked":false,"id":334645,"user_name":"windliang","can_delete":false,"product_type":"c1","uid":1234620,"ip_address":"","ucode":"D31E26BFB09DE6","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/bc/026ac6b1.jpg","comment_is_top":false,"comment_ctime":1645056512,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645056512","product_id":100039001,"comment_content":"争哥，这个建造者模式看起来和原始的 GOF 书中的定义不太一样？原始的建造者模式是没有应用了吗","like_count":0},{"had_liked":false,"id":330046,"user_name":"Geek_East","can_delete":false,"product_type":"c1","uid":1589947,"ip_address":"","ucode":"A1A7CBF9B8FB2D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXKSvfaeicog2Ficx4W3pNeA1KRLOS7iaFy2uoxCDoYpGkGnP6KPGecKia6Dr3MtCkNGpHxAzmTMd0LA/132","comment_is_top":false,"comment_ctime":1641769376,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1641769376","product_id":100039001,"comment_content":"多线程怎么搞","like_count":0},{"had_liked":false,"id":320538,"user_name":"charmsongo","can_delete":false,"product_type":"c1","uid":1609051,"ip_address":"","ucode":"4FBEE716E93A1A","user_header":"https://static001.geekbang.org/account/avatar/00/18/8d/5b/383a49e4.jpg","comment_is_top":false,"comment_ctime":1636372389,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636372389","product_id":100039001,"comment_content":"public class ConstructorArg {<br>    private boolean isRef;<br>    private Class type;<br>    private Object arg;<br>    private ConstructorArg(Builder builder) {<br>        this.isRef = builder.isRef;<br>        this.type = builder.type;<br>        this.arg = builder.arg;<br>    }<br>    &#47;&#47;...省略getter方法...<br><br>    public static class Builder {<br>        private boolean isRef;<br>        private Class type;<br>        private Object arg;<br>        public ConstructorArg Builder() {<br>            if (isRef &amp;&amp; !(arg instanceof String)) {<br>                throw new RuntimeException(&quot;1...&quot;);<br>            }<br>            if (!isRef) {<br>                if (arg == null || type == null) {<br>                    throw new RuntimeException(&quot;2...&quot;);<br>                }<br>            }<br>            return new ConstructorArg(this);<br>        }<br>        public Builder setRef(boolean ref) {<br>            isRef = ref;<br>            return this;<br>        }<br>        public Builder setType(Class type) {<br>            this.type = type;<br>            return this;<br>        }<br>        public Builder setArg(Object arg) {<br>            this.arg = arg;<br>            return this;<br>        }<br>    }<br>}","like_count":0},{"had_liked":false,"id":320330,"user_name":"静✨","can_delete":false,"product_type":"c1","uid":1658413,"ip_address":"","ucode":"1B33229C206339","user_header":"https://static001.geekbang.org/account/avatar/00/19/4e/2d/06d3f9f5.jpg","comment_is_top":false,"comment_ctime":1636257258,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636257258","product_id":100039001,"comment_content":"项目里用ES的querybuilder已久，一直只觉得整个过程呵然而成。今天看了设计者模式，对其中的原因恍然大悟！感谢小争哥","like_count":0},{"had_liked":false,"id":316977,"user_name":"柠檬树下少年和吉他","can_delete":false,"product_type":"c1","uid":2287842,"ip_address":"","ucode":"BAA49942E3EE3F","user_header":"https://static001.geekbang.org/account/avatar/00/22/e8/e2/5a1345c9.jpg","comment_is_top":false,"comment_ctime":1634631222,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634631222","product_id":100039001,"comment_content":"我在开发场景中怎么用不到这个建造者模式","like_count":0},{"had_liked":false,"id":313705,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1632625323,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632625323","product_id":100039001,"comment_content":"package com.zx.design.builder;<br><br>&#47;**<br> * Copyright (C) zhongda<br> *<br> * @author zhangxu<br> * @date 2021&#47;9&#47;26 0026 09:50<br> * @description:<br> *&#47;<br>public class ConstructorArg {<br>    private boolean isRef;<br>    private Class type;<br>    private Object arg;<br><br><br><br>    private ConstructorArg(boolean isRef,Class type,Object arg){<br>        this.isRef = isRef;<br>        this.type = type;<br>        this.arg = arg;<br>    }<br><br>    public static ConstructorArg.Builder newInstance(){<br>        return new ConstructorArg.Builder();<br>    }<br><br><br>    public static class Builder{<br>        private boolean isRef = false;<br>        private Class type = null;<br>        private Object arg = null;<br><br>        public Builder(){<br>        }<br><br>        public ConstructorArg.Builder isRef(boolean isRef){<br>            this.isRef = isRef;<br>            return this;<br>        }<br><br>        public ConstructorArg.Builder type(Class type){<br>            this.type = type;<br>            return this;<br>        }<br><br>        public ConstructorArg.Builder arg(Object arg){<br>            this.arg = arg;<br>            return this;<br>        }<br><br>        public ConstructorArg build(){<br>            if(isRef){<br><br>                if(arg==null){<br>                    throw new IllegalArgumentException(&quot;arg can not be null&quot;);<br>                }<br><br>                if(!(arg instanceof String)){<br>                    throw new IllegalArgumentException(&quot;arg type is wrong&quot;);<br>                }<br><br>            }else{<br>                if(this.type==null || this.arg==null){<br>                    throw new IllegalArgumentException(&quot;type or arg can not be null&quot;);<br>                }<br>            }<br><br>            return new ConstructorArg(this.isRef,this.type,this.arg);<br>        }<br>    }<br><br>}<br>","like_count":0,"discussions":[{"author":{"id":1206066,"avatar":"https://static001.geekbang.org/account/avatar/00/12/67/32/b402f3c5.jpg","nickname":"eve","note":"","ucode":"1C439CB1703118","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":106477,"discussion_content":"你这个不是策略模式，而且这个场景用模板模式更好一些","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1577537755,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1744062,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eq69BUSktQUY0dhQIoFxSAic0r3ElUUUL1uFtpFnKSpCAJYEsOfibU3Ja701L8UmbrPVS2ZAIreRLtA/132","nickname":"Liscoal","note":"","ucode":"8A6A0DBD60847F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1206066,"avatar":"https://static001.geekbang.org/account/avatar/00/12/67/32/b402f3c5.jpg","nickname":"eve","note":"","ucode":"1C439CB1703118","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":249323,"discussion_content":"他这个例子里面,public static <T> T handle(Fun<T> fun);方法的确体现出了策略模式. Fun<T>是抽象策略，其子类是具体策略，而DealWithHandle类则是环境(Context)。\n我个人也赞同你说的这个场景采用模板方法模式会更好.因为这三个步骤1.发送请求报文 2.请求报文 3.解析回执报文的实现细节根据不同业务方差异通常是比较大的，最好还是由不同的子类去实现。\n策略模式比较常见的场景是对过多的if eles优化.","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1587915438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":106477,"ip_address":""},"score":249323,"extra":""},{"author":{"id":1112490,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f9/aa/3e80212e.jpg","nickname":"龙猫","note":"","ucode":"FD726CC969EF9C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1744062,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eq69BUSktQUY0dhQIoFxSAic0r3ElUUUL1uFtpFnKSpCAJYEsOfibU3Ja701L8UmbrPVS2ZAIreRLtA/132","nickname":"Liscoal","note":"","ucode":"8A6A0DBD60847F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296138,"discussion_content":"都是大佬，学习了，血赚","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596459789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":249323,"ip_address":""},"score":296138,"extra":""}]},{"author":{"id":2130462,"avatar":"https://static001.geekbang.org/account/avatar/00/20/82/1e/f3cb3d57.jpg","nickname":"超越自我","note":"","ucode":"8A55D972EEFADA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299586,"discussion_content":"这个应该是模板方法模式","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1597741183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1916100,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/3c/c4/27305e34.jpg","nickname":"Atom","note":"","ucode":"A5204FC1C13A9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285497,"discussion_content":"看了github很多几k star写的设计模式，确实都是用阿猫阿狗来类比，初次容易理解，但是后头就又忘了，实际生产时又想不出来得用什么，为什么用，怎么用","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1592844121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2396269,"avatar":"https://static001.geekbang.org/account/avatar/00/24/90/6d/705f3874.jpg","nickname":"大雄","note":"","ucode":"BABD97EBBB1394","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342486,"discussion_content":"最快的学习方法就是自己在项目里面想着这个功能可以用那种设计模式，及时不需要用，你也去尝试着用，后面就慢慢的理解这种设计模式是什么，怎么用才好，看阿猫阿狗确实看了就忘，不能真正理解","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610696106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1501018,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/5a/9578215e.jpg","nickname":"蔡晓亮","note":"","ucode":"48C043DE389595","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318286,"discussion_content":"开源项目这种写法比较多，学习了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603698313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1103353,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d5/f9/1f9a2c3c.jpg","nickname":"磨砖做镜","note":"","ucode":"D8B8196AE1ED98","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250674,"discussion_content":"手机看代码不方便。。这评论区应该支持md","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588035426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1597071,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLe9iavda8ia7vNkbMVEHsCKs43l6U6HGWibiaxxKd9PuiaYu5wRedicC96PLicZ9VIh0ic5Jg8YHPrta3IAQ/132","nickname":"Geek_00e01b","note":"","ucode":"BC76A83B53D0EF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1103353,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d5/f9/1f9a2c3c.jpg","nickname":"磨砖做镜","note":"","ucode":"D8B8196AE1ED98","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312114,"discussion_content":"电脑看也不方便，这种没有格式的根本不想看","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1602584895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":250674,"ip_address":""},"score":312114,"extra":""}]},{"author":{"id":2707023,"avatar":"https://static001.geekbang.org/account/avatar/00/29/4e/4f/acc26a87.jpg","nickname":"Luffy","note":"","ucode":"ECF5402610FE72","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590442,"discussion_content":"666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665741333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖北"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2807969,"avatar":"","nickname":"Geek_7ce555","note":"","ucode":"5ED7DD4FF41E26","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583089,"discussion_content":"学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659922331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2415448,"avatar":"https://static001.geekbang.org/account/avatar/00/24/db/58/a7a0a85b.jpg","nickname":"二饼","note":"","ucode":"48120565D135F7","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579927,"discussion_content":"厉害，谢谢分享","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657777269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2349845,"avatar":"","nickname":"Geek_5b71f3","note":"","ucode":"104CB5C80FFF8D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331792,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606978100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1112490,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f9/aa/3e80212e.jpg","nickname":"龙猫","note":"","ucode":"FD726CC969EF9C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296136,"discussion_content":"66666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596459770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1242573,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/cd/3890be04.jpg","nickname":"小川","note":"","ucode":"D462222DDBB978","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":89912,"discussion_content":"- - 我.. 我也想加","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576764285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1131687,"avatar":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","nickname":"啦啦啦","note":"","ucode":"6B12EC90A62525","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":82080,"discussion_content":"不错，老兄对设计模式理解的很好，可以加个微信交流一下不","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576317631,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313272,"user_name":"Geek_ae35e3","can_delete":false,"product_type":"c1","uid":2777897,"ip_address":"","ucode":"82C8AD06D84FCA","user_header":"","comment_is_top":false,"comment_ctime":1632360613,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632360613","product_id":100039001,"comment_content":"了解了本质。自然就明白他们的区别。说不出来区别，也就说明还没有了解本质","like_count":0},{"had_liked":false,"id":307307,"user_name":"R","can_delete":false,"product_type":"c1","uid":2172520,"ip_address":"","ucode":"3721FC8C8DE174","user_header":"https://static001.geekbang.org/account/avatar/00/21/26/68/b86dc4df.jpg","comment_is_top":false,"comment_ctime":1629020093,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1629020093","product_id":100039001,"comment_content":"&#47;**<br> * 需求：<br> * &lt;li&gt;当 isRef 为 true 的时候, arg 表示 String 类型的 refBeanId, type不需要设置&lt;&#47;li&gt;<br> * &lt;li&gt;当 isRef 为 false 的时候, arg、type 都需要设置&lt;&#47;li&gt;<br> *<br> * @author Ringo<br> * @date 2021&#47;8&#47;15 16:51<br> *&#47;<br>public class ConstructorArg {<br><br>    private boolean isRef;<br><br>    private Class&lt;?&gt; type;<br><br>    private Object arg;<br><br>    private ConstructorArg() {<br>    }<br><br>    &#47;&#47; ToString<br>    @Override<br>    public String toString() {<br>        return &quot;ConstructorArg{&quot; +<br>                &quot;isRef=&quot; + isRef +<br>                &quot;, type=&quot; + type +<br>                &quot;, arg=&quot; + arg +<br>                &#39;}&#39;;<br>    }<br><br>    &#47;&#47; 创建Builder的时候直接使用这个方法<br>    public static Builder withIsRef(boolean isRef) {<br>        return new Builder().isRef(isRef);<br>    }<br><br>    public static class Builder {<br><br>        private boolean isRef;<br><br>        private Class&lt;?&gt; type;<br><br>        private Object arg;<br><br>        public Builder isRef(boolean isRef) {<br>            this.isRef = isRef;<br>            return this;<br>        }<br><br>        public Builder type(Class&lt;?&gt; type) {<br>            this.type = type;<br>            return this;<br>        }<br><br>        public Builder arg(Object arg) {<br>            this.arg = arg;<br>            return this;<br>        }<br><br>        public ConstructorArg build() {<br>            ConstructorArg constructorArg = new ConstructorArg();<br>            constructorArg.isRef = this.isRef;<br>            if (this.isRef) {<br>                if (!(this.arg instanceof String))<br>                    throw new IllegalArgumentException(&quot;arg必须是String类型&quot;);<br>                constructorArg.arg = this.arg;<br>                constructorArg.type = null;<br>            } else {<br>                if (this.arg == null || this.type == null)<br>                    throw new IllegalArgumentException(&quot;arg或type不能为空&quot;);<br>                constructorArg.type = this.type;<br>                constructorArg.arg = this.arg;<br>            }<br>            return constructorArg;<br>        }<br>    }<br>}","like_count":0},{"had_liked":false,"id":306465,"user_name":"sean","can_delete":false,"product_type":"c1","uid":2703237,"ip_address":"","ucode":"B517C6A09A4F07","user_header":"","comment_is_top":false,"comment_ctime":1628572764,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1628572764","product_id":100039001,"comment_content":"静态构建者模式是不是会有线程冲突问题，需要加锁，因为builder里面的方法相当于修改全局变量","like_count":0},{"had_liked":false,"id":303002,"user_name":"吕成 Zero","can_delete":false,"product_type":"c1","uid":2410746,"ip_address":"","ucode":"5665769CC41329","user_header":"https://static001.geekbang.org/account/avatar/00/24/c8/fa/baf9847c.jpg","comment_is_top":false,"comment_ctime":1626511565,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626511565","product_id":100039001,"comment_content":"&#47;&#47; 写得不对的地方请各位指正。<br>public class ConstructorArg {<br>    private boolean isRef;<br>    private Class type;<br>    private Object arg;<br><br>    private ConstructorArg (Builder builder) {<br>        isRef = builder.isRef;<br>        type = builder.type;<br>        arg = builder.arg;<br>    }<br><br>    public static class Builder {<br>        private boolean isRef;<br>        private Class type;<br>        private Object arg;<br><br>        public ConstructorArg build() {<br>            if (this.isRef == true) {<br>                if (this.arg != null &amp;&amp; this.arg instanceof String &amp;&amp; type == null) {<br>                    System.out.println(&quot;build success&quot;);<br>                } else {<br>                    throw new IllegalArgumentException(&quot;The arg should be String and the type doesn&#39;t need to be set&quot;);<br>                }<br>            } else if (this.isRef == false) {<br>                if (this.arg != null &amp;&amp; type != null) {<br>                    System.out.println(&quot;build success&quot;);<br>                } else {<br>                    throw new IllegalArgumentException(&quot;Both arg and type must be set&quot;);<br>                }<br>            }<br>            return new ConstructorArg(this);<br>        }<br><br>        public Builder setIsRef(boolean isRef) {<br>            if (ObjectUtils.isEmpty(isRef)) {<br>                throw new IllegalArgumentException(&quot;The isRef must be set&quot;);<br>            }<br>            this.isRef = isRef;<br>            return this;<br>        }<br><br>        public Builder setType(Class type) {<br>            if (ObjectUtils.isEmpty(type)) {<br>                throw new IllegalArgumentException(&quot;The type should not be null when setting value&quot;);<br>            }<br>            this.type = type;<br>            return this;<br>        }<br><br>        public Builder setArg(Object arg) {<br>            if (ObjectUtils.isEmpty(arg)) {<br>                throw new IllegalArgumentException(&quot;The arg should not be null when setting value&quot;);<br>            }<br>            this.arg = arg;<br>            return this;<br>        }<br>    }<br>}","like_count":0},{"had_liked":false,"id":298406,"user_name":"Lee","can_delete":false,"product_type":"c1","uid":1144462,"ip_address":"","ucode":"314D7BCB5C7C24","user_header":"https://static001.geekbang.org/account/avatar/00/11/76/8e/cf43b065.jpg","comment_is_top":false,"comment_ctime":1624087092,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624087092","product_id":100039001,"comment_content":"使用工厂模式还是建造者模式，根源还是“定制化”。<br>一个对象即使再复杂，如果不提供太多定制化的创建过程，希望完全屏蔽创建过程，这个时候就使用工厂模式，这其实是创建过程的黑盒化。<br>如果创建的对象可以有多种定制化的方案，使用者可以灵活的设置各种参数，这个时候是无法屏蔽创建细节的，这时候更适合使用建造者模式，这是创建过程白盒化。<br>所以最根本的还是这个对象你想提供的“定制化”程度。","like_count":0},{"had_liked":false,"id":294427,"user_name":"Kyle(","can_delete":false,"product_type":"c1","uid":1640978,"ip_address":"","ucode":"0C14C4C086CAA9","user_header":"https://static001.geekbang.org/account/avatar/00/19/0a/12/f8b988b8.jpg","comment_is_top":false,"comment_ctime":1621937787,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621937787","product_id":100039001,"comment_content":"老师，那不是可以直接用Bulder....不过要外层限制了只能用ResourcePoolConfig那还好....另外我看到RabbitMQ的Bulder模式有另外的玩法，类似于你课后的问题，人家不在校验里做，而是直接限制了方法（多个建造者套娃的感觉）你必须至少先bind + to构造，或者bind + to + with 构造...","like_count":0},{"had_liked":false,"id":293051,"user_name":"ZX","can_delete":false,"product_type":"c1","uid":1235583,"ip_address":"","ucode":"0D2622FE6D1774","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/7f/8069035d.jpg","comment_is_top":false,"comment_ctime":1621174108,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621174108","product_id":100039001,"comment_content":"生成器模式，具体应该有哪几部分划分呢。在什么样的场景下使用说的很清晰，但是具体生成器解析好像还差了一点","like_count":0},{"had_liked":false,"id":288877,"user_name":"她","can_delete":false,"product_type":"c1","uid":1968721,"ip_address":"","ucode":"FAC6851866C9C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/unkzY52hVDjTmZJGNkrBR75tFs4XTGBoYYcOYkIcPvHlQrLibwc94aBfj1uWiawoKeEMwHbkvgThXZarfoP8Dzag/132","comment_is_top":false,"comment_ctime":1618746243,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618746243","product_id":100039001,"comment_content":"&quot;如果我们把必填项也通过 set() 方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了。&quot;  可以帮忙解答下这句话的意思吗？为什么 “校验这些必填项是否已经填写的逻辑就无处安放了” 没有地方写了，必填项校验做了后，接着后面写不就行了吗~","like_count":0},{"had_liked":false,"id":288204,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1618363258,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1618363258","product_id":100039001,"comment_content":"public class ConstructorArg {<br>    private boolean isRef;<br>    private Class type;<br>    private Object arg;<br><br>    private Object ext;<br><br>    private ConstructorArg() {<br><br>    }<br><br>    public static class Builder {<br><br>        private ConstructorArg target;<br><br>        public Builder() {<br>            target = new ConstructorArg();<br>        }<br><br>        public ConstructorArg build() {<br>            if (target.arg == null) {<br>                throw new IllegalArgumentException(&quot;arg需要设置&quot;);<br>            }<br>            if (target.isRef) {<br>                if (!(target.arg instanceof String)) {<br>                    throw new IllegalArgumentException(&quot;arg为String&quot;);<br>                }<br>            } else {<br>                if (target.type == null) {<br>                    throw new IllegalArgumentException(&quot;type需要设置&quot;);<br>                }<br>            }<br>            return target;<br>        }<br><br>        public Builder setRef(boolean ref) {<br>            target.isRef = ref;<br>            return this;<br>        }<br><br>        public Builder setType(Class type) {<br>            target.type = type;<br>            return this;<br>        }<br><br>        public Builder setArg(Object arg) {<br>            target.arg = arg;<br>            return this;<br>        }<br><br>        public Builder set(Consumer&lt;ConstructorArg&gt; consumer) {<br>            consumer.accept(target);<br>            return this;<br>        }<br><br>        public static void main(String[] args) {<br>            ConstructorArg build = new Builder().setRef(false).setArg(&quot;123&quot;).setType(String.class).set(target-&gt;target.ext =&quot;otherTest&quot;).build();<br>            System.out.println(build);<br>        }<br>    }<br>}<br>由于主类中的成员变量，要在Builder类中重新再定义一遍。考虑Builder类不维护主类字段，在Builder()中提取构造好主类对象，后续再进行对指定字段Set，主类扩展字段时Builder类只需调用set处理Consumer&lt;ConstructorArg&gt;即可<br>缺点：由于Builder()提前构造空对象，对象存在无效状态<br>优点：只需要维护主类新增字段即可，可维护性更好","like_count":0},{"had_liked":false,"id":287591,"user_name":"ljx","can_delete":false,"product_type":"c1","uid":2446982,"ip_address":"","ucode":"6133FC98C44498","user_header":"https://static001.geekbang.org/account/avatar/00/25/56/86/db4c0d1c.jpg","comment_is_top":false,"comment_ctime":1618041547,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1618041547","product_id":100039001,"comment_content":"之前一直不太理解建造者模式。看了这篇文章感觉收获很大。想起昨天做一个需求的时候就遇到了第二种需要考虑建造者模式的情况。当时就在想校验放在哪里合适。始终找不到合适的地方，最后只能草草的放在了一个奇奇怪怪的地方。下周就用建造者模式重构一下","like_count":0},{"had_liked":false,"id":286226,"user_name":"越客","can_delete":false,"product_type":"c1","uid":2421338,"ip_address":"","ucode":"2BF54F35774744","user_header":"https://static001.geekbang.org/account/avatar/00/24/f2/5a/399ff23b.jpg","comment_is_top":false,"comment_ctime":1617201355,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617201355","product_id":100039001,"comment_content":"python就不需要建造者模式，它的传参机制就决定了不会存在参数列表过长和默认参数设置的问题","like_count":0},{"had_liked":false,"id":283660,"user_name":"Yeyw","can_delete":false,"product_type":"c1","uid":1463740,"ip_address":"","ucode":"C9D20DB91C3BE5","user_header":"https://static001.geekbang.org/account/avatar/00/16/55/bc/fad0090b.jpg","comment_is_top":false,"comment_ctime":1615875205,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615875205","product_id":100039001,"comment_content":"&#47;**<br> * 构造方法参数类<br> *<br> * @author Ye yw<br> * @date 2021&#47;3&#47;16 14:07<br> *&#47;<br><br>public class ConstructorArg {<br>    &#47;**<br>     * 是否引用<br>     *&#47;<br>    private final boolean isRef;<br>    &#47;**<br>     * 参数类型<br>     *&#47;<br>    private final Class&lt;?&gt; type;<br>    &#47;**<br>     * 参数值<br>     *&#47;<br>    private final Object arg;<br><br>    public ConstructorArg(boolean isRef, Class&lt;?&gt; type, Object arg) {<br>        this.isRef = isRef;<br>        this.type = type;<br>        this.arg = arg;<br>    }<br><br>    public static Builder builder() {<br>        return new Builder();<br>    }<br><br>    public static class Builder {<br>        private boolean isRef;<br>        private Class&lt;?&gt; type;<br>        private Object arg;<br><br>        public Builder() {<br>        }<br><br>        public Builder isRef(boolean ref) {<br>            isRef = ref;<br>            return this;<br>        }<br><br>        public Builder type(Class&lt;?&gt; type) {<br>            this.type = type;<br>            return this;<br>        }<br><br>        public Builder arg(Object arg) {<br>            this.arg = arg;<br>            return this;<br>        }<br><br>        public ConstructorArg build() {<br>            if (isRef) {<br>                type = null;<br>                Assert.state(arg instanceof String, &quot;arg must be a String&quot;);<br>            } else {<br>                Assert.notNull(arg, &quot;arg cannot be null&quot;);<br>                Assert.notNull(type, &quot;type cannot be null&quot;);<br>            }<br><br>            return new ConstructorArg(isRef, type, arg);<br>        }<br><br><br>    }<br>}<br>","like_count":0},{"had_liked":false,"id":282720,"user_name":"大风","can_delete":false,"product_type":"c1","uid":1640974,"ip_address":"","ucode":"583873CCAA2A67","user_header":"","comment_is_top":false,"comment_ctime":1615375496,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615375496","product_id":100039001,"comment_content":"大师高屋建瓴拨云见日，从此再无建造者模式的窗户纸","like_count":0},{"had_liked":false,"id":282192,"user_name":"李树增","can_delete":false,"product_type":"c1","uid":2015851,"ip_address":"","ucode":"58B0509EE56777","user_header":"https://static001.geekbang.org/account/avatar/00/1e/c2/6b/149d9ab1.jpg","comment_is_top":false,"comment_ctime":1615125541,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615125541","product_id":100039001,"comment_content":"package com.lsz.factory.demo.api;<br><br>import java.util.Objects;<br><br>public class ConstructorArg {<br>    private boolean isRef;<br><br>    private Class type;<br><br>    private Object arg;<br><br>    public ConstructorArg() {}<br><br>    private ConstructorArg(boolean isRef, Class type, Object arg) {<br>        this.isRef = isRef;<br>        this.type = type;<br>        this.arg = arg;<br>    }<br><br>    public boolean isRef() {<br>        return isRef;<br>    }<br><br>    public void setRef(boolean ref) {<br>        isRef = ref;<br>    }<br><br>    public Class getType() {<br>        return type;<br>    }<br><br>    public void setType(Class type) {<br>        this.type = type;<br>    }<br><br>    public Object getArg() {<br>        return arg;<br>    }<br><br>    public void setArg(Object arg) {<br>        this.arg = arg;<br>    }<br><br><br>    public static class ConstructorArgBuilder {<br>        private boolean isRef;<br>        private Class type;<br>        private Object arg;<br><br>        public ConstructorArgBuilder isRef(boolean isRef) {<br>            this.isRef = isRef;<br>            return this;<br>        }<br><br>        public ConstructorArgBuilder type(Class type) {<br>            this.type = type;<br>            return this;<br>        }<br><br>        public ConstructorArgBuilder arg(Object arg) {<br>            this.arg = arg;<br>            return this;<br>        }<br><br>        public ConstructorArg build() {<br>            if (Objects.isNull(isRef) || Objects.isNull(arg)) {<br>                throw new IllegalArgumentException(&quot;need &#39;isRef&#39; or &#39;arg&#39;&quot;);<br>            }<br>            if (!isRef &amp;&amp; Objects.isNull(type)) {<br>                throw new IllegalArgumentException(&quot;need &#39;type&#39;&quot;);<br>            }<br>            return new ConstructorArg(isRef, type, arg);<br>        }<br>    }<br>}<br>","like_count":0},{"had_liked":false,"id":281642,"user_name":"马晨阳","can_delete":false,"product_type":"c1","uid":1230031,"ip_address":"","ucode":"344ACC3BF7F14A","user_header":"https://static001.geekbang.org/account/avatar/00/12/c4/cf/6e1205cc.jpg","comment_is_top":false,"comment_ctime":1614838332,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614838332","product_id":100039001,"comment_content":"感觉最近看代码里基本builder模式都不是用的本意，都是觉得set很low所以用，其实根本没必要","like_count":0},{"had_liked":false,"id":279391,"user_name":"openxgj","can_delete":false,"product_type":"c1","uid":1282657,"ip_address":"","ucode":"9B611C505CB7F5","user_header":"https://static001.geekbang.org/account/avatar/00/13/92/61/661716ed.jpg","comment_is_top":false,"comment_ctime":1613747625,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1613747625","product_id":100039001,"comment_content":"&#47;**<br> * desc：建造者模式<br> * 要求：<br> * 当 isRef 为 true 的时候，arg 表示 String 类型的 refBeanId，type 不需要设置；<br> * 当 isRef 为 false 的时候，arg、type 都需要设置<br> *<br> * @author: openxgj<br> * @date: 2021&#47;2&#47;19<br> **&#47;<br>public class ConstructorArg {<br><br>    private boolean isRef;<br>    private Class type;<br>    private Object arg;<br><br>    private ConstructorArg(Builder builder) {<br>        this.isRef = builder.isRef;<br>        this.type = builder.type;<br>        this.arg = builder.arg;<br>    }<br><br>    public static class Builder {<br><br>        private boolean isRef;<br>        private Class type;<br>        private Object arg;<br><br>        public ConstructorArg build() {<br>            if (isRef) {<br><br>                if (!(arg instanceof String)) {<br>                    throw new IllegalArgumentException(&quot;arg type error is not [java.lang.String]&quot;);<br>                }<br><br>                if (null != type) {<br>                    throw new IllegalArgumentException(&quot;type should not set&quot;);<br>                }<br><br>            } else {<br><br>                if (null == type || null == arg) {<br>                    throw new IllegalArgumentException(&quot;type &amp; arg can not be null&quot;);<br>                }<br><br>            }<br><br>            return new ConstructorArg(this);<br>        }<br><br>        public Builder isRef(boolean isRef) {<br>            this.isRef = isRef;<br>            return this;<br>        }<br><br>        public Builder type(Class type) {<br>            this.type = type;<br>            return this;<br>        }<br><br>        public Builder arg(Object arg) {<br>            this.arg = arg;<br>            return this;<br>        }<br><br>    }<br><br>}<br>","like_count":0},{"had_liked":false,"id":279356,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1613728341,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613728341","product_id":100039001,"comment_content":"设计模式这一part适合与GOF参照学习，一个是示例，一个是理论。","like_count":0},{"had_liked":false,"id":277040,"user_name":"是小毛吖","can_delete":false,"product_type":"c1","uid":1363547,"ip_address":"","ucode":"B14B176DA1C989","user_header":"https://static001.geekbang.org/account/avatar/00/14/ce/5b/d7e523c2.jpg","comment_is_top":false,"comment_ctime":1612243932,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612243932","product_id":100039001,"comment_content":"Builder建设者模式的一种，而非全貌吧。很少有人通过对比set、构造函数等方式介绍建造者模式，感觉这样会容易被误导。","like_count":0},{"had_liked":false,"id":275344,"user_name":"zh","can_delete":false,"product_type":"c1","uid":1982711,"ip_address":"","ucode":"98772B1B6C6E06","user_header":"https://static001.geekbang.org/account/avatar/00/1e/40/f7/e62bbc62.jpg","comment_is_top":false,"comment_ctime":1611479142,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611479142","product_id":100039001,"comment_content":"提供两个构造函数，一个只有一个string参数，一个有两个参数：arg、type","like_count":0},{"had_liked":false,"id":274012,"user_name":"webmin","can_delete":false,"product_type":"c1","uid":1047014,"ip_address":"","ucode":"98B0CA882454E8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/e6/47742988.jpg","comment_is_top":false,"comment_ctime":1610788066,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1610788066","product_id":100039001,"comment_content":"&#47;&#47;留言字数受限文中的Exception应该是为IllegalArgumentException<br>public class ConstructorArg {<br>    private boolean isRef;<br>    private Class type;<br>    private Object arg;<br>    public boolean isRef() {return isRef; }<br>    public Class getType() {return type;}<br>    public Object getArg() {return arg;}<br><br>    private ConstructorArg() {}<br><br>    public static ConstructorArg builder(Function&lt;ConstructorArg, Function&lt;ConstructorArg, Exception&gt;&gt;... options) throws Exception {<br>        ConstructorArg cArg = new ConstructorArg();<br><br>        for (int i = 0; i &lt; options.length; i++) {<br>            Exception err = options[i].apply(cArg).apply(cArg);<br>            if (err != null) {<br>                throw err;<br>            }<br>        }<br>        return cArg;<br>    }<br><br>    public Function&lt;ConstructorArg, Exception&gt; setRef(boolean ref) {<br>        return (c) -&gt; {<br><br>            if (Objects.isNull(c.arg)) {<br>                return new Exception(&quot;...&quot;);<br>            }<br><br>            if (ref &amp;&amp; !Objects.isNull(c.type)) {<br>                return new Exception(&quot;...&quot;);<br>            }<br><br>            if (ref &amp;&amp; arg.getClass() != String.class) {<br>                return new Exception(&quot;...&quot;);<br>            }<br><br>            if (!ref &amp;&amp; Objects.isNull(c.type)) {<br>                return new Exception(&quot;...&quot;);<br>            }<br><br>            c.isRef = ref;<br>            return null;<br>        };<br>    }<br><br>    public Function&lt;ConstructorArg, Exception&gt; setType(Class type) {<br>        return (c) -&gt; {<br>            if (c.isRef || Objects.isNull(type)) {<br>                return new Exception(&quot;...&quot;);<br>            }<br>            c.type = type;<br>            return null;<br>        };<br>    }<br><br>    public Function&lt;ConstructorArg, Exception&gt; setArg(Object arg) {<br>        return (c) -&gt; {<br>            if (Objects.isNull(arg)) {<br>                return new Exception(&quot;...&quot;);<br>            }<br><br>            if (c.isRef &amp;&amp; arg.getClass() != String.class) {<br>                return new Exception(&quot;...&quot;);<br>            }<br><br>            c.arg = arg;<br>            return null;<br>        };<br>    }<br>}","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475305,"discussion_content":"好像我写的是有点问题，稍后更正下，多谢指出","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574377806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2162521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/MaX06SRk19zM2lAaymYylpXD6LMtIPFlDyxZKgRhmZCjhNE4nIdDGBmh08razhebVCgAv54xialYBBIIwmleBew/132","nickname":"Geek_6d1382","note":"","ucode":"B61E65CFEB684F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307645,"discussion_content":"这个直接在公共构造方法当中抛异常如何？这样也能避免实例化","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1600702435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2195178,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/aaWpgv6exm7wPOQ73dtsJ7sia4FEyibbyGgSKJmCChkAACHDBOff2enL6Nv5DhyXJibcic0nNErcO0fTkT4AqlbGwQ/132","nickname":"Geek_6cf3b2","note":"","ucode":"F9D6B16AC4EA91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329827,"discussion_content":"一年之后依然没改","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1606465635,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1071601,"avatar":"https://static001.geekbang.org/account/avatar/00/10/59/f1/8909b9e0.jpg","nickname":"叉歪叉","note":"","ucode":"2C1AFC6335FF0E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298719,"discussion_content":"public class SimulatorInterface {\n\n    protected SimulatorInterface() {\n        check();\n    }\n\n    public void check() {\n        throw new IllegalStateException(&#34;&#34;);\n    }\n}\n\npublic class SubClassA extends SimulatorInterface {\n    @Override\n    public void check() {\n    }\n}\n\n---------\n这样不知道可不可以，捂脸","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1597387646,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1732780,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","nickname":"面向百度编程","note":"","ucode":"8FE04A019D71D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216454,"discussion_content":"还好我看了一下评论，自己并没有错","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1585452830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1035963,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ce/bb/e6c353a1.jpg","nickname":"jaxz","note":"","ucode":"9971305B1CEFEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341652,"discussion_content":"依然没改","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610497404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1766127,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/f2/ef/014389c5.jpg","nickname":"李明威","note":"","ucode":"199C95F3A4C1A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320668,"discussion_content":"我说怎么感觉有点问题呢，之前都是写private","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604448795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1438470,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f3/06/8da1bf0c.jpg","nickname":"Fredo","note":"","ucode":"681D6692617DAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":157365,"discussion_content":"看到这里我也愣了一下，但之后就过去了，这里是个问题。多谢指出！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580474392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2277251,"avatar":"https://static001.geekbang.org/account/avatar/00/22/bf/83/c83be5a3.jpg","nickname":"eHackyd","note":"","ucode":"E6E7994FBDF0A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378761,"discussion_content":"其实能不能实例化是根据访问限定符来看的，自己思考下就知道了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623394076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188793,"avatar":"https://static001.geekbang.org/account/avatar/00/12/23/b9/8d182f13.jpg","nickname":"起风了","note":"","ucode":"9A8A2E51E198EE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307806,"discussion_content":"啊，还好我看了评论。没学过java，不然就当正确的记成笔记了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600763429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1624574,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c9/fe/874b172b.jpg","nickname":"benxiong","note":"","ucode":"F6498059D439D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281503,"discussion_content":"还没有改","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591753946,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1862936,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/6d/18/e05f72ee.jpg","nickname":"冰原的苍蓝星","note":"","ucode":"84120EC31A63AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":255168,"discussion_content":"还没有改？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588383665,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1056982,"avatar":"https://static001.geekbang.org/account/avatar/00/10/20/d6/b9513db0.jpg","nickname":"kingcall","note":"","ucode":"508884DC684B5B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215727,"discussion_content":"应该是解决不了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585375993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121284,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1c/04/b26b665e.jpg","nickname":"孙杏","note":"","ucode":"F0221C3F8D4C77","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":157176,"discussion_content":"所以这块正确的表达方式应该是什么呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580450828,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1638878,"avatar":"https://static001.geekbang.org/account/avatar/00/19/01/de/bf524817.jpg","nickname":"慌张而黑糖","note":"","ucode":"B4416885A301C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":102811,"discussion_content":"这里我也有个问题，如果构造函数声明为私有的了，那还能被继承吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577365237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1242373,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/05/d6547381.jpg","nickname":"才才","note":"","ucode":"94D76106261987","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1638878,"avatar":"https://static001.geekbang.org/account/avatar/00/19/01/de/bf524817.jpg","nickname":"慌张而黑糖","note":"","ucode":"B4416885A301C8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":199840,"discussion_content":"如果有一个公共构造函数就可以继承","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583631818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":102811,"ip_address":""},"score":199840,"extra":""}]},{"author":{"id":1310798,"avatar":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","nickname":"吴小智","note":"","ucode":"C7C9F58B5C9F7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87142,"discussion_content":"好像还没有改？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576646833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":273433,"user_name":"子房","can_delete":false,"product_type":"c1","uid":1438860,"ip_address":"","ucode":"CB05938C248BB3","user_header":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","comment_is_top":false,"comment_ctime":1610594959,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610594959","product_id":100039001,"comment_content":"争哥讲的可以，解惑了","like_count":0},{"had_liked":false,"id":273350,"user_name":"子房","can_delete":false,"product_type":"c1","uid":1438860,"ip_address":"","ucode":"CB05938C248BB3","user_header":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","comment_is_top":false,"comment_ctime":1610545710,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610545710","product_id":100039001,"comment_content":"课后作业首先属于创建一个特定类型的对象， 由于创建对象带有一些复杂逻辑， 所以可以考虑使用  builder  模式构建对象。参数校验都放在单独的一个 buider 方法，  提供 set 方法传入参数，然后对参数进行校验。","like_count":0},{"had_liked":false,"id":273295,"user_name":"子房","can_delete":false,"product_type":"c1","uid":1438860,"ip_address":"","ucode":"CB05938C248BB3","user_header":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","comment_is_top":false,"comment_ctime":1610527270,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610527270","product_id":100039001,"comment_content":"特意看一下 springApplicationBuilder 类的设计<br>    public SpringApplication build(String... args) {<br>        this.configureAsChildIfNecessary(args);<br>        this.application.addPrimarySources(this.sources);<br>        return this.application;<br>    }<br>创建一个 springApplication 应用对象，内部承担的责任确实很多","like_count":0},{"had_liked":false,"id":270346,"user_name":"起风了","can_delete":false,"product_type":"c1","uid":2293092,"ip_address":"","ucode":"613DFFDBB65DFB","user_header":"https://static001.geekbang.org/account/avatar/00/22/fd/64/5651dfd2.jpg","comment_is_top":false,"comment_ctime":1609076594,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609076594","product_id":100039001,"comment_content":"关于建造者模式缺点的一个问题：<br>使用建造者模式后，文章中的初始化对象，name字段实际上是可以不传的，不传会抛出异常。但是使用构造器和set方法时，name是必须传入的，不然无法new对象。这是不是建造者模式的一个缺陷呢。","like_count":0},{"had_liked":false,"id":266226,"user_name":"cw","can_delete":false,"product_type":"c1","uid":1264296,"ip_address":"","ucode":"82A6B50462F9F9","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/a8/b7e36dd2.jpg","comment_is_top":false,"comment_ctime":1607246183,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607246183","product_id":100039001,"comment_content":"建造者模式是创建性模式的一种 与工厂有着异曲同工之妙  但是存在略微区别。<br>建造者模式关注的是对象内部细节，比如参数。<br>建造者模式是避免对象不合法过程的一个比较好的实现----建造者模式也可以用set来实现 但是set可能会导致隐蔽bug。<br>","like_count":0},{"had_liked":false,"id":261758,"user_name":"是非～成败～","can_delete":false,"product_type":"c1","uid":2135601,"ip_address":"","ucode":"5988E5C8B50754","user_header":"https://static001.geekbang.org/account/avatar/00/20/96/31/d3a58c6f.jpg","comment_is_top":false,"comment_ctime":1605514938,"is_pvip":false,"replies":[{"id":"96133","content":"不错！","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606701259,"ip_address":"","comment_id":261758,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605514938","product_id":100039001,"comment_content":"&#47;**<br> * 需求：<br> * 当 isRef 为 true 的时候，arg 表示 String 类型的 refBeanId，type 不需要设置；<br> * 当 isRef 为 false 的时候，arg、type 都需要设置。<br> * 请根据这个需求，完善 ConstructorArg 类。<br> *&#47;<br>public class ConstructorArg_02 {<br>    private boolean isRef;<br>    private Class type;<br>    private Object arg;<br><br>    private ConstructorArg_02(Builder builder) {<br>        this.isRef = builder.isRef;<br>        this.type = builder.type;<br>        this.arg = builder.arg;<br>    }<br><br>    public static class Builder {<br>        private boolean isRef;<br>        private Class type;<br>        private Object arg;<br><br>        &#47;&#47; 后面两个参数依赖isRef，所以isRef设置成必选参数<br>        public Builder(boolean isRef) {<br>            this.isRef = isRef;<br>        }<br><br>        public ConstructorArg_02 build() {<br>            return new ConstructorArg_02(this);<br>        }<br><br>        public Builder setType(Class type) {<br>            this.type = type;<br>            return this;<br>        }<br><br>        public Builder setArg(Object arg) {<br>            &#47;&#47; isRef为true, arg不是String类型就报错<br>            if (isRef &amp;&amp; arg.getClass() != String.class) {<br>                throw new RuntimeException(&quot;参数错误&quot;);<br>            }<br>            this.arg = arg;<br>            return this;<br>        }<br>    }<br>}<br>咱也不知道写的好不好，希望争哥看到了检视指导一二","like_count":0,"discussions":[{"author":{"id":1429627,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJN64OCUT0Jp0h2Wiau9Os0o1WbwUeoq2QL0U2vZpib8ozPxo0XDiaPM9xcKfbkoBL24ztEHelxPIMVg/132","nickname":"Kevin","note":"","ucode":"9DFFD6E3960CF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53922,"discussion_content":"动态一时爽  重构火葬场","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1574235458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1134761,"avatar":"https://static001.geekbang.org/account/avatar/00/11/50/a9/3f8c7418.jpg","nickname":"冰糕不冰","note":"","ucode":"B754FE464BA426","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1429627,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJN64OCUT0Jp0h2Wiau9Os0o1WbwUeoq2QL0U2vZpib8ozPxo0XDiaPM9xcKfbkoBL24ztEHelxPIMVg/132","nickname":"Kevin","note":"","ucode":"9DFFD6E3960CF7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54005,"discussion_content":"这跟动态扯不上关系吧","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574250045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53922,"ip_address":""},"score":54005,"extra":""},{"author":{"id":1356120,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b1/58/7d4f968f.jpg","nickname":"plasmatium","note":"","ucode":"1564F6A20186AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1429627,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJN64OCUT0Jp0h2Wiau9Os0o1WbwUeoq2QL0U2vZpib8ozPxo0XDiaPM9xcKfbkoBL24ztEHelxPIMVg/132","nickname":"Kevin","note":"","ucode":"9DFFD6E3960CF7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":68947,"discussion_content":"动态运行时才会报错，go是根本编译不过去","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575247153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53922,"ip_address":""},"score":68947,"extra":""},{"author":{"id":1024294,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","nickname":"null","note":"","ucode":"F9039EFED6B55D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1429627,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJN64OCUT0Jp0h2Wiau9Os0o1WbwUeoq2QL0U2vZpib8ozPxo0XDiaPM9xcKfbkoBL24ztEHelxPIMVg/132","nickname":"Kevin","note":"","ucode":"9DFFD6E3960CF7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":157659,"discussion_content":"有时对实现了哪些接口，压根没有个很直观的结果。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1580486091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53922,"ip_address":""},"score":157659,"extra":""}]},{"author":{"id":1200660,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/14/cb118a61.jpg","nickname":"键舞飞扬","note":"","ucode":"4EC7A8D2E7AC78","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342067,"discussion_content":" 因go不用声明实现了什么接口，当你读别人写的复杂的代码时，你就很难看出类与类之间的关系，你得去对比它们是不是定义了相同结构的方法。可读性与维护性难度大大增加。就为了少定义一个接口？","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1610589664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1298139,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ce/db/bb1821b3.jpg","nickname":"王      慈","note":"","ucode":"EACC3D086674D8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":155954,"discussion_content":"Go这种也存在实现非预期接口的问题, 可能存在隐患. 但总体来讲确实是舒服一些.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580306511,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1519521,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2f/a1/5f32ada6.jpg","nickname":"大姨夫斯基","note":"","ucode":"79989AC4DD36FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54128,"discussion_content":"go我认为是更好的  java在动手前要付出很多努力去规划好整个体系的继承结构 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574261440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1200650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/0a/65976e95.jpg","nickname":"kougazhang","note":"","ucode":"E9AD678FCEC75D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1519521,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2f/a1/5f32ada6.jpg","nickname":"大姨夫斯基","note":"","ucode":"79989AC4DD36FE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":533983,"discussion_content":"不费力气规划更容易腐化","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638057964,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":54128,"ip_address":""},"score":533983,"extra":""}]},{"author":{"id":1079425,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/81/f6229358.jpg","nickname":"fresh meat","note":"","ucode":"6AC5A69F80ECE7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54072,"discussion_content":"显示实现有什么侵入性？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574257284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1466447,"avatar":"https://static001.geekbang.org/account/avatar/00/16/60/4f/db0e62b3.jpg","nickname":"Daiver","note":"","ucode":"9B1A03AFBC79BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1079425,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/81/f6229358.jpg","nickname":"fresh meat","note":"","ucode":"6AC5A69F80ECE7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54073,"discussion_content":"java 你需要 implements 接口","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574257493,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":54072,"ip_address":""},"score":54073,"extra":""},{"author":{"id":1274117,"avatar":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","nickname":"👽","note":"","ucode":"D313AF941B412D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1466447,"avatar":"https://static001.geekbang.org/account/avatar/00/16/60/4f/db0e62b3.jpg","nickname":"Daiver","note":"","ucode":"9B1A03AFBC79BC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58373,"discussion_content":"不可以默认实现么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574672100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":54073,"ip_address":""},"score":58373,"extra":""}]}]},{"had_liked":false,"id":260205,"user_name":"旅途","can_delete":false,"product_type":"c1","uid":1212902,"ip_address":"","ucode":"5022477E8E9441","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","comment_is_top":false,"comment_ctime":1604940827,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604940827","product_id":100039001,"comment_content":"老师,build方式构造类怎么让使用者知道,哪些方法是必须调用的,哪些属性之间有约束关系呢?<br>","like_count":0},{"had_liked":false,"id":253903,"user_name":"加个鸡腿吧","can_delete":false,"product_type":"c1","uid":1322569,"ip_address":"","ucode":"B2FEE53658782C","user_header":"https://static001.geekbang.org/account/avatar/00/14/2e/49/ffe1ac9d.jpg","comment_is_top":false,"comment_ctime":1602941572,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602941572","product_id":100039001,"comment_content":"这是java语言的本身的问题吧！还是kotlin好，方法可以有默认参数","like_count":0},{"had_liked":false,"id":250701,"user_name":"空城。","can_delete":false,"product_type":"c1","uid":2080208,"ip_address":"","ucode":"0F6F110D811C2E","user_header":"https://static001.geekbang.org/account/avatar/00/1f/bd/d0/070824d1.jpg","comment_is_top":false,"comment_ctime":1601198854,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1601198854","product_id":100039001,"comment_content":"public class ConstructorArg {<br>    private boolean isRef;<br>    private Class type;<br>    private Object arg;<br><br>    private ConstructorArg() {<br>    }<br><br>    private ConstructorArg(Builder builder) {<br>        this.isRef = builder.isRef;<br>        this.type = builder.type;<br>        this.arg = builder.arg;<br>    }<br><br>    public static Builder builder() {<br>        return new Builder();<br>    }<br><br>    public static class Builder {<br>        private boolean isRef;<br>        private Class type;<br>        private Object arg;<br><br>        public boolean isRef() {<br>            return isRef;<br>        }<br><br>        public Builder setRef(boolean ref) {<br>            isRef = ref;<br>            return this;<br>        }<br><br>        public Class getType() {<br>            return type;<br>        }<br><br>        public Builder setType(Class type) {<br>            this.type = type;<br>            return this;<br>        }<br><br>        public Object getArg() {<br>            return arg;<br>        }<br><br>        public Builder setArg(Object arg) {<br>            this.arg = arg;<br>            return this;<br>        }<br><br>        public ConstructorArg build() {<br>            if (!isRef) {<br>                if (type == null || arg == null) {<br>                    throw new IllegalArgumentException();<br>                }<br>            } else {<br>                if (arg == null) {<br>                    throw new IllegalArgumentException();<br>                }<br>            }<br><br>            return new ConstructorArg(this);<br>        }<br>    }<br>}","like_count":0},{"had_liked":false,"id":247966,"user_name":"鲁鸣","can_delete":false,"product_type":"c1","uid":2152306,"ip_address":"","ucode":"974BA3C3E64630","user_header":"https://static001.geekbang.org/account/avatar/00/20/d7/72/cbef720d.jpg","comment_is_top":false,"comment_ctime":1599960290,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599960290","product_id":100039001,"comment_content":"属性重复的问题可能让代码会看着有点不舒服","like_count":0},{"had_liked":false,"id":247038,"user_name":"Geek_35cfdd","can_delete":false,"product_type":"c1","uid":1792214,"ip_address":"","ucode":"AD9615ABB4CA25","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoiaP1gptuBzj3AXMpY8yLTIkpuarouOVzLde4636UJ7zAgnOEZibiaAIRVAicFaO64ftH45YOn1pD3VA/132","comment_is_top":false,"comment_ctime":1599566362,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1599566362","product_id":100039001,"comment_content":"文中的例子感觉既可以用建造器模式也可以用工厂模式。工厂模式一不定非要限定于创建不同的类（这些类之间有继承关系）。而且如果不限制对config对象进行二次修改的话，把build里面的校验放在当前对象的set方法中也是ok的（这种就可以不使用任务设计模式）。","like_count":0,"discussions":[{"author":{"id":1712043,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/1f/ab/42fc8571.jpg","nickname":"Little Bird","note":"","ucode":"CF310EF87749DD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578425,"discussion_content":"著名的 VFS(Virtual File System) 也可以看到抽象类 &amp; 接口的影子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656733284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292251,"discussion_content":"那请问接口在这个例子中是如何解耦的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595155708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240678,"user_name":"氵又弓虽","can_delete":false,"product_type":"c1","uid":1605330,"ip_address":"","ucode":"A62F060B02CDD7","user_header":"https://static001.geekbang.org/account/avatar/00/18/7e/d2/be993431.jpg","comment_is_top":false,"comment_ctime":1597032380,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597032380","product_id":100039001,"comment_content":"建造者模式适合场景：构建的对象属性存在：依赖关系（Dependencies）、合法校验（Preconditions）、不可变（Immutable） 需求时。","like_count":0},{"had_liked":false,"id":239103,"user_name":"Morse","can_delete":false,"product_type":"c1","uid":1624157,"ip_address":"","ucode":"B09A716D79AE3B","user_header":"https://static001.geekbang.org/account/avatar/00/18/c8/5d/1e3685e6.jpg","comment_is_top":false,"comment_ctime":1596436448,"is_pvip":false,"replies":[{"id":"89270","content":"那就要用builder模式了","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1597454216,"ip_address":"","comment_id":239103,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1596436448","product_id":100039001,"comment_content":"为什么定义了一个长方形类，如果不使用建造者模式，采用先创建后 set 的方式，那就会导致在第一个 set 之后，对象处于无效状态？求大佬解答","like_count":0,"discussions":[{"author":{"id":1330141,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4b/dd/41614582.jpg","nickname":"HomeyLiu","note":"","ucode":"EF4CCB92C369B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":533913,"discussion_content":"存储也应该用接口,因为支持存本地和云端","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638020693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1438470,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f3/06/8da1bf0c.jpg","nickname":"Fredo","note":"","ucode":"681D6692617DAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":157369,"discussion_content":"支持存本地和云端，是否需要加个策略模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580474724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1325282,"avatar":"https://static001.geekbang.org/account/avatar/00/14/38/e2/28aa8e6c.jpg","nickname":"会玩code","note":"","ucode":"9220B072AF68C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53786,"discussion_content":"你好，请问下这跟直接把接口换成抽象类里的抽象方法不也一样吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574216224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1026280,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/e8/bc84c47d.jpg","nickname":"熊斌","note":"","ucode":"24D0C32F397113","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1325282,"avatar":"https://static001.geekbang.org/account/avatar/00/14/38/e2/28aa8e6c.jpg","nickname":"会玩code","note":"","ucode":"9220B072AF68C7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53803,"discussion_content":"你好，我认为不一样。原因有下\n\n系统范围内十几个业务需要使用附件接口，它们需要三个行为 上传、下载、删除，抽象成接口，是约定了附件接口的使用协议，告诉那些业务功能的实现着，你们都需要按照这样来开发\n\n抽象类中的抽象方法我认为一般写的是对于业务是公共方法、但对于调用方是不必关心的，像Java里面抽象方法一般都是protected的。\n\n总结一下，接口是约定规范的、对调用者是开放的；而抽象类包含接口的部分，又比接口更近一步能写实现，一般把子类重复代码抽象到里面，对外是不可见的。\n\n如果非要做成抽象方法行不行？\n答案是可以的，但不优雅。\n","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1574217963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53786,"ip_address":""},"score":53803,"extra":""}]}]},{"had_liked":false,"id":238405,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1596160349,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1596160349","product_id":100039001,"comment_content":"我们现在解决构造函数参数过多的一个方法就是将所有参数都组装到一个类中去，不过这样的缺点就是无法将必填和可选区分开来","like_count":0,"discussions":[{"author":{"id":2277251,"avatar":"https://static001.geekbang.org/account/avatar/00/22/bf/83/c83be5a3.jpg","nickname":"eHackyd","note":"","ucode":"E6E7994FBDF0A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378725,"discussion_content":"你要从接口和抽象类在java1中的语法去理解它们最原始的意义，java8之后的修改是补充，但并不能作为对概念的理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623374124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335303,"discussion_content":"抽象类可以有不允许重写的方法，接口不可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608164377,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237265,"user_name":"西电","can_delete":false,"product_type":"c1","uid":2063037,"ip_address":"","ucode":"95BD4CE9D93018","user_header":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","comment_is_top":false,"comment_ctime":1595759321,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595759321","product_id":100039001,"comment_content":"用c++实现，但是好像没办法通过new创建对象，各位大佬看一下<br>class ResourcePoolConfig {<br>public:<br>\tclass Builder {<br>\tpublic:<br>\t\tstring name;<br>\t\tint maxTotal = DEFAULT_MAX_TOTAL;<br>\t\tint maxIdle = DEFAULT_MAX_IDLE;<br>\t\tint minIdle = DEFAULT_MIN_IDLE;<br>\t\tBuilder() {\t\t<br>\t\t}<br>\t\tResourcePoolConfig* build() {<br>\t\t\t&#47;&#47;校验逻辑<br>\t\t\tif (name.size() == 0) {<br>\t\t\t\tthrow new invalid_argument(&quot;name null&quot;);<br>\t\t\t}<br>\t\t\tif (maxIdle &gt; maxTotal) {<br>\t\t\t\tthrow new invalid_argument(&quot;maxIdle out&quot;);<br>\t\t\t}<br>\t\t\tif (minIdle &gt; maxIdle || minIdle &gt; maxTotal) {<br>\t\t\t\tthrow new invalid_argument(&quot;minIdle out&quot;);<br>\t\t\t}<br>\t\t\treturn new ResourcePoolConfig(*this);<br>\t\t}<br>\t\tBuilder setName(string name) {<br>\t\t\tthis-&gt;name = name;<br>\t\t\treturn *this;<br>\t\t}<br>\t\tBuilder setMaxTotal(int maxTotal) {<br>\t\t\tthis-&gt;maxIdle = maxTotal;<br>\t\t\treturn *this;<br>\t\t}<br>\t\tBuilder setMaxIdle(int maxIdle) {<br>\t\t\tthis-&gt;maxIdle = maxIdle;<br>\t\t\treturn *this;<br>\t\t}<br>\t\tBuilder setMinIdle(int minIdle) {<br>\t\t\tthis-&gt;minIdle = minIdle;<br>\t\t\treturn *this;<br>\t\t}<br>\tprivate:<br>\t\tconst static int DEFAULT_MAX_TOTAL = 8;<br>\t\tconst static int DEFAULT_MAX_IDLE = 8;<br>\t\tconst static int DEFAULT_MIN_IDLE = 0;<br><br>\t};<br>private:<br>\tstring name;<br>\tint maxTotal;<br>\tint maxIdle;<br>\tint minIdle;<br>\tResourcePoolConfig(Builder builder) {<br>\t\tthis-&gt;name = builder.name;<br>\t\tthis-&gt;maxTotal = builder.maxTotal;<br>\t\tthis-&gt;maxIdle = builder.maxIdle;<br>\t\tthis-&gt;minIdle = builder.minIdle;<br>\t}<br>};<br>&#47;&#47;创建对象<br>ResourcePoolConfig *config =  ResourcePoolConfig::Builder()<br>\t\t.setName(&quot;mysql&quot;)<br>\t\t.setMaxTotal(8)<br>\t\t.setMaxIdle(8)<br>\t\t.setMinIdle(1)<br>\t\t.build();","like_count":0},{"had_liked":false,"id":234209,"user_name":"奔跑的小孩","can_delete":false,"product_type":"c1","uid":1304259,"ip_address":"","ucode":"0053193F7A9870","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/21uTMWr7bx5qMibp2hwmGvLbYuj5Aic2dqD3futlNo25eDGDt4t7zzN9cdnj7cVGwTot1U4AyADfWUpqjq1SicgWQ/132","comment_is_top":false,"comment_ctime":1594620607,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594620607","product_id":100039001,"comment_content":"将的很清晰很到位","like_count":0},{"had_liked":false,"id":231259,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1593617038,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1593617038","product_id":100039001,"comment_content":"建造者多了让调用方传参，并且是2个阶段，build阶段可以做检查","like_count":0},{"had_liked":false,"id":230249,"user_name":"数学汤家凤","can_delete":false,"product_type":"c1","uid":2029485,"ip_address":"","ucode":"DE84E777C384AD","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f7/ad/4fd4d867.jpg","comment_is_top":false,"comment_ctime":1593327272,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1593327272","product_id":100039001,"comment_content":"public class ConstructorArg {<br>    private boolean isRef;<br>    private Class&lt;?&gt; type;<br>    private Object arg; &#47;&#47; TODO: 待完善...<br><br>    private ConstructorArg(Builder builder) {<br>        this.isRef = builder.isRef;<br>        this.type = builder.type;<br>        this.arg = builder.arg;<br>    }<br><br>    public static class Builder {<br>        private boolean isRef;<br>        private Class&lt;?&gt; type;<br>        private Object arg;<br><br>        public ConstructorArg build() {<br>            if (!isRef) {<br>                if (arg == null) throw new IllegalArgumentException(&quot;agr 必填&quot;);<br>                if (type == null) throw new IllegalArgumentException(&quot;type 必填&quot;);<br>            }<br>            return new ConstructorArg(this);<br>        }<br><br>        public Builder setRef(boolean ref) {<br>            if (ref &amp;&amp; (type != null || arg != null)) throw new IllegalArgumentException(&quot;type 与 arg 要为 null&quot;);<br>            this.isRef = ref;<br>            return this;<br>        }<br><br>        public Builder setType(Class&lt;?&gt; type) {<br>            if (isRef) throw new IllegalArgumentException(&quot;isRef 要为 false&quot;);<br>            if (type == null) throw new IllegalArgumentException(&quot;type 必填&quot;);<br>            this.type = type;<br>            return this;<br>        }<br><br>        public Builder setArg(Object arg) {<br>            if (isRef) throw new IllegalArgumentException(&quot;isRef 要为 false&quot;);<br>            if (arg == null) throw new IllegalArgumentException(&quot;arg 必填&quot;);<br>            this.arg = arg;<br>            return this;<br>        }<br>    }<br><br>    @Override<br>    public String toString() {<br>        return &quot;ConstructorArg{&quot; +<br>                &quot;isRef=&quot; + isRef +<br>                &quot;, type=&quot; + type +<br>                &quot;, arg=&quot; + arg +<br>                &#39;}&#39;;<br>    }<br>}<br>","like_count":0},{"had_liked":false,"id":229781,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1593144065,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1593144065","product_id":100039001,"comment_content":"其实只有三个参数，直接用构造函数判断也行。如果非要搞建造者模式，理由也是充足的。<br>class ConstructorArg1 {<br>    private boolean isRef;<br>    private Class type;<br>    private Object arg;<br><br>    public ConstructorArg1(boolean isRef, Class type, Object arg) {<br>        this.isRef = isRef;<br>        this.type = type;<br>        this.arg = arg;<br><br>        if (isRef) {<br>            if (!(arg instanceof String)) {<br>                throw new IllegalArgumentException();<br>            }<br>        } else {<br>            if (arg == null || type == null) {<br>                throw new IllegalArgumentException();<br>            }<br>        }<br>    }<br>}<br><br><br>class ConstructorArg2 {<br>    private boolean isRef;<br>    private Class type;<br>    private Object arg;<br><br>    public ConstructorArg2(Builder builder) {<br>        this.isRef = builder.isRef;<br>        this.type = builder.type;<br>        this.arg = builder.arg;<br>    }<br><br>    static class Builder {<br>        private boolean isRef;<br>        private Class type;<br>        private Object arg;<br><br>        public boolean isRef() {<br>            return isRef;<br>        }<br><br>        public Builder setRef(boolean ref) {<br>            isRef = ref;<br>            return this;<br>        }<br><br>        public Class getType() {<br>            return type;<br>        }<br><br>        public Builder setType(Class type) {<br>            this.type = type;<br>            return this;<br>        }<br><br>        public Object getArg() {<br>            return arg;<br>        }<br><br>        public Builder setArg(Object arg) {<br>            this.arg = arg;<br>            return this;<br>        }<br><br>        public ConstructorArg2 build() {<br>            if (isRef) {<br>                if (!(arg != null &amp;&amp; arg instanceof String)) {<br>                    throw new IllegalArgumentException();<br>                }<br>            } else {<br>                if (arg == null || type == null) {<br>                    throw new IllegalArgumentException();<br>                }<br>            }<br>            return new ConstructorArg2(this);<br>        }<br>    }<br>}","like_count":0},{"had_liked":false,"id":227364,"user_name":"Geek_42f729","can_delete":false,"product_type":"c1","uid":1600341,"ip_address":"","ucode":"76CFFF9DEDDF96","user_header":"https://static001.geekbang.org/account/avatar/00/18/6b/55/2b0f219b.jpg","comment_is_top":false,"comment_ctime":1592364569,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592364569","product_id":100039001,"comment_content":"&#47;**<br>         * 当 isRef 为 true 的时候，arg 表示 String 类型的 refBeanId，type 不需要设置；<br>         *<br>         * 当 isRef 为 false 的时候，arg、type 都需要设置。<br>         *<br>         * 请根据这个需求，完善 ConstructorArg 类。<br>         *&#47;<br>        <br>        public ConstructorArg build () {<br>            Assert.assertNotNull(arg);<br><br>            boolean isString = arg instanceof String;<br>            if (isRef &amp;&amp; isString) {<br>                return new ConstructorArg(this);<br>            }<br><br>            Assert.assertNotNull(type);<br>            return new ConstructorArg(this);<br>        }","like_count":0,"discussions":[{"author":{"id":1619597,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er6OV33jHia3U9LYlZEx2HrpsELeh3KMlqFiaKpSAaaZeBttXRAVvDXUgcufpqJ60bJWGYGNpT7752w/132","nickname":"dog_brother","note":"","ucode":"9F64D3C6D815FB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408341,"discussion_content":"是的，纯虚函数才是所谓的接口","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635230931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225427,"user_name":"宁悦","can_delete":false,"product_type":"c1","uid":1901403,"ip_address":"","ucode":"68844C314FEEF8","user_header":"https://static001.geekbang.org/account/avatar/00/1d/03/5b/3cdbc9fa.jpg","comment_is_top":false,"comment_ctime":1591754596,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591754596","product_id":100039001,"comment_content":" 应用场景：类有多个参数需要创建的时候配置。<br><br>    实现方式1.0：<br>        将所有参数集中在构造函数中，完成类的创建。<br><br>        缺点：构造函数列表过长，可能出现遗漏<br><br><br>    实现方式2.0：<br>        将必要参数放进构造函数中，其他参数通过set方法设置。<br><br>        缺点：必要参数不能过长，都这会出现上面的问题。有依赖关系的时候，，set的无法做逻辑验证。<br><br><br>    实现方式3.0：<br>        用建造者模式构造对象，可以在Build方法内做参数间的关系验证，在set方法内做本参数验证，如是否为空等。<br><br>        缺点：需要额外编写Builder类代码。","like_count":0},{"had_liked":false,"id":221533,"user_name":"漂泊的小飘","can_delete":false,"product_type":"c1","uid":1222578,"ip_address":"","ucode":"25C0CA4887D8AD","user_header":"https://static001.geekbang.org/account/avatar/00/12/a7/b2/274a4192.jpg","comment_is_top":false,"comment_ctime":1590536192,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590536192","product_id":100039001,"comment_content":"工厂模式参数固定 建造者模式不固定","like_count":0},{"had_liked":false,"id":220415,"user_name":"炫炫","can_delete":false,"product_type":"c1","uid":1358609,"ip_address":"","ucode":"FDC7A0C6E08B02","user_header":"https://static001.geekbang.org/account/avatar/00/14/bb/11/7069b8eb.jpg","comment_is_top":false,"comment_ctime":1590238559,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590238559","product_id":100039001,"comment_content":"建造者模式真的简单好用","like_count":0},{"had_liked":false,"id":220101,"user_name":"简单猫","can_delete":false,"product_type":"c1","uid":1866485,"ip_address":"","ucode":"EA027D4C344E25","user_header":"https://static001.geekbang.org/account/avatar/00/1c/7a/f5/54a5084b.jpg","comment_is_top":false,"comment_ctime":1590156806,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590156806","product_id":100039001,"comment_content":"工厂模式为了生产不同的商品(生产不同类)<br>建造者模式是为了同一产品定制不同的风格(同一类 不同参数配置)","like_count":0},{"had_liked":false,"id":216748,"user_name":"worthto","can_delete":false,"product_type":"c1","uid":1387712,"ip_address":"","ucode":"41D7ABBBD2E7FF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/N6yjnrLnMW4XVSkBr3f0N3F962l35b5j0kib9VSlAqqbf6iaoCPicL1WnJ9KjgT4egQ7A2G0Zx3OayaK4yuoZrUVA/132","comment_is_top":false,"comment_ctime":1589335965,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589335965","product_id":100039001,"comment_content":"个人看法，构造者模式方便他人，麻烦自己。其优点不在于建造者模式本身看起来多牛逼或者代码多简洁，而在于调用构造者模式的代码简洁明了，可以使用.setter().settter().settter()...builder() 这种方式。正如文档中提到的，建造者模式解决了三个问题：构造参数过多，构造参数之间存在的依赖关系，参数内部是final的情况，如果类的构建有以上三点要求，就考虑使用建造者模式。","like_count":0},{"had_liked":false,"id":214448,"user_name":"工藤新一","can_delete":false,"product_type":"c1","uid":1754668,"ip_address":"","ucode":"F2AFB6F6A42FAA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLeXjFHy8wGyrDnm6ib7hjZNjocUHarn0XFc8zLc061Ax99bFmrLN9yAxicklpcjKFx2gHqUKWQ3MRw/132","comment_is_top":false,"comment_ctime":1588751265,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1588751265","product_id":100039001,"comment_content":"打卡：<br>其实感觉就是建造者模式，是为了让底层的类创建好了就不能在修改(不能再使用setter);<br>想要创建的时候拥有原子性，但是参数多不想适用构造函数；<br>需要很多校验，可以在build的时候统一校验；<br>链式的构造也比较清晰；<br>","like_count":0,"discussions":[{"author":{"id":2052476,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Qq6oLfOTgKzjiculoUDicdv7WoY1iabPfOTumibWeInVP2Mnod9XVPrNSClvIiaLbvtDlIjRnWUNaXcYwREGzlcaDog/132","nickname":"Geek_在下蟑螂王","note":"","ucode":"E1F5BBB5BC5962","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293339,"discussion_content":"打卡","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595505714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211636,"user_name":"好吗好的","can_delete":false,"product_type":"c1","uid":1103897,"ip_address":"","ucode":"446228B08C8BB2","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/19/18d1df08.jpg","comment_is_top":false,"comment_ctime":1587991541,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587991541","product_id":100039001,"comment_content":"回过头来复习这课的时候觉得，在这个场景下还是构造器更简单清晰一些：<br>public class ConstructorArg {<br>    private boolean isRef;<br>    private Class type;<br>    private Object arg;<br><br>    public ConstructorArg(){<br>    }<br><br>    public ConstructorArg(String arg){<br>        isRef = true;<br>        type = String.class;<br>        arg = arg;<br>    }<br><br>    public ConstructorArg(Object arg,Class type){<br>        isRef = false;<br>        type = type;<br>        arg = arg;<br>    }<br>}","like_count":0},{"had_liked":false,"id":209365,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1587541374,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587541374","product_id":100039001,"comment_content":"<br>&#47;**在下面的 ConstructorArg 类中，当 isRef 为 true 的时候，arg 表示 String 类型的 refBeanId，type 不需要设置；当 isRef 为 false 的时候，arg、type 都需要设置。请根据这个需求，完善 ConstructorArg 类。<br> * @author wuzhixin<br> * @version 1.0<br> * @date 2020&#47;4&#47;22 15:04<br> * @desc<br> *&#47;<br>public class ContructorArg {<br>    private boolean isRef;<br>    private Class type;<br>    private Object arg;<br>    <br>    public ContructorArg(Builder builder){<br>        this.arg = builder.arg;<br>        this.type = builder.type;<br>        this.isRef = builder.isRef;<br>    }<br>    public static class Builder{<br>      &#47;&#47;  private Builder builder = new Builder();<br>        private boolean isRef;<br>        private Class type;<br>        private Object arg;<br><br>        public ContructorArg build(){<br>          if(this.isRef){<br>              if(this.arg==null){<br>                  throw new IllegalArgumentException(&quot;arg is not null&quot;);<br>              }<br>              if(!(this.arg instanceof String)){<br>                  throw new IllegalArgumentException(&quot;arg must be string type&quot;);<br>              }<br>          }else{<br>              if(this.arg==null||this.type==null){<br>                  throw new IllegalArgumentException(&quot;arg and type are not null&quot;);<br>              }<br>          }<br>          return new ContructorArg(this);<br>        }<br>        public Builder setRef(boolean ref) {<br>            this.isRef = ref;<br>            return this;<br>        }<br>        public Builder setType(Class type) {<br>            this.type = type;<br>            return this;<br>        }<br>        public Builder setArg(Object arg) {<br>            this.arg = arg;<br>            return this;<br>        }<br>    }<br>}<br>","like_count":0},{"had_liked":false,"id":208918,"user_name":"肖臧","can_delete":false,"product_type":"c1","uid":1047733,"ip_address":"","ucode":"4FAC9FF54DD6A0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/b5/ac717737.jpg","comment_is_top":false,"comment_ctime":1587464742,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587464742","product_id":100039001,"comment_content":"&lt;Effective Java&gt;的第二条规则，可以当个补充阅读资料：<br>https:&#47;&#47;sjsdfg.github.io&#47;effective-java-3rd-chinese&#47;#&#47;notes&#47;02.%20%E5%BD%93%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E8%BF%87%E5%A4%9A%E6%97%B6%E4%BD%BF%E7%94%A8builder%E6%A8%A1%E5%BC%8F","like_count":0},{"had_liked":false,"id":208917,"user_name":"肖臧","can_delete":false,"product_type":"c1","uid":1047733,"ip_address":"","ucode":"4FAC9FF54DD6A0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/b5/ac717737.jpg","comment_is_top":false,"comment_ctime":1587464412,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587464412","product_id":100039001,"comment_content":"一般还会在主类里面写个静态的builder方法，返回builder对象：<br>public static ResourcePoolConfig.Builder builder() {<br>\treturn new Builder();<br>}<br>","like_count":0},{"had_liked":false,"id":204290,"user_name":"FIRE","can_delete":false,"product_type":"c1","uid":1670763,"ip_address":"","ucode":"85861D990FB3AB","user_header":"https://static001.geekbang.org/account/avatar/00/19/7e/6b/36fc4516.jpg","comment_is_top":false,"comment_ctime":1586360367,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586360367","product_id":100039001,"comment_content":"其实就是先给你创建一个默认的对象，把非必填的都给你设置好了。有什么你需要重新设置的你再设置一下覆盖掉。mybatis使用了好多建造者模式","like_count":0},{"had_liked":false,"id":203311,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586169524,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1586169524","product_id":100039001,"comment_content":"设计模式真的牛逼！不懂设计模式，可谓之不懂编码。","like_count":0},{"had_liked":false,"id":203293,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586167690,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1586167690","product_id":100039001,"comment_content":"Product – The product class defines the type of the complex object that is to be generated by the builder pattern.<br>Builder – This abstract base class defines all of the steps that must be taken in order to correctly create a product. Each step is generally abstract as the actual functionality of the builder is carried out in the concrete subclasses. The GetProduct method is used to return the final product. The builder class is often replaced with a simple interface.<br>ConcreteBuilder – There may be any number of concrete builder classes inheriting from Builder. These classes contain the functionality to create a particular complex product.<br>Director – The director class controls the algorithm that generates the final product object. A director object is instantiated and its Construct method is called. The method includes a parameter to capture the specific concrete builder object that is to be used to generate the product. The director then calls methods of the concrete builder in the correct order to generate the product object. On completion of the process, the GetProduct method of the builder object can be used to return the product.","like_count":0},{"had_liked":false,"id":203270,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586164104,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1586164104","product_id":100039001,"comment_content":"Builder is a creational design pattern that lets you construct complex objects step by step. The pattern allows you to produce different types and representations of an object using the same construction code.<br><br>Separate the construction of a complex object from its representation so that the same construction process can create different representations.","like_count":0},{"had_liked":false,"id":203264,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586162761,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1586162761","product_id":100039001,"comment_content":"老师的学习方式属于运用型吧。关于设计模式的讲解，老师是在学员了解设计模式的前提下进行的课程设计，感觉这个偏于应用。因为基本的模式概念并没有介绍，所以，一般人第一次听会一脸懵。哈哈哈","like_count":0},{"had_liked":false,"id":202214,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1585924616,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585924616","product_id":100039001,"comment_content":"课后题目要求创建对象时，根据入参做校验。使用builder对象先持有参数，在执行build()方法的时候，只需要根据isRef值做判断即可。<br><br>这里用build模式完成了复杂的参数校验","like_count":0},{"had_liked":false,"id":201290,"user_name":"布凡","can_delete":false,"product_type":"c1","uid":1202465,"ip_address":"","ucode":"346FCD332F8BFA","user_header":"https://static001.geekbang.org/account/avatar/00/12/59/21/d2efde18.jpg","comment_is_top":false,"comment_ctime":1585746567,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585746567","product_id":100039001,"comment_content":".net Core 中webHostBuilder 类就是建造者模式<br>&#47;&#47;use case<br>var host = new WebHostBuilder()<br>            .UseKestrel()<br>            .UseContentRoot(Directory.GetCurrentDirectory())<br>            .UseIISIntegration()<br>            .UseStartup&lt;Startup&gt;()<br>            .UseApplicationInsights()<br>            .UseUrls(&quot;http:&#47;&#47;*:5000&quot;)<br>            .Build();<br>在这里就是要生成的Http Server的宿主. WebHostBuilder负责建造这个宿主。<br>源码地址：https:&#47;&#47;github.com&#47;dotnet&#47;aspnetcore&#47;blob&#47;f3f9a1cdbcd06b298035b523732b9f45b1408461&#47;src&#47;Hosting&#47;Hosting&#47;src&#47;WebHostBuilder.cs","like_count":0},{"had_liked":false,"id":194966,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1585124843,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1585124843","product_id":100039001,"comment_content":"这句话没有想明白，把必填项校验得逻辑写在set里不可以吗？<br><br>“我们刚刚讲到，name 是必填的，所以，我们把它放到构造函数中，强制创建对象的时候就设置。如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填项也通过 set() 方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了”","like_count":0,"discussions":[{"author":{"id":1010302,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6a/7e/a6af4c00.jpg","nickname":"№修罗★幻影","note":"","ucode":"FF89FB2C584833","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214482,"discussion_content":"如果这个set方法没被调用呢？你怎么触发set里面的检验代码？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585197789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":194276,"user_name":"木木","can_delete":false,"product_type":"c1","uid":1181486,"ip_address":"","ucode":"E82C58AF2604ED","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/2e/878d3c92.jpg","comment_is_top":false,"comment_ctime":1585044902,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585044902","product_id":100039001,"comment_content":"现学现用，项目用到了JwtToken，构建Token的时候就用到了建造者模式，判断了一下token过期时间不能为空，过期时间需要 &gt; 签发时间。","like_count":0},{"had_liked":false,"id":194079,"user_name":"不能忍的地精","can_delete":false,"product_type":"c1","uid":1754913,"ip_address":"","ucode":"66A921C0BC8102","user_header":"","comment_is_top":false,"comment_ctime":1585022657,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585022657","product_id":100039001,"comment_content":"package com.lilike.mndt.util;<br><br>import org.omg.SendingContext.RunTime;<br><br>public class Momo {<br><br><br>    private boolean isRef;<br><br>    private Class type;<br><br>    private Object arg;<br><br>    public boolean isRef() {<br>        return isRef;<br>    }<br><br>    public Class getType() {<br>        return type;<br>    }<br><br>    public Object getArg() {<br>        return arg;<br>    }<br><br>    private Momo(Builder builder) {<br>        this.isRef = builder.isRef;<br>        this.type = builder.type;<br>        this.arg = builder.arg;<br>    }<br><br><br>    private static class Builder {<br><br>        private boolean isRef;<br><br>        private Class type;<br><br>        private Object arg;<br><br>        public Momo builder() {<br>            if (!isRef) {<br>                if (type == null) {<br>                    throw new RuntimeException(&quot;type 不能为空&quot;);<br>                }<br>                if (arg == null) {<br>                    throw new RuntimeException(&quot;arg 不能为空&quot;);<br>                }<br>            }<br><br>            return new Momo(this);<br><br>        }<br><br>        public Builder setIsRef(Boolean isRef) {<br>            this.isRef = isRef;<br>            return this;<br>        }<br><br>        public Builder setType(Class type) {<br>            this.type = type;<br>            return this;<br>        }<br><br>        public Builder setArg(Object arg) {<br>            this.arg = arg;<br>            return this;<br>        }<br><br>    }<br><br>    public static void main(String[] args) {<br><br>        Momo momo = new Momo.Builder().setIsRef(true).builder();<br>        System.out.println(momo);<br><br>        Momo momo2 = new Momo.Builder().setIsRef(false).builder();<br>        System.out.println(momo2);<br><br><br>    }<br><br><br><br>}<br><br>","like_count":0},{"had_liked":false,"id":186023,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1583743612,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583743612","product_id":100039001,"comment_content":"public class ConstructorArg {<br>    private boolean isRef;<br>    private Class type;<br>    private Object arg;<br><br>    private ConstructorArg(Builder builder) {<br>        this.isRef = builder.isRef;<br>        this.type = builder.type;<br>        this.arg = builder.arg;<br>    }<br><br>    @Override<br>    public String toString() {<br>        return &quot;ConstructorArg{&quot; +<br>                &quot;isRef=&quot; + isRef +<br>                &quot;, type=&quot; + type +<br>                &quot;, arg=&quot; + arg +<br>                &#39;}&#39;;<br>    }<br><br>    &#47;**<br>     * 要求<br>     * isRef 为true的时候,arg表示String类型的refBeanld,type不需要设置<br>     * isRef为false的时候,arg和type都需要设置<br>     *&#47;<br>    public static class Builder{<br>        private boolean isRef;<br>        private Class type;<br>        private Object arg;<br><br>        public ConstructorArg build(){<br>            if (isRef){<br>                if (!(arg instanceof String)){<br>                    throw new RuntimeException(&quot;格式不对,检查arg&quot;);<br>                }<br>            }else{<br>                if (arg == null || type == null){<br>                    throw new RuntimeException(&quot;格式不对,检查arg和typr&quot;);<br>                }<br>            }<br>            return new ConstructorArg(this);<br>        }<br><br>        public Builder setIsRef(Boolean isRef){<br>            if (isRef == null){<br>                throw new RuntimeException(&quot;不能传入空的isRef&quot;);<br>            }<br>            this.isRef = isRef;<br>            return this;<br>        }<br><br>        public Builder setType(Class type){<br>            if (type == null){<br>                throw new RuntimeException(&quot;不能传入空的type&quot;);<br>            }<br>            this.type = type;<br>            return this;<br>        }<br><br>        public Builder setArg(Object arg){<br>            if (arg == null){<br>                throw new RuntimeException(&quot;不能传入空的arg&quot;);<br>            }<br>            this.arg = arg;<br>            return this;<br>        }<br>    }<br>}","like_count":0},{"had_liked":false,"id":185489,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1274787,"ip_address":"","ucode":"C233DF1D224EC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","comment_is_top":false,"comment_ctime":1583592191,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1583592191","product_id":100039001,"comment_content":"王争老师，你好！有个问题：<br>1、需要创建的domain是不可变的，虽然使用builder模式完成bean的创建，屏蔽了set方法，更安全，封装性更好；<br>2、但是这个bean还涉及mybatis内增删改查时字段的映射，以及接口字段的映射，我们项目中也不建议使用dto,因为字段基本都是一样的，sonar扫描出来也是大量重复的字段，一个domain就够了；虽然Mybatis mapping文件中数据封装类使用内部类,类似这种parameterType=&quot;com.flc.cityhiking.entity.Feed$Builder&quot;，但是总感觉怪怪的，涉及这种场景，建议用法是咋样的？代码中建议这么用吗？<br>@Mapper<br>public interface FeedMapper {<br>int addFeed(Feed.Builder builder);<br>List&lt;Feed.Builder&gt; queryAllFeeds();<br>}<br><br>我的示例代码如下：<br><br>@RequestMapping(value = &quot;&#47;saveFeed&quot;, method = RequestMethod.POST)<br>public void saveFeed() {<br><br>    Feed.Builder builder = new Feed.Builder()<br>            .setTitle(“test&quot;)<br>            .setContent(&quot;hello&quot;)<br>            .setImageName(&quot;https:&#47;&#47;is2-ssl.mzstatic.com&#47;image&#47;thumb&#47;Purple125&#47;v4&#47;3e&#47;70&#47;ed&#47;3e70edf5-d409-7fcb-2470-dfb2cfe304a0&#47;AppIcon-1x_U007emarketing-85-220-2.png&#47;75x75bb-85.png&quot;)<br>            .setTime(&quot;2020.03.07&quot;)<br>            .setUsername(“michael&quot;);<br>    transactionService.addFeed(builder);<br>}<br><br>@RequestMapping(value = &quot;&#47;AllFeeds&quot;, method = RequestMethod.GET)<br>List&lt;Feed&gt; queryAllFeeds() {<br>    List&lt;Feed.Builder&gt; builders = transactionService.queryAllFeeds();<br>    List&lt;Feed&gt; feedList = builders.stream().map(Feed.Builder::builder).collect(Collectors.toList());<br>    return feedList;<br>}<br><br>&lt;insert id=&quot;addFeed&quot; parameterType=&quot;com.flc.cityhiking.entity.Feed$Builder&quot;&gt;<br>    insert into Feed<br>    (<br>        title,<br>        username,<br>        content,<br>        time,<br>        imageName<br>    )<br>    values<br>    (<br>        #{title},<br>        #{username},<br>        #{content},<br>        #{time},<br>        #{imageName}<br>    )<br>&lt;&#47;insert&gt;<br><br>&lt;select id=&quot;queryAllFeeds&quot; resultType=&quot;com.flc.cityhiking.entity.Feed$Builder&quot;&gt;<br>    SELECT<br>        id,<br>        title,<br>        username,<br>        content,<br>        time,<br>        imageName<br>    FROM Feed<br>&lt;&#47;select&gt;","like_count":0},{"had_liked":false,"id":184601,"user_name":"xzy","can_delete":false,"product_type":"c1","uid":1002095,"ip_address":"","ucode":"1A44368083A19E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","comment_is_top":false,"comment_ctime":1583369893,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583369893","product_id":100039001,"comment_content":"我这里没有用建造者模式，使用了静态工厂方法。静态工厂方法的一个优点是，它们是有名字的，比起构造函数和建造者来说，更易用，生成的客户端代码，更易阅读：<br>public static class ConstructorArg {<br>\t\tprivate boolean isRef;<br>\t\tprivate Class type;<br>\t\tprivate Object arg;<br><br>\t\tprivate ConstructorArg() {<br>\t\t}<br><br>\t\tpublic static ConstructorArg refArg(String className) {<br>\t\t\tif (StringUtils.isBlank(className)) {<br>\t\t\t\tthrow new IllegalArgumentException(&quot;...&quot;);<br>\t\t\t}<br>\t\t\tConstructorArg constructorArg = new ConstructorArg();<br>\t\t\tconstructorArg.isRef = true;<br>\t\t\tconstructorArg.arg = className;<br>\t\t\treturn constructorArg;<br>\t\t}<br><br>\t\tpublic static ConstructorArg nonRefArg(Class type,Object arg) {<br>\t\t\tif (type == null || arg == null) {<br>\t\t\t\tthrow new IllegalArgumentException(&quot;...&quot;);<br>\t\t\t}<br>\t\t\tConstructorArg constructorArg = new ConstructorArg();<br>\t\t\tconstructorArg.isRef = false;<br>\t\t\tconstructorArg.type = type;<br>\t\t\tconstructorArg.arg = arg;<br>\t\t\treturn constructorArg;<br>\t\t}<br><br>\t\tpublic boolean getIsRef() {<br>\t\t\treturn isRef;<br>\t\t}<br><br><br>\t\tpublic Class getType() {<br>\t\t\treturn type;<br>\t\t}<br><br><br>\t\tpublic Object getArg() {<br>\t\t\treturn arg;<br>\t\t}<br>\t}","like_count":0},{"had_liked":false,"id":183488,"user_name":"郭凯强","can_delete":false,"product_type":"c1","uid":1188524,"ip_address":"","ucode":"002F58C3640560","user_header":"https://static001.geekbang.org/account/avatar/00/12/22/ac/fc8e435a.jpg","comment_is_top":false,"comment_ctime":1583050749,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583050749","product_id":100039001,"comment_content":"课后作业：<br>public class ConstructorArg {<br>    private boolean isRef;<br>    private Class type;<br>    private Object arg;<br>    <br>    private ConstructorArg(Builder builder) {<br>    \tthis.isRef = bulider.isRef;<br>    \tthis.type = builder.type;<br>    \tthis.arg = builder.arg;<br>    }<br><br>    public static class Builder {<br>    \tprivate boolean isRef;<br>    \tprivate Class type;<br>    \tprivate Object arg;<br><br>    \tpublic ConstructorArg build() {<br>    \t\tif (isRef &amp;&amp; arg.getClass() != String.class) {<br>    \t\t\tthrow new IllegalArgumentException(&quot;isRef为true，arg需要是string类型&quot;);<br>    \t\t}<br>    \t\tif (!isRef &amp;&amp; (arg == null || type == null)) {<br>    \t\t\tthrow new IllegalArgumentException(&quot;isRef为false，arg和type都不能为空&quot;);<br>    \t\t}<br><br>    \t\treturn new ConstructorArg(this);<br>    \t}<br><br>    \tpublic Builder setIsRef(boolean isRef) {<br>    \t\tthis.isRef = isRef;<br>    \t\treturn this;<br>    \t}<br><br>    \tpublic Builder setType(Class type) {<br>    \t\tthis.type = type;<br>    \t\treturn this;<br>    \t}<br><br>    \tpublic Builder setArg(Object arg) {<br>    \t\tthis.arg = arg;<br>    \t\treturn this;<br>    \t}<br>    }<br> }","like_count":0},{"had_liked":false,"id":183407,"user_name":"小刀","can_delete":false,"product_type":"c1","uid":1351063,"ip_address":"","ucode":"94DF8C45E09E42","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/iaByN5IfYbE9jMtWrtTDXtPEIHeV77KW1p7ZkiasiaGgA50VXaibo4fbp5ib2JkFP3iaIe4AUudLibufkEIofu5euCNHg/132","comment_is_top":false,"comment_ctime":1583034679,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583034679","product_id":100039001,"comment_content":"将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示","like_count":0},{"had_liked":false,"id":182837,"user_name":"goingao","can_delete":false,"product_type":"c1","uid":1076132,"ip_address":"","ucode":"1A6A20B98F0DD7","user_header":"https://static001.geekbang.org/account/avatar/00/10/6b/a4/6ba9d110.jpg","comment_is_top":false,"comment_ctime":1582873655,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1582873655","product_id":100039001,"comment_content":"对象的状态有点搞不清楚。。","like_count":0},{"had_liked":false,"id":182551,"user_name":"💢 星星💢","can_delete":false,"product_type":"c1","uid":1254392,"ip_address":"","ucode":"A402B765222C35","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/f8/24fcccea.jpg","comment_is_top":false,"comment_ctime":1582808207,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582808207","product_id":100039001,"comment_content":"我们平常业务开发，基本上都是使用 MVC框架映射到VO,在beantools.copy一把到entry中.然后进行数据保存，是否必填得逻辑都是由数据库要校验得。其他校验都是在copy之前完成得。想问一下，我们普通业务开发是否也需要用到builder模式呢？就如果有有很多必填逻辑而且字段相互依赖比较严重。我现在很疑惑这个。我以前是不是都做错了。请教一下。。","like_count":0},{"had_liked":false,"id":181228,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1582522570,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582522570","product_id":100039001,"comment_content":"笔记：<br>一、使用场景：<br>1）类的构造函数必填属性很多，通过set设置，没有办法校验必填属性<br>2）如果类的属性之间有一定的依赖关系，构造函数配合set方式，无法进行依赖关系和约束条件校验<br>3）需要创建不可变对象，不能暴露set方法。<br>（前提是需要传递很多的属性，如果属性很少，可以不需要建造者模式）<br>二、实现方式：<br>把构造函数定义为private，定义public static class Builder 内部类，通过Builder 类的set方法设置属性，调用build方法创建对象。<br><br>三、和工厂模式的区别：<br>1）工厂模式：创建不同的同一类型对象（集成同一个父类或是接口的一组子类），由给定的参数来创建哪种类型的对象；<br>2）建造者模式：创建一种类型的复杂对象，通过很多可设置参数，“定制化”的创建对象","like_count":0},{"had_liked":false,"id":180429,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1582279754,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582279754","product_id":100039001,"comment_content":"<br>public class ConstructorArg {<br>    private static final String TAG = &quot;ConstructorArg&quot;;<br><br>    private boolean isRef;<br>    private Class type;<br>    private Object arg;<br><br>    private ConstructorArg(Builder builder){<br>        this.isRef = builder.isRef;<br>        this.type = builder.type;<br>        this.arg = builder.arg;<br>    }<br><br> <br><br>    public static class Builder{<br>        private boolean isRef;<br>        private Class type;<br>        private Object arg;<br><br>        public Builder(boolean isRef){<br>            this.isRef = isRef;<br>        }<br><br>        public Builder setType(Class type){<br>            this.type = type;<br>            return this;<br>        }<br><br>        public Builder setArg(Object arg){<br>            this.arg = arg;<br>            return this;<br>        }<br><br>        public ConstructorArg build(){<br>            checkIsRef(this.isRef);<br>            ConstructorArg arg = new ConstructorArg(this);<br>            return arg;<br>        }<br><br>        &#47;**校验参数*&#47;<br>        private void checkIsRef(boolean isRef){<br>            &#47;**<br>             * 当 isRef 为 true 的时候，arg 表示 String 类型的 refBeanId，type 不需要设置；*&#47;<br>            if (this.isRef == true){<br>                if (this.type != null){<br>                    throw new IllegalArgumentException(&quot;当 isRef 为 true 的时候，type 不需要设置；&quot;);<br>                }<br><br>                if (!(this.arg instanceof String)){<br>                    throw new IllegalArgumentException(&quot;当 isRef 为 true 的时候，arg 表示 String 类型的 refBeanId&quot;);<br>                }<br>            }<br><br>            &#47;**<br>             * 当 isRef 为 false 的时候，arg、type 都需要设置。*&#47;<br>            if (this.isRef == false){<br>                if (this.arg == null){<br>                    throw new IllegalArgumentException(&quot;当 isRef 为 false 的时候，arg需要设置。&quot;);<br>                }<br><br>                if (this.type == null){<br>                    throw new IllegalArgumentException(&quot;当 isRef 为 false 的时候，type 都需要设置。&quot;);<br>                }<br>            }<br>        }<br>    }<br>}","like_count":0},{"had_liked":false,"id":180365,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1582267823,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582267823","product_id":100039001,"comment_content":"感觉建造者模型就是对创建过程的一个封装","like_count":0},{"had_liked":false,"id":180361,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1582267489,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582267489","product_id":100039001,"comment_content":"class builder {<br>      arg;<br>      type;<br>      is_ref;<br>      build_constructor( is_ref, arg, type ) {<br>          this-&gt;isref = is_ref; <br>          if ( is_ref ) {<br>              this-&gt;arg = arg;<br>           } else {<br>                 this-&gt;arg = arg;<br>                 this-&gt;type = type;<br>           }<br>      }<br>public class ConstructorArg {  <br>  private boolean isRef;   <br>  private Class type;    <br>  private Object arg; <br>  public ConstructorArg( builder* p_builder ) {<br>       this-&gt;isRef = p_builder-&gt;is_ref;<br>       this-&gt;arg = p_builder-&gt;arg<br>       this-&gt;type = p_builder-&gt;type;<br>  }<br> }<br>}<br>然后总结如下<br>最本质的东西是<br>工厂模型 根据不同的参数类型 来创建不同类型的对象<br>而建造模型 根据参数的情况在创建对象时对成员变量进行赋值<br>工厂模型 针对的是不同的类型<br>建造者模型针对的是同一个类型不同的构造参数情况<br>本来以为自己看懂了 然后来做思考题的时候却卡了一下 然后给出了伪代码如下","like_count":0},{"had_liked":false,"id":179591,"user_name":"Treasure","can_delete":false,"product_type":"c1","uid":1177602,"ip_address":"","ucode":"4211ECEB347C3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/f8/02/a02d127d.jpg","comment_is_top":false,"comment_ctime":1582035696,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1582035696","product_id":100039001,"comment_content":"如果不使用建造者模式，采用先创建后 set 的方式，那就会导致在第一个 set 之后，对象处于无效状态。<br>------------------------------------------------------------------------<br>为啥对象会处于无效状态，高和宽都用set，那么高和宽就设置好了啊，为何对象会无效？","like_count":0,"discussions":[{"author":{"id":1018370,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","nickname":"Frank","note":"","ucode":"7A488CC6FE15E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54111,"discussion_content":"请问普通类模拟抽象类，如果将构造器私有，子类怎么继承？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574260063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1593289,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","nickname":"编程界的小学生","note":"","ucode":"4A5BE9A5E877FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1018370,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","nickname":"Frank","note":"","ucode":"7A488CC6FE15E7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54125,"discussion_content":"很抱歉，之前没有想到这个，我的回答有误，抱歉了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574260909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":54111,"ip_address":""},"score":54125,"extra":""},{"author":{"id":1018370,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","nickname":"Frank","note":"","ucode":"7A488CC6FE15E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1593289,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","nickname":"编程界的小学生","note":"","ucode":"4A5BE9A5E877FA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54133,"discussion_content":"没事儿~~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574261791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":54125,"ip_address":""},"score":54133,"extra":""}]}]},{"had_liked":false,"id":179445,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1582006540,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582006540","product_id":100039001,"comment_content":"构造者模式是有开销的，在有性能需求，且要构建的对象数量较多的场景。建议用静态方法代替构造者模式。<br><br>构造者模式是好东西，但使用场景要掂量。","like_count":0}]}