{"id":171282,"title":"42 | 跟踪诊断：让应用内存不“泄露”？","content":"<p><strong>课件和Demo地址</strong><br>\n<a href=\"https://gitee.com/geektime-geekbang/geek_netty\">https://gitee.com/geektime-geekbang/geek_netty</a></p>","comments":[{"had_liked":false,"id":156366,"user_name":"Standly","can_delete":false,"product_type":"c3","uid":1181055,"ip_address":"","ucode":"805CC5784D3F76","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/7f/a7df049a.jpg","comment_is_top":false,"comment_ctime":1574862522,"is_pvip":false,"replies":[{"id":60555,"content":"嗯，你总结的挺全面的，其实这块很饶人，像你这样分块看挺好！","user_name":"作者回复","user_name_real":"傅健","uid":1638649,"ctime":1575324779,"ip_address":"","comment_id":156366,"utype":1}],"discussion_count":12,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"看了源码重新理了下思路：\n1. 创建ByteBuf时调用了track0(obj)方法，传入的obj就是创建的ByteBuf对象。\n2. track0(obj)方法内做了2件事\n   a. 创建一个弱引用对象，绑定上面传入的ByteBuf对象和一个全局的弱引用队列refQueue。\n   b. 把这个弱引用对象加入到另一个全局集合allLeaks里面。\n3. ByteBuf对象用完了，正常情况会调用release()方法回收堆外内存，同时release()方法中调用了弱引用对象DefaultResourceLeak的close()方法，从allLeaks集合里面把这个弱引用对象移除。如果开发者忘记调用release()方法，则allLeaks集合里还会存在这个弱引用对象。\n4. 一段时间后，ByteBuf对象被GC回收，此时会触发一个操作：ByteBuf对象所绑定的弱引用对象被加入到refQueue中。\n5.下一次创建ByteBuf时又调用了track0(obj)方法，把refQueue和allLeaks这俩集合一对比，既存在于refQueue（说明ByteBuf用完了且已经被GC回收），又存在于allLeaks（说明没调用release释放内存），表明存在内存泄漏。\n","like_count":26,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476080,"discussion_content":"嗯，你总结的挺全面的，其实这块很饶人，像你这样分块看挺好！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575324779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1786752,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/43/80/b1ae32cd.jpg","nickname":"Kenneth。🌞","note":"","ucode":"299ADF236395CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":594159,"discussion_content":"在第一步可以提及下返回ByteBuf 实际上是SimpleLeakAwareByteBuf， 不然忽略了包装类，找不到实际release入口","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1668839236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1250327,"avatar":"https://static001.geekbang.org/account/avatar/00/13/14/17/8763dced.jpg","nickname":"微微一笑","note":"","ucode":"CFA7ABE81D0B99","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384474,"discussion_content":"比作者讲的清楚！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626608024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1274049,"avatar":"https://static001.geekbang.org/account/avatar/00/13/70/c1/eb005452.jpg","nickname":"bigbaldy","note":"","ucode":"F5192F24F96806","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296950,"discussion_content":"直接在poll refQueue时释放掉堆外内存不就可以了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596712357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1108924,"avatar":"https://static001.geekbang.org/account/avatar/00/10/eb/bc/6ccac4bb.jpg","nickname":"武文文武","note":"","ucode":"5288366646A15B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":262455,"discussion_content":"java自动释放内存，把引用置null不就会被回收了吗？包括堆外内存也一样啊，为何还要调用release呢？请指教下呗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589100705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1181055,"avatar":"https://static001.geekbang.org/account/avatar/00/12/05/7f/a7df049a.jpg","nickname":"Standly","note":"","ucode":"805CC5784D3F76","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1108924,"avatar":"https://static001.geekbang.org/account/avatar/00/10/eb/bc/6ccac4bb.jpg","nickname":"武文文武","note":"","ucode":"5288366646A15B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":262980,"discussion_content":"堆外不会自动回收，gc只回收堆内存吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589159610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":262455,"ip_address":"","group_id":0},"score":262980,"extra":""}]},{"author":{"id":1101615,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/2f/4f89f22a.jpg","nickname":"李鑫磊","note":"","ucode":"D06517CFCEEE00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":188015,"discussion_content":"内存泄漏不是指的有强引用指向内存，导致内存无法被 GC，ByteBuf 对象的内存既然已经被 GC 了，为什么还说发生了内存泄漏呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582788264,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1181055,"avatar":"https://static001.geekbang.org/account/avatar/00/12/05/7f/a7df049a.jpg","nickname":"Standly","note":"","ucode":"805CC5784D3F76","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1101615,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/2f/4f89f22a.jpg","nickname":"李鑫磊","note":"","ucode":"D06517CFCEEE00","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223959,"discussion_content":"不是bytebuf对象本身，是bytebuf关联的直接内存。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586264133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":188015,"ip_address":"","group_id":0},"score":223959,"extra":""}]},{"author":{"id":1101615,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/2f/4f89f22a.jpg","nickname":"李鑫磊","note":"","ucode":"D06517CFCEEE00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":188010,"discussion_content":"弱引用对象加入到 refQueue 中，说明 ByteBuf 对象被 GC 了呀，被 GC 了不就意味着内存释放了吗？内存释放了为什么还说内存泄漏了呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582787933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1214499,"avatar":"https://static001.geekbang.org/account/avatar/00/12/88/23/a0966b4d.jpg","nickname":"Tim Zhang","note":"","ucode":"4956AC5FE45EE1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1101615,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/2f/4f89f22a.jpg","nickname":"李鑫磊","note":"","ucode":"D06517CFCEEE00","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":202103,"discussion_content":"同样疑惑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583858009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":188010,"ip_address":"","group_id":0},"score":202103,"extra":""},{"author":{"id":1274049,"avatar":"https://static001.geekbang.org/account/avatar/00/13/70/c1/eb005452.jpg","nickname":"bigbaldy","note":"","ucode":"F5192F24F96806","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1101615,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/2f/4f89f22a.jpg","nickname":"李鑫磊","note":"","ucode":"D06517CFCEEE00","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296951,"discussion_content":"只是ByteBuf的堆内内存释放了，堆外并没有","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596712397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":188010,"ip_address":"","group_id":0},"score":296951,"extra":""},{"author":{"id":1155616,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a2/20/7549ff2b.jpg","nickname":"flying eagle","note":"","ucode":"1020359D893C04","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1101615,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/2f/4f89f22a.jpg","nickname":"李鑫磊","note":"","ucode":"D06517CFCEEE00","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549257,"discussion_content":"同样疑惑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643788492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":188010,"ip_address":"","group_id":0},"score":549257,"extra":""}]}]},{"had_liked":false,"id":157120,"user_name":"zpzeng","can_delete":false,"product_type":"c3","uid":1697579,"ip_address":"","ucode":"BC53D95766FE7C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epOLt1slWbKAtNR9yjAfvrM73hlOQpe2Zzptah7jN3relYAhDudicALnysGfAPL0RjVdzhS7Y2Kbmg/132","comment_is_top":false,"comment_ctime":1575037140,"is_pvip":false,"replies":[{"id":62164,"content":"这里你抓住几个关键点：\n1 GC的时候，堆内引用不可达了，所以才被回收了，所以错失了主动释放的机会；\n2 弱引用对象的回收就和普通对象一样，所以开始加到list后，假设没有释放，会在list里面，所以有人指向它，所以它不会被回收掉。所以后面refQueue才能拿出对象看看在不在list里面。","user_name":"作者回复","user_name_real":"stroller","uid":1638649,"ctime":1576743921,"ip_address":"","comment_id":157120,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师，针对这个检测有几个问题想不明白，弱引用对象指向的是谁，是堆外内存，还是持有堆外内存的堆内对象？GC的时候，弱引用对象不是应该被回收掉吗，那么弱引用队列 allLeak里还有对象能和refQueue做对比吗？堆外内存的释放是个什么概念，是没有被堆内对象持有，还是有个位置存储内存块的可分配状态？\n我能假设的一个相对合理的解释是：弱引用指向的是堆内对象，GC的时候堆内对象不引用堆外内存，但没有显式的释放，此时这个对象被回收了，然后这个对象的弱引用被记录到refQueue中，然后某个时间出发refQueue 和allLeak的对比，发现有堆外内存没有被释放。但是这样就有“C的时候，弱引用对象不是应该被回收掉吗，那么弱引用队列 allLeak里还有对象能和refQueue做对比吗？” 的问题。\n麻烦老师解答一下","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476333,"discussion_content":"这里你抓住几个关键点：\n1 GC的时候，堆内引用不可达了，所以才被回收了，所以错失了主动释放的机会；\n2 弱引用对象的回收就和普通对象一样，所以开始加到list后，假设没有释放，会在list里面，所以有人指向它，所以它不会被回收掉。所以后面refQueue才能拿出对象看看在不在list里面。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576743921,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156888,"user_name":"鱼向北游","can_delete":false,"product_type":"c3","uid":1439908,"ip_address":"","ucode":"580EC7DCE57E9A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/IPdZZXuHVMibwfZWmm7NiawzeEFGsaRoWjhuN99iaoj5amcRkiaOePo6rH1KJ3jictmNlic4OibkF4I20vOGfwDqcBxfA/132","comment_is_top":false,"comment_ctime":1574992228,"is_pvip":false,"replies":[{"id":61373,"content":"谢谢提醒，最早是linked list.现在是set.不知道以后变成什么，不同版本都不一样都，以后也不知道变成什么，不过大体思路都是一样的:判断集合里有没有这个对象来判断gc后的对象引用计数有没有到0。","user_name":"作者回复","user_name_real":"stroller","uid":1638649,"ctime":1576091597,"ip_address":"","comment_id":156888,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"allleaks为了做快速查找那个应该是个set一类的吧 但是大家都叫他链表","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476263,"discussion_content":"谢谢提醒，最早是linked list.现在是set.不知道以后变成什么，不同版本都不一样都，以后也不知道变成什么，不过大体思路都是一样的:判断集合里有没有这个对象来判断gc后的对象引用计数有没有到0。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576091597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182432,"user_name":"李鑫磊","can_delete":false,"product_type":"c3","uid":1101615,"ip_address":"","ucode":"D06517CFCEEE00","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/2f/4f89f22a.jpg","comment_is_top":false,"comment_ctime":1582787592,"is_pvip":false,"replies":null,"discussion_count":6,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"buffer.release() 和 GC 有什么区别吗？不都是内存被释放了？弱引用指向的对象被 GC 掉了，空间不就被释放了，然后弱引用进入 ReferenceQueue，内存不是被释放掉了吗？怎么还说是内存泄漏了呢？","like_count":2,"discussions":[{"author":{"id":1793475,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/5d/c3/69019d24.jpg","nickname":"江东","note":"","ucode":"391A62BC7039B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542270,"discussion_content":"感觉是和netty内部池化内存管理方式有关","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640696835,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1200971,"avatar":"https://static001.geekbang.org/account/avatar/00/12/53/4b/28991f30.jpg","nickname":"Alpha 👀","note":"","ucode":"3C0BAD36550718","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337535,"discussion_content":"我理解虽然是GC回收了内存，但是并不是因为程序主动release释放的，GC很有可能就是我们只申请空间不主动释放，内存泄漏才造成的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608965026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1212750,"avatar":"https://static001.geekbang.org/account/avatar/00/12/81/4e/d71092f4.jpg","nickname":"夏目","note":"","ucode":"67C075A01CF4D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273250,"discussion_content":"弱引用对象是只要发生GC就会被回收。但是实际上使用的ByteBuf的引用(强引用)只要存在内存空间就不会被回收，release()会释放内存同时将弱应用从集合移除，这样的话只要GC后发现ReferenceQueue中弱引用不存在于集合中即说明调用了release()方法，释放了内存。反之如果存在于集合中则说明没有调用release()释放内存，那么则会发生内存泄露。不知道我这样讲你理解吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590421309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1066928,"avatar":"https://static001.geekbang.org/account/avatar/00/10/47/b0/a9b77a1e.jpg","nickname":"冬风向左吹","note":"","ucode":"376C45C5134F93","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1212750,"avatar":"https://static001.geekbang.org/account/avatar/00/12/81/4e/d71092f4.jpg","nickname":"夏目","note":"","ucode":"67C075A01CF4D2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538018,"discussion_content":"都已经gc了，资源都已经释放了，为啥还要关心那个集合里面有没有引用呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639300935,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":273250,"ip_address":"","group_id":0},"score":538018,"extra":""},{"author":{"id":1786752,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/43/80/b1ae32cd.jpg","nickname":"Kenneth。🌞","note":"","ucode":"299ADF236395CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1066928,"avatar":"https://static001.geekbang.org/account/avatar/00/10/47/b0/a9b77a1e.jpg","nickname":"冬风向左吹","note":"","ucode":"376C45C5134F93","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":594160,"discussion_content":"如果不了解它bytebuf 释放逻辑，代码换为Pool 化实现在生产就会出现问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1668839369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":538018,"ip_address":"上海","group_id":0},"score":594160,"extra":""}]},{"author":{"id":1883035,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/bb/9b/d649f756.jpg","nickname":"月夜枫","note":"","ucode":"A153D482576782","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":200270,"discussion_content":"同问！请老师回答一下吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583673355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178245,"user_name":"黄海峰","can_delete":false,"product_type":"c3","uid":1275357,"ip_address":"","ucode":"E9340719BC96B2","user_header":"https://static001.geekbang.org/account/avatar/00/13/75/dd/9ead6e69.jpg","comment_is_top":false,"comment_ctime":1581641311,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"先问问ByteBuf的引用计数在哪里什么时候加减一","like_count":1},{"had_liked":false,"id":178190,"user_name":"suke","can_delete":false,"product_type":"c3","uid":1007753,"ip_address":"","ucode":"C0287C31A4F45B","user_header":"","comment_is_top":false,"comment_ctime":1581604284,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师有个问题想问一下,netty参数指定使用池化内存也就是堆内内存以后,即使ctx.alloc().buffer() 申请了内存以后,没有释放,这个内存无论怎么样,都在内存池里,永远不可能被gc吧?如果不会被gc,岂不是永远检测不到内存泄漏?","like_count":1},{"had_liked":false,"id":328381,"user_name":"江东","can_delete":false,"product_type":"c3","uid":1793475,"ip_address":"","ucode":"391A62BC7039B3","user_header":"https://static001.geekbang.org/account/avatar/00/1b/5d/c3/69019d24.jpg","comment_is_top":false,"comment_ctime":1640696713,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"检测内存是否泄露是和netty池化管理内存有关吗","like_count":0},{"had_liked":false,"id":295963,"user_name":"Geek_5aec96","can_delete":false,"product_type":"c3","uid":2591874,"ip_address":"","ucode":"45345D53041E42","user_header":"","comment_is_top":false,"comment_ctime":1622684078,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师 你好 可以讲解一下它这个内存分配算法么","like_count":0},{"had_liked":false,"id":280357,"user_name":"Geek_1cc6d1","can_delete":false,"product_type":"c3","uid":1850248,"ip_address":"","ucode":"3E083616DD0742","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erZCyXaP2gbxwFHxvtnyaaF2Pyy5KkSMsk9kh7SJl8icp1CD6wicb6VJibiblGibbpDo6IuHrdST6AnWQg/132","comment_is_top":false,"comment_ctime":1614166791,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"byteBuf = ctx.allocate().buffer();  这个局部局部变量怎么会发生内存泄漏呢？方法执行完了，byteBuf 不就自动回收了么？它指向的内存，也会被自动回收。 这里的泄漏是指没有立即回收还是一直不会被回收？","like_count":0},{"had_liked":false,"id":214864,"user_name":"心浮天空","can_delete":false,"product_type":"c3","uid":1051609,"ip_address":"","ucode":"3B2D0E6CC51EE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/0b/d9/3328dd12.jpg","comment_is_top":false,"comment_ctime":1588837149,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师你好，在看ResourceLeakDelector相关源码时发现，在使用ByteBufAlloctor分配内存空间时(ctx.alloc)，会自动添加内存泄露检测(根据检测等级决定是否追踪检测)，是不是在开发过程中是否应该尽量使用Allocator分配内存，并且避免直接使用 ByteBuf，最佳实践是什么？希望老师解答。","like_count":0,"discussions":[{"author":{"id":1155616,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a2/20/7549ff2b.jpg","nickname":"flying eagle","note":"","ucode":"1020359D893C04","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549258,"discussion_content":"如何直接使用 buyeBuf 呢？不还是得通过 ctx.alloc创建","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643788646,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182439,"user_name":"李鑫磊","can_delete":false,"product_type":"c3","uid":1101615,"ip_address":"","ucode":"D06517CFCEEE00","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/2f/4f89f22a.jpg","comment_is_top":false,"comment_ctime":1582788270,"is_pvip":false,"replies":null,"discussion_count":2,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"弱引用对象加入到 refQueue 中，说明 ByteBuf 对象被 GC 了呀，被 GC 了不就意味着内存释放了吗？内存释放了为什么还说内存泄漏了呢？","like_count":0,"discussions":[{"author":{"id":1155616,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a2/20/7549ff2b.jpg","nickname":"flying eagle","note":"","ucode":"1020359D893C04","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549260,"discussion_content":"堆内对象指向堆外内存，在没有正确调用 release 的情况下，只是堆内对象被释放，但是堆外内存还是 &#34; 使用 &#34; 中，这个 ByteBuf 指向了堆外的内存空间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643788767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1556708,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKYLPAlGUWic4yAqsGtEYBSRR7gDjyg9yiaJicNhMwiaNw4rMKQ5DHTfp7gmic0gpqEwCZaou8G6CdHKCg/132","nickname":"ant","note":"","ucode":"A39A03AF257471","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303026,"discussion_content":"建议你再看一遍视频梳理一下逻辑，你应该是没理解老师的意思。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599117225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181725,"user_name":"suke","can_delete":false,"product_type":"c3","uid":1007753,"ip_address":"","ucode":"C0287C31A4F45B","user_header":"","comment_is_top":false,"comment_ctime":1582624690,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"老师遇到过引用计数提前释放的问题么io.netty.util.IllegalReferenceCountException: refCnt: 0, increment: 1 ，我现在的问题是已经确定内存被提前释放了 但是我后面的handler还需要用，有没有什么好的方法可以排查出来到底是哪里提前释放了","like_count":0},{"had_liked":false,"id":178608,"user_name":"密码123456","can_delete":false,"product_type":"c3","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1581758731,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100036701,"comment_content":" DefaultResourceLeak ref = (DefaultResourceLeak) refQueue.poll();\n           if (ref == null) {\n                break;\n            }\n\n            &#47;&#47;判断有没有泄露的关键\n            if (!ref.dispose()) {\n                continue;\n            }\n这段代码，假如所有的bytebuf都没有释放，那么说是不是就永远都检测不到，内存泄漏？","like_count":0},{"had_liked":false,"id":178598,"user_name":"密码123456","can_delete":false,"product_type":"c3","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1581755671,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"写了一个若引用的例子，代码如下：\nObject s=new Object();\nReferenceQueue&lt;Object&gt; rq=new ReferenceQueue&lt;&gt;();\nWeakReference  re=new WeakReference(s, rq);\ns=null;\nSystem.gc();\n&#47;&#47;System.out.println(&quot;====&quot;);\nObject obj= rq.poll();\nSystem.out.println(obj);\n为什么我把注释放开，就可以获取到。不放开注释就获取不到释放的对象呢？\n","like_count":0}]}