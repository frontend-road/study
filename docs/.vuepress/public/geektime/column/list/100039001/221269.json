{"id":221269,"title":"67 | 迭代器模式（下）：如何设计实现一个支持“快照”功能的iterator？","content":"<p>上两节课，我们学习了迭代器模式的原理、实现，并且分析了在遍历集合的同时增删集合元素，产生不可预期结果的原因以及应对策略。</p><p>今天，我们再来看这样一个问题：如何实现一个支持“快照”功能的迭代器？这个问题算是对上一节课内容的延伸思考，为的是帮你加深对迭代器模式的理解，也是对你分析、解决问题的一种锻炼。你可以把它当作一个面试题或者练习题，在看我的讲解之前，先试一试自己能否顺利回答上来。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>问题描述</h2><p>我们先来介绍一下问题的背景：如何实现一个支持“快照”功能的迭代器模式？</p><p>理解这个问题最关键的是理解“快照”两个字。所谓“快照”，指我们为容器创建迭代器的时候，相当于给容器拍了一张快照（Snapshot）。之后即便我们增删容器中的元素，快照中的元素并不会做相应的改动。而迭代器遍历的对象是快照而非容器，这样就避免了在使用迭代器遍历的过程中，增删容器中的元素，导致的不可预期的结果或者报错。</p><p>接下来，我举一个例子来解释一下上面这段话。具体的代码如下所示。容器list中初始存储了3、8、2三个元素。尽管在创建迭代器iter1之后，容器list删除了元素3，只剩下8、2两个元素，但是，通过iter1遍历的对象是快照，而非容器list本身。所以，遍历的结果仍然是3、8、2。同理，iter2、iter3也是在各自的快照上遍历，输出的结果如代码中注释所示。</p><!-- [[[read_end]]] --><pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\nlist.add(3);\nlist.add(8);\nlist.add(2);\n\nIterator&lt;Integer&gt; iter1 = list.iterator();//snapshot: 3, 8, 2\nlist.remove(new Integer(2));//list：3, 8\nIterator&lt;Integer&gt; iter2 = list.iterator();//snapshot: 3, 8\nlist.remove(new Integer(3));//list：8\nIterator&lt;Integer&gt; iter3 = list.iterator();//snapshot: 3\n\n// 输出结果：3 8 2\nwhile (iter1.hasNext()) {\n  System.out.print(iter1.next() + &quot; &quot;);\n}\nSystem.out.println();\n\n// 输出结果：3 8\nwhile (iter2.hasNext()) {\n  System.out.print(iter1.next() + &quot; &quot;);\n}\nSystem.out.println();\n\n// 输出结果：8\nwhile (iter3.hasNext()) {\n  System.out.print(iter1.next() + &quot; &quot;);\n}\nSystem.out.println();\n</code></pre><p>如果由你来实现上面的功能，你会如何来做呢？下面是针对这个功能需求的骨架代码，其中包含ArrayList、SnapshotArrayIterator两个类。对于这两个类，我只定义了必须的几个关键接口，完整的代码实现我并没有给出。你可以试着去完善一下，然后再看我下面的讲解。</p><pre><code>public ArrayList&lt;E&gt; implements List&lt;E&gt; {\n  // TODO: 成员变量、私有函数等随便你定义\n  \n  @Override\n  public void add(E obj) {\n    //TODO: 由你来完善\n  }\n  \n  @Override\n  public void remove(E obj) {\n    // TODO: 由你来完善\n  }\n  \n  @Override\n  public Iterator&lt;E&gt; iterator() {\n    return new SnapshotArrayIterator(this);\n  }\n}\n\npublic class SnapshotArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; {\n  // TODO: 成员变量、私有函数等随便你定义\n  \n  @Override\n  public boolean hasNext() {\n    // TODO: 由你来完善\n  }\n  \n  @Override\n  public E next() {//返回当前元素，并且游标后移一位\n    // TODO: 由你来完善\n  }\n}\n</code></pre><h2>解决方案一</h2><p>我们先来看最简单的一种解决办法。在迭代器类中定义一个成员变量snapshot来存储快照。每当创建迭代器的时候，都拷贝一份容器中的元素到快照中，后续的遍历操作都基于这个迭代器自己持有的快照来进行。具体的代码实现如下所示：</p><pre><code>public class SnapshotArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; {\n  private int cursor;\n  private ArrayList&lt;E&gt; snapshot;\n\n  public SnapshotArrayIterator(ArrayList&lt;E&gt; arrayList) {\n    this.cursor = 0;\n    this.snapshot = new ArrayList&lt;&gt;();\n    this.snapshot.addAll(arrayList);\n  }\n\n  @Override\n  public boolean hasNext() {\n    return cursor &lt; snapshot.size();\n  }\n\n  @Override\n  public E next() {\n    E currentItem = snapshot.get(cursor);\n    cursor++;\n    return currentItem;\n  }\n}\n</code></pre><p>这个解决方案虽然简单，但代价也有点高。每次创建迭代器的时候，都要拷贝一份数据到快照中，会增加内存的消耗。如果一个容器同时有多个迭代器在遍历元素，就会导致数据在内存中重复存储多份。不过，庆幸的是，Java中的拷贝属于浅拷贝，也就是说，容器中的对象并非真的拷贝了多份，而只是拷贝了对象的引用而已。关于深拷贝、浅拷贝，我们在<a href=\"https://time.geekbang.org/column/article/200786\">第47讲</a>中有详细的讲解，你可以回过头去再看一下。</p><p>那有没有什么方法，既可以支持快照，又不需要拷贝容器呢？</p><h2>解决方案二</h2><p>我们再来看第二种解决方案。</p><p>我们可以在容器中，为每个元素保存两个时间戳，一个是添加时间戳addTimestamp，一个是删除时间戳delTimestamp。当元素被加入到集合中的时候，我们将addTimestamp设置为当前时间，将delTimestamp设置成最大长整型值（Long.MAX_VALUE）。当元素被删除时，我们将delTimestamp更新为当前时间，表示已经被删除。</p><p>注意，这里只是标记删除，而非真正将它从容器中删除。</p><p>同时，每个迭代器也保存一个迭代器创建时间戳snapshotTimestamp，也就是迭代器对应的快照的创建时间戳。当使用迭代器来遍历容器的时候，只有满足addTimestamp&lt;snapshotTimestamp&lt;delTimestamp的元素，才是属于这个迭代器的快照。</p><p>如果元素的addTimestamp&gt;snapshotTimestamp，说明元素在创建了迭代器之后才加入的，不属于这个迭代器的快照；如果元素的delTimestamp&lt;snapshotTimestamp，说明元素在创建迭代器之前就被删除掉了，也不属于这个迭代器的快照。</p><p>这样就在不拷贝容器的情况下，在容器本身上借助时间戳实现了快照功能。具体的代码实现如下所示。注意，我们没有考虑ArrayList的扩容问题，感兴趣的话，你可以自己完善一下。</p><pre><code>public class ArrayList&lt;E&gt; implements List&lt;E&gt; {\n  private static final int DEFAULT_CAPACITY = 10;\n\n  private int actualSize; //不包含标记删除元素\n  private int totalSize; //包含标记删除元素\n\n  private Object[] elements;\n  private long[] addTimestamps;\n  private long[] delTimestamps;\n\n  public ArrayList() {\n    this.elements = new Object[DEFAULT_CAPACITY];\n    this.addTimestamps = new long[DEFAULT_CAPACITY];\n    this.delTimestamps = new long[DEFAULT_CAPACITY];\n    this.totalSize = 0;\n    this.actualSize = 0;\n  }\n\n  @Override\n  public void add(E obj) {\n    elements[totalSize] = obj;\n    addTimestamps[totalSize] = System.currentTimeMillis();\n    delTimestamps[totalSize] = Long.MAX_VALUE;\n    totalSize++;\n    actualSize++;\n  }\n\n  @Override\n  public void remove(E obj) {\n    for (int i = 0; i &lt; totalSize; ++i) {\n      if (elements[i].equals(obj)) {\n        delTimestamps[i] = System.currentTimeMillis();\n        actualSize--;\n      }\n    }\n  }\n\n  public int actualSize() {\n    return this.actualSize;\n  }\n\n  public int totalSize() {\n    return this.totalSize;\n  }\n\n  public E get(int i) {\n    if (i &gt;= totalSize) {\n      throw new IndexOutOfBoundsException();\n    }\n    return (E)elements[i];\n  }\n\n  public long getAddTimestamp(int i) {\n    if (i &gt;= totalSize) {\n      throw new IndexOutOfBoundsException();\n    }\n    return addTimestamps[i];\n  }\n\n  public long getDelTimestamp(int i) {\n    if (i &gt;= totalSize) {\n      throw new IndexOutOfBoundsException();\n    }\n    return delTimestamps[i];\n  }\n}\n\npublic class SnapshotArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; {\n  private long snapshotTimestamp;\n  private int cursorInAll; // 在整个容器中的下标，而非快照中的下标\n  private int leftCount; // 快照中还有几个元素未被遍历\n  private ArrayList&lt;E&gt; arrayList;\n\n  public SnapshotArrayIterator(ArrayList&lt;E&gt; arrayList) {\n    this.snapshotTimestamp = System.currentTimeMillis();\n    this.cursorInAll = 0;\n    this.leftCount = arrayList.actualSize();;\n    this.arrayList = arrayList;\n\n    justNext(); // 先跳到这个迭代器快照的第一个元素\n  }\n\n  @Override\n  public boolean hasNext() {\n    return this.leftCount &gt;= 0; // 注意是&gt;=, 而非&gt;\n  }\n\n  @Override\n  public E next() {\n    E currentItem = arrayList.get(cursorInAll);\n    justNext();\n    return currentItem;\n  }\n\n  private void justNext() {\n    while (cursorInAll &lt; arrayList.totalSize()) {\n      long addTimestamp = arrayList.getAddTimestamp(cursorInAll);\n      long delTimestamp = arrayList.getDelTimestamp(cursorInAll);\n      if (snapshotTimestamp &gt; addTimestamp &amp;&amp; snapshotTimestamp &lt; delTimestamp) {\n        leftCount--;\n        break;\n      }\n      cursorInAll++;\n    }\n  }\n}\n</code></pre><p>实际上，上面的解决方案相当于解决了一个问题，又引入了另外一个问题。ArrayList底层依赖数组这种数据结构，原本可以支持快速的随机访问，在O(1)时间复杂度内获取下标为i的元素，但现在，删除数据并非真正的删除，只是通过时间戳来标记删除，这就导致无法支持按照下标快速随机访问了。如果你对数组随机访问这块知识点不了解，可以去看我的《数据结构与算法之美》专栏，这里我就不展开讲解了。</p><p>现在，我们来看怎么解决这个问题：让容器既支持快照遍历，又支持随机访问？</p><p>解决的方法也不难，我稍微提示一下。我们可以在ArrayList中存储两个数组。一个支持标记删除的，用来实现快照遍历功能；一个不支持标记删除的（也就是将要删除的数据直接从数组中移除），用来支持随机访问。对应的代码我这里就不给出了，感兴趣的话你可以自己实现一下。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>今天我们讲了如何实现一个支持“快照”功能的迭代器。其实这个问题本身并不是学习的重点，因为在真实的项目开发中，我们几乎不会遇到这样的需求。所以，基于今天的内容我不想做过多的总结。我想和你说一说，为什么我要来讲今天的内容呢？</p><p>实际上，学习本节课的内容，如果你只是从前往后看一遍，看懂就觉得ok了，那收获几乎是零。一个好学习方法是，把它当作一个思考题或者面试题，在看我的讲解之前，自己主动思考如何解决，并且把解决方案用代码实现一遍，然后再来看跟我的讲解有哪些区别。这个过程对你分析问题、解决问题的能力的锻炼，代码设计能力、编码能力的锻炼，才是最有价值的，才是我们这篇文章的意义所在。所谓“知识是死的，能力才是活的”就是这个道理。</p><p>其实，不仅仅是这一节的内容，整个专栏的学习都是这样的。</p><p>在《数据结构与算法之美》专栏中，有同学曾经对我说，他看了很多遍我的专栏，几乎看懂了所有的内容，他觉得都掌握了，但是，在最近第一次面试中，面试官给他出了一个结合实际开发的算法题，他还是没有思路，当时脑子一片放空，问我学完这个专栏之后，要想应付算法面试，还要学哪些东西，有没有推荐的书籍。</p><p>我看了他的面试题之后发现，用我专栏里讲的知识是完全可以解决的，而且，专栏里已经讲过类似的问题，只是换了个业务背景而已。之所以他没法回答上来，还是没有将知识转化成解决问题的能力，因为他只是被动地“看”，从来没有主动地“思考”。<strong>只掌握了知识，没锻炼能力，遇到实际的问题还是没法自己去分析、思考、解决</strong>。</p><p>我给他的建议是，把专栏里的每个开篇问题都当做面试题，自己去思考一下，然后再看解答。这样整个专栏学下来，对能力的锻炼就多了，再遇到算法面试也就不会一点思路都没有了。同理，学习《设计模式之美》这个专栏也应该如此。</p><h2>课堂讨论</h2><p>在今天讲的解决方案二中，删除元素只是被标记删除。被删除的元素即便在没有迭代器使用的情况下，也不会从数组中真正移除，这就会导致不必要的内存占用。针对这个问题，你有进一步优化的方法吗？</p><p>欢迎留言和我分享你的思考。如果有收获，欢迎你把这篇文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"66 | 迭代器模式（中）：遍历集合的同时，为什么不能增删集合元素？","id":219964},"right":{"article_title":"68 | 访问者模式（上）：手把手带你还原访问者模式诞生的思维过程","id":221852}},"comments":[{"had_liked":false,"id":203045,"user_name":"LJK","can_delete":false,"product_type":"c1","uid":1199213,"ip_address":"","ucode":"12B2441099FF1D","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/6d/c20f2d5a.jpg","comment_is_top":false,"comment_ctime":1586127101,"is_pvip":false,"discussion_count":11,"race_medal":0,"score":"362363379965","product_id":100039001,"comment_content":"思考题感觉像是数据库的MVCC？<br>- 容器中维护一个每个迭代器创建时间的列表<br>- 每次有迭代器创建时就在这个列表中加入自己的创建时间<br>- 迭代器迭代完成后将列表中对应时间点删除<br>- 清理容器时，对于容器中每个元素，如果addTime小于这个列表中的最小时间点就可以进行删除","like_count":84,"discussions":[{"author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":81830,"discussion_content":"就是这个理儿","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576286330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2550743,"avatar":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","nickname":"if...else...","note":"","ucode":"D0565908C99695","race_medal":4,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377672,"discussion_content":"cas操作大哥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622770963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2062402,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKOnpl8fRB9r2vED2s8j7Arwbn2K6M6HUBWNjgoqV4uqe94fTGK4WGpOJLeRxXcBXk3dp23eQR0AQ/132","nickname":"吴钩","note":"","ucode":"0EB50E8144BCDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350959,"discussion_content":"我觉得不完全准确。get和increment之间可以被打断的，只是increment是CAS实现的，若检测到并发冲突就重新执行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614082460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1004264,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/52/e8/92a2e66d.jpg","nickname":"第二少","note":"","ucode":"4A09D1E7589F67","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302563,"discussion_content":"『场景需要保证 get 与 increment 中间不插入其他操作，否则函数的正确性无法保证』也说不通，单独的get操作是有的，要按这个说法，也不应该有单独的get操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598956746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1112747,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","nickname":"李小四","note":"","ucode":"2A766BE16B276B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1004264,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/52/e8/92a2e66d.jpg","nickname":"第二少","note":"","ucode":"4A09D1E7589F67","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":308639,"discussion_content":"不明白你认为错误的点在哪里，get是只读的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601016367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":302563,"ip_address":""},"score":308639,"extra":""}]},{"author":{"id":1501505,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e9/41/7cb2cf64.jpg","nickname":"Poppy","note":"","ucode":"AF656A00521037","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":222938,"discussion_content":"赞同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586180996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1397298,"avatar":"https://static001.geekbang.org/account/avatar/00/15/52/32/bb570f48.jpg","nickname":"向往的生活","note":"","ucode":"0E8DB45357820F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":81168,"discussion_content":"说的很有道理呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576228859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":264726,"user_name":"万历十五年","can_delete":false,"product_type":"c1","uid":1122150,"ip_address":"","ucode":"3D8CF5DF847AE8","user_header":"https://static001.geekbang.org/account/avatar/00/11/1f/66/59e0647a.jpg","comment_is_top":false,"comment_ctime":1606617890,"is_pvip":false,"replies":[{"id":"96065","content":"嗯嗯 ������<br>","user_name":"作者回复","comment_id":264726,"uid":"1190123","ip_address":"","utype":1,"ctime":1606700557,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"139045571362","product_id":100039001,"comment_content":"思考题：为迭代器创建虚引用，当迭代器被回收时，清空容器中相应元素。","like_count":33,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477693,"discussion_content":"集中答疑一下吧 课都提前录好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576198161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1162242,"avatar":"https://static001.geekbang.org/account/avatar/00/11/bc/02/3f7a7197.jpg","nickname":"跨江大桥","note":"","ucode":"4629B23F1BB9F0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":415246,"discussion_content":"没有答疑，有加餐","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637037547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2277251,"avatar":"https://static001.geekbang.org/account/avatar/00/22/bf/83/c83be5a3.jpg","nickname":"eHackyd","note":"","ucode":"E6E7994FBDF0A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379088,"discussion_content":"所以他有没集中答疑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623677168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203099,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1586139748,"is_pvip":false,"discussion_count":9,"race_medal":0,"score":"83190518372","product_id":100039001,"comment_content":"在阅读本节代码实现就想到了第二种方案存在类似思考题的问题<br>解决方案可以在合适的时候清理带删除标记的元素。本想使用数据库的多版本控制（MVCC)的方案，把所有的迭代器对象存起来，并添加创建时间。但是冒出一个新问题，数据库事务有commit来表示事务已完成，而迭代器的使用完成无法知晓，还在思考方案中……","like_count":19,"discussions":[{"author":{"id":2028956,"avatar":"","nickname":"勿更改任何信息","note":"","ucode":"575185C69C05A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408711,"discussion_content":"所见略同\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635305772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203256,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1586161680,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"61715703824","product_id":100039001,"comment_content":"课后思考题：类似数组动态扩容和缩容，删除元素时可以比较被删除元素的总数，在被删除元素总数 &lt; 总数的 1&#47;2 时， 进行resize数组，清空被删除的元素，回收空间。","like_count":15,"discussions":[{"author":{"id":1590960,"avatar":"https://static001.geekbang.org/account/avatar/00/18/46/b0/4f45e06e.jpg","nickname":"天雨流芳","note":"","ucode":"81657BA9C900FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213463,"discussion_content":"“通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一‘’ 有道理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585096925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203664,"user_name":"smartjia","can_delete":false,"product_type":"c1","uid":1330509,"ip_address":"","ucode":"704BCDE56251D2","user_header":"https://static001.geekbang.org/account/avatar/00/14/4d/4d/58c2ffa1.jpg","comment_is_top":false,"comment_ctime":1586250203,"is_pvip":false,"discussion_count":9,"race_medal":0,"score":"57420825051","product_id":100039001,"comment_content":"感觉代码有两个小问题，若理解有误，请帮指正：<br><br>问题1. 重复删除同一个元素时，actualSize 应该保持不变。<br>以下是修改后的代码：<br>@Override <br>public void remove(E obj) <br>{<br> for (int i = 0; i &lt; totalSize; ++i) {<br> if (elements[i].equals(obj) &amp;&amp; delTimestamps[i] == Long.MAX_VALUE) { &#47;&#47; 防止重复删除<br> delTimestamps[i] = System.currentTimeMillis(); <br> actualSize--; }<br> } <br>}<br><br>问题2： 遍历完一个元素后需要让 cursorInAll 自增，否则 cursorInAll 一直指向第一个待遍历的元素。同时hasNext() 恒为true， 也需要修改。<br>以下是修改后的代码：<br><br>@Override <br>public E next() { <br> E currentItem = arrayList.get(cursorInAll); <br> cursorInAll++； &#47;&#47;自增，否则 cursorInAll 一直不变<br> justNext(); <br> return currentItem; <br>}<br><br>@Override <br>public boolean hasNext() { <br>      return this.leftCount &gt;= 0; &#47;&#47; 注意是&gt;=, 而非&gt; （ 修改后 leftCount &gt;= 0 恒成立， 总是返回 true）<br>      改为：<br>      return cursorInAll &lt; arrayList.totalSize()；<br>} ","like_count":14,"discussions":[{"author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":81829,"discussion_content":"如果高并发的话，接口隔离的话，分别调用两个函数，是否会产生并发不同步的问题。有涉及到了加锁，加锁就会影响性能。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1576286209,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203515,"user_name":"辉哥","can_delete":false,"product_type":"c1","uid":1236983,"ip_address":"","ucode":"21A65F4EE6CD04","user_header":"","comment_is_top":false,"comment_ctime":1586225148,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"31650996220","product_id":100039001,"comment_content":"课堂讨论：可以创建一个object类型的常量，删除数组元素时，可以将被删除数组元素的引用指向该常量。Android中的SparseArray就是采用此方式实现的","like_count":7,"discussions":[{"author":{"id":1282715,"avatar":"https://static001.geekbang.org/account/avatar/00/13/92/9b/65f98192.jpg","nickname":"Wh1","note":"","ucode":"6D28506B99A285","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":201824,"discussion_content":"关于你的1和2，AtomicInteger其实也给出了相应的get() 和 set() 方法，但AtomicInteger的乘和除我倒是真没看见...\n关于你的3，AtomicInteger是为了保证 &#34;自增 + 返回结果&#34; 这个操作的原子性，AtomicInteger才设立了getAndIncrement()，如果是增加一些其他操作，就无法保证原子性了 。\n至于为什么这个操作是原子的，因为内部通过Unsafe提供的CAS自旋修改内存偏移地址实现的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583842464,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203409,"user_name":"马以","can_delete":false,"product_type":"c1","uid":1344431,"ip_address":"","ucode":"3FEA06CA14DE28","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","comment_is_top":false,"comment_ctime":1586185172,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"27355988948","product_id":100039001,"comment_content":"记录一个迭代变量，每迭代一次，计数加一，迭代完一次减一，当为0的时候就可以删除标记为delete的元素了","like_count":7,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478382,"discussion_content":"不一样呢你再看看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576796900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1632462,"avatar":"https://static001.geekbang.org/account/avatar/00/18/e8/ce/b5576a7f.jpg","nickname":"hotdog5225","note":"","ucode":"3FC53FEDBEE34A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215190,"discussion_content":"我觉得，作者的意思应该是：第一个理解是从实现类的角度来说的，要求实现类实现的接口中不应该有实现类不能实现/或者不需要实现的API。第三个理解是从接口的调用者来说的，调用者不应当依赖自己不需要的接口。（当然在作者的代码中，第三个理解中的代码，也包含了描述第一个理解的代码）。个人理解。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585298451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2286788,"avatar":"https://static001.geekbang.org/account/avatar/00/22/e4/c4/065f8c0c.jpg","nickname":"Tom-TTC","note":"","ucode":"36AB0797D6FD3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325957,"discussion_content":"感觉，第一个说的是api接口，第三个是java的interface类，分别对应文章中举的用户管理和redis等配置的例子。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605489974,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2071327,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/9b/1f/9f3379d3.jpg","nickname":"Geek_7f21d2","note":"","ucode":"12204FDAD951BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302330,"discussion_content":"第一种， 你对外输出的一种能力，客户端可能只使用部分的能力 ，这样不符合接口隔离； 第三种， 你内部开发， 有多种的能力，不同的接口定义各自的能力","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598879864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1448126,"avatar":"https://static001.geekbang.org/account/avatar/00/16/18/be/ad3127e0.jpg","nickname":"慕高迪","note":"","ucode":"EB1CB5EA4E3A90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290533,"discussion_content":"第一种微服务调用都是远程接口调用，如果接口中包含了不需要的内容，那就是违反了接口隔离原则。而第三种OOP中的接口，属于系统内的调用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594526303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1397298,"avatar":"https://static001.geekbang.org/account/avatar/00/15/52/32/bb570f48.jpg","nickname":"向往的生活","note":"","ucode":"0E8DB45357820F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287896,"discussion_content":"我也有同样的感觉 哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593582828,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1053853,"avatar":"https://static001.geekbang.org/account/avatar/00/10/14/9d/19dcdd42.jpg","nickname":"瓜瓜","note":"","ucode":"2E98377E48399E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":277666,"discussion_content":"我想，现在我们就应该这么理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591089573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1817921,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erBJ1vppuwhTibCia7P24TQMz7TiaMId5QQjZuQJGicn4HynQEFGhC0x0wRUO2JlPzVPWK0sGtMwlvBLQ/132","nickname":"Onlyhalo","note":"","ucode":"ABDE0C48BCDD78","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163811,"discussion_content":"我怎么感觉也差不多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581098486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1328354,"avatar":"https://static001.geekbang.org/account/avatar/00/14/44/e2/763526e9.jpg","nickname":"程晓擘","note":"","ucode":"96986D5AE2B96C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":114821,"discussion_content":"我和你有一样的感觉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577977694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203280,"user_name":"子豪sirius","can_delete":false,"product_type":"c1","uid":1117023,"ip_address":"","ucode":"E8D08D2D33E785","user_header":"https://static001.geekbang.org/account/avatar/00/11/0b/5f/2cc4060c.jpg","comment_is_top":false,"comment_ctime":1586165061,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"23061001541","product_id":100039001,"comment_content":"第二个问题，我想可不可用个数组记录当前有多少个迭代器。每调用一次iterrator方法，迭代器加一；有元素删除时，记录这个时间点的迭代器的数量；当迭代器访问到该元素时，减一，减到0，说明不再有删除该元素时间点之前生成的迭代器来访问了，就可以实际删除该元素。","like_count":5},{"had_liked":false,"id":213117,"user_name":"xk_","can_delete":false,"product_type":"c1","uid":1514305,"ip_address":"","ucode":"DFE1AC38EA78A7","user_header":"https://static001.geekbang.org/account/avatar/00/17/1b/41/dbb7d785.jpg","comment_is_top":false,"comment_ctime":1588304962,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"14473206850","product_id":100039001,"comment_content":"课后题：<br>我们可以在集合类中记录每一个迭代器创建时间列表iteratorCreateTimeList。<br><br>在迭代器创建的时候，删除iteratorCreateTimeList[0]之前的被标记删除的元素。<br><br>在迭代器中需要写一个销毁的方法，删掉iteratorCreateTimeList中对应的创建时间，删除iteratorCreateTimeList[0]之前的被标记删除的元素。","like_count":3,"discussions":[{"author":{"id":1385377,"avatar":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","nickname":"何妨","note":"","ucode":"EC3983BFF7992A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":80837,"discussion_content":"补充一下重点:对于api接口，调用者不应该强迫依赖它不需要的接口，可以考虑拆分出来，例如文中用户删除接口。对于函数来说应该只实现单一功能，例如文中 count 函数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576199318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203343,"user_name":"webmin","can_delete":false,"product_type":"c1","uid":1047014,"ip_address":"","ucode":"98B0CA882454E8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/e6/47742988.jpg","comment_is_top":false,"comment_ctime":1586177333,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"14471079221","product_id":100039001,"comment_content":"可以参考GC的算法，弄一个减化版的优化方法：<br>1. 被删除的元素是否还有可能被已经创建的iterator所访问，即被删除的元素还被引用着；（iterator使用完需要有调用关闭动作）<br>2. 被删除的元素达到一定量时，按照删除时间清理掉效早删除的元素，清理掉的最晚的被删除元素的删除时间放置在清理标识字段，iterator迭代时检查清理标识字段，如果iterator创建时间早于清理标识字段中的时间丢出异常；","like_count":3,"discussions":[{"author":{"id":1219438,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","nickname":"蓝魔丶","note":"","ucode":"2AE4359E263558","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281398,"discussion_content":"这个要求是不是需要被删除的元素需要有序？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591718867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1095857,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","nickname":"梦倚栏杆","note":"","ucode":"BDEB97F2822445","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223816,"discussion_content":"🤝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586257100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203051,"user_name":"eason2017","can_delete":false,"product_type":"c1","uid":1009422,"ip_address":"","ucode":"E070BA624FA490","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/0e/c77ad9b1.jpg","comment_is_top":false,"comment_ctime":1586128376,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14471030264","product_id":100039001,"comment_content":"定时清理里面的数据，做一次同步。期间可能会加锁来保证数据的有效性。","like_count":3},{"had_liked":false,"id":210956,"user_name":"桃花河逆流而上","can_delete":false,"product_type":"c1","uid":1464183,"ip_address":"","ucode":"A88A60296743CF","user_header":"https://static001.geekbang.org/account/avatar/00/16/57/77/ad6b2b8b.jpg","comment_is_top":false,"comment_ctime":1587870124,"is_pvip":false,"replies":[{"id":"78924","content":"1. 我再看下<br>2. 可以取纳秒时间，也可以用版本号","user_name":"作者回复","comment_id":210956,"uid":"1190123","ip_address":"","utype":1,"ctime":1588129833,"user_name_real":"王争"}],"discussion_count":3,"race_medal":0,"score":"10177804716","product_id":100039001,"comment_content":"1.代码貌似跑得不对，只有justNext方法自增了cursorInAll，假设第一个元素没有被删除，那么总是cursorInAll总是0；<br>2.时间戳获取有点问题，连续操作获取时间戳很有可能都是一样的，应该将时间戳进行递增操作，防止相等","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493155,"discussion_content":"1. 我再看下\n2. 可以取纳秒时间，也可以用版本号","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588129833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2206073,"avatar":"","nickname":"大虫灬过大江","note":"","ucode":"FBF248F35A35B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377330,"discussion_content":"代码cursorInAll确实没有办法增加上去","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622604180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299881,"discussion_content":"逆流大佬，你这是要逆袭啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597848077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203630,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1586243840,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10176178432","product_id":100039001,"comment_content":"想起来MySQL中的多版本控制，用于实现事物间不同的隔离级别","like_count":2},{"had_liked":false,"id":203304,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1586168546,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10176103138","product_id":100039001,"comment_content":"1.给元素打时间截实现快照，空间成本会比较大。这里其实采用复制状态机一样能起到效果，只是空间成本就变成了时间成本。<br><br>2.至于栏主的课后题，这已经是从实现快照，变成快照操作在多线程可见了。那么当前的实现是不严谨的，并发会有数据不符合预期的情况。<br><br>3.不考虑并发问题，仅看如何释放内存这个问题。复制状态机可以将一段时间的log整合，实现快照往前移动（比如redis）。放在这里也一样，定时对元素做整合，将被删除的元素移除即可。（遗憾的时，基于时间截这种，无法在某个快照（状态），结合log，做往后倒退的操作）","like_count":2,"discussions":[{"author":{"id":1095857,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","nickname":"梦倚栏杆","note":"","ucode":"BDEB97F2822445","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223819,"discussion_content":"赋值状态机是什么意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586257179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1095857,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","nickname":"梦倚栏杆","note":"","ucode":"BDEB97F2822445","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":224334,"discussion_content":"百度就有。一般存储系统都会基于这个做为数据的实现模式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586277699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":223819,"ip_address":""},"score":224334,"extra":""}]}]},{"had_liked":false,"id":203260,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1586162126,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"10176096718","product_id":100039001,"comment_content":"我有个想法，当迭代器创建后，容器元素如果被删除了，则在迭代器创建强引用指向这个容器元素，容器中元素将之前元素的强引用变为弱引用。<br> 当迭代器不再使用后，会被gc掉，从而删除的元素只剩下弱引用了，那下一次gc，这个删除的元素就会被gc掉。","like_count":2,"discussions":[{"author":{"id":1775076,"avatar":"","nickname":"严","note":"","ucode":"9704161D1B317C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":251930,"discussion_content":"数组引用着弱引用，弱引用不会删除吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588126675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181055,"avatar":"https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg","nickname":"z.l","note":"","ucode":"805CC5784D3F76","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":245608,"discussion_content":"我的想法跟你一样，但是感觉还少了点，元素被gc掉之后，数组的长度还是没变，数组中会有很多null元素，还需要另外一种机制来压缩数组大小","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587688914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1100064,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","nickname":"zj","note":"","ucode":"E3329CCF694AC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1181055,"avatar":"https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg","nickname":"z.l","note":"","ucode":"805CC5784D3F76","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":246087,"discussion_content":"可以在容器的add，remove get方法检查是否有null，我看ThreadLocalMap是这样处理的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587726239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":245608,"ip_address":""},"score":246087,"extra":""}]}]},{"had_liked":false,"id":329373,"user_name":"Geek_b71d2c","can_delete":false,"product_type":"c1","uid":2731263,"ip_address":"","ucode":"3E44D6B22E4451","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKB2930aZlw66wLtB5jnTzUBWKP750AKl2f2C7QxoWBzOVxdCh5PEL7viaalYE7bKUdpTYTDAS7iaDg/132","comment_is_top":false,"comment_ctime":1641304551,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5936271847","product_id":100039001,"comment_content":"在方案一中老师说了Java属于浅拷贝，只拷贝容器的引用，那原有容器中的数据发生增删时会同步影响到迭代器中的容器，那这样又如何能实现快照功能呢？","like_count":1},{"had_liked":false,"id":203527,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1586227243,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5881194539","product_id":100039001,"comment_content":"课堂讨论: <br>在调用List#iterator()之前, 删除deltimestamp &lt; 当前时间的元素.","like_count":1},{"had_liked":false,"id":203402,"user_name":"马以","can_delete":false,"product_type":"c1","uid":1344431,"ip_address":"","ucode":"3FEA06CA14DE28","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","comment_is_top":false,"comment_ctime":1586184739,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5881152035","product_id":100039001,"comment_content":"是的，这个是和数据库的事务隔离差不多，老师这里用的是时间戳，我们还可以利用一个自增的序列号来控制，都是一样的；","like_count":1,"discussions":[{"author":{"id":1092169,"avatar":"https://static001.geekbang.org/account/avatar/00/10/aa/49/51790edb.jpg","nickname":"落尘kira","note":"","ucode":"D203B519E43F85","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263921,"discussion_content":"使用版本号的还需要额外维护唯一性（保证每个快照版本要不一致），时间戳相对更轻便一些\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589266249,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203366,"user_name":"Ken张云忠","can_delete":false,"product_type":"c1","uid":1134288,"ip_address":"","ucode":"D0BAC9FC17DE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","comment_is_top":false,"comment_ctime":1586179890,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5881147186","product_id":100039001,"comment_content":"在集合增加一个数组field，专门用来记录引用该元素的迭代器个数，当迭代器个数为0且该元素已经标记为删除元素时才真正的删除元素，当需要迭代器使用者在使用完迭代器后需要显示得调用迭代器注销该元素的函数，对于使用者不太友好了。","like_count":1},{"had_liked":false,"id":203315,"user_name":"筱乐乐哦","can_delete":false,"product_type":"c1","uid":1307611,"ip_address":"","ucode":"AE92539F0419C3","user_header":"https://static001.geekbang.org/account/avatar/00/13/f3/db/5b7a8fd8.jpg","comment_is_top":false,"comment_ctime":1586170341,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5881137637","product_id":100039001,"comment_content":"老师，有个问题：你在文章中说到：让容器既支持快照遍历，又支持随机访问？我们可以在 ArrayList 中存储两个数组。一个支持标记删除的，用来实现快照遍历功能；一个不支持标记删除的（也就是将要删除的数据直接从数组中移除），用来支持随机访问<br>如果是这样操作，那和浅拷贝的那个比较，没发现有优势呀，老师可以说下这块吗","like_count":1,"discussions":[{"author":{"id":1945605,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/b0/05/c9da834e.jpg","nickname":"小人物大希望","note":"","ucode":"8EF313AA26D4B8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263514,"discussion_content":"删除元素的时候重建 支持随机访问 的那个数组（添加元素的时候，直接插入到尾部即可），反正删除的时间复杂度是本身就是O(n)，多一个O(n)的操作还是O(n)。\n这样迭代的时候，就不用浅拷贝了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589209866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1385377,"avatar":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","nickname":"何妨","note":"","ucode":"EC3983BFF7992A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223375,"discussion_content":"多个迭代器遍历的时候是有优势的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586220492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203269,"user_name":"徐凯","can_delete":false,"product_type":"c1","uid":1244991,"ip_address":"","ucode":"12F82BA3649CD5","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/3f/bbb8a88c.jpg","comment_is_top":false,"comment_ctime":1586163671,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5881130967","product_id":100039001,"comment_content":"容器可以放指向元素的指针，当不用时直接将指针释放并置为空","like_count":1},{"had_liked":false,"id":360694,"user_name":"Geek_7e0e83","can_delete":false,"product_type":"c1","uid":2142423,"ip_address":"广东","ucode":"554DEE2AAAE33C","user_header":"","comment_is_top":false,"comment_ctime":1666764624,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666764624","product_id":100039001,"comment_content":"这个思考题 没有想出来思路。先参考了一下 精选的留言 然后再加上自己的理解 提供给大家参考<br><br>1.维护一个迭代器的创建时间戳列表，记录了每一个迭代器创建的时间。迭代器使用完毕后。将时间信息移除。当元素执行删除动作的时候，如果元素的删除时间满足，小于最小的迭代器时间戳列表时间。则当前元素可以删除。意味着没有迭代器使用了这个元素。整个核心的关键在于 元素删除的时间节点是否有迭代器引用此元素。<br><br>2.弱引用<br><br>实际上是在上一步的基础上自动化的解决了迭代器使用完毕之后的主动删除操作。可以将迭代器存储在弱引用对象中，然后建立一个集合存储这些弱引用的迭代器对象。那么当迭代器不再使用的时候，弱引用对象会自动被GC回收。容器执行元素的删除动作(size() 扩容等等会和元素数据有交互的操作的时候)时，只需要遍历弱引用迭代器集合，看当前迭代器对象还存在的迭代器的创建时间 是否大于 删除元素的删除时间 如果大于 就可以删除此元素。因为这代表着这个元素被删除的之后才创建的迭代器。","like_count":0},{"had_liked":false,"id":349420,"user_name":"ZQY","can_delete":false,"product_type":"c1","uid":1213349,"ip_address":"","ucode":"48C681D8E05118","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/a5/9312bc8c.jpg","comment_is_top":false,"comment_ctime":1655962899,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655962899","product_id":100039001,"comment_content":"异曲同工：Leetcode1146-Snapshot Array","like_count":0},{"had_liked":false,"id":345102,"user_name":"🚦注意有车              ༽","can_delete":false,"product_type":"c1","uid":2113645,"ip_address":"","ucode":"F638673227ECB1","user_header":"https://static001.geekbang.org/account/avatar/00/20/40/6d/61caf56b.jpg","comment_is_top":false,"comment_ctime":1652023706,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1652023706","product_id":100039001,"comment_content":"方案二其实保存两份数据，一份实际物理删除，一份逻辑删除，如果数据增加了，莫名的还是会增加内存消耗","like_count":0},{"had_liked":false,"id":337473,"user_name":"Marco","can_delete":false,"product_type":"c1","uid":1397516,"ip_address":"","ucode":"796A4B9D1DE55D","user_header":"https://static001.geekbang.org/account/avatar/00/15/53/0c/b4907516.jpg","comment_is_top":false,"comment_ctime":1646838561,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646838561","product_id":100039001,"comment_content":"创建迭代器的时候可以做一次清理工作，delTimestamp &lt; snapshotTimestamp 的元素其实可以清理掉","like_count":0},{"had_liked":false,"id":323789,"user_name":"MrVito","can_delete":false,"product_type":"c1","uid":1252169,"ip_address":"","ucode":"716FF6F8871706","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/49/ddefc656.jpg","comment_is_top":false,"comment_ctime":1638163096,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638163096","product_id":100039001,"comment_content":"加入一个gc的概念， 被引用的元素+1，被删除元素-1，最后遍历引用为0的元素，删除。","like_count":0},{"had_liked":false,"id":322552,"user_name":"陆一鸣猜不动","can_delete":false,"product_type":"c1","uid":2831163,"ip_address":"","ucode":"68E89A037F9A0C","user_header":"https://static001.geekbang.org/account/avatar/00/2b/33/3b/0b25b622.jpg","comment_is_top":false,"comment_ctime":1637480395,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637480395","product_id":100039001,"comment_content":"不是很明白这一章做快照的目的是什么？是为了解决一个iterator进行了删除操作，而导致另外一个iterator报错么？感觉不定义清楚这个，讨论部分的问题的答案就比较模糊","like_count":0},{"had_liked":false,"id":317753,"user_name":"Kevin⚡️Zhou","can_delete":false,"product_type":"c1","uid":1440772,"ip_address":"","ucode":"C0FC2673705212","user_header":"https://static001.geekbang.org/account/avatar/00/15/fc/04/d83a555e.jpg","comment_is_top":false,"comment_ctime":1634926004,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634926004","product_id":100039001,"comment_content":"public void add(E obj)里面, 难道不应该是<br>addTimestamps[actualSize] = System.currentTimeMillis(); <br>delTimestamps[actualSize] = Long.MAX_VALUE; <br>吗?","like_count":0},{"had_liked":false,"id":317470,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1634805820,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634805820","product_id":100039001,"comment_content":"对文中代码优化后，并增加了扩容机制：<br>本节代码目录：java_parent&#47;zx_jvm&#47;src&#47;main&#47;java&#47;com&#47;zx&#47;design&#47;iterator&#47;demo04_scale<br>git仓库地址：https:&#47;&#47;bitbucket.org&#47;xiaomao016&#47;java_parent&#47;src&#47;master&#47;<br>","like_count":0},{"had_liked":false,"id":311954,"user_name":"茶没喝完","can_delete":false,"product_type":"c1","uid":1644104,"ip_address":"","ucode":"D72D88C42A1258","user_header":"https://static001.geekbang.org/account/avatar/00/19/16/48/09493874.jpg","comment_is_top":false,"comment_ctime":1631549844,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631549844","product_id":100039001,"comment_content":"逻辑删除的元素没有被任何迭代器使用时，如何删除？<br>容器内部维护一个List&lt;WeakReference&gt; iterators保存活跃的迭代器，如果iterators保存的是虚引用，当迭代器没有强引用时，会被回收，iterators的值会为null。<br>所以可以遍历iterators，找到一个最小snapshotTimestamp(如果iterators元素都为null,或者为空)，就去当前时间。元素的deleTimestamp&lt;snapshotTimestamp都可以删除。","like_count":0},{"had_liked":false,"id":307657,"user_name":"额。","can_delete":false,"product_type":"c1","uid":1371888,"ip_address":"","ucode":"99B1942BAEC011","user_header":"https://static001.geekbang.org/account/avatar/00/14/ee/f0/f2577e45.jpg","comment_is_top":false,"comment_ctime":1629192047,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629192047","product_id":100039001,"comment_content":"看这个代码，怎么保证get方法能拿到未被删除的记录？看起来是不行，感觉还是cow的思路更好","like_count":0},{"had_liked":false,"id":300200,"user_name":"青年祭司","can_delete":false,"product_type":"c1","uid":1259156,"ip_address":"","ucode":"C88EDAE3FF09AE","user_header":"https://static001.geekbang.org/account/avatar/00/13/36/94/0b969588.jpg","comment_is_top":false,"comment_ctime":1625044706,"is_pvip":false,"discussion_count":0,"race_medal":5,"score":"1625044706","product_id":100039001,"comment_content":"我们可以在 ArrayList 中存储两个数组。一个支持标记删除的，用来实现快照遍历功能；一个不支持标记删除的（也就是将要删除的数据直接从数组中移除），用来支持随机访问。<br>这样的话，是不是只有最新的迭代器才支持随机访问，而中间快照的迭代器还是不行","like_count":0},{"had_liked":false,"id":289097,"user_name":"布凡","can_delete":false,"product_type":"c1","uid":1202465,"ip_address":"","ucode":"346FCD332F8BFA","user_header":"https://static001.geekbang.org/account/avatar/00/12/59/21/d2efde18.jpg","comment_is_top":false,"comment_ctime":1618874771,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618874771","product_id":100039001,"comment_content":"主动思考","like_count":0},{"had_liked":false,"id":287070,"user_name":"Yeyw","can_delete":false,"product_type":"c1","uid":1463740,"ip_address":"","ucode":"C9D20DB91C3BE5","user_header":"https://static001.geekbang.org/account/avatar/00/16/55/bc/fad0090b.jpg","comment_is_top":false,"comment_ctime":1617765253,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617765253","product_id":100039001,"comment_content":"创建迭代器时注册迭代器的创建时间，当迭代器销毁时判断是否有比自己时间小的迭代器，当迭代器销毁时，清楚相应的注册以及容器中删除时间小于创建时间的数据","like_count":0},{"had_liked":false,"id":275646,"user_name":"子房","can_delete":false,"product_type":"c1","uid":1438860,"ip_address":"","ucode":"CB05938C248BB3","user_header":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","comment_is_top":false,"comment_ctime":1611631138,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611631138","product_id":100039001,"comment_content":"学习了","like_count":0},{"had_liked":false,"id":272357,"user_name":"David","can_delete":false,"product_type":"c1","uid":1021825,"ip_address":"","ucode":"22CBBC13FC97A9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/97/81/e1eaf621.jpg","comment_is_top":false,"comment_ctime":1610069074,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1610069074","product_id":100039001,"comment_content":"迭代的时候使用全量数组<br>随机访问的时候使用正常数组<br>在添加和删除的时候同时操作两个数组","like_count":0},{"had_liked":false,"id":268616,"user_name":"Janet－林","can_delete":false,"product_type":"c1","uid":1093701,"ip_address":"","ucode":"29B4CCE6D6890B","user_header":"https://static001.geekbang.org/account/avatar/00/10/b0/45/8a223c24.jpg","comment_is_top":false,"comment_ctime":1608274215,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608274215","product_id":100039001,"comment_content":"课后思考题，想了一下容器维护迭代器创建时间，迭代器在迭代时判断时间是否直接删除的做法，再对比扩容再触发回收的做法，感觉扩容触发会更好","like_count":0},{"had_liked":false,"id":260360,"user_name":"樱小路依然","can_delete":false,"product_type":"c1","uid":1269957,"ip_address":"","ucode":"DBA9FF68015FE5","user_header":"https://static001.geekbang.org/account/avatar/00/13/60/c5/69286d58.jpg","comment_is_top":false,"comment_ctime":1604991746,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604991746","product_id":100039001,"comment_content":"参考python垃圾回收引用计数法,<br>每个元素增加一个属性, 引用次数<br>每创建一个迭代器,根据时间区间,给对应的元素增加一个引用计数.<br>每当一个迭代器迭代到这个元素之后,减少一个引用计数.<br>创建迭代器时,清理掉引用计数为0,且有逻辑删除时间节点的元素","like_count":0},{"had_liked":false,"id":256400,"user_name":"flyCoder","can_delete":false,"product_type":"c1","uid":1074897,"ip_address":"","ucode":"82FB7B60775978","user_header":"https://static001.geekbang.org/account/avatar/00/10/66/d1/8664c464.jpg","comment_is_top":false,"comment_ctime":1603617609,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1603617609","product_id":100039001,"comment_content":"这个快照的实现方式又给我提供了一些新的思路","like_count":0},{"had_liked":false,"id":251719,"user_name":"小乙哥","can_delete":false,"product_type":"c1","uid":1063308,"ip_address":"","ucode":"C77E79BEA0C325","user_header":"https://static001.geekbang.org/account/avatar/00/10/39/8c/089525aa.jpg","comment_is_top":false,"comment_ctime":1601807303,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601807303","product_id":100039001,"comment_content":"删除的元素引入过期时间的概念，当超过过期时间之后就代表可以物理删除了","like_count":0},{"had_liked":false,"id":247669,"user_name":"任国宁","can_delete":false,"product_type":"c1","uid":1960963,"ip_address":"","ucode":"FE47D8DB5FA4C7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoXoqDLvF3l8OzIwDBVlbgZ2FtbPFoncicFjQPqMFkKqdG5BnRVIxxrN40zUhTkynsd6yLhqqYiblAQ/132","comment_is_top":false,"comment_ctime":1599789646,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599789646","product_id":100039001,"comment_content":"思考题，参考数据库mvcc,是不是可以在集合内部保存所有迭代器对象，只不过用弱引用，等检测到所有弱引用对象都被回收了，就锁定不让创建新的迭代器，然后进行快照的清除","like_count":0},{"had_liked":false,"id":240896,"user_name":"Mew151","can_delete":false,"product_type":"c1","uid":1002201,"ip_address":"","ucode":"D4793F5874F345","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/d9/75dd7cf9.jpg","comment_is_top":false,"comment_ctime":1597112452,"is_pvip":false,"replies":[{"id":"89269","content":"要看这个函数的定义了，文章中对你的疑问（按照下标随机访问）也有点解释，你可以再看下","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1597454177,"ip_address":"","comment_id":240896,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1597112452","product_id":100039001,"comment_content":"方案二中：<br>  public E get(int i) {<br>    if (i &gt;= totalSize) {<br>      throw new IndexOutOfBoundsException();<br>    }<br>    return (E)elements[i];<br>  }<br>这个方法不需要判断第i个元素是不是已删除的吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503587,"discussion_content":"要看这个函数的定义了，文章中对你的疑问（按照下标随机访问）也有点解释，你可以再看下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597454177,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239953,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1596700427,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596700427","product_id":100039001,"comment_content":"类容器用一个静态变量，记录当前最早的创建迭代器的创建时间戳，当迭代器析构时，统一判断下是否可以更新该时间戳，如果可以，意味着被更新的老时间戳和更新后的新时间戳之间标记删除的元素可以安全删除了","like_count":0},{"had_liked":false,"id":238432,"user_name":"Smile @ Life","can_delete":false,"product_type":"c1","uid":1293907,"ip_address":"","ucode":"320EDAD5A8BE56","user_header":"https://static001.geekbang.org/account/avatar/00/13/be/53/eda4b622.jpg","comment_is_top":false,"comment_ctime":1596165426,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596165426","product_id":100039001,"comment_content":"课堂讨论问题就是一个垃圾回收机制的问题，我们可以对数组的使用量设置一个阈值，然后在添加元素的时候，当用量超过这个阈值，执行一次垃圾回收，因为执行垃圾回收的时候要移动数组，此时可能还有很多SnapshotArrayIterator在遍历，此时需要类似stop-the-world的机制，加入一个读写锁，让所有SnapshotArrayIterator暂停遍历，然后清除被标记删除的元素，同时更新每个SnapshotArrayIterator的遍历位置。","like_count":0},{"had_liked":false,"id":232921,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1594169872,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594169872","product_id":100039001,"comment_content":"初步解决的方式是：<br>物理上动态拷贝一份，来存快照；但是占用额外内存。<br>优化后的方法为：<br>删除时使用假删除，逻辑上删除，实际上只是利用标记来标识元素被删除。然后，因为假删除的原因，无法通过下标直接访问，从而做了两个数组，进行映射指定下标的数组。","like_count":0},{"had_liked":false,"id":225347,"user_name":"蓝魔丶","can_delete":false,"product_type":"c1","uid":1219438,"ip_address":"","ucode":"2AE4359E263558","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","comment_is_top":false,"comment_ctime":1591720632,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591720632","product_id":100039001,"comment_content":"课后问题思考：<br>1.如果存在并发的话，是否只能通过加锁检测已经不会被访问到的删除的元素，然后进行删除操作<br>2.如果没有并发问题，可以通过下一次迭代创建的时候清除比创建时间小的元素","like_count":0},{"had_liked":false,"id":221827,"user_name":"马图斯","can_delete":false,"product_type":"c1","uid":1325779,"ip_address":"","ucode":"A78C2C7D7742C1","user_header":"https://static001.geekbang.org/account/avatar/00/14/3a/d3/f30fb4a9.jpg","comment_is_top":false,"comment_ctime":1590597365,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1590597365","product_id":100039001,"comment_content":"没有看到哪里有浅拷贝啊，不是new了一个ArrayList么？哪位能帮忙理解一下？","like_count":0},{"had_liked":false,"id":217903,"user_name":"老杨同志","can_delete":false,"product_type":"c1","uid":1246199,"ip_address":"","ucode":"3F334F0CFD3DE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg","comment_is_top":false,"comment_ctime":1589642347,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589642347","product_id":100039001,"comment_content":"回答一下思考题，有同学提到了mysql的mvcc我也是这个思路，大概的实现方式是，创建迭代器时讲迭代器加入弱引用集合，并记录迭代器创建时间，迭代开始时可以判断未被回收的迭代器如果都是在元素删除后创建的，那么元素就可以真删除了","like_count":0},{"had_liked":false,"id":213224,"user_name":"Yuuuuu","can_delete":false,"product_type":"c1","uid":1233780,"ip_address":"","ucode":"64FD04761D2111","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/74/578b169d.jpg","comment_is_top":false,"comment_ctime":1588335656,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588335656","product_id":100039001,"comment_content":"将iterator的弱引用存储在list中。每次调用add、get、remove方法时，检查弱引用对象是否被回收，如果都被回收则执行清理工作。","like_count":0},{"had_liked":false,"id":209222,"user_name":"Viola","can_delete":false,"product_type":"c1","uid":1528096,"ip_address":"","ucode":"CF8FF5323AE43A","user_header":"","comment_is_top":false,"comment_ctime":1587521189,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587521189","product_id":100039001,"comment_content":"第二种的两个时间戳，跟隔壁林老师讲MYSQL事务的数据可见性，举高低水位的例子有异曲同工之妙哇","like_count":0},{"had_liked":false,"id":208868,"user_name":"嘉一","can_delete":false,"product_type":"c1","uid":1196864,"ip_address":"","ucode":"8D16BD0B75B019","user_header":"https://static001.geekbang.org/account/avatar/00/12/43/40/e7ef18de.jpg","comment_is_top":false,"comment_ctime":1587454213,"is_pvip":false,"replies":[{"id":"78928","content":"可以使用纳秒时间或者版本号","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1588130249,"ip_address":"","comment_id":208868,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587454213","product_id":100039001,"comment_content":"发现一个问题，如果在SnapshotArrayIterator创建前添加了几个数据，那么会不会出现这几个数据的添加时间戳和SnapshotArrayIterator创建的时间戳是一样（因为计算机的时间戳最小是毫秒，而添加数据毕竟是非常快的操作，可能在不到一毫秒的时间就完成了）的导致这几个数据遍历不了？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492655,"discussion_content":"可以使用纳秒时间或者版本号","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588130249,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206593,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1586906130,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1586906130","product_id":100039001,"comment_content":"课堂讨论： 每隔一段时间就清理下，清理的时机：没有迭代器在迭代该数组的时候","like_count":0},{"had_liked":false,"id":206276,"user_name":"88591","can_delete":false,"product_type":"c1","uid":1254656,"ip_address":"","ucode":"04CE3E46455185","user_header":"https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg","comment_is_top":false,"comment_ctime":1586833263,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586833263","product_id":100039001,"comment_content":"只有使用过迭代器才进行逻辑删除，如果没有使用过迭代器就进行物理删除","like_count":0},{"had_liked":false,"id":205231,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1586574765,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586574765","product_id":100039001,"comment_content":"容器维护一个最早迭代器创建时间lastIterator，可以用一个线程定期清理delTime &lt; lastIterator的元素。<br><br>为了提升性能，也可以不用定期扫描。在对集合进行遍历的时候顺带删除","like_count":0},{"had_liked":false,"id":204518,"user_name":"Geek_41d472","can_delete":false,"product_type":"c1","uid":1247965,"ip_address":"","ucode":"DEC2B6329460CF","user_header":"https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg","comment_is_top":false,"comment_ctime":1586415848,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586415848","product_id":100039001,"comment_content":"感觉迭代器模式在工作中没什么应用场景啊","like_count":0},{"had_liked":false,"id":204159,"user_name":"岁月","can_delete":false,"product_type":"c1","uid":1337598,"ip_address":"","ucode":"29A2A2BC3C4FE4","user_header":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","comment_is_top":false,"comment_ctime":1586343465,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586343465","product_id":100039001,"comment_content":"有好多算法题想了很久都没想出来, 很打击信心的呀........而且一般能想出来的解法, 代码都基本能写出来, 而写具体的代码要消耗很多时间, 还是挺难抉择的, 我之前学的数据结构和算法, 就基本把全部涉及到的代码都自己实现一遍.花了好几个月....不过后来还是忘记了..........","like_count":0},{"had_liked":false,"id":204150,"user_name":"岁月","can_delete":false,"product_type":"c1","uid":1337598,"ip_address":"","ucode":"29A2A2BC3C4FE4","user_header":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","comment_is_top":false,"comment_ctime":1586342168,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586342168","product_id":100039001,"comment_content":"思考题<br>在容器类里面使用一个计数, 标记当前迭代器被创建了多少个, 然后在迭代器内存要被释放的时候, 对容器的计数-1, 每次迭代器被创建的时候, 计数+1; 当计数=0的时候, 容器就负责把那个快照数组整个都删除掉","like_count":0},{"had_liked":false,"id":203852,"user_name":"Geek_3b1096","can_delete":false,"product_type":"c1","uid":1549364,"ip_address":"","ucode":"A6BD92B79B3632","user_header":"","comment_is_top":false,"comment_ctime":1586274953,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586274953","product_id":100039001,"comment_content":"改变学习方法","like_count":0},{"had_liked":false,"id":203760,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1586263774,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586263774","product_id":100039001,"comment_content":"设计模式_67: 迭代器模式(下)<br># 作业：<br>当被删除的元素数量占比超过阈值时，进行扫描操作，删除没有任何迭代器使用的元素。<br># 感想：<br>亲手写了一遍，看到文章中用到一些辅助的变量，想去掉这些事实，结果是逻辑比较复杂，bug调了半天才解开，另外，`remove`后，最好手动`Thread.sleep(xxx)`一段时间，否则时间戳会一致。。。<br>","like_count":0},{"had_liked":false,"id":203600,"user_name":"君哥聊技术","can_delete":false,"product_type":"c1","uid":1325816,"ip_address":"","ucode":"2C9A22BCE4C79E","user_header":"https://static001.geekbang.org/account/avatar/00/14/3a/f8/c1a939e7.jpg","comment_is_top":false,"comment_ctime":1586239818,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586239818","product_id":100039001,"comment_content":"对于列表每个元素，维护一个对应的列表A，用来存储在删除之前创建的迭代器，每个迭代器运行完成后，从列表中删除，当列表为空并且这个元素有删除标志时，删除这个元素。","like_count":0},{"had_liked":false,"id":203590,"user_name":"前端西瓜哥","can_delete":false,"product_type":"c1","uid":1248576,"ip_address":"","ucode":"150130C34CD1C1","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/40/f70e5653.jpg","comment_is_top":false,"comment_ctime":1586237882,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586237882","product_id":100039001,"comment_content":"可以参考 Java 中内置的 ArrayList.trimToSize() 方法的思路，自定义一个 removeDelItems 方法，在确保当前所有迭代器都迭代完的情况下，显式调用该方法，移除掉所有 delTimestamp 不为 Long.MAX_VALUE 的数组元素，从而减少内存占用。","like_count":0},{"had_liked":false,"id":203552,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1586231930,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586231930","product_id":100039001,"comment_content":"对于今天给出的方案二中,删除元素只是标记删除,被删除的元素在没有迭代器使用的情况下,也不会数组中真正的移除,导致不必要的占用,如何优化<br>对于这个问题,实现起来并不难,就是修改两个标记集合中对应的时间,修改两个展示用的集合大小,但是难点在于什么时候去调用删除的方法,如何去知道什么时候迭代器没有调用,首先我想到了先去利用一个集合将所有的迭代器保存,在调用删除方法的时候检查这个迭代器数组,只有自己或者没有数组的时候,进行删除,但是带来一个问题,如何知道迭代器结束了呢?编写一个结束方法?这样每次迭代完成都需要调用,是否是太繁琐了?那么,只能考虑让线程结束后自动回收了,那么就是一个弱引用的数组.当然,这并不是最好的方法,因为线程很长,迭代很短,那么我想着,是否可以在每次调用remove的时候,将要remove的元素放在一个集合中,然后每几次添加触发一次gc,清除迭代器,那么接下来的实现就很清晰了,有两种方式,一种是等待所有的迭代器都清空了,在将remove集合中的所有元素批量remove掉,或者是在remove集合中的元素数量到达一定程度的时候,将整个类加上锁,让迭代器和正常的修改都阻塞,然后删除后放开,不过事先更难,我的整体思路就差不多走到这了","like_count":0},{"had_liked":false,"id":203250,"user_name":"Jemmy","can_delete":false,"product_type":"c1","uid":1007330,"ip_address":"","ucode":"A979F4A5210225","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/e2/1fad3052.jpg","comment_is_top":false,"comment_ctime":1586160889,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1586160889","product_id":100039001,"comment_content":"Iterator析构函数中调中ArrayList的清理函数，清理函数并不是每次都清理，设置一个loadFactory，当已删除元素超过这个loadFactory时之行清理","like_count":0},{"had_liked":false,"id":203138,"user_name":"hanazawakana","can_delete":false,"product_type":"c1","uid":1251721,"ip_address":"","ucode":"E0F6FACBFE7D15","user_header":"https://static001.geekbang.org/account/avatar/00/13/19/89/20488013.jpg","comment_is_top":false,"comment_ctime":1586143512,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586143512","product_id":100039001,"comment_content":"迭代器结束循环后，删除快照数据。开始创建列表时，再创建一个新的快照数据","like_count":0},{"had_liked":false,"id":203084,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1586138038,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1586138038","product_id":100039001,"comment_content":"对于课后思考题的基本想法就是真正删除那些已经被标记删除的元素，只有这样才能节省内存占用，主要的问题是什么时候删除元素？因为是快照，那么假设用户在某段时间内是需要这个快照做一些事情的，所以就需要快照保留一段时间，不能立即清理元素，所以可以在方案二的实现中增加快照保存时间的时间戳，然后开个线程定时扫描所有元素的删除时间戳，和这个快照保存时间戳进行对比，当当前时间-元素的删除时间&gt;快照保存时间的时候，就清理掉这个元素。","like_count":0},{"had_liked":false,"id":203079,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1586137519,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586137519","product_id":100039001,"comment_content":"课后思考题：定期进行清除","like_count":0},{"had_liked":false,"id":203069,"user_name":"Lee","can_delete":false,"product_type":"c1","uid":1153239,"ip_address":"","ucode":"459D3303717703","user_header":"https://static001.geekbang.org/account/avatar/00/11/98/d7/7f7a0e6f.jpg","comment_is_top":false,"comment_ctime":1586135789,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1586135789","product_id":100039001,"comment_content":"课后问题可以在构建SnapshotArrayIterator的时候，将ArrayList中删除时间在当前时间之前的已经标注删除的记录清理一次，并不会影响快照实际有效内容。","like_count":0,"discussions":[{"author":{"id":1337598,"avatar":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","nickname":"岁月","note":"","ucode":"29A2A2BC3C4FE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":224984,"discussion_content":"这样会导致先前的迭代器遍历不正确.","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1586342454,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203054,"user_name":"Geek_27a248","can_delete":false,"product_type":"c1","uid":1542778,"ip_address":"","ucode":"6AC3AC42E6EEC9","user_header":"https://static001.geekbang.org/account/avatar/00/17/8a/7a/54003392.jpg","comment_is_top":false,"comment_ctime":1586132624,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586132624","product_id":100039001,"comment_content":"如果有两个数组保存数据，一个有标记时间戳的，一个没有标记时间戳来支持随机访问的，那Arraylist真正的删除数据的方法也是采用的这种吗，这三篇文章看的有点迷糊了，待我从头在慢慢的看来实验一遍。。本篇文章最大的收获是又坚定了我每篇文章都写代码实验一下的决心","like_count":0}]}