{"id":740816,"title":"第 15 章 迭代器(1)","content":"<blockquote>\n<p>漫长的一天结束了。</p>\n<p style=\"text-align: right\">——Phil</p>\n</blockquote>\n<p>&nbsp;</p>\n<p><strong>迭代器</strong>是一个值，它可以生成一系列值，通常用来执行循环操作。Rust 的标准库不仅提供了用于遍历向量、字符串、哈希表和其他集合的迭代器，还提供了“从输入流中产生文本行”“从网络服务器中产生新的入站连接”“从通信通道中其他线程接收的值”等迭代器。当然，你也可以出于自己的目的实现迭代器。Rust 的 <code>for</code> 循环为使用迭代器提供了一种自然的语法，但迭代器本身也提供了一组丰富的方法，比如映射（<code>map</code>）、过滤（<code>filter</code>）、连接（<code>join</code>）、收集（<code>collect</code>）等。</p>\n<p>Rust 的各种迭代器灵活、富有表现力而且高效。考虑以下函数，它会返回前 <code>n</code> 个正整数之和（通常称为<strong>第 <code>n</code> 个三角形数</strong>）：</p>\n<pre class=\"code-rows\"><code>fn triangle(n: i32) -&gt; i32 {\n    let mut sum = 0;\n    for i in 1..=n {\n        sum += i;\n    }\n    sum\n}</code></pre>\n<p>表达式 <code>1..=n</code> 是一个 <code>RangeInclusive&lt;i32&gt;</code> 型的值。而 <code>RangeInclusive&lt;i32&gt;</code> 是一个迭代器，可以生成其起始值到结束值（包括两者）之间的整数，因此你可以将它用作 <code>for</code> 循环的操作数来对从 <code>1</code> 到 <code>n</code> 的值求和。</p>\n<p>但是迭代器还有一个 <code>fold</code> 方法，可以实现完全一样的效果：</p>\n<pre class=\"code-rows\"><code>fn triangle(n: i32) -&gt; i32 {\n    (1..=n).fold(0, |sum, item| sum + item)\n}</code></pre>\n<p>开始运行时以 <code>0</code> 作为总和，<code>fold</code> 会获取 <code>1..=n</code> 生成的每个值，并以总和（<code>sum</code>）跟当前值（<code>item</code>）为参数调用闭包 <code>|sum, item| sum + item</code>。闭包的返回值会作为新的总和。它返回的最后一个值就是 <code>fold</code> 自身要返回的值——在这个例子中，也就是整个序列的总和。如果你用惯了 <code>for</code> 循环和 <code>while</code> 循环，这种写法可能看起来很奇怪，但一旦习惯了 <code>fold</code>，你就会发现 <code>fold</code> 的表达方式更加清晰和简洁。</p><!-- [[[read_end]]] -->\n<p>这就是函数式编程语言的标准风格，非常注重表达能力。Rust 的迭代器都经过了精心设计，以确保编译器可以把它们翻译成优秀的机器码。例如前面展示的第二个定义，在发行版中，Rust 会理解 <code>fold</code> 的定义并将其内联到 <code>triangle</code> 中。接下来是将闭包 <code>|sum, item| sum + item</code> 内联到 <code>triangle</code> 中。最后，Rust 会检查合并后的代码并意识到有一种更简单的方法可以对从 <code>1</code> 到 <code>n</code> 的数值求和：其总和总会等于 <code>n * (n+1) / 2</code>。于是 Rust 将 <code>triangle</code> 的整个函数体，包括循环、闭包和所有内容，翻译成了单个乘法指令和几个算术运算。</p>\n<p>虽然这个例子只涉及简单的算术运算，但迭代器在重度使用时也同样表现出色。它们是 Rust 提供的另一种灵活抽象，在典型应用中几乎不会产生额外开销。</p>\n<p>在本章中，我们将解释以下核心知识点。</p>\n<ul>\n<li><code>Iterator</code> 特型和 <code>IntoIterator</code> 特型，两者是 Rust 迭代器的基础。</li>\n<li>一个典型的迭代器流水线通常有 3 个阶段：从某种“值源”创建迭代器，通过选择或处理从中流过的值来将一种迭代器适配成另一种迭代器，然后消耗此迭代器生成的值。</li>\n<li>如何为自己的类型实现迭代器。</li>\n</ul>\n<p>迭代器的方法非常多，不过只要你掌握了其基本思想，就可以粗略浏览相应的部分。但迭代器在 Rust 惯用法中非常常见，熟悉它们附带的工具对于掌握这门语言至关重要。</p>\n<h2 id=\"nav_point_238\">15.1　<code>Iterator</code> 特型与 <code>IntoIterator</code> 特型</h2>\n<p>迭代器是实现了 <code>std::iter::Iterator</code> 特型的任意值：</p>\n<pre class=\"code-rows\"><code>trait Iterator {\n    type Item;\n    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;\n    …… // 很多默认方法\n}</code></pre>\n<p><code>Item</code> 是迭代器所生成的值的类型。<code>next</code> 方法要么返回 <code>Some(v)</code>（其中 <code>v</code> 是迭代器的下一个值），要么返回 <code>None</code>（作为序列结束的标志）。这里我们省略了 <code>Iterator</code> 的许多默认方法，本章的其余小节会分别介绍它们。</p>\n<p>只要可以用某种自然的方式来迭代某种类型，该类型就可以实现 <code>std::iter::IntoIterator</code>，其 <code>into_iter</code> 方法会接受一个值并返回一个迭代器：</p>\n<pre class=\"code-rows\"><code>trait IntoIterator where Self::IntoIter: Iterator&lt;Item=Self::Item&gt; {\n    type Item;\n    type IntoIter: Iterator;\n    fn into_iter(self) -&gt; Self::IntoIter;\n}</code></pre>\n<p><code>IntoIter</code> 是迭代器本身的类型，而 <code>Item</code> 是它生成的值的类型。任何实现了 <code>IntoIterator</code> 的类型都称为<strong>可迭代者</strong>，因为你可以随意迭代它。</p>\n<p>Rust 的 <code>for</code> 循环会将所有这些部分很好地结合在一起。要遍历向量的元素，你可以这样写：</p>\n<pre class=\"code-rows\"><code>println!(\"There's:\");\nlet v = vec![\"antimony\", \"arsenic\", \"aluminum\", \"selenium\"];\n\nfor element in &amp;v {\n    println!(\"{}\", element);\n}</code></pre>\n<p>在幕后，每个 <code>for</code> 循环都只是调用 <code>IntoIterator</code> 和 <code>Iterator</code> 中某些方法的简写形式：</p>\n<pre class=\"code-rows\"><code>let mut iterator = (&amp;v).into_iter();\nwhile let Some(element) = iterator.next() {\n    println!(\"{}\", element);\n}</code></pre>\n<p><code>for</code> 循环会使用 <code>IntoIterator::into_iter</code> 将其操作数 <code>&amp;v</code> 转换为迭代器，然后重复调用 <code>Iterator::next</code>。每次返回 <code>Some(element)</code> 时，<code>for</code> 循环都会执行其循环体，如果返回 <code>None</code>，则循环结束。</p>\n<p>先记住这个例子，下面介绍迭代器的一些术语。</p>\n<ul>\n<li>正如我们所说，<strong>迭代器</strong>是实现了 <code>Iterator</code> 的任意类型。</li>\n<li><strong>可迭代者</strong>是任何实现了 <code>IntoIterator</code> 的类型：你可以通过调用它的 <code>into_iter</code> 方法来获得一个迭代器。在这里，向量引用 <code>&amp;v</code> 就是可迭代者。</li>\n<li>迭代器能<strong>生成</strong>值。</li>\n<li>迭代器生成的值是<strong>条目</strong>。在这里，条目是 <code>\"antimony\"</code>、<code>\"arsenic\"</code> 等。</li>\n<li>接收迭代器所生成条目的代码是<strong>消费者</strong>。在这里，<code>for</code> 循环体就是消费者。</li>\n</ul>\n<p>虽然 <code>for</code> 循环总会在其操作数上调用 <code>into_iter</code>，但你也可以直接把迭代器传给 <code>for</code> 循环，比如，在遍历 <code>Range</code> 时就是这样的。所有迭代器都自动实现了 <code>IntoIterator</code>，并带有一个直接返回迭代器的 <code>into_iter</code> 方法。</p>\n<p>如果在返回 <code>None</code> 后再次调用迭代器的 <code>next</code> 方法，则 <code>Iterator</code> 特型没有规定它应该做什么。大多数迭代器只会再次返回 <code>None</code>，但也有例外。（如果这个过程中出了问题，可以参考一下 15.3.7 节中介绍的 <code>fuse</code> 适配器。）</p>\n<h2 id=\"nav_point_239\">15.2　创建迭代器</h2>\n<p>虽然 Rust 标准库文档对每个种类的迭代器类型都进行了详细解释，但标准库还是遵循了一些通用的约定，来帮助你定位并找到想要的东西。</p>\n<h3 id=\"nav_point_240\">15.2.1　<code>iter</code> 方法与 <code>iter_mut</code> 方法</h3>\n<p>大多数集合类型提供了 <code>iter</code>（迭代器）方法和 <code>iter_mut</code>（可变迭代器）方法，它们会返回该类型的自然迭代器，为每个条目生成共享引用或可变引用。像 <code>&amp;[T]</code> 和 <code>&amp;mut [T]</code> 这样的数组切片也有 <code>iter</code> 方法和 <code>iter_mut</code> 方法。如果你不打算让 <code>for</code> 循环替你跟迭代器打交道，<code>iter</code> 方法和 <code>iter_mut</code> 方法就是获取迭代器最常用的方法：</p>\n<pre class=\"code-rows\"><code>let v = vec![4, 20, 12, 8, 6];\nlet mut iterator = v.iter();\nassert_eq!(iterator.next(), Some(&amp;4));\nassert_eq!(iterator.next(), Some(&amp;20));\nassert_eq!(iterator.next(), Some(&amp;12));\nassert_eq!(iterator.next(), Some(&amp;8));\nassert_eq!(iterator.next(), Some(&amp;6));\nassert_eq!(iterator.next(), None);</code></pre>\n<p>这个迭代器的条目类型是 <code>&amp;i32</code>：每次调用 <code>next</code> 都会生成对下一个元素的引用，直到抵达向量的末尾。</p>\n<p>每种类型都可以自由选用任何符合其设计意图的方式实现 <code>iter</code> 和 <code>iter_mut</code>。<code>std::path::Path</code> 上的 <code>iter</code> 方法会返回一个迭代器，一次生成一个路径组件：</p>\n<pre class=\"code-rows\"><code>use std::ffi::OsStr;\nuse std::path::Path;\n\nlet path = Path::new(\"C:/Users/JimB/Downloads/Fedora.iso\");\nlet mut iterator = path.iter();\nassert_eq!(iterator.next(), Some(OsStr::new(\"C:\")));\nassert_eq!(iterator.next(), Some(OsStr::new(\"Users\")));\nassert_eq!(iterator.next(), Some(OsStr::new(\"JimB\")));\n...</code></pre>\n<p>这个迭代器的条目类型是 <code>&amp;std::ffi::OsStr</code>，是从操作系统调用所要求的那类字符串借用的切片类型。</p>\n<p>如果类型有不止一种常用的遍历方式，该类型通常会为每种遍历方式提供一个专门的方法，因为普通的 <code>iter</code> 方法会产生歧义。例如，<code>&amp;str</code> 字符串切片类型就没有 <code>iter</code> 方法——如果 <code>s</code> 是 <code>&amp;str</code>，则 <code>s.bytes()</code> 会返回一个能生成 <code>s</code> 中每字节的迭代器，而 <code>s.chars()</code> 则会将内容解释为 UTF-8 并生成每个 Unicode 字符。</p>\n<h3 id=\"nav_point_241\">15.2.2　<code>IntoIterator</code> 的实现</h3>\n<p>如果一个类型实现了 <code>IntoIterator</code>，你也可以自行调用它的 <code>into_iter</code> 方法，就像 <code>for</code> 循环一样：</p>\n<pre class=\"code-rows\"><code>// 大家通常会使用HashSet，但它的迭代顺序是不确定的，\n// 因此在这个示例中用了BTreeSet，它的演示效果更好些\nuse std::collections::BTreeSet;\nlet mut favorites = BTreeSet::new();\nfavorites.insert(\"Lucy in the Sky With Diamonds\".to_string());\nfavorites.insert(\"Liebesträume No. 3\".to_string());\nlet mut it = favorites.into_iter();\nassert_eq!(it.next(), Some(\"Liebesträume No. 3\".to_string()));\nassert_eq!(it.next(), Some(\"Lucy in the Sky With Diamonds\".to_string()));\nassert_eq!(it.next(), None);</code></pre>\n<p>大多数集合实际上提供了 <code>IntoIterator</code> 的几种实现，用于共享引用（<code>&amp;T</code>）、可变引用（<code>&amp;mut T</code>）和移动（<code>T</code>）。</p>\n<ul>\n<li>给定一个集合的<strong>共享引用</strong>，<code>into_iter</code> 会返回一个迭代器，该迭代器会生成对其条目的共享引用。例如，在前面的代码中，<code>(&amp;favorites).into_iter()</code> 会返回一个 <code>Item</code> 类型为 <code>&amp;String</code> 的迭代器。</li>\n<li>给定对集合的<strong>可变引用</strong>，<code>into_iter</code> 会返回一个迭代器，该迭代器会生成对其条目的可变引用。如果 <code>vector</code> 是某个 <code>Vec&lt;String&gt;</code>，则调用 <code>(&amp;mut vector).into_iter()</code> 会返回一个 <code>Item</code> 类型为 <code>&amp;mut String</code> 的迭代器。</li>\n<li>当按值传递集合时，<code>into_iter</code> 会返回一个迭代器，该迭代器会获取集合的所有权并按值返回这些条目，这些条目的所有权会从集合转移给消费者，原始集合在此过程中已被消耗掉了。例如，前面代码中的 <code>favorites.into_iter()</code> 调用返回了一个迭代器，该迭代器会按值生成每个字符串，消费者会获得每个字符串的所有权。当迭代器被丢弃时，<code>BTreeSet</code> 中剩余的所有元素都将被丢弃，并且该集合的空壳也将被丢弃。</li>\n</ul>\n<p>由于 <code>for</code> 循环会将 <code>IntoIterator::into_iter</code> 作为它的操作对象，因此这 3 种实现创建了以下惯用法，用于迭代对集合的共享引用或可变引用，或者消耗该集合并获取其元素的所有权：</p>\n<pre class=\"code-rows\"><code>for element in &amp;collection { ... }\nfor element in &amp;mut collection { ... }\nfor element in collection { ... }</code></pre>\n<p>其中每种用法最终都会调用此处列出的三种 <code>IntoIterator</code> 实现之一。</p>\n<p>并非每种类型都提供了这 3 种实现，比如，<code>HashSet</code>、<code>BTreeSet</code> 和 <code>BinaryHeap</code> 不会在可变引用上实现 <code>IntoIterator</code>，因为修改它们的元素可能会违反类型自身的不变性规则——修改后的值很可能有不同的哈希值，或者相对于其邻居的顺序改变了，所以修改它会让该类型处于错误状态。另一部分类型确实支持修改，但只支持修改一部分，比如，<code>HashMap</code> 和 <code>BTreeMap</code> 会生成对其条目值的可变引用，但只能提供对其键的共享引用，原因与前面给出的相似。</p>\n<p>总体原则是，迭代应该是高效且可预测的，因此 Rust 不会提供昂贵或可能表现出意外行为的实现。（例如，对修改过的 <code>HashSet</code> 条目重新进行哈希，可能会导致在迭代中稍后再次遇到这些条目。）</p>\n<p>切片实现了 3 个 <code>IntoIterator</code> 变体中的两个，由于切片并不拥有自己的元素，因此不存在“按值”引用的情况。<code>&amp;[T]</code> 和 <code>&amp;mut [T]</code> 各自的 <code>into_iter</code> 会分别返回一个迭代器，该迭代器会生成对其元素的共享引用和可变引用。如果你将底层的切片类型 <code>[T]</code> 想象成某种集合，那它就完美地遵循了集合的总体模式。<span class=\"comment-number\">1</span></p>\n\n<p>你可能已经注意到了，对于共享引用和可变引用，前两个 <code>IntoIterator</code> 变体等效于在引用目标上调用 <code>iter</code> 或 <code>iter_mut</code>。为什么 Rust 要同时提供 <code>into_iter</code> 和 <code>iter</code> 这两种方式呢？</p>\n<p><code>IntoIterator</code> 是确保 <code>for</code> 循环工作的关键，显而易见它是必要的。但当我们不用 <code>for</code> 循环时，写 <code>favorites.iter()</code> 会比 <code>(&amp;favorites).into_iter()</code> 更清晰。我们会频繁通过共享引用进行迭代，因此 <code>iter</code> 和 <code>iter_mut</code> 仍然具有很高的工效学价值。</p>\n<p><code>IntoIterator</code> 在泛型代码中也很有用：你可以使用像 <code>T: IntoIterator</code> 这样的限界来将类型变量 <code>T</code> 限制为可以迭代的类型，还可以编写 <code>T: IntoIterator&lt;Item=U&gt;</code> 来进一步要求迭代时生成具有特定类型 <code>U</code> 的条目。例如，<code>dump</code> 函数可以转储任何其条目可用 <code>\"{:?}\"</code> 格式打印的可迭代者的值：</p>\n<pre class=\"code-rows\"><code>use std::fmt::Debug;\n\nfn dump&lt;T, U&gt;(t: T)\n    where T: IntoIterator&lt;Item=U&gt;,\n          U: Debug\n{\n    for u in t {\n        println!(\"{:?}\", u);\n    }\n}</code></pre>\n<p>但你不能使用 <code>iter</code> 和 <code>iter_mut</code> 来编写这个泛型函数，因为它们不是任何特型的方法：只是大多数可迭代类型恰好具有叫这两个名字的方法而已。</p>\n<h3 id=\"nav_point_242\">15.2.3　<code>from_fn</code> 与 <code>successors</code></h3>\n<p>要生成一系列值，有一种简单而通用的方法，那就是提供一个能返回这些值的闭包。</p>\n<p>给定返回 <code>Option&lt;T&gt;</code> 的函数，<code>std::iter::from_fn</code>（来自 <code>fn</code>）就会返回一个迭代器，该迭代器会调用 <code>fn</code> 来生成条目。例如：</p>\n<pre class=\"code-rows\"><code>use rand::random; // 在Cargo.toml中添加dependencies: rand = \"0.7\"\nuse std::iter::from_fn;\n\n// 产生1000条端点均匀分布在区间[0, 1]上的随机线段的长度（这并不是\n// `rand_distr` crate中能找到的分布类型，但你可以轻易实现一个）\nlet lengths: Vec&lt;f64&gt; =\n    from_fn(|| Some((random::&lt;f64&gt;() - random::&lt;f64&gt;()).abs()))\n        .take(1000)\n        .collect();</code></pre>\n<p>它会调用 <code>from_fn</code> 来让迭代器产生随机数。由于迭代器总是返回 <code>Some</code>，因此序列永不结束，但我们调用 <code>take(1000)</code> 时会将其限制为前 1000 个元素。然后 <code>collect</code> 会从这 1000 次迭代中构建出向量。这是构造已初始化向量的有效方式，我们会在 15.4.13 节中解释原因。</p>\n<p>如果每个条目都依赖于其前一个条目，那么 <code>std::iter::successors</code> 函数很实用。只需要提供一个初始条目和一个函数，且该函数能接受一个条目并返回下一个条目的 <code>Option</code>。如果返回 <code>None</code>，则迭代结束。例如，下面是编写第 2 章中的曼德博集绘图器的 <code>escape_time</code> 函数的另一种方式：</p>\n<pre class=\"code-rows\"><code>use num::Complex;\nuse std::iter::successors;\n\nfn escape_time(c: Complex&lt;f64&gt;, limit: usize) -&gt; Option&lt;usize&gt; {\n    let zero = Complex { re: 0.0, im: 0.0 };\n    successors(Some(zero), |&amp;z| { Some(z * z + c) })\n        .take(limit)\n        .enumerate()\n        .find(|(_i, z)| z.norm_sqr() &gt; 4.0)\n        .map(|(i, _z)| i)\n}</code></pre>\n<p>从零开始，<code>successors</code>（后继者）调用会通过反复对最后一个点求平方再加上参数 <code>c</code> 来生成复平面上的一系列点。在绘制曼德博集时，我们想看看这个序列是永远在原点附近打转还是“飞向”无穷远。调用 <code>take(limit)</code> 确定了我们追踪序列的次数限制，然后 <code>enumerate</code> 对每个点进行编号，将每个点 <code>z</code> 变成元组 <code>(i, z)</code>。我们使用 <code>find</code> 来寻找距离原点足够远的第一个点以判断是否逃逸。<code>find</code> 方法会返回一个 <code>Option</code>：如果这样的点存在就返回 <code>Some((i, z))</code>，否则返回 <code>None</code>。调用 <code>Option::map</code> 会将 <code>Some((i, z))</code> 变成 <code>Some(i)</code>，但不会改变 <code>None</code>，因为这正是我们想要的返回值。</p>\n<p><code>from_fn</code> 和 <code>successors</code> 都接受 <code>FnMut</code> 闭包，因此你的闭包可以捕获和修改周边作用域中的变量。例如，下面的 <code>fibonacci</code> 函数就用 <code>move</code> 闭包来捕获一个变量并将其用作自己的运行状态：</p>\n<pre class=\"code-rows\"><code>fn fibonacci() -&gt; impl Iterator&lt;Item=usize&gt; {\n    let mut state = (0, 1);\n    std::iter::from_fn(move || {\n        state = (state.1, state.0 + state.1);\n        Some(state.0)\n    })\n}\n\nassert_eq!(fibonacci().take(8).collect::&lt;Vec&lt;_&gt;&gt;(),\n           vec![1, 1, 2, 3, 5, 8, 13, 21]);</code></pre>\n<p>需要注意的是，<code>from_fn</code> 方法和 <code>successors</code> 方法非常灵活，你几乎可以将任何对迭代器的使用改写成对其中之一的调用，通过传递复杂的闭包来得到你想要的行为。但这样做浪费了迭代器提供的机会，即使用常见模式的标准名称来更清晰地表达计算中的数据流。在使用这两个方法之前，请确保你已经熟悉本章中的其他迭代器方法，通常其他迭代器是更好的选择。<span class=\"comment-number\">2</span></p>\n\n<h3 id=\"nav_point_243\">15.2.4　<code>drain</code> 方法</h3>\n<p>有许多集合类型提供了 <code>drain</code>（抽取）方法。<code>drain</code> 会接受一个对集合的可变引用，并返回一个迭代器，该迭代器会将每个元素的所有权传给消费者。然而，与按值获取并消耗掉集合的 <code>into_iter()</code> 方法不同，<code>drain</code> 只会借入对集合的可变引用，当迭代器被丢弃时，它会从集合中移除所有剩余元素以清空集合。</p>\n<p>对于可以按范围索引的类型（如 <code>String</code>、向量和 <code>VecDeque</code>），<code>drain</code> 方法可指定要移除的元素范围，而不是“抽干”整个序列：</p>\n<pre class=\"code-rows\"><code>let mut outer = \"Earth\".to_string();\nlet inner = String::from_iter(outer.drain(1..4));\n\nassert_eq!(outer, \"Eh\");\nassert_eq!(inner, \"art\");</code></pre>\n<p>如果确实需要“抽干”整个序列，使用整个范围（<code>..</code>）作为参数即可。</p>\n<h3 id=\"nav_point_244\">15.2.5　其他迭代器源</h3>\n<p>前面的内容主要关注集合类型（如向量和 <code>HashMap</code>），但标准库中还有许多其他类型也支持迭代。表 15-1 总结了一些比较有趣的迭代器，限于篇幅，还有更多没有列出来。我们在专门讲解特定类型的章（第 16 章、第 17 章和第 18 章）中会更详细地介绍其中的一些方法。</p>\n<p><strong>表 15-1：标准库中的其他迭代器</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>类型或特型</p></th>\n<th><p>表达式</p></th>\n<th><p>注意事项</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>std::ops::Range</code></p></td>\n<td><p><code>1..10</code><br /><code>(1..10).step_by(2)</code></p></td>\n<td><p>两个端点必须是可迭代的整数类型。范围包括起始值，不包括结束值<br />生成 1、3、5、7、9</p></td>\n</tr>\n<tr>\n<td><p><code>std::ops::RangeFrom</code></p></td>\n<td><p><code>1..</code></p></td>\n<td><p>无界迭代。起点必须是一个整数。如果值达到了该类型的上限，可能会发生 panic 或溢出</p></td>\n</tr>\n<tr>\n<td><p><code>std::ops::RangeInclusive</code></p></td>\n<td><p><code>1..=10</code></p></td>\n<td><p>和 <code>Range</code> 类似，但包含结束值</p></td>\n</tr>\n<tr>\n<td><p><code>Option&lt;T&gt;</code></p></td>\n<td><p><code>Some(10).iter()</code></p></td>\n<td><p>表现得像一个长度为 0（<code>None</code>）或 1（<code>Some(v)</code>）的向量</p></td>\n</tr>\n<tr>\n<td><p><code>Result&lt;T, E&gt;</code></p></td>\n<td><p><code>Ok(\"blah\").iter()</code></p></td>\n<td><p>类似于 <code>Option</code>，但生成 <code>Ok</code> 值</p></td>\n</tr>\n<tr>\n<td><p><code>Vec&lt;T&gt;,&amp;[T]</code></p></td>\n<td><p><code>v.windows(16)</code><br /><code>v.chunks(16)</code><br /><code>v.chunks_mut(1024)</code><br /><code>v.split(|byte|byte &amp; 1 != 0)</code><br /><code>v.split_mut(...)</code><br /><code>v.rsplit(...)</code><br /><code>v.splitn(n, ...)</code></p></td>\n<td><p>从左到右生成给定长度的所有连续切片。窗口之间会有重叠<br />从左到右生成给定长度的不重叠的连续切片<br />和 <code>chunks</code> 类似，但生成的切片是可变的<br />生成由匹配给定谓词的元素分隔的切片<br />同上，但生成可变切片<br />与 <code>split</code> 类似，但从右到左生成切片<br />与 <code>split</code> 类似，但最多生成 <i>n</i> 个切片</p></td>\n</tr>\n<tr>\n<td><p><code>String,&amp;str</code></p></td>\n<td><p><code>s.bytes()</code><br /><code>s.chars()</code><br /><code>s.split_whitespace()</code><br /><code>s.lines()</code><br /><code>s.split('/')</code><br /><code>s.matches(char::is_numeric)</code></p></td>\n<td><p>生成一些 UTF-8 格式的字节<br />生成一些 UTF-8 表示的字符<br />按空白字符拆分字符串，并生成非空白字符的切片<br />生成字符串各行的切片<br />用给定模式拆分字符串，用匹配项之间的部分生成切片。模式可以有很多种：字符、<code>String</code> 和闭包<br />生成与给定模式匹配的切片</p></td>\n</tr>\n<tr>\n<td><p><code>std::collections::HashMap, std::collections::BTreeMap</code></p></td>\n<td><p><code>map.keys(), map.values()</code><br /><code>map.values_mut()</code></p></td>\n<td><p>生成对该 <code>map</code> 的键或值的共享引用<br />生成对条目值的可变引用</p></td>\n</tr>\n<tr>\n<td><p><code>std::collections::HashSet, std::collections::BTreeSet</code></p></td>\n<td><p><code>set1.union(set2)</code><br /><code>set1.intersection(set2)</code></p></td>\n<td><p>生成对 <code>set1</code> 和 <code>set2</code> 并集元素的共享引用<br />生成对 <code>set1</code> 和 <code>set2</code> 交集元素的共享引用</p></td>\n</tr>\n<tr>\n<td><p><code>std::sync::mpsc::Receiver</code></p></td>\n<td><p><code>recv.iter()</code></p></td>\n<td><p>生成从位于另一个线程的对端发送者发来的值</p></td>\n</tr>\n<tr>\n<td><p><code>std::io::Read</code></p></td>\n<td><p><code>stream.bytes()</code><br /><code>stream.chars()</code></p></td>\n<td><p>从 I/O 流中生成一些字节<br />将流解析为 UTF-8，并生成一些字符</p></td>\n</tr>\n<tr>\n<td><p><code>std::io::BufRead</code></p></td>\n<td><p><code>bufstream.lines()</code><br /><code>bufstream.split(0)</code></p></td>\n<td><p>将流解析为 UTF-8，并按行生成一些 <code>String</code><br />使用给定的字节拆分流，生成该字节间的 <code>Vec&lt;u8&gt;</code> 缓冲区</p></td>\n</tr>\n<tr>\n<td><p><code>std::fs::ReadDir</code></p></td>\n<td><p><code>std::fs::read_dir(path)</code></p></td>\n<td><p>生成目录条目</p></td>\n</tr>\n<tr>\n<td><p><code>std::net::TcpListener</code></p></td>\n<td><p><code>listener.incoming()</code></p></td>\n<td><p>生成传入的网络连接</p></td>\n</tr>\n<tr>\n<td><p>自由函数</p></td>\n<td><p><code>std::iter::empty()</code><br /><code>std::iter::once(5)</code><br /><code>std::iter::repeat(\"#9\")</code></p></td>\n<td><p>立即返回 <code>None</code><br />生成给定的值然后结束<br />总是生成给定的值</p></td>\n</tr>\n</tbody>\n</table>\n","comments":[]}