{"id":740762,"title":"第 4 章 响应系统的作用与实现(1)","content":"<h1 id=\"nav_point_31\">第 4 章　响应系统的作用与实现</h1>\r\n<p>前文没有提到响应系统，响应系统也是 Vue.js 的重要组成部分，所以我们会花费大量篇幅介绍。在本章中，我们首先讨论什么是响应式数据和副作用函数，然后尝试实现一个相对完善的响应系统。在这个过程中，我们会遇到各种各样的问题，例如如何避免无限递归？为什么需要嵌套的副作用函数？两个副作用函数之间会产生哪些影响？以及其他很多需要考虑的细节。接着，我们会详细讨论与响应式数据相关的内容。我们知道 Vue.js 3 采用 <code>Proxy</code> 实现响应式数据，这涉及语言规范层面的知识。这部分内容包括如何根据语言规范实现对数据对象的代理，以及其中的一些重要细节。接下来，我们就从认识响应式数据和副作用函数开始，一步一步地了解响应系统的设计与实现。</p>\r\n<h2 id=\"nav_point_32\">4.1　响应式数据与副作用函数</h2>\r\n<p>副作用函数指的是会产生副作用的函数，如下面的代码所示：</p>\r\n<pre class=\"no-line-number\"><code>01 function effect() {\r\n02   document.body.innerText = 'hello vue3'\r\n03 }</code></pre>\r\n<p>当 <code>effect</code> 函数执行时，它会设置 <code>body</code> 的文本内容，但除了 <code>effect</code> 函数之外的任何函数都可以读取或设置 <code>body</code> 的文本内容。也就是说，<code>effect</code> 函数的执行会直接或间接影响其他函数的执行，这时我们说 <code>effect</code> 函数产生了副作用。副作用很容易产生，例如一个函数修改了全局变量，这其实也是一个副作用，如下面的代码所示：</p>\r\n<pre class=\"no-line-number\"><code>01 // 全局变量\r\n02 let val = 1\r\n03\r\n04 function effect() {\r\n05   val = 2 // 修改全局变量，产生副作用\r\n06 }</code></pre>\r\n<p>理解了什么是副作用函数，再来说说什么是响应式数据。假设在一个副作用函数中读取了某个对象的属性：</p>\r\n<pre class=\"no-line-number\"><code>01 const obj = { text: 'hello world' }\r\n02 function effect() {\r\n03   // effect 函数的执行会读取 obj.text\r\n04   document.body.innerText = obj.text\r\n05 }</code></pre>\r\n<p>如上面的代码所示，副作用函数 <code>effect</code> 会设置 <code>body</code> 元素的 <code>innerText</code> 属性，其值为 <code>obj.text</code>，当 <code>obj.text</code> 的值发生变化时，我们希望副作用函数 <code>effect</code> 会重新执行：</p>\r\n<pre class=\"no-line-number\"><code>01 obj.text = 'hello vue3' // 修改 obj.text 的值，同时希望副作用函数会重新执行</code></pre>\r\n<p>这句代码修改了字段 <code>obj.text</code> 的值，我们希望当值变化后，副作用函数自动重新执行，如果能实现这个目标，那么对象 <code>obj</code> 就是响应式数据。但很明显，以上面的代码来看，我们还做不到这一点，因为 <code>obj</code> 是一个普通对象，当我们修改它的值时，除了值本身发生变化之外，不会有任何其他反应。下一节中我们会讨论如何让数据变成响应式数据。</p>\r\n<h2 id=\"nav_point_33\">4.2　响应式数据的基本实现</h2>\r\n<p>接着上文思考，如何才能让 <code>obj</code> 变成响应式数据呢？通过观察我们能发现两点线索：</p>\r\n<ul>\r\n<li>当副作用函数 <code>effect</code> 执行时，会触发字段 <code>obj.text</code> 的<strong>读取</strong>操作；</li>\r\n<li>当修改 <code>obj.text</code> 的值时，会触发字段 <code>obj.text</code> 的<strong>设置</strong>操作。</li>\r\n</ul>\r\n<p>如果我们能拦截一个对象的读取和设置操作，事情就变得简单了，当读取字段 <code>obj.text</code> 时，我们可以把副作用函数 <code>effect</code> 存储到一个“桶”里，如图 4-1 所示。</p>\r\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00498.jpeg\" alt=\"{%}\" /></p>\r\n<p class=\"ebook-image-title\"><strong>图 4-1　将副作用函数存储到“桶”中</strong></p>\r\n<p>接着，当设置 <code>obj.text</code> 时，再把副作用函数 <code>effect</code> 从“桶”里取出并执行即可，如图 4-2 所示。</p>\r\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00499.jpeg\" alt=\"\" width=\"26%\" style=\"width: 26%\" /></p>\r\n<p class=\"ebook-image-title\"><strong>图 4-2　把副作用函数从“桶”内取出并执行</strong></p>\r\n<p>现在问题的关键变成了我们如何才能拦截一个对象属性的读取和设置操作。在 ES2015 之前，只能通过 <code>Object.defineProperty</code> 函数实现，这也是 Vue.js 2 所采用的方式。在 ES2015+ 中，我们可以使用代理对象 <code>Proxy</code> 来实现，这也是 Vue.js 3 所采用的方式。</p>\r\n<p>接下来我们就根据如上思路，采用 <code>Proxy</code> 来实现：</p>\r\n<pre class=\"no-line-number\"><code>01 // 存储副作用函数的桶\r\n02 const bucket = new Set()\r\n03\r\n04 // 原始数据\r\n05 const data = { text: 'hello world' }\r\n06 // 对原始数据的代理\r\n07 const obj = new Proxy(data, {\r\n08   // 拦截读取操作\r\n09   get(target, key) {\r\n10     // 将副作用函数 effect 添加到存储副作用函数的桶中\r\n11     bucket.add(effect)\r\n12     // 返回属性值\r\n13     return target[key]\r\n14   },\r\n15   // 拦截设置操作\r\n16   set(target, key, newVal) {\r\n17     // 设置属性值\r\n18     target[key] = newVal\r\n19     // 把副作用函数从桶里取出并执行\r\n20     bucket.forEach(fn =&gt; fn())\r\n21     // 返回 true 代表设置操作成功\r\n22     return true\r\n23   }\r\n24 })</code></pre>\r\n<p>首先，我们创建了一个用于存储副作用函数的桶 <code>bucket</code>，它是 <code>Set</code> 类型。接着定义原始数据 <code>data</code>，<code>obj</code> 是原始数据的代理对象，我们分别设置了 <code>get</code> 和 <code>set</code> 拦截函数，用于拦截读取和设置操作。当读取属性时将副作用函数 <code>effect</code> 添加到桶里，即 <code>bucket.add(effect)</code>，然后返回属性值；当设置属性值时先更新原始数据，再将副作用函数从桶里取出并重新执行，这样我们就实现了响应式数据。可以使用下面的代码来测试一下：</p>\r\n<pre class=\"no-line-number\"><code>01 // 副作用函数\r\n02 function effect() {\r\n03   document.body.innerText = obj.text\r\n04 }\r\n05 // 执行副作用函数，触发读取\r\n06 effect()\r\n07 // 1 秒后修改响应式数据\r\n08 setTimeout(() =&gt; {\r\n09   obj.text = 'hello vue3'\r\n10 }, 1000)</code></pre>\r\n<p>在浏览器中运行上面这段代码，会得到期望的结果。</p>\r\n<p>但是目前的实现还存在很多缺陷，例如我们直接通过名字（<code>effect</code>）来获取副作用函数，这种硬编码的方式很不灵活。副作用函数的名字可以任意取，我们完全可以把副作用函数命名为 <code>myEffect</code>，甚至是一个匿名函数，因此我们要想办法去掉这种硬编码的机制。下一节会详细讲解这一点，这里大家只需要理解响应式数据的基本实现和工作原理即可。</p>\r\n<h2 id=\"nav_point_34\">4.3　设计一个完善的响应系统</h2>\r\n<p>在上一节中，我们了解了如何实现响应式数据。但其实在这个过程中我们已经实现了一个微型响应系统，之所以说“微型”，是因为它还不完善，本节我们将尝试构造一个更加完善的响应系统。</p>\r\n<p>从上一节的例子中不难看出，一个响应系统的工作流程如下：</p>\r\n<ul>\r\n<li>当<strong>读取</strong>操作发生时，将副作用函数收集到“桶”中；</li>\r\n<li>当<strong>设置</strong>操作发生时，从“桶”中取出副作用函数并执行。</li>\r\n</ul>\r\n<p>看上去很简单，但需要处理的细节还真不少。例如在上一节的实现中，我们硬编码了副作用函数的名字（<code>effect</code>），导致一旦副作用函数的名字不叫 <code>effect</code>，那么这段代码就不能正确地工作了。而我们希望的是，哪怕副作用函数是一个匿名函数，也能够被正确地收集到“桶”中。为了实现这一点，我们需要提供一个用来注册副作用函数的机制，如以下代码所示：</p>\r\n<pre class=\"no-line-number\"><code>01 // 用一个全局变量存储被注册的副作用函数\r\n02 let activeEffect\r\n03 // effect 函数用于注册副作用函数\r\n04 function effect(fn) {\r\n05   // 当调用 effect 注册副作用函数时，将副作用函数 fn 赋值给 activeEffect\r\n06   activeEffect = fn\r\n07   // 执行副作用函数\r\n08   fn()\r\n09 }</code></pre>\r\n<p>首先，定义了一个全局变量 <code>activeEffect</code>，初始值是 <code>undefined</code>，它的作用是存储被注册的副作用函数。接着重新定义了 <code>effect</code> 函数，它变成了一个用来注册副作用函数的函数，<code>effect</code> 函数接收一个参数 <code>fn</code>，即要注册的副作用函数。我们可以按照如下所示的方式使用 <code>effect</code> 函数：</p>\r\n<pre class=\"no-line-number\"><code>01 effect(\r\n02   // 一个匿名的副作用函数\r\n03   () =&gt; {\r\n04     document.body.innerText = obj.text\r\n05   }\r\n06 )</code></pre>\r\n<p>可以看到，我们使用一个匿名的副作用函数作为 <code>effect</code> 函数的参数。当 <code>effect</code> 函数执行时，首先会把匿名的副作用函数 <code>fn</code> 赋值给全局变量 <code>activeEffect</code>。接着执行被注册的匿名副作用函数 <code>fn</code>，这将会触发响应式数据 <code>obj.text</code> 的读取操作，进而触发代理对象 <code>Proxy</code> 的 <code>get</code> 拦截函数：</p>\r\n<pre class=\"no-line-number\"><code>01 const obj = new Proxy(data, {\r\n02   get(target, key) {\r\n03     // 将 activeEffect 中存储的副作用函数收集到“桶”中\r\n04     if (activeEffect) {  // 新增\r\n05       bucket.add(activeEffect)  // 新增\r\n06     }  // 新增\r\n07     return target[key]\r\n08   },\r\n09   set(target, key, newVal) {\r\n10     target[key] = newVal\r\n11     bucket.forEach(fn =&gt; fn())\r\n12     return true\r\n13   }\r\n14 })</code></pre>\r\n<p>如上面的代码所示，由于副作用函数已经存储到了 <code>activeEffect</code> 中，所以在 <code>get</code> 拦截函数内应该把 <code>activeEffect</code> 收集到“桶”中，这样响应系统就不依赖副作用函数的名字了。</p>\r\n<p>但如果我们再对这个系统稍加测试，例如在响应式数据 <code>obj</code> 上设置一个不存在的属性时：</p>\r\n<pre class=\"no-line-number\"><code>01 effect(\r\n02   // 匿名副作用函数\r\n03   () =&gt; {\r\n04     console.log('effect run') // 会打印 2 次\r\n05     document.body.innerText = obj.text\r\n06   }\r\n07 )\r\n08\r\n09 setTimeout(() =&gt; {\r\n10   // 副作用函数中并没有读取 notExist 属性的值\r\n11   obj.notExist = 'hello vue3'\r\n12 }, 1000)</code></pre>\r\n<p>可以看到，匿名副作用函数内部读取了字段 <code>obj.text</code> 的值，于是匿名副作用函数与字段 <code>obj.text</code> 之间会建立响应联系。接着，我们开启了一个定时器，一秒钟后为对象 <code>obj</code> 添加新的 <code>notExist</code> 属性。我们知道，在匿名副作用函数内并没有读取 <code>obj.notExist</code> 属性的值，所以理论上，字段 <code>obj.notExist</code> 并没有与副作用建立响应联系，因此，定时器内语句的执行不应该触发匿名副作用函数重新执行。但如果我们执行上述这段代码就会发现，定时器到时后，匿名副作用函数却重新执行了，这是不正确的。为了解决这个问题，我们需要重新设计“桶”的数据结构。</p>\r\n<p>在上一节的例子中，我们使用一个 <code>Set</code> 数据结构作为存储副作用函数的“桶”。导致该问题的根本原因是，我们<strong>没有在副作用函数与被操作的目标字段之间建立明确的联系</strong>。例如当读取属性时，无论读取的是哪一个属性，其实都一样，都会把副作用函数收集到“桶”里；当设置属性时，无论设置的是哪一个属性，也都会把“桶”里的副作用函数取出并执行。副作用函数与被操作的字段之间没有明确的联系。解决方法很简单，只需要在副作用函数与被操作的字段之间建立联系即可，这就需要我们重新设计“桶”的数据结构，而不能简单地使用一个 <code>Set</code> 类型的数据作为“桶”了。</p>\r\n<p>那应该设计怎样的数据结构呢？在回答这个问题之前，我们需要先仔细观察下面的代码：</p>\r\n<pre class=\"no-line-number\"><code>01 effect(function effectFn() {\r\n02   document.body.innerText = obj.text\r\n03 })</code></pre>\r\n<p>在这段代码中存在三个角色：</p>\r\n<ul>\r\n<li>被操作（读取）的代理对象 <code>obj</code>；</li>\r\n<li>被操作（读取）的字段名 <code>text</code>；</li>\r\n<li>使用 <code>effect</code> 函数注册的副作用函数 <code>effectFn</code>。</li>\r\n</ul>\r\n<p>如果用 <code>target</code> 来表示一个代理对象所代理的原始对象，用 <code>key</code> 来表示被操作的字段名，用 <code>effectFn</code> 来表示被注册的副作用函数，那么可以为这三个角色建立如下关系：</p>\r\n<pre class=\"no-line-number\"><code>01 target\r\n02     └── key\r\n03         └── effectFn</code></pre>\r\n<p>这是一种树型结构，下面举几个例子来对其进行补充说明。</p>\r\n<p>如果有两个副作用函数同时读取同一个对象的属性值：</p>\r\n<pre class=\"no-line-number\"><code>01 effect(function effectFn1() {\r\n02   obj.text\r\n03 })\r\n04 effect(function effectFn2() {\r\n05   obj.text\r\n06 })</code></pre>\r\n<p>那么关系如下：</p>\r\n<pre class=\"no-line-number\"><code>01 target\r\n02     └── text\r\n03         └── effectFn1\r\n04         └── effectFn2</code></pre>\r\n<p>如果一个副作用函数中读取了同一个对象的两个不同属性：</p>\r\n<pre class=\"no-line-number\"><code>01 effect(function effectFn() {\r\n02   obj.text1\r\n03   obj.text2\r\n04 })</code></pre>\r\n<p>那么关系如下：</p>\r\n<pre class=\"no-line-number\"><code>01 target\r\n02     └── text1\r\n03         └── effectFn\r\n04     └── text2\r\n05         └── effectFn</code></pre>\r\n<p>如果在不同的副作用函数中读取了两个不同对象的不同属性：</p>\r\n<pre class=\"no-line-number\"><code>01 effect(function effectFn1() {\r\n02   obj1.text1\r\n03 })\r\n04 effect(function effectFn2() {\r\n05   obj2.text2\r\n06 })</code></pre>\r\n<p>那么关系如下：</p>\r\n<pre class=\"no-line-number\"><code>01 target1\r\n02     └── text1\r\n03         └── effectFn1\r\n04 target2\r\n05     └── text2\r\n06         └── effectFn2</code></pre>\r\n<p>总之，这其实就是一个树型数据结构。这个联系建立起来之后，就可以解决前文提到的问题了。拿上面的例子来说，如果我们设置了 <code>obj2.text2</code> 的值，就只会导致 <code>effectFn2</code> 函数重新执行，并不会导致 <code>effectFn1</code> 函数重新执行。</p>\r\n<p>接下来我们尝试用代码来实现这个新的“桶”。首先，需要使用 <code>WeakMap</code> 代替 <code>Set</code> 作为桶的数据结构：</p>\r\n<pre class=\"no-line-number\"><code>01 // 存储副作用函数的桶\r\n02 const bucket = new WeakMap()</code></pre>\r\n<p>然后修改 <code>get</code>/<code>set</code> 拦截器代码：</p>\r\n<pre class=\"no-line-number\"><code>01 const obj = new Proxy(data, {\r\n02   // 拦截读取操作\r\n03   get(target, key) {\r\n04     // 没有 activeEffect，直接 return\r\n05     if (!activeEffect) return target[key]\r\n06     // 根据 target 从“桶”中取得 depsMap，它也是一个 Map 类型：key --&gt; effects\r\n07     let depsMap = bucket.get(target)\r\n08     // 如果不存在 depsMap，那么新建一个 Map 并与 target 关联\r\n09     if (!depsMap) {\r\n10       bucket.set(target, (depsMap = new Map()))\r\n11     }\r\n12     // 再根据 key 从 depsMap 中取得 deps，它是一个 Set 类型，\r\n13     // 里面存储着所有与当前 key 相关联的副作用函数：effects\r\n14     let deps = depsMap.get(key)\r\n15     // 如果 deps 不存在，同样新建一个 Set 并与 key 关联\r\n16     if (!deps) {\r\n17       depsMap.set(key, (deps = new Set()))\r\n18     }\r\n19     // 最后将当前激活的副作用函数添加到“桶”里\r\n20     deps.add(activeEffect)\r\n21\r\n22     // 返回属性值\r\n23     return target[key]\r\n24   },\r\n25   // 拦截设置操作\r\n26   set(target, key, newVal) {\r\n27     // 设置属性值\r\n28     target[key] = newVal\r\n29     // 根据 target 从桶中取得 depsMap，它是 key --&gt; effects\r\n30     const depsMap = bucket.get(target)\r\n31     if (!depsMap) return\r\n32     // 根据 key 取得所有副作用函数 effects\r\n33     const effects = depsMap.get(key)\r\n34     // 执行副作用函数\r\n35     effects &amp;&amp; effects.forEach(fn =&gt; fn())\r\n36   }\r\n37 })</code></pre>\r\n<p>从这段代码可以看出构建数据结构的方式，我们分别使用了 <code>WeakMap</code>、<code>Map</code> 和 <code>Set</code>：</p>\r\n<ul>\r\n<li><code>WeakMap</code> 由 <code>target --&gt; Map</code> 构成；</li>\r\n<li><code>Map</code> 由 <code>key --&gt; Set</code> 构成。</li>\r\n</ul>\r\n<p>其中 <code>WeakMap</code> 的键是原始对象 <code>target</code>，<code>WeakMap</code> 的值是一个 <code>Map</code> 实例，而 <code>Map</code> 的键是原始对象 <code>target</code> 的 <code>key</code>，<code>Map</code> 的值是一个由副作用函数组成的 <code>Set</code>。它们的关系如图 4-3 所示。</p>\r\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00500.jpeg\" alt=\"\" width=\"60%\" style=\"width: 60%\" /></p>\r\n<p class=\"ebook-image-title\"><strong>图 4-3　<code>WeakMap</code>、<code>Map</code> 和 <code>Set</code> 之间的关系</strong></p>\r\n<p>为了方便描述，我们把图 4-3 中的 <code>Set</code> 数据结构所存储的副作用函数集合称为 <code>key</code> 的<strong>依赖集合</strong>。</p>\r\n<p>搞清了它们之间的关系，我们有必要解释一下这里为什么要使用 <code>WeakMap</code>，这其实涉及 <code>WeakMap</code> 和 <code>Map</code> 的区别，我们用一段代码来讲解：</p>\r\n<pre class=\"no-line-number\"><code>01 const map = new Map();\r\n02 const weakmap = new WeakMap();\r\n03\r\n04 (function(){\r\n05     const foo = ;\r\n06     const bar = ;\r\n07\r\n08     map.set(foo, 1);\r\n09     weakmap.set(bar, 2);\r\n10 })()</code></pre>\r\n<p>首先，我们定义了 <code>map</code> 和 <code>weakmap</code> 常量，分别对应 <code>Map</code> 和 <code>WeakMap</code> 的实例。接着定义了一个立即执行的函数表达式（IIFE），在函数表达式内部定义了两个对象：<code>foo</code> 和 <code>bar</code>，这两个对象分别作为 <code>map</code> 和 <code>weakmap</code> 的 <code>key</code>。当该函数表达式执行完毕后，对于对象 <code>foo</code> 来说，它仍然作为 <code>map</code> 的 <code>key</code> 被引用着，因此<strong>垃圾回收器</strong>（grabage collector）不会把它从内存中移除，我们仍然可以通过 <code>map.keys</code> 打印出对象 <code>foo</code>。然而对于对象 <code>bar</code> 来说，由于 <code>WeakMap</code> 的 <code>key</code> 是弱引用，它不影响垃圾回收器的工作，所以一旦表达式执行完毕，垃圾回收器就会把对象 <code>bar</code> 从内存中移除，并且我们无法获取 <code>weakmap</code> 的 <code>key</code> 值，也就无法通过 <code>weakmap</code> 取得对象 <code>bar</code>。</p>\r\n<p>简单地说，<code>WeakMap</code> 对 <code>key</code> 是弱引用，不影响垃圾回收器的工作。据这个特性可知，一旦 <code>key</code> 被垃圾回收器回收，那么对应的键和值就访问不到了。所以 <code>WeakMap</code> 经常用于存储那些只有当 <code>key</code> 所引用的对象存在时（没有被回收）才有价值的信息，例如上面的场景中，如果 <code>target</code> 对象没有任何引用了，说明用户侧不再需要它了，这时垃圾回收器会完成回收任务。但如果使用 <code>Map</code> 来代替 <code>WeakMap</code>，那么即使用户侧的代码对 <code>target</code> 没有任何引用，这个 <code>target</code> 也不会被回收，最终可能导致内存溢出。</p>\r\n<p>最后，我们对上文中的代码做一些封装处理。在目前的实现中，当读取属性值时，我们直接在 <code>get</code> 拦截函数里编写把副作用函数收集到“桶”里的这部分逻辑，但更好的做法是将这部分逻辑单独封装到一个 <code>track</code> 函数中，函数的名字叫 <code>track</code> 是为了表达<strong>追踪</strong>的含义。同样，我们也可以把<strong>触发</strong>副作用函数重新执行的逻辑封装到 <code>trigger</code> 函数中：</p>\r\n<pre class=\"no-line-number\"><code>01 const obj = new Proxy(data, {\r\n02   // 拦截读取操作\r\n03   get(target, key) {\r\n04     // 将副作用函数 activeEffect 添加到存储副作用函数的桶中\r\n05     track(target, key)\r\n06     // 返回属性值\r\n07     return target[key]\r\n08   },\r\n09   // 拦截设置操作\r\n10   set(target, key, newVal) {\r\n11     // 设置属性值\r\n12     target[key] = newVal\r\n13     // 把副作用函数从桶里取出并执行\r\n14     trigger(target, key)\r\n15   }\r\n16 })\r\n17\r\n18 // 在 get 拦截函数内调用 track 函数追踪变化\r\n19 function track(target, key) {\r\n20   // 没有 activeEffect，直接 return\r\n21   if (!activeEffect) return\r\n22   let depsMap = bucket.get(target)\r\n23   if (!depsMap) {\r\n24     bucket.set(target, (depsMap = new Map()))\r\n25   }\r\n26   let deps = depsMap.get(key)\r\n27   if (!deps) {\r\n28     depsMap.set(key, (deps = new Set()))\r\n29   }\r\n30   deps.add(activeEffect)\r\n31 }\r\n32 // 在 set 拦截函数内调用 trigger 函数触发变化\r\n33 function trigger(target, key) {\r\n34   const depsMap = bucket.get(target)\r\n35   if (!depsMap) return\r\n36   const effects = depsMap.get(key)\r\n37   effects &amp;&amp; effects.forEach(fn =&gt; fn())\r\n38 }</code></pre>\r\n<p>如以上代码所示，分别把逻辑封装到 <code>track</code> 和 <code>trigger</code> 函数内，这能为我们带来极大的灵活性。</p>\r\n<h2 id=\"nav_point_35\">4.4　分支切换与 <code>cleanup</code></h2>\r\n<p>首先，我们需要明确分支切换的定义，如下面的代码所示：</p>\r\n<pre class=\"no-line-number\"><code>01 const data = { ok: true, text: 'hello world' }\r\n02 const obj = new Proxy(data, { /* ... */ })\r\n03\r\n04 effect(function effectFn() {\r\n05   document.body.innerText = obj.ok ? obj.text : 'not'\r\n06 })</code></pre>\r\n<p>在 <code>effectFn</code> 函数内部存在一个三元表达式，根据字段 <code>obj.ok</code> 值的不同会执行不同的代码分支。当字段 <code>obj.ok</code> 的值发生变化时，代码执行的分支会跟着变化，这就是所谓的分支切换。</p>\r\n<p>分支切换可能会产生遗留的副作用函数。拿上面这段代码来说，字段 <code>obj.ok</code> 的初始值为 <code>true</code>，这时会读取字段 <code>obj.text</code> 的值，所以当 <code>effectFn</code> 函数执行时会触发字段 <code>obj.ok</code> 和字段 <code>obj.text</code> 这两个属性的读取操作，此时副作用函数 <code>effectFn</code> 与响应式数据之间建立的联系如下：</p>\r\n<pre class=\"no-line-number\"><code>01 data\r\n02     └── ok\r\n03         └── effectFn\r\n04     └── text\r\n05         └── effectFn</code></pre>\r\n<p>图 4-4 给出了更详细的描述。</p>\r\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00501.jpeg\" alt=\"\" width=\"85%\" style=\"width: 85%\" /></p>\r\n<p class=\"ebook-image-title\"><strong>图 4-4　副作用函数与响应式数据之间的联系</strong></p>\r\n<p>可以看到，副作用函数 <code>effectFn</code> 分别被字段 <code>data.ok</code> 和字段 <code>data.text</code> 所对应的依赖集合收集。当字段 <code>obj.ok</code> 的值修改为 <code>false</code>，并触发副作用函数重新执行后，由于此时字段 <code>obj.text</code> 不会被读取，只会触发字段 <code>obj.ok</code> 的读取操作，所以理想情况下副作用函数 <code>effectFn</code> 不应该被字段 <code>obj.text</code> 所对应的依赖集合收集，如图 4-5 所示。</p>\r\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00502.jpeg\" alt=\"\" width=\"85%\" style=\"width: 85%\" /></p>\r\n<p class=\"ebook-image-title\"><strong>图 4-5　理想情况下副作用函数与响应式数据之间的联系</strong></p>\r\n<p>但按照前文的实现，我们还做不到这一点。也就是说，当我们把字段 <code>obj.ok</code> 的值修改为 <code>false</code>，并触发副作用函数重新执行之后，整个依赖关系仍然保持图 4-4 所描述的那样，这时就产生了遗留的副作用函数。</p>\r\n<p>遗留的副作用函数会导致不必要的更新，拿下面这段代码来说：</p>\r\n<pre class=\"no-line-number\"><code>01 const data = { ok: true, text: 'hello world' }\r\n02 const obj = new Proxy(data, { /* ... */ })\r\n03\r\n04 effect(function effectFn() {\r\n05   document.body.innerText = obj.ok ? obj.text : 'not'\r\n06 })</code></pre>\r\n<p><code>obj.ok</code> 的初始值为 <code>true</code>，当我们将其修改为 <code>false</code> 后：</p>\r\n<pre class=\"no-line-number\"><code>01 obj.ok = false</code></pre>\r\n<p>这会触发更新，即副作用函数会重新执行。但由于此时 <code>obj.ok</code> 的值为 <code>false</code>，所以不再会读取字段 <code>obj.text</code> 的值。换句话说，无论字段 <code>obj.text</code> 的值如何改变，<code>document.body.innerText</code> 的值始终都是字符串 <code>'not'</code>。所以最好的结果是，无论 <code>obj.text</code> 的值怎么变，都不需要重新执行副作用函数。但事实并非如此，如果我们再尝试修改 <code>obj.text</code> 的值：</p>\r\n<pre class=\"no-line-number\"><code>01 obj.text = 'hello vue3'</code></pre>\r\n<p>这仍然会导致副作用函数重新执行，即使 <code>document.body.innerText</code> 的值不需要变化。</p>\r\n<p>解决这个问题的思路很简单，每次副作用函数执行时，我们可以先把它从所有与之关联的依赖集合中删除，如图 4-6 所示。</p>\r\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00503.jpeg\" alt=\"\" width=\"85%\" style=\"width: 85%\" /></p>\r\n<p class=\"ebook-image-title\"><strong>图 4-6　断开副作用函数与响应式数据之间的联系</strong></p>\r\n<p>当副作用函数执行完毕后，会重新建立联系，但在新的联系中不会包含遗留的副作用函数，即图 4-5 所描述的那样。所以，如果我们能做到每次副作用函数执行前，将其从相关联的依赖集合中移除，那么问题就迎刃而解了。</p>\r\n<p>要将一个副作用函数从所有与之关联的依赖集合中移除，就需要明确知道哪些依赖集合中包含它，因此我们需要重新设计副作用函数，如下面的代码所示。在 <code>effect</code> 内部我们定义了新的 <code>effectFn</code> 函数，并为其添加了 <code>effectFn.deps</code> 属性，该属性是一个数组，用来存储所有包含当前副作用函数的依赖集合：</p>\r\n<pre class=\"no-line-number\"><code>01 // 用一个全局变量存储被注册的副作用函数\r\n02 let activeEffect\r\n03 function effect(fn) {\r\n04   const effectFn = () =&gt; {\r\n05     // 当 effectFn 执行时，将其设置为当前激活的副作用函数\r\n06     activeEffect = effectFn\r\n07     fn()\r\n08   }\r\n09   // activeEffect.deps 用来存储所有与该副作用函数相关联的依赖集合\r\n10   effectFn.deps = []\r\n11   // 执行副作用函数\r\n12   effectFn()\r\n13 }</code></pre>\r\n<p>那么 <code>effectFn.deps</code> 数组中的依赖集合是如何收集的呢？其实是在 <code>track</code> 函数中：</p>\r\n<pre class=\"no-line-number\"><code>01 function track(target, key) {\r\n02   // 没有 activeEffect，直接 return\r\n03   if (!activeEffect) return\r\n04   let depsMap = bucket.get(target)\r\n05   if (!depsMap) {\r\n06     bucket.set(target, (depsMap = new Map()))\r\n07   }\r\n08   let deps = depsMap.get(key)\r\n09   if (!deps) {\r\n10     depsMap.set(key, (deps = new Set()))\r\n11   }\r\n12   // 把当前激活的副作用函数添加到依赖集合 deps 中\r\n13   deps.add(activeEffect)\r\n14   // deps 就是一个与当前副作用函数存在联系的依赖集合\r\n15   // 将其添加到 activeEffect.deps 数组中\r\n16   activeEffect.deps.push(deps) // 新增\r\n17 }</code></pre>\r\n<p>如以上代码所示，在 <code>track</code> 函数中我们将当前执行的副作用函数 <code>activeEffect</code> 添加到依赖集合 <code>deps</code> 中，这说明 <code>deps</code> 就是一个与当前副作用函数存在联系的依赖集合，于是我们也把它添加到 <code>activeEffect.deps</code> 数组中，这样就完成了对依赖集合的收集。图 4-7 描述了这一步所建立的关系。</p>\r\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00504.jpeg\" alt=\"\" width=\"90%\" style=\"width: 90%\" /></p>\r\n<p class=\"ebook-image-title\"><strong>图 4-7　对依赖集合的收集</strong></p>\r\n<p>有了这个联系后，我们就可以在每次副作用函数执行时，根据 <code>effectFn.deps</code> 获取所有相关联的依赖集合，进而将副作用函数从依赖集合中移除：</p>\r\n<pre class=\"no-line-number\"><code>01 // 用一个全局变量存储被注册的副作用函数\r\n02 let activeEffect\r\n03 function effect(fn) {\r\n04   const effectFn = () =&gt; {\r\n05     // 调用 cleanup 函数完成清除工作\r\n06     cleanup(effectFn)  // 新增\r\n07     activeEffect = effectFn\r\n08     fn()\r\n09   }\r\n10   effectFn.deps = []\r\n11   effectFn()\r\n12 }</code></pre>\r\n<p>下面是 <code>cleanup</code> 函数的实现：</p>\r\n<pre class=\"no-line-number\"><code>01 function cleanup(effectFn) {\r\n02   // 遍历 effectFn.deps 数组\r\n03   for (let i = 0; i &lt; effectFn.deps.length; i++) {\r\n04     // deps 是依赖集合\r\n05     const deps = effectFn.deps[i]\r\n06     // 将 effectFn 从依赖集合中移除\r\n07     deps.delete(effectFn)\r\n08   }\r\n09   // 最后需要重置 effectFn.deps 数组\r\n10   effectFn.deps.length = 0\r\n11 }</code></pre>\r\n<p><code>cleanup</code> 函数接收副作用函数作为参数，遍历副作用函数的 <code>effectFn.deps</code> 数组，该数组的每一项都是一个依赖集合，然后将该副作用函数从依赖集合中移除，最后重置 <code>effectFn.deps</code> 数组。</p>\r\n<p>至此，我们的响应系统已经可以避免副作用函数产生遗留了。但如果你尝试运行代码，会发现目前的实现会导致无限循环执行，问题出在 <code>trigger</code> 函数中：</p>\r\n<pre class=\"no-line-number\"><code>01 function trigger(target, key) {\r\n02   const depsMap = bucket.get(target)\r\n03   if (!depsMap) return\r\n04   const effects = depsMap.get(key)\r\n05   effects &amp;&amp; effects.forEach(fn =&gt; fn()) // 问题出在这句代码\r\n06 }</code></pre>\r\n<p>在 <code>trigger</code> 函数内部，我们遍历 <code>effects</code> 集合，它是一个 <code>Set</code> 集合，里面存储着副作用函数。当副作用函数执行时，会调用 <code>cleanup</code> 进行清除，实际上就是从 <code>effects</code> 集合中将当前执行的副作用函数剔除，但是副作用函数的执行会导致其重新被收集到集合中，而此时对于 <code>effects</code> 集合的遍历仍在进行。这个行为可以用如下简短的代码来表达：</p>\r\n<pre class=\"no-line-number\"><code>01 const set = new Set([1])\r\n02\r\n03 set.forEach(item =&gt; {\r\n04   set.delete(1)\r\n05   set.add(1)\r\n06   console.log('遍历中')\r\n07 })</code></pre>\r\n<p>在上面这段代码中，我们创建了一个集合 <code>set</code>，它里面有一个元素数字 <code>1</code>，接着我们调用 <code>forEach</code> 遍历该集合。在遍历过程中，首先调用 <code>delete(1)</code> 删除数字 <code>1</code>，紧接着调用 <code>add(1)</code> 将数字 <code>1</code> 加回，最后打印 <code>'遍历中'</code>。如果我们在浏览器中执行这段代码，就会发现它会无限执行下去。</p>\r\n<p>语言规范中对此有明确的说明：在调用 <code>forEach</code> 遍历 <code>Set</code> 集合时，如果一个值已经被访问过了，但该值被删除并重新添加到集合，如果此时 <code>forEach</code> 遍历没有结束，那么该值会重新被访问。因此，上面的代码会无限执行。解决办法很简单，我们可以构造另外一个 <code>Set</code> 集合并遍历它：</p>\r\n<pre class=\"no-line-number\"><code>01 const set = new Set([1])\r\n02\r\n03 const newSet = new Set(set)\r\n04 newSet.forEach(item =&gt; {\r\n05   set.delete(1)\r\n06   set.add(1)\r\n07   console.log('遍历中')\r\n08 })</code></pre>\r\n<p>这样就不会无限执行了。回到 <code>trigger</code> 函数，我们需要同样的手段来避免无限执行：</p>\r\n<pre class=\"no-line-number\"><code>01 function trigger(target, key) {\r\n02   const depsMap = bucket.get(target)\r\n03   if (!depsMap) return\r\n04   const effects = depsMap.get(key)\r\n05\r\n06   const effectsToRun = new Set(effects)  // 新增\r\n07   effectsToRun.forEach(effectFn =&gt; effectFn())  // 新增\r\n08   // effects &amp;&amp; effects.forEach(effectFn =&gt; effectFn()) // 删除\r\n09 }</code></pre>\r\n<p>如以上代码所示，我们新构造了 <code>effectsToRun</code> 集合并遍历它，代替直接遍历 <code>effects</code> 集合，从而避免了无限执行。</p>\r\n<blockquote>\r\n<p><strong>提示</strong>　</p>\r\n<p>ECMA 关于 <code>Set.prototype.forEach</code> 的规范，可参见 ECMAScript 2020 Language Specification。</p>\r\n</blockquote>\r\n<h2 id=\"nav_point_36\">4.5　嵌套的 <code>effect</code> 与 <code>effect</code> 栈</h2>\r\n<p><code>effect</code> 是可以发生嵌套的，例如：</p>\r\n<pre class=\"no-line-number\"><code>01 effect(function effectFn1() {\r\n02   effect(function effectFn2() { /* ... */ })\r\n03   /* ... */\r\n04 })</code></pre>\r\n<p>在上面这段代码中，<code>effectFn1</code> 内部嵌套了 <code>effectFn2</code>，<code>effectFn1</code> 的执行会导致 <code>effectFn2</code> 的执行。那么，什么场景下会出现嵌套的 <code>effect</code> 呢？拿 Vue.js 来说，实际上 Vue.js 的渲染函数就是在一个 <code>effect</code> 中执行的：</p>\r\n<pre class=\"no-line-number\"><code>01 // Foo 组件\r\n02 const Foo = {\r\n03   render() {\r\n04     return /* ... */\r\n05   }\r\n06 }</code></pre>\r\n<p>在一个 <code>effect</code> 中执行 <code>Foo</code> 组件的渲染函数：</p>\r\n<pre class=\"no-line-number\"><code>01 effect(() =&gt; {\r\n02   Foo.render()\r\n03 })</code></pre>\r\n<p>当组件发生嵌套时，例如 <code>Foo</code> 组件渲染了 <code>Bar</code> 组件：</p>\r\n<pre class=\"no-line-number\"><code>01 // Bar 组件\r\n02 const Bar = {\r\n03   render() { /* ... */ },\r\n04 }\r\n05 // Foo 组件渲染了 Bar 组件\r\n06 const Foo = {\r\n07   render() {\r\n08     return &lt;Bar /&gt; // jsx 语法\r\n09   },\r\n10 }</code></pre>\r\n<p>此时就发生了 <code>effect</code> 嵌套，它相当于：</p>\r\n<pre class=\"no-line-number\"><code>01 effect(() =&gt; {\r\n02   Foo.render()\r\n03   // 嵌套\r\n04   effect(() =&gt; {\r\n05     Bar.render()\r\n06   })\r\n07 })</code></pre>\r\n<p>这个例子说明了为什么 <code>effect</code> 要设计成可嵌套的。接下来，我们需要搞清楚，如果 <code>effect</code> 不支持嵌套会发生什么？实际上，按照前文的介绍与实现来看，我们所实现的响应系统并不支持 <code>effect</code> 嵌套，可以用下面的代码来测试一下：</p>\r\n<pre class=\"no-line-number\"><code>01 // 原始数据\r\n02 const data = { foo: true, bar: true }\r\n03 // 代理对象\r\n04 const obj = new Proxy(data, { /* ... */ })\r\n05\r\n06 // 全局变量\r\n07 let temp1, temp2\r\n08\r\n09 // effectFn1 嵌套了 effectFn2\r\n10 effect(function effectFn1() {\r\n11   console.log('effectFn1 执行')\r\n12\r\n13   effect(function effectFn2() {\r\n14     console.log('effectFn2 执行')\r\n15     // 在 effectFn2 中读取 obj.bar 属性\r\n16     temp2 = obj.bar\r\n17   })\r\n18   // 在 effectFn1 中读取 obj.foo 属性\r\n19   temp1 = obj.foo\r\n20 })</code></pre>\r\n<p>在上面这段代码中，<code>effectFn1</code> 内部嵌套了 <code>effectFn2</code>，很明显，<code>effectFn1</code> 的执行会导致 <code>effectFn2</code> 的执行。需要注意的是，我们在 <code>effectFn2</code> 中读取了字段 <code>obj.bar</code>，在 <code>effectFn1</code> 中读取了字段 <code>obj.foo</code>，并且 <code>effectFn2</code> 的执行先于对字段 <code>obj.foo</code> 的读取操作。在理想情况下，我们希望副作用函数与对象属性之间的联系如下：</p>\r\n<pre class=\"no-line-number\"><code>01 data\r\n02   └── foo\r\n03     └── effectFn1\r\n04   └── bar\r\n05     └── effectFn2</code></pre>\r\n<p>在这种情况下，我们希望当修改 <code>obj.foo</code> 时会触发 <code>effectFn1</code> 执行。由于 <code>effectFn2</code> 嵌套在 <code>effectFn1</code> 里，所以会间接触发 <code>effectFn2</code> 执行，而当修改 <code>obj.bar</code> 时，只会触发 <code>effectFn2</code> 执行。但结果不是这样的，我们尝试修改 <code>obj.foo</code> 的值，会发现输出为：</p>\r\n<pre class=\"no-line-number\"><code>01 'effectFn1 执行'\r\n02 'effectFn2 执行'\r\n03 'effectFn2 执行'</code></pre>\r\n<p>一共打印三次，前两次分别是副作用函数 <code>effectFn1</code> 与 <code>effectFn2</code> 初始执行的打印结果，到这一步是正常的，问题出在第三行打印。我们修改了字段 <code>obj.foo</code> 的值，发现 <code>effectFn1</code> 并没有重新执行，反而使得 <code>effectFn2</code> 重新执行了，这显然不符合预期。</p>\r\n<p>问题出在哪里呢？其实就出在我们实现的 <code>effect</code> 函数与 <code>activeEffect</code> 上。观察下面这段代码：</p>\r\n<pre class=\"no-line-number\"><code>01 // 用一个全局变量存储当前激活的 effect 函数\r\n02 let activeEffect\r\n03 function effect(fn) {\r\n04   const effectFn = () =&gt; {\r\n05     cleanup(effectFn)\r\n06     // 当调用 effect 注册副作用函数时，将副作用函数赋值给 activeEffect\r\n07     activeEffect = effectFn\r\n08     fn()\r\n09   }\r\n10   // activeEffect.deps 用来存储所有与该副作用函数相关的依赖集合\r\n11   effectFn.deps = []\r\n12   // 执行副作用函数\r\n13   effectFn()\r\n14 }</code></pre>\r\n<p>我们用全局变量 <code>activeEffect</code> 来存储通过 <code>effect</code> 函数注册的副作用函数，这意味着同一时刻 <code>activeEffect</code> 所存储的副作用函数只能有一个。当副作用函数发生嵌套时，内层副作用函数的执行会覆盖 <code>activeEffect</code> 的值，并且永远不会恢复到原来的值。这时如果再有响应式数据进行依赖收集，即使这个响应式数据是在外层副作用函数中读取的，它们收集到的副作用函数也都会是内层副作用函数，这就是问题所在。</p>\r\n<p>为了解决这个问题，我们需要一个副作用函数栈 <code>effectStack</code>，在副作用函数执行时，将当前副作用函数压入栈中，待副作用函数执行完毕后将其从栈中弹出，并始终让 <code>activeEffect</code> 指向栈顶的副作用函数。这样就能做到一个响应式数据只会收集直接读取其值的副作用函数，而不会出现互相影响的情况，如以下代码所示：</p>\r\n<pre class=\"no-line-number\"><code>01 // 用一个全局变量存储当前激活的 effect 函数\r\n02 let activeEffect\r\n03 // effect 栈\r\n04 const effectStack = []  // 新增\r\n05\r\n06 function effect(fn) {\r\n07   const effectFn = () =&gt; {\r\n08     cleanup(effectFn)\r\n09     // 当调用 effect 注册副作用函数时，将副作用函数赋值给 activeEffect\r\n10     activeEffect = effectFn\r\n11     // 在调用副作用函数之前将当前副作用函数压入栈中\r\n12     effectStack.push(effectFn)  // 新增\r\n13     fn()\r\n14     // 在当前副作用函数执行完毕后，将当前副作用函数弹出栈，并把 activeEffect 还原为之前的值\r\n15     effectStack.pop()  // 新增\r\n16     activeEffect = effectStack[effectStack.length - 1]  // 新增\r\n17   }\r\n18   // activeEffect.deps 用来存储所有与该副作用函数相关的依赖集合\r\n19   effectFn.deps = []\r\n20   // 执行副作用函数\r\n21   effectFn()\r\n22 }</code></pre>\r\n<p>我们定义了 <code>effectStack</code> 数组，用它来模拟栈，<code>activeEffect</code> 没有变化，它仍然指向当前正在执行的副作用函数。不同的是，当前执行的副作用函数会被压入栈顶，这样当副作用函数发生嵌套时，栈底存储的就是外层副作用函数，而栈顶存储的则是内层副作用函数，如图 4-8 所示。</p>\r\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00505.jpeg\" alt=\"\" width=\"50%\" style=\"width: 50%\" /></p>\r\n<p class=\"ebook-image-title\"><strong>图 4-8　副作用函数栈</strong></p>\r\n<p>当内层副作用函数 <code>effectFn2</code> 执行完毕后，它会被弹出栈，并将副作用函数 <code>effectFn1</code> 设置为 <code>activeEffect</code>，如图 4-9 所示。</p>\r\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00506.jpeg\" alt=\"\" width=\"50%\" style=\"width: 50%\" /></p>\r\n<p class=\"ebook-image-title\"><strong>图 4-9　副作用函数从栈中弹出</strong></p>\r\n<p>如此一来，响应式数据就只会收集直接读取其值的副作用函数作为依赖，从而避免发生错乱。</p>\r\n<h2 id=\"nav_point_37\">4.6　避免无限递归循环</h2>\r\n<p>如前文所说，实现一个完善的响应系统要考虑诸多细节。而本节要介绍的无限递归循环就是其中之一，还是举个例子：</p>\r\n<pre class=\"no-line-number\"><code>01 const data = { foo: 1 }\r\n02 const obj = new Proxy(data, { /*...*/ })\r\n03\r\n04 effect(() =&gt; obj.foo++)</code></pre>\r\n<p>可以看到，在 <code>effect</code> 注册的副作用函数内有一个自增操作 <code>obj.foo++</code>，该操作会引起栈溢出：</p>\r\n<pre class=\"no-line-number\"><code>01 Uncaught RangeError: Maximum call stack size exceeded</code></pre>\r\n<p>为什么会这样呢？接下来我们就尝试搞清楚这个问题，并提供解决方案。</p>\r\n<p>实际上，我们可以把 <code>obj.foo++</code> 这个自增操作分开来看，它相当于：</p>\r\n<pre class=\"no-line-number\"><code>01 effect(() =&gt; {\r\n02   // 语句\r\n03   obj.foo = obj.foo + 1\r\n04 })</code></pre>\r\n<p>在这个语句中，既会读取 <code>obj.foo</code> 的值，又会设置 <code>obj.foo</code> 的值，而这就是导致问题的根本原因。我们可以尝试推理一下代码的执行流程：首先读取 <code>obj.foo</code> 的值，这会触发 <code>track</code> 操作，将当前副作用函数收集到“桶”中，接着将其加 <code>1</code> 后再赋值给 <code>obj.foo</code>，此时会触发 <code>trigger</code> 操作，即把“桶”中的副作用函数取出并执行。但问题是该副作用函数正在执行中，还没有执行完毕，就要开始下一次的执行。这样会导致无限递归地调用自己，于是就产生了栈溢出。</p>\r\n<p>解决办法并不难。通过分析这个问题我们能够发现，读取和设置操作是在同一个副作用函数内进行的。此时无论是 <code>track</code> 时收集的副作用函数，还是 <code>trigger</code> 时要触发执行的副作用函数，都是 <code>activeEffect</code>。基于此，我们可以在 <code>trigger</code> 动作发生时增加守卫条件：<strong>如果 <code>trigger</code> 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行</strong>，如以下代码所示：</p>\r\n<pre class=\"no-line-number\"><code>01 function trigger(target, key) {\r\n02   const depsMap = bucket.get(target)\r\n03   if (!depsMap) return\r\n04   const effects = depsMap.get(key)\r\n05\r\n06   const effectsToRun = new Set()\r\n07   effects &amp;&amp; effects.forEach(effectFn =&gt; {\r\n08     // 如果 trigger 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行\r\n09     if (effectFn !== activeEffect) {  // 新增\r\n10       effectsToRun.add(effectFn)\r\n11     }\r\n12   })\r\n13   effectsToRun.forEach(effectFn =&gt; effectFn())\r\n14   // effects &amp;&amp; effects.forEach(effectFn =&gt; effectFn())\r\n15 }</code></pre>\r\n<p>这样我们就能够避免无限递归调用，从而避免栈溢出。</p>\r\n","comments":[{"had_liked":false,"id":386694,"user_name":"haoleir","can_delete":false,"product_type":"c1","uid":1273252,"ip_address":"广东","ucode":"3FAC05601B5752","user_header":"https://static001.geekbang.org/account/avatar/00/13/6d/a4/e07825c8.jpg","comment_is_top":false,"comment_ctime":1705366211,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100636603,"comment_content":"“采用 Proxy 来实现”，后面的代码块有丢失。还有前面两章的代码部分，也是有类似情况，麻烦再检查下~","like_count":0,"discussions":[{"author":{"id":2852467,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/86/73/5190bbde.jpg","nickname":"苏果果","note":"","ucode":"12A62ED032F345","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635911,"discussion_content":"好的，我们看看～谢谢反馈！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705371744,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}