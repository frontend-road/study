{"id":225904,"title":"72 | 解释器模式：如何设计实现一个自定义接口告警规则功能？","content":"<p>上一节课，我们学习了命令模式。命令模式将请求封装成对象，方便作为函数参数传递和赋值给变量。它主要的应用场景是给命令的执行附加功能，换句话说，就是控制命令的执行，比如，排队、异步、延迟执行命令、给命令执行记录日志、撤销重做命令等等。总体上来讲，命令模式的应用范围并不广。</p><p>今天，我们来学习解释器模式，它用来描述如何构建一个简单的“语言”解释器。比起命令模式，解释器模式更加小众，只在一些特定的领域会被用到，比如编译器、规则引擎、正则表达式。所以，解释器模式也不是我们学习的重点，你稍微了解一下就可以了。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>解释器模式的原理和实现</h2><p>解释器模式的英文翻译是Interpreter Design Pattern。在GoF的《设计模式》一书中，它是这样定义的：</p><blockquote>\n<p>Interpreter pattern is used to defines a grammatical representation for a language and provides an interpreter to deal with this grammar.</p>\n</blockquote><p>翻译成中文就是：解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。</p><!-- [[[read_end]]] --><p>看了定义，你估计会一头雾水，因为这里面有很多我们平时开发中很少接触的概念，比如“语言”“语法”“解释器”。实际上，这里的“语言”不仅仅指我们平时说的中、英、日、法等各种语言。从广义上来讲，只要是能承载信息的载体，我们都可以称之为“语言”，比如，古代的结绳记事、盲文、哑语、摩斯密码等。</p><p>要想了解“语言”表达的信息，我们就必须定义相应的语法规则。这样，书写者就可以根据语法规则来书写“句子”（专业点的叫法应该是“表达式”），阅读者根据语法规则来阅读“句子”，这样才能做到信息的正确传递。而我们要讲的解释器模式，其实就是用来实现根据语法规则解读“句子”的解释器。</p><p>为了让你更好地理解定义，我举一个比较贴近生活的例子来解释一下。</p><p>实际上，理解这个概念，我们可以类比中英文翻译。我们知道，把英文翻译成中文是有一定规则的。这个规则就是定义中的“语法”。我们开发一个类似Google Translate这样的翻译器，这个翻译器能够根据语法规则，将输入的中文翻译成英文。这里的翻译器就是解释器模式定义中的“解释器”。</p><p>刚刚翻译器这个例子比较贴近生活，现在，我们再举个更加贴近编程的例子。</p><p>假设我们定义了一个新的加减乘除计算“语言”，语法规则如下：</p><ul>\n<li>运算符只包含加、减、乘、除，并且没有优先级的概念；</li>\n<li>表达式（也就是前面提到的“句子”）中，先书写数字，后书写运算符，空格隔开；</li>\n<li>按照先后顺序，取出两个数字和一个运算符计算结果，结果重新放入数字的最头部位置，循环上述过程，直到只剩下一个数字，这个数字就是表达式最终的计算结果。</li>\n</ul><p>我们举个例子来解释一下上面的语法规则。</p><p>比如“ 8 3 2 4 - + * ”这样一个表达式，我们按照上面的语法规则来处理，取出数字“8 3”和“-”运算符，计算得到5，于是表达式就变成了“ 5 2 4 + * ”。然后，我们再取出“ 5 2 ”和“ + ”运算符，计算得到7，表达式就变成了“ 7 4 * ”。最后，我们取出“ 7 4”和“ * ”运算符，最终得到的结果就是28。</p><p>看懂了上面的语法规则，我们将它用代码实现出来，如下所示。代码非常简单，用户按照上面的规则书写表达式，传递给interpret()函数，就可以得到最终的计算结果。</p><pre><code>public class ExpressionInterpreter {\n  private Deque&lt;Long&gt; numbers = new LinkedList&lt;&gt;();\n\n  public long interpret(String expression) {\n    String[] elements = expression.split(&quot; &quot;);\n    int length = elements.length;\n    for (int i = 0; i &lt; (length+1)/2; ++i) {\n      numbers.addLast(Long.parseLong(elements[i]));\n    }\n\n    for (int i = (length+1)/2; i &lt; length; ++i) {\n      String operator = elements[i];\n      boolean isValid = &quot;+&quot;.equals(operator) || &quot;-&quot;.equals(operator)\n              || &quot;*&quot;.equals(operator) || &quot;/&quot;.equals(operator);\n      if (!isValid) {\n        throw new RuntimeException(&quot;Expression is invalid: &quot; + expression);\n      }\n\n      long number1 = numbers.pollFirst();\n      long number2 = numbers.pollFirst();\n      long result = 0;\n      if (operator.equals(&quot;+&quot;)) {\n        result = number1 + number2;\n      } else if (operator.equals(&quot;-&quot;)) {\n        result = number1 - number2;\n      } else if (operator.equals(&quot;*&quot;)) {\n        result = number1 * number2;\n      } else if (operator.equals(&quot;/&quot;)) {\n        result = number1 / number2;\n      }\n      numbers.addFirst(result);\n    }\n\n    if (numbers.size() != 1) {\n      throw new RuntimeException(&quot;Expression is invalid: &quot; + expression);\n    }\n\n    return numbers.pop();\n  }\n}\n</code></pre><p>在上面的代码实现中，语法规则的解析逻辑（第23、25、27、29行）都集中在一个函数中，对于简单的语法规则的解析，这样的设计就足够了。但是，对于复杂的语法规则的解析，逻辑复杂，代码量多，所有的解析逻辑都耦合在一个函数中，这样显然是不合适的。这个时候，我们就要考虑拆分代码，将解析逻辑拆分到独立的小类中。</p><p>该怎么拆分呢？我们可以借助解释器模式。</p><p>解释器模式的代码实现比较灵活，没有固定的模板。我们前面也说过，应用设计模式主要是应对代码的复杂性，实际上，解释器模式也不例外。它的代码实现的核心思想，就是将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分成一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。</p><p>前面定义的语法规则有两类表达式，一类是数字，一类是运算符，运算符又包括加减乘除。利用解释器模式，我们把解析的工作拆分到NumberExpression、AdditionExpression、SubstractionExpression、MultiplicationExpression、DivisionExpression这样五个解析类中。</p><p>按照这个思路，我们对代码进行重构，重构之后的代码如下所示。当然，因为加减乘除表达式的解析比较简单，利用解释器模式的设计思路，看起来有点过度设计。不过呢，这里我主要是为了解释原理，你明白意思就好，不用过度细究这个例子。</p><pre><code>public interface Expression {\n  long interpret();\n}\n\npublic class NumberExpression implements Expression {\n  private long number;\n\n  public NumberExpression(long number) {\n    this.number = number;\n  }\n\n  public NumberExpression(String number) {\n    this.number = Long.parseLong(number);\n  }\n\n  @Override\n  public long interpret() {\n    return this.number;\n  }\n}\n\npublic class AdditionExpression implements Expression {\n  private Expression exp1;\n  private Expression exp2;\n\n  public AdditionExpression(Expression exp1, Expression exp2) {\n    this.exp1 = exp1;\n    this.exp2 = exp2;\n  }\n\n  @Override\n  public long interpret() {\n    return exp1.interpret() + exp2.interpret();\n  }\n}\n// SubstractionExpression/MultiplicationExpression/DivisionExpression与AdditionExpression代码结构类似，这里就省略了\n\npublic class ExpressionInterpreter {\n  private Deque&lt;Expression&gt; numbers = new LinkedList&lt;&gt;();\n\n  public long interpret(String expression) {\n    String[] elements = expression.split(&quot; &quot;);\n    int length = elements.length;\n    for (int i = 0; i &lt; (length+1)/2; ++i) {\n      numbers.addLast(new NumberExpression(elements[i]));\n    }\n\n    for (int i = (length+1)/2; i &lt; length; ++i) {\n      String operator = elements[i];\n      boolean isValid = &quot;+&quot;.equals(operator) || &quot;-&quot;.equals(operator)\n              || &quot;*&quot;.equals(operator) || &quot;/&quot;.equals(operator);\n      if (!isValid) {\n        throw new RuntimeException(&quot;Expression is invalid: &quot; + expression);\n      }\n\n      Expression exp1 = numbers.pollFirst();\n      Expression exp2 = numbers.pollFirst();\n      Expression combinedExp = null;\n      if (operator.equals(&quot;+&quot;)) {\n        combinedExp = new AdditionExpression(exp1, exp2);\n      } else if (operator.equals(&quot;-&quot;)) {\n        combinedExp = new AdditionExpression(exp1, exp2);\n      } else if (operator.equals(&quot;*&quot;)) {\n        combinedExp = new AdditionExpression(exp1, exp2);\n      } else if (operator.equals(&quot;/&quot;)) {\n        combinedExp = new AdditionExpression(exp1, exp2);\n      }\n      long result = combinedExp.interpret();\n      numbers.addFirst(new NumberExpression(result));\n    }\n\n    if (numbers.size() != 1) {\n      throw new RuntimeException(&quot;Expression is invalid: &quot; + expression);\n    }\n\n    return numbers.pop().interpret();\n  }\n}\n</code></pre><h2>解释器模式实战举例</h2><p>接下来，我们再来看一个更加接近实战的例子，也就是咱们今天标题中的问题：如何实现一个自定义接口告警规则功能？</p><p>在我们平时的项目开发中，监控系统非常重要，它可以时刻监控业务系统的运行情况，及时将异常报告给开发者。比如，如果每分钟接口出错数超过100，监控系统就通过短信、微信、邮件等方式发送告警给开发者。</p><p>一般来讲，监控系统支持开发者自定义告警规则，比如我们可以用下面这样一个表达式，来表示一个告警规则，它表达的意思是：每分钟API总出错数超过100或者每分钟API总调用数超过10000就触发告警。</p><pre><code>api_error_per_minute &gt; 100 || api_count_per_minute &gt; 10000\n</code></pre><p>在监控系统中，告警模块只负责根据统计数据和告警规则，判断是否触发告警。至于每分钟API接口出错数、每分钟接口调用数等统计数据的计算，是由其他模块来负责的。其他模块将统计数据放到一个Map中（数据的格式如下所示），发送给告警模块。接下来，我们只关注告警模块。</p><pre><code>Map&lt;String, Long&gt; apiStat = new HashMap&lt;&gt;();\napiStat.put(&quot;api_error_per_minute&quot;, 103);\napiStat.put(&quot;api_count_per_minute&quot;, 987);\n</code></pre><p>为了简化讲解和代码实现，我们假设自定义的告警规则只包含“||、&amp;&amp;、&gt;、&lt;、==”这五个运算符，其中，“&gt;、&lt;、==”运算符的优先级高于“||、&amp;&amp;”运算符，“&amp;&amp;”运算符优先级高于“||”。在表达式中，任意元素之间需要通过空格来分隔。除此之外，用户可以自定义要监控的key，比如前面的api_error_per_minute、api_count_per_minute。</p><p>那如何实现上面的需求呢？我写了一个骨架代码，如下所示，其中的核心的实现我没有给出，你可以当作面试题，自己试着去补全一下，然后再看我的讲解。</p><pre><code>public class AlertRuleInterpreter {\n\n  // key1 &gt; 100 &amp;&amp; key2 &lt; 1000 || key3 == 200\n  public AlertRuleInterpreter(String ruleExpression) {\n    //TODO:由你来完善\n  }\n\n  //&lt;String, Long&gt; apiStat = new HashMap&lt;&gt;();\n  //apiStat.put(&quot;key1&quot;, 103);\n  //apiStat.put(&quot;key2&quot;, 987);\n  public boolean interpret(Map&lt;String, Long&gt; stats) {\n    //TODO:由你来完善\n  }\n\n}\n\npublic class DemoTest {\n  public static void main(String[] args) {\n    String rule = &quot;key1 &gt; 100 &amp;&amp; key2 &lt; 30 || key3 &lt; 100 || key4 == 88&quot;;\n    AlertRuleInterpreter interpreter = new AlertRuleInterpreter(rule);\n    Map&lt;String, Long&gt; stats = new HashMap&lt;&gt;();\n    stats.put(&quot;key1&quot;, 101l);\n    stats.put(&quot;key3&quot;, 121l);\n    stats.put(&quot;key4&quot;, 88l);\n    boolean alert = interpreter.interpret(stats);\n    System.out.println(alert);\n  }\n}\n</code></pre><p>实际上，我们可以把自定义的告警规则，看作一种特殊“语言”的语法规则。我们实现一个解释器，能够根据规则，针对用户输入的数据，判断是否触发告警。利用解释器模式，我们把解析表达式的逻辑拆分到各个小类中，避免大而复杂的大类的出现。按照这个实现思路，我把刚刚的代码补全，如下所示，你可以拿你写的代码跟我写的对比一下。</p><pre><code>public interface Expression {\n  boolean interpret(Map&lt;String, Long&gt; stats);\n}\n\npublic class GreaterExpression implements Expression {\n  private String key;\n  private long value;\n\n  public GreaterExpression(String strExpression) {\n    String[] elements = strExpression.trim().split(&quot;\\\\s+&quot;);\n    if (elements.length != 3 || !elements[1].trim().equals(&quot;&gt;&quot;)) {\n      throw new RuntimeException(&quot;Expression is invalid: &quot; + strExpression);\n    }\n    this.key = elements[0].trim();\n    this.value = Long.parseLong(elements[2].trim());\n  }\n\n  public GreaterExpression(String key, long value) {\n    this.key = key;\n    this.value = value;\n  }\n\n  @Override\n  public boolean interpret(Map&lt;String, Long&gt; stats) {\n    if (!stats.containsKey(key)) {\n      return false;\n    }\n    long statValue = stats.get(key);\n    return statValue &gt; value;\n  }\n}\n\n// LessExpression/EqualExpression跟GreaterExpression代码类似，这里就省略了\n\npublic class AndExpression implements Expression {\n  private List&lt;Expression&gt; expressions = new ArrayList&lt;&gt;();\n\n  public AndExpression(String strAndExpression) {\n    String[] strExpressions = strAndExpression.split(&quot;&amp;&amp;&quot;);\n    for (String strExpr : strExpressions) {\n      if (strExpr.contains(&quot;&gt;&quot;)) {\n        expressions.add(new GreaterExpression(strExpr));\n      } else if (strExpr.contains(&quot;&lt;&quot;)) {\n        expressions.add(new LessExpression(strExpr));\n      } else if (strExpr.contains(&quot;==&quot;)) {\n        expressions.add(new EqualExpression(strExpr));\n      } else {\n        throw new RuntimeException(&quot;Expression is invalid: &quot; + strAndExpression);\n      }\n    }\n  }\n\n  public AndExpression(List&lt;Expression&gt; expressions) {\n    this.expressions.addAll(expressions);\n  }\n\n  @Override\n  public boolean interpret(Map&lt;String, Long&gt; stats) {\n    for (Expression expr : expressions) {\n      if (!expr.interpret(stats)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n}\n\npublic class OrExpression implements Expression {\n  private List&lt;Expression&gt; expressions = new ArrayList&lt;&gt;();\n\n  public OrExpression(String strOrExpression) {\n    String[] andExpressions = strOrExpression.split(&quot;\\\\|\\\\|&quot;);\n    for (String andExpr : andExpressions) {\n      expressions.add(new AndExpression(andExpr));\n    }\n  }\n\n  public OrExpression(List&lt;Expression&gt; expressions) {\n    this.expressions.addAll(expressions);\n  }\n\n  @Override\n  public boolean interpret(Map&lt;String, Long&gt; stats) {\n    for (Expression expr : expressions) {\n      if (expr.interpret(stats)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\npublic class AlertRuleInterpreter {\n  private Expression expression;\n\n  public AlertRuleInterpreter(String ruleExpression) {\n    this.expression = new OrExpression(ruleExpression);\n  }\n\n  public boolean interpret(Map&lt;String, Long&gt; stats) {\n    return expression.interpret(stats);\n  }\n} \n</code></pre><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。实际上，这里的“语言”不仅仅指我们平时说的中、英、日、法等各种语言。从广义上来讲，只要是能承载信息的载体，我们都可以称之为“语言”，比如，古代的结绳记事、盲文、哑语、摩斯密码等。</p><p>要想了解“语言”要表达的信息，我们就必须定义相应的语法规则。这样，书写者就可以根据语法规则来书写“句子”（专业点的叫法应该是“表达式”），阅读者根据语法规则来阅读“句子”，这样才能做到信息的正确传递。而我们要讲的解释器模式，其实就是用来实现根据语法规则解读“句子”的解释器。</p><p>解释器模式的代码实现比较灵活，没有固定的模板。我们前面说过，应用设计模式主要是应对代码的复杂性，解释器模式也不例外。它的代码实现的核心思想，就是将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。</p><h2>课堂讨论</h2><p>1.在你过往的项目经历或阅读源码的时候，有没有用到或者见过解释器模式呢？<br>\n2.在告警规则解析的例子中，如果我们要在表达式中支持括号“（）”，那如何对代码进行重构呢？你可以把它当作练习，试着编写一下代码。</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"71 | 命令模式：如何利用命令模式实现一个手游后端架构？","id":224549},"right":{"article_title":"73 | 中介模式：什么时候用中介模式？什么时候用观察者模式？","id":226710}},"comments":[{"had_liked":false,"id":207853,"user_name":"Panmax","can_delete":false,"product_type":"c1","uid":1004871,"ip_address":"","ucode":"9D65E3B84C5519","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/47/d217c45f.jpg","comment_is_top":false,"comment_ctime":1587197722,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"267875170074","product_id":100039001,"comment_content":"第二个代码示例中的代码段：<br>  if (operator.equals(&quot;+&quot;)) {<br>    combinedExp = new AdditionExpression(exp1, exp2);<br>  } else if (operator.equals(&quot;-&quot;)) {<br>    combinedExp = new AdditionExpression(exp1, exp2);<br>  } else if (operator.equals(&quot;*&quot;)) {<br>    combinedExp = new AdditionExpression(exp1, exp2);<br>  } else if (operator.equals(&quot;&#47;&quot;)) {<br>    combinedExp = new AdditionExpression(exp1, exp2);<br>  }<br>应改为：<br>  if (operator.equals(&quot;+&quot;)) {<br>    combinedExp = new AdditionExpression(exp1, exp2);<br>  } else if (operator.equals(&quot;-&quot;)) {<br>    combinedExp = new SubstractionExpression(exp1, exp2);<br>  } else if (operator.equals(&quot;*&quot;)) {<br>    combinedExp = new MultiplicationExpression(exp1, exp2);<br>  } else if (operator.equals(&quot;&#47;&quot;)) {<br>    combinedExp = new DivisionExpression(exp1, exp2);<br>  }","like_count":63,"discussions":[{"author":{"id":2699218,"avatar":"","nickname":"Geek_279849","note":"","ucode":"FC6A3514FC955C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558167,"discussion_content":"👍现在还没改","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1648111681,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1202465,"avatar":"https://static001.geekbang.org/account/avatar/00/12/59/21/d2efde18.jpg","nickname":"布凡","note":"","ucode":"346FCD332F8BFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546069,"discussion_content":"现在都没改过来……","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1642149248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1125548,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2c/ac/551b6936.jpg","nickname":"ShaneMao","note":"","ucode":"48B5944B95DEE6","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582767,"discussion_content":"现在还没改","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659666392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"重庆"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1616622,"avatar":"https://static001.geekbang.org/account/avatar/00/18/aa/ee/15c328ca.jpg","nickname":"ɴɪᴋᴇʀ","note":"","ucode":"DB7D92CBB5FD15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557422,"discussion_content":"哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647792895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214247,"user_name":"LiuHu","can_delete":false,"product_type":"c1","uid":1039768,"ip_address":"","ucode":"284E2025C554BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/dd/98/883c42b4.jpg","comment_is_top":false,"comment_ctime":1588683898,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"139027637370","product_id":100039001,"comment_content":"SpEL（Spring Expression Language )  就是典型的解释器模式实现。<br>在项目中实现简单的自动化规则过滤器，就是将过滤器配置翻译成 SpEL 表达式执行的","like_count":33},{"had_liked":false,"id":207828,"user_name":"迷羊","can_delete":false,"product_type":"c1","uid":1286251,"ip_address":"","ucode":"85AF8CED3436C8","user_header":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","comment_is_top":false,"comment_ctime":1587191752,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"53126799304","product_id":100039001,"comment_content":"因为做的是数据类型的项目，就是根据自定义的SQL来创建API以供可以通过http形式直接调用，项目中就是用Druid来解析SQL的，用的就是解释器模式，SQL语句中的每个字符对应一个表达式。","like_count":13,"discussions":[{"author":{"id":1068361,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","nickname":"明翼","note":"","ucode":"E77F86BEB3D5C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":243065,"discussion_content":"自动根据sql创建接口，这个挺好的想法","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587518684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1068361,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","nickname":"明翼","note":"","ucode":"E77F86BEB3D5C1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":258380,"discussion_content":"主要功能就是用来方便控制权限访问，可以给企业二次开发。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1588683658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":243065,"ip_address":""},"score":258380,"extra":""}]},{"author":{"id":2550743,"avatar":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","nickname":"if...else...","note":"","ucode":"D0565908C99695","race_medal":4,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380347,"discussion_content":"根据sql自动生成接口😳","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624449669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212639,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1588168446,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"44537841406","product_id":100039001,"comment_content":"我是做风控技术的，发现这个模式对我理解规则引擎的设计很有帮助","like_count":11},{"had_liked":false,"id":207380,"user_name":"Ken张云忠","can_delete":false,"product_type":"c1","uid":1134288,"ip_address":"","ucode":"D0BAC9FC17DE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","comment_is_top":false,"comment_ctime":1587074337,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"44536747297","product_id":100039001,"comment_content":"Java中注解处理器做的就是解释的功能，以及前端编译时的语法分析、语义分析，后端编译时生成的中间表达式，用来触发更多优化，优化的处理可以理解为高效的解释，最终生成机器可以执行的汇编指令。","like_count":11,"discussions":[{"author":{"id":1344431,"avatar":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","nickname":"马以","note":"","ucode":"3FEA06CA14DE28","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":236281,"discussion_content":"那你要这么说，编译器才是王者","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587085405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1701867,"avatar":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","nickname":"，","note":"","ucode":"A5543C8DFEB198","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1344431,"avatar":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","nickname":"马以","note":"","ucode":"3FEA06CA14DE28","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":240235,"discussion_content":"编译器本来就挺复杂的,不管是前端编译还是后端编译,不过他说的注解处理器,我觉得主要目的应该是对代码进行附加处理,比如规范校验,生成gettersetter等等,就像lombok那样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587347135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":236281,"ip_address":""},"score":240235,"extra":""}]}]},{"had_liked":false,"id":207640,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1587126404,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"40241832068","product_id":100039001,"comment_content":"关于问题一，使用过。偏向科研，自定义一门语言，然后通过语法解析器分析读入。<br>例如使用RDDL(Relational Domain Definition Language)关系领域定义语言描述马尔可夫决策过程。<br>domain prop_dbn {<br>  \t<br>\trequirements = { reward-deterministic };<br>      \t<br>\tpvariables { <br>\t\tp : { state-fluent,  bool, default = false };<br>\t\tq : { state-fluent,  bool, default = false };<br>\t\tr : { state-fluent,  bool, default = false }; <br>\t\ta : { action-fluent, bool, default = false }; <br>\t};<br>  <br>\tcpfs {<br>\t\t&#47;&#47; Some standard Bernoulli conditional probability tables<br>\t\tp&#39; = if (p ^ r) then Bernoulli(.9) else Bernoulli(.3);<br>\t\t\t\t\t\t<br>\t\tq&#39; = if (q ^ r) then Bernoulli(.9) <br>\t\t\t\t\t\telse if (a) then Bernoulli(.3) else Bernoulli(.8);<br><br>\t\t&#47;&#47; KronDelta is like a DiracDelta, but for discrete data (boolean or int)<br>\t\tr&#39; = if (~q) then KronDelta(r) else KronDelta(r &lt;=&gt; q);\t\t\t\t\t\t\t\t\t\t<br>\t};<br>    <br>\t&#47;&#47; A boolean functions as a 0&#47;1 integer when a numerical value is needed\t<br>\treward = p + q - r; &#47;&#47; a boolean functions as a 0&#47;1 integer when a numerical value is needed<br>}<br>        <br>instance inst_dbn {<br><br>\tdomain = prop_dbn;\t<br>\tinit-state { <br>\t\tp = true;  &#47;&#47; could also just say &#39;p&#39; by itself <br>\t\tq = false; &#47;&#47; default so unnecessary, could also say &#39;~q&#39; by itself<br>\t\tr;         &#47;&#47; same as r = true<br>\t};<br>  <br>\tmax-nondef-actions = 1;<br>\thorizon  = 20;<br>\tdiscount = 0.9;<br>}","like_count":9},{"had_liked":false,"id":211743,"user_name":"花儿少年","can_delete":false,"product_type":"c1","uid":1318540,"ip_address":"","ucode":"CFE4F64243673B","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/8c/450fe5cb.jpg","comment_is_top":false,"comment_ctime":1588000278,"is_pvip":false,"replies":[{"id":"78747","content":"是的 没错","user_name":"作者回复","comment_id":211743,"uid":"1190123","ip_address":"","utype":1,"ctime":1588041889,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"35947738646","product_id":100039001,"comment_content":"类似于规则引擎是不是也是个解释器，只不过是个复杂很多的解释器","like_count":8,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493351,"discussion_content":"是的 没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588041889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":210524,"user_name":"kylexy_0817","can_delete":false,"product_type":"c1","uid":1068372,"ip_address":"","ucode":"392DD9DD5E4B6E","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/54/9c214885.jpg","comment_is_top":false,"comment_ctime":1587783769,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35947522137","product_id":100039001,"comment_content":"ES中的各种分词器","like_count":8},{"had_liked":false,"id":219134,"user_name":"鲨鱼辣椒","can_delete":false,"product_type":"c1","uid":1417145,"ip_address":"","ucode":"6060F73DC67D19","user_header":"https://static001.geekbang.org/account/avatar/00/15/9f/b9/b7423728.jpg","comment_is_top":false,"comment_ctime":1589953750,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27359757526","product_id":100039001,"comment_content":"定时任务中的cron表达式","like_count":6},{"had_liked":false,"id":207574,"user_name":"李稳","can_delete":false,"product_type":"c1","uid":1401912,"ip_address":"","ucode":"B8164B6B65E26C","user_header":"https://static001.geekbang.org/account/avatar/00/15/64/38/1bd1324e.jpg","comment_is_top":false,"comment_ctime":1587111772,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27356915548","product_id":100039001,"comment_content":"输入规则，解析规则，输入数据，使用规则判断数据","like_count":6},{"had_liked":false,"id":207428,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1587085336,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27356889112","product_id":100039001,"comment_content":"加括号的话，要加一个ExpressionManager，在manager里面用括号把表达式划分为几段，再根据表达式间是 与 还是 或 来添加最上面那一层的表达式","like_count":6},{"had_liked":false,"id":212370,"user_name":"苗","can_delete":false,"product_type":"c1","uid":1088710,"ip_address":"","ucode":"5ECCC6C855E541","user_header":"https://static001.geekbang.org/account/avatar/00/10/9c/c6/05a6798f.jpg","comment_is_top":false,"comment_ctime":1588090712,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23062927192","product_id":100039001,"comment_content":"使用过nutz开源项目的表达式引擎，可以扩展各种操作符。","like_count":5},{"had_liked":false,"id":207510,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1587096836,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"23061933316","product_id":100039001,"comment_content":"https:&#47;&#47;github.com&#47;HeavenXin&#47;MonitorExpressionTest<br>关于第二道题,趁着中午写了写,大家可以参考一下","like_count":5,"discussions":[{"author":{"id":1018370,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","nickname":"Frank","note":"","ucode":"7A488CC6FE15E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":91964,"discussion_content":"同感，我也是先完成需求，后面有时间再回顾自己的代码，重新优化。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576851180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1000237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/43/2d/af86d73f.jpg","nickname":"enjoylearning","note":"","ucode":"DCAF8538DEA277","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":95375,"discussion_content":"脚本代码如shell本来经常看不下去","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577021628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208820,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1587443131,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14472345019","product_id":100039001,"comment_content":"还真有项目有这种场景，动态表单的值校验，可以自定义校验，校验之间还可以相互组合。但是用的是组合模式，后面思考一下解释器模式如何使用，貌似更适合~","like_count":3},{"had_liked":false,"id":207877,"user_name":"马球先生","can_delete":false,"product_type":"c1","uid":1119609,"ip_address":"","ucode":"858C2CE0E494C5","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/79/efde2a69.jpg","comment_is_top":false,"comment_ctime":1587202146,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14472104034","product_id":100039001,"comment_content":"告警规则的代码 真是读了半天才看懂😂","like_count":3},{"had_liked":false,"id":207486,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1587091720,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14471993608","product_id":100039001,"comment_content":"对于一个Java程序员来说,应该知道从Java语言解释为JVM规范语言,是需要进行解释器解析的,从词法解析器,解析出对应的类定义属性等,到语法解析器,解析成对应的语法树,再使用语义解析器,进行判断规范和解析语法糖","like_count":3,"discussions":[{"author":{"id":1694207,"avatar":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","nickname":"Heaven","note":"","ucode":"FA33FBCC66C911","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":236472,"discussion_content":"https://github.com/HeavenXin/MonitorExpressionTest\n关于第二道题,趁着中午写了写,大家可以参考一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587096816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":254883,"user_name":"Gopher","can_delete":false,"product_type":"c1","uid":1206229,"ip_address":"","ucode":"3C1F9012BB486D","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/d5/1b26b725.jpg","comment_is_top":false,"comment_ctime":1603204711,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10193139303","product_id":100039001,"comment_content":"金融业务里面 风控规则 也可以使用到，比如某个用户10分钟内触发多少笔大额资金 就触发 报警","like_count":2},{"had_liked":false,"id":208240,"user_name":"makermade","can_delete":false,"product_type":"c1","uid":1133194,"ip_address":"","ucode":"03386B90CB8F20","user_header":"https://static001.geekbang.org/account/avatar/00/11/4a/8a/c1069412.jpg","comment_is_top":false,"comment_ctime":1587307633,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10177242225","product_id":100039001,"comment_content":"最近整好要做告警规则相关的开发，，，醍醐灌顶","like_count":2},{"had_liked":false,"id":207496,"user_name":"唐朝农民","can_delete":false,"product_type":"c1","uid":1133947,"ip_address":"","ucode":"6F8F43C6652225","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIaOAxRlZjFkGfRBn420LuAcyWkMrpq5iafGdqthX5icJPjql0ibZOAdafaqbfvw4ZpVzDmsaYglVXDw/132","comment_is_top":false,"comment_ctime":1587093856,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10177028448","product_id":100039001,"comment_content":"请问怎么生成复杂一点的表达式树呢","like_count":2,"discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":236842,"discussion_content":"这个也是我感兴趣的。将表达式描述成树，留个坑吧，以后研究一下。简单的就是用递归。父节点为符号，左右子节点为数字或者变量，然后表达式的描述是递归的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587126525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218846,"user_name":"Edward Lee","can_delete":false,"product_type":"c1","uid":1228518,"ip_address":"","ucode":"156223F1D7E94A","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/e6/7808520d.jpg","comment_is_top":false,"comment_ctime":1589885995,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884853291","product_id":100039001,"comment_content":"课后思考<br>Hibernate HQL<br>JSTL 表达式 ${fn:substring(...)}<br>Freemarker &#47; Velocity<br>Struct2 OGNL<br>... ...","like_count":1},{"had_liked":false,"id":207482,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1587091285,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5882058581","product_id":100039001,"comment_content":"解释器模式符合单一职责原则. 在例子中, 为&quot;&gt;&quot;, &quot;&lt;&quot;, &quot;=&quot;分别封装成独立函数, 避免了处理函数过长导致的可读性, 可维护性问题.<br><br>解释器模式符合开闭原则. 在例子中, 如果要添加&quot;(&quot;, &quot;)&quot;解析功能, 封装BracketExpression, AlertRuleInterpreter添加BracketExpression就能实现新的需求. ","like_count":1},{"had_liked":false,"id":207461,"user_name":"liu_liu","can_delete":false,"product_type":"c1","uid":1019138,"ip_address":"","ucode":"24283806A07759","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/02/6a16058a.jpg","comment_is_top":false,"comment_ctime":1587089322,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5882056618","product_id":100039001,"comment_content":"react 中的 jsx","like_count":1},{"had_liked":false,"id":355293,"user_name":"douge","can_delete":false,"product_type":"c1","uid":1048441,"ip_address":"重庆","ucode":"A6EB1AA3D53516","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ff/79/f400c4d1.jpg","comment_is_top":false,"comment_ctime":1661251263,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1661251263","product_id":100039001,"comment_content":"可以使用栈实现，更加通用的做法是语法解析，我使用的递归下降算法，比较直观。代码 https:&#47;&#47;github.com&#47;cquliaoli&#47;monitor","like_count":0},{"had_liked":false,"id":347592,"user_name":"陌兮","can_delete":false,"product_type":"c1","uid":1415619,"ip_address":"","ucode":"00CE47CAECD5CD","user_header":"https://static001.geekbang.org/account/avatar/00/15/99/c3/e4f408d4.jpg","comment_is_top":false,"comment_ctime":1654178398,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1654178398","product_id":100039001,"comment_content":"有使用到解析器模式。印象比较深的有两次，一次是自定义的配置识别组件，解析对应的规则，然后匹配相应的配置，因为是存库的，所以规则设计的比较简单。<br>第二次是另一家公司，解析的文法更为复杂，使用的也是最常见的语法树来处理的","like_count":0},{"had_liked":false,"id":332427,"user_name":"最摇摆的鱼","can_delete":false,"product_type":"c1","uid":1255574,"ip_address":"","ucode":"DA19F4C4224719","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqgVXa8DyW0YsrdYtPNMOdGH6hfdwfjwyBPRyoc9yuS4Ml18l0kApOoOKwYkF6NlDPYpX1bVEWomw/132","comment_is_top":false,"comment_ctime":1643246890,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1643246890","product_id":100039001,"comment_content":"14， 15行的trim()是不是多余呀？","like_count":0},{"had_liked":false,"id":322541,"user_name":"Lingo","can_delete":false,"product_type":"c1","uid":1075334,"ip_address":"","ucode":"82ECA2E0533B78","user_header":"https://static001.geekbang.org/account/avatar/00/10/68/86/348be7f8.jpg","comment_is_top":false,"comment_ctime":1637474836,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1637474836","product_id":100039001,"comment_content":"jvm，jdk，就是c语言写的java语法解释器","like_count":0},{"had_liked":false,"id":314766,"user_name":"makermade","can_delete":false,"product_type":"c1","uid":1133194,"ip_address":"","ucode":"03386B90CB8F20","user_header":"https://static001.geekbang.org/account/avatar/00/11/4a/8a/c1069412.jpg","comment_is_top":false,"comment_ctime":1633411102,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633411102","product_id":100039001,"comment_content":"Activemq中的消息过滤功能，根据自定义tag过滤","like_count":0},{"had_liked":false,"id":299119,"user_name":"somenzz","can_delete":false,"product_type":"c1","uid":1187197,"ip_address":"","ucode":"EA59A170DF8910","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/7d/368df396.jpg","comment_is_top":false,"comment_ctime":1624463199,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624463199","product_id":100039001,"comment_content":"在老师的基础上写了个支持括号的 Python 版本，相比不带括号的，增加了两个类，尽量做到对扩展开放，对修改关闭。<br><br>https:&#47;&#47;github.com&#47;somenzz&#47;geekbang&#47;blob&#47;master&#47;design-pattern&#47;72-interpreter-demo.py","like_count":0},{"had_liked":false,"id":299118,"user_name":"somenzz","can_delete":false,"product_type":"c1","uid":1187197,"ip_address":"","ucode":"EA59A170DF8910","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/7d/368df396.jpg","comment_is_top":false,"comment_ctime":1624463126,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624463126","product_id":100039001,"comment_content":"在老师的基础上写了个带括号的 Python 版本，相比不带括号版本的代码，只增加了两个类，做到对扩展开放，对修改关闭。","like_count":0},{"had_liked":false,"id":298805,"user_name":"小橘子的大叔","can_delete":false,"product_type":"c1","uid":2586350,"ip_address":"","ucode":"C585F7346DE66D","user_header":"https://static001.geekbang.org/account/avatar/00/27/76/ee/4a7efec5.jpg","comment_is_top":false,"comment_ctime":1624330002,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1624330002","product_id":100039001,"comment_content":"增加工具类:<br>public class ExpressionUtils {<br>    private ExpressionUtils() {}<br>    public static List&lt;String&gt; getExpressionsBySymbol(String expression, String symbol) {<br>        Stack&lt;String&gt; stack = new Stack&lt;&gt;();<br>        StringBuilder stringBuilder = new StringBuilder();<br>        List&lt;String&gt; expressions = new ArrayList&lt;&gt;();<br>        boolean isExists = false;<br>        for (int i = 0; i &lt; expression.length(); i++) {<br>            String s = String.valueOf(expression.charAt(i));<br>            if (&quot;(&quot;.equals(s)) {<br>                stack.push(s);<br>                stringBuilder.append(s);<br>                continue;<br>            }<br>            if (&quot;)&quot;.equals(s)) {<br>                stack.pop();<br>                stringBuilder.append(s);<br>                continue;<br>            }<br>            if (stack.isEmpty() &amp;&amp; symbol.equals(s)) {<br>                if (isExists) {<br>                    isExists = false;<br>                    continue;<br>                }<br>                expressions.add(stringBuilder.toString());<br>                stringBuilder.setLength(0);<br>                isExists = true;<br>                continue;<br>            }<br>            stringBuilder.append(s);<br>        }<br>        if (stringBuilder.length() &gt; 0) {<br>            expressions.add(stringBuilder.toString());<br>        }<br>     return expressions;<br>    }<br>}<br>增加括号表达式:<br>public class BracketsExpression implements Expression {<br>    private Expression expression;<br>    public BracketsExpression(String ruleExpression) {<br>        &#47;&#47;去掉首尾括号<br>        ruleExpression = ruleExpression.substring(ruleExpression.indexOf(&quot;(&quot;) + 1, ruleExpression.lastIndexOf(&quot;)&quot;));<br>        this.expression = new OrExpression(ruleExpression);<br>    }<br>    @Override<br>    public boolean interpret(Map&lt;String, Long&gt; stats) {<br>        return expression.interpret(stats);<br>    }<br>}<br>将OrExpression和AndExpression的切割方式改为:ExpressionUtils.getExpressionsBySymbol(strAndExpression, “这里为|或者&amp;”);<br>在AndExpression添加if (strExpr.contains(&quot;(&quot;)) {<br>                expressions.add(new BracketsExpression(strExpr));<br>            }<br>","like_count":0,"discussions":[{"author":{"id":1204333,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/6d/e2576fda.jpg","nickname":"Rancood","note":"","ucode":"052BDF2221F480","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555576,"discussion_content":"这不能解决括号里面包含括号的情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646979728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":287435,"user_name":"Yeyw","can_delete":false,"product_type":"c1","uid":1463740,"ip_address":"","ucode":"C9D20DB91C3BE5","user_header":"https://static001.geekbang.org/account/avatar/00/16/55/bc/fad0090b.jpg","comment_is_top":false,"comment_ctime":1617950115,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617950115","product_id":100039001,"comment_content":"Spring Jpa方法命名的解析","like_count":0},{"had_liked":false,"id":279815,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1613974046,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613974046","product_id":100039001,"comment_content":"编译原理里面有涉及到这个","like_count":0},{"had_liked":false,"id":279554,"user_name":"香","can_delete":false,"product_type":"c1","uid":1220273,"ip_address":"","ucode":"121D6CECECEEC3","user_header":"https://static001.geekbang.org/account/avatar/00/12/9e/b1/758f2fe7.jpg","comment_is_top":false,"comment_ctime":1613819211,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613819211","product_id":100039001,"comment_content":"Apache Calcite使用了JavaCC这个框架来生成语法和词法解析器，进而解析和处理各种复杂的SQL。所以当前我自己如果需要开发自定义的一套语言或语法规则时，也会使用JavaCC，不过当你去观察JavaCC生成的各种表达式类时，其实跟争哥这里写的也是基本相似的。","like_count":0},{"had_liked":false,"id":272750,"user_name":"码生笔谈","can_delete":false,"product_type":"c1","uid":1229329,"ip_address":"","ucode":"EBAD30BEE4E17D","user_header":"https://static001.geekbang.org/account/avatar/00/12/c2/11/323358ed.jpg","comment_is_top":false,"comment_ctime":1610263056,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610263056","product_id":100039001,"comment_content":"&amp;&amp; 优先级高于 | | 是不是","like_count":0},{"had_liked":false,"id":265867,"user_name":"阿骨打","can_delete":false,"product_type":"c1","uid":2122539,"ip_address":"","ucode":"35EADA5550162A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","comment_is_top":false,"comment_ctime":1607055507,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1607055507","product_id":100039001,"comment_content":"争哥的 OrExpression 中 构造器部分 解析表达式应该是有误，我修改了如下，大家可以看看对不对<br>&#47;&#47;   &quot;key1 &gt; 100 &amp;&amp; key2 &gt; 30 || key3 &gt; 100 || key4 &gt; 88&quot;<br>    public OrExpression(String strOrExpression) {<br>        String[] andExpressions = strOrExpression.split(&quot;\\\\|\\\\|&quot;);<br>        System.out.println(&quot;andExpressions = &quot; + Arrays.toString(andExpressions));<br>        List&lt;String&gt; andExpressionsToList = new LinkedList&lt;&gt;();<br>        for (String andExpression : andExpressions) {<br>            andExpressionsToList.add(andExpression);<br>        }<br>        &#47;&#47;1.找出 &amp;&amp; 的表达式<br>        Iterator&lt;String&gt; iterator = andExpressionsToList.iterator();<br>        while (iterator.hasNext()) {<br>            String andExpr = iterator.next();<br>            if (andExpr.contains(&quot;&amp;&amp;&quot;)) {<br>                expressions.add(new AndExpression(andExpr));<br>                iterator.remove();<br>            }<br>        }<br>        &#47;&#47;2.找出其他表达式<br>        for (String otherExpr : andExpressionsToList) {<br>            if (otherExpr.contains(&quot;&gt;&quot;)) {<br>                expressions.add(new GreaterExpression(otherExpr));<br>            }<br>            &#47;&#47; &lt;     new Less<br>            &#47;&#47; ==   new Equals<br>        }<br>注释部分为 争哥之前的写法<br>&#47;&#47;        for (String andExpr : andExpressions) {<br>&#47;&#47;            if (andExpr.contains(&quot;&amp;&amp;&quot;)) {<br>&#47;&#47;                expressions.add(new AndExpression(andExpr));<br>&#47;&#47;            }<br>&#47;&#47;        }<br>        System.out.println(&quot;OrExpression的expressions = &quot; + expressions);<br>    }","like_count":0,"discussions":[{"author":{"id":1115302,"avatar":"https://static001.geekbang.org/account/avatar/00/11/04/a6/18c4f73c.jpg","nickname":"Airsaid","note":"","ucode":"5B90BC0044F376","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345040,"discussion_content":"我看现在争哥写的版本是没有问题的，去掉了  if (andExpr.contains(&#34;&amp;&amp;&#34;)) 这个判断就 OK 了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611644795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":265854,"user_name":"阿骨打","can_delete":false,"product_type":"c1","uid":2122539,"ip_address":"","ucode":"35EADA5550162A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","comment_is_top":false,"comment_ctime":1607052806,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607052806","product_id":100039001,"comment_content":"争哥，代码是不是有问题呀， 你示例的代码 输入 &quot;key1 &gt; 100 &amp;&amp; key2 &gt; 30 || key3 &gt; 100 || key4 &gt; 88&quot;<br>其实是捕捉不到   key3 &gt; 100 || key4 &gt; 88 这部分的参数的，因为Or的代码中，只解析了 带有 &amp;&amp;符号的，其他的 没解析。。。<br>","like_count":0},{"had_liked":false,"id":261240,"user_name":"铁男神sama","can_delete":false,"product_type":"c1","uid":1394822,"ip_address":"","ucode":"0A3E3E61D36EDE","user_header":"https://static001.geekbang.org/account/avatar/00/15/48/86/54c68afe.jpg","comment_is_top":false,"comment_ctime":1605248532,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605248532","product_id":100039001,"comment_content":"没看懂代码，自己动手debug才明白咋回事。不禁感叹- -妙啊！","like_count":0},{"had_liked":false,"id":260943,"user_name":"查理","can_delete":false,"product_type":"c1","uid":1111297,"ip_address":"","ucode":"A9FEA901E3A05D","user_header":"https://static001.geekbang.org/account/avatar/00/10/f5/01/5389295c.jpg","comment_is_top":false,"comment_ctime":1605158747,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1605158747","product_id":100039001,"comment_content":"感觉这个模式挺常用的。稍微复杂点的业务，就会用到配置化，配置就相当于规则，那怎么解析规则就用到这个模式了","like_count":0,"discussions":[{"author":{"id":1142395,"avatar":"","nickname":"谭亮","note":"","ucode":"8BE75B6409548C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574962,"discussion_content":"是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654498255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":254637,"user_name":"阿骨打","can_delete":false,"product_type":"c1","uid":2122539,"ip_address":"","ucode":"35EADA5550162A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","comment_is_top":false,"comment_ctime":1603161079,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603161079","product_id":100039001,"comment_content":"自己实现了半天  跟坨屎一样  业务都集中在Interpretor里了，还是看看争哥的代码把。。。","like_count":0},{"had_liked":false,"id":248205,"user_name":"写代码的","can_delete":false,"product_type":"c1","uid":2085090,"ip_address":"","ucode":"F58186409A3D65","user_header":"https://static001.geekbang.org/account/avatar/00/1f/d0/e2/1d00c079.jpg","comment_is_top":false,"comment_ctime":1600064555,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600064555","product_id":100039001,"comment_content":"解释器模式中，一般而言规则是静态的，数据是动态的，所以，如果构造规则表达式的花费的时间比较长或者比较频繁，可以考虑使用缓存: Map&lt;String, Expression&gt; cache; ","like_count":0},{"had_liked":false,"id":235190,"user_name":"扶摇九万里","can_delete":false,"product_type":"c1","uid":1240371,"ip_address":"","ucode":"58F30697C9D62B","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/33/070f7537.jpg","comment_is_top":false,"comment_ctime":1594934273,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594934273","product_id":100039001,"comment_content":"druid项目中有对sql的解析用的解释器模式，还有访问者模式用的比较多","like_count":0},{"had_liked":false,"id":228950,"user_name":"CharType","can_delete":false,"product_type":"c1","uid":1089182,"ip_address":"","ucode":"DCAEB621E0CAB7","user_header":"https://static001.geekbang.org/account/avatar/00/10/9e/9e/975f6c70.jpg","comment_is_top":false,"comment_ctime":1592855619,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592855619","product_id":100039001,"comment_content":"想到了java中的注解","like_count":0},{"had_liked":false,"id":223663,"user_name":"Garwen","can_delete":false,"product_type":"c1","uid":1045062,"ip_address":"","ucode":"C76346E1734AB8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f2/46/09c457eb.jpg","comment_is_top":false,"comment_ctime":1591151917,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1591151917","product_id":100039001,"comment_content":"老师啊，想了三天了还是没想到思考题第二题带括号解释器的优雅写法，写的惨不忍睹，能不能给个思路或者示例代码啊。","like_count":0,"discussions":[{"author":{"id":1401098,"avatar":"https://static001.geekbang.org/account/avatar/00/15/61/0a/1e98cc81.jpg","nickname":"evalcony","note":"","ucode":"D8CE3E832A7A10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":124393,"discussion_content":"写1个好。数据库查询是高消耗操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578418344,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1016594,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/83/12/4ba82798.jpg","nickname":"我是智障","note":"","ucode":"ED9D959423E024","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":93226,"discussion_content":"我觉得一个方法就好了，一行记录的数据量没有多大，都需要经过数据库查询一次，没太大关系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576915624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221027,"user_name":"道","can_delete":false,"product_type":"c1","uid":1324160,"ip_address":"","ucode":"851A0AD751D317","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/80/30e9ae41.jpg","comment_is_top":false,"comment_ctime":1590385891,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590385891","product_id":100039001,"comment_content":"第二题：对每个规则解析的时候先去掉首尾多余的括号再拆分即可","like_count":0},{"had_liked":false,"id":216284,"user_name":"皮特尔","can_delete":false,"product_type":"c1","uid":1017161,"ip_address":"","ucode":"313862C91DD325","user_header":"https://static001.geekbang.org/account/avatar/00/0f/85/49/585c69c4.jpg","comment_is_top":false,"comment_ctime":1589214806,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1589214806","product_id":100039001,"comment_content":"曾经我们也有一个实现“自定义解释器”的需求，后来发现用现成的Java类 ScriptEngine 就可以满足需求。<br>推荐给大家。","like_count":0}]}