{"id":431904,"title":"03 | 内存布局：应用程序是如何安排数据的？","content":"<p>你好，我是海纳。</p><p>在前边的课程里，我们学习了计算机物理地址和虚拟地址的概念。有了虚拟地址之后，运行在系统里的用户进程看到的地址空间范围，都是虚拟地址空间范围（32位计算机的地址范围是4G；64位计算机的地址范围是256T）。这样的话，就不用再担心内存地址不够用，以及与其他进程之间产生内存地址冲突的问题了。</p><p>前面几节课，我们关注的是如何解决进程之间的冲突，从这节课起，我们一起来看下进程内部的虚拟内存布局，或者说单一进程是如何安排自己的各种数据的。</p><p>学习了这节课，你将理解全局变量和static变量在内存中的位置以及初始化时机，在这个基础上，你还将明白在栈上创建对象和在堆上创建对象有什么不同等问题。这些问题的核心都可以归结到“内存是如何布局的”这个问题上，所以只有深刻地掌握了内存布局的知识，你才能做到以不变应万变，面对各种具体问题才有了分析的方向和思路，进而，你才能写出更加“内存安全”的代码。</p><p>首先，我们来看一下，对于一个典型的进程来说，它的内存空间是由哪些部分组成的？每个部分又被安置在空间的什么位置？</p><h3>抽象内存布局</h3><p>我们知道，CPU运行一个程序，实质就是在顺序执行该程序的机器码。一个程序的机器码会被组织到同一个地方，这个地方就是<strong>代码段</strong>。</p><!-- [[[read_end]]] --><p>另外，程序在运行过程中必然要操作数据。这其中，对于有初值的变量，它的初始值会存放在程序的二进制文件中，而且，这些数据部分也会被装载到内存中，即程序的<strong>数据段</strong>。数据段存放的是程序中已经初始化且不为0的全局变量和静态变量。</p><p>对于未初始化的全局变量和静态变量，因为编译器知道它们的初始值都是0，因此便不需要再在程序的二进制映像中存放这么多0了，只需要记录他们的大小即可，这便是<strong>BSS段</strong>。BSS段这个缩写名字是Block Started by Symbol，但很多人可能更喜欢把它记作Better Save Space的缩写。</p><p>数据段和BSS段里存放的数据也只能是部分数据，主要是全局变量和静态变量，但程序在运行过程中，仍然需要记录大量的临时变量，以及运行时生成的变量，这里就需要新的内存区域了，即程序的<strong>堆空间</strong>跟<strong>栈空间</strong>。与代码段以及数据段不同的是，堆和栈并不是从磁盘中加载，它们都是由程序在运行的过程中申请，在程序运行结束后释放。</p><p>总的来说，一个程序想要运行起来所需要的几块基本内存区域：代码段、数据段、BSS段、堆空间和栈空间。下面就是内存布局的示意图：</p><p><img src=\"https://static001.geekbang.org/resource/image/fc/c0/fcb6231d9cc3841643e4b84462e5b3c0.jpg?wh=2284x1980\" alt=\"\"></p><p>这是程序运行起来所需要的最小功能集，如果你尝试去看Linux 0.11的内核代码的话，会发现它所支持的a.out文件格式和内存布局就是上边的样子。</p><p>除了上面所讲的基本内存区域外，现代应用程序中还会包含其他的一些内存区域，主要有以下几类：</p><ul>\n<li><strong>存放加载的共享库的内存空间</strong>：如果一个进程依赖共享库，那对应的，该共享库的代码段、数据段、BSS段也需要被加载到这个进程的地址空间中。</li>\n<li><strong>共享内存段</strong>：我们可以通过系统调用映射一块匿名区域作为共享内存，用来进行进程间通信。</li>\n<li><strong>内存映射文件</strong>：我们也可以将磁盘的文件映射到内存中，用来进行文件编辑或者是类似共享内存的方式进行进程通信。</li>\n</ul><p>这样我们就初步了解了一个进程内存中需要哪些区域。</p><p>在上面的讨论中，我们并没有区分磁盘的程序段(Section)，以及内存程序段(Segment)的概念，这两个词在国内往往都被翻译成“段”，导致大多数同学会混淆它们。这里我来给你做一个区分。</p><p><img src=\"https://static001.geekbang.org/resource/image/bc/c9/bca1533a0af7ee8476yy12f4b04083c9.jpg?wh=2284x1319\" alt=\"\"></p><p>上图从两个视角展示了应用程序的分布，左边是程序在磁盘中的文件布局结构，右边是程序加载到内存中的内存布局结构。</p><p>对于磁盘的程序，每一个单元结构称为Section。我们可以通过readelf -S的选项，来查看二进制文件中所有的Section信息。对于右边的内存镜像，每一个单元结构称为Segment。我们可以通过readelf -l的选项，来查看二进制文件加载到内存之后的Segment布局信息。</p><p>同时我们也可以看到，往往多个Section会对应一个Segment，例如.text、.rodata等一些只读的Section，会被映射到内存的一个只读/执行的Segment里；而.data、.bss等一些可读写的Section，则会被映射到内存的一个具有读写权限的Segment里。并且对于磁盘二进制中一些辅助信息的Section，例如.symtab、.strtab等，不需要在内存中进行映射。</p><p>总的来说，<strong>Section主要是指在磁盘中的程序段，而Segment则用来指代内存中的程序段，Segment是将具有相同权限属性的Section集合在一起，系统为它们分配的一块内存空间。</strong></p><p>接下来，我们就具体看下Linux系统下内存布局是怎样的。</p><h3>IA-32机器上的Linux进程内存布局</h3><p>在32位机器上，每个进程都具有4GB的寻址能力。Linux系统会默认将高地址的1GB空间分配给内核，剩余的低3GB是用户可以使用的用户空间。下图是32位机器上Linux进程的一个典型的内存布局。在实践中，我们可以通过<code>cat /proc/pid/maps</code>来查看某个进程的实际虚拟内存布局。</p><p><img src=\"https://static001.geekbang.org/resource/image/61/b2/61ee74faa861797b34397ed837a027b2.jpg?wh=2284x1808\" alt=\"\"></p><p>现在，我们从低地址到高地址，依次来解释下图中的布局情况。</p><p>首先，我们发现在32位Linux系统下，从0地址开始的内存区域并不是直接就是代码段区域，而是一段不可访问的保留区。这是因为在大多数的系统里，我们认为比较小数值的地址不是一个合法地址，例如，我们通常在C的代码里会将无效的指针赋值为NULL。因此，这里会出现一段不可访问的内存保留区，防止程序因为出现bug，导致读或写了一些小内存地址的数据，而使得程序跑飞。</p><p>接下来，我们可以看到，代码段从0x08048000的位置开始排布（需要注意的是，以上地址需要gcc编译的时候不开启pie的选项）。就像我们前面提到的，代码段、数据段都是从可执行文件映像中装载到内存中；BSS段则是根据BSS段所需的大小，在加载时生成一段0填充的内存空间。</p><p>紧接着，排在BSS段后边的就是堆空间了。在图中，堆的空间里有一个向上的箭头，这里标明了堆地址空间的增长方向，也就是说，<strong>每次在进程向内核申请新的堆地址时候，其地址的值是在增大的</strong>。与之对应的是栈空间，有一个向下的箭头，说明栈增长的方向是向低地址方向增长，也就是说，<strong>每次进程申请新的栈地址时，其地址值是在减少的</strong>。</p><p>对此，我们可以想象堆和栈分别由两个指针控制，堆指针指明了当前堆空间的边界，栈指针指明了当前栈空间的边界。当堆申请新的内存空间时，只需要将堆指针增加对应的大小，回收地址时减少对应的大小即可。而栈的申请刚好相反。这其实就是内核对堆跟栈使用的最根本的方式，其中，堆的指针叫做“Program break”，栈的指针叫做“Stack pointer”，也就是x86架构下的sp寄存器。我们在后续的课程中会分别展开堆空间跟栈空间的实现原理。</p><p>继续往下看，就到了内存映射区域，这里最常见的就是程序所依赖的共享库，例如libc.so。共享库的代码段、数据段、BSS段都会被装载到这里。</p><p>这里我要说明一点，我们上述的布局分析都是基于Linux系统下关闭了进程地址随机化的选项。如果打开进程地址随机化的模式，其中的堆空间、栈空间和共享库映射的地址，在每次程序运行下都会不一样。这是因为内核在加载的过程中，会对这些区域的起始地址增加一些随机的偏移值，这能增加缓冲区溢出的难度。</p><p>对于这个进程地址随机化选项，我们可以通过<code> sudo sysctl -w kernel.randomize_va_space=val</code>的命令来设置。其中，val=0表示关闭内存地址随机化；val=1表示使得mmap的基地址、栈地址和VDSO的地址随机化；val=2则是在1的基础上增加堆地址的随机化。</p><p>到这里，我们对32位机器下Linux进程的内存布局有了一个清晰的认知。对于64位系统而言，它的基本框架与32位架构是一致的，但在一些细节上，还是有所不同。</p><h3>Intel 64机器上的Linux进程内存布局</h3><p>64位系统理论的寻址范围是2^64，也就是16EB。但是，从目前来看，我们的系统和应用往往用不到这么庞大的地址空间。因此，在目前的Intel 64架构里定义了canonical address的概念，即在64位的模式下，如果地址位63到地址的最高有效位被设置为全 1 或全零，那么该地址被认为是canonical form。目前，Intel 64处理器往往支持48位的虚拟地址，这意味着canonical address必须将第 63 位到第 48 位设置为零或一（这取决于第 47 位是零还是一）。</p><p>所以，目前的64系统下的寻址空间是2^48，即256TB。而且根据canonical address的划分，地址空间天然地被分割成两个区间，分别是0x0 - 0x00007fffffffffff和0xffff800000000000 - 0xffffffffffffffff。这样就直接将低128T的空间划分为用户空间，高128T划分为内核空间。下面这张图展示了Intel 64机器上的Linux进程内存布局：</p><p><img src=\"https://static001.geekbang.org/resource/image/12/1c/1258dabe44e33c66c0f423d8d24a8f1c.jpg?wh=2284x1578\" alt=\"\"></p><p>从图中你可以看到，在用户空间和内核空间之间有一个巨大的内存空洞。这块空间之所以用更深颜色来区分，是因为这块空间的不可访问是由CPU来保证的（这里的地址都不满足Intel 64的Canonical form）。</p><p>对于64位的程序，你在查看/proc/pid/maps的过程中，会发现代码段跟数据段的中间还有一段不可以读写的保护段，它的作用也是防止程序在读写数据段的时候越界访问到代码段，这个保护段可以让越界访问行为直接崩溃，防止它继续往下运行。</p><p>在所有的内存区域中，程序员打交道最多、接触最广泛的就是堆空间。所以，我们接下来重点关注操作系统所提供的，用于管理堆的系统调用是怎样的。这里我会先给你讲如何通过系统调用申请堆空间，关于堆空间更精细的管理，我们将在第9节课介绍。</p><h3>申请堆空间</h3><p>其实，不管是32位系统还是64位系统，内核都会维护一个变量brk，指向堆的顶部，所以，<strong>brk的位置实际上就决定了堆的大小</strong>。Linux系统为我们提供了两个重要的系统调用来修改堆的大小，分别是sbrk和mmap。接下来，我们来学习这两个系统调用是如何使用的。我们先来看sbrk。</p><h4>sbrk</h4><p>sbrk函数的头文件和原型定义如下：</p><pre><code>#include &lt;unistd.h&gt;\n\nvoid* sbrk(intptr_t incr);\n</code></pre><p><strong>sbrk通过给内核的brk变量增加incr，来改变堆的大小，incr可以为负数</strong>。当incr为正数时，堆增大，当incr为负数时，堆减小。如果sbrk函数执行成功，那返回值就是brk的旧值；如果失败，就会返回-1，同时会把errno设置为ENOMEM。</p><p>在实际应用中，我们很少直接使用sbrk来申请堆内存，而是使用C语言提供的malloc函数进行堆内存的分配，然后用free进行内存释放。关于malloc和free的具体实现，我们将在第8节课进行详细讲解。这里你要注意的是，malloc和free函数不是系统调用，而是C语言的运行时库。Linux上的主流运行时库是glibc，其他影响力比较大的运行时库还有musl等。C语言的运行时库多是以动态链接库的方式实现的，关于动态链接库的相关知识，我们会在第7节课加以介绍。</p><p>在C语言的运行时库里，malloc向程序提供分配一小块内存的功能，当运行时库的内存分配完之后，它会使用sbrk方法向操作系统再申请一块大的内存。我们可以将C语言的运行时库类比为零售商，它从操作系统那里批发一块比较大的内存，然后再通过零售的方式一点点地提供给程序员使用。</p><h4>mmap</h4><p>另一个可以申请堆内存的系统调用是mmap，它是最重要的内存管理接口。mmap的头文件和原型如下所示：</p><pre><code>  #include &lt;unistd.h&gt;\n    #include &lt;sys/mman.h&gt;\n\nvoid* mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset);\n</code></pre><p>我来解释一下上述代码中的各个变量的意义：</p><ul>\n<li>addr代表该区域的起始地址；</li>\n<li>length代表该区域长度；</li>\n<li>prot描述了这块新的内存区域的访问权限；</li>\n<li>flags描述了该区域的类型；</li>\n<li>fd 代表文件描述符；</li>\n<li>offset 代表文件内的偏移值。</li>\n</ul><p>mmap的功能非常强大，根据参数的不同，它可以用于创建共享内存，也可以创建文件映射区域用于提升IO效率，还可以用来申请堆内存。决定它的功能的，主要是prot, flags和fd这三个参数，我们分别来看看。</p><p>prot 的值可以是以下四个常量的组合：</p><ul>\n<li>PROT_EXEC，表示这块内存区域有可执行权限，意味着这部分内存可以看成是代码段，它里面存储的往往是CPU可以执行的机器码。</li>\n<li>PROT_READ，表示这块内存区域可读。</li>\n<li>PROT_WRITE，表示这块内存区域可写。</li>\n<li>PROT_NONE，表示这块内存区域的页面不能被访问。</li>\n</ul><p>而flags的值可取的常量比较多，你可以通过 man mmap查看，这里我只列举一下最重要的四种可取值常量：</p><ul>\n<li><strong>MAP_SHARED</strong>：创建一个共享映射的区域，多个进程可以通过共享映射的方式，来共享同一个文件。这样一来，一个进程对该文件的修改，其他进程也可以观察到，这就实现了数据的通讯。</li>\n<li><strong>MAP_PRIVATE</strong>：创建一个私有的映射区域，多个进程可以使用私有映射的方式，来映射同一个文件。但是，当一个进程对文件进行修改时，操作系统就会为它创建一个独立的副本，这样它对文件的修改，其他进程就看不到了，从而达到映射区域私有的目的。</li>\n<li><strong>MAP_ANONYMOUS</strong>：创建一个匿名映射，也就是没有关联文件。使用这个选项时，fd参数必须为空。</li>\n<li><strong>MAP_FIXED</strong>：一般来说，addr参数只是建议操作系统尽量以addr为起始地址进行内存映射，但如果操作系统判断addr作为起始地址不能满足长度或者权限要求时，就会另外再找其他适合的区域进行映射。如果flags的值取是MAP_FIXED的话，就不再把addr看成是建议了，而是将其视为强制要求。如果不能成功映射，就会返回空指针。</li>\n</ul><p>通常，我们使用私有匿名映射来进行堆内存的分配，具体的原理我们会在第9节课详细分析。</p><p>我们再来看参数fd。当参数fd不为0时，mmap映射的内存区域将会和文件关联，如果fd为0，就没有对应的相关文件，此时就是匿名映射，flags的取值必须为MAP_ANONYMOUS。</p><p>明白了mmap及其各参数的含义后，你肯定想知道什么场景下才会使用mmap，我们又该怎么使用它。</p><h4>mmap的其他应用场景</h4><p>mmap这个系统调用的能力非常强大，我们在后面还会经常遇到它。在这节课里，我们先来了解一下它最常见的用法。</p><p>根据映射的类型，mmap有四种最常用的组合：<br>\n<img src=\"https://static001.geekbang.org/resource/image/98/93/98fcb5aa607b8be9ffa037e9f7eea593.jpg?wh=2284x1285\" alt=\"\"></p><p>其中，私有匿名映射常用于分配内存，也就是我们上文讲的申请堆内存，具体原理我们会在第9节课讲解。而私有文件映射常用于加载动态库，它的原理我们会在第7节课和第8节课进行分析。</p><p>这里我们重点看看共享匿名映射。我们通过一个例子，来了解一下mmap是如何用于父子进程之间的通信的，其他的例子我会在后面的章节陆续给你介绍。它的用法示例代码如下：</p><pre><code>#include &lt;sys/mman.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n    pid_t pid;\n\n    char* shm = (char*)mmap(0, 4096, PROT_READ | PROT_WRITE,\n        MAP_SHARED | MAP_ANONYMOUS, -1, 0);\n\n    if (!(pid = fork())){\n        sleep(1);\n        printf(&quot;child got a message: %s\\n&quot;, shm);\n        sprintf(shm, &quot;%s&quot;, &quot;hello, father.&quot;);\n        exit(0);\n    }\n  \n    sprintf(shm, &quot;%s&quot;, &quot;hello, my child&quot;);\n    sleep(2);\n    printf(&quot;parent got a message: %s\\n&quot;, shm);\n\n    return 0;\n}\n</code></pre><p>在这个过程中，我们先是用mmap方法创建了一块共享内存区域，命名为 shm（第9行代码），接着，又通过fork这个系统调用创建了子进程。从第13行到第16行代码是子进程的执行逻辑，具体来讲，子进程休眠一秒后，从shm中取出一行字符并打印出来，然后又向共享内存中写入了一行消息（第15行）。</p><p>在子进程的执行逻辑之后，是父进程的执行逻辑（第19行以后）：父进程先写入一行消息，然后休眠两秒，等待子进程完成读取消息和发消息的过程并退出后，父进程再从共享内存中取出子进程发过来的消息。</p><p>这就是共享匿名映射在父子进程间通信的运用。我们使用gcc编译运行上面的例子，可以得到这样的结果：</p><pre><code>$ gcc -o mm mmap_shm.c\n$ ./mm\nchild got a message: hello, my child\nparent got a message: hello, father.\n</code></pre><p>我想请你结合我刚才的讲解，来分析一下这个程序运行的结果，这样你就理解的更透彻了。</p><p>关于共享匿名映射，我们就讲到这里，至于mmap的另一个组合共享文件映射。它的作用其实和共享匿名映射相似，也可以用于进程间通讯。不同的是，共享文件映射是通过文件名来创建共享内存区域的，这就让没有父子关系的进程，也可以通过相同的文件创建共享内存区域，从而可以使用共享内存进行进程间通讯。更具体的原理分析我放在了第10章。</p><h3>总结</h3><p>好，这节课我们就讲到这里，现在我们来总结一下。</p><p>在这节课中，我们从抽象到具体逐步了解了程序运行时的内存布局模型。我们了解到，<strong>一个进程的内存可以分为内核区域和用户区域</strong>。内核区域是由操作系统内核维护的，我们通常并不关心这一块内存是如何使用的。</p><p>程序员最关心的是用户空间，用户空间大致可以分为栈、堆、bss段、数据段和代码段：</p><ul>\n<li><strong>代码段</strong>保存的是程序的机器指令，这一段区域的内存往往是可读可执行，但不可写；</li>\n<li><strong>数据段</strong>保存的是程序的静态变量和全局变量；</li>\n<li><strong>bss段</strong>用于无初值的变量区域；</li>\n<li><strong>堆</strong>是程序员可以自由申请的空间，当我们在写程序时要保存数据，优先会选择堆；</li>\n<li><strong>栈</strong>是函数执行时的活跃记录，这将是我们下一节课要重点分析的内容。</li>\n</ul><p>这5个内存区域通常是由高地址向低地址顺序排列的。但这并不是绝对的，以后我们会看到各种反例，比如代码段的位置完全可以比堆的位置还要高。</p><p>接着，我们以Linux为例，分别研究了IA-32架构和Intel64架构上的内存布局。在这两种情况下，各个段都是按照上述功能进行划分的，区别在于64架构中地址空间更大，而且内核空间和用户空间是不连续的。</p><p>此外，我们还初步学习了两个用于堆管理的系统调用sbrk和mmap。其中，mmap的用法非常复杂，根据调用时传的参数，它有4种常见的用法，分别是私有匿名映射、私有文件映射、共享匿名映射和共享文件映射。其中，共享匿名映射是我们这节课的重点，它可以用于父子进程之间的通讯。关于mmap的其他功能，我们会在后面的课程逐渐展开。</p><p>在接下来的课程中，我会给你详细介绍内存布局中的堆跟栈，这两块也是我们开发人员最常打交道的内存区域，让你对程序运行时的环境和内存状态有一个更深入的理解。</p><h3>思考题</h3><p>在这节课的最后，我给你留一道思考题。</p><p>一块内存区域的权限一般包括可读，可写，可执行三类，请你思考一下，代码段应该被授予怎么样的权限呢？数据段和堆又该被授予怎样的权限呢？欢迎你在留言区和我交流你的想法，我在留言区等你。</p><p><img src=\"https://static001.geekbang.org/resource/image/65/df/658ed22f6d65bc0aac3297139c9bb9df.jpg?wh=2733x1659\" alt=\"\"></p><p>好啦，这节课到这就结束啦。欢迎你把这节课分享给更多对计算机内存感兴趣的朋友。我是海纳，我们下节课再见！</p>","comments":[{"had_liked":false,"id":319538,"user_name":"êｗěｎ","can_delete":false,"product_type":"c1","uid":1066707,"ip_address":"","ucode":"5000233111BEFA","user_header":"https://static001.geekbang.org/account/avatar/00/10/46/d3/e25d104a.jpg","comment_is_top":false,"comment_ctime":1635844059,"is_pvip":true,"replies":[{"id":"115868","content":"很有意思的问题：）我们课里也介绍了mmap的几个作用。其中私有匿名映射用于分配空间，这样分配的空间还是从映射区域里分配的，但是从功能上说呢，它和使用sbrk所得到的内存区域又是相同的。所以这一部分内存我们还是倾向于称呼它为堆。但你要知道的是，其实严格来说，这是从文件映射区“偷”来的。","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1635925054,"ip_address":"","comment_id":319538,"utype":1}],"discussion_count":3,"race_medal":0,"score":"35995582427","product_id":100094901,"comment_content":"老师，文章里说mmap也可以修改堆大小，那映射的区域为啥不属于堆呢？","like_count":8,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529663,"discussion_content":"很有意思的问题：）我们课里也介绍了mmap的几个作用。其中私有匿名映射用于分配空间，这样分配的空间还是从映射区域里分配的，但是从功能上说呢，它和使用sbrk所得到的内存区域又是相同的。所以这一部分内存我们还是倾向于称呼它为堆。但你要知道的是，其实严格来说，这是从文件映射区“偷”来的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635925054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1026921,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ab/69/5f1f0d1c.jpg","nickname":"支离书","note":"","ucode":"AD2570AC5EF7BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531362,"discussion_content":"严格来说，堆的大小只有通过sbrk一种系统调用方式来调整，mmap操作的都是映射区的内存吧","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1637292722,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":1,"child_discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1026921,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ab/69/5f1f0d1c.jpg","nickname":"支离书","note":"","ucode":"AD2570AC5EF7BB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532308,"discussion_content":"严格意义上是这样的。所以我用了“偷”这个词","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637572116,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":531362,"ip_address":""},"score":532308,"extra":"{\"user_type\":2}"}]}]},{"had_liked":false,"id":322010,"user_name":"大脑壳","can_delete":false,"product_type":"c1","uid":1049447,"ip_address":"","ucode":"224E362AD55DBD","user_header":"https://static001.geekbang.org/account/avatar/00/10/03/67/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1637135797,"is_pvip":true,"replies":[{"id":"117046","content":"不是。JVM把很多东西都托管了。它和linux进程布局很不相同。但是JVM仍然有很多设计深受传统的进程内存使用的影响。先学好Linux进程布局吧。JVM我们慢慢讲。","user_name":"作者回复","user_name_real":"编辑","uid":"1360512","ctime":1637325630,"ip_address":"","comment_id":322010,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18817004981","product_id":100094901,"comment_content":"您这里所描述的linux进程的内存布局，和JVM的内存布局是一个维度吗？JVM内部的堆栈和linxu系统的堆栈是一个什么样的关系？请老师指教","like_count":4,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531504,"discussion_content":"不是。JVM把很多东西都托管了。它和linux进程布局很不相同。但是JVM仍然有很多设计深受传统的进程内存使用的影响。先学好Linux进程布局吧。JVM我们慢慢讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637325630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319508,"user_name":"Jack","can_delete":false,"product_type":"c1","uid":1297112,"ip_address":"","ucode":"F3863DAEF449D5","user_header":"https://static001.geekbang.org/account/avatar/00/13/ca/d8/b109ed85.jpg","comment_is_top":false,"comment_ctime":1635838746,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14520740634","product_id":100094901,"comment_content":"写得太好了，老师快点更新","like_count":3},{"had_liked":false,"id":318948,"user_name":"慢动作","can_delete":false,"product_type":"c1","uid":1133945,"ip_address":"","ucode":"62C944F4A4D8AC","user_header":"https://static001.geekbang.org/account/avatar/00/11/4d/79/803537db.jpg","comment_is_top":false,"comment_ctime":1635488611,"is_pvip":true,"replies":[{"id":"115618","content":"bss段在磁盘上的时候，只记录了大小，比如100字节，在磁盘上不需要真的保留100字节，只要记下来就行了。加载进内存的时候要先为他分配100字节，然后这100字节再和data段合并到一起，成为内存里的data segment。带有初始值的变量，是放到data section的。这个文章里面有的。再仔细看一下～","user_name":"作者回复","user_name_real":"氦钠锶","uid":"1360512","ctime":1635555512,"ip_address":"","comment_id":318948,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14520390499","product_id":100094901,"comment_content":"从执行视角那张图，代码段是可读可执行，数据段是可读可写，把链接器视角的.bss对应为数据段了，后面的图又把bss单独列出来，这是为什么？bss存了未初始化的数据，只有大小，那初始化后数据放哪里？","like_count":3,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529440,"discussion_content":"bss段在磁盘上的时候，只记录了大小，比如100字节，在磁盘上不需要真的保留100字节，只要记下来就行了。加载进内存的时候要先为他分配100字节，然后这100字节再和data段合并到一起，成为内存里的data segment。带有初始值的变量，是放到data section的。这个文章里面有的。再仔细看一下～","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635555512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133945,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4d/79/803537db.jpg","nickname":"慢动作","note":"","ucode":"62C944F4A4D8AC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409997,"discussion_content":"谢谢老师，看得不仔细，现在找到了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635566718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320386,"user_name":"姑射仙人","can_delete":false,"product_type":"c1","uid":1008517,"ip_address":"","ucode":"3EFC1F3E592165","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/85/1dc41622.jpg","comment_is_top":false,"comment_ctime":1636288054,"is_pvip":false,"replies":[{"id":"116175","content":"是工作在不同层次上的。mmap其实只负责将文件与内存页对应起来。至于这个页是缺页状态，还是在Cache里，或者在swap区域，都是操作系统关心的，mmap不需要知道这些的。有很多开源组件使用mmap来加速IO，这是很常见的技巧。更常见的是驱动开发里使用这个技巧。因为这部分的资料比较多了，而且和我们这个专栏的主题关联度也不是那么强，所以我就没写这部分内容。","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1636340521,"ip_address":"","comment_id":320386,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10226222646","product_id":100094901,"comment_content":"老师，mmap和Page Cache的使用有关系吗？像RocketMQ中写文件使用的内存映射文件。","like_count":2,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529975,"discussion_content":"是工作在不同层次上的。mmap其实只负责将文件与内存页对应起来。至于这个页是缺页状态，还是在Cache里，或者在swap区域，都是操作系统关心的，mmap不需要知道这些的。有很多开源组件使用mmap来加速IO，这是很常见的技巧。更常见的是驱动开发里使用这个技巧。因为这部分的资料比较多了，而且和我们这个专栏的主题关联度也不是那么强，所以我就没写这部分内容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636340521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319624,"user_name":"我是内存","can_delete":false,"product_type":"c1","uid":1711838,"ip_address":"","ucode":"3D763D4F434D50","user_header":"https://static001.geekbang.org/account/avatar/00/1a/1e/de/cdee1780.jpg","comment_is_top":false,"comment_ctime":1635868286,"is_pvip":false,"replies":[{"id":"115855","content":"1. 不行的哦，这个是linux内核源码写死的，要改就得改linux的源代码再重新编译。2. 你的比喻很直观，非常好，页表就是管户口的，没在页表里注册的，就是黑户，👍","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1635921115,"ip_address":"","comment_id":319624,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10225802878","product_id":100094901,"comment_content":"请问下：<br>1.IA-32的内存布局中kernel占1G，用户空间占3G，这个比例是可以随意调整的吗?<br>2.64bit的内存布局中，深色的空洞部分是表示它占着地方，但是没把它占据的空间添加到虚拟地址空间里面吧，相当于是一个黑户？","like_count":2,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529693,"discussion_content":"1. 不行的哦，这个是linux内核源码写死的，要改就得改linux的源代码再重新编译。2. 你的比喻很直观，非常好，页表就是管户口的，没在页表里注册的，就是黑户，👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635921115,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1711838,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/1e/de/cdee1780.jpg","nickname":"我是内存","note":"","ucode":"3D763D4F434D50","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":412207,"discussion_content":"就说如果定制剪裁的话，3:1这个比例是可以改的是吧，改完后引用到这个比例值的地方也会有相应的更新。不是说很多应用用不到3G那么大的虚拟空间嘛，那给kernel多分配一些是不是能提高一些性能？比如减少页交换啥的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636103366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318899,"user_name":"送过快递的码农","can_delete":false,"product_type":"c1","uid":1587666,"ip_address":"","ucode":"66EA81B3BADC73","user_header":"https://static001.geekbang.org/account/avatar/00/18/39/d2/845c0e39.jpg","comment_is_top":false,"comment_ctime":1635476115,"is_pvip":false,"replies":[{"id":"115616","content":"很全面！思考得很深入！非常好","user_name":"作者回复","user_name_real":"氦钠锶","uid":"1360512","ctime":1635553826,"ip_address":"","comment_id":318899,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10225410707","product_id":100094901,"comment_content":"我说下我的猜想，代码段，可读可执行，数据段：可读可写。至于堆：这个我猜想所在，如果单从我们写一个Hello World程序的时候，堆看起来有读写权限就行。但是，由于我们有实时编译技术，就从我知道的Java来说，有jit。虽然我从来没接触过这个大神，但是它本质上无非就是把一个动态字符穿实时编译成一个可执行字节码。由于通常字符串是在堆中的，所以编译成的可执行字节码是存在堆里面的。所以我猜想，堆里面肯定是有执行权限的。这个技术像Java可以进行字节码技术进行动态代理，大大增加了程序的灵活性，但是，也让程序有了被攻击的可能性，比如很多反序列化技术比如阿里巴巴的fastjson的bug应该和即时编译是有关系的。<br>老师我有个问题，就是之前在别的专栏里看的内容，说Linux进程和线程是在内核里面是一样的数据结构，那么进程的子进程和线程应该也是可区分的把，至少进程之前，内存除了共享内存，彼此之间是不能通讯的吧，但是线程是无条件使用进程的内存权限吧。内核还是能够区分这个任务是进程还是线程的吧","like_count":3,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529419,"discussion_content":"很全面！思考得很深入！非常好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635553826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330136,"user_name":"=","can_delete":false,"product_type":"c1","uid":2600127,"ip_address":"","ucode":"104232A8292220","user_header":"https://static001.geekbang.org/account/avatar/00/27/ac/bf/f549183e.jpg","comment_is_top":false,"comment_ctime":1641810073,"is_pvip":false,"replies":[{"id":"120891","content":"堆一般也是可写可读，要让他可执行，得用mmap或者mprotect接口主动去修改","user_name":"作者回复","user_name_real":"编辑","uid":"1360512","ctime":1642385543,"ip_address":"","comment_id":330136,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5936777369","product_id":100094901,"comment_content":"代码段：可读可执行<br>数据段：可读可写<br>堆：可读可写可执行","like_count":1,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546661,"discussion_content":"堆一般也是可写可读，要让他可执行，得用mmap或者mprotect接口主动去修改","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1642385543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326119,"user_name":"坚定的抢手","can_delete":false,"product_type":"c1","uid":2831233,"ip_address":"","ucode":"E5A5EC6196C518","user_header":"https://static001.geekbang.org/account/avatar/00/2b/33/81/3693f4d9.jpg","comment_is_top":false,"comment_ctime":1639386276,"is_pvip":false,"replies":[{"id":"118507","content":"好的。这个问题比较复杂，放在评论里篇幅太长了。我准备在最后开一个专题文章专门讲一下，就不在这里回答了。","user_name":"作者回复","user_name_real":"编辑","uid":"1360512","ctime":1639488515,"ip_address":"","comment_id":326119,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5934353572","product_id":100094901,"comment_content":"打开随机化的模式，会让内核在加载的过程中，对这些区域的起始地址增加一些随机的偏移值，这能增加缓冲区溢出的难度。<br>这个地方不太明白，为什么增加随机便宜值之后会增加缓冲区溢出的难度。希望老师能抽空解答一下。<br><br>网上查了一下关于随机化的作用，一般性的回答都是说，提高程序的安全防止攻击。","like_count":1,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538698,"discussion_content":"好的。这个问题比较复杂，放在评论里篇幅太长了。我准备在最后开一个专题文章专门讲一下，就不在这里回答了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639488515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358955,"user_name":"muzigef","can_delete":false,"product_type":"c1","uid":1670664,"ip_address":"北京","ucode":"BB65A61733D1D4","user_header":"https://static001.geekbang.org/account/avatar/00/19/7e/08/a50945c3.jpg","comment_is_top":false,"comment_ctime":1665064221,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665064221","product_id":100094901,"comment_content":"代码段跟数据段的中间有保护段，但是这 5 个内存区域乱序之后，保护段就失去作用了，系统如何保障代码段的安全呢","like_count":0},{"had_liked":false,"id":357448,"user_name":"zssdhr","can_delete":false,"product_type":"c1","uid":1010602,"ip_address":"北京","ucode":"2DFE1F017A46EB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/aa/ec09c4b4.jpg","comment_is_top":false,"comment_ctime":1663259451,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663259451","product_id":100094901,"comment_content":"老师，使用 mmap 共享内存，进程 A 修改的内容是不是需要刷新到磁盘后 进程 B 才能看见？这种共享内存的速度会不会比 System V 的 shm 共享内存方式（将多个进程的虚拟地址空间映射到同一块物理内存）慢？","like_count":0},{"had_liked":false,"id":340092,"user_name":"VenFox","can_delete":false,"product_type":"c1","uid":1002112,"ip_address":"","ucode":"11F08AD5685505","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/80/52e9e50e.jpg","comment_is_top":false,"comment_ctime":1648601630,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1648601630","product_id":100094901,"comment_content":"我们通常在 C 的代码里会将无效的指针赋值为 NULL。因此，这里会出现一段不可访问的内存保留区，防止程序因为出现 bug，导致读或写了一些小内存地址的数据，而使得程序跑飞。<br>老师，这段话看不太懂，设为null跟读写小内存地址有什么关系？","like_count":0},{"had_liked":false,"id":334199,"user_name":"佳伦","can_delete":false,"product_type":"c1","uid":1064508,"ip_address":"","ucode":"3AE8098B5BE716","user_header":"https://static001.geekbang.org/account/avatar/00/10/3e/3c/fc3ad983.jpg","comment_is_top":false,"comment_ctime":1644808206,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644808206","product_id":100094901,"comment_content":"什么时候使用brk分配，什么时候使用mmap呢？","like_count":0},{"had_liked":false,"id":329195,"user_name":"牙齿天天晒太阳","can_delete":false,"product_type":"c1","uid":2817633,"ip_address":"","ucode":"319289611BE05B","user_header":"https://static001.geekbang.org/account/avatar/00/2a/fe/61/2ee87c68.jpg","comment_is_top":false,"comment_ctime":1641204005,"is_pvip":false,"replies":[{"id":"120113","content":"没关系，先继续往下看。概念确实就是这样，一开始有点枯燥。动手实践最好的莫过于自己写一个toy操作系统和一个小语言。","user_name":"作者回复","user_name_real":"编辑","uid":"1360512","ctime":1641536037,"ip_address":"","comment_id":329195,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1641204005","product_id":100094901,"comment_content":"老师，感觉看了一堆概念，但是没有具体的了解，能否搞点实践呢。","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544474,"discussion_content":"没关系，先继续往下看。概念确实就是这样，一开始有点枯燥。动手实践最好的莫过于自己写一个toy操作系统和一个小语言。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641536037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329194,"user_name":"牙齿天天晒太阳","can_delete":false,"product_type":"c1","uid":2817633,"ip_address":"","ucode":"319289611BE05B","user_header":"https://static001.geekbang.org/account/avatar/00/2a/fe/61/2ee87c68.jpg","comment_is_top":false,"comment_ctime":1641203898,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641203898","product_id":100094901,"comment_content":"从图中你可以看到，在用户空间和内核空间之间有一个巨大的内存空洞。这块空间之所以用更深颜色来区分，是因为这块空间的不可访问是由 CPU 来保证的（这里的地址都不满足 Intel 64 的 Canonical form）。<br>==================<br>这段话没懂","like_count":0},{"had_liked":false,"id":327182,"user_name":"WA自动机","can_delete":false,"product_type":"c1","uid":2172274,"ip_address":"","ucode":"9328FF7AFC503A","user_header":"https://static001.geekbang.org/account/avatar/00/21/25/72/3d0af192.jpg","comment_is_top":false,"comment_ctime":1639969752,"is_pvip":false,"replies":[{"id":"119044","content":"继续向后看，学习完第十课可以自己再思考一下。如果还是没能解答你的疑问，可以加入微信群继续提问。","user_name":"作者回复","user_name_real":"编辑","uid":"1360512","ctime":1640016917,"ip_address":"","comment_id":327182,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1639969752","product_id":100094901,"comment_content":"老师，前面的文章提到过：通过虚拟内存，每个进程有独立的页表。用fork创建父子进程应该都是有自己独立的页表啊，他们是怎么做到共享内存的呢","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540324,"discussion_content":"继续向后看，学习完第十课可以自己再思考一下。如果还是没能解答你的疑问，可以加入微信群继续提问。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640016917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1016777,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/83/c9/5d03981a.jpg","nickname":"thomas","note":"","ucode":"9AB945308F1B50","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":541296,"discussion_content":"麻烦给下微信群号","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640325008,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":540324,"ip_address":""},"score":541296,"extra":""}]},{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546243,"discussion_content":"映射到同一块物理内存就行了～～","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1642252153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324673,"user_name":"Casper","can_delete":false,"product_type":"c1","uid":1022129,"ip_address":"","ucode":"69282EB175B48E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/b1/f89a84d0.jpg","comment_is_top":false,"comment_ctime":1638536637,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1638536637","product_id":100094901,"comment_content":"请教一下老师，在32位机器上, 我安装了4G的物理内存，内核会占据3G~4G的虚拟空间地址，此时内核的实际加载地址是3G~4G之间的某个位置上吗? <br>如果32位只安装了2G内存, 此时内核占据的内存会加载在什么地方呢?","like_count":0,"discussions":[{"author":{"id":2839104,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/52/40/1fe5be2b.jpg","nickname":"联通","note":"","ucode":"EAA1331CFAFDA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551051,"discussion_content":"物理内存和虚拟内存之间的映射不是按照地址一一对应的，虚拟内存划分的各种区域是逻辑上的概念，同时通过对页的权限控制达到不同的访问权限，不是物理上的概念","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1644889248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323497,"user_name":"龍少²⁰¹⁹","can_delete":false,"product_type":"c1","uid":1493902,"ip_address":"","ucode":"04C30390DFEC2F","user_header":"https://static001.geekbang.org/account/avatar/00/16/cb/8e/a1e9b721.jpg","comment_is_top":false,"comment_ctime":1637933534,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637933534","product_id":100094901,"comment_content":"1 “这 5 个内存区域通常是由高地址向低地址顺序排列的”，这句话是不是写反了，应该是“这 5 个内存区域通常是由低地址向高地址顺序排列的”；<br>2 brk是什么缩写呢？<br>3 elf文件的其他描述section又分别是做什么的呢？<br>4 Linux内存空间为什么和进程的虚拟空间共用一个虚拟内存空间呢？","like_count":0},{"had_liked":false,"id":322295,"user_name":"支离书","can_delete":false,"product_type":"c1","uid":1026921,"ip_address":"","ucode":"AD2570AC5EF7BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ab/69/5f1f0d1c.jpg","comment_is_top":false,"comment_ctime":1637292234,"is_pvip":false,"replies":[{"id":"117041","content":"这里只限可以直接运行的二进制文件。例如windows上的exe文件，linux上的elf文件哈。Java中是另外一回事，它是由JVM托管的。我们后面再谈哈。","user_name":"作者回复","user_name_real":"编辑","uid":"1360512","ctime":1637324841,"ip_address":"","comment_id":322295,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1637292234","product_id":100094901,"comment_content":"请教老师，数据段和BSS段存储的内容会变化吗？在java中，他们只存储基础类型的数据吗？如果是new一个object不就跑堆里了吗？","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531493,"discussion_content":"这里只限可以直接运行的二进制文件。例如windows上的exe文件，linux上的elf文件哈。Java中是另外一回事，它是由JVM托管的。我们后面再谈哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637324841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321845,"user_name":".","can_delete":false,"product_type":"c1","uid":1335848,"ip_address":"","ucode":"C0541289C44AF8","user_header":"https://static001.geekbang.org/account/avatar/00/14/62/28/0356880b.jpg","comment_is_top":false,"comment_ctime":1637064266,"is_pvip":false,"replies":[{"id":"117055","content":"地址随机是由两者一起决定的：操作系统的加载器生成随机地址，编译器保证产生的代码是地址无关代码。第二个问题：是的，这是前提。","user_name":"作者回复","user_name_real":"编辑","uid":"1360512","ctime":1637326568,"ip_address":"","comment_id":321845,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1637064266","product_id":100094901,"comment_content":"不大理解随机地址是由内核控制还是gcc的pie控制？<br>是不是只有启用gcc的pie内核才会对程序使用随机地址？","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531516,"discussion_content":"地址随机是由两者一起决定的：操作系统的加载器生成随机地址，编译器保证产生的代码是地址无关代码。第二个问题：是的，这是前提。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637326568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321052,"user_name":"逆童","can_delete":false,"product_type":"c1","uid":2693687,"ip_address":"","ucode":"C45F16951E01B6","user_header":"https://static001.geekbang.org/account/avatar/00/29/1a/37/5a5d88ea.jpg","comment_is_top":false,"comment_ctime":1636635469,"is_pvip":false,"replies":[{"id":"116617","content":"确实。正如开篇所说，这门课是从很多门课中，把它们里面与内存管理相关的部门垂直地总结出来的。如果依赖了其他模块，我尽量模糊处理的。你可以看看开篇词里提到的课。如果推荐书的话，机械工业出版社的《计算机组成》，《计算机体系结构》，《深入理解计算机系统》等书都是可以的。","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1636698311,"ip_address":"","comment_id":321052,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1636635469","product_id":100094901,"comment_content":"听了老师的3节课，很带劲儿。但感觉只有计算机组成原理和操作系统2块儿的基础，理解起来不够连贯。老师能从“入门打基础”和“进阶”的角度，推荐些书或者给出一个本课程相关的知识体系，这样学起来会更好","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530201,"discussion_content":"确实。正如开篇所说，这门课是从很多门课中，把它们里面与内存管理相关的部门垂直地总结出来的。如果依赖了其他模块，我尽量模糊处理的。你可以看看开篇词里提到的课。如果推荐书的话，机械工业出版社的《计算机组成》，《计算机体系结构》，《深入理解计算机系统》等书都是可以的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636698311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320689,"user_name":"Geek_27eb54","can_delete":false,"product_type":"c1","uid":2715118,"ip_address":"","ucode":"7D1EE10A61C7C0","user_header":"","comment_is_top":false,"comment_ctime":1636452472,"is_pvip":false,"replies":[{"id":"116320","content":"这种写进代码段的偏移都是编译时就决定了的。所以不会出现“小于”的情况。因为这些地址都是编译器根据地址的情况算出来的。至于你问的其他的，是不是数据段，只凭一个数字，我也没办法判断的。你要结合C++源代码去看。gcc打开-g选项，然后再用objdump查看可执行程序就能看到了。","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1636507409,"ip_address":"","comment_id":320689,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1636452472","product_id":100094901,"comment_content":"在加载动态链接库时，通常有3段内存值得关注，其中前两段是可读可执行的，通过分析是代码的，可以通过readelf看到要加载的两段，还有一段是可读可写的，这块是数据段么？？？我在调试过程中经常发现这样的一部分程序:<br>    ```<br>    add $0x4f196,%ebx<br>    mov 0x4a04(%ebx),%eax<br>    addl $0x1,0x10(%eax)<br>  ```<br>首先，ebx中存放的是当前的ip指针，通过加上一定的偏移指向了第三个可读可写的段的基址，基址+0x4a04后的数据，就是动态库中的数据段数据么？0x4a04是否是编译时就计算好的？是否会存在这个段分配的空间小于基址+0x4a04的情况？如果存在程序又是如何处理这种情况呢？<br>","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530084,"discussion_content":"这种写进代码段的偏移都是编译时就决定了的。所以不会出现“小于”的情况。因为这些地址都是编译器根据地址的情况算出来的。至于你问的其他的，是不是数据段，只凭一个数字，我也没办法判断的。你要结合C++源代码去看。gcc打开-g选项，然后再用objdump查看可执行程序就能看到了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636507409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319462,"user_name":"柒","can_delete":false,"product_type":"c1","uid":2419502,"ip_address":"","ucode":"D41241629321A1","user_header":"https://static001.geekbang.org/account/avatar/00/24/eb/2e/90fea784.jpg","comment_is_top":false,"comment_ctime":1635821046,"is_pvip":false,"replies":[{"id":"115851","content":"linux内核代码里的声明就是addr。形参就是个名字而已。","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1635920554,"ip_address":"","comment_id":319462,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1635821046","product_id":100094901,"comment_content":"void* mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset);<br>第一个形参名是start，而不是addr， 形参名  见名知意。","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529643,"discussion_content":"linux内核代码里的声明就是addr。形参就是个名字而已。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635920554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319358,"user_name":"鵼","can_delete":false,"product_type":"c1","uid":1101766,"ip_address":"","ucode":"F6561743835F7E","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/c6/6a2d0a5e.jpg","comment_is_top":false,"comment_ctime":1635758279,"is_pvip":false,"replies":[{"id":"115807","content":"第一个问题和第二个问题确实就是一回事。代码段在加载进内存时，它的大小就已经固定了，系统为它分配合适大小的虚拟内存。堆的最大大小也会受到限制的。如果不够用了，这就是out of memory咯，分配不出新的内存，你这时再调用分配内存的函数，就会得到NULL指针或者Errno，具体要看这个函数是怎么规定的。<br>最后一个问题，bss段是和数据段靠在一起的，因为它们的读写权限是一样的，不同之处仅仅是bss段全0填充，所以在磁盘文件中只记录大小，不需要真的弄一个全0的section。所以它不是堆也不是栈，也就不能动态分配或者变化大小。bss就是data segment。你可以思考一下全局声明一个数组和在函数内部声明一个数组，以及动态malloc一个数组，这三个数组分别在哪里。还可以自己动手试一下，验证一下自己的猜想。","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1635834650,"ip_address":"","comment_id":319358,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1635758279","product_id":100094901,"comment_content":"老师，有3个问题。<br>1.代码段是连续的虚拟内存空间吗？操作系统是按页划分的，每次加载一页的数据，如果代码段超过 4k，操作系统会出发缺页异常，然后再加载至内存 。此时重新加载的代码段是重新分配在其它位置还是说进程启动的时候会 固定一个大的虚拟内存空间作为代码段？感觉即使分了一个大的虚拟空间地址段，是不是也有用尽的时候？还是说操作系统在加载进程的时候已经知道代码段的范围了（进程的大小），所以分配虚拟内存空间 的时候 其实已经确定代码段范围了。那数据段的范围怎么确定呢？<br>2.其实也是第一个问题，堆的大小，不乱序还能理解，顺序乱的话，如果代码段在堆的高位上面，那堆的大小不是确定了吗？如果堆不够怎么办？虚拟空间不连续的堆，brk如何确定，有多个brk吗？<br>3.bss是未初始化的全局变量和static变量，记录的是长度。这个我想了想，应该就是为了减少内存空间，比如初始化一个长度比较大的数组，如果直接在data数据段分配，会占用很大内存，其实还都是0，所以bss至记录了变量名字和长度。那如果后续程序堆这个数组进行了赋值操作，因为只有长度和名称，所以是直接分配 在堆或者栈中的还是数据段中？bss的数据会有什么变化呢？","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529607,"discussion_content":"第一个问题和第二个问题确实就是一回事。代码段在加载进内存时，它的大小就已经固定了，系统为它分配合适大小的虚拟内存。堆的最大大小也会受到限制的。如果不够用了，这就是out of memory咯，分配不出新的内存，你这时再调用分配内存的函数，就会得到NULL指针或者Errno，具体要看这个函数是怎么规定的。\n最后一个问题，bss段是和数据段靠在一起的，因为它们的读写权限是一样的，不同之处仅仅是bss段全0填充，所以在磁盘文件中只记录大小，不需要真的弄一个全0的section。所以它不是堆也不是栈，也就不能动态分配或者变化大小。bss就是data segment。你可以思考一下全局声明一个数组和在函数内部声明一个数组，以及动态malloc一个数组，这三个数组分别在哪里。还可以自己动手试一下，验证一下自己的猜想。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635834650,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2837328,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/4b/50/fae00aff.jpg","nickname":"HollyWong","note":"","ucode":"03A66A2BCC0A58","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413742,"discussion_content":"全局声明一个数组，在磁盘上bss只记录了他的长度大小，到内存中就按记录的大小分配内存合并到数据段并初始化为0；\n在函数中声明数组，函数没被调用前在内存中根本就没它，调用后在栈里分配，调用后，被OS回收。\nmalloc一个数组，它是在堆里，由用户申请和调用free释放。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1636552944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318984,"user_name":"香港电影半边天","can_delete":false,"product_type":"c1","uid":1356897,"ip_address":"","ucode":"7FF04E52C41E17","user_header":"https://static001.geekbang.org/account/avatar/00/14/b4/61/77fbebe7.jpg","comment_is_top":false,"comment_ctime":1635497679,"is_pvip":false,"replies":[{"id":"115649","content":"第4篇马上就要更新啦，你值得拥有～","user_name":"作者回复","user_name_real":"Geek_989457","uid":"2767338","ctime":1635589012,"ip_address":"","comment_id":318984,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1635497679","product_id":100094901,"comment_content":"第8，9，10章快点上啊，期待。另外，老师讲的太快了，理解跟不上，吼吼","like_count":0,"discussions":[{"author":{"id":2767338,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/39/ea/6466ec81.jpg","nickname":"小可爱是我","note":"","ucode":"7465CBCBC67EEF","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529451,"discussion_content":"第4篇马上就要更新啦，你值得拥有～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635589012,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318902,"user_name":"大豆","can_delete":false,"product_type":"c1","uid":1350130,"ip_address":"","ucode":"BC78EF2336DBD0","user_header":"https://static001.geekbang.org/account/avatar/00/14/99/f2/c74d24d7.jpg","comment_is_top":false,"comment_ctime":1635476805,"is_pvip":false,"replies":[{"id":"115617","content":"1. 仔细看图哦。mmap区域在brk上面的，而且一般离得还比较远，这是为了brk实现起来更方便。实际上，sbrk每一次都要检查brk指针是否与mmap区域重叠。如果有重叠就调用失败了。<br>2. 虚拟机托管的语言，它的选择非常多。具体我在十一节会介绍。拿java举例，它可以选择使用进程栈，也可以自己模拟栈，这都可以。<br>3. 字节码一般是放在堆里的，因为是运行时分配的空间","user_name":"作者回复","user_name_real":"氦钠锶","uid":"1360512","ctime":1635555299,"ip_address":"","comment_id":318902,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1635476805","product_id":100094901,"comment_content":"1、通过mmap来创建一块区域，那么这块区域是从brk的位置开始吗？还是找到一块满足大小的空闲区域即可。<br>2、像Java、dart这类高级语言，其虚拟机中的堆、栈等区域的内存分配都是在进程的堆中吧。<br>3、像字节码这些内容应该是加载在进程的堆中吧。","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529421,"discussion_content":"1. 仔细看图哦。mmap区域在brk上面的，而且一般离得还比较远，这是为了brk实现起来更方便。实际上，sbrk每一次都要检查brk指针是否与mmap区域重叠。如果有重叠就调用失败了。\n2. 虚拟机托管的语言，它的选择非常多。具体我在十一节会介绍。拿java举例，它可以选择使用进程栈，也可以自己模拟栈，这都可以。\n3. 字节码一般是放在堆里的，因为是运行时分配的空间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635555299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318826,"user_name":"牧野","can_delete":false,"product_type":"c1","uid":1372185,"ip_address":"","ucode":"8F3B90C4462DE0","user_header":"https://static001.geekbang.org/account/avatar/00/14/f0/19/9d754804.jpg","comment_is_top":false,"comment_ctime":1635440570,"is_pvip":false,"replies":[{"id":"115599","content":"正确了一半，但不完全。<br>代码段只可执行吗？数据段里是全局变量哦，只可读吗？再想想？","user_name":"作者回复","user_name_real":"氦钠锶","uid":"1360512","ctime":1635475449,"ip_address":"","comment_id":318826,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1635440570","product_id":100094901,"comment_content":"代码段：可执行。数据段：可读。堆：可读可写","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529390,"discussion_content":"正确了一半，但不完全。\n代码段只可执行吗？数据段里是全局变量哦，只可读吗？再想想？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635475449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2837328,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/4b/50/fae00aff.jpg","nickname":"HollyWong","note":"","ucode":"03A66A2BCC0A58","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413739,"discussion_content":"代码段：只读（为了保护）、可执行。数据段：可读可写不可执行（也是为了安全）。堆：可读可写，可执行（为了灵活）。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1636552292,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2419502,"avatar":"https://static001.geekbang.org/account/avatar/00/24/eb/2e/90fea784.jpg","nickname":"柒","note":"","ucode":"D41241629321A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":410675,"discussion_content":"数据段当然可读可写啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635756627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}