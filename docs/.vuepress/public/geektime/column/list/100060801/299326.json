{"id":299326,"title":"10 | 存储模块：如何用Redis解决推荐系统特征的存储问题？","content":"<p>你好，我是王喆。今天，我们来解决系统特征的存储问题。</p><p>在特征工程篇我们说过，在推荐系统这个大饭馆中，特征工程就是负责配料和食材的厨师，那我们上堂课搭建的推荐服务器就是准备做菜的大厨。配料和食材准备好了，做菜的大厨也已经开火热锅了，这时候我们得把食材及时传到大厨那啊。这个传菜的过程就是推荐系统特征的存储和获取过程。</p><p>可是我们知道，类似Embedding这样的特征是在离线环境下生成的，而推荐服务器是在线上环境中运行的，那这些<strong>离线的特征数据是如何导入到线上让推荐服务器使用的呢？</strong></p><p>今天，我们先以Netflix的推荐系统架构为例，来讲一讲存储模块在整个系统中的位置，再详细来讲推荐系统存储方案的设计原则，最后以Redis为核心搭建起Sparrow Recsys的存储模块。</p><h2>推荐系统存储模块的设计原则</h2><p>你还记得，我曾在<a href=\"https://time.geekbang.org/column/article/288917\">第1讲的课后题</a>中贴出过Netflix推荐系统的架构图（如图1）吗？Netflix采用了非常经典的Offline、Nearline、Online三层推荐系统架构。架构图中最核心的位置就是我在图中用红框标出的部分，它们是三个数据库Cassandra、MySQL和EVcache，这三个数据库就是Netflix解决特征和模型参数存储问题的钥匙。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/bc/ca/bc6d770cb20dfc90cc07168d626fd7ca.jpg?wh=1440*1587\" alt=\"\" title=\"图1 Netflix推荐系统架构中的特征与模型数据库\"></p><p>你可能会觉得，存储推荐特征和模型这件事情一点儿都不难啊。不就是找一个数据库把离线的特征存起来，然后再给推荐服务器写几个SQL让它取出来用不就行了吗？为什么还要像Netflix这样兴师动众地搞三个数据库呢？</p><p>想要搞明白这个问题，我们就得搞清楚设计推荐系统存储模块的原则。对于推荐服务器来说，由于线上的QPS压力巨大，每次有推荐请求到来，推荐服务器都需要把相关的特征取出。这就要求推荐服务器一定要“快”。</p><p>不仅如此，对于一个成熟的互联网应用来说，它的用户数和物品数一定是巨大的，几千万上亿的规模是十分常见的。所以对于存储模块来说，这么多用户和物品特征所需的存储量会特别大。这个时候，事情就很难办了，又要存储量大，又要查询快，还要面对高QPS的压力。很不幸，没有一个独立的数据库能<strong>经济又高效</strong>地单独完成这样复杂的任务。</p><p>因此，几乎所有的工业级推荐系统都会做一件事情，就是把特征的存储做成分级存储，把越频繁访问的数据放到越快的数据库甚至缓存中，把海量的全量数据放到便宜但是查询速度较慢的数据库中。</p><p>举个不恰当的例子，如果你把特征数据放到基于HDFS的HBase中，虽然你可以轻松放下所有的特征数据，但要让你的推荐服务器直接访问HBase进行特征查询，等到查询完成，这边用户的请求早就超时中断了，而Netflix的三个数据库正好满足了这样分级存储的需求。</p><p><img src=\"https://static001.geekbang.org/resource/image/03/78/0310b59276fde9eeec5d9cd946fef078.jpeg?wh=1336*1080\" alt=\"\" title=\"图2 分级存储的设计\"></p><p>比如说，Netflix使用的Cassandra，它作为流行的NoSQL数据库，具备大数据存储的能力，但为支持推荐服务器高QPS的需求，我们还需要把最常用的特征和模型参数存入EVcache这类内存数据库。而对于更常用的数据，我们可以把它们存储在Guava Cache等服务器内部缓存，甚至是服务器的内存中。总之，对于一个工程师来说，我们经常需要做出技术上的权衡，达成一个在花销和效果上平衡最优的技术方案。</p><p>而对于MySQL来说，由于它是一个强一致性的关系型数据库，一般存储的是比较关键的要求强一致性的信息，比如物品是否可以被推荐这种控制类的信息，物品分类的层级关系，用户的注册信息等等。这类信息一般是由推荐服务器进行阶段性的拉取，或者利用分级缓存进行阶段性的更新，避免因为过于频繁的访问压垮MySQL。</p><p>总的来说，推荐系统存储模块的设计原则就是“<strong>分级存储，把越频繁访问的数据放到越快的数据库甚至缓存中，把海量的全量数据放到廉价但是查询速度较慢的数据库中</strong>”。</p><h2>SparrowRecsys的存储系统方案</h2><p>那在我们要实现的SparrowRecsys中，存储模块的设计原则又是怎么应用的呢？</p><p>在SparrowRecsys中，我们把存储模块的设计问题进行了一些简化，避免由于系统设计得过于复杂导致你不易上手。</p><p>我们使用基础的文件系统保存全量的离线特征和模型数据，用Redis保存线上所需特征和模型数据，使用服务器内存缓存频繁访问的特征。</p><p>在实现技术方案之前，对于问题的整体分析永远都是重要的。我们需要先确定具体的存储方案，这个方案必须精确到哪级存储对应哪些具体特征和模型数据。</p><p>存储的工具已经知道了，那特征和模型数据分别是什么呢？这里，我们直接应用特征工程篇为SparrowRecsys准备好的一些特征就可以了。我把它们的具体含义和数据量级整理成了表格，如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/d9/2a/d9cf4b8899ff4442bc7cd87f502a9c2a.jpeg?wh=1920*777\" alt=\"\" title=\"图3 特征和模型数据\"></p><p>根据上面的特征数据，我们一起做一个初步的分析。首先，用户特征的总数比较大，它们很难全部载入到服务器内存中，所以我们把用户特征载入到Redis之类的内存数据库中是合理的。其次，物品特征的总数比较小，而且每次用户请求，一般只会用到一个用户的特征，但为了物品排序，推荐服务器需要访问几乎所有候选物品的特征。针对这个特点，我们完全可以把所有物品特征阶段性地载入到服务器内存中，大大减少Redis的线上压力。</p><p>最后，我们还要找一个地方去存储特征历史数据、样本数据等体量比较大，但不要求实时获取的数据。这个时候分布式文件系统（单机环境下以本机文件系统为例）往往是最好的选择，由于类似HDFS之类的分布式文件系统具有近乎无限的存储空间，我们可以把每次处理的全量特征，每次训练的Embedding全部保存到分布式文件系统中，方便离线评估时使用。</p><p>经过上面的分析，我们就得到了具体的存储方案，如下表：</p><p><img src=\"https://static001.geekbang.org/resource/image/34/63/34958066e8704ea2780d7f8007e18463.jpeg?wh=1920*594\" alt=\"\" title=\"图4 SparrowRecsys的存储方案\"></p><p>此外，文件系统的存储操作非常简单，在SparrowRecsys中就是利用Spark的输出功能实现的，我们就不再重点介绍了。而服务器内部的存储操作主要是跟Redis进行交互，所以接下来，我们重点介绍Redis的特性以及写入和读取方法。</p><h2>你需要知道的Redis基础知识</h2><p>Redis是当今业界最主流的内存数据库，那在使用它之前，我们应该清楚Redis的两个主要特点。</p><p><strong>一是所有的数据都以Key-value的形式存储。</strong> 其中，Key只能是字符串，value可支持的数据结构包括string(字符串)、list(链表)、set(集合)、zset(有序集合)和hash(哈希)。这个特点决定了Redis的使用方式，无论是存储还是获取，都应该以键值对的形式进行，并且根据你的数据特点，设计值的数据结构。</p><p><strong>二是所有的数据都存储在内存中，磁盘只在持久化备份或恢复数据时起作用</strong>。这个特点决定了Redis的特性，一是QPS峰值可以很高，二是数据易丢失，所以我们在维护Redis时要充分考虑数据的备份问题，或者说，不应该把关键的业务数据唯一地放到Redis中。但对于可恢复，不关乎关键业务逻辑的推荐特征数据，就非常适合利用Redis提供高效的存储和查询服务。</p><p>在实际的Sparrow Recsys的Redis部分中，我们用到了Redis最基本的操作，set、get和keys，value的数据类型用到了string。</p><h2>Sparrow Recsys中的Redis部分的实践流程</h2><p>Redis的实践流程还是符合我们“把大象装冰箱”的三部曲，只不过，这三步变成了安装Redis，把数据写进去，把数据读出来。下面，我们来逐一来讲。</p><p><strong>首先是安装Redis。</strong> Redis的安装过程在linux/Unix环境下非常简单，你参照<a href=\"http://www.redis.cn/download.html\">官方网站的步骤</a>依次执行就好。Windows环境下的安装过程稍复杂一些，你可以参考<a href=\"https://www.cnblogs.com/liuqingzheng/p/9831331.html\">这篇文章</a>进行安装。</p><p>在启动Redis之后，如果没有特殊的设置，Redis服务会默认运行在6379端口，没有特殊情况保留这个默认的设置就可以了，因为我们的Sparrow RecSys也是默认从6379端口存储和读取Redis数据的。</p><p><strong>然后是运行离线程序，通过jedis客户端写入Redis。</strong> 在Redis运行起来之后，我们就可以在离线Spark环境下把特征数据写入Redis。这里我们以[第8讲(<a href=\"https://time.geekbang.org/column/article/296932\">https://time.geekbang.org/column/article/296932</a>)中生成的Embedding数据为例，来实现Redis的特征存储过程。</p><p>实际的过程非常简单，首先我们利用最常用的Redis Java客户端Jedis生成redisClient，然后遍历训练好的Embedding向量，将Embedding向量以字符串的形式存入Redis，并设置过期时间（ttl）。具体实现请参考下面的代码（代码参考com.wzhe.sparrowrecsys.offline.spark.featureeng.Embedding 中的trainItem2vec函数）：</p><pre><code>if (saveToRedis) {\n  //创建redis client\n  val redisClient = new Jedis(redisEndpoint, redisPort)\n  val params = SetParams.setParams()\n  //设置ttl为24小时\n  params.ex(60 * 60 * 24)\n  //遍历存储embedding向量\n  for (movieId &lt;- model.getVectors.keys) {\n    //key的形式为前缀+movieId，例如i2vEmb:361\n    //value的形式是由Embedding向量生成的字符串，例如 &quot;0.1693846 0.2964318 -0.13044095 0.37574086 0.55175656 0.03217995 1.327348 -0.81346786 0.45146862 0.49406642&quot;\n    redisClient.set(redisKeyPrefix + &quot;:&quot; + movieId, model.getVectors(movieId).mkString(&quot; &quot;), params)\n  }\n  //关闭客户端连接\n  redisClient.close()\n}\n\n</code></pre><p><strong>最后是在推荐服务器中把Redis数据读取出来。</strong></p><p>在服务器端，根据刚才梳理出的存储方案，我们希望服务器能够把所有物品Embedding阶段性地全部缓存在服务器内部，用户Embedding则进行实时查询。这里，我把缓存物品Embedding的代码放在了下面。</p><p>你可以看到，它的实现的过程也并不复杂，就是先用keys操作把所有物品Embedding前缀的键找出，然后依次将Embedding载入内存。</p><pre><code>//创建redis client\nJedis redisClient = new Jedis(REDIS_END_POINT, REDIS_PORT);\n//查询出所有以embKey为前缀的数据\nSet&lt;String&gt; movieEmbKeys = redisClient.keys(embKey + &quot;*&quot;);\nint validEmbCount = 0;\n//遍历查出的key\nfor (String movieEmbKey : movieEmbKeys){\n    String movieId = movieEmbKey.split(&quot;:&quot;)[1];\n    Movie m = getMovieById(Integer.parseInt(movieId));\n    if (null == m) {\n        continue;\n    }\n    //用redisClient的get方法查询出key对应的value，再set到内存中的movie结构中\n    m.setEmb(parseEmbStr(redisClient.get(movieEmbKey)));\n    validEmbCount++;\n}\nredisClient.close();\n\n</code></pre><p>这样一来，在具体为用户推荐的过程中，我们再利用相似的接口查询出用户的Embedding，与内存中的Embedding进行相似度的计算，就可以得到最终的推荐列表了。</p><p>如果你已经安装好了Redis，我非常推荐你运行SparrowRecsys中Offline部分Embedding主函数，先把物品和用户Embedding生成并且插入Redis（注意把saveToRedis变量改为true）。然后再运行Online部分的RecSysServer，看一下推荐服务器有没有正确地从Redis中读出物品和用户Embedding并产生正确的推荐结果（注意，记得要把util.Config中的EMB_DATA_SOURCE配置改为DATA_SOURCE_REDIS）。</p><p>当然，除了Redis，我们还提到了多种不同的缓存和数据库，如Cassandra、EVcache、GuavaCache等等，它们都是业界非常流行的存储特征的工具，你有兴趣的话也可以在课后查阅相关资料进行进一步的学习。在掌握了我们特征存储的基本原则之后，你也可以在业余时间尝试思考一下每个数据库的不同和它们最合适的应用场景。</p><h2>小结</h2><p>今天我们学习了推荐系统存储模块的设计原则和具体的解决方案，并且利用Sparrow Recsys进行了实战。</p><p>在设计推荐系统存储方案时，我们一般要遵循“分级存储”的原则，在开销和性能之间取得权衡。在Sparrow Recsys的实战中，我们安装并操作了内存数据库Redis，你要记住Redis的特点“Key-value形式存储”和“纯内存数据库”。在具体的特征存取过程中，我们应该熟悉利用jedis执行SET，GET等Redis常用操作的方法。</p><p>最后，我也把重要的知识点总结在了下面，你可以再回顾一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/5f/08/5f76090e7742593928eaf118d72d2b08.jpeg?wh=1920*712\" alt=\"\"></p><p>对于搭建一套完整的推荐服务来说，我们已经迈过了两大难关，分别是用Jetty Server搭建推荐服务器问题，以及用Redis解决特征存储的问题。下节课，我们会一起来挑战线上服务召回层的设计。</p><h2>课后思考</h2><p>你觉得课程中存储Embedding的方式还有优化的空间吗？除了string，我们是不是还可以用其他Redis value的数据结构存储Embedding数据，那从效率的角度考虑，使用string和使用其他数据结构的优缺点有哪些？为什么？</p><p>欢迎把你的思考和答案写在留言区，也欢迎你把这节课分享给你的朋友，我们下节课见！</p>","comments":[{"had_liked":false,"id":256541,"user_name":"An","can_delete":false,"product_type":"c1","uid":1062147,"ip_address":"","ucode":"D7E5B984C30AA1","user_header":"https://static001.geekbang.org/account/avatar/00/10/35/03/57ddf921.jpg","comment_is_top":false,"comment_ctime":1603674156,"is_pvip":false,"replies":[{"id":"93394","content":"非常好的点。生产环境我们一般选择提前载入一些warm up物品id的方式载入物品embedding。这里做了一个简化，推荐大家参考这条评论，多谢！","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1603692558,"ip_address":"","comment_id":256541,"utype":1}],"discussion_count":1,"race_medal":0,"score":"216352038956","product_id":100060801,"comment_content":"redis keys命令不能用在生产环境中，如果数量过大效率十分低，导致redis长时间堵塞在keys上。","like_count":50,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508047,"discussion_content":"非常好的点。生产环境我们一般选择提前载入一些warm up物品id的方式载入物品embedding。这里做了一个简化，推荐大家参考这条评论，多谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603692558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":256598,"user_name":"AIGeek","can_delete":false,"product_type":"c1","uid":1007346,"ip_address":"","ucode":"D87C69F9169412","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/f2/bd3a45f5.jpg","comment_is_top":false,"comment_ctime":1603688739,"is_pvip":true,"replies":[{"id":"93404","content":"生产环境确实经常使用protobuf进行压缩，非常好的经验。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1603693022,"ip_address":"","comment_id":256598,"utype":1}],"discussion_count":4,"race_medal":0,"score":"160517478691","product_id":100060801,"comment_content":"Redis value 可以用pb格式存储, 存储上节省空间. 解析起来相比string, cpu的效率也应该会更高","like_count":37,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508066,"discussion_content":"生产环境确实经常使用protobuf进行压缩，非常好的经验。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603693022,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2308143,"avatar":"https://static001.geekbang.org/account/avatar/00/23/38/2f/8bf9e860.jpg","nickname":"吕天意","note":"","ucode":"AD771C4EB390DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329351,"discussion_content":"protobuf 格式缺失是可以大幅压缩存储，节约存储空间，但是相对应的数据解压和可读性上(调试时)是有折扣的。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1606370100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1944884,"avatar":"","nickname":"AstrHan","note":"","ucode":"14C5F3323A472D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329386,"discussion_content":"我以前试过，感觉没有比json快，也可能存的类型和数据量有关？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606377113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1944884,"avatar":"","nickname":"AstrHan","note":"","ucode":"14C5F3323A472D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334057,"discussion_content":"protobuf需要反序列化压缩数据，效率上不一定比json高，主要的benefit在于大幅节省存储空间。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1607715248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":329386,"ip_address":""},"score":334057,"extra":""}]}]},{"had_liked":false,"id":264267,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1606397426,"is_pvip":false,"replies":[{"id":"95834","content":"优秀。非常好的经验之谈，推荐其他同学学习。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1606415672,"ip_address":"","comment_id":264267,"utype":1}],"discussion_count":4,"race_medal":0,"score":"134750383602","product_id":100060801,"comment_content":"1.redis这种缓存中尽量放活跃的数据，存放全量的embedding数据，对内存消耗太大。尤其物品库，用户embedding特别多的情况下。<br>2.分布式kv可以做这种embedding的存储<br>3.关于embedding的编码可以用pb来解决。embedding维度太大的时候，redis里的数据结构占用空间会变大，因为除了embedding本身的空间，还有数据结构本身占用的空间。","like_count":31,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510485,"discussion_content":"优秀。非常好的经验之谈，推荐其他同学学习。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606415672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2115316,"avatar":"https://static001.geekbang.org/account/avatar/00/20/46/f4/93b1275b.jpg","nickname":"Alan","note":"","ucode":"591A28E310A8F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352309,"discussion_content":"这里pd可以理解为pandas的三种Series、DataFrame、Time-series数据结构吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614678674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1073125,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","nickname":"范闲","note":"","ucode":"F21FD7DF6BA53C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2115316,"avatar":"https://static001.geekbang.org/account/avatar/00/20/46/f4/93b1275b.jpg","nickname":"Alan","note":"","ucode":"591A28E310A8F5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352324,"discussion_content":"Pd？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614684053,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":352309,"ip_address":""},"score":352324,"extra":""},{"author":{"id":1349749,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK6mh3xlaMoGtWjmVJh2LutdLcQcPbKNjRlVru3bx8ynPhgwuGhhdzTkwEMoXbvBtgkcDSfom1kZg/132","nickname":"夜雨声烦","note":"","ucode":"87D8DB1E32522A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2115316,"avatar":"https://static001.geekbang.org/account/avatar/00/20/46/f4/93b1275b.jpg","nickname":"Alan","note":"","ucode":"591A28E310A8F5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372589,"discussion_content":"是pb protobuf，不是pd","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620388289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":352309,"ip_address":""},"score":372589,"extra":""}]}]},{"had_liked":false,"id":258570,"user_name":"fsc2016","can_delete":false,"product_type":"c1","uid":1255585,"ip_address":"","ucode":"5480F05703A974","user_header":"https://static001.geekbang.org/account/avatar/00/13/28/a1/fd2bfc25.jpg","comment_is_top":false,"comment_ctime":1604486754,"is_pvip":false,"replies":[{"id":"94136","content":"这两个问题都是非常好的问题，推荐其他同学思考。<br><br>1. 我们并没有把用户embedding保存在内存中，只是把item embedding提前load到内存里，所以其实不存在这样的情况。但你说的也是非常好的用户数据缓存的方案，我们一般会指定一个用户内存区域的大小，用FIFO的方案来缓存，这样内存用完了，就自动把早进来的用户pop出去。<br><br>另外分级的想法也非常好，如果有条件可以判断活跃用户，可以尽量选择活跃用户进行缓存。<br><br>2、你说的没错，用户emb和物品emb必须在一个向量空间内才能够做相似度计算。咱们项目中的用户emb是通过item emb平均生成的，所以可以这样计算。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1604529405,"ip_address":"","comment_id":258570,"utype":1}],"discussion_count":1,"race_medal":0,"score":"83208865378","product_id":100060801,"comment_content":"老师，有俩个问题<br>1，文中关于RecForYou，是来一个用户访问，就把用户的embding存入推荐服务器内存，如果一个短时间一下来百万级用户，都存入服务器内存，这样会不会出问题，优化的话应当也可以对用户分级，活跃用户存下来，非活跃其他还是从Redis实时读取用户特征。<br>2，RecForYou中，给用户推荐电影，使用的用户embding和候选电影embding的余弦距离来排序，这俩个不同维度embding计算余弦相似度有意义嘛，还是因为本例子中用户embding由其看过的电影embbding 相加来的。所以这么做嘛","like_count":20,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508698,"discussion_content":"这两个问题都是非常好的问题，推荐其他同学思考。\n\n1. 我们并没有把用户embedding保存在内存中，只是把item embedding提前load到内存里，所以其实不存在这样的情况。但你说的也是非常好的用户数据缓存的方案，我们一般会指定一个用户内存区域的大小，用FIFO的方案来缓存，这样内存用完了，就自动把早进来的用户pop出去。\n\n另外分级的想法也非常好，如果有条件可以判断活跃用户，可以尽量选择活跃用户进行缓存。\n\n2、你说的没错，用户emb和物品emb必须在一个向量空间内才能够做相似度计算。咱们项目中的用户emb是通过item emb平均生成的，所以可以这样计算。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604529405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263515,"user_name":"Lucifer","can_delete":false,"product_type":"c1","uid":2325595,"ip_address":"","ucode":"FE65094A67640D","user_header":"https://static001.geekbang.org/account/avatar/00/23/7c/5b/7a8d842c.jpg","comment_is_top":false,"comment_ctime":1606146028,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"31670917100","product_id":100060801,"comment_content":"向量索引faiss","like_count":7,"discussions":[{"author":{"id":1697075,"avatar":"","nickname":"Sanders","note":"","ucode":"3D460FEEDCDF34","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348020,"discussion_content":"milvus","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1612405657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":266154,"user_name":"Geek_ddf8b1","can_delete":false,"product_type":"c1","uid":2309043,"ip_address":"","ucode":"70E1BB4C1CC6C4","user_header":"","comment_is_top":false,"comment_ctime":1607219186,"is_pvip":false,"replies":[{"id":"96782","content":"是这样，长期兴趣或这说周期比较长的metadata特征，按天写入特征数据库，实时特征进行实时更新。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1607389778,"ip_address":"","comment_id":266154,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27377022962","product_id":100060801,"comment_content":"<br>        用户特征分为长期兴趣特征和实时兴趣特征，长期兴趣特征一般是按天更新，实时特征可能按分钟或者秒级更新。请问实际项目中是长期特征按天更新写入redis，短期特征分钟级更新写入redis这样吗？ ","like_count":6,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511165,"discussion_content":"是这样，长期兴趣或这说周期比较长的metadata特征，按天写入特征数据库，实时特征进行实时更新。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607389778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258604,"user_name":"shenhuaze","can_delete":false,"product_type":"c1","uid":1960811,"ip_address":"","ucode":"32927236CBEA0B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/qw7rRHUPRzhibxXWLG7kc3zkhZwBn4JZaryzko2eWOjSxDlRvUathHugrIVKhcCqxhtsANUTq0140AlbDkLZmcw/132","comment_is_top":false,"comment_ctime":1604499733,"is_pvip":false,"replies":[{"id":"94144","content":"一般来说Cassandra的读性能会比HBase好很多，包括类似的AWS用的dynamoDB，现在用得多一些。<br><br>但也有对HBase的读性能做优化的，比如加缓存，做一些读取命令的优化，但作为服务线上的实时数据库，确实会用的少一些。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1604534599,"ip_address":"","comment_id":258604,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27374303509","product_id":100060801,"comment_content":"王老师，想问一下关于全量特征存储的数据库选型。业界用来存储全量特征的最主流的数据库是什么？Cassandra吗？HBase是否合适？","like_count":6,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508709,"discussion_content":"一般来说Cassandra的读性能会比HBase好很多，包括类似的AWS用的dynamoDB，现在用得多一些。\n\n但也有对HBase的读性能做优化的，比如加缓存，做一些读取命令的优化，但作为服务线上的实时数据库，确实会用的少一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604534599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":272457,"user_name":"Geek_b6bf29","can_delete":false,"product_type":"c1","uid":2016648,"ip_address":"","ucode":"F9823DEAEA5EF8","user_header":"","comment_is_top":false,"comment_ctime":1610093758,"is_pvip":false,"replies":[{"id":"98793","content":"在线服务内部可以有各种载入和维护feature的缓存逻辑。最简单比如设置一个timer去定期load热门的新feature。不用重启服务器。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1610145821,"ip_address":"","comment_id":272457,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23084930238","product_id":100060801,"comment_content":"老师你好，关于这一步 “我们完全可以把所有物品特征阶段性地载入到服务器内存中，大大减少 Redis 的线上压力。” 该如何具体操作呢。比如离线计算每6个小时更新物品特征，是不是在线服务也要重启更新，把最新的物品特征载入服务器？还是有更好的方法，可以支持热更新，不用重启在线服务？","like_count":5,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513287,"discussion_content":"在线服务内部可以有各种载入和维护feature的缓存逻辑。最简单比如设置一个timer去定期load热门的新feature。不用重启服务器。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610145821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283902,"user_name":"张宏宇","can_delete":false,"product_type":"c1","uid":2451461,"ip_address":"","ucode":"4215918FB5CD1A","user_header":"https://static001.geekbang.org/account/avatar/00/25/68/05/e39a9cc8.jpg","comment_is_top":false,"comment_ctime":1615978760,"is_pvip":false,"replies":[{"id":"103415","content":"这个肯定会存在。但我觉得要点还得具体问题具体分析，要看一下物品和用户特征有没有必要完全协同的更新，比如物品历史ctr这个特征，完全可以独立更新。<br><br>如果一定要一起更新，那么就只能在streaming平台上每次都协同更新这些特征。<br><br>我个人觉得有一些秒级、分钟级的差异，影响不会那么大，没有那么关键。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1616636344,"ip_address":"","comment_id":283902,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18795847944","product_id":100060801,"comment_content":"老师，我想问的是特征在更新的时候可能发生数据不一致的情况，比如用户特征先更新，物品特征后更新，在两个特征更新过程中线上服务读取特征数据的时候，可能用户特征是新的，物品特征是老的，不知道老师是否遇到过这样的问题以及如何解决的，谢谢！","like_count":4,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517175,"discussion_content":"这个肯定会存在。但我觉得要点还得具体问题具体分析，要看一下物品和用户特征有没有必要完全协同的更新，比如物品历史ctr这个特征，完全可以独立更新。\n\n如果一定要一起更新，那么就只能在streaming平台上每次都协同更新这些特征。\n\n我个人觉得有一些秒级、分钟级的差异，影响不会那么大，没有那么关键。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616636344,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258321,"user_name":"Jackie","can_delete":false,"product_type":"c1","uid":2199565,"ip_address":"","ucode":"AB22242B6E05A7","user_header":"https://static001.geekbang.org/account/avatar/00/21/90/0d/331cb979.jpg","comment_is_top":false,"comment_ctime":1604386002,"is_pvip":false,"replies":[{"id":"94118","content":"那按照咱们这节课讲的分级存储的原则，内存里面放不下，应该怎么解决这个问题呢？能不能放一些经常访问的在内存里，长尾的放在其他地方？或者经常用的特征放内存里等等方法？","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1604464430,"ip_address":"","comment_id":258321,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10194320594","product_id":100060801,"comment_content":"文中说把物品特征放到服务器中，“我们完全可以把所有物品特征阶段性地载入到服务器内存中，大大减少 Redis 的线上压力。”，那如果物品也特别多，不也放不下吗？","like_count":2,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508618,"discussion_content":"那按照咱们这节课讲的分级存储的原则，内存里面放不下，应该怎么解决这个问题呢？能不能放一些经常访问的在内存里，长尾的放在其他地方？或者经常用的特征放内存里等等方法？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604464430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2115316,"avatar":"https://static001.geekbang.org/account/avatar/00/20/46/f4/93b1275b.jpg","nickname":"Alan","note":"","ucode":"591A28E310A8F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352317,"discussion_content":"计算Top全网热门商品、计算类别TopN商品，将这些存到redis应该能满足推荐需求了！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614680783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":256570,"user_name":"浣熊当家","can_delete":false,"product_type":"c1","uid":1952248,"ip_address":"","ucode":"939F06050423E4","user_header":"https://static001.geekbang.org/account/avatar/00/1d/c9/f8/72955ef9.jpg","comment_is_top":false,"comment_ctime":1603680590,"is_pvip":false,"replies":[{"id":"93400","content":"spark本质上是一个java lib，所以可以被maven安装依赖。<br><br>redis是一个数据库，需要按照文中的方式安装到电脑上。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1603692857,"ip_address":"","comment_id":256570,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10193615182","product_id":100060801,"comment_content":"有个很小白的问题请问老师， 我们在IntelliJ的Maven porject里用到的工具比如spark， redis， 这些需要我们额外下载安装到电脑上吗？还是说在Maven项目中已经通过代码添加依赖，就已经完成了安装？","like_count":2,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508057,"discussion_content":"spark本质上是一个java lib，所以可以被maven安装依赖。\n\nredis是一个数据库，需要按照文中的方式安装到电脑上。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603692857,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":256567,"user_name":"浣熊当家","can_delete":false,"product_type":"c1","uid":1952248,"ip_address":"","ucode":"939F06050423E4","user_header":"https://static001.geekbang.org/account/avatar/00/1d/c9/f8/72955ef9.jpg","comment_is_top":false,"comment_ctime":1603679870,"is_pvip":false,"replies":[{"id":"93398","content":"可以，请参照 com.wzhe.sparrowrecsys.offline.spark.embedding.Embedding中的trainItem2vec函数<br><br>以及com.wzhe.sparrowrecsys.online.datamanager.DataManager中的loadMovieEmb函数","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1603692792,"ip_address":"","comment_id":256567,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10193614462","product_id":100060801,"comment_content":"请问老师，文中的两部分redis相关的代码，可以在Maven项目中找到吗？老师可不可以提供以下路径信息方便找到？","like_count":2,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508056,"discussion_content":"可以，请参照 com.wzhe.sparrowrecsys.offline.spark.embedding.Embedding中的trainItem2vec函数\n\n以及com.wzhe.sparrowrecsys.online.datamanager.DataManager中的loadMovieEmb函数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603692792,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":272698,"user_name":"胡译匀","can_delete":false,"product_type":"c1","uid":2378174,"ip_address":"","ucode":"B675D1C76520E1","user_header":"https://static001.geekbang.org/account/avatar/00/24/49/be/6ee1c9da.jpg","comment_is_top":false,"comment_ctime":1610235716,"is_pvip":false,"replies":[{"id":"98856","content":"scala 程序本质上就是java程序，在IDEA里面的调试方法和java一样","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1610264074,"ip_address":"","comment_id":272698,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5905203012","product_id":100060801,"comment_content":"请问如何调试scala程序？网上找了半天也没靠谱的，谢谢。","like_count":1,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513359,"discussion_content":"scala 程序本质上就是java程序，在IDEA里面的调试方法和java一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610264074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":268382,"user_name":"romance","can_delete":false,"product_type":"c1","uid":1029768,"ip_address":"","ucode":"393DC641CCE86E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b6/88/e8deccbc.jpg","comment_is_top":false,"comment_ctime":1608172104,"is_pvip":false,"replies":[{"id":"97467","content":"只要正确安装了scala并且配置好了maven环境，能够引入spark的lib，就可以跑起来。项目的默认环境是单机环境，不需要任何外部spark环境","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1608246960,"ip_address":"","comment_id":268382,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5903139400","product_id":100060801,"comment_content":"老师，Embedding 主函数要装了Spark才能跑起来吧？","like_count":1,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511930,"discussion_content":"只要正确安装了scala并且配置好了maven环境，能够引入spark的lib，就可以跑起来。项目的默认环境是单机环境，不需要任何外部spark环境","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608246960,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":266155,"user_name":"Geek_ddf8b1","can_delete":false,"product_type":"c1","uid":2309043,"ip_address":"","ucode":"70E1BB4C1CC6C4","user_header":"","comment_is_top":false,"comment_ctime":1607219321,"is_pvip":false,"replies":[{"id":"96785","content":"不可能直接从kafka读取的，线上系统不可能接入任何流处理系统。需要以redis这类特征数据库作为所有数据的线上中转存储。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1607389882,"ip_address":"","comment_id":266155,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5902186617","product_id":100060801,"comment_content":"        为保证线上请求特征和线下日志特征数据一致性，用户线上请求时用户特征和物品特征是从redis查询得到后写到日志文件吗？<br>        这时用户的实时特征比如过去几分钟点击的物品序列特征是从kafka读取还是从redis读取？ <br>        还是kafka发送用户的行为物品序列数据每隔几分钟写入redis，然后线上请求获取特征做预估打分和写特征数据到日志文件统一从redis读取？","like_count":1,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511166,"discussion_content":"不可能直接从kafka读取的，线上系统不可能接入任何流处理系统。需要以redis这类特征数据库作为所有数据的线上中转存储。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607389882,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":356116,"user_name":"雨尽书声响","can_delete":false,"product_type":"c1","uid":2767781,"ip_address":"北京","ucode":"3C0D9FB64961A2","user_header":"https://static001.geekbang.org/account/avatar/00/2a/3b/a5/689cc3fd.jpg","comment_is_top":false,"comment_ctime":1661996329,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661996329","product_id":100060801,"comment_content":"老师您好，文中说把物品特征放到服务器中，“我们完全可以把所有物品特征阶段性地载入到服务器内存中，大大减少 Redis 的线上压力。”，物品特征存入内存大约多少条会比较合适那","like_count":0},{"had_liked":false,"id":336085,"user_name":"Calmness","can_delete":false,"product_type":"c1","uid":2885368,"ip_address":"","ucode":"60CC8C3366C3D0","user_header":"https://static001.geekbang.org/account/avatar/00/2c/06/f8/9f6d64bd.jpg","comment_is_top":false,"comment_ctime":1645888141,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645888141","product_id":100060801,"comment_content":"老师，服务器内存不够的时候放在内存数据库，但是内存数据库不也全部都是建立在内存的基础上的吗？那如果服务器内存不够了放在内存数据库里不也不够吗？还有那个阶段性的物品特征该怎么理解呀？能举个例子吗","like_count":0},{"had_liked":false,"id":332602,"user_name":"dandy","can_delete":false,"product_type":"c1","uid":1583740,"ip_address":"","ucode":"5EE976FCBD9215","user_header":"https://static001.geekbang.org/account/avatar/00/18/2a/7c/0d6a87c4.jpg","comment_is_top":false,"comment_ctime":1643362331,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643362331","product_id":100060801,"comment_content":"老师你们这边是把item embedding存到内存，那用户存的是原始特征还是embedding后的存到redis呢，如果是原始特征是否需要特征抽取呢。一般现在业内是怎么处理的。 我们内部系统是item和user都是存的原始特征，后面做特征抽取，在embedding","like_count":1},{"had_liked":false,"id":310327,"user_name":"Geek_ddf8b1","can_delete":false,"product_type":"c1","uid":2309043,"ip_address":"","ucode":"70E1BB4C1CC6C4","user_header":"","comment_is_top":false,"comment_ctime":1630594920,"is_pvip":false,"replies":[{"id":"112489","content":"分级cache，区分活跃用户非活跃用户","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1630692562,"ip_address":"","comment_id":310327,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1630594920","product_id":100060801,"comment_content":"老师 请教一下 推荐项目中用户有几千万，几千万用户的特征（部分是用户实时行为特征）全部存在redis中，key太多会导致redis查询性能直线下降，请问这个问题如何解决？","like_count":0,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526197,"discussion_content":"分级cache，区分活跃用户非活跃用户","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630692562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":305329,"user_name":"Alvin","can_delete":false,"product_type":"c1","uid":2413045,"ip_address":"","ucode":"6F5E9AFAD16FB6","user_header":"https://static001.geekbang.org/account/avatar/00/24/d1/f5/efe2175a.jpg","comment_is_top":false,"comment_ctime":1627907634,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627907634","product_id":100060801,"comment_content":"have this problem:  file:&#47;home&#47;hadoop&#47;SparrowRecSys&#47;src&#47;main&#47;resources&#47;webroot&#47;sampledata&#47;ratings.csv<br>","like_count":0},{"had_liked":false,"id":305010,"user_name":"Betterme","can_delete":false,"product_type":"c1","uid":1237195,"ip_address":"","ucode":"1AAAD00D33F35F","user_header":"https://static001.geekbang.org/account/avatar/00/12/e0/cb/1ef6c142.jpg","comment_is_top":false,"comment_ctime":1627749594,"is_pvip":false,"replies":[{"id":"110430","content":"这个FIFO，LRU之类的逻辑都可以，首次加载最好有warming的过程","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1627921585,"ip_address":"","comment_id":305010,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1627749594","product_id":100060801,"comment_content":"物品向量一次性加载到内存里，那后续怎么更新这部分数据呢？写个调度热加载吗？","like_count":0,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524250,"discussion_content":"这个FIFO，LRU之类的逻辑都可以，首次加载最好有warming的过程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627921585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283672,"user_name":"Geek_379a55","can_delete":false,"product_type":"c1","uid":1564240,"ip_address":"","ucode":"4E4C3DB32736B9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIM0aLd8cjg3wzaLLK551L4HBx6zVIMuTINgOVUeibU6xHj0MRXQKsPIicKuZSlSibTibfE76u35Zralw/132","comment_is_top":false,"comment_ctime":1615879710,"is_pvip":false,"replies":[{"id":"103409","content":"这是一个工程问题，一般利用版本，redis的ttl等方式解决。其实你自己完全可以自己设计一下这个更新机制。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1616635987,"ip_address":"","comment_id":283672,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1615879710","product_id":100060801,"comment_content":"“这样一来，在具体为用户推荐的过程中，我们再利用相似的接口查询出用户的 Embedding，与内存中的 Embedding 进行相似度的计算，就可以得到最终的推荐列表了。“<br><br>王喆老师，用户的embedding是离线计算存储在redis，然后线上服务启动的时候加载在内存中，当离线计算的用户embedding更新时，线上服务内存中的用户embedding如何做到同步更新呢？<br>","like_count":0,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517109,"discussion_content":"这是一个工程问题，一般利用版本，redis的ttl等方式解决。其实你自己完全可以自己设计一下这个更新机制。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616635987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":277410,"user_name":"Sanders","can_delete":false,"product_type":"c1","uid":1697075,"ip_address":"","ucode":"3D460FEEDCDF34","user_header":"","comment_is_top":false,"comment_ctime":1612407253,"is_pvip":false,"replies":[{"id":"100819","content":"batch预测是必须要做的，几乎无法减少inference的消耗。只能从精简online inference模型的结构下手。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1612599790,"ip_address":"","comment_id":277410,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1612407253","product_id":100060801,"comment_content":"在SparrowRecsys中，在线计算用户Embedding和物品Embedding的工作放在离线计算更适合呢？在线只缓存用户推荐列表及物品得分，这样避免在线计算。<br>在实际情况中，推荐得分都是模型通过计算物品、用户和上下文特征来得到，每次请求包含用户ID，候选集id列表和上下文，假设用户特征在redis，N个物品特征在内存，这时batch预测就可能成为瓶颈，在这块有什么好的设计减少预测计算量？","like_count":0,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515041,"discussion_content":"batch预测是必须要做的，几乎无法减少inference的消耗。只能从精简online inference模型的结构下手。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612599790,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":272349,"user_name":"ALAN","can_delete":false,"product_type":"c1","uid":1240164,"ip_address":"","ucode":"70E3B1C730E63F","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/64/7403c694.jpg","comment_is_top":false,"comment_ctime":1610066359,"is_pvip":false,"replies":[{"id":"98753","content":"学了这节课不应该问出这个问题。建议再看一看，或者自己搜索一下。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1610086981,"ip_address":"","comment_id":272349,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1610066359","product_id":100060801,"comment_content":"老师，存储系统类型，内存数据库和服务器内存不是一回事吗？有什么区别？","like_count":0,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513249,"discussion_content":"学了这节课不应该问出这个问题。建议再看一看，或者自己搜索一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610086981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2414687,"avatar":"","nickname":"Geek_f30bcb","note":"","ucode":"69996919542668","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343021,"discussion_content":"根据缓存应用的耦合度，可以分为local cache(本地缓存)和remote cache(分布式缓存)：\n\n本地缓存：指的是在应用中的缓存组件，其最大的优点是应用和cache在同一个进程内部，请求缓存非常快速，没有过多的网络开销等，在单应用不需要集群支持或者集群情况下各节点无需互相通知的场景下使用本地缓存较为合适；同时，它的缺点也是因为缓存跟应用程序耦合，多个应用程序无法直接共享缓存，各应用或集群的各节点都需要维护自己的单独缓存，对内存是一种浪费。\n分布式缓存：指的是与应用分离的缓存组件或服务，其最大的优点是自身就是一个独立的应用，与本地应用隔离，多个应用可直接共享缓存。\n性能对比\n\n本地缓存有几种实现：编程直接实现缓存、Ehcache、Guava Cache\n分布式缓存有几种实现：memcached、redis","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1610920956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}