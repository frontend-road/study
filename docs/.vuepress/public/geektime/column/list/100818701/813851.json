{"id":813851,"title":"09｜基于Raft协议构建分布式集群（三）","content":"<blockquote>\n<p><span class=\"reference\">本课程为精品小课，不标配音频</span></p>\n</blockquote><p>你好，我是文强。这节课我们继续完善基于 Raft 协议开发的分布式集群。我们会讲解如何开发 Raft Node 上的 Raft 状态机，并最终构建包括<strong>发起选举</strong>、<strong>选举 Leader</strong>、<strong>心跳发送</strong><strong>、</strong><strong>心跳过期</strong>等等 Raft 协议定义的核心步骤的集群。</p><p>首先我们需要再回顾一下 Raft 协议的原理，以便接下来更好地理解 Raft 状态机的构建。建议你主要回顾前面推荐的<a href=\"https://thesecretlivesofdata.com/raft/\">《Raft 协议的动图原理展示》</a>。从功能上看，Raft 算法由下面六个核心流程组成：</p><ol>\n<li>\n<p>节点发现</p>\n</li>\n<li>\n<p>发起选举</p>\n</li>\n<li>\n<p>选举 Leader</p>\n</li>\n<li>\n<p>心跳检测</p>\n</li>\n<li>\n<p>心跳超时</p>\n</li>\n<li>\n<p>重新发起选举</p>\n</li>\n</ol><p>所以我们构建状态机也是围绕这六点展开的。最开始先来记住一个定义，就是：<strong>Raft 状态机本质上是一个 Tokio 的任务（也就是 Tokio Task）</strong>。接下来我们简单聊一下 Raft 状态机的运行原理。</p><h2>状态机运行原理</h2><p>先来看下面这张图：</p><p><img src=\"https://static001.geekbang.org/resource/image/93/fe/930210fc45f6d88e476be0ccc05ec8fe.jpeg?wh=1920x1080\" alt=\"\"></p><p>如上图所示，Raft Node 主要由 gRPC Server、Raft 状态机、Raft Storage 三部分组成。其中最关键的是 Raft 状态机，它驱动了 Raft Node 向前运行。从启动流程的角度看，服务启动后，会先启动 gRPC Server、初始化 RawNode，然后启动 Raft 状态机。Raft 状态机本质上是一个 Loop 线程，它会不间断地运行去驱动 RawNode 向前运行。</p><!-- [[[read_end]]] --><p>那什么叫做 RawNode 向前运行呢？</p><p>是指每个 RawNode 初始化后，需要根据自己的角色不断地做一些事情。比如，如果是 Leader 节点，那么就需要检测是否有新的用户数据写入，并将用户数据分发给多个 Follower，同时需要定时给 Follower 节点发送心跳信息。如果是 Follower 节点，则需要定时查看是否有心跳，如果有心跳则继续等待下一次心跳，如果心跳过期则发起新的选举。而这些操作都是由 Raft 状态机来驱动的。</p><p>不管是 Leader 还是 Follower 的信息，当 Raft 状态机生成消息后，都会通过 Tokio Channel 将消息从网络层发送给其他节点。从而完成发起选举、投票选举 Leader、心跳发送等行为。所以，从集群的角度来看，整体架构图如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/a1/22/a17c5a8fa9441a5a10340838ea90cf22.jpg?wh=2736x680\" alt=\"\"></p><p>基于上面集群的架构图，我们来讲一下上面的 Raft 算法中的六个核心流程。</p><ol>\n<li><strong>节点发现</strong>：如下代码所示，Raft Node 之间相互发现是在启动时通过 ConfState 中的voters变量来配置的。</li>\n</ol><pre><code class=\"language-plain\">// 初始化 Raft 的投票者列表\nlet mut cs = storage.read_lock().conf_state();\ncs.voters = cluster.node_ids();\n</code></pre><ol start=\"2\">\n<li>\n<p><strong>选举（发起选举和选举 Leader）</strong>：RaftNode 启动时，Raft 状态机会根据配置的voters节点信息，从其他节点获取当前是否有 Leader，有的话就将自己转变为 Follower 角色，然后根据 Follower 的角色视角去驱动 Raft 状态机的运行。如果当前集群没有 Leader，则 Raft 状态机会发起选举，也就是生成 MsgType 为 MsgRequestVote 的消息，将消息通过 Tokio Channel 发送给网络层，再通过网络层发送给其他 Raft Node。</p>\n</li>\n<li>\n<p><strong>心跳检测</strong>：Raft Leader 运行时，Raft 状态机会不间断生成 MsgType 为 MsgHeartbeat 的消息，并将消息发送给 Follower。当 Follower 收到 MsgType 为 MsgHeartbeat 的消息时，会给 Leader 返回 MsgType 为 MsgHeartbeatResponse 的消息。</p>\n</li>\n<li>\n<p><strong>心跳过期</strong> <strong>&amp;</strong> <strong>重新发起选举</strong>：当 Follower 状态机向前驱动时，如果检测到心跳过期，那么则生成 MsgType 为MsgRequestVote的消息，发起一次新的选举。</p>\n</li>\n</ol><p>接下来看一段单机 RaftNode 运行，并将自己选举为 Leader 的日志信息，这段日志展示了RaftNode 从运行到选举为 Leader 的过程（日志就不展开讲了，每一行还是比较容易看懂的）。</p><p><img src=\"https://static001.geekbang.org/resource/image/3a/d5/3a0883d48ccfaf0ac4042c8afdf343d5.png?wh=1920x497\" alt=\"图片\"></p><p>讲到这里你就会发现：<strong>Raft 集群的运行是依靠 Raft 状态机不断<strong><strong>地</strong></strong>向前驱动去<strong><strong>生</strong></strong>成不同类型的消息，从而完成不同的操作</strong>。</p><p>那接下来我们就来实现 Raft 状态机。开发 Raft 状态机的第一步是初始化 raft-rs 中的 RawNode 对象。</p><h2>初始化 RawNode</h2><p>在前面我们频繁提到 Raft Node 和 Raft 状态机这两个概念，现在又出现了 RawNode，我们先来看一下这三者的区别。</p><ul>\n<li>\n<p><strong>Raft Node</strong>：指 Raft 中的投票者节点，一般一个物理节点（或服务进程）就是一个 Raft Node。</p>\n</li>\n<li>\n<p><strong>RawNode</strong>：是 raft-rs 库的一个结构体，用于初始化一个投票者。</p>\n</li>\n<li>\n<p><strong>Raft 状态机</strong>：指服务进程中驱动 RawNode 状态运行的线程。一般情况下，一个 RawNode 对应一个 Raft 状态机，也就是一个线程。用于避免多个 RawNode 运行在同一个线程中相互影响。</p>\n</li>\n</ul><p>了解完这几个概念，接下来就初始化 RawNode 对象。从实现上主要包含两步：</p><ol>\n<li>\n<p><strong>构建配置</strong></p>\n</li>\n<li>\n<p><strong>创建 RawNode 对象</strong></p>\n</li>\n</ol><p>先来看构建配置，代码如下：</p><pre><code class=\"language-plain\">    fn build_config(&amp;self, apply_index: u64) -&gt; Config {\n        let conf = placement_center_conf();\n        Config {\n            id: conf.node_id,\n            election_tick: 10,\n            heartbeat_tick: 3,\n            max_size_per_msg: 1024 * 1024 * 1024,\n            max_inflight_msgs: 256,\n            applied: apply_index,\n            ..Default::default()\n        }\n    }\n</code></pre><p>构建配置代码实现很简单，你需要重点关注 id 和 applied 这两个配置项。</p><ul>\n<li>\n<p><strong>id</strong>：指 RawNode 的唯一标识，用来区分不同的投票者。多个 RawNode 之间的 id 不能重复。</p>\n</li>\n<li>\n<p><strong>applied</strong>：表示当前 Raft Node 上持久化存储的最新的 commit index。因为进程会重启，所以当进程重启时，就需要从本地持久化的存储中，恢复当前 RawNode 的 commit index。（在这一步，你就看到前面持久化存储层的作用了）</p>\n</li>\n</ul><p>接下来看一下如何创建 RawNode。</p><pre><code class=\"language-plain\">pub async fn new_node(&amp;self) -&gt; RawNode&lt;RaftMachineStorage&gt; {\n        let cluster = self.placement_cluster.read().unwrap();\n        // 创建RawNode 的存储层，也就是 Raw 的Stroage Trait 的实现。\n        // 这里用了我们实现上一章实现的存储层 RaftMachineStorage\n        let storage = RaftMachineStorage::new(self.raft_storage.clone());\n\n\n        // 构建 RawNode 的配置\n        let hs = storage.read_lock().hard_state();\n        let conf = self.build_config(hs.commit);\n\n\n        // 初始化 Raft 的投票者列表\n        let mut cs = storage.read_lock().conf_state();\n        cs.voters = cluster.node_ids();\n        let _ = storage.write_lock().save_conf_state(cs);\n        \n        // raft-rs 库有自己的日志实现，也就是会打印 raft 运行日志到一个独立的文件\n        let logger = self.build_slog();\n\n\n        // 初始化一个 RawNode 实例\n        let node = RawNode::new(&amp;conf, storage, &amp;logger).unwrap();\n        return node;\n}\n</code></pre><p>上面这段代码的核心逻辑是，初始化存储层实现、初始化配置、初始化投票者列表、初始化日志、创建RawNode 实例。整体流程比较简单直观。需要注意的是，上面的代码中有这样一行：</p><pre><code class=\"language-plain\">cs.voters = cluster.node_ids()\n</code></pre><p>如果你对 Raft 协议理解得较多的话，就知道 <strong>Raft Node 之间需要知道对方的存在，才能进行投票选举，并将得票超过半数的 Raft Node 选举为 Leader</strong>。这行代码就是初始化配置当前总共有几个 Raft Node，让Node之间能够相互发现，从而选举出 Leader。</p><p>node_ids 方法的代码如下所示，返回的是所有投票者的节点 id 列表。</p><pre><code class=\"language-plain\">pub fn node_ids(&amp;self) -&gt; Vec&lt;u64&gt; {\n   let mut voters = Vec::new();\n   for (id, _) in self.peers.iter() {\n       voters.push(*id);\n   }\n   return voters;\n}\n</code></pre><p>当然如果只有一个 RawNode，那么它会被自动选举为 Leader，运行日志如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/81/b1/81e4a4ceb7c970e9b2ae5cc0e24775b1.png?wh=1920x502\" alt=\"图片\"></p><p>初始化后 RawNode后，接下来我们来看状态机的具体逻辑实现。</p><p>从实现来看，状态机的代码由<strong>驱动代码</strong>和<strong>逻辑代码</strong>两部分组成。由于篇幅原因，我们这里只讲代码的主要实现逻辑，完整代码请看 Demo 示例中的<a href=\"https://github.com/robustmq/robustmq-geek/blob/main/src/placement-center/src/raft/machine.rs\">《machine.rs》</a>。接下来先来看状态机驱动代码。</p><h2>状态机驱动代码</h2><p>状态机驱动代码是指驱动 Raft 状态机向前运行的主流程代码。先来看代码：</p><pre><code class=\"language-plain\">pub async fn run(&amp;mut self) {\n        // 初始化 RawNode 实例\n        let mut raft_node: RawNode&lt;RaftRocksDBStorage&gt; = self.new_node().await;\n        // 定义每隔 100ms 向前驱动一次状态机\n        let heartbeat = Duration::from_millis(100);\n        let mut now = Instant::now();\n        // 使用 loop 循环一直向后驱动 Raft 状态机\n        loop {\n            // 接收进程停止的信号，优雅退出进程\n            match self.stop_recv.try_recv() {\n                Ok(val) =&gt; {\n                    if val {\n                        info!(\"{}\", \"Raft Node Process services stop.\");\n                        break;\n                    }\n                }\n                Err(_) =&gt; {}\n            }\n            // 通过 timeout 配合 receiver 实现每 100ms 向前驱动状态机\n            match timeout(heartbeat, self.receiver.recv()).await {\n                // 接收其它Raft Node 上的 Raft 状态机生成的Message，进行处理\n                // 比如发起投票、心跳、心跳返回等等\n                Ok(Some(RaftMessage::Raft { message, chan })) =&gt; {\n                    match raft_node.step(message) {\n                        Ok(_) =&gt; match chan.send(RaftResponseMesage::Success) {\n                            Ok(_) =&gt; {}\n                            Err(_) =&gt; {\n                                error!(\"{}\",\"commit entry Fails to return data to chan. chan may have been closed\");\n                            }\n                        },\n                        Err(e) =&gt; {\n                            error!(\"{}\", e);\n                        }\n                    }\n                }\n                // 接收写入到 Raft 状态机的用户消息，并进行处理\n                Ok(Some(RaftMessage::Propose { data, chan })) =&gt; {\n                    let seq = self\n                        .seqnum\n                        .fetch_add(1, std::sync::atomic::Ordering::Relaxed);\n                    match raft_node.propose(serialize(&amp;seq).unwrap(), data) {\n                        Ok(_) =&gt; {\n                            self.resp_channel.insert(seq, chan);\n                        }\n                        Err(e) =&gt; {\n                            error!(\"{}\", e);\n                        }\n                    }\n                }\n                Ok(None) =&gt; continue,\n                Err(_) =&gt; {}\n            }\n\n\n            let elapsed = now.elapsed();\n            // 每隔一段时间（称为一个 tick），调用 RawNode::tick 方法使 Raft 的逻辑时钟前进一步。\n            if elapsed &gt;= heartbeat {\n                raft_node.tick();\n                now = Instant::now();\n            }\n            \n            // 在每个驱动周期(收到业务消息或者每 100ms)，尝试去处理 Raft Message\n            self.on_ready(&amp;mut raft_node).await;\n        }\n}\n</code></pre><p>上面这段代码主要逻辑已经写在注释里面了。我们总结一下核心流程。</p><ol>\n<li>\n<p>通过 loop + timeout + self.receiver.recv 来驱动 Raft 状态机向前运行。即如果收到需要 Raft 状态机处理的消息，就向前驱动一步，处理这部分消息。如果没有需要 Raft 状态机处理的消息，则每 100ms 向前驱动一步。</p>\n</li>\n<li>\n<p>Raft 状态机会接收<strong>其他 Raft Node 运行状态消息</strong>和<strong>用户消息</strong>进行处理，这两个消息是网络层 gRPC Server 通过 Tokio Channel 传递过来的。当状态机接收到消息数据后，即刻进行处理。</p>\n</li>\n<li>\n<p>通过 self.stop_recv.try_recv() 来优雅停止状态机。</p>\n</li>\n<li>\n<p>每 100ms 将 Raft 状态机的逻辑时钟向前驱动一步。</p>\n</li>\n<li>\n<p>Raft 每驱动一次，则会调用 self.on_ready 尝试处理本次驱动是否有需要处理的消息。</p>\n</li>\n</ol><p>可以看到，上面的 run 方法是一个 loop 的循环，为了不阻塞主线程，需要将它放在一个独立的子任务中运行。从代码实现上来看，如下所示直接通过 tokio::spawn 启动一个 tokio task 运行即可。</p><pre><code class=\"language-plain\">let mut raft: RaftMachine = RaftMachine::new(\n  self.placement_cache.clone(),\n  data_route,\n  peer_message_send,\n  raft_message_recv,\n  stop_recv,\n  self.raft_machine_storage.clone(),\n);\n\n\ntokio::spawn(async move {\n    raft.run().await;\n});\n</code></pre><p>讲到这里，其实 Raft 状态机主体框架已经开发完成了。我们根据前面状态机运行原理的两张图来总结一下整体的运行流程：<strong>进程启动，启动 gRPC Server，启动状态机，状态机会自己运行，找到 Leader 或发起 Leaer 选举。根据自身的角色生成不同的消息，通过Tokio Channel 发送给网络层，并通过网络层发送给其他节点，从而和其他 Raft 节点互动，进而完成集群的组建</strong>。</p><p>你应该会注意到，run 方法中我们通过一个 on_ready 方法来处理每一批次的 Raft 消息，也就是说在 on_ready 方法里面会完成每一批次 Raft 消息的逻辑处理。所以可以将它称为状态机逻辑代码。接下来来看一下它的实现。</p><h2>状态机逻辑代码</h2><p>直接来看代码：</p><pre><code class=\"language-plain\">async fn on_ready(&amp;mut self, raft_node: &amp;mut RawNode&lt;RaftRocksDBStorage&gt;) {\n        // 检查 raft 状态机是否已经准备好\n        // 是的话，向下运行\n        // 否的话，表示这批次没有需要处理的消息\n        if !raft_node.has_ready() {\n            return;\n        }\n        \n        // 获取到这一批次需要处理的数据\n        let mut ready = raft_node.ready();\n        \n        // 判断消息是否为空\n        // 如果不为空，表示 有Raft Message需要发给其他Raft Node，\n        // 则需要把 Raft 消息通过我们构建的网络层发送给其他的 Raft Node\n        if !ready.messages().is_empty() {\n            // mark 1\n            self.send_message(ready.take_messages()).await;\n        }\n        \n        // 判断这次向前驱动，是否有快照数据需要恢复\n        // 如果有快照数据，则需要恢复快照数据，即将快照数据持久化存储到存储层\n        if *ready.snapshot() != Snapshot::default() {\n            // mark 2\n            let s = ready.snapshot().clone();\n            info!(\n                \"save snapshot,term:{},index:{}\",\n                s.get_metadata().get_term(),\n                s.get_metadata().get_index()\n            );\n            raft_node.mut_store().apply_snapshot(s).unwrap();\n        }\n        \n        // 持久化存储 Raft 日志\n        // 即判断是否有 Entry 需要保存\n        // 如果有 Entry 需要保存，则需要将 Entry 持久化保存\n        if !ready.entries().is_empty() {\n            // // mark 3\n            let entries = ready.entries();\n            raft_node.mut_store().append(entries).unwrap();\n        }\n\n\n        // 处理已经能够被 Apply 的消息\n        // 因为 Raft 存储是两阶段的，Leader 接收到数据后，需要被多个节点都处理成功后才能算处理成功\n        // 所以 这一步是 apply 已经被多个节点处理成功的数据\n        // mark 4\n        self.handle_committed_entries(raft_node, ready.take_committed_entries());\n\n\n        // 如果有 HardState 数据更新，则更新本地持久化存储的 HardState 数据\n        if let Some(hs) = ready.hs() {\n            // mark 5\n            debug!(\"save hardState!!!,len:{:?}\", hs);\n            raft_node.mut_store().set_hard_state(hs.clone()).unwrap();\n        }\n        \n        // 判断是否有persisted messages 消息\n        // 有的话就发送给其他 Raft 节点\n        if !ready.persisted_messages().is_empty() {\n            // mark 6\n            self.send_message(ready.take_persisted_messages()).await;\n        }\n    \n        // 在确保一个 Ready 中的所有进度被正确处理完成之后，调用&nbsp;RawNode::advance&nbsp;接口。\n        let mut light_rd = raft_node.advance(ready);\n    \n        // 更新 HardState 中的 commit inde 信息\n        if let Some(commit) = light_rd.commit_index() {\n            // mark 7\n            raft_node.mut_store().set_hard_state_comit(commit).unwrap();\n        }\n        // mark 8 同上\n        self.send_message(light_rd.take_messages()).await;\n        // mark 9 同上\n        self.handle_committed_entries(raft_node, light_rd.take_committed_entries());\n        raft_node.advance_apply();\n  }\n</code></pre><p>上面代码的主要逻辑已经加在注释中了，就不再重复。我们还是来总结下核心逻辑。</p><ol>\n<li>\n<p>on_ready 代码把我们之前实现的网络层和存储层的逻辑都集成进来了。也就是代码中标记了 mark 1～9 位置的代码。比如当状态机生成需要发送给其他节点的消息，就调用send_message 方法将消息发给其他节点。如果需要持久化存储消息，就调用RaftMachineStorage 中对应的方法完成存储。</p>\n</li>\n<li>\n<p>你可以认为 on_ready 代码逻辑步骤是固定的，假设你要实现自己的 Raft 状态机，那么直接把这段代码复制下来，把代码中标记了 mark 1～9 位置的代码变为自己的实现即可。</p>\n</li>\n<li>\n<p>总结一下标记了 mark 的代码块的作用：</p>\n<ol>\n<li>\n<p>mark 1/6/8：如果有需要发送给其他 Raft Node 的消息，则通过 send_message 方法，调用 gRPC 模块，将消息发送给其他节点。</p>\n</li>\n<li>\n<p>mark 2：恢复快照，将快照中的数据持久化到本地的 RocksDB 中。</p>\n</li>\n<li>\n<p>mark 3：持久化存储 Raft 日志，将数据持久化存储到 RocksDB 中。</p>\n</li>\n<li>\n<p>mark 4/9：处理业务数据，这一点我们在下节课会细讲。</p>\n</li>\n<li>\n<p>mark 5：持久化保存 HardState 数据到 RocksDB 中。</p>\n</li>\n<li>\n<p>mark 7：持久化保存最新的 commit index 到 RocksDB 中。</p>\n</li>\n</ol>\n</li>\n</ol><p>当完成上面的工作后，Raft 状态机也全部完成了。 同时基于 Raft 协议的分布式集群也构建完成了。讲到这里，虽然我们已经完成了每个部分的开发，但是你是不是对整个集群的运行流程还是点模糊，没有一个整体的概念？</p><p>是的，这很正常，所以接下来我们从宏观的角度来总结一下我们基于 Raft 协议构建的集群的运行逻辑和代码关系。</p><h2>集群运行宏观总结</h2><p>回顾一下，我们总共完成了三个事情：</p><ol>\n<li>\n<p>基于 RocksDB 的 Raft Log 存储层的开发。</p>\n</li>\n<li>\n<p>基于 gRPC 的 Raft Node 网络层的开发。</p>\n</li>\n<li>\n<p>基于 Tokio 的 Raft 状态机的开发。</p>\n</li>\n</ol><p>这三个工作都是指单个Raft Node 维度的实现。而从集群的角度看，就是多个Raft Node 就可以组成集群。因此只要我们启动多个 Raft Node，它就会自动组建成集群。那它是怎么组建集群的呢？ 来看下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/63/7c/6392b987c8d0c89eb66fa20cb14bdc7c.jpeg?wh=1900x808\" alt=\"图片\"></p><p>组建集群的代码运行逻辑如下：</p><ol>\n<li>\n<p>单个 Raft Node 启动，会尝试从本地 RocksDB 的数据目录恢复数据，如果 RocksDB 目录不存在，则会创建一个新的数据目录，否则就恢复Raft Node 的状态数据。主要是通过 Storate Trait 的 initial_state 方法读取 HardState 和 ConfState 数据。</p>\n</li>\n<li>\n<p>同时 Raft Node 会启动网络层 gRPC Server 和 Raft 状态机。</p>\n</li>\n<li>\n<p>Raft 状态机启动后，会判断是否有 Leader，有的话就获取 Leader 信息，没有的话重新发起选举。这些动作是由 raft-rs 库的 RawNode 实现的。</p>\n</li>\n<li>\n<p>不管是获取 Leader 还是发起选举，都是由 RawNode 发起的。由 RawNode 生成消息，然后通过网络层跟其他 Raft Node 交互。</p>\n</li>\n<li>\n<p>选举出 Leader 后，Leader 会向 Follower 发送心跳信息，如果 Follower 没及时收到心跳，则会重新发起选举。</p>\n</li>\n</ol><p>每个节点启动都会执行上面这些逻辑。比如单节点启动，就会将自己选为 Leader，如果有新节点启动，则会获取当前集群的 Leader 或者发起选举。以此类推，多个 Raft Node 就会组建成集群了。</p><p>在集群构建完成后，你可能有个疑问：<strong>如果你写一条数据，这个数据最终是如何完成分布式存储的</strong>？这个问题我们留到下节课，我们会基于当前构建的 Raft 集群来完成数据的分布式多副本可靠存储。</p><h2>总结</h2><blockquote>\n<p>tips：每节课的代码都能在项目 <a href=\"https://github.com/robustmq/robustmq-geek\">https://github.com/robustmq/robustmq-geek</a> 中找到源码，有兴趣的同学可以下载源码来看。</p>\n</blockquote><p>到了这节课，基于 Raft 协议构建分布式集群就完成了。可以看到，基于 raft-rs 库来构建集群，整个流程还是很繁杂的，要自己实现很多细节。</p><p>在这里我想说明的是，不论我们基于哪个库来实现集群，甚至自己实现一个一致性协议来构建集群，它的底层原理都是一样的，是通用的。因此在我看来，从学习的角度，选择哪个库来实现的区别不大，重要的是你能深刻理解一致性协议的细节。</p><p>客观来讲，至今为止我们也只是实现了最简单的集群。里面还有很多细节需要优化，比如异步快照构建、高性能的快照同步和恢复、Raft 日志存 RocksDB 写放大问题、Raft 节点之间高性能的消息同步等等。所以欢迎你参与我的项目<a href=\"https://github.com/robustmq/robustmq\">https://github.com/robustmq/robustmq</a>，来了解更多的细节。</p><p>在实际的实现中，也会建议你可以考虑基于 openraft 库来实现自己的集群，因为 openraft 库是一个完整的实现，对于使用者来说开发理解成本会更低一些。选型的考虑过程在<a href=\"https://time.geekbang.org/column/article/810640\">第 7 课</a>讲完了，你可以根据自己的实际需要来选择合适的类库。</p><p>不过基于 raft-rs 库实现构建集群有一个好处是，<strong>会让你对 Raft</strong> <strong>的原理及实现有更深的理解</strong>。当你把这三节课的内容理解透，想必你对 Raft 协议的理解会深入很多，后续不管使用哪个 Raft 库，应该都更得心应手。</p><h2>思考题</h2><p>这里是本节课推荐的相关 issue 的任务列表，请点击查看<a href=\"http://www.robustmq.com/docs/robustmq-tutorial-cn/%e8%b4%a1%e7%8c%ae%e6%8c%87%e5%8d%97/good-first-issue/\">《Good First Issue》</a>。另外欢迎给我的项目 <a href=\"https://github.com/robustmq/robustmq\">https://github.com/robustmq/robustmq</a> 点个 Star 啊！</p>","neighbors":{"left":{"article_title":"08｜基于Raft协议构建分布式集群（二）","id":813382},"right":{"article_title":"10｜分布式：实现集群化、多副本KV存储引擎","id":813869}},"comments":[]}