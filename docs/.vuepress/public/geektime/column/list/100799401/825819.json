{"id":825819,"title":"39｜数据误操作了如何快速恢复？","content":"<p>你好，我是俊达。</p><p>上一讲中，我们知道了如何使用Xtrabackup来备份数据库和恢复数据库。不管是全量备份，还是增量备份，实际上都只能将数据库恢复到一个固定的时间点，这个时间点就是Xtrabackup备份完成的那个时刻。</p><p>但是在现实中，数据恢复的要求往往会更高。假设我们每天凌晨都会备份数据库。某一天下午，由于误操作，某一个重要的业务表的数据被清空了。使用凌晨的备份文件，只能恢复一部分数据。从凌晨到误操作发生的那一刻，这个表上进行了很多DML操作，这部分数据如何恢复呢？</p><p>这一讲我们就来解决这个问题。根据误操作的不同情况，我们可以选择不同方法来恢复数据。</p><h2>Binlog备份</h2><p>为了将数据库恢复到任意一个时间点，我们需要将Binlog也备份起来。如果Binlog没有备份，同时你又把Binlog删除了，那么就可能无法将数据恢复到这些Binlog覆盖的时间点。</p><p>备份Binlog实际上比较简单，一个Binlog，一旦完成切换，里面的内容就不会发生变化。你可以使用操作系统的命令，比如cp，将除了最后一个binlog之外其他Binlog，拷贝到备份空间。使用这种方式，无法实时备份最新的那个Binlog文件。极端情况下，如果这个时候数据库所在的服务器崩溃了，而且无法启动，那么你可能会丢失最后一个Binlog中的数据。</p><!-- [[[read_end]]] --><p>命令行工具mysqlbinlog提供了一个功能，可以实时接收远程数据库上生成的Binlog事件。</p><pre><code class=\"language-plain\">mysqlbinlog \\\n\t--read-from-remote-server \\\n  --host=172.16.121.234 \\\n  --port=3307 \\\n\t--user=backup \\\n\t--password=somepass \\\n\t--protocol=tcp \\\n\t--stop-never \\\n\t--raw \\\n\t--result-file=/path/to/binlog-backup/ \\\n  mysql-binlog.00000N\n</code></pre><p>mysqlbinlog的命令行参数中，加上read-from-remote-server后，可以模拟IO线程，连接到数据库，执行BINLOG_DUMP命令，接收Binlog。加上参数stop-never，读取完当前所有的Binlog后，也不会退出，而是继续等待主库生成新的Binlog事件。</p><p>使用mysqlbinlog备份远程的Binlog时，一般要加上raw参数。你可以将参数result-file设置为一个目录，这样Binlog会写到这个目录中，如果不加这个参数，默认会将Binlog文件保存到当前目录下。</p><p>最后一个参数（mysql-binlog.00000N）是开始读取的第一个Binlog的文件名。如果发生一些异常，如网络超时，或Dump线程被Kill了，mysqlbinlog命令会异常退出。如果mysqlbinlog命令异常退出了，你可以先看一下最后备份的那个Binlog文件，然后再重新从这个文件开始，备份Binlog。</p><h2>恢复到指定时间点</h2><p>只要有全量备份，以及全量备份后的所有binlog，就能将数据库恢复到全量备份之后的任意时间点。</p><p><img src=\"https://static001.geekbang.org/resource/image/73/06/73c96d3eb534f94e719947eb6b06a506.jpg?wh=1234x381\" alt=\"图片\"></p><p>看上面这个图，如果在T2时间点发生了数据丢失故障，就可以找一个在T2时间之前完成的全量备份。假设在时间点T0有一个全量备份，T1有一个增量备份，就可以先恢复全量备份和增量备份，然后再应用T1到T2之间的Binlog。如果没有增量备份，也可以恢复全量备份后，应用T0到T2之间的Binlog。这样都能将数据恢复到发生故障前的那个时间点。</p><h3>找到时间点对应的binlog</h3><p>时间点恢复具体怎么操作呢？首先要定位该时间点对应的binlog位点（binlog文件和文件内的偏移量）。每个binlog头部都记录了binlog产生的时间，我们可以使用mysqlbinlog工具解析binlog，查看binlog的第一个event的时间。</p><pre><code class=\"language-plain\"># mysqlbinlog -v binlog.000021 | head\n/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;\n/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;\nDELIMITER /*!*/;\n# at 4\n#230625 16:44:06 server id 23480  end_log_pos 126 CRC32 0x245d7ed7 \tStart: binlog v 4, server v 8.0.32 created 230625 16:44:06\n</code></pre><p>如果我们需要恢复到某个时间点T，那么我们需要找的binlog开始时间不大于T，并且该binlog的下一个binlog的开始时间大于T。</p><p>这里提供一个python的脚本，可以批量查看binlog时间。</p><pre><code class=\"language-plain\">import sys\nimport struct\n\nif len(sys.argv) &gt;= 2:\n   pattern = sys.argv[1]\nelse:\n   pattern = 'mysql-bin.[0-9]*'\n\nprint ('binlog pattern: %s' % pattern)\n\ndef parse_binlog_header(filename):\n    with open(filename, 'rb') as f:\n        data = f.read(8)\n        return struct.unpack('i', data[4:])[0]\n\ndef main():\n\n    import glob\n    from datetime import datetime\n    for f in sorted(glob.glob(pattern), key=lambda x: int(x.split('.')[-1])):\n        ts = parse_binlog_header(f)\n        print f, ts, datetime.fromtimestamp(ts)\n\nif __name__ == '__main__':\n    main()\n</code></pre><p>使用脚本，传入binlog匹配模式，显示binlog时间：</p><pre><code class=\"language-plain\"># python parse_binlog_time.py  'binlog/binlog.[0-9]*'\nbinlog pattern: binlog/binlog.[0-9]*\nbinlog/binlog.000001 1686640790 2023-06-13 15:19:50\nbinlog/binlog.000002 1686647377 2023-06-13 17:09:37\nbinlog/binlog.000003 1686647391 2023-06-13 17:09:51\n......\nbinlog/binlog.000020 1687682137 2023-06-25 16:35:37\nbinlog/binlog.000021 1687682646 2023-06-25 16:44:06\nbinlog/binlog.000022 1687683127 2023-06-25 16:52:07\n</code></pre><p>我们的全量备份binlog位点是binlog.000020。</p><pre><code class=\"language-plain\"># cat xtrabackup_binlog_info\nbinlog.000020\t610\t58224b02-09b7-11ee-90bd-fab81f64ee00:1-13191,7caa9a48-b325-11ed-8541-fab81f64ee00:1-27\n</code></pre><p>假设我们希望将数据库恢复到2023-06-25 16:45:00，那么根据各个binlog的时间信息，我们需要恢复到binlog.000021，从这个binlog中找到16:45:00对应的位点。</p><pre><code class=\"language-plain\"># mysqlbinlog --stop-datetime=\"2023-06-25 16:45:01\" binlog/binlog.000021 | grep -A 1 \"^# at\" | tail -2\n\n# at 340009\n#230625 16:45:00 server id 23480  end_log_pos 340040 CRC32 0xa1841663 \tXid = 88279\n</code></pre><p>我们需要应用binlog.000021偏移量340040之前的binlog。</p><p>接下来要解决怎么应用Binlog的问题。MySQL提供了命令行工具mysqlbinlog，可以解析Binlog，解析出来后，可以直接发送给MySQL执行。这可能也是平时比较常用的一个方法。更好的方法，是利用MySQL的复制模块来应用Binlog。我们来看一下这两种方法分别是怎么操作的。</p><h3>方法一：使用mysqlbinlog解析binlog并执行</h3><p>从前面的步骤，我们得到了需要执行的binlog。</p><ul>\n<li>\n<p>binlog开始位点：binlog.000020，偏移量610。</p>\n</li>\n<li>\n<p>binlog结束位点：binlog.000021，偏移量340040。</p>\n</li>\n</ul><p>依次使用mysqlbinlog解析binlog，并发送给mysql执行。执行第一个binlog时指定参数start-position，执行最后一个binlog时，指定参数stop-position。</p><p>使用下面的命令执行第一个binlog。</p><pre><code class=\"language-plain\">mysqlbinlog --start-position=610 binlog.000020 | mysql -uroot -h127.0.0.1 -P6380 -uroot -pabc123\n</code></pre><p>执行中间的binlog，如果binlog数量比较多，你可能需要写一个脚本来处理。当然，这个测试案例中只有2个binlog。</p><p>使用下面的命令执行最后一个binlog。</p><pre><code class=\"language-plain\">mysqlbinlog --stop-position=340040 binlog.000021 | mysql -uroot -h127.0.0.1 -P6380 -uroot -pabc123\n</code></pre><p>binlog执行完成后，校验一下数据。这里我们查看最后一个应用的binlog事件。</p><pre><code class=\"language-plain\"> mysqlbinlog -v --stop-position=340040 binlog.000021 | tail -30\n# at 339746\n#230625 16:45:00 server id 23480  end_log_pos 339817 CRC32 0x89660c48 \tQuery\tthread_id=29218\texec_time=0\terror_code=0\nSET TIMESTAMP=1687682700/*!*/;\nBEGIN\n/*!*/;\n# at 339817\n#230625 16:45:00 server id 23480  end_log_pos 339880 CRC32 0xd5fb3c23 \tTable_map: `demo`.`last_gtid` mapped to number 209\n# has_generated_invisible_primary_key=0\n# at 339880\n#230625 16:45:00 server id 23480  end_log_pos 340009 CRC32 0x8153feb1 \tWrite_rows: table id 209 flags: STMT_END_F\n\nBINLOG '\njP6XZBO4WwAAPwAAAKgvBQAAANEAAAAAAAEABGRlbW8ACWxhc3RfZ3RpZAACAw8CoA8CAQEAAgP8\n/wAjPPvV\njP6XZB64WwAAgQAAACkwBQAAANEAAAAAAAEAAgAC/wBsaAAAVwA1ODIyNGIwMi0wOWI3LTExZWUt\nOTBiZC1mYWI4MWY2NGVlMDA6MS0yOTExMCwKN2NhYTlhNDgtYjMyNS0xMWVkLTg1NDEtZmFiODFm\nNjRlZTAwOjEtMjex/lOB\n'/*!*/;\n### INSERT INTO `demo`.`last_gtid`\n### SET\n###   @1=26732\n###   @2='58224b02-09b7-11ee-90bd-fab81f64ee00:1-29110,\\n7caa9a48-b325-11ed-8541-fab81f64ee00:1-27'\n</code></pre><p>查看数据，验证数据是否恢复到了正确的时间点。</p><pre><code class=\"language-plain\">mysql&gt; select * from demo.last_gtid order by id desc limit 1;\n+-------+-----------------------------------------------------------------------------------------+\n| id    | gtid                                                                                    |\n+-------+-----------------------------------------------------------------------------------------+\n| 26732 | 58224b02-09b7-11ee-90bd-fab81f64ee00:1-29110,\n7caa9a48-b325-11ed-8541-fab81f64ee00:1-27 |\n+-------+-----------------------------------------------------------------------------------------+\n1 row in set (0.00 sec)\n</code></pre><h3>方法二：使用MySQL原生复制功能实现时间点恢复</h3><p>虽然使用mysqlbinlog解析并执行binlog，是实现mysql时间点恢复的一种常用的方法，但是这么做其实有一些缺点。</p><ul>\n<li>\n<p>先解析Binlog，再发送给MySQL执行，性能不够好，事务只能单线程应用。</p>\n</li>\n<li>\n<p>如果中间某个Binlog执行时出错了，脚本中还要做好错误处理。</p>\n</li>\n</ul><p>在正式环境中，我更建议使用下面这种方法，利用MySQL的数据复制功能来实现时间点恢复。</p><p>操作方法其实很简单。</p><ol>\n<li>\n<p>启动一个空的mysql实例，将需要恢复的binlog注册到这个实例中。</p>\n</li>\n<li>\n<p>将需要恢复数据的那个实例，作为备库，从步骤1创建的binlog实例中复制数据。</p>\n</li>\n</ol><h4>启动binlog实例</h4><p>先初始化一个空白实例。</p><pre><code class=\"language-plain\">## 创建相关目录\nmkdir -p /data/servebinlog/{data,log,binlog,relaylog,tmp,run}\n\n## 准备my.cnf\n\n## 初始化数据库\n/opt/mysql/bin/mysqld --defaults-file=/data/servebinlog/my.cnf --initialize\n\n\ntail -1 /data/servebinlog/log/alert.log\n2023-06-26T08:54:33.758630Z 6 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: ar2sWPCf4.++\n\n## 修改文件owner，并启动实例\nchown -R mysql:mysql /data/servebinlog/\n\nmysqld_safe --defaults-file=/data/servebinlog/my.cnf &amp;\n\n## 修改默认密码，创建复制账号\nmysql -uroot -par2sWPCf4.++ -h127.0.0.1 -P16380\n\nmysql&gt; alter user 'root'@'localhost' identified by 'abc123';\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; create user 'rep'@'%' identified by 'rep123';\nQuery OK, 0 rows affected (0.02 sec)\n\nmysql&gt; grant replication slave on *.* to 'rep'@'%';\nQuery OK, 0 rows affected (0.01 sec)\n</code></pre><p>注册binlog。将需要的binlog复制到binlog实例的目录中，并编辑binlog.index文件，重启binlog实例。</p><pre><code class=\"language-plain\">## 停实例\nmysqladmin -h127.0.0.1 -P16380 -uroot -pabc123 shutdown\n\n## 清空原有binlog，将需要的binlog复制到指定目录\nrm /data/servebinlog/binlog/binlog.00000*\ncp /data/mysql8.0/binlog/binlog.0000{20,21,22} /data/servebinlog/binlog/\n\n\n## 编辑binlog.index，最终内容如下\n# cat /data/servebinlog/binlog/binlog.index\n/data/servebinlog/binlog/binlog.000020\n/data/servebinlog/binlog/binlog.000021\n/data/servebinlog/binlog/binlog.000022\n\n## 启动实例\nchown -R mysql:mysql /data/servebinlog/\nmysqld_safe --defaults-file=/data/servebinlog/my.cnf &amp;\n</code></pre><p>到这一步，binlog实例就准备完成了。</p><pre><code class=\"language-plain\">\nmysql&gt; show binary logs;\n+---------------+-----------+-----------+\n| Log_name      | File_size | Encrypted |\n+---------------+-----------+-----------+\n| binlog.000020 |   5598638 | No        |\n| binlog.000021 |   4751928 | No        |\n| binlog.000022 |   3944712 | No        |\n| binlog.000023 |       237 | No        |\n+---------------+-----------+-----------+\n\n\nmysql&gt; select @@gtid_purged\\G\n*************************** 1. row ***************************\n@@gtid_purged: 0b06b27c-13ff-11ee-8d21-fab81f64ee00:1-3,\n58224b02-09b7-11ee-90bd-fab81f64ee00:1-13191,\n7caa9a48-b325-11ed-8541-fab81f64ee00:27\n1 row in set (0.00 sec)\n\nmysql&gt; select @@gtid_executed\\G\n*************************** 1. row ***************************\n@@gtid_executed: 0b06b27c-13ff-11ee-8d21-fab81f64ee00:1-3,\n58224b02-09b7-11ee-90bd-fab81f64ee00:1-51514,\n7caa9a48-b325-11ed-8541-fab81f64ee00:27\n1 row in set (0.00 sec)\n</code></pre><h4>从binlog实例复制数据</h4><p>先查看全备的binlog位点。</p><pre><code class=\"language-plain\"># cat xtrabackup_binlog_info\nbinlog.000020\t610\t58224b02-09b7-11ee-90bd-fab81f64ee00:1-13191,7caa9a48-b325-11ed-8541-fab81f64ee00:1-27\n</code></pre><p>到需要进行时间点恢复的实例上执行下面这些命令，建立数据复制通道，使用start slave until命令将数据恢复到指定的Binlog位点。</p><pre><code class=\"language-plain\">mysql&gt; reset slave all;\nQuery OK, 0 rows affected, 1 warning (0.03 sec)\n\nmysql&gt; change master to master_host='172.16.121.234', master_port=16380, master_user='rep', master_password='rep123', get_master_public_key=1, master_log_file='binlog.000020', master_log_pos=610;\nQuery OK, 0 rows affected, 9 warnings (0.13 sec)\n\nmysql&gt; start slave until master_log_file='binlog.000021', master_log_pos=340009;\nQuery OK, 0 rows affected, 3 warnings (0.03 sec)\n</code></pre><p>等待SQL线程执行完成，执行完成的标志是Slave_SQL_Running=No，并且Relay_Master_Log_File和Exec_Master_Log_Pos和start slave until命令中指定的位点一样。</p><pre><code class=\"language-plain\">mysql&gt; show slave status\\G\n*************************** 1. row ***************************\n               Slave_IO_State: Waiting for source to send event\n                  Master_Host: 172.16.121.234\n                  Master_User: rep\n                  Master_Port: 16380\n                Connect_Retry: 60\n              Master_Log_File: binlog.000023\n          Read_Master_Log_Pos: 237\n               Relay_Log_File: relaylog.000004\n                Relay_Log_Pos: 340210\n        Relay_Master_Log_File: binlog.000021\n             Slave_IO_Running: Yes\n            Slave_SQL_Running: No\n......\n          Exec_Master_Log_Pos: 340040\n</code></pre><p>和直接使用mysqlbinlog解析binlog并执行的方法对比，用binlog实例进行时间点恢复需要创建一个临时空白实例，看起来更加复杂，但是有下面这些优点。</p><ol>\n<li>更加可靠。使用了mysql原生的复制代码来执行binlog，比使用mysqlbinlog解析binlog并执行更可靠。</li>\n<li>效率更高。如果开启了多线程复制，应用binlog的效率会更高。</li>\n<li>更容易处理异常。如果应用binlog的过程中遇到各种错误，可以像处理一个普通的备库遇到的问题那样来处理。</li>\n</ol><h3>时间点恢复注意事项</h3><p>使用备库产生的binlog恢复数据时，需要注意备库是否有延迟。如果备库本身存在延迟，那么备库上生成的binlog的时间戳和真实的业务时间可能存在偏差，依据这个时间来进行恢复，就可能达不到业务上的恢复目标。所以进行时间点恢复时，优先选择使用主库的binlog来进行恢复。当然在实际业务场景中，主备库之间可能会存在角色切换，需要想办法确定待恢复的时间点上，哪一个实例是主库。</p><p>我们也需要监控好主备库的复制状态，如果存在复制中断、复制延迟、甚至是主备库数据不一致的情况，需要及时处理。不然，在对备库进行的备份可能实际上是无效的。</p><p>前面讲的时间点恢复方案，优点是适应性广，理论上能恢复所有类型的数据误操作。但是如果数据库特别大，恢复的时间可能会比较久。恢复数据消耗的时间越长，业务受到的损失就可能越大。在一些特定的场景下，还可以采用其他一些恢复方法，提升恢复的速度，作为整个数据恢复方案的补充。</p><h2>基于Binlog回滚的数据恢复</h2><p>如果使用了ROW格式的Binlog，并且参数binlog_row_image为FULL，那么在执行DML语句时，会在Binlog中记录修改的记录的所有字段。如果是执行UPDATE或DELETE语句导致的数据问题，你可以在Binlog中找到修改前的数据，进行数据恢复。当然，如果是因为执行了tuncate table或drop table导致的数据丢失，binlog中没有记录具体的数据，就不能使用这种方式来恢复了。</p><p>怎么解析Binlog中的数据呢？有一些开源的工具，比如binlog2sql。其实你也可以使用mysqlbinlog来解析。</p><p>对于ROW格式的Binlog，mysqlbinlog加上-v选项，可以输出文本格式的数据。比如我在数据库上执行了这几个SQL。</p><pre><code class=\"language-plain\">update salaries set salaries = 999999 limit 100;\ndelete from employees limit 30;\n</code></pre><p>使用mysqlbinlog -v，可以解析出这样的数据。</p><pre><code class=\"language-plain\">### UPDATE `employees`.`salaries`\n### WHERE\n###   @1=10001\n###   @2=60117\n###   @3='1986:06:26'\n###   @4='1987:06:26'\n### SET\n###   @1=10001\n###   @2=999999\n###   @3='1986:06:26'\n###   @4='1987:06:26'\n### UPDATE `employees`.`salaries`\n### WHERE\n###   @1=10001\n###   @2=62102\n###   @3='1987:06:26'\n###   @4='1988:06:25'\n### SET\n###   @1=10001\n###   @2=999999\n###   @3='1987:06:26'\n###   @4='1988:06:25'\n\n\n### DELETE FROM `employees`.`employees`\n### WHERE\n###   @1=20\n###   @2='2013:10:10'\n###   @3='AAAA'\n###   @4='BBBB'\n###   @5=1\n###   @6='2024:08:03'\n### DELETE FROM `employees`.`employees`\n### WHERE\n###   @1=10001\n###   @2='1953:09:02'\n###   @3='Georgi'\n###   @4='Facello'\n###   @5=1\n###   @6='2024:08:03'\n</code></pre><p>如果是Update更新错了，可以把Update的Binlog中，Where部分的字段提取出来，这些是更新前的数据。如果是Delete错了，把Where部分的字段提取出来，也可以恢复数据。</p><p>这里的格式比较简单，你可以写一些脚本来提取这些数据。这里我提供一段python代码作为参考。</p><pre><code class=\"language-plain\">import re\nimport sys\n\n\"\"\"\nmysqlbinlog --no-defaults -v binlog_file | python parse_binlog.py\nor\nmysqlbinlog --no-defaults -v binlog_file &gt; decoded_binlog\npython parse_binlog.py decoded_binlog\n\"\"\"\n\nif len(sys.argv) == 1:\n    file = sys.stdin\nelse:\n    file = open(sys.argv[1])\n\nSTATE_UPDATE = 10\nSTATE_DELETE = 20\nSTATE_INIT = 0\n\nm_update = re.compile('### UPDATE `(.*)`[.]`(.*)`')\nm_delete = re.compile('### DELETE FROM `(.*)`[.]`(.*)`')\nm_set = re.compile('###   @[0-9]+=(.*)$')\n\ndef get_lines(file):\n    while True:\n        line = file.readline()\n        if line:\n            yield line\n        else:\n            return\n\ndef parse_binlog():\n    state = STATE_INIT\n    db = ''\n    table = ''\n    columns = []\n    for line in get_lines(file):\n        line = line.strip()\n        if state == STATE_INIT:\n            m = m_update.match(line)\n            if m:\n                state = STATE_UPDATE\n                db, table = m.groups()\n                columns = []\n                continue\n            m = m_delete.match(line)\n            if m:\n                state = STATE_DELETE\n                db, table = m.groups()\n                columns = []\n                continue\n        elif state == STATE_UPDATE:\n            if line == '### WHERE':\n                continue\n            elif line == '### SET':\n                state = STATE_INIT\n                print_sql(db, table, columns, 'update')\n                columns = []\n            else:\n                m = m_set.match(line)\n                if m:\n                    val = m.groups()[0]\n                    columns.append(val)\n        elif state == STATE_DELETE:\n            if line == '### WHERE':\n                continue\n            else:\n                m = m_set.match(line)\n                if m:\n                    val = m.groups()[0]\n                    columns.append(val)\n                else:\n                    print_sql(db, table, columns, 'delete')\n                    columns = []\n                    m = m_delete.match(line)\n                    if m:\n                        state = STATE_DELETE\n                        db, table = m.groups()\n                    else:\n                        state = STATE_INIT\n\ndef print_sql(db, table, columns, dml_type):\n    print \"-- dml_type: {}, db: {}, table: {}, columns: {}\".format(dml_type, db, table, len(columns))\n    print \"replace into {}.{} values({})\".format(db, table, \", \".join(columns))\n\nif __name__ == '__main__':\n    parse_binlog()\n</code></pre><p>这样，你就可以找回误更新或误删除的数据了。</p><pre><code class=\"language-plain\"># mysqlbinlog -v mysql-binlog.000014 | python parse_binlog.py\n\n-- dml_type: update, db: employees, table: salaries, columns: 4\nreplace into employees.salaries values(10001, 60117, '1986:06:26', '1987:06:26')\n-- dml_type: update, db: employees, table: salaries, columns: 4\nreplace into employees.salaries values(10001, 62102, '1987:06:26', '1988:06:25')\n...\n\n-- dml_type: delete, db: employees, table: employees, columns: 6\nreplace into employees.employees values(10028, '1963:11:26', 'Domenick', 'Tempesti', 1, '1991:10:22')\n-- dml_type: delete, db: employees, table: employees, columns: 6\nreplace into employees.employees values(10029, '1956:12:13', 'Otmar', 'Herbst', 1, '1985:11:20')\n</code></pre><p>这里的方法虽然看起来比较简陋，但是在一些特定的场景下，可以帮你快速恢复数据。当然，如果在正式环境使用这类工具，我的建议是先把从Binlog中找回的数据写到一个临时表里，对数据进行验证后，再更新到正式的业务表里。</p><h2>Xtrabackup单表恢复</h2><p>如果表被DROP或Truncate了，你还可以考虑使用xtrabackup的单表恢复功能。当然，能使用单表恢复的前提，是使用了独立表空间(innodb_per_table=1)。</p><p>接下来我给你演示一下单表恢复的操作步骤。</p><h3>1. Prepare备份文件</h3><p>prepare时带上参数–export，xtrabackup会生成import tablespace需要的文件。</p><pre><code class=\"language-plain\"># xtrabackup --prepare --export --target-dir=. &gt; export.log 2&gt;&amp;1\n</code></pre><p>查看日志，确认prepare成功。</p><pre><code class=\"language-plain\">tail export.log\n</code></pre><p>查看目标数据库下的文件，这里我们希望恢复demo.last_gtid表。</p><pre><code class=\"language-plain\"># ls -l demo/last_gtid.*\n-rw-r--r-- 1 root root     715 6月  27 11:03 demo/last_gtid.cfg\n-rw-r----- 1 root root 9437184 6月  26 16:08 demo/last_gtid.ibd\n</code></pre><h3>2. 目标数据库上创建希望恢复的表</h3><p>表结构要和备份时的表结构一致。</p><pre><code class=\"language-plain\">mysql&gt; show create table last_gtid\\G\n*************************** 1. row ***************************\n       Table: last_gtid\nCreate Table: CREATE TABLE `last_gtid` (\n  `id` int NOT NULL AUTO_INCREMENT,\n  `gtid` varchar(1000) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=26733 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci\n1 row in set (0.00 sec)\n</code></pre><p>我们先将表drop掉，模拟数据丢失的场景。</p><pre><code class=\"language-plain\">mysql&gt; drop table last_gtid;\nQuery OK, 0 rows affected (0.03 sec)\n</code></pre><p>创建结构，并执行discard tablespace命令。</p><pre><code class=\"language-plain\">mysql&gt;  CREATE TABLE `last_gtid` (\n       `id` int NOT NULL AUTO_INCREMENT,\n       `gtid` varchar(1000) DEFAULT NULL,\n       PRIMARY KEY (`id`)\n     ) ENGINE=InnoDB;\nQuery OK, 0 rows affected (0.06 sec)\n\nmysql&gt; alter table last_gtid discard tablespace;\nQuery OK, 0 rows affected (0.01 sec)\n</code></pre><h3>3. 将备份的文件copy到目标实例的数据库目录下</h3><p>我们将表的cfg和ibd文件copy到目标实例数据库对应目录下，并修改文件owner。如果文件owner没有正确设置，下一步import表空间时可能会出错。</p><pre><code class=\"language-plain\"># cp last_gtid.* /data/full_restore/data/demo/\n\n# ls -l /data/full_restore/data/demo/\n-rw-r--r-- 1 root  root      715 6月  27 11:06 last_gtid.cfg\n-rw-r----- 1 root  root  9437184 6月  27 11:06 last_gtid.ibd\n\n# chown -R mysql:mysql /data/full_restore/data/demo/\n</code></pre><h3>4. import表空间</h3><p>执行import tablespace命令恢复数据。确认数据已经恢复。</p><pre><code class=\"language-plain\">\nmysql&gt; alter table demo.last_gtid import tablespace;\nQuery OK, 0 rows affected (0.29 sec)\n\nmysql&gt; select count(*) from demo.last_gtid;\n+----------+\n| count(*) |\n+----------+\n|    10813 |\n+----------+\n1 row in set (0.00 sec)\n</code></pre><p>如果不知道表的表结构，可以使用ibd2sdi工具，从ibd文件中提取表结构信息。</p><pre><code class=\"language-plain\"># ibd2sdi last_gtid.ibd | more\n[\"ibd2sdi\"\n,\n{\n\t\"type\": 1,\n\t\"id\": 371,\n\t\"object\":\n\t\t{\n    \"mysqld_version_id\": 80032,\n    \"dd_version\": 80023,\n    \"sdi_version\": 80019,\n    \"dd_object_type\": \"Table\",\n    \"dd_object\": {\n        \"name\": \"last_gtid\",\n        \"mysql_version_id\": 80032,\n        \"created\": 20230621022444,\n        \"last_altered\": 20230621022444,\n        \"hidden\": 1,\n        \"options\": \"avg_row_length=0;encrypt_type=N;key_block_size=0;keys_disabled=0;pack_record=1;stats_a\nuto_recalc=0;stats_sample_pages=0;\",\n        \"columns\": [\n            {\n                \"name\": \"id\",\n                \"type\": 4,\n                \"is_nullable\": false,\n                \"is_zerofill\": false,\n                \"is_unsigned\": false,\n                \"is_auto_increment\": true,\n                \"is_virtual\": false,\n                ......\n\n                \"column_key\": 2,\n                \"column_type_utf8\": \"int\",\n                \"elements\": [],\n                \"collation_id\": 255,\n                \"is_explicit_collation\": false\n            },\n            {\n                \"name\": \"gtid\",\n                \"type\": 16,\n                \"is_nullable\": true,\n                \"is_zerofill\": false,\n                \"is_unsigned\": false,\n                \"is_auto_increment\": false,\n                \"is_virtual\": false,\n                \"hidden\": 1,\n                \"ordinal_position\": 2,\n                \"char_length\": 4000,\n                .....\n                \"column_key\": 1,\n                \"column_type_utf8\": \"varchar(1000)\",\n                \"elements\": [],\n                \"collation_id\": 255,\n                \"is_explicit_collation\": false\n            },\n</code></pre><h2>总结</h2><p>在备份系统的设计中，要把Binlog备份也考虑进去，有了完整的Binlog，你可以将数据库恢复到任意一个时间点。在有些场景下，使用Binlog回滚的方案，能加快数据恢复的速度，减少业务的故障时长。</p><p>针对可能存在的数据丢失故障，你可以有计划地进行恢复演练，这不仅能验证备份和数据恢复方案的有效性，还能给恢复时长建立一个基线。这样，当需要紧急恢复数据时，你可以比较精确地估算出恢复需要多少时间。</p><h2>思考题</h2><p>如果数据库中有几个表被错误地Truncate了，如何在最短的时间内，将这几个表的数据恢复到执行truncate命令前的时间点？</p><p>期待你的思考，欢迎在留言区中与我交流。如果今天的课程让你有所收获，也欢迎转发给有需要的朋友。我们下节课再见。</p>","neighbors":{"left":{"article_title":"38｜为什么有了备库还要做备份？兼谈 Xtrabackup 的使用","id":824912},"right":{"article_title":"40｜MySQL 8.0 Clone 插件的应用和内部原理","id":825825}},"comments":[{"had_liked":false,"id":395813,"user_name":"一本书","can_delete":false,"product_type":"c1","uid":2767251,"ip_address":"湖北","ucode":"4C07047F052BB4","user_header":"https://static001.geekbang.org/account/avatar/00/2a/39/93/f0247cf8.jpg","comment_is_top":false,"comment_ctime":1732156046,"is_pvip":true,"replies":[{"id":143730,"content":"是的，文章里这个地方可能写得不够清楚。\n\n文章里，判断一个binlog文件的时间，用了binlog文件头的时间戳，这个时间是Binlog的创建时间。\n\n至于从主库上复制过来的Binlog，记录到备库的Binlog中时，时间是不会变的。\n\n如果复制有延迟，就可能会存下面在这样的情况。\n备库上Binlog N的开始时间是 10点整，Binlog N+1的开始时间是11点整。\n但由于备库延迟，Binlog N+1里实际上还有主库上10点多生成的Binlog。如果需要把数据恢复到10:30，只应用到Binlog N，就会缺少Binlog N+1中的一些事务。\n","user_name":"作者回复","user_name_real":"编辑","uid":3898827,"ctime":1732168688,"ip_address":"浙江","comment_id":395813,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100799401,"comment_content":"“如果备库本身存在延迟，那么备库上生成的 binlog 的时间戳和真实的业务时间可能存在偏差”，老师，针对这句话我有一些疑问，备库的 binlog 时间戳是binlog在备库中应用的时间点还是与主库保持一致？如果是跟主库保持一致，那就和真实的业务时间应该是一样的吧？gpt说备库的 binlog 时间戳通常与主库保持一致。\n如果选择主备之前存在1分钟延迟，要备份12点的数据，而11：59到12点的数据没应用到备库上，备库的binlog也就没有这部分数据，从而用备库恢复会丢失这部分数据，所以达不到业务上的恢复目标，我猜测是老师想说的是这个意思？","like_count":0,"discussions":[{"author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":654203,"discussion_content":"是的，文章里这个地方可能写得不够清楚。\n\n文章里，判断一个binlog文件的时间，用了binlog文件头的时间戳，这个时间是Binlog的创建时间。\n\n至于从主库上复制过来的Binlog，记录到备库的Binlog中时，时间是不会变的。\n\n如果复制有延迟，就可能会存下面在这样的情况。\n备库上Binlog N的开始时间是 10点整，Binlog N+1的开始时间是11点整。\n但由于备库延迟，Binlog N+1里实际上还有主库上10点多生成的Binlog。如果需要把数据恢复到10:30，只应用到Binlog N，就会缺少Binlog N+1中的一些事务。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1732168688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":395789,"user_name":"牧野静风","can_delete":false,"product_type":"c1","uid":1311629,"ip_address":"广东","ucode":"FB5963F97C23AA","user_header":"https://static001.geekbang.org/account/avatar/00/14/03/8d/38a98dc6.jpg","comment_is_top":false,"comment_ctime":1732082248,"is_pvip":false,"replies":[{"id":143738,"content":"是的。一般在做时间点恢复时，会先把全量数据恢复到一个临时的实例上，然后在这个临时的实例上应用Binlog。恢复数据的过程中，是不允许业务连到这个临时实例上操作的。\n如果是主库遇到数据故障（比如误操作删库删表了），一般的做法是先把数据恢复到一个临时实例，然后再把数据导入到正式环境中。\n\n主库遇到严重数据问题时，先停掉应用。等数据恢复完成后，再开启业务。","user_name":"作者回复","user_name_real":"编辑","uid":3898827,"ctime":1732240334,"ip_address":"浙江","comment_id":395789,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100799401,"comment_content":"有个问题，在使用binlog恢复过程中，这个库只能作为从库了吧，主库要切走之后才好操作，如果是主库，应用连着在写入，这块怎么处理，并且后续正常写入呢","like_count":0,"discussions":[{"author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":654249,"discussion_content":"是的。一般在做时间点恢复时，会先把全量数据恢复到一个临时的实例上，然后在这个临时的实例上应用Binlog。恢复数据的过程中，是不允许业务连到这个临时实例上操作的。\n如果是主库遇到数据故障（比如误操作删库删表了），一般的做法是先把数据恢复到一个临时实例，然后再把数据导入到正式环境中。\n\n主库遇到严重数据问题时，先停掉应用。等数据恢复完成后，再开启业务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1732240334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]}]}