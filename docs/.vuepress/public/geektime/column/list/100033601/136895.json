{"id":136895,"title":"19 | Promise：使用Promise，告别回调函数","content":"<p>在<a href=\"https://time.geekbang.org/column/article/135624\">上一篇文章</a>中我们聊到了微任务是如何工作的，并介绍了MutationObserver是如何利用微任务来权衡性能和效率的。今天我们就接着来聊聊微任务的另外一个应用<strong>Promise</strong>，DOM/BOM API中新加入的API大多数都是建立在Promise上的，而且新的前端框架也使用了大量的Promise。可以这么说，Promise已经成为现代前端的“水”和“电”，很是关键，所以深入学习Promise势在必行。</p><p>不过，Promise的知识点有那么多，而我们只有一篇文章来介绍，那应该怎么讲解呢？具体讲解思路是怎样的呢？</p><p>如果你想要学习一门新技术，最好的方式是先了解这门技术是如何诞生的，以及它所解决的问题是什么。了解了这些后，你才能抓住这门技术的本质。所以本文我们就来重点聊聊JavaScript引入Promise的动机，以及解决问题的几个核心关键点。</p><p>要谈动机，我们一般都是先从问题切入，那么Promise到底解决了什么问题呢？在正式开始介绍之前，我想有必要明确下，Promise解决的是异步编码风格的问题，而不是一些其他的问题，所以接下来我们聊的话题都是围绕编码风格展开的。</p><h2>异步编程的问题：代码逻辑不连续</h2><p>首先我们来回顾下JavaScript的异步编程模型，你应该已经非常熟悉页面的事件循环系统了，也知道页面中任务都是执行在主线程之上的，相对于页面来说，主线程就是它整个的世界，所以在执行一项耗时的任务时，比如下载网络文件任务、获取摄像头等设备信息任务，这些任务都会放到页面主线程之外的进程或者线程中去执行，这样就避免了耗时任务“霸占”页面主线程的情况。你可以结合下图来看看这个处理过程：</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/01/85/01e40e30db7e8a91eb70ce02fd8a6985.png?wh=1142*731\" alt=\"\"></p><center><span class=\"reference\">Web应用的异步编程模型</span></center><p>上图展示的是一个标准的异步编程模型，页面主线程发起了一个耗时的任务，并将任务交给另外一个进程去处理，这时页面主线程会继续执行消息队列中的任务。等该进程处理完这个任务后，会将该任务添加到渲染进程的消息队列中，并排队等待循环系统的处理。排队结束之后，循环系统会取出消息队列中的任务进行处理，并触发相关的回调操作。</p><p>这就是页面编程的一大特点：<strong>异步回调</strong>。</p><p>Web页面的单线程架构决定了异步回调，而异步回调影响到了我们的编码方式，到底是如何影响的呢？</p><p>假设有一个下载的需求，使用XMLHttpRequest来实现，具体的实现方式你可以参考下面这段代码：</p><pre><code>//执行状态\nfunction onResolve(response){console.log(response) }\nfunction onReject(error){console.log(error) }\n\nlet xhr = new XMLHttpRequest()\nxhr.ontimeout = function(e) { onReject(e)}\nxhr.onerror = function(e) { onReject(e) }\nxhr.onreadystatechange = function () { onResolve(xhr.response) }\n\n//设置请求类型，请求URL，是否同步信息\nlet URL = 'https://time.geekbang.com'\nxhr.open('Get', URL, true);\n\n//设置参数\nxhr.timeout = 3000 //设置xhr请求的超时时间\nxhr.responseType = &quot;text&quot; //设置响应返回的数据格式\nxhr.setRequestHeader(&quot;X_TEST&quot;,&quot;time.geekbang&quot;)\n\n//发出请求\nxhr.send();\n</code></pre><p>我们执行上面这段代码，可以正常输出结果的。但是，这短短的一段代码里面竟然出现了五次回调，这么多的回调会导致代码的逻辑不连贯、不线性，非常不符合人的直觉，这就是异步回调影响到我们的编码方式。</p><p>那有什么方法可以解决这个问题吗？当然有，我们可以封装这堆凌乱的代码，降低处理异步回调的次数。</p><h2>封装异步代码，让处理流程变得线性</h2><p>由于我们重点关注的是<strong>输入内容（请求信息）<strong>和</strong>输出内容（回复信息）</strong>，至于中间的异步请求过程，我们不想在代码里面体现太多，因为这会干扰核心的代码逻辑。整体思路如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/83/5c/83dd5231c2e36c636c61af6a6dc80a5c.png?wh=1142*445\" alt=\"\"></p><center><span class=\"reference\">封装请求过程</span></center><p>从图中你可以看到，我们将XMLHttpRequest请求过程的代码封装起来了，重点关注输入数据和输出结果。</p><p>那我们就按照这个思路来改造代码。首先，我们把输入的HTTP请求信息全部保存到一个request的结构中，包括请求地址、请求头、请求方式、引用地址、同步请求还是异步请求、安全设置等信息。request结构如下所示：</p><pre><code>//makeRequest用来构造request对象\nfunction makeRequest(request_url) {\n    let request = {\n        method: 'Get',\n        url: request_url,\n        headers: '',\n        body: '',\n        credentials: false,\n        sync: true,\n        responseType: 'text',\n        referrer: ''\n    }\n    return request\n}\n</code></pre><p>然后就可以封装请求过程了，这里我们将所有的请求细节封装进XFetch函数，XFetch代码如下所示：</p><pre><code>//[in] request，请求信息，请求头，延时值，返回类型等\n//[out] resolve, 执行成功，回调该函数\n//[out] reject  执行失败，回调该函数\nfunction XFetch(request, resolve, reject) {\n    let xhr = new XMLHttpRequest()\n    xhr.ontimeout = function (e) { reject(e) }\n    xhr.onerror = function (e) { reject(e) }\n    xhr.onreadystatechange = function () {\n        if (xhr.status = 200)\n            resolve(xhr.response)\n    }\n    xhr.open(request.method, URL, request.sync);\n    xhr.timeout = request.timeout;\n    xhr.responseType = request.responseType;\n    //补充其他请求信息\n    //...\n    xhr.send();\n}\n</code></pre><p>这个XFetch函数需要一个request作为输入，然后还需要两个回调函数resolve和reject，当请求成功时回调resolve函数，当请求出现问题时回调reject函数。</p><p>有了这些后，我们就可以来实现业务代码了，具体的实现方式如下所示：</p><pre><code>XFetch(makeRequest('https://time.geekbang.org'),\n    function resolve(data) {\n        console.log(data)\n    }, function reject(e) {\n        console.log(e)\n    })\n</code></pre><h2>新的问题：回调地狱</h2><p>上面的示例代码已经比较符合人的线性思维了，在一些简单的场景下运行效果也是非常好的，不过一旦接触到稍微复杂点的项目时，你就会发现，如果嵌套了太多的回调函数就很容易使得自己陷入了<strong>回调地狱</strong>，不能自拔。你可以参考下面这段让人凌乱的代码：</p><pre><code>XFetch(makeRequest('https://time.geekbang.org/?category'),\n      function resolve(response) {\n          console.log(response)\n          XFetch(makeRequest('https://time.geekbang.org/column'),\n              function resolve(response) {\n                  console.log(response)\n                  XFetch(makeRequest('https://time.geekbang.org')\n                      function resolve(response) {\n                          console.log(response)\n                      }, function reject(e) {\n                          console.log(e)\n                      })\n              }, function reject(e) {\n                  console.log(e)\n              })\n      }, function reject(e) {\n          console.log(e)\n      })\n</code></pre><p>这段代码是先请求<code>time.geekbang.org/?category</code>，如果请求成功的话，那么再请求<code>time.geekbang.org/column</code>，如果再次请求成功的话，就继续请求<code>time.geekbang.org</code>。也就是说这段代码用了三层嵌套请求，就已经让代码变得混乱不堪，所以，我们还需要解决这种嵌套调用后混乱的代码结构。</p><p>这段代码之所以看上去很乱，归结其原因有两点：</p><ul>\n<li><strong>第一是嵌套调用</strong>，下面的任务依赖上个任务的请求结果，并<strong>在上个任务的回调函数内部执行新的业务逻辑</strong>，这样当嵌套层次多了之后，代码的可读性就变得非常差了。</li>\n<li><strong>第二是任务的不确定性</strong>，执行每个任务都有两种可能的结果（成功或者失败），所以体现在代码中就需要对每个任务的执行结果做两次判断，这种对每个任务都要进行一次额外的错误处理的方式，明显增加了代码的混乱程度。</li>\n</ul><p>原因分析出来后，那么问题的解决思路就很清晰了：</p><ul>\n<li><strong>第一是消灭嵌套调用</strong>；</li>\n<li><strong>第二是合并多个任务的错误处理</strong>。</li>\n</ul><p>这么讲可能有点抽象，不过Promise已经帮助我们解决了这两个问题。那么接下来我们就来看看Promise是怎么消灭嵌套调用和合并多个任务的错误处理的。</p><h2>Promise：消灭嵌套调用和多次错误处理</h2><p>首先，我们使用Promise来重构XFetch的代码，示例代码如下所示：</p><pre><code>function XFetch(request) {\n  function executor(resolve, reject) {\n      let xhr = new XMLHttpRequest()\n      xhr.open('GET', request.url, true)\n      xhr.ontimeout = function (e) { reject(e) }\n      xhr.onerror = function (e) { reject(e) }\n      xhr.onreadystatechange = function () {\n          if (this.readyState === 4) {\n              if (this.status === 200) {\n                  resolve(this.responseText, this)\n              } else {\n                  let error = {\n                      code: this.status,\n                      response: this.response\n                  }\n                  reject(error, this)\n              }\n          }\n      }\n      xhr.send()\n  }\n  return new Promise(executor)\n}\n</code></pre><p>接下来，我们再利用XFetch来构造请求流程，代码如下：</p><pre><code>var x1 = XFetch(makeRequest('https://time.geekbang.org/?category'))\nvar x2 = x1.then(value =&gt; {\n    console.log(value)\n    return XFetch(makeRequest('https://www.geekbang.org/column'))\n})\nvar x3 = x2.then(value =&gt; {\n    console.log(value)\n    return XFetch(makeRequest('https://time.geekbang.org'))\n})\nx3.catch(error =&gt; {\n    console.log(error)\n})\n</code></pre><p>你可以观察上面这两段代码，重点关注下Promise的使用方式。</p><ul>\n<li>首先我们引入了Promise，在调用XFetch时，会返回一个Promise对象。</li>\n<li>构建Promise对象时，需要传入一个<strong>executor函数</strong>，XFetch的主要业务流程都在executor函数中执行。</li>\n<li>如果运行在excutor函数中的业务执行成功了，会调用resolve函数；如果执行失败了，则调用reject函数。</li>\n<li>在excutor函数中调用resolve函数时，会触发promise.then设置的回调函数；而调用reject函数时，会触发promise.catch设置的回调函数。</li>\n</ul><p>以上简单介绍了Promise一些主要的使用方法，通过引入Promise，上面这段代码看起来就非常线性了，也非常符合人的直觉，是不是很酷？基于这段代码，我们就可以来分析Promise是如何消灭嵌套回调和合并多个错误处理了。</p><p>我们先来看看Promise是怎么消灭嵌套回调的。产生嵌套函数的一个主要原因是在发起任务请求时会带上回调函数，这样当任务处理结束之后，下个任务就只能在回调函数中来处理了。</p><p>Promise主要通过下面两步解决嵌套回调问题的。</p><p><strong>首先，Promise实现了回调函数的延时绑定</strong>。回调函数的延时绑定在代码上体现就是先创建Promise对象x1，通过Promise的构造函数executor来执行业务逻辑；创建好Promise对象x1之后，再使用x1.then来设置回调函数。示范代码如下：</p><pre><code>//创建Promise对象x1，并在executor函数中执行业务逻辑\nfunction executor(resolve, reject){\n    resolve(100)\n}\nlet x1 = new Promise(executor)\n\n\n//x1延迟绑定回调函数onResolve\nfunction onResolve(value){\n    console.log(value)\n}\nx1.then(onResolve)\n</code></pre><p><strong>其次，需要将回调函数onResolve的返回值穿透到最外层</strong>。因为我们会根据onResolve函数的传入值来决定创建什么类型的Promise任务，创建好的Promise对象需要返回到最外层，这样就可以摆脱嵌套循环了。你可以先看下面的代码：</p><p><img src=\"https://static001.geekbang.org/resource/image/ef/7f/efcc4fcbebe75b4f6e92c89b968b4a7f.png?wh=1142*922\" alt=\"\"></p><center><span class=\"reference\">回调函数返回值穿透到最外层</span></center><p>现在我们知道了Promise通过回调函数延迟绑定和回调函数返回值穿透的技术，解决了循环嵌套。</p><p>那接下来我们再来看看Promise是怎么处理异常的，你可以回顾<a href=\"https://time.geekbang.org/column/article/135624\">上篇文章</a>思考题留的那段代码，我把这段代码也贴在文中了，如下所示：</p><pre><code>function executor(resolve, reject) {\n    let rand = Math.random();\n    console.log(1)\n    console.log(rand)\n    if (rand &gt; 0.5)\n        resolve()\n    else\n        reject()\n}\nvar p0 = new Promise(executor);\n\nvar p1 = p0.then((value) =&gt; {\n    console.log(&quot;succeed-1&quot;)\n    return new Promise(executor)\n})\n\nvar p3 = p1.then((value) =&gt; {\n    console.log(&quot;succeed-2&quot;)\n    return new Promise(executor)\n})\n\nvar p4 = p3.then((value) =&gt; {\n    console.log(&quot;succeed-3&quot;)\n    return new Promise(executor)\n})\n\np4.catch((error) =&gt; {\n    console.log(&quot;error&quot;)\n})\nconsole.log(2)\n</code></pre><p>这段代码有四个Promise对象：p0～p4。无论哪个对象里面抛出异常，都可以通过最后一个对象p4.catch来捕获异常，通过这种方式可以将所有Promise对象的错误合并到一个函数来处理，这样就解决了每个任务都需要单独处理异常的问题。</p><p>之所以可以使用最后一个对象来捕获所有异常，是因为Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被onReject函数处理或catch语句捕获为止。具备了这样“冒泡”的特性后，就不需要在每个Promise对象中单独捕获异常了。至于Promise错误的“冒泡”性质是怎么实现的，就留给你课后思考了。</p><p>通过这种方式，我们就消灭了嵌套调用和频繁的错误处理，这样使得我们写出来的代码更加优雅，更加符合人的线性思维。</p><h2>Promise与微任务</h2><p>讲了这么多，我们似乎还没有将微任务和Promise关联起来，那么Promise和微任务的关系到底体现哪里呢？</p><p>我们可以结合下面这个简单的Promise代码来回答这个问题：</p><pre><code>function executor(resolve, reject) {\n    resolve(100)\n}\nlet demo = new Promise(executor)\n\nfunction onResolve(value){\n    console.log(value)\n}\ndemo.then(onResolve)\n</code></pre><p>对于上面这段代码，我们需要重点关注下它的执行顺序。</p><p>首先执行new Promise时，Promise的构造函数会被执行，不过由于Promise是V8引擎提供的，所以暂时看不到Promise构造函数的细节。</p><p>接下来，Promise的构造函数会调用Promise的参数executor函数。然后在executor中执行了resolve，resolve函数也是在V8内部实现的，那么resolve函数到底做了什么呢？我们知道，执行resolve函数，会触发demo.then设置的回调函数onResolve，所以可以推测，resolve函数内部调用了通过demo.then设置的onResolve函数。</p><p>不过这里需要注意一下，由于Promise采用了回调函数延迟绑定技术，所以在执行resolve函数的时候，回调函数还没有绑定，那么只能推迟回调函数的执行。</p><p>这样按顺序陈述可能把你绕晕了，下面来模拟实现一个Promise，我们会实现它的构造函数、resolve方法以及then方法，以方便你能看清楚Promise的背后都发生了什么。这里我们就把这个对象称为Bromise，下面就是Bromise的实现代码：</p><pre><code>function Bromise(executor) {\n    var onResolve_ = null\n    var onReject_ = null\n     //模拟实现resolve和then，暂不支持rejcet\n    this.then = function (onResolve, onReject) {\n        onResolve_ = onResolve\n    };\n    function resolve(value) {\n          //setTimeout(()=&gt;{\n            onResolve_(value)\n           // },0)\n    }\n    executor(resolve, null);\n}\n</code></pre><p>观察上面这段代码，我们实现了自己的构造函数、resolve、then方法。接下来我们使用Bromise来实现我们的业务代码，实现后的代码如下所示：</p><pre><code>function executor(resolve, reject) {\n    resolve(100)\n}\n//将Promise改成我们自己的Bromsie\nlet demo = new Bromise(executor)\n\nfunction onResolve(value){\n    console.log(value)\n}\ndemo.then(onResolve)\n</code></pre><p>执行这段代码，我们发现执行出错，输出的内容是：</p><pre><code>Uncaught TypeError: onResolve_ is not a function\n    at resolve (&lt;anonymous&gt;:10:13)\n    at executor (&lt;anonymous&gt;:17:5)\n    at new Bromise (&lt;anonymous&gt;:13:5)\n    at &lt;anonymous&gt;:19:12\n</code></pre><p>之所以出现这个错误，是由于Bromise的延迟绑定导致的，在调用到onResolve_函数的时候，Bromise.then还没有执行，所以执行上述代码的时候，当然会报“onResolve_ is not a function“的错误了。</p><p>也正是因为此，我们要改造Bromise中的resolve方法，让resolve延迟调用onResolve_。</p><p>要让resolve中的onResolve_函数延后执行，可以在resolve函数里面加上一个定时器，让其延时执行onResolve_函数，你可以参考下面改造后的代码：</p><pre><code>function resolve(value) {\n          setTimeout(()=&gt;{\n              onResolve_(value)\n            },0)\n    }\n</code></pre><p>上面采用了定时器来推迟onResolve的执行，不过使用定时器的效率并不是太高，好在我们有微任务，所以Promise又把这个定时器改造成了微任务了，这样既可以让onResolve_延时被调用，又提升了代码的执行效率。这就是Promise中使用微任务的原由了。</p><h2>总结</h2><p>好了，今天我们就聊到这里，下面我来总结下今天所讲的内容。</p><p>首先，我们回顾了Web页面是单线程架构模型，这种模型决定了我们编写代码的形式——异步编程。基于异步编程模型写出来的代码会把一些关键的逻辑点打乱，所以这种风格的代码不符合人的线性思维方式。接下来我们试着把一些不必要的回调接口封装起来，简单封装取得了一定的效果，不过，在稍微复制点的场景下依然存在着回调地狱的问题。然后我们分析了产生回调地狱的原因：</p><ol>\n<li>多层嵌套的问题；</li>\n<li>每种任务的处理结果存在两种可能性（成功或失败），那么需要在每种任务执行结束后分别处理这两种可能性。</li>\n</ol><p>Promise通过回调函数延迟绑定、回调函数返回值穿透和错误“冒泡”技术解决了上面的两个问题。</p><p>最后，我们还分析了Promise之所以要使用微任务是由Promise回调函数延迟绑定技术导致的。</p><h2>思考时间</h2><p>终于把Promise讲完了，这一篇文章非常有难度，所以需要你课后慢慢消消化，再次提醒，Promise非常重要。那么今天我给你留三个思考题：</p><ol>\n<li>Promise中为什么要引入微任务？</li>\n<li>Promise中是如何实现回调函数返回值穿透的？</li>\n<li>Promise出错后，是怎么通过“冒泡”传递给最后那个捕获异常的函数？</li>\n</ol><p>这三个问题你不用急着完成，可以先花一段时间查阅材料，然后再来一道一道解释。搞清楚了这三道题目，你也就搞清楚了Promise。</p><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><p></p>","comments":[{"had_liked":false,"id":133936,"user_name":"Geek_Jamorx","can_delete":false,"product_type":"c1","uid":1608908,"ip_address":"","ucode":"5B5669D0C75FBD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ0F94uoYZQicRd7YEFjEJWm0EaUJXzkhiaqa5GQQ8a1FkicQIoHC4sp2ZG9m1JAFABuGsj34ucztjibA/132","comment_is_top":false,"comment_ctime":1568702426,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"358050987994","product_id":100033601,"comment_content":"这三个题目非常重要，就跟做笔记一样回答了<br>1、Promise 中为什么要引入微任务？<br><br>由于promise采用.then延时绑定回调机制，而new Promise时又需要直接执行promise中的方法，即发生了先执行方法后添加回调的过程，此时需等待then方法绑定两个回调后才能继续执行方法回调，便可将回调添加到当前js调用栈中执行结束后的任务队列中，由于宏任务较多容易堵塞，则采用了微任务<br><br>2、Promise 中是如何实现回调函数返回值穿透的？<br>首先Promise的执行结果保存在promise的data变量中，然后是.then方法返回值为使用resolved或rejected回调方法新建的一个promise对象，即例如成功则返回new Promise（resolved），将前一个promise的data值赋给新建的promise<br><br>3、Promise 出错后，是怎么通过“冒泡”传递给最后那个捕获<br>promise内部有resolved_和rejected_变量保存成功和失败的回调，进入.then（resolved，rejected）时会判断rejected参数是否为函数，若是函数，错误时使用rejected处理错误；若不是，则错误时直接throw错误，一直传递到最后的捕获，若最后没有被捕获，则会报错。可通过监听unhandledrejection事件捕获未处理的promise错误<br><br><br><br>","like_count":84,"discussions":[{"author":{"id":1008156,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/1c/2218975d.jpg","nickname":"左岸","note":"","ucode":"68A80875587B75","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":47972,"discussion_content":"为什么不在then函数实现的时候，判断下promise的状态如果已经resolved则执行 onResolve回调， onResolve_ 那里也判断下是否有 onResolved回调 有则执行，没有则不执行","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1573438529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1201350,"avatar":"https://static001.geekbang.org/account/avatar/00/12/54/c6/c2481790.jpg","nickname":"lisiur","note":"","ucode":"CEB2DBCE29CAA7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1008156,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/1c/2218975d.jpg","nickname":"左岸","note":"","ucode":"68A80875587B75","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":61700,"discussion_content":"我也有同样疑问，所以我觉得延时绑定不是promise引入微任务的原因，只是规范里说了“onFulfilled 和 onRejected 只有在执行环境堆栈仅包含平台代码时才可被调用”（异步调用），所以才引入微任务，至于为啥一定要异步执行，我还很疑惑","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574782552,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":47972,"ip_address":""},"score":61700,"extra":""},{"author":{"id":1266698,"avatar":"https://static001.geekbang.org/account/avatar/00/13/54/0a/9a002ad5.jpg","nickname":"Adam Lau","note":"","ucode":"7E542D6E789500","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1008156,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/1c/2218975d.jpg","nickname":"左岸","note":"","ucode":"68A80875587B75","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364322,"discussion_content":"如果没有then呢，resolve咋执行？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617442888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":47972,"ip_address":""},"score":364322,"extra":""},{"author":{"id":1077573,"avatar":"https://static001.geekbang.org/account/avatar/00/10/71/45/126cd913.jpg","nickname":"袭","note":"","ucode":"D5B8609CDFB145","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1008156,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/1c/2218975d.jpg","nickname":"左岸","note":"","ucode":"68A80875587B75","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376287,"discussion_content":"因为在new的时候就要执行到resolve，如果没有绑定线性执行下去会报错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622057742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":47972,"ip_address":""},"score":376287,"extra":""}]},{"author":{"id":2547859,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/93/c512e343.jpg","nickname":"云销雨霁","note":"","ucode":"0F3F5867B9EC82","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389127,"discussion_content":"我测试了，“若不是，则错误时直接throw错误”, 并没有，而是用new promise.reject封装错误，是新promise，一直向后传递，可以被.catch 捕获，如果catch有回调函数，如果没有只能继续外抛，只能被 unhandledrejection捕获","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629126895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1201350,"avatar":"https://static001.geekbang.org/account/avatar/00/12/54/c6/c2481790.jpg","nickname":"lisiur","note":"","ucode":"CEB2DBCE29CAA7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":63970,"discussion_content":"2.2.4 onFulfilled or onRejected must not be called until the execution context stack contains only platform code.  [Promise/A+规范]\n3.1 Here “platform code” means engine, environment, and promise implementation code. In practice, **this requirement ensures that onFulfilled and onRejected execute asynchronously, after the event loop turn in which then is called, and with a fresh stack.** This can be implemented with either a “macro-task” mechanism such as setTimeout or setImmediate, or with a “micro-task” mechanism such as MutationObserver or process.nextTick. Since the promise implementation is considered platform code, it may itself contain a task-scheduling queue or “trampoline” in which the handlers are called. [Promise/A+规范]","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574926998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134180,"user_name":"空间","can_delete":false,"product_type":"c1","uid":1294597,"ip_address":"","ucode":"2C83162E9E914A","user_header":"https://static001.geekbang.org/account/avatar/00/13/c1/05/fd1d47b6.jpg","comment_is_top":false,"comment_ctime":1568771234,"is_pvip":false,"replies":[{"id":"51508","content":"ajax就是xmlhttprequest，必然是宏任务！<br><br>准确地说，Promise在执行resolve或者reject时，触发微任务，所以在Promise的executor函数中调用xmlhttprequest会触发宏任务。<br><br>如果xmlhttprequest请求成功了，通过resolve触发微任务<br><br>如果xmlhttprequest请求失败了，通过reject触发微任务","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1568809633,"ip_address":"","comment_id":134180,"utype":1}],"discussion_count":2,"race_medal":0,"score":"263561776290","product_id":100033601,"comment_content":"异步AJAX请求是宏任务吧？Promise是微任务，那么用Promise进行的异步Ajax调用时宏任务还是微任务？","like_count":62,"discussions":[{"author":{"id":2071110,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/9a/46/bb7d948e.jpg","nickname":"ronny","note":"","ucode":"E2D3A70AAC89AA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390852,"discussion_content":"1. Promise是微任务的说法有些偏了，应该是Promise中执行的resolve或者reject函数是微任务。\n2. Promise构造函数中的代码跟同步代码一样执行，所以在Promise构造函数中的ajax调用就跟不在Promise中执行一样，就是产生一个宏任务。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1630078218,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467642,"discussion_content":"ajax就是xmlhttprequest，必然是宏任务！\n\n准确地说，Promise在执行resolve或者reject时，触发微任务，所以在Promise的executor函数中调用xmlhttprequest会触发宏任务。\n\n如果xmlhttprequest请求成功了，通过resolve触发微任务\n\n如果xmlhttprequest请求失败了，通过reject触发微任务","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1568809633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134231,"user_name":"皮皮大神","can_delete":false,"product_type":"c1","uid":1395031,"ip_address":"","ucode":"A42B445AB85736","user_header":"https://static001.geekbang.org/account/avatar/00/15/49/57/978fb576.jpg","comment_is_top":false,"comment_ctime":1568778743,"is_pvip":false,"replies":[{"id":"51472","content":"这个加餐可以有！<br><br>这篇问题主要在宏观视角建立对Promise的认知。<br><br>关于手写 或者细节内容课程结束之后我们慢慢聊。<br><br>目前被编辑追稿子压力大，好多问题没及时回复还望理解哈。课程结束之后我会相信回复大家的问题的。<br>","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1568781605,"ip_address":"","comment_id":134231,"utype":1}],"discussion_count":11,"race_medal":0,"score":"104647993847","product_id":100033601,"comment_content":"老师，我觉得这章没有前面的讲得透彻，手写的bromise非常不完整，希望老师答疑的时候可以带我们写一遍完整promise源码，三种状态的切换，还有.then为什么可以连续调用，内部如何解决多层异步嵌套，我觉得都很值得讲解，老师带我们飞。","like_count":25,"discussions":[{"author":{"id":1028582,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b1/e6/d09e9277.jpg","nickname":"Geek_aa4de8","note":"","ucode":"8BAF6A3B421E86","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":14935,"discussion_content":"再牛的大佬也怕催稿，哈哈哈哈","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1568790023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467662,"discussion_content":"这个加餐可以有！\n\n这篇问题主要在宏观视角建立对Promise的认知。\n\n关于手写 或者细节内容课程结束之后我们慢慢聊。\n\n目前被编辑追稿子压力大，好多问题没及时回复还望理解哈。课程结束之后我会相信回复大家的问题的。\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568781605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1273044,"avatar":"https://static001.geekbang.org/account/avatar/00/13/6c/d4/85ef1463.jpg","nickname":"路漫漫","note":"","ucode":"F70F1DC612DE9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":549360,"discussion_content":"老师，三年了，加个餐吧，快饿死了","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1643882301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":467662,"ip_address":""},"score":549360,"extra":""}]},{"author":{"id":1232242,"avatar":"https://static001.geekbang.org/account/avatar/00/12/cd/72/b7083420.jpg","nickname":"Zzzrd","note":"","ucode":"524593B1193AFE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284892,"discussion_content":"希望有生之年还能看到加餐","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592667840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1598292,"avatar":"","nickname":"乔小爷","note":"","ucode":"FF62A2A482091E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":233968,"discussion_content":"说好的加餐呢，没看到呀","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586953438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1920900,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/4f/84/1f07b419.jpg","nickname":"菜心儿","note":"","ucode":"9A40BDE81550C5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212282,"discussion_content":"同意，可以分析下promise的源码","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584954758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042608,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/b0/0fcb621d.jpg","nickname":"Zero","note":"","ucode":"59ABB977DAD663","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367682,"discussion_content":"老师领进门，不能手把手永远教下去吧。promise简易实现那篇文章就很好，自己写一遍就都能明白了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618424074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1394410,"avatar":"https://static001.geekbang.org/account/avatar/00/15/46/ea/b86667b8.jpg","nickname":"王玄","note":"","ucode":"E54ABB340D1E49","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":354896,"discussion_content":"git 上面搜索 es6-promise 看一下 代码很精妙","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615358992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1215560,"avatar":"https://static001.geekbang.org/account/avatar/00/12/8c/48/9fe3e416.jpg","nickname":"深红","note":"","ucode":"1D498804604D32","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284110,"discussion_content":"可以看看我之前写过的promise简易实现 http://anata.me/2020/05/07/Promise简易实现/","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592446485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1074336,"avatar":"https://static001.geekbang.org/account/avatar/00/10/64/a0/95c76200.jpg","nickname":"寰","note":"","ucode":"1C177E813ADA41","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":226495,"discussion_content":"看到代码就喷饭了，可怜我的学费","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586435166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121383,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1c/67/8bc3f8a6.jpg","nickname":"Ciel","note":"","ucode":"EB2FF38EE85EB0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":20936,"discussion_content":"看到这就笑了哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569400157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207476,"user_name":"穿秋裤的男孩","can_delete":false,"product_type":"c1","uid":1748640,"ip_address":"","ucode":"D0F48C66377893","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ae/a0/707350ef.jpg","comment_is_top":false,"comment_ctime":1587090949,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"44536763909","product_id":100033601,"comment_content":"promise.then是订阅者，订阅promise状态的改变，并且负责回掉；promise.resolve和promise.reject为发布者，发布promise的状态改变的信息。","like_count":11,"discussions":[{"author":{"id":2338500,"avatar":"https://static001.geekbang.org/account/avatar/00/23/ae/c4/eafb9ba1.jpg","nickname":"长寿","note":"","ucode":"5FBDF9E65D2F3F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584890,"discussion_content":"这个我觉得不能算是发布订阅，因为then方法是通过检查promise对象的状态来执行对应回调。而resolve和reject是用来改变当前promise的状态的，并没有发布事件。所以应该说是围绕着promise这个状态机来处理异步逻辑的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661208809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"辽宁"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138468,"user_name":"Rapheal","can_delete":false,"product_type":"c1","uid":1636368,"ip_address":"","ucode":"71BCD0F9131EF2","user_header":"","comment_is_top":false,"comment_ctime":1570262780,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40224968444","product_id":100033601,"comment_content":"Promise的改进版，测试过也无问题。之前使用闭包存放所有回调函数有些问题，所有的Promise对象都是共享，这样会造成全局数据结构有问题。当前是基于回调函数数组传递在Promise对象之间传递实现。<br><br><br>    function _Promise(executor) {<br>        this._resolve = [];<br>        this._reject = [];<br>        this._catch;<br><br>        &#47;*临时保存引用*&#47;<br>        let self = this;<br>        <br>        this.then = function (resolve, reject) {<br>            resolve &amp;&amp; this._resolve.push(resolve);<br>            reject &amp;&amp; this._reject.push(reject);<br>            return this;<br>        }<br><br>        <br>        this.resolve = function (data) {<br>            setTimeout(() =&gt; {<br>                let callback = self._resolve.shift();<br>                self._reject &amp;&amp; self._reject.shift();<br>                let pro;<br>                callback &amp;&amp; (pro = callback(data));<br>                self._resolve &amp;&amp; (pro._resolve = self._resolve);<br>                self._reject &amp;&amp; (pro._reject = self._reject);<br>                self._catch &amp;&amp; (pro._catch = self._catch);<br><br>            }, 0)<br>        }<br><br>        this.reject = function (error) {        <br>            setTimeout(() =&gt; {<br>                let callback;<br>                self._reject &amp;&amp; (callback = self._reject.shift());<br>                callback &amp;&amp; callback(error);<br>                callback || self._catch(error);<br><br>            }, 0);<br>        }<br><br>        this.catch = function (callback) {<br>            this._catch = callback;<br>            return this;<br>        }<br>        executor(this.resolve, this.reject);<br>    }<br><br><br>function executor(resolve, reject) {<br>    let rand = Math.random();<br>    console.log(1)<br>    console.log(rand)<br>    if (rand &gt; 0.5)<br>        resolve(rand)<br>    else<br>        reject(rand)<br>}<br>var p0 = new _Promise(executor);<br><br>var p1 = p0.then((value) =&gt; {<br>    console.log(&quot;succeed-1&quot;)<br>    return new _Promise(executor)<br>})<br><br>var p3 = p1.then((value) =&gt; {<br>    console.log(&quot;succeed-2&quot;)<br>    return new _Promise(executor)<br>})<br><br>var p4 = p3.then((value) =&gt; {<br>    console.log(&quot;succeed-3&quot;)<br>    return new _Promise(executor)<br>})<br><br>p4.catch((error) =&gt; {<br>    console.log(&quot;error&quot;)<br>})<br><br><br>console.log(2)<br>","like_count":9},{"had_liked":false,"id":134890,"user_name":"Angus","can_delete":false,"product_type":"c1","uid":1377467,"ip_address":"","ucode":"7CC3BA1550FB5B","user_header":"https://static001.geekbang.org/account/avatar/00/15/04/bb/5e5c37c1.jpg","comment_is_top":false,"comment_ctime":1568947407,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"31633718479","product_id":100033601,"comment_content":"看完这节之后我自己去实现了手写Promise，回顾了一下Promise，关于这方面的文章很多，我觉得老师大可不必在这里花大量篇幅去讲。专栏的名字是浏览器工作原理与实践，所以我希望老师能够更加着重这一方面的讲解。","like_count":8,"discussions":[{"author":{"id":1677187,"avatar":"https://static001.geekbang.org/account/avatar/00/19/97/83/845b48e2.jpg","nickname":"Allen_","note":"","ucode":"CA5E00E4644CD5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41946,"discussion_content":"老师多讲还不行，promise也是实践中很重要的啊，我支持老师这种广而深的方法","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1572537476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1231317,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c9/d5/b08a27ed.jpg","nickname":"灵感_idea","note":"","ucode":"E0DBDDFA6040F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1677187,"avatar":"https://static001.geekbang.org/account/avatar/00/19/97/83/845b48e2.jpg","nickname":"Allen_","note":"","ucode":"CA5E00E4644CD5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340794,"discussion_content":"是的，这都是这个专栏中的惊喜，平时在其他文章里零零散散看到的，在这里基本都有了，超值。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1610161065,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":41946,"ip_address":""},"score":340794,"extra":""}]}]},{"had_liked":false,"id":206848,"user_name":"乔小爷","can_delete":false,"product_type":"c1","uid":1598292,"ip_address":"","ucode":"FF62A2A482091E","user_header":"","comment_is_top":false,"comment_ctime":1586944647,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27356748423","product_id":100033601,"comment_content":"不是说要手写promise吗，，怎么在教程里面没有看到","like_count":6,"discussions":[{"author":{"id":1519072,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2d/e0/d50a729c.jpg","nickname":"詹昊潼","note":"","ucode":"ECBD75B87168A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":235127,"discussion_content":"对，加餐里面就没有promise","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1587022142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186710,"user_name":"Geek_be6d3f","can_delete":false,"product_type":"c1","uid":1895737,"ip_address":"","ucode":"6FA800907EDE27","user_header":"","comment_is_top":false,"comment_ctime":1583908494,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18763777678","product_id":100033601,"comment_content":"请问以下，在“异步编程的问题：代码逻辑不连续”这段中，代码下方的第一行，老师说“这短短的一段代码里面竟然出现了五次回调”，可是我怎么数，都只有三次回调啊，还有两次在哪里？","like_count":4,"discussions":[{"author":{"id":1646417,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK8UYbedASKgzZfao6svMhNA9bsNWmxcQ7pibshPncmia9icCNV1kb3WZ4G2maRfQqvsbhLIsiat1vsrw/132","nickname":"dudoulion","note":"","ucode":"321675BC8C1C02","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291650,"discussion_content":" xhr.ontimeout = function (e)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594898895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134914,"user_name":"Hurry","can_delete":false,"product_type":"c1","uid":1138560,"ip_address":"","ucode":"12FEE2A50CC667","user_header":"https://static001.geekbang.org/account/avatar/00/11/5f/80/51269d88.jpg","comment_is_top":false,"comment_ctime":1568950819,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14453852707","product_id":100033601,"comment_content":"这个太赞了 “ Promise 通过回调函数延迟绑定、回调函数返回值穿透和和错误“冒泡”技术 “， 之前看到别人手写实现 Promise，代码虽然可以看懂，但是理解不深，所以关键还是看如何实现这个三个点 回调函数延迟绑定、回调函数返回值穿透和和错误“冒泡”，结合这三个点和 promise API，手写一个 Promise, So easy<br><br>```js<br>class PromiseSimple {<br>  constructor(executionFunction) {<br>    this.promiseChain = []; &#47;&#47; 1.通过数组存储 callback，实现callback 延迟执行<br>    this.handleError = () =&gt; {};<br><br>    this.onResolve = this.onResolve.bind(this);<br>    this.onReject = this.onReject.bind(this);<br><br>    executionFunction(this.onResolve, this.onReject);<br>  }<br><br>  then(onResolve) {<br>    this.promiseChain.push(onResolve);<br><br>    return this;<br>  }<br><br>  catch(handleError) {<br>    this.handleError = handleError;<br><br>    return this;<br>  }<br><br>  onResolve(value) {<br>    let storedValue = value;<br><br>    try {<br>      this.promiseChain.forEach((nextFunction) =&gt; {<br>         storedValue = nextFunction(storedValue); &#47;&#47; 2.循环，实现 callback 值传递<br>      });<br>    } catch (error) {   &#47;&#47; 3. try catch, 实现错误值冒泡<br>      this.promiseChain = [];<br><br>      this.onReject(error);<br>    }<br>  }<br><br>  onReject(error) {<br>    this.handleError(error);<br>  }<br>}<br>```<br>","like_count":3,"discussions":[{"author":{"id":1677187,"avatar":"https://static001.geekbang.org/account/avatar/00/19/97/83/845b48e2.jpg","nickname":"Allen_","note":"","ucode":"CA5E00E4644CD5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41948,"discussion_content":"这是最菜鸟版的promise，现在的比这个复杂多了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572537605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133817,"user_name":"許敲敲","can_delete":false,"product_type":"c1","uid":1046681,"ip_address":"","ucode":"6486466820E7BF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/99/8e760987.jpg","comment_is_top":false,"comment_ctime":1568679137,"is_pvip":false,"replies":[{"id":"51511","content":"手写我加餐来讲","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1568810094,"ip_address":"","comment_id":133817,"utype":1}],"discussion_count":9,"race_medal":0,"score":"14453581025","product_id":100033601,"comment_content":"面试手写promise也不怕了","like_count":3,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467515,"discussion_content":"手写我加餐来讲","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568810094,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2740364,"avatar":"https://static001.geekbang.org/account/avatar/00/29/d0/8c/d18d1309.jpg","nickname":"不凉","note":"","ucode":"3A57D3845F921C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":560215,"discussion_content":"等加餐\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1649230857,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":467515,"ip_address":""},"score":560215,"extra":""}]},{"author":{"id":1910075,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/25/3b/a971fc8e.jpg","nickname":"阿感","note":"","ucode":"7BCB7E44A832D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":256499,"discussion_content":"等老师加餐……","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1588487943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1168666,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/ibZO2lNDlECbEc1Ykkne3nfaXSJunnJa5ia0IWLLdcibrXdtVmjMEpdUWaUHx67ArRw35taAgfaYt9PO3aR73Sl8w/132","nickname":"zhaozigang","note":"","ucode":"4F05977DB5380A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1910075,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/25/3b/a971fc8e.jpg","nickname":"阿感","note":"","ucode":"7BCB7E44A832D1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311638,"discussion_content":"等加餐","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1602427568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":256499,"ip_address":""},"score":311638,"extra":""},{"author":{"id":2224995,"avatar":"https://static001.geekbang.org/account/avatar/00/21/f3/63/0a851d59.jpg","nickname":"goali","note":"","ucode":"0AD765488BAFC9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1168666,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/ibZO2lNDlECbEc1Ykkne3nfaXSJunnJa5ia0IWLLdcibrXdtVmjMEpdUWaUHx67ArRw35taAgfaYt9PO3aR73Sl8w/132","nickname":"zhaozigang","note":"","ucode":"4F05977DB5380A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340845,"discussion_content":"等加餐","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610178345,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":311638,"ip_address":""},"score":340845,"extra":""},{"author":{"id":2015986,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c2/f2/b3b349a4.jpg","nickname":"OOP","note":"","ucode":"FA536DFBF793F8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2224995,"avatar":"https://static001.geekbang.org/account/avatar/00/21/f3/63/0a851d59.jpg","nickname":"goali","note":"","ucode":"0AD765488BAFC9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363695,"discussion_content":"等加餐","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617264784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":340845,"ip_address":""},"score":363695,"extra":""}]},{"author":{"id":2311402,"avatar":"https://static001.geekbang.org/account/avatar/00/23/44/ea/8a9b868d.jpg","nickname":"琼斯基亚","note":"","ucode":"24892258DF0CC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542741,"discussion_content":"没有加餐了，吃不饱了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640832565,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1228985,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c0/b9/df78724b.jpg","nickname":"C。","note":"","ucode":"0C5F9B62531DD3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381021,"discussion_content":"等加餐啊老师\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1624870003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1462795,"avatar":"https://static001.geekbang.org/account/avatar/00/16/52/0b/d5cff3ea.jpg","nickname":"钢蛋","note":"","ucode":"8824D3032B333E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353733,"discussion_content":"等加餐啊老师","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1615197512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":291944,"user_name":"Condor Hero","can_delete":false,"product_type":"c1","uid":1528334,"ip_address":"","ucode":"BD850FE812D22F","user_header":"https://static001.geekbang.org/account/avatar/00/17/52/0e/c5ff46d2.jpg","comment_is_top":false,"comment_ctime":1620620476,"is_pvip":true,"discussion_count":1,"race_medal":1,"score":"10210555068","product_id":100033601,"comment_content":"```js<br>new Promise((r, rj) =&gt; {<br>    r();<br>}).then(() =&gt; {<br>    new Promise((r, rj) =&gt; {<br>        r();<br>    }).then(() =&gt; {<br>        console.log(&quot;inner then1&quot;)<br>        return new Promise((r, rj) =&gt; {<br>            r();<br>        })<br>    }).then(() =&gt; {<br>        console.log(&quot;inner then2&quot;)<br>    })<br>})<br>.then(() =&gt; {<br>    console.log(&quot;outer then2&quot;);<br>})<br>.then(() =&gt; {<br>    console.log(&quot;outer then3&quot;);<br>})<br>.then(() =&gt; {<br>    console.log(&quot;outer then4&quot;);<br>})<br>.then(() =&gt; {<br>    console.log(&quot;outer then5&quot;);<br>})<br>.then(() =&gt; {<br>    console.log(&quot;outer then6&quot;);<br>})<br>```<br>输出结果：<br><br>```<br>inner then1<br>outer then2<br>outer then3<br>outer then4<br>inner then2<br>outer then5<br>outer then6<br>```<br>老师能帮忙解释下这段代码的输出逻辑吗？<br><br>搞不懂输出 `outer then2` 之后紧接着输出了 `outer then3` 和  `outer then4` ，然后才输出 `inner then2`。<br><br>而我理解的是 `outer then2` 之后直接输出 `inner then2` 才对，我理解的顺序：<br><br>```<br>inner then1<br>outer then2<br>inner then2<br>outer then3<br>outer then4<br>outer then5<br>outer then6<br>```<br>","like_count":3,"discussions":[{"author":{"id":1506837,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epDbHfM0ly8B8k6RTtpqlqAU7PKribkLuk5PWbPdgeicVicoTY8wNMeFxtYx1ehvN5eSyfkq27dQUiaxg/132","nickname":"xliang","note":"","ucode":"862DCB20A60CEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535083,"discussion_content":"第一个Promise的then里new了另一个Promise，而不是return new Promise，这是创建了两条Promise链，两条链之间是相互竞争的，可能调用的顺序刚好导致这样的输出顺序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638347545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220558,"user_name":"张萌","can_delete":false,"product_type":"c1","uid":1377299,"ip_address":"","ucode":"89C08DB3239BE5","user_header":"https://static001.geekbang.org/account/avatar/00/15/04/13/84d35588.jpg","comment_is_top":false,"comment_ctime":1590288633,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10180223225","product_id":100033601,"comment_content":"一个简易版的 Promise<br>class Promise {<br>  constructor(fn) {<br>    this.state = Promise.PENDING;<br>    this.value = undefined;<br>    this.reason = null;<br>    this.onFulfilledCallbacks = [];<br>    this.onRejectedCallbacks = [];<br>    fn(this.resolve.bind(this), this.reject.bind(this));<br>  }<br><br>  then(onFulfilled, onRejected) {<br>    if (this.state === Promise.FULFILLED) {<br>      onFulfilled(this.value);<br>    } else if (this.state === Promise.REJECTED) {<br>      onRejected(this.reason);<br>    } else {<br>      this.onFulfilledCallbacks.push(onFulfilled);<br>      this.onRejectedCallbacks.push(onRejected);<br>    }<br>    return this;<br>  }<br><br>  resolve(value) {<br>    this.state = Promise.FULFILLED;<br>    this.value = value;<br>    if (value.constructor === this.constructor) {<br>      value.onFulfilledCallbacks = [...this.onFulfilledCallbacks];<br>      value.onRejectedCallbacks = [...this.onRejectedCallbacks];<br>    } else {<br>      this.onFulfilledCallbacks.forEach((item) =&gt; {<br>        if (typeof item === &#39;function&#39;) {<br>          item(value);<br>        }<br>      });<br>    }<br>  }<br><br>  reject(reason) {<br>    this.state = Promise.REJECTED;<br>    this.reason = reason;<br>    this.onRejectedCallbacks.forEach((item) =&gt; {<br>      if (typeof item === &#39;function&#39;) {<br>        item(reason);<br>      }<br>    });<br>  }<br>}<br><br>Promise.PENDING = &#39;pending&#39;;<br>Promise.FULFILLED = &#39;fulfilled&#39;;<br>Promise.REJECTED = &#39;rejected&#39;;<br><br><br>module.exports = Promise;","like_count":2,"discussions":[{"author":{"id":2258397,"avatar":"https://static001.geekbang.org/account/avatar/00/22/75/dd/9affd4d5.jpg","nickname":"九千七","note":"","ucode":"1E385C88B3401A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343689,"discussion_content":"let promise = new Promise((resolve, reject) => {\n    resolve(3);\n  }).then((val) => {\n    return 4\n  }).then((val) => {\n    console.log(val)\n  })\n这个例子就不行哦，这里输出的应该是4\n问题在于then方法中不是简单的返回自身","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611136281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1190201,"avatar":"https://static001.geekbang.org/account/avatar/00/12/29/39/0aec7827.jpg","nickname":"费马","note":"","ucode":"BCAAF9C16F0CC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342393,"discussion_content":"很清楚！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610672107,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":305263,"user_name":"林高鸿","can_delete":false,"product_type":"c1","uid":1008474,"ip_address":"","ucode":"34AD2C0A7542AB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/5a/4ec96cfe.jpg","comment_is_top":false,"comment_ctime":1627895345,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5922862641","product_id":100033601,"comment_content":"老师，我理解是这样，这里感觉大部分人（可能也包括老师）都弄错了，我理解的是：<br><br>对我们（普通使用者）来说，用 Promise 是因为有宏任务问题（AJAX，SetTimeout）需要解决，而专注问题解决时是不需要考虑工具（Promise）自身实现原理（微任务）的<br><br>简言之，对普通使用者来说，把 Promise 和微任务联系起来是本末倒置<br><br><br>PS：其实，如果能保证用 Promise 解决的是异步问题（宏任务&#47;微任务），那 Promise 自身实现原理也不需要微任务来“延迟绑定”（因为异步回来要 resolve 时，then 一定已经执行绑定...）","like_count":2,"discussions":[{"author":{"id":1952230,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/c9/e6/5cc0b2b4.jpg","nickname":"黯墨","note":"","ucode":"B79074735C71D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552125,"discussion_content":"前文提过，微任务是为了更好的实现延迟绑定而改造的\n\n//总结这个标题上方\n“上面采用了定时器来推迟 onResolve 的执行，不过使用定时器的效率并不是太高，好在我们有微任务，所以 Promise 又把这个定时器改造成了微任务了，这样既可以让 onResolve_ 延时被调用，又提升了代码的执行效率。这就是 Promise 中使用微任务的原由了。”\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645294439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245182,"user_name":"悠米","can_delete":false,"product_type":"c1","uid":1377073,"ip_address":"","ucode":"7669A317A34FA9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/mX9k3VNGc2mZkfTmI9zia209EugGkpFyLXl8ia1HcnhJCrAsoJ2UliaHQaeDjKOkoCaQOia6iaoj1Dkv3gZqsONlaMg/132","comment_is_top":false,"comment_ctime":1598858432,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5893825728","product_id":100033601,"comment_content":"老师，手写 Promise 什么时候会有？非常期待~","like_count":1},{"had_liked":false,"id":243532,"user_name":"旗鼓相当的对手","can_delete":false,"product_type":"c1","uid":2007774,"ip_address":"","ucode":"D80BE6E12FF2CE","user_header":"https://static001.geekbang.org/account/avatar/00/1e/a2/de/84f2754d.jpg","comment_is_top":false,"comment_ctime":1598172167,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5893139463","product_id":100033601,"comment_content":"<br>function Bromise(executor) {<br>    var onResolve_ = null;<br>    var onReject_ = null;<br>    var self = this;<br>    this.then = function (onResolve) {<br>        onResolve_ = onResolve<br>        &#47;&#47; 每次都返回自身，完成穿透<br>        return self;<br>    };<br>    this.catch = function(onReject){<br>        onReject_ = onReject;<br>    };<br>    function resolve(value) {<br>          &#47;&#47;setTimeout(()=&gt;{<br>              onResolve_(value);<br>          &#47;&#47;},0);<br>    }<br>    function reject(err){<br>          &#47;&#47;setTimeout(()=&gt;{<br>              onReject_(err);<br>          &#47;&#47;});<br>    }<br>    executor(resolve, reject);<br>}","like_count":0},{"had_liked":false,"id":159590,"user_name":"任振鹏","can_delete":false,"product_type":"c1","uid":1385329,"ip_address":"","ucode":"D33DC7856947D6","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/71/57c16ecb.jpg","comment_is_top":false,"comment_ctime":1575696324,"is_pvip":false,"replies":[{"id":"60979","content":"微任务也可以不触发渲染操作，也可以出发渲染操作！<br><br>比如你也可以在微任务中通过js来修改dom，触发重绘，重排等动作！<br><br>你也可以在微任务中执行一些逻辑运算，这就和页面渲染没有关系了！","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1575701901,"ip_address":"","comment_id":159590,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5870663620","product_id":100033601,"comment_content":"老师 渲染流水线 在 微任务 之前 还是 之后 执行啊？","like_count":1,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477110,"discussion_content":"微任务也可以不触发渲染操作，也可以出发渲染操作！\n\n比如你也可以在微任务中通过js来修改dom，触发重绘，重排等动作！\n\n你也可以在微任务中执行一些逻辑运算，这就和页面渲染没有关系了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575701901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154384,"user_name":"胖虎","can_delete":false,"product_type":"c1","uid":1206158,"ip_address":"","ucode":"2A3D72C6F38980","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/8e/14f06610.jpg","comment_is_top":false,"comment_ctime":1574419603,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869386899","product_id":100033601,"comment_content":"&quot;回调函数返回值穿透到最外层&quot; 这句话配合老师您讲的例子是错误的  return x2  这个x2按照您那种方式没办法返回到最外层  最外层的x2和里面函数return 出来的x2根本就是两个东西","like_count":1},{"had_liked":false,"id":138455,"user_name":"Rapheal","can_delete":false,"product_type":"c1","uid":1636368,"ip_address":"","ucode":"71BCD0F9131EF2","user_header":"","comment_is_top":false,"comment_ctime":1570254595,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5865221891","product_id":100033601,"comment_content":"自己手写了一个_Promise,运行老师上面的程序，没啥毛病。除了使用宏任务，可以解决嵌套和参数穿透问题。<br><br><br>var _Promise = (function () {<br>    <br>    &#47;*使用闭包 保存所有的回调函数 *&#47; <br>    var _resolve = [];<br>    var _reject = [];<br>    var _catch;<br><br>    return function (executor) {<br><br>        this.print = function () {<br>            console.log(_resolve)<br>            console.log(_catch)<br><br>        }<br>        this.then = function (resolve, reject) {<br>            resolve &amp;&amp; _resolve.push(resolve);<br>            reject &amp;&amp; _reject.push(reject);<br>            return this;<br>        }<br><br>        this.resolve = function (data) {<br>            setTimeout(function () {<br>                let callback = _resolve.shift();<br>                let pro;<br>                callback &amp;&amp; (pro = callback(data));<br>                _reject.shift();<br><br>            }, 0)<br>        }<br><br>        this.reject = function (error) {<br>            setTimeout(function () {<br>                let callback = _reject.shift();<br>                callback &amp;&amp; callback(error);<br>                callback || _catch(error);<br><br>            }, 0);<br>        }<br><br>        this.catch = function (callback) {<br>            _catch = callback;<br>            return this;<br>        }<br>        executor(this.resolve, this.reject);<br>    }<br>})()<br><br>function executor(resolve, reject) {<br>    let rand = Math.random();<br>    console.log(1)<br>    console.log(rand)<br>    if (rand &gt; 0.5)<br>        resolve(rand)<br>    else<br>        reject(rand)<br>}<br>var p0 = new _Promise(executor);<br><br>var p1 = p0.then((value) =&gt; {<br>    console.log(&quot;succeed-1&quot;)<br>    return new _Promise(executor)<br>})<br><br>var p3 = p1.then((value) =&gt; {<br>    console.log(&quot;succeed-2&quot;)<br>    return new _Promise(executor)<br>})<br><br>var p4 = p3.then((value) =&gt; {<br>    console.log(&quot;succeed-3&quot;)<br>    return new _Promise(executor)<br>})<br><br>p4.catch((error) =&gt; {<br>    console.log(&quot;error&quot;)<br>})<br><br><br>console.log(2)<br>","like_count":2},{"had_liked":false,"id":133897,"user_name":"Chao","can_delete":false,"product_type":"c1","uid":1108745,"ip_address":"","ucode":"DD7742F5537521","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/09/ba5f0135.jpg","comment_is_top":false,"comment_ctime":1568692108,"is_pvip":false,"replies":[{"id":"51384","content":"有，现在写稿子时间紧，等我主要稿件写完会抽出大把时间来专门解答问题。","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1568707565,"ip_address":"","comment_id":133897,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5863659404","product_id":100033601,"comment_content":"老师 你有答疑环节吗","like_count":1,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467548,"discussion_content":"有，现在写稿子时间紧，等我主要稿件写完会抽出大把时间来专门解答问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568707565,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1046304,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f7/20/e2dfa9c2.jpg","nickname":"花儿与少年","note":"","ucode":"E2D685737E4F1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":15858,"discussion_content":"答疑是不是可以以视频的形式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568856711,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318184,"user_name":"撒哈拉","can_delete":false,"product_type":"c1","uid":1608406,"ip_address":"","ucode":"2F64B26543D772","user_header":"https://static001.geekbang.org/account/avatar/00/18/8a/d6/00cf9218.jpg","comment_is_top":false,"comment_ctime":1635175750,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635175750","product_id":100033601,"comment_content":"promise 为了解决嵌套调用，我理解。 为了解决成功和错误多次处理我是没想到的 ","like_count":0},{"had_liked":false,"id":294708,"user_name":"袭","can_delete":false,"product_type":"c1","uid":1077573,"ip_address":"","ucode":"D5B8609CDFB145","user_header":"https://static001.geekbang.org/account/avatar/00/10/71/45/126cd913.jpg","comment_is_top":false,"comment_ctime":1622058353,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622058353","product_id":100033601,"comment_content":"延迟绑定和返回值穿透，可以理解成是提供了新的思路：原思路是嵌套处理任务结果。这种写法是先声明任务，再声明任务的返回处理流程，实际上是创造了独立性，把原来的嵌套变成了分割的两步，再用微任务把两部分连起来","like_count":0},{"had_liked":false,"id":294707,"user_name":"袭","can_delete":false,"product_type":"c1","uid":1077573,"ip_address":"","ucode":"D5B8609CDFB145","user_header":"https://static001.geekbang.org/account/avatar/00/10/71/45/126cd913.jpg","comment_is_top":false,"comment_ctime":1622057528,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622057528","product_id":100033601,"comment_content":"1.因为需要提供resolve函数给executor,而resolve并未指名，所以需要通过微任务机制等then中绑定后再执行。<br>2.executor生成了业务相关数据，而resolve进行了返回值的返回，因此在then绑定时才明确了返回值是什么，从而实现从resolve函数穿透executor","like_count":0},{"had_liked":false,"id":291963,"user_name":"tobemaster","can_delete":false,"product_type":"c1","uid":1397191,"ip_address":"","ucode":"74F8193B7B1F1E","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/c7/15cb1d28.jpg","comment_is_top":false,"comment_ctime":1620627815,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620627815","product_id":100033601,"comment_content":"有个问题非常困惑。<br><br>const p1 = new Promise(resolve =&gt; {<br>      console.log(&#39;begin&#39;);<br>      resolve(&#39;then1&#39;);<br>    }).then(v =&gt; {<br>      console.log(v);<br>      return &#39;then2&#39;;<br>    })<br>  <br>    &#47;&#47; then 链式调用，和微任务的产生关系<br>    new Promise(resolve =&gt; {<br>      console.log(1);<br>      resolve();<br>    })<br>      .then(() =&gt; {<br>        console.log(2);<br>      })<br>      .then(() =&gt; {<br>        console.log(3);<br>      })<br>      .then(() =&gt; {<br>        console.log(4);<br>        syncSleep(1000)<br>      })<br>      .then(() =&gt; {<br>        console.log(5);<br>      })<br>  <br>    const p2 = new Promise(resolve =&gt; {<br>     <br>      resolve(p1);<br>    })<br>  <br>    p2.then(v =&gt; console.log(v));<br><br>这段代码的实际结果和我预期的不一致。<br>我的预期是<br>begin<br> 1<br>then1<br>2<br>then2<br>3<br>4<br>5<br>但是实际结果是<br>begin<br>1<br>then1<br>2<br>3<br>4<br>then2<br>5<br>主要是 P1 变成接受状态（fullfill）后，P2 究竟何时 变成接受状态，这个时机没太懂","like_count":0},{"had_liked":false,"id":289051,"user_name":"Hong","can_delete":false,"product_type":"c1","uid":1162862,"ip_address":"","ucode":"2E7FB03BFEC8F9","user_header":"https://static001.geekbang.org/account/avatar/00/11/be/6e/46a5da10.jpg","comment_is_top":false,"comment_ctime":1618833961,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1618833961","product_id":100033601,"comment_content":"看完后有点疑问，老师的结论是源码中体现的吗？比如引入微任务就是延迟绑定？<br><br>最后，我们还分析了 Promise 之所以要使用微任务是由 Promise 回调函数延迟绑定技术导致的。<br><br>如果单纯为了延迟绑定，可以通过Promise内部状态机来控制，比如下面简单的demo实现就行把文中例子跑起来，并不用微任务<br><br>&#47;&#47; Bromise实现<br>function Bromise(fn) {<br>  var state = &#39;pending&#39;;<br>  var value = null;<br><br>  function fulfill(result) {<br>    state = &#39;fulfilled&#39;;<br>    value = result;<br>  }<br><br>  function reject(reason) {<br>    state = &#39;rejected&#39;;<br>    value = reason;<br>  }<br>  <br>  fn(<br>    function(result) {<br>      fulfill(result);<br>    },<br>    function(reason) {<br>      reject(reason);<br>    }<br>  )<br><br>  this.then = function(onFulfilled, onRejected) {<br>    if (state === &#39;fulfilled&#39;) {<br>      onFulfilled(value);<br>    }<br>    if (state === &#39;rejected&#39;) {<br>      onRejected(value);<br>    }<br>  }<br>}<br><br>&#47;&#47; demo执行输出<br>function executor(resolve, reject) { resolve(100); }<br>&#47;&#47;将Promise改成我们自己的Bromsie<br>var demo = new Bromise(executor);<br>function onResolve(value) {<br>  console.log(value)<br>}<br>demo.then(onResolve)<br>&#47;&#47; 输出 100<br><br>期待老师解答","like_count":0,"discussions":[{"author":{"id":2547859,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/93/c512e343.jpg","nickname":"云销雨霁","note":"","ucode":"0F3F5867B9EC82","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389139,"discussion_content":"function executor(resolve, reject) { resolve(100); } \n你这是同步任务，如果是个异步任务呢，同步任务为什么还用 promise搞复杂了，直接同步写啊，如果是个定时器，\nfunction executor(resolve, reject) {\n  setTimeout(() => {\n    resolve(100)\n  }, 0)\n}\n执行then 的时候，你还在pending状态，你这个函数一直无法进入fulfilled，而宏任务是的缺点是会被其他宏任务阻塞，系统任务，UI渲染等，而微任务的优先级最高，能尽快改变promise状态到fullfilled或reject ，并执行onResolve方法\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629129646,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":268154,"user_name":"蜂蜜","can_delete":false,"product_type":"c1","uid":2221924,"ip_address":"","ucode":"6BFE89D3668063","user_header":"https://static001.geekbang.org/account/avatar/00/21/e7/64/c6cbf46f.jpg","comment_is_top":false,"comment_ctime":1608085594,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608085594","product_id":100033601,"comment_content":"老师请教一个问题，按照您所说的，resolve放到微任务中执行是为了满足延迟绑定回调函数，那下面这个例子：<br><br>const p = Promise.resolve(5)<br>  microTimerFunc = () =&gt; {<br>    p.then(res =&gt; {<br>\tconsole.log(res)<br>    })<br>  }<br>setTimeout(microTimerFunc, 0)<br><br>在微任务队列中执行了resolve(5),但此时并没有注册回调函数，仍然输出了5,还请老师帮忙解释一下","like_count":0},{"had_liked":false,"id":257758,"user_name":"相望于江湖","can_delete":false,"product_type":"c1","uid":1253128,"ip_address":"","ucode":"9CCB6F89F92C89","user_header":"https://static001.geekbang.org/account/avatar/00/13/1f/08/14642f9e.jpg","comment_is_top":false,"comment_ctime":1604118668,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1604118668","product_id":100033601,"comment_content":"您好，看了您的专栏，感觉收获真的很大。不想其他的一些作者，您肯定是看过源码，立足在在非常丰富的工程实践之上。我这里有几个问题，想请教下：<br>1 如何学习chrominum源码：<br>     1.1 从哪里开始起步，有什么社区论坛、资料推荐<br>     1.2 学习源码之前是否需要专门去学习一下c++的一些工程实践<br><br>2 如何将tc39提出的规范和具体实现对应上<br><br>3.本人是一名前端工程师，做过后端，如何参与到chromnuim相关的论坛、社区并作出相应的贡献。<br><br>谢谢","like_count":0,"discussions":[{"author":{"id":1154704,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9e/90/2089b670.jpg","nickname":"侯全","note":"","ucode":"67EC06A53B2905","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350466,"discussion_content":"首先，英语要跟的上，资料 Google chromium 就能找到官方的仓库和文档，其次，C++ 肯定是跑不掉的，肯定要会，甚至是熟练，第2点，去看规范啊，按照规范写 demo 断点调试 chromium 不就对上了么！第3点，找点第一点的官方文档后，各种 email list ，google group，bug report 等都可以参与啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613887141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252139,"user_name":"林浩","can_delete":false,"product_type":"c1","uid":1375777,"ip_address":"","ucode":"266C06165AFA47","user_header":"https://static001.geekbang.org/account/avatar/00/14/fe/21/df75ca94.jpg","comment_is_top":false,"comment_ctime":1602142338,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602142338","product_id":100033601,"comment_content":"饿了,等待老师手写promise 加餐篇","like_count":0},{"had_liked":false,"id":235665,"user_name":"Geek_bb5943","can_delete":false,"product_type":"c1","uid":1618923,"ip_address":"","ucode":"E7380ADCC98CB1","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIBUFdN3p3KvwsAeYltGbenNFPmIJ1tdXVGkVkkibKs1n12Brd1iae5BNXnW8HKSYX8bTtSqrpeuJUw/132","comment_is_top":false,"comment_ctime":1595142340,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595142340","product_id":100033601,"comment_content":"我记得实现是通过异步队列去实现的，区分了nodejs端和浏览器端，不知道有没有说对？","like_count":0},{"had_liked":false,"id":229775,"user_name":"Kite","can_delete":false,"product_type":"c1","uid":1374421,"ip_address":"","ucode":"9DACE8E0EC84A6","user_header":"https://static001.geekbang.org/account/avatar/00/14/f8/d5/fd04fcbc.jpg","comment_is_top":false,"comment_ctime":1593142177,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593142177","product_id":100033601,"comment_content":"使用 setTimeout 将任务放到延迟任务队列中进行延迟执行","like_count":0},{"had_liked":false,"id":225310,"user_name":"江谢木","can_delete":false,"product_type":"c1","uid":1563403,"ip_address":"","ucode":"E1B1B0F0F03D41","user_header":"https://static001.geekbang.org/account/avatar/00/17/db/0b/f0ded153.jpg","comment_is_top":false,"comment_ctime":1591712074,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591712074","product_id":100033601,"comment_content":"老师，既然微任务是为了解决实时性和效率平衡问题的，那么在promise 中封装异步任务，只是改变了编程风格并没有发挥微任务的作用，因为promise 中执行的异步任务，如setTimeout\\XMLHttpRequest等还是会触发宏任务，在再宏任务中执行reject&#47;resolve触发微任务。所以，我想是否存在新的API异步任务，会直接触发微任务，而无需借助宏任务，如fetch。希望老师解答，谢谢。","like_count":0},{"had_liked":false,"id":225171,"user_name":"james","can_delete":false,"product_type":"c1","uid":1232771,"ip_address":"","ucode":"AC42035106E5B9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/yyibGRYCArsUNBfCAEAibua09Yb9D5AdO8TkCmXymhAepibqmlz0hzg06ggBLxyvXicnjqFVGr7zYF0rQoZ0aXCBAg/132","comment_is_top":false,"comment_ctime":1591672994,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1591672994","product_id":100033601,"comment_content":"1、Promise 中为什么要引入微任务？<br><br>由于promise采用.then延时绑定回调机制，而new Promise时又需要直接执行promise中的方法，即发生了先执行方法后添加回调的过程，此时需等待then方法绑定两个回调后才能继续执行方法回调，便可将回调添加到当前js调用栈中执行结束后的任务队列中，由于宏任务较多容易堵塞，则采用了微任务<br><br>2、Promise 中是如何实现回调函数返回值穿透的？<br>首先Promise的执行结果保存在promise的data变量中，然后是.then方法返回值为使用resolved或rejected回调方法新建的一个promise对象，即例如成功则返回new Promise（resolved），将前一个promise的data值赋给新建的promise<br><br>3、Promise 出错后，是怎么通过“冒泡”传递给最后那个捕获<br>promise内部有onResolvedCallback和onRejectedCallback数组来保存成功和失败的回调，进入.then（resolved，rejected）时会判断rejected参数是否为函数，若是函数，错误时使用rejected处理错误；若不是或者没传入，则会默认创建个函数来抛出捕获的错误，一直传递到最后的捕获，若最后没有被捕获，则会报错。可通过监听unhandledrejection事件捕获未处理的promise错误","like_count":0},{"had_liked":false,"id":203160,"user_name":"Coutinho","can_delete":false,"product_type":"c1","uid":1730875,"ip_address":"","ucode":"5D52969F8FB3DA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/69/3b/7111598b.jpg","comment_is_top":false,"comment_ctime":1586145926,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586145926","product_id":100033601,"comment_content":"您好！<br>请问绑定onResolve_的过程是先执行then的微任务进行绑定，然后再执行微任务进行onResoleve的调用吗？<br>","like_count":0},{"had_liked":false,"id":182501,"user_name":"大前端洞见","can_delete":false,"product_type":"c1","uid":1010463,"ip_address":"","ucode":"1FA227A25F6056","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/1f/f7be5246.jpg","comment_is_top":false,"comment_ctime":1582797365,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582797365","product_id":100033601,"comment_content":"最近学习了一下 Promise 源码，源码还是有些绕的，需要仔细理解。https:&#47;&#47;github.com&#47;giscafer&#47;front-end-manual&#47;issues&#47;37","like_count":0},{"had_liked":false,"id":155948,"user_name":"lisiur","can_delete":false,"product_type":"c1","uid":1201350,"ip_address":"","ucode":"CEB2DBCE29CAA7","user_header":"https://static001.geekbang.org/account/avatar/00/12/54/c6/c2481790.jpg","comment_is_top":false,"comment_ctime":1574781342,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574781342","product_id":100033601,"comment_content":"then函数为什么延时绑定就需要在微任务里执行resolve？先将结果保存下来，什么时候调用then函数时就把结果抛出去不行吗？","like_count":0},{"had_liked":false,"id":153772,"user_name":"江谢木","can_delete":false,"product_type":"c1","uid":1563403,"ip_address":"","ucode":"E1B1B0F0F03D41","user_header":"https://static001.geekbang.org/account/avatar/00/17/db/0b/f0ded153.jpg","comment_is_top":false,"comment_ctime":1574305294,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574305294","product_id":100033601,"comment_content":"老师，文中用promise重构XFetch代码中，resolve接收了两个参数，第二个参数this的作用是什么，没看懂，希望老师解答下。","like_count":0},{"had_liked":false,"id":150470,"user_name":"Geek_6b0898","can_delete":false,"product_type":"c1","uid":1628484,"ip_address":"","ucode":"3C2C89FE432097","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL7KMU6r5CquSI5kQlcaLuwph9HCSWcClT0YSmbon1Vov5ZcJpOCrc8WHEbfLrxbFedTjsEWuhgiaw/132","comment_is_top":false,"comment_ctime":1573541760,"is_pvip":false,"replies":[{"id":"57886","content":"快了，快了，最近家里小孩生病住院，折腾了好久，刚出院！","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1573554740,"ip_address":"","comment_id":150470,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573541760","product_id":100033601,"comment_content":"想问下老师什么时候给加餐课？支持老师尽快出啊","like_count":0,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474170,"discussion_content":"快了，快了，最近家里小孩生病住院，折腾了好久，刚出院！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573554740,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147013,"user_name":"凭实力写bug","can_delete":false,"product_type":"c1","uid":1235611,"ip_address":"","ucode":"6F772551F18935","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/9b/e0ef47df.jpg","comment_is_top":false,"comment_ctime":1572763777,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572763777","product_id":100033601,"comment_content":"我比较想知道promise微任务的功能是怎么实现的","like_count":0},{"had_liked":false,"id":146657,"user_name":"蓝配鸡","can_delete":false,"product_type":"c1","uid":1348738,"ip_address":"","ucode":"C79A7CA8885B7C","user_header":"https://static001.geekbang.org/account/avatar/00/14/94/82/d0a417ba.jpg","comment_is_top":false,"comment_ctime":1572595646,"is_pvip":false,"replies":[{"id":"56709","content":"mac下的keynote","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1572615167,"ip_address":"","comment_id":146657,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572595646","product_id":100033601,"comment_content":"请问老师你用的什么工具画图？ ","like_count":0,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472959,"discussion_content":"mac下的keynote","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572615167,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136005,"user_name":"tick","can_delete":false,"product_type":"c1","uid":1106123,"ip_address":"","ucode":"D2C864306C06CB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKOASyV1lpdkW6It8WQltNGj9021PTibqOwRUTccaSUEM1GmQThOTIRp9Eu7XNZZFfGGNveLbUSw9Q/132","comment_is_top":false,"comment_ctime":1569326781,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569326781","product_id":100033601,"comment_content":"Bromise实现的then是不是不太对，then是要有返回Promise的，我理解Promise对吧？","like_count":0},{"had_liked":false,"id":134867,"user_name":"柒月","can_delete":false,"product_type":"c1","uid":1371240,"ip_address":"","ucode":"839A8F88C376A3","user_header":"https://static001.geekbang.org/account/avatar/00/14/ec/68/06d59613.jpg","comment_is_top":false,"comment_ctime":1568944239,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568944239","product_id":100033601,"comment_content":"很棒，那个Bromise的代码绕了半天总算看明白了","like_count":0},{"had_liked":false,"id":134625,"user_name":"李懂","can_delete":false,"product_type":"c1","uid":1330436,"ip_address":"","ucode":"539E6639042C88","user_header":"https://static001.geekbang.org/account/avatar/00/14/4d/04/5e0d3713.jpg","comment_is_top":false,"comment_ctime":1568881639,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1568881639","product_id":100033601,"comment_content":"问个问题，看了好多库发送一个请求new XMLHttpRequest（），咋不使用单例，发送请求共用一个或者请求对象池！","like_count":0,"discussions":[{"author":{"id":1319638,"avatar":"https://static001.geekbang.org/account/avatar/00/14/22/d6/9378f4d5.jpg","nickname":"隔夜果酱","note":"","ucode":"5AFEB62E832BCB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":17089,"discussion_content":"个人感觉如果公用一个XMLHttpRequest实例,\n那每次构建请求时都要重置实例上的各种设置,比如onError,timeout之类的,\n如果不重置可能引起很难测试的bug.所以每次都用新实例多好.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568946431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134505,"user_name":"花儿与少年","can_delete":false,"product_type":"c1","uid":1046304,"ip_address":"","ucode":"E2D685737E4F1B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/20/e2dfa9c2.jpg","comment_is_top":false,"comment_ctime":1568856634,"is_pvip":false,"replies":[{"id":"51556","content":"会的，可以把你的问题列出来，我答疑时会有针对性","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1568857675,"ip_address":"","comment_id":134505,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568856634","product_id":100033601,"comment_content":"老师会在加班课里给大家讲解典型课后思考题吗","like_count":0,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467778,"discussion_content":"会的，可以把你的问题列出来，我答疑时会有针对性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568857675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134397,"user_name":"mfist","can_delete":false,"product_type":"c1","uid":1373624,"ip_address":"","ucode":"4F99F422C23FB4","user_header":"https://static001.geekbang.org/account/avatar/00/14/f5/b8/9f165f4b.jpg","comment_is_top":false,"comment_ctime":1568818764,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568818764","product_id":100033601,"comment_content":"1. Promise中为什么要引入微任务？ 因为promise的resolve和reject回调采用延时绑定机制，宏任务粒度太大所以引入微任务<br>2. Promise中如何实现回调函数返回值穿越的？在then中返回一个新的promise<br>3. Promise出错后是怎么通过冒泡传递给最后那个捕获异常的函数？出错后通过包装成promise.reject形式返回，如果then中没有第二个参数处理异常，则继续返回promise.reject的promise，直到被处理<br><br>今日总结<br>Promise的产生主要是为了解决回调地狱问题，然后从异步编程的代码不连续问题；到封装异步代码，让处理流程变的线性；在复杂情况下引出了嵌套调用、任务不确定性两个问题。Promise通过实现函数的延时绑定和回调函数的返回值穿透到最外面来解决上面问题。","like_count":0},{"had_liked":false,"id":134362,"user_name":"袋袋","can_delete":false,"product_type":"c1","uid":1551852,"ip_address":"","ucode":"C1F5AE7699B28A","user_header":"https://static001.geekbang.org/account/avatar/00/17/ad/ec/776c9f72.jpg","comment_is_top":false,"comment_ctime":1568813164,"is_pvip":false,"replies":[{"id":"51516","content":"微任务是v8来实现的，具体实现方式等我课程录完来手写一个Promise。<br>","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1568818804,"ip_address":"","comment_id":134362,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568813164","product_id":100033601,"comment_content":"老师，最后说定时器的效率不高，promise又把定时器改造成了微任务，可以说下具体是怎么改造的吗","like_count":1,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467717,"discussion_content":"微任务是v8来实现的，具体实现方式等我课程录完来手写一个Promise。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568818804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134011,"user_name":"Lin","can_delete":false,"product_type":"c1","uid":1233903,"ip_address":"","ucode":"ABC88EC5DDD660","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/ef/46f2fd89.jpg","comment_is_top":false,"comment_ctime":1568719070,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568719070","product_id":100033601,"comment_content":"promise 的 resolve 不仅仅是延迟绑定吧？ 如果用上述带有 setTimeout Bromise ，但是我在 then 语句的调用上加一个  setTimeout，<br>function executor(resolve, reject) {<br>    resolve(100)<br>}<br>&#47;&#47; 将 Promise 改成我们自己的 Bromsie<br>let demo2 = new Bromise(executor)<br><br>function onResolve(value){<br>    console.log(value)<br>}<br>setTimeout(() =&gt; { demo2.then(onResolve) }, 500)<br>也是会报错的:<br>Uncaught TypeError: onResolve_ is not a function<br>    at &lt;anonymous&gt;:10:13<br><br>所以 promise 的then采用的是延迟绑定加 cache 吧， resolve 调用的时候他应该还会判断一下 onResolve 函数是否存在?<br>","like_count":0},{"had_liked":false,"id":133920,"user_name":"Will","can_delete":false,"product_type":"c1","uid":1161437,"ip_address":"","ucode":"BB78C2B9B44D36","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/dd/d729557f.jpg","comment_is_top":false,"comment_ctime":1568698599,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1568698599","product_id":100033601,"comment_content":"请问老师，promise和Rxjs有关系吗？","like_count":0,"discussions":[{"author":{"id":1010463,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6b/1f/f7be5246.jpg","nickname":"大前端洞见","note":"","ucode":"1FA227A25F6056","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":188116,"discussion_content":"没有。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582797213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133845,"user_name":"vividlipi","can_delete":false,"product_type":"c1","uid":1168991,"ip_address":"","ucode":"92E708BBF0DF9D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLIpicRcvnmGNAfxuiaFdzIjR2FecqU5IS6KAZ5MS57sGybHxcraxCoUqaERl3kF2JvfHPrAgTqs1cQ/132","comment_is_top":false,"comment_ctime":1568683210,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568683210","product_id":100033601,"comment_content":"x.then().then().then().catch(); <br>猜测then可能在执行onResolve之前会判断一下","like_count":0}]}