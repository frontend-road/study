{"id":496702,"title":"10｜TDD中的驱动（3）：何为经典学派？何为伦敦学派？","content":"<p>你好，我是徐昊。今天我们继续来讨论测试驱动开发中的驱动。</p><p>上节课我们讲了四种常用的重构手法，分别是提取方法、内联方法、引入参数和引入字段。并区分了用于高效修改代码的重构手法，和用于消除坏味道以改进架构设计的重构。还介绍了一种架构软件的方法：重构到模式。也就是通过重构将坏味道替换为模式，从而改进软件架构的方式。</p><p>重构到模式，或者说TDD 红/绿/重构循环中的重构，是在完成功能的前提下以演进的方式进行设计。这是延迟性决策策略，也叫<strong>最晚尽责时刻</strong>（Last Responsible Moment，LRM）。也就是说，与其在信息不足的情况下做决定，不如延迟到信息更多，或是不得不做出决策的时机再决策。这种策略的重点在于，在保持决策有效性的前提下，尽可能地推迟决策时间。</p><p>如果架构愿景不清晰，那么“<strong>最晚尽责时刻”<strong>让我们不必花费时间进行空对空的讨论，可以尽早开始实现功能，再通过重构从</strong>可工作的软件</strong>（Working Software）中提取架构。这种方式也被称作TDD的经典学派（Classic School）或芝加哥学派（Chicago School）。</p><p>除了经典学派之外，还有一种TDD风格，被称作TDD的伦敦学派（London School）。如果架构愿景已经比较清晰了，那么我们就可以使用伦敦学派进行TDD。</p><!-- [[[read_end]]] --><h2>命令行解析</h2><p>伦敦学派的做法是这样的：</p><ul>\n<li>按照功能需求与架构愿景划分对象的角色和职责；</li>\n<li>根据角色与职责，明确对象之间的交互；</li>\n<li>按照调用栈（Call Stack）的顺序，自外向内依次实现不同的对象；</li>\n<li>在实现的过程中，依照交互关系，使用测试替身替换所有与被实现对象直接关联的对象；</li>\n<li>直到所有对象全部都实现完成。</li>\n</ul><p>接下来我仍然以命令行参数解析为例，演示一下如何通过伦敦学派的方式来开发它。</p><p>首先是明确我们的架构愿景，也就是对象的角色与职责划分。如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/f2/80/f227e4af9dc2712a6e4988fd57011780.jpg?wh=2291x1285\" alt=\"\"></p><p>如上图所示，在系统中一共存在四个类：作为对外API的Args，从参数列表中提取参数的ValueRetriever，将Java类对象封装为选项的OptionClass，以及根据类型和数据解析参数的OptionParser。它们的交互，也如上图所示。</p><p>在划定角色和职责之后，我们来依次实现它们。视频演示如下：</p><p><video poster=\"https://media001.geekbang.org/c3ff1c03368340b58ba758801651bfa7/snapshots/4e951595bfe549088afe4f9d6676e627-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/301cc344-17fb9ee2b98-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/95777ec3250a447caa54a51173bc17fb/85d98229be474159b9c5c0393b207583-6b646ed635f7561dd4e91a56f9b56b3b-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><h2>与经典模式的差异</h2><p>通过上面的视频展示，你能明显体会到“伦敦学派”与“经典学派”的差异：</p><ul>\n<li>经典学派强调功能优先，设计/架构后置，通过重构进行演进式设计。</li>\n<li>而“伦敦学派”并不排斥预先存在的设计，更强调如何通过测试替身，将注意力集中到功能上下文中的某个对象上。然后在测试的驱动下，按部就班地完成功能开发。</li>\n</ul><p>然而<strong>二者其实并没有什么冲突</strong>。回顾一下第八讲的演示，以及本节课介绍伦敦学派时的演示，你会发现二者有相似之处：都不是将功能整体作为单元的粒度，而是选择了更小的范围。所不同的仅仅在于，在本节课中，我们更为细致地划分了功能上下文（也就是做了更多的设计）。</p><p>所以我们可以将伦敦学派看作<strong>一种利用架构愿景分割功能上下文，然后再进入经典模式的TDD方法</strong>。这么做的好处是，对于复杂的场景，可以极大简化构造测试的时间。下面让我们看一个例子：</p><p><video poster=\"https://media001.geekbang.org/ac822f20f57c4f67ba0f524852c297f8/snapshots/7bca72087f07443595ae76d365bd200a-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/23728d01-17fb9ee286d-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/7eea68126969471baa5caf644e6f6de4/7dbb747192e34fd5b5e45b1b0c5eb9fd-df31229a789459062e9ab54a747b0b5e-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><p>在这个例子里，我们可以通过重构去获得想要的架构，比如提取出Repository等。但是，以经典学派构造测试过于麻烦，而如果以伦敦学派开始就可以简单很多：</p><p><video poster=\"https://media001.geekbang.org/8cd3bc1858bd4875aede8106a2b476ef/snapshots/874da6d9e557454c8106eb5d8308b144-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/4a1d80ce-17fcf8ba383-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/2ceac31674344360ab4d6f5ed0d60f64/44e3ad3f30804cbe9776dd6db3fd5c70-672702cf61f5f9503c29817c20887176-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><p>需要提醒一下，经典学派和伦敦学派是TDD中都需要掌握的基本功。在功能上下文内，以经典学派为主；而跨功能上下文时，可以使用伦敦学派对不同的功能上下文进行隔离。</p><p>顺便说一句，曾经有一段时间，TDD社区内将这两种风格对立起来：</p><ul>\n<li>经典学派质疑伦敦学派向预先设计妥协，放弃了演进式架构。</li>\n<li>伦敦学派攻击经典学派不愿吸收借鉴行业积累，“难道每次都要从一个大类重构到MVC吗？”</li>\n</ul><p>然而这种分歧是无意义的。在不同的场合下，我们只需要使用该用的方式就好。</p><h2>小结</h2><p>通过第8-10这三节课，我们讨论了测试驱动中的驱动。也回答了测试驱动到底能够驱动什么：<strong>单元级别功能测试能够驱动其对应单元（功能上下文或变化点）的功能需求</strong>。而对于单元之内某个功能的实现，则无能为力。</p><p>从“驱动”的角度来说，TDD实际上并不是一种编码技术，更像是一种架构技术，它可以帮助你更好地将功能放置到不同的单元。于是我们继续介绍了TDD中两种处理架构的思路：延迟性决策的经典学派和通过架构愿景划分功能上下文的伦敦学派。</p><p>至此，我们已经对测试驱动开发有了较深入的了解，知道了什么样的测试，提供什么样的驱动。那么下节课，让我们看看测试驱动开发的全貌。</p><h2>思考题</h2><p>在伦敦学派中，是如何保证测试的有效性的？</p><p><strong>编辑来信</strong>：</p><blockquote>\n<p>TDD是一项技能，唯有动手实操、反复练习，才能有所小成。为了帮助你更快地进步，徐昊老师特发起了<strong>“代码评点”</strong>活动。<br>\n<strong>　</strong><br>\n在第一个实战项目结束后，我们会根据你提交的<a href=\"https://jinshuju.net/f/TvdN15\">学习反馈</a>，手动选出其中几位进行代码评点与解疑答惑。而评点的详细内容我们也将制成加餐，展示在专栏里，供其他同学学习与参考。<br>\n<strong>　</strong><br>\n划重点！如果学完第1-10讲再写反馈，将会大大提高你入选的机会！另，此次收集时间截至4月3日零点。所以非常希望你能跟上我们的更新进度，多动手实操，并记录学习体会。<br>\n<strong>　</strong><br>\n最后，希望我们都能好好学习，更上层楼！</p>\n</blockquote>","neighbors":{"left":{"article_title":"09｜TDD中的驱动（2）：重构发挥了什么作用？","id":496701},"right":{"article_title":"11｜作为工程化方法的TDD：更低的成本与更高的效能","id":496703}},"comments":[{"had_liked":false,"id":342299,"user_name":"汗香","can_delete":false,"product_type":"c1","uid":1807921,"ip_address":"","ucode":"8F2C8A595F888A","user_header":"https://static001.geekbang.org/account/avatar/00/1b/96/31/91cc9c3c.jpg","comment_is_top":false,"comment_ctime":1650180750,"is_pvip":false,"replies":[{"id":"125054","content":"驱动controller的时候 double service 驱动service的时候 double dao","user_name":"作者回复","user_name_real":"编辑","uid":"2537798","ctime":1650184165,"ip_address":"","comment_id":342299,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5945148046","product_id":100109401,"comment_content":"我认为保证测试有效性有两点：<br>1、不能对待测方法的实现使用测试替身，可以对测试方法调用的外部组件使用测试替身<br>2、不能行为验证绑定到实现方法的内部<br><br>另外我有个问题，最后一个视频演示的是 Controller -&gt; Dao 的场景，这种直接对 Dao 使用测试替身，这种方法毋庸置疑，但如果是多层构架，如 Controller -&gt; Service -&gt; Dao ，那么我们在测 Controller 时应该是对 Dao 使用测试替身还对 Service 使用测试替身","like_count":1,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564192,"discussion_content":"驱动controller的时候 double service 驱动service的时候 double dao","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650184165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":349208,"user_name":"SochiLee","can_delete":false,"product_type":"c1","uid":1537865,"ip_address":"","ucode":"47596594EDF4D7","user_header":"https://static001.geekbang.org/account/avatar/00/17/77/49/445eea2d.jpg","comment_is_top":false,"comment_ctime":1655799022,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655799022","product_id":100109401,"comment_content":"古典学派到底是叫芝加哥学派还是底特律学派呀？《Mocks Aren&#39;t Stubs》中说古典学派叫底特律学派。","like_count":0},{"had_liked":false,"id":346448,"user_name":"姑射仙人","can_delete":false,"product_type":"c1","uid":1008517,"ip_address":"","ucode":"3EFC1F3E592165","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/85/1dc41622.jpg","comment_is_top":false,"comment_ctime":1653142383,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653142383","product_id":100109401,"comment_content":"在伦敦学派中，是如何保证测试的有效性的？<br><br>状态验证","like_count":1},{"had_liked":false,"id":344919,"user_name":"zenk","can_delete":false,"product_type":"c1","uid":1013669,"ip_address":"","ucode":"B235D5EBCF49BC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/77/a5/c5ae871d.jpg","comment_is_top":false,"comment_ctime":1651857242,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1651857242","product_id":100109401,"comment_content":"在伦敦学派中，是如何保证测试的有效性的？<br><br>架构愿景清晰，保证可以构造稳定的测试替身，进而保证测试的有效性。","like_count":0},{"had_liked":false,"id":344489,"user_name":"davix","can_delete":false,"product_type":"c1","uid":1074465,"ip_address":"","ucode":"CBFB39BAD7938B","user_header":"https://static001.geekbang.org/account/avatar/00/10/65/21/101a7075.jpg","comment_is_top":false,"comment_ctime":1651584553,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651584553","product_id":100109401,"comment_content":"在伦敦学派中，是如何保证测试的有效性的？<br>我覺得是通過更高層的集成測試保證的。比如repository的測試要用真實數據庫","like_count":0},{"had_liked":false,"id":340433,"user_name":"wenming","can_delete":false,"product_type":"c1","uid":1023436,"ip_address":"","ucode":"A0EF1D46850017","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9d/cc/b48d3e96.jpg","comment_is_top":false,"comment_ctime":1648811031,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648811031","product_id":100109401,"comment_content":"思考题我是这么理解的：只要构造 Stub 的时候不对 SUT 的结果产生影响，也就是说，Stub 的存在不会改变测试的效果，只是我们构建夹具（测试上下文）的形式或者说方法有区别，那么整个测试的有效性就能够得到保证","like_count":0},{"had_liked":false,"id":340311,"user_name":"邓志国","can_delete":false,"product_type":"c1","uid":1043844,"ip_address":"","ucode":"380AE67ED7B9D7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/84/0b8e2d25.jpg","comment_is_top":false,"comment_ctime":1648736195,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648736195","product_id":100109401,"comment_content":"保证测试有效，就得用足够好的测试替身。","like_count":0},{"had_liked":false,"id":340224,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1648685363,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648685363","product_id":100109401,"comment_content":"测试入参：伦敦学派中通过“Mock 外层”返回了当前需要的数据，测试时隔离了对外层的依赖，降低了构造测试的难度。<br>功能验证：使用状态验证<br>伦敦学派通过“Mock 外层”返回了当前需要的数据，本层功能依然使用状态验证，所以可以保证测试的有效性。<br><br>08 09 10 学习笔记 http:&#47;&#47;wyyl1.com&#47;post&#47;19&#47;06&#47;","like_count":0},{"had_liked":false,"id":340151,"user_name":"枫中的刀剑","can_delete":false,"product_type":"c1","uid":1322387,"ip_address":"","ucode":"4B086F538184AA","user_header":"https://static001.geekbang.org/account/avatar/00/14/2d/93/0f1cbf44.jpg","comment_is_top":false,"comment_ctime":1648630355,"is_pvip":false,"replies":[{"id":"124382","content":"引入测试替身之后 可以验证更大范围","user_name":"作者回复","user_name_real":"编辑","uid":"2537798","ctime":1648632876,"ip_address":"","comment_id":340151,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1648630355","product_id":100109401,"comment_content":"对于伦敦学派，根据第5、6章节的内容，也是主要是通过状态校验来保证测试的有效性。但是有个疑惑点是对于伦敦学派，采用状态验证的方式只能保证单个sut的有效性，而对于更大的功能上下文的有效性是应该没法保证的，所以对于完整功能的有效性验证就只能通过更大的端到端测试来保证吗？","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559168,"discussion_content":"引入测试替身之后 可以验证更大范围","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648632877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}