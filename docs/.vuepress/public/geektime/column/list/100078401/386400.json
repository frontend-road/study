{"id":386400,"title":"19 | 土地不能浪费：如何管理内存对象？","content":"<p>你好，我是LMOS。</p><p>在前面的课程中，我们建立了物理内存页面管理器，它既可以分配单个页面，也可以分配多个连续的页面，还能指定在特殊内存地址区域中分配页面。</p><p>但你发现没有，物理内存页面管理器一次分配至少是一个页面，而我们对内存分页是一个页面4KB，即4096字节。对于小于一个页面的内存分配请求，它无能为力。如果要实现小于一个页面的内存分配请求，又该怎么做呢？</p><p>这节课我们就一起来解决这个问题。课程配套代码，你可以从<a href=\"https://gitee.com/lmos/cosmos/tree/master/lesson19~21/Cosmos\">这里</a>获得。</p><h2>malloc给我们的启发</h2><p>首先，我想和你说说，为什么小于一个页面的内存我们也要格外珍惜？</p><p>如果你在大学学过C程序设计语言的话，相信你对C库中的malloc函数也不会陌生，它负责完成分配一块内存空间的功能。</p><p>下面的代码。我相信你也写过，或者写过类似的，不用多介绍你也可以明白。</p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt; \n#include &lt;stdlib.h&gt;   \nint main() {    \n    char *str;      \n    //内存分配 存放15个char字符类型   \n    str = (char *) malloc(15);\n    if (str == NULL) {\n        printf(&quot;mem alloc err\\n&quot;);\n        return -1;\n    }\n    //把hello world字符串复制到str开始的内存地址空间中\n    strcpy(str, &quot;hello world&quot;);\n    //打印hello world字符串和它的地址    \n    printf(&quot;String = %s,  Address = %u\\n&quot;, str, str);\n    //释放分配的内存\n    free(str);      \n    return(0); \n}\n</code></pre><p>这个代码流程很简单，就是分配一块15字节大小的内存空间，然后把字符串复制到分配的内存空间中，最后用字符串的形式打印了那个块内存，最后释放该内存空间。</p><p>但我们并不是要了解malloc、free函数的工作原理，而是要清楚，像这样分配几个字节内存空间的操作，这在内核中比比皆是。</p><h2>页还能细分吗</h2><p>是的，单从内存角度来看，页最小是以字节为单位的。但是从MMU角度看，内存是以页为单位的，所以我们的Cosmos的物理内存分配器也以页为单位。现在的问题是，内核中有大量远小于一个页面的内存分配请求，如果对此还是分配一个页面，就会浪费内存。</p><!-- [[[read_end]]] --><p>要想解决这个问题，<strong>就要细分“页”这个单位</strong>。虽然从MMU角度来看，页不能细分，但是从软件逻辑层面页可以细分，但是如何分，则十分讲究。</p><p>结合历史经验和硬件特性（Cache行大小）来看，我们可以把一个页面或者连续的多个页面，分成32字节、64字节、128字节、256字节、512字节、1024字节、2048字节、4096字节（一个页）。这些都是Cache行大小的倍数。我们给这些小块内存取个名字，叫<strong>内存对象</strong>。</p><p>我们可以这样设计：<strong>把一个或者多个内存页面分配出来，作为一个内存对象的容器，在这个容器中容纳相同的内存对象，即同等大小的内存块。</strong>你可以把这个容器，想像成一个内存对象数组。为了让你更好理解，我还给你画了张图解释。</p><p><img src=\"https://static001.geekbang.org/resource/image/a9/47/a9e3c059aceb3433de2116f9bee02d47.jpg?wh=5160x3099\" alt=\"\" title=\"内存对象视图\"></p><h2>如何表示一个内存对象</h2><p>前面只是进行了理论上的设计和构想，下面我们就通过代码来实现这些构想，真正把想法变成现实。</p><p>我们从内存对象开始入手。如何表示一个内存对象呢？当然是要设计一个表示内存对象的数据结构，代码如下所示：</p><pre><code>typedef struct s_FREOBJH\n{\n    list_h_t oh_list;     //链表\n    uint_t oh_stus;       //对象状态\n    void* oh_stat;        //对象的开始地址\n}freobjh_t;\n</code></pre><p>我们在后面的代码中就用freobjh_t结构表示一个对象，其中的链表是为了找到这个对象。是不是很简单？没错，表示一个内存对象就是如此简单。</p><h2>内存对象容器</h2><p>光有内存对象还不够，如何放置内存对象是很重要的。根据前面的构想，为了把多个同等大小的内存对象放在一个内存对象容器中，我们需要设计出表示内存对象容器的数据结构。内存容器要占用内存页面，需要内存对象计数信息、内存对象大小信息，还要能扩展容量。</p><p>把上述功能综合起来，代码如下所示。</p><pre><code>//管理内存对象容器占用的内存页面所对应的msadsc_t结构\ntypedef struct s_MSCLST\n{\n    uint_t ml_msanr;  //多少个msadsc_t\n    uint_t ml_ompnr;  //一个msadsc_t对应的连续的物理内存页面数\n    list_h_t ml_list; //挂载msadsc_t的链表\n}msclst_t;\n//管理内存对象容器占用的内存\ntypedef struct s_MSOMDC\n{\n    //msclst_t结构数组mc_lst[0]=1个连续页面的msadsc_t\n    //               mc_lst[1]=2个连续页面的msadsc_t\n    //               mc_lst[2]=4个连续页面的msadsc_t\n    //               mc_lst[3]=8个连续页面的msadsc_t\n    //               mc_lst[4]=16个连续页面的msadsc_t\n    msclst_t mc_lst[MSCLST_MAX];\n    uint_t mc_msanr;   //总共多个msadsc_t结构\n    list_h_t mc_list;\n    //内存对象容器第一个占用msadsc_t\n    list_h_t mc_kmobinlst;\n    //内存对象容器第一个占用msadsc_t对应的连续的物理内存页面数\n    uint_t mc_kmobinpnr;\n}msomdc_t;\n//管理内存对象容器扩展容量\ntypedef struct s_KMBEXT\n{\n    list_h_t mt_list;        //链表\n    adr_t mt_vstat;          //内存对象容器扩展容量开始地址\n    adr_t mt_vend;           //内存对象容器扩展容量结束地址\n    kmsob_t* mt_kmsb;        //指向内存对象容器结构\n    uint_t mt_mobjnr;        //内存对象容器扩展容量的内存中有多少对象\n}kmbext_t;\n//内存对象容器\ntypedef struct s_KMSOB\n{\n    list_h_t so_list;        //链表\n    spinlock_t so_lock;      //保护结构自身的自旋锁\n    uint_t so_stus;          //状态与标志\n    uint_t so_flgs;\n    adr_t so_vstat;          //内存对象容器的开始地址\n    adr_t so_vend;           //内存对象容器的结束地址\n    size_t so_objsz;         //内存对象大小\n    size_t so_objrelsz;      //内存对象实际大小\n    uint_t so_mobjnr;        //内存对象容器中总共的对象个数\n    uint_t so_fobjnr;        //内存对象容器中空闲的对象个数\n    list_h_t so_frelst;      //内存对象容器中空闲的对象链表头\n    list_h_t so_alclst;      //内存对象容器中分配的对象链表头\n    list_h_t so_mextlst;     //内存对象容器扩展kmbext_t结构链表头\n    uint_t so_mextnr;        //内存对象容器扩展kmbext_t结构个数\n    msomdc_t so_mc;          //内存对象容器占用内存页面管理结构\n    void* so_privp;          //本结构私有数据指针\n    void* so_extdp;          //本结构扩展数据指针\n}kmsob_t;\n</code></pre><p>这段代码中设计了四个数据结构：kmsob_t用于表示内存对象容器，kmbext_t用于表示内存对象容器的扩展内存，msomdc_t和msclst_t用于管理内存对象容器占用的物理内存页面。</p><p>你可能很难理解它们之间的关系，所以我为你准备了一幅图，如下所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/7y/bb/7yye7013ae2a878286fc6052c9318bbb.jpg?wh=4460x3085\" alt=\"\" title=\"内存对象容器关系\"></p><p>结合图示我们可以发现，在一组连续物理内存页面（用来存放内存对象）的开始地址那里，就存放着我们kmsob_t和kmbext_t的实例变量，它们占用了几十字节的空间。</p><h2>初始化</h2><p>因为kmsob_t、kmbext_t、freobjh_t结构的实例变量，它们是建立内存对象容器时创建并初始化的，这个过程是伴随着分配内存对象而进行的，所以内存对象管理器的初始化很简单。</p><p>但是有一点还是要初始化的，那就是<strong>管理kmsob_t结构的数据结构</strong>，它用于挂载不同大小的内存容器。现在我们就在cosmos/hal/x86/目录下建立一个kmsob.c文件，来实现这个数据结构并初始化，代码如下所示。</p><pre><code>#define KOBLST_MAX (64)\n//挂载kmsob_t结构\ntypedef struct s_KOBLST\n{\n    list_h_t ol_emplst; //挂载kmsob_t结构的链表\n    kmsob_t* ol_cahe;   //最近一次查找的kmsob_t结构\n    uint_t ol_emnr;     //挂载kmsob_t结构的数量\n    size_t ol_sz;       //kmsob_t结构中内存对象的大小\n}koblst_t;\n//管理kmsob_t结构的数据结构\ntypedef struct s_KMSOBMGRHED\n{\n    spinlock_t ks_lock;  //保护自身的自旋锁\n    list_h_t ks_tclst;   //链表\n    uint_t ks_tcnr;\n    uint_t ks_msobnr;    //总共多少个kmsob_t结构\n    kmsob_t* ks_msobche; //最近分配内存对象的kmsob_t结构\n    koblst_t ks_msoblst[KOBLST_MAX]; //koblst_t结构数组\n}kmsobmgrhed_t;\n//初始化koblst_t结构体\nvoid koblst_t_init(koblst_t *initp, size_t koblsz)\n{\n    list_init(&amp;initp-&gt;ol_emplst);\n    initp-&gt;ol_cahe = NULL;\n    initp-&gt;ol_emnr = 0;\n    initp-&gt;ol_sz = koblsz;\n    return;\n}\n//初始化kmsobmgrhed_t结构体\nvoid kmsobmgrhed_t_init(kmsobmgrhed_t *initp)\n{\n    size_t koblsz = 32;\n    knl_spinlock_init(&amp;initp-&gt;ks_lock);\n    list_init(&amp;initp-&gt;ks_tclst);\n    initp-&gt;ks_tcnr = 0;\n    initp-&gt;ks_msobnr = 0;\n    initp-&gt;ks_msobche = NULL;\n    for (uint_t i = 0; i &lt; KOBLST_MAX; i++)\n    {\n        koblst_t_init(&amp;initp-&gt;ks_msoblst[i], koblsz);\n        koblsz += 32;//这里并不是按照开始的图形分类的而是每次增加32字节，所以是32，64,96,128,160,192,224，256，.......\n    }\n    return;\n}\n//初始化kmsob\nvoid init_kmsob()\n{\n    kmsobmgrhed_t_init(&amp;memmgrob.mo_kmsobmgr);\n    return;\n}\n</code></pre><p>上面的代码注释已经很清楚了，就是init_kmsob函数调用kmsobmgrhed_t_init函数，在其中循环初始化koblst_t结构体数组，不多做解释。</p><p>但是有一点我们要搞清楚：<strong>kmsobmgrhed_t结构的实例变量是放在哪里的，它其实放在我们之前的memmgrob_t结构中了</strong>，代码如下所示。</p><pre><code>//cosmos/include/halinc/halglobal.c\nHAL_DEFGLOB_VARIABLE(memmgrob_t,memmgrob);\n\ntypedef struct s_MEMMGROB\n{\n    list_h_t mo_list;\n    spinlock_t mo_lock;\n    uint_t mo_stus;\n    uint_t mo_flgs;\n    //略去很多字段\n    //管理kmsob_t结构的数据结构\n    kmsobmgrhed_t mo_kmsobmgr;\n    void* mo_privp;\n    void* mo_extp;\n}memmgrob_t;\n//cosmos/hal/x86/memmgrinit.c\nvoid init_memmgr()\n{\n    //初始化内存页结构\n    init_msadsc();\n    //初始化内存区结构\n    init_memarea();\n    //处理内存占用\n    init_search_krloccupymm(&amp;kmachbsp);\n    //合并内存页到内存区中\n    init_memmgrob();\n    //初始化kmsob\n    init_kmsob();\n    return;\n}\n</code></pre><p>这并没有那么难，是不是？到这里，我们在内存管理初始化init_memmgr函数中调用了init_kmsob函数，对管理内存对象容器的结构进行了初始化，这样后面我们就能分配内存对象了。</p><h2>分配内存对象</h2><p>根据前面的初始化过程，我们只是初始化了kmsobmgrhed_t结构，却没初始化任何kmsob_t结构，而这个结构就是存放内存对象的容器，没有它是不能进行任何分配内存对象的操作的。</p><p>下面我们一起在分配内存对象的过程中探索，应该如何查找、建立kmsob_t结构，然后在kmsob_t结构中建立freobjh_t结构，最后在内存对象容器的容量不足时，一起来扩展容器的内存。</p><h3>分配内存对象的接口</h3><p>分配内存对象的流程，仍然要从分配接口开始。分配内存对象的接口很简单，只有一个内存对象大小的参数，然后返回内存对象的首地址。下面我们先在kmsob.c文件中写好这个函数，代码如下所示。</p><pre><code>//分配内存对象的核心函数\nvoid *kmsob_new_core(size_t msz)\n{\n    //获取kmsobmgrhed_t结构的地址\n    kmsobmgrhed_t *kmobmgrp = &amp;memmgrob.mo_kmsobmgr;\n    void *retptr = NULL;\n    koblst_t *koblp = NULL;\n    kmsob_t *kmsp = NULL;\n    cpuflg_t cpuflg;\n    //对kmsobmgrhed_t结构加锁\n    knl_spinlock_cli(&amp;kmobmgrp-&gt;ks_lock, &amp;cpuflg);\n    koblp = onmsz_retn_koblst(kmobmgrp, msz);\n    if (NULL == koblp)\n    {\n        retptr = NULL;\n        goto ret_step;\n    }\n    kmsp = onkoblst_retn_newkmsob(koblp, msz);\n    if (NULL == kmsp)\n    {\n        kmsp = _create_kmsob(kmobmgrp, koblp, koblp-&gt;ol_sz);\n        if (NULL == kmsp)\n        {\n            retptr = NULL;\n            goto ret_step;\n        }\n    }\n    retptr = kmsob_new_onkmsob(kmsp, msz);\n    if (NULL == retptr)\n    {\n        retptr = NULL;\n        goto ret_step;\n    }\n    //更新kmsobmgrhed_t结构的信息\n    kmsob_updata_cache(kmobmgrp, koblp, kmsp, KUC_NEWFLG);\nret_step:\n    //解锁kmsobmgrhed_t结构\n    knl_spinunlock_sti(&amp;kmobmgrp-&gt;ks_lock, &amp;cpuflg);\n    return retptr;\n}\n//内存对象分配接口\nvoid *kmsob_new(size_t msz)\n{\n    //对于小于1 或者 大于2048字节的大小不支持 直接返回NULL表示失败\n    if (1 &gt; msz || 2048 &lt; msz)\n    {\n        return NULL;\n    }\n    //调用核心函数\n    return kmsob_new_core(msz);\n}\n</code></pre><p>上面代码中，内存对象分配接口很简单，只是对分配内存对象的大小进行检查，然后调用分配内存对象的核心函数，在这个核心函数中，就是围绕我们之前定义的几个数据结构，去进行一系列操作了。</p><p>但是究竟做了哪些操作呢，别急，我们继续往下看。</p><h3>查找内存对象容器</h3><p>根据前面的设计，我们已经知道内存对象是放在内存对象容器中的，所以要分配内存对象，必须要先根据要分配的内存对象大小，找到内存对象容器。</p><p>同时，我们还知道，内存对象容器数据结构kmsob_t就挂载在kmsobmgrhed_t数据结构中的ks_msoblst数组中，所以我们要遍历ks_msoblst数组，我们来写一个onmsz_retn_koblst函数，它返回ks_msoblst数组元素的指针，表示先根据内存对象的大小找到挂载kmsob_t结构对应的koblst_t结构。</p><pre><code>//看看内存对象容器是不是合乎要求\nkmsob_t *scan_newkmsob_isok(kmsob_t *kmsp, size_t msz)\n{    \n    //只要内存对象大小小于等于内存对象容器的对象大小就行\n    if (msz &lt;= kmsp-&gt;so_objsz)\n    {\n        return kmsp;\n    }\n    return NULL;\n}\n\nkoblst_t *onmsz_retn_koblst(kmsobmgrhed_t *kmmgrhlokp, size_t msz)\n{\n    //遍历ks_msoblst数组\n    for (uint_t kli = 0; kli &lt; KOBLST_MAX; kli++)\n    {\n        //只要大小合适就返回       \n        if (kmmgrhlokp-&gt;ks_msoblst[kli].ol_sz &gt;= msz)\n        {\n            return &amp;kmmgrhlokp-&gt;ks_msoblst[kli];\n        }\n    }\n    return NULL;\n}\n\nkmsob_t *onkoblst_retn_newkmsob(koblst_t *koblp, size_t msz)\n{\n    kmsob_t *kmsp = NULL, *tkmsp = NULL;\n    list_h_t *tmplst = NULL;\n    //先看看上次分配所用到的koblst_t是不是正好是这次需要的\n    kmsp = scan_newkmsob_isok(koblp-&gt;ol_cahe, msz);\n    if (NULL != kmsp)\n    {\n        return kmsp;\n    }\n    //如果koblst_t中挂载的kmsob_t大于0\n    if (0 &lt; koblp-&gt;ol_emnr)\n    {\n        //开始遍历koblst_t中挂载的kmsob_t\n        list_for_each(tmplst, &amp;koblp-&gt;ol_emplst)\n        {\n            tkmsp = list_entry(tmplst, kmsob_t, so_list);\n            //检查当前kmsob_t是否合乎要求\n            kmsp = scan_newkmsob_isok(tkmsp, msz);\n            if (NULL != kmsp)\n            {\n                return kmsp;\n            }\n        }\n    }\n    return NULL;\n}\n</code></pre><p>上述代码非常好理解，就是通过onmsz_retn_koblst函数，它根据内存对象大小查找并返回ks_msoblst数组元素的指针，这个数组元素中就挂载着相应的内存对象容器，然后由onkoblst_retn_newkmsob函数查询其中的内存对象容器并返回。</p><h3>建立内存对象容器</h3><p>不知道你发现没有，有一种情况必然会发生，那就是第一次分配内存对象时调用onkoblst_retn_newkmsob函数，它肯定会返回一个NULL。因为第一次分配时肯定没有kmsob_t结构，所以我们在这个时候建立一个kmsob_t结构，即<strong>建立内存对象容器</strong>。</p><p>下面我们写一个_create_kmsob函数来创建kmsob_t结构，并执行一些初始化工作，代码如下所示。</p><pre><code>//初始化内存对象数据结构\nvoid freobjh_t_init(freobjh_t *initp, uint_t stus, void *stat)\n{\n    list_init(&amp;initp-&gt;oh_list);\n    initp-&gt;oh_stus = stus;\n    initp-&gt;oh_stat = stat;\n    return;\n}\n//初始化内存对象容器数据结构\nvoid kmsob_t_init(kmsob_t *initp)\n{\n    list_init(&amp;initp-&gt;so_list);\n    knl_spinlock_init(&amp;initp-&gt;so_lock);\n    initp-&gt;so_stus = 0;\n    initp-&gt;so_flgs = 0;\n    initp-&gt;so_vstat = NULL;\n    initp-&gt;so_vend = NULL;\n    initp-&gt;so_objsz = 0;\n    initp-&gt;so_objrelsz = 0;\n    initp-&gt;so_mobjnr = 0;\n    initp-&gt;so_fobjnr = 0;\n    list_init(&amp;initp-&gt;so_frelst);\n    list_init(&amp;initp-&gt;so_alclst);\n    list_init(&amp;initp-&gt;so_mextlst);\n    initp-&gt;so_mextnr = 0;\n    msomdc_t_init(&amp;initp-&gt;so_mc);\n    initp-&gt;so_privp = NULL;\n    initp-&gt;so_extdp = NULL;\n    return;\n}\n//把内存对象容器数据结构，挂载到对应的koblst_t结构中去\nbool_t kmsob_add_koblst(koblst_t *koblp, kmsob_t *kmsp)\n{\n    list_add(&amp;kmsp-&gt;so_list, &amp;koblp-&gt;ol_emplst);\n    koblp-&gt;ol_emnr++;\n    return TRUE;\n}\n//初始化内存对象容器\nkmsob_t *_create_init_kmsob(kmsob_t *kmsp, size_t objsz, adr_t cvadrs, adr_t cvadre, msadsc_t *msa, uint_t relpnr)\n{\n    //初始化kmsob结构体\n    kmsob_t_init(kmsp);\n    //设置内存对象容器的开始、结束地址，内存对象大小\n    kmsp-&gt;so_vstat = cvadrs;\n    kmsp-&gt;so_vend = cvadre;\n    kmsp-&gt;so_objsz = objsz;\n    //把物理内存页面对应的msadsc_t结构加入到kmsob_t中的so_mc.mc_kmobinlst链表上\n    list_add(&amp;msa-&gt;md_list, &amp;kmsp-&gt;so_mc.mc_kmobinlst);\n    kmsp-&gt;so_mc.mc_kmobinpnr = (uint_t)relpnr;\n    //设置内存对象的开始地址为kmsob_t结构之后，结束地址为内存对象容器的结束地址\n    freobjh_t *fohstat = (freobjh_t *)(kmsp + 1), *fohend = (freobjh_t *)cvadre;\n\n    uint_t ap = (uint_t)((uint_t)fohstat);\n    freobjh_t *tmpfoh = (freobjh_t *)((uint_t)ap);\n    for (; tmpfoh &lt; fohend;)\n    {//相当在kmsob_t结构体之后建立一个freobjh_t结构体数组\n        if ((ap + (uint_t)kmsp-&gt;so_objsz) &lt;= (uint_t)cvadre)\n        {//初始化每个freobjh_t结构体\n            freobjh_t_init(tmpfoh, 0, (void *)tmpfoh);\n            //把每个freobjh_t结构体加入到kmsob_t结构体中的so_frelst中\n           list_add(&amp;tmpfoh-&gt;oh_list, &amp;kmsp-&gt;so_frelst);\n            kmsp-&gt;so_mobjnr++;\n            kmsp-&gt;so_fobjnr++;\n        }\n        ap += (uint_t)kmsp-&gt;so_objsz;\n        tmpfoh = (freobjh_t *)((uint_t)ap);\n    }\n    return kmsp;\n}\n\n//建立一个内存对象容器\nkmsob_t *_create_kmsob(kmsobmgrhed_t *kmmgrlokp, koblst_t *koblp, size_t objsz)\n{\n    kmsob_t *kmsp = NULL;\n    msadsc_t *msa = NULL;\n    uint_t relpnr = 0;\n    uint_t pages = 1;\n    if (128 &lt; objsz)\n    {\n        pages = 2;\n    }\n    if (512 &lt; objsz)\n    {\n        pages = 4;\n    }\n    //为内存对象容器分配物理内存空间，这是我们之前实现的物理内存页面管理器\n    msa = mm_division_pages(&amp;memmgrob, pages, &amp;relpnr, MA_TYPE_KRNL, DMF_RELDIV);\n    if (NULL == msa)\n    {\n        return NULL;\n    }\n    u64_t phyadr = msa-&gt;md_phyadrs.paf_padrs &lt;&lt; PSHRSIZE;\n    u64_t phyade = phyadr + (relpnr &lt;&lt; PSHRSIZE) - 1;\n    //计算它们的虚拟地址\n    adr_t vadrs = phyadr_to_viradr((adr_t)phyadr);\n    adr_t vadre = phyadr_to_viradr((adr_t)phyade);\n    //初始化kmsob_t并建立内存对象\n    kmsp = _create_init_kmsob((kmsob_t *)vadrs, koblp-&gt;ol_sz, vadrs, vadre, msa, relpnr);\n    //把kmsob_t结构，挂载到对应的koblst_t结构中去\n    if (kmsob_add_koblst(koblp, kmsp) == FALSE)\n    {\n        system_error(&quot; _create_kmsob kmsob_add_koblst FALSE\\n&quot;);\n    }\n    //增加计数\n    kmmgrlokp-&gt;ks_msobnr++;\n    return kmsp;\n</code></pre><p>_create_kmsob函数就是根据分配内存对象大小，建立一个内存对象容器。</p><p>首先，这个函数会找物理内存页面管理器申请一块连续内存页面。然后，在其中的开始部分建立kmsob_t结构的实例变量，又在kmsob_t结构的后面建立freobjh_t结构数组，并把每个freobjh_t结构挂载到kmsob_t结构体中的so_frelst中。最后再把kmsob_t结构，挂载到kmsobmgrhed_t结构对应的koblst_t结构中去。</p><p>上面的注释已经很清楚了，我相信你看得懂。</p><h3>扩容内存对象容器</h3><p>如果我们不断重复分配同一大小的内存对象，那么那个内存对象容器中的内存对象，迟早要分配完的。一旦内存对象分配完，内存对象容器就没有空闲的内存空间产生内存对象了。这时，我们就要为内存对象容器扩展内存空间了。</p><p>下面我们来写代码实现，如下所示。</p><pre><code>//初始化kmbext_t结构\nvoid kmbext_t_init(kmbext_t *initp, adr_t vstat, adr_t vend, kmsob_t *kmsp)\n{\n    list_init(&amp;initp-&gt;mt_list);\n    initp-&gt;mt_vstat = vstat;\n    initp-&gt;mt_vend = vend;\n    initp-&gt;mt_kmsb = kmsp;\n    initp-&gt;mt_mobjnr = 0;\n    return;\n}\n//扩展内存页面\nbool_t kmsob_extn_pages(kmsob_t *kmsp)\n{\n    msadsc_t *msa = NULL;\n    uint_t relpnr = 0;\n    uint_t pages = 1;\n    if (128 &lt; kmsp-&gt;so_objsz)\n    {\n        pages = 2;\n    }\n    if (512 &lt; kmsp-&gt;so_objsz)\n    {\n        pages = 4;\n    }\n    //找物理内存页面管理器分配2或者4个连续的页面\n    msa = mm_division_pages(&amp;memmgrob, pages, &amp;relpnr, MA_TYPE_KRNL, DMF_RELDIV);\n    if (NULL == msa)\n    {\n        return FALSE;\n    }\n    u64_t phyadr = msa-&gt;md_phyadrs.paf_padrs &lt;&lt; PSHRSIZE;\n    u64_t phyade = phyadr + (relpnr &lt;&lt; PSHRSIZE) - 1;\n    adr_t vadrs = phyadr_to_viradr((adr_t)phyadr);\n    adr_t vadre = phyadr_to_viradr((adr_t)phyade);\n    //求出物理内存页面数对应在kmsob_t的so_mc.mc_lst数组中下标\n    sint_t mscidx = retn_mscidx(relpnr);\n    //把物理内存页面对应的msadsc_t结构加入到kmsob_t的so_mc.mc_lst数组中\n    list_add(&amp;msa-&gt;md_list, &amp;kmsp-&gt;so_mc.mc_lst[mscidx].ml_list);\n    kmsp-&gt;so_mc.mc_lst[mscidx].ml_msanr++;\n\n    kmbext_t *bextp = (kmbext_t *)vadrs;\n    //初始化kmbext_t数据结构\n    kmbext_t_init(bextp, vadrs, vadre, kmsp);\n//设置内存对象的开始地址为kmbext_t结构之后，结束地址为扩展内存页面的结束地址\n    freobjh_t *fohstat = (freobjh_t *)(bextp + 1), *fohend = (freobjh_t *)vadre;\n\n    uint_t ap = (uint_t)((uint_t)fohstat);\n    freobjh_t *tmpfoh = (freobjh_t *)((uint_t)ap);\n    for (; tmpfoh &lt; fohend;)\n    {\n        if ((ap + (uint_t)kmsp-&gt;so_objsz) &lt;= (uint_t)vadre)\n        {//在扩展的内存空间中建立内存对象\n            freobjh_t_init(tmpfoh, 0, (void *)tmpfoh);\n            list_add(&amp;tmpfoh-&gt;oh_list, &amp;kmsp-&gt;so_frelst);\n            kmsp-&gt;so_mobjnr++;\n            kmsp-&gt;so_fobjnr++;\n            bextp-&gt;mt_mobjnr++;\n        }\n        ap += (uint_t)kmsp-&gt;so_objsz;\n        tmpfoh = (freobjh_t *)((uint_t)ap);\n    }\n    list_add(&amp;bextp-&gt;mt_list, &amp;kmsp-&gt;so_mextlst);\n    kmsp-&gt;so_mextnr++;\n    return TRUE;\n}\n</code></pre><p>有了前面建立内存对象容器的经验，加上这里的注释，我们理解上述代码并不难：不过是分配了另一块连续的内存空间，作为空闲的内存对象，并且把这块内存空间加内存对象容器中统一管理。</p><h3>分配内存对象</h3><p>有了内存对象容器，就可以分配内存对象了。由于我们前面精心设计了内存对象容器、内存对象等数据结构，这使得我们的内存对象分配代码时极其简单，而且性能极高。</p><p>下面我们来实现它吧！代码如下所示。</p><pre><code>//判断内存对象容器中有没有内存对象\nuint_t scan_kmob_objnr(kmsob_t *kmsp)\n{\n    if (0 &lt; kmsp-&gt;so_fobjnr)\n    {\n        return kmsp-&gt;so_fobjnr;\n    }\n    return 0;\n}\n//实际分配内存对象\nvoid *kmsob_new_opkmsob(kmsob_t *kmsp, size_t msz)\n{\n    //获取kmsob_t中的so_frelst链表头的第一个空闲内存对象\n    freobjh_t *fobh = list_entry(kmsp-&gt;so_frelst.next, freobjh_t, oh_list);\n    //从链表中脱链\n    list_del(&amp;fobh-&gt;oh_list);\n    //kmsob_t中的空闲对象计数减一\n    kmsp-&gt;so_fobjnr--;\n    //返回内存对象首地址\n    return (void *)(fobh);\n}\n\nvoid *kmsob_new_onkmsob(kmsob_t *kmsp, size_t msz)\n{\n    void *retptr = NULL;\n    cpuflg_t cpuflg;\n    knl_spinlock_cli(&amp;kmsp-&gt;so_lock, &amp;cpuflg);\n    //如果内存对象容器中没有空闲的内存对象了就需要扩展内存对象容器的内存了\n    if (scan_kmsob_objnr(kmsp) &lt; 1)\n    {//扩展内存对象容器的内存\n        if (kmsob_extn_pages(kmsp) == FALSE)\n        {\n            retptr = NULL;\n            goto ret_step;\n        }\n    }\n    //实际分配内存对象\n    retptr = kmsob_new_opkmsob(kmsp, msz);\nret_step:\n    knl_spinunlock_sti(&amp;kmsp-&gt;so_lock, &amp;cpuflg);\n    return retptr;\n}\n</code></pre><p>分配内存对象的核心操作就是，<strong>kmsob_new_opkmsob函数从空闲内存对象链表头中取出第一个内存对象，返回它的首地址</strong>。这个算法非常高效，无论内存对象容器中的内存对象有多少，kmsob_new_opkmsob函数的操作始终是固定的，而如此高效的算法得益于我们先进的数据结构设计。</p><p>好了，到这里内存对象的分配就已经完成了，下面我们去实现内存对象的释放。</p><h2>释放内存对象</h2><p>释放内存对象，就是要把内存对象还给它所归属的内存对象容器。其逻辑就是根据释放内存对象的地址和大小，找到对应的内存对象容器，然后把该内存对象加入到对应内存对象容器的空闲链表上，最后看一看要不要释放内存对象容器占用的物理内存页面。</p><h3>释放内存对象的接口</h3><p>这里我们依然要从释放内存对象的接口开始实现，下面我们在kmsob.c文中写下这个函数，代码如下所示。</p><pre><code>bool_t kmsob_delete_core(void *fadrs, size_t fsz)\n{\n    kmsobmgrhed_t *kmobmgrp = &amp;memmgrob.mo_kmsobmgr;\n    bool_t rets = FALSE;\n    koblst_t *koblp = NULL;\n    kmsob_t *kmsp = NULL;\n    cpuflg_t cpuflg;\n    knl_spinlock_cli(&amp;kmobmgrp-&gt;ks_lock, &amp;cpuflg);\n    //根据释放内存对象的大小在kmsobmgrhed_t中查找并返回koblst_t，在其中挂载着对应的kmsob_t，这个在前面已经写好了\n    koblp = onmsz_retn_koblst(kmobmgrp, fsz);\n    if (NULL == koblp)\n    {\n        rets = FALSE;\n        goto ret_step;\n    }\n    kmsp = onkoblst_retn_delkmsob(koblp, fadrs, fsz);\n    if (NULL == kmsp)\n    {\n        rets = FALSE;\n        goto ret_step;\n    }\n    rets = kmsob_delete_onkmsob(kmsp, fadrs, fsz);\n    if (FALSE == rets)\n    {\n        rets = FALSE;\n        goto ret_step;\n    }\n    if (_destroy_kmsob(kmobmgrp, koblp, kmsp) == FALSE)\n    {\n        rets = FALSE;\n        goto ret_step;\n    }\n    rets = TRUE;\nret_step:\n    knl_spinunlock_sti(&amp;kmobmgrp-&gt;ks_lock, &amp;cpuflg);\n    return rets;\n}\n//释放内存对象接口\nbool_t kmsob_delete(void *fadrs, size_t fsz)\n{\n    //对参数进行检查，但是多了对内存对象地址的检查 \n    if (NULL == fadrs || 1 &gt; fsz || 2048 &lt; fsz)\n    {\n        return FALSE;\n    }\n    //调用释放内存对象的核心函数\n    return kmsob_delete_core(fadrs, fsz);\n}\n</code></pre><p>上述代码中，等到kmsob_delete函数检查参数通过之后，就调用释放内存对象的核心函数kmsob_delete_core，在这个函数中，一开始根据释放内存对象大小，找到挂载其kmsob_t结构的koblst_t结构，接着又做了一系列的操作，这些操作正是我们接下来要实现的。</p><h3>查找内存对象容器</h3><p>释放内存对象，首先要找到这个将要释放的内存对象所属的内存对象容器。释放时的查找和分配时的查找不一样，因为要检查<strong>释放的内存对象是不是属于该内存对象容器。</strong></p><p>下面我们一起来实现这个函数，代码如下所示。</p><pre><code>//检查释放的内存对象是不是在kmsob_t结构中\nkmsob_t *scan_delkmsob_isok(kmsob_t *kmsp, void *fadrs, size_t fsz)\n{//检查释放内存对象的地址是否落在kmsob_t结构的地址区间\n    if ((adr_t)fadrs &gt;= (kmsp-&gt;so_vstat + sizeof(kmsob_t)) &amp;&amp; ((adr_t)fadrs + (adr_t)fsz) &lt;= kmsp-&gt;so_vend)\n    {    //检查释放内存对象的大小是否小于等于kmsob_t内存对象容器的对象大小 \n        if (fsz &lt;= kmsp-&gt;so_objsz)\n        {\n            return kmsp;\n        }\n    }\n    if (1 &gt; kmsp-&gt;so_mextnr)\n    {//如果kmsob_t结构没有扩展空间，直接返回\n        return NULL;\n    }\n    kmbext_t *bexp = NULL;\n    list_h_t *tmplst = NULL;\n    //遍历kmsob_t结构中的每个扩展空间\n    list_for_each(tmplst, &amp;kmsp-&gt;so_mextlst)\n    {\n        bexp = list_entry(tmplst, kmbext_t, mt_list);\n        //检查释放内存对象的地址是否落在扩展空间的地址区间\n        if ((adr_t)fadrs &gt;= (bexp-&gt;mt_vstat + sizeof(kmbext_t)) &amp;&amp; ((adr_t)fadrs + (adr_t)fsz) &lt;= bexp-&gt;mt_vend)\n        {//同样的要检查大小\n            if (fsz &lt;= kmsp-&gt;so_objsz)\n            {\n                return kmsp;\n            }\n        }\n    }\n    return NULL;\n}\n//查找释放内存对象所属的kmsob_t结构\nkmsob_t *onkoblst_retn_delkmsob(koblst_t *koblp, void *fadrs, size_t fsz)\n{\n    v *kmsp = NULL, *tkmsp = NULL;\n    list_h_t *tmplst = NULL;\n    //看看上次刚刚操作的kmsob_t结构\n    kmsp = scan_delkmsob_isok(koblp-&gt;ol_cahe, fadrs, fsz);\n    if (NULL != kmsp)\n    {\n        return kmsp;\n    }\n    if (0 &lt; koblp-&gt;ol_emnr)\n    {    //遍历挂载koblp-&gt;ol_emplst链表上的每个kmsob_t结构\n        list_for_each(tmplst, &amp;koblp-&gt;ol_emplst)\n        {\n            tkmsp = list_entry(tmplst, kmsob_t, so_list);\n            //检查释放的内存对象是不是属于这个kmsob_t结构\n            kmsp = scan_delkmsob_isok(tkmsp, fadrs, fsz);\n            if (NULL != kmsp)\n            {\n                return kmsp;\n            }\n        }\n    }\n    return NULL;\n}\n</code></pre><p>上面的代码注释已经很明白了，搜索对应koblst_t结构中的每个kmsob_t结构体，随后进行检查，检查了kmsob_t结构的自身内存区域和扩展内存区域。即比较释放内存对象的地址是不是落在它们的内存区间中，其大小是否合乎要求。</p><h3>释放内存对象</h3><p>如果不出意外，会找到释放内存对象的kmsob_t结构，这样就可以释放内存对象了，就是把这块内存空间还给内存对象容器，这个过程的具体代码实现如下所示。</p><pre><code>bool_t kmsob_del_opkmsob(kmsob_t *kmsp, void *fadrs, size_t fsz)\n{\n    if ((kmsp-&gt;so_fobjnr + 1) &gt; kmsp-&gt;so_mobjnr)\n    {\n        return FALSE;\n    }\n    //让freobjh_t结构重新指向要释放的内存空间\n    freobjh_t *obhp = (freobjh_t *)fadrs;\n    //重新初始化块内存空间\n    freobjh_t_init(obhp, 0, obhp);\n    //加入kmsob_t结构的空闲链表\n    list_add(&amp;obhp-&gt;oh_list, &amp;kmsp-&gt;so_frelst);\n    //kmsob_t结构的空闲对象计数加一\n    kmsp-&gt;so_fobjnr++;\n    return TRUE;\n}\n//释放内存对象\nbool_t kmsob_delete_onkmsob(kmsob_t *kmsp, void *fadrs, size_t fsz)\n{\n    bool_t rets = FALSE;\n    cpuflg_t cpuflg;\n    //对kmsob_t结构加锁\n    knl_spinlock_cli(&amp;kmsp-&gt;so_lock, &amp;cpuflg);\n    //实际完成内存对象释放\n    if (kmsob_del_opkmsob(kmsp, fadrs, fsz) == FALSE)\n    {\n        rets = FALSE;\n        goto ret_step;\n    }\n    rets = TRUE;\nret_step:\n    //对kmsob_t结构解锁\n    knl_spinunlock_sti(&amp;kmsp-&gt;so_lock, &amp;cpuflg);\n    return rets;\n}\n</code></pre><p>结合上述代码和注释，我们现在明白了kmsob_delete_onkmsob函数调用kmsob_del_opkmsob函数。其核心机制就是<strong>把要释放内存对象的空间，重新初始化，变成一个freobjh_t结构的实例变量，最后把这个freobjh_t结构加入到kmsob_t结构中空闲链表中</strong>，这就实现了内存对象的释放。</p><h3>销毁内存对象容器</h3><p>如果我们释放了所有的内存对象，就会出现空的内存对象容器。如果下一次请求同样大小的内存对象，那么这个空的内存对象容器还能继续复用，提高性能。</p><p>但是你有没有想到，频繁请求的是不同大小的内存对象，那么空的内存对象容器会越来越多，这会占用大量内存，所以我们必须要把空的内存对象容器销毁。</p><p>下面我们写代码实现销毁内存对象容器。</p><pre><code>uint_t scan_freekmsob_isok(kmsob_t *kmsp)\n{\n    //当内存对象容器的总对象个数等于空闲对象个数时，说明这内存对象容器空闲\n    if (kmsp-&gt;so_mobjnr == kmsp-&gt;so_fobjnr)\n    {\n        return 2;\n    }\n    return 1;\n}\n\nbool_t _destroy_kmsob_core(kmsobmgrhed_t *kmobmgrp, koblst_t *koblp, kmsob_t *kmsp)\n{\n    list_h_t *tmplst = NULL;\n    msadsc_t *msa = NULL;\n    msclst_t *mscp = kmsp-&gt;so_mc.mc_lst;\n    list_del(&amp;kmsp-&gt;so_list);\n    koblp-&gt;ol_emnr--;\n    kmobmgrp-&gt;ks_msobnr--;\n    //释放内存对象容器扩展空间的物理内存页面\n    //遍历kmsob_t结构中的so_mc.mc_lst数组\n    for (uint_t j = 0; j &lt; MSCLST_MAX; j++)\n    {\n        if (0 &lt; mscp[j].ml_msanr)\n        {//遍历每个so_mc.mc_lst数组中的msadsc_t结构\n            list_for_each_head_dell(tmplst, &amp;mscp[j].ml_list)\n            {\n                msa = list_entry(tmplst, msadsc_t, md_list);\n                list_del(&amp;msa-&gt;md_list);\n                //msadsc_t脱链\n                //释放msadsc_t对应的物理内存页面\n                if (mm_merge_pages(&amp;memmgrob, msa, (uint_t)mscp[j].ml_ompnr) == FALSE)\n                {\n                    system_error(&quot;_destroy_kmsob_core mm_merge_pages FALSE2\\n&quot;);\n                }\n            }\n        }\n    }\n    //释放内存对象容器本身占用的物理内存页面\n    //遍历每个so_mc.mc_kmobinlst中的msadsc_t结构。它只会遍历一次\n    list_for_each_head_dell(tmplst, &amp;kmsp-&gt;so_mc.mc_kmobinlst)\n    {\n        msa = list_entry(tmplst, msadsc_t, md_list);\n        list_del(&amp;msa-&gt;md_list);\n        //msadsc_t脱链\n        //释放msadsc_t对应的物理内存页面\n        if (mm_merge_pages(&amp;memmgrob, msa, (uint_t)kmsp-&gt;so_mc.mc_kmobinpnr) == FALSE)\n        {\n            system_error(&quot;_destroy_kmsob_core mm_merge_pages FALSE2\\n&quot;);\n        }\n    }\n    return TRUE;\n}\n//\n```销毁内存对象容器\nbool_t _destroy_kmsob(kmsobmgrhed_t *kmobmgrp, koblst_t *koblp, kmsob_t *kmsp)\n{\n    //看看能不能销毁\n    uint_t screts = scan_freekmsob_isok(kmsp);\n    if (2 == screts)\n    {//调用销毁内存对象容器的核心函数\n        return _destroy_kmsob_core(kmobmgrp, koblp, kmsp);\n    }\n    return FALSE;\n}\n</code></pre><p>上述代码中，首先会检查一下内存对象容器是不是空闲的，如果空闲，就调用<strong>销毁内存对象容器的核心函数_destroy_kmsob_core</strong>。在_destroy_kmsob_core函数中，首先要释放内存对象容器的扩展空间所占用的物理内存页面，最后才可以释放内存对象容器自身占用物理内存页面。</p><p>请注意。<strong>这个顺序不能前后颠倒</strong>，这是因为扩展空间的物理内存页面对应的msadsc_t结构，它就挂载在kmsob_t结构的so_mc.mc_lst数组中。</p><p>好了，到这里我们内存对象释放的流程就完成了，这意味着我们整个内存对象管理也告一段落了。</p><h2>重点回顾</h2><p>今天我们从malloc函数入手，思考内核要怎样分配大量小块内存。我们把物理内存页面进一步细分成内存对象，为了表示和管理内存对象，又设计了内存对象、内存对象容器等一系列数据结构，随后写代码把它们初始化，最后我们依赖这些数据结构实现了内存对象管理算法。</p><p>下面我们来回顾一下这节课的重点。</p><p>1.我们发现，在应用程序中可以使用malloc函数动态分配一些小块内存，其实这样的场景在内核中也是比比皆是。比如，内核经常要动态创建数据结构的实例变量，就需要分配小块的内存空间。</p><p>2.为了实现内存对象的表示、分配和释放功能，我们定义了内存对象和内存对象容器的数据结构freobjh_t、kmsob_t，并为了管理kmsob_t结构又定义了kmsobmgrhed_t结构。</p><p>3.我们写好了初始化kmsobmgrhed_t结构的函数，并在init_kmsob中调用了它，进而又被init_memmgr函数调用，由于kmsobmgrhed_t结构是为了管理kmsob_t结构的所以在一开始就要被初始化。</p><p>4.我们基于这些数据结构实现了内存对象的分配和释放。</p><h2>思考题</h2><p>为什么我们在分配内存对象大小时要按照Cache行大小的倍数分配呢？</p><p>欢迎你在留言区分享你的思考或疑问。如果这节课对你有帮助，也欢迎你分享给自己的同事、朋友，跟他一起交流讨论。</p><p>好，我是LMOS，我们下节课见！</p>","neighbors":{"left":{"article_title":"18 | 划分土地（下）：如何实现内存页的分配与释放？","id":385628},"right":{"article_title":"20 | 土地需求扩大与保障：如何表示虚拟内存？","id":387258}},"comments":[]}