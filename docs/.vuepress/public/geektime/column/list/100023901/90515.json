{"id":90515,"title":"21 | 原子类：无锁工具类的典范","content":"<p>前面我们多次提到一个累加器的例子，示例代码如下。在这个例子中，add10K()这个方法不是线程安全的，问题就出在变量count的可见性和count+=1的原子性上。可见性问题可以用volatile来解决，而原子性问题我们前面一直都是采用的互斥锁方案。</p><pre><code>public class Test {\n  long count = 0;\n  void add10K() {\n    int idx = 0;\n    while(idx++ &lt; 10000) {\n      count += 1;\n    }\n  }\n}\n</code></pre><p>其实对于简单的原子性问题，还有一种<strong>无锁方案</strong>。Java SDK并发包将这种无锁方案封装提炼之后，实现了一系列的原子类。不过，在深入介绍原子类的实现之前，我们先看看如何利用原子类解决累加器问题，这样你会对原子类有个初步的认识。</p><p>在下面的代码中，我们将原来的long型变量count替换为了原子类AtomicLong，原来的 <code>count +=1</code> 替换成了 count.getAndIncrement()，仅需要这两处简单的改动就能使add10K()方法变成线程安全的，原子类的使用还是挺简单的。</p><pre><code>public class Test {\n  AtomicLong count = \n    new AtomicLong(0);\n  void add10K() {\n    int idx = 0;\n    while(idx++ &lt; 10000) {\n      count.getAndIncrement();\n    }\n  }\n}\n</code></pre><p>无锁方案相对互斥锁方案，最大的好处就是<strong>性能</strong>。互斥锁方案为了保证互斥性，需要执行加锁、解锁操作，而加锁、解锁操作本身就消耗性能；同时拿不到锁的线程还会进入阻塞状态，进而触发线程切换，线程切换对性能的消耗也很大。 相比之下，无锁方案则完全没有加锁、解锁的性能消耗，同时还能保证互斥性，既解决了问题，又没有带来新的问题，可谓绝佳方案。那它是如何做到的呢？</p><!-- [[[read_end]]] --><h2>无锁方案的实现原理</h2><p>其实原子类性能高的秘密很简单，硬件支持而已。CPU为了解决并发问题，提供了CAS指令（CAS，全称是Compare And Swap，即“比较并交换”）。CAS指令包含3个参数：共享变量的内存地址A、用于比较的值B和共享变量的新值C；并且只有当内存中地址A处的值等于B时，才能将内存中地址A处的值更新为新值C。<strong>作为一条CPU指令，CAS指令本身是能够保证原子性的</strong>。</p><p>你可以通过下面CAS指令的模拟代码来理解CAS的工作原理。在下面的模拟程序中有两个参数，一个是期望值expect，另一个是需要写入的新值newValue，<strong>只有当目前count的值和期望值expect相等时，才会将count更新为newValue</strong>。</p><pre><code>class SimulatedCAS{\n  int count；\n  synchronized int cas(\n    int expect, int newValue){\n    // 读目前count的值\n    int curValue = count;\n    // 比较目前count值是否==期望值\n    if(curValue == expect){\n      // 如果是，则更新count的值\n      count = newValue;\n    }\n    // 返回写入前的值\n    return curValue;\n  }\n}\n</code></pre><p>你仔细地再次思考一下这句话，“<strong>只有当目前count的值和期望值expect相等时，才会将count更新为newValue。</strong>”要怎么理解这句话呢？</p><p>对于前面提到的累加器的例子，<code>count += 1</code> 的一个核心问题是：基于内存中count的当前值A计算出来的count+=1为A+1，在将A+1写入内存的时候，很可能此时内存中count已经被其他线程更新过了，这样就会导致错误地覆盖其他线程写入的值（如果你觉得理解起来还有困难，建议你再重新看看<a href=\"https://time.geekbang.org/column/article/83682\">《01 | 可见性、原子性和有序性问题：并发编程Bug的源头》</a>）。也就是说，只有当内存中count的值等于期望值A时，才能将内存中count的值更新为计算结果A+1，这不就是CAS的语义吗！</p><p>使用CAS来解决并发问题，一般都会伴随着自旋，而所谓自旋，其实就是循环尝试。例如，实现一个线程安全的<code>count += 1</code>操作，“CAS+自旋”的实现方案如下所示，首先计算newValue = count+1，如果cas(count,newValue)返回的值不等于count，则意味着线程在执行完代码①处之后，执行代码②处之前，count的值被其他线程更新过。那此时该怎么处理呢？可以采用自旋方案，就像下面代码中展示的，可以重新读count最新的值来计算newValue并尝试再次更新，直到成功。</p><pre><code>class SimulatedCAS{\n  volatile int count;\n  // 实现count+=1\n  addOne(){\n    do {\n      newValue = count+1; //①\n    }while(count !=\n      cas(count,newValue) //②\n  }\n  // 模拟实现CAS，仅用来帮助理解\n  synchronized int cas(\n    int expect, int newValue){\n    // 读目前count的值\n    int curValue = count;\n    // 比较目前count值是否==期望值\n    if(curValue == expect){\n      // 如果是，则更新count的值\n      count= newValue;\n    }\n    // 返回写入前的值\n    return curValue;\n  }\n}\n</code></pre><p>通过上面的示例代码，想必你已经发现了，CAS这种无锁方案，完全没有加锁、解锁操作，即便两个线程完全同时执行addOne()方法，也不会有线程被阻塞，所以相对于互斥锁方案来说，性能好了很多。</p><p>但是在CAS方案中，有一个问题可能会常被你忽略，那就是<strong>ABA</strong>的问题。什么是ABA问题呢？</p><p>前面我们提到“如果cas(count,newValue)返回的值<strong>不等于</strong>count，意味着线程在执行完代码①处之后，执行代码②处之前，count的值被其他线程<strong>更新过</strong>”，那如果cas(count,newValue)返回的值<strong>等于</strong>count，是否就能够认为count的值没有被其他线程<strong>更新过</strong>呢？显然不是的，假设count原本是A，线程T1在执行完代码①处之后，执行代码②处之前，有可能count被线程T2更新成了B，之后又被T3更新回了A，这样线程T1虽然看到的一直是A，但是其实已经被其他线程更新过了，这就是ABA问题。</p><p>可能大多数情况下我们并不关心ABA问题，例如数值的原子递增，但也不能所有情况下都不关心，例如原子化的更新对象很可能就需要关心ABA问题，因为两个A虽然相等，但是第二个A的属性可能已经发生变化了。所以在使用CAS方案的时候，一定要先check一下。</p><h2>看Java如何实现原子化的count += 1</h2><p>在本文开始部分，我们使用原子类AtomicLong的getAndIncrement()方法替代了<code>count += 1</code>，从而实现了线程安全。原子类AtomicLong的getAndIncrement()方法内部就是基于CAS实现的，下面我们来看看Java是如何使用CAS来实现原子化的<code>count += 1</code>的。</p><p>在Java 1.8版本中，getAndIncrement()方法会转调unsafe.getAndAddLong()方法。这里this和valueOffset两个参数可以唯一确定共享变量的内存地址。</p><pre><code>final long getAndIncrement() {\n  return unsafe.getAndAddLong(\n    this, valueOffset, 1L);\n}\n</code></pre><p>unsafe.getAndAddLong()方法的源码如下，该方法首先会在内存中读取共享变量的值，之后循环调用compareAndSwapLong()方法来尝试设置共享变量的值，直到成功为止。compareAndSwapLong()是一个native方法，只有当内存中共享变量的值等于expected时，才会将共享变量的值更新为x，并且返回true；否则返回fasle。compareAndSwapLong的语义和CAS指令的语义的差别仅仅是返回值不同而已。</p><pre><code>public final long getAndAddLong(\n  Object o, long offset, long delta){\n  long v;\n  do {\n    // 读取内存中的值\n    v = getLongVolatile(o, offset);\n  } while (!compareAndSwapLong(\n      o, offset, v, v + delta));\n  return v;\n}\n//原子性地将变量更新为x\n//条件是内存中的值等于expected\n//更新成功则返回true\nnative boolean compareAndSwapLong(\n  Object o, long offset, \n  long expected,\n  long x);\n</code></pre><p>另外，需要你注意的是，getAndAddLong()方法的实现，基本上就是CAS使用的经典范例。所以请你再次体会下面这段抽象后的代码片段，它在很多无锁程序中经常出现。Java提供的原子类里面CAS一般被实现为compareAndSet()，compareAndSet()的语义和CAS指令的语义的差别仅仅是返回值不同而已，compareAndSet()里面如果更新成功，则会返回true，否则返回false。</p><pre><code>do {\n  // 获取当前值\n  oldV = xxxx；\n  // 根据当前值计算新值\n  newV = ...oldV...\n}while(!compareAndSet(oldV,newV);\n</code></pre><h2>原子类概览</h2><p>Java SDK并发包里提供的原子类内容很丰富，我们可以将它们分为五个类别：<strong>原子化的基本数据类型、原子化的对象引用类型、原子化数组、原子化对象属性更新器</strong>和<strong>原子化的累加器</strong>。这五个类别提供的方法基本上是相似的，并且每个类别都有若干原子类，你可以通过下面的原子类组成概览图来获得一个全局的印象。下面我们详细解读这五个类别。</p><p><img src=\"https://static001.geekbang.org/resource/image/00/4a/007a32583fbf519469462fe61805eb4a.png?wh=1142*461\" alt=\"\"></p><center><span class=\"reference\">原子类组成概览图</span></center><h3>1. 原子化的基本数据类型</h3><p>相关实现有AtomicBoolean、AtomicInteger和AtomicLong，提供的方法主要有以下这些，详情你可以参考SDK的源代码，都很简单，这里就不详细介绍了。</p><pre><code>getAndIncrement() //原子化i++\ngetAndDecrement() //原子化的i--\nincrementAndGet() //原子化的++i\ndecrementAndGet() //原子化的--i\n//当前值+=delta，返回+=前的值\ngetAndAdd(delta) \n//当前值+=delta，返回+=后的值\naddAndGet(delta)\n//CAS操作，返回是否成功\ncompareAndSet(expect, update)\n//以下四个方法\n//新值可以通过传入func函数来计算\ngetAndUpdate(func)\nupdateAndGet(func)\ngetAndAccumulate(x,func)\naccumulateAndGet(x,func)\n</code></pre><h3>2. 原子化的对象引用类型</h3><p>相关实现有AtomicReference、AtomicStampedReference和AtomicMarkableReference，利用它们可以实现对象引用的原子化更新。AtomicReference提供的方法和原子化的基本数据类型差不多，这里不再赘述。不过需要注意的是，对象引用的更新需要重点关注ABA问题，AtomicStampedReference和AtomicMarkableReference这两个原子类可以解决ABA问题。</p><p>解决ABA问题的思路其实很简单，增加一个版本号维度就可以了，这个和我们在<a href=\"https://time.geekbang.org/column/article/89456\">《18 | StampedLock：有没有比读写锁更快的锁？》</a>介绍的乐观锁机制很类似，每次执行CAS操作，附加再更新一个版本号，只要保证版本号是递增的，那么即便A变成B之后再变回A，版本号也不会变回来（版本号递增的）。AtomicStampedReference实现的CAS方法就增加了版本号参数，方法签名如下：</p><pre><code>boolean compareAndSet(\n  V expectedReference,\n  V newReference,\n  int expectedStamp,\n  int newStamp) \n</code></pre><p>AtomicMarkableReference的实现机制则更简单，将版本号简化成了一个Boolean值，方法签名如下：</p><pre><code>boolean compareAndSet(\n  V expectedReference,\n  V newReference,\n  boolean expectedMark,\n  boolean newMark)\n</code></pre><h3>3. 原子化数组</h3><p>相关实现有AtomicIntegerArray、AtomicLongArray和AtomicReferenceArray，利用这些原子类，我们可以原子化地更新数组里面的每一个元素。这些类提供的方法和原子化的基本数据类型的区别仅仅是：每个方法多了一个数组的索引参数，所以这里也不再赘述了。</p><h3>4. 原子化对象属性更新器</h3><p>相关实现有AtomicIntegerFieldUpdater、AtomicLongFieldUpdater和AtomicReferenceFieldUpdater，利用它们可以原子化地更新对象的属性，这三个方法都是利用反射机制实现的，创建更新器的方法如下：</p><pre><code>public static &lt;U&gt;\nAtomicXXXFieldUpdater&lt;U&gt; \nnewUpdater(Class&lt;U&gt; tclass, \n  String fieldName)\n</code></pre><p>需要注意的是，<strong>对象属性必须是volatile类型的，只有这样才能保证可见性</strong>；如果对象属性不是volatile类型的，newUpdater()方法会抛出IllegalArgumentException这个运行时异常。</p><p>你会发现newUpdater()的方法参数只有类的信息，没有对象的引用，而更新<strong>对象</strong>的属性，一定需要对象的引用，那这个参数是在哪里传入的呢？是在原子操作的方法参数中传入的。例如compareAndSet()这个原子操作，相比原子化的基本数据类型多了一个对象引用obj。原子化对象属性更新器相关的方法，相比原子化的基本数据类型仅仅是多了对象引用参数，所以这里也不再赘述了。</p><pre><code>boolean compareAndSet(\n  T obj, \n  int expect, \n  int update)\n</code></pre><h3>5. 原子化的累加器</h3><p>DoubleAccumulator、DoubleAdder、LongAccumulator和LongAdder，这四个类仅仅用来执行累加操作，相比原子化的基本数据类型，速度更快，但是不支持compareAndSet()方法。如果你仅仅需要累加操作，使用原子化的累加器性能会更好。</p><h2>总结</h2><p>无锁方案相对于互斥锁方案，优点非常多，首先性能好，其次是基本不会出现死锁问题（但可能出现饥饿和活锁问题，因为自旋会反复重试）。Java提供的原子类大部分都实现了compareAndSet()方法，基于compareAndSet()方法，你可以构建自己的无锁数据结构，但是<strong>建议你不要这样做，这个工作最好还是让大师们去完成</strong>，原因是无锁算法没你想象的那么简单。</p><p>Java提供的原子类能够解决一些简单的原子性问题，但你可能会发现，上面我们所有原子类的方法都是针对一个共享变量的，如果你需要解决多个变量的原子性问题，建议还是使用互斥锁方案。原子类虽好，但使用要慎之又慎。</p><h2>课后思考</h2><p>下面的示例代码是合理库存的原子化实现，仅实现了设置库存上限setUpper()方法，你觉得setUpper()方法的实现是否正确呢？</p><pre><code>public class SafeWM {\n  class WMRange{\n    final int upper;\n    final int lower;\n    WMRange(int upper,int lower){\n    //省略构造函数实现\n    }\n  }\n  final AtomicReference&lt;WMRange&gt;\n    rf = new AtomicReference&lt;&gt;(\n      new WMRange(0,0)\n    );\n  // 设置库存上限\n  void setUpper(int v){\n    WMRange nr;\n    WMRange or = rf.get();\n    do{\n      // 检查参数合法性\n      if(v &lt; or.lower){\n        throw new IllegalArgumentException();\n      }\n      nr = new\n        WMRange(v, or.lower);\n    }while(!rf.compareAndSet(or, nr));\n  }\n}\n</code></pre><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><p></p>","neighbors":{"left":{"article_title":"20 | 并发容器：都有哪些“坑”需要我们填？","id":90201},"right":{"article_title":"22 | Executor与线程池：如何创建正确的线程池？","id":90771}},"comments":[{"had_liked":false,"id":86508,"user_name":"张天屹","can_delete":false,"product_type":"c1","uid":1477612,"ip_address":"","ucode":"8BD6BD6DCF0F4F","user_header":"https://static001.geekbang.org/account/avatar/00/16/8b/ec/dc03f5ad.jpg","comment_is_top":false,"comment_ctime":1555385784,"is_pvip":false,"replies":[{"id":"31152","content":"👍<br>","user_name":"作者回复","comment_id":86508,"uid":"1269969","ip_address":"","utype":1,"ctime":1555413863,"user_name_real":"王宝令"}],"discussion_count":2,"race_medal":0,"score":"409577278904","product_id":100023901,"comment_content":"如果线程1 运行到WMRange or = rf.get();停止，切换到线程2 更新了值，切换回到线程1，进入循环将永远比较失败死循环，解决方案是将读取的那一句放入循环里，CAS每次自旋必须要重新检查新的值才有意义","like_count":95,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447044,"discussion_content":"👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555413863,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2817383,"avatar":"","nickname":"Geek_0e145a","note":"","ucode":"55806C67EE550E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":412450,"discussion_content":"豁然开朗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636171951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86557,"user_name":"天涯煮酒","can_delete":false,"product_type":"c1","uid":1241127,"ip_address":"","ucode":"EF9516EC878E4C","user_header":"https://static001.geekbang.org/account/avatar/00/12/f0/27/8b72141c.jpg","comment_is_top":false,"comment_ctime":1555399519,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"263548404575","product_id":100023901,"comment_content":"or = rf.get(); 应该放到do{}内","like_count":61},{"had_liked":false,"id":87315,"user_name":"Geek_ebda96","can_delete":false,"product_type":"c1","uid":1134862,"ip_address":"","ucode":"02912E6D95A5A6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoRiaKX0ulEibbbwM4xhjyMeza0Pyp7KO1mqvfJceiaM6ZNtGpXJibI6P2qHGwBP9GKwOt9LgHicHflBXw/132","comment_is_top":false,"comment_ctime":1555566542,"is_pvip":false,"replies":[{"id":"31553","content":"你的这个写法是对的👍","user_name":"作者回复","comment_id":87315,"uid":"1269969","ip_address":"","utype":1,"ctime":1555676769,"user_name_real":"王宝令"}],"discussion_count":13,"race_medal":0,"score":"164764323790","product_id":100023901,"comment_content":"老师你举的这个例子，自己实现CAS是不是有点不对<br>class SimulatedCAS{<br>  volatile int count;<br>  &#47;&#47; 实现 count+=1<br>  addOne(){<br>    do {<br>      newValue = count+1; &#47;&#47;①<br>    }while(count !=<br>      cas(count,newValue) &#47;&#47;②<br>  }<br>  &#47;&#47; 模拟实现 CAS，仅用来帮助理解<br>  synchronized int cas(<br>    int expect, int newValue){<br>    &#47;&#47; 读目前 count 的值<br>    int curValue = count;<br>    &#47;&#47; 比较目前 count 值是否 == 期望值<br>    if(curValue == expect){<br>      &#47;&#47; 如果是，则更新 count 的值<br>      count= newValue;<br>    }<br>    &#47;&#47; 返回写入前的值<br>    return curValue;<br>  }<br>}<br><br>2 这里是不是应该用oldValue来比较，在do里面的时候先把count的值用oldValue保存下来，传入的参数expected为oldValue,newValue为oldValue+1<br><br>do{<br>    oldValue = count;<br>    newValue = oldValue + 1;<br>}while(oldValue != cas(oldValue, newValue))<br><br>望指正","like_count":38,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447394,"discussion_content":"你的这个写法是对的👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555676769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1441876,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2vn8hyjICTCletGs0omz28lhriaZKX2XX9icYzAEon2IEoRnlXqyOia2bEPP0j7T6xexTnr77JJic8w/132","nickname":"Geek_c22199","note":"","ucode":"1CE5B65513E360","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221127,"discussion_content":"volatile 是保证可见性的，看到本章节那儿就很费解，因为count读到的值会一直是新的，cas返回的值也一直是新的……\n需要获取旧值才能说的通，楼主问了想问的问题","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1585979302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1120212,"avatar":"https://static001.geekbang.org/account/avatar/00/11/17/d4/d7a4e6f5.jpg","nickname":"胡楚坚","note":"","ucode":"225883EDF35BED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":36169,"discussion_content":"看到文章就纳闷，赶紧翻来评论，，果然有问题哈。（count是类属性，非线程安全，换成方法变量就线程安全了）","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571326373,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1120212,"avatar":"https://static001.geekbang.org/account/avatar/00/11/17/d4/d7a4e6f5.jpg","nickname":"胡楚坚","note":"","ucode":"225883EDF35BED","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50195,"discussion_content":"那个变量是 volitale 的……","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1573691967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":36169,"ip_address":""},"score":50195,"extra":""},{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366931,"discussion_content":"正是因为是volitale 所以老师那种写法cas(oldValue, newValue)每次都会是true。假如初始值是1，当前线程想更新成2，如果不记1，在当前线程cas之前有另外一个线程更新成2，此时当前线程cas(oldValue, newValue)会更新为2，但其实应该是3","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618219582,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":50195,"ip_address":""},"score":366931,"extra":""},{"author":{"id":1689144,"avatar":"https://static001.geekbang.org/account/avatar/00/19/c6/38/b41dc894.jpg","nickname":"马半仙","note":"","ucode":"14868A55469A76","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408716,"discussion_content":"不是的，你传的是count，但是你是在调用方法，传过去的只是个值，而不是方法变量，穿进去就不是volitale了，是不会更新内存最新值的，所以层主和老师实现方法是一样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635306485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":366931,"ip_address":""},"score":408716,"extra":""}]},{"author":{"id":1156592,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg","nickname":"Joker","note":"","ucode":"126AF848001A1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":45157,"discussion_content":"老师的那个cout应该是对的，我跑了一下，没啥问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573007435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2226367,"avatar":"https://static001.geekbang.org/account/avatar/00/21/f8/bf/59f2e600.jpg","nickname":"月明风清","note":"","ucode":"65A97CF2E320FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1156592,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg","nickname":"Joker","note":"","ucode":"126AF848001A1E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575059,"discussion_content":"跑一下对，不代表写的是对的，并发问题本来就有随机性，难以复原并发问题的场景","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654572977,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":45157,"ip_address":""},"score":575059,"extra":""}]},{"author":{"id":1687656,"avatar":"https://static001.geekbang.org/account/avatar/00/19/c0/68/314e8306.jpg","nickname":"威先森","note":"","ucode":"5F445C6832274B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365584,"discussion_content":"上面评论错了，😂cas方法返回的永远都是旧的count值，count有可能是旧的或者新的，当while条件满足（就是count值和cas返回的值不等时）就会自旋。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617845575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2343086,"avatar":"https://static001.geekbang.org/account/avatar/00/23/c0/ae/e5e62510.jpg","nickname":"徐志超-Klaus","note":"","ucode":"CF26B39965F2A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1687656,"avatar":"https://static001.geekbang.org/account/avatar/00/19/c0/68/314e8306.jpg","nickname":"威先森","note":"","ucode":"5F445C6832274B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389808,"discussion_content":"这里我也很费解，新值不等于旧值不就修改成功了吗？修改成功了为什么要自旋呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629436700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":365584,"ip_address":""},"score":389808,"extra":""}]},{"author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296245,"discussion_content":"一样的。方法变量也是线程可见的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596497132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1118758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/12/26/e7561fda.jpg","nickname":"Volcano","note":"","ucode":"EE659D034636BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":25560,"discussion_content":"这不是一样吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570538744,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5482,"discussion_content":"这不是一样吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566294189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":210749,"user_name":"长脖子树","can_delete":false,"product_type":"c1","uid":1182802,"ip_address":"","ucode":"D9090EF67EEB1B","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/52/f25c3636.jpg","comment_is_top":false,"comment_ctime":1587819726,"is_pvip":true,"replies":[{"id":"78690","content":"👍","user_name":"作者回复","comment_id":210749,"uid":"1269969","ip_address":"","utype":1,"ctime":1588032413,"user_name_real":"王宝令"}],"discussion_count":4,"race_medal":0,"score":"100372067534","product_id":100023901,"comment_content":"原子类在 java 层面虽然看起来是无锁的, 但是深入到操作系统和cpu层面仍然有锁<br>比如像在多处理器计算机里常常会有一种 TSL 指令, (测试并加锁 test and set lock),  它是一种硬件支持的互斥方案, 执行这个指令的cpu将锁住内存总线, 以禁止其他CPU 在本指令结束之前访问内存<br>这个指令类似于 intel 处理器上的 lock cmpxchg , 但在近几代的实现上, 对内存总线的锁定做了类似于分段锁的优化, 仅仅锁定部分的缓存行<br>参考: <br>1. 现代操作系统<br>2. https:&#47;&#47;en.wikipedia.org&#47;wiki&#47;Compare-and-swap<br>3. https:&#47;&#47;stackoverflow.com&#47;questions&#47;11065675&#47;lock-prefix-of-intel-instruction-what-is-the-point<br>4. https:&#47;&#47;cloud.tencent.com&#47;developer&#47;article&#47;1189884","like_count":23,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493100,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588032413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1926057,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/63/a9/abed781e.jpg","nickname":"李維道","note":"","ucode":"9A16ECAB2522E3","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559255,"discussion_content":"你说的这些属于硬件和操作系统为了解决可见性问题所引入的锁机制和缓存一致性协议，这个部分与原子类和CAS是要解决原子性问题不大一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648657931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1309236,"avatar":"https://static001.geekbang.org/account/avatar/00/13/fa/34/8091ae3f.jpg","nickname":"茉莉清可乐对奶茶","note":"","ucode":"A7D48223EB473D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531677,"discussion_content":"牛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637381000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1624355,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c9/23/76511858.jpg","nickname":"洛奇","note":"","ucode":"662B4005721119","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363558,"discussion_content":"厉害！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617237480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86651,"user_name":"木卫六","can_delete":false,"product_type":"c1","uid":1199495,"ip_address":"","ucode":"D113DF578C5BF5","user_header":"https://static001.geekbang.org/account/avatar/00/12/4d/87/57236a2d.jpg","comment_is_top":false,"comment_ctime":1555418871,"is_pvip":true,"replies":[{"id":"31159","content":"我也觉得没有ABA问题","user_name":"作者回复","comment_id":86651,"uid":"1269969","ip_address":"","utype":1,"ctime":1555423790,"user_name_real":"王宝令"}],"discussion_count":2,"race_medal":0,"score":"53095026423","product_id":100023901,"comment_content":"首先，or=rf.get()需要放到do{}，每次需要重新获取，以防其他线程更新过导致死循环；<br><br>然后，nr是new的，我觉得应该不会发生ABA的问题（reference的compareAndSet比较的是内存地址）。另外ABA问题应该容易发生在值类型上吧，引用类型的应该几乎不会发生？对于引用类型，几乎不会发生经过至少两次new对象，最后对象放在了同一块or之前使用的内存区块上吧？<br>","like_count":12,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447109,"discussion_content":"我也觉得没有ABA问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555423790,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1438585,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f3/79/f9a2c983.jpg","nickname":"东方未曦","note":"","ucode":"C19EFEFA25318D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332834,"discussion_content":"如果是享元模式，对象不一定是new出来的，而是指向同一个，就会有ABA问题","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1607352509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86588,"user_name":"andy","can_delete":false,"product_type":"c1","uid":1063321,"ip_address":"","ucode":"F03BE5E20B471C","user_header":"https://static001.geekbang.org/account/avatar/00/10/39/99/42929758.jpg","comment_is_top":false,"comment_ctime":1555404613,"is_pvip":false,"replies":[{"id":"31148","content":"对👍<br><br>","user_name":"作者回复","comment_id":86588,"uid":"1269969","ip_address":"","utype":1,"ctime":1555411987,"user_name_real":"王宝令"}],"discussion_count":4,"race_medal":0,"score":"53095012165","product_id":100023901,"comment_content":"public class SafeWM {<br>  class WMRange{<br>    final int upper;<br>    final int lower;<br>    WMRange(int upper,int lower){<br>    &#47;&#47; 省略构造函数实现<br>    }<br>  }<br>  final AtomicReference&lt;WMRange&gt;<br>    rf = new AtomicReference&lt;&gt;(<br>      new WMRange(0,0)<br>    );<br>  &#47;&#47; 设置库存上限<br>  void setUpper(int v){<br>    WMRange nr;<br>    WMRange or;<br>    do{<br>\t  or = rf.get();<br>      &#47;&#47; 检查参数合法性<br>      if(v &lt; or.lower){<br>        throw new IllegalArgumentException();<br>      }<br>      nr = new<br>        WMRange(v, or.lower);<br>    }while(!rf.compareAndSet(or, nr));<br>  }<br>}<br><br> 这样子对吗？","like_count":12,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447084,"discussion_content":"对👍\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555411987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1101615,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/2f/4f89f22a.jpg","nickname":"李鑫磊","note":"","ucode":"D06517CFCEEE00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7967,"discussion_content":"这和老师写的有区别吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567742881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1258399,"avatar":"https://static001.geekbang.org/account/avatar/00/13/33/9f/8dbd9558.jpg","nickname":"逆流的鱼","note":"","ucode":"AA3DDE44A83C40","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6415,"discussion_content":"不是说属性要volatile的吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566892129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1258399,"avatar":"https://static001.geekbang.org/account/avatar/00/13/33/9f/8dbd9558.jpg","nickname":"逆流的鱼","note":"","ucode":"AA3DDE44A83C40","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574118,"discussion_content":"final 也可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653835675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":6415,"ip_address":""},"score":574118,"extra":""}]}]},{"had_liked":false,"id":86329,"user_name":"郑晨Cc","can_delete":false,"product_type":"c1","uid":1324942,"ip_address":"","ucode":"57146E444D6329","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/8e/cf0b4575.jpg","comment_is_top":false,"comment_ctime":1555355133,"is_pvip":false,"replies":[{"id":"31050","content":"👍，不过我觉得没必要用atomicfieldreference","user_name":"作者回复","comment_id":86329,"uid":"1269969","ip_address":"","utype":1,"ctime":1555387779,"user_name_real":"王宝令"}],"discussion_count":3,"race_medal":0,"score":"48799995389","product_id":100023901,"comment_content":"or是原始的 nr是new出来的 指向不同的内存地址 compareandset的结果永远返回false 结果是死循环？是不是应该用atomicfieldreference？","like_count":11,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446972,"discussion_content":"👍，不过我觉得没必要用atomicfieldreference","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555387779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1624590,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ca/0e/5009c5ff.jpg","nickname":"遇见","note":"","ucode":"FAF53CD4C28494","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214563,"discussion_content":"不是死循环，是为了保证把or修改成nr的时候， 实际的值仍然是or， 没有被另外的线程修改。这个问题的bug在于应该每次都拿实际值赋值给or。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585208500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1786788,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJINWmZjibZA4eibL31PzMDia2yt1icOc9QnFWwTKuXbWTFCAZaMgCrqO7Oa5sZka81pHoibPgSM8nCjibA/132","nickname":"超能力先生","note":"","ucode":"C042DB628CAA86","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":117508,"discussion_content":"compareAndSet不是比较or与nr吧，or是与实际值比较，nr是你想要的新值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578123426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90760,"user_name":"随风而逝","can_delete":false,"product_type":"c1","uid":1447169,"ip_address":"","ucode":"4E4D46905697AB","user_header":"https://static001.geekbang.org/account/avatar/00/16/15/01/927d96e5.jpg","comment_is_top":false,"comment_ctime":1556628711,"is_pvip":false,"replies":[{"id":"32575","content":"无效","user_name":"作者回复","comment_id":90760,"uid":"1269969","ip_address":"","utype":1,"ctime":1556700332,"user_name_real":"王宝令"}],"discussion_count":3,"race_medal":0,"score":"31621399783","product_id":100023901,"comment_content":"老师，这些原子操作类在分布式程序中还有效吗？","like_count":7,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448641,"discussion_content":"无效","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556700332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1118952,"avatar":"https://static001.geekbang.org/account/avatar/00/11/12/e8/aa60f7f1.jpg","nickname":"赵存金","note":"","ucode":"89D69F8D2DF269","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319263,"discussion_content":"哈哈哈 一针见血","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603976039,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1053498,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/3a/b0454322.jpg","nickname":"Eric","note":"","ucode":"59752A51A382A6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":176554,"discussion_content":"两个层面的东西","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582037453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91005,"user_name":"xuery","can_delete":false,"product_type":"c1","uid":1027584,"ip_address":"","ucode":"F461B61BE06131","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/00/025f37e7.jpg","comment_is_top":false,"comment_ctime":1556781673,"is_pvip":true,"replies":[{"id":"32624","content":"👍","user_name":"作者回复","comment_id":91005,"uid":"1269969","ip_address":"","utype":1,"ctime":1556787233,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"27326585449","product_id":100023901,"comment_content":"例子中的模拟CAS，cas函数是加了锁的，保证整个操作的原子性；我的理解是这个只是一个模拟，实际中肯定不会加上锁的","like_count":6,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448761,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556787233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86856,"user_name":"刘志兵","can_delete":false,"product_type":"c1","uid":1441734,"ip_address":"","ucode":"A90C2FA49EDC23","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/c6/8b5cbe97.jpg","comment_is_top":false,"comment_ctime":1555466948,"is_pvip":false,"replies":[{"id":"31304","content":"最终依赖的是cpu提供的原子指令，不用我们操心。","user_name":"作者回复","comment_id":86856,"uid":"1269969","ip_address":"","utype":1,"ctime":1555510617,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"27325270724","product_id":100023901,"comment_content":"老师，compareAndSwapLong方法是一个native方法，比较共享变量和expect值是否相等，相等才设置新的值x, 不明白这里的对比是怎么保证原子性的，对比也是要再读一次共享变量，然后对比吧，如果先读出来之后对比的时候被其他线程修改了，那还是会有问题","like_count":6,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447213,"discussion_content":"最终依赖的是cpu提供的原子指令，不用我们操心。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555510617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142049,"user_name":"刘育飞","can_delete":false,"product_type":"c1","uid":1363642,"ip_address":"","ucode":"06600614E898CC","user_header":"https://static001.geekbang.org/account/avatar/00/14/ce/ba/f73555c7.jpg","comment_is_top":false,"comment_ctime":1571283926,"is_pvip":true,"replies":[{"id":"54920","content":"cas大部分都是CPU提供的指令，这里只是模拟它的原理","user_name":"作者回复","comment_id":142049,"uid":"1269969","ip_address":"","utype":1,"ctime":1571361953,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"23046120406","product_id":100023901,"comment_content":" 不明白     synchronized int cas() 这不是已经用了 同步synchronized 关键字 吗怎么会 无锁 无堵塞呢","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470967,"discussion_content":"cas大部分都是CPU提供的指令，这里只是模拟它的原理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571361953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107141,"user_name":"Vincent","can_delete":false,"product_type":"c1","uid":1189765,"ip_address":"","ucode":"F0A32C9210FF42","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/85/06fbdeac.jpg","comment_is_top":false,"comment_ctime":1561466962,"is_pvip":true,"replies":[{"id":"38932","content":"局部变量不存在线程安全问题","user_name":"作者回复","comment_id":107141,"uid":"1269969","ip_address":"","utype":1,"ctime":1561596038,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":1,"score":"23036303442","product_id":100023901,"comment_content":"第一个例子也不是线程安全的吧？i++这个操作不是线程安全的，会导致判断错误吧？","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455382,"discussion_content":"局部变量不存在线程安全问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561596038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86382,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1555374383,"is_pvip":false,"replies":[{"id":"31046","content":"👍","user_name":"作者回复","comment_id":86382,"uid":"1269969","ip_address":"","utype":1,"ctime":1555387328,"user_name_real":"王宝令"}],"discussion_count":2,"race_medal":0,"score":"18735243567","product_id":100023901,"comment_content":"我觉得可能会出现死循环。WMRange or = rf.get(); 应该放在do里面。每次比较交换失败后，重新获取一次。","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446996,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555387328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1651848,"avatar":"","nickname":"Geek_039a5c","note":"","ucode":"08F4FA864D4B65","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547947,"discussion_content":"cas  自己不会循环获取一次 预期值吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642949908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131272,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1567688054,"is_pvip":false,"replies":[{"id":"49595","content":"👍","user_name":"作者回复","comment_id":131272,"uid":"1269969","ip_address":"","utype":1,"ctime":1567690739,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"14452589942","product_id":100023901,"comment_content":"感觉理解好了volatile和CAS，这些原子类就都好理解了","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466362,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567690739,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95147,"user_name":"考休","can_delete":false,"product_type":"c1","uid":1053955,"ip_address":"","ucode":"968DFC00D6D0CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg","comment_is_top":false,"comment_ctime":1557974592,"is_pvip":false,"replies":[{"id":"33988","content":"我觉得可以","user_name":"作者回复","comment_id":95147,"uid":"1269969","ip_address":"","utype":1,"ctime":1557980483,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"14442876480","product_id":100023901,"comment_content":"cas的实现原理感觉跟乐观锁有相似的地方，不知道是不是可以这么理解","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450345,"discussion_content":"我觉得可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557980483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88077,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1555840107,"is_pvip":false,"replies":[{"id":"31710","content":"👍","user_name":"作者回复","comment_id":88077,"uid":"1269969","ip_address":"","utype":1,"ctime":1555894199,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"14440741995","product_id":100023901,"comment_content":"课后习题：如果在do{}while()第一次没设置成功，即对象已经被其他线程修改，or已经是过期的对象，导致死循环，可以写成如：<br>public class SafeWM {<br>  class WMRange{<br>    final int upper;<br>    final int lower;<br>    WMRange(int upper,int lower){<br>\tif(upper &lt; lower){<br>        \t\tthrow new IllegalArgumentException();<br>      \t}<br>    &#47;&#47; 省略构造函数实现<br>    }<br>  }<br>  final AtomicReference&lt;WMRange&gt;<br>    rf = new AtomicReference&lt;&gt;(<br>      new WMRange(0,0)<br>    );<br>  &#47;&#47; 设置库存上限<br>  void setUpper(int v){<br>    WMRange nr;<br>    WMRange or;<br>    do{ <br>      or = = rf.get();<br>      nr = new<br>        WMRange(v, or.lower);<br>    }while(!rf.compareAndSet(or, nr));<br>  }<br>}","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447715,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555894199,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224050,"user_name":"与海同宽","can_delete":false,"product_type":"c1","uid":1312701,"ip_address":"","ucode":"2F1D3411C96898","user_header":"https://static001.geekbang.org/account/avatar/00/14/07/bd/9e8d1cff.jpg","comment_is_top":false,"comment_ctime":1591262955,"is_pvip":false,"replies":[{"id":"82611","content":"创建线程是个费时的操作，而线程执行期间太短，所以并发度不高。可以在线程执行方法内部加循环试试","user_name":"作者回复","comment_id":224050,"uid":"1269969","ip_address":"","utype":1,"ctime":1591414753,"user_name_real":"王宝令"}],"discussion_count":4,"race_medal":0,"score":"10181197547","product_id":100023901,"comment_content":"老师，您好，我有个关于AtomicXXX源码的问题，我将AtomicXXX某一个源码复制出来，并进行相关的测试，发现value这个属性加和不加volatile关键字最终的测试结果都是一致的(所以就妄自猜测该关键字是多余的，但是我知道这肯定不可能)，如下是我的测试类，AtomicInteger两次的测试不同在于加和不加volatile关键字，希望老师能答复，这个问题快把我憋出内伤来了<br>    &#47;&#47; JDK 1.8<br>    private static final AtomicInteger atomicInteger = new AtomicInteger(0);<br>    public static void main(String[] args) throws InterruptedException {<br>        for(int i = 0; i &lt; 10000; i++) {<br>            new Thread(() -&gt; {<br>                atomicInteger.incrementAndGet();<br>            }).start();<br>        }<br>        Thread.sleep(1000);<br>        System.out.println(atomicInteger.get());<br>    }","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497346,"discussion_content":"创建线程是个费时的操作，而线程执行期间太短，所以并发度不高。可以在线程执行方法内部加循环试试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591414753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1255574,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqgVXa8DyW0YsrdYtPNMOdGH6hfdwfjwyBPRyoc9yuS4Ml18l0kApOoOKwYkF6NlDPYpX1bVEWomw/132","nickname":"最摇摆的鱼","note":"","ucode":"DA19F4C4224719","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409576,"discussion_content":"查了一下，如果不是经常变换automicinteger的引用的话不需要使用volatile。automicinteger已经保证了可见性，老师后面的讲解也提到了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635470454,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1255574,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqgVXa8DyW0YsrdYtPNMOdGH6hfdwfjwyBPRyoc9yuS4Ml18l0kApOoOKwYkF6NlDPYpX1bVEWomw/132","nickname":"最摇摆的鱼","note":"","ucode":"DA19F4C4224719","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409570,"discussion_content":"我也有这个问题，AtomicInteger前面还需要volatile关键字吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635469967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1441569,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ff/21/8815d2e5.jpg","nickname":"亮子","note":"","ucode":"DF37D5E0714D02","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1255574,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqgVXa8DyW0YsrdYtPNMOdGH6hfdwfjwyBPRyoc9yuS4Ml18l0kApOoOKwYkF6NlDPYpX1bVEWomw/132","nickname":"最摇摆的鱼","note":"","ucode":"DA19F4C4224719","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":544258,"discussion_content":"本身就是安全的，不需要volatile","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641450265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":409570,"ip_address":""},"score":544258,"extra":""}]}]},{"had_liked":false,"id":179602,"user_name":"Eric","can_delete":false,"product_type":"c1","uid":1053498,"ip_address":"","ucode":"59752A51A382A6","user_header":"https://static001.geekbang.org/account/avatar/00/10/13/3a/b0454322.jpg","comment_is_top":false,"comment_ctime":1582037731,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10171972323","product_id":100023901,"comment_content":"请问  unsafe.getAndAddLong()中是如何解决ABA问题的？","like_count":2},{"had_liked":false,"id":152845,"user_name":"东风第一枝","can_delete":false,"product_type":"c1","uid":1402697,"ip_address":"","ucode":"0CD0F62E90DAD8","user_header":"https://static001.geekbang.org/account/avatar/00/15/67/49/864dba17.jpg","comment_is_top":false,"comment_ctime":1574088531,"is_pvip":false,"replies":[{"id":"59688","content":"这段代码所在的方法是synchronized😂","user_name":"作者回复","comment_id":152845,"uid":"1269969","ip_address":"","utype":1,"ctime":1574729396,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"10164023123","product_id":100023901,"comment_content":"&#47;&#47; 比较目前count值是否==期望值    <br>if(curValue == expect){      <br>&#47;&#47; 如果是，则更新count的值      <br>count= newValue;    <br>}<br>==========<br>这段代码老师说是仅用来帮助理解，实际上这个是存在竞态条件的，如果在if执行完之后，count的值被别的变量修改，那么结果就不正确了。想找老师确认一下我理解的对不对？","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474960,"discussion_content":"这段代码所在的方法是synchronized😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574729396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97385,"user_name":"Sean","can_delete":false,"product_type":"c1","uid":1242497,"ip_address":"","ucode":"2521FB6292F304","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/81/92d01e3a.jpg","comment_is_top":false,"comment_ctime":1558663054,"is_pvip":false,"replies":[{"id":"34844","content":"v是上限，下限不变，没问题","user_name":"作者回复","comment_id":97385,"uid":"1269969","ip_address":"","utype":1,"ctime":1558672954,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"10148597646","product_id":100023901,"comment_content":"设置上限为什么是WMRange(v, or.lower);? 是笔误还是我理解错了？","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451261,"discussion_content":"v是上限，下限不变，没问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558672954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87316,"user_name":"Mark","can_delete":false,"product_type":"c1","uid":1125474,"ip_address":"","ucode":"01437C4021E82E","user_header":"https://static001.geekbang.org/account/avatar/00/11/2c/62/b5fcbf2b.jpg","comment_is_top":false,"comment_ctime":1555566579,"is_pvip":false,"replies":[{"id":"31549","content":"有这种可能","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555675635,"ip_address":"","comment_id":87316,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5850533875","product_id":100023901,"comment_content":"请教一个问题<br>compareAndSwapLong 更新完后返回的是true false，再return v。这是两步操作，return v之前，内存值有可能已经被该了，不是v了。<br>有这种可能吗？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447395,"discussion_content":"有这种可能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555675635,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86512,"user_name":"小萝卜","can_delete":false,"product_type":"c1","uid":1033008,"ip_address":"","ucode":"2D51E0D8B4A3F9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c3/30/6ae57626.jpg","comment_is_top":false,"comment_ctime":1555386989,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5850354285","product_id":100023901,"comment_content":"第16行应该放在循环体内","like_count":1},{"had_liked":false,"id":86417,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1555376721,"is_pvip":false,"replies":[{"id":"31041","content":"等价的<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555386140,"ip_address":"","comment_id":86417,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5850344017","product_id":100023901,"comment_content":"对文中 的 do{}while()循环有点困惑，为什么不是while(){}?","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447010,"discussion_content":"等价的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555386140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":349853,"user_name":"buynow","can_delete":false,"product_type":"c1","uid":1105118,"ip_address":"","ucode":"655871D1E6CB15","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/OkKvEddT1v8sKic6XrJEib3FoMxsyKMpT9znC3qicl9iaFj2B5MZ23kYkhmkUUJrhd2VNrnkpwxMRHbC9rBwibFc5Kg/132","comment_is_top":false,"comment_ctime":1656386909,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656386909","product_id":100023901,"comment_content":"CAS和加锁操作在各种不同场景性能区别是什么","like_count":0},{"had_liked":false,"id":347924,"user_name":"月明风清","can_delete":false,"product_type":"c1","uid":2226367,"ip_address":"","ucode":"65A97CF2E320FA","user_header":"https://static001.geekbang.org/account/avatar/00/21/f8/bf/59f2e600.jpg","comment_is_top":false,"comment_ctime":1654585724,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654585724","product_id":100023901,"comment_content":"我想问一下，什么场景下需要关心 ABA 问题呢，可不可以举个实例的例子。","like_count":0},{"had_liked":false,"id":347923,"user_name":"月明风清","can_delete":false,"product_type":"c1","uid":2226367,"ip_address":"","ucode":"65A97CF2E320FA","user_header":"https://static001.geekbang.org/account/avatar/00/21/f8/bf/59f2e600.jpg","comment_is_top":false,"comment_ctime":1654585522,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654585522","product_id":100023901,"comment_content":"我想问一下，什么场景下不需要关注 ABA 问题呢？能不能举个实际的例子。","like_count":0},{"had_liked":false,"id":335590,"user_name":"守护我的敌人痛击我的队友","can_delete":false,"product_type":"c1","uid":1266754,"ip_address":"","ucode":"670EDBA2ADE37B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKsYRmTSDl6eYB1u3afF26TCbFRQFUocpQajGdlU84icFmvsF6K4hYg30faTcYeH2Jnw7TWNu0Nd1w/132","comment_is_top":false,"comment_ctime":1645597901,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645597901","product_id":100023901,"comment_content":"萨达","like_count":0},{"had_liked":false,"id":327878,"user_name":"凯文小猪","can_delete":false,"product_type":"c1","uid":1980201,"ip_address":"","ucode":"36D8AD0229547F","user_header":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","comment_is_top":false,"comment_ctime":1640336264,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640336264","product_id":100023901,"comment_content":"加锁、解锁操作本身就消耗性能；同时拿不到锁的线程还会进入阻塞状态，进而触发线程切换，线程切换对性能的消耗也很大。<br><br>这一点一直是误导很多人的，加解锁本身只是调用系统库函数 进入保护模式 启用内存页保护地址 保存寄存器而已。<br>而传统的系统库函数都是在几十ns级别可完成。而加锁失败也只是扔到阻塞链表里而已<br>所以锁的问题实际上是两类：<br>1.频繁调用锁引发的线程切换 这个是与数量级成正相关的 所以如果只是两两线程之间 或者n个（数量有限）线程的情况下 ，试想我们代码中所有的读写io DMA拷贝都是库函数调用<br>2.对于锁的掌控 如死锁，加锁失败处理。临界区掺杂其他IO操作 导致锁短时间内无法释放 ，是大多数人畏惧锁的原因<br>","like_count":0},{"had_liked":false,"id":316668,"user_name":"小钢炮","can_delete":false,"product_type":"c1","uid":2029015,"ip_address":"","ucode":"676C4CCF3CCD0D","user_header":"","comment_is_top":false,"comment_ctime":1634481608,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634481608","product_id":100023901,"comment_content":"CAS的自旋每次都应该从内存中读取最新的值判断","like_count":0},{"had_liked":false,"id":304143,"user_name":"Geek_e6f358","can_delete":false,"product_type":"c1","uid":1855137,"ip_address":"","ucode":"C21E94A90258A2","user_header":"","comment_is_top":false,"comment_ctime":1627271717,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1627271717","product_id":100023901,"comment_content":" WMRange or = rf.get();应该放在do里面，每次循环都重新获取最新的值，否则or会指向旧引用，从而一直自旋下去","like_count":0},{"had_liked":false,"id":291914,"user_name":"纽扣","can_delete":false,"product_type":"c1","uid":1313813,"ip_address":"","ucode":"870A1E731E1C02","user_header":"https://static001.geekbang.org/account/avatar/00/14/0c/15/ad1d202c.jpg","comment_is_top":false,"comment_ctime":1620606365,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1620606365","product_id":100023901,"comment_content":"老师您好，请问：CAS有可能因为无限自旋导致活锁问题这个可以理解，但是饥饿问题是如何导致的呢？","like_count":0,"discussions":[{"author":{"id":2420294,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ee/46/7d65ae37.jpg","nickname":"木几丶","note":"","ucode":"FFDB958DA64F8C","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390840,"discussion_content":"非公平锁，导致一直拿不到锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630073944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":286264,"user_name":"洛奇","can_delete":false,"product_type":"c1","uid":1624355,"ip_address":"","ucode":"662B4005721119","user_header":"https://static001.geekbang.org/account/avatar/00/18/c9/23/76511858.jpg","comment_is_top":false,"comment_ctime":1617236592,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617236592","product_id":100023901,"comment_content":"不是太懂，为什么共享变量的对象引用的更新也需要原子化？","like_count":0},{"had_liked":false,"id":282041,"user_name":"俺能学个啥","can_delete":false,"product_type":"c1","uid":1026742,"ip_address":"","ucode":"30740C5B58774C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/b6/46a5bbf3.jpg","comment_is_top":false,"comment_ctime":1615025839,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615025839","product_id":100023901,"comment_content":"CAS操作将rf的引用由or替换为nr失败后，说明其他线程修改了原子引用，则需要获取最新的原子引用再次重试，但获取操作在循环体外，故如果CAS失败会陷入死循环，成功的话就直接跳出，可以把获取原子引用操作置于循环体内","like_count":0},{"had_liked":false,"id":270462,"user_name":"poordickey","can_delete":false,"product_type":"c1","uid":1810156,"ip_address":"","ucode":"2A436EC813AF97","user_header":"","comment_is_top":false,"comment_ctime":1609137874,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609137874","product_id":100023901,"comment_content":"不得不说  这课程比看书好太多了  书本总是讲究全面系统  而不是行如流水带着解决问题的思路去讲解知识点  很棒  老师内功真的很不错","like_count":0},{"had_liked":false,"id":263889,"user_name":"瓶子霸哥","can_delete":false,"product_type":"c1","uid":1125806,"ip_address":"","ucode":"A7EEB459AB5550","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/nVVI6Fib5LHbhAhv8CJ9MYPau7Lcp840ST6BeqnlibUNmI4UYvGIzxtOHcKIzFa10ERANAZQUaiaKkQg4SowsUR2g/132","comment_is_top":false,"comment_ctime":1606288352,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606288352","product_id":100023901,"comment_content":"我看到 AtomicReference 有个 updateAndGet() 方法，但是里面没有用 CAS. 是为什么啊？我贴一下 AtomicReference#updateAndGet 的实现<br>    &#47;**<br>     * Atomically updates (with memory effects as specified by {@link<br>     * VarHandle#compareAndSet}) the current value with the results of<br>     * applying the given function, returning the updated value. The<br>     * function should be side-effect-free, since it may be re-applied<br>     * when attempted updates fail due to contention among threads.<br>     *<br>     * @param updateFunction a side-effect-free function<br>     * @return the updated value<br>     * @since 1.8<br>     *&#47;<br>    public final V updateAndGet(UnaryOperator&lt;V&gt; updateFunction) {<br>        V prev = get(), next = null;<br>        for (boolean haveNext = false;;) {<br>            if (!haveNext)<br>                next = updateFunction.apply(prev);<br>            if (weakCompareAndSetVolatile(prev, next))<br>                return next;<br>            haveNext = (prev == (prev = get()));<br>        }<br>    }","like_count":0},{"had_liked":false,"id":251234,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1601432658,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1601432658","product_id":100023901,"comment_content":"CAS每次自旋必须要重新检查新的值才有意义","like_count":0},{"had_liked":false,"id":245417,"user_name":"fightingD","can_delete":false,"product_type":"c1","uid":1443637,"ip_address":"","ucode":"AD2876CED5D5AC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKwViav94kcF50CxA0Jw7icicxociaVzut97iacy3b2ciacFqXuFWdiakVq304YcI8pt4HT5A1Yvp8EkYCpw/132","comment_is_top":false,"comment_ctime":1598940807,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598940807","product_id":100023901,"comment_content":"应该有问题，原子化的对象引用能保证引用对象的原子更新，但是当有竞态条件的时候还是需要用互斥锁来处理。","like_count":0},{"had_liked":false,"id":239011,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1596414955,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596414955","product_id":100023901,"comment_content":"根据模拟代码来看，cpu保证的原子性的步骤一共三个。1.读取count的值，赋值给curcount. 2.比较count和curcount值是否一致 3.将计算后的新值赋值给count  一共三个步骤。原本的疑惑是既然可以保证三个指令的原子性，那为何不能保证两个操作的原子性呢(1.读取count值 2.计算后的新值赋值给count值)  后面阅读到自旋的时候明白了，其实cpu也不能保证三个指令组合的原子性，也只能一条一条的保证。","like_count":0},{"had_liked":false,"id":231409,"user_name":"Geek_41d472","can_delete":false,"product_type":"c1","uid":1247965,"ip_address":"","ucode":"DEC2B6329460CF","user_header":"https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg","comment_is_top":false,"comment_ctime":1593670772,"is_pvip":false,"replies":[{"id":"85621","content":"Unsafe的命名和多线程应该没有关系😂","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1593836288,"ip_address":"","comment_id":231409,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593670772","product_id":100023901,"comment_content":"专栏买了好久了一直没看完,最近才有时间看到这里,不知道老师还关注这个专栏问题吗,我还是抱着试试心态,万一老师还关注呢.<br>我现在的问题是,原子类unsafe.getAndAddLong() ,从名字是看 unsafe就是不安全的意思,那么调用这个方法线程到底安不全呢?不然为何会这样命名?","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500291,"discussion_content":"Unsafe的命名和多线程应该没有关系😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593836288,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":227166,"user_name":"设计模式并发编程","can_delete":false,"product_type":"c1","uid":2020762,"ip_address":"","ucode":"9EB371149F19EF","user_header":"https://static001.geekbang.org/account/avatar/00/1e/d5/9a/515fd6f2.jpg","comment_is_top":false,"comment_ctime":1592303084,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592303084","product_id":100023901,"comment_content":"如果 cas(count,newValue) 返回的值不等于 count，则意味着线程在执行完代码①处之后，执行代码②处之前，count 的值被其他线程更新过。<br>---------    这句话是不是说错了啊？”不等于“应该改成“等于” ","like_count":0},{"had_liked":false,"id":226870,"user_name":"古夜","can_delete":false,"product_type":"c1","uid":1341612,"ip_address":"","ucode":"0A82D3CFCEDF07","user_header":"https://static001.geekbang.org/account/avatar/00/14/78/ac/e5e6e7f3.jpg","comment_is_top":false,"comment_ctime":1592220302,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592220302","product_id":100023901,"comment_content":"<br>class SimulatedCAS{<br>  int count；<br>  synchronized int cas(<br>    int expect, int newValue){<br>    &#47;&#47; 读目前count的值<br>    int curValue = count;<br>    &#47;&#47; 比较目前count值是否==期望值<br>    if(curValue == expect){<br>      &#47;&#47; 如果是，则更新count的值<br>      count = newValue;<br>    }<br>    &#47;&#47; 返回写入前的值<br>    return curValue;<br>  }<br>}<br><br>为什么要返回旧值呢？","like_count":0},{"had_liked":false,"id":212849,"user_name":"better","can_delete":false,"product_type":"c1","uid":1169063,"ip_address":"","ucode":"AF1DB566EBB8A5","user_header":"https://static001.geekbang.org/account/avatar/00/11/d6/a7/ac23f5a6.jpg","comment_is_top":false,"comment_ctime":1588224355,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588224355","product_id":100023901,"comment_content":"老师，我感觉 compareAndSwapLong() 此natvie方法中，应该会继续获取最新的 value 值吧，不然会造成死循环的感觉，对比您的示例代码例子，也有重新获取 value 值。","like_count":0},{"had_liked":false,"id":185719,"user_name":"Alex","can_delete":false,"product_type":"c1","uid":1024763,"ip_address":"","ucode":"F6B5C64BC99FB7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a2/fb/94af9cf1.jpg","comment_is_top":false,"comment_ctime":1583670368,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583670368","product_id":100023901,"comment_content":"16行应放循环内，如果有其他线程修改成功，那么每次都是rf的最新对象跟旧对象比较进入死循环","like_count":0},{"had_liked":false,"id":170830,"user_name":"乾坤瞬间","can_delete":false,"product_type":"c1","uid":1683130,"ip_address":"","ucode":"15BDCF29CBF8EB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","comment_is_top":false,"comment_ctime":1578733639,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578733639","product_id":100023901,"comment_content":"CAS理解的关键所在A为内存中上次的值，由于可见性问题，线程处理A的时候，会加载到当前线程中的工作空间中，因此。下次更新的的时候，只要保证当前的A与工作空间中的值一直的时候才能拥有被更新的操作，同时读内存的值与写内存值的操作必须要互斥，否则，在更新值的同时有一个线程T读取了内存相关的内存值，此时，T线程仍然会更新，这个是如何实现的？","like_count":0},{"had_liked":false,"id":153770,"user_name":"朕爱吾妃","can_delete":false,"product_type":"c1","uid":1733692,"ip_address":"","ucode":"B10EB69934F9E2","user_header":"https://static001.geekbang.org/account/avatar/00/1a/74/3c/da79d2a1.jpg","comment_is_top":false,"comment_ctime":1574304874,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574304874","product_id":100023901,"comment_content":"WMRange or = rf.get();这句话不放入do-while里这个or值一直不会发生变化，也就是如果在获取or这个之后，修改这个值之前，有其他线程进行值的修改，这样比较的时候就会出现与期望值不一样的情况，然后循环，这时候or还是没有修改，还是与期望值不一样，然后再次循环... ...，这样这个线程就会进行死循环，如果是实际项目中的话，应该会触发超时","like_count":0},{"had_liked":false,"id":148506,"user_name":"考休","can_delete":false,"product_type":"c1","uid":1053955,"ip_address":"","ucode":"968DFC00D6D0CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg","comment_is_top":false,"comment_ctime":1573020565,"is_pvip":false,"replies":[{"id":"57246","content":"你比较的是getandincrement和++的性能😂","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1573047973,"ip_address":"","comment_id":148506,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1573020565","product_id":100023901,"comment_content":"老师，为什么我用synchronized实现的add10k方法执行要比使用AtomicInteger的执行更快呢，不应该采用AtomicInteger更快才对吗？<br><br>synchronized：<br>public synchronized void add10k() {<br>            int idx = 0;<br>            while (idx &lt; 100000000) {<br>                count++;<br>                idx++;<br>      }<br>}<br><br>AtomicInteger:<br><br>AtomicInteger count = new AtomicInteger(0);<br>    public void add10k() {<br>        int idx = 0;<br>        while (idx &lt; 100000000) {<br>            count.getAndIncrement();<br>            idx++;<br>        }<br>    }","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473515,"discussion_content":"你比较的是getandincrement和++的性能😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573047973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1895314,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/STqKg1kLgvRuduQfo0R2E2osYBian7XrQAjSWmOwL9nyZVhq7vyLPnlGcgvguFV4aV7ToWLFiauEMKy96KWHKBVg/132","nickname":"离境”","note":"","ucode":"7186EF2BEF8956","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377924,"discussion_content":"频繁更新，加锁应该更快一点吧，我的实验结果也是这样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622965016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1053955,"avatar":"https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg","nickname":"考休","note":"","ucode":"968DFC00D6D0CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":45556,"discussion_content":"应该是一万个线程每个加一，而不是一个线程加一万，我真是傻了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573048809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136537,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1569466465,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1569466465","product_id":100023901,"comment_content":"两个问题：<br>1、compareAndSet每次和new 出来的object比较，永远不会相等，会出现死循环，这里比较的应该是oldValue和newValue,并使用cas方法对符合条件的值做更新。<br>2、cas的完整过程应该是取出oldValue-&gt;比较-&gt;符合条件则用cas操作更新，也就是代码中的rf.get应该放在循环里。也就是说不能割裂对共享资源的CAS操作，不然并发时会有ABA问题","like_count":0},{"had_liked":false,"id":132277,"user_name":".","can_delete":false,"product_type":"c1","uid":1194614,"ip_address":"","ucode":"2FBBAB303A4D5A","user_header":"https://static001.geekbang.org/account/avatar/00/12/3a/76/e9f18792.jpg","comment_is_top":false,"comment_ctime":1568077808,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568077808","product_id":100023901,"comment_content":"此处原意应该是想考察or变量再CAS后如果不匹配，需要重新再次获取新的值，即WMRange or = rf.get()这条语句应该放到do{}while();的第一句。但问题的关键其实这里由于后面的nr是new出来的，所以rf.compareAndSet(or, nr)按地址进行比较无论如何都是不等的，死循环。","like_count":0},{"had_liked":false,"id":116754,"user_name":"james","can_delete":false,"product_type":"c1","uid":1260477,"ip_address":"","ucode":"CB62CF7C4EF92D","user_header":"https://static001.geekbang.org/account/avatar/00/13/3b/bd/f9f780a4.jpg","comment_is_top":false,"comment_ctime":1563905582,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563905582","product_id":100023901,"comment_content":"无锁方案的原理后的第二个SimulatedCAS类中，就算只有一个线程累加count，第一次循环cas的返回值不等于count，然后再进行一次循环，count才与cas的返回值相等，我这样理解对吧？","like_count":0},{"had_liked":false,"id":114975,"user_name":"齐","can_delete":false,"product_type":"c1","uid":1486566,"ip_address":"","ucode":"378B273955095D","user_header":"https://static001.geekbang.org/account/avatar/00/16/ae/e6/58f30bb3.jpg","comment_is_top":false,"comment_ctime":1563440735,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1563440735","product_id":100023901,"comment_content":"WMRange or = rf.get();放到do while循环内部，因为cas失败之后需获取最新的引用值再重新进行cas，即自旋。","like_count":0},{"had_liked":false,"id":103876,"user_name":"何妨","can_delete":false,"product_type":"c1","uid":1385377,"ip_address":"","ucode":"EC3983BFF7992A","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","comment_is_top":false,"comment_ctime":1560558345,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560558345","product_id":100023901,"comment_content":"在count+=1的那个例子，不会存在线程a在验证等于期望值后赋值之前，线程b在这之间也验证成功，然后两个线程本身应该总体+2结果+1的情况么","like_count":0},{"had_liked":false,"id":103451,"user_name":"金子般的心","can_delete":false,"product_type":"c1","uid":1006897,"ip_address":"","ucode":"8F6F217AF0C0EA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5d/31/2ccc4675.jpg","comment_is_top":false,"comment_ctime":1560438032,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1560438032","product_id":100023901,"comment_content":"期望值是怎么来的？怎么知道期望值？","like_count":0,"discussions":[{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":48290,"discussion_content":"变量初始值为1，每次加1，第一次运算时的期望值就是1+1=2","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573471593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96642,"user_name":"Hour","can_delete":false,"product_type":"c1","uid":1448748,"ip_address":"","ucode":"AA1045ACABC0BB","user_header":"https://static001.geekbang.org/account/avatar/00/16/1b/2c/6b3c0911.jpg","comment_is_top":false,"comment_ctime":1558483770,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558483770","product_id":100023901,"comment_content":"赞!赞!赞!","like_count":0},{"had_liked":false,"id":96187,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1558353296,"is_pvip":false,"replies":[{"id":"34427","content":"这种情况就不能用它了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558357755,"ip_address":"","comment_id":96187,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558353296","product_id":100023901,"comment_content":"AtomicMarkableReference 麻烦问下，这个能解决ABA问题吗？？<br>例如：初始值   1   false， <br>线程A来改期望1  false。  结果中途被线程BC来修改了。<br>线程B改后结果 2 true<br>线程C改后结果 1 flase。<br>此时，线程A还修改成功。<br>","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450758,"discussion_content":"这种情况就不能用它了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558357755,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92271,"user_name":"XYW","can_delete":false,"product_type":"c1","uid":1445285,"ip_address":"","ucode":"D8D455F1A28D94","user_header":"https://static001.geekbang.org/account/avatar/00/16/0d/a5/9aad5cc5.jpg","comment_is_top":false,"comment_ctime":1557218270,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557218270","product_id":100023901,"comment_content":"or=rf.get()应该放到do{}while()内，另外有个问题想请教老师，假设T1和T2两线程同时执行setUpper(),T1进入循环后被阻塞，T2进入并更新成功，然后T1继续执行需要两次循环才能更新成功，那么当前状态变成T1设置的值了，然而T2才是后更新的却没有变成T2设置的值，这样合理吗？","like_count":0},{"had_liked":false,"id":88069,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1555835471,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1555835471","product_id":100023901,"comment_content":"获取最新值操作应该放到do-while循环中，以保证每次循环获取最新值<br>or=rf.get()放到循环中","like_count":0},{"had_liked":false,"id":87497,"user_name":"杨春鹏","can_delete":false,"product_type":"c1","uid":1172056,"ip_address":"","ucode":"518F38232F97B5","user_header":"https://static001.geekbang.org/account/avatar/00/11/e2/58/8c8897c8.jpg","comment_is_top":false,"comment_ctime":1555628443,"is_pvip":false,"replies":[{"id":"31512","content":"这里只是模拟cpu的cas指令,用于讲明白cas是怎么工作的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555647236,"ip_address":"","comment_id":87497,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555628443","product_id":100023901,"comment_content":"你好。对于addonne()虽然没有互斥锁，但是调用的cas()方法上还是加上了synchronized，那么不是还是相当于线程之间有竞争吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447486,"discussion_content":"这里只是模拟cpu的cas指令,用于讲明白cas是怎么工作的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555647236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86998,"user_name":"晓杰","can_delete":false,"product_type":"c1","uid":1441546,"ip_address":"","ucode":"1174C88EEBF8A6","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","comment_is_top":false,"comment_ctime":1555494667,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555494667","product_id":100023901,"comment_content":"请问老师atomicRefrence的compareAndSet比较的时候是怎么比较的","like_count":0},{"had_liked":false,"id":86955,"user_name":"西行寺咕哒子","can_delete":false,"product_type":"c1","uid":1441988,"ip_address":"","ucode":"CAE570245BA299","user_header":"https://static001.geekbang.org/account/avatar/00/16/00/c4/634c1e10.jpg","comment_is_top":false,"comment_ctime":1555486914,"is_pvip":false,"replies":[{"id":"31281","content":"👍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555499521,"ip_address":"","comment_id":86955,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555486914","product_id":100023901,"comment_content":"试了一下 确实是死循环 猜测：线程1 中 or 是在 do 循环体外面获取 如果线程2改变了 AtomicReference 中的对象 那么线程1 中调用的compareAndSet（or，ur） or 始终不是线程2更新后的 导致一直返回false 从而死循环。将rf.get()放到do循环体内就好了<br> ","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447262,"discussion_content":"👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555499521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86884,"user_name":"Kenny","can_delete":false,"product_type":"c1","uid":1102688,"ip_address":"","ucode":"F17D11D1331F84","user_header":"https://static001.geekbang.org/account/avatar/00/10/d3/60/d0473a16.jpg","comment_is_top":false,"comment_ctime":1555470090,"is_pvip":false,"replies":[{"id":"31280","content":"我觉得是对的，不过复杂场景可能没有这么简单<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555499500,"ip_address":"","comment_id":86884,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555470090","product_id":100023901,"comment_content":"老师你好，您上面提到无锁方案不会产生死锁问题，但是可能会产生饥饿和活锁。对于CAS来说，产生饥饿比较容易理解，那是否CAS不会产生活锁？我是这样理解的：因为如果n个线程对一个变量执行CAS，产生自旋的条件是变量被其他线程改了，而变量被其他线程改了之后，等待修改的线程就变为N-1，这样循环下去，最终所有的线程都能完成修改，所以不会产生活锁？您看我理解得对吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447229,"discussion_content":"我觉得是对的，不过复杂场景可能没有这么简单\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555499500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86506,"user_name":"magict4","can_delete":false,"product_type":"c1","uid":1043789,"ip_address":"","ucode":"CB6F063D881AAC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/4d/1d1a1a00.jpg","comment_is_top":false,"comment_ctime":1555385675,"is_pvip":false,"replies":[{"id":"31149","content":"正确👍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555412305,"ip_address":"","comment_id":86506,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555385675","product_id":100023901,"comment_content":"可能会陷入死循环。<br><br>线程1执行完23行之后，被暂停。<br>线程2执行，并成功更新rf的内容。<br>线程1继续执行，24行while语句返回为false(因为rf内容已经被线程2更新)。<br>线程1重新进入do循环。注意此时or并没有被重新读取。while语句继续返回false，如此往复。<br><br>感觉把 WMRange or = rf.get(); 这一行放到 do 内部，就可以了，不知道是否正确？<br>","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447042,"discussion_content":"正确👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555412305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86480,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1555380863,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555380863","product_id":100023901,"comment_content":"public class SafeWM {<br>  class WMRange{<br>    final int upper;<br>    final int lower;<br>    WMRange(int upper,int lower){<br>    &#47;&#47; 省略构造函数实现<br>    }<br>  }<br>  final AtomicReference&lt;WMRange&gt;<br>    rf = new AtomicReference&lt;&gt;(<br>      new WMRange(0,0)<br>    );<br>  &#47;&#47; 设置库存上限<br>  void setUpper(int v){<br>    WMRange nr;<br>    WMRange or = rf.get();<br>    do{<br>      &#47;&#47; 检查参数合法性<br>      if(v &lt; or.lower){<br>        throw new IllegalArgumentException();<br>      }<br>      nr = new<br>        WMRange(v, or.lower);<br>    }while(!rf.compareAndSet(or, nr));<br>  }<br>}<br><br>不是很清楚AtomicReference.CAS比较的是对象内存中的地址，还是包括了属性内存中的地址。 我猜想思考题这里写的是对的吧?<br><br>可是如果我说它是错的，我又不知道它错在哪里。","like_count":0},{"had_liked":false,"id":86433,"user_name":"周治慧","can_delete":false,"product_type":"c1","uid":1335293,"ip_address":"","ucode":"7D56C4E66BEE17","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKR3ibELhjgVicCNShZCBwvaDxibnzibggG4wUzVkS2mkDxUBZyIs87nDEdJ7PiahJBVoZcuhQ84RxAziag/132","comment_is_top":false,"comment_ctime":1555377575,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555377575","product_id":100023901,"comment_content":"两个对象比较的时候是比较的地址值，old和new地址值一直是不等的，设置上限应该是去更新对象的字段的值保证字段值的cas","like_count":0},{"had_liked":false,"id":86430,"user_name":"zhangtnty","can_delete":false,"product_type":"c1","uid":1180553,"ip_address":"","ucode":"3C9A14BD7CF432","user_header":"https://static001.geekbang.org/account/avatar/00/12/03/89/e1621a01.jpg","comment_is_top":false,"comment_ctime":1555377489,"is_pvip":false,"replies":[{"id":"31315","content":"我也觉得没有aba问题，简单的原子性问题都可以用它，但是不建议自己构建复杂的无锁算法去解决并发问题。<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555511557,"ip_address":"","comment_id":86430,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555377489","product_id":100023901,"comment_content":"王老师好, 文中题目我认为不存在 ABA 的问题。问题是O r 的值应该放在 do 循环体内,如果两个线程 A , B 。同时执行方法, A 执行完 B 却始终拿不到 A 的新值, 致 B 进入 死循环。<br>另外, 王老师能否针对无锁原子类的实际应用场景列举一些，谢谢！<br>","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447016,"discussion_content":"我也觉得没有aba问题，简单的原子性问题都可以用它，但是不建议自己构建复杂的无锁算法去解决并发问题。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555511557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86416,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1555376670,"is_pvip":false,"replies":[{"id":"31155","content":"看一下v+delta<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555414872,"ip_address":"","comment_id":86416,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555376670","product_id":100023901,"comment_content":"Java如何实现原子化的count+=1中，getLongVolatile（）仅仅是获取当前值，return回去的v并没有对当前值+1啊？<br>","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447009,"discussion_content":"看一下v+delta\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555414872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86413,"user_name":"苏志辉","can_delete":false,"product_type":"c1","uid":1068927,"ip_address":"","ucode":"39B25CE21C04EE","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/7f/5dc11380.jpg","comment_is_top":false,"comment_ctime":1555376321,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555376321","product_id":100023901,"comment_content":"不安全，因为cas只能保证引用一样，没法保证属性没变","like_count":0},{"had_liked":false,"id":86401,"user_name":"Felix Envy","can_delete":false,"product_type":"c1","uid":1200085,"ip_address":"","ucode":"24E0F2165AD108","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/d5/e23dc965.jpg","comment_is_top":false,"comment_ctime":1555375591,"is_pvip":false,"replies":[{"id":"31316","content":"👍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555511570,"ip_address":"","comment_id":86401,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555375591","product_id":100023901,"comment_content":"WMRange or = rf.get(); 这段应该放到循环体里面去，不然一旦发生并发就会有线程进入死循环。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447001,"discussion_content":"👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555511570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86396,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1555375218,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555375218","product_id":100023901,"comment_content":"饥饿的情况，我能够想象出来，可是出现活锁的情况，我想象不出来？知道的同学麻烦告知下。","like_count":0},{"had_liked":false,"id":86394,"user_name":"张德","can_delete":false,"product_type":"c1","uid":1101929,"ip_address":"","ucode":"31FE63E8725EFC","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/69/5dbdc245.jpg","comment_is_top":false,"comment_ctime":1555375046,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555375046","product_id":100023901,"comment_content":"先打卡  一般老师讲的课 我都是看3遍","like_count":0},{"had_liked":false,"id":86362,"user_name":"Kid😋","can_delete":false,"product_type":"c1","uid":1317216,"ip_address":"","ucode":"7150F69AAAB477","user_header":"https://static001.geekbang.org/account/avatar/00/14/19/60/888f1371.jpg","comment_is_top":false,"comment_ctime":1555373434,"is_pvip":false,"replies":[{"id":"31047","content":"有可能有，这个得看场景<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555387558,"ip_address":"","comment_id":86362,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1555373434","product_id":100023901,"comment_content":"打卡！对CAS理解还是不够，要反复多读几次文章了。另外有个小疑问，CAS中的自旋循环是否会有性能问题？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446988,"discussion_content":"有可能有，这个得看场景\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555387558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":48294,"discussion_content":"虚拟机有关闭自旋锁的参数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573471839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86347,"user_name":"kyle","can_delete":false,"product_type":"c1","uid":1179158,"ip_address":"","ucode":"DB05C0F7D2C472","user_header":"https://static001.geekbang.org/account/avatar/00/11/fe/16/0f096793.jpg","comment_is_top":false,"comment_ctime":1555371278,"is_pvip":false,"replies":[{"id":"31048","content":"只是为了让你理解原理，cas不是用sync实现的<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555387604,"ip_address":"","comment_id":86347,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555371278","product_id":100023901,"comment_content":"synchronized 关键字不是隐含加锁操作吗？<br>为什么说cas是无锁的呢！","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446982,"discussion_content":"只是为了让你理解原理，cas不是用sync实现的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555387604,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86344,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1555370031,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1555370031","product_id":100023901,"comment_content":"看了一遍，先打卡，对CAS+自旋还不太明白。看到上一篇文章留言人数少了很多。","like_count":0,"discussions":[{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":48299,"discussion_content":"需要阅读Java虚拟机那本书","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573471898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86321,"user_name":"唐荣轩","can_delete":false,"product_type":"c1","uid":1268732,"ip_address":"","ucode":"D225DC43E94D23","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ8a5dg6aBRohA4bQ5KcHdDt6nCnrk0PiarfnVZ3zsgrBbjayAG1bhuAEfyZaNpplnXYDytZlWpfkA/132","comment_is_top":false,"comment_ctime":1555349398,"is_pvip":false,"replies":[{"id":"31154","content":"👍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555414735,"ip_address":"","comment_id":86321,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555349398","product_id":100023901,"comment_content":"某些指标统计程序、trace模型两ID模型中的SpanID（0.1.2，0.1.5）生成器可以基于原子类进行实现","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446968,"discussion_content":"👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555414735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}