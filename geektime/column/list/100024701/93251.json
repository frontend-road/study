{"id":93251,"title":"15 | 调度（上）：如何制定项目管理流程？","content":"<p>前几节，我们介绍了task_struct数据结构。它就像项目管理系统一样，可以帮项目经理维护项目运行过程中的各类信息，但这并不意味着项目管理工作就完事大吉了。task_struct仅仅能够解决“<strong>看到</strong>”的问题，咱们还要解决如何制定流程，进行项目调度的问题，也就是“<strong>做到</strong>”的问题。</p><p>公司的人员总是有限的。无论接了多少项目，公司不可能短时间增加很多人手。有的项目比较紧急，应该先进行排期；有的项目可以缓缓，但是也不能让客户等太久。所以这个过程非常复杂，需要平衡。</p><p>对于操作系统来讲，它面对的CPU的数量是有限的，干活儿都是它们，但是进程数目远远超过CPU的数目，因而就需要进行进程的调度，有效地分配CPU的时间，既要保证进程的最快响应，也要保证进程之间的公平。这也是一个非常复杂的、需要平衡的事情。</p><h2>调度策略与调度类</h2><p>在Linux里面，进程大概可以分成两种。</p><p>一种称为<strong>实时进程</strong>，也就是需要尽快执行返回结果的那种。这就好比我们是一家公司，接到的客户项目需求就会有很多种。有些客户的项目需求比较急，比如一定要在一两个月内完成的这种，客户会加急加钱，那这种客户的优先级就会比较高。</p><p>另一种是<strong>普通进程</strong>，大部分的进程其实都是这种。这就好比，大部分客户的项目都是普通的需求，可以按照正常流程完成，优先级就没实时进程这么高，但是人家肯定也有确定的交付日期。</p><!-- [[[read_end]]] --><p>那很显然，对于这两种进程，我们的调度策略肯定是不同的。</p><p>在task_struct中，有一个成员变量，我们叫<strong>调度策略</strong>。</p><pre><code>unsigned int policy;\n</code></pre><p>它有以下几个定义：</p><pre><code>#define SCHED_NORMAL\t\t0\n#define SCHED_FIFO\t\t1\n#define SCHED_RR\t\t2\n#define SCHED_BATCH\t\t3\n#define SCHED_IDLE\t\t5\n#define SCHED_DEADLINE\t\t6\n</code></pre><p>配合调度策略的，还有我们刚才说的<strong>优先级</strong>，也在task_struct中。</p><pre><code>int prio, static_prio, normal_prio;\nunsigned int rt_priority;\n</code></pre><p>优先级其实就是一个数值，对于实时进程，优先级的范围是0～99；对于普通进程，优先级的范围是100～139。数值越小，优先级越高。从这里可以看出，所有的实时进程都比普通进程优先级要高。毕竟，谁让人家加钱了呢。</p><h3>实时调度策略</h3><p>对于调度策略，其中SCHED_FIFO、SCHED_RR、SCHED_DEADLINE是实时进程的调度策略。</p><p>虽然大家都是加钱加急的项目，但是也不能乱来，还是需要有个办事流程才行。</p><p>例如，<strong>SCHED_FIFO</strong>就是交了相同钱的，先来先服务，但是有的加钱多，可以分配更高的优先级，也就是说，高优先级的进程可以抢占低优先级的进程，而相同优先级的进程，我们遵循先来先得。</p><p>另外一种策略是，交了相同钱的，轮换着来，这就是<strong>SCHED_RR轮流调度算法</strong>，采用时间片，相同优先级的任务当用完时间片会被放到队列尾部，以保证公平性，而高优先级的任务也是可以抢占低优先级的任务。</p><p>还有一种新的策略是<strong>SCHED_DEADLINE</strong>，是按照任务的deadline进行调度的。当产生一个调度点的时候，DL调度器总是选择其deadline距离当前时间点最近的那个任务，并调度它执行。</p><h3>普通调度策略</h3><p>对于普通进程的调度策略有，SCHED_NORMAL、SCHED_BATCH、SCHED_IDLE。</p><p>既然大家的项目都没有那么紧急，就应该按照普通的项目流程，公平地分配人员。</p><p>SCHED_NORMAL是普通的进程，就相当于咱们公司接的普通项目。</p><p>SCHED_BATCH是后台进程，几乎不需要和前端进行交互。这有点像公司在接项目同时，开发一些可以复用的模块，作为公司的技术积累，从而使得在之后接新项目的时候，能够减少工作量。这类项目可以默默执行，不要影响需要交互的进程，可以降低它的优先级。</p><p>SCHED_IDLE是特别空闲的时候才跑的进程，相当于咱们学习训练类的项目，比如咱们公司很长时间没有接到外在项目了，可以弄几个这样的项目练练手。</p><p>上面无论是policy还是priority，都设置了一个变量，变量仅仅表示了应该这样这样干，但事情总要有人去干，谁呢？在task_struct里面，还有这样的成员变量：</p><pre><code>const struct sched_class *sched_class;\n</code></pre><p>调度策略的执行逻辑，就封装在这里面，它是真正干活的那个。</p><p>sched_class有几种实现：</p><ul>\n<li>\n<p>stop_sched_class优先级最高的任务会使用这种策略，会中断所有其他线程，且不会被其他任务打断；</p>\n</li>\n<li>\n<p>dl_sched_class就对应上面的deadline调度策略；</p>\n</li>\n<li>\n<p>rt_sched_class就对应RR算法或者FIFO算法的调度策略，具体调度策略由进程的task_struct-&gt;policy指定；</p>\n</li>\n<li>\n<p>fair_sched_class就是普通进程的调度策略；</p>\n</li>\n<li>\n<p>idle_sched_class就是空闲进程的调度策略。</p>\n</li>\n</ul><p>这里实时进程的调度策略RR和FIFO相对简单一些，而且由于咱们平时常遇到的都是普通进程，在这里，咱们就重点分析普通进程的调度问题。普通进程使用的调度策略是fair_sched_class，顾名思义，对于普通进程来讲，公平是最重要的。</p><h2>完全公平调度算法</h2><p>在Linux里面，实现了一个基于CFS的调度算法。CFS全称Completely Fair Scheduling，叫完全公平调度。听起来很“公平”。那这个算法的原理是什么呢？我们来看看。</p><p>首先，你需要记录下进程的运行时间。CPU会提供一个时钟，过一段时间就触发一个时钟中断。就像咱们的表滴答一下，这个我们叫Tick。CFS会为每一个进程安排一个虚拟运行时间vruntime。如果一个进程在运行，随着时间的增长，也就是一个个tick的到来，进程的vruntime将不断增大。没有得到执行的进程vruntime不变。</p><p>显然，那些vruntime少的，原来受到了不公平的对待，需要给它补上，所以会优先运行这样的进程。</p><p>这有点像让你把一筐球平均分到N个口袋里面，你看着哪个少，就多放一些；哪个多了，就先不放。这样经过多轮，虽然不能保证球完全一样多，但是也差不多公平。</p><p>你可能会说，不还有优先级呢？如何给优先级高的进程多分时间呢？</p><p>这个简单，就相当于N个口袋，优先级高的袋子大，优先级低的袋子小。这样球就不能按照个数分配了，要按照比例来，大口袋的放了一半和小口袋放了一半，里面的球数目虽然差很多，也认为是公平的。</p><p>在更新进程运行的统计量的时候，我们其实就可以看出这个逻辑。</p><pre><code>/*\n * Update the current task's runtime statistics.\n */\nstatic void update_curr(struct cfs_rq *cfs_rq)\n{\n\tstruct sched_entity *curr = cfs_rq-&gt;curr;\n\tu64 now = rq_clock_task(rq_of(cfs_rq));\n\tu64 delta_exec;\n......\n\tdelta_exec = now - curr-&gt;exec_start;\n......\n\tcurr-&gt;exec_start = now;\n......\n\tcurr-&gt;sum_exec_runtime += delta_exec;\n......\n\tcurr-&gt;vruntime += calc_delta_fair(delta_exec, curr);\n\tupdate_min_vruntime(cfs_rq);\n......\n}\n\n\n/*\n * delta /= w\n */\nstatic inline u64 calc_delta_fair(u64 delta, struct sched_entity *se)\n{\n\tif (unlikely(se-&gt;load.weight != NICE_0_LOAD))\n        /* delta_exec * weight / lw.weight */\n\t\tdelta = __calc_delta(delta, NICE_0_LOAD, &amp;se-&gt;load);\n\treturn delta;\n}\n</code></pre><p>在这里得到当前的时间，以及这次的时间片开始的时间，两者相减就是这次运行的时间delta_exec ，但是得到的这个时间其实是实际运行的时间，需要做一定的转化才作为虚拟运行时间vruntime。转化方法如下：</p><center>虚拟运行时间vruntime += 实际运行时间delta_exec * NICE_0_LOAD/权重</center><p>这就是说，同样的实际运行时间，给高权重的算少了，低权重的算多了，但是当选取下一个运行进程的时候，还是按照最小的vruntime来的，这样高权重的获得的实际运行时间自然就多了。这就相当于给一个体重(权重)200斤的胖子吃两个馒头，和给一个体重100斤的瘦子吃一个馒头，然后说，你们两个吃的是一样多。这样虽然总体胖子比瘦子多吃了一倍，但是还是公平的。</p><h2>调度队列与调度实体</h2><p>看来CFS需要一个数据结构来对vruntime进行排序，找出最小的那个。这个能够排序的数据结构不但需要查询的时候，能够快速找到最小的，更新的时候也需要能够快速地调整排序，要知道vruntime可是经常在变的，变了再插入这个数据结构，就需要重新排序。</p><p>能够平衡查询和更新速度的是树，在这里使用的是红黑树。</p><p>红黑树的的节点是应该包括vruntime的，称为调度实体。</p><p>在task_struct中有这样的成员变量：</p><p>struct sched_entity se;<br>\nstruct sched_rt_entity rt;<br>\nstruct sched_dl_entity dl;</p><p>这里有实时调度实体sched_rt_entity，Deadline调度实体sched_dl_entity，以及完全公平算法调度实体sched_entity。</p><p>看来不光CFS调度策略需要有这样一个数据结构进行排序，其他的调度策略也同样有自己的数据结构进行排序，因为任何一个策略做调度的时候，都是要区分谁先运行谁后运行。</p><p>而进程根据自己是实时的，还是普通的类型，通过这个成员变量，将自己挂在某一个数据结构里面，和其他的进程排序，等待被调度。如果这个进程是个普通进程，则通过sched_entity，将自己挂在这棵红黑树上。</p><p>对于普通进程的调度实体定义如下，这里面包含了vruntime和权重load_weight，以及对于运行时间的统计。</p><pre><code>struct sched_entity {\n\tstruct load_weight\t\tload;\n\tstruct rb_node\t\t\trun_node;\n\tstruct list_head\t\tgroup_node;\n\tunsigned int\t\t\ton_rq;\n\tu64\t\t\t\texec_start;\n\tu64\t\t\t\tsum_exec_runtime;\n\tu64\t\t\t\tvruntime;\n\tu64\t\t\t\tprev_sum_exec_runtime;\n\tu64\t\t\t\tnr_migrations;\n\tstruct sched_statistics\t\tstatistics;\n......\n};\n</code></pre><p>下图是一个红黑树的例子。</p><p><img src=\"https://static001.geekbang.org/resource/image/c2/93/c2b86e79f19d811ce10774688fc0c093.jpeg?wh=2849*1814\" alt=\"\"></p><p>所有可运行的进程通过不断地插入操作最终都存储在以时间为顺序的红黑树中，vruntime最小的在树的左侧，vruntime最多的在树的右侧。 CFS调度策略会选择红黑树最左边的叶子节点作为下一个将获得CPU的任务。</p><p>这棵红黑树放在哪里呢？就像每个软件工程师写代码的时候，会将任务排成队列，做完一个做下一个。</p><p>CPU也是这样的，每个CPU都有自己的 struct rq 结构，其用于描述在此CPU上所运行的所有进程，其包括一个实时进程队列rt_rq和一个CFS运行队列cfs_rq，在调度时，调度器首先会先去实时进程队列找是否有实时进程需要运行，如果没有才会去CFS运行队列找是否有进程需要运行。</p><pre><code>struct rq {\n\t/* runqueue lock: */\n\traw_spinlock_t lock;\n\tunsigned int nr_running;\n\tunsigned long cpu_load[CPU_LOAD_IDX_MAX];\n......\n\tstruct load_weight load;\n\tunsigned long nr_load_updates;\n\tu64 nr_switches;\n\n\n\tstruct cfs_rq cfs;\n\tstruct rt_rq rt;\n\tstruct dl_rq dl;\n......\n\tstruct task_struct *curr, *idle, *stop;\n......\n};\n</code></pre><p>对于普通进程公平队列cfs_rq，定义如下：</p><pre><code>/* CFS-related fields in a runqueue */\nstruct cfs_rq {\n\tstruct load_weight load;\n\tunsigned int nr_running, h_nr_running;\n\n\n\tu64 exec_clock;\n\tu64 min_vruntime;\n#ifndef CONFIG_64BIT\n\tu64 min_vruntime_copy;\n#endif\n\tstruct rb_root tasks_timeline;\n\tstruct rb_node *rb_leftmost;\n\n\n\tstruct sched_entity *curr, *next, *last, *skip;\n......\n};\n</code></pre><p>这里面rb_root指向的就是红黑树的根节点，这个红黑树在CPU看起来就是一个队列，不断地取下一个应该运行的进程。rb_leftmost指向的是最左面的节点。</p><p>到这里终于凑够数据结构了，上面这些数据结构的关系如下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/ac/fd/ac043a08627b40b85e624477d937f3fd.jpeg?wh=3722*1727\" alt=\"\"></p><h2>调度类是如何工作的？</h2><p>凑够了数据结构，接下来我们来看调度类是如何工作的。</p><p>调度类的定义如下：</p><pre><code>struct sched_class {\n\tconst struct sched_class *next;\n\n\n\tvoid (*enqueue_task) (struct rq *rq, struct task_struct *p, int flags);\n\tvoid (*dequeue_task) (struct rq *rq, struct task_struct *p, int flags);\n\tvoid (*yield_task) (struct rq *rq);\n\tbool (*yield_to_task) (struct rq *rq, struct task_struct *p, bool preempt);\n\n\n\tvoid (*check_preempt_curr) (struct rq *rq, struct task_struct *p, int flags);\n\n\n\tstruct task_struct * (*pick_next_task) (struct rq *rq,\n\t\t\t\t\t\tstruct task_struct *prev,\n\t\t\t\t\t\tstruct rq_flags *rf);\n\tvoid (*put_prev_task) (struct rq *rq, struct task_struct *p);\n\n\n\tvoid (*set_curr_task) (struct rq *rq);\n\tvoid (*task_tick) (struct rq *rq, struct task_struct *p, int queued);\n\tvoid (*task_fork) (struct task_struct *p);\n\tvoid (*task_dead) (struct task_struct *p);\n\n\n\tvoid (*switched_from) (struct rq *this_rq, struct task_struct *task);\n\tvoid (*switched_to) (struct rq *this_rq, struct task_struct *task);\n\tvoid (*prio_changed) (struct rq *this_rq, struct task_struct *task, int oldprio);\n\tunsigned int (*get_rr_interval) (struct rq *rq,\n\t\t\t\t\t struct task_struct *task);\n\tvoid (*update_curr) (struct rq *rq)\n</code></pre><p>这个结构定义了很多种方法，用于在队列上操作任务。这里请大家注意第一个成员变量，是一个指针，指向下一个调度类。</p><p>上面我们讲了，调度类分为下面这几种：</p><pre><code>extern const struct sched_class stop_sched_class;\nextern const struct sched_class dl_sched_class;\nextern const struct sched_class rt_sched_class;\nextern const struct sched_class fair_sched_class;\nextern const struct sched_class idle_sched_class;\n</code></pre><p>它们其实是放在一个链表上的。这里我们以调度最常见的操作，<strong>取下一个任务</strong>为例，来解析一下。可以看到，这里面有一个for_each_class循环，沿着上面的顺序，依次调用每个调度类的方法。</p><pre><code>/*\n * Pick up the highest-prio task:\n */\nstatic inline struct task_struct *\npick_next_task(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)\n{\n\tconst struct sched_class *class;\n\tstruct task_struct *p;\n......\n\tfor_each_class(class) {\n\t\tp = class-&gt;pick_next_task(rq, prev, rf);\n\t\tif (p) {\n\t\t\tif (unlikely(p == RETRY_TASK))\n\t\t\t\tgoto again;\n\t\t\treturn p;\n\t\t}\n\t}\n}\n</code></pre><p>这就说明，调度的时候是从优先级最高的调度类到优先级低的调度类，依次执行。而对于每种调度类，有自己的实现，例如，CFS就有fair_sched_class。</p><pre><code>const struct sched_class fair_sched_class = {\n\t.next\t\t\t= &amp;idle_sched_class,\n\t.enqueue_task\t\t= enqueue_task_fair,\n\t.dequeue_task\t\t= dequeue_task_fair,\n\t.yield_task\t\t= yield_task_fair,\n\t.yield_to_task\t\t= yield_to_task_fair,\n\t.check_preempt_curr\t= check_preempt_wakeup,\n\t.pick_next_task\t\t= pick_next_task_fair,\n\t.put_prev_task\t\t= put_prev_task_fair,\n\t.set_curr_task          = set_curr_task_fair,\n\t.task_tick\t\t= task_tick_fair,\n\t.task_fork\t\t= task_fork_fair,\n\t.prio_changed\t\t= prio_changed_fair,\n\t.switched_from\t\t= switched_from_fair,\n\t.switched_to\t\t= switched_to_fair,\n\t.get_rr_interval\t= get_rr_interval_fair,\n\t.update_curr\t\t= update_curr_fair,\n};\n</code></pre><p>对于同样的pick_next_task选取下一个要运行的任务这个动作，不同的调度类有自己的实现。fair_sched_class的实现是pick_next_task_fair，rt_sched_class的实现是pick_next_task_rt。</p><p>我们会发现这两个函数是操作不同的队列，pick_next_task_rt操作的是rt_rq，pick_next_task_fair操作的是cfs_rq。</p><pre><code>static struct task_struct *\npick_next_task_rt(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)\n{\n\tstruct task_struct *p;\n\tstruct rt_rq *rt_rq = &amp;rq-&gt;rt;\n......\n}\n\n\nstatic struct task_struct *\npick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)\n{\n\tstruct cfs_rq *cfs_rq = &amp;rq-&gt;cfs;\n\tstruct sched_entity *se;\n\tstruct task_struct *p;\n......\n}\n</code></pre><p>这样整个运行的场景就串起来了，在每个CPU上都有一个队列rq，这个队列里面包含多个子队列，例如rt_rq和cfs_rq，不同的队列有不同的实现方式，cfs_rq就是用红黑树实现的。</p><p>当有一天，某个CPU需要找下一个任务执行的时候，会按照优先级依次调用调度类，不同的调度类操作不同的队列。当然rt_sched_class先被调用，它会在rt_rq上找下一个任务，只有找不到的时候，才轮到fair_sched_class被调用，它会在cfs_rq上找下一个任务。这样保证了实时任务的优先级永远大于普通任务。</p><p>下面我们仔细看一下sched_class定义的与调度有关的函数。</p><ul>\n<li>\n<p>enqueue_task向就绪队列中添加一个进程，当某个进程进入可运行状态时，调用这个函数；</p>\n</li>\n<li>\n<p>dequeue_task 将一个进程从就绪队列中删除；</p>\n</li>\n<li>\n<p>pick_next_task 选择接下来要运行的进程；</p>\n</li>\n<li>\n<p>put_prev_task 用另一个进程代替当前运行的进程；</p>\n</li>\n<li>\n<p>set_curr_task 用于修改调度策略；</p>\n</li>\n<li>\n<p>task_tick 每次周期性时钟到的时候，这个函数被调用，可能触发调度。</p>\n</li>\n</ul><p>在这里面，我们重点看fair_sched_class对于pick_next_task的实现pick_next_task_fair，获取下一个进程。调用路径如下：pick_next_task_fair-&gt;pick_next_entity-&gt;__pick_first_entity。</p><pre><code>struct sched_entity *__pick_first_entity(struct cfs_rq *cfs_rq)\n{\n\tstruct rb_node *left = rb_first_cached(&amp;cfs_rq-&gt;tasks_timeline);\n\n\n\tif (!left)\n\t\treturn NULL;\n\n\n\treturn rb_entry(left, struct sched_entity, run_node);\n</code></pre><p>从这个函数的实现可以看出，就是从红黑树里面取最左面的节点。</p><h2>总结时刻</h2><p>好了，这一节我们讲了调度相关的数据结构，还是比较复杂的。一个CPU上有一个队列，CFS的队列是一棵红黑树，树的每一个节点都是一个sched_entity，每个sched_entity都属于一个task_struct，task_struct里面有指针指向这个进程属于哪个调度类。</p><p><img src=\"https://static001.geekbang.org/resource/image/10/af/10381dbafe0f78d80beb87560a9506af.jpeg?wh=2519*2072\" alt=\"\"></p><p>在调度的时候，依次调用调度类的函数，从CPU的队列中取出下一个进程。上面图中的调度器、上下文切换这一节我们没有讲，下一节我们讲讲基于这些数据结构，如何实现调度。</p><h2>课堂练习</h2><p>这里讲了进程调度的策略和算法，你知道如何通过API设置进程和线程的调度策略吗？你可以写个程序尝试一下。</p><p>欢迎留言和我分享你的疑惑和见解，也欢迎你收藏本节内容，<span class=\"orange\">反复研读</span>。你也可以把今天的内容分享给你的朋友，和他一起学习、进步。</p><p><img src=\"https://static001.geekbang.org/resource/image/8c/37/8c0a95fa07a8b9a1abfd394479bdd637.jpg?wh=1110*659\" alt=\"\"></p>","comments":[{"had_liked":false,"id":90881,"user_name":"why","can_delete":false,"product_type":"c1","uid":1012937,"ip_address":"","ucode":"C9E796E53F6F5E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/74/c9/d3439ca4.jpg","comment_is_top":false,"comment_ctime":1556706942,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"400988665470","product_id":100024701,"comment_content":"- 调度策略与调度类<br>\t- 进程包括两类: 实时进程(优先级高); 普通进程<br>\t- 两种进程调度策略不同: task_struct-&gt;policy 指明采用哪种调度策略(有6种策略)<br>\t- 优先级配合调度策略, 实时进程(0-99); 普通进程(100-139)<br>\t- 实时调度策略, 高优先级可抢占低优先级进程<br>\t\t- FIFO: 相同优先级进程先来先得<br>\t\t- RR: 轮流调度策略, 采用时间片轮流调度相同优先级进程<br>\t\t- Deadline: 在调度时, 选择 deadline 最近的进程<br>\t- 普通调度策略<br>\t\t- normal: 普通进程<br>\t\t- batch: 后台进程, 可以降低优先级<br>\t\t- idle: 空闲时才运行<br>\t- 调度类: task_struct 中 * sched_class 指向封装了调度策略执行逻辑的类(有5种)<br>\t\t- stop: 优先级最高. 将中断其他所有进程, 且不能被打断<br>\t\t- dl: 实现 deadline 调度策略<br>\t\t- rt: RR 或 FIFO, 具体策略由 task_struct-&gt;policy 指定<br>\t\t- fair: 普通进程调度<br>\t\t- idle: 空闲进程调度<br>- 普通进程的 fair 完全公平调度算法 CFS(Linux 实现)<br>\t- 记录进程运行时间( vruntime 虚拟运行时间)<br>\t- 优先调度 vruntime 小的进程<br>\t- 按照比例累计 vruntime, 使之考虑进优先级关系<br>- 调度队列和调度实体<br>\t- CFS 中需要对 vruntime 排序找最小, 不断查询更新, 因此利用红黑树实现调度队列<br>\t- task_struct 中有 实时, deadline 和 cfs 三个调度实体, cfs 调度实体即红黑树节点<br>\t- 每个 CPU 都有 rq 结构体, 里面有 dl_rq, rt_rq 和 cfs_rq 三个调度队列以及其他信息; 队列描述该 CPU 所运行的所有进程<br>\t- 先在 rt_rq 中找进程运行, 若没有再到 cfs_rq 中找; cfs_rq 中 rb_root 指向红黑树根节点, rb_leftmost指向最左节点<br>- 调度类如何工作<br>\t- 调度类中有一个成员指向下一个调度类(按优先级顺序串起来)<br>\t- 找下一个运行任务时, 按 stop-dl-rt-fair-idle 依次调用调度类, 不同调度类操作不同调度队列<br>","like_count":94,"discussions":[{"author":{"id":1968013,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/07/8d/3e76560f.jpg","nickname":"王建峰","note":"","ucode":"8BF1AEFFA7EA5F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374465,"discussion_content":"特别棒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621206029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1116317,"avatar":"https://static001.geekbang.org/account/avatar/00/11/08/9d/9dd3257c.jpg","nickname":"大脸猫","note":"","ucode":"B63DA3852CF9EB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":315408,"discussion_content":"笔记就靠你了哥们","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603271176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93896,"user_name":"拾贝壳的孩子","can_delete":false,"product_type":"c1","uid":1054038,"ip_address":"","ucode":"63118ECB55F758","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/56/a969e60b.jpg","comment_is_top":false,"comment_ctime":1557656138,"is_pvip":false,"replies":[{"id":"33889","content":"对的，饿死，cpu一直转，低优先级的没响应","user_name":"作者回复","comment_id":93896,"uid":"1001590","ip_address":"","utype":1,"ctime":1557899877,"user_name_real":"刘超@网易云"}],"discussion_count":2,"race_medal":0,"score":"233485890122","product_id":100024701,"comment_content":"如果优先队列一直有任务,普通队列的task一直得不到处理，操作系统会怎么做呢？<br>-------------------------------------------------------------------------------------<br>我现在知道这个问题的答案了。这种现象叫做饿死。我当时想到这个问题时其实不知道这个概念。<br>为了防止这种现象的发生，操作系统在一定的时间周期会重置所有task的优先级，这样就保证<br>了低优先级的task得以执行,而不被饿死。但是这个时间设置为多少合适？设置的短了会导致系统的频繁重置。设置的长了，又会使普通优先级的task切换太慢。这个时间一般是系统研究人员研究得到的，我觉得可能可以通过一些统计学上的方式来做。<br>为了解决task响应时间和完成时间的平衡，现代操作系统如Windows和Linux都依赖于Multi-Level Feedback Queue, 和文章讲的正好对应起来了。首先面对的情况是：<br>1. 操作系统无法知道每个task何时到来 ？<br>2. 操作系统无法知道每个task运行完成实际需要多少时间 ？<br>那么FIFO ShortJobFirst或者Short Time Completed First 算法，面对这两种场景将无从下手。<br>面对这样的问题，为了使交互性的TASK能够得到快速的响应，提升用户的的体验，同时缩短task 的完成时间。计算机科学家提出了Multi-Level Feedback Queue的解决方案。基本思想是通过优先级保证交互性的task，能够快速响应，同时通过统计task 对CPU的使用时间以期对TASK判断，有点类似于机器学习。<br>如果某个task 在其时间片里用完前释放CPU， 可以认为这是种交互式的task, 优先级保留。反之认为某个task是需要运行时间长的。同时基于对task 对cpu 时间使用的统计作为判断依据。这样经过一段时间运行后，长时间运行的队列会被逐渐降低优先级。<br>而快速响应的task 能够优先使用CPU。但是这里面还有两个问题: 首先，如果优先级低的一直得不到cpu, 可能会出现饿死。其次，有人可能会利用这个漏洞编程的方式在使用完CPU时间片后释放CPU，从而控制CPU。 基于此，Multi-feedback-queue有以下5条规则：<br>1. 如果A的优先级大于B， 则A先运行。<br>2. 如果A的优先级等于B， 则以RR算法交互运行。<br>3. 新来的 Task 会被置于最高的优先级。<br>4. 如果一个task 在其当前优先级运行完被分配的时间片后，会降低其优先级，重置其放弃使用CPU的次数。（这条规则修改过，是为了防止有人利于原有规则的漏洞控制CPU, 原来的规则是如果一个task 在其时间片用完前释放cpu, 则其优先级保持不变， 这个修正增加了对task 实际使用cpu 时间统计作为判断依据）。<br>5. 系统每过时钟周期的倍数，会重置所有task 的优先级。（这条规则是为了防止task被饿死的，也是我之前所疑惑的）。","like_count":55,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449818,"discussion_content":"对的，饿死，cpu一直转，低优先级的没响应","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557899877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1798979,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/73/43/ae139b1f.jpg","nickname":"博","note":"","ucode":"F7CA69FF5D09BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":231504,"discussion_content":"那么重置的规则能否说说","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586821593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":192435,"user_name":"OOK","can_delete":false,"product_type":"c1","uid":1342712,"ip_address":"","ucode":"BE6220D4E922E9","user_header":"https://static001.geekbang.org/account/avatar/00/14/7c/f8/1183f1ac.jpg","comment_is_top":false,"comment_ctime":1584850580,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"143318771348","product_id":100024701,"comment_content":"这里给大家分享几个文章，大家对背后的机制明白后，这些代码就很好理解了，这些文章涉及linux调度器的发展历史，O(n), O(1)调度器，到cfs。<br><br>1. http:&#47;&#47;www.wowotech.net&#47;process_management&#47;scheduler-history.html<br><br>2. https:&#47;&#47;www.ibm.com&#47;developerworks&#47;cn&#47;linux&#47;l-cn-scheduler&#47;index.html<br><br>3. https:&#47;&#47;www.jianshu.com&#47;p&#47;673c9e4817a8<br><br>","like_count":34,"discussions":[{"author":{"id":2004350,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/95/7e/1057f77a.jpg","nickname":"四有青年","note":"","ucode":"121A7C613E6C32","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541175,"discussion_content":"第一篇文章讲得非常棒，花了两个工作日晚上细细看完了，收获颇丰！从O(n)-&gt;O(1)-&gt;CFS调度器，可以理解内核在此演变过程中的思考，特此回来评价！！！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640272751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1782139,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/31/7b/5914f8eb.jpg","nickname":"小骆驼🐪","note":"","ucode":"C62F685903F2F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380921,"discussion_content":"２，３链接都打不开了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624795983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2046179,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLAsbPRKgaVw8kKp5pKGUE4JdDZaW16RoRTItTI3wJ3pPGNoFIjYQm8FKa3xLlNwRicziclmWKsmp7kA/132","nickname":"清河","note":"","ucode":"AB44CB37FCB026","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301449,"discussion_content":"太棒了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598529947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91416,"user_name":"青石","can_delete":false,"product_type":"c1","uid":1215531,"ip_address":"","ucode":"B0056AD6453322","user_header":"https://static001.geekbang.org/account/avatar/00/12/8c/2b/3ab96998.jpg","comment_is_top":false,"comment_ctime":1557032828,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"117521149820","product_id":100024701,"comment_content":"# 查看当前进程的调度策略 <br>$ chrt  -p 31636<br>pid 31636 的当前调度策略：SCHED_OTHER<br>pid 31636 的当前调度优先级：0<br><br># 修改31636进程的调度策略为SCHED_FIFO，优先级为10<br>$ chrt  -f -p 10 31636<br>$ chrt  -p 31636<br>pid 31636 的当前调度策略：SCHED_FIFO<br>pid 31636 的当前调度优先级：10","like_count":28,"discussions":[{"author":{"id":1221532,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a3/9c/8a14b7db.jpg","nickname":"k先生","note":"","ucode":"76D292DC62B52D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3013,"discussion_content":"sched_other 是属于哪种调度策略？其它调度策略？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564112911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1466033,"avatar":"https://static001.geekbang.org/account/avatar/00/16/5e/b1/09b9f4e6.jpg","nickname":"马克","note":"","ucode":"66F2991470A20E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1221532,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a3/9c/8a14b7db.jpg","nickname":"k先生","note":"","ucode":"76D292DC62B52D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286726,"discussion_content":"SCHED_NORMAL (traditionally called SCHED_OTHER) 就是SCHED_NORMAL","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1593268607,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3013,"ip_address":""},"score":286726,"extra":""}]}]},{"had_liked":false,"id":90798,"user_name":"Keep-Moving","can_delete":false,"product_type":"c1","uid":1182631,"ip_address":"","ucode":"76F33C06E07A27","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/a7/6ef32187.jpg","comment_is_top":false,"comment_ctime":1556661916,"is_pvip":false,"replies":[{"id":"32632","content":"进程和线程都是task，一起调度","user_name":"作者回复","comment_id":90798,"uid":"1001590","ip_address":"","utype":1,"ctime":1556811948,"user_name_real":"刘超@网易云"}],"discussion_count":2,"race_medal":0,"score":"83161040540","product_id":100024701,"comment_content":"本节讲的是进程的调度，那线程的调度是什么样的呢？Linux调度的基本单位是进程还是线程呢？","like_count":19,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448660,"discussion_content":"进程和线程都是task，一起调度","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556811948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2028811,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f5/0b/73628618.jpg","nickname":"兔嘟嘟","note":"","ucode":"5A9042B4C7670C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390324,"discussion_content":"内核中都是task，感觉一会儿进程一会儿线程挺混乱的，但毕竟进程调度是习惯用语了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629778696,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90926,"user_name":"刘強","can_delete":false,"product_type":"c1","uid":1035612,"ip_address":"","ucode":"B2E41BB894A727","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cd/5c/e09eac13.jpg","comment_is_top":false,"comment_ctime":1556728935,"is_pvip":false,"replies":[{"id":"32630","content":"是的","user_name":"作者回复","comment_id":90926,"uid":"1001590","ip_address":"","utype":1,"ctime":1556811804,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"48801369191","product_id":100024701,"comment_content":"感觉这个sched_class结构体类似面向对象中的基类啊,通过函数指针类型的成员指向不同的函数，实现了多态。","like_count":12,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448728,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556811804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117962,"user_name":"kdb_reboot","can_delete":false,"product_type":"c1","uid":1003594,"ip_address":"","ucode":"4C56FCA563FCA3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/4a/04fef27f.jpg","comment_is_top":false,"comment_ctime":1564199294,"is_pvip":false,"replies":[{"id":"46402","content":"赞","user_name":"作者回复","comment_id":117962,"uid":"1001590","ip_address":"","utype":1,"ctime":1566298928,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"40218904958","product_id":100024701,"comment_content":"可以通过sched_setscheduler和pthread_setschedparam设置进程和线程的API","like_count":9,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460199,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566298928,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90879,"user_name":"why","can_delete":false,"product_type":"c1","uid":1012937,"ip_address":"","ucode":"C9E796E53F6F5E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/74/c9/d3439ca4.jpg","comment_is_top":false,"comment_ctime":1556705062,"is_pvip":false,"replies":[{"id":"32631","content":"每次新进程创建完毕后，都会试图先让新的抢占一次","user_name":"作者回复","comment_id":90879,"uid":"1001590","ip_address":"","utype":1,"ctime":1556811870,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"40211410726","product_id":100024701,"comment_content":"如果是新建的进程如何处理, 它 vruntime 总是最小的, 总被调度直到与其他进程相当.","like_count":9,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448706,"discussion_content":"每次新进程创建完毕后，都会试图先让新的抢占一次","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556811870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":116844,"user_name":"江山未","can_delete":false,"product_type":"c1","uid":1090196,"ip_address":"","ucode":"5293DD9482717F","user_header":"https://static001.geekbang.org/account/avatar/00/10/a2/94/ae0a60d8.jpg","comment_is_top":false,"comment_ctime":1563931288,"is_pvip":false,"replies":[{"id":"46423","content":"到了内核里面，就没有所谓进程不进程了，对于操作系统内核的代码，都是数据结构，随内核怎么操作都行。地址是初始化的时候，重要数据结构的起始地址都是能够找到的。","user_name":"作者回复","comment_id":116844,"uid":"1001590","ip_address":"","utype":1,"ctime":1566299842,"user_name_real":"刘超@网易云"}],"discussion_count":4,"race_medal":0,"score":"27333735064","product_id":100024701,"comment_content":"有个疑问，sched_class和rq这些结构，都存在内核态的哪里啊，也有一个进程负责维护他们吗，CPU怎么有他们的地址的。。抱歉问题比较多","like_count":7,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459706,"discussion_content":"到了内核里面，就没有所谓进程不进程了，对于操作系统内核的代码，都是数据结构，随内核怎么操作都行。地址是初始化的时候，重要数据结构的起始地址都是能够找到的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566299842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1116508,"avatar":"https://static001.geekbang.org/account/avatar/00/11/09/5c/b5d79d20.jpg","nickname":"李亮亮","note":"","ucode":"290907F930B261","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":26443,"discussion_content":"所谓内核态跟用户态，可以理解为两种环境。这两种环境的特权级别不一样，对于硬件来说也有相关的特权级别，比如CPU 的特权用 ring0-ring4来划分，不同的特权级别可以做的事也就不一样了。那么如何利用硬件这种特权能力，当然就是从软件上也做相应的特权环境，所以对于Linux来说，内核态就对应了CUP的ring0，用户态对应了 ring3，ring1和ring2没有使用。对于CPU来说，一条指令执行前会检查其特权允不允许，那么对于软件来说也是一样。比如当需要读取本地一个文件，这也是需要一定权限的，而这个权限只能在内核态使用。所以通过系统调用陷入了内核态。对于进程或者线程来说，陷入内核态的时候还是那个进程跟线程，但是会保存当前的执行环境（用户态的环境），等内核态执行完就必须恢复，也就是前面两章提到的。所以系统调用多了也会影响性能。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1570602407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1203671,"avatar":"","nickname":"风逐残叶_c","note":"","ucode":"9BB90C99B09691","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363362,"discussion_content":"啊，看完了后面两篇这个问题就知道了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617179255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1203671,"avatar":"","nickname":"风逐残叶_c","note":"","ucode":"9BB90C99B09691","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363343,"discussion_content":"讲初始化的时候不是有一个内核状态的1号进程吗，然后ps命令也能看到[]括起来的特殊进程。虽然作者回复说是无所谓进程不进程，但是这些调度的代码总要有一个时间被CPU执行起来，把内核里面的这些数据结构的状态刷新了，才算是完成进程之间的切换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617173737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91019,"user_name":"焰火","can_delete":false,"product_type":"c1","uid":1244606,"ip_address":"","ucode":"D3353B386DE3B5","user_header":"https://static001.geekbang.org/account/avatar/00/12/fd/be/079c78c7.jpg","comment_is_top":false,"comment_ctime":1556792731,"is_pvip":true,"replies":[{"id":"32628","content":"是的，同一个时刻同一个cpu只能给一个进程用","user_name":"作者回复","comment_id":91019,"uid":"1001590","ip_address":"","utype":1,"ctime":1556811749,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"27326596507","product_id":100024701,"comment_content":"一个task 分配给一个cpu执行后，就不会再被其他cpu 执行了吧？  ","like_count":7,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448766,"discussion_content":"是的，同一个时刻同一个cpu只能给一个进程用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556811749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115398,"user_name":"garlic","can_delete":false,"product_type":"c1","uid":1019579,"ip_address":"","ucode":"FEB147EDB5774E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/bb/c039dc11.jpg","comment_is_top":false,"comment_ctime":1563572910,"is_pvip":true,"replies":[{"id":"46562","content":"赞","user_name":"作者回复","comment_id":115398,"uid":"1001590","ip_address":"","utype":1,"ctime":1566357717,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":1,"score":"23038409390","product_id":100024701,"comment_content":"进程线程的API ： http:&#47;&#47;man7.org&#47;linux&#47;man-pages&#47;man7&#47;sched.7.html, Posix Threads API  http:&#47;&#47;man7.org&#47;linux&#47;man-pages&#47;man7&#47;pthreads.7.html , 实时调度策略可以设置优先级普通调度策略设置nice值。 线程要设置指定的调度策略， 主线程 PTHREAD_EXPLICIT_SCHED 否则默认集成主线程调度策略。 网上找了个例子验证了一下： https:&#47;&#47;garlicspace.com&#47;2019&#47;07&#47;16&#47;linux-%e8%bf%9b%e7%a8%8b%ef%bc%8c%e7%ba%bf%e7%a8%8b%e7%9a%84%e8%b0%83%e5%ba%a6%e7%ad%96%e7%95%a5api&#47;","like_count":5,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459088,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566357717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127743,"user_name":"奔跑的码仔","can_delete":false,"product_type":"c1","uid":1609871,"ip_address":"","ucode":"AB3B02B07B8B8C","user_header":"https://static001.geekbang.org/account/avatar/00/18/90/8f/9c691a5f.jpg","comment_is_top":false,"comment_ctime":1566787151,"is_pvip":false,"replies":[{"id":"48774","content":"是的","user_name":"作者回复","comment_id":127743,"uid":"1001590","ip_address":"","utype":1,"ctime":1567495633,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"18746656335","product_id":100024701,"comment_content":"对于CFS的这个比喻很贴切，之前看过CFS相关的内容，一直找不到如何用一个现实中的过程类比一下。大口袋和小口袋所放入的球的比例一样，对应到CFS，也就是vruntime一样，从这个角度来看，也就是做到了完全的公平！","like_count":4,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464633,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567495633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284710,"user_name":"山中无老虎 😪","can_delete":false,"product_type":"c1","uid":1180460,"ip_address":"","ucode":"594247C3A976DE","user_header":"https://static001.geekbang.org/account/avatar/00/12/03/2c/33ba4d12.jpg","comment_is_top":false,"comment_ctime":1616425055,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"14501326943","product_id":100024701,"comment_content":"求帮忙，只想知道，如何通过entity反向拿到task_struct","like_count":4,"discussions":[{"author":{"id":1180460,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/2c/33ba4d12.jpg","nickname":"山中无老虎 😪","note":"","ucode":"594247C3A976DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360399,"discussion_content":"自己回答了，在pick_next_task_fair里面调用了 task_of -》container_of() ，container_of是一个宏通过结构体的某个成员变量找到这个结构体的地址，具体大家自己搜索下","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1616427144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1679661,"avatar":"https://static001.geekbang.org/account/avatar/00/19/a1/2d/599e9051.jpg","nickname":"CycleGAN","note":"","ucode":"9FD04813911A02","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401882,"discussion_content":"赞，解决了我的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633757487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109631,"user_name":"你好呀","can_delete":false,"product_type":"c1","uid":1049361,"ip_address":"","ucode":"2E97656410BACA","user_header":"https://static001.geekbang.org/account/avatar/00/10/03/11/f58c6278.jpg","comment_is_top":false,"comment_ctime":1562069024,"is_pvip":false,"replies":[{"id":"48809","content":"如果创建一个rt的，是能够看到这个现象的","user_name":"作者回复","comment_id":109631,"uid":"1001590","ip_address":"","utype":1,"ctime":1567498176,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"14446970912","product_id":100024701,"comment_content":"想要cpu使用率一直100 % 进程的优先级是不是要最高  好一直占用时间片？","like_count":3,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456489,"discussion_content":"如果创建一个rt的，是能够看到这个现象的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567498176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90822,"user_name":"叫啥好捏","can_delete":false,"product_type":"c1","uid":1478749,"ip_address":"","ucode":"BBD685AACAE059","user_header":"https://static001.geekbang.org/account/avatar/00/16/90/5d/08f28cb0.jpg","comment_is_top":false,"comment_ctime":1556677024,"is_pvip":false,"replies":[{"id":"49501","content":"写的期间，就没休息过呀","user_name":"作者回复","comment_id":90822,"uid":"1001590","ip_address":"","utype":1,"ctime":1567676798,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"14441578912","product_id":100024701,"comment_content":"大佬假期也不休息么","like_count":3,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448674,"discussion_content":"写的期间，就没休息过呀","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567676798,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127680,"user_name":"天王","can_delete":false,"product_type":"c1","uid":1239337,"ip_address":"","ucode":"C074B2F9A5F007","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/29/629d9bb0.jpg","comment_is_top":false,"comment_ctime":1566778985,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10156713577","product_id":100024701,"comment_content":"调度，1 task_struct 里面有policy和priority，任务调度的策略和优先级，项目即进程多了，干活的人即CPU个数是有限的，需要进行进程的调度，分配CPU的时间，既保证线程的快速响应，也保证公平。2 调度策略 2.1 linux里面进程分成2种，一种是实时进程，一种是普通进程，正常时间排 调度策略，task_struct里面有个policy，里面有一些枚举值，SCHED_normal 0，sched_fifo 1，sched_rr 2，sched_batch 3，sched_idle 5，sched_deadline 6。配合调度策略的还有priority，task_struct里面有prio，static_prio，normal_prio，实时进程的优先级是0到99，普通进程是100到139，优先级越小，优先级越高。2.2 调度策略分实时调度策略和普通调度策略 2.21实时调度策略有sched_rr，sched_fifo，sched_deadline，sched_fifo 是高优先级的抢占低优先级的进程，相同优先级的先进的先处理，sched_rr 是轮流着来，每个调度执行个时间片，执行完放到队列后面，sched_deadline，是哪个快到时间了，执行哪个。2.22 普通调度策略 sched_normal，sched_batch，sched_idle，sched_normal 普通进程，sched_batch 后台进程，sched_idle空闲的时候才跑的后台进程，3 policy和priority都是定义了一种策略，具体的调度类 sched_class，sched_class定义了几种实现，stop_sched_class 这个任务优先级最高，可以中断其他线程，不能被其他线程中断，dl_sched_class对应sched_deadline的调度策略，rt_sched_class对应rr算法和fifo的调度策略，fair_sched_class对应就是完全公平的调度策略，idle_sched_class对应空闲的调度策略。4 普通进程的完全公平调度算法 CFS 全称completely fair schedue CFS的原理4.1首先记录一个进程的运行时间 CPU会提供一个时钟，每隔一段时间触发一个中断，叫tick，CFS会为每个进程提供一个虚拟运行时间virtualruntime，随着进程的运行，tick的到来virtualruntime会增大，没有得到执行的virtualruntime保持不变，virtualruntime少的会补上，下次会优先分，优先级高的给一个大桶，按比例分，这样就能给优先级高的优先分配，同样的运行时间，给优先级高的算的少，这样，下次分配的时候，按照virtualruntime小的分配，优先级高的就被执行到了。5 调度队列和调度实体 平衡快速查询和更新的数据结构是红黑树，红黑树的节点是包含virtualruntime的，称为调度实体，有几种sched_entity 完全公平调度实体，sched_rt_entity 实时调度实体，sched_dl_entity deadline调度实体，进程根据自己的状况选择某一个实体，如果是普通进程，则通过sched_entity将自己挂在红黑树上，sched_entity里面包含了vruntime和load_weight，还有统计信息，所有可运行的进程通过不断的插入更新操作，都存储在以时间为顺序的红黑树中，virtualruntime最小的的在树的左侧，最大的在树的右侧，CFS策略会选择左侧最小的作为下一个要执行的任务。红黑树的位置，每个CPU有自己的struct rq结构，用于描述所有在此CPU上运行的所有进程，包括实时队列rt_mq和CFS运行队列cfs_mq，调度器首先会去实时队列rt_mq上有没有要运行的进程，没有去cfs_mq去看下是否有进程需要执行，cfs_mq里面有个rb_root指向的是红黑树的根节点，这个红黑树就像一个队列，不断取下一个要运行的进程，rb_leftmost指向最左边的节点。6 调度类如何工作 6.1 sched_class 结构 sched_class next用于指向下一个调度类，enqueue_task用于将就绪的进程加入到调度列表，dequeue用于将进程从调度列表删除，pick_next_task 用于查找下一个任务，6.2 每个CPU上都有一个大队列rq，这个队列包含多个子队列，rt_rq，cfs_rq，CPU找任务要执行的时候，按照优先级依次调度sched_class，不同的sched_class操作不同的队列，，优先rt_mq是否还有task，没有的话，调用fair_sched_class去cfs_","like_count":2},{"had_liked":false,"id":98261,"user_name":"Geek__WMK","can_delete":false,"product_type":"c1","uid":1450350,"ip_address":"","ucode":"BD402525A0E3DD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI6J3aB8SFk2p54J1NtwZ4fXfxMNlWC4mGH1NAvZicKwCTXbiaRRClb6IicMF2X3VHfnE5mZZiaQhLj2w/132","comment_is_top":false,"comment_ctime":1558944210,"is_pvip":false,"replies":[{"id":"49248","content":"网友见面","user_name":"作者回复","comment_id":98261,"uid":"1001590","ip_address":"","utype":1,"ctime":1567605814,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"10148878802","product_id":100024701,"comment_content":"@why是小灰吧","like_count":2,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451621,"discussion_content":"网友见面","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567605814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95506,"user_name":"nora","can_delete":false,"product_type":"c1","uid":1206539,"ip_address":"","ucode":"3A3EABF27D0261","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/0b/780b0aac.jpg","comment_is_top":false,"comment_ctime":1558068322,"is_pvip":false,"replies":[{"id":"49339","content":"nice是可以调整优先级的。NICE_0_LOAD是NICE值为0的权重，是一个基准值。","user_name":"作者回复","comment_id":95506,"uid":"1001590","ip_address":"","utype":1,"ctime":1567650246,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"10148002914","product_id":100024701,"comment_content":"老师，请教一下 虚拟运行时间 vruntime += 实际运行时间 delta_exec * NICE_0_LOAD&#47; 权重中NICE_0_LOAD是什么意思呢？cfs调度实体是红黑树，那实时进程呢，是普通队列嘛？","like_count":2,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450487,"discussion_content":"nice是可以调整优先级的。NICE_0_LOAD是NICE值为0的权重，是一个基准值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567650246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":306031,"user_name":"Geek_63bb29","can_delete":false,"product_type":"c1","uid":2017041,"ip_address":"","ucode":"65C27FA7531722","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/5kv7IqibneNnMLqtWZQR5f1et8lJmoxiaU43Ttzz3zqW7QzBqMkib8GCtImKsms7PPbWmTB51xRnZQAnRPfA1wVaw/132","comment_is_top":false,"comment_ctime":1628307784,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5923275080","product_id":100024701,"comment_content":"老师，请问通过红黑树找到最左边的rb_node后，如何定位到对应task_struct进程呀？","like_count":1},{"had_liked":false,"id":225875,"user_name":"蹦哒","can_delete":false,"product_type":"c1","uid":1458931,"ip_address":"","ucode":"56591A657DE7C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epcs6PibsP9vEXv4EibUw3bhQPUK04zRTOvfrvF08TwM67xPb1LBh2uRENHQwo2VqYfC5GhJmM7icxHA/132","comment_is_top":false,"comment_ctime":1591880231,"is_pvip":false,"replies":[{"id":"83464","content":"赞","user_name":"作者回复","comment_id":225875,"uid":"1001590","ip_address":"","utype":1,"ctime":1592186076,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"5886847527","product_id":100024701,"comment_content":"看到SCHED_DEADLINE，想到了React中的Fiber调度策略，优先完成距离超时时间最小的任务","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498025,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592186076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163339,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1576701191,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871668487","product_id":100024701,"comment_content":"请问老师，普通进程的调度，只是选择一个优先级最高的，感觉堆的数据结构更合适，这里选择红黑树是不是有其他考量?","like_count":1},{"had_liked":false,"id":96906,"user_name":"杨领well","can_delete":false,"product_type":"c1","uid":1145650,"ip_address":"","ucode":"3974A03855168C","user_header":"https://static001.geekbang.org/account/avatar/00/11/7b/32/60089a62.jpg","comment_is_top":false,"comment_ctime":1558533328,"is_pvip":false,"replies":[{"id":"49263","content":"源码很多地方是混合的，重点看逻辑过程哈","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567608451,"ip_address":"","comment_id":96906,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5853500624","product_id":100024701,"comment_content":"建议：<br>1、源码在第一行标记出具体出处（某某文件某某行）<br>2、文中出现的源码尽量将其标签（如：again）的位置标记出来。","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451057,"discussion_content":"源码很多地方是混合的，重点看逻辑过程哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567608451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92111,"user_name":"拾贝壳的孩子","can_delete":false,"product_type":"c1","uid":1054038,"ip_address":"","ucode":"63118ECB55F758","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/56/a969e60b.jpg","comment_is_top":false,"comment_ctime":1557189609,"is_pvip":false,"replies":[{"id":"49462","content":"是的，如果你创建一个rt的进程，会占用100%cpu，然后就发现系统不能用了","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567671416,"ip_address":"","comment_id":92111,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5852156905","product_id":100024701,"comment_content":"如果优先队列一直有任务,普通队列的task一直得不到处理，操作系统会怎么做呢？","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449150,"discussion_content":"是的，如果你创建一个rt的进程，会占用100%cpu，然后就发现系统不能用了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567671416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90801,"user_name":"安排","can_delete":false,"product_type":"c1","uid":1260026,"ip_address":"","ucode":"F78CFA9624CAEF","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg","comment_is_top":false,"comment_ctime":1556665798,"is_pvip":false,"replies":[{"id":"49502","content":"调度的时候要呀","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567676816,"ip_address":"","comment_id":90801,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5851633094","product_id":100024701,"comment_content":"讲的清晰明了，但是有个疑问，task_struct中为什么需要指向sched_class的指针呢？没想到有啥作用？","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448663,"discussion_content":"调度的时候要呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567676816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1609871,"avatar":"https://static001.geekbang.org/account/avatar/00/18/90/8f/9c691a5f.jpg","nickname":"奔跑的码仔","note":"","ucode":"AB3B02B07B8B8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6216,"discussion_content":"进程切换到运行状态时，需要将其添加到调度队列中，这时候就需要通过该变量所指向的sched_class的enqueue_task将进程添加到调度队列中","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1566790852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2096666,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/fe/1a/39d34ba2.jpg","nickname":"Lancer幸运E","note":"","ucode":"2ADA1468601C05","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1609871,"avatar":"https://static001.geekbang.org/account/avatar/00/18/90/8f/9c691a5f.jpg","nickname":"奔跑的码仔","note":"","ucode":"AB3B02B07B8B8C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579361,"discussion_content":"清晰","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657371939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":6216,"ip_address":""},"score":579361,"extra":""}]}]},{"had_liked":false,"id":352335,"user_name":"| ~浑蛋~","can_delete":false,"product_type":"c1","uid":3024820,"ip_address":"","ucode":"B6904B44DFA805","user_header":"https://static001.geekbang.org/account/avatar/00/2e/27/b4/df65c0f7.jpg","comment_is_top":false,"comment_ctime":1658562771,"is_pvip":true,"discussion_count":0,"race_medal":3,"score":"1658562771","product_id":100024701,"comment_content":"既然都是task，怎么查看Java里面的运行时线程信息","like_count":0},{"had_liked":false,"id":322567,"user_name":"Kino","can_delete":false,"product_type":"c1","uid":1255270,"ip_address":"","ucode":"CBE8588F3C302C","user_header":"https://static001.geekbang.org/account/avatar/00/13/27/66/afa629d6.jpg","comment_is_top":false,"comment_ctime":1637484797,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637484797","product_id":100024701,"comment_content":"有个小疑问，请各位大神解答下，对于cfs，优先调度vruntime小的，那么对于新建的进程，是否总是vruntime最小而获取到大部分调度机会？","like_count":0},{"had_liked":false,"id":318667,"user_name":"Jia Tiancai","can_delete":false,"product_type":"c1","uid":2548102,"ip_address":"","ucode":"EF2F5FE8A0DF3E","user_header":"","comment_is_top":false,"comment_ctime":1635385611,"is_pvip":false,"discussion_count":0,"race_medal":3,"score":"1635385611","product_id":100024701,"comment_content":"有两个疑问，麻烦老师或同学帮忙解答一下呢，非常感谢！<br>1. 向就绪队列中增加一个进程，上面提到每个CPU都有对应的队列，是往哪个CPU中增加这个进程呢？<br>2. 每个CPU都有rt_rq和cfs_rq，如果某个CPU的rt_rq为空，而另外的CPU的rt_rq又有很多，怎么保证整个系统的实时进程优先运行的呢，CFS又怎么保证整个系统进程调度的公平性的呢?","like_count":0},{"had_liked":false,"id":311370,"user_name":"一个迷路的野指针","can_delete":false,"product_type":"c1","uid":2634743,"ip_address":"","ucode":"0FCE200DAD0CF8","user_header":"https://static001.geekbang.org/account/avatar/00/28/33/f7/542be086.jpg","comment_is_top":false,"comment_ctime":1631190659,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631190659","product_id":100024701,"comment_content":"有个疑问：为啥要把实际运行时间转换为虚拟时间","like_count":0},{"had_liked":false,"id":308737,"user_name":"兔嘟嘟","can_delete":false,"product_type":"c1","uid":2028811,"ip_address":"","ucode":"5A9042B4C7670C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f5/0b/73628618.jpg","comment_is_top":false,"comment_ctime":1629776715,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629776715","product_id":100024701,"comment_content":"请问老师，按照”取最小值，频繁更新，支持删除插入“的这几个标准，除了红黑树，是不是堆和跳表也符合，这里又为什么不使用呢？","like_count":0},{"had_liked":false,"id":306034,"user_name":"Geek_63bb29","can_delete":false,"product_type":"c1","uid":2017041,"ip_address":"","ucode":"65C27FA7531722","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/5kv7IqibneNnMLqtWZQR5f1et8lJmoxiaU43Ttzz3zqW7QzBqMkib8GCtImKsms7PPbWmTB51xRnZQAnRPfA1wVaw/132","comment_is_top":false,"comment_ctime":1628309283,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628309283","product_id":100024701,"comment_content":"老师，以下代码，rb_entry是咋从rb_node获得sched_entity的呢<br>struct sched_entity *se;<br>se = rb_entry(leftmost, struct sched_entity, run_node);<br><br><br>","like_count":0},{"had_liked":false,"id":302962,"user_name":"长青","can_delete":false,"product_type":"c1","uid":1360825,"ip_address":"","ucode":"035E147C097C09","user_header":"https://static001.geekbang.org/account/avatar/00/14/c3/b9/5cd84471.jpg","comment_is_top":false,"comment_ctime":1626485804,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626485804","product_id":100024701,"comment_content":"老师能举例说明一下，linux上哪些进程是实时进程或普通进程吗？","like_count":0},{"had_liked":false,"id":293035,"user_name":"王建峰","can_delete":false,"product_type":"c1","uid":1968013,"ip_address":"","ucode":"8BF1AEFFA7EA5F","user_header":"https://static001.geekbang.org/account/avatar/00/1e/07/8d/3e76560f.jpg","comment_is_top":false,"comment_ctime":1621164260,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"1621164260","product_id":100024701,"comment_content":"超哥，现在提问题还有机会能得到你回复么?","like_count":0,"discussions":[{"author":{"id":1299347,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d3/93/c3fb8566.jpg","nickname":"ProcessIsTheKey","note":"","ucode":"BE02EFD75F7D98","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375915,"discussion_content":"哈哈，没了，我也是最近才开始学习，5年java开发经验，但是一脸懵逼...","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621867148,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1968013,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/07/8d/3e76560f.jpg","nickname":"王建峰","note":"","ucode":"8BF1AEFFA7EA5F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1299347,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d3/93/c3fb8566.jpg","nickname":"ProcessIsTheKey","note":"","ucode":"BE02EFD75F7D98","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377021,"discussion_content":"同感","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622467219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":375915,"ip_address":""},"score":377021,"extra":""}]},{"author":{"id":1547763,"avatar":"https://static001.geekbang.org/account/avatar/00/17/9d/f3/3f6dd32b.jpg","nickname":"叶紫真","note":"","ucode":"9CD7567FDB7F1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375032,"discussion_content":"应该不得行了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621438965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1968013,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/07/8d/3e76560f.jpg","nickname":"王建峰","note":"","ucode":"8BF1AEFFA7EA5F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1547763,"avatar":"https://static001.geekbang.org/account/avatar/00/17/9d/f3/3f6dd32b.jpg","nickname":"叶紫真","note":"","ucode":"9CD7567FDB7F1F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375047,"discussion_content":"🤣","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621468472,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":375032,"ip_address":""},"score":375047,"extra":""}]}]},{"had_liked":false,"id":287083,"user_name":"明天","can_delete":false,"product_type":"c1","uid":2458966,"ip_address":"","ucode":"3E8070C4C8FCD0","user_header":"https://static001.geekbang.org/account/avatar/00/25/85/56/6fe64e92.jpg","comment_is_top":false,"comment_ctime":1617768574,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617768574","product_id":100024701,"comment_content":"老师 内核态选择了一个任务后如何返回用户态的？","like_count":0},{"had_liked":false,"id":278052,"user_name":"ben","can_delete":false,"product_type":"c1","uid":2097533,"ip_address":"","ucode":"3287431472A90C","user_header":"https://static001.geekbang.org/account/avatar/00/20/01/7d/36a82725.jpg","comment_is_top":false,"comment_ctime":1612741723,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612741723","product_id":100024701,"comment_content":"谁的vruntime值较小就说明它以前占用cpu的时间较短，受到了“不公平”对待，因此下一个运行进程就是它。这样既能公平选择进程，又能保证高优先级进程获得较多的运行时间。这就是CFS的主要思想了。","like_count":0},{"had_liked":false,"id":237283,"user_name":"佳佳大魔王","can_delete":false,"product_type":"c1","uid":1235320,"ip_address":"","ucode":"D5214903D85A0F","user_header":"https://static001.geekbang.org/account/avatar/00/12/d9/78/8a328299.jpg","comment_is_top":false,"comment_ctime":1595768586,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1595768586","product_id":100024701,"comment_content":"本文中“优先级其实就是一个数值，对于实时进程，优先级的范围是 0～99；对于普通进程，优先级的范围是 100～139。数值越小，优先级越高。”<br>而《Linux内核设计与实现》中（原书第3版第37页），Linux采用了两种不同的优先级范围。第一种是nice值，它的范围是从-20到19，默认值为0；越大的nice值意味着更低的优先级；第二种范围是实时优先级，其值是可配置的，默认情况下它的变化范围是从0到99.与nice值相反，越高的实时优先级数值意味着进程优先级越高。<br>这两种观点矛盾了啊，搞不懂了，谁来回答我一下。","like_count":0,"discussions":[{"author":{"id":1399058,"avatar":"https://static001.geekbang.org/account/avatar/00/15/59/12/49458cb3.jpg","nickname":"🙄","note":"","ucode":"294786B5F39F8E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373284,"discussion_content":"100-PRI  这个公式转换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620690881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1946744,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/b4/78/47011c75.jpg","nickname":"xavier","note":"","ucode":"E3C38864D3C8E4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310209,"discussion_content":"有回答了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601689323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235322,"user_name":"海军上校","can_delete":false,"product_type":"c1","uid":1104290,"ip_address":"","ucode":"7B0D9EC01A3F36","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/a2/afbc447c.jpg","comment_is_top":false,"comment_ctime":1594973635,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594973635","product_id":100024701,"comment_content":"老师~ 调度器的也需要cpu执行吧？ 它是什么机制","like_count":0},{"had_liked":false,"id":233224,"user_name":"做一个积极的跳蚤","can_delete":false,"product_type":"c1","uid":2035956,"ip_address":"","ucode":"BBE367BBCB6C28","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ecruTrMgzvqIs5iaWVibZw4Rxic42ZXGTflvOFHiaZEkf32Su01gDCWT8tdIcEoybg0ibAYU2Q8f9bleL7Q37fKguxQ/132","comment_is_top":false,"comment_ctime":1594264158,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594264158","product_id":100024701,"comment_content":"请问老师，利用cpu亲和性接口pthread_setaffinity_np 让线程独占cpu是什么原理呢？","like_count":0},{"had_liked":false,"id":232679,"user_name":"梦想的优惠券","can_delete":false,"product_type":"c1","uid":1257418,"ip_address":"","ucode":"D3B44F6C618CA7","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/ca/cbce6e94.jpg","comment_is_top":false,"comment_ctime":1594087289,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1594087289","product_id":100024701,"comment_content":"每个CPU上都有一个队列，那有没有可能，当有多个CPU的时候，队列中出现相同的任务？如：CPU1和CPU2的队列中，都有任务task1，然后在同一时刻，task1被CPU1和CPU2同时执行？","like_count":0},{"had_liked":false,"id":220196,"user_name":"珠闪闪","can_delete":false,"product_type":"c1","uid":1300447,"ip_address":"","ucode":"45BE0D586A3839","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eov38ZkwCyNoBdr5drgX0cp2eOGCv7ibkhUIqCvcnFk8FyUIS6K4gHXIXh0fu7TB67jaictdDlic4OwQ/132","comment_is_top":false,"comment_ctime":1590202297,"is_pvip":false,"replies":[{"id":"83074","content":"启动的时候，其实只要初始化一个头就好了","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1591785476,"ip_address":"","comment_id":220196,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1590202297","product_id":100024701,"comment_content":"刘超老师，每个CPU上的任务队列是谁分配的？什么时候分配的？","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496080,"discussion_content":"启动的时候，其实只要初始化一个头就好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591785476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1104290,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d9/a2/afbc447c.jpg","nickname":"海军上校","note":"","ucode":"7B0D9EC01A3F36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291848,"discussion_content":"老师~ 就是哪个task该进入哪个cpu队列是怎么决定的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594973291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191063,"user_name":"有米","can_delete":false,"product_type":"c1","uid":1005042,"ip_address":"","ucode":"C9A10B7A67BC12","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/f2/ba68d931.jpg","comment_is_top":false,"comment_ctime":1584721213,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584721213","product_id":100024701,"comment_content":"感觉跟分布式系统的负载均衡策略大同小异，设计模式就是：策略模式","like_count":0},{"had_liked":false,"id":182148,"user_name":"monchickey","can_delete":false,"product_type":"c1","uid":1513948,"ip_address":"","ucode":"D7B670444F62B3","user_header":"https://static001.geekbang.org/account/avatar/00/17/19/dc/9d3ed421.jpg","comment_is_top":false,"comment_ctime":1582721013,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1582721013","product_id":100024701,"comment_content":"老师你好，我想问一下假如两个进程优先级相同，1个进程是纯计算会一直占用cpu，而另一个进程是频繁io操作，这个进程稍微占用一点vruntime就马上进入阻塞了，就会被前者抢占，而前者只能是被动被调度，这样岂不是两个进程的vruntime会越差越大，和cfs有些矛盾了，这里一直想不通，请问实际是啥情况呢？","like_count":0,"discussions":[{"author":{"id":1478179,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8e/23/7d2e4f70.jpg","nickname":"瞳影","note":"","ucode":"1A01E5CB41EDA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282032,"discussion_content":"可以看一下这个：https://www.jianshu.com/p/673c9e4817a8，里面 min_vruntime 的描述","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591864815,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170510,"user_name":"sun","can_delete":false,"product_type":"c1","uid":1136181,"ip_address":"","ucode":"948FD34662AFB0","user_header":"https://static001.geekbang.org/account/avatar/00/11/56/35/eeee9309.jpg","comment_is_top":false,"comment_ctime":1578623415,"is_pvip":false,"replies":[{"id":"66276","content":"不会的","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1578823882,"ip_address":"","comment_id":170510,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1578623415","product_id":100024701,"comment_content":"老师，请问同一个task会出现在所有cpu的队列中吗","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481002,"discussion_content":"不会的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578823882,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1798979,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/73/43/ae139b1f.jpg","nickname":"博","note":"","ucode":"F7CA69FF5D09BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":231516,"discussion_content":"那一个进程开了三个线程，三个线程运行在三个CPU执行，但是他们是属于同一个进城吧，就和同一个task出现在所有CPU的队列上吧，假设三个CPU。。而且这里的所有CPU还是CPU的所有队列说的不是很清楚吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586822181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168641,"user_name":"Roger","can_delete":false,"product_type":"c1","uid":1106324,"ip_address":"","ucode":"59E190F8F14281","user_header":"https://static001.geekbang.org/account/avatar/00/10/e1/94/de3f0409.jpg","comment_is_top":false,"comment_ctime":1578130057,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578130057","product_id":100024701,"comment_content":"虽然内核下是优先级越低是越高， 实时进程(0-99),这里应该是数值越高优先级越高，应该是内核会做转换。请老师确认一下。","like_count":0},{"had_liked":false,"id":155305,"user_name":"czh","can_delete":false,"product_type":"c1","uid":1159078,"ip_address":"","ucode":"649FE5C9269D69","user_header":"https://static001.geekbang.org/account/avatar/00/11/af/a6/3f15ba2f.jpg","comment_is_top":false,"comment_ctime":1574676664,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574676664","product_id":100024701,"comment_content":"1.要了解有哪些部分，这些部分之间的前后关系是啥（流程图）。<br>2.摘抄：一个 CPU 上有一个队列，CFS 的队列是一棵红黑树，树的每一个节点都是一个 sched_entity，每个 sched_entity 都属于一个 task_struct，task_struct 里面有指针指向这个进程属于哪个调度类。<br>3.这句话就讲解了流程图之间各个部分之间的关系。<br>4.前几遍学习注重流程以及其中的关系！","like_count":0},{"had_liked":false,"id":146474,"user_name":"柳长青","can_delete":false,"product_type":"c1","uid":1716747,"ip_address":"","ucode":"3EA2B7BD5DBCAF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/1pMbwZrAl5gVy4FictX9HiaDicYOjRI2E6flxrXLhLTcneF74TowWK6rJW6oKs9iakPl0dqHsWjav0TjK6vyEZTlJA/132","comment_is_top":false,"comment_ctime":1572532563,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572532563","product_id":100024701,"comment_content":"我可以这么理解吗：就是所有的调度策略都是系统默认设置好了，并不能单独设置个别进程的调度策略，如果要更改系统的调度策略怎么办？","like_count":0},{"had_liked":false,"id":127759,"user_name":"奔跑的码仔","can_delete":false,"product_type":"c1","uid":1609871,"ip_address":"","ucode":"AB3B02B07B8B8C","user_header":"https://static001.geekbang.org/account/avatar/00/18/90/8f/9c691a5f.jpg","comment_is_top":false,"comment_ctime":1566788610,"is_pvip":false,"replies":[{"id":"48773","content":"进程。<br><br>哈哈哈","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567495623,"ip_address":"","comment_id":127759,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566788610","product_id":100024701,"comment_content":"“如果没有才会去 CFS 运行队列找是否有进行需要运行”","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464641,"discussion_content":"进程。\n\n哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567495623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115553,"user_name":"唐荣轩","can_delete":false,"product_type":"c1","uid":1268732,"ip_address":"","ucode":"D225DC43E94D23","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ8a5dg6aBRohA4bQ5KcHdDt6nCnrk0PiarfnVZ3zsgrBbjayAG1bhuAEfyZaNpplnXYDytZlWpfkA/132","comment_is_top":false,"comment_ctime":1563621048,"is_pvip":false,"replies":[{"id":"46558","content":"哈哈，歧视胖子","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1566356937,"ip_address":"","comment_id":115553,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563621048","product_id":100024701,"comment_content":"胖子吃馒头这个例子，改成搬砖吃馒头可能更合适。高级搬砖工吃两个，一般搬砖工吃1个","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459157,"discussion_content":"哈哈，歧视胖子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566356937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115298,"user_name":"Regina","can_delete":false,"product_type":"c1","uid":1135151,"ip_address":"","ucode":"2256559FB9A8D7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/vTku9cFYPh2T8DSImQoPRLxgSibcVgCRYqMcEYibexxLkfn9IKhUSAasZ7QoB72SDWym31niah2y00ibRWdHibibib1wQ/132","comment_is_top":false,"comment_ctime":1563526689,"is_pvip":false,"replies":[{"id":"46565","content":"不是轮流，是按vruntime选择最小的运行","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1566357832,"ip_address":"","comment_id":115298,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563526689","product_id":100024701,"comment_content":"每个 CPU 都有 rq 结构体，是轮流执行task队列里面的task吗","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459045,"discussion_content":"不是轮流，是按vruntime选择最小的运行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566357832,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114363,"user_name":"Marshall","can_delete":false,"product_type":"c1","uid":1476507,"ip_address":"","ucode":"0FB004E8163F44","user_header":"https://static001.geekbang.org/account/avatar/00/16/87/9b/8bebc8b6.jpg","comment_is_top":false,"comment_ctime":1563282785,"is_pvip":false,"replies":[{"id":"46611","content":"可以__migrate_task","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1566366796,"ip_address":"","comment_id":114363,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1563282785","product_id":100024701,"comment_content":"老师一个task绑定完一个cpu以后 还会解绑去然后交给其他cpu吗","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458625,"discussion_content":"可以__migrate_task","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566366796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135151,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/vTku9cFYPh2T8DSImQoPRLxgSibcVgCRYqMcEYibexxLkfn9IKhUSAasZ7QoB72SDWym31niah2y00ibRWdHibibib1wQ/132","nickname":"Regina","note":"","ucode":"2256559FB9A8D7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3106,"discussion_content":"我也想问这个问题，你知道了么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564191032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108180,"user_name":"Amark","can_delete":false,"product_type":"c1","uid":1121326,"ip_address":"","ucode":"E5F48633654002","user_header":"https://static001.geekbang.org/account/avatar/00/11/1c/2e/93812642.jpg","comment_is_top":false,"comment_ctime":1561691370,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561691370","product_id":100024701,"comment_content":"请问刘老师，就绪队列，还有阻塞队列在哪里","like_count":0},{"had_liked":false,"id":102600,"user_name":"youyui","can_delete":false,"product_type":"c1","uid":1501890,"ip_address":"","ucode":"4CBD130E31CAEA","user_header":"https://static001.geekbang.org/account/avatar/00/16/ea/c2/445977ea.jpg","comment_is_top":false,"comment_ctime":1560260791,"is_pvip":false,"replies":[{"id":"49134","content":"会调度到其他cpu的，但是当前的时间片没必要","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567596338,"ip_address":"","comment_id":102600,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1560260791","product_id":100024701,"comment_content":"一个task是不是永远只能绑定在一个CPU的rq上，不会在其他CPU上运行了？有没有 一个CPU比较闲，去其他比较忙的CPU那窃取点任务的机制？","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453494,"discussion_content":"会调度到其他cpu的，但是当前的时间片没必要","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567596338,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1122150,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1f/66/59e0647a.jpg","nickname":"万历十五年","note":"","ucode":"3D8CF5DF847AE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288437,"discussion_content":"在多处理器环境下，有个负载均衡器，基于各cpu的算力和各cpu上schedule entity来计算负载，当一个task被分配到某个cpu之后，因为cache的存在，通常会一直在这个亲和度比较高的cpu上运行，直到负载均衡器再次负载均衡","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593750181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93615,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1557536478,"is_pvip":true,"replies":[{"id":"49396","content":"优先级高的应该多分时间","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567654634,"ip_address":"","comment_id":93615,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1557536478","product_id":100024701,"comment_content":"虚拟运行时间 vruntime += 实际运行时间 delta_exec * NICE_0_LOAD&#47; 权重<br>同样的实际运行时间，给高权重的算少了，低权重的算多了<br><br>这里的权重不是优先级吧，那么权重和优先级是怎么个对应关系呢？<br><br>","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449700,"discussion_content":"优先级高的应该多分时间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567654634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93450,"user_name":"郑晨Cc","can_delete":false,"product_type":"c1","uid":1324942,"ip_address":"","ucode":"57146E444D6329","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/8e/cf0b4575.jpg","comment_is_top":false,"comment_ctime":1557473729,"is_pvip":false,"replies":[{"id":"49398","content":"查找快，也不需要频繁调整。","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567654856,"ip_address":"","comment_id":93450,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557473729","product_id":100024701,"comment_content":"CFS对vruntime 的排序为啥要用复杂的红黑树呢？他只需要知道最小的vruntime和插入新的vruntime ，也不需要随机的查询，按理说用小顶堆更合适的啊 ","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449638,"discussion_content":"查找快，也不需要频繁调整。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567654856,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93251,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1557448053,"is_pvip":true,"replies":[{"id":"49402","content":"用不了这么多级别","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567656542,"ip_address":"","comment_id":93251,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1557448053","product_id":100024701,"comment_content":"对于实时进程，优先级的范围是 0～99；对于普通进程，优先级的范围是 100~139<br>这里为什么 实时进程 的范围是100，而普通进程的优先级范围才是40 ？<br>","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449545,"discussion_content":"用不了这么多级别","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567656542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92530,"user_name":"nora","can_delete":false,"product_type":"c1","uid":1206539,"ip_address":"","ucode":"3A3EABF27D0261","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/0b/780b0aac.jpg","comment_is_top":false,"comment_ctime":1557293292,"is_pvip":false,"replies":[{"id":"49426","content":"那不是，看线程创建那一节","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567663138,"ip_address":"","comment_id":92530,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1557293292","product_id":100024701,"comment_content":"所以Linux下其实进程和线程一样的，都会占用task，故Linux下线程并不会比进程轻量级？","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449304,"discussion_content":"那不是，看线程创建那一节","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567663138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1122150,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1f/66/59e0647a.jpg","nickname":"万历十五年","note":"","ucode":"3D8CF5DF847AE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288445,"discussion_content":"进程是资源分配单位，线程是调度单位。进程也是通过线程来实现运行的，所以对于linux内核调度来说，眼睛里只有task。在调度的时候，同一进程内的多线程之间的调度成本要小于不同进程之间的切换；而且线程的创建和销毁成本也小于进程，所以线程还是比进程轻。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593750788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1315006,"avatar":"https://static001.geekbang.org/account/avatar/00/14/10/be/2920e011.jpg","nickname":"清蒸","note":"","ucode":"4AFB34F84F49A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1411,"discussion_content":"还是要轻量级的。进程创建需要的资源比较多，销毁也相对麻烦。线程资源共享，要轻量一些","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1562603356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92147,"user_name":"Helios","can_delete":false,"product_type":"c1","uid":1380758,"ip_address":"","ucode":"BE6B98EE8F0D09","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJrOl63enWXCRxN0SoucliclBme0qrRb19ATrWIOIvibKIz8UAuVgicBMibIVUznerHnjotI4dm6ibODA/132","comment_is_top":false,"comment_ctime":1557191985,"is_pvip":false,"replies":[{"id":"49461","content":"又不是马上结束，先打一个flag，需要被调度。还是会当前时间片结束的。至于下个时间片，本来就不一定是他呀。","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567671138,"ip_address":"","comment_id":92147,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557191985","product_id":100024701,"comment_content":"“每次新进程创建完毕后，都会试图先让新的抢占一次”。<br><br>那如果不断有新的任务进来，那岂不是对以前的任务不公平了呢，尤其是那些快运行完（可能就差几个时间片了）的任务。","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449159,"discussion_content":"又不是马上结束，先打一个flag，需要被调度。还是会当前时间片结束的。至于下个时间片，本来就不一定是他呀。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567671138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92141,"user_name":"Helios","can_delete":false,"product_type":"c1","uid":1380758,"ip_address":"","ucode":"BE6B98EE8F0D09","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJrOl63enWXCRxN0SoucliclBme0qrRb19ATrWIOIvibKIz8UAuVgicBMibIVUznerHnjotI4dm6ibODA/132","comment_is_top":false,"comment_ctime":1557191878,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557191878","product_id":100024701,"comment_content":"“每次新进程创建完毕后，都会试图先让新的抢占一次”。因为vruntime比较小，那如果一直有新的任务进来，是不是对","like_count":0},{"had_liked":false,"id":91230,"user_name":"leon","can_delete":false,"product_type":"c1","uid":1260247,"ip_address":"","ucode":"2A6F8A10330A81","user_header":"https://static001.geekbang.org/account/avatar/00/13/3a/d7/454a1b90.jpg","comment_is_top":false,"comment_ctime":1556938236,"is_pvip":false,"replies":[{"id":"32858","content":"是的，叫任务调度吧","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1557155020,"ip_address":"","comment_id":91230,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556938236","product_id":100024701,"comment_content":"Linux的最小调度单位是线程，每个进程又至少都有一个线程，当我们在谈Linux调度的时候为啥不说是线程调度？所谓的进程调度是说的也是调度的里面的线程吗？那是不是就没有所谓的进程调度了呢？","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448851,"discussion_content":"是的，叫任务调度吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557155020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91195,"user_name":"小龙的城堡","can_delete":false,"product_type":"c1","uid":1005727,"ip_address":"","ucode":"7F1F9704548E2D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/58/9f/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1556901329,"is_pvip":false,"replies":[{"id":"49489","content":"红黑树倒腾的少。对的。","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567675332,"ip_address":"","comment_id":91195,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556901329","product_id":100024701,"comment_content":"老师，有两个疑问：1.cfs模式下，在选取下一个要执行的任务为什么不用优先级队列，而用红黑树，我觉得无非就是取下一个运行时间最少的任务，没有查询的需求；2.课后习题是不是要用到有关设置进城类型的系统调用才能完成，毕竟调度发生在内核态。多谢老师！","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448840,"discussion_content":"红黑树倒腾的少。对的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567675332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}