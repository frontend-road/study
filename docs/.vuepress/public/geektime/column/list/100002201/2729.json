{"id":2729,"title":"35 | 编程范式游记（6）- 面向对象编程","content":"<p>你好，我是陈皓，网名左耳朵耗子。</p>\n<p>前面我们谈了函数式编程，函数式编程总结起来就是把一些功能或逻辑代码通过函数拼装方式来组织的玩法。这其中涉及最多的是函数，也就是编程中的代码逻辑。但我们知道，代码中还是需要处理数据的，这些就是所谓的“状态”，函数式编程需要我们写出无状态的代码。</p>\n<p>而这天下并不存在没有状态没有数据的代码，如果函数式编程不处理状态这些东西，那么，状态会放在什么地方呢？总是需要一个地方放这些数据的。</p>\n<p>对于状态和数据的处理，我们有必要提一下“面向对象编程”（Object-oriented programming，OOP）这个编程范式了。我们知道，<strong>面向对象的编程有三大特性：封装、继承和多态</strong>。</p>\n<p>面向对象编程是一种具有对象概念的程序编程范型，同时也是一种程序开发的抽象方针，它可能包含数据、属性、代码与方法。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的可重用性、灵活性和可扩展性，对象里的程序可以访问及修改对象相关联的数据。在面向对象编程里，计算机程序会被设计成彼此相关的对象。</p>\n<p>面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反：传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对计算机下达的指令。面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个小型的“机器”，即对象。</p>\n<p>目前已经被证实的是，面向对象程序设计推广了程序的灵活性和可维护性，并且在大型项目设计中广为应用。此外，支持者声称面向对象程序设计要比以往的做法更加便于学习，因为它能够让人们更简单地设计并维护程序，使得程序更加便于分析、设计、理解。</p>\n<p>现在，几乎所有的主流语言都支持面向对象，比如：Common Lisp、Python、C++、Objective-C、Smalltalk、Delphi、Java、Swift、C#、Perl、Ruby与PHP等。</p>\n<p>说起面向对象，就不得不提由Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides合作出版的《<a href=\"https://book.douban.com/subject/1052241/\">设计模式：可复用面向对象软件的基础</a>》（Design Patterns - Elements of Reusable Object-Oriented Software）一书，在此书中共收录了23种设计模式。</p>\n<!-- [[[read_end]]] -->\n<p>这本书的23个经典的设计模式，基本上就是说了两个面向对象的核心理念：</p>\n<ul>\n<li><strong>“Program to an ‘interface’, not an ‘implementation’.”</strong>\n<ul>\n<li>使用者不需要知道数据类型、结构、算法的细节。</li>\n<li>使用者不需要知道实现细节，只需要知道提供的接口。</li>\n<li>利于抽象、封装、动态绑定、多态。</li>\n<li>符合面向对象的特质和理念。</li>\n</ul>\n</li>\n<li><strong>“Favor ‘object composition’ over ‘class inheritance’.”</strong>\n<ul>\n<li>继承需要给子类暴露一些父类的设计和实现细节。</li>\n<li>父类实现的改变会造成子类也需要改变。</li>\n<li>我们以为继承主要是为了代码重用，但实际上在子类中需要重新实现很多父类的方法。</li>\n<li>继承更多的应该是为了多态。</li>\n</ul>\n</li>\n</ul>\n<h1>示例一：拼装对象</h1>\n<p>好，我们先来看一个示例，假设我们有如下的描述：</p>\n<ul>\n<li><strong>四个物体</strong>：木头桌子、木头椅子、塑料桌子、塑料椅子</li>\n<li><strong>四个属性</strong>：燃点、密度、价格、重量</li>\n</ul>\n<p>那么，我们怎么用面向对象的方式来设计我们的类呢？</p>\n<p>参看下图：</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/31/1d/312b75985fa6a969084f7180efc2861d.jpg?wh=2109x1260\" alt=\"\" /></p>\n<ul>\n<li>图的左边是“材质类” Material。其属性有燃点和密度。</li>\n<li>图的右边是“家具类” Furniture。其属性有价格和体积。</li>\n<li>在Furniture中耦合了Material。而具体的Material是Wood还是Plastic，这在构造对象的时候注入到Furniture里就好了。</li>\n<li>这样，在家具类中，通过材料的密度属性和家具的体积属性就可以计算出重量属性。</li>\n</ul>\n<p>这样设计的优点显而易见，它能和现实世界相对应起来，而且，材料类是可以重用的。这个模式也表现了面向对象的拼装数据的另一个精髓——喜欢组合，而不是继承。这个模式在设计模式里叫“桥接（Bridge）模式”。</p>\n<p>和函数式编程来比较，函数式强调动词，而面向对象强调名词，面向对象更多地关注接口间的关系，而通过多态来适配不同的具体实现。</p>\n<h1>示例二：拼装功能</h1>\n<p>再来看一个示例。我们的需求是：处理电商系统中的订单，处理订单有一个关键的动作就是计算订单的价格。有的订单需要打折，有的则不打折。</p>\n<p>在进行面向对象编程时，假设我们用Java语言，我们需要先写一个接口—— <code>BillingStrategy</code>，其中一个方法就是<code>getActPrice(double rawPrice)</code>，输入一个原始的价格，输出一个根据相应的策略计算出来的价格。</p>\n<pre><code>interface BillingStrategy {\n    public double getActPrice(double rawPrice);\n}\n</code></pre>\n<p>这个接口很简单，只是对接口的抽象，而与实现无关。现在我们需要对这个接口进行实现。</p>\n<pre><code>// Normal billing strategy (unchanged price)\nclass NormalStrategy implements BillingStrategy {\n    @Override\n    public double getActPrice(double rawPrice) {\n        return rawPrice;\n    }\n}\n\n// Strategy for Happy hour (50% discount)\nclass HappyHourStrategy implements BillingStrategy {\n    @Override\n    public double getActPrice(double rawPrice) {\n        return rawPrice * 0.5;\n    }\n}\n</code></pre>\n<p>上面的代码实现了两个策略，一个是不打折的：<code>NormalStrategy</code>，一个是打了5折的：<code>HappyHourStrategy</code>。</p>\n<p>于是，我们先封装订单项 <code>OrderItem</code>，其包含了每个商品的原始价格和数量，以及计算价格的策略。</p>\n<pre><code>class OrderItem {\n    public String Name;\n    public double Price;\n    public int Quantity;\n    public BillingStrategy Strategy;\n    public OrderItem(String name, double price, int quantity, BillingStrategy strategy) {\n        this.Name = name;\n        this.Price = price;\n        this.Quantity = quantity;\n        this.Strategy = strategy;\n    }\n}\n</code></pre>\n<p>然后，在我们的订单类—— <code>Order</code> 中封装了 <code>OrderItem</code> 的列表，即商品列表。并在操作订单添加购买商品时，加入一个计算价格的 <code>BillingStrategy</code>。</p>\n<pre><code>class Order {\n    private List&lt;OrderItem&gt; orderItems = new ArrayList&lt;OrderItem&gt;();\n    private BillingStrategy strategy = new NormalStrategy();\n\n    public void Add(String name, double price, int quantity, BillingStrategy strategy) {\n        orderItems.add(new OrderItem(name, price, quantity, strategy));\n    }\n    \n    // Payment of bill\n    public void PayBill() {\n        double sum = 0;\n        for (OrderItem item : orderItems) {\n            \n            actPrice = item.Strategy.getActPrice(item.price * item.quantity);\n            sum += actPrice;\n            \n            System.out.println(&quot;%s -- %f(%d) - %f&quot;, \n            \t\titem.name, item.price, item.quantity, actPrice);\n        }\n        System.out.println(&quot;Total due: &quot; + sum);\n    }\n}\n\n</code></pre>\n<p>最终，我们在 <code>PayBill()</code> 函数中，把整个订单的价格明细和总价打印出来。</p>\n<p>在上面这个示例中，可以看到，我把定价策略和订单处理的流程分开了。这么做的好处是，我们可以随时给不同的商品注入不同的价格计算策略，这样一来就有很高的灵活度了。剩下的事就交给我们的运营人员来配置不同的商品使用什么样的价格计算策略了。</p>\n<p>注意：现实社会中，订单价格计算会比这个事复杂得多，比如：有会员价，有打折卡，还有商品的打包价等，而且还可以叠加不同的策略（叠加策略用前面说的函数式的pipeline或decorator就可以实现）。我们这里只是为了说明面向对象编程范式，所以故意简单化了。</p>\n<p>其实，这个设计模式叫——策略模式。我认为，这是设计模式中最为经典的模式了，其充分体现了面向对象编程的方式。</p>\n<h1>示例三：资源管理</h1>\n<p>先看一段代码：</p>\n<pre><code>mutex m;\n\nvoid foo() {\n    m.lock();\n    Func();\n    if ( ! everythingOk() ) return; \n    ...\n    ...\n    m.unlock();\n}\n</code></pre>\n<p>可以看到，上面这段代码是有问题的，原因是：那个 <code>if</code> 语句返回时没有把锁给unlock掉，这会导致锁没有被释放。如果我们要把代码写对，需要在return前unlock一下。</p>\n<pre><code>mutex m;\n\nvoid foo() {\n    m.lock();\n    Func();\n    if ( ! everythingOk() ) {\n        m.unlock();\n        return;\n    } \n    ...\n    ...\n    m.unlock();\n}\n</code></pre>\n<p>但是，在所有的函数退出的地方都要加上 <code>m.unlock();</code> 语句，这会让我们很难维护代码。于是可以使用面向对象的编程模式，我们先设计一个代理类。</p>\n<pre><code>class lock_guard {\n\tprivate: \n\t\tmutex &amp;_m;\n\tpublic:\n\t\tlock_guard(mutex &amp;m):_m(m) { _m.lock(); }\n\t\t~lock_guard() { _m.unlock(); }\n};\n</code></pre>\n<p>然后，我们的代码就可以这样写了：</p>\n<pre><code>mutex m;\n\nvoid foo() {\n\tlock_guard guard(m);\n\tFunc();\n\tif ( ! everythingOk() ) {\n\t\treturn;\n\t} \n\t...\n\t...\n}\n</code></pre>\n<p>这个技术叫RAII（Resource Acquisition Is Initialization，资源获取就是初始化）， 是C++中的一个利用了面向对象的技术。这个设计模式叫“代理模式”。我们可以把一些控制资源分配和释放的逻辑交给这些代理类，然后，只需要关注业务逻辑代码了。而且，在我们的业务逻辑代码中，减少了这些和业务逻辑不相关的程序控制的代码。</p>\n<p>从上面的代码中，我们可以看到下面几个面向对象的事情。</p>\n<ul>\n<li>\n<p>我们使用接口抽象了具体的实现类。</p>\n</li>\n<li>\n<p>然后其它类耦合的是接口而不是实现类。这就是多态，其增加了程序的可扩展性。</p>\n</li>\n<li>\n<p>因为这就是接口编程，所谓接口也就是一种“协议”，就像HTTP协议一样。浏览器和后端的程序都依赖于这一种协议，而不是具体实现（如果是依赖具体实现，那么浏览器就要依赖后端的编程语言或中间件了，这就太恶心了）。于是，浏览器和后端的程序就完全解除依赖关系，而去依赖于一个标准的协议。</p>\n</li>\n<li>\n<p>这就是面向对象的编程范式的精髓！同样也是IoC/DIP（控制反转/依赖倒置）的本质。</p>\n</li>\n</ul>\n<h1>IoC 控制反转</h1>\n<p>关于IoC的的概念提出来已经很多年了，其被用于一种面向对象的设计。我在这里再简单地回顾一下这个概念。我先谈技术，再说管理。</p>\n<p>话说，我们有一个开关要控制一个灯的开和关这两个动作，最常见也是最没有技术含量的实现会是这个样子：</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/31/16/31b5900acf68c8bf0a60abe13615a816.jpg?wh=1350x759\" alt=\"\" /><br />\n然后，有一天，我们发现需要对灯泡扩展一下，于是做了个抽象类：</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/10/11/1013e5f8ab38fcb1591d02f38c813911.jpg?wh=1623x1023\" alt=\"\" /><br />\n但是，如果有一天，我们发现这个开关可能还要控制别的不单单是灯泡的东西，就会发现这个开关耦合了灯泡这种类别，非常不利于扩展，于是反转控制出现了。</p>\n<p>就像现实世界一样，造开关的工厂根本不关心要控制的东西是什么，它只做一个开关应该做好的事，就是把电接通，把电断开（不管是手动的，还是声控的，还是光控，还是遥控的）。而我们造的各种各样的灯泡（不管是日光灯、白炽灯）的工厂也不关心你用什么样的开关，反正我只管把灯的电源接口给做出来。然后，开关厂和电灯厂依赖于一个标准的通电和断电的接口。于是产生了IoC控制反转，如下图：</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/62/40/62eedb8a4ffdae94604759659078db40.jpg?wh=2190x1587\" alt=\"\" /><br />\n所谓控制反转的意思是，开关从以前设备的专用开关，转变到了控制电源的开关，而以前的设备要反过来依赖于开关厂声明的电源连接接口。只要符合开关厂定义的电源连接的接口，这个开关可以控制所有符合这个电源连接接口的设备。也就是说，开关从依赖设备这种情况，变成了设备反过来依赖于开关所定义的接口。</p>\n<p>这样的例子在生活中太多见了，比如说：</p>\n<ul>\n<li>\n<p>钱就是一个很好的例子。以前大家都是“以物易物”，所以，在各种物品之前都需要相应的“交易策略”，比如：一头羊换2袋米，一袋米换一斤猪后腿肉……这种换算太复杂了。于是，“钱”就出来了，所谓“钱”，其实就是一种交易协议，所有的商品都依赖这个协议，而不用再互相依赖了。于是整个世界的运作就简单了很多。</p>\n</li>\n<li>\n<p>在交易的过程中，卖家向买家卖东西，一手交钱一手交货，所以，基本上来说卖家和买家必需强耦合（必需见面）。这个时候，银行出来做担保，买家把钱先垫到银行，银行让卖家发货，买家验货后，银行再把钱打给卖家。这就是反转控制。买卖双方把对对方的直接依赖和控制，反转到了让对方来依赖一个标准的交易模型的接口。股票交易也是一样的，证交所就是买卖双方的标准交易模型接口。</p>\n</li>\n<li>\n<p>上面这个例子，可能还不明显，再举一个例子。海尔公司作为一个电器制商需要把自己的商品分销到全国各地，但是发现，不同的分销渠道有不同的玩法，于是派出了各种销售代表玩不同的玩法。随着渠道越来越多，发现，每增加一个渠道就要新增一批人和一个新的流程，严重耦合并依赖各渠道商的玩法。</p>\n</li>\n</ul>\n<p>实在受不了了，于是制定业务标准，开发分销信息化系统，只有符合这个标准的渠道商才能成为海尔的分销商，让各个渠道商反过来依赖自己标准。反转了控制，倒置了依赖。</p>\n<p>这个思维方式其实还深远地影响了很多东西，比如我们的系统架构。</p>\n<ul>\n<li>云计算平台中有很多的云产品线。一些底层服务的开发团队只管开发底层的技术，然后什么也不管了，就交给上层的开发人员。上层开发人员在底层团队开发出来的产品上面开发各种管理这个底层资源的东西，比如：生产底层资源的业务，底层资源的控制台，底层资源的监控系统。</li>\n</ul>\n<p>然而，随着接入的资源越来越多，上层为各个云资源控制生产，开发控制台和监控的团队，完全干不过来了。这个时候依赖倒置和反转控制又可以解决问题了。为了有统一体验，各个云产品线需要遵从一定的协议或规范来开发。比如，每个云产品团队需要按照标准定义相关资源的生命周期管理，提供控制台，接入整体监控系统，通过标准的协议开发控制系统。</p>\n<ul>\n<li>集中式处理电子商务订单的流程。各个垂直业务线都需要通过这个平台来处理自己的交易业务，但是垂直业务线上的个性化需求太多。于是，这个技术平台开始发现，对来自各个业务方的需求应接不暇，各种变态需求严重干扰系统，各种技术决策越来越不好做，导致需求排期排不过来。</li>\n</ul>\n<p>这个时候，也可以使用依赖倒置和反转控制的思想来解决问题：开发一个插件模型、工作流引擎和Pub/Sub系统，让业务方的个性化需求支持以插件的方式插入订单流程中。业务方自己的数据存在自己的库中，业务逻辑也不要侵入系统，并可以使用工作流引擎或Pub/Sub的协议标准来自己定义工作流的各个步骤（甚至把工作流引擎的各个步骤的decider交给各个业务方自行处理）。</p>\n<p>让各个业务方来依赖于标准插件和工作流接口，反转控制，让它们来控制系统，依赖倒置，让它们来依赖标准。</p>\n<p>上面这些我想说什么？我想说的是：</p>\n<ul>\n<li>\n<p>我们每天都在标准化和定制化中纠结。我们痛苦于哪些应该是平台要做的，哪些应该要甩出去的。</p>\n</li>\n<li>\n<p>这里面会出现大量的与业务无关的软件或中间件，包括协议、数据、接口……</p>\n</li>\n<li>\n<p>通过面向对象的这些方式，我们可以通过抽象来解耦，通过中间件来解耦，这样可以降低软件的复杂度。</p>\n</li>\n</ul>\n<p>总而言之，我们就是想通过一种标准来让业务更为规范。</p>\n<h1>小结</h1>\n<p>不过，我们也需要知道面向对象的优缺点。</p>\n<p><strong>优点</strong></p>\n<ul>\n<li>能和真实的世界交相辉映，符合人的直觉。</li>\n<li>面向对象和数据库模型设计类型，更多地关注对象间的模型设计。</li>\n<li>强调于“名词”而不是“动词”，更多地关注对象和对象间的接口。</li>\n<li>根据业务的特征形成一个个高内聚的对象，有效地分离了抽象和具体实现，增强了可重用性和可扩展性。</li>\n<li>拥有大量非常优秀的设计原则和设计模式。</li>\n<li>S.O.L.I.D（单一功能、开闭原则、里氏替换、接口隔离以及依赖反转，是面向对象设计的五个基本原则）、IoC/DIP……</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>代码都需要附着在一个类上，从一侧面上说，其鼓励了类型。</li>\n<li>代码需要通过对象来达到抽象的效果，导致了相当厚重的“代码粘合层”。</li>\n<li>因为太多的封装以及对状态的鼓励，导致了大量不透明并在并发下出现很多问题。</li>\n</ul>\n<p>还是好多人并不是喜欢面向对象，尤其是喜欢函数式和泛型那些人，似乎都是非常讨厌面向对象的。</p>\n<p>通过对象来达到抽象结果，把代码分散在不同的类里面，然后，要让它们执行起来，就需要把这些类粘合起来。所以，它另外一方面鼓励相当厚重的代码黏合层（代码黏合层就是把代码黏合到这里面）。</p>\n<p>在Java里有很多注入方式，像Spring那些注入，鼓励黏合，导致了大量的封装，完全不知道里面在干什么事情。而且封装屏蔽了细节，具体发生啥事你还不知道。这些都是面向对象不太好的地方。</p>\n<p>以下是《编程范式游记》系列文章的目录，方便你了解这一系列内容的全貌。</p>\n<ul>\n<li><a href=\"https://time.geekbang.org/column/article/301\">01 | 编程范式游记：起源</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/303\">02 | 编程范式游记：泛型编程</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2017\">03 | 编程范式游记：类型系统和泛型的本质</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2711\">04 | 编程范式游记：函数式编程</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2723\">05 | 编程范式游记：修饰器模式</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2729\">06 | 编程范式游记：面向对象编程</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2741\">07 | 编程范式游记：基于原型的编程范式</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2748\">08 | 编程范式游记：Go 语言的委托模式</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2751\">09 | 编程范式游记：编程的本质</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2752\">10 | 编程范式游记：逻辑编程范式</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2754\">11 | 编程范式游记：程序世界里的编程范式</a></li>\n</ul>\n","neighbors":{"left":{"article_title":"34 | 编程范式游记（5）- 修饰器模式","id":2723},"right":{"article_title":"36 | 编程范式游记（7）- 基于原型的编程范式","id":2741}},"comments":[{"had_liked":false,"id":195113,"user_name":"业余爱好者","can_delete":false,"product_type":"c1","uid":1482915,"ip_address":"","ucode":"A890935A982988","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","comment_is_top":false,"comment_ctime":1585138036,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"203448600948","product_id":100002201,"comment_content":"控制反转就是:从“受制于人”到“授制于人”。","like_count":46},{"had_liked":false,"id":2445,"user_name":"光明","can_delete":false,"product_type":"c1","uid":1002252,"ip_address":"","ucode":"0A5E7CFD91A3CF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4b/0c/dab49a2b.jpg","comment_is_top":false,"comment_ctime":1517272384,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"87416618304","product_id":100002201,"comment_content":"文章太好了，赞👍","like_count":20,"discussions":[{"author":{"id":1509673,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/ts4U7Bn2aPoHmHkKfib1FfmBWrJrDwiaddia5P6HVE3NA26LkRasybwPzWScn3ZUSTYib4kz5zlANTTcy0JSlUnkmA/132","nickname":"lrlzhcoding","note":"","ucode":"9E71B9093B9667","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":210700,"discussion_content":"牛呀，就是这么有深度！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584762219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98244,"user_name":"拉欧","can_delete":false,"product_type":"c1","uid":1206605,"ip_address":"","ucode":"40996A8093A95F","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/4d/81c44f45.jpg","comment_is_top":false,"comment_ctime":1558941111,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"61688483255","product_id":100002201,"comment_content":"面向对象编程，一是抽象思维，把数据和算法抽象成类和对象；二是标准化，接口即协议，所有的实现类都要满足定义的接口才可以作为依赖；三是封装，对象之间通过接口调用，互相之间不关心彼此的细节；总之，接口的定义是否清晰是面向对象设计的关键；<br>由于对象内封装了状态，所以在并发环境下天然存在问题","like_count":14},{"had_liked":false,"id":113919,"user_name":"瀚海星尘","can_delete":false,"product_type":"c1","uid":1024461,"ip_address":"","ucode":"90F418299EA3BF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a1/cd/2c513481.jpg","comment_is_top":false,"comment_ctime":1563185073,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35922923441","product_id":100002201,"comment_content":"IoC&#47;DIP的思想真是酷啊！！！","like_count":8},{"had_liked":false,"id":5658,"user_name":"连子","can_delete":false,"product_type":"c1","uid":1083778,"ip_address":"","ucode":"9A8F2BBE5AA736","user_header":"https://static001.geekbang.org/account/avatar/00/10/89/82/9df54b61.jpg","comment_is_top":false,"comment_ctime":1523715032,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31588486104","product_id":100002201,"comment_content":"领域建模啥时候讲讲？","like_count":7},{"had_liked":false,"id":3529,"user_name":"Join","can_delete":false,"product_type":"c1","uid":1014873,"ip_address":"","ucode":"20F51EFFD8FEDE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7c/59/dc9bbb21.jpg","comment_is_top":false,"comment_ctime":1519825135,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31584596207","product_id":100002201,"comment_content":"刚好今天代码里用到了IOC&#47;DI,这时候看下文章太有感觉了，有补充了新的知识，谢谢皓子叔","like_count":7},{"had_liked":false,"id":5253,"user_name":"fsj","can_delete":false,"product_type":"c1","uid":1017571,"ip_address":"","ucode":"5DA2B549C9B5FE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/86/e3/28d1330a.jpg","comment_is_top":false,"comment_ctime":1522942631,"is_pvip":false,"replies":[{"id":"1430","content":"求不丑陋的例子","user_name":"作者回复","user_name_real":"左耳朵","uid":"1001269","ctime":1523159616,"ip_address":"","comment_id":5253,"utype":1}],"discussion_count":7,"race_medal":0,"score":"27292746407","product_id":100002201,"comment_content":"示例三中的代码感觉使用了RAII技术也很丑陋；控制反转挺难理解的，但是我觉得更难的是识别出哪里需要控制反转","like_count":6,"discussions":[{"author":{"id":1001269,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/35/89726f5f.jpg","nickname":"左耳朵","note":"","ucode":"8A4741D677702E","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":416652,"discussion_content":"求不丑陋的例子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1523159616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1182146,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/c2/8c5442bf.jpg","nickname":"老庄道人","note":"","ucode":"C102EA323A69B4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539407,"discussion_content":"对于C++熟悉的人就会感觉这是C++世界里最重要的技术之一了！而且C++是确定性析构，完全可以计算在哪里析构，哪里退出，使得完全控制成为可能（不像Java，使用垃圾回收，完全无法计算出何时析构对象）\n另外，什么是丑陋，什么不是丑陋呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639709407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1273920,"avatar":"https://static001.geekbang.org/account/avatar/00/13/70/40/ce062d99.jpg","nickname":"丝竹乱耳","note":"","ucode":"933A41A394B0E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":412914,"discussion_content":"我觉得也挺难理解的 主要是析构函数  何时退出。我也忘记了。我觉得耗子应该解释一下的。例子是不好理解。换成java的代理就非常棒了。你们这些人呐 还不让人有其他声音 服了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636331809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1363691,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ce/eb/d5489892.jpg","nickname":"CComma","note":"","ucode":"58AE7F9013D402","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371454,"discussion_content":"控制反转是最基本的概念了吧。。。随便找个应届生问问应该都知道","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619774158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2446418,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/zdK3dSkFwicZHtx5CLAKFJRORRibq2YqvHOP0tySLxVx0X1oD9AJanan2wia2hHaswgxdrCzEEGyVgFTVZ8sElTzQ/132","nickname":"Geek_fbfc4f","note":"","ucode":"7010B242A3F474","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369850,"discussion_content":"说别人代码丑陋，那就请你给出不丑陋的例子出来。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619173232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1148292,"avatar":"https://static001.geekbang.org/account/avatar/00/11/85/84/0dbdf8c1.jpg","nickname":"Jover","note":"","ucode":"0D4D45ED55C37B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320158,"discussion_content":"觉得这里RAII丑陋的，我怀疑你是外行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604278817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2002555,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/8e/7b/701c741f.jpg","nickname":"难得自然萌","note":"","ucode":"73C86B48236104","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302183,"discussion_content":"C#中接口Proxy","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598833749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96041,"user_name":"七月有风","can_delete":false,"product_type":"c1","uid":1439990,"ip_address":"","ucode":"B3F82397347C5B","user_header":"https://static001.geekbang.org/account/avatar/00/15/f8/f6/3e2db176.jpg","comment_is_top":false,"comment_ctime":1558315759,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"14443217647","product_id":100002201,"comment_content":"老师，您好，RAII 那段代码在C++中可以那样去实现，在JavaScript中有没有替代方案，最近就有这个问题，一直没找到很好的解决方案。请老师回复。","like_count":3,"discussions":[{"author":{"id":1620237,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b9/0d/ae745ec0.jpg","nickname":"刹那","note":"","ucode":"E0B1C29EB07754","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":251261,"discussion_content":"装饰器","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1588077374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1723812,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/4d/a4/d28eb55d.jpg","nickname":"拒绝","note":"","ucode":"36BBA79BBFEA8B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":192425,"discussion_content":"不成熟的小建议，是不是可以尝试下中间件","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583074107,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106498,"user_name":"edisonhuang","can_delete":false,"product_type":"c1","uid":1530167,"ip_address":"","ucode":"BB2F639A779F96","user_header":"https://static001.geekbang.org/account/avatar/00/17/59/37/bd2de0a4.jpg","comment_is_top":false,"comment_ctime":1561336867,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10151271459","product_id":100002201,"comment_content":"面向对象的编程有三大特性：封装、继承和多态<br>相比于函数式编程更强调动作，面向对象则更强调名词。它更符合我们人类的思考模式，将数据封装在对象之中 <br>面向对象强调两点，一是面向接口而非面向实现编程。二是偏向使用组合而非继承。<br>通过面向对象的方法，实现控制反转个依赖导致。对于底层的服务更多的是实现标准的协议，同时将协议开放出来提供给其他系统订阅 。而基于协议需要做怎样的具体操作，则交给其他系统以及来决策<br>","like_count":3},{"had_liked":false,"id":99440,"user_name":"Valen","can_delete":false,"product_type":"c1","uid":1142948,"ip_address":"","ucode":"282DB2DB480507","user_header":"https://static001.geekbang.org/account/avatar/00/11/70/a4/33bf86a0.jpg","comment_is_top":false,"comment_ctime":1559214851,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10149149443","product_id":100002201,"comment_content":"@xilie 关于会员等级与多个业务特权对应的问题, 想了下可以用控制反转的方法. 就是抽出一个 等级&lt;-&gt;特权 的标准出来, 向外提供 类似 `getPrivileges(level)`, `havePrivilege(privilege, level)` 的接口, 然后会员等级系统和业务系统都依赖于这个标准. 有变动的话就直接改这个标准就行","like_count":2},{"had_liked":false,"id":89147,"user_name":"xilie","can_delete":false,"product_type":"c1","uid":1013805,"ip_address":"","ucode":"AFCC4E157F7830","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJVegfjqa0gM4hcRrBhZkIf7Uc5oeTMYsg6o5pd76IQlUoIIh2ic6P22xVEFtRnAzjyLtiaPVstkKug/132","comment_is_top":false,"comment_ctime":1556090991,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10146025583","product_id":100002201,"comment_content":"有个面向对象的设计问题求解：<br><br>背景：1、有会员等级系统，等级级别分类需要由运营情况来定可伸缩，并不固定；2、好几个业务系统，跟进会员等级，给予不同的会员权利；<br><br>问题：如果会员等级系统只提供接口，业务系统使用，这样虽然会员等级系统很干净，可是一旦会员等级系统的级别分类变化，各业务系统得对应开发。而如果换个方式，业务系统注入不同等级的会员权利，会员等级系统就很不干净，而且各业务系统注入的会员等级可能不一致，造成混乱。<br><br>不像开关，只有开和关，固定不变，会员等级系统内的等级级别会变化，怎么解决呢？","like_count":2,"discussions":[{"author":{"id":1062530,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/1dqCdNfN3fwbWl9JGEiamPW2Nqy53msKRZQRASEszfdsYEgbGwSVJy2S6EhJbmH5htbuwWZUYuicskRM7Jw2ibiaUA/132","nickname":"Jack","note":"","ucode":"E2D6427C2E65B6","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":110876,"discussion_content":"统一等级，业务系统各自实现权利","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577761911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2066246,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/87/46/125e5997.jpg","nickname":"Thyyyy","note":"","ucode":"EF90097F54784E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376639,"discussion_content":"选1，因为不同等级的会员权利是纯业务的东西不应该进会员等级系统。 这里有问题的是需求的设计，会员等级能随意伸缩本质上意味着“会员等级”不是一个严格定义的规范，在没有规范的情况下谈会员权利本来就是不可能的。\n有一个可能到折衷方案是，预先定义出一个比较细的对内会员等级（比如分100级），业务方针对这个100级赋予权利。同时运营方在这个100级里面去区分外部看到的会员等级。\n当然这样还是不好，理想情况下应该是讨论清楚需求，预先确定不会修改的等级级别，才能保证各个业务授权统一性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622247251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20524,"user_name":"宋桓公","can_delete":false,"product_type":"c1","uid":1151948,"ip_address":"","ucode":"04235C2B87AB0E","user_header":"https://static001.geekbang.org/account/avatar/00/11/93/cc/dfe92ee1.jpg","comment_is_top":false,"comment_ctime":1534509466,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10124444058","product_id":100002201,"comment_content":"我觉得面向对象最有用的是多态","like_count":2,"discussions":[{"author":{"id":2002555,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/8e/7b/701c741f.jpg","nickname":"难得自然萌","note":"","ucode":"73C86B48236104","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302184,"discussion_content":"首先要有封装才会有继承有了继承才会有多态","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598833809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169616,"user_name":"slark","can_delete":false,"product_type":"c1","uid":1143574,"ip_address":"","ucode":"7E8DE962AA23A7","user_header":"https://static001.geekbang.org/account/avatar/00/11/73/16/595b0342.jpg","comment_is_top":false,"comment_ctime":1578390615,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5873357911","product_id":100002201,"comment_content":"面向对象从了解时候感觉很自然，通过类封装数据，对外只暴露接口，只要接口不变，底层实现可以进行更新，同时通过继承和多态，适应了动态场景。但函数式编程里就不需要了么？期待后续说明","like_count":1},{"had_liked":false,"id":140290,"user_name":"业余爱好者","can_delete":false,"product_type":"c1","uid":1482915,"ip_address":"","ucode":"A890935A982988","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","comment_is_top":false,"comment_ctime":1570871475,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5865838771","product_id":100002201,"comment_content":"本文的控制反转似乎和spring中的控制反转不是一回事？","like_count":1,"discussions":[{"author":{"id":1156607,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a5/ff/6201122c.jpg","nickname":"Geek_89bbab","note":"","ucode":"B3110D5B3C9500","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288993,"discussion_content":"Martin Fowler一篇文章中提到：\n现在对控制反转的含义有些混淆;有些人将这里的一般原则与这些容器使用的控制反转(如依赖注入)的特定样式混淆了。\n文中讲的是通用的IOC的一般原则。 spring中的ioc大多是依赖注入的模式。\nThere is some confusion these days over the meaning of inversion of control due to the rise of IoC containers; some people confuse the general principle here with the specific styles of inversion of control (such as dependency injection) that these containers use. The name is somewhat confusing (and ironic) since IoC containers are generally regarded as a competitor to EJB, yet EJB uses inversion of control just as much (if not more).","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1593952826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1144462,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/8e/cf43b065.jpg","nickname":"Lee","note":"","ucode":"314D7BCB5C7C24","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379704,"discussion_content":"Spring的IOC讲的其实就是依赖注入，而我觉得作者讲的IOC更像是依赖反转，现在大家对IOC的理解就像对面向对象的理解一样，一家一个样啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624085628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":2478,"user_name":"Freezer","can_delete":false,"product_type":"c1","uid":1013840,"ip_address":"","ucode":"5592D85A343C3C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/50/1c9a95f8.jpg","comment_is_top":false,"comment_ctime":1517368279,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5812335575","product_id":100002201,"comment_content":"耗子神，更新的太慢了，求加餐啊🙏🙏🙏","like_count":1},{"had_liked":false,"id":2468,"user_name":"RZ_diversity","can_delete":false,"product_type":"c1","uid":1007035,"ip_address":"","ucode":"C1F39517927DE4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5d/bb/1c579a50.jpg","comment_is_top":false,"comment_ctime":1517345473,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5812312769","product_id":100002201,"comment_content":"看过后，对本科学的C＋＋有了新的认识，需要反复领会其中的知识点","like_count":1},{"had_liked":false,"id":332283,"user_name":"丝竹乱耳","can_delete":false,"product_type":"c1","uid":1273920,"ip_address":"","ucode":"933A41A394B0E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/70/40/ce062d99.jpg","comment_is_top":false,"comment_ctime":1643157411,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643157411","product_id":100002201,"comment_content":"面向对象最大的问题 把逻辑写在不同文件中，然后又想办法聚集在一起。搞出一大堆  概念。动态代理 委托 spi<br>让人看不懂 甚至头疼。","like_count":0},{"had_liked":false,"id":276596,"user_name":"喜剧。","can_delete":false,"product_type":"c1","uid":1042681,"ip_address":"","ucode":"5F9CF567792B8A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e8/f9/4412b473.jpg","comment_is_top":false,"comment_ctime":1612022232,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612022232","product_id":100002201,"comment_content":"以前对接口的理解不是那么深刻，今天学习到了。","like_count":0},{"had_liked":false,"id":266454,"user_name":"刘匿名","can_delete":false,"product_type":"c1","uid":1319157,"ip_address":"","ucode":"CB4C1DC8C1BB31","user_header":"https://static001.geekbang.org/account/avatar/00/14/20/f5/6cdbfa90.jpg","comment_is_top":false,"comment_ctime":1607344159,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1607344159","product_id":100002201,"comment_content":"面向对象确实是很好的设计思想，不过很多情况下确实会引起层层封装。<br>用好面向对象的难点主要是对象概念的拆分吧，颗粒度多大合适？是否有必要所有逻辑都创建一个对象？当前这么拆是否是过度设计？<br>进一步讲，难点还是在于需求走向的把握吧","like_count":0},{"had_liked":false,"id":261529,"user_name":"爱学习的大叔","can_delete":false,"product_type":"c1","uid":1085152,"ip_address":"","ucode":"91F9ABF1EC98D0","user_header":"https://static001.geekbang.org/account/avatar/00/10/8e/e0/847348b1.jpg","comment_is_top":false,"comment_ctime":1605402952,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605402952","product_id":100002201,"comment_content":"用了几年c#，面向对象你总是可以很好的去根据现实世界去抽象事物，坏处就是系统大了类满天飞，但是你又不得不用。","like_count":0},{"had_liked":false,"id":256623,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1603692409,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603692409","product_id":100002201,"comment_content":"面向对象编程可以说是我最熟悉的编程范式，以下是我的一点点理解：<br>1、面向对象编程注重抽象和分层，这是计算机科学解决复杂问题的方案，甚至是人类解决复杂问题的方案。如 SpringMVC，就是典型的一种分层和抽象策略，它让我们设计大型复杂系统成为了可能，可以逐层击破，并且各自优化。<br>2、面向对象编程还天然地契合现实生活，使代码易于理解。<br><br>面向对象编程，我自己踩过的坑，就是分层透传问题。底层的实现直接浮上抽象层，这样就会出现代码逐渐奔溃的现象。假如可以深入回答以下几个问题，我觉得可以理解为对OOP入门：<br>1、为什么类似的 实体类 对象，要分 VO、Entity、DO等多个类似的对象？<br>2、为什么写一个实现类，总是要先写一个接口？<br>3、为什么很多地方需要一个工厂模式？不建议直接 new 一个对象？","like_count":0},{"had_liked":false,"id":247764,"user_name":"你为啥那么牛","can_delete":false,"product_type":"c1","uid":1503506,"ip_address":"","ucode":"1ABC604A54A8F6","user_header":"https://static001.geekbang.org/account/avatar/00/16/f1/12/7dac30d6.jpg","comment_is_top":false,"comment_ctime":1599824017,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1599824017","product_id":100002201,"comment_content":"面向对象，有一种写法，需要耗子叔提供点建议。<br>比如有两个对象，一个是用户对象 User，一个是组织对象Organization。<br>1、我想查机构下所有用户，比如定义了GetUser(string orgId)，那这个定义是归属于User、还是Organization？<br>2、比如我要声明一个组织对象，有一种写法是再Organization得构造函数里，传入了orgId，用于初始化机构对象。比如 var org = new Organization(&quot;orgId&quot;); 此种方式，可不可取？<br>3、比如定义GetUser 归属于组织下，便有了此调用。List&lt;User&gt; usr = org.GetUser()，机构ID得参数是通过构造器传入得。循环usr时，就可以直接调用usr内的属性、方法等，继续进行User对象得操作。<br><br>以上方式，就是微软推崇得面向对象编程得逻辑，感觉很正确，但也觉得很不爽！耗子叔，你怎么看？<br>","like_count":0,"discussions":[{"author":{"id":1299347,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d3/93/c3fb8566.jpg","nickname":"ProcessIsTheKey","note":"","ucode":"BE02EFD75F7D98","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376610,"discussion_content":"个人见解：\n1、getUser(String orgId)这个定义个人觉得归属于User更好，获取某类或某个对象就应该归属于它所在的领域内，统一这样处理，业务及代码边界非常清晰，易于理解和维护；\n2、Organization org = new Organization(&#34;orgId&#34;);这种方式，一般可以用，多数情况下new 一个空的对象，然后调用setter方法更合适一些。\n3、这一点跟第一点有些冲突了，不太建议使用。\n以上纯粹个人见解，还请各位大佬指教。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622210618,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223433,"user_name":"肖臧","can_delete":false,"product_type":"c1","uid":1047733,"ip_address":"","ucode":"4FAC9FF54DD6A0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/b5/ac717737.jpg","comment_is_top":false,"comment_ctime":1591088384,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591088384","product_id":100002201,"comment_content":"“actPrice = item.Strategy.GetActPrice(item.price * item.quantity)”<br>Item这个类应该有个getPrice方法吧，然后在委托给BillStrategy接口的getActPrice方法，我觉得不应该把Strategy暴露出来，这样违反封装性了。另外这是Java代码吧，至少方法的命名规则也应该符合驼峰命名法。感觉这个例子不像耗子老师严谨的风格。","like_count":0},{"had_liked":false,"id":213226,"user_name":"Edward Lee","can_delete":false,"product_type":"c1","uid":1228518,"ip_address":"","ucode":"156223F1D7E94A","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/e6/7808520d.jpg","comment_is_top":false,"comment_ctime":1588335970,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588335970","product_id":100002201,"comment_content":"我觉得面向对象编程其中一个缺点是容易产生过度设计，更严重的缺点又是不设计","like_count":0},{"had_liked":false,"id":211315,"user_name":"Geek_dwq","can_delete":false,"product_type":"c1","uid":1817279,"ip_address":"","ucode":"7DC6BFCF746787","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/wI2LwgvwseNqXwkF67zicD9UXBSle9DPhmL6uyKG9Nib6NLfU3OuKYuSQ4DHCWxIQecnqell2vKVvNX8boox0B8w/132","comment_is_top":false,"comment_ctime":1587948050,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587948050","product_id":100002201,"comment_content":"IoC 控制反转使用的例子很赞，通俗易懂","like_count":0},{"had_liked":false,"id":205826,"user_name":"LeonardRon","can_delete":false,"product_type":"c1","uid":1026808,"ip_address":"","ucode":"1B3ACC61DE1877","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/f8/4b89254e.jpg","comment_is_top":false,"comment_ctime":1586744663,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586744663","product_id":100002201,"comment_content":"理论知识，还是要多品才能领悟","like_count":0},{"had_liked":false,"id":200443,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/d017438c.jpg","comment_is_top":false,"comment_ctime":1585584837,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585584837","product_id":100002201,"comment_content":"耗子叔讲技术深入浅出，就喜欢这种feel","like_count":0},{"had_liked":false,"id":183202,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1582971168,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582971168","product_id":100002201,"comment_content":"这个还比较熟悉，面向对象，万事万物皆对象，强调面向接口编程（接口既协议，好似强调契约精神，协议既定以诚为本）及组合优于继承。<br>控制反转和依赖倒置那一块和之前学的大同小异，估计是讲解角度的差异引起的。","like_count":0},{"had_liked":false,"id":180638,"user_name":"技术骨干","can_delete":false,"product_type":"c1","uid":1098720,"ip_address":"","ucode":"8FCF8DE6D29201","user_header":"https://static001.geekbang.org/account/avatar/00/10/c3/e0/3db22579.jpg","comment_is_top":false,"comment_ctime":1582356845,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582356845","product_id":100002201,"comment_content":"讲的通俗易懂。","like_count":0},{"had_liked":false,"id":171600,"user_name":"行道有德","can_delete":false,"product_type":"c1","uid":1495977,"ip_address":"","ucode":"92B2A5A6E8E7C3","user_header":"https://static001.geekbang.org/account/avatar/00/16/d3/a9/36e59707.jpg","comment_is_top":false,"comment_ctime":1578972710,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578972710","product_id":100002201,"comment_content":"抽丝剥茧","like_count":0}]}