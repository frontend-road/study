{"id":494597,"title":"03｜TDD演示（3）：按测试策略重组测试","content":"<p>你好，我是徐昊。今天我们来继续进行命令行参数解析的TDD演示。</p><p>首先让我们回顾一下题目与需求与代码进度。如前所述，题目源自Bob大叔的  <em><em>Clean Code</em></em>  第十四章：</p><blockquote>\n<p>我们中的大多数人都不得不时不时地解析一下命令行参数。如果我们没有一个方便的工具，那么我们就简单地处理一下传入main函数的字符串数组。有很多开源工具可以完成这个任务，但它们可能并不能完全满足我们的要求。所以我们再写一个吧。<br>\n<strong>　</strong><br>\n传递给程序的参数由标志和值组成。标志应该是一个字符，前面有一个减号。每个标志都应该有零个或多个与之相关的值。例如：<br>\n<strong>　</strong><br>\n-l -p 8080 -d /usr/logs<br>\n<strong>　</strong><br>\n“l”（日志）没有相关的值，它是一个布尔标志，如果存在则为true，不存在则为false。“p”（端口）有一个整数值，“d”（目录）有一个字符串值。标志后面如果存在多个值，则该标志表示一个列表：<br>\n<strong>　</strong><br>\n-g this is a list -d 1 2 -3 5<br>\n<strong>　</strong><br>\n\"g\"表示一个字符串列表[“this”, “is”, “a”, “list”]，“d\"标志表示一个整数列表[1, 2, -3, 5]。<br>\n<strong>　</strong><br>\n如果参数中没有指定某个标志，那么解析器应该指定一个默认值。例如，false代表布尔值，0代表数字，”\"代表字符串，[]代表列表。如果给出的参数与模式不匹配，重要的是给出一个好的错误信息，准确地解释什么是错误的。<br>\n<strong>　</strong><br>\n确保你的代码是可扩展的，即如何增加新的数值类型是直接和明显的。</p>\n</blockquote><!-- [[[read_end]]] --><p>目前我们的代码结构如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/e6/c4/e6efe45de49576d10b0f8b9505c6b8c4.jpg?wh=7064x3323\" alt=\"\"></p><p>我们目前的任务列表为：</p><pre><code>ArgsTest:\n// sad path:\n// TODO: -bool -l t / -l t f\n// TODO: - int -p/ -p 8080 8081\n// TODO: - string -d/ -d /usr/logs /usr/vars\n// default value:\n// TODO: - bool : false\n// TODO: -int :0\n// TODO: - string &quot;&quot;\n</code></pre><h2>调整任务列表</h2><p>当我们罗列任务列表的时候，还没有进行重构，系统中也只有Args一个类。而经过重构之后，我们提取了OptionParser接口，以及与之对应的实现类：BooleanOptionParser和SingleValuedOptionParser。那么当再去构造测试的时候，就存在两个不同的选择：继续针对Args进行测试，或是直接对BooleanOptionParser进行测试。</p><p>代码分别如下所示：</p><pre><code>@Test\npublic void should_not_accept_extra_argument_for_boolean_option() {\n  TooManyArgumentsException e = assertThrows(TooManyArgumentsException.class, \n    () -&gt; Args.parse(BooleanOption.class, &quot;-l&quot;, &quot;t&quot;));\n  assertEquals(&quot;l&quot;, e.getOption()); \n}\n\n@Test\npublic void should_not_accept_extra_argument_for_boolean_option() {\n    TooManyArgumentsException e = assertThrows(TooManyArgumentsException.class, () -&gt;\n            new BooleanOptionParser().parse(&quot;-l&quot;, &quot;t&quot;, option(&quot;l&quot;)));\n    assertEquals(&quot;l&quot;, e.getOption());\n}\n</code></pre><p>在当前的架构下，这两个测试是等效的功能验证，但是它们的测试范围不同，在下图中，我用虚线边框圈定了它们的范围：</p><p><img src=\"https://static001.geekbang.org/resource/image/61/a5/614c3b883bdd3c45f59285992ec502a5.jpg?wh=7487x4213\" alt=\"\"></p><p>那么在这种情况下，我们可以选择粒度更小的测试，这样更有益于问题的定位。于是，我们可以修改任务列表，将剩余的任务分配到对应的组件上去：</p><pre><code>BooleanOptionParserTest: \n// sad path:\n// TODO: -bool -l t / -l t f\n// default:\n// TODO: - bool : false\n\nSingleValuedOptionParserTest:\n// sad path:\n// TODO: - int -p/ -p 8080 8081\n// TODO: - string -d/ -d /usr/logs /usr/vars\n// default value:\n// TODO: -int :0\n// TODO: - string &quot;&quot;\n</code></pre><p>现在让我们进入红/绿循环：</p><p><video poster=\"https://static001.geekbang.org/resource/image/6c/2a/6c00yy3399ed8de0c99f39ac0fb3d32a.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/a9bfca5-17f91706b9e-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/b147373e80d0440d9886f736551ef767/166a063799784ba1b21b129bd5ec4b26-480f0c0504821677b9788fc920148b46-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><p>类似的，根据任务列表，完成SingleValuedOptionParser的功能：</p><p><video poster=\"https://static001.geekbang.org/resource/image/6c/2a/6c00yy3399ed8de0c99f39ac0fb3d32a.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/435dd8e6-17f919289eb-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/d87601e59bbe4c53a68088078bea1297/86c89a93d6304fd38649e5b9f498bfe2-b1aeef6e30c6c484351048aa1e190859-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><h2>按照测试策略重组测试</h2><p>在这个红/绿环节中，我们发现在整数类型和字符串类型的异常场景中，差异仅仅在于如何构造SingleValuedOptionParser：</p><pre><code>new SingleValuedOptionParser(0, Integer:parseInt)\nnew SingleValuedOptionParser(&quot;&quot;, String::valueOf)\n</code></pre><p>也就是说，仅仅是测试代码的差别，而被测试的代码则没有任何区别。我们按照任务列表，再构造其他场景的测试，也仅仅是不同测试数据的重复而已。所以将剩余任务从列表中取消就好了。</p><p>在当前的代码中，还遗存着一些重构前的测试。对比经过重构之后新写的测试，就会发现对于类似的功能，我们测试的出发点和测试的范围都有不同，这是一种坏味道。我们需要对测试进行重构，以消除这些不一致：</p><p><video poster=\"https://static001.geekbang.org/resource/image/6c/2a/6c00yy3399ed8de0c99f39ac0fb3d32a.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/5143a612-17f91839fd6-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/36df79120e4f45de96c86718edab529d/8fbe4a535d574322902224cccaf9c03d-a7bd7b933fd068bf5812733a3b4d5a2c-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><p>在继续完成其他功能之前，我们可以快速审查一下代码，可以显而易见地发现几个明显的Bug，那么我们可以通过一系列红/绿环节来修复它们：</p><p><video poster=\"https://static001.geekbang.org/resource/image/6c/2a/6c00yy3399ed8de0c99f39ac0fb3d32a.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/25515456-17f9176eb96-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/ad1f90ca1b6a4595a12b436a0e51c623/6d6cb2e787f84ac68bd3e1bd88e0018f-bd76453965100ffa32afc3cac1d32063-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><p>好了，到此为止，我们得到了一个颇为健壮的代码，以及清晰、可扩展的代码结构。</p><h2>小结</h2><p>在这节课中，我们展示了红/绿/重构循环是如何与任务列表互动，任务列表又是怎样持续指导我们进行测试驱动开发的。让我们回想一下最开始构想的任务列表：</p><pre><code>// TODO: boolean -l\n// TODO: int -p 8080\n// TODO: string -d /usr/logs\n// TODO: example 1\n// sad path:\n// TODO: -bool -l t / -l t f\n// TODO: - int -p/ -p 8080 8081\n// TODO: - string -d/ -d /usr/logs /usr/vars\n// default value:\n// TODO: - bool : false\n// TODO: -int :0\n// TODO: - string &quot;&quot;\n</code></pre><p>我们真正的开发过程是这样的，先按照任务列表完成了一块功能点：</p><pre><code>// TODO: boolean -l \n// TODO: int -p 8080\n// TODO: string -d /usr/logs\n// TODO: example 1\n</code></pre><p>发现了坏味道，开始重构。通过重构引入了新的组件，改变了架构。于是剩余的任务列表改为：</p><pre><code>BooleanOptionParserTest: \n// sad path:\n// TODO: -bool -l t / -l t f\n// default:\n// TODO: - bool : fals\n\nSingleValuedOptionParserTest:\n// sad path:\n// TODO: - int -p/ -p 8080 8081\n// default value:\n// TODO: -int :0\n</code></pre><p>陆续完成这些任务，发现不一致的测试策略，重组测试。然后进行代码审查，发现了几个缺陷，于是剩余任务列表变为（请重点关注列表的变化）：</p><pre><code>ArgsTest:\n// TODO：无标注的参数\n// TODO：不支持的类型\n   \nSingleValuedOptionParserTest:\n// TODO: 错误的数值格式\n</code></pre><p>不难发现，任务列表是一个随代码结构（重构）、测试策略（在哪个范围内测试）、代码实现情况（存在哪些缺陷）等因素而动态调整的列表。<strong>它的内容体现了我们最新的认知，它的变化记录了我们认知改变的过程。</strong></p><p>下节课，我们将继续完成命令行列表标志的功能。我们会重复任务分解与红/绿/重构循环。请注意，对于列表标志的任务分解与我们已完成的功能有何不同。</p><h2>思考题</h2><p>请根据当前代码结构，对列表标志功能进行任务分解。</p><p>如果你在学习过程中还有什么问题或想法，欢迎加入<a href=\"https://jinshuju.net/f/zvOavT\">读者交流群</a>。最后，也欢迎把你学习这节课的代码与体会分享在留言区，我们下节课再见！</p>","neighbors":{"left":{"article_title":"02｜TDD演示（2）：识别坏味道与代码重构","id":494212},"right":{"article_title":"04｜TDD演示（4）：实现对于列表参数的支持","id":494604}},"comments":[{"had_liked":false,"id":338977,"user_name":"wenming","can_delete":false,"product_type":"c1","uid":1023436,"ip_address":"","ucode":"A0EF1D46850017","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9d/cc/b48d3e96.jpg","comment_is_top":true,"comment_ctime":1647846565,"is_pvip":false,"replies":[{"id":"123895","content":"一般遗漏是&quot;你不知道自己不知道” 所以很难避免 更多需要交叉检验 比如结对编程 或者 code review","user_name":"作者回复","user_name_real":"编辑","uid":"2537798","ctime":1647852858,"ip_address":"","comment_id":338977,"utype":1}],"discussion_count":1,"race_medal":0,"score":"9.2233720642724004e+18","product_id":100109401,"comment_content":"老师，任务列表里面的 Corner case 部分，除了代码审查发现，还有没有其他办法能够避免遗漏导致 BUG 呢？","like_count":6,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557528,"discussion_content":"一般遗漏是&#34;你不知道自己不知道” 所以很难避免 更多需要交叉检验 比如结对编程 或者 code review","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647852858,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339124,"user_name":"🐑","can_delete":false,"product_type":"c1","uid":2189689,"ip_address":"","ucode":"DE34B3B14287D1","user_header":"https://static001.geekbang.org/account/avatar/00/21/69/79/b4132042.jpg","comment_is_top":true,"comment_ctime":1647932994,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"9.2233720470926008e+18","product_id":100109401,"comment_content":"大家好～我是TDD这门课的编辑辰洋～<br><br>🎐我来友情提示一下下～<br><br>01-04是视频演示，好对TDD有个感性的认识。<br><br>05-10是对演示的复盘，同时也会讲解TDD的相关知识点。比如测试的基本结构，TDD中的测试是啥～<br><br>所以，如果你在01-04的操作卡壳了，可以从05开始学，看看5-10，这才是重点哇。看完再回头去看01-04～","like_count":2},{"had_liked":false,"id":339058,"user_name":"临风","can_delete":false,"product_type":"c1","uid":1145430,"ip_address":"","ucode":"59A7F3DDD94D76","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/56/29877cb9.jpg","comment_is_top":false,"comment_ctime":1647875008,"is_pvip":true,"replies":[{"id":"124060","content":"good","user_name":"作者回复","user_name_real":"编辑","uid":"2537798","ctime":1648051646,"ip_address":"","comment_id":339058,"utype":1}],"discussion_count":1,"race_medal":1,"score":"61777417152","product_id":100109401,"comment_content":"测试代码也是需要重构的，之前一直没有意识到这点，觉得就算有点冗余也没关系。但实际上，只要是多余的代码就意味着团队的负债，会增加编译成本、跑用例的时间成本（这两项影响不大），更重要的是影响理解的成本，好的测试，就应该通过测试用例就能清晰的理解业务逻辑，而不是一行一行的去看代码。<br>学习了几讲后，越发觉得TDD其实是一种内功修炼，无论你的水平是多少，都是可以通过TDD不断精进，你对语言特性、设计模式、重构手法等等基本功，还有你对业务的理解，都通过一个个的用例、一次次重构体现出来。<br>TDD是一种对做事方法的极致拆分，一次只做一件事，思考业务逻辑时就不考虑实现和代码坏味道；编写业务代码时，也仅考虑能通过用例的逻辑；而重构时，也是不能改变原来的代码逻辑的。通过一个个极小粒度的操作，实现最终整体的协调，有种艺术的美感。","like_count":15,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558043,"discussion_content":"good","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648051646,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339382,"user_name":"webmin","can_delete":false,"product_type":"c1","uid":1047014,"ip_address":"","ucode":"98B0CA882454E8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/e6/47742988.jpg","comment_is_top":false,"comment_ctime":1648049183,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"18827918367","product_id":100109401,"comment_content":"三课观看下来有一种和老师结对的感觉，忽然明白了结对编程的相互学习过程比结果更最要，以往看到的代码包括开源项目的都已经是阶段性的结果，这个阶段结果的产生其实中间还一些子过程你是看不到的，就算你有设计文档和实现代码但是中间过程是缺失的，且这些中间过程也是无法从设计文档和结果代码反推出来的。中间的这些渐进过程才是内功心法。","like_count":4},{"had_liked":false,"id":339378,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1648048259,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10237982851","product_id":100109401,"comment_content":"03 课<br>学习笔记 http:&#47;&#47;wyyl1.com&#47;post&#47;19&#47;03&#47;<br>源码 https:&#47;&#47;github.com&#47;wyyl1&#47;geektime-tdd&#47;tree&#47;branch-03<br>摘要：<br>1. 测试代码需要重构<br>2. 提前将 Option 对象提取出 flag 的代码在 bad path 翻车了<br>3. 视频中代码的两个坏味道，期中之一：if 没有 “{}”。苹果公司的“GoTo Fail 漏洞”，就是因为没有括号引起的。<br>内容摘自：范学雷老师的专栏 极客时间 | 代码精进之路 | 02 | 把错误关在笼子里的五道关卡","like_count":2,"discussions":[{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558336,"discussion_content":"不客气\n另一个是吞了异常信息","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648211953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","nickname":"escray","note":"","ucode":"1F4204930E47C4","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558273,"discussion_content":"参考了一下你发布的源码，感谢。\n\n另外，摘要第 3 条说两个坏味道，一个是 if 没有 {} ，另一个呢？\n\n对于 if 这个，其实我觉得只要保持了代码的可读性，问题并不大。\n\n当然，如果团队有代码规范，要求 if 必须 {}，那就另外说。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648186365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":352152,"user_name":"老衲","can_delete":false,"product_type":"c1","uid":1433290,"ip_address":"","ucode":"B02BB107DB51BE","user_header":"https://static001.geekbang.org/account/avatar/00/15/de/ca/73f15fe7.jpg","comment_is_top":false,"comment_ctime":1658410279,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658410279","product_id":100109401,"comment_content":"这一节跟上一节的内容是不是少了对TooManyArgumentsException 的封装描述？","like_count":0},{"had_liked":false,"id":346645,"user_name":"子夜枯灯","can_delete":false,"product_type":"c1","uid":1359678,"ip_address":"","ucode":"5D84BFE7832038","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/3e/cdc36608.jpg","comment_is_top":false,"comment_ctime":1653312191,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1653312191","product_id":100109401,"comment_content":"代学习源码: https:&#47;&#47;github.com&#47;ziyekudeng&#47;my-geektime-tdd.git","like_count":0},{"had_liked":false,"id":341605,"user_name":"Geek_7c4953","can_delete":false,"product_type":"c1","uid":1809168,"ip_address":"","ucode":"359745D4725D4F","user_header":"","comment_is_top":false,"comment_ctime":1649732497,"is_pvip":false,"replies":[{"id":"124816","content":"对象风格是以被修改的状态为线索组织代码，过程风格是以流程为线索。思考的方式不一样","user_name":"作者回复","user_name_real":"编辑","uid":"2537798","ctime":1649739126,"ip_address":"","comment_id":341605,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1649732497","product_id":100109401,"comment_content":"这节课的视频看过来，感觉代码变得难以阅读了。<br>我觉得原因有两点：<br>1.因为对坏味道的延迟处理，让坏味道影响了代码的可读性。<br>2.因为对逻辑的构建是点式的而非线性的，导致思维在几个点之间跳跃而非循序渐进的，造成思维处在“先回忆再思考”的循环中。<br><br>不过也有可能是因为不是第一人称写代码，所以思维并不是完全跟上，不知道老师对这个问题怎么看。","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561891,"discussion_content":"对象风格是以被修改的状态为线索组织代码，过程风格是以流程为线索。思考的方式不一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649739126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341086,"user_name":"奇小易","can_delete":false,"product_type":"c1","uid":1171151,"ip_address":"","ucode":"E06B4DFB5352BB","user_header":"https://static001.geekbang.org/account/avatar/00/11/de/cf/ef2e0501.jpg","comment_is_top":false,"comment_ctime":1649339826,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1649339826","product_id":100109401,"comment_content":"2W2H笔记<br><br>What<br>Q: 什么是按测试策略重组测试？<br>A:<br>视频中的操作实际上就是把ArgsTest中的部分测试挪到了BooleanOptionParserTest中。<br>本质上就是让所有测试都能放到合适的地方。也就是按照测试策略（哪个测试方法放哪里）重组了测试。<br><br>Q：任务列表和红&#47;绿&#47;重构循环之间是如何相互影响的？<br>A:<br>第一课中，分解出第一版任务列表，完成了三种简单类型的解析的Happy Path。<br>第二课中，识别现有代码的坏味道，并使用重构将其消除。此时代码结构已经被调整。<br>第三课中，<br>由于代码结构的调整，故任务列表也随之进行调整。<br>继续完成三种简单类型解析的sad path和default value。<br>发现测试代码中存在坏味道，对测试代码进行重组。<br>完成这些操作之后，对当前代码进行代码审查，发现有些新的任务需要做。<br>此时任务列表也被更新。<br><br>How<br>Q: 在同一个代码结构下，有两个测试的验证功能是相同的，而它们的测试范围却不同。<br>此时该选择哪一种？<br>A:<br>选择范围更小的测试，粒度更小能够更快速的定位问题。","like_count":0},{"had_liked":false,"id":339954,"user_name":"Gojustforfun","can_delete":false,"product_type":"c1","uid":1187021,"ip_address":"","ucode":"7513A40F27344F","user_header":"https://static001.geekbang.org/account/avatar/00/12/1c/cd/8d552516.jpg","comment_is_top":false,"comment_ctime":1648484225,"is_pvip":true,"replies":[{"id":"124275","content":"good","user_name":"作者回复","user_name_real":"编辑","uid":"2537798","ctime":1648513614,"ip_address":"","comment_id":339954,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1648484225","product_id":100109401,"comment_content":"Go演示git提交记录:<br>https:&#47;&#47;github.com&#47;longyue0521&#47;TDD-In-Go&#47;commits&#47;args<br><br>Commits on Mar 28, 2022 ~ Commits on Mar 26, 2022之间的内容与本篇文章对应.<br><br>采用baby step每步都有提交记录可以对比学习.<br><br>如果觉得本项目对你有帮助,欢迎留言、star","like_count":1,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558861,"discussion_content":"good","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648513614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}