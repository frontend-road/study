{"id":41802,"title":"11 | 排序（上）：为什么插入排序比冒泡排序更受欢迎？","content":"<p>排序对于任何一个程序员来说，可能都不会陌生。你学的第一个算法，可能就是排序。大部分编程语言中，也都提供了排序函数。在平常的项目中，我们也经常会用到排序。排序非常重要，所以我会花多一点时间来详细讲一讲经典的排序算法。</p><p>排序算法太多了，有很多可能你连名字都没听说过，比如猴子排序、睡眠排序、面条排序等。我只讲众多排序算法中的一小撮，也是最经典的、最常用的：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。我按照时间复杂度把它们分成了三类，分三节课来讲解。</p><p><img src=\"https://static001.geekbang.org/resource/image/fb/cd/fb8394a588b12ff6695cfd664afb17cd.jpg?wh=1142*704\" alt=\"\"></p><p>带着问题去学习，是最有效的学习方法。所以按照惯例，我还是先给你出一个思考题：<strong><span class=\"orange\">插入排序和冒泡排序的时间复杂度相同，都是O(n<sup>2</sup>)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？</span></strong></p><p>你可以先思考一两分钟，带着这个问题，我们开始今天的内容！</p><h2>如何分析一个“排序算法”？</h2><p>学习排序算法，我们除了学习它的算法原理、代码实现之外，更重要的是要学会如何评价、分析一个排序算法。那分析一个排序算法，要从哪几个方面入手呢？</p><h3><span class=\"orange\">排序算法的执行效率</span></h3><p>对于排序算法执行效率的分析，我们一般会从这几个方面来衡量：</p><p><strong>1.最好情况、最坏情况、平均<strong><strong>情况</strong></strong>时间复杂度</strong></p><!-- [[[read_end]]] --><p>我们在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。除此之外，你还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。</p><p>为什么要区分这三种时间复杂度呢？第一，有些排序算法会区分，为了好对比，所以我们最好都做一下区分。第二，对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。</p><p><strong>2.时间复杂度的系数、常数 、低阶</strong></p><p>我们知道，时间复杂度反映的是数据规模n很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但是实际的软件开发中，我们排序的可能是10个、100个、1000个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。</p><p><strong>3.比较次数和交换（或移动）次数</strong></p><p>这一节和下一节讲的都是基于比较的排序算法。基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。</p><h3><span class=\"orange\">排序算法的内存消耗</span></h3><p>我们前面讲过，算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，我们还引入了一个新的概念，<strong>原地排序</strong>（Sorted in place）。原地排序算法，就是特指空间复杂度是O(1)的排序算法。我们今天讲的三种排序算法，都是原地排序算法。</p><h3><span class=\"orange\">排序算法的稳定性</span></h3><p>仅仅用执行效率和内存消耗来衡量排序算法的好坏是不够的。针对排序算法，我们还有一个重要的度量指标，<strong>稳定性</strong>。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p><p>我通过一个例子来解释一下。比如我们有一组数据2，9，3，4，8，3，按照大小排序之后就是2，3，3，4，8，9。</p><p>这组数据里有两个3。经过某种排序算法排序之后，如果两个3的前后顺序没有改变，那我们就把这种排序算法叫作<strong>稳定的排序算法</strong>；如果前后顺序发生变化，那对应的排序算法就叫作<strong>不稳定的排序算法</strong>。</p><p>你可能要问了，两个3哪个在前，哪个在后有什么关系啊，稳不稳定又有什么关系呢？为什么要考察排序算法的稳定性呢？</p><p>很多数据结构和算法课程，在讲排序的时候，都是用整数来举例，但在真正软件开发中，我们要排序的往往不是单纯的整数，而是一组对象，我们需要按照对象的某个key来排序。</p><p>比如说，我们现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果我们现在有10万条订单数据，我们希望按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照下单时间从早到晚有序。对于这样一个排序需求，我们怎么来做呢？</p><p>最先想到的方法是：我们先按照金额对订单数据进行排序，然后，再遍历排序之后的订单数据，对于每个金额相同的小区间再按照下单时间排序。这种排序思路理解起来不难，但是实现起来会很复杂。</p><p>借助稳定排序算法，这个问题可以非常简洁地解决。解决思路是这样的：我们先按照下单时间给订单排序，注意是按照下单时间，不是金额。排序完成之后，我们用稳定排序算法，按照订单金额重新排序。两遍排序之后，我们得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。为什么呢？</p><p><strong>稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变</strong>。第一次排序之后，所有的订单按照下单时间从早到晚有序了。在第二次排序中，我们用的是稳定的排序算法，所以经过第二次排序之后，相同金额的订单仍然保持下单时间从早到晚有序。</p><p><img src=\"https://static001.geekbang.org/resource/image/13/59/1381c1f3f7819ae61ab17455ed7f0b59.jpg?wh=1142*765\" alt=\"\"></p><h2>冒泡排序（Bubble Sort）</h2><p>我们从冒泡排序开始，学习今天的三种排序算法。</p><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作。</p><p>我用一个例子，带你看下冒泡排序的整个过程。我们要对一组数据4，5，6，3，2，1，从小到大进行排序。第一次冒泡操作的详细过程就是这样：</p><p><img src=\"https://static001.geekbang.org/resource/image/40/e9/4038f64f47975ab9f519e4f739e464e9.jpg?wh=1142*741\" alt=\"\"></p><p>可以看出，经过一次冒泡操作之后，6这个元素已经存储在正确的位置上。要想完成所有数据的排序，我们只要进行6次这样的冒泡操作就行了。</p><p><img src=\"https://static001.geekbang.org/resource/image/92/09/9246f12cca22e5d872cbfce302ef4d09.jpg?wh=1142*749\" alt=\"\"></p><p>实际上，刚讲的冒泡过程还可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。我这里还有另外一个例子，这里面给6个元素排序，只需要4次冒泡操作就可以了。</p><p><img src=\"https://static001.geekbang.org/resource/image/a9/e6/a9783a3b13c11a5e064c5306c261e8e6.jpg?wh=1142*679\" alt=\"\"></p><p>冒泡排序算法的原理比较容易理解，具体的代码我贴到下面，你可以结合着代码来看我前面讲的原理。</p><pre><code>// 冒泡排序，a表示数组，n表示数组大小\npublic void bubbleSort(int[] a, int n) {\n  if (n &lt;= 1) return;\n \n for (int i = 0; i &lt; n; ++i) {\n    // 提前退出冒泡循环的标志位\n    boolean flag = false;\n    for (int j = 0; j &lt; n - i - 1; ++j) {\n      if (a[j] &gt; a[j+1]) { // 交换\n        int tmp = a[j];\n        a[j] = a[j+1];\n        a[j+1] = tmp;\n        flag = true;  // 表示有数据交换      \n      }\n    }\n    if (!flag) break;  // 没有数据交换，提前退出\n  }\n}\n</code></pre><p>现在，结合刚才我分析排序算法的三个方面，我有三个问题要问你。</p><p><strong>第一，冒泡排序是原地排序算法吗？</strong></p><p>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为O(1)，是一个原地排序算法。</p><p><strong>第二，冒泡排序是稳定的排序算法吗？</strong></p><p>在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。</p><p><strong>第三，冒泡排序<strong><strong>的时间复杂度</strong></strong>是多少？</strong></p><p>最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是O(n)。而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行n次冒泡操作，所以最坏情况时间复杂度为O(n<sup>2</sup>)。</p><p><img src=\"https://static001.geekbang.org/resource/image/fe/0f/fe107c06da8b290fb78fcce4f6774c0f.jpg?wh=1142*299\" alt=\"\"></p><p>最好、最坏情况下的时间复杂度很容易分析，那平均情况下的时间复杂是多少呢？我们前面讲过，平均时间复杂度就是加权平均期望时间复杂度，分析的时候要结合概率论的知识。</p><p>对于包含n个数据的数组，这n个数据就有n!种排列方式。不同的排列方式，冒泡排序执行的时间肯定是不同的。比如我们前面举的那两个例子，其中一个要进行6次冒泡，而另一个只需要4次。如果用概率论方法定量分析平均时间复杂度，涉及的数学推理和计算就会很复杂。我这里还有一种思路，通过“<strong>有序度</strong>”和“<strong>逆序度</strong>”这两个概念来进行分析。</p><p><strong>有序度</strong>是数组中具有有序关系的元素对的个数。有序元素对用数学表达式表示就是这样：</p><pre><code>有序元素对：a[i] &lt;= a[j], 如果i &lt; j。\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/a1/20/a1ef4cc1999d6bd0af08d8417ee55220.jpg?wh=1142*545\" alt=\"\"></p><p>同理，对于一个倒序排列的数组，比如6，5，4，3，2，1，有序度是0；对于一个完全有序的数组，比如1，2，3，4，5，6，有序度就是<strong>n*(n-1)/2</strong>，也就是15。我们把这种完全有序的数组的有序度叫作<strong>满有序度</strong>。</p><p>逆序度的定义正好跟有序度相反（默认从小到大为有序），我想你应该已经想到了。关于逆序度，我就不举例子讲了。你可以对照我讲的有序度的例子自己看下。</p><pre><code>逆序元素对：a[i] &gt; a[j], 如果i &lt; j。\n</code></pre><p>关于这三个概念，我们还可以得到一个公式：<strong>逆序度=满有序度-有序度</strong>。我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。</p><p>我还是拿前面举的那个冒泡排序的例子来说明。要排序的数组的初始状态是4，5，6，3，2，1 ，其中，有序元素对有(4，5) (4，6)(5，6)，所以有序度是3。n=6，所以排序完成之后终态的满有序度为n*(n-1)/2=15。</p><p><img src=\"https://static001.geekbang.org/resource/image/88/34/8890cbf63ea80455ce82490a23361134.jpg?wh=1142*737\" alt=\"\"></p><p>冒泡排序包含两个操作原子，<strong>比较</strong>和<strong>交换</strong>。每交换一次，有序度就加1。不管算法怎么改进，交换次数总是确定的，即为<strong>逆序度，<strong>也就是</strong>n*(n-1)/2–初始有序度</strong>。此例中就是15–3=12，要进行12次交换操作。</p><p>对于包含n个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏情况下，初始状态的有序度是0，所以要进行n*(n-1)/2次交换。最好情况下，初始状态的有序度是n*(n-1)/2，就不需要进行交换。我们可以取个中间值n*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。</p><p>换句话说，平均情况下，需要n*(n-1)/4次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是O(n<sup>2</sup>)，所以平均情况下的时间复杂度就是O(n<sup>2</sup>)。</p><p>这个平均时间复杂度推导过程其实并不严格，但是很多时候很实用，毕竟概率论的定量分析太复杂，不太好用。等我们讲到快排的时候，我还会再次用这种“不严格”的方法来分析平均时间复杂度。</p><h2>插入排序（Insertion Sort）</h2><p>我们先来看一个问题。一个有序的数组，我们往里面添加一个新的数据后，如何继续保持数据有序呢？很简单，我们只要遍历数组，找到数据应该插入的位置将其插入即可。</p><p><img src=\"https://static001.geekbang.org/resource/image/7b/a6/7b257e179787c633d2bd171a764171a6.jpg?wh=1142*699\" alt=\"\"></p><p>这是一个动态排序的过程，即动态地往有序集合中添加数据，我们可以通过这种方法保持集合中的数据一直有序。而对于一组静态数据，我们也可以借鉴上面讲的插入方法，来进行排序，于是就有了插入排序算法。</p><p>那<strong>插入排序具体是如何借助上面的思想来实现排序的呢</strong>？</p><p>首先，我们将数组中的数据分为两个区间，<strong>已排序区间</strong>和<strong>未排序区间</strong>。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。</p><p>如图所示，要排序的数据是4，5，6，1，3，2，其中左侧为已排序区间，右侧是未排序区间。</p><p><img src=\"https://static001.geekbang.org/resource/image/b6/e1/b60f61ec487358ac037bf2b6974d2de1.jpg?wh=1142*699\" alt=\"\"></p><p>插入排序也包含两种操作，一种是<strong>元素的比较</strong>，一种是<strong>元素<strong><strong>的</strong></strong>移动</strong>。当我们需要将一个数据a插入到已排序区间时，需要拿a与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素a插入。</p><p>对于不同的查找插入点方法（从头到尾、从尾到头），元素的比较次数是有区别的。但对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度。</p><p>为什么说移动次数就等于逆序度呢？我拿刚才的例子画了一个图表，你一看就明白了。满有序度是n*(n-1)/2=15，初始序列的有序度是5，所以逆序度是10。插入排序中，数据移动的个数总和也等于10=3+3+4。</p><p><img src=\"https://static001.geekbang.org/resource/image/fd/01/fd6582d5e5927173ee35d7cc74d9c401.jpg?wh=1142*744\" alt=\"\"></p><p>插入排序的原理也很简单吧？我也将代码实现贴在这里，你可以结合着代码再看下。</p><pre><code>// 插入排序，a表示数组，n表示数组大小\npublic void insertionSort(int[] a, int n) {\n  if (n &lt;= 1) return;\n\n  for (int i = 1; i &lt; n; ++i) {\n    int value = a[i];\n    int j = i - 1;\n    // 查找插入的位置\n    for (; j &gt;= 0; --j) {\n      if (a[j] &gt; value) {\n        a[j+1] = a[j];  // 数据移动\n      } else {\n        break;\n      }\n    }\n    a[j+1] = value; // 插入数据\n  }\n}\n</code></pre><p>现在，我们来看点稍微复杂的东西。我这里还是有三个问题要问你。</p><p><strong>第一，插入排序是原地排序算法吗？</strong></p><p>从实现过程可以很明显地看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是O(1)，也就是说，这是一个原地排序算法。</p><p><strong>第二，插入排序是<strong><strong>稳定</strong></strong>的排序算法吗？</strong></p><p>在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。</p><p><strong>第三，插入排序<strong><strong>的时间复杂度</strong></strong>是多少？</strong></p><p>如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为O(n)。注意，这里是<strong>从尾到头遍历已经有序的数据</strong>。</p><p>如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为O(n<sup>2</sup>)。</p><p>还记得我们在数组中插入一个数据的平均时间复杂度是多少吗？没错，是O(n)。所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行n次插入操作，所以平均时间复杂度为O(n<sup>2</sup>)。</p><h2>选择排序（Selection Sort）</h2><p>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p><p><img src=\"https://static001.geekbang.org/resource/image/32/1d/32371475a0b08f0db9861d102474181d.jpg?wh=1142*856\" alt=\"\"></p><p>照例，也有三个问题需要你思考，不过前面两种排序算法我已经分析得很详细了，这里就直接公布答案了。</p><p>首先，选择排序空间复杂度为O(1)，是一种原地排序算法。选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为O(n<sup>2</sup>)。你可以自己来分析看看。</p><p>那选择排序是稳定的排序算法吗？这个问题我着重来说一下。</p><p>答案是否定的，选择排序是一种不稳定的排序算法。从我前面画的那张图中，你可以看出来，选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。</p><p>比如5，8，5，2，9这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素2，与第一个5交换位置，那第一个5和中间的5顺序就变了，所以就不稳定了。正是因此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。</p><h2>解答开篇</h2><p>基本的知识都讲完了，我们来看开篇的问题：冒泡排序和插入排序的时间复杂度都是O(n<sup>2</sup>)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？</p><p>我们前面分析冒泡排序和插入排序的时候讲到，冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。</p><p>但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要3个赋值操作，而插入排序只需要1个。我们来看这段操作：</p><pre><code>冒泡排序中数据的交换操作：\nif (a[j] &gt; a[j+1]) { // 交换\n   int tmp = a[j];\n   a[j] = a[j+1];\n   a[j+1] = tmp;\n   flag = true;\n}\n\n插入排序中数据的移动操作：\nif (a[j] &gt; value) {\n  a[j+1] = a[j];  // 数据移动\n} else {\n  break;\n}\n</code></pre><p>我们把执行一个赋值语句的时间粗略地计为单位时间（unit_time），然后分别用冒泡排序和插入排序对同一个逆序度是K的数组进行排序。用冒泡排序，需要K次交换操作，每次需要3个赋值语句，所以交换操作总耗时就是3*K单位时间。而插入排序中数据移动操作只需要K个单位时间。</p><p>这个只是我们非常理论的分析，为了实验，针对上面的冒泡排序和插入排序的Java代码，我写了一个性能对比测试程序，随机生成10000个数组，每个数组中包含200个数据，然后在我的机器上分别用冒泡和插入排序算法来排序，冒泡排序算法大约700ms才能执行完成，而插入排序只需要100ms左右就能搞定！</p><p>所以，虽然冒泡排序和插入排序在时间复杂度上是一样的，都是O(n<sup>2</sup>)，但是如果我们希望把性能优化做到极致，那肯定首选插入排序。插入排序的算法思路也有很大的优化空间，我们只是讲了最基础的一种。如果你对插入排序的优化感兴趣，可以自行学习一下<a href=\"https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F\">希尔排序</a>。</p><h2>内容小结</h2><p>要想分析、评价一个排序算法，需要从执行效率、内存消耗和稳定性三个方面来看。因此，这一节，我带你分析了三种时间复杂度是O(n<sup>2</sup>)的排序算法，冒泡排序、插入排序、选择排序。你需要重点掌握的是它们的分析方法。</p><p><img src=\"https://static001.geekbang.org/resource/image/34/50/348604caaf0a1b1d7fee0512822f0e50.jpg?wh=1142*584\" alt=\"\"></p><p>这三种时间复杂度为O(n<sup>2</sup>)的排序算法中，冒泡排序、选择排序，可能就纯粹停留在理论的层面了，学习的目的也只是为了开拓思维，实际开发中应用并不多，但是插入排序还是挺有用的。后面讲排序优化的时候，我会讲到，有些编程语言中的排序函数的实现原理会用到插入排序算法。</p><p>今天讲的这三种排序算法，实现代码都非常简单，对于小规模数据的排序，用起来非常高效。但是在大规模数据排序的时候，这个时间复杂度还是稍微有点高，所以我们更倾向于用下一节要讲的时间复杂度为O(nlogn)的排序算法。</p><h2>课后思考</h2><p>我们讲过，特定算法是依赖特定的数据结构的。我们今天讲的几种排序算法，都是基于数组实现的。如果数据存储在链表中，这三种排序算法还能工作吗？如果能，那相应的时间、空间复杂度又是多少呢？</p><p>欢迎留言和我分享，我会第一时间给你反馈。</p><hr><p><span class=\"orange\">我已将本节内容相关的详细代码更新到GitHub，<a href=\"https://github.com/wangzheng0822/algo\">戳此</a>即可查看。</span></p>","neighbors":{"left":{"article_title":"10 |  递归：如何用三行代码找到“最终推荐人”？","id":41440},"right":{"article_title":"12 | 排序（下）：如何用快排思想在O(n)内查找第K大元素？","id":41913}},"comments":[{"had_liked":true,"id":32483,"user_name":"双木公子","can_delete":false,"product_type":"c1","uid":1116567,"ip_address":"","ucode":"751885864D3AB7","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/97/4314e2d8.jpg","comment_is_top":true,"comment_ctime":1539588251,"is_pvip":false,"replies":[{"id":"11872","content":"👍 回答的很好 可以作为标准答案了 同学们把这条顶上去吧","user_name":"作者回复","comment_id":32483,"uid":"1190123","ip_address":"","utype":1,"ctime":1539614488,"user_name_real":"gg"}],"discussion_count":44,"race_medal":0,"score":"9.2233797865154007e+18","product_id":100017301,"comment_content":"对于老师所提课后题，觉得应该有个前提，是否允许修改链表的节点value值，还是只能改变节点的位置。一般而言，考虑只能改变节点位置，冒泡排序相比于数组实现，比较次数一致，但交换时操作更复杂；插入排序，比较次数一致，不需要再有后移操作，找到位置后可以直接插入，但排序完毕后可能需要倒置链表；选择排序比较次数一致，交换操作同样比较麻烦。综上，时间复杂度和空间复杂度并无明显变化，若追求极致性能，冒泡排序的时间复杂度系数会变大，插入排序系数会减小，选择排序无明显变化。","like_count":1805,"discussions":[{"author":{"id":2052521,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/51/a9/741b5ad9.jpg","nickname":"FD","note":"","ucode":"ED396BD322489E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290082,"discussion_content":"插入排序不需要逆置链表。可以根据情况选择头插还是尾插，或者固定好插入部位，选择比当前大的插还是小的插","likes_number":16,"is_delete":false,"is_hidden":false,"ctime":1594341320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2052521,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/51/a9/741b5ad9.jpg","nickname":"FD","note":"","ucode":"ED396BD322489E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379606,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624009396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":290082,"ip_address":""},"score":379606,"extra":""}]},{"author":{"id":1373893,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f6/c5/6329ddcc.jpg","nickname":"阿冰777","note":"","ucode":"F365EB44F971F3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69564,"discussion_content":"插入排序为什么要倒置链表？没明白","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1575293515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2216696,"avatar":"https://static001.geekbang.org/account/avatar/00/21/d2/f8/bb75ce47.jpg","nickname":"Conscious","note":"","ucode":"9863284FD5D18E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":315978,"discussion_content":"老师的那段插入排序的代码是从后向前 也就是从大到小 找插入位置的  \n如果单链表是从大到小排列  即 从大到小 找插入位置  最后是需要倒置的\n如果单链表是从小到大排列  那么插入后  不需要倒置","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1603342332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1657999,"avatar":"https://static001.geekbang.org/account/avatar/00/19/4c/8f/83eefcff.jpg","nickname":"厚积薄发","note":"","ucode":"6FE711F65C8C66","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21943,"discussion_content":"如果值交换，那链表和数组形式差异不大，如果是结点交换，选择排序比较麻烦","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1569554927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1529060,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLcKGqKcJNW6yLbqOwutsMJH67usyOlHyCX2pSgTQbQS4jndGbvbBsCVqM8n5Un1iasWouqMjUKL0Q/132","nickname":"Hanan","note":"","ucode":"A2DE97818F5E02","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":169,"discussion_content":"请问为什么链表的插入排序最后需要反转链表，整个过程可以再详细一点吗？","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1561213062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":11,"child_discussions":[{"author":{"id":1031734,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/be/36/abb7bfe3.jpg","nickname":"xenoblade3","note":"","ucode":"620DD0491EEFF3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1529060,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLcKGqKcJNW6yLbqOwutsMJH67usyOlHyCX2pSgTQbQS4jndGbvbBsCVqM8n5Un1iasWouqMjUKL0Q/132","nickname":"Hanan","note":"","ucode":"A2DE97818F5E02","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504,"discussion_content":"因为是从尾到头进行插入比较，我猜可能是指使用head指针来保存已经排序的尾节点，插入完成后再对head进行倒序。如果用了额外的一个指针变量保存排序的尾指针，head保持更新，插入完成后应该就不需要倒序了吧。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1561623364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":169,"ip_address":""},"score":504,"extra":""},{"author":{"id":1071941,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5b/45/5dc5437e.jpg","nickname":"Joiner","note":"","ucode":"7F67D4C325E71F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1031734,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/be/36/abb7bfe3.jpg","nickname":"xenoblade3","note":"","ucode":"620DD0491EEFF3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5698,"discussion_content":"单向链表，如果head指针保存尾节点，那插入排序进行不下去吧，我理解的是单向链表应该从头开始比较，如果从尾开始比较，那每次往前一个节点都会很麻烦，而且就算这样，还是需要知道链表头在哪","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1566440769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":504,"ip_address":""},"score":5698,"extra":""},{"author":{"id":1258401,"avatar":"https://static001.geekbang.org/account/avatar/00/13/33/a1/f3835f01.jpg","nickname":"社会猪","note":"","ucode":"CFF5EA7F247373","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1071941,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5b/45/5dc5437e.jpg","nickname":"Joiner","note":"","ucode":"7F67D4C325E71F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":14562,"discussion_content":"是多少","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568771253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5698,"ip_address":""},"score":14562,"extra":""}]},{"author":{"id":1239137,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e8/61/8e8147a2.jpg","nickname":"嘿哈","note":"","ucode":"0AB6F70AE4D63A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":249372,"discussion_content":"没明白为啥插入排序完成后需要倒置链表，排序遍历直接从链表头开始遍历，并且可以直接插入，感觉不需要倒置链表吧","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1587916421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":1734656,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/78/00/675a5795.jpg","nickname":"小龙成Hu","note":"","ucode":"6AFCED06795C91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1239137,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e8/61/8e8147a2.jpg","nickname":"嘿哈","note":"","ucode":"0AB6F70AE4D63A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":272998,"discussion_content":"你跟他讲的是两种思路，数组实现也可以  从已排序区间 头遍历 也可以从尾部遍历比较","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1590389101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":249372,"ip_address":""},"score":272998,"extra":""},{"author":{"id":1114093,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ff/ed/b2fc0e7c.jpg","nickname":"7","note":"","ucode":"10A6E57A027D42","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1239137,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e8/61/8e8147a2.jpg","nickname":"嘿哈","note":"","ucode":"0AB6F70AE4D63A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279001,"discussion_content":"你单链表怎么插入呢？\n这个插入虽然单链表也可以实现，但时间复杂度很高。\n只有双向链表才可以实现插入","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591271127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":249372,"ip_address":""},"score":279001,"extra":""},{"author":{"id":1347919,"avatar":"https://static001.geekbang.org/account/avatar/00/14/91/4f/b359e3f3.jpg","nickname":"渔父歌","note":"","ucode":"4F7F6928DB6843","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1114093,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ff/ed/b2fc0e7c.jpg","nickname":"7","note":"","ucode":"10A6E57A027D42","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296039,"discussion_content":"单链表为什么插入时间复杂度会变高呢，如果用一个指针指向未排序和排序的分界节点，用另一个指针指向头节点，每次将分界节点后面的节点取出到前面进行插，这样应该排序完成之后就有序的，不太明白为什么要倒置链表。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596436911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":279001,"ip_address":""},"score":296039,"extra":""}]},{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426789,"discussion_content":"👍 回答的很好 可以作为标准答案了 同学们把这条顶上去吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1539614488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2596620,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/9bWBm2fZiaJswN8Yg0w79KGtaFNhba2Hvib5G46lN8Ql9Sps25NibJG4qHiayh6pqQONDpMKtWegBMXZEibY5rS47tw/132","nickname":"Geek_94eb13","note":"","ucode":"5BDFF8F86CD2C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374665,"discussion_content":"个人认为单链表实现插入排序应该有两种方式，第一种，从头节点开始，然后每一轮都是从指定节点开始倒序比较，由于单链表结构比较特殊，想获取上一个节点只能从头顺序遍历比较进行定位，时间复杂度系数变高，第二种，从头节点开始，然后每一轮只进行顺序遍历比较交换位置（也就是每一轮从指定节点开始继续往下进行比较，小的往尾部方向移动，大的往头方向移动），最后形成一条倒序链表。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621306584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2849207,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/p7WrTfywicxkRZTdlSEvzTsrWssRF0YnmGY2ffFYGKjIoNC8fnbMiaI9Kic0gOD3icLiapY5vmYh89yLUH7qgZZicn3g/132","nickname":"Geek_8b8904","note":"","ucode":"3A7967582FFE8D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532845,"discussion_content":"我觉得没必要倒置链表，无非就是升序降序逻辑可能是反的，那么在排序的时候判断条件反转不就不用倒置了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637718561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2269984,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/1sWUKJBuJdvOPCbp0FAwy43bxOSZ4pUazvv3icb4bcpm2Of8gFluJhyhVuIkIv3eSiaico8umibUrloz9POiapCV3Tw/132","nickname":"Geek_edffd3","note":"","ucode":"F61990464F2282","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385435,"discussion_content":"交换节点位置的意义在哪儿？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627037764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2625677,"avatar":"https://static001.geekbang.org/account/avatar/00/28/10/8d/abf02c56.jpg","nickname":"王兴","note":"","ucode":"3EF1AC47EE7C78","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2269984,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/1sWUKJBuJdvOPCbp0FAwy43bxOSZ4pUazvv3icb4bcpm2Of8gFluJhyhVuIkIv3eSiaico8umibUrloz9POiapCV3Tw/132","nickname":"Geek_edffd3","note":"","ucode":"F61990464F2282","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385454,"discussion_content":"我感觉只是实现的条件限制，相比较来说交换值更容易","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627048994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":385435,"ip_address":""},"score":385454,"extra":""}]},{"author":{"id":2269984,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/1sWUKJBuJdvOPCbp0FAwy43bxOSZ4pUazvv3icb4bcpm2Of8gFluJhyhVuIkIv3eSiaico8umibUrloz9POiapCV3Tw/132","nickname":"Geek_edffd3","note":"","ucode":"F61990464F2282","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385434,"discussion_content":"交换值和交换节点位置有啥区别？为什么会交换节点位置是啥意思？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627037732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1902750,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/wiaQmkQdIh84RibSLrDkIA3POPhxYU2kjRFvVeLynfm3JjzKc5VEOUpbGT0QxYzKoR6V0mmcLxdqKibqy8hiasUZ4g/132","nickname":"谷氨酸钠","note":"","ucode":"DA4F1A48FB0CDD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379530,"discussion_content":"对于单链表的选择排序，可以不用交换操作。将从未排序区间查找到的最小节点直接插入到已排序区间的尾部，然后在未排序区间直接删除这个最小节点，这样对吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623940670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2464909,"avatar":"https://static001.geekbang.org/account/avatar/00/25/9c/8d/07514b58.jpg","nickname":"旺旺","note":"","ucode":"C731B734562C5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1902750,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/wiaQmkQdIh84RibSLrDkIA3POPhxYU2kjRFvVeLynfm3JjzKc5VEOUpbGT0QxYzKoR6V0mmcLxdqKibqy8hiasUZ4g/132","nickname":"谷氨酸钠","note":"","ucode":"DA4F1A48FB0CDD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380951,"discussion_content":"我感觉是直接修改其指针，不用进行删除操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624837527,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":379530,"ip_address":""},"score":380951,"extra":""},{"author":{"id":2223791,"avatar":"https://static001.geekbang.org/account/avatar/00/21/ee/af/bb84441d.jpg","nickname":"旗袍不开、怎么得胜？","note":"","ucode":"27351FE057C9A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1902750,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/wiaQmkQdIh84RibSLrDkIA3POPhxYU2kjRFvVeLynfm3JjzKc5VEOUpbGT0QxYzKoR6V0mmcLxdqKibqy8hiasUZ4g/132","nickname":"谷氨酸钠","note":"","ucode":"DA4F1A48FB0CDD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392802,"discussion_content":"理论上没问题，反正也不稳定，就破罐子破摔了。不过这样还要单独保存一个尾节点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631146346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":379530,"ip_address":""},"score":392802,"extra":""}]},{"author":{"id":1789481,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/4e/29/adcb78e7.jpg","nickname":"静心","note":"","ucode":"B80DE4B5C923D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379268,"discussion_content":"插入排序没必要插入后倒置链表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623803748,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2145095,"avatar":"https://static001.geekbang.org/account/avatar/00/20/bb/47/b60ae3eb.jpg","nickname":"你好，阳光","note":"","ucode":"1A2F487C57F7D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376869,"discussion_content":"我觉得冒泡排序链表实现的交换操作相比于数组实现的复杂度差不多，数组实现需要交换两个变量（3次赋值），链表实现需要改变待交换的相邻两个节点（a,b）的附近的三个指针指向（即把a的前驱节点的next指针指向b的next，把a的next指针指向b的next，再把b的next指向a）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622386997,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1521507,"avatar":"https://static001.geekbang.org/account/avatar/00/17/37/63/77d14f7e.jpg","nickname":"现在姓周二十年后是老周","note":"","ucode":"D497AB36E2D93A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2145095,"avatar":"https://static001.geekbang.org/account/avatar/00/20/bb/47/b60ae3eb.jpg","nickname":"你好，阳光","note":"","ucode":"1A2F487C57F7D9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381401,"discussion_content":"a的前驱节点的next指针指向b的next？是不是应该指向b呢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625040600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":376869,"ip_address":""},"score":381401,"extra":""}]},{"author":{"id":2090232,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/e4/f8/80374742.jpg","nickname":"锅侠","note":"","ucode":"2F7856BEF55301","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333871,"discussion_content":"没看明白","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607656860,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1325309,"avatar":"https://static001.geekbang.org/account/avatar/00/14/38/fd/14b6f0cf.jpg","nickname":"叫我小小诗","note":"","ucode":"535A328D57838B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":243178,"discussion_content":"为什么冒泡排序的时间复杂度系数会变大，插入排序系数会减小？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587527026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1375256,"avatar":"https://static001.geekbang.org/account/avatar/00/14/fc/18/8e69f7cf.jpg","nickname":"TANMIYOO","note":"","ucode":"BC3556131D4D61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1325309,"avatar":"https://static001.geekbang.org/account/avatar/00/14/38/fd/14b6f0cf.jpg","nickname":"叫我小小诗","note":"","ucode":"535A328D57838B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283564,"discussion_content":"个人愚见:冒泡排序在于交换,若是单向链表,必然要拿到这两个连续节点的上一个节点的引用,取上一节点的引用的这步操作增加了时间复杂度","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1592297924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":243178,"ip_address":""},"score":283564,"extra":""},{"author":{"id":2166610,"avatar":"","nickname":"Geek_a282b1","note":"","ucode":"C62700D6C88A4D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1325309,"avatar":"https://static001.geekbang.org/account/avatar/00/14/38/fd/14b6f0cf.jpg","nickname":"叫我小小诗","note":"","ucode":"535A328D57838B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341570,"discussion_content":"冒泡必须要交换相邻元素，相比数组，链表交换两个相邻结点的成本更高；\n对于数组，如果元素应该插入的位置是 k，那么 k 及之后的元素都要向后移动一位，而对于链表就不用移动结点，只需要把结点删除再插入即可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610454616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":243178,"ip_address":""},"score":341570,"extra":""}]},{"author":{"id":1258401,"avatar":"https://static001.geekbang.org/account/avatar/00/13/33/a1/f3835f01.jpg","nickname":"社会猪","note":"","ucode":"CFF5EA7F247373","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":17054,"discussion_content":"111","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568944565,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1235154,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d8/d2/8bc05ccf.jpg","nickname":"Charley Choi 🎃","note":"","ucode":"E43371C6B2BBDA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":227,"discussion_content":"选择排序使用链表实现，时间复杂度系统由于交换操作应该变大才对，怎会无明显变化？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561343126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1258401,"avatar":"https://static001.geekbang.org/account/avatar/00/13/33/a1/f3835f01.jpg","nickname":"社会猪","note":"","ucode":"CFF5EA7F247373","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1235154,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d8/d2/8bc05ccf.jpg","nickname":"Charley Choi 🎃","note":"","ucode":"E43371C6B2BBDA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":14609,"discussion_content":"aaa","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568772862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":227,"ip_address":""},"score":14609,"extra":""},{"author":{"id":1244968,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ff/28/cd96cdb6.jpg","nickname":"sprittee","note":"","ucode":"61AE0314960944","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1235154,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d8/d2/8bc05ccf.jpg","nickname":"Charley Choi 🎃","note":"","ucode":"E43371C6B2BBDA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56238,"discussion_content":"链表的交换操作也是常数级别的跟数组一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574445471,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":227,"ip_address":""},"score":56238,"extra":""}]}]},{"had_liked":false,"id":32850,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1539703089,"is_pvip":false,"discussion_count":11,"race_medal":0,"score":"1732411523377","product_id":100017301,"comment_content":"本节从昨天更新到今天，一共前前后后认认真真听了五遍，再到今天晚上花3小时把3个排序算法实现，做了冒泡排序与插入排序的测试实验。随机生成二维数组a[200][10000]和b[200][10000]（a,b数组数据一致），然后在我的机器上分别用冒泡和插入排序算法来排序（a数组冒泡，b数组插入），冒泡排序算法大约 16332ms 才能执行完成，而插入排序只需要 2228ms 左右。<br>总结一句：听五遍不如敲一遍！","like_count":403,"discussions":[{"author":{"id":1088710,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/c6/05a6798f.jpg","nickname":"苗","note":"","ucode":"5ECCC6C855E541","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":32628,"discussion_content":"敲也要敲5遍","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1571053551,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2344273,"avatar":"","nickname":"Geek_db37b3","note":"","ucode":"A9F61199FB3D92","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331309,"discussion_content":"我觉得 冒泡排序比起插入排序还有一点不足的是 它比较的次数会更多","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1606826569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1221604,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a3/e4/50266292.jpg","nickname":"库博","note":"","ucode":"0D5DD558C9EB25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2344273,"avatar":"","nickname":"Geek_db37b3","note":"","ucode":"A9F61199FB3D92","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389191,"discussion_content":"并没有，如果不考虑提前结束的情况，比较次数是相当的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629169507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":331309,"ip_address":""},"score":389191,"extra":""}]},{"author":{"id":1351894,"avatar":"https://static001.geekbang.org/account/avatar/00/14/a0/d6/c45137e6.jpg","nickname":"芥末的味道","note":"","ucode":"9CC7E8CF00DF64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356434,"discussion_content":"干嘛要听呢 看文字不香吗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1615599156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1250907,"avatar":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","nickname":"Monday","note":"","ucode":"77B9BACC783598","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1351894,"avatar":"https://static001.geekbang.org/account/avatar/00/14/a0/d6/c45137e6.jpg","nickname":"芥末的味道","note":"","ucode":"9CC7E8CF00DF64","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356478,"discussion_content":"在路上，眼要看路\n挤地铁，没多空间","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1615605721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":356434,"ip_address":""},"score":356478,"extra":""}]},{"author":{"id":1004953,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/55/99/4bdadfd3.jpg","nickname":"Chloe","note":"","ucode":"C4848ED5B35752","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":233304,"discussion_content":"为什么要用二维数组？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586916628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1195438,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3d/ae/daa07f0c.jpg","nickname":"无痕","note":"","ucode":"AE8546EEA7FD00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1004953,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/55/99/4bdadfd3.jpg","nickname":"Chloe","note":"","ucode":"C4848ED5B35752","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344431,"discussion_content":"同问，二维数据应该还是每个单维度在排序吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611461795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":233304,"ip_address":""},"score":344431,"extra":""}]},{"author":{"id":2344287,"avatar":"https://static001.geekbang.org/account/avatar/00/23/c5/5f/249ea670.jpg","nickname":"雨一直下","note":"","ucode":"D949F9542DEC35","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334982,"discussion_content":"怎么看运行时间?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608042159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1250907,"avatar":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","nickname":"Monday","note":"","ucode":"77B9BACC783598","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2344287,"avatar":"https://static001.geekbang.org/account/avatar/00/23/c5/5f/249ea670.jpg","nickname":"雨一直下","note":"","ucode":"D949F9542DEC35","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335015,"discussion_content":"开始之前获得当前毫秒数，执行完后，再次执行，两次的差值就是","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1608052126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":334982,"ip_address":""},"score":335015,"extra":""}]},{"author":{"id":1268797,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5c/3d/e8325811.jpg","nickname":"对白","note":"","ucode":"3183E5ADBC794B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294656,"discussion_content":"我试了一下，如果对长度为100的数组进行排序，使用插入排序的运行时间是0.00007s，而使用冒泡排序的运行时间是0.0026s，差距如此之大！！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595950594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1734656,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/78/00/675a5795.jpg","nickname":"小龙成Hu","note":"","ucode":"6AFCED06795C91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1268797,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5c/3d/e8325811.jpg","nickname":"对白","note":"","ucode":"3183E5ADBC794B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329821,"discussion_content":"与机器性能有关","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606464431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":294656,"ip_address":""},"score":329821,"extra":""}]}]},{"had_liked":true,"id":35452,"user_name":"德拉","can_delete":false,"product_type":"c1","uid":1213868,"ip_address":"","ucode":"293C3287EBDBDE","user_header":"https://static001.geekbang.org/account/avatar/00/12/85/ac/3fd7f6b8.jpg","comment_is_top":false,"comment_ctime":1540599608,"is_pvip":false,"discussion_count":29,"race_medal":0,"score":"1311505624888","product_id":100017301,"comment_content":"有同学提到的算法过程动态图，可以看看这个https:&#47;&#47;visualgo.net&#47;","like_count":306,"discussions":[{"author":{"id":1111116,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f4/4c/aac5165c.jpg","nickname":"Ant_D","note":"","ucode":"9C8C8417D0AF09","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375270,"discussion_content":"Mark","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621559953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1926222,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/64/4e/83c61c7f.jpg","nickname":"靓仔","note":"","ucode":"077A290A2DCF42","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581680,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658914985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2962599,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/34/a7/52c4ea60.jpg","nickname":"年少挽滑稽世无双","note":"","ucode":"793DCBDE25A07B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568794,"discussion_content":"666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651228452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1201022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/53/7e/b6829040.jpg","nickname":"SevenMonths","note":"","ucode":"62A9740FBD1FAE","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554951,"discussion_content":"收藏下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646676133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2829938,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/2e/72/6772f172.jpg","nickname":"ᯤ¹º²⁴ᴳ⁺","note":"","ucode":"8EEF0251BAE054","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554195,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646266364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042793,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e9/69/779b48c2.jpg","nickname":"苏忆","note":"","ucode":"B8BE78280CCB99","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548245,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643097567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316470,"avatar":"https://static001.geekbang.org/account/avatar/00/14/16/76/baac2e82.jpg","nickname":"段伟","note":"","ucode":"E34B4C9D2B1291","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534551,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638229274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2260390,"avatar":"https://static001.geekbang.org/account/avatar/00/22/7d/a6/15798bf2.jpg","nickname":"温雅小公子","note":"","ucode":"9EA63E36D7C85C","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532178,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637550907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2538725,"avatar":"https://static001.geekbang.org/account/avatar/00/26/bc/e5/74e94a76.jpg","nickname":"文件傳輸","note":"","ucode":"A2EDB0D1DBB880","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395002,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632185541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2753672,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/WaoJzYaQHicuvl3jUxty2SkbjL551JdfvGNqoiaEI0WqIR4ErKFuXiaOmbmVv0v6SmpCsmK4ZLWHYYtqico9aXZe6w/132","nickname":"Geek_0ac651","note":"","ucode":"D806124CA61EF2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393705,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631553852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379607,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624009770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2330992,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/70/b4734b77.jpg","nickname":"wave","note":"","ucode":"AE8324016213CB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377061,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622473783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2567260,"avatar":"https://static001.geekbang.org/account/avatar/00/27/2c/5c/ecb7768d.jpg","nickname":"丶浅墨","note":"","ucode":"411B57A1F7AB4D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372727,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620444281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1339586,"avatar":"https://static001.geekbang.org/account/avatar/00/14/70/c2/0df5cc71.jpg","nickname":"Melon","note":"","ucode":"8E4A96B3BA0239","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372489,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620354767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1240328,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ed/08/ebaa6e88.jpg","nickname":"一夕秋雨","note":"","ucode":"34903AFA57FA27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363403,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617189025,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1078833,"avatar":"https://static001.geekbang.org/account/avatar/00/10/76/31/c84a9f39.jpg","nickname":"雷健雄","note":"","ucode":"BFCD014B1754F1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":354697,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615337288,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1690595,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/CF1K4m4SgQxuryVPHCvgIF4CWP0ibicW3OpXQWHnkhxudIuzhMAbUXMwzLPCliaKv5kLQ1zfn1DPlISWvJny1eyQA/132","nickname":"Albert","note":"","ucode":"69D15B1F4DA3D1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329112,"discussion_content":"很好，记录一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606313739,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2133091,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLiaP0XkVNlJn30MR3oicYvmg4VEu3riaIS1ibCjBlOc4kdibGvibNv3MTQQh0ypWBbCIvzRT6t5rA7XHpQ/132","nickname":"Geek_7951c9","note":"","ucode":"051338820C3659","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327781,"discussion_content":"马","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605946827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1406863,"avatar":"https://static001.geekbang.org/account/avatar/00/15/77/8f/9022acfb.jpg","nickname":"Black","note":"","ucode":"16CF5F1A3AA1F9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327066,"discussion_content":"cy","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605744479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2187327,"avatar":"https://static001.geekbang.org/account/avatar/00/21/60/3f/44f1ccdd.jpg","nickname":"小雄","note":"","ucode":"2349838C1595BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318500,"discussion_content":"插眼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603766660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1098624,"avatar":"","nickname":"dream7519","note":"","ucode":"55E229FA55E15C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284656,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592577452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1068326,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4d/26/44095eba.jpg","nickname":"贱贱的梦想","note":"","ucode":"A3F7AF23D193AF","race_medal":4,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279775,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591414262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1926508,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/65/6c/be97a3ae.jpg","nickname":"Geek_bb2310","note":"","ucode":"022885B257DEB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260079,"discussion_content":"嗯嗯，经典网站\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588846359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132312,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/18/293cd24d.jpg","nickname":"o0oi1i","note":"","ucode":"D1F6AD4AAEAFBE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":243471,"discussion_content":"感谢分享！！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587543204,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194060,"avatar":"https://static001.geekbang.org/account/avatar/00/12/38/4c/5426e2e0.jpg","nickname":"CJJ","note":"","ucode":"7E02A6A8547559","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":242268,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587473396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1192940,"avatar":"https://static001.geekbang.org/account/avatar/00/12/33/ec/f41da26c.jpg","nickname":"杨剑锋","note":"","ucode":"890BA54B313C2D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":89051,"discussion_content":"感谢分享，非常形象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576747460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1024267,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a1/0b/f009ac0d.jpg","nickname":"liven","note":"","ucode":"E35421271196B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88764,"discussion_content":"这个太好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576730342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1367221,"avatar":"https://static001.geekbang.org/account/avatar/00/14/dc/b5/7fd5f418.jpg","nickname":"Reina","note":"","ucode":"AFF6C03FF07F4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73852,"discussion_content":"赞呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575601982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1642257,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJMW3f6jeDLDVaZODBwJmZOrHRT31bZ0bHLibTRF8xBmfQ6PjfbmqWbw5P92vcEFMAoYSkV4Vt1iarg/132","nickname":"luxuabc","note":"","ucode":"73BAC7A3276743","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62226,"discussion_content":"这个太好了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574824881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":true,"id":72030,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1551502249,"is_pvip":false,"discussion_count":10,"race_medal":0,"score":"916379536297","product_id":100017301,"comment_content":"二刷了下排序，有了一些新的体会。<br><br>冒泡、插入、选择排序都有一个共同点，将待排序数列分为已排序和未排序两部分。在未排序的部分中查找一个最值，放到已排序数列的恰当位置。<br><br>具体到代码层面，外层循环的变量用于分割已排序和未排序数，内层循环的变量用于在未排序数中查找。从思路上看，这三种算法其实是一样的，所以时间复杂度也相同。<br>","like_count":214,"discussions":[{"author":{"id":1438908,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f4/bc/f97c2d9d.jpg","nickname":"憨人","note":"","ucode":"EFA74A9880B60C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163748,"discussion_content":"插入排序内层循环的变量应该是在已排序数中找插入位置。冒泡排序的内层循环的变量则是在未排序数中查找。两者思路有点相反","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1581090730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1068724,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4e/b4/335e58d6.jpg","nickname":"华新","note":"","ucode":"B6DB20898F5F99","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":189415,"discussion_content":"插入排序并不是从未排序列表中查找一个最值吧。。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1582879067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1686409,"avatar":"https://static001.geekbang.org/account/avatar/00/19/bb/89/c080540d.jpg","nickname":"红桃K-","note":"","ucode":"2B6B71EEF1F07F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":177643,"discussion_content":"我有不一样的理解，甚至觉得您说的不太准确，但是我也不知道我的想法对不对，希望大家也一起思考思考。\n外层循环循环一次排好一个数据，换句话说，外层循环是需要循环的次数就是需要排的数据的个数\n一次冒泡每次保证最大的数在最后，所以需要排n-1次就可以，因为只剩一个数没排的时候这个数必定是最小的。\n插入同理，插入视第一个数据为有序区，也就是不用排第一个位置的数据，起始条件就是i=1，剩下的数据都需要排序，所以是i<n。\n选择是每次选择未排序区最小的元素与在未排序区的开始互换，也可以说是和有序区末尾的下一个元素互换。互换一次拍好一个数据，从第一个开始，也就是下标为0开始，i=0，需要排n-1次，因为剩下最后一个一定是所有数据中最大的。\n这是我认为外层循环的含义\n而我认为内层循环才是像您说的那样分割已排序区和未排序区，同时在内层循环内完成比较、交换、或是移动操作。\n不知道这么理解对不对，我的理解如有错误，希望大家指正，共同学习进步，谢谢\n","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1582117765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1245294,"avatar":"https://static001.geekbang.org/account/avatar/00/13/00/6e/11362a1e.jpg","nickname":"感动超人","note":"","ucode":"DDBFE64A9DB28D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1686409,"avatar":"https://static001.geekbang.org/account/avatar/00/19/bb/89/c080540d.jpg","nickname":"红桃K-","note":"","ucode":"2B6B71EEF1F07F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":183599,"discussion_content":"数组是有顺序的,所以外层 i 的循环次数可以确定 i 元素的位置  进而分割 有序无序\n重要的一点, 内层 j 的循环次数是根据 外层i 确定的 所以进一步理解就是 外层i 分割","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1582504454,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":177643,"ip_address":""},"score":183599,"extra":""},{"author":{"id":1437760,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f0/40/219be32a.jpg","nickname":"绝影","note":"","ucode":"EA3C85D21DE210","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1686409,"avatar":"https://static001.geekbang.org/account/avatar/00/19/bb/89/c080540d.jpg","nickname":"红桃K-","note":"","ucode":"2B6B71EEF1F07F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":231203,"discussion_content":"插入排序我不是很赞同，外层循环都是从无序序列中顺序取出的一个插入值(位置为i)，i之后的元素是无序的，i之前的元素是有序的（已经排序好的），插入值和有序序列中的最大值位置开始比较（也就是j=i-1），如果插入值大于有序序列中当前的比较值，那就把比较值后移一个位置，位置为i的元素已经取出来存放在临时变量里面了，即使i之前的元素都后移动一个位置也不会覆盖其他值。内层循环当前比较元素j的位置加1始终等于元素为空的位置，直到比较到小于等于插入值时不再进行比较，把取出值插入到位空的位置。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586788967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":177643,"ip_address":""},"score":231203,"extra":""}]},{"author":{"id":1423991,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ba/77/e89c2351.jpg","nickname":"滕生","note":"","ucode":"354C1A26FE3CF2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87248,"discussion_content":"总结的好啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576655375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1748135,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/ac/a7/cd002b88.jpg","nickname":"Ezio、","note":"","ucode":"645B5A59125D5A","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389383,"discussion_content":"说的很好，意思表达到了，一句话醍醐灌顶","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629257959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1248326,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0c/46/dfe32cf4.jpg","nickname":"多选参数","note":"","ucode":"B2294D80AB075F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":246519,"discussion_content":"找最值不太多吧，插入就不是。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587742046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1689380,"avatar":"https://static001.geekbang.org/account/avatar/00/19/c7/24/19d0683e.jpg","nickname":"crossing","note":"","ucode":"3B66CFFF38BA67","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71688,"discussion_content":"已排序和未排序两部分，很好！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575449122,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1661456,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epYAmnyHBCVY7YicTF3IXa39mvVTuyum9yicPyFG5amXuo6R2QOTicX0iaXLicH8CTktC7XHruv81ichgkg/132","nickname":"Geek_b25f99","note":"","ucode":"6F7BEAB2C31528","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":45982,"discussion_content":"总结的好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573106032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32499,"user_name":"靑城","can_delete":false,"product_type":"c1","uid":1242064,"ip_address":"","ucode":"ADE48AF334558B","user_header":"https://static001.geekbang.org/account/avatar/00/12/f3/d0/8727aa8e.jpg","comment_is_top":false,"comment_ctime":1539591446,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"538410503446","product_id":100017301,"comment_content":"总结<br><br>一、排序方法与复杂度归类<br>（1）几种最经典、最常用的排序方法：冒泡排序、插入排序、选择排序、快速排序、归并排序、计数排序、基数排序、桶排序。<br>（2）复杂度归类<br>冒泡排序、插入排序、选择排序          O(n^2)<br>快速排序、归并排序                           O(nlogn)<br>计数排序、基数排序、桶排序             O(n)<br><br>二、如何分析一个“排序算法”？<br>&lt;1&gt;算法的执行效率<br>1. 最好、最坏、平均情况时间复杂度。<br>2. 时间复杂度的系数、常数和低阶。<br>3. 比较次数，交换（或移动）次数。<br>&lt;2&gt;排序算法的稳定性<br>1. 稳定性概念：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。<br>2. 稳定性重要性：可针对对象的多种属性进行有优先级的排序。<br>3. 举例：给电商交易系统中的“订单”排序，按照金额大小对订单数据排序，对于相同金额的订单以下单时间早晚排序。用稳定排序算法可简洁地解决。先按照下单时间给订单排序，排序完成后用稳定排序算法按照订单金额重新排序。<br>&lt;3&gt;排序算法的内存损耗<br>原地排序算法：特指空间复杂度是O(1)的排序算法。<br><br>三、冒泡排序<br>       冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求，如果不满足就让它俩互换。<br>稳定性：冒泡排序是稳定的排序算法。<br>空间复杂度：冒泡排序是原地排序算法。<br>时间复杂度：<br>1. 最好情况（满有序度）：O(n)。<br>2. 最坏情况（满逆序度）：O(n^2)。<br>3. 平均情况：<br>       “有序度”和“逆序度”：对于一个不完全有序的数组，如4，5，6，3，2，1，有序元素对为3个（4，5），（4，6），（5，6），有序度为3，逆序度为12；对于一个完全有序的数组，如1，2，3，4，5，6，有序度就是n*(n-1)&#47;2，也就是15，称作满有序度；逆序度=满有序度-有序度；冒泡排序、插入排序交换（或移动）次数=逆序度。<br>       最好情况下初始有序度为n*(n-1)&#47;2，最坏情况下初始有序度为0，则平均初始有序度为n*(n-1)&#47;4，即交换次数为n*(n-1)&#47;4，因交换次数&lt;比较次数&lt;最坏情况时间复杂度，所以平均时间复杂度为O(n^2)。<br><br>四、插入排序<br>       插入排序将数组数据分成已排序区间和未排序区间。初始已排序区间只有一个元素，即数组第一个元素。在未排序区间取出一个元素插入到已排序区间的合适位置，直到未排序区间为空。<br>空间复杂度：插入排序是原地排序算法。<br>时间复杂度：<br>1. 最好情况：O(n)。<br>2. 最坏情况：O(n^2)。<br>3. 平均情况：O(n^2)（往数组中插入一个数的平均时间复杂度是O(n)，一共重复n次）。<br>稳定性：插入排序是稳定的排序算法。<br><br>五、选择排序<br>       选择排序将数组分成已排序区间和未排序区间。初始已排序区间为空。每次从未排序区间中选出最小的元素插入已排序区间的末尾，直到未排序区间为空。<br>空间复杂度：选择排序是原地排序算法。<br>时间复杂度：（都是O(n^2)）<br>1. 最好情况：O(n^2)。<br>2. 最坏情况：O(n^2)。<br>3. 平均情况：O(n^2)。<br>稳定性：选择排序不是稳定的排序算法。<br><br>思考<br>       选择排序和插入排序的时间复杂度相同，都是O(n^2)，在实际的软件开发中，为什么我们更倾向于使用插入排序而不是冒泡排序算法呢？<br>       答：从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要3个赋值操作，而插入排序只需要1个，所以在对相同数组进行排序时，冒泡排序的运行时间理论上要长于插入排序。<br>","like_count":125},{"had_liked":false,"id":32402,"user_name":"myrabbit","can_delete":false,"product_type":"c1","uid":1208073,"ip_address":"","ucode":"FC0F930358D0BE","user_header":"","comment_is_top":false,"comment_ctime":1539565306,"is_pvip":false,"replies":[{"id":"11880","content":"不是我画的 大编辑画的","user_name":"作者回复","comment_id":32402,"uid":"1190123","ip_address":"","utype":1,"ctime":1539615280,"user_name_real":"gg"}],"discussion_count":9,"race_medal":0,"score":"435331262202","product_id":100017301,"comment_content":"王老师，我发现你文章中的图画的很漂亮，字也写得很漂亮，图文结合的形式对于表达的帮助真的很大！有时候做笔记也可以用此方法，请问你的图文是用什么软件画的？","like_count":101,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426758,"discussion_content":"不是我画的 大编辑画的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539615280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1088710,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/c6/05a6798f.jpg","nickname":"苗","note":"","ucode":"5ECCC6C855E541","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":32630,"discussion_content":"编辑估计都学会了；我还没会。","likes_number":25,"is_delete":false,"is_hidden":false,"ctime":1571053601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2548071,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e1/67/3d9ba083.jpg","nickname":"song","note":"","ucode":"207F060187295E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544914,"discussion_content":"画的挺好看的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641779575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1324863,"avatar":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","nickname":"KK","note":"","ucode":"FFC31A3FE3A285","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":224671,"discussion_content":"应该是使用：procreate软件绘制的，里面有大量的笔刷工具。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586322599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1218253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/cd/b8f4877b.jpg","nickname":"Richie","note":"","ucode":"556DB70C610E0E","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":185286,"discussion_content":"我也一直想问这个问题，不知道用的什么软件\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582612702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1439426,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f6/c2/bfa234d2.jpg","nickname":"不吃香菜","note":"","ucode":"5CB13465A73790","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":82874,"discussion_content":"sketch这个很好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576394107,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132296,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/08/9fd18b01.jpg","nickname":"calm","note":"","ucode":"02279DE21A71AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5315,"discussion_content":"大编辑用什么软件画的呀，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566175738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1377467,"avatar":"https://static001.geekbang.org/account/avatar/00/15/04/bb/5e5c37c1.jpg","nickname":"Angus","note":"","ucode":"7CC3BA1550FB5B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1132296,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/08/9fd18b01.jpg","nickname":"calm","note":"","ucode":"02279DE21A71AE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6244,"discussion_content":"手画的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566809683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5315,"ip_address":""},"score":6244,"extra":""},{"author":{"id":1360115,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c0/f3/eff6f6ad.jpg","nickname":"cyz","note":"","ucode":"801EF96897BFCF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1132296,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/08/9fd18b01.jpg","nickname":"calm","note":"","ucode":"02279DE21A71AE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":32016,"discussion_content":"好像是sketchBook","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570978494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5315,"ip_address":""},"score":32016,"extra":""}]}]},{"had_liked":false,"id":41850,"user_name":"陈问渔","can_delete":false,"product_type":"c1","uid":1194166,"ip_address":"","ucode":"6838D015BB9CBB","user_header":"https://static001.geekbang.org/account/avatar/00/12/38/b6/234a17a7.jpg","comment_is_top":false,"comment_ctime":1542858894,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"285010700430","product_id":100017301,"comment_content":"https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;HQg3BzzQfJXcWyltsgOfCQ<br><br>这里面的图解排序算法，很形象。java实现的代码","like_count":66},{"had_liked":true,"id":36469,"user_name":"流风之回雪","can_delete":false,"product_type":"c1","uid":1202376,"ip_address":"","ucode":"BDB41EC122BF8A","user_header":"https://static001.geekbang.org/account/avatar/00/12/58/c8/8824c9b1.jpg","comment_is_top":false,"comment_ctime":1541121920,"is_pvip":false,"replies":[{"id":"12953","content":"👍钻研精神","user_name":"作者回复","comment_id":36469,"uid":"1190123","ip_address":"","utype":1,"ctime":1541123758,"user_name_real":"gg"}],"discussion_count":15,"race_medal":0,"score":"246354257792","product_id":100017301,"comment_content":"a[j+1] = value; &#47;&#47; 插入数据，这条语句弄了好久才明白，一直以为 j的值最小为0，那么a[j+1]最小就是a[1]，不过这样赋值逻辑上就有问题，后来debug了一下，发现j是可以为-1的，a[j+1]最小为a[0]，这样逻辑上就通了，果然多敲代码才能弄明白勒","like_count":57,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427878,"discussion_content":"👍钻研精神","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541123758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018620,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","nickname":"ipofss","note":"","ucode":"DE3061C9259F9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294884,"discussion_content":"我也是迷糊了好久，终于想明白了。当所有的已排序的数都大于value时，j就能减到-1，插入头部，就是位置为0；当找到一个小于等于value的数时，就该往j的右边一位插入value，就是j+1了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1596024181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1397631,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKVUskibDnhMt5MCIJ8227HWkeg2wEEyewps8GuWhWaY5fy7Ya56bu2ktMlxdla3K29Wqia9efCkWaQ/132","nickname":"衬衫的价格是19美元","note":"","ucode":"655F925451F772","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309257,"discussion_content":"执行到a[j+1] = value有两种来源，一种是a[j] <= value，也就是找到了第一个不大于value的值，那么把value放他后面就行了，也就是j+1的位置；另一种是内层for循环已经走完了，也就是value应该放在a[0]的位置，由于此时j = -1, 因此j+1 就是a[0]了。此处a[j+1] = value把两种情况巧妙的结合到一起了，其实分开写也行，逻辑上更清楚，但是看起来没这么美观了。我觉得这是个非常好的问题，我觉得算法就是要扣这些实现细节，光清楚原理只是一条腿，能准确无误的实现是另一条腿，共勉","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1601229063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1329980,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4b/3c/a66a3e81.jpg","nickname":"杜茂坤","note":"","ucode":"93CC412C68527F","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553321,"discussion_content":"终于明白了，注意j定义的位置，它是定义在第一个for循环之后，第二个for循环之前，当从尾到头找插入元素时，假如当前已排好是456，现在需要插入1，1与6比较6后移，1与5比较5后移，1与4比较4后移，因为第二个for循环的第二个条件是j&gt;=0,所以当j=0时是满足条件的，执行完后，执行--j，此时j = -1,不满足j&gt;=0这个条件，此时会执行 a[j + 1] = value;这条语句，此时j=-1,j+1 = 0；","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1645849241,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194060,"avatar":"https://static001.geekbang.org/account/avatar/00/12/38/4c/5426e2e0.jpg","nickname":"CJJ","note":"","ucode":"7E02A6A8547559","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":242272,"discussion_content":"我刚刚看到也有点懵，然后一直在地铁里面想，刚好想通就到站了哈哈","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587473506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1299347,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d3/93/c3fb8566.jpg","nickname":"ProcessIsTheKey","note":"","ucode":"BE02EFD75F7D98","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552201,"discussion_content":"// 从代码上分析   \n public static void insertionSort(int[] arr) {\n        int len = arr.length;\n        for (int i = 1; i &lt; len; i++) {//未排序区间\n            //待排序的元素\n            int itemInOrdering = arr[i];\n            //找到这个待排元素在已排序区间的位置\n            int j = i - 1;//代码C处\n            for (; j &gt; -1; j--) {//代码B处\n                if (itemInOrdering &lt; arr[j]) {\n                    //所有大于itemInOrdering值的，依次后移一个位置,代码A处\n                    arr[j + 1] = arr[j];\n                } else {\n                    //再往下走就是小于或等于itemInOrdering值的了，直接break即可，这个时候的j就是待排序元素应该插入的下标\n                    System.out.println(&#34;break break&#34;);\n                    break;\n                }\n            }\n            //因为代码A处最后一行走完之后，代码B处对j进行了减1处理，所以需要把1加回来；\n            //特例情况：itemInOrdering就是目前已排序区间最大值，那么j就是代码C处定义的值，同样需要把1加回来\n            arr[j + 1] = itemInOrdering;\n        }\n        System.out.println(&#34;数据:&#34; + Arrays.toString(arr));\n    }","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645345398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2559151,"avatar":"https://static001.geekbang.org/account/avatar/00/27/0c/af/c9dfd8f2.jpg","nickname":"五后","note":"","ucode":"3032B397B736EF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539278,"discussion_content":"for循环最后j减了1之后，不符合判断条件，不进入循环体了。所以for循环后面的j，比理论上的小了1，所以要加1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639655293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2090232,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/e4/f8/80374742.jpg","nickname":"锅侠","note":"","ucode":"2F7856BEF55301","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333870,"discussion_content":"我都是靠想象来完成的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607656767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1876592,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/a2/70/98cfd56b.jpg","nickname":"新安","note":"","ucode":"CA2E1304FCAC6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296912,"discussion_content":"一样一样，debug了一下才恍然大悟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596703812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":68850,"discussion_content":"可以的，比如  [6 ,5 ,3 ] 这种数组，最开始就是 --j 到 j = -1了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575220062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1729853,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/65/3d/afc2e163.jpg","nickname":"西谷","note":"","ucode":"0378211B2359E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53819,"discussion_content":"我也在这困住了好久，最后打了个桩才意识到还有个j--","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574221892,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1716067,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/2f/63/7a048d46.jpg","nickname":"梨子苹果","note":"","ucode":"3666813FEE31D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53761,"discussion_content":"第一个都是1了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574214127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1258957,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/cd/5bb487a0.jpg","nickname":"荣思敏","note":"","ucode":"50689C9D89846A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":45771,"discussion_content":"吊炸天，我也是打算去研究下这行为什么不是a[j] = value 的，结果看了你的，了然。必须动手来起！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573085395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1185974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/18/b6/f3f68a39.jpg","nickname":"马建华","note":"","ucode":"928189590259AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":12690,"discussion_content":"我明白了！因为在for循环中，j=0以后，还是满足条件，j--之后j变成了-1，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568561463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1185974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/18/b6/f3f68a39.jpg","nickname":"马建华","note":"","ucode":"928189590259AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":12669,"discussion_content":"没明白，j怎么可以到-1呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568559961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":38543,"user_name":"allean","can_delete":false,"product_type":"c1","uid":1051470,"ip_address":"","ucode":"A0D2DB4F219EAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/0b/4e/fd946cb2.jpg","comment_is_top":false,"comment_ctime":1542073288,"is_pvip":false,"replies":[{"id":"13814","content":"👍","user_name":"作者回复","comment_id":38543,"uid":"1190123","ip_address":"","utype":1,"ctime":1542074282,"user_name_real":"gg"}],"discussion_count":2,"race_medal":0,"score":"233470307272","product_id":100017301,"comment_content":"每一次看文章都要至少看三遍，代码实现也至少写三遍，不是追求量，是真的感觉每一次的体会都更加不一样😁","like_count":54,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428742,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542074282,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2404887,"avatar":"https://static001.geekbang.org/account/avatar/00/24/b2/17/3161b49c.jpg","nickname":"达叔灬","note":"","ucode":"5CCBAF13548F02","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369560,"discussion_content":"确实 第一遍刷一下大致的内容 第二遍开始深入理解 第三遍 算是复习 ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1619078702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34420,"user_name":"姜威","can_delete":false,"product_type":"c1","uid":1244051,"ip_address":"","ucode":"C58EB9A5AD634D","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/93/f19a5364.jpg","comment_is_top":false,"comment_ctime":1540168811,"is_pvip":false,"replies":[{"id":"12271","content":"👍","user_name":"作者回复","comment_id":34420,"uid":"1190123","ip_address":"","utype":1,"ctime":1540174587,"user_name_real":"gg"}],"discussion_count":1,"race_medal":0,"score":"177633827947","product_id":100017301,"comment_content":"总结：<br>一、几种经典排序算法及其时间复杂度级别<br>冒泡、插入、选择 O(n^2) 基于比较<br>快排、归并 O(nlogn) 基于比较<br>计数、基数、桶 O(n) 不基于比较<br>二、如何分析一个排序算法？<br>1.学习排序算法的思路？明确原理、掌握实现以及分析性能。<br>2.如何分析排序算法性能？从执行效率、内存消耗以及稳定性3个方面分析排序算法的性能。<br>3.执行效率：从以下3个方面来衡量<br>1）最好情况、最坏情况、平均情况时间复杂度<br>2）时间复杂度的系数、常数、低阶：排序的数据量比较小时考虑<br>3）比较次数和交换（或移动）次数<br>4.内存消耗：通过空间复杂度来衡量。针对排序算法的空间复杂度，引入原地排序的概念，原地排序算法就是指空间复杂度为O(1)的排序算法。<br>5.稳定性：如果待排序的序列中存在值等的元素，经过排序之后，相等元素之间原有的先后顺序不变，就说明这个排序算法时稳定的。<br>三、冒泡排序<br>1.排序原理<br>1）冒泡排序只会操作相邻的两个数据。<br>2）对相邻两个数据进行比较，看是否满足大小关系要求，若不满足让它俩互换。<br>3）一次冒泡会让至少一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作。<br>4）优化：若某次冒泡不存在数据交换，则说明已经达到完全有序，所以终止冒泡。<br>2.代码实现（见下一条留言）<br>3.性能分析<br>1）执行效率：最小时间复杂度、最大时间复杂度、平均时间复杂度<br>最小时间复杂度：数据完全有序时，只需进行一次冒泡操作即可，时间复杂度是O(n)。<br>最大时间复杂度：数据倒序排序时，需要n次冒泡操作，时间复杂度是O(n^2)。<br>平均时间复杂度：通过有序度和逆序度来分析。<br>什么是有序度？<br>有序度是数组中具有有序关系的元素对的个数，比如[2,4,3,1,5,6]这组数据的有序度就是11，分别是[2,4][2,3][2,5][2,6][4,5][4,6][3,5][3,6][1,5][1,6][5,6]。同理，对于一个倒序数组，比如[6,5,4,3,2,1]，有序度是0；对于一个完全有序的数组，比如[1,2,3,4,5,6]，有序度为n*(n-1)&#47;2，也就是15，完全有序的情况称为满有序度。<br>什么是逆序度？逆序度的定义正好和有序度相反。核心公式：逆序度=满有序度-有序度。<br>排序过程，就是有序度增加，逆序度减少的过程，最后达到满有序度，就说明排序完成了。<br>冒泡排序包含两个操作原子，即比较和交换，每交换一次，有序度加1。不管算法如何改进，交换的次数总是确定的，即逆序度。<br>对于包含n个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏的情况初始有序度为0，所以要进行n*(n-1)&#47;2交换。最好情况下，初始状态有序度是n*(n-1)&#47;2，就不需要进行交互。我们可以取个中间值n*(n-1)&#47;4，来表示初始有序度既不是很高也不是很低的平均情况。<br>换句话说，平均情况下，需要n*(n-1)&#47;4次交换操作，比较操作可定比交换操作多，而复杂度的上限是O(n^2)，所以平均情况时间复杂度就是O(n^2)。<br>以上的分析并不严格，但很实用，这就够了。<br>2）空间复杂度：每次交换仅需1个临时变量，故空间复杂度为O(1)，是原地排序算法。<br>3）算法稳定性：如果两个值相等，就不会交换位置，故是稳定排序算法。<br>四、插入排序<br>1.算法原理<br>首先，我们将数组中的数据分为2个区间，即已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想就是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间中的元素一直有序。重复这个过程，直到未排序中元素为空，算法结束。<br>2.代码实现（见下一条留言）<br>3.性能分析<br>1）时间复杂度：最好、最坏、平均情况<br>如果要排序的数组已经是有序的，我们并不需要搬移任何数据。只需要遍历一遍数组即可，所以时间复杂度是O(n)。如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，因此时间复杂度是O(n^2)。而在一个数组中插入一个元素的平均时间复杂都是O(n)，插入排序需要n次插入，所以平均时间复杂度是O(n^2)。<br>2）空间复杂度：从上面的代码可以看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是O(1)，是原地排序算法。<br>3）算法稳定性：在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现的元素的后面，这样就保持原有的顺序不变，所以是稳定的。<br><br><br>","like_count":41,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427205,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540174587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32415,"user_name":"Jo","can_delete":false,"product_type":"c1","uid":1233748,"ip_address":"","ucode":"0EF4D66963C112","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/peVXJxibHW5xicV0o87BniaV31KSDaT9SibhQd1VH1lpgmwc77nezp81n3amCzjYhT5jOpw6sfOxXGajzyL1cZjeZw/132","comment_is_top":false,"comment_ctime":1539566838,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"121798651126","product_id":100017301,"comment_content":"冒泡排序的外层循环次数只需要n-1次，此时第1个数字在上一次已经比较过，肯定比第2个小（或大），所以第n次没必要比较了","like_count":28,"discussions":[{"author":{"id":1329980,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4b/3c/a66a3e81.jpg","nickname":"杜茂坤","note":"","ucode":"93CC412C68527F","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552047,"discussion_content":"对，冒泡排序每次确定一个数，n-1次已经确定了n-1个数了，剩下的一个也就已经定了，算法中外层的循环次数应该是n-1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645255614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1611025,"avatar":"https://static001.geekbang.org/account/avatar/00/18/95/11/eb431e52.jpg","nickname":"沈康","note":"","ucode":"02AFA50738AB8E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370561,"discussion_content":"没错外层循环只需要n-1次数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619449847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":47404,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1544142417,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"96033422929","product_id":100017301,"comment_content":"把该讲内容总结为几个问题, 大家复习的时候可以先尝试回答这些问题检查自己的掌握程度:<br><br>\t1. <br>分析排序算法的三个维度都是什么?<br>\t2. <br>从算法执行效率这个维度出发可以从哪三个方面进行衡量?<br>\t3. <br>原地排序的概念是什么?<br>\t4. <br>什么是排序的稳定性, 稳定性排序算法和不稳定排序算法的区别在哪里?<br>\t5. <br>数组的满序度, 有序度, 逆序度概念各是什么? 如何计算?  <br>\t6. <br>冒泡排序的实现思路是怎样的, 请实现冒泡排序算法?<br>\t7. <br>冒泡排序的为什么是原地排序算法, 为什么是稳定排序算法, 最好最坏,平均时间复杂度各是多少?<br>\t8. <br>插入排序的实现思路是怎样的, 请实现插入排序算法?<br>\t9. <br>插入排序的为什么是原地排序算法, 为什么是原地排序算法, 最好最坏,平均时间复杂度各是多少?<br>\t10. <br>选择排序的实现思路是怎样的, 请实现选择排序算法?<br>\t11. <br>选择排序的为什么是原地排序算法, 为什么不是稳定排序算法, 最好最坏,平均时间复杂度各是多少?<br>\t12. <br>插入排序比冒泡排序的优势在哪里<br><br>","like_count":22,"discussions":[{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163359,"discussion_content":"1.分析排序算法的三个维度都是什么?\n执行效率，内存消耗，算法稳定性\n2.从算法执行效率这个维度出发可以从哪三个方面进行衡量?\n最好最坏和平均时间复杂度，时间复杂度系数、常数和低阶，比较和交换、移动次数\n3.原地排序的概念是什么?\n排序时，除待排序元素组外部不占用额外的空间，即为原地排序\n4.什么是排序的稳定性, 稳定性排序算法和不稳定排序算法的区别在哪里?\n对于相同元素，在排序前后的位置不变，即为稳定算法。稳定与不稳定的区别在于相同元素在排序前后的位置是否变化。\n5.数组的满序度, 有序度, 逆序度概念各是什么? 如何计算?\n有序度是指有序元素对的个数，逆序度是指反序元素对的个数，满序度是指在排序后有序元素对的个数，两者之和就是满序度。\n6.冒泡排序的实现思路是怎样的, 请实现冒泡排序算法?\n相邻元素进行比较，有序则不交换，反序则交换，直到最后一个元素，这样可以保证一个满足条件的元素被移动到最终位置。下一轮从第二个元素开始，直到倒数第二个元素。\n7.冒泡排序的为什么是原地排序算法, 为什么是稳定排序算法, 最好最坏,平均时间复杂度各是多少?\n不占用额外空间。相同元素比较后不交换则稳定，交换则不稳定。最好O(n),最坏O(n2),平均O(n2).\n8.插入排序的实现思路是怎样的, 请实现插入排序算法?\n将待排序元素组分成已排序区和未排序区，将未排序区元素依次插入已排序区，且保证已排序区始终有序，直到未排序区为空。\n9.插入排序的为什么是原地排序算法, 最好最坏,平均时间复杂度各是多少?\n未使用额外空间排序。最好O(n),最坏O(n2),平均O(n2)。\n10.选择排序的实现思路是怎样的, 请实现选择排序算法?\n将待排序元素组分成已排序区和未排序区，在未排序区中找满足条件的元素插入已排序区的最后，直到未排序区为空。\n11.选择排序的为什么是原地排序算法, 为什么不是稳定排序算法, 最好最坏,平均时间复杂度各是多少?\n排序未使用额外空间。元素在插入已排序区时会导致未排序区第一个元素和满足条件元素进行交换，交换可能导致相同元素位置变化。最好O(n2),最坏O(n2),平均O(n2)。\n12.插入排序比冒泡排序的优势在哪里\n在java中，冒泡排序中交换需要三次赋值，插入排序中交换需要一次赋值，开销插入排序小。\n插入排序的优化空间比冒泡排序大","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1581073414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32398,"user_name":"醉比","can_delete":false,"product_type":"c1","uid":1248399,"ip_address":"","ucode":"79E65F62BE7809","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/8f/4ebd303a.jpg","comment_is_top":false,"comment_ctime":1539564751,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"87438910671","product_id":100017301,"comment_content":"大家多思考多吸收吧。。。。我得多吸收一会","like_count":20},{"had_liked":true,"id":121915,"user_name":"王木公","can_delete":false,"product_type":"c1","uid":1014550,"ip_address":"","ucode":"F049AEBFA0338D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/16/ca250e8c.jpg","comment_is_top":false,"comment_ctime":1565248812,"is_pvip":false,"replies":[{"id":"45692","content":"很难知道人家是怎么想到的，你要求有点高了，说不定灵机一动就想到了。","user_name":"作者回复","comment_id":121915,"uid":"1190123","ip_address":"","utype":1,"ctime":1565909005,"user_name_real":"王争"}],"discussion_count":10,"race_medal":0,"score":"74579692844","product_id":100017301,"comment_content":"感觉有个问题始终没有解决。前人是如何想出的这些算法？或者说是在怎样的环境下，作者经历了怎样的心路历程想出了这个算法。我认为知道这个很重要，尽管现在学这些算法觉得理所应当，但当时间久了仍然会忘记，尤其是那些细节临界点，人的大脑适合记忆有关联性的东西，这些算法则属于不擅长记忆的创造性内容，如果没有历史那些前提，相信很难根本性掌握。","like_count":17,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462002,"discussion_content":"很难知道人家是怎么想到的，你要求有点高了，说不定灵机一动就想到了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565909005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1988075,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJX4ZU53F8hBHicctluqK6Ef3U0ib40bq1vFyAvqV0wu3GaPuWbj967OdMT7k0gl3OMxsfopvbk9veQ/132","nickname":"Geek_dd8b2b","note":"","ucode":"CBEF7C39075A96","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283922,"discussion_content":"我觉得插入排序是从打扑克牌里想出来的，我有红桃10我就找红桃j，红桃q，红桃k","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1592400409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1351075,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a3/79fc9017.jpg","nickname":"minsky","note":"","ucode":"7296ECA064E89B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290095,"discussion_content":"个人认为这些源于对数据的一些基本操作，譬如要让整体有序，我们一般都是先让局部有序，然后让局部扩充为整体，这种思想的常见的做法譬如用下标控制将数据分为有序部分和无序部分，让后让有序部分逐渐扩大到整体的范围。往细了看，添加有序部分的时候很自然的想到的一些基本操作譬如搜索和插入方式，直接在有序部分插入就需要在找到这个元素的时候做一次搜索确保它是当前有序部分的下一个元素（选着排序的做法），直接获取元素然后在有序部分搜索插入的位置然后插入（插入排序的做法），这两种做法都用到了搜索一个是在有序的部分做搜索一个在无序部分搜索。\n上面讲到的所有数据分部分，然后逐渐扩大有序部分，先插入后搜索和先搜索后插入等这些基本的操作是感觉是源于对数据结构本身的特点以及问题的边界调节实践出来动手经验，然后在排序的时候综合的用上了而已。\n说了这么多，其实总结来看就是排序算法是一个综合的算法，要深刻理解和掌握需要先掌握它的“零部件”，零部件的掌握就是一个实践总结的过程","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1594343932,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1652836,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epKJlW7sqts2ZbPuhMbseTAdvHWnrc4ficAeSZyKibkvn6qyxflPrkKKU3mH6XCNmYvDg11tB6y0pxg/132","nickname":"pc","note":"","ucode":"1AD538B9A900B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":225128,"discussion_content":"加法是怎么搞出来的，你了解了么","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1586349509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194060,"avatar":"https://static001.geekbang.org/account/avatar/00/12/38/4c/5426e2e0.jpg","nickname":"CJJ","note":"","ucode":"7E02A6A8547559","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":242274,"discussion_content":"我觉得，编程还是源于生活吧，生活中就有很多时候需要排序的，用的最多应该就是一个一个比较吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587473794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2322244,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/mxxEd3scP7RUgoh9oXWqUZDU5fIabDIh0ALAcvGZy4GXJYiazicd2ARGodujqU77fbGHatPyZMdVSQ04Y0qNDWaA/132","nickname":"zzzzzc","note":"","ucode":"9F58C0BD30E300","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":354300,"discussion_content":"这叫重在理解！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615271200,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1228588,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/2c/09f58f16.jpg","nickname":"痞子呀","note":"","ucode":"0678778302E555","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128302,"discussion_content":"同感，很多时候我们对这些背后的故事几乎并不了解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578627189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":68853,"discussion_content":"em，同感","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575220360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1079152,"avatar":"https://static001.geekbang.org/account/avatar/00/10/77/70/466368e1.jpg","nickname":"杰森莫玛","note":"","ucode":"A29AEC27270657","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9712,"discussion_content":"对，最好记住每种算法的发明者","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568207507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1212024,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7e/78/cbe25302.jpg","nickname":"王彤","note":"","ucode":"6E795B663DF29F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1079152,"avatar":"https://static001.geekbang.org/account/avatar/00/10/77/70/466368e1.jpg","nickname":"杰森莫玛","note":"","ucode":"A29AEC27270657","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":131011,"discussion_content":"这个要求就太高了，都是站在前人基础上，包括平方根倒数速算数现在都不知道是谁发现的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578819160,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":9712,"ip_address":""},"score":131011,"extra":""}]}]},{"had_liked":false,"id":34422,"user_name":"姜威","can_delete":false,"product_type":"c1","uid":1244051,"ip_address":"","ucode":"C58EB9A5AD634D","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/93/f19a5364.jpg","comment_is_top":false,"comment_ctime":1540169187,"is_pvip":false,"replies":[{"id":"12272","content":"👍","user_name":"作者回复","comment_id":34422,"uid":"1190123","ip_address":"","utype":1,"ctime":1540174607,"user_name_real":"gg"}],"discussion_count":5,"race_medal":0,"score":"70259645923","product_id":100017301,"comment_content":"五、选择排序<br>1.算法原理<br>选择排序算法也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，并将其放置到已排序区间的末尾。<br>2.代码实现（见下一条留言）<br>3.性能分析<br>1）时间复杂度：最好、最坏、平均情况<br>选择排序的最好、最坏、平均情况时间复杂度都是O(n^2)。为什么？因为无论是否有序，每个循环都会完整执行，没得商量。<br>2）空间复杂度：<br>选择排序算法空间复杂度是O(1)，是一种原地排序算法。<br>3）算法稳定性：<br>选择排序算法不是一种稳定排序算法，比如[5,8,5,2,9]这个数组，使用选择排序算法第一次找到的最小元素就是2，与第一个位置的元素5交换位置，那第一个5和中间的5的顺序就变量，所以就不稳定了。正因如此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。<br>六、思考<br>1.冒泡排序和插入排序的时间复杂度都是 O(n^2)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？<br>冒泡排序移动数据有3条赋值语句，而选择排序的交换位置的只有1条赋值语句，因此在有序度相同的情况下，冒泡排序时间复杂度是选择排序的3倍，所以，选择排序性能更好。<br>2.如果数据存储在链表中，这三种排序算法还能工作吗？如果能，那相应的时间、空间复杂度又是多少呢？<br><br>代码实现：<br>&#47;**<br> * 冒泡排序<br> * @param a 待排序数组<br> * @param n 数组长度<br> *&#47;<br>public static void bubbleSort(int[] a, int n) {<br>        if(n&lt;=0) return ;<br>\tfor (int i = 0; i &lt; n; i++) {<br>\t\t&#47;&#47;标记一次冒泡是否存在数据交换，若存在，则改为true<br>\t\tboolean tag = false;<br>\t\tfor (int j = 0; j &lt; n-1-i; j++) {<br>\t\t\tif(a[j] &gt; a[j+1]){<br>\t\t\t\tint temp = a[j];<br>\t\t\t\ta[j] = a[j+1];<br>\t\t\t\ta[j+1] = temp;<br>\t\t\t\ttag = true;<br>\t\t\t}<br>\t\t}<br>\t\t&#47;&#47;若本次冒泡操作未发生数据交换，则终止冒泡操作<br>\t\tif (tag == false) break;<br>\t}<br>}<br><br>&#47;**<br> * 插入排序<br> * @param a 待排序数组<br> * @param n 表示数组大小<br> *&#47;<br>public static void insertSort(int[] a, int n) {<br>       if(n&lt;=1) return;<br>       for(int i=1;i&lt;n;i++){<br>            int value=a[i];<br>            int j=i-1;<br>            &#47;&#47;找到插入位置<br>            for(;j&gt;0;j--){<br>            if(a[j]&gt;value){<br>                  a[j+1]=a[j];&#47;&#47;移动数据<br>            } else {<br>                  break;<br>            }<br>       }<br>       a[j+1]=value;&#47;&#47;插入数据<br>       }<br>}<br><br>&#47;**<br> * 选择排序<br> * @param a 待排序数组<br> * @param n 数组长度<br> *&#47;<br>public static void selectSort(int[] a, int n) {<br>\tif(n&lt;=0) return;<br>        for(int i=0;i&lt;n;i++){<br>             int min=i;<br>             for(int j=i;j&lt;n;j++){<br>                  if(a[j] &lt; a[min]) min=j;<br>             }<br>             if(min != i){<br>                  int temp=a[i];<br>                  a[i]=a[min];<br>                  a[min]=temp;<br>             }<br>        }<br>}","like_count":16,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427207,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540174607,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":68852,"discussion_content":"// 选择排序，a表示数组，n表示数组大小\npublic void selectionSort(int[] a, int n) {\n\n\tif(n <= 1) {\n\t\treturn;\n\t}\n\t\n\tfor(int i = 0; i < n - 1; i++){\n\t\tint min = i;\n\t\n\t\t// 找出剩下的未排序区间的最小值的下标\n\t\t// 无论如何 都要比较到头，所以这里 是 O(n) \n\t\tfor(int j = i+1; j < n; j++){\n\t\t\tif(a[j] < a[min]){\n\t\t\t\tmin = j;\n\t\t\t}\n\t\t}\n\t\n\t\t// 和当前下标 不相等的话，要对调一下\n\t\tif(min != i){\n\t\t\tint tempValue = a[i];\n\t\t\ta[i] = a[min]\n\t\t\ta[min] = tempValue;\n\t\t}\n\t}\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575220288,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":68851,"discussion_content":"selectSort  细节有问题。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575220285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1047466,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fb/aa/01fedf6c.jpg","nickname":"JKwar","note":"","ucode":"B733CA24D5701F","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":44514,"discussion_content":"冒泡排序移动数据有3条赋值语句，而选择排序的交换位置的只有1条赋值语句，因此在有序度相同的情况下，冒泡排序时间复杂度是选择排序的3倍，所以，选择排序性能更好           有问题应该是插入排序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572954527,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1616981,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ac/55/f7aec5c3.jpg","nickname":"白菜","note":"","ucode":"D4CF8392B3BCBE","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4263,"discussion_content":"冒泡排序和选择排序的代码应该要稍微改一点地方。if(n<=1) return;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565259293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32656,"user_name":"oldman","can_delete":false,"product_type":"c1","uid":1133711,"ip_address":"","ucode":"6BACE2832B4429","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/8f/a90b3969.jpg","comment_is_top":false,"comment_ctime":1539657483,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"65964166923","product_id":100017301,"comment_content":"我用python实现了冒泡排序，插入排序，选择排序。地址如下，欢迎大家一起探讨：<br>冒泡排序：https:&#47;&#47;github.com&#47;lipeng1991&#47;testdemo&#47;blob&#47;master&#47;40_bubble_sort.py<br>插入排序：https:&#47;&#47;github.com&#47;lipeng1991&#47;testdemo&#47;blob&#47;master&#47;41_insert_sort.py<br>选择排序： https:&#47;&#47;github.com&#47;lipeng1991&#47;testdemo&#47;blob&#47;master&#47;42_select_sort.py","like_count":15},{"had_liked":false,"id":100459,"user_name":"ILoveKindness","can_delete":false,"product_type":"c1","uid":1559444,"ip_address":"","ucode":"A6210B034AAC62","user_header":"https://static001.geekbang.org/account/avatar/00/17/cb/94/eedbace3.jpg","comment_is_top":false,"comment_ctime":1559558886,"is_pvip":false,"replies":[{"id":"36269","content":"应该是不需要倒置的。","user_name":"作者回复","comment_id":100459,"uid":"1190123","ip_address":"","utype":1,"ctime":1559612243,"user_name_real":"王争"}],"discussion_count":3,"race_medal":0,"score":"61689101030","product_id":100017301,"comment_content":"老师您好，我不是很懂您所置顶的答案中插入排序后要倒置链表的意思，请求解答。","like_count":14,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452559,"discussion_content":"应该是不需要倒置的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559612243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1391354,"avatar":"https://static001.geekbang.org/account/avatar/00/15/3a/fa/21f64eaa.jpg","nickname":"mimof9","note":"","ucode":"C83B3E2CD62BBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352572,"discussion_content":"一般这里都是指单链表，不存在从后向前比较的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614773527,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1268797,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5c/3d/e8325811.jpg","nickname":"对白","note":"","ucode":"3183E5ADBC794B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294674,"discussion_content":"如果是从后向前比较看谁小就需要倒置链表，如果从前向后比较看谁大就不需要倒置链表，两种比较思路而已，都是可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595953348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32387,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":false,"comment_ctime":1539564105,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"53079171657","product_id":100017301,"comment_content":"三种排序算法不涉及随机读取，所以链表是可以实现的，而且时间复杂度空间空间复杂度和数组一样，O(n*n),O(1).","like_count":12,"discussions":[{"author":{"id":1758802,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d6/52/d34b1e1f.jpg","nickname":"dark","note":"","ucode":"97588C4A78A78A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584543,"discussion_content":"如果考虑cpu缓存的影响，即使复杂度一致，数组结构还是会更快","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660903561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37750,"user_name":"安静","can_delete":false,"product_type":"c1","uid":1212634,"ip_address":"","ucode":"7C4DB6D81A48EB","user_header":"https://static001.geekbang.org/account/avatar/00/12/80/da/9c0c458c.jpg","comment_is_top":false,"comment_ctime":1541724076,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"44491397036","product_id":100017301,"comment_content":"每天坐地铁看一节都有点坚持不下来了，加油。","like_count":10,"discussions":[{"author":{"id":2069098,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/92/6a/af4ec360.jpg","nickname":"半年","note":"","ucode":"6A53D27062778C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573610,"discussion_content":"２０２２年了，看了多少遍了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653545377,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1115562,"avatar":"https://static001.geekbang.org/account/avatar/00/11/05/aa/3c7c00a4.jpg","nickname":"GK java","note":"","ucode":"AA54E8CAAB974C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":410529,"discussion_content":"21年啦，看完啦没有，兄弟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635725533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2136199,"avatar":"https://static001.geekbang.org/account/avatar/00/20/98/87/57b30e4d.jpg","nickname":"zaygee小号","note":"","ucode":"7EB24821C9B4B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300435,"discussion_content":"同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598099485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":52615,"user_name":"星","can_delete":false,"product_type":"c1","uid":1243505,"ip_address":"","ucode":"2D795C3EE6E706","user_header":"https://static001.geekbang.org/account/avatar/00/12/f9/71/e2f2ef7e.jpg","comment_is_top":false,"comment_ctime":1545454711,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"40200160375","product_id":100017301,"comment_content":"冒泡排序的应该重复n-1次就有序了","like_count":9,"discussions":[{"author":{"id":1268797,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5c/3d/e8325811.jpg","nickname":"对白","note":"","ucode":"3183E5ADBC794B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294675,"discussion_content":"是的，n个元素只需要比较n-1次。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595953402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146107,"user_name":"低调","can_delete":false,"product_type":"c1","uid":1124982,"ip_address":"","ucode":"7D29B371BE9A46","user_header":"https://static001.geekbang.org/account/avatar/00/11/2a/76/36fdddb3.jpg","comment_is_top":false,"comment_ctime":1572433319,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"31637204391","product_id":100017301,"comment_content":"思想理解了，代码跟不上，难受。。。","like_count":7,"discussions":[{"author":{"id":3195094,"avatar":"","nickname":"Geek_a31b27","note":"","ucode":"CE367B2C4CA092","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589876,"discussion_content":"眼睛👀:我会了，手:不，你不会","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665380816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"陕西"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1991078,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/61/a6/bd6cf262.jpg","nickname":"。","note":"","ucode":"067C449245568C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293937,"discussion_content":"我也是。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595733490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32511,"user_name":"z","can_delete":false,"product_type":"c1","uid":1149575,"ip_address":"","ucode":"C4FBF3F6B51FE3","user_header":"https://static001.geekbang.org/account/avatar/00/11/8a/87/7ad32df9.jpg","comment_is_top":false,"comment_ctime":1539595795,"is_pvip":false,"replies":[{"id":"11871","content":"同学要求太高了，整不来，凑活着看吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539614374,"ip_address":"","comment_id":32511,"utype":1}],"discussion_count":3,"race_medal":0,"score":"27309399571","product_id":100017301,"comment_content":"老师，可不可以将排序章节的示例图，换成动态的图，那样更形象些，还能加深印象","like_count":6,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426800,"discussion_content":"同学要求太高了，整不来，凑活着看吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539614374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1457551,"avatar":"https://static001.geekbang.org/account/avatar/00/16/3d/8f/4d1ffc7f.jpg","nickname":"Geek_麟凤来思","note":"","ucode":"7ADF5585765A42","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1237,"discussion_content":"排序算法总结\nhttps://www.runoob.com/w3cnote/sort-algorithm-summary.html   \n\n十大经典排序算法（内含动态图实现过程）\nhttps://www.runoob.com/w3cnote/ten-sorting-algorithm.html\n\nJava 排序算法分析与实现\nhttps://www.runoob.com/w3cnote/java-sorting-algorithm-analysis-and-implementation.html\n\nPython3实例：页面底部排序算法（内含动态图实现过程）\nhttps://www.runoob.com/python3/python3-examples.html\n","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1562427991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1644333,"avatar":"https://static001.geekbang.org/account/avatar/00/19/17/2d/4eb809fc.jpg","nickname":"nuaadanie","note":"","ucode":"5BAD97A42D4A53","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":233035,"discussion_content":"嗯，动态的图可以参考其他网站的，老师说的都是思想，还是需要自己写代码加深体会，思想如果懂了，其实动态图没必要","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586905914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37476,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1541601480,"is_pvip":false,"replies":[{"id":"13448","content":"我不是解释了嘛 先金额再时间 代码写起来比较麻烦","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541641341,"ip_address":"","comment_id":37476,"utype":1}],"discussion_count":6,"race_medal":0,"score":"23016437960","product_id":100017301,"comment_content":"订单那个题目为什么要先按照订单时间排序，再按照金额呢？我先按照金额，再按订单时间有什么不一样么","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428356,"discussion_content":"我不是解释了嘛 先金额再时间 代码写起来比较麻烦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541641341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1591060,"avatar":"https://static001.geekbang.org/account/avatar/00/18/47/14/255b30fe.jpg","nickname":"Czz","note":"","ucode":"1959FF29F3CE9C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8369,"discussion_content":"因为要求是：对于金额相同的那些订单，需要按照订单时间做升序排序，也就是说，金额的有序度，是基于时间的有序度的。所以，要先按时间排，然后再按金额排！","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1567952005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1592371,"avatar":"","nickname":"Teyana_Mo","note":"","ucode":"31DF518D403409","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109976,"discussion_content":"个人建议,可以结合新增订单来理解.\n1. 先时间后金额,对于新增订单,只需针对与新增订单同一时间段的订单进行比较排序,不需要与其他时间段的订单比较.\n2.若是先金额后时间,对于每次新增订单,都需要先根据金额对所有订单进行比较排序,再根据时间排序.","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1577715592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1185974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/18/b6/f3f68a39.jpg","nickname":"马建华","note":"","ucode":"928189590259AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":10531,"discussion_content":"说的对，如果先按照金额排序，此时金额是有序的，再按照时间排序，就有可能把金额顺序打乱了，比如[0903, 30;0904,30;0903,30;0903,40],先金额排序再时间排序就变成了[0903, 30;0903,30;0903,40;0904,30]","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568294328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1318633,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1e/e9/dcc63d8f.jpg","nickname":"怕什么，抱紧我","note":"","ucode":"CBCEA76E9EF33B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271738,"discussion_content":"题目要求:金额排序优先,然后再按照时间排序! 如果最后时间排序,会影响到金额的排序,需要额外逻辑处理!如果时间优先,影响时间排序的因素只有金额;\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590175392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163364,"discussion_content":"时间和金额都是稳定的话，谁先谁后都一样的。后排的那个都只需要看前者相同的那些项即可。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581073708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72119,"user_name":"小时候可笨了","can_delete":false,"product_type":"c1","uid":1066608,"ip_address":"","ucode":"8F272AD9B33C0C","user_header":"https://static001.geekbang.org/account/avatar/00/10/46/70/e5ae5890.jpg","comment_is_top":false,"comment_ctime":1551524988,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"18731394172","product_id":100017301,"comment_content":"老师，逆序度的公式是怎么得到的啊？想不明白。为啥是n*(n-1)&#47;2","like_count":4,"discussions":[{"author":{"id":1249652,"avatar":"https://static001.geekbang.org/account/avatar/00/13/11/74/72ffa6d6.jpg","nickname":"StayLet","note":"","ucode":"6B748CA3AF3C5B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206725,"discussion_content":"一楼给的应该是等差数列前N 项和公式，这里用高中排列组合中的组合公式来解释应该会比较合适。要做的事情是求 n 个元素的满序度，换成组合概念就是从 n 个元素中选出 2 个元素的组合。根据公式(这里用逗号区分上下标，逗号前为下标，逗号后为上标) Cn,2 = An,2 / A2,2 = An,2 / 2! = n*(n-1)/2","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1584434343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":68858,"discussion_content":"em，你这样数数，前提 完全有序--》即 n个有序的数字\n第一个和后面的n-1个能组成一对，就是n-1；第二个就是n-2, 一直到最后一个是0，即 0+1+2+。。。+n-1 = (n-1)*n/2，这是数学公式  不知道你还记得不\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575220857,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1663660,"avatar":"https://static001.geekbang.org/account/avatar/00/19/62/ac/9fb6c140.jpg","nickname":"利伊奥克儿","note":"","ucode":"2160BEBAD1034D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40618,"discussion_content":"排列组合的充实C(n,2)=n*(n-1)/2","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572245040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1095445,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b7/15/6a2b6b83.jpg","nickname":"董宗磊","note":"","ucode":"D7005A328BC2EE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7151,"discussion_content":"数学中排列组合知识","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567404506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1250807,"avatar":"https://static001.geekbang.org/account/avatar/00/13/15/f7/744720a2.jpg","nickname":"DriveMan_邱佳源","note":"","ucode":"A4C83BF07DEE7A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4720,"discussion_content":"数学公式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565685651,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220661,"user_name":"归零","can_delete":false,"product_type":"c1","uid":1103208,"ip_address":"","ucode":"C99B8E93009A46","user_header":"https://static001.geekbang.org/account/avatar/00/10/d5/68/2201b6b9.jpg","comment_is_top":false,"comment_ctime":1590305603,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14475207491","product_id":100017301,"comment_content":"跟着学习算法大概两周，自从毕业后很少再去刷题了，本次为了跳槽，”不得已“开始进行，有几点体会：<br>1.每道算法题的都要经过这样的过程：大体思路--&gt;边界条件分析--&gt;写出bugfree的代码。(前两步是重点)<br>2.学习算法，对于自己的理解能力，代码编写能力有很大的帮助，是一种比较底层的认知提高，同时还要正确的写出来，又锻炼了动手能力，一举多得，加油！！！","like_count":3},{"had_liked":false,"id":66942,"user_name":"weimin","can_delete":false,"product_type":"c1","uid":1354721,"ip_address":"","ucode":"C94DD3DE451885","user_header":"https://static001.geekbang.org/account/avatar/00/14/ab/e1/14cf564b.jpg","comment_is_top":false,"comment_ctime":1550045227,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14434947115","product_id":100017301,"comment_content":"选择排序Java版<br>\tpublic int[] sort(int[] arr) {<br>\t\tint size = arr.length;<br>\t\tfor(int j = 0; j &lt; size; j++) {<br>\t\t\tint min = arr[j];<br>\t\t\tint index = -1;<br>\t\t\tfor(int i = j+1;i &lt; size;i++) {<br>\t\t\t\tint a = arr[i];<br>\t\t\t\tif(min &gt; a) {<br>\t\t\t\t\tmin = a;<br>\t\t\t\t\tindex = i;<br>\t\t\t\t}<br>\t\t\t}<br>\t\t\tif(index &gt; -1) {<br>\t\t\t\tint tmp = arr[j];<br>\t\t\t\tarr[j] = arr[index];<br>\t\t\t\tarr[index] = tmp;<br>\t\t\t}<br>\t\t}<br>\t\treturn arr;<br>\t}","like_count":3,"discussions":[{"author":{"id":1909502,"avatar":"","nickname":"晴空一鹤","note":"","ucode":"95940CDE56A2FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553217,"discussion_content":"终于刷到你 还好我没放弃","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645770543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":45624,"user_name":"几多不几多","can_delete":false,"product_type":"c1","uid":1326270,"ip_address":"","ucode":"B5021F8D2F2D13","user_header":"https://static001.geekbang.org/account/avatar/00/14/3c/be/2bce7512.jpg","comment_is_top":false,"comment_ctime":1543727270,"is_pvip":false,"replies":[{"id":"16360","content":"n*（n-1）&#47;4对应复杂度的表示就是o（n^2）你可以简单这么理解就好","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543801968,"ip_address":"","comment_id":45624,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14428629158","product_id":100017301,"comment_content":"换句话说，平均情况下，需要 n*(n-1)&#47;4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n2)，所以平均情况下的时间复杂度就是 O(n2)。<br>比较操作肯定要比交换操作多这能懂，复杂度上限是O(n2)也能懂，但是怎么最后那句话怎么就所以上了？ 这里没懂可以解答下吗？谢谢老师","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431126,"discussion_content":"n*（n-1）/4对应复杂度的表示就是o（n^2）你可以简单这么理解就好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543801968,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":68855,"discussion_content":"区间上下限，大O表示法，忽略 系数，常数 和 低阶","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575220522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35826,"user_name":"楓","can_delete":false,"product_type":"c1","uid":1253377,"ip_address":"","ucode":"A9C8DC012EBB1F","user_header":"https://static001.geekbang.org/account/avatar/00/13/20/01/03047a58.jpg","comment_is_top":false,"comment_ctime":1540816766,"is_pvip":false,"replies":[{"id":"12836","content":"你可以自己举个例子 然后debug一下代码 就知道了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540951145,"ip_address":"","comment_id":35826,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14425718654","product_id":100017301,"comment_content":"插入排序的代码对吗？看这个代码，j=0的时候，a[0]的值就没变过，不变又如何排序？你怎么知道他是最小的。（我是菜鸡勿喷）","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427679,"discussion_content":"你可以自己举个例子 然后debug一下代码 就知道了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540951145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34736,"user_name":"Northern","can_delete":false,"product_type":"c1","uid":1060908,"ip_address":"","ucode":"6B8DB4CF385029","user_header":"https://static001.geekbang.org/account/avatar/00/10/30/2c/333d7080.jpg","comment_is_top":false,"comment_ctime":1540275749,"is_pvip":false,"replies":[{"id":"12383","content":"j为什么会是-1呢","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540292425,"ip_address":"","comment_id":34736,"utype":1}],"discussion_count":9,"race_medal":0,"score":"14425177637","product_id":100017301,"comment_content":"a[j+1] = value; &#47;&#47; 插入数据<br>插入排序代码中，移动1时，j会为-1，这样不就下标越界了吗？","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427315,"discussion_content":"j为什么会是-1呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540292425,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1747184,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/a8/f0/529f15e9.jpg","nickname":"第四单元","note":"","ucode":"3ED9D553E1DE17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75801,"discussion_content":"每次循环时j的初始值为i-1，i从1开始循环最小为1，那么j最小为0，不会为-1哦。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575780676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1485515,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/KB4590biaILdggH6ibRibQtlr7p2yONZCfeRK3QM9OSHrwyZrV8oSl5HuOHICl4lQtVoKgpHVydmxQ4peeYPmoIGA/132","nickname":"Chris","note":"","ucode":"712CD86AE8EB81","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4965,"discussion_content":"当前跳出的位置为小于value值得位置，即a[j]的位置，所以应该把value放在a[j]后面一个位置即a[j+1]，该位置的数之前比value大，已经被移向后面一个位置，value正好放在该位置","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565861171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1593141,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/35/7828e961.jpg","nickname":"Geek_20e78b","note":"","ucode":"647D06E867469A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1485515,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/KB4590biaILdggH6ibRibQtlr7p2yONZCfeRK3QM9OSHrwyZrV8oSl5HuOHICl4lQtVoKgpHVydmxQ4peeYPmoIGA/132","nickname":"Chris","note":"","ucode":"712CD86AE8EB81","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":259882,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588827316,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4965,"ip_address":""},"score":259882,"extra":""}]},{"author":{"id":1268797,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5c/3d/e8325811.jpg","nickname":"对白","note":"","ucode":"3183E5ADBC794B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294677,"discussion_content":"因为是从后向前比较元素，j减到-1刚好while循环结束，然后j+1=0位置填上最小值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595953616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1593141,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/35/7828e961.jpg","nickname":"Geek_20e78b","note":"","ucode":"647D06E867469A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":259902,"discussion_content":"由于1=<i<n&amp;&amp;j=i-1，即i不可能为0，所以j不能为-1，j最小只能取到0。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588828608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1147347,"avatar":"https://static001.geekbang.org/account/avatar/00/11/81/d3/f0a88806.jpg","nickname":"🍐 🍾 🔆","note":"","ucode":"1B7C90800AD4D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1593141,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/35/7828e961.jpg","nickname":"Geek_20e78b","note":"","ucode":"647D06E867469A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281742,"discussion_content":"j 当然能减到-1 最后哪个a[j+1] 刚好置回来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591799566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":259902,"ip_address":""},"score":281742,"extra":""}]},{"author":{"id":1593141,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/35/7828e961.jpg","nickname":"Geek_20e78b","note":"","ucode":"647D06E867469A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":259880,"discussion_content":"所谓插入就是在j 与旧的j+1 之间，插入新的j+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588827238,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1116188,"avatar":"https://static001.geekbang.org/account/avatar/00/11/08/1c/ef15e661.jpg","nickname":" 臣馟飞扬","note":"","ucode":"F2F882B7678055","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53108,"discussion_content":"j=-1，那j+1正好就是0了，不会越界哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574133150,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181859,"user_name":"柚子","can_delete":false,"product_type":"c1","uid":1248611,"ip_address":"","ucode":"2F8CC2952E3122","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/63/85f471e2.jpg","comment_is_top":false,"comment_ctime":1582646484,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10172581076","product_id":100017301,"comment_content":"作者讲解的很清晰。作为一个phper。用PHP使用冒泡、插入和系统自带的sort函数对比了下。冒泡性能是最差的，插入会比冒泡好个几倍。自带的sort是性能最好的，好几百倍。下一节学完用快速排序测试下","like_count":2},{"had_liked":false,"id":162973,"user_name":"嗯","can_delete":false,"product_type":"c1","uid":1785226,"ip_address":"","ucode":"F4698EAAF80C76","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTITfQ8KqlVjpQS68xia7gmMcSXjDXgvKF0MUbRBVBqH2w5Ppe7JsR3RImJ5600YaGu27x71fotCbEg/132","comment_is_top":false,"comment_ctime":1576636674,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10166571266","product_id":100017301,"comment_content":"老师，有序度这个公式是怎么推导出来的，","like_count":2,"discussions":[{"author":{"id":1965403,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/fd/5b/0c821fbc.jpg","nickname":"Cshine🌸🌸","note":"","ucode":"D2BEFD692CC1F1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":254227,"discussion_content":"排列组合，n个里面选2个有多少种选法，Cn2","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588301526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":43221,"user_name":"金炜","can_delete":false,"product_type":"c1","uid":1240446,"ip_address":"","ucode":"0CD20149636B94","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/7e/255fb6ee.jpg","comment_is_top":false,"comment_ctime":1543197416,"is_pvip":false,"replies":[{"id":"15601","content":"效率就会比较低了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543285564,"ip_address":"","comment_id":43221,"utype":1}],"discussion_count":5,"race_medal":0,"score":"10133132008","product_id":100017301,"comment_content":"选择排序也可以做成稳定的，选出未排序的最小值，不交换而是放在已排最后 后面依次往后挪一？","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430329,"discussion_content":"效率就会比较低了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543285564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1156074,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a3/ea/53333dd5.jpg","nickname":"HoSalt","note":"","ucode":"610B03E2A002D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":242894,"discussion_content":"这是插入排序的变种了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587488996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1747184,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/a8/f0/529f15e9.jpg","nickname":"第四单元","note":"","ucode":"3ED9D553E1DE17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75803,"discussion_content":"后面依次往后挪一，那这个移动的操作复杂度不就是O(n)吗，再算上选择排序本身的复杂度，整体复杂度不就高达O(n^3)了吗。大家看我分析的对吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575780813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1250807,"avatar":"https://static001.geekbang.org/account/avatar/00/13/15/f7/744720a2.jpg","nickname":"DriveMan_邱佳源","note":"","ucode":"A4C83BF07DEE7A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4722,"discussion_content":"这样的效率比插入排序多了求出最小值的消耗，对吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565685773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1250807,"avatar":"https://static001.geekbang.org/account/avatar/00/13/15/f7/744720a2.jpg","nickname":"DriveMan_邱佳源","note":"","ucode":"A4C83BF07DEE7A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163372,"discussion_content":"多了规避未排序区元素交换而进行的数据迁移，类似在一个有数据数组的第一个位置插一个值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581074584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4722,"ip_address":""},"score":163372,"extra":""}]}]},{"had_liked":false,"id":33994,"user_name":"Kudo","can_delete":false,"product_type":"c1","uid":1036948,"ip_address":"","ucode":"21965914B72AEB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d2/94/8bd217f1.jpg","comment_is_top":false,"comment_ctime":1539941105,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10129875697","product_id":100017301,"comment_content":"Python实现：<br>1.冒泡排序<br>def bubble_sort(ls):<br>    moved = False<br>    for i in range(len(ls)):<br>        for j in range(len(ls)-1-i):<br>            if ls[j] &gt; ls[j+1]:<br>                ls[j], ls[j+1] = ls[j+1], ls[j]<br>                moved = True<br>        if not moved:<br>            break<br>2.插入排序<br>def insertion_sort(ls):<br>    for i in range(1, len(ls)):<br>        element = ls[i]<br>        loc = i - 1<br>        while loc &gt;= 0:<br>            if element &lt; ls[loc]:<br>                ls[loc+1] = ls[loc]<br>                loc = loc - 1<br>            else:<br>                break<br>        ls[loc+1] = element<br>3.选择排序<br>def selection_sort(ls):<br>    for i in range(len(ls)):<br>        min_idx = i<br>        for j in range(i,len(ls)):<br>            if ls[j] &lt; ls[min_idx]:<br>                min_idx = j<br>        ls[i], ls[min_idx] = ls[min_idx], ls[i]","like_count":2,"discussions":[{"author":{"id":1528865,"avatar":"https://static001.geekbang.org/account/avatar/00/17/54/21/aaf74594.jpg","nickname":"Fullmetal Alchemist","note":"","ucode":"4D260084DBC2B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403554,"discussion_content":"moved = False要放在地一层循环里面吧，不然你这样只要交换了一次就一直True了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634107874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1268797,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5c/3d/e8325811.jpg","nickname":"对白","note":"","ucode":"3183E5ADBC794B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294680,"discussion_content":"我发现了几个小错误，一是函数都忘记写return返回值了；二是选择排序的第二个for循环应该是for j in range(i+1,len(ls)):","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595953798,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32776,"user_name":"辰陌","can_delete":false,"product_type":"c1","uid":1245043,"ip_address":"","ucode":"961C874D36C958","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/73/8c64ed7f.jpg","comment_is_top":false,"comment_ctime":1539695979,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10129630571","product_id":100017301,"comment_content":"也写一次留言：三种排序的python代码，欢迎大家提意见啊<br>冒泡：<br>def bubbleSort(a, n):    # a表示数组，n表示数组大小<br>    if n &lt;= 1:return <br>    <br>    for i in range(n):<br>        flag = False<br>        for j in range(n-i-1):<br>            if a[j] &gt; a[j+1]:<br>                a[j], a[j+1] = a[j+1], a[j]<br>                flag = True<br>        if flag == False: break<br><br>插入：<br>def insertionSort(a, n):<br>    if n &lt;= 1: return <br>    <br>    for i in range(1, n):<br>        j = i<br>        while a[j-1] &gt; a[j] and j &gt; 0:<br>            a[j-1], a[j] = a[j], a[j-1]<br>            j -= 1<br><br>选择：<br>def selectionSort(a, n):<br>    for i in range(n-1, 0, -1):<br>        max_j = i<br>        for j in range(i):<br>            if a[j] &gt; a[max_j]:<br>                max_j = j<br>        a[i], a[max_j] = a[max_j], a[i]","like_count":2},{"had_liked":false,"id":32667,"user_name":"董航","can_delete":false,"product_type":"c1","uid":1231787,"ip_address":"","ucode":"9CA208FD26F849","user_header":"https://static001.geekbang.org/account/avatar/00/12/cb/ab/1aac53bf.jpg","comment_is_top":false,"comment_ctime":1539659193,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10129593785","product_id":100017301,"comment_content":"写的好好，希望更新快点，每天地铁一篇，稳稳的，看的很爽","like_count":2},{"had_liked":false,"id":32454,"user_name":"DADDYHINS","can_delete":false,"product_type":"c1","uid":1189131,"ip_address":"","ucode":"C5676EF53CA248","user_header":"https://static001.geekbang.org/account/avatar/00/12/25/0b/f9fc5255.jpg","comment_is_top":false,"comment_ctime":1539577276,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10129511868","product_id":100017301,"comment_content":"链表也能用这三种排序，不涉及随机访问，所以时间复杂度也是一样的吧。🤔","like_count":2},{"had_liked":false,"id":32432,"user_name":"yaya","can_delete":false,"product_type":"c1","uid":1233856,"ip_address":"","ucode":"8C7FAC8F828BA4","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/c0/d38daa2d.jpg","comment_is_top":false,"comment_ctime":1539571212,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10129505804","product_id":100017301,"comment_content":"今天终于明白了为什么会有排序稳定的概念，理解是用于多重key的排序的情况下稳定算法可以转化为对每个key分别一层层排序。<br>作业:可以实现，冒泡排序空间复杂度o(1)，时间复杂度o(n2).插入排序空间复杂度o(1),空间复杂度o(n2).","like_count":2},{"had_liked":false,"id":319561,"user_name":"时不时充充电","can_delete":false,"product_type":"c1","uid":2453902,"ip_address":"","ucode":"F45712325DAE50","user_header":"https://static001.geekbang.org/account/avatar/00/25/71/8e/31458837.jpg","comment_is_top":false,"comment_ctime":1635850271,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5930817567","product_id":100017301,"comment_content":"链表的插入排序算法：<br>&#47;**<br> * Definition for singly-linked list.<br> * struct ListNode {<br> *     int val;<br> *     ListNode *next;<br> *     ListNode() : val(0), next(nullptr) {}<br> *     ListNode(int x) : val(x), next(nullptr) {}<br> *     ListNode(int x, ListNode *next) : val(x), next(next) {}<br> * };<br> *&#47;<br>class Solution {<br>public:<br>    ListNode* insertionSortList(ListNode* head) {<br>        if(!head) return head;<br>        ListNode * dummy = new ListNode(0);<br>        ListNode* cur = head;<br>        while(cur){<br>            ListNode* p = dummy;<br>            while(p-&gt;next){<br>                if(cur-&gt;val &gt;= p-&gt;next-&gt;val){<br>                    p = p-&gt;next;<br>                }<br>                else break;<br>            }<br>            ListNode* node = cur-&gt;next;<br>            cur-&gt;next = p-&gt;next;<br>            p-&gt;next = cur;<br>            cur = node;<br>        }<br>        return dummy-&gt;next;<br>    }<br>};","like_count":1},{"had_liked":false,"id":319218,"user_name":"YX","can_delete":false,"product_type":"c1","uid":2636178,"ip_address":"","ucode":"CC108CCE845EAE","user_header":"https://static001.geekbang.org/account/avatar/00/28/39/92/88ed94f2.jpg","comment_is_top":false,"comment_ctime":1635682596,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5930649892","product_id":100017301,"comment_content":"选择排序：<br>思想：第一次我从整个数组中遍历找 一个最小值，然后把它和arr[0]交换<br><br>​           第二次我从第二个数开始遍历找一个最小值，然后把它和arr[1]交换<br><br>​           。。。。。<br><br>代码：<br>public static void selectSort(int[] arr)  {<br>        &#47;&#47; 要选择排序的次数<br>        for (int i = 0; i &lt; arr.length - 1 ;  i++) {  <br>            int minIndex = i;   &#47;&#47; 最小下标minIndex<br>            int min = arr[i];   &#47;&#47; 最小值min<br>            for (int j = i + 1; j &lt; arr.length ; j++) {<br>                &#47;&#47; 如果当前值比min更小<br>                if (min &gt; arr[j]) {<br>                    min = arr[j];<br>                    minIndex = j;<br>                }<br>            }<br>            &#47;&#47; 循环结束找出了最小值,和arr[i]交换(这里其实可以优化)<br>            int temp = arr[i];<br>            arr[i] = arr[minIndex];<br>            arr[minIndex] = temp;<br>        }<br>    }","like_count":1},{"had_liked":false,"id":239531,"user_name":"looper","can_delete":false,"product_type":"c1","uid":1162159,"ip_address":"","ucode":"899D50A315BCAE","user_header":"https://static001.geekbang.org/account/avatar/00/11/bb/af/2624cc07.jpg","comment_is_top":false,"comment_ctime":1596556397,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5891523693","product_id":100017301,"comment_content":"插入排序也需要一个赋值空间又来存储待插入的值啊，文章里却说“不需要额外的存储空间”","like_count":1,"discussions":[{"author":{"id":2370675,"avatar":"https://static001.geekbang.org/account/avatar/00/24/2c/73/5b7af117.jpg","nickname":"四月的谎言","note":"","ucode":"5A924319D1050E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401110,"discussion_content":"说的应该是不会随着n的变化，空间增加。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633567568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213638,"user_name":"Geek_ac7784","can_delete":false,"product_type":"c1","uid":1981613,"ip_address":"","ucode":"62F0E5E6D6F4BA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/8Dj4ugujXwY24G8pcpgDFGiciarXetG3ItQ4M9mSQMLyRdRRXEXXJVfib48mGUQAu87QcvImwyJIVJlEFeEguV44w/132","comment_is_top":false,"comment_ctime":1588497546,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5883464842","product_id":100017301,"comment_content":"学习感悟：<br>1. 排排序要从执行效率，内存消耗、稳定性三个方面进行分析。<br>2. 对于执行效率的分析：<br>    1. 需要分析最优和最坏的时间复杂度分析方法和对应的情况。平均时间复杂度的分析引入了一个新的概念：逆序度、有序度、满有序度。<br>    2. 不能忽略系数、低阶甚至常数。<br>    3. 比较和交换的次数。<br>3. 一串n个数字，从前往后会形成n(n-1)&#47;2个数据对。如果他们全是有序的，称该情况的有序度为满有序度。逆序度是逆序数对的数量，有序度是有序数对的数量。所以从数量关系上来看，逆序度+有序的=总数对数，也就是满有序度。<br>4. 易知排序算法的交换次数最少为逆序度，而比较次数要看具体情况。但容易理解的是，插入排序和冒泡排序的。最坏情况二者比较次数均为n(n-1)&#47;2次，最好情况比较次数都是n-1次。但是平均情况的分析，用逆序度为n(n-1)&#47;4的情况来分析，二者都是O(n方)<br>5. 插入排序要比冒泡排序少一定的比较次数。最终结果虽然都是O(n方），但是插入排序效果要好一些。<br>6  排序算法三问？空间复杂度(原地排序),，稳定情况，时间复杂度包括三种<br>7. 选择排序-原地排序，一种不稳定的排序方式，时间复杂度都是O(n方）,因为不管好坏，选择排序几乎都经历了一样的过程。<br>8. 细致分析插入排序和冒泡排序：除了之前分析的比较次数外，冒泡排序的交换数据需要三次赋值和一次flag的更新，而插入排序只需要将该位置向后移一位就行了，简单的多<br>9. 综上，插入排序用的多。另外两种几乎可以扔进故纸堆了。<br>链表的排序操作：不考虑更改节点数据，而是改变位置<br>冒泡：比较次数与交换次数不变，但是交换操作更复杂，因为涉及到前后四个结点<br>插入：容易实现一点，甚至不需要移动数据，找到位置直接插。但是寻找插入点得变成从前往后。想法：遍历原链表，一个一个掰下来，插入新的有序链表。需要一个头结点。<br>选择：也容易实现，使用新链表技术，复杂度跟原来一样，几乎是插入排序的另一种思路。一个是找未排序链表的最小值，一个是在排序链表中找正确的位置。比较次数有明显不同。","like_count":1},{"had_liked":false,"id":203200,"user_name":"KID","can_delete":false,"product_type":"c1","uid":1867938,"ip_address":"","ucode":"EE80B7CA7CC2A2","user_header":"https://static001.geekbang.org/account/avatar/00/1c/80/a2/96dcd1fa.jpg","comment_is_top":false,"comment_ctime":1586154871,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5881122167","product_id":100017301,"comment_content":"* 最好、最坏、平均时间复杂度<br>* 同一阶时间复杂度比较时，需要考虑系数、常数、低阶<br>* 基于比较的排序算法，涉及比较元素大小，元素交换移动两种操作<br>* 排序的稳定性，元素大小相同时，不发生移动则是稳定排序<br>* 有序度是数组中具有有序关系的元素对的个数<br>* 逆序度与有序度相反<br>* 完全有序的数组的有序度叫作满有序度<br>* 逆序度 = 满有序度 - 有序度","like_count":1},{"had_liked":false,"id":201813,"user_name":"喻茂","can_delete":false,"product_type":"c1","uid":1318661,"ip_address":"","ucode":"C8BD8086A17365","user_header":"https://static001.geekbang.org/account/avatar/00/14/1f/05/8a06692e.jpg","comment_is_top":false,"comment_ctime":1585839890,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880807186","product_id":100017301,"comment_content":"&lt;?php<br>&#47;&#47; 插入排序<br>function insertSort(&amp;$arr) {<br>\t$arrLen = count($arr);<br>\tif ($arrLen &lt;= 1) return;<br>\t<br>\tfor ($i=1;$i&lt;$arrLen;$i++) {<br>\t\t$value = $arr[$i];<br>\t\t<br>\t\tfor($j=$i-1;$j&gt;=0;$j--) {<br>\t\t\t<br>\t\t\tif ($arr[$j] &gt; $value) {<br>\t\t\t\t$arr[$j+1] = $arr[$j];&#47;&#47; 移动数据<br>\t\t\t} else {<br>\t\t\t\tbreak;<br>\t\t\t}<br>\t\t}<br>\t\t$arr[$j+1] = $value;&#47;&#47; 插入数据<br>\t}<br>}<br><br>$arr1 = [4,5,6,3,2,1];<br><br>insertSort($arr1);<br><br>echo &quot;&lt;pre&gt;&quot;;<br>var_dump($arr1);<br><br><br>&#47;&#47; 冒泡排序<br>function bubbleSort(&amp;$arr) {<br>\t$arrLen = count($arr);<br>\tif ($arrLen &lt;= 1) return;<br>\tfor ($i=0;$i&lt;$arrLen;$i++) {<br>\t\t&#47;&#47; 提前退出冒泡循环标志位<br>\t\t$flag = false;<br>\t\tfor ($j=0;$j&lt;$arrLen-$i-1;$j++) {<br>\t\t\tif ($arr[$j] &gt; $arr[$j+1]) {<br>\t\t\t\t$tmp = $arr[$j];<br>\t\t\t\t$arr[$j] = $arr[$j+1];<br>\t\t\t\t$arr[$j+1] = $tmp;<br>\t\t\t\t$flag = true;<br>\t\t\t}<br>\t\t}<br>\t\tif (!$flag) break;<br>\t}<br>}<br><br>$arr2 = [4,5,6,3,2,1];<br><br>bubbleSort($arr2);<br><br>echo &quot;&lt;pre&gt;&quot;;<br>var_dump($arr2);","like_count":1},{"had_liked":false,"id":194571,"user_name":"SteelHuaSheng","can_delete":false,"product_type":"c1","uid":1396126,"ip_address":"","ucode":"BC8127FC5207FC","user_header":"https://static001.geekbang.org/account/avatar/00/15/4d/9e/04ec08bf.jpg","comment_is_top":false,"comment_ctime":1585068412,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5880035708","product_id":100017301,"comment_content":"第一遍直接看懵逼了。我要多看两遍，仔细研究一下。。。&#47;🤦‍♀️","like_count":1},{"had_liked":false,"id":170844,"user_name":"Vicent🍀","can_delete":false,"product_type":"c1","uid":1589894,"ip_address":"","ucode":"70AEA72A0B6F0E","user_header":"https://static001.geekbang.org/account/avatar/00/18/42/86/6b2e81ba.jpg","comment_is_top":false,"comment_ctime":1578738315,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5873705611","product_id":100017301,"comment_content":"您好，老师，我做了测试，如果冒泡排序不做无位置交换的优化，冒泡计算效率确实没有插入排序快。但是如果加入了冒泡的优化，冒泡排序的效率就会很高，所以我有两个疑问：如果冒泡优化的效率提升这么明显，一般的编程语言实现难道没有加这个优化吗？实际使用中需要去考虑冒泡的这种优化提升吗？","like_count":1},{"had_liked":false,"id":156658,"user_name":"Geek_9314a4","can_delete":false,"product_type":"c1","uid":1703491,"ip_address":"","ucode":"5B82556BA95DCE","user_header":"https://static001.geekbang.org/account/avatar/00/19/fe/43/2483b90b.jpg","comment_is_top":false,"comment_ctime":1574931909,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5869899205","product_id":100017301,"comment_content":"老师好，关于for循环中的自增，我知道都一样但习惯来说不都是i++吗为啥您每次都是++i呢？","like_count":1,"discussions":[{"author":{"id":1588966,"avatar":"https://static001.geekbang.org/account/avatar/00/18/3e/e6/138c4772.jpg","nickname":"这个bug不耐撕","note":"","ucode":"6823864F574259","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299367,"discussion_content":"for循环中++i 和 i++ 的区别\n根据上面的for循环的语法定义 ++i 和 i++的结果是一样的，都要等代码块执行完毕才能执行语句3，但是性能是不同的。在大量数据的时候++i的性能要比i++的性能好原因：\n\ni++由于是在使用当前值之后再+1，所以需要一个临时的变量来转存。\n\n而++i则是在直接+1，省去了对内存的操作的环节，相对而言能够提高性能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597667165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150003,"user_name":"2018","can_delete":false,"product_type":"c1","uid":1107371,"ip_address":"","ucode":"4C2CD47AD70177","user_header":"https://static001.geekbang.org/account/avatar/00/10/e5/ab/6fab2492.jpg","comment_is_top":false,"comment_ctime":1573443236,"is_pvip":true,"discussion_count":4,"race_medal":0,"score":"5868410532","product_id":100017301,"comment_content":"看了老师的选择排序的代码，感觉不需要那么复杂，每次冲无序区选出的最小的值肯定比上次从无序区选出的最小值要大，所以直接放在当前有序区的最后就好了，代码实现如下：<br><br>public int[] selectSort(int[] nums) {<br>        if (nums.length == 1) {<br>            return nums;<br>        }<br>        for (int i = 0, len = nums.length; i &lt; len; i++) {<br>            int min = nums[i];<br>            for (int j = i; j &lt; len - 1; j++) {<br>                min = Math.min(nums[j], min);<br>            }<br>            nums[i] = min;<br>        }<br>        return nums;<br>    }","like_count":1,"discussions":[{"author":{"id":1609223,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8e/07/8d364c7f.jpg","nickname":"fanxi","note":"","ucode":"106331FA6B0FD0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56190,"discussion_content":"只有nums[i] = min; 你这样把nums[i]之前的值弄丢了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574437875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1965403,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/fd/5b/0c821fbc.jpg","nickname":"Cshine🌸🌸","note":"","ucode":"D2BEFD692CC1F1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":254232,"discussion_content":"按你这个方法，应该还需要移动很多次，时间复杂度就上去了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588301904,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1686409,"avatar":"https://static001.geekbang.org/account/avatar/00/19/bb/89/c080540d.jpg","nickname":"红桃K-","note":"","ucode":"2B6B71EEF1F07F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":178651,"discussion_content":"你这思想可以说是插入排序的思想了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582185384,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1107371,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e5/ab/6fab2492.jpg","nickname":"2018","note":"","ucode":"4C2CD47AD70177","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56331,"discussion_content":"前面的代码中已经把第i个位置的值取出来并且已经放到正确的位置了，你说的这个操作只是把选出来的值放到i的位置","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574474297,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141780,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1571223640,"is_pvip":false,"replies":[{"id":"54903","content":"这个java本身的预编译有关系的，你调整下冒泡和插入代码的执行顺序看看","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1571360121,"ip_address":"","comment_id":141780,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5866190936","product_id":100017301,"comment_content":"按照下面的代码运行，时间冒泡是1026 ，插入是65 差别这么大？我的计算过程是不是有问题。<br> public static void main(String[] args) {<br><br>        &#47;&#47; 冒泡排序<br>        sort_bubble s = new sort_bubble();<br>        &#47;&#47; 插入排序：<br>        sort_insert s1 = new sort_insert();<br>        <br>        <br>        &#47;&#47; 准备要排序的数组。随机生成10000个数组，每个数组包含200个元素。分别测试冒泡和插入排序算法的时间。<br>        int num = 10000;<br>        int count = 200;<br>        int seed = 2000;<br>        Random random = new Random();<br>        int[][] src = new int[num][count];<br>        for (int i = 0; i &lt; num; i++) {<br>            int[] arr = new int[count];<br>            for (int j = 0; j &lt;count; j++){<br>                arr[j] = random.nextInt(seed);<br>            }<br>            src[i] = arr;<br>        }<br><br>       <br>        &#47;&#47;拷贝一份数组<br>        int[][] mao = new int[num][count];<br>        for(int i=0;i&lt;num;i++){<br>            int[]arr = new int[count];<br>            for(int j=0;j&lt;count;j++){<br>                arr[j] = src[i][j];<br>            }<br>            mao[i] = arr;<br>        }<br>        &#47;&#47;冒泡排序<br>        long startMao = System.currentTimeMillis();<br>        for(int i=0;i&lt;num;i++){<br>            s.sort_final(mao[i], count);    <br>        }<br>        long endMao = System.currentTimeMillis();<br>        &#47;&#47;计算时间<br>        long dtime = endMao - startMao;<br>        System.out.println(&quot;冒泡时间:&quot;+dtime);<br><br><br>        &#47;&#47;拷贝一份数组<br>        int[][] cha = new int[num][count];<br>        for(int i=0;i&lt;num;i++){<br>            int[]arr = new int[count];<br>            for(int j=0;j&lt;count;j++){<br>                arr[j] = src[i][j];<br>            }<br>            cha[i] = arr;<br>        }<br>        &#47;&#47;插入排序<br>        long startCha = System.currentTimeMillis();<br>        for(int i=0;i&lt;num;i++){<br>            s1.sort(cha[i], count);<br>        }<br>        long endCha = System.currentTimeMillis();<br>        &#47;&#47;计算时间<br>        long dtimec = endCha - startCha;<br>        System.out.println(&quot;插入时间:&quot;+dtimec);<br><br><br>    }","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470886,"discussion_content":"这个java本身的预编译有关系的，你调整下冒泡和插入代码的执行顺序看看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571360121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103292,"user_name":"🐬🐬🐬","can_delete":false,"product_type":"c1","uid":1155214,"ip_address":"","ucode":"6585F8B8ADC43E","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/8e/919dee01.jpg","comment_is_top":false,"comment_ctime":1560410230,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5855377526","product_id":100017301,"comment_content":"js版本代码实现：<br>const bubbleSort = (arr) =&gt; {<br>    let n = arr.length<br>    if (n &lt;= 1) return arr<br>    for (let i = 0; i &lt; n; i++) {<br>        let flag = false<br>        for (let s = 0; s &lt; (n - i - 1); s++) { &#47;&#47; 每次冒泡完成后，最后面就多一个元素在正确的位置，这部分不需要再排序，比如：第一次冒泡是0个已排序，需要n次排序，第二次冒泡已有一个排序，需要n-1,第s次冒泡需要n-s-1次<br>            if (arr[s] &gt; arr[s + 1]) { &#47;&#47; 交换位置<br>                let temp = arr[s]<br>                arr[s] = arr[s + 1]<br>                arr[s + 1] = temp<br>                flag = true<br>            }<br>        }<br><br>        if (!flag) {<br>            return arr<br>        }<br>    }<br>}<br><br>const insertionSort = (arr) =&gt; {<br>    let n = arr.length<br>    if (n &lt;= 1) return arr<br>    for (let i = 1; i &lt; n; i++) { &#47;&#47; 从第二个数开始作为无序数组一次插入有序数组<br>        let value = arr[i] &#47;&#47; 记录插入值<br>        let s = i-1 &#47;&#47; 有序数组最大索引 <br>        for(; s&gt;=0; s--) { &#47;&#47; 从后向前依次遍历有序数组 <br>            if (value &lt; arr[s]) { &#47;&#47; 插入值小于有序数组某值 则空出此位置，并向后移动数据<br>                arr[s+1] = arr[s]<br>            } else { &#47;&#47; 与插入值比较大于时则跳出循环（因为是有序数组，没必要继续向前比较）<br>                break;<br>            }<br>        }<br>        arr[s+1] = value<br>    }<br>    return arr<br>}<br><br>const selectionSort = (arr) =&gt; {<br>    let n = arr.length<br>    if(n&lt;=1) return arr<br>    for(let i =0;i&lt;n;i++) {<br>        let min = i &#47;&#47; 最小值索引，初始赋值第一个<br>        for (let s = i + 1; s &lt; n; s++) { &#47;&#47; 未排序数组中找到最小值索引<br>            if (arr[s] &lt; arr[min]) {<br>                min = s<br>            }<br>        }<br>        &#47;&#47; 从头依次赋值<br>        if(arr[i] &gt; arr[min]) { &#47;&#47; 将最小值与头部对应位置交换<br>            let temp = arr[i]<br>            arr[i] = arr[min]<br>            arr[min] = temp<br>        }<br>    }<br>    return arr<br>}<br>","like_count":1,"discussions":[{"author":{"id":1505981,"avatar":"https://static001.geekbang.org/account/avatar/00/16/fa/bd/7bf33188.jpg","nickname":"Masami","note":"","ucode":"73E03F53335DBC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73440,"discussion_content":"本来看老师代码没明白，看到你的 n - i - 1 这个代码的注解让我一下子明白了，感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575559520,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89491,"user_name":"衬衫的价格是19美元","can_delete":false,"product_type":"c1","uid":1397631,"ip_address":"","ucode":"655F925451F772","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKVUskibDnhMt5MCIJ8227HWkeg2wEEyewps8GuWhWaY5fy7Ya56bu2ktMlxdla3K29Wqia9efCkWaQ/132","comment_is_top":false,"comment_ctime":1556184926,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5851152222","product_id":100017301,"comment_content":"订单排序的问题可否用加权评分实现，socre = timestamp*10^10 + money&#47;10^5，根据score排序，时间复杂度O(n)","like_count":1},{"had_liked":false,"id":54360,"user_name":"kingcall","can_delete":false,"product_type":"c1","uid":1056982,"ip_address":"","ucode":"508884DC684B5B","user_header":"https://static001.geekbang.org/account/avatar/00/10/20/d6/b9513db0.jpg","comment_is_top":false,"comment_ctime":1545834719,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5840802015","product_id":100017301,"comment_content":"选择排序，每次在未排序的元素里面定位最小元素时间，不用等于，就只有大于或者小于不就稳定了吗？","like_count":1,"discussions":[{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":68859,"discussion_content":"em 老师不是举例子了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575220908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":47794,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1233546,"ip_address":"","ucode":"84925F8DEE79CA","user_header":"https://static001.geekbang.org/account/avatar/00/12/d2/8a/57dcd0c7.jpg","comment_is_top":false,"comment_ctime":1544198581,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5839165877","product_id":100017301,"comment_content":"鏈連插入排序的比較次數和數組實現的，真的一致嗎？","like_count":1,"discussions":[{"author":{"id":1773278,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/0e/de/58e87ee4.jpg","nickname":"德鲁大叔","note":"","ucode":"DEF7B044BB756A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":93253,"discussion_content":"我觉得链表比较次数应该是数组的2倍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576917181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":38715,"user_name":"不飞鸟","can_delete":false,"product_type":"c1","uid":1149571,"ip_address":"","ucode":"EF27C925DDD83A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8a/83/f3430d01.jpg","comment_is_top":false,"comment_ctime":1542113454,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5837080750","product_id":100017301,"comment_content":"为啥感觉选择排序未排序区最小值放到未排序区第一个位置，先依次后移再放置可以是稳定的，要是用交换方法就不稳定了","like_count":1,"discussions":[{"author":{"id":1686409,"avatar":"https://static001.geekbang.org/account/avatar/00/19/bb/89/c080540d.jpg","nickname":"红桃K-","note":"","ucode":"2B6B71EEF1F07F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":177660,"discussion_content":"放在第一个位置，未排序区其他数据要从末尾开始一次向后搬移一位，这样的话就不叫选择排序了，这可以说是插入排序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582118113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32659,"user_name":"Mr.Panda","can_delete":false,"product_type":"c1","uid":1238864,"ip_address":"","ucode":"655A3013B5E849","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/50/d476ed6c.jpg","comment_is_top":false,"comment_ctime":1539657943,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5834625239","product_id":100017301,"comment_content":"Java实现选择排序<br>public class SelectionSort {<br>\t<br>\tpublic static void sort(int[] arr) {<br>\t\tif(arr.length&lt;=1)<br>\t\t\treturn;<br>\t\t<br>\t\tfor(int i=0;i&lt;arr.length-1;i++) {<br>\t\t\tint min_index = i;&#47;&#47;标记最小元素索引<br>\t\t\tint j = i+1;<br>\t\t\tfor(;j&lt;arr.length;j++) {<br>\t\t\t\tif (arr[min_index]&gt;arr[j]) {<br>\t\t\t\t\tmin_index = j;<br>\t\t\t\t}<br>\t\t\t}<br>\t\t\t&#47;&#47;交换未排序区间：最小数与首位互换位置<br>\t\t\tint v = arr[i];<br>\t\t\tarr[i] = arr[min_index];<br>\t\t\tarr[min_index] = v;<br>\t\t}<br>\t}<br>\t<br>\tpublic static void main(String[] args) {<br>\t\tint[] arr = {6,1,3,4,2};<br>\t\tSelectionSort.sort(arr);<br>\t\tfor(int i:arr) {<br>\t\t\tSystem.out.print(i + &quot; &quot;);<br>\t\t}<br>\t}<br>}","like_count":1},{"had_liked":false,"id":32534,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1539604264,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5834571560","product_id":100017301,"comment_content":"我觉得 冒泡和插入选择排序都可以用链表实现，他们排序时的结束条件为达到尾结点<br>                    最好时间复杂度                   最坏时间复杂度               平均时间复杂度<br>冒泡:                   O(1)                                        O(n²)                              O(n²)<br>插入:                   O(n)                                        O(n²)                              O(n)(因为不涉及移动)<br>选择:                   O(n²)                                         O(n²)                             O(n²)<br>感觉时间复杂度分析好难啊 尤其是平均时间分析<br>","like_count":1},{"had_liked":false,"id":32531,"user_name":"后端进阶","can_delete":false,"product_type":"c1","uid":1125656,"ip_address":"","ucode":"480F48F5378307","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/18/918eaecf.jpg","comment_is_top":false,"comment_ctime":1539603525,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5834570821","product_id":100017301,"comment_content":"选择排序算法：<br><br>public static void selectionSort(int[] array, int n) {<br>        if (n &lt;= 1) {<br>            return;<br>        }<br>        for (int i = 0; i &lt; n - 1; i++) {<br>            int min = array[i];<br>            int j = i + 1;<br>            &#47;&#47; 找到未排序区最小元素下标<br>            int flag = i;<br>            for (; j &lt; n; j++) {<br>                if (array[j] &lt; min) {<br>                    flag = j;<br>                }<br>            }<br><br>            &#47;&#47; 交换<br>            if (flag != i) {<br>                int tmp = array[i];<br>                array[i] = array[flag];<br>                array[flag] = tmp;<br>            }<br>        }<br>    }","like_count":1},{"had_liked":false,"id":32417,"user_name":"大可可","can_delete":false,"product_type":"c1","uid":1186458,"ip_address":"","ucode":"BC635013E7B87E","user_header":"https://static001.geekbang.org/account/avatar/00/12/1a/9a/7b246eb1.jpg","comment_is_top":false,"comment_ctime":1539567540,"is_pvip":false,"replies":[{"id":"11878","content":"第六次自己跟自己比较 你也可以说是5次","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539615135,"ip_address":"","comment_id":32417,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5834534836","product_id":100017301,"comment_content":"冒泡6个数5次不就能排好么","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426765,"discussion_content":"第六次自己跟自己比较 你也可以说是5次","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539615135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32399,"user_name":"凉粉","can_delete":false,"product_type":"c1","uid":1131111,"ip_address":"","ucode":"DD1280BD703948","user_header":"https://static001.geekbang.org/account/avatar/00/11/42/67/b96b843f.jpg","comment_is_top":false,"comment_ctime":1539564802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5834532098","product_id":100017301,"comment_content":"re:没写错啊 你觉得应该怎么写呢<br><br>如果写在循环外面，只能是初始数组直接是有序才能用，写在第一个for开头好像更好。","like_count":1},{"had_liked":false,"id":360365,"user_name":"貳木","can_delete":false,"product_type":"c1","uid":2522833,"ip_address":"四川","ucode":"614891641AF72D","user_header":"https://static001.geekbang.org/account/avatar/00/26/7e/d1/77a2cb85.jpg","comment_is_top":false,"comment_ctime":1666503069,"is_pvip":false,"discussion_count":0,"race_medal":3,"score":"1666503069","product_id":100017301,"comment_content":"选择排序不是稳定的排序算法，是因为“交换位置”，不是相对位置改变，就不是稳定的了。","like_count":0},{"had_liked":false,"id":358350,"user_name":"111","can_delete":false,"product_type":"c1","uid":3109487,"ip_address":"北京","ucode":"D6E8E83A118A3E","user_header":"https://static001.geekbang.org/account/avatar/00/2f/72/6f/44c10658.jpg","comment_is_top":false,"comment_ctime":1664240626,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664240626","product_id":100017301,"comment_content":"总结：<br>评价排序算法：<br>1. 是否稳定<br>2. 是否原地<br>3. 时间复杂度<br>改成链表，插入排序的插入会进一步得到优化","like_count":0},{"had_liked":false,"id":355603,"user_name":"一敬","can_delete":false,"product_type":"c1","uid":1136721,"ip_address":"中国台湾","ucode":"5ED541DD7FE728","user_header":"https://static001.geekbang.org/account/avatar/00/11/58/51/fc457d4e.jpg","comment_is_top":false,"comment_ctime":1661528113,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661528113","product_id":100017301,"comment_content":"1. 冒泡排序和选择排序的原理相似，都是找最小（或最大）的元素放到最前面（或最后面），他们的区别在于如何去把最小（或最大）的元素放在最前面（或最后面）。<br>冒泡是通过比较一次交换一次位置的方式慢慢的把元素移到前面（或后面），而选择排序是找到最小或最大的直接与最前面（或最后面）的元素交换位置。<br>2. 插入排序和选择排序原理不同实现方式相似，都是分已排序和未排序区域，从未排序中选择一个元素添加到已排序区域。不同点是，插入排序是从未排序中随意选择一个元素在通过冒泡方式加入到已排序区域，选择排序是从未排序中选择最小（或最大的）直接插入到已排序的区域。","like_count":0},{"had_liked":false,"id":340918,"user_name":"吕超","can_delete":false,"product_type":"c1","uid":1740409,"ip_address":"","ucode":"B36883984BE16B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/8e/79/f9d5dd3a.jpg","comment_is_top":false,"comment_ctime":1649229781,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649229781","product_id":100017301,"comment_content":"关于选择排序，文中的代码用的是用非排序区的最小元素与非排序区的第一个元素交换，所以造成了排序不稳定。但是如果把非排序区的最小元素放到非排序区第一位，同时，最小元素原始位置之前的非排序区元素向后移动一位的话，就可以保证排序稳定了。不过这样会增加元素移动次数（从4次到12次），也变成了另一种插入排序。<br><br>换句话说，选择排序以牺牲了稳定性为代价，大大减少了交换次数，在不追求稳定性的场景下，也是高效的排序算法。","like_count":0},{"had_liked":false,"id":336805,"user_name":"谭雪娇","can_delete":false,"product_type":"c1","uid":1375252,"ip_address":"","ucode":"B20AB23E0D20E0","user_header":"https://static001.geekbang.org/account/avatar/00/14/fc/14/b6b50f91.jpg","comment_is_top":false,"comment_ctime":1646377618,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646377618","product_id":100017301,"comment_content":"力扣88. 练习三种排序<br>1.冒泡：<br>&#47;**<br> * @param {number[]}  nums1,nums2<br> * @param {number} m,n<br> * @return {void} Do not return anything, modify nums1 in-place instead.<br> *&#47;<br>var merge = function(nums1, m, nums2, n) {<br>    for(let i =0; i &lt; n; i++){<br>        nums1[m +i] = nums2[i]<br>    }<br>    for(let j=0;j &lt; nums1.length;j++){<br>        let flag = false<br>        for(let k = 0; k &lt; nums1.length-j-1; k++){<br>            if(nums1[k]&gt; nums1[k+1]){<br>                let temp = nums1[k+1]<br>                nums1[k+1] = nums1[k]<br>                nums1[k] = temp<br>                flag = true<br>            }<br>        }<br>        if(!flag) break<br>    }<br>};<br>2，插入<br>var merge = function(nums1, m, nums2, n) {<br>    for(let i =0; i &lt; n; i++){<br>        nums1[m +i] = nums2[i]<br>    }<br>    for(let j=1;j &lt; nums1.length;++j){<br>        let value = nums1[j]<br>        let k=j - 1<br>        for(; k &gt;=0; --k){<br>            if(value &lt; nums1[k]){<br>                nums1[k+1] = nums1[k]<br>            }else {<br>                break<br>            }<br>        }<br>        nums1[k+1] = value<br>    }<br>};<br>3.快速<br>var merge = function (nums1, m, nums2, n) {<br>      for (let i = 0; i &lt; n; i++) {<br>        nums1[m + i] = nums2[i]<br>      }<br>      for (let k = 0; k &lt; nums1.length; k++) {<br>        let minValue = nums1[k]<br>        for (let j = k; j &lt; nums1.length; j++) {<br>          if (nums1[j] &lt; minValue) {<br>            minValue = nums1[j]<br>            nums1[j] = nums1[k]<br>            nums1[k] = minValue<br>          }<br>        }<br>      }<br>    };","like_count":0},{"had_liked":false,"id":336432,"user_name":"Today","can_delete":false,"product_type":"c1","uid":1235000,"ip_address":"","ucode":"4FA397F0BD8C6E","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/38/41027bda.jpg","comment_is_top":false,"comment_ctime":1646143322,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646143322","product_id":100017301,"comment_content":"学习到了三种经典的排序算法:<br>1. 冒泡排序: 每次通过相邻元素比较和交换得到一个元素的正确位置, 平均时间复杂度是 O(n^2), 通过分析平均逆序度 = 满序度O(n^2) - 有序度 得出。<br>它是一种稳定的原地排序算法; 效率仅次于插入排序。<br><br>2. 插入排序: 从未排序区间中依次取出每个数, 在已排序区间中找到合适的位置进行插入, 保证已排序区间使用有序.。<br>它的特点是可以动态地保证数组始终有序。<br>平均时间复杂度也是 O(n^2), 因为每移动一次就减少了一个逆序度, 它也是一种稳定的原地排序算法;  由于没有交换操作所以效率会比冒泡更高。<br><br>3. 选择排序:  每次从未排序区间中找到一个最小值放到已排序区间的末尾；<br>平均时间复杂度是 O(n^2);  它是一种不稳定的排序算法，因为最小值和前面的数进行交换破坏了稳定性，效率比较低。<br><br>三种排序算法在链表中依然可以使用， 链表也可以遍历，通过改变值 和 指针位置进行交换 和 移动，时间复杂没有改变。<br>插入排序在链表排序中的做法是：用尾指针记录有序区间的末尾节点， 用 prev 指针记录要比较节点的前一个节点 （默认是 dummyHead）,  用 cur 指针记录无序区间的第一个节点位置，遍历一遍把 cur 记录的节点放到合适的位置 （维持有序区间的末尾节点可以优化效率） ","like_count":0},{"had_liked":false,"id":335965,"user_name":"Geek_nasus","can_delete":false,"product_type":"c1","uid":2887043,"ip_address":"","ucode":"2F595A9B594E89","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotSA4LJMicQu5ibpVtGFSTQqK6z8jaZ0fuEehjyKjoWyvyT9eUzdYjOhGIYdxcj9kNWK6cO14TlNjw/132","comment_is_top":false,"comment_ctime":1645793250,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1645793250","product_id":100017301,"comment_content":"写的go语言版冒泡和插入<br><br>&#47;&#47;冒泡正排序<br>func BubbleSort(a []int) []int {<br>\tif len(a) &lt; 2 {<br>\t\treturn a<br>\t}<br>\tfor i := 0; i &lt; len(a)-1; i++ {<br>\t\tflag := false<br>\t\tfor j := i + 1; j &lt; len(a); j++ {<br>\t\t\tif a[i] &gt; a[j] {<br>\t\t\t\ta[i], a[j] = a[j], a[i]<br>\t\t\t\tflag = true<br>\t\t\t}<br>\t\t}<br>\t\tif !flag {<br>\t\t\tbreak<br>\t\t}<br>\t}<br>\treturn a<br>}<br><br>&#47;&#47;插入排序<br>func InsertionSort(a []int) []int {<br>    if len(a) &lt; 2 {<br>\t\treturn a<br>\t}<br>\tfor i := 1; i &lt; len(a); i++ {<br>\t\tfor j := i; j &gt; 0; j-- {<br>\t\t\tif a[j] &lt; a[j-1] {<br>\t\t\t\ta[j], a[j-1] = a[j-1], a[j]<br>\t\t\t} else {<br>\t\t\t\tbreak<br>\t\t\t}<br>\t\t}<br>\t}<br>\treturn a<br>}","like_count":0},{"had_liked":false,"id":329811,"user_name":"康","can_delete":false,"product_type":"c1","uid":1454534,"ip_address":"","ucode":"4B1D729C903D1F","user_header":"https://static001.geekbang.org/account/avatar/00/16/31/c6/f08d1ac5.jpg","comment_is_top":false,"comment_ctime":1641547204,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641547204","product_id":100017301,"comment_content":"插入排序中的一句代码：<br> a[j+1] = value; &#47;&#47; 插入数据<br><br>应该是：<br>a[j] = value; ","like_count":0},{"had_liked":false,"id":328412,"user_name":"heart_east","can_delete":false,"product_type":"c1","uid":2002553,"ip_address":"","ucode":"FEB4457C0B43F3","user_header":"https://static001.geekbang.org/account/avatar/00/1e/8e/79/c36da38a.jpg","comment_is_top":false,"comment_ctime":1640707505,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640707505","product_id":100017301,"comment_content":"我觉得冒泡排序多冒了一次，这个冒泡排序，图中6个数，5次冒泡不就可以了吗？n个数字，n-1次冒泡就可以了","like_count":0},{"had_liked":false,"id":328007,"user_name":"刘亚辉","can_delete":false,"product_type":"c1","uid":1520163,"ip_address":"","ucode":"60CD2FF352BED9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/icHicAP9M4M4ALsKr6vgLW7FNTmmBJGcvicg9QiamucYpNfupwZYrPicgeK73KNw0rgNuwnJdgLfSzkQ34ibfltZYUbQ/132","comment_is_top":false,"comment_ctime":1640447131,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640447131","product_id":100017301,"comment_content":"一直不太明白，插入排序的时候，明明是把a[j]向后移了，为什么在插入数据的时候把value插入到a[j+1]位置了？","like_count":0},{"had_liked":false,"id":323682,"user_name":"。。","can_delete":false,"product_type":"c1","uid":2853618,"ip_address":"","ucode":"A52A6043D27D87","user_header":"https://static001.geekbang.org/account/avatar/00/2b/8a/f2/6c6f7886.jpg","comment_is_top":false,"comment_ctime":1638092668,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638092668","product_id":100017301,"comment_content":"我有个问题不太明白，对于插入排序，如果在查找有序区间的时候，通过二分法来查找插入元素要插入的位置，然后将该位置后的有序区间的元素向后移动，再将插入元素插入进来，感觉这样会稍微快一点点，不知道这种想法对不对，如果对的话，它的时间复杂度有该如何分析呢？","like_count":0},{"had_liked":false,"id":323360,"user_name":"海","can_delete":false,"product_type":"c1","uid":2434444,"ip_address":"","ucode":"59457FA0A6E934","user_header":"https://static001.geekbang.org/account/avatar/00/25/25/8c/066a5b4e.jpg","comment_is_top":false,"comment_ctime":1637854255,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637854255","product_id":100017301,"comment_content":"这两种排序速度让我想起了CSAPP第三版封面那个图","like_count":0},{"had_liked":false,"id":322287,"user_name":"Geek_e9a05e","can_delete":false,"product_type":"c1","uid":2835263,"ip_address":"","ucode":"32E1804CE6364D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/zUZMSvia9ByR2YbkeB9T4oymlzDCEsxUb4xPUNo39xgehdF0uqtWBRz5avLI3U5vS0XWVEKNWDpFtFib6s9v5kNA/132","comment_is_top":false,"comment_ctime":1637290819,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1637290819","product_id":100017301,"comment_content":"正常来说，对于相同逆序度的冒泡和插入，插入效率更高，但是冒泡排序是存在优化情况的，优化代码下具体的执行效率也不能说一定会比插入排序慢吧","like_count":0},{"had_liked":false,"id":320651,"user_name":"々向日葵ミ","can_delete":false,"product_type":"c1","uid":1252202,"ip_address":"","ucode":"2425FBCEE8916D","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/6a/4482b2b6.jpg","comment_is_top":false,"comment_ctime":1636438605,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636438605","product_id":100017301,"comment_content":"冒泡排序代码有问题吧？flag=false不能直接break吧，后面的数据也许不是有序的呢？","like_count":0},{"had_liked":false,"id":317284,"user_name":"付伟","can_delete":false,"product_type":"c1","uid":1397649,"ip_address":"","ucode":"97DC8054E30D97","user_header":"https://static001.geekbang.org/account/avatar/00/15/53/91/5a160371.jpg","comment_is_top":false,"comment_ctime":1634732355,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634732355","product_id":100017301,"comment_content":"把插入排序实现了一遍，发现还有点卡壳，需要多练习练习","like_count":0},{"had_liked":false,"id":314434,"user_name":"俯瞰风景.","can_delete":false,"product_type":"c1","uid":1044166,"ip_address":"","ucode":"A6DB68B7B84AEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/c6/bebcbcf0.jpg","comment_is_top":false,"comment_ctime":1633051795,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633051795","product_id":100017301,"comment_content":"对非满有序度的序列进行排序，必然要涉及到元素交换或者数据挪移。排序的基本操作就是比较大小和数据交换(挪移)。如果要求原地排序，就要保证数据的流向是朝着一个方向就行的，选择排序之所以不是原地排序，是因为同一个数据节点可以朝两个方向流动，这就可能打破最初的序列。<br><br>设计排序算法的关键是，让每一个数据在比较的过程中明确自己位置，然后再移动到自己的位置上去。<br><br>对于排序算法，有序度是固定的，所以数据交换(移动)的次数是固定的。而优化的方向是：比较操作尽可能少、赋值操作尽可能少。<br><br>对比冒泡和插入，冒泡的数据交换和插入的数据移动次数都等于逆序度，是一样的，数据比较次数也是是一样的。不过插入的数据移动只需要赋值一次，而冒泡的数据交换却需要赋值三次。【移动比交换更加高效】","like_count":0},{"had_liked":false,"id":314183,"user_name":"林蓝","can_delete":false,"product_type":"c1","uid":2340552,"ip_address":"","ucode":"36E4445613E1C3","user_header":"https://static001.geekbang.org/account/avatar/00/23/b6/c8/35948bf5.jpg","comment_is_top":false,"comment_ctime":1632888659,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632888659","product_id":100017301,"comment_content":"性能测试那块，我用python实现了一下，发现不是三倍关系，而是二倍关系，是因为python中交换两个数的值，a, b = b, a 只用到了两次赋值操作。","like_count":0},{"had_liked":false,"id":311113,"user_name":"易早","can_delete":false,"product_type":"c1","uid":1227817,"ip_address":"","ucode":"007BF7BC6BCE96","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3KNMHFkH73hWpk4ENqmu2q6KB8Ia9dic8Xsf4PFM4Cu8898BKgKX2KLELbwbIDPMiakshdlQ7w1Zjia5mdRhOo4eA/132","comment_is_top":false,"comment_ctime":1631073447,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631073447","product_id":100017301,"comment_content":"这一节感觉内容有点多了，准备多刷几次","like_count":0},{"had_liked":false,"id":308701,"user_name":"李叶","can_delete":false,"product_type":"c1","uid":1470449,"ip_address":"","ucode":"41B33FA8526E48","user_header":"https://static001.geekbang.org/account/avatar/00/16/6f/f1/35f9f16f.jpg","comment_is_top":false,"comment_ctime":1629762922,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629762922","product_id":100017301,"comment_content":"冒泡排序：比较相邻选择，将最大值放到最后；插入排序，取第一个值为有序区间，从无序区间依次取值，然后与有序区间比较插入；选择排序：每次从无序区间获取最小值，插入有序区间末位。","like_count":0},{"had_liked":false,"id":307159,"user_name":"Juniper","can_delete":false,"product_type":"c1","uid":1174794,"ip_address":"","ucode":"1BC24554034BD3","user_header":"https://static001.geekbang.org/account/avatar/00/11/ed/0a/18201290.jpg","comment_is_top":false,"comment_ctime":1628913054,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628913054","product_id":100017301,"comment_content":"看着老师的讲解，自己把选择排序写出来了，开心","like_count":0},{"had_liked":false,"id":306769,"user_name":"百川","can_delete":false,"product_type":"c1","uid":2015066,"ip_address":"","ucode":"BCC9D224C09CD6","user_header":"https://static001.geekbang.org/account/avatar/00/1e/bf/5a/824a5e46.jpg","comment_is_top":false,"comment_ctime":1628694098,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628694098","product_id":100017301,"comment_content":"冒泡排序的第一个循环，条件 i &lt; n,是不是 i&lt; n-1 就行了","like_count":0},{"had_liked":false,"id":304279,"user_name":"cosz3","can_delete":false,"product_type":"c1","uid":1218665,"ip_address":"","ucode":"B9023D4A088CF2","user_header":"https://static001.geekbang.org/account/avatar/00/12/98/69/5a1c6620.jpg","comment_is_top":false,"comment_ctime":1627312472,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627312472","product_id":100017301,"comment_content":"自己瞎编了一个这样的插入排序，对照了一下争哥的还是，争哥写地好<br>```<br>def insert_sort(a):<br>    length = len(a)<br>    if length &lt;= 1:<br>        return<br>    i = 1<br><br>    while(i &lt; length):<br>        j = 0<br>        while(j &lt; i):<br>            if a[i] &lt; a[j]:<br>                for x in range(j, i+1):<br>                    tmp = a[x]<br>                    a[x] = a[i]<br>                    a[i] = tmp<br>                break<br>            j += 1<br>        i += 1<br>```","like_count":0},{"had_liked":false,"id":304090,"user_name":"Geek_edffd3","can_delete":false,"product_type":"c1","uid":2269984,"ip_address":"","ucode":"F61990464F2282","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/1sWUKJBuJdvOPCbp0FAwy43bxOSZ4pUazvv3icb4bcpm2Of8gFluJhyhVuIkIv3eSiaico8umibUrloz9POiapCV3Tw/132","comment_is_top":false,"comment_ctime":1627228600,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627228600","product_id":100017301,"comment_content":"冒泡排序是在无序组中比较和交换，而插入排序是在有序组中比较和交换，选择排序是在无序组中比较，在有序组中交换。本质上，交换的次数就是逆序数。","like_count":0},{"had_liked":false,"id":290961,"user_name":"双木公子","can_delete":false,"product_type":"c1","uid":1116567,"ip_address":"","ucode":"751885864D3AB7","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/97/4314e2d8.jpg","comment_is_top":false,"comment_ctime":1619880031,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619880031","product_id":100017301,"comment_content":"算法整理过程见：https:&#47;&#47;blog.csdn.net&#47;BruceLee1314&#47;article&#47;details&#47;116333499?spm=1001.2014.3001.5501","like_count":0},{"had_liked":false,"id":290800,"user_name":"Lin","can_delete":false,"product_type":"c1","uid":2582519,"ip_address":"","ucode":"91D1ADD33E4C2E","user_header":"https://static001.geekbang.org/account/avatar/00/27/67/f7/1fdcacac.jpg","comment_is_top":false,"comment_ctime":1619755011,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619755011","product_id":100017301,"comment_content":"<br>&#47;&#47; 插入排序，a表示数组，n表示数组大小<br>public void insertionSort(int[] a, int n) {<br>  if (n &lt;= 1) return;<br><br>  for (int i = 1; i &lt; n-1; ++i) {<br>    int value = a[i];<br>    int j = i - 1;<br>    &#47;&#47; 查找插入的位置<br>    for (; j &gt;= 0; --j) {<br>      if (a[j] &gt; value) {<br>        a[j+1] = a[j];  &#47;&#47; 数据移动<br>      } else {<br>        break;<br>      }<br>    }<br>    a[j+1] = value; &#47;&#47; 插入数据<br>  }<br>}<br><br>冒泡排序最外层的for 循环条件还可以修改为 n-1 ,减少一次循环，因为最后一次循环的时候就只剩一个数了，不知道这样修改对不对，有没有小伙伴一起来讨论下","like_count":0},{"had_liked":false,"id":288962,"user_name":"张知信","can_delete":false,"product_type":"c1","uid":2144474,"ip_address":"","ucode":"7C896BB3214B3D","user_header":"https://static001.geekbang.org/account/avatar/00/20/b8/da/42284f64.jpg","comment_is_top":false,"comment_ctime":1618799892,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618799892","product_id":100017301,"comment_content":"排序算法的执行效率。1. 最好情况、最坏情况、平均情况时间复杂度；2. 时间复杂度的系数、常数 、低阶；3. 比较次数和交换（或移动）次数。<br>排序算法的内存消耗。原地排序，空间复杂度为O(1)。<br>排序算法的稳定性。<br>冒泡排序。只会比较两个相邻的元素。原地排序，稳定，最好O(n)，最坏O(n2)，平均O(n2)。<br>逆序度 = 满有序度 - 有序度。<br>插入排序。每次往已排序区间插入，并保持有序。原地排序，稳定，最好O(n)，最坏O(n2)，平均O(n2)。<br>选择排序。每次从未排序区间选择最小的，放到有序区间最后。原地排序，不稳定，最好O(n2)，最坏O(n2)，平均O(n2)。<br>冒泡、插入、选择排序用于链表的时间、空间复杂度？空间复杂度O(1)。时间复杂度，没有明显变化。","like_count":0},{"had_liked":false,"id":285049,"user_name":"徐志超-Klaus","can_delete":false,"product_type":"c1","uid":2343086,"ip_address":"","ucode":"CF26B39965F2A2","user_header":"https://static001.geekbang.org/account/avatar/00/23/c0/ae/e5e62510.jpg","comment_is_top":false,"comment_ctime":1616592024,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616592024","product_id":100017301,"comment_content":"当我准备做笔记的时候，发现整片文章没有一句废话，结构完美，完全没有需要我整理和归纳的地方，如果我理解了，并把这三个排序写出来了，可以直接复制到我的笔记里吗？","like_count":0},{"had_liked":false,"id":284788,"user_name":"Del皮耶罗","can_delete":false,"product_type":"c1","uid":1326223,"ip_address":"","ucode":"E90D6311ED875F","user_header":"https://static001.geekbang.org/account/avatar/00/14/3c/8f/be719404.jpg","comment_is_top":false,"comment_ctime":1616471191,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616471191","product_id":100017301,"comment_content":"感觉插入排序比冒泡排序快的原因，是不是插入排序的内层循环不会每次都遍历到头，而冒泡排序是完整地遍历了两层","like_count":0},{"had_liked":false,"id":284406,"user_name":"Boom clap!!!","can_delete":false,"product_type":"c1","uid":2443427,"ip_address":"","ucode":"E9AF8ECB963239","user_header":"https://static001.geekbang.org/account/avatar/00/25/48/a3/2df11999.jpg","comment_is_top":false,"comment_ctime":1616230651,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1616230651","product_id":100017301,"comment_content":"1.能<br>2.冒泡排序 最好是o(n），最坏是o（n2），平均是o(n)<br>3.插入排序 。都是o(1)<br>4.选择:","like_count":0},{"had_liked":false,"id":284254,"user_name":"Wheat","can_delete":false,"product_type":"c1","uid":1260141,"ip_address":"","ucode":"7D99EA149B6DE8","user_header":"https://static001.geekbang.org/account/avatar/00/13/3a/6d/910b2445.jpg","comment_is_top":false,"comment_ctime":1616142001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616142001","product_id":100017301,"comment_content":"看图是直接插，实际上还是相邻元素比较交换","like_count":0},{"had_liked":false,"id":283079,"user_name":"肖云雷","can_delete":false,"product_type":"c1","uid":1021910,"ip_address":"","ucode":"8ACC80251A7288","user_header":"https://static001.geekbang.org/account/avatar/00/0f/97/d6/679ac894.jpg","comment_is_top":false,"comment_ctime":1615539953,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615539953","product_id":100017301,"comment_content":"C 语言写出选择排序的实现<br>void selectionSort(int *arr, int n) {<br>    if (n &lt; 2) {<br>        return;<br>    }<br>    for (int i = 0; i &lt; n ; i++) {<br>        int min = i;<br>        for (int j = i; j &lt; n; j++) {<br>            if (arr[min] &gt; arr[j]) {<br>                min = j;<br>            }<br>        }<br>        int value = arr[min];<br>        arr[min] = arr[i];<br>        arr[i] = value;<br>    }<br>}","like_count":0},{"had_liked":false,"id":282461,"user_name":"zzzzzc","can_delete":false,"product_type":"c1","uid":2322244,"ip_address":"","ucode":"9F58C0BD30E300","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/mxxEd3scP7RUgoh9oXWqUZDU5fIabDIh0ALAcvGZy4GXJYiazicd2ARGodujqU77fbGHatPyZMdVSQ04Y0qNDWaA/132","comment_is_top":false,"comment_ctime":1615262272,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615262272","product_id":100017301,"comment_content":"1、对于时间复杂度不是一个量级的算法，如果样本有一定规模（数组大或者使用频率高），肯定是时间复杂度低的好，除非你的n很小、算法不常用；对于同一时间复杂度的算法，由于时间复杂度的衡量是忽略了常量的，所以整体上常量小的算法更优。<br>2、如果用链表的话，选择排序是稳定的。选择排序是遍历未排序部分，顺序放入已排序队尾，插入排序是顺序取未排序队首，遍历已排序部分再插入，所以时间复杂度即便考虑常量整体上也应该是一样的","like_count":0},{"had_liked":false,"id":281092,"user_name":"八九","can_delete":false,"product_type":"c1","uid":1191617,"ip_address":"","ucode":"B996A884BFA474","user_header":"https://static001.geekbang.org/account/avatar/00/12/2e/c1/0fcd29ab.jpg","comment_is_top":false,"comment_ctime":1614580812,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614580812","product_id":100017301,"comment_content":"笔记(下)：<br>7.插入排序（Insertion Sort）<br>将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。<br>插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。<br>对于不同的查找插入点方法（从头到尾、从尾到头），元素的比较次数是有区别的。但对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度。<br>1).插入排序是原地排序算法<br>插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)<br>2).插入排序是稳定的排序算法<br>在插入排序中，对于值相同的元素，可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变。<br>3).插入排序的时间复杂度是多少？<br>如果要排序的数据已经是有序的，我们并不需要搬移任何数据。<br>如果我们从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为 O(n)。注意，这里是从尾到头遍历已经有序的数据。<br>如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为 O(n2)。<br>在数组中插入一个数据的平均时间复杂度是 O(n)。所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度为 O(n2)。<br><br>8.选择排序（Selection Sort）<br>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。<br>1).选择排序是原地排序算法<br>选择排序空间复杂度为 O(1),最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n^2)。<br>2).选择排序是不稳定的排序算法<br>选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。<br><br>9.冒泡排序和插入排序的时间复杂度都是 O(n2)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？<br>冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。<br>但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要3个赋值操作，而插入排序只需要1个。<br>我们把执行一个赋值语句的时间粗略地计为单位时间（unit_time），然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序。<br>用冒泡排序，需要K次交换操作，每次需要3个赋值语句，所以交换操作总耗时就是3*K单位时间。而插入排序中数据移动操作只需要K个单位时间。<br>所以，虽然冒泡排序和插入排序在时间复杂度上是一样的，都是 O(n2)，但是如果我们希望把性能优化做到极致，那肯定首选插入排序。<br><br>10.上面的三种排序算法，都是基于数组实现的。如果数据存储在链表中，那相应的时间、空间复杂度又是多少呢？(评论：双木公子)<br>一般而言，考虑只能改变节点位置，冒泡排序相比于数组实现，比较次数一致，但交换时操作更复杂；<br>插入排序，比较次数一致，不需要再有后移操作，找到位置后可以直接插入，但排序完毕后可能需要倒置链表；<br>选择排序比较次数一致，交换操作同样比较麻烦。<br>综上，时间复杂度和空间复杂度并无明显变化，若追求极致性能，冒泡排序的时间复杂度系数会变大，插入排序系数会减小，选择排序无明显变化。<br>","like_count":0},{"had_liked":false,"id":281091,"user_name":"八九","can_delete":false,"product_type":"c1","uid":1191617,"ip_address":"","ucode":"B996A884BFA474","user_header":"https://static001.geekbang.org/account/avatar/00/12/2e/c1/0fcd29ab.jpg","comment_is_top":false,"comment_ctime":1614580798,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614580798","product_id":100017301,"comment_content":"笔记(上)：<br>1.常用排序：<br>O(n^2)：冒泡排序、插入排序、选择排序 (本篇)<br>O(nlogn)：归并排序、快速排序<br>O(n)：计数排序、基数排序、桶排序<br><br>2.排序算法的执行效率<br>1).最好情况、最坏情况、平均情况时间复杂度<br>在分析排序算法的时间复杂度时，还要分析原始数据是什么样的。因为排序算法的性能受原始数据的有序性影响。<br>2).时间复杂度的系数、常数 、低阶<br>时间复杂度反映的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。<br>但是实际的软件开发中，在对同一阶时间复杂度的排序算法性能对比的时候，就要把系数、常数、低阶也考虑进来。<br>3).比较次数和交换（或移动）次数<br>基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。<br>所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。<br><br>3.排序算法的内存消耗<br>算法的内存消耗可以通过空间复杂度来衡量。引入一个新的概念，原地排序（Sorted in place）。<br>原地排序算法，就是特指空间复杂度是O(1)的排序算法。<br><br>4.排序算法的稳定性<br>稳定性这个概念是说，如果待排序的序列中存在“值相等”的元素，经过排序之后，相等元素之间原有的前后顺序不变（不变：稳定的排序算法；变了：不稳定的排序算法）。<br>算法稳定性的用处：多次排序中，下一次排序需要依赖上一次排序的稳定结果。<br>例子：按照金额从小到大对订单数据排序。对于金额相同的订单，按照下单时间从早到晚有序。<br>先按照下单时间给订单排序，注意是按照下单时间，不是金额。排序完成之后，用稳定排序算法，按照订单金额重新排序。<br><br>5.冒泡排序（Bubble Sort）<br>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。<br>一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。<br>冒泡优化：当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。<br>1).冒泡排序是原地排序算法<br>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)。<br>2).冒泡排序是稳定的排序算法<br>当有相邻的两个元素大小相等的时候，不做交换，相同大小的数据在排序前后不会改变顺序。<br>3).冒泡排序的时间复杂度是多少？<br>最好情况：O(n),原始数据有序，一次冒泡即可。(1,2,3,4,5)<br>最坏情况：O(n2),原始数据倒序，需要进行n次冒泡。(5,4,3,2,1)<br>平均情况：O(n2)<br><br>6.逆序度 = 满有序度 - 有序度<br>【有序度】是数组中具有有序关系的元素对的个数。(有序元素对：a[i] &lt;= a[j], 如果i &lt; j)<br>【满有序度】是完全有序的数组。<br>【逆序度】的定义正好跟有序度相反（默认从小到大为有序，逆序元素对：a[i] &gt; a[j], 如果i &lt; j）<br>我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。<br>冒泡排序包含两个操作原子，比较和交换。每交换一次，有序度就加 1。不管算法怎么改进，交换次数总是确定的，即为逆序度，也就是n*(n-1)&#47;2–初始有序度。<br>例子：原始数据(4,5,6,3,2,1)，其中有序元素对有(4,5)(4,6)(5,6)，所以有序度是3。n=6，所以排序完成之后终态的满有序度为 n*(n-1)&#47;2=15。交换次数就是15–3=12<br>对于包含n个数据的数组进行冒泡排序，平均交换次数是多少呢？<br>最坏情况下，初始状态的有序度是 0，需要进行 n*(n-1)&#47;2 次交换。<br>最好情况下，初始状态的有序度是 n*(n-1)&#47;2，不需要进行交换。<br>我们可以取个中间值 n*(n-1)&#47;4，来表示初始有序度既不是很高也不是很低的平均情况。<br>换句话说，平均情况下，需要 n*(n-1)&#47;4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n2)，所以平均情况下的时间复杂度就是 O(n2)。<br>","like_count":0},{"had_liked":false,"id":281085,"user_name":"八九","can_delete":false,"product_type":"c1","uid":1191617,"ip_address":"","ucode":"B996A884BFA474","user_header":"https://static001.geekbang.org/account/avatar/00/12/2e/c1/0fcd29ab.jpg","comment_is_top":false,"comment_ctime":1614579349,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614579349","product_id":100017301,"comment_content":"java版本- 冒泡排序和插入排序性能对比：插入排序效率更高<br>&#47;&#47;10000个随机元素的数组进行排序<br>    static void bubbleVsInsertion() {<br>        int[] arr = new int[10000];<br>        long start = System.currentTimeMillis();<br>        for (int i = 0; i &lt; 10000; i++) {<br>            arr[i] = new Random().nextInt(10000);<br>        }<br>        arr = insertionSortTail(arr);&#47;&#47;Run Time:42(ms)、55(ms)<br>        &#47;&#47;arr = bubbleSort(arr);&#47;&#47;Run Time:320(ms)、425(ms)<br>        long end = System.currentTimeMillis();<br>        System.out.println(Arrays.toString(arr));<br>        System.out.println(&quot;start time:&quot; + start + &quot;; end time:&quot; + end + &quot;; Run Time:&quot; + (end - start) + &quot;(ms)&quot;);<br>    }<br>","like_count":0},{"had_liked":false,"id":281084,"user_name":"八九","can_delete":false,"product_type":"c1","uid":1191617,"ip_address":"","ucode":"B996A884BFA474","user_header":"https://static001.geekbang.org/account/avatar/00/12/2e/c1/0fcd29ab.jpg","comment_is_top":false,"comment_ctime":1614579255,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614579255","product_id":100017301,"comment_content":"java版本-插入排序<br>    static int[] insertionSortHead(int[] arr) {<br>        &#47;*插入排序-从头到尾:将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。<br>        插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。<br>        重复这个过程，直到未排序区间中元素为空，算法结束。<br>        * 4, 6, 5, 3, 2, 1<br>        * 4 5 6 3 2 1 （6换5）<br>        * 3 4 5 6 2 1 （4换3，5换4，6换5）<br>        * 2 3 4 5 6 1 （3换2换，4换3，5换4，6换5）<br>        * 1 2 3 4 5 6 （2换1换，3换2，4换3，5换4，6换5）<br>        * *&#47;<br>        for (int i = 1; i &lt; arr.length; i++) {<br>            for (int j = 0; j &lt; i; j++) {<br>                if (arr[i] &lt; arr[j]) {<br>                    int temp = arr[j];<br>                    arr[j] = arr[i];<br>                    arr[i] = temp;<br>                    System.out.println(&quot;i=&quot; + i + &quot;:&quot; + arr[i] + &quot;与&quot; + arr[j] + &quot;互换&quot;);<br>                }<br>            }<br>        }<br>        return arr;<br>    }<br><br>    static int[] insertionSortTail(int[] arr) {<br>        &#47;*插入排序-从尾到头:从有序区的最后一个元素开始往回一个一个比较<br>         * 4 5 6 1 3 2<br>         * 1 4 5 6 3 2 （1换6,1换5,1换4）<br>         * 1 3 4 5 6 2 （3换6,3换5,3换4）<br>         * 1 2 3 4 5 6 （2换6,2换5,2换4,2换3）<br>         * *&#47;<br>        for (int i = 1; i &lt; arr.length; i++) {<br>            int val = arr[i];<br>            int index = i - 1;<br>            &#47;&#47;查找插入的位置<br>            for (; index &gt;= 0; index--) {<br>                if (arr[index] &gt; val) {<br>                    arr[index + 1] = arr[index];&#47;&#47;数据移动<br>                } else {<br>                    break;<br>                }<br>            }<br>            arr[index + 1] = val;&#47;&#47;插入数据<br>        }<br>        return arr;<br>    }<br>","like_count":0},{"had_liked":false,"id":281083,"user_name":"八九","can_delete":false,"product_type":"c1","uid":1191617,"ip_address":"","ucode":"B996A884BFA474","user_header":"https://static001.geekbang.org/account/avatar/00/12/2e/c1/0fcd29ab.jpg","comment_is_top":false,"comment_ctime":1614579189,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614579189","product_id":100017301,"comment_content":"java版本：冒泡排序及选择排序<br>&#47;&#47;冒泡排序<br>    static int[] bubbleSort(int[] arr) {<br>        int num = 0;<br>        for (int i = 0; i &lt; arr.length; i++) {&#47;&#47;比较次数<br>            &#47;&#47; 提前退出冒泡循环的标志位<br>            boolean flag = false;<br>            for (int j = 0; j &lt; arr.length - i - 1; j++) {&#47;&#47;两两相比<br>                if (arr[j] &gt; arr[j + 1]) {&#47;&#47;交换值<br>                    int temp = arr[j + 1];<br>                    arr[j + 1] = arr[j];<br>                    arr[j] = temp;<br>                    flag = true; &#47;&#47; 表示有数据交换<br>                    num++;<br>                }<br>            }<br>            if (!flag) {&#47;&#47; 没有数据交换，提前退出<br>                break;<br>            }<br>        }<br>        System.out.println(&quot;交换次数：&quot; + num);<br>        &#47;*交换次数即为逆序度，逆序度 = 满有序度 - 有序度，满有序度为n*(n-1)&#47;2<br>【有序度】是数组中具有有序关系的元素对的个数。(有序元素对：a[i] &lt;= a[j], 如果i &lt; j)<br>【满有序度】是完全有序的数组。<br>【逆序度】的定义正好跟有序度相反（默认从小到大为有序，逆序元素对：a[i] &gt; a[j], 如果i &lt; j）*&#47;<br>        return arr;<br>    }<br><br>    static int[] selectionSort(int[] arr) {<br>        &#47;*选择排序-循环每个元素，与其他元素比对，找出最小元素进行交换。<br>         * 4, 6, 5, 3, 2, 1<br>         * 1 6 5 3 2 4 （1换4）<br>         * 1 2 5 3 6 4 （2换6）<br>         * 1 2 3 5 6 4 （3换5）<br>         * 1 2 3 4 6 5 （4换5）<br>         * 1 2 3 4 5 6 （5换6）<br>         * *&#47;<br>        for (int i = 0; i &lt; arr.length - 1; i++) {<br>            int minIndex = i;<br>            for (int j = i + 1; j &lt; arr.length; j++) {<br>                if (arr[j] &lt; arr[minIndex]) {&#47;&#47;找出最小元素<br>                    minIndex = j;<br>                }<br>            }<br>            int temp = arr[i];&#47;&#47;交换<br>            arr[i] = arr[minIndex];<br>            arr[minIndex] = temp;<br>        }<br>        return arr;<br>    }<br>","like_count":0},{"had_liked":false,"id":280901,"user_name":"独行者","can_delete":false,"product_type":"c1","uid":1336769,"ip_address":"","ucode":"49AD61CF6D886D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erPvJ4mY2qE37iaoY7RQ7r9M3f7Xws6XHT9fSjwXxagR0F6icb7ZUBDDbsWIRyRnVdfichtAXQxP8goQ/132","comment_is_top":false,"comment_ctime":1614474656,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614474656","product_id":100017301,"comment_content":"感谢老师的讲解，特别是关于平均时间的计算，通俗易懂，可以让初学者理解。","like_count":0},{"had_liked":false,"id":280511,"user_name":"罗耀龙@坐忘","can_delete":false,"product_type":"c1","uid":1917663,"ip_address":"","ucode":"3CEA258DE7F3C7","user_header":"https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg","comment_is_top":false,"comment_ctime":1614238233,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1614238233","product_id":100017301,"comment_content":"茶艺师学编程<br><br>思考题<br>感觉应该能，在不修改值的情况下，修改指针的操作O（1）,但在遍历上的花销反而更多了，总体下来，感觉3种排序换成链表后的总的花销没多大变化。","like_count":0},{"had_liked":false,"id":278447,"user_name":"骑着驴读着书的谢小夕","can_delete":false,"product_type":"c1","uid":1625340,"ip_address":"","ucode":"56F0A469B630A2","user_header":"https://static001.geekbang.org/account/avatar/00/18/cc/fc/92646317.jpg","comment_is_top":false,"comment_ctime":1612945149,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612945149","product_id":100017301,"comment_content":"若使用 链表 代替数组实现， 冒泡排序 和 选择排序 都有 swap 操作， 会变得复杂。","like_count":0},{"had_liked":false,"id":277513,"user_name":"进化菌","can_delete":false,"product_type":"c1","uid":1276861,"ip_address":"","ucode":"B30A5F78BB4171","user_header":"https://static001.geekbang.org/account/avatar/00/13/7b/bd/ccb37425.jpg","comment_is_top":false,"comment_ctime":1612438776,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1612438776","product_id":100017301,"comment_content":"补充一下 PHP 代码，如果换成这样，是不是选择排序就算是稳定排序了呢？<br>function selection_sort($arr)<br>{<br>    $arr_length = count($arr);<br>    if (!is_array($arr) || 0 === $arr_length) {<br>        return [];<br>    }<br><br>    for ($i = 0; $i &lt; $arr_length; $i++) {<br>        $min= $i;<br>        for ($j = $i + 1; $j &lt; $arr_length; $j++) {<br>            if ($arr[$j] &lt; $arr[$min]) {<br>                $min = $j;<br>            }<br>        }<br>        if ($min != $i) {<br>            &#47;&#47; 方式：交换位置<br>            &#47;*$temp = $arr[$i];<br>            $arr[$i] = $arr[$min];<br>            $arr[$min] = $temp;*&#47;<br><br>            &#47;&#47; 方式：插入位置<br>            $temp = $arr[$min];<br>            for ($t = $min - 1; $t &gt;= 0; --$t) {<br>                if ($arr[$t] &lt;= $temp) {<br>                    break;<br>                }<br>                $arr[$t+1] = $arr[$t];<br>            }<br>            $arr[$i] = $temp;<br>        }<br>    }<br><br>    return $arr;<br>}","like_count":0},{"had_liked":false,"id":277511,"user_name":"进化菌","can_delete":false,"product_type":"c1","uid":1276861,"ip_address":"","ucode":"B30A5F78BB4171","user_header":"https://static001.geekbang.org/account/avatar/00/13/7b/bd/ccb37425.jpg","comment_is_top":false,"comment_ctime":1612437404,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1612437404","product_id":100017301,"comment_content":"有点小疑问：选择排序为啥一定要把未排序区的最小值跟未排序区的第一个值交换位置呢？是因为不交换需要移动未排序区位置变得更复杂，还是因为定义如此呢？","like_count":0},{"had_liked":false,"id":276543,"user_name":"xxx","can_delete":false,"product_type":"c1","uid":1356978,"ip_address":"","ucode":"E78B1F15BC10F7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIcLjatV3GHdibZXCTIgL1X2A7jpByIeLH3Zyia8KXdT4JRcicmVSgq5ekRHCFCFenMqicsAwaWYibHkTw/132","comment_is_top":false,"comment_ctime":1611996143,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611996143","product_id":100017301,"comment_content":"冒泡排序是遍历N次，每次相邻元素进行两两比较和交换。<br>插入排序是将数据分成有序和无序两部分，每次从无序序列中取出第一个，从有序序列列尾开始比较，如果需要插入的话，则将当前数据后移。<br>选择排序是遍历N次，每次从后部分数据中找出元素最小的数，和当前数据交换。","like_count":0},{"had_liked":false,"id":276047,"user_name":"😘Hong","can_delete":false,"product_type":"c1","uid":1122746,"ip_address":"","ucode":"0EEDEDC8F12E60","user_header":"https://static001.geekbang.org/account/avatar/00/11/21/ba/176cd91d.jpg","comment_is_top":false,"comment_ctime":1611757829,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611757829","product_id":100017301,"comment_content":"看着懂了，也会敲了，过了两天又忘记了，怎么办。","like_count":0},{"had_liked":false,"id":274420,"user_name":"Jason.li","can_delete":false,"product_type":"c1","uid":2353767,"ip_address":"","ucode":"A7C99173BC1C06","user_header":"https://static001.geekbang.org/account/avatar/00/23/ea/67/9f3ca37c.jpg","comment_is_top":false,"comment_ctime":1611018237,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611018237","product_id":100017301,"comment_content":"<br>1、冒泡排序，单链表可以搞定，复杂度o(n*n)<br>2、插入排序，单链表表可以搞定，复杂度o(n*n), 省去了移动数据得到操作<br>3、选择排序，最好用双链表，复杂度o(n*n)","like_count":0},{"had_liked":false,"id":273826,"user_name":"kevin","can_delete":false,"product_type":"c1","uid":2217714,"ip_address":"","ucode":"DEE2032A6C48D6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erBWCaFC3KbRDpjxMEhgZJFGo0q1twv9gicsUF5Qmu57X3bVt4wn1GV5ibhL2xlrGDuza7HhDiaMdxEg/132","comment_is_top":false,"comment_ctime":1610690512,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610690512","product_id":100017301,"comment_content":"void InsertSort(int *a, int len)<br>{<br>\tif (len &lt;= 1)<br>\t{<br>\t\treturn;<br>\t}<br><br>\tfor (int i = 1;i &lt; len; ++i)<br>\t{<br>\t\tint value = a[i];<br>\t\tint j = i -1;<br>\t\tfor(;j &gt;= 0; --j)<br>\t\t{<br>\t\t\tif (a[j] &gt; value)<br>\t\t\t{<br>\t\t\t\ta[j + 1] = a[j];<br>\t\t\t}<br>\t\t\telse<br>\t\t\t{<br>\t\t\t\tbreak;<br>\t\t\t}<br>\t\t}<br><br>\t\ta[j + 1] = value;<br>\t}<br>}<br><br>void BubbleSort(int *a, int len)<br>{<br>\tif (len &lt;= 1)<br>\t{<br>\t\treturn;<br>\t}<br><br>\tfor(int i = 0;i &lt; len;++i)<br>\t{<br>\t\tbool flag = false;<br>\t\tfor(int j = 0; j &lt; len - i - 1 ; ++j)<br>\t\t{<br>\t\t\tif (a[j+1] &lt; a[j])<br>\t\t\t{<br>\t\t\t\tint temp = a[j];<br>\t\t\t\ta[j] = a[j+1];<br>\t\t\t\ta[j+1] = temp;<br>\t\t\t\tflag = true;<br>\t\t\t}<br>\t\t}<br><br>\t\tif (!flag)<br>\t\t{<br>\t\t\tbreak;<br>\t\t}<br>\t}<br>}","like_count":0},{"had_liked":false,"id":273755,"user_name":"xxx","can_delete":false,"product_type":"c1","uid":1356978,"ip_address":"","ucode":"E78B1F15BC10F7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIcLjatV3GHdibZXCTIgL1X2A7jpByIeLH3Zyia8KXdT4JRcicmVSgq5ekRHCFCFenMqicsAwaWYibHkTw/132","comment_is_top":false,"comment_ctime":1610671438,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610671438","product_id":100017301,"comment_content":"关于最好情况和最坏情况复杂度，以及平均时间复杂度这几个概念看过不少了，但还是不习惯用这种方式去分析，可能是脑子太懒了吧。","like_count":0},{"had_liked":false,"id":272890,"user_name":"hzy115","can_delete":false,"product_type":"c1","uid":1412497,"ip_address":"","ucode":"7AD5A955640248","user_header":"https://static001.geekbang.org/account/avatar/00/15/8d/91/b58aa132.jpg","comment_is_top":false,"comment_ctime":1610347758,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610347758","product_id":100017301,"comment_content":"插入排序的typescript版本有点问题<br>第45行代码 应该将array[j + 1]改为temp。","like_count":0},{"had_liked":false,"id":271498,"user_name":"今天明天🚗","can_delete":false,"product_type":"c1","uid":2155648,"ip_address":"","ucode":"D087C216CFF5BA","user_header":"https://static001.geekbang.org/account/avatar/00/20/e4/80/bfc5e2d9.jpg","comment_is_top":false,"comment_ctime":1609667009,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609667009","product_id":100017301,"comment_content":" for (int i = intArray.Length - 2; i &gt;= 0; i--)<br>            {<br>                int value = intArray[i];<br>                int j = i + 1;&#47;&#47;数组末尾<br>                for (; j &lt;= intArray.Length - 1; j++)<br>                {<br>                    if (intArray[j] &lt; value)<br>                    {<br>                        intArray[j-1] = intArray[j];<br>                    }<br>                    else<br>                    {<br>                        break;<br>                    }<br>                }<br>                intArray[j-1] = value;<br>            }","like_count":0},{"had_liked":false,"id":270133,"user_name":"陌.寒哲","can_delete":false,"product_type":"c1","uid":1147711,"ip_address":"","ucode":"B7079FF211D712","user_header":"https://static001.geekbang.org/account/avatar/00/11/83/3f/bc2ea80d.jpg","comment_is_top":false,"comment_ctime":1608947771,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608947771","product_id":100017301,"comment_content":"插入排序进一步减少代码的写法，go版本<br>\tfor i := 0;i&lt; len(array); i ++ {<br>\t\tfor k := i;k&gt; 0 &amp;&amp; array[k] &lt; array[k-1]; k-- {<br>\t\t\tarray[k],array[k-1] = array[k-1], array[k]<br>\t\t}<br>\t}","like_count":0},{"had_liked":false,"id":270129,"user_name":"陌.寒哲","can_delete":false,"product_type":"c1","uid":1147711,"ip_address":"","ucode":"B7079FF211D712","user_header":"https://static001.geekbang.org/account/avatar/00/11/83/3f/bc2ea80d.jpg","comment_is_top":false,"comment_ctime":1608946966,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608946966","product_id":100017301,"comment_content":"我认为插入排序的代码中那个j放在内层for循环的外面定义，并且在内层for循环结束以后再把a[j+1] = value; 这样没有意义，直接在for循环里就能全部完成啊，有人知道为什么那样写吗?<br>我的go版本<br>\tfor i := 0;i&lt; len(array); i ++ {<br>\t\tvalue := array[i]<br>\t\tfor k := i;k&gt; 0; k-- {<br>\t\t\tif array[k-1]&lt;value {<br>\t\t\t\tbreak<br>\t\t\t}else{<br>\t\t\t\tarray[k],array[k-1] = array[k-1], array[k]<br>\t\t\t}<br>\t\t}<br>\t}<br><br>还写了javascript版本<br>\tfor (var i = 0; i &lt; array.length; i++) {<br>\t\tvar value = array[i]<br>\t\t<br>\t\tfor(var k = i ; k &gt; 0; k --){<br>\t\t\tif (array[k-1] &lt; value){<br>\t\t\t\tbreak\t\t\t\t<br>\t\t\t}else{<br>\t\t\t\tvar temp = array[k]<br>\t\t\t\tarray[k] = array[k-1]<br>\t\t\t\tarray[k-1] = temp<br>\t\t\t}<br>\t\t}<br>\t}<br><br>都是不需要在for外面定义那个内层的循环下标啊，不知道老师那样写有什么好处，我这样写不是可读性更好吗？<br>","like_count":0},{"had_liked":false,"id":268964,"user_name":"santa","can_delete":false,"product_type":"c1","uid":2316325,"ip_address":"","ucode":"93B1BC812E847C","user_header":"https://static001.geekbang.org/account/avatar/00/23/58/25/ffcb1cee.jpg","comment_is_top":false,"comment_ctime":1608450978,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608450978","product_id":100017301,"comment_content":"算法可视化https:&#47;&#47;visualgo.net&#47;zh<br>","like_count":0},{"had_liked":false,"id":268113,"user_name":"慕高迪","can_delete":false,"product_type":"c1","uid":1448126,"ip_address":"","ucode":"EB1CB5EA4E3A90","user_header":"https://static001.geekbang.org/account/avatar/00/16/18/be/ad3127e0.jpg","comment_is_top":false,"comment_ctime":1608076817,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608076817","product_id":100017301,"comment_content":"<br>1. 冒泡排序<br><br>通过对相邻元素的比较和交换，从而把最大的元素交换到末尾；重复这个过程，直到元素有序。如果输入的元素本身有序，可以使用优化版的冒泡算法，也就是判断是否有数据交换，如果没有那么就说明是有序的。<br><br>分析：<br><br>1.1 空间复杂度为：O(1)。不需要额外的内存空间占用。<br>1.2 稳定性：稳定的<br>1.3 复杂度分析：<br>我们以优化后的冒泡排序为例：<br>最好情况下，输入数据本身有序，不存在数据交换。此时的时间复杂度为：O(N)<br>最坏情况下，输入数据是逆序的，每次都需要进行数据交换。此时的时间复杂度为：O(N^2)<br>平均情况下，由于输入样本的不固定，平均时间复杂度又需要把概率算进去，所以这件事对于专业的同学是比较难计算的。故而我们引入了有序度和逆序度的概念，用以评估平均时间的复杂度。<br>所谓的有序度：就是原数据中，有序的元素对的个数。比如原数据为：1，2，3，4，5，那么有序对的个数为（1，2）（1，3）（2，3）.....（4，5）共计15个。像这种完全有序的数据，它的有序度也成为满有序度。用公式总结为N(N-1)&#47;2 <br>所谓的逆序度：正好与有序度相反，说的是原数据中逆序元素对的个数。<br>最后可以总结出来一个公式：逆有序度 = 满有序度 - 有序度。我们还可以总结出来一个规律：在算法执行的过程中，元素的交换次数正好等于逆有序度。<br><br>在该算法中最好情况下的有序度为满有序度，最坏情况下有序度为0。所以平均情况下的交换次数为O(N^2) =  N(N-1)&#47; 2 * 1&#47;2 。比较的次数肯定比交换的多，最坏情况下的复杂度又为O(N^2)，所以平均时间复杂度为O(N^2)<br><br>2.插入排序<br><br>把数据分为有序组和无序组，遍历有序数据，将无序数组的元素插入到有序组中合适的位置。直到无序组中没有数据，此时有序组的数据均为有序状态。默认情况下有序组的元素为原数据的第一个元素。<br><br>分析：<br><br>2.1 空间复杂度为：O(1)。不需要额外的内存空间占用。<br>2.2 稳定性：稳定的<br>2.3 复杂度分析：<br>最好情况下，输入数据本身有序，我们从尾到头的遍历，每次只需要一次比较。此时的时间复杂度为：O(N)<br>最坏情况下，输入数据是逆序的，每次都需要进行数据交换。此时的时间复杂度为：O(N^2)<br>由于插入排序相当于向数据中插入元素，所以类似于数组，平均时间复杂度为O(N)。所以对于N个元素的插入，平均时间复杂度为O(N^2)<br><br>3.选择排序<br><br>也分为有序组和无序组，只不过它会在无序组中每次取最小的数据，放到原数据的第一个位置，然后依次类推，直到数据有序。默认情况下，有序组的元素为空。<br><br>分析：<br><br>2.1 空间复杂度为：O(1)。不需要额外的内存空间占用。<br>2.2 稳定性：插入排序后，会改变相同元素的先后位置，从而是不稳定的。例如：5，9，5，3，进行排序，第一个比较交换就会让第一个5到3的位置。<br>2.3 复杂度分析：<br>无论是在最好情况下还是最坏情况下，不管输入的数据是否有序，为了找出最小值，都需要对数据进行遍历，所以最好=最坏=平均=O(N^2)<br><br>为什么均为O(N^2)的时间复杂度，插入排序却比冒泡排序更加常用？<br><br>在追求极致性能的情况下，这就要算上具体的系数，低阶和常数。插入排序在具体的比较和交换操作上要比冒泡排序要少，所以比插入排序更加常用。<br><br>综上，都是时间复杂度为O(N^2)的，在实际工作中都不是很常用。","like_count":0},{"had_liked":false,"id":267210,"user_name":"锅侠","can_delete":false,"product_type":"c1","uid":2090232,"ip_address":"","ucode":"2F7856BEF55301","user_header":"https://static001.geekbang.org/account/avatar/00/1f/e4/f8/80374742.jpg","comment_is_top":false,"comment_ctime":1607651366,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607651366","product_id":100017301,"comment_content":"这里我来说一下最坏情况时间复杂度是如何算出来的，只考虑执行一行代码。<br>外层for循环执行的次数为: n<br>内层for循环的执行次数为: n + (n-1) + (n-2) + (n-1) + ... + 1 , 由等差数列列的求和公式可得 最终执行次数为： （n^2 + n） &#47; 2 <br><br>所以总执行次数是 n + （n^2 + n） &#47; 2  , 忽略常数、系数、低阶，所以是时间复杂度为O(n^2)<br>","like_count":0},{"had_liked":false,"id":266065,"user_name":"Alvin-L","can_delete":false,"product_type":"c1","uid":1603052,"ip_address":"","ucode":"5AC96AAB75B720","user_header":"https://static001.geekbang.org/account/avatar/00/18/75/ec/c60b29f5.jpg","comment_is_top":false,"comment_ctime":1607156535,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607156535","product_id":100017301,"comment_content":"查看jdk源码，大师们排序算法的实现，是大规模数据时使用双轴快速排序，当分裂的总量到了小规模程度时，使用的就是插入排序了。","like_count":0},{"had_liked":false,"id":264068,"user_name":"Qiubh","can_delete":false,"product_type":"c1","uid":1072658,"ip_address":"","ucode":"3BC33EC44F2FDE","user_header":"https://static001.geekbang.org/account/avatar/00/10/5e/12/c0c4d6f2.jpg","comment_is_top":false,"comment_ctime":1606328578,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606328578","product_id":100017301,"comment_content":"冒泡排序的时间复杂度最坏的情况应该是个等差数列的求和。n个数据应该是(n-1)+(n-2)+(n-3)+....+1<br>不应该是 n(n-1)&#47;2 吗？毕竟 n² 比 n(n-1)&#47;2 还是大的多啊。","like_count":0},{"had_liked":false,"id":263156,"user_name":"郑印","can_delete":false,"product_type":"c1","uid":1005282,"ip_address":"","ucode":"181B0FDE5E1532","user_header":"https://static001.geekbang.org/account/avatar/00/0f/56/e2/2dcab30d.jpg","comment_is_top":false,"comment_ctime":1606026254,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606026254","product_id":100017301,"comment_content":" public static void sort(int[] arr){<br>        if(arr.length &lt;= 1){<br>            return;<br>        }<br>        for (int i=1;i&lt;arr.length;i++){<br>            for (int j = i;j&gt;0;j--){<br>                if(arr[j] &lt; arr[j-1]){<br>                    int tmp = arr[j];<br>                    arr[j] = arr[j-1];<br>                    arr[j-1] = tmp;<br>                }else{<br>                    break;<br>                }<br>            }<br>            System.out.println(JSON.toJSONString(arr));<br>        }<br>    }<br><br>这样的实现算是插入排序，还是冒泡排序， 这个实现每个阶段的输出和课程的结果是一样的。","like_count":0},{"had_liked":false,"id":262411,"user_name":"大力","can_delete":false,"product_type":"c1","uid":1364353,"ip_address":"","ucode":"1B2125C519443D","user_header":"https://static001.geekbang.org/account/avatar/00/14/d1/81/89ba9d81.jpg","comment_is_top":false,"comment_ctime":1605710207,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605710207","product_id":100017301,"comment_content":"思考题：<br>冒泡排序：<br>https:&#47;&#47;github.com&#47;kolinkuang&#47;algo-demos&#47;blob&#47;master&#47;linked_list_sorting&#47;bubble&#47;case3.js<br>最好时间复杂度：O(n)<br>最差时间复杂度：O(n^2)<br>空间复杂度：O(1)<br><br>插入排序<br>https:&#47;&#47;github.com&#47;kolinkuang&#47;algo-demos&#47;blob&#47;master&#47;linked_list_sorting&#47;insertion&#47;case2.js<br>最好时间复杂度：O(n)<br>最差时间复杂度：O(n^2)？<br>空间复杂度：O(1)<br><br>选择排序<br>https:&#47;&#47;github.com&#47;kolinkuang&#47;algo-demos&#47;blob&#47;master&#47;linked_list_sorting&#47;selection&#47;case3.js<br>最好时间复杂度：O(n^2)<br>最差时间复杂度：O(n^2)<br>空间复杂度：O(1)","like_count":0},{"had_liked":false,"id":261962,"user_name":"前方的灯有点弱","can_delete":false,"product_type":"c1","uid":2058455,"ip_address":"","ucode":"5CEDBCF3DDC991","user_header":"https://static001.geekbang.org/account/avatar/00/1f/68/d7/29025f1f.jpg","comment_is_top":false,"comment_ctime":1605591363,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605591363","product_id":100017301,"comment_content":"相同情况, 越短的代码，造成的性能就会越好","like_count":0},{"had_liked":false,"id":261700,"user_name":"18233563705","can_delete":false,"product_type":"c1","uid":1364492,"ip_address":"","ucode":"0C04BEA146B01F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJeahDXoHnJ6Ta5zpibydXuYic4QuNOpC5qw3icRd9SA8gnAjJupnNgMcO6T9npcHI3ZnZ8tkrM0MwBg/132","comment_is_top":false,"comment_ctime":1605493744,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605493744","product_id":100017301,"comment_content":"原地排序的时间复杂度是O(1)？难道不是O(n)吗？","like_count":0},{"had_liked":false,"id":260250,"user_name":"一路向西","can_delete":false,"product_type":"c1","uid":1309718,"ip_address":"","ucode":"59D044DFE23D30","user_header":"https://static001.geekbang.org/account/avatar/00/13/fc/16/97592232.jpg","comment_is_top":false,"comment_ctime":1604970173,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604970173","product_id":100017301,"comment_content":"在c++封装的一些方法里面，例如sort，它是用的什么排序方法？如何来评价其选择的排序是效率最高的？","like_count":0},{"had_liked":false,"id":258883,"user_name":"ɴɪᴋᴇʀ","can_delete":false,"product_type":"c1","uid":1616622,"ip_address":"","ucode":"DB7D92CBB5FD15","user_header":"https://static001.geekbang.org/account/avatar/00/18/aa/ee/15c328ca.jpg","comment_is_top":false,"comment_ctime":1604575429,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604575429","product_id":100017301,"comment_content":"我觉得，上面插入排序的 int value = a[i]；就类类似于链表(下)中所讲到的哨兵思想，通过哨兵降低时间复杂度，对于大量数据效率会有很大提升。","like_count":0},{"had_liked":false,"id":257473,"user_name":"grk","can_delete":false,"product_type":"c1","uid":1024866,"ip_address":"","ucode":"B899891ECE8A5A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a3/62/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1603981983,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603981983","product_id":100017301,"comment_content":"冒泡排序是不是多排了一次","like_count":0},{"had_liked":false,"id":254184,"user_name":"Mickey","can_delete":false,"product_type":"c1","uid":1059845,"ip_address":"","ucode":"548E950F57D2A8","user_header":"https://static001.geekbang.org/account/avatar/00/10/2c/05/b8e769fa.jpg","comment_is_top":false,"comment_ctime":1603078187,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603078187","product_id":100017301,"comment_content":"插入排序的转换代码只有一行，相比冒泡三行，运行效率理论会高","like_count":0},{"had_liked":false,"id":253964,"user_name":"吉法师","can_delete":false,"product_type":"c1","uid":2232546,"ip_address":"","ucode":"F1E3F4F526CA13","user_header":"https://static001.geekbang.org/account/avatar/00/22/10/e2/35f2fc23.jpg","comment_is_top":false,"comment_ctime":1602993631,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602993631","product_id":100017301,"comment_content":"其实排序算法的稳定性，可以通过某些特殊的方法将不稳定的排序算法改写成稳定的。<br>也有另外一种，比如冒泡排序的判断条件有个等于，相同的也交换，那就是不稳定的了。","like_count":0},{"had_liked":false,"id":250925,"user_name":"码农翻身的小粉丝","can_delete":false,"product_type":"c1","uid":1064752,"ip_address":"","ucode":"1FB018F749CE84","user_header":"","comment_is_top":false,"comment_ctime":1601282737,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601282737","product_id":100017301,"comment_content":"简单排序：<br>1.冒泡排序：外层循环控制循环的次数，内层循环每次从所有待排序的数据子集中把最大值通过两两比较并交换后放到数据末尾的有序子集的第一个元素处。<br>2.插入排序：外层循环代表所有未排序的元素个数(假设第一个元素是最小的有序子集)，内层循环每次把当前元素和前面的有序子集逐一比较，找到位置后停下，做出插入动作，继续下一次循环<br>3.选择排序：同样将数据分为排序和未排序两部分，外层循环代表未排序的数据子集。每次循环先假设当前下标代表未排序元素子集的最小值的下标，内层循环从当前下标往后开始逐一和当前外循环下标所代表的元素比较，内循环结束，若最小值下标有变化，则交换当前外循环i所代表的假设最小值与内循环选出来的最小值的下标。","like_count":0},{"had_liked":false,"id":250832,"user_name":"吴关俊","can_delete":false,"product_type":"c1","uid":2173036,"ip_address":"","ucode":"6ACA9C31BBCCF8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoxfvYvvMkjsjwA6rnpIGY2DSZ6Ww5yxP6brbzkicNdXc6ftPoAC8J94SoicneVDmH1Wdta194oFribQ/132","comment_is_top":false,"comment_ctime":1601256573,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601256573","product_id":100017301,"comment_content":"为啥选择排序不是稳定的呢，如果a,b相等，重排后位置根本不会变化，","like_count":0},{"had_liked":false,"id":250729,"user_name":"Geek_636e46","can_delete":false,"product_type":"c1","uid":2164554,"ip_address":"","ucode":"E27F2B037B4C41","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLc8iay7SThjDaND4WNn4jlK2L7fyPaFibzxUyS6UiaypQsMibIjhxONeChTuTHZEdjXk0CHEgRRjJKbA/132","comment_is_top":false,"comment_ctime":1601203153,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601203153","product_id":100017301,"comment_content":"但是选择排序好像更快？我用1*1000的随机数组排了一下，冒泡3.2s，插入0.14s，选择0.0036s","like_count":0},{"had_liked":false,"id":250425,"user_name":"不甘心的翔入非非","can_delete":false,"product_type":"c1","uid":1474300,"ip_address":"","ucode":"1C39E0E5215C54","user_header":"https://static001.geekbang.org/account/avatar/00/16/7e/fc/b132947b.jpg","comment_is_top":false,"comment_ctime":1601083191,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601083191","product_id":100017301,"comment_content":"一个小前端瑟瑟发抖不敢大声说话。。。","like_count":0},{"had_liked":false,"id":250424,"user_name":"不甘心的翔入非非","can_delete":false,"product_type":"c1","uid":1474300,"ip_address":"","ucode":"1C39E0E5215C54","user_header":"https://static001.geekbang.org/account/avatar/00/16/7e/fc/b132947b.jpg","comment_is_top":false,"comment_ctime":1601083118,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601083118","product_id":100017301,"comment_content":"<br>&#47;&#47; 冒泡排序，a表示数组，n表示数组大小<br>public void bubbleSort(int[] a, int n) {<br>  if (n &lt;= 1) return;<br> <br> for (int i = 0; i &lt; n; ++i) {<br>    &#47;&#47; 提前退出冒泡循环的标志位<br>    boolean flag = false;<br>    for (int j = 0; j &lt; n - i - 1; ++j) {<br>      if (a[j] &gt; a[j+1]) { &#47;&#47; 交换<br>        int tmp = a[j];<br>        a[j] = a[j+1];<br>        a[j+1] = tmp;<br>        flag = true;  &#47;&#47; 表示有数据交换      <br>      }<br>    }<br>    if (!flag) break;  &#47;&#47; 没有数据交换，提前退出<br>  }<br>}<br>老师但是上面举例的这个是没有优化过的冒泡排序法吧？","like_count":0},{"had_liked":false,"id":249629,"user_name":"LearnAndTry","can_delete":false,"product_type":"c1","uid":1512860,"ip_address":"","ucode":"0ECF4398C870DC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Rr8ABLicfgJHZ3xs3bXNjHdicwVN0zBiaFtIEXw4D1licedSuia3zicxJC4lqtrNwPmCeAW5UR2Ugia0dNfcvtXYnpOwQ/132","comment_is_top":false,"comment_ctime":1600735342,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600735342","product_id":100017301,"comment_content":"有序度和逆序度概念的引入把我们的排序讨论拉高了一个层级。有意思","like_count":0},{"had_liked":false,"id":249285,"user_name":"秋谷","can_delete":false,"product_type":"c1","uid":1515645,"ip_address":"","ucode":"745E8DB283BB51","user_header":"https://static001.geekbang.org/account/avatar/00/17/20/7d/2a5c137c.jpg","comment_is_top":false,"comment_ctime":1600569061,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600569061","product_id":100017301,"comment_content":"老师，我看冒泡排序有一个提前退出的flag，然后下面有评论说外层排序次数可以是n-1，这两个是不是对等条件，就是可以替换的呢","like_count":0},{"had_liked":false,"id":248450,"user_name":"WilliamVector","can_delete":false,"product_type":"c1","uid":1898112,"ip_address":"","ucode":"E0D3C3D4FCB7C9","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f6/80/85ec2c2a.jpg","comment_is_top":false,"comment_ctime":1600168108,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600168108","product_id":100017301,"comment_content":"【要点】<br>1、冒泡排序（Bubble Sort）。冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。冒泡排序是稳定的原地排序算法。最好、最坏和平均时间复杂度为：O(n)、O(n2)、O(n2)。<br>2、插入排序（Insertion Sort）。将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。插入排序是稳定的原地排序算法。最好、最坏和平均时间复杂度为：O(n)、O(n2)、O(n2)。<br>3、选择排序（Selection Sort）。选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。最好、最坏和平均时间复杂度为：O(n2)、O(n2)、O(n2)。<br>【思考】<br>双木公子：冒泡排序相比于数组实现，比较次数一致，但交换时操作更复杂；插入排序，比较次数一致，不需要再有后移操作，找到位置后可以直接插入；选择排序比较次数一致，交换操作同样比较麻烦。综上，时间复杂度和空间复杂度并无明显变化，若追求极致性能，冒泡排序的时间复杂度系数会变大，插入排序系数会减小，选择排序无明显变化。","like_count":0},{"had_liked":false,"id":247015,"user_name":"scp-166","can_delete":false,"product_type":"c1","uid":1625472,"ip_address":"","ucode":"20928E00DA18B2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/C4mfaPk43JjY1GxAWv1MAlern5TG4zHdknAM0PojA01xdK8nPPW2fI1bicCmgDib3B4SeIUmPamI4CzpMBodJANw/132","comment_is_top":false,"comment_ctime":1599557866,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599557866","product_id":100017301,"comment_content":"老师，现在有个场景，需要在小量(200左右)有序list中插入数据，我很快想到了插入排序，问题来了: 平常工作都是无脑 Collections.sort(), 现在是否需要自己手动实现一个插入排序的工具类呢?","like_count":0},{"had_liked":false,"id":245797,"user_name":"dpjin","can_delete":false,"product_type":"c1","uid":1539183,"ip_address":"","ucode":"0383D8003E6C14","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/pHPfugzib71JdXkKxRITCzdD46DYcDYHImoYeibHdyu4hLWOBXh7OLllx247vKJvWIcu18dxWOTAtv8AaRB8opvQ/132","comment_is_top":false,"comment_ctime":1599057434,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599057434","product_id":100017301,"comment_content":"golang实现冒泡排序和插入排序<br>func SortByBubble(list []int) []int {<br>\tif len(list) &gt; 1{<br>\t\tfor i := 0; i &lt; len(list); i++ {<br>\t\t\tfor j := 0; j &lt; len(list)-1; j++ {<br>\t\t\t\tif list[j] &gt; list[j+1] {<br>\t\t\t\t\tlist[j], list[j+1] = list[j+1], list[j]<br>\t\t\t\t\tcontinue<br>\t\t\t\t}<br>\t\t\t}<br>\t\t}<br>\t}<br>\treturn list<br>}<br><br>func SortByInsertion(list []int) []int {<br>\tif len(list) &gt; 1 {<br>\t\tfor i := 1; i &lt; len(list); i++ {<br>\t\t\ttmp := list[i]<br>\t\t\tfor j := i - 1; j &gt;= 0; j-- {<br>\t\t\t\tif tmp &lt; list[j] {<br>\t\t\t\t\tlist[j+1], list[j] = list[j], tmp<br>\t\t\t\t} else {<br>\t\t\t\t\tbreak<br>\t\t\t\t}<br>\t\t\t}<br>\t\t}<br>\t}<br>\treturn list<br>}","like_count":0},{"had_liked":false,"id":243875,"user_name":"JerryZhu","can_delete":false,"product_type":"c1","uid":1591223,"ip_address":"","ucode":"76850CD45786C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","comment_is_top":false,"comment_ctime":1598317923,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598317923","product_id":100017301,"comment_content":"老师好， 对于有序度公式 n*（n-1）&#47;2  是怎么得到？","like_count":0},{"had_liked":false,"id":243112,"user_name":"Geek_a814f7","can_delete":false,"product_type":"c1","uid":2129514,"ip_address":"","ucode":"3C0EED9218954B","user_header":"","comment_is_top":false,"comment_ctime":1597971093,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597971093","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":237786,"user_name":"对白","can_delete":false,"product_type":"c1","uid":1268797,"ip_address":"","ucode":"3183E5ADBC794B","user_header":"https://static001.geekbang.org/account/avatar/00/13/5c/3d/e8325811.jpg","comment_is_top":false,"comment_ctime":1595952659,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595952659","product_id":100017301,"comment_content":"稳定性排序算法的作用：在二次排序的基础上保持着一次排序的意义","like_count":0},{"had_liked":false,"id":237779,"user_name":"对白","can_delete":false,"product_type":"c1","uid":1268797,"ip_address":"","ucode":"3183E5ADBC794B","user_header":"https://static001.geekbang.org/account/avatar/00/13/5c/3d/e8325811.jpg","comment_is_top":false,"comment_ctime":1595950701,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595950701","product_id":100017301,"comment_content":"我用python分别实现了冒泡、插入、选择和希尔排序，大家可以看一下~<br>def bubble_sort(arr):<br>    #比较<br>    for i in range(len(arr)-1):<br>        flag=False<br>        #交换<br>        for j in range(len(arr)-i-1):<br>            if arr[j]&gt;arr[j+1]:<br>                arr[j],arr[j+1]=arr[j+1],arr[j]<br>                flag=True<br>        if not flag:<br>            return arr<br>    return arr<br><br>def insert_sort(arr):<br>    #遍历未排序区间中的元素<br>    for i in range(1,len(arr)):<br>        j=i-1<br>        while j&gt;=0 and arr[i]&lt;arr[j]:<br>            arr[j+1]=arr[j]<br>            j=j-1<br>        arr[j+1]=arr[i]<br>    return arr<br><br>def selection_sort(arr):<br>    for i in range(len(arr)):<br>        min_index=i<br>        #找出未排序区间中的最小值<br>        for j in range(i+1,len(arr)):<br>            if arr[min_index]&gt;arr[j]:<br>                min_index=j<br>        #添加到已排序区间的末尾<br>        arr[i],arr[min_index]=arr[min_index],arr[i]<br>    return arr<br><br>def shell_sort(arr):<br>    a=len(arr)<br>    gap=a&#47;&#47;2<br>    while gap&gt;=1:<br>        for i in range(a):<br>            j=i<br>            while j&gt;=gap and arr[j-gap]&gt;arr[j]:<br>                arr[j-gap],arr[j]=arr[j],arr[j-gap]<br>                j=j-gap<br>        gap=gap&#47;&#47;2<br>    return arr","like_count":0},{"had_liked":false,"id":237223,"user_name":"Geek_123d36","can_delete":false,"product_type":"c1","uid":2082963,"ip_address":"","ucode":"AE849572C4BAC3","user_header":"","comment_is_top":false,"comment_ctime":1595746561,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595746561","product_id":100017301,"comment_content":"插入排序的代码注释有点少，我也是看了好久才搞明白到底做了啥，作为小白而言看见这样的编程思想还真是让我人惊叹","like_count":0},{"had_liked":false,"id":237184,"user_name":"。","can_delete":false,"product_type":"c1","uid":1991078,"ip_address":"","ucode":"067C449245568C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/61/a6/bd6cf262.jpg","comment_is_top":false,"comment_ctime":1595731588,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1595731588","product_id":100017301,"comment_content":"老师，我没理解插入排序第二个for循环为什么用--j，我试了下用j--也是可以的，能说下这里用--j的原因吗？","like_count":0,"discussions":[{"author":{"id":1994946,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/70/c2/d3b890ec.jpg","nickname":"刘晓冬","note":"","ucode":"0AC9F3B87FB9C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296689,"discussion_content":"--j是立马进行减 j--是执行完其他语句后再减  循环里面由于是独立的个体 两个等价 但是 赋值语句中有其他操作就不一定了 i =0  ,a = i++ +1 (=1,i最后自增1)  i =0  ,a =++ i +1 (=2，i立马自增1)  ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596622254,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236343,"user_name":"sibyl","can_delete":false,"product_type":"c1","uid":1323652,"ip_address":"","ucode":"0D142011860D69","user_header":"","comment_is_top":false,"comment_ctime":1595393702,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595393702","product_id":100017301,"comment_content":"&#47;**<br> * 对链表进行冒泡排序<br> *&#47;<br>public class BubbleSortLinkList {<br>    public static LinkNode sort(LinkNode head){<br>        LinkNode guard = new LinkNode();<br>        guard.next = head;<br>        int len = head.len();<br>        for (int i = 0; i &lt; len; i++){<br>            &#47;&#47; 每轮将最大值交换到最后<br>            LinkNode p = guard;<br>            int j = 0;<br>            boolean isSwap = false;<br>            while (p.next !=null &amp;&amp; p.next.next != null &amp;&amp; j &lt; len - i){<br>                if (p.next.value &gt; p.next.next.value){<br>                    swap(p);<br>                    isSwap = true;<br>                }<br>                p = p.next;<br>                j++;<br>            }<br>            if (!isSwap){<br>                &#47;&#47;没有发生交换，说明已经有序<br>                break;<br>            }<br>        }<br>        return guard.next;<br>    }<br><br>    &#47;**<br>     * 交换pre的后继和后继的后继<br>     *<br>     * @param pre 前驱节点<br>     *&#47;<br>    public static void swap(LinkNode pre){<br>        Objects.requireNonNull(pre);<br>        Objects.requireNonNull(pre.next);<br>        Objects.requireNonNull(pre.next.next);<br>        LinkNode a = pre.next;<br>        LinkNode b = pre.next.next;<br>        LinkNode c = pre.next.next.next;<br>        pre.next = b;<br>        b.next = a;<br>        a.next = c;<br>    }<br>}","like_count":0},{"had_liked":false,"id":235395,"user_name":"苗","can_delete":false,"product_type":"c1","uid":1088710,"ip_address":"","ucode":"5ECCC6C855E541","user_header":"https://static001.geekbang.org/account/avatar/00/10/9c/c6/05a6798f.jpg","comment_is_top":false,"comment_ctime":1594996904,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594996904","product_id":100017301,"comment_content":"一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作；外层循环执行n-1层就可以了。","like_count":0},{"had_liked":false,"id":235159,"user_name":"Merry","can_delete":false,"product_type":"c1","uid":1024036,"ip_address":"","ucode":"E2A114E10814BA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a0/24/68c679c8.jpg","comment_is_top":false,"comment_ctime":1594910758,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594910758","product_id":100017301,"comment_content":"这三种排序算法都可以在链表上实现，时空复杂度均分别为O(n)、O(1)，但在链表（不可随机存取）上的效率远低于在数组上实现。","like_count":0},{"had_liked":false,"id":234484,"user_name":"beyond","can_delete":false,"product_type":"c1","uid":1962858,"ip_address":"","ucode":"89185FC5C39067","user_header":"https://static001.geekbang.org/account/avatar/00/1d/f3/6a/66b6472b.jpg","comment_is_top":false,"comment_ctime":1594699544,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594699544","product_id":100017301,"comment_content":"插入排序和冒泡排序很像,冒泡排序是在未排序区间从前往后进行遍历,进行比较和交换操作.插入排序是从后往前遍历,进行比较和交换操作,不过这个交换操作只需要a[j+1]=a[j],比较简单.<br>","like_count":0},{"had_liked":false,"id":231376,"user_name":"山水如初","can_delete":false,"product_type":"c1","uid":1930382,"ip_address":"","ucode":"D4BE5C836DE53D","user_header":"https://static001.geekbang.org/account/avatar/00/1d/74/8e/caa7afec.jpg","comment_is_top":false,"comment_ctime":1593659967,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593659967","product_id":100017301,"comment_content":"选择排序是一种不稳定的排序算法。<br><br>同时又是“稳定的”，没错是稳定的差：连最好情况时间复杂度都是 O(n^2)。😂","like_count":0},{"had_liked":false,"id":229143,"user_name":"Geek_e68053","can_delete":false,"product_type":"c1","uid":2044920,"ip_address":"","ucode":"53AA5F0627FEEC","user_header":"","comment_is_top":false,"comment_ctime":1592906693,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592906693","product_id":100017301,"comment_content":"冒泡排序算法有地方错了for (int i = 0; i &lt; n; ++i)  这里应该是i=1, 冒泡排序N个元素，最多只需N-1次排序","like_count":0},{"had_liked":false,"id":227411,"user_name":"极客学子","can_delete":false,"product_type":"c1","uid":1149510,"ip_address":"","ucode":"40051597564EB7","user_header":"https://static001.geekbang.org/account/avatar/00/11/8a/46/71747b18.jpg","comment_is_top":false,"comment_ctime":1592375328,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592375328","product_id":100017301,"comment_content":"能，由于几个排序是遍历数据进行比较的，可以不需要随机访问，不过链表需要双向链表才能更好的工作：<br>冒泡排序：时间复杂度：最好O(n)，最坏O(n^2)，平均O(n^2)；空间复杂度：O(1);<br>插入排序：时间复杂度：最好O(n)，最坏O(n^2)，平均O(n^2)；空间复杂度：O(1);<br>选择排序：时间复杂度：最好O(n^2)，最坏O(n^2)，平均O(n^2)；空间复杂度：O(1);<br>其实冒泡和选择排序基于数组或者链表区别不大，有区别的主要是插入排序，插入排序基于链表会省略移动数据那一部分开销","like_count":0},{"had_liked":false,"id":227342,"user_name":"杨冬","can_delete":false,"product_type":"c1","uid":1956611,"ip_address":"","ucode":"317607AAA75F85","user_header":"https://static001.geekbang.org/account/avatar/00/1d/db/03/67fbb09d.jpg","comment_is_top":false,"comment_ctime":1592360280,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592360280","product_id":100017301,"comment_content":"老师，有个问题，不太理解。冒泡排序中计算平均时间复杂度不适合理解。--》平均情况下，需要 n*(n-1)&#47;4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n2)，所以平均情况下的时间复杂度就是 O(n2)。","like_count":0},{"had_liked":false,"id":226265,"user_name":"Geek_849f9f","can_delete":false,"product_type":"c1","uid":2027473,"ip_address":"","ucode":"67601F35A91999","user_header":"","comment_is_top":false,"comment_ctime":1592019069,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592019069","product_id":100017301,"comment_content":"可以使用链表实现，时间与空间复杂度与数组无多大区别","like_count":0},{"had_liked":false,"id":225380,"user_name":"Fozei","can_delete":false,"product_type":"c1","uid":1984068,"ip_address":"","ucode":"C9004B1FED8749","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKDCEibaYsiaaLHH440T8ibzvR0ibqeNuNpmm7qE2iaehpL7AU0QQ4EvHtC0UC0zuB0qIuIRYEibyUrZ8lQ/132","comment_is_top":false,"comment_ctime":1591749193,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591749193","product_id":100017301,"comment_content":"一直有个疑问呀,不管哪种排序,是否稳定,是不是跟具体实现有关系呢?一个稳定的排序算法,可以写成不稳定的,一个不稳定的排序算法,同样也可以实现成稳定的,不知道说的对不对.","like_count":0},{"had_liked":false,"id":225259,"user_name":"Jokky💫","can_delete":false,"product_type":"c1","uid":1475913,"ip_address":"","ucode":"B8E6B913D1E975","user_header":"https://static001.geekbang.org/account/avatar/00/16/85/49/b29e96ea.jpg","comment_is_top":false,"comment_ctime":1591697941,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1591697941","product_id":100017301,"comment_content":"github上selection_sort的排序代码应该排序次数数组长度减1次:<br>```<br>def selection_sort(arr):<br>    length = len(arr)<br>    if length&lt;=1:<br>        return arr<br>    for i in range(length-1):<br>        min_index = i<br>        min_value = arr[i]<br>        for j in range(i,length):<br>            if arr[j]&lt;min_value:<br>                min_value = arr[j]<br>                min_index = j<br>        arr[i],arr[min_index] = arr[min_index],arr[i]<br>    return arr<br>```","like_count":0},{"had_liked":false,"id":224181,"user_name":"Joeswooddd","can_delete":false,"product_type":"c1","uid":1659483,"ip_address":"","ucode":"EB6E368171E20F","user_header":"https://static001.geekbang.org/account/avatar/00/19/52/5b/034f4f5c.jpg","comment_is_top":false,"comment_ctime":1591314228,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591314228","product_id":100017301,"comment_content":"作为一名大一学生，之前学过BubbleSort和InsectionSort，考试的时候都是默写，但通过这章节上我现在能从原理上一步一步分析，能一步一步构架出它们，同时我很感激老师你，能在让我在打基础的时间能遇见这么漂亮的代码","like_count":0},{"had_liked":false,"id":220624,"user_name":"杨锋","can_delete":false,"product_type":"c1","uid":1283461,"ip_address":"","ucode":"85A7828A538FB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/95/85/15cd21c2.jpg","comment_is_top":false,"comment_ctime":1590297786,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1590297786","product_id":100017301,"comment_content":"是不是每一次冒泡都会把最大的数字放到最后","like_count":0},{"had_liked":false,"id":220352,"user_name":"Geek_py hang","can_delete":false,"product_type":"c1","uid":1915167,"ip_address":"","ucode":"E1DABF14C9176B","user_header":"https://static001.geekbang.org/account/avatar/00/1d/39/1f/579ae900.jpg","comment_is_top":false,"comment_ctime":1590225647,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590225647","product_id":100017301,"comment_content":"冒泡管理，投票方式","like_count":0},{"had_liked":false,"id":219155,"user_name":"草原上的骆驼🐫","can_delete":false,"product_type":"c1","uid":1651618,"ip_address":"","ucode":"F0B12CB1FEED84","user_header":"https://static001.geekbang.org/account/avatar/00/19/33/a2/585be249.jpg","comment_is_top":false,"comment_ctime":1589956578,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589956578","product_id":100017301,"comment_content":"js版本的选择排序<br>function selectionSort(arr){<br>    let len = arr.length<br>    if(len &lt;= 1) return <br><br>    for(let i = 1; i &lt; len; ++i){<br>        let right_arr = arr.slice(i),<br>            min = Math.min.apply(null, right_arr),<br>            index = arr.findIndex(item =&gt; item===min),<br>            j = i - 1;<br>            for(;j &gt;= 0; --j){<br>                if(arr[j] &gt; min){<br>                    arr[index] = arr[j] <br>                } else {<br>                    break;<br>                }<br>            }<br>            arr[j+1] = min<br>    }<br>    return arr<br>}<br>console.log(selectionSort([4,5,6,1,3,2]))","like_count":0},{"had_liked":false,"id":219132,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1589953097,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589953097","product_id":100017301,"comment_content":"冒泡排序，插入排序，选择排序。<br>三种排序的时间复杂度都是O(n2)，空间复杂度是O(n)。冒泡和插入都是稳定排序，而选择排序是不稳定排序。","like_count":0},{"had_liked":false,"id":218972,"user_name":"iris","can_delete":false,"product_type":"c1","uid":1986106,"ip_address":"","ucode":"8D54D1DBEA6F64","user_header":"https://static001.geekbang.org/account/avatar/00/1e/4e/3a/1932100c.jpg","comment_is_top":false,"comment_ctime":1589905571,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589905571","product_id":100017301,"comment_content":"冒泡排序：两两相比，移动位置，每一次比较都有一个数据回到正确位置，空间复杂度O(1)，原地排序，时间复杂度O(n^2)，稳定排序。<br>插入排序：分为有序区和无序区，第一位设为有序区，然后每次从无序区取一个数据到有序区放到正确位置，空间复杂度O(1)，原地排序，时间复杂度O(n^2)，稳定排序。<br>选择排序：也是有序区和无序区，区别是现在无序区选择最小的数放到无序区，属于不稳定排序。<br>冒泡排序和插入排序虽然时间复杂度一样，但是在代码实现上插入排序优一点，所以日常选择排序更受欢迎。<br>逆序度=满有序度-有序度","like_count":0},{"had_liked":false,"id":213433,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1588413096,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588413096","product_id":100017301,"comment_content":"在追老师的“设计模式课程”，抽空又来看看“数据结构”这个专栏。<br>反正，多看看吧，不可能一次就把一个文章或专栏学会的。","like_count":0},{"had_liked":false,"id":211519,"user_name":"霹雳大仙pp","can_delete":false,"product_type":"c1","uid":1046893,"ip_address":"","ucode":"F654FD9AEC1D56","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/6d/b623562a.jpg","comment_is_top":false,"comment_ctime":1587976760,"is_pvip":false,"discussion_count":0,"race_medal":3,"score":"1587976760","product_id":100017301,"comment_content":"稳定性，如果初始数据顺序有意义，则二次排序不破坏原有排序的意义，则为稳定性。<br>应该看业务需要，如果不在乎初始顺序，也无所谓稳定性了","like_count":0},{"had_liked":false,"id":210865,"user_name":"hailowell","can_delete":false,"product_type":"c1","uid":1195572,"ip_address":"","ucode":"557DCAB01710AB","user_header":"","comment_is_top":false,"comment_ctime":1587857439,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587857439","product_id":100017301,"comment_content":"选择排序 使用一块新的空间，比较后直接插入 可以维持稳定性 同时减少了插值操作。就是空间占用较大","like_count":0},{"had_liked":false,"id":210329,"user_name":"默默","can_delete":false,"product_type":"c1","uid":1006635,"ip_address":"","ucode":"AF798B9D327F24","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/2b/8b771383.jpg","comment_is_top":false,"comment_ctime":1587722015,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587722015","product_id":100017301,"comment_content":"排序的两个基本操作是比较和交换数据。基于数组和链表的序列，比较操作是一致的，交换操作也是一致的，只需要交换借点的数据即可。","like_count":0},{"had_liked":false,"id":210317,"user_name":"leahchuan","can_delete":false,"product_type":"c1","uid":1239760,"ip_address":"","ucode":"585294EF903227","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/d0/3ed2dd26.jpg","comment_is_top":false,"comment_ctime":1587719532,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1587719532","product_id":100017301,"comment_content":"为什么冒泡排序的最好时间复杂度是O(n)，当数据有序时，虽然不用移动了，但不都要比较一遍吗","like_count":0},{"had_liked":false,"id":209375,"user_name":"o0oi1i","can_delete":false,"product_type":"c1","uid":1132312,"ip_address":"","ucode":"D1F6AD4AAEAFBE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/18/293cd24d.jpg","comment_is_top":false,"comment_ctime":1587543080,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587543080","product_id":100017301,"comment_content":"对于老师的问题完全没有任何的思路😭","like_count":0},{"had_liked":false,"id":209057,"user_name":"海之蓝","can_delete":false,"product_type":"c1","uid":1257821,"ip_address":"","ucode":"7C994B7797533E","user_header":"https://static001.geekbang.org/account/avatar/00/13/31/5d/a416ac29.jpg","comment_is_top":false,"comment_ctime":1587483863,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587483863","product_id":100017301,"comment_content":"1、在相同有序度的数组情况下，插入排序比冒泡排序效率更高，因为冒泡排序在交换数据时需要三行赋值语句，而插入排序只需要一行赋值语句；<br>2、选择排序很少用到，虽然平均时间复杂度与冒泡、插入排序相同，但它不是稳定的排序；<br>3、评价一个排序算法的优劣主要从三个方面分析：是否原地排序、是否稳定排序、时间复杂度。","like_count":0},{"had_liked":false,"id":208877,"user_name":"Hinimix","can_delete":false,"product_type":"c1","uid":1316937,"ip_address":"","ucode":"7994136C93BD89","user_header":"https://static001.geekbang.org/account/avatar/00/14/18/49/b1d864e5.jpg","comment_is_top":false,"comment_ctime":1587456494,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587456494","product_id":100017301,"comment_content":"老师，我写这个算是插入排序吗，我自己画图自己写了一下，感觉也就比冒泡排序好一点<br><br>&#47;&#47; 插入排序<br>func insertSort(sliceName *[]int) {<br>\t&#47;&#47; 如果数组&lt;=1，不用排序<br>\tif len(*sliceName) &lt;= 1 {<br>\t\treturn<br>\t}<br>\t&#47;&#47;x是未排序分组<br>\tfor x := 1; x &lt; len(*sliceName); x++ {<br>\t\tvalue := (*sliceName)[x]<br>\t\t&#47;&#47;y是已排序分组<br>\t\tfor y := 0; y &lt; x; y++ {<br>\t\t\tif (*sliceName)[y] &gt; value {<br>\t\t\t\t(*sliceName)[x] = (*sliceName)[y]<br>\t\t\t\t(*sliceName)[y] = value<br>\t\t\t\tvalue = (*sliceName)[x]<br>\t\t\t}<br>\t\t}<br>\t}<br>}","like_count":0},{"had_liked":false,"id":208839,"user_name":"Allan","can_delete":false,"product_type":"c1","uid":1310388,"ip_address":"","ucode":"8DA4DBECC2C45C","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","comment_is_top":false,"comment_ctime":1587447538,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1587447538","product_id":100017301,"comment_content":"“选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。”文中这句话是否写的不对与图不符合，下面的如是选择最小与已经排序对比后交换位置，而文中说选择最小放到已排序的末尾？","like_count":0,"discussions":[{"author":{"id":1092218,"avatar":"https://static001.geekbang.org/account/avatar/00/10/aa/7a/ae8c247d.jpg","nickname":"指尖以东","note":"","ucode":"1DEE134FE92FD0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":243285,"discussion_content":"我也注意到了，应该最小的放到了头部","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587532094,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1310388,"avatar":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","nickname":"Allan","note":"","ucode":"8DA4DBECC2C45C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1092218,"avatar":"https://static001.geekbang.org/account/avatar/00/10/aa/7a/ae8c247d.jpg","nickname":"指尖以东","note":"","ucode":"1DEE134FE92FD0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":244624,"discussion_content":"慢慢发现后面文章还会有小的疑点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587617554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":243285,"ip_address":""},"score":244624,"extra":""}]}]},{"had_liked":false,"id":208773,"user_name":"russellyue","can_delete":false,"product_type":"c1","uid":1541894,"ip_address":"","ucode":"0758ACF772F9C1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epIMwPE6FwsicZ6bjhu7ZpWLnoib8G76sA1XL8y5W8GxqfQEjBub6g57E60mzjWzrA6icMRw1QT5CpyA/132","comment_is_top":false,"comment_ctime":1587436671,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1587436671","product_id":100017301,"comment_content":"总结：在分析一个排序算法的时候，着重要注意以下三点。第一，因为实际开发中，排序的数据通常不大，所以在针对同一阶时间复杂度的排序算法时，要考虑系数、常数和低阶的部分。比如插入排序优于冒泡排序的原因就在于，在交换元素的时候，冒泡排序需要三步操作，而插入排序只有一步操作。第二，要看是否为原地排序，也就是空间复杂度是否为O(1)。第三，要看是否是稳定排序算法。也就是在排序前后，相同值的结点前后顺序是否不变。在针对一个对象中的多个元素进行先后排序的时候，稳定排序能保证后一次排序不会影响到前一次排序。另一个重要的概念是，逆序度 = 满有序度 - 有序度。","like_count":0},{"had_liked":false,"id":208275,"user_name":"JackySong","can_delete":false,"product_type":"c1","uid":1855483,"ip_address":"","ucode":"47D976A0150839","user_header":"https://static001.geekbang.org/account/avatar/00/1c/4f/fb/716bb5e8.jpg","comment_is_top":false,"comment_ctime":1587311936,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587311936","product_id":100017301,"comment_content":"所以重点在于插入排序，另外两种冒泡和选择排序只要知道原理就行了是吧？！","like_count":0},{"had_liked":false,"id":206515,"user_name":"yoummg","can_delete":false,"product_type":"c1","uid":1067856,"ip_address":"","ucode":"1B809CFDD7A508","user_header":"https://static001.geekbang.org/account/avatar/00/10/4b/50/fdecd51a.jpg","comment_is_top":false,"comment_ctime":1586873121,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586873121","product_id":100017301,"comment_content":"第一次听到排序稳定性的正解，👍<br><br>原来清楚的知道，冒泡，插入，选择排序都是o(n*n)，但从未自己思考过其中谁的效率更优秀。<br><br>每次的三个问题，解释了这三种排序，插入 &gt; 冒泡 &gt; 选择<br><br>链表的排序，进行数据结构层面算法的对比，特别好，直接看了@双木公子的答案👍","like_count":0},{"had_liked":false,"id":206339,"user_name":"梅端","can_delete":false,"product_type":"c1","uid":1525335,"ip_address":"","ucode":"FEC08731457770","user_header":"https://static001.geekbang.org/account/avatar/00/17/46/57/fe38a6db.jpg","comment_is_top":false,"comment_ctime":1586843526,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586843526","product_id":100017301,"comment_content":"之前已经很熟悉三种常规的排序算法了，但是现在来看还是觉得获益良多，特别是老师关于每种排序算法的特点讲解那一部分，看来还需要继续深入学习才可以。","like_count":0},{"had_liked":false,"id":206106,"user_name":"亢（知行合一的路上）","can_delete":false,"product_type":"c1","uid":1347013,"ip_address":"","ucode":"958AF7C96EB9E8","user_header":"https://static001.geekbang.org/account/avatar/00/14/8d/c5/898b13b4.jpg","comment_is_top":false,"comment_ctime":1586787677,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586787677","product_id":100017301,"comment_content":"插入排序开始没写对，哈哈 得多练习啊","like_count":0},{"had_liked":false,"id":204013,"user_name":"鱿鱼先森","can_delete":false,"product_type":"c1","uid":1694627,"ip_address":"","ucode":"543FB3F2AA852B","user_header":"https://wx.qlogo.cn/mmopen/vi_32/ox4nIqvFdt77xSW2rm5QJcYPj0r10up6etUXohw47B50Giby7wexBksrpcSu3n9n7iaqGFCGt2STMkJlJgKaTzvg/132","comment_is_top":false,"comment_ctime":1586319422,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586319422","product_id":100017301,"comment_content":"选择排序算法存在的意义是什么？","like_count":0},{"had_liked":false,"id":204009,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586318629,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1586318629","product_id":100017301,"comment_content":"逆序度 = 满有序度 - 有序度。我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，从而完成排序。对排序有了新的认识。","like_count":0},{"had_liked":false,"id":203620,"user_name":"仝","can_delete":false,"product_type":"c1","uid":1806534,"ip_address":"","ucode":"BD2EA4F235EE3C","user_header":"https://static001.geekbang.org/account/avatar/00/1b/90/c6/43220b78.jpg","comment_is_top":false,"comment_ctime":1586242122,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586242122","product_id":100017301,"comment_content":"完全有序数组的 有序度n*(n-1)&#47;2  是怎么算出来的呢？  烦请老师帮忙解答下","like_count":0},{"had_liked":false,"id":202956,"user_name":"单色","can_delete":false,"product_type":"c1","uid":1907486,"ip_address":"","ucode":"A1DA6E497FD74C","user_header":"https://static001.geekbang.org/account/avatar/00/1d/1b/1e/f5c16f7e.jpg","comment_is_top":false,"comment_ctime":1586092979,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586092979","product_id":100017301,"comment_content":"老师，选择排序算法的最好时间复杂度如何分析呢呢？","like_count":0},{"had_liked":false,"id":202875,"user_name":"贵贵","can_delete":false,"product_type":"c1","uid":1196359,"ip_address":"","ucode":"97D5F277B5317D","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/47/7e4bdd7b.jpg","comment_is_top":false,"comment_ctime":1586078502,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1586078502","product_id":100017301,"comment_content":"分析方法论 - 排序算法<br>从执行效率（时间复杂度）、内存消耗（空间复杂度）、稳定性（满有序度 = 有序度 + 逆序度）三个方面入手<br>a、从实际执行考虑两个算法时，除了分析最好时间复杂、最坏时间复杂度、平均时间复杂度，还要考虑时间复杂度的系数<br>虽然两个算法的时间复杂度，空间复杂度可能是一样的，但是复杂度前面的系数K的值不一样，会导致实际执行效率的不同，因此插入排序 &gt; 冒泡排序<br>b、还要考虑：比较的次数、移动的次数<br>c、在考虑平均时间复杂度的时候，用概率这种定量的方式可能会很复杂<br>此时采用有序度的概念视角来分析问题，会更加简单明了。<br><br>当实际动手去写冒泡或者插入排序的时候，还是会发现一些问题。<br>动手最好了<br><br><br>","like_count":0},{"had_liked":false,"id":202446,"user_name":"奔跑的码仔","can_delete":false,"product_type":"c1","uid":1609871,"ip_address":"","ucode":"AB3B02B07B8B8C","user_header":"https://static001.geekbang.org/account/avatar/00/18/90/8f/9c691a5f.jpg","comment_is_top":false,"comment_ctime":1585989901,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585989901","product_id":100017301,"comment_content":"插入排序算法的实现分为:头插法和尾插法。文中所讲的是尾插法。头插法的话，最好、最坏、平局的复杂度都是O(n2)。","like_count":0},{"had_liked":false,"id":200981,"user_name":"yezi","can_delete":false,"product_type":"c1","uid":1935780,"ip_address":"","ucode":"B2E5CC51D37C44","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/AiaYGqeT5oDEUaRq2vVLOIesrnPwJH3VfN8tb3CZlAbxW9QYo6TfPqUS8c4ibAyibsn1955GK3EOJsjFFKXRbSYvA/132","comment_is_top":false,"comment_ctime":1585702634,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585702634","product_id":100017301,"comment_content":"冒泡排序仅对数组中相邻元素进行比较和交换，因此键相同的元素不会改变顺序，插入排序，输入的数据的顺序能大幅度影响它的时间复杂度","like_count":0},{"had_liked":false,"id":200642,"user_name":"蜗牛","can_delete":false,"product_type":"c1","uid":1086220,"ip_address":"","ucode":"01CC18F12E556D","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/0c/0a6a0d5e.jpg","comment_is_top":false,"comment_ctime":1585627392,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585627392","product_id":100017301,"comment_content":"可以。冒泡交换会复杂，插入减少了移动，会快一点。选择交换会复杂一点","like_count":0},{"had_liked":false,"id":195654,"user_name":"谭方敏","can_delete":false,"product_type":"c1","uid":1710960,"ip_address":"","ucode":"728DC7ECB7C902","user_header":"https://static001.geekbang.org/account/avatar/00/1a/1b/70/547042ee.jpg","comment_is_top":false,"comment_ctime":1585209628,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585209628","product_id":100017301,"comment_content":"排序算法的执行效率<br>1 最好情况，最坏情况，平均情况时间复杂度<br>有序度不同的数据，对于排序的执行时间肯定是有影响的.<br><br>2 时间复杂度的系数，常数，低阶<br>在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数，常数，低阶也考虑进来。<br><br>3 比较次数和交换(或移动)次数<br>元素比较大小，元素交换或移动。<br>在分析排序算法的执行效率的时候，应该把比较次数和交换(或移动）次数也考虑进去.<br><br>排序算法的内存消耗<br>原地排序：空间复杂度是O(1)的排序算法。<br><br><br>排序算法稳定性：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有先后顺序不变。<br><br>值相等元素在排序算法排序后，相等元素顺序没有改变，那么这就叫稳定的排序算法;反之则叫不稳定的排序算法。<br><br><br>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关<br><br>系要求。<br>如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该的位置，重复n次,就完成了n个数据<br><br>的排序工作。<br><br>冒泡排序是原地排序算法，只涉及相邻数据的交换操作，需要常量级的临时空间。<br><br>冒泡排序是稳定的排序算法，只有交换才可以改变两个元素的前后顺序。而如果相邻的两个元素大小相<br><br>等时，不做交换，不改变顺序。<br><br>冒泡排序的时间复杂度:有序，最好情况O(n）;倒序，最坏情况O(n^2).<br><br><br>有序度是数组中具有有序关系的元素对的个数。有序元素对数学表达式表示就是<br>有序元素:a[i] &lt;= a[j],如果i &lt;j.<br><br>对于一个完全有序的数组，比如1,2,3,4,5,6,有序度就是n*(n-1)&#47;2. 这种完全有序的数组的有序度叫做<br><br>满有序度.<br>对于倒序排列的数组，比如6,5,4,3,2,1,有序度是0.<br><br>逆序度定义跟有序度恰好相反。<br>逆序元素对:a[i] &gt; a[j], 如果i &lt; j.<br><br>逆序度 = 满有序度 - 有序度<br>我们排序过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。<br><br>冒泡排序包含两个操作原子，比较与交换。每交换一次，有序度就加1.<br>不管算法怎么修改，交换次数总是确定的，即为逆序度，也就是n*(n-1)&#47;2 - 初始有序度.<br><br>插入排序(Insertion Sort)<br><br>我们将数组中的数据分为两个区间，已排序区间和未排序区间。<br>初始已排序区间只有一个元素，就是数组的第一个元素。<br>插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证<br><br>已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。<br><br>插入排序也包含两种操作，一种是元素的比较，一种是元素的移动。当我们需要将一个数据a插入到已排<br><br>序区间时，需要拿a与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还<br><br>需要将插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素a插入<br><br>.<br><br>插入排序，原地排序算法，空间复杂度是O(1).<br><br>插入排序，稳定的排序算法，值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的<br><br>后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。<br><br>插入排序的时间复杂度: 有序，最好情况O(n）;倒序，最坏情况O(n^2).<br><br><br>选择排序(Selection Sort)<br>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未<br><br>排序区间中找到最小的元素，将其放到已排序区间的末尾.<br><br>选择排序空间复杂度为O(1), 属于原地排序算法，最好(坏),平均情况时间复杂度都为O(n^2).<br><br>选择排序，不稳定的排序算法，选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换<br><br>位置，这样破坏了稳定性。<br><br>冒泡排序需要3个赋值操作，而插入排序只需要1个.<br>同样时间复杂度是O(n^2)，插入排序优于冒泡排序。<br><br>             是原地排序?  是否稳定？   最好  最坏  平均<br><br>冒泡排序      是           是          O(n)  O(n^2) O(n^2)<br><br>插入排序      是           是          O(n)  O(n^2) O(n^2)<br><br>选择排序      是           否          O(n^2) O(n^2) O(n^2)<br><br>问题1.<br>排序算法还能工作，原来用下标访问，用链表的话，要选择用next指针，或者用快慢指针，或者前驱和后继指针访问。需要重新实现而已.<br><br>问题2：<br>无论是链表还是数组，三种排序的比较和交换次数并没有改变，所以最好(坏)平均情况时间复杂度均未变.<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>","like_count":0},{"had_liked":false,"id":192286,"user_name":"獨自去遠方","can_delete":false,"product_type":"c1","uid":1503941,"ip_address":"","ucode":"E246B33F397441","user_header":"https://static001.geekbang.org/account/avatar/00/16/f2/c5/2a441c27.jpg","comment_is_top":false,"comment_ctime":1584845425,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584845425","product_id":100017301,"comment_content":"排序（上）<br><br>\t？更多使用插入排序而非冒泡排序<br>\t\t数据移动比数据交换更加高效<br><br>\t评价、分析排序算法<br>\t\t执行效率<br>\t\t\t1.最好情况、最坏情况、平均情况时间复杂度<br>\t\t\t2.时间复杂度的系数、常数、低阶<br>\t\t\t3.比较次数和移动次数<br>\t\t内存消耗<br>\t\t\t原地排序O(1)<br>\t\t稳定性<br>\t\t\t排序之后，相同元素的先后顺序不变--&gt;稳定的排序算法<br>\t\t有序度<br>\t\t\t有序关系的元素对的个数<br>\t\t\t逆序度=满有序度-有序度<br>\t冒泡排序<br>\t\t原地排序<br>\t\t稳定的排序算法<br>\t\t时间复杂度<br>\t\t\t最好O(n)<br>\t\t\t最坏O(n平方)<br>\t\t有序度<br>\t\t\t交换<br>\t\t\t\t交换一次，有序度增加1<br>\t\t\t\t逆序度取平均值：n*(n-1)&#47;4<br>\t\t\t\t平均情况时间复杂度：O(n平方)<br>\t\t\t比较<br>\t\t\t\t比较比交换操作多，取上限 O(n平方)<br><br>\t\t停止条件<br>\t\t\t外层循环一次交换都没有发生<br><br>\t插入排序<br>\t\t已排序区间\t未排序区间<br>\t\t未排序区间取出元素，与已排序区间比较并插入<br>\t\t比较的时候从后往前比较<br><br>\t\t原地排序<br>\t\t稳定的排序算法<br>\t\t时间复杂度<br>\t\t\t最好O(n)<br>\t\t\t最坏O(n平方)<br>\t\t移动次数等于逆序度<br>\t\t\t插入操作，需要移动后面元素<br><br><br><br>\t选择排序<br>\t\t已排序区间\t未排序区间<br>\t\t从未排序区间找到最小元素，放到已排序区间的末尾<br><br>\t\t原地排序<br>\t\t不是稳定的排序算法<br>\t\t时间复杂度<br>\t\t\t最坏情况和平均情况时间复杂度都为 O(n平方)<br><br>","like_count":0},{"had_liked":false,"id":191177,"user_name":"雨落千木的时节","can_delete":false,"product_type":"c1","uid":1796430,"ip_address":"","ucode":"A268063299F0D6","user_header":"https://static001.geekbang.org/account/avatar/00/1b/69/4e/7ef7604b.jpg","comment_is_top":false,"comment_ctime":1584752693,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584752693","product_id":100017301,"comment_content":"插入排序是稳定的排序算法，数据操作次数比冒泡排序少，学习了","like_count":0},{"had_liked":false,"id":189898,"user_name":"侯代烨","can_delete":false,"product_type":"c1","uid":1327868,"ip_address":"","ucode":"77C83CB1858DE7","user_header":"https://static001.geekbang.org/account/avatar/00/14/42/fc/c89243d8.jpg","comment_is_top":false,"comment_ctime":1584580777,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584580777","product_id":100017301,"comment_content":"还是得多刷几遍","like_count":0},{"had_liked":false,"id":189135,"user_name":"james","can_delete":false,"product_type":"c1","uid":1232771,"ip_address":"","ucode":"AC42035106E5B9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/yyibGRYCArsUNBfCAEAibua09Yb9D5AdO8TkCmXymhAepibqmlz0hzg06ggBLxyvXicnjqFVGr7zYF0rQoZ0aXCBAg/132","comment_is_top":false,"comment_ctime":1584458472,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1584458472","product_id":100017301,"comment_content":"总结<br><br>一、排序方法与复杂度归类<br>（1）几种最经典、最常用的排序方法：冒泡排序、插入排序、选择排序、快速排序、归并排序、计数排序、基数排序、桶排序。<br>（2）复杂度归类<br>冒泡排序、插入排序、选择排序 O(n^2)<br>快速排序、归并排序 O(nlogn)<br>计数排序、基数排序、桶排序 O(n)<br><br>二、如何分析一个“排序算法”？<br>&lt;1&gt;算法的执行效率<br>1. 最好、最坏、平均情况时间复杂度。<br>2. 时间复杂度的系数、常数和低阶。<br>3. 比较次数，交换（或移动）次数。<br>&lt;2&gt;排序算法的稳定性<br>1. 稳定性概念：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。<br>2. 稳定性重要性：可针对对象的多种属性进行有优先级的排序。<br>3. 举例：给电商交易系统中的“订单”排序，按照金额大小对订单数据排序，对于相同金额的订单以下单时间早晚排序。用稳定排序算法可简洁地解决。先按照下单时间给订单排序，排序完成后用稳定排序算法按照订单金额重新排序。<br>&lt;3&gt;排序算法的内存损耗<br>原地排序算法：特指空间复杂度是O(1)的排序算法。<br><br>三、冒泡排序<br>       冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求，如果不满足就让它俩互换。<br>稳定性：冒泡排序是稳定的排序算法。<br>空间复杂度：冒泡排序是原地排序算法。<br>时间复杂度：<br>1. 最好情况（满有序度）：O(n)。<br>2. 最坏情况（满逆序度）：O(n^2)。<br>3. 平均情况：<br>       “有序度”和“逆序度”：对于一个不完全有序的数组，如4，5，6，3，2，1，有序元素对为3个（4，5），（4，6），（5，6），有序度为3，逆序度为12；对于一个完全有序的数组，如1，2，3，4，5，6，有序度就是n*(n-1)&#47;2，也就是15，称作满有序度；逆序度=满有序度-有序度；冒泡排序、插入排序交换（或移动）次数=逆序度。<br>       最好情况下初始有序度为n*(n-1)&#47;2，最坏情况下初始有序度为0，则平均初始有序度为n*(n-1)&#47;4，即交换次数为n*(n-1)&#47;4，因交换次数&lt;比较次数&lt;最坏情况时间复杂度，所以平均时间复杂度为O(n^2)。<br><br>四、插入排序<br>       插入排序将数组数据分成已排序区间和未排序区间。初始已排序区间只有一个元素，即数组第一个元素。在未排序区间取出一个元素插入到已排序区间的合适位置，直到未排序区间为空。<br>空间复杂度：插入排序是原地排序算法。<br>时间复杂度：<br>1. 最好情况：O(n)。<br>2. 最坏情况：O(n^2)。<br>3. 平均情况：O(n^2)（往数组中插入一个数的平均时间复杂度是O(n)，一共重复n次）。<br>稳定性：插入排序是稳定的排序算法。<br><br>五、选择排序<br>       选择排序将数组分成已排序区间和未排序区间。初始已排序区间为空。每次从未排序区间中选出最小的元素插入已排序区间的末尾，直到未排序区间为空。<br>空间复杂度：选择排序是原地排序算法。<br>时间复杂度：（都是O(n^2)）<br>1. 最好情况：O(n^2)。<br>2. 最坏情况：O(n^2)。<br>3. 平均情况：O(n^2)。<br>稳定性：选择排序不是稳定的排序算法。<br><br>思考<br>       选择排序和插入排序的时间复杂度相同，都是O(n^2)，在实际的软件开发中，为什么我们更倾向于使用插入排序而不是冒泡排序算法呢？<br>       答：从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要3个赋值操作，而插入排序只需要1个，所以在对相同数组进行排序时，冒泡排序的运行时间理论上要长于插入排序。","like_count":0},{"had_liked":false,"id":188798,"user_name":"Frode","can_delete":false,"product_type":"c1","uid":1503064,"ip_address":"","ucode":"B7B8DBF9980EA1","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/58/d05ec302.jpg","comment_is_top":false,"comment_ctime":1584416670,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584416670","product_id":100017301,"comment_content":"选择排序-Java实现<br>private static void sort(int[] arr, int n) {<br>        if (n &lt; 1) return;<br>        for (int i = 0; i &lt; n; i++) {<br>            int k = i;<br>            for (int j = i; j &lt; n; j++) {<br>                if (arr[j] &lt; arr[k]) {<br>                    k = j;<br>                }<br>            }<br>            if (k != i) {<br>                int temp = arr[i];<br>                arr[i] = arr[k];<br>                arr[k] = temp;<br>            }<br>        }<br>    }","like_count":0},{"had_liked":false,"id":187453,"user_name":"老周聊架构","can_delete":false,"product_type":"c1","uid":1450331,"ip_address":"","ucode":"4121EDBAE73002","user_header":"https://static001.geekbang.org/account/avatar/00/16/21/5b/7add72c0.jpg","comment_is_top":false,"comment_ctime":1584112966,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584112966","product_id":100017301,"comment_content":"https:&#47;&#47;blog.csdn.net&#47;riemann_&#47;article&#47;details&#47;103205043 <br>根据看的文章我对十大排序算法的总结","like_count":0},{"had_liked":false,"id":183168,"user_name":"Eternal","can_delete":false,"product_type":"c1","uid":1188023,"ip_address":"","ucode":"EA6FE7CC98F740","user_header":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","comment_is_top":false,"comment_ctime":1582965315,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582965315","product_id":100017301,"comment_content":"想到两个有意思的点<br>第一个：<br>插入排序和选择排序都是要区分已经有序和未排序的两段。<br>插入排序是每次从未排序种取一个节点在已经有序的段中找到合适的位置插入；<br>选择排序是每次从未排序中选择一个最小的直接放到已经排序的末尾；<br>插入和选择感觉有点互为相反的思想，选择排序不稳定，插入排序稳定<br><br>第二个：<br>1.冒泡排序和插入排序最坏的时间复杂度都是O(n2),这个是理论的极限值。当具体到一个具体的问题的时候，比如1000，50000个数字的时候，冒泡需要三个赋值操作，插入只需要一个赋值操作，实际耗费时间，冒泡远远多于插入。我想到的是，一般情况大家都会用分析法来比较两个算法的时间复杂度，这都是理论的，我以前也一直都是这样思考的，但是用真实代码+实际数据测试来得到实践的数据的例子提醒我了，理论只能初略估算，实践验证才是最终答案。","like_count":0},{"had_liked":false,"id":182373,"user_name":"发霉的宅大人","can_delete":false,"product_type":"c1","uid":1738243,"ip_address":"","ucode":"6757E30FE5E48D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/03/95004954.jpg","comment_is_top":false,"comment_ctime":1582775285,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582775285","product_id":100017301,"comment_content":"思考题：<br>都可以实现，只不过因为需要比较交换，所以我们要用到3个指针，front，mid，rear。mid和rear比较的。再借用front进行交换位置。<br>如果是双向链表的话就可以简单一些。","like_count":0},{"had_liked":false,"id":180676,"user_name":"斐波那契","can_delete":false,"product_type":"c1","uid":1464006,"ip_address":"","ucode":"85E2EBC01392B1","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/c6/0b449bc6.jpg","comment_is_top":false,"comment_ctime":1582362762,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582362762","product_id":100017301,"comment_content":"冒泡排序里交换用到了第三个临时变量 以前遇到一个题目就是在不使用第三个变量实现两个数交换","like_count":0},{"had_liked":false,"id":180642,"user_name":"拾迹","can_delete":false,"product_type":"c1","uid":1025093,"ip_address":"","ucode":"38F367B77FF2D7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/45/3cb5cdc6.jpg","comment_is_top":false,"comment_ctime":1582357787,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1582357787","product_id":100017301,"comment_content":"老师，有个疑问：就是您举得那个稳定性排序的例子感觉有点牵强，因为其实现实开发中，肯定不会去触发两次排序的，而且评论里有同学也支持可以通过加权的方式一次排序即可。我在想稳定性排序是不是关键在于能够减少元素移动的次数，但是感觉也说服不了自己，而且也没想到现实中有相应的例子。只能说这只是排序算法的一个特点而已，并不能说稳定的就好，不稳定的就不好，具体场景选择相应的算法，稳定性作为一个比较重要的考量点。","like_count":0},{"had_liked":false,"id":180577,"user_name":"拾迹","can_delete":false,"product_type":"c1","uid":1025093,"ip_address":"","ucode":"38F367B77FF2D7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/45/3cb5cdc6.jpg","comment_is_top":false,"comment_ctime":1582340496,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1582340496","product_id":100017301,"comment_content":"老师，选择排序是一个非稳定排序。如果我们结合插入排序的话，每次从未排序空间里找第一个最小值，然后插到已排序空间，这样是不是就可以变成稳定排序了。","like_count":0},{"had_liked":false,"id":179588,"user_name":"红桃K-","can_delete":false,"product_type":"c1","uid":1686409,"ip_address":"","ucode":"2B6B71EEF1F07F","user_header":"https://static001.geekbang.org/account/avatar/00/19/bb/89/c080540d.jpg","comment_is_top":false,"comment_ctime":1582035160,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582035160","product_id":100017301,"comment_content":"用我的想法憋出来的代码，写完之后就有点看不懂老师写的了... 陷入自己的思维里无法自拔<br>public void insertionSort(int[] a, int n) {<br>        if (n &lt;= 1) return;<br>        for (int i = 0; i &lt; n - 1; i++) {   &#47;&#47;i代表有序区间的最后一个数据下标<br><br>            for (int j = i + 1; j &gt; 0; j--) {<br>                if (a[j] &lt; a[j - 1]) {<br>                    int less = a[j];<br>                    a[j] = a[j - 1];<br>                    a[j - 1] = less;<br>                } else {<br>                    break;<br>                }<br>            }<br>        }<br>    }","like_count":0},{"had_liked":false,"id":178584,"user_name":"一只独立特行的猪","can_delete":false,"product_type":"c1","uid":1473358,"ip_address":"","ucode":"52263607CCBE6F","user_header":"https://static001.geekbang.org/account/avatar/00/16/7b/4e/73a9deec.jpg","comment_is_top":false,"comment_ctime":1581751906,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581751906","product_id":100017301,"comment_content":"插入排序的最好情况下的时间复杂度是O(n)，为什么从尾部开始遍历，对于已经排序好的数组，文中的代码可以实现O(n)的时间复杂度吗？","like_count":0},{"had_liked":false,"id":178543,"user_name":"王jojo","can_delete":false,"product_type":"c1","uid":1812840,"ip_address":"","ucode":"1ABE7FA2614F86","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/68/ec442a70.jpg","comment_is_top":false,"comment_ctime":1581738049,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581738049","product_id":100017301,"comment_content":"课后那道题想了一下,链表实现这个三个排序在复杂度上可能与数组差不多, 选择排序没有明显差别, 插入不用移动数据了, 冒泡的话交换结点有的说会复杂我试了一下还好吧","like_count":0},{"had_liked":false,"id":178411,"user_name":"czh","can_delete":false,"product_type":"c1","uid":1159078,"ip_address":"","ucode":"649FE5C9269D69","user_header":"https://static001.geekbang.org/account/avatar/00/11/af/a6/3f15ba2f.jpg","comment_is_top":false,"comment_ctime":1581681875,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581681875","product_id":100017301,"comment_content":"基本操作：比较次数来计算复杂度，而不是不交换或插入","like_count":0},{"had_liked":false,"id":178039,"user_name":"Robert","can_delete":false,"product_type":"c1","uid":1036870,"ip_address":"","ucode":"AF2A0EFDD3ADF9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d2/46/16d36cf7.jpg","comment_is_top":false,"comment_ctime":1581577118,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581577118","product_id":100017301,"comment_content":"希尔排序的图解分析，博主写的还是很不错的https:&#47;&#47;blog.csdn.net&#47;qq_39207948&#47;article&#47;details&#47;80006224","like_count":0},{"had_liked":false,"id":176494,"user_name":"郭建伟","can_delete":false,"product_type":"c1","uid":1370608,"ip_address":"","ucode":"816487A84A2FDA","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ4QCWqGgMN4iauCdWAcaiaowSr4u9Omgf5f6JLjTtBrxzN4JlMXaERd8sfEEmicgsxJA8f0tgFIHKGw/132","comment_is_top":false,"comment_ctime":1581071699,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581071699","product_id":100017301,"comment_content":"选择排序JAVA版。<br><br>public class SelectionSort {<br>    public void sort(int[] array) {<br>        if (array == null || array.length &lt; 2) return;<br>        for (int i = 0; i &lt; array.length - 1; i++) {<br>            int minIndex = i;<br>            for (int j = i + 1; j &lt; array.length; j++) {<br>                if (array[j] &lt; array[minIndex]) {<br>                    minIndex = j;<br>                }<br>            }<br>            swap(array, i, minIndex);<br>        }<br>    }<br><br>    private void swap(int[] array, int firstIndex, int secondIndex) {<br>        int tmp = array[firstIndex];<br>        array[firstIndex] = array[secondIndex];<br>        array[secondIndex] = tmp;<br>    }<br>}","like_count":0},{"had_liked":false,"id":173108,"user_name":"Geek_256e80","can_delete":false,"product_type":"c1","uid":1805157,"ip_address":"","ucode":"37F6425A005F76","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3pP1iaBmkdXtbo6VS7B8xJBbxXFXNBWcwm1dWzd53s94o4wBUwhaZDdavialVVMprNpeLhEFpHzspNMFOGWxV8Vg/132","comment_is_top":false,"comment_ctime":1579425091,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579425091","product_id":100017301,"comment_content":"1.插入排序的代码有一定的问题，为3,2,1时，代码输出为2，3，1<br>2总结下：冒泡排序的的最差为n!,即为n2<br>2算法使用要根据业务场景，要结合具体需求来实现，对于算法问题的情况下，插入排序大于冒泡排序<br>","like_count":0},{"had_liked":false,"id":171921,"user_name":"搬铁少年ai","can_delete":false,"product_type":"c1","uid":1031045,"ip_address":"","ucode":"01D4A830A088D7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bb/85/191eea69.jpg","comment_is_top":false,"comment_ctime":1579053531,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579053531","product_id":100017301,"comment_content":"选择排序的时间复杂度分析<br><br>需要进行n-1次循环，每次循环1次交换<br>n-i次比较，所以是(n-1)(n-i+1)，大约为n2，是这样吗老师","like_count":0},{"had_liked":false,"id":171087,"user_name":"Attract","can_delete":false,"product_type":"c1","uid":1112638,"ip_address":"","ucode":"DEB10AF9AB5A41","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/3e/92d74b38.jpg","comment_is_top":false,"comment_ctime":1578841870,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578841870","product_id":100017301,"comment_content":"在实际项目中稳定排序算法很有用诶，我以前都没用过这个算法，属于我不知道我不知道的内容，这周一定要自己写两次，来熟悉熟悉，感谢老师","like_count":0},{"had_liked":false,"id":170391,"user_name":"pikachu122","can_delete":false,"product_type":"c1","uid":1689365,"ip_address":"","ucode":"43FE4DBC872FFA","user_header":"https://static001.geekbang.org/account/avatar/00/19/c7/15/24bf166a.jpg","comment_is_top":false,"comment_ctime":1578584285,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578584285","product_id":100017301,"comment_content":"Day4<br>学习课程：《数据结构与算法之美》<br>章节：11.排序（上）<br>总结：<br>1、冒泡排序：遍历整个数组，比较所有相邻的两个元素，如果它们不满足大小关系，就将它们交换。当某次冒泡没有数据交换时，说明达到了完全有序，此时不再执行后续冒泡。冒泡排序是原地排序，具有稳定性，时间复杂度最好为O(N)（数组完全有序），最差为O(N^2)（数组倒序）。<br>2、为了分析冒泡排序的平均复杂度，提出了有序度和逆序度的概念。有序度就是数组中有序关系的元素对数。逆序度的定义与之相反。逆序度=N(N-1)&#47;2-有序度。冒泡排序中元素交换的次数就是逆序度。平均情况下需要N(N-1)&#47;4次交换，因此平均复杂度为O（N^2)。<br>3、插入排序：将数组分为已排序和未排序两块。初始的已排序区间为第一个元素，其余为未排序区间。每次将未排序区间的第一个元素插入到已排序区间中的合适位置。插入排序是原地排序，具有稳定性。它的最好时间复杂度为O(N)（数组完全有序），最坏时间复杂度为O(N^2)（数组倒序）。平均时间复杂度为O(N^2)。<br>4、选择排序：与插入排序类似将数组分为两块，不过一开始已排序区间为空。每次遍历未排序区间，找到最小值，与未排序区间的第一个元素交换位置。该排序是原地排序，但是并不是稳定的排序算法。它的最好、最坏、平均时间复杂度都为O(N^2)。<br>5、冒泡排序和插入排序的时间复杂度一样，但是冒泡排序的数据交换需要进行3个赋值操作，而插入排序只需要进行1个。因此实际测试中插入排序的用时比冒泡排序更快，在实际应用中更为广泛。<br>6、课后思考：在链表中，这三种算法可以工作。它们的比较次数与数组实现相同，但除了插入排序外，另两种交换时所需的步骤更加复杂，插入排序不需要数组后移，时间复杂度系数更小。因此对于链表实现的结构，插入排序比冒泡排序的时间优势进一步扩大。","like_count":0},{"had_liked":false,"id":170384,"user_name":"pikachu122","can_delete":false,"product_type":"c1","uid":1689365,"ip_address":"","ucode":"43FE4DBC872FFA","user_header":"https://static001.geekbang.org/account/avatar/00/19/c7/15/24bf166a.jpg","comment_is_top":false,"comment_ctime":1578583529,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1578583529","product_id":100017301,"comment_content":"我有一个问题：如果选择排序中，未排序区段内找到的最小元素不是与未排序区段的第一个元素交换，而是像插入排序那样插在已排序区段的末尾，所有元素向后移一位，这样不就可以具有稳定性了吗？","like_count":0,"discussions":[{"author":{"id":1689365,"avatar":"https://static001.geekbang.org/account/avatar/00/19/c7/15/24bf166a.jpg","nickname":"pikachu122","note":"","ucode":"43FE4DBC872FFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":127742,"discussion_content":"比如老师例子中的5 8 5 2 9 第一次找出2，不与5交换位置而是直接插在第一个5的前面 变成2 5 8 5 9。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578583758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1686409,"avatar":"https://static001.geekbang.org/account/avatar/00/19/bb/89/c080540d.jpg","nickname":"红桃K-","note":"","ucode":"2B6B71EEF1F07F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1689365,"avatar":"https://static001.geekbang.org/account/avatar/00/19/c7/15/24bf166a.jpg","nickname":"pikachu122","note":"","ucode":"43FE4DBC872FFA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":176584,"discussion_content":"这样的话效率太低了呀，你放在第一个位置，那么后续的数据都要向后搬移","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582037880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":127742,"ip_address":""},"score":176584,"extra":""}]}]},{"had_liked":false,"id":167299,"user_name":"高学义","can_delete":false,"product_type":"c1","uid":1321934,"ip_address":"","ucode":"4B1AA896B567B2","user_header":"https://static001.geekbang.org/account/avatar/00/14/2b/ce/15a82b5c.jpg","comment_is_top":false,"comment_ctime":1577758889,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1577758889","product_id":100017301,"comment_content":"选择排序在一趟遍历完成后，如果发现已经是有序的，可以终止后续的各趟遍历，这样最好情况的时间复杂度不是O（n）吗，请指教。","like_count":0,"discussions":[{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163384,"discussion_content":"是的，不过也只有满序时才是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581075630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165289,"user_name":"耀","can_delete":false,"product_type":"c1","uid":1634462,"ip_address":"","ucode":"3692BEC242A399","user_header":"https://static001.geekbang.org/account/avatar/00/18/f0/9e/cf6570f7.jpg","comment_is_top":false,"comment_ctime":1577194278,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577194278","product_id":100017301,"comment_content":"以前学的排序算法都没去注意算法的稳定性，虽然也知道算法的复杂度，但是真没有有认真的计算过平均复杂度，以前就是很简单的以为是最好和最差只和除2，还是和最差一样。课程中给出了基于概率的思想计算平均复杂度，是一种更为准确方法。","like_count":0},{"had_liked":false,"id":164252,"user_name":"德鲁大叔","can_delete":false,"product_type":"c1","uid":1773278,"ip_address":"","ucode":"DEF7B044BB756A","user_header":"https://static001.geekbang.org/account/avatar/00/1b/0e/de/58e87ee4.jpg","comment_is_top":false,"comment_ctime":1576916893,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576916893","product_id":100017301,"comment_content":"老师，单链表插入排序比较次数应该是数组的2倍吧","like_count":0},{"had_liked":false,"id":163468,"user_name":"编程海中的🐟","can_delete":false,"product_type":"c1","uid":1623347,"ip_address":"","ucode":"3EB9ADD94F4093","user_header":"https://static001.geekbang.org/account/avatar/00/18/c5/33/8889014b.jpg","comment_is_top":false,"comment_ctime":1576726744,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1576726744","product_id":100017301,"comment_content":"我觉得选择排序是不是稳定，还是取决代码如何写。","like_count":0,"discussions":[{"author":{"id":1528610,"avatar":"https://static001.geekbang.org/account/avatar/00/17/53/22/cce9a2e5.jpg","nickname":"naku","note":"","ucode":"B49EF5B5B38400","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":210123,"discussion_content":"咋写稳定","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584709228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163451,"user_name":"无始","can_delete":false,"product_type":"c1","uid":1758577,"ip_address":"","ucode":"B96982583496B1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d5/71/308fe8a4.jpg","comment_is_top":false,"comment_ctime":1576724628,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576724628","product_id":100017301,"comment_content":"https:&#47;&#47;github.com&#47;JinYuan91&#47;javabasis&#47;blob&#47;master&#47;java-basis-datastructure&#47;src&#47;main&#47;java&#47;com&#47;java&#47;basis&#47;datastructure&#47;sort&#47;Dubble.java<br><br>https:&#47;&#47;github.com&#47;JinYuan91&#47;javabasis&#47;blob&#47;master&#47;java-basis-datastructure&#47;src&#47;main&#47;java&#47;com&#47;java&#47;basis&#47;datastructure&#47;sort&#47;Insert.java<br><br>冒泡插入自己简单实现了一下","like_count":0},{"had_liked":false,"id":163007,"user_name":"会飞的鱼","can_delete":false,"product_type":"c1","uid":1156926,"ip_address":"","ucode":"CDCFBFE03C48BD","user_header":"https://static001.geekbang.org/account/avatar/00/11/a7/3e/a00cfbde.jpg","comment_is_top":false,"comment_ctime":1576639443,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1576639443","product_id":100017301,"comment_content":"老师，冒泡排序的空间复杂度为什么是O(1)呢？<br>代码交换元素的次数是逆序度，也就是要执行逆序度次int tmp = a[j];<br>按照您计算平均时间复杂度的分析，平均情况下需要 n*(n-1)&#47;4 次交换操作，那不就是O(n的平方)的空间复杂度吗？","like_count":0,"discussions":[{"author":{"id":1686409,"avatar":"https://static001.geekbang.org/account/avatar/00/19/bb/89/c080540d.jpg","nickname":"红桃K-","note":"","ucode":"2B6B71EEF1F07F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":176592,"discussion_content":"流水的数据，单一的空间呀。tmp就是那个tmp，只不过每次交换存的数据不一样喽","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582038003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161623,"user_name":"猫切切切切切","can_delete":false,"product_type":"c1","uid":1075033,"ip_address":"","ucode":"F350BA1B7FFDC4","user_header":"https://static001.geekbang.org/account/avatar/00/10/67/59/017b5726.jpg","comment_is_top":false,"comment_ctime":1576251675,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576251675","product_id":100017301,"comment_content":"预设链表节点的值在排序过程中是不可改动的，<br>因为链表节点可能被引用。<br><br>基于比较的排序，过程中要么交换要么移动；<br>而链表相对于数组，交换较复杂，移动较简单。<br><br>又因为：<br>冒泡排序是交换的过程，<br>插入排序是移动的过程，<br>选择排序也是交换的过程。<br><br>所以链表相对于数组：<br>冒泡排序各项时间&#47;空间复杂度都不变，如果考虑系数，则时间复杂度变大（因为交换较复杂）；<br>插入排序各项时间&#47;空间复杂度都不变，如果考虑系数，则时间复杂度变小（因为移动较简单）；<br>选择排序同冒泡。<br>","like_count":0},{"had_liked":false,"id":161004,"user_name":"赤云","can_delete":false,"product_type":"c1","uid":1093258,"ip_address":"","ucode":"67476D582D8B6A","user_header":"https://static001.geekbang.org/account/avatar/00/10/ae/8a/e67def95.jpg","comment_is_top":false,"comment_ctime":1576076484,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576076484","product_id":100017301,"comment_content":"有序度：待排数据的初始有序数<br>满有序度：排序后的有序数<br>逆序度：满有序度-有序度<br>排序算法的交换数为逆序度","like_count":0},{"had_liked":false,"id":159759,"user_name":"第四单元","can_delete":false,"product_type":"c1","uid":1747184,"ip_address":"","ucode":"3ED9D553E1DE17","user_header":"https://static001.geekbang.org/account/avatar/00/1a/a8/f0/529f15e9.jpg","comment_is_top":false,"comment_ctime":1575781111,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575781111","product_id":100017301,"comment_content":"讨论稳定性那里，先按金额再按时间排序的那个例子，是不是也可以这么实现：使用一种稳定的排序算法进行排序，其中比较的规则定义为：先按金额比较，金额相同时按时间比较。大家怎么看？","like_count":0},{"had_liked":false,"id":159628,"user_name":"技术修行者","can_delete":false,"product_type":"c1","uid":1013147,"ip_address":"","ucode":"28CA41A1214D6B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/9b/611e74ab.jpg","comment_is_top":false,"comment_ctime":1575708592,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1575708592","product_id":100017301,"comment_content":"思维导图：https:&#47;&#47;mubu.com&#47;doc&#47;iGeQ3EmbA0<br><br>思考题：<br>1. 考虑排序过程中的操作：比较和移动（数据交换），这两种操作和底层数据的存储形式关系不大。<br>2. 对于链表形式的线性表排序，如果链表元素的值可以改动，那么本章中涉及的排序算法的整体时间复杂度和数组形式的线性表没有区别。","like_count":0},{"had_liked":false,"id":159565,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1575686774,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575686774","product_id":100017301,"comment_content":"（1）排序中最经典的排序算法：<br>\t冒泡排序，插入排序，选择排序，归并排序，快速排序，计数排序，计数排序，桶排序。<br><br>（2）“排序算法”分析：<br>\tA：排序算法的执行效率：<br>\t\t1，最好情况，最坏情况，平均情况时间复杂度<br>\t\t2，时间复杂度的系数，常数，低阶<br>\t\t3，比较次数和交换（或移动）次数\t<br>\tB：排序算法的内存消耗：<br>\t\t1，算法的内存消耗可以通过空间复杂度来衡量，针对排序算法的空间复杂度，引入了：原地排序（Sorted in place）概念。<br>\t\t2，原地排序算法：特征空间复杂度是O(1)的排序算法。<br>\tC：排序算法的稳定性<br>\t\t1，针对排序算法，还有一个重要的度量指标：稳定性。<br>\t\t2，稳定性：若待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。<br>（3）冒泡排序（Bubble Sort）<br>\t1，执行流程：<br>\t\ta，冒泡排序只会操作相邻的两个数据。<br>\t\tb，每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。<br>\t\tc，如果不满足，就让相邻的两个元素互相交换。<br>\t\td，一次冒泡会让至少一个元素移动到它应该在的位置，重复n次，就完成n个数据的排序工作。<br>\t<br>\t2，算法分析：<br>\t\ta，是原地排序算法吗？<br>\t\t冒泡的过程中只涉及相邻数据的交换操作，只需要常量级的临时空间，所以空间复杂度为O(1)，是一个原地排序算法。<br><br>\t\tb，是稳定的排序算法吗？<br>\t\t\t*：在冒泡排序过程中，只有交换才可以改变两个元素的前后顺序。<br>\t\t\t*：在排序过程中，当相邻的两个元素大小相等时，我不做交换，相等的数据在排序前后，不会被改变顺序，所以冒泡排序是稳定的排序算法。<br><br>\t\tc，时间复杂度是多少？<br>\t\t\t*：最好情况下，要排序的数据已经有序，只需要进行一次冒泡操作，所以最好的是O(n)。<br>\t\t\t*：最坏情况下，要排序的数据刚好是倒序，需要进行n次冒泡排序，所以最坏的是O(n^2)。<br>\t\t\t*：平均情况，平均情况下需要n*(n-1)&#47;4次交换操作，比较操作肯定要比交换操作多，而复杂度上限是O(n^2)，所以平均情况下，时间复杂度就是O(n^2)。<br><br>（4）插入排序（Insertion Sort）<br>\t1，插入排序讲数组中的数据分为两个区间，已排序区间和未排序区间。<br>\t<br>2，插入排序的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。<br>\t<br>\t3，执行流程：<br>a. 插入排序也包含两种操作，一种是元素的比较，一种是元素的移动。<br>\t\t<br>b. 当我们需要将一个数据a插入到已排序区间时，需要拿a与已排序区间的元素依次比较大小，找到合适的插入位置。<br><br>c. 找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置。<br><br>d. 对于不同的查找插入点方法（从头到尾，从尾到头），元素的比较次数是有区别的。但对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度。<br><br>4，算法分析:<br>\t第一：插入排序是原地排序算法吗？<br>\t\t从实现过程可以很明显的看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是O(1)。<br>\t<br>\t第二：插入排序是稳定的排序的算法吗？<br>\t\t在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面。<br>\t<br>\t第三：查入排序的时间复杂度是多少？<br>\t\t若数据是有序的，就不需要搬移任何数据。如果从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能插入的位置。所以这种情况下，最好是时间复杂度为O(n)。<br>\t\t最坏情况时间复杂度为O(n^2)<br>                平均时间复杂度为O(n^2)<br><br>(5) 选择排序（Selection Sort）<br>\t1 选择排序算法的实现思路有点类似排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。<br>\t2，空间复杂度也是O(1),时间复杂度，最坏和平均时间复杂度都为O(n^2)。<br>\t3，选择排序不是一种稳定的排序算法。\t<br>\t（6）使用选择排序，而不是冒泡排序的原因是：<br>\t\t虽然两者的时间复杂度都是O(n^2),都是原地排序算法，但<br>\t\t1，冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆向度。插入排序是同样的，不管如何优化，元素移动的次数也等于原始数据的逆序度。<br>\t\t2，但是从代码实现上看，冒泡排序的数据交换要比插入排序的时间移动要复杂，冒泡排序需要3个赋值操作，而插入排序只需要1个。消耗的时间要更多。<br>","like_count":0},{"had_liked":false,"id":159514,"user_name":"big智慧","can_delete":false,"product_type":"c1","uid":1202616,"ip_address":"","ucode":"272C32E19EAE1A","user_header":"https://static001.geekbang.org/account/avatar/00/12/59/b8/2a4624c3.jpg","comment_is_top":false,"comment_ctime":1575643999,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575643999","product_id":100017301,"comment_content":"打卡Day9：<br>1、日期：<br>* 2019年12月3日<br><br>2、是什么：<br>* 时间复杂度为O(n*n)的排序算法：冒泡排序、插入排序、选择排序<br><br>3、为什么：<br>* 执行效率：在不同数据有序度、不同规模下判断最好、最坏、平均时间复杂度，同时分析移动的次数 <br>* 内存的消耗：可以分析空间复杂度 <br>* 稳定性分析：排序前后相同的值的顺序是否会改变   <br>4、递归在工作中类似的场景：<br>* 分析项目成功与否，最重要的是交付结果，但是要分析投入的时间，投入的资源情况，还要看新项目是否影响历史项目的数据或者功能。从不同的维度看项目是否真的成功了。 <br><br>5、关注点：<br>* 关注点：分析维度、前后对比 ","like_count":0},{"had_liked":false,"id":159321,"user_name":"Ronnyz","can_delete":false,"product_type":"c1","uid":1488280,"ip_address":"","ucode":"9F34527B1D343D","user_header":"https://static001.geekbang.org/account/avatar/00/16/b5/98/ffaf2aca.jpg","comment_is_top":false,"comment_ctime":1575598870,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575598870","product_id":100017301,"comment_content":"存储在链表中的话，交换起来会比较复杂","like_count":0},{"had_liked":false,"id":158989,"user_name":"SteveYang","can_delete":false,"product_type":"c1","uid":1754829,"ip_address":"","ucode":"C42BCA4F40A9EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKCbnOvEatUN4ysE2cl6zJNoAJVXXuQVhicQ1jxh6Z2Towrmmc1I6PndaicuQQ0RyyJPyJQicv4tSib9Q/132","comment_is_top":false,"comment_ctime":1575511649,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575511649","product_id":100017301,"comment_content":"对链表排序，交换操作会更加复杂，插入操作会更加简单，空间复杂度没有变化，时间复杂度没有明显变化，相对来说对插入排序少了移动会省点时间，对冒泡排序和选择排序由于交换操作更加复杂会更耗时点。","like_count":0},{"had_liked":false,"id":158497,"user_name":"百里","can_delete":false,"product_type":"c1","uid":1212873,"ip_address":"","ucode":"2CE96129AA7F78","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/c9/9194612b.jpg","comment_is_top":false,"comment_ctime":1575385284,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575385284","product_id":100017301,"comment_content":"实际开发中插入排序的前半部分有序,是存在优化空间的,比如使用二分查找.而冒泡就无法再优化.","like_count":0},{"had_liked":false,"id":158431,"user_name":"港","can_delete":false,"product_type":"c1","uid":1122464,"ip_address":"","ucode":"35931FC6198180","user_header":"https://static001.geekbang.org/account/avatar/00/11/20/a0/1fca96c0.jpg","comment_is_top":false,"comment_ctime":1575369735,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575369735","product_id":100017301,"comment_content":"改成链表之后，冒泡排序、插入排序、选择排序的时间复杂度仍然不变，从时间复杂度系数上讲，冒泡排序系数会变大，插入排序会变小，选择排序基本不变，原因在于链表的插入操作时间复杂度为O(1)，数组插入操作平均时间复杂度为O(n)","like_count":0},{"had_liked":false,"id":158191,"user_name":"梦想的优惠券","can_delete":false,"product_type":"c1","uid":1257418,"ip_address":"","ucode":"D3B44F6C618CA7","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/ca/cbce6e94.jpg","comment_is_top":false,"comment_ctime":1575344680,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1575344680","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":158133,"user_name":"Cy23","can_delete":false,"product_type":"c1","uid":1591293,"ip_address":"","ucode":"8DC561C5151758","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/fd/895f0c27.jpg","comment_is_top":false,"comment_ctime":1575336723,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575336723","product_id":100017301,"comment_content":"又对冒泡算法，插入算法深入了解，并把代码转为PHP执行了下。","like_count":0},{"had_liked":false,"id":158045,"user_name":"大海","can_delete":false,"product_type":"c1","uid":1001446,"ip_address":"","ucode":"20913D0265971B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/47/e6/67b0b711.jpg","comment_is_top":false,"comment_ctime":1575302347,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575302347","product_id":100017301,"comment_content":"把数组分成已排序和未排序两边的做法真是太巧妙了","like_count":0},{"had_liked":false,"id":157536,"user_name":"一路向前","can_delete":false,"product_type":"c1","uid":1044524,"ip_address":"","ucode":"5D7CC9F8BFCDA6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f0/2c/513173e9.jpg","comment_is_top":false,"comment_ctime":1575189190,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575189190","product_id":100017301,"comment_content":"测试了10万个随机数的排序效率，对这3种O(n^2)的排序做个直观对比：<br>***********[Begin]Bouble sort**********<br>***********[End]Bouble sort**********<br>Run time: [ 63.670406 ] seconds.<br>***********[Begin]Insert sort**********<br>***********[End]Insert sort**********<br>Run time: [ 17.872087 ] seconds.<br>***********[Begin]Select sort**********<br>***********[End]Select sort**********<br>Run time: [ 24.533143 ] seconds.","like_count":0},{"had_liked":false,"id":156024,"user_name":"Leoorz","can_delete":false,"product_type":"c1","uid":1030657,"ip_address":"","ucode":"8912628AD6ADE0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/01/5ce8ce0b.jpg","comment_is_top":false,"comment_ctime":1574813939,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574813939","product_id":100017301,"comment_content":"学习心得<br><br>可以从3个角度来对一个排序算法做评估：<br><br>1. 算法执行效率：即时间复杂度，各阶系数以及过程中需要的“比较”“移动”次数；<br><br>2. 算法内存消耗：即空间复杂度，“原地排序”意味着消耗O（1）的内存；<br><br>3. 稳定性：即相等的排序对象间的相对顺序，排序后保持不变<br><br><br>学完冒泡、插入及选择排序，做一下整理及区分：<br><br>相同点：<br><br>三者皆为原地排序，思维方式都是将整个序列在逻辑上分为两部分：已排序序列以及未排序序列，并平均每O(n)内实现一次未排序对象移动至已排序序列，平均执行O(n)次，故三者的平均时间复杂度皆为O(n^2)<br><br>不同点：<br><br>思维方式上三者的差异，就在于实现未排序序列中元素移至已排序序列的方式：<br><br>        插入排序，未排序序列中对象按序逐个遍历，通过操作有序序列（移动有序序列中的对象）实现无序对象有序化；<br><br>        选择排序，通过操作无序序列（每次遍历出最小的元素），每O(n)进行一次交换，实现一次极值对象有序化；<br><br>        冒泡排序，通过操作无序序列（无序序列对象遍历过程中耦合进行多次交换），每O(n)从无序队列中实现一次极值对象有序化，思维复杂度上，比选择排序以及插入排序更复杂（后二者的比较交换及比较移动分别是独立进行的）；<br><br>稳定性上：冒泡与插入排序，可以实现稳定的排序，而选择排序是不稳定的，根因在于选择排序的交换，是无序交换，而同存在交换的冒泡排序，是有序交换，故冒泡稳定而选择不稳定。<br><br>","like_count":0},{"had_liked":false,"id":153368,"user_name":"梨子苹果","can_delete":false,"product_type":"c1","uid":1716067,"ip_address":"","ucode":"3666813FEE31D3","user_header":"https://static001.geekbang.org/account/avatar/00/1a/2f/63/7a048d46.jpg","comment_is_top":false,"comment_ctime":1574225036,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1574225036","product_id":100017301,"comment_content":"实际上相对于选择排序，冒泡排序每一轮都会将更多的元素变得有序。而选择排序只会是一个","like_count":0,"discussions":[{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163947,"discussion_content":"冒泡排序只能保证每轮把一个值变成有序，其他有序的只是碰巧，不能靠这个概率。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581130528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152092,"user_name":"静艺","can_delete":false,"product_type":"c1","uid":1605624,"ip_address":"","ucode":"24A98F5FA2A34B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/4Uw7lDxq4ArDemWcxIZBAS7q0nDyvyDiboWxODeFF3CfGhjgVj1LFeVibokFKZPPj7yUoichnqGbcT5DBFFunc25g/132","comment_is_top":false,"comment_ctime":1573875732,"is_pvip":false,"replies":[{"id":"59142","content":"ipad paper","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1574334215,"ip_address":"","comment_id":152092,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1573875732","product_id":100017301,"comment_content":"想请问老师，内容里的插图是用什么软件画出来的哈哈哈，感觉很清楚很好看","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474713,"discussion_content":"ipad paper","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574334215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188023,"avatar":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","nickname":"Eternal","note":"","ucode":"EA6FE7CC98F740","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":190602,"discussion_content":"这个问题好像好几节课都有人问，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582964500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152012,"user_name":"洗洗睡吧","can_delete":false,"product_type":"c1","uid":1641326,"ip_address":"","ucode":"DE7F8B4CA512F6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJDdmHm6txEVtEXEDibSdIsRLEpghOoMt2kfZHetY9QLWHygicKCfhVoYiaylAZJoXbcCMBhXqMF4icgw/132","comment_is_top":false,"comment_ctime":1573833698,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1573833698","product_id":100017301,"comment_content":"最好情况时间复杂度这里是否有问题？我理解选择和插入排序最好情况下内外两层循环依然要走完整一遍，所以还是O(n2) .而冒泡排序经过优化，在最好情况下可以只走一遍就结束，所以是O(n)<br>参考：https:&#47;&#47;www.cnblogs.com&#47;melon-h&#47;archive&#47;2012&#47;09&#47;20&#47;2694941.html","like_count":0,"discussions":[{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":68861,"discussion_content":"插入排序，内循环最好的情况是 每次直接break , 和 数据规模 n无关，可以理解为内循环是O(1)，所以 最好情况时间复杂度就是 O(n)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575221151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151682,"user_name":"WIZ","can_delete":false,"product_type":"c1","uid":1260348,"ip_address":"","ucode":"313AF84674475C","user_header":"https://static001.geekbang.org/account/avatar/00/13/3b/3c/2947127c.jpg","comment_is_top":false,"comment_ctime":1573779028,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573779028","product_id":100017301,"comment_content":"通过链表来实现这三种算法：<br>由于冒泡、插入、选择都是基于比较的算法，那么，不管是用数组还是链表，其比较次数都是不变的，变化的是交换操作，那么，<br>对于冒泡来说，交换两个节点比数组交换2个值的操作要复杂<br>对于插入排序来说，由于在已排序区间插入节点时不需要再进行数据移动，所以时间上是优于数组的<br>对于选择排序来说，查找到要插入的节点之后，直接将其从原位置删除，插入到已排序区间末尾即可，时间上无明显变化。<br>综上，若基于链表来实现三种算法，那么时间复杂度上来说，冒泡排序增大，插入排序缩小，选择排序无明显变化。","like_count":0},{"had_liked":false,"id":150680,"user_name":"黄振宇","can_delete":false,"product_type":"c1","uid":1686397,"ip_address":"","ucode":"976BC7B46DA419","user_header":"https://static001.geekbang.org/account/avatar/00/19/bb/7d/26340713.jpg","comment_is_top":false,"comment_ctime":1573600234,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573600234","product_id":100017301,"comment_content":"花了一周搞明白这三个算法是咋回事了。也用了c++实现。但是对于算法是不是稳定的，有两个问题：<br>1.插入排序，重复元素控制的是插入的位置，插到是前面的元素的后面，才保证的是稳定。<br>2.选择排序，同样也可以控制两个重复值交换的顺序啊。某种意义上也是稳定算法啦。","like_count":0},{"had_liked":false,"id":150561,"user_name":"严飞","can_delete":false,"product_type":"c1","uid":1664671,"ip_address":"","ucode":"3CE193939D8A16","user_header":"https://static001.geekbang.org/account/avatar/00/19/66/9f/825097ff.jpg","comment_is_top":false,"comment_ctime":1573557572,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573557572","product_id":100017301,"comment_content":"冒泡排序这个代码，第一个for循环的i是不是应该是小于n-1呢，如果是小于n的话，当i=n-1的时候，内层循环就是空的，<br>for (int i = 0; i &lt; n; ++i) {<br>    for (int j = 0; j &lt; n - i - 1; ++j) {<br>      ","like_count":0},{"had_liked":false,"id":150527,"user_name":"刚","can_delete":false,"product_type":"c1","uid":1723783,"ip_address":"","ucode":"4C7D7274E9FE78","user_header":"https://static001.geekbang.org/account/avatar/00/1a/4d/87/853c3098.jpg","comment_is_top":false,"comment_ctime":1573550058,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573550058","product_id":100017301,"comment_content":"排序算法的稳定性也取决于排序算法的条件，比如：2，9，3，4，8，3，冒泡排序，如果条件 a[i] &gt; a[a+1]，则是稳定的，但是改为 a[i] &gt;= a[i+1] 则是不稳定的，同理插入排序也有这个问题，跟临界条件也有关系，不知道我说的对不对","like_count":0},{"had_liked":false,"id":150175,"user_name":"仲夏","can_delete":false,"product_type":"c1","uid":1690965,"ip_address":"","ucode":"2849869C765CDE","user_header":"https://static001.geekbang.org/account/avatar/00/19/cd/55/8c1243dc.jpg","comment_is_top":false,"comment_ctime":1573473558,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573473558","product_id":100017301,"comment_content":"数据结构是难学的，但是收获与付出是成正比的，这个是对于自己代码能力的重要提高，开发中只会几个增删改查相当于耗时间，提升这种思维方式与能力才是给自己提高价值","like_count":0},{"had_liked":false,"id":148846,"user_name":"无名道长","can_delete":false,"product_type":"c1","uid":1387960,"ip_address":"","ucode":"0F694D17459CC0","user_header":"https://static001.geekbang.org/account/avatar/00/15/2d/b8/7e49a241.jpg","comment_is_top":false,"comment_ctime":1573094253,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573094253","product_id":100017301,"comment_content":"go 语言实现的插入排序，大佬帮忙看看对吗？<br>func Insertion(a []int) {<br>\tn := len(a)<br>\tif n &lt;= 1 {<br>\t\treturn<br>\t}<br>\tfor i := 1; i &lt; n; i++ {<br>\t\tfor j := i; j &gt; 0; j-- {<br>\t\t\tif a[j-1] &gt; a[j] {<br>\t\t\t\ta[j-1], a[j] = a[j], a[j-1]<br>\t\t\t} else {<br>\t\t\t\tbreak<br>\t\t\t}<br>\t\t}<br>\t}<br>}","like_count":0},{"had_liked":false,"id":145457,"user_name":"高坤","can_delete":false,"product_type":"c1","uid":1689197,"ip_address":"","ucode":"9BCD93629F7B76","user_header":"https://static001.geekbang.org/account/avatar/00/19/c6/6d/65ec48f1.jpg","comment_is_top":false,"comment_ctime":1572276031,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572276031","product_id":100017301,"comment_content":"老师，请问下这个例子的空间复杂度都是n(1),是因为空间复杂度“不考虑循环体内的变量所占得空间”还是因为“循环体内的变量所占得空间很小而忽略不计”？","like_count":0},{"had_liked":false,"id":142603,"user_name":"imperial","can_delete":false,"product_type":"c1","uid":1465302,"ip_address":"","ucode":"8D0693B3C142B1","user_header":"https://static001.geekbang.org/account/avatar/00/16/5b/d6/d6c26ea2.jpg","comment_is_top":false,"comment_ctime":1571410537,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571410537","product_id":100017301,"comment_content":" 希尔排序:shellSort([2,1],[52,39,67,70,8,25,52,56,5,3])  js排序以后为什么为[ 70, 67, 56, 52, 52, 25, 8, 5, 3, undefined ]，会出现undefinded","like_count":0},{"had_liked":false,"id":141494,"user_name":"心境若水天下无敌","can_delete":false,"product_type":"c1","uid":1213180,"ip_address":"","ucode":"5E6273A6AF67C7","user_header":"https://static001.geekbang.org/account/avatar/00/12/82/fc/bf1e85cb.jpg","comment_is_top":false,"comment_ctime":1571185462,"is_pvip":false,"replies":[{"id":"54905","content":"最后一步你指的是什么意思呢？","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1571360232,"ip_address":"","comment_id":141494,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1571185462","product_id":100017301,"comment_content":"归并排序的最后一步是怎么合并的","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470770,"discussion_content":"最后一步你指的是什么意思呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571360232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1213180,"avatar":"https://static001.geekbang.org/account/avatar/00/12/82/fc/bf1e85cb.jpg","nickname":"心境若水天下无敌","note":"","ucode":"5E6273A6AF67C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51078,"discussion_content":"就是将两个 分别排序好的集合， 合并在一起. ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573808379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140800,"user_name":"苗","can_delete":false,"product_type":"c1","uid":1088710,"ip_address":"","ucode":"5ECCC6C855E541","user_header":"https://static001.geekbang.org/account/avatar/00/10/9c/c6/05a6798f.jpg","comment_is_top":false,"comment_ctime":1571050589,"is_pvip":false,"replies":[{"id":"54519","content":"很正常啊，你看看我后面有一篇谈学习方法的文章。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1571093871,"ip_address":"","comment_id":140800,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571050589","product_id":100017301,"comment_content":"我完了，插入排序的代码，在纸上走了好几遍才能想明白。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470567,"discussion_content":"很正常啊，你看看我后面有一篇谈学习方法的文章。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571093871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140743,"user_name":"niexia","can_delete":false,"product_type":"c1","uid":1238585,"ip_address":"","ucode":"FB95E807E0B1BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/e6/39/1dad4153.jpg","comment_is_top":false,"comment_ctime":1571040421,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571040421","product_id":100017301,"comment_content":"逆序度和有序度不考虑相等的情况么？满有序度等于 n*(n-1) &#47; 2，并且逆序度 = 满有序度 - 有序度，那么逆序度的定义里面就应该包含相等的情况，即 a[i] &gt;= a[j]，i &lt; j","like_count":0},{"had_liked":false,"id":140189,"user_name":"刘楠","can_delete":false,"product_type":"c1","uid":1120773,"ip_address":"","ucode":"9F19D44CBEE039","user_header":"https://static001.geekbang.org/account/avatar/00/11/1a/05/f154d134.jpg","comment_is_top":false,"comment_ctime":1570846114,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570846114","product_id":100017301,"comment_content":"希尔排序，就是在最外层包一层，组<br>  for (int grap = arr.length &#47; 2; grap &gt; 0; grap &#47;= 2) {<br>            &#47;&#47;最外层是分组<br>            &#47;&#47;下面就是插入排序<br>            for (int i = grap; i &lt; arr.length; i++) {<br>                int value = arr[i];<br>                int j = i - 1;<br>                for (; j &gt;= 0; j--) {<br>                    if (arr[j] &gt; value) {<br>                        arr[j + 1] = arr[j];<br>                    } else {<br>                        break;<br>                    }<br>                }<br>                arr[j + 1] = value;<br>            }<br><br>        }","like_count":0},{"had_liked":false,"id":139628,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1570693904,"is_pvip":false,"replies":[{"id":"53982","content":"最好的办法是自己拿个例子跑一下，就明白了。文字解释太难解释清楚了。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1570747135,"ip_address":"","comment_id":139628,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1570693904","product_id":100017301,"comment_content":"老师，对于插入排序中a[j + 1] 为什么+1能详细解释下吗？感谢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470025,"discussion_content":"最好的办法是自己拿个例子跑一下，就明白了。文字解释太难解释清楚了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570747135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":29219,"discussion_content":"感谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570755607,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139241,"user_name":"Geek_b617bf","can_delete":false,"product_type":"c1","uid":1220552,"ip_address":"","ucode":"9BAFC3B184B1D2","user_header":"https://static001.geekbang.org/account/avatar/00/12/9f/c8/0318c83e.jpg","comment_is_top":false,"comment_ctime":1570590906,"is_pvip":false,"replies":[{"id":"53764","content":"你的测试代码写的有问题，这个跟java的预编译有关系，你把maopo和charu的测试顺序颠倒一下看下","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1570659917,"ip_address":"","comment_id":139241,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570590906","product_id":100017301,"comment_content":"冒泡:    public int[] maopaoSort(int[] arr) {<br>        int length = arr.length;<br>        for (int i = 0; i &lt; length; i++) {<br>            boolean flag = false;<br>            for (int j = 0; j &lt; length - i - 1; j++) {<br>                if (arr[j] &gt; arr[j + 1]) {<br>                    int temp = arr[j];<br>                    arr[j] = arr[j + 1];<br>                    arr[j + 1] = temp;<br>                    &#47;&#47;说明有数据交换<br>                    flag = true;<br>                }<br>            }<br>            if (!flag) {<br>                break;<br>            }<br>        }<br>        return arr;<br>    }+<br><br>插入:<br> public int[] insertSort(int[] arr, int length) {<br>        for (int i = 1; i &lt; length; i++) {<br>            &#47;&#47;value保存的是待插入的元素<br>            int value = arr[i];<br>            int j = i - 1;<br>            &#47;&#47;查找插入的位置<br>            for (; j &gt;= 0; j--) {<br>                if (arr[j] &gt; value) {<br>                 &#47;&#47;如果后面的小了,就不断往前交换,就把a[j]处的元素前移,这里也做了三次赋值<br>                    int temp =arr[j];<br>                    arr[j] = arr[j+1];<br>                    arr[j+1]=temp;<br>                } else {<br>                    &#47;&#47;说明这个是有序的,前面的也已经有序<br>                    break;<br>                }<br>            }<br>        }<br>        return arr;<br>    }<br>跑了一遍测试,发现冒泡的时间是插入的三倍左右.<br>测试代码为:<br>public void benchMarkSortTest() {<br><br>        long startTime2 = System.currentTimeMillis();<br>        for (int i = 0; i &lt; 40000; i++) {<br>            maopaoSort(SortUtil.randomArr(200));<br>        }<br>        System.out.println(&quot;冒泡排序的时间为&quot; + (System.currentTimeMillis() - startTime2));<br><br>        long startTime = System.currentTimeMillis();<br>        for (int i = 0; i &lt; 40000; i++) {<br>            insertSort(SortUtil.randomArr(200));<br>        }<br>        System.out.println(&quot;插入排序的时间为&quot; + (System.currentTimeMillis() - startTime));<br>    }<br><br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469850,"discussion_content":"你的测试代码写的有问题，这个跟java的预编译有关系，你把maopo和charu的测试顺序颠倒一下看下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570659917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138414,"user_name":"Geek_b617bf","can_delete":false,"product_type":"c1","uid":1220552,"ip_address":"","ucode":"9BAFC3B184B1D2","user_header":"https://static001.geekbang.org/account/avatar/00/12/9f/c8/0318c83e.jpg","comment_is_top":false,"comment_ctime":1570208144,"is_pvip":false,"replies":[{"id":"53628","content":"你把两个的代码贴全一点发上来吧 我看下","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1570582634,"ip_address":"","comment_id":138414,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570208144","product_id":100017301,"comment_content":"老师,你说插入排序的效率要高于冒泡,是因为在交换次数相同的时候插入排序只需要一次赋值语句,但是我把插入排序改成<br>for (; j &gt;= 0; j--) {<br>                if (arr[j] &gt; value) {<br>                    &#47;&#47;如果后面的小了,就不断往前交换,就把a[j]处的元素前移,这里也做了三次赋值<br>                    int temp =arr[j];<br>                    arr[j] = arr[j+1];<br>                    arr[j+1]=temp;<br>                } else {<br>                    &#47;&#47;说明这个是有序的,前面的也已经有序<br>                    break;<br>                }<br>                arr[j] = value;<br>            }<br>也进行了3k次的赋值操作<br>发现插入排序的速度耗时依然是冒泡的三分之一左右,,请问这是为什么啊..","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469514,"discussion_content":"你把两个的代码贴全一点发上来吧 我看下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570582634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138364,"user_name":"Lance","can_delete":false,"product_type":"c1","uid":1686840,"ip_address":"","ucode":"CCE52F86EEBBED","user_header":"https://static001.geekbang.org/account/avatar/00/19/bd/38/6d436088.jpg","comment_is_top":false,"comment_ctime":1570179300,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570179300","product_id":100017301,"comment_content":"排序算法的平均情况时间复杂度分析可以通过有序度分析，有序度是指待排序数组中有序元素对的个数，逆序度则与有序度相反，是逆序元素对的个数，一个完全有序数组的有序度个数成为满有序度。<br>逆序度=满有序度-有序度<br>排序算法的过程实际是一种增加有序度,减少逆序度的过程,最后达到满有序度。<br>冒泡排序算法的元素交换操作次数、插入排序算法的元素移动操作次数都等于原始数组的逆序度，所以不管算法如何优化，其交换次数或移动次数都是不变的。","like_count":0},{"had_liked":false,"id":138221,"user_name":"zaab","can_delete":false,"product_type":"c1","uid":1683063,"ip_address":"","ucode":"EE846895FF0C85","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/QYKSUV20DMgBHAPLfgngdw4N8FHRCSBLCJueVRu9Ya1Ba2x4icx70zoVVFOZtG1K6TkHj5CFbuztQhRFyCjWXHQ/132","comment_is_top":false,"comment_ctime":1570105542,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570105542","product_id":100017301,"comment_content":"我觉得像这种时间复杂度，空间复杂度 不要像做笔记一样记下来，作总结，没用， 还不如自己认真看一下，学一下。","like_count":0},{"had_liked":false,"id":137802,"user_name":"Minos","can_delete":false,"product_type":"c1","uid":1655300,"ip_address":"","ucode":"C4619192861A1A","user_header":"https://static001.geekbang.org/account/avatar/00/19/42/04/c3afd674.jpg","comment_is_top":false,"comment_ctime":1569857086,"is_pvip":false,"replies":[{"id":"54158","content":"貌似不对呢 应该都是O^2","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1570831913,"ip_address":"","comment_id":137802,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569857086","product_id":100017301,"comment_content":"老师想问一下，单链表插入排序，实现由于单链表不好找上个节点，所以是从头结点开始比较，时间复杂度分析了一下发现，最好情况是完全逆序O(n)，最坏情况是正序O(n^2)，平均复杂度因为单链表插入的原因，为O(n)，不知道我分析的对不对，希望老师能解答一下","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469270,"discussion_content":"貌似不对呢 应该都是O^2","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570831913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136384,"user_name":"蓝色~冰*羽","can_delete":false,"product_type":"c1","uid":1205873,"ip_address":"","ucode":"E2F6424766AD7C","user_header":"https://static001.geekbang.org/account/avatar/00/12/66/71/8a5d02ab.jpg","comment_is_top":false,"comment_ctime":1569420051,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569420051","product_id":100017301,"comment_content":"public static void insertSortBySelf(int[] arr){<br>        int i,j,temp;<br>        for (i=1;i&lt;arr.length;i++){<br>            temp = arr[i]; &#47;&#47;注意是将要排序的数字保存到临时变量<br>            j = i-1;<br>            for (;j&gt;=0 &amp;&amp; temp&lt;arr[j];--j){ &#47;&#47;如果后面的元素小于前面元素，向后移动，还要注意的是j&gt;=0这个判断条件是为了防止越界，因为temp如果交换的话每次都会前移<br>                arr[j+1] = arr[j];<br>            }<br>            arr[j+1] = temp;<br>        }<br>    }<br>我这个插入排序思路是对的吧，不过感觉应该还有优化的空间","like_count":0},{"had_liked":false,"id":135035,"user_name":"David","can_delete":false,"product_type":"c1","uid":1023472,"ip_address":"","ucode":"1C76747719CD3B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9d/f0/6c34b90f.jpg","comment_is_top":false,"comment_ctime":1568984941,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568984941","product_id":100017301,"comment_content":"链表也是能实现的，感觉还是要多动手撸一下","like_count":0},{"had_liked":false,"id":134184,"user_name":"Jack_Cui","can_delete":false,"product_type":"c1","uid":1246643,"ip_address":"","ucode":"A2C44AB026245A","user_header":"https://static001.geekbang.org/account/avatar/00/13/05/b3/a8a835cf.jpg","comment_is_top":false,"comment_ctime":1568771950,"is_pvip":false,"replies":[{"id":"51525","content":"说说哪里错了呢","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1568845151,"ip_address":"","comment_id":134184,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1568771950","product_id":100017301,"comment_content":"插入排序代码是错的","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467644,"discussion_content":"说说哪里错了呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568845151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1695455,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqUMEsVYklTc7akT2e6pfytu4jTQ88EVe1H6L2eHdXC6G8sbKCvfrnSDUIRq229M2Wt419LX2q8SQ/132","nickname":"时光流逝x","note":"","ucode":"D7334E717D9ED0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50521,"discussion_content":"应该是寻找插入位置的自减到0的时候继续自减会空指针指向-1,但是会直接跳到插入数据操作+1后会变成0，然后就会把value插在0位置。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573731966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133932,"user_name":"ParadiseHell","can_delete":false,"product_type":"c1","uid":1121108,"ip_address":"","ucode":"09B3CCCA33A26F","user_header":"https://static001.geekbang.org/account/avatar/00/11/1b/54/63a74f11.jpg","comment_is_top":false,"comment_ctime":1568701889,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568701889","product_id":100017301,"comment_content":"最大的收获莫过于重新认识了冒泡排序，想起大学时初学冒泡排序的时候双层循环是这样的 for(int i = 0; i &lt; n -1; i++) for(int j = i + 1; j &lt; n; j++); 而且根本无法判断是否需要继续进行比较的操作，现在想起来这种写法最大的问题就是会存在相同数据会出现一会上浮一会下沉，个人觉得破坏了冒泡排序的最初的本意。","like_count":0},{"had_liked":false,"id":133166,"user_name":"huangzehao","can_delete":false,"product_type":"c1","uid":1386934,"ip_address":"","ucode":"8A6530D82B48E3","user_header":"https://wx.qlogo.cn/mmopen/vi_32/jqDSNBHmPbPGayjtXrm9iciccSKbfg6g8oMgXc147jib4HjoUK1RINorZYfBuiaQBibqJIrQRVG77PKGS0dW5PVAAicw/132","comment_is_top":false,"comment_ctime":1568425214,"is_pvip":false,"replies":[{"id":"51227","content":"好像有点不对，每次生成的随机数据好像都不一样啊","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1568589102,"ip_address":"","comment_id":133166,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568425214","product_id":100017301,"comment_content":"排序性能测试方法，可以这样实现吗？<br><br>\t&#47;&#47;性能调试方法，生成200个数组，每个数组1000个数字，进行比较测试排序算法的效率<br>\tpublic static ArrayList&lt;int []&gt; testSortTime(int n){<br>\t\tArrayList&lt;int []&gt; arrays = new ArrayList&lt;int[]&gt;(n);<br>\t\tRandom random = new Random(1000);<br>\t\tfor(int i = 0; i &lt; n;i++){<br>\t\t\tint [] arr = new int [4000];<br>\t\t\tfor(int j = 0; j &lt; arr.length;j++){<br>\t\t\t\tarr[j] = random.nextInt(5000);<br>\t\t\t}<br>\t\t\tarrays.add(arr);<br>\t\t}<br>\t\treturn arrays;<br>\t}<br><br>\tpublic static void main(String[] args) {<br>\t\t&#47;&#47;比较不同排序的时间<br>\t\tArrayList&lt;int []&gt; arra = testSortTime(500);<br>\t\t<br>\t\tlong start = System.currentTimeMillis();<br>\t\tfor (int[] arr : arra) {<br>\t\t\t&#47;&#47;bubbleSort(arr); &#47;&#47;bubbleSort:  4066<br>\t\t\t&#47;&#47;insertSort(arr); &#47;&#47;insertSort:  697<br>\t\t\tselectSort(arr);   &#47;&#47;selectSort:  1951<br>\t\t}<br>\t\tlong end = System.currentTimeMillis();<br>\t\t&#47;&#47;System.out.println(&quot;bubbleSort:  &quot;+(end-start));bubbleSort:  4066<br>\t\t&#47;&#47;System.out.println(&quot;insertSort:  &quot;+(end-start));insertSort:  697<br>\t\tSystem.out.println(&quot;selectSort:  &quot;+(end-start)); &#47;&#47;selectSort:  1951<br>\t\t<br>\t}","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467276,"discussion_content":"好像有点不对，每次生成的随机数据好像都不一样啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568589102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133165,"user_name":"huangzehao","can_delete":false,"product_type":"c1","uid":1386934,"ip_address":"","ucode":"8A6530D82B48E3","user_header":"https://wx.qlogo.cn/mmopen/vi_32/jqDSNBHmPbPGayjtXrm9iciccSKbfg6g8oMgXc147jib4HjoUK1RINorZYfBuiaQBibqJIrQRVG77PKGS0dW5PVAAicw/132","comment_is_top":false,"comment_ctime":1568425071,"is_pvip":false,"replies":[{"id":"51228","content":"嗯嗯","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1568589126,"ip_address":"","comment_id":133165,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568425071","product_id":100017301,"comment_content":"老师，你好，选择排序可以这样优化，如果minIndex没改变的话则没必要交换数据了<br><br>&#47;&#47;选择排序算法<br>\tpublic static int [] selectSort(int [] array){<br>\t\tint n = array.length;<br>\t\t<br>\t\tfor(int i = 0;i &lt; n;i++){<br>\t\t\tint minIndex = i;<br>\t\t\tfor(int j = i+1; j &lt; n; j++){<br>\t\t\t\tif(array[minIndex] &gt; array[j]){ &#47;&#47;选择排序从未排序区间找出最小的元素下标<br>\t\t\t\t\tminIndex = j;<br>\t\t\t\t}<br>\t\t\t}<br>\t\t\tif(minIndex != i){&#47;&#47;如果最小元素下标产生改变则交换数据<br>\t\t\t\tint temp = array[i];<br>\t\t\t\tarray[i] = array[minIndex];<br>\t\t\t\tarray[minIndex] = temp;<br>\t\t\t}<br>\t\t}<br>\t\treturn array;<br>\t}","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467275,"discussion_content":"嗯嗯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568589126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133046,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1568336568,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568336568","product_id":100017301,"comment_content":"三种排序算法，插入最优、然后是冒泡、最差是选择","like_count":0},{"had_liked":false,"id":132829,"user_name":"胡永","can_delete":false,"product_type":"c1","uid":1200543,"ip_address":"","ucode":"6C8BA1E0BED9C0","user_header":"https://static001.geekbang.org/account/avatar/00/12/51/9f/1840385e.jpg","comment_is_top":false,"comment_ctime":1568248630,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568248630","product_id":100017301,"comment_content":"今天学到的是三种算法：冒泡排序，插入排序，交换排序；分析一个排序算法的好坏有三个指标：稳定性，复杂度，内存消耗，经典的算法分为三类，今天算法为O(n)的算一类；O(nlogn),O(n);","like_count":0},{"had_liked":false,"id":131232,"user_name":"林肯","can_delete":false,"product_type":"c1","uid":1008582,"ip_address":"","ucode":"D2C97220230DE5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/c6/d6ea3df3.jpg","comment_is_top":false,"comment_ctime":1567676019,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567676019","product_id":100017301,"comment_content":"&#47;&#47;冒泡排序<br>func mpSort(array []int ) []int {<br>   if len(array) &lt;=1{<br>      return array<br>   }<br><br>   var i,j int<br>   for i=1; i&lt; len(array); i++{<br>      var flag = false<br>      for j=0;j&lt;len(array)-i;j++{<br>         if array[j] &gt; array[j+1]{<br>            swap := array[j]<br>            array[j] = array[j+1]<br>            array[j+1] = swap<br>            flag = true<br>         }<br><br>      }<br>      if flag == false{<br>         break<br>      }<br>   }<br>   return array<br><br>}<br><br>&#47;&#47;插入排序<br>func insertSort(array []int ) []int{<br>   if len(array) &lt;=1{<br>      return array<br>   }<br><br>   var i,j int<br><br>   for i=1; i&lt; len(array); i++{<br>      swap := array[i]<br>      for j=i-1;j&gt;=0;j--{<br>         if array[j] &gt; swap{<br>            array[j+1] = array[j]<br>         }else {<br>            break<br>         }<br><br>      }<br>      array[j+1] =  swap<br><br>   }<br>   return array<br><br>}","like_count":0},{"had_liked":false,"id":129497,"user_name":"云龙","can_delete":false,"product_type":"c1","uid":1622953,"ip_address":"","ucode":"FE3DF5E0530D86","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/EIxfye0noElD6CgfvHgByRN9ics8hGENNBRuibSmXqeMNakF0BpN8RWpXUWcd8v2Wp8N7bqd9mDia5n8PH2qeUySA/132","comment_is_top":false,"comment_ctime":1567141596,"is_pvip":false,"replies":[{"id":"48488","content":"思路不对，你这个不是插入排序啊","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1567378274,"ip_address":"","comment_id":129497,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567141596","product_id":100017301,"comment_content":"我的思路有没有问题呢？<br>&#47;&#47; 插入排序，a 表示数组，n 表示数组大小<br>void insertionSort(int[] a, int n){<br>  if(n &lt; = 1)<br>    return;<br>  for(int i = 1; i &lt; n; i++){<br>    for(int j = i; j &gt; 0; j--){<br>      if(a[i] &lt; a[j]){<br>        &#47;&#47;交换<br>        int tem = a[i];<br>        tem = a[j];<br>        a[j] = a[i];<br>        break;<br>      }<br>    }<br>  }<br>}","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465506,"discussion_content":"思路不对，你这个不是插入排序啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567378274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128582,"user_name":"静静聆听","can_delete":false,"product_type":"c1","uid":1263932,"ip_address":"","ucode":"0A8600CB928EFE","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","comment_is_top":false,"comment_ctime":1566908459,"is_pvip":false,"replies":[{"id":"48491","content":"你没怎么看懂我用稳定排序如何排序订单的呢，你再仔细看下文章","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1567378513,"ip_address":"","comment_id":128582,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566908459","product_id":100017301,"comment_content":"老师，有个疑问，关于排序算法稳定性的介绍并为说服我，因为本章节讲的都是基于比较的排序算法，而比较的方式是你自己写的，你写比较规则的时候就可以指明先根据金额排序，金额相同再比较时间即可啊，根本不用考虑排序是否有稳定性","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465003,"discussion_content":"你没怎么看懂我用稳定排序如何排序订单的呢，你再仔细看下文章","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567378513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128312,"user_name":"angel😇txy🤓","can_delete":false,"product_type":"c1","uid":1133702,"ip_address":"","ucode":"C0AEE0D8BAF7ED","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/86/3be94807.jpg","comment_is_top":false,"comment_ctime":1566870193,"is_pvip":true,"replies":[{"id":"47734","content":"可以不用概率来推导","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1566949350,"ip_address":"","comment_id":128312,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566870193","product_id":100017301,"comment_content":"老师平均时间复杂度推导太复杂，可以不理解吗，记住结果行不行","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464890,"discussion_content":"可以不用概率来推导","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566949350,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127935,"user_name":"Angus","can_delete":false,"product_type":"c1","uid":1377467,"ip_address":"","ucode":"7CC3BA1550FB5B","user_header":"https://static001.geekbang.org/account/avatar/00/15/04/bb/5e5c37c1.jpg","comment_is_top":false,"comment_ctime":1566811620,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566811620","product_id":100017301,"comment_content":"看选择排序的稳定性的时候，一开始我被这句话误导了——“但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾“，如果是放到末尾有点理解为插入了，如果是插入就不会造成不稳定。而理解为和未排序区间的第一个元素互换位置，那就会造成未排序区间的第一个元素的不稳定。","like_count":0},{"had_liked":false,"id":127445,"user_name":"不动声色满心澎湃","can_delete":false,"product_type":"c1","uid":1621658,"ip_address":"","ucode":"80D8F9E49AF7C2","user_header":"https://static001.geekbang.org/account/avatar/00/18/be/9a/b0b89be3.jpg","comment_is_top":false,"comment_ctime":1566717163,"is_pvip":false,"replies":[{"id":"47233","content":"sort是啥？顺序不对的话，最后的结果是不对的，你可以举个例子自己看下。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1566773178,"ip_address":"","comment_id":127445,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1566717163","product_id":100017301,"comment_content":"这里有个问题，在说明稳定排序的时候，举得例子：先比较时间再比较下单金额。 我想问的是  如果我在一个sort里直接先判断下单金额，如果下单金额一样的时候再比较时间。 这个一次性比较和分开两次的比较有什么实质性的差距嘛","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464494,"discussion_content":"sort是啥？顺序不对的话，最后的结果是不对的，你可以举个例子自己看下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566773178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1621658,"avatar":"https://static001.geekbang.org/account/avatar/00/18/be/9a/b0b89be3.jpg","nickname":"不动声色满心澎湃","note":"","ucode":"80D8F9E49AF7C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6999,"discussion_content":"老师我的意思是：您的方法是先排序a再排序b然后得到先按照b排序 如果b的数值一样再按照a排序的数组。那我如果我的排序不用两次。直接一次先判断a 如果a相等再按照b排序。好像是等价的做法。这时候就不需要稳定算法了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567248418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126534,"user_name":"Monroe  He","can_delete":false,"product_type":"c1","uid":1348219,"ip_address":"","ucode":"D04ECB2EF2E0DA","user_header":"https://static001.geekbang.org/account/avatar/00/14/92/7b/8c7e3e61.jpg","comment_is_top":false,"comment_ctime":1566402395,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566402395","product_id":100017301,"comment_content":"冒泡排序相对与插入排序，赋值操作更多，在同一级下时间复杂度更高。<br>选择排序是每次在剩余数据中选择最小的数据，在交换过程中破坏了相同数据的相对顺序，是不稳定的排序算法","like_count":0},{"had_liked":false,"id":126478,"user_name":"冰风落叶","can_delete":false,"product_type":"c1","uid":1128059,"ip_address":"","ucode":"E4DE480B95A17D","user_header":"https://static001.geekbang.org/account/avatar/00/11/36/7b/3788ca13.jpg","comment_is_top":false,"comment_ctime":1566392353,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566392353","product_id":100017301,"comment_content":"知识点总结：<br><br>一、如何衡量一个排序算法的好坏：<br>1. 最好、最坏、平均时间复杂度，及最好、最好时间复杂度的原始数据 （针对小规模数据排序时，如果是同阶时间复杂度，应该把系数、常数、低阶也考虑进来）<br>2. 空间复杂度 （空间复杂度为1的叫做原地排序）<br>3. 稳定性 （排序的稳定性是指相等的对象，在排序之后，顺序保持不变）<br>4. 对基于比较的排序算法，应该把比较次数和交换次数也考虑进去<br><br>二、有序度、逆序度、满有序度<br>1. 有序度就是有顺序关系的元素对个数，例如：1、3、4的有序度就是3，(1,3)、(1,4)、(3,4)<br>2. 满有序度就是指完全有序的数组，公式=n*(n-1)&#47;2<br>3. 逆序度就是有逆序关系的元素个数，逆序度 = 满有序度 - 有序度<br>4. 我们排序的过程就是增加有序度，减少逆序度的过程，最后达到满有序度就说明排序完成了。（交换次数就是逆序度）<br><br>三、冒泡排序<br>1. 原理：从第一个开始，依次比较相邻元素的大小然后进行交换操作，把大的往后交换，直到没有交换操作为止。<br>2. 最好时间复杂度：O(n)，当数组刚好是顺序的时候，只需要挨个比较一遍就行了，不需要做交换操作，所以时间复杂度为O(n)<br>3. 最坏时间复杂度：O(n*n)，当数组刚好是完全逆序的时候，需要挨个比较，并且重复n此，所以时间复杂度为O(n*n)<br>4. 平均时间复杂度：O(n*n)，当一半的满有序度n*(n-1)&#47;4，进行计算的话，交换次数就是n*(n-1)&#47;4，比较次数肯定比交换次数多，所有得出来的不准确的平均时间复杂度为O(n*n)<br>5. 冒泡的稳定性：元素相同时不做交换，所以冒泡是稳定的排序算法<br><br>四、插入排序<br>1. 原理： 选取未排序的元素，插入到已排序区间的合适位置，止到未排序区间为空。<br>2. 最好时间复杂度： O(n)，当数组刚好是完全顺序时，每次只用比较一次就能找到正确的位置，重复n次，就可以清空未排序区间，所以最好时间复杂度为O(n)<br>3. 最坏时间复杂度：O(n*n)，当数组刚好是完全逆序时，每次都要比较n次才能找到正确位置，重复n次，才能清空未排序区间，所以最坏时间复杂度为O(n*n)<br>4. 平均时间复杂度：O(n*n)，因为往数组中插入一个元素的平均时间复杂度为O(n)，而插入排序可以理解为重复n次的数组插入操作，所以平均时间复杂度为O(n*n)<br>5. 插入的稳定性：未出现的元素总会插入到已排序元素的前边，所以插入排序是稳定的排序算法。<br><br>五、插入排序为何比冒泡排序更优？<br>1. 相同点：插入排序和冒泡排序的平均时间复杂度都是O(n*n)，都是稳定的排序算法，都是原地排序，元素交换的次数都是逆序度<br>2. 插入比冒泡的优势：冒泡的交换操作需要三个赋值操作，而插入只需要一步赋值操作，而且插入排序还有很大的优化空间，所以插入更优选一点。","like_count":0},{"had_liked":false,"id":126402,"user_name":"Geek_26bedb","can_delete":false,"product_type":"c1","uid":1619375,"ip_address":"","ucode":"B7389175247C2D","user_header":"","comment_is_top":false,"comment_ctime":1566381835,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566381835","product_id":100017301,"comment_content":"python代码：<br>冒泡排序：<br>def BubbleSort(list_,n):<br>    if n&lt;=1:<br>        return list_<br>    for i in range(n):<br>        for j in range(n-i-1):<br>            if list_[j]&gt;list_[j+1]:<br>                a = list_[j]<br>                list_[j] = list_[j+1]<br>                list_[j+1] = a<br>    return list_<br>插入排序：<br>def InsertSort(list_,n):<br>    if n&lt;=1:return list_<br>    for i in range(n):<br>        val = list_[i]<br>        for j in range(0,i):<br>            if list_[j]&gt;val:<br>                list_[i] = list_[j]<br>                list_[j] = val<br>    return list_<br>时间对比：a = np.arange(10000), random.shuffle(a)<br>                 BubbleSort时间：23.392488479614258； InsertSort时间：6.541499376296997<br>","like_count":0},{"had_liked":false,"id":125019,"user_name":"言易","can_delete":false,"product_type":"c1","uid":1265098,"ip_address":"","ucode":"8614E43CBA3692","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLhIRlNpJSEMJLrlIRLdXmVgfWTWia4RJMxiaVvCOZmyMjf7Fiad7ib0eibuu8UAMCrx9UbSmBOpUs9ibxg/132","comment_is_top":false,"comment_ctime":1566047231,"is_pvip":false,"replies":[{"id":"47255","content":"可以啊，你找个变量记录一下length也可以的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1566775416,"ip_address":"","comment_id":125019,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566047231","product_id":100017301,"comment_content":"不太懂为什么要在外部传入数组的大小，不能直接使用数组的length属性来获取么？如果是怕每次获取数组长度消耗性能，也可以获取一次后用一个变量来存储吧？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463401,"discussion_content":"可以啊，你找个变量记录一下length也可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566775416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123624,"user_name":"Joiner","can_delete":false,"product_type":"c1","uid":1071941,"ip_address":"","ucode":"7F67D4C325E71F","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/45/5dc5437e.jpg","comment_is_top":false,"comment_ctime":1565715987,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565715987","product_id":100017301,"comment_content":"老师，冒泡排序的平均时间复杂度，如果用概率的知识该怎么求解呢（假设每个位置出现的概率一样）","like_count":0},{"had_liked":false,"id":123503,"user_name":"加温后的啤酒","can_delete":false,"product_type":"c1","uid":1344488,"ip_address":"","ucode":"5F30978CDB1606","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/e8/f726c635.jpg","comment_is_top":false,"comment_ctime":1565688842,"is_pvip":false,"replies":[{"id":"45686","content":"是的，代码中多了一次循环","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1565907783,"ip_address":"","comment_id":123503,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565688842","product_id":100017301,"comment_content":"争哥 冒泡排序代码那里 最外层for循环 i &lt; n-1 就行了吧？ 不需要 i &lt; n。 n个数的话 外层最多遍历 n-1遍。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462701,"discussion_content":"是的，代码中多了一次循环","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565907783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119628,"user_name":"jianantian","can_delete":false,"product_type":"c1","uid":1032167,"ip_address":"","ucode":"92D884B5561BFF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bf/e7/85dd9521.jpg","comment_is_top":false,"comment_ctime":1564641248,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564641248","product_id":100017301,"comment_content":"是否稳定和是否原地两个要一起满足才有意义吧，像选择排序很明显有一个稳定但不是原地的实现。","like_count":0},{"had_liked":false,"id":119615,"user_name":"Langzi233","can_delete":false,"product_type":"c1","uid":1042685,"ip_address":"","ucode":"5A21AC08FC089B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e8/fd/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1564638011,"is_pvip":false,"replies":[{"id":"44226","content":"你说的对，多了一次循环。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1564960288,"ip_address":"","comment_id":119615,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564638011","product_id":100017301,"comment_content":"老师，冒泡排序代码外层循环的判断条件应该是i &lt; n - 1。对于有序度为0的情况，flag不会为false即不会提前跳出循环，而总数为n是需要循环的次数是n-1次，因为i从0开始，所以判断条件是i &lt; n-1","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460981,"discussion_content":"你说的对，多了一次循环。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564960288,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119566,"user_name":"may_huang","can_delete":false,"product_type":"c1","uid":1451623,"ip_address":"","ucode":"EAF989F18FC109","user_header":"https://static001.geekbang.org/account/avatar/00/16/26/67/c3d90f46.jpg","comment_is_top":false,"comment_ctime":1564626973,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1564626973","product_id":100017301,"comment_content":"我实现的选择排序：<br>void select_sort(int a[], int len)<br>{<br>    int i, j;<br>    int tmp, value, idx;<br>    if (len &lt;= 1) {<br>        printf(&quot;Don&#39;t need to sort.\\n&quot;);<br>        return;<br>    }<br>    <br>    for (i = 0; i &lt; len; i++) {<br>        value = a[i];<br>        j = i;<br>        for ( ;j &lt; len; j++) {<br>            if (a[i] &gt; a[j]) {<br>                a[i] = a[j]; &#47;&#47;找到最小值<br>                idx = j; &#47;&#47;记录最小值的索引<br>            }<br>        }<br>        if (value == a[i]) &#47;&#47;最小值就是本身不需要交换<br>            continue;<br>        &#47;&#47;交换<br>        a[idx] = value;<br>    }<br>    return;<br>}","like_count":0},{"had_liked":false,"id":118986,"user_name":"(｡ì _ í｡)","can_delete":false,"product_type":"c1","uid":1243693,"ip_address":"","ucode":"5D20864FA37AEB","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/2d/64f68768.jpg","comment_is_top":false,"comment_ctime":1564479888,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564479888","product_id":100017301,"comment_content":"插入算法推演好几遍，都得出，j=0的时候，a[j+1] = value，怎么想都想不通，仔细看了下代码发现是--j ,下一次循环的时候，j=-1，a[j+1]=value就说得通了。果然要仔细审题啊","like_count":0},{"had_liked":false,"id":115771,"user_name":"tong467","can_delete":false,"product_type":"c1","uid":1560667,"ip_address":"","ucode":"544F6FB2C5A936","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJjw7KXibCGnibOm3O73xCGyCzdmgKuc017X8IQZCdNvAWxoWxHSgMTLgd7rGs1LCBPaU5oHbO16F0A/132","comment_is_top":false,"comment_ctime":1563722831,"is_pvip":false,"replies":[{"id":"42286","content":"没看出你写的比我写的简单啊，我语句更少啊，你赋值操作更多啊","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1563745831,"ip_address":"","comment_id":115771,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563722831","product_id":100017301,"comment_content":"老师插曲排序是不是写复杂了。<br>从需要被插入的数据往前判断只要大于当前值就交换，就能找到正确位置。这样应该没错吧。<br>public int[] insertSort2(int[] source) {<br>        for (int i = 1; i &lt; source.length; i++) {<br>            int j = i;<br>            for (; j &gt; 0; j--) {<br>                if (source[j] &lt; source[j-1]) {<br>                    int temp = source[j-1];<br>                    source[j-1] = source[j];<br>                    source[j] = temp;<br>                }else{<br>                    break;<br>                }<br>            }<br>        }<br>        return source;<br>    }","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459282,"discussion_content":"没看出你写的比我写的简单啊，我语句更少啊，你赋值操作更多啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563745831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114800,"user_name":"亢（知行合一的路上）","can_delete":false,"product_type":"c1","uid":1347013,"ip_address":"","ucode":"958AF7C96EB9E8","user_header":"https://static001.geekbang.org/account/avatar/00/14/8d/c5/898b13b4.jpg","comment_is_top":false,"comment_ctime":1563410319,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563410319","product_id":100017301,"comment_content":"需要实现一遍，帮助理解；学的过程大脑难免偷懒😄","like_count":0},{"had_liked":false,"id":114199,"user_name":"Leo","can_delete":false,"product_type":"c1","uid":1217896,"ip_address":"","ucode":"947C5785A7EDF1","user_header":"https://static001.geekbang.org/account/avatar/00/12/95/68/41546e8a.jpg","comment_is_top":false,"comment_ctime":1563249615,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563249615","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":113913,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1563184461,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563184461","product_id":100017301,"comment_content":"算法_011<br><br># 作业<br>链表实现的排序表现：<br>1. 冒泡排序：<br>\t- 稳定<br>\t- 原地<br>\t- O(n^2)，比数组执行操作多<br>2. 插入排序：<br>\t- 稳定<br>\t- 原地<br>\t- O(n^2)，比数组执行操作少<br>3. 选择排序：<br>\t- 不稳定<br>\t- 原地<br>\t- O(n^2)，与数组基本一致<br><br># 内容<br><br>1. 排序的指标：<br>\t- 原地<br>\t- 稳定<br>\t- 时间复杂度<br><br>2. 三个指标的分析思路<br><br>3. 衡量有序程度的概念<br>\t- 有序度<br>\t- 逆序度<br><br># 感想<br><br>大O的时间复杂度分析法，把相同数量及的算法试做一致。<br><br>但是每一次基础的操作，冒泡排序都使用更多的赋值和临时变量。<br><br>用代码实现了三种排序方式，发现插入排序只用了冒泡一半的执行时间，当然是同一个数量级，但这个优势足以让商业项目中，完全放弃冒泡排序。","like_count":0},{"had_liked":false,"id":113134,"user_name":"抱着漫画书的少年","can_delete":false,"product_type":"c1","uid":1245226,"ip_address":"","ucode":"A222BB666755DC","user_header":"https://static001.geekbang.org/account/avatar/00/13/00/2a/1f474d7d.jpg","comment_is_top":false,"comment_ctime":1562901749,"is_pvip":false,"replies":[{"id":"41289","content":"算是，不过效率不高","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1562977324,"ip_address":"","comment_id":113134,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562901749","product_id":100017301,"comment_content":"这段代码算不算是选择排序:<br><br>public static void selectSort02(int[] arr) {<br>    int length = arr.length;<br>    if (length &lt;= 1) {<br>      return;<br>    }<br><br>    for (int i = 0; i &lt; length - 1; i++) {<br>      for (int j = i + 1; j &lt; length; j++) {<br>        if (arr[j] &lt; arr[i]) {<br>          int tmp = arr[i];<br>          arr[i] = arr[j];<br>          arr[j] = tmp;<br>        }<br>      }<br>    }<br><br>  }","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458072,"discussion_content":"算是，不过效率不高","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562977324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113082,"user_name":"唐二毛","can_delete":false,"product_type":"c1","uid":1597884,"ip_address":"","ucode":"7C16F45165F4BA","user_header":"https://static001.geekbang.org/account/avatar/00/18/61/bc/a656bee7.jpg","comment_is_top":false,"comment_ctime":1562894417,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1562894417","product_id":100017301,"comment_content":"选择排序最好时间复杂度为什么是O(n^2), 百思不得其解!","like_count":0,"discussions":[{"author":{"id":1250807,"avatar":"https://static001.geekbang.org/account/avatar/00/13/15/f7/744720a2.jpg","nickname":"DriveMan_邱佳源","note":"","ucode":"A4C83BF07DEE7A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4723,"discussion_content":"因为当数据有序时，采用的是插入排序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565685988,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112610,"user_name":"你在不远的未来","can_delete":false,"product_type":"c1","uid":1318404,"ip_address":"","ucode":"5B34C8BD03B71A","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/04/f902047e.jpg","comment_is_top":false,"comment_ctime":1562770990,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562770990","product_id":100017301,"comment_content":"看了网友写的插入排序，我思考了下稍微做了下优化，发现之后的速度是优化之后的冒泡速度的2倍。<br>优化之后的插入排序如下<br><br>public static void insertOrder(int[] a, int n) {<br>        for (int offset = 1; offset &lt; n; offset++) {<br>            int temp = a[offset];<br><br>            &#47;&#47;当指针元素包含在(负无穷, 元素值)区间内，进入已排数组位移并插入操作。否则继续指针位移。<br>            &#47;&#47;改进的地方：直接判断已排数据尾部元素即可，类似大顶堆判断。<br>            if (temp &lt; a[offset - 1]) {<br>                for (int i = offset - 1; i &gt;= 0; i--) {<br>                    &#47;&#47;元素搬移<br>                    a[i + 1] = a[i];<br><br>                    &#47;&#47;中止插入条件：推理置空位置为头部或者置空位置前一位小于等于temp值<br>                    if (i == 0 || temp &gt;= a[i - 1]) {<br>                        a[i] = temp;<br>                        break;<br>                    }<br>                }<br>            }<br>        }<br>    }","like_count":0},{"had_liked":false,"id":111284,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1562537424,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562537424","product_id":100017301,"comment_content":"仔细看了冒泡和插入排序的代码，每次交换都提升一个有序度。冒泡的交换是针对两个元素的，必须要用到三次操作，插入是针对一个元素和一个区间，区间的平均每个元素就一次赋值操作，外加头尾两次操作。也就是说区间中被交换元素个数是一的时候，冒泡和插入代价相等，但是区间被交换元素大于一的时候，插入优于冒泡。选择排序的交换也是针对两个元素，代价和冒泡相同，但是和冒泡不同的是选择排序通过定下最终位置交换，原来元素的相对位置被打乱了，失去了稳定性。","like_count":0},{"had_liked":false,"id":111279,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1562536299,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562536299","product_id":100017301,"comment_content":"如果采用链表存储数据，各种链表对于交换相邻元素，复杂度都是O(1),所以对于冒泡排序和插入排序复杂度不变，都是O(n2).选择排序也可以找出链表的最小元素插入到头部，复杂度也是O(n2).","like_count":0},{"had_liked":false,"id":111077,"user_name":"Joiner","can_delete":false,"product_type":"c1","uid":1071941,"ip_address":"","ucode":"7F67D4C325E71F","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/45/5dc5437e.jpg","comment_is_top":false,"comment_ctime":1562466828,"is_pvip":false,"replies":[{"id":"40494","content":"是的，也可以不倒置的，你理解的没错！","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1562543817,"ip_address":"","comment_id":111077,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562466828","product_id":100017301,"comment_content":"老师，对于评论区第一条评论，插入排序完成后很可能需要倒置链表，为什么可能要倒置链表？没想明白，是因为排序一般都是从小到大，如果要从大到小所以需要倒置吗？如果是那样，可以写两个方法啊","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457216,"discussion_content":"是的，也可以不倒置的，你理解的没错！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562543817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111039,"user_name":"Geek_麟凤来思","can_delete":false,"product_type":"c1","uid":1457551,"ip_address":"","ucode":"7ADF5585765A42","user_header":"https://static001.geekbang.org/account/avatar/00/16/3d/8f/4d1ffc7f.jpg","comment_is_top":false,"comment_ctime":1562427832,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562427832","product_id":100017301,"comment_content":"排序算法总结<br>https:&#47;&#47;www.runoob.com&#47;w3cnote&#47;sort-algorithm-summary.html   <br><br>十大经典排序算法<br>https:&#47;&#47;www.runoob.com&#47;w3cnote&#47;ten-sorting-algorithm.html<br><br>Java 排序算法分析与实现<br>https:&#47;&#47;www.runoob.com&#47;w3cnote&#47;java-sorting-algorithm-analysis-and-implementation.html","like_count":0},{"had_liked":false,"id":110159,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1562202652,"is_pvip":true,"replies":[{"id":"40131","content":"建议全部看完，然后再回过头来多刷几遍","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1562281620,"ip_address":"","comment_id":110159,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562202652","product_id":100017301,"comment_content":"老师，请教一下. <br>就是其实我已经看到树那边的章节了. 但是感觉前面的印象不深了，那这边建议 我是接着树往下看，整体有个印象再回来从头学习，还是现在就停止直接回来从头复习呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456752,"discussion_content":"建议全部看完，然后再回过头来多刷几遍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562281620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109260,"user_name":"棒棒鸡不棒","can_delete":false,"product_type":"c1","uid":1526445,"ip_address":"","ucode":"52886261524958","user_header":"https://static001.geekbang.org/account/avatar/00/17/4a/ad/a62b0a1e.jpg","comment_is_top":false,"comment_ctime":1561989575,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561989575","product_id":100017301,"comment_content":"选择排序的时间复杂度在三种情况下都为O(n2)是因为不管怎样都得进行两次for循环来找到未排序区的最小值，不知道说的对不对。","like_count":0},{"had_liked":false,"id":109253,"user_name":"棒棒鸡不棒","can_delete":false,"product_type":"c1","uid":1526445,"ip_address":"","ucode":"52886261524958","user_header":"https://static001.geekbang.org/account/avatar/00/17/4a/ad/a62b0a1e.jpg","comment_is_top":false,"comment_ctime":1561988356,"is_pvip":false,"replies":[{"id":"39582","content":"是的，是包含移动数据的时间的。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1562024349,"ip_address":"","comment_id":109253,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561988356","product_id":100017301,"comment_content":"老师，这里选择排序说到数组的插入的时间复杂度为O(n)，这里应该说的是插入元素之后，后面的元素要移动相应的位置吧，因为我翻到前面的文章看到数组的插入的时间复杂度为O(1)，所以来问问看是不是我这么理解的。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456323,"discussion_content":"是的，是包含移动数据的时间的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562024349,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107395,"user_name":"邓海涵","can_delete":false,"product_type":"c1","uid":1473900,"ip_address":"","ucode":"DCCA91C3B4CBAE","user_header":"https://static001.geekbang.org/account/avatar/00/16/7d/6c/e7163342.jpg","comment_is_top":false,"comment_ctime":1561527261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561527261","product_id":100017301,"comment_content":"插入这个代码实现太秒了","like_count":0},{"had_liked":false,"id":106612,"user_name":"徐鹏","can_delete":false,"product_type":"c1","uid":1221936,"ip_address":"","ucode":"B19B6EB7002231","user_header":"https://static001.geekbang.org/account/avatar/00/12/a5/30/4be78ce7.jpg","comment_is_top":false,"comment_ctime":1561356754,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561356754","product_id":100017301,"comment_content":"冒泡、选择、插入排序练习 https:&#47;&#47;github.com&#47;KusePeng&#47;data_structure&#47;tree&#47;master&#47;src&#47;practice&#47;sort&#47;ex01","like_count":0},{"had_liked":false,"id":106267,"user_name":"小白菜","can_delete":false,"product_type":"c1","uid":1568340,"ip_address":"","ucode":"ACD1267D329B96","user_header":"https://static001.geekbang.org/account/avatar/00/17/ee/54/dac0a6b6.jpg","comment_is_top":false,"comment_ctime":1561229767,"is_pvip":false,"replies":[{"id":"38638","content":"应该是编程基础差，可以先从抄袭模仿开始。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1561419627,"ip_address":"","comment_id":106267,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561229767","product_id":100017301,"comment_content":"老师您好，希望能得到你的回复，谢谢！看完这一章，对于你写的样例代码理解开始变得困难，感觉自己写的话，就会写不出。不知道是自己没有理解其中的算法原理？还是对于语言本身就没学好？还是练得少？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455025,"discussion_content":"应该是编程基础差，可以先从抄袭模仿开始。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561419627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106196,"user_name":"salmonl","can_delete":false,"product_type":"c1","uid":1010160,"ip_address":"","ucode":"0F85E5AD2C52B2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/69/f0/714c2f83.jpg","comment_is_top":false,"comment_ctime":1561200586,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561200586","product_id":100017301,"comment_content":"大概看了下没有看到PHP版本的插入排序，参考老师的例子，并做了些改进<br>改进前<br>&#47;&#47; 开始的思考是用一个数组单独存储排序好的元素，这样空间复杂度就高了<br>function insertSort($arr)<br>{<br>        $count = count($arr);<br>        for ($i = 1; $i &lt; $count; $i++) {<br>                $value = $arr[$i];<br>                &#47;&#47; $i - 1 之前的元素都是有序的<br>                for ($j = $i - 1; $j &gt;= 0; $j--) {<br>                        if ($arr[$j] &gt; $value) {<br>                                &#47;&#47; 后移一个位置<br>                                $arr[$j + 1] = $arr[$j];<br>                        } else {<br>                                break;<br>                        }<br>                }<br>                &#47;&#47; 开始比较困惑，为啥是$j + 1。因为$j + 1 = $i, 而$i的值已经被赋值$value, 所以$j + 1相当于空隙<br>                $arr[$j + 1] = $value;<br>        }<br><br>        return $arr;<br>}<br><br>$data = [2, 3, 8, 6, 1];<br>var_dump(insertSort($data));<br><br>改进后：未排序的元素比已排序序列中最后一个元素小时，才移动和插入<br>function insertSort($arr)<br>{<br>        $count = count($arr);<br>        for ($i = 1; $i &lt; $count; $i++) {<br>                &#47;&#47; 未排序的元素比已排序序列中最后一个元素小时，才移动和插入<br>                if ($arr[$i - 1] &gt; $arr[$i]) {<br>                        $value = $arr[$i];<br>                        for ($j = $i - 1; $j &gt;= 0; $j--) {<br>                                if ($arr[$j] &gt; $value) {<br>                                        &#47;&#47; 后移一个位置<br>                                        $arr[$j + 1] = $arr[$j];<br>                                } else {<br>                                        break;<br>                                }<br>                        }<br>                        $arr[$j + 1] = $value;<br>                }<br>        }<br><br>        return $arr;<br>}<br>也可以看这里http:&#47;&#47;niliu.me&#47;articles&#47;1017.html#more-1017","like_count":0},{"had_liked":false,"id":106156,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1561191363,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561191363","product_id":100017301,"comment_content":"如何分析一个排序算法？<br>1.排序算法的执行效率<br>最好、最坏、平均时间复杂度<br>时间复杂度的系数、常数、低阶<br>比较和移动次数<br>2.排序算法的内存消耗<br>3.排序算法的稳定性<br>从有序度看排序算法？<br>逆序度 = 满有序度 - 有序度<br>排序的过程就是增加有序度，减少逆序度，直到达到满有序度<br>三种o(n2)排序算法的分析？<br>冒泡排序：最好时复o(n)，最坏和平均时复o(n2)；原地排序；稳定<br>插入排序：最好时复o(n)，最坏和平均时复o(n2)；原地排序；稳定<br>（希尔排序是改进版的插入排序）<br>选择排序：最好、最坏和平均时复o(n2)；原地排序；不稳定<br>为何插入排序比冒泡排序更受欢迎？<br>每个交换或移动操作，插入仅需要1个单位时间，对应的冒泡需要3个<br>在限于位置的交换下，基于链表实现的三种排序算法性能如何？<br>三种时间复杂度和空间复杂度不变；时间复杂度系数上来看，冒泡增加，选择基本不变，插入减少","like_count":0},{"had_liked":false,"id":104265,"user_name":"　焚心以火","can_delete":false,"product_type":"c1","uid":1251067,"ip_address":"","ucode":"41AB4C408C96D1","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/fb/2727d82c.jpg","comment_is_top":false,"comment_ctime":1560702364,"is_pvip":false,"replies":[{"id":"37763","content":"自己写写代码看下就知道了","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560733032,"ip_address":"","comment_id":104265,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560702364","product_id":100017301,"comment_content":"我们先按照金额对订单数据进行排序。<br>这样是麻烦在哪里呢？<br><br> ","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454194,"discussion_content":"自己写写代码看下就知道了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560733032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103797,"user_name":"董帅军","can_delete":false,"product_type":"c1","uid":1455242,"ip_address":"","ucode":"DAB77161FD8E68","user_header":"https://static001.geekbang.org/account/avatar/00/16/34/8a/61bfebf8.jpg","comment_is_top":false,"comment_ctime":1560514760,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560514760","product_id":100017301,"comment_content":"冒泡排序交换不一定复杂吧😄","like_count":0},{"had_liked":false,"id":103795,"user_name":"董帅军","can_delete":false,"product_type":"c1","uid":1455242,"ip_address":"","ucode":"DAB77161FD8E68","user_header":"https://static001.geekbang.org/account/avatar/00/16/34/8a/61bfebf8.jpg","comment_is_top":false,"comment_ctime":1560514178,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560514178","product_id":100017301,"comment_content":"团队作战","like_count":0},{"had_liked":false,"id":102549,"user_name":"倡印","can_delete":false,"product_type":"c1","uid":1455958,"ip_address":"","ucode":"4F53AA5D017D89","user_header":"https://static001.geekbang.org/account/avatar/00/16/37/56/11068390.jpg","comment_is_top":false,"comment_ctime":1560249132,"is_pvip":false,"replies":[{"id":"37273","content":"选择排序你再看下原理。其排序的过程中，有交换的操作，导致不稳定的。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560382168,"ip_address":"","comment_id":102549,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560249132","product_id":100017301,"comment_content":"如果排序数字从小到大，使用选择排序。选择排序在无序组里面从后往前查找岂不是也能实现稳定排序？？？？？ 求讨论下。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453474,"discussion_content":"选择排序你再看下原理。其排序的过程中，有交换的操作，导致不稳定的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560382168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101880,"user_name":"重剑无锋","can_delete":false,"product_type":"c1","uid":1238330,"ip_address":"","ucode":"35A8E3BBDF57DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/3a/e2e1a7e8.jpg","comment_is_top":false,"comment_ctime":1560008767,"is_pvip":false,"replies":[{"id":"36772","content":"😁 貌似是的，针对不同数据。或者说两个3，我们也要人为区分个大小、先后。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560122251,"ip_address":"","comment_id":101880,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560008767","product_id":100017301,"comment_content":"满有序度 = n(n-1)&#47;2 这个地方感觉有个bug  如果 出现两个同样大小的元素 如 1 2 3 3 4 这种，满有序度 =  n(n-1)&#47;2 就不成立了","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453154,"discussion_content":"😁 貌似是的，针对不同数据。或者说两个3，我们也要人为区分个大小、先后。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560122251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99792,"user_name":"xilie","can_delete":false,"product_type":"c1","uid":1013805,"ip_address":"","ucode":"AFCC4E157F7830","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJVegfjqa0gM4hcRrBhZkIf7Uc5oeTMYsg6o5pd76IQlUoIIh2ic6P22xVEFtRnAzjyLtiaPVstkKug/132","comment_is_top":false,"comment_ctime":1559302363,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559302363","product_id":100017301,"comment_content":"插入和冒泡好像啊，一个是往左边排，一个是往右边排","like_count":0},{"had_liked":false,"id":99041,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1559134651,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1559134651","product_id":100017301,"comment_content":"插入排序<br> a[j+1] = value;<br>此处是因为 上面的for循环 ,--j  无论内部的执行与否, j已经被-1了 <br><br>所以是将比较出来的小的值,放到了 a[j+1]上面.","like_count":0},{"had_liked":false,"id":98314,"user_name":"糖","can_delete":false,"product_type":"c1","uid":1542834,"ip_address":"","ucode":"784DDA19104392","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJzP9yB6eIRRyVNe3iab0gXB6yOeaNRHGx6raTQz2grfE5N2LWl6uIj1mrSU7nxiaEzeSLp6xAkE3iaQ/132","comment_is_top":false,"comment_ctime":1558955445,"is_pvip":true,"replies":[{"id":"35217","content":"不正常。300多倍呢，vector肯定有用的不好的地方。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559007310,"ip_address":"","comment_id":98314,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558955445","product_id":100017301,"comment_content":"老师，我用c++中的vector和int[]数组分别实现这三种算法，发现两者之间差距不是一般的大，比如拿冒泡举例，我发现在给10000个整数排序时，他们之间能差几百倍，在我的机器上跑int[]需要0.2s而用vector需要73s，但是我的程序里只用到了[]这个运算符，对于二者差距这么大是正常的吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451641,"discussion_content":"不正常。300多倍呢，vector肯定有用的不好的地方。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559007310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98144,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1558920383,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558920383","product_id":100017301,"comment_content":"有点标记回收的意思，冒泡是发现逆序马上交换，插入则是早准位置一次办理多个逆序问题","like_count":0},{"had_liked":false,"id":95832,"user_name":"Mr.Ren","can_delete":false,"product_type":"c1","uid":1392846,"ip_address":"","ucode":"5FDD50CFB1CBBF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLCQX614vYChuhGrYJSichTb5gpEPnb5YdSpeBicFician56GRDaQT6Jfg4cax8MR8gvtw0E9fHwrGXjA/132","comment_is_top":false,"comment_ctime":1558195009,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558195009","product_id":100017301,"comment_content":"随机选择哨兵，然后换到第一个。","like_count":0},{"had_liked":false,"id":94147,"user_name":"蠟筆小噺","can_delete":false,"product_type":"c1","uid":1264412,"ip_address":"","ucode":"694ABA92BC48C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJN8s3YnzyDRCeg73yzglRgQgk581uIY1FRFO01GibMro4Mbxk58rRgulZTKrSGnd8ZD6RHY8uQj2A/132","comment_is_top":false,"comment_ctime":1557731356,"is_pvip":false,"replies":[{"id":"33702","content":"可以用二分查找，加快找到要插入的位置，但是并不能减少时间复杂度，因为将数据插入到查找到的位置的时候，还是要在数组中一个一个的挪位置。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1557791732,"ip_address":"","comment_id":94147,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557731356","product_id":100017301,"comment_content":"老师，插入排序部分，每次寻找插入位置时候，是否可以使用二分法变体寻找插入位置，最终使复杂度变成O(nlogn)呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449931,"discussion_content":"可以用二分查找，加快找到要插入的位置，但是并不能减少时间复杂度，因为将数据插入到查找到的位置的时候，还是要在数组中一个一个的挪位置。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557791732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93824,"user_name":"　焚心以火","can_delete":false,"product_type":"c1","uid":1251067,"ip_address":"","ucode":"41AB4C408C96D1","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/fb/2727d82c.jpg","comment_is_top":false,"comment_ctime":1557631158,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557631158","product_id":100017301,"comment_content":"golang,插排<br>func insertSort(nums []int) {<br>\tl := len(nums)<br>\tif l &lt;=1 {<br>\t\treturn <br>\t}<br>\tfor i:=1;i&lt;l;i++ {<br>\t\tfor j:=0; j&lt;i;j++ {<br>\t\t\t if nums[i] &gt; nums[j] { &#47;&#47; 大的交换<br>\t\t\t\tnums[i],nums[j] =  nums[j],nums[i]<br>\t\t\t }<br>\t\t}<br>\t}<br>}","like_count":0},{"had_liked":false,"id":92967,"user_name":"　　　　　　　　","can_delete":false,"product_type":"c1","uid":1193804,"ip_address":"","ucode":"89D9556E72D061","user_header":"https://static001.geekbang.org/account/avatar/00/12/37/4c/848aae03.jpg","comment_is_top":false,"comment_ctime":1557369659,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557369659","product_id":100017301,"comment_content":"  &#47;**<br>     * 这是使用链表来实现冒泡排序<br>     *<br>     * @param linkedList<br>     * @param n<br>     *&#47;<br>    public static void bubbleSort(LinkedList&lt;Integer&gt; linkedList, int n) {<br>        if (n &lt; 1) {<br>            return;<br>        }<br>        for (int i = 0; i &lt; n; i++) {<br>            &#47;&#47;提前退出冒泡标识<br>            boolean flag = false;<br>            for (int j = 0; j &lt; n - i - 1; j++) {<br>                if (linkedList.get(j) &gt; linkedList.get(j + 1)) {<br>                    int tmp = linkedList.get(j);<br>                    linkedList.set(j, linkedList.get(j + 1));<br>                    linkedList.set(j + 1, tmp);<br>                    flag = true;&#47;&#47;表示有数据交互<br>                }<br>            }<br>            if (!flag) {<br>                break;<br>            }<br>        }<br>    }<br><br>    &#47;**<br>     * 插入排序 基于链表实现<br>     *<br>     * @param linkedLis<br>     * @param n<br>     *&#47;<br>    public static void insertionSort(LinkedList&lt;Integer&gt; linkedLis, int n) {<br>        if (n &lt;= 1) {<br>            return;<br>        }<br><br>        &#47;&#47;循环变量链表<br>        for (int i = 1; i &lt; n; i++) {<br>            int value = linkedLis.remove(i);<br>            int j = i - 1;<br>            for (; j &gt;= 0; j--) {<br>                if (linkedLis.get(j) &lt; value) {<br>                    break;<br>                }<br>            }<br>            linkedLis.add(j + 1, value);<br>        }<br>    }<br><br><br>    &#47;**<br>     * 选择排序 基于链表<br>     *<br>     * @param linkedList<br>     * @param n<br>     *&#47;<br>    public static void selectSort(LinkedList&lt;Integer&gt; linkedList, int n) {<br>        for (int i = 0; i &lt; n; i++) {<br>            int k = i;<br>            &#47;&#47;找出最小下标的值<br>            for (int j = i + 1; j &lt; n ; j++) {<br>                if(linkedList.get(j) &lt; linkedList.get(k)){<br>                    k = j;<br>                }<br>            }<br><br>            &#47;&#47;将最小值放到未排序记录的第一个位置<br>            if(k &gt; i) {<br>                int tmp = linkedList.get(i);<br>                linkedList.set(i, linkedList.get(k));<br>                linkedList.set(k, tmp);<br>            }<br>        }     <br>    }<br><br>各位大佬，请多指教","like_count":0},{"had_liked":false,"id":92556,"user_name":"Danny","can_delete":false,"product_type":"c1","uid":1243886,"ip_address":"","ucode":"5EBD4E9ECBAE7A","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/ee/8303a7d6.jpg","comment_is_top":false,"comment_ctime":1557300693,"is_pvip":false,"replies":[{"id":"33264","content":"哈哈，还要更厉害的，你可以看下我写的这篇：<br>https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;-JGbGbwk7K9NTT1BYsovgg","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1557451353,"ip_address":"","comment_id":92556,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557300693","product_id":100017301,"comment_content":"睡眠排序，这个厉害了<br>public class SleepSort {  <br>\t<br>    public static void main(String[] args) {  <br>    \t<br>        int[] arr = {1,4,7,3,8,9,2,6,5};<br>        &#47;&#47;创建指定长度的线程数组<br>        SortThread[] sortThreads = new SortThread[arr.length];  <br>        &#47;&#47;指定每个线程数组的值<br>        for (int i = 0; i &lt; sortThreads.length; i++) {  <br>            sortThreads[i] = new SortThread(arr[i]);  <br>        } <br>        &#47;&#47;开启每个线程<br>        for (int i = 0; i &lt; sortThreads.length; i++) {  <br>            sortThreads[i].start();  <br>        }  <br>    }  <br>}  <br>class SortThread extends Thread{  <br>    int s = 0;  <br>    public SortThread(int s){  <br>        this.s = s;  <br>    }  <br>    public void run(){  <br>        try {  <br>            sleep(s*10+10);  &#47;&#47;睡眠指定的时间<br>        } catch (InterruptedException e) {  <br>              <br>            e.printStackTrace();  <br>        }  <br>        &#47;&#47;输出该数<br>        System.out.println(s);  <br>    }  <br>}  <br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449317,"discussion_content":"哈哈，还要更厉害的，你可以看下我写的这篇：\nhttps://mp.weixin.qq.com/s/-JGbGbwk7K9NTT1BYsovgg","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557451353,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90631,"user_name":"平头哥","can_delete":false,"product_type":"c1","uid":1482189,"ip_address":"","ucode":"33BFBC9934046A","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eojas5DpMgT2bUdTia6mXOo8ch4g9vYzwqlW2S0lD6BuibDgAJ28u8Q4voJ2jdZTdGVoU4W8dDXgg4g/132","comment_is_top":false,"comment_ctime":1556591852,"is_pvip":false,"replies":[{"id":"32581","content":"没怎么看懂你说的呢","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1556702194,"ip_address":"","comment_id":90631,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556591852","product_id":100017301,"comment_content":"插入排序  a[j+1] = a[j]; &#47;&#47; 数据移动  a[j]的值是否应该要赋值一下了？<br><br> ","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448600,"discussion_content":"没怎么看懂你说的呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556702194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89680,"user_name":"jsntszp","can_delete":false,"product_type":"c1","uid":1258433,"ip_address":"","ucode":"4AC7A1652FFBDA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/A4UMCHkSgpfHibEk3CYwwbl3IvabldYibfm4o3wsgpiaCsPUotvMGlhBwO5p3ZZAmx0qicicqdibx4S7Poblb56w7Iqw/132","comment_is_top":false,"comment_ctime":1556243518,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556243518","product_id":100017301,"comment_content":"插入排序会出现j为-1的情况","like_count":0},{"had_liked":false,"id":88728,"user_name":"ThinkingMan.","can_delete":false,"product_type":"c1","uid":1217603,"ip_address":"","ucode":"722674A8BACA85","user_header":"https://static001.geekbang.org/account/avatar/00/12/94/43/6e68c860.jpg","comment_is_top":false,"comment_ctime":1555986761,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555986761","product_id":100017301,"comment_content":"这一节学起来感觉就有点吃力了^_^，还得多花时间来啃","like_count":0},{"had_liked":false,"id":85486,"user_name":"张珂","can_delete":false,"product_type":"c1","uid":1451555,"ip_address":"","ucode":"63D5760B253A59","user_header":"https://static001.geekbang.org/account/avatar/00/16/26/23/e99ff49f.jpg","comment_is_top":false,"comment_ctime":1555074892,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555074892","product_id":100017301,"comment_content":"对于开篇的问题写一点小想法：<br>插入排序的数据交换操作确实比冒泡排序的要简单，操作次数少。但个人还有一点想法，就是对于需要经常数据变动的排序来说，插入排序对于已排序好的部分没有影响，直接将新数据通过一次遍历插入即可，此时时间复杂度是O(n)。而冒泡排序则比较麻烦，整个数组都需要重新排序才行，时间复杂度则又是O(n2)","like_count":0},{"had_liked":false,"id":84965,"user_name":"Frankie_圳","can_delete":false,"product_type":"c1","uid":1482880,"ip_address":"","ucode":"A16B40AF83C184","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/80/6f9d3ebd.jpg","comment_is_top":false,"comment_ctime":1554950032,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554950032","product_id":100017301,"comment_content":"自己尝试实现了一下选择排序，感觉更像是冒泡排序<br>测试了一下三种排序算法，由快到慢依次是 选择排序、插入排序、冒泡排序。这好像和老师讲的不符合啊？<br>有错误请老师指教，谢谢<br><br>以下为选择排序的代码：<br>public class SelectionSort {<br>\tpublic void sort(int[] a ,int n) {<br>\t\tfor(int i=0;i&lt;n;i++) {<br>\t\t\tint min = Integer.MAX_VALUE;<br>\t\t\tint flag = -1;<br>\t\t\tfor(int j=i;j&lt;n;j++) {<br>\t\t\t\tif(a[j]&lt;min) {<br>\t\t\t\t\tmin = a[j];<br>\t\t\t\t\tflag = j;<br>\t\t\t\t}<br>\t\t\t}<br>\t\t\tint temp = a[i];<br>\t\t\ta[i] = a[flag];<br>\t\t\ta[flag] = temp;<br>\t\t}<br>\t}<br>}","like_count":0},{"had_liked":false,"id":84906,"user_name":"泡泡","can_delete":false,"product_type":"c1","uid":1147399,"ip_address":"","ucode":"7F071EE06D7747","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKCmqW21Zguv8kPiayib4U42B3jLGk2Y4Leia0fQjnU0Lfgic8BwbdMIePiayDadFKzV9kSt3F8jRicZxxA/132","comment_is_top":false,"comment_ctime":1554944445,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554944445","product_id":100017301,"comment_content":"n（n-1）=n^2-n，n趋于无穷大的时候，-n那就是个可以忽略的小小数，所以就等价于n^2了","like_count":0},{"had_liked":false,"id":84055,"user_name":"wang","can_delete":false,"product_type":"c1","uid":1270262,"ip_address":"","ucode":"C1A3BCACCB188E","user_header":"https://static001.geekbang.org/account/avatar/00/13/61/f6/1d6b548a.jpg","comment_is_top":false,"comment_ctime":1554775899,"is_pvip":false,"replies":[{"id":"31014","content":"你可以自己测试下，好像也不行","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1555381145,"ip_address":"","comment_id":84055,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554775899","product_id":100017301,"comment_content":"老师，基于快排的稳定性，网上很多不同的说法，说是很难实现，需要有额外的空间，重点在于partition的操作，我采用关于前后指针法进行的操作，也就是维护一个bigger 指针始终指向的是第一个大于pivot 分界值的，遇到小于pivot 分界值的，就交换，不是只要保证如果相等的情况也进行交换就能保证稳定行了吗？不知道想法对不对<br>public static int partition_(int[] arr, int left, int right ){<br>        int bigger = left;<br>        int pivot = arr[right];<br>        &#47;&#47; 找到第一个bigger<br>        int j = left;<br>        for (; j &lt;= right; ++j){<br>            if(arr[j] &gt; arr[right]){<br>                bigger = j;<br>                break;<br>            }<br>        }<br>        if(bigger == left &amp;&amp; j-1 == right){<br>            return right;<br>        }<br>        for(int i = j; i &lt; right; ++i){<br>            if(arr[i] &lt;= pivot){<br>                swap(arr, i, bigger);<br>                bigger++;<br>            }<br>        }<br>        if(bigger != right){<br>            swap(arr, bigger, right);<br>        }<br>        return bigger;<br>    }<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446233,"discussion_content":"你可以自己测试下，好像也不行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555381145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82921,"user_name":"好好学习","can_delete":false,"product_type":"c1","uid":1258789,"ip_address":"","ucode":"63A002997462E3","user_header":"https://static001.geekbang.org/account/avatar/00/13/35/25/bab760a1.jpg","comment_is_top":false,"comment_ctime":1554348992,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554348992","product_id":100017301,"comment_content":"冒泡排序两层循环，计算平均时间复杂度，可以认为外层平均循环 n&#47;2 次，此时内存循环为 n&#47;2 次，平均复杂度 n^2&#47;4  可以认为是 O(n^2)","like_count":0},{"had_liked":false,"id":79754,"user_name":"___","can_delete":false,"product_type":"c1","uid":1229519,"ip_address":"","ucode":"B0BA5A1413798C","user_header":"https://static001.geekbang.org/account/avatar/00/12/c2/cf/573a0fdc.jpg","comment_is_top":false,"comment_ctime":1553533362,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553533362","product_id":100017301,"comment_content":"选择排序，<br>在有序的情况下，依然要依次遍历找出最小值，所以最好时间复杂度为O(n^2)<br><br>看n变不如多敲几遍","like_count":0},{"had_liked":false,"id":78042,"user_name":"机遇号","can_delete":false,"product_type":"c1","uid":1105053,"ip_address":"","ucode":"A2940DE77BCAEA","user_header":"https://static001.geekbang.org/account/avatar/00/10/dc/9d/e20b37d7.jpg","comment_is_top":false,"comment_ctime":1553061334,"is_pvip":false,"replies":[{"id":"28520","content":"前提是数据已经在内存中了，这里跟数据库没关系的。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1553133600,"ip_address":"","comment_id":78042,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553061334","product_id":100017301,"comment_content":"您好，文中举例说10条订单排序问题。您的意思是不是根据时间排序从数据库中查询出来再使用稳定排序？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443946,"discussion_content":"前提是数据已经在内存中了，这里跟数据库没关系的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553133600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77422,"user_name":"854434716","can_delete":false,"product_type":"c1","uid":1462056,"ip_address":"","ucode":"AFBE96ECD85015","user_header":"https://static001.geekbang.org/account/avatar/00/16/4f/28/a4049049.jpg","comment_is_top":false,"comment_ctime":1552922253,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552922253","product_id":100017301,"comment_content":"做插入排序的话恐怕单链表很困难吧 获取前置节点往前插的操作怎么搞 数组一个 --操作 搞定了 单链表不行呐","like_count":0},{"had_liked":false,"id":77232,"user_name":"Cato","can_delete":false,"product_type":"c1","uid":1445356,"ip_address":"","ucode":"532DD9AE61830C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/HyQpynfiaic8RhuT7Vhia1RgYq20gYNQPW6sGTxZllaQ0uwJe6SQBoAmibyZic8SwfsQTdgECeO5ic8CBZc6AJicUcQGg/132","comment_is_top":false,"comment_ctime":1552893744,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552893744","product_id":100017301,"comment_content":"用 Swift 实现了一下插入排序，发现修改不了 a[0] 的值，仔细看了一下才发现 Java 的 for 循环会在 --j 之后再做条件判断（j &gt;= 0），所以 j 确实可以是 -1","like_count":0},{"had_liked":false,"id":77113,"user_name":"赵高龙","can_delete":false,"product_type":"c1","uid":1259115,"ip_address":"","ucode":"0DF7550246BFA5","user_header":"https://static001.geekbang.org/account/avatar/00/13/36/6b/d20ee86b.jpg","comment_is_top":false,"comment_ctime":1552837205,"is_pvip":false,"replies":[{"id":"28121","content":"这会不会跟语言执行器本身的优化有关系呢？你可以先执行ByZhaogaolong，再执行ByWangZheng试下。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1552876022,"ip_address":"","comment_id":77113,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552837205","product_id":100017301,"comment_content":"老师您好，有一事不明，在10w个数据排序的测试中，我看到你优化的冒泡排序的代码，基本少了1&#47;2（5w次）的循环，但在冒泡排序中反而没有没有优化的（10w次）的循环快，请指点。<br><br> ```golang<br>package main<br><br>import (<br>\t&quot;fmt&quot;<br>\t&quot;math&#47;rand&quot;<br>\t&quot;time&quot;<br>)<br><br>func BubbleSortByWangZheng(data []int) {<br>\tc := 0<br>\tn := len(data)<br>\tfor i := 0; i &lt; n; i++ {<br>\t\tflag := false<br>\t\tfor j := 0; j &lt; n-i-1; j++ {<br>\t\t\tc++<br>\t\t\tif data[j] &lt; data[j+1] {<br>\t\t\t\tdata[j], data[j+1] = data[j+1], data[j]<br>\t\t\t\tflag = true<br>\t\t\t}<br>\t\t}<br>\t\tif !flag {<br>\t\t\tbreak<br>\t\t}<br>\t}<br>\tfmt.Printf(&quot;共循环：%d 次\\n&quot;, c)<br>}<br><br>func BubbleSortByZhaogaolong(data []int) {<br>\tc := 0<br>\tn := len(data)<br>\tfor i := 0; i &lt; n; i++ {<br>\t\tfor j := 0; j &lt; n; j++ {<br>\t\t\tc++<br>\t\t\tif data[i] &gt; data[j] {<br>\t\t\t\tdata[i], data[j] = data[j], data[i]<br>\t\t\t}<br>\t\t}<br>\t}<br>\tfmt.Printf(&quot;共循环：%d 次\\n&quot;, c)<br>}<br><br>func RandNumber(count int) []int {<br>\tvar result []int<br>\tfor i := 0; i &lt; count; i++ {<br>\t\tresult = append(<br>\t\t\tresult,<br>\t\t\trand.Intn(100),<br>\t\t)<br>\t}<br>\treturn result<br>}<br><br>func main() {<br>\tstart := time.Now()<br>\tdata := RandNumber(100000)<br>\tdata2 := []int{}<br>\tdata2 = append(data2, data...)<br>\tfmt.Println(&quot;构造数据花费时间：&quot;, time.Since(start))<br><br>\tstart2 := time.Now()<br>\tBubbleSortByWangZheng(data)<br>\tfmt.Println(&quot;数据排序ByWangZheng 花费时间：&quot;, time.Since(start2))<br><br>\tstart3 := time.Now()<br>\tBubbleSortByZhaogaolong(data2)<br>\tfmt.Println(&quot;数据排序ByZhaogaolong 花费时间：&quot;, time.Since(start3))<br>}<br>```<br><br>执行结果：<br>➜  sort go run main.go<br>构造数据花费时间： 5.844981ms<br>共循环：4999447497 次<br>数据排序ByWangZheng 花费时间： 16.695706092s<br>共循环：10000000000 次<br>数据排序ByZhaogaolong 花费时间： 5.64327824s<br><br>为什么差距这么大呢？<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443584,"discussion_content":"这会不会跟语言执行器本身的优化有关系呢？你可以先执行ByZhaogaolong，再执行ByWangZheng试下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552876022,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75840,"user_name":"小样","can_delete":false,"product_type":"c1","uid":1446283,"ip_address":"","ucode":"4E43FBF236AEB8","user_header":"https://static001.geekbang.org/account/avatar/00/16/11/8b/47f65375.jpg","comment_is_top":false,"comment_ctime":1552480033,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552480033","product_id":100017301,"comment_content":"感觉时间复杂度最好最好，还可以看懂，里面的平均时间复杂度 ，有些难理解","like_count":0},{"had_liked":false,"id":75654,"user_name":"张珂","can_delete":false,"product_type":"c1","uid":1451555,"ip_address":"","ucode":"63D5760B253A59","user_header":"https://static001.geekbang.org/account/avatar/00/16/26/23/e99ff49f.jpg","comment_is_top":false,"comment_ctime":1552444464,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552444464","product_id":100017301,"comment_content":"第一节课的时候立了flag要好好写评论，但今天这个课下作业确实有点想不明白了。<br>看了有个同学跑了冒泡和插入排序的性能实验，我也就跑了下选择和插入排序的性能实验，分别跑int[10000][10000]的随机数组排序，生成随机数时使用相同的随机数种子，结果为选择排序平均用230213毫秒，插入排序平均用112100毫秒","like_count":0},{"had_liked":false,"id":75067,"user_name":"红红股海","can_delete":false,"product_type":"c1","uid":1064854,"ip_address":"","ucode":"188FD60BEFD25F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKnoSoric6IJjI9icQdhaL3IKRwbeic4IoLYAFricOzm0LnGbALtY6VQCYZ1AOiaux2foHok3OpRY94oxw/132","comment_is_top":false,"comment_ctime":1552353291,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552353291","product_id":100017301,"comment_content":"选择排序还是有优点的，交换的次数最少","like_count":0},{"had_liked":false,"id":74408,"user_name":"Yesterday","can_delete":false,"product_type":"c1","uid":1010409,"ip_address":"","ucode":"6A416B7906C1E0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6a/e9/d76511d8.jpg","comment_is_top":false,"comment_ctime":1552219633,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552219633","product_id":100017301,"comment_content":"冒泡排序中，内层循环结束后，需要重置一下 flag.<br><br>```java<br>    void bubbleSort(int arr[]) {<br>        if (arr == null || arr.length &lt;= 1) {<br>            return;<br>        }<br><br>        int len = arr.length;<br>        boolean sorted = true;<br>        for (int i = 0; i &lt; len; i++) {<br>            for (int j = 0; j &lt; len - i - 1; j++) {<br>                if (arr[j] &gt; arr[j + 1]) {<br>                    int tmp = arr[j];<br>                    arr[j] = arr[j + 1];<br>                    arr[j + 1] = tmp;<br>                    sorted = false;<br>                }<br>            }<br><br>            if (sorted) {<br>                break;<br>            }<br><br>            sorted = true;<br>        }<br>    }<br>```","like_count":0},{"had_liked":false,"id":74101,"user_name":"mrlay","can_delete":false,"product_type":"c1","uid":1041640,"ip_address":"","ucode":"385A1954ED3317","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e4/e8/a1703783.jpg","comment_is_top":false,"comment_ctime":1552104139,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552104139","product_id":100017301,"comment_content":"思考题：答案是坑定。 思路一 ： 提取链表的key 稳定的放入新构造的数组中； 思路二： 直接排序，但是链表间成员的交换是比较复杂的；处理的号只是会让系数变大，多了低阶项。","like_count":0},{"had_liked":false,"id":71875,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1551458381,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551458381","product_id":100017301,"comment_content":"总结:冒泡排序,插入排序，选择排序的时间空间复杂度分析和是否稳定性，有序数和满逆序数和逆序数的概念，对排序算法的认识有进一步的提升","like_count":0},{"had_liked":false,"id":71064,"user_name":"汪木木","can_delete":false,"product_type":"c1","uid":1095399,"ip_address":"","ucode":"A2B1EFCBBB7387","user_header":"https://static001.geekbang.org/account/avatar/00/10/b6/e7/6d49e73f.jpg","comment_is_top":false,"comment_ctime":1551257435,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551257435","product_id":100017301,"comment_content":"选择排序<br>public static void sort(int[] arr, int n) {<br>        if (n &lt;= 1) {<br>            return;<br>        }<br>        for (int i = 0; i &lt; n; i++) {<br>            &#47;**<br>             * mark the first element of unsorted as minimum<br>             *&#47;<br>            int minimum = arr[i];<br>            int minIndex = i;<br><br>            &#47;**<br>             * for each of the unsorted elements<br>             * extract the minimum element X<br>             *&#47;<br>            for (int j = i + 1; j &lt; n; j++) {<br>                if (arr[j] &lt; minimum) {<br>                    minimum = arr[j];<br>                    minIndex = j;<br>                }<br>            }<br><br>            &#47;**<br>             * swap<br>             *&#47;<br>            int temp = arr[i];<br>            arr[i] = arr[minIndex];<br>            arr[minIndex] = temp;<br>        }<br>    }","like_count":0},{"had_liked":false,"id":70046,"user_name":"the one","can_delete":false,"product_type":"c1","uid":1348149,"ip_address":"","ucode":"693C8676903100","user_header":"https://static001.geekbang.org/account/avatar/00/14/92/35/c2a2f6ea.jpg","comment_is_top":false,"comment_ctime":1550975731,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550975731","product_id":100017301,"comment_content":"插入排序有一个优化策略，因为已排序区是有序的，所以在已排序区数比较多的时候，找插入位置的时候可以用二分查找。","like_count":0},{"had_liked":false,"id":69394,"user_name":"信天游","can_delete":false,"product_type":"c1","uid":1046101,"ip_address":"","ucode":"4B46403E169499","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f6/55/1065fce8.jpg","comment_is_top":false,"comment_ctime":1550733733,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550733733","product_id":100017301,"comment_content":"老师 忽略我上面说的那个，完全有序是O(n),已经想清楚了","like_count":0},{"had_liked":false,"id":69389,"user_name":"信天游","can_delete":false,"product_type":"c1","uid":1046101,"ip_address":"","ucode":"4B46403E169499","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f6/55/1065fce8.jpg","comment_is_top":false,"comment_ctime":1550733254,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550733254","product_id":100017301,"comment_content":"完全有序的冒泡排序不应该直接输出结果么？<br>一次也不用冒泡；在内层循环中 a[i]一直比a[i+1]小的，不需要做比较操作","like_count":0},{"had_liked":false,"id":67314,"user_name":"浩涛","can_delete":false,"product_type":"c1","uid":1390697,"ip_address":"","ucode":"DCF935D3F9FC6D","user_header":"https://static001.geekbang.org/account/avatar/00/15/38/69/7b11b341.jpg","comment_is_top":false,"comment_ctime":1550128862,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550128862","product_id":100017301,"comment_content":"我觉得冒泡跟排序的区别是比较的对象不同，同样是分为有序区和无序区，冒泡是在无序比较，插曲则是拿无序在有序比较，所以插曲排序在比较时可以预知后面比较结果，在找到插曲点直接插入并终止循环","like_count":0},{"had_liked":false,"id":67239,"user_name":"Aaron","can_delete":false,"product_type":"c1","uid":1067913,"ip_address":"","ucode":"441614DAEAF8D0","user_header":"https://static001.geekbang.org/account/avatar/00/10/4b/89/a65d1a3f.jpg","comment_is_top":false,"comment_ctime":1550114432,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550114432","product_id":100017301,"comment_content":"尝试着 swift 实现了下选择排序 但是感觉有点像冒泡啊.. 不知道对不对:<br>func selectionSort(array:[Int])-&gt;[Int]{<br>    <br>    var tem = array<br>    for _ in 0...array.count-1{<br>        var sorted = 1<br>        repeat {<br>            var compared = 0<br>            for i in (sorted...tem.count-1-compared).reversed(){<br>                if  tem[i] &lt; tem[i-1]{<br>                    tem.swapAt(i,i-1)<br>                }<br>            }<br>            compared += 1<br>            sorted += 1<br>        }while sorted == array.count - 1<br>    }<br>    <br>    return tem<br>}","like_count":0},{"had_liked":false,"id":65867,"user_name":"Pre-Y","can_delete":false,"product_type":"c1","uid":1396900,"ip_address":"","ucode":"A13D13A37F3ABC","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/a4/8d2e454b.jpg","comment_is_top":false,"comment_ctime":1549708001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549708001","product_id":100017301,"comment_content":"今日份的打卡。<br>一遍刷下来对稳定性分析有了形象的认识，对三种排序也有了新的认识。😬对于逆序度还有点模糊，查阅资料再刷一遍。","like_count":0},{"had_liked":false,"id":65544,"user_name":"西西弗与卡夫卡","can_delete":false,"product_type":"c1","uid":1001710,"ip_address":"","ucode":"B4C27B8335B76A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/ee/872ad07e.jpg","comment_is_top":false,"comment_ctime":1549442896,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1549442896","product_id":100017301,"comment_content":"如果用选择排序中的数组用链表替换，交换变成节点摘取和插入的话，整个算法就变成稳定排序了","like_count":0},{"had_liked":false,"id":63860,"user_name":"卖藥郎","can_delete":false,"product_type":"c1","uid":1231829,"ip_address":"","ucode":"0539EF1D335918","user_header":"https://static001.geekbang.org/account/avatar/00/12/cb/d5/fab32cf7.jpg","comment_is_top":false,"comment_ctime":1548560940,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548560940","product_id":100017301,"comment_content":"王老师你好，平时我们需要的数据都是在数据库中进行排序操作的，数据库中的排序算法是怎样的呢？","like_count":0},{"had_liked":false,"id":63538,"user_name":"安南寸暖🤕","can_delete":false,"product_type":"c1","uid":1387564,"ip_address":"","ucode":"9E8036B99E3F16","user_header":"https://static001.geekbang.org/account/avatar/00/15/2c/2c/77f80dfc.jpg","comment_is_top":false,"comment_ctime":1548395228,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548395228","product_id":100017301,"comment_content":"选择排序为什么是不稳定排序呢？  类似  1(1)，3(1)，1(2)，5，1(3)，2，3(2)<br>排序如下：<br>1.   1(1)，3(1)，1(2)，5，1(3)，2，3(2)<br>2.  1(1)，1(2)，3(1)，5，1(3)，2，3(2)<br>3.  1(1)，1(2)，1(3)，3(1)，5，2，3(2)<br>4.  1(1)，1(2)，1(3)，2，3(1)，5，3(2)<br>5.  1(1)，1(2)，1(3)，2，3(1)，5，3(2)<br>6.  1(1)，1(2)，1(3)，2，3(1)，3(2)，5<br><br>我觉得是否稳定取决于具体的写法， 如何找到未排序中的最小值会影响到整体算法是否是稳定的。<br>如果采用存储最小值和地址的方法 等于的情况就不要把当前键值赋值给存储最小值和地址的方法<br>talk is cheap,  show you code<br>```<br>public void sort(int[] a, int n) {<br>  if (n &lt;= 1) return;<br>  int min = MAX;<br>  int minIndex = 0;<br>  int middleValue = 0;<br>  for (int i = 0; i &lt; n; i++) {<br>    &#47;&#47; 寻找最小值<br>    for (int j = 0; j &lt; i; j++) {<br>      if (a[j] &lt; min) {  &#47;&#47; 等于的时候不置换<br>        minIndex = j<br>      }<br>    }<br>    middleValue = a[j]<br>    a[j] = a[i]<br>    a[i] = middleValue;<br>  }<br>}<br>```<br>这样就变成稳定排序了呀  还有插入排序是否是稳定排序也看怎么找位置 如果从大到小找位置的话 就是稳定排序  如果从小到大判断前一个元素的位置的话 就变成了不稳定排序了呀。","like_count":0},{"had_liked":false,"id":63231,"user_name":"isea_you","can_delete":false,"product_type":"c1","uid":1015440,"ip_address":"","ucode":"8D6CBABACED5FE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/90/21db58fd.jpg","comment_is_top":false,"comment_ctime":1548303116,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548303116","product_id":100017301,"comment_content":"冒泡是严格的O(N^2)的排序算法吧。因为每一次需要比对，<br><br>而插入就不是，因为前面是有序的，所以如果原始数据是顺序的话，每一给都只比较一个值，前面的数据就不需要比较了，因此可以做到时间复杂度为O（1），这就是插入排序的优势，它利用了之前的排序。<br><br>选择排序也是严格的O（N^2）的，因为，即便是顺序的数据，也还是需要遍历找到最大，放在数组的末端。<br><br>冒泡排序在面对顺序的原始数据的时候，还是需要两两比对，即便不用交换，但是比对，仍然是O（N^2）的。<br><br>如果不对，请指教。","like_count":0},{"had_liked":false,"id":60728,"user_name":"猎斜曜","can_delete":false,"product_type":"c1","uid":1159535,"ip_address":"","ucode":"A48126BD38347B","user_header":"https://static001.geekbang.org/account/avatar/00/11/b1/6f/826b1763.jpg","comment_is_top":false,"comment_ctime":1547538513,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547538513","product_id":100017301,"comment_content":"boolean flag = false;<br>这个赋值可以写在循环外面，不必每次赋值。","like_count":0},{"had_liked":false,"id":58528,"user_name":"李","can_delete":false,"product_type":"c1","uid":1119312,"ip_address":"","ucode":"5C0FAA211F2E26","user_header":"https://static001.geekbang.org/account/avatar/00/11/14/50/c23cf47d.jpg","comment_is_top":false,"comment_ctime":1547104358,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1547104358","product_id":100017301,"comment_content":"平均情况下，需要 n*(n-1)&#47;4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n^2)，所以平均情况下的时间复杂度就是 O(n^2)。<br>从这个来看 平均交换n^2-n&#47;4     &lt; 平均比较  <br>那么         n*(n-1)&#47;2  &lt;平均交换+平均比较  &lt;O(n^2)  <br>去掉常数是  n^2-n    <br>为什么平均复杂度不是n^2-n  ，n能直接省去吗？  直接省去 和坏复杂度不就一样了吗。<br>明显有好的时候，不应该平均复杂度和最坏的一样吧？那平均还有什么意义呢？<br>不是很理解这种考虑<br>","like_count":0},{"had_liked":false,"id":57963,"user_name":"halo","can_delete":false,"product_type":"c1","uid":1138057,"ip_address":"","ucode":"782892605CC855","user_header":"https://static001.geekbang.org/account/avatar/00/11/5d/89/93b837d6.jpg","comment_is_top":false,"comment_ctime":1546951690,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546951690","product_id":100017301,"comment_content":"排序考虑   时间空间复杂度，稳定性","like_count":0},{"had_liked":false,"id":57953,"user_name":"泉","can_delete":false,"product_type":"c1","uid":1099760,"ip_address":"","ucode":"914709BE802A8D","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/f0/aa2e0749.jpg","comment_is_top":false,"comment_ctime":1546950268,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1546950268","product_id":100017301,"comment_content":"冒泡<br>插入<br>选择<br>","like_count":0},{"had_liked":false,"id":56534,"user_name":"寒溪","can_delete":false,"product_type":"c1","uid":1001970,"ip_address":"","ucode":"67B9F1A1C15A20","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/f2/25cfa472.jpg","comment_is_top":false,"comment_ctime":1546483569,"is_pvip":false,"replies":[{"id":"20488","content":"paper","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1546566538,"ip_address":"","comment_id":56534,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1546483569","product_id":100017301,"comment_content":"博主讲的非常精彩慢条斯理，请问图是用什么工具画的？<br>谢谢！","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435099,"discussion_content":"paper","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546566538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56295,"user_name":"Suns","can_delete":false,"product_type":"c1","uid":1118301,"ip_address":"","ucode":"49D791F4A56E23","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/5d/db5cd2d3.jpg","comment_is_top":false,"comment_ctime":1546417300,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546417300","product_id":100017301,"comment_content":"冒泡排序最外层循环结束条件是不是应该是 i  &lt; n -1 ？","like_count":0},{"had_liked":false,"id":53954,"user_name":"大可可","can_delete":false,"product_type":"c1","uid":1186458,"ip_address":"","ucode":"BC635013E7B87E","user_header":"https://static001.geekbang.org/account/avatar/00/12/1a/9a/7b246eb1.jpg","comment_is_top":false,"comment_ctime":1545781243,"is_pvip":false,"replies":[{"id":"19656","content":"是的 你说的没错","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545826051,"ip_address":"","comment_id":53954,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1545781243","product_id":100017301,"comment_content":"老师，冒泡和插入交换的次数是一样的，比较的次数不是一样的吧","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434300,"discussion_content":"是的 你说的没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545826051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1205873,"avatar":"https://static001.geekbang.org/account/avatar/00/12/66/71/8a5d02ab.jpg","nickname":"蓝色~冰*羽","note":"","ucode":"E2F6424766AD7C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21086,"discussion_content":"为什么我感觉比较的次数是一样的啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569420476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":53555,"user_name":"CathyLin","can_delete":false,"product_type":"c1","uid":1240546,"ip_address":"","ucode":"F7CDFF5E1A235F","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/e2/0e1c6c5a.jpg","comment_is_top":false,"comment_ctime":1545670829,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545670829","product_id":100017301,"comment_content":"先回答思考题：<br>我觉得这三种算法都是可以通过链表来实现的。但是我觉得用双向链表会更好些。<br>1) bubble sort: 时间复杂度为 O(n^2)，空间复杂度为 O(1)<br>2) insertion sort: 时间复杂度为 O(n^2)，空间复杂度为 O(1)<br>3) selection sort: 时间复杂度为 O(n^2)，空间复杂度为 O(1)<br><br>笔记有点多还请见谅 +_+<br>经典的排序算法<br>⎣带着问题去学习，是最有效的学习方法。⎤<br><br>如何分析一个排序算法？<br>除了学习算法原理和代码实现之外，还要学习如何评价、分析一个排序算法。<br><br>排序算法的执行效率<br>1）在分析时间复杂度时，要给出最好、最坏、平均时间复杂度。<br>2）以及要给出是在什么原始数据下到达那种时间复杂度。<br>3）考虑比较次数 &amp; 交换次数<br><br>排序算法的内存消耗<br>原地排序 (sorted in place) - 就是空间复杂度为 O(1) 的排序算法。这里讲的 3 种都是原地排序。<br><br>排序算法的稳定性<br>稳定性是指：如果要排序的数组中存在相同大小的数字，如果排完序之后这两个元素的先后顺序没有变化，那么就说明是一个稳定的排序；否则说明是不稳定的。<br>稳定排序可以用在订单排序中。<br><br>冒泡排序 (Bubble Sort)<br>冒泡排序每次只会比较相邻的两个数据，如果不满足大小关系，那么就进行交换顺序；这样始终能保证一次能够使至少一个数归到正确的位置上去。然后重复 n 次，就完成了 n 个数的排序工作。<br><br>例子，对一组数据 4,5,6,3,2,1 进行第一次冒泡排序的过程。<br>优化：当某次冒泡排序没有数据交换时，那么说明已经到达了完全排序，那么就不用再进行后续的冒泡排序了。<br><br>冒泡排序最好时间复杂度为 O(n)，最坏时间复杂度为 O(n^2)。<br>平均时间复杂度：我们前面说的是加权平均期望时间复杂度，要结合概率论。<br>这里我们用“有序度”和“逆序度”两个概念来分析。<br><br>有序度 - 是指数组中具有有序关系的元素对的个数。<br>有序元素对：a[i] &lt;= a[j], 如果 i &lt; j。<br><br>对于一个倒序排列的数组，有序度为 0；对于一个完全有序的数组，有序度为 n*(n-1)&#47;2，也叫满有序度。<br><br>逆序度 - 和有序度的定义刚好相反。<br>逆序元素对：a[i] &gt; a[j], 如果 i &lt; j。<br>逆序度 = 满有序度 - 有序度。<br><br>排序就是为了增加有序度，减少逆序度的过程，并且最后达到满有序度，就说明完成了。<br>每交换一次，有序度就加 1。无论算法怎么改进，交换次数是一定的，就是等于逆序度。<br><br>对于包含 n 个元素的数组进行冒泡排序，平均交换次数是多少呢？<br>最好的情况就是初始状态的有序度为 n*(n-1)&#47;2，那么交换次数就是 0 。<br>最坏情况下，初始状态的有序度为 0 ，那么交换次数就为 n*(n-1)&#47;2。<br>我们可以取一个中间值 n*(n-1)&#47;4 来表示平均交换情况。<br>所以平均情况下的时间复杂度就为 O(n^2)。<br><br>插入排序 (Insertion Sort)<br>就是为了保证数字在插入数组之后还能够有序，所以就先遍历数组，然后找到位置将其插入就好了。<br><br>思路：<br>插入排序将数组分为已排序区间 &amp; 未排序区间。然后一开始的时候，只有第一个数字是已排序的，然后我们每次从未排序区间中找数字插入到已排序区间中，并保证已排序区间一直有序。直到未排序区间为空，算法就结束了。<br><br>插入排序，对于一个给定的初始序列，它们移动的操作次数是固定的，就等于逆序度。<br>Why？看一下下面那个例子就可以明白了，满有序度是 n*(n-1)&#47;2 =15，初始有序度是 5，然后可以得出逆序度是 10。所以插入排序中，数据移动的次数总和为 (3+3+4)=10。<br><br>代码实现见 web page，还是比较重要的。<br><br>选择排序 (Selection Sort)<br>选择排序和插入排序差不多，也分为已排序的区间和未排序的区间。只不过它是每次都在未排序区间中找最小值然后放到已排序区间的末尾。<br><br>选择排序是稳定的算法吗？<br>Nope! 从前面那张图可以看出，选择排序每次都要找未排序区间中的最小值，然后和前面的数字进行交换，这样的话就会破坏数组的稳定性了，因为我们不知道谁排在谁前面了。<br><br>冒泡排序和插入排序的时间复杂度都是 O(n^2)，为什么插入排序更受欢迎呢？<br>其实就是因为冒泡排序的数据交换会比插入排序更复杂，bubble sort 要 3 条语句，而 insertion sort 只需要 1 条语句。<br><br>Summary<br>分析一个排序算法，从时间复杂度、内存消耗和稳定性三个方面来判断。<br>","like_count":0},{"had_liked":false,"id":53464,"user_name":"$Jason","can_delete":false,"product_type":"c1","uid":1040403,"ip_address":"","ucode":"BB0DB558D5BBB3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e0/13/6c2a5bd2.jpg","comment_is_top":false,"comment_ctime":1545650954,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545650954","product_id":100017301,"comment_content":"老师，还是我，我又来看排序了","like_count":0},{"had_liked":false,"id":53040,"user_name":"王小臭","can_delete":false,"product_type":"c1","uid":1161015,"ip_address":"","ucode":"AA95955882B2E7","user_header":"https://static001.geekbang.org/account/avatar/00/11/b7/37/36ce456f.jpg","comment_is_top":false,"comment_ctime":1545574428,"is_pvip":false,"replies":[{"id":"19363","content":"好像没有吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545649245,"ip_address":"","comment_id":53040,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545574428","product_id":100017301,"comment_content":"老师，插入排序的16行代码手误了","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434022,"discussion_content":"好像没有吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545649245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":52280,"user_name":"Ben","can_delete":false,"product_type":"c1","uid":1252353,"ip_address":"","ucode":"70351D4FAE47F7","user_header":"https://static001.geekbang.org/account/avatar/00/13/1c/01/5aaaf5b6.jpg","comment_is_top":false,"comment_ctime":1545357862,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545357862","product_id":100017301,"comment_content":"大牛, 关于开篇的问题, 移动操作和交换操作都是为了排序, 那么冒泡排序也可以用移动操作将最值移动到末位, 这样来看开篇问题的就变成排序过程中移动操作和交换操作的优劣","like_count":0},{"had_liked":false,"id":51462,"user_name":"James Scott","can_delete":false,"product_type":"c1","uid":1255048,"ip_address":"","ucode":"E673BD69503693","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/88/e8098480.jpg","comment_is_top":false,"comment_ctime":1545185519,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545185519","product_id":100017301,"comment_content":"王老师：我发现您放在GitHub上的代码有一个问题。在插入排序中,最后面的应该是a[j]=value,而不是a[j+1]=value。我自己在电脑上敲了一遍，也进行了相关测试，发现是有问题的。","like_count":0},{"had_liked":false,"id":51154,"user_name":"被吹落的风","can_delete":false,"product_type":"c1","uid":1242309,"ip_address":"","ucode":"AF62645E386A7B","user_header":"https://static001.geekbang.org/account/avatar/00/12/f4/c5/39f2acfd.jpg","comment_is_top":false,"comment_ctime":1545121700,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545121700","product_id":100017301,"comment_content":"#pragma mark -<br>#pragma mark 选择排序<br>- (void)selectionSort:(NSMutableArray *)datasource<br>{<br>    for (NSInteger i = 0; i &lt; datasource.count; i++)<br>    {<br>        NSInteger j = i;<br>        <br>        NSNumber *minNumber = datasource[j];<br>        NSInteger index = j;<br>        <br>        for (; j &lt; datasource.count; j++)<br>        {<br>            if (minNumber.integerValue &gt; [datasource[j] integerValue])<br>            {<br>                minNumber = datasource[j];<br>                index = j;<br>            }<br>        }<br>        <br>        if (index != i)<br>        {<br>            [datasource exchangeObjectAtIndex:index withObjectAtIndex:i];<br>        }<br>    }<br>}<br><br>#pragma mark -<br>#pragma mark 希尔排序<br>- (void)shellSort:(NSMutableArray *)datasource<br>{<br>    NSInteger sublistCount = datasource.count &#47; 2;<br><br>    while (sublistCount &gt; 0)<br>    {<br>        for (NSInteger i = 0; i &lt; sublistCount; i++)<br>        {<br>            NSMutableArray *subArray = [NSMutableArray array];<br><br>            for (NSInteger j = 0; j &lt; datasource.count &#47; sublistCount; j++)<br>            {<br>                [subArray addObject:datasource[i + sublistCount * j]];<br>            }<br>&#47;&#47;            NSLog(@&quot;subArray前:%@&quot;,subArray);<br><br>            [self insertionSort:subArray];<br><br>&#47;&#47;            NSLog(@&quot;subArray...............................................后:%@&quot;,subArray);<br><br>            for (NSInteger j = 0; j &lt; datasource.count &#47; sublistCount; j++)<br>            {<br>                [datasource replaceObjectAtIndex:i + sublistCount * j withObject:subArray[j]];<br>            }<br>        }<br><br>        sublistCount = sublistCount &#47; 2;<br>    }<br>}<br><br>老师，这是我写的希尔算法，经测试为什么效率还不如快速排序？是写的有问题吗","like_count":0},{"had_liked":false,"id":50553,"user_name":"金咩咩","can_delete":false,"product_type":"c1","uid":1150607,"ip_address":"","ucode":"7F328A5F98EAC6","user_header":"https://static001.geekbang.org/account/avatar/00/11/8e/8f/517c89a9.jpg","comment_is_top":false,"comment_ctime":1545008995,"is_pvip":false,"replies":[{"id":"18149","content":"暂时没想到特别的优势","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545009353,"ip_address":"","comment_id":50553,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545008995","product_id":100017301,"comment_content":"选择排序有什么优点吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433018,"discussion_content":"暂时没想到特别的优势","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545009353,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":49537,"user_name":"匆匆","can_delete":false,"product_type":"c1","uid":1333414,"ip_address":"","ucode":"4DB39C6CD5743B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/H8NxrljQXliccaT5fjdXJQYS3ou3Z9ykAuKw6EgicicEA9L4jQLz3h85P0odgDSaK0cA9oTyUKibbiagdNvnHuuV5mQ/132","comment_is_top":false,"comment_ctime":1544709047,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544709047","product_id":100017301,"comment_content":"关于排序<br><br>冒泡排序（稳定）：最优时间复杂度O(n)，最坏时间复杂度O(n^2)，平均时间复杂度O(n^2)。<br><br>插入排序（稳定）：最优时间复杂度O(n)，最坏时间复杂度O(n^2)，平均时间复杂度O(n^2)。<br><br>选择排序（稳定）：是原地排序算法，每次从未排序区间找到最小值插入到已排序区间的最后。最好最坏平均时间复杂度都是O(n^2),并且不是稳定的排序算法，所以此算法逊色于冒泡和插入排序。<br><br>总结：选择排序最次，所以一般不用。冒泡和插入排序时间复杂度虽然一样，但是由于冒泡排序的数据交换要比插入排序的数据移动要复杂，代码多，所以时间成本上插入排序更好（相差倍数关系）。一般采用插入排序。<br>","like_count":0},{"had_liked":false,"id":48336,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1544423958,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544423958","product_id":100017301,"comment_content":"逆序度代表了移动次数，比较次数一样<br>交换的方式不一样，<br>一个是移动（一次赋值），<br>一个是交换（三次赋值），<br>思考题，不会","like_count":0},{"had_liked":false,"id":48247,"user_name":"云淡风轻","can_delete":false,"product_type":"c1","uid":1108310,"ip_address":"","ucode":"9F539C742C63C2","user_header":"https://static001.geekbang.org/account/avatar/00/10/e9/56/a65d08f0.jpg","comment_is_top":false,"comment_ctime":1544406136,"is_pvip":false,"replies":[{"id":"17166","content":"确认了下 好像没啥问题呢","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544406864,"ip_address":"","comment_id":48247,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1544406136","product_id":100017301,"comment_content":"老师 冒泡排序的图好像不对啊 按照代码来跑应该不是这样的 请老手确认下","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432086,"discussion_content":"确认了下 好像没啥问题呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544406864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":47409,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1544142811,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544142811","product_id":100017301,"comment_content":"思考题:如果是链表的数据结构, 感觉实现起来会更复杂, 对于链表因为每个元素有下一个元素的指针, 所以要时刻注意链不能断掉, 尤其是插入和选择排序的算法需要先给取出的元素的位置填充上一个值再做后面的比较和移动.","like_count":0},{"had_liked":false,"id":46512,"user_name":"董某人","can_delete":false,"product_type":"c1","uid":1237968,"ip_address":"","ucode":"62B249ADAC141F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep0ic1X2oYwJY4rUXdcTExmKnUvYLPqiazVmjA0QHOiaCcp5GEQZia8UKdya2TMq1CibwV4iaNe0hqZZ1eg/132","comment_is_top":false,"comment_ctime":1543931412,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543931412","product_id":100017301,"comment_content":"【Selection Sort 的平均情况时间复杂度】<br>我是初学者，虽然老师在前文提到不需要详细分析平均复杂度的确切值，但是我还是一个学生，所以时间较充足，就试着分析了一下，若是思路有误，希望大家不吝赐教。<br><br>因为最好、最坏情况的时间复杂度都相同，平均情况自然也是 O(n^2).<br>为了方便分析，我们先假设 n 是偶数。首先，比较操作的次数在任何情况下都是不可能更改的，而比较操作的时间复杂度是 O(n^2) 。再来，便是再加上移动操作的时间复杂度。下面对移动操作的时间复杂度进行分析：<br>第一次比较后，有 (n−1)&#47;n  的可能性进行一次交换操作；第二次比较后，有 (n−3)&#47;(n−2)  的可能性进行一次交换操作；… ;以此类推，到第 k 次比较时，有 (n−2(k−1)−1)&#47;(n−2(k−1))=1&#47;2  ，即满足 n−2k=0 。之后，从第 k+1 次比较开始，“需要进行交换”的可能性的“概率表达式”发生改变：此时的 n=n&#47;2。即：有 ((n&#47;2)−(i−（n&#47;2）−1)−1 )&#47;( n&#47;2  −(i−（n&#47;2）−1))  。<br>直到 n&#47;2−(i−（n&#47;2）−1)=2 ，即 n=i+1，此时  (n−i)&#47;(n−i+1)=1&#47;2  。<br>综上所述，平均情况需要的交换操作次数为：<br>(n−1)&#47;n+(n−3)&#47;(n−2)+…+2&#47;3+1&#47;2+(n−2)&#47;n+…+2&#47;3+1&#47;2=2 <br>至此，我们可知，平均情况下的交换操作也是常数级别的，因此平均情况时间复杂度为： O(n^2)。<br>","like_count":0},{"had_liked":false,"id":46058,"user_name":"小志","can_delete":false,"product_type":"c1","uid":1037841,"ip_address":"","ucode":"11C9EAB9746D8B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d6/11/808eb5f8.jpg","comment_is_top":false,"comment_ctime":1543840058,"is_pvip":false,"replies":[{"id":"16529","content":"是的 你理解的没错","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543887800,"ip_address":"","comment_id":46058,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1543840058","product_id":100017301,"comment_content":"王老师好，有个疑惑，关于稳定性。拿冒泡来说，冒泡之所以稳定，是因为判断条件是当 a[j] &gt; a[j+1] 时，两者才交换，那如果判断条件写成 a[j] &gt;= a[j+1]，这样的话，冒泡就不稳定了，不知这样理解，您怎么看？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431321,"discussion_content":"是的 你理解的没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543887800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":45480,"user_name":"小老鼠","can_delete":false,"product_type":"c1","uid":1257460,"ip_address":"","ucode":"C663A0C863A515","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/f4/2dede51a.jpg","comment_is_top":false,"comment_ctime":1543651927,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543651927","product_id":100017301,"comment_content":"Python 中的数组排序排序方式sort用的是什么方式。","like_count":0},{"had_liked":false,"id":45044,"user_name":"王浩","can_delete":false,"product_type":"c1","uid":1229190,"ip_address":"","ucode":"EF4CFD45533803","user_header":"https://static001.geekbang.org/account/avatar/00/12/c1/86/afd6e862.jpg","comment_is_top":false,"comment_ctime":1543541248,"is_pvip":false,"replies":[{"id":"16016","content":"都不是 看下2节课","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543542071,"ip_address":"","comment_id":45044,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1543541248","product_id":100017301,"comment_content":"选择一种排序算法需要考虑,数据量,使用场景,在执行效率,内存消耗,稳定性这几个方面入手。在java中集合中的排序是插入排序还是冒泡排序？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430906,"discussion_content":"都不是 看下2节课","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543542071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":44143,"user_name":"大汉儿","can_delete":false,"product_type":"c1","uid":1275727,"ip_address":"","ucode":"D29CAF532C193A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/UmaqicDNweuQicMMn69tibdZ2mnvibjjTgP0n1HUmD77rR3hl5HGNibmHXoyibHC9vichAHV4vRSTzywG5NcKRlfeOLWQ/132","comment_is_top":false,"comment_ctime":1543373293,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543373293","product_id":100017301,"comment_content":"老师，依旧没懂为什么要考虑稳定性","like_count":0},{"had_liked":false,"id":43843,"user_name":"Geek_987169","can_delete":false,"product_type":"c1","uid":1180853,"ip_address":"","ucode":"4B2955A044805D","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/b5/8bc4790b.jpg","comment_is_top":false,"comment_ctime":1543308674,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543308674","product_id":100017301,"comment_content":"老师：<br>在冒泡排序和插入排序的比较中，对于逆序度为k的序列，插入排序需要一个&quot;数据后移&quot;的赋值操作，紧接着还需要一个&quot;插入元素&quot;的赋值操作，所以插入排序的时间是不是应该是2k啊，不是k？望老师解惑！","like_count":0},{"had_liked":false,"id":43610,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1543245685,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543245685","product_id":100017301,"comment_content":" &#47;**<br>     * 链表的冒泡排序<br>     *<br>     * @param linkedList<br>     * @param n<br>     *&#47;<br>    public static void sortLinkedList(LinkedList&lt;Integer&gt; linkedList, int n) {<br>        if (linkedList.size() &lt;= 1) {<br>            return;<br>        }<br>        for (int i = 0; i &lt; n; i++) {<br>            for (int j = 0; j &lt; (n - 1) - i; j++) {<br>                int x = linkedList.get(j);&#47;&#47;随机访问O(n)<br>                int y = linkedList.get(j + 1);&#47;&#47;随机访问O(n)<br>                if (x &gt; y) {<br>                    int temp = x;<br>                    linkedList.set(j, y);<br>                    linkedList.set(j + 1, temp);<br>                }<br>            }<br>        }<br>    }<br>不推荐使用链表的排序","like_count":0},{"had_liked":false,"id":41977,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1542885370,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542885370","product_id":100017301,"comment_content":"老师，是我记错了，我今天特意去重新认真看了，平均情况时间复杂度大多情况下等同于最坏情况时间复杂度。而均摊时间复杂度属于平均情况时间复杂的特殊情况，等同于最好的时间复杂度。","like_count":0},{"had_liked":false,"id":41791,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1542852205,"is_pvip":false,"replies":[{"id":"15062","content":"那是均摊的时候啊 ","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542885085,"ip_address":"","comment_id":41791,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542852205","product_id":100017301,"comment_content":"老师，我没记错，在您的第四课的时间复杂度的内容小结标题上的倒数第二段结尾写到:而且，在能够应用均摊时间复杂度的场合，一般均摊时间复杂度就等于最好情况时间复杂度。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429902,"discussion_content":"那是均摊的时候啊 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542885085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":41509,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1542796442,"is_pvip":false,"replies":[{"id":"14967","content":"你记错了吧 我记得我说的是平均一般就等于最坏","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542851869,"ip_address":"","comment_id":41509,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542796442","product_id":100017301,"comment_content":"老师，之前文章不是讲：通常情况的平均时间复杂度差不多就是最好的时间复杂度，那么冒泡就是个特例，还有其他特例吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429827,"discussion_content":"你记错了吧 我记得我说的是平均一般就等于最坏","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542851869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":41370,"user_name":"豆豆爸爸又","can_delete":false,"product_type":"c1","uid":1281725,"ip_address":"","ucode":"0E469366E501CE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/sNQOKNMJtDzVicWmYSV1d9ibUr7ibviacEuyCoVzvnBkmDrVX20gpAIAusG7fRtN5h2NbCFsjKqdrJKHWPnLpl0MkA/132","comment_is_top":false,"comment_ctime":1542769862,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542769862","product_id":100017301,"comment_content":"如果选择排序算法，另外开辟一个空间保存已排序的数据，每次只需要在未排序的集合中进行比较操作，那么此时，空间复杂度为O（n），时间复杂度也是O（n）。  也就是用额外空间代价来避免交换操作。我这样说对么。","like_count":0},{"had_liked":false,"id":41369,"user_name":"豆豆爸爸又","can_delete":false,"product_type":"c1","uid":1281725,"ip_address":"","ucode":"0E469366E501CE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/sNQOKNMJtDzVicWmYSV1d9ibUr7ibviacEuyCoVzvnBkmDrVX20gpAIAusG7fRtN5h2NbCFsjKqdrJKHWPnLpl0MkA/132","comment_is_top":false,"comment_ctime":1542769861,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542769861","product_id":100017301,"comment_content":"如果选择排序算法，另外开辟一个空间保存已排序的数据，每次只需要在未排序的集合中进行比较操作，那么此时，空间复杂度为O（n），时间复杂度也是O（n）。  也就是用额外空间代价来避免交换操作。我这样说对么。","like_count":0},{"had_liked":false,"id":41326,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1542765838,"is_pvip":false,"replies":[{"id":"15068","content":"应该不能吧 你多拿些测试数据测测","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542885639,"ip_address":"","comment_id":41326,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542765838","product_id":100017301,"comment_content":"老师是的呀，我自己写了这个排序，能实现效果但是，应该不是冒泡，这个属于哪种？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429765,"discussion_content":"应该不能吧 你多拿些测试数据测测","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542885639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":40975,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1542707662,"is_pvip":false,"replies":[{"id":"14796","content":"代码是你自己写的吧 感觉不怎么对啊","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542765716,"ip_address":"","comment_id":40975,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542707662","product_id":100017301,"comment_content":"老师请教个问题：为啥下面这种方式也可以实现最终排序，但是执行的过程跟你的配图完全不一样？？麻烦老师解答下！！！谢谢  <br>public static void sort(int[] array) {<br>        &#47;&#47;若数组只有一个元素，则直接返回<br>        if (array.length &lt;= 1) {<br>            return;<br>        }<br>        for (int i = 0; i &lt; array.length - 1; i++) {<br>            System.out.println(String.format(&quot;开始第【%d】轮比较&quot;, i));<br>            for (int j = i + 1; j &lt; array.length; j++) {<br>                if (array[i] &gt; array[j]) {<br>                    System.out.println(Arrays.toString(array));<br>                    System.out.println(String.format(&quot;开始交换索引为：%d的元素【%d】与索引为：索引为：%d的元素【%d】&quot;, i, array[i], j, array[j]));<br>                    int temp = array[i];<br>                    array[i] = array[j];<br>                    array[j] = temp;<br>                }<br>            }<br>        }<br>    }","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429665,"discussion_content":"代码是你自己写的吧 感觉不怎么对啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542765716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":40516,"user_name":"进阶的码农","can_delete":false,"product_type":"c1","uid":1017821,"ip_address":"","ucode":"D8991282640334","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/dd/4f53f95d.jpg","comment_is_top":false,"comment_ctime":1542628432,"is_pvip":false,"replies":[{"id":"14665","content":"最后一次只有一个数据 也就不用排了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542678671,"ip_address":"","comment_id":40516,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542628432","product_id":100017301,"comment_content":"有点困扰，为什么这三种排序，最外边的for循环都是n-1次 不是n次","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429550,"discussion_content":"最后一次只有一个数据 也就不用排了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542678671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":40298,"user_name":"cw","can_delete":false,"product_type":"c1","uid":1264296,"ip_address":"","ucode":"82A6B50462F9F9","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/a8/b7e36dd2.jpg","comment_is_top":false,"comment_ctime":1542590500,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542590500","product_id":100017301,"comment_content":"使用链表奇偶，那么冒泡排序就需要每次都从头开始遍历，其次，交换操作可能会变得更加复杂。插入排序的插入操作就会变得更加复杂，且每次都需要从头开始排序。选择排序就需要也是每次都需要从头开始排序，并且交换操作会变得异常复杂","like_count":0},{"had_liked":false,"id":40182,"user_name":"悟空WuKong","can_delete":false,"product_type":"c1","uid":1139455,"ip_address":"","ucode":"49AFD2B048C1BA","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/ff/f71034e9.jpg","comment_is_top":false,"comment_ctime":1542541700,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542541700","product_id":100017301,"comment_content":"图应该是手工画的吧","like_count":0},{"had_liked":false,"id":39862,"user_name":"allean","can_delete":false,"product_type":"c1","uid":1051470,"ip_address":"","ucode":"A0D2DB4F219EAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/0b/4e/fd946cb2.jpg","comment_is_top":false,"comment_ctime":1542370014,"is_pvip":false,"replies":[{"id":"14693","content":"👍 说的好","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542680423,"ip_address":"","comment_id":39862,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542370014","product_id":100017301,"comment_content":"汗，有的同学只看不写，有何用啊？看看就能快速理解这样的人太少了吧！看一遍不如亲手敲一遍理解的深刻！","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429261,"discussion_content":"👍 说的好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542680423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":38809,"user_name":"鲂町肋","can_delete":false,"product_type":"c1","uid":1299852,"ip_address":"","ucode":"9FE2843EA4770F","user_header":"https://static001.geekbang.org/account/avatar/00/13/d5/8c/fe5857d5.jpg","comment_is_top":false,"comment_ctime":1542132274,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542132274","product_id":100017301,"comment_content":"编码实现了一下，确实插入排序比冒泡排序效率高，感觉冒泡排序除了多几次赋值外，更要命的是没有利用已经排好的有序列，导致后续遍历次数没有减少，插入就不一样，一个break提高节省不少时间","like_count":0},{"had_liked":false,"id":38278,"user_name":"大给给","can_delete":false,"product_type":"c1","uid":1238618,"ip_address":"","ucode":"69B6FBE9E81467","user_header":"https://static001.geekbang.org/account/avatar/00/12/e6/5a/377dc4bf.jpg","comment_is_top":false,"comment_ctime":1542014446,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542014446","product_id":100017301,"comment_content":"换句话说，平均情况下，需要 n*(n-1)&#47;4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n)，所以平均情况下的时间复杂度就是 O(n²).....这句话没懂，求大神们的解释！！！","like_count":0},{"had_liked":false,"id":37488,"user_name":"sudden","can_delete":false,"product_type":"c1","uid":1128846,"ip_address":"","ucode":"7FEF669F63CC02","user_header":"https://static001.geekbang.org/account/avatar/00/11/39/8e/9973100b.jpg","comment_is_top":false,"comment_ctime":1541605949,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541605949","product_id":100017301,"comment_content":"老师，看你文章真的太舒服了，当时学数据结构要是有你写教材，我肯定能学的更有兴趣~","like_count":0},{"had_liked":false,"id":37033,"user_name":"小和尚笨南北","can_delete":false,"product_type":"c1","uid":1204628,"ip_address":"","ucode":"17C9BBB6DD25D2","user_header":"https://static001.geekbang.org/account/avatar/00/12/61/94/713b38ef.jpg","comment_is_top":false,"comment_ctime":1541427852,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541427852","product_id":100017301,"comment_content":"冒泡排序时，N个元素，第一层循环中，循环N-1次是不是就已经排好序了。<br>可以少循环一次","like_count":0},{"had_liked":false,"id":36973,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1541409596,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541409596","product_id":100017301,"comment_content":"写给楼上 @myrabbit <br>ipad+apple pencil+app：procreate  可轻松画出这种图，","like_count":0},{"had_liked":false,"id":36299,"user_name":"张迪","can_delete":false,"product_type":"c1","uid":1104835,"ip_address":"","ucode":"6A5D44999A0FEA","user_header":"https://static001.geekbang.org/account/avatar/00/10/db/c3/e11adfe8.jpg","comment_is_top":false,"comment_ctime":1541033713,"is_pvip":false,"replies":[{"id":"12887","content":"自己debug一下","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541036225,"ip_address":"","comment_id":36299,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541033713","product_id":100017301,"comment_content":"代码太绕，看不明白怎么办呢？有什么技巧吗","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427821,"discussion_content":"自己debug一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541036225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36002,"user_name":"$Jason","can_delete":false,"product_type":"c1","uid":1040403,"ip_address":"","ucode":"BB0DB558D5BBB3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e0/13/6c2a5bd2.jpg","comment_is_top":false,"comment_ctime":1540886854,"is_pvip":false,"replies":[{"id":"12825","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540950274,"ip_address":"","comment_id":36002,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540886854","product_id":100017301,"comment_content":"这篇文章我看了好几遍，把三种排序一个个自己按照原理写了一遍","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427730,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540950274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35473,"user_name":"Milittle","can_delete":false,"product_type":"c1","uid":1045455,"ip_address":"","ucode":"80E566639A8ABB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f3/cf/851dab01.jpg","comment_is_top":false,"comment_ctime":1540612031,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1540612031","product_id":100017301,"comment_content":"对于现在“双木公子”的回答：我有一点不成熟的小建议，不知道是否正确：<br>那就是用链表实现选择排序，其实不需要进行交换操作，直接将未排序区间的最小值节点找到，然后插到有序区间的最后就可以了（可以把原节点删掉即可，当然会出现多开辟一个新空间的过程，这个时间估计也比较慢），这样不仅不用交换，而且，还可以让选择排序具有稳定性（主要是这一点是不是可以满足呢？）。不知道理解是否正确。希望老师给予解答。","like_count":0},{"had_liked":false,"id":35464,"user_name":"方少伟","can_delete":false,"product_type":"c1","uid":1185831,"ip_address":"","ucode":"4C93DD3B9AABE5","user_header":"https://static001.geekbang.org/account/avatar/00/12/18/27/845d47d4.jpg","comment_is_top":false,"comment_ctime":1540605758,"is_pvip":false,"replies":[{"id":"12687","content":"😓 要怎么讲啊","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540740673,"ip_address":"","comment_id":35464,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540605758","product_id":100017301,"comment_content":"冒泡的原理过程都没讲","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427544,"discussion_content":"😓 要怎么讲啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540740673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35243,"user_name":"kakasi","can_delete":false,"product_type":"c1","uid":1237297,"ip_address":"","ucode":"64F357E6A08CA5","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/31/eb103bdc.jpg","comment_is_top":false,"comment_ctime":1540474201,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540474201","product_id":100017301,"comment_content":"分析排序算法: <br>1. 执行效率。最好、最坏、平均时间复杂度。其实数据不那么大的时候系数、赋值语句等因素也可以了考虑。<br>2. 内存消耗。即空间复杂度。<br>3. 稳定性。即排序后天相等元素的前后顺序不变。<br><br>冒泡排序分析: <br>1. 执行效率。最好: O（n），需要做break操作。最坏: O（n2）。平均: O（n2）。这个平均的分析比较难，可以用有序度分析个大概。有序度即从左到右任意组合两个数，左边小于右边的组合个数。逆序度=满序度（逆序）-有序度，逆序度就是冒泡需要交换的次数。<br>2. 内存消耗: 原地排序O（1）。<br>3. 稳定性: 稳定。<br><br>插入排序分析: <br>1. 执行效率。最好: O（n）。最坏: O（n2）。平均: O（n2）。平均也是用逆序度分析。<br>2. 内存消耗: 原地排序O（1）。<br>3. 稳定性: 稳定。<br><br>选择排序分析: <br>1. 执行效率。最好: O（n2）。最坏: O（n2）。平均: O（n2）。<br>2. 内存消耗: 原地排序O（1）。<br>3. 稳定性: 不稳定。<br><br>一般不会选择冒泡和选择，插入有时候会用。因为冒泡相对于插入赋值语句更多，比起插入没有任何优势，而选择更是如此，还不稳定。","like_count":0},{"had_liked":false,"id":35088,"user_name":"qinggeouye","can_delete":false,"product_type":"c1","uid":1251536,"ip_address":"","ucode":"5B53EEDD7BEC9C","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/d0/49b06424.jpg","comment_is_top":false,"comment_ctime":1540403715,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540403715","product_id":100017301,"comment_content":"学习完毕，mark。基于链表的排序，如果是改变结点位置，比较大小后，难点在于结点指针如何指向，同时注意前面链表章节提高的指针丢失问题。","like_count":0},{"had_liked":false,"id":34908,"user_name":"Marnie","can_delete":false,"product_type":"c1","uid":1001912,"ip_address":"","ucode":"ECF9B22574F868","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/b8/fb19aa6a.jpg","comment_is_top":false,"comment_ctime":1540350705,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540350705","product_id":100017301,"comment_content":"原地排序算法，空间复杂度为1的排序算法。<br>稳定排序算法，排序前后相同数字的前后顺序不发生变化。<br>冒泡法和插入算法的时间复杂度都为为n的平方，但一般原则插入排序算法，原因是插入排序算法只需要进行一次数据交换，而冒泡语言三次。","like_count":0},{"had_liked":false,"id":34782,"user_name":"Jamin","can_delete":false,"product_type":"c1","uid":1236792,"ip_address":"","ucode":"0449B773FE4D21","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJhyK1QiaqyNox3wr3GmBibziau9pPDxN5HjYBpYCd7ytDmLNtJ1cKKaq2WYFF3jpRSg6638M8NFDf2w/132","comment_is_top":false,"comment_ctime":1540298926,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540298926","product_id":100017301,"comment_content":"void insertSort(int [] a) {<br>        <br>    for(int i=1;i&lt;a.length;i++) {<br><br>        for(int j=i;j&gt;=1; j--) {<br>            if(a[j]&lt;a[j-1]) {<br>                int tmp = a[j-1];<br>                a[j-1] = a[j];<br>                a[j] = tmp;<br>            }<br>        }<br>    }<br>}","like_count":0},{"had_liked":false,"id":34781,"user_name":"Jamin","can_delete":false,"product_type":"c1","uid":1236792,"ip_address":"","ucode":"0449B773FE4D21","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJhyK1QiaqyNox3wr3GmBibziau9pPDxN5HjYBpYCd7ytDmLNtJ1cKKaq2WYFF3jpRSg6638M8NFDf2w/132","comment_is_top":false,"comment_ctime":1540298834,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540298834","product_id":100017301,"comment_content":"这样写插入排序比较简单<br>void insertSort(int [] a) {<br>        <br>    for(int i=1;i&lt;a.length;i++) {<br><br>        for(int j=i;j&gt;=1; j--) {<br>            if(a[j]&lt;a[j-1]) {<br>                int tmp = a[j-1];<br>                a[j-1] = a[j];<br>                a[j] = tmp;<br>            }<br>        }<br>    }<br>}","like_count":0},{"had_liked":false,"id":34732,"user_name":"肖春","can_delete":false,"product_type":"c1","uid":1255632,"ip_address":"","ucode":"145DA071937279","user_header":"https://static001.geekbang.org/account/avatar/00/13/28/d0/248ac91c.jpg","comment_is_top":false,"comment_ctime":1540274417,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540274417","product_id":100017301,"comment_content":"&#47;&#47; 插入排序，a 表示数组，n 表示数组大小<br>public void insertionSort(int[] a, int n) {<br>  if (n &lt;= 1) return;<br><br>  for (int i = 1; i &lt; n; ++i) {<br>    int value = a[i];<br>    int j = i - 1;<br>    &#47;&#47; 查找插入的位置<br>    for (; j &gt;= 0; --j) {<br>      if (a[j] &gt; value) {<br>        a[j+1] = a[j];  &#47;&#47; 数据移动<br>      } else {<br>        break;<br>      }<br>    }<br>    a[j+1] = value; &#47;&#47; 插入数据<br>  }<br>}<br><br> a[j+1] = value; &#47;&#47; 插入数据  这个地方应该是 a[j]=value","like_count":0},{"had_liked":false,"id":34296,"user_name":"kylexy_0817","can_delete":false,"product_type":"c1","uid":1068372,"ip_address":"","ucode":"392DD9DD5E4B6E","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/54/9c214885.jpg","comment_is_top":false,"comment_ctime":1540091563,"is_pvip":false,"replies":[{"id":"12276","content":"不需要分组的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540174981,"ip_address":"","comment_id":34296,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540091563","product_id":100017301,"comment_content":"老师您好，我有个比较菜的问题，就是任意给定一组数据，在进行插入排序之前，是否要先进行一次有序数据与无序数据的分组？如果是，那插入排序的算法时间复杂度是否要包含这次分组？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427166,"discussion_content":"不需要分组的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540174981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34174,"user_name":"iswlqn","can_delete":false,"product_type":"c1","uid":1115991,"ip_address":"","ucode":"2ABB791F7DBF18","user_header":"https://static001.geekbang.org/account/avatar/00/11/07/57/4afabdcb.jpg","comment_is_top":false,"comment_ctime":1540031484,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540031484","product_id":100017301,"comment_content":"最高赞里说链表实现插入排序，可能需要逆置，为什么啊…感觉是他说错了","like_count":0},{"had_liked":false,"id":34150,"user_name":"Stephen","can_delete":false,"product_type":"c1","uid":1208572,"ip_address":"","ucode":"CB08E34AB48D99","user_header":"https://static001.geekbang.org/account/avatar/00/12/70/fc/77f60338.jpg","comment_is_top":false,"comment_ctime":1540022544,"is_pvip":false,"replies":[{"id":"12191","content":"会的 在堆那一节","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540047647,"ip_address":"","comment_id":34150,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540022544","product_id":100017301,"comment_content":"老师，后面会介绍堆排序吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427133,"discussion_content":"会的 在堆那一节","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540047647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34139,"user_name":"杨林","can_delete":false,"product_type":"c1","uid":1240048,"ip_address":"","ucode":"B5CDEF33C1BEE4","user_header":"https://static001.geekbang.org/account/avatar/00/12/eb/f0/689e4d47.jpg","comment_is_top":false,"comment_ctime":1540017942,"is_pvip":false,"replies":[{"id":"12194","content":"不是的 可以提前结束冒泡","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540047860,"ip_address":"","comment_id":34139,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540017942","product_id":100017301,"comment_content":"难道冒泡时间复杂度不是稳定o(n平方）","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427129,"discussion_content":"不是的 可以提前结束冒泡","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540047860,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34014,"user_name":"linliicer","can_delete":false,"product_type":"c1","uid":1235423,"ip_address":"","ucode":"E11320048D1A29","user_header":"","comment_is_top":false,"comment_ctime":1539948657,"is_pvip":false,"replies":[{"id":"12200","content":"为啥不行呢？很多时间平均复杂度的分析就是靠一个感觉。真要理论推导还真不一定能推导的出来。我这里就是要教你这种估算的方法。虽然不严谨。但很实用。这也是专栏的一个特点。就是要实用。你看复杂度分析那一节里有同学也留言说过 很多时候平均复杂度的分析就是靠一个感觉 高手还是有共鸣的 你可以去翻翻04 05节的留言找找","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540048674,"ip_address":"","comment_id":34014,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539948657","product_id":100017301,"comment_content":"冒泡排序的平均时间复杂度这也太草率了吧？直接最高次数加最低次数除以2就是平均次数？你说的不严格，这也太不严格了吧！！<br>这个平均时间复杂度确实非常复杂，不分析就不分析，没必要这样凑活着做！","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427103,"discussion_content":"为啥不行呢？很多时间平均复杂度的分析就是靠一个感觉。真要理论推导还真不一定能推导的出来。我这里就是要教你这种估算的方法。虽然不严谨。但很实用。这也是专栏的一个特点。就是要实用。你看复杂度分析那一节里有同学也留言说过 很多时候平均复杂度的分析就是靠一个感觉 高手还是有共鸣的 你可以去翻翻04 05节的留言找找","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540048674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33643,"user_name":"佳慕流年","can_delete":false,"product_type":"c1","uid":1256020,"ip_address":"","ucode":"D38D0C7802835A","user_header":"https://static001.geekbang.org/account/avatar/00/13/2a/54/7db35245.jpg","comment_is_top":false,"comment_ctime":1539842196,"is_pvip":false,"replies":[{"id":"12084","content":"不会啊 i最大n-1","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539854916,"ip_address":"","comment_id":33643,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539842196","product_id":100017301,"comment_content":"插入排序例子for循环是从1开始的，int value = arr〔i〕   到循环最后一次的时候，不会出现数组下标越界的异常吗","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427020,"discussion_content":"不会啊 i最大n-1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539854916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33620,"user_name":"程","can_delete":false,"product_type":"c1","uid":1006991,"ip_address":"","ucode":"66386B3603D39F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5d/8f/16e1da5d.jpg","comment_is_top":false,"comment_ctime":1539837980,"is_pvip":false,"replies":[{"id":"12085","content":"我整理一下放到github","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539854981,"ip_address":"","comment_id":33620,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539837980","product_id":100017301,"comment_content":"老师，那个冒泡和插入的性能对比测试程序有贴出来吗，想了解下那个耗时是怎么统计出来的谢谢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427016,"discussion_content":"我整理一下放到github","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539854981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33558,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1539825291,"is_pvip":false,"replies":[{"id":"12092","content":"不好算呢","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539856248,"ip_address":"","comment_id":33558,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539825291","product_id":100017301,"comment_content":"换句话说，平均情况下，需要 n*(n-1)&#47;4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n2)，所以平均情况下的时间复杂度就是 O(n2)。   请问比较操作能否算出平均时间复杂度？ 它的平均情况时间复杂度是多少    求计算过程","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426994,"discussion_content":"不好算呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539856248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33552,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1539824813,"is_pvip":false,"replies":[{"id":"12093","content":"O（n*（n-1）&#47;4）","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539856325,"ip_address":"","comment_id":33552,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539824813","product_id":100017301,"comment_content":"平均情况下，需要 n*(n-1)&#47;4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n2)，所以平均情况下的时间复杂度就是 O(n2)。    平均情况的时间复杂度怎么算出来的","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426993,"discussion_content":"O（n*（n-1）/4）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539856325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33264,"user_name":"山野刁民","can_delete":false,"product_type":"c1","uid":1191795,"ip_address":"","ucode":"3371E25F6AEFBC","user_header":"https://static001.geekbang.org/account/avatar/00/12/2f/73/00a56a7d.jpg","comment_is_top":false,"comment_ctime":1539768095,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539768095","product_id":100017301,"comment_content":"冒泡排序：相邻元素两两比较并移动，对原数组操作<br>插入排序：取乱序队列一个元素与已排序队列元素比较，并插入其中，对原数组操作<br>选择排序：取乱序队列中最小值放入排序队列末尾，对原数组操作<br>满有序度=初始有序度+逆序度<br>有序度这个概念应该就是指两两比较时顺序移动的次数，只要对原数组有顺序移动的操作应该都可以适用，故这里选择不适用","like_count":0},{"had_liked":false,"id":33060,"user_name":"zixuan","can_delete":false,"product_type":"c1","uid":1131300,"ip_address":"","ucode":"C72920DD05B074","user_header":"https://static001.geekbang.org/account/avatar/00/11/43/24/3f9f7c70.jpg","comment_is_top":false,"comment_ctime":1539742191,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539742191","product_id":100017301,"comment_content":"ShellSort核心思想：用更大的步长比较和交换数据，每次消除可能不止1个逆序对，因而比普通插入排序要快。有点部分类似快排。","like_count":0},{"had_liked":false,"id":32949,"user_name":"三季人","can_delete":false,"product_type":"c1","uid":1213268,"ip_address":"","ucode":"BB8389BAF099FC","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/54/bf00c8f0.jpg","comment_is_top":false,"comment_ctime":1539737452,"is_pvip":false,"replies":[{"id":"12053","content":"你自己拿个测试数据照着代码走一遍就知道了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539788741,"ip_address":"","comment_id":32949,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539737452","product_id":100017301,"comment_content":"插入排序第11行和第16行都是对a[j+1]赋值，没有插入啊，16行应该是a[j]的赋值吧","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426918,"discussion_content":"你自己拿个测试数据照着代码走一遍就知道了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539788741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32931,"user_name":"咖啡猫口里的咖啡猫🐱","can_delete":false,"product_type":"c1","uid":1036565,"ip_address":"","ucode":"FE2441B3A40375","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d1/15/7d47de48.jpg","comment_is_top":false,"comment_ctime":1539736316,"is_pvip":false,"replies":[{"id":"12056","content":"看不到你代码和测试代码 我不好评判","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539788916,"ip_address":"","comment_id":32931,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539736316","product_id":100017301,"comment_content":"优化的冒泡排序和插入排序，确实冒泡排序耗时比插入排序低，数组大小10000，random 1亿随机范围数，执行1亿次；然后我用老师github的sortsaddon类的那个int数组也是一样的结果  &lt;java&gt;","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426914,"discussion_content":"看不到你代码和测试代码 我不好评判","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539788916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32781,"user_name":"纯洁的憎恶","can_delete":false,"product_type":"c1","uid":1130512,"ip_address":"","ucode":"5E9757DE6F45DF","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/10/b6bf3c3c.jpg","comment_is_top":false,"comment_ctime":1539696595,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1539696595","product_id":100017301,"comment_content":"评价排序算法的三个维度：时间复杂度、空间复杂度、稳定性。其中，空间复杂度为O（1）的排序算法为本地排序；大小相等的元素，在排序完成后的前后次序不变，称为稳定排序，稳定排序算法可用于多维度排序的快速实现；时间复杂度需要考虑最好、最坏与平均情况，使用概率论方法计算平均复杂度过于复杂，可采用平均交换次数近似衡量平均复杂度，交换次数等于逆序度，最好情况与最坏情况的逆序度取平均值，可近似视为平均交换次数。<br><br>排序算法实现过程中，不同算法的移动操作代码复杂度不同，冒泡排序一次移动需要3次赋值操作，而插入排序只需要一次。","like_count":0},{"had_liked":false,"id":32768,"user_name":"luffy","can_delete":false,"product_type":"c1","uid":1244950,"ip_address":"","ucode":"702034E116A99F","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/16/b0ab9a73.jpg","comment_is_top":false,"comment_ctime":1539693279,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539693279","product_id":100017301,"comment_content":"问大家一个算法问题，面试遇到的，如何求多个文件的最大公共路径？我的想法是把文件的路径按“&#47;”拆分，然后将多个文件拆分成一个二维数组，然后从第一列开始，依次判断二维数组的列是否全部相等。如全部相等，继续判断；若不是全部相等，停止判断，记下列的下标。然后拼出最大的公共路径。该方式是否可行？如何判断二维数组的列是否全部相等？试着写了下，需要3层for嵌套，觉得效率太低，有没有好的方式？<br>func test() {<br>\tarr := [][]int{{1, 2, 3, 4}, {1, 2, 3, 9}, {1, 2, 5, 7}, {1, 2, 6, 7}}<br>\tfmt.Println(arr)<br><br>\tfor j := 0; j &lt; len(arr[0]); j++ { &#47;&#47;列数<br>\t\tfor i := 0; i &lt; len(arr); i++ { &#47;&#47;行数<br>\t\t\t&#47;&#47;每一个数，依次与后面的数全部比较<br>\t\t}<br>\t}<br>}","like_count":0},{"had_liked":false,"id":32765,"user_name":"虎虎❤️","can_delete":false,"product_type":"c1","uid":1086535,"ip_address":"","ucode":"157F261E80291A","user_header":"https://static001.geekbang.org/account/avatar/00/10/94/47/75875257.jpg","comment_is_top":false,"comment_ctime":1539691712,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539691712","product_id":100017301,"comment_content":"冒泡排序也可以优化为赋值代替交换。快排的优势应该是内层循环可以提前终止，减少了比较的次数。","like_count":0},{"had_liked":false,"id":32761,"user_name":"TryTs","can_delete":false,"product_type":"c1","uid":1036276,"ip_address":"","ucode":"1DD1E974D461A1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cf/f4/26b95f0b.jpg","comment_is_top":false,"comment_ctime":1539690842,"is_pvip":false,"replies":[{"id":"11939","content":"都看看不行吗 非得二选一啊 还有你读不读研呢 具体怎么选 还要结合你的情况来分析","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539701732,"ip_address":"","comment_id":32761,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539690842","product_id":100017301,"comment_content":"谢谢老师上次的回答，其实现在很纠结。我现在大三了，你说我是一门心思的去学算法与数据结构呢，还是可以暂时搁置这个，去跟老师搞搞深度学习机器学习之类的。如果是你你怎么选？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426887,"discussion_content":"都看看不行吗 非得二选一啊 还有你读不读研呢 具体怎么选 还要结合你的情况来分析","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539701732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32728,"user_name":"咖啡猫口里的咖啡猫🐱","can_delete":false,"product_type":"c1","uid":1036565,"ip_address":"","ucode":"FE2441B3A40375","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d1/15/7d47de48.jpg","comment_is_top":false,"comment_ctime":1539680594,"is_pvip":false,"replies":[{"id":"11942","content":"详细说说你的测试用例 代码是用的我文章中的吗","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539701908,"ip_address":"","comment_id":32728,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539680594","product_id":100017301,"comment_content":"为什么我测试的冒泡排序比插入排序耗时小，随着数据的增大，甚至是1倍","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426871,"discussion_content":"详细说说你的测试用例 代码是用的我文章中的吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539701908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32719,"user_name":"kaoker","can_delete":false,"product_type":"c1","uid":1115225,"ip_address":"","ucode":"499060AE9A4B2C","user_header":"","comment_is_top":false,"comment_ctime":1539678639,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539678639","product_id":100017301,"comment_content":"----对于老师所提课后题，觉得应该有个前提，是否允许修改链表的节点value值，还是只能改变节点的位置。一般而言，考虑只能改变节点位置，冒泡排序相比于数组实现，比较次数一致，但交换时操作更复杂；插入排序，比较次数一致，不需要再有后移操作，找到位置后可以直接插入，但排序完毕后可能需要倒置链表；选择排序比较次数一致，交换操作同样比较麻烦。综上，时间复杂度和空间复杂度并无明显变化，若追求极致性能，冒泡排序的时间复杂度系数会变大，插入排序系数会减小，选择排序无明显变化。---<br>关于上面答案的问题,为什么选择插入可能会倒置链表啊?冒泡排序会吗?<br>","like_count":0},{"had_liked":false,"id":32704,"user_name":"Geek_7f18eb","can_delete":false,"product_type":"c1","uid":1248270,"ip_address":"","ucode":"4A78D4583C73CA","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/0e/91af1b43.jpg","comment_is_top":false,"comment_ctime":1539672432,"is_pvip":false,"replies":[{"id":"11944","content":"看起来有点像选择排序","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539702223,"ip_address":"","comment_id":32704,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539672432","product_id":100017301,"comment_content":"for (int i = 0; i &lt; a.length; i++) {<br>            &#47;&#47;注意这儿的    外层从i开始循环 内层从i+1处开始循环遍历<br>            for (int j = i + 1; j &lt; a.length; j++) {<br>                if (a[i] &gt; a[j]) {<br>                    int c = a[i];<br>                    a[i] = a[j];<br>                    a[j] = c;<br>                }<br>            }<br>        }<br>这种不是原地排序算法呢，但是效率好像也比冒泡排序高，问下老师  这种写法的排序   有问题吗？有名称吗？<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426864,"discussion_content":"看起来有点像选择排序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539702223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32700,"user_name":"程序员大天地","can_delete":false,"product_type":"c1","uid":1249001,"ip_address":"","ucode":"7A21F15FEE2D5B","user_header":"https://static001.geekbang.org/account/avatar/00/13/0e/e9/98b6ea61.jpg","comment_is_top":false,"comment_ctime":1539671802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539671802","product_id":100017301,"comment_content":"Go语言版本：<br>&#47;&#47;数组的冒泡排序,升序，时间复杂度：最好O(n),最坏O(n^2),平均O(n^2),稳定排序<br>func BubbleSort(array []int32, num int32) {<br>\tflag := false<br>\tfor i := int32(0); i &lt; num; i++ {<br>\t\tflag = false<br>\t\tfor j := int32(0); j &lt; num-i-1; j++ {<br>\t\t\tif array[j+1] &lt; array[j] {<br>\t\t\t\tarray[j], array[j+1] = array[j+1], array[j]<br>\t\t\t\tflag = true<br>\t\t\t}<br>\t\t}<br>\t\tif !flag { &#47;&#47;数组已经有序，直接退出<br>\t\t\tbreak<br>\t\t}<br>\t}<br>}<br><br>&#47;&#47;数组的插入排序,升序，时间复杂度：最好O(n),最坏O(n^2),平均O(n^2)，稳定排序<br>func InsertSort(array []int32, num int32) {<br>\tfor i := int32(1); i &lt; num; i++ {<br>\t\tvalue := array[i] &#47;&#47;保存下要插入的值<br>\t\tj := i - 1<br>\t\tfor ; j &gt;= 0; j-- { &#47;&#47;查找插入的位子<br>\t\t\tif array[j] &gt; value {<br>\t\t\t\tarray[j+1] = array[j] &#47;&#47; 搬移数据<br>\t\t\t} else {<br>\t\t\t\tbreak &#47;&#47;找到了插入位子<br>\t\t\t}<br>\t\t}<br>\t\tarray[j+1] = value<br>\t}<br>}<br><br>&#47;&#47;数组的选择排序,升序，时间复杂度：最好O(n^2),最坏O(n^2),平均O(n^2)，不稳定排序<br>func SelectSort(array []int32, num int32) {<br>\tfor i := int32(0); i &lt; num; i++ {<br>\t\tminIndex := i<br>\t\tfor j := i + 1; j &lt; num; j++ {<br>\t\t\tif array[j] &lt; array[minIndex] {<br>\t\t\t\tminIndex = j<br>\t\t\t}<br>\t\t}<br>\t\tarray[i], array[minIndex] = array[minIndex], array[i]<br>\t}<br>}","like_count":0},{"had_liked":false,"id":32600,"user_name":"空白格","can_delete":false,"product_type":"c1","uid":1235765,"ip_address":"","ucode":"472F5456892E77","user_header":"https://static001.geekbang.org/account/avatar/00/12/db/35/f3b78d18.jpg","comment_is_top":false,"comment_ctime":1539618724,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539618724","product_id":100017301,"comment_content":"深夜打卡","like_count":0},{"had_liked":false,"id":32599,"user_name":"Rain","can_delete":false,"product_type":"c1","uid":1238221,"ip_address":"","ucode":"6A270D922A3B9D","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","comment_is_top":false,"comment_ctime":1539618715,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539618715","product_id":100017301,"comment_content":"老师您能帮忙解释下为什么希尔排序是插入排序的一种优化吗？或者说为什么希尔排序的性能要好于插入排序呢？因为我看了希尔排序的算法之后发现希尔排序最后一次增量必须为1，且这个时候的执行过程完全等同于插入排序。尝试去查有人说数据量大的情况下插入排序将一个较小的数组插入到前面去的时候会产生大量的数据搬移，这个我能理解，但我就是理解不了希尔排序什么情况下比插入排序工作量小了。麻烦老师解答下，谢谢啦。","like_count":0},{"had_liked":false,"id":32583,"user_name":"花见笑","can_delete":false,"product_type":"c1","uid":1219485,"ip_address":"","ucode":"8A5122BC11E695","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/9d/d487c368.jpg","comment_is_top":false,"comment_ctime":1539616260,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539616260","product_id":100017301,"comment_content":"感觉插入排序，在查找插入位置的时可以利用已排序部分的有序特性用更优秀的查找算法而不是单纯遍历，比如用二分查找法替代遍历查找。","like_count":0},{"had_liked":false,"id":32571,"user_name":"insist","can_delete":false,"product_type":"c1","uid":1054536,"ip_address":"","ucode":"1EE2800A900BA7","user_header":"https://static001.geekbang.org/account/avatar/00/10/17/48/3ab39c86.jpg","comment_is_top":false,"comment_ctime":1539613264,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539613264","product_id":100017301,"comment_content":"在排序算法中，有序度，满有序度，逆序度的概念可以用于粗略分析复杂度，冒泡需要交换次数以及插入排序需要移动次数等于逆序度，满序度为n*（n-1）&#47;2","like_count":0},{"had_liked":false,"id":32569,"user_name":"Rain","can_delete":false,"product_type":"c1","uid":1238221,"ip_address":"","ucode":"6A270D922A3B9D","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","comment_is_top":false,"comment_ctime":1539613107,"is_pvip":false,"replies":[{"id":"11950","content":"你这个代码感觉不对啊。冒泡是交换相邻的元素","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539703482,"ip_address":"","comment_id":32569,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539613107","product_id":100017301,"comment_content":"在读老师的文章之前我心中的冒泡一直是下面这样。现在感觉好像是冒泡的逆过程（冒泡是数字往上走，我这个是小数字往下走）。想请老师帮忙确认下这个算法在原理上跟冒泡是一样的吗？<br><br>private static void someSort(int[] arr) {<br>    int len = arr.length;<br>    if (len == 1) return;<br><br>    for (int i = 0; i &lt; len; i++) {<br>      for (int j = i + 1; j &lt; len; j++) {<br>        if (arr[i] &gt; arr[j]) {<br>          int tmp = arr[i];<br>          arr[i] = arr[j];<br>          arr[j] = tmp;<br>        }<br>      }<br>    }<br>  }","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426821,"discussion_content":"你这个代码感觉不对啊。冒泡是交换相邻的元素","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539703482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32568,"user_name":"勤劳的小胖子-libo","can_delete":false,"product_type":"c1","uid":1158344,"ip_address":"","ucode":"5BB20CD5A56568","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/c8/4b1c0d40.jpg","comment_is_top":false,"comment_ctime":1539613045,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539613045","product_id":100017301,"comment_content":"没有随机访问，应该都可以。<br>冒泡: O(n) O(n²) O(n²)<br>插入: O(n) O(n²) O(n²) 时间复杂度，虽然没有数据移动，但比较次数没有减少<br>选择: O(n²) O(n²) O(n²)","like_count":0},{"had_liked":false,"id":32559,"user_name":"花见笑","can_delete":false,"product_type":"c1","uid":1219485,"ip_address":"","ucode":"8A5122BC11E695","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/9d/d487c368.jpg","comment_is_top":false,"comment_ctime":1539608083,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539608083","product_id":100017301,"comment_content":"插入排序的思维天然符合软件在运营时对数据保证有序的要求，简单来说数据在递增时只需要把新数据插入对应的有序位置，而没有必要像冒泡排序那样每次都要把数据全都排序一遍，这样我们就充分利用了现有数据的有序性来排序。","like_count":0},{"had_liked":false,"id":32540,"user_name":"虎虎❤️","can_delete":false,"product_type":"c1","uid":1086535,"ip_address":"","ucode":"157F261E80291A","user_header":"https://static001.geekbang.org/account/avatar/00/10/94/47/75875257.jpg","comment_is_top":false,"comment_ctime":1539604947,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539604947","product_id":100017301,"comment_content":"选择排序好像涉及随机访问了，数组中首先要找到最小的元素序号，然后与当前无序数组开头的位置交换。<br>除非用指针记录最小节点的位置，以及最小节点前一个指针。另外纪录无序链表的第一个元素的位置。前后进行节点移动操作。","like_count":0},{"had_liked":false,"id":32538,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1539604820,"is_pvip":false,"replies":[{"id":"11888","content":"本来就不简单 多下点功夫吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539615898,"ip_address":"","comment_id":32538,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539604820","product_id":100017301,"comment_content":"大佬，我觉得分析复杂度很困难怎么办！","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426809,"discussion_content":"本来就不简单 多下点功夫吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539615898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32525,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1539601869,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539601869","product_id":100017301,"comment_content":"不得不说我是真的把这篇文章读了三遍...觉得算算法的复杂好恼火哦 尤其是平均时间复杂度","like_count":0},{"had_liked":false,"id":32520,"user_name":"朱明伟","can_delete":false,"product_type":"c1","uid":1243879,"ip_address":"","ucode":"D5C8F16E8CFC6F","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/e7/55f9283f.jpg","comment_is_top":false,"comment_ctime":1539600263,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539600263","product_id":100017301,"comment_content":"插入排序时间复杂度会小一点，因为不涉及移动其他数据了。只需要插入到最前面","like_count":0},{"had_liked":false,"id":32516,"user_name":"阳仔","can_delete":false,"product_type":"c1","uid":1046920,"ip_address":"","ucode":"79F73D85EDF3E2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/88/cdda9e6f.jpg","comment_is_top":false,"comment_ctime":1539597177,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539597177","product_id":100017301,"comment_content":"学习反馈：<br>如何分析排序算法，可以从以下三方面入手<br>1、分析排序算法的执行效率；<br>主要是从最好时间、最坏时间、平均时间复杂度来进行分析<br>2、分析内存消耗；<br>3、是否是稳定的排序算法；<br>当一个排序算法执行之后，如果仍然可以保持原有元素的相对位置，那么这个算法就是稳定的。<br>本文讲了3中常见的O(n^2)的排序算法<br>1、冒泡排序<br>2、选择排序<br>3、插入排序<br>冒泡排序和插入排序是稳定的排序算法，而选择排序则不是；<br>冒泡排序和选择排序更多是在理论理解上的，主要是锻炼思维能力，分析算法，实际使用很少；<br>在小规模的数据排序上，插入排序的效率是比较高的，因此在实际应用中会使用到。<br>本文的三种排序算法都是比较基础的，主要是要掌握分析算法的方法；<br>===========================================================<br>public static void bubbleSort(int[] a) {<br>        int n = a.length;<br>        if (n &lt;= 1) {<br>            return;<br>        }<br>        for (int i = 0; i &lt; n; ++i) {<br>            for (int j = 0; j &lt; n - i - 1; ++j) {<br>                if (a[j] &gt; a[j + 1]) {<br>                    swap(a, j, j + 1);<br>                }<br>            }<br>        }<br>    }<br><br>    public static void insertionSort(int[] a) {<br>        int n = a.length;<br>        if (n &lt;= 1) {<br>            return;<br>        }<br>        for (int i = 1; i &lt; n; ++i) {<br>            int value = a[i];<br>            int j = i - 1;<br>            while (j &gt;= 0) {<br>                if (a[j] &gt; value) {<br>                    a[j + 1] = a[j];<br>                    j--;<br>                } else {<br>                    break;<br>                }<br><br>            }<br>            a[j + 1] = value;<br>        }<br>    }<br><br>    public static void selectionSort(int[] a) {<br>        int n = a.length;<br>        if (n &lt;= 1) {<br>            return;<br>        }<br>        for (int i = 0; i &lt; n; ++i) {<br>            int min = i;<br>            for (int j = i + 1; j &lt; n; ++j) {<br>                if (a[min] &gt; a[j]) {<br>                    min = j;<br>                }<br>            }<br>            swap(a, min, i);<br>        }<br>    }<br><br>    private static void swap(int[] a, int i, int j) {<br>        int temp = a[i];<br>        a[i] = a[j];<br>        a[j] = temp;<br>    }<br>","like_count":0},{"had_liked":false,"id":32512,"user_name":"宋意","can_delete":false,"product_type":"c1","uid":1229043,"ip_address":"","ucode":"2CCFDB02BA8ADF","user_header":"https://static001.geekbang.org/account/avatar/00/12/c0/f3/281ccb06.jpg","comment_is_top":false,"comment_ctime":1539595996,"is_pvip":false,"replies":[{"id":"11889","content":"那还是自行百度吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539615966,"ip_address":"","comment_id":32512,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539595996","product_id":100017301,"comment_content":"老师，你的希尔排序是中文维基百科的连接，是不是得借给同学们一个梯子啊","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426801,"discussion_content":"那还是自行百度吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539615966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32502,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1539592077,"is_pvip":false,"replies":[{"id":"11870","content":"冒泡排序交换结点的话并不难吧，只是要多记录几个相邻的结点","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539614359,"ip_address":"","comment_id":32502,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539592077","product_id":100017301,"comment_content":"尝试用链表写冒泡，一开始想着要交换链表结点，好复杂。原来交换结点的值就好了。🙂","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426796,"discussion_content":"冒泡排序交换结点的话并不难吧，只是要多记录几个相邻的结点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539614359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32497,"user_name":"蒋礼锐","can_delete":false,"product_type":"c1","uid":1248897,"ip_address":"","ucode":"25E042066A1427","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/gM1ibHKPkrs5DSIp4aIuQ9jnYtNicc2tdG244PbaSvKw5jO9DWrhWghcVM1Y5Iq2QSpzLBUeWZQLhARst51z35mA/132","comment_is_top":false,"comment_ctime":1539590465,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539590465","product_id":100017301,"comment_content":"三种排序都能用链表实现，因为在链表中获取元素的复杂度为O(n)，插入元素的复杂度为O(1),而数组刚好相反，获取元素为1，插入元素为n，排序中均会涉及了插入和获取，所以两者的时间复杂度是一样的。但是空间复杂度两者都不需要额外申请，所以排序过程都是O(1)","like_count":0},{"had_liked":false,"id":32490,"user_name":"沉睡的木木夕","can_delete":false,"product_type":"c1","uid":1036362,"ip_address":"","ucode":"2C6B23B34C44E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d0/4a/7e3d158d.jpg","comment_is_top":false,"comment_ctime":1539589168,"is_pvip":false,"replies":[{"id":"11854","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539607164,"ip_address":"","comment_id":32490,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539589168","product_id":100017301,"comment_content":"自己在草稿上把插入排序的过程画了一遍，弄懂了所谓的前后顺序不变了","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426792,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539607164,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32489,"user_name":"Rain","can_delete":false,"product_type":"c1","uid":1238221,"ip_address":"","ucode":"6A270D922A3B9D","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","comment_is_top":false,"comment_ctime":1539589020,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539589020","product_id":100017301,"comment_content":"Re Kong:<br>----<br>老师，用数组实现的话，插入排序比冒泡排序的空间复杂度高，要不断移动数据的位置，我理解采用哪一种算法，要考虑数据的规模和数据结构吧？<br>----<br><br>插入排序并不比冒泡排序的空间复杂度高吧？他们的空间复杂度都是O(1), 因为他们都是借用了1个外部空间，冒泡排序用这个外部空间做数据交换，而插入排序用这个外部空间做数据对比以及暂存待排序元素的值。<br><br>另外再粘贴一段老师曾经回复留言时写的一句话：“空间复杂度是要看额外的内存消耗，而不是看链表存储本身需要多少空间”。","like_count":0},{"had_liked":false,"id":32481,"user_name":"🐱您的好友William🐱","can_delete":false,"product_type":"c1","uid":1215456,"ip_address":"","ucode":"427786DB178965","user_header":"https://static001.geekbang.org/account/avatar/00/12/8b/e0/9a79ddac.jpg","comment_is_top":false,"comment_ctime":1539587128,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539587128","product_id":100017301,"comment_content":"其实在将复杂度变成“有序度”思考的时候我们是忽略的if比较的复杂度的，这是因为仔细看看在前两个算法中，比较的复杂度虽然是大于等于数据搬移复杂度的，但是两个是同阶的（搬移和比较总是同时出现，或者比较出现搬移没有出现），所以最后没有影响。所以从另一个“只计算判断复杂度就够了“的角度，也可以得出是O(n^2) 。（个人观点，不对轻喷）","like_count":0},{"had_liked":false,"id":32479,"user_name":"Keep-Moving","can_delete":false,"product_type":"c1","uid":1182631,"ip_address":"","ucode":"76F33C06E07A27","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/a7/6ef32187.jpg","comment_is_top":false,"comment_ctime":1539586698,"is_pvip":false,"replies":[{"id":"11873","content":"是的，多一次也没关系，因为当i=n-1时，第二层循环什么都没做","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539614540,"ip_address":"","comment_id":32479,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539586698","product_id":100017301,"comment_content":"for (int i = 0; i &lt; n; ++i)<br>冒泡代码的外层循环，不用i &lt; n，直接i &lt; n - 1，就可以了吧","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426787,"discussion_content":"是的，多一次也没关系，因为当i=n-1时，第二层循环什么都没做","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539614540,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32461,"user_name":"沉睡的木木夕","can_delete":false,"product_type":"c1","uid":1036362,"ip_address":"","ucode":"2C6B23B34C44E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d0/4a/7e3d158d.jpg","comment_is_top":false,"comment_ctime":1539580649,"is_pvip":false,"replies":[{"id":"11875","content":"你关注黄色波浪线标注出来的三个订单，前后顺序没变","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539614878,"ip_address":"","comment_id":32461,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539580649","product_id":100017301,"comment_content":"&quot;如果两个 3 的前后顺序没有改变，那我们就把这种排序算法叫作...&quot;<br>我反复看了这句话以及后面的订单时间排序以及费用排序之后的demo，还是无法理解这个&quot;前后顺序没有改变&quot;到底指的是什么？<br>好比订单的排序demo，左图经过稳定排序算法演变到右图，怎么看都是“前后顺序已经改变了”<br>望解答这个疑问","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426781,"discussion_content":"你关注黄色波浪线标注出来的三个订单，前后顺序没变","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539614878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32419,"user_name":"刘远通","can_delete":false,"product_type":"c1","uid":1253307,"ip_address":"","ucode":"4D3EE819E4B235","user_header":"https://static001.geekbang.org/account/avatar/00/13/1f/bb/c488d5db.jpg","comment_is_top":false,"comment_ctime":1539567620,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539567620","product_id":100017301,"comment_content":"选择排序是交换两个元素的位置  插入是直接放到前面 但是要挪动很多的元素的位置<br>冒泡是通过相邻两个元素比较 如果可以一直往上冒的话  就是这个元素和每一个元素比较","like_count":0},{"had_liked":false,"id":32400,"user_name":"Geek_ed5c7b","can_delete":false,"product_type":"c1","uid":1094805,"ip_address":"","ucode":"F60D2D502E5C1E","user_header":"https://static001.geekbang.org/account/avatar/00/10/b4/95/433d47eb.jpg","comment_is_top":false,"comment_ctime":1539564892,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539564892","product_id":100017301,"comment_content":"个人觉得冒泡和插入排序可以用链表来实现，它的时间复杂度应该更少，因为不用移动数据","like_count":0},{"had_liked":false,"id":32385,"user_name":"Kong","can_delete":false,"product_type":"c1","uid":1211315,"ip_address":"","ucode":"D1BB2649F1CF84","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/b3/37b2b73d.jpg","comment_is_top":false,"comment_ctime":1539563896,"is_pvip":false,"replies":[{"id":"11881","content":"移动数据并不需要太多额外的存储空间的 空间复杂度也不高的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539615367,"ip_address":"","comment_id":32385,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539563896","product_id":100017301,"comment_content":"老师，用数组实现的话，插入排序比冒泡排序的空间复杂度高，要不断移动数据的位置，我理解采用哪一种算法，要考虑数据的规模和数据结构吧？<br>个人理解，请老师指正","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426751,"discussion_content":"移动数据并不需要太多额外的存储空间的 空间复杂度也不高的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539615367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32329,"user_name":"晚风·和煦","can_delete":false,"product_type":"c1","uid":1236047,"ip_address":"","ucode":"0B1DB8F437A4B2","user_header":"","comment_is_top":false,"comment_ctime":1539533576,"is_pvip":false,"replies":[{"id":"11883","content":"这块不怎么懂呢 不好意思","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539615482,"ip_address":"","comment_id":32329,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539533576","product_id":100017301,"comment_content":"作者您好，我理解不了git的快照，他是抽象的还是具体的东西。可以推荐一些文章吗？谢谢！","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426730,"discussion_content":"这块不怎么懂呢 不好意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539615482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}