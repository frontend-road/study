{"id":86540,"title":"27 | channel的关闭和广播","content":"<h1>课件及源代码地址</h1><p><a href=\"https://gitee.com/geektime-geekbang/go_learning\">https://gitee.com/geektime-geekbang/go_learning</a></p><h2>书目推荐</h2><p><a href=\"time://mall?url=https%3A%2F%2Fh5.youzan.com%2Fv2%2Fgoods%2F1ycmk3uob0ryw\">《计算机程序的构造和解释》</a></p>","comments":[{"had_liked":false,"id":79348,"user_name":"Harry陈祥","can_delete":false,"product_type":"c3","uid":1016584,"ip_address":"","ucode":"EC44D97731116D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/83/08/91caf5c1.jpg","comment_is_top":false,"comment_ctime":1553441637,"is_pvip":false,"replies":[{"id":28940,"content":"这个在前面的课程中讲到过，chan是一个结构，这个结构在传递时是被复制的，其中的指针成员也会被复制到新的chan中，所以新旧两个chan会指向同一个内存区域","user_name":"作者回复","user_name_real":"ChaoCai2010","uid":1008262,"ctime":1553470756,"ip_address":"","comment_id":79348,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100024001,"comment_content":"老师您好。\n传参 chan的时候，指针传参和值传参，看起来好像都可以work，而且复用的还是同一个通道。\n\n那对于chan的值传参，copy的是什么？","like_count":4,"discussions":[{"author":{"id":1008262,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/86/632ad029.jpg","nickname":"蔡超","note":"","ucode":"4C281BBF511238","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444464,"discussion_content":"这个在前面的课程中讲到过，chan是一个结构，这个结构在传递时是被复制的，其中的指针成员也会被复制到新的chan中，所以新旧两个chan会指向同一个内存区域","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553470756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1658796,"avatar":"https://static001.geekbang.org/account/avatar/00/19/4f/ac/80439ba7.jpg","nickname":"Aprelude","note":"","ucode":"840D3F7A35AEEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293523,"discussion_content":"那传chan的时候 chan是复制地址 还是复制chan的结构体呢 ，类似于切片还是数组呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595566366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234427,"user_name":"郭星","can_delete":false,"product_type":"c3","uid":1182219,"ip_address":"","ucode":"8A0F5DF80E0C61","user_header":"https://static001.geekbang.org/account/avatar/00/12/0a/0b/985d3800.jpg","comment_is_top":false,"comment_ctime":1594690480,"is_pvip":false,"replies":[{"id":87662,"content":" go语言是之传递的，所有如果不用指针，receiver中的wg将是一个副本并指向不同的地址空间，所以wg.Done()并不会是外部不同副本的wg.Wait()解除等待","user_name":"作者回复","user_name_real":"ChaoCai2010","uid":1008262,"ctime":1595767446,"ip_address":"","comment_id":234427,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100024001,"comment_content":"package close\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;sync&quot;\n\t&quot;testing&quot;\n)\n\n&#47;&#47; 发布者\nfunc publisher(ch chan int) {\n\tgo func() {\n\t\tfor i := 0; i &lt; 10; i++ {\n\t\t\tch &lt;- i\n\t\t}\n\t}()\n}\n\n&#47;&#47; 接受者\nfunc receiver(ch chan int, wg sync.WaitGroup) {\n\tgo func() {\n\t\t&#47;&#47;for {\n\t\tfor i := 0; i &lt; 10; i++ {\n\t\t\tfmt.Println(&lt;-ch)\n\t\t}\n\t\twg.Done()\n\t}()\n}\n\nfunc TestPubRe(t *testing.T) {\n\tvar wg sync.WaitGroup\n\tch := make(chan int)\n\tpublisher(ch)\n\twg.Add(1)\n\treceiver(ch, wg)\n\twg.Wait()\n}\n当WaitGroup使用值接收时为什么会报fatal error: all goroutines are asleep - deadlock!; ? \n但当我使用指针接收时,就不会抛出deadlock","like_count":3,"discussions":[{"author":{"id":1008262,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/86/632ad029.jpg","nickname":"蔡超","note":"","ucode":"4C281BBF511238","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501388,"discussion_content":" go语言是之传递的，所有如果不用指针，receiver中的wg将是一个副本并指向不同的地址空间，所以wg.Done()并不会是外部不同副本的wg.Wait()解除等待","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595767446,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2403351,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ac/17/430ddd05.jpg","nickname":"🐟","note":"","ucode":"F61C3F67E4A2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1008262,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/86/632ad029.jpg","nickname":"蔡超","note":"","ucode":"4C281BBF511238","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":542619,"discussion_content":"啊？这是为什么啊？ 值传递的情况下，wg 虽然结构被复制了一份，但是结构里面的指针指向的内存还是同一块儿吧？ 我迷惑了老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640795666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":501388,"ip_address":"","group_id":0},"score":542619,"extra":""}]},{"author":{"id":2890901,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/1c/95/3d8920c9.jpg","nickname":"abcdabcd999","note":"","ucode":"E1D9902737F544","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600938,"discussion_content":"wg Done 就是一个 计数器而已，\nfunc (wg *WaitGroup) Done() {\n\twg.Add(-1)\n}\n这有啥迷惑的，你要修改这里面的数字，你就得传递指针","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674963484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"山西","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250890,"user_name":"Geek_427d0c","can_delete":false,"product_type":"c3","uid":1876823,"ip_address":"","ucode":"D7A04138C4B8CB","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/X4ib36ADEvj76XaKD4OUY9k15KqWCAVCwibPicBxz6BBUfDrVolpYInn8zFOw3JBPtVw3L4Lkibaf2eLPemwGKzAXA/132","comment_is_top":false,"comment_ctime":1601274046,"is_pvip":false,"replies":[{"id":99524,"content":"这个我在讲座中有讲过：\n1 Go语言是都是传值的，\n2 chan是一个结构体，被复制后其中的成员仍指向同一内存区域，类似的还有slice和map","user_name":"作者回复","user_name_real":"蔡超","uid":1008262,"ctime":1610891685,"ip_address":"","comment_id":250890,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100024001,"comment_content":"func dataProducer(ch chan int, wg *sync.WaitGroup) 老师，为什么你只把WaitGroup的指针传进去，而channel不传指针呢？编程(ch *chan int, wg *sync.WaitGroup)?","like_count":2,"discussions":[{"author":{"id":1008262,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/86/632ad029.jpg","nickname":"蔡超","note":"","ucode":"4C281BBF511238","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506327,"discussion_content":"这个我在讲座中有讲过：\n1 Go语言是都是传值的，\n2 chan是一个结构体，被复制后其中的成员仍指向同一内存区域，类似的还有slice和map","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610891685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83184,"user_name":"Steven Fung","can_delete":false,"product_type":"c3","uid":1052952,"ip_address":"","ucode":"193D1031AA362B","user_header":"https://static001.geekbang.org/account/avatar/00/10/11/18/bba8efd2.jpg","comment_is_top":false,"comment_ctime":1554453891,"is_pvip":false,"replies":[{"id":30063,"content":"这是因为你用的是buffered chan他是非阻塞的。所以只要外面的主协程在退出前能有时间让他运行完，他就可以输出。\n你可以在TestSelect最后退出前加一个sleep 1秒，你就会发现更短的timeout一样会输出那些信息","user_name":"作者回复","user_name_real":"ChaoCai2010","uid":1008262,"ctime":1554476779,"ip_address":"","comment_id":83184,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100024001,"comment_content":"func serviceOne() string {\n\ttime.Sleep(time.Millisecond * 50)\n\treturn &quot;service 1 done&quot;\n}\n\nfunc channelserviceone_2nd() chan string {\n\tretCh := make(chan string, 1)\n\tgo func() {\n\t\tret := serviceOne()\n\t\tfmt.Println(&quot;returned result.&quot;)\n\t\tretCh &lt;- ret\n\t\tfmt.Println(&quot;service exited.&quot;)\n\t}()\n\treturn retCh\n}\n\nfunc TestSelect(t *testing.T) {\n\tselect {\n\tcase ret := &lt;-channelserviceone_2nd():\n\t\tt.Log(ret)\n\tcase &lt;-time.After(time.Millisecond * 49):\n\t\tt.Log(&quot;time out&quot;)\n\t}\n}\n\nOutput:\n=== RUN   TestSelect\nreturned result.\nservice exited.\n--- PASS: TestSelect (0.05s)\n    &#47;Users&#47;stevenfung&#47;Documents&#47;code&#47;go&#47;src&#47;github.com&#47;CrazyPassion&#47;go&#47;helloworld&#47;test&#47;goroutine&#47;goroutine_test.go:115: time out\nPASS\nok  \tgithub.com&#47;CrazyPassion&#47;go&#47;helloworld&#47;test&#47;goroutine\t0.058s\nSuccess: Tests passed.\n老师，请教下这个问题，这个想不明白。按说serviceOne等待是50ms，49ms会超时，觉得应该看不到channelserviceone_2nd里面的打印，但是现在可以看到，并且也看到了超时的打印，这个是为什么？","like_count":2,"discussions":[{"author":{"id":1008262,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/86/632ad029.jpg","nickname":"蔡超","note":"","ucode":"4C281BBF511238","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445908,"discussion_content":"这是因为你用的是buffered chan他是非阻塞的。所以只要外面的主协程在退出前能有时间让他运行完，他就可以输出。\n你可以在TestSelect最后退出前加一个sleep 1秒，你就会发现更短的timeout一样会输出那些信息","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554476779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2890901,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/1c/95/3d8920c9.jpg","nickname":"abcdabcd999","note":"","ucode":"E1D9902737F544","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600934,"discussion_content":"打印出这一句并不代表就同时执行了两个 case，调用 channelserviceone_2nd() 就会启动它里面的 goroutine，这个goroutine 实际上没有没有完全执行完，得到了第二个 case 的超时，所以就输出 time out，我在上一篇的评论区中给出了例子，这也是 select 的真正的用处","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674963271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"山西","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","nickname":"escray","note":"","ucode":"1F4204930E47C4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366268,"discussion_content":"按照老师提示，将 timeout 的时间改为了 30 ms，在 TestSelect 后面增加了 sleep 1 秒\nfunc TestSelectAgain(t *testing.T) {\n    select {\n    case ret := <-channelserviceone_2nd():\n        t.Log(ret)\n    case <-time.After(time.Millisecond * 30):\n        t.Log(&#34;time out&#34;)\n    }\n    time.Sleep(time.Second * 1)\n}\n输出如下：\n\n=== RUN   TestSelectAgain\n   ... /src/channel_close_test.go:86: time out\nreturned result.\nservice exited.\n--- PASS: TestSelectAgain (1.04s)\n\n可以看到即使是超时了，仍然输出了 channelserviceone_2nd 里面的打印。\n\n另外，如果将通道改为非阻塞的（不增加 sleep），那么就会得到：\n\nreturned result.\n    .../src/channel_close_test.go:86: time out\n\n打印出了一句，稍微有一点诡异","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618017950,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2719667,"avatar":"https://static001.geekbang.org/account/avatar/00/29/7f/b3/e50ec43e.jpg","nickname":"查理安","note":"","ucode":"D9432FE5E2C1AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","nickname":"escray","note":"","ucode":"1F4204930E47C4","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":401019,"discussion_content":"最后只打印出了一句是因为主协程执行完了，剩下的&#34;service exited.&#34;没来得及执行到就退出了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633522823,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":366268,"ip_address":"","group_id":0},"score":401019,"extra":""}]}]},{"had_liked":false,"id":143224,"user_name":"碧雪天虹","can_delete":false,"product_type":"c3","uid":1258359,"ip_address":"","ucode":"313CC048C7E341","user_header":"https://static001.geekbang.org/account/avatar/00/13/33/77/0c593044.jpg","comment_is_top":false,"comment_ctime":1571651213,"is_pvip":false,"replies":[{"id":55917,"content":"通道应该由生产者来关闭，在关闭的channel上发送数据程序会panic","user_name":"作者回复","user_name_real":"ChaoCai2010","uid":1008262,"ctime":1572178671,"ip_address":"","comment_id":143224,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100024001,"comment_content":"消费者可以通过 data,ok&lt;-ch 来判断通道是否关闭, 生产者如何判断通道是否关闭?\n\nfunc TestCloseChannel(t *testing.T) {\n\tvar wg sync.WaitGroup\n\tch := make(chan int)\n\tdataProducer(ch, &amp;wg)\n\tdataReceiver(ch, &amp;wg)\n        &#47;&#47; 已经关闭通道, 生产者如何判断\n\tclose(ch)\n\twg.Wait()\n}\n","like_count":1,"discussions":[{"author":{"id":1008262,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/86/632ad029.jpg","nickname":"蔡超","note":"","ucode":"4C281BBF511238","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471431,"discussion_content":"通道应该由生产者来关闭，在关闭的channel上发送数据程序会panic","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572178671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250936,"user_name":"Geek_427d0c","can_delete":false,"product_type":"c3","uid":1876823,"ip_address":"","ucode":"D7A04138C4B8CB","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/X4ib36ADEvj76XaKD4OUY9k15KqWCAVCwibPicBxz6BBUfDrVolpYInn8zFOw3JBPtVw3L4Lkibaf2eLPemwGKzAXA/132","comment_is_top":false,"comment_ctime":1601284844,"is_pvip":false,"replies":[{"id":91843,"content":"在go test的运行程序中也要实用fmt输出，不要使用t.log.\n通过go test -v运行","user_name":"作者回复","user_name_real":"ChaoCai2010","uid":1008262,"ctime":1601386342,"ip_address":"","comment_id":250936,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100024001,"comment_content":"请教老师，go run和go test有什么不同呢？ 我为了实现消费者每隔一秒打印0，1，2...，所以在生产者的协程里加了一个time.Sleep，也就是每隔一秒产生一个数字。IDE的debug模式和go run都能正常实现，但是go test看起来就像把输出缓存起来，然后等最外面额协程执行完，一下子打印所有的输出","like_count":0,"discussions":[{"author":{"id":1008262,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/86/632ad029.jpg","nickname":"蔡超","note":"","ucode":"4C281BBF511238","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506339,"discussion_content":"在go test的运行程序中也要实用fmt输出，不要使用t.log.\n通过go test -v运行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601386342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177240,"user_name":"黄三可","can_delete":false,"product_type":"c3","uid":1132988,"ip_address":"","ucode":"DDD0ED0C1E419F","user_header":"https://static001.geekbang.org/account/avatar/00/11/49/bc/c324a7de.jpg","comment_is_top":false,"comment_ctime":1581330564,"is_pvip":false,"replies":[{"id":70076,"content":"WaitGroup类似于Channel这样的对象，他的定义是一个结构，虽然对象复制了，但是对象中成员还是指向同一地址空间的。","user_name":"作者回复","user_name_real":"ChaoCai2010","uid":1008262,"ctime":1582344385,"ip_address":"","comment_id":177240,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100024001,"comment_content":"本节中的dataProducer方法，waitGroup传入的是指针，为什么在方法体中使用时，不需要像传入int指针一样，写成*wg.Done()","like_count":0,"discussions":[{"author":{"id":1008262,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/86/632ad029.jpg","nickname":"蔡超","note":"","ucode":"4C281BBF511238","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483356,"discussion_content":"WaitGroup类似于Channel这样的对象，他的定义是一个结构，虽然对象复制了，但是对象中成员还是指向同一地址空间的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582344385,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136710,"user_name":"面向加薪学习","can_delete":false,"product_type":"c3","uid":1108117,"ip_address":"","ucode":"5164A1DF058AC5","user_header":"https://static001.geekbang.org/account/avatar/00/10/e8/95/13b88119.jpg","comment_is_top":false,"comment_ctime":1569495731,"is_pvip":false,"replies":[{"id":52594,"content":"这部分不会有问题。","user_name":"作者回复","user_name_real":"ChaoCai2010","uid":1008262,"ctime":1569647729,"ip_address":"","comment_id":136710,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100024001,"comment_content":"老师，请教一个问题，如果做爬虫程序，其实程序启动就是死循环，初始化channel容量10个，有新数据就添加到channel里，然后一直不关闭，应该也不会有问题吧","like_count":0,"discussions":[{"author":{"id":1008262,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/86/632ad029.jpg","nickname":"蔡超","note":"","ucode":"4C281BBF511238","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468766,"discussion_content":"这部分不会有问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569647729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112045,"user_name":"mamba","can_delete":false,"product_type":"c3","uid":1598484,"ip_address":"","ucode":"24DB3BBFFFF8B5","user_header":"https://static001.geekbang.org/account/avatar/00/18/64/14/13f37902.jpg","comment_is_top":false,"comment_ctime":1562659714,"is_pvip":false,"replies":[{"id":41238,"content":"虽然，语句是串行的，是线程的调度不是","user_name":"作者回复","user_name_real":"ChaoCai2010","uid":1008262,"ctime":1562938229,"ip_address":"","comment_id":112045,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100024001,"comment_content":"func TestCloseChannel(t *testing.T) {\n\tvar wg sync.WaitGroup\n\tch := make(chan int)\n\n\twg.Add(1)\n\tdataProducer(ch, &amp;wg)\n\twg.Add(1)\n\tdataReceiver(ch, &amp;wg)\n\twg.Add(1)\n\tdataReceiver(ch, &amp;wg)\n\twg.Add(1)\n\tdataReceiver(ch, &amp;wg)\n\twg.Wait()\n}\n\n想知道，为什么后面的两个 dataReceiver 也能得到数据，  难道这三个dataReceiver不是串行执行的吗？我的理解是第一个 dataReceiver 会把 dataProducer 产生的所有数据都读完 才退出。\n","like_count":0,"discussions":[{"author":{"id":1008262,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/86/632ad029.jpg","nickname":"蔡超","note":"","ucode":"4C281BBF511238","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457550,"discussion_content":"虽然，语句是串行的，是线程的调度不是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562938229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106949,"user_name":"田佳伟","can_delete":false,"product_type":"c3","uid":1034087,"ip_address":"","ucode":"D31C9799F383D2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/67/0077314b.jpg","comment_is_top":false,"comment_ctime":1561427912,"is_pvip":false,"replies":[{"id":38770,"content":"实际上和方法调用的直接传递复制是不同的，还是通过chan来完成的","user_name":"作者回复","user_name_real":"ChaoCai2010","uid":1008262,"ctime":1561470459,"ip_address":"","comment_id":106949,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100024001,"comment_content":"老师，当发送操作在执行的时候发现空的通道中，正好有等待的接收操作，那么它会直接把元素值复制给接收方，实际是这样的吗","like_count":0,"discussions":[{"author":{"id":1008262,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/86/632ad029.jpg","nickname":"蔡超","note":"","ucode":"4C281BBF511238","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455297,"discussion_content":"实际上和方法调用的直接传递复制是不同的，还是通过chan来完成的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561470459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103497,"user_name":"春春家的雷雷","can_delete":false,"product_type":"c3","uid":1453138,"ip_address":"","ucode":"267A4726E5F95F","user_header":"","comment_is_top":false,"comment_ctime":1560468770,"is_pvip":false,"replies":[{"id":37615,"content":"waitgroup 方法是没有timeout可以设置的。你可以通过后面课程介绍的取消任务相关的内容自己实现一个有超时的等待（参见select部分内容）","user_name":"作者回复","user_name_real":"ChaoCai2010","uid":1008262,"ctime":1560591461,"ip_address":"","comment_id":103497,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100024001,"comment_content":"wg是不是要设置一下超时时间呢","like_count":0,"discussions":[{"author":{"id":1008262,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/86/632ad029.jpg","nickname":"蔡超","note":"","ucode":"4C281BBF511238","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453897,"discussion_content":"waitgroup 方法是没有timeout可以设置的。你可以通过后面课程介绍的取消任务相关的内容自己实现一个有超时的等待（参见select部分内容）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560591461,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78090,"user_name":"Gary","can_delete":false,"product_type":"c3","uid":1218372,"ip_address":"","ucode":"12265D6A578113","user_header":"https://static001.geekbang.org/account/avatar/00/12/97/44/3929e620.jpg","comment_is_top":false,"comment_ctime":1553069624,"is_pvip":false,"replies":[{"id":28495,"content":"可以的","user_name":"作者回复","user_name_real":"ChaoCai2010","uid":1008262,"ctime":1553087367,"ip_address":"","comment_id":78090,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100024001,"comment_content":"channel可以放自定义类型吗？","like_count":0,"discussions":[{"author":{"id":1008262,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/86/632ad029.jpg","nickname":"蔡超","note":"","ucode":"4C281BBF511238","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443963,"discussion_content":"可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553087367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":273852,"user_name":"Geek_d586af","can_delete":false,"product_type":"c3","uid":2161180,"ip_address":"","ucode":"2966DBC6BD9B20","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/jtNYcW0hUoI1RzVic1tpJ7mkh4nccicC3aaC4aicYQCy9R1RZBMSWn8qDxjvVKqca9LnWxCfsicEqeW0bUkX6Bogyg/132","comment_is_top":false,"comment_ctime":1610697023,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":3,"product_id":100024001,"comment_content":"疑问：如果buffer channel还有没取完数据，此时关闭channel，那么未取完的数据怎么办？\n猜测：buffer channel的close操作肯定是在buffer channel未空的时候进行的。\n\n然后进行一下测试\nfunc pruducer(c chan int, wg *sync.WaitGroup) {\n\tgo func() {\n\t\tfor i := 0; i &lt; 10; i++ {\n\t\t\tc &lt;- i\n\t\t}\n\t\tclose(c)\n\t\tfmt.Println(&quot;关闭通道&quot;)\n\t\twg.Done()\n\t}()\n}\n\nfunc consumer(c chan int, w *sync.WaitGroup) {\n\tgo func() {\n\t\tfor  {\n\t\t\ttime.Sleep(time.Microsecond*10)\n\t\t\tif i, ok := &lt;-c; ok{\n\t\t\t\tfmt.Println(i)\n\t\t\t}else {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tw.Done()\n\t}()\n}\n\nfunc TestChannelClose(t *testing.T)  {\n\twg:=&amp;sync.WaitGroup{}\n\tc:=make(chan int,10)\n\twg.Add(2)\n\tpruducer(c,wg)\n\tconsumer(c,wg)\n\twg.Wait()\n}\n运行结果：\n0\n1\n关闭通道\n2\n3\n4\n5\n6\n7\n8\n9\n\n可以看出，buffer channel的数据没取完，就已经执行了close()。\n首先可以肯定数据没取完是不可能关闭通道的，所以我猜测close()也是异步操作，相当于协程里在创建一个协程，只有在全部取完数据后，在具体执行真正意义的关闭通道，","like_count":13,"discussions":[{"author":{"id":1020525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","nickname":"escray","note":"","ucode":"1F4204930E47C4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366264,"discussion_content":"打印出来“关闭通道”，并不意味着通道已经关闭了。\n\n我觉的你的猜测应该是对的，会等到通道中的全部数据取完之后，才会真正关闭。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618017430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281766,"user_name":"八宝","can_delete":false,"product_type":"c3","uid":1324501,"ip_address":"","ucode":"89D991A930FDEA","user_header":"https://static001.geekbang.org/account/avatar/00/14/35/d5/17833946.jpg","comment_is_top":false,"comment_ctime":1614872977,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":1,"score":3,"product_id":100024001,"comment_content":"func TestChannleClose(t *testing.T) {\n\tvar group sync.WaitGroup\n\tch := make(chan int, 10)\n\tfmt.Printf(&quot;main goroutine chan int address: %x\\n&quot;, unsafe.Pointer(&amp;ch))\n\tfmt.Printf(&quot;main goroutine waitGroup address: %x\\n&quot;, unsafe.Pointer(&amp;group))\n\tgroup.Add(1)\n\tgo func(ch1 chan int, wg *sync.WaitGroup) {\n\t\tfmt.Printf(&quot;producer chan int address: %x\\n&quot;, unsafe.Pointer(&amp;ch1))\n\t\tfmt.Printf(&quot;producer goroutine waitGroup address: %x\\n&quot;, unsafe.Pointer(wg))\n\t\tfor i := 1; i &lt; 11; i++ {\n\t\t\tch1 &lt;- i\n\t\t}\n\t\tclose(ch1)\n\t\twg.Done()\n\t}(ch, &amp;group)\n\tgroup.Add(1)\n\tgo func(ch1 *chan int, wg *sync.WaitGroup) {\n\t\tfmt.Printf(&quot;consumer chan int address: %x\\n&quot;, unsafe.Pointer(ch1))\n\t\tfmt.Printf(&quot;consumer goroutine waitGroup address: %x\\n&quot;, unsafe.Pointer(wg))\n\t\tfor {\n\t\t\tif v, ok := &lt;-*ch1; ok {\n\t\t\t\tfmt.Println(v)\n\t\t\t} else {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\twg.Done()\n\t}(&amp;ch, &amp;group)\n\tgroup.Wait()\n}\n输出如下：\n=== RUN   TestChannleClose\nmain goroutine chan int address: c000006048\nmain goroutine waitGroup address: c000016340\nconsumer chan int address: c000006048\nconsumer goroutine waitGroup address: c000016340\nproducer chan int address: c000086000\nproducer goroutine waitGroup address: c000016340\n\n结论： golang 方法传参都是值传递，如果不使用指针传递，那么会创建新的对象并进行内容复制","like_count":3,"discussions":[{"author":{"id":2853200,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/89/50/aee9fdab.jpg","nickname":"小杰","note":"","ucode":"BBDF8E9F348F65","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545363,"discussion_content":"好棒，而且我看sync.WaitGroup第一次的复制不能是值，所以考虑用指针传递。实际go里面指针也只是copy过去的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641916294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147966,"user_name":"我姓蔡。","can_delete":false,"product_type":"c3","uid":1625164,"ip_address":"","ucode":"42852793D6A945","user_header":"https://static001.geekbang.org/account/avatar/00/18/cc/4c/aea32790.jpg","comment_is_top":false,"comment_ctime":1572923406,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100024001,"comment_content":"对于通道的okidiom，ok我更愿意理解为是否有数据可以接收，对于同步通道来说，接发都是阻塞的，接收数据不阻塞了要么是有一端发送了数据，要么是通道close了，所以对于同步通道ok为false，那么就是通道关闭了，对于异步通道来说，通道close了，但是通道中还有数据存在，这个时候接收ok还是为true，只有当没有数据可以接收了，ok才为false。\n对于closed和nil的通道:\n1.对于closed的通道，发送数据会panic\n2.对于closed的通道，同步通道会读出零值，异步通道如果有缓存数据读出缓存数据，没有缓存数据读出零值\n3.对于nil通道，读和写都会阻塞，可以利用这一点，在通道多路选择的时候，将读完数据的通道置空，判断所有通道都为nil之后才退出。","like_count":3},{"had_liked":false,"id":81917,"user_name":"面朝大海春暖花开","can_delete":false,"product_type":"c3","uid":1118924,"ip_address":"","ucode":"F9F9F53D05304B","user_header":"https://static001.geekbang.org/account/avatar/00/11/12/cc/6a08cf26.jpg","comment_is_top":false,"comment_ctime":1554082550,"is_pvip":false,"replies":null,"discussion_count":3,"race_medal":0,"score":3,"product_id":100024001,"comment_content":"开始有点困扰，如果channel里的数据没有取完，这时producer关闭了channel，receiver能继续取数据么？\n然后实验了一下：发现当receivers从channel取完了数据，producer的colse(channel)才会被执行，即close(channel)会阻塞至channel中数据全部被取完。\n不知道对不对，请老师指点。多谢！","like_count":3,"discussions":[{"author":{"id":1363634,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ce/b2/1f914527.jpg","nickname":"海盗船长","note":"","ucode":"ECB28BA21A4113","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320071,"discussion_content":"你的结论是对的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604237248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2002004,"avatar":"","nickname":"周勇","note":"","ucode":"38AB0AF3654DB8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265675,"discussion_content":"我认为不管有没有缓存，close的关闭都是在channel全部被取走之后才进行的操作。\nfunc TestCloseChannel(t *testing.T) {\n\tvar wg sync.WaitGroup\n\tch := make(chan int)\n\twg.Add(1)\n\tgo func() {\n\t\tdataProducer(ch, &amp;wg)\n\t}()\n\n\ttime.Sleep(time.Second * 2)\n\tif _, ok := <-ch; ok {\n\t\tfmt.Println(&#34;当前通道是打开的&#34;)\n\t} else {\n\t\tfmt.Println(&#34;当前通道是关闭的&#34;)\n\t}\n\n\twg.Add(1)\n\tdataReceiver(ch, &amp;wg)\n\twg.Wait()\n}\n\n\n结果：\n当前通道是打开的\n1\n2\n3\n4\n5\n6\n7\n8\n9","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589427637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1419723,"avatar":"https://static001.geekbang.org/account/avatar/00/15/a9/cb/a431bde5.jpg","nickname":"木头发芽","note":"","ucode":"657B381C5DA963","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":247649,"discussion_content":"不带buffer的chan是会阻塞至被取走为止的，所以没有close的还没取完之说","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587820386,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359551,"user_name":"恶魔果实","can_delete":false,"product_type":"c3","uid":1962297,"ip_address":"广东","ucode":"691CD833C984AC","user_header":"https://static001.geekbang.org/account/avatar/00/1d/f1/39/b0960780.jpg","comment_is_top":false,"comment_ctime":1665640792,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100024001,"comment_content":"x, ok := &lt;-ch\n\n一个已关闭的管道有两种情况：\n1.管道缓冲区已经没有数据；\n2.管道缓冲区还有数据。\n\n第一种情况，管道已经关闭且缓冲区没有数据，那么管道读取表达式返回的第一个变量相应类型的零值，第二个变量为false\n\n第二种情况，管道已经关闭且缓冲区还有数据，那么管道毒气表达式第一个变量为读取到的数据，第二个变量为true\n\n可见，只有管道已经关闭且缓冲区中没有数据的时候，管道读取表达式返回的第二个变量才跟管道关闭状态一致。","like_count":0},{"had_liked":false,"id":315107,"user_name":"阿俊","can_delete":false,"product_type":"c3","uid":1049343,"ip_address":"","ucode":"3ADA1093D29D5E","user_header":"https://static001.geekbang.org/account/avatar/00/10/02/ff/569d5904.jpg","comment_is_top":false,"comment_ctime":1633689662,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100024001,"comment_content":"感觉这个chan有点像Java的阻塞队列","like_count":0},{"had_liked":false,"id":307327,"user_name":"braincy","can_delete":false,"product_type":"c3","uid":1467619,"ip_address":"","ucode":"B1DE2447CD5102","user_header":"https://static001.geekbang.org/account/avatar/00/16/64/e3/6e469d05.jpg","comment_is_top":false,"comment_ctime":1629030436,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":3,"product_id":100024001,"comment_content":"老师，我尝试了下两个 Receiver 的运行时间为什么会比一个 Receiver 的时间长？","like_count":0,"discussions":[{"author":{"id":2890901,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/1c/95/3d8920c9.jpg","nickname":"abcdabcd999","note":"","ucode":"E1D9902737F544","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600930,"discussion_content":"这可能是线程调度引起的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674962871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"山西","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":304006,"user_name":"山青","can_delete":false,"product_type":"c3","uid":1627670,"ip_address":"","ucode":"904AE3C23D3B92","user_header":"https://static001.geekbang.org/account/avatar/00/18/d6/16/107f0d04.jpg","comment_is_top":false,"comment_ctime":1627182005,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":3,"product_id":100024001,"comment_content":"这个多个receiver接收同一个producer产生的数据，可以不可以理解为一个地方产生数据后，由于线程（协程）调度，其中一个receiver接收到数据后，宁外一个接受者还处于阻塞状态，只有调度到他的协程的 时候他才能去接受到下一个数据、","like_count":0,"discussions":[{"author":{"id":2403351,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ac/17/430ddd05.jpg","nickname":"🐟","note":"","ucode":"F61C3F67E4A2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542614,"discussion_content":"我也是这么理解的，两个receiver 相当于是在抢占 channel 里的数据，抢到的 就消费，抢不到的 相当于面对一个空channel，就继续阻塞咯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640795006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":304002,"user_name":"山青","can_delete":false,"product_type":"c3","uid":1627670,"ip_address":"","ucode":"904AE3C23D3B92","user_header":"https://static001.geekbang.org/account/avatar/00/18/d6/16/107f0d04.jpg","comment_is_top":false,"comment_ctime":1627181024,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100024001,"comment_content":"我感觉这个for循环里面一个发送一个接受 我感觉只有一个receiver 一个for循环发送一个for 循环接受  ，相互阻塞  发完后只要收完就可以了 如果收发数量不对等 会出现发阻塞或者收阻塞","like_count":0},{"had_liked":false,"id":287534,"user_name":"escray","can_delete":false,"product_type":"c3","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1618018836,"is_pvip":true,"replies":null,"discussion_count":1,"race_medal":0,"score":4,"product_id":100024001,"comment_content":"一个或多个 Producer ，配合一个或多个 Receiver，语句串行，线程调度并行，Go 语言确实是天生异步。\n\n我觉的 channel 关闭的机制还是挺巧妙的。\n\n结合留言中的代码示例，可以看到 close 是异步的，会等通道中的数据被完全读取之后再关闭。\n\n```\nch chan int, wg *sync.WaitGroup\n```\n\n这个参数列表可以记在心中\n\n另外得记住 channel 是结构体，传递的时候是被复制的，新旧两个 channel 指向同一个内存区域。\n","like_count":0,"discussions":[{"author":{"id":2890901,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/1c/95/3d8920c9.jpg","nickname":"abcdabcd999","note":"","ucode":"E1D9902737F544","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600928,"discussion_content":"?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674962840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"山西","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208475,"user_name":"拉铁","can_delete":false,"product_type":"c3","uid":1224912,"ip_address":"","ucode":"4286AEAD0A6E6C","user_header":"","comment_is_top":false,"comment_ctime":1587367161,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100024001,"comment_content":"当channel关闭并且缓冲区为空时，继续从从channel接收消息才会得到一个对应类型的零值。","like_count":0},{"had_liked":false,"id":121737,"user_name":"虢國技醬","can_delete":false,"product_type":"c3","uid":1056807,"ip_address":"","ucode":"5A192262AA037E","user_header":"https://static001.geekbang.org/account/avatar/00/10/20/27/a6932fbe.jpg","comment_is_top":false,"comment_ctime":1565194746,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100024001,"comment_content":"跟着老师一起手动敲代码，越瞧越来劲","like_count":0},{"had_liked":false,"id":78228,"user_name":"忽然之间","can_delete":false,"product_type":"c3","uid":1052876,"ip_address":"","ucode":"CA6CF7883735DE","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/cc/9226d3c8.jpg","comment_is_top":false,"comment_ctime":1553096923,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100024001,"comment_content":"type MyChan struct {\n\tChid int\n    Msg  string\n}\n\nfunc dataProducer1(ch chan MyChan, wg *sync.WaitGroup) {\n\tgo func() {\n\t\tfor i := 0; i &lt; 10; i++ {\n\t\t\tch &lt;- MyChan{i, &quot;msg&quot;}\n\t\t}\n\t\tclose(ch)\n\t\twg.Done()\n\t}()\n}\n\nfunc TestCloseChannel1(t *testing.T) {\n\tvar wg sync.WaitGroup\n\tch := make(chan MyChan)\n\twg.Add(1)\n\tdataProducer1(ch, &amp;wg)\n\twg.Add(1)\n\tdataReceiver1(ch, &amp;wg)\n\twg.Wait()\n}\n\n先模仿老师的代码。 ","like_count":0}]}