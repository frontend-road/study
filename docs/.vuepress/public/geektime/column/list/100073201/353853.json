{"id":353853,"title":"07 | 条件语句：WHERE 与 HAVING有什么不同?","content":"<p>你好，我是朱晓峰。</p><p>我们在进行查询的时候，经常需要按条件对查询结果进行筛选，这就要用到条件语句WHERE和HAVING了。</p><p>WHERE是直接对表中的字段进行限定，来筛选结果；HAVING则需要跟分组关键字GROUP BY一起使用，通过对分组字段或分组计算函数进行限定，来筛选结果。虽然它们都是对查询进行限定，却有着各自的特点和适用场景。很多时候，我们会遇到2个都可以用的情况。一旦用错，就很容易出现执行效率低下、查询结果错误，甚至是查询无法运行的情况。</p><p>下面我就借助项目实施过程中的实际需求，给你讲讲WHERE和HAVING分别是如何对查询结果进行筛选的，以及它们各自的优缺点，来帮助你正确地使用它们，使你的查询不仅能够得到正确的结果，还能占用更少的资源，并且速度更快。</p><h2>一个实际查询需求</h2><p>超市的经营者提出，要查单笔销售金额超过50元的商品。我们来分析一下这个需求：需要查询出一个商品记录集，限定条件是单笔销售金额超过50元。这个时候，我们就需要用到WHERE和HAVING了。</p><p>这个问题的条件很明确，查询的结果也只有“商品”一个字段，好像很容易实现。</p><p>假设我们有一个这样的商品信息表（demo.goodsmaster），里面有2种商品：书和笔。</p><!-- [[[read_end]]] --><pre><code>mysql&gt; SELECT *\n    -&gt; FROM demo.goodsmaster;\n+------------+---------+-----------+---------------+------+------------+\n| itemnumber | barcode | goodsname | specification | unit | salesprice |\n+------------+---------+-----------+---------------+------+------------+\n|          1 | 0001    | 书        |               | 本   |      89.00 |\n|          2 | 0002    | 笔        |               | 支   |       5.00 |\n+------------+---------+-----------+---------------+------+------------+\n2 rows in set (0.00 sec)\n</code></pre><p>同时，我们还有一个商品销售明细表（demo.transactiondetails），里面有4条销售记录：</p><pre><code>mysql&gt; SELECT *\n    -&gt; FROM demo.transactiondetails;\n+---------------+------------+----------+-------+------------+\n| transactionid | itemnumber | quantity | price | salesvalue |\n+---------------+------------+----------+-------+------------+\n|             1 |          1 |    1.000 | 89.00 |      89.00 |\n|             1 |          2 |    2.000 |  5.00 |      10.00 |\n|             2 |          1 |    2.000 | 89.00 |     178.00 |\n|             3 |          2 |   10.000 |  5.00 |      50.00 |\n+---------------+------------+----------+-------+------------+\n4 rows in set (0.01 sec)\n</code></pre><p>接下来，我们分别用WHERE和HAVING进行查询，看看它们各自是如何查询的，是否能够得到正确的结果。</p><p>第一步，用WHERE关键字进行查询：</p><pre><code>mysql&gt; SELECT DISTINCT b.goodsname\n-&gt; FROM demo.transactiondetails AS a\n-&gt; JOIN demo.goodsmaster AS b\n-&gt; ON (a.itemnumber=b.itemnumber)\n-&gt; WHERE a.salesvalue &gt; 50;\n+-----------+\n| goodsname |\n+-----------+\n| 书 |\n+-----------+\n1 row in set (0.00 sec)\n</code></pre><p>第二步，用HAVING关键字进行查询：</p><pre><code>mysql&gt; SELECT b.goodsname\n-&gt; FROM demo.transactiondetails AS a\n-&gt; JOIN demo.goodsmaster AS b\n-&gt; ON (a.itemnumber=b.itemnumber)\n-&gt; GROUP BY b.goodsname\n-&gt; HAVING max(a.salesvalue)&gt;50;\n+-----------+\n| goodsname |\n+-----------+\n| 书 |\n+-----------+\n1 row in set (0.00 sec)\n</code></pre><p>可以发现，两次查询的结果是一样的。那么，这两种查询到底有什么区别，哪个更好呢？要弄明白这个问题，我们要先学习下WHERE和HAVING的执行过程。</p><h2>WHERE</h2><p>我们先来分析一下刚才使用WHERE条件的查询语句，来看看MySQL是如何执行这个查询的。</p><p>首先，MySQL从数据表demo.transactiondetails中抽取满足条件“a.salesvalue&gt;50”的记录：</p><pre><code>mysql&gt; SELECT *\n    -&gt; FROM demo.transactiondetails AS a\n    -&gt; WHERE a.salesvalue &gt; 50;\n+---------------+------------+----------+-------+------------+\n| transactionid | itemnumber | quantity | price | salesvalue |\n+---------------+------------+----------+-------+------------+\n|             1 |          1 |    1.000 | 89.00 |      89.00 |\n|             2 |          1 |    2.000 | 89.00 |     178.00 |\n+---------------+------------+----------+-------+------------+\n2 rows in set (0.00 sec)\n</code></pre><p>为了获取到销售信息所对应的商品名称，我们需要通过公共字段“itemnumber”与数据表demo.goodsmaster进行关联，从demo.goodsmaster中获取商品名称：</p><pre><code>mysql&gt; SELECT\n    -&gt;     a.*, b.goodsname\n    -&gt; FROM\n    -&gt;     demo.transactiondetails a\n    -&gt;         JOIN\n    -&gt;     demo.goodsmaster b ON (a.itemnumber = b.itemnumber)\n    -&gt; WHERE\n    -&gt;     a.salesvalue &gt; 50;\n+---------------+------------+----------+-------+------------+-----------+\n| transactionid | itemnumber | quantity | price | salesvalue | goodsname |\n+---------------+------------+----------+-------+------------+-----------+\n|             1 |          1 |    1.000 | 89.00 |      89.00 | 书        |\n|             2 |          1 |    2.000 | 89.00 |     178.00 | 书        |\n+---------------+------------+----------+-------+------------+-----------+\n2 rows in set (0.00 sec)\n</code></pre><p>这个时候，如果查询商品名称，就会出现两个重复的记录：</p><pre><code>mysql&gt; SELECT\n    -&gt;     b.goodsname\n    -&gt; FROM\n    -&gt;     demo.transactiondetails AS a\n    -&gt;         JOIN\n    -&gt;     demo.goodsmaster AS b ON (a.itemnumber = b.itemnumber)\n    -&gt; WHERE\n    -&gt;     a.salesvalue &gt; 50;\n+-----------+\n| goodsname |\n+-----------+\n| 书        |\n| 书        |\n+-----------+\n2 rows in set (0.00 sec)\n</code></pre><p>需要注意的是，为了消除重复的语句，这里我们需要用到一个关键字：DISTINCT，它的作用是返回唯一不同的值。比如，DISTINCT 字段1，就表示返回所有字段1的不同的值。</p><p>下面我们尝试一下加上DISTINCT关键字的查询：</p><pre><code>mysql&gt; SELECT\n    -&gt;     DISTINCT(b.goodsname)  -- 返回唯一不同的值\n    -&gt; FROM\n    -&gt;     demo.transactiondetails AS a\n    -&gt;         JOIN\n    -&gt;     demo.goodsmaster AS b ON (a.itemnumber = b.itemnumber)\n    -&gt; WHERE\n    -&gt;     a.salesvalue &gt; 50;\n+-----------+\n| goodsname |\n+-----------+\n| 书        |\n+-----------+\n1 row in set (0.00 sec)\n</code></pre><p>这样，我们就得到了需要的结果：单笔销售金额超过50元的商品就是“书”。</p><p>总之，WHERE关键字的特点是，直接用表的字段对数据集进行筛选。如果需要通过关联查询从其他的表获取需要的信息，那么执行的时候，也是先通过WHERE条件进行筛选，用筛选后的比较小的数据集进行连接。这样一来，连接过程中占用的资源比较少，执行效率也比较高。</p><h2>HAVING</h2><p>讲完了WHERE，我们再说说HAVING是如何执行的。不过，在这之前，我要先给你介绍一下GROUP BY，因为HAVING不能单独使用，必须要跟GROUP BY一起使用。</p><p>我们可以把GROUP BY理解成对数据进行分组，方便我们对组内的数据进行统计计算。</p><p>下面我举个小例子，具体讲一讲GROUP BY如何使用，以及如何在分组里面进行统计计算。</p><p>假设现在有一组销售数据，我们需要从里面查询每天、每个收银员的销售数量和销售金额。我们通过下面的代码，来查看一下数据的内容：</p><pre><code>mysql&gt; SELECT *\n    -&gt; FROM demo.transactionhead;\n+---------------+------------------+------------+---------------------+\n| transactionid | transactionno    | operatorid | transdate           |\n+---------------+------------------+------------+---------------------+\n|             1 | 0120201201000001 |          1 | 2020-12-10 00:00:00 |\n|             2 | 0120201202000001 |          2 | 2020-12-11 00:00:00 |\n|             3 | 0120201202000002 |          2 | 2020-12-12 00:00:00 |\n+---------------+------------------+------------+---------------------+\n3 rows in set (0.00 sec)\n\nmysql&gt; SELECT *\n    -&gt; FROM demo.transactiondetails;\n+---------------+------------+----------+-------+------------+\n| transactionid | itemnumber | quantity | price | salesvalue |\n+---------------+------------+----------+-------+------------+\n|             1 |          1 |    1.000 | 89.00 |      89.00 |\n|             1 |          2 |    2.000 |  5.00 |      10.00 |\n|             2 |          1 |    2.000 | 89.00 |     178.00 |\n|             3 |          2 |   10.000 |  5.00 |      50.00 |\n+---------------+------------+----------+-------+------------+\n4 rows in set (0.01 sec)\n\nmysql&gt; SELECT *\n    -&gt; FROM demo.operator;\n+------------+----------+--------+--------------+-------------+---------+--------------------+--------+\n| operatorid | branchid | workno | operatorname | phone       | address | pid                | duty   |\n+------------+----------+--------+--------------+-------------+---------+--------------------+--------+\n|          1 |        1 | 001    | 张静         | 18612345678 | 北京    | 110392197501012332 | 店长   |\n|          2 |        1 | 002    | 李强         | 13312345678 | 北京    | 110222199501012332 | 收银员 |\n+------------+----------+--------+--------------+-------------+---------+--------------------+--------+\n2 rows in set (0.01 sec)\n\nmysql&gt; SELECT\n    -&gt; a.transdate,   -- 交易时间\n    -&gt; c.operatorname,-- 操作员\n    -&gt; d.goodsname,   -- 商品名称\n    -&gt; b.quantity,    -- 销售数量\n    -&gt; b.price,       -- 价格\n    -&gt; b.salesvalue   -- 销售金额\n    -&gt; FROM\n    -&gt;   demo.transactionhead AS a\n    -&gt; JOIN\n    -&gt;   demo.transactiondetails AS b ON (a.transactionid = b.transactionid)\n    -&gt; JOIN\n    -&gt;  demo.operator AS c ON (a.operatorid = c.operatorid)\n    -&gt; JOIN\n    -&gt;  demo.goodsmaster AS d ON (b.itemnumber = d.itemnumber);\n+---------------------+--------------+-----------+----------+-------+------------+\n| transdate           | operatorname | goodsname | quantity | price | salesvalue |\n+---------------------+--------------+-----------+----------+-------+------------+\n| 2020-12-10 00:00:00 | 张静         | 书        |    1.000 | 89.00 |      89.00 |\n| 2020-12-10 00:00:00 | 张静         | 笔        |    2.000 |  5.00 |      10.00 |\n| 2020-12-11 00:00:00 | 李强         | 书        |    2.000 | 89.00 |     178.00 |\n| 2020-12-12 00:00:00 | 李强         | 笔        |   10.000 |  5.00 |      50.00 |\n+---------------------+--------------+-----------+----------+-------+------------+\n4 rows in set (0.00 sec)\n</code></pre><p>如果我想看看每天的销售数量和销售金额，可以按照一个字段“transdate”对数据进行分组和统计：</p><pre><code>mysql&gt; SELECT\n    -&gt; a.transdate,\n    -&gt; SUM(b.quantity), -- 统计分组的总计销售数量\n    -&gt; SUM(b.salesvalue) -- 统计分组的总计销售金额\n    -&gt; FROM\n    -&gt;   demo.transactionhead AS a\n    -&gt; JOIN\n    -&gt; demo.transactiondetails AS b ON (a.transactionid = b.transactionid)\n    -&gt; GROUP BY a.transdate;\n+---------------------+-----------------+-------------------+\n| transdate           | SUM(b.quantity) | SUM(b.salesvalue) |\n+---------------------+-----------------+-------------------+\n| 2020-12-10 00:00:00 |           3.000 |             99.00 |\n| 2020-12-11 00:00:00 |           2.000 |            178.00 |\n| 2020-12-12 00:00:00 |          10.000 |             50.00 |\n+---------------------+-----------------+-------------------+\n3 rows in set (0.00 sec)\n</code></pre><p>如果我想看每天、每个收银员的销售数量和销售金额，就可以按2个字段进行分组和统计，分别是“transdate”和“operatorname”：</p><pre><code>mysql&gt;  SELECT\n    -&gt;     a.transdate,\n    -&gt;     c.operatorname,\n    -&gt;     SUM(b.quantity), -- 数量求和\n    -&gt;     SUM(b.salesvalue)-- 金额求和\n    -&gt; FROM\n    -&gt;     demo.transactionhead AS a\n    -&gt;         JOIN\n    -&gt;     demo.transactiondetails AS b ON (a.transactionid = b.transactionid)\n    -&gt;         JOIN\n    -&gt;     demo.operator AS C ON (a.operatorid = c.operatorid)\n    -&gt; GROUP BY a.transdate , c.operatorname; -- 按照交易日期和操作员分组\n+---------------------+--------------+-----------------+-------------------+\n| transdate           | operatorname | SUM(b.quantity) | SUM(b.salesvalue) |\n+---------------------+--------------+-----------------+-------------------+\n| 2020-12-10 00:00:00 | 张静         |           3.000 |             99.00 |\n| 2020-12-11 00:00:00 | 李强         |           2.000 |            178.00 |\n| 2020-12-12 00:00:00 | 李强         |          10.000 |             50.00 |\n+---------------------+--------------+-----------------+-------------------+\n3 rows in set (0.00 sec)\n</code></pre><p>可以看到，通过对销售数据按照交易日期和收银员进行分组，再对组内数据进行求和统计，就实现了对每天、每个收银员的销售数量和销售金额的查询。</p><p>好了，知道了GROUP BY的使用方法，我们就来学习下HAVING。</p><p>回到开头的超市经营者的需求：查询单笔销售金额超过50元的商品。现在我们来使用HAVING来实现，代码如下：</p><pre><code>mysql&gt; SELECT b.goodsname\n    -&gt; FROM demo.transactiondetails AS a\n    -&gt; JOIN demo.goodsmaster AS b\n    -&gt; ON (a.itemnumber=b.itemnumber)\n    -&gt; GROUP BY b.goodsname\n    -&gt; HAVING max(a.salesvalue)&gt;50;\n+-----------+\n| goodsname |\n+-----------+\n| 书        |\n+-----------+\n1 row in set (0.00 sec)\n</code></pre><p>这种查询方式在MySQL里面是分四步实现的。</p><p>第一步，把流水明细表和商品信息表通过公共字段“itemnumber”连接起来，从2个表中获取数据：</p><pre><code>mysql&gt; SELECT\n    -&gt;     a.*, b.*\n    -&gt; FROM\n    -&gt;     demo.transactiondetails a\n    -&gt;         JOIN\n    -&gt;     demo.goodsmaster b ON (a.itemnumber = b.itemnumber);\n+---------------+------------+----------+-------+------------+------------+---------+-----------+---------------+------+------------+\n| transactionid | itemnumber | quantity | price | salesvalue | itemnumber | barcode | goodsname | specification | unit | salesprice |\n+---------------+------------+----------+-------+------------+------------+---------+-----------+---------------+------+------------+\n|             1 |          1 |    1.000 | 89.00 |      89.00 |          1 | 0001    | 书        | NULL          | 本   |      89.00 |\n|             1 |          2 |    2.000 |  5.00 |      10.00 |          2 | 0002    | 笔        | NULL          | 支   |       5.00 |\n|             2 |          1 |    2.000 | 89.00 |     178.00 |          1 | 0001    | 书        | NULL          | 本   |      89.00 |\n|             3 |          2 |   10.000 |  5.00 |      50.00 |          2 | 0002    | 笔        | NULL          | 支   |       5.00 |\n+---------------+------------+----------+-------+------------+------------+---------+-----------+---------------+------+------------+\n4 rows in set (0.00 sec)\n</code></pre><p>查询的结果有点复杂，为了方便你理解，我对结果进行了分类，并加了注释，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/5a/33/5a65e30972010a72576d4008fb0b9333.jpg?wh=7250*2895\" alt=\"\"></p><p>第二步，把结果集按照商品名称分组，分组的示意图如下所示：</p><p>组1：</p><p><img src=\"https://static001.geekbang.org/resource/image/23/10/239766d1849b25d03049be4f21c95510.jpg?wh=7988*2525\" alt=\"\"></p><p>组2：</p><p><img src=\"https://static001.geekbang.org/resource/image/2d/ca/2d4b2fec2c3b84a25928f21353727eca.jpeg?wh=1914*500\" alt=\"\"></p><p>第三步，对分组后的数据集进行筛选，把组中字段“salesvalue”的最大值&gt;50的组筛选出来。筛选后的结果集如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/96/a6/96bdae61f5924a9118071294cab86ba6.jpeg?wh=1805*332\" alt=\"\"></p><p>第四步，返回商品名称。这时，我们就得到了需要的结果：单笔销售金额超过50元的商品就是“书”。</p><p>现在我们来简单小结下使用HAVING的查询过程。首先，我们要把所有的信息都准备好，包括从关联表中获取需要的信息，对数据集进行分组，形成一个包含所有需要的信息的数据集合。接着，再通过HAVING条件的筛选，得到需要的数据。</p><h2>怎么正确地使用WHERE和HAVING？</h2><p>现在，你已经知道了WHERE和HAVING的具体使用方法。那么，在查询时，我们怎样才能正确地使用它们呢？</p><p>首先，你要知道它们的2个典型区别。</p><p>第一个区别是，<strong>如果需要通过连接从关联表中获取需要的数据，WHERE是先筛选后连接，而HAVING是先连接后筛选</strong>。</p><p>这一点，就决定了在关联查询中，WHERE比HAVING更高效。因为WHERE可以先筛选，用一个筛选后的较小数据集和关联表进行连接，这样占用的资源比较少，执行效率也就比较高。HAVING则需要先把结果集准备好，也就是用未被筛选的数据集进行关联，然后对这个大的数据集进行筛选，这样占用的资源就比较多，执行效率也较低。</p><p>第二个区别是，WHERE可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件；HAVING必须要与GROUP BY配合使用，可以把分组计算的函数和分组字段作为筛选条件。</p><p>这决定了，<strong>在需要对数据进行分组统计的时候，HAVING可以完成WHERE不能完成的任务</strong>。这是因为，在查询语法结构中，WHERE在GROUP BY之前，所以无法对分组结果进行筛选。HAVING在GROUP BY之后，可以使用分组字段和分组中的计算函数，对分组的结果集进行筛选，这个功能是WHERE无法完成的。</p><p>这么说你可能不太好理解，我来举个小例子。假如超市经营者提出，要查询一下是哪个收银员、在哪天卖了2单商品。这种必须先分组才能筛选的查询，用WHERE语句实现就比较难，我们可能要分好几步，通过把中间结果存储起来，才能搞定。但是用HAVING，则很轻松，代码如下：</p><pre><code>mysql&gt; SELECT\n    -&gt;   a.transdate, c.operatorname\n    -&gt; FROM\n    -&gt;   demo.transactionhead AS a\n    -&gt; JOIN\n    -&gt;   demo.transactiondetails AS b ON (a.transactionid = b.transactionid)\n    -&gt; JOIN\n    -&gt;   demo.operator AS c ON (a.operatorid = c.operatorid)\n    -&gt; GROUP BY a.transdate,c.operatorname\n    -&gt; HAVING count(*)=2;  -- 销售了2单\n+---------------------+--------------+\n| transdate           | operatorname |\n+---------------------+--------------+\n| 2020-12-10 00:00:00 | 张静         |\n+---------------------+--------------+\n1 row in set (0.01 sec)\n</code></pre><p>我汇总了WHERE和HAVING各自的优缺点，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/24/50/2423421554df9a7dfd15495beb850150.jpg?wh=3250*1449\" alt=\"\"></p><p>不过，需要注意的是，WHERE和HAVING也不是互相排斥的，我们可以在一个查询里面同时使用WHERE和HAVING。</p><p>举个例子，假设现在我们有一组销售数据，包括交易时间、收银员、商品名称、销售数量、价格和销售金额等信息，超市的经营者要查询“2020-12-10”和“2020-12-11”这两天收银金额超过100元的销售日期、收银员名称、销售数量和销售金额。</p><pre><code>mysql&gt; SELECT\n    -&gt;     a.transdate,\n    -&gt;    c.operatorname,\n    -&gt;     d.goodsname,\n    -&gt;     b.quantity,\n    -&gt;     b.price,\n    -&gt;     b.salesvalue\n    -&gt; FROM\n    -&gt;     demo.transactionhead AS a\n    -&gt;         JOIN\n    -&gt;     demo.transactiondetails AS b ON (a.transactionid = b.transactionid)\n    -&gt;        JOIN\n    -&gt;     demo.operator AS c ON (a.operatorid = c.operatorid)\n    -&gt;        JOIN\n    -&gt;    demo.goodsmaster as d on (b.itemnumber=d.itemnumber);\n+---------------------+--------------+-----------+----------+-------+------------+\n| transdate           | operatorname | goodsname | quantity | price | salesvalue |\n+---------------------+--------------+-----------+----------+-------+------------+\n| 2020-12-10 00:00:00 | 张静         | 书        |    1.000 | 89.00 |      89.00 |\n| 2020-12-10 00:00:00 | 张静         | 笔        |    2.000 |  5.00 |      10.00 |\n| 2020-12-11 00:00:00 | 李强         | 书        |    2.000 | 89.00 |     178.00 |\n| 2020-12-12 00:00:00 | 李强         | 笔        |   10.000 |  5.00 |      50.00 |\n+---------------------+--------------+-----------+----------+-------+------------+\n4 rows in set (0.00 sec)\n</code></pre><p>我们来分析一下这个需求：由于是要按照销售日期和收银员进行统计，所以，必须按照销售日期和收银员进行分组，因此，我们可以通过使用GROUP BY和HAVING进行查询：</p><pre><code>mysql&gt; SELECT\n    -&gt;     a.transdate,\n    -&gt;     c.operatorname,\n    -&gt;     SUM(b.quantity), -- 销售数量求和\n    -&gt;     SUM(b.salesvalue)-- 销售金额求和\n    -&gt; FROM\n    -&gt;     demo.transactionhead AS a\n    -&gt;         JOIN\n    -&gt;     demo.transactiondetails AS b ON (a.transactionid = b.transactionid)\n    -&gt;         JOIN\n    -&gt;     demo.operator AS c ON (a.operatorid = c.operatorid)\n    -&gt; GROUP BY a.transdate , operatorname  -- 按照日期、收银员分组\n    -&gt; HAVING a.transdate IN ('2020-12-10' , '2020-12-11')\n    -&gt;     AND SUM(b.salesvalue) &gt; 100;   -- 最后筛选数据\n+---------------------+--------------+-----------------+-------------------+\n| transdate           | operatorname | SUM(b.quantity) | SUM(b.salesvalue) |\n+---------------------+--------------+-----------------+-------------------+\n| 2020-12-11 00:00:00 | 李强         |           2.000 |            178.00 |\n+---------------------+--------------+-----------------+-------------------+\n1 row in set (0.00 sec) \n</code></pre><p>如果你仔细看HAVING后面的筛选条件，就会发现，条件a.transdate IN ('2020-12-10' , '2020-12-11')，其实可以用WHERE来限定。我们把查询改一下试试：</p><pre><code> mysql&gt; SELECT\n    -&gt;     a.transdate,\n    -&gt;     c.operatorname,\n    -&gt;     SUM(b.quantity),\n    -&gt;     SUM(b.salesvalue)\n    -&gt; FROM\n    -&gt;     demo.transactionhead AS a\n    -&gt;         JOIN\n    -&gt;     demo.transactiondetails AS b ON (a.transactionid = b.transactionid)\n    -&gt;         JOIN\n    -&gt;     demo.operator AS c ON (a.operatorid = c.operatorid)\n    -&gt; WHERE a.transdate in ('2020-12-12','2020-12-11') -- 先按日期筛选\n    -&gt; GROUP BY a.transdate , operatorname\n    -&gt; HAVING SUM(b.salesvalue)&gt;100;  -- 后按金额筛选\n+---------------------+--------------+-----------------+-------------------+\n| transdate           | operatorname | SUM(b.quantity) | SUM(b.salesvalue) |\n+---------------------+--------------+-----------------+-------------------+\n| 2020-12-11 00:00:00 | 李强         |           2.000 |            178.00 |\n+---------------------+--------------+-----------------+-------------------+\n1 row in set (0.00 sec)\n</code></pre><p>很显然，我们同样得到了需要的结果。这是因为我们把条件拆分开，包含分组统计函数的条件用HAVING，普通条件用WHERE。这样，我们就既利用了WHERE条件的高效快速，又发挥了HAVING可以使用包含分组统计函数的查询条件的优点。当数据量特别大的时候，运行效率会有很大的差别。</p><h2>总结</h2><p>今天，我给你介绍了条件语句WHERE和HAVING在MySQL中的执行原理。WHERE可以先按照条件对数据进行筛选，然后进行数据连接，所以效率更高。HAVING可以在分组之后，通过使用分组中的计算函数，实现WHERE难以完成的数据筛选。</p><p>了解了WHERE和HAVING各自的特点，我们就可以在查询中，充分利用它们的优势，更高效地实现我们的查询目标。</p><p>最后，我想提醒你的是，很多人刚开始学习MySQL的时候，不太喜欢用HAVING，一提到条件语句，就想当然地用WHERE。其实，HAVING是非常有用的，特别是在做一些复杂的统计查询的时候，经常要用到分组，这个时候HAVING就派上用场了。</p><p>当然，你也可以不用HAVING，而是把查询分成几步，把中间结果存起来，再用WHERE筛选，或者干脆把这部分筛选功能放在应用层面，用代码来实现。但是，这样做的效率很低，而且会增加工作量，加大维护成本。所以，学会使用HAVING，对你完成复杂的查询任务非常有帮助。</p><h2>思考题</h2><p>有这样一种说法：HAVING后面的条件，必须是包含分组中的计算函数的条件，你觉得对吗？为什么？</p><p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得今天的内容对你有所帮助，也欢迎你分享你的朋友或同事，我们下节课见。</p>","comments":[{"had_liked":false,"id":289325,"user_name":"朱晓峰","can_delete":false,"product_type":"c1","uid":2356905,"ip_address":"","ucode":"D2F84F44329C29","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLZKoB7sooIiaCHqcdNGI97WI3ZJLJph4mibIiat1qRvrBmkicZTEYvyT5iax1vlLFFgk2xgUibmnWvkicWA/132","comment_is_top":true,"comment_ctime":1618976975,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"9.2233720556535992e+18","product_id":100073201,"comment_content":"你好，我是朱晓峰，下面我就来公布一下上节课思考题的答案：<br><br>上节课，我们学习了如何进行多表查询。下面是思考题的答案：<br><br>如果不能使用外键约束，你可以在应用层增加确保数据完整性的功能模块，比如删除主表记录时，增加检查从表中是否应用了这条记录的功能，如果应用了，就不允许删除。","like_count":5,"discussions":[{"author":{"id":2680555,"avatar":"https://static001.geekbang.org/account/avatar/00/28/e6/eb/7b7c0101.jpg","nickname":"彭彬","note":"","ucode":"5AF4F4D7163DFE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393446,"discussion_content":"这样做还不是要查询一次数据库？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631436623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284834,"user_name":"lesserror","can_delete":false,"product_type":"c1","uid":1351076,"ip_address":"","ucode":"25A54D1165FCF6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","comment_is_top":false,"comment_ctime":1616490093,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"48861130349","product_id":100073201,"comment_content":"之前刚学习数据库的时候，也会混淆WHERE和HAVING。今天学习了这一节，又有了更加清晰地认知。<br><br>WHERE是针对数据库文件的发挥作用，而HAVING是针对结果集发挥作用。WHERE所能作用的字段条件要是数据表文件中真实存在的字段，而having只是根据前面查询出来的结果集再次进行查询。<br><br>这样看来HAVING后面不一定要是包含分组中的计算函数的条件。例如以下两条语句就是等效的：<br><br>select goods_price, goods_name from goods where goods_price &lt; 100<br><br>select goods_price, goods_name from goods having goods_price &lt; 100<br>","like_count":11,"discussions":[{"author":{"id":1067564,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4a/2c/f8451d77.jpg","nickname":"石维康","note":"","ucode":"E39ED8416B2C01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360868,"discussion_content":" HAVING 不能单独使用，必须要跟 GROUP BY 一起使用","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1616550818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1067564,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4a/2c/f8451d77.jpg","nickname":"石维康","note":"","ucode":"E39ED8416B2C01","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360871,"discussion_content":"你实际测试过？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616551388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":360868,"ip_address":""},"score":360871,"extra":""},{"author":{"id":1067564,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4a/2c/f8451d77.jpg","nickname":"石维康","note":"","ucode":"E39ED8416B2C01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361675,"discussion_content":"测试过，老师课程里也提到了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616726502,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":360871,"ip_address":""},"score":361675,"extra":""},{"author":{"id":1202379,"avatar":"https://static001.geekbang.org/account/avatar/00/12/58/cb/daf94c0e.jpg","nickname":"菜鸟🐤要先飞","note":"","ucode":"56668DB891F7BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1067564,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4a/2c/f8451d77.jpg","nickname":"石维康","note":"","ucode":"E39ED8416B2C01","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372551,"discussion_content":"难道是mysql版本问题吗？我的是8.0\nmysql> select * from goodsmaster;\n+------------+---------+-----------+---------------+------+-------+\n| itemnumber | barcode | goodsname | specification | unit | price |\n+------------+---------+-----------+---------------+------+-------+\n|          1 | 123     | 123       | 123           | 123  | 13.45 |\n|          9 | 0003    | 尺子1     | NULL          | 支   | 15.00 |\n|         10 | 0004    | 测试1     | NULL          | 支   | 20.00 |\n|         11 | 0003    | 尺子1     | NULL          | 支   | 15.00 |\n|         12 | 0004    | 测试1     | NULL          | 本   | 20.00 |\n|         13 | 0003    | 尺子2     | NULL          | 本   | 39.00 |\n|         14 | 0004    | 测试32    | NULL          | 本   | 29.00 |\n+------------+---------+-----------+---------------+------+-------+\n7 rows in set (0.00 sec)\nmysql> select * from goodsmaster having price>20;\n+------------+---------+-----------+---------------+------+-------+\n| itemnumber | barcode | goodsname | specification | unit | price |\n+------------+---------+-----------+---------------+------+-------+\n|         13 | 0003    | 尺子2     | NULL          | 本   | 39.00 |\n|         14 | 0004    | 测试32    | NULL          | 本   | 29.00 |\n+------------+---------+-----------+---------------+------+-------+\n2 rows in set (0.00 sec)\n\nmysql> select * from goodsmaster where price>20;\n+------------+---------+-----------+---------------+------+-------+\n| itemnumber | barcode | goodsname | specification | unit | price |\n+------------+---------+-----------+---------------+------+-------+\n|         13 | 0003    | 尺子2     | NULL          | 本   | 39.00 |\n|         14 | 0004    | 测试32    | NULL          | 本   | 29.00 |\n+------------+---------+-----------+---------------+------+-------+\n2 rows in set (0.00 sec)\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620375293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":361675,"ip_address":""},"score":372551,"extra":""}]}]},{"had_liked":false,"id":285977,"user_name":"洛奇","can_delete":false,"product_type":"c1","uid":1624355,"ip_address":"","ucode":"662B4005721119","user_header":"https://static001.geekbang.org/account/avatar/00/18/c9/23/76511858.jpg","comment_is_top":false,"comment_ctime":1617091291,"is_pvip":false,"replies":[{"id":"106118","content":"ON后面的字句是连接条件，WHERE后面的子句才是筛选条件，不一样的","user_name":"作者回复","comment_id":285977,"uid":"2356905","ip_address":"","utype":1,"ctime":1621247852,"user_name_real":"朱晓峰"}],"discussion_count":3,"race_medal":0,"score":"27386895067","product_id":100073201,"comment_content":"筛选条件放在ON或者WHERE子句中，都是一样的吧？","like_count":6,"discussions":[{"author":{"id":2571552,"avatar":"https://static001.geekbang.org/account/avatar/00/27/3d/20/c17a361c.jpg","nickname":"a   绅士      🚬","note":"","ucode":"832DEE61A381D8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369050,"discussion_content":"sql执行顺序是先ON后where","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1618912488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2356905,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLZKoB7sooIiaCHqcdNGI97WI3ZJLJph4mibIiat1qRvrBmkicZTEYvyT5iax1vlLFFgk2xgUibmnWvkicWA/132","nickname":"朱晓峰","note":"","ucode":"D2F84F44329C29","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517839,"discussion_content":"ON后面的字句是连接条件，WHERE后面的子句才是筛选条件，不一样的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621247852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2110718,"avatar":"https://static001.geekbang.org/account/avatar/00/20/34/fe/e5429b02.jpg","nickname":"glimmer","note":"","ucode":"48A16C52FB4C45","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2356905,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLZKoB7sooIiaCHqcdNGI97WI3ZJLJph4mibIiat1qRvrBmkicZTEYvyT5iax1vlLFFgk2xgUibmnWvkicWA/132","nickname":"朱晓峰","note":"","ucode":"D2F84F44329C29","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":567920,"discussion_content":"所以先where后on，后groupby，后having？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651028523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":517839,"ip_address":""},"score":567920,"extra":""}]}]},{"had_liked":false,"id":302373,"user_name":"青雘","can_delete":false,"product_type":"c1","uid":2687278,"ip_address":"","ucode":"29D71967CA90F0","user_header":"https://static001.geekbang.org/account/avatar/00/29/01/2e/5d3d4b86.jpg","comment_is_top":false,"comment_ctime":1626182128,"is_pvip":false,"replies":[{"id":"110394","content":"很抱歉数据包是不能提供的，可以自己动手创建数据，也是一种很好的练习","user_name":"作者回复","comment_id":302373,"uid":"2356905","ip_address":"","utype":1,"ctime":1627874082,"user_name_real":"朱晓峰"}],"discussion_count":1,"race_medal":0,"score":"14511084016","product_id":100073201,"comment_content":"有数据库的数据包吗 ？ 这咋动手 没有数据","like_count":3,"discussions":[{"author":{"id":2356905,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLZKoB7sooIiaCHqcdNGI97WI3ZJLJph4mibIiat1qRvrBmkicZTEYvyT5iax1vlLFFgk2xgUibmnWvkicWA/132","nickname":"朱晓峰","note":"","ucode":"D2F84F44329C29","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523280,"discussion_content":"很抱歉数据包是不能提供的，可以自己动手创建数据，也是一种很好的练习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627874082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284739,"user_name":"星空下","can_delete":false,"product_type":"c1","uid":1183639,"ip_address":"","ucode":"473643B567674A","user_header":"https://static001.geekbang.org/account/avatar/00/12/0f/97/372d8628.jpg","comment_is_top":false,"comment_ctime":1616457454,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10206392046","product_id":100073201,"comment_content":"having可以替代where  只是要与group by联合使用。后跟条件不一定是分组函数","like_count":2},{"had_liked":false,"id":354110,"user_name":"不管","can_delete":false,"product_type":"c1","uid":1094549,"ip_address":"北京","ucode":"49C35544E8A6D7","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/95/77f5aa52.jpg","comment_is_top":false,"comment_ctime":1660101541,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5955068837","product_id":100073201,"comment_content":"对于0基础的来说这个还是太难了","like_count":1},{"had_liked":false,"id":333467,"user_name":"SharpBB","can_delete":false,"product_type":"c1","uid":2014573,"ip_address":"","ucode":"D30C5B798B8E8C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/bd/6d/7010f98e.jpg","comment_is_top":false,"comment_ctime":1644375522,"is_pvip":true,"replies":[{"id":"123486","content":"好的","user_name":"作者回复","comment_id":333467,"uid":"2356905","ip_address":"","utype":1,"ctime":1647075310,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"5939342818","product_id":100073201,"comment_content":"WHERE<br>\t直接用表字段对数据集进行筛选 得到较少的数据集 再进行连接 资源占用少 执行效率高<br>HAVING<br>\t需要将数据准备好 并进行分组形成集合 再对该集合进行having条件的筛选<br>两者区别<br>\t1.where先筛选后连接 having先连接后筛选 where的效率更高<br>\t2.where可以直接用 而having必须和group by一起用才可以<br>\t3.可以在having中用函数 但where不行 所以having可以做一些更nb的查询","like_count":1,"discussions":[{"author":{"id":2356905,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLZKoB7sooIiaCHqcdNGI97WI3ZJLJph4mibIiat1qRvrBmkicZTEYvyT5iax1vlLFFgk2xgUibmnWvkicWA/132","nickname":"朱晓峰","note":"","ucode":"D2F84F44329C29","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555799,"discussion_content":"好的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647075310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358247,"user_name":"曙光","can_delete":false,"product_type":"c1","uid":1476450,"ip_address":"江西","ucode":"04D65BF7F19845","user_header":"https://static001.geekbang.org/account/avatar/00/16/87/62/f99b5b05.jpg","comment_is_top":false,"comment_ctime":1664112932,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664112932","product_id":100073201,"comment_content":"“单笔销售金额超过 50 元的商品”，感觉有歧义，一笔销售金额有两个商品，且相加大于50，如果max(a.salesvalue)&gt;50，会丢失“书”这个商品。<br>老师用GROUP BY b.goodsname做分组，用max查结果，我的理解是，”查不同类型的商品，且价格有超过50&quot;","like_count":0},{"had_liked":false,"id":343118,"user_name":"me","can_delete":false,"product_type":"c1","uid":2662659,"ip_address":"","ucode":"205E44AFEDFFFC","user_header":"https://static001.geekbang.org/account/avatar/00/28/a1/03/dff6bc2f.jpg","comment_is_top":false,"comment_ctime":1650639362,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650639362","product_id":100073201,"comment_content":"SQL逻辑查询语句执行顺序 <br>不应该是连表后再where嘛？ （下方是执行顺序）<br>SELECT DISTINCT &lt;select_list&gt;<br>FROM &lt;left_table&gt;<br>&lt;join_type&gt; JOIN &lt;right_table&gt;<br>ON &lt;join_condition&gt;<br>WHERE &lt;where_condition&gt;<br>GROUP BY &lt;group_by_list&gt;<br>HAVING &lt;having_condition&gt;<br>ORDER BY &lt;order_by_condition&gt;<br>LIMIT &lt;limit_number&gt;","like_count":0},{"had_liked":false,"id":334443,"user_name":"七月的雨","can_delete":false,"product_type":"c1","uid":2839126,"ip_address":"","ucode":"7B3829576985D4","user_header":"https://static001.geekbang.org/account/avatar/00/2b/52/56/6ac8be3c.jpg","comment_is_top":false,"comment_ctime":1644939044,"is_pvip":false,"replies":[{"id":"123501","content":"group by是对数据进行分组，having则是对结果集进行限定，建议再复习一下课程中的相关内容","user_name":"作者回复","comment_id":334443,"uid":"2356905","ip_address":"","utype":1,"ctime":1647076021,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1644939044","product_id":100073201,"comment_content":"group by不是很理解，和having配合在一起使用有点懵了。","like_count":0,"discussions":[{"author":{"id":2356905,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLZKoB7sooIiaCHqcdNGI97WI3ZJLJph4mibIiat1qRvrBmkicZTEYvyT5iax1vlLFFgk2xgUibmnWvkicWA/132","nickname":"朱晓峰","note":"","ucode":"D2F84F44329C29","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555817,"discussion_content":"group by是对数据进行分组，having则是对结果集进行限定，建议再复习一下课程中的相关内容","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647076021,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317690,"user_name":"Bird","can_delete":false,"product_type":"c1","uid":1379704,"ip_address":"","ucode":"D79AA5BA747890","user_header":"https://static001.geekbang.org/account/avatar/00/15/0d/78/aa5f920d.jpg","comment_is_top":false,"comment_ctime":1634891267,"is_pvip":false,"replies":[{"id":"116468","content":"这里用max()的主要目的是，消除结果集中的重复记录。获得正确结果的方法不止一种，文中的查询主要是为了演示HAVING()的用法。","user_name":"作者回复","comment_id":317690,"uid":"2356905","ip_address":"","utype":1,"ctime":1636616291,"user_name_real":"朱晓峰"}],"discussion_count":3,"race_medal":0,"score":"1634891267","product_id":100073201,"comment_content":"老师您好，用 HAVING 查询单笔超过 50 元商品的 SQL 中，用到了 HAVING max(a.salesvalue)&gt;50<br><br>这个 max() 我不太理解，是指在分组后对每个组中的 salesvalue 取最大值再和 50 比较吗？<br><br>这块不明白导致后面原文说的“第三步，对分组后的数据集进行筛选，把组中字段“salesvalue”的最大值 &gt;50 的组筛选出来。”就更不明白了。<br><br>我的疑问是，需求是找到比 50 大的就好，不理解这里为什么用到求最大值。求的是哪些数据范围的最大值呢？","like_count":0,"discussions":[{"author":{"id":2356905,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLZKoB7sooIiaCHqcdNGI97WI3ZJLJph4mibIiat1qRvrBmkicZTEYvyT5iax1vlLFFgk2xgUibmnWvkicWA/132","nickname":"朱晓峰","note":"","ucode":"D2F84F44329C29","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528932,"discussion_content":"这里用max()的主要目的是，消除结果集中的重复记录。获得正确结果的方法不止一种，文中的查询主要是为了演示HAVING()的用法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636616291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1217329,"avatar":"https://static001.geekbang.org/account/avatar/00/12/93/31/abb7bfe3.jpg","nickname":"picoasis","note":"","ucode":"D5113416FF2B14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2356905,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLZKoB7sooIiaCHqcdNGI97WI3ZJLJph4mibIiat1qRvrBmkicZTEYvyT5iax1vlLFFgk2xgUibmnWvkicWA/132","nickname":"朱晓峰","note":"","ucode":"D2F84F44329C29","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":531036,"discussion_content":"1. 联系前面的distinct，只是为了防止重复的话也可以用DISTINCT来替代。\n2. 那么想到了执行效率问题。搜到一篇文章(https://www.cnblogs.com/liliuguang/p/12580249.html)说group by比distinct效率高一些。\n3. 但是在这个示例中 是用的（distinct +where） vs （group by+having ），where又比group by效率高一些，那么该如何判断这两个方案的效率呢？\n类似情况该依赖什么依据进行选择呢？\n\n下面是两个方案的代码：\n-- 方案1 ：distinct+where\nselect DISTINCT b.goodsname\nfrom transactiondetails as a \njoin  goodsmaster as b \non a.itemnumber = b.itemnumber\nwhere a.salesvalue&gt;50;\n\n-- 方案2  group by \nselect b.goodsname\nfrom transactiondetails as a \njoin  goodsmaster as b \non a.itemnumber = b.itemnumber\ngroup by b.goodsname\nhaving max(a.salesvalue)&gt;50;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637209412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":528932,"ip_address":""},"score":531036,"extra":"{\"user_type\":1}"}]},{"author":{"id":1217329,"avatar":"https://static001.geekbang.org/account/avatar/00/12/93/31/abb7bfe3.jpg","nickname":"picoasis","note":"","ucode":"D5113416FF2B14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531032,"discussion_content":"我尝试了不加max 直接 having a.salesvalue&gt;50,会报错。\n搜了一下，说是having后面要跟聚合函数——因为——having 的功能本来就是对 group by 分组后的数据进行第二次筛选的，所以 只能是一个聚合函数，否则会产生1对n的错误。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637208310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311738,"user_name":"彭彬","can_delete":false,"product_type":"c1","uid":2680555,"ip_address":"","ucode":"5AF4F4D7163DFE","user_header":"https://static001.geekbang.org/account/avatar/00/28/e6/eb/7b7c0101.jpg","comment_is_top":false,"comment_ctime":1631436538,"is_pvip":false,"replies":[{"id":"113749","content":"请参考思考题答案","user_name":"作者回复","comment_id":311738,"uid":"2356905","ip_address":"","utype":1,"ctime":1632799029,"user_name_real":"朱晓峰"}],"discussion_count":1,"race_medal":0,"score":"1631436538","product_id":100073201,"comment_content":"HAVING 后面的条件，必须是包含分组中的计算函数的条件，或者select后面的字段","like_count":0,"discussions":[{"author":{"id":2356905,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLZKoB7sooIiaCHqcdNGI97WI3ZJLJph4mibIiat1qRvrBmkicZTEYvyT5iax1vlLFFgk2xgUibmnWvkicWA/132","nickname":"朱晓峰","note":"","ucode":"D2F84F44329C29","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526725,"discussion_content":"请参考思考题答案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632799029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":302090,"user_name":"hello","can_delete":false,"product_type":"c1","uid":2369641,"ip_address":"","ucode":"1348364A1A38F1","user_header":"https://static001.geekbang.org/account/avatar/00/24/28/69/b013f07d.jpg","comment_is_top":false,"comment_ctime":1626075094,"is_pvip":false,"replies":[{"id":"113723","content":"mysql优化器在制定查询计划的时候，会对查询进行优化，比如重写查询语句，目的是提高查询的速度效率，不会机械按照固定的顺序执行。","user_name":"作者回复","comment_id":302090,"uid":"2356905","ip_address":"","utype":1,"ctime":1632796812,"user_name_real":"朱晓峰"}],"discussion_count":1,"race_medal":0,"score":"1626075094","product_id":100073201,"comment_content":"sql语句的执行顺序，不是先执行join 再执行where吗？老师在提到where优点的时候说where的优点是先筛选在关联。这里似乎跟sql执行的顺序有了矛盾呢","like_count":0,"discussions":[{"author":{"id":2356905,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLZKoB7sooIiaCHqcdNGI97WI3ZJLJph4mibIiat1qRvrBmkicZTEYvyT5iax1vlLFFgk2xgUibmnWvkicWA/132","nickname":"朱晓峰","note":"","ucode":"D2F84F44329C29","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523177,"discussion_content":"mysql优化器在制定查询计划的时候，会对查询进行优化，比如重写查询语句，目的是提高查询的速度效率，不会机械按照固定的顺序执行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632796812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300177,"user_name":"born","can_delete":false,"product_type":"c1","uid":1164840,"ip_address":"","ucode":"3F097B2EE52478","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLzJr3dmr96ULaeQQJrslQcSZfH8fwPug8q42Y69q0daYarUbx1b0U1iadjcTtOmUicDnlx968SLLkw/132","comment_is_top":false,"comment_ctime":1625035711,"is_pvip":false,"replies":[{"id":"109151","content":"是的，由于2条记录的商品名称相同，用商品名称来分组，结果就是一条数据，如果分组中加上销售金额，就是2条数据了","user_name":"作者回复","comment_id":300177,"uid":"2356905","ip_address":"","utype":1,"ctime":1625718637,"user_name_real":"朱晓峰"}],"discussion_count":1,"race_medal":0,"score":"1625035711","product_id":100073201,"comment_content":"在“查询单笔销售金额超过 50 元的商品”例子中的第三步，GROUP BY只用goodsname字段结果只返回了组中的第一条数据，想要返回图示中的两条数据还要添加另外的字段吧","like_count":0,"discussions":[{"author":{"id":2356905,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLZKoB7sooIiaCHqcdNGI97WI3ZJLJph4mibIiat1qRvrBmkicZTEYvyT5iax1vlLFFgk2xgUibmnWvkicWA/132","nickname":"朱晓峰","note":"","ucode":"D2F84F44329C29","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522667,"discussion_content":"是的，由于2条记录的商品名称相同，用商品名称来分组，结果就是一条数据，如果分组中加上销售金额，就是2条数据了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625718637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":293757,"user_name":"沈康","can_delete":false,"product_type":"c1","uid":1611025,"ip_address":"","ucode":"02AFA50738AB8E","user_header":"https://static001.geekbang.org/account/avatar/00/18/95/11/eb431e52.jpg","comment_is_top":false,"comment_ctime":1621522465,"is_pvip":false,"replies":[{"id":"106555","content":"请参考思考题答案","user_name":"作者回复","comment_id":293757,"uid":"2356905","ip_address":"","utype":1,"ctime":1621569897,"user_name_real":"朱晓峰"}],"discussion_count":1,"race_medal":0,"score":"1621522465","product_id":100073201,"comment_content":"有这样一种说法：HAVING 后面的条件，必须是包含分组中的计算函数的条件，你觉得对吗？为什么？<br><br>我认为是对的，既然 having是在group之后的筛选，那么只能选择group的计算函数","like_count":0,"discussions":[{"author":{"id":2356905,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLZKoB7sooIiaCHqcdNGI97WI3ZJLJph4mibIiat1qRvrBmkicZTEYvyT5iax1vlLFFgk2xgUibmnWvkicWA/132","nickname":"朱晓峰","note":"","ucode":"D2F84F44329C29","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520343,"discussion_content":"请参考思考题答案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621569897,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":285975,"user_name":"洛奇","can_delete":false,"product_type":"c1","uid":1624355,"ip_address":"","ucode":"662B4005721119","user_header":"https://static001.geekbang.org/account/avatar/00/18/c9/23/76511858.jpg","comment_is_top":false,"comment_ctime":1617090712,"is_pvip":false,"replies":[{"id":"106117","content":"不会的，HAVING后面的SUM(b.salesvalue)用于数据筛选，与SELECT里面的SUM(b.salesvalue)作用不同，不可以合并","user_name":"作者回复","comment_id":285975,"uid":"2356905","ip_address":"","utype":1,"ctime":1621247779,"user_name_real":"朱晓峰"}],"discussion_count":1,"race_medal":0,"score":"1617090712","product_id":100073201,"comment_content":"本文中最后一条SQL的两处SUM(b.salesvalue)是不是会重复计算？它们可以合并吗？","like_count":0,"discussions":[{"author":{"id":2356905,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLZKoB7sooIiaCHqcdNGI97WI3ZJLJph4mibIiat1qRvrBmkicZTEYvyT5iax1vlLFFgk2xgUibmnWvkicWA/132","nickname":"朱晓峰","note":"","ucode":"D2F84F44329C29","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517838,"discussion_content":"不会的，HAVING后面的SUM(b.salesvalue)用于数据筛选，与SELECT里面的SUM(b.salesvalue)作用不同，不可以合并","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621247779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}