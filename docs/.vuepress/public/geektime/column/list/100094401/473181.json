{"id":473181,"title":"33 | 编译原理（中）：Vue Compiler模块全解析","content":"<p>你好，我是大圣。</p><p>上一讲我带你手写了一个迷你的Vue compiler，还学习了编译原理的基础知识。通过实现这个迷你Vue compiler，我们知道了tokenizer可以用来做语句分析，而parse负责生成抽象语法树AST。然后我们一起分析AST中的Vue语法，最后通过generate函数生成最终的代码。</p><p>今天我就带你深入Vue的compiler源码之中，看看Vue内部到底是怎么实现的。有了上一讲编译原理的入门基础，你会对Compiler执行全流程有更深的理解。</p><h2>Vue compiler入口分析</h2><p>Vue 3内部有4个和compiler相关的包。compiler-dom和compiler-core负责实现浏览器端的编译，这两个包是我们需要深入研究的，compiler-ssr负责服务器端渲染，我们后面讲ssr的时候再研究，compiler-sfc是编译.vue单文件组件的，有兴趣的同学可以自行探索。</p><p>首先我们进入到vue-next/packages/compiler-dom/index.ts文件下，在<a href=\"https://github.com/vuejs/vue-next/blob/master/packages/compiler-dom/src/index.ts#L40\">GitHub</a>上你可以找到下面这段代码。</p><p>compiler函数有两个参数，第一个参数template，它是我们项目中的模板字符串；第二个参数options是编译的配置，内部调用了baseCompile函数。我们可以看到，这里的调用关系和runtime-dom、runtime-core的关系类似，compiler-dom负责传入浏览器Dom相关的API，实际编译的baseCompile是由compiler-core提供的。</p><!-- [[[read_end]]] --><pre><code class=\"language-javascript\">export function compile(\n  template: string,\n  options: CompilerOptions = {}\n): CodegenResult {\n  return baseCompile(\n    template,\n    extend({}, parserOptions, options, {\n      nodeTransforms: [\n        // ignore &lt;script&gt; and &lt;tag&gt;\n        // this is not put inside DOMNodeTransforms because that list is used\n        // by compiler-ssr to generate vnode fallback branches\n        ignoreSideEffectTags,\n        ...DOMNodeTransforms,\n        ...(options.nodeTransforms || [])\n      ],\n      directiveTransforms: extend(\n        {},\n        DOMDirectiveTransforms,\n        options.directiveTransforms || {}\n      ),\n      transformHoist: __BROWSER__ ? null : stringifyStatic\n    })\n  )\n}\n</code></pre><p>我们先来看看compiler-dom做了哪些额外的配置。</p><p>首先，parserOption传入了parse的配置，通过parserOption传递的isNativeTag来区分element和component。这里的实现也非常简单，把所有html的标签名存储在一个对象中，然后就可以很轻松地判断出div是浏览器自带的element。</p><p>baseCompile传递的其他参数nodeTransforms和directiveTransforms，它们做的也是和上面代码类似的事。</p><pre><code class=\"language-javascript\">\nexport const parserOptions: ParserOptions = {\n  isVoidTag,\n  isNativeTag: tag =&gt; isHTMLTag(tag) || isSVGTag(tag),\n  isPreTag: tag =&gt; tag === 'pre',\n  decodeEntities: __BROWSER__ ? decodeHtmlBrowser : decodeHtml,\n\n  isBuiltInComponent: (tag: string): symbol | undefined =&gt; {\n    if (isBuiltInType(tag, `Transition`)) {\n      return TRANSITION\n    } else if (isBuiltInType(tag, `TransitionGroup`)) {\n      return TRANSITION_GROUP\n    }\n  },\n  ...\n}\nconst HTML_TAGS =\n  'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\n  'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +\n  'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\n  'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +\n  'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\n  'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\n  'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\n  'option,output,progress,select,textarea,details,dialog,menu,' +\n  'summary,template,blockquote,iframe,tfoot'\nexport const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS)\n</code></pre><h2>Vue浏览器端编译的核心流程</h2><p>然后，我们进入到baseCompile函数中，这就是Vue浏览器端编译的核心流程。</p><p>下面的代码中可以很清楚地看到，我们先通过baseParse把传递的template解析成AST，然后通过transform函数对AST进行语义化分析，最后通过generate函数生成代码。</p><p>这个主要逻辑和我们写的迷你compiler基本一致，这些函数大概要做的事你也心中有数了。这里你也能体验到，亲手实现一个迷你版本对我们阅读源码很有帮助。</p><p>接下来，我们就进入到这几个函数之中去，看一下跟迷你compiler里的实现相比，我们到底做了哪些优化。</p><pre><code class=\"language-javascript\">export function baseCompile(\n  template: string | RootNode,\n  options: CompilerOptions = {}\n): CodegenResult {\n  const ast = isString(template) ? baseParse(template, options) : template\n  const [nodeTransforms, directiveTransforms] =\n    getBaseTransformPreset(prefixIdentifiers)\n\n  transform(\n    ast,\n    extend({}, options, {\n      prefixIdentifiers,\n      nodeTransforms: [\n        ...nodeTransforms,\n        ...(options.nodeTransforms || []) // user transforms\n      ],\n      directiveTransforms: extend(\n        {},\n        directiveTransforms,\n        options.directiveTransforms || {} // user transforms\n      )\n    })\n  )\n  return generate(\n    ast,\n    extend({}, options, {\n      prefixIdentifiers\n    })\n  )\n}\n\n</code></pre><p>上一讲中我们体验了Vue的在线模板编译环境，可以在console中看到Vue解析得到的AST。</p><p>如下图所示，可以看到这个AST比迷你版多了很多额外的属性。<strong>loc用来描述节点对应代码的信息，component和directive用来记录代码中出现的组件和指令等等</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/0e/3f/0e264bc3ffcfa67babec3b1cf8047d3f.png?wh=1920x982\" alt=\"图片\"></p><p>然后我们进入到baseParse函数中, 这里的createParserContext和createRoot用来生成上下文，其实就是创建了一个对象，保存当前parse函数中需要共享的数据和变量，最后调用parseChildren。</p><p>children内部开始判断&lt;开头的标识符，判断开始还是闭合标签后，接着会生成一个nodes数组。其中，advanceBy函数负责更新context中的source用来向前遍历代码，最终对不同的场景执行不同的函数。</p><pre><code class=\"language-javascript\">export function baseParse(\n  content: string,\n  options: ParserOptions = {}\n): RootNode {\n  const context = createParserContext(content, options)\n  const start = getCursor(context)\n  return createRoot(\n    parseChildren(context, TextModes.DATA, []),\n    getSelection(context, start)\n  )\n}\nfunction parseChildren(\n  context: ParserContext,\n  mode: TextModes,\n  ancestors: ElementNode[]\n): TemplateChildNode[] {\n  const parent = last(ancestors)\n  // 依次生成node\n  const nodes: TemplateChildNode[] = []\n  // 如果遍历没结束\n  while (!isEnd(context, mode, ancestors)) {\n\n    const s = context.source\n    let node: TemplateChildNode | TemplateChildNode[] | undefined = undefined\n    \n    if (mode === TextModes.DATA || mode === TextModes.RCDATA) {\n      if (!context.inVPre &amp;&amp; startsWith(s, context.options.delimiters[0])) {\n        // 处理vue的变量标识符，两个大括号 '{{'\n        node = parseInterpolation(context, mode)\n      } else if (mode === TextModes.DATA &amp;&amp; s[0] === '&lt;') {\n        // 处理&lt;开头的代码，可能是&lt;div&gt;也有可能是&lt;/div&gt; 或者&lt;!的注释\n        if (s.length === 1) {\n          // 长度是1，只有一个&lt; 有问题 报错\n          emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 1)\n        } else if (s[1] === '!') {\n          // html注释\n          if (startsWith(s, '&lt;!--')) {\n            node = parseComment(context)\n          } else if (startsWith(s, '&lt;!DOCTYPE')) {\n              \n            // DOCTYPE\n            node = parseBogusComment(context)\n          }\n        } else if (s[1] === '/') {\n           //&lt;/ 开头的标签，结束标签\n          // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state\n          if (/[a-z]/i.test(s[2])) {\n            emitError(context, ErrorCodes.X_INVALID_END_TAG)\n            parseTag(context, TagType.End, parent)\n            continue\n          } \n        } else if (/[a-z]/i.test(s[1])) {\n          // 解析节点\n          node = parseElement(context, ancestors)\n          // 2.x &lt;template&gt; with no directive compat\n          node = node.children\n          }\n        }\n      }\n    }\n    if (!node) {\n      // 文本\n      node = parseText(context, mode)\n    }\n    // node树数组，遍历puish\n    if (isArray(node)) {\n      for (let i = 0; i &lt; node.length; i++) {\n        pushNode(nodes, node[i])\n      }\n    } else {\n      pushNode(nodes, node)\n    }\n  }\n\n  return removedWhitespace ? nodes.filter(Boolean) : nodes\n}\n</code></pre><p>parseInterpolation和parseText函数的逻辑比较简单。parseInterpolation负责识别变量的分隔符 {{ 和}} ，然后通过parseTextData获取变量的值，并且通过innerStart和innerEnd去记录插值的位置；parseText负责处理模板中的普通文本，主要是把文本包裹成AST对象。</p><p>接着我们看看处理节点的parseElement函数都做了什么。首先要判断pre和v-pre标签，然后通过isVoidTag判断标签是否是自闭合标签，这个函数是从compiler-dom中传来的，之后会递归调用parseChildren，接着再解析开始标签、解析子节点，最后解析结束标签。</p><pre><code class=\"language-javascript\">const VOID_TAGS =\n  'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr'\n\nexport const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS)\nfunction parseElement(\n  context: ParserContext,\n  ancestors: ElementNode[]\n): ElementNode | undefined {\n  // Start tag.\n  // 是不是pre标签和v-pre标签\n  const wasInPre = context.inPre\n  const wasInVPre = context.inVPre\n  const parent = last(ancestors)\n  // 解析标签节点\n  const element = parseTag(context, TagType.Start, parent)\n  const isPreBoundary = context.inPre &amp;&amp; !wasInPre\n  const isVPreBoundary = context.inVPre &amp;&amp; !wasInVPre\n\n  if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {\n    // #4030 self-closing &lt;pre&gt; tag\n    if (isPreBoundary) {\n      context.inPre = false\n    }\n    if (isVPreBoundary) {\n      context.inVPre = false\n    }\n    return element\n  }\n\n  // Children.\n  ancestors.push(element)\n  const mode = context.options.getTextMode(element, parent)\n  const children = parseChildren(context, mode, ancestors)\n  ancestors.pop()\n  element.children = children\n\n  // End tag.\n  if (startsWithEndTagOpen(context.source, element.tag)) {\n    parseTag(context, TagType.End, parent)\n  } else {\n    emitError(context, ErrorCodes.X_MISSING_END_TAG, 0, element.loc.start)\n    if (context.source.length === 0 &amp;&amp; element.tag.toLowerCase() === 'script') {\n      const first = children[0]\n      if (first &amp;&amp; startsWith(first.loc.source, '&lt;!--')) {\n        emitError(context, ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT)\n      }\n    }\n  }\n\n  element.loc = getSelection(context, element.loc.start)\n\n  if (isPreBoundary) {\n    context.inPre = false\n  }\n  if (isVPreBoundary) {\n    context.inVPre = false\n  }\n  return element\n}\n</code></pre><p>最后，我们来看下解析节点的parseTag函数的逻辑，匹配文本标签结束的位置后，先通过parseAttributes函数处理属性，然后对pre和v-pre标签进行检查，最后通过isComponent函数判断是否为组件。</p><p>isComponent内部会通过compiler-dom传递的isNativeTag来辅助判断结果，最终返回一个描述节点的对象，包含当前节点所有解析之后的信息，tag表示标签名，children表示子节点的数组，具体代码我放在了后面。</p><pre><code class=\"language-javascript\">function parseTag(\n  context: ParserContext,\n  type: TagType,\n  parent: ElementNode | undefined\n): ElementNode | undefined {\n\n  // Tag open. \n  const start = getCursor(context)\n  //匹配标签结束的位置\n  const match = /^&lt;\\/?([a-z][^\\t\\r\\n\\f /&gt;]*)/i.exec(context.source)!\n  const tag = match[1]\n  const ns = context.options.getNamespace(tag, parent)\n  // 向前遍历代码\n  advanceBy(context, match[0].length)\n  advanceSpaces(context)\n\n  // save current state in case we need to re-parse attributes with v-pre\n  const cursor = getCursor(context)\n  const currentSource = context.source\n\n  // check &lt;pre&gt; tag \n  if (context.options.isPreTag(tag)) {\n    context.inPre = true\n  }\n  // Attributes.\n  // 解析属性\n  let props = parseAttributes(context, type)\n  // check v-pre\n  if (){...}\n  // Tag close.\n  let isSelfClosing = false\n  if (type === TagType.End) {\n    return\n  }\n\n  let tagType = ElementTypes.ELEMENT\n  if (!context.inVPre) {\n    if (tag === 'slot') {\n      tagType = ElementTypes.SLOT\n    } else if (tag === 'template') {\n      if (\n        props.some(\n          p =&gt;\n            p.type === NodeTypes.DIRECTIVE &amp;&amp; isSpecialTemplateDirective(p.name)\n        )\n      ) {\n        tagType = ElementTypes.TEMPLATE\n      }\n    } else if (isComponent(tag, props, context)) {\n      tagType = ElementTypes.COMPONENT\n    }\n  }\n\n  return {\n    type: NodeTypes.ELEMENT,\n    ns,\n    tag,\n    tagType,\n    props,\n    isSelfClosing,\n    children: [],\n    loc: getSelection(context, start),\n    codegenNode: undefined // to be created during transform phase\n  }\n}\n\n</code></pre><p>parse函数生成AST之后，我们就有了一个完整描述template的对象，它包含了template中所有的信息。</p><h2>AST的语义化分析</h2><p>下一步我们要对AST进行语义化的分析。transform函数的执行流程分支很多，<strong>核心的逻辑就是识别一个个的Vue的语法，并且进行编译器的优化，我们经常提到的静态标记就是这一步完成的</strong>。</p><p>我们进入到transform函数中，可以看到，内部通过createTransformContext创建上下文对象，这个对象包含当前分析的属性配置，包括是否ssr，是否静态提升还有工具函数等等，这个对象的属性你可以在 <a href=\"https://github.com/vuejs/vue-next/blob/0dc521b9e15ce4aa3d5229e90d2173644529e92b/packages/compiler-core/src/transforms/transformElement.ts\">GitHub</a>上看到。</p><pre><code class=\"language-javascript\">\n\nexport function transform(root: RootNode, options: TransformOptions) {\n  const context = createTransformContext(root, options)\n  traverseNode(root, context)\n  if (options.hoistStatic) {\n    hoistStatic(root, context)\n  }\n  if (!options.ssr) {\n    createRootCodegen(root, context)\n  }\n  // finalize meta information\n  root.helpers = [...context.helpers.keys()]\n  root.components = [...context.components]\n  root.directives = [...context.directives]\n  root.imports = context.imports\n  root.hoists = context.hoists\n  root.temps = context.temps\n  root.cached = context.cached\n\n  if (__COMPAT__) {\n    root.filters = [...context.filters!]\n  }\n}\n\n</code></pre><p>然后通过traverseNode即可编译AST所有的节点。核心的转换流程是在遍历中实现，内部使用switch判断node.type执行不同的处理逻辑。比如如果是Interpolation，就需要在helper中导入toDisplayString工具函数，这个迷你版本中我们也实现过。</p><pre><code class=\"language-javascript\">\nexport function traverseNode(\n  node: RootNode | TemplateChildNode,\n  context: TransformContext\n) {\n  context.currentNode = node\n  // apply transform plugins\n  const { nodeTransforms } = context\n  const exitFns = []\n  for (let i = 0; i &lt; nodeTransforms.length; i++) {\n    // 处理exitFns\n  }\n  swtch (node.type) {\n    case NodeTypes.COMMENT:\n      if (!context.ssr) {\n        context.helper(CREATE_COMMENT)\n      }\n      break\n    case NodeTypes.INTERPOLATION:\n      if (!context.ssr) {\n        context.helper(TO_DISPLAY_STRING)\n      }\n      break\n    case NodeTypes.IF:\n      for (let i = 0; i &lt; node.branches.length; i++) {\n        traverseNode(node.branches[i], context)\n      }\n      break\n    case NodeTypes.IF_BRANCH:\n    case NodeTypes.FOR:\n    case NodeTypes.ELEMENT:\n    case NodeTypes.ROOT:\n      traverseChildren(node, context)\n      break\n  }\n\n  // exit transforms\n  context.currentNode = node\n  let i = exitFns.length\n  while (i--) {\n    exitFns[i]()\n  }\n}\n\n</code></pre><p>transform中还会调用transformElement来转换节点，用来处理props和children的静态标记，transformText用来转换文本，这里的代码比较简单， 你可以自行在<a href=\"https://github.com/vuejs/vue-next/blob/0dc521b9e15ce4aa3d5229e90d2173644529e92b/packages/compiler-core/src/transforms/transformElement.ts\">Github</a>上查阅。<br>\ntransform函数参数中的nodeTransforms和directiveTransforms传递了Vue中template语法的配置，这个两个函数由getBaseTransformPreset返回。</p><p>下面的代码中，transformIf和transformFor函数式解析Vue中v-if和v-for的语法转换，transformOn和transformModel是解析v-on和v-model的语法解析，这里我们只关注v-开头的语法。</p><pre><code class=\"language-javascript\">\n\nexport function getBaseTransformPreset(\n  prefixIdentifiers?: boolean\n): TransformPreset {\n  return [\n    [\n      transformOnce,\n      transformIf,\n      transformMemo,\n      transformFor,\n      ...(__COMPAT__ ? [transformFilter] : []),\n      ...(!__BROWSER__ &amp;&amp; prefixIdentifiers\n        ? [\n            // order is important\n            trackVForSlotScopes,\n            transformExpression\n          ]\n        : __BROWSER__ &amp;&amp; __DEV__\n        ? [transformExpression]\n        : []),\n      transformSlotOutlet,\n      transformElement,\n      trackSlotScopes,\n      transformText\n    ],\n    {\n      on: transformOn,\n      bind: transformBind,\n      model: transformModel\n    }\n  ]\n}\n\n</code></pre><p>然后我们再来看看transformIf的函数实现。首先判断v-if、v-else和v-else-if属性，内部通过createCodegenNodeForBranch来创建条件分支，在AST中标记当前v-if的处理逻辑。这段逻辑标记结束后，在generate中就会把v-if标签和后面的v-else标签解析成三元表达式。</p><pre><code class=\"language-javascript\">export const transformIf = createStructuralDirectiveTransform(\n  /^(if|else|else-if)$/,\n  (node, dir, context) =&gt; {\n    return processIf(node, dir, context, (ifNode, branch, isRoot) =&gt; {\n      const siblings = context.parent!.children\n      let i = siblings.indexOf(ifNode)\n      let key = 0\n      while (i-- &gt;= 0) {\n        const sibling = siblings[i]\n        if (sibling &amp;&amp; sibling.type === NodeTypes.IF) {\n          key += sibling.branches.length\n        }\n      }\n      return () =&gt; {\n        if (isRoot) {\n          ifNode.codegenNode = createCodegenNodeForBranch(\n            branch,\n            key,\n            context\n          ) as IfConditionalExpression\n        } else {\n          // attach this branch's codegen node to the v-if root.\n          const parentCondition = getParentCondition(ifNode.codegenNode!)\n          parentCondition.alternate = createCodegenNodeForBranch(\n            branch,\n            key + ifNode.branches.length - 1,\n            context\n          )\n        }\n      }\n    })\n  }\n)\n</code></pre><p>transform对AST分析结束之后，我们就得到了一个优化后的AST对象，最后我们需要调用generate函数最终生成render函数。</p><h2>template到render函数的转化</h2><p>结合下面的代码我们可以看到，generate首先通过createCodegenContext创建上下文对象，然后通过genModulePreamble生成预先定义好的代码模板，然后生成render函数，最后生成创建虚拟DOM的表达式。</p><pre><code class=\"language-javascript\">export function generate(\n  ast,\n  options\n): CodegenResult {\n  const context = createCodegenContext(ast, options)\n  const {\n    mode,\n    push,\n    prefixIdentifiers,\n    indent,\n    deindent,\n    newline,\n    scopeId,\n    ssr\n  } = context\n\n  if (!__BROWSER__ &amp;&amp; mode === 'module') {\n    // 预设代码，module风格 就是import语句\n    genModulePreamble(ast, preambleContext, genScopeId, isSetupInlined)\n  } else {\n    // 预设代码，函数风格 就是import语句\n    genFunctionPreamble(ast, preambleContext)\n  }\n  // render还是ssrRender\n  const functionName = ssr ? `ssrRender` : `render`\n  const args = ssr ? ['_ctx', '_push', '_parent', '_attrs'] : ['_ctx', '_cache']\n  if (!__BROWSER__ &amp;&amp; options.bindingMetadata &amp;&amp; !options.inline) {\n    // binding optimization args\n    args.push('$props', '$setup', '$data', '$options')\n  }\n  const signature =\n    !__BROWSER__ &amp;&amp; options.isTS\n      ? args.map(arg =&gt; `${arg}: any`).join(',')\n      : args.join(', ')\n\n  if (isSetupInlined) {\n    push(`(${signature}) =&gt; {`)\n  } else {\n    push(`function ${functionName}(${signature}) {`)\n  }\n  indent()\n\n  // 组件，指令声明代码\n  if (ast.components.length) {\n    genAssets(ast.components, 'component', context)\n    if (ast.directives.length || ast.temps &gt; 0) {\n      newline()\n    }\n  }\n  if (ast.components.length || ast.directives.length || ast.temps) {\n    push(`\\n`)\n    newline()\n  }\n\n  if (ast.codegenNode) {\n    genNode(ast.codegenNode, context)\n  } else {\n    push(`null`)\n  }\n\n  if (useWithBlock) {\n    deindent()\n    push(`}`)\n  }\n\n  deindent()\n  push(`}`)\n\n  return {\n    ast,\n    code: context.code,\n    preamble: isSetupInlined ? preambleContext.code : ``,\n    // SourceMapGenerator does have toJSON() method but it's not in the types\n    map: context.map ? (context.map as any).toJSON() : undefined\n  }\n}\n\n</code></pre><p>我们来看下关键的步骤，genModulePreamble函数生成import风格的代码，这也是我们迷你版本中的功能：通过遍历helpers，生成import字符串，这对应了代码的第二行。</p><pre><code class=\"language-javascript\">// 生成这个 \n// import { toDisplayString as _toDisplayString, createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\"\n\nfunction genModulePreamble(\n  ast: RootNode,\n  context: CodegenContext,\n  genScopeId: boolean,\n  inline?: boolean\n) {\n\n  if (genScopeId &amp;&amp; ast.hoists.length) {\n    ast.helpers.push(PUSH_SCOPE_ID, POP_SCOPE_ID)\n  }\n  // generate import statements for helpers\n  if (ast.helpers.length) {\n      push(\n        `import { ${ast.helpers\n          .map(s =&gt; `${helperNameMap[s]} as _${helperNameMap[s]}`)\n          .join(', ')} } from ${JSON.stringify(runtimeModuleName)}\\n`\n      )\n    }\n  }\n  ...\n}\n\n</code></pre><p>接下来的步骤就是生成渲染函数render和component的代码，最后通过genNode生成创建虚拟的代码，执行switch语句生成不同的代码，一共有十几种情况，这里就不一一赘述了。我们可以回顾上一讲中迷你代码的逻辑，总之针对变量，标签，v-if和v-for都有不同的代码生成逻辑，最终才实现了template到render函数的转化。</p><pre><code class=\"language-javascript\">function genNode(node: CodegenNode | symbol | string, context: CodegenContext) {\n  if (isString(node)) {\n    context.push(node)\n    return\n  }\n  if (isSymbol(node)) {\n    context.push(context.helper(node))\n    return\n  }\n  switch (node.type) {\n    case NodeTypes.ELEMENT:\n    case NodeTypes.IF:\n    case NodeTypes.FOR:\n      genNode(node.codegenNode!, context)\n      break\n    case NodeTypes.TEXT:\n      genText(node, context)\n      break\n    case NodeTypes.SIMPLE_EXPRESSION:\n      genExpression(node, context)\n      break\n    case NodeTypes.INTERPOLATION:\n      genInterpolation(node, context)\n      break\n    case NodeTypes.TEXT_CALL:\n      genNode(node.codegenNode, context)\n      break\n    case NodeTypes.COMPOUND_EXPRESSION:\n      genCompoundExpression(node, context)\n      break\n    case NodeTypes.COMMENT:\n      genComment(node, context)\n      break\n    case NodeTypes.VNODE_CALL:\n      genVNodeCall(node, context)\n      break\n\n    case NodeTypes.JS_CALL_EXPRESSION:\n      genCallExpression(node, context)\n      break\n    case NodeTypes.JS_OBJECT_EXPRESSION:\n      genObjectExpression(node, context)\n      break\n    case NodeTypes.JS_ARRAY_EXPRESSION:\n      genArrayExpression(node, context)\n      break\n    case NodeTypes.JS_FUNCTION_EXPRESSION:\n      genFunctionExpression(node, context)\n      break\n    case NodeTypes.JS_CONDITIONAL_EXPRESSION:\n      genConditionalExpression(node, context)\n      break\n    case NodeTypes.JS_CACHE_EXPRESSION:\n      genCacheExpression(node, context)\n      break\n    case NodeTypes.JS_BLOCK_STATEMENT:\n      genNodeList(node.body, context, true, false)\n      break\n\n    /* istanbul ignore next */\n    case NodeTypes.IF_BRANCH:\n      // noop\n      break\n\n  }\n}\n</code></pre><h2></h2><h2>总结</h2><p>今天的内容到这就讲完了，我给你总结一下今天讲到的内容吧。</p><p>今天我们一起分析了Vue中的compiler执行全流程，有了上一讲编译入门知识的基础之后，今天的parse，transform和generate模块就是在上一讲的基础之上，更加全面地实现代码的编译和转化。</p><p><img src=\"https://static001.geekbang.org/resource/image/a9/1e/a995298a4422d287a57e342dc105471e.jpg?wh=3510x1214\" alt=\"\"></p><p>上面的流程图中，我们代码中的template是通过compiler函数进行编译转换，compiler内部调用了compiler-core中的baseCompile函数，并且传递了浏览器平台的转换逻辑。</p><p>比如isNativeTag等函数，baseCompie函数中首先通过baseParse函数把template处理成为AST，并且由transform函数进行标记优化，transfom内部的transformIf，transformOn等函数会对Vue中的语法进行标记，这样在generate函数中就可以使用优化后的AST去生成最终的render函数。</p><p>最终，render函数会和我们写的setup函数一起组成组件对象，交给页面进行渲染。后面我特意为你绘制了一幅Vue全流程的架构图，你可以保存下来随时查阅。</p><p><img src=\"https://static001.geekbang.org/resource/image/3b/97/3b266af3c5f43d235a8ec0e687bc4c97.jpg?wh=8312x4611\" alt=\"\"></p><p>Vue源码中的编译优化也是Vue框架的亮点之一，我们自己也要思考编译器优化的机制，可以提高浏览器运行时的性能，我们项目中该如何借鉴这种思路呢？下一讲我会详细剖析编译原理在实战里的应用，敬请期待。</p><h2>思考题</h2><p>最后留一个思考题，transform函数中针对Vue中的语法有很多的函数处理，比如transformIf会把v-if指令编译成为一个三元表达式，请你从其余的函数选一个在评论区分享transform处理的结果吧。欢迎在评论区分享你的答案，我们下一讲再见！</p>","neighbors":{"left":{"article_title":"32｜编译原理（上）：手写一个迷你Vue 3 Compiler的入门原理","id":472927},"right":{"article_title":"34 | 编译原理（下）：编译原理给我们带来了什么？","id":473193}},"comments":[]}