{"id":126169,"title":"33丨如何使用性能分析工具定位SQL执行慢的原因？","content":"<p>在上一篇文章中，我们了解了查询优化器，知道在查询优化器中会经历逻辑查询优化和物理查询优化。需要注意的是，查询优化器只能在已经确定的情况下（SQL语句、索引设计、缓冲池大小、查询优化器参数等已知的情况）决定最优的查询执行计划。</p><p>但实际上SQL执行起来可能还是很慢，那么到底从哪里定位SQL查询慢的问题呢？是索引设计的问题？服务器参数配置的问题？还是需要增加缓存的问题呢？今天我们就从性能分析来入手，定位导致SQL执行慢的原因。</p><p>今天的内容主要包括以下几个部分：</p><ol>\n<li>数据库服务器的优化分析的步骤是怎样的？中间有哪些需要注意的地方？</li>\n<li>如何使用慢查询日志查找执行慢的SQL语句？</li>\n<li>如何使用EXPLAIN查看SQL执行计划？</li>\n<li>如何使用SHOW PROFILING分析SQL执行步骤中的每一步的执行时间？</li>\n</ol><h2>数据库服务器的优化步骤</h2><p>当我们遇到数据库调优问题的时候，该如何思考呢？我把思考的流程整理成了下面这张图。</p><p>整个流程划分成了观察（Show status）和行动（Action）两个部分。字母S的部分代表观察（会使用相应的分析工具），字母A代表的部分是行动（对应分析可以采取的行动）。<br>\n<img src=\"https://static001.geekbang.org/resource/image/99/37/998b1a255fe608856ac043eb9c36d237.png?wh=800*1523\" alt=\"\"><br>\n我们可以通过观察了解数据库整体的运行状态，通过性能分析工具可以让我们了解执行慢的SQL都有哪些，查看具体的SQL执行计划，甚至是SQL执行中的每一步的成本代价，这样才能定位问题所在，找到了问题，再采取相应的行动。</p><!-- [[[read_end]]] --><p>我来详细解释一下这张图。</p><p>首先在S1部分，我们需要观察服务器的状态是否存在周期性的波动。如果存在周期性波动，有可能是周期性节点的原因，比如双十一、促销活动等。这样的话，我们可以通过A1这一步骤解决，也就是加缓存，或者更改缓存失效策略。</p><p>如果缓存策略没有解决，或者不是周期性波动的原因，我们就需要进一步分析查询延迟和卡顿的原因。接下来进入S2这一步，我们需要开启慢查询。慢查询可以帮我们定位执行慢的SQL语句。我们可以通过设置<code>long_query_time</code>参数定义“慢”的阈值，如果SQL执行时间超过了<code>long_query_time</code>，则会认为是慢查询。当收集上来这些慢查询之后，我们就可以通过分析工具对慢查询日志进行分析。</p><p>在S3这一步骤中，我们就知道了执行慢的SQL语句，这样就可以针对性地用EXPLAIN查看对应SQL语句的执行计划，或者使用SHOW PROFILE查看SQL中每一个步骤的时间成本。这样我们就可以了解SQL查询慢是因为执行时间长，还是等待时间长。</p><p>如果是SQL等待时间长，我们进入A2步骤。在这一步骤中，我们可以调优服务器的参数，比如适当增加数据库缓冲池等。如果是SQL执行时间长，就进入A3步骤，这一步中我们需要考虑是索引设计的问题？还是查询关联的数据表过多？还是因为数据表的字段设计问题导致了这一现象。然后在这些维度上进行对应的调整。</p><p>如果A2和A3都不能解决问题，我们需要考虑数据库自身的SQL查询性能是否已经达到了瓶颈，如果确认没有达到性能瓶颈，就需要重新检查，重复以上的步骤。如果已经达到了性能瓶颈，进入A4阶段，需要考虑增加服务器，采用读写分离的架构，或者考虑对数据库分库分表，比如垂直分库、垂直分表和水平分表等。</p><p>以上就是数据库调优的流程思路。当我们发现执行SQL时存在不规则延迟或卡顿的时候，就可以采用分析工具帮我们定位有问题的SQL，这三种分析工具你可以理解是SQL调优的三个步骤：慢查询、EXPLAIN和SHOW PROFILE。</p><h2>使用慢查询定位执行慢的SQL</h2><p>慢查询可以帮我们找到执行慢的SQL，在使用前，我们需要先看下慢查询是否已经开启，使用下面这条命令即可：</p><pre><code>mysql &gt; show variables like '%slow_query_log';\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/9e/35/9efe05b732290a3ed0132597e2ca0f35.png?wh=1138*386\" alt=\"\"><br>\n我们能看到<code>slow_query_log=OFF</code>，也就是说慢查询日志此时是关上的。我们可以把慢查询日志打开，注意设置变量值的时候需要使用global，否则会报错：</p><pre><code>mysql &gt; set global slow_query_log='ON';\n</code></pre><p>然后我们再来查看下慢查询日志是否开启，以及慢查询日志文件的位置：</p><p><img src=\"https://static001.geekbang.org/resource/image/20/11/20d327118c221ada2bb123a4ce975e11.png?wh=1253*425\" alt=\"\"><br>\n你能看到这时慢查询分析已经开启，同时文件保存在DESKTOP-4BK02RP-slow文件中。</p><p>接下来我们来看下慢查询的时间阈值设置，使用如下命令：</p><pre><code>mysql &gt; show variables like '%long_query_time%';\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/a7/7a/a752b54a3fa38af449b55ccd0e628e7a.png?wh=1203*388\" alt=\"\"></p><p>这里如果我们想把时间缩短，比如设置为3秒，可以这样设置：</p><pre><code>mysql &gt; set global long_query_time = 3;\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/a1/49/a17e97c29e0c66177e2844ae96189449.png?wh=1205*533\" alt=\"\"><br>\n我们可以使用MySQL自带的mysqldumpslow工具统计慢查询日志（这个工具是个Perl脚本，你需要先安装好Perl）。</p><p>mysqldumpslow命令的具体参数如下：</p><ul>\n<li>-s：采用order排序的方式，排序方式可以有以下几种。分别是c（访问次数）、t（查询时间）、l（锁定时间）、r（返回记录）、ac（平均查询次数）、al（平均锁定时间）、ar（平均返回记录数）和at（平均查询时间）。其中at为默认排序方式。</li>\n<li>-t：返回前N条数据 。</li>\n<li>-g：后面可以是正则表达式，对大小写不敏感。</li>\n</ul><p>比如我们想要按照查询时间排序，查看前两条SQL语句，这样写即可：</p><pre><code>perl mysqldumpslow.pl -s t -t 2 &quot;C:\\ProgramData\\MySQL\\MySQL Server 8.0\\Data\\DESKTOP-4BK02RP-slow.log&quot;\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/5b/44/5bded5220b76bfe20c59bb2968cc3744.png?wh=1730*342\" alt=\"\"><br>\n你能看到开启了慢查询日志，并设置了相应的慢查询时间阈值之后，只要查询时间大于这个阈值的SQL语句都会保存在慢查询日志中，然后我们就可以通过mysqldumpslow工具提取想要查找的SQL语句了。</p><h2>如何使用EXPLAIN查看执行计划</h2><p>定位了查询慢的SQL之后，我们就可以使用EXPLAIN工具做针对性的分析，比如我们想要了解product_comment和user表进行联查的时候所采用的的执行计划，可以使用下面这条语句：</p><pre><code>EXPLAIN SELECT comment_id, product_id, comment_text, product_comment.user_id, user_name FROM product_comment JOIN user on product_comment.user_id = user.user_id \n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/ab/13/ab63d280a507eeb327bf154a0e87bf13.png?wh=1729*96\" alt=\"\"><br>\nEXPLAIN可以帮助我们了解数据表的读取顺序、SELECT子句的类型、数据表的访问类型、可使用的索引、实际使用的索引、使用的索引长度、上一个表的连接匹配条件、被优化器查询的行的数量以及额外的信息（比如是否使用了外部排序，是否使用了临时表等）等。</p><p>SQL执行的顺序是根据id从大到小执行的，也就是id越大越先执行，当id相同时，从上到下执行。</p><p>数据表的访问类型所对应的type列是我们比较关注的信息。type可能有以下几种情况：</p><p><img src=\"https://static001.geekbang.org/resource/image/22/92/223e8c7b863bd15c83f25e3d93958692.png?wh=1106*606\" alt=\"\"><br>\n在这些情况里，all是最坏的情况，因为采用了全表扫描的方式。index和all差不多，只不过index对索引表进行全扫描，这样做的好处是不再需要对数据进行排序，但是开销依然很大。如果我们在Extral列中看到Using index，说明采用了索引覆盖，也就是索引可以覆盖所需的SELECT字段，就不需要进行回表，这样就减少了数据查找的开销。</p><p>比如我们对product_comment数据表进行查询，设计了联合索引<code>composite_index (user_id, comment_text)</code>，然后对数据表中的<code>comment_id</code>、<code>comment_text</code>、<code>user_id</code>这三个字段进行查询，最后用EXPLAIN看下执行计划：</p><pre><code>EXPLAIN SELECT comment_id, comment_text, user_id FROM product_comment \n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/07/8f/07a47b0146b0e881381f78812914568f.png?wh=1730*77\" alt=\"\"><br>\n你能看到这里的访问方式采用了index的方式，key列采用了联合索引，进行扫描。Extral列为Using index，告诉我们索引可以覆盖SELECT中的字段，也就不需要回表查询了。</p><p>range表示采用了索引范围扫描，这里不进行举例，从这一级别开始，索引的作用会越来越明显，因此我们需要尽量让SQL查询可以使用到range这一级别及以上的type访问方式。</p><p>index_merge说明查询同时使用了两个或以上的索引，最后取了交集或者并集。比如想要对<code>comment_id=500000</code> 或者<code>user_id=500000</code>的数据进行查询，数据表中comment_id为主键，user_id是普通索引，我们可以查看下执行计划：</p><pre><code>EXPLAIN SELECT comment_id, product_id, comment_text, user_id FROM product_comment WHERE comment_id = 500000 OR user_id = 500000\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/4d/7e/4d07052ad81616f1d3b37bdb0a32067e.png?wh=1730*63\" alt=\"\"><br>\n你能看到这里同时使用到了两个索引，分别是主键和user_id，采用的数据表访问类型是index_merge，通过union的方式对两个索引检索的数据进行合并。</p><p>ref类型表示采用了非唯一索引，或者是唯一索引的非唯一性前缀。比如我们想要对<code>user_id=500000</code>的评论进行查询，使用EXPLAIN查看执行计划：</p><pre><code>EXPLAIN SELECT comment_id, comment_text, user_id FROM product_comment WHERE user_id = 500000 \n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/0a/b6/0a98105a776ce82bf6503fcad2ebe2b6.png?wh=1729*82\" alt=\"\"><br>\n这里user_id为普通索引（因为user_id在商品评论表中可能是重复的），因此采用的访问类型是ref，同时在ref列中显示const，表示连接匹配条件是常量，用于索引列的查找。</p><p>eq_ref类型是使用主键或唯一索引时产生的访问方式，通常使用在多表联查中。假设我们对<code>product_comment</code>表和user表进行联查，关联条件是两张表的user_id相等，使用EXPLAIN进行执行计划查看：</p><pre><code>EXPLAIN SELECT * FROM product_comment JOIN user WHERE product_comment.user_id = user.user_id \n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/59/33/59a1c808e79e2462fa6ffe5d7623d433.png?wh=1730*106\" alt=\"\"><br>\nconst类型表示我们使用了主键或者唯一索引（所有的部分）与常量值进行比较，比如我们想要查看<code>comment_id=500000</code>，查看执行计划：</p><pre><code>EXPLAIN SELECT comment_id, comment_text, user_id FROM product_comment WHERE comment_id = 500000 \n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/6c/34/6c95ac56a800f1a89e3fb461418a4334.png?wh=1730*77\" alt=\"\"><br>\n需要说明的是const类型和eq_ref都使用了主键或唯一索引，不过这两个类型有所区别，const是与常量进行比较，查询效率会更快，而eq_ref通常用于多表联查中。</p><p>system类型一般用于MyISAM或Memory表，属于const类型的特例，当表只有一行时连接类型为system（我在GitHub上上传了test_myisam数据表，该数据表只有一行记录，下载地址：<a href=\"https://github.com/cystanford/SQL_MyISAM\">https://github.com/cystanford/SQL_MyISAM</a>）。我们查看下执行计划：</p><pre><code>EXPLAIN SELECT * FROM test_myisam\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/9c/c6/9c2160c4f11d023ece153fcf34f639c6.png?wh=1730*90\" alt=\"\"><br>\n你能看到除了all类型外，其他类型都可以使用到索引，但是不同的连接方式的效率也会有所不同，效率从低到高依次为all &lt; index &lt; range &lt; index_merge &lt; ref &lt; eq_ref &lt; const/system。我们在查看执行计划的时候，通常希望执行计划至少可以使用到range级别以上的连接方式，如果只使用到了all或者index连接方式，我们可以从SQL语句和索引设计的角度上进行改进。</p><h2>使用SHOW PROFILE查看SQL的具体执行成本</h2><p>SHOW PROFILE相比EXPLAIN能看到更进一步的执行解析，包括SQL都做了什么、所花费的时间等。默认情况下，profiling是关闭的，我们可以在会话级别开启这个功能。</p><pre><code>mysql &gt; show variables like 'profiling';\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/db/96/db06756d6d8c0614c2a7574b0f6ba896.png?wh=1013*384\" alt=\"\"><br>\n通过设置<code>profiling='ON'</code>来开启show profile：</p><pre><code>mysql &gt; set profiling = 'ON';\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/11/bd/113b83ee204c9e9bbd4d8bd406abafbd.png?wh=1211*542\" alt=\"\"><br>\n我们可以看下当前会话都有哪些profiles，使用下面这条命令：</p><pre><code>mysql &gt; show profiles;\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/d0/80/d0f2ceae31f260f7b3e5f4e2a96e7280.png?wh=1700*416\" alt=\"\"><br>\n你能看到当前会话一共有2个查询，如果我们想要查看上一个查询的开销，可以使用：</p><pre><code>mysql &gt; show profile;\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/80/0d/80a0962163ddd49e728f45d2bcd9fc0d.png?wh=1042*1197\" alt=\"\"><br>\n我们也可以查看指定的Query ID的开销，比如<code>show profile for query 2</code>查询结果是一样的。在SHOW PROFILE中我们可以查看不同部分的开销，比如cpu、block.io等：</p><p><img src=\"https://static001.geekbang.org/resource/image/ec/83/ec4a633bff55a96aa831155a59bc1e83.png?wh=1730*863\" alt=\"\"><br>\n通过上面的结果，我们可以弄清楚每一步骤的耗时，以及在不同部分，比如CPU、block.io 的执行时间，这样我们就可以判断出来SQL到底慢在哪里。</p><p>不过SHOW PROFILE命令将被弃用，我们可以从information_schema中的profiling数据表进行查看。</p><h2>总结</h2><p>我今天梳理了SQL优化的思路，从步骤上看，我们需要先进行观察和分析，分析工具的使用在日常工作中还是很重要的。今天只介绍了常用的三种分析工具，实际上可以使用的分析工具还有很多。</p><p>我在这里总结一下今天文章里提到的三种分析工具。我们可以通过慢查询日志定位执行慢的SQL，然后通过EXPLAIN分析该SQL语句是否使用到了索引，以及具体的数据表访问方式是怎样的。我们也可以使用SHOW PROFILE进一步了解SQL每一步的执行时间，包括I/O和CPU等资源的使用情况。</p><p><img src=\"\" alt=\"\"></p><p>今天我介绍了EXPLAIN和SHOW PROFILE这两个工具，你还使用过哪些分析工具呢？</p><p>另外我们在进行数据表连接的时候，会有多种访问类型，你可以讲一下ref、eq_ref和 const 这三种类型的区别吗？查询效率有何不同？</p><p>欢迎你在评论区写下你的思考，也欢迎把这篇文章分享给你的朋友或者同事，一起交流进步。</p>","neighbors":{"left":{"article_title":"32丨查询优化器是如何工作的？","id":125429},"right":{"article_title":"34丨答疑篇：关于索引以及缓冲池的一些解惑","id":127873}},"comments":[{"had_liked":false,"id":127725,"user_name":"DZ","can_delete":false,"product_type":"c1","uid":1132240,"ip_address":"","ucode":"452555FA0F9E0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/46/d0/6bafd7d4.jpg","comment_is_top":false,"comment_ctime":1566784750,"is_pvip":false,"replies":[{"id":"47661","content":"对的，所以效率上来说一般是 ref &lt; eq_ref &lt; const","user_name":"作者回复","user_name_real":"cy","uid":"1306094","ctime":1566900596,"ip_address":"","comment_id":127725,"utype":1}],"discussion_count":1,"race_medal":0,"score":"151890640110","product_id":100029501,"comment_content":"如果两表关联查询，可以这样理解：<br><br>1. ref - 双层循环，直到找出所有匹配。<br>2. eq_ref - 双层循环，借助索引的唯一性，找到匹配就马上退出内层循环。<br>3. const: 单层循环。<br><br>按照循环次数递减的顺序排列它们，应该是 ref &gt; eq_ref &gt; const，循环次数越少，查询效率越高。","like_count":36,"discussions":[{"author":{"id":1306094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ed/ee/c4779b67.jpg","nickname":"cy","note":"","ucode":"50D653399A31F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464622,"discussion_content":"对的，所以效率上来说一般是 ref &amp;lt; eq_ref &amp;lt; const","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566900596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128610,"user_name":"leslie","can_delete":false,"product_type":"c1","uid":1324255,"ip_address":"","ucode":"798E7C1CC98CC2","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg","comment_is_top":false,"comment_ctime":1566913483,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"121825997771","product_id":100029501,"comment_content":"      explain看的东西不止这点吧：老师是不是针对错了DB，至少现实生产这点东西的定位完全不够；老师在生产中不看表的状态就做explain么？如果表的DML过高的话，explain的操作完全没有价值。<br>     如果一张表的自增跑到了100万，数据量只有10万；说明这张表可能已经损坏了，第一步就是修复表而不是一开始做explain。就像我们拿到一台设备不是先去测功能，首先应当坚持设备是否完全OK再去测试，数据库不可能拿到的是一张全新的表；首先应当是表的性能评估，然后再说相关的检查吧。<br>       个人觉得今天的讲解的时候漏了真正的第一步：设备没坚持就开始检查设备性能了。<br>    ","like_count":29,"discussions":[{"author":{"id":1716015,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/2f/2f/f434b676.jpg","nickname":"背靠咸🐟遇见🐱","note":"","ucode":"30113675864F23","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408822,"discussion_content":"表的性能评估是怎么进行的啊。。。不懂就问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635327502,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1364281,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d1/39/9feb690e.jpg","nickname":"-Destroyall","note":"","ucode":"182DE1018A3236","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387091,"discussion_content":"1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627979440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127701,"user_name":"土土人","can_delete":false,"product_type":"c1","uid":1045486,"ip_address":"","ucode":"6501B7D4F63E95","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f3/ee/33ef689b.jpg","comment_is_top":false,"comment_ctime":1566781971,"is_pvip":true,"replies":[{"id":"62751","content":"有的，比如Oracle自带的AWR工具","user_name":"作者回复","user_name_real":"cy","uid":"1306094","ctime":1577089111,"ip_address":"","comment_id":127701,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23041618451","product_id":100029501,"comment_content":"oracle是否有对应工呢？","like_count":6,"discussions":[{"author":{"id":1306094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ed/ee/c4779b67.jpg","nickname":"cy","note":"","ucode":"50D653399A31F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464613,"discussion_content":"有的，比如Oracle自带的AWR工具","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577089111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128176,"user_name":"LJK","can_delete":false,"product_type":"c1","uid":1199213,"ip_address":"","ucode":"12B2441099FF1D","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/6d/c20f2d5a.jpg","comment_is_top":false,"comment_ctime":1566849248,"is_pvip":false,"replies":[{"id":"47660","content":"一般来说sending data相比于其他部分会比较长。你也可以查看不同的模块时间，比如SHOW PROFILE cpu,block_io for query ...","user_name":"作者回复","user_name_real":"cy","uid":"1306094","ctime":1566900461,"ip_address":"","comment_id":128176,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18746718432","product_id":100029501,"comment_content":"SHOW PROFILE还会再有细致一点的说明么？一般看到都是sending data这个时间最长，不知道包含了哪些具体操作在里面？","like_count":5,"discussions":[{"author":{"id":1306094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ed/ee/c4779b67.jpg","nickname":"cy","note":"","ucode":"50D653399A31F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464824,"discussion_content":"一般来说sending data相比于其他部分会比较长。你也可以查看不同的模块时间，比如SHOW PROFILE cpu,block_io for query ...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566900461,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127774,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1566790857,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18746660041","product_id":100029501,"comment_content":"你可以讲一下 ref、eq_ref 和 const 这三种类型的区别吗？查询效率有何不同？<br>ref 是使用了非唯一索引<br>eq_ref 是使用了主键或唯一索引，一般在两表连接查询中索引<br>const 是使用了主键或唯一索引 与常量值进行比较<br><br>查询效率 ref &lt; eq_ref &lt; const","like_count":5},{"had_liked":false,"id":196622,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1585297681,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14470199569","product_id":100029501,"comment_content":"当前会话是代表什么，当前事务么","like_count":2},{"had_liked":false,"id":128375,"user_name":"听雨","can_delete":false,"product_type":"c1","uid":1254493,"ip_address":"","ucode":"252754F9FCFF0C","user_header":"https://static001.geekbang.org/account/avatar/00/13/24/5d/65e61dcb.jpg","comment_is_top":false,"comment_ctime":1566876368,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10156810960","product_id":100029501,"comment_content":"用EXPLAIN查看SQL执行顺序：如果SQL使用EXISTS嵌套子查询，按说，执行顺序是先执行主查询，再执行子查询，但是EXPLAIN出来的结果是主查询的id为1，子查询的id为2，也就是说是先执行的子查询，这是为什么呢","like_count":3,"discussions":[{"author":{"id":2962599,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/34/a7/52c4ea60.jpg","nickname":"年少挽滑稽世无双","note":"","ucode":"793DCBDE25A07B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588407,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663745257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127656,"user_name":"安静的boy","can_delete":false,"product_type":"c1","uid":1196475,"ip_address":"","ucode":"F5F44B75228A85","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/bb/21ce60d2.jpg","comment_is_top":false,"comment_ctime":1566775910,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10156710502","product_id":100029501,"comment_content":"index_merge的那个例子中，查询的type怎么是ref","like_count":2},{"had_liked":false,"id":290626,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1619664980,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5914632276","product_id":100029501,"comment_content":"想问一下，运维的那个MySQL慢SQL的页面怎么弄出来的的，就是甩给我一个网页地址，里面是SLOW LOG PLATFORM里面的详细慢sql日志，毕竟是页面，感觉看起来要比去服务器看输出友好一点。<br>是什么工具，搭建在自己的服务器，可以选择数据库，选择用户的查看日志详情，自己玩，安装的话对服务器要求高吗<br>","like_count":2},{"had_liked":false,"id":196893,"user_name":"汪zZ","can_delete":false,"product_type":"c1","uid":1234757,"ip_address":"","ucode":"8B93062A683902","user_header":"https://static001.geekbang.org/account/avatar/00/12/d7/45/d1621188.jpg","comment_is_top":false,"comment_ctime":1585321762,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"5880289058","product_id":100029501,"comment_content":"EXPLAIN那里有些不太清楚，还有要是有一些经验上的阈值分析就好了","like_count":1},{"had_liked":false,"id":302746,"user_name":"andy","can_delete":false,"product_type":"c1","uid":1154153,"ip_address":"","ucode":"66FA6DABD5BD3B","user_header":"https://static001.geekbang.org/account/avatar/00/11/9c/69/d16ea710.jpg","comment_is_top":false,"comment_ctime":1626351880,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626351880","product_id":100029501,"comment_content":"等待时间和执行时间是在哪里查？","like_count":0},{"had_liked":false,"id":263379,"user_name":"beyondzhao","can_delete":false,"product_type":"c1","uid":1003123,"ip_address":"","ucode":"439C944D5B1192","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/73/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1606120230,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606120230","product_id":100029501,"comment_content":"老师，想问下，慢查询里最后那个例子里，采用 mysqldumpslow 按时间排序查看前两条 SQL 查询语句，查询结果里第二条查询语句 Time=164.04s（656s），括号里的656秒表示什么意思呢？哪一个才是这条 SQL 语句查询的耗时呢?","like_count":0},{"had_liked":false,"id":203519,"user_name":"张滔","can_delete":false,"product_type":"c1","uid":1322636,"ip_address":"","ucode":"87ABAFF0E861E0","user_header":"https://static001.geekbang.org/account/avatar/00/14/2e/8c/b261e15a.jpg","comment_is_top":false,"comment_ctime":1586226211,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1586226211","product_id":100029501,"comment_content":"我给领导提出的建议是开启慢查询，然后根据慢查询来优化sql，但领导说这样的话工作会拖拖沓沓，要求我把我们系统的所有sql整理出来进行优化，您赞同我领导的做法吗？","like_count":0,"discussions":[{"author":{"id":1111183,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f4/8f/06bd9544.jpg","nickname":"AlphaGao","note":"","ucode":"862000415389FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305326,"discussion_content":"整理出来是准备肉眼优化吗哈哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599878961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":195142,"user_name":"博弈","can_delete":false,"product_type":"c1","uid":1433344,"ip_address":"","ucode":"B1A69837E41972","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/EcYNib1bnDf5dz6JcrE8AoyZYMdqic2VNmbBtCcVZTO9EoDZZxqlQDEqQKo6klCCmklOtN9m0dTd2AOXqSneJYLw/132","comment_is_top":false,"comment_ctime":1585140443,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585140443","product_id":100029501,"comment_content":"通过本章学习，了解了如何使用性能分析工具定位SQL执行慢的原因，希望能在实践中运用。","like_count":0},{"had_liked":false,"id":163401,"user_name":"竹影","can_delete":false,"product_type":"c1","uid":1532231,"ip_address":"","ucode":"40386DFA60F899","user_header":"https://static001.geekbang.org/account/avatar/00/17/61/47/0a6e9729.jpg","comment_is_top":false,"comment_ctime":1576717404,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576717404","product_id":100029501,"comment_content":"多表联查的时候，SQL的执行顺序是怎样的？where后什么时候执行？","like_count":0},{"had_liked":false,"id":128921,"user_name":"law","can_delete":false,"product_type":"c1","uid":1037514,"ip_address":"","ucode":"3B664E2667ED63","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d4/ca/bdb348db.jpg","comment_is_top":false,"comment_ctime":1566984141,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566984141","product_id":100029501,"comment_content":"生产环境遇到一种情况，有两个组合索引：coupon_code(tenant_id,coupon_code,platforms), idx_eq_coupon8(tenant_id,end_date,state),有个查询条件按照第二个组合索引的条件查询，但没有用到第二个索引，而是用到了第一个，麻烦老师帮忙分析下这种情况怎么定位什么原因？","like_count":0},{"had_liked":false,"id":128771,"user_name":"Jack 乐","can_delete":false,"product_type":"c1","uid":1205795,"ip_address":"","ucode":"D5E36481290E60","user_header":"https://static001.geekbang.org/account/avatar/00/12/66/23/d67cc01a.jpg","comment_is_top":false,"comment_ctime":1566960355,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1566960355","product_id":100029501,"comment_content":"老师，你好！百万级大表创建联合索引，导致阻塞现象，如何解决？","like_count":0,"discussions":[{"author":{"id":1135990,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/76/a55871ab.jpg","nickname":"孙庆良","note":"","ucode":"CA05C4CFEFB0F9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311191,"discussion_content":"问题太粗了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602249165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}