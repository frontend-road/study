{"id":829302,"title":"14｜用LangChain实现一个Agent","content":"<p>你好，我是郑晔！</p><p>上一讲，我们抛开了 LangChain，基于 OpenAI Python 程序库实现了一个 Agent，主要是为了让你更好地理解 Agent 的运作机理。其中最核心的部分就是一个循环，不断地执行各种动作，直到判断运行的结果是停下来。</p><p>现在，你已经知道了 Agent 是怎样运作的，这一讲，我们再回来看看如何用 LangChain 实现一个 Agent，相信有了之前的铺垫，这一讲的代码就比较容易理解了。</p><h2>基于LangChain实现的Agent</h2><p>从实现的功能上讲，我们这一讲要实现的功能和上一讲是完全相同的，只不过我们采用了 LangChain 的基础设施，代码如下所示：</p><pre><code class=\"language-python\">from langchain.agents import AgentExecutor, create_react_agent\nfrom langchain_core.prompts import PromptTemplate\nfrom langchain_core.tools import tool\nfrom langchain_openai import ChatOpenAI\n\n@tool\ndef calculate(what: str) -&gt; float:\n    \"\"\"Runs a calculation and returns the number - uses Python so be sure to use floating point syntax if necessary\"\"\"\n    return eval(what)\n\n@tool\ndef ask_fruit_unit_price(fruit: str) -&gt; str:\n    \"\"\"Asks the user for the price of a fruit\"\"\"\n    if fruit.casefold() == \"apple\":\n        return \"Apple unit price is 10/kg\"\n    elif fruit.casefold() == \"banana\":\n        return \"Banana unit price is 6/kg\"\n    else:\n        return \"{} unit price is 20/kg\".format(fruit)\n\n\nprompt = PromptTemplate.from_template('''Answer the following questions as best you can. You have access to the following tools:\n\n{tools}\n\nUse the following format:\n\nQuestion: the input question you must answer\nThought: you should always think about what to do\nAction: the action to take, should be one of [{tool_names}]\nAction Input: the input to the action\nObservation: the result of the action\n... (this Thought/Action/Action Input/Observation can repeat N times)\nThought: I now know the final answer\nFinal Answer: the final answer to the original input question\n\nBegin!\n\nQuestion: {input}\nThought:{agent_scratchpad}''')\n\ntools = [calculate, ask_fruit_unit_price]\nmodel = ChatOpenAI(model=\"gpt-4o-mini\")\nagent = create_react_agent(model, tools, prompt)\nagent_executor = AgentExecutor(agent=agent, tools=tools, verbose=True)\nresult = agent_executor.invoke({\n    \"input\": \"What is the total price of 3 kg of apple and 2 kg of banana?\"\n})\nprint(result)\n</code></pre><!-- [[[read_end]]] --><h2>工具</h2><p>这一讲的代码与上一讲实现了完全相同的功能，主要是我们把上一讲的两个动作函数几乎原封不动地搬了过来。</p><pre><code class=\"language-python\">@tool\ndef calculate(what: str) -&gt; float:\n    \"\"\"Runs a calculation and returns the number - uses Python so be sure to use floating point syntax if necessary\"\"\"\n    return eval(what)\n\n@tool\ndef ask_fruit_unit_price(fruit: str) -&gt; str:\n    \"\"\"Asks the user for the price of a fruit\"\"\"\n    if fruit.casefold() == \"apple\":\n        return \"Apple unit price is 10/kg\"\n    elif fruit.casefold() == \"banana\":\n        return \"Banana unit price is 6/kg\"\n    else:\n        return \"{} unit price is 20/kg\".format(fruit)\n</code></pre><p>之所以要说几乎，是我们给这两个函数添加了一点东西。首先，<code>@tool</code> 是一个装饰器，它让我们把一个函数变成了一个工具（tool）。</p><p>工具在 LangChain 里是一个重要的概念，它和我们说的 Agent 系统架构中的工具概念是可以对应上的，工具主要负责执行查询，或是完成一个一个的动作。</p><p>Agent 在执行过程中，会获取工具的信息，传给大模型。这些信息主要就是一个工具的名称、描述和参数，这样大模型就知道该在什么情况下怎样调用这个工具了。<code>@tool</code> 可以提取函数名变成工具名，提取参数变成工具的参数，还有一点就是，它可以提取函数的 Docstring 作为工具的描述。这样一来，calculate 就从一个普通的函数变成了一个工具。</p><pre><code class=\"language-python\">@tool\ndef calculate(what: str) -&gt; float:\n    \"\"\"Runs a calculation and returns the number - uses Python so be sure to use floating point syntax if necessary\"\"\"\n    return eval(what)\n\nprint(calculate.name)\nprint(calculate.description)\nprint(calculate.args)\n</code></pre><h2>提示词</h2><p>接下来就是提示词，这里我们没有把上一讲的提示词直接搬过来，而是采用了一个<a href=\"https://smith.langchain.com/hub/hwchase17/react\">更通用的提示词</a>：</p><pre><code class=\"language-python\">prompt = PromptTemplate.from_template('''Answer the following questions as best you can. You have access to the following tools:\n\n{tools}\n\nUse the following format:\n\nQuestion: the input question you must answer\nThought: you should always think about what to do\nAction: the action to take, should be one of [{tool_names}]\nAction Input: the input to the action\nObservation: the result of the action\n... (this Thought/Action/Action Input/Observation can repeat N times)\nThought: I now know the final answer\nFinal Answer: the final answer to the original input question\n\nBegin!\n\nQuestion: {input}\nThought:{agent_scratchpad}''')\n</code></pre><p>如果你还记得，我们在学习<a href=\"https://time.geekbang.org/column/article/822235\">提示工程</a>的那一讲的时候，已经见过这个提示词模板了，再结合上一讲介绍过的提示词，对于这里的思考（Thought）、行动（Action）和观察（Observation），你肯定不陌生了。</p><p>作为一个模板，这里面有几个空是留给我们的，最主要的就是 <code>tools</code> 和 <code>tool_names</code> 两个变量，这就是工具的信息。<code>tool_names</code> 很简单，就是工具的名称。</p><p><code>tools</code> 是工具格式化成一个字符串。比如，在缺省的实现中， <code>calculate</code> 就会格式化成下面这个样子，可以看到它包括了工具的基本属性都拼装了进去。</p><pre><code class=\"language-plain\">calculate(what: str) -&gt; float - Runs a calculation and returns the number - uses Python so be sure to use floating point syntax if necessary\n</code></pre><p><code>input</code> 也比较好理解，就是我们的输入。 <code>agent_scratchpad</code> 是在 Agent 的执行过程中，存放中间过程的，你可以把它理解成我们上一讲的聊天历史部分。</p><h2>组装 Agent</h2><p>有了工具，有了提示词，现在我们可以组装 Agent 了：</p><pre><code class=\"language-python\">tools = [calculate, ask_fruit_unit_price]\nmodel = ChatOpenAI(model=\"gpt-4o-mini\")\nagent = create_react_agent(model, tools, prompt)\nagent_executor = AgentExecutor(agent=agent, tools=tools, verbose=True)\n</code></pre><p>我们调用 <code>create_react_agent</code> 创建了一个基于 ReAct 的 Agent。前面说过，ReAct 的Agent 能够正常运行，需要提示词与代码配合起来使用。我前面给出的提示词就是要与 <code>create_react_agent</code> 函数配合在一起使用的。</p><p><code>create_react_agent</code> 完成的工作就是基于这段提示词的执行过程进行处理，比如，解析返回内容中的动作（Action）与动作输入（Action Input），还有前面说的 <code>agent_scratchpad</code> 的处理过程，也是在这个函数中组装进去的。</p><p>站在软件设计的角度看，二者结合如此紧密，却被分开了，等于破坏了封装。实际上，二者之前确实是合在一起的，就是一个 <code>create_react_agent</code> 函数。现在将二者分开，是为了给使用者一个调整提示词的机会。</p><p>与之前几个基于 LangChain 的应用最大的不同在于，我们这个 Agent 的实现并没有组装成一个链。正如我们前面所说，Agent 的核心是一个循环，这其实是一个流程，而之前的应用从头到尾都是一个“链”式过程。所以，这里用到了 AgentExecutor。</p><p>即便不看它的实现，你应该也能知道，其核心实现就是一个循环：判断是不是该结束，不是的话，继续下一步，向大模型发送消息，是的话，跳出循环。</p><p>现在，我们已经组装好了所有的代码，接下来就是执行这个 Agent 了：</p><pre><code class=\"language-python\">result = agent_executor.invoke({\n    \"input\": \"What is the total price of 3 kg of apple and 2 kg of banana?\"\n})\nprint(result)\n</code></pre><p>一次的执行结果输出如下：</p><pre><code class=\"language-plain\">&gt; Entering new AgentExecutor chain...\n\nTo find the total price of 3 kg of apples and 2 kg of bananas, I need to know the unit prices of both fruits. I will first ask for the price of apples and then for the price of bananas.\n\nAction: ask_fruit_unit_price&nbsp;&nbsp;\nAction Input: \"apple\"&nbsp; \nApple unit price is 10/kg\n\nNow that I have the unit price of apples, I need to ask for the unit price of bananas.\n\nAction: ask_fruit_unit_price&nbsp;&nbsp;\nAction Input: \"banana\"&nbsp; \nBanana unit price is 6/kg\n\nNow that I have the unit prices of both fruits (10/kg for apples and 6/kg for bananas), I can calculate the total price for 3 kg of apples and 2 kg of bananas.\n\nAction: calculate&nbsp;&nbsp;\nAction Input: \"3 * 10 + 2 * 6\"&nbsp; 42\n\nI now know the final answer\nFinal Answer: The total price of 3 kg of apples and 2 kg of bananas is 42.\n\n&gt; Finished chain.\n{'input': 'What is the total price of 3 kg of apple and 2 kg of banana?', 'output': 'The total price of 3 kg of apples and 2 kg of bananas is 42.'}\n</code></pre><p>因为在 AgentExecutor 初始化的时候，我打开了 <code>verbose</code> 这个开关，所以，这里我们看到 Agent 内部的执行过程。我们可以看到，其过程几乎与我们上一讲的过程是一样的，先查看苹果和香蕉的单价，然后，计算总和。最终，把计算结果返回给我们。</p><h2>工具（Tool）和工具包（Toolkit）</h2><p>在前面的实现中，为了兼容上一讲的内容，我们自定义了自己的工具实现。实际上， LangChain 社区已经为我们提供了<a href=\"https://python.langchain.com/docs/integrations/tools/\">大量的工具</a>，让我们可以很方便地集成各种东西。在很多情况下，这些工具我们只要直接拿过来用就好，下面是一个例子：</p><pre><code class=\"language-python\">shell_tool = ShellTool()\n\ntools = [shell_tool]\nmodel = ChatOpenAI(model=\"gpt-4o-mini\")\nagent = create_react_agent(model, tools, prompt)\nagent_executor = AgentExecutor(agent=agent, tools=tools, verbose=True)\nresult = agent_executor.invoke({\n    \"input\": \"Create a file named 'test.txt' and write 'Hello, World!' to it.\"\n})\n</code></pre><p>在这个例子里，我们创建了一个可以执行自然语言命令的命令行工具。为了支持命令行的执行，我们引入了 ShellTool，它是一个命令行工具。所有的工具实际上都是 Tool 这个接口的实现，ShellTool 也是实现这个接口。前面的动作函数就是通过 <code>@tool</code> 这个装饰器生成了一个实现 Tool 接口的对象。</p><p>对程序员来说，命令行的行为大家都不陌生，下面就是这个 Agent 的一次执行结果，我让它创建了一个名为 test.txt 的文件，然后，在其中写入“Hello, World!”。</p><pre><code class=\"language-plain\">I need to create a file named 'test.txt' and then write the text 'Hello, World!' into it. I'll do this using shell commands in the terminal.&nbsp;\n\nAction: terminal&nbsp;&nbsp;\nAction Input: echo 'Hello, World!' &gt; test.txt&nbsp;&nbsp;\n\nExecuting command:\n&nbsp;echo 'Hello, World!' &gt; test.txt\n\nThe file 'test.txt' has been created with the content 'Hello, World!'.&nbsp;\n\nFinal Answer: A file named 'test.txt' has been created with the content 'Hello, World!'.\n</code></pre><p>除了工具，LangChain 还有一个 Toolkit 的概念，它的作用是把相关的一些工具集成在一起。举个例子，Github 提供了一大堆的能力，比如查询 Issue、创建 Pull Request 等等。如果一个一个列出来就会很多，所以，就有了一个 Github Toolkit 把它们放在了一起。下面是一个示例：</p><pre><code class=\"language-plain\">github = GitHubAPIWrapper()\ntoolkit = GitHubToolkit.from_github_api_wrapper(github)\n\ntools = toolkit.get_tools()\nagent = create_react_agent(model, tools, prompt)\n...\n</code></pre><p>当然，为了这段代码能够执行，你需要找到相关的配置：</p><pre><code class=\"language-bash\">export GITHUB_APP_ID=\"your-app-id\"\nexport GITHUB_APP_PRIVATE_KEY=\"path-to-private-key\"\nexport GITHUB_REPOSITORY=\"your-github-repository\"\n</code></pre><p>正是有了工具和工具包的概念，Agent 能做的事情就会无限放大。如果我们做的是比较通用的事情，很多时候，就是在已有的工具和工具包中进行选择。不过，我之所以把如何编写一个工具放在前头，是因为大多数情况下，我们需要编写自己的工具，无论是访问私有的数据，还是内部的接口。所以，学习编写工具几乎是一件必须要学会的事。不过，这种代码就进入到我们熟悉的范围了，对大部分程序员而言，应该不是太大的问题。</p><p>现在你已经了解了采用 LangChain 构建 Agent 的基本方法。虽然我们这里只介绍了基于 ReAct 构建的 Agent，但实际上，LangChain 里提供了大量的各种创建 Agent 的方法，比如创建基于 SQL 的 Agent、基于 JSON 的 Agent 等等，我们可以根据需要进行选择。</p><h2>总结时刻</h2><p>这一讲，我们使用 LangChain 重新构建了上一讲的 Agent。有了上一讲的基础，这一讲的代码理解起来应该非常容易。</p><p>与构建其它类型应用不同的地方是，构建 Agent 不是构建一条“链”，所以，需要用一个 AgentExecutor 去执行 Agent，其本质是一个循环，一直执行到大模型认为已经找到了答案。</p><p>与 Agent 配合的概念中，工具（Tool）和工具包（Toolkit）是非常重要的。开发一个 Agent，很多时候就是在开发工具和集成工具：</p><ul>\n<li>\n<p>工具负责与模型交互，其输入由模型产生，输出会回传给模型。</p>\n</li>\n<li>\n<p>工具包是一组相关的工具。</p>\n</li>\n</ul><p>如果今天的内容你只能记住一件事，那请记住，<strong>编写基于 LangChain 的 Agent，关键点是学会工具。</strong></p><h2>练习题</h2><p>LangChain 社区提供了大量的工具，你可以找一个自己感兴趣的，用它来改造这一讲的代码，实现一个新的 Agent。欢迎在留言区分享你的改造心得。</p><p>欢迎你在留言区和我交流互动，如果这一讲对你有帮助，别忘了分享给身边更多朋友。</p>","neighbors":{"left":{"article_title":"13｜从头实现一个Agent","id":828836},"right":{"article_title":"15｜长期记忆：让大模型更了解你","id":829671}},"comments":[{"had_liked":false,"id":396093,"user_name":"grok","can_delete":false,"product_type":"c1","uid":1341502,"ip_address":"美国","ucode":"4744AB3FA28FE2","user_header":"https://static001.geekbang.org/account/avatar/00/14/78/3e/f60ea472.jpg","comment_is_top":false,"comment_ctime":1733091904,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100839101,"comment_content":"我用的grok2，本节代码跑不通。需要清理输入。改动如下：\n```\ndef clean_tool_input(func):\n    &quot;&quot;&quot;装饰器：清理传递给工具函数的输入&quot;&quot;&quot;\n    @wraps(func)  # 这会保留原始函数的元数据，包括 docstring\n    def wrapper(input_str: str, *args, **kwargs):\n        # 清理输入，只取第一行并去除空白字符\n        cleaned_input = input_str.split(&#39;\\n&#39;)[0].strip()\n        return func(cleaned_input, *args, **kwargs)\n    return wrapper\n\n@tool\n@clean_tool_input\ndef calculate(what: str) -&gt; float:\n    &quot;&quot;&quot;Runs a calculation and returns the number - uses Python so be sure to use floating point syntax if necessary&quot;&quot;&quot;\n    return eval(what)\n\n@tool\n@clean_tool_input\ndef ask_fruit_unit_price(fruit: str) -&gt; str:\n    &quot;&quot;&quot;Asks the user for the price of a fruit&quot;&quot;&quot;\n    if fruit.casefold() == &quot;apple&quot;:\n        return &quot;Apple unit price is 10&#47;kg&quot;\n    elif fruit.casefold() == &quot;banana&quot;:\n        return &quot;Banana unit price is 6&#47;kg&quot;\n    else:\n        return &quot;{} unit price is 20&#47;kg&quot;.format(fruit)\n```\n\n完整代码在此：https:&#47;&#47;github.com&#47;groklab&#47;misc&#47;blob&#47;main&#47;geektime-llm-zhengye-column&#47;lec14.ipynb","like_count":3}]}