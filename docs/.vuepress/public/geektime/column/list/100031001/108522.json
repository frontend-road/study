{"id":108522,"title":"09 | Widget，构建Flutter界面的基石","content":"<p>你好，我是陈航。</p><p>在前面的Flutter开发起步和Dart基础模块中，我和你一起学习了Flutter框架的整体架构与基本原理，分析了Flutter的项目结构和运行机制，并从Flutter开发角度介绍了Dart语言的基本设计思路，也通过和其他高级语言的类比深入认识了Dart的语法特性。</p><p>这些内容，是我们接下来系统学习构建Flutter应用的基础，可以帮助我们更好地掌握Flutter的核心概念和技术。</p><p>在第4篇文章“<a href=\"https://time.geekbang.org/column/article/105703\">Flutter区别于其他方案的关键技术是什么？</a>”中，我和你分享了一张来自Flutter官方的架构图，不难看出Widget是整个视图描述的基础。这张架构图很重要，所以我在这里又放了一次。</p><p><img src=\"https://static001.geekbang.org/resource/image/ac/2f/ac7d1cec200f7ea7cb6cbab04eda252f.png?wh=2274*1186\" alt=\"\"></p><center><span class=\"reference\">图1 Flutter架构图</span></center><p>备注：此图引自<a href=\"https://flutter.dev/docs/resources/technical-overview\">Flutter System Overview</a></p><p>那么，Widget到底是什么呢？</p><p>Widget是Flutter功能的抽象描述，是视图的配置信息，同样也是数据的映射，是Flutter开发框架中最基本的概念。前端框架中常见的名词，比如视图（View）、视图控制器（View Controller）、活动（Activity）、应用（Application）、布局（Layout）等，在Flutter中都是Widget。</p><!-- [[[read_end]]] --><p>事实上，<strong>Flutter的核心设计思想便是“一切皆Widget”</strong>。所以，我们学习Flutter，首先得从学会使用Widget开始。</p><p>那么，在今天的这篇文章中，我会带着你一起学习Widget在Flutter中的设计思路和基本原理，以帮助你深入理解Flutter的视图构建过程。</p><h2>Widget渲染过程</h2><p>在进行App开发时，我们往往会关注的一个问题是：如何结构化地组织视图数据，提供给渲染引擎，最终完成界面显示。</p><p>通常情况下，不同的UI框架中会以不同的方式去处理这一问题，但无一例外地都会用到视图树（View Tree）的概念。而Flutter将视图树的概念进行了扩展，把视图数据的组织和渲染抽象为三部分，即Widget，Element和 RenderObject。</p><p>这三部分之间的关系，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/b4/c9/b4ae98fe5b4c9a7a784c916fd140bbc9.png?wh=774*72\" alt=\"\"></p><center><span class=\"reference\">图2 Widget，Element与RenderObject</span></center><h3>Widget</h3><p>Widget是Flutter世界里对视图的一种结构化描述，你可以把它看作是前端中的“控件”或“组件”。Widget是控件实现的基本逻辑单位，里面存储的是有关视图渲染的配置信息，包括布局、渲染属性、事件响应信息等。</p><p>在页面渲染上，<strong>Flutter将“Simple is best”这一理念做到了极致</strong>。为什么这么说呢？Flutter将Widget设计成不可变的，所以当视图渲染的配置信息发生变化时，Flutter会选择重建Widget树的方式进行数据更新，以数据驱动UI构建的方式简单高效。</p><p>但，这样做的缺点是，因为涉及到大量对象的销毁和重建，所以会对垃圾回收造成压力。不过，Widget本身并不涉及实际渲染位图，所以它只是一份轻量级的数据结构，重建的成本很低。</p><p>另外，由于Widget的不可变性，可以以较低成本进行渲染节点复用，因此在一个真实的渲染树中可能存在不同的Widget对应同一个渲染节点的情况，这无疑又降低了重建UI的成本。</p><h3>Element</h3><p>Element是Widget的一个实例化对象，它承载了视图构建的上下文数据，是连接结构化的配置信息到完成最终渲染的桥梁。</p><p>Flutter渲染过程，可以分为这么三步：</p><ul>\n<li>首先，通过Widget树生成对应的Element树；</li>\n<li>然后，创建相应的RenderObject并关联到Element.renderObject属性上；</li>\n<li>最后，构建成RenderObject树，以完成最终的渲染。</li>\n</ul><p>可以看到，Element同时持有Widget和RenderObject。而无论是Widget还是Element，其实都不负责最后的渲染，只负责发号施令，真正去干活儿的只有RenderObject。那你可能会问，<strong>既然都是发号施令，那为什么需要增加中间的这层Element树呢？直接由Widget命令RenderObject去干活儿不好吗？</strong></p><p>答案是，可以，但这样做会极大地增加渲染带来的性能损耗。</p><p>因为Widget具有不可变性，但Element却是可变的。实际上，Element树这一层将Widget树的变化（类似React 虚拟DOM diff）做了抽象，可以只将真正需要修改的部分同步到真实的RenderObject树中，最大程度降低对真实渲染视图的修改，提高渲染效率，而不是销毁整个渲染视图树重建。</p><p>这，就是Element树存在的意义。</p><h3>RenderObject</h3><p>从其名字，我们就可以很直观地知道，RenderObject是主要负责实现视图渲染的对象。</p><p>在前面的第4篇文章“<a href=\"https://time.geekbang.org/column/article/105703\">Flutter区别于其他方案的关键技术是什么？</a>”中，我们提到，Flutter通过控件树（Widget树）中的每个控件（Widget）创建不同类型的渲染对象，组成渲染对象树。</p><p>而渲染对象树在Flutter的展示过程分为四个阶段，即布局、绘制、合成和渲染。 其中，布局和绘制在RenderObject中完成，Flutter采用深度优先机制遍历渲染对象树，确定树中各个对象的位置和尺寸，并把它们绘制到不同的图层上。绘制完毕后，合成和渲染的工作则交给Skia搞定。</p><p>Flutter通过引入Widget、Element与RenderObject这三个概念，把原本从视图数据到视图渲染的复杂构建过程拆分得更简单、直接，在易于集中治理的同时，保证了较高的渲染效率。</p><h2>RenderObjectWidget介绍</h2><p>通过第5篇文章“<a href=\"https://time.geekbang.org/column/article/106199\">从标准模板入手，体会Flutter代码是如何运行在原生系统上的</a>”的介绍，你应该已经知道如何使用StatelessWidget和StatefulWidget了。</p><p>不过，StatelessWidget和StatefulWidget只是用来组装控件的容器，并不负责组件最后的布局和绘制。在Flutter中，布局和绘制工作实际上是在Widget的另一个子类RenderObjectWidget内完成的。</p><p>所以，在今天这篇文章的最后，我们再来看一下RenderObjectWidget的源码，来看看如何使用Element和RenderObject完成图形渲染工作。</p><pre><code>abstract class RenderObjectWidget extends Widget {\n  @override\n  RenderObjectElement createElement();\n  @protected\n  RenderObject createRenderObject(BuildContext context);\n  @protected\n  void updateRenderObject(BuildContext context, covariant RenderObject renderObject) { }\n  ...\n}\n</code></pre><p>RenderObjectWidget是一个抽象类。我们通过源码可以看到，这个类中同时拥有创建Element、RenderObject，以及更新RenderObject的方法。</p><p>但实际上，<strong>RenderObjectWidget本身并不负责这些对象的创建与更新</strong>。</p><p>对于Element的创建，Flutter会在遍历Widget树时，调用createElement去同步Widget自身配置，从而生成对应节点的Element对象。而对于RenderObject的创建与更新，其实是在RenderObjectElement类中完成的。</p><pre><code>abstract class RenderObjectElement extends Element {\n  RenderObject _renderObject;\n\n  @override\n  void mount(Element parent, dynamic newSlot) {\n    super.mount(parent, newSlot);\n    _renderObject = widget.createRenderObject(this);\n    attachRenderObject(newSlot);\n    _dirty = false;\n  }\n   \n  @override\n  void update(covariant RenderObjectWidget newWidget) {\n    super.update(newWidget);\n    widget.updateRenderObject(this, renderObject);\n    _dirty = false;\n  }\n  ...\n}\n</code></pre><p>在Element创建完毕后，Flutter会调用Element的mount方法。在这个方法里，会完成与之关联的RenderObject对象的创建，以及与渲染树的插入工作，插入到渲染树后的Element就可以显示到屏幕中了。</p><p>如果Widget的配置数据发生了改变，那么持有该Widget的Element节点也会被标记为dirty。在下一个周期的绘制时，Flutter就会触发Element树的更新，并使用最新的Widget数据更新自身以及关联的RenderObject对象，接下来便会进入Layout和Paint的流程。而真正的绘制和布局过程，则完全交由RenderObject完成：</p><pre><code>abstract class RenderObject extends AbstractNode with DiagnosticableTreeMixin implements HitTestTarget {\n  ...\n  void layout(Constraints constraints, { bool parentUsesSize = false }) {...}\n  \n  void paint(PaintingContext context, Offset offset) { }\n}\n</code></pre><p>布局和绘制完成后，接下来的事情就交给Skia了。在VSync信号同步时直接从渲染树合成Bitmap，然后提交给GPU。这部分内容，我已经在之前的“<a href=\"https://time.geekbang.org/column/article/105703\">Flutter区别于其他方案的关键技术是什么</a>？”中与你介绍过了，这里就不再赘述了。</p><p>接下来，我以下面的界面示例为例，与你说明Widget、Element与RenderObject在渲染过程中的关系。在下面的例子中，一个Row容器放置了4个子Widget，左边是Image，而右边则是一个Column容器下排布的两个Text。</p><p><img src=\"https://static001.geekbang.org/resource/image/f4/b9/f4d2ac98728cf4f24b0237958d0ce0b9.png?wh=422*222\" alt=\"\"></p><center><span class=\"reference\">图3 界面示例</span></center><p>那么，在Flutter遍历完Widget树，创建了各个子Widget对应的Element的同时，也创建了与之关联的、负责实际布局和绘制的RenderObject。</p><p><img src=\"https://static001.geekbang.org/resource/image/35/6d/3536bd7bc00b42b220ce18ba86c2a26d.png?wh=1622*448\" alt=\"\"></p><center><span class=\"reference\">图4 示例界面生成的“三棵树”</span></center><h2>总结</h2><p>好了，今天关于Widget的设计思路和基本原理的介绍，我们就先进行到这里。接下来，我们一起回顾下今天的主要内容吧。</p><p>首先，我与你介绍了Widget渲染过程，学习了在Flutter中视图数据的组织和渲染抽象的三个核心概念，即Widget、 Element和RenderObject。</p><p>其中，Widget是Flutter世界里对视图的一种结构化描述，里面存储的是有关视图渲染的配置信息；Element则是Widget的一个实例化对象，将Widget树的变化做了抽象，能够做到只将真正需要修改的部分同步到真实的Render Object树中，最大程度地优化了从结构化的配置信息到完成最终渲染的过程；而RenderObject，则负责实现视图的最终呈现，通过布局、绘制完成界面的展示。</p><p>最后，在对Flutter Widget渲染过程有了一定认识后，我带你阅读了RenderObjectWidget的代码，理解Widget、Element与RenderObject这三个对象之间是如何互相配合，实现图形渲染工作的。</p><p>熟悉了Widget、Element与RenderObject这三个概念，相信你已经对组件的渲染过程有了一个清晰而完整的认识。这样，我们后续再学习常用的组件和布局时，就能够从不同的视角去思考框架设计的合理性了。</p><p>不过在日常开发学习中，绝大多数情况下，我们只需要了解各种Widget特性及使用方法，而无需关心Element及RenderObject。因为Flutter已经帮我们做了大量优化工作，因此我们只需要在上层代码完成各类Widget的组装配置，其他的事情完全交给Flutter就可以了。</p><h2>思考题</h2><p>你是如何理解Widget、Element和RenderObject这三个概念的？它们之间是一一对应的吗？你能否在Android/iOS/Web中找到对应的概念呢？</p><p>欢迎你在评论区给我留言分享你的观点，我会在下一篇文章中等待你！感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p><p></p>","neighbors":{"left":{"article_title":"08 | 综合案例：掌握Dart核心特性","id":107315},"right":{"article_title":"10 | Widget中的State到底是什么？","id":108576}},"comments":[{"had_liked":false,"id":115059,"user_name":"竹之同学","can_delete":false,"product_type":"c1","uid":1426358,"ip_address":"","ucode":"00A322BE03D348","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLBKSykSmNnspVs5OvAUGLecibeiczo7sQYJ4XoJXNa2jWUwvwiaHz8yM3iak0ErUSUIJrGfzNUJ7P79Rg/132","comment_is_top":false,"comment_ctime":1563463846,"is_pvip":false,"replies":[{"id":"42021","content":"赞","user_name":"作者回复","comment_id":115059,"uid":"1088582","ip_address":"","utype":1,"ctime":1563469795,"user_name_real":"土豆盒子"}],"discussion_count":1,"race_medal":0,"score":"259261501606","product_id":100031001,"comment_content":"如果用 Vue 来比喻的话，Widget 就是 Vue 的 template；Element 就是 virtual DOM；RenderObject 就是DOM，不知道这种想法对不？","like_count":61,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458948,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563469795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115214,"user_name":"大土豆","can_delete":false,"product_type":"c1","uid":1121636,"ip_address":"","ucode":"67445DC3EC9DB0","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/64/52a5863b.jpg","comment_is_top":false,"comment_ctime":1563509369,"is_pvip":true,"replies":[{"id":"42187","content":"赞","user_name":"作者回复","comment_id":115214,"uid":"1088582","ip_address":"","utype":1,"ctime":1563554255,"user_name_real":"土豆盒子"}],"discussion_count":2,"race_medal":0,"score":"96052789881","product_id":100031001,"comment_content":"React：JSX-&gt;虚拟DOM-&gt;浏览器DOM<br>React Native：JSX-&gt;虚拟DOM-&gt;Android&#47;iOS原生控件<br>flutter：Widget-&gt;Element（类似虚拟DOM，只是一种数据结构）-&gt; RenderObject 交给底层渲染<br>","like_count":23,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459013,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563554255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1138560,"avatar":"https://static001.geekbang.org/account/avatar/00/11/5f/80/51269d88.jpg","nickname":"Hurry","note":"","ucode":"12FEE2A50CC667","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75896,"discussion_content":"啥时候这个widget可以变成类似于jsx的语法糖，就完美了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575794130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222300,"user_name":"六号先生117","can_delete":false,"product_type":"c1","uid":1005232,"ip_address":"","ucode":"F5AA9A6CE32EBD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/56/b0/5f5ec445.jpg","comment_is_top":false,"comment_ctime":1590741072,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"66015250512","product_id":100031001,"comment_content":"推荐一篇好文，读完之后回头再翻这一篇很容易理解了。https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;6ckRnyAALbCsXfZu56kTDw","like_count":16},{"had_liked":false,"id":114865,"user_name":"KrystalJake","can_delete":false,"product_type":"c1","uid":1151469,"ip_address":"","ucode":"C8F72FD349AD04","user_header":"https://static001.geekbang.org/account/avatar/00/11/91/ed/a0d244bb.jpg","comment_is_top":false,"comment_ctime":1563420082,"is_pvip":false,"replies":[{"id":"42020","content":"Element是可复用的，只要Widget前后类型一样。比如Widget是蓝色的，重建后变红色了，Element是会复用的。所以是多个Widget（销毁前后）会对应一个Element","user_name":"作者回复","comment_id":114865,"uid":"1088582","ip_address":"","utype":1,"ctime":1563469720,"user_name_real":"土豆盒子"}],"discussion_count":3,"race_medal":0,"score":"57397994930","product_id":100031001,"comment_content":"您好：<br>我看有的文档(flutter in action)会说一个Widget会对应多个Element，因为Element是根据Widget创建的，您的分享里说一个渲染点对应可能对应多个Widget，还是不太理解Widget，Element，RenderObject之间的关系，什么情况下一对一，一对多或多对一，希望能详细讲解一下，谢谢","like_count":13,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458851,"discussion_content":"Element是可复用的，只要Widget前后类型一样。比如Widget是蓝色的，重建后变红色了，Element是会复用的。所以是多个Widget（销毁前后）会对应一个Element","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563469720,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1636003,"avatar":"https://static001.geekbang.org/account/avatar/00/18/f6/a3/b00c0289.jpg","nickname":"*o呮啙辷唸","note":"","ucode":"6B30C26E5505AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":535907,"discussion_content":"！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638603305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":458851,"ip_address":""},"score":535907,"extra":""}]},{"author":{"id":1083238,"avatar":"https://static001.geekbang.org/account/avatar/00/10/87/66/31629628.jpg","nickname":"MaO","note":"","ucode":"3D839733E87435","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":67918,"discussion_content":"这种复用是框架自动检测出来的吗？\n比如一开始是蓝色的Widget，后来重建了一个红色的Widget，框架是怎么识别应该复用之前那个Element？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575188781,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115241,"user_name":"puppy_love","can_delete":false,"product_type":"c1","uid":1377496,"ip_address":"","ucode":"CAADEED7433B44","user_header":"https://static001.geekbang.org/account/avatar/00/15/04/d8/21885ced.jpg","comment_is_top":false,"comment_ctime":1563516645,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"53103124197","product_id":100031001,"comment_content":"flutter渲染原理相关文章看了太多了，但是大部分都是根据图一的flutter架构图重复描述（就好像Android的架构图反复叙述没有意义），刚开始看到这张图的时候以为又是一篇雷同文章，没想到后面的阐述这么清晰生动，让我对flutter的渲染原理有了一个立体的理解，也对flutter更有信心了","like_count":12},{"had_liked":false,"id":172332,"user_name":"樊不烦","can_delete":false,"product_type":"c1","uid":1351816,"ip_address":"","ucode":"07182A8CCFA169","user_header":"https://static001.geekbang.org/account/avatar/00/14/a0/88/a4ffd85e.jpg","comment_is_top":false,"comment_ctime":1579156253,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35938894621","product_id":100031001,"comment_content":"在iOS中，感觉没有Widget对应的概念，它更像是每个UIView控件中的属性，而Element就相当于UIView，RenderObject就像是CALayer。因为Widget是只读的所以当我们修改某一属性的时候就会重新生成一个Widget，然后在对应的Element中去更新，就相当于更新UIView中的属性，然后在通过RenderObject也就是类似于CALayer的去重新计算和布局。请问老师不知道我理解的是否有偏差","like_count":9},{"had_liked":false,"id":114835,"user_name":"丁某某","can_delete":false,"product_type":"c1","uid":1134357,"ip_address":"","ucode":"F7E9478D9998DB","user_header":"https://static001.geekbang.org/account/avatar/00/11/4f/15/463fcaf1.jpg","comment_is_top":false,"comment_ctime":1563414580,"is_pvip":false,"replies":[{"id":"42016","content":"变了就销毁重建","user_name":"作者回复","comment_id":114835,"uid":"1088582","ip_address":"","utype":1,"ctime":1563469363,"user_name_real":"土豆盒子"}],"discussion_count":1,"race_medal":0,"score":"35923152948","product_id":100031001,"comment_content":"flutter 将Widget设计成不可变，怎么理解？","like_count":9,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458837,"discussion_content":"变了就销毁重建","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563469363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":116070,"user_name":"加温后的啤酒","can_delete":false,"product_type":"c1","uid":1344488,"ip_address":"","ucode":"5F30978CDB1606","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/e8/f726c635.jpg","comment_is_top":false,"comment_ctime":1563780949,"is_pvip":false,"replies":[{"id":"42592","content":"可以这么理解","user_name":"作者回复","comment_id":116070,"uid":"1088582","ip_address":"","utype":1,"ctime":1563856299,"user_name_real":"土豆盒子"}],"discussion_count":1,"race_medal":0,"score":"31628552021","product_id":100031001,"comment_content":"在iOS中，UIView相当于Element，CALayer相当于renderObject。 老师 我的理解对吗？","like_count":7,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459371,"discussion_content":"可以这么理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563856299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114830,"user_name":"Keep-Moving","can_delete":false,"product_type":"c1","uid":1182631,"ip_address":"","ucode":"76F33C06E07A27","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/a7/6ef32187.jpg","comment_is_top":false,"comment_ctime":1563413371,"is_pvip":false,"replies":[{"id":"42017","content":"绘制侧重绘图命令（GPU前），渲染侧重最终呈现（GPU后）","user_name":"作者回复","comment_id":114830,"uid":"1088582","ip_address":"","utype":1,"ctime":1563469432,"user_name_real":"土豆盒子"}],"discussion_count":1,"race_medal":0,"score":"23038249851","product_id":100031001,"comment_content":"文中提到的绘制和渲染的区别是什么呢？","like_count":6,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458834,"discussion_content":"绘制侧重绘图命令（GPU前），渲染侧重最终呈现（GPU后）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563469432,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133220,"user_name":"Tony","can_delete":false,"product_type":"c1","uid":1236087,"ip_address":"","ucode":"4CB4DBD048CD63","user_header":"https://static001.geekbang.org/account/avatar/00/12/dc/77/05b119eb.jpg","comment_is_top":false,"comment_ctime":1568449440,"is_pvip":false,"replies":[{"id":"52430","content":"两层意思：1.表示Widget是一个配置，Element才是最终的对象；2.Element是通过遍历Widget树时，调用Widget的方法创建的","user_name":"作者回复","comment_id":133220,"uid":"1088582","ip_address":"","utype":1,"ctime":1569498941,"user_name_real":"土豆盒子"}],"discussion_count":1,"race_medal":0,"score":"18748318624","product_id":100031001,"comment_content":"Element 则是 Widget 的一个实例化对象是什么含义","like_count":4,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467301,"discussion_content":"两层意思：1.表示Widget是一个配置，Element才是最终的对象；2.Element是通过遍历Widget树时，调用Widget的方法创建的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569498941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114823,"user_name":"Paradise","can_delete":false,"product_type":"c1","uid":1456728,"ip_address":"","ucode":"BF960407E87878","user_header":"https://static001.geekbang.org/account/avatar/00/16/3a/58/494a6aca.jpg","comment_is_top":false,"comment_ctime":1563412436,"is_pvip":false,"replies":[{"id":"42019","content":"前半部分不对哈。Element是可复用的，只要Widget前后类型一样。比如Widget是蓝色的，重建后变红色了，Element是会复用的。所以是多个Widget（销毁前后）会对应一个Element","user_name":"作者回复","comment_id":114823,"uid":"1088582","ip_address":"","utype":1,"ctime":1563469693,"user_name_real":"土豆盒子"}],"discussion_count":1,"race_medal":0,"score":"18743281620","product_id":100031001,"comment_content":"一个Widget可以对应多个Element，因为Widget是不可变的配置信息，而一个Element对应一个RenderObject","like_count":4,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458828,"discussion_content":"前半部分不对哈。Element是可复用的，只要Widget前后类型一样。比如Widget是蓝色的，重建后变红色了，Element是会复用的。所以是多个Widget（销毁前后）会对应一个Element","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563469693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115003,"user_name":"Longwei243","can_delete":false,"product_type":"c1","uid":1023476,"ip_address":"","ucode":"3326F04A3DFD35","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9d/f4/7d74c9bb.jpg","comment_is_top":false,"comment_ctime":1563448526,"is_pvip":false,"replies":[{"id":"42024","content":"ScrollController确实还不支持，可以关注下这个issue：https:&#47;&#47;github.com&#47;flutter&#47;flutter&#47;issues&#47;12319","user_name":"作者回复","comment_id":115003,"uid":"1088582","ip_address":"","utype":1,"ctime":1563470910,"user_name_real":"土豆盒子"}],"discussion_count":1,"race_medal":0,"score":"14448350414","product_id":100031001,"comment_content":"listview想要通过代码滑动到某个item有什么办法吗？item的高度都是不固定的","like_count":3,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458922,"discussion_content":"ScrollController确实还不支持，可以关注下这个issue：https://github.com/flutter/flutter/issues/12319","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563470910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":116783,"user_name":"mαnajay","can_delete":false,"product_type":"c1","uid":1067450,"ip_address":"","ucode":"6DE9FBD1BEC8AD","user_header":"https://static001.geekbang.org/account/avatar/00/10/49/ba/23c9246a.jpg","comment_is_top":false,"comment_ctime":1563926541,"is_pvip":false,"replies":[{"id":"42866","content":"这块RenderObject帮你自动做了，一般情况下不需要管这么底层的渲染机制。","user_name":"作者回复","comment_id":116783,"uid":"1088582","ip_address":"","utype":1,"ctime":1563981747,"user_name_real":"土豆盒子"}],"discussion_count":1,"race_medal":0,"score":"10153861133","product_id":100031001,"comment_content":"我想问下 flutter 关于GPU 离屏渲染 这块有和iOS之类的不一样的地方吗？ <br>比如圆角 ，阴影， mask ，不透明多层合并 等 处理","like_count":2,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459684,"discussion_content":"这块RenderObject帮你自动做了，一般情况下不需要管这么底层的渲染机制。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563981747,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166851,"user_name":"MaO","can_delete":false,"product_type":"c1","uid":1083238,"ip_address":"","ucode":"3D839733E87435","user_header":"https://static001.geekbang.org/account/avatar/00/10/87/66/31629628.jpg","comment_is_top":false,"comment_ctime":1577614584,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5872581880","product_id":100031001,"comment_content":"如果 Widget 的配置数据发生了改变，那么持有该 Widget 的 Element 节点也会被标记为 dirty。在下一个周期的绘制时，Flutter 就会触发 Element 树的更新，并使用最新的 Widget 数据更新自身以及关联的 RenderObject 对象<br><br>-----？<br>这个知识点有更详细的参考资料吗？","like_count":1},{"had_liked":false,"id":127071,"user_name":"这得从我捡到一个鼠标垫开始说起","can_delete":false,"product_type":"c1","uid":1272321,"ip_address":"","ucode":"2FF4347B4E7A9B","user_header":"https://static001.geekbang.org/account/avatar/00/13/6a/01/d9cb531d.jpg","comment_is_top":false,"comment_ctime":1566549962,"is_pvip":true,"replies":[{"id":"47647","content":"Widget和Element是一一对应的，RenderObject不是，只有实际需要布局和绘制的控件才会有RenderObject，参考文中对RenderObjectWidget的源码分析","user_name":"作者回复","comment_id":127071,"uid":"1088582","ip_address":"","utype":1,"ctime":1566893237,"user_name_real":"土豆盒子"}],"discussion_count":3,"race_medal":0,"score":"5861517258","product_id":100031001,"comment_content":"你是如何理解 Widget、Element 和 Render？<br>答：Widget描述了整个布局，从而构建出一棵树。flutter遍历这棵树的每一个widget，从而构造出对应的Element对象，Element对象再构造出对应的RenderObject对象。由于Widget是不可变的，而Element可变。每当Widget变化的时候，这个Widget会被重新创建，Element发现Widget重新创建后，就改变自身对应的部分同时也改变RenderObject对应的部分。通过阅读这篇文章，我的理解是，他们确实是一一对应的。","like_count":1,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464305,"discussion_content":"Widget和Element是一一对应的，RenderObject不是，只有实际需要布局和绘制的控件才会有RenderObject，参考文中对RenderObjectWidget的源码分析","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566893237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1334176,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKuBRnCydBSIAcT4Gwxeha4icNWYmC8PoREohZuq6GB97wBVV0vvGoTG9fwicowOQhJLicZBXyDIH2Gw/132","nickname":"夏季的雪","note":"","ucode":"1ED315F5CE4E3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375738,"discussion_content":"只有实际需要布局和绘制的控件才会有RenderObject是什么意思，不太明白？还有不需要布局和绘制的控件吗？每个空控件最终都会通过布局和绘制显示到屏幕上啊？希望老师能帮助解答疑惑，谢谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621837925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1636003,"avatar":"https://static001.geekbang.org/account/avatar/00/18/f6/a3/b00c0289.jpg","nickname":"*o呮啙辷唸","note":"","ucode":"6B30C26E5505AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1334176,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKuBRnCydBSIAcT4Gwxeha4icNWYmC8PoREohZuq6GB97wBVV0vvGoTG9fwicowOQhJLicZBXyDIH2Gw/132","nickname":"夏季的雪","note":"","ucode":"1ED315F5CE4E3A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535909,"discussion_content":"有的，比方说点击事件也是一个widget","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638603429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":375738,"ip_address":""},"score":535909,"extra":""}]}]},{"had_liked":false,"id":115816,"user_name":"davidzhou","can_delete":false,"product_type":"c1","uid":1018904,"ip_address":"","ucode":"F4B2929F4111DC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/18/7cbc34eb.jpg","comment_is_top":false,"comment_ctime":1563754502,"is_pvip":false,"replies":[{"id":"42593","content":"UIKit其实没有widget这一层","user_name":"作者回复","comment_id":115816,"uid":"1088582","ip_address":"","utype":1,"ctime":1563856337,"user_name_real":"土豆盒子"}],"discussion_count":1,"race_medal":0,"score":"5858721798","product_id":100031001,"comment_content":"在iOS里面UIKit的UIView，对应widget，core animation的CALayer对应element，core graphics的context对应renderobject，不知道有没有理解到位","like_count":1,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459300,"discussion_content":"UIKit其实没有widget这一层","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563856337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300183,"user_name":"Jagtu","can_delete":false,"product_type":"c1","uid":1297203,"ip_address":"","ucode":"0B4BE045FE3041","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/fnuh61CTYT2ql6YkbLrOSZuYZqU7sDZcjeEF5llEIdMOVeuktkaibibBrt30V5fjNrtpruy8suqHiawnHzlcvc7wA/132","comment_is_top":false,"comment_ctime":1625038087,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1625038087","product_id":100031001,"comment_content":"不懂就问，Widget 的不可变性为什么能使渲染节点复用？","like_count":0,"discussions":[{"author":{"id":1887261,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/cc/1d/3c0272a1.jpg","nickname":"abc🙂","note":"","ucode":"FCF2B9091D161B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558853,"discussion_content":"Immutable使得widget转化成element变成纯函数，可预测，如果widget带走状态，内存地址不变，就很难比对新旧状态的差异","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648486605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250201,"user_name":"jayce","can_delete":false,"product_type":"c1","uid":1330907,"ip_address":"","ucode":"70ACD13415EA8F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epk6XJfVGqsW1b5oiatsuvSRkCF4yo2KxSUSf5LHRRTbuCPKJrRiblqRbMZBuicQMgDTO1bRp6vXW7Lg/132","comment_is_top":false,"comment_ctime":1600983263,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600983263","product_id":100031001,"comment_content":"Android而言，Widget相当于View每帧的配置属性，Element相当于View layout, measure draw逻辑, RenderObject 相当于Canvas？","like_count":0},{"had_liked":false,"id":248128,"user_name":"Geeker","can_delete":false,"product_type":"c1","uid":1896510,"ip_address":"","ucode":"937B190AE0EC6F","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f0/3e/f9f021bf.jpg","comment_is_top":false,"comment_ctime":1600041131,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600041131","product_id":100031001,"comment_content":"深入浅出不容易，老师把握的好！感谢谢！","like_count":0},{"had_liked":false,"id":245942,"user_name":"许先森","can_delete":false,"product_type":"c1","uid":1795371,"ip_address":"","ucode":"1F42D4A6B5C6AF","user_header":"https://static001.geekbang.org/account/avatar/00/1b/65/2b/446ef7b6.jpg","comment_is_top":false,"comment_ctime":1599116973,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1599116973","product_id":100031001,"comment_content":"还是不太明白Widget存在的意义，Element中有Widget和RenderObject，抽象点说Widget不变和变化的部分Element完全都知道，为什么还需要Widget？只有Element和RenderObject就好了呀，只是为了结构分层吗？<br>Widget、Element、RenderObject分别对应安卓中的什么呢？是下面这样吗：<br>安卓中Widget：(UI控件)、Element：(UI控件在内存中的实例)、RenderObject：（CPU通过opengl操作GPU）？","like_count":0,"discussions":[{"author":{"id":2161498,"avatar":"","nickname":"七七不说话","note":"","ucode":"B62B9A517CD7FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304083,"discussion_content":"俺也没明白.....","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599464470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244270,"user_name":"西钾钾","can_delete":false,"product_type":"c1","uid":1097722,"ip_address":"","ucode":"0EE77083636ED9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJV27QOK57cdpdh3E4hbArCOlccdtjCyWooF9fhjeSKAMo9SN1v9RODkrZUZD4RejjbdsqU2FIeMA/132","comment_is_top":false,"comment_ctime":1598447249,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598447249","product_id":100031001,"comment_content":"老师有个疑问：可以将Element理解成实现statefulwidget必要的产物么？因为对于statelesswidget本身就是不变的，完全可以对应到renderobject上。","like_count":0},{"had_liked":false,"id":230199,"user_name":"Geek_d7ea11","can_delete":false,"product_type":"c1","uid":1603717,"ip_address":"","ucode":"0FEF691CF21C79","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIBC94guaFqiaSlFhyibfo6kySHPqJCfQKzzz8JwumEMGiaVDfXJTbFAMK4vS6t9UJib4S8icmtsd7NAsg/132","comment_is_top":false,"comment_ctime":1593309152,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593309152","product_id":100031001,"comment_content":"当Widget创建时会生成与之对应的Element(Element可复用，所以可能出现WIdget多对一Element）,其中需要绘制渲染的Widget节点会在Element中被标记为dirty,创建RenderingObject来进行layout 和paint.","like_count":0},{"had_liked":false,"id":230113,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1783603,"ip_address":"","ucode":"25439BAAEEF8FA","user_header":"https://static001.geekbang.org/account/avatar/00/1b/37/33/7425bd10.jpg","comment_is_top":false,"comment_ctime":1593266605,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1593266605","product_id":100031001,"comment_content":"“如果 Widget 的配置数据发生了改变，那么持有该 Widget 的 Element 节点也会被标记为 dirty。 ”<br><br>这一步是具体怎么实现的呢？<br><br>其中 Widget 树中某个或者多个节点发生变化时，该节点及其子节点是都会被销毁重建吗？如果是的话，对应的 Element 树节点及其子节点是不是都需要标记为 dirty 或者某种状态？待 Widget树重建后，开始从有标记的 Element 树开始遍历对比对应的 widget ，如果没有变化则取消标记，有变化则标记为 dirty；如果不需要全部标记，Element 树是如何感知 Widget 树重建前后的变化的。","like_count":0,"discussions":[{"author":{"id":1603717,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIBC94guaFqiaSlFhyibfo6kySHPqJCfQKzzz8JwumEMGiaVDfXJTbFAMK4vS6t9UJib4S8icmtsd7NAsg/132","nickname":"Geek_d7ea11","note":"","ucode":"0FEF691CF21C79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286847,"discussion_content":"这里面有个边界概念，Boundary。如果当前节点发生变化的时候，确实其子节点也会重绘，这时候可以手动的加入Boundary来 提示系统这部分不需要跟着上面节点重绘。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593309345,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1783603,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/37/33/7425bd10.jpg","nickname":"Jason","note":"","ucode":"25439BAAEEF8FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1603717,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIBC94guaFqiaSlFhyibfo6kySHPqJCfQKzzz8JwumEMGiaVDfXJTbFAMK4vS6t9UJib4S8icmtsd7NAsg/132","nickname":"Geek_d7ea11","note":"","ucode":"0FEF691CF21C79","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286862,"discussion_content":"应该不会完全重绘吧，Element 树会计算 diff，只绘制有变化的部分","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593313007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":286847,"ip_address":""},"score":286862,"extra":""}]}]},{"had_liked":false,"id":226567,"user_name":"Y.L.","can_delete":false,"product_type":"c1","uid":1454614,"ip_address":"","ucode":"52AFB6D564811E","user_header":"https://static001.geekbang.org/account/avatar/00/16/32/16/2dd59936.jpg","comment_is_top":false,"comment_ctime":1592142727,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592142727","product_id":100031001,"comment_content":"在一个真实的渲染树中可能存在不同的 Widget 对应同一个渲染节点的情况，陈老师这句话不太明白，能举例说明一下吗","like_count":0},{"had_liked":false,"id":224646,"user_name":"Ying","can_delete":false,"product_type":"c1","uid":1110414,"ip_address":"","ucode":"BC35B2A63AA12F","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/8e/bf53c3be.jpg","comment_is_top":false,"comment_ctime":1591496191,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591496191","product_id":100031001,"comment_content":"在iOS中,widget这层感觉找不到对应的概念, Element可以对应UIView, RenderObject应该可以对应Layer层","like_count":0},{"had_liked":false,"id":215097,"user_name":"涛","can_delete":false,"product_type":"c1","uid":1085100,"ip_address":"","ucode":"92263D02C543E1","user_header":"https://static001.geekbang.org/account/avatar/00/10/8e/ac/24fc311b.jpg","comment_is_top":false,"comment_ctime":1588904129,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588904129","product_id":100031001,"comment_content":"有个疑问求回复：按照本文的理解，如果我更新了最上层的widget，是不是对应的整个RenderObject树也都得更新？这一点有点不理解。另外，Element是如何做到只更新需要更新的部分的呢？","like_count":0},{"had_liked":false,"id":204371,"user_name":"凡","can_delete":false,"product_type":"c1","uid":1041878,"ip_address":"","ucode":"BCF83BE1D434D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e5/d6/37a1be71.jpg","comment_is_top":false,"comment_ctime":1586393171,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586393171","product_id":100031001,"comment_content":"感觉在iOS中，widget有点像NSObject的意思，element有点类似UIView，RenderObject有点类似CALayer。","like_count":0},{"had_liked":false,"id":194294,"user_name":"","can_delete":false,"product_type":"c1","uid":1652072,"ip_address":"","ucode":"","user_header":"","comment_is_top":false,"comment_ctime":1585046773,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585046773","product_id":100031001,"comment_content":"RenderObjectWidget既然不负责这些对象的创建与更新。那么存在的意义是什么？<br>","like_count":0},{"had_liked":false,"id":180465,"user_name":"MaO","can_delete":false,"product_type":"c1","uid":1083238,"ip_address":"","ucode":"3D839733E87435","user_header":"https://static001.geekbang.org/account/avatar/00/10/87/66/31629628.jpg","comment_is_top":false,"comment_ctime":1582288986,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582288986","product_id":100031001,"comment_content":"statefulwidget可以嵌套吗","like_count":0},{"had_liked":false,"id":179258,"user_name":"Geek_473879","can_delete":false,"product_type":"c1","uid":1843920,"ip_address":"","ucode":"D7F4C74F6D0030","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7h2t7ZmOZEpzazicoHF0ricTvaObicQCYZpolMz38tnPzcV1KywglcTibf6yPY0JLc4PWA3LtapgJKg/132","comment_is_top":false,"comment_ctime":1581946712,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581946712","product_id":100031001,"comment_content":"Element是可复用的，只要Widget前后类型一样。比如Widget是蓝色的，重建后变红色了，Element是会复用的。所以是多个Widget（销毁前后）会对应一个Element ，这个不是很懂。","like_count":0},{"had_liked":false,"id":175709,"user_name":"Jersey、","can_delete":false,"product_type":"c1","uid":1358381,"ip_address":"","ucode":"53985C9B1CF73E","user_header":"https://static001.geekbang.org/account/avatar/00/14/ba/2d/e0339b0a.jpg","comment_is_top":false,"comment_ctime":1580804800,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1580804800","product_id":100031001,"comment_content":"下面是自己读这篇文章过程时,产生的疑问和思考之后得出的论述, 不知道是否合理。<br>疑问:<br>1. Widget 不可变的设计原因？<br>2. 为什么需要引入 Element , 并将其设计成可变性来解决 Widget 重建和销毁带来的性能消耗？<br>3. Widget 与 Element 是如何配合工作的, 来降低视图更新带来性能消耗？<br>论述: <br>Widget 是一颗不可变的模型树<br>Element 是一颗可变的中间层树, 它才是真正会影响到 RenderObject(最终渲染树)结果的数据<br><br>Element 的出现主要是为了降低 Widget 树改变时需要消耗和重建而直接导致 RenderObject 树的变化, 也需要面临重建和销毁的性能影响。<br>在引入 Element 树之前, 当 Widget 需要改变时,由于其不可变性需要经过销毁和重建, 然后直接触发 RenderObject 树的更新, 对于性能来说这样损耗相对较大。<br>在引入了 Element 树之后, 当 Widget  需要改变时, 其必须要经过销毁和重建的过程(但是其又是比较轻量级的数据类型, 在性能权衡方面做取舍是非常正确的), 这点也充分体现了将 Widget 设计成不可变的依据。<br>由于 Element 树的存在, 直到 Widget 完成重建销毁过程之后, 其会对原有 Element 进行 Diff, 然后在对 Diff 结果进行最低程度修改的方式，去更新 RenderObject 这颗真是渲染树, 这样以来相对未引入 Element 树的设计要优秀很多。<br><br>","like_count":0,"discussions":[{"author":{"id":1044793,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f1/39/768503ad.jpg","nickname":"钱洋彪","note":"","ucode":"84FBB0E48FD885","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":210532,"discussion_content":"关于1:Widget不可变的设计原因，我的理解是：这就好比函数的值传递和引用传递一样，如果是值传递，其他输入参数一样，那么输出一定一样，如果是引用传递，其他输入参数一样，输出并不一定一样。所以如果Widget设计成了可变，那么State一样，并不能确保渲染出来的Widget长的一样，而Widget设计成不可变，那么State一样，渲染就一定一样。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584750972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153259,"user_name":"满大大","can_delete":false,"product_type":"c1","uid":1170022,"ip_address":"","ucode":"06DE739A6CE9EF","user_header":"https://static001.geekbang.org/account/avatar/00/11/da/66/5858322e.jpg","comment_is_top":false,"comment_ctime":1574209060,"is_pvip":true,"replies":[{"id":"59802","content":"RenderObjectWidget是渲染的起点，也是这些对象的载体啊。它自己不负责他们的创建和更新，但是提供了创建和更新的方法让框架在合适的时机调用<br>","user_name":"作者回复","user_name_real":"土豆盒子","uid":"1088582","ctime":1574755820,"ip_address":"","comment_id":153259,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1574209060","product_id":100031001,"comment_content":"RenderObjectWidget 本身并不负责这些对象的创建与更新，拿它有啥用啊","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475098,"discussion_content":"RenderObjectWidget是渲染的起点，也是这些对象的载体啊。它自己不负责他们的创建和更新，但是提供了创建和更新的方法让框架在合适的时机调用\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574755820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1603717,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIBC94guaFqiaSlFhyibfo6kySHPqJCfQKzzz8JwumEMGiaVDfXJTbFAMK4vS6t9UJib4S8icmtsd7NAsg/132","nickname":"Geek_d7ea11","note":"","ucode":"0FEF691CF21C79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286850,"discussion_content":"它负责实际渲染，Widget只包含视图的属性信息（颜色等），Element是接收变化部分的，处理变化，需要渲染的部分交给RenderObject","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593309939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146052,"user_name":"outman","can_delete":false,"product_type":"c1","uid":1673639,"ip_address":"","ucode":"2A520B3204ECE9","user_header":"https://static001.geekbang.org/account/avatar/00/19/89/a7/82827b76.jpg","comment_is_top":false,"comment_ctime":1572425132,"is_pvip":false,"replies":[{"id":"58823","content":"交给build中返回的那个Widget去做布局&#47;绘制","user_name":"作者回复","user_name_real":"土豆盒子","uid":"1088582","ctime":1574164502,"ip_address":"","comment_id":146052,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572425132","product_id":100031001,"comment_content":"请教个问题。RenderObjectWidget是通过RenderObject来进行布局绘制。那么继承StatefulWidget&#47;StatelessWidget的，是怎么进行布局绘制的呢，他们会创建ComponentElement，而不是RenderObjectElement，好像不会创建RenderObject。","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472690,"discussion_content":"交给build中返回的那个Widget去做布局/绘制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574164502,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142191,"user_name":"xuelian","can_delete":false,"product_type":"c1","uid":1273382,"ip_address":"","ucode":"4D5209C28BB6FB","user_header":"https://static001.geekbang.org/account/avatar/00/13/6e/26/255d1935.jpg","comment_is_top":false,"comment_ctime":1571307481,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571307481","product_id":100031001,"comment_content":"举个例子,我准备写自定义的navagationBar,开始用的bottomBar,他的children需要是Widget.Flutter中的Button是不带文字+图片的,所以想到用navagationBarItem.但是报错了,说type不是Widget.这在iOS中他们都是UIView,这说明Widget不是单纯对应View.总的来说他是一个狭义上的“对象”,如老师上面说一切皆Widget,和React的一切皆组件一样,都是被特殊定义的“对象”.","like_count":0},{"had_liked":false,"id":140464,"user_name":"欢乐的小马驹","can_delete":false,"product_type":"c1","uid":1078951,"ip_address":"","ucode":"B594106688CEE7","user_header":"https://static001.geekbang.org/account/avatar/00/10/76/a7/374e86a7.jpg","comment_is_top":false,"comment_ctime":1570952746,"is_pvip":false,"replies":[{"id":"56184","content":"按照这个标准他俩对应Element更合适","user_name":"作者回复","user_name_real":"土豆盒子","uid":"1088582","ctime":1572320702,"ip_address":"","comment_id":140464,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570952746","product_id":100031001,"comment_content":"iOS中，大部分情况没有Widhet。但是NavigationBar对应Element，NavigationBarItem对应Widget。可以这样理解吗？老师","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470400,"discussion_content":"按照这个标准他俩对应Element更合适","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572320702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138319,"user_name":"雷声大","can_delete":false,"product_type":"c1","uid":1235883,"ip_address":"","ucode":"3159C97CBB7575","user_header":"https://static001.geekbang.org/account/avatar/00/12/db/ab/981ca927.jpg","comment_is_top":false,"comment_ctime":1570161310,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570161310","product_id":100031001,"comment_content":"Flutter UI的理念更偏向前端框架， 终端从来没这么搞过","like_count":0},{"had_liked":false,"id":130140,"user_name":"夜色下云淡风轻","can_delete":false,"product_type":"c1","uid":1270969,"ip_address":"","ucode":"59C1656AED4792","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/XktNguBOU1CyXt2QoNtY6TAHnfA1QEqXZmdn7whTZggeKSiaibnbRwnHR1T1XqPDQrVJDbUicFw4bXBzlNby71a1g/132","comment_is_top":false,"comment_ctime":1567389654,"is_pvip":false,"replies":[{"id":"48902","content":"大部分对；Element主要是做复用判断的，所以每个Widget都有Element，RenderObject只有可视的控件才有","user_name":"作者回复","user_name_real":"土豆盒子","uid":"1088582","ctime":1567511446,"ip_address":"","comment_id":130140,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567389654","product_id":100031001,"comment_content":"有界面的Widget会生成Element，Element生成对应的RenderObject进行实际的布局绘制工作；而如果没有界面就不会生成Element自然也就没有RenderObject，Element和RenderObject必定是对应的这样理解对吗？","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465828,"discussion_content":"大部分对；Element主要是做复用判断的，所以每个Widget都有Element，RenderObject只有可视的控件才有","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567511446,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126627,"user_name":"张简","can_delete":false,"product_type":"c1","uid":1453513,"ip_address":"","ucode":"CF3F30D412FF78","user_header":"https://static001.geekbang.org/account/avatar/00/16/2d/c9/0d8983f3.jpg","comment_is_top":false,"comment_ctime":1566438486,"is_pvip":false,"replies":[{"id":"47053","content":"可以这么理解","user_name":"作者回复","user_name_real":"土豆盒子","uid":"1088582","ctime":1566580870,"ip_address":"","comment_id":126627,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566438486","product_id":100031001,"comment_content":"widget是数据的映射，数据来源于state(可变widget)和初始化数据(不可变widget)。可以这么理解吗？","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464091,"discussion_content":"可以这么理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566580870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123971,"user_name":"🌙","can_delete":false,"product_type":"c1","uid":1606578,"ip_address":"","ucode":"D70F6C3AF8AA1B","user_header":"https://static001.geekbang.org/account/avatar/00/18/83/b2/e83dd93c.jpg","comment_is_top":false,"comment_ctime":1565785949,"is_pvip":false,"replies":[{"id":"49535","content":"element是一个介于widget与renderobject的中间类，用来进行渲染资源复用的","user_name":"作者回复","user_name_real":"土豆盒子","uid":"1088582","ctime":1567683727,"ip_address":"","comment_id":123971,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565785949","product_id":100031001,"comment_content":"widget是保存的控件的属性值吗？element是该控件对应的对象？能不能举个例子来说明一下，不是很懂","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462928,"discussion_content":"element是一个介于widget与renderobject的中间类，用来进行渲染资源复用的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567683727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115168,"user_name":"Egos","can_delete":false,"product_type":"c1","uid":1071143,"ip_address":"","ucode":"9F0055B140E935","user_header":"https://static001.geekbang.org/account/avatar/00/10/58/27/1188e017.jpg","comment_is_top":false,"comment_ctime":1563502469,"is_pvip":false,"replies":[{"id":"42188","content":"Android和iOS原生框架里其实没有Widget这一层","user_name":"作者回复","user_name_real":"土豆盒子","uid":"1088582","ctime":1563554315,"ip_address":"","comment_id":115168,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1563502469","product_id":100031001,"comment_content":"Android 里面View 相当于Widget、Window 相当于Element、Surface 相当于RenderObject。","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458997,"discussion_content":"Android和iOS原生框架里其实没有Widget这一层","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563554315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1256284,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/lTPkR3OBWyffM5zl84FYoJI8cXhibA72T1LATMwwiaia6TjVqHMLElZcSyqibyQiceic6loVvovGzicj7gRtxTIJcRzAQ/132","nickname":"bily","note":"","ucode":"365BAD99D4C1BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318644,"discussion_content":"android的xml和viem的属性配置信息我觉得可以理解为widget","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603796564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1630764,"avatar":"https://static001.geekbang.org/account/avatar/00/18/e2/2c/d35dbb77.jpg","nickname":"刘心","note":"","ucode":"724242459E0C15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220220,"discussion_content":"vc和activity相当于element，view相当于renderobject。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585841026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1270673,"avatar":"https://static001.geekbang.org/account/avatar/00/13/63/91/ce155f76.jpg","nickname":"少年游","note":"","ucode":"2804184FE06E9C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3047,"discussion_content":"Android的xml布局文件可以理解成Widget么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564132371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114889,"user_name":"吴小安","can_delete":false,"product_type":"c1","uid":1371398,"ip_address":"","ucode":"EDF8E04F867069","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqr5ibqxYwcSgqPA7s49MZb1vEKKXT4mPTojwiclXkJf3ug26NuzTa6A5gbicR2rAUHdEkUAn13Rr2KQ/132","comment_is_top":false,"comment_ctime":1563424226,"is_pvip":false,"replies":[{"id":"41945","content":"是的","user_name":"作者回复","user_name_real":"土豆盒子","uid":"1088582","ctime":1563430891,"ip_address":"","comment_id":114889,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1563424226","product_id":100031001,"comment_content":"如果 Widget 的配置数据发生了改变，那么持有该 Widget 的 Element 节点也会被标记为 dirty。 <br>widget按照文中所说widget是被element持有，那widget变化了是怎样找到对应的element？widget也持有element？","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458867,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563430891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1701883,"avatar":"","nickname":"Geek_20f143","note":"","ucode":"5D97BD5FA4A26F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72649,"discussion_content":"Widget和Element相互持有,不会循环引用吗?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575511409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114857,"user_name":"mq","can_delete":false,"product_type":"c1","uid":1594742,"ip_address":"","ucode":"B675D1E33E902C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoibW0Cougnv3Hjl8n1EWoUHloXu5lMicuPm1FcJ0qyXWEaqwXv4Z09ARaeDRicbicL9RTIXnoNARibSxw/132","comment_is_top":false,"comment_ctime":1563418437,"is_pvip":false,"replies":[{"id":"42014","content":"准确的说是数据驱动UI配置。你的UI有10个可配置项，每次改UI只需要把这些配置项同步过去就好了，系统自动帮你搞定渲染。<br><br>界面几乎一样，说明可配置项几乎一样，再抽象一层就好了。<br>","user_name":"作者回复","user_name_real":"土豆盒子","uid":"1088582","ctime":1563469178,"ip_address":"","comment_id":114857,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563418437","product_id":100031001,"comment_content":"数据驱动UI构建的话，感觉数据与UI层耦合程度会很高，是不是很难进行重用界面？如果有一个界面几乎一样，但是数据不一样的话是不是要做重复的UI？","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458847,"discussion_content":"准确的说是数据驱动UI配置。你的UI有10个可配置项，每次改UI只需要把这些配置项同步过去就好了，系统自动帮你搞定渲染。\n\n界面几乎一样，说明可配置项几乎一样，再抽象一层就好了。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563469178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114855,"user_name":"mq","can_delete":false,"product_type":"c1","uid":1594742,"ip_address":"","ucode":"B675D1E33E902C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoibW0Cougnv3Hjl8n1EWoUHloXu5lMicuPm1FcJ0qyXWEaqwXv4Z09ARaeDRicbicL9RTIXnoNARibSxw/132","comment_is_top":false,"comment_ctime":1563418294,"is_pvip":false,"replies":[{"id":"42015","content":"widget是一个配置，并不负责最终渲染，是否需要重新渲染，Flutter会在内部做diff，两个widget前后一样，就不需要渲染了。至于ListView的Cell，在Widget层面当然是要复用的，因为不同的cell配置不一样呀<br><br><br>","user_name":"作者回复","user_name_real":"土豆盒子","uid":"1088582","ctime":1563469348,"ip_address":"","comment_id":114855,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563418294","product_id":100031001,"comment_content":"widget的渲染成本很低，意思是不是说ListView中类似的Cell可以不用进行重用了？","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458846,"discussion_content":"widget是一个配置，并不负责最终渲染，是否需要重新渲染，Flutter会在内部做diff，两个widget前后一样，就不需要渲染了。至于ListView的Cell，在Widget层面当然是要复用的，因为不同的cell配置不一样呀\n\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563469348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114825,"user_name":"Miracle_","can_delete":false,"product_type":"c1","uid":1594671,"ip_address":"","ucode":"5B885163D73439","user_header":"","comment_is_top":false,"comment_ctime":1563412813,"is_pvip":false,"replies":[{"id":"42023","content":"布局叠加嵌套在任何框架上都会影响性能的哈，除非你的视图是完全不透明的，能把下层视图完全挡住，这样OpenGL就不绘制","user_name":"作者回复","user_name_real":"土豆盒子","uid":"1088582","ctime":1563470615,"ip_address":"","comment_id":114825,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563412813","product_id":100031001,"comment_content":"有一点不理解，在Android中布局叠加嵌套会影响绘制性能，为什么Flutter中叠加不会呢？","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458830,"discussion_content":"布局叠加嵌套在任何框架上都会影响性能的哈，除非你的视图是完全不透明的，能把下层视图完全挡住，这样OpenGL就不绘制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563470615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}