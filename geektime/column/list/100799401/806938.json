{"id":806938,"title":"11｜表太大了，修改表结构太慢怎么解决？（上）","content":"<p>你好，我是俊达。</p><p>平时我们使用MySQL，或多或少都会遇到DDL的需求。比如有新业务上线，需要给现有的表添加新的字段；或者需要调整索引来优化性能；或者现有的表可能存在大量碎片，需要优化表，收缩空间。</p><p>那么对现有的业务表执行各类DDL操作时，需要多少时间才能执行完成？执行的过程中是否会锁表，应用程序在DDL执行的过程中是否能正常读写数据？DDL操作是否会消耗大量资源，影响数据库的性能？特别是当操作的表特别大，或者应用系统的可用性要求特别高的时候，这些问题就特别重要。</p><p>这一讲我们就来详细地分析MySQL中各类DDL操作具体是如何执行的。如何在完成DDL的同时，尽量减少对业务系统的影响。</p><p>有些DDL只需要修改元数据，不影响表中实际存储的数据，这些操作通常很快就能完成。有些DDL需要重建表，执行过程中需要复制整个表的数据，这些DDL的开销比较大。从MySQL 5.6开始，InnoDB存储引擎逐渐支持了Online DDL，很多DDL操作，在重建表的过程中可以尽量不锁表，减少对应用系统的影响。但也有一些DDL，在执行的整个过程中都需要锁表，应用程序只能读取数据，无法修改数据。还有一些DDL操作，主要是创建索引，在执行期间不需要重建表，但需要扫描整个表的数据，按索引字段对数据进行排序，构建新的索引。</p><!-- [[[read_end]]] --><p>很多MySQL DDL语句中，可以加上关键字ALGORITHM和LOCK，用于指定DDL的执行方式。比如在下面这个SQL中，我们指定了ALGORITHM为INPLACE，LOCK为NONE。由于这个SQL只是修改了字段的注释，因此执行很快。</p><pre><code class=\"language-go\">mysql&gt; desc salaries;\n+-----------+------+------+-----+---------+-------+\n| Field     | Type | Null | Key | Default | Extra |\n+-----------+------+------+-----+---------+-------+\n| emp_no    | int  | NO   | PRI | NULL    |       |\n| salary    | int  | NO   |     | NULL    |       |\n| from_date | date | NO   | PRI | NULL    |       |\n| to_date   | date | YES  |     | NULL    |       |\n+-----------+------+------+-----+---------+-------+\n\n\nmysql&gt; alter table salaries \n    modify emp_no int not null comment 'Employee Identity', \n    algorithm=inplace, \n    lock=none;\n\nQuery OK, 0 rows affected (6.01 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n</code></pre><p>如果DDL不支持以ALGORITHM指定的方式来执行，会直接报错。下面这个SQL中，修改了字段的not null属性，因此无法以INSTANT的方式执行。</p><pre><code class=\"language-go\">mysql&gt; alter table salaries modify salary int, algorithm=instant;\nERROR 1845 (0A000): ALGORITHM=INSTANT is not supported for this operation. Try ALGORITHM=COPY/INPLACE.\n</code></pre><p>关键字ALGORITHM可以指定为DEFAULT、INSTANT、INPLACE或COPY。</p><ul>\n<li>DEFAULT：默认方式，不同的DDL类型，默认的执行方式可能不一样。MySQL会以该DDL开销最低的方式来选择默认的执行方式。</li>\n<li>INSTANT：MySQL 8.0新加的执行方式，使用这种执行方式时，添加字段和删除字段时不需要重建表。ALGORITHM指定为INSTANT时，不能再指定LOCK关键字。</li>\n<li>INPLACE：Online DDL。使用INPLACE时，默认不锁表。这里的不锁表，是指重建表时复制数据的过程中，或创建二级索引时读取全表数据进行排序、生成索引的过程中不锁表。但是在复制数据或生成索引的过程中，表上会有新的DML修改数据，这些修改会记录到一个在线的变更日志中。InnoDB需要将变更日志中的内容更新到新的表或索引中，而这个过程中是会锁表的，这一点后面会详细介绍。</li>\n<li>COPY：传统的DDL执行方式，执行过程中会锁表，默认锁模式为SHARED，应用程序可以读取表中的数据，但是不能写入数据。如果LOCK指定为EXCLUSIVE，那么读操作也会被阻塞。</li>\n</ul><p>关键字LOCK可以指定为NONE、SHARED或EXCLUSIVE，如果不指定，就会根据具体的DDL语句、指定的ALGORITHM来确定一个默认的锁级别。</p><ul>\n<li>NONE：不锁表。</li>\n<li>SHARED：共享锁，允许读取数据，但是不允许修改数据。</li>\n<li>EXCLUSIVE：排它锁，不允许读取和修改数据。</li>\n</ul><p>接下来，我们分别来介绍MySQL中几种不同类型的DDL。</p><h2>只修改元数据的DDL操作</h2><p>有一些DDL只需要修改元数据，不需要修改表中实际存储的数据。修改表名、字段名或索引名就是这样的操作。</p><pre><code class=\"language-go\">mysql&gt; alter table employees rename to employees_v2;\nQuery OK, 0 rows affected (0.03 sec)\n\nmysql&gt; alter table dept_emp rename key dept_no to idx_dept_no;\nQuery OK, 0 rows affected (0.01 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\nmysql&gt; alter table dept_emp rename column to_date to end_date;\nQuery OK, 0 rows affected (0.02 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n</code></pre><p>修改表名有一个重要的作用。比如某个业务表不再使用了，我们先不要急着DROP TABLE，而是先将表改一个名字，等过一段时间，确定确实没有任何业务会访问这个表了，再DROP表。因为如果DROP表之后，你再发现还有业务会访问这个表，恢复起来就比较麻烦了，可能需要比较长的时间，而改个表名，恢复起来就非常方便了。</p><p>DROP TABLE、DROP INDEX这样的操作也基本上也只需要修改元数据，执行速度一般也很快。当然DROP表和索引时，还需要回收它们占用的物理空间。如果开启了innodb_file_per_table，DROP表时需要删除对应的ibd文件。</p><p>删除索引也是一个需要特别注意的操作。虽然删除索引并不会影响表中的数据，但可能会影响一些查询的性能。一些关键索引删除后，可能会导致数据库CPU被打满，这个时候你想把索引再加回来，可能就需要比较长的时间了，而且可能需要先把业务停掉才行。MySQL 8.0支持不可见索引，删除索引前，你可以先把索引设置为不可见。这样，执行计划不会再考虑这个索引，但是执行DML操作时，会正常维护这个索引。</p><pre><code class=\"language-go\">mysql&gt; alter table dept_emp alter index idx_dept_no invisible;\nQuery OK, 0 rows affected (0.00 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\nmysql&gt; explain select * from dept_emp where dept_no = 'd005' limit 1;\n+----+-------------+----------+------+---------------+--------+-------------+\n| id | select_type | table    | type | possible_keys | rows   | Extra       |\n+----+-------------+----------+------+---------------+--------+-------------+\n|  1 | SIMPLE      | dept_emp | ALL  | NULL          | 331143 | Using where |\n+----+-------------+----------+------+---------------+--------+-------------+\n</code></pre><p>如果你发现业务系统还需要使用这个索引，可以将索引改成可见，这个操作通常也很快能完成。</p><pre><code class=\"language-go\">mysql&gt; alter table dept_emp alter index idx_dept_no visible;\nQuery OK, 0 rows affected (0.01 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n</code></pre><p>此外，修改表和字段的注释，也只需要修改元数据，这应该容易理解。</p><pre><code class=\"language-go\">mysql&gt; alter table dept_emp comment='Department Employee Relationship';\nQuery OK, 0 rows affected (0.01 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\nmysql&gt; alter table dept_emp modify from_date date not null comment 'From Date', algorithm=instant;\nQuery OK, 0 rows affected (0.01 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n</code></pre><p>需要注意，修改字段的注释时，需要确保字段的类型和是否为NULL属性不变，否则就不能仅仅修改元数据了。下面这个例子中，由于修改了字段的是否可为NULL的约束，开销就比较大了。</p><pre><code class=\"language-go\">mysql&gt; alter table dept_emp modify from_date date comment 'From Date', algorithm=instant;\nERROR 1845 (0A000): ALGORITHM=INSTANT is not supported for this operation. Try ALGORITHM=COPY/INPLACE.\n</code></pre><h2>Instant DDL</h2><p>给表加字段是一个很常见的需求，但是在5.7及更早的版本中，每次加字段都需要重建整个表，开销实在是有点大，特别是当表的数据量比较大的时候。MySQL 8.0中新增了Instant DDL特性，主要解决了加字段需要重建表的这个问题。</p><p>实际上在8.0中，加字段时，即使不指定algorithm=instant，默认也是使用instant的方式。</p><pre><code class=\"language-go\">mysql&gt; alter table salaries add c1 int, algorithm=instant;\nQuery OK, 0 rows affected (0.02 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n</code></pre><p>MySQL 8.0.29版本开始，你还可以将字段加到任意指定的位置。</p><pre><code class=\"language-go\">mysql&gt; alter table salaries add column c2 int after salary, algorithm=instant;\nQuery OK, 0 rows affected (0.01 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\nmysql&gt; desc salaries;\n+-----------+------+------+-----+---------+-------+\n| Field     | Type | Null | Key | Default | Extra |\n+-----------+------+------+-----+---------+-------+\n| emp_no    | int  | NO   | PRI | NULL    |       |\n| salary    | int  | NO   |     | NULL    |       |\n| c2        | int  | YES  |     | NULL    |       |\n| from_date | date | NO   | PRI | NULL    |       |\n| to_date   | date | NO   |     | NULL    |       |\n| c1        | int  | YES  |     | NULL    |       |\n+-----------+------+------+-----+---------+-------+\n</code></pre><p>删除字段也可以使用instant方式，也只需要修改元数据。</p><pre><code class=\"language-go\">]mysql&gt; alter table salaries drop column to_date, algorithm=instant;\nQuery OK, 0 rows affected (0.01 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n</code></pre><p>当然，instant DDL也有一些限制，就是同一个表，能执行的instant加字段或删除字段的操作次数是有限制的，超过这个次数后，再执行时就会报错“Maximum row versions reached”。</p><pre><code class=\"language-go\">mysql&gt; alter table salaries add column cc int, algorithm=instant;\nERROR 4092 (HY000): Maximum row versions reached for table employees/salaries. No more columns can be added or dropped instantly. Please use COPY/INPLACE.\n</code></pre><p>每执行一次Instant DDL，表的行版本就会加1，当行版本达到64时，就无法再对这个表执行Instant DDL了。从information_schema.innodb_tables这个系统表中，可以查看表当前的行版本数。</p><pre><code class=\"language-go\">mysql&gt; select * from information_schema.innodb_tables where name = 'employees/salaries'\\G\n*************************** 1. row ***************************\n          TABLE_ID: 1510\n              NAME: employees/salaries\n              FLAG: 33\n            N_COLS: 8\n             SPACE: 243\n        ROW_FORMAT: Dynamic\n     ZIP_PAGE_SIZE: 0\n        SPACE_TYPE: Single\n      INSTANT_COLS: 0\nTOTAL_ROW_VERSIONS: 64\n1 row in set (0.00 sec)\n</code></pre><p>达到行版本限制后，你就只能使用inplace或copy的方式加字段了。</p><pre><code class=\"language-go\">mysql&gt;  alter table salaries add column cc int, algorithm=inplace;\nQuery OK, 0 rows affected (4.96 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n</code></pre><p>以inplace或copy的方式执行过后，表的行版本数会清零，然后你就可以继续开心地使用instant DDL了。</p><pre><code class=\"language-go\">mysql&gt;  alter table salaries add column d10 int, algorithm=instant;\nQuery OK, 0 rows affected (0.02 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\nmysql&gt;  alter table salaries add column d11 int, add column d12 int, algorithm=instant;\nQuery OK, 0 rows affected (0.01 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n</code></pre><h3>Instant DDL是怎么实现的</h3><p>那么Instant DDL是怎么实现的呢？为什么要限制行版本的数量？执行过Instant DDL的表，查询数据和写入数据时有什么特殊的地方吗？这和InnoDB的元数据，以及InnoDB的行记录格式相关。</p><h4>InnoDB元数据存储</h4><p>元数据中记录了一个表有哪些字段，这些字段的数据类型是什么，字段的顺序是怎样的。MySQL 8.0将元数据存储在一系列的InnoDB表中。你需要使用Debug版本的MySQL，并且设置一个特殊的会话变量后，才能查询这些元数据表。</p><p>我们先创建一个测试表，执行一些instant DDL操作，然后再来看元数据中是怎么记录的。</p><pre><code class=\"language-go\">create table t_instant(a int, b int, primary key(a));\nalter table t_instant add c varchar(30), algorithm=instant;\nalter table t_instant add c2 varchar(30), algorithm=instant;\nalter table t_instant drop b, algorithm=instant;\n\n\nmysql&gt;desc t_instant;\n+-------+-------------+------+-----+---------+-------+\n| Field | Type        | Null | Key | Default | Extra |\n+-------+-------------+------+-----+---------+-------+\n| a     | int         | NO   | PRI | NULL    |       |\n| c     | varchar(30) | YES  |     | NULL    |       |\n| c2    | varchar(30) | YES  |     | NULL    |       |\n+-------+-------------+------+-----+---------+-------+\n</code></pre><p>要查看元数据，需要使用Debug版本的MySQL。官方提供的二进制包中包含了Debug版本的二进制。你只需要将mysql二进制包中的bin/mysqld替换成bin/mysqld-debug，将lib/plugin下的so文件都替换成lib/plugin/debug下的so文件，再启动MySQL就可以了。</p><p>登录到Debug版本的MySQL后，设置debug会话变量，然后就可以访问InnoDB的元数据了。</p><pre><code class=\"language-go\">mysql&gt; SET SESSION debug='+d,skip_dd_table_access_check';\nQuery OK, 0 rows affected (0.01 sec)\n</code></pre><p>我们来看一下前面创建的那个测试表t_instant的元数据。</p><pre><code class=\"language-go\">mysql&gt; desc t_instant;\n+-------+-------------+------+-----+---------+-------+\n| Field | Type        | Null | Key | Default | Extra |\n+-------+-------------+------+-----+---------+-------+\n| a     | int         | NO   | PRI | NULL    |       |\n| c     | varchar(30) | YES  |     | NULL    |       |\n| c2    | varchar(30) | YES  |     | NULL    |       |\n+-------+-------------+------+-----+---------+-------+\n3 rows in set (0.01 sec)\n\nmysql&gt; select t2.name, t2.ordinal_position as ord_no, t2.se_private_data, \n    t2.hidden, t2.type, t2.char_length\nfrom mysql.tables t1, mysql.columns t2\nwhere t1.id = t2.table_id\nand t1.name = 't_instant';\n\n+--------------------------+--------+--------------------------------------------------------------+---------+---------------------+-------------+\n| name                     | ord_no | se_private_data                                              | hidden  | type                | char_length |\n+--------------------------+--------+--------------------------------------------------------------+---------+---------------------+-------------+\n| a                        |      1 | physical_pos=0;table_id=1086;                                | Visible | MYSQL_TYPE_LONG     |          11 |\n| c                        |      2 | default_null=1;physical_pos=4;table_id=1086;version_added=1; | Visible | MYSQL_TYPE_VARCHAR  |         120 |\n| c2                       |      3 | default_null=1;physical_pos=5;table_id=1086;version_added=2; | Visible | MYSQL_TYPE_VARCHAR  |         120 |\n| DB_TRX_ID                |      4 | physical_pos=1;table_id=1086;                                | SE      | MYSQL_TYPE_INT24    |           6 |\n| DB_ROLL_PTR              |      5 | physical_pos=2;table_id=1086;                                | SE      | MYSQL_TYPE_LONGLONG |           7 |\n| !hidden!_dropped_v3_p3_b |      6 | physical_pos=3;version_dropped=3;                            | SE      | MYSQL_TYPE_LONG     |          11 |\n+--------------------------+--------+--------------------------------------------------------------+---------+---------------------+-------------+\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/93/2e/93167b503b79b14a79b999d910e1622e.png?wh=1852x340\" alt=\"图片\"></p><p>从元数据中，我们可以看到，这个表实际上有6个字段，其中有3个字段是不可见的，对用户可见的有3个字段。其中字段C是在版本1中添加的，字段C2是在版本2中添加的，字段B在版本3中被删除了。</p><h4>InnoDB行格式</h4><p>在InnoDB数据页面中，每一行记录的头部，有一个标识位，用来标记这行记录是不是在INSTANT DDL之后写入的。对于INSTANT DDL之后写入或修改过的记录，还会有一个version字节，用来标识这行记录修改时，表结构的对应版本。</p><p><img src=\"https://static001.geekbang.org/resource/image/e9/36/e91eb4e6d3a9cc5608d69ec8ed396836.jpg?wh=1692x345\" alt=\"图片\"></p><p>InnoDB在解析数据页中的一行记录时，先获取记录头部的版本信息，假设这行记录的版本为K，那么只需从元数据中查出在版本K或K之前添加并且在版本K之前还没有被删除的字段，根据这个字段列表来解析这行记录。最后，在返回这行记录时，需要过滤掉当前不可见的字段。</p><p>能以INSTANT方式执行DDL的前提，是这个DDL操作不需要修改已有数据的行记录格式。因此，我们就可以这样理解，修改字段类型不能以INSTANT的方式执行，因为不同的字段类型，数据存储格式是不一样的。修改字段是否可以为NULL，也不能以INSTANT的方式执行。因为对于可以为NULL的字段，记录头部有一个对应的比特，用来标记这个列中存储的数据是否为NULL。</p><p>对于枚举类型，如果只是往类型最后添加新的选项，并且新加的选项不会导致字段存储长度发生变化，那么就可以使用INSTANT DDL。减少枚举值、修改枚举值的顺序、将新的枚举值添加到已有列表的中间，都无法使用instant DDL。</p><pre><code class=\"language-go\">mysql&gt; create table t_enum(a enum('A', 'B'));\nQuery OK, 0 rows affected (3.42 sec)\n\nmysql&gt; alter table t_enum modify a enum('A', 'B', 'C'), algorithm=instant;\nQuery OK, 0 rows affected (0.26 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\nmysql&gt; alter table t_enum modify a enum('C', 'B', 'A'), algorithm=instant;\nERROR 1846 (0A000): ALGORITHM=INSTANT is not supported. Reason:\nNeed to rebuild the table to change column type. \nTry ALGORITHM=COPY/INPLACE.\n\nmysql&gt; alter table t_enum modify a enum('A', 'B', 'D', 'C'), algorithm=instant;\nERROR 1846 (0A000): ALGORITHM=INSTANT is not supported. Reason: \nNeed to rebuild the table to change column type. \nTry ALGORITHM=COPY/INPLACE.\n</code></pre><p>修改varchar类型的长度不能使用INSTANT DDL。如果是增加长度，并且长度在变更前后都不超过255字节，或者长度在变更前后都超过255字节，那么可以使用INPLACE的方式执行，只需要修改元数据。如果变更前长度不到255字节，变更后长度超过255字节，那么就不能使用INPLACE的方式执行了，需要用COPY的方式执行。这主要是跟varchar字段的物理存储格式有关。</p><p>下面这个例子中，employees表使用了utf8mb4字符集，将last_name改成varchar(64)时，长度超过255字节了，因此需要使用COPY的方式来执行DDL。</p><pre><code class=\"language-go\">mysql&gt; desc employees;\n+------------+---------------+------+-----+---------+-------+\n| Field      | Type          | Null | Key | Default | Extra |\n+------------+---------------+------+-----+---------+-------+\n| emp_no     | int           | NO   | PRI | NULL    |       |\n| birth_date | date          | NO   |     | NULL    |       |\n| first_name | varchar(14)   | NO   |     | NULL    |       |\n| last_name  | varchar(16)   | NO   |     | NULL    |       |\n| gender     | enum('M','F') | NO   |     | NULL    |       |\n| hire_date  | date          | NO   |     | NULL    |       |\n+------------+---------------+------+-----+---------+-------+\n\nmysql&gt; alter table employees modify last_name varchar(64) not null, algorithm=inplace;\nERROR 1846 (0A000): ALGORITHM=INPLACE is not supported. Reason: Cannot change column type INPLACE. Try ALGORITHM=COPY.\n\n\nmysql&gt; alter table employees modify last_name varchar(64) not null, algorithm=copy;\nQuery OK, 300024 rows affected (1.38 sec)\nRecords: 300024  Duplicates: 0  Warnings: 0\n</code></pre><p>字段长度超过255字节后，再增加长度就可以使用INPLACE方式执行，并且不需要重建表，执行速度很快。</p><pre><code class=\"language-go\">mysql&gt; alter table employees modify last_name varchar(128) not null, algorithm=inplace;\nQuery OK, 0 rows affected (0.02 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n</code></pre><p>如果你要缩减varchar字段的长度，那么就只能以COPY的方式执行DDL了。因为缩减长度时，表里面已有的数据可能会超长。</p><pre><code class=\"language-go\">mysql&gt; alter table employees modify last_name varchar(100) not null, algorithm=inplace;\nERROR 1846 (0A000): ALGORITHM=INPLACE is not supported. Reason: Cannot change column type INPLACE. Try ALGORITHM=COPY.\n\n\nmysql&gt; alter table employees modify last_name varchar(10) not null, algorithm=inplace;\nERROR 1846 (0A000): ALGORITHM=INPLACE is not supported. Reason: Cannot change column type INPLACE. Try ALGORITHM=COPY.\n</code></pre><h2>总结</h2><p>这一讲中，我们讨论的是通常执行速度很快的这一类DDL，也就是只需要修改元数据的DDL。Instant DDL是MySQL 8.0增加的快速加列特性，可以快速地给大表增加字段。当然，还有一些DDL，执行期间的开销会比较大，这一讲的下篇中，我们再来详细讨论。</p><h2>思考题</h2><p>只修改元数据的DDL、INSTANT DDL执行速度通常都很快，但是这些DDL执行也是需要获取元数据锁的，比如下面这个例子：</p><ul>\n<li>会话1 开启一个事务，执行一个select for update操作。</li>\n</ul><pre><code class=\"language-go\">mysql&gt; desc t_ddl;\n+-------+------+------+-----+---------+-------+\n| Field | Type | Null | Key | Default | Extra |\n+-------+------+------+-----+---------+-------+\n| a     | int  | NO   | PRI | NULL    |       |\n| b     | int  | YES  |     | NULL    |       |\n+-------+------+------+-----+---------+-------+\n2 rows in set (0.01 sec)\n\n\nmysql&gt; begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; select * from t_ddl limit 1 for update;\nEmpty set (1.12 sec)\n</code></pre><ul>\n<li>会话2 执行一个instant DDL。</li>\n</ul><pre><code class=\"language-go\">mysql&gt; alter table t_ddl add c int, algorithm=instant;\n</code></pre><ul>\n<li>会话3 执行一个普通的select操作。</li>\n</ul><pre><code class=\"language-go\">mysql&gt; select * from t_ddl limit 1;\n</code></pre><p>你会发现，会话2和会话3都被阻塞了。从processlist可以看到，它们都在等待元数据锁。（输出结果做了简化）</p><pre><code class=\"language-go\">mysql&gt; show processlist;\n+----+---------+------+---------------------------------+------------------------------------------------+\n| Id | Command | Time | State                           | Info                                           |\n+----+---------+------+---------------------------------+------------------------------------------------+\n|  8 | Sleep   |  116 |                                 | NULL                                           |\n| 11 | Query   |  105 | Waiting for table metadata lock | alter table t_ddl add c int, algorithm=instant |\n| 12 | Query   |   96 | Waiting for table metadata lock | select * from t_ddl limit 1                    |\n+----+---------+------+---------------------------------+------------------------------------------------+\n</code></pre><p>从performance_schema.metadata_locks也可以看到t_ddl表的元数据持有和请求情况。</p><pre><code class=\"language-go\">mysql&gt; select * from metadata_locks where object_name = 't_ddl';\n-------------+-------------------+-------------+-------------------+-----------------+\n OBJECT_NAME | LOCK_TYPE         | LOCK_STATUS | SOURCE            | OWNER_THREAD_ID |\n-------------+-------------------+-------------+-------------------+-----------------+\n t_ddl       | SHARED_WRITE      | GRANTED     | sql_parse.cc:6093 |              49 |\n t_ddl       | SHARED_UPGRADABLE | GRANTED     | sql_parse.cc:6093 |              50 |\n t_ddl       | EXCLUSIVE         | PENDING     | mdl.cc:3753       |              50 |\n t_ddl       | SHARED_READ       | PENDING     | sql_parse.cc:6093 |              51 |\n-------------+-------------------+-------------+-------------------+-----------------+\n</code></pre><p>还有哪些情况会导致DDL无法获取到元数据锁？怎么快速定位到元数据锁的阻塞源？</p><p>期待你的思考，欢迎在留言区中与我交流。如果今天的课程让你有所收获，也欢迎转发给有需要的朋友。我们下节课再见！</p>","comments":[{"had_liked":false,"id":394274,"user_name":"叶明","can_delete":false,"product_type":"c1","uid":1412429,"ip_address":"江苏","ucode":"D0B4B7660DA766","user_header":"https://static001.geekbang.org/account/avatar/00/15/8d/4d/992070e8.jpg","comment_is_top":false,"comment_ctime":1726299894,"is_pvip":false,"replies":[{"id":143132,"content":"这个答案很全面。\n👍👍","user_name":"作者回复","user_name_real":"编辑","uid":3898827,"ctime":1726465696,"ip_address":"浙江","comment_id":394274,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100799401,"comment_content":"还有哪些情况会导致 DDL 无法获取到元数据锁？\n1、大事务\n2、长事务，比如耗时较长的查询\n3、备份\n需要持有 MDL 锁后才能执行的语句，都会阻塞 DDL，因为其他会话无法获取这些语句涉及到的表的 MDL 写锁（MDL 的读锁和写锁冲突）。\n\n怎么快速定位到元数据锁的阻塞源？\n从视图 sys.schema_table_lock_waits 中可以找到造成阻塞的源和被阻塞的线程。","like_count":1,"discussions":[{"author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651194,"discussion_content":"这个答案很全面。\n👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1726465696,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":394268,"user_name":"123","can_delete":false,"product_type":"c1","uid":2662872,"ip_address":"新加坡","ucode":"5A343B568B9524","user_header":"https://static001.geekbang.org/account/avatar/00/28/a1/d8/42252c48.jpg","comment_is_top":false,"comment_ctime":1726283827,"is_pvip":false,"replies":[{"id":143128,"content":"instant ddl加列后，新插入或更新的数据，会把新列的值和一行记录中的其他列存放在一起。\n\ninstant ddl加列后，表里原先就存在的记录，没有存储新加的列。查询时，从元数据中获取新列的默认值，和原先记录中的列，一起返回给客户端。","user_name":"作者回复","user_name_real":"编辑","uid":3898827,"ctime":1726401576,"ip_address":"浙江","comment_id":394268,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100799401,"comment_content":"老师，请教一个问题：\nMySQL8 使用instant ddl的时候，例如添加新的列，新列的数据是额外存储的吗？例如需要修改聚簇索引和二级索引，需要获取该数据返回给客户端的时候再额外从另一种数据结构中获取？\n\n","like_count":1,"discussions":[{"author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651176,"discussion_content":"instant ddl加列后，新插入或更新的数据，会把新列的值和一行记录中的其他列存放在一起。\n\ninstant ddl加列后，表里原先就存在的记录，没有存储新加的列。查询时，从元数据中获取新列的默认值，和原先记录中的列，一起返回给客户端。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1726401577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":394200,"user_name":"binzhang","can_delete":false,"product_type":"c1","uid":1647189,"ip_address":"美国","ucode":"F2670F2EA24FAD","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM59PTNiaDASVicbVaeWBU1WKmOgyHcqVtl85nDwAqDicib1EUKE2RRoU0x0vZctZO4kbPDUTTke8qKfAw/132","comment_is_top":false,"comment_ctime":1726115658,"is_pvip":false,"replies":[{"id":143099,"content":"这个问题提得非常好。\n\ninnodb_lock_wait_timeout是行锁的超时时间。\n你可能是想设置lock_wait_timeout，这是metadata lock的超时时间。\n\n执行ddl前设置lock_wait_timeout是比较安全的一种做法，可以避免DDL长时间等待metadata锁而影响其他DML语句。","user_name":"作者回复","user_name_real":"编辑","uid":3898827,"ctime":1726208962,"ip_address":"浙江","comment_id":394200,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100799401,"comment_content":"is it a best practice to execute &quot;SET innodb_lock_wait_timeout = 1;&quot; before execute any DDL?","like_count":1,"discussions":[{"author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651089,"discussion_content":"这个问题提得非常好。\n\ninnodb_lock_wait_timeout是行锁的超时时间。\n你可能是想设置lock_wait_timeout，这是metadata lock的超时时间。\n\n执行ddl前设置lock_wait_timeout是比较安全的一种做法，可以避免DDL长时间等待metadata锁而影响其他DML语句。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1726208962,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":394956,"user_name":"黑微狗‮‮","can_delete":false,"product_type":"c1","uid":1177797,"ip_address":"浙江","ucode":"D44505E7E97BB3","user_header":"https://static001.geekbang.org/account/avatar/00/11/f8/c5/6d38f3e3.jpg","comment_is_top":false,"comment_ctime":1728906844,"is_pvip":false,"replies":[{"id":143409,"content":"这个问题提得非常好。\n\n我再次看了下应用row_log的这部分代码（row_log_table_apply和row_log_apply这两个函数），\n应用row_log时，如果当前处理的不是最后一个block，会先释放主键或索引上的x锁（rw_lock_x_unlock）。\n\n在处理最后一个block时，会对主键或索引加锁（rw_lock_x_lock），然后再应用row_log。\n\n这里的锁，是索引内存结构上的读写锁（struct dict_index_t { rw_lock_t lock }）。\n\n文章中对应用row_log时的加锁，描述的不太准确。\n\n感谢指正，也解决了我原先的一个疑问。🫡🫡","user_name":"作者回复","user_name_real":"编辑","uid":3898827,"ctime":1728976399,"ip_address":"浙江","comment_id":394956,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100799401,"comment_content":"老师麻烦问下，网上看的文章对于INPLACE执行流程的描述，关于里面row_log的应用，想问下，在execution阶段同时在应用row_log到新表，最后commit阶段只应用最后一个block。还是所有的row_log都是在commit阶段应用的呢？","like_count":0,"discussions":[{"author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":652458,"discussion_content":"这个问题提得非常好。\n\n我再次看了下应用row_log的这部分代码（row_log_table_apply和row_log_apply这两个函数），\n应用row_log时，如果当前处理的不是最后一个block，会先释放主键或索引上的x锁（rw_lock_x_unlock）。\n\n在处理最后一个block时，会对主键或索引加锁（rw_lock_x_lock），然后再应用row_log。\n\n这里的锁，是索引内存结构上的读写锁（struct dict_index_t { rw_lock_t lock }）。\n\n文章中对应用row_log时的加锁，描述的不太准确。\n\n感谢指正，也解决了我原先的一个疑问。🫡🫡","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1728976399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":394358,"user_name":"TheOne","can_delete":false,"product_type":"c1","uid":1582134,"ip_address":"北京","ucode":"2A359780156A8B","user_header":"https://static001.geekbang.org/account/avatar/00/18/24/36/0829cbdc.jpg","comment_is_top":false,"comment_ctime":1726622329,"is_pvip":false,"replies":[{"id":143148,"content":"问题1. 修改数据类型会改变数据的存储格式，因此instant ddl不支持。删除字段时，不动老的数据，只要在解析行记录时，把已删除字段的数据忽略掉就行。\n先删除字段，再增加字段，和修改数据类型是不一样的。修改数据类型会保留字段原先的数据。\n\n问题2. 删除字段后，更新了元数据中字段对应的那一行记录。\n比如字段b被改名为!hidden!_dropped_v3_p3_b\n\n问题3. 如果字段上有索引，就不支持使用instant ddl删除字段了。\n删除有索引的字段，相当于要做几个操作\na) 删除包含该字段的索引\nb) 重建索引，但是要去掉待删除的字段\nc) 删除字段\n如果涉及到重建索引，那么表比较大时，DDL就会比较慢了。\n","user_name":"作者回复","user_name_real":"编辑","uid":3898827,"ctime":1726641434,"ip_address":"浙江","comment_id":394358,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100799401,"comment_content":"老师有几个问题想问下\n1. 增加和删除字段，可以通过 instant 方式进行，但是修改字段数据类型不行，是因为修改的时候涉及到旧数据吗？但是删除的时候，也涉及到旧数据吧，这里的修改方案如果是先删除，再新增是不是也能用上 instant？\n\n2.表 t_instant 其实一共操作了4个字段(a，b，c，c2)，但是元数据里有6个字段，对于 add 字段来说，应该会在原数据里加一条，但是删除字段的时候，是在原来的行上做修改，还是新增一条呢？\n我看您的事例是在最后新增了一条删除的记录，然后 b 字段消失了\n\n3. 删除字段这种操作，索引里面的数据会一起删掉吧？假如表很大的话，是不是也会比较慢呢，比如 500 万","like_count":0,"discussions":[{"author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651259,"discussion_content":"问题1. 修改数据类型会改变数据的存储格式，因此instant ddl不支持。删除字段时，不动老的数据，只要在解析行记录时，把已删除字段的数据忽略掉就行。\n先删除字段，再增加字段，和修改数据类型是不一样的。修改数据类型会保留字段原先的数据。\n\n问题2. 删除字段后，更新了元数据中字段对应的那一行记录。\n比如字段b被改名为!hidden!_dropped_v3_p3_b\n\n问题3. 如果字段上有索引，就不支持使用instant ddl删除字段了。\n删除有索引的字段，相当于要做几个操作\na) 删除包含该字段的索引\nb) 重建索引，但是要去掉待删除的字段\nc) 删除字段\n如果涉及到重建索引，那么表比较大时，DDL就会比较慢了。\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1726641434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":394179,"user_name":"Shelly","can_delete":false,"product_type":"c1","uid":2422713,"ip_address":"广东","ucode":"75BA35C2737EA6","user_header":"https://static001.geekbang.org/account/avatar/00/24/f7/b9/f2eec64e.jpg","comment_is_top":false,"comment_ctime":1726046177,"is_pvip":false,"replies":[{"id":143087,"content":"对的，可以通过metadata_locks来查。👍","user_name":"作者回复","user_name_real":"编辑","uid":3898827,"ctime":1726056676,"ip_address":"浙江","comment_id":394179,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100799401,"comment_content":"确定元数据锁阻塞源，根据相关表关联查询：\nmysql&gt; SELECT \n    -&gt;     p.id AS ID,\n    -&gt;     p.user as USER,\n    -&gt;     t.PROCESSLIST_DB AS DB_NAME,\n    -&gt;     m.OBJECT_NAME AS TABLE_NAME,\n    -&gt;     t.PROCESSLIST_TIME AS SPEND_TIME,\n    -&gt;     t.PROCESSLIST_INFO AS SQL_TEXT,\n    -&gt;     m.LOCK_TYPE AS LOCK_TYPE,\n    -&gt;     m.LOCK_STATUS as LOCK_STATUS  \n    -&gt; FROM \n    -&gt;     information_schema.processlist p \n    -&gt; JOIN \n    -&gt;     performance_schema.threads t \n    -&gt; ON \n    -&gt;     p.id=t.PROCESSLIST_ID \n    -&gt; JOIN \n    -&gt;     performance_schema.metadata_locks m \n    -&gt; ON \n    -&gt;     m.OWNER_THREAD_ID=t.THREAD_ID \n    -&gt; WHERE \n    -&gt;     m.OBJECT_SCHEMA=&#39;test1&#39; and m.OBJECT_NAME=&#39;t_ddl&#39;\\G\n*************************** 1. row ***************************\n         ID: 52\n       USER: root\n    DB_NAME: test1\n TABLE_NAME: t_ddl\n SPEND_TIME: 1176\n   SQL_TEXT: alter table t_ddl add c int, algorithm=instant\n  LOCK_TYPE: SHARED_UPGRADABLE\nLOCK_STATUS: GRANTED\n*************************** 2. row ***************************\n         ID: 52\n       USER: root\n    DB_NAME: test1\n TABLE_NAME: t_ddl\n SPEND_TIME: 1176\n   SQL_TEXT: alter table t_ddl add c int, algorithm=instant\n  LOCK_TYPE: EXCLUSIVE\nLOCK_STATUS: PENDING\n*************************** 3. row ***************************\n         ID: 54\n       USER: root\n    DB_NAME: test1\n TABLE_NAME: t_ddl\n SPEND_TIME: 1146\n   SQL_TEXT: select * from t_ddl limit 1\n  LOCK_TYPE: SHARED_READ\nLOCK_STATUS: PENDING\n*************************** 4. row ***************************\n         ID: 55\n       USER: root\n    DB_NAME: test1\n TABLE_NAME: t_ddl\n SPEND_TIME: 1187\n   SQL_TEXT: select * from t_ddl limit 1 for update\n  LOCK_TYPE: SHARED_WRITE\nLOCK_STATUS: GRANTED\n4 rows in set (0.02 sec)\n\n可以查看到阻塞源是select * from t_ddl limit 1 for update，kill 55杀掉阻塞源。","like_count":0,"discussions":[{"author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651005,"discussion_content":"对的，可以通过metadata_locks来查。👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1726056676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":394176,"user_name":"Geek_0126","can_delete":false,"product_type":"c1","uid":3952196,"ip_address":"浙江","ucode":"2916F7FB3F6D71","user_header":"https://static001.geekbang.org/account/avatar/00/3c/4e/44/49b29792.jpg","comment_is_top":false,"comment_ctime":1726042199,"is_pvip":false,"replies":[{"id":143088,"content":"是的。慢查询和未提交的事务，都是metadata lock的阻塞源。👍","user_name":"作者回复","user_name_real":"编辑","uid":3898827,"ctime":1726056759,"ip_address":"浙江","comment_id":394176,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100799401,"comment_content":"有慢查询或者其他事务占用此表时，会导致DDL无法获取元数据锁。一般可以通过查看活跃链接及事务列表来确定阻塞源。","like_count":0,"discussions":[{"author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651006,"discussion_content":"是的。慢查询和未提交的事务，都是metadata lock的阻塞源。👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1726056759,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]}]}