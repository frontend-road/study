{"id":733984,"title":"02｜初出茅庐：构造一个极简的HttpServer","content":"<p>你好，我是郭屹，今天我们继续学习手写 MiniTomcat，从这里开始要同步写代码了。</p><p>与MiniSpring相同，我们也会从一个最简单的程序开始，一步步地演化迭代，最终实现Tomcat的核心功能。这节课，我们就来构造第一个简单的Web服务器应用程序。结构如图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/91/80/919b493e16b8853a763d1f7997404880.png?wh=2190x972\" alt=\"\"></p><p>可以看出，当用户从浏览器这端发起一个静态的请求时，这个极简HTTP Server仅仅是简单地将本地的静态文件返回给客户端。这也正是我们手写MiniTomcat的第一步。</p><h2>Web请求流程</h2><p>一个Web服务器，简单来讲，就是要按照HTTP协议的规范处理前端发过来的Request并返回Response。在这节课中，我们计划请求 <code>http://localhost:8080/test.txt</code> 这个地址，实现一个最简单的Web应用服务器。</p><p>我们简单回顾一下，在浏览器中输入一个网页地址，键入回车的那一刻，从请求开始到请求结束这个过程会经历几步。</p><ol>\n<li>DNS解析，将域名解析为IP地址。</li>\n<li>与目标端建立TCP连接。</li>\n<li>发送HTTP请求。</li>\n<li>服务器解析HTTP请求并返回处理后的报文。</li>\n<li>浏览器解析返回的报文并渲染页面。</li>\n<li>TCP连接断开。</li>\n</ol><p>在这个过程中，还有很多诸如三次握手，DNS解析顺序等具体技术细节，因为不是这节课的主要论题，所以这里不再详细说明。在上述Web请求流程中，我们重点关注“发送HTTP请求”“服务器解析HTTP请求并返回处理后的报文”以及“浏览器解析返回的报文并渲染页面”这三步。</p><!-- [[[read_end]]] --><h2>项目结构</h2><p>首先我们定义项目的结构，为减少阅读Tomcat实际源码的障碍，项目结构以及类的名字会仿照Tomcat源码中的定义。作为起步，在这节课中项目结构简单定义如下：</p><pre><code class=\"language-plain\">MiniTomcat\n├─ src\n│  ├─ server\n│  │  ├─ HttpServer.java\n│  │  ├─ Request.java\n│  │  ├─ Response.java\n├─ webroot\n│  ├─ hello.txt\n</code></pre><p>和应用服务器有关的代码放在 <code>src/server</code> 目录下，而webroot目录下目前放了一个名叫hello.txt的文本文件，这个目录下计划存放返回给浏览器的静态资源。</p><h2>Request请求类</h2><p>我们打开浏览器，尝试输入 <code>http://localhost:8080/hello.txt</code>， 看看请求参数有哪些内容。</p><pre><code class=\"language-plain\">GET /hello.txt HTTP/1.1\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9\nCache-Control: max-age=0\nConnection: keep-alive\nHost: localhost:8080\nSec-Fetch-Dest: document\nSec-Fetch-Mode: navigate\nSec-Fetch-Site: none\nSec-Fetch-User: ?1\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36\nsec-ch-ua: \"Google Chrome\";v=\"113\", \"Chromium\";v=\"113\", \"Not-A.Brand\";v=\"24\"\n</code></pre><p>以上是HTTP协议规定的请求标准格式。由上述内容可以看出，请求按行划分，首先可以分为两部分：第一行与其他行。第一行的内容中包含请求方法（GET）、请求路径（/hello.txt）、使用的协议以及版本（HTTP/1.1）。从第一行往下就是具体的请求头了，以Key-Value键值对的形式按行列出。一般关注较多的Key是Accept、Host、Content-Type、Authorization等。</p><p>现在我们就有了作为参考的Request示例，接下来我们就参考标准格式，对Request参数进行解析，提取我们需要的关键元素与信息。</p><p>我们定义Request.java类，用来构造请求参数对象。</p><pre><code class=\"language-java\">package src.server;\npublic class Request {\n    private InputStream input;\n    private String uri;\n    public Request(InputStream input) {\n        this.input = input;\n    }\n    public void parse() {\n        StringBuffer request = new StringBuffer(2048);\n        int i;\n        byte[] buffer = new byte[2048];\n        try {\n            i = input.read(buffer);\n        } catch (IOException e) {\n            e.printStackTrace();\n            i = -1;\n        }\n        for (int j = 0; j &lt; i; j++) {\n            request.append((char) buffer[j]);\n        }\n        uri = parseUri(request.toString());\n    }\n    private String parseUri(String requestString) {\n        int index1, index2;\n        index1 = requestString.indexOf(' ');\n        if (index1 != -1) {\n            index2 = requestString.indexOf(' ', index1 + 1);\n            if (index2 &gt; index1) return requestString.substring(index1 + 1, index2);\n        }\n        return null;\n    }\n    public String getUri() {\n        return uri;\n    }\n}\n</code></pre><p>Request类中目前有两个域，一个是input，类型为InputStream，另外一个是URI，类型为String。我们希望以此接收请求来的输入流，并提取出其中的URI来。因此，Request对象必须由传入的InputStream这一输入流对类进行初始化。在Request类中，最核心的当数 <code>parse()</code> 方法，主要的工作都由这个过程完成。</p><p>在 <code>parse()</code> 方法中，主要将I/O的输入流转换成固定的请求格式（参见前面列出的请求类）。InputStream先用byte数组接收，执行 <code>input.read(buffer)</code> 后，input的内容会转换成byte数组，填充buffer。这个方法的返回值表示写入buffer中的总字节数（代码中的2048）。随后将byte数组的内容通过循环拼接至StringBuffer中，转换成我们熟悉的请求格式。</p><p>然后我们用parseUri方法，获取Uri。</p><pre><code class=\"language-java\">&nbsp; private String parseUri(String requestString) {\n&nbsp; &nbsp; int index1, index2;\n&nbsp; &nbsp; index1 = requestString.indexOf(' ');\n&nbsp; &nbsp; if (index1 != -1) {\n&nbsp; &nbsp; &nbsp; index2 = requestString.indexOf(' ', index1 + 1);\n&nbsp; &nbsp; &nbsp; if (index2 &gt; index1)\n&nbsp; &nbsp; &nbsp; &nbsp; return requestString.substring(index1 + 1, index2);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; return null;\n&nbsp; }\n</code></pre><p>前面我们说过，HTTP协议规定，在请求格式第一行的内容中，包含请求方法、请求路径、使用的协议以及版本，用一个空格分开。上述代码的功能在于，<strong>获取传入参数第一行两个空格中的一段，作为请求的 URI。</strong>如果格式稍微有点出入，这个解析就会失败。从这里也可以看出，遵守协议的重要性。</p><h2>构造服务器</h2><p>在构造了HTTP请求类之后，我们来看看服务器是如何处理这个HTTP请求以及如何传输返回报文的。</p><p>在src/server目录下，定义HttpServer.java类。</p><pre><code class=\"language-java\">package src.server;\npublic class HttpServer {\n    public static final String WEB_ROOT = System.getProperty(\"user.dir\") + File.separator + \"webroot\";\n    public static void main(String[] args) {\n        HttpServer server = new HttpServer();\n        server.await();\n    }\n    public void await() { //服务器循环等待请求并处理\n        ServerSocket serverSocket = null;\n        int port = 8080;\n        try {\n            serverSocket = new ServerSocket(port, 1, InetAddress.getByName(\"127.0.0.1\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n        while (true) {\n            Socket socket = null;\n            InputStream input = null;\n            OutputStream output = null;\n            try {\n                socket = serverSocket.accept(); //接收请求连接\n                input = socket.getInputStream();\n                output = socket.getOutputStream();\n                // create Request object and parse\n                Request request = new Request(input);\n                request.parse();\n                // create Response object\n                Response response = new Response(output);\n                response.setRequest(request);\n                response.sendStaticResource();\n                // close the socket\n                socket.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre><p>首先我们看一下 <code>main()</code> 方法，这也是我们整个程序的核心启动方法。</p><pre><code class=\"language-java\">    public static void main(String[] args) {\n        HttpServer server = new HttpServer();\n        server.await();\n    }\n</code></pre><p>可以看到启动类很简单，实例化一个HTTP Server对象后，调用 <code>await()</code> 方法。随后我们看看 <code>await()</code> 方法内有什么奥秘吧！</p><pre><code class=\"language-java\">public void await() {\n    ServerSocket serverSocket = null;\n    int port = 8080;\n    try {\n        serverSocket = new ServerSocket(port, 1, InetAddress.getByName(\"127.0.0.1\"));\n    } catch (IOException e) {\n        e.printStackTrace();\n        System.exit(1);\n    }\n    while (true) {\n        Socket socket = null;\n        InputStream input = null;\n        OutputStream output = null;\n        try {\n            socket = serverSocket.accept();\n            input = socket.getInputStream();\n            output = socket.getOutputStream();\n            // create Request object and parse\n            Request request = new Request(input);\n            request.parse();\n            // create Response object\n            Response response = new Response(output);\n            response.setRequest(request);\n            response.sendStaticResource();\n            // close the socket\n            socket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre><p>从上面的代码中可以看出，这其实就是一个简单的网络服务器程序。如果你熟悉Java网络I/O的话，一眼就能看出来，整个过程就是启动了一个ServerSocket接收客户端的请求，生成Socket连接后包装成Request/Response进行处理。</p><p>我们看看具体代码。</p><pre><code class=\"language-plain\">new ServerSocket(port, 1, InetAddress.getByName(\"127.0.0.1\"))\n</code></pre><p>使用ServerSocket监听8080端口，为方便测试，在这个地方直接写死127.0.0.1这个值，我们可以在本地进行测试。</p><p>通过 <code>serverSocket.accept()</code> 为每一个连接生成一个socket。通过 <code>socket.getInputStream()</code> 获取通过浏览器传入的输入流，包装成前面提到的Request对象，调用 <code>parse()</code> 解析URI。在这一步我们完成了对Request请求的解析工作。然后创建一个Response，通过Response输出，具体实现后面再说。最后关闭 <code>socket.close()</code>，中断这次TCP连接，然后程序循环，等待下一次连接。</p><p>到此为止我们就构建出了一个最简单的HTTP Server，即构建Request -&gt; 解析 -&gt; 构建Response输出，这样我们就模拟实现了一个最简单的Web应用服务器。现在我们还需要构造Response对象，就可以完成一次完整的HTTP交互。</p><h2>Response返回对象</h2><p>和构造Request请求对象一样，我们用同样的方法来构造Response返回对象，将HTTP返回对象处理成浏览器可渲染，便于用户浏览的数据。</p><p>先定义Response.java类。</p><pre><code class=\"language-java\">package src.server;\npublic class Response {\n    private static final int BUFFER_SIZE = 1024;\n    Request request;\n    OutputStream output;\n    public Response(OutputStream output) {\n        this.output = output;\n    }\n    public void setRequest(Request request) {\n        this.request = request;\n    }\n    public void sendStaticResource() throws IOException {\n        byte[] bytes = new byte[BUFFER_SIZE];\n        FileInputStream fis = null;\n        try {\n            File file = new File(HttpServer.WEB_ROOT, request.getUri());\n            if (file.exists()) {\n                fis = new FileInputStream(file);\n                int ch = fis.read(bytes, 0, BUFFER_SIZE);\n                while (ch != -1) {\n                    output.write(bytes, 0, ch);\n                    ch = fis.read(bytes, 0, BUFFER_SIZE);\n                }\n                output.flush();\n            }\n            else {\n                String errorMessage = \"HTTP/1.1 404 FIle Not Found\\r\\n\" +\n                        \"Content-Type: text/html\\r\\n\" +\n                        \"Content-Length: 23\\r\\n\" +\n                        \"\\r\\n\" +\n                        \"&lt;h1&gt;File Not Found&lt;/h1&gt;\";\n                output.write(errorMessage.getBytes());\n            }\n        }\n        catch (Exception e) {\n            System.out.println(e.toString());\n        }\n        finally {\n            if (fis != null) {\n                fis.close();\n            }\n        }\n    }\n}\n</code></pre><p>Response类和Request类有些类似，不一样的地方在于Response通过OutputStream输出内容。我们可以看到，现在这个Response其实只能返回静态文件数据。在 <code>sendStaticResource()</code> 方法中，我们的实现非常简单粗糙，就是直接把webroot下的文件内容完整地输出了。</p><p>代码如下所示：</p><pre><code class=\"language-java\">File file = new File(HttpServer.WEB_ROOT, request.getUri());\nif (file.exists()) {\n    fis = new FileInputStream(file);\n    int ch = fis.read(bytes, 0, BUFFER_SIZE);\n    while (ch != -1) {\n        output.write(bytes, 0, ch);\n        ch = fis.read(bytes, 0, BUFFER_SIZE);\n    }\n    output.flush();\n}\n</code></pre><p>我们看到，Response它就是根据解析到的URI在内部创建一个file，逐个字节读取file的内容，然后写入output里。中间并没有进行任何处理，也没有按照HTTP协议拼接格式串。也正因如此，这就需要我们自己手动在文件中写出完整的返回数据格式，在webroot下创建hello.txt。</p><pre><code class=\"language-plain\">HTTP/1.1 200 OK\nContent-Type: text/html\nContent-Length: 12\n\nHello World!\n</code></pre><p>如上所示，这个文本文件的内容就是按照HTTP规定的返回格式手工写好的。因为这是第一步，实现极简，我们先这么写，这也是后面需要优化改造的点。不过从这里我们可以感受到HTTP协议本身的简单，就是一些文本字符串的格式约定。</p><p>可以看到，返回格式和请求格式有些不一样，区别在于第一行先展示协议及其版本（HTTP/1.1）、HTTP状态码（200）与HTTP状态内容（OK）。在返回头设置完毕后空一行，显示返回体 <code>Hello World!</code>。</p><h2>测试</h2><p>在上述准备工作完毕后，在HttpServer类中运行 <code>main()</code> 方法，程序会在本地8080端口启动一个Socket持续监听请求。这时我们在浏览器中键入 <code>http://localhost:8080/hello.txt</code>，可以看到浏览器页面上返回了 <code>Hello World！</code>字样，说明我们的第一个HTTP服务器构建成功了，顺利返回了hello.txt中的返回体内容。</p><h2>小结</h2><p><img src=\"https://static001.geekbang.org/resource/image/a7/ee/a7f371690f741a6956419221766c60ee.jpg?wh=2562x2098\" alt=\"\"></p><p>这节课我们构造了第一个可运行的HttpServer。我们按照Java网络编程的规程，启动了一个ServerSocket在8080端口进行监听，对HTTP请求的传入串进行了封装，且实现了对输入串的解析，提取出了URI，并根据URI创建文件，读取文件中的内容，然后写入到outputStream中。</p><p>虽然极为简单粗糙，功能也极简，但是确实是做到响应HTTP Request -&gt; 解析 -&gt; 构建Response输出全闭环。当然，我们也知道，这个闭环中请求这个环节是依靠的浏览器的功能，不是我们自己实现的，响应的格式也是由用户自己在文件中写好的，不是我们的服务器完成的，后面我们再来改进。</p><p>注：由于许多学员反映GitHub从国内访问太慢甚至出现访问不了的状况，我请助手帮我将代码搬到国内的 <a href=\"https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter02\">Gitee</a> 上来了，感谢。</p><h2>思考题</h2><p>学完了这节课的内容，我们来思考一个问题：我们的这个HTTP Server只能返回静态资源，没有动态内容，所以不能叫做应用服务器Application Server，那么从原理上如何将它变成一个应用服务器呢？</p><p>欢迎你把你思考后的结果分享到评论区，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p>","neighbors":{"left":{"article_title":"01｜持久的传奇：Tomcat的发展历程与框架演进","id":733840},"right":{"article_title":"03｜动态Response：按照规范构造返回流","id":734199}},"comments":[{"had_liked":false,"id":387637,"user_name":"猛禽不是鸟","can_delete":false,"product_type":"c1","uid":1068707,"ip_address":"广东","ucode":"19C1E2E558C847","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/a3/7c685adf.jpg","comment_is_top":false,"comment_ctime":1708313949,"is_pvip":false,"replies":[{"id":141239,"content":"赞👍🏻","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1708491067,"ip_address":"澳大利亚","comment_id":387637,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"在应用服务器中维护一个请求地址和对应处理类【方法】的映射关系，然后在parse解析出来uri之后，通过映射关系找到对应的处理方法。","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":637425,"discussion_content":"赞👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1708491067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385513,"user_name":"听风有信","can_delete":false,"product_type":"c1","uid":2683430,"ip_address":"广东","ucode":"2CCB467114FF5C","user_header":"https://static001.geekbang.org/account/avatar/00/28/f2/26/a8ac6b42.jpg","comment_is_top":false,"comment_ctime":1702863663,"is_pvip":false,"replies":[{"id":140499,"content":"过程是这样。这些问题是思考题，没有标准答案，只是启发式的。从静态文本到程序动态生成，最简单的就是提供一个接口，服务器加载实现类，调用固定的方法，返回字符串。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1702903996,"ip_address":"北京","comment_id":385513,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"应用服务器的话，要根据客户端的请求，然后执行相应的业务处理程序，最后将业务程序的输出返回给客户端，这种输出的内容是动态生成的。","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634014,"discussion_content":"过程是这样。这些问题是思考题，没有标准答案，只是启发式的。从静态文本到程序动态生成，最简单的就是提供一个接口，服务器加载实现类，调用固定的方法，返回字符串。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702903996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1177739,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f8/8b/74d2ab6b.jpg","nickname":"斜杠青年","note":"","ucode":"D7AF02B8588549","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651285,"discussion_content":"其实如果在忙于编写业务代码的同时停下来，思考一下文档中的这节内容，会豁然开朗，基于此可以猜测 thymeleaf 的实现原理，以及 JSP 的渲染逻辑，以及为什么现在更普及 前端 React、VUE 的单页面程序，都有迹可循。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1726676989,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385294,"user_name":"阿加西","can_delete":false,"product_type":"c1","uid":1181102,"ip_address":"中国香港","ucode":"6CC27117D29D1E","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/ae/1520ad92.jpg","comment_is_top":false,"comment_ctime":1702386532,"is_pvip":false,"replies":[{"id":140434,"content":"经典必须的。一步步自己写下来。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1702444780,"ip_address":"北京","comment_id":385294,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"参考了《How Tomcat Works》","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633666,"discussion_content":"经典必须的。一步步自己写下来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702444780,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":387007,"user_name":"Xiaosong","can_delete":false,"product_type":"c1","uid":1883431,"ip_address":"美国","ucode":"28A03027343F9D","user_header":"https://static001.geekbang.org/account/avatar/00/1c/bd/27/e653a220.jpg","comment_is_top":false,"comment_ctime":1706150694,"is_pvip":false,"replies":[{"id":141093,"content":"这是出于性能的考虑，网络程序，直接从流上拿字节。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1706230416,"ip_address":"澳大利亚","comment_id":387007,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"好奇为什么parseUri要写的这么麻烦，直接requestString.split(&#39; &#39;)，检查一下length，然后 取第二个不就行了吗","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636484,"discussion_content":"这是出于性能的考虑，网络程序，直接从流上拿字节。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1706230416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386138,"user_name":"健康的小牛犊","can_delete":false,"product_type":"c1","uid":2263754,"ip_address":"江苏","ucode":"A63C30B602F0A5","user_header":"https://static001.geekbang.org/account/avatar/00/22/8a/ca/1afcc75b.jpg","comment_is_top":false,"comment_ctime":1704180723,"is_pvip":false,"replies":[{"id":140772,"content":"Spring是一个应用程序框架，不是服务器。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1704205127,"ip_address":"湖南","comment_id":386138,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"Spring和tomcat是如何结合在一起的呢，按理说tomcat本身就可以作为一个web服务器了，那spring的作用是啥呢","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634944,"discussion_content":"Spring是一个应用程序框架，不是服务器。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704205127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1103002,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d4/9a/11134ccc.jpg","nickname":"小四","note":"","ucode":"41BAE89BCCF047","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":639390,"discussion_content":"Spring是一个应用开发框架，包含很多模块，比如 Spring MVC，用于简化 web 开发。\n\n简单的说，tomcat 是一个servlet 容器，而spring MVC 本质还是一个 servlet的封装。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1710581802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3718893,"avatar":"https://static001.geekbang.org/account/avatar/00/38/be/ed/f90bd120.jpg","nickname":"Lunch","note":"","ucode":"69485D8B1893ED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635845,"discussion_content":"Tomcat就是一个服务启动程序，Tomcat给了我们接口，让我们写项目代码，然后顺便帮我们启动项目代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705294353,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385430,"user_name":"Geek_50a5cc","can_delete":false,"product_type":"c1","uid":1786951,"ip_address":"北京","ucode":"0F6C1C2552261F","user_header":"","comment_is_top":false,"comment_ctime":1702620847,"is_pvip":false,"replies":[{"id":140480,"content":"http协议没有限制响应数据的大小，理论上没有规定。不过实际服务器和应用场景，可以自行规定大小限制。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1702777636,"ip_address":"北京","comment_id":385430,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"如果将读取的文件内容，放在message里面返回过去；\nString Message = &quot;HTTP&#47;1.1 404 FIle Not Found\\r\\n&quot; +\n                        &quot;Content-Type: text&#47;html\\r\\n&quot; +\n                        &quot;Content-Length: 23\\r\\n&quot; +\n                        &quot;\\r\\n&quot; +\n                        &quot;&lt;h1&gt;&quot;+\n                        result.toString() +\n                        &quot;&lt;&#47;h1&gt;&quot;;\n                output.write(Message.getBytes());\n如果文件里 字符 很多的时候，这个是否都会完全输出显示出来呢；\n（result就是文件字节流转换的字符串）","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633913,"discussion_content":"http协议没有限制响应数据的大小，理论上没有规定。不过实际服务器和应用场景，可以自行规定大小限制。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702777636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385343,"user_name":"Koyi","can_delete":false,"product_type":"c1","uid":3183457,"ip_address":"上海","ucode":"D4115B2852FCE8","user_header":"https://static001.geekbang.org/account/avatar/00/30/93/61/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1702460471,"is_pvip":false,"replies":[{"id":140436,"content":"往后看，现在是起步的粗糙版本。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1702474197,"ip_address":"北京","comment_id":385343,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"Request类 第13行 读取数据时，使用一个while循环判断返回值是否大于0以保证成功读取完数据是不是好些","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633683,"discussion_content":"往后看，现在是起步的粗糙版本。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702474197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":394385,"user_name":"斜杠青年","can_delete":false,"product_type":"c1","uid":1177739,"ip_address":"广东","ucode":"D7AF02B8588549","user_header":"https://static001.geekbang.org/account/avatar/00/11/f8/8b/74d2ab6b.jpg","comment_is_top":false,"comment_ctime":1726676621,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"我自己在学习 http 协议的时候，就想到了，可以直接基于字节码来进行开始到 socket 进而到 http 协议，到多路复用，异步IO，到 tomcat 的知识点串起来，但是一直没有决心进行梳理，看到这个课程如获珍宝，学会此课程可以明白理解为什么压测的时候，无论如何提升服务器规格，数据库规格，吞吐还是上不去，以及各种状态码代表什么，瓶颈在TCP层还是Tomcat层，都会得到答案。","like_count":0},{"had_liked":false,"id":388280,"user_name":"旷野之希","can_delete":false,"product_type":"c1","uid":2278431,"ip_address":"加拿大","ucode":"B25186DD7BF213","user_header":"https://static001.geekbang.org/account/avatar/00/22/c4/1f/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1709790139,"is_pvip":false,"replies":null,"discussion_count":2,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"我遇到一个问题，当时随便使用了一个端口号7000，会报403 forbidden的异常，但是换一个端口，比如8888就可以正常访问hello.txt了，这可能是什么原因呢？","like_count":0,"discussions":[{"author":{"id":1177739,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f8/8b/74d2ab6b.jpg","nickname":"斜杠青年","note":"","ucode":"D7AF02B8588549","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651284,"discussion_content":"有可能是本地有其他的服务使用 7000 端口，实际服务启动的不是 7000 端口","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1726676721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3619143,"avatar":"https://static001.geekbang.org/account/avatar/00/37/39/47/791d0f5e.jpg","nickname":"信“自个er”不就好了","note":"","ucode":"8FFE9E61DD0285","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":648533,"discussion_content":"我是不管啥端口，页面显示拒绝链接请求。。。。防火墙已关","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1721748632,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"安徽","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}