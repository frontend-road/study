{"id":429063,"title":"25｜类型系统：如何围绕trait来设计和架构系统？","content":"<p>你好，我是陈天。</p><p>Trait，trait，trait，怎么又是 trait？how old are you?</p><p>希望你还没有厌倦我们没完没了地聊关于 trait 的话题。因为 trait 在 Rust 开发中的地位，怎么吹都不为过。</p><p>其实不光是 Rust 中的 trait，任何一门语言，和接口处理相关的概念，都是那门语言在使用过程中最重要的概念。<strong>软件开发的整个行为，基本上可以说是不断创建和迭代接口，然后在这些接口上进行实现的过程</strong>。</p><p>在这个过程中，有些接口是标准化的，雷打不动，就像钢筋、砖瓦、螺丝、钉子、插座等这些材料一样，无论要构筑的房子是什么样子的，这些标准组件的接口在确定下来后，都不会改变，它们就像 Rust 语言标准库中的标准 trait 一样。</p><p>而有些接口是跟构造的房子息息相关的，比如门窗、电器、家具等，它们就像你要设计的系统中的 trait 一样，可以把系统的各个部分联结起来，最终呈现给用户一个完整的使用体验。</p><p>之前讲了trait 的基础知识，也介绍了如何在实战中使用 trait 和 trait object。今天，我们再花一讲的时间，来看看如何围绕着 trait 来设计和架构系统。</p><p>由于在讲架构和设计时，不免要引入需求，然后我需要解释这需求的来龙去脉，再提供设计思路，再介绍 trait 在其中的作用，但这样下来，一堂课的内容能讲好一个系统设计就不错了。所以我们换个方式，把之前设计过的系统捋一下，重温它们的 trait 设计，看看其中的思路以及取舍。</p><!-- [[[read_end]]] --><h2>用 trait 让代码自然舒服好用</h2><p>在<a href=\"https://time.geekbang.org/column/article/413634\">第 5 讲</a>，thumbor 的项目里，我设计了一个 SpecTransform trait，通过它可以统一处理任意类型的、描述我们希望如何处理图片的 spec：</p><pre><code class=\"language-protobuf\">// 一个 spec 可以包含上述的处理方式之一（这是 protobuf 定义）\nmessage Spec {\n  oneof data {\n    Resize resize = 1;\n    Crop crop = 2;\n    Flipv flipv = 3;\n    Fliph fliph = 4;\n    Contrast contrast = 5;\n    Filter filter = 6;\n    Watermark watermark = 7;\n  }\n}\n</code></pre><p>SpecTransform trait 的定义如下（<a href=\"https://github.com/tyrchen/geektime-rust/blob/master/05_thumbor/src/engine/mod.rs#L16\">代码</a>）：</p><pre><code class=\"language-rust\">// SpecTransform：未来如果添加更多的 spec，只需要实现它即可\npub trait SpecTransform&lt;T&gt; {\n    // 对图片使用 op 做 transform\n    fn transform(&amp;mut self, op: T);\n}\n</code></pre><p>它可以用来对图片使用某个 spec 进行处理。</p><p>但如果你阅读 GitHub 上的源码，你可能会发现一个没用到的文件 <a href=\"http://imageproc.rs\">imageproc.rs</a> 中类似的 trait（<a href=\"https://github.com/tyrchen/geektime-rust/blob/master/05_thumbor/src/imageproc.rs#L41\">代码</a>）：</p><pre><code class=\"language-rust\">pub trait ImageTransform {\n    fn transform(&amp;self, image: &amp;mut PhotonImage);\n}\n</code></pre><p>这个 trait 是第一版的 trait。我依旧保留着它，就是想在此展示一下 trait 设计上的取舍。</p><p>当你审视这段代码的时候会不会觉得，这个 trait 的设计有些草率？因为如果传入的 image 来自不同的图片处理引擎，而某个图片引擎提供的 image 类型不是 PhotonImage，那这个接口不就无法使用了么？</p><p>hmm，这是个设计上的大问题啊。想想看，以目前所学的知识，怎么解决这个问题呢？什么可以帮助我们延迟 image 是否必须是 PhotonImage 的决策呢？</p><p>对，泛型。我们可以使用泛型 trait 修改一下刚才那段代码：</p><pre><code class=\"language-rust\">// 使用 trait 可以统一处理的接口，以后无论增加多少功能，只需要加新的 Spec，然后实现 ImageTransform 接口\npub trait ImageTransform&lt;Image&gt; {\n    fn transform(&amp;self, image: &amp;mut Image);\n}\n</code></pre><p>把传入的 image 类型抽象成泛型类型之后，延迟了图片类型判断和支持的决策，可用性更高。</p><p>但如果你继续对比现在的 ImageTransform和之前写的 SpecTransform，会发现，它们实现 trait 的数据结构和用在 trait 上的泛型参数，正好掉了个个。</p><p>你看，PhotonImage 下对于 Contrast 的 ImageTransform 的实现：</p><pre><code class=\"language-rust\">impl ImageTransform&lt;PhotonImage&gt; for Contrast {\n    fn transform(&amp;self, image: &amp;mut Image) {\n        effects::adjust_contrast(image, self.contrast);\n    }\n}\n</code></pre><p>而同样的，PhotonImage 下对 Contract 的 SpecTransform 的实现：</p><pre><code class=\"language-rust\">impl SpecTransform&lt;&amp;Contrast&gt; for Photon {\n    fn transform(&amp;mut self, op: &amp;Contrast) {\n        effects::adjust_contrast(&amp;mut self.0, op.contrast);\n    }\n}\n</code></pre><p>这两种方式基本上等价，但一个围绕着 Spec 展开，一个围绕着 Image 展开：<br>\n<img src=\"https://static001.geekbang.org/resource/image/05/93/05052aff8a2204ddba4fd4aee81ce193.jpg?wh=2364x1740\" alt=\"\"></p><p>那么，哪种设计更好呢？</p><p>其实二者并没有功能上或者性能上的优劣。</p><p>那为什么我选择了 SpecTransform 的设计呢？在第一版的设计我还没有考虑 Engine的时候，是以 Spec 为中心的；但在把 Engine 考虑进去后，我以 Engine 为中心重新做了设计，这样做的好处是，开发新的 Engine 的时候，SpecTransform trait 用起来更顺手，更自然一些。</p><p>嗯，顺手，自然。接口的设计一定要关注使用者的体验，一个使用起来感觉自然顺手舒服的接口，就是更好的接口。<strong>因为这意味着使用的时候，代码可以自然而然写出来，而无需看文档</strong>。</p><p>比如同样是 Python 代码：</p><pre><code class=\"language-python\">df[df[\"age\"] &gt; 10]\n</code></pre><p>就要比：</p><pre><code class=\"language-python\">df.filter(df.col(\"age\").gt(10))\n</code></pre><p>要更加自然舒服。前面的代码，你看一眼别人怎么用，自己就很快能写出来，而后者，你需要先搞清楚 filter 函数是怎么回事，以及col()、gt() 这两个方法如何使用。</p><p>我们再来看来两段 Rust 代码。这行使用了 From/Into trait 的代码：</p><pre><code class=\"language-rust\">let url = generate_url_with_spec(image_spec.into());\n</code></pre><p>就要比：</p><pre><code class=\"language-rust\">let data = image_spec.encode_to_vec();\nlet s = encode_config(data, URL_SAFE_NO_PAD);\nlet url = generate_url_with_spec(s);\n</code></pre><p>要简洁、自然得多。它把实现细节都屏蔽了起来，只让用户关心他们需要关心的逻辑。<br>\n所以，我们在设计 trait 的时候，除了关注功能，还要注意是否好用、易用。这也是为什么我们在介绍 KV server 的时候，不断强调，trait 在设计结束之后，不要先着急撰写实现 trait 的代码，而是最好先写一些对于 trait 使用的测试代码。</p><p>你在写这些测试代码的使用体验，就是别人在使用你的 trait 构建系统时的真实体验，如果它用起来别扭、啰嗦，不看文档就不容易用对，那这个 trait 本身还有待进一步迭代。</p><h2>用 trait 做桥接</h2><p>在软件开发的绝大多数时候，我们都不会从零到一完完全全设计和构建系统的所有部分。就像盖房子，不可能从一抔土、一块瓦片开始打造。我们需要依赖生态系统中已有的组件。</p><p>作为架构师，你的职责是在生态系统中找到合适的组件，连同你自己打造的部分，一起粘合起来，形成一个产品。所以，你会遇到那些接口与你预期不符的组件，可是自己又无法改变那些组件来让接口满足你的预期，怎么办？</p><p>此刻，我们需要桥接。</p><p>就像要用的电器是二相插口，而附近墙上的插座只有三相插口，我们总不能修改电器或者墙上的插座，使其满足对方吧？正确的做法是购置一个多项插座来桥接二者。</p><p>在 Rust 里，桥接的工作可以通过函数来完成，但最好通过 trait 来桥接。继续看<a href=\"https://time.geekbang.org/column/article/413634\">第 5 讲 </a>thumbor 里的另一个 trait Engine（<a href=\"https://github.com/tyrchen/geektime-rust/blob/master/05_thumbor/src/engine/mod.rs#L8\">代码</a>）：</p><pre><code class=\"language-rust\">// Engine trait：未来可以添加更多的 engine，主流程只需要替换 engine\npub trait Engine {\n    // 对 engine 按照 specs 进行一系列有序的处理\n    fn apply(&amp;mut self, specs: &amp;[Spec]);\n    // 从 engine 中生成目标图片，注意这里用的是 self，而非 self 的引用\n    fn generate(self, format: ImageOutputFormat) -&gt; Vec&lt;u8&gt;;\n}\n</code></pre><p>通过 Engine 这个 trait，我们把第三方的库 photon和自己设计的 Image Spec 连接起来，使得我们不用关心 Engine 背后究竟是什么，只需要调用 apply 和 generate 方法即可：</p><pre><code class=\"language-rust\">// 使用 image engine 处理\nlet mut engine: Photon = data\n    .try_into()\n    .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;\nengine.apply(&amp;spec.specs);\nlet image = engine.generate(ImageOutputFormat::Jpeg(85));\n</code></pre><p>这段代码中，由于之前为 Photon 实现了 TryFrom&lt;Bytes&gt;，所以可以直接调用 try_into() 来得到一个 photon engine：</p><pre><code class=\"language-rust\">// 从 Bytes 转换成 Photon 结构\nimpl TryFrom&lt;Bytes&gt; for Photon {\n    type Error = anyhow::Error;\n\n    fn try_from(data: Bytes) -&gt; Result&lt;Self, Self::Error&gt; {\n        Ok(Self(open_image_from_bytes(&amp;data)?))\n    }\n}\n</code></pre><p>就桥接 thumbor 代码和 photon crate 而言，Engine 表现良好，它让我们不但很容易使用 photon crate，还可以很方便在未来需要的时候替换掉 photon crate。</p><p>不过，Engine 在构造时，所做的桥接还是不够直观和自然，如果不仔细看代码或者文档，使用者可能并不清楚，第3行代码，如何通过 TryFrom/TryInto 得到一个实现了 Engine 的结构。从这个使用体验来看，我们会希望通过使用 Engine trait，任何一个图片引擎都可以统一地创建 Engine结构。怎么办？</p><p>可以为这个 trait 添加一个缺省的 create 方法：</p><pre><code class=\"language-rust\">// Engine trait：未来可以添加更多的 engine，主流程只需要替换 engine\npub trait Engine {\n    // 生成一个新的 engine\n    fn create&lt;T&gt;(data: T) -&gt; Result&lt;Self&gt;\n    where\n        Self: Sized,\n        T: TryInto&lt;Self&gt;,\n    {\n        data.try_into()\n            .map_err(|_| anyhow!(\"failed to create engine\"))\n    }\n    // 对 engine 按照 specs 进行一系列有序的处理\n    fn apply(&amp;mut self, specs: &amp;[Spec]);\n    // 从 engine 中生成目标图片，注意这里用的是 self，而非 self 的引用\n    fn generate(self, format: ImageOutputFormat) -&gt; Vec&lt;u8&gt;;\n}\n</code></pre><p>注意看新 create 方法的约束：任何 T，只要实现了相应的 TryFrom/TryInto，就可以用这个缺省的 create() 方法来构造 Engine。</p><p>有了这个接口后，上面使用 engine 的代码可以更加直观，省掉了第3行的try_into()处理：</p><pre><code class=\"language-rust\">// 使用 image engine 处理\nlet mut engine = Photon::create(data)\n    .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;\nengine.apply(&amp;spec.specs);\nlet image = engine.generate(ImageOutputFormat::Jpeg(85));\n</code></pre><p>桥接是架构中一个非常重要的思想，我们一定要掌握这个思想的精髓。</p><p>再举个例子。比如现在想要系统可以通过访问某个 REST API，得到用户自己发布的、按时间顺序倒排的朋友圈。怎么写这段代码呢？最简单粗暴的方式是：</p><pre><code class=\"language-rust\">let secret_api = api_with_user_token(&amp;user, params);\nlet data: Vec&lt;Status&gt; = reqwest::get(secret_api)?.json()?;\n</code></pre><p>更好的方式是使用 trait 桥接来屏蔽实现细节：</p><pre><code class=\"language-rust\">pub trait FriendCircle {\n\t  fn get_published(&amp;self, user: &amp;User) -&gt; Result&lt;Vec&lt;Status&gt;, FriendCircleError&gt;;\n    ... \n}\n</code></pre><p>这样，我们的业务逻辑代码可以围绕着这个接口展开，而无需关心它具体的实现是来自 REST API，还是其它什么地方；也不用关心实现做没做 cache、有没有重传机制、具体都会返回什么样的错误（FriendCircleError 就已经提供了所有的出错可能）等等。</p><h2>使用 trait 提供控制反转</h2><p>继续看刚才的Engine 代码，在 Engine 和 T 之间通过 TryInto trait 进行了解耦，使得调用者可以灵活处理他们的 T：</p><pre><code class=\"language-rust\">pub trait Engine {\n    // 生成一个新的 engine\n    fn create&lt;T&gt;(data: T) -&gt; Result&lt;Self&gt;\n    where\n        Self: Sized,\n        T: TryInto&lt;Self&gt;,\n    {\n        data.try_into()\n            .map_err(|_| anyhow!(\"failed to create engine\"))\n    }\n    ...\n}\n</code></pre><p>这里还体现了trait 在设计中，另一个很重要的作用，控制反转。</p><p>通过使用 trait，我们可以在设计底层库的时候告诉上层：<strong>我需要某个满足 trait X 的数据，因为我依赖这个数据实现的 trait X 方法来完成某些功能，但这个数据具体怎么实现，我不知道，也不关心</strong>。</p><p>刚才为 Engine 新构建的 create 方法。T 是实现 Engine 所需要的依赖，我们不知道属于类型 T 的 data 是如何在上下文中产生的，也不关心 T 具体是什么，只要 T 实现了 TryInto&lt;Self&gt; 即可。这就是典型的控制反转。</p><p>使用 trait 做控制反转另一个例子是<a href=\"https://time.geekbang.org/column/article/414478\">第 6 讲</a>中的 <a href=\"https://docs.rs/sqlparser/0.12.0/sqlparser/dialect/trait.Dialect.html\">Dialect trait</a>（<a href=\"https://docs.rs/sqlparser/0.12.0/src/sqlparser/dialect/mod.rs.html#43-56\">代码</a>）：</p><pre><code class=\"language-rust\">pub trait Dialect: Debug + Any {\n    /// Determine if a character starts a quoted identifier. The default\n    /// implementation, accepting \"double quoted\" ids is both ANSI-compliant\n    /// and appropriate for most dialects (with the notable exception of\n    /// MySQL, MS SQL, and sqlite). You can accept one of characters listed\n    /// in `Word::matching_end_quote` here\n    fn is_delimited_identifier_start(&amp;self, ch: char) -&gt; bool {\n        ch == '\"'\n    }\n    /// Determine if a character is a valid start character for an unquoted identifier\n    fn is_identifier_start(&amp;self, ch: char) -&gt; bool;\n    /// Determine if a character is a valid unquoted identifier character\n    fn is_identifier_part(&amp;self, ch: char) -&gt; bool;\n}\n</code></pre><p>我们只需要为自己的 SQL 方言实现 Dialect trait：</p><pre><code class=\"language-rust\">// 创建自己的 sql 方言。TyrDialect 支持 identifier 可以是简单的 url\nimpl Dialect for TyrDialect {\n    fn is_identifier_start(&amp;self, ch: char) -&gt; bool {\n        ('a'..='z').contains(&amp;ch) || ('A'..='Z').contains(&amp;ch) || ch == '_'\n    }\n\n    // identifier 可以有 ':', '/', '?', '&amp;', '='\n    fn is_identifier_part(&amp;self, ch: char) -&gt; bool {\n        ('a'..='z').contains(&amp;ch)\n            || ('A'..='Z').contains(&amp;ch)\n            || ('0'..='9').contains(&amp;ch)\n            || [':', '/', '?', '&amp;', '=', '-', '_', '.'].contains(&amp;ch)\n    }\n}\n</code></pre><p>就可以让 sql parser 解析我们的 SQL 方言：</p><pre><code class=\"language-rust\">let ast = Parser::parse_sql(&amp;TyrDialect::default(), sql.as_ref())?;\n</code></pre><p>这就是 Dialect 这个看似简单的 trait 的强大用途。</p><p>对于我们这些使用者来说，通过Dialect trait，可以很方便地注入自己的解析函数，来提供我们的 SQL 方言的额外信息；对于 sqlparser 这个库的作者来说，通过 Dialect trait，他不必关心未来会有多少方言、每个方言长什么样子，只需要方言的作者告诉他如何 tokenize 一个标识符即可。</p><p>控制反转是架构中经常使用到的功能，它能够<strong>让调用者和被调用者之间的关系在某个时刻调转过来，被调用者反过来调用调用者提供的能力，二者协同完成一些事情</strong>。</p><p>比如 MapReduce 的架构：用于 map 的方法和用于 reduce 的方法是啥，MapReduce 的架构设计者并不清楚，但调用者可以把这些方法提供给 MapReduce 架构，由 MapReduce 架构在合适的时候进行调用。</p><p>当然，控制反转并非只能由 trait 来完成，但使用 trait 做控制反转会非常灵活，调用者和被调用者只需要关心它们之间的接口，而非具体的数据结构。</p><h2>用 trait 实现 SOLID 原则</h2><p>其实刚才介绍的用 trait 做控制反转，核心体现的就是面向对象设计时SOLID原则中的，依赖反转原则DIP，这是一个很重要的构建灵活系统的思想。</p><p>在做面向对象设计时，我们经常会探讨 <a href=\"https://en.wikipedia.org/wiki/SOLID\">SOLID 原则</a>：</p><ul>\n<li>SRP：单一职责原则，是指每个模块应该只负责单一的功能，不应该让多个功能耦合在一起，而是应该将其组合在一起。</li>\n<li>OCP：开闭原则，是指软件系统应该对修改关闭，而对扩展开放。</li>\n<li>LSP：里氏替换原则，是指如果组件可替换，那么这些可替换的组件应该遵守相同的约束，或者说接口。</li>\n<li>ISP：接口隔离原则，是指使用者只需要知道他们感兴趣的方法，而不该被迫了解和使用对他们来说无用的方法或者功能。</li>\n<li>DIP：依赖反转原则，是指某些场合下底层代码应该依赖高层代码，而非高层代码去依赖底层代码。</li>\n</ul><p>虽然 Rust 不是一门面向对象语言，但这些思想都是通用的。</p><p>在过去的课程中，我一直强调 SRP 和 OCP。你看<a href=\"https://time.geekbang.org/column/article/414478\">第 6 讲</a>的 Fetch / Load trait，它们都只负责一个很简单的动作：</p><pre><code class=\"language-rust\">#[async_trait]\npub trait Fetch {\n    type Error;\n    async fn fetch(&amp;self) -&gt; Result&lt;String, Self::Error&gt;;\n}\n\npub trait Load {\n    type Error;\n    fn load(self) -&gt; Result&lt;DataSet, Self::Error&gt;;\n}\n</code></pre><p>以 Fetch 为例，我们先实现了 UrlFetcher，后来又根据需要，实现了 FileFetcher。</p><p>FileFetcher 的实现并不会对 UrlFetcher 的实现代码有任何影响，也就是说，在实现 FileFetcher 的时候，已有的所有实现了 Fetch 接口的代码都是稳定的，它们对修改是关闭的；同时，在实现 FileFetcher 的时候，我们扩展了系统的能力，使系统可以根据不同的前缀（<code>from file://</code> 或者 <code>from &lt;http://</code>&gt;）进行不同的处理，这是对扩展开放。</p><p>前面提到的 SpecTransform / Engine trait，包括<a href=\"https://time.geekbang.org/column/article/425001\"> 21 讲</a>中 KV server 里涉及的 CommandService trait：</p><pre><code class=\"language-rust\">/// 对 Command 的处理的抽象\npub trait CommandService {\n    /// 处理 Command，返回 Response\n    fn execute(self, store: &amp;impl Storage) -&gt; CommandResponse;\n}\n</code></pre><p>也是 SRP 和 OCP 原则的践行者。</p><p>LSP 里氏替换原则自不必说，我们本文中所有的内容都在践行通过使用接口，来使组件可替换。比如上文提到的 Engine trait，在 KV server 中我们使用的 Storage trait，都允许我们在不改变代码核心逻辑的前提下，替换其中的主要组件。</p><p>至于 ISP 接口隔离原则，我们目前撰写的 trait 都很简单，天然满足接口隔离原则。其实，大部分时候，当你的 trait 满足 SRP 单一职责原则时，它也满足接口隔离原则。</p><p>但在 Rust 中，有些 trait 的接口可能会比较庞杂，<strong>此时，如果我们想减轻调用者的负担，让它们能够在需要的时候才引入某些接口，可以使用 trait 的继承</strong>。比如 AsyncRead / AsyncWrite / Stream 和它们对应的 AsyncReadExt / AsyncWriteExt / StreamExt 等。这样，复杂的接口被不同的 trait 分担了并隔离开。</p><h2>小结</h2><p>接口设计是架构设计中最核心的环节。<strong>好的接口容易使用，很难误用，会让使用接口的人产生共鸣</strong>。当我们说一段代码读起来/写起来感觉很舒服，或者很不舒服、很冗长、很难看，这种感觉往往就来自于接口给人的感觉，我们可以妥善使用 trait 来降低甚至消除这种不舒服的感觉。</p><p>当我们的代码和其他人的代码共存时，接口在不同的组件之间就起到了桥接的作用。通过桥接，甚至可以把原本设计不好的代码，先用接口封装成我们希望的样子，然后实现这个简单的包装，之后再慢慢改动原先不好的设计。</p><p>这样，由于系统的其它部分使用新的接口处理，未来改动的影响被控制在很小的范围。在第 5 讲设计 thumbor 的时候我也提到，photon 库并不是一个设计良好的库，然而，通过 Engine trait 的桥接，未来即使我们 fork 一下 photon 库，对其大改，并不会影响 thumbor 的代码。</p><p>最后，在软件设计时，我们还要注意 SOLID 原则。基本上，<strong>好的 trait，设计一定是符合 SOLID 原则的</strong>，从 Rust 标准库的设计，以及之前讲到的 trait，结合今天的解读，想必你对此有了一定的认识。未来在使用 trait 构建你自己的接口时，你也可以将 SOLID 原则作为一个备忘清单，随时检查。</p><h3>思考题</h3><p>Rust 下有一个处理 Web 前端的库叫 <a href=\"https://github.com/yewstack/yew\">yew</a>。请 clone 到你本地，然后使用 ag 或者 rgrep（eat our own dogfood）查找一下所有的 trait 定义，看看这些 trait 被设计的目的和意义，并且着重阅读一下它最核心的 Component trait，思考几个问题：</p><ol>\n<li>Component trait 可以做 trait object 么？</li>\n<li>关联类型 Message 和 Properties 的作用是什么？</li>\n<li>作为使用者，该如何用 Component trait？它的 lifecycle 是什么样子的？</li>\n<li>如果你之前有前端开发的经验，比较一下 React / Vue / Elm component 和 yew component 的区别？</li>\n</ol><pre><code class=\"language-rust\">yew on  master via 🦀 v1.55.0\n❯ rgrep \"pub trait\" \"**/*.rs\"\nexamples/router/src/generator.rs\n   155:1   pub trait Generated: Sized {\npackages/yew/src/html/component/mod.rs\n    42:1   pub trait Component: Sized + 'static {\npackages/yew/src/html/component/properties.rs\n     6:1   pub trait Properties: PartialEq {\nexamples/boids/src/math.rs\n   128:1   pub trait WeightedMean&lt;T = Self&gt;: Sized {\n   152:1   pub trait Mean&lt;T = Self&gt;: Sized {\npackages/yew/src/functional/mod.rs\n    69:1   pub trait FunctionProvider {\npackages/yew/src/html/conversion.rs\n     5:1   pub trait ImplicitClone: Clone {}\n    18:1   pub trait IntoPropValue&lt;T&gt; {\npackages/yew/src/html/listener/mod.rs\n    27:1   pub trait TargetCast\n   136:1   pub trait IntoEventCallback&lt;EVENT&gt; {\npackages/yew/src/scheduler.rs\n    11:1   pub trait Runnable {\npackages/yew-router/src/routable.rs\n    16:1   pub trait Routable: Sized + Clone {\npackages/yew-agent/src/pool.rs\n    60:1   pub trait Dispatched: Agent + Sized + 'static {\n    78:1   pub trait Dispatchable {}\npackages/yew/src/html/component/scope.rs\n   508:1   pub trait SendAsMessage&lt;COMP: Component&gt; {\npackages/yew-macro/src/stringify.rs\n    16:1   pub trait Stringify {\npackages/yew-agent/src/lib.rs\n    22:1   pub trait Agent: Sized + 'static {\n    82:1   pub trait Discoverer {\n    92:1   pub trait Bridge&lt;AGN: Agent&gt; {\n    98:1   pub trait Bridged: Agent + Sized + 'static {\npackages/yew-agent/src/utils/store.rs\n    20:1   pub trait Store: Sized + 'static {\n   138:1   pub trait Bridgeable: Sized + 'static {\npackages/yew-macro/src/html_tree/mod.rs\n   178:1   pub trait ToNodeIterator {\npackages/yew/src/virtual_dom/listeners.rs\n    42:1   pub trait Listener {\npackages/yew-agent/src/worker/mod.rs\n    17:1   pub trait Threaded {\n    24:1   pub trait Packed {\n</code></pre><p>感谢你的阅读，如果你觉得有收获，也欢迎你分享给身边的朋友，邀他一起讨论。今天你已经完成Rust学习的第25次打卡啦，我们下节课见！</p>","neighbors":{"left":{"article_title":"24｜类型系统：如何在实战中使用trait object？","id":428018},"right":{"article_title":"加餐｜Rust2021版次问世了！","id":429665}},"comments":[{"had_liked":false,"id":319064,"user_name":"郑晔","can_delete":false,"product_type":"c1","uid":1258861,"ip_address":"","ucode":"1EBD5AA5D4FC89","user_header":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","comment_is_top":false,"comment_ctime":1635562667,"is_pvip":false,"replies":[{"id":"116401","content":"谢谢指正。我的理解来自于 https:&#47;&#47;en.wikipedia.org&#47;wiki&#47;Single-responsibility_principle<br><br>&gt; 一个类或模块应该有一个，而且只有一个，改变（例如重写）的理由","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1636557513,"ip_address":"","comment_id":319064,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14520464555","product_id":100085301,"comment_content":"老师对单一职责的理解是错的，这一点是我特意在《软件设计之美》中纠正的，因为单一功能是一个永远为真的说法，单一职责是要把变化纳入考量。具体的可以参考《软件设计之美》和《架构整洁之道》中关于单一职责的讲解。","like_count":3,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529483,"discussion_content":"谢谢指正。我的理解来自于 https://en.wikipedia.org/wiki/Single-responsibility_principle\n\n&amp;gt; 一个类或模块应该有一个，而且只有一个，改变（例如重写）的理由","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1636557513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1046714,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","nickname":"约书亚","note":"","ucode":"81EA27ADD9EC1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587983,"discussion_content":"真理。单从字面理解单一职责这4个字其实毫无意义，必须考虑变化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663424674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"天津"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2254917,"avatar":"https://static001.geekbang.org/account/avatar/00/22/68/45/ddf89612.jpg","nickname":"bestgopher","note":"","ucode":"D89735C8CA9C6E","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549266,"discussion_content":"活捉大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643791815,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317751,"user_name":"Marvichov","can_delete":false,"product_type":"c1","uid":1111835,"ip_address":"","ucode":"7482099415C41C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/1b/db7a0edc.jpg","comment_is_top":false,"comment_ctime":1634925604,"is_pvip":false,"replies":[{"id":"115232","content":"👍 非常好！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1635121636,"ip_address":"","comment_id":317751,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5929892900","product_id":100085301,"comment_content":"doc: https:&#47;&#47;github.com&#47;yewstack&#47;yew&#47;blob&#47;master&#47;packages&#47;yew&#47;src&#47;html&#47;component&#47;mod.rs#L42<br><br>1. 不能, 返回类型有Self; 运行时type被erase掉了, 不知道Self具体是什么类型.<br>2. Message感觉有点像actor里面的message: op to change component state. 应该是用于定义交互的时候, dynamic change component的. Properties应该是DOM的property, 用于render view的…<br><br>比如impl Component for List https:&#47;&#47;github.com&#47;yewstack&#47;yew&#47;blob&#47;master&#47;packages&#47;yew&#47;src&#47;virtual_dom&#47;vlist.rs#L495<br>```<br>    #[derive(Clone, Properties, PartialEq)]<br>    pub struct ListProps {<br>        pub children: Children,<br>    }<br><br>impl Component for List {<br>      fn view(&amp;self, ctx: &amp;Context&lt;Self&gt;) -&gt; Html {<br>          html! { &lt;&gt;{ for ctx.props().children.iter() }&lt;&#47;&gt; }<br>      }<br>```<br>3. https:&#47;&#47;docs.rs&#47;yew&#47;0.18.0&#47;yew&#47;#example; 重点是`Sized` `+ &#39;Static` bound`. 实现的类型必须是Sized. 同时如果有reference element, 其lifetime必须是static的.<br><br>感觉virtual dom有必要了解了解...","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528955,"discussion_content":"👍 非常好！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635121636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2101988,"avatar":"https://static001.geekbang.org/account/avatar/00/20/12/e4/57ade29a.jpg","nickname":"dva","note":"","ucode":"EE27DAFCBF198D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":533104,"discussion_content":"你真的好强呀，兄弟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637768744,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357484,"user_name":"进击的Lancelot","can_delete":false,"product_type":"c1","uid":2620407,"ip_address":"广东","ucode":"3BCC355801DC61","user_header":"https://static001.geekbang.org/account/avatar/00/27/fb/f7/88ab6f83.jpg","comment_is_top":false,"comment_ctime":1663301315,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1663301315","product_id":100085301,"comment_content":"思考题：<br><br>Component trait 可以做 trait object 么？<br>做不了 trait object，因为其中的方法并不符合对象安全原则，要么返回  Self 对象，要么带有泛型参数<br><br>关联类型 Message 和 Properties 的作用是什么？<br>Message 的作用是用来和 Component 进行交互，使其获得动态能力的。 properties 则表达了 Component 的属性，当 Component 的父组件被重新渲染时，子组件要么重新生成，要么从传递给 changed 方法中的上下文接受新的 properties<br><br>做为使用者，该如何用 Component trait？它的 lifecycle 是什么样子的？<br>为自定义类型实现 Component trait 需要指定关联类型 Message 和 Properties，并提供 create 和 view 两个方法的自定义实现即可。它的 lifecycle 是静态生命周期，贯穿程序的始终","like_count":0},{"had_liked":false,"id":331042,"user_name":"渡鸦10086","can_delete":false,"product_type":"c1","uid":2491000,"ip_address":"","ucode":"58D72C8B5E9B98","user_header":"https://static001.geekbang.org/account/avatar/00/26/02/78/4d40b4b2.jpg","comment_is_top":false,"comment_ctime":1642392164,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1642392164","product_id":100085301,"comment_content":"思考题：<br>1. Component trait 的 create 方法会返回 Self，所以不能做 trait Object<br>2. 关联类型 Message 用于让 Components 类型动态化及可交互化，Component 可以使用 enum 或 () 来声明。 Properties 就是 Component 的属性，当 Component 的父组件被重新渲染时时，它将被重新创建，或者在传递给被改变的 life cycle 方法的上下文中接收新的属性。<br>3. YEW的官方实例：https:&#47;&#47;docs.rs&#47;yew&#47;0.18.0&#47;yew&#47;#example。life cycle ： `&#39;static` 代表静态生命周期<br>4. 没有前端经验。。<br>","like_count":0},{"had_liked":false,"id":323323,"user_name":"核桃","can_delete":false,"product_type":"c1","uid":1385204,"ip_address":"","ucode":"7AB05270CBCCCB","user_header":"https://static001.geekbang.org/account/avatar/00/15/22/f4/9fd6f8f0.jpg","comment_is_top":false,"comment_ctime":1637834317,"is_pvip":false,"replies":[{"id":"118889","content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639850563,"ip_address":"","comment_id":323323,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1637834317","product_id":100085301,"comment_content":"今天写了一段全局单例的代码，如下所示.<br><br>```<br>pub struct Monitor {<br>    sender: UnsafeCell&lt;Option&lt;mpsc::TxUnbounded&lt;Vec&lt;xxx&gt;&gt;&gt;&gt;,<br>}<br><br>impl Monitor {<br>    pub fn set_sender(&amp;self, sender: mpsc::TxUnbounded&lt;Vec&lt;xxx&gt;&gt;) {<br>        let self_sender_option: &amp;mut Option&lt;mpsc::TxUnbounded&lt;Vec&lt;xxx&gt;&gt;&gt; =<br>            unsafe { transmute(self.sender.get()) };<br>        self_sender_option.replace(sender);<br>    }<br><br>    pub fn send_monitor(&amp;self, info_vec: Vec&lt;xxx&gt;) {<br>        let self_sender: &amp;mut Option&lt;mpsc::TxUnbounded&lt;Vec&lt;xxx&gt;&gt;&gt; =<br>            unsafe { transmute(self.sender.get()) };<br>        ...<br>    }<br>}<br><br>unsafe impl Send for Monitor {}<br>unsafe impl Sync for Monitor {}<br><br>&#47;&#47;why we use Arc to contain Monitor is that lazy_static seems a const value.<br>&#47;&#47;rust can&#39;t change the const value unless new at first.<br>&#47;&#47;but Arc can share to use the value.<br>lazy_static! {<br>    pub static ref GLOBAL_MONITOR: Arc&lt;Monitor&gt; =<br>        Arc::new(Monitor { sender: UnsafeCell::new(None) });<br>}<br>```<br><br>这里使用lazy_static进行全局实现静态变量，但是因为初始化的时候并没有办法指向一个其他的变量，因此这里考虑使用了Arc处理，但是这段代码其实还是有点问题的，因为并没有考虑到竞争并发的情况，但是这里似乎更加适合使用once cell。rust在这部分的实现，感觉还是有点欠缺的。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539850,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639850563,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317855,"user_name":"0@1","can_delete":false,"product_type":"c1","uid":1549191,"ip_address":"","ucode":"932A4139DB8169","user_header":"https://static001.geekbang.org/account/avatar/00/17/a3/87/eb923eb3.jpg","comment_is_top":false,"comment_ctime":1634996081,"is_pvip":false,"replies":[{"id":"115224","content":"trait 就是让对应的类型拥有对应的行为。所以你为 struct 实现 trait，这个 struct 类型就有了 trait 的行为；你对 struct 的引用实现 trait，struct 类型的引用就有了 trait 的行为；裸指针也是类似。当你持有一个 *const MyStruct 的数据时，你可以调用 trait 的方法。对裸指针来说，一般实现 trait 的意义不大，因为 self 此时可干的事情很少。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1635121196,"ip_address":"","comment_id":317855,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1634996081","product_id":100085301,"comment_content":"老师，想问下关于trait的一些问题, 下面是个代码例子，<br>struct MyStruct;<br>trait MyTrait{<br>    fn test(&amp;self);<br>}<br><br>impl MyTrait for MyStruct{<br>    fn test(&amp;self) {<br>        println!(&quot;MyStruct&quot;)<br>    }<br>}<br>impl MyTrait for &amp;MyStruct{<br>    fn test(&amp;self) {<br>        println!(&quot;&amp;MyStruct&quot;)<br>    }<br>}<br>impl MyTrait for *const MyStruct{<br>    fn test(&amp;self) {<br>        println!(&quot;*const MyStruct&quot;)<br>    }<br>}<br>fn main() {<br>   let my_struct = MyStruct;<br>    my_struct.test();<br>    &amp;my_struct.test();<br>    let my_struct_ptr = &amp;my_struct as *const MyStruct;<br>    my_struct_ptr.test();<br>}<br><br>1. impl MyTrait for &amp;MyStruct 和 impl MyTrait for MyStruct 这2个有什么区别，什么情况下适合<br>为引用实现trait, impl MyTrait for &amp;MyStruct<br><br>2. impl MyTrait for *const MyStruct <br>这种方式，给裸指针实现trait, 有什么使用场景么<br><br><br><br>","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529008,"discussion_content":"trait 就是让对应的类型拥有对应的行为。所以你为 struct 实现 trait，这个 struct 类型就有了 trait 的行为；你对 struct 的引用实现 trait，struct 类型的引用就有了 trait 的行为；裸指针也是类似。当你持有一个 *const MyStruct 的数据时，你可以调用 trait 的方法。对裸指针来说，一般实现 trait 的意义不大，因为 self 此时可干的事情很少。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635121196,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317583,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1634865965,"is_pvip":false,"replies":[{"id":"115235","content":"👍","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1635121669,"ip_address":"","comment_id":317583,"utype":1}],"discussion_count":1,"race_medal":2,"score":"1634865965","product_id":100085301,"comment_content":"接口的设计要注重用户体验，这太重要了。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528881,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635121669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}