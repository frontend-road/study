{"id":117247,"title":"36 | 记一次线上SQL死锁事故：如何避免死锁？","content":"<p>你好，我是刘超。今天我们来聊聊死锁，开始之前，先分享个小故事，相信你可能遇到过，或能从中获得一点启发。</p><p>之前我参与过一个项目，在项目初期，我们是没有将读写表分离的，而是基于一个主库完成读写操作。在业务量逐渐增大的时候，我们偶尔会收到系统的异常报警信息，DBA通知我们数据库出现了死锁异常。</p><p>按理说业务开始是比较简单的，就是新增订单、修改订单、查询订单等操作，那为什么会出现死锁呢？经过日志分析，我们发现是作为幂等性校验的一张表经常出现死锁异常。我们和DBA讨论之后，初步怀疑是索引导致的死锁问题。后来我们在开发环境中模拟了相关操作，果然重现了该死锁异常。</p><p>接下来我们就通过实战来重现下该业务死锁异常。首先，创建一张订单记录表，该表主要用于校验订单重复创建：</p><pre><code>CREATE TABLE `order_record`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `order_no` int(11) DEFAULT NULL,\n  `status` int(4) DEFAULT NULL,\n  `create_date` datetime(0) DEFAULT NULL,\n  PRIMARY KEY (`id`) USING BTREE,\n  INDEX `idx_order_status`(`order_no`,`status`) USING BTREE\n) ENGINE = InnoDB\n</code></pre><p>为了能重现该问题，我们先将事务设置为手动提交。这里要注意一下，MySQL数据库和Oracle提交事务不太一样，MySQL数据库默认情况下是自动提交事务，我们可以通过以下命令行查看自动提交事务是否开启：</p><pre><code>mysql&gt; show variables like 'autocommit';\n+---------------+-------+\n| Variable_name | Value |\n+---------------+-------+\n| autocommit    | ON    |\n+---------------+-------+\n1 row in set (0.01 sec)\n</code></pre><p>下面就操作吧，先将MySQL数据库的事务提交设置为手动提交，通过以下命令行可以关闭自动提交事务：</p><pre><code>mysql&gt; set autocommit = 0;\nQuery OK, 0 rows affected (0.00 sec)\n</code></pre><!-- [[[read_end]]] --><p>订单在做幂等性校验时，先是通过订单号检查订单是否存在，如果不存在则新增订单记录。知道具体的逻辑之后，我们再来模拟创建产生死锁的运行SQL语句。首先，我们模拟新建两个订单，并按照以下顺序执行幂等性校验SQL语句（垂直方向代表执行的时间顺序）：</p><p><img src=\"https://static001.geekbang.org/resource/image/49/a0/49198c13e2dfdff0a9492a1b58cd93a0.jpg?wh=1360*1072\" alt=\"\"></p><p>此时，我们会发现两个事务已经进入死锁状态。我们可以在information_schema数据库中查询到具体的死锁情况，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/7d/47/7d6e8c42d082ac5b75882e3d171a8047.jpg?wh=2348*558\" alt=\"\"></p><p>看到这，你可能会想，<span class=\"orange\">为什么SELECT要加for update排他锁，而不是使用共享锁呢？</span>试想下，如果是两个订单号一样的请求同时进来，就有可能出现幻读。也就是说，一开始事务A中的查询没有该订单号，后来事务B新增了一个该订单号的记录，此时事务A再新增一条该订单号记录，就会创建重复的订单记录。面对这种情况，我们可以使用锁间隙算法来防止幻读。</p><h2>死锁是如何产生的？</h2><p>上面我们说到了锁间隙，在<a href=\"https://time.geekbang.org/column/article/114194\">第33讲</a>中，我已经讲过了并发事务中的锁机制以及行锁的具体实现算法，不妨回顾一下。</p><p>行锁的具体实现算法有三种：record lock、gap lock以及next-key lock。record lock是专门对索引项加锁；gap lock是对索引项之间的间隙加锁；next-key lock则是前面两种的组合，对索引项以其之间的间隙加锁。</p><p>只在可重复读或以上隔离级别下的特定操作才会取得gap lock或next-key lock，在Select、Update和Delete时，除了基于唯一索引的查询之外，其它索引查询时都会获取gap lock或next-key lock，即锁住其扫描的范围。主键索引也属于唯一索引，所以主键索引是不会使用gap lock或next-key lock。</p><p>在MySQL中，gap lock默认是开启的，即innodb_locks_unsafe_for_binlog参数值是disable的，且MySQL中默认的是RR事务隔离级别。</p><p>当我们执行以下查询SQL时，由于order_no列为非唯一索引，此时又是RR事务隔离级别，所以SELECT的加锁类型为gap lock，这里的gap范围是(4,+∞）。</p><blockquote>\n<p>SELECT id FROM <code>demo</code>.<code>order_record</code> where <code>order_no</code> = 4 for update;</p>\n</blockquote><p>执行查询SQL语句获取的gap lock并不会导致阻塞，而当我们执行以下插入SQL时，会在插入间隙上再次获取插入意向锁。插入意向锁其实也是一种gap锁，它与gap lock是冲突的，所以当其它事务持有该间隙的gap lock时，需要等待其它事务释放gap lock之后，才能获取到插入意向锁。</p><p>以上事务A和事务B都持有间隙(4,+∞）的gap锁，而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的gap锁释放，于是就造成了循环等待，导致死锁。</p><blockquote>\n<p>INSERT INTO <code>demo</code>.<code>order_record</code>(<code>order_no</code>, <code>status</code>, <code>create_date</code>) VALUES (5, 1, ‘2019-07-13 10:57:03’);</p>\n</blockquote><p>我们可以通过以下锁的兼容矩阵图，来查看锁的兼容性：</p><p><img src=\"https://static001.geekbang.org/resource/image/58/e3/58b1567a4ff86460ececfd420eda80e3.jpg?wh=1358*404\" alt=\"\"></p><h2>避免死锁的措施</h2><p>知道了死锁问题源自哪儿，就可以找到合适的方法来避免它了。</p><p>避免死锁最直观的方法就是在两个事务相互等待时，当一个事务的等待时间超过设置的某一阈值，就对这个事务进行回滚，另一个事务就可以继续执行了。这种方法简单有效，在InnoDB中，参数innodb_lock_wait_timeout是用来设置超时时间的。</p><p>另外，我们还可以将order_no列设置为唯一索引列。虽然不能防止幻读，但我们可以利用它的唯一性来保证订单记录不重复创建，这种方式唯一的缺点就是当遇到重复创建订单时会抛出异常。</p><p>我们还可以使用其它的方式来代替数据库实现幂等性校验。例如，使用Redis以及ZooKeeper来实现，运行效率比数据库更佳。</p><h2>其它常见的SQL死锁问题</h2><p>这里再补充一些常见的SQL死锁问题，以便你遇到时也能知道其原因，从而顺利解决。</p><p>我们知道死锁的四个必要条件：互斥、占有且等待、不可强占用、循环等待。只要系统发生死锁，这些条件必然成立。所以在一些经常需要使用互斥共用一些资源，且有可能循环等待的业务场景中，要特别注意死锁问题。</p><p>接下来，我们再来了解一个出现死锁的场景。</p><p>我们讲过，InnoDB存储引擎的主键索引为聚簇索引，其它索引为辅助索引。如果我们之前使用辅助索引来更新数据库，就需要修改为使用聚簇索引来更新数据库。如果两个更新事务使用了不同的辅助索引，或一个使用了辅助索引，一个使用了聚簇索引，就都有可能导致锁资源的循环等待。由于本身两个事务是互斥，也就构成了以上死锁的四个必要条件了。</p><p>我们还是以上面的这个订单记录表来重现下聚簇索引和辅助索引更新时，循环等待锁资源导致的死锁问题：</p><p><img src=\"https://static001.geekbang.org/resource/image/b6/e7/b685033798d1027dac3f2f6cb1c2c6e7.jpg?wh=1358*250\" alt=\"\"></p><p>出现死锁的步骤：</p><p><img src=\"https://static001.geekbang.org/resource/image/e0/b4/e018d73c4a00de2bc3dc6932e0fa75b4.jpg?wh=1362*422\" alt=\"\"></p><p>综上可知，在更新操作时，我们应该尽量使用主键来更新表字段，这样可以有效避免一些不必要的死锁发生。</p><h2>总结</h2><p>数据库发生死锁的概率并不是很大，一旦遇到了，就一定要彻查具体原因，尽快找出解决方案，老实说，过程不简单。我们只有先对MySQL的InnoDB存储引擎有足够的了解，才能剖析出造成死锁的具体原因。</p><p>例如，以上我例举的两种发生死锁的场景，一个考验的是我们对锁算法的了解，另外一个考验则是我们对聚簇索引和辅助索引的熟悉程度。</p><p><span class=\"orange\">解决死锁的最佳方式当然就是预防死锁的发生了，我们平时编程中，可以通过以下一些常规手段来预防死锁的发生：</span></p><p>1.在编程中尽量按照固定的顺序来处理数据库记录，假设有两个更新操作，分别更新两条相同的记录，但更新顺序不一样，有可能导致死锁；</p><p>2.在允许幻读和不可重复读的情况下，尽量使用RC事务隔离级别，可以避免gap lock导致的死锁问题；</p><p>3.更新表时，尽量使用主键更新；</p><p>4.避免长事务，尽量将长事务拆解，可以降低与其它事务发生冲突的概率；</p><p>5.设置锁等待超时参数，我们可以通过innodb_lock_wait_timeout设置合理的等待超时阈值，特别是在一些高并发的业务中，我们可以尽量将该值设置得小一些，避免大量事务等待，占用系统资源，造成严重的性能开销。</p><h2>思考题</h2><p>除了设置  innodb_lock_wait_timeout  参数来避免已经产生死锁的SQL长时间等待，你还知道其它方法来解决类似问题吗？</p><p>期待在留言区看到你的见解。也欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他一起讨论。</p><p></p>","neighbors":{"left":{"article_title":"35 | MySQL调优之索引：索引的失效与优化","id":116369},"right":{"article_title":"37 | 什么时候需要分表分库？","id":118384}},"comments":[{"had_liked":false,"id":123534,"user_name":"张学磊","can_delete":false,"product_type":"c1","uid":1250029,"ip_address":"","ucode":"F545F384A6F1E1","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotSSnZic41tGkbflx0ogIg3ia6g2muFY1hCgosL2t3icZm7I8Ax1hcv1jNgr6vrZ53dpBuGhaoc6DKg/132","comment_is_top":false,"comment_ctime":1565694976,"is_pvip":false,"replies":[{"id":"45562","content":"这个回答是我想要的。<br><br>Innodb提供了wait-for graph算法来主动进行死锁检测，我们可以通过innodb_deadlock_detect = on  打开死锁检测。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1565833812,"ip_address":"","comment_id":123534,"utype":1}],"discussion_count":1,"race_medal":0,"score":"267853667328","product_id":100028001,"comment_content":"MySQL默认开启了死锁检测机制，当检测到死锁后会选择一个最小(锁定资源最少得事务)的事务进行回滚","like_count":63,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462713,"discussion_content":"这个回答是我想要的。\n\nInnodb提供了wait-for graph算法来主动进行死锁检测，我们可以通过innodb_deadlock_detect = on  打开死锁检测。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565833812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205631,"user_name":"ty_young","can_delete":false,"product_type":"c1","uid":1284337,"ip_address":"","ucode":"EB1D5DB0AE7B33","user_header":"","comment_is_top":false,"comment_ctime":1586691365,"is_pvip":false,"replies":[{"id":"77102","content":"是的，共享锁和排他锁是属于行锁，意向锁都属于表锁","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1586862773,"ip_address":"","comment_id":205631,"utype":1}],"discussion_count":3,"race_medal":0,"score":"48831331621","product_id":100028001,"comment_content":"老师您好，请问插入意向锁是一种表锁么","like_count":11,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491533,"discussion_content":"是的，共享锁和排他锁是属于行锁，意向锁都属于表锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586862773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413996,"discussion_content":"插入意向锁是行级锁 执行完mvcc后会加锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636632881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542194,"discussion_content":"额 你在哪里看到的插入意向锁是行级锁？我怎么看到的不一样呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640678901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":413996,"ip_address":""},"score":542194,"extra":""}]}]},{"had_liked":false,"id":124546,"user_name":"ok","can_delete":false,"product_type":"c1","uid":1350706,"ip_address":"","ucode":"7D460A24E3F380","user_header":"https://static001.geekbang.org/account/avatar/00/14/9c/32/77e30b6e.jpg","comment_is_top":false,"comment_ctime":1565918953,"is_pvip":false,"replies":[{"id":"51147","content":"在3的insert操作中，回去获取插入意向锁，而插入意向锁也是一种gap锁，根据矩阵图，插入意向锁和gap间隙锁是冲突的，所以insert操作需要等待间隙锁的释放。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568541579,"ip_address":"","comment_id":124546,"utype":1}],"discussion_count":6,"race_medal":0,"score":"40220624617","product_id":100028001,"comment_content":"老师，请问事例中insert order_record的事务AB中，请解答下疑惑，我描述如下<br>1、事务A执行select 4 for update获取（4,+∞）间隙锁<br>2、图中B事务再执行select 5 for update获取（5,+∞）的间隙锁 <br>3、事务A执行insert 4 发现事务A自己持有（4,+∞）间隙锁，所以不用等待呀！<br>4、事务B执行insert 5 发现事务A没有commit，持有（4,+∞）间隙锁，所以等待事务A释放锁<br>5、事务A提交，事务B insert 5获取到锁，commit<br><br>请指出问题…","like_count":10,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463218,"discussion_content":"在3的insert操作中，回去获取插入意向锁，而插入意向锁也是一种gap锁，根据矩阵图，插入意向锁和gap间隙锁是冲突的，所以insert操作需要等待间隙锁的释放。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568541579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1636410,"avatar":"https://static001.geekbang.org/account/avatar/00/18/f8/3a/e0c14cb3.jpg","nickname":"lizhibo","note":"","ucode":"FDF4FA12C699B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24518,"discussion_content":"其实 他们的间隙锁应该是 从最后一条记录开始 我觉得不是从4开始的 因为判断是4不存在才会插入 应该是（最后一条记录，+∞） 5 也是 因为记录4没有提交","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1570164266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1239557,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ea/05/c0d8014d.jpg","nickname":"一道阳光","note":"","ucode":"F35207CCCEC6E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1636410,"avatar":"https://static001.geekbang.org/account/avatar/00/18/f8/3a/e0c14cb3.jpg","nickname":"lizhibo","note":"","ucode":"FDF4FA12C699B3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":256530,"discussion_content":"两个事务获取到的间隙锁区间都是一样的，都能获取到间隙锁，但是不允许事务A的插入与事务B获取到间隙锁这两个过程都发生。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588491183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":24518,"ip_address":""},"score":256530,"extra":""}]},{"author":{"id":1633352,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo6LWpXbPSmCJI5N3EV3jOoUHaR3qKNhIzXnGDlyLuMqBCttZn1wSDbIsANIicacgMiaicib5iaUBYhcHA/132","nickname":"Geek_d36e4b","note":"","ucode":"ACBC2B93B0E3B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413961,"discussion_content":"实际上间隙锁的范围应该是 (-∞,+∞) , 因为此时表里没有任何记录","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636620071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1118374,"avatar":"https://static001.geekbang.org/account/avatar/00/11/10/a6/4d2c933e.jpg","nickname":"K","note":"","ucode":"69831D1EFC083C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5262,"discussion_content":"我刚刚看到老师说的，重点不是事务A看到自己持有gap锁，是事务A发现事务B也持有，所以需要等待。麻烦老师解释一下看对不对啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566121696,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1239557,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ea/05/c0d8014d.jpg","nickname":"一道阳光","note":"","ucode":"F35207CCCEC6E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1118374,"avatar":"https://static001.geekbang.org/account/avatar/00/11/10/a6/4d2c933e.jpg","nickname":"K","note":"","ucode":"69831D1EFC083C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":256528,"discussion_content":"是的，两个事务获取的间隙锁区间是一样的，在mysql45讲里，多个事务间隙锁的获取不会有冲突，造成冲突的是事务A的插入这个操作与事务B获取到的间隙锁造成了冲突。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1588491056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5262,"ip_address":""},"score":256528,"extra":""}]}]},{"had_liked":false,"id":123271,"user_name":"我已经设置了昵称","can_delete":false,"product_type":"c1","uid":1364034,"ip_address":"","ucode":"ED672C5EBDBDC4","user_header":"https://static001.geekbang.org/account/avatar/00/14/d0/42/6fd01fb9.jpg","comment_is_top":false,"comment_ctime":1565656509,"is_pvip":false,"replies":[{"id":"45279","content":"for update是一种悲观锁实现，我们可以使用性能更好的乐观锁来实现，通过版本号来实现数据更新不丢失问题，这种方式是最佳选择。<br><br>而对于插入时防重复问题，可以对不允许重复字段设置唯一索引，进行唯一约束，这是一种不友好的实现方式。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1565660954,"ip_address":"","comment_id":123271,"utype":1}],"discussion_count":3,"race_medal":0,"score":"27335460285","product_id":100028001,"comment_content":"老师。我们一般不会在查询的时候加上for update，我们的组长让我们事务中不要放查询语句，只能放插入或者更新，就是提前查好，组装好，然后开始执行事务。我觉得这其实会出现重复插入（并发量一高就会出现）。请问老师事务中真的不能做查询操作吗，还有查询的时候怎么防止同时两个事务查不到相对应的数据而造成重复插入","like_count":7,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462606,"discussion_content":"for update是一种悲观锁实现，我们可以使用性能更好的乐观锁来实现，通过版本号来实现数据更新不丢失问题，这种方式是最佳选择。\n\n而对于插入时防重复问题，可以对不允许重复字段设置唯一索引，进行唯一约束，这是一种不友好的实现方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565660954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1114064,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ff/d0/402be1e9.jpg","nickname":"VIC","note":"","ucode":"3B3E6D344488B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365225,"discussion_content":"版本号，是更新还是插入？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617753480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306601,"discussion_content":"你这个问题是个幂等问题，解决办法很多，不要局限于数据库","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600326664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170518,"user_name":"阿杜","can_delete":false,"product_type":"c1","uid":1066705,"ip_address":"","ucode":"349D3572F5ABE7","user_header":"https://static001.geekbang.org/account/avatar/00/10/46/d1/a1ddf49f.jpg","comment_is_top":false,"comment_ctime":1578624613,"is_pvip":false,"replies":[{"id":"70530","content":"1、因为更新索引字段要获取该字段的索引；<br>2、非聚簇索引就是非主键索引，即status字段索引。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1582723211,"ip_address":"","comment_id":170518,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18758493797","product_id":100028001,"comment_content":"老师，有两个人闻到这个问题，感觉回答的我也不是很明白：<br>1:老师你最后放的那张图，为啥主健索引还需要获取非主键索引的锁啊，主键索引不是已经持有这一整行数据了么？<br>2.老师，您最后的那个例子，更新status时要获取index_order_status非聚簇索引，这句话能稍微解释一下吗？谢谢了<br>麻烦老师详细解答下。","like_count":4,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481005,"discussion_content":"1、因为更新索引字段要获取该字段的索引；\n2、非聚簇索引就是非主键索引，即status字段索引。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582723211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1049208,"avatar":"https://static001.geekbang.org/account/avatar/00/10/02/78/23c56bce.jpg","nickname":"james","note":"","ucode":"5701899403917C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319709,"discussion_content":"获取主键索引后, 要更新status, status的值在主键索引叶子节点里, 光更新这个还不行啊, status也是索引啊, 所以在更新status索引的时候也得得到锁啊, 但是这个锁已经被where status=xx这条语句占着了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1604107465,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1961072,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/ec/70/50af6724.jpg","nickname":"张咘咘","note":"","ucode":"4AA6E0DF112CF3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384444,"discussion_content":"那我可以这么理解吗？非主键索引加锁的时候 其实还要进行一次回表找对应的主键进行加锁吗？那主键索引和非主键索引两种行锁的实现是 一个要回表 一个不要回表吗？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626595102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123222,"user_name":"a、","can_delete":false,"product_type":"c1","uid":1532404,"ip_address":"","ucode":"590FE8DB111492","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvUlicgrWtibbDzwhLw5cQrDSy2JuE1mVvmXq11KQIwpLicgDuWfpp9asE0VCN6HhibPDWn7wBc2lfmA/132","comment_is_top":false,"comment_ctime":1565630495,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18745499679","product_id":100028001,"comment_content":"1.设置Transaction的超时时间<br>2.设置Transaction的级别为串行化级别","like_count":4},{"had_liked":false,"id":166018,"user_name":"insist","can_delete":false,"product_type":"c1","uid":1054536,"ip_address":"","ucode":"1EE2800A900BA7","user_header":"https://static001.geekbang.org/account/avatar/00/10/17/48/3ab39c86.jpg","comment_is_top":false,"comment_ctime":1577363279,"is_pvip":false,"replies":[{"id":"65933","content":"由于 order_no 列为非唯一索引，此时又是 RR 事务隔离级别，所以事务A的select获取的是gap锁，事务B也是获取的gap锁，gap锁是相互兼容的，所以可以同时获取到。<br><br>是为了防止幻读，需要通过插入意向锁实现阻塞等待gap锁的释放。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1578487424,"ip_address":"","comment_id":166018,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14462265167","product_id":100028001,"comment_content":"事务 A 和事务 B 都持有间隙 (4,+∞）的 gap 锁，而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的 gap 锁释放，于是就造成了循环等待，导致死锁<br>------------------<br>老师，请问一下，1、为什么A、B可以同时持有gap锁呢？2、为什么获取意向锁之前需要等待对方的gap锁呢？ 比较迷茫","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479353,"discussion_content":"由于 order_no 列为非唯一索引，此时又是 RR 事务隔离级别，所以事务A的select获取的是gap锁，事务B也是获取的gap锁，gap锁是相互兼容的，所以可以同时获取到。\n\n是为了防止幻读，需要通过插入意向锁实现阻塞等待gap锁的释放。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578487424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1000353,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/43/a1/abb7bfe3.jpg","nickname":"李亚方","note":"","ucode":"5828A930327E28","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387530,"discussion_content":"可重复读是允许幻读出现的呀？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628235481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1000353,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/43/a1/abb7bfe3.jpg","nickname":"李亚方","note":"","ucode":"5828A930327E28","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542197,"discussion_content":"对的 我也觉得有问题 应该是为了防止可重复读 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640679677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":387530,"ip_address":""},"score":542197,"extra":""}]}]},{"had_liked":false,"id":152418,"user_name":"cky.宇","can_delete":false,"product_type":"c1","uid":1369447,"ip_address":"","ucode":"93A3EAD9D50A5F","user_header":"https://static001.geekbang.org/account/avatar/00/14/e5/67/16322a5d.jpg","comment_is_top":false,"comment_ctime":1573995747,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14458897635","product_id":100028001,"comment_content":"感觉还可以把隔离级别改成RC。RR下锁比较严格，举两个例子：一个就是间隙锁的原因，就像老师的例子一样，如果一个事务在表t1 insert后没有commit，其他事务就不能对表t1进行insert，这样就可能会出现用户A的insert锁住了用户B的insert的情况，其实用户A和B是业务不相关的。而RC下没有间隙锁，不会有这种情况。 第二个就是RR加锁的范围更大，RR下会锁住所有扫描过的行，只有commit后才会全部释放，例如：select no from orders where status = 1 and create_at &gt; xx for update; 其中只有status有索引，那么mysql就要先扫描status索引再回表找满足create_at的行。如果是RR下，会锁住所有status=1的行，直到commit后释放。如果是RC下，当找到满足条件(status, craeted_at)的行后，会释放掉不满住条件但是status=1的行，不需要等到commit。这些细节都会造成RC和RR的性能差距很大。而一些需要重复读的需求可以通过代码来保证。  ","like_count":4},{"had_liked":false,"id":143183,"user_name":"月迷津渡","can_delete":false,"product_type":"c1","uid":1264111,"ip_address":"","ucode":"2B18B2FE3DAC3B","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/ef/02401473.jpg","comment_is_top":false,"comment_ctime":1571643609,"is_pvip":false,"replies":[{"id":"55868","content":"因为主键是唯一索引，所以不会使用next-key lock","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1572083148,"ip_address":"","comment_id":143183,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5866610905","product_id":100028001,"comment_content":"一个表它的主键是UUID生成的，如果说为了避免幻读而加了一个Next-key lock，那它会怎么锁的，感觉后插入的位置待定。。。还是全表锁？","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471411,"discussion_content":"因为主键是唯一索引，所以不会使用next-key lock","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572083148,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316574,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1634397942,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1634397942","product_id":100028001,"comment_content":"gap lock 的范围不是根据数据库中已有的记录来确定的吗？","like_count":0},{"had_liked":false,"id":311845,"user_name":"大明猩","can_delete":false,"product_type":"c1","uid":1494622,"ip_address":"","ucode":"61D330B42AE3C4","user_header":"https://static001.geekbang.org/account/avatar/00/16/ce/5e/b103d538.jpg","comment_is_top":false,"comment_ctime":1631502801,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1631502801","product_id":100028001,"comment_content":"这种事务A,事务B同时执行时利用的多线程吗，还是单纯用的SQL语句","like_count":0},{"had_liked":false,"id":311842,"user_name":"大明猩","can_delete":false,"product_type":"c1","uid":1494622,"ip_address":"","ucode":"61D330B42AE3C4","user_header":"https://static001.geekbang.org/account/avatar/00/16/ce/5e/b103d538.jpg","comment_is_top":false,"comment_ctime":1631502199,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1631502199","product_id":100028001,"comment_content":"这种事务A，事务B的先后顺序是怎么模拟的不会搞啊","like_count":0,"discussions":[{"author":{"id":2420294,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ee/46/7d65ae37.jpg","nickname":"木几丶","note":"","ucode":"FFDB958DA64F8C","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547518,"discussion_content":"开2个客户端，按时序敲各自的SQL语句","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642732074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310972,"user_name":"胖佳","can_delete":false,"product_type":"c1","uid":1058362,"ip_address":"","ucode":"CF367D54D9589D","user_header":"https://static001.geekbang.org/account/avatar/00/10/26/3a/5c1f4d91.jpg","comment_is_top":false,"comment_ctime":1631005065,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631005065","product_id":100028001,"comment_content":"老师，能介绍一下mysql集群使用的ndbcluster引擎与innoDB在加锁方面的区别吗？","like_count":0},{"had_liked":false,"id":305934,"user_name":"李亚方","can_delete":false,"product_type":"c1","uid":1000353,"ip_address":"","ucode":"5828A930327E28","user_header":"https://static001.geekbang.org/account/avatar/00/0f/43/a1/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1628235577,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628235577","product_id":100028001,"comment_content":"【作者回复：为了防止幻读，需要通过插入意向锁实现阻塞等待gap锁的释放。】RR隔离级别是允许出现幻读的呀？","like_count":0},{"had_liked":false,"id":286981,"user_name":"VIC","can_delete":false,"product_type":"c1","uid":1114064,"ip_address":"","ucode":"3B3E6D344488B2","user_header":"https://static001.geekbang.org/account/avatar/00/10/ff/d0/402be1e9.jpg","comment_is_top":false,"comment_ctime":1617713299,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617713299","product_id":100028001,"comment_content":"在一个方法里实现查询，插入。可以吗","like_count":0},{"had_liked":false,"id":280147,"user_name":"皇家救星","can_delete":false,"product_type":"c1","uid":1326106,"ip_address":"","ucode":"89F1274A3835FE","user_header":"https://static001.geekbang.org/account/avatar/00/14/3c/1a/1806ef25.jpg","comment_is_top":false,"comment_ctime":1614093772,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614093772","product_id":100028001,"comment_content":"请问老师，平时正式环境mysql修改事务隔离级别的多吗。用rc级别跟rr级别比，会有什么缺点（优点是不是只有减少死锁）","like_count":0},{"had_liked":false,"id":255547,"user_name":"刘宽","can_delete":false,"product_type":"c1","uid":1281573,"ip_address":"","ucode":"11B9BCD8532339","user_header":"https://static001.geekbang.org/account/avatar/00/13/8e/25/5ed88a40.jpg","comment_is_top":false,"comment_ctime":1603370370,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603370370","product_id":100028001,"comment_content":"你那个冲突的表格有错误，插入意向锁不影响间隙锁","like_count":0},{"had_liked":false,"id":249554,"user_name":"torres","can_delete":false,"product_type":"c1","uid":1108761,"ip_address":"","ucode":"34DABCFC7B74EA","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/19/76b0b98c.jpg","comment_is_top":false,"comment_ctime":1600691817,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600691817","product_id":100028001,"comment_content":"事物A 应该是先获取order_no 的非聚簇索引， 再获取主键索引吧？  而不是 order_status 非聚簇索引，此处是笔误吗，还是我的理解问题？","like_count":0},{"had_liked":false,"id":232604,"user_name":"黄平","can_delete":false,"product_type":"c1","uid":1142708,"ip_address":"","ucode":"2207224A09735C","user_header":"https://static001.geekbang.org/account/avatar/00/11/6f/b4/4aefe4c0.jpg","comment_is_top":false,"comment_ctime":1594046907,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594046907","product_id":100028001,"comment_content":"聚簇索引和辅助索引更新问题，是在可重复读的隔离级别下才有是吗？","like_count":0},{"had_liked":false,"id":224529,"user_name":"ty_young","can_delete":false,"product_type":"c1","uid":1284337,"ip_address":"","ucode":"EB1D5DB0AE7B33","user_header":"","comment_is_top":false,"comment_ctime":1591431542,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591431542","product_id":100028001,"comment_content":"老师您好，第二个使用非聚簇索引产生死锁的案例里面，有些混淆，锁应该是针对的数据库表的吧，为啥跟索引相关","like_count":0},{"had_liked":false,"id":219889,"user_name":"td901105","can_delete":false,"product_type":"c1","uid":1348830,"ip_address":"","ucode":"32D42A4F36FA02","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/SM4fwn9uFicXU8cQ1rNF2LQdKNbZI1FX1jmdwaE2MTrBawbugj4TQKjMKWG0sGbmqQickyARXZFS8NZtobvoWTHA/132","comment_is_top":false,"comment_ctime":1590114636,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590114636","product_id":100028001,"comment_content":"看到这，你可能会想，为什么 SELECT 要加 for update 排他锁，而不是使用共享锁呢？试想下，如果是两个订单号一样的请求同时进来，就有可能出现幻读。也就是说，一开始事务 A 中的查询没有该订单号，后来事务 B 新增了一个该订单号的记录，此时事务 A 再新增一条该订单号记录，就会创建重复的订单记录。面对这种情况，我们可以使用锁间隙算法来防止幻读。<br>老师，这个不太理解？insert操作是不用加锁吗？","like_count":0},{"had_liked":false,"id":206242,"user_name":"达达队长","can_delete":false,"product_type":"c1","uid":1117597,"ip_address":"","ucode":"1C3F2E4F6B7637","user_header":"https://static001.geekbang.org/account/avatar/00/11/0d/9d/58d09086.jpg","comment_is_top":false,"comment_ctime":1586828430,"is_pvip":false,"replies":[{"id":"77120","content":"是的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1586865481,"ip_address":"","comment_id":206242,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586828430","product_id":100028001,"comment_content":"老师这一句不懂：事务 A 和事务 B 都持有间隙 (4,+∞）的 gap 锁？<br>应该是：A是(4,+∞）B是(5,+∞）吧","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491726,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586865481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205222,"user_name":"HeGuang","can_delete":false,"product_type":"c1","uid":1256762,"ip_address":"","ucode":"2B938BCB4B82FA","user_header":"https://static001.geekbang.org/account/avatar/00/13/2d/3a/ffa02c6d.jpg","comment_is_top":false,"comment_ctime":1586573173,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1586573173","product_id":100028001,"comment_content":"ERROR 1109 (42S02): Unknown table &#39;INNODB_LOCKS&#39; in information_schema，<br>innodb_lock_waits ,<br>这两张表怎么都没有啊，mysql 版本8.0.15","like_count":0,"discussions":[{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542196,"discussion_content":"我也发现高版本好像没有这2个表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640679477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200381,"user_name":"郭奉孝","can_delete":false,"product_type":"c1","uid":1411489,"ip_address":"","ucode":"335993F5D61473","user_header":"https://static001.geekbang.org/account/avatar/00/15/89/a1/00d7330d.jpg","comment_is_top":false,"comment_ctime":1585578925,"is_pvip":false,"replies":[{"id":"75244","content":"减少主订单表的查询操作","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1585741518,"ip_address":"","comment_id":200381,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585578925","product_id":100028001,"comment_content":"老师，为什么订单表校验重复订单不在主表而要用这么一张冗余表","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490012,"discussion_content":"减少主订单表的查询操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585741518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185284,"user_name":"Geeker","can_delete":false,"product_type":"c1","uid":1896510,"ip_address":"","ucode":"937B190AE0EC6F","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f0/3e/f9f021bf.jpg","comment_is_top":false,"comment_ctime":1583552402,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583552402","product_id":100028001,"comment_content":"感谢！","like_count":0},{"had_liked":false,"id":165713,"user_name":"孫やさん","can_delete":false,"product_type":"c1","uid":1134895,"ip_address":"","ucode":"C60877C1C71685","user_header":"https://static001.geekbang.org/account/avatar/00/11/51/2f/7b04140c.jpg","comment_is_top":false,"comment_ctime":1577287068,"is_pvip":true,"replies":[{"id":"65936","content":"在更新status时，由于是根据条件order_no来更新状态的，所以获取的是index_order_status索引，index_order_status是一个联合索引，由于不是主键，所以是非聚簇索引。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1578487869,"ip_address":"","comment_id":165713,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1577287068","product_id":100028001,"comment_content":"老师，您最后的那个例子，更新status时要获取index_order_status非聚簇索引，这句话能稍微解释一下吗？谢谢了","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479264,"discussion_content":"在更新status时，由于是根据条件order_no来更新状态的，所以获取的是index_order_status索引，index_order_status是一个联合索引，由于不是主键，所以是非聚簇索引。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578487869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306603,"discussion_content":"因为status是索引字段，更新的时候需要调整该索引字段在index_order_status索引树下的位置","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600327104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066705,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/d1/a1ddf49f.jpg","nickname":"阿杜","note":"","ucode":"349D3572F5ABE7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128261,"discussion_content":"不是直接可以根据主键更新吗？为什么还要查order_no来更新呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578624347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1261959,"avatar":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","nickname":"Better me","note":"","ucode":"CADF08D357489A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1066705,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/d1/a1ddf49f.jpg","nickname":"阿杜","note":"","ucode":"349D3572F5ABE7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285561,"discussion_content":"老师列举的案例是这样写的，所以说需要将根据非聚簇索引更新改为聚簇索引更新","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592880731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":128261,"ip_address":""},"score":285561,"extra":""}]}]},{"had_liked":false,"id":155660,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":false,"comment_ctime":1574733615,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574733615","product_id":100028001,"comment_content":"oracle里面的自增列，一般是通过一个sequence来控制的，一直感觉不如mysql方便。根据今天的例子来看，虽然sequence会产生一些不连续的情况，但好像可以减少一些脏读和死锁的情况，反而感觉挺合理的。","like_count":0},{"had_liked":false,"id":140455,"user_name":"～","can_delete":false,"product_type":"c1","uid":1494270,"ip_address":"","ucode":"BF9A5925C978C4","user_header":"https://static001.geekbang.org/account/avatar/00/16/cc/fe/702cf7bf.jpg","comment_is_top":false,"comment_ctime":1570948996,"is_pvip":false,"replies":[{"id":"55151","content":"select col from t where t.col = &#39;xx&#39; for update不会导致索引失效的，使用排他锁是不是发生了死锁了呢？","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1571476861,"ip_address":"","comment_id":140455,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570948996","product_id":100028001,"comment_content":"老师， 我实践了一下， 发现select col from t where t.col = &#39;xx&#39; for update会导致覆盖索引失效,而使用使用共享锁就不会失效， 这是什么原理呢","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470397,"discussion_content":"select col from t where t.col = &amp;#39;xx&amp;#39; for update不会导致索引失效的，使用排他锁是不是发生了死锁了呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571476861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138325,"user_name":"lizhibo","can_delete":false,"product_type":"c1","uid":1636410,"ip_address":"","ucode":"FDF4FA12C699B3","user_header":"https://static001.geekbang.org/account/avatar/00/18/f8/3a/e0c14cb3.jpg","comment_is_top":false,"comment_ctime":1570164455,"is_pvip":false,"replies":[{"id":"53309","content":"互相锁等待，又无法释放彼此等待的锁，就是死锁状态了","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1570346467,"ip_address":"","comment_id":138325,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1570164455","product_id":100028001,"comment_content":"老师 ，最后那个 根据主键ID 和 订单编号更新状态的例子 我这边怎么都是 锁等待 而没有出现死锁的情况， 事物级别RR ","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469485,"discussion_content":"互相锁等待，又无法释放彼此等待的锁，就是死锁状态了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570346467,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1622022,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJia6zEsh2u119zJicmq7wApvnricZEKiawaZicice1cOzujWdFicFwPtavlHiaVpCNgCpxBtdl7ynd3y0wkQ/132","nickname":"james_xu","note":"","ucode":"12E50291F5BA89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380911,"discussion_content":"老师给的例子只有再并发的情况下，两个会话同时执行了这两个SQL，然后会话1获得了主键索引上的锁正准备获取辅助索引上的锁，会话2获得了辅助索引上的锁正准备获取主键索引上的锁时才会发生死锁。你自己操作时，是先执行会话1，此时会话1已经获取了主键索引和辅助索引上的锁了，所以再执行会话2是锁等待。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624788907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1636410,"avatar":"https://static001.geekbang.org/account/avatar/00/18/f8/3a/e0c14cb3.jpg","nickname":"lizhibo","note":"","ucode":"FDF4FA12C699B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":25030,"discussion_content":"不是啊 第一个先执行不提交事务，第二个在执行出现锁等待","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570373858,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1072896,"avatar":"","nickname":"700","note":"","ucode":"E4BD0CBADAF951","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1636410,"avatar":"https://static001.geekbang.org/account/avatar/00/18/f8/3a/e0c14cb3.jpg","nickname":"lizhibo","note":"","ucode":"FDF4FA12C699B3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346217,"discussion_content":"你是对的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611888424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":25030,"ip_address":""},"score":346217,"extra":""}]}]},{"had_liked":false,"id":133906,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1568695563,"is_pvip":false,"replies":[{"id":"51387","content":"是的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568718317,"ip_address":"","comment_id":133906,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1568695563","product_id":100028001,"comment_content":"感悟：<br>1、默认将mysql隔离级别调成RC<br>2、使用主键更新<br><br>疑问：RR级别下，如果使用唯一索引更新，是record lock么？ ","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467552,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568718317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133602,"user_name":"man1s","can_delete":false,"product_type":"c1","uid":1466953,"ip_address":"","ucode":"FFDB6B52F65A1B","user_header":"https://static001.geekbang.org/account/avatar/00/16/62/49/6332c99b.jpg","comment_is_top":false,"comment_ctime":1568619367,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568619367","product_id":100028001,"comment_content":"死锁检测，消耗cpu","like_count":0},{"had_liked":false,"id":133307,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1568510873,"is_pvip":false,"replies":[{"id":"51095","content":"一样是不兼容的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568530507,"ip_address":"","comment_id":133307,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568510873","product_id":100028001,"comment_content":"课后思考及问题<br>1：有个疑问，文中说“插入意向锁其实也是一种 gap 锁，它与 gap lock 是冲突的，所以当其它事务持有该间隙的 gap lock 时，需要等待其它事务释放 gap lock 之后，才能获取到插入意向锁。”<br>在锁的兼容矩阵图中，先获取到Next-key lock再请求获取Insert Intention lock时是冲突的，反过来就是兼容的?","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467341,"discussion_content":"一样是不兼容的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568530507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132330,"user_name":"💢 星星💢","can_delete":false,"product_type":"c1","uid":1254392,"ip_address":"","ucode":"A402B765222C35","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/f8/24fcccea.jpg","comment_is_top":false,"comment_ctime":1568086145,"is_pvip":false,"replies":[{"id":"50650","content":"索引和数据是两个概念，我们说过，聚合索引的叶子节点会存放整个数据，而辅助索引的叶子节点存放的是主键id","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568125376,"ip_address":"","comment_id":132330,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1568086145","product_id":100028001,"comment_content":"老师你最后放的那张图，为啥主健索引还需要获取非主键索引的锁啊，主键索引不是已经持有这一整行数据了么？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466881,"discussion_content":"索引和数据是两个概念，我们说过，聚合索引的叶子节点会存放整个数据，而辅助索引的叶子节点存放的是主键id","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568125376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542195,"discussion_content":"我也没太理解 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640679247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066705,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/d1/a1ddf49f.jpg","nickname":"阿杜","note":"","ucode":"349D3572F5ABE7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128264,"discussion_content":"没太理解解释","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578624537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129796,"user_name":"十大杰出青年","can_delete":false,"product_type":"c1","uid":1559178,"ip_address":"","ucode":"BAB4AA12604CF6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/a5U0nqaicLy5ZJkESxBd5lMicNQcTTDK8vURyyWiabHxic7vS1VVk7HWTZg6ltyWJ3n9jb3Gq554ibfjsf7bv1v1Sdw/132","comment_is_top":false,"comment_ctime":1567255810,"is_pvip":false,"replies":[{"id":"48419","content":"由于RC隔离级别只解决了脏读，所以是记录锁","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567297730,"ip_address":"","comment_id":129796,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567255810","product_id":100028001,"comment_content":"老师，RC隔离级别下的select、update、delete基于聚簇索引和辅助索引分别获取什么lock？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465654,"discussion_content":"由于RC隔离级别只解决了脏读，所以是记录锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567297730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125229,"user_name":"新世界","can_delete":false,"product_type":"c1","uid":1079495,"ip_address":"","ucode":"4473DC1505F158","user_header":"https://static001.geekbang.org/account/avatar/00/10/78/c7/083a3a0b.jpg","comment_is_top":false,"comment_ctime":1566124505,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1566124505","product_id":100028001,"comment_content":"for update和update都是悲观锁有什么区别？","like_count":0,"discussions":[{"author":{"id":2060756,"avatar":"","nickname":"在下蟑螂王","note":"","ucode":"E66A65A327095A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299210,"discussion_content":"前者是主动上排它锁，作查询。后者是上排它锁，作更新。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597593423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1877904,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/a7/90/9a0da433.jpg","nickname":"小哇","note":"","ucode":"1C2C1FE3FCB9CE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287911,"discussion_content":"应该是select语句有for update和没有的区别吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593586715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125218,"user_name":"K","can_delete":false,"product_type":"c1","uid":1118374,"ip_address":"","ucode":"69831D1EFC083C","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/a6/4d2c933e.jpg","comment_is_top":false,"comment_ctime":1566121286,"is_pvip":false,"replies":[{"id":"46219","content":"如果我们之前使用辅助索引来更新数据库，就需要修改为使用聚簇索引来更新数据库。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1566264591,"ip_address":"","comment_id":125218,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566121286","product_id":100028001,"comment_content":"老师您好，麻烦问一下：“如果使用辅助索引来更新数据库，就需要使用聚簇索引来更新数据库...”这句话是什么意思啊？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463482,"discussion_content":"如果我们之前使用辅助索引来更新数据库，就需要修改为使用聚簇索引来更新数据库。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566264591,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124884,"user_name":"星星滴蓝天","can_delete":false,"product_type":"c1","uid":1465990,"ip_address":"","ucode":"2F2F56F93AD828","user_header":"https://static001.geekbang.org/account/avatar/00/16/5e/86/40877404.jpg","comment_is_top":false,"comment_ctime":1566008114,"is_pvip":false,"replies":[{"id":"46210","content":"过来人👍🏻","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1566264041,"ip_address":"","comment_id":124884,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566008114","product_id":100028001,"comment_content":"我们有一个很悲催的经历，更新的时候没有使用主键更新，之前还好好的，后来（服务迁移、降低配置......处理流程变长）很悲剧的死锁了。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463346,"discussion_content":"过来人👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566264041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124580,"user_name":"阿琨","can_delete":false,"product_type":"c1","uid":1131735,"ip_address":"","ucode":"011711A55C8ED0","user_header":"https://static001.geekbang.org/account/avatar/00/11/44/d7/915da418.jpg","comment_is_top":false,"comment_ctime":1565923380,"is_pvip":true,"replies":[{"id":"50399","content":"可以","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567948317,"ip_address":"","comment_id":124580,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565923380","product_id":100028001,"comment_content":"老师，使用ON DUPLICATE KEY UPDATE这个是不是也可以解决这种呢","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463234,"discussion_content":"可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567948317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124263,"user_name":"奇奇","can_delete":false,"product_type":"c1","uid":1399097,"ip_address":"","ucode":"BC86B0CB55E35A","user_header":"","comment_is_top":false,"comment_ctime":1565847563,"is_pvip":true,"replies":[{"id":"45729","content":"是的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1565919052,"ip_address":"","comment_id":124263,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565847563","product_id":100028001,"comment_content":"mysql本身自带死锁检测<br>超时时间在业务上是很难接受的","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463088,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565919052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123471,"user_name":"Fever","can_delete":false,"product_type":"c1","uid":1263997,"ip_address":"","ucode":"2595F13BC3ECAB","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/7d/7b9fd831.jpg","comment_is_top":false,"comment_ctime":1565683491,"is_pvip":false,"replies":[{"id":"45303","content":"是的，跟竖向是一样的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1565692301,"ip_address":"","comment_id":123471,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565683491","product_id":100028001,"comment_content":"兼容矩阵图里的Gap锁和横向的Insert Intention不兼容吧。。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462689,"discussion_content":"是的，跟竖向是一样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565692301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123415,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1565671104,"is_pvip":true,"replies":[{"id":"45563","content":"对的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1565833831,"ip_address":"","comment_id":123415,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565671104","product_id":100028001,"comment_content":"for update基本不被允许使用，除非经过review以及测试不会有死锁风险<br>对于锁机制，要很好的了解索引数据结构才能明白锁导致的奇怪现象是怎么出现的<br>","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462663,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565833831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}