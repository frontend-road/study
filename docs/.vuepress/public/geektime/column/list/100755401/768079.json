{"id":768079,"title":"19｜测试策略（二）：功能上下文划分","content":"<p>你好，我是徐昊，今天我们来继续学习AI时代的软件工程。</p><p>上节课，我们讲解了如何通过测试四象限（Agile Testing Quadrants）构造有效的测试策略（Test Strategy），以及为何构造支持团队的测试（Q1和Q2象限）是测试策略中重要的一环。而在构造Q1和Q2象限的时候，重点在于建立Q1象限和Q2象限的直接关联。这时候，功能上下文就起到了非常重要的作用。</p><p>那么今天我们就来看一看如何有效地划分功能上下文。</p><h2>利用架构划分功能上下文</h2><p><strong>划分功能上下文最简单的方法就是软件架构</strong>。软件架构是软件系统的基本结构和组织方式，主要包括系统由哪些组件构成，以及各个组件之间的关系。在软件架构中，组件是指软件系统中具有明确功能定义和责任的模块。</p><p>因而，通过组件负责的功能单元就可以很容易地获得功能上下文。让我们看一个非常简单的例子：</p><p><img src=\"https://static001.geekbang.org/resource/image/08/01/085ddcb769ec544b7f6c0d833a5de901.jpg?wh=1417x635\" alt=\"\"></p><p>这是一个非常常见的后端分层架构模式，核心的业务逻辑处在业务逻辑层中，业务逻辑层通过持久化接口访问数据，所有的逻辑通过HTTP接口暴露对外访问的API。现在，我们有一个业务场景需要使用这个架构模式实现。业务场景是“作为一个用户，我希望获取所有的在售商品，从而我可以选择我想要购买的商品”。</p><!-- [[[read_end]]] --><p>那么我们就可以按照架构模式的指引，为这个业务场景引入对应的组件，操作如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/98/7d/98322c268d4b18805d0d559a492d647d.jpg?wh=1300x832\" alt=\"\"></p><p>在我们引入的组件中，按照架构模式，它们作用分别为：</p><ul>\n<li>ProductsAPI：通过HTTP协议将ProductService暴露为API；</li>\n<li>ProductService：封装围绕产品目录相关的业务逻辑，通过ProductDAO访问持久化的数据；</li>\n<li>ProductDAO：封装对于持久化数据访问的相关逻辑。</li>\n</ul><p>按照我们寻找到的功能上下文，就可以很容易地构造相互关联的Q1与Q2测试：</p><p><img src=\"https://static001.geekbang.org/resource/image/75/8a/75f452cc3873f1ccd0afda90d380868a.jpg?wh=1875x1004\" alt=\"\"></p><p>这样划分之后，我们可以明显看到，对于“获取产品目录”的功能测试（Q2测试），测试了多个架构中的组件（HTTP interface，application logic以及persistent）。而与之相对的，另外三个测试则仅仅是测试了对应的组件。同时由于我们按照架构分解了不同的功能上下文，那么当属于Q2的功能测试失败时，至少会有一个处于Q1的测试失败。<strong>失败的测试就指明了发生问题的组件。</strong></p><p><strong>需要注意的是，到底是Q1还是Q2的测试，并不是由使用的测试方式决定的</strong>。比如，前面这个例子中的ProductDAO测试。通常对于DAO测试，我们需要使用内存数据库（in-memory database）或是连接专门用于测试的数据库实例。</p><p><strong>从测试技术的角度来看，这种使用数据库的测试通常会被归类为集成测试，而Q1测试通常是单元测试或者组件测试，那么这类测试往往被划归为Q2测试。</strong></p><p>但是，按照我们上节课所讲的，Q1测试与Q2测试的划分，是因为其受众与目的不同。就算采用了内存数据库，或是专门用于测试的数据库实例，它的受众仍然是<strong>技术导向</strong>。因而，只能是Q1象限的测试。</p><h2>在测试中引入测试替身</h2><p>测试策略中另一个重要的问题，就是对于不同的测试使用何种测试替身（Test Double）。如果没有测试替身，那么我们将无法独立测试架构模式中指定的组件。比如还是上面的例子，ProductsAPI可能是这样实现的（使用Java Jersey作为RESTful API的框架）：</p><pre><code class=\"language-plain\">@Path(\"/products\")\npublic class ProductsAPI {\n    private ProductService productService = new ProductServiceImpl();\n    \n    @GET\n    @Produces(MediaType.APPLICATION_JSON)\n    public List&lt;Product&gt; getAllProducts() {\n        return productService.getAllProducts();\n    }\n}\n</code></pre><p>其中ProductServiceImpl是生产环境中使用的代码，也就是要使用ProductsDAO去访问持久化数据的实现方式。当我们要测试这个API层的组件时，可能会用这样的方式：</p><pre><code class=\"language-plain\">public class ProductsAPITest extends JerseyTest {\n    @Override\n    protected Application configure() {\n        return new ResourceConfig(ProductsAPI.class);\n    }\n    \n    @Test\n    public void testGetAllProducts() {\n        Response response = target(\"/products\").request().get();\n        // 验证响应状态码是否为200\n        assertEquals(Response.Status.OK.getStatusCode(), response.getStatus());\n        // 获取响应中的产品列表\n        List&lt;Product&gt; products = response.readEntity(new GenericType&lt;List&lt;Product&gt;&gt;() {});\n        // 验证返回的产品列表是否包含了预期的产品\n        assertEquals(3, products.size()); // 假设我们期望有3个产品s\n    }\n}\n</code></pre><p>这里的问题是，如果按照现在的代码去写，那么这个测试就会是一个<strong>功能测试</strong>。因为无论我们怎么构造这个测试，它都会使用ProductServiceImpl去执行测试。而ProductServiceImpl则又会使用ProductsDAO。这个测试就变成了使用所有架构组件的测试。</p><p>所以这里我们必须引入测试替身，才能解决这个问题。我们可以做一个简单的修改，首先，<strong>改为依赖注入（Dependency Injection）</strong>：</p><pre><code class=\"language-plain\">@Path(\"/products\")\npublic class ProductsAPI {\n    @Inject\n    private ProductService productService;\n    @GET\n    @Produces(MediaType.APPLICATION_JSON)\n    public List&lt;Product&gt; getAllProducts() {\n        return productService.getAllProducts();\n    }\n}\n</code></pre><p>然后在测试中注入测试替身，而不是真实的实现：</p><pre><code class=\"language-plain\">public class ProductResourceTest extends JerseyTest {\n    private ProductService productService;\n    \n    @Override\n    protected Application configure() {\n        // 创建 ProductService 的替身\n        productService = new ProductServiceDouble();\n        \n        // 创建 ResourceConfig 实例并注册资源类及依赖\n        return new ResourceConfig()\n                .register(ProductsAPI.class)\n                .register(new AbstractBinder() {\n                    @Override\n                    protected void configure() {\n                        bind(productService).to(ProductService.class);\n                    }\n                });\n    }\n\n    @Test\n    public void testGetAllProducts() {\n        // 发送GET请求到\"/products\"端点\n        Response response = target(\"/products\").request().get();\n        // 验证响应状态码是否为200\n        assertEquals(Response.Status.OK.getStatusCode(), response.getStatus());\n        // 获取响应中的产品列表\n        List&lt;Product&gt; products = response.readEntity(new GenericType&lt;List&lt;Product&gt;&gt;() {});\n        // 验证返回的产品列表是否包含了预期的产品\n        assertEquals(3, products.size()); // 假设我们期望有3个产品\n    }\n}\n</code></pre><p>这样，我们在测试中将使用ProductServiceDouble而不是ProductServiceImpl去进行测试。这个测试只会覆盖架构模式里，HTTP interface层中ProdcutsAPI这个组件。我们也就可以针对不同的功能上下文去进行独立的测试了。</p><p><strong>如果不能在测试中引入测试替身，那么我们几乎无法在Q2测试与Q1测试之间直接建立关联，甚至都无法构造有效的Q1测试。因而，测试替身是测试策略能够落地的关键。</strong></p><p>在确认能够引入测试替身之后，针对不同组件选择哪种测试替身，就是另一个重要的课题。测试替身有多种不同的形态，目前我们广泛使用的测试替身有这么几种：</p><ul>\n<li>哑对象（Dummy Object）：哑对象不会被实际使用，通常它们只是用来填充参数列表。它们可以是简单的占位符，只是为了满足方法签名的需求；</li>\n<li>假实现（Fake Object）：假实现是一种实际可以使用的特定实现，但跟真实实现相比会简化很多。一般不会用于生产环境。比如，内存数据库就是一个很好的例子，对于绝大多数场景，它提供的功能已经足够了，但是不会被用于生产环境；</li>\n<li>存根对象（Stub）：为测试过程中调用的方法提供预先准备好的答案，但通常不会对测试调用之外的方法有任何响应。与假实现不同，存根只满足于特定的场景，而无法看作是一个可用的实现；</li>\n<li>间谍对象（Spy）：间谍对象是一种特殊的存根对象。除了响应某些具体方法之外，它还会根据测试的调用，记录一些信息。比如，使用间谍对象进行测试，它可能会记录某个方法一共被调用了多少次等等；</li>\n<li>模拟对象（Mock）：模拟对象对于将要进行的调用存在明确的预期。它会根据预先编排好的答案响应所有的调用。如果接收的调用不满足预期，它们会抛出异常。通常使用模拟对象时，会在最终的验证过程中进行检查，以确保它们接收到符合预期的所有调用。</li>\n</ul><p>比如在前面的例子里，ProductDAO的测试就使用了假实现（Fake）。ProductService和ProdcutsAPI的测试则会使用存根对象（Stub）。</p><p>为功能上下文选择合适的测试替身策略，是测试策略中非常容易被忽略的一环。而选择恰当的替身策略，则能保证测试的有效性，并控制测试成本。那么对应到我们的例子中，我们可以这样来总结：<br>\n<img src=\"https://static001.geekbang.org/resource/image/ea/30/ea247894f27de0a978a45c8345b16930.jpg?wh=1920x990\" alt=\"\"></p><p>需要注意的是，除了五种测试替身之外，我们还有一个选择，就是使用真实的对象。当我们使用真实对象的时候，我们实际上在合并不同的功能上下文。比如，对于之前的例子，我们可以选择让ProductsAPI直接使用ProductService，但并不使用真正的DAO对象。那么，测试可能就是这个样子：</p><pre><code class=\"language-plain\">public class ProductResourceTest extends JerseyTest {\n    private ProductService productService;\n    \n    @Override\n    protected Application configure() {\n        // 创建 ProductService 的替身\n        productService = new ProductServiceImpl(new ProductDAOStub());\n        \n        // 创建 ResourceConfig 实例并注册资源类及依赖\n        return new ResourceConfig()\n                .register(ProductsAPI.class)\n                .register(new AbstractBinder() {\n                    @Override\n                    protected void configure() {\n                        bind(productService).to(ProductService.class);\n                    }\n                });\n    }\n\n    @Test\n    public void testGetAllProducts() {\n        // 发送GET请求到\"/products\"端点\n        Response response = target(\"/products\").request().get();\n        // 验证响应状态码是否为200\n        assertEquals(Response.Status.OK.getStatusCode(), response.getStatus());\n        // 获取响应中的产品列表\n        List&lt;Product&gt; products = response.readEntity(new GenericType&lt;List&lt;Product&gt;&gt;() {});\n        // 验证返回的产品列表是否包含了预期的产品\n        assertEquals(3, products.size()); // 假设我们期望有3个产品\n    }\n}\n\n</code></pre><p>那么实际上，我们表达的测试策略是这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/67/e9/6715d000fyyc7b98c09a6af10cff87e9.jpg?wh=1920x986\" alt=\"\"></p><p><strong>也就是说，虽然从架构模式上看，系统中存在两个不同的功能上下文，但是作为测试策略，我们选择将这两个功能上下文看作一个整体进行测试。</strong></p><p>比如在上面的例子中，我们这个做法是非常有道理的。因为HTTP interface这一层，只有很少的逻辑，绝大部分逻辑都是将application logic层中的返回值进行格式转换。因而我们可以将这两个功能上下文合并，以减少低价值的测试。</p><p>当然，我们也可以选择把Application Logic层与Persistent层合并，虽然在目前这个例子里，这么做并没有带来什么好处。</p><h2>小结</h2><p>这节课我们主要讲解了利用架构划分功能上下文，以及为不同的功能上下文选择对应的测试替身。</p><p>我们刻意回避了存根与模拟对象这一老生常谈的话题，感兴趣的同学，可以参考我TDD专栏中，关于<a href=\"https://time.geekbang.org/column/article/496698\">行为验证</a>与<a href=\"https://time.geekbang.org/column/article/496697\">状态验证</a>的章节，或是Martin Folwer在07年写下的经典文章 <a href=\"https://martinfowler.com/articles/mocksArentStubs.html#ClassicalAndMockistTesting\">Mocks Ain’t Stubs</a>.</p><p>当我们获得了测试策略之后，我们就能准确地要求大语言模型（Large Language Model）按照某个特定架构风格生成代码了。这将是我们下节课的内容。</p><h2>思考题</h2><p>除了架构之外，还有什么划分功能上下文的办法？</p><p>欢迎在留言区分享你的想法，我会让编辑置顶一些优质回答供大家学习讨论。</p>","neighbors":{"left":{"article_title":"18｜测试策略（一）：如何构造有效的测试策略？","id":767358},"right":{"article_title":"20｜使用 LLM 按照测试策略生成代码","id":768399}},"comments":[{"had_liked":false,"id":390674,"user_name":"hakunamatata","can_delete":false,"product_type":"c1","uid":3864937,"ip_address":"四川","ucode":"AF596E068442AA","user_header":"https://static001.geekbang.org/account/avatar/00/3a/f9/69/106f4ff9.jpg","comment_is_top":false,"comment_ctime":1715930814,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100755401,"comment_content":"在买点咖啡的场景的中，可以按照消费者，咖啡馆服务员根据角色来划分上下文。","like_count":1},{"had_liked":false,"id":390441,"user_name":"Gojustforfun","can_delete":false,"product_type":"c1","uid":1187021,"ip_address":"北京","ucode":"7513A40F27344F","user_header":"https://static001.geekbang.org/account/avatar/00/12/1c/cd/8d552516.jpg","comment_is_top":false,"comment_ctime":1715345072,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100755401,"comment_content":"最后代码中注释有问题 ——&#47;&#47; 创建 ProductService 的替身\n\n应该是创建ProductDAO的替身，创建ProductService的真是对象","like_count":0},{"had_liked":false,"id":390118,"user_name":"咖啡","can_delete":false,"product_type":"c1","uid":1152339,"ip_address":"广东","ucode":"FD6BEF1934A277","user_header":"https://static001.geekbang.org/account/avatar/00/11/95/53/70a70139.jpg","comment_is_top":false,"comment_ctime":1714402559,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100755401,"comment_content":"在DDD架构下通过参与者的角色或者领域&#47;子域划分功能上下文感觉也行","like_count":0},{"had_liked":false,"id":389829,"user_name":"术子米德","can_delete":false,"product_type":"c1","uid":1898023,"ip_address":"浙江","ucode":"382EA7E2AF0B56","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f6/27/c27599ae.jpg","comment_is_top":false,"comment_ctime":1713566134,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100755401,"comment_content":"🤔☕️🤔☕️🤔\n【Q】除了架构之外，还有什么划分功能上下文的办法？\n【A】功能，它是钉子，它要技术的锤子，才能有用。可是，钉子死在田里，锤子窝在家里，两不相见，没用。\n功能，它是穿线引针，技术，它是面料、它是里子、它是边角饰件。一件好衣服，需要好的料子、加上好引针、再加好穿线。穿过的每个点，都会发生事件（Event），连续的事件线串起来的技术，做成我们期待的系统。\n因此，所谓的事件风暴法，我喜欢叫做穿针引线法，也是划分功能上下文的好法子。\n— by 术子米德@2024年4月20日","like_count":0},{"had_liked":false,"id":389796,"user_name":"术子米德","can_delete":false,"product_type":"c1","uid":1898023,"ip_address":"浙江","ucode":"382EA7E2AF0B56","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f6/27/c27599ae.jpg","comment_is_top":false,"comment_ctime":1713481137,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100755401,"comment_content":"🤔☕️🤔☕️🤔\n【R】划分功能上下文 简单法 软件架构。\nQ1的可行需要依赖注入（Dependency Inject）和测试替身（Test Double）的加持。\n哑（Dummy）&#47;有但不用，假（Fake）&#47;用随意值，存根（Stub）&#47;用特定值，间谍（Spy）&#47;记点东西，模拟（Mock）&#47;交互验证。\n【.I.】单元测试，要Mock，这个太麻烦，这个引入很多工作量，这个没必要搞这么复杂，这个不靠谱，这个…，这么稀奇古怪的理由的潜台词，有两个：1）很明显，我根本不想单元测试；2）很隐晦，我根本没明白问题点在哪里。\n我工作的单位是模块，一个有边界的模块，一个定义清楚接口和操作、其对象有状态切换的模块，那么我交付的模块，就是这边界定义清晰的模块，且，我能验证交付时模块具备的功能。\n也就是说，在我出手交付前，我要对我的模块做验证，它是我的工作单元，于是我把这种模块级的验证，叫做单元测试。\n【Q】单元测试，要进行哪些方面，或者说哪些维度的设计，是否有推荐的文章或书籍？\n— by 术子米德@2024年4月19日","like_count":0}]}