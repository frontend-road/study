{"id":469114,"title":"14 | 禁止空指针，该怎么避免崩溃的空指针？","content":"<p>你好，我是范学雷。今天，我们讨论Java的空指针。</p><p>我们都知道空指针，它的发明者开玩笑似的，称它是一个价值10亿美元的错误；同时呢，他还称C语言的get方法是一个价值100亿美元的错误。空指针真的错得这么厉害吗？get方法又有什么问题？我们能够在Java语言里改进或者消除空指针吗？</p><p>我们从阅读案例开始，来看一看该怎么理解这些问题，以及怎么降低这些问题的影响。</p><h2>阅读案例</h2><p>通常地，一个人的姓名包括两个部分，姓（Last Name）和名（First Name）。在有些文化里，也会使用中间名（Middle Name）。所以，我们通常可以使用姓、名、中间名这三个要素来标识一个人的姓名。用代码的形式表示出来，就是下面的代码这样。</p><pre><code class=\"language-java\">public record FullName(String firstName,\n        String middleName, String lastName) {\n    // blank\n}\n</code></pre><p>中间名并不是必需的，因为有的人使用中间名，有的人不使用。现在我们假设，需要判断一个人的中间名是不是黛安（Diane）。这个判断的逻辑，可能就像下面的代码这样。</p><pre><code class=\"language-java\">private static boolean hasMiddleName(\n        FullName fullName, String middleName) {\n    return fullName.middleName().equals(middleName);\n}\n</code></pre><!-- [[[read_end]]] --><p>这个判断的逻辑是没有问题的。但是它的代码实现，就存在没有校验空指针的错误。如果一个人不使用中间名，那么FullName.middleName这个方法的返回值就是一个空指针。 如果一个对象是空指针，那么调用它的任何方法，都会抛出空指针异常（NullPointerException）。</p><p>我们可以试着使用JDK 11的JShell，看一看空指针异常的异常信息是什么样子的。</p><pre><code class=\"language-java\">$ jshell -v\n|&nbsp; Welcome to JShell -- Version 11.0.13\n|&nbsp; For an introduction type: /help intro\n\njshell&gt; String a = null;\na ==&gt; null\n|&nbsp; created variable a : String\n\njshell&gt; a.equals(\"b\");\n|&nbsp; Exception java.lang.NullPointerException\n|&nbsp; &nbsp; &nbsp; &nbsp; at (#2:1)\n</code></pre><p>然后，我们再试试看JDK 17里，空指针异常信息是什么样的。</p><pre><code class=\"language-java\">$ jshell -v\n|&nbsp; Welcome to JShell -- Version 17\n|&nbsp; For an introduction type: /help intro\n\njshell&gt; String a = null;\na ==&gt; null\n|&nbsp; created variable a : String\n\njshell&gt; a.equals(\"b\");\n|&nbsp; Exception java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\" because \"REPL.$JShell$11.a\" is null\n|&nbsp; &nbsp; &nbsp; &nbsp; at (#2:1)\n</code></pre><p>对比一下，我们可以看到，JDK 17的异常信息里，包含了调用者（REPL.<span dollar=\"\">$</span>JShell<span dollar=\"\">$</span>11.a）和被调用者（String.equals(Object)）的信息；而JDK 11里，调用者的信息需要从调用堆栈里寻找，而且没有被调用者的信息。</p><p>这是空指针异常的一个小的改进。它简化了问题排查的流程，提高了问题排查的效率。</p><p>好的，我们再回到主题，看一看空指针异常到底有什么危害。按照我们前面讨论过的中间名的逻辑，有的人不使用中间名。那么，如果一个对象的中间名是空值，也就意味着他没有中间名。可是，在上面的实现代码里，如果中间名是空值，hasMiddleName抛出了空指针异常，而不是通过返回值来表示这个对象没有中间名。</p><p>这当然是一个错误。我们<strong>需要检查返回值有没有可能是空指针，然后才能继续使用返回值。</strong>这是一个C语言或者Java语言软件工程师需要掌握的基本常识。当然，这也是一个我们编码的时候，需要遵守的纪律。</p><p>检查返回值有没有可能是空指针需要额外的代码，而且不符合我们的思维习惯。下面的代码，我添加了空指针的检查，这就让它看起来就有点臃肿。这就是精准控制的代价。</p><pre><code class=\"language-java\">private static boolean hasMiddleNameImplA(\n        FullName fullName, String middleName) {\n    if (fullName.middleName() != null) {\n        return fullName.middleName().equals(middleName);\n    }\n\n    return middleName == null;\n}\n</code></pre><p><strong>空指针的问题，其实是我们人类行为方式的一个反映。</strong>无论是纪律还是常识，如果没有配以强制性的手段，都没有办法获得100%的执行。如果不能100%地执行，一个危害就会从一个小小的局部，蔓延到一个庞大的系统。</p><p>今天的应用程序，我们几乎可以肯定地说，都是由很多小的部件组合起来的。其中，99%以上的部件，我们都不了解，甚至都不知道它们的存在。任何一个小的部件出了问题，都会蔓延开来，酝酿出一个更大的问题。</p><p>在C语言和Java语言里，存在着大量的空指针。不管我们怎么努力，也不管我们经验多么丰富，总是会时不时地就忘了检查空指针。而忘了检查这样的小错误，很可能就蔓延成严重的事故。所以，空指针发明者称它是一个价值10亿美元的错误。</p><p>那有什么办法能够降低空指针的负面影响呢？</p><h2>避免空指针</h2><p>降低空指针的负面影响的最重要的办法，就是不要产生空指针。没有空指针的代码，代码更简洁，风险也更小。</p><p>比如说，我们可以使用空字符串来替代字符串的空指针。如果用这种思路，我们就可以把阅读案例里FullName档案类，修改成不使用空指针的版本了。</p><pre><code class=\"language-java\">public record FullName(String firstName,\n        String middleName, String lastName) {\n    public FullName(String firstName,\n            String middleName, String lastName) {\n        this.firstName = firstName == null ? \"\" : firstName;\n        this.middleName = middleName == null ? \"\" : middleName;\n        this.lastName = lastName == null ? \"\" : lastName;\n    }\n}\n</code></pre><p>这样，我们就不用检查空指针了；因此，也就不用担心空指针带来的问题了。所以，代码的使用也就变得简洁了起来。</p><pre><code class=\"language-java\">private static boolean hasMiddleName(\n        FullName fullName, String middleName) {\n    return fullName.middleName().equals(middleName);\n}\n</code></pre><p>在很多场景下，我们都可以使用空值来替代空指针，比如，空的字符串、空的集合。在API设计的时候，如果碰到了使用空指针的规范或者代码，我们要停下来想一想，有没有替代空指针的办法？如果能够避免空指针，我们的代码会更健壮，更容易维护。</p><h2>强制性检查</h2><p>不过，不是在所有的情况下我们都能够避免空指针的。如果空指针不能避免，降低空指针的负面影响的另外一个办法，就是在使用空指针的时候，执行强制性的检查。所谓强制性的检查，对于编程语言来说，指的是我们通常能够依赖的是编译器的能力，以及新的接口设计思路。</p><h2>不尽人意的Optional</h2><p>在JDK 8正式发布，而后在JDK 9和11持续改进的Optional工具类是JDK试图降低空指针风险的一个尝试。</p><p>设计Optional的目的，是希望开发者能够先调用它的Optional.isPresent方法，然后再调用Optional.get方法获得目标对象。 按照设计者的预期，这个Optional类的使用应该像下面的代码这样。</p><pre><code class=\"language-java\">private static boolean hasMiddleName(\n        FullName fullName, String middleName) {\n    if (fullName.middleName().isPresent()) {\n        return fullName.middleName().get().equals(middleName);\n    }\n\n    return middleName == null;\n}\n</code></pre><p>当然，我们还需要修改FullName的API，就像下面的代码这样。</p><pre><code class=\"language-java\">public final class FullName {\n    // snipped\n    public Optional&lt;String&gt; middleName() {\n        return Optional.ofNullable(middleName);\n    }\n    // snipped\n}\n</code></pre><p>遗憾的是，我们也可以不按照预期的方式使用它，比如下面的代码，我们就没有调用Optional.isPresent方法，而是直接使用了Optional.get方法。这不在设计者的预期之内，但是这是合法的代码。</p><pre><code class=\"language-java\">private static boolean hasMiddleName(FullName fullName, String middleName) {\n    return fullName.middleName().get().equals(middleName);\n}\n</code></pre><p>如果Optional指代的对象不存在，或者是个空指针，Optional.get方法就会抛出NoSuchElementException异常。和空指针异常一样，这个异常也是运行时异常。虽然这个异常的名字不再叫做空指针异常，但它实质上依然是空指针异常。当然，这个异常也具有和空指针异常相同的问题。</p><p>如果你对比一下使用空指针的代码和使用Optional类的代码，就会发现这两个类型的代码，不论是正确的使用方法还是错误的使用方法，它们在形式上是相似的。Optional带来了不必要的复杂性，然而它并没有简化开发者的工作，也没有解决掉空指针的问题。</p><p>被寄予厚望的Optional的设计，不能尽如人意。</p><h2>新特性带来的新希望</h2><p>那么，对于空指针的检查，我们能不能借助编译器，让它变得更强硬一点呢？下面的例子，就是我们使用新特性来解决空指针问题的一个新的探索。</p><p>我们希望返回值的检查是强制性的。如果不检查，就没有办法得到返回值指代的真实对象。实现的思路，就是使用封闭类和模式匹配。</p><p>首先呢，我们定义一个指代返回值的封闭类Returned。为什么使用封闭类呢，因为封闭类的子类可查可数。可查可数，也就意味着我们可以有简单的模式匹配。</p><pre><code class=\"language-java\">public sealed interface Returned&lt;T&gt; {\n    Returned.Undefined UNDEFINED = new Undefined();\n\n    record ReturnValue&lt;T&gt;(T returnValue) implements Returned {\n    }\n\n    record Undefined() implements Returned {\n    }\n}\n</code></pre><p>然后呢，我们就可以使用Returned来表示返回值了。</p><pre><code class=\"language-plain\">public final class FullName {\n    // snipped\n    public Returned&lt;String&gt; middleName() {\n        if (middleName == null) {\n            return Returned.UNDEFINED;\n        }\n\n        return new Returned.ReturnValue&lt;&gt;(middleName);\n    }\n    // snipped\n}\n</code></pre><p>最后，我们来看看Returned是怎么使用的。</p><pre><code class=\"language-java\">private static boolean hasMiddleName(FullName fullName, String middleName) {\n    return switch (fullName.middleName()) {\n        case Returned.Undefined undefined -&gt; false;\n        case Returned.ReturnValue rv -&gt; {\n            String returnedMiddleName = (String)rv.returnValue();\n            yield returnedMiddleName.equals(middleName);\n        }\n    };\n}\n</code></pre><p>这种使用了封闭类和模式匹配的设计，极大地压缩了开发者的自由度，强制要求开发者的代码必须执行空指针的检查，只有这样才能编写下一步的代码。 这种看似放弃了灵活性的设计，恰恰把开发者从低级易犯的错误中解救了出来。不论是对写代码的开发者，还是对读代码的开发者来说，这都是一件好事。</p><p>好事情的背后，往往都意味着一些妥协。比如说吧，使用空指针的代码，我们可以轻松地使用档案类；使用Optional和Returned的代码，我们就要重新回到传统的类上面来了。</p><p>无论档案类、封闭类还是模式匹配，对于Java来说，都还是新鲜的技术。要想让这些技术之间熟练配合，还需要一些这样或者那样的磨练，包括不停地改进，组合效应的新研究等。</p><h2>总结</h2><p>好，到这里，我来做个小结。前面，我们讨论了空指针带来的问题，以及降低空指针负面影响的一些办法。</p><p>总体来说，在我们的代码里，尽量不要产生空指针。没有空指针，也就没有了空指针的烦恼。</p><p>如果避免不了空指针，我们就要看看能不能执行强制性的检查。比如使用封闭类和模式匹配的组合形式，让编译器和接口设计帮助我们实施这种强制性。</p><p>如果不能实施强制性的检查，我们就要遵守空指针的编码纪律。也就是说，对于可能是空指针的变量，先检查后使用。</p><p>如果面试中聊到了空指针的问题，你可以聊一聊空指针的危害，以及我们这一次学习到的解决办法。</p><h2>思考题</h2><p>今天，我们使用封闭类和模式匹配来降低空指针危害的例子，有点像我们前面提到过的替代异常处理的错误码方案。其实，一个带有返回值的方法，通常要考虑三种情况：正常情况、异常情况以及空指针。我们可以把空指针解读为正常情况，也可以解读为异常情况。</p><p>如果要在返回值这个封闭类里考虑进这三种情况，我们该怎么设计这个封闭类以及它的许可类呢？这是我们这一次的思考题。</p><p>为了方便你阅读，我把我们这次讨论用到的Returned的实现代码拷贝到了下面。你可以在这个基础上修改。</p><pre><code class=\"language-java\">public sealed interface Returned&lt;T&gt; {\n    Returned.Undefined UNDEFINED = new Undefined();\n\n    record ReturnValue&lt;T&gt;(T returnValue) implements Returned {\n    }\n\n    record Undefined() implements Returned {\n    }\n}\n</code></pre><p>欢迎你在留言区留言、讨论，分享你的阅读体验以及你的设计和代码。我们下节课见！</p><p>注：本文使用的完整的代码可以从<a href=\"https://github.com/XueleiFan/java-up/tree/main/src/main/java/co/ivi/jus/nullp\">GitHub</a>下载，你可以通过修改<a href=\"https://github.com/XueleiFan/java-up/tree/main/src/main/java/co/ivi/jus/nullp\">GitHub</a>上<a href=\"https://github.com/XueleiFan/java-up/blob/main/src/main/java/co/ivi/jus/nullp/review/xuelei/Returned.java\">review template</a>代码，完成这次的思考题。如果你想要分享你的修改或者想听听评审的意见，请提交一个 GitHub的拉取请求（Pull Request），并把拉取请求的地址贴到留言里。这一小节的拉取请求代码，请在<a href=\"https://github.com/XueleiFan/java-up/tree/main/src/main/java/co/ivi/jus/nullp/review\">空指针专用的代码评审目录</a>下，建一个以你的名字命名的子目录，代码放到你专有的子目录里。比如，我的代码，就放在nullp/review/xuelei的目录下面。</p>","comments":[{"had_liked":false,"id":327046,"user_name":"fatme","can_delete":false,"product_type":"c1","uid":1034451,"ip_address":"","ucode":"75A805D2BB2AD1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c8/d3/3020ae46.jpg","comment_is_top":false,"comment_ctime":1639884682,"is_pvip":false,"replies":[{"id":"119010","content":"一门编程语言的最大目标，是程序员不犯错误，而不是好的程序员少犯错误。所以，在不同的角度看，答案也许不一样。<br>1. 除了isPresent，其他的方法都是附带的红利。<br>2. 如果能够消除空指针的产生，也就用不着Required了；如果消除不了，Required也不用着。<br>3. 这本质上和直接判断空指针是一样的，需要程序员的认真和代码阅读者的认真。如果都能够认真起来，就不存在空指针的问题了。<br><br>无论是GoLang还是Optional, Returned，和直接检查空指针相比，都没有简化代码。这是消除空指针影响的代价。","user_name":"作者回复","user_name_real":"作者","uid":"1111315","ctime":1639982157,"ip_address":"","comment_id":327046,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5934851978","product_id":100097301,"comment_content":"1. 感觉 Optional 更有用的是 orElse, ifPresent, filter, map, flatMap 这些方法。isPresent 本质上和判断空指针的方式是一样的，没有优势<br>2. 像 Optional 是对 nullable 数据的支持，java 也可以增加对 required 数据的支持。比如增加 Required&lt;T&gt;, 编译器禁止对 Required 数据赋值 null。我们的代码变为：public record FullName(Required&lt;String&gt; firstName, String middleName, Required&lt;String&gt; lastName)。这样对哪些数据是可空，哪些数据是不可空，一目了然。<br>3. Retruned 的使用太复杂。我更愿意使用以下代码：<br>switch (fullName.middleName()) {<br>    case null -&gt; {...};<br>    case String s -&gt; {...};<br>}","like_count":1,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540179,"discussion_content":"一门编程语言的最大目标，是程序员不犯错误，而不是好的程序员少犯错误。所以，在不同的角度看，答案也许不一样。\n1. 除了isPresent，其他的方法都是附带的红利。\n2. 如果能够消除空指针的产生，也就用不着Required了；如果消除不了，Required也不用着。\n3. 这本质上和直接判断空指针是一样的，需要程序员的认真和代码阅读者的认真。如果都能够认真起来，就不存在空指针的问题了。\n\n无论是GoLang还是Optional, Returned，和直接检查空指针相比，都没有简化代码。这是消除空指针影响的代价。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639982158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326901,"user_name":"墨名次","can_delete":false,"product_type":"c1","uid":1330267,"ip_address":"","ucode":"926EDC57291C09","user_header":"https://static001.geekbang.org/account/avatar/00/14/4c/5b/5499d6e6.jpg","comment_is_top":false,"comment_ctime":1639739031,"is_pvip":false,"replies":[{"id":"118764","content":"这个写法有意思。非空的话，该怎么处理？","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1639760536,"ip_address":"","comment_id":326901,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5934706327","product_id":100097301,"comment_content":"Returned跟Optional还是有些复杂，<br>在C＃跟Kotlin里面我觉得挺简洁的，如果借鉴C#可以这样写:<br><br><br>private static boolean hasMiddleName(FullName fullName, String middleName) {<br>    return fullName.middleName?.equals(middleName);<br>}<br><br><br>就只加一个问号，如果需要判断fullName对象是否空那就前面再加一个问号","like_count":1,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539601,"discussion_content":"这个写法有意思。非空的话，该怎么处理？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639760536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1330267,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4c/5b/5499d6e6.jpg","nickname":"墨名次","note":"","ucode":"926EDC57291C09","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":539604,"discussion_content":"老师指的是fullName对象非空吗，\n\nreturn fullName?.middleName?.equals(middleName) ?? false;\n\n因为前面的比较逻辑会返回一个可空的布尔类型bool?，所以用双问号在后面加了个默认值false；\n\n如果形参middleName是一个常量那么还可以这样写:\n\nreturn fullName is {middleName : middleName};\n\n如果fullName为null也不会出现空引用的，其中花括号里左边的middleName是fullName的属性，右边的middleName是参数。\n\n上面两种写法只要参数middleName为null那么返回结果一定为false。\n\n上面的两种写法等同于:\n\nif(middleName == null || fullName == null || fullName.middleName == null) {\nreturn false;\n}\nreturn fullName.middleName.equals(middleName);\n\n代码简洁是挺简洁的，不过感觉也有点复杂，不学习的话可能不能一眼看懂，我还是更喜欢if else一些","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1639764168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":539601,"ip_address":""},"score":539604,"extra":""}]},{"author":{"id":1104850,"avatar":"https://static001.geekbang.org/account/avatar/00/10/db/d2/e29f8834.jpg","nickname":"lidashuang","note":"","ucode":"560ABE8032760E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546690,"discussion_content":"Ruby里也这样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642392853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326835,"user_name":"kimoti","can_delete":false,"product_type":"c1","uid":1897671,"ip_address":"","ucode":"0A78077408C2B1","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f4/c7/037235c9.jpg","comment_is_top":false,"comment_ctime":1639715985,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5934683281","product_id":100097301,"comment_content":"感觉那个Optional就是个鸡肋,你不还是得调一下isPresent方法吗？这和判断一下是否为NULL不是一样吗？","like_count":1,"discussions":[{"author":{"id":1258209,"avatar":"https://static001.geekbang.org/account/avatar/00/13/32/e1/c9aacb37.jpg","nickname":"段启超","note":"","ucode":"164CF3018071B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540493,"discussion_content":"Optional 的价值不在于能避免空指针，更多的是一个强制性的提醒，让你去强制校验空指针。如果你去问一个开发为啥NPE了，得到的答案可能就是两个字： 忘了， 就这么直接。所以optional 是提醒你要去校验，而不是能替你解决。 ","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1640069260,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1673990,"avatar":"https://static001.geekbang.org/account/avatar/00/19/8b/06/fb3be14a.jpg","nickname":"TableBear","note":"","ucode":"A2C0562EEA2725","race_medal":3,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539504,"discussion_content":"个人感觉可能跟@Nullable注解是一样的，只是告诉调用者我这个函数返回值可能是空。个人浅见，不喜勿喷。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1639730686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326779,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1639673687,"is_pvip":false,"replies":[{"id":"118729","content":"Optional一言难尽啊","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1639713597,"ip_address":"","comment_id":326779,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5934640983","product_id":100097301,"comment_content":"开始使用 Optional 的时候确实也遇到了像文中说的空指针（以为使用后就能神奇的消除空指针），后来还错用了 Optional.of() 又遇到空指针，直到最后才发现 Optional.ofNullable() 才是能最大限度避免空指针的方法。<br>如果有需要返回 null 的地方，可以通过一个中间层封装其状态，避免直接返回 null；<br>或者今后 JDK 升级功能后像 Go 一样没有空指针异常了，但是 Go 的 panic 一样能让程序崩溃；<br>支持老师的观点：在我们的代码里，尽量不要产生空指针。没有空指针，也就没有了空指针的烦恼","like_count":1,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539430,"discussion_content":"Optional一言难尽啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639713598,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":539463,"discussion_content":"多次被坑后领会了设计意图，按套路写，好多了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639722566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":539430,"ip_address":""},"score":539463,"extra":""}]}]},{"had_liked":false,"id":359547,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1665633837,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665633837","product_id":100097301,"comment_content":"学习打卡","like_count":0},{"had_liked":false,"id":344455,"user_name":"shen","can_delete":false,"product_type":"c1","uid":1215066,"ip_address":"","ucode":"AE5737B0C7DC4F","user_header":"https://static001.geekbang.org/account/avatar/00/12/8a/5a/b67a82e3.jpg","comment_is_top":false,"comment_ctime":1651565122,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651565122","product_id":100097301,"comment_content":"上面消除null的其实就是空对象模式","like_count":0},{"had_liked":false,"id":331704,"user_name":"时光勿念","can_delete":false,"product_type":"c1","uid":1025003,"ip_address":"","ucode":"72C8EC5A62C700","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a3/eb/d26459ae.jpg","comment_is_top":false,"comment_ctime":1642731961,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642731961","product_id":100097301,"comment_content":"用optional代码还会变的臃肿，好丑的，还不如@Nullable","like_count":0},{"had_liked":false,"id":328053,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1640504238,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640504238","product_id":100097301,"comment_content":"1.optional我一般是多个map打点下去。判断是否存在很少用。 都是最后包不存在抛指定异常的逻辑。<br>2.好处是结构可读性有很大提高，不要每步都判空了。<br>3.坏处是没有每步判空，所以并不好排查是哪步返回空导致逻辑没往下周。（健全日志可以缓解）<br><br>看来这东西普遍的用法和实现者的期望差距有点大呀。","like_count":0},{"had_liked":false,"id":327406,"user_name":"Jagger Chen","can_delete":false,"product_type":"c1","uid":1993603,"ip_address":"","ucode":"7C6ACBCF32ED12","user_header":"https://static001.geekbang.org/account/avatar/00/1e/6b/83/5fb44cd0.jpg","comment_is_top":false,"comment_ctime":1640102729,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640102729","product_id":100097301,"comment_content":"尝试将空指针定义为异常情况<br>https:&#47;&#47;github.com&#47;XueleiFan&#47;java-up&#47;pull&#47;17&#47;commits","like_count":0},{"had_liked":false,"id":327389,"user_name":"Jagger Chen","can_delete":false,"product_type":"c1","uid":1993603,"ip_address":"","ucode":"7C6ACBCF32ED12","user_header":"https://static001.geekbang.org/account/avatar/00/1e/6b/83/5fb44cd0.jpg","comment_is_top":false,"comment_ctime":1640094263,"is_pvip":false,"replies":[{"id":"119239","content":"是的，这个if语句编译器不能强制性的检查。","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1640201918,"ip_address":"","comment_id":327389,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640094263","product_id":100097301,"comment_content":"老师您好，尝试将判断为 null 这段逻辑注释掉，编译器没有报错，是否说明没有完全地做到强制检查呢？谢谢<br>    public Returned&lt;String&gt; middleName() {<br>&#47;&#47;        if (middleName == null) {<br>&#47;&#47;            return Returned.UNDEFINED;<br>&#47;&#47;        }<br>        return new Returned.ReturnValue&lt;&gt;(middleName);<br>    }","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540921,"discussion_content":"是的，这个if语句编译器不能强制性的检查。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640201918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326920,"user_name":"第二少","can_delete":false,"product_type":"c1","uid":1004264,"ip_address":"","ucode":"4A09D1E7589F67","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/e8/92a2e66d.jpg","comment_is_top":false,"comment_ctime":1639750896,"is_pvip":true,"replies":[{"id":"119006","content":"用对了就好，不过容易用错，不是我喜欢的方式","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1639972702,"ip_address":"","comment_id":326920,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1639750896","product_id":100097301,"comment_content":"Optional 在这样一种情景下特别有用：<br>a.b.c.d.e.f <br>其中a,b,c,d,e,f都有可能为null，现在要访问f，进行一些处理，可以这么做：<br>Optional.ofNullable(a).map(A::getB).map(B::getC).map(C::getD).map(D::getE).map(E::getF).ifPresent(f -&gt; ...);<br>只要a,b,c,d,e,f中任何一个为null，后续的代码就不会继续执行，也不会抛出NPE","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540155,"discussion_content":"用对了就好，不过容易用错，不是我喜欢的方式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639972702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/e24e181e.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544777,"discussion_content":"不抛NPE，就不知道哪里出错了，有时候这样的行为“突然不工作”，又没异常抛出，反而对业务解决不友好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641708623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1004264,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/52/e8/92a2e66d.jpg","nickname":"第二少","note":"","ucode":"4A09D1E7589F67","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/e24e181e.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545721,"discussion_content":"就我假设的这个场景来说，通常这是在一个流处理过程中，如果存在需要处理的f，就取出来处理，如果不存在f（说明a,b,c,d,e,f中至少有一个为null）就跳过，继续处理流中的下一个数据；如果中间抛异常，就会中断整个流处理；如果是为了debug方便，可以适当增加日志代码，抛异常不是一个好的方式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642044937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":544777,"ip_address":""},"score":545721,"extra":""}]}]},{"had_liked":false,"id":326906,"user_name":"redseed","can_delete":false,"product_type":"c1","uid":1067102,"ip_address":"","ucode":"939551D0925035","user_header":"https://static001.geekbang.org/account/avatar/00/10/48/5e/36d96d40.jpg","comment_is_top":false,"comment_ctime":1639743121,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639743121","product_id":100097301,"comment_content":"Option.flatMap 在多层嵌套判空的场景比较有用，其他就比较一般了","like_count":0},{"had_liked":false,"id":326903,"user_name":"Calvin","can_delete":false,"product_type":"c1","uid":1603004,"ip_address":"","ucode":"0EEF5B207623B5","user_header":"https://static001.geekbang.org/account/avatar/00/18/75/bc/e24e181e.jpg","comment_is_top":false,"comment_ctime":1639740062,"is_pvip":false,"replies":[{"id":"118765","content":"可以看看GitHub里同学们做的作业啊。如果GitHub的PR不能提供答案，我再看看怎么讲这些习题。","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1639760672,"ip_address":"","comment_id":326903,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1639740062","product_id":100097301,"comment_content":"老师，这些课程最后的习题，能不能讲一下答案？<br>不然都不知道自己做的对不对，比如可以加餐一讲专门讲，这样也可以丰富一下这个课程的目录和内容。","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539602,"discussion_content":"可以看看GitHub里同学们做的作业啊。如果GitHub的PR不能提供答案，我再看看怎么讲这些习题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639760672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326844,"user_name":"bigben","can_delete":false,"product_type":"c1","uid":1169313,"ip_address":"","ucode":"DBD15A6C8E2590","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJkeOAC8k7aPMfQZ4ickiavpfR9mTQs1wGhGtIicotzAoszE5qkLfFTabkDU2E39ovSgoibJ1IiaLXtGicg/132","comment_is_top":false,"comment_ctime":1639719782,"is_pvip":false,"replies":[{"id":"118766","content":"还在探索更简单的方式。","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1639761965,"ip_address":"","comment_id":326844,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1639719782","product_id":100097301,"comment_content":"用Returned并不比Optional有优势，代码比较冗长，整个公司统一比较难。java语言级为啥不提供更简单的方式呢？其它语言有可借鉴的好的方法吗？","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539603,"discussion_content":"还在探索更简单的方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639761966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326843,"user_name":"学习","can_delete":false,"product_type":"c1","uid":1437425,"ip_address":"","ucode":"CDFB71E0D1508B","user_header":"https://static001.geekbang.org/account/avatar/00/15/ee/f1/16545faf.jpg","comment_is_top":false,"comment_ctime":1639719481,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639719481","product_id":100097301,"comment_content":"optional我是体验不出强大之处，代码量还是那么多，没怎么降，不过Optionl.ifPersent()有时还是有点用，但没优势","like_count":0}]}