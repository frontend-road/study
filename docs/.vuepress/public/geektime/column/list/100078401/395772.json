{"id":395772,"title":"30 | 部门响应：设备如何处理内核I/O包？","content":"<p>你好，我是LMOS。</p><p>在上一课中，我们实现了建立设备的接口，这相当于制定了部门的相关法规，只要遵守这些法规就能建立一个部门。当然，建立了一个部门，是为了干活的，吃空饷可不行。</p><p>其实一个部门的职责不难确定，它应该能对上级下发的任务作出响应，并完成相关工作，而这对应到设备，就是如何处理内核的I/O包，这节课我们就来解决这个问题。</p><p>首先，我们需要搞清楚什么是I/O包，然后实现内核向设备发送I/O包的工作。最后，我还会带你一起来完成一个驱动实例，用于处理I/O包，这样你就能真正理解这里的来龙去脉了。</p><p>好，让我们开始今天的学习吧！代码你可以从<a href=\"https://gitee.com/lmos/cosmos/tree/master/lesson30/Cosmos\">这里</a>下载。</p><h2>什么是I/O包</h2><p>就像你要给部门下达任务时，需要准备材料报表之类的东西。同样，内核要求设备做什么事情，完成什么功能，必须要告诉设备的驱动程序。</p><p>内核要求设备完成任务，无非是调用设备的驱动程序函数，把完成任务的细节用参数的形式传递给设备的驱动程序。</p><p>由于参数很多，而且各种操作所需的参数又不相同，所以我们就想到了更高效的管理方法，也就是把各种操作所需的各种参数封装在一个数据结构中，称为I/O包，这样就可以统一驱动程序功能函数的形式了。</p><p>思路理清以后，现在我们来设计这个数据结构，如下所示。</p><!-- [[[read_end]]] --><pre><code>typedef struct s_OBJNODE\n{\n    spinlock_t  on_lock;        //自旋锁\n    list_h_t    on_list;        //链表\n    sem_t       on_complesem;   //完成信号量\n    uint_t      on_flgs;        //标志\n    uint_t      on_stus;        //状态\n    sint_t      on_opercode;    //操作码\n    uint_t      on_objtype;     //对象类型\n    void*       on_objadr;      //对象地址\n    uint_t      on_acsflgs;     //访问设备、文件标志\n    uint_t      on_acsstus;     //访问设备、文件状态\n    uint_t      on_currops;     //对应于读写数据的当前位置\n    uint_t      on_len;         //对应于读写数据的长度\n    uint_t      on_ioctrd;      //IO控制码\n    buf_t       on_buf;         //对应于读写数据的缓冲区\n    uint_t      on_bufcurops;   //对应于读写数据的缓冲区的当前位置\n    size_t      on_bufsz;       //对应于读写数据的缓冲区的大小\n    uint_t      on_count;       //对应于对象节点的计数\n    void*       on_safedsc;     //对应于对象节点的安全描述符\n    void*       on_fname;       //对应于访问数据文件的名称\n    void*       on_finode;      //对应于访问数据文件的结点\n    void*       on_extp;        //用于扩展\n}objnode_t;\n</code></pre><p>现在你可能还无法从objnode_t这个名字看出它跟I/O包的关系。但你从刚才的代码里可以看出，objnode_t的数据结构中包括了各个驱动程序功能函数的所有参数。</p><p>等我们后面讲到API接口时，你会发现，objnode_t结构不单是完成了I/O包传递参数的功能，它在整个I/O生命周期中，都起着重要的作用。这里为了好理解，我们就暂且把objnode_t结构当作I/O包来看。</p><h3>创建和删除I/O包</h3><p>刚才，我们已经定义了I/O包也就是objnode_t结构，但若是要使用它，就必须先把它建立好。</p><p>根据以往的经验，你应该已经猜到了，这里创建I/O包就是在内存中建立objnode_t结构的实例变量并初始化它。由于这是一个全新的模块，所以我们要先在cosmos/kernel/目录下建立一个新的krlobjnode.c文件，在这个文件中写代码，如下所示。</p><pre><code>//建立objnode_t结构\nobjnode_t *krlnew_objnode()\n{\n    objnode_t *ondp = (objnode_t *)krlnew((size_t)sizeof(objnode_t));//分配objnode_t结构的内存空间\n    if (ondp == NULL)\n    {\n        return NULL;\n    }\n    objnode_t_init(ondp);//初始化objnode_t结构\n    return ondp;\n}\n//删除objnode_t结构\nbool_t krldel_objnode(objnode_t *onodep)\n{\n    if (krldelete((adr_t)onodep, (size_t)sizeof(objnode_t)) == FALSE)//删除objnode_t结构的内存空间\n    {\n        hal_sysdie(&quot;krldel_objnode err&quot;);\n        return FALSE;\n    }\n    return TRUE;\n}\n</code></pre><p>上述代码非常简单，主要完成了建立、删除objnode_t结构这两件事，其实说白了就是分配和释放objnode_t结构的内存空间。</p><p>这里再一次体现了<strong>内存管理组件在操作系统内核之中的重要性</strong>，objnode_t_init函数会初始化objnode_t结构中的字段，因为其中有自旋锁、链表、信号量，而这些结构并不能简单地初始为0，否则可以直接使用memset之类的函数把那个内存空间清零就行了。</p><h2>向设备发送I/O包</h2><p>现在我们假定在上层接口函数中，已经建立了一个I/O包（即objnode_t结构），并且把操作码、操作对象和相关的参数信息填写到了objnode_t结构之中。那么下一步，就需要把这个I/O发送给具体设备的驱动程序，以便驱动程序完成具体工作。</p><p>我们需要定义实现一个函数，专门用于完成这个功能，它标志着一个设备驱动程序开始运行，经它之后内核就实际的控制权交给驱动程序，由驱动程序代表内核操控设备。</p><p>下面，我们就来写好这个函数，不过这个函数属于驱动模型函数，所以要在krldevice.c文件中实现这个函数。代码如下所示。</p><pre><code>//发送设备IO\ndrvstus_t krldev_io(objnode_t *nodep)\n{\n    //获取设备对象 \n    device_t *devp = (device_t *)(nodep-&gt;on_objadr);\n    if ((nodep-&gt;on_objtype != OBJN_TY_DEV &amp;&amp; nodep-&gt;on_objtype != OBJN_TY_FIL) || nodep-&gt;on_objadr == NULL)\n    {//检查操作对象类型是不是文件或者设备，对象地址是不是为空\n        return DFCERRSTUS;\n    }\n    if (nodep-&gt;on_opercode &lt; 0 || nodep-&gt;on_opercode &gt;= IOIF_CODE_MAX)\n    {//检查IO操作码是不是合乎要求\n        return DFCERRSTUS;\n    }\n    return krldev_call_driver(devp, nodep-&gt;on_opercode, 0, 0, NULL, nodep);//调用设备驱动\n}\n//调用设备驱动\ndrvstus_t krldev_call_driver(device_t *devp, uint_t iocode, uint_t val1, uint_t val2, void *p1, void *p2)\n{\n    driver_t *drvp = NULL;\n    if (devp == NULL || iocode &gt;= IOIF_CODE_MAX)\n    {//检查设备和IO操作码\n        return DFCERRSTUS;\n    }\n    drvp = devp-&gt;dev_drv;\n    if (drvp == NULL)//检查设备是否有驱动程序\n    {\n        return DFCERRSTUS;\n    }\n    //用IO操作码为索引调用驱动程序功能分派函数数组中的函数\n    return drvp-&gt;drv_dipfun[iocode](devp, p2);\n}\n</code></pre><p>krldev_io函数，只接受一个参数，也就是objnode_t结构的指针。它会首先检查objnode_t结构中的IO操作码是不是合乎要求的，还要检查被操作的对象即设备是不是为空，然后调用krldev_call_driver函数。</p><p>这个krldev_call_driver函数会再次确认传递进来的设备和IO操作码，然后重点检查设备有没有驱动程序。这一切检查通过之后，我们就用IO操作码为索引调用驱动程序功能分派函数数组中的函数，并把设备和objnode_t结构传递进去。有没有觉得眼熟？没错，这正是我们<a href=\"https://time.geekbang.org/column/article/394875\">前面课程</a>中对驱动程序的设计。</p><p>好了，现在一个设备的驱动程序就能正式开始工作，开始响应处理内核发来的I/O包了。可是我们还没有驱动呢，所以下面我们就去实现一个驱动程序。</p><h2>驱动程序实例</h2><p>现在我们一起来实现一个真实而且简单的设备驱动程序，就是systick设备驱动，它是我们Cosmos系统的心跳，systick设备的主要功能和作用是每隔 1ms产生一个中断，相当于一个定时器，每次时间到达就产生一个中断向系统报告又过了1ms，相当于千分之一秒，即每秒钟内产生1000次中断。</p><p>对于现代CPU的速度来说，这个中断频率不算太快。x86平台上有没有这样的定时器呢？当然有，其中8254就是一个古老且常用的定时器，对它进行编程设定，它就可以周期的产生定时器中断。</p><p>这里我们就以8254定时器为基础，实现Cosmos系统的systick设备。我们先从systick设备驱动程序的整体框架入手，然后建立systick设备，最后一步一步实现systick设备驱动程序。</p><h3>systick设备驱动程序的整体框架</h3><p>在前面的课程中，我们已经了解了在Cosmos系统下，一个设备驱动程序的基本框架，但是我们没有深入具体化。</p><p>所以，这里我会带你从全局好好了解一个真实的设备，它的驱动程序应该至少有哪些函数。由于这是个驱动程序，我们需要在cosmos/drivers/目录下建立一个drvtick.c文件，在drvtick.c文件中写入以下代码，如下所示。</p><pre><code>//驱动程序入口和退出函数\ndrvstus_t systick_entry(driver_t *drvp, uint_t val, void *p)\n{\n    return DFCERRSTUS;\n}\ndrvstus_t systick_exit(driver_t *drvp, uint_t val, void *p)\n{\n    return DFCERRSTUS;\n}\n//设备中断处理函数\ndrvstus_t systick_handle(uint_t ift_nr, void *devp, void *sframe)\n{\n    return DFCEERSTUS;\n}\n//打开、关闭设备函数\ndrvstus_t systick_open(device_t *devp, void *iopack)\n{\n    return DFCERRSTUS;\n}\ndrvstus_t systick_close(device_t *devp, void *iopack)\n{\n    return DFCERRSTUS;\n}\n//读、写设备数据函数\ndrvstus_t systick_read(device_t *devp, void *iopack)\n{\n    return DFCERRSTUS;\n}\ndrvstus_t systick_write(device_t *devp, void *iopack)\n{\n    return DFCERRSTUS;\n}\n//调整读写设备数据位置函数\ndrvstus_t systick_lseek(device_t *devp, void *iopack)\n{\n    return DFCERRSTUS;\n}\n//控制设备函数\ndrvstus_t systick_ioctrl(device_t *devp, void *iopack)\n{\n    return DFCERRSTUS;\n}\n//开启、停止设备函数\ndrvstus_t systick_dev_start(device_t *devp, void *iopack)\n{\n    return DFCERRSTUS;\n}\ndrvstus_t systick_dev_stop(device_t *devp, void *iopack)\n{\n    return DFCERRSTUS;\n}\n//设置设备电源函数\ndrvstus_t systick_set_powerstus(device_t *devp, void *iopack)\n{\n    return DFCERRSTUS;\n}\n//枚举设备函数\ndrvstus_t systick_enum_dev(device_t *devp, void *iopack)\n{\n    return DFCERRSTUS;\n}\n//刷新设备缓存函数\ndrvstus_t systick_flush(device_t *devp, void *iopack)\n{\n    return DFCERRSTUS;\n}\n//设备关机函数\ndrvstus_t systick_shutdown(device_t *devp, void *iopack)\n{\n    return DFCERRSTUS;\n}\n</code></pre><p>以上就是一个驱动程序必不可少的函数，<strong>在各个函数可以返回一个错误状态，而不做任何实际工作，但是必须要有这个函数。</strong>这样在内核发来任何设备功能请求时，驱动程序才能给予适当的响应。这样，一个驱动程序的整体框架就确定了。</p><p>写好了驱动程序的整体框架，我们这个驱动就完成了一半。下面我们来一步一步来实现它。</p><h3>systick设备驱动程序的入口</h3><p>我们先来写好systick设备驱动程序的入口函数。那这个函数用来做什么呢？其实我们在上一节课就详细讨论过，无非是建立设备，向内核注册设备，安装中断回调函数等操作，所以这里不再赘述。</p><p>我们直接写出这个函数，如下所示。</p><pre><code>drvstus_t systick_entry(driver_t* drvp,uint_t val,void* p)\n{\n    if(drvp==NULL) //drvp是内核传递进来的参数，不能为NULL\n    {\n        return DFCERRSTUS;\n    }\n    device_t* devp=new_device_dsc();//建立设备描述符结构的变量实例\n    if(devp==NULL)//不能失败\n    {\n        return DFCERRSTUS;\n    }\n    systick_set_driver(drvp);\n    systick_set_device(devp,drvp);//驱动程序的功能函数设置到driver_t结构中的drv_dipfun数组中\n    if(krldev_add_driver(devp,drvp)==DFCERRSTUS)//将设备挂载到驱动中\n    {\n        if(del_device_dsc(devp)==DFCERRSTUS)//注意释放资源。\n        {\n            return DFCERRSTUS;\n        }\n        return DFCERRSTUS;\n    }\n    if(krlnew_device(devp)==DFCERRSTUS)//向内核注册设备\n    {\n        if(del_device_dsc(devp)==DFCERRSTUS)//注意释放资源\n        {\n            return DFCERRSTUS;\n        }\n        return DFCERRSTUS;\n    }\n    //安装中断回调函数systick_handle\n    if(krlnew_devhandle(devp,systick_handle,20)==DFCERRSTUS)\n    {\n        return DFCERRSTUS;  //注意释放资源。\n    }\n    init_8254();//初始化物理设备 \n    if(krlenable_intline(0x20)==DFCERRSTUS)\n    { \n        return DFCERRSTUS;\n    }\n    return DFCOKSTUS;\n}\n</code></pre><p>你可能非常熟悉这部分代码，没错，这正是上节课中，我们的那个驱动程序入口函数的实例。</p><p>不过在上节课里，我们主要是要展示一个驱动程序入口函数的流程。这里却是要投入工作的真实设备驱动。</p><p>最后的<strong>krlenable_intline函数</strong>，它的主要功能是开启一个中断源上的中断。而init_8254函数则是为了初始化8254，它就是一个古老且常用的定时器。这两个函数非常简单，我已经帮写好了。</p><p>但是这样还不够，有了驱动程序入口函数，驱动程序并不会自动运行。根据前面我们的设计，需要把这个驱动程序入口函数放入驱动表中。</p><p>下面我们就把这个systick_entry函数，放到驱动表里，代码如下所示。</p><pre><code>//cosmos/kernel/krlglobal.c\nKRL_DEFGLOB_VARIABLE(drventyexit_t,osdrvetytabl)[]={systick_entry,NULL};\n</code></pre><p>有了刚才这步操作之后，Cosmos在启动的时候，就会执行初始驱动初始化init_krldriver函数，接着这个函数就会启动运行systick设备驱动程序入口函数。我们的systick_entry函数一旦执行，就会建立systick设备，不断的产生时钟中断。</p><h3>配置设备和驱动</h3><p>在驱动程序入口函数中，除了那些标准的流程之外，我们还要对设备和驱动进行适当的配置，就是设置一些标志、状态、名称、驱动功能派发函数等等。有了这些信息，设备才能加入到驱动程序中，然后注册到内核，这样才能被内核所识别。</p><p>好，让我们先来实现设置驱动程序的函数，它主要设置设备驱动程序的名称、功能派发函数，代码如下。</p><pre><code>void systick_set_driver(driver_t *drvp)\n{\n    //设置驱动程序功能派发函数\n    drvp-&gt;drv_dipfun[IOIF_CODE_OPEN] = systick_open;\n    drvp-&gt;drv_dipfun[IOIF_CODE_CLOSE] = systick_close;\n    drvp-&gt;drv_dipfun[IOIF_CODE_READ] = systick_read;\n    drvp-&gt;drv_dipfun[IOIF_CODE_WRITE] = systick_write;\n    drvp-&gt;drv_dipfun[IOIF_CODE_LSEEK] = systick_lseek;\n    drvp-&gt;drv_dipfun[IOIF_CODE_IOCTRL] = systick_ioctrl;\n    drvp-&gt;drv_dipfun[IOIF_CODE_DEV_START] = systick_dev_start;\n    drvp-&gt;drv_dipfun[IOIF_CODE_DEV_STOP] = systick_dev_stop;\n    drvp-&gt;drv_dipfun[IOIF_CODE_SET_POWERSTUS] = systick_set_powerstus;\n    drvp-&gt;drv_dipfun[IOIF_CODE_ENUM_DEV] = systick_enum_dev;\n    drvp-&gt;drv_dipfun[IOIF_CODE_FLUSH] = systick_flush;\n    drvp-&gt;drv_dipfun[IOIF_CODE_SHUTDOWN] = systick_shutdown;\n    drvp-&gt;drv_name = &quot;systick0drv&quot;;//设置驱动程序名称\n    return;\n}\n</code></pre><p>上述代码的功能并不复杂，我一说你就能领会。systick_set_driver函数，无非就是将12个驱动功能函数的地址，分别设置到driver_t结构的drv_dipfun数组中。其中，驱动功能函数在该数组中的元素位置，正好与IO操作码一一对应，当内核用IO操作码调用驱动时，就是调用了这个数据中的函数。最后，我们将驱动程序的名称设置为systick0drv。</p><p>新建的设备也需要配置相关的信息才能工作，比如需要指定设备，设备状态与标志，设备类型、设备名称这些信息。尤其要注意的是，设备类型非常重要，内核正是通过类型来区分各种设备的，下面我们写个函数，完成这些功能，代码如下所示。</p><pre><code>void systick_set_device(device_t *devp, driver_t *drvp)\n{\n    devp-&gt;dev_flgs = DEVFLG_SHARE;//设备可共享访问\n    devp-&gt;dev_stus = DEVSTS_NORML;//设备正常状态\n    devp-&gt;dev_id.dev_mtype = SYSTICK_DEVICE;//设备主类型\n    devp-&gt;dev_id.dev_stype = 0;//设备子类型\n    devp-&gt;dev_id.dev_nr = 0; //设备号\n    devp-&gt;dev_name = &quot;systick0&quot;;//设置设备名称\n    return;\n}\n</code></pre><p>上述代码中，systick_set_device函数需要两个参数，但是第二个参数暂时没起作用，而第一个参数其实是一个device_t结构的指针，在systick_entry函数中调用new_device_dsc函数的时候，就会返回这个指针。后面我们会把设备加载到内核中，那时这个指针指向的设备才会被注册。</p><h3>打开与关闭设备</h3><p>其实对于systick这样设备，主要功能是定时中断，还不能支持读、写、控制、刷新、电源相关的功能，就算内核对systick设备发起了这样的I/O包，systick设备驱动程序相关的功能函数也只能返回一个错误码，表示不支持这样的功能请求。</p><p>但是，打开与关闭设备这样的功能还是应该要实现。下面我们就来实现这两个功能请求函数，代码如下所示。</p><pre><code>//打开设备\ndrvstus_t systick_open(device_t *devp, void *iopack)\n{\n    krldev_inc_devcount(devp);//增加设备计数\n    return DFCOKSTUS;//返回成功完成的状态\n}\n//关闭设备\ndrvstus_t systick_close(device_t *devp, void *iopack)\n{\n    krldev_dec_devcount(devp);//减少设备计数\n    return DFCOKSTUS;//返回成功完成的状态\n}\n</code></pre><p>这样，打开与关闭设备的功能就实现了，只是简单地增加与减少设备的引用计数，然后返回成功完成的状态就行了。而增加与减少设备的引用计数，是为了统计有多少个进程打开了这个设备，当设备引用计数为0时，就说明没有进程使用该设备。</p><h3>systick设备中断回调函数</h3><p>对于systick设备来说，重要的并不是打开、关闭，读写等操作，而是systick设备产生的中断，以及在中断回调函数中执行的操作，即周期性的执行系统中的某些动作，比如更新系统时间，比如控制一个进程占用CPU的运行时间等，这些操作都需要在systick设备中断回调函数中执行。</p><p>按照前面的设计，systick设备每秒钟产生1000次中断，那么1秒钟就会调用1000次这个中断回调函数，这里我们只要写出这个函数就行了，因为安装中断回调函数的思路，我们在前面的课程中已经说过了（可以回顾上节课），现在我们直接实现这个中断函数，代码可以像后面这样写。</p><pre><code>drvstus_t systick_handle(uint_t ift_nr, void *devp, void *sframe)\n{\n    kprint(&quot;systick_handle run devname:%s intptnr:%d\\n&quot;, ((device_t *)devp)-&gt;dev_name, ift_nr);\n    return DFCOKSTUS;\n}\n</code></pre><p>这个中断回调函数，暂时什么也没干，就输出一条信息，让我们知道它运行了，为了直观观察它运行了，我们要对内核层初始化函数修改一下，禁止进程运行，以免进程输出的信息打扰我们观察结果，修改的代码如下所示。</p><pre><code>void init_krl()\n{\n    init_krlmm();\n    init_krldevice();//初始化设备\n    init_krldriver();//初始化驱动程序\n    init_krlsched();\n    //init_krlcpuidle();禁止进程运行\n    STI();//打开CPU响应中断的能力\n    die(0);//进入死循环\n    return;\n}\n</code></pre><p>下面，我们打开终端切到Cosmos目录下，执行make vboxtest指令，如果不出意外，我们将会中看到如下界面。</p><p><img src=\"https://static001.geekbang.org/resource/image/84/e9/84c7837a89eb56b2863c8b30eb1217e9.jpg?wh=1044x921\" alt=\"\" title=\"测试中断回调函数\"></p><p>上图中的信息，会不断地滚动出现，信息中包含设备名称和中断号，这标志着我们中断回调函数的运行正确无误。</p><p>当然，如果我们费了这么功夫搞了中断回调函数，就只是为了输出信息，那也太不划算了，我们当然有更重要的事情要做，你还记得之前讲过的进程知识吗？这里我再帮你理一理思路。</p><p>我们在每个进程中都要主动调用进程调度器函数，否则进程就会永远霸占CPU，永远运行下去。这是因为，我们没有定时器可以周期性地检查进程运行了多长时间，如果进程的运行时间超过了，就应该强制调度，让别的进程开始运行。</p><p>更新进程运行时间的代码，我已经帮你写好了，你只需要在这个中断回调函数中调用就好了，代码如下所示。</p><pre><code>drvstus_t systick_handle(uint_t ift_nr, void *devp, void *sframe)\n{\n    krlthd_inc_tick(krlsched_retn_currthread());//更新当前进程的tick\n    return DFCOKSTUS;\n}\n</code></pre><p>这里的krlthd_inc_tick函数需要一个进程指针的参数，而krlsched_retn_currthread函数是返回当前正在运行进程的指针。在krlthd_inc_tick函数中对进程的tick值加1，如果大于20（也就是20 毫秒）就重新置0，并进行调度。</p><p>下面，我们把内核层初始化函数恢复到原样，重新打开终端切到cosmos目录下，执行make vboxtest指令，我们就将会看到如下界面。</p><p><img src=\"https://static001.geekbang.org/resource/image/75/47/75647910ba0529e6c80ba127bbe9c247.jpg?wh=1044x921\" alt=\"\" title=\"测试进程运行时间更新\"></p><p>我们可以看到，进程A、进程B，还有调度器交替输出的信息。这已经证明我们更新进程运行时间，检查其时间是否用完并进行调度的代码逻辑，都是完全正确的，恭喜你走到了这一步！</p><p>至此，我们的systick驱动程序就实现了，它非常简单，但却包含了一个驱动程序完整实现。同时，这个过程也一步步验证了我们对驱动模型的设计是正确的。</p><h2>重点回顾</h2><p>又到课程的结尾，到此为止，我们了解了实现一个驱动程序完整过程，虽然我们只是驱动了一个定时器设备，使之周期性的产生定时中断。在定时器设备的中断回调函数中，我们调用了更新进程时间的函数，达到了这样的目的：在进程运行超时的情况下，内核有能力夺回CPU，调度别的进程运行。</p><p>现在我来为你梳理一下重点。</p><p>1.为了搞清楚设备如何处理I/O包，我们了解了什么是I/O包，写好了处理建立、删除I/O包的代码。</p><p>2.要使设备完成相应的功能，内核就必须向设备驱动发送相应的I/O包，在I/O包提供相应IO操作码和适当的参数。所以，我们动手实现了向设备发送I/O包并调用设备驱动程序的机制。</p><p>3.一切准备就绪之后，我们建立了systick驱动程序实例，这是一个完整的驱动程序，它支持打开关闭和周期性产生中断的功能请求。通过这个实例，让我们了解了一个真实设备驱动的实现以及它处理内核I/O包的过程。</p><p>你可能对这样简单的驱动程序不够满意，也不能肯定我们的驱动模型是不是能适应大多数场景，请不要着急，在后面讲到文件系统时，我们会实现一个更为复杂的驱动程序。</p><h2>思考题</h2><p>请你想一想，为什么没有systick设备这样周期性的产生中断，进程就有可能霸占CPU呢？</p><p>欢迎你在留言区跟我交流互动，也欢迎你把这节课分享给身边的同事、朋友，一起实践驱动程序的实例。</p><p>好，我是LMOS，我们下节课见！</p>","neighbors":{"left":{"article_title":"29 | 部门建立：如何在内核中注册设备？","id":394875},"right":{"article_title":"31 | 瞧一瞧Linux：如何获取所有设备信息？","id":396896}},"comments":[{"had_liked":false,"id":303461,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":true,"comment_ctime":1626798930,"is_pvip":false,"replies":[{"id":"109848","content":"对的，老哥总结到位","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1626833703,"ip_address":"","comment_id":303461,"utype":1}],"discussion_count":1,"race_medal":0,"score":"9.2233720685462999e+18","product_id":100078401,"comment_content":"一、数据结构<br>objnode_t表示一个IO包，包括了各种操作所需的各种参数<br><br>二、 向设备发送 I&#47;O 包<br>krldev_io-&gt;krldev_call_driver-&gt;通过函数指针，调用设备驱动指定功能编号的功能函数<br>所有驱动功能函数，都会传入objnode_t参数<br><br>三、 8254初始化<br>在上一节中，完成了8254设备的初始化及驱动的初始化，并启用了8254硬件中断<br>其中，在初始化驱动时：<br>systick_entry-&gt;krlnew_devhandle-&gt;krladd_irqhandle-&gt;hal_add_ihandle<br>将intserdsc_t结构【包括驱动回调函数】，挂载到了intfltdsc_t.i_serlist中<br><br>四、8254中断调用链<br>1、8254产生硬件中断<br>2、CPU收到中断，通过中断处理表IDT，找到中断门，通过门检查后，会找到中断处理入口，然后找到硬件中断分发函数hal_hwint_allocator<br>【第一个参数为中断编号，在rdi；第二个参数为中断发生时的栈指针，在rsi】<br>调用硬件中断处理函数hal_do_hwint<br>3、hal_do_hwint<br>如有必要，结束硬件中断<br>调用中断回调函数hal_do_hwint-&gt;hal_run_intflthandle<br>4、hal_run_intflthandle<br>先获取intfltdsc_t中断异常表<br>然后调用intfltdsc_t中，i_serlist上所有挂载intserdsc_t 结构中的中断处理的回调函数s_handle<br>5、8254回调函数为systick_handle<br>6、systick_handle<br>更新进程的tick，如果超出20毫秒，让出CPU使用权限，进行进程调度<br>","like_count":7,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523689,"discussion_content":"对的，老哥总结到位","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626833703,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":302798,"user_name":"springXu","can_delete":false,"product_type":"c1","uid":2064750,"ip_address":"","ucode":"F5DB0B963C894F","user_header":"","comment_is_top":false,"comment_ctime":1626380329,"is_pvip":true,"replies":[{"id":"109565","content":"正确 正确 ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1626398885,"ip_address":"","comment_id":302798,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35986118697","product_id":100078401,"comment_content":"因为内核的调度器也要被激活。如果没定时器中断，调度器的激活貌似只能靠其他中断，比如用户结束进程，或者进程抢占了其他被锁资源，才能激活进程调度器。","like_count":9,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523427,"discussion_content":"正确 正确 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626398885,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":309324,"user_name":"青玉白露","can_delete":false,"product_type":"c1","uid":2619436,"ip_address":"","ucode":"96FE2D4D2B94A0","user_header":"https://static001.geekbang.org/account/avatar/00/27/f8/2c/92969c48.jpg","comment_is_top":false,"comment_ctime":1630047976,"is_pvip":false,"replies":[{"id":"112124","content":"是的 是的","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1630286625,"ip_address":"","comment_id":309324,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5925015272","product_id":100078401,"comment_content":"因为进程根本不知道自己执行了多久的CPU，所以需要时钟来提醒他，并且在超时的时候强制进行进程调度。","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525829,"discussion_content":"是的 是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630286625,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":302810,"user_name":"罗 乾 林","can_delete":false,"product_type":"c1","uid":1188222,"ip_address":"","ucode":"D0406F95176ABA","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/7e/fb725950.jpg","comment_is_top":false,"comment_ctime":1626396077,"is_pvip":false,"replies":[{"id":"109560","content":"正确 老铁","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1626398669,"ip_address":"","comment_id":302810,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5921363373","product_id":100078401,"comment_content":"进程调度发生在用户态和内核态切换，如果一个应用程序只在用户态做计算不进行系统调用，系统将没有机会完成进程调度。定时器的出现就能打破这一问题，使系统进入中断处理程序，进而完成进程调度","like_count":2,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523437,"discussion_content":"正确 老铁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626398669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":302801,"user_name":"LDxy","can_delete":false,"product_type":"c1","uid":1188710,"ip_address":"","ucode":"956432CE7B7761","user_header":"https://static001.geekbang.org/account/avatar/00/12/23/66/413c0bb5.jpg","comment_is_top":false,"comment_ctime":1626391682,"is_pvip":false,"replies":[{"id":"109562","content":"我搞 很多 新名词概念 哈哈","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1626398767,"ip_address":"","comment_id":302801,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5921358978","product_id":100078401,"comment_content":" I&#47;O 包这个概念第一次听说","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523430,"discussion_content":"我搞 很多 新名词概念 哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626398767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2744096,"avatar":"https://static001.geekbang.org/account/avatar/00/29/df/20/22ea0c26.jpg","nickname":"开火车练漂移","note":"","ucode":"C810A2B205E7D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395877,"discussion_content":"请问作者，有关于操作系统内核相关故障分析或处理的方法，或相关说明吗？不是咱们的LMOS，其他操作系统的也可以，QNX最好，非常感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632360364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345092,"user_name":"艾恩凝","can_delete":false,"product_type":"c1","uid":2950704,"ip_address":"","ucode":"F2B81BF4F0106A","user_header":"https://static001.geekbang.org/account/avatar/00/2d/06/30/c26ea06a.jpg","comment_is_top":false,"comment_ctime":1652016784,"is_pvip":false,"replies":[{"id":"125955","content":"哈哈 ","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1652064603,"ip_address":"","comment_id":345092,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1652016784","product_id":100078401,"comment_content":"打卡，看简单，调程序 又花了点时间","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571059,"discussion_content":"哈哈 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652064603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308915,"user_name":"Entropy","can_delete":false,"product_type":"c1","uid":1708105,"ip_address":"","ucode":"F44486B23A7B13","user_header":"https://static001.geekbang.org/account/avatar/00/1a/10/49/01657245.jpg","comment_is_top":false,"comment_ctime":1629859247,"is_pvip":false,"replies":[{"id":"111877","content":"只有进程上下文","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1629940062,"ip_address":"","comment_id":308915,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1629859247","product_id":100078401,"comment_content":"如果产生时钟中断，那么此时cpu不是要切换上下文来执行中断回调函数systick_handle吗？ 如果是，那么调用krlsched_retn_currthread()是不是返回的是中断处理函数所在的进程，所以之前被切换的进程计时不会加1？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525680,"discussion_content":"只有进程上下文","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629940062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1708105,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/10/49/01657245.jpg","nickname":"Entropy","note":"","ucode":"F44486B23A7B13","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391215,"discussion_content":"我查了下这个博客：https://www.huaweicloud.com/articles/12525713.html\n里面提到了中断上下文和进程上下文...\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630334617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1708105,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/10/49/01657245.jpg","nickname":"Entropy","note":"","ucode":"F44486B23A7B13","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391210,"discussion_content":"那执行中断函数的时候不需要独立的上下文吗？还是说就在当前进程上下文中执行？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630333485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":302803,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1626393798,"is_pvip":false,"replies":[{"id":"109561","content":"是的 铁汁","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1626398727,"ip_address":"","comment_id":302803,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1626393798","product_id":100078401,"comment_content":"因为之前实现的调度主要看优先级和运行时间，如果没有 systick 中断来记录运行时间，那么调度器就无法根据运行时间来强制休眠高优先级进程，高优先级进程将会霸占CPU。","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523432,"discussion_content":"是的 铁汁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626398727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}