{"id":740783,"title":"第 18 章 同构渲染","content":"<h1 id=\"nav_point_180\">第 18 章　同构渲染</h1>\n<p>Vue.js 可以用于构建客户端应用程序，组件的代码在浏览器中运行，并输出 DOM 元素。同时，Vue.js 还可以在 Node.js 环境中运行，它可以将同样的组件渲染为字符串并发送给浏览器。这实际上描述了 Vue.js 的两种渲染方式，即<strong>客户端渲染</strong>（client-side rendering，CSR），以及<strong>服务端渲染</strong>（server-side rendering，SSR）。另外，Vue.js 作为现代前端框架，不仅能够独立地进行 CSR 或 SSR，还能够将两者结合，形成所谓的<strong>同构渲染</strong>（isomorphic rendering）。本章，我们将讨论 CSR、SSR 以及同构渲染之间的异同，以及 Vue.js 同构渲染的实现机制。</p>\n<h2 id=\"nav_point_181\">18.1　CSR、SSR 以及同构渲染</h2>\n<p>在设计软件时，我们经常会遇到这样的问题：“是否应该使用服务端渲染？”这个问题没有确切的答案，具体还要看软件的需求以及场景。想要为软件选择合适的架构策略，就需要我们对不同的渲染策略做到了然于胸，知道它们各自的优缺点。服务端渲染并不是一项新技术，也不是一个新概念。在 Web 2.0 之前，网站主要负责提供各种各样的内容，通常是一些新闻站点、个人博客、小说站点等。这些站点主要强调内容本身，而不强调与用户之间具有高强度的交互。当时的站点基本采用传统的服务端渲染技术来实现。例如，比较流行的 PHP/JSP 等技术。图 18-1 给出了服务端渲染的工作流程图。</p><!-- [[[read_end]]] -->\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00656.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 18-1　服务端渲染的工作流程</strong></p>\n<p>(1) 用户通过浏览器请求站点。</p>\n<p>(2) 服务器请求 API 获取数据。</p>\n<p>(3) 接口返回数据给服务器。</p>\n<p>(4) 服务器根据模板和获取的数据拼接出最终的 HTML 字符串。</p>\n<p>(5) 服务器将 HTML 字符串发送给浏览器，浏览器解析 HTML 内容并渲染。</p>\n<p>当用户再次通过超链接进行页面跳转，会重复上述 5 个步骤。可以看到，传统的服务端渲染的用户体验非常差，任何一个微小的操作都可能导致页面刷新。</p>\n<p>后来以 AJAX 为代表，催生了 Web 2.0。在这个阶段，大量的 SPA（single-page application）诞生，也就是接下来我们要介绍的 CSR 技术。与 SSR 在服务端完成模板和数据的融合不同，CSR 是在浏览器中完成模板与数据的融合，并渲染出最终的 HTML 页面。图 18-2 给出了 CSR 的详细工作流程。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00657.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 18-2　CSR 的工作流程</strong></p>\n<ul>\n<li><p>客户端向服务器或 CDN 发送请求，获取静态的 HTML 页面。注意，此时获取的 HTML 页面通常是空页面。在 HTML 页面中，会包含 <code>&lt;style&gt;</code>、<code>&lt;link&gt;</code> 和 <code>&lt;script&gt;</code> 等标签。例如：</p>\n<pre class=\"code-rows\"><code> &lt;!DOCTYPE html&gt;\n &lt;html lang=\"zh\"&gt;\n &lt;head&gt;\n   &lt;meta charset=\"UTF-8\"&gt;\n   &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n   &lt;title&gt;My App&lt;/title&gt;\n   &lt;link rel=\"stylesheet\" href=\"/dist/app.css\"&gt;\n &lt;/head&gt;\n &lt;body&gt;\n   &lt;div id=\"app\"&gt;&lt;/div&gt;\n<p>&lt;script src=“/dist/app.js”&gt;&lt;/script&gt;<br />\n&lt;/body&gt;<br />\n&lt;/html&gt;<br />\n</code></pre></p>\n<p>这是一个包含 <code>&lt;link rel=\"stylesheet\"&gt;</code> 与 <code>&lt;script&gt;</code> 标签的空 HTML 页面。浏览器在得到该页面后，不会渲染出任何内容，所以从用户的视角看，此时页面处于“白屏”阶段。</p>\n</li>\n<li><p>虽然 HTML 页面是空的，但浏览器仍然会解析 HTML 内容。由于 HTML 页面中存在 <code>&lt;link rel=\"stylesheet\"&gt;</code> 和 <code>&lt;script&gt;</code> 等标签，所以浏览器会加载 HTML 中引用的资源，例如 app.css 和 app.js。接着，服务器或 CDN 会将相应的资源返回给浏览器，浏览器对 CSS 和 JavaScript 代码进行解释和执行。因为页面的渲染任务是由 JavaScript 来完成的，所以当 JavaScript 被解释和执行后，才会渲染出页面内容，即“白屏”结束。但初始渲染出来的内容通常是一个“骨架”，因为还没有请求 API 获取数据。</p>\n</li>\n<li>客户端再通过 AJAX 技术请求 API 获取数据，一旦接口返回数据，客户端就会完成动态内容的渲染，并呈现完整的页面。</li>\n</ul>\n<p>当用户再次通过点击“跳转”到其他页面时，浏览器并不会真正的进行跳转动作，即不会进行刷新，而是通过前端路由的方式动态地渲染页面，这对用户的交互体验会非常友好。但很明显的是，与 SSR 相比，CSR 会产生所谓的“白屏”问题。实际上，CSR 不仅仅会产生白屏问题，它对 SEO（搜索引擎优化）也不友好。表 18-1 从多个方面比较了 SSR 与 CSR。</p>\n<p><strong>表 18-1　SSR 与 CSR 的比较</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>&nbsp;</p></th>\n<th><p>SSR</p></th>\n<th><p>CSR</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>SEO</p></td>\n<td><p>友好</p></td>\n<td><p>不友好</p></td>\n</tr>\n<tr>\n<td><p>白屏问题</p></td>\n<td><p>无</p></td>\n<td><p>有</p></td>\n</tr>\n<tr>\n<td><p>占用服务端资源</p></td>\n<td><p>多</p></td>\n<td><p>少</p></td>\n</tr>\n<tr>\n<td><p>用户体验</p></td>\n<td><p>差</p></td>\n<td><p>好</p></td>\n</tr>\n</tbody>\n</table>\n<p>SSR 和 CSR 各有优缺点。SSR 对 SEO 更加友好，而 CSR 对 SEO 不太友好。由于 SSR 的内容到达时间更快，因此它不会产生白屏问题。相对地，CSR 会有白屏问题。另外，由于 SSR 是在服务端完成页面渲染的，所以它需要消耗更多服务端资源。CSR 则能够减少对服务端资源的消耗。对于用户体验，由于 CSR 不需要进行真正的“跳转”，用户会感觉更加“流畅”，所以 CSR 相比 SSR 具有更好的用户体验。从这些角度来看，无论是 SSR 还是 CSR，都不可以作为“银弹”，我们需要从项目的实际需求出发，决定到底采用哪一个。例如你的项目非常需要 SEO，那么就应该采用 SSR。</p>\n<p>那么，我们能否融合 SSR 与 CSR 两者的优点于一身呢？答案是“可以的”，这就是接下来我们要讨论的同构渲染。同构渲染分为首次渲染（即首次访问或刷新页面）以及非首次渲染。图 18-3 给出了同构渲染首次渲染的工作流程。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00658.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 18-3　真实 DOM 与虚拟 DOM 的关系</strong></p>\n<p>实际上，同构渲染中的首次渲染与 SSR 的工作流程是一致的。也就是说，当首次访问或者刷新页面时，整个页面的内容是在服务端完成渲染的，浏览器最终得到的是渲染好的 HTML 页面。但是该页面是纯静态的，这意味着用户还不能与页面进行任何交互，因为整个应用程序的脚本还没有加载和执行。另外，该静态的 HTML 页面中也会包含 <code>&lt;link&gt;</code>、<code>&lt;script&gt;</code> 等标签。除此之外，同构渲染所产生的 HTML 页面与 SSR 所产生的 HTML 页面有一点最大的不同，即前者会包含当前页面所需要的初始化数据。直白地说，服务器通过 API 请求的数据会被序列化为字符串，并拼接到静态的 HTML 字符串中，最后一并发送给浏览器。这么做实际上是为了后续的激活操作，后文会详细讲解。</p>\n<p>假设浏览器已经接收到初次渲染的静态 HTML 页面，接下来浏览器会解析并渲染该页面。在解析过程中，浏览器会发现 HTML 代码中存在 <code>&lt;link&gt;</code> 和 <code>&lt;script&gt;</code> 标签，于是会从 CDN 或服务器获取相应的资源，这一步与 CSR 一致。当 JavaScript 资源加载完毕后，会进行激活操作，这里的激活就是我们在 Vue.js 中常说的 “hydration”。激活包含两部分工作内容。</p>\n<ul>\n<li>Vue.js 在当前页面已经渲染的 DOM 元素以及 Vue.js 组件所渲染的虚拟 DOM 之间建立联系。</li>\n<li>Vue.js 从 HTML 页面中提取由服务端序列化后发送过来的数据，用以初始化整个 Vue.js 应用程序。</li>\n</ul>\n<p>激活完成后，整个应用程序已经完全被 Vue.js 接管为 CSR 应用程序了。后续操作都会按照 CSR 应用程序的流程来执行。当然，如果刷新页面，仍然会进行服务端渲染，然后再进行激活，如此往复。</p>\n<p>表 18-2 对比了 SSR、CSR 和同构渲染的优劣。</p>\n<p><strong>表 18-2　SSR、CSR 和同构渲染之间的对比</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>&nbsp;</p></th>\n<th><p>SSR</p></th>\n<th><p>CSR</p></th>\n<th><p>同构渲染</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>SEO</p></td>\n<td><p>友好</p></td>\n<td><p>不友好</p></td>\n<td><p>友好</p></td>\n</tr>\n<tr>\n<td><p>白屏问题</p></td>\n<td><p>无</p></td>\n<td><p>有</p></td>\n<td><p>无</p></td>\n</tr>\n<tr>\n<td><p>占用服务端资源</p></td>\n<td><p>多</p></td>\n<td><p>少</p></td>\n<td><p>中</p></td>\n</tr>\n<tr>\n<td><p>用户体验</p></td>\n<td><p>差</p></td>\n<td><p>好</p></td>\n<td><p>好</p></td>\n</tr>\n</tbody>\n</table>\n<p>可以看到，同构渲染除了也需要部分服务端资源外，其他方面的表现都非常棒。由于同构渲染方案在首次渲染时和浏览器刷新时仍然需要服务端完成渲染工作，所以也需要部分服务端资源，但相比所有页面跳转都需要服务端完成渲染来说，同构渲染所占用的服务端资源相对少一些。</p>\n<p>另外，对同构渲染最多的误解是，它能够提升<strong>可交互时间</strong>（TTI）。事实是同构渲染仍然需要像 CSR 那样等待 JavaScript 资源加载完成，并且客户端激活完成后，才能响应用户操作。因此，理论上同构渲染无法提升可交互时间。</p>\n<p>同构渲染的“同构”一词的含义是，同样一套代码既可以在服务端运行，也可以在客户端运行。例如，我们用 Vue.js 编写一个组件，该组件既可以在服务端运行，被渲染为 HTML 字符串；也可以在客户端运行，就像普通的 CSR 应用程序一样。我们会在 18.2 节讨论 Vue.js 的组件是如何在服务端被渲染为 HTML 字符串的。</p>\n<h2 id=\"nav_point_182\">18.2　将虚拟 DOM 渲染为 HTML 字符串</h2>\n<p>既然“同构”指的是，同样的代码既能在服务端运行，也能在客户端运行，那么本节我们就讨论如何在服务端将虚拟 DOM 渲染为 HTML 字符串。</p>\n<p>给出如下虚拟节点对象，它用来描述一个普通的 <code>div</code> 标签：</p>\n<pre class=\"code-rows\"><code> const ElementVNode = {\n   type: 'div',\n   props: {\n     id: 'foo'\n   },\n   children: [\n     { type: 'p', children: 'hello' }\n   ]\n }\n</code></pre>\n<p>为了将虚拟节点 <code>ElementVNode</code> 渲染为字符串，我们需要实现 <code>renderElementVNode</code> 函数。该函数接收用来描述普通标签的虚拟节点作为参数，并返回渲染后的 HTML 字符串：</p>\n<pre class=\"code-rows\"><code> function renderElementVNode(vnode) {\n   // 返回渲染后的结果，即 HTML 字符串\n }\n</code></pre>\n<p>在不考虑任何边界条件的情况下，实现 <code>renderElementVNode</code> 非常简单，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function renderElementVNode(vnode) {\n   // 取出标签名称 tag 和标签属性 props，以及标签的子节点\n   const { type: tag, props, children } = vnode\n   // 开始标签的头部\n   let ret = `&lt;$`\n   // 处理标签属性\n   if (props) {\n     for (const k in props) {\n       // 以 key=\"value\" 的形式拼接字符串\n       ret += ` $=\"$\"`\n     }\n   }\n   // 开始标签的闭合\n   ret += `&gt;`\n<p>// 处理子节点<br />\n// 如果子节点的类型是字符串，则是文本内容，直接拼接<br />\nif (typeof children === ‘string’) {<br />\nret += children<br />\n} else if (Array.isArray(children)) {<br />\n// 如果子节点的类型是数组，则递归地调用 renderElementVNode 完成渲染<br />\nchildren.forEach(child =&gt; {<br />\nret += renderElementVNode(child)<br />\n})<br />\n}</p>\n<p>// 结束标签<br />\nret += <code>&amp;lt;/$&amp;gt;</code></p>\n<p>// 返回拼接好的 HTML 字符串<br />\nreturn ret<br />\n}<br />\n</code></pre></p>\n<p>接着，我们可以调用 <code>renderElementVNode</code> 函数完成对 <code>ElementVNode</code> 的渲染：</p>\n<pre class=\"code-rows\"><code> console.log(renderElementVNode(ElementVNode)) // &lt;div id=\"foo\"&gt;&lt;p&gt;hello&lt;/p&gt;&lt;/div&gt;\n</code></pre>\n<p>可以看到，输出结果是我们所期望的 HTML 字符串。实际上，将一个普通标签类型的虚拟节点渲染为 HTML 字符串，本质上是字符串的拼接。不过，上面给出的 <code>renderElementVNode</code> 函数的实现仅仅用来展示将虚拟 DOM 渲染为 HTML 字符串的核心原理，并不满足生产要求，因为它存在以下几点缺陷。</p>\n<ul>\n<li><code>renderElementVNode</code> 函数在渲染标签类型的虚拟节点时，还需要考虑该节点是否是自闭合标签。</li>\n<li>对于属性（<code>props</code>）的处理会比较复杂，要考虑属性名称是否合法，还要对属性值进行 HTML 转义。</li>\n<li>子节点的类型多种多样，可能是任意类型的虚拟节点，如 <code>Fragment</code>、组件、函数式组件、文本等，这些都需要处理。</li>\n<li>标签的文本子节点也需要进行 HTML 转义。</li>\n</ul>\n<p>上述这些问题都属于边界条件，接下来我们逐个处理。首先处理自闭合标签，它的术语叫作 void element，它的完整列表如下：</p>\n<pre class=\"code-rows\"><code> const VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr'\n</code></pre>\n<p>可以在 WHATWG 的规范中查看完整的 void element。</p>\n<p>对于 void element，由于它无须闭合标签，所以在为此类标签生成 HTML 字符串时，无须为其生成对应的闭合标签，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> const VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr'.split(',')\n<p>function renderElementVNode2(vnode) {<br />\nconst { type: tag, props, children } = vnode<br />\n// 判断是否是 void element<br />\nconst isVoidElement = VOID_TAGS.includes(tag)</p>\n<p>let ret = <code>&amp;lt;$</code></p>\n<p>if (props) {<br />\nfor (const k in props) {<br />\nret += <code> $=&quot;$&quot;</code><br />\n}<br />\n}</p>\n<p>// 如果是 void element，则自闭合<br />\nret += isVoidElement ? <code>/&amp;gt;</code> : <code>&amp;gt;</code><br />\n// 如果是 void element，则直接返回结果，无须处理 children，因为 void element 没有 children<br />\nif (isVoidElement) return ret</p>\n<p>if (typeof children === ‘string’) {<br />\nret += children<br />\n} else {<br />\nchildren.forEach(child =&gt; {<br />\nret += renderElementVNode2(child)<br />\n})<br />\n}</p>\n<p>ret += <code>&amp;lt;/$&amp;gt;</code></p>\n<p>return ret<br />\n}<br />\n</code></pre></p>\n<p>在上面这段代码中，我们增加了对 void element 的处理。需要注意的一点是，由于自闭合标签没有子节点，所以可以跳过对 <code>children</code> 的处理。</p>\n<p>接下来，我们需要更严谨地处理 HTML 属性。处理属性需要考虑多个方面，首先是对 boolean attribute 的处理。所谓 boolean attribute，并不是说这类属性的值是布尔类型，而是指，如果这类指令存在，则代表 <code>true</code>，否则代表 <code>false</code>。例如 <code>&lt;input/&gt;</code> 标签的 <code>checked</code> 属性和 <code>disabled</code> 属性：</p>\n<pre class=\"code-rows\"><code> &lt;!-- 选中的 checkbox --&gt;\n &lt;input type=\"checkbox\" checked /&gt;\n &lt;!-- 未选中的 checkbox --&gt;\n &lt;input type=\"checkbox\" /&gt;\n</code></pre>\n<p>从上面这段 HTML 代码示例中可以看出，当渲染 boolean attribute 时，通常无须渲染它的属性值。</p>\n<p>关于属性，另外一点需要考虑的是安全问题。WHATWG 规范的 13.1.2.3 节中明确定义了属性名称的组成。</p>\n<p>属性名称必须由一个或多个<strong>非</strong>以下字符组成。</p>\n<ul>\n<li>控制字符集（control character）的码点范围是：<code>[0x01, 0x1f]</code> 和 <code>[0x7f, 0x9f]</code>。</li>\n<li>U+0020 (SPACE)、U+0022 (\")、U+0027 (')、U+003E (&gt;)、U+002F (/) 以及 U+003D (=)。</li>\n<li><code>noncharacters</code>，这里的 <code>noncharacters</code> 代表 Unicode 永久保留的码点，这些码点在 Unicode 内部使用，它的取值范围是：<code>[0xFDD0, 0xFDEF]</code>，还包括：<code>0xFFFE</code>、<code>0xFFFF</code>、<code>0x1FFFE</code>、<code>0x1FFFF</code>、<code>0x2FFFE</code>、<code>0x2FFFF</code>、<code>0x3FFFE</code>、<code>0x3FFFF</code>、<code>0x4FFFE</code>、<code>0x4FFFF</code>、<code>0x5FFFE</code>、<code>0x5FFFF</code>、<code>0x6FFFE</code>、<code>0x6FFFF</code>、<code>0x7FFFE</code>、<code>0x7FFFF</code>、<code>0x8FFFE</code>、<code>0x8FFFF</code>、<code>0x9FFFE</code>、<code>0x9FFFF</code>、<code>0xAFFFE</code>、<code>0xAFFFF</code>、<code>0xBFFFE</code>、<code>0xBFFFF</code>、<code>0xCFFFE</code>、<code>0xCFFFF</code>、<code>0xDFFFE</code>、<code>0xDFFFF</code>、<code>0xEFFFE</code>、<code>0xEFFFF</code>、<code>0xFFFFE</code>、<code>0xFFFFF</code>、<code>0x10FFFE</code>、<code>0x10FFFF</code>。</li>\n</ul>\n<p>考虑到 Vue.js 的模板编译器在编译过程中已经对 <code>noncharacters</code> 以及控制字符集进行了处理，所以我们只需要小范围处理即可，任何不满足上述条件的属性名称都是不安全且不合法的。</p>\n<p>另外，在虚拟节点中的 <code>props</code> 对象中，通常会包含仅用于组件运行时逻辑的相关属性。例如，<code>key</code> 属性仅用于虚拟 DOM 的 Diff 算法，<code>ref</code> 属性仅用于实现 template <code>ref</code> 的功能等。在进行服务端渲染时，应该忽略这些属性。除此之外，服务端渲染也无须考虑事件绑定。因此，也应该忽略 <code>props</code> 对象中的事件处理函数。</p>\n<p>更加严谨的属性处理方案如下：</p>\n<pre class=\"code-rows\"><code> function renderElementVNode(vnode) {\n   const { type: tag, props, children } = vnode\n   const isVoidElement = VOID_TAGS.includes(tag)\n<p>let ret = <code>&amp;lt;$</code></p>\n<p>if (props) {<br />\n// 调用 renderAttrs 函数进行严谨处理<br />\nret += renderAttrs(props)<br />\n}</p>\n<p>ret += isVoidElement ? <code>/&amp;gt;</code> : <code>&amp;gt;</code></p>\n<p>if (isVoidElement) return ret</p>\n<p>if (typeof children === ‘string’) {<br />\nret += children<br />\n} else {<br />\nchildren.forEach(child =&gt; {<br />\nret += renderElementVNode(child)<br />\n})<br />\n}</p>\n<p>ret += <code>&amp;lt;/$&amp;gt;</code></p>\n<p>return ret<br />\n}<br />\n</code></pre></p>\n<p>可以看到，在 <code>renderElementVNode</code> 函数内，我们调用了 <code>renderAttrs</code> 函数来实现对 <code>props</code> 的处理。<code>renderAttrs</code> 函数的具体实现如下：</p>\n<pre class=\"code-rows\"><code> // 应该忽略的属性\n const shouldIgnoreProp = ['key', 'ref']\n<p>function renderAttrs(props) {<br />\nlet ret = ‘’<br />\nfor (const key in props) {<br />\nif (<br />\n// 检测属性名称，如果是事件或应该被忽略的属性，则忽略它<br />\nshouldIgnoreProp.includes(key) ||<br />\n/^on[^a-z]/.test(key)<br />\n) {<br />\ncontinue<br />\n}<br />\nconst value = props[key]<br />\n// 调用 renderDynamicAttr 完成属性的渲染<br />\nret += renderDynamicAttr(key, value)<br />\n}<br />\nreturn ret<br />\n}<br />\n</code></pre></p>\n<p><code>renderDynamicAttr</code> 函数的实现如下：</p>\n<pre class=\"code-rows\"><code> // 用来判断属性是否是 boolean attribute\n const isBooleanAttr = (key) =&gt;\n (`itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly` +\n   `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +\n   `loop,open,required,reversed,scoped,seamless,` +\n   `checked,muted,multiple,selected`).split(',').includes(key)\n<p>// 用来判断属性名称是否合法且安全<br />\nconst isSSRSafeAttrName = (key) =&gt; !/[&gt;/=&quot;'\\u0009\\u000a\\u000c\\u0020]/.test(key)</p>\n<p>function renderDynamicAttr(key, value) {<br />\nif (isBooleanAttr(key)) {<br />\n// 对于 boolean attribute，如果值为 false，则什么都不需要渲染，否则只需要渲染 key 即可<br />\nreturn value === false ? <code>: ` $`    } else if (isSSRSafeAttrName(key)) {      // 对于其他安全的属性，执行完整的渲染，      // 注意：对于属性值，我们需要对它执行 HTML 转义操作      return value === '' ? ` $` : ` $=&quot;$&quot;`    } else {      // 跳过不安全的属性，并打印警告信息      console.warn(        `[@vue/server-renderer] Skipped rendering unsafe attribute name: $`      )      return</code><br />\n}<br />\n}<br />\n</code></pre></p>\n<p>这样我们就实现了对普通元素类型的虚拟节点的渲染。实际上，在 Vue.js 中，由于 <code>class</code> 和 <code>style</code> 这两个属性可以使用多种合法的数据结构来表示，例如 <code>class</code> 的值可以是字符串、对象、数组，所以理论上我们还需要考虑这些情况。不过原理都是相通的，对于使用不同数据结构表示的 <code>class</code> 或 <code>style</code>，我们只需要将不同类型的数据结构序列化成字符串表示即可。</p>\n<p>另外，观察上面代码中的 <code>renderDynamicAttr</code> 函数的实现能够发现，在处理属性值时，我们调用了 <code>escapeHtml</code> 对其进行转义处理，这对于防御 XSS 攻击至关重要。HTML 转义指的是将特殊字符转换为对应的 HTML 实体。其转换规则很简单。</p>\n<ul>\n<li>如果该字符串作为普通内容被拼接，则应该对以下字符进行转义。<ul>\n<li>将字符 <code>&amp;</code> 转义为实体 <code>&amp;amp;</code>。</li>\n<li>将字符 <code>&lt;</code> 转义为实体 <code>&amp;lt;</code>。</li>\n<li>将字符 <code>&gt;</code> 转义为实体 <code>&amp;gt;</code>。</li>\n</ul>\n</li>\n<li>如果该字符串作为属性值被拼接，那么除了上述三个字符应该被转义之外，还应该转义下面两个字符。<ul>\n<li>将字符 <code>\"</code> 转义为实体 <code>&amp;quot;</code>。</li>\n<li>将字符 <code>'</code> 转义为实体 <code>&amp;#39;</code>。</li>\n</ul>\n</li>\n</ul>\n<p>具体实现如下：</p>\n<pre class=\"code-rows\"><code> const escapeRE = /[\"'&amp;&lt;&gt;]/\n function escapeHtml(string) {\n   const str = '' + string\n   const match = escapeRE.exec(str)\n<p>if (!match) {<br />\nreturn str<br />\n}</p>\n<p>let html = ‘’<br />\nlet escaped<br />\nlet index<br />\nlet lastIndex = 0<br />\nfor (index = match.index; index &lt; str.length; index++) {<br />\nswitch (str.charCodeAt(index)) {<br />\ncase 34: // &quot;<br />\nescaped = ‘&amp;quot;’<br />\nbreak<br />\ncase 38: // &amp;<br />\nescaped = ‘&amp;amp;’<br />\nbreak<br />\ncase 39: // ’<br />\nescaped = ‘&amp;#39;’<br />\nbreak<br />\ncase 60: // &lt;<br />\nescaped = ‘&amp;lt;’<br />\nbreak<br />\ncase 62: // &gt;<br />\nescaped = ‘&amp;gt;’<br />\nbreak<br />\ndefault:<br />\ncontinue<br />\n}</p>\n<pre><code> if (lastIndex !== index) {\n   html += str.substring(lastIndex, index)\n }\n\n lastIndex = index + 1\n html += escaped\n</code></pre>\n<p>}</p>\n<p>return lastIndex !== index ? html + str.substring(lastIndex, index) : html<br />\n}<br />\n</code></pre></p>\n<p>原理很简单，只需要在给定字符串中查找需要转义的字符，然后将其替换为对应的 HTML 实体即可。</p>\n<h2 id=\"nav_point_183\">18.3　将组件渲染为 HTML 字符串</h2>\n<p>在 18.2 节中，我们讨论了如何将普通标签类型的虚拟节点渲染为 HTML 字符串。本节，我们将在此基础上，讨论如何将组件类型的虚拟节点渲染为 HTML 字符串。</p>\n<p>假设我们有如下组件，以及用来描述组件的虚拟节点：</p>\n<pre class=\"code-rows\"><code> // 组件\n const MyComponent = {\n   setup() {\n     return () =&gt; {\n       // 该组件渲染一个 div 标签\n       return {\n         type: 'div',\n         children: 'hello'\n       }\n     }\n   }\n }\n<p>// 用来描述组件的 VNode 对象<br />\nconst CompVNode = {<br />\ntype: MyComponent,<br />\n}<br />\n</code></pre></p>\n<p>我们将实现 <code>renderComponentVNode</code> 函数，并用它把组件类型的虚拟节点渲染为 HTML 字符串：</p>\n<pre class=\"code-rows\"><code> const html = renderComponentVNode(CompVNode)\n console.log(html) // 输出：&lt;div&gt;hello&lt;/div&gt;\n</code></pre>\n<p>实际上，把组件渲染为 HTML 字符串与把普通标签节点渲染为 HTML 字符串并没有本质区别。我们知道，组件的渲染函数用来描述组件要渲染的内容，它的返回值是虚拟 DOM。所以，我们只需要执行组件的渲染函数取得对应的虚拟 DOM，再将该虚拟 DOM 渲染为 HTML 字符串，并作为 <code>renderComponentVNode</code> 函数的返回值即可。最基本的实现如下：</p>\n<pre class=\"code-rows\"><code> function renderComponentVNode(vnode) {\n   // 获取 setup 组件选项\n   let { type: { setup } } = vnode\n   // 执行 setup 函数得到渲染函数 render\n   const render = setup()\n   // 执行渲染函数得到 subTree，即组件要渲染的内容\n   const subTree = render()\n   // 调用 renderElementVNode 完成渲染，并返回其结果\n   return renderElementVNode(subTree)\n }\n</code></pre>\n<p>上面这段代码的逻辑非常简单，它仅仅展示了渲染组件的最基本原理，仍然存在很多问题。</p>\n<ul>\n<li><code>subTree</code> 本身可能是任意类型的虚拟节点，包括组件类型。因此，我们不能直接使用 <code>renderElementVNode</code> 来渲染它。</li>\n<li>执行 <code>setup</code> 函数时，也应该提供 <code>setupContext</code> 对象。而执行渲染函数 <code>render</code> 时，也应该将其 <code>this</code> 指向 <code>renderContext</code> 对象。实际上，在组件的初始化和渲染方面，其完整流程与第 13 章讲解的客户端的渲染流程一致。例如，也需要初始化 <code>data</code>，也需要得到 <code>setup</code> 函数的执行结果，并检查 <code>setup</code> 函数的返回值是函数还是 <code>setupState</code> 等。</li>\n</ul>\n<p>对于第一个问题，我们可以通过封装通用函数来解决，如下面 <code>renderVNode</code> 函数的代码所示：</p>\n<pre class=\"code-rows\"><code> function renderVNode(vnode) {\n   const type = typeof vnode.type\n   if (type === 'string') {\n     return renderElementVNode(vnode)\n   } else if (type === 'object' || type === 'function') {\n     return renderComponentVNode(vnode)\n   } else if (vnode.type === Text) {\n     // 处理文本...\n   } else if (vnode.type === Fragment) {\n     // 处理片段...\n   } else {\n     // 其他 VNode 类型\n   }\n }\n</code></pre>\n<p>有了 <code>renderVNode</code> 后，我们就可以在 <code>renderComponentVNode</code> 中使用它来渲染 <code>subTree</code> 了：</p>\n<pre class=\"code-rows\"><code> function renderComponentVNode(vnode) {\n   let { type: { setup } } = vnode\n   const render = setup()\n   const subTree = render()\n   // 使用 renderVNode 完成对 subTree 的渲染\n   return renderVNode(subTree)\n }\n</code></pre>\n<p>第二个问题则涉及组件的初始化流程。我们先回顾一下组件在客户端渲染时的整体流程，如图 18-4 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00659.jpeg\" alt=\"\" width=\"42%\" style=\"width: 42%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 18-4　客户端渲染时，组件的初始化流程</strong></p>\n<p>在进行服务端渲染时，组件的初始化流程与客户端渲染时组件的初始化流程基本一致，但有两个重要的区别。</p>\n<ul>\n<li>服务端渲染的是应用的当前快照，它不存在数据变更后重新渲染的情况。因此，所有数据在服务端都无须是响应式的。利用这一点，我们可以减少服务端渲染过程中创建响应式数据对象的开销。</li>\n<li>服务端渲染只需要获取组件要渲染的 <code>subTree</code> 即可，无须调用渲染器完成真实 DOM 的创建。因此，在服务端渲染时，可以忽略“设置 <code>render effect</code> 完成渲染”这一步。</li>\n</ul>\n<p>图 18-5 给出了服务端渲染时初始化组件的流程。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00660.jpeg\" alt=\"\" width=\"57%\" style=\"width: 57%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 18-5　服务端渲染时，组件的初始化流程</strong></p>\n<p>可以看到，只需要对客户端初始化组件的逻辑稍作调整，即可实现组件在服务端的渲染。另外，由于组件在服务端渲染时，不需要渲染真实 DOM 元素，所以无须创建并执行 <code>render effect</code>。这意味着，组件的 <code>beforeMount</code> 以及 <code>mounted</code> 钩子不会被触发。而且，由于服务端渲染不存在数据变更后的重新渲染逻辑，所以 <code>beforeUpdate</code> 和 <code>updated</code> 钩子也不会在服务端执行。完整的实现如下：</p>\n<pre class=\"code-rows\"><code> function renderComponentVNode(vnode) {\n   const isFunctional = typeof vnode.type === 'function'\n   let componentOptions = vnode.type\n   if (isFunctional) {\n     componentOptions = {\n       render: vnode.type,\n       props: vnode.type.props\n     }\n   }\n   let { render, data, setup, beforeCreate, created, props: propsOption } = componentOptions\n<p>beforeCreate &amp;&amp; beforeCreate()</p>\n<p>// 无须使用 reactive() 创建 data 的响应式版本<br />\nconst state = data ? data() : null<br />\nconst [props, attrs] = resolveProps(propsOption, vnode.props)</p>\n<p>const slots = vnode.children || {}</p>\n<p>const instance = {<br />\nstate,<br />\nprops, // props 无须 shallowReactive<br />\nisMounted: false,<br />\nsubTree: null,<br />\nslots,<br />\nmounted: [],<br />\nkeepAliveCtx: null<br />\n}</p>\n<p>function emit(event, …payload) {<br />\nconst eventName = <code>on$</code><br />\nconst handler = instance.props[eventName]<br />\nif (handler) {<br />\nhandler(…payload)<br />\n} else {<br />\nconsole.error(‘事件不存在’)<br />\n}<br />\n}</p>\n<p>// setup<br />\nlet setupState = null<br />\nif (setup) {<br />\nconst setupContext = { attrs, emit, slots }<br />\nconst prevInstance = setCurrentInstance(instance)<br />\nconst setupResult = setup(shallowReadonly(instance.props), setupContext)<br />\nsetCurrentInstance(prevInstance)<br />\nif (typeof setupResult === ‘function’) {<br />\nif (render) console.error(‘setup 函数返回渲染函数，render 选项将被忽略’)<br />\nrender = setupResult<br />\n} else {<br />\nsetupState = setupContext<br />\n}<br />\n}</p>\n<p>vnode.component = instance</p>\n<p>const renderContext = new Proxy(instance, {<br />\nget(t, k, r) {<br />\nconst { state, props, slots } = t</p>\n<pre><code>   if (k === '$slots') return slots\n\n   if (state &amp;amp;&amp;amp; k in state) {\n     return state[k]\n   } else if (k in props) {\n     return props[k]\n   } else if (setupState &amp;amp;&amp;amp; k in setupState) {\n     return setupState[k]\n   } else {\n     console.error('不存在')\n   }\n },\n set (t, k, v, r) {\n   const { state, props } = t\n   if (state &amp;amp;&amp;amp; k in state) {\n     state[k] = v\n   } else if (k in props) {\n     props[k] = v\n   } else if (setupState &amp;amp;&amp;amp; k in setupState) {\n     setupState[k] = v\n   } else {\n     console.error('不存在')\n   }\n }\n</code></pre>\n<p>})</p>\n<p>created &amp;&amp; created.call(renderContext)</p>\n<p>const subTree = render.call(renderContext, renderContext)</p>\n<p>return renderVNode(subTree)<br />\n}<br />\n</code></pre></p>\n<p>观察上面的代码可以发现，该实现与客户端渲染的逻辑基本一致。这段代码与第 13 章给出的关于组件渲染的代码也非常相似，唯一的区别在于，在服务端渲染时，无须使用 <code>reactive</code> 函数为 <code>data</code> 数据创建响应式版本，并且 <code>props</code> 数据也无须是浅响应的。</p>\n<h2 id=\"nav_point_184\">18.4　客户端激活的原理</h2>\n<p>讨论完如何将组件渲染为 HTML 字符串之后，我们再来讨论客户端激活的实现原理。什么是客户端激活呢？我们知道，对于同构渲染来说，组件的代码会在服务端和客户端分别执行一次。在服务端，组件会被渲染为静态的 HTML 字符串，然后发送给浏览器，浏览器再把这段纯静态的 HTML 渲染出来。这意味着，此时页面中已经存在对应的 DOM 元素。同时，该组件还会被打包到一个 JavaScript 文件中，并在客户端被下载到浏览器中解释并执行。这时问题来了，当组件的代码在客户端执行时，会再次创建 DOM 元素吗？答案是“不会”。由于浏览器在渲染了由服务端发送过来的 HTML 字符串之后，页面中已经存在对应的 DOM 元素了，所以组件代码在客户端运行时，不需要再次创建相应的 DOM 元素。但是，组件代码在客户端运行时，仍然需要做两件重要的事：</p>\n<ul>\n<li>在页面中的 DOM 元素与虚拟节点对象之间建立联系；</li>\n<li>为页面中的 DOM 元素添加事件绑定。</li>\n</ul>\n<p>我们知道，一个虚拟节点被挂载之后，为了保证更新程序能正确运行，需要通过该虚拟节点的 <code>vnode.el</code> 属性存储对真实 DOM 对象的引用。而同构渲染也是一样，为了应用程序在后续更新过程中能够正确运行，我们需要在页面中已经存在的 DOM 对象与虚拟节点对象之间建立正确的联系。另外，在服务端渲染的过程中，会忽略虚拟节点中与事件相关的 <code>props</code>。所以，当组件代码在客户端运行时，我们需要将这些事件正确地绑定到元素上。其实，这两个步骤就体现了客户端激活的含义。</p>\n<p>理解了客户端激活的含义后，我们再来看一下它的具体实现。当组件进行纯客户端渲染时，我们通过渲染器的 <code>renderer.render</code> 函数来完成渲染，例如：</p>\n<pre class=\"code-rows\"><code> renderer.render(vnode, container)\n</code></pre>\n<p>而对于同构应用，我们将使用独立的 <code>renderer.hydrate</code> 函数来完成激活：</p>\n<pre class=\"code-rows\"><code> renderer.hydrate(vnode, container)\n</code></pre>\n<p>实际上，我们可以用代码模拟从服务端渲染到客户端激活的整个过程，如下所示：</p>\n<pre class=\"code-rows\"><code> // html 代表由服务端渲染的字符串\n const html = renderComponentVNode(compVNode)\n<p>// 假设客户端已经拿到了由服务端渲染的字符串<br />\n// 获取挂载点<br />\nconst container = document.querySelector(‘#app’)<br />\n// 设置挂载点的 innerHTML，模拟由服务端渲染的内容<br />\ncontainer.innerHTML = html</p>\n<p>// 接着调用 hydrate 函数完成激活<br />\nrenderer.hydrate(compVNode, container)<br />\n</code></pre></p>\n<p>其中 <code>CompVNode</code> 的代码如下：</p>\n<pre class=\"code-rows\"><code> const MyComponent = {\n   name: 'App',\n   setup() {\n     const str = ref('foo')\n<pre><code> return () =&amp;gt; {\n   return {\n     type: 'div',\n     children: [\n       {\n         type: 'span',\n         children: str.value,\n         props: {\n           onClick: () =&amp;gt; {\n             str.value = 'bar'\n           }\n         }\n       },\n       { type: 'span', children: 'baz' }\n     ]\n   }\n }\n</code></pre>\n<p>}<br />\n}</p>\n<p>const CompVNode = {<br />\ntype: MyComponent,<br />\n}<br />\n</code></pre></p>\n<p>接下来，我们着手实现 <code>renderer.hydrate</code> 函数。与 <code>renderer.render</code> 函数一样，<code>renderer.hydrate</code> 函数也是渲染器的一部分，因此它也会作为 <code>createRenderer</code> 函数的返回值，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function createRenderer(options) {\n   function hydrate(node, vnode) {\n     // ...\n   }\n<p>return {<br />\nrender,<br />\n// 作为 createRenderer 函数的返回值<br />\nhydrate<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>这样，我们就可以通过 <code>renderer.hydrate</code> 函数来完成客户端激活了。在具体实现之前，我们先来看一下页面中已经存在的真实 DOM 元素与虚拟 DOM 对象之间的关系。图 18-6 给出了上面代码中 <code>MyComponent</code> 组件所渲染的真实 DOM 和它所渲染的虚拟 DOM 对象之间的关系。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00661.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 18-6　真实 DOM 与虚拟 DOM 之间的关系</strong></p>\n<p>由图 18-6 可知，真实 DOM 元素与虚拟 DOM 对象都是树型结构，并且节点之间存在一一对应的关系。因此，我们可以认为它们是“同构”的。而激活的原理就是基于这一事实，递归地在真实 DOM 元素与虚拟 DOM 节点之间建立关系。另外，在虚拟 DOM 中并不存在与容器元素（或挂载点）对应的节点。因此，在激活的时候，应该从容器元素的第一个子节点开始，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function hydrate(vnode, container) {\n   // 从容器元素的第一个子节点开始\n   hydrateNode(container.firstChild, vnode)\n }\n</code></pre>\n<p>其中，<code>hydrateNode</code> 函数接收两个参数，分别是真实 DOM 元素和虚拟 DOM 元素。<code>hydrateNode</code> 函数的具体实现如下：</p>\n<pre class=\"code-rows\"><code> function hydrateNode(node, vnode) {\n   const { type } = vnode\n   // 1. 让 vnode.el 引用真实 DOM\n   vnode.el = node\n<p>// 2. 检查虚拟 DOM 的类型，如果是组件，则调用 mountComponent 函数完成激活<br />\nif (typeof type === ‘object’) {<br />\nmountComponent(vnode, container, null)<br />\n} else if (typeof type === ‘string’) {<br />\n// 3. 检查真实 DOM 的类型与虚拟 DOM 的类型是否匹配<br />\nif (node.nodeType !== 1) {<br />\nconsole.error(‘mismatch’)<br />\nconsole.error(‘服务端渲染的真实 DOM 节点是：’, node)<br />\nconsole.error(‘客户端渲染的虚拟 DOM 节点是：’, vnode)<br />\n} else {<br />\n// 4. 如果是普通元素，则调用 hydrateElement 完成激活<br />\nhydrateElement(node, vnode)<br />\n}<br />\n}</p>\n<p>// 5. 重要：hydrateNode 函数需要返回当前节点的下一个兄弟节点，以便继续进行后续的激活操作<br />\nreturn node.nextSibling<br />\n}<br />\n</code></pre></p>\n<p><code>hydrateNode</code> 函数的关键点比较多。首先，要在真实 DOM 元素与虚拟 DOM 元素之间建立联系，即 <code>vnode.el = node</code>。这样才能保证后续更新操作正常进行。其次，我们需要检测虚拟 DOM 的类型，并据此判断应该执行怎样的激活操作。在上面的代码中，我们展示了对组件和普通元素类型的虚拟节点的处理。可以看到，在激活普通元素类型的节点时，我们检查真实 DOM 元素的类型与虚拟 DOM 的类型是否相同，如果不同，则需要打印 <code>mismatch</code> 错误，即客户端渲染的节点与服务端渲染的节点不匹配。同时，为了能够让用户快速定位问题节点，保证开发体验，我们最好将客户端渲染的虚拟节点与服务端渲染的真实 DOM 节点都打印出来，供用户参考。对于组件类型节点的激活操作，则可以直接通过 <code>mountComponent</code> 函数来完成。对于普通元素的激活操作，则可以通过 <code>hydrateElement</code> 函数来完成。最后，<code>hydrateNode</code> 函数需要返回当前激活节点的下一个兄弟节点，以便进行后续的激活操作。<code>hydrateNode</code> 函数的返回值非常重要，它的用途体现在 <code>hydrateElement</code> 函数内，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> // 用来激活普通元素类型的节点\n function hydrateElement(el, vnode) {\n   // 1. 为 DOM 元素添加事件\n   if (vnode.props) {\n     for (const key in vnode.props) {\n       // 只有事件类型的 props 需要处理\n       if (/^on/.test(key)) {\n         patchProps(el, key, null, vnode.props[key])\n       }\n     }\n   }\n   // 递归地激活子节点\n   if (Array.isArray(vnode.children)) {\n     // 从第一个子节点开始\n     let nextNode = el.firstChild\n     const len = vnode.children.length\n     for (let i = 0; i &lt; len; i++) {\n       // 激活子节点，注意，每当激活一个子节点，hydrateNode 函数都会返回当前子节点的下一个兄弟节点，\n       // 于是可以进行后续的激活了\n       nextNode = hydrateNode(nextNode, vnode.children[i])\n     }\n   }\n }\n</code></pre>\n<p><code>hydrateElement</code> 函数有两个关键点。</p>\n<ul>\n<li>因为服务端渲染是忽略事件的，浏览器只是渲染了静态的 HTML 而已，所以激活 DOM 元素的操作之一就是为其添加事件处理程序。</li>\n<li>递归地激活当前元素的子节点，从第一个子节点 <code>el.firstChild</code> 开始，递归地调用 <code>hydrateNode</code> 函数完成激活。注意这里的小技巧，<code>hydrateNode</code> 函数会返回当前节点的下一个兄弟节点，利用这个特点即可完成所有子节点的处理。</li>\n</ul>\n<p>对于组件的激活，我们还需要针对性地处理 <code>mountComponent</code> 函数。<strong>由于服务端渲染的页面中已经存在真实 DOM 元素，所以当调用</strong> <code>mountComponent</code> <strong>函数进行组件的挂载时，无须再次创建真实 DOM 元素</strong>。基于此，我们需要对 <code>mountComponent</code> 函数做一些调整，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function mountComponent(vnode, container, anchor) {\n   // 省略部分代码\n<p>instance.update = effect(() =&gt; {<br />\nconst subTree = render.call(renderContext, renderContext)<br />\nif (!instance.isMounted) {<br />\nbeforeMount &amp;&amp; beforeMount.call(renderContext)<br />\n// 如果 vnode.el 存在，则意味着要执行激活<br />\nif (vnode.el) {<br />\n// 直接调用 hydrateNode 完成激活<br />\nhydrateNode(vnode.el, subTree)<br />\n} else {<br />\n// 正常挂载<br />\npatch(null, subTree, container, anchor)<br />\n}<br />\ninstance.isMounted = true<br />\nmounted &amp;&amp; mounted.call(renderContext)<br />\ninstance.mounted &amp;&amp; instance.mounted.forEach(hook =&gt; hook.call(renderContext))<br />\n} else {<br />\nbeforeUpdate &amp;&amp; beforeUpdate.call(renderContext)<br />\npatch(instance.subTree, subTree, container, anchor)<br />\nupdated &amp;&amp; updated.call(renderContext)<br />\n}<br />\ninstance.subTree = subTree<br />\n}, {<br />\nscheduler: queueJob<br />\n})<br />\n}<br />\n</code></pre></p>\n<p>可以看到，唯一需要调整的地方就是组件的渲染副作用，即 <code>render effect</code>。还记得 <code>hydrateNode</code> 函数所做的第一件事是什么吗？是在真实 DOM 与虚拟 DOM 之间建立联系，即 <code>vnode.el = node</code>。所以，当渲染副作用执行挂载操作时，我们优先检查虚拟节点的 <code>vnode.el</code> 属性是否已经存在，如果存在，则意味着无须进行全新的挂载，只需要进行激活操作即可，否则仍然按照之前的逻辑进行全新的挂载。最后一个关键点是，组件的激活操作需要在真实 DOM 与 <code>subTree</code> 之间进行。</p>\n<h2 id=\"nav_point_185\">18.5　编写同构的代码</h2>\n<p>正如我们在 18.1 节中介绍的那样，“同构”一词指的是一份代码既在服务端运行，又在客户端运行。因此，在编写组件代码时，应该额外注意因代码运行环境的不同所导致的差异。</p>\n<h3 id=\"nav_point_186\">18.5.1　组件的生命周期</h3>\n<p>我们知道，当组件的代码在服务端运行时，由于不会对组件进行真正的挂载操作，即不会把虚拟 DOM 渲染为真实 DOM 元素，所以组件的 <code>beforeMount</code> 与 <code>mounted</code> 这两个钩子函数不会执行。又因为服务端渲染的是应用的快照，所以不存在数据变化后的重新渲染，因此，组件的 <code>beforeUpdate</code> 与 <code>updated</code> 这两个钩子函数也不会执行。另外，在服务端渲染时，也不会发生组件被卸载的情况，所以组件的 <code>beforeUnmount</code> 与 <code>unmounted</code> 这两个钩子函数也不会执行。实际上，只有 <code>beforeCreate</code> 与 <code>created</code> 这两个钩子函数会在服务端执行，所以当你编写组件代码时需要额外注意。如下是一段常见的问题代码：</p>\n<pre class=\"code-rows\"><code> &lt;script&gt;\n export default {\n   created() {\n     this.timer = setInterval(() =&gt; {\n       // 做一些事情\n     }, 1000)\n   },\n   beforeUnmount() {\n     // 清除定时器\n     clearInterval(this.timer)\n   }\n }\n &lt;/script&gt;\n</code></pre>\n<p>观察上面这段组件代码，我们在 <code>created</code> 钩子函数中设置了一个定时器，并尝试在组件被卸载之前将其清除，即在 <code>beforeUnmount</code> 钩子函数执行时将其清除。如果在客户端运行这段代码，并不会产生任何问题；但如果在服务端运行，则会造成内存泄漏。因为 <code>beforeUnmount</code> 钩子函数不会在服务端运行，所以这个定时器将永远不会被清除。</p>\n<p>实际上，在 <code>created</code> 钩子函数中设置定时器对于服务端渲染没有任何意义。这是因为服务端渲染的是应用程序的快照，所谓快照，指的是在当前数据状态下页面应该呈现的内容。所以，在定时器到时，修改数据状态之前，应用程序的快照已经渲染完毕了。所以我们说，在服务端渲染时，定时器内的代码没有任何意义。遇到这类问题时，我们通常有两个解决方案：</p>\n<ul>\n<li>方案一：将创建定时器的代码移动到 <code>mounted</code> 钩子中，即只在客户端执行定时器；</li>\n<li>方案二：使用环境变量包裹这段代码，让其不在服务端运行。</li>\n</ul>\n<p>方案一应该很好理解，而方案二依赖项目的环境变量。例如，在通过 webpack 或 Vite 等构建工具搭建的同构项目中，通常带有这种环境变量。以 Vite 为例，我们可以使用 <code>import.meta.env.SSR</code> 来判断当前代码的运行环境：</p>\n<pre class=\"code-rows\"><code> &lt;script&gt;\n export default {\n   created() {\n     // 只在非服务端渲染时执行，即只在客户端执行\n     if (!import.meta.env.SSR) {\n       this.timer = setInterval(() =&gt; {\n         // 做一些事情\n       }, 1000)\n     }\n   },\n   beforeUnmount() {\n     clearInterval(this.timer)\n   }\n }\n &lt;/script&gt;\n</code></pre>\n<p>可以看到，我们通过 <code>import.meta.env.SSR</code> 来使代码只在特定环境中运行。实际上，构建工具会分别为客户端和服务端输出两个独立的包。构建工具在为客户端打包资源的时候，会在资源中排除被 <code>import.meta.env.SSR</code> 包裹的代码。换句话说，上面的代码中被 <code>!import.meta.env.SSR</code> 包裹的代码只会在客户端包中存在。</p>\n<h3 id=\"nav_point_187\">18.5.2　使用跨平台的 API</h3>\n<p>编写同构代码的另一个关键点是使用跨平台的 API。由于组件的代码既运行于浏览器，又运行于服务器，所以在编写代码的时候要避免使用平台特有的 API。例如，仅在浏览器环境中才存在的 <code>window</code>、<code>document</code> 等对象。然而，有时你不得不使用这些平台特有的 API。这时你可以使用诸如 <code>import.meta.env.SSR</code> 这样的环境变量来做代码守卫：</p>\n<pre class=\"code-rows\"><code> &lt;script&gt;\n if (!import.meta.env.SSR) {\n   // 使用浏览器平台特有的 API\n   window.xxx\n }\n<p>export default {<br />\n// …<br />\n}<br />\n&lt;/script&gt;<br />\n</code></pre></p>\n<p>类似地，Node.js 中特有的 API 也无法在浏览器中运行。因此，为了减轻开发时的心智负担，我们可以选择跨平台的第三方库。例如，使用 Axios 作为网络请求库。</p>\n<h3 id=\"nav_point_188\">18.5.3　只在某一端引入模块</h3>\n<p>通常情况下，我们自己编写的组件的代码是可控的，这时我们可以使用跨平台的 API 来保证代码“同构”。然而，第三方模块的代码非常不可控。假设我们有如下组件：</p>\n<pre class=\"code-rows\"><code> &lt;script&gt;\n import storage from './storage.js'\n export default {\n   // ...\n }\n &lt;/script&gt;\n</code></pre>\n<p>上面这段组件代码本身没有任何问题，但它依赖了 <code>./storage.js</code> 模块。如果该模块中存在非同构的代码，则仍然会发生错误。假设 <code>./storage.js</code> 模块的代码如下：</p>\n<pre class=\"code-rows\"><code> // storage.js\n export const storage = window.localStorage\n</code></pre>\n<p>可以看到，<code>./storage.js</code> 模块中依赖了浏览器环境下特有的 API，即 <code>window.localStorage</code>。因此，当进行服务端渲染时会发生错误。对于这个问题，有两种解决方案，方案一是使用 <code>import.meta.env.SSR</code> 来做代码守卫：</p>\n<pre class=\"code-rows\"><code> // storage.js\n export const storage = !import.meta.env.SSR ? window.localStorage : {}\n</code></pre>\n<p>这样做虽然能解决问题，但是在大多数情况下我们无法修改第三方模块的代码。因此，更多时候我们会采用接下来介绍的方案二来解决问题，即条件引入：</p>\n<pre class=\"code-rows\"><code> &lt;script&gt;\n let storage\n // 只有在非 SSR 下才引入 ./storage.js 模块\n if (!import.meta.env.SSR) {\n   storage = import('./storage.js')\n }\n export default {\n   // ...\n }\n &lt;/script&gt;\n</code></pre>\n<p>上面这段代码是修改后的组件代码。可以看到，我们通过 <code>import.meta.env.SSR</code> 做了代码守卫，实现了特定环境下的模块加载。但是，仅在特定环境下加载模板，就意味着该模板的功能仅在该环境下生效。例如在上面的代码中，<code>./storage.js</code> 模板的代码仅会在客户端生效。也就是说，服务端将会缺失该模块的功能。为了弥补这个缺陷，我们通常需要根据实际情况，再实现一个具有同样功能并且可运行于服务端的模块，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> &lt;script&gt;\n let storage\n if (!import.meta.env.SSR) {\n   // 用于客户端\n   storage = import('./storage.js')\n } else {\n   // 用于服务端\n   storage = import('./storage-server.js')\n }\n export default {\n   // ...\n }\n &lt;/script&gt;\n</code></pre>\n<p>可以看到，我们根据环境的不同，引入不用的模块实现。</p>\n<h3 id=\"nav_point_189\">18.5.4　避免交叉请求引起的状态污染</h3>\n<p>编写同构代码时，额外需要注意的是，避免交叉请求引起的状态污染。在服务端渲染时，我们会为每一个请求创建一个全新的应用实例，例如：</p>\n<pre class=\"code-rows\"><code> import { createSSRApp } from 'vue'\n import { renderToString } from '@vue/server-renderer'\n import App from 'App.vue'\n<p>// 每个请求到来，都会执行一次 render 函数<br />\nasync function render(url, manifest) {<br />\n// 为当前请求创建应用实例<br />\nconst app = createSSRApp(App)</p>\n<p>const ctx = {}<br />\nconst html = await renderToString(app, ctx)</p>\n<p>return html<br />\n}<br />\n</code></pre></p>\n<p>可以看到，每次调用 <code>render</code> 函数进行服务端渲染时，都会为当前请求调用 <code>createSSRApp</code> 函数来创建一个新的应用实例。这是为了避免不同请求共用同一个应用实例所导致的状态污染。</p>\n<p>除了要为每一个请求创建独立的应用实例之外，状态污染的情况还可能发生在单个组件的代码中，如下所示：</p>\n<pre class=\"code-rows\"><code> &lt;script&gt;\n // 模块级别的全局变量\n let count = 0\n<p>export default {<br />\ncreate() {<br />\ncount++<br />\n}<br />\n}<br />\n&lt;/script&gt;<br />\n</code></pre></p>\n<p>如果上面这段组件的代码在浏览器中运行，则不会产生任何问题，因为浏览器与用户是一对一的关系，每一个浏览器都是独立的。但如果这段代码在服务器中运行，情况会有所不同，因为服务器与用户是一对多的关系。当用户 A 发送请求到服务器时，服务器会执行上面这段组件的代码，即执行 <code>count++</code>。接着，用户 B 也发送请求到服务器，服务器再次执行上面这段组件的代码，此时的 <code>count</code> 已经因用户 A 的请求自增了一次，因此对于用户 B 而言，用户 A 的请求会影响到他，于是就会造成请求间的交叉污染。所以，在编写组件代码时，要额外注意组件中出现的全局变量。</p>\n<h3 id=\"nav_point_190\">18.5.5　<code>&lt;ClientOnly&gt;</code> 组件</h3>\n<p>最后，我们再来介绍一个对编写同构代码非常有帮助的组件，即 <code>&lt;ClientOnly&gt;</code> 组件。在日常开发中，我们经常会使用第三方模块。而它们不一定对 SSR 友好，例如：</p>\n<pre class=\"code-rows\"><code> &lt;template&gt;\n   &lt;SsrIncompatibleComp /&gt;\n &lt;/template&gt;\n</code></pre>\n<p>假设 <code>&lt;SsrIncompatibleComp /&gt;</code> 是一个不兼容 SSR 的第三方组件，我们没有办法修改它的源代码，这时应该怎么办呢？这时我们会想，既然这个组件不兼容 SSR，那么能否只在客户端渲染该组件呢？其实是可以的，我们可以自行实现一个 <code>&lt;ClientOnly&gt;</code> 的组件，该组件可以让模板的一部分内容仅在客户端渲染，如下面这段模板所示：</p>\n<pre class=\"code-rows\"><code> &lt;template&gt;\n   &lt;ClientOnly&gt;\n     &lt;SsrIncompatibleComp /&gt;\n   &lt;/ClientOnly&gt;\n &lt;/template&gt;\n</code></pre>\n<p>可以看到，我们使用 <code>&lt;ClientOnly&gt;</code> 组件包裹了不兼容 SSR 的 <code>&lt;SsrIncompatibleComp/&gt;</code> 组件。这样，在服务端渲染时就会忽略该组件，且该组件仅会在客户端被渲染。那么，<code>&lt;ClientOnly&gt;</code> 组件是如何做到这一点的呢？这其实是利用了 CSR 与 SSR 的差异。如下是 <code>&lt;ClientOnly&gt;</code> 组件的实现：</p>\n<pre class=\"code-rows\"><code> import { ref, onMounted, defineComponent } from 'vue'\n<p>export const ClientOnly = defineComponent({<br />\nsetup(_, { slots }) {<br />\n// 标记变量，仅在客户端渲染时为 true<br />\nconst show = ref(false)<br />\n// onMounted 钩子只会在客户端执行<br />\nonMounted(() =&gt; {<br />\nshow.value = true<br />\n})<br />\n// 在服务端什么都不渲染，在客户端才会渲染 &lt;ClientOnly&gt; 组件的插槽内容<br />\nreturn () =&gt; (show.value &amp;&amp; slots.default ? slots.default() : null)<br />\n}<br />\n})<br />\n</code></pre></p>\n<p>可以看到，整体实现非常简单。其原理是利用了 <code>onMounted</code> 钩子只会在客户端执行的特性。我们创建了一个标记变量 <code>show</code>，初始值为 <code>false</code>，并且仅在客户端渲染时将其设置为 <code>true</code>。这意味着，在服务端渲染的时候，<code>&lt;ClientOnly&gt;</code> 组件的插槽内容不会被渲染。而在客户端渲染时，只有等到 <code>mounted</code> 钩子触发后才会渲染 <code>&lt;ClientOnly&gt;</code> 组件的插槽内容。这样就实现了被 <code>&lt;ClientOnly&gt;</code> 组件包裹的内容仅会在客户端被渲染。</p>\n<p>另外，<code>&lt;ClientOnly&gt;</code> 组件并不会导致客户端激活失败。因为在客户端激活的时候，<code>mounted</code> 钩子还没有触发，所以服务端与客户端渲染的内容一致，即什么都不渲染。等到激活完成，且 <code>mounted</code> 钩子触发执行之后，才会在客户端将 <code>&lt;ClientOnly&gt;</code> 组件的插槽内容渲染出来。</p>\n<h2 id=\"nav_point_191\">18.6　总结</h2>\n<p>在本章中，我们首先讨论了 CSR、SSR 和同构渲染的工作机制，以及它们各自的优缺点。具体可以总结为表 18-3。</p>\n<p><strong>表 18-3　CSR 和 SSR 的比较</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>&nbsp;</p></th>\n<th><p>SSR</p></th>\n<th><p>CSR</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>SEO</p></td>\n<td><p>友好</p></td>\n<td><p>不友好</p></td>\n</tr>\n<tr>\n<td><p>白屏问题</p></td>\n<td><p>无</p></td>\n<td><p>有</p></td>\n</tr>\n<tr>\n<td><p>占用服务端资源</p></td>\n<td><p>多</p></td>\n<td><p>少</p></td>\n</tr>\n<tr>\n<td><p>用户体验</p></td>\n<td><p>差</p></td>\n<td><p>好</p></td>\n</tr>\n</tbody>\n</table>\n<p>当我们为应用程序选择渲染架构时，需要结合软件的需求及场景，选择合适的渲染方案。</p>\n<p>接着，我们讨论了 Vue.js 是如何把虚拟节点渲染为字符串的。以普通标签节点为例，在将其渲染为字符串时，要考虑以下内容。</p>\n<ul>\n<li>自闭合标签的处理。对于自闭合标签，无须为其渲染闭合标签部分，也无须处理其子节点。</li>\n<li>属性名称的合法性，以及属性值的转义。</li>\n<li>文本子节点的转义。</li>\n</ul>\n<p>具体的转义规则如下。</p>\n<ul>\n<li>对于普通内容，应该对文本中的以下字符进行转义。<ul>\n<li>将字符 <code>&amp;</code> 转义为实体 <code>&amp;amp;</code>。</li>\n<li>将字符 <code>&lt;</code> 转义为实体 <code>&amp;lt;</code>。</li>\n<li>将字符 <code>&gt;</code> 转义为实体 <code>&amp;gt;</code>。</li>\n</ul>\n</li>\n<li>对于属性值，除了上述三个字符应该转义之外，还应该转义下面两个字符。<ul>\n<li>将字符 <code>\"</code> 转义为实体 <code>&amp;quot;</code>。</li>\n<li>将字符 <code>'</code> 转义为实体 <code>&amp;#39;</code>。</li>\n</ul>\n</li>\n</ul>\n<p>然后，我们讨论了如何将组件渲染为 HTML 字符串。在服务端渲染组件与渲染普通标签并没有本质区别。我们只需要通过执行组件的 <code>render</code> 函数，得到该组件所渲染的 <code>subTree</code> 并将其渲染为 HTML 字符串即可。另外，在渲染组件时，需要考虑以下几点。</p>\n<ul>\n<li>服务端渲染不存在数据变更后的重新渲染，所以无须调用 <code>reactive</code> 函数对 <code>data</code> 等数据进行包装，也无须使用 <code>shallowReactive</code> 函数对 <code>props</code> 数据进行包装。正因如此，我们也无须调用 <code>beforeUpdate</code> 和 <code>updated</code> 钩子。</li>\n<li>服务端渲染时，由于不需要渲染真实 DOM 元素，所以无须调用组件的 <code>beforeMount</code> 和 <code>mounted</code> 钩子。</li>\n</ul>\n<p>之后，我们讨论了客户端激活的原理。在同构渲染过程中，组件的代码会分别在服务端和浏览器中执行一次。在服务端，组件会被渲染为静态的 HTML 字符串，并发送给浏览器。浏览器则会渲染由服务端返回的静态的 HTML 内容，并下载打包在静态资源中的组件代码。当下载完毕后，浏览器会解释并执行该组件代码。当组件代码在客户端执行时，由于页面中已经存在对应的 DOM 元素，所以渲染器并不会执行创建 DOM 元素的逻辑，而是会执行激活操作。激活操作可以总结为两个步骤。</p>\n<ul>\n<li>在虚拟节点与真实 DOM 元素之间建立联系，即 <code>vnode.el = el</code>。这样才能保证后续更新程序正确运行。</li>\n<li>为 DOM 元素添加事件绑定。</li>\n</ul>\n<p>最后，我们讨论了如何编写同构的组件代码。由于组件代码既运行于服务端，也运行于客户端，所以当我们编写组件代码时要额外注意。具体可以总结为以下几点。</p>\n<ul>\n<li>注意组件的生命周期。<code>beforeUpdate</code>、<code>updated</code>、<code>beforeMount</code>、<code>mounted</code>、<code>beforeUnmount</code>、<code>unmounted</code> 等生命周期钩子函数不会在服务端执行。</li>\n<li>使用跨平台的 API。由于组件的代码既要在浏览器中运行，也要在服务器中运行，所以编写组件代码时，要额外注意代码的跨平台性。通常我们在选择第三方库的时候，会选择支持跨平台的库，例如使用 Axios 作为网络请求库。</li>\n<li>特定端的实现。无论在客户端还是在服务端，都应该保证功能的一致性。例如，组件需要读取 cookie 信息。在客户端，我们可以通过 <code>document.cookie</code> 来实现读取；而在服务端，则需要根据请求头来实现读取。所以，很多功能模块需要我们为客户端和服务端分别实现。</li>\n<li>避免交叉请求引起的状态污染。状态污染既可以是应用级的，也可以是模块级的。对于应用，我们应该为每一个请求创建一个独立的应用实例。对于模块，我们应该避免使用模块级的全局变量。这是因为在不做特殊处理的情况下，多个请求会共用模块级的全局变量，造成请求间的交叉污染。</li>\n<li>仅在客户端渲染组件中的部分内容。这需要我们自行封装 <code>&lt;ClientOnly&gt;</code> 组件，被该组件包裹的内容仅在客户端才会被渲染。</li>\n</ul>\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 17 章 编译优化","id":740782},"right":{"article_title":"作者简介","id":740784}},"comments":[{"had_liked":false,"id":393674,"user_name":"kaiyong","can_delete":false,"product_type":"c1","uid":2034440,"ip_address":"广东","ucode":"916AFD00BD609F","user_header":"https://static001.geekbang.org/account/avatar/00/1f/0b/08/2720e9a7.jpg","comment_is_top":false,"comment_ctime":1724552607,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636603,"comment_content":"作者你好，文中的代码块，内容显示有点问题，建议可以的话，把配套学习仓库的 源码 路径发下~","like_count":0},{"had_liked":false,"id":393672,"user_name":"kaiyong","can_delete":false,"product_type":"c1","uid":2034440,"ip_address":"广东","ucode":"916AFD00BD609F","user_header":"https://static001.geekbang.org/account/avatar/00/1f/0b/08/2720e9a7.jpg","comment_is_top":false,"comment_ctime":1724552017,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636603,"comment_content":"文中“图 18-3 给出了同构渲染首次渲染的工作流程”内容描述，与实际所给的图片 18-3 是不是没对应上？","like_count":0}]}