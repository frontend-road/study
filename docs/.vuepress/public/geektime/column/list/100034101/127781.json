{"id":127781,"title":"07 | 编译器前端工具（二）：用Antlr重构脚本语言","content":"<p>上一讲，我带你用Antlr生成了词法分析器和语法分析器，也带你分析了，跟一门成熟的语言相比，在词法规则和语法规则方面要做的一些工作。</p><p>在词法方面，我们参考Java的词法规则文件，形成了一个CommonLexer.g4词法文件。在这个过程中，我们研究了更完善的字符串字面量的词法规则，还讲到要通过规则声明的前后顺序来解决优先级问题，比如关键字的规则一定要在标识符的前面。</p><p>目前来讲，我们已经完善了词法规则，所以今天我们来补充和完善一下语法规则，看一看怎样用最高效的速度，完善语法功能。比如一天之内，我们是否能为某个需要编译技术的项目实现一个可行性原型？</p><p>而且，我还会带你熟悉一下常见语法设计的最佳实践。这样当后面的项目需要编译技术做支撑时，你就会很快上手，做出成绩了！</p><p>接下来，我们先把表达式的语法规则梳理一遍，让它达到成熟语言的级别，然后再把语句梳理一遍，包括前面几乎没有讲过的流程控制语句。最后再升级解释器，用Visitor模式实现对AST的访问，这样我们的代码会更清晰，更容易维护了。</p><p>好了，让我们正式进入课程，先将表达式的语法完善一下吧！</p><h2>完善表达式（Expression）的语法</h2><p>在“<a href=\"https://time.geekbang.org/column/article/126910\">06 | 编译器前端工具（一）：用Antlr生成词法、语法分析器</a>”中，我提到Antlr能自动处理左递归的问题，所以在写表达式时，我们可以大胆地写成左递归的形式，节省时间。</p><!-- [[[read_end]]] --><p>但这样，我们还是要为每个运算写一个规则，逻辑运算写完了要写加法运算，加法运算写完了写乘法运算，这样才能实现对优先级的支持，还是有些麻烦。</p><p>其实，Antlr能进一步地帮助我们。我们可以把所有的运算都用一个语法规则来涵盖，然后用最简洁的方式支持表达式的优先级和结合性。在我建立的PlayScript.g4语法规则文件中，只用了一小段代码就将所有的表达式规则描述完了：</p><pre><code>expression\n    : primary\n    | expression bop='.'\n      ( IDENTIFIER\n      | functionCall\n      | THIS\n      )\n    | expression '[' expression ']'\n    | functionCall\n    | expression postfix=('++' | '--')\n    | prefix=('+'|'-'|'++'|'--') expression\n    | prefix=('~'|'!') expression\n    | expression bop=('*'|'/'|'%') expression  \n    | expression bop=('+'|'-') expression \n    | expression ('&lt;' '&lt;' | '&gt;' '&gt;' '&gt;' | '&gt;' '&gt;') expression\n    | expression bop=('&lt;=' | '&gt;=' | '&gt;' | '&lt;') expression\n    | expression bop=INSTANCEOF typeType\n    | expression bop=('==' | '!=') expression\n    | expression bop='&amp;' expression\n    | expression bop='^' expression\n    | expression bop='|' expression\n    | expression bop='&amp;&amp;' expression\n    | expression bop='||' expression\n    | expression bop='?' expression ':' expression\n    | &lt;assoc=right&gt; expression\n      bop=('=' | '+=' | '-=' | '*=' | '/=' | '&amp;=' | '|=' | '^=' | '&gt;&gt;=' | '&gt;&gt;&gt;=' | '&lt;&lt;=' | '%=')\n      expression\n    ;\n</code></pre><p>这个文件几乎包括了我们需要的所有的表达式规则，包括几乎没提到的点符号表达式、递增和递减表达式、数组表达式、位运算表达式规则等，已经很完善了。</p><p>那么它是怎样支持优先级的呢？原来，优先级是通过右侧不同产生式的顺序决定的。在标准的上下文无关文法中，产生式的顺序是无关的，但在具体的算法中，会按照确定的顺序来尝试各个产生式。</p><p>你不可能一会儿按这个顺序，一会儿按那个顺序。然而，同样的文法，按照不同的顺序来推导的时候，得到的AST可能是不同的。我们需要注意，这一点从文法理论的角度，是无法接受的，但从实践的角度，是可以接受的。比如LL文法和LR文法的概念，是指这个文法在LL算法或LR算法下是工作正常的。又比如我们之前做加法运算的那个文法，就是递归项放在右边的那个，在递归下降算法中会引起结合性的错误，但是如果用LR算法，就完全没有这个问题，生成的AST完全正确。</p><pre><code>additiveExpression\n    :   IntLiteral\n    |   IntLiteral Plus additiveExpression\n    ;\n</code></pre><p>Antlr的这个语法实际上是把产生式的顺序赋予了额外的含义，用来表示优先级，提供给算法。所以，我们可以说这些文法是Antlr文法，因为是与Antlr的算法相匹配的。当然，这只是我起的一个名字，方便你理解，免得你产生困扰。</p><p>我们再来看看Antlr是如何依据这个语法规则实现结合性的。在语法文件中，Antlr对于赋值表达式做了&lt;assoc=right&gt;的属性标注，说明赋值表达式是右结合的。如果不标注，就是左结合的，交给Antlr实现了！</p><p>我们不妨继续猜测一下Antlr内部的实现机制。我们已经分析了保证正确的结合性的算法，比如把递归转化成循环，然后在构造AST时，确定正确的父子节点关系。那么Antlr是不是也采用了这样的思路呢？或者说还有其他方法？你可以去看看Antlr生成的代码验证一下。</p><p>在思考这个问题的同时你会发现，<strong>学习原理是很有用的。</strong>因为当你面对Antlr这样工具时，能够猜出它的实现机制。</p><p>通过这个简化的算法，AST被成功简化，不再有加法节点、乘法节点等各种不同的节点，而是统一为表达式节点。你可能会问了：“如果都是同样的表达式节点，怎么在解析器里把它们区分开呢？怎么知道哪个节点是做加法运算或乘法运算呢？”</p><p>很简单，我们可以查找一下当前节点有没有某个运算符的Token。比如，如果出现了或者运算的Token（“||”），就是做逻辑或运算，而且语法里面的bop=、postfix=、prefix=这些属性，作为某些运算符Token的别名，也会成为表达式节点的属性。通过查询这些属性的值，你可以很快确定当前运算的类型。</p><p>到目前为止，我们彻底完成了表达式的语法工作，可以放心大胆地在脚本语言里使用各种表达式，把精力放在完善各类语句的语法工作上了。</p><h2>完善各类语句（Statement）的语法</h2><p>我先带你分析一下PlayScript.g4文件中语句的规则：</p><pre><code>statement\n    : blockLabel=block\n    | IF parExpression statement (ELSE statement)?\n    | FOR '(' forControl ')' statement\n    | WHILE parExpression statement\n    | DO statement WHILE parExpression ';'\n    | SWITCH parExpression '{' switchBlockStatementGroup* switchLabel* '}'\n    | RETURN expression? ';'\n    | BREAK IDENTIFIER? ';'\n    | SEMI\n    | statementExpression=expression ';'\n    ;\n</code></pre><p>同表达式一样，一个statement规则就可以涵盖各类常用语句，包括if语句、for循环语句、while循环语句、switch语句、return语句等等。表达式后面加一个分号，也是一种语句，叫做表达式语句。</p><p>从语法分析的难度来看，上面这些语句的语法比表达式的语法简单的多，左递归、优先级和结合性的问题这里都没有出现。这也算先难后易，苦尽甘来了吧。实际上，我们后面要设计的很多语法，都没有想象中那么复杂。</p><p>既然我们尝到了一些甜头，不如趁热打铁，深入研究一下if语句和for语句？看看怎么写这些语句的规则？多做这样的训练，再看到这些语句，你的脑海里就能马上反映出它的语法规则。</p><h4>1.研究一下if语句</h4><p>在C和Java等语言中，if语句通常写成下面的样子：</p><pre><code>if (condition)\n  做一件事情;\nelse\n  做另一件事情;\n</code></pre><p>但更多情况下，if和else后面是花括号起止的一个语句块，比如：</p><pre><code>if (condition){\n  做一些事情；\n}\nelse{\n  做另一些事情；\n}\n</code></pre><p>它的语法规则是这样的：</p><pre><code>statement : \n          ...\n          | IF parExpression statement (ELSE statement)? \n          ...\n          ;\nparExpression : '(' expression ')';\n</code></pre><p>我们用了IF和ELSE这两个关键字，也复用了已经定义好的语句规则和表达式规则。你看，语句规则和表达式规则一旦设计完毕，就可以被其他语法规则复用，多么省心！</p><p>但是if语句也有让人不省心的地方，比如会涉及到二义性文法问题。所以，接下来我们就借if语句，分析一下二义性文法这个现象。</p><h4>2.解决二义性文法</h4><p>学计算机语言的时候，提到if语句，会特别提一下嵌套if语句和悬挂else的情况，比如下面这段代码：</p><pre><code>if (a &gt; b)\nif (c &gt; d)\n做一些事情；\nelse\n做另外一些事情；\n</code></pre><p>在上面的代码中，我故意取消了代码的缩进。那么，你能不能看出else是跟哪个if配对的呢？</p><p>一旦你语法规则写得不够好，就很可能形成二义性，也就是用同一个语法规则可以推导出两个不同的句子，或者说生成两个不同的AST。这种文法叫做二义性文法，比如下面这种写法：</p><pre><code>stmt -&gt; if expr stmt\n      | if expr stmt else stmt\n      | other\n</code></pre><p>按照这个语法规则，先采用第一条产生式推导或先采用第二条产生式推导，会得到不同的AST。左边的这棵AST中，else跟第二个if配对；右边的这棵AST中，else跟第一个if配对。</p><p><img src=\"https://static001.geekbang.org/resource/image/58/69/589ae549366701286417475fbc361469.jpg?wh=1142*261\" alt=\"\"></p><p>大多数高级语言在解析这个示例代码时都会产生第一个AST，即else跟最邻近的if配对，也就是下面这段带缩进的代码表达的意思：</p><pre><code>if (a &gt; b)\n  if (c &gt; d)\n    做一些事情；\n  else\n    做另外一些事情；\n</code></pre><p>那么，有没有办法把语法写成没有二义性的呢？当然有了。</p><pre><code>stmt -&gt; fullyMatchedStmt | partlyMatchedStmt\nfullyMatchedStmt -&gt; if expr fullyMatchedStmt else fullyMatchedStmt\n                   | other\npartlyMatchedStmt -&gt; if expr stmt\n                   | if expr fullyMatchedStmt else partlyMatchedStmt\n</code></pre><p>按照上面的语法规则，只有唯一的推导方式，也只能生成唯一的AST：</p><p><img src=\"https://static001.geekbang.org/resource/image/49/08/493e98268dac0e100ca745f6e379fe08.jpg?wh=1142*739\" alt=\"\"></p><p>其中，解析第一个if语句时只能应用partlyMatchedStmt规则，解析第二个if语句时，只能适用fullyMatchedStmt规则。</p><p>这时，我们就知道可以通过改写语法规则来解决二义性文法。至于怎么改写规则，确实不像左递归那样有清晰的套路，但是可以多借鉴成熟的经验。</p><p>再说回我们给Antlr定义的语法，这个语法似乎并不复杂，怎么就能确保不出现二义性问题呢？因为Antlr解析语法时用到的是LL算法。</p><p>LL算法是一个深度优先的算法，所以在解析到第一个statement时，就会建立下一级的if节点，在下一级节点里会把else子句解析掉。如果Antlr不用LL算法，就会产生二义性。这再次验证了我们前面说的那个知识点：文法要经常和解析算法配合。</p><p>分析完if语句，并借它说明了二义性文法之后，我们再针对for语句做一个案例研究。</p><h4>3.研究一下for语句</h4><p>for语句一般写成下面的样子：</p><pre><code>for (int i = 0; i &lt; 10; i++){\n  println(i);\n}\n</code></pre><p>相关的语法规则如下：</p><pre><code>statement : \n         ...\n          | FOR '(' forControl ')' statement\n         ...\n          ;\n\nforControl \n          : forInit? ';' expression? ';' forUpdate=expressionList?\n          ;\n\nforInit \n          : variableDeclarators \n          | expressionList \n          ;\n\nexpressionList\n          : expression (',' expression)*\n          ;\n</code></pre><p>从上面的语法规则中看到，for语句归根到底是由语句、表达式和变量声明构成的。代码中的for语句，解析后形成的AST如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/2a/0a/2aafdb592342d5d694b32a347d4c430a.jpg?wh=1142*614\" alt=\"\"></p><p>熟悉了for语句的语法之后，我想提一下语句块（block）。在if语句和for语句中，会用到它，所以我捎带着把语句块的语法构成写了一下，供你参考：</p><pre><code>block\n    : '{' blockStatements '}'\n    ;\n\nblockStatements\n    : blockStatement*\n    ;\n\nblockStatement\n    : variableDeclarators ';'     //变量声明\n    | statement\n    | functionDeclaration         //函数声明\n    | classDeclaration            //类声明\n    ;\n</code></pre><p>现在，我们已经拥有了一个相当不错的语法体系，除了要放到后面去讲的函数、类有关的语法之外，我们几乎完成了playscript的所有的语法设计工作。接下来，我们再升级一下脚本解释器，让它能够支持更多的语法，同时通过使用Visitor模式，让代码结构更加完善。</p><h2>用Vistor模式升级脚本解释器</h2><p>我们在纯手工编写的脚本语言解释器里，用了一个evaluate()方法自上而下地遍历了整棵树。随着要处理的语法越来越多，这个方法的代码量会越来越大，不便于维护。而Visitor设计模式针对每一种AST节点，都会有一个单独的方法来负责处理，能够让代码更清晰，也更便于维护。</p><p>Antlr能帮我们生成一个Visitor处理模式的框架，我们在命令行输入：</p><pre><code>antlr -visitor PlayScript.g4\n</code></pre><p>-visitor参数告诉Antlr生成下面两个接口和类：</p><pre><code>public interface PlayScriptVisitor&lt;T&gt; extends ParseTreeVisitor&lt;T&gt; {...}\n\npublic class PlayScriptBaseVisitor&lt;T&gt; extends AbstractParseTreeVisitor&lt;T&gt; implements PlayScriptVisitor&lt;T&gt; {...}\n</code></pre><p>在PlayScriptBaseVisitor中，可以看到很多visitXXX()这样的方法，每一种AST节点都对应一个方法，例如：</p><pre><code>@Override public T visitPrimitiveType(PlayScriptParser.PrimitiveTypeContext ctx) {...}\n</code></pre><p>其中泛型&lt; T &gt;指的是访问每个节点时返回的数据的类型。在我们手工编写的版本里，当时只处理整数，所以返回值一律用Integer，现在我们实现的版本要高级一点，AST节点可能返回各种类型的数据，比如：</p><ul>\n<li>浮点型运算的时候，会返回浮点数；</li>\n<li>字符类型运算的时候，会返回字符型数据；</li>\n<li>还可能是程序员自己设计的类型，如某个类的实例。</li>\n</ul><p>所以，我们就让Visitor统一返回Object类型好了，能够适用于各种情况。这样，我们的Visitor就是下面的样子（泛型采用了Object）：</p><pre><code>public class MyVisitor extends PlayScriptBaseVisitor&lt;Object&gt;{\n  ...\n}\n</code></pre><p>这样，在visitExpression()方法中，我们可以编写各种表达式求值的代码，比如，加法和减法运算的代码如下：</p><pre><code>public Object visitExpression(ExpressionContext ctx) {\n        Object rtn = null;\n        //二元表达式\n        if (ctx.bop != null &amp;&amp; ctx.expression().size() &gt;= 2) {\n            Object left = visitExpression(ctx.expression(0));\n            Object right = visitExpression(ctx.expression(1));\n            ...\n            Type type = cr.node2Type.get(ctx);//数据类型是语义分析的成果\n\n            switch (ctx.bop.getType()) {\n            case PlayScriptParser.ADD:        //加法运算\n                rtn = add(leftObject, rightObject, type);\n                break;\n            case PlayScriptParser.SUB:        //减法运算\n                rtn = minus(leftObject, rightObject, type);\n                break;\n            ...   \n            }\n        }\n        ...\n}\n</code></pre><p>其中ExpressionContext就是AST中表达式的节点，叫做Context，意思是你能从中取出这个节点所有的上下文信息，包括父节点、子节点等。其中，每个子节点的名称跟语法中的名称是一致的，比如加减法语法规则是下面这样：</p><pre><code>expression bop=('+'|'-') expression \n</code></pre><p>那么我们可以用ExpressionContext的这些方法访问子节点：</p><pre><code>ctx.expression();     //返回一个列表，里面有两个成员，分别是左右两边的子节点\nctx.expression(0);    //运算符左边的表达式，是另一个ExpressionContext对象\nctx.expression(1);    //云算法右边的表达式\nctx.bop();            //一个Token对象，其类型是PlayScriptParser.ADD或SUB\nctx.ADD();            //访问ADD终结符，当做加法运算的时候，该方法返回非空值\nctx.MINUS()；         //访问MINUS终结符\n</code></pre><p>在做加法运算的时候我们还可以递归的对下级节点求值，就像代码里的visitExpression(ctx.expression(0))。同样，要想运行整个脚本，我们只需要visit根节点就行了。</p><p>所以，我们可以用这样的方式，为每个AST节点实现一个visit方法。从而把整个解释器升级一遍。除了实现表达式求值，我们还可以为今天设计的if语句、for语句来编写求值逻辑。以for语句为例，代码如下：</p><pre><code>// 初始化部分执行一次\nif (forControl.forInit() != null) {\n    rtn = visitForInit(forControl.forInit());\n}\n\nwhile (true) {\n    Boolean condition = true; // 如果没有条件判断部分，意味着一直循环\n    if (forControl.expression() != null) {\n        condition = (Boolean) visitExpression(forControl.expression());\n    }\n\n    if (condition) {\n        // 执行for的语句体\n        rtn = visitStatement(ctx.statement(0));\n\n        // 执行forUpdate，通常是“i++”这样的语句。这个执行顺序不能出错。\n        if (forControl.forUpdate != null) {\n            visitExpressionList(forControl.forUpdate);\n        }\n    } else {\n        break;\n    }\n}\n</code></pre><p>你需要注意for语句中各个部分的执行规则，比如：</p><ul>\n<li>forInit部分只能执行一次；</li>\n<li>每次循环都要执行一次forControl，看看是否继续循环；</li>\n<li>接着执行for语句中的语句体；</li>\n<li>最后执行forUpdate部分，通常是一些“i++”这样的语句。</li>\n</ul><p>支持了这些流程控制语句以后，我们的脚本语言就更丰富了！</p><h2>课程小结</h2><p>今天，我带你用Antlr高效地完成了很多语法分析工作，比如完善表达式体系，完善语句体系。除此之外，我们还升级了脚本解释器，使它能够执行更多的表达式和语句。</p><p>在实际工作中，针对面临的具体问题，我们完全可以像今天这样迅速地建立可以运行的代码，专注于解决领域问题，快速发挥编译技术的威力。</p><p>而且在使用工具时，针对工具的某个特性，比如对优先级和结合性的支持，我们大致能够猜到工具内部的实现机制，因为我们已经了解了相关原理。</p><h2>一课一思</h2><p>我们通过Antlr并借鉴成熟的规则文件，很快就重构了脚本解释器，这样工作效率很高。那么，针对要解决的领域问题，你是不是借鉴过一些成熟实践或者最佳实践来提升效率和质量？在这个过程中又有什么心得呢？欢迎在留言区分享你的心得。</p><p>最后，感谢你的阅读，如果这篇文章让你有所收获，也欢迎你将它分享给更多的朋友。</p><p>我把一门功能比较全的脚本语言的示例放在了playscript-java项目下，以后几讲的内容都会参考这里面的示例代码。</p><ul>\n<li>playscript-java（项目目录）： <a href=\"https://gitee.com/richard-gong/PlayWithCompiler/tree/master/playscript-java\">码云</a>   <a href=\"https://github.com/RichardGong/PlayWithCompiler/tree/master/playscript-java\">GitHub</a></li>\n<li>PlayScript.java（入口程序）：   <a href=\"https://gitee.com/richard-gong/PlayWithCompiler/blob/master/playscript-java/src/main/play/PlayScript.java\">码云</a>   <a href=\"https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/main/play/PlayScript.java\">GitHub</a></li>\n<li>PlayScript.g4（语法规则）：     <a href=\"https://gitee.com/richard-gong/PlayWithCompiler/blob/master/playscript-java/src/main/play/PlayScript.g4\">码云</a> <a href=\"https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/main/play/PlayScript.g4\">GitHub</a></li>\n<li>ASTEvaluator.java（解释器）： <a href=\"https://gitee.com/richard-gong/PlayWithCompiler/blob/master/playscript-java/src/main/play/ASTEvaluator.java\">码云</a>   <a href=\"https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/main/play/ASTEvaluator.java\">GitHub</a></li>\n</ul><p></p>","neighbors":{"left":{"article_title":"06 | 编译器前端工具（一）：用Antlr生成词法、语法分析器","id":126910},"right":{"article_title":"08 | 作用域和生存期：实现块作用域和函数","id":128623}},"comments":[{"had_liked":false,"id":129052,"user_name":"李懂","can_delete":false,"product_type":"c1","uid":1330436,"ip_address":"","ucode":"539E6639042C88","user_header":"https://static001.geekbang.org/account/avatar/00/14/4d/04/5e0d3713.jpg","comment_is_top":false,"comment_ctime":1567035994,"is_pvip":false,"replies":[{"id":"48268","content":"在编译领域，有一个事情，叫做自举（bootstraping），也就是这门语言的编译器可以用自己这门语言编写。这是语言迈向成熟的标志。一般前面的版本，是要借助别的语言编写编译器，但后面就应该用自己的语言来编译了。<br>著名的语言都实现了自举。比如，go语言的编译器是用go编写的（早期版本应该是用C语言写的编译器。能实现自举，还是go发展历程上的一个历程碑）。<br>最早的语言的编译器，那肯定是用汇编写。到一定程度后再自举。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1567150915,"ip_address":"","comment_id":129052,"utype":1}],"discussion_count":2,"race_medal":0,"score":"87466381914","product_id":100034101,"comment_content":"现在都是用一门语言去实现这些功能，我想知道最开始的语言是怎么实现分析的呢！有一点鸡生蛋蛋生鸡！","like_count":20,"discussions":[{"author":{"id":1629788,"avatar":"https://static001.geekbang.org/account/avatar/00/18/de/5c/aee3d7c2.jpg","nickname":"Zheng Yang","note":"","ucode":"68EEA0BF28B0A0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7031,"discussion_content":"一开始是卡片打孔，然后保存这些的卡片，后来用0101代替，0101不好记，就产生了汇编语言Flow-Matic助记，然后最早的编译器就出现了，随后又诞生了Fortran. Algol，Lisp，Cobol，Basic。BCPL, B语言，C语言也随之出现了.","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1567286780,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465246,"discussion_content":"在编译领域，有一个事情，叫做自举（bootstraping），也就是这门语言的编译器可以用自己这门语言编写。这是语言迈向成熟的标志。一般前面的版本，是要借助别的语言编写编译器，但后面就应该用自己的语言来编译了。\n著名的语言都实现了自举。比如，go语言的编译器是用go编写的（早期版本应该是用C语言写的编译器。能实现自举，还是go发展历程上的一个历程碑）。\n最早的语言的编译器，那肯定是用汇编写。到一定程度后再自举。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567150915,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128753,"user_name":"Spring","can_delete":false,"product_type":"c1","uid":1007267,"ip_address":"","ucode":"80594B4B056A53","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/a3/9670d4b4.jpg","comment_is_top":false,"comment_ctime":1566957059,"is_pvip":false,"replies":[{"id":"47815","content":"对。你提的问题很好。<br>说明你思考的很深入了。<br>“+”执行加法运算，是由计算机语言的语义规定的。比如，你可以再让“+”去做字符串连接，这也是语义上的规定。<br>所以，计算机语言之间真正的差别，其实在语义上。<br>词法分析、语法分析完毕以后，只是搭起一个数据结构。至于基于这个结构可以干什么，还必须附加语义。你可以在这个AST上附加一些“动作指令”，比如对AST遍历的时候，遍历到“+”，就把两边加起来。这就是属性计算做的事情。我们把value作为一个属性，用一些规则来计算属性。说起来，属性计算还是大师高德纳提出来的。<br>你再沿着自己的思路深入下去，你可能自己把高德纳大师想到的也都想出来了。<br>看来你对编译原理的直觉很好:-D","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1566960477,"ip_address":"","comment_id":128753,"utype":1}],"discussion_count":1,"race_medal":0,"score":"74581401091","product_id":100034101,"comment_content":"老师，你好。请教一下，词法，语法解析后生成 AST 后，计算机怎么指导我的AST 中的“+” 就是执行 add  的计算呢？这其中是不是还有还存在一个中间层？","like_count":17,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465087,"discussion_content":"对。你提的问题很好。\n说明你思考的很深入了。\n“+”执行加法运算，是由计算机语言的语义规定的。比如，你可以再让“+”去做字符串连接，这也是语义上的规定。\n所以，计算机语言之间真正的差别，其实在语义上。\n词法分析、语法分析完毕以后，只是搭起一个数据结构。至于基于这个结构可以干什么，还必须附加语义。你可以在这个AST上附加一些“动作指令”，比如对AST遍历的时候，遍历到“+”，就把两边加起来。这就是属性计算做的事情。我们把value作为一个属性，用一些规则来计算属性。说起来，属性计算还是大师高德纳提出来的。\n你再沿着自己的思路深入下去，你可能自己把高德纳大师想到的也都想出来了。\n看来你对编译原理的直觉很好:-D","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566960477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128785,"user_name":"Void_seT","can_delete":false,"product_type":"c1","uid":1070863,"ip_address":"","ucode":"DD55CB0198A5CD","user_header":"https://static001.geekbang.org/account/avatar/00/10/57/0f/1f229bf5.jpg","comment_is_top":false,"comment_ctime":1566962621,"is_pvip":false,"replies":[{"id":"47817","content":"各种文法规则的设计经验的积累，属于&quot;最佳实践&quot;的范畴。我建议大家不仅仅是要懂原理，还能掌握一些最佳实践，说起某个语法现象的时候，随后就能写出几个文法来。<br>能有这种实操能力，才算是把理论落到实际了。这些“最佳实践”，属于你自己积累的领域经验，这也是你为什么会更有竞争力的原因。<br>这些经验，只有动手，多看别人的，才能积累。一般没有书籍专门讲这个，顶多是以示例的方式呈现。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1566963077,"ip_address":"","comment_id":128785,"utype":1}],"discussion_count":1,"race_medal":0,"score":"61696504765","product_id":100034101,"comment_content":"老师，目前的学习过程中，比如表达式语法规则、语句语法规则等，虽然能知道它们表示了什么，但是并不知道它是怎么凭空产生的；请问：这种规则是相对比较固定的，我们要使用时，可以参照“标准”的规则文法进行修改呢？还是要自己掌握各种类型语法规则的各个组成细节，以便于在写语法规则时可以信手拈来呢？如果需要熟练掌握语法规则的各个组成细节，目前的工作如果还用不到生成“小编译器”这种技能，也就是没有练习或高强度的训练时间的话，是否需要现在就硬啃下这块硬骨头（因为怕长时间不使用，将来真正要使用时，还是要重新再训练一遍）？","like_count":15,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465102,"discussion_content":"各种文法规则的设计经验的积累，属于&amp;quot;最佳实践&amp;quot;的范畴。我建议大家不仅仅是要懂原理，还能掌握一些最佳实践，说起某个语法现象的时候，随后就能写出几个文法来。\n能有这种实操能力，才算是把理论落到实际了。这些“最佳实践”，属于你自己积累的领域经验，这也是你为什么会更有竞争力的原因。\n这些经验，只有动手，多看别人的，才能积累。一般没有书籍专门讲这个，顶多是以示例的方式呈现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566963077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132421,"user_name":"宇智波芭芭干","can_delete":false,"product_type":"c1","uid":1477509,"ip_address":"","ucode":"AB95FA5B073079","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKQBotbJDGmnxL1ib3yD2XI7HfRcLMLmNfMXEIIebWaT9q2fvmTYm7lfISgic4W7BZ5r4Jtib9iawEJhg/132","comment_is_top":false,"comment_ctime":1568118505,"is_pvip":false,"replies":[{"id":"50728","content":"谢谢提意见。我们会收集大家的意见，在课件版本迭代时提升表述水平！","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1568181570,"ip_address":"","comment_id":132421,"utype":1}],"discussion_count":7,"race_medal":0,"score":"31632889577","product_id":100034101,"comment_content":"学习时总感觉节奏在老师那边，自己的思路并不连贯，对于初学者容易出现断片。在极客时间其它老师那里也同步购买了linux以及网络协议，另外一边通过故事的形式通熟易懂的讲解了一些底层知识原理，学习也是相当顺畅有兴趣，而这里不知道为啥就是顺畅不起来，差距不是一般的大。","like_count":7,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466927,"discussion_content":"谢谢提意见。我们会收集大家的意见，在课件版本迭代时提升表述水平！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568181570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133945,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4d/79/803537db.jpg","nickname":"慢动作","note":"","ucode":"62C944F4A4D8AC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409640,"discussion_content":"反而觉得linux故事生硬，全是代码细节，目前还没看完。学习没有容易的，感觉容易就是没有进步，","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635478732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1987547,"avatar":"","nickname":"学徒","note":"","ucode":"95956442ECB8C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377209,"discussion_content":"没有别的原因，就是因为编译原理就是难。可能需要反复的琢磨","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1622550299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1260883,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3d/53/9d8a1207.jpg","nickname":"尼欧","note":"","ucode":"39D4D1F5F51764","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346568,"discussion_content":"应该说是课程性质决定的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611995084,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133036,"avatar":"https://static001.geekbang.org/account/avatar/00/11/49/ec/6bae1fd7.jpg","nickname":"哇咔咔","note":"","ucode":"54BF877836C591","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301350,"discussion_content":"因为你没有去自己写代码，估计是被递归整懵了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598498084,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1484184,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","nickname":"djfhchdh","note":"","ucode":"E71D75328CE398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":111229,"discussion_content":"菜👎","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577786590,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1415666,"avatar":"https://static001.geekbang.org/account/avatar/00/15/99/f2/36e102e6.jpg","nickname":"爆米花","note":"","ucode":"4F8BC766DBC4CD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1484184,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","nickname":"djfhchdh","note":"","ucode":"E71D75328CE398","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407235,"discussion_content":"你为什么这样说，谁派你来的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634953383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":111229,"ip_address":""},"score":407235,"extra":""}]}]},{"had_liked":false,"id":129743,"user_name":"windpiaoxue","can_delete":false,"product_type":"c1","uid":1258079,"ip_address":"","ucode":"3769AAFFB61814","user_header":"https://static001.geekbang.org/account/avatar/00/13/32/5f/0c870296.jpg","comment_is_top":false,"comment_ctime":1567236823,"is_pvip":false,"replies":[{"id":"48569","content":"为你的动手实践点赞！<br>其实原因我在文稿里已经说了。<br>我们实现一个算法的时候，是有确定的顺序来匹配的。所以，即使是二义性文法，在某种算法下也可以正常解析。<br><br>严格的非二义性文法要求得比较高。它要求是算法无关的。也就是不管你用最左还是最右推导，得出的结果是一样的。<br><br>关键点，在于把“文法”和“算法”这两件事区分开。文法是二义的，用某个具体算法却不一定是二义的。<br><br>其余的部分，你可以再看看文稿，是否能理解。Antlr是LL算法，最左推导、深度优先。如果你一时看不明白，也没关系，因为到后面我还会专门讲LL算法。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1567407667,"ip_address":"","comment_id":129743,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31632007895","product_id":100034101,"comment_content":"老师您好<br>例如下面这个规则：<br>stmt -&gt; if expr stmt<br>      | if expr stmt else stmt<br>      | other<br>我测试了一下，antlr使用上面这个规则可以正确的处理悬挂else的问题，<br>antlr在处理这种二义性问题的时候，是依据什么来处理的。<br>","like_count":7,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465624,"discussion_content":"为你的动手实践点赞！\n其实原因我在文稿里已经说了。\n我们实现一个算法的时候，是有确定的顺序来匹配的。所以，即使是二义性文法，在某种算法下也可以正常解析。\n\n严格的非二义性文法要求得比较高。它要求是算法无关的。也就是不管你用最左还是最右推导，得出的结果是一样的。\n\n关键点，在于把“文法”和“算法”这两件事区分开。文法是二义的，用某个具体算法却不一定是二义的。\n\n其余的部分，你可以再看看文稿，是否能理解。Antlr是LL算法，最左推导、深度优先。如果你一时看不明白，也没关系，因为到后面我还会专门讲LL算法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567407667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333884,"user_name":"Geek_6304e3","can_delete":false,"product_type":"c1","uid":2905630,"ip_address":"","ucode":"8DD9A6D8E7DC60","user_header":"","comment_is_top":false,"comment_ctime":1644570203,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14529472091","product_id":100034101,"comment_content":"老师，后面的用 Vistor 模式升级脚本解释器开始有点看不懂，不懂java，有JavaScript版本的吗？文章一些代码都是直接说这样写，但是我不知道这样写之后在哪里关联运行起来。","like_count":4},{"had_liked":false,"id":333849,"user_name":"Geek_6304e3","can_delete":false,"product_type":"c1","uid":2905630,"ip_address":"","ucode":"8DD9A6D8E7DC60","user_header":"","comment_is_top":false,"comment_ctime":1644562820,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10234497412","product_id":100034101,"comment_content":"visitor这些解释器要怎么执行呢？","like_count":2},{"had_liked":false,"id":333842,"user_name":"Geek_6304e3","can_delete":false,"product_type":"c1","uid":2905630,"ip_address":"","ucode":"8DD9A6D8E7DC60","user_header":"","comment_is_top":false,"comment_ctime":1644560966,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10234495558","product_id":100034101,"comment_content":"visitExpression方法实在哪个文件生成的？文中没有说。","like_count":2},{"had_liked":false,"id":148296,"user_name":"fung","can_delete":false,"product_type":"c1","uid":1117384,"ip_address":"","ucode":"8C781315F62C6B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLJ9I2tZHaGuvibuLQFxTicoC1PQTwswI6NDCT6MV1IgqE5ibAVPucKXaiafTpCmvtGPtfSSpC4rbH5aA/132","comment_is_top":false,"comment_ctime":1572969127,"is_pvip":false,"replies":[{"id":"57510","content":"首先，关于Antlr的详细语法，你可以看一下它的作者的一本书：《the definitive antlr 4 reference》，应该也有中文版的。<br><br>另外，你可以搜一下EBNF的语法，因为antlr的语法基本上就是EBNF的语法，跟正则表达式的语法也很像，然后又加了一些元素，比如给某些部分做了命名。<br>bop=(&#39;+&#39;|&#39;-&#39;)是给(&#39;+&#39;|&#39;-&#39;)起了个名称，便于引用。<br><br>最后，当你动手实践的时候，这些困难就都不存在了。你就是对它们陌生。用多了就不陌生了！","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1573292207,"ip_address":"","comment_id":148296,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10162903719","product_id":100034101,"comment_content":"老师，这一段看不懂咋办，有的救吗？看不懂这些语法啊，能解析下吗？或有其他资料介绍吗？谢谢<br>expression : primary | expression bop=&#39;.&#39; ( IDENTIFIER | functionCall | THIS ) | expression &#39;[&#39; expression &#39;]&#39; | functionCall | expression postfix=(&#39;++&#39; | &#39;--&#39;) | prefix=(&#39;+&#39;|&#39;-&#39;|&#39;++&#39;|&#39;--&#39;) expression | prefix=(&#39;~&#39;|&#39;!&#39;) expression | expression bop=(&#39;*&#39;|&#39;&#47;&#39;|&#39;%&#39;) expression | expression bop=(&#39;+&#39;|&#39;-&#39;) expression | expression (&#39;&lt;&#39; &#39;&lt;&#39; | &#39;&gt;&#39; &#39;&gt;&#39; &#39;&gt;&#39; | &#39;&gt;&#39; &#39;&gt;&#39;) expression | expression bop=(&#39;&lt;=&#39; | &#39;&gt;=&#39; | &#39;&gt;&#39; | &#39;&lt;&#39;) expression .......","like_count":2,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473454,"discussion_content":"首先，关于Antlr的详细语法，你可以看一下它的作者的一本书：《the definitive antlr 4 reference》，应该也有中文版的。\n\n另外，你可以搜一下EBNF的语法，因为antlr的语法基本上就是EBNF的语法，跟正则表达式的语法也很像，然后又加了一些元素，比如给某些部分做了命名。\nbop=(&amp;#39;+&amp;#39;|&amp;#39;-&amp;#39;)是给(&amp;#39;+&amp;#39;|&amp;#39;-&amp;#39;)起了个名称，便于引用。\n\n最后，当你动手实践的时候，这些困难就都不存在了。你就是对它们陌生。用多了就不陌生了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573292207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005623,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/58/37/5ee5df14.jpg","nickname":"李自强","note":"","ucode":"B8E98799F1C6DF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570863,"discussion_content":"bop感觉是binary operator，上一讲提到的在语法规则文件里，可以出现在同一条规则里。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651973631,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144636,"user_name":"shantelle","can_delete":false,"product_type":"c1","uid":1708274,"ip_address":"","ucode":"5EEAA38BF058C8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ1KSrs5Wf7VFhckiaKClt4kmJibBVic9tp2GicoQ0pAU1FRwS7VrCUzPXu8GQ65biaibrKxibQ7TUI3IBDA/132","comment_is_top":false,"comment_ctime":1571987754,"is_pvip":false,"replies":[{"id":"57698","content":"转义字符，比如：\\t是tab。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1573444564,"ip_address":"","comment_id":144636,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10161922346","product_id":100034101,"comment_content":"宫老师你好，请问这个匹配的是什么内容呢<br>&#39;\\\\&#39; [btnfr&quot;&#39;\\\\]","like_count":2,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472044,"discussion_content":"转义字符，比如：\\t是tab。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573444564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141770,"user_name":"zhj","can_delete":false,"product_type":"c1","uid":1311772,"ip_address":"","ucode":"65B9E222D6E075","user_header":"https://static001.geekbang.org/account/avatar/00/14/04/1c/b0c6c009.jpg","comment_is_top":false,"comment_ctime":1571221349,"is_pvip":false,"replies":[{"id":"57582","content":"回头把代码分拆整理一下。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1573344120,"ip_address":"","comment_id":141770,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10161155941","product_id":100034101,"comment_content":"现在拿到的ASTEvaluator，都裹扎了编译器相关的代码，这里才看到Ast树，这边没有很好的 版本迭代吗，上来直接就是讲课同步的代码，看的云里雾里，没法循序渐进","like_count":2,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470880,"discussion_content":"回头把代码分拆整理一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573344120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128739,"user_name":"石维康","can_delete":false,"product_type":"c1","uid":1067564,"ip_address":"","ucode":"E39ED8416B2C01","user_header":"https://static001.geekbang.org/account/avatar/00/10/4a/2c/f8451d77.jpg","comment_is_top":false,"comment_ctime":1566955750,"is_pvip":false,"replies":[{"id":"47783","content":"这是给block起了个别名，这样在生成的AST节点StatementContext中，就会有blockLabel这个属性，来访问这个下级节点。<br>就是为了编程方便的。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1566957732,"ip_address":"","comment_id":128739,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10156890342","product_id":100034101,"comment_content":"statement<br>    : blockLabel=block<br>    | IF parExpression statement (ELSE statement)?<br>    | FOR &#39;(&#39; forControl &#39;)&#39; statement<br>    | WHILE parExpression statement<br>    | DO statement WHILE parExpression &#39;;&#39;<br>    | SWITCH parExpression &#39;{&#39; switchBlockStatementGroup* switchLabel* &#39;}&#39;<br>    | RETURN expression? &#39;;&#39;<br>    | BREAK IDENTIFIER? &#39;;&#39;<br>    | SEMI<br>    | statementExpression=expression &#39;;&#39;<br>    ;<br>请问&quot; : blockLabel=block&quot;这个规则如何解释?谢谢!","like_count":2,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465083,"discussion_content":"这是给block起了个别名，这样在生成的AST节点StatementContext中，就会有blockLabel这个属性，来访问这个下级节点。\n就是为了编程方便的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566957732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333910,"user_name":"Geek_6304e3","can_delete":false,"product_type":"c1","uid":2905630,"ip_address":"","ucode":"8DD9A6D8E7DC60","user_header":"","comment_is_top":false,"comment_ctime":1644575588,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5939542884","product_id":100034101,"comment_content":"老师，你给的java版本的项目跑不起来。。不懂java<br>","like_count":1},{"had_liked":false,"id":161827,"user_name":"草戊","can_delete":false,"product_type":"c1","uid":1044202,"ip_address":"","ucode":"F1B0CB0A4FA762","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/ea/c8136dfd.jpg","comment_is_top":false,"comment_ctime":1576362465,"is_pvip":false,"replies":[{"id":"63373","content":"如果是手写编译器，就很容易处理。在处理*号的时候加一点代码进行上下文的分析就好了。<br>像Antlr这样编译器生成工具，支持你在做解析的时候嵌入自己的代码，进行与上下文有关的分析。分析的结果，会反馈回来影响编译过程。<br>所以，在词法或语法分析时就开始进行上下文的分析（或语义分析），是一个普遍使用的技巧。<br>如果你想深入了解一下这个问题，推荐你看一下这篇论文: <br>https:&#47;&#47;www.antlr.org&#47;papers&#47;predicated-parsing.pdf<br>这里面还有其他一些例子。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1577433706,"ip_address":"","comment_id":161827,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5871329761","product_id":100034101,"comment_content":"老师，有些语言的部分文法是上下文有关，比如说必须是第七列写*号来注释。对于这样的语言分析，有什么好的建议吗？在parser前先做预处理变换？","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477873,"discussion_content":"如果是手写编译器，就很容易处理。在处理*号的时候加一点代码进行上下文的分析就好了。\n像Antlr这样编译器生成工具，支持你在做解析的时候嵌入自己的代码，进行与上下文有关的分析。分析的结果，会反馈回来影响编译过程。\n所以，在词法或语法分析时就开始进行上下文的分析（或语义分析），是一个普遍使用的技巧。\n如果你想深入了解一下这个问题，推荐你看一下这篇论文: \nhttps://www.antlr.org/papers/predicated-parsing.pdf\n这里面还有其他一些例子。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577433706,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138496,"user_name":"cry soul","can_delete":false,"product_type":"c1","uid":1508461,"ip_address":"","ucode":"986C52250EB110","user_header":"https://static001.geekbang.org/account/avatar/00/17/04/6d/c959cb93.jpg","comment_is_top":false,"comment_ctime":1570280241,"is_pvip":false,"replies":[{"id":"53816","content":"谢谢你的建议。有的代码文件确实很长，查找不太容易。我后面优化一下代码链接！","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1570677225,"ip_address":"","comment_id":138496,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5865247537","product_id":100034101,"comment_content":"建议老师用用git搭好tag来表示每个课程到到哪部分源码，不然需要读好几篇才能自己尝试。","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469543,"discussion_content":"谢谢你的建议。有的代码文件确实很长，查找不太容易。我后面优化一下代码链接！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570677225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129064,"user_name":"李懂","can_delete":false,"product_type":"c1","uid":1330436,"ip_address":"","ucode":"539E6639042C88","user_header":"https://static001.geekbang.org/account/avatar/00/14/4d/04/5e0d3713.jpg","comment_is_top":false,"comment_ctime":1567038018,"is_pvip":false,"replies":[{"id":"48265","content":"我记着你这个需求。<br>我看看能否把这个点插到某一讲中。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1567150749,"ip_address":"","comment_id":129064,"utype":1}],"discussion_count":4,"race_medal":0,"score":"5862005314","product_id":100034101,"comment_content":"JavaScript中的this是咋实现的，这个一直处于迷糊当中，好想弄清楚，不同语言之间语意的差别，学完语意能理解么😇 😇 😇 ，看了很多课程，都很失望，都是再讲几种场景，怎么指向，没实质的改变！","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465255,"discussion_content":"我记着你这个需求。\n我看看能否把这个点插到某一讲中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567150749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1629788,"avatar":"https://static001.geekbang.org/account/avatar/00/18/de/5c/aee3d7c2.jpg","nickname":"Zheng Yang","note":"","ucode":"68EEA0BF28B0A0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7028,"discussion_content":"this是类符号表里的头指针","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567285666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1905024,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/11/80/73ff198e.jpg","nickname":"VictorLee","note":"","ucode":"FF7C211DA853CE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305913,"discussion_content":"关键字动态编译","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600129507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2009848,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/aa/f8/d126592e.jpg","nickname":"机智过人诸葛维奇涌","note":"","ucode":"331F17DAAAE087","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304979,"discussion_content":"https://github.com/mqyqingfeng/Blog/issues/7 这里有个js规范翻译，结合编译原理一起感觉更好理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599729710,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129016,"user_name":"中年男子","can_delete":false,"product_type":"c1","uid":1039204,"ip_address":"","ucode":"027C86B3370150","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","comment_is_top":false,"comment_ctime":1567007414,"is_pvip":true,"replies":[{"id":"48275","content":"你的进度有点快！<br>playscript-cpp我还没有整理好。<br>如果你着急看后端的东西，建议你先做两件事情：<br>1.用Antlr将.g4文件生成c++代码，测试一下在C++中运行是否OK。<br>2.下载和安装LLVM，做做教程里的例子，有一个是c++的例子。<br>好消息是，这两个项目都是用cmake管理的。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1567151530,"ip_address":"","comment_id":129016,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5861974710","product_id":100034101,"comment_content":"编译\b git 里 PlayScript-cpp， 我这里报错， PlayScriptJit.h 这个文件， 搞了半天没搞懂<br>In file included from &#47;Users&#47;shiny&#47;learn&#47;PlayWithCompiler&#47;playscript-cpp&#47;src&#47;PlayScript.cpp:5:<br>[build] In file included from &#47;Users&#47;shiny&#47;learn&#47;PlayWithCompiler&#47;playscript-cpp&#47;src&#47;grammar&#47;IRGen.h:28:<br>[build] &#47;Users&#47;shiny&#47;learn&#47;PlayWithCompiler&#47;playscript-cpp&#47;src&#47;grammar&#47;PlayScriptJIT.h:33:31: error: unknown type name &#39;LegacyRTDyldObjectLinkingLayer&#39;; did you mean &#39;RTDyldObjectLinkingLayer&#39;?<br>[build]             using ObjLayerT = LegacyRTDyldObjectLinkingLayer;<br>[build]                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br>[build]                               RTDyldObjectLinkingLayer","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465225,"discussion_content":"你的进度有点快！\nplayscript-cpp我还没有整理好。\n如果你着急看后端的东西，建议你先做两件事情：\n1.用Antlr将.g4文件生成c++代码，测试一下在C++中运行是否OK。\n2.下载和安装LLVM，做做教程里的例子，有一个是c++的例子。\n好消息是，这两个项目都是用cmake管理的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567151530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128904,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1566982181,"is_pvip":false,"replies":[{"id":"48285","content":"我相信你的消化能力:-D","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1567152958,"ip_address":"","comment_id":128904,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5861949477","product_id":100034101,"comment_content":"难度越来越大了，要好好消化才行。","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465166,"discussion_content":"我相信你的消化能力:-D","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567152958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128656,"user_name":"(￣_￣ )","can_delete":false,"product_type":"c1","uid":1133366,"ip_address":"","ucode":"8B6E2EF240D4AD","user_header":"https://static001.geekbang.org/account/avatar/00/11/4b/36/ed40fb3a.jpg","comment_is_top":false,"comment_ctime":1566926673,"is_pvip":false,"replies":[{"id":"47788","content":"点赞！<br>动手出真知！","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1566957914,"ip_address":"","comment_id":128656,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5861893969","product_id":100034101,"comment_content":"写了一晚上终于用c语言模仿着实现了第二节课的内容<br>https:&#47;&#47;github.com&#47;hongningexpro&#47;Play_with_Compiler&#47;tree&#47;master&#47;01-Simple_Lexer","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465042,"discussion_content":"点赞！\n动手出真知！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566957914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":354458,"user_name":"Geek_3c4e22","can_delete":false,"product_type":"c1","uid":2962296,"ip_address":"福建","ucode":"C0F60880FD487B","user_header":"","comment_is_top":false,"comment_ctime":1660436995,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660436995","product_id":100034101,"comment_content":"压根就不知道怎么把代码跑起来","like_count":0},{"had_liked":false,"id":338865,"user_name":"丁本","can_delete":false,"product_type":"c1","uid":1228727,"ip_address":"","ucode":"A900A8968466A5","user_header":"https://static001.geekbang.org/account/avatar/00/12/bf/b7/6463ef60.jpg","comment_is_top":false,"comment_ctime":1647765851,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647765851","product_id":100034101,"comment_content":"反馈个 typo ：“云算法右边的表达式”","like_count":0},{"had_liked":false,"id":332132,"user_name":"Gaollard","can_delete":false,"product_type":"c1","uid":1378779,"ip_address":"","ucode":"1B200F5E73C3E1","user_header":"https://static001.geekbang.org/account/avatar/00/15/09/db/78996b11.jpg","comment_is_top":false,"comment_ctime":1643033768,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643033768","product_id":100034101,"comment_content":"第一次看 bop 没看懂，后面才理解。他只是起指代作用，比如 bop=(&#39;&lt;=&#39; | &#39;&gt;=&#39; | &#39;&gt;&#39; | &#39;&lt;&#39;) 表示，这里的bop 为 (&#39;&lt;=&#39; | &#39;&gt;=&#39; | &#39;&gt;&#39; | &#39;&lt;&#39;) ","like_count":0},{"had_liked":false,"id":317816,"user_name":"爆米花","can_delete":false,"product_type":"c1","uid":1415666,"ip_address":"","ucode":"4F8BC766DBC4CD","user_header":"https://static001.geekbang.org/account/avatar/00/15/99/f2/36e102e6.jpg","comment_is_top":false,"comment_ctime":1634978275,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634978275","product_id":100034101,"comment_content":"expression bop=&#39;.&#39; ( IDENTIFIER | functionCall | THIS )<br>老师，这一段是点运算符吗，为什么不写成 <br>IDENTIFIER bop=&#39;.&#39; ( IDENTIFIER | functionCall | THIS )","like_count":0},{"had_liked":false,"id":298066,"user_name":"Victor.qiu","can_delete":false,"product_type":"c1","uid":1144635,"ip_address":"","ucode":"958D2C78E4FC72","user_header":"https://static001.geekbang.org/account/avatar/00/11/77/3b/5502a4fa.jpg","comment_is_top":false,"comment_ctime":1623899481,"is_pvip":false,"replies":[{"id":"108189","content":"带括号的表达式属于primary（基础表达式），你可以看链接里提供的完整的语法文件，里面有。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1623925269,"ip_address":"","comment_id":298066,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1623899481","product_id":100034101,"comment_content":"老师，那个表达式的规则里怎么没有看到对括号的匹配","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522002,"discussion_content":"带括号的表达式属于primary（基础表达式），你可以看链接里提供的完整的语法文件，里面有。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623925269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":268249,"user_name":"coconut","can_delete":false,"product_type":"c1","uid":2344081,"ip_address":"","ucode":"07B95C7A6AC2F7","user_header":"https://static001.geekbang.org/account/avatar/00/23/c4/91/a017bf72.jpg","comment_is_top":false,"comment_ctime":1608113757,"is_pvip":true,"replies":[{"id":"98466","content":"看过了！很好！把python和antlr结合起来使用。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1609731232,"ip_address":"","comment_id":268249,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1608113757","product_id":100034101,"comment_content":"参考老师的Java代码，写了一个简陋的Python版本，目前可以解析下面的语句<br><br>int a=2*3+1;a=a+3*2;int b=1+2;snoopy_print(a, b);<br><br>https:&#47;&#47;github.com&#47;leveryd&#47;PlayWithCompiler&#47;blob&#47;master&#47;main.py","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511885,"discussion_content":"看过了！很好！把python和antlr结合起来使用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609731232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236049,"user_name":"A.Y.","can_delete":false,"product_type":"c1","uid":2029589,"ip_address":"","ucode":"7A9701DD436547","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f8/15/2724d7ec.jpg","comment_is_top":false,"comment_ctime":1595298349,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1595298349","product_id":100034101,"comment_content":"老师您好！我在运行本节的示例PlayScript.java的时候，发现ASTEvaluator解释执行的结果为null，通过打断点发现程序根本没有进入ASTEvaluator里面去。我用的是antlr-4.8版本，程序使用的是github上的示例没有改动。请问是什么地方编写的不正确或者需要调整吗？<br>","like_count":0,"discussions":[{"author":{"id":1286495,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJF2LUt5pJt4OStxojTuBQh1B4pJgtbMU1lAmHf4uwcxfa6PBaPC9aauhFrGLDVbRa5GAfPKibPC7A/132","nickname":"Geek_peter","note":"","ucode":"AE5FFDEE70CEFD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587657,"discussion_content":" antlr -visitor PlayScript.g4","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663204718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"河南"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224323,"user_name":"郭思奇","can_delete":false,"product_type":"c1","uid":2025037,"ip_address":"","ucode":"AF27E4880453AE","user_header":"","comment_is_top":false,"comment_ctime":1591344690,"is_pvip":false,"replies":[{"id":"82797","content":"在语法分析阶段，它会根据语法规则，直接认定这是一条变量声明语句（带有初始化部分）。因为，在语法规则里，int_32只要是一个标识符就行。<br>在语义分析阶段，编译器会查找int_32是不是一个合法的类型。如果没有在其他地方定义这个类型，编译器就会报错。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1591620786,"ip_address":"","comment_id":224323,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591344690","product_id":100034101,"comment_content":"老师，您好，想请教下，当前编程中常有数据类型定义，对于一种新定义的数据类型，例如 int_32 age = 45，语法分析时如何识别该语句是一条初始化语句呢？","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497443,"discussion_content":"在语法分析阶段，它会根据语法规则，直接认定这是一条变量声明语句（带有初始化部分）。因为，在语法规则里，int_32只要是一个标识符就行。\n在语义分析阶段，编译器会查找int_32是不是一个合法的类型。如果没有在其他地方定义这个类型，编译器就会报错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591620786,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191892,"user_name":"lcp0578","can_delete":false,"product_type":"c1","uid":1559585,"ip_address":"","ucode":"E347928F8DB98D","user_header":"https://static001.geekbang.org/account/avatar/00/17/cc/21/e3c45732.jpg","comment_is_top":false,"comment_ctime":1584802711,"is_pvip":false,"replies":[{"id":"74124","content":"点赞！","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1585126222,"ip_address":"","comment_id":191892,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1584802711","product_id":100034101,"comment_content":"好好学习天天向上","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488280,"discussion_content":"点赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585126222,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179524,"user_name":"hilltsui","can_delete":false,"product_type":"c1","uid":1725302,"ip_address":"","ucode":"D59A02AA45A52F","user_header":"","comment_is_top":false,"comment_ctime":1582021118,"is_pvip":false,"replies":[{"id":"74208","content":"是的，这一季的课程，后半部分都是偏向后端的。<br>还有下一季的课程里，通过分析实际的编译器，也介绍了很多后端知识和运行时的知识。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1585146611,"ip_address":"","comment_id":179524,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582021118","product_id":100034101,"comment_content":"学到挺多东西的课程。老师请问后面的课程会有讲解关于编译后端的内容吗挺期待的","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484293,"discussion_content":"是的，这一季的课程，后半部分都是偏向后端的。\n还有下一季的课程里，通过分析实际的编译器，也介绍了很多后端知识和运行时的知识。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585146611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177861,"user_name":"Aaaaaaaaaaayou","can_delete":false,"product_type":"c1","uid":1073601,"ip_address":"","ucode":"67BA315B87587D","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/c1/93031a2a.jpg","comment_is_top":false,"comment_ctime":1581516083,"is_pvip":false,"replies":[{"id":"77063","content":"那你实际上是又帮我发现了一个bug :-D<br>本地变量入符号表，应该在变量消解的过程中去做，不能提前做，否则变量的定义和使用关系就会错误。<br>修改后的代码，把TypeResolve分了两个阶段。你看看修改后的代码，以及再运行一下BlockScope.play看看。<br>https:&#47;&#47;github.com&#47;RichardGong&#47;PlayWithCompiler&#47;blob&#47;master&#47;playscript-java&#47;src&#47;main&#47;play&#47;TypeResolver.java<br>https:&#47;&#47;github.com&#47;RichardGong&#47;PlayWithCompiler&#47;blob&#47;master&#47;playscript-java&#47;src&#47;main&#47;play&#47;RefResolver.java","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1586849801,"ip_address":"","comment_id":177861,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1581516083","product_id":100034101,"comment_content":"老师，examples&#47;BlockScope.play 的输出结果应该是 0 2 3 0。因为在 type resolve 阶段已经把所有的变量定义都识别出来了，然后在 ref resolve 阶段解决分号中第一个 i 的引用时会在当前作用域中寻找到，所以分号中对 i 的赋值不会影响到根作用域的变量 i。运行了一下程序确实如此。","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483569,"discussion_content":"那你实际上是又帮我发现了一个bug :-D\n本地变量入符号表，应该在变量消解的过程中去做，不能提前做，否则变量的定义和使用关系就会错误。\n修改后的代码，把TypeResolve分了两个阶段。你看看修改后的代码，以及再运行一下BlockScope.play看看。\nhttps://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/main/play/TypeResolver.java\nhttps://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/main/play/RefResolver.java","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586849801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1284574,"avatar":"https://static001.geekbang.org/account/avatar/00/13/99/de/a8b1e731.jpg","nickname":"--","note":"","ucode":"99ECDDCFAF477D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343394,"discussion_content":"这样改掉之后，会导致后面的函数，闭包解析报空指针异常","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611028099,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131609,"user_name":"长方体混凝土移动工程师","can_delete":false,"product_type":"c1","uid":1262728,"ip_address":"","ucode":"00CB4C4AB4D119","user_header":"https://static001.geekbang.org/account/avatar/00/13/44/88/69580101.jpg","comment_is_top":false,"comment_ctime":1567824340,"is_pvip":false,"replies":[{"id":"50757","content":"在PlayScript.g4中：<br><br>statement<br>    : blockLabel=block<br><br>blockLabel就是给block起个别名而已。可以在StatementContext中访问blockLabel属性，来获得一个block子节点。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1568183660,"ip_address":"","comment_id":131609,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567824340","product_id":100034101,"comment_content":"blockLabel 这个怎么没看到在哪里定义的呢?","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466535,"discussion_content":"在PlayScript.g4中：\n\nstatement\n    : blockLabel=block\n\nblockLabel就是给block起个别名而已。可以在StatementContext中访问blockLabel属性，来获得一个block子节点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568183660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131598,"user_name":"长方体混凝土移动工程师","can_delete":false,"product_type":"c1","uid":1262728,"ip_address":"","ucode":"00CB4C4AB4D119","user_header":"https://static001.geekbang.org/account/avatar/00/13/44/88/69580101.jpg","comment_is_top":false,"comment_ctime":1567822396,"is_pvip":false,"replies":[{"id":"50759","content":"是的，只是个别名。<br>它会变成ExpressionStatement的一个属性。通过这个属性，可以获得一个子节点。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1568183703,"ip_address":"","comment_id":131598,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567822396","product_id":100034101,"comment_content":"bop只是一个别名吗？","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466528,"discussion_content":"是的，只是个别名。\n它会变成ExpressionStatement的一个属性。通过这个属性，可以获得一个子节点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568183703,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131241,"user_name":"Lafite","can_delete":false,"product_type":"c1","uid":1391107,"ip_address":"","ucode":"42B3430F366930","user_header":"https://static001.geekbang.org/account/avatar/00/15/3a/03/bd7d8a6d.jpg","comment_is_top":false,"comment_ctime":1567677606,"is_pvip":false,"replies":[{"id":"49544","content":"playscript的java版我没有维护多个版本。所以里面有很多特性是后面几讲里的。<br>但是，你可以先关注本讲的内容。比如，（1）比较完整的语法规则文件；(2)ASTEvaluator.java如何完成计算的整体流程。<br>一些其他的细节，听完后面几讲以后，应该就能明白了。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1567684453,"ip_address":"","comment_id":131241,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567677606","product_id":100034101,"comment_content":"宫老师，本章的代码应该如何去学习呢，想学习一下 本章的解释器及其他代码， 结果发现代码量比较大，我阅读起来比较困难，麻烦老师指导一下，谢谢","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466347,"discussion_content":"playscript的java版我没有维护多个版本。所以里面有很多特性是后面几讲里的。\n但是，你可以先关注本讲的内容。比如，（1）比较完整的语法规则文件；(2)ASTEvaluator.java如何完成计算的整体流程。\n一些其他的细节，听完后面几讲以后，应该就能明白了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567684453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129631,"user_name":"沉淀的梦想","can_delete":false,"product_type":"c1","uid":1177315,"ip_address":"","ucode":"BCB7C26F9D214B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg","comment_is_top":false,"comment_ctime":1567176901,"is_pvip":false,"replies":[{"id":"48573","content":"这两个生成的结果一样。Antlr会知道其实&#39;+&#39;是你已经在词法规则中声明了的，知道这里等价于ADD。<br>如果词法规则里没有把&#39;+&#39;定义成ADD，也没关系，Antlr会自动添加词法规则，但名称就是它自己起的了。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1567408562,"ip_address":"","comment_id":129631,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1567176901","product_id":100034101,"comment_content":"有个疑问，为什么expression的规则是写作  <br><br>expression bop=(&#39;+&#39;|&#39;-&#39;) expression <br><br>而不是写作：<br><br>expression bop=(ADD|SUB) expression <br><br>","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465573,"discussion_content":"这两个生成的结果一样。Antlr会知道其实&amp;#39;+&amp;#39;是你已经在词法规则中声明了的，知道这里等价于ADD。\n如果词法规则里没有把&amp;#39;+&amp;#39;定义成ADD，也没关系，Antlr会自动添加词法规则，但名称就是它自己起的了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567408562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1629788,"avatar":"https://static001.geekbang.org/account/avatar/00/18/de/5c/aee3d7c2.jpg","nickname":"Zheng Yang","note":"","ucode":"68EEA0BF28B0A0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7030,"discussion_content":"因为是终止符，不需要在代换了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567285791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128688,"user_name":"雲至","can_delete":false,"product_type":"c1","uid":1568487,"ip_address":"","ucode":"47E2D099322BB1","user_header":"https://static001.geekbang.org/account/avatar/00/17/ee/e7/4375e97c.jpg","comment_is_top":false,"comment_ctime":1566950927,"is_pvip":false,"replies":[{"id":"47786","content":"antlr是个工具。它的完整语法和介绍什么的，看官方网站和我提供的参考书就行了。我们课程不可能在这方面笔墨太多。<br>工具这个事情，你只要了解了原理，去试着用一下就行了。<br>动手是最重要的。课程里的示例代码，可以给你怎么具体使用antlr提供很多线索。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1566957885,"ip_address":"","comment_id":128688,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566950927","product_id":100034101,"comment_content":"老师能讲一下antlr的语法吗？","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465058,"discussion_content":"antlr是个工具。它的完整语法和介绍什么的，看官方网站和我提供的参考书就行了。我们课程不可能在这方面笔墨太多。\n工具这个事情，你只要了解了原理，去试着用一下就行了。\n动手是最重要的。课程里的示例代码，可以给你怎么具体使用antlr提供很多线索。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566957885,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}