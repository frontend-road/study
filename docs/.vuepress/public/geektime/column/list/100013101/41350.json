{"id":41350,"title":"26 | sync.Mutex与sync.RWMutex","content":"<p>我在前面用20多篇文章，为你详细地剖析了Go语言本身的一些东西，这包括了基础概念、重要语法、高级数据类型、特色语句、测试方案等等。</p><p>这些都是Go语言为我们提供的最核心的技术。我想，这已经足够让你对Go语言有一个比较深刻的理解了。</p><p>从本篇文章开始，我们将一起探讨Go语言自带标准库中一些比较核心的代码包。这会涉及这些代码包的标准用法、使用禁忌、背后原理以及周边的知识。</p><hr></hr><p>既然Go语言是以独特的并发编程模型傲视群雄的语言，那么我们就先来学习与并发编程关系最紧密的代码包。</p><h2>前导内容： 竞态条件、临界区与同步工具</h2><p>我们首先要看的就是<code>sync</code>包。这里的“sync”的中文意思是“同步”。我们下面就从同步讲起。</p><p>相比于Go语言宣扬的“用通讯的方式共享数据”，通过共享数据的方式来传递信息和协调线程运行的做法其实更加主流，毕竟大多数的现代编程语言，都是用后一种方式作为并发编程的解决方案的（这种方案的历史非常悠久，恐怕可以追溯到上个世纪多进程编程时代伊始了）。</p><p>一旦数据被多个线程共享，那么就很可能会产生争用和冲突的情况。这种情况也被称为<strong>竞态条件（race condition）</strong>，这往往会破坏共享数据的一致性。</p><p>共享数据的一致性代表着某种约定，即：多个线程对共享数据的操作总是可以达到它们各自预期的效果。</p><!-- [[[read_end]]] --><p>如果这个一致性得不到保证，那么将会影响到一些线程中代码和流程的正确执行，甚至会造成某种不可预知的错误。这种错误一般都很难发现和定位，排查起来的成本也是非常高的，所以一定要尽量避免。</p><p>举个例子，同时有多个线程连续向同一个缓冲区写入数据块，如果没有一个机制去协调这些线程的写入操作的话，那么被写入的数据块就很可能会出现错乱。比如，在线程A还没有写完一个数据块的时候，线程B就开始写入另外一个数据块了。</p><p>显然，这两个数据块中的数据会被混在一起，并且已经很难分清了。因此，在这种情况下，我们就需要采取一些措施来协调它们对缓冲区的修改。这通常就会涉及同步。</p><p>概括来讲，<strong>同步的用途有两个，一个是避免多个线程在同一时刻操作同一个数据块，另一个是协调多个线程，以避免它们在同一时刻执行同一个代码块。</strong></p><p>由于这样的数据块和代码块的背后都隐含着一种或多种资源（比如存储资源、计算资源、I/O资源、网络资源等等），所以我们可以把它们看做是共享资源，或者说共享资源的代表。我们所说的同步其实就是在控制多个线程对共享资源的访问。</p><p>一个线程在想要访问某一个共享资源的时候，需要先申请对该资源的访问权限，并且只有在申请成功之后，访问才能真正开始。</p><p>而当线程对共享资源的访问结束时，它还必须归还对该资源的访问权限，若要再次访问仍需申请。</p><p>你可以把这里所说的访问权限想象成一块令牌，线程一旦拿到了令牌，就可以进入指定的区域，从而访问到资源，而一旦线程要离开这个区域了，就需要把令牌还回去，绝不能把令牌带走。</p><p>如果针对某个共享资源的访问令牌只有一块，那么在同一时刻，就最多只能有一个线程进入到那个区域，并访问到该资源。</p><p>这时，我们可以说，多个并发运行的线程对这个共享资源的访问是完全串行的。只要一个代码片段需要实现对共享资源的串行化访问，就可以被视为一个临界区（critical section），也就是我刚刚说的，由于要访问到资源而必须进入的那个区域。</p><p>比如，在我前面举的那个例子中，实现了数据块写入操作的代码就共同组成了一个临界区。如果针对同一个共享资源，这样的代码片段有多个，那么它们就可以被称为相关临界区。</p><p>它们可以是一个内含了共享数据的结构体及其方法，也可以是操作同一块共享数据的多个函数。临界区总是需要受到保护的，否则就会产生竞态条件。<strong>施加保护的重要手段之一，就是使用实现了某种同步机制的工具，也称为同步工具。</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/73/6c/73d3313640e62bb95855d40c988c2e6c.png?wh=1145*618\" alt=\"\"></p><p>（竞态条件、临界区与同步工具）</p><p><strong>在Go语言中，可供我们选择的同步工具并不少。其中，最重要且最常用的同步工具当属互斥量（mutual exclusion，简称mutex）。</strong><code>sync</code>包中的<code>Mutex</code>就是与其对应的类型，该类型的值可以被称为互斥量或者互斥锁。</p><p>一个互斥锁可以被用来保护一个临界区或者一组相关临界区。我们可以通过它来保证，在同一时刻只有一个goroutine处于该临界区之内。</p><p>为了兑现这个保证，每当有goroutine想进入临界区时，都需要先对它进行锁定，并且，每个goroutine离开临界区时，都要及时地对它进行解锁。</p><p>锁定操作可以通过调用互斥锁的<code>Lock</code>方法实现，而解锁操作可以调用互斥锁的<code>Unlock</code>方法。以下是demo58.go文件中重点代码经过简化之后的片段：</p><pre><code>mu.Lock()\n_, err := writer.Write([]byte(data))\nif err != nil {\n log.Printf(&quot;error: %s [%d]&quot;, err, id)\n}\nmu.Unlock()\n</code></pre><p>你可能已经看出来了，这里的互斥锁就相当于我们前面说的那块访问令牌。那么，我们怎样才能用好这块访问令牌呢？请看下面的问题。</p><p><strong>我们今天的问题是：我们使用互斥锁时有哪些注意事项？</strong></p><p>这里有一个典型回答。</p><p>使用互斥锁的注意事项如下：</p><ol>\n<li>不要重复锁定互斥锁；</li>\n<li>不要忘记解锁互斥锁，必要时使用<code>defer</code>语句；</li>\n<li>不要对尚未锁定或者已解锁的互斥锁解锁；</li>\n<li>不要在多个函数之间直接传递互斥锁。</li>\n</ol><h2>问题解析</h2><p>首先，你还是要把互斥锁看作是针对某一个临界区或某一组相关临界区的唯一访问令牌。</p><p>虽然没有任何强制规定来限制，你用同一个互斥锁保护多个无关的临界区，但是这样做，一定会让你的程序变得很复杂，并且也会明显地增加你的心智负担。</p><p>你要知道，对一个已经被锁定的互斥锁进行锁定，是会立即阻塞当前的goroutine的。这个goroutine所执行的流程，会一直停滞在调用该互斥锁的<code>Lock</code>方法的那行代码上。</p><p>直到该互斥锁的<code>Unlock</code>方法被调用，并且这里的锁定操作成功完成，后续的代码（也就是临界区中的代码）才会开始执行。这也正是互斥锁能够保护临界区的原因所在。</p><p>一旦，你把一个互斥锁同时用在了多个地方，就必然会有更多的goroutine争用这把锁。这不但会让你的程序变慢，还会大大增加死锁（deadlock）的可能性。</p><p>所谓的死锁，指的就是当前程序中的主goroutine，以及我们启用的那些goroutine都已经被阻塞。这些goroutine可以被统称为用户级的goroutine。这就相当于整个程序都已经停滞不前了。</p><p>Go语言运行时系统是不允许这种情况出现的，只要它发现所有的用户级goroutine都处于等待状态，就会自行抛出一个带有如下信息的panic：</p><pre><code>fatal error: all goroutines are asleep - deadlock!\n</code></pre><p><strong>注意，这种由Go语言运行时系统自行抛出的panic都属于致命错误，都是无法被恢复的，调用<code>recover</code>函数对它们起不到任何作用。也就是说，一旦产生死锁，程序必然崩溃。</strong></p><p>因此，我们一定要尽量避免这种情况的发生。而最简单、有效的方式就是让每一个互斥锁都只保护一个临界区或一组相关临界区。</p><p>在这个前提之下，我们还需要注意，对于同一个goroutine而言，既不要重复锁定一个互斥锁，也不要忘记对它进行解锁。</p><p>一个goroutine对某一个互斥锁的重复锁定，就意味着它自己锁死了自己。先不说这种做法本身就是错误的，在这种情况下，想让其他的goroutine来帮它解锁是非常难以保证其正确性的。</p><p>我以前就在团队代码库中见到过这样的代码。那个作者的本意是先让一个goroutine自己锁死自己，然后再让一个负责调度的goroutine定时地解锁那个互斥锁，从而让前一个goroutine周期性地去做一些事情，比如每分钟检查一次服务器状态，或者每天清理一次日志。</p><p>这个想法本身是没有什么问题的，但却选错了实现的工具。对于互斥锁这种需要精细化控制的同步工具而言，这样的任务并不适合它。</p><p>在这种情况下，即使选用通道或者<code>time.Ticker</code>类型，然后自行实现功能都是可以的，程序的复杂度和我们的心智负担也会小很多，更何况还有不少已经很完备的解决方案可供选择。</p><p>话说回来，其实我们说“不要忘记解锁互斥锁”的一个很重要的原因就是：<strong>避免重复锁定。</strong></p><p>因为在一个goroutine执行的流程中，可能会出现诸如“锁定、解锁、再锁定、再解锁”的操作，所以如果我们忘记了中间的解锁操作，那就一定会造成重复锁定。</p><p>除此之外，忘记解锁还会使其他的goroutine无法进入到该互斥锁保护的临界区，这轻则会导致一些程序功能的失效，重则会造成死锁和程序崩溃。</p><p>在很多时候，一个函数执行的流程并不是单一的，流程中间可能会有分叉，也可能会被中断。</p><p>如果一个流程在锁定了某个互斥锁之后分叉了，或者有被中断的可能，那么就应该使用<code>defer</code>语句来对它进行解锁，而且这样的<code>defer</code>语句应该紧跟在锁定操作之后。这是最保险的一种做法。</p><p>忘记解锁导致的问题有时候是比较隐秘的，并不会那么快就暴露出来。这也是我们需要特别关注它的原因。相比之下，解锁未锁定的互斥锁会立即引发panic。</p><p>并且，与死锁导致的panic一样，它们是无法被恢复的。<strong>因此，我们总是应该保证，对于每一个锁定操作，都要有且只有一个对应的解锁操作。</strong></p><p>换句话说，我们应该让它们成对出现。这也算是互斥锁的一个很重要的使用原则了。在很多时候，利用<code>defer</code>语句进行解锁可以更容易做到这一点。</p><p><img src=\"https://static001.geekbang.org/resource/image/4f/0d/4f86467d09ffca6e0c02602a9cb7480d.png?wh=1610*1052\" alt=\"\"></p><p>（互斥锁的重复锁定和重复解锁）</p><p>最后，可能你已经知道，Go语言中的互斥锁是开箱即用的。换句话说，一旦我们声明了一个<code>sync.Mutex</code>类型的变量，就可以直接使用它了。</p><p>不过要注意，该类型是一个结构体类型，属于值类型中的一种。把它传给一个函数、将它从函数中返回、把它赋给其他变量、让它进入某个通道都会导致它的副本的产生。</p><p>并且，原值和它的副本，以及多个副本之间都是完全独立的，它们都是不同的互斥锁。</p><p>如果你把一个互斥锁作为参数值传给了一个函数，那么在这个函数中对传入的锁的所有操作，都不会对存在于该函数之外的那个原锁产生任何的影响。</p><p>所以，你在这样做之前，一定要考虑清楚，这种结果是你想要的吗？我想，在大多数情况下应该都不是。即使你真的希望，在这个函数中使用另外一个互斥锁也不要这样做，这主要是为了避免歧义。</p><p>以上这些，就是我想要告诉你的关于互斥锁的锁定、解锁，以及传递方面的知识。这其中还包括了我的一些理解。希望能够对你有用。相关的例子我已经写在demo59.go文件中了，你可以去阅读一番，并运行起来看看。</p><h2>知识扩展</h2><p>问题1：读写锁与互斥锁有哪些异同？</p><p>读写锁是读/写互斥锁的简称。在Go语言中，读写锁由<code>sync.RWMutex</code>类型的值代表。与<code>sync.Mutex</code>类型一样，这个类型也是开箱即用的。</p><p>顾名思义，读写锁是把对共享资源的“读操作”和“写操作”区别对待了。它可以对这两种操作施加不同程度的保护。换句话说，相比于互斥锁，读写锁可以实现更加细腻的访问控制。</p><p>一个读写锁中实际上包含了两个锁，即：读锁和写锁。<code>sync.RWMutex</code>类型中的<code>Lock</code>方法和<code>Unlock</code>方法分别用于对写锁进行锁定和解锁，而它的<code>RLock</code>方法和<code>RUnlock</code>方法则分别用于对读锁进行锁定和解锁。</p><p>另外，对于同一个读写锁来说有如下规则。</p><ol>\n<li>在写锁已被锁定的情况下再试图锁定写锁，会阻塞当前的goroutine。</li>\n<li>在写锁已被锁定的情况下试图锁定读锁，也会阻塞当前的goroutine。</li>\n<li>在读锁已被锁定的情况下试图锁定写锁，同样会阻塞当前的goroutine。</li>\n<li>在读锁已被锁定的情况下再试图锁定读锁，并不会阻塞当前的goroutine。</li>\n</ol><p>换一个角度来说，对于某个受到读写锁保护的共享资源，多个写操作不能同时进行，写操作和读操作也不能同时进行，但多个读操作却可以同时进行。</p><p>当然了，只有在我们正确使用读写锁的情况下，才能达到这种效果。还是那句话，我们需要让每一个锁都只保护一个临界区，或者一组相关临界区，并以此尽量减少误用的可能性。顺便说一句，我们通常把这种不能同时进行的操作称为互斥操作。</p><p>再来看另一个方面。对写锁进行解锁，会唤醒“所有因试图锁定读锁，而被阻塞的goroutine”，并且，这通常会使它们都成功完成对读锁的锁定。</p><p>然而，对读锁进行解锁，只会在没有其他读锁锁定的前提下，唤醒“因试图锁定写锁，而被阻塞的goroutine”；并且，最终只会有一个被唤醒的goroutine能够成功完成对写锁的锁定，其他的goroutine还要在原处继续等待。至于是哪一个goroutine，那就要看谁的等待时间最长了。</p><p>除此之外，读写锁对写操作之间的互斥，其实是通过它内含的一个互斥锁实现的。因此，也可以说，Go语言的读写锁是互斥锁的一种扩展。</p><p>最后，需要强调的是，与互斥锁类似，解锁“读写锁中未被锁定的写锁”，会立即引发panic，对于其中的读锁也是如此，并且同样是不可恢复的。</p><p>总之，读写锁与互斥锁的不同，都源于它把对共享资源的写操作和读操作区别对待了。这也使得它实现的互斥规则要更复杂一些。</p><p>不过，正因为如此，我们可以使用它对共享资源的操作，实行更加细腻的控制。另外，由于这里的读写锁是互斥锁的一种扩展，所以在有些方面它还是沿用了互斥锁的行为模式。比如，在解锁未锁定的写锁或读锁时的表现，又比如，对写操作之间互斥的实现方式。</p><h2>总结</h2><p>我们今天讨论了很多与多线程、共享资源以及同步有关的知识。其中涉及了不少重要的并发编程概念，比如，竞态条件、临界区、互斥量、死锁等。</p><p>虽然Go语言是以“用通讯的方式共享数据”为亮点的，但是它依然提供了一些易用的同步工具。其中，互斥锁是我们最常用到的一个。</p><p>互斥锁常常被用来：保证多个goroutine并发地访问同一个共享资源时的完全串行，这是通过保护针对此共享资源的一个临界区，或一组相关临界区实现的。因此，我们可以把它看做是goroutine进入相关临界区时，必须拿到的访问令牌。</p><p>为了用对并且用好互斥锁，我们需要了解它实现的互斥规则，更要理解一些关于它的注意事项。</p><p>比如，不要重复锁定或忘记解锁，因为这会造成goroutine不必要的阻塞，甚至导致程序的死锁。</p><p>又比如，不要传递互斥锁，因为这会产生它的副本，从而引起歧义并可能导致互斥操作的失效。</p><p>再次强调，我们总是应该让每一个互斥锁都只保护一个临界区，或一组相关临界区。</p><p>至于读写锁，它是互斥锁的一种扩展。我们需要知道它与互斥锁的异同，尤其是互斥规则和行为模式方面的异同。一个读写锁中同时包含了读锁和写锁，由此也可以看出它对于针对共享资源的读操作和写操作是区别对待的。我们可以基于这件事，对共享资源实施更加细致的访问控制。</p><p>最后，需要特别注意的是，无论是互斥锁还是读写锁，我们都不要试图去解锁未锁定的锁，因为这样会引发不可恢复的panic。</p><h2>思考题</h2><ol>\n<li>你知道互斥锁和读写锁的指针类型都实现了哪一个接口吗？</li>\n<li>怎样获取读写锁中的读锁？</li>\n</ol><p><a href=\"https://github.com/hyper0x/Golang_Puzzlers\">戳此查看Go语言专栏文章配套详细代码。</a></p><p></p>","neighbors":{"left":{"article_title":"25 | 更多的测试手法","id":41255},"right":{"article_title":"27 | 条件变量sync.Cond （上）","id":41588}},"comments":[{"had_liked":false,"id":31298,"user_name":"属雨","can_delete":false,"product_type":"c1","uid":1202624,"ip_address":"","ucode":"700236847A5C94","user_header":"https://static001.geekbang.org/account/avatar/00/12/59/c0/6f02c096.jpg","comment_is_top":false,"comment_ctime":1539144466,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"130388163346","product_id":100013101,"comment_content":"第一个问题：<br>Lock接口。<br>第二个问题：<br>变量.Rlock()","like_count":30,"discussions":[{"author":{"id":1272825,"avatar":"https://static001.geekbang.org/account/avatar/00/13/6b/f9/da3ee7a8.jpg","nickname":"Onyanga","note":"","ucode":"DF4D22F0D51881","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300406,"discussion_content":"RLocker","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1598083807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1336951,"avatar":"https://static001.geekbang.org/account/avatar/00/14/66/77/194ba21d.jpg","nickname":"lzh","note":"","ucode":"C3D83DF4230109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362833,"discussion_content":"RLock()","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617035421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82774,"user_name":"阳仔","can_delete":false,"product_type":"c1","uid":1046920,"ip_address":"","ucode":"79F73D85EDF3E2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/88/cdda9e6f.jpg","comment_is_top":false,"comment_ctime":1554303732,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"117518420724","product_id":100013101,"comment_content":"学习将近一半的课程了发现:<br>1. 内容不够简洁，很多知识点其实画图出来更容易让读者理解<br>2. 感觉不大适合初学者，反而对已经入门有一定经验的学习者会帮助更大一些<br>3. 可以看出来作者是非常精通go的","like_count":27,"discussions":[{"author":{"id":1203834,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5e/7a/028dc1a9.jpg","nickname":"修罗","note":"","ucode":"9C25F94C40285F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":191966,"discussion_content":"同意","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583050555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1210386,"avatar":"https://static001.geekbang.org/account/avatar/00/12/78/12/7df38a54.jpg","nickname":"helloworld2018","note":"","ucode":"2AE40C0DF5A9F7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560939,"discussion_content":"写的太啰嗦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649494956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2948592,"avatar":"","nickname":"woJA1wCgAA_-wbFKSNXFkMtE_zcssu9g","note":"","ucode":"3F0EFFE9DB2E2B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557810,"discussion_content":"确实有很些细节可能没举例到，但是全文真的满满的干货。看了一段时间go知识了，看了这篇，收获还是挺大的，一种知识验证的感觉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647962679,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2806043,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLBFkSq1oiaEMRjtyyv4ZpCI0OuaSsqs04ODm0OkZF6QhsAh3SvqhxibS2n7PLAVZE3QRSn5Hic0DyXg/132","nickname":"ddh","note":"","ucode":"8E852375365F16","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541070,"discussion_content":"看了这个课程， 我觉得作者有大才","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640248598,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31480,"user_name":"Geek_cd5dcf","can_delete":false,"product_type":"c1","uid":1074596,"ip_address":"","ucode":"4B6499FBABA8BC","user_header":"","comment_is_top":false,"comment_ctime":1539217030,"is_pvip":false,"replies":[{"id":"11820","content":"对，不会，这是defer的机制保证的。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1539577295,"ip_address":"","comment_id":31480,"utype":1}],"discussion_count":6,"race_medal":0,"score":"83143595654","product_id":100013101,"comment_content":"讲的通俗易懂，还是挺好理解的，想问下mutex如果加锁后<br>mutex.lock（）<br>defer mutex.unlock（）<br>在所有场景下都不会出错吗？","like_count":19,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426362,"discussion_content":"对，不会，这是defer的机制保证的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539577295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1295596,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIBJYQ73yYqmiaU7Zg0BHPh9gpSglI79Dzcbob7I2tZOhTjbTTCw13KzVusYhLbKkukV9Ru5UfJMxQ/132","nickname":"Geek_2d276a","note":"","ucode":"866B39EBE71356","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294157,"discussion_content":"想确认一下，这个defer的执行时机是，当前函数返回时吗？共享临界区是否会跨函数存在，即加锁和解锁不在同一函数中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595812090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1083782,"avatar":"https://static001.geekbang.org/account/avatar/00/10/89/86/4a7b4d03.jpg","nickname":"王翔","note":"","ucode":"5F967EA510E231","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":20519,"discussion_content":"我认为不是这样的。如果这个函数在内部如果还有其他的函数调用，如果被调用的函数也有相同的mutex.Lock()就会导致死锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569324348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1807836,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/95/dc/07195a63.jpg","nickname":"锋","note":"","ucode":"F26BC1F14AB0D7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1083782,"avatar":"https://static001.geekbang.org/account/avatar/00/10/89/86/4a7b4d03.jpg","nickname":"王翔","note":"","ucode":"5F967EA510E231","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":198126,"discussion_content":"锁套锁的设计一般很少会用，很容易造成死锁\n\n并且如果你是函数传递的mutex，那么被调用函数里面的mutex跟当前这个mutex也不是同一个啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583476725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":20519,"ip_address":""},"score":198126,"extra":""},{"author":{"id":1295596,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIBJYQ73yYqmiaU7Zg0BHPh9gpSglI79Dzcbob7I2tZOhTjbTTCw13KzVusYhLbKkukV9Ru5UfJMxQ/132","nickname":"Geek_2d276a","note":"","ucode":"866B39EBE71356","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1807836,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/95/dc/07195a63.jpg","nickname":"锋","note":"","ucode":"F26BC1F14AB0D7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294155,"discussion_content":"不用函数传递，互斥锁就是一全局变量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595811833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":198126,"ip_address":""},"score":294155,"extra":""},{"author":{"id":2630632,"avatar":"https://static001.geekbang.org/account/avatar/00/28/23/e8/9f445339.jpg","nickname":"章潘","note":"","ucode":"1A24E1B3084450","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1083782,"avatar":"https://static001.geekbang.org/account/avatar/00/10/89/86/4a7b4d03.jpg","nickname":"王翔","note":"","ucode":"5F967EA510E231","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":584037,"discussion_content":"郝大一再强调小心用锁，不要重复加锁。如果非得嵌套，只能说明  扛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660570829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":20519,"ip_address":"广东"},"score":584037,"extra":""}]}]},{"had_liked":false,"id":76741,"user_name":"🐻","can_delete":false,"product_type":"c1","uid":1043072,"ip_address":"","ucode":"534EDAD496A0E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ea/80/8759e4c1.jpg","comment_is_top":false,"comment_ctime":1552699147,"is_pvip":false,"replies":[{"id":"28877","content":"√","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1553399050,"ip_address":"","comment_id":76741,"utype":1}],"discussion_count":1,"race_medal":0,"score":"61682241291","product_id":100013101,"comment_content":"1. Locker 接口<br>2. func (rw *RWMutex) RLocker() Locker","like_count":14,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443427,"discussion_content":"√","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553399050,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185563,"user_name":"Pana","can_delete":false,"product_type":"c1","uid":1016571,"ip_address":"","ucode":"6E016D4966B187","user_header":"https://static001.geekbang.org/account/avatar/00/0f/82/fb/9d232a7a.jpg","comment_is_top":false,"comment_ctime":1583634451,"is_pvip":false,"replies":[{"id":"71693","content":"如果CPU只有一个核心，那么就不会有真正的并行计算了。但是，并发还是会有的。这是因为仍然可以同时有多个goroutine存在（它们可以同时处于可运行状态），只不过Go语言的运行时系统无法让它们在同一时刻都运行罢了。<br><br>并发和并行这两个词的含义是不同的，需要我们分清楚。简单来说，并发是指在同一个时间段内提交多个任务给系统，并行是指在同一时刻系统能执行多个任务。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1583649450,"ip_address":"","comment_id":185563,"utype":1}],"discussion_count":2,"race_medal":0,"score":"31648405523","product_id":100013101,"comment_content":"如果cpu只有一个核心，是不是就不会产生并发的情况？","like_count":7,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486416,"discussion_content":"如果CPU只有一个核心，那么就不会有真正的并行计算了。但是，并发还是会有的。这是因为仍然可以同时有多个goroutine存在（它们可以同时处于可运行状态），只不过Go语言的运行时系统无法让它们在同一时刻都运行罢了。\n\n并发和并行这两个词的含义是不同的，需要我们分清楚。简单来说，并发是指在同一个时间段内提交多个任务给系统，并行是指在同一时刻系统能执行多个任务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583649450,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188793,"avatar":"https://static001.geekbang.org/account/avatar/00/12/23/b9/8d182f13.jpg","nickname":"起风了","note":"","ucode":"9A8A2E51E198EE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291323,"discussion_content":"并行是让多个处理器或者多核处理器同时执行多个任务，同一时间有多个任务调度。\n并发是 CPU 内核通过时间片或中断来控制，遇到 IO 阻塞或者时间片用完时会交出线程的使用权，从而实现一个内核上处理多个任务。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1594780231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135282,"user_name":"安排","can_delete":false,"product_type":"c1","uid":1260026,"ip_address":"","ucode":"F78CFA9624CAEF","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg","comment_is_top":false,"comment_ctime":1569117170,"is_pvip":false,"replies":[{"id":"51902","content":"传统的协程只是线程内的流程控制工具。它没法做到一个线程内有两个及以上控制流同时进行，只能是这一个挂起那一个运行然后那一个挂起这一个再运行。同时它也不属于多线程编程，没法统一调度多个线程内的控制流。<br><br>goroutine 我就不用多说了，它属于用户级线程，与系统级线程搭配使用，很强大也很灵活。深入的东西可以看我的那本《Go 并发编程实战》。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1569125460,"ip_address":"","comment_id":135282,"utype":1}],"discussion_count":3,"race_medal":0,"score":"23043953650","product_id":100013101,"comment_content":"goroutine和协程有什么本质区别啊，搜了网上也没看出来啥本质区别，有这方面的资料吗？","like_count":5,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468125,"discussion_content":"传统的协程只是线程内的流程控制工具。它没法做到一个线程内有两个及以上控制流同时进行，只能是这一个挂起那一个运行然后那一个挂起这一个再运行。同时它也不属于多线程编程，没法统一调度多个线程内的控制流。\n\ngoroutine 我就不用多说了，它属于用户级线程，与系统级线程搭配使用，很强大也很灵活。深入的东西可以看我的那本《Go 并发编程实战》。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569125460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3042134,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/6b/56/dce3cda9.jpg","nickname":"韩勇","note":"","ucode":"6412857673E60D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579902,"discussion_content":"Goroutine和其他语言的协程（coroutine）在使用方式上类似，但从字面意义上来看不同（一个是Goroutine，一个是coroutine），再就是协程是一种协作任务控制机制，在最简单的意义上，协程不是并发的，而Goroutine支持并发的。因此Goroutine可以理解为一种Go语言的协程。同时它可以运行在一个或多个线程上。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1657764787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1336951,"avatar":"https://static001.geekbang.org/account/avatar/00/14/66/77/194ba21d.jpg","nickname":"lzh","note":"","ucode":"C3D83DF4230109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362834,"discussion_content":"协程是线程实现多任务，一个任务称为一个协程。goroutine是实现协程的一种方式，通过G与M的结合实现多任务，除了goroutine，实现协程还有yield。个人理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617035626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95224,"user_name":"Hector","can_delete":false,"product_type":"c1","uid":1496889,"ip_address":"","ucode":"110CAF87ADDC01","user_header":"https://static001.geekbang.org/account/avatar/00/16/d7/39/6698b6a9.jpg","comment_is_top":false,"comment_ctime":1557991536,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23032828016","product_id":100013101,"comment_content":"读写锁总结，1、可以随便读，即使加锁多个goroutine同时读  2、加锁写的时候，啥也不能干，不能写。即使没加读锁也不能读。老师写的有点绕蒙了。<br>引用原文：对写锁进行解锁，会唤醒“所有因试图锁定读锁，而被阻塞的 goroutine”，并且，这通常会使它们都成功完成对读锁的锁定。意思就是在对资源的写锁进行解锁时，原来你在对该资源上写锁的时候，所有的读锁会锁定来配合写操作，直到写锁解除锁定时，这些读锁才会解锁。","like_count":5,"discussions":[{"author":{"id":1071316,"avatar":"https://static001.geekbang.org/account/avatar/00/10/58/d4/c52f9f6d.jpg","nickname":"芝士老爹","note":"","ucode":"5F2935967574D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3821,"discussion_content":"还是把老师讲的理解透彻吧，我觉得还是应该把阻塞和锁定区别开来：因为资源被锁了，所以其他G再去锁定，就会被阻塞，等待解锁操作来唤醒。。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1564845669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":291559,"user_name":"授人以🐟，不如授人以渔","can_delete":false,"product_type":"c1","uid":1193874,"ip_address":"","ucode":"BD53829E924B66","user_header":"https://static001.geekbang.org/account/avatar/00/12/37/92/961ba560.jpg","comment_is_top":false,"comment_ctime":1620362438,"is_pvip":true,"replies":[{"id":"105653","content":"1. 我又看了下源码。这是为了避免“迭代读锁定”的问题。这个问题最终会导致当前读写锁永不可用。你想想，如果一个 goroutine 一直在不断地读锁定同一个读写锁，那么想要写锁定这个读写锁的 goroutine 就会永远阻塞在那里。<br><br>2. main goroutine 释放读锁之后，goroutine 1 会首先得到写锁定的机会。这同样是为了避免“迭代读锁定”。因为如果先给 goroutine 2 机会，那 goroutine 1 的写锁定不是还得等吗？要真是这样的话，假如 main goroutine 和 goroutine 1 都在不断地试图读锁定，那么 goroutine 2 就会一直阻塞下去。<br><br>所以说，如果这个事情让你的程序停滞了，那么你就要检查一下程序中是不是有“迭代读锁定”的情况。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1620458198,"ip_address":"","comment_id":291559,"utype":1}],"discussion_count":4,"race_medal":0,"score":"18800231622","product_id":100013101,"comment_content":"老师，麻烦分析一下这样的场景：main goroutine 拿到读锁，此时 goroutine 1 试图拿到写锁但被阻塞，紧接着 goroutine 2 试图拿到读锁。我想知道 goroutine 2 为什么也会被阻塞，另外 main goroutine 读锁被释放后，哪个 goroutine 会继续运行？","like_count":4,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519507,"discussion_content":"1. 我又看了下源码。这是为了避免“迭代读锁定”的问题。这个问题最终会导致当前读写锁永不可用。你想想，如果一个 goroutine 一直在不断地读锁定同一个读写锁，那么想要写锁定这个读写锁的 goroutine 就会永远阻塞在那里。\n\n2. main goroutine 释放读锁之后，goroutine 1 会首先得到写锁定的机会。这同样是为了避免“迭代读锁定”。因为如果先给 goroutine 2 机会，那 goroutine 1 的写锁定不是还得等吗？要真是这样的话，假如 main goroutine 和 goroutine 1 都在不断地试图读锁定，那么 goroutine 2 就会一直阻塞下去。\n\n所以说，如果这个事情让你的程序停滞了，那么你就要检查一下程序中是不是有“迭代读锁定”的情况。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1620458198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1460961,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4a/e1/2a498473.jpg","nickname":"李威","note":"","ucode":"3409A9390BD1FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389963,"discussion_content":"这里的“迭代读锁定”是sync\\rwmutex.go源码中的recursive read locking","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629541556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2647265,"avatar":"https://static001.geekbang.org/account/avatar/00/28/64/e1/97fba9a0.jpg","nickname":"Jesse Stutler","note":"","ucode":"9E172A6635EB48","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543782,"discussion_content":"翻译成“饥饿”可能更好一点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641301683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1650748,"avatar":"https://static001.geekbang.org/account/avatar/00/19/30/3c/0668d6ae.jpg","nickname":"盘胧","note":"","ucode":"5386CC4C92ECC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394242,"discussion_content":"是有点翻译的刻板了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631799110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34513,"user_name":"sky","can_delete":false,"product_type":"c1","uid":1082187,"ip_address":"","ucode":"FC323371453C97","user_header":"https://static001.geekbang.org/account/avatar/00/10/83/4b/0e96fcae.jpg","comment_is_top":false,"comment_ctime":1540196257,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18720065441","product_id":100013101,"comment_content":"郝大 关于demo59这个案例能大概描述下具体的功能流程吗 代码看起来没有方向感啊 ","like_count":4,"discussions":[{"author":{"id":1099513,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c6/f9/caf27bd3.jpg","nickname":"大王叫我来巡山","note":"","ucode":"1B8D0C701BC95E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":10879,"discussion_content":"你不明白的只是通道的那部分代码，那部分代码只是为了保证主协程的最后退出，另外写数据的那部分代码你也可以不要，只用写个header就好了，这样就清晰了，最粗暴的做法就是把通道那段代码拿掉，然后让主协程sleep","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568332980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202418,"user_name":"NoTryNoSuccess","can_delete":false,"product_type":"c1","uid":1372735,"ip_address":"","ucode":"89EE8B4CEECC1F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKOM6tVLSiciaQeQst0g3iboWO74ibicicVAia9qno0X6cf65pEKLgdKkUdcpCWpjAB5e6semrFrruiaGQWhg/132","comment_is_top":false,"comment_ctime":1585986035,"is_pvip":false,"replies":[{"id":"75959","content":"互斥锁、条件变量和原子操作都是由操作系统和CPU指令集支撑的，所以Go语言的这些同步工具是可以在多线程以及多核CPU甚至多CPU上正确执行的。无需担心。相反，这些同步工具恰恰针对的就是并发和并行的应用场景。这正是它们的用武之地啊。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1586173951,"ip_address":"","comment_id":202418,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14470887923","product_id":100013101,"comment_content":"请问老师，多核心条件下如果两个goroutine底层同时运行在两个线程上，那么此时这两个goroutine实际上是完全并行的。此时它们如果同时进行互斥锁的锁定操作（随后可能同时对同一资源进行写操作）岂不是不能达到对临界区的保护目的了吗？","like_count":4,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490578,"discussion_content":"互斥锁、条件变量和原子操作都是由操作系统和CPU指令集支撑的，所以Go语言的这些同步工具是可以在多线程以及多核CPU甚至多CPU上正确执行的。无需担心。相反，这些同步工具恰恰针对的就是并发和并行的应用场景。这正是它们的用武之地啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586173951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1199601,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4d/f1/a56fefba.jpg","nickname":"bin","note":"","ucode":"B5AC8B5993AB76","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273475,"discussion_content":"老师，如果是分布式的呢？也能达到锁定效果吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590460047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1336951,"avatar":"https://static001.geekbang.org/account/avatar/00/14/66/77/194ba21d.jpg","nickname":"lzh","note":"","ucode":"C3D83DF4230109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1199601,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4d/f1/a56fefba.jpg","nickname":"bin","note":"","ucode":"B5AC8B5993AB76","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362835,"discussion_content":"……分布式肯定用分布式锁啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617035859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":273475,"ip_address":""},"score":362835,"extra":""}]}]},{"had_liked":false,"id":200626,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1585626061,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14470527949","product_id":100013101,"comment_content":"今日总结<br>今天主要是讲了 关于并发同步问题<br>两种方式<br>1. 互斥锁 sync&#47;Mutex<br>   保证他们对同一个临界区的访问是串行的<br>2. 读写锁 <br>   分为读锁和写锁<br>   当读写锁定时 任何尝试的写的锁都会被阻塞 而其他的读却不会 原因在于写的时候会改变内存区域的数据<br> 当写锁锁定时 无论是读还是写加锁都会阻塞  原因同上<br>当写锁进行解锁时 会唤醒所有读锁阻塞的goroutine <br>而读锁解锁时 会唤醒某一个写锁 具体是哪一个写锁 就看那个写锁等待的事件最长<br>尤其要注意 <br>一个锁应该只保护一个临界区域<br>不要尝试重复锁定(有可能会导致死锁) 引发系统运行时自动的panic 并且这个panic无法被恢复<br>不要对未加锁的锁进行 会引发panic 并且无法恢复<br>不要传递锁 因为锁时结构体类型 传递时 是值传递 会产生很多副本 导致 锁不是一个锁了<br>一定要释放锁 最好的办法还是 defer语句解锁 加锁和解锁语句成对出现<br>关于思考题<br>Lock接口<br>2func (rw *RWMutex) RLocker() Locker","like_count":3},{"had_liked":false,"id":172410,"user_name":"CcczzZ","can_delete":false,"product_type":"c1","uid":1019568,"ip_address":"","ucode":"5F46DA5053D2BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/b0/ef201991.jpg","comment_is_top":false,"comment_ctime":1579171703,"is_pvip":false,"replies":[{"id":"66904","content":"简单一句话：读写锁中的读锁锁定操作之间是不互斥的。另外，对于读写锁，读锁锁定操作会与写锁锁定操作互斥，写锁锁定操作之间也会互斥。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1579228427,"ip_address":"","comment_id":172410,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14464073591","product_id":100013101,"comment_content":"老师，有个疑问，文中说的这句：「对读锁进行解锁，只会在没有其他读锁锁定的前提下，唤醒“因试图锁定写锁，而被阻塞的 goroutine”」。<br>我的理解是，对读锁进行解锁时，此刻若存在其他读锁等待的话，是会优先唤醒读锁的，如果不存在其他等待的读锁，才会唤醒写锁。不知道这样理解是否正确？<br><br>而基于上面的理解，我写了段代码测试了一下，发现结果并不是这样，实际情况是：「当读锁进行解锁时，若此刻存在其他的读锁和写锁，会根据他们实际阻塞等待的时间长短，优先唤醒并执行」<br>就像下面，写锁在前面执行，等待的时间也比读锁场，所以当读锁解锁时，优先唤醒的是等待时间较长的写锁。<br><br>func main() {<br><br>    var rwMu sync.RWMutex<br><br>    &#47;&#47; 模拟多个写&#47;读锁进行阻塞，当释放读锁的时候看谁先获取到锁（会在没有其他读锁的时候，唤醒写锁）<br><br>    rwMu.RLock()<br>    fmt.Println(&quot;start RLock&quot;)<br><br>    &#47;&#47; 写<br>    go func() {<br>        defer func() {<br>            rwMu.Unlock()<br>            fmt.Println(&quot;get UnLock&quot;)<br>        }()<br>        rwMu.Lock()<br>        fmt.Println(&quot;get Lock&quot;)<br>    }()<br>    time.Sleep(time.Millisecond * 200)<br><br>    &#47;&#47; 读<br>    go func() {<br>        defer func() {<br>            rwMu.RUnlock()<br>            fmt.Println(&quot;get RUnLock&quot;)<br>        }()<br>        rwMu.RLock()<br>        fmt.Println(&quot;get RLock&quot;)<br>    }()<br>    time.Sleep(time.Millisecond * 200)<br><br>    rwMu.RUnlock()<br>    fmt.Println(&quot;start RUnLock&quot;)<br>    time.Sleep(time.Second * 1)<br>}<br><br>运行结果（等待时间较长的写操作先执行了）：<br>start RLock<br>start RUnLock<br>get Lock<br>get UnLock<br>get RLock<br>get RUnLock","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481734,"discussion_content":"简单一句话：读写锁中的读锁锁定操作之间是不互斥的。另外，对于读写锁，读锁锁定操作会与写锁锁定操作互斥，写锁锁定操作之间也会互斥。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579228427,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1019568,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8e/b0/ef201991.jpg","nickname":"CcczzZ","note":"","ucode":"5F46DA5053D2BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":137064,"discussion_content":"我大概知道问题在哪里了😂 忘了下面这个知识点\n\n读写锁，当有读锁时，其他读锁此时并不会被阻塞！","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1579177067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1193874,"avatar":"https://static001.geekbang.org/account/avatar/00/12/37/92/961ba560.jpg","nickname":"授人以🐟，不如授人以渔","note":"","ucode":"BD53829E924B66","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372516,"discussion_content":"CcczzZ，你上面贴出来的代码是没问题的！原因是：Lock() 先于 RLock() 执行，此时 两个用户 goroutine 都会被阻塞。那如果你把 写和读的  goroutine 交换位置，结果的输出就会不同。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1620362063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":38593,"user_name":"Leon📷","can_delete":false,"product_type":"c1","uid":1219496,"ip_address":"","ucode":"B9BBD1EFAAE5A2","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg","comment_is_top":false,"comment_ctime":1542078731,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14426980619","product_id":100013101,"comment_content":"老师，我想问下多协程并发情况怎么调试日志，google官方似乎也不推荐我们在日志中把协程号打印出来，只能通过添加唯一序列号识别吗","like_count":3,"discussions":[{"author":{"id":1071316,"avatar":"https://static001.geekbang.org/account/avatar/00/10/58/d4/c52f9f6d.jpg","nickname":"芝士老爹","note":"","ucode":"5F2935967574D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3822,"discussion_content":"协程号打印出来没啥意义吧！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564845769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173128,"user_name":"Geek_b5876e","can_delete":false,"product_type":"c1","uid":1649594,"ip_address":"","ucode":"DE272DE44DCF03","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK66wjYZxVSnSJ33hbBCzSgHXsyQia8JrvJvibeH6Fcficu1lx83K0gzc3lpcxYllqH9ficibqanqKWGrA/132","comment_is_top":false,"comment_ctime":1579429367,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10169363959","product_id":100013101,"comment_content":"通过strace观察了一下锁的系统调用，发现了 futex ，go 语言锁的实现也是依赖于操作系统原语和信号量的","like_count":2},{"had_liked":false,"id":133041,"user_name":"大王叫我来巡山","can_delete":false,"product_type":"c1","uid":1099513,"ip_address":"","ucode":"1B8D0C701BC95E","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/f9/caf27bd3.jpg","comment_is_top":false,"comment_ctime":1568334281,"is_pvip":false,"replies":[{"id":"51014","content":"对于非缓冲通道，写的 goroutine 必然会先完成操作。锁本身只保证互斥。被阻塞的 goroutine 也会有先有后，但会根据被阻塞那一刻的先后，而不是什么读写的先后。<br><br>另外互斥锁跟原子操作有本质上的区别，不要搞混。<br><br>再另外，goroutine 与协程也有本质上的区别，不要搞混。<br><br>","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1568437840,"ip_address":"","comment_id":133041,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10158268873","product_id":100013101,"comment_content":"需要请教老师的是，主协程收到信号就被唤醒了，认为可以读了，但是被阻塞的写协程收到锁释放的消息会不会比主协程要早，然后继续获得写的机会，主协程会不会被阻塞？我认为是不会的，此处的锁只是保证了不同写协程互斥的写入，也就是写操作是原子的，但是并不保证读操作一定在写完后就读吧","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467234,"discussion_content":"对于非缓冲通道，写的 goroutine 必然会先完成操作。锁本身只保证互斥。被阻塞的 goroutine 也会有先有后，但会根据被阻塞那一刻的先后，而不是什么读写的先后。\n\n另外互斥锁跟原子操作有本质上的区别，不要搞混。\n\n再另外，goroutine 与协程也有本质上的区别，不要搞混。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568437840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1099513,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c6/f9/caf27bd3.jpg","nickname":"大王叫我来巡山","note":"","ucode":"1B8D0C701BC95E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":11864,"discussion_content":"谢谢老师，看明白了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568437916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120378,"user_name":"芝士老爹","can_delete":false,"product_type":"c1","uid":1071316,"ip_address":"","ucode":"5F2935967574D0","user_header":"https://static001.geekbang.org/account/avatar/00/10/58/d4/c52f9f6d.jpg","comment_is_top":false,"comment_ctime":1564849040,"is_pvip":false,"replies":[{"id":"44306","content":"那要看谁先等待了，这里的等待队列是先进先出的。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1564973131,"ip_address":"","comment_id":120378,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10154783632","product_id":100013101,"comment_content":"如果一直有新的读锁请求，会不会导致写锁锁不了？<br>还是说如果有了一个wlock锁请求了，现在因为有rlock未释放锁，wlock的协程被阻塞，后面再有新的rlock锁请求也会先被阻塞，等待wlock锁协程先恢复？","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461307,"discussion_content":"那要看谁先等待了，这里的等待队列是先进先出的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564973131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008348,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/dc/8876c73b.jpg","nickname":"moooofly","note":"","ucode":"4A20795C281B6F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7950,"discussion_content":"上面的读者的问题应该是说：当前处于 rlock 锁定状态，之后有来了一个 wlock ，如果这时再来一个或 N 个 rlock 上锁，那么当第一个 rlock 被解锁时，是 wlock 被唤醒，还是由于有新的 rlock 存在的原因，导致 wlock 仍旧无法被唤醒；\n\n按照作者的文章中的说法，我觉得应该是只要当 rlock 被解锁时，发现仍旧存在其他 rlock ，那么 wlock 就无法被唤醒；因为 rlock 并不会阻塞其他 rlock ，因此 rlock 时没有排队概念的，而 wlock 会阻塞其他 wlock ，所以有排队概念；","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1567736793,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008348,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/dc/8876c73b.jpg","nickname":"moooofly","note":"","ucode":"4A20795C281B6F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7944,"discussion_content":"&#34;对读锁进行解锁，只会在没有其他读锁锁定的前提下，唤醒“因试图锁定写锁，而被阻塞的 goroutine”；并且，最终只会有一个被唤醒的 goroutine 能够成功完成对写锁的锁定，其他的 goroutine 还要在原处继续等待。至于是哪一个 goroutine，那就要看谁的等待时间最长了。&#34;--我对上面这段话的理解是：如果存在 N 个 rlock 处于锁定状态（N>1），并且存在 M 个 wlock 处于锁定状态（M>1），则对一个 rlock 解锁，无法唤醒其他 wlock ，只有 N 个 rlock 都被解锁后，wlock 才会被唤醒，并且 wlock 的唤醒顺序是看其在队列中的顺序的，先进的先唤醒；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567736463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99696,"user_name":"soooldier","can_delete":false,"product_type":"c1","uid":1000746,"ip_address":"","ucode":"04EC4C01DD06FD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/45/2a/c4413de4.jpg","comment_is_top":false,"comment_ctime":1559281654,"is_pvip":false,"replies":[{"id":"35823","content":"看这里吧：https:&#47;&#47;github.com&#47;hyper0x&#47;Golang_Puzzlers&#47;tree&#47;master&#47;src&#47;puzzlers&#47;article22<br><br>你可以把这里的 article 理解成 topic。一些比较长的 topic 可能会被编辑拆分为多篇文章，所以就出现了这种情况。太长的文章对读者们不太友好，不容易集中精力读下去。<br><br>你可以对照着专栏的目录，按照主题，找一下对应的 articleXX 目录。<br><br>Update:<br>我刚刚添加了一个序号映射表：https:&#47;&#47;github.com&#47;hyper0x&#47;Golang_Puzzlers&#47;blob&#47;master&#47;mapping_table.md 。你用这个就可以方便地对照了。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1559292144,"ip_address":"","comment_id":99696,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10149216246","product_id":100013101,"comment_content":"配套代码里puzzlers&#47;article26下并没有demo58.go，也没有demo59.go，懵圈中。。。","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452229,"discussion_content":"看这里吧：https://github.com/hyper0x/Golang_Puzzlers/tree/master/src/puzzlers/article22\n\n你可以把这里的 article 理解成 topic。一些比较长的 topic 可能会被编辑拆分为多篇文章，所以就出现了这种情况。太长的文章对读者们不太友好，不容易集中精力读下去。\n\n你可以对照着专栏的目录，按照主题，找一下对应的 articleXX 目录。\n\nUpdate:\n我刚刚添加了一个序号映射表：https://github.com/hyper0x/Golang_Puzzlers/blob/master/mapping_table.md 。你用这个就可以方便地对照了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559292144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32472,"user_name":"timmy21","can_delete":false,"product_type":"c1","uid":1174860,"ip_address":"","ucode":"9D6DED247B1F38","user_header":"https://static001.geekbang.org/account/avatar/00/11/ed/4c/8674b6ad.jpg","comment_is_top":false,"comment_ctime":1539584182,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10129518774","product_id":100013101,"comment_content":"郝老师，之前问了一个是否需要上锁的问题。有一个细节我忘说了，一个写者，一个读者，并且“读者”读取变量时不需要保证返回最新值。这种场景下是否可以不上锁？或者不上锁会有什么问题吗？会panic吗？","like_count":2,"discussions":[{"author":{"id":1417824,"avatar":"https://static001.geekbang.org/account/avatar/00/15/a2/60/f3939ab4.jpg","nickname":"哈哼","note":"","ucode":"C1108406573D49","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":12360,"discussion_content":"看业务逻辑，你这个场景，可以不用锁。\n如果是操作很多个变量，一半新，一半旧会引发业务逻辑问题，比如转账结算，那一定要锁。\n如果是那种周期性动作，一次有问题，下一次能修复，可以不加锁，但最好加下，心里负担小。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568525102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1202828,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5a/8c/cee414db.jpg","nickname":"凯","note":"","ucode":"4CA509DA58B3A6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7258,"discussion_content":"是否可以读写分离，读操作-->写锁-->写-->解写锁，这貌似可以直接用互斥锁，不需要用到读写锁。按我的理解，读写锁应该是为了在互斥锁的基础上为了使锁的时间变短，并且可以保证读到的都是最新数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567436103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":195489,"user_name":"给力","can_delete":false,"product_type":"c1","uid":1113645,"ip_address":"","ucode":"646EE4AFC17224","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/2d/2c9177ca.jpg","comment_is_top":false,"comment_ctime":1585191263,"is_pvip":false,"replies":[{"id":"74284","content":"sema 实际上代表着基于内存地址的锁机制。相关的代码在 sync 包的 runtime.go 文件和 runtime 包的 seme.go 文件中。你有兴趣的话可以看一看。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1585194719,"ip_address":"","comment_id":195489,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5880158559","product_id":100013101,"comment_content":"对于使用锁有个疑问：<br>type Mutex struct {<br>\tstate int32<br>\tsema  uint32<br>}<br>state表示锁的一个状态<br><br>sema这个变量没太理清是做什么的？什么场景下使用","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489089,"discussion_content":"sema 实际上代表着基于内存地址的锁机制。相关的代码在 sync 包的 runtime.go 文件和 runtime 包的 seme.go 文件中。你有兴趣的话可以看一看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585194719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37473,"user_name":"jacke","can_delete":false,"product_type":"c1","uid":1161209,"ip_address":"","ucode":"05F355E1FF88C5","user_header":"https://static001.geekbang.org/account/avatar/00/11/b7/f9/a8f26b10.jpg","comment_is_top":false,"comment_ctime":1541600414,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5836567710","product_id":100013101,"comment_content":"问下老师,读写锁解锁部分有点不明白：写锁解锁的时候如果同时有写锁和读锁在等待，是优先唤醒读锁是把？<br>这个规定对读锁解锁也适用是把?","like_count":1,"discussions":[{"author":{"id":1019568,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8e/b0/ef201991.jpg","nickname":"CcczzZ","note":"","ucode":"5F46DA5053D2BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":136881,"discussion_content":"对，适用的，可以写代码试一下。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579170184,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":356400,"user_name":"黄仲辉","can_delete":false,"product_type":"c1","uid":1593521,"ip_address":"北京","ucode":"D7EB3C3ADD99DA","user_header":"https://static001.geekbang.org/account/avatar/00/18/50/b1/7b701518.jpg","comment_is_top":false,"comment_ctime":1662266796,"is_pvip":false,"replies":[{"id":"129765","content":"可重入锁相当于一个语法糖。它在很多时候会掩盖应用程序编写上的问题，从程序设计的角度讲会起到不好的作用。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1662345918,"ip_address":"北京","comment_id":356400,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1662266796","product_id":100013101,"comment_content":"同一个goroutine也不能多次执行一个mutex的lock，这是不可重入锁，go为何没有原生实现可重入锁？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586563,"discussion_content":"可重入锁相当于一个语法糖。它在很多时候会掩盖应用程序编写上的问题，从程序设计的角度讲会起到不好的作用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662345918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350898,"user_name":"MClink","can_delete":false,"product_type":"c1","uid":1435733,"ip_address":"","ucode":"F479190923355C","user_header":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","comment_is_top":false,"comment_ctime":1657298055,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1657298055","product_id":100013101,"comment_content":"临界区竞争的例子<br>package main<br><br>import (<br>\t&quot;fmt&quot;<br>\t&quot;sync&quot;<br>)<br><br>func main() {<br>\taddWithLock()<br>\taddWithNotLock()<br>}<br><br>func addWithNotLock() {<br>\tvar count int<br>\tvar wg sync.WaitGroup<br>\twg.Add(10) &#47;&#47;添加10个等待<br>\tfor i := 0; i &lt; 10; i++ {<br>\t\tgo func() {<br>\t\t\tdefer wg.Done() &#47;&#47;执行完一个协程去掉一个等待<br>\t\t\t&#47;&#47;对count进行10万次加1<br>\t\t\tfor j := 0; j &lt; 100000; j++ {<br>\t\t\t\tcount++ &#47;&#47;此处为临界区域<br>\t\t\t}<br>\t\t}()<br>\t}<br>\twg.Wait()<br>\tfmt.Println(count)<br>}<br><br>func addWithLock() {<br>\tvar count = 0 &#47;&#47;公共修改的变量<br>\tvar mu = sync.Mutex{}<br>\t&#47;&#47;使用WaitGroup等待10个goroutine完成<br>\tvar wg sync.WaitGroup<br>\twg.Add(10) &#47;&#47;添加10个等待<br>\t&#47;&#47;循环执行10个协程<br>\tfor i := 0; i &lt; 10; i++ {<br>\t\tgo func() {<br>\t\t\tdefer wg.Done() &#47;&#47;执行完一个协程去掉一个等待<br>\t\t\t&#47;&#47;对count进行10万次加1<br>\t\t\tfor j := 0; j &lt; 100000; j++ {<br>\t\t\t\t&#47;&#47;开始执行到临界区域 加锁<br>\t\t\t\tmu.Lock()<br>\t\t\t\tcount++ &#47;&#47;此处为临界区域<br>\t\t\t\t&#47;&#47;临界区域执行结束 释放锁<br>\t\t\t\tmu.Unlock()<br>\t\t\t}<br>\t\t}()<br>\t}<br>\t&#47;&#47;主线程等待10个协程完成<br>\twg.Wait()<br>\tfmt.Println(count)<br>}<br>","like_count":0},{"had_liked":false,"id":350897,"user_name":"MClink","can_delete":false,"product_type":"c1","uid":1435733,"ip_address":"","ucode":"F479190923355C","user_header":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","comment_is_top":false,"comment_ctime":1657298036,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1657298036","product_id":100013101,"comment_content":"临界区竞争实例","like_count":0},{"had_liked":false,"id":327192,"user_name":"jxs1211","can_delete":false,"product_type":"c1","uid":1101006,"ip_address":"","ucode":"B7F1F2D84389E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","comment_is_top":false,"comment_ctime":1639972523,"is_pvip":false,"replies":[{"id":"119013","content":"对，这是有一整套规则的。简单来说就是，在各个语句执行的任意间隔、在同步工具造成的阻塞时、在语句调用内核态的代码并需要等待时，以及当前的goroutine执行时间过久需要切换时。<br><br>这个机制正式讲起来篇幅会非常大。<br><br>我记得我之前跟你说过吧，可以看我那本《Go并发编程实战》。<br><br>另一个方式是直接看Go语言的源码。其实《Go并发编程实战》是可以帮助你看懂Go语言源码的。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1639984636,"ip_address":"","comment_id":327192,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1639972523","product_id":100013101,"comment_content":"根据执行go run demo58.go -protecting=0的结果来看，go程序运行时调度时机并不是某个goroutine阻塞（即使不阻塞也会可能被P从M上分离），而是有它自己判断机制，对吗，那么他的调度机制是怎么样的呢，是否类似原理的参考资料","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540188,"discussion_content":"对，这是有一整套规则的。简单来说就是，在各个语句执行的任意间隔、在同步工具造成的阻塞时、在语句调用内核态的代码并需要等待时，以及当前的goroutine执行时间过久需要切换时。\n\n这个机制正式讲起来篇幅会非常大。\n\n我记得我之前跟你说过吧，可以看我那本《Go并发编程实战》。\n\n另一个方式是直接看Go语言的源码。其实《Go并发编程实战》是可以帮助你看懂Go语言源码的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639984637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327175,"user_name":"jxs1211","can_delete":false,"product_type":"c1","uid":1101006,"ip_address":"","ucode":"B7F1F2D84389E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","comment_is_top":false,"comment_ctime":1639967909,"is_pvip":false,"replies":[{"id":"119012","content":"sync.Mutex是不分读和写的，原则上你用它来保护什么操作都可以，只是有时候效率会不太好（下面会提到）。sync.RWMutex分读写。首先要明确，所谓写就是会改变资源的内容或状态，所谓读就是只会访问但不会改变。<br><br>sync.RWMutex中包含了两个锁，用写锁可以保证两个（写）操作之间是互斥的，用读锁不会保证两个（读）操作之间是互斥的。而且，更重要的是，同一个读写锁的写锁和读锁之间是互斥的（读-写操作互斥）。因此，我们就可以利用读写锁来实施区别化的保护。<br><br>你需要根据这套规则来设计你使用的方式。<br><br>当你会对某一个共享资源既访问又改变，而且这两种操作分别由不同的代码块执行的时候，就应该用读写锁，因为读写锁可以在这种情况下提高效率。如果在互斥锁下执行读操作和写操作，那么读-读之间就会互斥（这其实是没必要的）。如果用读写锁，那么读-读之间就不会互斥，这就提高了效率（尤其是在读操作并发量很高的情况下）。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1639984352,"ip_address":"","comment_id":327175,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1639967909","product_id":100013101,"comment_content":"&#47;&#47; 2 只有读的情况下就是用读锁,同时又读写的情况下,就是用读写锁并分别用读锁保护读操作,写锁保护写操作,是这样吗?<br>\t&#47;&#47; 衍生的问题:<br>\t\t&#47;&#47; 如果只用读锁，保护写操作，是否有什么问题<br>\t\t&#47;&#47; 读写锁引入了更多的复杂度，是否要结合实际情况确定读写情况下，是否一定要引入读写锁<br>\t\t&#47;&#47; 是否有一定需要使用读写锁而不适用读锁的场景，可否举例","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540186,"discussion_content":"sync.Mutex是不分读和写的，原则上你用它来保护什么操作都可以，只是有时候效率会不太好（下面会提到）。sync.RWMutex分读写。首先要明确，所谓写就是会改变资源的内容或状态，所谓读就是只会访问但不会改变。\n\nsync.RWMutex中包含了两个锁，用写锁可以保证两个（写）操作之间是互斥的，用读锁不会保证两个（读）操作之间是互斥的。而且，更重要的是，同一个读写锁的写锁和读锁之间是互斥的（读-写操作互斥）。因此，我们就可以利用读写锁来实施区别化的保护。\n\n你需要根据这套规则来设计你使用的方式。\n\n当你会对某一个共享资源既访问又改变，而且这两种操作分别由不同的代码块执行的时候，就应该用读写锁，因为读写锁可以在这种情况下提高效率。如果在互斥锁下执行读操作和写操作，那么读-读之间就会互斥（这其实是没必要的）。如果用读写锁，那么读-读之间就不会互斥，这就提高了效率（尤其是在读操作并发量很高的情况下）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639984352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327174,"user_name":"jxs1211","can_delete":false,"product_type":"c1","uid":1101006,"ip_address":"","ucode":"B7F1F2D84389E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","comment_is_top":false,"comment_ctime":1639967874,"is_pvip":false,"replies":[{"id":"119011","content":"一个针对的是数据块（共享资源），另一个针对的是代码块（临界区）。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1639983574,"ip_address":"","comment_id":327174,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1639967874","product_id":100013101,"comment_content":"1 一个是避免多个线程在同一时刻操作同一个数据块，另一个是协调多个线程，以避免它们在同一时刻执行同一个代码块。这2个描述的区别在哪？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540184,"discussion_content":"一个针对的是数据块（共享资源），另一个针对的是代码块（临界区）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639983574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317068,"user_name":"jxs1211","can_delete":false,"product_type":"c1","uid":1101006,"ip_address":"","ucode":"B7F1F2D84389E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","comment_is_top":false,"comment_ctime":1634655748,"is_pvip":false,"replies":[{"id":"114895","content":"这要看你的诉求是什么。<br><br>如果你就是需要持续不断地试图从某处读取数据，那么就不应该“见到 io.EOF 后 break”。因为这可能会让 for 语句过早的结束执行。<br><br>如果你的 for 语句只需要读取“现存的剩余数据”后结束执行，那么就需要“见到 io.EOF 后 break”。<br><br>所以，即使像你写的这段无结束条件的 for 语句，仍然需要这样考虑。关键问题是，你的核心诉求是什么？<br>","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1634709205,"ip_address":"","comment_id":317068,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1634655748","product_id":100013101,"comment_content":"如果所有写入数据都被读完了，reader是否可能因为读取不到数据返回EOF,而一直无法退出for循环呢<br>for {<br>\tdata, n, err = readConfig.handler()<br>\tif err == nil || err != io.EOF {<br>\t    break<br>\t}<br>        ....<br>}","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528637,"discussion_content":"这要看你的诉求是什么。\n\n如果你就是需要持续不断地试图从某处读取数据，那么就不应该“见到 io.EOF 后 break”。因为这可能会让 for 语句过早的结束执行。\n\n如果你的 for 语句只需要读取“现存的剩余数据”后结束执行，那么就需要“见到 io.EOF 后 break”。\n\n所以，即使像你写的这段无结束条件的 for 语句，仍然需要这样考虑。关键问题是，你的核心诉求是什么？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634709205,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317061,"user_name":"jxs1211","can_delete":false,"product_type":"c1","uid":1101006,"ip_address":"","ucode":"B7F1F2D84389E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","comment_is_top":false,"comment_ctime":1634654475,"is_pvip":false,"replies":[{"id":"114896","content":"其实不需要过多关注这个时间戳。这只是概率问题，多核CPU中的并发执行更有可能出现这种情况。<br><br>你运行程序的CPU的主频是多少？其中共用多少个CPU核心？然后你算一算，这颗CPU在 1 纳秒之内一共可以进行多少次运算？<br>","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1634710225,"ip_address":"","comment_id":317061,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1634654475","product_id":100013101,"comment_content":"发现不同goroutine写入操作时可能会写入相同的时间数据：<br>2021&#47;10&#47;19 22:34:29 writer [2-4]: Oct 19 22:34:29.119490600      (total: 494)<br>2021&#47;10&#47;19 22:34:29 writer [5-4]: Oct 19 22:34:29.119490600      (total: 520)<br>以为是因为genWriter中mu.Lock()并没有把产生data的代码包括在临界区中，于是将这行代码加入到mu.Lock()中，但是测试出来的数据还是会写入相同的数据，难道不应该是当一个goroutine获取令牌进入临界区写入数据，其它goroutine等待吗，这个的话怎么会出现不同goroutine写入的时间一样的情况呢，求解","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528633,"discussion_content":"其实不需要过多关注这个时间戳。这只是概率问题，多核CPU中的并发执行更有可能出现这种情况。\n\n你运行程序的CPU的主频是多少？其中共用多少个CPU核心？然后你算一算，这颗CPU在 1 纳秒之内一共可以进行多少次运算？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634710225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314653,"user_name":"jxs1211","can_delete":false,"product_type":"c1","uid":1101006,"ip_address":"","ucode":"B7F1F2D84389E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","comment_is_top":false,"comment_ctime":1633303055,"is_pvip":false,"replies":[{"id":"114108","content":"Channel 其实就是基于互斥锁、信号量等建立起来的高层抽象。像互斥锁、原子操作这些在 channel 面前就算是低层抽象了。<br><br>你在使用的时候，按照实际需要来选择就可以了，不用太在乎这里所说的“低层”、“高层”。对于应用程序来说，这两层基本上没有区别。你应该更关注“同步”和“异步”之间的差别。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1633681517,"ip_address":"","comment_id":314653,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1633303055","product_id":100013101,"comment_content":"&#47;&#47; Package sync provides basic synchronization primitives such as mutual<br>&#47;&#47; exclusion locks. Other than the Once and WaitGroup types, most are intended<br>&#47;&#47; for use by low-level library routines. Higher-level synchronization is<br>&#47;&#47; better done via channels and communication.<br>这段注释中描述的low-level和high-level的区别是指底层和上层吗，这个意思是go底层对并发控制的实现是用的是mutual exclusion locks. 而用户要使用的话推荐还是用channel或者通信的机制吗","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527753,"discussion_content":"Channel 其实就是基于互斥锁、信号量等建立起来的高层抽象。像互斥锁、原子操作这些在 channel 面前就算是低层抽象了。\n\n你在使用的时候，按照实际需要来选择就可以了，不用太在乎这里所说的“低层”、“高层”。对于应用程序来说，这两层基本上没有区别。你应该更关注“同步”和“异步”之间的差别。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633681517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314406,"user_name":"星渊王","can_delete":false,"product_type":"c1","uid":1199987,"ip_address":"","ucode":"947249B4A5B079","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/73/b1db99da.jpg","comment_is_top":false,"comment_ctime":1633000426,"is_pvip":false,"replies":[{"id":"113952","content":"两个变量在内存里肯定会有不同的地址啊，否则就不是“两个”变量了。但是，与它们绑定的值却是相同的啊（注意，不是同一个，但却是相同的）。<br><br>正因为如此，我们才会说“当把一个变量的值赋给另一个变量的时候，这个值会被拷贝”。或者说，正因为有“另一个地方同时需要这个值”这种需求，才有了“拷贝出一个副本，并把这个副本给到另一个地方”这种解决方案。<br><br>最后，顺便说一下，赋值也会拷贝值，所以互斥锁在使用后就不要再做赋值操作了，否则就会造成互斥锁功能上的异常。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1633244042,"ip_address":"","comment_id":314406,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1633000426","product_id":100013101,"comment_content":"var sy sync.Mutex<br><br>func main() {<br>\trouter := gin.Default()<br><br>\trouter.GET(&quot;&#47;&quot;, func(c *gin.Context) {<br>\t\tnum := c.Query(&quot;num&quot;)<br><br>\t\tnum2,err := strconv.Atoi(num)<br>\t\tif err != nil {<br>\t\t\tc.JSON(200,gin.H{<br>\t\t\t\t&quot;name&quot;:&quot;maogou&quot; + err.Error(),<br>\t\t\t})<br>\t\t}<br>\t\tdemo(num2)<br>\t\tc.JSON(200,gin.H{<br>\t\t\t&quot;name&quot;:&quot;maogou&quot;,<br>\t\t})<br>\t})<br><br>\trouter.GET(&quot;&#47;demo1&quot;, func(c *gin.Context) {<br>\t\tsy2 := sy<br><br>\t\tfmt.Printf(&quot;%p\\n&quot;,&amp;sy)<br>\t\tfmt.Printf(&quot;%p\\n&quot;,&amp;sy2)<br>\t\tfmt.Println(sy == sy2)<br>}<br><br>最终输出结果<br>0xa87858<br>0xc0003060a0<br>true   不太理解这两个为什么会相等 ? ","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527674,"discussion_content":"两个变量在内存里肯定会有不同的地址啊，否则就不是“两个”变量了。但是，与它们绑定的值却是相同的啊（注意，不是同一个，但却是相同的）。\n\n正因为如此，我们才会说“当把一个变量的值赋给另一个变量的时候，这个值会被拷贝”。或者说，正因为有“另一个地方同时需要这个值”这种需求，才有了“拷贝出一个副本，并把这个副本给到另一个地方”这种解决方案。\n\n最后，顺便说一下，赋值也会拷贝值，所以互斥锁在使用后就不要再做赋值操作了，否则就会造成互斥锁功能上的异常。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633244042,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":302015,"user_name":"无名无姓","can_delete":false,"product_type":"c1","uid":2621412,"ip_address":"","ucode":"487BD5AA2CD305","user_header":"https://static001.geekbang.org/account/avatar/00/27/ff/e4/927547a9.jpg","comment_is_top":false,"comment_ctime":1626019549,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1626019549","product_id":100013101,"comment_content":"讲的不错","like_count":0},{"had_liked":false,"id":294353,"user_name":"杨丁","can_delete":false,"product_type":"c1","uid":1008597,"ip_address":"","ucode":"D469B0BCA86587","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/d5/a300899a.jpg","comment_is_top":false,"comment_ctime":1621911108,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621911108","product_id":100013101,"comment_content":"思考题：<br>1. Locker接口","like_count":0},{"had_liked":false,"id":289587,"user_name":"幼儿编程教学","can_delete":false,"product_type":"c1","uid":1237199,"ip_address":"","ucode":"F13F3150E6CAE9","user_header":"https://static001.geekbang.org/account/avatar/00/12/e0/cf/43f201f2.jpg","comment_is_top":false,"comment_ctime":1619090389,"is_pvip":false,"replies":[{"id":"105088","content":"锁的范围太大，往往不是错用了defer语句，而是函数切分方面有问题，没有合理切分，或者切得太大。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1619155894,"ip_address":"","comment_id":289587,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1619090389","product_id":100013101,"comment_content":"郝老师，请教下。<br>看文章，推荐用defer的方式去解锁。<br>但，这样的话，锁的范围会大一点。但，好像这是最保险的方法，好像也没办法，是吧？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518959,"discussion_content":"锁的范围太大，往往不是错用了defer语句，而是函数切分方面有问题，没有合理切分，或者切得太大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619155894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":279640,"user_name":"mkii","can_delete":false,"product_type":"c1","uid":1674466,"ip_address":"","ucode":"534914EC7EA304","user_header":"https://static001.geekbang.org/account/avatar/00/19/8c/e2/48f4e4fa.jpg","comment_is_top":false,"comment_ctime":1613885872,"is_pvip":false,"replies":[{"id":"101641","content":"这个没有固定的唤醒优先级。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1613980638,"ip_address":"","comment_id":279640,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1613885872","product_id":100013101,"comment_content":"老师，如果当前写锁被锁定，解锁时这2者有没有唤醒的优先级。等待读锁的goroutine和等待写锁的goroutine","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515809,"discussion_content":"这个没有固定的唤醒优先级。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613980638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1132878,"avatar":"https://static001.geekbang.org/account/avatar/00/11/49/4e/8798cd01.jpg","nickname":"顷","note":"","ucode":"096B6859C1FA80","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":536763,"discussion_content":"老师的这个回答，是否和原文中描述的 【对写锁进行解锁，会唤醒“所有因试图锁定读锁，而被阻塞的 goroutine”，并且，这通常会使它们都成功完成对读锁的锁定。】这句有歧义呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638864468,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":515809,"ip_address":""},"score":536763,"extra":""}]}]},{"had_liked":false,"id":273017,"user_name":"我的腿腿","can_delete":false,"product_type":"c1","uid":1239277,"ip_address":"","ucode":"2AAA36A7C3AD75","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/ed/f9347e5e.jpg","comment_is_top":false,"comment_ctime":1610414175,"is_pvip":false,"replies":[{"id":"98956","content":"你这么说谁也帮不了你。你需要用代码描述。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1610445412,"ip_address":"","comment_id":273017,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1610414175","product_id":100013101,"comment_content":"我用同一把互斥锁，在两个协程里面用，都有对应的加锁解锁操作，另一个协程莫名就阻塞了？咋回事","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513460,"discussion_content":"你这么说谁也帮不了你。你需要用代码描述。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610445412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1435733,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","nickname":"MClink","note":"","ucode":"F479190923355C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380886,"discussion_content":"你这种应该是偶现的，就是同个锁你两个协程都进行的锁操作导致的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624777491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1239277,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e8/ed/f9347e5e.jpg","nickname":"我的腿腿","note":"","ucode":"2AAA36A7C3AD75","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341814,"discussion_content":"dog","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610530448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":267118,"user_name":"初学者","can_delete":false,"product_type":"c1","uid":2052670,"ip_address":"","ucode":"5E404009761B90","user_header":"https://static001.geekbang.org/account/avatar/00/1f/52/3e/f74da7bd.jpg","comment_is_top":false,"comment_ctime":1607601071,"is_pvip":false,"replies":[{"id":"97252","content":"API本身肯定无法这么精细地介入你的程序。读锁和写锁具体保护什么是需要应用程序的开发者自己去设计和执行的。<br><br>绝大多数情况下，读锁的临界区里只应该包含对某个共享资源的获取操作；只要涉及到了对共享资源的修改，就应该使用写锁而不是读锁，即使其中包含了读操作也是如此","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1607914807,"ip_address":"","comment_id":267118,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1607601071","product_id":100013101,"comment_content":"老师，想问下读写锁的读锁和写锁具体操作的内容是什么，比如加读锁的代码块，这段代码块里面的关于读的内容都会被读锁区分出来吗，代码块中的读和写具体指什么呢","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511513,"discussion_content":"API本身肯定无法这么精细地介入你的程序。读锁和写锁具体保护什么是需要应用程序的开发者自己去设计和执行的。\n\n绝大多数情况下，读锁的临界区里只应该包含对某个共享资源的获取操作；只要涉及到了对共享资源的修改，就应该使用写锁而不是读锁，即使其中包含了读操作也是如此","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607914807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155065,"user_name":"疯琴","can_delete":false,"product_type":"c1","uid":1099379,"ip_address":"","ucode":"82ACAA4A27753D","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/73/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1574642790,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574642790","product_id":100013101,"comment_content":"讲得挺清晰的","like_count":0},{"had_liked":false,"id":102670,"user_name":"糊李糊涂","can_delete":false,"product_type":"c1","uid":1197625,"ip_address":"","ucode":"E0F6064CBA32B1","user_header":"https://static001.geekbang.org/account/avatar/00/12/46/39/e545c885.jpg","comment_is_top":false,"comment_ctime":1560295172,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560295172","product_id":100013101,"comment_content":"Locker和RLocker","like_count":0},{"had_liked":false,"id":91630,"user_name":"张sir","can_delete":false,"product_type":"c1","uid":1209431,"ip_address":"","ucode":"52958DF6705208","user_header":"https://static001.geekbang.org/account/avatar/00/12/74/57/7b828263.jpg","comment_is_top":false,"comment_ctime":1557063379,"is_pvip":false,"replies":[{"id":"32768","content":"你可以理解为同一把锁保护的多个代码段。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1557109106,"ip_address":"","comment_id":91630,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557063379","product_id":100013101,"comment_content":"一组临界区是什么场景下会，能举个例子吗？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448972,"discussion_content":"你可以理解为同一把锁保护的多个代码段。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557109106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":69022,"user_name":"...","can_delete":false,"product_type":"c1","uid":1142098,"ip_address":"","ucode":"9D73E00133C236","user_header":"https://static001.geekbang.org/account/avatar/00/11/6d/52/404912c3.jpg","comment_is_top":false,"comment_ctime":1550647811,"is_pvip":false,"replies":[{"id":"25263","content":"这里说的就是可重入锁啊。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1551184351,"ip_address":"","comment_id":69022,"utype":1}],"discussion_count":6,"race_medal":0,"score":"1550647811","product_id":100013101,"comment_content":"老师 go有没有可重入锁的概念","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439919,"discussion_content":"这里说的就是可重入锁啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551184351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1417824,"avatar":"https://static001.geekbang.org/account/avatar/00/15/a2/60/f3939ab4.jpg","nickname":"哈哼","note":"","ucode":"C1108406573D49","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":12351,"discussion_content":"不行，java里有。在go里这就是重复加锁，是bug","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568524658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1071316,"avatar":"https://static001.geekbang.org/account/avatar/00/10/58/d4/c52f9f6d.jpg","nickname":"芝士老爹","note":"","ucode":"5F2935967574D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3824,"discussion_content":"Python里面的那种递归锁？可以连续锁多次？GO里面没得。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564845946,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1650748,"avatar":"https://static001.geekbang.org/account/avatar/00/19/30/3c/0668d6ae.jpg","nickname":"盘胧","note":"","ucode":"5386CC4C92ECC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1071316,"avatar":"https://static001.geekbang.org/account/avatar/00/10/58/d4/c52f9f6d.jpg","nickname":"芝士老爹","note":"","ucode":"5F2935967574D0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394243,"discussion_content":"有啊  一样的。不是bug","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631799756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3824,"ip_address":""},"score":394243,"extra":""},{"author":{"id":1071316,"avatar":"https://static001.geekbang.org/account/avatar/00/10/58/d4/c52f9f6d.jpg","nickname":"芝士老爹","note":"","ucode":"5F2935967574D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1650748,"avatar":"https://static001.geekbang.org/account/avatar/00/19/30/3c/0668d6ae.jpg","nickname":"盘胧","note":"","ucode":"5386CC4C92ECC2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":406235,"discussion_content":"同一个锁实例，多次lock？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634726660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":394243,"ip_address":""},"score":406235,"extra":""},{"author":{"id":1650748,"avatar":"https://static001.geekbang.org/account/avatar/00/19/30/3c/0668d6ae.jpg","nickname":"盘胧","note":"","ucode":"5386CC4C92ECC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1071316,"avatar":"https://static001.geekbang.org/account/avatar/00/10/58/d4/c52f9f6d.jpg","nickname":"芝士老爹","note":"","ucode":"5F2935967574D0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":406524,"discussion_content":"害，你查一下就知道了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634785202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":406235,"ip_address":""},"score":406524,"extra":""}]}]},{"had_liked":false,"id":47013,"user_name":"静以储势·Shuke","can_delete":false,"product_type":"c1","uid":1119090,"ip_address":"","ucode":"98736831B73028","user_header":"https://static001.geekbang.org/account/avatar/00/11/13/72/434a40f1.jpg","comment_is_top":false,"comment_ctime":1544018983,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1544018983","product_id":100013101,"comment_content":"Golang可以用mutex像java一样嵌套加锁么？","like_count":0,"discussions":[{"author":{"id":1417824,"avatar":"https://static001.geekbang.org/account/avatar/00/15/a2/60/f3939ab4.jpg","nickname":"哈哼","note":"","ucode":"C1108406573D49","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":12349,"discussion_content":"不行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568524590,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1071316,"avatar":"https://static001.geekbang.org/account/avatar/00/10/58/d4/c52f9f6d.jpg","nickname":"芝士老爹","note":"","ucode":"5F2935967574D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3825,"discussion_content":"不可以。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564845966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39492,"user_name":"生活在别处","can_delete":false,"product_type":"c1","uid":1096441,"ip_address":"","ucode":"E7F60026F2737A","user_header":"https://static001.geekbang.org/account/avatar/00/10/ba/f9/351e4fc0.jpg","comment_is_top":false,"comment_ctime":1542289563,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1542289563","product_id":100013101,"comment_content":"读写锁是公平的吗？","like_count":0,"discussions":[{"author":{"id":1336951,"avatar":"https://static001.geekbang.org/account/avatar/00/14/66/77/194ba21d.jpg","nickname":"lzh","note":"","ucode":"C3D83DF4230109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362836,"discussion_content":"不公平，抢占的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617035971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31672,"user_name":"timmy21","can_delete":false,"product_type":"c1","uid":1174860,"ip_address":"","ucode":"9D6DED247B1F38","user_header":"https://static001.geekbang.org/account/avatar/00/11/ed/4c/8674b6ad.jpg","comment_is_top":false,"comment_ctime":1539260649,"is_pvip":false,"replies":[{"id":"11816","content":"必须上锁，程序现在运行没问题不代表到服务器上没问题。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1539577101,"ip_address":"","comment_id":31672,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539260649","product_id":100013101,"comment_content":"郝老师，我使用race进行竞争检测，发现有些变量只有一个写者，一个读者。程序运行没有问题，上锁我担心性能下降，这种情况下需要去上锁吗？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426461,"discussion_content":"必须上锁，程序现在运行没问题不代表到服务器上没问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539577101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31605,"user_name":"CBBIOT","can_delete":false,"product_type":"c1","uid":1200298,"ip_address":"","ucode":"542339EECA68B9","user_header":"","comment_is_top":false,"comment_ctime":1539244610,"is_pvip":false,"replies":[{"id":"11819","content":"极客时间这两天会开通这个专栏的小密圈。敬请期待。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1539577257,"ip_address":"","comment_id":31605,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539244610","product_id":100013101,"comment_content":"郝老师你的这个学习群怎么加?有买你的书还没有看，目前还在学基础。","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426427,"discussion_content":"极客时间这两天会开通这个专栏的小密圈。敬请期待。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539577257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}