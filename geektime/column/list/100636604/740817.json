{"id":740817,"title":"第 15 章 迭代器(2)","content":"<h2 id=\"nav_point_245\">15.3　迭代器适配器</h2>\n<p>一旦你手头有了迭代器，迭代器的 <code>Iterator</code> 特型就会提供大量<strong>适配器方法</strong>（也可以简称为<strong>适配器</strong>）。适配器会消耗某个迭代器并构建一个实现了特定行为的新迭代器。为了阐明适配器的工作原理，我们将从两个最流行的适配器 <code>map</code> 和 <code>filter</code> 开始，然后介绍其他适配器，涵盖了你能想到的从其他序列生成值序列的几乎所有方式：截断、跳过、组合、反转、连接、重复等。</p>\n<h3 id=\"nav_point_246\">15.3.1　<code>map</code> 与 <code>filter</code></h3>\n<p><code>Iterator</code> 特型的 <code>map</code>（映射）适配器能针对迭代器的各个条目调用闭包来帮你转换迭代器。<code>filter</code> 适配器能使用闭包来帮你从迭代器中过滤某些条目，由闭包决定保留和丢弃哪些条目。</p>\n<p>假设你正在逐行遍历文本并希望去掉每一行的前导空格和尾随空格。标准库的 <code>str::trim</code> 方法能从单个 <code>&amp;str</code> 中丢弃前导空格和尾随空格，返回一个新的、修剪过的 <code>&amp;str</code> 借用。你可以通过 <code>map</code> 适配器将 <code>str::trim</code> 应用于迭代器中的每一行：</p>\n<pre class=\"code-rows\"><code>let text = \"  ponies  \\n   giraffes\\niguanas  \\nsquid\".to_string();\nlet v: Vec&lt;&amp;str&gt; = text.lines()\n    .map(str::trim)\n    .collect();\nassert_eq!(v, [\"ponies\", \"giraffes\", \"iguanas\", \"squid\"]);</code></pre>\n<p><code>text.lines()</code> 调用会返回一个生成字符串中各行的迭代器。在该迭代器上调用 <code>map</code> 会返回第二个迭代器，第二个迭代器会对每一行调用 <code>str::trim</code> 并将生成的结果作为自己的条目。最后，<code>collect</code> 会将这些条目收集到一个向量中。</p>\n<p><code>map</code> 返回的迭代器本身当然也可以进一步适配。如果你想将结果中的 <code>iguanas</code> 排除，可以这样写：</p>\n<pre class=\"code-rows\"><code>let text = \"  ponies  \\n   giraffes\\niguanas  \\nsquid\".to_string();\nlet v: Vec&lt;&amp;str&gt; = text.lines()\n    .map(str::trim)\n    .filter(|s| *s != \"iguanas\")\n    .collect();\nassert_eq!(v, [\"ponies\", \"giraffes\", \"squid\"]);</code></pre>\n<p>在这里，<code>filter</code> 会返回第三个迭代器，它只会从 <code>map</code> 迭代器的结果中生成闭包 <code>|s| *s != \"iguanas\"</code> 返回 <code>true</code> 的那些条目。迭代器的适配器链条就像 Unix shell 中的管道：每个适配器都有单一用途，并且很清楚此序列是如何在从左到右读取时进行转换的。</p><!-- [[[read_end]]] -->\n<p><code>map</code> 和 <code>filter</code> 的适配器的签名如下所示：</p>\n<pre class=\"code-rows\"><code>fn map&lt;B, F&gt;(self, f: F) -&gt; impl Iterator&lt;Item=B&gt;\n    where Self: Sized, F: FnMut(Self::Item) -&gt; B;\n\nfn filter&lt;P&gt;(self, predicate: P) -&gt; impl Iterator&lt;Item=Self::Item&gt;\n    where Self: Sized, P: FnMut(&amp;Self::Item) -&gt; bool;</code></pre>\n<p>在标准库中，<code>map</code> 和 <code>filter</code> 实际上返回的是名为 <code>std::iter::Map</code> 和 <code>std::iter::Filter</code> 的专用不透明（隐藏了实现细节的）<code>struct</code> 类型。然而，仅仅看到这些名字并不能告诉我们更多信息，所以在本书中，我们会写成 <code>-&gt; impl Iterator&lt;Item=...&gt;</code>，因为这揭示了我们真正关心的事情：此方法返回了能生成给定类型条目的 <code>Iterator</code>。</p>\n<p>大多数适配器会按值接受 <code>self</code>，这就要求 <code>Self</code> 必须是固定大小的（<code>Sized</code>）（所有常见的迭代器都是这样的）。</p>\n<p><code>map</code> 迭代器会按值将每个条目传给闭包，然后将闭包结果的所有权转移给自己的消费者。<code>filter</code> 迭代器会通过共享引用将每个条目传给闭包，并保留所有权以便再把选定的条目传给自己的消费者。这就是为什么该示例必须解引用 <code>s</code> 以便将其与 <code>\"iguanas\"</code> 进行比较：<code>filter</code> 迭代器的条目类型是 <code>&amp;str</code>，因此闭包参数 <code>s</code> 的类型是 <code>&amp;&amp;str</code>。</p>\n<p>关于迭代器适配器，有两点需要特别注意。</p>\n<p>第一个要点是，单纯在迭代器上调用适配器并不会消耗任何条目，只会返回一个新的迭代器，新迭代器会根据需要从第一个迭代器中提取条目，以生成自己的条目。在适配器的适配链中，实际完成任何工作（同时消耗条目）的唯一方法是在最终的迭代器上调用 <code>next</code>。</p>\n<p>因此，在我们之前的示例中，方法调用 <code>text.lines()</code> 本身实际上并不会解析字符串中的任何一行，它只是返回了一个迭代器，当需要时<strong>才会</strong>解析这些行。同样，<code>map</code> 和 <code>filter</code> 也只会返回新的迭代器，当需要时，它们<strong>才会</strong>映射或过滤。在由 <code>collect</code> 调用 <code>filter</code> 迭代器上的 <code>next</code> 之前，不会进行任何实际的工作。</p>\n<p>如果你在使用有副作用的适配器，这一点尤为重要。例如，以下代码根本不会输出任何内容：</p>\n<pre class=\"code-rows\"><code>[\"earth\", \"water\", \"air\", \"fire\"]\n    .iter().map(|elt| println!(\"{}\", elt));</code></pre>\n<p><code>iter</code> 调用会返回数组元素的迭代器，<code>map</code> 调用会返回第二个迭代器，第二个迭代器会对第一个迭代器生成的每个值调用闭包。但是这里没有任何代码会实际用到整个链条的值，所以 <code>next</code> 方法永远不会执行。事实上，Rust 会就此发出警告：</p>\n<pre class=\"code-rows\"><code>warning: unused `std::iter::Map` that must be used\n  |\n7 | /     [\"earth\", \"water\", \"air\", \"fire\"]\n8 | |         .iter().map(|elt| println!(\"{}\", elt));\n  | |_______________________________________________^\n  |\n  = note: iterators are lazy and do nothing unless consumed</code></pre>\n<p>错误消息中的术语 lazy（惰性）不是贬义词，只是用来表示“推迟计算，直到需要该值”这种机制的行话。Rust 的惯例是迭代器应该做尽可能少的必要工作来满足每次对 <code>next</code> 的调用，在这个例子中，根本没有这样的调用，所以什么也没做。</p>\n<p>第二个要点是，迭代器的适配器是一种零成本抽象。由于 <code>map</code>、<code>filter</code> 和其他类似的适配器都是泛型的，因此将它们应用于迭代器就会专门针对所涉及的特定迭代器类型生成特化代码。这意味着 Rust 会有足够的信息将每个迭代器的 <code>next</code> 方法内联到它的消费者中，然后将这一组功能作为一个单元翻译成机器代码。因此，我们之前展示的迭代器的 <code>lines</code>/ <code>map</code>/ <code>filter</code> 链条会和手写代码一样高效：</p>\n<pre class=\"code-rows\"><code>for line in text.lines() {\n    let line = line.trim();\n    if line != \"iguanas\" {\n        v.push(line);\n    }\n}</code></pre>\n<p>下面我们接着介绍可用于 <code>Iterator</code> 特型上的各种适配器。</p>\n<h3 id=\"nav_point_247\">15.3.2　<code>filter_map</code> 与 <code>flat_map</code></h3>\n<p>在每个传入条目都会生成一个传出条目的情况下，<code>map</code> 适配器很实用。但是，如果想从迭代中删除而不是处理某些条目，或想用零个或多个条目替换单个条目时该怎么办？<code>filter_map</code>（过滤映射）适配器和 <code>flat_map</code>（展平映射）适配器为你提供了这种灵活性。</p>\n<p><code>filter_map</code> 适配器与 <code>map</code> 类似，不同之处在于前者允许其闭包将条目转换为新条目（就像 <code>map</code> 那样）或从迭代中丢弃该条目。因此，它有点儿像 <code>filter</code> 和 <code>map</code> 的组合。它的签名如下所示：</p>\n<pre class=\"code-rows\"><code>fn filter_map&lt;B, F&gt;(self, f: F) -&gt; impl Iterator&lt;Item=B&gt;\n    where Self: Sized, F: FnMut(Self::Item) -&gt; Option&lt;B&gt;;</code></pre>\n<p>它和 <code>map</code> 的签名基本相同，不同之处在于这里的闭包会返回 <code>Option&lt;B&gt;</code>，而不只是 <code>B</code>。当闭包返回 <code>None</code> 时，该条目就会从本迭代中丢弃；当返回 <code>Some(b)</code> 时，<code>b</code> 就是 <code>filter_map</code> 迭代器生成的下一个条目。</p>\n<p>假设你要扫描字符串，以查找可解析为数值且以空格分隔的单词，然后处理该数值，忽略其他单词。可以这样写：</p>\n<pre class=\"code-rows\"><code>use std::str::FromStr;\n\nlet text = \"1\\nfrond .25  289\\n3.1415 estuary\\n\";\nfor number in text\n    .split_whitespace()\n    .filter_map(|w| f64::from_str(w).ok())\n{\n    println!(\"{:4.2}\", number.sqrt());\n}</code></pre>\n<p>上面的代码会输出以下内容：</p>\n<pre class=\"code-rows\"><code>1.00\n0.50\n17.00\n1.77</code></pre>\n<p>传给 <code>filter_map</code> 的闭包会尝试使用 <code>f64::from_str</code> 来解析每个以空格分隔的切片。结果是一个 <code>Result&lt;f64, ParseFloatError&gt;</code>，再调用 <code>.ok()</code> 就会把它变成 <code>Option&lt;f64&gt;</code>：如果解析错误就会变成 <code>None</code>；如果成功就会变成 <code>Some(v)</code>。<code>filter_map</code> 迭代器会丢弃所有 <code>None</code> 值并为每个 <code>Some(v)</code> 生成值 <code>v</code>。</p>\n<p>但是像这样把 <code>map</code> 和 <code>filter</code> 融合成一个操作，而非直接使用两种适配器，意义何在？实际上，刚才的例子已经展示了 <code>filter_map</code> 适配器的价值。如果只有先试着实际处理一下条目才能决定是否应该在迭代中包含它，该适配器就会派上用场。只用 <code>filter</code> 和 <code>map</code> 也可以做同样的事，但略显烦琐：</p>\n<pre class=\"code-rows\"><code>text.split_whitespace()\n    .map(|w| f64::from_str(w))\n    .filter(|r| r.is_ok())\n    .map(|r| r.unwrap())</code></pre>\n<p>我们可以将 <code>flat_map</code> 视为与 <code>filter_map</code> 功能类似的适配器，即对 <code>map</code> 的功能延伸，只是现在这个闭包不仅可以像 <code>map</code> 那样返回一个条目，或像 <code>filter_map</code> 那样返回零个或一个条目，还可以返回任意数量的条目序列。也就是说，<code>flat_map</code> 迭代器会生成此闭包返回的序列串联后的结果。</p>\n<p><code>flat_map</code> 的签名如下所示：</p>\n<pre class=\"code-rows\"><code>fn flat_map&lt;U, F&gt;(self, f: F) -&gt; impl Iterator&lt;Item=U::Item&gt;\n    where F: FnMut(Self::Item) -&gt; U, U: IntoIterator;</code></pre>\n<p>传给 <code>flat_map</code> 的闭包必须返回一个可迭代者，但可以返回任意种类的可迭代者。<span class=\"comment-number\">3</span></p>\n\n<p>假设有一个将国家映射成其主要城市的表。给定一个国家列表，如何遍历这些国家的主要城市呢？</p>\n<pre class=\"code-rows\"><code>use std::collections::HashMap;\n\nlet mut major_cities = HashMap::new();\nmajor_cities.insert(\"Japan\", vec![\"Tokyo\", \"Kyoto\"]);\nmajor_cities.insert(\"The United States\", vec![\"Portland\", \"Nashville\"]);\nmajor_cities.insert(\"Brazil\", vec![\"São Paulo\", \"Brasília\"]);\nmajor_cities.insert(\"Kenya\", vec![\"Nairobi\", \"Mombasa\"]);\nmajor_cities.insert(\"The Netherlands\", vec![\"Amsterdam\", \"Utrecht\"]);\n\nlet countries = [\"Japan\", \"Brazil\", \"Kenya\"];\n\nfor &amp;city in countries.iter().flat_map(|country| &amp;major_cities[country]) {\n    println!(\"{}\", city);\n}</code></pre>\n<p>上面的代码会输出以下内容：</p>\n<pre class=\"code-rows\"><code>Tokyo\nKyoto\nSão Paulo\nBrasília\nNairobi\nMombasa</code></pre>\n<p>可以这样理解，对于每个国家，我们都会检索其城市的向量，将所有向量串联成一个序列，然后打印出来。</p>\n<p>但请记住，迭代器是惰性的：只有当 <code>for</code> 循环调用了 <code>flat_map</code> 迭代器的 <code>next</code> 方法时才会实际工作。完整的串联序列从未在内存中构建过。不过，这里有一个小小的状态机，它会从城市迭代器中逐个提取，直到用完，然后才为下一个国家/ 地区生成一个新的城市迭代器。其效果实际上和嵌套循环一样，但封装成了迭代器以便使用。<span class=\"comment-number\">4</span></p>\n\n<h3 id=\"nav_point_248\">15.3.3　<code>flatten</code></h3>\n<p><code>flatten</code>（展平）适配器会串联起迭代器的各个条目，这里假设每个条目本身都是可迭代者：</p>\n<pre class=\"code-rows\"><code>use std::collections::BTreeMap;\n\n// 一个把城市映射为城市中停车场的表格：每个值都是一个向量\nlet mut parks = BTreeMap::new();\nparks.insert(\"Portland\",  vec![\"Mt. Tabor Park\", \"Forest Park\"]);\nparks.insert(\"Kyoto\",     vec![\"Tadasu-no-Mori Forest\", \"Maruyama Koen\"]);\nparks.insert(\"Nashville\", vec![\"Percy Warner Park\", \"Dragon Park\"]);\n\n// 构建一个表示全部停车场的向量。`values`给出了一个能生成\n// 向量的迭代器，然后`flatten`会依次生成每个向量的元素\nlet all_parks: Vec&lt;_&gt; = parks.values().flatten().cloned().collect();\n\nassert_eq!(all_parks,\n           vec![\"Tadasu-no-Mori Forest\", \"Maruyama Koen\", \"Percy Warner Park\",\n                \"Dragon Park\", \"Mt. Tabor Park\", \"Forest Park\"]);</code></pre>\n<p>名称 <code>\"flatten\"</code> 来自将二级结构展平为一级结构的直观图景：<code>BTreeMap</code> 及其表示停车场名称的 <code>Vec</code> 会被展平为一个能生成所有名称的迭代器。</p>\n<p><code>flatten</code> 的签名如下所示：</p>\n<pre class=\"code-rows\"><code>fn flatten(self) -&gt; impl Iterator&lt;Item=Self::Item::Item&gt;\n    where Self::Item: IntoIterator;</code></pre>\n<p>这意味着，底层迭代器的条目必须自行实现 <code>IntoIterator</code> 才能真正形成一个由序列组成的序列。然后，<code>flatten</code> 方法会返回一个迭代器，该迭代器会生成这些序列的串联。当然，这都是惰性执行的，只有当我们迭代完上一个序列才会从 <code>self</code> 中提取一个新序列。</p>\n<p><code>flatten</code> 方法还有一些看似不寻常的用法。如果你只想从一个 <code>Vec&lt;Option&lt;...&gt;&gt;</code> 中迭代出 <code>Some</code> 的值，那么 <code>flatten</code> 可以漂亮地完成此任务：</p>\n<pre class=\"code-rows\"><code>assert_eq!(vec![None, Some(\"day\"), None, Some(\"one\")]\n           .into_iter()\n           .flatten()\n           .collect::&lt;Vec&lt;_&gt;&gt;(),\n           vec![\"day\", \"one\"]);</code></pre>\n<p>这是因为 <code>Option</code> 本身也实现了 <code>IntoIterator</code>，表示由 0 个或 1 个元素组成的序列。<code>None</code> 元素对迭代没有任何贡献，而每个 <code>Some</code> 元素都会贡献一个值。同样，也可以用 <code>flatten</code> 来迭代 <code>Option&lt;Vec&lt;...&gt;&gt;</code> 值：其中 <code>None</code> 的行为等同于空向量。</p>\n<p><code>Result</code> 也实现了 <code>IntoIterator</code>，其中 <code>Err</code> 表示一个空序列，因此将 <code>flatten</code> 应用于 <code>Result</code> 值的迭代器有效地排除了所有 <code>Err</code> 并将它们丢弃，进而产生了一个解包装过的由成功值组成的流。通常不应该忽略代码中的错误，但如果你很清楚自己在做什么，那么这可能是个有用的小技巧。</p>\n<p>如果你发现自己随手用了 <code>flatten</code>，这个时候你真正需要的可能是 <code>flat_map</code>。例如，标准库的 <code>str::to_uppercase</code> 方法可以将字符串转换为大写，其工作方式如下所示：</p>\n<pre class=\"code-rows\"><code>fn to_uppercase(&amp;self) -&gt; String {\n    self.chars()\n        .map(char::to_uppercase)\n        .flatten() // 使用flat_map更好\n        .collect()\n}</code></pre>\n<p>用 <code>flatten</code> 的原因是 <code>ch.to_uppercase()</code> 返回的不是单个字符，而是会生成一个或多个字符的迭代器。将每个字符都映射成其对应的大写字母会生成由字符迭代器组成的迭代器，而 <code>flatten</code> 负责将它们拼接在一起，形成我们最终可以收集（<code>collect</code>）到 <code>String</code> 中的内容。</p>\n<p>不过 <code>map</code> 和 <code>flatten</code> 的组合非常常见，因此 <code>Iterator</code> 为这种情况提供了 <code>flat_map</code> 适配器。（事实上，<code>flat_map</code> 比 <code>flatten</code> 先纳入标准库。）因此，可以把前面的代码改写成如下形式。</p>\n<pre class=\"code-rows\"><code>fn to_uppercase(&amp;self) -&gt; String {\n    self.chars()\n        .flat_map(char::to_uppercase)\n        .collect()\n}</code></pre>\n<h3 id=\"nav_point_249\">15.3.4　<code>take</code> 与 <code>take_while</code></h3>\n<p><code>Iterator</code> 特型的 <code>take</code>（取出）适配器和 <code>take_while</code>（当……时取出）适配器的作用是当条目达到一定数量或闭包决定中止时结束迭代。它们的签名如下所示：</p>\n<pre class=\"code-rows\"><code>fn take(self, n: usize) -&gt; impl Iterator&lt;Item=Self::Item&gt;\n    where Self: Sized;\n\nfn take_while&lt;P&gt;(self, predicate: P) -&gt; impl Iterator&lt;Item=Self::Item&gt;\n    where Self: Sized, P: FnMut(&amp;Self::Item) -&gt; bool;</code></pre>\n<p>两者都会接手某个迭代器的所有权并返回一个新的迭代器，新的迭代器会从第一个迭代器中传递条目，并可能提早终止序列。<code>take</code> 迭代器会在最多生成 <code>n</code> 个条目后返回 <code>None</code>。<code>take_while</code> 迭代器会针对每个条目调用 <code>predicate</code>，并对 <code>predicate</code> 返回了 <code>false</code> 的首个条目以及其后的每个条目都返回 <code>None</code>。</p>\n<p>例如，给定一封电子邮件，其中有一个空行将标题与邮件正文分隔开，如果只想遍历标题就可以使用 <code>take_while</code>：</p>\n<pre class=\"code-rows\"><code>let message = \"To: jimb\\r\\n\\\n               From: superego &lt;editor@oreilly.com&gt;\\r\\n\\\n               \\r\\n\\\n               Did you get any writing done today?\\r\\n\\\n               When will you stop wasting time plotting fractals?\\r\\n\";\nfor header in message.lines().take_while(|l| !l.is_empty()) {\n    println!(\"{}\" , header);\n}</code></pre>\n<p>回想一下 3.7.1 节，当字符串中的一行以反斜杠结尾时，Rust 中不会包含字符串中下一行的缩进，因此字符串中的任何一行都没有前导空格。这意味着 <code>message</code> 的第 3 行是空白的。<code>take_while</code> 适配器一看到空行就会中止此迭代，所以此代码只会打印两行。</p>\n<pre class=\"code-rows\"><code>To: jimb\nFrom: superego &lt;editor@oreilly.com&gt;</code></pre>\n<h3 id=\"nav_point_250\">15.3.5　<code>skip</code> 与 <code>skip_while</code></h3>\n<p><code>Iterator</code> 特型的 <code>skip</code>（跳过）和 <code>skip_while</code>（当……时跳过）是与 <code>take</code> 和 <code>take_while</code> 互补的方法：<code>skip</code> 从迭代开始时就丢弃一定数量的条目，<code>skip_while</code> 则一直丢弃条目直到闭包终于找到一个可接受的条目为止，然后将剩下的条目按照原样传递出来。它们的签名如下所示：</p>\n<pre class=\"code-rows\"><code>fn skip(self, n: usize) -&gt; impl Iterator&lt;Item=Self::Item&gt;\n    where Self: Sized;\n\nfn skip_while&lt;P&gt;(self, predicate: P) -&gt; impl Iterator&lt;Item=Self::Item&gt;\n    where Self: Sized, P: FnMut(&amp;Self::Item) -&gt; bool;</code></pre>\n<p><code>skip</code> 适配器的常见用途之一是在迭代程序的命令行参数时跳过命令本身的名称。在第 2 章中，我们的最大公约数计算器曾用如下代码循环其命令行参数：</p>\n<pre class=\"code-rows\"><code>for arg in std::env::args().skip(1) {\n    ...\n}</code></pre>\n<p><code>std::env::args</code> 函数会返回一个迭代器，该迭代器会将程序的各个参数生成为一些 <code>String</code> 型条目，首个条目是程序本身的名称，但这并不是我们要在循环中处理的字符串。对该迭代器调用 <code>skip(1)</code> 会返回一个新的迭代器，新迭代器会在首次调用时丢弃程序名称，然后生成所有后续参数。</p>\n<p><code>skip_while</code> 适配器会使用闭包决定从序列的开头丢弃多少个条目。你还可以像下面这样遍历 15.3.4 节中消息正文的各行：</p>\n<pre class=\"code-rows\"><code>for body in message.lines()\n    .skip_while(|l| !l.is_empty())\n    .skip(1) {\n    println!(\"{}\" , body);\n}</code></pre>\n<p>这会使用 <code>skip_while</code> 来跳过非空行，但迭代器本身还是会生成一个空行——毕竟，闭包对该空行返回了 <code>false</code>。所以我们还要使用 <code>skip</code> 方法来丢弃它，并返回一个迭代器，其第一个条目是消息正文的第 1 行。与 15.3.4 节中的 <code>message</code> 声明合用，此代码会输出如下内容。</p>\n<pre class=\"code-rows\"><code>Did you get any writing done today?\nWhen will you stop wasting time plotting fractals?</code></pre>\n<h3 id=\"nav_point_251\">15.3.6　<code>peekable</code></h3>\n<p><code>peekable</code>（可窥视）迭代器的功能是允许我们窥视即将生成的下一个条目，而无须实际消耗它。调用 <code>Iterator</code> 特型的 <code>peekable</code> 方法可以将任何迭代器变成 <code>peekable</code> 迭代器：</p>\n<pre class=\"code-rows\"><code>fn peekable(self) -&gt; std::iter::Peekable&lt;Self&gt;\n    where Self: Sized;</code></pre>\n<p>在这里，<code>Peekable&lt;Self&gt;</code> 是一个实现了 <code>Iterator&lt;Item=Self::Item&gt;</code> 的结构体，而 <code>Self</code> 是底层迭代器的类型。</p>\n<p><code>peekable</code> 迭代器有一个额外的方法 <code>peek</code>，该方法会返回一个 <code>Option&lt;&amp;Item&gt;</code>：如果底层迭代器已耗尽，那么返回值就为 <code>None</code>；否则为 <code>Some(r)</code>，其中 <code>r</code> 是对下一个条目的共享引用。（注意，如果迭代器的条目类型已经是对某个值的引用了，则最终产出就会是对引用的引用。）</p>\n<p>调用 <code>peek</code> 会尝试从底层迭代器中提取下一个条目，如果条目存在，就将其缓存，直到下一次调用 <code>next</code> 时给出。<code>Peekable</code> 上的所有其他 <code>Iterator</code> 方法都知道这个缓存，比如，<code>peekable</code> 迭代器 <code>iter</code> 上的 <code>iter.last()</code> 就知道要在耗尽底层迭代器后检查此缓存。</p>\n<p>有时候，只有超前一点儿才能决定应该从迭代器中消耗多少个条目，在这种情况下，<code>peekable</code> 迭代器就变得至关重要。如果要从字符流中解析数值，那么在看到数值后面的第一个非数值字符之前是无法确定该数值的结束位置的：</p>\n<pre class=\"code-rows\"><code>use std::iter::Peekable;\n\nfn parse_number&lt;I&gt;(tokens: &amp;mut Peekable&lt;I&gt;) -&gt; u32\n    where I: Iterator&lt;Item=char&gt;\n{\n    let mut n = 0;\n    loop {\n        match tokens.peek() {\n            Some(r) if r.is_digit(10) =&gt; {\n                n = n * 10 + r.to_digit(10).unwrap();\n            }\n            _ =&gt; return n\n        }\n        tokens.next();\n    }\n}\n\nlet mut chars = \"226153980,1766319049\".chars().peekable();\nassert_eq!(parse_number(&amp;mut chars), 226153980);\n// 注意，`parse_number`并没有消耗这个逗号，所以我们能看到它\nassert_eq!(chars.next(), Some(','));\nassert_eq!(parse_number(&amp;mut chars), 1766319049);\nassert_eq!(chars.next(), None);</code></pre>\n<p><code>parse_number</code> 函数会使用 <code>peek</code> 来检查下一个字符，只有当它是数字时才消耗它。如果它不是数字或迭代器已消耗完（也就是说，<code>peek</code> 返回了 <code>None</code>），我们将返回已解析的数值并将下一个字符留在迭代器中，以供使用。</p>\n<h3 id=\"nav_point_252\">15.3.7　<code>fuse</code></h3>\n<p><code>Iterator</code> 特型并没有规定一旦 <code>next</code> 返回 <code>None</code> 之后，再次调用 <code>next</code> 方法时应该如何行动。大多数迭代器只是再次返回 <code>None</code>，但也有例外。如果你的代码依赖于“再次返回 <code>None</code>”这种行为，那么遇到例外可能会让你大吃一惊。</p>\n<p><code>fuse</code>（保险丝）适配器能接受任何迭代器并生成一个确保在第一次返回 <code>None</code> 后继续返回 <code>None</code> 的迭代器：</p>\n<pre class=\"code-rows\"><code>struct Flaky(bool);\n\nimpl Iterator for Flaky {\n    type Item = &amp;'static str;\n    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {\n        if self.0 {\n            self.0 = false;\n            Some(\"totally the last item\")\n        } else {\n            self.0 = true; // 糟糕！\n            None\n        }\n    }\n}\n\nlet mut flaky = Flaky(true);\nassert_eq!(flaky.next(), Some(\"totally the last item\"));\nassert_eq!(flaky.next(), None);\nassert_eq!(flaky.next(), Some(\"totally the last item\"));\n\nlet mut not_flaky = Flaky(true).fuse();\nassert_eq!(not_flaky.next(), Some(\"totally the last item\"));\nassert_eq!(not_flaky.next(), None);\nassert_eq!(not_flaky.next(), None);</code></pre>\n<p><code>fuse</code> 适配器在需要使用不明来源迭代器的泛型代码中非常有用。与其奢望要处理的每个迭代器都表现良好，还不如使用 <code>fuse</code> 加上保险。</p>\n<h3 id=\"nav_point_253\">15.3.8　可逆迭代器与 <code>rev</code></h3>\n<p>有的迭代器能够从序列的两端抽取条目，使用 <code>rev</code>（逆转）适配器可以反转此类迭代器。例如，向量上的迭代器就可以像从头开始一样轻松地从向量的末尾抽取条目。这样的迭代器可以实现 <code>std::iter::DoubleEndedIterator</code> 特型，它扩展了 <code>Iterator</code>：</p>\n<pre class=\"code-rows\"><code>trait DoubleEndedIterator: Iterator {\n    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;\n}</code></pre>\n<p>你可以将双端迭代器想象成用两根手指分别标记序列的当前首端和尾端。从任何一端提取条目都会让该手指向另一端前进，当两者相遇时，迭代就完成了：</p>\n<pre class=\"code-rows\"><code>let bee_parts = [\"head\", \"thorax\", \"abdomen\"];\n\nlet mut iter = bee_parts.iter();\nassert_eq!(iter.next(),      Some(&amp;\"head\"));\nassert_eq!(iter.next_back(), Some(&amp;\"abdomen\"));\nassert_eq!(iter.next(),      Some(&amp;\"thorax\"));\n\nassert_eq!(iter.next_back(), None);\nassert_eq!(iter.next(),      None);</code></pre>\n<p>基于切片迭代器的结构，这种行为实现起来非常简单：切片迭代器实际上是一对指向我们尚未生成的元素范围的起始指针和结束指针，<code>next</code> 和 <code>next_back</code> 所做的只是从起始指针或结束指针中提取一个条目而已。<code>BTreeSet</code> 和 <code>BTreeMap</code> 等有序集合的迭代器也是双端的：它们的 <code>next_back</code> 方法会首先提取最大的元素或条目。总体而言，只要有可能，标准库就会提供双端迭代能力。</p>\n<p>但并非所有迭代器都能如此轻松地实现，比如，从通道的 <code>Receiver</code> 中生成来自其他线程的值的迭代器显然无法预测最后接收的值可能是什么。一般来说，你需要查看标准库的文档以了解哪些迭代器实现了 <code>DoubleEndedIterator</code>，哪些没有实现。</p>\n<p>如果迭代器是双端的，就可以用 <code>rev</code> 适配器将其逆转：</p>\n<pre class=\"code-rows\"><code>fn rev(self) -&gt; impl Iterator&lt;Item=Self&gt;\n    where Self: Sized + DoubleEndedIterator;</code></pre>\n<p>返回的迭代器也是双端的，只是互换了 <code>next</code> 方法和 <code>next_back</code> 方法：</p>\n<pre class=\"code-rows\"><code>let meals = [\"breakfast\", \"lunch\", \"dinner\"];\n\nlet mut iter = meals.iter().rev();\nassert_eq!(iter.next(), Some(&amp;\"dinner\"));\nassert_eq!(iter.next(), Some(&amp;\"lunch\"));\nassert_eq!(iter.next(), Some(&amp;\"breakfast\"));\nassert_eq!(iter.next(), None);</code></pre>\n<p>大多数适配器，如果应用到某个可逆迭代器上，就会返回另一个可逆迭代器，比如，<code>map</code> 和 <code>filter</code> 都会保留可逆性。</p>\n<h3 id=\"nav_point_254\">15.3.9　<code>inspect</code></h3>\n<p><code>inspect</code>（探查）适配器为调试迭代器适配器的流水线提供了便利，但在生产代码中用得不多。<code>inspect</code> 只是对每个条目的共享引用调用闭包，然后传递该条目。闭包不会影响条目，但可以做一些事情，比如打印它们或对它们进行断言。</p>\n<p>本示例演示了将字符串转换为大写会更改其长度的情况：</p>\n<pre class=\"code-rows\"><code>let upper_case: String = \"große\".chars()\n    .inspect(|c| println!(\"before: {:?}\", c))\n    .flat_map(|c| c.to_uppercase())\n    .inspect(|c| println!(\" after:     {:?}\", c))\n    .collect();\nassert_eq!(upper_case, \"GROSSE\");</code></pre>\n<p>小写德语字母 <code>ß</code> 的大写形式是 <code>SS</code>，这就是 <code>char::to_uppercase</code> 会返回一个字符迭代器而不是单个字符的原因。前面的代码使用了 <code>flat_map</code> 将 <code>to_uppercase</code> 返回的所有序列连接成一个 <code>String</code>，同时输出以下内容。</p>\n<pre class=\"code-rows\"><code>before: 'g'\n after:    'G'\nbefore: 'r'\n after:    'R'\nbefore: 'o'\n after:    'O'\nbefore: 'ß'\n after:    'S'\n after:    'S'\nbefore: 'e'\n after:    'E'</code></pre>\n<h3 id=\"nav_point_255\">15.3.10　<code>chain</code></h3>\n<p><code>chain</code>（链接）适配器会将一个迭代器追加到另一个迭代器之后。更准确地说，<code>i1.chain(i2)</code> 会返回一个迭代器，该迭代器从 <code>i1</code> 中提取条目，直到用尽，然后从 <code>i2</code> 中提取条目。</p>\n<p><code>chain</code> 适配器的签名如下所示：</p>\n<pre class=\"code-rows\"><code>fn chain&lt;U&gt;(self, other: U) -&gt; impl Iterator&lt;Item=Self::Item&gt;\n    where Self: Sized, U: IntoIterator&lt;Item=Self::Item&gt;;</code></pre>\n<p>换句话说，你可以将迭代器与任何会生成相同条目类型的可迭代者链接在一起。</p>\n<p>例如：</p>\n<pre class=\"code-rows\"><code>let v: Vec&lt;i32&gt; = (1..4).chain([20, 30, 40]).collect();\nassert_eq!(v, [1, 2, 3, 20, 30, 40]);</code></pre>\n<p>如果 <code>chain</code> 的两个底层迭代器都是可逆的，则其结果迭代器也是可逆的：</p>\n<pre class=\"code-rows\"><code>let v: Vec&lt;i32&gt; = (1..4).chain([20, 30, 40]).rev().collect();\nassert_eq!(v, [40, 30, 20, 3, 2, 1]);</code></pre>\n<p><code>chain</code> 迭代器会跟踪这两个底层迭代器是否返回了 <code>None</code> 并按需把其中一个迭代器的 <code>next</code> 和 <code>next_back</code> 重定向到另一个迭代器的 <code>next</code> 和 <code>next_back</code>。</p>\n<h3 id=\"nav_point_256\">15.3.11　<code>enumerate</code></h3>\n<p><code>Iterator</code> 特型的 <code>enumerate</code>（枚举）适配器会将运行索引附加到序列中，它接受某个迭代器生成的条目 <code>A, B, C, ...</code> 并返回生成的值对 <code>(0, A), (1, B), (2, C), ...</code>。乍看起来，这微不足道，但其使用频率相当惊人。</p>\n<p>消费者可以使用上述索引将一个条目与另一个条目区分开来，并建立处理每个条目时的上下文。例如，第 2 章中的曼德博集绘图器会将图像分成 8 个水平条带，并将每个条带分配给不同的线程。该代码就使用了 <code>enumerate</code> 来告诉每个线程其条带对应于图像的哪个部分。</p>\n<p>从一个矩形像素缓冲区开始：</p>\n<pre class=\"code-rows\"><code>let mut pixels = vec![0; columns * rows];</code></pre>\n<p>接下来使用 <code>chunks_mut</code> 将图像拆分为一些水平条带，每个线程负责一个：</p>\n<pre class=\"code-rows\"><code>let threads = 8;\nlet band_rows = rows / threads + 1;\n...\nlet bands: Vec&lt;&amp;mut [u8]&gt; = pixels.chunks_mut(band_rows * columns).collect();</code></pre>\n<p>然后遍历条带，为每个条带启动一个线程：</p>\n<pre class=\"code-rows\"><code>for (i, band) in bands.into_iter().enumerate() {\n    let top = band_rows * i;\n    // 启动一个线程来渲染`top..top + band_rows`范围内的行\n    ...\n}</code></pre>\n<p>每次迭代都会得到一个 <code>(i, band)</code> 值对，其中 <code>band</code> 是 <code>&amp;mut [u8]</code> 类型的像素缓冲区切片，表示线程应该绘制的区域，而 <code>i</code> 是该条带在整个图像中的索引，由 <code>enumerate</code> 适配器提供。绘图的边界和条带的大小足以让线程确定分配给它的是图像中的哪个部分，从而确定要在 <code>band</code> 中绘制什么。</p>\n<p>可以将 <code>enumerate</code> 生成的 <code>(index, item)</code> 值对视为在迭代 <code>HashMap</code> 或其他关联集合时获得的 <code>(key, value)</code> 值对。如果在切片或向量上进行迭代，则 <code>index</code> 就是 <code>item</code> 对应的 <code>key</code>。</p>\n<h3 id=\"nav_point_257\">15.3.12　<code>zip</code></h3>\n<p><code>zip</code>（拉合）适配器会将两个迭代器组合成一个迭代器，新的迭代器会生成值对，每个底层迭代器各提供一个值，就像把拉链的两侧拉合起来一样。当两个底层迭代器中的任何一个已结束时，拉合后的迭代器就结束了。</p>\n<p>例如，可以通过将无尽范围 <code>0..</code> 与一个迭代器拉合起来获得与 <code>enumerate</code> 适配器相同的效果：</p>\n<pre class=\"code-rows\"><code>let v: Vec&lt;_&gt; = (0..).zip(\"ABCD\".chars()).collect();\nassert_eq!(v, vec![(0, 'A'), (1, 'B'), (2, 'C'), (3, 'D')]);</code></pre>\n<p>从这个意义上说，你可以将 <code>zip</code> 视为 <code>enumerate</code> 的泛化版本：<code>enumerate</code> 会将索引附加到序列，而 <code>zip</code> 能附加来自任意迭代器的条目。之前我们建议用 <code>enumerate</code> 在处理条目时协助提供上下文，而 <code>zip</code> 提供了一种更灵活的方式来实现同样的效果。</p>\n<p><code>zip</code> 的参数本身不一定是迭代器，可以是任意可迭代者。</p>\n<pre class=\"code-rows\"><code>use std::iter::repeat;\n\nlet endings = [\"once\", \"twice\", \"chicken soup with rice\"];\nlet rhyme: Vec&lt;_&gt; = repeat(\"going\")\n    .zip(endings)\n    .collect();\nassert_eq!(rhyme, vec![(\"going\", \"once\"),\n                       (\"going\", \"twice\"),\n                       (\"going\", \"chicken soup with rice\")]);</code></pre>\n<h3 id=\"nav_point_258\">15.3.13　<code>by_ref</code></h3>\n<p>前面我们一直在将适配器附加到迭代器上。一旦开始这样做，还能再取下适配器吗？一般来说是不能，因为适配器会接手底层迭代器的所有权，并且没有提供归还所有权的方法。</p>\n<p>迭代器的 <code>by_ref</code>（按引用）方法会借入迭代器的可变引用，便于将各种适配器应用于该引用。一旦消耗完适配器中的条目，就会丢弃这些适配器，借用也就结束了，然后你就能重新获得对原始迭代器的访问权。</p>\n<p>例如，在本章前面我们展示过如何使用 <code>take_while</code> 和 <code>skip_while</code> 来处理邮件消息的标题行和正文。但是，如果想让两者使用同一个底层迭代器来处理邮件消息，该怎么办呢？借助 <code>by_ref</code>，我们就可以使用 <code>take_while</code> 来处理邮件头，完成这些之后，取回底层迭代器，此时 <code>take_while</code> 恰好位于处理消息正文的适当位置：</p>\n<pre class=\"code-rows\"><code>let message = \"To: jimb\\r\\n\\\n               From: id\\r\\n\\\n               \\r\\n\\\n               Oooooh, donuts!!\\r\\n\";\n\nlet mut lines = message.lines();\n\nprintln!(\"Headers:\");\nfor header in lines.by_ref().take_while(|l| !l.is_empty()) {\n    println!(\"{}\" , header);\n}\n\nprintln!(\"\\nBody:\");\nfor body in lines {\n    println!(\"{}\" , body);\n}</code></pre>\n<p>调用 <code>lines.by_ref()</code> 会借出一个对迭代器的可变引用，<code>take_while</code> 迭代器会取得这个引用的所有权。该迭代器在第一个 <code>for</code> 循环结束时超出了作用域，表示本次借用已结束，这样你就能在第二个 <code>for</code> 循环中再次使用 <code>lines</code> 了。上述代码将输出以下内容：</p>\n<pre class=\"code-rows\"><code>Headers:\nTo: jimb\nFrom: id\n\nBody:\nOooooh, donuts!!</code></pre>\n<p><code>by_ref</code> 适配器的定义很简单：它会返回对迭代器的可变引用。然后，标准库中还包含了这个神奇的小实现：</p>\n<pre class=\"code-rows\"><code>impl&lt;'a, I: Iterator + ?Sized&gt; Iterator for &amp;'a mut I {\n    type Item = I::Item;\n    fn next(&amp;mut self) -&gt; Option&lt;I::Item&gt; {\n        (**self).next()\n    }\n    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {\n        (**self).size_hint()\n    }\n}</code></pre>\n<p>换句话说，如果 <code>I</code> 是某种迭代器类型，那么 <code>&amp;mut I</code> 就同样是一个迭代器，其 <code>next</code> 方法和 <code>size_hint</code> 方法会转发给其引用目标。当你在此迭代器的可变引用上调用某个适配器时，适配器会取得<strong>引用</strong>（而不是迭代器本身）的所有权。当适配器超出作用域时，本次借用就会结束。</p>\n<h3 id=\"nav_point_259\">15.3.14　<code>cloned</code> 与 <code>copied</code></h3>\n<p><code>cloned</code>（克隆后）适配器会接受一个生成引用的迭代器，并返回一个会生成从这些引用克隆而来的值的迭代器，就像 <code>iter.map(|item| item.clone())</code>。当然，引用目标的类型也必须实现了 <code>Clone</code>：</p>\n<pre class=\"code-rows\"><code>let a = ['1', '2', '3', '∞'];\n\nassert_eq!(a.iter().next(),          Some(&amp;'1'));\nassert_eq!(a.iter().cloned().next(), Some('1'));</code></pre>\n<p><code>copied</code>（复制后）适配器的设计思想同样如此，但限制更严格，它要求引用目标的类型必须实现了 <code>Copy</code>。像 <code>iter.copied()</code> 这样的调用与 <code>iter.map(|r| *r)</code> 大致相同。由于每个实现了 <code>Copy</code> 的类型也必定实现了 <code>Clone</code>，因此 <code>cloned</code> 更通用。但根据条目类型的不同，<code>clone</code> 调用可能会进行任意次数的分配和复制。如果你认为由于条目类型很简单，因而永远不会发生内存分配，那么最好使用 <code>copied</code> 来让类型检查器帮你验证这种假设。</p>\n<h3 id=\"nav_point_260\">15.3.15　<code>cycle</code></h3>\n<p><code>cycle</code>（循环）适配器会返回一个迭代器，它会无限重复底层迭代器生成的序列。底层迭代器必须实现 <code>std::clone::Clone</code>，以便 <code>cycle</code> 保存其初始状态并且在每次循环重新开始时复用它。下面是一个例子：</p>\n<pre class=\"code-rows\"><code>let dirs = [\"North\", \"East\", \"South\", \"West\"];\nlet mut spin = dirs.iter().cycle();\nassert_eq!(spin.next(), Some(&amp;\"North\"));\nassert_eq!(spin.next(), Some(&amp;\"East\"));\nassert_eq!(spin.next(), Some(&amp;\"South\"));\nassert_eq!(spin.next(), Some(&amp;\"West\"));\nassert_eq!(spin.next(), Some(&amp;\"North\"));\nassert_eq!(spin.next(), Some(&amp;\"East\"));</code></pre>\n<p>或者，下面是纯粹为了演示迭代器的用法而编写的代码：</p>\n<pre class=\"code-rows\"><code>use std::iter::;\n\nlet fizzes = repeat(\"\").take(2).chain(once(\"fizz\")).cycle();\nlet buzzes = repeat(\"\").take(4).chain(once(\"buzz\")).cycle();\nlet fizzes_buzzes = fizzes.zip(buzzes);\n\nlet fizz_buzz = (1..100).zip(fizzes_buzzes)\n    .map(|tuple|\n        match tuple {\n            (i, (\"\", \"\")) =&gt; i.to_string(),\n            (_, (fizz, buzz)) =&gt; format!(\"{}{}\", fizz, buzz)\n        });\n\nfor line in fizz_buzz {\n    println!(\"{}\", line);\n}</code></pre>\n<p>这是一个儿童文字游戏，现在有时会用作程序员的求职面试问题：玩家轮流数数，将任何可被 3 整除的数值替换为单词 <code>fizz</code>；将任何可被 5 整除的数值替换为单词 <code>buzz</code>；能被两者整除的数值则替换为单词 <code>fizzbuzz</code>。</p>\n<h2 id=\"nav_point_261\">15.4　消耗迭代器</h2>\n<p>迄今为止，我们已经介绍了创建迭代器并将它们适配成新迭代器的方法，在这里，我们会通过展示如何消耗它们来完成整个处理过程。</p>\n<p>当然，你可以使用带有 <code>for</code> 循环的迭代器，也可以显式调用 <code>next</code>，但有许多常见任务不必一遍又一遍地写出来。<code>Iterator</code> 特型提供了一大组可选方法来涵盖其中的许多任务。</p>\n<h3 id=\"nav_point_262\">15.4.1　简单累加：<code>count</code>、<code>sum</code> 和 <code>product</code></h3>\n<p><code>count</code>（计数）方法会从迭代器中提取条目，直到迭代器返回 <code>None</code>，并报告提取的条目数。下面是一个计算标准输入行数的小程序：<span class=\"comment-number\">5</span></p>\n\n<pre class=\"code-rows\"><code>use std::io::prelude::*;\n\nfn main() {\n    let stdin = std::io::stdin();\n    println!(\"{}\", stdin.lock().lines().count());\n}</code></pre>\n<p><code>sum</code>（求和）方法和 <code>product</code>（乘积）方法会分别计算迭代器条目之和与乘积，结果必须是整数或浮点数。</p>\n<pre class=\"code-rows\"><code>fn triangle(n: u64) -&gt; u64 {\n    (1..=n).sum()\n}\nassert_eq!(triangle(20), 210);\n\nfn factorial(n: u64) -&gt; u64 {\n    (1..=n).product()\n}\nassert_eq!(factorial(20), 2432902008176640000);</code></pre>\n<p>（为方便与其他类型一起工作，可以通过实现 <code>std::iter::Sum</code> 特型和 <code>std::iter::Product</code> 特型来扩展 <code>sum</code> 和 <code>product</code>，这里我们就不展开讲解这些特型了。）</p>\n<h3 id=\"nav_point_263\">15.4.2　<code>min</code> 与 <code>max</code></h3>\n<p><code>Iterator</code> 上的 <code>min</code>（最小）方法和 <code>max</code>（最大）方法会分别返回迭代器生成的最小条目与最大条目。迭代器的条目类型必须实现 <code>std::cmp::Ord</code>，这样条目之间才能相互比较：</p>\n<pre class=\"code-rows\"><code>assert_eq!([-2, 0, 1, 0, -2, -5].iter().max(), Some(&amp;1));\nassert_eq!([-2, 0, 1, 0, -2, -5].iter().min(), Some(&amp;-5));</code></pre>\n<p>这些方法会返回一个 <code>Option&lt;Self::Item&gt;</code> 以便当迭代器不再生成任何条目时能返回 <code>None</code>。</p>\n<p>就像 12.2 节中所讲的，Rust 的浮点类型 <code>f32</code> 和 <code>f64</code> 仅实现了 <code>std::cmp::PartialOrd</code> 而没有实现 <code>std::cmp::Ord</code>，因此不能使用 <code>min</code> 方法和 <code>max</code> 方法来计算浮点数序列中的最小值和最大值。这在 Rust 设计中并不讨喜，却是经过深思熟虑的——因为不清楚这些函数该如何处理 IEEE 的 <code>NaN</code> 值，如果只是简单地忽略则可能会掩盖代码中更严重的问题。</p>\n<p>如果知道如何处理 <code>NaN</code> 值，则可以改用 <code>max_by</code> 和 <code>min_by</code> 迭代器方法，这样你就可以提供自己的比较函数了。</p>\n<h3 id=\"nav_point_264\">15.4.3　<code>max_by</code> 与 <code>min_by</code></h3>\n<p><code>max_by</code>（据……最大）方法和 <code>min_by</code>（据……最小）方法会分别返回迭代器生成的最大条目与最小条目，由你提供的比较函数确定规则：</p>\n<pre class=\"code-rows\"><code>use std::cmp::Ordering;\n\n// 比较两个f64值，如果其一是NaN，则引发panic\nfn cmp(lhs: &amp;f64, rhs: &amp;f64) -&gt; Ordering {\n    lhs.partial_cmp(rhs).unwrap()\n}\n\nlet numbers = [1.0, 4.0, 2.0];\nassert_eq!(numbers.iter().copied().max_by(cmp), Some(4.0));\nassert_eq!(numbers.iter().copied().min_by(cmp), Some(1.0));\n\nlet numbers = [1.0, 4.0, std::f64::NAN, 2.0];\nassert_eq!(numbers.iter().copied().max_by(cmp), Some(4.0)); // 引发panic</code></pre>\n<p><code>max_by</code> 方法和 <code>min_by</code> 方法会通过引用将条目传给比较函数，这样一来，这两个方法就可以与任意种类的迭代器一起高效配合使用。在上面的代码中，虽然我们已经用 <code>copied</code> 获取了会生成 <code>f64</code> 条目的迭代器，但 <code>cmp</code> 函数还是期望通过引用获取其参数。</p>\n<h3 id=\"nav_point_265\">15.4.4　<code>max_by_key</code> 与 <code>min_by_key</code></h3>\n<p>使用 <code>Iterator</code> 上的 <code>max_by_key</code>（据键最大）方法和 <code>min_by_key</code>（据键最小）方法可以选择最大条目或最小条目，由针对每个条目调用的闭包确定。闭包可以选择条目的某些字段或对此条目执行某些计算。由于你通常只对与某些最小值或最大值相关的数据感兴趣，而不仅仅是极值本身，因此这两个函数通常比 <code>max</code> 和 <code>min</code> 更有用。它们的签名如下所示：</p>\n<pre class=\"code-rows\"><code>fn min_by_key&lt;B: Ord, F&gt;(self, f: F) -&gt; Option&lt;Self::Item&gt;\n    where Self: Sized, F: FnMut(&amp;Self::Item) -&gt; B;\n\nfn max_by_key&lt;B: Ord, F&gt;(self, f: F) -&gt; Option&lt;Self::Item&gt;\n    where Self: Sized, F: FnMut(&amp;Self::Item) -&gt; B;</code></pre>\n<p>也就是说，给定一个接受某条目并返回任意有序类型 <code>B</code> 的闭包，则返回那个调用闭包时所返回的 <code>B</code> 为最大或最小的条目；如果没有生成任何条目，则返回 <code>None</code>。</p>\n<p>例如，要扫描城市的哈希表，分别查找人口最多和最少的城市，可以这样写：</p>\n<pre class=\"code-rows\"><code>use std::collections::HashMap;\n\nlet mut populations = HashMap::new();\npopulations.insert(\"Portland\",  583_776);\npopulations.insert(\"Fossil\",        449);\npopulations.insert(\"Greenhorn\",       2);\npopulations.insert(\"Boring\",      7_762);\npopulations.insert(\"The Dalles\", 15_340);\n\nassert_eq!(populations.iter().max_by_key(|&amp;(_name, pop)| pop),\n           Some((&amp;\"Portland\", &amp;583_776)));\nassert_eq!(populations.iter().min_by_key(|&amp;(_name, pop)| pop),\n           Some((&amp;\"Greenhorn\", &amp;2)));</code></pre>\n<p>闭包 <code>|&amp;(_name, pop)| pop</code> 会针对迭代器生成的每个条目进行调用并返回要用于比较的值——在本例中为城市人口。这两个方法返回的值是整个条目，而不仅仅是闭包返回的值。（当然，如果要频繁进行这样的条目查询，最好用一种比在表中进行线性查找更高效的方式。）</p>\n<h3 id=\"nav_point_266\">15.4.5　对条目序列进行比较</h3>\n<p>如果字符串、向量和切片的各个元素是可比较的，我们就可以使用 <code>&lt;</code> 运算符和 <code>==</code> 运算符来对它们进行比较。但是，比较运算符不能用来比较迭代器，这项工作是由像 <code>eq</code> 和 <code>lt</code> 这样的方法来完成的。相关方法从迭代器中成对取出条目并比较，直到得出结果：</p>\n<pre class=\"code-rows\"><code>let packed = \"Helen of Troy\";\nlet spaced = \"Helen   of    Troy\";\nlet obscure = \"Helen of Sandusky\"; // 好人，只是不出名\n\nassert!(packed != spaced);\nassert!(packed.split_whitespace().eq(spaced.split_whitespace()));\n\n// 此断言为真，因为' ' &lt; 'o'\nassert!(spaced &lt; obscure);\n\n// 此断言为真，因为'Troy' &gt; 'Sandusky'\nassert!(spaced.split_whitespace().gt(obscure.split_whitespace()));</code></pre>\n<p>调用 <code>split_whitespace</code> 会返回字符串中以空白字符分隔的单词的迭代器。在这些迭代器上使用 <code>eq</code> 方法和 <code>gt</code> 方法会进行逐词比较（而不是逐字符比较），因为 <code>&amp;str</code> 实现了 <code>PartialOrd</code> 和 <code>PartialEq</code>。</p>\n<p>迭代器提供的比较方法既包括用于相等比较的 <code>eq</code> 方法和 <code>ne</code> 方法，也包括用于有序比较的 <code>lt</code> 方法、<code>le</code> 方法、<code>gt</code> 方法和 <code>ge</code> 方法。而 <code>cmp</code> 方法和 <code>partial_cmp</code> 方法的行为类似于 <code>Ord</code> 特型和 <code>PartialOrd</code> 特型的相应方法。</p>\n<h3 id=\"nav_point_267\">15.4.6　<code>any</code> 与 <code>all</code></h3>\n<p><code>any</code>（任意）方法和 <code>all</code>（所有）方法会将闭包应用于迭代器生成的每个条目。如果闭包对任意条目返回了 <code>true</code> 或对所有条目都返回了 <code>true</code>，则相应的方法返回 <code>true</code>：</p>\n<pre class=\"code-rows\"><code>let id = \"Iterator\";\n\nassert!( id.chars().any(char::is_uppercase));\nassert!(!id.chars().all(char::is_uppercase));</code></pre>\n<p>这两个方法只会消耗确定答案所需的尽可能少的条目。如果闭包已经为给定条目返回了 <code>true</code>，则 <code>any</code> 会立即返回 <code>true</code>，不会再从迭代器中提取更多条目。</p>\n<h3 id=\"nav_point_268\">15.4.7　<code>position</code>、<code>rposition</code> 和 <code>ExactSizeIterator</code></h3>\n<p><code>position</code>（位置）方法会针对迭代器中的每个条目调用闭包，并返回调用结果为 <code>true</code> 的第一个条目的索引。确切而言，它会返回关于此索引的 <code>Option</code>：如果闭包没有为任何条目返回 <code>true</code>，则 <code>position</code> 返回 <code>None</code>。一旦闭包返回 <code>true</code>，<code>position</code> 就会停止提取条目：</p>\n<pre class=\"code-rows\"><code>let text = \"Xerxes\";\nassert_eq!(text.chars().position(|c| c == 'e'), Some(1));\nassert_eq!(text.chars().position(|c| c == 'z'), None);</code></pre>\n<p><code>rposition</code>（右起位置）方法也是一样的，只是从右侧开始搜索：</p>\n<pre class=\"code-rows\"><code>let bytes = b\"Xerxes\";\nassert_eq!(bytes.iter().rposition(|&amp;c| c == b'e'), Some(4));\nassert_eq!(bytes.iter().rposition(|&amp;c| c == b'X'), Some(0));</code></pre>\n<p><code>rposition</code> 方法要求使用可逆迭代器，以便它能从此序列的右端提取条目。另外，它也要求这是确切大小迭代器，以便能像 <code>position</code> 一样对索引进行赋值，最左边的索引值为 <code>0</code>。所谓确切大小迭代器就是实现了 <code>std::iter::ExactSizeIterator</code> 特型的迭代器：</p>\n<pre class=\"code-rows\"><code>trait ExactSizeIterator: Iterator {\n    fn len(&amp;self) -&gt; usize { ... }\n    fn is_empty(&amp;self) -&gt; bool { ... }\n}</code></pre>\n<p><code>len</code> 方法会返回剩余的条目数，而 <code>is_empty</code> 方法会在迭代完成时返回 <code>true</code>。</p>\n<p>自然，也不是每个迭代器都能预知要生成的条目数，比如，之前使用的 <code>str::chars</code> 迭代器就不能（UTF-8 是可变宽度编码），因此不能在字符串上使用 <code>rposition</code>。但是字节数组上的迭代器必定知道数组的长度，因此它可以实现 <code>ExactSizeIterator</code>。</p>\n<h3 id=\"nav_point_269\">15.4.8　<code>fold</code> 与 <code>rfold</code></h3>\n<p><code>fold</code>（折叠）方法是一种非常通用的工具，用于在迭代器生成的整个条目序列上累积某种结果。给定一个初始值（我们称之为<strong>累加器</strong>）和一个闭包，<code>fold</code> 会以当前累加器和迭代器中的下一个条目为参数反复调用这个闭包。闭包返回的值被视为新的累加器，并将其与下一个条目一起传给闭包。最终，累加器的值就是 <code>fold</code> 本身返回的值。如果序列为空，则 <code>fold</code> 只返回初始累加器。</p>\n<p>使用迭代器值的许多其他方法可以改写成对 <code>fold</code> 的使用：</p>\n<pre class=\"code-rows\"><code>let a = [5, 6, 7, 8, 9, 10];\n\nassert_eq!(a.iter().fold(0, |n, _| n+1), 6);        // 计数\nassert_eq!(a.iter().fold(0, |n, i| n+i), 45);       // 求和\nassert_eq!(a.iter().fold(1, |n, i| n*i), 151200);   // 乘积\n\n// 最大值\nassert_eq!(a.iter().cloned().fold(i32::min_value(), std::cmp::max),\n           10);</code></pre>\n<p><code>fold</code> 方法的签名如下所示：</p>\n<pre class=\"code-rows\"><code>fn fold&lt;A, F&gt;(self, init: A, f: F) -&gt; A\n    where Self: Sized, F: FnMut(A, Self::Item) -&gt; A;</code></pre>\n<p>这里，<code>A</code> 是累加器的类型。闭包的第一个参数 <code>init</code> 及其返回值都是类型 <code>A</code>，<code>fold</code> 自身的返回值也是类型 <code>A</code>。</p>\n<p>请注意，累加器的值会移动进闭包或者从闭包中移动出来，因此你可以将 <code>fold</code> 与各种非 <code>Copy</code> 的累加器类型一起使用：</p>\n<pre class=\"code-rows\"><code>let a = [\"Pack\", \"my\", \"box\", \"with\",\n         \"five\", \"dozen\", \"liquor\", \"jugs\"];\n\n// 另见切片的`join`方法，它不会像这里一样帮你在末尾添加额外的空格\nlet pangram = a.iter()\n    .fold(String::new(), |s, w| s + w + \" \");\nassert_eq!(pangram, \"Pack my box with five dozen liquor jugs \");</code></pre>\n<p><code>rfold</code>（右起折叠）方法与 <code>fold</code> 方法基本相同，但需要一个双端迭代器，并从后往前处理各个条目。</p>\n<pre class=\"code-rows\"><code>let weird_pangram = a.iter()\n    .rfold(String::new(), |s, w| s + w + \" \");\nassert_eq!(weird_pangram, \"jugs liquor dozen five with box my Pack \");</code></pre>\n<h3 id=\"nav_point_270\">15.4.9　<code>try_fold</code> 与 <code>try_rfold</code></h3>\n<p><code>try_fold</code>（尝试折叠）方法与 <code>fold</code> 方法基本相同，不过迭代可以提前退出，无须消耗迭代器中的所有值。传给 <code>try_fold</code> 的闭包返回的值会指出它是应该立即返回，还是继续折叠迭代器的条目。</p>\n<p>闭包可以返回多种类型的值，根据类型值，<code>try_fold</code> 方法可判断继续折叠的方式。</p>\n<ul>\n<li>如果闭包返回 <code>Result&lt;T, E&gt;</code>，可能是因为它执行了 I/O 或其他一些容易出错的操作，那就返回 <code>Ok(v)</code> 令 <code>try_fold</code> 继续折叠，同时将 <code>v</code> 作为新的累加器值。如果返回 <code>Err(e)</code>，则 <code>try_fold</code> 立即停止折叠。折叠后的最终值是一个带有最终累加器值的 <code>Result</code>，或者由闭包返回的错误值。</li>\n<li>如果闭包返回 <code>Option&lt;T&gt;</code>，则 <code>Some(v)</code> 表示折叠应该以 <code>v</code> 作为新的累加器值继续前进，而 <code>None</code> 表示迭代应该立即停止。折叠后的最终值也是 <code>Option</code> 类型的。</li>\n<li>最后，闭包还可以返回一个 <code>std::ops::ControlFlow</code> 值。这种类型是一个具有两个变体的枚举，即 <code>Continue(c)</code> 和 <code>Break(b)</code>，分别表示使用新的累加器值 <code>c</code> 继续或提前中止迭代。折叠的最终结果是一个 <code>ControlFlow</code> 值：如果折叠消耗了整个迭代器，并生成了最终的累加器值 <code>v</code>，则为 <code>Continue(v)</code>；如果闭包中途返回了值 <code>b</code>，则为 <code>Break(b)</code>。</li>\n</ul>\n<p><code>Continue(c)</code> 和 <code>Break(b)</code> 的行为与 <code>Ok(c)</code> 和 <code>Err(b)</code> 完全一样。使用 <code>ControlFlow</code> 而不用 <code>Result</code> 的优点在于，有时候提前退出并不表示出错了，而只是表明提前得出了答案，这种情况下它会让代码可读性更好。我们接下来会展示一个例子。</p>\n<p>下面是一段对从标准输入读取的数值进行求和的程序：</p>\n<pre class=\"code-rows\"><code>use std::error::Error;\nuse std::io::prelude::*;\nuse std::str::FromStr;\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let stdin = std::io::stdin();\n    let sum = stdin.lock()\n        .lines()\n        .try_fold(0, |sum, line| -&gt; Result&lt;u64, Box&lt;dyn Error&gt;&gt; {\n            Ok(sum + u64::from_str(&amp;line?.trim())?)\n        })?;\n    println!(\"{}\", sum);\n    Ok(())\n}</code></pre>\n<p>缓冲输入流上的 <code>lines</code> 迭代器会生成 <code>Result&lt;String, std::io::Error&gt;</code> 类型的条目，并且将 <code>String</code> 解析为整数时也可能会出错。在这里使用 <code>try_fold</code> 会让闭包返回 <code>Result&lt;u64, ...&gt;</code>，所以我们可以使用 <code>?</code> 运算符将本次失败从闭包传播到 <code>main</code> 函数。</p>\n<p><code>try_fold</code> 非常灵活，被用来实现 <code>Iterator</code> 的许多其他消费者方法，比如，以下是 <code>all</code> 的一种实现：</p>\n<pre class=\"code-rows\"><code>fn all&lt;P&gt;(&amp;mut self, mut predicate: P) -&gt; bool\n    where P: FnMut(Self::Item) -&gt; bool,\n          Self: Sized\n{\n    use std::ops::ControlFlow::*;\n    self.try_fold((), |_, item| {\n        if predicate(item) { Continue(()) } else { Break(()) }\n    }) == Continue(())\n}</code></pre>\n<p>请注意，这里无法用普通的 <code>fold</code> 来写，<code>all</code> 的语义承诺了一旦 <code>predicate</code> 返回 <code>false</code> 就停止从底层迭代器中消耗条目，但 <code>fold</code> 总是会消耗掉整个迭代器。</p>\n<p>如果你正在实现自己的迭代器类型，就值得研究一下你的迭代器能否比 <code>Iterator</code> 特型的默认定义更高效地实现 <code>try_fold</code>。如果可以为 <code>try_fold</code> 提速，那么基于它构建的所有其他方法都会受益。</p>\n<p>顾名思义，<code>try_rfold</code>（尝试右起折叠）方法与 <code>try_fold</code> 方法相同，只是从后面而不是前面开始提取值，并且要求传入一个双端迭代器。</p>\n<h3 id=\"nav_point_271\">15.4.10　<code>nth</code> 与 <code>nth_back</code></h3>\n<p><code>nth</code>（第 <em>n</em> 个）方法会接受索引参数 <code>n</code>，从迭代器中跳过 <code>n</code> 个条目，并返回下一个条目，如果序列提前结束了，则返回 <code>None</code>。调用 <code>.nth(0)</code> 等效于 <code>.next()</code>。</p>\n<p><code>nth</code> 不会像适配器那样接手迭代器的所有权，因此可以多次调用：</p>\n<pre class=\"code-rows\"><code>let mut squares = (0..10).map(|i| i*i);\n\nassert_eq!(squares.nth(4), Some(16));\nassert_eq!(squares.nth(0), Some(25));\nassert_eq!(squares.nth(6), None);</code></pre>\n<p>它的签名如下所示：</p>\n<pre class=\"code-rows\"><code>fn nth(&amp;mut self, n: usize) -&gt; Option&lt;Self::Item&gt;\n    where Self: Sized;</code></pre>\n<p><code>nth_back</code>（倒数第 <em>n</em> 个）方法与 <code>nth</code> 方法很像，只是从双端迭代器的后面往前提取。调用 <code>.nth_back(0)</code> 等效于 <code>.next_back()</code>：返回最后一个条目；如果迭代器为空则返回 <code>None</code>。</p>\n<h3 id=\"nav_point_272\">15.4.11　<code>last</code></h3>\n<p><code>last</code>（最后一个）方法会返回迭代器生成的最后一个条目，如果为空则返回 <code>None</code>。它的签名如下所示：</p>\n<pre class=\"code-rows\"><code>fn last(self) -&gt; Option&lt;Self::Item&gt;;</code></pre>\n<p>例如：</p>\n<pre class=\"code-rows\"><code>let squares = (0..10).map(|i| i*i);\nassert_eq!(squares.last(), Some(81));</code></pre>\n<p>会从前面开始消耗所有迭代器的条目，即便此迭代器是可逆的也会如此。如果你有一个可逆迭代器并且不想消耗它的所有条目，应该只写 <code>iter.next_back()</code>。</p>\n<h3 id=\"nav_point_273\">15.4.12　<code>find</code>、<code>rfind</code> 和 <code>find_map</code></h3>\n<p><code>find</code>（查找）方法会从迭代器中提取条目，返回第一个由给定闭包回复 <code>true</code> 的条目，如果序列在找到合适的条目之前就结束了则返回 <code>None</code>。它的签名如下所示：</p>\n<pre class=\"code-rows\"><code>fn find&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;Self::Item&gt;\n    where Self: Sized,\n          P: FnMut(&amp;Self::Item) -&gt; bool;</code></pre>\n<p><code>rfind</code>（右起查找）方法与此类似，但要求迭代器为双端迭代器并从后往前搜索值，返回<strong>最后</strong>一个给定闭包回复为 <code>true</code> 的条目。</p>\n<p>例如，使用 15.4.4 节的城市和人口表，你可以这样写：</p>\n<pre class=\"code-rows\"><code>assert_eq!(populations.iter().find(|&amp;(_name, &amp;pop)| pop &gt; 1_000_000),\n           None);\nassert_eq!(populations.iter().find(|&amp;(_name, &amp;pop)| pop &gt; 500_000),\n           Some((&amp;\"Portland\", &amp;583_776)));</code></pre>\n<p>这个表中没有任何城市的人口超过一百万，但有一个城市有五十万人口。</p>\n<p>有时候，闭包不仅仅是一个简单的谓词——对每个条目进行逻辑判断并继续向前，它还可能是更复杂的东西，比如生成一个有意义的值。在这种情况下就需要使用 <code>find_map</code>（查找并映射），它的签名如下所示：</p>\n<pre class=\"code-rows\"><code>fn find_map&lt;B, F&gt;(&amp;mut self, f: F) -&gt; Option&lt;B&gt; where\n    F: FnMut(Self::Item) -&gt; Option&lt;B&gt;;</code></pre>\n<p><code>find_map</code> 和 <code>find</code> 很像，但其闭包不会返回 <code>bool</code>，而是返回某个值的 <code>Option</code>。<code>find_map</code> 会返回第一个类型为 <code>Some</code> 的 <code>Option</code>。</p>\n<p>假设有个城市内部公园的数据库，而我们要查看其中的公园是否有火山，有的话就给出公园的名称。</p>\n<pre class=\"code-rows\"><code>let big_city_with_volcano_park = populations.iter()\n    .find_map(|(&amp;city, _)| {\n        if let Some(park) = find_volcano_park(city, &amp;parks) {\n            // find_map会返回下面的值，以便让调用者知道我们找到了哪个公园\n            return Some((city, park.name));\n        }\n\n        // 拒绝此条目，并继续搜索\n        None\n    });\n\nassert_eq!(big_city_with_volcano_park,\n           Some((\"Portland\", \"Mt. Tabor Park\")));</code></pre>\n<h3 id=\"nav_point_274\">15.4.13　构建集合：<code>collect</code> 与 <code>FromIterator</code></h3>\n<p>本书一直在用 <code>collect</code>（收集）方法构建包含迭代器条目的向量，比如，在第 2 章中，我们曾调用 <code>std::env::args()</code> 获取程序命令行参数的迭代器，然后调用该迭代器的 <code>collect</code> 方法把它们收集到一个向量中：</p>\n<pre class=\"code-rows\"><code>let args: Vec&lt;String&gt; = std::env::args().collect();</code></pre>\n<p>但 <code>collect</code> 并不是向量专用的，事实上，它可以构建出 Rust 标准库中任意类型的集合，只要迭代器能生成合适的条目类型即可：</p>\n<pre class=\"code-rows\"><code>use std::collections::;\n\nlet args: HashSet&lt;String&gt; = std::env::args().collect();\nlet args: BTreeSet&lt;String&gt; = std::env::args().collect();\nlet args: LinkedList&lt;String&gt; = std::env::args().collect();\n\n// 只有键–值对才能收集到Map中，因此对于这个例子，\n// 要把字符串序列和整数序列拉合在一起\nlet args: HashMap&lt;String, usize&gt; = std::env::args().zip(0..).collect();\nlet args: BTreeMap&lt;String, usize&gt; = std::env::args().zip(0..).collect();\n\n// 其他代码略</code></pre>\n<p>当然，<code>collect</code> 本身并不知道如何构造出所有这些类型。相反，如果某些集合类型（如 <code>Vec</code> 或 <code>HashMap</code>）知道如何从迭代器构造自身，就会自行实现 <code>std::iter::FromIterator</code>（来自迭代器）特型，而 <code>collect</code> 只是一个便捷的浅层包装而已：</p>\n<pre class=\"code-rows\"><code>trait FromIterator&lt;A&gt;: Sized {\n    fn from_iter&lt;T: IntoIterator&lt;Item=A&gt;&gt;(iter: T) -&gt; Self;\n}</code></pre>\n<p>如果一个集合类型实现了 <code>FromIterator&lt;A&gt;</code>，那么它的类型关联函数 <code>from_iter</code> 就能从一个可迭代者生成的 <code>A</code> 类型条目中构建出一个该类型的值。</p>\n<p>在最简单的情况下，实现代码可以构造出一个空集合，然后将迭代器中的条目一个个添加进去。例如，<code>std::collections::LinkedList</code> 的 <code>FromIterator</code> 就是这样实现的。</p>\n<p>不过，也有一些类型可以用更好的方式实现，比如，要从某个迭代器 <code>iter</code> 构造出一个向量可以非常简单。</p>\n<pre class=\"code-rows\"><code>let mut vec = Vec::new();\nfor item in iter {\n    vec.push(item)\n}\nvec</code></pre>\n<p>但这样做的效果并不理想：随着向量的增长，它可能要扩展其缓冲区，进而需要调用堆分配器并复制现有元素。向量固然进行了算法优化来保持这种开销尽可能低，但是如果有某种方法可以直接分配一个正确大小的缓冲区作为起点，那就根本没必要调整大小了。</p>\n<p>这是 <code>Iterator</code> 特型的 <code>size_hint</code> 方法的用武之地：</p>\n<pre class=\"code-rows\"><code>trait Iterator {\n    ...\n    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {\n        (0, None)\n    }\n}</code></pre>\n<p><code>size_hint</code> 方法会返回迭代器要生成的条目数的下限与可选上限，默认返回 0 作为下限而没有指定上限，这实际上就是在说“我也不知道上限”。许多迭代器可以做得更好，比如，<code>Range</code> 上的迭代器肯定知道它将生成多少个条目，<code>Vec</code> 或 <code>HashMap</code> 上的迭代器也知道。这类迭代器为 <code>size_hint</code> 提供了自己的专有定义。</p>\n<p><code>Vec</code> 的 <code>FromIterator</code> 实现如果想在一开始就正确设置新向量的缓冲区大小，那么这些上下限信息正是它所需要的。但在插入条目时仍然会检查缓冲区是否足够大，因此即使这种提示不正确，也只会影响性能，而不会影响安全。其他类型也可以采取类似的步骤，比如，<code>HashSet</code> 和 <code>HashMap</code> 就会使用 <code>Iterator::size_hint</code> 来为其哈希表选择合适的初始大小。</p>\n<p>关于类型推断的一点说明：在本节的一开始，你曾看到同样是调用 <code>std::env::args(). collect()</code>，却根据上下文生成了 4 种类型的集合，这可能有点儿奇怪。<code>collect</code> 的返回类型就是它的类型参数，所以前两个调用等价于以下代码：</p>\n<pre class=\"code-rows\"><code>let args = std::env::args().collect::&lt;Vec&lt;String&gt;&gt;();\nlet args = std::env::args().collect::&lt;HashSet&lt;String&gt;&gt;();</code></pre>\n<p>但如果只有一种类型可以作为 <code>collect</code> 的参数，Rust 的类型推断就会为你提供这种类型。当你明确写出 <code>args</code> 的类型时，也足以说明只有一种类型了。</p>\n<h3 id=\"nav_point_275\">15.4.14　<code>Extend</code> 特型</h3>\n<p>如果一个类型实现了 <code>std::iter::Extend</code>（扩展）特型，那么它的 <code>extend</code> 方法就能将一些可迭代的条目添加到集合中：</p>\n<pre class=\"code-rows\"><code>let mut v: Vec&lt;i32&gt; = (0..5).map(|i| 1 &lt;&lt; i).collect();\nv.extend([31, 57, 99, 163]);\nassert_eq!(v, [1, 2, 4, 8, 16, 31, 57, 99, 163]);</code></pre>\n<p>所有的标准集合都实现了 <code>Extend</code>，因此它们都有 <code>extend</code> 方法，<code>String</code> 也实现了，但具有固定长度的数组和切片则未实现。</p>\n<p><code>Extend</code> 特型的定义如下所示：</p>\n<pre class=\"code-rows\"><code>trait Extend&lt;A&gt; {\n    fn extend&lt;T&gt;(&amp;mut self, iter: T)\n        where T: IntoIterator&lt;Item=A&gt;;\n}</code></pre>\n<p>显然，这与 <code>std::iter::FromIterator</code> 非常相似：后者会创建新集合，而 <code>Extend</code> 会扩展现有集合。事实上，标准库中 <code>FromIterator</code> 的好几个实现都只是简单地创建一个新的空集合，然后调用 <code>extend</code> 填充它，比如 <code>std::collections::LinkedList</code> 的 <code>FromIterator</code> 就是这样实现的。</p>\n<pre class=\"code-rows\"><code>impl&lt;T&gt; FromIterator&lt;T&gt; for LinkedList&lt;T&gt; {\n    fn from_iter&lt;I: IntoIterator&lt;Item = T&gt;&gt;(iter: I) -&gt; Self {\n        let mut list = Self::new();\n        list.extend(iter);\n        list\n    }\n}</code></pre>\n<h3 id=\"nav_point_276\">15.4.15　<code>partition</code></h3>\n<p><code>partition</code>（分区）方法会将迭代器的条目划分到两个集合中，并使用闭包来决定每个条目归属的位置：</p>\n<pre class=\"code-rows\"><code>let things = [\"doorknob\", \"mushroom\", \"noodle\", \"giraffe\", \"grapefruit\"];\n\n// 惊人的事实：在这个列表里生物的名字都是以奇数序的字母开头的\nlet (living, nonliving): (Vec&lt;&amp;str&gt;, Vec&lt;&amp;str&gt;)\n    = things.iter().partition(|name| name.as_bytes()[0] &amp; 1 != 0);\n\nassert_eq!(living,    vec![\"mushroom\", \"giraffe\", \"grapefruit\"]);\nassert_eq!(nonliving, vec![\"doorknob\", \"noodle\"]);</code></pre>\n<p>与 <code>collect</code> 一样，<code>partition</code> 也可以创建你喜欢的任意种类的集合，但这些集合必须属于同一个类型。和 <code>collect</code> 一样，你需要指定返回类型：前面的示例明确写出了 <code>living</code> 和 <code>nonliving</code> 的类型，并让类型推断为调用 <code>partition</code> 选择正确的类型参数。</p>\n<p><code>partition</code> 的签名如下所示：</p>\n<pre class=\"code-rows\"><code>fn partition&lt;B, F&gt;(self, f: F) -&gt; (B, B)\n    where Self: Sized,\n          B: Default + Extend&lt;Self::Item&gt;,\n          F: FnMut(&amp;Self::Item) -&gt; bool;</code></pre>\n<p><code>collect</code> 要求其结果类型实现了 <code>FromIterator</code>，而 <code>partition</code> 则要求其结果类型实现了 <code>std::default::Default</code>，因为所有 Rust 集合都实现了 <code>std::default::Default</code>，而 <code>std::default::Extend</code> 则用于将元素添加到集合中。</p>\n<p>其他语言提供的 <code>partition</code> 操作往往只是将迭代器拆分为两个迭代器，而不会构建两个集合——这种处理方法之所以在 Rust 中并非好的选择，是因为那些已从底层迭代器中提取但尚未从已分区迭代器中提取的条目需要在某处进行缓冲，毕竟如果无论如何都要在内部构建某种集合，那还不如直接返回这些集合本身。</p>\n<h3 id=\"nav_point_277\">15.4.16　<code>for_each</code> 与 <code>try_for_each</code></h3>\n<p><code>for_each</code>（对每一个）方法会简单地对每个条目调用某个闭包：</p>\n<pre class=\"code-rows\"><code>[\"doves\", \"hens\", \"birds\"].iter()\n    .zip([\"turtle\", \"french\", \"calling\"])\n    .zip(2..5)\n    .rev()\n    .map(|((item, kind), quantity)| {\n        format!(\"{} {} {}\", quantity, kind, item)\n    })\n    .for_each(|gift| {\n        println!(\"You have received: {}\", gift);\n    });</code></pre>\n<p>输出如下所示：</p>\n<pre class=\"code-rows\"><code>You have received: 4 calling birds\nYou have received: 3 french hens\nYou have received: 2 turtle doves</code></pre>\n<p>这与简单的 <code>for</code> 循环非常相似，你同样可以在其中使用像 <code>break</code> 和 <code>continue</code> 这样的控制结构，但下面这样的适配器长链条调用在 <code>for</code> 循环中会显得有点儿笨拙：</p>\n<pre class=\"code-rows\"><code>for gift in [\"doves\", \"hens\", \"birds\"].iter()\n    .zip([\"turtle\", \"french\", \"calling\"])\n    .zip(2..5)\n    .rev()\n    .map(|((item, kind), quantity)| {\n        format!(\"{} {} {}\", quantity, kind, item)\n    })\n{\n    println!(\"You have received: {}\", gift);\n}</code></pre>\n<p>要绑定的模式 <code>gift</code> 最终可能离使用它的循环体很远。</p>\n<p>如果你的闭包需要容错或提前退出，可以使用 <code>try_for_each</code>（尝试对每一个）。</p>\n<pre class=\"code-rows\"><code>...\n    .try_for_each(|gift| {\n        writeln!(&amp;mut output_file, \"You have received: {}\", gift)\n    })?;</code></pre>\n<h2 id=\"nav_point_278\">15.5　实现自己的迭代器</h2>\n<p>你可以为自己的类型实现 <code>IntoIterator</code> 特型和 <code>Iterator</code> 特型，令本章中展示的所有适配器和消费者都可以使用它，甚至包括许多针对标准迭代器接口编写的库和 crate 代码。在本节中，我们将展示两个迭代器：一个简单的迭代器，可以遍历范围类型；一个相对复杂些的迭代器，可以遍历二叉树类型。</p>\n<p>假设我们有以下范围类型（从标准库的 <code>std::ops::Range&lt;T&gt;</code> 类型简化而来）。</p>\n<pre class=\"code-rows\"><code>struct I32Range {\n    start: i32,\n    end: i32\n}</code></pre>\n<p>要想迭代 <code>I32Range</code> 就需要两个状态：当前值和迭代应该结束的界限。这恰好非常适合 <code>I32Range</code> 类型本身，使用 <code>start</code> 作为下一个值，并使用 <code>end</code> 作为界限。因此，你可以像这样实现 <code>Iterator</code>：</p>\n<pre class=\"code-rows\"><code>impl Iterator for I32Range {\n    type Item = i32;\n    fn next(&amp;mut self) -&gt; Option&lt;i32&gt; {\n        if self.start &gt;= self.end {\n            return None;\n        }\n        let result = Some(self.start);\n        self.start += 1;\n        result\n    }\n}</code></pre>\n<p>此迭代器会生成 <code>i32</code> 型条目，也就是其 <code>Item</code> 类型。如果迭代已完成，则 <code>next</code> 会返回 <code>None</code>，否则，它会生成下一个值并更新其状态以便为下一次调用做准备。</p>\n<p>当然，<code>for</code> 循环会使用 <code>IntoIterator::into_iter</code> 将其操作数转换为迭代器。但是标准库为每个实现了 <code>Iterator</code> 的类型都提供了 <code>IntoIterator</code> 的通用实现，所以 <code>I32Range</code> 可以直接使用：</p>\n<pre class=\"code-rows\"><code>let mut pi = 0.0;\nlet mut numerator = 1.0;\n\nfor k in (I32Range { start: 0, end: 14 }) {\n    pi += numerator / (2*k + 1) as f64;\n    numerator /= -3.0;\n}\npi *= f64::sqrt(12.0);\n\n// IEEE 754精确定义了此结果\nassert_eq!(pi as f32, std::f32::consts::PI);</code></pre>\n<p>但 <code>I32Range</code> 是一个特例，因为其迭代目标和迭代器的类型是一样的。但还有许多情况没这么简单，比如，下面是第 10 章中的二叉树类型：</p>\n<pre class=\"code-rows\"><code>enum BinaryTree&lt;T&gt; {\n    Empty,\n    NonEmpty(Box&lt;TreeNode&lt;T&gt;&gt;)\n}\n\nstruct TreeNode&lt;T&gt; {\n    element: T,\n    left: BinaryTree&lt;T&gt;,\n    right: BinaryTree&lt;T&gt;\n}</code></pre>\n<p>遍历二叉树的经典方式是递归，使用函数调用栈来跟踪你当前在树中的位置以及尚未访问的节点。但是当为 <code>BinaryTree&lt;T&gt;</code> 实现 <code>Iterator</code> 时，对 <code>next</code> 的每次调用都必须生成一个值并返回。为了跟踪尚未生成的树节点，迭代器必须维护自己的栈。下面是 <code>BinaryTree</code> 的一种可能的迭代器类型：</p>\n<pre class=\"code-rows\"><code>use self::BinaryTree::*;\n\n// `BinaryTree`的有序遍历状态\nstruct TreeIter&lt;'a, T&gt; {\n    // 跟踪树节点引用的栈。由于我们使用了`Vec`的`push`方法\n    // 和`pop`方法，因此栈顶就是向量的末尾\n    //\n    // 迭代器接下来要访问的节点位于栈顶，栈顶之下的那些祖先\n    // 仍未访问。如果栈已空，则本迭代结束\n    unvisited: Vec&lt;&amp;'a TreeNode&lt;T&gt;&gt;\n}</code></pre>\n<p>创建了一个新的 <code>TreeIter</code> 时，它的初始状态应该是即将生成的树中最左侧的叶节点。根据 <code>unvisited</code> 栈的规则，它应该让那个叶节点位于栈顶，然后是栈顶节点未访问的祖先：位于树的左边缘的节点。我们可以通过从根到叶遍历树的左边缘并推入我们遇到的每个节点来初始化 <code>unvisited</code>（未访问的栈），因此我们将在 <code>TreeIter</code> 上定义一个方法来执行此操作：</p>\n<pre class=\"code-rows\"><code>impl&lt;'a, T: 'a&gt; TreeIter&lt;'a, T&gt; {\n    fn push_left_edge(&amp;mut self, mut tree: &amp;'a BinaryTree&lt;T&gt;) {\n        while let NonEmpty(ref node) = *tree {\n            self.unvisited.push(node);\n            tree = &amp;node.left;\n        }\n    }\n}</code></pre>\n<p>写成 <code>mut tree</code> 能让代码中的循环在沿着左边缘向下移动时更改 <code>tree</code> 指向的节点，但是由于 <code>tree</code> 是共享引用，它不能改变节点本身。</p>\n<p>有了这个辅助方法，就可以给 <code>BinaryTree</code> 提供一个 <code>iter</code> 方法，让它返回遍历树的迭代器了：</p>\n<pre class=\"code-rows\"><code>impl&lt;T&gt; BinaryTree&lt;T&gt; {\n    fn iter(&amp;self) -&gt; TreeIter&lt;T&gt; {\n        let mut iter = TreeIter { unvisited: Vec::new() };\n        iter.push_left_edge(self);\n        iter\n    }\n}</code></pre>\n<p><code>iter</code> 方法会构造一个带有空 <code>unvisited</code> 栈的 <code>TreeIter</code>，然后调用 <code>push_left_edge</code> 进行初始化。根据 <code>unvisited</code> 栈规则的要求，最左边的节点位于栈顶。</p>\n<p>遵循标准库的做法，也可以通过调用 <code>BinaryTree::iter</code> 在对树的共享引用上实现 <code>IntoIterator</code>：</p>\n<pre class=\"code-rows\"><code>impl&lt;'a, T: 'a&gt; IntoIterator for &amp;'a BinaryTree&lt;T&gt; {\n    type Item = &amp;'a T;\n    type IntoIter = TreeIter&lt;'a, T&gt;;\n    fn into_iter(self) -&gt; Self::IntoIter {\n        self.iter()\n    }\n}</code></pre>\n<p>这个 <code>IntoIter</code> 定义将 <code>TreeIter</code> 定义为针对 <code>&amp;BinaryTree</code> 的迭代器类型。</p>\n<p>最后，在 <code>Iterator</code> 实现中，我们开始实际遍历树。与 <code>BinaryTree</code> 的 <code>iter</code> 方法一样，迭代器的 <code>next</code> 方法也遵循栈规则：</p>\n<pre class=\"code-rows\"><code>impl&lt;'a, T&gt; Iterator for TreeIter&lt;'a, T&gt; {\n    type Item = &amp;'a T;\n    fn next(&amp;mut self) -&gt; Option&lt;&amp;'a T&gt; {\n        // 找到此迭代必须生成的节点，或完成迭代（如果为`None`，\n        // 请使用`?`运算符立即返回）\n        let node = self.unvisited.pop()?;\n\n        // 在`node`之后，我们接下来生成的条目必须是`node`右子树中最左边\n        // 的子节点，所以要从这里向下推进。这个辅助方法恰好是我们想要的\n        self.push_left_edge(&amp;node.right);\n\n        // 生成一个对本节点值的引用\n        Some(&amp;node.element)\n    }\n}</code></pre>\n<p>如果栈为空，则迭代完成。否则，<code>node</code> 就是对当前要访问的节点的引用，此调用将返回一个指向其 <code>element</code> 字段的引用。但首先，我们必须将迭代器的状态推进到下一个节点。如果这个节点具有右子树，则下一个要访问的节点是该子树最左侧的节点，我们可以使用 <code>push_left_edge</code> 将它及其未访问的祖先压入栈。但是如果这个节点没有右子树，则 <code>push_left_edge</code> 没有任何效果，这正是我们想要的：我们希望新的栈顶是 <code>node</code> 的第一个未访问的祖先（如果有的话）。</p>\n<p>有了 <code>IntoIterator</code> 和 <code>Iterator</code> 这两个实现，我们终于可以使用 <code>for</code> 循环来通过引用迭代 <code>BinaryTree</code> 了。使用 10.2.9 节中 <code>BinaryTree</code> 的 <code>add</code> 方法：</p>\n<pre class=\"code-rows\"><code>// 构建一棵小树\nlet mut tree = BinaryTree::Empty;\ntree.add(\"jaeger\");\ntree.add(\"robot\");\ntree.add(\"droid\");\ntree.add(\"mecha\");\n\n// 对它进行遍历\nlet mut v = Vec::new();\nfor kind in &amp;tree {\n    v.push(*kind);\n}\nassert_eq!(v, [\"droid\", \"jaeger\", \"mecha\", \"robot\"]);</code></pre>\n<p>图 15-1 展示了当我们遍历示例树时 <code>unvisited</code> 栈的行为方式。对于每一步，下一个要访问的节点都会位于栈顶，所有未访问的祖先则位于其下方。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00863.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 15-1：迭代遍历二叉树</strong></p>\n<p>所有常用的迭代器适配器和消费者都能用在我们这棵树上：</p>\n<pre class=\"code-rows\"><code>assert_eq!(tree.iter()\n           .map(|name| format!(\"mega-{}\", name))\n           .collect::&lt;Vec&lt;_&gt;&gt;(),\n           vec![\"mega-droid\", \"mega-jaeger\",\n                \"mega-mecha\", \"mega-robot\"]);</code></pre>\n<p>各种迭代器正是 Rust 哲学的体现，即提供强大的、零成本的抽象，提升代码的表现力和可读性。迭代器并没有完全取代循环，但确实提供了一个功能强大的基础构件，天然支持惰性求值特性且具有出色的性能。</p>\n\n<br style=\"page-break-after:always\" />","comments":[]}