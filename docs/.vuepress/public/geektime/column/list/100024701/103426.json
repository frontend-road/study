{"id":103426,"title":"39 | 管道：项目组A完成了，如何交接给项目组B？","content":"<p>在这一章的第一节里，我们大致讲了管道的使用方式以及相应的命令行。这一节，我们就具体来看一下管道是如何实现的。</p><p>我们先来看，我们常用的<strong>匿名管道</strong>（Anonymous Pipes），也即将多个命令串起来的竖线，背后的原理到底是什么。</p><p>上次我们说，它是基于管道的，那管道如何创建呢？管道的创建，需要通过下面这个系统调用。</p><pre><code>int pipe(int fd[2])\n</code></pre><p>在这里，我们创建了一个管道pipe，返回了两个文件描述符，这表示管道的两端，一个是管道的读取端描述符fd[0]，另一个是管道的写入端描述符fd[1]。</p><p><img src=\"https://static001.geekbang.org/resource/image/8f/a7/8fa3144bf3a34ddf789884a75fa2d4a7.png?wh=823*817\" alt=\"\"></p><p>我们来看在内核里面是如何实现的。</p><pre><code>SYSCALL_DEFINE1(pipe, int __user *, fildes)\n{\n\treturn sys_pipe2(fildes, 0);\n}\n\nSYSCALL_DEFINE2(pipe2, int __user *, fildes, int, flags)\n{\n\tstruct file *files[2];\n\tint fd[2];\n\tint error;\n\n\terror = __do_pipe_flags(fd, files, flags);\n\tif (!error) {\n\t\tif (unlikely(copy_to_user(fildes, fd, sizeof(fd)))) {\n......\n\t\t\terror = -EFAULT;\n\t\t} else {\n\t\t\tfd_install(fd[0], files[0]);\n\t\t\tfd_install(fd[1], files[1]);\n\t\t}\n\t}\n\treturn error;\n}\n</code></pre><p>在内核中，主要的逻辑在pipe2系统调用中。这里面要创建一个数组files，用来存放管道的两端的打开文件，另一个数组fd存放管道的两端的文件描述符。如果调用__do_pipe_flags没有错误，那就调用fd_install，将两个fd和两个struct file关联起来。这一点和打开一个文件的过程很像了。</p><p>我们来看__do_pipe_flags。这里面调用了create_pipe_files，然后生成了两个fd。从这里可以看出，fd[0]是用于读的，fd[1]是用于写的。</p><!-- [[[read_end]]] --><pre><code>static int __do_pipe_flags(int *fd, struct file **files, int flags)\n{\n\tint error;\n\tint fdw, fdr;\n......\n\terror = create_pipe_files(files, flags);\n......\n\terror = get_unused_fd_flags(flags);\n......\n\tfdr = error;\n\n\terror = get_unused_fd_flags(flags);\n......\n\tfdw = error;\n\n\tfd[0] = fdr;\n\tfd[1] = fdw;\n\treturn 0;\n......\n}\n</code></pre><p>创建一个管道，大部分的逻辑其实都是在create_pipe_files函数里面实现的。这一章第一节的时候，我们说过，命名管道是创建在文件系统上的。从这里我们可以看出，匿名管道，也是创建在文件系统上的，只不过是一种特殊的文件系统，创建一个特殊的文件，对应一个特殊的inode，就是这里面的get_pipe_inode。</p><pre><code>int create_pipe_files(struct file **res, int flags)\n{\n\tint err;\n\tstruct inode *inode = get_pipe_inode();\n\tstruct file *f;\n\tstruct path path;\n......\n\tpath.dentry = d_alloc_pseudo(pipe_mnt-&gt;mnt_sb, &amp;empty_name);\n......\n\tpath.mnt = mntget(pipe_mnt);\n\n\td_instantiate(path.dentry, inode);\n\n\tf = alloc_file(&amp;path, FMODE_WRITE, &amp;pipefifo_fops);\n......\n\tf-&gt;f_flags = O_WRONLY | (flags &amp; (O_NONBLOCK | O_DIRECT));\n\tf-&gt;private_data = inode-&gt;i_pipe;\n\n\tres[0] = alloc_file(&amp;path, FMODE_READ, &amp;pipefifo_fops);\n......\n\tpath_get(&amp;path);\n\tres[0]-&gt;private_data = inode-&gt;i_pipe;\n\tres[0]-&gt;f_flags = O_RDONLY | (flags &amp; O_NONBLOCK);\n\tres[1] = f;\n\treturn 0;\n......\n}\n</code></pre><p>从get_pipe_inode的实现，我们可以看出，匿名管道来自一个特殊的文件系统pipefs。这个文件系统被挂载后，我们就得到了struct vfsmount *pipe_mnt。然后挂载的文件系统的superblock就变成了：pipe_mnt-&gt;mnt_sb。如果你对文件系统的操作还不熟悉，要返回去复习一下文件系统那一章啊。</p><pre><code>static struct file_system_type pipe_fs_type = {\n\t.name\t\t= &quot;pipefs&quot;,\n\t.mount\t\t= pipefs_mount,\n\t.kill_sb\t= kill_anon_super,\n};\n\nstatic int __init init_pipe_fs(void)\n{\n\tint err = register_filesystem(&amp;pipe_fs_type);\n\n\tif (!err) {\n\t\tpipe_mnt = kern_mount(&amp;pipe_fs_type);\n\t}\n......\n}\n\nstatic struct inode * get_pipe_inode(void)\n{\n\tstruct inode *inode = new_inode_pseudo(pipe_mnt-&gt;mnt_sb);\n\tstruct pipe_inode_info *pipe;\n......\n\tinode-&gt;i_ino = get_next_ino();\n\n\tpipe = alloc_pipe_info();\n......\n\tinode-&gt;i_pipe = pipe;\n\tpipe-&gt;files = 2;\n\tpipe-&gt;readers = pipe-&gt;writers = 1;\n\tinode-&gt;i_fop = &amp;pipefifo_fops;\n\tinode-&gt;i_state = I_DIRTY;\n\tinode-&gt;i_mode = S_IFIFO | S_IRUSR | S_IWUSR;\n\tinode-&gt;i_uid = current_fsuid();\n\tinode-&gt;i_gid = current_fsgid();\n\tinode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = current_time(inode);\n\n\treturn inode;\n......\n}\n</code></pre><p>我们从new_inode_pseudo函数创建一个inode。这里面开始填写Inode的成员，这里和文件系统的很像。这里值得注意的是struct pipe_inode_info，这个结构里面有个成员是struct pipe_buffer *bufs。我们可以知道，<strong>所谓的匿名管道，其实就是内核里面的一串缓存</strong>。</p><p>另外一个需要注意的是pipefifo_fops，将来我们对于文件描述符的操作，在内核里面都是对应这里面的操作。</p><pre><code>const struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read_iter\t= pipe_read,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};\n</code></pre><p>我们回到create_pipe_files函数，创建完了inode，还需创建一个dentry和他对应。dentry和inode对应好了，我们就要开始创建struct file对象了。先创建用于写入的，对应的操作为pipefifo_fops；再创建读取的，对应的操作也为pipefifo_fops。然后把private_data设置为pipe_inode_info。这样从struct file这个层级上，就能直接操作底层的读写操作。</p><p>至此，一个匿名管道就创建成功了。如果对于fd[1]写入，调用的是pipe_write，向pipe_buffer里面写入数据；如果对于fd[0]的读入，调用的是pipe_read，也就是从pipe_buffer里面读取数据。</p><p>但是这个时候，两个文件描述符都是在一个进程里面的，并没有起到进程间通信的作用，怎么样才能使得管道是跨两个进程的呢？还记得创建进程调用的fork吗？在这里面，创建的子进程会复制父进程的struct files_struct，在这里面fd的数组会复制一份，但是fd指向的struct file对于同一个文件还是只有一份，这样就做到了，两个进程各有两个fd指向同一个struct file的模式，两个进程就可以通过各自的fd写入和读取同一个管道文件实现跨进程通信了。</p><p><img src=\"https://static001.geekbang.org/resource/image/9c/a3/9c0e38e31c7a51da12faf4a1aca10ba3.png?wh=1162*1363\" alt=\"\"></p><p>由于管道只能一端写入，另一端读出，所以上面的这种模式会造成混乱，因为父进程和子进程都可以写入，也都可以读出，通常的方法是父进程关闭读取的fd，只保留写入的fd，而子进程关闭写入的fd，只保留读取的fd，如果需要双向通行，则应该创建两个管道。</p><p>一个典型的使用管道在父子进程之间的通信代码如下：</p><pre><code>#include &lt;unistd.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;string.h&gt;\n\nint main(int argc, char *argv[])\n{\n  int fds[2];\n  if (pipe(fds) == -1)\n    perror(&quot;pipe error&quot;);\n\n  pid_t pid;\n  pid = fork();\n  if (pid == -1)\n    perror(&quot;fork error&quot;);\n\n  if (pid == 0){\n    close(fds[0]);\n    char msg[] = &quot;hello world&quot;;\n    write(fds[1], msg, strlen(msg) + 1);\n    close(fds[1]);\n    exit(0);\n  } else {\n    close(fds[1]);\n    char msg[128];\n    read(fds[0], msg, 128);\n    close(fds[0]);\n    printf(&quot;message : %s\\n&quot;, msg);\n    return 0;\n  }\n}\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/71/b6/71eb7b4d026d04e4093daad7e24feab6.png?wh=1162*1363\" alt=\"\"></p><p>到这里，我们仅仅解析了使用管道进行父子进程之间的通信，但是我们在shell里面的不是这样的。在shell里面运行A|B的时候，A进程和B进程都是shell创建出来的子进程，A和B之间不存在父子关系。</p><p>不过，有了上面父子进程之间的管道这个基础，实现A和B之间的管道就方便多了。</p><p>我们首先从shell创建子进程A，然后在shell和A之间建立一个管道，其中shell保留读取端，A进程保留写入端，然后shell再创建子进程B。这又是一次fork，所以，shell里面保留的读取端的fd也被复制到了子进程B里面。这个时候，相当于shell和B都保留读取端，只要shell主动关闭读取端，就变成了一管道，写入端在A进程，读取端在B进程。</p><p><img src=\"https://static001.geekbang.org/resource/image/81/fa/81be4d460aaa804e9176ec70d59fdefa.png?wh=2494*4663\" alt=\"\"></p><p>接下来我们要做的事情就是，将这个管道的两端和输入输出关联起来。这就要用到dup2系统调用了。</p><pre><code>int dup2(int oldfd, int newfd);\n</code></pre><p>这个系统调用，将老的文件描述符赋值给新的文件描述符，让newfd的值和oldfd一样。</p><p>我们还是回忆一下，在files_struct里面，有这样一个表，下标是fd，内容指向一个打开的文件struct file。</p><pre><code>struct files_struct {\n  struct file __rcu * fd_array[NR_OPEN_DEFAULT];\n}\n</code></pre><p>在这个表里面，前三项是定下来的，其中第零项STDIN_FILENO表示标准输入，第一项STDOUT_FILENO表示标准输出，第三项STDERR_FILENO表示错误输出。</p><p>在A进程中，写入端可以做这样的操作：dup2(fd[1],STDOUT_FILENO)，将STDOUT_FILENO（也即第一项）不再指向标准输出，而是指向创建的管道文件，那么以后往标准输出写入的任何东西，都会写入管道文件。</p><p>在B进程中，读取端可以做这样的操作，dup2(fd[0],STDIN_FILENO)，将STDIN_FILENO也即第零项不再指向标准输入，而是指向创建的管道文件，那么以后从标准输入读取的任何东西，都来自于管道文件。</p><p>至此，我们才将A|B的功能完成。</p><p><img src=\"https://static001.geekbang.org/resource/image/c0/e2/c042b12de704995e4ba04173e0a304e2.png?wh=2149*1363\" alt=\"\"></p><p>为了模拟A|B的情况，我们可以将前面的那一段代码，进一步修改成下面这样：</p><pre><code>#include &lt;unistd.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;string.h&gt;\n\nint main(int argc, char *argv[])\n{\n  int fds[2];\n  if (pipe(fds) == -1)\n    perror(&quot;pipe error&quot;);\n\n  pid_t pid;\n  pid = fork();\n  if (pid == -1)\n    perror(&quot;fork error&quot;);\n\n  if (pid == 0){\n    dup2(fds[1], STDOUT_FILENO);\n    close(fds[1]);\n    close(fds[0]);\n    execlp(&quot;ps&quot;, &quot;ps&quot;, &quot;-ef&quot;, NULL);\n  } else {\n    dup2(fds[0], STDIN_FILENO);\n    close(fds[0]);\n    close(fds[1]);\n    execlp(&quot;grep&quot;, &quot;grep&quot;, &quot;systemd&quot;, NULL);\n  }\n  \n  return 0;\n}\n</code></pre><p>接下来，我们来看命名管道。我们在讲命令的时候讲过，命名管道需要事先通过命令mkfifo，进行创建。如果是通过代码创建命名管道，也有一个函数，但是这不是一个系统调用，而是Glibc提供的函数。它的定义如下：</p><pre><code>int\nmkfifo (const char *path, mode_t mode)\n{\n  dev_t dev = 0;\n  return __xmknod (_MKNOD_VER, path, mode | S_IFIFO, &amp;dev);\n}\n\nint\n__xmknod (int vers, const char *path, mode_t mode, dev_t *dev)\n{\n  unsigned long long int k_dev;\n......\n  /* We must convert the value to dev_t type used by the kernel.  */\n  k_dev = (*dev) &amp; ((1ULL &lt;&lt; 32) - 1);\n......\n  return INLINE_SYSCALL (mknodat, 4, AT_FDCWD, path, mode,\n                         (unsigned int) k_dev);\n}\n</code></pre><p>Glibc的mkfifo函数会调用mknodat系统调用，还记得咱们学字符设备的时候，创建一个字符设备的时候，也是调用的mknod。这里命名管道也是一个设备，因而我们也用mknod。</p><pre><code>SYSCALL_DEFINE4(mknodat, int, dfd, const char __user *, filename, umode_t, mode, unsigned, dev)\n{\n\tstruct dentry *dentry;\n\tstruct path path;\n\tunsigned int lookup_flags = 0;\n......\nretry:\n\tdentry = user_path_create(dfd, filename, &amp;path, lookup_flags);\n......\n\tswitch (mode &amp; S_IFMT) {\n......\n\t\tcase S_IFIFO: case S_IFSOCK:\n\t\t\terror = vfs_mknod(path.dentry-&gt;d_inode,dentry,mode,0);\n\t\t\tbreak;\n\t}\n......\n}\n</code></pre><p>对于mknod的解析，我们在字符设备那一节已经解析过了，先是通过user_path_create对于这个管道文件创建一个dentry，然后因为是S_IFIFO，所以调用vfs_mknod。由于这个管道文件是创建在一个普通文件系统上的，假设是在ext4文件上，于是vfs_mknod会调用ext4_dir_inode_operations的mknod，也即会调用ext4_mknod。</p><pre><code>const struct inode_operations ext4_dir_inode_operations = {\n......\n\t.mknod\t\t= ext4_mknod,\n......\n};\n\nstatic int ext4_mknod(struct inode *dir, struct dentry *dentry,\n\t\t      umode_t mode, dev_t rdev)\n{\n\thandle_t *handle;\n\tstruct inode *inode;\n......\n\tinode = ext4_new_inode_start_handle(dir, mode, &amp;dentry-&gt;d_name, 0,\n\t\t\t\t\t    NULL, EXT4_HT_DIR, credits);\n\thandle = ext4_journal_current_handle();\n\tif (!IS_ERR(inode)) {\n\t\tinit_special_inode(inode, inode-&gt;i_mode, rdev);\n\t\tinode-&gt;i_op = &amp;ext4_special_inode_operations;\n\t\terr = ext4_add_nondir(handle, dentry, inode);\n\t\tif (!err &amp;&amp; IS_DIRSYNC(dir))\n\t\t\text4_handle_sync(handle);\n\t}\n\tif (handle)\n\t\text4_journal_stop(handle);\n......\n}\n\n#define ext4_new_inode_start_handle(dir, mode, qstr, goal, owner, \\\n\t\t\t\t    type, nblocks)\t\t    \\\n\t__ext4_new_inode(NULL, (dir), (mode), (qstr), (goal), (owner), \\\n\t\t\t 0, (type), __LINE__, (nblocks))\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode-&gt;i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode-&gt;i_fop = &amp;def_chr_fops;\n\t\tinode-&gt;i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode-&gt;i_fop = &amp;def_blk_fops;\n\t\tinode-&gt;i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode-&gt;i_fop = &amp;pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n......\n}\n</code></pre><p>在ext4_mknod中，ext4_new_inode_start_handle会调用__ext4_new_inode，在ext4文件系统上真的创建一个文件，但是会调用init_special_inode，创建一个内存中特殊的inode，这个函数我们在字符设备文件中也遇到过，只不过当时inode的i_fop指向的是def_chr_fops，这次换成管道文件了，inode的i_fop变成指向pipefifo_fops，这一点和匿名管道是一样的。</p><p>这样，管道文件就创建完毕了。</p><p>接下来，要打开这个管道文件，我们还是会调用文件系统的open函数。还是沿着文件系统的调用方式，一路调用到pipefifo_fops的open函数，也就是fifo_open。</p><pre><code>static int fifo_open(struct inode *inode, struct file *filp)\n{\n\tstruct pipe_inode_info *pipe;\n\tbool is_pipe = inode-&gt;i_sb-&gt;s_magic == PIPEFS_MAGIC;\n\tint ret;\n\tfilp-&gt;f_version = 0;\n\n\tif (inode-&gt;i_pipe) {\n\t\tpipe = inode-&gt;i_pipe;\n\t\tpipe-&gt;files++;\n\t} else {\n\t\tpipe = alloc_pipe_info();\n\t\tpipe-&gt;files = 1;\n\t\tinode-&gt;i_pipe = pipe;\n\t\tspin_unlock(&amp;inode-&gt;i_lock);\n\t}\n\tfilp-&gt;private_data = pipe;\n\tfilp-&gt;f_mode &amp;= (FMODE_READ | FMODE_WRITE);\n\n\tswitch (filp-&gt;f_mode) {\n\tcase FMODE_READ:\n\t\tpipe-&gt;r_counter++;\n\t\tif (pipe-&gt;readers++ == 0)\n\t\t\twake_up_partner(pipe);\n\t\tif (!is_pipe &amp;&amp; !pipe-&gt;writers) {\n\t\t\tif ((filp-&gt;f_flags &amp; O_NONBLOCK)) {\n\t\t\tfilp-&gt;f_version = pipe-&gt;w_counter;\n\t\t\t} else {\n\t\t\t\tif (wait_for_partner(pipe, &amp;pipe-&gt;w_counter))\n\t\t\t\t\tgoto err_rd;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase FMODE_WRITE:\n\t\tpipe-&gt;w_counter++;\n\t\tif (!pipe-&gt;writers++)\n\t\t\twake_up_partner(pipe);\n\t\tif (!is_pipe &amp;&amp; !pipe-&gt;readers) {\n\t\t\tif (wait_for_partner(pipe, &amp;pipe-&gt;r_counter))\n\t\t\t\tgoto err_wr;\n\t\t}\n\t\tbreak;\n\tcase FMODE_READ | FMODE_WRITE:\n\t\tpipe-&gt;readers++;\n\t\tpipe-&gt;writers++;\n\t\tpipe-&gt;r_counter++;\n\t\tpipe-&gt;w_counter++;\n\t\tif (pipe-&gt;readers == 1 || pipe-&gt;writers == 1)\n\t\t\twake_up_partner(pipe);\n\t\tbreak;\n......\n\t}\n......\n}\n</code></pre><p>在fifo_open里面，创建pipe_inode_info，这一点和匿名管道也是一样的。这个结构里面有个成员是struct pipe_buffer *bufs。我们可以知道，<strong>所谓的命名管道，其实是也是内核里面的一串缓存。</strong></p><p>接下来，对于命名管道的写入，我们还是会调用pipefifo_fops的pipe_write函数，向pipe_buffer里面写入数据。对于命名管道的读入，我们还是会调用pipefifo_fops的pipe_read，也就是从pipe_buffer里面读取数据。</p><h2>总结时刻</h2><p>无论是匿名管道，还是命名管道，在内核都是一个文件。只要是文件就要有一个inode。这里我们又用到了特殊inode、字符设备、块设备，其实都是这种特殊的inode。</p><p>在这种特殊的inode里面，file_operations指向管道特殊的pipefifo_fops，这个inode对应内存里面的缓存。</p><p>当我们用文件的open函数打开这个管道设备文件的时候，会调用pipefifo_fops里面的方法创建struct file结构，他的inode指向特殊的inode，也对应内存里面的缓存，file_operations也指向管道特殊的pipefifo_fops。</p><p>写入一个pipe就是从struct file结构找到缓存写入，读取一个pipe就是从struct file结构找到缓存读出。</p><p><img src=\"https://static001.geekbang.org/resource/image/48/97/486e2bc73abbe91d7083bb1f4f678097.png?wh=2749*2383\" alt=\"\"></p><h2>课堂练习</h2><p>上面创建匿名管道的程序，你一定要运行一下，然后试着通过strace查看自己写的程序的系统调用，以及直接在命令行使用匿名管道的系统调用，做一个比较。</p><p>欢迎留言和我分享你的疑惑和见解 ，也欢迎可以收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习和进步。</p><p><img src=\"https://static001.geekbang.org/resource/image/8c/37/8c0a95fa07a8b9a1abfd394479bdd637.jpg?wh=1110*659\" alt=\"\"></p>","comments":[{"had_liked":false,"id":107739,"user_name":"Sharry","can_delete":false,"product_type":"c1","uid":1239293,"ip_address":"","ucode":"045DDB864659F6","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/fd/035f4c94.jpg","comment_is_top":false,"comment_ctime":1561602115,"is_pvip":false,"replies":[{"id":"48848","content":"不会到磁盘上，假的inode","user_name":"作者回复","comment_id":107739,"uid":"1001590","ip_address":"","utype":1,"ctime":1567501047,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"27331405891","product_id":100024701,"comment_content":"- 匿名管道: 只能在管道创建进程及其后代之间通信<br>  - 通过 pipe 系统调用创建<br>  - **inode 由特殊的文件系统 pipefs 创建**<br>  - **inode 关联的 fos 为 pipefifo_fops**<br>- 命名管道: 通过管道文件名, 可以在任意进程之间通信<br>  - 通过 mkfifo Glibc 库函数创建<br>    - 内部调用 mknodat 系统调用<br>  - **inode 由普通文件系统创建, 真实存在于磁盘中**<br>  - **inode 关联的 fos 与匿名管道一致, 为 pipefifo_fops**<br><br>老师, 在阅读的过程中产生了一个疑问, 匿名管道创建 inode 使用到的文件系统 pipefs, 也是属于内存文件系统吗? 这个 inode 是否会写到磁盘上呢?","like_count":6,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455647,"discussion_content":"不会到磁盘上，假的inode","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567501047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118649,"user_name":"海军上校","can_delete":false,"product_type":"c1","uid":1104290,"ip_address":"","ucode":"7B0D9EC01A3F36","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/a2/afbc447c.jpg","comment_is_top":false,"comment_ctime":1564406070,"is_pvip":false,"replies":[{"id":"46394","content":"不是的，留着fd1","user_name":"作者回复","comment_id":118649,"uid":"1001590","ip_address":"","utype":1,"ctime":1566298307,"user_name_real":"刘超@网易云"}],"discussion_count":3,"race_medal":0,"score":"14449307958","product_id":100024701,"comment_content":"管道代码是不是写错啦？pid=0应该是子进程 close fd1吧 我理解的","like_count":3,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460507,"discussion_content":"不是的，留着fd1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566298307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1475340,"avatar":"https://static001.geekbang.org/account/avatar/00/16/83/0c/b9e39db4.jpg","nickname":"韩俊臣","note":"","ucode":"D6A15C025570D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282404,"discussion_content":"显然是写错了，pid==0是子进程，那应该是关闭fd[1](写)，父进程关闭fd[0](读)","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591965373,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1609871,"avatar":"https://static001.geekbang.org/account/avatar/00/18/90/8f/9c691a5f.jpg","nickname":"奔跑的码仔","note":"","ucode":"AB3B02B07B8B8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":22054,"discussion_content":"应该是写错了吧，要不和下面的图不一致了。图中，子进程关闭了fd[1]，父进程关闭了fd[0]","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569570845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225723,"user_name":"八台上","can_delete":false,"product_type":"c1","uid":1391143,"ip_address":"","ucode":"FB3D74B522C720","user_header":"https://static001.geekbang.org/account/avatar/00/15/3a/27/5d218272.jpg","comment_is_top":false,"comment_ctime":1591840605,"is_pvip":false,"replies":[{"id":"83468","content":"管道重启就没了","user_name":"作者回复","comment_id":225723,"uid":"1001590","ip_address":"","utype":1,"ctime":1592186192,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"10181775197","product_id":100024701,"comment_content":"请问 管道是特殊的inode  这个inode也会占用磁盘吗   不然机器重启的时候不就没了吗？","like_count":2,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497964,"discussion_content":"管道重启就没了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592186192,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164431,"user_name":"shangyu","can_delete":false,"product_type":"c1","uid":1011389,"ip_address":"","ucode":"13A26E53508D75","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6e/bd/b83ad32d.jpg","comment_is_top":false,"comment_ctime":1576988645,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"10166923237","product_id":100024701,"comment_content":"请问下老师pipe的缓存大小是多少呢 如果进程a的输出太大会有什么影响呢","like_count":2,"discussions":[{"author":{"id":1204168,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5f/c8/13aa8aa9.jpg","nickname":"night","note":"","ucode":"03B3C955092C03","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408485,"discussion_content":"不同 POSIX 的实现，pipe buffer 的大小是不同的\nhttps://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635254933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":293911,"user_name":"静✨","can_delete":false,"product_type":"c1","uid":1658413,"ip_address":"","ucode":"1B33229C206339","user_header":"https://static001.geekbang.org/account/avatar/00/19/4e/2d/06d3f9f5.jpg","comment_is_top":false,"comment_ctime":1621601368,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5916568664","product_id":100024701,"comment_content":"看了三遍 居然看懂了。<br>这个创建管道的实现真是牛皮","like_count":1},{"had_liked":false,"id":268778,"user_name":"xavier","can_delete":false,"product_type":"c1","uid":1946744,"ip_address":"","ucode":"E3C38864D3C8E4","user_header":"https://static001.geekbang.org/account/avatar/00/1d/b4/78/47011c75.jpg","comment_is_top":false,"comment_ctime":1608346519,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5903313815","product_id":100024701,"comment_content":"好奇想问，在举例中的那个shell创建A和B进程的时候，在fork生成 B进程的时候，是保留了B进程的管道输出的部分，而将shell父进程的管道输出关闭掉了，那如果shell紧接着再去fork一个C进程，岂不是管道的输入和输出都没有了？","like_count":2,"discussions":[{"author":{"id":1053178,"avatar":"https://static001.geekbang.org/account/avatar/00/10/11/fa/e0dcc1bf.jpg","nickname":"榕","note":"","ucode":"4611A40E21ECEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590429,"discussion_content":"我的理解，对于超过3个命令，如A | B | C ，应该是shell fork A，A fork B， B fork C，A和B、B和C之间各构建一个管道。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665734652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1716827,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/32/5b/d0c7e813.jpg","nickname":"luo","note":"","ucode":"1A1DA8EB916ECF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531754,"discussion_content":"我的理解也是需要再开一个管道，假设还有子进程C，那么shell进程会创建另外一个管道用于子进程B和子进程C之间的通信","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637406799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2401422,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/NyFOEueITjaGLpakMEuWAqVQjo1uDIXlpDdpCxXGfaWiaXzibLQ3WgOFCe8D9FvCmyjsGT7jDsLUbkt8jt2aVs9g/132","nickname":"geek","note":"","ucode":"FF0845140D72A9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369317,"discussion_content":"n个点连城一条直线，需要n-1条边。多个进程需要多个管道吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619003554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137399,"user_name":"奔跑的码仔","can_delete":false,"product_type":"c1","uid":1609871,"ip_address":"","ucode":"AB3B02B07B8B8C","user_header":"https://static001.geekbang.org/account/avatar/00/18/90/8f/9c691a5f.jpg","comment_is_top":false,"comment_ctime":1569729896,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5864697192","product_id":100024701,"comment_content":"strace -f -o file .&#47;npipe 可以看到咱们父、子进程的整个执行过程。<br>strace -f -o file1 ps -ef | grep systemd只可以看到ps -ef命令的execv，看不到grep命令的。","like_count":1},{"had_liked":false,"id":107339,"user_name":"石维康","can_delete":false,"product_type":"c1","uid":1067564,"ip_address":"","ucode":"E39ED8416B2C01","user_header":"https://static001.geekbang.org/account/avatar/00/10/4a/2c/f8451d77.jpg","comment_is_top":false,"comment_ctime":1561516308,"is_pvip":false,"replies":[{"id":"48855","content":"参数不是struct inode *inode","user_name":"作者回复","comment_id":107339,"uid":"1001590","ip_address":"","utype":1,"ctime":1567501309,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"5856483604","product_id":100024701,"comment_content":"在ext4_mknod函数里调用init_special_inode时传入的是上一步ext4_new_inode_start_handle返回的inode。为什么文中还会说&quot;但是会调用 init_special_inode，创建一个内存中特殊的 inode&quot;?<br>在init_special_inode中也没有看到创建虚拟inode的地方？","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455477,"discussion_content":"参数不是struct inode *inode","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567501309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347441,"user_name":"小鳄鱼","can_delete":false,"product_type":"c1","uid":1178888,"ip_address":"","ucode":"9C30CAFB41A263","user_header":"https://static001.geekbang.org/account/avatar/00/11/fd/08/c039f840.jpg","comment_is_top":false,"comment_ctime":1654044856,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654044856","product_id":100024701,"comment_content":"二刷：匿名管道通过pipefs，而命名管道被当成设备需要通过ext4在磁盘上创建文件。显然，后者不会因为重启而消失，管道依然存在。但管道中的内容会丢失，因为实际上是内核的缓存。而前者重启后，管道都找不着了。是这样吗？","like_count":0},{"had_liked":false,"id":327084,"user_name":"linker","can_delete":false,"product_type":"c1","uid":1803259,"ip_address":"","ucode":"6C5799F2FC2C82","user_header":"https://static001.geekbang.org/account/avatar/00/1b/83/fb/621adceb.jpg","comment_is_top":false,"comment_ctime":1639907847,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639907847","product_id":100024701,"comment_content":"bash创建的匿名管道居然没有用dup2函数","like_count":0},{"had_liked":false,"id":259903,"user_name":"John117","can_delete":false,"product_type":"c1","uid":1943290,"ip_address":"","ucode":"79F14507D85DA5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epTjkcZR0E7apmNbbLeAnlDePhUT6qJAwK6iasibLCckQTlEW9x5MEMa3HKrekZfTdkaJIpKFDHSFfA/132","comment_is_top":false,"comment_ctime":1604885053,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1604885053","product_id":100024701,"comment_content":"老师，对于有名管道来说，现在a和b两个进程需要通信。如果我在进程a中创建了一个管道，现在有个进程b，有什么优雅的方法将管道的path告诉进程b？","like_count":0,"discussions":[{"author":{"id":2656701,"avatar":"","nickname":"Geek_6ac1ff","note":"","ucode":"BE1FE373283316","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381395,"discussion_content":"只能提前在程序外面用命令创建吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625039918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":228498,"user_name":"蹦哒","can_delete":false,"product_type":"c1","uid":1458931,"ip_address":"","ucode":"56591A657DE7C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epcs6PibsP9vEXv4EibUw3bhQPUK04zRTOvfrvF08TwM67xPb1LBh2uRENHQwo2VqYfC5GhJmM7icxHA/132","comment_is_top":false,"comment_ctime":1592713021,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1592713021","product_id":100024701,"comment_content":"请问老师：<br>fd只是一个int，如果一个进程不停循环的用各个整数来尝试读取写入，恰巧有一个fd另外一个进程打开准备读取或者写入。这样岂不有可能破坏了进程的隔离性？","like_count":0,"discussions":[{"author":{"id":2656701,"avatar":"","nickname":"Geek_6ac1ff","note":"","ucode":"BE1FE373283316","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381398,"discussion_content":"文件描述符是相对于进程来说的，不同的进程，相同的fd指向的是不同的文件","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1625040242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066409,"avatar":"https://static001.geekbang.org/account/avatar/00/10/45/a9/3d48d6a2.jpg","nickname":"Lorry","note":"","ucode":"BD4754D0F1D786","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373785,"discussion_content":"你描述不就是并发问题吗？进程/线程对于公共资源的占用，为了避免并发设计了相应的机制哦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620872835,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137382,"user_name":"奔跑的码仔","can_delete":false,"product_type":"c1","uid":1609871,"ip_address":"","ucode":"AB3B02B07B8B8C","user_header":"https://static001.geekbang.org/account/avatar/00/18/90/8f/9c691a5f.jpg","comment_is_top":false,"comment_ctime":1569727132,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569727132","product_id":100024701,"comment_content":"“当我们用文件的 open 函数打开这个管道设备文件的时候，会调用 pipefifo_fops 里面的方法创建 struc file”。应该vfs创建的struct file，并将文件inode指向的pipefifo_fops赋值给struct file的的f_ops的吧？","like_count":0},{"had_liked":false,"id":111674,"user_name":"cuikt","can_delete":false,"product_type":"c1","uid":1242702,"ip_address":"","ucode":"9A1DB426CEFEEA","user_header":"https://static001.geekbang.org/account/avatar/00/12/f6/4e/0066303c.jpg","comment_is_top":false,"comment_ctime":1562581150,"is_pvip":false,"replies":[{"id":"46735","content":"命令写的有问题，echo &#39;aaa&#39;的输出，是后面的输入，而&gt;的意思是输出导向a.txt，和输入没有关系呀","user_name":"作者回复","comment_id":111674,"uid":"1001590","ip_address":"","utype":1,"ctime":1566387410,"user_name_real":"刘超@网易云"}],"discussion_count":2,"race_medal":0,"score":"1562581150","product_id":100024701,"comment_content":"老师你好，我在shell中执行echo &#39;aaa&#39; | &gt; a.txt ，为什么a.txt文件被创建了，但是a.txt是空的呢？","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457411,"discussion_content":"命令写的有问题，echo &amp;#39;aaa&amp;#39;的输出，是后面的输入，而&amp;gt;的意思是输出导向a.txt，和输入没有关系呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566387410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1101226,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cd/aa/33d48789.jpg","nickname":"卫江","note":"","ucode":"DE2F7A6916F1A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2840,"discussion_content":"管道是把上一个的输出当做下一个的输入，> 是输出重定向，与输入没有关系，上面的第二个命令并不能表达，我要把标准输入写到文件a.txt中，它只是代表一个重定向操作，可以改成 echo &#39;aaa&#39; | tee > a.txt,tee的作用就是把标准输入中的内容输出到标准输出中，而标准输出就是我们重定向之后的a,txt","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1563964076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107321,"user_name":"有铭","can_delete":false,"product_type":"c1","uid":1046302,"ip_address":"","ucode":"2C7CB36CA5C04C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3XbCueYYVWTiclv8T5tFpwiblOxLphvSZxL4ujMdqVMibZnOiaFK2C5nKRGv407iaAsrI0CDICYVQJtiaITzkjfjbvrQ/132","comment_is_top":false,"comment_ctime":1561514445,"is_pvip":false,"replies":[{"id":"48856","content":"都不像吧","user_name":"作者回复","comment_id":107321,"uid":"1001590","ip_address":"","utype":1,"ctime":1567501327,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"1561514445","product_id":100024701,"comment_content":"管道更像是流处理，还是批处理？","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455466,"discussion_content":"都不像吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567501327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}