{"id":158248,"title":"08 | 微服务架构模型：几种常见模型的对比和分析","content":"<p>你好，我是欧创新。</p><p>在上一讲中我重点介绍了DDD分层架构，同时我也提到了微服务架构模型其实还有好多种，不知道你注意到了没？这些架构模型在我们的实际应用中都具有很高的借鉴价值。</p><p>那么今天我们就把DDD分层架构（详情介绍如有遗忘可回看 <a href=\"https://time.geekbang.org/column/article/156849\">[第07讲]</a> ）、整洁架构、六边形架构这三种架构模型放到一起，对比分析，看看如何利用好它们，帮助我们设计出高内聚低耦合的中台以及微服务架构。</p><h2>整洁架构</h2><p>整洁架构又名“洋葱架构”。为什么叫它洋葱架构？看看下面这张图你就明白了。整洁架构的层就像洋葱片一样，它体现了分层的设计思想。</p><p>在整洁架构里，同心圆代表应用软件的不同部分，从里到外依次是领域模型、领域服务、应用服务和最外围的容易变化的内容，比如用户界面和基础设施。</p><p>整洁架构最主要的原则是依赖原则，它定义了各层的依赖关系，<span class=\"orange\">越往里依赖越低，代码级别越高，越是核心能力。</span>外圆代码依赖只能指向内圆，内圆不需要知道外圆的任何情况。</p><p><img src=\"https://static001.geekbang.org/resource/image/fc/42/fc8208d9f4cfadb7949d6e98a8c18442.png?wh=1123*767\" alt=\"\"></p><p>在洋葱架构中，各层的职能是这样划分的：</p><ul>\n<li>领域模型实现领域内核心业务逻辑，它封装了企业级的业务规则。领域模型的主体是实体，一个实体可以是一个带方法的对象，也可以是一个数据结构和方法集合。</li>\n<li>领域服务实现涉及多个实体的复杂业务逻辑。</li>\n<li>应用服务实现与用户操作相关的服务组合与编排，它包含了应用特有的业务流程规则，封装和实现了系统所有用例。</li>\n<li>最外层主要提供适配的能力，适配能力分为主动适配和被动适配。主动适配主要实现外部用户、网页、批处理和自动化测试等对内层业务逻辑访问适配。被动适配主要是实现核心业务逻辑对基础资源访问的适配，比如数据库、缓存、文件系统和消息中间件等。</li>\n<li>红圈内的领域模型、领域服务和应用服务一起组成软件核心业务能力。</li>\n</ul><!-- [[[read_end]]] --><h2>六边形架构</h2><p>六边形架构又名“端口适配器架构”。追溯微服务架构的渊源，一般都会涉及到六边形架构。</p><p>六边形架构的核心理念是：<span class=\"orange\">应用是通过端口与外部进行交互的。</span>我想这也是微服务架构下API网关盛行的主要原因吧。</p><p>也就是说，在下图的六边形架构中，红圈内的核心业务逻辑（应用程序和领域模型）与外部资源（包括APP、Web应用以及数据库资源等）完全隔离，仅通过适配器进行交互。它解决了业务逻辑与用户界面的代码交错问题，很好地实现了前后端分离。六边形架构各层的依赖关系与整洁架构一样，都是由外向内依赖。</p><p><img src=\"https://static001.geekbang.org/resource/image/85/6c/85fb9fb2782b343d45b4ca18c8f21e6c.png?wh=1142*854\" alt=\"\"></p><p>六边形架构将系统分为内六边形和外六边形两层，这两层的职能划分如下：</p><ul>\n<li>红圈内的六边形实现应用的核心业务逻辑；</li>\n<li>外六边形完成外部应用、驱动和基础资源等的交互和访问，对前端应用以API主动适配的方式提供服务，对基础资源以依赖倒置被动适配的方式实现资源访问。</li>\n</ul><p>六边形架构的一个端口可能对应多个外部系统，不同的外部系统也可能会使用不同的适配器，由适配器负责协议转换。这就使得应用程序能够以一致的方式被用户、程序、自动化测试和批处理脚本使用。</p><h2>三种微服务架构模型的对比和分析</h2><p>虽然DDD分层架构、整洁架构、六边形架构的架构模型表现形式不一样，但你不要被它们的表象所迷惑，这三种架构模型的设计思想正是微服务架构高内聚低耦合原则的完美体现，而它们身上闪耀的正是以领域模型为中心的设计思想。</p><p><img src=\"https://static001.geekbang.org/resource/image/b2/71/b2e4dad1040857b5aedf0b1675ae4171.png?wh=1310*971\" alt=\"\"></p><p>我们看下上面这张图，结合图示对这三种架构模型做一个分析。</p><p>请你重点关注图中的红色线框，它们是非常重要的分界线，这三种架构里面都有，它的作用就是将核心业务逻辑与外部应用、基础资源进行隔离。</p><p>红色框内部主要实现核心业务逻辑，但核心业务逻辑也是有差异的，有的业务逻辑属于领域模型的能力，有的则属于面向用户的用例和流程编排能力。按照这种功能的差异，我们在这三种架构中划分了应用层和领域层，来承担不同的业务逻辑。</p><p>领域层实现面向领域模型，实现领域模型的核心业务逻辑，属于原子模型，它需要保持领域模型和业务逻辑的稳定，对外提供稳定的细粒度的领域服务，所以它处于架构的核心位置。</p><p>应用层实现面向用户操作相关的用例和流程，对外提供粗粒度的API服务。它就像一个齿轮一样进行前台应用和领域层的适配，接收前台需求，随时做出响应和调整，尽量避免将前台需求传导到领域层。应用层作为配速齿轮则位于前台应用和领域层之间。</p><p><span class=\"orange\">可以说，这三种架构都考虑了前端需求的变与领域模型的不变。</span>需求变幻无穷，但变化总是有矩可循的，用户体验、操作习惯、市场环境以及管理流程的变化，往往会导致界面逻辑和流程的多变。但总体来说，不管前端如何变化，在企业没有大的变革的情况下，核心领域逻辑基本不会大变，所以领域模型相对稳定，而用例和流程则会随着外部应用需求而随时调整。把握好这个规律，我们就知道该如何设计应用层和领域层了。</p><p>架构模型通过分层的方式来控制需求变化从外到里对系统的影响，从外向里受需求影响逐步减小。面向用户的前端可以快速响应外部需求进行调整和发布，灵活多变，应用层通过服务组合和编排来实现业务流程的快速适配上线，减少传导到领域层的需求，使领域层保持长期稳定。</p><p>这样设计的好处很明显了，就是可以保证领域层的核心业务逻辑不会因为外部需求和流程的变动而调整，对于建立前台灵活、中台稳固的架构很有帮助。</p><p>看到这里，你是不是已经猜出中台和微服务设计的关键了呢？我给出的答案是：领域模型和微服务的合理分层设计。那么你的答案呢？</p><h2>从三种架构模型看中台和微服务设计</h2><p>结合这三种微服务架构模型的共性，下面我来谈谈中台和微服务设计的一些心得体会。</p><p>中台本质上是领域的子域，它可能是核心域，也可能是通用域或支撑域。通常大家认为阿里的中台对应DDD的通用域，将通用的公共能力沉淀为中台，对外提供通用共享服务。</p><p>中台作为子域还可以继续分解为子子域，在子域分解到合适大小，通过事件风暴划分限界上下文以后，就可以定义微服务了，微服务用来实现中台的能力。表面上看，DDD、中台、微服务这三者之间似乎没什么关联，实际上它们的关系是非常紧密的，组合在一起可以作为一个理论体系用于你的中台和微服务设计。</p><h3>1. 中台建设要聚焦领域模型</h3><p>中台需要站在全企业的高度考虑能力的共享和复用。</p><p>中台设计时，我们需要建立中台内所有限界上下文的领域模型，DDD建模过程中会考虑架构演进和功能的重新组合。领域模型建立的过程会对业务和应用进行清晰的逻辑和物理边界（微服务）划分。领域模型的结果会影响到后续的系统模型、架构模型和代码模型，最终影响到微服务的拆分和项目落地。</p><p>因此，在中台设计中我们首先要聚焦领域模型，将它放在核心位置。</p><h3>2. 微服务要有合理的架构分层</h3><p>微服务设计要有分层的设计思想，让各层各司其职，建立松耦合的层间关系。</p><p>不要把与领域无关的逻辑放在领域层实现，保证领域层的纯洁和领域逻辑的稳定，避免污染领域模型。也不要把领域模型的业务逻辑放在应用层，这样会导致应用层过于庞大，最终领域模型会失焦。如果实在无法避免，我们可以引入防腐层，进行新老系统的适配和转换，过渡期完成后，可以直接将防腐层代码抛弃。</p><p>微服务内部的分层方式我们已经清楚了，那微服务之间是否也有层次依赖关系呢？如何实现微服务之间的服务集成？</p><p>有的微服务可以与前端应用集成，一起完成特定的业务，这是项目级微服务。而有的则是某个职责单一的中台微服务，企业级的业务流程需要将多个这样的微服务组合起来才能完成，这是企业级中台微服务。<span class=\"orange\">两类微服务由于复杂度不一样，集成方式也会有差异。</span></p><p><strong>项目级微服务</strong></p><p>项目级微服务的内部遵循分层架构模型就可以了。领域模型的核心逻辑在领域层实现，服务的组合和编排在应用层实现，通过API网关为前台应用提供服务，实现前后端分离。但项目级的微服务可能会调用其它微服务，你看在下面这张图中，比如某个项目级微服务B调用认证微服务A，完成登录和权限认证。</p><p>通常项目级微服务之间的集成，发生在微服务的应用层，由应用服务调用其它微服务发布在API网关上的应用服务。你看下图中微服务B中红色框内的应用服务B，它除了可以组合和编排自己的领域服务外，还可以组合和编排外部微服务的应用服务。它只要将编排后的服务发布到API网关供前端调用，这样前端就可以直接访问自己的微服务了。</p><p><img src=\"https://static001.geekbang.org/resource/image/b4/9e/b4231550cfbd56c15ccb3795d1062f9e.png?wh=1899*971\" alt=\"\"></p><p><strong>企业级中台微服务</strong></p><p>企业级的业务流程往往是多个中台微服务一起协作完成的，那跨中台的微服务如何实现集成呢？</p><p>企业级中台微服务的集成不能像项目级微服务一样，在某一个微服务内完成跨微服务的服务组合和编排。</p><p>我们可以在中台微服务之上增加一层，你看下面这张图，增加的这一层就位于红色框内，它的主要职能就是处理跨中台微服务的服务组合和编排，以及微服务之间的协调，它还可以完成前端不同渠道应用的适配。如果再将它的业务范围扩大一些，我可以将它做成一个面向不同行业和渠道的服务平台。</p><p>我们不妨借用BFF（服务于前端的后端，Backend for Frontends）这个词，暂且称它为BFF微服务。BFF微服务与其它微服务存在较大的差异，就是它没有领域模型，因此这个微服务内也不会有领域层。BFF微服务可以承担应用层和用户接口层的主要职能，完成各个中台微服务的服务组合和编排，可以适配不同前端和渠道的要求。</p><p><img src=\"https://static001.geekbang.org/resource/image/ee/3b/eeb66579c1725817d0e9185161f1843b.png?wh=1853*1389\" alt=\"\"></p><h3>3. 应用和资源的解耦与适配</h3><p>传统以数据为中心的设计模式，应用会对数据库、缓存、文件系统等基础资源产生严重依赖。</p><p>正是由于它们之间的这种强依赖的关系，我们一旦更换基础资源就会对应用产生很大的影响，因此需要为应用和资源解耦。</p><p>在微服务架构中，应用层、领域层和基础层解耦是通过仓储模式，采用依赖倒置的设计方法来实现的。在应用设计中，我们会同步考虑和基础资源的代码适配，那么一旦基础设施资源出现变更（比如换数据库），就可以屏蔽资源变更对业务代码的影响，切断业务逻辑对基础资源的依赖，最终降低资源变更对应用的影响。</p><h2>总结</h2><p>今天我们详细讲解了整洁架构和六边形架构，并对包括DDD分层架构在内的三种微服务架构模进行对比分析，总结出了它们的共同特征，并从共性出发，梳理出了中台建模和微服务架构设计的几个要点，我们后面还会有更加详细的有关设计落地的讲述。</p><p><strong>那从今天的内容中我们不难看出：</strong>DDD分层架构、整洁架构、六边形架构都是以领域模型为核心，实行分层架构，内部核心业务逻辑与外部应用、资源隔离并解耦。请务必记好这个设计思想，今后会有大用处。</p><h2>思考题</h2><p>在系统设计时，你是如何避免外部需求对核心业务逻辑的影响的？有什么具体方法可以分享给大家吗？</p><p>欢迎留言分享，你也可以把今天所学分享给身边的朋友，邀请他一同交流、打卡。</p><p></p>","comments":[{"had_liked":false,"id":148590,"user_name":"ANYI","can_delete":false,"product_type":"c1","uid":1084773,"ip_address":"","ucode":"B010B0FB10E0C5","user_header":"https://static001.geekbang.org/account/avatar/00/10/8d/65/633a7478.jpg","comment_is_top":false,"comment_ctime":1573034757,"is_pvip":false,"replies":[{"id":"57230","content":"微服务之间要分两种情况，一种是项目级的少量微服务之间的调用。这样的调用可以放在微服务内的应用层，没必要再单独拿出一个微服务来进行服务组合和编排。<br>另外一种是复杂的企业级微服务调用和组合。拿出一个独立的BFF微服务的主要目的，一个是避免在一个微服务内组合太多的微服务的应用服务。二是，通过BFF微服务编排组合，可以减少由于前台的需求变化，传导到后端微服务中，可以降低后端微服务的发版频率，保持后端微服务的稳定。","user_name":"作者回复","comment_id":148590,"uid":"1316268","ip_address":"","utype":1,"ctime":1573044586,"user_name_real":"渔"}],"discussion_count":5,"race_medal":0,"score":"156191857413","product_id":100037301,"comment_content":"微服务之间通过服务内部的应用层来连接多个微服务，微服务之间的相互调用；有两个疑问：1，微服务之间互相调用应该是什么样子？会不会就出现了网状微服务的调用关系结构了<br>2，是把这个夸多个微服务的应用层独立起来成为一个微服务（类似BFF微服务，没有领域）减少微服务之间调用关系？微服务之间就应该减少依赖调用？","like_count":37,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473543,"discussion_content":"微服务之间要分两种情况，一种是项目级的少量微服务之间的调用。这样的调用可以放在微服务内的应用层，没必要再单独拿出一个微服务来进行服务组合和编排。\n另外一种是复杂的企业级微服务调用和组合。拿出一个独立的BFF微服务的主要目的，一个是避免在一个微服务内组合太多的微服务的应用服务。二是，通过BFF微服务编排组合，可以减少由于前台的需求变化，传导到后端微服务中，可以降低后端微服务的发版频率，保持后端微服务的稳定。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573044586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1167120,"avatar":"https://static001.geekbang.org/account/avatar/00/11/cf/10/9fa2e5ba.jpg","nickname":"进击的巨人","note":"","ucode":"DB62D77D460BF1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329646,"discussion_content":"另外企业级中台微服务通过增加一层BFF层，但也避免不了还是会有各个应用服务之间的相互调用和依赖问题吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606441959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1167120,"avatar":"https://static001.geekbang.org/account/avatar/00/11/cf/10/9fa2e5ba.jpg","nickname":"进击的巨人","note":"","ucode":"DB62D77D460BF1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329644,"discussion_content":"项目级微服务通过应用层进行进行交互，如果出现循环依赖怎么办啊？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606441860,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":186820,"discussion_content":"对于项目级微服务，在应用层调用其他微服务，如果A前端是一种逻辑判断；当遇到B前端时，可能是另外一种逻辑判断了，此时，就需要再重载一下方法，再进行针对B前端的逻辑处理吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582717080,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1437715,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f0/13/e5d0355a.jpg","nickname":"杨志远","note":"","ucode":"24F0BF091EDCBB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295496,"discussion_content":"可能要具体场景具体分析，参考工厂方法模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596208610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":186820,"ip_address":""},"score":295496,"extra":""}]}]},{"had_liked":false,"id":148231,"user_name":"lightSky","can_delete":false,"product_type":"c1","uid":1018749,"ip_address":"","ucode":"5801C2DF8ABEC5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8b/7d/6432b435.jpg","comment_is_top":false,"comment_ctime":1572961195,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"104652176299","product_id":100037301,"comment_content":"关于这几种架构的区别，我觉得可以有一条原则作为主线，就是依赖倒置，不管是clean架构还是分层，或者六边形架构，都是高层次依赖于低层次的接口，都是为了实现关注点分离，提高代码的内聚性，隔离变化，最终达到稳定性的同时拥有良好的扩展性，架构最终都是趋同的，不同点就是他们在层与层之间的扩展点的方式不同。😄","like_count":24},{"had_liked":false,"id":194554,"user_name":"IT_matters","can_delete":false,"product_type":"c1","uid":1074700,"ip_address":"","ucode":"71D7146E245D26","user_header":"https://static001.geekbang.org/account/avatar/00/10/66/0c/370626c4.jpg","comment_is_top":false,"comment_ctime":1585066786,"is_pvip":false,"replies":[{"id":"74333","content":"其实这三种架构是一种演化的关系。2003年DDD诞生，它是一种上下层的关系。六边形架构是在2005年提出，将这种上下层的关系演变为内外关系，内部代表了应用的业务逻辑，外部代表应用的驱动逻辑。但六边形架构的内层的业务逻辑还没有明显的领域模型的概念。2008年洋葱架构出现，六边形架构实际上是洋葱架构的一个超集。它与六边形架构有着相同的思路，都是通过编写适配器代码将应用逻辑从对基础设施的依赖中解放出来，避免基础设施代码渗透到应用逻辑中。洋葱架构在业务逻辑中加入了一些在领域驱动设计的分层的概念，比如用户接口层、应用层、领域层和基础层，另外它还明确了外层依赖内层，内层对外层无感知的这种依赖关系。虽然这三者之间在表达形式上存在差异，但它们的核心职责都是要做到核心业务逻辑和技术实现细节的分离和解耦。","user_name":"作者回复","comment_id":194554,"uid":"1316268","ip_address":"","utype":1,"ctime":1585223175,"user_name_real":"渔"}],"discussion_count":2,"race_medal":0,"score":"83189445410","product_id":100037301,"comment_content":"<br>您好，关于分层架构和六边形架构区别，在您给别人的评论中看到区别这样一段话。<br>------------------------------<br>主要区别还是在外围的适配上，端口适配器会给每个不同的场景，设计一个端口提供调用服务，这种是主动适配。还有一种是资源方面服务，是被动适配的方式。所有的外围对象都是平等的，可以是自动化的测试工具，也可以是APP。<br>DDD是通过接口层来对外提供服务接口，基础资源通过仓储依赖倒置使用资源，并实现解耦。<br><br>------------------------------<br>我感觉这二者还是一样的啊，如果分层架构在接口层，实现各种适配器，比如job，soa,rest。就可以说它是六边形架构了吗？有具体代码的例子吗，一望便知。从评论区来看，很多读者都对二者的区别比较疑惑。","like_count":19,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488841,"discussion_content":"其实这三种架构是一种演化的关系。2003年DDD诞生，它是一种上下层的关系。六边形架构是在2005年提出，将这种上下层的关系演变为内外关系，内部代表了应用的业务逻辑，外部代表应用的驱动逻辑。但六边形架构的内层的业务逻辑还没有明显的领域模型的概念。2008年洋葱架构出现，六边形架构实际上是洋葱架构的一个超集。它与六边形架构有着相同的思路，都是通过编写适配器代码将应用逻辑从对基础设施的依赖中解放出来，避免基础设施代码渗透到应用逻辑中。洋葱架构在业务逻辑中加入了一些在领域驱动设计的分层的概念，比如用户接口层、应用层、领域层和基础层，另外它还明确了外层依赖内层，内层对外层无感知的这种依赖关系。虽然这三者之间在表达形式上存在差异，但它们的核心职责都是要做到核心业务逻辑和技术实现细节的分离和解耦。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585223175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1074700,"avatar":"https://static001.geekbang.org/account/avatar/00/10/66/0c/370626c4.jpg","nickname":"IT_matters","note":"","ucode":"71D7146E245D26","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214711,"discussion_content":"谢谢您的解答，写的很详细","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585228162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":192283,"user_name":"steven","can_delete":false,"product_type":"c1","uid":1246817,"ip_address":"","ucode":"A19683831477C0","user_header":"https://static001.geekbang.org/account/avatar/00/13/06/61/1060cf94.jpg","comment_is_top":false,"comment_ctime":1584845144,"is_pvip":false,"replies":[{"id":"73729","content":"这种情况是经常遇到的，所以在开发的时候，在应用服务对聚合与聚合之间的服务编排时不要采用对象依赖，采用ID的方式。因为如果未来聚合被拆分到不同的微服务的时候，原来在一个微服务内的对象依赖就不存在了，你需要调的代码量就会比较多。","user_name":"作者回复","comment_id":192283,"uid":"1316268","ip_address":"","utype":1,"ctime":1584930621,"user_name_real":"渔"}],"discussion_count":6,"race_medal":0,"score":"53124452696","product_id":100037301,"comment_content":"应用层与领域层的区别，一般情况下还是很容易的。但是有些复杂的，也是经常会遇到的场景：比如某个A领域和B领域在C应用层作拼装时，会有业务判断的情况（比如需要综合判断A领域与B领域的对象，才能继续作后续的业务操作），此种情况下，如何设计才能避免这类问题呢？<br><br>尽量避免跨领域的业务聚合是一种方法，但是很多情况下很难避免这类现象。","like_count":12,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488360,"discussion_content":"这种情况是经常遇到的，所以在开发的时候，在应用服务对聚合与聚合之间的服务编排时不要采用对象依赖，采用ID的方式。因为如果未来聚合被拆分到不同的微服务的时候，原来在一个微服务内的对象依赖就不存在了，你需要调的代码量就会比较多。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1584930621,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188023,"avatar":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","nickname":"Eternal","note":"","ucode":"EA6FE7CC98F740","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327767,"discussion_content":"之前的写法\n\nObject aResult=a();\n\nObject bResult=b(aResult);\n\nObject cResult=b(bResult);\n\n改造后的写法\n\nObject aResult=a(objectId);\n\nObject bResult=b(objectId);\n\nObject cResult=b(objectId);\n\n不知道我理解的对不\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605942404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1435845,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e8/c5/8bdb0bba.jpg","nickname":"DarKnight","note":"","ucode":"B04AFD03768827","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1188023,"avatar":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","nickname":"Eternal","note":"","ucode":"EA6FE7CC98F740","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329301,"discussion_content":"我感觉这样是对的，不同聚合之间仅靠ID传参","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606362777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":327767,"ip_address":""},"score":329301,"extra":""}]},{"author":{"id":1449647,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1e/af/5b59f524.jpg","nickname":"yinyin","note":"","ucode":"D6C6E74D213EB4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540639,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640100396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1004349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/3d/1189e48a.jpg","nickname":"微思","note":"","ucode":"853C48AA183A7B","race_medal":4,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405880,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634655684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273428,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590456329,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150683,"user_name":"Geek_d94e60","can_delete":false,"product_type":"c1","uid":1336228,"ip_address":"","ucode":"31A7F2D17C9E74","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/dxDiajEGQoG0FRDX0CyQ43bLzO8w5tUyS3mDiaY7Q97xicLIGSmTFJZjAibYRWwvEYur9vjt9Tzic5icUETIbRGkhHGA/132","comment_is_top":false,"comment_ctime":1573601376,"is_pvip":false,"replies":[{"id":"57956","content":"BFF做微服务之间的编排。微服务内的应用服务主要做领域服务的编排和聚合之间的协调。BFF是微服务之间的，应用服务是微服务内的。","user_name":"作者回复","comment_id":150683,"uid":"1316268","ip_address":"","utype":1,"ctime":1573607169,"user_name_real":"渔"}],"discussion_count":1,"race_medal":0,"score":"44523274336","product_id":100037301,"comment_content":"如果有了BFF这一层做统一编排，微服务内部还需要编排吗？如果碰到如下两种方案<br>A调用B， B再调用C<br>A调用B ,   A再调用C<br>刚开始识别不出复用性，两个方案感觉都可行，如何抉择，有什么原则指导吗？","like_count":10,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474241,"discussion_content":"BFF做微服务之间的编排。微服务内的应用服务主要做领域服务的编排和聚合之间的协调。BFF是微服务之间的，应用服务是微服务内的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573607169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146122,"user_name":"瓜瓜","can_delete":false,"product_type":"c1","uid":1053853,"ip_address":"","ucode":"2E98377E48399E","user_header":"https://static001.geekbang.org/account/avatar/00/10/14/9d/19dcdd42.jpg","comment_is_top":false,"comment_ctime":1572436868,"is_pvip":false,"replies":[{"id":"56410","content":"没有差异就不会有这么多叫法😄。它们几个其实是一点一点继承和发展过来的，在大的分层上基本上没什么太大的差异，思路基本是一致的，都是以领域模型为中心，加上用于编排的应用层逻辑。但是在分层的内部有一些小的差异。包括外部的适配方式也有差异。","user_name":"作者回复","comment_id":146122,"uid":"1316268","ip_address":"","utype":1,"ctime":1572446442,"user_name_real":"渔"}],"discussion_count":1,"race_medal":0,"score":"44522109828","product_id":100037301,"comment_content":" 看完后，就是没区别。","like_count":11,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472719,"discussion_content":"没有差异就不会有这么多叫法😄。它们几个其实是一点一点继承和发展过来的，在大的分层上基本上没什么太大的差异，思路基本是一致的，都是以领域模型为中心，加上用于编排的应用层逻辑。但是在分层的内部有一些小的差异。包括外部的适配方式也有差异。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572446442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187547,"user_name":"sundy","can_delete":false,"product_type":"c1","uid":1724856,"ip_address":"","ucode":"581D4B976524B6","user_header":"https://static001.geekbang.org/account/avatar/00/1a/51/b8/f76b15a1.jpg","comment_is_top":false,"comment_ctime":1584156039,"is_pvip":false,"replies":[{"id":"72539","content":"中台体现的主要还是企业级的复用能力，它的价值不在技术上，可以说中台更偏业务。SOA或者微服务只是一种实现方式的不同。中台强调企业级内的整体解决方案。","user_name":"作者回复","comment_id":187547,"uid":"1316268","ip_address":"","utype":1,"ctime":1584283722,"user_name_real":"渔"}],"discussion_count":1,"race_medal":0,"score":"35943894407","product_id":100037301,"comment_content":"始终不理解soa与中台有啥区别，感觉在技术上没什么创新","like_count":8,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487142,"discussion_content":"中台体现的主要还是企业级的复用能力，它的价值不在技术上，可以说中台更偏业务。SOA或者微服务只是一种实现方式的不同。中台强调企业级内的整体解决方案。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584283722,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167986,"user_name":"kevin","can_delete":false,"product_type":"c1","uid":1199192,"ip_address":"","ucode":"918EFC033B1630","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/58/25152fa9.jpg","comment_is_top":false,"comment_ctime":1577972319,"is_pvip":false,"replies":[{"id":"65304","content":"现在技术发展这么快，一切皆有可能的。这样做其实也是将领域模型和资源逻辑解耦的过程。","user_name":"作者回复","comment_id":167986,"uid":"1316268","ip_address":"","utype":1,"ctime":1578031759,"user_name_real":"渔"}],"discussion_count":4,"race_medal":0,"score":"27347776095","product_id":100037301,"comment_content":"有个点一直不太理解，还望老师解惑。<br>文章提到抽象出一个仓储的接口，与基础层的数据库进行解耦，方便后续有替换数据库。这种情况在实际场景中很少出现，选用合适的存储中间件是一件重要的事情，一般在项目初期就确定了，中途替换的概率很小，为了这样的小概率事件，是不是有些过度设计？","like_count":6,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480086,"discussion_content":"现在技术发展这么快，一切皆有可能的。这样做其实也是将领域模型和资源逻辑解耦的过程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578031759,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135638,"avatar":"https://static001.geekbang.org/account/avatar/00/11/54/16/c9dabe36.jpg","nickname":"小辉辉","note":"","ucode":"86BD1A20A7B3CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543413,"discussion_content":"有些系统刚开始是给某个企业定做的。\n后期想市场推广，不能保证新客户就有原来指定的数据库。\n如果这时候再改代码来适配不同数据库，工作量就非常大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641130053,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188023,"avatar":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","nickname":"Eternal","note":"","ucode":"EA6FE7CC98F740","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327768,"discussion_content":"我们做消息系统，数据库用过MySQL、MongDB、ES 5年内换了3个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605942523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1259218,"avatar":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","nickname":"发条橙子 。","note":"","ucode":"ED076F4534FFED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":272422,"discussion_content":"当发展起来需要读写分离 分库分表 这个就很有必要了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590304000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146068,"user_name":"TH","can_delete":false,"product_type":"c1","uid":1053413,"ip_address":"","ucode":"C5EA20546DC09C","user_header":"https://static001.geekbang.org/account/avatar/00/10/12/e5/592d9324.jpg","comment_is_top":false,"comment_ctime":1572427924,"is_pvip":true,"replies":[{"id":"56394","content":"是这样的。直白一点就是业务的归业务，基础的归基础，两者通过一层来适配，具体就是通过接口的方式。","user_name":"作者回复","comment_id":146068,"uid":"1316268","ip_address":"","utype":1,"ctime":1572443292,"user_name_real":"渔"}],"discussion_count":5,"race_medal":0,"score":"27342231700","product_id":100037301,"comment_content":"想起了一句话：软件开发中遇到的所有问题，都可以通过增加一层抽象来解决。<br><br>对于依赖倒置的实现不是很清楚，按我的理解就是面向接口编程，由调用方将基础设施层的具体实现传入到被调用的服务，老师可以详细解释一下吗？","like_count":6,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472698,"discussion_content":"是这样的。直白一点就是业务的归业务，基础的归基础，两者通过一层来适配，具体就是通过接口的方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572443292,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1064149,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/2PtNr4sjKLYNnibicnwWcZicmQbTguUK9ZaCVBLYmiaSYFRjRrUP08jHO9N7KB2adDw87ywccexMJh8yCQ84q5gEzg/132","nickname":"阿固","note":"","ucode":"F16B99FED58993","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":47018,"discussion_content":"由调用方传入具体实现，个人认为有误，调用方是不关心具体实现的。依赖倒置，我的理解是：调用方（A）直接调用具体实现（B）完成功能，暂称A依赖B。现在A定义一个接口，A调用接口完成功能，而B要实现A的接口，称为B依赖A（的接口）。以上为个人理解","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573259852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1437715,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f0/13/e5d0355a.jpg","nickname":"杨志远","note":"","ucode":"24F0BF091EDCBB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1064149,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/2PtNr4sjKLYNnibicnwWcZicmQbTguUK9ZaCVBLYmiaSYFRjRrUP08jHO9N7KB2adDw87ywccexMJh8yCQ84q5gEzg/132","nickname":"阿固","note":"","ucode":"F16B99FED58993","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295893,"discussion_content":"\n依赖的方式有很多种A依赖于B，可以分为以下几种情况：\n1. B是A的成员属性\n2.B是A中某个方法的入参\n3.B是A中某个方法的返回值类型\n\n您说的B实现A接口，A与B是实现关系，并不依赖","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596377024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":47018,"ip_address":""},"score":295893,"extra":""},{"author":{"id":1435845,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e8/c5/8bdb0bba.jpg","nickname":"DarKnight","note":"","ucode":"B04AFD03768827","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1064149,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/2PtNr4sjKLYNnibicnwWcZicmQbTguUK9ZaCVBLYmiaSYFRjRrUP08jHO9N7KB2adDw87ywccexMJh8yCQ84q5gEzg/132","nickname":"阿固","note":"","ucode":"F16B99FED58993","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329297,"discussion_content":"原来的依赖方向，例如A依赖B，可能体现为A里面直接调用了B的方法。依赖倒置之后，A只调用了一个抽象的接口方法，B是这个抽象方法的其中一个实现。从原来的“A直接调用B”，反过来变成了“B要去实现A所需要的抽象”。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1606362530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":47018,"ip_address":""},"score":329297,"extra":""}]},{"author":{"id":1398824,"avatar":"https://static001.geekbang.org/account/avatar/00/15/58/28/c86340ca.jpg","nickname":"达文西","note":"","ucode":"01C1063F23D634","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":89058,"discussion_content":"再说说我的理解: 领域服务需要调用基础服务的功能,在基础服务中定义了相关要实现的接口,以及不同的实现,领域服务调用接口,再通过依赖注入的方式,引用不同的实现(比如spring中通过配置文件注入不同的实现),进而使得接口的具体行为依赖于注入的具体实现类,实现了依赖导致. 依赖倒置是一只编程思想,依赖注入是这种思想的其中一种实现方式.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576747676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145980,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1572411880,"is_pvip":false,"replies":[{"id":"56350","content":"这里你可以考虑单体架构的演进方式。可以先对系统做整体的领域建模分析，分解成多个不同的子域，建立领域模型。再根据优先级将部分领域模型对应的功能和数据从原来的单体应用中拆分出来，拆分为微服务。对原来的单体系统的前端提供API服务，原有系统的前端界面保持不变，整个架构演变用户无感知。当所有领域模型的微服务建设完成后，就可以抛弃原来的单体应用了。","user_name":"作者回复","comment_id":145980,"uid":"1316268","ip_address":"","utype":1,"ctime":1572422889,"user_name_real":"渔"}],"discussion_count":4,"race_medal":0,"score":"27342215656","product_id":100037301,"comment_content":"回答问题：<br>1.为了支持外部应用，内部核心业务必须增加新逻辑。这种情况主要是要提高对价值的意识和风险的敏感。尽量不去加核心逻辑的代码，如果加了，必须是有足够价值的特性，且风险点可控或无。<br>2.为了支持外部应用，内部核心业务存在现有功能逻辑，但需调整兼容。这种情况就对该核心逻辑做进一步抽象，将通用部分复用，常变部分做抽象，实现更细力度的配置策略的定制能力。（当然也是要有足够价值）。<br><br>提问：<br>老的大项目并没有合理的架构分层。套到整洁架构上来看。<br>1.领域服务层会干领域模型的活。（贫血领域模型）<br>2.领域服务层会干应用层的活。（领域层大量rpc调用外部服务，并依托外部服务返回的dto做大量业务）<br>3.基础层会干领域服务的事。（dao层写业务，发mq，存solr，redis）<br><br>对于以上情况，做既有代码改善的小步重构，老师可有好套路或则思路？毕竟这种项目要大改规范，成本（时间）和风险（线上事故）都是接受不了的。（我重构了一遍，但是是业务架构上的。领域服务和基础层的职责越界并没有全量调整，仅是跟着需求，若涉及到就修修补补）","like_count":6,"discussions":[{"author":{"id":1188023,"avatar":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","nickname":"Eternal","note":"","ucode":"EA6FE7CC98F740","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327764,"discussion_content":"先还是完整的建模走一遍，把最理想的领域模型搞出来，然后取最有价值的部分按照领域模型拆分成微服务，这样一点点的蚕食老系统，等它完全没啥业务了就干掉他","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1605941931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472653,"discussion_content":"这里你可以考虑单体架构的演进方式。可以先对系统做整体的领域建模分析，分解成多个不同的子域，建立领域模型。再根据优先级将部分领域模型对应的功能和数据从原来的单体应用中拆分出来，拆分为微服务。对原来的单体系统的前端提供API服务，原有系统的前端界面保持不变，整个架构演变用户无感知。当所有领域模型的微服务建设完成后，就可以抛弃原来的单体应用了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572422889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273422,"discussion_content":"mark，有参考价值","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590455712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1731543,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6b/d7/8872624a.jpg","nickname":"xmeng","note":"","ucode":"C0CA2182BA3B4B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351961,"discussion_content":"mark，先完整建模走一遍，把最理想的领域模型搞出来，然后取最有价值的部分按照领域模型拆分成微服务，这样一点点的蚕食老系统，等它完全没啥业务了就干掉他。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614527256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153027,"user_name":"y3","can_delete":false,"product_type":"c1","uid":1128084,"ip_address":"","ucode":"C93F8EC2AAACF6","user_header":"https://static001.geekbang.org/account/avatar/00/11/36/94/5aecb0ef.jpg","comment_is_top":false,"comment_ctime":1574142859,"is_pvip":false,"replies":[{"id":"58810","content":"你是说应用服务的编排吗？<br>你把这种编排理解成在同一个微服务内，一个方法对多个不同方法的调用就可以了，如果涉及到外部微服务的接口调用，你需要做DO与DTO的数据转换。","user_name":"作者回复","comment_id":153027,"uid":"1316268","ip_address":"","utype":1,"ctime":1574147568,"user_name_real":"渔"}],"discussion_count":2,"race_medal":0,"score":"18754012043","product_id":100037301,"comment_content":"请问老师，在设计微服务接口编排的时候，有哪些需要注意的地方？最好可以在github上给一个demo。","like_count":4,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475024,"discussion_content":"你是说应用服务的编排吗？\n你把这种编排理解成在同一个微服务内，一个方法对多个不同方法的调用就可以了，如果涉及到外部微服务的接口调用，你需要做DO与DTO的数据转换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574147568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1128084,"avatar":"https://static001.geekbang.org/account/avatar/00/11/36/94/5aecb0ef.jpg","nickname":"y3","note":"","ucode":"C93F8EC2AAACF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53231,"discussion_content":"好的，谢谢老师。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574147778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145994,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1572414497,"is_pvip":false,"replies":[{"id":"56454","content":"它们几个其实是一点一点继承和发展过来的，在大的分层上基本上没什么太大的差异，思路基本是一致的，都是以领域模型为中心，加上用于编排的应用层逻辑。但是在分层的内部有一些小的差异。包括外部的适配方式也有差异。","user_name":"作者回复","comment_id":145994,"uid":"1316268","ip_address":"","utype":1,"ctime":1572486002,"user_name_real":"渔"}],"discussion_count":3,"race_medal":0,"score":"18752283681","product_id":100037301,"comment_content":"分层架构、整洁架构、六边形架构有什么区别？","like_count":4,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472660,"discussion_content":"它们几个其实是一点一点继承和发展过来的，在大的分层上基本上没什么太大的差异，思路基本是一致的，都是以领域模型为中心，加上用于编排的应用层逻辑。但是在分层的内部有一些小的差异。包括外部的适配方式也有差异。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572486002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1016905,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","nickname":"观弈道人","note":"","ucode":"F3BB619A33C605","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54869,"discussion_content":"还是不理解它们具体有啥差异，代码写法上会有明显的不一样吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574321060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1067638,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4a/76/abb7bfe3.jpg","nickname":"大海浮萍","note":"","ucode":"7A3B9011C639ED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1016905,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","nickname":"观弈道人","note":"","ucode":"F3BB619A33C605","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331434,"discussion_content":"有同样的疑问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606874567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":54869,"ip_address":""},"score":331434,"extra":""}]}]},{"had_liked":false,"id":146988,"user_name":"默然","can_delete":false,"product_type":"c1","uid":1299976,"ip_address":"","ucode":"D4FEDA4E27D4D1","user_header":"https://static001.geekbang.org/account/avatar/00/13/d6/08/fc702101.jpg","comment_is_top":false,"comment_ctime":1572751745,"is_pvip":false,"replies":[{"id":"56785","content":"领域服务是不会暴露给多个微服务的。领域服务位于领域层，它只对应用层暴露。你说的领域服务是不是应用层的服务？<br>你说的数据聚合的问题，不清楚你内部数据是如何分库分表的，是否是一个微服务一个库。<br>如果按照DDD的方法设计的话，应该是一个微服务一个库。微服务拆分后，数据肯定会更分散。有几种方案可以解决你这个问题。<br>第一种方式，如果数据量不大的话，可以采用冗余数据的方式，如果微服务B要用微服务A的数据的话，你可以将微服务A的部分数据冗余到微服务B中，它可能是实体也可能是值对象。<br>第二种方式，如果数据量比较大的话，可以建立一个集中的数据平台或者叫数据中台，这个平台会汇集各个微服务的数据，你可以建立数据模型，加工处理，以后涉及到多个微服务数据的查询就可以走这个平台。","user_name":"作者回复","comment_id":146988,"uid":"1316268","ip_address":"","utype":1,"ctime":1572785781,"user_name_real":"渔"}],"discussion_count":3,"race_medal":0,"score":"14457653633","product_id":100037301,"comment_content":"领域服务被多个微服务依赖如何处理？<br>举个例子，我们有中台微服务A、B、C，都是用同一个网关，之前渠道都是PC。现在加一个APP，展示ABC的数据，但是关注点不一样，PC更关注整体的情况，而APP更关注实时的数据。加了一个APP的中台D，现在在APP需要看B里的报表，同时还要在app中收藏、评论、分享。做数据的聚合太麻烦了，由于没有分库，我就直接在D里处理了。","like_count":3,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473089,"discussion_content":"领域服务是不会暴露给多个微服务的。领域服务位于领域层，它只对应用层暴露。你说的领域服务是不是应用层的服务？\n你说的数据聚合的问题，不清楚你内部数据是如何分库分表的，是否是一个微服务一个库。\n如果按照DDD的方法设计的话，应该是一个微服务一个库。微服务拆分后，数据肯定会更分散。有几种方案可以解决你这个问题。\n第一种方式，如果数据量不大的话，可以采用冗余数据的方式，如果微服务B要用微服务A的数据的话，你可以将微服务A的部分数据冗余到微服务B中，它可能是实体也可能是值对象。\n第二种方式，如果数据量比较大的话，可以建立一个集中的数据平台或者叫数据中台，这个平台会汇集各个微服务的数据，你可以建立数据模型，加工处理，以后涉及到多个微服务数据的查询就可以走这个平台。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572785781,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273490,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590462376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1299976,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d6/08/fc702101.jpg","nickname":"默然","note":"","ucode":"D4FEDA4E27D4D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42910,"discussion_content":"是的，我就是想问数据分散的问题。期待后面的实战","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572825484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":276080,"user_name":"Md3zed","can_delete":false,"product_type":"c1","uid":1717785,"ip_address":"","ucode":"83EAD89468ED7B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/CccT5NgKlZRlTL8f4BsIDqfJ8tRkHPyaR3SXnfgU7acxo2OO7vGzNWjfQBuFnbPPzVYH8Lh49f1jyicuuRSndcA/132","comment_is_top":false,"comment_ctime":1611774383,"is_pvip":false,"replies":[{"id":"101041","content":"是的。","user_name":"作者回复","comment_id":276080,"uid":"1316268","ip_address":"","utype":1,"ctime":1612852695,"user_name_real":"欧创新"}],"discussion_count":2,"race_medal":0,"score":"10201708975","product_id":100037301,"comment_content":"实体的职责是处理实体内的业务逻辑，领域服务的职责是处理实体外的业务逻辑，这两种都是在领域内的业务逻辑。应用层（服务）的职责就是粘合剂把领域内的原子能力进一步粘合封装对外提供粗粒度的领域能力。bff的职责就是充当微服务间（不同子域）的粘合剂作用，提供统一完整的业务逻辑。","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514594,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612852695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2329181,"avatar":"https://static001.geekbang.org/account/avatar/00/23/8a/5d/9f146e48.jpg","nickname":"Monday","note":"","ucode":"33C597731B7AFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532199,"discussion_content":"用户接口层呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637554053,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215023,"user_name":"开心小毛","can_delete":false,"product_type":"c1","uid":1023762,"ip_address":"","ucode":"9D57A2773759F3","user_header":"","comment_is_top":false,"comment_ctime":1588875313,"is_pvip":false,"replies":[{"id":"80280","content":"微服务架构一般采用前后端分离设计，前端页面逻辑和后端微服务业务逻辑独立开发，独立部署，通过网关实现前后端集成。<br>前台应用接入中台微服务的技术组件一般是API网关。<br>API网关主要包括：鉴权、降级限流、流量分析、负载均衡、服务路由和访问日志等功能。API网关可以帮助用户，方便的管理微服务API接口，实现安全的前后端分离，实现高效的系统集成和精细的服务监控。<br>","user_name":"作者回复","comment_id":215023,"uid":"1316268","ip_address":"","utype":1,"ctime":1589424889,"user_name_real":"渔"}],"discussion_count":3,"race_medal":0,"score":"10178809905","product_id":100037301,"comment_content":"和使用注册中心相比，DDD落地中优先使用API网关么？<br>使用API网关可用性会不会受影响，例如API网关自身的吞吐，以及需要额外的心跳检测确保服务提供在线。（如果使用zookeeper作为注册中心的话这些问题都可以避免）。那么API网关在DDD中如此流行的原因是什么呢，其比较优势在哪里。<br>谢谢老师解惑。","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494280,"discussion_content":"微服务架构一般采用前后端分离设计，前端页面逻辑和后端微服务业务逻辑独立开发，独立部署，通过网关实现前后端集成。\n前台应用接入中台微服务的技术组件一般是API网关。\nAPI网关主要包括：鉴权、降级限流、流量分析、负载均衡、服务路由和访问日志等功能。API网关可以帮助用户，方便的管理微服务API接口，实现安全的前后端分离，实现高效的系统集成和精细的服务监控。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589424889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1053485,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/2d/ad1bfe92.jpg","nickname":"江湖中人","note":"","ucode":"9E464AE9CC62EE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318580,"discussion_content":"我理解的是这样的：API网关：对外提供服务；注册中心：用于内网应用之间的互相调用。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603785519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273454,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590457753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196035,"user_name":"莫离","can_delete":false,"product_type":"c1","uid":1099426,"ip_address":"","ucode":"DB820A7284CC36","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/a2/11c99f7f.jpg","comment_is_top":false,"comment_ctime":1585231996,"is_pvip":false,"replies":[{"id":"74414","content":"是的，BFF主要是做组合和串联。<br>跨微服务或者聚合的服务调用，如果是项目级的应用你直接通过应用服务来组合和编排就可以了。如果领域服务依赖其他微服务的应用服务，你把这部分组合逻辑上移到应用服务就可以了。","user_name":"作者回复","comment_id":196035,"uid":"1316268","ip_address":"","utype":1,"ctime":1585275812,"user_name_real":"渔"}],"discussion_count":4,"race_medal":0,"score":"10175166588","product_id":100037301,"comment_content":"BFF就相当于没有自己单独的业务逻辑，只是把多个微服务拿来做流程编排，相当于故事串联的作用，是吧？那如果有微服务A的应用层需要依赖微服务B，怎么办呢？还有就是微服务A的领域服务内部的业务逻辑需要依赖另外一个微服务B，这种情况又怎么处理呢，把微服务B当作基础数据层来处理？","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489215,"discussion_content":"是的，BFF主要是做组合和串联。\n跨微服务或者聚合的服务调用，如果是项目级的应用你直接通过应用服务来组合和编排就可以了。如果领域服务依赖其他微服务的应用服务，你把这部分组合逻辑上移到应用服务就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585275812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1210058,"avatar":"","nickname":"Geek_wentao","note":"","ucode":"847149D6352D13","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560882,"discussion_content":"跨微服务之间的领域服务依赖，将依赖逻辑上浮到应用服务是一种方法。我想到的是：是不是领域划分本身要调整呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649481024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188023,"avatar":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","nickname":"Eternal","note":"","ucode":"EA6FE7CC98F740","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302016,"discussion_content":"可以理解为跨微服务之间的领域服务依赖需要将依赖逻辑上浮到应用服务","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598759368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273427,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590456031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180483,"user_name":"刘强","can_delete":false,"product_type":"c1","uid":1816623,"ip_address":"","ucode":"3640B6AAD21D23","user_header":"https://static001.geekbang.org/account/avatar/00/1b/b8/2f/5b039bef.jpg","comment_is_top":false,"comment_ctime":1582293823,"is_pvip":false,"replies":[{"id":"70388","content":"你说的OBD应该只是做持久化吧。如果是这样，你一样还可以有领域层和应用层的。从OBD获取到持久化对象后，你就可以在领域层初始化领域对象，然后实现核心领域逻辑。","user_name":"作者回复","comment_id":180483,"uid":"1316268","ip_address":"","utype":1,"ctime":1582621885,"user_name_real":"渔"}],"discussion_count":4,"race_medal":0,"score":"10172228415","product_id":100037301,"comment_content":"看了这节课，我突然理解了我们公司的神人设计的思路了。他做了一个叫面向对象数据库的东西，暂且称为obd。我们开发的微服务不直接接触表，而是访问这个odb。有两个问题<br>1.他封装的这个odb就屏蔽了我们访问数据库的入口。<br>2.我们开发就没有了领域层，因为领域层都在odb里了，我们只需要开发应用层就好了，对吗","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484676,"discussion_content":"你说的OBD应该只是做持久化吧。如果是这样，你一样还可以有领域层和应用层的。从OBD获取到持久化对象后，你就可以在领域层初始化领域对象，然后实现核心领域逻辑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582621885,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1650785,"avatar":"https://static001.geekbang.org/account/avatar/00/19/30/61/50e24e09.jpg","nickname":"煜","note":"","ucode":"3C5A9A55A65FC9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377831,"discussion_content":"这东西和jpa概念其实是一样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622898411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1193337,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/79/21647da2.jpg","nickname":"Keith","note":"","ucode":"B40774090714D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366226,"discussion_content":"你这所说的obd就是基础层, 采用了仓储模式的设计, 屏蔽了具体存储的细节","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617983194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1259218,"avatar":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","nickname":"发条橙子 。","note":"","ucode":"ED076F4534FFED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":272421,"discussion_content":"他做的是基础层 帮你们做了应用层、领域层对基础层依赖倒置的事情","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590303949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166832,"user_name":"金龟","can_delete":false,"product_type":"c1","uid":1228500,"ip_address":"","ucode":"1C7D35C8AE8D9D","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/d4/ff1c1319.jpg","comment_is_top":false,"comment_ctime":1577608605,"is_pvip":false,"replies":[{"id":"64811","content":"这种服务调用方式要尽量避免。在领域建模的时候，要根据服务地图和微服务的上下游关系把这种循环调用的方式切断。","user_name":"作者回复","comment_id":166832,"uid":"1316268","ip_address":"","utype":1,"ctime":1577662576,"user_name_real":"渔"}],"discussion_count":2,"race_medal":0,"score":"10167543197","product_id":100037301,"comment_content":"个人感觉项目级微服务这里有问题，服务a的应用层直接调用服务b的应用层，那如果服务b再调服务a应用层不就成环了。我觉得应该是应用层只能调取下层接口，服务a的应用层也只能调用服务b的领域层","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479645,"discussion_content":"这种服务调用方式要尽量避免。在领域建模的时候，要根据服务地图和微服务的上下游关系把这种循环调用的方式切断。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577662576,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1107666,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/d2/638ca831.jpg","nickname":"z","note":"","ucode":"CDB0BE8562ECB6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267981,"discussion_content":"a不能调用b的领域层，只能调用6的应用层或者用户接口层。应该是照老师的说法，切断循环调用。每个微服务只暴露接口层","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589720300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161853,"user_name":"Geek_88604f","can_delete":false,"product_type":"c1","uid":1501234,"ip_address":"","ucode":"33DD1318E53814","user_header":"","comment_is_top":false,"comment_ctime":1576379905,"is_pvip":false,"replies":[{"id":"61647","content":"是的，这种领域模型是一种贫领域模型。可能没有聚合根的概念。实体之间是独立的，服务与服务之间也没有分层和编排。","user_name":"作者回复","comment_id":161853,"uid":"1316268","ip_address":"","utype":1,"ctime":1576398101,"user_name_real":"渔"}],"discussion_count":1,"race_medal":0,"score":"10166314497","product_id":100037301,"comment_content":"实际的项目中还存在一种集成方式：基于数据的集成。微服务A将外部的数据采集进来存储到对象存储服务上；微服务B批量处理这些数据，挖掘出数据关联规则存储到数仓中；微服务C从数仓中获取关联规则向用户呈现。微服务ABC之间并不存在直接的编排关系。","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477883,"discussion_content":"是的，这种领域模型是一种贫领域模型。可能没有聚合根的概念。实体之间是独立的，服务与服务之间也没有分层和编排。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576398101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332672,"user_name":"突围","can_delete":false,"product_type":"c1","uid":1090414,"ip_address":"","ucode":"03E865CC8A6F2A","user_header":"https://static001.geekbang.org/account/avatar/00/10/a3/6e/52580973.jpg","comment_is_top":false,"comment_ctime":1643453314,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5938420610","product_id":100037301,"comment_content":"仓储模式，如何使用依赖倒置的设计方法来解耦，没太明白，能详细说下吗？<br>这种模式，DAO层在各个业务微服务里吗？还是只是从代码层面隔离出来？","like_count":1},{"had_liked":false,"id":273124,"user_name":"Geek_4f13aa","can_delete":false,"product_type":"c1","uid":2323831,"ip_address":"","ucode":"BA01D6E6FCA734","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKRLfnpj6j5SJZpWQIgDLLuaEulApGkAiakL1lWG9CqveI4CiaLd1EZGbVOehmaJZG5pRbFZF58ZIdg/132","comment_is_top":false,"comment_ctime":1610445878,"is_pvip":false,"replies":[{"id":"99163","content":"定时任务平台应该属于基础设施层的组件吧，可以在领域层设计仓储接口，在基础层完成仓储实现。在领域层完成查询逻辑后，可以调用仓储接口启动工作流引擎。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1610693043,"ip_address":"","comment_id":273124,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5905413174","product_id":100037301,"comment_content":"欧老师，在使用四层模型的时候，系统中的job应该置于哪一层。例如用是xxl-job、VIP Saturn 相似的定时任务平台。需要在系统中嵌入式集成。实际使用会涉及到数据的查询，根据查询结果执行响应的cmd。","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513502,"discussion_content":"定时任务平台应该属于基础设施层的组件吧，可以在领域层设计仓储接口，在基础层完成仓储实现。在领域层完成查询逻辑后，可以调用仓储接口启动工作流引擎。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610693043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220478,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1590247855,"is_pvip":true,"replies":[{"id":"81576","content":"是的，所以领域建模很重要。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1590453976,"ip_address":"","comment_id":220478,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5885215151","product_id":100037301,"comment_content":"避免业务核心层受外部需求影响，本质上还是要建立一个业务内核<br>这个内核是稳定的，然后在内核之上可以做涎生与扩展<br>对应用DDD，就是建立领域层，然后在上层有应用层来实现跨聚合的流程编排与调用其它微服务的操作<br>这样领域层只受自已边界内的业务影响，而不会受边界外的需求影响，从而做到哲学上的高内聚低耦合","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496151,"discussion_content":"是的，所以领域建模很重要。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590453976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273452,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590457435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189629,"user_name":"杨杰","can_delete":false,"product_type":"c1","uid":1131823,"ip_address":"","ucode":"74817EA9499843","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/2f/b0b0dd74.jpg","comment_is_top":false,"comment_ctime":1584536065,"is_pvip":false,"replies":[{"id":"73048","content":"facade是被调，应用层可以编排内部的领域服务和外部的服务，如果放接口层，就没法编排外部服务了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1584545698,"ip_address":"","comment_id":189629,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5879503361","product_id":100037301,"comment_content":"回看的时候发现一个问题，如果微服务之间是通过应用层互相调用的。那么facade层还有什么用呢？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487751,"discussion_content":"facade是被调，应用层可以编排内部的领域服务和外部的服务，如果放接口层，就没法编排外部服务了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584545698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182709,"user_name":"see","can_delete":false,"product_type":"c1","uid":1644634,"ip_address":"","ucode":"F1F1CD1D85DDB5","user_header":"https://static001.geekbang.org/account/avatar/00/19/18/5a/a49a9353.jpg","comment_is_top":false,"comment_ctime":1582854133,"is_pvip":false,"replies":[{"id":"70696","content":"是的，b和c是领域层下的两个聚合的服务。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1582867815,"ip_address":"","comment_id":182709,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5877821429","product_id":100037301,"comment_content":"老师我有点不明白的是，<br>我在开发的时候是用一层应用层(简称a)利用rpc调用下面的几个rpc框架的服务(简称b服务，c服务)，那么根据你图中的理解，一个微服务应该是包括a，b，c。a是应用层，b，c是领域层，是这么理解的吗。","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485422,"discussion_content":"是的，b和c是领域层下的两个聚合的服务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582867815,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167694,"user_name":"lupguo","can_delete":false,"product_type":"c1","uid":1009098,"ip_address":"","ucode":"1B55A01DF78647","user_header":"https://static001.geekbang.org/account/avatar/00/0f/65/ca/38dcd55a.jpg","comment_is_top":false,"comment_ctime":1577894881,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5872862177","product_id":100037301,"comment_content":"solid原则、kiss原则、遵循高类聚低耦合原则、oop的封装继承和多态、抽象、领域核心能力、ddd分层依赖倒置解耦、洋葱由外向内依赖、六边形适配、微服务编排（项目、企业中台BFF）、区分变化和不变，将变化封装和隔离，可以引入防腐层实现架构演进和过度。","like_count":1},{"had_liked":false,"id":161151,"user_name":"Geek_aa8017","can_delete":false,"product_type":"c1","uid":1748911,"ip_address":"","ucode":"286195887103C2","user_header":"","comment_is_top":false,"comment_ctime":1576133139,"is_pvip":false,"replies":[{"id":"61483","content":"如果采用微服务架构，建议还是用springboot吧。用facade接口放DDD分层架构的用户接口层就可以了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1576194015,"ip_address":"","comment_id":161151,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5871100435","product_id":100037301,"comment_content":"老师，你后面讲的实战列子是基于什么架构来设计的啊？像用到springboot或springmvc定义的Controller类是放在用户接口层还是放在基础层呢，按我的理解如果基于ddd分层架构就放在用户接口层，如果是基于六边形架构就放在基础层，是这样吗？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477617,"discussion_content":"如果采用微服务架构，建议还是用springboot吧。用facade接口放DDD分层架构的用户接口层就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576194015,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146335,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1572502312,"is_pvip":false,"replies":[{"id":"56498","content":"你把项目级微服务和中台微服务理解为简单应用和企业级复杂应用就可以了。项目级应用是一两个微服务加前端就可以跑起来，服务关联简单，服务的编排和组合，在微服务内部解决就可以了。而企业级是有多个微服务加前端才能跑起来，在前端和微服务之间有大量的服务需要组合和编排，因此单独拿出一层，用于前端和微服务之间的组合和编排。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572510536,"ip_address":"","comment_id":146335,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5867469608","product_id":100037301,"comment_content":"不太能理解项目级微服务和中台微服务的区别，所以也就想不通为什么后者要加上一层BFF。<br>其实我觉得能不能抛开中台这个buzzy word来说明呢？毕竟BFF的概念是出的比中台要早很多。<br>顺便，我也觉得三种架构区别不大...或者说这三种是看问题的三个不同的角度。<br><br>","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472807,"discussion_content":"你把项目级微服务和中台微服务理解为简单应用和企业级复杂应用就可以了。项目级应用是一两个微服务加前端就可以跑起来，服务关联简单，服务的编排和组合，在微服务内部解决就可以了。而企业级是有多个微服务加前端才能跑起来，在前端和微服务之间有大量的服务需要组合和编排，因此单独拿出一层，用于前端和微服务之间的组合和编排。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572510536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2329181,"avatar":"https://static001.geekbang.org/account/avatar/00/23/8a/5d/9f146e48.jpg","nickname":"Monday","note":"","ucode":"33C597731B7AFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532200,"discussion_content":"那用户接口层呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637554555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188023,"avatar":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","nickname":"Eternal","note":"","ucode":"EA6FE7CC98F740","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327771,"discussion_content":"感觉是，应用多了，复杂了就加一层BFF，如果应用很简单，其实单体就够了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605943041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146046,"user_name":"何沛","can_delete":false,"product_type":"c1","uid":1477145,"ip_address":"","ucode":"5673C580982710","user_header":"https://static001.geekbang.org/account/avatar/00/16/8a/19/a54761af.jpg","comment_is_top":false,"comment_ctime":1572423694,"is_pvip":false,"replies":[{"id":"56407","content":"是的，领域层也是少不了要演进的😄。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572444576,"ip_address":"","comment_id":146046,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5867390990","product_id":100037301,"comment_content":"思考题：<br>面向用户的展现层可以快速响应外部需求进行调整和发布，灵活多变，<br>应用层通过服务组合和编排实现业务流程的快速适配上线，<br>领域层基本就不需要太多的变化了，<br>如果真的万不得已要修改领域层，领域层也要遵循面向对象的6大原则(单一职则原则、开闭原则、里氏替换原则、依赖倒置原则、接口隔离原则、迪米特原则），保证领域层高内聚低耦合。","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472686,"discussion_content":"是的，领域层也是少不了要演进的😄。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572444576,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1108505,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","nickname":"瓜瓜","note":"","ucode":"F90A5135A9BB4B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41594,"discussion_content":"为什么你这么优秀😀","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572477463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146041,"user_name":"Asia","can_delete":false,"product_type":"c1","uid":1218304,"ip_address":"","ucode":"7445830CD179A6","user_header":"https://static001.geekbang.org/account/avatar/00/12/97/00/fad94180.jpg","comment_is_top":false,"comment_ctime":1572422916,"is_pvip":false,"replies":[{"id":"56351","content":"微服务之间的调用都是在应用层。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572424025,"ip_address":"","comment_id":146041,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5867390212","product_id":100037301,"comment_content":"项目级微服务的那张图中，调用其他微服务的功能往往发生在领域层的领域服务中，甚至是领域模型的方法中，因为领域的某个属性或者能力依赖于其他服务，这种情况是设计的不合理导致的还是属于正常的呢？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472684,"discussion_content":"微服务之间的调用都是在应用层。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572424025,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1218304,"avatar":"https://static001.geekbang.org/account/avatar/00/12/97/00/fad94180.jpg","nickname":"Asia","note":"","ucode":"7445830CD179A6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":43999,"discussion_content":"按照作者的回答，是需要避免这种让A服务中的领域对象能力依赖于B服务的。但是应用层是处于领域核心层之上的，核心层是没法调用应用层的，否则这两层就相互依赖了。这就要求应用层能够进行细粒度的逻辑编排，这样做的结果往往会造成【领域模型缺血】或者领域服务被弱化，过多的逻辑细节拥挤在应用层","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1572921770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1108505,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","nickname":"瓜瓜","note":"","ucode":"F90A5135A9BB4B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41595,"discussion_content":"由此可见是设计不合理了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572477548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146035,"user_name":"。","can_delete":false,"product_type":"c1","uid":1222200,"ip_address":"","ucode":"75B163F01F20F3","user_header":"https://static001.geekbang.org/account/avatar/00/12/a6/38/55483b8c.jpg","comment_is_top":false,"comment_ctime":1572422420,"is_pvip":false,"replies":[{"id":"56352","content":"不是每个微服务都有自己的API网关，只是做一个示例。多个微服务可以共用一个API网关的。<br>在企业级中台设计的时候可以一个中台多个微服务共用一个网关。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572424176,"ip_address":"","comment_id":146035,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5867389716","product_id":100037301,"comment_content":"项目级微服务和企业级微服务的例子里，每个微服务都是有自己单独的注册中心？<br><br>我理解的是，一套微服务体系，包括：一个注册中心集群，微服务A集群，微服务B集群 等微服务集群，API网关集群。所有服务均通过API网关对外暴露，API网关还负责鉴权、限流、路由分发等。","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472681,"discussion_content":"不是每个微服务都有自己的API网关，只是做一个示例。多个微服务可以共用一个API网关的。\n在企业级中台设计的时候可以一个中台多个微服务共用一个网关。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572424176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145940,"user_name":"吃饭饭","can_delete":false,"product_type":"c1","uid":1231549,"ip_address":"","ucode":"95CFA07CDA2957","user_header":"https://static001.geekbang.org/account/avatar/00/12/ca/bd/a51ae4b2.jpg","comment_is_top":false,"comment_ctime":1572404419,"is_pvip":false,"replies":[{"id":"56353","content":"仓储模式是一种设计模式。它是在应用业务逻辑和数据层之间增加的一个抽象层，应用逻辑通过调用仓储接口的方式与数据层交互，与数据相关的实现都在仓储实现中实现，这样就可以避免在应用逻辑中混入数据相关的实现逻辑。从而就解耦了应用逻辑和数据逻辑。在基础资源变化时不会对应用逻辑有太大的影响。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572425923,"ip_address":"","comment_id":145940,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5867371715","product_id":100037301,"comment_content":"【在微服务架构中，应用层、领域层和基础层解耦是通过仓储模式，采用依赖倒置的设计方法来实现的】这种依赖倒置具体指的什么？是每个微服务不用配置自己的数据库，直接用数据仓库？数据库更换或者出问题了，自动切换配置屏蔽故障库？不太明白","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472638,"discussion_content":"仓储模式是一种设计模式。它是在应用业务逻辑和数据层之间增加的一个抽象层，应用逻辑通过调用仓储接口的方式与数据层交互，与数据相关的实现都在仓储实现中实现，这样就可以避免在应用逻辑中混入数据相关的实现逻辑。从而就解耦了应用逻辑和数据逻辑。在基础资源变化时不会对应用逻辑有太大的影响。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572425923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1220919,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/CJYUnMtcdu7GdMGxzVicTYpfsbhTKzrCIpoLIJxn8ByWsq1ol35RZLe1u4eWJpFhGK7ISpee2slWYokn0vBicw7A/132","nickname":"Woosang","note":"","ucode":"BB63C9F1BBDF61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41371,"discussion_content":"仓储模式是某种架构模式吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572411768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1220919,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/CJYUnMtcdu7GdMGxzVicTYpfsbhTKzrCIpoLIJxn8ByWsq1ol35RZLe1u4eWJpFhGK7ISpee2slWYokn0vBicw7A/132","nickname":"Woosang","note":"","ucode":"BB63C9F1BBDF61","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41533,"discussion_content":"是一种设计模式。增加一层，将业务逻辑与数据库实现分离。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572447030,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":41371,"ip_address":""},"score":41533,"extra":""}]}]},{"had_liked":false,"id":145925,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1572402953,"is_pvip":false,"replies":[{"id":"56315","content":"基础层是面向所有层的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572404453,"ip_address":"","comment_id":145925,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5867370249","product_id":100037301,"comment_content":"ddd分层、整洁架构、六变形架构。没看出太大的区别。核心都是应用层、领域层。 这三种架构的基础层，其它各层都可访问？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472631,"discussion_content":"基础层是面向所有层的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572404453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1419276,"avatar":"https://static001.geekbang.org/account/avatar/00/15/a8/0c/82ba8ef9.jpg","nickname":"Frank","note":"","ucode":"FAACCA4E6D481F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62264,"discussion_content":"我也很想知道这3种架构的区别，不然云里雾里的，傻傻分不清","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574828976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145885,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1572398505,"is_pvip":true,"replies":[{"id":"56313","content":"是这样的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572402911,"ip_address":"","comment_id":145885,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5867365801","product_id":100037301,"comment_content":"DDD 分层架构、整洁架构、六边形架构都是以领域模型为核心，实行分层架构，内部核心业务逻辑与外部应用、资源隔离并解耦","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472615,"discussion_content":"是这样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572402911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359508,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"湖南","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1665584177,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665584177","product_id":100037301,"comment_content":"BFF的实现是什么样子，引入所有的服务的api jar包？","like_count":0},{"had_liked":false,"id":358923,"user_name":"过河别忘了拆桥","can_delete":false,"product_type":"c1","uid":1217827,"ip_address":"四川","ucode":"B2547A0D3841BE","user_header":"https://static001.geekbang.org/account/avatar/00/12/95/23/03e7e400.jpg","comment_is_top":false,"comment_ctime":1665029877,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665029877","product_id":100037301,"comment_content":"感觉这几种架构没什么区别呢","like_count":0},{"had_liked":false,"id":356632,"user_name":"马什么冬梅","can_delete":false,"product_type":"c1","uid":1121568,"ip_address":"北京","ucode":"84702DC06AB24D","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/20/40964cca.jpg","comment_is_top":false,"comment_ctime":1662457081,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662457081","product_id":100037301,"comment_content":"老师你好, 我在尝试使用DDD设计系统的时候碰到两个疑问:<br><br>1. 关于事件, 我现在将事件区分为 本地领域事件 和 远程领域事件, 本地领域事件 就是在服务内进行发布, 订阅 这个比较简单; 但是对于远程领域事件这块, 当前服务会发布事件, 需要另一个微服务订阅, 在工程层面, 这个事件应该定义在哪里呢?<br>我想了几种方式:<br>    ① 定义在发布者所在微服务的 api 层中, 这个api 模块会被其他微服务依赖, 这样时间类就可以被复用<br>    ② 在发布者 和 订阅者两个微服务的 应用层中分别定义, 保证数据结构一致就行<br>这两种方式哪个比较合适? <br>2. 关于DDD分层架构中, 基础资源为什么会会依赖 应用层 和领域层? 在我理解中中间件会在 应用层中使用 例如 redis , MQ 这些在应用层中会被使用, 那应该是应用层依赖 基础层, 如果如图中, 基础层依赖应用层, 应用层如何调用这些基础资源能力呢?","like_count":0},{"had_liked":false,"id":356585,"user_name":"最可爱的人","can_delete":false,"product_type":"c1","uid":3069245,"ip_address":"广东","ucode":"2285BC4AAC434F","user_header":"https://static001.geekbang.org/account/avatar/00/2e/d5/3d/3e49c9db.jpg","comment_is_top":false,"comment_ctime":1662441557,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662441557","product_id":100037301,"comment_content":"1.微服务间调用是应用层调用应用层，采用http的话，服务方需要在应用层发布http服务？服务方的用户接口层不适用于微服务间调用吗？<br>2.数据库访问时，领域层定义接口，基础层实现。采用mybatis时，mapper本身就是接口，这块实践中如何操作呢？<br>","like_count":0},{"had_liked":false,"id":351584,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1657959662,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1657959662","product_id":100037301,"comment_content":"从层次调用上阿里的商业能力就有点像BFF。<br>但目的上会有差异。BFF是为了适应不同前端的变化而单独加了这一层，这个是解决前端部分的变化。<br>商业能力则是为了解决业务域的复用与扩展问题。没有商业能力则某个领域微服务就需要在这个域中调用其它微服务，这样对于定制来看是非常不利的，一次需求的定制可能就涉及到多个领域微服务的定制，并且很难知道一次需求要改动哪些领域以及哪些扩展点。<br>商业能力通过编排领域来实现最终业务能力。","like_count":0},{"had_liked":false,"id":351126,"user_name":"朱兆前","can_delete":false,"product_type":"c1","uid":1572378,"ip_address":"","ucode":"3F41AD9FCA7735","user_header":"https://static001.geekbang.org/account/avatar/00/17/fe/1a/9a7ad182.jpg","comment_is_top":false,"comment_ctime":1657536418,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1657536418","product_id":100037301,"comment_content":"中台应该是业务无关或者说引入任何业务内都不需要较大变动的模块吧？那这个bff的意义是什么呢？是为了满足部分业务的特殊性而增减服务编排的吗？比如文件服务做成中台，内部服务传上去即可了，但如对外的合同文件需要客户签署，也许会加一个短信通知服务(这里似乎中台互调，也有可能会业务服务包装后再去调用短信中台),bff是做这个的吗？如果这样的话，由中台维护还是业务部门自己二开呢","like_count":0},{"had_liked":false,"id":345024,"user_name":"Geek_f66cf1","can_delete":false,"product_type":"c1","uid":1937889,"ip_address":"","ucode":"F2F2F6FF6E76E8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqUFIOBnowQQXzVlTXw3ic49FZ8Wq3fD3CzwRh4DnsRqibAosIeXZ6mxaYZ3mOX8LRpYapeKO5iaouKA/132","comment_is_top":false,"comment_ctime":1651938488,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651938488","product_id":100037301,"comment_content":"防腐层是为了适配新老系统或者外部系统，可不能就那么随便废弃掉。","like_count":0},{"had_liked":false,"id":344959,"user_name":"炫封","can_delete":false,"product_type":"c1","uid":2996234,"ip_address":"","ucode":"A4A51E03D51125","user_header":"https://static001.geekbang.org/account/avatar/00/2d/b8/0a/36a25082.jpg","comment_is_top":false,"comment_ctime":1651896898,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651896898","product_id":100037301,"comment_content":"六边形是哪6边呢？看起来像是4变形架构（整洁架构）换了个形状。","like_count":0},{"had_liked":false,"id":343394,"user_name":"陶乐乐","can_delete":false,"product_type":"c1","uid":1943501,"ip_address":"","ucode":"2D4355A7498948","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epb9WYgYQJCMF3XrBbYxnzoXchW2DHfrXHeI2iasiasFdHzJ1XEMjKIN1WdqCgqIQqWU2ibQmYbCic6Gg/132","comment_is_top":false,"comment_ctime":1650814006,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650814006","product_id":100037301,"comment_content":"外部需求需要进行分析，确定它的业务流程编码，然后调用领域模型组成","like_count":0},{"had_liked":false,"id":331606,"user_name":"Dante","can_delete":false,"product_type":"c1","uid":2032233,"ip_address":"","ucode":"B9116D4EFAD195","user_header":"https://static001.geekbang.org/account/avatar/00/1f/02/69/394570a1.jpg","comment_is_top":false,"comment_ctime":1642669366,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642669366","product_id":100037301,"comment_content":"我想说的是，这跟六边形有啥关系？四边形五边形圆形不能说明问题？六在了何处。。","like_count":0},{"had_liked":false,"id":329146,"user_name":"楞伽山人","can_delete":false,"product_type":"c1","uid":1142335,"ip_address":"","ucode":"5859C06DAC790D","user_header":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","comment_is_top":false,"comment_ctime":1641179372,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641179372","product_id":100037301,"comment_content":"老师 我把所有的留言和文章都看完了 也没有看到每一层的异常怎么去定义呢？","like_count":0},{"had_liked":false,"id":329142,"user_name":"楞伽山人","can_delete":false,"product_type":"c1","uid":1142335,"ip_address":"","ucode":"5859C06DAC790D","user_header":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","comment_is_top":false,"comment_ctime":1641177283,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641177283","product_id":100037301,"comment_content":"老师 我看了一下您提供的这个项目 在应用层如果要调用其它微服务的应用层，那这个时候是存在dto的，这个dto是放在应用层的目录吗？而且这个过程还需要将do转换为dto，也会存在服务的暴露吧，这个时候也是接口存在dto，那这个时候返回的是dto还是do？目录又是什么样的呢","like_count":0},{"had_liked":false,"id":329140,"user_name":"楞伽山人","can_delete":false,"product_type":"c1","uid":1142335,"ip_address":"","ucode":"5859C06DAC790D","user_header":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","comment_is_top":false,"comment_ctime":1641175710,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641175710","product_id":100037301,"comment_content":"老师 你好 看了这么多篇了 总看到网关 在这里的网关和注册中心有什么区别吗？一直不太理解","like_count":0},{"had_liked":false,"id":326141,"user_name":"徐李","can_delete":false,"product_type":"c1","uid":1213325,"ip_address":"","ucode":"41550F6CA1E112","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/8d/03cac826.jpg","comment_is_top":false,"comment_ctime":1639392200,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1639392200","product_id":100037301,"comment_content":"这种架构理论的探索真的是需要大量的实践，不断的抽象出符合当下的开发模型。","like_count":0},{"had_liked":false,"id":326139,"user_name":"徐李","can_delete":false,"product_type":"c1","uid":1213325,"ip_address":"","ucode":"41550F6CA1E112","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/8d/03cac826.jpg","comment_is_top":false,"comment_ctime":1639392037,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1639392037","product_id":100037301,"comment_content":"第一次了解到基于领域的开发架构：DDD，整洁模式，六边形模式。以往自己做架构开发只涉及到了mvc的三层架构，这次接触到这些算是打开眼界。","like_count":0},{"had_liked":false,"id":322754,"user_name":"马以","can_delete":false,"product_type":"c1","uid":1344431,"ip_address":"","ucode":"3FEA06CA14DE28","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","comment_is_top":false,"comment_ctime":1637576006,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637576006","product_id":100037301,"comment_content":"为啥叫六边形架构，这里有啥特殊含义？我8边形和16边形不也是一样？","like_count":0},{"had_liked":false,"id":320475,"user_name":"Geek_1f3bda","can_delete":false,"product_type":"c1","uid":2106140,"ip_address":"","ucode":"50AA813F0C2CF8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erZP8e2vqiaACIicjjqB3IIlksQz5kvcsuOopiaXpUibI0MEPByxq985qKzZ9mwsAnH35wWrJQIPnZy7A/132","comment_is_top":false,"comment_ctime":1636346267,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1636346267","product_id":100037301,"comment_content":"老师，项目级的微服务两者之间的调用为什么还需要通过API网关，之间通过RPC协议走服务发现不行吗？","like_count":0,"discussions":[{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543488,"discussion_content":"是的 我也对这里不是很能理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641177809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319663,"user_name":"江宇霆","can_delete":false,"product_type":"c1","uid":1232848,"ip_address":"","ucode":"D38A92CFD4D611","user_header":"https://static001.geekbang.org/account/avatar/00/12/cf/d0/15d7c285.jpg","comment_is_top":false,"comment_ctime":1635904639,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635904639","product_id":100037301,"comment_content":"这几种架构的区别，可以搞个表格汇总吗？或者还有对应的代码。不然感觉看下来有点虚………","like_count":0},{"had_liked":false,"id":315252,"user_name":"俯瞰风景.","can_delete":false,"product_type":"c1","uid":1044166,"ip_address":"","ucode":"A6DB68B7B84AEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/c6/bebcbcf0.jpg","comment_is_top":false,"comment_ctime":1633768912,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633768912","product_id":100037301,"comment_content":"微服务架构的核心是隔离变化与不变。领域层实现稳定不变的核心业务逻辑，通过应用层对领域层的服务进行编排和组合，以应对复杂多变的用户接口层的需求。此外，领域层通过依赖倒置的方式消除对基础层的依赖，实现解耦，方便进行基础层组件的更新和升级。","like_count":0},{"had_liked":false,"id":313848,"user_name":"fcb的鱼","can_delete":false,"product_type":"c1","uid":1243901,"ip_address":"","ucode":"88667EBF09CEC0","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/fd/ec24cba7.jpg","comment_is_top":false,"comment_ctime":1632710433,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632710433","product_id":100037301,"comment_content":"看了本篇，也看了留言，还是没太明白为啥会有六边形架构一说(或者说为啥不是四边形或者五边形,这个六边形主要想体现出啥)。","like_count":0},{"had_liked":false,"id":313324,"user_name":"Mars","can_delete":false,"product_type":"c1","uid":1103640,"ip_address":"","ucode":"65DF3E2EC194FA","user_header":"https://static001.geekbang.org/account/avatar/00/10/d7/18/0d1447db.jpg","comment_is_top":false,"comment_ctime":1632378453,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1632378453","product_id":100037301,"comment_content":"欧老师，我想请问下，文中2张图里，微服务A，应用服务a，领域服务b 都分别是一个可执行的进程吗？ 我企业级跨服务架构中的 BFF微服务里 包含里应用服务A、B、C、D，它们之间的关系是什么？","like_count":0},{"had_liked":false,"id":313153,"user_name":"怕什么，抱紧我","can_delete":false,"product_type":"c1","uid":1318633,"ip_address":"","ucode":"CBCEA76E9EF33B","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/e9/dcc63d8f.jpg","comment_is_top":false,"comment_ctime":1632297960,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1632297960","product_id":100037301,"comment_content":"api网关那一层，就可以做成，BFF为微服务，没有领域","like_count":0},{"had_liked":false,"id":309291,"user_name":"花生","can_delete":false,"product_type":"c1","uid":1266634,"ip_address":"","ucode":"5397C08BD51DD4","user_header":"https://static001.geekbang.org/account/avatar/00/13/53/ca/44088dd0.jpg","comment_is_top":false,"comment_ctime":1630032992,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630032992","product_id":100037301,"comment_content":"api网关是什么概念，和niginx的区别是怎样的","like_count":0},{"had_liked":false,"id":302504,"user_name":"九先生","can_delete":false,"product_type":"c1","uid":1122533,"ip_address":"","ucode":"A63A333299D485","user_header":"https://static001.geekbang.org/account/avatar/00/11/20/e5/f66d6144.jpg","comment_is_top":false,"comment_ctime":1626243824,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626243824","product_id":100037301,"comment_content":"以电商平台为例：<br>BFF层：淘宝 天猫 阿里巴巴 饿了么 （小前台）<br>应用层：商品中心  订单中心  会员中心<br>领域层：商品中台、库存中台（属于商品中心应用），买家订单中台、卖家订单中台（订单中心）<br>BBB层做的是  商品中心、订单中心、会员中心 能力的编排<br>应用层做的是自己下面领域（业务中台）内 能力的编排<br>不知道这样举例是否合适？","like_count":0},{"had_liked":false,"id":296319,"user_name":"煜","can_delete":false,"product_type":"c1","uid":1650785,"ip_address":"","ucode":"3C5A9A55A65FC9","user_header":"https://static001.geekbang.org/account/avatar/00/19/30/61/50e24e09.jpg","comment_is_top":false,"comment_ctime":1622898218,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622898218","product_id":100037301,"comment_content":"传统的MVC三层架构不也是高层依赖低层接口吗，这种也是依赖倒置吗？","like_count":0},{"had_liked":false,"id":296306,"user_name":"sgl","can_delete":false,"product_type":"c1","uid":1252243,"ip_address":"","ucode":"D73875BA22954F","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/93/e3b44969.jpg","comment_is_top":false,"comment_ctime":1622892552,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622892552","product_id":100037301,"comment_content":"怎么才能让基础层，存储层依赖领域层，谁负责编排领域层的存储","like_count":0},{"had_liked":false,"id":293986,"user_name":"当你的世界里有风吹过","can_delete":false,"product_type":"c1","uid":2051946,"ip_address":"","ucode":"42712891366309","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4f/6a/0a6b437e.jpg","comment_is_top":false,"comment_ctime":1621670095,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621670095","product_id":100037301,"comment_content":"中台的概念中，对应的有前台和后台。 而BFF是否可以理解为前台的中的服务端，通过中台能力快速响应客户需求的变化？","like_count":0},{"had_liked":false,"id":292584,"user_name":"猛男还是萌男","can_delete":false,"product_type":"c1","uid":1132630,"ip_address":"","ucode":"BD334667FCCBFF","user_header":"https://static001.geekbang.org/account/avatar/00/11/48/56/99369df2.jpg","comment_is_top":false,"comment_ctime":1620884876,"is_pvip":false,"replies":[{"id":"105943","content":"在后面的课程里面有一个代码示例。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1620910879,"ip_address":"","comment_id":292584,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1620884876","product_id":100037301,"comment_content":"老师  到目前为止基本上学习的都是一些理论和思想，能不能专门给一个针对于DDD微服务架构的框架代码。在这个框架将所有的课程内容都体现进去，这样我们在学习的过程中能够结合实际的框架代码更能够容易理解这些设计思想。 ","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519885,"discussion_content":"在后面的课程里面有一个代码示例。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620910879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":282413,"user_name":"kevin","can_delete":false,"product_type":"c1","uid":1199192,"ip_address":"","ucode":"918EFC033B1630","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/58/25152fa9.jpg","comment_is_top":false,"comment_ctime":1615218563,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615218563","product_id":100037301,"comment_content":"看完了关于分层架构、洋葱架构、六边形架构还是不清楚区别在哪里？不都是分层么","like_count":0},{"had_liked":false,"id":280706,"user_name":"语行😄😀😍","can_delete":false,"product_type":"c1","uid":1067217,"ip_address":"","ucode":"652631AC09048E","user_header":"https://static001.geekbang.org/account/avatar/00/10/48/d1/f5f0e194.jpg","comment_is_top":false,"comment_ctime":1614323347,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614323347","product_id":100037301,"comment_content":"老师，我这边有个问题。<br>对于整洁架构和六边形架构，以我的理解，差别在于对前端应用和基础资源(数据库、缓存、文件系统)的适配上。不过就基础资源来说，都是要以依赖倒置的方式来实现吧？我不太清楚在实际应用中，六边形架构中的“适配器”，都是要以api网关的形式来做吗？","like_count":0},{"had_liked":false,"id":269095,"user_name":"run","can_delete":false,"product_type":"c1","uid":2330098,"ip_address":"","ucode":"D1FD236572F165","user_header":"https://static001.geekbang.org/account/avatar/00/23/8d/f2/8b2471ed.jpg","comment_is_top":false,"comment_ctime":1608521778,"is_pvip":false,"replies":[{"id":"97752","content":"如果是中台，并且需要考虑将这些服务组合后的逻辑，实现企业级复用的话，建议放在BFF层。如果只是简单的项目内容使用的话，可以放在用户中心的应用层的应用服务来编排，这样可以少运维一个微服务。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1608709558,"ip_address":"","comment_id":269095,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1608521778","product_id":100037301,"comment_content":"老师，请教个问题。假设我现在中台有用户中心、权益中心、安全中心三个微服务。我有个需求是用户登录的时候进行安全验证，或者用户注册的时候进行发放一个权益，这种涉及到跨领域的微服务调用是放在BFF层去组装呢，还是就放在在用户中心去调用其他中心的服务？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512147,"discussion_content":"如果是中台，并且需要考虑将这些服务组合后的逻辑，实现企业级复用的话，建议放在BFF层。如果只是简单的项目内容使用的话，可以放在用户中心的应用层的应用服务来编排，这样可以少运维一个微服务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608709558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1253652,"avatar":"https://static001.geekbang.org/account/avatar/00/13/21/14/423a821f.jpg","nickname":"Steven","note":"","ucode":"3FE64459842015","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541970,"discussion_content":"用户注册时发放权益，可以考虑用消息队列","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640616114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":247439,"user_name":"刘晓帆","can_delete":false,"product_type":"c1","uid":1159908,"ip_address":"","ucode":"988495B820D8CC","user_header":"https://static001.geekbang.org/account/avatar/00/11/b2/e4/2c593d2f.jpg","comment_is_top":false,"comment_ctime":1599709569,"is_pvip":true,"replies":[{"id":"90933","content":"1、你说的没错。用户接口层的服务封装了应用服务。跨微服务调用时的逻辑是这样的：微服务A将应用层的DO对象转换成DTO然后调用微服务B发布在API网关的用户接口层的服务，在微服务B内，Facade接口调用应用服务。<br>2、在微服务内应用层主要是完成业务逻辑的编排和组合，用户接口层主要是完成与外部应的接口和数据适配。如果全部放在用户接口层的话，应用层其实就没有存在的价值了。而其实很多时候微服务内需要组合多个聚合的领域服务以及外部微服务的服务，这一块的逻辑编排还是有一定的复杂度的，个人建议还是有所区分为好。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1599789005,"ip_address":"","comment_id":247439,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1599709569","product_id":100037301,"comment_content":"您好，受益匪浅<br>之前一直2个疑惑：<br>1. “微服务的应用服务，集成了其它微服务的应用服务”，为什么要这样说了？<br>我理解的实际情况是，微服务A的应用服务调用了微服务B的通信接口（无论http还是rpc）,那不应该说是“微服务的应用服务，集成了其它微服务的 用户接口的调用”<br><br>2. 紧接上个问题的延申，我一直有个想法想请指教：各个微服务间的交互，均通过应用服务调用其它微服务的用户接口层，真正实现“对内(微服务)既对外(前端等)”。<br>这样的话，微服务其实不用关注其它微服务的应用服务，只关注接口；所有涉及到的通信交互逻辑，像http、rpc，包括您之前说的领域事件&#47;消息中间件的消费（前面章节说放在应用层），都统一放在用户接口层，会不会更清晰？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505402,"discussion_content":"1、你说的没错。用户接口层的服务封装了应用服务。跨微服务调用时的逻辑是这样的：微服务A将应用层的DO对象转换成DTO然后调用微服务B发布在API网关的用户接口层的服务，在微服务B内，Facade接口调用应用服务。\n2、在微服务内应用层主要是完成业务逻辑的编排和组合，用户接口层主要是完成与外部应的接口和数据适配。如果全部放在用户接口层的话，应用层其实就没有存在的价值了。而其实很多时候微服务内需要组合多个聚合的领域服务以及外部微服务的服务，这一块的逻辑编排还是有一定的复杂度的，个人建议还是有所区分为好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599789005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236272,"user_name":"Lukia","can_delete":false,"product_type":"c1","uid":1028698,"ip_address":"","ucode":"C19472337BCCC6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b2/5a/574f5bb0.jpg","comment_is_top":false,"comment_ctime":1595382387,"is_pvip":false,"replies":[{"id":"87325","content":"这种外层依赖内层的依赖关系主要是指同一个微服务内。<br>当应用服务调用其他微服务的应用服务时，需要将DO转成DTO然后完成快微服务的服务调用。<br>","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1595406866,"ip_address":"","comment_id":236272,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1595382387","product_id":100037301,"comment_content":"请教老师，如果在一个微服务的应用层的逻辑编排有跨微服务的调用需求，是不是也需要像repo一样先在应用层定义一份rpc的接口（出于依赖需要指向内部同心圆的原则，否则就变成应用层需要依赖借接口层的rpc具体实现逻辑了）然后在","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502011,"discussion_content":"这种外层依赖内层的依赖关系主要是指同一个微服务内。\n当应用服务调用其他微服务的应用服务时，需要将DO转成DTO然后完成快微服务的服务调用。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595406866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":543494,"discussion_content":"老师 您好 我也有同样的疑问？我感觉这个问题没有说明清楚 而且这里面存在协议的转换，是不是跟Lukia同学说的情况一样 需要定义一层接口 具体实现到基础层去做呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641178987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":502011,"ip_address":""},"score":543494,"extra":""}]},{"author":{"id":1028698,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b2/5a/574f5bb0.jpg","nickname":"Lukia","note":"","ucode":"C19472337BCCC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292954,"discussion_content":"基础层做具体工作rpc框架的调用逻辑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595395687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223712,"user_name":"加勒比海带","can_delete":false,"product_type":"c1","uid":1180186,"ip_address":"","ucode":"129E060503085A","user_header":"https://static001.geekbang.org/account/avatar/00/12/02/1a/f7d899f2.jpg","comment_is_top":false,"comment_ctime":1591164390,"is_pvip":false,"replies":[{"id":"82478","content":"是的。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1591254396,"ip_address":"","comment_id":223712,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591164390","product_id":100037301,"comment_content":"之前没有应用服务和微服务的概念，学习了之后才懂得有这么多分层架构的模型。中台整个微服务的拆分是一个动态过程，有合有分，大的原则就是严格的耦合架构，设计出用户接口层、应用层、领域服务层、基础层。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497222,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591254396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221097,"user_name":"jun","can_delete":false,"product_type":"c1","uid":1899314,"ip_address":"","ucode":"3A9633CA1FE72E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/LalJD9ruYQI5zVM1GOCe4PjunIbbeeMiacFHC4TAj0DBVeialKt3vRCLs9dxn1vYXvfp8pgcyaeEQkh1nde1JoBQ/132","comment_is_top":false,"comment_ctime":1590403713,"is_pvip":false,"replies":[{"id":"81573","content":"微服务内服务的调用关系建议你看一下第16章，里面有详细描述。网关验证主要用于前后端分离后，前端应用与后端微服务之间的API调用管理。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1590453822,"ip_address":"","comment_id":221097,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590403713","product_id":100037301,"comment_content":"疑问：应用业务聚合层，调用领域层的基础服务，在部署上来说应该是属于内部网络调用，还需要经过网关验证吗？个人理解的是前端经过网关验证后，后续调用应该都是内部调用的链路。不知道理解的是否有问题，请指教。 ","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496330,"discussion_content":"微服务内服务的调用关系建议你看一下第16章，里面有详细描述。网关验证主要用于前后端分离后，前端应用与后端微服务之间的API调用管理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590453822,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208140,"user_name":"方佳","can_delete":false,"product_type":"c1","uid":1956418,"ip_address":"","ucode":"3EFE91C9621689","user_header":"","comment_is_top":false,"comment_ctime":1587283403,"is_pvip":false,"replies":[{"id":"77699","content":"这里不是直连的意思，是指它们都是属于基础资源这一类别的意思。<br>不管是连接到用户界面这一类主动适配还是连接到基础资源的被动适配，是都有一个适配器进行不同前端或后端资源的适配操作。<br>依赖倒置是依赖抽象接口进行程序设计，而不是依赖于具体实现编程。在DDD里领域逻辑会通过仓储接口访问基础层仓储实现的数据处理逻辑，所以只要仓储接口不变，更换基础资源就不会影响到任何领域逻辑实现代码，这样就实现了依赖倒置。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1587296772,"ip_address":"","comment_id":208140,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587283403","product_id":100037301,"comment_content":"如何理解洋葱架构最外层的基础资源直连数据库、文件等？  以及如何理解依赖倒置？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492355,"discussion_content":"这里不是直连的意思，是指它们都是属于基础资源这一类别的意思。\n不管是连接到用户界面这一类主动适配还是连接到基础资源的被动适配，是都有一个适配器进行不同前端或后端资源的适配操作。\n依赖倒置是依赖抽象接口进行程序设计，而不是依赖于具体实现编程。在DDD里领域逻辑会通过仓储接口访问基础层仓储实现的数据处理逻辑，所以只要仓储接口不变，更换基础资源就不会影响到任何领域逻辑实现代码，这样就实现了依赖倒置。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587296772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206082,"user_name":"风中舞者","can_delete":false,"product_type":"c1","uid":1070630,"ip_address":"","ucode":"BE0D480624CFC1","user_header":"https://static001.geekbang.org/account/avatar/00/10/56/26/5f78314d.jpg","comment_is_top":false,"comment_ctime":1586784777,"is_pvip":false,"replies":[{"id":"77325","content":"分层太多肯定会带来性能的影响所以需要权衡，尤其对于分层后如果需要数据转换带来的性能损耗。<br>其实DDD四层架构只是比三层架构多一层，把业务逻辑层分层了应用层和领域层，这种分层不会带来太多的性能损耗。但是它带来的价值是远远大于这种性能的损耗。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1587003587,"ip_address":"","comment_id":206082,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1586784777","product_id":100037301,"comment_content":"老师，文章里的企业中台微服务架构算上前端一共六层，虽然逻辑架构清晰，增加调用链路影响性能。这块如何解决。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491665,"discussion_content":"分层太多肯定会带来性能的影响所以需要权衡，尤其对于分层后如果需要数据转换带来的性能损耗。\n其实DDD四层架构只是比三层架构多一层，把业务逻辑层分层了应用层和领域层，这种分层不会带来太多的性能损耗。但是它带来的价值是远远大于这种性能的损耗。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587003587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1067638,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4a/76/abb7bfe3.jpg","nickname":"大海浮萍","note":"","ucode":"7A3B9011C639ED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331544,"discussion_content":"在CQRS架构的查询部分中，就是应用层直接调用仓储层直接查询，中间跳过了领域层","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606897585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2089155,"avatar":"","nickname":"昌南一枝花","note":"","ucode":"66118BEFFDC9BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297339,"discussion_content":"有的时候是不是可以简化一下？一个微服务内部，有的简单逻辑，比如Controller层需要查询的数据，数据库直接返回的PO对象就能满足，是不是就可以按3层来，无需再转化为DTO了？有的包含复杂逻辑的再加上领域层按4层来？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596880155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2089155,"avatar":"","nickname":"昌南一枝花","note":"","ucode":"66118BEFFDC9BF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543497,"discussion_content":"我个人觉的还是按照还是按照严格分层来好 后面方便服务的管理 如果后面基础层变了 用户接口层也可能发生变化影响的是多层了 再者是简单的调用 可能性能上不会有太多的影响 相反是复杂的调用有一些影响 既然是复杂的都能做 简单的去做何尝不是呢 更多是我们自己想快捷一下 是不是可以这么理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641180029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":297339,"ip_address":""},"score":543497,"extra":""}]}]},{"had_liked":false,"id":190574,"user_name":"Geek_d38f30","can_delete":false,"product_type":"c1","uid":1512147,"ip_address":"","ucode":"955D6480731336","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ib1aca6ibMC3bcTZeVdTFalyyhdvy4DLQ7s4WBTWaw95k8IJNTUkZ5VwfB9rYwxVz3PAz4chBJhWcyMHib9KdEEnQ/132","comment_is_top":false,"comment_ctime":1584669563,"is_pvip":false,"replies":[{"id":"73300","content":"是的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1584689641,"ip_address":"","comment_id":190574,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1584669563","product_id":100037301,"comment_content":"避免外部需求对核心业务逻辑的影响？<br>依赖控制反转。底层替换时，替换接口实现就好。<br>适配，新业务要适配老接口。做个转换。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488007,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584689641,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189951,"user_name":"杨杰","can_delete":false,"product_type":"c1","uid":1131823,"ip_address":"","ucode":"74817EA9499843","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/2f/b0b0dd74.jpg","comment_is_top":false,"comment_ctime":1584585260,"is_pvip":false,"replies":[{"id":"73082","content":"不好意思哈，省略了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1584590265,"ip_address":"","comment_id":189951,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1584585260","product_id":100037301,"comment_content":"欧老师：在上面企业级中台微服务的图上，BFF层是通过网关调用微服务的应用层而不是facade层。是上图省略了么？如果不是省略了，那么前面提到的facade在这个里面扮演的作用是什么呢？PS：昨天刚刚提过这个问题，但是感觉还不是很清晰。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487839,"discussion_content":"不好意思哈，省略了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584590265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188748,"user_name":"彦峰你要加油啊！","can_delete":false,"product_type":"c1","uid":1664020,"ip_address":"","ucode":"756E46DA81715D","user_header":"https://static001.geekbang.org/account/avatar/00/19/64/14/2f3263e3.jpg","comment_is_top":false,"comment_ctime":1584411280,"is_pvip":false,"replies":[{"id":"72891","content":"学无止境啊。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1584441164,"ip_address":"","comment_id":188748,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1584411280","product_id":100037301,"comment_content":"以前在学习的时候建议使用六边形架构, 我一直只知道六边形架构,这次明白了 DDD 分层架构、整洁架构、六边形架构 不学习真的不行","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487508,"discussion_content":"学无止境啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584441164,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178676,"user_name":"发飙的蜗牛","can_delete":false,"product_type":"c1","uid":1800868,"ip_address":"","ucode":"B2D96A2D0B6BA4","user_header":"https://static001.geekbang.org/account/avatar/00/1b/7a/a4/79ffe77c.jpg","comment_is_top":false,"comment_ctime":1581777593,"is_pvip":false,"replies":[{"id":"69831","content":"有一些项目建设过程中，存在新老并行的情况，老的是单体架构，而新的是微服务架构。有时候微服务为了保持领域模型同时为了兼容老系统的业务逻辑，会增加一些代码来处理这些新老系统之间的兼容性功能。等过渡期过去后，就可以删掉这些代码了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1582114317,"ip_address":"","comment_id":178676,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1581777593","product_id":100037301,"comment_content":"学习了整洁架构，六边形架构的分层架构设计，以及它们与DDD分层架构的异同。整洁架构又叫洋葱架构，由外向内依赖，其分层跟DDD差不多，主要目的也是实现核心业务逻辑与外部资源的隔离，从而实现高内聚，低耦合。六边形架构又叫端口适配器架构，通过各种适配器来解耦核心业务逻辑与外部资源。三种架构的设计都是以领域模型为中心进行分层，从而实现内部核心业务逻辑与外部应用，资源的解耦，实现高内聚低耦合！另外需要关注微服务之间的相互调用，可以在项目级微服务中调用其它微服务，然而当这种需求很频繁的时候，其实我们可以考虑在谢谢中台微服务之上增加一层BFF微服务，这样能减少微服务的频繁发布，只需要关注BFF就可以！<br>有一个问题，老师可以举一个例子来解释一下防腐层吗？不太理解","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483918,"discussion_content":"有一些项目建设过程中，存在新老并行的情况，老的是单体架构，而新的是微服务架构。有时候微服务为了保持领域模型同时为了兼容老系统的业务逻辑，会增加一些代码来处理这些新老系统之间的兼容性功能。等过渡期过去后，就可以删掉这些代码了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582114317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167385,"user_name":"苗","can_delete":false,"product_type":"c1","uid":1088710,"ip_address":"","ucode":"5ECCC6C855E541","user_header":"https://static001.geekbang.org/account/avatar/00/10/9c/c6/05a6798f.jpg","comment_is_top":false,"comment_ctime":1577781854,"is_pvip":false,"replies":[{"id":"64985","content":"其实这几种架构模式大同小异，saga是通过分布式事务来保证微服务之间的数据一致性。对于实时性要求不高的建议优先采用领域事件驱动机制。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1577797637,"ip_address":"","comment_id":167385,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577781854","product_id":100037301,"comment_content":"之前在看《微服务设计》一书中，记得作者提到六边形架构比较适合DDD,提倡各微服务应用采用saga事件的方式降低服务间的依赖。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479841,"discussion_content":"其实这几种架构模式大同小异，saga是通过分布式事务来保证微服务之间的数据一致性。对于实时性要求不高的建议优先采用领域事件驱动机制。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577797637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167120,"user_name":"郭登鹏","can_delete":false,"product_type":"c1","uid":1593777,"ip_address":"","ucode":"334CE44273D08F","user_header":"https://static001.geekbang.org/account/avatar/00/18/51/b1/d56c99c4.jpg","comment_is_top":false,"comment_ctime":1577695493,"is_pvip":false,"replies":[{"id":"64943","content":"后端推送是指异步的事件机制吗？在领域事件那一节有专门介绍。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1577746549,"ip_address":"","comment_id":167120,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577695493","product_id":100037301,"comment_content":"请教个问题 看到的都是关于用户层主动调用服务的方式 那后端推送的形式也是这样的设计嘛？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479751,"discussion_content":"后端推送是指异步的事件机制吗？在领域事件那一节有专门介绍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577746549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166853,"user_name":"hk","can_delete":false,"product_type":"c1","uid":1057377,"ip_address":"","ucode":"92996CA0BCDD66","user_header":"https://static001.geekbang.org/account/avatar/00/10/22/61/580bb3c3.jpg","comment_is_top":false,"comment_ctime":1577615241,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1577615241","product_id":100037301,"comment_content":"老师，如果分领域分库拆分了微服务，前台有一个聚合查询需求，这个聚合查询包含了有订单，商品，评论等领域的信息，对于这种横跨多领域的查询是需要采用搜索引擎还是其他的方法？","like_count":0,"discussions":[{"author":{"id":1438475,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f3/0b/4560079e.jpg","nickname":"王宇","note":"","ucode":"0E9BC3AD99C8E5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":192388,"discussion_content":"实在和同样的问题…我估计系统还不够大，拆微服务比较费心…","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583073415,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163576,"user_name":"达文西","can_delete":false,"product_type":"c1","uid":1398824,"ip_address":"","ucode":"01C1063F23D634","user_header":"https://static001.geekbang.org/account/avatar/00/15/58/28/c86340ca.jpg","comment_is_top":false,"comment_ctime":1576748100,"is_pvip":false,"replies":[{"id":"62325","content":"这几种架构都是前后端分离架构。<br>都是通过将前端适配和资源适配分离，从而保持领域模型的稳定和纯洁。DDD分层架构中的的领域模型的聚合边界，可以很好的实现微服务架构的演进。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1576825512,"ip_address":"","comment_id":163576,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1576748100","product_id":100037301,"comment_content":"从洋葱模型演进到六边形模型是把用户界面剥离出去,实现前后端分离?那从六边形演进到ddd模型,把用户接口层跟基础层分离出来相对带来什么好处呢?是不是相对来讲ddd架构比六边形架构更高内存低耦合了,也就更方便做微服务拆分","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478460,"discussion_content":"这几种架构都是前后端分离架构。\n都是通过将前端适配和资源适配分离，从而保持领域模型的稳定和纯洁。DDD分层架构中的的领域模型的聚合边界，可以很好的实现微服务架构的演进。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576825512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1253652,"avatar":"https://static001.geekbang.org/account/avatar/00/13/21/14/423a821f.jpg","nickname":"Steven","note":"","ucode":"3FE64459842015","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541996,"discussion_content":"有点晕了，演进的顺序到底是啥啊？\n洋葱模型 -&gt; 六边形 -&gt; DDD，还是 DDD -&gt; 六边形 -&gt; 洋葱模型？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640617756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162462,"user_name":"okjesse","can_delete":false,"product_type":"c1","uid":1050510,"ip_address":"","ucode":"1CD3B09D5C1F11","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8e/307098e4.jpg","comment_is_top":false,"comment_ctime":1576542917,"is_pvip":false,"replies":[{"id":"61795","content":"为了保持领域模型的独立性，尽量通过应用层的应用服务或者BFF吧。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1576545028,"ip_address":"","comment_id":162462,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576542917","product_id":100037301,"comment_content":"请问数据中台是最底层领域层可以调用还是bff层可以调用，还是两层都可以呢。谢谢","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478055,"discussion_content":"为了保持领域模型的独立性，尽量通过应用层的应用服务或者BFF吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576545028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156176,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1419276,"ip_address":"","ucode":"FAACCA4E6D481F","user_header":"https://static001.geekbang.org/account/avatar/00/15/a8/0c/82ba8ef9.jpg","comment_is_top":false,"comment_ctime":1574829081,"is_pvip":false,"replies":[{"id":"60121","content":"它们的设计思想都是为了分离关注点，在应用逻辑以下的部分思路基本都是一致的，主要是核心业务逻辑和领域模型。其实都可以用DDD的战略方法来设计领域模型。主要区别还是在外围的适配上，端口适配器会给每个不同的场景，设计一个端口提供调用服务，这种是主动适配。还有一种是资源方面服务，是被动适配的方式。所有的外围对象都是平等的，可以是自动化的测试工具，也可以是APP。<br>DDD是通过接口层来对外提供服务接口，基础资源通过仓储依赖倒置使用资源，并实现解耦。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574925477,"ip_address":"","comment_id":156176,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574829081","product_id":100037301,"comment_content":"看了之后，干货很多，但是对于3种架构的区别傻傻分不清，还请老师解答一下哈","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476019,"discussion_content":"它们的设计思想都是为了分离关注点，在应用逻辑以下的部分思路基本都是一致的，主要是核心业务逻辑和领域模型。其实都可以用DDD的战略方法来设计领域模型。主要区别还是在外围的适配上，端口适配器会给每个不同的场景，设计一个端口提供调用服务，这种是主动适配。还有一种是资源方面服务，是被动适配的方式。所有的外围对象都是平等的，可以是自动化的测试工具，也可以是APP。\nDDD是通过接口层来对外提供服务接口，基础资源通过仓储依赖倒置使用资源，并实现解耦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574925477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155816,"user_name":"白开水有三种味道","can_delete":false,"product_type":"c1","uid":1678696,"ip_address":"","ucode":"5706E8C4D284D6","user_header":"https://static001.geekbang.org/account/avatar/00/19/9d/68/75e6f912.jpg","comment_is_top":false,"comment_ctime":1574760700,"is_pvip":false,"replies":[{"id":"59907","content":"原子业务是实体或值对象的自身的业务行为和逻辑。最底层的流程应该领域服务，它有协调实体的职责。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574777297,"ip_address":"","comment_id":155816,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574760700","product_id":100037301,"comment_content":"原子层是不是企业的最底层的流程？比如销售记账，开票那些的","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475883,"discussion_content":"原子业务是实体或值对象的自身的业务行为和逻辑。最底层的流程应该领域服务，它有协调实体的职责。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574777297,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155444,"user_name":"周孟","can_delete":false,"product_type":"c1","uid":1062026,"ip_address":"","ucode":"2DD1B5199F1BC1","user_header":"https://static001.geekbang.org/account/avatar/00/10/34/8a/08a79d38.jpg","comment_is_top":false,"comment_ctime":1574689654,"is_pvip":false,"replies":[{"id":"59667","content":"领域模型大多提供的是实体相关的基础原子服务，只要基础模型不变，业务逻辑就不会变，所以领域模型基本就能保持稳定。而前端为了响应外部需求或流程的变化，所以会频繁的变动，但是这种变动可以通过应用层的编排很快做出调整，需求不会传导到领域层，所以领域模型的业务逻辑保持不变。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574693563,"ip_address":"","comment_id":155444,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574689654","product_id":100037301,"comment_content":"个人觉得这章节的关键在下面这句话：“可以说，这三种架构都考虑了前端需求的变与领域模型的不变。”，但一时没能想明白，目前接触的保险行业系统因产品变化，前后台都要改动没能很好识别出来领域模型不变这一点，老师能给解惑一下吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475755,"discussion_content":"领域模型大多提供的是实体相关的基础原子服务，只要基础模型不变，业务逻辑就不会变，所以领域模型基本就能保持稳定。而前端为了响应外部需求或流程的变化，所以会频繁的变动，但是这种变动可以通过应用层的编排很快做出调整，需求不会传导到领域层，所以领域模型的业务逻辑保持不变。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574693563,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154875,"user_name":"krugle","can_delete":false,"product_type":"c1","uid":1045770,"ip_address":"","ucode":"60A7D9189C01BE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/0a/077b9922.jpg","comment_is_top":false,"comment_ctime":1574585179,"is_pvip":false,"replies":[{"id":"59517","content":"前端展示的时候获取的数据是按需提供的，如果DO对象本身就有，只需要在DO转DTO的时候，加上就可以了，这个需求不会传导到基础层数据库的。<br>如果新增的字段涉及到领域层核心的实体属性或者数据库结构，确实需要从上到下修改。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574651518,"ip_address":"","comment_id":154875,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574585179","product_id":100037301,"comment_content":"基础层怎么才能做到通用 比如前端展示突然要多一个字煅 那基础层不是也要改吗 从上到下都要改","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475602,"discussion_content":"前端展示的时候获取的数据是按需提供的，如果DO对象本身就有，只需要在DO转DTO的时候，加上就可以了，这个需求不会传导到基础层数据库的。\n如果新增的字段涉及到领域层核心的实体属性或者数据库结构，确实需要从上到下修改。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574651518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147682,"user_name":"张迪","can_delete":false,"product_type":"c1","uid":1104835,"ip_address":"","ucode":"6A5D44999A0FEA","user_header":"https://static001.geekbang.org/account/avatar/00/10/db/c3/e11adfe8.jpg","comment_is_top":false,"comment_ctime":1572878969,"is_pvip":false,"replies":[{"id":"56931","content":"差的太多了。完全不在一个水平的东西。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572904911,"ip_address":"","comment_id":147682,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572878969","product_id":100037301,"comment_content":"怎么感觉中台和ESB好像<br>","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473285,"discussion_content":"差的太多了。完全不在一个水平的东西。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572904911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147138,"user_name":"miniluo","can_delete":false,"product_type":"c1","uid":1397339,"ip_address":"","ucode":"5735B6DEE7902B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/FheCgo4Ovibo0L1vAGgMdZkzQMm1GUMHMMqQ8aglufXaD2hW9z96DjQicAam723jOCZwXVmiaNiaaq4PLsf4COibZ5A/132","comment_is_top":false,"comment_ctime":1572825025,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572825025","product_id":100037301,"comment_content":"看完了，晚上回去画画图，这样深刻点。","like_count":0},{"had_liked":false,"id":146643,"user_name":"andywang","can_delete":false,"product_type":"c1","uid":1441581,"ip_address":"","ucode":"585092411083A6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKsHXJofxYo78CRv2h9BXic2qnnttQqxNicPYAibx721MuRa3NQeDVpzPJmMG1pGClpEfqHIwDxIeepg/132","comment_is_top":false,"comment_ctime":1572591679,"is_pvip":false,"replies":[{"id":"56697","content":"我也不知道它为什么画成六边形哈，是不是因为圆的、方的被别人占了，开个玩笑哈😄。有的人说是因为六边形最稳定，还有的说是一条边代表一个端口， 不过肯定不限定端口数量的。你有没有发现，在很多架构图中很多微服务都是用六边形来示意的，这或许就是它们的渊源。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572607393,"ip_address":"","comment_id":146643,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1572591679","product_id":100037301,"comment_content":"一直不是很明白这个六边形架构具体指的是哪六边形？ <br><br>难道是APP，web，自动化测试，DB，文件，缓存？？？ <br>","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472953,"discussion_content":"我也不知道它为什么画成六边形哈，是不是因为圆的、方的被别人占了，开个玩笑哈😄。有的人说是因为六边形最稳定，还有的说是一条边代表一个端口， 不过肯定不限定端口数量的。你有没有发现，在很多架构图中很多微服务都是用六边形来示意的，这或许就是它们的渊源。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572607393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1435845,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e8/c5/8bdb0bba.jpg","nickname":"DarKnight","note":"","ucode":"B04AFD03768827","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329308,"discussion_content":"我也以为六条边有什么特殊的六种涵义，现在看来更像是想表达领域模型是稳定的这一寓意","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606364296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1441581,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKsHXJofxYo78CRv2h9BXic2qnnttQqxNicPYAibx721MuRa3NQeDVpzPJmMG1pGClpEfqHIwDxIeepg/132","nickname":"andywang","note":"","ucode":"585092411083A6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42237,"discussion_content":"在领域驱动的书里也说六边形架构，但一直搞不清楚怎么把这个六边形架构落地了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572616919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146239,"user_name":"懒虫一个","can_delete":false,"product_type":"c1","uid":1119641,"ip_address":"","ucode":"FEC22E4606A235","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/99/d1dcdf76.jpg","comment_is_top":false,"comment_ctime":1572482178,"is_pvip":false,"replies":[{"id":"56441","content":"在实战篇里。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572483530,"ip_address":"","comment_id":146239,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572482178","product_id":100037301,"comment_content":"请问什么时候有代码案例、场景案例？可以加深影响","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472764,"discussion_content":"在实战篇里。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572483530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145948,"user_name":"切糕","can_delete":false,"product_type":"c1","uid":1185409,"ip_address":"","ucode":"DCD3C14CAC4ED3","user_header":"https://static001.geekbang.org/account/avatar/00/12/16/81/77f84354.jpg","comment_is_top":false,"comment_ctime":1572405608,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572405608","product_id":100037301,"comment_content":"三种架构都是以领域服务核心，利用分层思想，封装外部变化，实现高内聚、低耦合。","like_count":0},{"had_liked":false,"id":145900,"user_name":"天天向上","can_delete":false,"product_type":"c1","uid":1031113,"ip_address":"","ucode":"5948D359734193","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bb/c9/37924ad4.jpg","comment_is_top":false,"comment_ctime":1572400601,"is_pvip":false,"replies":[{"id":"56317","content":"不要求一个微服务一API网关的，你可以结合公司的具体情况。如果按照企业级中台设计的话，有可能一个中台会有一个 API网关，集中管理这个中台的服务发布。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572404745,"ip_address":"","comment_id":145900,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1572400601","product_id":100037301,"comment_content":"一个微服务 一个API网关 这个分太细啦吧？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472621,"discussion_content":"不要求一个微服务一API网关的，你可以结合公司的具体情况。如果按照企业级中台设计的话，有可能一个中台会有一个 API网关，集中管理这个中台的服务发布。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572404745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188023,"avatar":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","nickname":"Eternal","note":"","ucode":"EA6FE7CC98F740","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302020,"discussion_content":"我们公司就一共搞了3套api网关","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598759840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145891,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1572399436,"is_pvip":true,"replies":[{"id":"56312","content":"整洁架构不是传统的单体服务。这几种架构你要了解他们的分层，每层的含义。这些是不同于传统的单体架构的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572402792,"ip_address":"","comment_id":145891,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1572399436","product_id":100037301,"comment_content":"整体架构就相当于传统单体服务，前后端融合一起。六边形架构就是最近流行的前后端分离，老师是这样的吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472616,"discussion_content":"整洁架构不是传统的单体服务。这几种架构你要了解他们的分层，每层的含义。这些是不同于传统的单体架构的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572402792,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188023,"avatar":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","nickname":"Eternal","note":"","ucode":"EA6FE7CC98F740","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327770,"discussion_content":"整洁架构\n六边形架构\nDDD分层架构\n首先三个架构都是领域模型中的架构，因此他们都有别于传统架构\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605942867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}