{"id":740976,"title":"第 7 章 用测试描述需求和契约","content":"\n<p>在现代软件设计中，测试已经不再是传统的测试。自从“极限编程”方法学提出测试驱动开发，测试就已经突破了质量检验或者质量保证的功能范畴，成为软件开发活动中一个基础却重要的实践。本章我们将介绍软件开发的重要范式：测试先行。测试先行对于高效和高质量地进行软件开发极为重要。</p>\n<p>本章的结构如下。</p>\n<ul>\n<li>将测试作为一个建设性活动：从对测试认知的升级出发，说明测试已经不仅仅是传统意义上的测试，而是一个建设性的活动。</li>\n<li>从 V 模型到 I 模型：通过把需求分析和系统测试合二为一，把接口设计和模块测试、单元测试合在一起，加快反馈周期。</li>\n<li>用测试澄清和文档化需求：介绍 BDD 工具的使用，展示如何使用类自然语言描述需求。</li>\n<li>用测试澄清职责和契约：介绍 BDD 和 JUnit 等工具在模块设计粒度上的使用，展示如何使用这些工具说明设计契约。</li>\n<li>测试先行：讨论测试先行的开发范式，及其对质量和效率的重大影响。</li>\n</ul>\n<h2 id=\"nav_point_151\">7.1　将测试作为一个建设性活动</h2>\n<p>一个项目的测试活动应该在什么时候开始？“在项目的前期就应该开始”，大多数人会这样回答。测试人员应该在早期就参与需求的制定和评审活动，这是一个教科书式的回答，正确性当然毋庸置疑。但实际情况是怎样的呢？</p>\n<p>现状并没有预想的那样乐观。在实际的工作场景中，大量团队，特别是有专职测试人员的团队，经常在开发工作几乎完成时才开始真正认真地对待测试。在项目的早期，测试人员多数忙于其他项目，也不知道如何介入正在进行的需求分析等活动，并且从参与的必要性上讲，也没有感到多么紧急。</p>\n<p>这种比较典型的情况反映出大家对于测试活动的价值存在认知不足的问题。如果只是把测试作为质量保证活动，那么它在项目前期无法发挥作用几乎是必然的。不过，如果今天你还是这样认识测试，那么是时候升级一下认知了。</p>\n<p>人们对测试所发挥作用的认知，经历了一个渐进的过程。这里我们以 SWEBOK（软件工程知识体系）<sup>[38]</sup> 为例，看一下测试定义的变迁。SWEBOK 对测试的定义包括两段。在第一段中，它如此描述测试：</p><!-- [[[read_end]]] -->\n<blockquote>\n<p>软件测试使用有限的测试用例对一个程序的期望行为进行动态验证。测试用例集是从无限的执行域中选取的。</p>\n</blockquote>\n<p>这段描述反映的是测试的经典定义：做测试是验证程序的期望行为。好的测试应该使用尽量低的成本发现尽量多的问题。所以，这个描述中的关键字是“期望行为”“动态验证”“选取”“有限的测试用例”。在第二段中，SWEBOK 给出了更为重要的描述。</p>\n<blockquote>\n<p>最近，关于软件测试的观点进化为了建设性的活动。测试不再仅仅被视作在编码完成之后以发现错误为目的的活动。软件测试是（或者应该是）贯穿软件开发和维护的全生命周期的活动。</p>\n</blockquote>\n<p>这体现了非常重要的认知升级。之所以称软件测试为“建设性活动”，是因为传统意义上的软件测试被看作“破坏性活动”，即试图让软件在测试环境中运行失败并尽早修复，以保证最终所交付软件的质量。这种测试主要是用作质量反馈，并不能直接提升代码质量或者运行效率。而需求分析、软件设计和编码等都能让软件的能力越来越丰富，从而持续提升软件价值。软件测试升级为建设性活动，意味着软件测试不再是单纯的“测试”，而是可以更好地参与到需求分析、软件设计等活动中。</p>\n<p>我们已经见到过测试作为建设性活动的价值：在第 3 章讲解需求分析时，我们曾经介绍过实例化需求这一关键实践。实例化需求就是通过实际的例子来说明需求，测试人员、开发人员和需求人员都参与其中，并且这些实际的例子会被转换为测试用例。这就是测试先行给需求分析带来的好处：正是因为测试先行，才获得了更高质量的需求。测试先行，让传统的 V 模型发生了根本性的改变。</p>\n<h2 id=\"nav_point_152\">7.2　从 V 模型到 I 模型</h2>\n<p>软件测试成为建设性活动，是软件开发范式的一次重大改变。本节将介绍这一改变：从 V 模型到 I 模型。在需求领域，它对应于已经在第 3 章介绍过的实例化需求实践。在开发领域，它对应于一个重要的设计实践：测试先行的设计。</p>\n<h3 id=\"nav_point_153\">7.2.1　V 模型</h3>\n<p>V 模型<sup>[39]</sup>是一种软件开发生命周期模型，它的示意图如图 7.1 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00356.jpeg\" alt=\"\" width=\"90%\" style=\"width: 90%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 7.1</strong>　V 模型</p>\n<p>V 模型本质上是对瀑布模型的精化和改进。在瀑布模型中，测试是一个单独的阶段，没有强调测试活动具体应该如何进行，这个精度是不够的。对于大规模系统，测试肯定不可能一步完成，它需要从细粒度到粗粒度，逐级验证和向上集成。V 模型把测试活动进一步展开，强调了更细粒度的测试阶段，并且建立了开发活动和这些测试阶段之间的关系。</p>\n<p>V 模型精准展示了“测试活动”和“建设性活动”（如需求分析、架构、设计和编码）之间的验证关系。虽然 V 模型也说明了测试分析、测试计划等活动可以在需求分析、架构设计等阶段就同步开始，但是它的核心目标仍然是质量保证，与“建设性活动”没有什么关系。也就是说，测试活动对需求分析、架构、设计和编码的影响是后置的。</p>\n<h3 id=\"nav_point_154\">7.2.2　测试前置</h3>\n<p>图 7.1 所示的 V 模型有巨大的改进空间，也就是引入测试前置，这样，测试活动就可以对开发活动产生重要的影响。事实上，这是一种以终为始的思维模式。例如，曾经在 3.4 节讨论的实例化需求就是典型的测试前置的应用。</p>\n<p>在图 3.9 中，需求分析、测试分析和测试示例之间彼此配合，互相增强。当需求分析和测试分析这两个活动遵循 V 模型，并且在两个时空独立发生时，它们之间很难产生互动。但是，当以实例化需求的方式让这两个活动在同一时空中发生时，需求分析和测试分析就可以互相启发，这样既产生了更高质量的需求，也产生了更高质量的测试用例。</p>\n<h3 id=\"nav_point_155\">7.2.3　I 模型</h3>\n<p>并非只在需求分析阶段可以以终为始，在任何一个阶段，都可以应用这种测试前置的策略。如果把 V 模型中左右两侧的活动全部合并到同一时空中，就得到了 I 模型（如图 7.2 所示）。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00357.jpeg\" alt=\"\" width=\"67%\" style=\"width: 67%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 7.2</strong>　I 模型</p>\n<p>I 模型能够让反馈更加及时，让过程质量得到最大保证。读者先回顾图 1.2，再思考 I 模型，就会发现：I 模型是对缺陷成本递增曲线的最佳回应。</p>\n<p>I 模型推导出的实践有如下三个特点。</p>\n<ul>\n<li>在需求阶段立即验证需求质量，这就是曾在第 3 章介绍的实例化需求。</li>\n<li>在设计阶段立即验证设计质量，这就是本章和第 11 章将会深入探究的测试先行和测试驱动开发。</li>\n<li>在编码阶段立即验证编码质量，这就是将在第 10 章介绍的结对编程。</li>\n</ul>\n<p>因为这种立即的验证<span class=\"comment-number\">1</span>，I 模型能够带来快速的反馈，大幅提升各环节的质量，使总体质量提升并且使成本下降。</p>\n\n<h3 id=\"nav_point_156\">7.2.4　实例化需求</h3>\n<p>实例化需求的有效性来自测试前置。实例化需求也叫作验收测试驱动开发（ATDD，Acceptance Test-Driven Development），或者行为驱动开发（BDD，Behavior-Driven Development）。这三个名称虽然所站的视角不同，但都对应同一个实践。</p>\n<p>实例化需求是站在需求视角，关注如何把需求分析弄清楚，让需求描述无歧义。验收测试驱动开发关注的是验收测试前置，并且用这些验收测试来推进开发过程。行为驱动开发的思想和验收测试驱动开发类似，只不过它认为更重要的关注点是软件的期望行为，而不仅仅是测试。</p>\n<h3 id=\"nav_point_157\">7.2.5　测试先行的设计</h3>\n<p>把实例化需求的逻辑应用在设计活动中，就是测试先行的设计。在 6.4 节中，我们曾经提到过设计契约。但是，文本形式并不是描述设计契约的最佳形式，因为自然语言天生具有歧义，并且无论是 JavaDoc 文档还是普通的设计文档，都没法回避一个基本问题：文档很容易背离实际的代码。在本章中，我们将会看到如何使用自动化测试来表达设计契约。</p>\n<blockquote>\n<p>在开始实现之前就先用测试把意图说清楚的行为，就是测试先行的设计。</p>\n</blockquote>\n<h2 id=\"nav_point_158\">7.3　用测试澄清和文档化需求</h2>\n<p>首先我们来研究在需求分析和系统测试这个粒度上，如何使用自动化测试来增强沟通效果，提升质量保障能力。</p>\n<p>我们已经在第 3 章中介绍过如何用测试用例表达和澄清需求，本节就在此基础上研究如何把这些测试用例变为自动化的用例。仅仅把测试用例自动化并不困难，目前存在一些卓越的技术框架，借助这些框架把测试代码和需求文档合二为一，可以大幅提升测试用例作为需求说明的价值。</p>\n<h3 id=\"nav_point_159\">7.3.1　BDD 框架</h3>\n<p>我们习惯把整合了自动化测试和需求文档的框架称为 BDD 框架。各种 BDD 框架的本质类似，结构也大同小异。本节我们选择 Cucumber 框架作为示例来展示 BDD 框架在需求描述方面的强大能力。</p>\n<p><strong>案例</strong></p>\n<p>本节我们将继续基于用户注册的案例进行讨论。用户注册对应的业务规则和测试用例在表 3.1 中。如果使用 Cucumber 框架的自动化测试来描述业务规则，那这个测试是怎样的呢？代码清单 7.1 给出了一个示例。</p>\n<pre class=\"code-rows\"><code>Feature: 用户注册应该使用有效密码\n    有效密码需同时包含字母、数字、特殊字符且长度大于等于 6 位。\n\n    Scenario Outline: 用户注册\n        When 以用户名\"testuser\"、密码为\"&lt;password&gt;\"注册新用户\n        Then 结果应该是\"&lt;result&gt;\"\n\n        Examples:\n        | 业务规则                     | password      | result        |\n        | 包含字母、数字和特殊字符      | 1111!a        | 注册成功      |\n        | 密码长度要大于等于 6 位       | 123!a         | 失败：无效密码|\n        | 密码要包含字母                | 11111!        | 失败：无效密码|\n        | 密码要包含特殊字符            | 11111a        | 失败：无效密码|\n        | 密码要包含数字                | abcdef!       | 失败：无效密码|</code></pre>\n<p><strong>代码清单 7.1</strong>　用户注册过程中的密码校验</p>\n<p><strong>是自动化测试，也是可执行的需求</strong></p>\n<p>对比表 3.1 和代码清单 7.1，二者看起来几乎一样。就算要找差异，也只是这里多了一些类似于 <code>Feature</code>、<code>Scanario Outline</code>、<code>Given-When-Then</code> 以及 <code>Examples</code> 的关键字。即使没有编程背景，在阅读这段代码时也不会感到太困难。</p>\n<p>既然是代码，自然就可以运行。图 7.3 是在控制台键入 <code>cucumber</code> 命令后得到的输出。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00358.jpeg\" alt=\"\" width=\"98%\" style=\"width: 98%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 7.3</strong>　运行 Cucumber 自动化测试</p>\n<p>下面简要介绍一下这段输出中的关键内容。</p>\n<ul>\n<li>倒数第 3 行表明总共执行了 5 个测试场景，且全部通过。执行通过的测试在输出结果中标记为绿色。</li>\n<li>倒数第 2 行表明这些测试包含 10 个测试步骤。</li>\n<li>倒数第 1 行表明执行所有的测试共耗时 0.015 秒。</li>\n</ul>\n<p><strong>采用 BDD 框架的收益</strong></p>\n<p>BDD 框架让我们可以像描述需求一样撰写自动化测试，或者说可以用代码的形式描述需求，这是一个巨大的突破，原因有三。</p>\n<ul>\n<li>首先，这种需求描述形式是需求人员、开发人员和测试人员都能理解的。它有助于软件开发团队完成从 V 模型到 I 模型的演进。</li>\n<li>第二，传统需求文档面临的最大挑战就是随着业务的演化，它们会逐渐过时。为了保证需求文档能够及时更新，需要增加相当高的管理成本。而可执行的需求文档一旦不再是最新的，在执行时就一定会失败，这大大地保证了需求文档的准确性。能够始终保持更新的文档，也被称为活文档。</li>\n<li>第三，由于这种需求描述采用的是文本形式的代码，所以可以按代码对待它，包括使用版本管理工具的各种功能、通过代码库对其进行维护等，这也有助于保证测试和代码的一致性。</li>\n</ul>\n<h3 id=\"nav_point_160\">7.3.2　深入理解并使用 BDD 框架</h3>\n<p>深入理解 BDD 框架是非常重要的，这有助于更高效地使用这种框架描述“可执行的需求”。这里我们仍然以 Cucumber 框架为例进行介绍。</p>\n<p><strong>Cucumber 框架的结构要求</strong></p>\n<p>图 7.4 给出了 Cucumber 框架对自动化测试的结构要求。其中包含两个主要部分：业务功能描述和技术执行。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00359.jpeg\" alt=\"\" width=\"90%\" style=\"width: 90%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 7.4</strong>　Cucumber 框架自动化测试的结构</p>\n<p>业务功能描述的核心关注点是业务分析，即如何高质量地把需求说清楚、说明白。为此，Cucumber 框架定义了一个三级结构：功能、场景和步骤。它们之间的关系是：系统包含一系列功能，每个功能都涉及若干具体的使用场景，每个场景中都包含一组执行步骤。下面举例说明。</p>\n<ul>\n<li>用户注册、用户登录都是功能。</li>\n<li>对于用户注册这个功能，可能包含注册成功、注册失败等场景。</li>\n<li>注册成功场景和注册失败场景都要用到填写用户名、填写密码、点击注册等动作。</li>\n</ul>\n<p>分析代码清单 7.1，可以看到其是遵循 Cucumber 框架的规范撰写的。其中使用的语法规范叫作 Gherkin 语法。</p>\n<p><strong>Gherkin 语法</strong></p>\n<p>Gherkin 语法尽量模拟了自然语言。例如，代码清单 7.1 中高亮的 <code>Feature</code>、<code>Scenario Outline</code> 等都是 Gherkin 语法的关键字。执行 <code>cucumber</code> 命令时，Cucumber 工具需要根据这些关键字获知：当前在执行哪个功能、处于哪个场景，以及执行到了哪一个步骤。Gherkin 语法的关键字很少，列表见代码清单 7.1。</p>\n<p><strong>表 7.1</strong>　Gherkin 语法的关键字</p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>关键字</p></th>\n<th><p>中文关键字</p></th>\n<th><p>意义</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>Feature</code></p></td>\n<td><p>功能</p></td>\n<td><p>标识一个功能的开始</p></td>\n</tr>\n<tr>\n<td><p><code>Background</code></p></td>\n<td><p>背景</p></td>\n<td><p>介绍一些和当前功能相关的背景信息</p></td>\n</tr>\n<tr>\n<td><p><code>Scenario</code></p></td>\n<td><p>场景、剧本</p></td>\n<td><p>功能由若干场景构成，如成功场景、异常场景等</p></td>\n</tr>\n<tr>\n<td><p><code>Given</code></p></td>\n<td><p>假如、假设、假定</p></td>\n<td><p>一个场景的初始条件</p></td>\n</tr>\n<tr>\n<td><p><code>When</code></p></td>\n<td><p>当</p></td>\n<td><p>一个场景的触发动作</p></td>\n</tr>\n<tr>\n<td><p><code>Then</code></p></td>\n<td><p>那么</p></td>\n<td><p>一个场景的期望结果</p></td>\n</tr>\n<tr>\n<td><p><code>And</code></p></td>\n<td><p>而且、并且、同时</p></td>\n<td><p>关联词</p></td>\n</tr>\n<tr>\n<td><p><code>But</code></p></td>\n<td><p>但是</p></td>\n<td><p>关联词</p></td>\n</tr>\n<tr>\n<td><p><code>Scenario Outline</code></p></td>\n<td><p>场景大纲、剧本大纲</p></td>\n<td><p>为一组用例（数据驱动）提供的统一场景</p></td>\n</tr>\n<tr>\n<td><p><code>Examples</code></p></td>\n<td><p>例子</p></td>\n<td><p>为一组用例提供的数据</p></td>\n</tr>\n</tbody>\n</table>\n<p>在表 7.1 中，<code>Feature</code> 是最顶层的结构，它下辖若干 <code>Scenario</code>，每个 <code>Scenario</code> 都有一组 <code>Given-When-Then</code> 描述（我们已经在第 3 章介绍过 Given-When-Then 模式）。遵循 Gherkin 语法的文件叫作 Feature 文件，文件名的后缀为 .feature。代码清单 7.1 就是一个 Feature 文件。</p>\n<p><code>Given-When-Then</code> 描述的是测试用例真正要执行的动作。事实上，除了 <code>Given-WhenThen</code>，其他关键字都不需要具体到执行动作，<code>And</code> 和 <code>But</code> 是两个关联词，用于表达并列的初始条件、触发动作或期望结果。甚至更简洁点儿，一个星号（<code>*</code>）也可以表达关联信息。</p>\n<p><code>Scenario Outline</code> 和 <code>Examples</code> 是两种更简化的表达测试用例的方式。当存在若干场景都遵循相同的步骤，只是输入数据不同时，就可以使用场景大纲 - 例子的形式。。代码清单 7.1 中的测试用例就是采用了这种形式。</p>\n<p>值得说明一下，Cucumber 框架是支持中文的，表 7.1 的第二列中给出了 Gherkin 语法的中文关键字。这给非英语的团队提供了便利，可以让需求分析师等人更容易地接受 Gherkin 语法。如果使用中文关键字，那么代码清单 7.1 就可以如下书写。</p>\n<pre class=\"code-rows\"><code># language: zh-CN\n功能: 用户注册应该使用有效密码\n    有效密码需同时包含字母、数字、特殊字符且长度大于等于 6 位。\n\n    场景大纲: 用户注册\n        当 以用户名\"testuser\"、密码为\"&lt;password&gt;\"注册新用户\n        那么 结果应该是\"&lt;result&gt;\"\n\n        例子:\n        （后续省略）</code></pre>\n<p><strong>代码清单 7.2</strong>　使用中文关键字表达测试场景</p>\n<p>这样的“测试”看起来更像文档了，大大增加了可读性。</p>\n<p><strong>编写胶水层代码</strong></p>\n<p>一切 BDD 工具都离不开“胶水层”，因为计算机不太可能直接理解自然语言，因此还需要一层“胶水”，其正式的说法是步骤定义，用来把自然语言和真实系统联系起来。本节我们继续以 Cucumber 框架为例，介绍如何使用胶水层代码将执行步骤映射到系统动作。</p>\n<p>简单起见，本例假定完成用户注册需要调用 HTTP 接口。当然，注册功能也可以通过 Web 页面完成，或者通过手机操作界面完成，不管使用哪种形式，本节讨论的方法都是普遍适用的，只是胶水层代码的编写方式有所不同。</p>\n<p>假定该注册接口是在 http://localhost:8080/register 上提供的一个 POST 操作，接收 JSON 格式的数据，返回注册是否成功的信息。按照这个接口定义，我们使用 Ruby 语言<span class=\"comment-number\">2</span>编写步骤定义的代码如下所示。</p>\n\n<pre class=\"code-rows\"><code>require 'net/http'\nrequire 'uri'\nrequire 'json'\nrequire \"rspec/expectations\"\n\nWhen(/^以用户名\"([^\"]*)\"、密码为\"([^\"]*)\"注册新用户 【美】/) do |username, password|\n    @expect_result = register(username, password)\nend\n\nThen(/^结果应该是'(.*)'【美】/) do |expect_result|\n    expect(@expect_result).to eq expect_result\nend\n\ndef register (username, password)\n    uri = URI.parse(\"http://localhost:8080/register\")\n    header = {'Content-Type': 'application/json'}\n    user = {\n        name: username,\n        password: password\n    }\n\n    http = Net::HTTP.new(uri.host, uri.port)\n    request = Net::HTTP::Post.new(uri.request_uri, header)\n    request.body = user.to_json\n\n    response = http.request(request)\n    return (response.body == \"Registration Success.\") ? \"注册成功\" : \"失败：无效密码\"\nend</code></pre>\n<p><strong>代码清单 7.3</strong>　使用 Ruby 语言实现的用户注册胶水层代码</p>\n<p>把上述代码保存为 registration_steps.rb 文件。根据 Cucumber 的约定，本例的实际代码结构如图 7.5 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00360.jpeg\" alt=\"\" width=\"90%\" style=\"width: 90%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 7.5</strong>　Cucumber 自动化测试的代码结构</p>\n<p>请首先关注代码清单 7.3 中的第 6 行至第 20 行，紧跟在 <code>Given</code>、<code>When</code>、<code>Then</code> 关键字之后的正则表达式是把自然语言和可执行代码联系起来的关键。Cucumber 自动化测试在执行时看到 Feature 文件中定义的步骤后，就会到对应的步骤定义文件中寻找与之匹配的文本。如果找到，就会执行后面的代码。例如，在本例中，当读取到“用户名为 <code>'testuser'</code>”这样的文本时，就会匹配代码清单 7.3 中的第 6 行至第 8 行，把 <code>testuser</code> 赋值给 <code>username</code> 变量。当读取到“用户注册”这个步骤时，则会执行第 14 行至第 16 行，调用 <code>register</code> 方法。</p>\n<p>调用系统的功能只是执行了测试动作，我们还需要判断执行结果是成功还是失败。这需要用到一个重要的测试概念：断言。断言比较实际执行结果和预期执行结果，当二者相同时断言成功，否则断言失败。本例中使用了 Ruby 的 RSpec 断言库，其具体的判断逻辑如代码清单 7.3 中的第 18 行至第 20 行所示。</p>\n<p>具体的实现方式并不是本节的介绍要点，关键需要注意的是 BDD 工具是如何融合需求文档和自动化测试用例，让需求说明更清晰，更容易保持更新，同时又能起到质量保障作用的。此外，Cucumber 当然不是唯一的 BDD 工具，Guage、Robot Framework 等也都各具特色。在实际工作中可以结合场景选择合适的工具。</p>\n<h2 id=\"nav_point_161\">7.4　用测试澄清职责和契约</h2>\n<p>在第 5 章中，我们使用科赫雪花类比了设计单元的自相似性——设计单元的结构都是相似的，只是层次粒度有所不同。现在我们把这个理论应用于测试：既然可以使用自动化测试来说明需求，那使用自动化测试来说明设计职责自然也可以。两者唯一的区别是关键涉众有所不同：需求的核心关注者包括用户、业务人员等，设计职责的核心关注者则主要是彼此协作的开发团队，或者开发者自己。</p>\n<h3 id=\"nav_point_162\">7.4.1　把在实例化需求阶段编写的测试用例复用到内部接口</h3>\n<p>在 7.3 节中，我们使用 Cucumber 编写了用户注册功能的系统级测试。但是，如果只能在系统级执行这些测试，执行成本会更高。</p>\n<p>系统级测试的成本肯定高于模块级测试的成本，例如，每次都需要启动一个 HTTP 服务，在速度上就不可能像本地测试那么快。如果设计做得好，那么 HTTP 接口层只是一层封装，在它之下是一个具有等价的原生编程语言的 API。那么，在开发过程中，能不能以一种低成本的方式运行这些测试呢？</p>\n<p>答案是肯定的。在 Cucumber 的生态下，如果使用的是 Java 编程语言，就可以采用 cucumber-java。如果在需求阶段就已经采用 Feature 文件定义了功能，而现在想直接剥掉 HTTP 接口层进行测试，那么使用 cucumber-java 可以做到对 Feature 文件一字不改，仅调整步骤定义文件，就得到可运行的测试用例。</p>\n<p>下面我们以曾经在 6.4 节用过的表达式问题为例，展示如何使用 Feature 文件和 Java 胶水层代码来完成自动化测试。</p>\n<p>(1) 在项目中增加依赖，以使用 Cucumber 的能力。</p>\n<p>要运行 cucumber-java，需要先让项目中包含 Cucumber 相关的 Java 依赖。根据使用的 Java 版本或者 Cucumber 版本的不同，这个依赖可能不一样。以 cucumber-java（6.10.4）为例，需要增加如下 maven 依赖。<span class=\"comment-number\">3</span></p>\n\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.cucumber&lt;/groupId&gt;\n    &lt;artifactId&gt;cucumber-java&lt;/artifactId&gt;\n    &lt;version&gt;6.10.4&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;</code></pre>\n<p><strong>代码清单 7.4</strong>　增加 cucumber-java 依赖</p>\n<p>(2) 编写 Feature 文件来描述设计契约。</p>\n<p>我们已经在 6.4 节分析过 <code>Expression</code> 的契约，在此继续使用这个例子，展示如何结合 Feature 文件和模块的接口定义，达成使用测试说明契约的目标。</p>\n<p>首先基于 <code>Expression</code> 的契约编写测试。</p>\n<pre class=\"code-rows\"><code>功能: 四则运算\n    场景大纲: 基本四则运算\n        假如表达式是'&lt;输入&gt;'\n        那么结果应该是'&lt;输出&gt;'\n\n        例子:\n        |规则 |输入|输出|\n        |支持加法|2+3|5|\n        |支持减法|2-3|-1|\n        |支持乘法|2*3|6|\n        |支持除法|6/2|3|\n        |遵循四则运算优先级|5*(2+3)|25|\n        |支持多重括号|((2+3)*2+2)*5|60|</code></pre>\n<p><strong>代码清单 7.5</strong>　基于 Cucumber 编写的 <code>Expression</code> 契约测试</p>\n<p>(3) 使用 Cucumber 的 JUnit Runner 运行测试。</p>\n<p>现在我们需要让这个测试可以运行。由于 Cucumber 被设计为一个 JUnit 扩展，所以仅需要编写一个空的 JUnit 测试，然后指明单元测试的 Runner，就可以运行 Feature 文件中的测试了。示例代码如下所示。<span class=\"comment-number\">4</span></p>\n\n<pre class=\"code-rows\"><code>import io.cucumber.junit.Cucumber;\nimport io.cucumber.junit.CucumberOptions;\nimport org.junit.runner.RunWith;\n\n@RunWith(Cucumber.class)\n@CucumberOptions(plugin = {\"pretty\", \"html:target/cucumber\"})\npublic class RunCucumberTest {\n}</code></pre>\n<p><strong>代码清单 7.6</strong>　增加一个测试来运行 Feature 文件中的测试</p>\n<p>到此，尽管我们还没有编写胶水层代码，但是这个测试已经可以运行了，只不过不能运行成功。Cucumber 设计得非常好，它可以直接告诉开发者还缺失哪些胶水层代码，这为胶水层代码的编写提供了相当大的便利。</p>\n<p>(4) 编写步骤定义代码。</p>\n<p>最后我们使用 cucumber-java 来编写步骤定义代码，其中直接调用了 Java 接口。</p>\n<pre class=\"code-rows\"><code>public class ExpressionTestStep {\n    private String expression;\n    @假如(\"^表达式是'(.*)'【美】\")\n    public void toBeEvaluatedIs(String expression) throws Throwable {\n        this.expression = expression;\n    }\n\n    @那么(\"^结果应该是'(.*)'【美】\")\n    public void resultIs(Double result) throws Throwable {\n        Expression e = new StackExpression();\n        assertEquals(result, e.evaluate(expression));\n    }\n}</code></pre>\n<p><strong>代码清单 7.7</strong>　Expression 契约测试的步骤定义代码</p>\n<p>(5) 运行测试。</p>\n<p>假如契约都已经得到了满足，那么运行测试，就可以得到运行成功的结果。</p>\n<pre class=\"code-rows\"><code>【美】 cucumber\n# language: zh-CN\n功能: 四则运算\n… 内容省略 …\n6 scenarios (6 passed)\n12 steps (12 passed)\n0m0.795s</code></pre>\n<p><strong>代码清单 7.8</strong>　Expression 契约测试的执行结果</p>\n<h3 id=\"nav_point_163\">7.4.2　直接使用 JUnit 编写测试，描述设计契约</h3>\n<p>更多时候，我们需要直接在模块级描述接口的契约，或者说，是编写接口级的测试。固然可以使用 Gherkin 语法编写 Feature 文件，但是对于程序员来说，直接使用原生的语言肯定更为便捷。</p>\n<p>在大多数情况下，开发者测试是使用原生语言编写的。代码清单 7.9 就是使用 JUnit5 编写的测试。这是一个数据驱动形式的测试。</p>\n<pre class=\"code-rows\"><code>public class ExpressionTest {\n    @ParameterizedTest(name=\" : should be \")\n    @CsvSource({\n        \"支持加法,2+3,5\",\n        \"支持减法,2−3,−1\",\n        \"支持乘法,2*3,6\",\n        \"支持除法,6/2,3\",\n        \"遵循四则运算优先级,(2+3)*5,25\",\n        \"支持多重括号,((2+3)*2+2)*5,60\"})\n    public void evaluateExpressions(String name, String expr, Double result)\n        throws ExpressionError {\n        Expression expression = new StackExpression();\n        assertEquals(result, expression.evaluate(expr));\n    }\n}</code></pre>\n<p><strong>代码清单 7.9</strong>　使用 JUnit 编写的 <code>Expression</code> 契约测试</p>\n<p>虽然这段代码是 JUnit 测试，但它的可读性仍然很好。其中的 <code>data</code> 声明使用的是非常典型的业务规则 - 示例的形式，表述方式也非常接近自然语言。本书的 10.3 节还将讨论提升测试易读性的技术。</p>\n<p>至此，我们已经介绍了使用 BDD 工具描述的需求、使用 BDD 工具或 JUnit 描述的模块接口。它们产出的结果都是可运行的测试，同时都具有很好的易读性，是需求或者接口描述的精确契约。这种先编写测试再进行实现的方式，就是测试先行。</p>\n<h2 id=\"nav_point_164\">7.5　测试先行</h2>\n<p>从测试后置到测试先行，不仅是测试理念的变迁，更是开发模式的升级。本节将梳理测试先行带来的关键影响及具有的优势。</p>\n<h3 id=\"nav_point_165\">7.5.1　以终为始，聚焦外部行为</h3>\n<p>测试先行改变的不仅是我们看待测试的视角，更是进行开发的方式。这样看来，无论是开发者，还是传统意义上的测试人员，都需要切换思路，重新审视既有的工作方式。</p>\n<p><strong>测试后置已经不适用于现在的场景</strong></p>\n<p>测试后置在历史上有其合理性，但是已经不适用于现在的场景了。</p>\n<ul>\n<li>从目标角度看，在软件发展的历史上，人们首先遇到的问题不是软件的演进问题，而是软件质量不可靠的问题。如何能让交付的软件更可靠，是彼时测试的使命。</li>\n<li>从技术环境角度看，在软件发展早期，由于计算资源的昂贵和测试工具的缺乏，运行自动化测试是一个成本很高的任务。</li>\n</ul>\n<p>现在的软件开发所面临的问题相较之前已经有了巨大变化。</p>\n<ul>\n<li>首先，持续演进成为软件最基本的特征。在这种情况下，保证软件的质量就升级为了始终保证软件的质量。我们不仅要保证当前的版本没有缺陷，还需要保证所有在过去版本中有效的承诺在新版本中仍然有效。也就是说，无论内部实现如何变化，外部行为都需要正确，这就需要自动化测试作为有力的保证。但是，一旦测试后置，有经验的读者都知道，再想让代码具有完备的自动化测试就非常困难了。</li>\n<li>其次，自动化测试的运行不再是一个高成本的任务。相较于高昂的人工成本，运行一次自动化测试几乎是免费的，它随时随地可以运行，只不过如果软件尚未开发完成，那么测试必然会失败。从本质上讲，这种“失败”其实是好消息，因为它明确地告诉我们：还存在某些功能尚未实现。</li>\n</ul>\n<p><strong>自动化测试关心的是外部行为</strong></p>\n<p>自动化测试应该关心外部行为而不是内部实现。这里的“内部”和“外部”是针对所研究的边界说的。外部行为反映的是“契约”，而内部实现仅是“如何实现这些契约”。自动化测试的期望结构如图 7.6 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00361.jpeg\" alt=\"\" width=\"28%\" style=\"width: 28%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 7.6</strong>　自动化测试需要关注外部行为</p>\n<p>图 7.6 清晰地回答了“软件都还没开发出来，怎么可以开始测试呢？”这样的问题。不要把单元测试或模块测试和白盒测试混为一谈。在契约这个层面上，它们都是黑盒测试。在 10.3 节我们还会讨论这个话题。在本章中读者需要注意：如图 7.6 所示，测试先行一定是针对接口进行的。这是一个关键认知，也是测试先行的基础。</p>\n<p><strong>单元测试是开发人员的任务</strong></p>\n<p>用测试来描述接口契约，意味着测试本身已经是一个设计活动而不是质量保证活动。在有些团队中，会假定开发人员和测试人员是不同的角色，这种认知是不对的。</p>\n<p>无论在过去、现在还是未来，单元测试都是开发人员的职责，无论是否有专职的测试团队，都不应该把单元测试交给测试团队去完成。这是因为：单元测试是一个设计活动，保证每个设计单元都能正常工作本来就是开发人员工作的一部分。同时，设计的变化是非常频繁的。假定单元测试时使用的用例也让测试人员编写，那测试人员就会被迫参与到一个频繁变化的设计契约中，不但成本高昂，效果也不会好。</p>\n<p><strong>测试人员的角色和任务都已经发生变化</strong></p>\n<p>单元测试是开发人员的任务，对于更细的测试粒度而言，测试人员扮演的角色也发生了变化。在人们的传统印象中，测试人员类似于质检员，其核心使命是保证产出的软件符合要求、没有缺陷。而现在，即使仍然存在专职的测试人员，其核心使命也已经变成“打造质量保证工具和设施”，不再局限于发现问题这一点。这种角色转变，让软件在演进过程中持续获得质量保证。</p>\n<blockquote>\n<p>测试人员不再是质检员，而是质量保证工具和设施的打造者。</p>\n</blockquote>\n<p>正因如此，测试人员在项目早期参与需求分析与评审活动就变得更有必要，也更有动力了。以往，即使在项目早期邀请测试人员参与这些活动，测试人员也很难进入状态。但是现在，由于核心使命已经不同，所以测试人员更在意“如何防范问题发生”，而不是“如何检测出错误”，也就更容易进入状态了。</p>\n<p>测试先行对测试人员的角色提出了新的技能要求。设计测试用例的技能固然重要，但编写自动化测试代码是一项基本技能。由于技能要求的高度重叠，测试人员和开发人员的角色正在融合，甚至有些公司已经不再保留大规模的专职测试团队。这种融合是双向的，不仅要求测试人员掌握足够的编程技能，也要求开发人员具备更多的测试思维。</p>\n<h3 id=\"nav_point_166\">7.5.2　测试先行的优势</h3>\n<p>测试先行带来了一系列优势，下面我们分析其中几个。</p>\n<p><strong>使契约显式化</strong></p>\n<p>契约显式化是测试先行的本质，在测试先行的前提下，测试的本质不是质量保证，而是定义契约。</p>\n<blockquote>\n<p>测试先行，把测试活动从“发现错误”转变为了“制定标准”。</p>\n</blockquote>\n<p>代码形式的契约解决了自然语言会引起歧义的问题。使用自然语言描述需求或者设计接口，很容易出现歧义，使用代码形式的契约则不会——代码比抽象的语言更具体，而且不会“说谎”。</p>\n<p>从“发现错误”到“制定标准”，是一个重要的思维方式转换过程。一旦完成了这种转换，测试场景就从“代码完成了吗？让我来测试一下。”变成了“这是实现的标准，如果你的代码完成了，可以用它来检验。”。“标准”是一种契约，是对开发人员应该如何实现代码制定的具体化要求。将定义契约和最终检验质量的活动合二为一，是 I 模型的精髓所在。</p>\n<p><strong>把自动化测试作为活文档</strong></p>\n<p>软件具有持续演进的特征。正因如此，即便付出相当多的努力，也很难保证及时更新和同步传统的需求文档和设计文档，导致它们最终失去参考的权威性。曾经花费大力气建立的文档，经过若干次版本迭代后，由于信息不再准确，而逐渐被后来的维护者和阅读者抛弃。此时代码成为唯一可信的信息来源，于是一种不那么正常却很常见的现象产生了：需求相关的人员说不清系统的当前行为，测试人员基于开发人员的理解设计测试。</p>\n<p>及时更新设计文档是非常重要的。只有让文档和代码建立关联，才能保证让文档得到持续更新。由于 BDD 框架、高质量的单元测试框架等大幅提升了测试代码的易读性，所以用测试代码作为文档成为了可能。自动化测试代码也是代码，因此很容易持续更新，避免了传统的孤立文档会过时的问题。我们也常常把这类可以持续更新的需求文档或契约说明文档叫作活文档。</p>\n<p><strong>使自动化测试成为接口使用说明</strong></p>\n<p>在测试先行的前提下，自动化测试聚焦于外部契约，它本质上就是在模拟使用方的使用场景。所以，站在使用方的角度，这样的测试集能带来许多便利。例如，你一时想不起来一个接口应该如何调用、调用后的期望结果应该是什么、使用它时有哪些规则和约束等，就可以从对应的测试代码中获得相应信息。</p>\n<p>在高质量的项目中，这样的测试代码比比皆是。我们已经在代码清单 2.19 中见过高质量的测试示例，下面再看几个例子。这些代码节选自开源项目 OkHttp。<span class=\"comment-number\">5</span> OkHttp 是一个基于 Java 语言的 HTTP 的客户端，如果我们想使用 OkHttp 的能力发送一个异步的 HTTP 请求，应该如何做呢？OkHttp 自带的测试代码已经给出了一个清晰的示例。</p>\n\n<pre class=\"code-rows\"><code>public final class CallTest {\n    private OkHttpClient client;\n    private MockServer server;\n    private RecordingCallback callback = new RecordingCallback();\n\n    // 部分代码略\n    @Test public void get_Async() throws Exception {\n        server.enqueue(new MockResponse()\n              .setBody(\"abc\")\n              .addHeader(\"Content-Type: text/plain\"));\n\n        Request request = new Request.Builder()\n                .url(server.url(\"/\"))\n                .header(\"User-Agent\", \"AsyncApiTest\")\n                .build();\n        client.newCall(request).enqueue(callback);\n\n        callback.await(request.url())\n                .assertCode(200)\n                .assertHeader(\"Content-Type\", \"text/plain\")\n                .assertBody(\"abc\");\n\n        assertEquals(\"AsyncApiTest\", server.takeRequest().getHeader(\"User-Agent\"));\n    }\n}</code></pre>\n<p><strong>代码清单 7.10</strong>　把测试代码作为接口使用说明</p>\n<p>这段代码中最重要的信息是第 12 行至第 16 行。这部分展示了如何构造一个 HTTP 请求，并通过 <code>OkHttpClient</code> 实例发出该请求。其中，异步回调方法应该写在 <code>callback</code> 实例中。通过查看 <code>RecordingCallback</code> 类的定义，我们可以知道它是 <code>Callback</code> 接口的一个实现。</p>\n<p>上面展示的是一种流程性的契约说明。下面我们再来看一段业务规则类型的契约说明。这段测试代码把琐碎的业务规则以测试用例的形式做了明确呈现。</p>\n<pre class=\"code-rows\"><code>public class HttpDateParseNoStandardStringTest {\n    @Test\n    public void ignoreExtraStringAfterTimeZone() {\n        assertEquals(0L,HttpDate.parse(\"Thu, 01 Jan 1970 00:00:00 GMT JUNK\").getTime());\n    }\n\n    @Test\n    public void isInvalidIfWithoutTimeZone() {\n        assertNull(HttpDate.parse(\"Thu, 01 Jan 1970 00:00:00\"));\n    }\n    @Test\n    public void isInvalidIfWithoutSecond() {\n        assertNull(HttpDate.parse(\"Thu, 01 Jan 1970 00:00 GMT\"));\n    }\n    @Test\n    public void isInvalidIfWithExtraSpace() {\n        assertNull(HttpDate.parse(\"Thu,  01 Jan 1970 00:00 GMT\"));\n    }\n    @Test\n    public void isInvalidIfDateOnlyOneDigit() {\n        assertNull(HttpDate.parse(\"Thu, 1 Jan 1970 00:00 GMT\"));\n    }\n}</code></pre>\n<p><strong>代码清单 7.11</strong>　用测试用例来说明琐碎的业务规则</p>\n<p><code>HttpDate</code> 是一个类，它提供了一个 <code>parse</code> 方法，能将字符串解析为一个日期。但是，<code>HttpDate</code> 对格式的要求是比较严格的，要明确哪些格式的字符串可以解析，哪些不可以。查看上面的测试代码，很容易得到答案：字符串必须包含时区信息，必须包含秒，不能有多余的空格，日期数字必须是两位，等等。</p>\n<p>一旦接口的使用方式以测试代码的形式沉淀下来，在将来使用接口时，就很容易找到现成的示范，这很好地提升了接口的可理解性。</p>\n<p><strong>能够及时反馈接口质量</strong></p>\n<p>使用测试代码来说明接口的使用方式，也是在实现接口之前对用户将会如何使用接口做的一种模拟。如果在这时发现接口的使用方式不当，就可以灵活调整。相反，如果接口都实现完毕了再来写测试代码，那么即使发现接口使用起来不是那么方便，也不太愿意做调整了，毕竟实现代码都已经写完了，再调整需要付出更大的代价。</p>\n<p>提前编写自动化测试，可以挖掘出很多原本容易忽略的细节。以前述的 <code>Expression</code> 接口为例，有下面这些细节。</p>\n<ul>\n<li>名字合适吗？</li>\n<li>参数和返回值合理吗？</li>\n<li>异常情况的定义和抛出形式合理吗？</li>\n</ul>\n<p>在测试先行的模式下，测试代码模拟了调用方的角色，从而使反馈来得更早。如果接口存在不合理之处，那么在编写测试代码的时候就可以发现，这时候产品代码还没有开始编写，调整接口定义的成本几乎为零。</p>\n<p>假如没有测试先行，那么接口的定义往往要到和调用方集成时才能得到检验，这时检验出问题的话，影响就比较大。所以，在缺少测试先行的情况下，需求澄清和接口定义的检验都具有严重的滞后性。</p>\n<p><strong>缩短质量反馈周期，对抗缺陷成本递增</strong></p>\n<p>在 1.2 节，我们介绍了缺陷成本递增曲线。图 1.2 表明，缺陷造成的成本，取决于从注入缺陷到发现缺陷的时间。通过测试先行，把 V 模型升级为 I 模型，可以在最大程度上加快反馈，减轻缺陷造成的影响。</p>\n<p>由于测试先行，测试代码的编写时间会早于产品代码的编写时间，因此随时随地都可以运行测试代码，最小化了错误的发现时间。并且，自动化测试代码的存在取代了手工测试。只要运行自动化测试代码，无论是测试代码本身存在的错误，还是产品实现代码中的错误，都能很快被发现并予以修复。</p>\n<p>测试先行还有一个非常有趣的心理因素。一般来说，一旦产品代码编写完毕，程序员从心理上就会觉得“工作已经完成了”，此时编写测试代码往往被视作一种“负担”，动力自然不那么足。但是，提前编写自动化测试代码，更像是给自己准备一个用来检验代码编写得是否正确的工具，这看起来要有吸引力得多。</p>\n<h2 id=\"nav_point_167\">7.6　小结</h2>\n<p>本章聚焦于测试先行的开发范式。测试先行的本质是契约先行。在业务越来越复杂、协作越来越复杂的时代，清晰的接口和设计契约是高质量软件设计的关键。用测试来描述契约，消除了契约的模糊性，有助于更好地达成共识，为软件实现创造一个良好的开始。</p>\n<p>本章介绍了两个层次上的测试先行的实现：使用 BDD 工具达成系统级的测试先行，使用 BDD 工具或单元测试工具达成模块级的测试先行。</p>\n<p>当然，尽管测试先行带来了更好的质量保证，但并不意味着测试先行能完全代替所有的经典测试。完整的质量保证活动覆盖一个更大的范围，如可用性测试、易用性测试、稳定性测试、兼容性测试等都是测试先行不能代替的。在理解测试先行时，虽然质量是一个重要的出发点，但本质还是应该归结到设计契约的明确化上。</p>\n<p>图 7.7 给出了本章的核心内容。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00362.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 7.7</strong>　测试先行：用测试描述需求和契约</p>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 6 章 依赖、接口和契约","id":740975},"right":{"article_title":"第 8 章 用领域模型指导实现(1)","id":740977}},"comments":[]}