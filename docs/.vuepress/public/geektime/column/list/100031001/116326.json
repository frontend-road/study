{"id":116326,"title":"19 | 用户交互事件该如何响应？","content":"<p>你好，我是陈航。今天，我和你分享的主题是，如何响应用户交互事件。</p><p>在前面两篇文章中，我和你一起学习了Flutter依赖的包管理机制。在Flutter中，包是包含了外部依赖的功能抽象。对于资源和工程代码依赖，我们采用包配置文件pubspec.yaml进行统一管理。</p><p>通过前面几个章节的学习，我们已经掌握了如何在Flutter中通过内部实现和外部依赖去实现自定义UI，完善业务逻辑。但除了按钮和ListView这些动态的组件之外，我们还无法响应用户交互行为。那今天的分享中，我就着重与你讲述Flutter是如何监听和响应用户的手势操作的。</p><p>手势操作在Flutter中分为两类：</p><ul>\n<li>第一类是原始的指针事件（Pointer Event），即原生开发中常见的触摸事件，表示屏幕上触摸（或鼠标、手写笔）行为触发的位移行为；</li>\n<li>第二类则是手势识别（Gesture Detector），表示多个原始指针事件的组合操作，如点击、双击、长按等，是指针事件的语义化封装。</li>\n</ul><p>接下来，我们先看一下原始的指针事件。</p><h2>指针事件</h2><p>指针事件表示用户交互的原始触摸数据，如手指接触屏幕PointerDownEvent、手指在屏幕上移动PointerMoveEvent、手指抬起PointerUpEvent，以及触摸取消PointerCancelEvent，这与原生系统的底层触摸事件抽象是一致的。</p><!-- [[[read_end]]] --><p>在手指接触屏幕，触摸事件发起时，Flutter会确定手指与屏幕发生接触的位置上究竟有哪些组件，并将触摸事件交给最内层的组件去响应。与浏览器中的事件冒泡机制类似，事件会从这个最内层的组件开始，沿着组件树向根节点向上冒泡分发。</p><p>不过Flutter无法像浏览器冒泡那样取消或者停止事件进一步分发，我们只能通过hitTestBehavior去调整组件在命中测试期内应该如何表现，比如把触摸事件交给子组件，或者交给其视图层级之下的组件去响应。</p><p>关于组件层面的原始指针事件的监听，Flutter提供了Listener Widget，可以监听其子Widget的原始指针事件。</p><p>现在，我们一起看一个Listener的案例。我定义了一个宽度为300的红色正方形Container，利用Listener监听其内部Down、Move及Up事件：</p><pre><code>Listener(\n  child: Container(\n    color: Colors.red,//背景色红色\n    width: 300,\n    height: 300,\n  ),\n  onPointerDown: (event) =&gt; print(&quot;down $event&quot;),//手势按下回调\n  onPointerMove:  (event) =&gt; print(&quot;move $event&quot;),//手势移动回调\n  onPointerUp:  (event) =&gt; print(&quot;up $event&quot;),//手势抬起回调\n);\n</code></pre><p>我们试着在红色正方形区域内进行触摸点击、移动、抬起，可以看到Listener监听到了一系列原始指针事件，并打印出了这些事件的位置信息：</p><pre><code>I/flutter (13829): up PointerUpEvent(Offset(97.7, 287.7))\nI/flutter (13829): down PointerDownEvent(Offset(150.8, 313.4))\nI/flutter (13829): move PointerMoveEvent(Offset(152.0, 313.4))\nI/flutter (13829): move PointerMoveEvent(Offset(154.6, 313.4))\nI/flutter (13829): up PointerUpEvent(Offset(157.1, 312.3))\n</code></pre><h2>手势识别</h2><p>使用Listener可以直接监听指针事件。不过指针事件毕竟太原始了，如果我们想要获取更多的触摸事件细节，比如判断用户是否正在拖拽控件，直接使用指针事件的话就会非常复杂。</p><p>通常情况下，响应用户交互行为的话，我们会使用封装了手势语义操作的Gesture，如点击onTap、双击onDoubleTap、长按onLongPress、拖拽onPanUpdate、缩放onScaleUpdate等。另外，Gesture可以支持同时分发多个手势交互行为，意味着我们可以通过Gesture同时监听多个事件。</p><p><strong>Gesture是手势语义的抽象，而如果我们想从组件层监听手势，则需要使用GestureDetector</strong>。GestureDetector是一个处理各种高级用户触摸行为的Widget，与Listener一样，也是一个功能性组件。</p><p>接下来，我们通过一个案例来看看GestureDetector的用法。</p><p>我定义了一个Stack层叠布局，使用Positioned组件将1个红色的Container放置在左上角，并同时监听点击、双击、长按和拖拽事件。在拖拽事件的回调方法中，我们更新了Container的位置：</p><pre><code>//红色container坐标\ndouble _top = 0.0;\ndouble _left = 0.0;\nStack(//使用Stack组件去叠加视图，便于直接控制视图坐标\n  children: &lt;Widget&gt;[\n    Positioned(\n      top: _top,\n      left: _left,\n      child: GestureDetector(//手势识别\n        child: Container(color: Colors.red,width: 50,height: 50),//红色子视图\n        onTap: ()=&gt;print(&quot;Tap&quot;),//点击回调\n        onDoubleTap: ()=&gt;print(&quot;Double Tap&quot;),//双击回调\n        onLongPress: ()=&gt;print(&quot;Long Press&quot;),//长按回调\n        onPanUpdate: (e) {//拖动回调\n          setState(() {\n            //更新位置\n            _left += e.delta.dx;\n            _top += e.delta.dy;\n          });\n        },\n      ),\n    )\n  ],\n);\n</code></pre><p>运行这段代码，并查看控制台输出，可以看到，红色的Container除了可以响应我们的拖拽行为外，还能够同时响应点击、双击、长按这些事件。</p><p><img src=\"https://static001.geekbang.org/resource/image/b8/4e/b8c4fa6e898ef154afc217d5ebf0b54e.gif?wh=680*1416\" alt=\"\"></p><center><span class=\"reference\">图1 GestureDetector示例</span></center><p>尽管在上面的例子中，我们对一个Widget同时监听了多个手势事件，但最终只会有一个手势能够得到本次事件的处理权。对于多个手势的识别，Flutter引入了<strong>手势竞技场（Arena）</strong>的概念，用来识别究竟哪个手势可以响应用户事件。手势竞技场会考虑用户触摸屏幕的时长、位移以及拖动方向，来确定最终手势。</p><p><strong>那手势竞技场具体是怎么实现的呢？</strong></p><p>实际上，GestureDetector内部对每一个手势都建立了一个工厂类（Gesture Factory）。而工厂类的内部会使用手势识别类（GestureRecognizer），来确定当前处理的手势。</p><p>而所有手势的工厂类都会被交给RawGestureDetector类，以完成监测手势的大量工作：使用Listener监听原始指针事件，并在状态改变时把信息同步给所有的手势识别器，然后这些手势会在竞技场决定最后由谁来响应用户事件。</p><p>有些时候我们可能会在应用中给多个视图注册同类型的手势监听器，比如微博的信息流列表中的微博，点击不同区域会有不同的响应：点击头像会进入用户个人主页，点击图片会进入查看大图页面，点击其他部分会进入微博详情页等。</p><p>像这样的手势识别发生在多个存在父子关系的视图时，手势竞技场会一并检查父视图和子视图的手势，并且通常最终会确认由子视图来响应事件。而这也是合乎常理的：从视觉效果上看，子视图的视图层级位于父视图之上，相当于对其进行了遮挡，因此从事件处理上看，子视图自然是事件响应的第一责任人。</p><p>在下面的示例中，我定义了两个嵌套的Container容器，分别加入了点击识别事件：</p><pre><code>GestureDetector(\n  onTap: () =&gt; print('Parent tapped'),//父视图的点击回调\n  child: Container(\n    color: Colors.pinkAccent,\n    child: Center(\n      child: GestureDetector(\n        onTap: () =&gt; print('Child tapped'),//子视图的点击回调\n        child: Container(\n          color: Colors.blueAccent,\n          width: 200.0,\n          height: 200.0,\n        ),\n      ),\n    ),\n  ),\n);\n</code></pre><p>运行这段代码，然后在蓝色区域进行点击，可以发现：尽管父容器也监听了点击事件，但Flutter只响应了子容器的点击事件。</p><pre><code>I/flutter (16188): Child tapped\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/8e/da/8e99c7bbc5d0b52b3ba80263f989e7da.png?wh=1440*2560\" alt=\"\"></p><center><span class=\"reference\">图2 父子嵌套GestureDetector示例</span></center><p>为了让父容器也能接收到手势，我们需要同时使用RawGestureDetector和GestureFactory，来改变竞技场决定由谁来响应用户事件的结果。</p><p>在此之前，<strong>我们还需要自定义一个手势识别器</strong>，让这个识别器在竞技场被PK失败时，能够再把自己重新添加回来，以便接下来还能继续去响应用户事件。</p><p>在下面的代码中，我定义了一个继承自点击手势识别器TapGestureRecognizer的类，并重写了其rejectGesture方法，手动地把自己又复活了：</p><pre><code>class MultipleTapGestureRecognizer extends TapGestureRecognizer {\n  @override\n  void rejectGesture(int pointer) {\n    acceptGesture(pointer);\n  }\n}\n</code></pre><p>接下来，我们需要将手势识别器和其工厂类传递给RawGestureDetector，以便用户产生手势交互事件时能够立刻找到对应的识别方法。事实上，RawGestureDetector的初始化函数所做的配置工作，就是定义不同手势识别器和其工厂类的映射关系。</p><p>这里，由于我们只需要处理点击事件，所以只配置一个识别器即可。工厂类的初始化采用GestureRecognizerFactoryWithHandlers函数完成，这个函数提供了手势识别对象创建，以及对应的初始化入口。</p><p>在下面的代码中，我们完成了自定义手势识别器的创建，并设置了点击事件回调方法。需要注意的是，由于我们只需要在父容器监听子容器的点击事件，所以只需要将父容器用RawGestureDetector包装起来就可以了，而子容器保持不变：</p><pre><code>RawGestureDetector(//自己构造父Widget的手势识别映射关系\n  gestures: {\n    //建立多手势识别器与手势识别工厂类的映射关系，从而返回可以响应该手势的recognizer\n    MultipleTapGestureRecognizer: GestureRecognizerFactoryWithHandlers&lt;\n        MultipleTapGestureRecognizer&gt;(\n          () =&gt; MultipleTapGestureRecognizer(),\n          (MultipleTapGestureRecognizer instance) {\n        instance.onTap = () =&gt; print('parent tapped ');//点击回调\n      },\n    )\n  },\n  child: Container(\n    color: Colors.pinkAccent,\n    child: Center(\n      child: GestureDetector(//子视图可以继续使用GestureDetector\n        onTap: () =&gt; print('Child tapped'),\n        child: Container(...),\n      ),\n    ),\n  ),\n);\n</code></pre><p>运行一下这段代码，我们可以看到，当点击蓝色容器时，其父容器也收到了Tap事件。</p><pre><code>I/flutter (16188): Child tapped\nI/flutter (16188): parent tapped \n</code></pre><h2>总结</h2><p>好了，今天的分享就到这里。我们来简单回顾下Flutter是如何响应用户事件的。</p><p>首先，我们了解了Flutter底层原始指针事件，以及对应的监听方式和冒泡分发机制。</p><p>然后，我们学习了封装了底层指针事件手势语义的Gesture，了解了多个手势的识别方法，以及其同时支持多个手势交互的能力。</p><p>最后，我与你介绍了Gesture的事件处理机制：在Flutter中，尽管我们可以对一个Widget监听多个手势，或是对多个Widget监听同一个手势，但Flutter会使用手势竞技场来进行各个手势的PK，以保证最终只会有一个手势能够响应用户行为。如果我们希望同时能有多个手势去响应用户行为，需要去自定义手势，利用RawGestureDetector和手势工厂类，在竞技场PK失败时，手动把它复活。</p><p>在处理多个手势识别场景，很容易出现手势冲突的问题。比如，当需要对图片进行点击、长按、旋转、缩放、拖动等操作的时候，如何识别用户当前是点击还是长按，是旋转还是缩放。如果想要精确地处理复杂交互手势，我们势必需要介入手势识别过程，解决异常。</p><p>不过需要注意的是，冲突的只是手势的语义化识别过程，原始指针事件是不会冲突的。所以，在遇到复杂的冲突场景通过手势很难搞定时，我们也可以通过Listener直接识别原始指针事件，从而解决手势识别的冲突。</p><p>我把今天分享所涉及到的<a href=\"https://github.com/cyndibaby905/19_gesture_demo\">事件处理demo</a>放到了GitHub上，你可以下载下来自己运行，进一步巩固学习效果。</p><h2>思考题</h2><p>最后，我给你留下两个思考题吧。</p><ol>\n<li>对于一个父容器中存在按钮FlatButton的界面，在父容器使用GestureDetector监听了onTap事件的情况下，如果我们点击按钮，父容器的点击事件会被识别吗，为什么？</li>\n<li>如果监听的是onDoubleTap事件，在按钮上双击，父容器的双击事件会被识别吗，为什么？</li>\n</ol><p>欢迎你在评论区给我留言分享你的观点，我会在下一篇文章中等待你！感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p><p></p>","comments":[{"had_liked":false,"id":122505,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1565409365,"is_pvip":false,"replies":[{"id":"45242","content":"赞","user_name":"作者回复","user_name_real":"土豆盒子","uid":"1088582","ctime":1565627060,"ip_address":"","comment_id":122505,"utype":1}],"discussion_count":2,"race_medal":0,"score":"156184232021","product_id":100031001,"comment_content":"对于一个父容器中存在按钮 FlatButton 的界面，在父容器使用 GestureDetector 监听了 onTap 事件的情况下，如果我们点击按钮，父容器的点击事件会被识别吗，为什么？<br>不会被识别，因为按钮有默认的点击监听事件，监听到点击事件后，不会再向上冒泡。<br><br>如果监听的是 onDoubleTap 事件，在按钮上双击，父容器的双击事件会被识别吗，为什么？<br>会被识别，因为按钮没有默认的双击监听事件。","like_count":37,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462280,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565627060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1180727,"avatar":"https://static001.geekbang.org/account/avatar/00/12/04/37/aa04f997.jpg","nickname":"和小胖","note":"","ucode":"406BD7AB987EBF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8538,"discussion_content":"这位大佬每次都给标准答案，点赞。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568015895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123212,"user_name":"竹之同学","can_delete":false,"product_type":"c1","uid":1426358,"ip_address":"","ucode":"00A322BE03D348","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLBKSykSmNnspVs5OvAUGLecibeiczo7sQYJ4XoJXNa2jWUwvwiaHz8yM3iak0ErUSUIJrGfzNUJ7P79Rg/132","comment_is_top":false,"comment_ctime":1565626733,"is_pvip":false,"replies":[{"id":"45290","content":"注意，冒泡是指原始的指针事件，手势竞技场是针对封装后的高级手势识别","user_name":"作者回复","user_name_real":"土豆盒子","uid":"1088582","ctime":1565676074,"ip_address":"","comment_id":123212,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18745495917","product_id":100031001,"comment_content":"前面说到指针事件有类似于浏览器一样的冒泡机制，事件会从这个最内层的组件开始，沿着组件树向根节点向上冒泡；后面又说到如果父子 widget 都用 GestureDetector 监听了同样的事件的话，只会用竞技场去响应一个，这两者是不是矛盾的？","like_count":5,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462583,"discussion_content":"注意，冒泡是指原始的指针事件，手势竞技场是针对封装后的高级手势识别","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565676074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1795371,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/65/2b/446ef7b6.jpg","nickname":"许先森","note":"","ucode":"1F42D4A6B5C6AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308678,"discussion_content":"指针事件和手势不是一个东西，手势是对指针事件有规则和算法的抽象封装，不是同一个东西自然可以有不同的规则，并不矛盾","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601027943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152702,"user_name":"菜头","can_delete":false,"product_type":"c1","uid":1456964,"ip_address":"","ucode":"C5E95519F9EA21","user_header":"https://static001.geekbang.org/account/avatar/00/16/3b/44/dd534c9b.jpg","comment_is_top":false,"comment_ctime":1574066351,"is_pvip":false,"replies":[{"id":"58776","content":"试试ScaleGestureRecognizer","user_name":"作者回复","user_name_real":"土豆盒子","uid":"1088582","ctime":1574133128,"ip_address":"","comment_id":152702,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5869033647","product_id":100031001,"comment_content":"API 没有找到 RotateGestureRecognizer<br>","like_count":1,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474904,"discussion_content":"试试ScaleGestureRecognizer","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574133128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122661,"user_name":"神经蛙","can_delete":false,"product_type":"c1","uid":1604240,"ip_address":"","ucode":"0511F6E6B30440","user_header":"https://static001.geekbang.org/account/avatar/00/18/7a/90/dc3537e7.jpg","comment_is_top":false,"comment_ctime":1565460355,"is_pvip":false,"replies":[{"id":"45239","content":"会根据用户交互的位置、加速度、方向等因子综合判断当前需要以哪个手势去响应，这是确定的；不确定的是如果你的交互存在二义性，而你需要识别的多个手势之间又非常相似（比如旋转和缩放），则最后到底哪个手势去响应需要综合PK一下。","user_name":"作者回复","user_name_real":"土豆盒子","uid":"1088582","ctime":1565626916,"ip_address":"","comment_id":122661,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5860427651","product_id":100031001,"comment_content":"“使用 Listener 监听原始指针事件，并在状态改变时把信息同步给所有的手势识别器，然后这些首饰会在竞技场决定最后哪个手势来响应用户事件”<br>这句话意思是不是说明，处理多个手势时，响应用户事件的手势具有不确定性，最后到底哪个手势会相应无法估测？","like_count":2,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462350,"discussion_content":"会根据用户交互的位置、加速度、方向等因子综合判断当前需要以哪个手势去响应，这是确定的；不确定的是如果你的交互存在二义性，而你需要识别的多个手势之间又非常相似（比如旋转和缩放），则最后到底哪个手势去响应需要综合PK一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565626916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":302862,"user_name":"季申","can_delete":false,"product_type":"c1","uid":2568642,"ip_address":"","ucode":"679966B9B6B9E5","user_header":"https://static001.geekbang.org/account/avatar/00/27/31/c2/7771e0e9.jpg","comment_is_top":false,"comment_ctime":1626413866,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626413866","product_id":100031001,"comment_content":"本来挺帅挺阳光的年轻人，这头像的照片拍出了50岁装嫩大叔的感觉，老气横秋啊","like_count":0},{"had_liked":false,"id":263262,"user_name":"Zsc","can_delete":false,"product_type":"c1","uid":1121216,"ip_address":"","ucode":"6F22DE27B7BEBA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/wibYwE23Fa0OZCatU1zrahbY3oxR6v18UJDWeKNhqKAdPyKVUWnj4dPrMicZdlichUwMiaG4UvcOVwhWmichwSSStXA/132","comment_is_top":false,"comment_ctime":1606063666,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606063666","product_id":100031001,"comment_content":"老师，比如左滑子widget处理，右滑子widget不处理，由父widget处理，这个有什么指点吗","like_count":0},{"had_liked":false,"id":197557,"user_name":"Summer","can_delete":false,"product_type":"c1","uid":1256923,"ip_address":"","ucode":"6E51D5574C1EFD","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKkeBKshjwVKcpVTs1kGkPibsD5j8odoY6oHrMU1EHqDVjHoLLqzknOd8Q0aWxTDCJjvK1NJIX5Ncg/132","comment_is_top":false,"comment_ctime":1585385099,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585385099","product_id":100031001,"comment_content":"与浏览器中的事件冒泡机制类似，事件会从这个最内层的组件开始，沿着组件树向根节点向上冒泡分发。<br><br>不过 Flutter 无法像浏览器冒泡那样取消或者停止事件进一步分发，我们只能通过 hitTestBehavior 去调整组件在命中测试期内应该如何表现，比如把触摸事件交给子组件，或者交给其视图层级之下的组件去响应。<br>这两段话有点疑问，上段话讲到事件会从最内层的组件开始，下一段话又说可以把触摸事件交给子组件开始，是不是有矛盾？","like_count":0},{"had_liked":false,"id":190952,"user_name":"鸡蛋石头","can_delete":false,"product_type":"c1","uid":1229450,"ip_address":"","ucode":"61801769E485C8","user_header":"https://static001.geekbang.org/account/avatar/00/12/c2/8a/aed13671.jpg","comment_is_top":false,"comment_ctime":1584712693,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1584712693","product_id":100031001,"comment_content":"点击后如果不只是print这样的一行代码，而是多行代码，如何处理？","like_count":0,"discussions":[{"author":{"id":1795371,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/65/2b/446ef7b6.jpg","nickname":"许先森","note":"","ucode":"1F42D4A6B5C6AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308677,"discussion_content":"()=> 改成（）{}就行了   多行就用大括号","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601027758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147586,"user_name":"zzz","can_delete":false,"product_type":"c1","uid":1041455,"ip_address":"","ucode":"352964E5D793DA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e4/2f/fb01f76d.jpg","comment_is_top":false,"comment_ctime":1572871601,"is_pvip":false,"replies":[{"id":"57146","content":"用原始指针事件监听就可以了，设定手势判定规则","user_name":"作者回复","user_name_real":"土豆盒子","uid":"1088582","ctime":1573010878,"ip_address":"","comment_id":147586,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572871601","product_id":100031001,"comment_content":"请问下 如何添加自定义的手势 比如连续点击三次？","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473267,"discussion_content":"用原始指针事件监听就可以了，设定手势判定规则","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573010878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141669,"user_name":"浣熊特工队","can_delete":false,"product_type":"c1","uid":1600719,"ip_address":"","ucode":"0EF7CB66397647","user_header":"https://static001.geekbang.org/account/avatar/00/18/6c/cf/baa4ee4d.jpg","comment_is_top":false,"comment_ctime":1571209769,"is_pvip":false,"replies":[{"id":"57702","content":"看一下是不是手势有冲突","user_name":"作者回复","user_name_real":"土豆盒子","uid":"1088582","ctime":1573446565,"ip_address":"","comment_id":141669,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1571209769","product_id":100031001,"comment_content":"老师，我把ListView、ExpansionTile两个结合起来用发现一个bug不知道什么原因造成的：在滑动列表的时候，展开的ExpansionTile都被折叠起来了，请问怎么解决这个问题啊。。","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470841,"discussion_content":"看一下是不是手势有冲突","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573446565,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1360093,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLEIsgI4ub1VOKWtVOfouAzSqx8Yt8ibQEsAnwNJsJHmuJzzpQqG79HullvYwpic8hgiclgON2GwXSjw/132","nickname":"cv0cv0","note":"","ucode":"93FF9277F03FD0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":92905,"discussion_content":"在 model 中保存一下折叠状态。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576893336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128876,"user_name":"Zxt","can_delete":false,"product_type":"c1","uid":1623736,"ip_address":"","ucode":"F5AE69082E8324","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqJV94SB9GY6ErM23QZ3jbYY7eIqbhoWHIMR2uusibj2Jib0CvAj64MLibkjwcCN6tOdgfW6dfNPpuhw/132","comment_is_top":false,"comment_ctime":1566979304,"is_pvip":false,"replies":[{"id":"47878","content":"通过让父子Widget共享controller机制实现","user_name":"作者回复","user_name_real":"土豆盒子","uid":"1088582","ctime":1566993285,"ip_address":"","comment_id":128876,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1566979304","product_id":100031001,"comment_content":"请教下，如何在子wiget中向父(owner) wiget传递参数，调用方法，好比代理模式。 例如： 父wiget在build方法里在Container的child中构造了一个继承自statefulwiget的子wiget，我如何在子wiget类里调用onwer类中的方法？","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465150,"discussion_content":"通过让父子Widget共享controller机制实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566993285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1623736,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqJV94SB9GY6ErM23QZ3jbYY7eIqbhoWHIMR2uusibj2Jib0CvAj64MLibkjwcCN6tOdgfW6dfNPpuhw/132","nickname":"Zxt","note":"","ucode":"F5AE69082E8324","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6637,"discussion_content":"请问这是否是20讲所说的跨组件传递","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567004601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}