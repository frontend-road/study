{"id":740946,"title":"4.1 无向图","content":"\n<p>在我们首先要学习的这种图模型中，<strong>边</strong>（edge）仅仅是两个<strong>顶点</strong>（vertex）之间的连接。为了和其他图模型相区别，我们将它称为<strong>无向图</strong>。这是一种最简单的图模型，我们先来看一下它的定义。</p>\n<blockquote>\n<p><strong>定义</strong>。图是由一组顶点和一组能够将两个顶点相连的边组成的。</p>\n</blockquote>\n<p>就定义而言，顶点叫什么名字并不重要，但我们需要一个方法来指代这些顶点。一般使用 0 至 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01468.gif\" alt=\"V-1\" inline-img=\"true\" /> 来表示一张含有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 个顶点的图中的各个顶点。这样约定是为了方便使用数组的索引来编写能够高效访问各个顶点中信息的代码。用一张符号表来为顶点的名字和 0 到 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01468.gif\" alt=\"V-1\" inline-img=\"true\" /> 的整数值建立一一对应的关系并不困难（请见 4.1.7 节），因此直接使用数组索引作为结点的名称更方便且不失一般性（也不会损失什么效率）。我们用 <code>v-w</code> 的记法来表示连接 <code>v</code> 和 <code>w</code> 的边，<code>w-v</code> 是这条边的另一种表示方法。</p>\n<p>在绘制一幅图时，用圆圈表示顶点，用连接两个顶点的线段表示边，这样就能直观地看出图的结构。但这种直觉有时也可能会误导我们，因为图的定义和绘出的图像是无关的。例如，图 4.1.1 中的两组图表示的是同一幅图，因为图的构成只有（无序的）顶点和边（顶点对）。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01470.gif\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.1.1　同一幅图的两种表示</strong></p>\n<p><strong>特殊的图</strong>。我们的定义允许出现两种简单而特殊的情况，参见图 4.1.2：</p>\n<ul>\n<li><strong>自环</strong>，即一条连接一个顶点和其自身的边；</li>\n<li>连接同一对顶点的两条边称为<strong>平行边</strong>。</li>\n</ul>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01471.gif\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.1.2　特殊的图</strong></p>\n<p>数学家常常将含有平行边的图称为<strong>多重图</strong>，而将没有平行边或自环的图称为<strong>简单图</strong>。一般来说，实现允许出现自环和平行边（因为它们会在实际应用中出现），但我们不会将它们作为示例。因此，我们用两个顶点就可以指代一条边了。</p><!-- [[[read_end]]] -->\n<h3 id=\"nav_point_169\">4.1.1　术语表</h3>\n<p>和图有关的术语非常多，其中大多数定义都很简单，我们在这里集中介绍。</p>\n<p>当两个顶点通过一条边相连时，我们称这两个顶点是<strong>相邻的</strong>，并称这条边<strong>依附于</strong>这两个顶点。某个顶点的<strong>度数</strong>即为依附于它的边的总数。<strong>子图</strong>是由一幅图的所有边的一个子集（以及它们所依附的所有顶点）组成的图。许多计算问题都需要识别各种类型的子图，特别是由能够<strong>顺序</strong>连接一系列顶点的边所组成的子图。</p>\n<blockquote>\n<p><strong>定义</strong>。在图中，<strong>路径</strong>是由边顺序连接的一系列顶点。<strong>简单路径</strong>是一条没有重复顶点的路径。<strong>环</strong>是一条至少含有一条边且起点和终点相同的路径。<strong>简单环</strong>是一条（除了起点和终点必须相同之外）不含有重复顶点和边的环。路径或者环的<strong>长度</strong>为其中所包含的边数。</p>\n</blockquote>\n<p>大多数情况下，我们研究的都是简单环和简单路径并会省略掉<strong>简单</strong>二字。当允许重复的顶点时，我们指的都是<strong>一般的</strong>路径和环。当两个顶点之间存在一条连接双方的路径时，我们称一个顶点和另一个顶点是<strong>连通</strong>的。我们用类似 <code>u-v-w-x</code> 的记法来表示 <code>u</code> 到 <code>x</code> 的一条路径，用 <code>u-v-w-x-u</code> 表示从 <code>u</code> 到 <code>v</code> 到 <code>w</code> 到 <code>x</code> 再回到 <code>u</code> 的一条环。我们会学习几种查找路径和环的算法。另外，路径和环也会帮我们从整体上考虑一幅图的性质，参见图 4.1.3。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01472.gif\" alt=\"\" width=\"55%\" style=\"width: 55%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.1.3　图的详解</strong></p>\n<blockquote>\n<p><strong>定义</strong>。如果从任意一个顶点都存在一条路径到达另一个任意顶点，我们称这幅图是<strong>连通图</strong>。一幅<strong>非连通的图</strong>由若干连通的部分组成，它们都是其极大连通子图。</p>\n</blockquote>\n<p>直观上来说，如果顶点是物理存在的对象，例如绳节或是念珠，而边也是物理存在的对象，例如绳子或是电线，那么将任意顶点提起，连通图都将是一个整体，而非连通图则会变成两个或多个部分。一般来说，要处理一张图就需要一个个地处理它的连通分量（子图）。</p>\n<p><strong>无环图</strong>是一种不包含环的图。我们将要学习的几个算法就是要找出一幅图中满足一定条件的无环子图。我们还需要一些术语来表示这些结构。</p>\n<blockquote>\n<p><strong>定义</strong>。<strong>树</strong>是一幅无环连通图。互不相连的树组成的集合称为<strong>森林</strong>。连通图的<strong>生成树</strong>是它的一幅子图，它含有图中的所有顶点且是一棵树。图的<strong>生成树森林</strong>是它的所有连通子图的生成树的集合，参见图 4.1.4 和图 4.1.5。</p>\n</blockquote>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01473.gif\" alt=\"\" width=\"40%\" style=\"width: 40%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.1.4　一棵树</strong></p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01474.gif\" alt=\"\" width=\"35%\" style=\"width: 35%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.1.5　生成树森林</strong></p>\n<p>树的定义非常通用，稍做改动就可以变成用来描述程序行为的（函数调用层次）模型和数据结构（二叉查找树、2-3 树等）。树的数学性质很直观并且已被系统地研究过，因此我们就不给出它们的证明了。例如，当且仅当一幅含有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 个结点的图 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01475.gif\" alt=\"G\" inline-img=\"true\" /> 满足下列 5 个条件之一时，它就是一棵树：</p>\n<ul>\n<li><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01475.gif\" alt=\"G\" /> 有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01468.gif\" alt=\"V-1\" /> 条边且不含有环；</li>\n<li><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01475.gif\" alt=\"G\" /> 有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01468.gif\" alt=\"V-1\" /> 条边且是连通的；</li>\n<li><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01475.gif\" alt=\"G\" /> 是连通的，但删除任意一条边都会使它不再连通；</li>\n<li><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01475.gif\" alt=\"G\" /> 是无环图，但添加任意一条边都会产生一条环；</li>\n<li><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01475.gif\" alt=\"G\" /> 中的任意一对顶点之间仅存在一条简单路径。</li>\n</ul>\n<p>我们会学习几种寻找生成树和森林的算法，以上这些性质在分析和实现这些算法的过程中扮演着重要的角色。</p>\n<p>图的<strong>密度</strong>是指已经连接的顶点对占所有可能被连接的顶点对的比例。在<strong>稀疏</strong>图中，被连接的顶点对很少；而在<strong>稠密</strong>图中，只有少部分顶点对之间没有边连接。一般来说，如果一幅图中不同的边的数量在顶点总数 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 的一个小的常数倍以内，那么我们就认为这幅图是稀疏的，否则则是稠密的，参见图 4.1.6。这条经验规律虽然会留下一片灰色地带（比如当边的数量为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01476.gif\" alt=\"\\sim cV^\" inline-img=\"true\" /> 时），但实际应用中稀疏图和稠密图之间的区别是十分明显的。我们将会遇到的应用使用的几乎都是稀疏图。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01477.gif\" alt=\"\" width=\"80%\" style=\"width: 80%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.1.6　两幅图 (<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01478.gif\" alt=\"V=50\" inline-img=\"true\" />)</strong></p>\n<p><strong>二分图</strong>是一种能够将所有结点分为两部分的图，其中图的每条边所连接的两个顶点都分别属于不同的部分。图 4.1.7 即为一幅二分图的示例，其中红色的结点是一个集合，黑色的结点是另一个集合。二分图会出现在许多场景中，我们会在本节的最后详细研究其中的一个场景。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01479.gif\" alt=\"\" width=\"60%\" style=\"width: 60%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.1.7　二分图</strong></p>\n<p>现在，我们已经做好了学习图处理算法的准备。我们首先会研究一种表示图的数据类型的 API 及其实现，然后会学习一些查找图和鉴别连通分量的经典算法。最后，我们会考虑真实世界中的一些图的应用，它们的顶点的名字可能不是整数并且会含有数目庞大的顶点和边。</p>\n<h3 id=\"nav_point_170\">4.1.2　表示无向图的数据类型</h3>\n<p>要开发处理图问题的各种算法，我们首先来看一份定义了图的基本操作的 API，参见表 4.1.1。有了它我们才能完成从简单的基本操作到解决复杂问题的各种任务。</p>\n<p><strong>表 4.1.1　无向图的 API</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td colspan=\"2\"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public class&nbsp;&nbsp;<b>Graph</b></code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Graph(int V)</code></td><td>创建一个含有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" /> 个顶点但不含有边的图</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Graph(In in)</code></td><td>从标准输入流 <code>in</code> 读入一幅图</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;V()</code></td><td>顶点数</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;E()</code></td><td>边数</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;addEdge(int v, int w)</code></td><td>向图中添加一条边 <code>v-w</code></td></tr>\n<tr><td><code>Iterable&lt;Integer&gt;&nbsp;&nbsp;adj(int v)</code></td><td>和 <code>v</code> 相邻的所有顶点</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;&nbsp;toString()</code></td><td>对象的字符串表示</td></tr>\n</table>\n\n<p>这份 API 含有两个构造函数，有两个方法用来分别返回图中的顶点数和边数，有一个方法用来添加一条边，<code>toString()</code> 方法和 <code>adj()</code> 方法用来允许用例遍历给定顶点的所有相邻顶点（遍历顺序不确定）。值得注意的是，本节将学习的所有算法都基于 <code>adj()</code> 方法所抽象的基本操作。</p>\n<p>第二个构造函数接受的输入由 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01480.gif\" alt=\"2E+2\" inline-img=\"true\" /> 个整数组成：首先是 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" />，然后是 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01481.gif\" alt=\"E\" inline-img=\"true\" />，再然后是 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01481.gif\" alt=\"E\" inline-img=\"true\" /> 对 0 到 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01468.gif\" alt=\"V-1\" inline-img=\"true\" /> 之间的整数，每个整数对都表示一条边。例如，我们使用了由图 4.1.8 中的 tinyG.txt 和 mediumG.txt 所描述的两个示例。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01482.gif\" alt=\"\" width=\"93%\" style=\"width: 93%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.1.8　<code>Graph</code> 的构造函数的输入格式（两个示例）</strong></p>\n<p>调用 <code>Graph</code> 的几段用例代码请见表 4.1.2。</p>\n<p><strong>表 4.1.2　最常用的图处理代码</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>任务</p></th>\n<th><p>实现</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>计算 <code>v</code> 的度数</p></td>\n<td><p></p><pre>public static int degree(Graph G, int v)<br />{<br />   int degree = 0;<br />   for (int w : G.adj(v)) degree++;<br />   return degree;<br />}</pre></td>\n</tr>\n<tr>\n<td><p>计算所有顶点的最大度数</p></td>\n<td><p></p><pre>public static int maxDegree(Graph G)<br />{<br />   int max = 0;<br />   for (int v = 0; v &lt; G.V(); v++)<br />      if (degree(G, v) &gt; max)<br />         max = degree(G, v);<br />   return max;<br />}</pre></td>\n</tr>\n<tr>\n<td><p>计算所有顶点的平均度数</p></td>\n<td><p></p><pre>public static double avgDegree(Graph G)<br />{ return 2.0 * G.E() / G.V(); }</pre></td>\n</tr>\n<tr>\n<td><p>计算自环的个数</p></td>\n<td><p></p><pre>public static int numberOfSelfLoops(Graph G)<br />{<br />   int count = 0;<br />   for (int v = 0; v &lt; G.V(); v++)<br />      for (int w : G.adj(v))<br />         if (v == w) count++;<br />   return count/2; //每条边都被记过两次<br />}</pre></td>\n</tr>\n<tr>\n<td><p>图的邻接表的字符串表示（<code>Graph</code> 的实例方法）</p></td>\n<td><p></p><pre>public String toString()<br />{<br />   String s = V + \" vertices, \" + E + \" edges\\n\";<br />   for (int v = 0; v &lt; V; v++)<br />   {<br />      s += v + \": \";<br />      for (int w : this.adj(v))<br />         s += w + \" \";<br />      s += \"\\n\";<br />   }<br />   return s;<br />}</pre></td>\n</tr>\n</tbody>\n</table>\n<h4>4.1.2.1　图的几种表示方法</h4>\n<p>我们要面对的下一个图处理问题就是用哪种方式（数据结构）来表示图并实现这份 API，这包含以下两个要求：</p>\n<ul>\n<li>它必须为可能在应用中碰到的各种类型的图预留出足够的<strong>空间</strong>；</li>\n<li><code>Graph</code> 的实例方法的实现一定要快——它们是开发处理图的各种用例的基础。</li>\n</ul>\n<p>这些要求比较模糊，但它们仍然能够帮助我们在三种图的表示方法中进行选择。</p>\n<ul>\n<li><strong>邻接矩阵</strong>。我们可以使用一个 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" /> 乘 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" /> 的布尔矩阵。当顶点 <code>v</code> 和顶点 <code>w</code> 之间有相连接的边时，定义 <code>v</code> 行 <code>w</code> 列的元素值为 <code>true</code>，否则为 <code>false</code>。这种表示方法不符合第一个条件——含有上百万个顶点的图是很常见的，<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01483.gif\" alt=\"V^2\" /> 个布尔值所需的空间是不能满足的。</li>\n<li><strong>边的数组</strong>。我们可以使用一个 <code>Edge</code> 类，它含有两个 <code>int</code> 实例变量。这种表示方法很简洁但不满足第二个条件——要实现 <code>adj()</code> 需要检查图中的所有边。</li>\n<li><strong>邻接表数组</strong>。我们可以使用一个以顶点为索引的列表数组，其中的每个元素都是和该顶点相邻的顶点列表，参见图 4.1.9。这种数据结构能够同时满足典型应用所需的以上两个条件，我们会在本章中一直使用它。</li>\n</ul>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01484.gif\" alt=\"\" width=\"50%\" style=\"width: 50%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.1.9　邻接表数组示意（无向图）</strong></p>\n<p>除了这些性能目标之外，经过缜密的检查，我们还发现了另一些在某些应用中可能会很重要的东西。例如，允许存在平行边相当于排除了邻接矩阵，因为邻接矩阵无法表示它们。</p>\n<h4>4.1.2.2　邻接表的数据结构</h4>\n<p>非稠密图的标准表示称为<strong>邻接表</strong>的数据结构，它将每个顶点的所有相邻顶点都保存在该顶点对应的元素所指向的一张链表中。我们使用这个数组就是为了快速访问给定顶点的邻接顶点列表。这里使用 1.3 节中的 <code>Bag</code> 抽象数据类型来实现这个链表，这样我们就可以在常数时间内添加新的边或遍历任意顶点的所有相邻顶点。后面框注“<code>Graph</code> 数据类型”中的 <code>Graph</code> 类的实现就是基于这种方法，而图 4.1.9 中所示的正是用这种方法处理 tinyG.txt 所得到的数据结构。要添加一条连接 <code>v</code> 与 <code>w</code> 的边，我们将 <code>w</code> 添加到 <code>v</code> 的邻接表中并把 <code>v</code> 添加到 <code>w</code> 的邻接表中。因此，在这个数据结构中每条边都会出现<strong>两次</strong>。这种 <code>Graph</code> 的实现的性能有如下特点：</p>\n<ul>\n<li>使用的空间和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01485.gif\" alt=\"V+E\" /> 成正比；</li>\n<li>添加一条边所需的时间为常数；</li>\n<li>遍历顶点 <code>v</code> 的所有相邻顶点所需的时间和 <code>v</code> 的度数成正比（处理每个相邻顶点所需的时间为常数）。</li>\n</ul>\n<p>对于这些操作，这样的特性已经是最优的了，这已经可以满足图处理应用的需要，而且支持平行边和自环（我们不会检测它们）。注意，边的插入顺序决定了 <code>Graph</code> 的邻接表中顶点的出现顺序，参见图 4.1.10。多个不同的邻接表可能表示着同一幅图。当使用构造函数从标准输入中读入一幅图时，这就意味着输入的格式和边的顺序决定了 <code>Graph</code> 的邻接表数组中顶点的出现顺序。因为算法在使用 <code>adj()</code> 来处理所有相邻的顶点时不会考虑它们在邻接表中的出现顺序，这种差异不会影响算法的正确性，但在调试或是跟踪邻接表的轨迹时我们还是需要注意这一点。为了简化操作，假设 <code>Graph</code> 有一个测试用例来从命令行参数指定的文件中读取一幅图并将它打印出来（参见表 4.1.2 中的 <code>toString()</code> 方法的实现），以显示邻接表中的各个顶点的出现顺序，这也是算法处理它们的顺序（请见练习 4.1.7）。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01486.jpeg\" alt=\"\" width=\"65%\" style=\"width: 65%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.1.10　由边得到的邻接表</strong></p>\n<blockquote>\n<p><strong><code>Graph</code> 数据类型</strong></p>\n<pre class=\"code-rows\"><code>public class Graph\n{\n   private final int V;          // 顶点数目\n   private int E;                // 边的数目\n   private Bag&lt;Integer&gt;[] adj;   // 邻接表\n   public Graph(int V)\n   {\n      this.V = V; this.E = 0;\n      adj = (Bag&lt;Integer&gt;[]) new Bag[V];      // 创建邻接表\n      for (int v = 0; v &lt; V; v++)             // 将所有链表初始化为空\n         adj[v] = new Bag&lt;Integer&gt;();\n   }\n   public Graph(In in)\n   {\n      this(in.readInt());          // 读取V并将图初始化\n      int E = in.readInt();        // 读取E\n      for (int i = 0; i &lt; E; i++)\n      {  // 添加一条边\n         int v = in.readInt();        // 读取一个顶点\n         int w = in.readInt();        // 读取另一个顶点\n         addEdge(v, w);               // 添加一条连接它们的边\n      }\n   }\n   public int V()  {  return V;  }\n   public int E()  {  return E;  }\n   public void addEdge(int v, int w)\n   {\n      adj[v].add(w);                            // 将w添加到v的链表中\n      adj[w].add(v);                            // 将v添加到w的链表中\n      E++;\n    }\n   public Iterable&lt;Integer&gt; adj(int v)\n   {  return adj[v];  }\n}</code></pre>\n<p>这份 <code>Graph</code> 的实现使用了一个由顶点索引的整型链表数组。每条边都会出现两次，即当存在一条连接 <code>v</code> 与 <code>w</code> 的边时，<code>w</code> 会出现在 <code>v</code> 的链表中，<code>v</code> 也会出现在 <code>w</code> 的链表中。第二个构造函数从输入流中读取一幅图，开头是 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" />，然后是 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01481.gif\" alt=\"E\" inline-img=\"true\" />，再然后是一列整数对，大小在 0 到 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01468.gif\" alt=\"V-1\" inline-img=\"true\" /> 之间。<code>toString()</code> 方法请见表 4.1.2。</p>\n</blockquote>\n<p>在实际应用中还有一些操作可能是很有用的，例如：</p>\n<ul>\n<li>添加一个顶点；</li>\n<li>删除一个顶点。</li>\n</ul>\n<p>实现这些操作的一种方法是扩展之前的 API，使用符号表（<code>ST</code>）来代替由顶点索引构成的数组（这样修改之后就不需要约定顶点名必须是整数了）。我们可能还需要：</p>\n<ul>\n<li>删除一条边；</li>\n<li>检查图是否含有边 <code>v-w</code>。</li>\n</ul>\n<p>要实现这些方法（不允许存在平行边），我们可能需要使用 <code>SET</code> 代替 <code>Bag</code> 来实现邻接表。我们称这种方法为<strong>邻接集</strong>。本书中不会使用这些数据结构，因为：</p>\n<ul>\n<li>用例代码不需要添加顶点、删除顶点和边或是检查一条边是否存在；</li>\n<li>当用例代码需要进行上述操作时，由于频率很低或者相关的邻接链表很短，因此可以直接使用穷举法遍历链表来实现；</li>\n<li>使用 <code>SET</code> 和 <code>ST</code> 会令算法的实现变得更加复杂，分散了读者对算法本身的注意力；</li>\n<li>在某些情况下，它们会使性能损失 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01487.gif\" alt=\"\\log V\" />。</li>\n</ul>\n<p>使我们的算法适应其他设计（例如，不允许出现平行边或是自环）并避免不必要的性能损失并不困难。表 4.1.3 总结了之前提到过的所有其他实现方法的性能特点。常见的应用场景都需要处理庞大的稀疏图，因此我们会一直使用邻接表。</p>\n<p><strong>表 4.1.3　典型 <code>Graph</code> 实现的性能复杂度</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>数据结构</p></th>\n<th><p>所需空间</p></th>\n<th><p>添加一条边 <code>v-w</code></p></th>\n<th><p>检查 <code>w</code> 和 <code>v</code> 是否相邻</p></th>\n<th><p>遍历 <code>v</code> 的所有相邻顶点</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>边的列表</p></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01481.gif\" inline-img=\"true\" /></p></td>\n<td><p>1</p></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01481.gif\" inline-img=\"true\" /></p></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01481.gif\" inline-img=\"true\" /></p></td>\n</tr>\n<tr>\n<td><p>邻接矩阵</p></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01483.gif\" inline-img=\"true\" /></p></td>\n<td><p>1</p></td>\n<td><p>1</p></td>\n<td><p><code>V</code></p></td>\n</tr>\n<tr>\n<td><p>邻接表</p></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01488.gif\" inline-img=\"true\" /></p></td>\n<td><p>1</p></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01489.gif\" inline-img=\"true\" />(<code>v</code>)</p></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01489.gif\" inline-img=\"true\" />(<code>v</code>)</p></td>\n</tr>\n<tr>\n<td><p>邻接集</p></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01488.gif\" inline-img=\"true\" /></p></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01487.gif\" inline-img=\"true\" /></p></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01487.gif\" inline-img=\"true\" /></p></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01490.gif\" inline-img=\"true\" />(<code>v</code>)</p></td>\n</tr>\n</tbody>\n</table>\n<h4>4.1.2.3　图的处理算法的设计模式</h4>\n<p>因为我们会讨论大量关于图处理的算法，所以设计的首要目标是将图的表示和实现分离开来。为此，我们会为每个任务创建一个相应的类，用例可以创建相应的对象来完成任务。类的构造函数一般会在预处理中构造各种数据结构，以有效地响应用例的请求。典型的用例程序会构造一幅图，将图传递给实现了某个算法的类（作为构造函数的参数），然后调用用例的方法来获取图的各种性质。作为热身，我们先来看看这份 API，参见表 4.1.4。</p>\n<p><strong>表 4.1.4　图处理算法的 API（热身）</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td colspan=\"2\"><code>public class&nbsp;&nbsp;<b>Search</b></code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Search(Graph G, int s)</code></td><td>找到和起点 <code>s</code> 连通的所有顶点</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;marked(int v)</code></td><td><code>v</code> 和 <code>s</code> 是连通的吗</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;count()</code></td><td>与 <code>s</code> 连通的顶点总数</td></tr>\n</table>\n\n<p>我们用<strong>起点</strong>（source）区分作为参数传递给构造函数的顶点与图中的其他顶点。在这份 API 中，构造函数的任务是找到图中与起点连通的其他顶点。用例可以调用 <code>marked()</code> 方法和 <code>count()</code> 方法来了解图的性质。方法名 <code>marked()</code> 指的是这种基本算法使用的一种实现方式，本章中会一直使用到这种算法：在图中从起点开始沿着路径到达其他顶点并标记每个路过的顶点。后面框注中的图处理用例 <code>TestSearch</code> 接受由命令行得到的一个输入流的名称和起始结点的编号，从输入流中读取一幅图（使用 <code>Graph</code> 的第二个构造函数），用这幅图和给定的起始结点创建一个 <code>Search</code> 对象，然后用 <code>marked()</code> 打印出图中和起点连通的所有顶点。它也调用了 <code>count()</code> 并打印了图是否是连通的（当且仅当搜索能够标记图中的所有顶点时图才是连通的）。</p>\n<pre class=\"code-rows\"><code>public class TestSearch\n{\n   public static void main(String[] args)\n   {\n      Graph G = new Graph(new In(args[0]));\n      int s = Integer.parseInt(args[1]);\n      Search search = new Search(G, s);\n\n      for (int v = 0; v &lt; G.V(); v++)\n         if (search.marked(v))\n            StdOut.print(v + \" \");\n      StdOut.println();\n\n      if (search.count() != G.V())\n         StdOut.print(\"NOT \");\n      StdOut.println(\"connected\");\n   }\n}</code></pre>\n<p style=\"text-align: center\">图处理的用例（热身）</p>\n<pre class=\"code-rows\"><code>% java TestSearch tinyG.txt 0\n0 1 2 3 4 5 6\nNOT connected\n\n% java TestSearch tinyG.txt 9\n9 10 11 12\nNOT connected</code></pre>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01491.gif\" alt=\"\" width=\"60%\" style=\"width: 60%\" /></p>\n<p>我们已经见过 <code>Search</code> API 的一种实现：第 1 章中的 union-find 算法。它的构造函数会创建一个 <code>UF</code> 对象，对图中的每一条边进行一次 <code>union()</code> 操作并调用 <code>connected(s,v)</code> 来实现 <code>marked(v)</code> 方法。实现 <code>count()</code> 方法需要一个加权的 <code>UF</code> 实现并扩展它的 API，以便使用 <code>count()</code> 方法返回 <code>wt[find(v)]</code>（请见练习 4.1.8）。这种实现简单而高效，但下面我们要学习的实现还可以更进一步。它基于的是<strong>深度优先搜索</strong>（DFS）的。这是一种重要的递归方法，它会沿着图的边寻找和起点连通的所有顶点。深度优先搜索是本章中将学习的好几种关于图的算法的基础。</p>\n<h3 id=\"nav_point_171\">4.1.3　深度优先搜索　通道</h3>\n<p>我们常常通过系统地检查每一个顶点和每一条边来获取图的各种性质。要得到图的一些简单性质（比如，计算所有顶点的度数）很容易，只要检查每一条边即可（任意顺序）。但图的许多其他性质和路径有关，因此一种很自然的想法是沿着图的边从一个顶点移动到另一个顶点。尽管存在各种各样的处理策略，但后面将要学习的几乎所有与图有关的算法都使用了这个简单的抽象模型，其中最简单的就是下面介绍的这种经典的方法。</p>\n<h4>4.1.3.1　走迷宫</h4>\n<p>思考图的搜索过程的一种有益的方法是，考虑另一个和它等价但历史悠久而又特别的问题——在一个由各种通道和路口组成的迷宫中找到出路。有些迷宫的规则很简单，但大多数迷宫则需要很复杂的策略才行。用<strong>迷宫</strong>代替<strong>图</strong>、<strong>通道</strong>代替<strong>边</strong>、<strong>路口</strong>代替<strong>顶点</strong>仅仅只是一些文字游戏，但就目前来说，这么做可以帮助我们直观地认识问题，参见图 4.1.11。探索迷宫而不迷路的一种古老办法（至少可以追溯到忒修斯和米诺陶的传说）叫做 <strong>Tremaux 搜索</strong>，参见图 4.1.12。要探索迷宫中的所有通道，我们需要：</p>\n<ul>\n<li>选择一条没有标记过的通道，在你走过的路上铺一条绳子；</li>\n<li>标记所有你第一次路过的路口和通道；</li>\n<li>当来到一个标记过的路口时（用绳子）回退到上个路口；</li>\n<li>当回退到的路口已没有可走的通道时继续回退。</li>\n</ul>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01492.gif\" alt=\"\" width=\"37%\" style=\"width: 37%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.1.11　等价的迷宫模型</strong></p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01493.gif\" alt=\"\" width=\"30%\" style=\"width: 30%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.1.12　Tremaux搜索</strong></p>\n<p>绳子可以保证你总能找到一条出路，标记则能保证你不会两次经过同一条通道或者同一个路口。要知道是否完全探索了整个迷宫需要的证明更复杂，只有用图搜索才能够更好地处理问题。Tremaux 搜索很直接，但它与完全搜索一张图仍然稍有不同，因此我们接下来看看图的搜索方法。</p>\n<pre class=\"code-rows\"><code>public class DepthFirstSearch\n{\n   private boolean[] marked;\n   private int count;\n\n   public DepthFirstSearch(Graph G, int s)\n   {\n      marked = new boolean[G.V()];\n      dfs(G, s);\n   }\n\n   private void dfs(Graph G, int v)\n   {\n      marked[v] = true;\n      count++;\n      for (int w : G.adj(v))\n         if (!marked[w]) dfs(G, w);\n   }\n\n   public boolean marked(int w)\n   {  return marked[w];  }\n\n   public int count()\n   {  return count;  }\n}</code></pre>\n<p style=\"text-align: center\">深度优先搜索</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01494.gif\" alt=\"\" width=\"60%\" style=\"width: 60%\" /></p>\n<h4>4.1.3.2　热身</h4>\n<p>搜索连通图的经典递归算法（遍历所有的顶点和边）和 Tremaux 搜索类似，但描述起来更简单。要搜索一幅图，只需用一个递归方法来遍历所有顶点。在访问其中一个顶点时：</p>\n<ul>\n<li>将它标记为已访问；</li>\n<li>递归地访问它的所有没有被标记过的邻居顶点。</li>\n</ul>\n<p>这种方法称为<strong>深度优先搜索</strong>（DFS）。<code>Search</code> API 的一种实现使用了这种方法，如深度优先搜索框注所示。它使用一个 <code>boolean</code> 数组来记录和起点连通的所有顶点。递归方法会标记给定的顶点并调用自己来访问该顶点的相邻顶点列表中所有没有被标记过的顶点。如果图是连通的，每个邻接链表中的元素都会被检查到。</p>\n<blockquote>\n<p><strong>命题 A</strong>。深度优先搜索标记与起点连通的所有顶点所需的时间和顶点的度数之和成正比。</p>\n<p><strong>证明</strong>。首先，我们要证明这个算法能够标记与起点 <code>s</code> 连通的所有顶点（且不会标记其他顶点）。因为算法仅通过边来寻找顶点，所以每个被标记过的顶点都与 <code>s</code> 连通。现在，假设某个没有被标记过的顶点 <code>w</code> 与 <code>s</code> 连通。因为 <code>s</code> 本身是被标记过的，由 <code>s</code> 到 <code>w</code> 的任意一条路径中至少有一条边连接的两个顶点分别是被标记过的和没有被标记过的，例如 <code>v-x</code>。根据算法，在标记了 <code>v</code> 之后必然会发现 <code>x</code>，因此这样的边是不存在的。前后矛盾。每个顶点都只会被访问一次保证了时间上限（检查标记的耗时和度数成正比）。</p>\n</blockquote>\n<h4>4.1.3.3　单向通道</h4>\n<p>代码中方法的调用和返回机制对应迷宫中绳子的作用：当已经处理过依附于一个顶点的所有边时（搜索了路口连接的所有通道），我们就只能“返回”（return，两者的意义相同）。为了更好地与迷宫的 Tremaux 搜索对应起来，我们可以想象一座完全由单向通道构造的迷宫（每个方向都有一个通道）。和在迷宫中会经过一条通道<strong>两次</strong>（方向不同）一样，在图中我们也会路过每条边两次（在它的两个端点各一次）。在 Tremaux 搜索中，要么是第一次访问区别了边的遍历方向的画法一条边，要么是沿着它从一个被标记过的顶点退回。在无向图的深度优先搜索中，在碰到边 <code>v-w</code> 时，要么进行递归调用（<code>w</code> 没有被标记过），要么跳过这条边（<code>w</code> 已经被标记过）。第二次从另一个方向 <code>w-v</code> 遇到这条边时，总是会忽略它，因为它的另一端 <code>v</code> 肯定已经被访问过了（在第一次遇到这条边的时候）。</p>\n<h4>4.1.3.4　跟踪深度优先搜索</h4>\n<p>通常，理解算法的最好方法是在一个简单的例子中跟踪它的行为。深度优先算法尤其是这样。在跟踪它的轨迹时，首先要注意的是，算法遍历边和访问顶点的顺序与图的<strong>表示</strong>是有关的，而不只是与图的结构或是算法有关。因为深度优先搜索只会访问和起点连通的顶点，所以使用图 4.1.13 所示的一幅小型连通图为例。在示例中，顶点 <code>2</code> 是顶点 <code>0</code> 之后第一个被访问的顶点，因为它正好是 <code>0</code> 的邻接表的第一个元素。要注意的第二点是，如前文所述，深度优先搜索中每条边都会被访问两次，且在第二次时总会发现这个顶点已经被标记过。这意味着深度优先搜索的轨迹可能会比你想象的长一倍！示例图仅含有 8 条边，但需要追踪算法在邻接表的 16 个元素上的操作。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01495.gif\" alt=\"\" width=\"60%\" style=\"width: 60%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.1.13　一幅连通的无向图</strong></p>\n<h4>4.1.3.5　深度优先搜索的详细轨迹</h4>\n<p>图 4.1.14 显示的是示例中每个顶点被标记后算法使用的数据结构，起点为顶点 <code>0</code>。查找开始于构造函数调用递归的 <code>dfs()</code> 来标记和访问顶点 <code>0</code>，后续处理如下所述。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01496.jpeg\" alt=\"\" width=\"70%\" style=\"width: 70%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.1.14　使用深度优先搜索的轨迹，寻找所有和顶点 0 连通的顶点</strong></p>\n<ul>\n<li>因为顶点 <code>2</code> 是 <code>0</code> 的邻接表的第一个元素且没有被标记过，<code>dfs()</code> 递归调用自己来标记并访问顶点 <code>2</code>（效果是系统会将顶点 <code>0</code> 和 <code>0</code> 的邻接表的当前位置压入栈中）。</li>\n<li>现在，顶点 <code>0</code> 是 <code>2</code> 的邻接表的第一个元素且已经被标记过了，因此 <code>dfs()</code> 跳过了它。接下来，顶点 <code>1</code> 是 <code>2</code> 的邻接表的第二个元素且没有被标记，<code>dfs()</code> 递归调用自己来标记并访问顶点 <code>1</code>。</li>\n<li>对顶点 <code>1</code> 的访问和前面有所不同：因为它的邻接表中的所有顶点（<code>0</code> 和 <code>2</code>）都已经被标记过了，因此不需要再进行递归，方法从 <code>dfs(1)</code> 中返回。下一条被检查的边是 <code>2-3</code>（在 <code>2</code> 的邻接表中顶点 <code>1</code> 之后的顶点是 <code>3</code>），因此 <code>dfs()</code> 递归调用自己来标记并访问顶点 <code>3</code>。</li>\n<li>顶点 <code>5</code> 是 <code>3</code> 的邻接表的第一个元素且没有被标记，因此 <code>dfs()</code> 递归调用自己来标记并访问顶点 <code>5</code>。</li>\n<li>顶点 <code>5</code> 的邻接表中的所有顶点（<code>3</code> 和 <code>0</code>）都已经被标记过了，因此不需要再进行递归。</li>\n<li>顶点 <code>4</code> 是 <code>3</code> 的邻接表的下一个元素且没有被标记过，因此 <code>dfs()</code> 递归调用自己来标记并访问顶点 <code>4</code>。这是最后一个需要被标记的顶点。</li>\n<li>在顶点 <code>4</code> 被标记了之后，<code>dfs()</code> 会检查它的邻接表，然后再检查 <code>3</code> 的邻接表，然后是 <code>2</code> 的邻接表，然后是 <code>0</code> 的，最后发现不需要再进行任何递归调用，因为所有的顶点都已经被标记过了。</li>\n</ul>\n<p><strong>这种简单的递归模式只是一个开始</strong>——深度优先搜索能够有效处理许多和图有关的任务。例如，本节中，我们已经可以用深度优先搜索来解决在第 1 章首次提到的一个问题。</p>\n<p><strong>连通性</strong>。<strong>给定一幅图，回答“两个给定的顶点是否连通？”或者“图中有多少个连通子图？”等类似问题</strong>。</p>\n<p>我们可以轻易地用处理图问题的标准设计模式给出这些问题的答案，还要将这些解答与在 1.5 节中学习的 union-find 算法进行比较。</p>\n<p>问题“两个给定的顶点是否连通？”等价于“两个给定的顶点之间是否存在一条路径？”，也许也可以叫做<strong>路径检测</strong>问题。但是，在 1.5 节学习的 union-find 算法的数据结构并不能解决<strong>找出</strong>这样一条路径的问题。深度优先搜索是我们已经学习过的几种方法中第一个能够解决这个问题的算法。它能够解决的另一个问题如下所述。</p>\n<p><strong>单点路径</strong>。<strong>给定一幅图和一个起点 <code>s</code>，回答“从 <code>s</code> 到给定目的顶点 <code>v</code> 是否存在一条路径？如果有，找出这条路径。”等类似问题</strong>。</p>\n<p>深度优先搜索算法之所以极为简单，是因为它所基于的概念为人所熟知并且非常容易实现。事实上，它是一个既小巧而又强大的算法，研究人员用它解决了无数困难的问题。上述两个问题只是我们将要研究的许多问题的开始。</p>\n<h3 id=\"nav_point_172\">4.1.4　寻找路径</h3>\n<p>单点路径问题在图的处理领域中十分重要。根据标准设计模式，我们将使用如下 API（请见表 4.1.5）。</p>\n<p><strong>表 4.1.5　路径的 API</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td colspan=\"2\"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public class&nbsp;&nbsp;<b>Paths</b></code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Paths(Graph G, int s)</code></td><td>在 <code>G</code> 中找出所有起点为 <code>s</code> 的路径</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;hasPathTo(int v)</code></td><td>是否存在从 <code>s</code> 到 <code>v</code> 的路径</td></tr>\n<tr><td><code>Iterable&lt;Integer&gt;&nbsp;&nbsp;pathTo(int v)</code></td><td><code>s</code> 到 <code>v</code> 的路径，如果不存在则返回 <code>null</code></td></tr>\n</table>\n\n<p>构造函数接受一个起点 <code>s</code> 作为参数，计算 <code>s</code> 到与 <code>s</code> 连通的每个顶点之间的路径。在为起点 <code>s</code> 创建了 <code>Paths</code> 对象后，用例可以调用 <code>pathTo()</code> 实例方法来遍历从 <code>s</code> 到任意和 <code>s</code> 连通的顶点的路径上的所有顶点。现在暂时查找所有路径，以后会实现只查找具有某些属性的路径。</p>\n<pre class=\"code-rows\"><code>% java Paths tinyCG.txt 0\n0 to 0: 0\n0 to 1: 0-2-1\n0 to 2: 0-2\n0 to 3: 0-2-3\n0 to 4: 0-2-3-4\n0 to 5: 0-2-3-5</code></pre>\n<p>　</p>\n<pre class=\"code-rows\"><code>public static void main(String[] args)\n{\n   Graph G = new Graph(new In(args[0]));\n   int s = Integer.parseInt(args[1]);\n   Paths search = new Paths(G, s);\n   for (int v = 0; v &lt; G.V(); v++)\n   {\n      StdOut.print(s + \" to \" + v + \": \");\n      if (search.hasPathTo(v))\n         for (int x : search.pathTo(v))\n            if (x == s) StdOut.print(x);\n            else StdOut.print(\"-\" + x);\n      StdOut.println();\n   }\n}</code></pre>\n<p style=\"text-align: center\"><code>Paths</code> 实现的测试用例</p>\n<p>上一页右下角框注中的用例从输入流中读取了一个图并从命令行得到一个起点，然后打印出从起点到与它连通的每个顶点之间的一条路径。</p>\n<h4>4.1.4.1　实现</h4>\n<p>算法 4.1 基于深度优先搜索实现了 <code>Paths</code>。它扩展了 4.1.3.2 节中的热身代码 <code>DepthFirstSearch</code>，添加了一个实例变量 <code>edgeTo[]</code> 整型数组来起到 Tremaux 搜索中绳子的作用。这个数组可以找到从每个与 <code>s</code> 连通的顶点回到 <code>s</code> 的路径。它会记住<strong>每个</strong>顶点到起点的路径，而不是记录当前顶点到起点的路径。为了做到这一点，在由边 <code>v-w</code> <strong>第一次访问</strong>任意 <code>w</code> 时，将 <code>edgeTo[w]</code> 设为 <code>v</code> 来记住这条路径。换句话说，<code>v-w</code> 是从 <code>s</code> 到 <code>w</code> 的路径上的最后一条已知的边。这样，搜索的结果是一棵以起点为根结点的树，<code>edgeTo[]</code> 是一棵由父链接表示的树。算法 4.1 的代码的右侧是一个小示例。要找出 <code>s</code> 到任意顶点 <code>v</code> 的路径，算法 4.1 实现的 <code>pathTo()</code> 方法用变量 <code>x</code> 遍历整棵树，将 <code>x</code> 设为 <code>edgeTo[x]</code>，就像 1.5 节中的 union-find 算法一样，然后在到达 s 之前，将遇到的所有顶点都压入栈中。将这个栈返回为一个 <code>Iterable</code> 对象帮助用例遍历 <code>s</code> 到 <code>v</code> 的路径。</p>\n<blockquote>\n<p><strong>算法 4.1　使用深度优先搜索查找图中的路径</strong></p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01497.gif\" alt=\"\" width=\"80%\" style=\"width: 80%\" /></p>\n<p>　</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01498.gif\" alt=\"\" width=\"60%\" style=\"width: 60%\" /></p>\n<p style=\"text-align: center\"><code>pathTo(5)</code> 的计算轨迹</p>\n<p>这段 <code>Graph</code> 的用例使用了深度优先搜索，以找出图中从给定的起点 <code>s</code> 到它连通的所有顶点的路径。来自 <code>DepthFirstSearch</code>（4.1.3.2 节）的代码均为灰色。为了保存到达每个顶点的已知路径，这段代码使用了一个以顶点编号为索引的数组 <code>edgeTo[]</code>，<code>edgeTo[w]=v</code> 表示 <code>v-w</code> 是第一次访问 <code>w</code> 时经过的边。<code>edgeTo[]</code> 数组是一棵用父链接表示的以 <code>s</code> 为根且含有所有与 <code>s</code> 连通的顶点的树。</p>\n</blockquote>\n<h4>4.1.4.2　详细轨迹</h4>\n<p>图 4.1.15 显示的是示例中每个顶点被标记后 <code>edgeTo[]</code> 的内容，起点为顶点 <code>0</code>。<code>marked[]</code> 和 <code>adj[]</code> 的内容与 4.1.3.5 节中的 <code>DepthFirstSearch</code> 的轨迹相同，递归调用和边检查的详细描述也完全一样，这里不再赘述。深度优先搜索向 <code>edgeTo[]</code> 数组中顺序添加了 <code>0-2</code>、<code>2-1</code>、<code>2-3</code>、<code>3-5</code> 和 <code>3-4</code>。这些边构成了一棵以起点为根结点的树并提供了 <code>pathTo()</code> 方法所需的信息，使得调用者可以按照前文所述的方法找到从 <code>0</code> 到顶点 <code>1</code>、<code>2</code>、<code>3</code>、<code>4</code>、<code>5</code> 的路径。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01499.jpeg\" alt=\"\" width=\"60%\" style=\"width: 60%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.1.15　使用深度优先搜索的轨迹，寻找所有起点为 0 的路径</strong></p>\n<p><code>DepthFirstPaths</code> 与 <code>DepthFirstSearch</code> 的构造函数仅有几条赋值语句不同，因此 4.1.3.2 节中的命题 A 仍然适用。另外，我们还有以下命题。</p>\n<blockquote>\n<p><strong>命题 A（续）</strong>。使用深度优先搜索得到从给定起点到任意标记顶点的路径所需的时间与路径的长度成正比。</p>\n<p><strong>证明</strong>。根据对已经访问过的顶点数量的归纳可得，<code>DepthFirstPaths</code> 中的 <code>edgeTo[]</code> 数组表示了一棵以起点为根结点的树。<code>pathTo()</code> 方法构造路径所需的时间和路径的长度成正比。</p>\n</blockquote>\n<h3 id=\"nav_point_173\">4.1.5　广度优先搜索</h3>\n<p>深度优先搜索得到的路径不仅取决于图的结构，还取决于图的表示和递归调用的性质。我们很自然地还经常对下面这些问题感兴趣。</p>\n<blockquote>\n<p>单点最短路径。给定一幅图和一个起点 <code>s</code>，回答“从 <code>s</code> 到给定目的顶点 <code>v</code> 是否存在一条路径？如果有，找出其中最短的那条（所含边数最少）。”等类似问题。</p>\n</blockquote>\n<p>解决这个问题的经典方法叫做<strong>广度优先搜索</strong>（BFS)。它也是许多图算法的基石，因此我们会在本节中详细学习。深度优先搜索在这个问题上没有什么作为，因为它遍历整个图的顺序和找出最短路径的目标没有任何关系。相比之下，广度优先搜索正是为了这个目标才出现的。要找到从 <code>s</code> 到 <code>v</code> 的最短路径，从 <code>s</code> 开始，在所有由一条边就可以到达的顶点中寻找 <code>v</code>，如果找不到我们就继续在与 <code>s</code> 距离两条边的所有顶点中查找 <code>v</code>，如此一直进行。深度优先搜索就好像是一个人在走迷宫，广度优先搜索则好像是一组人在一起朝各个方向走这座迷宫，每个人都有自己的绳子。当出现新的叉路时，可以假设一个探索者可以分裂为更多的人来搜索它们，当两个探索者相遇时，会合二为一（并继续使用先到达者的绳子），参见图 4.1.16。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01500.gif\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.1.16　广度优先的迷宫搜索</strong></p>\n<p>在程序中，在搜索一幅图时遇到有多条边需要遍历的情况时，我们会选择其中一条并将其他通道留到以后再继续搜索。在深度优先搜索中，我们用了一个可以下压的栈（这是由系统管理的，以支持递归搜索方法）。使用 LIFO（后进先出）的规则来描述压栈和走迷宫时先探索相邻的通道类似。从有待搜索的通道中选择最晚遇到过的那条。在广度优先搜索中，我们希望按照与起点的距离的顺序来遍历所有顶点，看起来这种顺序很容易实现：使用（FIFO，先进先出）队列来代替栈（LIFO，后进先出）即可。我们将从有待搜索的通道中选择最早遇到的那条。</p>\n<p><strong>实现</strong></p>\n<p>算法 4.2 实现了广度优先搜索算法。它使用了一个队列来保存所有已经被标记过但其邻接表还未被检查过的顶点。先将起点加入队列，然后重复以下步骤直到队列为空：</p>\n<ul>\n<li>取队列中的下一个顶点 <code>v</code> 并标记它；</li>\n<li>将与 <code>v</code> 相邻的所有未被标记过的顶点加入队列。</li>\n</ul>\n<p>算法 4.2 中的 <code>bfs()</code> 方法<strong>不是</strong>递归的。不像递归中隐式使用的栈，它显式地使用了一个队列。和深度优先搜索一样，它的结果也是一个数组 <code>edgeTo[]</code>，也是一棵用父链接表示的根结点为 <code>s</code> 的树。它表示了 <code>s</code> 到每个与 <code>s</code> 连通的顶点的最短路径。用例也可以使用算法 4.1 中为深度优先搜索实现的相同的 <code>pathTo()</code> 方法得到这些路径。</p>\n<p>图 4.1.17 和图 4.1.18 显示了用广度优先搜索处理样图时，算法使用的数据结构在每次循环的迭代开始时的内容。首先，顶点 <code>0</code> 被加入队列，然后循环开始搜索。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01501.gif\" alt=\"\" width=\"75%\" style=\"width: 75%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.1.17　使用广度优先搜索寻找所有起点为 <code>0</code> 的路径的结果</strong></p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01502.jpeg\" alt=\"\" width=\"70%\" style=\"width: 70%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.1.18　使用广度优先搜索的轨迹，寻找所有起点为 <code>0</code> 的路径</strong></p>\n<ul>\n<li>从队列中删去顶点 <code>0</code> 并将它的相邻顶点 <code>2</code>、<code>1</code> 和 <code>5</code> 加入队列中，标记它们并分别将它们在 <code>edgeTo[]</code> 中的值设为 <code>0</code>。</li>\n<li>从队列中删去顶点 <code>2</code> 并检查它的相邻顶点 <code>0</code> 和 <code>1</code>，发现两者都已经被标记。将相邻的顶点 <code>3</code> 和 <code>4</code> 加入队列，标记它们并分别将它们在 <code>edgeTo[]</code> 中的值设为 <code>2</code>。</li>\n<li>从队列中删去顶点 <code>1</code> 并检查它的相邻顶点 <code>0</code> 和 <code>2</code>，发现它们都已经被标记了。</li>\n<li>从队列中删去顶点 <code>5</code> 并检查它的相邻顶点 <code>3</code> 和 <code>0</code>，发现它们都已经被标记了。</li>\n<li>从队列中删去顶点 <code>3</code> 并检查它的相邻顶点 <code>5</code>、<code>4</code> 和 <code>2</code>，发现它们都已经被标记了。</li>\n<li>从队列中删去顶点 <code>4</code> 并检查它的相邻顶点 <code>3</code> 和 <code>2</code>，发现它们都已经被标记了。</li>\n</ul>\n<blockquote>\n<p><strong>算法 4.2　使用广度优先搜索查找图中的路径</strong></p>\n<pre class=\"code-rows\"><code>public class BreadthFirstPaths\n{\n   private boolean[] marked; // 到达该顶点的最短路径已知吗？\n   private int[] edgeTo;     // 到达该顶点的已知路径上的最后一个顶点\n   private final int s;      // 起点\n\n   public BreadthFirstPaths(Graph G, int s)\n   {\n      marked = new boolean[G.V()];\n      edgeTo = new int[G.V()];\n      this.s = s;\n      bfs(G, s);\n   }\n\n   private void bfs(Graph G, int s)\n   {\n      Queue&lt;Integer&gt; queue = new Queue&lt;Integer&gt;();\n      marked[s] = true;          // 标记起点\n      queue.enqueue(s);          // 将它加入队列\n      while (!queue.isEmpty())\n      {\n         int v = queue.dequeue(); // 从队列中删去下一顶点\n         for (int w : G.adj(v))\n            if (!marked[w])       // 对于每个未被标记的相邻顶点\n            {\n               edgeTo[w] = v;     // 保存最短路径的最后一条边\n               marked[w] = true;  // 标记它，因为最短路径已知\n               queue.enqueue(w);  // 并将它添加到队列中\n            }\n      }\n   }\n\n   public boolean hasPathTo(int v)\n   {  return marked[v];  }\n\n   public Iterable&lt;Integer&gt; pathTo(int v)\n   // 和深度优先搜索中的实现相同（请见算法4.1）\n\n}</code></pre>\n<p>　</p>\n<pre class=\"code-rows\"><code>% java BreadthFirstPaths tinyCG.txt 0\n0 to 0: 0\n0 to 1: 0-1\n0 to 2: 0-2\n0 to 3: 0-2-3\n0 to 4: 0-2-4\n0 to 5: 0-5</code></pre>\n<p>这段 <code>Graph</code> 的用例使用了广度优先搜索，以找出图中从构造函数得到的起点 <code>s</code> 到与其他所有顶点的最短路径。<code>bfs()</code> 方法会标记所有与 <code>s</code> 连通的顶点，因此用例可以调用 <code>hasPathTo()</code> 来判定一个顶点与 <code>s</code> 是否连通并使用 <code>pathTo()</code> 得到一条从 <code>s</code> 到 <code>v</code> 的路径，确保没有其他从 <code>s</code> 到 <code>v</code> 的路径所含的边比这条路径更少。</p>\n</blockquote>\n<p>对于这个例子来说，<code>edgeTo[]</code> 数组在第二步之后就已经完成了。和深度优先搜索一样，一旦所有的顶点都已经被标记，余下的计算工作就只是在检查连接到各个已被标记的顶点的边而已。</p>\n<blockquote>\n<p><strong>命题 B</strong>。对于从 <code>s</code> 可达的任意顶点 <code>v</code>，广度优先搜索都能找到一条从 s 到 v 的最短路径（没有其他从 s 到 v 的路径所含的边比这条路径更少）。</p>\n<p><strong>证明</strong>。由归纳易得队列总是包含零个或多个到起点的距离为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00842.gif\" alt=\"k\" inline-img=\"true\" /> 的顶点，之后是零个或多个到起点的距离为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01260.gif\" alt=\"k+1\" inline-img=\"true\" /> 的顶点，其中 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00842.gif\" alt=\"k\" inline-img=\"true\" /> 为整数，起始值为 0。这意味着顶点是按照它们和 <code>s</code> 的距离的顺序加入或者离开队列的。从顶点 <code>v</code> 加入队列到它离开队列之前，不可能找出到 <code>v</code> 的更短的路径，而在<code>v</code>离开队列之后发现的所有能够到达 <code>v</code> 的路径都不可能短于 <code>v</code> 在树中的路径长度。</p>\n</blockquote>\n<p>　</p>\n<blockquote>\n<p><strong>命题 B（续）</strong>。广度优先搜索所需的时间在最坏情况下和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01485.gif\" alt=\"V+E\" inline-img=\"true\" /> 成正比。</p>\n<p><strong>证明</strong>。和命题 A 一样（请见 4.1.3.2 节），广度优先搜索标记所有与 <code>s</code> 连通的顶点所需的时间也与它们的度数之和成正比。如果图是连通的，这个和就是所有顶点的度数之和，也就是 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01503.gif\" alt=\"2E\" inline-img=\"true\" />。</p>\n</blockquote>\n<p>注意，我们也可以用广度优先搜索来实现已经用深度优先搜索实现的 <code>Search</code> API，因为它检查所有与起点连通的顶点和边的方法只取决于查找的能力。</p>\n<p>我们在本章开头说过，深度优先搜索和广度优先搜索是我们首先学习的几种通用的图搜索的算法之一。在搜索中我们都会先将起点存入数据结构中，然后重复以下步骤直到数据结构被清空：</p>\n<ul>\n<li>取其中的下一个顶点并标记它；</li>\n<li>将 <code>v</code> 的所有相邻而又未被标记的顶点加入数据结构。</li>\n</ul>\n<p>这两个算法的不同之处仅在于从数据结构中获取下一个顶点的规则（对于广度优先搜索来说是最早加入的顶点，对于深度优先搜索来说是最晚加入的顶点）。这种差异得到了处理图的两种完全不同的视角，尽管无论使用哪种规则，所有与起点连通的顶点和边都会被检查到。</p>\n<p>图 4.1.19 和图 4.1.20 显示了深度优先搜索和广度优先搜索处理样图 mediumG.txt 的过程，它们清晰地展示了两种方法中搜索路径的不同。深度优先搜索不断深入图中并在栈中保存了所有分叉的顶点；广度优先搜索则像扇面一般扫描图，用一个队列保存访问过的最前端的顶点。深度优先搜索探索一幅图的方式是寻找离起点更远的顶点，只在碰到死胡同时才访问近处的顶点；广度优先搜索则会首先覆盖起点附近的顶点，只在临近的所有顶点都被访问了之后才向前进。深度优先搜索的路径通常较长而且曲折，广度优先搜索的路径则短而直接。根据应用的不同，所需要的性质也会有所不同（也许路径的性质也会变得无关紧要）。在 4.4 节中，我们会学习 <code>Paths</code> 的 API 的其他实现来寻找有特定属性的路径。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01504.gif\" alt=\"\" width=\"30%\" style=\"width: 30%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.1.19　使用深度优先搜索查找路径（250 个顶点）</strong></p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01505.gif\" alt=\"\" width=\"30%\" style=\"width: 30%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.1.20　使用广度优先搜索查找最短路径（250 个顶点）</strong></p>\n<h3 id=\"nav_point_174\">4.1.6　连通分量</h3>\n<p>深度优先搜索的下一个直接应用就是找出一幅图的所有连通分量。回忆 1.5 节中“与……连通”是一种<strong>等价关系</strong>，它能够将所有顶点切分为<strong>等价类</strong>（连通分量）。对于这个常见的任务，我们定义如下 API（请见表 4.1.6）。</p>\n<p><strong>表 4.1.6　连通分量的 API</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td colspan=\"2\"><code>public class&nbsp;&nbsp;<b>CC</b></code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CC(Graph G)</code></td><td>预处理构造函数</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;connected(int v, int w)</code></td><td><code>v</code> 和 <code>w</code> 连通吗</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;count()</code></td><td>连通分量数</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;id(int v)</code></td><td><code>v</code> 所在的连通分量的标识符（<code>0</code>～<code>count()-1</code>）</td></tr>\n</table>\n\n<p>用例可以用 <code>id()</code> 方法将连通分量用数组保存，如框注中的用例所示。它能够从标准输入中读取一幅图并打印其中的连通分量数，其后是每个子图中的所有顶点，每行一个子图。为了实现这些，它使用了一个 <code>Bag</code> 对象数组，然后用每个顶点所在的子图的标识符作为数组的索引，以将所有顶点加入相应的 <code>Bag</code> 对象中。当我们希望独立处理每个连通分量时这个用例就是一个模型。</p>\n<h4>4.1.6.1　实现</h4>\n<p>CC 的实现（请见算法 4.3）使用了 <code>marked[]</code> 数组来寻找一个顶点作为每个连通分量中深度优先搜索的起点。递归的深度优先搜索第一次调用的参数是顶点 <code>0</code>——它会标记所有与 <code>0</code> 连通的顶点。然后构造函数中的 <code>for</code> 循环会查找每个没有被标记的顶点并递归调用 <code>dfs()</code> 来标记和它相邻的所有顶点。另外，它还使用了一个以顶点作为索引的数组 <code>id[]</code>，将同一个连通分量中的顶点和连通分量的标识符关联起来（<code>int</code> 值）。这个数组使得 <code>connected()</code> 方法的实现变得十分简单，和 1.5 节中的 <code>connected()</code> 方法完全相同（只需检查标识符是否相同）。这里，标识符 <code>0</code> 会被赋予第一个连通分量中的所有顶点，<code>1</code> 会被赋予第二个连通分量中的所有顶点，依此类推。这样所有的标识符都会如 API 中指定的那样在 <code>0</code> 到 <code>count()-1</code> 之间。这个约定使得以子图作为索引的数组成为可能，如右侧框注用例所示。</p>\n<pre class=\"code-rows\"><code>public static void main(String[] args)\n{\n   Graph G = new Graph(new In(args[0]));\n   CC cc = new CC(G);\n\n   int M = cc.count();\n   StdOut.println(M + \" components\");\n\n   Bag&lt;Integer&gt;[] components;\n   components = (Bag&lt;Integer&gt;[]) new Bag[M];\n   for (int i = 0; i &lt; M; i++)\n      components[i] = new Bag&lt;Integer&gt;();\n   for (int v = 0; v &lt; G.V(); v++)\n      components[cc.id(v)].add(v);\n   for (int i = 0; i &lt; M; i++)\n   {\n      for (int v: components[i])\n         StdOut.print(v + \" \");\n      StdOut.println();\n   }\n}</code></pre>\n<p style=\"text-align: center\">查找连通分量 API 的测试用例</p>\n<blockquote>\n<p><strong>算法 4.3　使用深度优先搜索找出图中的所有连通分量</strong></p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01506.gif\" alt=\"\" width=\"55%\" style=\"width: 55%\" /></p>\n<p>　</p>\n<pre class=\"code-rows\"><code>% java Graph tinyG.txt\n13 vertices, 13 edges\n0: 6 2 1 5\n1: 0\n2: 0\n3: 5 4\n4: 5 6 3\n5: 3 4 0\n6: 0 4\n7: 8\n8: 7\n9: 11 10 12\n10: 9\n11: 9 12\n12: 11 9\n\n% java CC tinyG.txt\n3 components\n6 5 4 3 2 1 0\n8 7\n12 11 10 9</code></pre>\n<p>这段 <code>Graph</code> 的用例使得它的用例可以独立处理一幅图中的每个连通分量。来自 <code>DepthfirstSearch</code>（请见 4.1.3.2 节）的代码均为灰色。这里的实现是基于一个由顶点索引的数组 <code>id[]</code>。如果 <code>v</code> 属于第 <code>i</code> 个连通分量，则 <code>id[v]</code> 的值为 <code>i</code>。构造函数会找出一个未被标记的顶点并调用递归函数 dfs() 来标记并区分出所有和它连通的顶点，如此重复直到所有的顶点都被标记并区分。<code>connected()</code>、<code>count()</code> 和 <code>id()</code> 方法的实现非常简单（另见图 4.1.21）。</p>\n</blockquote>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01507.gif\" alt=\"\" width=\"80%\" style=\"width: 80%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.1.21　使用深度优先搜索寻找所有连通分量的轨迹</strong></p>\n<blockquote>\n<p><strong>命题 C</strong>。深度优先搜索的预处理使用的时间和空间与 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01485.gif\" alt=\"V+E\" inline-img=\"true\" /> 成正比且可以在常数时间内处理关于图的连通性查询。</p>\n<p><strong>证明</strong>。由代码可以知道每个邻接表的元素都只会被检查一次，共有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01503.gif\" alt=\"2E\" inline-img=\"true\" /> 个元素（每条边两个）。实例方法会检查或者返回一个或两个变量。</p>\n</blockquote>\n<h4>4.1.6.2　union-find 算法</h4>\n<p><code>CC</code> 中基于深度优先搜索来解决图连通性问题的方法与第 1 章中的 union-find 算法相比孰优孰劣？理论上，深度优先搜索比 union-find 算法快，因为它能保证所需的时间是常数而 union-find 算法不行；但在实际应用中，这点差异微不足道。union-find 算法其实更快，因为它不需要完整地构造并表示一幅图。更重要的是，union-find 算法是一种动态算法（我们在任何时候都能用接近常数的时间检查两个顶点是否连通，甚至是在添加一条边的时候），但深度优先搜索则必须要对图进行预处理。因此，我们在完成只需要判断连通性或是需要完成有大量连通性查询和插入操作混合等类似的任务时，更倾向使用 union-find 算法，而深度优先搜索则更适合实现图的抽象数据类型，因为它能更有效地利用已有的数据结构。</p>\n<p>我们已经用深度优先搜索解决了几个非常基础的问题。这种方法很简单，递归实现使我们能够进行复杂的运算并为一些图的处理问题给出简洁的解决方法。在表 4.1.7 中，我们为下面两个问题作出了解答。</p>\n<p><strong>检测环</strong>。<strong>给定的图是无环图吗</strong>？</p>\n<p><strong>双色问题</strong>。<strong>能够用两种颜色将图的所有顶点着色，使得任意一条边的两个端点的颜色都不相同吗？这个问题也等价于：这是一幅二分图吗</strong>？</p>\n<p>深度优先搜索和已学习过的其他算法一样，它简洁的代码下隐藏着复杂的计算。因此，研究这些例子、在样图中跟踪算法的轨迹并加以扩展、用算法来解决环和着色的问题都是非常值得的（留作练习）。</p>\n<p><strong>表 4.1.7　使用深度优先搜索处理图的其他示例</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>任务</p></th>\n<th><p>实现</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>G 是无环图吗？（假设不存在自环或平行边）</p></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01508.gif\" alt=\"\" width=\"90%\" style=\"width: 90%\" inline-img=\"true\" /></p></td>\n</tr>\n<tr>\n<td><p>G 是二分图吗？（双色问题）</p></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01509.gif\" alt=\"{%}\" inline-img=\"true\" /></p></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"nav_point_175\">4.1.7　符号图</h3>\n<p>在典型应用中，图都是通过文件或者网页定义的，使用的是字符串而非整数来表示和指代顶点。为了适应这样的应用，我们定义了拥有以下性质的输入格式：</p>\n<ul>\n<li>顶点名为字符串；</li>\n<li>用指定的分隔符来隔开顶点名（允许顶点名中含有空格）；</li>\n<li>每一行都表示一组边的集合，每一条边都连接着这一行的第一个名称表示的顶点和其他名称所表示的顶点；</li>\n<li>顶点总数 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" /> 和边的总数 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01481.gif\" alt=\"E\" /> 都是隐式定义的。</li>\n</ul>\n<p>图 4.1.22 是一个简单的示例。routes.txt 文件表示的是一个小型运输系统的模型，其中表示每个顶点的是美国机场的代码，连接它们的边则表示顶点之间的航线。文件只是一组边的列表。图 4.1.23 所示的是一个更庞大的例子，取自 movies.txt，即 3.5 节中介绍的<strong>互联网电影数据库</strong>。还记得吗？这个文件的每一行都列出了一个电影名以及出演该部电影的一系列演员。从图的角度来说，我们可以将它看作一幅图的定义，电影和演员都是顶点，而邻接表中的每一条边都将电影和它的表演者联系起来。注意，这是一幅二分图——电影顶点之间或者演员结点之间都没有边相连。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01510.gif\" alt=\"\" width=\"60%\" style=\"width: 60%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.1.22　符号图示例（边的列表）</strong></p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01511.gif\" alt=\"\" width=\"85%\" style=\"width: 85%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.1.23　符号图示例（邻接表）</strong></p>\n<h4>4.1.7.1　API</h4>\n<p>表 4.1.8 中，API 定义的 <code>Graph</code> 用例可以直接使用已有的图算法来处理这种文件定义的图。</p>\n<p><strong>表 4.1.8　用符号作为顶点名的图的 API</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td colspan=\"2\"><code>public class <b>SymbolGraph</b></code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SymbolGraph(String filename, String delim)</code></td><td>根据 <code>filename</code> 指定的文件构造图，使用 <code>delim</code> 来分隔顶点名</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;contains(String key)</code></td><td><code>key</code> 是一个顶点吗</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;index(String key)</code></td><td><code>Key</code> 的索引</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;&nbsp;name(int v)</code></td><td>索引 <code>v</code> 的顶点名</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Graph&nbsp;&nbsp;G()</code></td><td>隐藏的 <code>Graph</code> 对象</td></tr>\n</table>\n\n<p>这份 API 定义了一个构造函数来读取并构造图，用 <code>name()</code> 方法和 <code>index()</code> 方法将输入流中的顶点名和图算法使用的顶点索引对应起来。</p>\n<h4>4.1.7.2　测试用例</h4>\n<p>下一页框注所示的是符号图的测试用例，它用第一个命令行参数指定的文件（第二个命令行参数指定了分隔符）来构造一幅图并从标准输入接受查询。用户可以输入一个顶点名并得到该顶点的相邻结点的列表。这个用例提供的正好是 3.5 节中研究过的反向索引的功能。以 routes.txt 为例，你可以输入一个机场的代码来查找能从该机场直飞到达的城市，但这些信息并不是直接就能从文件中得到的。对于 movies.txt，你可以输入一个演员的名字来查看数据库中他所出演的影片列表。输入一部电影的名字来得到它的演员列表，这不过是在照搬文件中对应行数据，但输入演员的名字来得到影片的列表则相当于查找反向索引。尽管数据库的构造是为了将电影名连接到演员，二分图模型同时也意味着将演员连接到电影名。二分图的性质自动完成了反向索引。以后我们将会看到，这将成为处理更复杂的和图有关的问题的基础。</p>\n<pre class=\"code-rows\"><code>public static void main(String[] args)\n{\n   String filename = args[0];\n   String delim = args[1];\n   SymbolGraph sg = new SymbolGraph(filename, delim);\n\n   Graph G = sg.G();\n\n   while (StdIn.hasNextLine())\n   {\n      String source = StdIn.readLine();\n      for (int w : G.adj(sg.index(source)))\n         StdOut.println(\"   \" + sg.name(w));\n   }\n}</code></pre>\n<p style=\"text-align: center\">符号图 API 的测试用例</p>\n<pre class=\"code-rows\"><code>% java SymbolGraph routes.txt \" \"\nJFK\n   ORD\n   ATL\n   MCO\nLAX\n   LAS\n   PHX</code></pre>\n<p>　</p>\n<pre class=\"code-rows\"><code>% java SymbolGraph movies.txt \"/\"\nTin Men (1987)\n   DeBoy, David\n   Blumenfeld, Alan\n   ...\n   Geppi, Cindy\n   Hershey, Barbara\n   ...\nBacon, Kevin\n   Mystic River (2003)\n   Friday the 13th (1980)\n   Flatliners (1990)\n   Few Good Men, A (1992)\n   ...</code></pre>\n<p>很显然，这种方法适用于我们遇到过的所有图算法：用例可以用 <code>index()</code> 将顶点名转化为索引并在图的处理算法中使用，然后将处理结果用 <code>name()</code> 转化为顶点名以方便在实际应用中使用。</p>\n<h4>4.1.7.3　实现</h4>\n<p><code>SymbolGraph</code> 的完整实现请见下面的框注“符号图的数据类型”。它用到了以下 3 种数据结构，参见图 4.1.24。</p>\n<ul>\n<li>一个符号表 <code>st</code>，键的类型为 <code>String</code>（顶点名），值的类型为 <code>int</code>（索引）；</li>\n<li>一个数组 <code>keys[]</code>，用作反向索引，保存每个顶点索引所对应的顶点名；</li>\n<li>一个 <code>Graph</code> 对象 <code>G</code>，它使用索引来引用图中顶点。</li>\n</ul>\n<p><code>SymbolGraph</code> 会遍历两遍数据来构造以上数据结构，这主要是因为构造 <code>Graph</code> 对象需要顶点总数 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" />。在典型的实际应用中，在定义图的文件中指明 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01481.gif\" alt=\"E\" inline-img=\"true\" />（见本节开头 <code>Graph</code> 的构造函数）可能会有些不便，而有了 <code>SymbolGraph</code>，我们就可以方便地在 routes.txt 或者 movies.txt 中添加或者删除条目而不用担心需要维护边或顶点的总数。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01512.gif\" alt=\"\" width=\"95%\" style=\"width: 95%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.1.24　符号图中用到的数据结构</strong></p>\n<blockquote>\n<p><strong>符号图的数据类型</strong></p>\n<pre class=\"code-rows\"><code>public class SymbolGraph\n{\n   private ST&lt;String, Integer&gt; st;              // 符号名 → 索引\n   private String[] keys;                       // 索引 → 符号名\n   private Graph G;                             // 图\n\n   public SymbolGraph(String stream, String sp)\n   {\n      st = new ST&lt;String, Integer&gt;();\n      In in = new In(stream);                   // 第一遍\n      while (in.hasNextLine())                  // 构造索引\n      {\n         String[] a = in.readLine().split(sp);  // 读取字符串\n\n         for (int i = 0; i &lt; a.length; i++)     // 为每个不同的字符串关联一个索引\n            if (!st.contains(a[i]))\n\n               st.put(a[i], st.size());\n      }\n      keys = new String[st.size()];             // 用来获得顶点名的反向索引是一个数组\n\n      for (String name : st.keys())\n         keys[st.get(name)] = name;\n\n      G = new Graph(st.size());\n      in = new In(stream);                      // 第二遍\n      while (in.hasNextLine())                  // 构造图\n      {\n         String[] a = in.readLine().split(sp);  // 将每一行的第一个顶点和该行的其他顶点相连\n         int v = st.get(a[0]);\n         for (int i = 1; i &lt; a.length; i++)\n            G.addEdge(v, st.get(a[i]));\n      }\n   }\n\n   public boolean contains(String s) {  return st.contains(s);  }\n   public int index(String s)        {  return st.get(s);  }\n   public String name(int v)         {  return keys[v];  }\n   public Graph G()                  {  return G;  }\n}</code></pre>\n<p>这个 <code>Graph</code> 实现允许用例用字符串代替数字索引来表示图中的顶点。它维护了实例变量 <code>st</code>（符号表用来映射顶点名和索引）、<code>keys</code>（数组用来映射索引和顶点名）和 <code>G</code>（使用索引表示顶点的图）。为了构造这些数据结构，代码会将图的定义处理两遍（定义的每一行都包含一个顶点及它的相邻顶点列表，用分隔符 <code>sp</code> 隔开）。</p>\n</blockquote>\n<h4>4.1.7.4　间隔的度数</h4>\n<p>图处理的一个经典问题就是，找到一个社交网络之中两个人间隔的度数。为了弄清楚概念，我们用一个最近很流行的名为 <em>Kevin Bacon</em> 的游戏来说明这个问题。这个游戏用到了刚才讨论的“电影 - 演员”图。Kevin Bacon 是一个活跃的演员，曾出演过许多电影。我们为图中的每个演员赋一个 Kevin Bacon <strong>数</strong>：Bacon 本人为 0，所有和 Kevin Bacon 出演过同一部电影的人的值为 1，所有（除了 Kevin Bacon）和 Kevin Bacon 数为 1 的演员出演过同一部电影的其他演员的值为 2，依次类推。例如，Meryl Streep 的 Kevin Bacon 数为 1，因为她和 Kevin Bacon 一同出演过 <em>The River Wild</em>。Nicole Kidman 的值为 2，因为她虽然没有和 Kevin Bacon 同台演出过任何电影，但她和 Tom Cruise 一起演过 <em>Days of Thunder</em>，而 Tom Cruise 和 Kevin Bacon 一起演过 <em>A Few Good Men</em>。给定一个演员的名字，游戏最简单的玩法就是找出一系列的电影和演员来回溯到 Kevin Bacon。例如，有些影迷可能知道 Tom Hanks 和 Lloyd Bridges 一起演过 <em>Joe Versus the Volcano</em>，而 Bridges 和 Grace Kelly 一起演过 <em>High Noon</em>，Kelly 又和 Patrick Allen 一起演过 <em>Dial M for Murder</em>，Allen 和 Donald Sutherland 一起演过 <em>The Eagle has Landed</em>，Sutherland 和 Kevin Bacon 一起出演了 <em>Animal House</em>。但知道这些也并不足以确定 Tom Hanks 的 Kevin Bacon 数。（他的值实际上应该是 1，因为他和 Kevin Bacon 在 <em>Apollo 13</em> 中合作过）。你可以看到 Kevin Bacon 数必须定义为<strong>最短</strong>电影链的长度，因此如果不用计算机，人们很难知道游戏中到底谁赢了。当然，如后面框注“间隔的度数”中 <code>SymbolGraph</code> 的用例 <code>DegreesOfSeparation</code> 所示，<code>BreadthFirstPaths</code> 才是我们所要的程序，它通过最短路径来找出 movies.txt 中任意演员的 Kevin Bacon 数。这个程序从命令行得到一个起点，从标准输入中接受查询并打印出一条从起点到被查询顶点的最短路径。因为 movies.txt 所构造的是一幅二分图，每条路径上都会交替出现电影和演员的顶点。打出的结果可以证明这样的路径是存在的（但并不能证明它是最短的——你需要向你的朋友证明命题 B 才行）。<code>DegreesOfSeparation</code> 也能够在非二分图中找到最短路径。例如，在 routes.txt 中，它能够用最少的边找到一种从一个机场到达另一个机场的方法。</p>\n<pre class=\"code-rows\"><code>% java DegreesOfSeparation movies.txt \"/\" \"Bacon, Kevin\"\nKidman, Nicole\n   Bacon, Kevin\n   Woodsman,The(2004)\n   Grier,David Alan\n   Bewitched(2005)\n   Kidman, Nicole\nGrant, Cary\nBacon, Kevin\n   Planes,Trains Automobiles(1987)\n   Martin,Steve(I)\n   Dead Men Don't Wear Plaid(1982)\n   Grant, Cary</code></pre>\n<p>你可能会发现用 <code>DegreesOfSeparation</code> 来回答一些关于电影行业的问题很有趣。例如，你不但可以找到演员和演员之间的间隔，还可以找到电影和电影之间的间隔。更重要的是，间隔的概念在其他许多领域也被广泛研究。例如，数学家也会玩这个游戏，但他们的图是用一些论文的作者到 P.Erdös（20 世纪的一位多产的数学家）的距离来定义的。类似地，似乎新泽西州的每个人的 Bruce Springsteen 数都为 2，因为每个人都声称自己认识某个认识 Bruce 的人。要玩 Erdös 的游戏，你需要一个包含所有数学论文的数据库；要玩 Sprintsteen 的游戏还要困难一些。从更严肃的角度来说，间隔度数的理论在计算机网络的设计以及理解各个科学领域中的自然网络中都能起到重要的作用。</p>\n<pre class=\"code-rows\"><code>% java DegreesOfSeparation movies.txt \"/\" \"Animal House (1978)\"\nTitanic (1997)\n   Animal House (1978)\n   Allen, Karen (I)\n   Raiders of the Lost Ark (1981)\n   Taylor, Rocky (I)\n   Titanic (1997)\nTo Catch a Thief (1955)\n   Animal House (1978)\n   Vernon, John (I)\n   Topaz (1969)\n   Hitchcock, Alfred (I)\n   To Catch a Thief (1955)</code></pre>\n<blockquote>\n<p><strong>间隔的度数</strong></p>\n<pre class=\"code-rows\"><code>public class DegreesOfSeparation\n{\n   public static void main(String[] args)\n   {\n      SymbolGraph sg = new SymbolGraph(args[0], args[1]);\n\n      Graph G = sg.G();\n\n      String source = args[2];\n      if (!sg.contains(source))\n      {  StdOut.println(source + \"not in database.\"); return;  }\n\n      int s = sg.index(source);\n      BreadthFirstPaths bfs = new BreadthFirstPaths(G, s);\n\n      while (!StdIn.isEmpty())\n      {\n         String sink = StdIn.readLine();\n         if (sg.contains(sink))\n         {\n            int t = sg.index(sink);\n            if (bfs.hasPathTo(t))\n               for (int v : bfs.pathTo(t))\n                  StdOut.println(\"   \" + sg.name(v));\n            else StdOut.println(\"Not connected\");\n         }\n         else StdOut.println(\"Not in database.\");\n      }\n   }\n}</code></pre>\n<p>　</p>\n<pre class=\"code-rows\"><code>% java DegreesOfSeparation routes.txt \" \" JFK\nLAS\n   JFK\n   ORD\n   PHX\n   LAS\nDFW\n   JFK\n   ORD\n   DFW</code></pre>\n<p>这段代码使用了 <code>SymbolGraph</code> 和 <code>BreadthFirstPaths</code> 来查找图中的最短路径。对于 movies.txt，可以用它来玩 Kevin Bacon 游戏。</p>\n</blockquote>\n<h3 id=\"nav_point_176\">4.1.8　总结</h3>\n<p>在本节中，我们介绍了几个基本的概念，本章的其余部分会继续扩展并研究：</p>\n<ul>\n<li>图的术语；</li>\n<li>一种图的表示方法，能够处理大型而稀疏的图；</li>\n<li>和图处理相关的类的设计模式，其实现算法通过在相关的类的构造函数中对图进行预处理、构造所需的数据结构来高效支持用例对图的查询；</li>\n<li>深度优先搜索和广度优先搜索；</li>\n<li>支持使用符号作为图的顶点名的类。</li>\n</ul>\n<p>表 4.1.9 总结了我们已经学习过的所有图算法的实现。这些算法非常适合作为图处理的入门学习。随后学习更加复杂类型的图以及处理更加困难的问题时，我们还会用到这些代码的变种。在考虑了边的方向以及权重之后，同样的问题会变得困难得多，但同样的算法仍然奏效并将成为解决更加复杂问题的起点。</p>\n<p><strong>表 4.1.9　本节中得到解决的无向图处理问题</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>问题</p></th>\n<th><p>解决方法</p></th>\n<th><p>参阅</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>单点连通性</p></td>\n<td><p><code>DepthFirstSearch</code></p></td>\n<td><p>4.1.3.2 节</p></td>\n</tr>\n<tr>\n<td><p>单点路径</p></td>\n<td><p><code>DepthFirstPaths</code></p></td>\n<td><p>算法 4.1</p></td>\n</tr>\n<tr>\n<td><p>单点最短路径</p></td>\n<td><p><code>BreadthFirstPaths</code></p></td>\n<td><p>算法 4.2</p></td>\n</tr>\n<tr>\n<td><p>连通性</p></td>\n<td><p><code>CC</code></p></td>\n<td><p>算法 4.3</p></td>\n</tr>\n<tr>\n<td><p>检测环</p></td>\n<td><p><code>Cycle</code></p></td>\n<td><p>表 4.1.7</p></td>\n</tr>\n<tr>\n<td><p>双色问题（图的二分性）</p></td>\n<td><p><code>TwoColor</code></p></td>\n<td><p>表 4.1.7</p></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"nav_point_177\">答疑</h3>\n<p><strong>问</strong>　为什么不把所有的算法都实现在 Graph.java 中？</p>\n<p><strong>答</strong>　可以这么做，可以向基本的 <code>Graph</code> 抽象数据类型的定义中添加查询方法（以及它们需要的私有变量和方法等）。尽管这种方式可以用到一些我们所使用的数据结构的优点，它还是有一些严重的缺陷，因为图处理的成本比 1.3 节中遇到那些基本数据结构要高得多。这些缺点主要有：</p>\n<ul>\n<li>在图处理中，需要实现的操作还有很多，我们无法在一份 API 中全部精确地定义它们；</li>\n<li>简单任务的 API 和复杂任务所使用的 API 是相同的；</li>\n<li>一个方法将可以访问另外一个方法专用的变量，这有悖我们需要遵守的封装原则。</li>\n</ul>\n<p>这种情况并不罕见：这种 API 被称为<strong>宽</strong>接口（请见 1.2.5.2 节）。本章包含如此众多的图算法，将导致这种 API 变得非常宽。</p>\n<p><strong>问</strong>　<code>SymbolGraph</code> 真需要将图的定义遍历两遍吗？</p>\n<p><strong>答</strong>　不，你也可以将用时变为原来的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01513.gif\" alt=\"\\lg V\" inline-img=\"true\" /> 倍并直接用 <code>ST</code> 而非 <code>Bag</code> 来实现 <code>adj()</code>。我们的另一本书 <em>An Introduction to Programming in Java: An Interdisciplinary Approach</em> 中含有使用这种方法的一个实现。</p>\n<h3 id=\"nav_point_178\">练习</h3>\n<p><strong>4.1.1</strong>　一幅含有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 个顶点且不含有平行边的图中至多含有多少条边？一幅含有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 个顶点的连通图中至少含有多少条边？</p>\n<p><strong>4.1.2</strong>　按照正文中示意图的样式（请见图 4.1.9）画出 <code>Graph</code> 的构造函数在处理图 4.1.25 的 tinyGex2.txt 时构造的邻接表。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01514.gif\" alt=\"\" width=\"50%\" style=\"width: 50%\" /></p>\n<p><strong>图　4.1.25</strong></p>\n<p><strong>4.1.3</strong>　为 <code>Graph</code> 添加一个复制构造函数，它接受一幅图 <code>G</code> 然后创建并初始化这幅图的一个副本。<code>G</code> 的用例对它作出的任何改动都不应该影响到它的副本。</p>\n<p><strong>4.1.4</strong>　为 <code>Graph</code> 添加一个方法 <code>hasEdge()</code>，它接受两个整型参数 <code>v</code> 和 <code>w</code>。如果图含有边 <code>v-w</code>，方法返回 <code>true</code>，否则返回 <code>false</code>。</p>\n<p><strong>4.1.5</strong>　修改 <code>Graph</code>，不允许存在平行边和自环。</p>\n<p><strong>4.1.6</strong>　有一张含有四个顶点的图，其中的边为 <code>0-1</code>、<code>1-2</code>、<code>2-3</code> 和 <code>3-0</code>。给出一种邻接表数组，无论以任何顺序调用 <code>addEdge()</code> 来添加这些边都无法创建它。</p>\n<p><strong>4.1.7</strong>　为 <code>Graph</code> 编写一个测试用例，用命令行参数指定名字的输入流中接受一幅图，然后用 <code>toString()</code> 方法将其打印出来。</p>\n<p><strong>4.1.8</strong>　按照正文中的要求，用 union-find 算法实现 4.1.2.3 中搜索的 API。</p>\n<p><strong>4.1.9</strong>　使用 <code>dfs(0)</code> 处理由 <code>Graph</code> 的构造函数从 tinyGex2.txt（请见练习 4.1.2）得到的图并按照 4.1.3.5 节的图 4.1.14 的样式给出详细的轨迹。同时，画出 <code>edgeTo[]</code> 所表示的树。</p>\n<p><strong>4.1.10</strong>　证明在任意一幅连通图中都存在一个顶点，删去它（以及和它相连的所有边）不会影响到图的连通性，编写一个深度优先搜索的方法找出这样一个顶点。<strong>提示</strong>：留心那些相邻顶点全部都被标记过的顶点。</p>\n<p><strong>4.1.11</strong>　使用算法 4.2 中的 <code>bfs(G,0)</code> 处理由 <code>Graph</code> 的构造函数从 tinyGex2.txt（请见练习 4.1.2）得到的图并画出 <code>edgeTo[]</code> 所表示的树。</p>\n<p><strong>4.1.12</strong>　如果 <code>v</code> 和 <code>w</code> 都不是根结点，能够由广度优先搜索得到的树中计算它们之间的距离吗？</p>\n<p><strong>4.1.13</strong>　为 <code>BreadthFirstPaths</code> 的 API 添加并实现一个方法 <code>distTo()</code>，返回从起点到给定的顶点的最短路径的长度，它所需的时间应该为常数。</p>\n<p><strong>4.1.14</strong>　如果用栈代替队列来实现广度优先搜索，我们还能得到最短路径吗？</p>\n<p><strong>4.1.15</strong>　修改 <code>Graph</code> 的输入流构造函数，允许从标准输入读入图的邻接表（方法类似于 <code>SymbolGraph</code>），如图 4.1.26 的 tinyGadj.txt 所示。在顶点和边的总数之后，每一行由一个顶点和它的所有相邻顶点组成。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01515.gif\" alt=\"\" width=\"60%\" style=\"width: 60%\" /></p>\n<p><strong>图　4.1.26</strong></p>\n<p><strong>4.1.16</strong>　顶点 <code>v</code> 的<strong>离心率</strong>是它和离它最远的顶点的最短距离。图的<strong>直径</strong>即所有顶点的最大离心率，<strong>半径</strong>为所有顶点的最小离心率，<strong>中点</strong>为离心率和半径相等的顶点。实现以下 API，如表 4.1.10 所示。</p>\n<p><strong>表 4.1.10</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td colspan=\"2\"><code>public class&nbsp;&nbsp;<b>GraphProperties</b></code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GraphProperties(Graph G)</code></td><td>构造函数（如果 <code>G</code> 不是连通的，抛出异常）</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;eccentricity(int v)</code></td><td><code>v</code> 的离心率</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;diameter()</code></td><td><code>G</code> 的直径</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;radius()</code></td><td><code>G</code> 的半径</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;center()</code></td><td><code>G</code> 的某个中点</td></tr>\n</table>\n\n<p><strong>4.1.17</strong>　图的<strong>周长</strong>为图中最短环的长度。如果是无环图，则它的周长为无穷大。为 <code>GraphProperties</code> 添加一个方法 <code>girth()</code>，返回图的周长。<strong>提示</strong>：在每个顶点都进行广度优先搜索。含有 <code>s</code> 的最小环为 <code>s</code> 到某个顶点 <code>v</code> 的最短路径加上从 <code>v</code> 返回到 <code>s</code> 的边。</p>\n<p><strong>4.1.18</strong>　使用 <code>CC</code> 找出由 <code>Graph</code> 的输入流构造函数从 tinyGex2.txt（请见练习 4.1.2）得到的图中的所有连通分量并按照图 4.1.21 的样式给出详细的轨迹。</p>\n<p><strong>4.1.19</strong>　使用 <code>Cycle</code> 在由 <code>Graph</code> 的输入流构造函数从 tinyGex2.txt（请见练习 4.1.2）得到的图中找到的一个环并按照本节示意图的样式给出详细的轨迹。在最坏情况下，<code>Cycle</code> 构造函数的运行时间的增长数量级是多少？</p>\n<p><strong>4.1.20</strong>　使用 <code>TwoColor</code> 给出由 <code>Graph</code> 的构造函数从 tinyGex2.txt（请见练习 4.1.2）得到的图的一个着色方案并按照本节示意图的样式给出详细的轨迹。在最坏情况下，<code>TwoColor</code> 构造函数的运行时间的增长数量级是多少？</p>\n<p><strong>4.1.21</strong>　用 <code>SymbolGraph</code> 和 movie.txt 找到今年获得奥斯卡奖提名的演员的 Kevin Bacon 数。</p>\n<p><strong>4.1.22</strong>　编写一段程序 <code>BaconHistogram</code>，打印一幅 Kevin Bacon 数的柱状图，显示 movies.txt 中 Kevin Bacon 数为 0、1、2、3……的演员分别有多少。将值为无穷大的人（不与 Kevin Bacon 连通）归为一类。</p>\n<p><strong>4.1.23</strong>　计算由 movies.txt 得到的图的连通分量的数量和包含的顶点数小于 10 的连通分量的数量。计算最大的连通分量的离心率、直径、半径和中点。Kevin Bacon 在最大的连通分量之中吗？</p>\n<p><strong>4.1.24</strong>　修改 <code>DegreesOfSeparation</code>，从命令行接受一个整型参数 <code>y</code>，忽略上映年数超过 <code>y</code> 的电影。</p>\n<pre class=\"code-rows\"><code>% java DegreesOfSeparationDFS movies.txt\nSource: Bacon, Kevin\nQuery:  Kidman, Nicole\n   Bacon, Kevin\n   Mystic River (2003)\n   O’Hara, Jenny\n   Matchstick Men (2003)\n   Grant, Beth\n  ... [123 movies ] (!)\n   Law, Jude\n   Sky Captain... (2004)\n   Jolie, Angelina\n   Playing by Heart (1998)\n   Anderson, Gillian (I)\n   Cock and Bull Story, A (2005)\n   Henderson, Shirley (I)\n   24 Hour Party People (2002)\n   Eccleston, Christopher\n   Gone in Sixty Seconds (2000)\n   Balahoutis, Alexandra\n   Days of Thunder (1990)\n   Kidman, Nicole</code></pre>\n<p><strong>4.1.25</strong>　编写一个类似于 <code>DegreesOfSeparation</code> 的 <code>SymbolGraph</code> 用例，使用<strong>深度优先搜索</strong>代替广度优先搜索来查找两个演员之间的路径，输出类似右侧框注所示的数据。</p>\n<p><strong>4.1.26</strong>　使用 1.4 节中的内存使用模型评估用 <code>Graph</code> 表示一幅含有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 个顶点和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01481.gif\" alt=\"E\" inline-img=\"true\" /> 条边的图所需的内存。</p>\n<p><strong>4.1.27</strong>　如果重命名一幅图中的顶点就能够使之变得和另一幅图完全相同，这两幅图就是<strong>同构</strong>的。画出含有 2、3、4、5 个顶点的所有非同构的图。</p>\n<p><strong>4.1.28</strong>　修改 <code>Cycle</code>，允许图含有自环和平行边。</p>\n<h3 id=\"nav_point_179\">提高题</h3>\n<p><strong>4.1.29</strong>　<strong>欧拉环</strong>和<strong>汉密尔顿环</strong>。考虑以下 4 组边定义的图：</p>\n<pre class=\"code-rows\"><code>0-1 0-2 0-3 1-3 1-4 2-5 2-9 3-6 4-7 4-8 5-8 5-9 6-7 6-9 7-8\n0-1 0-2 0-3 1-3 0-3 2-5 5-6 3-6 4-7 4-8 5-8 5-9 6-7 6-9 8-8\n0-1 1-2 1-3 0-3 0-4 2-5 2-9 3-6 4-7 4-8 5-8 5-9 6-7 6-9 7-8\n4-1 7-9 6-2 7-3 5-0 0-2 0-8 1-6 3-9 6-3 2-8 1-5 9-8 4-5 4-7</code></pre>\n<p>　哪几幅图含有欧拉环（恰好包含了所有的边且没有重复的环）？哪几幅图含有汉密尔顿环（恰好包含了所有的顶点且没有重复的环）？</p>\n<p><strong>4.1.30</strong>　<strong>图的枚举</strong>。含有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 个顶点和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01481.gif\" alt=\"E\" inline-img=\"true\" /> 条边（不含平行边）的不同的无向图共有多少种？</p>\n<p><strong>4.1.31</strong>　<strong>检测平行边</strong>。设计一个线性时间的算法来统计图中的平行边的总数。</p>\n<p><strong>4.1.32</strong>　<strong>奇环</strong>。证明一幅图能够用两种颜色着色（二分图）当且仅当它不含有长度为奇数的环。</p>\n<p><strong>4.1.33</strong>　<strong>符号图</strong>。实现一个 <code>SymbolGraph</code>（不一定必须使用 <code>Graph</code>），只需要遍历一遍图的定义数据。由于需要查找符号表，实现中图的各种操作时耗可能会变为原来的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01487.gif\" alt=\"\\log V\" inline-img=\"true\" /> 倍。</p>\n<p><strong>4.1.34</strong>　<strong>双向连通性</strong>。如果任意一对顶点都能由两条不同（没有重叠的边或顶点）的路径连通则图就是<strong>双向连通</strong>的。在一幅连通图中，如果一个顶点（以及和它相连的边）被删掉后图不再连通，该顶点就被称为<strong>关节点</strong>。证明没有关节点的图是双向连通的。<strong>提示</strong>：给定任意一对顶点 <code>s</code> 和 <code>t</code> 和一条连接两点的路径，由于路径上没有任何顶点为关节点，构造另一条不同的路径连接 <code>s</code> 和 <code>t</code>。</p>\n<p><strong>4.1.35</strong>　<strong>边的连通性</strong>。在一幅连通图中，如果一条边被删除后图会被分为两个独立的连通分量，这条边就被称为<strong>桥</strong>。没有桥的图称为<strong>边连通</strong>图。开发一种基于深度优先搜索算法的数据类型，判断一个图是否是边连通图。</p>\n<p><strong>4.1.36</strong>　<strong>欧几里得图</strong>。为平面上的图设计并实现一份叫做 <code>EuclideanGraph</code> 的 API，其中图所有顶点均有坐标。实现一个 <code>show()</code> 方法，用 <code>StdDraw</code> 将图绘出。</p>\n<p><strong>4.1.37</strong>　<strong>图像处理</strong>。在一幅图像中将所有相邻的、颜色相同的点相连就可以得到一幅图，为这种隐式定义的图实现<strong>填充</strong>（flood fill）操作。</p>\n<h3 id=\"nav_point_180\">实验题</h3>\n<p><strong>4.1.38</strong>　<strong>随机图</strong>。编写一个程序 <code>ErdosRenyiGraph</code>，从命令行接受整数 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01481.gif\" alt=\"E\" inline-img=\"true\" />，随机生成 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01481.gif\" alt=\"E\" inline-img=\"true\" /> 对 0 到 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01468.gif\" alt=\"V-1\" inline-img=\"true\" /> 之间的整数来构造一幅图。<strong>注意</strong>：生成器可能会产生自环和平行边。</p>\n<p><strong>4.1.39</strong>　<strong>随机简单图</strong>。编写一个程序 <code>RandomSimpleGraph</code>，从命令行接受整数 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01481.gif\" alt=\"E\" inline-img=\"true\" />，用均等的几率生成含有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 个顶点和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01481.gif\" alt=\"E\" inline-img=\"true\" /> 条边的所有可能的简单图。</p>\n<p><strong>4.1.40</strong>　<strong>随机稀疏图</strong>。编写一个程序 <code>RandomSparseGraph</code>，根据精心选择的一组 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01481.gif\" alt=\"E\" inline-img=\"true\" /> 的值生成随机的稀疏图，以便用它对由 Erdös-Renyi 模型得到的图进行有意义的经验性测试。</p>\n<p><strong>4.1.41</strong>　<strong>随机欧几里得图</strong>。编写一个 <code>EuclideanGraph</code> 的用例（请见练习 4.1.36）<code>RandomEuclideanGraph</code>，用随机在平面上生成 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 个点的方式生成随机图，然后将每个点和在以该点为中心半径为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01229.gif\" alt=\"d\" inline-img=\"true\" /> 的圆内的其他点相连。<strong>注意</strong>：如果 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01229.gif\" alt=\"d\" inline-img=\"true\" /> 大于阈值 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01516.jpeg\" alt=\"\\sqrt{{\\rm\\\" inline-img=\"true\" />，那么得到的图几乎必然是连通的，否则得到的图几乎必然是不连通的。</p>\n<p><strong>4.1.42</strong>　<strong>随机网格图</strong>。编写一个 <code>EuclideanGraph</code> 的用例 <code>RandomGridGraph</code>，将 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01517.gif\" alt=\"\\sqrt\" inline-img=\"true\" /> 乘 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01517.gif\" alt=\"\\sqrt\" inline-img=\"true\" /> 的网格中的所有顶点和它们的相邻顶点相连（参考练习 1.5.18）。修改代码为图额外添加 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01027.gif\" alt=\"R\" inline-img=\"true\" /> 条随机的边。对于较大的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01027.gif\" alt=\"R\" inline-img=\"true\" />，缩小网格使得总边数保持在 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 个左右。添加一个选项，使得出现一条从顶点 <code>s</code> 到顶点 <code>v</code> 的边的概率与 <code>s</code> 到 <code>t</code> 的欧几里得距离成反比。</p>\n<p><strong>4.1.43</strong>　<strong>真实世界中的图</strong>。从网上找出一幅巨型加权图——可以是一张标记了距离的地图，或者是标明了费用的电话连接，或是航班价目表。编写一段程序 <code>RandomRealGraph</code>，从这幅图中随机迭取 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 个顶点，然后再从这些顶点构成的子图中随机选取 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01481.gif\" alt=\"E\" inline-img=\"true\" /> 条边来构造一幅图。</p>\n<p><strong>4.1.44</strong>　<strong>随机区间图</strong>。考虑数轴上的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 个区间的集合。这样的一个集合定义了一幅<strong>区间图</strong>，图中的每个顶点都对应一个区间，而边则对应两个区间的交集（大小不限）。编写一段程序，随机生成大小均为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01229.gif\" alt=\"d\" inline-img=\"true\" /> 的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 个区间，然后构造相应的区间图。<strong>提示</strong>：使用二分查找树。</p>\n<p><strong>4.1.45</strong>　<strong>随机运输图</strong>。定义运输系统的一种方法是定义一个顶点链的集合，每条顶点链都表示一条连接了多个顶点的路径。例如，链 <code>0-9-3-2</code> 定义了边 <code>0-9</code>、<code>9-3</code> 和 <code>3-2</code>。编写一个 <code>EuclideanGraph</code> 的用例 <code>RandomTransportation</code>，从一个输入文件中构造一幅图，文件的每行均为一条链，使用符号名。编辑一份合适的输入使得程序能够从中构造一幅和巴黎地铁系统相对应的图。</p>\n<blockquote>\n<p>测试所有的算法并研究所有图模型的所有参数是不现实的。请为下面的每一道题都编写一段程序来处理从输入得到的任意图。这段程序可以调用上面的任意生成器并对相应的图模型进行实验。可以根据上次实验的结果自己作出判断来选择不同实验。陈述结果以及由此得出的任何结论。</p>\n</blockquote>\n<p><strong>4.1.46</strong>　<strong>深度优先搜索中的路径长度</strong>。对于各种图的模型，运行实验并根据经验判断 <code>DepthFirstPaths</code> 在两个随机选定的顶点之间找到一条路径的概率并计算找到的路径的平均长度。</p>\n<p><strong>4.1.47</strong>　<strong>广度优先搜索中的路径长度</strong>。对于各种图的模型，运行实验并根据经验判断 <code>BreadthFirstPaths</code> 在两个随机选定的顶点之间找到一条路径的概率并计算找到的路径的平均长度。</p>\n<p><strong>4.1.48</strong>　<strong>连通分量</strong>。运行实验随机生成大量的图并画出柱状图，根据经验判断各种类型的随机图中连通分量的数量的分布情况。</p>\n<p><strong>4.1.49</strong>　<strong>双色问题</strong>。大多数的图都无法用两种颜色着色，深度优先搜索能够很快发现这一点。对于各种图模型，使用经验性的测试来研究 <code>TwoColor</code> 检查的边的数量。</p>\n","neighbors":{"left":{"article_title":"3.5 应用","id":740945},"right":{"article_title":"4.2 有向图","id":740947}},"comments":[]}