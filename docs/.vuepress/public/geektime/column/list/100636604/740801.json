{"id":740801,"title":"第 2 章 Rust 导览(2)","content":"<p>为了让我们的程序接收一系列数值作为命令行参数并打印出它们的最大公约数，可以将 src/main.rs 中的 <code>main</code> 函数替换为以下内容：</p>\n<pre class=\"code-rows\"><code>use std::str::FromStr;\nuse std::env;\n\nfn main() {\n    let mut numbers = Vec::new();\n\n    for arg in env::args().skip(1) {\n        numbers.push(u64::from_str(&amp;arg)\n                     .expect(\"error parsing argument\"));\n    }\n\n    if numbers.len() == 0 {\n        eprintln!(\"Usage: gcd NUMBER ...\");\n        std::process::exit(1);\n    }\n\n    let mut d = numbers[0];\n    for m in &amp;numbers[1..] {\n        d = gcd(d, *m);\n    }\n\n    println!(\"The greatest common divisor of {:?} is {}\",\n             numbers, d);\n}</code></pre>\n<p>我们来逐段分析一下：</p>\n<pre class=\"code-rows\"><code>use std::str::FromStr;\nuse std::env;</code></pre>\n<p>第一个 <code>use</code> 声明将标准库中的 <code>FromStr</code> <strong>特型</strong>引入了当前作用域。特型是可以由类型实现的方法集合。任何实现了 <code>FromStr</code> 特型的类型都有一个 <code>from_str</code> 方法，该方法会尝试从字符串中解析这个类型的值。<code>u64</code> 类型实现了 <code>FromStr</code>，所以我们将调用 <code>u64::from_str</code> 来解析程序中的命令行参数。尽管我们从未在程序的其他地方用到 <code>FromStr</code> 这个名字，但仍然要 <code>use</code>（使用）它，因为要想使用某个特型的方法，该特型就必须在作用域内。第 11 章会详细介绍特型。</p>\n<p>第二个 <code>use</code> 声明引入了 <code>std::env</code> 模块，该模块提供了与执行环境交互时会用到的几个函数和类型，包括 <code>args</code> 函数，该函数能让我们访问程序中的命令行参数。</p>\n<p>继续看程序中的 <code>main</code> 函数：</p>\n<pre class=\"code-rows\"><code>fn main() {</code></pre>\n<p><code>main</code> 函数没有返回值，所以可以简单地省略 <code>-&gt;</code> 和通常会跟在参数表后面的返回类型。</p>\n<pre class=\"code-rows\"><code>let mut numbers = Vec::new();</code></pre>\n<p>我们声明了一个可变的局部变量 <code>numbers</code> 并将其初始化为空向量。<code>Vec</code> 是 Rust 的可增长向量类型，类似于 C++ 的 <code>std::vector</code>、Python 的列表或 JavaScript 的数组。虽然从设计上说向量可以动态扩充或收缩，但仍然要标记为 <code>mut</code>，这样 Rust 才能把新值压入末尾。</p><!-- [[[read_end]]] -->\n<p><code>numbers</code> 的类型是 <code>Vec&lt;u64&gt;</code>，这是一个可以容纳 <code>u64</code> 类型的值的向量，但和以前一样，不需要把类型写出来。Rust 会推断它，一部分原因是我们将 <code>u64</code> 类型的值压入了此向量，另一部分原因是我们将此向量的元素传给了 <code>gcd</code>，后者只接受 <code>u64</code> 类型的值。</p>\n<pre class=\"code-rows\"><code>for arg in env::args().skip(1) {</code></pre>\n<p>这里使用了 <code>for</code> 循环来处理命令行参数，依次将变量 <code>arg</code> 指向每个参数并运行循环体。</p>\n<p><code>std::env</code> 模块的 <code>args</code> 函数会返回一个<strong>迭代器</strong>，此迭代器会按需生成<span class=\"comment-number\">1</span>每个参数，并在完成时给出提示。各种迭代器在 Rust 中无处不在，标准库中也包括一些迭代器，这些迭代器可以生成向量的元素、文件每一行的内容、通信信道上接收到的信息，以及几乎任何有意义的循环变量。Rust 的迭代器非常高效，编译器通常能将它们翻译成与手写循环相同的代码。第 15 章会展示迭代器的工作原理并给出相关示例。</p>\n\n<p>除了与 <code>for</code> 循环一起使用，迭代器还包含大量可以直接使用的方法。例如，<code>args</code> 返回的迭代器生成的第一个值永远是正在运行的程序的名称。如果想跳过它，就要调用迭代器的 <code>skip</code> 方法来生成一个新的迭代器，新迭代器会略去第一个值。</p>\n<pre class=\"code-rows\"><code>numbers.push(u64::from_str(&amp;arg)\n             .expect(\"error parsing argument\"));</code></pre>\n<p>这里我们调用了 <code>u64::from_str</code> 来试图将命令行参数 <code>arg</code> 解析为一个无符号的 64 位整数。<code>u64::from_str</code> 并不是 <code>u64</code> 值上的某个方法，而是与 <code>u64</code> 类型相关联的函数，类似于 C++ 或 Java 中的静态方法。<code>from_str</code> 函数不会直接返回 <code>u64</code>，而是返回一个指明本次解析已成功或失败的 <code>Result</code> 值。<code>Result</code> 值是以下两种变体之一：</p>\n<ul>\n<li>形如 <code>Ok(v)</code> 的值，表示解析成功了，<code>v</code> 是所生成的值；</li>\n<li>形如 <code>Err(e)</code> 的值，表示解析失败了，<code>e</code> 是解释原因的错误值。</li>\n</ul>\n<p>执行任何可能会失败的操作（例如执行输入或输出或者以其他方式与操作系统交互）的函数都会返回一个 <code>Result</code> 类型，其 <code>Ok</code> 变体会携带成功结果（传输的字节数、打开的文件等），而其 <code>Err</code> 变体会携带错误码，以指明出了什么问题。与大多数现代语言不同，Rust 没有异常（exception）：所有错误都使用 <code>Result</code> 或 <code>panic</code> 进行处理，详见第 7 章。</p>\n<p>我们用 <code>Result</code> 的 <code>expect</code> 方法来检查本次解析是否成功。如果结果是 <code>Err(e)</code>，那么 <code>expect</code> 就会打印出一条包含 <code>e</code> 的消息并直接退出程序。但如果结果是 <code>Ok(v)</code>，则 <code>expect</code> 会简单地返回 <code>v</code> 本身，最终我们会将其压入这个数值向量的末尾。</p>\n<pre class=\"code-rows\"><code>if numbers.len() == 0 {\n    eprintln!(\"Usage: gcd NUMBER ...\");\n    std::process::exit(1);\n}</code></pre>\n<p>空数组没有最大公约数，因此要检查此向量是否至少包含一个元素，如果没有则退出程序并报错。这里我们用 <code>eprintln!</code> 宏将错误消息写入标准错误流。</p>\n<pre class=\"code-rows\"><code>let mut d = numbers[0];\nfor m in &amp;numbers[1..] {\n    d = gcd(d, *m);\n}</code></pre>\n<p>该循环使用 <code>d</code> 作为其运行期间的值，不断地把它更新为已处理的所有数值的最大公约数。和以前一样，必须将 <code>d</code> 标记为可变，以便在循环中给它赋值。</p>\n<p>这个 <code>for</code> 循环有两个值得注意的地方。首先，我们写了 <code>for m in &amp;numbers[1..]</code>，那么这里的 <code>&amp;</code> 运算符有什么用呢？其次，我们写了 <code>gcd(d, *m)</code>，那么 <code>*m</code> 中的 <code>*</code> 又有什么用呢？这两个细节是紧密相关的。</p>\n<p>迄今为止，我们的代码只是在对简单的值（例如适合固定大小内存块的整数）进行操作。但现在我们要迭代一个向量，它可以是任意大小，而且可能会非常大。Rust 在处理这类值时非常慎重：它想让程序员控制内存消耗，明确每个值的生存时间，同时还要确保当不再需要这些值时能及时释放内存。</p>\n<p>所以在进行迭代时，需要告诉 Rust，该向量的<strong>所有权</strong>应该留在 <code>numbers</code> 上，我们只是为了本次循环而<strong>借用</strong>它的元素。<code>&amp;numbers[1..]</code> 中的 <code>&amp;</code> 运算符会从向量中借用从第二个元素开始的<strong>引用</strong>。<code>for</code> 循环会遍历这些被引用的元素，让 <code>m</code> 依次借出每个元素。<code>*m</code> 中的 <code>*</code> 运算符会将 <code>m</code><strong>解引用</strong>，产生它所引用的值，这就是要传给 <code>gcd</code> 的下一个 <code>u64</code>。最后，由于 <code>numbers</code> 拥有着此向量，因此当 <code>main</code> 末尾的 <code>numbers</code> 超出作用域时，Rust 会自动释放它。</p>\n<p>Rust 的所有权规则和引用规则是 Rust 内存管理和并发安全的关键所在，第 4 章和第 5 章会对此进行详细讨论。只有熟悉了这些规则，才算熟练掌握了 Rust。但是对于这个介绍性的导览，你只需要知道 <code>&amp;x</code> 借用了对 <code>x</code> 的引用，而 <code>*r</code> 访问的是 <code>r</code> 所引用的值就足够了。</p>\n<p>继续我们的程序：</p>\n<pre class=\"code-rows\"><code>println!(\"The greatest common divisor of {:?} is {}\",\n         numbers, d);</code></pre>\n<p>遍历 <code>numbers</code> 的元素后，程序会将结果打印到标准输出流。<code>println!</code> 宏会接受一个模板字符串，在模板字符串中以 <code>{...}</code> 形式标出的位置按要求格式化并插入剩余的参数，最后将结果写入标准输出流。</p>\n<p>C 和 C++ 要求 <code>main</code> 在程序成功完成时返回 0，在出现问题时返回非零的退出状态，而 Rust 假设只要 <code>main</code> 完全返回，程序就算成功完成。只有显式地调用像 <code>expect</code> 或 <code>std::process::exit</code> 这样的函数，才能让程序以表示错误的状态码终止。</p>\n<p><code>cargo run</code> 命令可以将参数传给程序，因此可以试试下面这些命令行处理：</p>\n<pre class=\"code-rows\"><code>$ cargo run 42 56\n   Compiling hello v0.1.0 (/home/jimb/rust/hello)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.22s\n     Running `/home/jimb/rust/hello/target/debug/hello 42 56`\nThe greatest common divisor of [42, 56] is 14\n$ cargo run 799459 28823 27347\n    Finished dev [unoptimized + debuginfo] target(s) in 0.02s\n     Running `/home/jimb/rust/hello/target/debug/hello 799459 28823 27347`\nThe greatest common divisor of [799459, 28823, 27347] is 41\n$ cargo run 83\n    Finished dev [unoptimized + debuginfo] target(s) in 0.02s\n     Running `/home/jimb/rust/hello/target/debug/hello 83`\nThe greatest common divisor of [83] is 83\n$ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.02s\n     Running `/home/jimb/rust/hello/target/debug/hello`\nUsage: gcd NUMBER ...</code></pre>\n<p>本节使用了 Rust 标准库中的一些特性。如果你好奇还有哪些别的特性，强烈建议看看 Rust 的在线文档。它具有实时搜索功能，能让你的探索更容易，其中还包括指向源代码的链接。安装 Rust 时，<code>rustup</code> 命令会自动在你的计算机上安装一份文档副本。你既可以在 Rust 网站上查看标准库文档，也可以使用以下命令打开浏览器查看。</p>\n<pre class=\"code-rows\"><code>$ rustup doc --std</code></pre>\n<h2 id=\"nav_point_26\">2.5　搭建 Web 服务器</h2>\n<p>Rust 的优势之一是在 crates.io 网站上发布的大量免费的可用包。<code>cargo</code> 命令可以让你的代码轻松使用 crates.io 上的包：它将下载包的正确版本，然后会构建包，并根据用户的要求更新包。一个 Rust 包，无论是库还是可执行文件，都叫作 crate（发音为 /kreɪt/，意思是“板条箱”）<span class=\"comment-number\">2</span>。Cargo 和 crates.io 的名字都来源于这个术语。</p>\n\n<p>为了展示这种工作过程，我们将使用 <code>actix-web</code>（Web 框架 crate）、<code>serde</code>（序列化 crate）以及它们所依赖的各种其他 crate 来组装出一个简单的 Web 服务器。如图 2-1 所示，该网站会提示用户输入两个数值并计算它们的最大公约数。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00811.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 2-1：计算最大公约数的网页</strong></p>\n<p>首先，让 Cargo 创建一个新包，命名为 <code>actix-gcd</code>：</p>\n<pre class=\"code-rows\"><code>$ cargo new actix-gcd\n     Created binary (application) `actix-gcd` package\n$ cd actix-gcd</code></pre>\n<p>然后，编辑新项目的 Cargo.toml 文件以列出所要使用的包，其内容应该是这样的：</p>\n<pre class=\"code-rows\"><code>[package]\nname = \"actix-gcd\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# 请到“The Cargo Book”查看更多的键及其定义\n\n[dependencies]\nactix-web = \"1.0.8\"\nserde = { version = \"1.0\", features = [\"derive\"] }</code></pre>\n<p>Cargo.toml 中 <code>[dependencies]</code> 部分的每一行都给出了 crates.io 上的 crate 名称，以及我们想要使用的那个 crate 的版本。在本例中，我们需要 <code>1.0.8</code> 版的 <code>actix-web</code> crate 和 <code>1.0</code> 版的 <code>serde</code> crate。crates.io 上这些 crate 的版本很可能比此处展示的版本新，但通过指明在测试此代码时所使用的特定版本，可以确保即使发布了新版本的包，这些代码仍然能继续编译。<span class=\"comment-number\">3</span>第 8 章会更详细地讨论版本管理。</p>\n\n<p>crate 可能具备某些可选特性：一部分接口或实现不是所有用户都需要的，但将其包含在那个 crate 中仍然有意义。例如，<code>serde</code> crate 就提供了一种非常简洁的方式来处理来自 Web 表单的数据，但根据 <code>serde</code> 的文档，只有选择了此 crate 的 <code>derive</code> 特性时它才可用，因此我们在 Cargo.toml 文件中请求了它。</p>\n<p>请注意，只需指定要直接用到的那些 crate 即可，<code>cargo</code> 会负责把它们自身依赖的所有其他 crate 带进来。</p>\n<p>在第一次迭代中，我们将实现此 Web 服务器的一个简单版本：它只会给出让用户输入要计算的数值的页面。actix-gcd/src/main.rs 的内容如下所示：</p>\n<pre class=\"code-rows\"><code>use actix_web::;\n\nfn main() {\n    let server = HttpServer::new(|| {\n        App::new()\n            .route(\"/\", web::get().to(get_index))\n    });\n\n    println!(\"Serving on http://localhost:3000...\");\n    server\n        .bind(\"127.0.0.1:3000\").expect(\"error binding server to address\")\n        .run().expect(\"error running server\");\n}\n\nfn get_index() -&gt; HttpResponse {\n    HttpResponse::Ok()\n        .content_type(\"text/html\")\n        .body(\n            r#\"\n                &lt;title&gt;GCD Calculator&lt;/title&gt;\n                &lt;form action=\"/gcd\" method=\"post\"&gt;\n                &lt;input type=\"text\" name=\"n\"/&gt;\n                &lt;input type=\"text\" name=\"m\"/&gt;\n                &lt;button type=\"submit\"&gt;Compute GCD&lt;/button&gt;\n                &lt;/form&gt;\n            \"#,\n        )\n}</code></pre>\n<p><code>use</code> 声明可以让来自 <code>actix-web</code> crate 的定义用起来更容易些。当我们写下 <code>use actix_web::{...}</code> 时，花括号中列出的每个名称都可以直接用在代码中，而不必每次都拼出全名，比如 <code>actix_web::HttpResponse</code> 可以简写为 <code>HttpResponse</code>。（稍后还会提及 <code>serde</code> crate。）</p>\n<p><code>main</code> 函数很简单：它调用 <code>HttpServer::new</code> 创建了一个响应单个路径 <code>\"/\"</code> 请求的服务器，打印了一条信息以提醒我们该如何连接它，然后监听本机的 TCP 端口 3000。</p>\n<p>我们传给 <code>HttpServer::new</code> 的参数是 Rust <strong>闭包</strong>表达式 <code>|| { App::new() ... }</code>。闭包是一个可以像函数一样被调用的值。这个闭包没有参数，如果有参数，那么可以将参数名放在两条竖线 <code>||</code> 之间。<code>{ ... }</code> 是闭包的主体。当我们启动服务器时，Actix 会启动一个线程池来处理传入的请求。每个线程都会调用这个闭包来获取 <code>App</code> 值的新副本，以告诉此线程该如何路由这些请求并处理它们。</p>\n<p>闭包会调用 <code>App::new</code> 来创建一个新的空白 <code>App</code>，然后调用它的 <code>route</code> 方法为路径 <code>\"/\"</code> 添加一个路由。提供给该路由的处理程序 <code>web::get().to(get_index)</code> 会通过调用函数 <code>get_index</code> 来处理 HTTP 的 <code>GET</code> 请求。<code>route</code> 方法的返回值就是调用它的那个 <code>App</code>，不过其现在已经有了新的路由。由于闭包主体的末尾没有分号，因此此 <code>App</code> 就是闭包的返回值，可供 <code>HttpServer</code> 线程使用。</p>\n<p><code>get_index</code> 函数会构建一个 <code>HttpResponse</code> 值，该值表示对 HTTP <code>GET /</code> 请求的响应。<code>HttpResponse::Ok()</code> 表示 HTTP <code>200 OK</code> 状态，意味着请求成功。我们会调用它的 <code>content_type</code> 方法和 <code>body</code> 方法来填入该响应的细节，每次调用都会返回在前一次基础上修改过的 <code>HttpResponse</code>。最后会以 <code>body</code> 的返回值作为 <code>get_index</code> 的返回值。</p>\n<p>由于响应文本包含很多双引号，因此我们使用 Rust 的“原始字符串”语法来编写它：首先是字母 <code>r</code>、0 到多个井号（<code>#</code>）标记、一个双引号，然后是字符串本体，并以另一个双引号结尾，后跟相同数量的 <code>#</code> 标记。任何字符都可以出现在原始字符串中而不被转义，包括双引号。事实上，Rust 根本不认识像 <code>\\\"</code> 这样的转义序列。我们总是可以在引号周围使用比文本内容中出现过的 <code>#</code> 更多的 <code>#</code> 标记，以确保字符串能在期望的地方结束。</p>\n<p>编写完 main.rs 后，可以使用 <code>cargo run</code> 命令来执行为运行它而要做的一切工作：获取所需的 crate、编译它们、构建我们自己的程序、将所有内容链接在一起，最后启动 main.rs。</p>\n<pre class=\"code-rows\"><code>$ cargo run\n    Updating crates.io index\n Downloading crates ...\n  Downloaded serde v1.0.100\n  Downloaded actix-web v1.0.8\n  Downloaded serde_derive v1.0.100\n...\n   Compiling serde_json v1.0.40\n   Compiling actix-router v0.1.5\n   Compiling actix-http v0.2.10\n   Compiling awc v0.2.7\n   Compiling actix-web v1.0.8\n   Compiling gcd v0.1.0 (/home/jimb/rust/actix-gcd)\n    Finished dev [unoptimized + debuginfo] target(s) in 1m 24s\n     Running `/home/jimb/rust/actix-gcd/target/debug/actix-gcd`\nServing on http://localhost:3000...</code></pre>\n<p>此刻，在浏览器中访问给定的 URL 就会看到图 2-1 所示的页面。</p>\n<p>但很遗憾，单击“Compute GCD”除了将浏览器导航到一个空白页面外，没有做任何事。为了继续解决这个问题，可以往 <code>App</code> 中添加另一个路由，以处理来自表单的 <code>POST</code> 请求。</p>\n<p>现在终于用到我们曾在 Cargo.toml 文件中列出的 <code>serde</code> crate 了：它提供了一个便捷工具来协助处理表单数据。首先，将以下 <code>use</code> 指令添加到 src/main.rs 的顶部：</p>\n<pre class=\"code-rows\"><code>use serde::Deserialize;</code></pre>\n<p>Rust 程序员通常会将所有的 <code>use</code> 声明集中放在文件的顶部，但这并非绝对必要：Rust 允许这些声明以任意顺序出现，只要它们出现在适当的嵌套级别即可。</p>\n<p>接下来，定义一个 Rust 结构体类型，用以表示期望从表单中获得的值：</p>\n<pre class=\"code-rows\"><code>#[derive(Deserialize)]\nstruct GcdParameters {\n    n: u64,\n    m: u64,\n}</code></pre>\n<p>上述代码定义了一个名为 <code>GcdParameters</code> 的新类型，它有两个字段（<code>n</code> 和 <code>m</code>），每个字段都是一个 <code>u64</code>，这是我们的 <code>gcd</code> 函数想要的参数类型。</p>\n<p>此 <code>struct</code> 定义上面的注解是一个属性，就像之前用来标记测试函数的 <code>#[test]</code> 属性一样。在类型定义之上放置一个 <code>#[derive(Deserialize)]</code> 属性会要求 <code>serde</code> crate 在程序编译时检查此类型并自动生成代码，以便从 HTML 表单 POST 提交过来的格式化数据中解析出此类型的值。事实上，该属性足以让你从几乎任何种类的结构化数据（<code>JSON</code>、<code>YAML</code>、<code>TOML</code> 或许多其他文本格式和二进制格式中的任何一种）中解析 <code>GcdParameters</code> 的值。<code>serde</code> crate 还提供了一个 <code>Serialize</code> 属性，该属性会生成代码来执行相反的操作，获取 Rust 值并以结构化的格式序列化它们。</p>\n<p>有了这个定义，就可以很容易地编写处理函数了：</p>\n<pre class=\"code-rows\"><code>fn post_gcd(form: web::Form&lt;GcdParameters&gt;) -&gt; HttpResponse {\n    if form.n == 0 || form.m == 0 {\n        return HttpResponse::BadRequest()\n            .content_type(\"text/html\")\n            .body(\"Computing the GCD with zero is boring.\");\n    }\n\n    let response =\n        format!(\"The greatest common divisor of the numbers {} and {} \\\n                 is &lt;b&gt;{}&lt;/b&gt;\\n\",\n                form.n, form.m, gcd(form.n, form.m));\n    HttpResponse::Ok()\n        .content_type(\"text/html\")\n        .body(response)\n}</code></pre>\n<p>对于用作 Actix 请求处理程序的函数，其参数必须全都是 Actix 知道该如何从 HTTP 请求中提取出来的类型。<code>post_gcd</code> 函数接受一个参数 <code>form</code>，其类型为 <code>web::Form&lt;GcdParameters&gt;</code>。当且仅当 <code>T</code> 可以从 HTML 表单提交过来的数据反序列化时，Actix 才能知道该如何从 HTTP 请求中提取任意类型为 <code>web::Form&lt;T&gt;</code> 的值。由于我们已经将 <code>#[derive(Deserialize)]</code> 属性放在了 <code>GcdParameters</code> 类型定义上，Actix 可以从表单数据中反序列化它，因此请求处理程序可以要求以 <code>web::Form&lt;GcdParameters&gt;</code> 值作为参数。这些类型和函数之间的关系都是在编译期指定的。如果使用了 Actix 不知道该如何处理的参数类型来编写处理函数，那么 Rust 编译器会直接向你报错。</p>\n<p>来看看 <code>post_gcd</code> 内部，如果任何一个参数为 0，则该函数会先行返回 HTTP <code>400 BAD REQUEST</code> 错误，因为如果它们为 0，我们的 <code>gcd</code> 函数将崩溃。同时，<code>post_gcd</code> 会使用 <code>format!</code> 宏来为此请求构造出响应体。<code>format!</code> 与 <code>println!</code> 很像，但它不会将文本写入标准输出，而是会将其作为字符串返回。一旦获得响应文本，<code>post_gcd</code> 就会将其包装在 HTTP <code>200 OK</code> 响应中，设置其内容类型，并将它返回给请求者。</p>\n<p>还必须将 <code>post_gcd</code> 注册为表单处理程序。为此，可以将 <code>main</code> 函数替换成以下这个版本：</p>\n<pre class=\"code-rows\"><code>fn main() {\n    let server = HttpServer::new(|| {\n        App::new()\n            .route(\"/\", web::get().to(get_index))\n            .route(\"/gcd\", web::post().to(post_gcd))\n    });\n\n    println!(\"Serving on http://localhost:3000...\");\n    server\n        .bind(\"127.0.0.1:3000\").expect(\"error binding server to address\")\n        .run().expect(\"error running server\");\n}</code></pre>\n<p>这里唯一的变化是添加了另一个 <code>route</code> 调用，确立 <code>web::post().to(post_gcd)</code> 作为路径 <code>\"/gcd\"</code> 的处理程序。</p>\n<p>最后剩下的部分是我们之前编写的 <code>gcd</code> 函数，它位于 actix-gcd/src/main.rs 文件中。有了它，你就可以中断运行中的服务器，重新构建并启动程序了：</p>\n<pre class=\"code-rows\"><code>$ cargo run\n   Compiling actix-gcd v0.1.0 (/home/jimb/rust/actix-gcd)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/actix-gcd`\nServing on http://localhost:3000...</code></pre>\n<p>这一次，访问 http://localhost:3000，输入一些数值，然后单击“Compute GCD”按钮，应该会看到一些实质性结果，如图 2-2 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00812.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 2-2：展示计算最大公约数结果的网页</strong></p>\n<h2 id=\"nav_point_27\">2.6　并发</h2>\n<p>Rust 的一大优势是它对并发编程的支持。Rust 中用来确保内存安全的那些规则也同样可以让线程在共享内存的时候避免数据竞争。</p>\n<ul>\n<li>如果使用互斥锁来协调对共享数据结构进行更改的多个线程，那么 Rust 会确保只有持有锁才能访问这些数据，并会在完工后自动释放锁。而在 C 和 C++ 中，互斥锁和它所保护的数据之间的联系只能体现在注释中。</li>\n<li>如果想在多个线程之间共享只读数据，那么 Rust 能确保你不会意外修改数据。而在 C 和 C++ 中，虽然类型系统也可以帮你解决这个问题，但很容易出错。</li>\n<li>如果将数据结构的所有权从一个线程转移给另一个线程，那么 Rust 能确保你真的放弃了对它的所有访问权限。而在 C 和 C++ 中，要由你来检查发送线程上的任何代码是否会再次接触数据。如果你弄错了，那么后果可能取决于处理器缓存中正在发生什么，以及你最近对内存进行过多少次写入。我们或多或少都在这方面吃过一点儿苦头。</li>\n</ul>\n<p>本节将引导你写出第二个多线程程序。</p>\n<p>你已经写完了第一个程序：用 Actix Web 框架实现的最大公约数服务器，它使用线程池来运行请求处理函数。如果服务器同时收到多个请求，那么它就会在多个线程中同时运行 <code>get_index</code> 函数和 <code>post_gcd</code> 函数。这可能有点儿令人震撼，因为我们在编写这些函数时甚至都没有考虑过并发。但 Rust 能确保这样做是安全的，无论你的服务器变得多么复杂：只要程序编译通过了，就一定不会出现数据竞争。所有 Rust 函数都是线程安全的。</p>\n<p>本节的程序绘制了曼德博集（一组分形几何图形，包括著名的海龟图等），这是一种对复数反复运行某个简单函数而生成的分形图。人们通常把“绘制曼德博集”称为<strong>易并行</strong>算法，因为其线程之间的通信模式非常简单，第 19 章会介绍更复杂的模式，但这里的任务已足以演示一些基本要素了。</p>\n<p>首先，创建一个新的 Rust 项目：</p>\n<pre class=\"code-rows\"><code>$ cargo new mandelbrot\n     Created binary (application) `mandelbrot` package\n$ cd mandelbrot</code></pre>\n<p>所有代码都将放在 mandelbrot/src/main.rs 中，我们将向 mandelbrot/Cargo.toml 添加一些依赖项。</p>\n<p>在进入并发曼德博实现之前，先来讲一下接下来将要执行的计算。</p>\n<h3 id=\"nav_point_28\">2.6.1　什么是曼德博集</h3>\n<p>在阅读代码时，具体了解一下它要执行的任务是很有帮助的，所以，我们可以稍微了解一点儿纯数学。先从一个简单的案例开始，然后添加复杂的细节，直到抵达曼德博集最核心的计算领域。</p>\n<p>下面是一个使用 Rust 特有语法实现的 <code>loop</code> 语句无限循环：</p>\n<pre class=\"code-rows\"><code>fn square_loop(mut x: f64) {\n    loop {\n        x = x * x;\n    }\n}</code></pre>\n<p>在现实世界中，Rust 能看出 <code>x</code> 从未用来做任何事，因此不会计算它的值。但目前，假设代码能按编写的方式运行。那么 <code>x</code> 的值会如何变化呢？对任何小于 1 的数值求平方会使它变得更小，因此它会趋近于 0；1 的平方会得到 1；对大于 1 的数值求平方会使它变大，因此它会趋近于无穷大；对一个负数求平方会先使其变为正数，之后它的变化情况和前面的情况类似，如图 2-3 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00813.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 2-3：重复对数值求平方的效果</strong></p>\n<p>因此，根据传给 <code>square_loop</code> 的值，<code>x</code> 的取值为 0 或 1、趋近 0 或趋近无穷大。</p>\n<p>现在考虑一个略有不同的循环：</p>\n<pre class=\"code-rows\"><code>fn square_add_loop(c: f64) {\n    let mut x = 0.;\n    loop {\n        x = x * x + c;\n    }\n}</code></pre>\n<p>这一次，<code>x</code> 从 0 开始，我们通过对它求平方后再加上 <code>c</code> 来调整它在每次迭代中的进度。这更难看出 <code>x</code> 的变化情况了，但通过一些实验会发现，如果 <code>c</code> 大于 0.25 或小于 -2.0，那么 <code>x</code> 最终会变得无限大，否则，它就会停留在 0 附近的某个地方。</p>\n<p>下一个问题：如果不再使用 <code>f64</code> 值而是改用复数做同样的循环会怎样？crates.io 上的 <code>num</code> crate 已经提供了开箱即用的复数类型，因此要在程序的 Cargo.toml 文件的 <code>[dependencies]</code> 部分添加一行 <code>num</code>。这是迄今为止的整个文件（稍后会添加更多）：</p>\n<pre class=\"code-rows\"><code>[package]\nname = \"mandelbrot\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# 请到“The Cargo Book”查看更多的键及其定义\n\n[dependencies]\nnum = \"0.4\"</code></pre>\n<p>现在可以编写此循环的倒数第二个版本了：</p>\n<pre class=\"code-rows\"><code>use num::Complex;\n\nfn complex_square_add_loop(c: Complex&lt;f64&gt;) {\n    let mut z = Complex { re: 0.0, im: 0.0 };\n    loop {\n        z = z * z + c;\n    }\n}</code></pre>\n<p>传统上会用 <code>z</code> 来代表复数，因此我们重命名了循环变量。表达式 <code>Complex { re: 0.0, im: 0.0 }</code> 是使用 <code>num</code> crate 的 <code>Complex</code> 类型编写复数 0 的方式。<code>Complex</code> 是一种 Rust 结构体类型（或 <code>struct</code>），其定义如下：</p>\n<pre class=\"code-rows\"><code>struct Complex&lt;T&gt; {\n    /// 复数的实部\n    re: T,\n\n    /// 复数的虚部\n    im: T,\n}</code></pre>\n<p>上述代码定义了一个名为 <code>Complex</code> 的结构体，该结构体有两个字段，即 <code>re</code> 和 <code>im</code>。<code>Complex</code> 是一种<strong>泛型</strong>结构体：可以把在类型名称之后的 <code>&lt;T&gt;</code> 读作“对于任意类型 <code>T</code>”。例如，<code>Complex&lt;f64&gt;</code> 是一个复数，其 <code>re</code> 字段和 <code>im</code> 字段为 <code>f64</code> 值，<code>Complex&lt;f32&gt;</code> 则使用 32 位浮点数，等等。根据此定义，像 <code>Complex { re: 0.24, im: 0.3 }</code> 这样的表达式就会生成一个 <code>Complex</code> 值，其 <code>re</code> 字段已初始化为 0.24，<code>im</code> 字段已初始化为 0.3。</p>\n<p><code>num</code> crate 支持用 <code>*</code>、<code>+</code> 和其他算术运算符来处理 <code>Complex</code> 值，因此该函数的其余部分仍然像之前的版本那样工作，只是它会将数值视作复平面上而不是实数轴上的点进行运算。第 12 章会讲解如何让 Rust 的运算符与自定义类型协同工作。</p>\n<p>我们终于抵达了纯数学之旅的终点。曼德博集的定义是：令 <code>z</code> 不会“飞到”无穷远的复数 <code>c</code> 的集合。我们最初的简单平方循环是可以预测的：任何大于 1 或小于 -1 的数值都会“飞”出去。把 <code>+ c</code> 放入每次迭代中会使变化情况更难预测：正如前面所说，大于 0.25 或小于 -2.0 的 <code>c</code> 值会导致 <code>z</code>“飞”出去。但是将此游戏推广到复数就会生成真正奇异而美丽的图案，这就是我们所要绘制的分形图。</p>\n<p>由于复数 <code>c</code> 具有实部 <code>c.re</code> 和虚部 <code>c.im</code>，因此可以把它们视为笛卡儿平面上某个点的 <code>x</code> 坐标和 <code>y</code> 坐标，如果 <code>c</code> 在曼德博集中，就在其中用黑色着色，否则就用浅色。因此，对于图像中的每个像素，必须在复平面上的相应点位运行前面的循环，看看它是逃逸到无穷远还是永远绕着原点运行，并相应地将其着色。</p>\n<p>无限循环需要一段时间才能完成，但是对缺乏耐心的人来说有两个小技巧。首先，如果不再永远运行循环而只是尝试一些有限次数的迭代，事实证明仍然可以获得该集合的一个不错的近似值。我们需要多少次迭代取决于想要绘制的边界的精度。其次，业已证明，一旦 <code>z</code> 离开了以原点为中心的半径为 2 的圆，它最终就一定会“飞到”无穷远的地方。所以下面是循环的最终版本，也是程序的核心：</p>\n<pre class=\"code-rows\"><code>use num::Complex;\n\n/// 尝试测定`c`是否位于曼德博集中，使用最多`limit`次迭代来判定\n///\n/// 如果`c`不是集合成员之一，则返回`Some(i)`，其中的`i`是`c`离开以原点\n/// 为中心的半径为2的圆时所需的迭代次数。如果`c`似乎是集合成员之一（确\n/// 切而言是达到了迭代次数限制但仍然无法证明`c`不是成员），则返回`None`\nfn escape_time(c: Complex&lt;f64&gt;, limit: usize) -&gt; Option&lt;usize&gt; {\n    let mut z = Complex { re: 0.0, im: 0.0 };\n    for i in 0..limit {\n        if z.norm_sqr() &gt; 4.0 {\n            return Some(i);\n        }\n        z = z * z + c;\n    }\n\n    None\n}</code></pre>\n<p>此函数会接受两个参数：<code>c</code> 是我们要测试其是否属于曼德博集的复数，<code>limit</code> 是要尝试的迭代次数上限，一旦超出这个次数就放弃并认为 <code>c</code> 可能是成员。</p>\n<p>该函数的返回值是一个 <code>Option&lt;usize&gt;</code>。Rust 的标准库中对 <code>Option</code> 类型的定义如下所示：</p>\n<pre class=\"code-rows\"><code>enum Option&lt;T&gt; {\n    None,\n    Some(T),\n}</code></pre>\n<p><code>Option</code> 是一种<strong>枚举类型</strong>（通常称为“枚举”，<code>enum</code>），因为它的定义枚举了这个类型的值可能是几种变体之一：对于任意类型 <code>T</code>，<code>Option&lt;T&gt;</code> 类型的值要么是 <code>Some(v)</code>，其中 <code>v</code> 的类型为 <code>T</code>；要么是 <code>None</code>，表示没有可用的 <code>T</code> 值。与之前讨论的 <code>Complex</code> 类型一样，<code>Option</code> 是一种泛型类型：你可以使用 <code>Option&lt;T&gt;</code> 来表示任何一种类型 <code>T</code> 的可选值。</p>\n<p>在这个例子中，<code>escape_time</code> 返回一个 <code>Option&lt;usize&gt;</code> 来指示 <code>c</code> 是否在曼德博集中——如果不在，是迭代了多少次才发现的。如果 <code>c</code> 不在集合中，那么 <code>escape_time</code> 就会返回 <code>Some(i)</code>，其中 <code>i</code> 是 <code>z</code> 在离开半径为 <code>2</code> 的圆之前的迭代次数。否则，<code>c</code> 显然在集合中，并且 <code>escape_time</code> 返回 <code>None</code>。</p>\n<pre class=\"code-rows\"><code>for i in 0..limit {</code></pre>\n<p>前面的示例展示了如何用 <code>for</code> 循环遍历命令行参数和向量元素，这个 <code>for</code> 循环则只是遍历从 <code>0</code> 开始到 <code>limit</code>（不含）的整数范围。</p>\n<p><code>z.norm_sqr()</code> 方法调用会返回 <code>z</code> 与原点距离的平方。要判断 <code>z</code> 是否已经离开半径为 <code>2</code> 的圆，不必计算平方根，只需将此距离的平方与 4.0 进行比较即可，这样速度更快。</p>\n<p>你可能已经注意到我们使用了 <code>///</code> 来标记函数定义上方的注释行，<code>Complex</code> 结构体成员上方的注释同样以 <code>///</code> 开头。这些叫作<strong>文档型注释</strong>，<code>rustdoc</code> 实用程序知道如何解析它们和它们所描述的代码，并生成在线文档。Rust 的标准库文档就是以这种形式编写的。第 8 章会详细讲解文档型注释。</p>\n<p>该程序的其余部分所“关心”的是决定以何种分辨率绘制此集合中的哪个部分，并将此项工作分发给多个线程以加快计算速度。</p>\n<h3 id=\"nav_point_29\">2.6.2　解析并配对命令行参数</h3>\n<p>该程序会接受几个命令行参数来控制我们要写入的图像的分辨率以及要绘制曼德博集里哪部分的图像。由于这些命令行参数遵循着一种共同的格式，因此我们写了一个解析它们的函数：</p>\n<pre class=\"code-rows\"><code>use std::str::FromStr;\n\n/// 把字符串`s`（形如`\"400x600\"`或`\"1.0,0.5\"`）解析成一个坐标对\n///\n/// 具体来说，`s`应该具有&lt;left&gt;&lt;sep&gt;&lt;right&gt;的格式，其中&lt;sep&gt;是由`separator`\n/// 参数给出的字符，而&lt;left&gt;和&lt;right&gt;是可以被`T::from_str`解析的字符串。\n/// `separator`必须是ASCII字符\n///\n/// 如果`s`具有正确的格式，就返回`Some&lt;(x, y)&gt;`；如果无法正确解析，就返回`None`\nfn parse_pair&lt;T: FromStr&gt;(s: &amp;str, separator: char) -&gt; Option&lt;(T, T)&gt; {\n    match s.find(separator) {\n        None =&gt; None,\n        Some(index) =&gt; {\n            match (T::from_str(&amp;s[..index]), T::from_str(&amp;s[index + 1..])) {\n                (Ok(l), Ok(r)) =&gt; Some((l, r)),\n                _ =&gt; None\n        }\n        }\n    }\n}\n\n#[test]\nfn test_parse_pair() {\n    assert_eq!(parse_pair::&lt;i32&gt;(\"\",        ','), None);\n    assert_eq!(parse_pair::&lt;i32&gt;(\"10,\",     ','), None);\n    assert_eq!(parse_pair::&lt;i32&gt;(\",10\",     ','), None);\n    assert_eq!(parse_pair::&lt;i32&gt;(\"10,20\",   ','), Some((10, 20)));\n    assert_eq!(parse_pair::&lt;i32&gt;(\"10,20xy\", ','), None);\n    assert_eq!(parse_pair::&lt;f64&gt;(\"0.5x\",    'x'), None);\n    assert_eq!(parse_pair::&lt;f64&gt;(\"0.5x1.5\", 'x'), Some((0.5, 1.5)));\n}</code></pre>\n<p><code>parse_pair</code> 的定义是一个<strong>泛型函数</strong>：</p>\n<pre class=\"code-rows\"><code>fn parse_pair&lt;T: FromStr&gt;(s: &amp;str, separator: char) -&gt; Option&lt;(T, T)&gt; {</code></pre>\n<p>可以把 <code>&lt;T: FromStr&gt;</code> 子句读作“对于实现了 <code>FromStr</code> 特型的任意类型 <code>T</code>……”，这样就能高效地一次定义出整个函数家族：<code>parse_pair::&lt;i32&gt;</code> 是能解析一对 <code>i32</code> 值的函数、<code>parse_pair::&lt;f64&gt;</code> 是能解析一对 <code>f64</code> 浮点值的函数，等等。这很像 C++ 中的函数模板。Rust 程序员会将 <code>T</code> 称作 <code>parse_pair</code> 的<strong>类型参数</strong>。当使用泛型函数时，Rust 通常能帮我们推断出类型参数，并且我们不必像这里的测试代码那样把它们明确写出来。</p>\n<p>我们的返回类型是 <code>Option&lt;(T, T)&gt;</code>：它或者是 <code>None</code>，或者是一个值 <code>Some((v1, v2))</code>，其中 <code>(v1, v2)</code> 是由两个 <code>T</code> 类型的值构成的元组。<code>parse_pair</code> 函数没有使用显式 <code>return</code> 语句，因此它的返回值是其函数体中最后一个（也是唯一的一个）表达式的值：</p>\n<pre class=\"code-rows\"><code>match s.find(separator) {\n    None =&gt; None,\n    Some(index) =&gt; {\n        ...\n    }\n}</code></pre>\n<p><code>String</code> 类型的 <code>find</code> 方法会在字符串中搜索与 <code>separator</code> 相匹配的字符。如果 <code>find</code> 返回 <code>None</code>，那么就意味着字符串中没有出现分隔符，这样整个 <code>match</code> 表达式的计算结果就为 <code>None</code>，表明解析失败。否则，<code>index</code> 值就是此分隔符在字符串中的位置。</p>\n<pre class=\"code-rows\"><code>match (T::from_str(&amp;s[..index]), T::from_str(&amp;s[index + 1..])) {\n    (Ok(l), Ok(r)) =&gt; Some((l, r)),\n    _ =&gt; None\n}</code></pre>\n<p>这里初步展现了 <code>match</code>（匹配）表达式的强大之处。<code>match</code> 的参数是如下元组表达式：</p>\n<pre class=\"code-rows\"><code>(T::from_str(&amp;s[..index]), T::from_str(&amp;s[index + 1..]))</code></pre>\n<p>表达式 <code>&amp;s[..index]</code> 和 <code>&amp;s[index + 1..]</code> 都是字符串的切片，分别位于分隔符之前和之后。类型参数 <code>T</code> 的关联函数 <code>from_str</code> 会获取其中的每一个元素并尝试将它们解析为类型 <code>T</code> 的值，从而生成结果元组。下面是我们要匹配的目标：</p>\n<pre class=\"code-rows\"><code>(Ok(l), Ok(r)) =&gt; Some((l, r)),</code></pre>\n<p>仅当此元组的两个元素都是 <code>Result</code> 类型的 <code>Ok</code> 变体时，该模式才能匹配上，这表明两个解析都成功了。如果是这样，那么 <code>Some((l, r))</code> 就是匹配表达式的值，也就是函数的返回值。</p>\n<pre class=\"code-rows\"><code>_ =&gt; None</code></pre>\n<p>通配符模式 <code>_</code> 会匹配任意内容并忽略其值。如果运行到此处，则表明 <code>parse_pair</code> 已然失败，因此其值为 <code>None</code>，并继而作为本函数的返回值。</p>\n<p>现在有了 <code>parse_pair</code>，就很容易编写一个函数来解析一对浮点坐标并将它们作为 <code>Complex&lt;f64&gt;</code> 值返回：</p>\n<pre class=\"code-rows\"><code>/// 把一对用逗号分隔的浮点数解析为复数\nfn parse_complex(s: &amp;str) -&gt; Option&lt;Complex&lt;f64&gt;&gt; {\n    match parse_pair(s, ',') {\n        Some((re, im)) =&gt; Some(Complex { re, im }),\n        None =&gt; None\n    }\n}\n\n#[test]\nfn test_parse_complex() {\n    assert_eq!(parse_complex(\"1.25,-0.0625\"),\n               Some(Complex { re: 1.25, im: -0.0625 }));\n    assert_eq!(parse_complex(\",-0.0625\"), None);\n}</code></pre>\n<p><code>parse_complex</code> 函数调用了 <code>parse_pair</code>，如果坐标解析成功则构建一个 <code>Complex</code> 值，如果失败则传回给它的调用者。</p>\n<p>如果你很细心，可能会注意到我们用了简写形式来构建 <code>Complex</code> 值。用同名变量来初始化结构体中的字段是很常见的写法，所以 Rust 不会强迫你写成 <code>Complex { re: re, im: im }</code>，而会让你简写成 <code>Complex { re, im }</code>。这是从 JavaScript 和 Haskell 中的类似写法借鉴来的。</p>\n<h3 id=\"nav_point_30\">2.6.3　从像素到复数的映射</h3>\n<p>我们的程序需要在两个彼此相关的坐标空间中运行：输出图像中的每个像素对应于复平面上的一个点。这两个空间之间的关系取决于要绘制曼德博集的哪一部分以及所请求图像的分辨率，这些都要通过命令行参数指定。以下函数会将<strong>图像空间</strong>转换为<strong>复数空间</strong>：</p>\n<pre class=\"code-rows\"><code>/// 给定输出图像中像素的行和列，返回复平面中对应的坐标\n///\n/// `bounds`是一个`pair`，给出了图像的像素宽度和像素高度。`pixel`是表示该\n/// 图像中特定像素的(column, row)二元组。`upper_left`参数和`lower_right`\n/// 参数是在复平面中表示指定图像覆盖范围的点\n fn pixel_to_point(bounds: (usize, usize),\n                  pixel: (usize, usize),\n                  upper_left: Complex&lt;f64&gt;,\n                  lower_right: Complex&lt;f64&gt;)\n    -&gt; Complex&lt;f64&gt;\n{\n    let (width, height) = (lower_right.re - upper_left.re,\n                           upper_left.im - lower_right.im);\n    Complex {\n        re: upper_left.re + pixel.0 as f64 * width / bounds.0 as f64,\n        im: upper_left.im - pixel.1 as f64 * height / bounds.1 as f64\n        // 为什么这里要用减法？这是因为在屏幕坐标系中pixel.1是\n        // 向下递增的，但复数的虚部是向上递增的\n    }\n}\n\n#[test]\nfn test_pixel_to_point() {\n    assert_eq!(pixel_to_point((100, 200), (25, 175),\n                              Complex { re: -1.0, im: 1.0 },\n                              Complex { re: 1.0, im: -1.0 }),\n               Complex { re: -0.5, im: -0.75 });\n}</code></pre>\n<p>图 2-4 说明了 <code>pixel_to_point</code> 所执行的计算规则。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00814.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 2-4：复平面与图像像素的对应关系</strong></p>\n<p><code>pixel_to_point</code> 的代码只是简单的计算，就不详细解释了。但是，有几点需要指出一下。下列形式的表达式引用的是元组中的元素：</p>\n<pre class=\"code-rows\"><code>pixel.0</code></pre>\n<p>这里引用的是 <code>pixel</code> 元组的第一个元素。</p>\n<pre class=\"code-rows\"><code>pixel.0 as f64</code></pre>\n<p>这是 Rust 的类型转换语法：这会将 <code>pixel.0</code> 转换为 <code>f64</code> 值。与 C 和 C++ 不同，Rust 通常会拒绝在数值类型之间进行隐式转换，因此你必须写出所需的转换。这可能有些烦琐，但明确说明发生了哪些转换以及发生于何时是非常有帮助的。隐式整数转换看似“人畜无害”，但从历史上看，它们一直是现实世界 C 和 C++ 代码中缺陷和安全漏洞的常见来源。</p>\n<h3 id=\"nav_point_31\">2.6.4　绘制曼德博集</h3>\n<p>要绘制出曼德博集，只需对复平面上的每个点调用 <code>escape_time</code>，并根据其结果为图像中的像素着色：</p>\n<pre class=\"code-rows\"><code>/// 将曼德博集对应的矩形渲染到像素缓冲区中\n///\n/// `bounds`参数会给出缓冲区`pixels`的宽度和高度，此缓冲区的每字节都\n/// 包含一个灰度像素。`upper_left`参数和 `lower_right`参数分别指定了\n/// 复平面中对应于像素缓冲区左上角和右下角的点\nfn render(pixels: &amp;mut [u8],\n          bounds: (usize, usize),\n          upper_left: Complex&lt;f64&gt;,\n          lower_right: Complex&lt;f64&gt;)\n{\n    assert!(pixels.len() == bounds.0 * bounds.1);\n\n    for row in 0..bounds.1 {\n        for column in 0..bounds.0 {\n            let point = pixel_to_point(bounds, (column, row),\n                                       upper_left, lower_right);\n            pixels[row * bounds.0 + column] =\n                match escape_time(point, 255) {\n                    None =&gt; 0,\n                    Some(count) =&gt; 255 - count as u8\n                };\n        }\n    }\n}</code></pre>\n<p>此刻，这一切看起来都很熟悉。</p>\n<pre class=\"code-rows\"><code>pixels[row * bounds.0 + column] =\n    match escape_time(point, 255) {\n        None =&gt; 0,\n        Some(count) =&gt; 255 - count as u8\n    };</code></pre>\n<p>如果 <code>escape_time</code> 认为该 <code>point</code> 属于本集合，<code>render</code> 就会将相应像素的颜色渲染为黑色 (<code>0</code>)。否则，<code>render</code> 会将需要更长时间才能逃离圆圈的数值渲染为较深的颜色。</p>\n<h3 id=\"nav_point_32\">2.6.5　写入图像文件</h3>\n<p><code>image</code> crate 提供了读取和写入各种图像格式的函数，以及一些基本的图像处理函数。特别是，此 crate 包含一个 PNG 图像文件格式的编码器，该程序使用这个编码器来保存计算的最终结果。为了使用 <code>image</code>，请将下面这行代码添加到 Cargo.toml 的 <code>[dependencies]</code> 部分：</p>\n<pre class=\"code-rows\"><code>image = \"0.13.0\"</code></pre>\n<p>然后可以这样写：</p>\n<pre class=\"code-rows\"><code>use image::ColorType;\nuse image::png::PNGEncoder;\nuse std::fs::File;\n\n/// 把`pixels`缓冲区（其尺寸由`bounds`给出）写入名为`filename`的文件中\nfn write_image(filename: &amp;str, pixels: &amp;[u8], bounds: (usize, usize))\n    -&gt; Result&lt;(), std::io::Error&gt;\n{\n    let output = File::create(filename)?;\n\n    let encoder = PNGEncoder::new(output);\n    encoder.encode(pixels,\n                   bounds.0 as u32, bounds.1 as u32,\n                   ColorType::Gray(8))?;\n\n    Ok(())\n}</code></pre>\n<p>这个函数的操作一目了然：它打开一个文件并尝试将图像写入其中。我们给编码器传入来自 <code>pixels</code> 的实际像素数据、来自 <code>bounds</code> 的宽度和高度，然后是最后一个参数，以说明如何解释 <code>pixels</code> 中的字节：值 <code>ColorType::Gray(8)</code> 表示每字节都是一个 8 位的灰度值。</p>\n<p>这些也同样一目了然。该函数值得一看的地方在于当出现问题时它是如何处理的。一旦遇到错误，就要将错误报告给调用者。正如之前提过的，Rust 中的容错函数应该返回一个 <code>Result</code> 值，成功时为 <code>Ok(s)</code>（其中 <code>s</code> 是成功值），失败时为 <code>Err(e)</code>（其中 <code>e</code> 是错误代码）。那么 <code>write_image</code> 的成功类型和错误类型是什么呢？</p>\n<p>当一切顺利时，<code>write_image</code> 函数只是把所有值得一看的东西都写到了文件中，没有任何有用的返回值。所以它的成功类型就是<strong>单元</strong>（unit）类型 <code>()</code>，而如此命名是因为这个类型只有一个值 <code>()</code>。单元类型类似于 C 和 C++ 中的 <code>void</code>。</p>\n<p>如果发生错误，那么可能是因为 <code>File::create</code> 无法创建文件或 <code>encoder.encode</code> 无法将图像写入其中，此 I/O 操作就会返回错误代码。<code>File::create</code> 的返回类型是 <code>Result&lt;std::fs::File, std::io::Error&gt;</code>，而 <code>encoder.encode</code> 的返回类型是 <code>Result&lt;(), std::io::Error&gt;</code>，所以两者共享着相同的错误类型，即 <code>std::io::Error</code>。<code>write_image</code> 函数也应该这么做。在任何情况下，失败都应导致立即返回，并传出用以描述错误原因的 <code>std::io::Error</code> 值。</p>\n<p>所以，为了正确处理 <code>File::create</code> 的结果，需要 <code>match</code> 它的返回值，如下所示：</p>\n<pre class=\"code-rows\"><code>let output = match File::create(filename) {\n    Ok(f) =&gt; f,\n    Err(e) =&gt; {\n        return Err(e);\n    }\n};</code></pre>\n<p>成功时，就将 <code>output</code> 赋值为 <code>Ok</code> 值中携带的 <code>File</code>。失败时，就将错误透传给调用者。</p>\n<p>这种 <code>match</code> 语句在 Rust 中是一种非常常见的模式，所以该语言提供了 <code>?</code> 运算符作为它的简写形式。因此，与其每次在尝试可能失败的事情时都明确地写出这个逻辑，不如使用以下等效且更易读的语句：</p>\n<pre class=\"code-rows\"><code>let output = File::create(filename)?;</code></pre>\n<p>如果 <code>File::create</code> 失败，那么 <code>?</code> 运算符就会从 <code>write_image</code> 返回，并传出此错误。否则，<code>output</code> 就会持有已成功打开的 <code>File</code>。</p>\n<blockquote>\n<p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00808.jpeg\" alt=\"\" width=\"5%\" style=\"width: 5%\" inline-img=\"true\" />　新手常犯的一个错误就是试图在 <code>main</code> 函数中使用 <code>?</code>。但是，由于 <code>main</code> 本身不返回值，因此这样做行不通。应该使用 <code>match</code> 语句，或者像 <code>unwrap</code> 和 <code>expect</code> 这样的简写方法。还可以选择简单地把 <code>main</code> 改成返回一个 <code>Result</code>，稍后会介绍这种方式。</p>\n</blockquote>\n<h3 id=\"nav_point_33\">2.6.6　并发版曼德博程序</h3>\n<p>万事俱备，可以展示一下 <code>main</code> 函数了，我们可以在其中利用并发来完成任务。为简单起见，先来看一个非并发版本：</p>\n<pre class=\"code-rows\"><code>use std::env;\n\nfn main() {\n    let args: Vec&lt;String&gt; = env::args().collect();\n\n    if args.len() != 5 {\n        eprintln!(\"Usage: {} FILE PIXELS UPPERLEFT LOWERRIGHT\",\n                  args[0]);\n        eprintln!(\"Example: {} mandel.png 1000x750 -1.20,0.35 -1,0.20\",\n                  args[0]);\n        std::process::exit(1);\n    }\n\n    let bounds = parse_pair(&amp;args[2], 'x')\n        .expect(\"error parsing image dimensions\");\n    let upper_left = parse_complex(&amp;args[3])\n        .expect(\"error parsing upper left corner point\");\n    let lower_right = parse_complex(&amp;args[4])\n        .expect(\"error parsing lower right corner point\");\n\n    let mut pixels = vec![0; bounds.0 * bounds.1];\n\n    render(&amp;mut pixels, bounds, upper_left, lower_right);\n\n    write_image(&amp;args[1], &amp;pixels, bounds)\n        .expect(\"error writing PNG file\");\n}</code></pre>\n<p>将命令行参数收集到一个 <code>String</code> 向量中后，我们会解析每个参数，然后开始计算。</p>\n<pre class=\"code-rows\"><code>let mut pixels = vec![0; bounds.0 * bounds.1];</code></pre>\n<p>宏调用 <code>vec![v; n]</code> 创建了一个 <code>n</code> 元素长的向量，其元素会被初始化为 <code>v</code>，因此前面的代码创建了一个长度为 <code>bounds.0 * bounds.1</code> 的全零向量，其中 <code>bounds</code> 是从命令行解析得来的图像分辨率。我们将使用此向量作为单字节灰度像素值的矩形数组，如图 2-5 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00815.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 2-5：使用向量作为矩形像素阵列</strong></p>\n<p>下一行值得关注的代码是：</p>\n<pre class=\"code-rows\"><code>render(&amp;mut pixels, bounds, upper_left, lower_right);</code></pre>\n<p>这会调用 <code>render</code> 函数来实际计算图像。表达式 <code>&amp;mut pixels</code> 借用了一个对像素缓冲区的可变引用，以允许 <code>render</code> 用计算出来的灰度值填充它，不过 <code>pixels</code> 仍然是此向量的拥有者。其余的参数传入了图像的尺寸和要绘制的复平面矩形。</p>\n<pre class=\"code-rows\"><code>write_image(&amp;args[1], &amp;pixels, bounds)\n    .expect(\"error writing PNG file\");</code></pre>\n<p>最后，将这个像素缓冲区作为 PNG 文件写入磁盘。在这个例子中，我们向缓冲区传入了一个共享（不可变）引用，因为 <code>write_image</code> 不需要修改缓冲区的内容。</p>\n<p>此时，可以在发布模式下构建和运行程序，它启用了许多强力的编译器优化，几秒后会在文件 mandel.png 中写入一个漂亮的图像：</p>\n<pre class=\"code-rows\"><code>$ cargo build --release\n    Updating crates.io index\n   Compiling autocfg v1.0.1\n   ...\n   Compiling image v0.13.0\n   Compiling mandelbrot v0.1.0 ($RUSTBOOK/mandelbrot)\n    Finished release [optimized] target(s) in 25.36s\n$ time target/release/mandelbrot mandel.png 4000x3000 -1.20,0.35 -1,0.20\nreal    0m4.678s\nuser    0m4.661s\nsys     0m0.008s</code></pre>\n<p>此命令会创建一个名为 mandel.png 的文件，你可以使用系统的图像查看器或在 Web 浏览器中查看该文件。如果一切顺利，它应该如图 2-6 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00816.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 2-6：并行曼德博程序的结果</strong></p>\n<p>在之前的记录中，我们使用过 Unix 的 <code>time</code> 程序来分析程序的运行时间——对图像的每个像素运行曼德博计算总共需要大约 <code>5</code> 秒。但是几乎所有的现代机器都有多个处理器核心，而这个程序只使用了一个。如果可以将此工作分派给机器提供的所有计算资源，则应该能更快地画完图像。</p>\n<p>为此，可以将图像分成多个部分（每个处理器一个），并让每个处理器为分派给它的像素着色。为简单起见，可以将其分成一些水平条带，如图 2-7 所示。当所有处理器都完成后，可以将像素写入磁盘中。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00817.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 2-7：将像素缓冲区划分为一些条带以进行并行渲染</strong></p>\n<p><code>crossbeam</code> crate 提供了许多有价值的并发设施，包括这里正需要的一个<strong>作用域线程</strong>设施。要使用此设施，必须将下面这行代码添加到 Cargo.toml 文件中：</p>\n<pre class=\"code-rows\"><code>crossbeam = \"0.8\"</code></pre>\n<p>然后要找出调用 <code>render</code> 的代码行并将其替换为以下内容：</p>\n<pre class=\"code-rows\"><code>let threads = 8;\nlet rows_per_band = bounds.1 / threads + 1;\n\n{\n    let bands: Vec&lt;&amp;mut [u8]&gt; =\n        pixels.chunks_mut(rows_per_band * bounds.0).collect();\n    crossbeam::scope(|spawner| {\n        for (i, band) in bands.into_iter().enumerate() {\n            let top = rows_per_band * i;\n            let height = band.len() / bounds.0;\n            let band_bounds = (bounds.0, height);\n            let band_upper_left =\n                pixel_to_point(bounds, (0, top), upper_left, lower_right);\n            let band_lower_right =\n                pixel_to_point(bounds, (bounds.0, top + height),\n                               upper_left, lower_right);\n\n            spawner.spawn(move |_| {\n                render(band, band_bounds, band_upper_left, band_lower_right);\n            });\n        }\n    }).unwrap();\n}</code></pre>\n<p>仍以刚才的方式分步进行讲解：</p>\n<pre class=\"code-rows\"><code>let threads = 8;\nlet rows_per_band = bounds.1 / threads + 1;</code></pre>\n<p>这里我们决定使用 8 个线程。<span class=\"comment-number\">4</span>然后会计算每个条带应该有多少行像素。我们向上舍入行数以确保条带覆盖整个图像，即使其高度并不是 <code>threads</code> 的整数倍。</p>\n\n<pre class=\"code-rows\"><code>let bands: Vec&lt;&amp;mut [u8]&gt; =\n    pixels.chunks_mut(rows_per_band * bounds.0).collect();</code></pre>\n<p>这里我们将像素缓冲区划分为几个条带。缓冲区的 <code>chunks_mut</code> 方法会返回一个迭代器，该迭代器会生成此缓冲区的可变且不重叠的切片，每个切片都包含 <code>rows_per_band * bounds.0</code> 个像素，换句话说，<code>rows_per_band</code> 包含整行的像素。<code>chunks_mut</code> 生成的最后一个切片包含的行数可能少一些，但每一行都包含同样数量的像素。最后，此迭代器的 <code>collect</code> 方法会构建一个向量来保存这些可变且不重叠的切片。</p>\n<p>现在可以使用 <code>crossbeam</code> 库了：</p>\n<pre class=\"code-rows\"><code>crossbeam::scope(|spawner| {\n    ...\n}).unwrap();</code></pre>\n<p>参数 <code>|spawner| { ... }</code> 是 Rust 闭包，它需要一个参数 <code>spawner</code>。请注意，与使用 <code>fn</code> 声明的函数不同，无须声明闭包参数的类型，Rust 将推断它们及其返回类型。在这里，<code>crossbeam::scope</code> 调用了此闭包，并将一个值作为 <code>spawner</code> 参数传给闭包，以便闭包使用 <code>spawner</code> 来创建新线程。<code>crossbeam::scope</code> 函数会等待所有线程执行完毕后返回。这种机制能让 Rust 确保这些线程不会在 <code>pixels</code> 超出作用域后再访问分配给自己的那部分，并能让我们确保当 <code>crossbeam::scope</code> 返回时，图像的计算已然完成。如果一切顺利，那么 <code>crossbeam::scope</code> 就会返回 <code>Ok(())</code>，但如果我们启动的任何线程发生了 panic，则它会返回一个 <code>Err</code>。我们会对该 <code>Result</code> 调用 <code>unwrap</code>，这样一来，在那种情况下我们也会发生 panic，并且用户会收到报告。</p>\n<pre class=\"code-rows\"><code>for (i, band) in bands.into_iter().enumerate() {</code></pre>\n<p>在这里，我们遍历了像素缓冲区的各个条带。<code>into_iter()</code> 迭代器会为循环体的每次迭代赋予独占一个条带的所有权，确保一次只有一个线程可以写入它（第 5 章会详细解释 <code>into_iter()</code> 迭代器的工作原理）。然后，枚举适配器生成了一些元组，将向量中的元素与其索引配对。</p>\n<pre class=\"code-rows\"><code>let top = rows_per_band * i;\nlet height = band.len() / bounds.0;\nlet band_bounds = (bounds.0, height);\nlet band_upper_left =\n    pixel_to_point(bounds, (0, top), upper_left, lower_right);\n\nlet band_lower_right =\n    pixel_to_point(bounds, (bounds.0, top + height),\n                   upper_left, lower_right);</code></pre>\n<p>给定索引和条带的实际大小（回想一下，最后一个条带可能比其他条带矮），可以生成 <code>render</code> 需要的一个边界框，但它只会引用缓冲区的这个条带，而不是整个图像。同样，我们会重新调整渲染器的 <code>pixel_to_point</code> 函数的用途，以找出条带的左上角和右下角落在复平面上的位置。</p>\n<pre class=\"code-rows\"><code>spawner.spawn(move |_| {\n    render(band, band_bounds, band_upper_left, band_lower_right);\n});</code></pre>\n<p>最后，创建一个线程，运行 <code>move |_| { ... }</code> 闭包。前面的 <code>move</code> 关键字表示这个闭包会接手它所用变量的所有权，特别是，只有此闭包才能使用可变切片 <code>band</code>。参数列表 <code>|_|</code> 意味着闭包会接受一个参数，但不使用它（另一个用以启动嵌套线程的启动器）。</p>\n<p>如前所述，<code>crossbeam::scope</code> 调用会确保所有线程在它返回之前都已完成，这意味着将图像保存到文件中是安全的，这就是我们下一步要做的。</p>\n<h3 id=\"nav_point_34\">2.6.7　运行曼德博绘图器</h3>\n<p>我们在这个程序中使用了几个外部 crate：<code>num</code> 用于复数运算，<code>image</code> 用于写入 PNG 文件，<code>crossbeam</code> 用于提供“作用域线程创建”原语。下面是包含所有这些依赖项的最终 Cargo.toml 文件：</p>\n<pre class=\"code-rows\"><code>[package]\nname = \"mandelbrot\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nnum = \"0.4\"\nimage = \"0.13\"\ncrossbeam = \"0.8\"</code></pre>\n<p>接下来就可以构建并运行程序了：</p>\n<pre class=\"code-rows\"><code>$ cargo build --release\n    Updating crates.io index\n   Compiling crossbeam-queue v0.3.2\n   Compiling crossbeam v0.8.1\n   Compiling mandelbrot v0.1.0 ($RUSTBOOK/mandelbrot)\n    Finished release [optimized] target(s) in #.## secs\n$ time target/release/mandelbrot mandel.png 4000x3000 -1.20,0.35 -1,0.20\nreal    0m1.436s\nuser    0m4.922s\nsys     0m0.011s</code></pre>\n<p>这里我们再次使用 <code>time</code> 来查看程序运行所需的时间，请注意，尽管我们仍然花费了将近 5 秒的处理器时间，但实际运行时间仅为 1.5 秒左右。你可以通过注释掉执行此操作的代码并再次进行测量来验证这部分时间是否花在了写入图像文件上。在测试此代码的笔记本计算机上，并发版本将曼德博计算时间缩短了近 3/4。第 19 章会展示如何对此做实质性改进。</p>\n<p>和以前一样，该程序会创建一个名为 mandel.png 的文件。有了这个更快的版本，你就可以根据自己的喜好更改命令行参数，更轻松地探索曼德博集了。</p>\n<h3 id=\"nav_point_35\">2.6.8　大“安”无形</h3>\n<p>这个并行程序与用任何其他语言写出来的程序并没有本质区别：我们将像素缓冲区的片段分给不同的处理器，由每个处理器单独处理，并在它们都完工时展示结果。那么 Rust 的并发支持有什么独到之处呢？</p>\n<p>这里并没有展示那些被编译器一票否决的 Rust 程序。本章中展示的代码能正确地在线程之间对缓冲区进行分区，但是这些代码的许多小型变体将无法正确进行分区（因此会导致数据竞争），不过这些变体里没有一个能逃过 Rust 编译器的静态检查。C 编译器或 C++ 编译器将乐于帮助你探索具有微妙数据竞争的广阔程序空间，而 Rust 会预先告诉你什么时候可能出错。</p>\n<p>第 4 章和第 5 章会讲解 Rust 的内存安全规则。第 19 章会讲解这些规则如何确保适当的安全并发环境。</p>\n<h2 id=\"nav_point_36\">2.7　文件系统与命令行工具</h2>\n<p>Rust 在命令行工具领域构筑了重要的基本应用场景。作为一种现代、安全、快速的系统编程语言，它为程序员提供了一个工具箱，他们可以用这个工具箱组装出灵活的命令行界面，从而复现或扩展现有工具的功能。例如，<code>bat</code> 命令<span class=\"comment-number\">5</span>就提供了一个支持语法高亮的替代方案 <code>cat</code>，并内置了对分页工具的支持，而 <code>hyperfine</code> 可以自动对任何通过命令或管道运行的程序执行基准测试。</p>\n\n<p>虽然如此复杂的内容已经超出了本书的范畴，但 Rust 可以让你轻松步入符合工效学的命令行领域。本节将向你展示如何构建自己的搜索与替换工具，并内置丰富多彩的输出和友好的错误消息。</p>\n<p>首先，创建一个新的 Rust 项目：</p>\n<pre class=\"code-rows\"><code>$ cargo new quickreplace\n     Created binary (application) `quickreplace` package\n$ cd quickreplace</code></pre>\n<p>我们的程序要用到另外两个 crate：用于在终端中创建彩色输出的 <code>text-colorizer</code> 以及执行实际搜索和替换的 <code>regex</code>。和以前一样，将这些 crate 放在 Cargo.toml 中，告诉 <code>cargo</code> 我们需要它们：</p>\n<pre class=\"code-rows\"><code>[package]\nname = \"quickreplace\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# 请到“The Cargo Book”查看更多的键及其定义\n\n[dependencies]\ntext-colorizer = \"1\"\nregex = \"1\"</code></pre>\n<p>凡是达到 1.0 版的 Rust crate 都会遵循“语义化版本控制”规则：在主版本号 1 发生变化之前，所有更新都应当在兼容前序版本的基础上扩展。因此，如果针对某个 crate 的 1.2 版测试过我们的程序，那它应该仍然适用于 1.3、1.4 等版本，但 2.0 版可能会引入不兼容的变更。如果在 Cargo.toml 文件中只是请求版本 <code>\"1\"</code> 的 crate，那么 Cargo 就会使用 2.0 之前的 crate 里最新的可用版本。</p>\n<h3 id=\"nav_point_37\">2.7.1　命令行界面</h3>\n<p>这个程序的界面非常简单。它有 4 个参数：要搜索的字符串（或正则表达式）、要替换成的字符串（或正则表达式）、输入文件的名称和输出文件的名称。我们将从包含这些参数的结构体开始写 main.rs 文件：</p>\n<pre class=\"code-rows\"><code>#[derive(Debug)]\nstruct Arguments {\n    target: String,\n    replacement: String,\n    filename: String,\n    output: String,\n}</code></pre>\n<p><code>#[derive(Debug)]</code> 属性会让编译器生成一些额外的代码，这能让我们在 <code>println!</code> 中使用 <code>{:?}</code> 来格式化 <code>Arguments</code> 结构体。</p>\n<p>如果用户输入的参数个数不对，那么通常会打印出一份关于如何使用本程序的简单说明。我们会使用一个名为 <code>print_usage</code> 的简单函数来完成此操作，并从 <code>text-colorizer</code> 导入所有内容，以便为这些输出添加一些颜色：</p>\n<pre class=\"code-rows\"><code>use text_colorizer::*;\n\nfn print_usage() {\n    eprintln!(\"{} - change occurrences of one string into another\",\n              \"quickreplace\".green());\n    eprintln!(\"Usage: quickreplace &lt;target&gt; &lt;replacement&gt; &lt;INPUT&gt; &lt;OUTPUT&gt;\");\n}</code></pre>\n<p>只要将 <code>.green()</code> 添加到字符串字面量的末尾，就可以生成包裹在适当 ANSI 转义码中的字符串，从而在终端模拟器中显示为绿色。然后，在打印之前将生成的字符串插到信息中的其他部分。</p>\n<p>现在可以开始收集并处理程序的参数了：</p>\n<pre class=\"code-rows\"><code>use std::env;\n\nfn parse_args() -&gt; Arguments {\n    let args: Vec&lt;String&gt; = env::args().skip(1).collect();\n\n    if args.len() != 4 {\n        print_usage();\n        eprintln!(\"{} wrong number of arguments: expected 4, got {}.\",\n            \"Error:\".red().bold(), args.len());\n        std::process::exit(1);\n    }\n\n    Arguments {\n        target: args[0].clone(),\n        replacement: args[1].clone(),\n        filename: args[2].clone(),\n        output: args[3].clone()\n    }\n}</code></pre>\n<p>为了获取用户输入的参数，我们会使用与前面例子中相同的 <code>args</code> 迭代器。<code>.skip(1)</code> 会跳过迭代器的第一个值（正在运行的程序的名称），让结果中只含命令行参数。</p>\n<p>首先 <code>collect()</code> 方法会生成一个 <code>Vec</code> 参数。然后我们会检查它的参数个数是否正确，如果不正确，则打印一条信息并以返回一个错误代码的形式退出。接下来我们再次对部分信息进行着色，并用 <code>.bold()</code> 把这段文本加粗。如果参数个数正确，就把它们放入一个 <code>Arguments</code> 结构体中，并返回该结构体。</p>\n<p>下面添加一个只会调用 <code>parse_args</code> 并打印输出的 <code>main</code> 函数：</p>\n<pre class=\"code-rows\"><code>fn main() {\n    let args = parse_args();\n    println!(\"{:?}\", args);\n}</code></pre>\n<p>现在，运行本程序，可以看到它正常输出了错误消息：</p>\n<pre class=\"code-rows\"><code>$ cargo run\n Updating crates.io index\nCompiling libc v0.2.82\nCompiling lazy_static v1.4.0\nCompiling memchr v2.3.4\nCompiling regex-syntax v0.6.22\nCompiling thread_local v1.1.0\nCompiling aho-corasick v0.7.15\nCompiling atty v0.2.14\nCompiling text-colorizer v1.0.0\nCompiling regex v1.4.3\nCompiling quickreplace v0.1.0 (/home/jimb/quickreplace)\nFinished dev [unoptimized + debuginfo] target(s) in 6.98s\nRunning `target/debug/quickreplace`\nquickreplace - change occurrences of one string into another\nUsage: quickreplace &lt;target&gt; &lt;replacement&gt; &lt;INPUT&gt; &lt;OUTPUT&gt;\nError: wrong number of arguments: expected 4, got 0</code></pre>\n<p>如果传给程序的参数个数正确，那么它就会打印出 <code>Arguments</code> 结构体的文本表示：</p>\n<pre class=\"code-rows\"><code>$ cargo run \"find\" \"replace\" file output\n    Finished dev [unoptimized + debuginfo] target(s) in 0.01s\n     Running `target/debug/quickreplace find replace file output`\nArguments { target: \"find\", replacement: \"replace\", filename: \"file\", output:\n\"output\" }</code></pre>\n<p>这是一个很好的开端。这些参数都已被正确提取并放置在 <code>Arguments</code> 结构体的正确部分中。</p>\n<h3 id=\"nav_point_38\">2.7.2　读写文件</h3>\n<p>接下来，我们需要用某种方法从文件系统中实际获取数据，以便进行处理，并在完工后将数据写回去。Rust 有一套健壮的输入 / 输出工具，但标准库的设计者知道读写文件是很常用的操作，所以刻意简化了它。我们所要做的是导入模块 <code>std::fs</code>，然后就可以访问 <code>read_to_string</code> 函数和 <code>write</code> 函数了：</p>\n<pre class=\"code-rows\"><code>use std::fs;</code></pre>\n<p><code>std::fs::read_to_string</code> 会返回一个 <code>Result&lt;String, std::io::Error&gt;</code>。如果此函数成功，就会生成一个 <code>String</code>；如果失败，就会生成一个 <code>std::io::Error</code>，这是标准库中用来表示 I/O 问题的类型。类似地，<code>std::fs::write</code> 会返回一个 <code>Result&lt;(), std::io::Error&gt;</code>：在成功的时候不返回任何内容，一旦出现问题就返回错误详情。</p>\n<pre class=\"code-rows\"><code>fn main() {\n    let args = parse_args();\n\n    let data = match fs::read_to_string(&amp;args.filename) {\n        Ok(v) =&gt; v,\n        Err(e) =&gt; {\n            eprintln!(\"{} failed to read from file '{}': {:?}\",\n                      \"Error:\".red().bold(), args.filename, e);\n            std::process::exit(1);\n        }\n    };\n\n    match fs::write(&amp;args.output, &amp;data) {\n        Ok(_) =&gt; {},\n        Err(e) =&gt; {\n            eprintln!(\"{} failed to write to file '{}': {:?}\",\n                \"Error:\".red().bold(), args.output, e);\n            std::process::exit(1);\n        }\n    };\n}</code></pre>\n<p>在这里，我们使用前面写好的 <code>parse_args()</code> 函数并将生成的文件名传给 <code>read_to_string</code> 和 <code>write</code>。对这些函数的输出使用 <code>match</code> 语句可以优雅地处理错误，打印出文件名、错误原因，并用一点儿醒目的颜色引起用户的注意。</p>\n<p>有了这个改写后的 <code>main</code> 函数，运行程序时就可以看到下面这些了，当然，新旧文件的内容是完全相同的：</p>\n<pre class=\"code-rows\"><code>$ cargo run \"find\" \"replace\" Cargo.toml Copy.toml\n   Compiling quickreplace v0.1.0 (/home/jimb/rust/quickreplace)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.01s\n     Running `target/debug/quickreplace find replace Cargo.toml Copy.toml`</code></pre>\n<p>该程序<strong>确实</strong>读取了输入文件 Cargo.toml，也<strong>确实</strong>写入了输出文件 Copy.toml，但是由于我们尚未编写任何代码来实际进行查找和替换，因此输出中没有任何变化。通过运行 <code>diff</code> 命令轻松进行查验，该命令确实没有检测到任何差异。</p>\n<pre class=\"code-rows\"><code>$ diff Cargo.toml Copy.toml</code></pre>\n<h3 id=\"nav_point_39\">2.7.3　查找并替换</h3>\n<p>这个程序的最后一步是实现它的实际功能：查找并替换。为此，我们将使用 <code>regex</code> crate，它会编译并执行正则表达式。它提供了一个名为 <code>Regex</code> 的结构体，表示已编译的正则表达式。<code>Regex</code> 有一个 <code>replace_all</code> 方法，该方法名副其实：在一个字符串中搜索此正则表达式的所有匹配项，并用给定的替代字符串替换每个匹配项。可以将这段逻辑提取到一个函数中：</p>\n<pre class=\"code-rows\"><code>use regex::Regex;\nfn replace(target: &amp;str, replacement: &amp;str, text: &amp;str)\n    -&gt; Result&lt;String, regex::Error&gt;\n{\n    let regex = Regex::new(target)?;\n    Ok(regex.replace_all(text, replacement).to_string())\n}</code></pre>\n<p>注意看这个函数的返回类型。就像之前使用过的标准库函数一样，<code>replace</code> 也会返回一个 <code>Result</code>，但这次它携带着 <code>regex</code> crate 提供的错误类型。</p>\n<p><code>Regex::new</code> 会编译用户提供的正则表达式，如果给定的字符串无效，那么它就会失败。与曼德博程序中一样，我们使用 <code>?</code> 符号在 <code>Regex::new</code> 失败的情况下短路它，但该函数将返回 <code>regex</code> crate 特有的错误类型。一旦正则表达式编译完成，它的 <code>replace_all</code> 方法就能用给定的替代字符串替换 <code>text</code> 中的任何匹配项。</p>\n<p>如果 <code>replace_all</code> 找到了匹配项，那么它就会返回一个新的 <code>String</code>，而这些匹配项会被替换成我们给它的文本。否则，<code>replace_all</code> 就会返回指向原始文本的指针，以回避不必要的内存分配和复制。然而，在这个例子中，我们想要一个独立的副本，因此无论是哪种情况，都要使用 <code>to_string</code> 方法来获取 <code>String</code> 并返回包裹在 <code>Result::Ok</code> 中的字符串，就像其他函数中的做法一样。</p>\n<p>现在，是时候将这个新函数合并到 <code>main</code> 代码中了：</p>\n<pre class=\"code-rows\"><code>fn main() {\n    let args = parse_args();\n\n    let data = match fs::read_to_string(&amp;args.filename) {\n        Ok(v) =&gt; v,\n        Err(e) =&gt; {\n           eprintln!(\"{} failed to read from file '{}': {:?}\",\n               \"Error:\".red().bold(), args.filename, e);\n           std::process::exit(1);\n        }\n    };\n\n    let replaced_data = match replace(&amp;args.target, &amp;args.replacement, &amp;data) {\n        Ok(v) =&gt; v,\n        Err(e) =&gt; {\n            eprintln!(\"{} failed to replace text: {:?}\",\n                \"Error:\".red().bold(), e);\n            std::process::exit(1);\n        }\n    };\n\n    match fs::write(&amp;args.output, &amp;replaced_data) {\n        Ok(v) =&gt; v,\n        Err(e) =&gt; {\n            eprintln!(\"{} failed to write to file '{}': {:?}\",\n                \"Error:\".red().bold(), args.filename, e);\n            std::process::exit(1);\n        }\n    };\n}</code></pre>\n<p>完成了最后一步，程序已经就绪，你可以测试它了：</p>\n<pre class=\"code-rows\"><code>$ echo \"Hello, world\" &gt; test.txt\n$ cargo run \"world\" \"Rust\" test.txt test-modified.txt\n   Compiling quickreplace v0.1.0 (/home/jimb/rust/quickreplace)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.88s\n     Running `target/debug/quickreplace world Rust test.txt test-modified.txt`\n\n$ cat test-modified.txt\nHello, Rust</code></pre>\n<p>错误处理做得也很到位，它优雅地向用户报告错误：</p>\n<pre class=\"code-rows\"><code>$ cargo run \"[[a-z]\" \"0\" test.txt test-modified.txt\n    Finished dev [unoptimized + debuginfo] target(s) in 0.01s\n     Running `target/debug/quickreplace '[[a-z]' 0 test.txt test-modified.txt`\nError: failed to replace text: Syntax(\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nregex parse error:\n    [[a-z]\n    ^\nerror: unclosed character class\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n)</code></pre>\n<p>当然，这个简单的演示中还缺少许多特性，但已经“五脏俱全”。至此，你已经了解了如何读取和写入文件、传播和显示错误，以及为输出着色以提升终端程序里的用户体验。</p>\n<p>在未来的章节中，我们将探讨应用程序开发中的高级技术，从数据的集合以及使用迭代器进行函数式编程到可实现高效并发的异步编程技术，但首先，你得在第 3 章的 Rust 基本数据类型方面打下坚实的基础。</p>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 2 章 Rust 导览(1)","id":740800},"right":{"article_title":"第 3 章 基本数据类型","id":740802}},"comments":[{"had_liked":false,"id":389654,"user_name":"Maer","can_delete":false,"product_type":"c1","uid":2054326,"ip_address":"广东","ucode":"417D27BA813543","user_header":"https://static001.geekbang.org/account/avatar/00/1f/58/b6/ca2cd085.jpg","comment_is_top":false,"comment_ctime":1713181322,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636604,"comment_content":"actix-gcd的案例代码已过期会报错，可运行的需要参考：https:&#47;&#47;github.com&#47;ProgrammingRust&#47;examples&#47;tree&#47;master&#47;actix-gcd","like_count":2},{"had_liked":false,"id":396103,"user_name":"马坤钲","can_delete":false,"product_type":"c1","uid":1389285,"ip_address":"江苏","ucode":"3FD58D280070BD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK6tjf32L6g7wVicvibGHRoJU5J72xibyKYQerhWYtonRxlutz35ZRRM6aPh4Cnlicb8qsrWxIYr98Ncg/132","comment_is_top":false,"comment_ctime":1733125770,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636604,"comment_content":"来交作业了：https:&#47;&#47;gitlab.com&#47;my_rust&#47;rust-project","like_count":0},{"had_liked":false,"id":395016,"user_name":"Roway","can_delete":false,"product_type":"c1","uid":1060967,"ip_address":"陕西","ucode":"65AF589142AB6C","user_header":"https://static001.geekbang.org/account/avatar/00/10/30/67/a1e9aaba.jpg","comment_is_top":false,"comment_ctime":1729091421,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":1,"score":2,"product_id":100636604,"comment_content":"Blocking waiting for file lock on package cache","like_count":0}]}