{"id":96168,"title":"36 | 生产者-消费者模式：用流水线思想提高效率","content":"<p>前面我们在<a href=\"https://time.geekbang.org/column/article/95525\">《34 | Worker Thread模式：如何避免重复创建线程？》</a>中讲到，Worker Thread模式类比的是工厂里车间工人的工作模式。但其实在现实世界，工厂里还有一种流水线的工作模式，类比到编程领域，就是<strong>生产者-消费者模式</strong>。</p><p>生产者-消费者模式在编程领域的应用也非常广泛，前面我们曾经提到，Java线程池本质上就是用生产者-消费者模式实现的，所以每当使用线程池的时候，其实就是在应用生产者-消费者模式。</p><p>当然，除了在线程池中的应用，为了提升性能，并发编程领域很多地方也都用到了生产者-消费者模式，例如Log4j2中异步Appender内部也用到了生产者-消费者模式。所以今天我们就来深入地聊聊生产者-消费者模式，看看它具体有哪些优点，以及如何提升系统的性能。</p><h2>生产者-消费者模式的优点</h2><p>生产者-消费者模式的核心是一个<strong>任务队列</strong>，生产者线程生产任务，并将任务添加到任务队列中，而消费者线程从任务队列中获取任务并执行。下面是生产者-消费者模式的一个示意图，你可以结合它来理解。</p><p><img src=\"https://static001.geekbang.org/resource/image/df/15/df72a9769cec7a25dc9093e160dbbb15.png?wh=1142*326\" alt=\"\"></p><center><span class=\"reference\">生产者-消费者模式示意图</span></center><p>从架构设计的角度来看，生产者-消费者模式有一个很重要的优点，就是<strong>解耦</strong>。解耦对于大型系统的设计非常重要，而解耦的一个关键就是组件之间的依赖关系和通信方式必须受限。在生产者-消费者模式中，生产者和消费者没有任何依赖关系，它们彼此之间的通信只能通过任务队列，所以<strong>生产者-消费者模式是一个不错的解耦方案</strong>。</p><!-- [[[read_end]]] --><p>除了架构设计上的优点之外，生产者-消费者模式还有一个重要的优点就是<strong>支持异步，并且能够平衡生产者和消费者的速度差异</strong>。在生产者-消费者模式中，生产者线程只需要将任务添加到任务队列而无需等待任务被消费者线程执行完，也就是说任务的生产和消费是异步的，这是与传统的方法之间调用的本质区别，传统的方法之间调用是同步的。</p><p>你或许会有这样的疑问，异步化处理最简单的方式就是创建一个新的线程去处理，那中间增加一个“<strong>任务队列</strong>”究竟有什么用呢？我觉得主要还是用于<strong>平衡生产者和消费者的速度差异</strong>。我们假设生产者的速率很慢，而消费者的速率很高，比如是1:3，如果生产者有3个线程，采用创建新的线程的方式，那么会创建3个子线程，而采用生产者-消费者模式，消费线程只需要1个就可以了。Java语言里，Java线程和操作系统线程是一一对应的，线程创建得太多，会增加上下文切换的成本，所以Java线程不是越多越好，适量即可。而<strong>生产者-消费者模式恰好能支持你用适量的线程</strong>。</p><h2>支持批量执行以提升性能</h2><p>前面我们在<a href=\"https://time.geekbang.org/column/article/95098\">《33 | Thread-Per-Message模式：最简单实用的分工方法》</a>中讲过轻量级的线程，如果使用轻量级线程，就没有必要平衡生产者和消费者的速度差异了，因为轻量级线程本身就是廉价的，那是否意味着生产者-消费者模式在性能优化方面就无用武之地了呢？当然不是，有一类并发场景应用生产者-消费者模式就有奇效，那就是<strong>批量执行</strong>任务。</p><p>例如，我们要在数据库里INSERT 1000条数据，有两种方案：第一种方案是用1000个线程并发执行，每个线程INSERT一条数据；第二种方案是用1个线程，执行一个批量的SQL，一次性把1000条数据INSERT进去。这两种方案，显然是第二种方案效率更高，其实这样的应用场景就是我们上面提到的批量执行场景。</p><p>在<a href=\"https://time.geekbang.org/column/article/95847\">《35 | 两阶段终止模式：如何优雅地终止线程？》</a>文章中，我们提到一个监控系统动态采集的案例，其实最终回传的监控数据还是要存入数据库的（如下图）。但被监控系统往往有很多，如果每一条回传数据都直接INSERT到数据库，那么这个方案就是上面提到的第一种方案：每个线程INSERT一条数据。很显然，更好的方案是批量执行SQL，那如何实现呢？这就要用到生产者-消费者模式了。</p><p><img src=\"https://static001.geekbang.org/resource/image/15/29/155d861702a047bd20b5708e06c6fd29.png?wh=1142*386\" alt=\"\"></p><center><span class=\"reference\">动态采集功能示意图</span></center><p>利用生产者-消费者模式实现批量执行SQL非常简单：将原来直接INSERT数据到数据库的线程作为生产者线程，生产者线程只需将数据添加到任务队列，然后消费者线程负责将任务从任务队列中批量取出并批量执行。</p><p>在下面的示例代码中，我们创建了5个消费者线程负责批量执行SQL，这5个消费者线程以 <code>while(true){}</code> 循环方式批量地获取任务并批量地执行。需要注意的是，从任务队列中获取批量任务的方法pollTasks()中，首先是以阻塞方式获取任务队列中的一条任务，而后则是以非阻塞的方式获取任务；之所以首先采用阻塞方式，是因为如果任务队列中没有任务，这样的方式能够避免无谓的循环。</p><pre><code>//任务队列\nBlockingQueue&lt;Task&gt; bq=new\n  LinkedBlockingQueue&lt;&gt;(2000);\n//启动5个消费者线程\n//执行批量任务  \nvoid start() {\n  ExecutorService es=executors\n    .newFixedThreadPool(5);\n  for (int i=0; i&lt;5; i++) {\n    es.execute(()-&gt;{\n      try {\n        while (true) {\n          //获取批量任务\n          List&lt;Task&gt; ts=pollTasks();\n          //执行批量任务\n          execTasks(ts);\n        }\n      } catch (Exception e) {\n        e.printStackTrace();\n      }\n    });\n  }\n}\n//从任务队列中获取批量任务\nList&lt;Task&gt; pollTasks() \n    throws InterruptedException{\n  List&lt;Task&gt; ts=new LinkedList&lt;&gt;();\n  //阻塞式获取一条任务\n  Task t = bq.take();\n  while (t != null) {\n    ts.add(t);\n    //非阻塞式获取一条任务\n    t = bq.poll();\n  }\n  return ts;\n}\n//批量执行任务\nexecTasks(List&lt;Task&gt; ts) {\n  //省略具体代码无数\n}\n</code></pre><h2>支持分阶段提交以提升性能</h2><p>利用生产者-消费者模式还可以轻松地支持一种分阶段提交的应用场景。我们知道写文件如果同步刷盘性能会很慢，所以对于不是很重要的数据，我们往往采用异步刷盘的方式。我曾经参与过一个项目，其中的日志组件是自己实现的，采用的就是异步刷盘方式，刷盘的时机是：</p><ol>\n<li>ERROR级别的日志需要立即刷盘；</li>\n<li>数据积累到500条需要立即刷盘；</li>\n<li>存在未刷盘数据，且5秒钟内未曾刷盘，需要立即刷盘。</li>\n</ol><p>这个日志组件的异步刷盘操作本质上其实就是一种<strong>分阶段提交</strong>。下面我们具体看看用生产者-消费者模式如何实现。在下面的示例代码中，可以通过调用 <code>info()</code>和<code>error()</code> 方法写入日志，这两个方法都是创建了一个日志任务LogMsg，并添加到阻塞队列中，调用 <code>info()</code>和<code>error()</code> 方法的线程是生产者；而真正将日志写入文件的是消费者线程，在Logger这个类中，我们只创建了1个消费者线程，在这个消费者线程中，会根据刷盘规则执行刷盘操作，逻辑很简单，这里就不赘述了。</p><pre><code>class Logger {\n  //任务队列  \n  final BlockingQueue&lt;LogMsg&gt; bq\n    = new BlockingQueue&lt;&gt;();\n  //flush批量  \n  static final int batchSize=500;\n  //只需要一个线程写日志\n  ExecutorService es = \n    Executors.newFixedThreadPool(1);\n  //启动写日志线程\n  void start(){\n    File file=File.createTempFile(\n      &quot;foo&quot;, &quot;.log&quot;);\n    final FileWriter writer=\n      new FileWriter(file);\n    this.es.execute(()-&gt;{\n      try {\n        //未刷盘日志数量\n        int curIdx = 0;\n        long preFT=System.currentTimeMillis();\n        while (true) {\n          LogMsg log = bq.poll(\n            5, TimeUnit.SECONDS);\n          //写日志\n          if (log != null) {\n            writer.write(log.toString());\n            ++curIdx;\n          }\n          //如果不存在未刷盘数据，则无需刷盘\n          if (curIdx &lt;= 0) {\n            continue;\n          }\n          //根据规则刷盘\n          if (log!=null &amp;&amp; log.level==LEVEL.ERROR ||\n              curIdx == batchSize ||\n              System.currentTimeMillis()-preFT&gt;5000){\n            writer.flush();\n            curIdx = 0;\n            preFT=System.currentTimeMillis();\n          }\n        }\n      }catch(Exception e){\n        e.printStackTrace();\n      } finally {\n        try {\n          writer.flush();\n          writer.close();\n        }catch(IOException e){\n          e.printStackTrace();\n        }\n      }\n    });  \n  }\n  //写INFO级别日志\n  void info(String msg) {\n    bq.put(new LogMsg(\n      LEVEL.INFO, msg));\n  }\n  //写ERROR级别日志\n  void error(String msg) {\n    bq.put(new LogMsg(\n      LEVEL.ERROR, msg));\n  }\n}\n//日志级别\nenum LEVEL {\n  INFO, ERROR\n}\nclass LogMsg {\n  LEVEL level;\n  String msg;\n  //省略构造函数实现\n  LogMsg(LEVEL lvl, String msg){}\n  //省略toString()实现\n  String toString(){}\n}\n</code></pre><h2>总结</h2><p>Java语言提供的线程池本身就是一种生产者-消费者模式的实现，但是线程池中的线程每次只能从任务队列中消费一个任务来执行，对于大部分并发场景这种策略都没有问题。但是有些场景还是需要自己来实现，例如需要批量执行以及分阶段提交的场景。</p><p>生产者-消费者模式在分布式计算中的应用也非常广泛。在分布式场景下，你可以借助分布式消息队列（MQ）来实现生产者-消费者模式。MQ一般都会支持两种消息模型，一种是点对点模型，一种是发布订阅模型。这两种模型的区别在于，点对点模型里一个消息只会被一个消费者消费，和Java的线程池非常类似（Java线程池的任务也只会被一个线程执行）；而发布订阅模型里一个消息会被多个消费者消费，本质上是一种消息的广播，在多线程编程领域，你可以结合观察者模式实现广播功能。</p><h2>课后思考</h2><p>在日志组件异步刷盘的示例代码中，写日志的线程以 <code>while(true){}</code> 的方式执行，你有哪些办法可以优雅地终止这个线程呢？</p><pre><code>this.writer.execute(()-&gt;{\n  try {\n    //未刷盘日志数量\n    int curIdx = 0;\n    long preFT=System.currentTimeMillis();\n    while (true) {\n    ......\n    }\n  } catch(Exception e) {}\n}    \n</code></pre><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><p></p>","neighbors":{"left":{"article_title":"35 | 两阶段终止模式：如何优雅地终止线程？","id":95847},"right":{"article_title":"37 | 设计模式模块热点问题答疑","id":96736}},"comments":[{"had_liked":false,"id":96351,"user_name":"锦","can_delete":false,"product_type":"c1","uid":1468298,"ip_address":"","ucode":"CB0EB4B68C468B","user_header":"https://static001.geekbang.org/account/avatar/00/16/67/8a/babd74dc.jpg","comment_is_top":false,"comment_ctime":1558402212,"is_pvip":false,"replies":[{"id":"34515","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558411839,"ip_address":"","comment_id":96351,"utype":1}],"discussion_count":1,"race_medal":0,"score":"534134346916","product_id":100023901,"comment_content":"在应用系统中，日志系统一般都是最后关闭的吧，因为它要为其他系统关闭提供写日志服务。所以日志系统关闭时需要把队列中所有日志都消费掉才能关闭。<br>可能需要在关闭日志系统时投入一个毒丸，表示没有新的日志写入。线程池在消费到毒丸时知道没有日志写入，将所有的日志刷盘，break循环体。<br>","like_count":125,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450843,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558411839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96459,"user_name":"PK時頭髮不亂","can_delete":false,"product_type":"c1","uid":1207867,"ip_address":"","ucode":"08AAAC8F4DE71D","user_header":"https://static001.geekbang.org/account/avatar/00/12/6e/3b/88f14e2a.jpg","comment_is_top":false,"comment_ctime":1558429195,"is_pvip":false,"replies":[{"id":"34581","content":"感谢感谢，有钱难买合适:)","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558451095,"ip_address":"","comment_id":96459,"utype":1}],"discussion_count":4,"race_medal":0,"score":"207716859403","product_id":100023901,"comment_content":"极客时间有好多课程, 我觉得王老师的干货是最实际最可用的, 必须要赞一个。","like_count":49,"discussions":[{"author":{"id":1008065,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/61/c1/9ad88d67.jpg","nickname":"Mr_杨","note":"","ucode":"AD31C2320DF6A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46541,"discussion_content":"确实是，购买了好几个专栏，王老师还有个王争的数据结构算法讲的干货最多，","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1573179126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450888,"discussion_content":"感谢感谢，有钱难买合适:)","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1558451095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1542037,"avatar":"https://static001.geekbang.org/account/avatar/00/17/87/95/cba0a896.jpg","nickname":"卢","note":"","ucode":"B6A9F41AEE348C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405601,"discussion_content":"我觉得这是一门最经典的并发课","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1634606785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2756739,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/10/83/0facd0eb.jpg","nickname":"利威尔兵长","note":"","ucode":"FDE0BD5BFB1B4A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538215,"discussion_content":"同感，其他讲的不是不成体系，就是高大空，假把式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639371705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96916,"user_name":"êｗěｎ","can_delete":false,"product_type":"c1","uid":1066707,"ip_address":"","ucode":"5000233111BEFA","user_header":"https://static001.geekbang.org/account/avatar/00/10/46/d3/e25d104a.jpg","comment_is_top":false,"comment_ctime":1558535168,"is_pvip":true,"replies":[{"id":"34753","content":"能快速定位的问题👍👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558617371,"ip_address":"","comment_id":96916,"utype":1}],"discussion_count":4,"race_medal":0,"score":"113227684864","product_id":100023901,"comment_content":"<br>之前遇到过一个生产问题，一个服务启动一段时间后就不停的超时，后面结合线程栈发现很多阻塞在打印日志的地方（我们用的就是log4j2），后面查到机子硬盘问题，io直接100%以上，日志刷盘满导致消费速度慢，队列撑满阻塞了写，这间接说明平衡好生产和消费速度以及适当的队列大小是很有必要。","like_count":27,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451062,"discussion_content":"能快速定位的问题👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558617371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2288362,"avatar":"https://static001.geekbang.org/account/avatar/00/22/ea/ea/77a59153.jpg","nickname":"耶马","note":"","ucode":"3A3CF67B016CDB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546924,"discussion_content":"写日志的同步的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642471788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1810156,"avatar":"","nickname":"poordickey","note":"","ucode":"2A436EC813AF97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340691,"discussion_content":"为什么日志写 会影响到主线程(业务)的执行呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610098887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2288362,"avatar":"https://static001.geekbang.org/account/avatar/00/22/ea/ea/77a59153.jpg","nickname":"耶马","note":"","ucode":"3A3CF67B016CDB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1810156,"avatar":"","nickname":"poordickey","note":"","ucode":"2A436EC813AF97","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546947,"discussion_content":"日志同步,阻塞问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642476394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":340691,"ip_address":""},"score":546947,"extra":""}]}]},{"had_liked":false,"id":97237,"user_name":"聂旋","can_delete":false,"product_type":"c1","uid":1193784,"ip_address":"","ucode":"40061E5AFDA99C","user_header":"https://static001.geekbang.org/account/avatar/00/12/37/38/5a3b72d4.jpg","comment_is_top":false,"comment_ctime":1558616510,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"74573060542","product_id":100023901,"comment_content":"安卓的主线程中也是采用消息队列加消息循环方式，来处理用户输入及各种事件。当应用退出时，会发送一个处理对象为null的消息给队列，消息循环遇到这样的消息时就退出了。","like_count":17,"discussions":[{"author":{"id":1193784,"avatar":"https://static001.geekbang.org/account/avatar/00/12/37/38/5a3b72d4.jpg","nickname":"聂旋","note":"","ucode":"40061E5AFDA99C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":59504,"discussion_content":"参见李玉刚的《Android开发艺术探索》关于hander/looper章节，里面有详细介绍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574689823,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58441,"discussion_content":" 有这个操作嘛？请教下具体的代码位置","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574675911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96730,"user_name":"苏籍","can_delete":false,"product_type":"c1","uid":1396252,"ip_address":"","ucode":"4FA289E084B789","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erYNBIwAj3KdIXaXbeMBUjTMz31zAToHIJSdo7oQk8bfsibwViaLobVQ8miatwBlC5spLS9kVCzHMjUA/132","comment_is_top":false,"comment_ctime":1558494043,"is_pvip":false,"replies":[{"id":"34654","content":"只有守护线程才会自动结束，线程池的线程不是守护线程","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558535698,"ip_address":"","comment_id":96730,"utype":1}],"discussion_count":1,"race_medal":0,"score":"57393068891","product_id":100023901,"comment_content":"您好老师问个最近用到的线程池使用的问题<br>我的工程是springboot的，在unitTest里（@SpringBootTest） 里调用了一个service A（通过@Autowired的）中的方法，A中启用了一个线程池，执行的任务 是往数据库里插入数据。但是总抛出数据源已经被关闭的异常，我理解的是在单测主线程已经结束，所以关闭了数据源这些清理工作，而此时线程池的线程还<br>没结束，这个时候去调用数据源是null 的，不知道这么理解对不对，另外这个test主线程结束，为啥线程池的线程还没结束（通过打断点看到的）。这个怎么理解，求教","like_count":13,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450991,"discussion_content":"只有守护线程才会自动结束，线程池的线程不是守护线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558535698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121801,"user_name":"Asanz","can_delete":false,"product_type":"c1","uid":1005200,"ip_address":"","ucode":"430AB7ED59EE3F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/56/90/be01bb8d.jpg","comment_is_top":false,"comment_ctime":1565226125,"is_pvip":false,"replies":[{"id":"44972","content":"需要","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1565429473,"ip_address":"","comment_id":121801,"utype":1}],"discussion_count":1,"race_medal":0,"score":"48809866381","product_id":100023901,"comment_content":"看到很多示例代码都没有关闭线程池的动作，难道局部的线程池就不要关闭吗？","like_count":11,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461954,"discussion_content":"需要","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565429473,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203394,"user_name":"Geek_c22199","can_delete":false,"product_type":"c1","uid":1441876,"ip_address":"","ucode":"1CE5B65513E360","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2vn8hyjICTCletGs0omz28lhriaZKX2XX9icYzAEon2IEoRnlXqyOia2bEPP0j7T6xexTnr77JJic8w/132","comment_is_top":false,"comment_ctime":1586183869,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"44535856829","product_id":100023901,"comment_content":"这段代码漂亮啊<br><br>&#47;&#47;阻塞式获取一条任务<br>  Task t = bq.take();<br>  while (t != null) {<br>    ts.add(t);<br>    &#47;&#47;非阻塞式获取一条任务<br>    t = bq.poll();<br>  }","like_count":11,"discussions":[{"author":{"id":1333649,"avatar":"https://static001.geekbang.org/account/avatar/00/14/59/91/fa2d8bb2.jpg","nickname":"不吃辣👾","note":"","ucode":"B25E0725B5E85F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586765,"discussion_content":"这种和全阻塞的比 好在哪里了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662480556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134381,"user_name":"生活发言权","can_delete":false,"product_type":"c1","uid":1136291,"ip_address":"","ucode":"B6269BE979DF35","user_header":"https://static001.geekbang.org/account/avatar/00/11/56/a3/0141096a.jpg","comment_is_top":false,"comment_ctime":1568815200,"is_pvip":false,"replies":[{"id":"51545","content":"高并发下，我觉得主要是做好限流和缓存，保护好瓶颈资源数据库，限流和缓存的方案要看流量大小和系统架构","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1568854798,"ip_address":"","comment_id":134381,"utype":1}],"discussion_count":2,"race_medal":4,"score":"40223520864","product_id":100023901,"comment_content":"请问一下高并发场景，四个人拼一个团，怎么拼？<br>1.db里记录拼团人数，如果小于4则直接update到拼团用户表，否则创建新的拼团id，新的记录。<br>2.高并发场景，怎么保证读写db的一致性？redis和db双写？<br>3.期待老师高见","like_count":9,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467724,"discussion_content":"高并发下，我觉得主要是做好限流和缓存，保护好瓶颈资源数据库，限流和缓存的方案要看流量大小和系统架构","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568854798,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2308075,"avatar":"","nickname":"Geek_89e362","note":"","ucode":"E596C2CFE1CFAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328595,"discussion_content":"这个应该能通过生产者-消费者模式实现，\n1、如果单节点可以先把拼团信息保存到本地缓存中，等到凑够四个人，统一刷大数据库中。此种方式要考虑宕机，数据丢失的问题。\n2、如果是集群可以通过 redis 做分布式缓存，把数据存到redis中，另起线程定时查询redis，如果凑够四个就直接刷大，磁盘中。这样redis 持久化方式要配置成aof实时刷盘。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606187942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102322,"user_name":"berthav_ss","can_delete":false,"product_type":"c1","uid":1268906,"ip_address":"","ucode":"A26CCBB8C8A0FB","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJDgV2qia6eALwftiakMorogZMBunfVvRr52gXQ3WbfDb5hyFtvFZnWMltLd1vNIQLxuBHkDibPefbXA/132","comment_is_top":false,"comment_ctime":1560203846,"is_pvip":false,"replies":[{"id":"37233","content":"可以考虑一下毒丸的方式","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1560348364,"ip_address":"","comment_id":102322,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35919942214","product_id":100023901,"comment_content":"宝令老师，如何优雅的停止线程池中某一组线程呢？例如我在线程a中启动了1-10线程，线程b中启动了2-30线程，如何优雅停止1-10线程呢","like_count":8,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453357,"discussion_content":"可以考虑一下毒丸的方式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560348364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96354,"user_name":"泛岁月的涟漪","can_delete":false,"product_type":"c1","uid":1104605,"ip_address":"","ucode":"1C27878EFBD3CC","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/dd/c9735ee8.jpg","comment_is_top":false,"comment_ctime":1558402453,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23033238933","product_id":100023901,"comment_content":"1、使用线程池的shutdown或者shutdownNow关闭线程池<br>2、while循环条件设置为一个volatile boolean变量<br>3、可以使用interrupt，但是线程是线程池管理的，没有消费者线程的引用中断不了","like_count":5},{"had_liked":false,"id":96388,"user_name":"晓杰","can_delete":false,"product_type":"c1","uid":1441546,"ip_address":"","ucode":"1174C88EEBF8A6","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","comment_is_top":false,"comment_ctime":1558407487,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18738276671","product_id":100023901,"comment_content":"35讲说到优雅地终止线程，首先需要线程状态转换为runnable状态（在终止刷盘的方法中调用Thread.interrupt()方法）<br>\t然后可以通过设置标志位来让线程优雅终止，具体有两种方式：<br>\t1、通过判断线程的中断状态Thread.currentThread.isInterrupted()<br>\t2、设置自己的线程终止标志位，该标志位volatile修饰的共享变量。（这种方式需要在终止刷盘的方法中修改该共享变量的值）","like_count":4},{"had_liked":false,"id":96373,"user_name":"ack","can_delete":false,"product_type":"c1","uid":1440912,"ip_address":"","ucode":"69CA1233EEA8E2","user_header":"https://static001.geekbang.org/account/avatar/00/15/fc/90/c9df0459.jpg","comment_is_top":false,"comment_ctime":1558405095,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18738274279","product_id":100023901,"comment_content":"public class Logger {<br>\t...<br>\t<br>    volatile boolean stop;<br><br>    &#47;&#47; 启动写日志线程<br>    void start() throws IOException {<br>\t\t...<br>        this.es.execute(() -&gt; {<br>            try {<br>                &#47;&#47; 未刷盘日志数量<br>                int curIdx = 0;<br>                long preFT = System.currentTimeMillis();<br>                while (!stop) {<br>                   \t...<br>                }<br>            } catch (InterruptedException e) {<br>                &#47;&#47; 重新设置线程中断状态<br>                Thread.currentThread().interrupt();<br>            } catch (Exception e) {<br>                e.printStackTrace();<br>            } finally {<br>\t\t\t\t...<br>            }<br>        });<br>    }<br>\t...<br>    void stop(){<br>        stop = true;<br>        es.shutdown();<br>    }<br>}","like_count":4},{"had_liked":false,"id":117743,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1564123071,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14449024959","product_id":100023901,"comment_content":"private BlockingQueue&lt;X&gt; bq = new LinkedBlockingQueue&lt;&gt;(1000);<br><br>&#47;&#47; 从任务队列中获取批量任务<br>List&lt;X&gt; pollTasks() throws InterruptedException{<br>  List&lt;X&gt; ts=new LinkedList&lt;&gt;();<br><br>  X t = bq.take();<br>  while (t != null) {<br>    ts.add(t);<br>    t = bq.poll();<br>  }<br><br>  return ts;<br>}<br><br>-----<br><br>需求背景：（一个线程往 bq 写数据，三个线程从 bq 读数据）<br>1. 线程 A 从数据库批量读取数据，每次读 1000 条记录，然后在 for 循环内写入队列 bq.put(x)。<br>2. 线程 B、线程 C、线程 D 调用 pollTasks() 方法获取数据列表，然后将数据列表做为参数，调用 Y 接口获取一批数据，最后进行业务运算。<br><br>-----<br><br>跑 demo 时发现 pollTasks() 方法有两个地方需要注意一下（一是：获取的列表数量不均，二是：退化成单元素列表）：<br>1. 线程 B、C、D 调用 pollTasks() 获得的列表，数据量不均匀，例如线程 B 只读取到 10+ 个元素，而线程 C 却读取了 1000+ 个元素。<br>2. 如果我上游写入队列 bq 速度较慢（通过一些复杂的运算再写入 bq），这时下游通过 pollTasks() 获取的列表，几乎都是只有一个元素的列表。<br><br><br>列表数据不均，可以增加返回列表的上限，或者增加超时机制。<br><br>退化成单元素列表：<br>1. pollTasks() 的调用方主动等待片刻，再获取数据。<br>2. 修改 pollTasks() 的实现，返回列表的前提条件是：列表的 size 必须 batchSizeLimit 下限，否则等待超时 System.currentTimeMillis()-startMillis&gt;1000。<br>","like_count":4,"discussions":[{"author":{"id":1740281,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8d/f9/ceb39113.jpg","nickname":"hostfox²⁰²⁰","note":"","ucode":"0D987C733D7CCB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":205924,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584358764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97026,"user_name":"曾轼麟","can_delete":false,"product_type":"c1","uid":1451391,"ip_address":"","ucode":"D418371AC11270","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/7f/473d5a77.jpg","comment_is_top":false,"comment_ctime":1558573660,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14443475548","product_id":100023901,"comment_content":"补充一下上面的留言，先通过创建的钩子去创建一个毒丸，然后释放资源","like_count":3},{"had_liked":false,"id":97016,"user_name":"曾轼麟","can_delete":false,"product_type":"c1","uid":1451391,"ip_address":"","ucode":"D418371AC11270","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/7f/473d5a77.jpg","comment_is_top":false,"comment_ctime":1558573155,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14443475043","product_id":100023901,"comment_content":"使用Runtime提供的钩子，然后在关闭前，先让内部任务执行完毕，再释放资源","like_count":3},{"had_liked":false,"id":223679,"user_name":"来","can_delete":false,"product_type":"c1","uid":1048433,"ip_address":"","ucode":"2612C1D888ED03","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ff/71/c492b7fa.jpg","comment_is_top":false,"comment_ctime":1591155017,"is_pvip":true,"replies":[{"id":"94110","content":"几乎所有多线程程序都会有队列，所以从底层看都是一样的，但是从高层看，是对不同问题的抽象，设计过程是一个从高向低的过程，在高层次只关注模型而不关注实现。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1604447468,"ip_address":"","comment_id":223679,"utype":1}],"discussion_count":1,"race_medal":1,"score":"10181089609","product_id":100023901,"comment_content":"你好我想问下，生产者-消费者模式和worker thread模式有什么区别和联系？我看它们的核心都是任务队列，都是先把任务放到任务队列中，然后再从任务队列中获取任务并执行。","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497211,"discussion_content":"几乎所有多线程程序都会有队列，所以从底层看都是一样的，但是从高层看，是对不同问题的抽象，设计过程是一个从高向低的过程，在高层次只关注模型而不关注实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604447468,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96883,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1558529163,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10148463755","product_id":100023901,"comment_content":"还是不太懂，线程池的实现是有两种模式吗？ Worker Thread 和 生产者-消费者 模式 ？","like_count":2},{"had_liked":false,"id":96570,"user_name":"Geek_bbbda3","can_delete":false,"product_type":"c1","uid":1504651,"ip_address":"","ucode":"737394CE472C21","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKNDKOCoZvCqoYVM1t97Q77QPLmRBGvOLYzFsh8073RicycoIuwGrIsCXpAFEyVBOxcyE3Ih1mr6Vw/132","comment_is_top":false,"comment_ctime":1558450223,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10148384815","product_id":100023901,"comment_content":"volatile stoped;<br><br>while(!stoped || bq.size() &gt;0)<br>｛｝<br><br>public void shutdown（）{<br>Stoped =true;<br>Es.shutdown（）；<br>while（es.awaitUtilTime（5，timeutil.seconds）｛<br>es.shutdownNow（）；<br>｝<br>","like_count":3},{"had_liked":false,"id":290922,"user_name":"Geek_b38255","can_delete":false,"product_type":"c1","uid":2441534,"ip_address":"","ucode":"23D66FDC18E67F","user_header":"","comment_is_top":false,"comment_ctime":1619861667,"is_pvip":false,"replies":[{"id":"105481","content":"很多模式底层实现都是生产者-消费者模式，模式更多地是与现实世界的类比，更多地是一种解决问题的思维方式。从类比的角度，Worker Thread 模式和生产者-消费者模式的区别就出来了，Worker Thread 模式更贴近现实，而生产者-消费者更多的是一种实现层面的模式。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1620116354,"ip_address":"","comment_id":290922,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5914828963","product_id":100023901,"comment_content":"老师你好，想请教下，生产者-消费者模式 与 Worker Thread 模式的区别是什么呢？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519325,"discussion_content":"很多模式底层实现都是生产者-消费者模式，模式更多地是与现实世界的类比，更多地是一种解决问题的思维方式。从类比的角度，Worker Thread 模式和生产者-消费者模式的区别就出来了，Worker Thread 模式更贴近现实，而生产者-消费者更多的是一种实现层面的模式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620116354,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":269678,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1608735651,"is_pvip":false,"replies":[{"id":"98294","content":"会很好������������","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1609397027,"ip_address":"","comment_id":269678,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5903702947","product_id":100023901,"comment_content":"第一段代码，非阻塞获取任务时，如果再单批次数量上限比如1000，是不是更好些","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512352,"discussion_content":"会很好������������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609397027,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155297,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1574675947,"is_pvip":false,"replies":[{"id":"59680","content":"廉价意味着可以轻松创建很多，线程是不能创建很多的。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1574727480,"ip_address":"","comment_id":155297,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5869643243","product_id":100023901,"comment_content":"如果使用轻量级线程，就没有必要平衡生产者和消费者的速度差异了，因为轻量级线程本身就是廉价的，<br><br>为什么廉价就不需要平衡？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475718,"discussion_content":"廉价意味着可以轻松创建很多，线程是不能创建很多的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574727480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60655,"discussion_content":"明白了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574743775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96391,"user_name":"佑儿","can_delete":false,"product_type":"c1","uid":1226196,"ip_address":"","ucode":"0629888E7A5E16","user_header":"https://static001.geekbang.org/account/avatar/00/12/b5/d4/3bd5b77b.jpg","comment_is_top":false,"comment_ctime":1558407870,"is_pvip":false,"replies":[{"id":"34512","content":"队列中的任务就丢了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558411583,"ip_address":"","comment_id":96391,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5853375166","product_id":100023901,"comment_content":"声明一个volatie变量用于表示线程结束，为true时，退出循环<br>","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450860,"discussion_content":"队列中的任务就丢了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558411583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96296,"user_name":"兔斯基","can_delete":false,"product_type":"c1","uid":1061320,"ip_address":"","ucode":"146A5FE2D8B301","user_header":"https://static001.geekbang.org/account/avatar/00/10/31/c8/a64e4aef.jpg","comment_is_top":false,"comment_ctime":1558396201,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5853363497","product_id":100023901,"comment_content":"增加一个volatile标志位，刷盘结束后，判断标志位，这样不会影响数据落盘，但是可能会发起听之后5秒才结束。或者用线程中断方式，处理好中断异常以及中断标识即可","like_count":1},{"had_liked":false,"id":96285,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1558392936,"is_pvip":false,"replies":[{"id":"34516","content":"可见，中断要看场景","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558412064,"ip_address":"","comment_id":96285,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5853360232","product_id":100023901,"comment_content":"设置一个volitle  。这里中断设置不了，没有引用。我觉得一个volite关键字够了。之前说happens before的时候说，volit写，优于volit读，应该立刻可见。还要问下老师，这么理解可以吗？中断是不是一定必须的？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450813,"discussion_content":"可见，中断要看场景","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558412064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339992,"user_name":"漠博嵩","can_delete":false,"product_type":"c1","uid":2660316,"ip_address":"","ucode":"33704880E9790F","user_header":"https://static001.geekbang.org/account/avatar/00/28/97/dc/8eacc8f1.jpg","comment_is_top":false,"comment_ctime":1648528464,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1648528464","product_id":100023901,"comment_content":"用volatile boolean flag字段, while(flag),  其他线程 修改flag字段为false 此线程就会终止","like_count":0},{"had_liked":false,"id":291983,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1620636630,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620636630","product_id":100023901,"comment_content":"<br>public class Logger {<br>    &#47;&#47;任务队列<br>    final BlockingQueue&lt;LogMsg&gt; bq = new LinkedBlockingQueue&lt;&gt;();<br>    &#47;&#47;flush批量<br>    static final int batchSize = 500;<br>    &#47;&#47;只需要一个线程写日志<br>    ExecutorService es = Executors.newFixedThreadPool(1);<br>    &#47;&#47;中断标志位<br>    volatile boolean flag = false;<br><br><br>    &#47;&#47;启动写日志线程<br>    void start() throws IOException {<br>        File file = File.createTempFile(<br>                &quot;foo&quot;, &quot;.log&quot;);<br>        final FileWriter writer =<br>                new FileWriter(file);<br>        this.es.execute(() -&gt; {<br>            try {<br>                &#47;&#47;未刷盘日志数量<br>                int curIdx = 0;<br>                long preFT = System.currentTimeMillis();<br>                while (!flag) {<br>                    LogMsg log = bq.poll(<br>                            5, TimeUnit.SECONDS);<br>                    &#47;&#47;写日志<br>                    if (log != null) {<br>                        writer.write(log.toString());<br>                        ++curIdx;<br>                    }<br>                    &#47;&#47;如果不存在未刷盘数据，则无需刷盘<br>                    if (curIdx &lt;= 0) {<br>                        continue;<br>                    }<br>                    &#47;&#47;根据规则刷盘<br>                    if (log != null &amp;&amp; log.level == LEVEL.ERROR ||<br>                            curIdx == batchSize ||<br>                            System.currentTimeMillis() - preFT &gt; 5000) {<br>                        writer.flush();<br>                        curIdx = 0;<br>                        preFT = System.currentTimeMillis();<br>                    }<br>                }<br>            } catch (Exception e) {<br>                e.printStackTrace();<br>            } finally {<br>                try {<br>                    writer.flush();<br>                    writer.close();<br>                } catch (IOException e) {<br>                    e.printStackTrace();<br>                }<br>            }<br>        });<br>    }<br><br><br>    void stop() {<br>        flag = true;<br>        this.es.shutdown();<br>    }<br>}<br>","like_count":0},{"had_liked":false,"id":280273,"user_name":"Geek_a852c8","can_delete":false,"product_type":"c1","uid":2206508,"ip_address":"","ucode":"D925A9D71A76BA","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/O6qftWBakkjQHrAhF5tia21GKkQxibJaPy2nWUKc9eiaouaqb67Hj60RRKgjgHhzPmaxaHkLszcNYrDSkj21lPylQ/132","comment_is_top":false,"comment_ctime":1614148286,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614148286","product_id":100023901,"comment_content":"LogMsg log = bq.poll( 5, TimeUnit.SECONDS); 这个位置不太对吧。 如果我前4秒写了100条INFO的日志，没有flush。后面又没有日志到BlockingQueue了。那么他等5秒的话，返回值是空，这时就不满足：存在未刷盘数据，且 5 秒钟内未曾刷盘，需要立即刷盘。改成这样：LogMsg log = bq.poll( 5000 - (System.currentTimeMillis()-preFT), TimeUnit.MilliSECONDS); 才对吧","like_count":0},{"had_liked":false,"id":235153,"user_name":"delete is create","can_delete":false,"product_type":"c1","uid":1147979,"ip_address":"","ucode":"A8C751219A7746","user_header":"https://static001.geekbang.org/account/avatar/00/11/84/4b/e4738ba8.jpg","comment_is_top":false,"comment_ctime":1594909191,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1594909191","product_id":100023901,"comment_content":"pollTasks 消费者里  我觉得最好设置一个batch_size 吧  到了这个阈值就执行入库，要不队列里一直有，那就一直取么","like_count":0},{"had_liked":false,"id":199835,"user_name":"😜哈哈","can_delete":false,"product_type":"c1","uid":1069001,"ip_address":"","ucode":"1FF58FB3A91135","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/c9/88837387.jpg","comment_is_top":false,"comment_ctime":1585496704,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585496704","product_id":100023901,"comment_content":"生产者消费者模型优选现有第三方mq","like_count":0},{"had_liked":false,"id":173996,"user_name":"feihui","can_delete":false,"product_type":"c1","uid":1007294,"ip_address":"","ucode":"13F1D4A82BC650","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/be/9ea55f46.jpg","comment_is_top":false,"comment_ctime":1579856655,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1579856655","product_id":100023901,"comment_content":"日志的那个程序中“LogMsg log = bq.poll( 5, TimeUnit.SECONDS);” 其中的 5 是不是应该是动态计算为 System.currentTimeMillis()-preFT，不然会出现旧数据 10 秒后才保存","like_count":0,"discussions":[{"author":{"id":1667033,"avatar":"","nickname":"Geek_c4e04c","note":"","ucode":"59632B3BA4B9F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295545,"discussion_content":"你发现的问题是对的，但是解法不对，应该改成preFT+5000-System.currentTimeMillis()","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596244593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":149241,"user_name":"Joker","can_delete":false,"product_type":"c1","uid":1156592,"ip_address":"","ucode":"126AF848001A1E","user_header":"https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg","comment_is_top":false,"comment_ctime":1573177906,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573177906","product_id":100023901,"comment_content":"如果没有队列的话：就会，一个生产线程就需要一个消费线程来相互跟进，所以这个就但是消费的赶不上生产的速度，就导致了两个问题：1.等待，2.多余线程创建。","like_count":0},{"had_liked":false,"id":119910,"user_name":"王藝明","can_delete":false,"product_type":"c1","uid":1546333,"ip_address":"","ucode":"374D68B8D3FAFC","user_header":"https://static001.geekbang.org/account/avatar/00/17/98/5d/8e91b338.jpg","comment_is_top":false,"comment_ctime":1564726640,"is_pvip":false,"replies":[{"id":"53940","content":"取光为止","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1570718336,"ip_address":"","comment_id":119910,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564726640","product_id":100023901,"comment_content":"老师好！批量插入 SQL 的案例中，【首先是以阻塞方式获取任务队列中的一条任务，而后则是以非阻塞的...】下面的代码，感觉如果一直能取到内容，岂不是退不出循环体了","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461125,"discussion_content":"取光为止","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570718336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115758,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1563719551,"is_pvip":false,"replies":[{"id":"42311","content":"应该都是4个空格<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1563754558,"ip_address":"","comment_id":115758,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563719551","product_id":100023901,"comment_content":"宝令老师，现在大公司代码规范都是缩进两空格么？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459274,"discussion_content":"应该都是4个空格\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563754558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115715,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1563703832,"is_pvip":false,"replies":[{"id":"51086","content":"火眼金睛👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1568507041,"ip_address":"","comment_id":115715,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563703832","product_id":100023901,"comment_content":"批量执行的代码第七行应该是executors，少了个e","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459249,"discussion_content":"火眼金睛👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568507041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113190,"user_name":"unanao","can_delete":false,"product_type":"c1","uid":1510485,"ip_address":"","ucode":"8F81ECF05D420C","user_header":"http://thirdwx.qlogo.cn/mmopen/ajNVdqHZLLAZUMxZDXiaVdiaEq6wK8XMBBXiaA6icoQykatgybzeqicLUv3420cCPqONmTwTZBydJG5V1TiamIyeiaTxw/132","comment_is_top":false,"comment_ctime":1562911574,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562911574","product_id":100023901,"comment_content":"下面代码使用drainTo更方便一些：<br>Task t = bq.take(); <br>while (t != null) {<br>    ts.add(t); <br>    t = bp.poll();<br>}<br><br>可以修改为：<br>t = bq.take();<br>bq.drainTo(ts);<br>ts.add(t); <br><br><br>","like_count":0},{"had_liked":false,"id":97977,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1558858077,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558858077","product_id":100023901,"comment_content":"worker Thread模式，worker相当于线程池里面的线程<br>生产者-消费者，相当于我们自己维护队列，队列，出队操作，然后比如消费者的话就可以直接使用线程池来消费，和worker Thread模式的区别和联系的话，worker Thread就是线程池工作的线程，生产者消费者就是线程池（worker Thread + 内部的队列+对内部队列的操作）+外部自己维护的队列+对外部队列的操作。<br>课后习题：多加个stop（）{terminated = true;es.shutdown()} 方法，将上面的while(true)改成while(!terminated)","like_count":0},{"had_liked":false,"id":97112,"user_name":"中年英雄王叔叔","can_delete":false,"product_type":"c1","uid":1116873,"ip_address":"","ucode":"701AC00E96A012","user_header":"https://static001.geekbang.org/account/avatar/00/11/0a/c9/3e71e615.jpg","comment_is_top":false,"comment_ctime":1558591472,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558591472","product_id":100023901,"comment_content":"我的理解是工人和工厂是耦合的，即线程池开始就有worker在了，而工厂和消费者则没什么关系","like_count":0},{"had_liked":false,"id":96596,"user_name":"ban","can_delete":false,"product_type":"c1","uid":1034204,"ip_address":"","ucode":"E523CE97E48266","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/dc/9408c8c2.jpg","comment_is_top":false,"comment_ctime":1558455726,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558455726","product_id":100023901,"comment_content":"我的想法是：弄一个volite可见性的标志位，当出发标志位的时候检查当前是否还有日志，有则取出来，直到阻塞队列为空，然后刷盘写入数据，然后break退出即可。<br>老师你看是否可行","like_count":0},{"had_liked":false,"id":96583,"user_name":"ban","can_delete":false,"product_type":"c1","uid":1034204,"ip_address":"","ucode":"E523CE97E48266","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/dc/9408c8c2.jpg","comment_is_top":false,"comment_ctime":1558452921,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558452921","product_id":100023901,"comment_content":" while (t != null) {<br>    ts.add(t);<br>    &#47;&#47; 非阻塞式获取一条任务<br>    t = bq.poll();<br>  }<br><br>加入集合的时候，是不是加个条数限制比较好，防止数据过多，把集合撑爆了","like_count":0},{"had_liked":false,"id":96393,"user_name":"佑儿","can_delete":false,"product_type":"c1","uid":1226196,"ip_address":"","ucode":"0629888E7A5E16","user_header":"https://static001.geekbang.org/account/avatar/00/12/b5/d4/3bd5b77b.jpg","comment_is_top":false,"comment_ctime":1558407945,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558407945","product_id":100023901,"comment_content":"我觉得这里虽然没有使用可中断操作，如果不考虑第三方的调用影响，也可以使用线程中断标识，只不过不能捕获异常。","like_count":0},{"had_liked":false,"id":96336,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1558400562,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1558400562","product_id":100023901,"comment_content":"打卡！监控系统那个例子里边pollTasks（）方法里边的 while循环怎么退出？那个while循环会一直把阻塞获取的第一条任务添加到任务队列。","like_count":0,"discussions":[{"author":{"id":1079495,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/c7/083a3a0b.jpg","nickname":"新世界","note":"","ucode":"4473DC1505F158","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549130,"discussion_content":"while循环第一次是阻塞获取数据，后面是poll非阻塞，获取完后poll就会返回为null就退出循环了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643597009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96284,"user_name":"刘绍","can_delete":false,"product_type":"c1","uid":1056297,"ip_address":"","ucode":"0802160061241F","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/29/3eefbebf.jpg","comment_is_top":false,"comment_ctime":1558392662,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558392662","product_id":100023901,"comment_content":"一大早就更新了，够早的","like_count":0}]}