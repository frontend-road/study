{"id":613332,"title":"06｜事件通知：一招打败各种神乎其神的回调事件","content":"<p>你好，我是何辉。今天我们探索Dubbo框架的第五道特色风味，事件通知。</p><p>如果你用过Spring的Event事件，想必对事件通知不陌生，我们看个项目例子回顾一下，比如有个支付系统提供了一个商品支付功能：</p><p><img src=\"https://static001.geekbang.org/resource/image/03/6d/034d9d2fe33b9aaa3e0f7b59c8bf9d6d.jpg?wh=1920x686\" alt=\"图片\"></p><p>图中的支付系统暴露了一个支付请求的Dubbo接口，支付核心业务逻辑是调用核心支付系统完成，当支付状态翻转为支付成功后，还需要额外做些事情，比如埋点商品信息、短信告知用户和通知物流派件。</p><p>面对这样一个完成核心功能后还需要额外处理多个事件的需求，你会怎么优雅地快速处理呢？</p><h2>面向过程编程</h2><p>商品支付成功后需要处理三件事（埋点、发短信、通知物流），这样的需求，你一定觉得简直太小儿科了，从上到下写就完事了。实现体逻辑就是图中线性的形式：</p><p><img src=\"https://static001.geekbang.org/resource/image/ec/31/ec1ab2fd0656de8ayy2f8a4e619fa531.jpg?wh=1920x879\" alt=\"图片\"></p><pre><code class=\"language-java\">@DubboService\n@Component\npublic class PayFacadeImpl implements PayFacade {\n    // 商品支付功能：一个大方法\n    @Override\n    public PayResp recvPay(PayReq req){\n        // 支付核心业务逻辑处理\n        此处省略若干行代码\n        \n        // 埋点已支付的商品信息\n        此处省略若干行代码\n        \n        // 发送支付成功短信给用户\n        此处省略若干行代码\n        \n        // 通知物流派件\n        此处省略若干行代码\n        \n        // 返回支付结果\n        return buildSuccResp();\n    }\n}\n</code></pre><!-- [[[read_end]]] --><p>支付系统完成核心业务逻辑后，先调用埋点SDK进行支付商品埋点，然后调用短信平台发送短信，最后向MQ发送了一条物流派送消息。整个编码流程一气呵成。</p><p>但是细想一下，一个大方法里写完所有功能逻辑，搞不好会有几千行代码。这种面向过程的写法，虽然写代码的人很爽，但是看代码的人可能会迷失方向，更重要的是可读性变差，增加了维护成本，也延长了维护周期。</p><p>机智的你要补充了，那就<strong>用面向对象编程的思路，把一些小功能用小方法封装一下</strong>，让那一大坨代码整体看起来整洁点。</p><p>好，我们整顿一下，把原来的大方法做细粒度的拆分：</p><p><img src=\"https://static001.geekbang.org/resource/image/ff/b5/ff3a924aa949318165a2cd1c08d5d7b5.jpg?wh=1920x879\" alt=\"图片\"></p><pre><code class=\"language-java\">@DubboService\n@Component\npublic class PayFacadeImpl implements PayFacade {\n    // 商品支付功能：一个大方法\n    @Override\n    public PayResp recvPay(PayReq req){\n        // 支付核心业务逻辑处理\n        method1();\n        \n        // 埋点已支付的商品信息\n        method2();\n        \n        // 发送支付成功短信给用户\n        method3();\n        \n        // 通知物流派件\n        method4();\n        \n        // 返回支付结果\n        return buildSuccResp();\n    }\n}\n</code></pre><p>商品支付功能的核心业务逻辑和另外3件事，是相对独立的功能，分别封装成了小方法。</p><p>改善后，支付功能的实现体逻辑整洁多了，大方法里面的4个小方法已经体现了该商品支付的大致业务流程，大体上有点封装的样子，代码主流程变清晰，可读性变强，各个模块之间有了一定的边界，维护起来也更容易。</p><p>但停在这里，可能会为我们之后的繁重工作量埋下种子，比如一周后需求又来了，要发送邮件、通知结算，怎么办呢？是不是还得继续添加小方法5和小方法6？</p><p>其实吧，<strong>继续追加小方法是我们大多数开发人员惯用的伎俩</strong>，直接在已有的代码后面接着写就完事，这样也没有什么大毛病，无非就是逻辑多了，方法多了，阅读起来比较费劲，只要功能能跑就阿弥陀佛了。</p><p>可是慢慢地，你就会发现自己变成只会垒业务代码的机器人了，毫无思考、毫无设计，很难掌控大型功能、系统或系统群的设计，将来机会来临时处处捉襟见肘，实施起来困难重重。</p><p>为了提升代码水平，我们继续思考商品支付的功能设计。</p><h2>改造小技巧</h2><p>分析现在的代码逻辑，虽然大方法中用一堆小方法串起来了，流程好像挺完美的，但核心逻辑和三个不那么关键的事件合在一起写，似乎没有重点可言，难以看出主要解决什么问题，容易让后续维护者随波逐流修改起来毫无章法，导致难以维护、复用和灵活扩展。</p><p>既然一起写不那么友好的话，分开不就行了？怎么分呢？</p><h3>如何解耦</h3><p>“分开”其实就是要做解耦，这里我教你一个解耦小技巧，从3方面分析：</p><ol>\n<li><strong>功能相关性</strong>。将一些功能非常相近的汇聚成一块，既是对资源的聚焦整合，也降低了他人的学习成本，尊重了人类物以类聚的认知习惯。</li>\n</ol><p>具体怎么判断功能相近受很多因素影响，比如你的团队构成、组织划分、认知高低对业务的理解等等，倾向各不相同，并没有绝对的标准，合适的、团队认可的才是最好的。</p><ol start=\"2\">\n<li><strong>密切相关性</strong>。按照与主流程的密切相关性，将一个个小功能分为密切与非密切。</li>\n<li><strong>状态变更性</strong>。按照是否有明显业务状态的先后变更，将一个个小功能再归类。</li>\n</ol><p>按照小技巧我们再梳理一下这4个功能：</p><p><img src=\"https://static001.geekbang.org/resource/image/e5/5a/e518a40f98219a699789a42bfba2a95a.jpg?wh=1920x692\" alt=\"图片\"></p><p>先看功能相关性，四个小功能的拆分没问题；再看密切相关性，支付核心业务逻辑是最重要的，其他三个事件的重要程度和迫切性并不高；最后看状态变更性，核心业务逻辑有了明显的状态变更后，在支付成功的关键节点后，驱动着继续做另外三件事。</p><p>所以如何解耦呢？<strong>我们可以将核心逻辑与三个事件剥离开，只有核心逻辑翻转为支付成功时才处理三个事件。</strong></p><p>这个例子的需求比较简单，你可以重点体会这个解耦技巧的思想，实际开发过程中的需求会复杂的多，用这个方法能很好地辅助你解耦需求问题。</p><h2>如何串联</h2><p>解耦完成，如何形成有血有肉、主次分明的结构呢？</p><p>相信你也想到了——以事件驱动的方式串联起来。事件驱动，简单理解就是一个事件会触发另一个或多个事件做出对应的响应行为。</p><p>在这个例子里，支付核心业务逻辑翻转为支付成功时，以这个状态变更节点为基准点，会触发另外三个事件做出对应的变化，<strong>该怎么从代码层面把这个串联的思路落地呢？</strong></p><p>难道要核心逻辑执行后，再执行三个事件逻辑？如果是这样，岂不是又回到了面向过程的写法了，这明显不行。难道要把三个事件的代码写到核心逻辑以外么？</p><pre><code class=\"language-java\">@DubboService\n@Component\npublic class PayFacadeImpl implements PayFacade {\n    // 商品支付功能：一个大方法\n    @Override\n    public PayResp recvPay(PayReq req){\n        // 支付核心业务逻辑处理\n        method1();\n              \n        // 返回支付结果\n        return buildSuccResp();\n    }\n}\n</code></pre><p>商品支付功能的实现体逻辑中只有 method1 方法，其他三个事件没有写在 recvPay 方法中了。考虑到我们要体现 recvPay 的核心逻辑，然后在核心逻辑翻转为支付成功时调用另外3个事件，<strong>现在的问题就是这个调用时机该怎么切入，或者说，怎么找到三个事件被调用的入口？</strong></p><p>为了快速落地编码，我们需要一个大的指导方向，拎清代码逻辑的每个环节需要什么，可以从哪些环节下手，来更好地把事件放到代码合适的位置进行解耦。</p><p>这里我再给你介绍一个小技巧——6W分析模型：</p><ul>\n<li>Who谁产生的事件？是功能本身业务实现体产生，还是功能归属源码框架来产生。</li>\n<li>What产生什么功能的事件？事件数据对象包含业务信息和事件凭证信息。</li>\n<li>When什么时候发生的事件？在业务发生之前、之后，还是业务发生异常时发布。</li>\n<li>Where在哪个系统、哪个功能、哪段代码位置发生的事件？</li>\n<li>Why为什么要有这个事件？解决某类或某系列的问题，提供一种扩展机制来丰富事件价值。</li>\n<li>How怎么把事件发布给需要关注的消费者？是自研框架，还是扩展已有框架中具有拦截或过滤特性的机制。</li>\n</ul><p>我们用这个模型先简单分析这三个事件，Who，都是商品支付功能中产生的支付完成事件；What，事件里面应该都具有商品和支付的关键信息，以及事件的唯一凭证信息；When，在商品支付功能核心逻辑处理完成后，支付状态翻转为支付成功时触发。</p><p><strong>接下来的Where，支付成功后，这三个额外的事件放到哪个位置合适呢？</strong></p><p>按照6W中Who，这三个事件是商品支付功能支付完成后需要去完成的事件，即我们需要在商品支付功能中提供这样的机制。但recvPay方法主体是用来体现核心支付逻辑的，这个模块中已经没法再追加代码了。那怎么办呢？</p><p>考虑到商品支付这个功能也只是Dubbo众多接口中的一个，我们不妨升维思考，站在Dubbo接口的框架调用流程中，看看是否可以在商品支付功能method1远程调用的前后做点事情来提供事件通知的入口。</p><p>回忆Dubbo调用远程的整个流程：</p><p><img src=\"https://static001.geekbang.org/resource/image/e1/f5/e1eb8d4f8f5ff3fyye575cf3ff8e24f5.png?wh=1920x488\" alt=\"图片\"></p><p>从商品支付功能的处理，到拦截模块，到代理模块，到网络模块，最后经过公网发送至核心支付系统。</p><p>从这张图中，你能看到业务模块是触发事件的源头，调用出去时经过拦截模块，返回也经过拦截模块，所以似乎可以借助拦截模块，实现一种新机制拦截Dubbo接口，类似面向切面编程的思想。</p><p>一想到AOP，我们就有想法了：</p><ol>\n<li>通过定义标准接口，让需要额外事件特性的功能去实现标准接口。</li>\n<li>通过反射调用，去调用任意指定的回调方法，按照约定好的规则去接口级别配置回调方法。</li>\n</ol><h3>想法一标准接口</h3><p>先看想法一，在底层定制标准接口：</p><pre><code class=\"language-java\">// 假设定制底层标准接口\npublic interface FrameworkNotifyService {\n    // 调用之前\n    void onInvoke(Request req);\n    // 调用之后\n    void onReturn(Response resp, Request req);\n    // 调用异常\n    void onThrow(Throwable ex, Request req);\n}\n</code></pre><p>底层标准接口里面有调用前、调用完成、调用异常的三个方法，然后让各自接口去实现标准接口，呈现出来的代码调用形式如图：<br>\n<img src=\"https://static001.geekbang.org/resource/image/31/54/311b4df4398dbdfyydb586e483e35254.png?wh=1853x1400\" alt=\"图片\"></p><pre><code class=\"language-java\">@DubboService\n@Component\npublic class PayFacadeImpl implements PayFacade, FrameworkNotifyService {\n    // 商品支付功能：一个大方法\n    @Override\n    public PayResp recvPay(PayReq req){\n        // 支付核心业务逻辑处理\n        method1();\n        // 返回支付结果\n        return buildSuccResp();\n    }\n    // 调用之前\n    @Override\n    void onInvoke(Request req){\n        System.out.println(\"[事件通知][调用之前] onInvoke 执行.\");\n    }\n    // 调用之后\n    @Override\n    void onReturn(Response resp, Request req){\n        System.out.println(\"[事件通知][调用之后] onReturn 执行.\");\n        // 埋点已支付的商品信息\n        method2();\n        // 发送支付成功短信给用户\n        method3();\n        // 通知物流派件\n        method4();\n    }\n    // 调用异常\n    @Override\n    void onThrow(Throwable ex, Request req){\n        System.out.println(\"[事件通知][调用异常] onThrow 执行.\");\n    }\n    @Override\n    public AliPayResp aliPay(AliPayReq req){\n        // 此处省略若干行代码\n        // 返回支付结果\n        return buildAliPayResp();\n    }\n    @Override\n    public WeixinPayResp weixinPay(WeixinerPayReq req){\n        // 此处省略若干行代码\n        // 返回支付结果\n        return buildWeixinPayResp();\n    }    \n}\n</code></pre><p>我们已为 recvPay 方法在类上继承了 FrameworkNotifyService&nbsp;底层标准接口，但是还想为 aliPay、weixinPay 方法再继续配置 FrameworkNotifyService&nbsp;底层标准接口时，发现行不通了，因为 FrameworkNotifyService 在 PayFacadeImpl 中只能被 implements 声明一次，声明多次是不符合语法的。</p><p>即使假设可以在 PayFacadeImpl 中声明 3 个 FrameworkNotifyService 标准接口，那么会出现 3 个一模一样的 onInvoke 方法需要被重写，到时候我们怎么分清哪个 onInvoke 是属于 recvPay 方法的接口回调呢？明显更加不合理了，想法一PASS。</p><h3>想法二反射调用</h3><p>那就看想法二，在接口级别配置回调方法，配置是开发人员配的：</p><p><img src=\"https://static001.geekbang.org/resource/image/c3/30/c3e95912b1d28b79ed893bb550c3c330.png?wh=1920x941\" alt=\"图片\"></p><p>在前置、后置、异常时都去读取配置回调指定的方法，即使将来配错了出现bug也是开发人员的问题，并不是我们框架的问题，框架只需要把这套反射回调的逻辑做稳定。这样一来<strong>6W中Why</strong>落地了。</p><p>这套反射回调方法的机制是在实现体调用的前、后和异常时被触发的，那<strong>6W中When和How</strong>也落地了。至于<strong>Where，</strong>要想拥有这样的环绕切面效果，自然得在过滤器里面的 invoker.invoke(invocation) 方法前后执行。</p><p>就剩下<strong>6W中What</strong>，事件信息该怎么传递到回调方法里。如果底层框架定制一套事件对象，不可避免将来要为维护事件对象买单，所以简单起见，不如跟随Dubbo接口的入参和反参来定义事件信息，免去后顾之忧。</p><p>好6W都想清楚了，按照想法二，我们画出逻辑图：</p><p><img src=\"https://static001.geekbang.org/resource/image/43/08/4397d2b52f1a3c3345ca5889c3427808.jpg?wh=1920x791\" alt=\"图片\"></p><p>把AOP的思想充分应用到了拦截模块中，在执行下一步调用之前、之后、异常时包裹了一层。</p><p>那过滤器的代码该怎么写呢？其实Dubbo底层的源码已经按照我们的预想实现了一番：</p><pre><code class=\"language-java\">@Activate(group = CommonConstants.CONSUMER)\npublic class FutureFilter implements ClusterFilter, ClusterFilter.Listener {\n    protected static final Logger logger = LoggerFactory.getLogger(FutureFilter.class);\n    @Override\n    public Result invoke(final Invoker&lt;?&gt; invoker, final Invocation invocation) throws RpcException {\n        // 调用服务之前：执行Dubbo接口配置中指定服务中的onInvoke方法\n        fireInvokeCallback(invoker, invocation);\n        // need to configure if there's return value before the invocation in order to help invoker to judge if it's\n        // necessary to return future.\n        // 调用服务并返回调用结果\n        return invoker.invoke(invocation);\n    }\n    \n    // 调用服务之后：\n    // 正常返回执行Dubbo接口配置中指定服务中的onReturn方法\n    // 异常返回执行Dubbo接口配置中指定服务中的onThrow方法\n    @Override\n    public void onResponse(Result result, Invoker&lt;?&gt; invoker, Invocation invocation) {\n        if (result.hasException()) {\n            // 调用出现了异常之后的应对处理\n            fireThrowCallback(invoker, invocation, result.getException());\n        } else {\n            // 正常调用返回结果的应对处理\n            fireReturnCallback(invoker, invocation, result.getValue());\n        }\n    }\n    \n    // 调用框架异常后：\n    // 异常返回执行Dubbo接口配置中指定服务中的onThrow方法\n    @Override\n    public void onError(Throwable t, Invoker&lt;?&gt; invoker, Invocation invocation) {\n        fireThrowCallback(invoker, invocation, t);\n    }\n}    \n</code></pre><p>从源码中可以看出，利用 FutureFilter 过滤器，主要做了3件事情：</p><ul>\n<li>在 invoker.invoke(invocation) 方法之前，利用 fireInvokeCallback 方法反射调用了接口配置中指定服务中的 onInvoke 方法。</li>\n<li>然后在 onResponse 响应时，处理了正常返回和异常返回的逻辑，分别调用了接口配置中指定服务中的 onReturn、onThrow 方法。</li>\n<li>最后在 onError 框架异常后，调用了接口配置中指定服务中的 onThrow 方法。</li>\n</ul><p>你有没有发现，根据现状诉求来推导，逐步分析问题并实现一套简单的事件通知机制，也能达到和源码如出一辙的效果，可谓是条条大路通罗马。</p><h2>如何改造</h2><p>接下来就是轻松环节了，核心逻辑和三个事件逻辑该怎么写呢？我们可以直接根据源码所提供的支撑能力，重新修改 recvPay 方法：</p><pre><code class=\"language-java\">@DubboService\n@Component\npublic class PayFacadeImpl implements PayFacade {\n    @Autowired\n    @DubboReference(\n            /** 为 DemoRemoteFacade 的 sayHello 方法设置事件通知机制 **/\n            methods = {@Method(\n                    name = \"sayHello\",\n                    oninvoke = \"eventNotifyService.onInvoke\",\n                    onreturn = \"eventNotifyService.onReturn\",\n                    onthrow = \"eventNotifyService.onThrow\")}\n    )\n    private DemoRemoteFacade demoRemoteFacade;\n    \n    // 商品支付功能：一个大方法\n    @Override\n    public PayResp recvPay(PayReq req){\n        // 支付核心业务逻辑处理\n        method1();\n        // 返回支付结果\n        return buildSuccResp();\n    }\n    private void method1() {\n        // 省略其他一些支付核心业务逻辑处理代码\n        demoRemoteFacade.sayHello(buildSayHelloReq());\n    }\n}\n\n// 专门为 demoRemoteFacade.sayHello 该Dubbo接口准备的事件通知处理类\n@Component(\"eventNotifyService\")\npublic class EventNotifyServiceImpl implements EventNotifyService {\n    // 调用之前\n    @Override\n    public void onInvoke(String name) {\n        System.out.println(\"[事件通知][调用之前] onInvoke 执行.\");\n    }\n    // 调用之后\n    @Override\n    public void onReturn(String result, String name) {\n        System.out.println(\"[事件通知][调用之后] onReturn 执行.\");\n        // 埋点已支付的商品信息\n        method2();\n        // 发送支付成功短信给用户\n        method3();\n        // 通知物流派件\n        method4();\n    }\n    // 调用异常\n    @Override\n    public void onThrow(Throwable ex, String name) {\n        System.out.println(\"[事件通知][调用异常] onThrow 执行.\");\n    }\n}\n</code></pre><p>代码中，我们主要做了4点调整：</p><ul>\n<li>创建了一个服务类 EventNotifyServiceImpl，里面定义了 onInvoke、onReturn、onThrow 三个事件通知机制的方法。</li>\n<li>按照 FutureFilter 的规定定义好 EventNotifyServiceImpl 中三个方法的入参。</li>\n<li>在 demoRemoteFacade 字段修饰的 @DubboReference 注解上添加事件通知的 @Method 相关属性配置。</li>\n<li>将支付核心业务逻辑处理继续留在 recvPay 方法中，然后将埋点、发短信、通知物流三个事件转移到了 EventNotifyServiceImpl.onReturn 方法中了。</li>\n</ul><p>通过这样的整理，我们彻底在 recvPay 方法中凸显了支付核心业务逻辑的重要性，剥离解耦了其他三件事与主体核心逻辑的边界。</p><p>当然，不光是Dubbo框架有这样优秀的回调机制，我们来回顾一下常用的一些事件回调机制：</p><ul>\n<li>Spring 框架，使用 publishEvent 方法发布 ApplicationEvent 事件。</li>\n<li>Tomcat 框架，在 Javax 规范的 ServletContainerInitializer.onStartup 方法中继续循环回调 ServletContextInitializer 接口的所有实现类。</li>\n<li>JVM 的关闭钩子事件，当程序正常退出或调用System.exit 或虚拟机被关闭时，会调用 Runtime.addShutdownHook 注册的线程。</li>\n</ul><p>类比我们今天分析的Dubbo源码思路，现在你可以设身处地的站在设计者兼使用者的角度再看这些源码了，相信你一定会有新体会。</p><p>我们常说源码中有很多优秀的设计值得学习，有时候并不是因为源码有多高深，而是在特定的框架中解决了某一类或某一系列的问题，而恰巧框架的这个解决方案又满足了我们在特定场景的诉求，使得我们可以在非常短的时间内实现业务需求。</p><h3>事件通知的应用</h3><p>事件通知的应用我们已经掌握了，不过，事件通知也只是一种机制流程，那在我们日常开发中，哪些应用场景可以考虑事件通知呢？</p><p>第一，职责分离，可以按照功能相关性剥离开，让各自的逻辑是内聚的、职责分明的。</p><p>第二，解耦，把复杂的面向过程风格的一坨代码分离，可以按照功能是技术属性还是业务属性剥离。</p><p>第三，事件溯源，针对一些事件的实现逻辑，如果遇到未知异常后还想再继续尝试重新执行的话，可以考虑事件持久化并支持在一定时间内重新回放执行。</p><h2>总结</h2><p>今天，我们从一个普通的商品支付功能开始，抛出如何优雅快速处理多个事件的问题，从面向过程，到简单封装，再到面向对象分析，我们采用巧妙的6W分析模型，推导出了与源码不谋而合的解决方案。</p><p>回顾一下6W分析模型要素：</p><ul>\n<li>Who：谁产生的事件，是功能本身业务实现体产生，还是功能归属源码框架来产生。</li>\n<li>What：产生什么功能的事件，事件数据对象包含业务信息和事件凭证信息。</li>\n<li>When：什么时候发生的事件，在业务发生之前、业务发生之后，还是业务发生异常时发布事件。</li>\n<li>Where：是在哪个系统、哪个功能、哪段代码位置发生的。</li>\n<li>Why：解决某一类或某一系列的问题，提供一种扩展机制来丰富事件价值。</li>\n<li>How：怎么发布事件，是自研框架，还是扩展已有框架中具有拦截或过滤特性的机制。</li>\n</ul><p>Dubbo框架中设置事件通知的简单三部曲：</p><ul>\n<li>首先，创建一个服务类，在该类中添加 onInvoke、onReturn、onThrow 三个方法。</li>\n<li>其次，在三个方法中按照源码 FutureFilter 的规则定义好方法入参。</li>\n<li>最后，@DubboReference 注解中或者<a href=\"dubbo:reference/\">dubbo:reference/</a>标签中给需要关注事件的Dubbo接口添加配置即可。</li>\n</ul><p>事件通知的应用场景主要有3类，职责分离、解耦、事件溯源。</p><h3>思考题</h3><p>你已经学会了事件通知机制的推导解决方案，可以说是掌握了使用和设计事件机制的精髓，今天的巩固练习是尝试研究源码，思考为什么Dubbo框架的事件通知机制不会因为重试机制的存在而触发多次呢？</p><p>欢迎留言参与讨论，如果有收获也欢迎分享给身边的朋友，说不定就帮他解决了一个问题，我们下一讲见。</p><h3>05思考题参考</h3><p>上一期的问题是源码中，点点直连在 ReferenceConfig 中设置的 url 属性是怎么和提供方建立通信连接的。</p><p>想要解答这个问题，与其顺着源码找答案，不如逆向通过异常结果找答案。其实挺简单的，比如url = dubbo://192.168.43.200:20883，IP和PORT都是随便填的，我们就是要看报错，只有报错了，我们才知道源码在哪里发起的连接。</p><p>先想办法运行程序来个报错先：</p><pre><code class=\"language-java\">Exception in thread \"main\" org.apache.dubbo.rpc.RpcException: Fail to create remoting client for service(dubbo://192.168.43.200:20883/com.hmilyylimh.cloud.facade.user.UserQueryFacade?application=dubbo-15-generic-string-consumer&amp;background=false&amp;codec=dubbo&amp;generic=true&amp;heartbeat=60000&amp;interface=com.hmilyylimh.cloud.facade.user.UserQueryFacade&amp;pid=10516&amp;qos.enable=false&amp;register.ip=192.168.100.183&amp;side=consumer&amp;sticky=false): client(url: dubbo://192.168.43.200:20883/com.hmilyylimh.cloud.facade.user.UserQueryFacade?application=dubbo-15-generic-string-consumer&amp;background=false&amp;codec=dubbo&amp;generic=true&amp;heartbeat=60000&amp;interface=com.hmilyylimh.cloud.facade.user.UserQueryFacade&amp;pid=10516&amp;qos.enable=false&amp;register.ip=192.168.100.183&amp;side=consumer&amp;sticky=false) failed to connect to server /192.168.43.200:20883 client-side timeout 3000ms (elapsed: 3004ms) from netty client 192.168.100.183 using dubbo version 3.0.7\n\tat org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.initClient(DubboProtocol.java:653)\n\tat org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.buildReferenceCountExchangeClient(DubboProtocol.java:610)\n\tat org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.buildReferenceCountExchangeClientList(DubboProtocol.java:597)\n\tat org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.getSharedClient(DubboProtocol.java:522)\n\tat org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.getClients(DubboProtocol.java:454)\n\tat org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.protocolBindingRefer(DubboProtocol.java:431)\n\tat org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.refer(DubboProtocol.java:422)\n\tat org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper.refer(ProtocolListenerWrapper.java:77)\n\tat org.apache.dubbo.qos.protocol.QosProtocolWrapper.refer(QosProtocolWrapper.java:85)\n\tat org.apache.dubbo.rpc.cluster.filter.ProtocolFilterWrapper.refer(ProtocolFilterWrapper.java:74)\n\tat org.apache.dubbo.rpc.protocol.ProtocolSerializationWrapper.refer(ProtocolSerializationWrapper.java:52)\n\tat org.apache.dubbo.rpc.Protocol$Adaptive.refer(Protocol$Adaptive.java)\n\tat org.apache.dubbo.config.ReferenceConfig.createInvokerForRemote(ReferenceConfig.java:494)\n\tat org.apache.dubbo.config.ReferenceConfig.createProxy(ReferenceConfig.java:397)\n\tat org.apache.dubbo.config.ReferenceConfig.init(ReferenceConfig.java:285)\n\tat org.apache.dubbo.config.ReferenceConfig.get(ReferenceConfig.java:219)\n\tat com.hmilyylimh.cloud.generic.string.Dubbo15GenericStringConsumerApplication.stringStyleRpcInvoke(Dubbo15GenericStringConsumerApplication.java:27)\n\tat com.hmilyylimh.cloud.generic.string.Dubbo15GenericStringConsumerApplication.main(Dubbo15GenericStringConsumerApplication.java:18)\nCaused by: org.apache.dubbo.remoting.RemotingException: client(url: dubbo://192.168.43.200:20883/com.hmilyylimh.cloud.facade.user.UserQueryFacade?application=dubbo-15-generic-string-consumer&amp;background=false&amp;codec=dubbo&amp;generic=true&amp;heartbeat=60000&amp;interface=com.hmilyylimh.cloud.facade.user.UserQueryFacade&amp;pid=10516&amp;qos.enable=false&amp;register.ip=192.168.100.183&amp;side=consumer&amp;sticky=false) failed to connect to server /192.168.43.200:20883 client-side timeout 3000ms (elapsed: 3004ms) from netty client 192.168.100.183 using dubbo version 3.0.7\n\tat org.apache.dubbo.remoting.transport.netty4.NettyClient.doConnect(NettyClient.java:197)\n\tat org.apache.dubbo.remoting.transport.AbstractClient.connect(AbstractClient.java:214)\n\tat org.apache.dubbo.remoting.transport.AbstractClient.&lt;init&gt;(AbstractClient.java:74)\n\tat org.apache.dubbo.remoting.transport.netty4.NettyClient.&lt;init&gt;(NettyClient.java:89)\n\tat org.apache.dubbo.remoting.transport.netty4.NettyTransporter.connect(NettyTransporter.java:40)\n\tat org.apache.dubbo.remoting.Transporter$Adaptive.connect(Transporter$Adaptive.java)\n\tat org.apache.dubbo.remoting.Transporters.connect(Transporters.java:74)\n\tat org.apache.dubbo.remoting.exchange.support.header.HeaderExchanger.connect(HeaderExchanger.java:39)\n\tat org.apache.dubbo.remoting.exchange.Exchangers.connect(Exchangers.java:107)\n\tat org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.initClient(DubboProtocol.java:649)\n\t... 17 more\n</code></pre><p>说明一下，这段日志信息是方便我们具体分析问题模拟出来的，但你按照泛化调用的方式指定url属性后发起调用发生异常后，看到的日志格式也是大同小异的。</p><p>从异常信息中，我们可以看到 RpcException 和 RemotingException 异常类，在 RemotingException 的下面，可以看到使用了 netty4 版本，调用 NettyClient.doConnect 发生了连接异常。</p><p>紧接着进入到 NettyClient.doConnect 代码中：</p><pre><code class=\"language-java\">protected void doConnect() throws Throwable {\n    long start = System.currentTimeMillis();\n    // 调用 Netty 框架中的 Bootstrap 类与提供方发起连接请求\n    ChannelFuture future = bootstrap.connect(getConnectAddress());\n    // 省略了其他的代码\n}\n</code></pre><p>由此可知，消费方与提供方想建立连接请求，默认是通过 netty 通信框架，源码中使用 Bootstrap.connect 来发起连接请求。</p><p>到这里，你就知道在哪里发起了连接请求了。想继续深入，你可以顺着 Bootstrap.connect 这个方法一直探究，直至找到 io.netty.channel.nio.AbstractNioChannel 这个抽象类，绑定、连接、断开等操作都在这个抽象类中，这是客户端与服务端建立通信连接最重要的类。</p>","comments":[{"had_liked":false,"id":367832,"user_name":"大大大熊myeh","can_delete":false,"product_type":"c1","uid":1139413,"ip_address":"浙江","ucode":"4832C2E7CEB151","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/d5/1f5c5ab6.jpg","comment_is_top":false,"comment_ctime":1675662982,"is_pvip":false,"replies":[{"id":134069,"content":"你好，大大大熊myeh：文章中的例子只是一种引导，大多数实际业务编码时，几乎会很少使用事件通知机制，主要是这些功能都是一些偏业务层面的东西，开发人员会比较倾向于自主控制逻辑走向。\n\n而放在事件通知里面处理的，反而是一些偏技术属性的功能，这些偏技术属性的功能正好可以和业务功能撇清界限，技术功能报错了就报错了，不要求十分精准，能被触发调用到就行了。","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1676016395,"ip_address":"广东","comment_id":367832,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"老师讲解的 Dubbo 事件通知方案好像跟面向过程编程的流程没啥两样，只不过是把若干事件的调用时机转移到了 Dubbo 提供的模板方法中，并且从流程图上来看还是同步调用的吧？\n\n个人觉得只是在可读性上有所增强，具体生产上是否有 dubbo 事件通知相关的应用案例呢？","like_count":1,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":603208,"discussion_content":"你好，大大大熊myeh：文章中的例子只是一种引导，大多数实际业务编码时，几乎会很少使用事件通知机制，主要是这些功能都是一些偏业务层面的东西，开发人员会比较倾向于自主控制逻辑走向。\n\n而放在事件通知里面处理的，反而是一些偏技术属性的功能，这些偏技术属性的功能正好可以和业务功能撇清界限，技术功能报错了就报错了，不要求十分精准，能被触发调用到就行了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676016396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":367179,"user_name":"hello","can_delete":false,"product_type":"c1","uid":1649057,"ip_address":"广东","ucode":"4F42DAA5DB5C38","user_header":"https://static001.geekbang.org/account/avatar/00/19/29/a1/41607383.jpg","comment_is_top":false,"comment_ctime":1674986696,"is_pvip":false,"replies":[{"id":133809,"content":"你好，hello：是滴，能看出你已经有了自己独有的理解想法了，这里是通过引出案例分析解耦理解源码思想而已。","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1675148785,"ip_address":"广东","comment_id":367179,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"虽然埋点、发短信、通知物流三个事件转移到了 EventNotifyServiceImpl.onReturn 方法中了，如果后续继续增加 发邮件 啥的功能还是会出现同样的问题。当然，这篇文章站在分析问题的角度解读源码就另当别论了。","like_count":0,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":601221,"discussion_content":"你好，hello：是滴，能看出你已经有了自己独有的理解想法了，这里是通过引出案例分析解耦理解源码思想而已。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1675148785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365364,"user_name":"熊猫","can_delete":false,"product_type":"c1","uid":1080238,"ip_address":"广东","ucode":"23C85117A16BEF","user_header":"https://static001.geekbang.org/account/avatar/00/10/7b/ae/66ae403d.jpg","comment_is_top":false,"comment_ctime":1672387674,"is_pvip":false,"replies":[{"id":133077,"content":"你好，熊猫：我有点没太理解，当枚举值变更时，是消费方判断报文的值不在自己的范围内么？还是哪种情况？","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1672397006,"ip_address":"广东","comment_id":365364,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"老师，你好，怎么解决当dubbo服务调用返回的对象中有枚举类型，当枚举类型变更时，报错的问题？","like_count":0,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597995,"discussion_content":"你好，熊猫：我有点没太理解，当枚举值变更时，是消费方判断报文的值不在自己的范围内么？还是哪种情况？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672397006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1080238,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7b/ae/66ae403d.jpg","nickname":"熊猫","note":"","ucode":"23C85117A16BEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":597996,"discussion_content":"老师，就是服务提供方使用枚举版本有新增，服务消费方还是用的旧枚举，这个时候服务调用会失败","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672397193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":597995,"ip_address":"四川","group_id":0},"score":597996,"extra":""},{"author":{"id":3870834,"avatar":"","nickname":"Geek_03820a","note":"","ucode":"0D06C0EE8E16EF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1080238,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7b/ae/66ae403d.jpg","nickname":"熊猫","note":"","ucode":"23C85117A16BEF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":640962,"discussion_content":"服务提供方上线完成后，需要涉及的调用方重新部署，然后线上再生产对应的新枚举值的数据，这时候调用方就可以解析了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1712028776,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":597996,"ip_address":"北京","group_id":0},"score":640962,"extra":""}]},{"author":{"id":1346215,"avatar":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","nickname":"William","note":"","ucode":"55F5D9DEE485B1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629264,"discussion_content":"尽量不要用枚举作为参数传递吧 , 定义为比较通用的string 或者int  类型 , 然后匹配不到 报个错误. \n最起码不强制依赖服务端的枚举, 尤其是有的枚举类只写名字,那跟顺序还有关系, 就更恶心了.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1696904275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"吉林","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}