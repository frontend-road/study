{"id":408409,"title":"01｜内存：值放堆上还是放栈上，这是一个问题","content":"<p>你好，我是陈天。今天我们打卡Rust学习的第一讲。</p><p>你是不是已经迫不及待想要了解Rust了，但是别着急，我们不会按常规直接开始介绍语法，<strong>而会先来回顾那些你平时认为非常基础的知识，比如说内存、函数</strong>。</p><p>提到基础知识，你是不是已经有点提不起兴趣了，这些东西我都知道，何必浪费时间再学一次呢？其实不然，这些年我接触过的资深工程师里，基础知识没学透，工作多年了，还得回来补课的大有人在。</p><p>以最基础的内存为例，很多人其实并没有搞懂什么时候数据应该放在栈上，什么时候应该在堆上，直到工作中实际出现问题了，才意识到数据的存放方式居然会严重影响并发安全，无奈回头重新补基础，时间精力的耗费都很大。</p><p>其实作为开发者，我们一辈子会经历很多工具、框架和语言，但是这些东西无论怎么变，底层逻辑都是不变的。</p><p>所以今天我们得<strong>回头重新思考，编程中那些耳熟能详却又似懂非懂的基础概念，搞清楚底层逻辑</strong>。而且这些概念，对我们后面学习和理解 Rust 中的知识点非常重要，之后，我们也会根据需要再穿插深入讲解。</p><p>代码中最基本的概念是变量和值，而存放它们的地方是内存，所以我们就从内存开始。</p><h2>内存</h2><p>我们的程序无时无刻不在跟内存打交道。在下面这个把 “hello world!” 赋值给 s 的简单语句中，就跟只读数据段（RODATA）、堆、栈分别有深度交互：</p><!-- [[[read_end]]] --><pre><code class=\"language-rust\">let s = \"hello world\".to_string();\n</code></pre><p>你可以使用 Rust playground 里这个<a href=\"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=8f515709abd520d98a6ac7b854227652\">代码片段</a> 感受一下字符串的内存使用情况。</p><p>首先，“hello world” 作为一个字符串常量（string literal），在编译时被存入可执行文件的 .RODATA 段（GCC）或者 .RDATA 段（VC++），然后在程序加载时，获得一个固定的内存地址。</p><p>当执行 “hello world”.to_string() 时，在堆上，一块新的内存被分配出来，并把 “hello world” 逐个字节拷贝过去。</p><p>当我们把堆上的数据赋值给 s 时，s 作为分配在栈上的一个变量，它需要知道堆上内存的地址，另外由于堆上的数据大小不确定且可以增长，我们还需要知道它的长度以及它现在有多大。</p><p>最终，<strong>为了表述这个字符串，我们使用了三个 word</strong>：第一个表示指针、第二个表示字符串的当前长度（11）、第三个表示这片内存的总容量（11）。在 64 位系统下，三个 word 是 24 个字节。</p><p>你也可以看下图，更直观一些：<img src=\"https://static001.geekbang.org/resource/image/a7/4c/a7e7f2334460f15f9afd04ebd710b54c.jpg?wh=2312x2043\" alt=\"\"></p><p>刚才提到字符串的内容在堆上，而指向字符串的指针等信息在栈上，现在就是检验你内存基础知识是否扎实的时候了：<strong>数据什么时候可以放在栈上，什么时候需要放在堆上呢</strong>？</p><p>这个问题，很多使用自动内存管理语言比如 Java/Python 的开发者，可能有一些模糊的印象或者规则：</p><ul>\n<li>基本类型（primitive type）存储在栈上，对象存储在堆上；</li>\n<li>少量数据存储在栈上，大量的数据存储在堆上。</li>\n</ul><p>这些虽然对，但并没有抓到实质。如果你在工作中只背规则套公式，一遇到特殊情况就容易懵，但是如果明白公式背后的推导逻辑，即使忘了，也很快能通过简单思考找到答案，所以接下来我们深挖堆和栈的设计原理，看看它们到底是如何工作的。</p><h2>栈</h2><p>栈是程序运行的基础。每当一个函数被调用时，一块连续的内存就会在栈顶被分配出来，这块内存被称为帧（frame）。</p><p>我们知道，栈是自顶向下增长的，一个程序的调用栈最底部，除去入口帧（entry frame），就是 main() 函数对应的帧，而随着 main() 函数一层层调用，栈会一层层扩展；调用结束，栈又会一层层回溯，把内存释放回去。</p><p>在调用的过程中，<strong>一个新的帧会分配足够的空间存储寄存器的上下文</strong>。在函数里使用到的通用寄存器会在栈保存一个副本，当这个函数调用结束，通过副本，可以恢复出原本的寄存器的上下文，就像什么都没有经历一样。此外，函数所需要使用到的局部变量，也都会在帧分配的时候被预留出来。</p><p>整个过程你可以再看看这张图辅助理解：<br>\n<img src=\"https://static001.geekbang.org/resource/image/cc/bc/cce3c36426cd910feaee4c4ccb3afcbc.jpg?wh=2312x2043\" alt=\"\"></p><p>那一个函数运行时，<strong>怎么确定究竟需要多大的帧呢</strong>？</p><p>这要归功于编译器。在编译并优化代码的时候，一个函数就是一个最小的编译单元。</p><p>在这个函数里，编译器得知道要用到哪些寄存器、栈上要放哪些局部变量，而这些都要在编译时确定。所以编译器就需要明确每个局部变量的大小，以便于预留空间。</p><p>这下我们就明白了：<strong>在编译时，一切无法确定大小或者大小可以改变的数据，都无法安全地放在栈上，最好放在堆上</strong>。比如一个函数，参数是字符串：</p><pre><code>fn say_name(name: String) {}\n\n// 调用\nsay_name(&quot;Lindsey&quot;.to_string());\nsay_name(&quot;Rosie&quot;.to_string());\n</code></pre><p>字符串的数据结构，在编译时大小不确定，运行时执行到具体的代码才知道大小。比如上面的代码，“Lindsey” 和 “Rosie” 的长度不一样，say_name() 函数只有在运行的时候，才知道参数的具体的长度。</p><p>所以，我们无法把字符串本身放在栈上，只能先将其放在堆上，然后在栈上分配对应的指针，引用堆上的内存。</p><h3>放栈上的问题</h3><p>从刚才的图中你也可以直观看到，栈上的内存分配是非常高效的。只需要改动栈指针（stack pointer），就可以预留相应的空间；把栈指针改动回来，预留的空间又会被释放掉。预留和释放只是动动寄存器，不涉及额外计算、不涉及系统调用，因而效率很高。</p><p>所以理论上说，只要可能，我们应该把变量分配到栈上，这样可以达到更好的运行速度。</p><p>那为什么在实际工作中，我们又要避免把大量的数据分配在栈上呢？</p><p><strong>这主要是考虑到调用栈的大小，避免栈溢出（stack overflow）</strong>。一旦当前程序的调用栈超出了系统允许的最大栈空间，无法创建新的帧，来运行下一个要执行的函数，就会发生栈溢出，这时程序会被系统终止，产生崩溃信息。</p><p>过大的栈内存分配是导致栈溢出的原因之一，更广为人知的原因是递归函数没有妥善终止。一个递归函数会不断调用自己，每次调用都会形成一个新的帧，如果递归函数无法终止，最终就会导致栈溢出。</p><h2>堆</h2><p>栈虽然使用起来很高效，但它的局限也显而易见。<strong>当我们需要动态大小的内存时，只能使用堆</strong>，比如可变长度的数组、列表、哈希表、字典，它们都分配在堆上。</p><p>堆上分配内存时，一般都会预留一些空间，这是最佳实践。</p><p>比如你创建一个列表，并往里添加两个值：</p><pre><code class=\"language-rust\">let mut arr = Vec::new();\narr.push(1);\narr.push(2);\n</code></pre><p>这个列表实际预留的大小是 4，并不等于其长度 2。这是因为堆上内存分配会使用 libc 提供的 malloc() 函数，其内部会请求操作系统的系统调用，来分配内存。系统调用的代价是昂贵的，所以我们要避免频繁地 malloc()。</p><p>对上面的代码来说，如果我们需要多少就分配多少，那列表每次新增值，都要新分配一大块的内存，先拷贝已有数据，再把新的值添加进去，最后释放旧的内存，这样效率很低。所以在堆内存分配时，预留的空间大小 4 会大于需要的实际大小 2 。</p><p>除了动态大小的内存需要被分配到堆上外，<strong>动态生命周期的内存也需要分配到堆上</strong>。</p><p>上文中我们讲到，栈上的内存在函数调用结束之后，所使用的帧被回收，相关变量对应的内存也都被回收待用。所以栈上内存的生命周期是不受开发者控制的，并且局限在当前调用栈。</p><p>而堆上分配出来的每一块内存需要显式地释放，<strong>这就使堆上内存有更加灵活的生命周期，可以在不同的调用栈之间共享数据</strong>。</p><p>如下图所示：<br>\n<img src=\"https://static001.geekbang.org/resource/image/ca/bb/ca7b49966c66b90cda6f8f6b9740c0bb.jpg?wh=2312x1394\" alt=\"\"></p><h3>放堆上的问题</h3><p>然而，堆内存的这种灵活性也给内存管理带来很多挑战。</p><p>如果手工管理堆内存的话，堆上内存分配后忘记释放，就会造成<strong>内存泄漏</strong>。一旦有内存泄漏，程序运行得越久，就越吃内存，最终会因为占满内存而被操作系统终止运行。</p><p>如果堆上内存被多个线程的调用栈引用，该内存的改动要特别小心，需要加锁以独占访问，来避免潜在的问题。比如说，一个线程在遍历列表，而另一个线程在释放列表中的某一项，就可能访问野指针，导致<strong>堆越界</strong>（heap out of bounds）。而堆越界是第一大内存安全问题。</p><p>如果堆上内存被释放，但栈上指向堆上内存的相应指针没有被清空，就有可能<strong>发生使用已释放内存（use after free）的情况</strong>，程序轻则崩溃，重则隐含安全隐患。根据<a href=\"https://github.com/Microsoft/MSRC-Security-Research/blob/master/presentations/2019_02_BlueHatIL/2019_01%20-%20BlueHatIL%20-%20Trends%2C%20challenge%2C%20and%20shifts%20in%20software%20vulnerability%20mitigation.pdf\">微软安全反应中心（MSRC）的研究</a>，这是第二大内存安全问题。</p><p><img src=\"https://static001.geekbang.org/resource/image/cf/0e/cfb3f358b47afd0def88186e3a31de0e.png?wh=1920x1000\" alt=\"图片\"></p><h3>GC、ARC如何解决</h3><p>为了避免堆内存手动管理造成的这些问题，以 Java 为首的一系列编程语言，采用了追踪式垃圾回收（<a href=\"https://en.wikipedia.org/wiki/Tracing_garbage_collection\">Tracing GC</a>）的方法，来自动管理堆内存。这种方式通过定期标记（mark）找出不再被引用的对象，然后将其清理（sweep）掉，来自动管理内存，减轻开发者的负担。</p><p>而 ObjC 和 Swift 则走了另一条路：自动引用计数（<a href=\"https://en.wikipedia.org/wiki/Automatic_Reference_Counting\">Automatic Reference Counting</a>）。在编译时，它为每个函数插入 retain/release 语句来自动维护堆上对象的引用计数，当引用计数为零的时候，release 语句就释放对象。</p><p>我们来对比一下这两个方案。</p><p>从效率上来说，GC 在内存分配和释放上无需额外操作，而 ARC 添加了大量的额外代码处理引用计数，所以 GC 效率更高，吞吐量（throughput）更大。</p><p>但是，GC 释放内存的时机是不确定的，释放时引发的 STW（Stop The World），也会导致代码执行的延迟（latency）不确定。<strong>所以一般携带 GC 的编程语言，不适于做嵌入式系统或者实时系统</strong>。当然，<a href=\"https://erlang.org/doc/apps/erts/GarbageCollection.html\">Erlang VM</a>是个例外， 它把 GC 的粒度下放到每个 process，最大程度解决了 STW 的问题。</p><p>我们使用 Android 手机偶尔感觉卡顿，而 iOS 手机却运行丝滑，大多是这个原因。而且做后端服务时，API 或者服务响应时间的 p99（99th percentile）也会受到 GC STW 的影响而表现不佳。</p><p>说句题外话，上面说的GC性能和我们常说的性能，涵义不太一样。常说的性能是吞吐量和延迟的总体感知，和实际性能是有差异的，GC 和 ARC 就是典型例子。GC 分配和释放内存的效率和吞吐量要比 ARC 高，<strong>但因为偶尔的高延迟，导致被感知的性能比较差</strong>，所以会给人一种 GC 不如 ARC 性能好的感觉。</p><h2>小结</h2><p>今天我们重新回顾基础概念，分析了栈和堆的特点。</p><p>对于<strong>存入栈上的值，它的大小在编译期就需要确定</strong>。栈上存储的变量生命周期在当前调用栈的作用域内，无法跨调用栈引用。</p><p><strong>堆可以存入大小未知或者动态伸缩的数据类型</strong>。堆上存储的变量，其生命周期从分配后开始，一直到释放时才结束，因此堆上的变量允许在多个调用栈之间引用。但也导致堆变量的管理非常复杂，手工管理会引发很多内存安全性问题，而自动管理，无论是 GC 还是 ARC，都有性能损耗和其它问题。</p><p>一句话对比总结就是：<strong>栈上存放的数据是静态的，固定大小，固定生命周期；堆上存放的数据是动态的，不固定大小，不固定生命周期</strong>。</p><p>下一讲我们会讨论基础概念，比如值和类型、指针和引用、函数、方法和闭包、接口和虚表、并发与并行、同步和异步，以及 Promise/async/await ，这些我们学习 Rust 或者任何语言都会接触到。</p><h2>思考题</h2><p>最后，是课后练习题环节，欢迎在留言区分享你的思考。</p><p>1.如果有一个数据结构需要在多个线程中访问，可以把它放在栈上吗？为什么？<br>\n2.可以使用指针引用栈上的某个变量吗？如果可以，在什么情况下可以这么做？</p><p>另外，文中出现的所有参考资料链接，我都会再统一整理到文末的“拓展阅读”板块，所以非常推荐你先跟着文章的思路走，学完之后如果有兴趣，可以看看我分享给你的其他资料。</p><p>如果你觉得有收获，也欢迎你分享给身边的朋友，邀TA一起讨论。我们下一讲见!</p><h2>拓展阅读</h2><p>1.<a href=\"https://github.com/Microsoft/MSRC-Security-Research/blob/master/presentations/2019_02_BlueHatIL/2019_01%20-%20BlueHatIL%20-%20Trends%2C%20challenge%2C%20and%20shifts%20in%20software%20vulnerability%20mitigation.pdf\">微软安全反应中心（MSRC）的研究</a><br>\n2.<a href=\"https://en.wikipedia.org/wiki/Tracing_garbage_collection\">追踪式垃圾回收Tracing GC</a><br>\n3.<a href=\"https://en.wikipedia.org/wiki/Automatic_Reference_Counting\">自动引用计数Automatic Reference Counting</a><br>\n4.<a href=\"https://erlang.org/doc/apps/erts/GarbageCollection.html\">Erlang VM 把 GC 的粒度下放到每个 process，最大程度解决了 STW 的问题</a><br>\n5.课程的<a href=\"https://github.com/tyrchen/geektime-rust\">GitHub仓库</a>，内含后续思考题参考思路及项目的完整代码</p>","neighbors":{"left":{"article_title":"开篇词｜让Rust成为你的下一门主力语言","id":408400},"right":{"article_title":"02｜串讲：编程开发中，那些你需要掌握的基本概念","id":410038}},"comments":[{"had_liked":false,"id":307953,"user_name":"f","can_delete":false,"product_type":"c1","uid":2741015,"ip_address":"","ucode":"D37A8E76DB782C","user_header":"https://static001.geekbang.org/account/avatar/00/29/d3/17/22c36063.jpg","comment_is_top":true,"comment_ctime":1629336990,"is_pvip":false,"replies":[{"id":"111593","content":"String 在 Rust 中是一个智能指针，我们后续会讲到，它内部是一个结构体，放在栈上，结构体中有指针指向堆内存。所以 &amp;s 指向一个栈上的地址。<br><br>多讲两句。{:p} 是通过 Pointer trait 实现。你可以看它的文档：https:&#47;&#47;doc.rust-lang.org&#47;std&#47;fmt&#47;trait.Pointer.html。<br><br>下面的代码可以帮助你更好地理解数据在内存的什么位置：<br><br>```rust<br>static MAX: u32 = 0;<br><br>fn foo() {}<br><br>fn main() {<br>    let hello = &quot;hello world&quot;.to_string();<br>    let data = Box::new(1);<br><br>    &#47;&#47; string literals 指向 RODATA 地址<br>    println!(&quot;RODATA: {:p}&quot;, &quot;hello world!&quot;);<br>    &#47;&#47; static 变量在 DATA section<br>    println!(&quot;DATA (static var): {:p}&quot;, &amp;MAX);<br>    &#47;&#47; function 在 TEXT<br>    println!(&quot;TEXT (function): {:p}&quot;, foo as *const ());<br>    &#47;&#47; String 结构体分配在栈上，所以其引用指向一个栈地址<br>    println!(&quot;STACK (&amp;hello): {:p}&quot;, &amp;hello);<br>    &#47;&#47; 需要通过解引用获取其堆上数据，然后取其引用<br>    println!(&quot;HEAP (&amp;*hello): {:p}&quot;, &amp;*hello);<br>    &#47;&#47; Box 实现了 Pointer trait 无需额外解引用<br>    println!(&quot;HEAP (box impl Pointer) {:p} {:p}&quot;, data, &amp;*data);<br>}<br>```<br><br>你可以直接在 playground 里运行这段代码：<br><br>https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=5ca2cfb1d03936eae4b9a77a40d9987b","user_name":"作者回复","comment_id":307953,"uid":"1079375","ip_address":"","utype":1,"ctime":1629430797,"user_name_real":"Tyr"}],"discussion_count":7,"race_medal":0,"score":"9.2233722704123003e+18","product_id":100085301,"comment_content":"看到老师文章中的playground的代码，想起来一直存在的一个疑惑，&quot;{:p}&quot;输出某个变量的地址，是这个变量自身结构的地址，还是变量所指向值的地址呢。比如<br>```rust<br>let s = &quot;helloworld&quot;.to_string();<br>println!(&quot;addr: {:p}&quot;, &amp;s);<br>```<br>输出的这个地址，是栈中s ptr|len|cap 变量结构本身的地址，还是ptr的值呢？","like_count":55,"discussions":[{"author":{"id":2741015,"avatar":"https://static001.geekbang.org/account/avatar/00/29/d3/17/22c36063.jpg","nickname":"f","note":"","ucode":"D37A8E76DB782C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389977,"discussion_content":"太喜欢老师了，用非常具有说服力的示例解释说明，直接又权威。不仅能让我确信心中的答案，更让我学到了更多相关联的内容。这就给老师去打广告去。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1629551916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1401568,"avatar":"https://static001.geekbang.org/account/avatar/00/15/62/e0/d2ff52da.jpg","nickname":"记事本","note":"","ucode":"FA942636EE0CC8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2741015,"avatar":"https://static001.geekbang.org/account/avatar/00/29/d3/17/22c36063.jpg","nickname":"f","note":"","ucode":"D37A8E76DB782C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553360,"discussion_content":"我也超级喜欢，解答我的好多疑惑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645860659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":389977,"ip_address":""},"score":553360,"extra":""}]},{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525347,"discussion_content":"String 在 Rust 中是一个智能指针，我们后续会讲到，它内部是一个结构体，放在栈上，结构体中有指针指向堆内存。所以 &amp;amp;s 指向一个栈上的地址。\n\n多讲两句。{:p} 是通过 Pointer trait 实现。你可以看它的文档：https://doc.rust-lang.org/std/fmt/trait.Pointer.html。\n\n下面的代码可以帮助你更好地理解数据在内存的什么位置：\n\n```rust\nstatic MAX: u32 = 0;\n\nfn foo() {}\n\nfn main() {\n    let hello = &amp;quot;hello world&amp;quot;.to_string();\n    let data = Box::new(1);\n\n    // string literals 指向 RODATA 地址\n    println!(&amp;quot;RODATA: {:p}&amp;quot;, &amp;quot;hello world!&amp;quot;);\n    // static 变量在 DATA section\n    println!(&amp;quot;DATA (static var): {:p}&amp;quot;, &amp;amp;MAX);\n    // function 在 TEXT\n    println!(&amp;quot;TEXT (function): {:p}&amp;quot;, foo as *const ());\n    // String 结构体分配在栈上，所以其引用指向一个栈地址\n    println!(&amp;quot;STACK (&amp;amp;hello): {:p}&amp;quot;, &amp;amp;hello);\n    // 需要通过解引用获取其堆上数据，然后取其引用\n    println!(&amp;quot;HEAP (&amp;amp;*hello): {:p}&amp;quot;, &amp;amp;*hello);\n    // Box 实现了 Pointer trait 无需额外解引用\n    println!(&amp;quot;HEAP (box impl Pointer) {:p} {:p}&amp;quot;, data, &amp;amp;*data);\n}\n```\n\n你可以直接在 playground 里运行这段代码：\n\nhttps://play.rust-lang.org/?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=5ca2cfb1d03936eae4b9a77a40d9987b","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629430797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2905523,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIDqHQQByGiaXcAk94MdDn3ftupZLXyR6bAKibxOzMxy5h3uBwZ7QiaCiaIfbCMK0cIQfGNax8iawoiaQAg/132","nickname":"nuan","note":"","ucode":"55FF98EB85404D","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555289,"discussion_content":"请问该如果打印 ptr、len 和 cap 的值呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646836092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111885,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f7/4d/abb7bfe3.jpg","nickname":"echog","note":"","ucode":"94A44CC76FC84A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":398640,"discussion_content":"println!(&#34;RODATA: {:p}&#34;, &#34;hello world!&#34;)是rodata的地址，那println!(&#34;stack？ {:p}&#34;, &amp;&#34;hello world!&#34;)是什么地址呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632824548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1089000,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9d/e8/39433235.jpg","nickname":"Christian","note":"","ucode":"D84F866015BA07","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389609,"discussion_content":"栈上的地址","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629355614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2741015,"avatar":"https://static001.geekbang.org/account/avatar/00/29/d3/17/22c36063.jpg","nickname":"f","note":"","ucode":"D37A8E76DB782C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1089000,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9d/e8/39433235.jpg","nickname":"Christian","note":"","ucode":"D84F866015BA07","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389975,"discussion_content":"感谢解答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629551516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":389609,"ip_address":""},"score":389975,"extra":""}]}]},{"had_liked":false,"id":308100,"user_name":"一期一会","can_delete":false,"product_type":"c1","uid":1043780,"ip_address":"","ucode":"1C44A6453F6381","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/44/2267a5a7.jpg","comment_is_top":true,"comment_ctime":1629390211,"is_pvip":true,"replies":[{"id":"111604","content":"追踪式 GC 的 STW 问题是很难避免的。所以 golang 也有同样的问题。Golang  在 2018 年之后性能好很多，golang 团队花了大力气优化，STW 从一个 GC cycle 的 10ms（2014 年）到两次 500us（2018年）。可以看这篇博客：https:&#47;&#47;go.dev&#47;blog&#47;ismmkeynote。","user_name":"作者回复","comment_id":308100,"uid":"1079375","ip_address":"","utype":1,"ctime":1629432302,"user_name_real":"Tyr"}],"discussion_count":2,"race_medal":0,"score":"9.2233721114986004e+18","product_id":100085301,"comment_content":"golang的GC是不是和Java类似也有stw？感觉golang卡顿少一些","like_count":18,"discussions":[{"author":{"id":1360910,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c4/0e/4fe1d6eb.jpg","nickname":"墨菲斯","note":"","ucode":"112316BA8C529B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393967,"discussion_content":"golang自从引入混合写屏障之后，gc性能就好了很多。在gc过程中，只有在开启和关闭混合写屏障的瞬间，才会有stw。这个时间很短暂，几乎可以忽略。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1631674874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525388,"discussion_content":"追踪式 GC 的 STW 问题是很难避免的。所以 golang 也有同样的问题。Golang  在 2018 年之后性能好很多，golang 团队花了大力气优化，STW 从一个 GC cycle 的 10ms（2014 年）到两次 500us（2018年）。可以看这篇博客：https://go.dev/blog/ismmkeynote。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629432302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307968,"user_name":"特修斯之船","can_delete":false,"product_type":"c1","uid":1068192,"ip_address":"","ucode":"C041A289017D0C","user_header":"https://static001.geekbang.org/account/avatar/00/10/4c/a0/6cfdefa6.jpg","comment_is_top":true,"comment_ctime":1629342654,"is_pvip":true,"replies":[{"id":"111599","content":"Python 和 JS 的 primitive type 放在栈上，对象放在堆上，通过引用传递。","user_name":"作者回复","comment_id":307968,"uid":"1079375","ip_address":"","utype":1,"ctime":1629431387,"user_name_real":"Tyr"}],"discussion_count":5,"race_medal":0,"score":"9.2233720771388006e+18","product_id":100085301,"comment_content":"对于大小未知的变量都放在堆中，那是不是可以认为动态语言例如JS和Python，变量都是放在堆中？","like_count":9,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525353,"discussion_content":"Python 和 JS 的 primitive type 放在栈上，对象放在堆上，通过引用传递。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629431387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2260953,"avatar":"","nickname":"k8s","note":"","ucode":"F00A9C2D81CB94","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":542582,"discussion_content":"java也是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640788779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":525353,"ip_address":""},"score":542582,"extra":""}]},{"author":{"id":1590610,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/B9vSOjMc2a86kYA8R5yDkVdFiaj2JeBZ1PuI9oUKhbnvuZwuibdUam6FTcGzDaiaFdk2GWJveUGhfCVpv4KaOdicoQ/132","nickname":"帝江","note":"","ucode":"93CBA4E4D05DA5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574423,"discussion_content":"怪不得js的对象在传递的时候是引用传递.理解了.理解了.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654055021,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2021265,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/d7/91/aa45c7a3.jpg","nickname":"六耳","note":"","ucode":"547AD58D9F5FF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545512,"discussion_content":"ECMAScript中包含五种原始类型，Undefined、Null、Number、Boolean、String。 但是String的大小是可变的呀。这里是不是有冲突呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641979891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2264685,"avatar":"https://static001.geekbang.org/account/avatar/00/22/8e/6d/f2354440.jpg","nickname":"瞌睡的李先生","note":"","ucode":"88480FAFB4F879","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":2021265,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/d7/91/aa45c7a3.jpg","nickname":"六耳","note":"","ucode":"547AD58D9F5FF7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556837,"discussion_content":"不冲突。这里你说的原始类型的字符串，是指字符串字面量。和String对象是不一样的。可以参考：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_Types#%E5%AD%97%E9%9D%A2%E9%87%8F_literals","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1647529731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":545512,"ip_address":""},"score":556837,"extra":""}]}]},{"had_liked":false,"id":309165,"user_name":"冰河","can_delete":false,"product_type":"c1","uid":1335495,"ip_address":"","ucode":"85BB6E539ABA8C","user_header":"https://static001.geekbang.org/account/avatar/00/14/60/c7/fe7080ec.jpg","comment_is_top":true,"comment_ctime":1629964919,"is_pvip":false,"replies":[{"id":"111954","content":"哈哈是的，大家要多多在留言区提问、回答、互动，学习气氛才会越来越好喔","user_name":"编辑回复","comment_id":309165,"uid":"2547771","ip_address":"","utype":2,"ctime":1630031521,"user_name_real":"叶如芊"}],"discussion_count":1,"race_medal":0,"score":"9.223372055664599e+18","product_id":100085301,"comment_content":"评论区的大神一大片呀～所以学习课程的同学一定要看看评论区呀。","like_count":4,"discussions":[{"author":{"id":2547771,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/3b/8ec916b2.jpg","nickname":"多少","note":"","ucode":"0A6EF7AA6E4BB7","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525766,"discussion_content":"哈哈是的，大家要多多在留言区提问、回答、互动，学习气氛才会越来越好喔","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630031521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307461,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1629112140,"is_pvip":false,"replies":[{"id":"111408","content":"嗯，@pedro 回答得很详尽了。我补充一下。1. 在多线程场景下，每个线程的生命周期是不固定的，无法在编译期知道谁先结束谁后结束，所以你不能把属于某个线程 A 调用栈上的内存共享给线程 B，因为 A 可能先于 B 结束。这时候，只能使用堆内存。这里有个例外，如果结束的顺序是确定的，那么可以共享，比如 scoped thread；2. 而同一个调用栈下，main() 调用 hello()，再调用 world()，编译器很清楚，world() 会先结束，之后是 hello()，最后是 main()。所以在 world() 下用指针引用 hello() 或者 main() 内部的变量没有问题，这个指针必然先于它指向的值结束。这个两个问题的实质是我们要搞明白哪些东西在编译期可以确定它们的关系或者因果，哪些只能在运行期确定。","user_name":"作者回复","comment_id":307461,"uid":"1079375","ip_address":"","utype":1,"ctime":1629248520,"user_name_real":"Tyr"}],"discussion_count":9,"race_medal":0,"score":"714593683276","product_id":100085301,"comment_content":"1. 如果有一个数据结构需要在多个线程中访问，可以把它放在栈上吗？为什么？<br>不能，栈上的数据会随着当前线程的函数调用栈而回收，多个线程访问须在堆上开辟。<br><br>2. 可以使用指针引用栈上的某个变量吗？如果可以，在什么情况下可以这么做？<br>可以，在当前函数调用栈中，可以新建变量在栈上开辟，顺便分配一个指针指向它，但是注意，这个指针的生命周期只能在当前栈帧中，不能作为返回值给别人用。<br><br>提一下，通篇读下来，明显感受到老师的内容极其深厚，能在各种语言之间斡旋，尖锐地指出每一门语言的特点，顺便再谈谈 rust 是如何解决它们的痛点，这才是 rust 真正的精髓所在。<br><br>rust 作为极其现代的语言，集百家之长而成，当然错误处理至今仍然很拉垮，将性能和安全做到了极致，但同时也带来了巨大的学习曲线，初学时，经常出现满屏的编译错误，每天都在和编译器做斗争。<br><br>也正是因为编译器极其严苛的规则，导致 rust 程序拥有无与伦比的信任度，基本编译通过、单测跑完就敢上线，去年有幸上线过 rust 项目，相较于原来的 java 版，无论是内存还是性能都带来了巨大提升，尤其是内存，几乎缩小了 80 倍左右。<br><br>未来很大程度上，rust 虽然不会成为主流，因为难，但它会是语言界的扫地僧。<br><br>写下第一个留言，期待和陈天老师成为朋友～ ","like_count":167,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525154,"discussion_content":"嗯，@pedro 回答得很详尽了。我补充一下。1. 在多线程场景下，每个线程的生命周期是不固定的，无法在编译期知道谁先结束谁后结束，所以你不能把属于某个线程 A 调用栈上的内存共享给线程 B，因为 A 可能先于 B 结束。这时候，只能使用堆内存。这里有个例外，如果结束的顺序是确定的，那么可以共享，比如 scoped thread；2. 而同一个调用栈下，main() 调用 hello()，再调用 world()，编译器很清楚，world() 会先结束，之后是 hello()，最后是 main()。所以在 world() 下用指针引用 hello() 或者 main() 内部的变量没有问题，这个指针必然先于它指向的值结束。这个两个问题的实质是我们要搞明白哪些东西在编译期可以确定它们的关系或者因果，哪些只能在运行期确定。","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1629248520,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":3078168,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/f8/18/7d334b88.jpg","nickname":"藏影🐯 188 9067 9681","note":"","ucode":"833CF2911858A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":582400,"discussion_content":"对细节扣到极致了，一下明白了闭包的存在基础","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659423731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":525154,"ip_address":"广东"},"score":582400,"extra":""}]},{"author":{"id":1200704,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","nickname":"pedro","note":"","ucode":"F40C839DDFD599","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389279,"discussion_content":"linux线程默认调用栈空间为8m，但其实会另外分配一小片内存作为guard，如果rust使用的也是linux线程，那么同理，也是有guard的","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1629201797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121975,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1e/b7/b20ab184.jpg","nickname":"麋鹿在泛舟","note":"","ucode":"1379CADA08688E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389205,"discussion_content":"既然第二个问题答案是yes\n为什么第一个问题就不行呢？ \n\n栈空间是由编译器而不是程序员管理变量的生命周期的，只要保证多线程运行时变量仍然没有被释放，那多线程对其使用就是安全的，不是吗？\n\n一个最简单的例子，funca 入口处就定义了一个局部变量，然后开始启用10个线程，每个线程均读取了这个变量， 函数结尾等待十线程结束才退出。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1629178493,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1200704,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","nickname":"pedro","note":"","ucode":"F40C839DDFD599","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1121975,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1e/b7/b20ab184.jpg","nickname":"麋鹿在泛舟","note":"","ucode":"1379CADA08688E","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":389208,"discussion_content":"线程函数调用栈会有保护措施，其它线程不可访问","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1629179034,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":389205,"ip_address":""},"score":389208,"extra":""},{"author":{"id":1121975,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1e/b7/b20ab184.jpg","nickname":"麋鹿在泛舟","note":"","ucode":"1379CADA08688E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1200704,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","nickname":"pedro","note":"","ucode":"F40C839DDFD599","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389253,"discussion_content":"这个保护错误叫什么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629193129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":389208,"ip_address":""},"score":389253,"extra":""},{"author":{"id":1200704,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","nickname":"pedro","note":"","ucode":"F40C839DDFD599","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1121975,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1e/b7/b20ab184.jpg","nickname":"麋鹿在泛舟","note":"","ucode":"1379CADA08688E","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":389261,"discussion_content":"Stackguard","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1629194898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":389253,"ip_address":""},"score":389261,"extra":""}]}]},{"had_liked":false,"id":307626,"user_name":"有铭","can_delete":false,"product_type":"c1","uid":1046302,"ip_address":"","ucode":"2C7CB36CA5C04C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3XbCueYYVWTiclv8T5tFpwiblOxLphvSZxL4ujMdqVMibZnOiaFK2C5nKRGv407iaAsrI0CDICYVQJtiaITzkjfjbvrQ/132","comment_is_top":false,"comment_ctime":1629183304,"is_pvip":false,"replies":[{"id":"111405","content":"嗯，这是个好问题。这句话我表述地太绝对了。应该修改为：「在编译时，一切无法确定大小或者大小可以改变的数据，都无法**安全地**放在栈上，**最好**放在堆上」。<br><br>可变参数的函数是一个很好的例子。对于 Java，可变参数 String... a 是 String[] 的语法糖，它是放在堆上的。在 C 语言里，这个行为是未定义的，它只是定义了你可以通过 var_start &#47; var_end 来获得可变参数的起始位置，以及最终结束可变参数的访问。但 gcc 的实现将可变参数放在栈上（估计是为了性能）。比如 C，你可以用 var_start &#47; var_end 获取可变参数，但如果不小心处理， 会导致访问栈上的垃圾内容，甚至导致程序崩溃：<br><br>```C<br>#include &lt;stdio.h&gt;<br>#include &lt;stdarg.h&gt;<br><br>int sum(int count, ...) {<br>    va_list ap;<br>    int i;<br>    double sum = 0;<br><br>    va_start(ap, count);<br>    for (i = 0; i &lt; count; i++) {<br>        sum += va_arg(ap, int);<br>    }<br>    va_end(ap);<br><br>    return sum;<br>}<br><br>int main(int argc, char const *argv[]) {<br>    printf(&quot;%d\\n&quot;, sum(10, 1, 2, 3)); &#47;&#47; 传入 3 个值但 count 为 10<br>    return 0;<br>}<br>```<br><br>同时谢谢 c4f 的提醒，alloca() 可以在栈上分配动态大小的内存，然而使用它需要非常小心，按 linux 的文档（[https:&#47;&#47;man7.org&#47;linux&#47;man-pages&#47;man3&#47;alloca.3.html](https:&#47;&#47;man7.org&#47;linux&#47;man-pages&#47;man3&#47;alloca.3.html)），官方建议配合 longjmp 使用。alloca() 如果分配太大的数据，超过栈容量会导致程序崩溃，即使你分配很小的数据，但如果使用 alloca() 的函数被优化导致 inline，又恰巧出现在大的 for&#47;while 循环中，也可能会导致崩溃。<br><br>所以，这两种在栈上分配可变大小的数据，是不安全的。","user_name":"作者回复","comment_id":307626,"uid":"1079375","ip_address":"","utype":1,"ctime":1629248133,"user_name_real":"Tyr"}],"discussion_count":6,"race_medal":0,"score":"143363104072","product_id":100085301,"comment_content":"在编译时，一切无法确定大小或者大小可以改变的数据，都无法放在栈上，只能放在堆上<br>======<br>我对这句话感到困惑，那可变长参数呢？可变长参数也属于在编译时无法确认大小的，难道也放在堆上？我搜索了一下发现rust似乎不支持可变长参数的函数，也不支持函数重载。所以我在想这种堆栈的特性是否是rust独有的。因为至少，Java就是支持可变长参数的，但是我目前没找到资料说明Java的可变长参数是如何实现再栈上的","like_count":34,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525222,"discussion_content":"嗯，这是个好问题。这句话我表述地太绝对了。应该修改为：「在编译时，一切无法确定大小或者大小可以改变的数据，都无法**安全地**放在栈上，**最好**放在堆上」。\n\n可变参数的函数是一个很好的例子。对于 Java，可变参数 String... a 是 String[] 的语法糖，它是放在堆上的。在 C 语言里，这个行为是未定义的，它只是定义了你可以通过 var_start / var_end 来获得可变参数的起始位置，以及最终结束可变参数的访问。但 gcc 的实现将可变参数放在栈上（估计是为了性能）。比如 C，你可以用 var_start / var_end 获取可变参数，但如果不小心处理， 会导致访问栈上的垃圾内容，甚至导致程序崩溃：\n\n```C\n#include &amp;lt;stdio.h&amp;gt;\n#include &amp;lt;stdarg.h&amp;gt;\n\nint sum(int count, ...) {\n    va_list ap;\n    int i;\n    double sum = 0;\n\n    va_start(ap, count);\n    for (i = 0; i &amp;lt; count; i++) {\n        sum += va_arg(ap, int);\n    }\n    va_end(ap);\n\n    return sum;\n}\n\nint main(int argc, char const *argv[]) {\n    printf(&amp;quot;%d\\n&amp;quot;, sum(10, 1, 2, 3)); // 传入 3 个值但 count 为 10\n    return 0;\n}\n```\n\n同时谢谢 c4f 的提醒，alloca() 可以在栈上分配动态大小的内存，然而使用它需要非常小心，按 linux 的文档（[https://man7.org/linux/man-pages/man3/alloca.3.html](https://man7.org/linux/man-pages/man3/alloca.3.html)），官方建议配合 longjmp 使用。alloca() 如果分配太大的数据，超过栈容量会导致程序崩溃，即使你分配很小的数据，但如果使用 alloca() 的函数被优化导致 inline，又恰巧出现在大的 for/while 循环中，也可能会导致崩溃。\n\n所以，这两种在栈上分配可变大小的数据，是不安全的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629248133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2739803,"avatar":"","nickname":"Ryan","note":"","ucode":"026C66ED684E00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389324,"discussion_content":"确实不是绝对的，c99也支持栈上的变长数组，类似alloca()。或者这数据虽然是变长的，但是你能确定它的最大长度，那在栈上搞个最大空间，然后手动检查长度也是可以的。这种都是临时用点小数据，不想搞到堆上去分配了。当然这些方式可能不太常用，或者不太适合作为一种模式来广泛使用。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629217874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1348586,"avatar":"https://static001.geekbang.org/account/avatar/00/14/93/ea/5aae2f50.jpg","nickname":"frendguo","note":"","ucode":"704EFF58E4447A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389309,"discussion_content":"可变参数应该是个list","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629211661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2637246,"avatar":"https://static001.geekbang.org/account/avatar/00/28/3d/be/98bebd57.jpg","nickname":"c4f","note":"","ucode":"F0F542BBABCB37","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389304,"discussion_content":"老师这儿说的不是很严谨。glibc 中有个函数 alloca() 就可以在栈上动态分配内存。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629210184,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1744800,"avatar":"","nickname":"Geek_97036e","note":"","ucode":"538E5DFB835DDF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389296,"discussion_content":"印象中Java的可变长参数是作为List 处理的，那其实就是传了一个List类型的参数。一点愚见，请高手斧正。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629207460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2260953,"avatar":"","nickname":"k8s","note":"","ucode":"F00A9C2D81CB94","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1744800,"avatar":"","nickname":"Geek_97036e","note":"","ucode":"538E5DFB835DDF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542584,"discussion_content":"除了字符串等一切编译器优化，java的大部分数据结构都放堆上，函数重载编译器层面重命名在text段加额外实现，包括Rust也能用宏自已来实现，cpp的函数重载好像就是编译外重命名。rust不支持有它的考虑，就像不给你基于Object继承，但第三方库有人实现了这个结构，可以存储任何对象不用trait对象(但没离这手段)。也可以支持反射，但有宏实现元编程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640789834,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":389296,"ip_address":""},"score":542584,"extra":""}]}]},{"had_liked":false,"id":307710,"user_name":"Geek_97036e","can_delete":false,"product_type":"c1","uid":1744800,"ip_address":"","ucode":"538E5DFB835DDF","user_header":"","comment_is_top":false,"comment_ctime":1629210367,"is_pvip":false,"replies":[{"id":"111456","content":"是一份。它们指向 .rodata 中同样的地址。你可以用这段代码测试一下：<br><br>```rust<br>fn main() {<br>    let x = &quot;hello world&quot;;<br>    println!(&quot;x = {:p}&quot;, x);<br>    foo();<br>}<br><br>fn foo() {<br>    let v = &quot;hello world&quot;;<br>    println!(&quot;v = {:p}&quot;, v);<br>}<br>```","user_name":"作者回复","comment_id":307710,"uid":"1079375","ip_address":"","utype":1,"ctime":1629256404,"user_name_real":"Tyr"}],"discussion_count":1,"race_medal":0,"score":"61758752511","product_id":100085301,"comment_content":"请教陈老师：<br>关于可执行文件加载string literal 到内存，如果不同的两个函数，foo() 和bar()中，各自都用到了一个string literal “hello”,  那么编译器从从可执行文件.rodata 中加载内存，是加载一份”hello”，还是两份？","like_count":14,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525253,"discussion_content":"是一份。它们指向 .rodata 中同样的地址。你可以用这段代码测试一下：\n\n```rust\nfn main() {\n    let x = &amp;quot;hello world&amp;quot;;\n    println!(&amp;quot;x = {:p}&amp;quot;, x);\n    foo();\n}\n\nfn foo() {\n    let v = &amp;quot;hello world&amp;quot;;\n    println!(&amp;quot;v = {:p}&amp;quot;, v);\n}\n```","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629256404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307506,"user_name":"🔥神山 | 雷神山","can_delete":false,"product_type":"c1","uid":2738622,"ip_address":"","ucode":"1552CB73E89381","user_header":"https://static001.geekbang.org/account/avatar/00/29/c9/be/1949917d.jpg","comment_is_top":false,"comment_ctime":1629127193,"is_pvip":false,"replies":[{"id":"111446","content":"👍","user_name":"作者回复","comment_id":307506,"uid":"1079375","ip_address":"","utype":1,"ctime":1629253576,"user_name_real":"Tyr"}],"discussion_count":1,"race_medal":0,"score":"61758669337","product_id":100085301,"comment_content":"1. 如果有一个数据结构需要在多个线程中访问，可以把它放在栈上吗？为什么？<br>不能, 每个线程都会拥有自己的栈,栈上数据无法进行跨栈访问.<br>2. 可以使用指针引用栈上的某个变量吗？如果可以，在什么情况下可以这么做？<br>可以,只要指针的生命周期小于或者等于栈上的引用源就行,如果生命周期大于引用源就会出现野指针的情况.在rust中会报错从而无法编译.","like_count":15,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525180,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629253576,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308425,"user_name":"DustyBun","can_delete":false,"product_type":"c1","uid":1580803,"ip_address":"","ucode":"546D2E89B2E96E","user_header":"https://static001.geekbang.org/account/avatar/00/18/1f/03/e4e15f95.jpg","comment_is_top":false,"comment_ctime":1629617493,"is_pvip":false,"replies":[{"id":"111698","content":"多谢支持:)","user_name":"作者回复","comment_id":308425,"uid":"2547771","ip_address":"","utype":1,"ctime":1629687961,"user_name_real":"多少"}],"discussion_count":3,"race_medal":0,"score":"53169225045","product_id":100085301,"comment_content":"只能说钱没白花，感觉这门课陈天老师不仅是在教授一门语言，更是在通过分析语言的特性来巩固我们的计算机基础知识。感谢老师，学生受教了，非常期待后面的课程。","like_count":12,"discussions":[{"author":{"id":2547771,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/3b/8ec916b2.jpg","nickname":"多少","note":"","ucode":"0A6EF7AA6E4BB7","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525488,"discussion_content":"多谢支持:)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629687961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2223048,"avatar":"https://static001.geekbang.org/account/avatar/00/21/eb/c8/22a00d40.jpg","nickname":"张夫花","note":"","ucode":"49572E64157B93","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541405,"discussion_content":"同感+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640356864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1023296,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9d/40/c6568531.jpg","nickname":"帅迪","note":"","ucode":"19365E67027D34","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393187,"discussion_content":"同感～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631282982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307598,"user_name":"Christian","can_delete":false,"product_type":"c1","uid":1089000,"ip_address":"","ucode":"D84F866015BA07","user_header":"https://static001.geekbang.org/account/avatar/00/10/9d/e8/39433235.jpg","comment_is_top":false,"comment_ctime":1629169271,"is_pvip":false,"replies":[{"id":"111411","content":"主线程创建子线程并等待子线程结束这个动作，是我们通过程序的上下文得出的结论，但这是运行时的编译器并不能理解他们的因果关系。比如：<br>```rust<br>fn main() {<br>    let x = 10;<br><br>    let handle = thread::spawn(|| {<br>        println!(&quot;x: {}&quot;, x);<br>    });<br>    handle.join().unwrap();<br>}<br>```<br>从代码中我们很容易得出结论，主线程的 x 被子线程引用是安全的，但在编译期编译器无法做出这样的保证。","user_name":"作者回复","comment_id":307598,"uid":"1079375","ip_address":"","utype":1,"ctime":1629249336,"user_name_real":"Tyr"}],"discussion_count":3,"race_medal":0,"score":"35988907639","product_id":100085301,"comment_content":"1. 如果有一个数据结构需要在多个线程中访问，可以把它放在栈上吗？为什么？<br>这种情况是可能的。比如主线程创建一个子线程并等待子线程结束。子线程使用指针访问主线程当前栈帧上的数据。<br>2. 可以使用指针引用栈上的某个变量吗？如果可以，在什么情况下可以这么做？<br>可以，只要指针的生命周期小于等于引用的值就行。","like_count":8,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525210,"discussion_content":"主线程创建子线程并等待子线程结束这个动作，是我们通过程序的上下文得出的结论，但这是运行时的编译器并不能理解他们的因果关系。比如：\n```rust\nfn main() {\n    let x = 10;\n\n    let handle = thread::spawn(|| {\n        println!(&amp;quot;x: {}&amp;quot;, x);\n    });\n    handle.join().unwrap();\n}\n```\n从代码中我们很容易得出结论，主线程的 x 被子线程引用是安全的，但在编译期编译器无法做出这样的保证。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629249336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2061524,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/74/d4/38d813f0.jpg","nickname":"Kerry","note":"","ucode":"92F809EC998FC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389945,"discussion_content":"估计是因为多线程是作为一个库的方式实现，而没有加到编译器里？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629532078,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014800,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7c/10/165cb374.jpg","nickname":"Scott","note":"","ucode":"7E57FDCB5E5D49","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539177,"discussion_content":"需要编译器知道join是啥意思，太为难它了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639633019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307946,"user_name":"chapin","can_delete":false,"product_type":"c1","uid":1070020,"ip_address":"","ucode":"BB1800A771A8E9","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/c4/dea5d7f3.jpg","comment_is_top":false,"comment_ctime":1629335305,"is_pvip":false,"replies":[{"id":"112326","content":"恩是的，多多在留言区活跃，咱们把氛围搞起来～","user_name":"编辑回复","comment_id":307946,"uid":"2547771","ip_address":"","utype":2,"ctime":1630464856,"user_name_real":"叶如芊"}],"discussion_count":1,"race_medal":0,"score":"23104171785","product_id":100085301,"comment_content":"往往评论才是精华。能看到很多大神的回复。","like_count":5,"discussions":[{"author":{"id":2547771,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/3b/8ec916b2.jpg","nickname":"多少","note":"","ucode":"0A6EF7AA6E4BB7","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525345,"discussion_content":"恩是的，多多在留言区活跃，咱们把氛围搞起来～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630464856,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325373,"user_name":"小疯子一头","can_delete":false,"product_type":"c1","uid":1346571,"ip_address":"","ucode":"93EE20AD7612A1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKmR5MWEFXdicmO0S784v3lTqH4BzoKk4YiaDqA9icTFtxL49nR2mFRl5FibQNgWF5bD6mFe30K6zAcCw/132","comment_is_top":false,"comment_ctime":1638934050,"is_pvip":true,"replies":[{"id":"118829","content":"建议你最好再补一下 CPU 的基础知识。寄存器存放的是 CPU 执行指令的数据和结果。它容量非常有限，所以很多数据是放在栈上的。函数调用相当于把当前 CPU 执行的流程暂时打断，所以函数返回的时候需要恢复之前 CPU 寄存器的上下文。","user_name":"作者回复","comment_id":325373,"uid":"1079375","ip_address":"","utype":1,"ctime":1639807642,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"14523835938","product_id":100085301,"comment_content":"有两个疑问：<br>文中提到‘在函数里使用到的通用寄存器会在栈保存一个副本，当这个函数调用结束，通过副本，可以恢复出原本的寄存器的上下文，就像什么都没有经历一样‘；<br>1.这里的栈、堆与寄存器是什么关系，本来理解栈、堆是不应该是存储在寄存器（寄存器是内存的实体）中吗，为啥上文理解起来是一个相反的逻辑；<br>2.栈帧是不是就是执行上下文，上文提到的寄存器的上下文跟这个有联系吗？","like_count":3,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539705,"discussion_content":"建议你最好再补一下 CPU 的基础知识。寄存器存放的是 CPU 执行指令的数据和结果。它容量非常有限，所以很多数据是放在栈上的。函数调用相当于把当前 CPU 执行的流程暂时打断，所以函数返回的时候需要恢复之前 CPU 寄存器的上下文。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639807642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":309895,"user_name":"技巅","can_delete":false,"product_type":"c1","uid":2290370,"ip_address":"","ucode":"56A5F002885975","user_header":"https://static001.geekbang.org/account/avatar/00/22/f2/c2/51e2c22f.jpg","comment_is_top":false,"comment_ctime":1630386625,"is_pvip":false,"replies":[{"id":"112294","content":"是的。不过建议如果只是使用 Rust，还是重点放在把 Rust 语言、标准库和重要的第三方库搞明白。编译器的实现原理，可以了解个大概，不做编译器的话，编译器源码级的细节没有必要了解。","user_name":"作者回复","comment_id":309895,"uid":"1079375","ip_address":"","utype":1,"ctime":1630425060,"user_name_real":"Tyr"}],"discussion_count":1,"race_medal":0,"score":"14515288513","product_id":100085301,"comment_content":"rust是开源的吗？可以去学习一下rust编译器实现原理","like_count":3,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526055,"discussion_content":"是的。不过建议如果只是使用 Rust，还是重点放在把 Rust 语言、标准库和重要的第三方库搞明白。编译器的实现原理，可以了解个大概，不做编译器的话，编译器源码级的细节没有必要了解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630425060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":309629,"user_name":"王硕尧","can_delete":false,"product_type":"c1","uid":1743072,"ip_address":"","ucode":"8E5ED0B869C213","user_header":"https://static001.geekbang.org/account/avatar/00/1a/98/e0/8c814c13.jpg","comment_is_top":false,"comment_ctime":1630284007,"is_pvip":false,"replies":[{"id":"112133","content":"👍 谢谢指正！","user_name":"作者回复","comment_id":309629,"uid":"1079375","ip_address":"","utype":1,"ctime":1630295867,"user_name_real":"Tyr"}],"discussion_count":1,"race_medal":0,"score":"14515185895","product_id":100085301,"comment_content":"之前有人问rust底层是怎么实现的内存分配，Windows部分有些问题。<br><br>&quot;作者回复: 确切地说是操作系统提供的接口，在 unix 下是 libc 的 malloc，在 windows 下应该是 MSVC 的 malloc，可以看：https:&#47;&#47;doc.rust-lang.org&#47;std&#47;alloc&#47;index.html。&quot;<br><br>Windows 是 HeapAlloc() <br>https:&#47;&#47;github.com&#47;rust-lang&#47;rust&#47;blob&#47;6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5&#47;library&#47;std&#47;src&#47;sys&#47;windows&#47;alloc.rs 这个是windows的实现；<br>https:&#47;&#47;github.com&#47;rust-lang&#47;rust&#47;blob&#47;6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5&#47;library&#47;std&#47;src&#47;sys&#47;unix&#47;alloc.rs 这个是unix的实现<br><br>PS: 极客时间不能回复作者给别人的评论，所以单独发一条","like_count":4,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525938,"discussion_content":"👍 谢谢指正！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630295867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307712,"user_name":"邵俊达","can_delete":false,"product_type":"c1","uid":1281460,"ip_address":"","ucode":"4B7DACE6DBCF95","user_header":"https://static001.geekbang.org/account/avatar/00/13/8d/b4/ff82483d.jpg","comment_is_top":false,"comment_ctime":1629210637,"is_pvip":false,"replies":[{"id":"111461","content":"FP 是 frame pointer，指向栈帧的起始位置。还有一个 SP（stack pointer）指向栈顶，它会随着栈的操作而变化。在开一个新的栈帧的时候，在栈顶会压入 callee 函数的参数，caller 返回地址，以及 caller FP。","user_name":"作者回复","comment_id":307712,"uid":"1079375","ip_address":"","utype":1,"ctime":1629257591,"user_name_real":"Tyr"}],"discussion_count":3,"race_medal":0,"score":"14514112525","product_id":100085301,"comment_content":"请问「栈」那节图中的 FP 是什么意思？可以顺便讲一下那张图吗？","like_count":3,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525255,"discussion_content":"FP 是 frame pointer，指向栈帧的起始位置。还有一个 SP（stack pointer）指向栈顶，它会随着栈的操作而变化。在开一个新的栈帧的时候，在栈顶会压入 callee 函数的参数，caller 返回地址，以及 caller FP。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629257591,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1050018,"avatar":"https://static001.geekbang.org/account/avatar/00/10/05/a2/721ae4c6.jpg","nickname":"Jervis","note":"","ucode":"86C02C483449CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":588932,"discussion_content":"老师，有个问题。执行过程中终止程序，那寄存器会被还原吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664238917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":525255,"ip_address":"广东"},"score":588932,"extra":""}]},{"author":{"id":1281460,"avatar":"https://static001.geekbang.org/account/avatar/00/13/8d/b4/ff82483d.jpg","nickname":"邵俊达","note":"","ucode":"4B7DACE6DBCF95","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389679,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629375656,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307516,"user_name":"YourSweetHeart","can_delete":false,"product_type":"c1","uid":1242122,"ip_address":"","ucode":"38843F447B03F2","user_header":"https://static001.geekbang.org/account/avatar/00/12/f4/0a/cf728857.jpg","comment_is_top":false,"comment_ctime":1629128987,"is_pvip":false,"replies":[{"id":"111419","content":"多谢支持","user_name":"作者回复","comment_id":307516,"uid":"2547771","ip_address":"","utype":1,"ctime":1629250160,"user_name_real":"多少"}],"discussion_count":1,"race_medal":0,"score":"14514030875","product_id":100085301,"comment_content":"看了一讲，都不用看目录了，<br>这就是我想要的东西","like_count":3,"discussions":[{"author":{"id":2547771,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/3b/8ec916b2.jpg","nickname":"多少","note":"","ucode":"0A6EF7AA6E4BB7","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525184,"discussion_content":"多谢支持","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629250160,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312767,"user_name":"NiceBlueChai","can_delete":false,"product_type":"c1","uid":2038718,"ip_address":"","ucode":"2043333890C448","user_header":"https://static001.geekbang.org/account/avatar/00/1f/1b/be/525e05ae.jpg","comment_is_top":false,"comment_ctime":1631977060,"is_pvip":true,"replies":[{"id":"113402","content":"在 *nix 下，你可以通过 ulimit -s 来查看和修改。linux 和 osx 默认是 8M。","user_name":"作者回复","comment_id":312767,"uid":"1079375","ip_address":"","utype":1,"ctime":1632240019,"user_name_real":"Tyr"}],"discussion_count":1,"race_medal":0,"score":"10221911652","product_id":100085301,"comment_content":"如何确定当前开发环境里调用栈的最大大小","like_count":2,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527104,"discussion_content":"在 *nix 下，你可以通过 ulimit -s 来查看和修改。linux 和 osx 默认是 8M。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632240019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307477,"user_name":"盆栽Charming","can_delete":false,"product_type":"c1","uid":1347630,"ip_address":"","ucode":"1AC57A471D8699","user_header":"https://static001.geekbang.org/account/avatar/00/14/90/2e/0b8ee026.jpg","comment_is_top":false,"comment_ctime":1629117621,"is_pvip":false,"replies":[{"id":"111449","content":"2. 在其他语言中，return 一个栈上的指针会有安全问题，在 Rust 下，这么做是安全的（更多原理敬请期待未来关于所有权和生命周期的几讲）：<br><br>```rust<br>fn main() {<br>    let x = 10;<br>    let result = foo(&amp;x);<br>    println!(&quot;{}&quot;, result);<br>}<br><br>fn foo(v: &amp;i32) -&gt; &amp;i32 {<br>    v<br>}<br>```<br><br>可以看看我之前的回答 :)","user_name":"作者回复","comment_id":307477,"uid":"1079375","ip_address":"","utype":1,"ctime":1629254024,"user_name_real":"Tyr"}],"discussion_count":2,"race_medal":0,"score":"10219052213","product_id":100085301,"comment_content":"1. 不建议这么做，如果有什么奇怪的理由，要先拥有一个线程间通信的协议保证数据没被修改，或者栈贞没了<br>2. 可以，请确保这个指针不会被return…","like_count":2,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525163,"discussion_content":"2. 在其他语言中，return 一个栈上的指针会有安全问题，在 Rust 下，这么做是安全的（更多原理敬请期待未来关于所有权和生命周期的几讲）：\n\n```rust\nfn main() {\n    let x = 10;\n    let result = foo(&amp;amp;x);\n    println!(&amp;quot;{}&amp;quot;, result);\n}\n\nfn foo(v: &amp;amp;i32) -&amp;gt; &amp;amp;i32 {\n    v\n}\n```\n\n可以看看我之前的回答 :)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629254024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1269633,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5f/81/07505cdf.jpg","nickname":"张金富","note":"","ucode":"2F571C73DB868F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389594,"discussion_content":"https://segmentfault.com/a/1190000021584903","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629351414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348185,"user_name":"星宿海","can_delete":false,"product_type":"c1","uid":2189067,"ip_address":"","ucode":"F49E70D579D59E","user_header":"https://static001.geekbang.org/account/avatar/00/21/67/0b/145e3804.jpg","comment_is_top":false,"comment_ctime":1654828880,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5949796176","product_id":100085301,"comment_content":"还是菜了，心中有模模糊糊的答案，又不太敢确定，看了评论区各位大佬和作者的解答与互动，又懂了一些，进一步接近真相，但又感觉乱乱的，不够统一，我得再梳理梳理，做到逻辑闭环。","like_count":1},{"had_liked":false,"id":318110,"user_name":"Geek_1240ce","can_delete":false,"product_type":"c1","uid":1886468,"ip_address":"","ucode":"29ECE58F80A793","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJjzOFKRWQ1iagtXTAYsPUfdtbPKnYnwXc3ahSjLJrxXib4bq76Z9r39aRa4eMib59YR9ibicI2IRP1fnw/132","comment_is_top":false,"comment_ctime":1635153856,"is_pvip":false,"replies":[{"id":"116587","content":"和操作系统和 CPU 有关，比如 linux 下可能是 .TEXT 或者 .RODATA 段。","user_name":"作者回复","comment_id":318110,"uid":"1079375","ip_address":"","utype":1,"ctime":1636644061,"user_name_real":"Tyr"}],"discussion_count":1,"race_medal":0,"score":"5930121152","product_id":100085301,"comment_content":"Rust 中 const 常量存储在什么地方，和 static var 是一个地方吗？","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529108,"discussion_content":"和操作系统和 CPU 有关，比如 linux 下可能是 .TEXT 或者 .RODATA 段。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636644061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314190,"user_name":"Geek_b19a61","can_delete":false,"product_type":"c1","uid":2532691,"ip_address":"","ucode":"CE12F5EAB53C1B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epIAlGotBeRExOTCPfHO25n5pxuZlYViawxYYxXdXicbYyiaovpYUgnO46eib48Fl2Ccck4MFDPIe69tg/132","comment_is_top":false,"comment_ctime":1632892083,"is_pvip":false,"replies":[{"id":"113978","content":"这里的「动态生命周期」，可以理解成生命周期不固定。比如栈上的内存，栈帧退出，内存的生命周期结束，非常固定。但如果我想要一个不随着栈帧退出而结束的内存怎么办，需要用堆。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633321212,"ip_address":"","comment_id":314190,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5927859379","product_id":100085301,"comment_content":"“除了动态大小的内存需要分配在堆上外，动态生命周期的内存也需要分配到堆上”<br>各位，这里动态生命周期，怎么理解呢，可以举个简单的例子帮忙理解下么","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527605,"discussion_content":"这里的「动态生命周期」，可以理解成生命周期不固定。比如栈上的内存，栈帧退出，内存的生命周期结束，非常固定。但如果我想要一个不随着栈帧退出而结束的内存怎么办，需要用堆。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633321212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2823671,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/15/f7/9a55e72b.jpg","nickname":"码农阿甘","note":"","ucode":"202FDAAA3BB393","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407394,"discussion_content":"老师说的栈帧退出，以执行一个函数为例，我是不是可以理解为函数执行完毕？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634998409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311630,"user_name":"啊啊啊黑猫警长","can_delete":false,"product_type":"c1","uid":1332196,"ip_address":"","ucode":"17AD678AB908C6","user_header":"https://static001.geekbang.org/account/avatar/00/14/53/e4/05d3a210.jpg","comment_is_top":false,"comment_ctime":1631353269,"is_pvip":false,"replies":[{"id":"113004","content":"不需要，但是在讲的过程中我会放很多官方文档的链接，这些都需要在讲到的时候去看一下。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631516533,"ip_address":"","comment_id":311630,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5926320565","product_id":100085301,"comment_content":"是不是要先把官方的文档过一遍再过来学呢?","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526686,"discussion_content":"不需要，但是在讲的过程中我会放很多官方文档的链接，这些都需要在讲到的时候去看一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631516533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1332196,"avatar":"https://static001.geekbang.org/account/avatar/00/14/53/e4/05d3a210.jpg","nickname":"啊啊啊黑猫警长","note":"","ucode":"17AD678AB908C6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393837,"discussion_content":"好的，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631614546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311465,"user_name":"Marvichov","can_delete":false,"product_type":"c1","uid":1111835,"ip_address":"","ucode":"7482099415C41C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/1b/db7a0edc.jpg","comment_is_top":false,"comment_ctime":1631244727,"is_pvip":false,"replies":[{"id":"113006","content":"指向上一个函数在调用下一个函数结束后的下一条指令。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631516599,"ip_address":"","comment_id":311465,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5926212023","product_id":100085301,"comment_content":"当call ret的时候, FP 之上的返回地址指向哪里呢? FP是不是也叫做BP? 参考https:&#47;&#47;flint.cs.yale.edu&#47;cs421&#47;papers&#47;x86-asm&#47;asm.html; ","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526617,"discussion_content":"指向上一个函数在调用下一个函数结束后的下一条指令。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631516599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2206794,"avatar":"","nickname":"Geek3847","note":"","ucode":"5EC8E975EFB1D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393302,"discussion_content":"是的，就是 ebp/rbp 寄存器的内容","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631347547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308246,"user_name":"官","can_delete":false,"product_type":"c1","uid":1696727,"ip_address":"","ucode":"E3FF6D04B9846B","user_header":"https://static001.geekbang.org/account/avatar/00/19/e3/d7/d7b3505f.jpg","comment_is_top":false,"comment_ctime":1629469852,"is_pvip":false,"replies":[{"id":"111789","content":"正确。也可以看看我之前的回复。谢谢你的课后感，我也希望能通过这门课帮助大家能更好地吃透基础的知识，这样对学习任何语言和系统都有好处。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629850214,"ip_address":"","comment_id":308246,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5924437148","product_id":100085301,"comment_content":"1. 如果有一个数据结构需要在多个线程中访问，可以把它放在栈上吗？为什么？<br>不可以，因为不同线程的生命周期是不同的，不同线程的无法进行跨栈访问，且同时访问还会造成死锁。因此需要在放在堆上并且需要加锁以独占访问。<br>2. 可以使用指针引用栈上的某个变量吗？如果可以，在什么情况下可以这么做？<br>可以，只要指针的生命周期小于栈内变量的生命周期即可。<br>课后感：感觉自己就是那个干了若干年后跑回来补基础算法知识的人，尤其是之前刷到过栈和堆的算法，今天听起来有一些醍醐灌顶的感觉，也终于明白有些算法的意义，感觉从不同角度理解到了之前似是而非的东西，希望这种感觉能保持下去，感谢老师的分享。","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525442,"discussion_content":"正确。也可以看看我之前的回复。谢谢你的课后感，我也希望能通过这门课帮助大家能更好地吃透基础的知识，这样对学习任何语言和系统都有好处。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629850214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307869,"user_name":"只吃无籽西瓜","can_delete":false,"product_type":"c1","uid":1244498,"ip_address":"","ucode":"F2F7954236CDAB","user_header":"https://static001.geekbang.org/account/avatar/00/12/fd/52/47fff845.jpg","comment_is_top":false,"comment_ctime":1629287309,"is_pvip":false,"replies":[{"id":"111596","content":"嗯，可以看我对之前留言的回答。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629431233,"ip_address":"","comment_id":307869,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5924254605","product_id":100085301,"comment_content":"1.每个线程有独立的栈和寄存器，多线程共享的数据不能放在栈上。<br>2.可以使用指针，但是别把这个指针返回。","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525321,"discussion_content":"嗯，可以看我对之前留言的回答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629431233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307726,"user_name":"Yuk亮","can_delete":false,"product_type":"c1","uid":1004350,"ip_address":"","ucode":"F3C684ADEB99D9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/53/3e/234726f9.jpg","comment_is_top":false,"comment_ctime":1629215428,"is_pvip":true,"replies":[{"id":"111454","content":"嗯，如果不考虑安全，那是都可以访问。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629256177,"ip_address":"","comment_id":307726,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5924182724","product_id":100085301,"comment_content":"貌似问题1大家都有不同意见。我认为是可以访问的，理论上只要有变量地址，那就可以访问。是否安全则是另外一个问题。实际上多线程访问一个栈上的变量的场景也不少，比如在任务并行执行的场景中，业务处理的线程创建一个atmoic的栈变量作为计数器，把需要并行的任务与这个栈变量的地址传递到线程池中，当任务完成，把计数器+1。业务线程则在检测计数器是否达到预期，以达到等待所有任务完成的目的。","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525261,"discussion_content":"嗯，如果不考虑安全，那是都可以访问。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629256177,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307605,"user_name":"茶底","can_delete":false,"product_type":"c1","uid":1188926,"ip_address":"","ucode":"687DD3686A84D2","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/3e/692a93f7.jpg","comment_is_top":false,"comment_ctime":1629171853,"is_pvip":false,"replies":[{"id":"111444","content":"👍","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629253121,"ip_address":"","comment_id":307605,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5924139149","product_id":100085301,"comment_content":"第一个问题，大家的答案都挺好的。第二问题就是在作用于域内访问临时变量（-.-）。超出当前作用域就不行了。对应rust的生命周期，不要在栈的生命周期之外引用就好。这个知识点c的书和go的书都会说一点。","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525215,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629253121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307600,"user_name":"拉斯特","can_delete":false,"product_type":"c1","uid":2738694,"ip_address":"","ucode":"1E69B8052C1F59","user_header":"https://static001.geekbang.org/account/avatar/00/29/ca/06/a110cc63.jpg","comment_is_top":false,"comment_ctime":1629169721,"is_pvip":false,"replies":[{"id":"111424","content":"编辑代回复下这条，群里现在已经有快二百人啦","user_name":"作者回复","user_name_real":"多少","uid":"2547771","ctime":1629250345,"ip_address":"","comment_id":307600,"utype":1}],"discussion_count":6,"race_medal":0,"score":"5924137017","product_id":100085301,"comment_content":"有同学进陈老师rust学习群了么？","like_count":1,"discussions":[{"author":{"id":2547771,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/3b/8ec916b2.jpg","nickname":"多少","note":"","ucode":"0A6EF7AA6E4BB7","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525212,"discussion_content":"编辑代回复下这条，群里现在已经有快二百人啦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629250345,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":2,"child_discussions":[{"author":{"id":1050018,"avatar":"https://static001.geekbang.org/account/avatar/00/10/05/a2/721ae4c6.jpg","nickname":"Jervis","note":"","ucode":"86C02C483449CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2547771,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/3b/8ec916b2.jpg","nickname":"多少","note":"","ucode":"0A6EF7AA6E4BB7","race_medal":0,"user_type":4,"is_pvip":false},"discussion":{"id":588933,"discussion_content":"请问怎么加群","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664239325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":525212,"ip_address":"广东"},"score":588933,"extra":""},{"author":{"id":2547771,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/3b/8ec916b2.jpg","nickname":"多少","note":"","ucode":"0A6EF7AA6E4BB7","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":1050018,"avatar":"https://static001.geekbang.org/account/avatar/00/10/05/a2/721ae4c6.jpg","nickname":"Jervis","note":"","ucode":"86C02C483449CC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588945,"discussion_content":"开篇词文末一般都有写加群入口","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664243823,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":588933,"ip_address":""},"score":588945,"extra":""}]},{"author":{"id":1202697,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5a/09/afa3e112.jpg","nickname":"清风徐来","note":"","ucode":"2AAA5B8DE30DF9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547843,"discussion_content":"陈老师在哪里啊， 可以拉一下我吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642900512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1347630,"avatar":"https://static001.geekbang.org/account/avatar/00/14/90/2e/0b8ee026.jpg","nickname":"盆栽Charming","note":"","ucode":"1AC57A471D8699","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390141,"discussion_content":"地址是？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629687053,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389282,"discussion_content":"进了呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629203352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307527,"user_name":"拉斯特","can_delete":false,"product_type":"c1","uid":2738694,"ip_address":"","ucode":"1E69B8052C1F59","user_header":"https://static001.geekbang.org/account/avatar/00/29/ca/06/a110cc63.jpg","comment_is_top":false,"comment_ctime":1629130995,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5924098291","product_id":100085301,"comment_content":"打卡打卡，与编译器作斗争。(ง •̀_•́)ง","like_count":1},{"had_liked":false,"id":356852,"user_name":"arronK","can_delete":false,"product_type":"c1","uid":1192961,"ip_address":"北京","ucode":"58DC6FBF2CF0C1","user_header":"https://static001.geekbang.org/account/avatar/00/12/34/01/30ca98e6.jpg","comment_is_top":false,"comment_ctime":1662643403,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1662643403","product_id":100085301,"comment_content":"1. 数据该存放在栈还是堆，主要看在编译期间是否能确定其“所占用的内存大小”以及是否能确定其 “存活的生命周期”。能确定占用内存大小和生命周期那就可以放栈上，不能确定就只好放堆上。<br>2. 栈内存中存放的东西由于占用大小和生命周期都确定，且由于栈的特性，可以无需手动管理内存。但堆就只能手动处理分配和释放了。<br>3. 为了解决需要手动释放的问题，就 GC 这种自动化管理堆内存的垃圾回收器。但不管什么样的回收策略，都会有占用运行资源，甚至 STW 的问题。对于底层程序和实时程序来说还是不太理想的。(所以 rust 独辟蹊径用 ownership + borrow + lifetime 来解决堆内存回收相关的问题，移除了 gc，同时几乎不用去管释放的事儿)","like_count":0},{"had_liked":false,"id":348835,"user_name":"刘润达","can_delete":false,"product_type":"c1","uid":3027848,"ip_address":"","ucode":"5A12845D8C2A2A","user_header":"https://static001.geekbang.org/account/avatar/00/2e/33/88/6574bdde.jpg","comment_is_top":false,"comment_ctime":1655446224,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655446224","product_id":100085301,"comment_content":"关于思考题2，按照函数调用栈的顺序，被调用的函数可以使用调用它的函数中的栈帧变量的指针，或者说可以”从上往下传“","like_count":0},{"had_liked":false,"id":348759,"user_name":"Geek_0ba253","can_delete":false,"product_type":"c1","uid":2612720,"ip_address":"","ucode":"55D6DDECC9AF60","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/QvyPibAqLH5uEr7GNL6Lg9jT9sUs9jtub4LvO575nHuT3viagzmvKLCwGQRicsiadic3n9lM62qQ6n5shHfXUYib8Ktg/132","comment_is_top":false,"comment_ctime":1655370755,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1655370755","product_id":100085301,"comment_content":"1.不能，多线程共享的变量的生命周期是不确定的，内存也不确定。<br>2.可以，在多个函数调用时，main函数中的局部变量可以以指针的方式传递给其他函数。","like_count":0},{"had_liked":false,"id":348050,"user_name":"都市夜归人","can_delete":false,"product_type":"c1","uid":1071909,"ip_address":"","ucode":"DFF59BE3D80B42","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/25/d78cc1fe.jpg","comment_is_top":false,"comment_ctime":1654689237,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1654689237","product_id":100085301,"comment_content":"为了表述这个字符串，我们使用了三个 word：第一个表示指针、第二个表示字符串的当前长度（11）、第三个表示这片内存的总容量（11）。在 64 位系统下，三个 word 是 24 个字节。<br>上面这句话总的三个word是哪三个word？","like_count":0},{"had_liked":false,"id":339104,"user_name":"Architect","can_delete":false,"product_type":"c1","uid":2185412,"ip_address":"","ucode":"E2A3F0CA990199","user_header":"https://static001.geekbang.org/account/avatar/00/21/58/c4/3dda9862.jpg","comment_is_top":false,"comment_ctime":1647918379,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1647918379","product_id":100085301,"comment_content":"感谢有这么好的教程：学习过程中有个小问题，盼回复。<br>栈帧分配是在编译期还是运行时???<br>    若是在编译期，如 main 分别调用两个非相互嵌套的函数时和繁衍子进程时栈帧如何分配<br> ","like_count":0},{"had_liked":false,"id":338708,"user_name":"Kevin","can_delete":false,"product_type":"c1","uid":2763179,"ip_address":"","ucode":"3588850B3370C8","user_header":"https://static001.geekbang.org/account/avatar/00/2a/29/ab/59a6e437.jpg","comment_is_top":false,"comment_ctime":1647676962,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1647676962","product_id":100085301,"comment_content":"学习了老师的课程，又学习了各路大神的经常评论，通体舒泰，舒服。","like_count":0},{"had_liked":false,"id":336638,"user_name":"陈","can_delete":false,"product_type":"c1","uid":1213540,"ip_address":"","ucode":"CBCB838773574F","user_header":"https://static001.geekbang.org/account/avatar/00/12/84/64/0c3e17bb.jpg","comment_is_top":false,"comment_ctime":1646270570,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646270570","product_id":100085301,"comment_content":"1. 如果有一个数据结构需要在多个线程中访问，可以把它放在栈上吗？为什么？<br>理论上可以，但需要保证数据源所在线程的生命周期大于等于其他线程生命周期。比如主子线程。<br>2. 可以使用指针引用栈上的某个变量吗？如果可以，在什么情况下可以这么做？<br>可以，指针的生命周期小于变量生命周期下可以的。","like_count":0},{"had_liked":false,"id":335155,"user_name":"xiaojunzhou","can_delete":false,"product_type":"c1","uid":1276024,"ip_address":"","ucode":"C155FA9BB89318","user_header":"https://static001.geekbang.org/account/avatar/00/13/78/78/681a3e06.jpg","comment_is_top":false,"comment_ctime":1645364129,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1645364129","product_id":100085301,"comment_content":"1. 如果有一个数据结构需要在多个线程中访问，可以把它放在栈上吗？为什么？<br>如果能保证该数据结构在多个线程执行结束前，没有被释放掉的话，就可以放在栈上，否则会出现文中说的“使用已释放内存（use after free）的情况”吧。因为栈上的内存分配由系统控制。<br><br>2. 可以使用指针引用栈上的某个变量吗？如果可以，在什么情况下可以这么做？<br>可以的，只要确保改变量的作用域超过引用它的指针","like_count":0},{"had_liked":false,"id":333700,"user_name":"子豪sirius","can_delete":false,"product_type":"c1","uid":1117023,"ip_address":"","ucode":"E8D08D2D33E785","user_header":"https://static001.geekbang.org/account/avatar/00/11/0b/5f/2cc4060c.jpg","comment_is_top":false,"comment_ctime":1644477959,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1644477959","product_id":100085301,"comment_content":"1. 不能；栈只能对应一个线程。如果这个线程退出，栈上的数据就会清理，其他线程就无法访问。<br>2. 可以；建立这个栈上的指针指向栈上的变量。但使用范围仅限于当前栈","like_count":0},{"had_liked":false,"id":333629,"user_name":"翅膀","can_delete":false,"product_type":"c1","uid":1142350,"ip_address":"","ucode":"F5169AD26A41B6","user_header":"https://static001.geekbang.org/account/avatar/00/11/6e/4e/034e2943.jpg","comment_is_top":false,"comment_ctime":1644455450,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644455450","product_id":100085301,"comment_content":"回答下两个问题.  <br>1:  一般来说放栈上不行,   但也不绝对, 只要保证使用变量的时候, 变量还在就可以. 比如<br>int main() {<br>    int   shared_obj;<br>    for(int i= 0;i&lt;100;i++) {<br>         new_thread( a_thread_fun(&amp;shared_obj) )<br>    }<br>    <br>    while(1) {time.sleep(1)}<br>}<br><br><br>2 :  可以.   子函数访问父函数内的变量. 可以通过指针. 关键还是要知道变量的生命周期. <br>","like_count":0},{"had_liked":false,"id":333523,"user_name":"Geek_c3e8ba","can_delete":false,"product_type":"c1","uid":2267094,"ip_address":"","ucode":"4F6324584CBE68","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erVssfB4KCGHchvbtm3Q9M7ON55xBNsAajmS8KgjOTDtgdbojNiaDWR18pLibPd79ksnEGTltAVficyw/132","comment_is_top":false,"comment_ctime":1644393526,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1644393526","product_id":100085301,"comment_content":"根据对内存模型的理解，栈是单独为线程来服务的，每一个线程所属的栈都是独立的，这样就类似每一个线程都有一个独立的执行域，第一个问题我感觉扩展一下，应该可以作为多线程交互状态机来使用，例如作为两个前后线程状态通知来共享前一个线程状态这样是可行的吧","like_count":0},{"had_liked":false,"id":333100,"user_name":"咕咕鸡","can_delete":false,"product_type":"c1","uid":1064766,"ip_address":"","ucode":"AFDDEA3BB21942","user_header":"https://static001.geekbang.org/account/avatar/00/10/3f/3e/42d1010e.jpg","comment_is_top":false,"comment_ctime":1644063966,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644063966","product_id":100085301,"comment_content":"关于第一个问题，如果是golang，返回栈上分配数据的指针会导致逃逸分析，栈上的数据会逃逸到堆上。但是在rust，目前还没有看到逃逸分析的资料，是rust不支持吗？想问一下陈老师这个问题。","like_count":0},{"had_liked":false,"id":332718,"user_name":"Geek_fbb801","can_delete":false,"product_type":"c1","uid":2903716,"ip_address":"","ucode":"A9418C386FCDB9","user_header":"","comment_is_top":false,"comment_ctime":1643515650,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643515650","product_id":100085301,"comment_content":"老师，其实关于线程和栈的关系在文章中没有提到，解习题时候信息是不够的；<br>","like_count":0},{"had_liked":false,"id":330718,"user_name":"evi.iiii","can_delete":false,"product_type":"c1","uid":2030719,"ip_address":"","ucode":"C46E63F8A6C90C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/fc/7f/b08b9a25.jpg","comment_is_top":false,"comment_ctime":1642131181,"is_pvip":false,"replies":[{"id":"120681","content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1642292024,"ip_address":"","comment_id":330718,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1642131181","product_id":100085301,"comment_content":"谢谢陈老师分享，再一次夯实了内存的基础知识，每一次听都能有不同的理解；<br><br>1. 如果有一个数据结构需要在多个线程中访问，可以把它放在栈上吗？为什么？<br>不能，栈的最大问题是会被回收，所以放在上面会出问题<br><br>2. 可以使用指针引用栈上的某个变量吗？如果可以，在什么情况下可以这么做？<br>一些基础类型的数据会放在栈上，对这些数据的使用可以去引用，但是不能超出这个数据的生命周期","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546290,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642292024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330519,"user_name":"chyuwei","can_delete":false,"product_type":"c1","uid":1361377,"ip_address":"","ucode":"19687765E6DE5D","user_header":"","comment_is_top":false,"comment_ctime":1642007512,"is_pvip":false,"replies":[{"id":"120692","content":"1. 很难，只有主线程可以保证栈上数据比子线程生命周期更长。<br>","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1642293036,"ip_address":"","comment_id":330519,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1642007512","product_id":100085301,"comment_content":"1. 如果有一个数据结构需要在多个线程中访问，可以把它放在栈上吗？为什么？<br>不一定，如果可以保证线程的生命周期比结构所在栈的生命周期更小就可以。<br><br>2. 可以使用指针引用栈上的某个变量吗？如果可以，在什么情况下可以这么做？<br>可以，但是指针的生命周期和栈是一样的。如果栈被释放了，那么就是野指针，指向错误的数据。<br><br>综上，只要能保证使用数据时数据是有效的（未被释放），其无论放在哪里都可以。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546301,"discussion_content":"1. 很难，只有主线程可以保证栈上数据比子线程生命周期更长。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642293036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330328,"user_name":"楼大海","can_delete":false,"product_type":"c1","uid":1020607,"ip_address":"","ucode":"DDF1AB81F1B140","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/bf/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1641913237,"is_pvip":false,"replies":[{"id":"120687","content":"嗯，这是个例外情况","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1642292780,"ip_address":"","comment_id":330328,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1641913237","product_id":100085301,"comment_content":"1. 如果有一个数据结构需要在多个线程中访问，可以把它放在栈上吗？为什么？<br><br>It depends。假如线程的生命周期有额外约定，比如该结构周期必定在所有引用者之后，则可以放在栈内。典型的就是在 main frame 存放共享变量，且在 main thread 中 join 其他子线程的结构。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546296,"discussion_content":"嗯，这是个例外情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642292780,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328658,"user_name":"loongmonkey","can_delete":false,"product_type":"c1","uid":2526234,"ip_address":"","ucode":"730C179FA904F2","user_header":"https://static001.geekbang.org/account/avatar/00/26/8c/1a/a98f59e6.jpg","comment_is_top":false,"comment_ctime":1640828756,"is_pvip":true,"replies":[{"id":"120761","content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1642308147,"ip_address":"","comment_id":328658,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640828756","product_id":100085301,"comment_content":"复习了下基础知识，拓展阅读很好！","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546400,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642308148,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325899,"user_name":"常常","can_delete":false,"product_type":"c1","uid":2855271,"ip_address":"","ucode":"CD9F1C05DF91BF","user_header":"https://static001.geekbang.org/account/avatar/00/2b/91/67/980df0ac.jpg","comment_is_top":false,"comment_ctime":1639218651,"is_pvip":false,"replies":[{"id":"118813","content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639804624,"ip_address":"","comment_id":325899,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1639218651","product_id":100085301,"comment_content":"1. 如果有一个数据结构需要在多个线程中访问，可以把它放在栈上吗？为什么？<br> 不能，每个线程有自己的栈，随着执行不断的压栈和出栈。<br>只有在单线程情况下可控，多线程情况下自身的栈情况无法把控。<br>2. 可以使用指针引用栈上的某个变量吗？如果可以，在什么情况下可以这么做？<br>一般情况下，栈上面存取会更加的快速，但是必须是有确定大小的。<br>对于基础数据，它并非是引用，而是直接地值复制。<br>如果想引用栈上面的数据，应当注意两个点<br>- 引用的生命周期必须短于实际数据的生命周期，避免悬垂指针<br>- 分清楚自己的目的，是保证实体的唯一，或者节省内存，否则这种办法只会引起不必要的复杂度","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539686,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639804624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321424,"user_name":"杜文斌","can_delete":false,"product_type":"c1","uid":1995167,"ip_address":"","ucode":"FCE0FFFED46253","user_header":"https://static001.geekbang.org/account/avatar/00/1e/71/9f/9a0da80c.jpg","comment_is_top":false,"comment_ctime":1636871061,"is_pvip":false,"replies":[{"id":"118925","content":"JS 自身有垃圾回收。任何脚本语言，都有不同的垃圾回收机制","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639853246,"ip_address":"","comment_id":321424,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1636871061","product_id":100085301,"comment_content":"1. 如果有一个数据结构需要在多个线程中访问，可以把它放在栈上吗？为什么？<br>不可以，数据所在线程执行完成时回收栈后，其他线程就访问不到了<br>2. 可以使用指针引用栈上的某个变量吗？如果可以，在什么情况下可以这么做？<br>当前线程应该可以<br><br>作为一个 JS 开发者，对堆栈这块儿的处理不是很了解，以上都是根据课程内容做的回答～<br><br>请教下作者，对应到 JS 这种动态语言， 是否就不涉及垃圾回收机制了","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539886,"discussion_content":"JS 自身有垃圾回收。任何脚本语言，都有不同的垃圾回收机制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639853247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317861,"user_name":"码农阿甘","can_delete":false,"product_type":"c1","uid":2823671,"ip_address":"","ucode":"202FDAAA3BB393","user_header":"https://static001.geekbang.org/account/avatar/00/2b/15/f7/9a55e72b.jpg","comment_is_top":false,"comment_ctime":1634997605,"is_pvip":false,"replies":[{"id":"115223","content":"👍","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1635120761,"ip_address":"","comment_id":317861,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1634997605","product_id":100085301,"comment_content":"一直使用C#，从来没注意过堆栈，基本都忘光了，听课的过程中，又回头恶补了一翻。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529010,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635120761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317711,"user_name":"ilookers","can_delete":false,"product_type":"c1","uid":1828290,"ip_address":"","ucode":"CAD6557DAC946D","user_header":"","comment_is_top":false,"comment_ctime":1634899346,"is_pvip":false,"replies":[{"id":"115233","content":"👍","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1635121641,"ip_address":"","comment_id":317711,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1634899346","product_id":100085301,"comment_content":"评论很精彩，一些以前理解似是而非又没持续关注的问题，在这里能找到一些解答的角度。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528941,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635121641,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316790,"user_name":"脑洞太大补不上","can_delete":false,"product_type":"c1","uid":1062808,"ip_address":"","ucode":"ABB5BA9AE6D50A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIf1t1D3ictrpgeFuIukNLUdicibnibk7GCO4KAv63ffNYbZPPibeTkhcKPpV7XCYpmaGGKsDKN2Miaephg/132","comment_is_top":false,"comment_ctime":1634551556,"is_pvip":false,"replies":[{"id":"115272","content":"1. 对。所以需要堆。<br>2. 对。Rust 通过所有权这个问题的处理变得简单清晰。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1635131144,"ip_address":"","comment_id":316790,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1634551556","product_id":100085301,"comment_content":"1. 这个问题本身似乎就没办法成立..<br>栈本身就是相对于某个单独可运行的最小单位(线程 &#47; Erlang Process)来说的<br>正常来讲一个线程在运行的时候才存在自己的栈空间, 里面有这个线程当前运行状态的所有信息..<br>一个线程怎么才能直接访问其他线程的栈呢? 除了硬拿着内存地址直接去访问, 我想不到其他的办法<br><br>2. 从操作本身上来说是可行的, 但这么用会很容易产生问题<br>栈上的内存会在退出作用域的时候被标记为不再使用 (栈顶指针退回去了)<br>如果这个时候指向刚刚某个栈内存的指针(内存地址) 还被拿到其他地方用了, 那谁也不知道别的函数&#47;线程拿着这个地址访问到的是个啥东西<br>当然, 如果这个指针只在和所指向的内存的同一个栈空间内去使用, 那还是没啥问题的<br><br><br>","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528502,"discussion_content":"1. 对。所以需要堆。\n2. 对。Rust 通过所有权这个问题的处理变得简单清晰。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635131144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":315973,"user_name":"阿成","can_delete":false,"product_type":"c1","uid":1390032,"ip_address":"","ucode":"CEC3CD65FB9333","user_header":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","comment_is_top":false,"comment_ctime":1634090551,"is_pvip":false,"replies":[{"id":"115282","content":"👍","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1635132428,"ip_address":"","comment_id":315973,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1634090551","product_id":100085301,"comment_content":"看了作者那张栈的示意图对有些细节还是不太明白的同学可以看看这个：<br><br>函数调用过程中栈到底是怎么压入和弹出的？ - Rich的回答 - 知乎<br>https:&#47;&#47;www.zhihu.com&#47;question&#47;22444939&#47;answer&#47;705117359","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528219,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635132428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314869,"user_name":"Steve","can_delete":false,"product_type":"c1","uid":1002255,"ip_address":"","ucode":"243D10F2DC065A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4b/0f/d747ed96.jpg","comment_is_top":false,"comment_ctime":1633513687,"is_pvip":false,"replies":[{"id":"114168","content":"👍","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633813331,"ip_address":"","comment_id":314869,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1633513687","product_id":100085301,"comment_content":"思考题：<br><br>1. 如果有一个数据结构需要在多个线程中访问，可以把它放在栈上吗？为什么？<br><br>答：不可以放在栈上，栈上存储的数据变量生命周期是在当前调用栈的作用域内，无法跨调用栈引用。<br><br>2. 可以使用指针引用栈上的某个变量吗？如果可以，在什么情况下可以这么做？<br><br>答：可以。在当前调用栈上新建变量，将指针引用到当前新建的变量。但是该变量的作用域是在当前栈帧中，当调用栈调用结束后就会释放掉。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527820,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633813331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314500,"user_name":"ayu","can_delete":false,"product_type":"c1","uid":1640515,"ip_address":"","ucode":"8DB850105E4379","user_header":"https://static001.geekbang.org/account/avatar/00/19/08/43/d2a8d8c8.jpg","comment_is_top":false,"comment_ctime":1633149405,"is_pvip":false,"replies":[{"id":"113971","content":"不明白你的意思。字符串字面量是放在了只读段，使用的时候栈上只是放了一个指向它的引用。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633320352,"ip_address":"","comment_id":314500,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1633149405","product_id":100085301,"comment_content":"老师，我有一个问题: <br>既然字面量在编译时可以放到只读段，那么在编译期间它的大小，需要占用的内存完全可以确定，为什么不把具体的某个字面量放到只读段，而不是栈中呢？","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527702,"discussion_content":"不明白你的意思。字符串字面量是放在了只读段，使用的时候栈上只是放了一个指向它的引用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633320352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1828290,"avatar":"","nickname":"ilookers","note":"","ucode":"CAD6557DAC946D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407036,"discussion_content":"字面量存放放在RODATA中，有且只有1份，生命周期是全局有效（&#39;static），如果放在栈中，栈销毁就没有了，其它线程需要引用的时候需要重建一遍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634897777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313746,"user_name":"soyoungad","can_delete":false,"product_type":"c1","uid":2422365,"ip_address":"","ucode":"F937BF11B95AE1","user_header":"","comment_is_top":false,"comment_ctime":1632645035,"is_pvip":false,"replies":[{"id":"113724","content":"当前函数中使用的通用寄存器中被用到的寄存器会被保存起来，栈帧结束时会再恢复回去。这样函数调用结束，上一个函数的上下文不会发生变化。你可以看：https:&#47;&#47;softwareengineering.stackexchange.com&#47;questions&#47;195385&#47;understanding-stack-frame-of-function-call-in-c-c","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632796844,"ip_address":"","comment_id":313746,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1632645035","product_id":100085301,"comment_content":"每个栈帧都有一份寄存器的拷贝，这份拷贝是上个栈帧的寄存器信息吗？用于在这个栈帧弹出的时候，还原上个栈帧的寄存机布局？没太明白，希望了老师再讲讲<br>","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527458,"discussion_content":"当前函数中使用的通用寄存器中被用到的寄存器会被保存起来，栈帧结束时会再恢复回去。这样函数调用结束，上一个函数的上下文不会发生变化。你可以看：https://softwareengineering.stackexchange.com/questions/195385/understanding-stack-frame-of-function-call-in-c-c","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632796844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2871656,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/wGYGZ4JW698Q966GUoiaMibxiasMccrquibjvZL6TvB9PJY4khB6dULQ5CAsCML8OTdUyNuPDr2OO7nNndic4t2CUoQ/132","nickname":"Geek_93d342","note":"","ucode":"AB3AB62AAA48CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544662,"discussion_content":"这个小视频讲把栈帧信息在内存中的调用轨迹讲的很清晰，推荐一看\nhttps://www.zhihu.com/zvideo/1457018650724765697?playTime=185.1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641623030,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313745,"user_name":"soyoungad","can_delete":false,"product_type":"c1","uid":2422365,"ip_address":"","ucode":"F937BF11B95AE1","user_header":"","comment_is_top":false,"comment_ctime":1632644949,"is_pvip":false,"replies":[{"id":"113725","content":"你可以思考一下，不然这些东西放在哪里？又用什么指令来操作它们？对于一个 &quot;hello world&quot;，如果你只想在程序运行时才生成它，那么是生成一大堆指令一个字符一个字符把它们写入堆或栈上内存效率高，还是把它们放在一段固定内存中，一条指令就可以读到效率高？不用担心在代码中导致的这些一次性的消耗。如果实在是量很大，你可以使用文件在运行时加载。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632797211,"ip_address":"","comment_id":313745,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1632644949","product_id":100085301,"comment_content":"既然 string literal 是放在 RODATA 区，是不是就意味着，如果一个程序有很多字符串字面量，并且这些字面量只被某段程序引用使用一次，那么这些字面量就算有固定的静态地址，那程序的其他部分也没法访问这些字面量了，是不是有点儿浪费内存啊","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527457,"discussion_content":"你可以思考一下，不然这些东西放在哪里？又用什么指令来操作它们？对于一个 &amp;quot;hello world&amp;quot;，如果你只想在程序运行时才生成它，那么是生成一大堆指令一个字符一个字符把它们写入堆或栈上内存效率高，还是把它们放在一段固定内存中，一条指令就可以读到效率高？不用担心在代码中导致的这些一次性的消耗。如果实在是量很大，你可以使用文件在运行时加载。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632797211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313037,"user_name":"Geek_5244fa","can_delete":false,"product_type":"c1","uid":1072743,"ip_address":"","ucode":"B87A550526F74C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5e/67/133d2da6.jpg","comment_is_top":false,"comment_ctime":1632222862,"is_pvip":true,"replies":[{"id":"113396","content":"这个图画得不那么好，s 是变量，用圆圈表示更好一些。s 就是这个 string。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632239594,"ip_address":"","comment_id":313037,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1632222862","product_id":100085301,"comment_content":"第一个图上，为什么栈上有一个 s，然后它指向一个 String？<br><br>还是说 let s = &quot;hello world&quot;.to_string(); 里 s 是个引用？","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527204,"discussion_content":"这个图画得不那么好，s 是变量，用圆圈表示更好一些。s 就是这个 string。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632239594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1828290,"avatar":"","nickname":"ilookers","note":"","ucode":"CAD6557DAC946D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407039,"discussion_content":"我这么理解， s 相当于下面伪代码中s，s 是栈变量本身，&amp;s 则是取栈变量的地址。\n\n```c\nstruct String {\n     intptr_t ptr;\n     usize_t len;\n     usize_t cap;\n};\n\nvoid main() {\n   String s;\n\n   // heap \n   heap = malloc()\n   \n   s.ptr = heap\n   s.len = len(ptr)\n   s.cap = align(len(ptr))\n}\n\n```","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634898488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312219,"user_name":"未填写","can_delete":false,"product_type":"c1","uid":2698611,"ip_address":"","ucode":"D79B9F8FCA4110","user_header":"https://static001.geekbang.org/account/avatar/00/29/2d/73/bde1abd9.jpg","comment_is_top":false,"comment_ctime":1631689827,"is_pvip":false,"replies":[{"id":"113166","content":"你可以自己运行一下，猜一猜。 &amp;&quot;hello world&quot;，是对 &quot;hello world&quot; 的引用。和 &quot;hello world&quot; 一样，Rust 编译器将这个引用也编译到了 RODATA  中。&amp;&amp;[1,2,3] 同理。你可以运行一下下面的代码感受一下：<br><br>```rust<br>fn main() {<br>    let s = &quot;hello world!&quot;.to_string();<br>    let s1 = &amp;&quot;hello world&quot;;<br>    println!(&quot;UNKNOWN          : {:p}&quot;, &amp;*s);<br>    println!(&quot;UNKNOWN          : {:p}&quot;, &amp;s);<br>    println!(&quot;UNKNOWN          : {:p}&quot;, s1);<br><br>    &#47;&#47; 这句编不过<br>    &#47;&#47; pass_static(&amp;s);<br><br>    &#47;&#47; 这句可以<br>    pass_static(s1);<br>}<br><br>fn pass_static(s: &amp;&#39;static str) {<br>    println!(&quot;{}&quot;, s);<br>}<br>```<br><br>playground: https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=963e1130255510864dabb1a522f1639f","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631759403,"ip_address":"","comment_id":312219,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1631689827","product_id":100085301,"comment_content":"老师您好，我在打印字符常量地址和其引用时，&quot;hello world&quot; (&amp;str : str常量的地址) 和 &amp;&quot;hello world&quot; (&amp;&amp;str: &amp;str 这个切片的地址) ，发现它们分别在不同的段上(后者是一个专属于切片的临时区嘛？)，想请教一下这块内存分配的内容，谢谢 :D<br>```<br>static MAX: u32 = 0;<br>fn foo() {}<br><br>fn main() {<br>    let mut s = &quot;hello world&quot;.to_string();<br>    let x: i32;<br><br>    &#47;&#47; function 在 TEXT<br>    println!(&quot;TEXT (function)  : {:p}&quot;, foo as *const ());<br><br>    &#47;&#47; static 变量在 DATA section<br>    println!(&quot;DATA (static var): {:p}&quot;, &amp;MAX);<br><br>    &#47;&#47; string literals 指向 RODATA 地址<br>    println!(&quot;literals RODATA  : {:p}&quot;, &quot;hello world!&quot;);<br><br>    &#47;&#47; 临时 array 指向 RODATA 地址<br>    println!(&quot;array RODATA     : {:p}&quot;, &amp;[1,2,3]);<br><br>    &#47;&#47; 这里是什么段呢?<br>    println!(&quot;UNKNOWN          : {:p}&quot;, &amp;&quot;hello world!&quot;);<br>    println!(&quot;UNKNOWN          : {:p}&quot;, &amp;&amp;[1,2,3]);<br>}<br>```","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526900,"discussion_content":"你可以自己运行一下，猜一猜。 &amp;amp;&amp;quot;hello world&amp;quot;，是对 &amp;quot;hello world&amp;quot; 的引用。和 &amp;quot;hello world&amp;quot; 一样，Rust 编译器将这个引用也编译到了 RODATA  中。&amp;amp;&amp;amp;[1,2,3] 同理。你可以运行一下下面的代码感受一下：\n\n```rust\nfn main() {\n    let s = &amp;quot;hello world!&amp;quot;.to_string();\n    let s1 = &amp;amp;&amp;quot;hello world&amp;quot;;\n    println!(&amp;quot;UNKNOWN          : {:p}&amp;quot;, &amp;amp;*s);\n    println!(&amp;quot;UNKNOWN          : {:p}&amp;quot;, &amp;amp;s);\n    println!(&amp;quot;UNKNOWN          : {:p}&amp;quot;, s1);\n\n    // 这句编不过\n    // pass_static(&amp;amp;s);\n\n    // 这句可以\n    pass_static(s1);\n}\n\nfn pass_static(s: &amp;amp;&amp;#39;static str) {\n    println!(&amp;quot;{}&amp;quot;, s);\n}\n```\n\nplayground: https://play.rust-lang.org/?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=963e1130255510864dabb1a522f1639f","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631759403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1390032,"avatar":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","nickname":"阿成","note":"","ucode":"CEC3CD65FB9333","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403525,"discussion_content":"大概猜一下背后的原因：因为 str 本身是在 RODATA 段，那么 &amp;str 所指向的地址、长度等也可以完全确定，并且 &amp;str 也不能被修改，所以可以一起放在 RODATA 段中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634097432,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2698611,"avatar":"https://static001.geekbang.org/account/avatar/00/29/2d/73/bde1abd9.jpg","nickname":"未填写","note":"","ucode":"D79B9F8FCA4110","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394163,"discussion_content":"谢谢！其实是运行后发现 /proc/xxx/maps 中分成了两段，这样看可能只是 RODATA 拆了一下hh","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631761044,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312129,"user_name":"lin","can_delete":false,"product_type":"c1","uid":2738637,"ip_address":"","ucode":"42FB7B3FB8EE3D","user_header":"https://static001.geekbang.org/account/avatar/00/29/c9/cd/4ce2f5fb.jpg","comment_is_top":false,"comment_ctime":1631632330,"is_pvip":false,"replies":[{"id":"113126","content":"对！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631671237,"ip_address":"","comment_id":312129,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631632330","product_id":100085301,"comment_content":"对 &quot;存入栈上的值，它的大小在编译期就需要确定&quot; 抱有疑问：<br>对于类似这种在 elaboration time(非编译时) 才能确定数组大小的，似乎也能放在栈里<br>```<br>#include &lt;iostream&gt;<br><br>using namespace::std;<br><br>int main(){<br>    int n = 0;<br>    cin &gt;&gt; n;<br>    int arr[n];<br>    for(int i = 0; i &lt; n; ++i) {<br>        arr[i] = 0;<br>    }<br>}<br>```<br>大致做法就是stack分为两部分，fixed size part &amp; variable size part, fixed size part放一个编译时确定大小的数组维度描述符，variable size part放具体的数组<br>具体参考 Programming Language Pragmatics, Michael L. Scott的 Ch 8.2 Arrays, Page 364 &quot;Stack Allocation&quot; ","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526872,"discussion_content":"对！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631671237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311795,"user_name":"马超","can_delete":false,"product_type":"c1","uid":1198816,"ip_address":"","ucode":"FAFF55DC5DD15C","user_header":"https://static001.geekbang.org/account/avatar/00/12/4a/e0/eff34583.jpg","comment_is_top":false,"comment_ctime":1631463476,"is_pvip":false,"replies":[{"id":"112987","content":"这是编译器（JVM 主要是 JIT）的额外优化了。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631514776,"ip_address":"","comment_id":311795,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631463476","product_id":100085301,"comment_content":"为啥jvm有逃逸分析特性，允许直接在栈上分配对象？","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526747,"discussion_content":"这是编译器（JVM 主要是 JIT）的额外优化了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631514776,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311474,"user_name":"水口行舟入她心","can_delete":false,"product_type":"c1","uid":1039465,"ip_address":"","ucode":"A6876A6DCBD55B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/dc/69/4e534d3d.jpg","comment_is_top":false,"comment_ctime":1631248449,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631248449","product_id":100085301,"comment_content":"留个言，证明我来过，至于课后作业就不写啦，有很多小伙伴都做出了优秀的解答，日拱一卒，功不唐捐，加油💪","like_count":0},{"had_liked":false,"id":311462,"user_name":"Lasuar","can_delete":false,"product_type":"c1","uid":2748738,"ip_address":"","ucode":"DFEFCE26A3B3A3","user_header":"https://static001.geekbang.org/account/avatar/00/29/f1/42/ffeadbb8.jpg","comment_is_top":false,"comment_ctime":1631244329,"is_pvip":false,"replies":[{"id":"112873","content":"所有权和生命周期确实会给开发者带来心智负担。这也是 Rust 和其它语言相比学习的主要难点（另外还有可变性）。所以我们要理解它，并且熟练掌握它。这样，当编译器报错时，可以明白为什么出错，以及如何解决它。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631284066,"ip_address":"","comment_id":311462,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631244329","product_id":100085301,"comment_content":"斗胆问一下老师，Rust的生命周期&amp;所有权机制 在某种程度上来说会不会成为 另一种类似于C&#47;C++编程中伴随的“心智负担”？","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526616,"discussion_content":"所有权和生命周期确实会给开发者带来心智负担。这也是 Rust 和其它语言相比学习的主要难点（另外还有可变性）。所以我们要理解它，并且熟练掌握它。这样，当编译器报错时，可以明白为什么出错，以及如何解决它。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631284066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311231,"user_name":"宝宝疯","can_delete":false,"product_type":"c1","uid":1026637,"ip_address":"","ucode":"D86F5A645FE61B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/4d/c7df89bf.jpg","comment_is_top":false,"comment_ctime":1631113530,"is_pvip":false,"replies":[{"id":"112810","content":"1. 不可以。栈上的数据会随着栈帧的销毁而销毁，所以，跨线程中访问栈上数据有可能访问到已回收的内存。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631159875,"ip_address":"","comment_id":311231,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631113530","product_id":100085301,"comment_content":"问题1：根据本讲中的要点：栈上的数据是静态的，静态大小，静态生命周期。所以如果一个数据结构要想能被多个线程中访问，还要放在栈上，那就只能是纯静态的数据了。所以结论是静态的数据结构是可以满足要求的。<br><br>问题2：感觉好像是可以。暂时想不到对应的情形。<br>","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526530,"discussion_content":"1. 不可以。栈上的数据会随着栈帧的销毁而销毁，所以，跨线程中访问栈上数据有可能访问到已回收的内存。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631159875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310528,"user_name":"YC","can_delete":false,"product_type":"c1","uid":2029526,"ip_address":"","ucode":"487213D7B37601","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f7/d6/9ebe565c.jpg","comment_is_top":false,"comment_ctime":1630726584,"is_pvip":false,"replies":[{"id":"112515","content":"1. rust 的行为和 C++ 不同，不会使用被 free 的数据。下一讲我们会谈到所有权，你会看到为何 rust 不同。<br>2. 对","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1630777667,"ip_address":"","comment_id":310528,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1630726584","product_id":100085301,"comment_content":"1. C++ 的话是make a copy of variable on stack，然后用自己stack上的copy，而假如用reference的话就会出现使用已经被free的variable。猜想Rust可能也是如此？<br>2.C++里指针&#47;ref是可以的，这样避免了每次copy，但是不能用作返回，否则就是dangling pointer","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526264,"discussion_content":"1. rust 的行为和 C++ 不同，不会使用被 free 的数据。下一讲我们会谈到所有权，你会看到为何 rust 不同。\n2. 对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630777667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308865,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":false,"comment_ctime":1629847233,"is_pvip":true,"replies":[{"id":"111943","content":"对","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1630030660,"ip_address":"","comment_id":308865,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1629847233","product_id":100085301,"comment_content":"问题一，栈是和其对应线程绑定的，创建销毁随这个线程调用方法，不断创建销毁栈帧，所以核心就是线程私有与其他线程不共享。<br>问题二，可以，只有在当前方法中，也就是调用栈中即可。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525649,"discussion_content":"对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630030660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308768,"user_name":"hksukiack","can_delete":false,"product_type":"c1","uid":1152310,"ip_address":"","ucode":"1F873D091DEE6A","user_header":"https://static001.geekbang.org/account/avatar/00/11/95/36/97c219c9.jpg","comment_is_top":false,"comment_ctime":1629791011,"is_pvip":false,"replies":[{"id":"111808","content":"对。可以看看我之前的回答。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629853687,"ip_address":"","comment_id":308768,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1629791011","product_id":100085301,"comment_content":"1. 如果有一个数据结构需要在多个线程中访问，可以把它放在栈上吗？为什么？<br>如果该结构在多个线程中是需要共享的，那不应该，因为每个线程拥有一份儿自己的栈空间<br>2. 可以使用指针引用栈上的某个变量吗？如果可以，在什么情况下可以这么做？<br>可以，只要该引用不跳出其栈运行范围就可以，即能在本函数中使用，也能传给子函数，但是不能传给父函数","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525619,"discussion_content":"对。可以看看我之前的回答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629853687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308407,"user_name":"鲲腾","can_delete":false,"product_type":"c1","uid":1127468,"ip_address":"","ucode":"490D30DDEC12B9","user_header":"https://static001.geekbang.org/account/avatar/00/11/34/2c/938f5cb9.jpg","comment_is_top":false,"comment_ctime":1629605930,"is_pvip":false,"replies":[{"id":"111782","content":"👍","user_name":"作者回复","user_name_real":"多少","uid":"2547771","ctime":1629818315,"ip_address":"","comment_id":308407,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1629605930","product_id":100085301,"comment_content":"1. 如果有一个数据结构需要在多个线程中访问，可以把它放在栈上吗？为什么？<br>不可以。<br>因为线程B无法追踪特定线程A使用的栈A的生命周期，也就无法保证线程B访问的特定栈地址的值，是否是在线程A的生命周期内的有效值。<br>2. 可以使用指针引用栈上的某个变量吗？如果可以，在什么情况下可以这么做？<br>有时可以。<br>同线程A的栈中较年轻的栈帧中代码，可以引用较年长的栈帧中的变量地址。","like_count":0,"discussions":[{"author":{"id":2547771,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/3b/8ec916b2.jpg","nickname":"多少","note":"","ucode":"0A6EF7AA6E4BB7","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525484,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629818315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308313,"user_name":"Kerry","can_delete":false,"product_type":"c1","uid":2061524,"ip_address":"","ucode":"92F809EC998FC6","user_header":"https://static001.geekbang.org/account/avatar/00/1f/74/d4/38d813f0.jpg","comment_is_top":false,"comment_ctime":1629531337,"is_pvip":false,"replies":[{"id":"111792","content":"嗯。可以看看我之前的回复。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629850349,"ip_address":"","comment_id":308313,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1629531337","product_id":100085301,"comment_content":"1. 如果有一个数据结构需要在多个线程中访问，可以把它放在栈上吗？为什么？<br><br>如果这个数据结构存放的栈帧，在这些线程运行时不会被回收，那就可以放在栈上。比如创建一个大小为3的数组，然后开3个线程，并等待这3个线程执行结束。每个线程返回前会将计算结果写入数组元素。<br><br>而如果函数创建了线程和数据结构后就返回了，那线程引用的数据结构其实已经失效了。<br><br>2. 可以使用指针引用栈上的某个变量吗？如果可以，在什么情况下可以这么做？<br><br>跟问题1一样，如果父作用域存活跟当前作用域至少一样久，父作用域的栈变量可以放心引用。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525457,"discussion_content":"嗯。可以看看我之前的回复。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629850349,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308280,"user_name":"嘟嘟","can_delete":false,"product_type":"c1","uid":1958092,"ip_address":"","ucode":"FEA6F454376F6D","user_header":"https://static001.geekbang.org/account/avatar/00/1d/e0/cc/b7dd3d67.jpg","comment_is_top":false,"comment_ctime":1629516008,"is_pvip":false,"replies":[{"id":"111790","content":"嗯，对的。你也可以看看我之前的回复。有更详尽的解答。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629850244,"ip_address":"","comment_id":308280,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1629516008","product_id":100085301,"comment_content":"打卡记录<br>1. 如果有一个数据结构需要在多个线程中访问，可以把它放在栈上吗？为什么？<br>不能,有数据结构的栈可能已经被回收了,再访问就不安全了.<br>2. 可以使用指针引用栈上的某个变量吗？如果可以，在什么情况下可以这么做？<br>可以,在同一个代码块中用.","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525450,"discussion_content":"嗯，对的。你也可以看看我之前的回复。有更详尽的解答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629850244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308161,"user_name":"小白菜","can_delete":false,"product_type":"c1","uid":1258934,"ip_address":"","ucode":"B238AB5CF722DE","user_header":"https://static001.geekbang.org/account/avatar/00/13/35/b6/3289330f.jpg","comment_is_top":false,"comment_ctime":1629434502,"is_pvip":true,"replies":[{"id":"111780","content":"👍","user_name":"作者回复","user_name_real":"多少","uid":"2547771","ctime":1629817851,"ip_address":"","comment_id":308161,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1629434502","product_id":100085301,"comment_content":"1. 如果有一个数据结构需要在多个线程中访问，可以把它放在栈上吗？为什么？<br>不可以，因为栈的上分配的生命周期是不受开发者控制的，多线程如果可以访问大概率会访问到已经被释放的数据结构，会直接导致系统崩溃。<br><br>2. 可以使用指针引用栈上的某个变量吗？如果可以，在什么情况下可以这么做？<br>可以的，只要在这个当前函数的栈帧中即可，如果发生了逃逸应该就分配到堆上了。","like_count":0,"discussions":[{"author":{"id":2547771,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/3b/8ec916b2.jpg","nickname":"多少","note":"","ucode":"0A6EF7AA6E4BB7","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525412,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629817851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308106,"user_name":"扶凯·Kane","can_delete":false,"product_type":"c1","uid":1566287,"ip_address":"","ucode":"0896B4914E1A87","user_header":"https://static001.geekbang.org/account/avatar/00/17/e6/4f/736d578c.jpg","comment_is_top":false,"comment_ctime":1629413836,"is_pvip":false,"replies":[{"id":"111591","content":"编辑代回下这条：下周一23号正式更新，每周3篇，一&#47;三&#47;五更","user_name":"编辑回复","user_name_real":"叶如芊","uid":"2547771","ctime":1629429217,"ip_address":"","comment_id":308106,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1629413836","product_id":100085301,"comment_content":"什么时候更新下一讲, 等不急了","like_count":0,"discussions":[{"author":{"id":2547771,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/3b/8ec916b2.jpg","nickname":"多少","note":"","ucode":"0A6EF7AA6E4BB7","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525393,"discussion_content":"编辑代回下这条：下周一23号正式更新，每周3篇，一/三/五更","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629429217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308104,"user_name":"张大锤","can_delete":false,"product_type":"c1","uid":2739199,"ip_address":"","ucode":"6B04DB3CA97DCD","user_header":"https://static001.geekbang.org/account/avatar/00/29/cb/ff/9bf7a76d.jpg","comment_is_top":false,"comment_ctime":1629401353,"is_pvip":false,"replies":[{"id":"111603","content":"1 可以看我之前的解答；2. 是这个意思","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629431930,"ip_address":"","comment_id":308104,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1629401353","product_id":100085301,"comment_content":"1. 如果有一个数据结构需要在多个线程中访问，可以把它放在栈上吗？为什么？<br>看对这个数据结构操作的需求。<br>一是如果只读：<br>因为线程中各自的线程栈互相独立，数据放在栈中，相当于，每一个线程栈上存一份一样的东西。<br><br>二是需要读、写<br>某线程改写了数据，其他线程无法知道。除非某线程改之前，消息通知所有其他线程不再读或者写数据，改之后通知所有其他线程，停下操作，同步改数据再继续。<br><br><br><br>2. 可以使用指针引用栈上的某个变量吗？如果可以，在什么情况下可以这么做？<br>栈上的变量，就是局部变量，局部变量的性质：出作用域会被自动释放。<br>所以，指针变量 指向 局部变量要注意几点：<br>一是野指针问题，确保指针变量用之前先初始化，栈空间数据不会自动初始化为0。不初始化就用，会有非预期的情况。<br>二是悬空指针问题。确保指针指向的变量不被先释放，已释放的变量，指针读的数据没有意义，指针写则污染栈空间。<br><br><br>","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525391,"discussion_content":"1 可以看我之前的解答；2. 是这个意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629431930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307939,"user_name":"旻言","can_delete":false,"product_type":"c1","uid":1018724,"ip_address":"","ucode":"563E6A83A50EC9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8b/64/d8bf2f6f.jpg","comment_is_top":false,"comment_ctime":1629334150,"is_pvip":false,"replies":[{"id":"111598","content":"嗯，可以看我对之前留言的回答。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629431265,"ip_address":"","comment_id":307939,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1629334150","product_id":100085301,"comment_content":"我来说说我的想法：<br>1. 我认为可以，如果你的业务是在当前函数栈中，把栈上变量传给给worker线程池，或者自己启动多个worker线程处理，那么只要发起调用的线程同步等待worker线程处理返回就可以。<br>2. 可以，道理其实跟1类似，只是这里是同一个线程而已（相当于自己等自己）<br>","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525343,"discussion_content":"嗯，可以看我对之前留言的回答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629431265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307909,"user_name":"Casper","can_delete":false,"product_type":"c1","uid":1022129,"ip_address":"","ucode":"69282EB175B48E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/b1/f89a84d0.jpg","comment_is_top":false,"comment_ctime":1629301347,"is_pvip":true,"replies":[{"id":"111597","content":"嗯。更多思考可以看我对之前留言的回答。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629431258,"ip_address":"","comment_id":307909,"utype":1}],"discussion_count":1,"race_medal":5,"score":"1629301347","product_id":100085301,"comment_content":"问题1: 不可以放在栈上, 因为一旦该函数调用返回后, 栈的内存就会被回收。<br>","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525336,"discussion_content":"嗯。更多思考可以看我对之前留言的回答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629431258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307762,"user_name":"Bruce","can_delete":false,"product_type":"c1","uid":2365229,"ip_address":"","ucode":"2A48A313481754","user_header":"https://static001.geekbang.org/account/avatar/00/24/17/2d/b7614553.jpg","comment_is_top":false,"comment_ctime":1629249411,"is_pvip":false,"replies":[{"id":"111428","content":"编辑代回复一下这条：在课程首页，有一个“Rust语言入门交流群”链接，点击扫二维码就能加入啦","user_name":"编辑回复","user_name_real":"叶如芊","uid":"2547771","ctime":1629251488,"ip_address":"","comment_id":307762,"utype":2}],"discussion_count":3,"race_medal":0,"score":"1629249411","product_id":100085301,"comment_content":"订阅了课程，如何进群呀","like_count":0,"discussions":[{"author":{"id":2547771,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/3b/8ec916b2.jpg","nickname":"多少","note":"","ucode":"0A6EF7AA6E4BB7","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525277,"discussion_content":"编辑代回复一下这条：在课程首页，有一个“Rust语言入门交流群”链接，点击扫二维码就能加入啦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629251488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2741273,"avatar":"https://static001.geekbang.org/account/avatar/00/29/d4/19/05bd2dcc.jpg","nickname":"尽心尽力就好","note":"","ucode":"CE24BBB1012BA8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389580,"discussion_content":"二维码显示被添加频繁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629346730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018724,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/64/d8bf2f6f.jpg","nickname":"旻言","note":"","ucode":"563E6A83A50EC9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389549,"discussion_content":"没找到啊，入群二维码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629335990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307743,"user_name":"1031","can_delete":false,"product_type":"c1","uid":1000678,"ip_address":"","ucode":"2958B982EDD3D3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/e6/5a571300.jpg","comment_is_top":false,"comment_ctime":1629244912,"is_pvip":false,"replies":[{"id":"111452","content":"可以看我之前的回复。是的，栈上可以存放大小不确定的数据。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629255894,"ip_address":"","comment_id":307743,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1629244912","product_id":100085301,"comment_content":"对无法确定大小和大小可以改变作为堆和栈的区别，我是存疑的，栈上也可以","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525270,"discussion_content":"可以看我之前的回复。是的，栈上可以存放大小不确定的数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629255894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307728,"user_name":"kimi","can_delete":false,"product_type":"c1","uid":1014643,"ip_address":"","ucode":"4DBCA231850D6A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/73/e5b46aa9.jpg","comment_is_top":false,"comment_ctime":1629215761,"is_pvip":false,"replies":[{"id":"111453","content":"第一个问题：如果值在线程 A 结束的时候释放，而此刻线程 B 对其的引用还存在，则会存在 use after free 的危险。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629256078,"ip_address":"","comment_id":307728,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1629215761","product_id":100085301,"comment_content":"两个思考题本质上是一个问题，答案都是可以。第二个问题大部分同学的回答都是可以，如果第二个问题可以，是可以推导出第一个问题也是可以的，因为栈上的变量和数据结构本质上都是栈上的一段内存区域，当然在栈上分配的数据结构得是定长的，如果这段内存区域可以使用指针引用，那这个指针就是可以在多个线程之间共享的。<br><br>简单介绍一下这两个问题背后的原理，在 x86 架构下，每个栈帧所占用的内存区域保存在两个寄存器中 ebp 和 esp，esp 是栈顶也即是帧顶指针，ebp 是帧底指针，编译器可以计算出每个栈帧的大小，程序员也能够计算出栈帧上任意定长数据结构或变量的指针。<br><br>另外，推荐程序员的自我修养这本书，第 11 章详细介绍了内存和调用惯例，了解了硬件架构的调用惯例就能随意调用进程内的函数了。<br><br>","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525263,"discussion_content":"第一个问题：如果值在线程 A 结束的时候释放，而此刻线程 B 对其的引用还存在，则会存在 use after free 的危险。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629256078,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307711,"user_name":"啥都不会的二胡","can_delete":false,"product_type":"c1","uid":2439739,"ip_address":"","ucode":"3A0387E2C9EEF9","user_header":"https://static001.geekbang.org/account/avatar/00/25/3a/3b/77b1946f.jpg","comment_is_top":false,"comment_ctime":1629210593,"is_pvip":false,"replies":[{"id":"111455","content":"1. 对，然而这种情况需要开发者来确保其安全性。<br>2. 对。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629256266,"ip_address":"","comment_id":307711,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1629210593","product_id":100085301,"comment_content":"1. 如果有一个数据结构需要在多个线程中访问，可以把它放在栈上吗？为什么？<br>从理论上来说可以存放于栈上。函数被执行时系统会在栈中为之分配栈帧，只要函数不结束运行，为其分配的栈帧不会被回收。而线程有都各自具有独立的栈空间，假设我们创建多个线程，每个线程都有一个入口函数，如果这些入口函数都进行死循环，则入口函数不会退出，栈帧也不会被回收。我们在入口函数中定义能够在编译时大小明确的局部变量，由于这些局部变量会被分配在栈中，且线程的入口函数不会退出，因此这个时候，这些定义在栈上的局部变量就可以被其他线程访问到。<br>2. 可以使用指针引用栈上的某个变量吗？如果可以，在什么情况下可以这么做？<br>可以。假设A函数调用B函数，A函数的栈帧分配后进入B函数并分配栈帧，此时可以在B函数中访问A函数栈上的变量，因为此时A函数栈帧并未被回收。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525254,"discussion_content":"1. 对，然而这种情况需要开发者来确保其安全性。\n2. 对。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629256266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307700,"user_name":"abeng","can_delete":false,"product_type":"c1","uid":1004232,"ip_address":"","ucode":"327D146A588324","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/c8/88cb1358.jpg","comment_is_top":false,"comment_ctime":1629205334,"is_pvip":false,"replies":[{"id":"111458","content":"1. 赞「作死」:)<br>2. 对","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629256627,"ip_address":"","comment_id":307700,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1629205334","product_id":100085301,"comment_content":"<br>1. 如果有一个数据结构需要在多个线程中访问，可以把它放在栈上吗？为什么？<br>理论上是可以的，也就是Cross-thread Stack Access，比如通过指向该数据结构的全局指针Ptr0，Thread1中初始化数据结构，地址保存到Ptr0，然后Thread2中访问Ptr0。但是，这么作死何必呢？<br>2. 可以使用指针引用栈上的某个变量吗？如果可以，在什么情况下可以这么做？<br>可以，当前作用域中向下传递，跟闭包差不多用法？","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525248,"discussion_content":"1. 赞「作死」:)\n2. 对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629256627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307673,"user_name":"虾","can_delete":false,"product_type":"c1","uid":1480118,"ip_address":"","ucode":"AD2E4C1EA4A946","user_header":"https://static001.geekbang.org/account/avatar/00/16/95/b6/9aff520e.jpg","comment_is_top":false,"comment_ctime":1629195933,"is_pvip":false,"replies":[{"id":"111460","content":"确切地说是操作系统提供的接口，在 unix 下是 libc 的 malloc，在 windows 下应该是 MSVC 的 malloc，可以看：https:&#47;&#47;doc.rust-lang.org&#47;std&#47;alloc&#47;index.html。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629257121,"ip_address":"","comment_id":307673,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1629195933","product_id":100085301,"comment_content":"“堆上内存分配会使用 libc 提供的 malloc() 函数”<br><br>这一句有些疑惑。Rust库底层是通过调用C库实现的吗？是为了容易实现与C语言二进制兼容？还是其他原因？","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525238,"discussion_content":"确切地说是操作系统提供的接口，在 unix 下是 libc 的 malloc，在 windows 下应该是 MSVC 的 malloc，可以看：https://doc.rust-lang.org/std/alloc/index.html。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629257121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307587,"user_name":"Geek_157398","can_delete":false,"product_type":"c1","uid":2738930,"ip_address":"","ucode":"21D6B343CA8F76","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DEiaFzfWQxaYIsLIb3icXDj6pgpaHme1Et8OApwpaaPI8Ah5GsiaVPvDeYc8ibhTtkJyib4MpmkJjgaibGWpORXIy1ag/132","comment_is_top":false,"comment_ctime":1629166783,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1629166783","product_id":100085301,"comment_content":"很棒 开口脆","like_count":0},{"had_liked":false,"id":307572,"user_name":"MILI","can_delete":false,"product_type":"c1","uid":1585568,"ip_address":"","ucode":"E16CC7C5495093","user_header":"https://static001.geekbang.org/account/avatar/00/18/31/a0/4a6352ae.jpg","comment_is_top":false,"comment_ctime":1629164212,"is_pvip":false,"replies":[{"id":"111412","content":"嗯，谢谢你的回复。我在另外两个留言中详细回复了，你可以看看。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629249440,"ip_address":"","comment_id":307572,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1629164212","product_id":100085301,"comment_content":"在查找一些资料后，如下思考，如有错误 请老师指正<br><br>1. 如果有一个数据结构需要在多个线程中访问，可以把它放在栈上吗？为什么？<br><br>   进程拥有代码和打开的文件资源、数据资源、独立的内存空间。<br><br>   线程从属于进程，一个进程至少包含一个主线程，线程拥有自己的栈空间（进程的堆栈空间的一部分）。<br><br>   进程中内存空间对应的虚拟的地址是唯一的。<br><br>   进程中线程分为主线程和子线程，子线程由主线程派生。<br><br>   在同一进程内， 只要获取栈的指针，是可以进行访问的。<br><br>   基于以上的推理，可以在同一进程内的子线程，访问主线程栈上数据结构。<br><br>   子线程拿到其他子线程的栈空间地址是可以访问的。<br><br>   是否可以放在栈上，要看以下几点<br>   \t数据结构中的数据长度是否是确定的,数据是否超过栈的大小<br>   \t数据结构生命周期是否是固定，数据的生命周期是否超过子线程的生命周期<br>   \t多线程访问是否是只读访问，是否有数据竞态的发生<br><br>   <br><br>2. 可以使用指针引用栈上的某个变量吗？如果可以，在什么情况下可以这么做？<br>   在同一进程内可以使用指针引用访问某个变量。<br><br>   可以的情况<br>   栈上的变量生命周期 大于 使用变量的线程生命周期，否则会造成悬垂指针<br><br>   <br><br>","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525198,"discussion_content":"嗯，谢谢你的回复。我在另外两个留言中详细回复了，你可以看看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629249440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307482,"user_name":"袁俊卿","can_delete":false,"product_type":"c1","uid":1163651,"ip_address":"","ucode":"6DBC05E7F80703","user_header":"https://static001.geekbang.org/account/avatar/00/11/c1/83/f6b67a46.jpg","comment_is_top":false,"comment_ctime":1629118874,"is_pvip":false,"replies":[{"id":"111413","content":"嗯，1 正解。对于 2，大部分编程语言都不推荐，但在 Rust 中，这是一个比较常见的操作。我们只要保证引用先于值退出作用域即可。可以看我之前的回复。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629249699,"ip_address":"","comment_id":307482,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1629118874","product_id":100085301,"comment_content":"1.多线程引用的数据结构最好不要放在栈上，放入栈中，要确保他不会随着函数的调用和返回所覆盖，否则会出现段错误或者其他错误。<br>2.一般不建议引用栈上的变量，如果要引用，同样要保证该变量不会随着函数的调用和返回覆盖。程序执行过程中，不存在函数返回情况下，可以引用栈上的变量。或者保证随着函数的调用返回，引用变量的所在的栈上的位置，从来没有sp寄存器的加减所覆盖过。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525167,"discussion_content":"嗯，1 正解。对于 2，大部分编程语言都不推荐，但在 Rust 中，这是一个比较常见的操作。我们只要保证引用先于值退出作用域即可。可以看我之前的回复。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629249699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}