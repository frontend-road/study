{"id":128623,"title":"08 | 作用域和生存期：实现块作用域和函数","content":"<p>目前，我们已经用Antlr重构了脚本解释器，有了工具的帮助，我们可以实现更高级的功能，比如函数功能、面向对象功能。当然了，在这个过程中，我们还要克服一些挑战，比如：</p><ul>\n<li>如果要实现函数功能，要升级变量管理机制；</li>\n<li>引入作用域机制，来保证变量的引用指向正确的变量定义；</li>\n<li>提升变量存储机制，不能只把变量和它的值简单地扔到一个HashMap里，要管理它的生存期，减少对内存的占用。</li>\n</ul><p>本节课，我将借实现块作用域和函数功能，带你探讨作用域和生存期及其实现机制，并升级变量管理机制。那么什么是作用域和生存期，它们的重要性又体现在哪儿呢？</p><p><strong>“作用域”和“生存期”</strong>是计算机语言中更加基础的概念，它们可以帮你深入地理解函数、块、闭包、面向对象、静态成员、本地变量和全局变量等概念。</p><p>而且一旦你深入理解，了解作用域与生存期在编译期和运行期的机制之后，就能解决在学习过程中可能遇到的一些问题，比如：</p><ul>\n<li>闭包的机理到底是什么？</li>\n<li>为什么需要栈和堆两种机制来管理内存？它们的区别又是什么？</li>\n<li>一个静态的内部类和普通的内部类有什么区别？</li>\n</ul><p>了解上面这些内容之后，接下来，我们来具体看看什么是作用域。</p><h2>作用域（Scope）</h2><p>作用域是指计算机语言中变量、函数、类等起作用的范围，我们来看一个具体的例子。</p><!-- [[[read_end]]] --><p>下面这段代码是用C语言写的，我们在全局以及函数fun中分别声明了a和b两个变量，然后在代码里对这些变量做了赋值操作：</p><pre><code>/*\nscope.c\n测试作用域。\n */\n#include &lt;stdio.h&gt;\n\nint a = 1;\n\nvoid fun()\n{\n    a = 2;\n    //b = 3;   //出错，不知道b是谁\n    int a = 3; //允许声明一个同名的变量吗？\n    int b = a; //这里的a是哪个？\n    printf(&quot;in fun: a=%d b=%d \\n&quot;, a, b);\n}\n\nint b = 4; //b的作用域从这里开始\n\nint main(int argc, char **argv){\n    printf(&quot;main--1: a=%d b=%d \\n&quot;, a, b);\n\n    fun();\n    printf(&quot;main--2: a=%d b=%d \\n&quot;, a, b);\n\n    //用本地变量覆盖全局变量\n    int a = 5;\n    int b = 5;\n    printf(&quot;main--3: a=%d b=%d \\n&quot;, a, b);\n\n    //测试块作用域\n    if (a &gt; 0){\n        int b = 3; //允许在块里覆盖外面的变量\n        printf(&quot;main--4: a=%d b=%d \\n&quot;, a, b);\n    }\n    else{\n        int b = 4; //跟if块里的b是两个不同的变量\n        printf(&quot;main--5: a=%d b=%d \\n&quot;, a, b);\n    }\n\n    printf(&quot;main--6: a=%d b=%d \\n&quot;, a, b);\n}\n</code></pre><p>这段代码编译后运行，结果是：</p><pre><code>main--1: a=1 b=4 \nin fun: a=3 b=3 \nmain--2: a=2 b=4 \nmain--3: a=5 b=5 \nmain--4: a=5 b=3 \nmain--6: a=5 b=5 \n</code></pre><p>我们可以得出这样的规律：</p><ul>\n<li>变量的作用域有大有小，外部变量在函数内可以访问，而函数中的本地变量，只有本地才可以访问。</li>\n<li>变量的作用域，从声明以后开始。</li>\n<li>在函数里，我们可以声明跟外部变量相同名称的变量，这个时候就覆盖了外部变量。</li>\n</ul><p>下面这张图直观地显示了示例代码中各个变量的作用域：</p><p><img src=\"https://static001.geekbang.org/resource/image/2e/fc/2ea46e1b2d1a6c863f6830a7af5fd3fc.jpg?wh=1142*729\" alt=\"\"></p><p>另外，C语言里还有块作用域的概念，就是用花括号包围的语句，if和else后面就跟着这样的语句块。块作用域的特征跟函数作用域的特征相似，都可以访问外部变量，也可以用本地变量覆盖掉外部变量。</p><p>你可能会问：“其他语言也有块作用域吗？特征是一样的吗？”其实，各个语言在这方面的设计机制是不同的。比如，下面这段用Java写的代码里，我们用了一个if语句块，并且在if部分、else部分和外部分别声明了一个变量c：</p><pre><code>/**\n * Scope.java\n * 测试Java的作用域\n */\npublic class ScopeTest{\n\n    public static void main(String args[]){\n        int a = 1;\n        int b = 2;\n\n        if (a &gt; 0){\n            //int b = 3; //不允许声明与外部变量同名的变量\n            int c = 3;\n        }\n        else{\n            int c = 4;   //允许声明另一个c，各有各的作用域\n        }\n        \n        int c = 5;  //这里也可以声明一个新的c\n    }\n}\n</code></pre><p>你能看到，Java的块作用域跟C语言的块作用域是不同的，它不允许块作用域里的变量覆盖外部变量。那么和C、Java写起来很像的JavaScript呢？来看一看下面这段测试JavaScript作用域的代码：</p><pre><code>/**\n * Scope.js\n * 测试JavaScript的作用域\n */\nvar a = 5;\nvar b = 5;\nconsole.log(&quot;1: a=%d b=%d&quot;, a, b);\n\nif (a &gt; 0) {\n    a = 4;\n    console.log(&quot;2: a=%d b=%d&quot;, a, b);\n    var b = 3; //看似声明了一个新变量，其实还是引用的外部变量\n    console.log(&quot;3: a=%d b=%d&quot;, a, b);\n}\nelse {\n    var b = 4;\n    console.log(&quot;4: a=%d b=%d&quot;, a, b);\n}\n\nconsole.log(&quot;5: a=%d b=%d&quot;, a, b);\n\nfor (var b = 0; b&lt; 2; b++){  //这里是否能声明一个新变量，用于for循环？\n    console.log(&quot;6-%d: a=%d b=%d&quot;,b, a, b);\n}\n\nconsole.log(&quot;7: a=%d b=%d&quot;, a, b);\n</code></pre><p>这段代码编译后运行，结果是：</p><pre><code>1: a=5 b=5\n2: a=4 b=5\n3: a=4 b=3\n5: a=4 b=3\n6-0: a=4 b=0\n6-1: a=4 b=1\n7: a=4 b=2\n</code></pre><p>你可以看到，JavaScript是没有块作用域的。我们在块里和for语句试图重新定义变量b，语法上是允许的，但我们每次用到的其实是同一个变量。</p><p>对比了三种语言的作用域特征之后，你是否发现原来看上去差不多的语法，内部机理却不同？这种不同其实是语义差别的一个例子。<strong>你要注意的是，现在我们讲的很多内容都已经属于语义的范畴了，对作用域的分析就是语义分析的任务之一。</strong></p><h2>生存期（Extent）</h2><p>了解了什么是作用域之后，我们再理解一下跟它紧密相关的生存期。它是变量可以访问的时间段，也就是从分配内存给它，到收回它的内存之间的时间。</p><p>在前面几个示例程序中，变量的生存期跟作用域是一致的。出了作用域，生存期也就结束了，变量所占用的内存也就被释放了。这是本地变量的标准特征，这些本地变量是用栈来管理的。</p><p>但也有一些情况，变量的生存期跟语法上的作用域不一致，比如在堆中申请的内存，退出作用域以后仍然会存在。</p><p>下面这段C语言的示例代码中，fun函数返回了一个整数的指针。出了函数以后，本地变量b就消失了，这个指针所占用的内存（&amp;b）就收回了，其中&amp;b是取b的地址，这个地址是指向栈里的一小块空间，因为b是栈里申请的。在这个栈里的小空间里保存了一个地址，指向在堆里申请的内存。这块内存，也就是用来实际保存数值2的空间，并没有被收回，我们必须手动使用free()函数来收回。</p><pre><code>/*\nextent.c\n测试生存期。\n */\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint * fun(){\n    int * b = (int*)malloc(1*sizeof(int)); //在堆中申请内存\n    *b = 2;  //给该地址赋值2\n   \n    return b;\n}\n\nint main(int argc, char **argv){\n    int * p = fun();\n    *p = 3;\n\n    printf(&quot;after called fun: b=%lu *b=%d \\n&quot;, (unsigned long)p, *p);\n \n    free(p);\n}\n</code></pre><p>类似的情况在Java里也有。Java的对象实例缺省情况下是在堆中生成的。下面的示例代码中，从一个方法中返回了对象的引用，我们可以基于这个引用继续修改对象的内容，这证明这个对象的内存并没有被释放：</p><pre><code>/**\n * Extent2.java\n * 测试Java的生存期特性\n */\npublic class Extent2{\n \n    StringBuffer myMethod(){\n        StringBuffer b = new StringBuffer(); //在堆中生成对象实例\n        b.append(&quot;Hello &quot;);\n        System.out.println(System.identityHashCode(b)); //打印内存地址\n        return b;  //返回对象引用，本质是一个内存地址\n    }\n\n    public static void main(String args[]){\n        Extent2 extent2 = new Extent2();\n        StringBuffer c = extent2.myMethod(); //获得对象引用\n        System.out.println(c);\n        c.append(&quot;World!&quot;);         //修改内存中的内容\n        System.out.println(c);\n\n        //跟在myMethod()中打印的值相同\n        System.out.println(System.identityHashCode(c));\n    }\n}\n</code></pre><p>因为Java对象所采用的内存超出了申请内存时所在的作用域，所以也就没有办法自动收回。所以Java采用的是自动内存管理机制，也就是垃圾回收技术。</p><p>那么为什么说作用域和生存期是计算机语言更加基础的概念呢？其实是因为它们对应到了运行时的内存管理的基本机制。虽然各门语言设计上的特性是不同的，但在运行期的机制都很相似，比如都会用到栈和堆来做内存管理。</p><p>好了，理解了作用域和生存期的原理之后，我们就来实现一下，先来设计一下作用域机制，然后再模拟实现一个栈。</p><h2>实现作用域和栈</h2><p>在之前的PlayScript脚本的实现中，处理变量赋值的时候，我们简单地把变量存在一个哈希表里，用变量名去引用，就像下面这样：</p><pre><code>public class SimpleScript {\n    private HashMap&lt;String, Integer&gt; variables = new HashMap&lt;String, Integer&gt;();\n    ...\n}\n</code></pre><p>但如果变量存在多个作用域，这样做就不行了。这时，我们就要设计一个数据结构，区分不同变量的作用域。分析前面的代码，你可以看到作用域是一个树状的结构，比如Scope.c的作用域：</p><p><img src=\"https://static001.geekbang.org/resource/image/2d/c8/2d3fc83aba7fe2fd7b29227e97184fc8.jpg?wh=1142*552\" alt=\"\"></p><p>面向对象的语言不太相同，它不是一棵树，是一片树林，每个类对应一棵树，所以它也没有全局变量。在我们的playscript语言中，我们设计了下面的对象结构来表示Scope：</p><pre><code>//编译过程中产生的变量、函数、类、块，都被称作符号\npublic abstract class Symbol {\n    //符号的名称\n    protected String name = null;\n\n    //所属作用域\n    protected Scope enclosingScope = null;\n\n    //可见性，比如public还是private\n    protected int visibility = 0;\n\n    //Symbol关联的AST节点\n    protected ParserRuleContext ctx = null;\n}\n\n//作用域\npublic abstract class Scope extends Symbol{\n    // 该Scope中的成员，包括变量、方法、类等。\n    protected List&lt;Symbol&gt; symbols = new LinkedList&lt;Symbol&gt;();\n}\n\n//块作用域\npublic class BlockScope extends Scope{\n    ...\n}\n\n//函数作用域\npublic class Function extends Scope implements FunctionType{\n    ...  \n}\n\n//类作用域\npublic class Class extends Scope implements Type{\n    ...\n}\n</code></pre><p>目前我们划分了三种作用域，分别是块作用域（Block）、函数作用域（Function）和类作用域（Class）。</p><p>我们在解释执行playscript的AST的时候，需要建立起作用域的树结构，对作用域的分析过程是语义分析的一部分。也就是说，并不是有了AST，我们马上就可以运行它，在运行之前，我们还要做语义分析，比如对作用域做分析，让每个变量都能做正确的引用，这样才能正确地执行这个程序。</p><p>解决了作用域的问题以后，再来看看如何解决生存期的问题。还是看Scope.c的代码，随着代码的执行，各个变量的生存期表现如下：</p><ul>\n<li>进入程序，全局变量逐一生效；</li>\n<li>进入main函数，main函数里的变量顺序生效；</li>\n<li>进入fun函数，fun函数里的变量顺序生效；</li>\n<li>退出fun函数，fun函数里的变量失效；</li>\n<li>进入if语句块，if语句块里的变量顺序生效；</li>\n<li>退出if语句块，if语句块里的变量失效；</li>\n<li>退出main函数，main函数里的变量失效；</li>\n<li>退出程序，全局变量失效。</li>\n</ul><p>通过下面这张图，你能直观地看到运行过程中栈的变化：</p><p><img src=\"https://static001.geekbang.org/resource/image/51/06/51f278ccd4fc7f28c6840e1d6b20bd06.jpg?wh=1142*229\" alt=\"\"></p><p>代码执行时进入和退出一个个作用域的过程，可以用栈来实现。每进入一个作用域，就往栈里压入一个数据结构，这个数据结构叫做<strong>栈桢（Stack Frame）</strong>。栈桢能够保存当前作用域的所有本地变量的值，当退出这个作用域的时候，这个栈桢就被弹出，里面的变量也就失效了。</p><p>你可以看到，栈的机制能够有效地使用内存，变量超出作用域的时候，就没有用了，就可以从内存中丢弃。我在ASTEvaluator.java中，用下面的数据结构来表示栈和栈桢，其中的PlayObject通过一个HashMap来保存各个变量的值：</p><pre><code>private Stack&lt;StackFrame&gt; stack = new Stack&lt;StackFrame&gt;();\n\npublic class StackFrame {\n    //该frame所对应的scope\n    Scope scope = null;\n\n    //enclosingScope所对应的frame\n    StackFrame parentFrame = null;\n\n    //实际存放变量的地方\n    PlayObject object = null;\n}\n\npublic class PlayObject {\n    //成员变量\n    protected Map&lt;Variable, Object&gt; fields = new HashMap&lt;Variable, Object&gt;();\n}\n</code></pre><p>目前，我们只是在概念上模仿栈桢，当我们用Java语言实现的时候，PlayObject对象是存放在堆里的，Java的所有对象都是存放在堆里的，只有基础数据类型，比如int和对象引用是放在栈里的。虽然只是模仿，这不妨碍我们建立栈桢的概念，在后端技术部分，我们会实现真正意义上的栈桢。</p><p>要注意的是，栈的结构和Scope的树状结构是不一致的。也就是说，栈里的上一级栈桢，不一定是Scope的父节点。要访问上一级Scope中的变量数据，要顺着栈桢的parentFrame去找。我在上图中展现了这种情况，在调用fun函数的时候，栈里一共有三个栈桢：全局栈桢、main()函数栈桢和fun()函数栈桢，其中main()函数栈桢的parentFrame和fun()函数栈桢的parentFrame都是全局栈桢。</p><h2>实现块作用域</h2><p>目前，我们已经做好了作用域和栈，在这之后，就能实现很多功能了，比如让if语句和for循环语句使用块作用域和本地变量。以for语句为例，visit方法里首先为它生成一个栈桢，并加入到栈中，运行完毕之后，再从栈里弹出：</p><pre><code>BlockScope scope = (BlockScope) cr.node2Scope.get(ctx);  //获得Scope\nStackFrame frame = new StackFrame(scope);  //创建一个栈桢\npushStack(frame);    //加入栈中\n\n...\n\n//运行完毕，弹出栈\nstack.pop();\n</code></pre><p>当我们在代码中需要获取某个变量的值的时候，首先在当前桢中寻找。找不到的话，就到上一级作用域对应的桢中去找：</p><pre><code>StackFrame f = stack.peek();       //获取栈顶的桢\nPlayObject valueContainer = null;\nwhile (f != null) {\n    //看变量是否属于当前栈桢里\n    if (f.scope.containsSymbol(variable)){ \n        valueContainer = f.object;\n        break;\n    }\n    //从上一级scope对应的栈桢里去找  \n    f = f.parentFrame;\n}\n</code></pre><p>运行下面的测试代码，你会看到在执行完for循环以后，我们仍然可以声明另一个变量i，跟for循环中的i互不影响，这证明它们确实属于不同的作用域：</p><pre><code>String script = &quot;int age = 44; for(int i = 0;i&lt;10;i++) { age = age + 2;} int i = 8;&quot;;\n</code></pre><p>进一步的，我们可以实现对函数的支持。</p><h2>实现函数功能</h2><p>先来看一下与函数有关的语法：</p><pre><code>//函数声明\nfunctionDeclaration\n    : typeTypeOrVoid? IDENTIFIER formalParameters ('[' ']')*\n      functionBody\n    ;\n//函数体\nfunctionBody\n    : block\n    | ';'\n    ;\n//类型或void\ntypeTypeOrVoid\n    : typeType\n    | VOID\n    ;\n//函数所有参数\nformalParameters\n    : '(' formalParameterList? ')'\n    ;\n//参数列表\nformalParameterList\n    : formalParameter (',' formalParameter)* (',' lastFormalParameter)?\n    | lastFormalParameter\n    ;\n//单个参数\nformalParameter\n    : variableModifier* typeType variableDeclaratorId\n    ;\n//可变参数数量情况下，最后一个参数\nlastFormalParameter\n    : variableModifier* typeType '...' variableDeclaratorId\n    ;\n//函数调用    \nfunctionCall\n    : IDENTIFIER '(' expressionList? ')'\n    | THIS '(' expressionList? ')'\n    | SUPER '(' expressionList? ')'\n    ;\n</code></pre><p>在函数里，我们还要考虑一个额外的因素：<strong>参数。</strong>在函数内部，参数变量跟普通的本地变量在使用时没什么不同，在运行期，它们也像本地变量一样，保存在栈桢里。</p><p>我们设计一个对象来代表函数的定义，它包括参数列表和返回值的类型：</p><pre><code>public class Function extends Scope implements FunctionType{\n    // 参数\n    protected List&lt;Variable&gt; parameters = new LinkedList&lt;Variable&gt;();\n\n    //返回值\n    protected Type returnType = null;\n    \n    ...\n}\n</code></pre><p>在调用函数时，我们实际上做了三步工作：</p><ul>\n<li>建立一个栈桢；</li>\n<li>计算所有参数的值，并放入栈桢；</li>\n<li>执行函数声明中的函数体。</li>\n</ul><p>我把相关代码放在了下面，你可以看一下：</p><pre><code>//函数声明的AST节点\nFunctionDeclarationContext functionCode = (FunctionDeclarationContext) function.ctx;\n\n//创建栈桢\nfunctionObject = new FunctionObject(function);\nStackFrame functionFrame = new StackFrame(functionObject);\n\n// 计算实参的值\nList&lt;Object&gt; paramValues = new LinkedList&lt;Object&gt;();\nif (ctx.expressionList() != null) {\n    for (ExpressionContext exp : ctx.expressionList().expression()) {\n        Object value = visitExpression(exp);\n        if (value instanceof LValue) {\n            value = ((LValue) value).getValue();\n        }\n        paramValues.add(value);\n    }\n}\n\n//根据形参的名称，在栈桢中添加变量\nif (functionCode.formalParameters().formalParameterList() != null) {\n    for (int i = 0; i &lt; functionCode.formalParameters().formalParameterList().formalParameter().size(); i++) {\n        FormalParameterContext param = functionCode.formalParameters().formalParameterList().formalParameter(i);\n        LValue lValue = (LValue) visitVariableDeclaratorId(param.variableDeclaratorId());\n        lValue.setValue(paramValues.get(i));\n    }\n}\n\n// 调用方法体\nrtn = visitFunctionDeclaration(functionCode);\n\n// 运行完毕，弹出栈\nstack.pop();\n</code></pre><p>你可以用playscript测试一下函数执行的效果，看看参数传递和作用域的效果：</p><pre><code>String script = &quot;int b= 10; int myfunc(int a) {return a+b+3;} myfunc(2);&quot;;\n</code></pre><h2>课程小结</h2><p>本节课，我带你实现了块作用域和函数，还跟你一起探究了计算机语言的两个底层概念：作用域和生存期。你要知道：</p><ul>\n<li>对作用域的分析是语义分析的一项工作。Antlr能够完成很多词法分析和语法分析的工作，但语义分析工作需要我们自己做。</li>\n<li>变量的生存期涉及运行期的内存管理，也引出了栈桢和堆的概念，我会在编译器后端技术时进一步阐述。</li>\n</ul><p>我建议你在学习新语言的时候，先了解它在作用域和生存期上的特点，然后像示例程序那样做几个例子，借此你会更快理解语言的设计思想。比如，为什么需要命名空间这个特性？全局变量可能带来什么问题？类的静态成员与普通成员有什么区别？等等。</p><p>下一讲，我们会尝试实现面向对象特性，看看面向对象语言在语义上是怎么设计的，以及在运行期有什么特点。</p><h2>一课一思</h2><p>既然我强调了作用域和生存期的重要性，那么在你熟悉的语言中，有哪些特性是能用作用域和生存期的概念做更基础的解读呢？比如，面向对象的语言中，对象成员的作用域和生存期是怎样的？欢迎在留言区与大家一起交流。</p><p>最后，感谢你的阅读，如果这篇文章让你有所收获，也欢迎你将它分享给更多的朋友。</p><p>今天讲的功能照样能在playscript-java项目中找到示例代码，其中还有用playscript写的脚本，你可以多玩一玩。</p><ul>\n<li>playscript-java（项目目录）： <a href=\"https://gitee.com/richard-gong/PlayWithCompiler/tree/master/playscript-java\">码云</a>  <a href=\"https://github.com/RichardGong/PlayWithCompiler/tree/master/playscript-java\">GitHub</a></li>\n<li>PlayScript.java（入口程序）：<a href=\"https://gitee.com/richard-gong/PlayWithCompiler/blob/master/playscript-java/src/main/play/PlayScript.java\">码云</a>   <a href=\"https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/main/play/PlayScript.java\">GitHub</a></li>\n<li>PlayScript.g4（语法规则）：<a href=\"https://gitee.com/richard-gong/PlayWithCompiler/blob/master/playscript-java/src/main/play/PlayScript.g4\">码云</a>   <a href=\"https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/main/play/PlayScript.g4\">GitHub</a></li>\n<li>ASTEvaluator.java（解释器）：<a href=\"https://gitee.com/richard-gong/PlayWithCompiler/blob/master/playscript-java/src/main/play/ASTEvaluator.java\">码云</a>   <a href=\"https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/main/play/ASTEvaluator.java\">GitHub</a></li>\n<li>BlockScope.play（演示块作用域）：<a href=\"https://gitee.com/richard-gong/PlayWithCompiler/blob/master/playscript-java/src/examples/BlockScope.play\">码云</a>   <a href=\"https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/examples/BlockScope.play\">GitHub</a></li>\n<li>function.play（演示基础函数功能）：<a href=\"https://gitee.com/richard-gong/PlayWithCompiler/blob/master/playscript-java/src/examples/function.play\">码云</a>   <a href=\"https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/examples/function.play\">GitHub</a></li>\n<li>lab/scope目录（各种语言的作用域测试）：<a href=\"https://gitee.com/richard-gong/PlayWithCompiler/tree/master/lab/scope\">码云</a>    <a href=\"https://github.com/RichardGong/PlayWithCompiler/tree/master/lab/scope\">GitHub</a></li>\n</ul><p></p>","neighbors":{"left":{"article_title":"07 | 编译器前端工具（二）：用Antlr重构脚本语言","id":127781},"right":{"article_title":"09 | 面向对象：实现数据和方法的封装","id":130422}},"comments":[{"had_liked":false,"id":129571,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1567156044,"is_pvip":false,"replies":[{"id":"48574","content":"很准确，很清晰！","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1567408607,"ip_address":"","comment_id":129571,"utype":1}],"discussion_count":1,"race_medal":0,"score":"100351403852","product_id":100034101,"comment_content":"变量的使用范围由作用域决定，作用域由词法规则决定，词法分析生成作用域链，之后查找变量就沿着这条作用域链查找，与函数调用栈就没有关系了。一般函数的生存期就是出栈后就结束了，如果是引用对象会在本次GC中回收，如果产生了闭包，那就要等到引用闭包的变量销毁，生存期才结束。","like_count":24,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465548,"discussion_content":"很准确，很清晰！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567408607,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224768,"user_name":"聆听v风声","can_delete":false,"product_type":"c1","uid":2027820,"ip_address":"","ucode":"1FDF4A5A7F9323","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f1/2c/d526d280.jpg","comment_is_top":false,"comment_ctime":1591534953,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"96080815465","product_id":100034101,"comment_content":"示例代码建议每节课加个tag或分支之类的，现在后面的人来看，都是最终完全版的代码..","like_count":23},{"had_liked":false,"id":201326,"user_name":"幻境之桥","can_delete":false,"product_type":"c1","uid":1061517,"ip_address":"","ucode":"F9F4DD94CB554E","user_header":"https://static001.geekbang.org/account/avatar/00/10/32/8d/91cd624b.jpg","comment_is_top":false,"comment_ctime":1585751722,"is_pvip":false,"replies":[{"id":"77012","content":"因为fun函数和main函数都是在全局作用域中定义的。fun中如果有一个变量，不是在本地声明的，那到哪里去找呢？要到全局作用域中去找，而不是到main函数中找。<br><br>我在课程里没有介绍一个概念：词法作用域（Lexical Scope），等以后找机会加上。<br>词法作用域又叫做静态作用域，也就是说，程序里用到的变量，在编译时，就知道是哪个变量定义。因为完全是根据声明时的位置关系来做变量引用解析的。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1586830369,"ip_address":"","comment_id":201326,"utype":1}],"discussion_count":5,"race_medal":0,"score":"53125359274","product_id":100034101,"comment_content":"我在上图中展现了这种情况，在调用 fun 函数的时候，栈里一共有三个栈桢：全局栈桢、main() 函数栈桢和 fun() 函数栈桢，其中 main() 函数栈桢的 parentFrame 和 fun() 函数栈桢的 parentFrame 都是全局栈桢。<br><br>老师这里没有明白为什么 fun()函数栈桢的 parentFrame 是全局栈桢而不是 main()的函数栈桢<br><br>这个 parentFrame 怎么定义呢？","like_count":13,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490299,"discussion_content":"因为fun函数和main函数都是在全局作用域中定义的。fun中如果有一个变量，不是在本地声明的，那到哪里去找呢？要到全局作用域中去找，而不是到main函数中找。\n\n我在课程里没有介绍一个概念：词法作用域（Lexical Scope），等以后找机会加上。\n词法作用域又叫做静态作用域，也就是说，程序里用到的变量，在编译时，就知道是哪个变量定义。因为完全是根据声明时的位置关系来做变量引用解析的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586830369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2945019,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/ef/fb/ab4ecf4a.jpg","nickname":"barry的学习1号","note":"","ucode":"86F99FDBD040B7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564925,"discussion_content":"所以上面的那个图画main和fun不应该是上下关系，应该是并列关系吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650355654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":3172071,"avatar":"","nickname":"Geek_245453","note":"","ucode":"331F617993E7D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2945019,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/ef/fb/ab4ecf4a.jpg","nickname":"barry的学习1号","note":"","ucode":"86F99FDBD040B7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586609,"discussion_content":" 那个图是调用关系，main调用fun，fun的栈帧在main的上面。但是变量的作用域父节点都是全局","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662371484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":564925,"ip_address":"北京"},"score":586609,"extra":""}]},{"author":{"id":2718510,"avatar":"","nickname":"jack123","note":"","ucode":"873D0046EF39D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400292,"discussion_content":"像JS这种 函数是第一公民的 可以在函数里面定于函数 又是怎么实现的呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633225434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2718510,"avatar":"","nickname":"jack123","note":"","ucode":"873D0046EF39D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":399837,"discussion_content":"查找变量的时 先到当前的词法作用域中查找变量 没有找到 再到全局作用域","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633078704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129421,"user_name":"Johnson","can_delete":false,"product_type":"c1","uid":1225037,"ip_address":"","ucode":"55B582953E49F3","user_header":"https://static001.geekbang.org/account/avatar/00/12/b1/4d/10c75b34.jpg","comment_is_top":false,"comment_ctime":1567127757,"is_pvip":false,"replies":[{"id":"48252","content":"因为目前是在讲前端，所以就先不引入IR。<br>同时也是在告诉同学们，哪怕我们只拿到了AST，也已经能做很多事情了。<br><br>IR在后端部分会讲。我会给出一个自己设计的IR的例子，用IR重新实现部分功能。然后再去采用LLVM的IR。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1567150163,"ip_address":"","comment_id":129421,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40221833421","product_id":100034101,"comment_content":"现在课程的做法相当于AST之后直接解析执行了，所有的逻辑都堆在AST和紧接着的语义分析，没有把AST转化成IR，然后在这个IR上做各种事情，最后再到interpreter执行。是因为前期为了简单起见，所以先这么直观的来么？","like_count":10,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465459,"discussion_content":"因为目前是在讲前端，所以就先不引入IR。\n同时也是在告诉同学们，哪怕我们只拿到了AST，也已经能做很多事情了。\n\nIR在后端部分会讲。我会给出一个自己设计的IR的例子，用IR重新实现部分功能。然后再去采用LLVM的IR。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567150163,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135309,"user_name":"吃瓜群众路人丙","can_delete":false,"product_type":"c1","uid":1488328,"ip_address":"","ucode":"606399329E6641","user_header":"https://static001.geekbang.org/account/avatar/00/16/b5/c8/836ff8ab.jpg","comment_is_top":false,"comment_ctime":1569122936,"is_pvip":false,"replies":[{"id":"52094","content":"递归函数的调用。<br>int a;<br>int foo(){<br>  a = a+1;<br>  if (a&lt;10){<br>     return foo();<br>  }<br>  else{<br>    return a;<br>  }<br>}<br><br>在递归调用的时候，你在函数里仍然可以访问全局变量。这个全局变量不在上一级的函数栈桢里。而是在最底下那个全局变量的栈桢。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1569300326,"ip_address":"","comment_id":135309,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27338926712","product_id":100034101,"comment_content":"也就是说，栈里的上一级栈桢，不一定是 Scope 的父节点。<br>老师能举个反例吗","like_count":6,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468139,"discussion_content":"递归函数的调用。\nint a;\nint foo(){\n  a = a+1;\n  if (a&amp;lt;10){\n     return foo();\n  }\n  else{\n    return a;\n  }\n}\n\n在递归调用的时候，你在函数里仍然可以访问全局变量。这个全局变量不在上一级的函数栈桢里。而是在最底下那个全局变量的栈桢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569300326,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131730,"user_name":"mcuking","can_delete":false,"product_type":"c1","uid":1561415,"ip_address":"","ucode":"03E608A7FB1F1D","user_header":"https://static001.geekbang.org/account/avatar/00/17/d3/47/6f6c05e0.jpg","comment_is_top":false,"comment_ctime":1567866079,"is_pvip":false,"replies":[{"id":"50751","content":"是的，我注意到了。<br>严格的表述这样写可能比较好：如果只是像java和c那样声明变量，就没有块作用域:-)","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1568183488,"ip_address":"","comment_id":131730,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27337669855","product_id":100034101,"comment_content":"其实 js 的 es6 版本已经支持块级作用域，可以用 let const 声明","like_count":6,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466599,"discussion_content":"是的，我注意到了。\n严格的表述这样写可能比较好：如果只是像java和c那样声明变量，就没有块作用域:-)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568183488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1646694,"avatar":"https://static001.geekbang.org/account/avatar/00/19/20/66/778f1767.jpg","nickname":"飞翔的荷兰人","note":"","ucode":"A3D6ED50D75380","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8862,"discussion_content":"没有let的时候，js的var可太坑人了。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568085597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132729,"user_name":"Geek_f9ea2d","can_delete":false,"product_type":"c1","uid":1633065,"ip_address":"","ucode":"CB9B422F034493","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIBThvjr88V0BVAOC4PicPUNPITZ2la5iciatFNYyicibcwicBjIaxElz77xsphqStrr81CSQeTXiaBVMTAA/132","comment_is_top":false,"comment_ctime":1568205862,"is_pvip":false,"replies":[{"id":"51378","content":"这是直接照搬的Java的语法。这是对数组的支持。目前playscript并没有支持数组，但语法也就先这么放着了。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1568698342,"ip_address":"","comment_id":132729,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14453107750","product_id":100034101,"comment_content":"functionDeclaration<br>    : typeTypeOrVoid? IDENTIFIER formalParameters (&#39;[&#39; &#39;]&#39;)*<br>      (THROWS qualifiedNameList)?<br>      functionBody<br>中的(&#39;[&#39; &#39;]&#39;)* 这个没明白什么意思，函数的声明，我觉得这样就够了：typeTypeOrVoid? IDENTIFIER formalParameters","like_count":3,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467091,"discussion_content":"这是直接照搬的Java的语法。这是对数组的支持。目前playscript并没有支持数组，但语法也就先这么放着了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568698342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1179056,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fd/b0/e30fd916.jpg","nickname":"京京beaver","note":"","ucode":"C21838D7CA7D6B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":12981,"discussion_content":"这是java语法定义的原始版本的注释，我也没看懂。按道理来说(参数列表)之后不可能再出现[]了。\nWe use rule this even for void methods which cannot have [] after parameters.\n   This simplifies grammar and we can consider void to be a type, which\n   renders the [] matching as a context-sensitive issue or a semantic check\n   for invalid return type after parsing","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568623697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129657,"user_name":"ZYS","can_delete":false,"product_type":"c1","uid":1632751,"ip_address":"","ucode":"B91657BD8D8E60","user_header":"https://static001.geekbang.org/account/avatar/00/18/e9/ef/d4587970.jpg","comment_is_top":false,"comment_ctime":1567206684,"is_pvip":false,"replies":[{"id":"48572","content":"讲后端部分的时候，主要是用cpp版本实现的。那部分的指导资料我整理一下，写一个README.md，尽快更新到Github和码云上。<br><br>先简单说一下：<br>1.如果仅仅用cpp版本的Antlr，这个比较简单，你做练习的时候可以试用一下。<br>2.把Antlr和LLVM一起用的时候，要配置的东西更多一些，好在有cmake。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1567408393,"ip_address":"","comment_id":129657,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14452108572","product_id":100034101,"comment_content":"宫老师，可否兼顾一下用c++的学员，介绍一下cpp版本playscript如何在visual studio2010或更高的版本运行？","like_count":3,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465589,"discussion_content":"讲后端部分的时候，主要是用cpp版本实现的。那部分的指导资料我整理一下，写一个README.md，尽快更新到Github和码云上。\n\n先简单说一下：\n1.如果仅仅用cpp版本的Antlr，这个比较简单，你做练习的时候可以试用一下。\n2.把Antlr和LLVM一起用的时候，要配置的东西更多一些，好在有cmake。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567408393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175884,"user_name":"Aaaaaaaaaaayou","can_delete":false,"product_type":"c1","uid":1073601,"ip_address":"","ucode":"67BA315B87587D","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/c1/93031a2a.jpg","comment_is_top":false,"comment_ctime":1580878097,"is_pvip":false,"replies":[{"id":"77033","content":"是的。谢谢你细心的阅读代码。<br>我已经在github里更新了，并且在commit comment中专门感谢了你:)<br>","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1586833072,"ip_address":"","comment_id":175884,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10170812689","product_id":100034101,"comment_content":"老师，playscript-java&#47;src&#47;main&#47;play&#47;DefaultFunctionType.java 中 public static boolean isType(FunctionType type1, FunctionType type2) 函数中 List&lt;Type&gt; paramTypes2 = type1.getParamTypes(); 是不是写错了? type1 应该改为 type2","like_count":2,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482940,"discussion_content":"是的。谢谢你细心的阅读代码。\n我已经在github里更新了，并且在commit comment中专门感谢了你:)\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586833072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129362,"user_name":"北冥Master","can_delete":false,"product_type":"c1","uid":1014142,"ip_address":"","ucode":"EBCCEC79AFC5DF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/79/7e/c38ac02f.jpg","comment_is_top":false,"comment_ctime":1567096666,"is_pvip":false,"replies":[{"id":"48254","content":"后几讲涉及的都是语义功能，并涉及了一部分运行期技术（给后端技术部分提前做铺垫）。<br>语义上的差别是每种语言真正的差别，但底层有一些共通的机制。搞搞明白对我们学各种语言都有好处。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1567150421,"ip_address":"","comment_id":129362,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10157031258","product_id":100034101,"comment_content":"牛逼，越来越深入了，看的有点吃力了","like_count":2,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465420,"discussion_content":"后几讲涉及的都是语义功能，并涉及了一部分运行期技术（给后端技术部分提前做铺垫）。\n语义上的差别是每种语言真正的差别，但底层有一些共通的机制。搞搞明白对我们学各种语言都有好处。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567150421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333878,"user_name":"Geek_6304e3","can_delete":false,"product_type":"c1","uid":2905630,"ip_address":"","ucode":"8DD9A6D8E7DC60","user_header":"","comment_is_top":false,"comment_ctime":1644569178,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5939536474","product_id":100034101,"comment_content":"老师，这个java项目的怎么跑起来呢，不懂java。","like_count":2},{"had_liked":false,"id":333875,"user_name":"Geek_6304e3","can_delete":false,"product_type":"c1","uid":2905630,"ip_address":"","ucode":"8DD9A6D8E7DC60","user_header":"","comment_is_top":false,"comment_ctime":1644568323,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5939535619","product_id":100034101,"comment_content":"老师可以照顾下前端的同学吗？有没有JavaScript版的呢","like_count":2},{"had_liked":false,"id":164454,"user_name":"草戊","can_delete":false,"product_type":"c1","uid":1044202,"ip_address":"","ucode":"F1B0CB0A4FA762","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/ea/c8136dfd.jpg","comment_is_top":false,"comment_ctime":1576996758,"is_pvip":false,"replies":[{"id":"63363","content":"实际上，在每一行代码，可以见到的“可用表达式”的集合都是不一样的。也就是说，在每一行，你可以反问的变量都是不同的。<br>比如，在int i = 3之后，你访问的i，和在它前面访问的i，是不一样的。<br>也就是说，块作用域，并不是在整个块里可见，而是在这个块里变量声明之后才可见。<br>在28讲，数据流分析中，专门有活跃性分析的一个算法，会教会你确定在每个位置的可用变量。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1577431564,"ip_address":"","comment_id":164454,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5871964054","product_id":100034101,"comment_content":"&#47;&#47;全局变量<br>int i = 0;<br>{<br>    &#47;&#47;这里引用的是全局变量<br>    i = 2;<br>    println(i); &#47;&#47;输出：2<br><br>    &#47;&#47;允许在块里新创建一个同名的变量<br>    int i = 3;<br>    println(i); &#47;&#47;输出：3<br>}<br>您好，上面例子中  【i = 2;】这句话在块中使用全局变量，但是实际上此块中也定义了i变量，只不过位置比较靠后，这种情况，本文中的作用域有办法解决吗？如果优先在本块中查找，那么会不会找到自己块中的i，而不是全局的i呢？<br>","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478772,"discussion_content":"实际上，在每一行代码，可以见到的“可用表达式”的集合都是不一样的。也就是说，在每一行，你可以反问的变量都是不同的。\n比如，在int i = 3之后，你访问的i，和在它前面访问的i，是不一样的。\n也就是说，块作用域，并不是在整个块里可见，而是在这个块里变量声明之后才可见。\n在28讲，数据流分析中，专门有活跃性分析的一个算法，会教会你确定在每个位置的可用变量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577431564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129892,"user_name":"Geek_89bbab","can_delete":false,"product_type":"c1","uid":1156607,"ip_address":"","ucode":"B3110D5B3C9500","user_header":"https://static001.geekbang.org/account/avatar/00/11/a5/ff/6201122c.jpg","comment_is_top":false,"comment_ctime":1567318100,"is_pvip":false,"replies":[{"id":"48580","content":"我往代码里加了注释，你可以更新一下看看！<br>我也把注释拷贝到这里。<br>里面有些特性，比如一等公民函数，是还没讲到的，10讲就会讲。<br><br>第一个if：<br>&#47;*<br>如果新加入的栈桢，跟某个已有的栈桢的enclosingScope是一样的，那么这俩的parentFrame也一样。<br>因为它们原本就是同一级的嘛。<br>比如：<br>void foo(){};<br>void bar(foo());<br><br>或者：<br>void foo();<br>if (...){<br>    foo();<br>}<br>*&#47;<br><br>第二个if:<br>&#47;*<br>如果新加入的栈桢，是某个已有的栈桢的下一级，那么就把把这个父子关系建立起来。比如：<br>void foo(){<br>    if (...){  &#47;&#47;把这个块往栈桢里加的时候，就符合这个条件。<br>    }<br>}<br>再比如,下面的例子:<br>class MyClass{<br>    void foo();<br>}<br>MyClass c = MyClass();  &#47;&#47;先加Class的栈桢，里面有类的属性，包括父类的<br>c.foo();                &#47;&#47;再加foo()的栈桢<br>    *&#47;<br><br>第3个if：<br>&#47;*<br>这是针对函数可能是一等公民的情况。这个时候，函数运行时的作用域，与声明时的作用域会不一致。<br>我在这里设计了一个“receiver”的机制，意思是这个函数是被哪个变量接收了。要按照这个receiver的作用域来判断。<br>*&#47;","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1567412704,"ip_address":"","comment_id":129892,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5862285396","product_id":100034101,"comment_content":"    private void pushStack(StackFrame frame) {<br>        &#47;&#47; 如果新加入的frame是当前frame的下一级，则入栈<br>        if (stack.size() &gt; 0) {<br><br>            for (int i = stack.size()-1; i&gt;0; i--){<br>                StackFrame f = stack.get(i);<br>                if (f.scope.enclosingScope == frame.scope.enclosingScope){<br>                    frame.parentFrame = f.parentFrame;<br>                    break;<br>                }<br>                else if (f.scope == frame.scope.enclosingScope){<br>                    frame.parentFrame = f;<br>                    break;<br>                }<br>                else if (frame.object instanceof FunctionObject){<br>                    FunctionObject functionObject = (FunctionObject)frame.object;<br>                    if (functionObject.receiver != null &amp;&amp; functionObject.receiver.enclosingScope == f.scope) {<br>                        frame.parentFrame = f;<br>                        break;<br>                    }<br>                }<br>            }<br><br>            if (frame.parentFrame == null){<br>                frame.parentFrame = stack.peek();<br>            }<br>        }<br><br>        stack.push(frame);<br><br>        if (traceStackFrame){<br>            dumpStackFrame();<br>        }<br>    }<br>老师可以解释一下这个函数吗?","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465700,"discussion_content":"我往代码里加了注释，你可以更新一下看看！\n我也把注释拷贝到这里。\n里面有些特性，比如一等公民函数，是还没讲到的，10讲就会讲。\n\n第一个if：\n/*\n如果新加入的栈桢，跟某个已有的栈桢的enclosingScope是一样的，那么这俩的parentFrame也一样。\n因为它们原本就是同一级的嘛。\n比如：\nvoid foo(){};\nvoid bar(foo());\n\n或者：\nvoid foo();\nif (...){\n    foo();\n}\n*/\n\n第二个if:\n/*\n如果新加入的栈桢，是某个已有的栈桢的下一级，那么就把把这个父子关系建立起来。比如：\nvoid foo(){\n    if (...){  //把这个块往栈桢里加的时候，就符合这个条件。\n    }\n}\n再比如,下面的例子:\nclass MyClass{\n    void foo();\n}\nMyClass c = MyClass();  //先加Class的栈桢，里面有类的属性，包括父类的\nc.foo();                //再加foo()的栈桢\n    */\n\n第3个if：\n/*\n这是针对函数可能是一等公民的情况。这个时候，函数运行时的作用域，与声明时的作用域会不一致。\n我在这里设计了一个“receiver”的机制，意思是这个函数是被哪个变量接收了。要按照这个receiver的作用域来判断。\n*/","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567412704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1384201,"avatar":"https://static001.geekbang.org/account/avatar/00/15/1f/09/3da5feb4.jpg","nickname":"李斯宁","note":"","ucode":"E1D45C1410C9FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368263,"discussion_content":"第一个有问题吧   bar(foo()){}  应该是 bar(){ foo(); } 吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618634708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":315188,"user_name":"hYector","can_delete":false,"product_type":"c1","uid":2173880,"ip_address":"","ucode":"C1DEEB8FAC0B2E","user_header":"https://static001.geekbang.org/account/avatar/00/21/2b/b8/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1633745853,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633745853","product_id":100034101,"comment_content":"请教老师，既然说每个变量都有自己的作用域，但是在作用域实现部分，突然变成全局，main(), if块等作用域，这是观念是怎么切换过来的？","like_count":0},{"had_liked":false,"id":301616,"user_name":"pencilCool","can_delete":false,"product_type":"c1","uid":1461770,"ip_address":"","ucode":"49A9FE2DEE2911","user_header":"https://static001.geekbang.org/account/avatar/00/16/4e/0a/0ff15eaa.jpg","comment_is_top":false,"comment_ctime":1625789016,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625789016","product_id":100034101,"comment_content":"嵌套的两个大括号，内外层出现同名变量：C 语言允许 覆盖，java 不允许，javascript 指向同一个。","like_count":0},{"had_liked":false,"id":240264,"user_name":"Geek_satsuki","can_delete":false,"product_type":"c1","uid":2096719,"ip_address":"","ucode":"9A94CD61747267","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLxoRkKV1kq8iaVzIzOmdG4fxzlibsjRcWRjRicaspaceAFMUqn8sa9xx0cNJSDaspHuWASsmSj0qPOQ/132","comment_is_top":false,"comment_ctime":1596815516,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596815516","product_id":100034101,"comment_content":"String script = &quot;int b= 10; int myfunc(int a) {return a+b+3;} myfunc(2);&quot;;<br>测试函数出现NULLException<br>script = int b= 10; int myfunc(int a) {return a+b+3;} myfunc(2);<br>Exception in thread &quot;main&quot; java.lang.NullPointerException<br>\tat play.TypeResolver.exitFormalParameter(TypeResolver.java:105)<br>\tat play.PlayScriptParser$FormalParameterContext.exitRule(PlayScriptParser.java:940)<br>","like_count":0},{"had_liked":false,"id":197507,"user_name":"漏网之渔","can_delete":false,"product_type":"c1","uid":1092258,"ip_address":"","ucode":"8D7896E99E784C","user_header":"https://static001.geekbang.org/account/avatar/00/10/aa/a2/c7a3758d.jpg","comment_is_top":false,"comment_ctime":1585382442,"is_pvip":true,"replies":[{"id":"77023","content":"在示例程序中，我是用一个PlayObject来模拟栈帧的，它里面用了一个HashMap来存放变量值。这些变量可能是一个函数的本地变量，也可能是对象的成员变量。<br>而MyLValue，实际上就是对一个栈帧中的变量的引用，相当于C语言中的一个变量地址。基于这个引用，就可以找到准确的变量存储位置，并做修改。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1586831506,"ip_address":"","comment_id":197507,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1585382442","product_id":100034101,"comment_content":"老师，lValue.setValue(paramValues.get(i));   为什么执行完这一行，实参的值就能进入functionFrame了？调试了一下代码，发现进入了MyLVaue类的setValue方法，这个MyLvalue类有一个private PlayObject valueContainer属性，改变了这个属性中的Map&lt;Variable, Object&gt; fields值，但是它是怎么改变frame栈帧里的值的呢？这一点我调试了之后不太明白；对MyLvalue和frame的关系不太理解，请老师指点。","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489536,"discussion_content":"在示例程序中，我是用一个PlayObject来模拟栈帧的，它里面用了一个HashMap来存放变量值。这些变量可能是一个函数的本地变量，也可能是对象的成员变量。\n而MyLValue，实际上就是对一个栈帧中的变量的引用，相当于C语言中的一个变量地址。基于这个引用，就可以找到准确的变量存储位置，并做修改。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586831506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1092258,"avatar":"https://static001.geekbang.org/account/avatar/00/10/aa/a2/c7a3758d.jpg","nickname":"漏网之渔","note":"","ucode":"8D7896E99E784C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216400,"discussion_content":"今天又调试了一遍大概理解清楚了。1. getLValue((Variable) symbol) 得到了栈顶栈帧中函数参数变量的PlayObject(存放成员变量的地方)，接着new 了一个MyValue作为返回值   2. new 新的MyLvalue实例对象时，构造函数中传递的参数PlayObject引用指向的是传进来的LValue，这个还是之前栈中的PlayObject，并没有产生新的实例对象，只是地址引用。 3.所以在lValue.setValue(paramValues.get(i));时，改变的还是栈帧PlayObject中的值。所以在后面的visitFunctionDeclaration(functionCode)访问函数体执行函数的时候，能够正确拿到栈帧的形参值。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585446162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196828,"user_name":"漏网之渔","can_delete":false,"product_type":"c1","uid":1092258,"ip_address":"","ucode":"8D7896E99E784C","user_header":"https://static001.geekbang.org/account/avatar/00/10/aa/a2/c7a3758d.jpg","comment_is_top":false,"comment_ctime":1585316206,"is_pvip":true,"replies":[{"id":"77017","content":"在示例代码里，PlayObject我就是拿它模拟一个栈帧的，里面放着各个变量的值。<br><br>LValue是左值的意思，也就是可以出现在赋值符号的左边。它得是一个对象引用（或C语言中的地址），以便往里面写新的值。而赋值符号右边的，叫做右值，它可以是一个具体的数值。<br><br>左值可以当做右值用，但右值不可以当成左值用。<br><br>在给AST做语义分析的时候，可以分析出哪个标识符实际是个左值，这样的话，遍历AST时，要获得变量引用，而不是获得变量值。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1586830891,"ip_address":"","comment_id":196828,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585316206","product_id":100034101,"comment_content":"老师，这里的LValue和PlayObject分别扮演的角色功能是什么样的，什么时候会用到他们；看了源代码，自己有点理不清楚。","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489397,"discussion_content":"在示例代码里，PlayObject我就是拿它模拟一个栈帧的，里面放着各个变量的值。\n\nLValue是左值的意思，也就是可以出现在赋值符号的左边。它得是一个对象引用（或C语言中的地址），以便往里面写新的值。而赋值符号右边的，叫做右值，它可以是一个具体的数值。\n\n左值可以当做右值用，但右值不可以当成左值用。\n\n在给AST做语义分析的时候，可以分析出哪个标识符实际是个左值，这样的话，遍历AST时，要获得变量引用，而不是获得变量值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586830891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158513,"user_name":"E","can_delete":false,"product_type":"c1","uid":1193143,"ip_address":"","ucode":"B1B0759EDA4AF9","user_header":"https://static001.geekbang.org/account/avatar/00/12/34/b7/60281658.jpg","comment_is_top":false,"comment_ctime":1575389348,"is_pvip":false,"replies":[{"id":"64898","content":"没有。<br>但是antlr支持在语法规则里嵌入一些代码，在语法分析的过程中完成一些语义分析工作。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1577698048,"ip_address":"","comment_id":158513,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1575389348","product_id":100034101,"comment_content":"有可以生成语义分析器的工具吗","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476752,"discussion_content":"没有。\n但是antlr支持在语法规则里嵌入一些代码，在语法分析的过程中完成一些语义分析工作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577698048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137859,"user_name":"风","can_delete":false,"product_type":"c1","uid":1444483,"ip_address":"","ucode":"E1CE0825AAF805","user_header":"https://static001.geekbang.org/account/avatar/00/16/0a/83/f916f903.jpg","comment_is_top":false,"comment_ctime":1569900959,"is_pvip":false,"replies":[{"id":"53878","content":"这里的代码我还没整理整齐。在后端部分的课程放出时，我会整理好。先简单的说一下：<br>Antlr本身是Java写的，但它可以生成其他语言的编译工具。这些编译工具呢，要调用一些基础的功能，这些功能就是针对不同语言的运行时（runtime）。<br>用C++编程时，需要用到头文件，然后用到它的库。a文件和dylib就是库。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1570703873,"ip_address":"","comment_id":137859,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569900959","product_id":100034101,"comment_content":"宫老师，请教两个问题，C++部分，playscript-cpp这个目录下，<br>（1）antlr4.7.2-runtime 这个目录包含antlr4.7.2的源码吗，还是只是包含由antlr生成的parser等程序编译所需要的文件？antlr4.7.2这个工具有没有C++的实现源码？<br>（2）lib目录中放的a文件和dylib文件是干嘛的呢？","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469291,"discussion_content":"这里的代码我还没整理整齐。在后端部分的课程放出时，我会整理好。先简单的说一下：\nAntlr本身是Java写的，但它可以生成其他语言的编译工具。这些编译工具呢，要调用一些基础的功能，这些功能就是针对不同语言的运行时（runtime）。\n用C++编程时，需要用到头文件，然后用到它的库。a文件和dylib就是库。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570703873,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137183,"user_name":"David","can_delete":false,"product_type":"c1","uid":1586094,"ip_address":"","ucode":"2AF5A315AB03C9","user_header":"https://static001.geekbang.org/account/avatar/00/18/33/ae/436e3a56.jpg","comment_is_top":false,"comment_ctime":1569641529,"is_pvip":false,"replies":[{"id":"53923","content":"在第21讲，里面提了内存布局的设计问题，一般会分为代码区、静态数据区、栈区、堆区。<br>如果只是function和class的定义，应该放在代码区才对。<br>在运行某个函数的时候，运行期动态生成的临时数据，才会放入栈里。<br>但每种语言在这方面的设计有它自己很大的灵活性。比如静态编译的语言和解释型语言的机制就很不一致。<br>08讲的栈，还是比较概念化的，简单的模拟了一个栈。21、22、23三讲，有一个符合标准的调用约定的栈的实现，也就是说跟C语言的实现是一致的，甚至可以跟C语言生成的二进制目标文件链接到一起。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1570713813,"ip_address":"","comment_id":137183,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569641529","product_id":100034101,"comment_content":"老师你好，javascript文件中定义一个function或者一个class，这个function也是放入全局作用域的栈帧中的吗？这些class在运行器中是放在栈帧中的吗？","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468976,"discussion_content":"在第21讲，里面提了内存布局的设计问题，一般会分为代码区、静态数据区、栈区、堆区。\n如果只是function和class的定义，应该放在代码区才对。\n在运行某个函数的时候，运行期动态生成的临时数据，才会放入栈里。\n但每种语言在这方面的设计有它自己很大的灵活性。比如静态编译的语言和解释型语言的机制就很不一致。\n08讲的栈，还是比较概念化的，简单的模拟了一个栈。21、22、23三讲，有一个符合标准的调用约定的栈的实现，也就是说跟C语言的实现是一致的，甚至可以跟C语言生成的二进制目标文件链接到一起。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570713813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135756,"user_name":"赖阿甘","can_delete":false,"product_type":"c1","uid":1351988,"ip_address":"","ucode":"77493FE85CBAF8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTICBNZjA9hW65x6g9b2iaicKUJW5gxFxtgPXH9Cqp6eyFfY1sD2hVY4dZrY5pmoK2r1KZEiaaIKocdZQ/132","comment_is_top":false,"comment_ctime":1569253577,"is_pvip":false,"replies":[{"id":"52071","content":"是用来支持数组的。我们并没有实现数组特性，但语法上留在那了。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1569294715,"ip_address":"","comment_id":135756,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569253577","product_id":100034101,"comment_content":"&#47;&#47; 函数声明<br>functionDeclaration<br>    : typeTypeOrVoid? IDENTIFIER formalParameters (&#39;[&#39; &#39;]&#39;)*    &#47;&#47;函数参数后面的方括号是做什么用的<br>      functionBody<br>    ;<br>老师请问函数参数后面的方括号是做什么用的","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468327,"discussion_content":"是用来支持数组的。我们并没有实现数组特性，但语法上留在那了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569294715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134586,"user_name":"曾经瘦过","can_delete":false,"product_type":"c1","uid":1240106,"ip_address":"","ucode":"57C32575A1C1FD","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/2a/b11d5ad8.jpg","comment_is_top":false,"comment_ctime":1568873569,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568873569","product_id":100034101,"comment_content":"基本看懂了  在巩固一下 跑跑代码 感觉越来越深入了  大概能明白为啥学好编译原理可以更好更快的学其他语言","like_count":1},{"had_liked":false,"id":130043,"user_name":"沉淀的梦想","can_delete":false,"product_type":"c1","uid":1177315,"ip_address":"","ucode":"BCB7C26F9D214B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg","comment_is_top":false,"comment_ctime":1567362336,"is_pvip":false,"replies":[{"id":"48563","content":"1.是运行双引号内部的部分，不是连String script= 也带上。<br>2.是使用playscript-java这个工程吗？别用错了工程。<br>如果还有问题，继续给我提问！<br>希望不影响你继续动手实践的热情！","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1567405940,"ip_address":"","comment_id":130043,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1567362336","product_id":100034101,"comment_content":"用PlayScript的代码运行课程中的示例时会报一个空指针异常<br>String script = &quot;int age = 44; for(int i = 0;i&lt;10;i++) { age = age + 2;} int i = 8;&quot;;<br><br>Exception in thread &quot;main&quot; java.lang.NullPointerException<br>\tat play.ASTEvaluator.visitStatement(ASTEvaluator.java:617)<br>\tat play.ASTEvaluator.visitBlockStatement(ASTEvaluator.java:363)<br>\tat play.ASTEvaluator.visitBlockStatements(ASTEvaluator.java:723)<br>\tat play.ASTEvaluator.visitProg(ASTEvaluator.java:733)<br>\tat play.PlayScriptParser$ProgContext.accept(PlayScriptParser.java:2031)<br>\tat org.antlr.v4.runtime.tree.AbstractParseTreeVisitor.visit(AbstractParseTreeVisitor.java:18)<br>\tat play.PlayScriptCompiler.Execute(PlayScriptCompiler.java:28)<br>\tat play.PlayScript.main(PlayScript.java:98)","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465777,"discussion_content":"1.是运行双引号内部的部分，不是连String script= 也带上。\n2.是使用playscript-java这个工程吗？别用错了工程。\n如果还有问题，继续给我提问！\n希望不影响你继续动手实践的热情！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567405940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1177315,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg","nickname":"沉淀的梦想","note":"","ucode":"BCB7C26F9D214B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7159,"discussion_content":"我运行的是旧版本的代码才出现的这个问题，把老师最新的代码拉下来就好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567408141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129564,"user_name":"李懂","can_delete":false,"product_type":"c1","uid":1330436,"ip_address":"","ucode":"539E6639042C88","user_header":"https://static001.geekbang.org/account/avatar/00/14/4d/04/5e0d3713.jpg","comment_is_top":false,"comment_ctime":1567154850,"is_pvip":false,"replies":[{"id":"48575","content":"这个栈桢还是拿java模拟的，让大家有个概念。到学后端的时候，那里有更物理的栈桢实现。到时候你可以进一步加深一下认识:-D","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1567409533,"ip_address":"","comment_id":129564,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567154850","product_id":100034101,"comment_content":"原来栈里放的栈贞，栈贞是Scope,类似执行上下文，里面保存了变量！以前一直以为进栈，是放的执行函数体，跟上脚步！","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465542,"discussion_content":"这个栈桢还是拿java模拟的，让大家有个概念。到学后端的时候，那里有更物理的栈桢实现。到时候你可以进一步加深一下认识:-D","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567409533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}