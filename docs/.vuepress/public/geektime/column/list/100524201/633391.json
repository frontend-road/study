{"id":633391,"title":"06｜循环链表：如何更方便地寻找数据？","content":"<p>你好，我是王健伟。</p><p>今天我要和你分享的主题是“循环链表”。循环链表可以分为单<span class=\"reference\">（单向）</span>循环链表和双<span class=\"reference\">（双向）</span>循环链表，只需要在原有单链表或者双链表基础之上做一些比较小的改动即可。</p><p>那么，为什么一定要在单链表或者双链表基础上引入循环链表呢？接下来，我们就从它们面临的主要问题出发，分别探讨单循环链表以及双循环链表的相关内容。</p><h1>单循环链表</h1><p>这里我们把单循环链表分为两种情况来讨论，第一种情况是传统的单循环链表，第二种情况是改进的单循环链表。它们有什么不同呢？</p><h2>传统单循环链表</h2><p>我们说过，单链表的每个节点只有一个后继指针，用于指向后继节点，而最后一个节点的后继指针指向nullptr<span class=\"reference\">（空）</span>，想一想，这会有什么不足呢？</p><p>没错，如果我们想找某个节点的前趋节点，除非拿到头节点的指针，否则是找不到的。</p><p>那么为了解决这个问题，我们就可以引入<strong>单循环链表</strong>了，它也被称为<strong>循环单链表</strong>。单循环链表，是在单链表的基础上，将链表中最后一个节点的后继指针由指向nullptr修改为指向头节点，从而整个单链表就构成了一个头尾相接的环，这种单链表称为单循环链表。</p><p>单循环链表的引入，实现了给定任意一个节点，都可以访问到链表中的所有节点，也就是遍历整个链表的可能。这样，我们就可以从遍历中找到指定节点的前趋节点了。</p><!-- [[[read_end]]] --><p>为了让实现的代码更简单，我们还是在链表中引入头节点，在单循环链表为空的时候，头节点的后继指针就是指向自身的，如图1所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/6c/51/6cc6800c2cf88394d91d3d2e1c916251.jpg?wh=1920x235\" alt=\"图片\" title=\"图1&nbsp; 空单循环链表头节点的后继指针指向自身\"></p><p>当单循环链表不为空时，最后一个节点的后继指针，就会指向头节点，如图2所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/9f/d4/9f26367131581cd2e05298de5e2861d4.jpg?wh=1920x211\" alt=\"图片\" title=\"图2&nbsp; 非空单循环链表最后一个节点的后继指针指向头节点\"></p><p>单循环链表的完整实现代码你可以<a href=\"https://gitee.com/jianw_wang/geektime_cpp_dsa/blob/master/08%EF%BD%9C%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B9%E4%BE%BF%E7%9A%84%E5%AF%BB%E6%89%BE%E6%95%B0%E6%8D%AE%EF%BC%9F/%EF%BC%881%EF%BC%89%E5%8D%95%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/MyProject.cpp\">参考课件</a>，下面的讲解里，我们就只列出核心代码。</p><p>先说<strong>初始化</strong>的问题。在通过构造函数对单循环链表进行初始化的时候，不要忘记把头节点的next指针指向自己， CirLinkList类构造函数内的代码类似下面的示例。</p><pre><code class=\"language-plain\">m_head = new Node&lt;T&gt;;\nm_head-&gt;next = m_head;\nm_length = 0;\n</code></pre><p>这里需要你思考一个问题，对比之前单循环列表为空和不为空的示意图，想一想，我们如果想要判断一个单循环链表是否为空的成员函数Empty，应该怎么去编写代码呢？</p><p>没错，只需要判断头节点的next指针是否指向头节点自身即可。</p><pre><code class=\"language-plain\">if (m_head-&gt;next == m_head) //单循环链表为空\n{\n\treturn true;\n}\nreturn false;\n</code></pre><p>另外，输出单循环链表中的所有元素的DispList成员函数中，相关的while循环条件也要从判断p是否为nullptr修改为“判断p是否指向头节点”。</p><pre><code class=\"language-plain\">Node&lt;T&gt;* p = m_head-&gt;next;\nwhile (p != m_head)\n{\n\tcout &lt;&lt; p-&gt;data &lt;&lt; \" \";&nbsp;\n\tp = p-&gt;next;\n}\ncout &lt;&lt; endl;&nbsp;\n</code></pre><p>我们还可以再从上面的代码延伸想象一下，对于一个非空的单循环链表，若判断某个数据节点是否是链表中最后一个节点，则只需要判断该节点的next指针是否指向头节点即可。</p><p>至于<strong>节点的插入和删除操作</strong>，只要注意维护好最后一个节点的后继指针指向，保证其永远指向头节点就可以。幸运的是，前述单链表中在某个位置插入指定元素以及删除某个位置元素的方法ListInsert和ListDelete的代码，完全不需要修改，就可以在单循环链表中使用。</p><p>最后，在析构函数中对单循环链表进行<strong>资源释放</strong>时，也要注意while判断条件，从原有的while (pnode != nullptr)修改为while (pnode != m_head)即可。</p><h2>改进的单循环链表</h2><p>所谓改进的单循环链表，指的是把链表的<strong>头指针</strong>修改为<strong>尾指针</strong>。</p><p>在当前的单循环链表中，如果不再使用m_head头指针来指向头节点，而是引入一个被称为尾指针的m_tail来指向最后一个节点<span class=\"reference\">（尾节点）</span>，那么m_tail-&gt;next就会正好指向头节点。当然，当链表为空时，尾指针指向的其实也是头节点。也就是如图3所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/2c/73/2c302ef16dca43d1116d7ab560488373.jpg?wh=1920x209\" alt=\"图片\" title=\"图3&nbsp; 取消头指针m_head，引入尾指针m_tail指向尾节点\"></p><p>可以看到，通过引入尾指针可以立即找到头节点（m_tail-&gt;next）。这样一来，一方面，对于在链表头部分进行插入或者删除操作，时间复杂度就会是O(1)。另一方面，在链表的尾部进行插入或者删除操作等，也就不再需要从前向后遍历各个节点，时间复杂度也将会变成O(1)。</p><p>总结下来，如果需要频繁地在链表头或者链表尾进行数据操作的话，可以考虑引入m_tail表尾指针，这样操作的效率就会更高。</p><p>不仅如此，引入尾指针的另外一个好处是可以迅速地将两个单循环链表连接起来形成一个更大的单循环链表。</p><p>假设现在，有单循环链表1和单循环链表2：</p><p><img src=\"https://static001.geekbang.org/resource/image/ab/11/ab4c522245ea36468bf7113f2e945d11.jpg?wh=1920x485\" alt=\"图片\" title=\"图4&nbsp; 单循环链表1和单循环链表2\"></p><p>如果把上面的两个单循环链表连接起来，那可能就会是这样的一个情形了：</p><p><img src=\"https://static001.geekbang.org/resource/image/e8/9b/e83d4a402e24bd823f385e3a1fdb609b.jpg?wh=1920x356\" alt=\"图片\" title=\"图5&nbsp; 将两个单循环链表连接起来形成一个新的单循环链表\"></p><p>那么如何实现图5的代码呢？这里我通过一些伪代码来实现，你可以尝试着参考这些伪代码理解思路，之后自己动手，写出实际的代码。</p><pre><code class=\"language-plain\">p1head = m_tail1-&gt;next; //先把单循环链表1的头节点暂存起来。\n①m_tail1-&gt;next = m_tail2-&gt;next-&gt;next; //让单循环链表1的尾节点指向单循环链表2的头节点之后的节点（第一个数据节点，也就是a11）。\np2head = m_tail2-&gt;next; //再把单循环链表2的头节点暂存起来。\n②m_tail2-&gt;next = p1head; //让单循环链表2的尾节点的next域指向单循环链表1的头节点。\n③//其他处理代码略：包括重新设置单循环链表2的长度、让单循环链表2的头指针的next域指向自己等。而对于单循环链表2头节点的释放，其实是在CirLinkList类的析构函数中进行的。\n</code></pre><p>当然，引入尾指针也增加了书写代码的难度，尤其要注意当删除链表尾部节点或者向链表尾部增加新节点时，尾指针也要进行相应的改变。</p><h1>双循环链表</h1><p>我们再说<strong>双循环链表</strong>，它也被称为<strong>循环双链表</strong>。</p><p>先来复习一下双链表的结构：</p><p><img src=\"https://static001.geekbang.org/resource/image/c4/1d/c4165617cdede30cyy80065eee4a5a1d.jpg?wh=1719x202\" alt=\"图片\"></p><p>虽然双链表可以很方便地找到某个节点前后的所有节点，但寻找效率却不一定高。比如已经拿到了双链表中最后一个节点的指针，那我们要如何快速寻找第1个节点呢？<strong>双循环链表</strong>可以很好的解决这个问题。</p><p>在双链表的基础上，我们将链表中最后一个节点的后继指针由指向nullptr修改为指向头节点，将链表头节点的前趋指针由指向nullptr修改为指向最后一个节点，也就构成了双循环链表。</p><p>为了让实现代码简单，依旧在链表中引入头节点。当双循环链表为空时，头节点的前趋指针和后继指针都指向自身，如图6所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/90/3a/90427d17cb9eb4be23ac409265a6c83a.jpg?wh=1920x221\" alt=\"图片\" title=\"图6&nbsp; 空双循环链表头节点的后继和前趋指针都指向自身\"></p><p>当双循环链表不为空时，最后一个节点的后继指针指向头节点，头节点的前趋指针指向最后一个节点，如图7所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/0f/a2/0f6292a7d6babc067a619a23c33588a2.jpg?wh=1920x245\" alt=\"图片\" title=\"图7&nbsp;带头节点的双循环链表数据存储描述图\"></p><p>从图7可以看到，双循环链表的所有后继指针形成了一个环，所有前趋指针也形成了一个环<span class=\"reference\">（一共两个环）</span>。这样的话，给定一个数据节点，无论访问链表的后继节点还是前趋节点，都非常灵活和方便。</p><p>理解之后，我们说代码的编写。在通过构造函数对双循环链表进行<strong>初始化</strong>时，不要忘记将头节点的next指针和prior指针都指向自己，下面是 DblCirLinkList 类构造函数内的代码<span class=\"reference\">（详细实现代码<a href=\"https://gitee.com/jianw_wang/geektime_cpp_dsa/blob/master/08%EF%BD%9C%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B9%E4%BE%BF%E7%9A%84%E5%AF%BB%E6%89%BE%E6%95%B0%E6%8D%AE%EF%BC%9F/%EF%BC%882%EF%BC%89%E5%8F%8C%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/MyProject.cpp\">参考课件</a>）</span>。</p><pre><code class=\"language-plain\">m_head = new DblNode&lt;T&gt;; //先创建一个头结点\nm_head-&gt;next = m_head;&nbsp;\nm_head-&gt;prior = m_head;&nbsp;\nm_length = 0;&nbsp; //头结点不计入双循环链表的长度\n</code></pre><p>显然，判断一个双循环链表是否为空的成员函数Empty，就只需要判断头节点的next指针<span class=\"reference\">（或者头节点的prior指针）</span>是否指向头节点自身即可<span class=\"reference\">（这点与单循环链表一致）</span>。</p><pre><code class=\"language-plain\">if (m_head-&gt;next == m_head) //双循环链表为空\n{\n    return true;\n}\nreturn false;\n</code></pre><p>同样，输出双循环链表中的所有元素的DispList成员函数中，相关的while循环条件也要从“判断p是否为nullptr”修改为“判断p是否指向头节点”。</p><pre><code class=\"language-plain\">DblNode&lt;T&gt;* p = m_head-&gt;next;\nwhile (p != m_head)&nbsp;\n{\n\tcout &lt;&lt; p-&gt;data &lt;&lt; \" \";&nbsp;\n\tp = p-&gt;next;\n}\ncout &lt;&lt; endl;\n</code></pre><p>有了上面的代码，我们不难想象，对于一个非空的双循环链表，如果要判断某个数据节点是否是链表中最后一个节点，那么只需要判断“该节点的next指针是否指向头节点”即可。</p><p>对于<strong>节点的插入和删除操作</strong>，要注意维护好最后一个节点的后继指针指向，保证其永远指向头节点，也要注意维护好头节点的前趋指针指向，保证其永远指向最后一个节点。和单循环链表的情况类似，前述双链表中在某个位置插入指定元素以及删除某个位置元素的方法ListInsert和ListDelete的代码完全不需要修改，即可在双循环链表中使用。</p><p>在析构函数中对双循环链表进行<strong>资源释放</strong>时，也要注意while判断条件，从原有的while (pnode != nullptr)修改为while (pnode != m_head)即可。</p><h2>小结</h2><p>这节课，我们讲解了循环链表，包含单循环链表和双循环链表。这两种链表都是为了更快速地查找链表中的数据而引入的。它们的便捷度也在逐步地提升。</p><p>不难看到，链表的实现方法非常多样且非常灵活，你只需要根据具体的应用场景来决定使用哪种类型的链表来保存数据即可，始终把握一个原则——使算法的执行效率尽可能得高。</p><p>一般来说，C++标准库中提供的容器基本上够用了。只有在不允许使用C++标准库或者对程序性能有更严苛要求的场合，才需要自己写代码来实现各种链表。</p><h2>归纳思考</h2><p>在这节课的最后，我也给你留了两道归纳思考题。</p><ol>\n<li>\n<p>请实现一个不带头节点的单循环链表。</p>\n</li>\n<li>\n<p>请实现一个不带头节点的双循环链表。</p>\n</li>\n</ol><p>欢迎你在留言区和我互动。如果你觉得有所收获，也可以把课程分享给更多的朋友一起交流学习。我们下一讲见！</p>","neighbors":{"left":{"article_title":"05｜双链表：搜索链表中节点的速度还可以更快吗？","id":632714},"right":{"article_title":"07｜静态链表：用一维数组表达的链表","id":634220}},"comments":[{"had_liked":false,"id":374594,"user_name":"阿阳","can_delete":false,"product_type":"c1","uid":1165817,"ip_address":"江苏","ucode":"20A35FB86B1C5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/c9/f9/39492855.jpg","comment_is_top":false,"comment_ctime":1684213720,"is_pvip":false,"replies":[{"id":136755,"content":"标准库中的list就是链表啦😁😁","user_name":"作者回复","user_name_real":"编辑","uid":1104356,"ctime":1684415363,"ip_address":"广东","comment_id":374594,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100524201,"comment_content":"老师好，请问能拓展一些关于“C++ 标准库中提供的容器”的知识吗？比如在这节课的链表，在标准库中的相关的知识的运用。","like_count":1,"discussions":[{"author":{"id":1104356,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d9/e4/791d0f5e.jpg","nickname":"KuangXiang","note":"","ucode":"BEEB53A49BA695","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":618665,"discussion_content":"标准库中的list就是链表啦😁😁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1684415363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370793,"user_name":"wu526","can_delete":false,"product_type":"c1","uid":1022129,"ip_address":"上海","ucode":"69282EB175B48E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/b1/f89a84d0.jpg","comment_is_top":false,"comment_ctime":1679281861,"is_pvip":false,"replies":[{"id":135301,"content":"往尾部插入一个节点，如果你用的是头指针，你尝试写段代码实现该功能（你是不是得先想办法找到尾部啊），时间复杂度是多少？如果你用的是尾指针，你同样尝试写段代码实现该功能，时间复杂度又是多少？","user_name":"作者回复","user_name_real":"编辑","uid":1104356,"ctime":1679321274,"ip_address":"广东","comment_id":370793,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100524201,"comment_content":"老师，文章中介绍的尾指针循环链表感觉怎么和头指针的循环链表一样呢？只是把 m_head 换成了 m_tail, 不是很理解，望老师解惑；","like_count":0,"discussions":[{"author":{"id":1104356,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d9/e4/791d0f5e.jpg","nickname":"KuangXiang","note":"","ucode":"BEEB53A49BA695","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609981,"discussion_content":"往尾部插入一个节点，如果你用的是头指针，你尝试写段代码实现该功能（你是不是得先想办法找到尾部啊），时间复杂度是多少？如果你用的是尾指针，你同样尝试写段代码实现该功能，时间复杂度又是多少？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679321274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":392948,"user_name":"Fang","can_delete":false,"product_type":"c1","uid":3540228,"ip_address":"上海","ucode":"6F026565387364","user_header":"https://static001.geekbang.org/account/avatar/00/36/05/04/8deca125.jpg","comment_is_top":false,"comment_ctime":1722261347,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100524201,"comment_content":"一般来说，C++ 标准库中提供的容器基本上够用了。只有在不允许使用 C++ 标准库或者对程序性能有更严苛要求的场合，才需要自己写代码来实现各种链表。\n\n(⊙o⊙)… ","like_count":0},{"had_liked":false,"id":386092,"user_name":"Sam Jiang","can_delete":false,"product_type":"c1","uid":3067009,"ip_address":"上海","ucode":"C9B0173A161175","user_header":"https://static001.geekbang.org/account/avatar/00/2e/cc/81/9514a363.jpg","comment_is_top":false,"comment_ctime":1704078958,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100524201,"comment_content":"老师，在实现尾指针单循环链表的时候，感觉需要同时定义m_tail和m_head，否则头结点不能初始化。但文稿中说的是用m_tail取代m_head，不知道应该如何实现呢？","like_count":0}]}