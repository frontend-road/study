{"id":479171,"title":"35｜即学即练：如何实现一个轻量级线程池？","content":"<p>你好，我是Tony Bai。</p><p>在这一讲的开始，首先恭喜你完成了这门课核心篇语法部分的学习。这一部分的篇幅不多，主要讲解了Go的两个核心语法知识点：接口与并发原语。它们分别是耦合设计与并发设计的主要参与者，Go应用的骨架设计离不开它们。</p><p>但理论和实践毕竟是两回事，学完了基本语法，也需要实操来帮助我们落地。所以，在这核心篇的最后一讲，我依然会用一个小实战项目，帮助你学会灵活运用这部分的语法点。</p><p>不过，关于接口类型做为“关节”作用的演示，我们前面的两个小实战项目中都有一定的体现了，只是那时还没有讲到接口类型，你现在可以停下来，回顾一下<a href=\"https://time.geekbang.org/column/article/434017\">09讲</a>和<a href=\"https://time.geekbang.org/column/article/471138\">27讲</a>的代码，看看是否有更深刻的体会。</p><p>而且，接口类型对Go应用静态骨架的编织作用，在接口类型数量较多的项目中体现得更明显，由于篇幅有限，我很难找到一个合适的演示项目。</p><p>因此，这一讲的实战项目，我们主要围绕Go并发来做，实现一个轻量级线程池，也就是Goroutine池。</p><h2>为什么要用到Goroutine池？</h2><p>在<a href=\"https://time.geekbang.org/column/article/475959\">第31讲</a>学习Goroutine的时候，我们就说过：相对于操作系统线程，Goroutine的开销十分小，一个Goroutine的起始栈大小为2KB，而且创建、切换与销毁的代价很低，我们可以创建成千上万甚至更多Goroutine。</p><!-- [[[read_end]]] --><p>所以和其他语言不同的是，Go应用通常可以为每个新建立的连接创建一个对应的新Goroutine，甚至是为每个传入的请求生成一个Goroutine去处理。这种设计还有一个好处，实现起来十分简单，Gopher们在编写代码时也没有很高的心智负担。</p><p><strong>不过，Goroutine的开销虽然“廉价”，但也不是免费的</strong>。</p><p>最明显的，一旦规模化后，这种非零成本也会成为瓶颈。我们以一个Goroutine分配2KB执行栈为例，100w Goroutine就是2GB的内存消耗。</p><p>其次，Goroutine从<a href=\"https://go.dev/doc/go1.4\">Go 1.4版本</a>开始采用了连续栈的方案，也就是每个Goroutine的执行栈都是一块连续内存，如果空间不足，运行时会分配一个更大的连续内存空间作为这个Goroutine的执行栈，将原栈内容拷贝到新分配的空间中来。</p><p>连续栈的方案，虽然能避免Go 1.3采用的分段栈会导致的<a href=\"https://docs.google.com/document/d/1wAaf1rYoM4S4gtnPh0zOlGzWtrZFQ5suE8qr2sD8uWQ/pub\">“hot split”问题</a>，但连续栈的原理也决定了，一旦Goroutine的执行栈发生了grow，那么即便这个Goroutine不再需要那么大的栈空间，这个Goroutine的栈空间也不会被Shrink（收缩）了，这些空间可能会处于长时间闲置的状态，直到Goroutine退出。</p><p>另外，随着Goroutine数量的增加，Go运行时进行Goroutine调度的处理器消耗，也会随之增加，成为阻碍Go应用性能提升的重要因素。</p><p>那么面对这样的问题，常见的应对方式是什么呢？</p><p>Goroutine池就是一种常见的解决方案。这个方案的核心思想是对Goroutine的重用，也就是把M个计算任务调度到N个Goroutine上，而不是为每个计算任务分配一个独享的Goroutine，从而提高计算资源的利用率。</p><p>接下来，我们就来真正实现一个简单的Goroutine池，我们叫它 <strong>workerpool</strong>。</p><h2>workerpool的实现原理</h2><p>workerpool的工作逻辑通常都很简单，所以即便是用于生产环境的workerpool实现，代码规模也都在千行左右。</p><p>当然，workerpool有很多种实现方式，这里为了更好地演示Go并发模型的应用模式，以及并发原语间的协作，我们采用完全基于channel+select的实现方案，不使用其他数据结构，也不使用sync包提供的各种同步结构，比如Mutex、RWMutex，以及Cond等。</p><p>workerpool的实现主要分为三个部分：</p><ul>\n<li>pool的创建与销毁；</li>\n<li>pool中worker（Goroutine）的管理；</li>\n<li>task的提交与调度。</li>\n</ul><p>其中，后两部分是pool的“精髓”所在，这两部分的原理我也用一张图表示了出来：</p><p><img src=\"https://static001.geekbang.org/resource/image/d4/fd/d48ba3a204ca6e8961a4425573afa0fd.jpg?wh=1920x1047\" alt=\"图片\"></p><p>我们先看一下图中pool对worker的管理。</p><p>capacity是pool的一个属性，代表整个pool中worker的最大容量。我们使用一个带缓冲的channel：active，作为worker的“计数器”，这种channel使用模式就是我们在第33讲中讲过的<strong>计数信号量</strong>，如果记不太清了可以复习一下<a href=\"https://time.geekbang.org/column/article/477365\">第33讲</a>中的相关内容。</p><p>当active channel可写时，我们就创建一个worker，用于处理用户通过Schedule函数提交的待处理的请求。当active channel满了的时候，pool就会停止worker的创建，直到某个worker因故退出，active channel又空出一个位置时，pool才会创建新的worker填补那个空位。</p><p>这张图里，我们把用户要提交给workerpool执行的请求抽象为一个Task。Task的提交与调度也很简单：Task通过Schedule函数提交到一个task channel中，已经创建的worker将从这个task channel中读取task并执行。</p><p>好了！“Talk is cheap，show me the code”！接下来，我们就来写一版workerpool的代码，来验证一下这里分析的原理是否可行。</p><h2>workerpool的一个最小可行实现</h2><p>我们先建立workerpool目录作为实战项目的源码根目录，然后为这个项目创建go module：</p><pre><code class=\"language-plain\">$mkdir workerpool1\n$cd workerpool1\n$go mod init github.com/bigwhite/workerpool\n</code></pre><p>接下来，我们创建pool.go作为workpool包的主要源码文件。在这个源码文件中，我们定义了Pool结构体类型，这个类型的实例代表一个workerpool：</p><pre><code class=\"language-plain\">type Pool struct {\n    capacity int         // workerpool大小\n\n    active chan struct{} // 对应上图中的active channel\n    tasks  chan Task     // 对应上图中的task channel\n\n    wg   sync.WaitGroup  // 用于在pool销毁时等待所有worker退出\n    quit chan struct{}   // 用于通知各个worker退出的信号channel\n}\n</code></pre><p>workerpool包对外主要提供三个API，它们分别是：</p><ul>\n<li>workerpool.New：用于创建一个pool类型实例，并将pool池的worker管理机制运行起来；</li>\n<li>workerpool.Free：用于销毁一个pool池，停掉所有pool池中的worker；</li>\n<li>Pool.Schedule：这是Pool类型的一个导出方法，workerpool包的用户通过该方法向pool池提交待执行的任务（Task）。</li>\n</ul><p>接下来我们就重点看看这三个API的实现。</p><p>我们先来看看workerpool.New是如何创建一个pool实例的：</p><pre><code class=\"language-plain\">func New(capacity int) *Pool {\n    if capacity &lt;= 0 {\n        capacity = defaultCapacity\n    }\n    if capacity &gt; maxCapacity { \n        capacity = maxCapacity\n    } \n\n    p := &amp;Pool{\n        capacity: capacity,\n        tasks:    make(chan Task),\n        quit:     make(chan struct{}),\n        active:   make(chan struct{}, capacity),\n    }\n\n    fmt.Printf(\"workerpool start\\n\")\n\n    go p.run()\n\n    return p\n}\n</code></pre><p>我们看到，New函数接受一个参数capacity用于指定workerpool池的容量，这个参数用于控制workerpool最多只能有capacity个worker，共同处理用户提交的任务请求。函数开始处有一个对capacity参数的“防御性”校验，当用户传入不合理的值时，函数New会将它纠正为合理的值。</p><p>Pool类型实例变量p完成初始化后，我们创建了一个新的Goroutine，用于对workerpool进行管理，这个Goroutine执行的是Pool类型的run方法：</p><pre><code class=\"language-plain\">func (p *Pool) run() { \n    idx := 0 \n\n    for { \n        select { \n        case &lt;-p.quit:\n            return\n        case p.active &lt;- struct{}{}:\n            // create a new worker\n            idx++\n            p.newWorker(idx)\n        } \n    } \n}\n</code></pre><p>run方法内是一个无限循环，循环体中使用select监视Pool类型实例的两个channel：quit和active。这种在for中使用select监视多个channel的实现，在Go代码中十分常见，是一种惯用法。</p><p>当接收到来自quit channel的退出“信号”时，这个Goroutine就会结束运行。而当active channel可写时，run方法就会创建一个新的worker Goroutine。 此外，为了方便在程序中区分各个worker输出的日志，我这里将一个从1开始的变量idx作为worker的编号，并把它以参数的形式传给创建worker的方法。</p><p>我们再将创建新的worker goroutine的职责，封装到一个名为newWorker的方法中：</p><pre><code class=\"language-plain\">func (p *Pool) newWorker(i int) {\n    p.wg.Add(1)\n    go func() {\n        defer func() {\n            if err := recover(); err != nil {\n                fmt.Printf(\"worker[%03d]: recover panic[%s] and exit\\n\", i, err)\n                &lt;-p.active\n            }\n            p.wg.Done()\n        }()\n\n        fmt.Printf(\"worker[%03d]: start\\n\", i)\n\n        for {\n            select {\n            case &lt;-p.quit:\n                fmt.Printf(\"worker[%03d]: exit\\n\", i)\n                &lt;-p.active\n                return\n            case t := &lt;-p.tasks:\n                fmt.Printf(\"worker[%03d]: receive a task\\n\", i)\n                t()\n            }\n        }\n    }()\n}\n</code></pre><p>我们看到，在创建一个新的worker goroutine之前，newWorker方法会先调用p.wg.Add方法将WaitGroup的等待计数加一。由于每个worker运行于一个独立的Goroutine中，newWorker方法通过go关键字创建了一个新的Goroutine作为worker。</p><p>新worker的核心，依然是一个基于for-select模式的循环语句，在循环体中，新worker通过select监视quit和tasks两个channel。和前面的run方法一样，当接收到来自quit channel的退出“信号”时，这个worker就会结束运行。tasks channel中放置的是用户通过Schedule方法提交的请求，新worker会从这个channel中获取最新的Task并运行这个Task。</p><p>Task是一个对用户提交的请求的抽象，它的本质就是一个函数类型：</p><pre><code class=\"language-plain\">type Task func()\n</code></pre><p>这样，用户通过Schedule方法实际上提交的是一个函数类型的实例。</p><p>在新worker中，为了防止用户提交的task抛出panic，进而导致整个workerpool受到影响，我们在worker代码的开始处，使用了defer+recover对panic进行捕捉，捕捉后worker也是要退出的，于是我们还通过<code>&lt;-p.active</code>更新了worker计数器。并且一旦worker goroutine退出，p.wg.Done也需要被调用，这样可以减少WaitGroup的Goroutine等待数量。</p><p>我们再来看workerpool提供给用户提交请求的导出方法Schedule：</p><pre><code class=\"language-plain\">var ErrWorkerPoolFreed    = errors.New(\"workerpool freed\")       // workerpool已终止运行\n\nfunc (p *Pool) Schedule(t Task) error {\n    select {\n    case &lt;-p.quit:\n        return ErrWorkerPoolFreed\n    case p.tasks &lt;- t:\n        return nil\n    }\n}\n</code></pre><p>Schedule方法的核心逻辑，是将传入的Task实例发送到workerpool的tasks channel中。但考虑到现在workerpool已经被销毁的状态，我们这里通过一个select，检视quit channel是否有“信号”可读，如果有，就返回一个哨兵错误ErrWorkerPoolFreed。如果没有，一旦p.tasks可写，提交的Task就会被写入tasks channel，以供pool中的worker处理。</p><p>这里要注意的是，这里的Pool结构体中的tasks是一个无缓冲的channel，如果pool中worker数量已达上限，而且worker都在处理task的状态，那么Schedule方法就会阻塞，直到有worker变为idle状态来读取tasks channel，schedule的调用阻塞才会解除。</p><p>至此，workerpool的最小可行实现的主要逻辑都实现完了。我们来验证一下它是否能按照我们的预期逻辑运行。</p><p>现在我们建立一个使用workerpool的项目demo1：</p><pre><code class=\"language-plain\">$mkdir demo1\n$cd demo1\n$go mod init demo1\n</code></pre><p>由于我们要引用本地的module，所以我们需要手工修改一下demo1的go.mod文件，并利用replace指示符将demo1对workerpool的引用指向本地workerpool1路径：</p><pre><code class=\"language-plain\">module demo1\n\ngo 1.17\n\nrequire github.com/bigwhite/workerpool v1.0.0\n\nreplace github.com/bigwhite/workerpool v1.0.0 =&gt; ../workerpool1\n</code></pre><p>然后创建demo1的main.go文件，源码如下：</p><pre><code class=\"language-plain\">package main\n  \nimport (\n    \"time\"\n    \"github.com/bigwhite/workerpool\"\n)\n\nfunc main() {\n    p := workerpool.New(5)\n\n    for i := 0; i &lt; 10; i++ {\n        err := p.Schedule(func() {\n            time.Sleep(time.Second * 3)\n        })\n        if err != nil {\n            println(\"task: \", i, \"err:\", err)\n        }\n    }\n\n    p.Free()\n}\n</code></pre><p>这个示例程序创建了一个capacity为5的workerpool实例，并连续向这个workerpool提交了10个task，每个task的逻辑很简单，只是Sleep 3秒后就退出。main函数在提交完任务后，调用workerpool的Free方法销毁pool，pool会等待所有worker执行完task后再退出。</p><p>demo1示例的运行结果如下：</p><pre><code class=\"language-plain\">workerpool start\nworker[005]: start\nworker[005]: receive a task\nworker[003]: start\nworker[003]: receive a task\nworker[004]: start\nworker[004]: receive a task\nworker[001]: start\nworker[002]: start\nworker[001]: receive a task\nworker[002]: receive a task\nworker[004]: receive a task\nworker[005]: receive a task\nworker[003]: receive a task\nworker[002]: receive a task\nworker[001]: receive a task\nworker[001]: exit\nworker[005]: exit\nworker[002]: exit\nworker[003]: exit\nworker[004]: exit\nworkerpool freed\n</code></pre><p>从运行的输出结果来看，workerpool的最小可行实现的运行逻辑与我们的原理图是一致的。</p><p>不过，目前的workerpool实现好比“铁板一块”，虽然我们可以通过capacity参数可以指定workerpool容量，但我们无法对workerpool的行为进行定制。</p><p>比如当workerpool中的worker数量已达上限，而且worker都在处理task时，用户调用Schedule方法将阻塞，如果用户不想阻塞在这里，以我们目前的实现是做不到的。</p><p>那我们可以怎么改进呢？我们可以尝试在上面实现的基础上，为workerpool添加功能选项（functional option）机制。</p><h2>添加功能选项机制</h2><p>功能选项机制，可以让某个包的用户可以根据自己的需求，通过设置不同功能选项来定制包的行为。Go语言中实现功能选项机制有多种方法，但Go社区目前使用最为广泛的一个方案，是Go语言之父Rob Pike在2014年在博文<a href=\"https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html\">《自引用函数与选项设计》</a>中论述的一种，这种方案也被后人称为“功能选项（functional option）”方案。</p><p>接下来，我们就来看看如何使用Rob Pike的这种“功能选项”方案，让workerpool支持行为定制机制。</p><p>首先，我们将workerpool1目录拷贝一份形成workerpool2目录，我们将在这个目录下为workerpool包添加功能选项机制。</p><p>然后，我们在workerpool2目录下创建option.go文件，在这个文件中，我们定义用于代表功能选项的类型Option：</p><pre><code class=\"language-plain\">type Option func(*Pool)\n</code></pre><p>我们看到，这个Option实质是一个接受*Pool类型参数的函数类型。那么如何运用这个Option类型呢？别急，马上你就会知道。现在我们先要做的是，明确给workerpool添加什么功能选项。这里我们为workerpool添加两个功能选项：Schedule调用是否阻塞，以及是否预创建所有的worker。</p><p>为了支持这两个功能选项，我们需要在Pool类型中增加两个bool类型的字段，字段的具体含义，我也在代码中注释了：</p><pre><code class=\"language-plain\">type Pool struct {\n    ... ...\n    preAlloc bool // 是否在创建pool的时候就预创建workers，默认值为：false\n\n    // 当pool满的情况下，新的Schedule调用是否阻塞当前goroutine。默认值：true\n    // 如果block = false，则Schedule返回ErrNoWorkerAvailInPool\n    block  bool\n    ... ...\n}\n</code></pre><p>针对这两个字段，我们在option.go中添加两个功能选项，WithBlock与WithPreAllocWorkers：</p><pre><code class=\"language-plain\">func WithBlock(block bool) Option {\n    return func(p *Pool) {\n        p.block = block\n    }\n}\n\nfunc WithPreAllocWorkers(preAlloc bool) Option {\n    return func(p *Pool) {\n        p.preAlloc = preAlloc\n    }\n}\n</code></pre><p>我们看到，这两个功能选项实质上是两个返回闭包函数的函数。</p><p>为了支持将这两个Option传给workerpool，我们还需要改造一下workerpool包的New函数，改造后的New函数代码如下：</p><pre><code class=\"language-plain\">func New(capacity int, opts ...Option) *Pool {\n    ... ...\n    for _, opt := range opts {\n        opt(p)\n    }\n\n    fmt.Printf(\"workerpool start(preAlloc=%t)\\n\", p.preAlloc)\n\n    if p.preAlloc {\n        // create all goroutines and send into works channel\n        for i := 0; i &lt; p.capacity; i++ {\n            p.newWorker(i + 1)\n            p.active &lt;- struct{}{}\n        }\n    }\n\n    go p.run()\n\n    return p\n}\n</code></pre><p>新版New函数除了接受capacity参数之外，还在它的参数列表中增加了一个类型为Option的可变长参数opts。在New函数体中，我们通过一个for循环，将传入的Option运用到Pool类型的实例上。</p><p>新版New函数还会根据preAlloc的值来判断是否预创建所有的worker，如果需要，就调用newWorker方法把所有worker都创建出来。newWorker的实现与上一版代码并没有什么差异，这里就不再详说了。</p><p>但由于preAlloc选项的加入，Pool的run方法的实现有了变化，我们来看一下：</p><pre><code class=\"language-plain\"> func (p *Pool) run() {\n     idx := len(p.active)\n \n     if !p.preAlloc {\n     loop:\n         for t := range p.tasks {\n             p.returnTask(t)\n             select {\n             case &lt;-p.quit:\n                 return\n             case p.active &lt;- struct{}{}:\n                 idx++\n                 p.newWorker(idx)\n             default:\n                 break loop\n             }\n         }\n     }\n \n     for {\n         select {\n         case &lt;-p.quit:\n             return\n         case p.active &lt;- struct{}{}:\n             // create a new worker\n             idx++\n             p.newWorker(idx)\n         }\n     }\n }\n</code></pre><p>新版run方法在preAlloc=false时，会根据tasks channel的情况在适合的时候创建worker（第4行~第18行)，直到active channel写满，才会进入到和第一版代码一样的调度逻辑中（第20行~第29行）。</p><p>而且，提供给用户的Schedule函数也因WithBlock选项，有了一些变化：</p><pre><code class=\"language-plain\"> func (p *Pool) Schedule(t Task) error {\n     select {\n     case &lt;-p.quit:\n         return ErrWorkerPoolFreed\n     case p.tasks &lt;- t:\n         return nil\n     default:\n         if p.block {\n             p.tasks &lt;- t\n             return nil\n         }\n         return ErrNoIdleWorkerInPool\n     }\n }\n</code></pre><p>Schedule在tasks chanel无法写入的情况下，进入default分支。在default分支中，Schedule根据block字段的值，决定究竟是继续阻塞在tasks channel上，还是返回ErrNoIdleWorkerInPool错误。</p><p>和第一版worker代码一样，我们也来验证一下新增的功能选项是否好用。我们建立一个使用新版workerpool的项目demo2，demo2的go.mod与demo1的go.mod相似：</p><pre><code class=\"language-plain\">module demo2\n\ngo 1.17\n\nrequire github.com/bigwhite/workerpool v1.0.0\n\nreplace github.com/bigwhite/workerpool v1.0.0 =&gt; ../workerpool2\n</code></pre><p>demo2的main.go文件如下：</p><pre><code class=\"language-plain\">package main\n  \nimport (\n    \"fmt\"\n    \"time\"\n\n    \"github.com/bigwhite/workerpool\"\n)\n\nfunc main() {\n    p := workerpool.New(5, workerpool.WithPreAllocWorkers(false), workerpool.WithBlock(false))\n\n    time.Sleep(time.Second * 2)\n    for i := 0; i &lt; 10; i++ {\n        err := p.Schedule(func() {\n            time.Sleep(time.Second * 3)\n        })\n        if err != nil {\n            fmt.Printf(\"task[%d]: error: %s\\n\", i, err.Error())\n        }\n    }\n\n    p.Free()\n}\n</code></pre><p>在demo2中，我们使用workerpool包提供的功能选项，设置了我们期望的workerpool的运作行为，包括不要预创建worker，以及不要阻塞Schedule调用。</p><p>考虑到Goroutine调度的次序的不确定性，这里我在创建workerpool与真正开始调用Schedule方法之间，做了一个Sleep，尽量减少Schedule都返回失败的频率（但这仍然无法保证这种情况不会发生）。</p><p>运行demo2，我们会得到这个结果：</p><pre><code class=\"language-plain\">workerpool start(preAlloc=false)\ntask[1]: error: no idle worker in pool\nworker[001]: start\ntask[2]: error: no idle worker in pool\ntask[4]: error: no idle worker in pool\ntask[5]: error: no idle worker in pool\ntask[6]: error: no idle worker in pool\ntask[7]: error: no idle worker in pool\ntask[8]: error: no idle worker in pool\ntask[9]: error: no idle worker in pool\nworker[001]: receive a task\nworker[002]: start\nworker[002]: exit\nworker[001]: receive a task\nworker[001]: exit\nworkerpool freed(preAlloc=false)\n</code></pre><p>不过，由于Goroutine调度的不确定性，这个结果仅仅是很多种结果的一种。我们看到，仅仅001这个worker收到了task，其余的worker都因为worker尚未创建完毕，而返回了错误，而不是像demo1那样阻塞在Schedule调用上。</p><h2>小结</h2><p>好了，今天的课讲到这里就结束了，现在我们一起来回顾一下吧。</p><p>在这一讲中，我们基于我们前面所讲的Go并发方面的内容，设计并实现了一个workerpool的最小可行实现，只用了不到200行代码。为了帮助你理解Go并发原语是如何运用的，这个workerpool实现完全基于channel+select，并没有使用到sync包提供的各种锁。</p><p>我们还基于workerpool的最小可行实现，为这个pool增加了功能选项的支持，我们采用的功能选项方案也是Go社区最为流行的方案，日常编码中如果你遇到了类似的需求可以重点参考。</p><p>最后我要提醒你：上面设计与实现的workerpool只是一个演示项目，不能作为生产项目使用。</p><h2>思考题</h2><p>关于workerpool这样的项目，如果让你来设计，你的设计思路是什么，不妨在留言区敞开谈谈？</p><p>欢迎你把这节课分享给更多感兴趣的朋友。我是Tony Bai，我们下节课见。</p><h3><a href=\"https://github.com/bigwhite/publication/tree/master/column/timegeek/go-first-course/35\">今天的项目源码在这里！</a></h3>","comments":[{"had_liked":false,"id":338386,"user_name":"ivhong","can_delete":false,"product_type":"c1","uid":2659871,"ip_address":"","ucode":"9947B228807AC9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ8ic8eLTo5rnqIMJicUfpkVBrOUJAW4fANicKIbHdC54O9SOdwSoeK6o8icibaUbh7ZUXAkGF9zwHqo0Q/132","comment_is_top":false,"comment_ctime":1647479909,"is_pvip":false,"replies":[{"id":123699,"content":"好问题。\n\n1. 传统理解的coroutine一般是面向协作式，而非抢占式。像python中通过yield关键字创建的协程，与主routine之间是在一个线程上实现的切换执行，从设计角度是通过coroutine实现了并发(concurrency)，但其实它们还是串行执行的，不会真正并行(paralellism)，即便在多核处理器上。\n                                                                                             \n基于上面的理解，我们就可以意识到goroutine并非传统意义上的coroutine，是支持抢占的，而且也必须依赖抢占实现runtime对goroutine的调度。它更像thread，可以绑定不同的cpu核并行执行（如果是在多核处理器上的话）。同时基于goroutine的设计也会一种并发的设计。\n\n而goroutine与thread又不同，goroutine是在用户层(相较于os的内核层）调度的，os并不知道其存在，goroutine的切换相对轻量。而thread是os\n来调度的，切换代价更高一些。\n\n所以文中将goroutine称为“轻量级线程”，而不是协程。\n\n2. 你理解的没错。这节课是为了演示goroutine、channel之间的调度与通信机制而“设计”出来的。goroutine使用代价很低，通常不用考虑池化。但是在一些大型网络服务程序时，一旦goroutine数量过多，内存占用以及调度goroutine的代价就不能不考虑了。于是有了“池化”的思路。这与传统的线程池的思路的确是一脉相承的\n\n3. go是gc的，内存不会越来越大。\n","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1647495219,"ip_address":"","comment_id":338386,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"非常感谢老师带着做了一次这样的实现，因为我自己也尝试过这种实现（纯粹是为了学习用）。有几个问题我不是特别明白，不知道是不是和老师理解的一样，望老师闲暇之余给予指正，谢谢！\n1. 这个是不是叫“协程池”，为什么叫做“线程池”？两者有什么区别呢？或者是到底什么是“协程”呢？\n2. 是不是这节课的实现，也纯粹是为了学习而实现的，个人理解，go实现Goroutine，就是为了解决“线程池”的繁琐，让“并发”实现的不用那么的麻烦，如果是超小“任务”，不用考虑线程频繁切换导致系统资源的浪费。如果再实现“协程池”的话，是不是丢失了这种优点？\n3. 常驻内存的Goroutine，反复使用，会导致这个Goroutine的内存越来越大，或者其他隐藏的风险么？","like_count":14},{"had_liked":false,"id":331114,"user_name":"$侯","can_delete":false,"product_type":"c1","uid":1019939,"ip_address":"","ucode":"488B1BD3924E7E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/90/23/5c74e9b7.jpg","comment_is_top":false,"comment_ctime":1642430185,"is_pvip":false,"replies":[{"id":120983,"content":"原文中有源码的链接，在最后。\n\n源码在 https:&#47;&#47;github.com&#47;bigwhite&#47;publication&#47;tree&#47;master&#47;column&#47;timegeek&#47;go-first-course&#47;35\n\n看了后，就可以回答你的问题了。","user_name":"作者回复","user_name_real":"作者","uid":1026224,"ctime":1642475072,"ip_address":"","comment_id":331114,"utype":1}],"discussion_count":7,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"老师您好请教几个问题：\n第一个问题，demo1中没有看到p.Free的代码示例，Free方法只是向p.quit &lt;- struct{}{}发送一个空结构体就可以吗，请教下Free方式该如何写\n第二个问题，demo1中好像也没看看到p.wg.Wait()","like_count":3,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556741,"discussion_content":"好问题。\n\n1. 传统理解的coroutine一般是面向协作式，而非抢占式。像python中通过yield关键字创建的协程，与主routine之间是在一个线程上实现的切换执行，从设计角度是通过coroutine实现了并发(concurrency)，但其实它们还是串行执行的，不会真正并行(paralellism)，即便在多核处理器上。\n                                                                                             \n基于上面的理解，我们就可以意识到goroutine并非传统意义上的coroutine，是支持抢占的，而且也必须依赖抢占实现runtime对goroutine的调度。它更像thread，可以绑定不同的cpu核并行执行（如果是在多核处理器上的话）。同时基于goroutine的设计也会一种并发的设计。\n\n而goroutine与thread又不同，goroutine是在用户层(相较于os的内核层）调度的，os并不知道其存在，goroutine的切换相对轻量。而thread是os\n来调度的，切换代价更高一些。\n\n所以文中将goroutine称为“轻量级线程”，而不是协程。\n\n2. 你理解的没错。这节课是为了演示goroutine、channel之间的调度与通信机制而“设计”出来的。goroutine使用代价很低，通常不用考虑池化。但是在一些大型网络服务程序时，一旦goroutine数量过多，内存占用以及调度goroutine的代价就不能不考虑了。于是有了“池化”的思路。这与传统的线程池的思路的确是一脉相承的\n\n3. go是gc的，内存不会越来越大。\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1647495219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331112,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1642429951,"is_pvip":false,"replies":[{"id":121004,"content":"看的真细致！👍\n\n1. worker一旦创建后，除了panic和quit通知退出，worker是不会退出的，也就是没有所谓“正常退出”的情况。所以没在defer中调用&lt;-p.active。\n2. 的确是笔误,感谢指出。\n3. 在文后有源码链接。这里的task仅是触发了worker创建，这里是调度循环，不处理task，所以要把task扔回tasks channel，等worker启动后再处理。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1642488429,"ip_address":"","comment_id":331112,"utype":1}],"discussion_count":12,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"老师以下几个问题哈：\n1、第一种实现中，这块是不是有点问题：\n\ngo func() {\n    defer func() {\n        if err := recover(); err != nil {\n            fmt.Printf(&quot;worker[%03d]: recover panic[%s] and exit\\n&quot;, i, err)\n            &lt;-p.active\n        }\n        p.wg.Done()\n    }()\n\n  &lt;-p.active是不是应该要放到if的外面，如果task执行本身没有出错，正常结束了，active没有减少的地方\n\n2、这块文字描述有点问题，p&lt;-active应该是&lt;-p.active\n“使用了 defer+recover 对 panic 进行捕捉，捕捉后 worker 也是要退出的，于是我们还通过p&lt;-active更新了 worker 计数器”\n\n3、第二种实现中，当没有提前创建worker，那么当tasks中有任务的时候，p.returnTask方法是干啥的？文章中没有这个方法，且文字也没有说明呀\n\n func (p *Pool) run() {\n     idx := len(p.active)\n \n     if !p.preAlloc {\n     loop:\n         for t := range p.tasks {\n             p.returnTask(t)\n             select {\n             case &lt;-p.quit:\n                 return\n             case p.active &lt;- struct{}{}:\n                 idx++\n                 p.newWorker(idx)\n             default:\n                 break loop\n             }\n         }\n     }\n ","like_count":3,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546988,"discussion_content":"看的真细致！👍\n\n1. worker一旦创建后，除了panic和quit通知退出，worker是不会退出的，也就是没有所谓“正常退出”的情况。所以没在defer中调用&lt;-p.active。\n2. 的确是笔误,感谢指出。\n3. 在文后有源码链接。这里的task仅是触发了worker创建，这里是调度循环，不处理task，所以要把task扔回tasks channel，等worker启动后再处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642488429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":3,"child_discussions":[{"author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":547022,"discussion_content":"谢谢老师，我在看下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642498665,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546988,"ip_address":"","group_id":0},"score":547022,"extra":""},{"author":{"id":2285931,"avatar":"https://static001.geekbang.org/account/avatar/00/22/e1/6b/74a8b7d8.jpg","nickname":"Hugh","note":"","ucode":"77434E01E1D715","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":566228,"discussion_content":"&gt; 这里的task仅是触发了worker创建，这里是调度循环，不处理task，所以要把task扔回tasks channel，等worker启动后再处理。\n\n关于这一点想问一下，如果把task重新扔回channel，是不是打乱了task的执行顺序。而且newWorker和run方法里都会从task channel监听task，则意味着有的task直接会被执行，有的回到了队尾。而且极端情况下可能会反复被放回队尾，从而导致永远轮不到被执行。而且这种现象存在workpoll的整个生命周期","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650633652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546988,"ip_address":"","group_id":0},"score":566228,"extra":""},{"author":{"id":1932430,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/7c/8e/830017ff.jpg","nickname":"香榭的枫叶🍂","note":"","ucode":"6EB2522892A0DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2285931,"avatar":"https://static001.geekbang.org/account/avatar/00/22/e1/6b/74a8b7d8.jpg","nickname":"Hugh","note":"","ucode":"77434E01E1D715","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591339,"discussion_content":"task是无缓冲的channel，没有排队的问题吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666520426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":566228,"ip_address":"北京","group_id":0},"score":591339,"extra":""}]},{"author":{"id":1019939,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/23/5c74e9b7.jpg","nickname":"$侯","note":"","ucode":"488B1BD3924E7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546959,"discussion_content":"第一个问题中，除非task有问题recover了否则是不需要减少的，这5个active在quit和程序结束前是一直在的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1642479140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1019939,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/23/5c74e9b7.jpg","nickname":"$侯","note":"","ucode":"488B1BD3924E7E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547024,"discussion_content":"谢谢大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642498682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546959,"ip_address":"","group_id":0},"score":547024,"extra":""}]},{"author":{"id":1214303,"avatar":"https://static001.geekbang.org/account/avatar/00/12/87/5f/6bf8b74a.jpg","nickname":"Kepler","note":"","ucode":"0C9CA3DB8B3CF0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559889,"discussion_content":"感觉第二版的!preAlloc + !block实现，大白老师是为了给我们展示这种用法，实战应该采用preAlloc + !block的组合，而且taskChan采用缓冲方式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649043619,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546968,"discussion_content":"我自己理了下，试着帮老师回答下这些问题，希望有错帮忙指正！\n1、&lt;-p.active 不放在 if 外面，因为只有发生panic时才需要把 p.active 计数减一（此时run又会重新new一个新的worker，保持“池”中活跃 goroutine 数恒定）；\n2、你说的对；\n3、returnTask方法，与它的名字字面含义一样，作用是“归还”task给p.tasks通道，因为for-range处读取tasks的本意只是为了有多少个task就创建多少个goroutine的worker（直到数量达到capacity，再break loop退出循环执行下面的逻辑），此处并不真正执行任务，所以将它归还回去，以便另一处真正执行任务的地方能接收到任务（t := &lt;-p.tasks）。完整源码在github有：文章最后有链接。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642483301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547023,"discussion_content":"谢谢大佬指点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642498676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546968,"ip_address":"","group_id":0},"score":547023,"extra":""},{"author":{"id":1184102,"avatar":"https://static001.geekbang.org/account/avatar/00/12/11/66/ac631a36.jpg","nickname":"Geralt","note":"","ucode":"2F31ED777D06A0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547035,"discussion_content":"调用returnTask归还的task还是有可能被for range获取到的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642500842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546968,"ip_address":"","group_id":0},"score":547035,"extra":""},{"author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1184102,"avatar":"https://static001.geekbang.org/account/avatar/00/12/11/66/ac631a36.jpg","nickname":"Geralt","note":"","ucode":"2F31ED777D06A0","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":547054,"discussion_content":"是的，所以我觉得这里可以优化下。另外搞成跟java的那样，带任务启动新worker，直到达到核心线程数。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1642510138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":547035,"ip_address":"","group_id":0},"score":547054,"extra":""}]}]},{"had_liked":false,"id":372125,"user_name":"Geek_0d5d37","can_delete":false,"product_type":"c1","uid":3522132,"ip_address":"四川","ucode":"1BB4AEF1328C64","user_header":"","comment_is_top":false,"comment_ctime":1680764743,"is_pvip":false,"replies":[{"id":135834,"content":"当preAlloc=false时，即不预分配时。这样就根据tasks的情况来创建worker。如果当前没有task，实际上系统中没有worker被创建出来，直到有task才会创建worker。一直到active channel满了！这样pool中所有worker都创建出来后，再跳出循环，进入下面的quit监听。\n\n不过workpool2的这段代码的确有refactor的空间😁。可以写的更好理解一些。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1680843383,"ip_address":"北京","comment_id":372125,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"老师您好，这个段代码作用我也不太理解\nif !p.preAlloc {\n\tloop:\n\t\tfor t := range p.tasks {\n\t\t\tp.returnTask(t)\n\t\t\tselect {\n\t\t\tcase &lt;-p.quit:\n\t\t\t\treturn\n\t\t\tcase p.active &lt;- struct{}{}:\n\t\t\t\tidx++\n\t\t\t\tp.newWorker(idx)\n\t\t\tdefault:\n\t\t\t\tbreak loop\n\t\t\t}\n\t\t}\n\t}\n\n您在留言中回答 当preAlloc=false时有用 ，如果是这样demo1 就是等于fasle的情况没使用这段代码的 ，请老师有空回答一下","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546988,"discussion_content":"看的真细致！👍\n\n1. worker一旦创建后，除了panic和quit通知退出，worker是不会退出的，也就是没有所谓“正常退出”的情况。所以没在defer中调用&lt;-p.active。\n2. 的确是笔误,感谢指出。\n3. 在文后有源码链接。这里的task仅是触发了worker创建，这里是调度循环，不处理task，所以要把task扔回tasks channel，等worker启动后再处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642488429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":3,"child_discussions":[{"author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":547022,"discussion_content":"谢谢老师，我在看下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642498665,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546988,"ip_address":"","group_id":0},"score":547022,"extra":""},{"author":{"id":2285931,"avatar":"https://static001.geekbang.org/account/avatar/00/22/e1/6b/74a8b7d8.jpg","nickname":"Hugh","note":"","ucode":"77434E01E1D715","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":566228,"discussion_content":"&gt; 这里的task仅是触发了worker创建，这里是调度循环，不处理task，所以要把task扔回tasks channel，等worker启动后再处理。\n\n关于这一点想问一下，如果把task重新扔回channel，是不是打乱了task的执行顺序。而且newWorker和run方法里都会从task channel监听task，则意味着有的task直接会被执行，有的回到了队尾。而且极端情况下可能会反复被放回队尾，从而导致永远轮不到被执行。而且这种现象存在workpoll的整个生命周期","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650633652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546988,"ip_address":"","group_id":0},"score":566228,"extra":""},{"author":{"id":1932430,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/7c/8e/830017ff.jpg","nickname":"香榭的枫叶🍂","note":"","ucode":"6EB2522892A0DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2285931,"avatar":"https://static001.geekbang.org/account/avatar/00/22/e1/6b/74a8b7d8.jpg","nickname":"Hugh","note":"","ucode":"77434E01E1D715","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591339,"discussion_content":"task是无缓冲的channel，没有排队的问题吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666520426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":566228,"ip_address":"北京","group_id":0},"score":591339,"extra":""}]},{"author":{"id":1019939,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/23/5c74e9b7.jpg","nickname":"$侯","note":"","ucode":"488B1BD3924E7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546959,"discussion_content":"第一个问题中，除非task有问题recover了否则是不需要减少的，这5个active在quit和程序结束前是一直在的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1642479140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1019939,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/23/5c74e9b7.jpg","nickname":"$侯","note":"","ucode":"488B1BD3924E7E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547024,"discussion_content":"谢谢大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642498682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546959,"ip_address":"","group_id":0},"score":547024,"extra":""}]},{"author":{"id":1214303,"avatar":"https://static001.geekbang.org/account/avatar/00/12/87/5f/6bf8b74a.jpg","nickname":"Kepler","note":"","ucode":"0C9CA3DB8B3CF0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559889,"discussion_content":"感觉第二版的!preAlloc + !block实现，大白老师是为了给我们展示这种用法，实战应该采用preAlloc + !block的组合，而且taskChan采用缓冲方式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649043619,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546968,"discussion_content":"我自己理了下，试着帮老师回答下这些问题，希望有错帮忙指正！\n1、&lt;-p.active 不放在 if 外面，因为只有发生panic时才需要把 p.active 计数减一（此时run又会重新new一个新的worker，保持“池”中活跃 goroutine 数恒定）；\n2、你说的对；\n3、returnTask方法，与它的名字字面含义一样，作用是“归还”task给p.tasks通道，因为for-range处读取tasks的本意只是为了有多少个task就创建多少个goroutine的worker（直到数量达到capacity，再break loop退出循环执行下面的逻辑），此处并不真正执行任务，所以将它归还回去，以便另一处真正执行任务的地方能接收到任务（t := &lt;-p.tasks）。完整源码在github有：文章最后有链接。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642483301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547023,"discussion_content":"谢谢大佬指点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642498676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546968,"ip_address":"","group_id":0},"score":547023,"extra":""},{"author":{"id":1184102,"avatar":"https://static001.geekbang.org/account/avatar/00/12/11/66/ac631a36.jpg","nickname":"Geralt","note":"","ucode":"2F31ED777D06A0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547035,"discussion_content":"调用returnTask归还的task还是有可能被for range获取到的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642500842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546968,"ip_address":"","group_id":0},"score":547035,"extra":""},{"author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1184102,"avatar":"https://static001.geekbang.org/account/avatar/00/12/11/66/ac631a36.jpg","nickname":"Geralt","note":"","ucode":"2F31ED777D06A0","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":547054,"discussion_content":"是的，所以我觉得这里可以优化下。另外搞成跟java的那样，带任务启动新worker，直到达到核心线程数。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1642510138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":547035,"ip_address":"","group_id":0},"score":547054,"extra":""}]}]},{"had_liked":false,"id":370067,"user_name":"Six Days","can_delete":false,"product_type":"c1","uid":1322463,"ip_address":"广东","ucode":"8587F2EEFFFD11","user_header":"https://static001.geekbang.org/account/avatar/00/14/2d/df/4949b250.jpg","comment_is_top":false,"comment_ctime":1678348129,"is_pvip":false,"replies":[{"id":134931,"content":"demo1创建goroutine后没有回收，一直是复用的，最多创建capacity个goroutine，直到pool销毁。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1678435665,"ip_address":"北京","comment_id":370067,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"请教一下，池化的话，当前的demo1场景是不是没有考虑使用同一个worker进行t任务的处理，而是通过不断的创建 Goroutine实现的，通过capacity控制了处理任务Goroutine的数量，通过Go gc 来实现Goroutine的回收，是不是因为Goroutine 的占内存比较小，为此没有做Goroutine 的复用，所以采用不断创建，还是当前为了简单演示呢，实际还是需要复用Goroutine 的呢？","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612674,"discussion_content":"当preAlloc=false时，即不预分配时。这样就根据tasks的情况来创建worker。如果当前没有task，实际上系统中没有worker被创建出来，直到有task才会创建worker。一直到active channel满了！这样pool中所有worker都创建出来后，再跳出循环，进入下面的quit监听。\n\n不过workpool2的这段代码的确有refactor的空间😁。可以写的更好理解一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680843383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3522132,"avatar":"","nickname":"Geek_0d5d37","note":"","ucode":"1BB4AEF1328C64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612686,"discussion_content":"老师我是不是可以这样理解demo2这段代码只是为了区别当preAlloc=false时，即不预分配时。 体现出worker没有提前创建而已。 只是这里通过遍历tasks阻塞了worker创建来实现","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1680850746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3522132,"avatar":"","nickname":"Geek_0d5d37","note":"","ucode":"1BB4AEF1328C64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612684,"discussion_content":"谢谢老师的回复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680850231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370065,"user_name":"Six Days","can_delete":false,"product_type":"c1","uid":1322463,"ip_address":"广东","ucode":"8587F2EEFFFD11","user_header":"https://static001.geekbang.org/account/avatar/00/14/2d/df/4949b250.jpg","comment_is_top":false,"comment_ctime":1678346270,"is_pvip":false,"replies":[{"id":134932,"content":"run在New中调用，active满了，代表capacity个worker goroutine已经创建完毕，后续将重用这些goroutine。这时候run会阻塞在select上直到quit channel有数据才会退出。p.active 那个case后续没用了。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1678436361,"ip_address":"北京","comment_id":370065,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"请教一下，p.active 的chan 容量指定是capacity，而只有run的时候，才会通过p.active &lt;- struct{}{} 往p.active中丢东西，p.active 才会变多，达到capacity时。任务T则阻塞，我理解 run 只会New的时候触发，请问是否与文中描述一致呢？\nfunc (p *Pool) run() {\n\tidx := 0\n\n\tfor {\n\t\tselect {\n\t\tcase &lt;-p.quit:\n\t\t\treturn\n\t\tcase p.active &lt;- struct{}{}:\n\t\t\t&#47;&#47; create a new worker\n\t\t\tidx++\n\t\t\tp.newWorker(idx)\n\t\t}\n\t}\n}","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608422,"discussion_content":"demo1创建goroutine后没有回收，一直是复用的，最多创建capacity个goroutine，直到pool销毁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678435665,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3647096,"avatar":"","nickname":"Geek_38ea75","note":"","ucode":"5295680D787299","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629987,"discussion_content":"没有任务就阻塞，每个协程就是在复用，除非有异常情况协程才会退出，即使有协程退出，还会有新的协程被创建。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1697960462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366834,"user_name":"demajiao","can_delete":false,"product_type":"c1","uid":1907425,"ip_address":"浙江","ucode":"1632CFCC16A5DF","user_header":"https://static001.geekbang.org/account/avatar/00/1d/1a/e1/1acde886.jpg","comment_is_top":false,"comment_ctime":1674396836,"is_pvip":false,"replies":[{"id":133706,"content":"当preAlloc=false时，即不预分配时，有用。","user_name":"作者回复","user_name_real":"作者","uid":1026224,"ctime":1674692595,"ip_address":"辽宁","comment_id":366834,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"if !p.preAlloc {\n\tloop:\n\t\tfor t := range p.tasks {\n\t\t\tp.returnTask(t)\n\t\t\tselect {\n\t\t\tcase &lt;-p.quit:\n\t\t\t\treturn\n\t\t\tcase p.active &lt;- struct{}{}:\n\t\t\t\tidx++\n\t\t\t\tp.newWorker(idx)\n\t\t\tdefault:\n\t\t\t\tbreak loop\n\t\t\t}\n\t\t}\n\t}\n\n这段代码感觉没用呀。","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608424,"discussion_content":"run在New中调用，active满了，代表capacity个worker goroutine已经创建完毕，后续将重用这些goroutine。这时候run会阻塞在select上直到quit channel有数据才会退出。p.active 那个case后续没用了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678436361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366388,"user_name":"撕影","can_delete":false,"product_type":"c1","uid":3222094,"ip_address":"湖南","ucode":"8DC169F8B8E653","user_header":"https://static001.geekbang.org/account/avatar/00/31/2a/4e/a3f53cae.jpg","comment_is_top":false,"comment_ctime":1673682649,"is_pvip":false,"replies":[{"id":133538,"content":"“关键变化”，指的是？","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1673857137,"ip_address":"北京","comment_id":366388,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"为何关键变化不写出来？太仓促了吧，一篇最后一节以没看懂收场，对学生打击可不小啊老师","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600651,"discussion_content":"当preAlloc=false时，即不预分配时，有用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674692596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":363111,"user_name":"Sunrise","can_delete":false,"product_type":"c1","uid":2820643,"ip_address":"辽宁","ucode":"791BC042992385","user_header":"https://static001.geekbang.org/account/avatar/00/2b/0a/23/c26f4e50.jpg","comment_is_top":false,"comment_ctime":1669250308,"is_pvip":false,"replies":[{"id":132082,"content":"最后一版Schedule加入了default分支，当pool资源不够又设置为non block时，schedule肯定会返回error啊。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1669491203,"ip_address":"辽宁","comment_id":363111,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"考虑到 Goroutine 调度的次序的不确定性，这里我在创建 workerpool 与真正开始调用 Schedule 方法之间，做了一个 Sleep，尽量减少 Schedule 都返回失败的频率\n这块也不太懂，为啥不加 Sleep 会全返回失败呢？","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":599883,"discussion_content":"“关键变化”，指的是？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673857138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":363058,"user_name":"Sunrise","can_delete":false,"product_type":"c1","uid":2820643,"ip_address":"北京","ucode":"791BC042992385","user_header":"https://static001.geekbang.org/account/avatar/00/2b/0a/23/c26f4e50.jpg","comment_is_top":false,"comment_ctime":1669188776,"is_pvip":false,"replies":[{"id":132042,"content":"问题1：主要是为了可选参数吧。为什么go没有原生支持默认参数与可选参数，我猜是因为go设计者压根就不想引入这个复杂性。\n\n问题2: 和goroutine的调度顺序有关。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1669251802,"ip_address":"北京","comment_id":363058,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"有几个问题不大理解，望老师抽空解答：\n1）自引用函数与选项设计是为了解决 go 函数没有默认参数和可选参数吗? go 函数为什么没有设计默认参数和可选参数呢？\n2）为什么下面的 for { select ... }  放到 goroutine 中 才会输出 ch2: 2 ch1: 1 done， 如果直接放到外面只会输出 done？\n  func TestSelect(t *testing.T) {\n\tch1 := make(chan int)\n\tch2 := make(chan int)\n\n\tgo func() {\n\t\tch1 &lt;- 1\n\t}()\n\n\tgo func() {\n\t\tch2 &lt;- 2\n\t}()\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase i := &lt;-ch1:\n\t\t\t\tfmt.Println(&quot;ch1:&quot;, i)\n\t\t\tcase j := &lt;-ch2:\n\t\t\t\tfmt.Println(&quot;ch2:&quot;, j)\n\t\t\tdefault:\n\t\t\t\tfmt.Println(&quot;done&quot;)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\t&#47;&#47; ch2: 2 ch1: 1 done\n}","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":594864,"discussion_content":"最后一版Schedule加入了default分支，当pool资源不够又设置为non block时，schedule肯定会返回error啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1669491203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338386,"user_name":"ivhong","can_delete":false,"product_type":"c1","uid":2659871,"ip_address":"","ucode":"9947B228807AC9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ8ic8eLTo5rnqIMJicUfpkVBrOUJAW4fANicKIbHdC54O9SOdwSoeK6o8icibaUbh7ZUXAkGF9zwHqo0Q/132","comment_is_top":false,"comment_ctime":1647479909,"is_pvip":false,"replies":[{"id":123699,"content":"好问题。\n\n1. 传统理解的coroutine一般是面向协作式，而非抢占式。像python中通过yield关键字创建的协程，与主routine之间是在一个线程上实现的切换执行，从设计角度是通过coroutine实现了并发(concurrency)，但其实它们还是串行执行的，不会真正并行(paralellism)，即便在多核处理器上。\n                                                                                             \n基于上面的理解，我们就可以意识到goroutine并非传统意义上的coroutine，是支持抢占的，而且也必须依赖抢占实现runtime对goroutine的调度。它更像thread，可以绑定不同的cpu核并行执行（如果是在多核处理器上的话）。同时基于goroutine的设计也会一种并发的设计。\n\n而goroutine与thread又不同，goroutine是在用户层(相较于os的内核层）调度的，os并不知道其存在，goroutine的切换相对轻量。而thread是os\n来调度的，切换代价更高一些。\n\n所以文中将goroutine称为“轻量级线程”，而不是协程。\n\n2. 你理解的没错。这节课是为了演示goroutine、channel之间的调度与通信机制而“设计”出来的。goroutine使用代价很低，通常不用考虑池化。但是在一些大型网络服务程序时，一旦goroutine数量过多，内存占用以及调度goroutine的代价就不能不考虑了。于是有了“池化”的思路。这与传统的线程池的思路的确是一脉相承的\n\n3. go是gc的，内存不会越来越大。\n","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1647495219,"ip_address":"","comment_id":338386,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"非常感谢老师带着做了一次这样的实现，因为我自己也尝试过这种实现（纯粹是为了学习用）。有几个问题我不是特别明白，不知道是不是和老师理解的一样，望老师闲暇之余给予指正，谢谢！\n1. 这个是不是叫“协程池”，为什么叫做“线程池”？两者有什么区别呢？或者是到底什么是“协程”呢？\n2. 是不是这节课的实现，也纯粹是为了学习而实现的，个人理解，go实现Goroutine，就是为了解决“线程池”的繁琐，让“并发”实现的不用那么的麻烦，如果是超小“任务”，不用考虑线程频繁切换导致系统资源的浪费。如果再实现“协程池”的话，是不是丢失了这种优点？\n3. 常驻内存的Goroutine，反复使用，会导致这个Goroutine的内存越来越大，或者其他隐藏的风险么？","like_count":14,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556741,"discussion_content":"好问题。\n\n1. 传统理解的coroutine一般是面向协作式，而非抢占式。像python中通过yield关键字创建的协程，与主routine之间是在一个线程上实现的切换执行，从设计角度是通过coroutine实现了并发(concurrency)，但其实它们还是串行执行的，不会真正并行(paralellism)，即便在多核处理器上。\n                                                                                             \n基于上面的理解，我们就可以意识到goroutine并非传统意义上的coroutine，是支持抢占的，而且也必须依赖抢占实现runtime对goroutine的调度。它更像thread，可以绑定不同的cpu核并行执行（如果是在多核处理器上的话）。同时基于goroutine的设计也会一种并发的设计。\n\n而goroutine与thread又不同，goroutine是在用户层(相较于os的内核层）调度的，os并不知道其存在，goroutine的切换相对轻量。而thread是os\n来调度的，切换代价更高一些。\n\n所以文中将goroutine称为“轻量级线程”，而不是协程。\n\n2. 你理解的没错。这节课是为了演示goroutine、channel之间的调度与通信机制而“设计”出来的。goroutine使用代价很低，通常不用考虑池化。但是在一些大型网络服务程序时，一旦goroutine数量过多，内存占用以及调度goroutine的代价就不能不考虑了。于是有了“池化”的思路。这与传统的线程池的思路的确是一脉相承的\n\n3. go是gc的，内存不会越来越大。\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1647495219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331114,"user_name":"$侯","can_delete":false,"product_type":"c1","uid":1019939,"ip_address":"","ucode":"488B1BD3924E7E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/90/23/5c74e9b7.jpg","comment_is_top":false,"comment_ctime":1642430185,"is_pvip":false,"replies":[{"id":120983,"content":"原文中有源码的链接，在最后。\n\n源码在 https:&#47;&#47;github.com&#47;bigwhite&#47;publication&#47;tree&#47;master&#47;column&#47;timegeek&#47;go-first-course&#47;35\n\n看了后，就可以回答你的问题了。","user_name":"作者回复","user_name_real":"作者","uid":1026224,"ctime":1642475072,"ip_address":"","comment_id":331114,"utype":1}],"discussion_count":7,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"老师您好请教几个问题：\n第一个问题，demo1中没有看到p.Free的代码示例，Free方法只是向p.quit &lt;- struct{}{}发送一个空结构体就可以吗，请教下Free方式该如何写\n第二个问题，demo1中好像也没看看到p.wg.Wait()","like_count":3,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546943,"discussion_content":"原文中有源码的链接，在最后。\n\n源码在 https://github.com/bigwhite/publication/tree/master/column/timegeek/go-first-course/35\n\n看了后，就可以回答你的问题了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642475072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":6,"child_discussions":[{"author":{"id":1019939,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/23/5c74e9b7.jpg","nickname":"$侯","note":"","ucode":"488B1BD3924E7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":546945,"discussion_content":"看到最后发现了，不知道怎么删评论[捂脸]","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642475212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546943,"ip_address":"","group_id":0},"score":546945,"extra":""},{"author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":546967,"discussion_content":"老师，试了下自己手动发 struct{}{}到p.quit会deadlock，调用close(p.quit)就不会，两者有啥区别呢？或者说close函数是否还多实现了哪些操作？\n\n另外，p.active和p.tasks不用close吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642482584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546943,"ip_address":"","group_id":0},"score":546967,"extra":""},{"author":{"id":1019939,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/23/5c74e9b7.jpg","nickname":"$侯","note":"","ucode":"488B1BD3924E7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546987,"discussion_content":"我的理解是有好多个地方的p.quit在等着接收，如果你往p.quit发送了一个struct{}{}，除了抢到这个struct{}{}的其他地方的就deadlock了，而close关闭会向所有的p.quit发出一个通知，像前面第33章节里介绍的一对多关系的信号量的那个例子","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1642488356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546967,"ip_address":"","group_id":0},"score":546987,"extra":""}]}]},{"had_liked":false,"id":331112,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1642429951,"is_pvip":false,"replies":[{"id":121004,"content":"看的真细致！👍\n\n1. worker一旦创建后，除了panic和quit通知退出，worker是不会退出的，也就是没有所谓“正常退出”的情况。所以没在defer中调用&lt;-p.active。\n2. 的确是笔误,感谢指出。\n3. 在文后有源码链接。这里的task仅是触发了worker创建，这里是调度循环，不处理task，所以要把task扔回tasks channel，等worker启动后再处理。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1642488429,"ip_address":"","comment_id":331112,"utype":1}],"discussion_count":12,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"老师以下几个问题哈：\n1、第一种实现中，这块是不是有点问题：\n\ngo func() {\n    defer func() {\n        if err := recover(); err != nil {\n            fmt.Printf(&quot;worker[%03d]: recover panic[%s] and exit\\n&quot;, i, err)\n            &lt;-p.active\n        }\n        p.wg.Done()\n    }()\n\n  &lt;-p.active是不是应该要放到if的外面，如果task执行本身没有出错，正常结束了，active没有减少的地方\n\n2、这块文字描述有点问题，p&lt;-active应该是&lt;-p.active\n“使用了 defer+recover 对 panic 进行捕捉，捕捉后 worker 也是要退出的，于是我们还通过p&lt;-active更新了 worker 计数器”\n\n3、第二种实现中，当没有提前创建worker，那么当tasks中有任务的时候，p.returnTask方法是干啥的？文章中没有这个方法，且文字也没有说明呀\n\n func (p *Pool) run() {\n     idx := len(p.active)\n \n     if !p.preAlloc {\n     loop:\n         for t := range p.tasks {\n             p.returnTask(t)\n             select {\n             case &lt;-p.quit:\n                 return\n             case p.active &lt;- struct{}{}:\n                 idx++\n                 p.newWorker(idx)\n             default:\n                 break loop\n             }\n         }\n     }\n ","like_count":3,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546943,"discussion_content":"原文中有源码的链接，在最后。\n\n源码在 https://github.com/bigwhite/publication/tree/master/column/timegeek/go-first-course/35\n\n看了后，就可以回答你的问题了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642475072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":6,"child_discussions":[{"author":{"id":1019939,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/23/5c74e9b7.jpg","nickname":"$侯","note":"","ucode":"488B1BD3924E7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":546945,"discussion_content":"看到最后发现了，不知道怎么删评论[捂脸]","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642475212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546943,"ip_address":"","group_id":0},"score":546945,"extra":""},{"author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":546967,"discussion_content":"老师，试了下自己手动发 struct{}{}到p.quit会deadlock，调用close(p.quit)就不会，两者有啥区别呢？或者说close函数是否还多实现了哪些操作？\n\n另外，p.active和p.tasks不用close吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642482584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546943,"ip_address":"","group_id":0},"score":546967,"extra":""},{"author":{"id":1019939,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/23/5c74e9b7.jpg","nickname":"$侯","note":"","ucode":"488B1BD3924E7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546987,"discussion_content":"我的理解是有好多个地方的p.quit在等着接收，如果你往p.quit发送了一个struct{}{}，除了抢到这个struct{}{}的其他地方的就deadlock了，而close关闭会向所有的p.quit发出一个通知，像前面第33章节里介绍的一对多关系的信号量的那个例子","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1642488356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546967,"ip_address":"","group_id":0},"score":546987,"extra":""}]}]},{"had_liked":false,"id":372125,"user_name":"Geek_0d5d37","can_delete":false,"product_type":"c1","uid":3522132,"ip_address":"四川","ucode":"1BB4AEF1328C64","user_header":"","comment_is_top":false,"comment_ctime":1680764743,"is_pvip":false,"replies":[{"id":135834,"content":"当preAlloc=false时，即不预分配时。这样就根据tasks的情况来创建worker。如果当前没有task，实际上系统中没有worker被创建出来，直到有task才会创建worker。一直到active channel满了！这样pool中所有worker都创建出来后，再跳出循环，进入下面的quit监听。\n\n不过workpool2的这段代码的确有refactor的空间😁。可以写的更好理解一些。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1680843383,"ip_address":"北京","comment_id":372125,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"老师您好，这个段代码作用我也不太理解\nif !p.preAlloc {\n\tloop:\n\t\tfor t := range p.tasks {\n\t\t\tp.returnTask(t)\n\t\t\tselect {\n\t\t\tcase &lt;-p.quit:\n\t\t\t\treturn\n\t\t\tcase p.active &lt;- struct{}{}:\n\t\t\t\tidx++\n\t\t\t\tp.newWorker(idx)\n\t\t\tdefault:\n\t\t\t\tbreak loop\n\t\t\t}\n\t\t}\n\t}\n\n您在留言中回答 当preAlloc=false时有用 ，如果是这样demo1 就是等于fasle的情况没使用这段代码的 ，请老师有空回答一下","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612674,"discussion_content":"当preAlloc=false时，即不预分配时。这样就根据tasks的情况来创建worker。如果当前没有task，实际上系统中没有worker被创建出来，直到有task才会创建worker。一直到active channel满了！这样pool中所有worker都创建出来后，再跳出循环，进入下面的quit监听。\n\n不过workpool2的这段代码的确有refactor的空间😁。可以写的更好理解一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680843383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3522132,"avatar":"","nickname":"Geek_0d5d37","note":"","ucode":"1BB4AEF1328C64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612686,"discussion_content":"老师我是不是可以这样理解demo2这段代码只是为了区别当preAlloc=false时，即不预分配时。 体现出worker没有提前创建而已。 只是这里通过遍历tasks阻塞了worker创建来实现","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1680850746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3522132,"avatar":"","nickname":"Geek_0d5d37","note":"","ucode":"1BB4AEF1328C64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612684,"discussion_content":"谢谢老师的回复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680850231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370067,"user_name":"Six Days","can_delete":false,"product_type":"c1","uid":1322463,"ip_address":"广东","ucode":"8587F2EEFFFD11","user_header":"https://static001.geekbang.org/account/avatar/00/14/2d/df/4949b250.jpg","comment_is_top":false,"comment_ctime":1678348129,"is_pvip":false,"replies":[{"id":134931,"content":"demo1创建goroutine后没有回收，一直是复用的，最多创建capacity个goroutine，直到pool销毁。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1678435665,"ip_address":"北京","comment_id":370067,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"请教一下，池化的话，当前的demo1场景是不是没有考虑使用同一个worker进行t任务的处理，而是通过不断的创建 Goroutine实现的，通过capacity控制了处理任务Goroutine的数量，通过Go gc 来实现Goroutine的回收，是不是因为Goroutine 的占内存比较小，为此没有做Goroutine 的复用，所以采用不断创建，还是当前为了简单演示呢，实际还是需要复用Goroutine 的呢？","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608422,"discussion_content":"demo1创建goroutine后没有回收，一直是复用的，最多创建capacity个goroutine，直到pool销毁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678435665,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3647096,"avatar":"","nickname":"Geek_38ea75","note":"","ucode":"5295680D787299","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629987,"discussion_content":"没有任务就阻塞，每个协程就是在复用，除非有异常情况协程才会退出，即使有协程退出，还会有新的协程被创建。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1697960462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370065,"user_name":"Six Days","can_delete":false,"product_type":"c1","uid":1322463,"ip_address":"广东","ucode":"8587F2EEFFFD11","user_header":"https://static001.geekbang.org/account/avatar/00/14/2d/df/4949b250.jpg","comment_is_top":false,"comment_ctime":1678346270,"is_pvip":false,"replies":[{"id":134932,"content":"run在New中调用，active满了，代表capacity个worker goroutine已经创建完毕，后续将重用这些goroutine。这时候run会阻塞在select上直到quit channel有数据才会退出。p.active 那个case后续没用了。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1678436361,"ip_address":"北京","comment_id":370065,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"请教一下，p.active 的chan 容量指定是capacity，而只有run的时候，才会通过p.active &lt;- struct{}{} 往p.active中丢东西，p.active 才会变多，达到capacity时。任务T则阻塞，我理解 run 只会New的时候触发，请问是否与文中描述一致呢？\nfunc (p *Pool) run() {\n\tidx := 0\n\n\tfor {\n\t\tselect {\n\t\tcase &lt;-p.quit:\n\t\t\treturn\n\t\tcase p.active &lt;- struct{}{}:\n\t\t\t&#47;&#47; create a new worker\n\t\t\tidx++\n\t\t\tp.newWorker(idx)\n\t\t}\n\t}\n}","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608424,"discussion_content":"run在New中调用，active满了，代表capacity个worker goroutine已经创建完毕，后续将重用这些goroutine。这时候run会阻塞在select上直到quit channel有数据才会退出。p.active 那个case后续没用了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678436361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366834,"user_name":"demajiao","can_delete":false,"product_type":"c1","uid":1907425,"ip_address":"浙江","ucode":"1632CFCC16A5DF","user_header":"https://static001.geekbang.org/account/avatar/00/1d/1a/e1/1acde886.jpg","comment_is_top":false,"comment_ctime":1674396836,"is_pvip":false,"replies":[{"id":133706,"content":"当preAlloc=false时，即不预分配时，有用。","user_name":"作者回复","user_name_real":"作者","uid":1026224,"ctime":1674692595,"ip_address":"辽宁","comment_id":366834,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"if !p.preAlloc {\n\tloop:\n\t\tfor t := range p.tasks {\n\t\t\tp.returnTask(t)\n\t\t\tselect {\n\t\t\tcase &lt;-p.quit:\n\t\t\t\treturn\n\t\t\tcase p.active &lt;- struct{}{}:\n\t\t\t\tidx++\n\t\t\t\tp.newWorker(idx)\n\t\t\tdefault:\n\t\t\t\tbreak loop\n\t\t\t}\n\t\t}\n\t}\n\n这段代码感觉没用呀。","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600651,"discussion_content":"当preAlloc=false时，即不预分配时，有用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674692596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366388,"user_name":"撕影","can_delete":false,"product_type":"c1","uid":3222094,"ip_address":"湖南","ucode":"8DC169F8B8E653","user_header":"https://static001.geekbang.org/account/avatar/00/31/2a/4e/a3f53cae.jpg","comment_is_top":false,"comment_ctime":1673682649,"is_pvip":false,"replies":[{"id":133538,"content":"“关键变化”，指的是？","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1673857137,"ip_address":"北京","comment_id":366388,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"为何关键变化不写出来？太仓促了吧，一篇最后一节以没看懂收场，对学生打击可不小啊老师","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":599883,"discussion_content":"“关键变化”，指的是？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673857138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":363111,"user_name":"Sunrise","can_delete":false,"product_type":"c1","uid":2820643,"ip_address":"辽宁","ucode":"791BC042992385","user_header":"https://static001.geekbang.org/account/avatar/00/2b/0a/23/c26f4e50.jpg","comment_is_top":false,"comment_ctime":1669250308,"is_pvip":false,"replies":[{"id":132082,"content":"最后一版Schedule加入了default分支，当pool资源不够又设置为non block时，schedule肯定会返回error啊。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1669491203,"ip_address":"辽宁","comment_id":363111,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"考虑到 Goroutine 调度的次序的不确定性，这里我在创建 workerpool 与真正开始调用 Schedule 方法之间，做了一个 Sleep，尽量减少 Schedule 都返回失败的频率\n这块也不太懂，为啥不加 Sleep 会全返回失败呢？","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":594864,"discussion_content":"最后一版Schedule加入了default分支，当pool资源不够又设置为non block时，schedule肯定会返回error啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1669491203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":363058,"user_name":"Sunrise","can_delete":false,"product_type":"c1","uid":2820643,"ip_address":"北京","ucode":"791BC042992385","user_header":"https://static001.geekbang.org/account/avatar/00/2b/0a/23/c26f4e50.jpg","comment_is_top":false,"comment_ctime":1669188776,"is_pvip":false,"replies":[{"id":132042,"content":"问题1：主要是为了可选参数吧。为什么go没有原生支持默认参数与可选参数，我猜是因为go设计者压根就不想引入这个复杂性。\n\n问题2: 和goroutine的调度顺序有关。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1669251802,"ip_address":"北京","comment_id":363058,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"有几个问题不大理解，望老师抽空解答：\n1）自引用函数与选项设计是为了解决 go 函数没有默认参数和可选参数吗? go 函数为什么没有设计默认参数和可选参数呢？\n2）为什么下面的 for { select ... }  放到 goroutine 中 才会输出 ch2: 2 ch1: 1 done， 如果直接放到外面只会输出 done？\n  func TestSelect(t *testing.T) {\n\tch1 := make(chan int)\n\tch2 := make(chan int)\n\n\tgo func() {\n\t\tch1 &lt;- 1\n\t}()\n\n\tgo func() {\n\t\tch2 &lt;- 2\n\t}()\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase i := &lt;-ch1:\n\t\t\t\tfmt.Println(&quot;ch1:&quot;, i)\n\t\t\tcase j := &lt;-ch2:\n\t\t\t\tfmt.Println(&quot;ch2:&quot;, j)\n\t\t\tdefault:\n\t\t\t\tfmt.Println(&quot;done&quot;)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\t&#47;&#47; ch2: 2 ch1: 1 done\n}","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":594641,"discussion_content":"问题1：主要是为了可选参数吧。为什么go没有原生支持默认参数与可选参数，我猜是因为go设计者压根就不想引入这个复杂性。\n\n问题2: 和goroutine的调度顺序有关。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1669251802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357118,"user_name":"菠萝吹雪—Code","can_delete":false,"product_type":"c1","uid":1650378,"ip_address":"辽宁","ucode":"A5B2FC661EE17D","user_header":"https://static001.geekbang.org/account/avatar/00/19/2e/ca/469f7266.jpg","comment_is_top":false,"comment_ctime":1662973407,"is_pvip":false,"replies":[{"id":130003,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1663098593,"ip_address":"辽宁","comment_id":357118,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"中秋假期打卡","like_count":1},{"had_liked":false,"id":355492,"user_name":"H","can_delete":false,"product_type":"c1","uid":1019263,"ip_address":"辽宁","ucode":"1A31369846B553","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/QUCB325iaqkJCz8uzRFicXgoISWnlund6DdE25ibjlCTV2zkiccQsZ4Nib9XNdcCJpuPa2XaZ9GnRwp6ibJq4VegHsug/132","comment_is_top":false,"comment_ctime":1661425613,"is_pvip":false,"replies":[{"id":129461,"content":"1. 是的。\n2. 原因就是问题1的描述","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1661691110,"ip_address":"辽宁","comment_id":355492,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"有些没太懂：\n1. run里面 p.returnTask(t)，相当于又把 task 异步扔p.tasks 里面了，然后创建worker等待从 p.tasks里面取task执行。因为returnTask和newWorker都是异步，所以无法保证是range p.tasks还是worker先执行\n2.在我理解，既然是想开5个容量的非预加载的线程池，10个循环中应该前5个应该都创建woker呀","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587488,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663098593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":354964,"user_name":"骚动","can_delete":false,"product_type":"c1","uid":2280216,"ip_address":"北京","ucode":"EBEBF417C866D4","user_header":"https://static001.geekbang.org/account/avatar/00/22/cb/18/0139e086.jpg","comment_is_top":false,"comment_ctime":1660917165,"is_pvip":false,"replies":[{"id":129245,"content":"在线工具，可以用processon.com，离线的我一般用draw.io。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1661217333,"ip_address":"北京","comment_id":354964,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师，请教一下，这种软件架构图是用什么画的啊？平时自己也想画画自己做的东西的架构图，但是没找到什么合适的工具","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585588,"discussion_content":"1. 是的。\n2. 原因就是问题1的描述","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661691110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":352037,"user_name":"我好像一点都不像程序员","can_delete":false,"product_type":"c1","uid":1435733,"ip_address":"","ucode":"F479190923355C","user_header":"https://static001.geekbang.org/account/avatar/00/15/e8/55/63189817.jpg","comment_is_top":false,"comment_ctime":1658361801,"is_pvip":false,"replies":[{"id":128098,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1658401847,"ip_address":"","comment_id":352037,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"功能选项这种封装的方式确实拓展性很好，和传统的参数传入并自动绑定来说，不需要更改New 的代码，只需要在外拓展","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584906,"discussion_content":"在线工具，可以用processon.com，离线的我一般用draw.io。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661217333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351028,"user_name":"Geek_a6104e","can_delete":false,"product_type":"c1","uid":1711967,"ip_address":"","ucode":"29A56792216DC8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/GJXKh8OG00U5ial64plAIibbIuwkzhPc8uYic9Hibl8SbqvhnS2JImHgCD4JGvTktiaVnCjHQWbA5wicaxRUN5aTEWnQ/132","comment_is_top":false,"comment_ctime":1657463972,"is_pvip":false,"replies":[{"id":127788,"content":"示例原意就是设计一个同步提交的workerpool池。即如果Schedule方法返回成功，说明用户提交的task肯定被某个worker处理了。\n\n如果要设计为异步提交语义，可以使用带缓冲的tasks channel。那样schedule方法提交后，task可能一直在channel中存着，直到有worker处理。但当缓冲区满了，还是会退化为同步提交。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1657700552,"ip_address":"","comment_id":351028,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"请问tasks通道为什么是不带缓存区的","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580915,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658401847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346066,"user_name":"Hugh","can_delete":false,"product_type":"c1","uid":2285931,"ip_address":"","ucode":"77434E01E1D715","user_header":"https://static001.geekbang.org/account/avatar/00/22/e1/6b/74a8b7d8.jpg","comment_is_top":false,"comment_ctime":1652798680,"is_pvip":false,"replies":[{"id":126261,"content":"这是两个层面的复用。GMP对G数据结构的复用是在runtime调度层面，但这种复用 用户层无法控制，G也不是总能被复用，就像sync.Pool中数据项，在一定时间内如果没有goroutine去从池中get，那么还是会被释放的。\n\n当然用户层面实现的goroutine 池也可以增加idle释放的特性(这一讲中的例子不支持)，但这种释放是用户层可控的。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1652822694,"ip_address":"","comment_id":346066,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师您好，请教个问题，之前说过在GMP模型中数据结构G是可以被复用的，那么协程池还有必要吗？因为协程池的一大优势就是复用协程，避免反复创建协程，那么其实go scheduler已经做到了","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579818,"discussion_content":"示例原意就是设计一个同步提交的workerpool池。即如果Schedule方法返回成功，说明用户提交的task肯定被某个worker处理了。\n\n如果要设计为异步提交语义，可以使用带缓冲的tasks channel。那样schedule方法提交后，task可能一直在channel中存着，直到有worker处理。但当缓冲区满了，还是会退化为同步提交。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657700553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343782,"user_name":"Geek_as","can_delete":false,"product_type":"c1","uid":1534500,"ip_address":"","ucode":"AB7B70DBC2B5F8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/qhonwcQle1RBufvLdTm4MgSNl554GBXUZtNNH65oYajbbRLxKsZX4hM9vFtrLLpDM0H93ZNWRFAZSrIZC7yAsQ/132","comment_is_top":false,"comment_ctime":1651052596,"is_pvip":false,"replies":[{"id":125588,"content":"demo2使用Workpool2中的returnTask代码如下：\n\nfunc (p *Pool) returnTask(t Task) {\n    go func() {\n        p.tasks &lt;- t\n    }()\n}\n\nreturnTask中创建了一个新goroutine来异步send task，returnTask怎么会卡住呢？","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1651138411,"ip_address":"","comment_id":343782,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师，最后一个例子好像有问题，假如我设置的是当没有活动go worker的时候阻塞，然后当前线程不会预创建，这时候我往池里面添加一个任务，由于没有worker可以接收，导致它走到了default,由于我是设置了获取不到就阻塞,所以我的代码走到了\nif p.block{\n\t\t\tp.tasks &lt;- t\n}\n这里，这时候run方法检测到task管道里有task，就接收下来，前面的p.tasks &lt;- t阻塞释放了，会继续走下去，然后run的话，在接收了管道的task后，执行的下一步操作是returnTask,然后创建活动worker，去执行returnTask返回的task，但出现了神奇的一幕，run的执行流程卡在returnTask的p.tasks &lt;- task中，导致后面的活动worker没法创建，一直卡在returnTask那里，后面我分析了一下，感觉应该是我的tasks是无缓冲队列，所以returnTask执行p.tasks &lt;- task的时候就卡在这里，等待其他人的接收，但这样就有问题了，因为接收操作要么在run的range中，要么是由活动worker接收，因为卡在returnTask这里，所以没法创建活动worker，也就没worker消费，变成了类似于死锁的样子，假如我配置了阻塞，和不预创建，理论上我提交给池里面的所有任务都不会被执行，我试了一下，当提交的任务超过两个就会爆死锁异常，后面我将returnTask这一步动作移动到了创建worker之后，就解决了这个问题","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568445,"discussion_content":"demo2使用Workpool2中的returnTask代码如下：\n\nfunc (p *Pool) returnTask(t Task) {\n    go func() {\n        p.tasks &lt;- t\n    }()\n}\n\nreturnTask中创建了一个新goroutine来异步send task，returnTask怎么会卡住呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651138411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338596,"user_name":"木木","can_delete":false,"product_type":"c1","uid":2704565,"ip_address":"","ucode":"86820F26A27308","user_header":"https://static001.geekbang.org/account/avatar/00/29/44/b5/7eba5a0e.jpg","comment_is_top":false,"comment_ctime":1647587716,"is_pvip":false,"replies":[{"id":123854,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1647810501,"ip_address":"","comment_id":338596,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"学到很多！感谢","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557431,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647810501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335569,"user_name":"快乐的臭豆腐","can_delete":false,"product_type":"c1","uid":1115249,"ip_address":"","ucode":"1E0F2B55FF3023","user_header":"https://static001.geekbang.org/account/avatar/00/11/04/71/7e5d7c85.jpg","comment_is_top":false,"comment_ctime":1645590240,"is_pvip":false,"replies":[{"id":122616,"content":"是阻塞了。tasks是不带缓冲的channel，如果5个worker都在处理task，那么没有空闲的worker去从tasks中读取，这时schedule新task会阻塞。直到有空闲worker。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1645607500,"ip_address":"","comment_id":335569,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师您好，有个地方不是很理解，希望您解答一下\n\n以第一版的WorkPool为例\n我尝试在Schedule函数追加了print函数，\nfmt.Printf(&quot;%s: Scheduling task\\n&quot;, time.Now())\n发现所有的Task并不是一次性加入到pool的\n当pool的capacity=5时，会先加入6个task然后等有task结束后再Schedule剩余的task，请问这是被阻塞了吗？理论上p.active才有capacity限制，p.tasks应该是一次性写入的\n\n\n","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552836,"discussion_content":"是阻塞了。tasks是不带缓冲的channel，如果5个worker都在处理task，那么没有空闲的worker去从tasks中读取，这时schedule新task会阻塞。直到有空闲worker。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645607500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333857,"user_name":"Witt","can_delete":false,"product_type":"c1","uid":1005864,"ip_address":"","ucode":"19C8BCA266130A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/28/943709cb.jpg","comment_is_top":false,"comment_ctime":1644564434,"is_pvip":false,"replies":[{"id":122063,"content":"首先这仅是一个demo。goroutine池有很多种实现方式，甚至基于同一种方式，比如文中的channel也有不同的策略设定。也许文中的demo设定的当p.tasks阻塞就返回错误（当p.block=false时）有些不合理。\n\n&quot;让调度时不阻塞，是不是把 task 放到一个队列里排队更合理，再加上一个丢弃策略，类似 Java 中的线程池&quot; -- 很好的提议。这也是一种设计过程的设定，在我的demo的基础上，稍作修改应该就能实现。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1644762667,"ip_address":"","comment_id":333857,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师，既然没有达到最大 worker 数，为什么不是去创建新的 worker 而是直接返回错误呢？这一点不是很理解，不应该是根据 task 自动创建预期内的 worker 直到 worker 数满了再返回没有空闲的 worker 错误吗\n\n再一个就是，让调度时不阻塞，是不是把 task 放到一个队列里排队更合理，再加上一个丢弃策略，类似 Java 中的线程池","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550863,"discussion_content":"首先这仅是一个demo。goroutine池有很多种实现方式，甚至基于同一种方式，比如文中的channel也有不同的策略设定。也许文中的demo设定的当p.tasks阻塞就返回错误（当p.block=false时）有些不合理。\n\n&#34;让调度时不阻塞，是不是把 task 放到一个队列里排队更合理，再加上一个丢弃策略，类似 Java 中的线程池&#34; -- 很好的提议。这也是一种设计过程的设定，在我的demo的基础上，稍作修改应该就能实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644762667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1005864,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/28/943709cb.jpg","nickname":"Witt","note":"","ucode":"19C8BCA266130A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":550900,"discussion_content":"感谢老师耐心解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644804613,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":550863,"ip_address":"","group_id":0},"score":550900,"extra":""}]}]},{"had_liked":false,"id":357118,"user_name":"菠萝吹雪—Code","can_delete":false,"product_type":"c1","uid":1650378,"ip_address":"辽宁","ucode":"A5B2FC661EE17D","user_header":"https://static001.geekbang.org/account/avatar/00/19/2e/ca/469f7266.jpg","comment_is_top":false,"comment_ctime":1662973407,"is_pvip":false,"replies":[{"id":130003,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1663098593,"ip_address":"辽宁","comment_id":357118,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"中秋假期打卡","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587488,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663098593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355492,"user_name":"H","can_delete":false,"product_type":"c1","uid":1019263,"ip_address":"辽宁","ucode":"1A31369846B553","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/QUCB325iaqkJCz8uzRFicXgoISWnlund6DdE25ibjlCTV2zkiccQsZ4Nib9XNdcCJpuPa2XaZ9GnRwp6ibJq4VegHsug/132","comment_is_top":false,"comment_ctime":1661425613,"is_pvip":false,"replies":[{"id":129461,"content":"1. 是的。\n2. 原因就是问题1的描述","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1661691110,"ip_address":"辽宁","comment_id":355492,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"有些没太懂：\n1. run里面 p.returnTask(t)，相当于又把 task 异步扔p.tasks 里面了，然后创建worker等待从 p.tasks里面取task执行。因为returnTask和newWorker都是异步，所以无法保证是range p.tasks还是worker先执行\n2.在我理解，既然是想开5个容量的非预加载的线程池，10个循环中应该前5个应该都创建woker呀","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585588,"discussion_content":"1. 是的。\n2. 原因就是问题1的描述","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661691110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":354964,"user_name":"骚动","can_delete":false,"product_type":"c1","uid":2280216,"ip_address":"北京","ucode":"EBEBF417C866D4","user_header":"https://static001.geekbang.org/account/avatar/00/22/cb/18/0139e086.jpg","comment_is_top":false,"comment_ctime":1660917165,"is_pvip":false,"replies":[{"id":129245,"content":"在线工具，可以用processon.com，离线的我一般用draw.io。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1661217333,"ip_address":"北京","comment_id":354964,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师，请教一下，这种软件架构图是用什么画的啊？平时自己也想画画自己做的东西的架构图，但是没找到什么合适的工具","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584906,"discussion_content":"在线工具，可以用processon.com，离线的我一般用draw.io。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661217333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":352037,"user_name":"我好像一点都不像程序员","can_delete":false,"product_type":"c1","uid":1435733,"ip_address":"","ucode":"F479190923355C","user_header":"https://static001.geekbang.org/account/avatar/00/15/e8/55/63189817.jpg","comment_is_top":false,"comment_ctime":1658361801,"is_pvip":false,"replies":[{"id":128098,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1658401847,"ip_address":"","comment_id":352037,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"功能选项这种封装的方式确实拓展性很好，和传统的参数传入并自动绑定来说，不需要更改New 的代码，只需要在外拓展","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580915,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658401847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351028,"user_name":"Geek_a6104e","can_delete":false,"product_type":"c1","uid":1711967,"ip_address":"","ucode":"29A56792216DC8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/GJXKh8OG00U5ial64plAIibbIuwkzhPc8uYic9Hibl8SbqvhnS2JImHgCD4JGvTktiaVnCjHQWbA5wicaxRUN5aTEWnQ/132","comment_is_top":false,"comment_ctime":1657463972,"is_pvip":false,"replies":[{"id":127788,"content":"示例原意就是设计一个同步提交的workerpool池。即如果Schedule方法返回成功，说明用户提交的task肯定被某个worker处理了。\n\n如果要设计为异步提交语义，可以使用带缓冲的tasks channel。那样schedule方法提交后，task可能一直在channel中存着，直到有worker处理。但当缓冲区满了，还是会退化为同步提交。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1657700552,"ip_address":"","comment_id":351028,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"请问tasks通道为什么是不带缓存区的","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579818,"discussion_content":"示例原意就是设计一个同步提交的workerpool池。即如果Schedule方法返回成功，说明用户提交的task肯定被某个worker处理了。\n\n如果要设计为异步提交语义，可以使用带缓冲的tasks channel。那样schedule方法提交后，task可能一直在channel中存着，直到有worker处理。但当缓冲区满了，还是会退化为同步提交。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657700553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346066,"user_name":"Hugh","can_delete":false,"product_type":"c1","uid":2285931,"ip_address":"","ucode":"77434E01E1D715","user_header":"https://static001.geekbang.org/account/avatar/00/22/e1/6b/74a8b7d8.jpg","comment_is_top":false,"comment_ctime":1652798680,"is_pvip":false,"replies":[{"id":126261,"content":"这是两个层面的复用。GMP对G数据结构的复用是在runtime调度层面，但这种复用 用户层无法控制，G也不是总能被复用，就像sync.Pool中数据项，在一定时间内如果没有goroutine去从池中get，那么还是会被释放的。\n\n当然用户层面实现的goroutine 池也可以增加idle释放的特性(这一讲中的例子不支持)，但这种释放是用户层可控的。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1652822694,"ip_address":"","comment_id":346066,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师您好，请教个问题，之前说过在GMP模型中数据结构G是可以被复用的，那么协程池还有必要吗？因为协程池的一大优势就是复用协程，避免反复创建协程，那么其实go scheduler已经做到了","like_count":1,"discussions":[{"author":{"id":1435733,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e8/55/63189817.jpg","nickname":"我好像一点都不像程序员","note":"","ucode":"F479190923355C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580943,"discussion_content":"给你举个例子，一个是公司层级的调度复用，你无法控制人员流动，一个是你组内的人员调度复用，你可以适当控制，达到减少内耗的作用","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1658411634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572507,"discussion_content":"这是两个层面的复用。GMP对G数据结构的复用是在runtime调度层面，但这种复用 用户层无法控制，G也不是总能被复用，就像sync.Pool中数据项，在一定时间内如果没有goroutine去从池中get，那么还是会被释放的。\n\n当然用户层面实现的goroutine 池也可以增加idle释放的特性(这一讲中的例子不支持)，但这种释放是用户层可控的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1652822694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343782,"user_name":"Geek_as","can_delete":false,"product_type":"c1","uid":1534500,"ip_address":"","ucode":"AB7B70DBC2B5F8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/qhonwcQle1RBufvLdTm4MgSNl554GBXUZtNNH65oYajbbRLxKsZX4hM9vFtrLLpDM0H93ZNWRFAZSrIZC7yAsQ/132","comment_is_top":false,"comment_ctime":1651052596,"is_pvip":false,"replies":[{"id":125588,"content":"demo2使用Workpool2中的returnTask代码如下：\n\nfunc (p *Pool) returnTask(t Task) {\n    go func() {\n        p.tasks &lt;- t\n    }()\n}\n\nreturnTask中创建了一个新goroutine来异步send task，returnTask怎么会卡住呢？","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1651138411,"ip_address":"","comment_id":343782,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师，最后一个例子好像有问题，假如我设置的是当没有活动go worker的时候阻塞，然后当前线程不会预创建，这时候我往池里面添加一个任务，由于没有worker可以接收，导致它走到了default,由于我是设置了获取不到就阻塞,所以我的代码走到了\nif p.block{\n\t\t\tp.tasks &lt;- t\n}\n这里，这时候run方法检测到task管道里有task，就接收下来，前面的p.tasks &lt;- t阻塞释放了，会继续走下去，然后run的话，在接收了管道的task后，执行的下一步操作是returnTask,然后创建活动worker，去执行returnTask返回的task，但出现了神奇的一幕，run的执行流程卡在returnTask的p.tasks &lt;- task中，导致后面的活动worker没法创建，一直卡在returnTask那里，后面我分析了一下，感觉应该是我的tasks是无缓冲队列，所以returnTask执行p.tasks &lt;- task的时候就卡在这里，等待其他人的接收，但这样就有问题了，因为接收操作要么在run的range中，要么是由活动worker接收，因为卡在returnTask这里，所以没法创建活动worker，也就没worker消费，变成了类似于死锁的样子，假如我配置了阻塞，和不预创建，理论上我提交给池里面的所有任务都不会被执行，我试了一下，当提交的任务超过两个就会爆死锁异常，后面我将returnTask这一步动作移动到了创建worker之后，就解决了这个问题","like_count":1,"discussions":[{"author":{"id":1435733,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e8/55/63189817.jpg","nickname":"我好像一点都不像程序员","note":"","ucode":"F479190923355C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580943,"discussion_content":"给你举个例子，一个是公司层级的调度复用，你无法控制人员流动，一个是你组内的人员调度复用，你可以适当控制，达到减少内耗的作用","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1658411634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572507,"discussion_content":"这是两个层面的复用。GMP对G数据结构的复用是在runtime调度层面，但这种复用 用户层无法控制，G也不是总能被复用，就像sync.Pool中数据项，在一定时间内如果没有goroutine去从池中get，那么还是会被释放的。\n\n当然用户层面实现的goroutine 池也可以增加idle释放的特性(这一讲中的例子不支持)，但这种释放是用户层可控的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1652822694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338596,"user_name":"木木","can_delete":false,"product_type":"c1","uid":2704565,"ip_address":"","ucode":"86820F26A27308","user_header":"https://static001.geekbang.org/account/avatar/00/29/44/b5/7eba5a0e.jpg","comment_is_top":false,"comment_ctime":1647587716,"is_pvip":false,"replies":[{"id":123854,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1647810501,"ip_address":"","comment_id":338596,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"学到很多！感谢","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568445,"discussion_content":"demo2使用Workpool2中的returnTask代码如下：\n\nfunc (p *Pool) returnTask(t Task) {\n    go func() {\n        p.tasks &lt;- t\n    }()\n}\n\nreturnTask中创建了一个新goroutine来异步send task，returnTask怎么会卡住呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651138411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335569,"user_name":"快乐的臭豆腐","can_delete":false,"product_type":"c1","uid":1115249,"ip_address":"","ucode":"1E0F2B55FF3023","user_header":"https://static001.geekbang.org/account/avatar/00/11/04/71/7e5d7c85.jpg","comment_is_top":false,"comment_ctime":1645590240,"is_pvip":false,"replies":[{"id":122616,"content":"是阻塞了。tasks是不带缓冲的channel，如果5个worker都在处理task，那么没有空闲的worker去从tasks中读取，这时schedule新task会阻塞。直到有空闲worker。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1645607500,"ip_address":"","comment_id":335569,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师您好，有个地方不是很理解，希望您解答一下\n\n以第一版的WorkPool为例\n我尝试在Schedule函数追加了print函数，\nfmt.Printf(&quot;%s: Scheduling task\\n&quot;, time.Now())\n发现所有的Task并不是一次性加入到pool的\n当pool的capacity=5时，会先加入6个task然后等有task结束后再Schedule剩余的task，请问这是被阻塞了吗？理论上p.active才有capacity限制，p.tasks应该是一次性写入的\n\n\n","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557431,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647810501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333857,"user_name":"Witt","can_delete":false,"product_type":"c1","uid":1005864,"ip_address":"","ucode":"19C8BCA266130A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/28/943709cb.jpg","comment_is_top":false,"comment_ctime":1644564434,"is_pvip":false,"replies":[{"id":122063,"content":"首先这仅是一个demo。goroutine池有很多种实现方式，甚至基于同一种方式，比如文中的channel也有不同的策略设定。也许文中的demo设定的当p.tasks阻塞就返回错误（当p.block=false时）有些不合理。\n\n&quot;让调度时不阻塞，是不是把 task 放到一个队列里排队更合理，再加上一个丢弃策略，类似 Java 中的线程池&quot; -- 很好的提议。这也是一种设计过程的设定，在我的demo的基础上，稍作修改应该就能实现。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1644762667,"ip_address":"","comment_id":333857,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师，既然没有达到最大 worker 数，为什么不是去创建新的 worker 而是直接返回错误呢？这一点不是很理解，不应该是根据 task 自动创建预期内的 worker 直到 worker 数满了再返回没有空闲的 worker 错误吗\n\n再一个就是，让调度时不阻塞，是不是把 task 放到一个队列里排队更合理，再加上一个丢弃策略，类似 Java 中的线程池","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552836,"discussion_content":"是阻塞了。tasks是不带缓冲的channel，如果5个worker都在处理task，那么没有空闲的worker去从tasks中读取，这时schedule新task会阻塞。直到有空闲worker。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645607500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333231,"user_name":"不负青春不负己🤘","can_delete":false,"product_type":"c1","uid":1363671,"ip_address":"","ucode":"A6DD8E8B20EA6E","user_header":"https://static001.geekbang.org/account/avatar/00/14/ce/d7/5315f6ce.jpg","comment_is_top":false,"comment_ctime":1644223329,"is_pvip":false,"replies":[{"id":121816,"content":"如果日常仅是开发一些cli或web，那么go标准库就能满足，没必要弄那么多第三方的框架。关于资料，专栏中的一篇加餐中提到一些，https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;468213 不知道是否满足你的需求。 ","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1644298249,"ip_address":"","comment_id":333231,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"想问一下,我是DBA,平常开发偏封装或者写工具，那是不是要多看一下CLI或者web 的项目，目前是Python做相关的工具，相对我来说，Go的优势就是不要考虑Python库依赖的问题，还有就是好多开源工具都说Go写的,出了问题可以看源代码，老师有推荐进阶的方式书籍或者其他相关的，网上一般都是偏业务方面的，跟工作不相关","like_count":1},{"had_liked":false,"id":332003,"user_name":"lesserror","can_delete":false,"product_type":"c1","uid":1351076,"ip_address":"","ucode":"25A54D1165FCF6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","comment_is_top":false,"comment_ctime":1642955484,"is_pvip":false,"replies":[{"id":121612,"content":"1. 并不是等到main goroutine退出才退出。当Worker pool满员时，这里会走到default分支，跳出该loop，进入到下面那个for循环，后面的for循环才是真正维护这个pool的主循环。\n2. 这篇写的的确有些仓促。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643541735,"ip_address":"","comment_id":332003,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"大白老师，谢谢你这一章节精彩的内容。有以下困惑，麻烦抽空解忧。\n\n1.. 第二版的Goroutine池的实现中，最后的测试运行输出环节中，运行到 run方法 这个Goroutine中时，!p.preAlloc 为true，for无限循环其实一直在运行 这个 case p.active &lt;- struct{}{}:。最后是因为主main Goroutine退出了，运行这个 无限for循环的 Goroutine也跟着退出了，所以这个无限for循环也退出了，可以这么理解吗？\n\n2. Goroutine的运行不确定性，在并发程序中的理解心智负担很大呀，稍微复杂的程序，会很不容易理解程序的运行原理。老师这个课程，对于 Goroutine 在稍微复杂的编发程序中是如何运行的，好像没有过多的解释，很容易让新手不知所以然。至少，最后这个版本的 Goroutine 池的中，最后的测试运行输出应该解释一下，输出为何是这样的。如果不运行，要能想到程序的输出结果，我觉得这才叫完全理解了。我觉得我现在目前很难做到。\n\nPS：returnTask 那里的逻辑能补充说明就好了，刚看到那里也是有点懵（看了评论才理解）。","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549928,"discussion_content":"如果日常仅是开发一些cli或web，那么go标准库就能满足，没必要弄那么多第三方的框架。关于资料，专栏中的一篇加餐中提到一些，https://time.geekbang.org/column/article/468213 不知道是否满足你的需求。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644298250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1363671,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ce/d7/5315f6ce.jpg","nickname":"不负青春不负己🤘","note":"","ucode":"A6DD8E8B20EA6E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":550005,"discussion_content":"日常能够接触到三个项目，一个go写数据库ha(代码走读过，跟日常相关最大),一个是go写的分布式数据库，还有现在做数据库容器化，搞operator的，哪个比较推荐","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1644327266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":549928,"ip_address":"","group_id":0},"score":550005,"extra":""}]},{"author":{"id":1079702,"avatar":"https://static001.geekbang.org/account/avatar/00/10/79/96/fb0d8a65.jpg","nickname":"李亮","note":"","ucode":"E26284C3BF7DF1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592454,"discussion_content":"Powerful command-line tools with Go\nGo for DevOps","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1667412477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331203,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1642483839,"is_pvip":false,"replies":[{"id":121005,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1642488442,"ip_address":"","comment_id":331203,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"实战项目棒棒哒","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546990,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642488442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331093,"user_name":"ゝ骑着小车去兜风。","can_delete":false,"product_type":"c1","uid":2600957,"ip_address":"","ucode":"35F9E5360DF42C","user_header":"https://static001.geekbang.org/account/avatar/00/27/af/fd/a1708649.jpg","comment_is_top":false,"comment_ctime":1642418928,"is_pvip":false,"replies":[{"id":121592,"content":"不知道 在最后实战篇的三节课 是否能初步回答你的问题。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643525140,"ip_address":"","comment_id":331093,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"看了这么长时间的专栏，感觉受益匪浅。之前虽然用过go但是一直没有系统的学习过，在开发过程中也遇到了许多坑。这段时间刷了两次函数方法和接口每次都能发掘到新的知识点，感觉对go有了全新的认识。对于今天这个小项目完全可以看的明白，但是如果说现在让我实现一个类似的协程池，就感觉自己没有这种思想头绪不知道从哪下手解决。我想问老师的是：怎么能够将自己所学的知识和实际的问题场景结合起来去解决实际问题，有哪些建议呢，还需要培养哪些技能？  感谢老师","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546990,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642488442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331034,"user_name":"在下宝龙、","can_delete":false,"product_type":"c1","uid":1618030,"ip_address":"","ucode":"0735B64EB61CAC","user_header":"https://static001.geekbang.org/account/avatar/00/18/b0/6e/921cb700.jpg","comment_is_top":false,"comment_ctime":1642389149,"is_pvip":false,"replies":[{"id":120905,"content":"sleep的2s并没有创建worker啊。这里指定的WithPreAllocWorkers(false)，即不预创建。run阻塞在对tasks channel的读取上，直到后面main goroutine第一次调用Schedule写入一个task，这时run才会开始按需创建Worker。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1642412036,"ip_address":"","comment_id":331034,"utype":1}],"discussion_count":5,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"最后一个例子，p := workerpool.New(5, workerpool.WithPreAllocWorkers(false),workerpool.WithBlock(false))    \ntime.Sleep(time.Second * 2)\n都给了两秒创建worker 都没创建好worker 吗？，按照代码的意思，即使不允许预先分配worker，作者run里面，继续分配worker 了啊，并且一开始没有task，直接就走default break loop了，感觉是不是多此一举了这里写的，break loop之后，就开始根据active 创建worker，设置是 5，那两秒肯定创建5个worker，所以不懂为甚么说woker不够。 是不是 p.returnTask(t) 这个缘故","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549035,"discussion_content":"不知道 在最后实战篇的三节课 是否能初步回答你的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643525140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331019,"user_name":"无名无姓","can_delete":false,"product_type":"c1","uid":2621412,"ip_address":"","ucode":"487BD5AA2CD305","user_header":"https://static001.geekbang.org/account/avatar/00/27/ff/e4/927547a9.jpg","comment_is_top":false,"comment_ctime":1642382389,"is_pvip":false,"replies":[{"id":120906,"content":"可以把问题提的具体一点😁。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1642412062,"ip_address":"","comment_id":331019,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"还是有些不理解","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546743,"discussion_content":"可以把问题提的具体一点😁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642412063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390461,"user_name":"Geek_b745bf","can_delete":false,"product_type":"c1","uid":2104889,"ip_address":"湖北","ucode":"6EB395F6AE0C15","user_header":"","comment_is_top":false,"comment_ctime":1715399231,"is_pvip":false,"replies":[{"id":142036,"content":"专栏中的代码更多是为了讲解知识点目的使用，不建议在生产中使用。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1715418642,"ip_address":"北京","comment_id":390461,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"老师，假如是运用在生产环境，以这个示例来看大概还需要补充一些什么呢","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":644674,"discussion_content":"专栏中的代码更多是为了讲解知识点目的使用，不建议在生产中使用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1715418642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383663,"user_name":"爱吃胡萝卜","can_delete":false,"product_type":"c1","uid":1459413,"ip_address":"广东","ucode":"35FCF84D1E04C5","user_header":"https://static001.geekbang.org/account/avatar/00/16/44/d5/ca522e83.jpg","comment_is_top":false,"comment_ctime":1699423974,"is_pvip":false,"replies":[{"id":139930,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1699481986,"ip_address":"辽宁","comment_id":383663,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"对于demo2个人 认为写的不好，一下是我的个人浅见\n\n```go\n&#47;&#47; New 函数代码片段\nif p.preAlloc {\n     &#47;&#47; create all goroutines and send into works channel \n     for i := 0; i &lt; p.capacity; i++ { \n        p.newWorker(i + 1) p.active &lt;- struct{}{}\n        } \n    }\n```\n\n```go\n&#47;&#47; run函数代码片段\nfor { \n    select { \n        case &lt;-p.quit: return \n        case p.active &lt;- struct{}{}: \n        &#47;&#47; create a new worker \n            idx++ \n            p.newWorker(idx) \n        } \n    }\n```\n\n这两个代码片段是等效的， 首先在new函数里 &lt;-p.quit 这个值是不可能触发的，即demo1事实上就是实现的preAlloc策略，\n我们应该只需要添加！PreAlloc策略即可","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631388,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699481986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":380524,"user_name":"phylony-lu","can_delete":false,"product_type":"c1","uid":1342724,"ip_address":"上海","ucode":"00666300AD0E7F","user_header":"https://static001.geekbang.org/account/avatar/00/14/7d/04/d606b6a8.jpg","comment_is_top":false,"comment_ctime":1693757832,"is_pvip":false,"replies":[{"id":138580,"content":"调用returnTask，主要是因为是在p.preAlloc=false的情况下，也就是不预先创建worker pool的情况下。当ScheduleTask后，由task来驱动worker的创建，但task已经被读取了出来，该task应该重新放回channel，由worker取出并执行。嗯，这里的确不够优雅。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1693814560,"ip_address":"北京","comment_id":380524,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"老师，我还是有些不是很明白，为什么要在run函数里执行for t := range p.tasks，tasks是无缓存得channel，默认没有推送就是会阻塞，有推送就是会进入循环，为什么还需要调用returnTask再推送一次消息给tasks得channel呢？这样做是不是要等到该task被消费才会允许再次推送值进来？\t\t\t\nfmt.Println(&quot;Add:&quot;, idx, t)\n&#47;&#47;p.returnTask(t)\n在newworkder得函数里select也一直在监听&lt;-p.task，有更新就会调用。那理论上来说，是不是可以将run得代码精简为去掉loop的剩余部分。因为p.acitve的channel堆满后也就是不会再调用goroutine了。不知道这样理解对不对，请老师帮忙解答疑惑，感谢。\n","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":627114,"discussion_content":"调用returnTask，主要是因为是在p.preAlloc=false的情况下，也就是不预先创建worker pool的情况下。当ScheduleTask后，由task来驱动worker的创建，但task已经被读取了出来，该task应该重新放回channel，由worker取出并执行。嗯，这里的确不够优雅。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1693814561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347732,"user_name":"Aeins","can_delete":false,"product_type":"c1","uid":1045910,"ip_address":"","ucode":"D5BF220767541D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/96/0cf9f3c7.jpg","comment_is_top":false,"comment_ctime":1654358903,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"1. demo01 的实现，已经是一种预分配的实现，demo02 在 New 里面 去预分配，没有必要\n\n2.  demo02 ，task 取出来，再放回去，总感觉不优雅。\n","like_count":3,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":627114,"discussion_content":"调用returnTask，主要是因为是在p.preAlloc=false的情况下，也就是不预先创建worker pool的情况下。当ScheduleTask后，由task来驱动worker的创建，但task已经被读取了出来，该task应该重新放回channel，由worker取出并执行。嗯，这里的确不够优雅。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1693814561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333231,"user_name":"不负青春不负己🤘","can_delete":false,"product_type":"c1","uid":1363671,"ip_address":"","ucode":"A6DD8E8B20EA6E","user_header":"https://static001.geekbang.org/account/avatar/00/14/ce/d7/5315f6ce.jpg","comment_is_top":false,"comment_ctime":1644223329,"is_pvip":false,"replies":[{"id":121816,"content":"如果日常仅是开发一些cli或web，那么go标准库就能满足，没必要弄那么多第三方的框架。关于资料，专栏中的一篇加餐中提到一些，https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;468213 不知道是否满足你的需求。 ","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1644298249,"ip_address":"","comment_id":333231,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"想问一下,我是DBA,平常开发偏封装或者写工具，那是不是要多看一下CLI或者web 的项目，目前是Python做相关的工具，相对我来说，Go的优势就是不要考虑Python库依赖的问题，还有就是好多开源工具都说Go写的,出了问题可以看源代码，老师有推荐进阶的方式书籍或者其他相关的，网上一般都是偏业务方面的，跟工作不相关","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549928,"discussion_content":"如果日常仅是开发一些cli或web，那么go标准库就能满足，没必要弄那么多第三方的框架。关于资料，专栏中的一篇加餐中提到一些，https://time.geekbang.org/column/article/468213 不知道是否满足你的需求。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644298250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1363671,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ce/d7/5315f6ce.jpg","nickname":"不负青春不负己🤘","note":"","ucode":"A6DD8E8B20EA6E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":550005,"discussion_content":"日常能够接触到三个项目，一个go写数据库ha(代码走读过，跟日常相关最大),一个是go写的分布式数据库，还有现在做数据库容器化，搞operator的，哪个比较推荐","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1644327266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":549928,"ip_address":"","group_id":0},"score":550005,"extra":""}]},{"author":{"id":1079702,"avatar":"https://static001.geekbang.org/account/avatar/00/10/79/96/fb0d8a65.jpg","nickname":"李亮","note":"","ucode":"E26284C3BF7DF1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592454,"discussion_content":"Powerful command-line tools with Go\nGo for DevOps","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1667412477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332003,"user_name":"lesserror","can_delete":false,"product_type":"c1","uid":1351076,"ip_address":"","ucode":"25A54D1165FCF6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","comment_is_top":false,"comment_ctime":1642955484,"is_pvip":false,"replies":[{"id":121612,"content":"1. 并不是等到main goroutine退出才退出。当Worker pool满员时，这里会走到default分支，跳出该loop，进入到下面那个for循环，后面的for循环才是真正维护这个pool的主循环。\n2. 这篇写的的确有些仓促。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643541735,"ip_address":"","comment_id":332003,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"大白老师，谢谢你这一章节精彩的内容。有以下困惑，麻烦抽空解忧。\n\n1.. 第二版的Goroutine池的实现中，最后的测试运行输出环节中，运行到 run方法 这个Goroutine中时，!p.preAlloc 为true，for无限循环其实一直在运行 这个 case p.active &lt;- struct{}{}:。最后是因为主main Goroutine退出了，运行这个 无限for循环的 Goroutine也跟着退出了，所以这个无限for循环也退出了，可以这么理解吗？\n\n2. Goroutine的运行不确定性，在并发程序中的理解心智负担很大呀，稍微复杂的程序，会很不容易理解程序的运行原理。老师这个课程，对于 Goroutine 在稍微复杂的编发程序中是如何运行的，好像没有过多的解释，很容易让新手不知所以然。至少，最后这个版本的 Goroutine 池的中，最后的测试运行输出应该解释一下，输出为何是这样的。如果不运行，要能想到程序的输出结果，我觉得这才叫完全理解了。我觉得我现在目前很难做到。\n\nPS：returnTask 那里的逻辑能补充说明就好了，刚看到那里也是有点懵（看了评论才理解）。","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549072,"discussion_content":"1. 并不是等到main goroutine退出才退出。当Worker pool满员时，这里会走到default分支，跳出该loop，进入到下面那个for循环，后面的for循环才是真正维护这个pool的主循环。\n2. 这篇写的的确有些仓促。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643541735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331203,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1642483839,"is_pvip":false,"replies":[{"id":121005,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1642488442,"ip_address":"","comment_id":331203,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"实战项目棒棒哒","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549072,"discussion_content":"1. 并不是等到main goroutine退出才退出。当Worker pool满员时，这里会走到default分支，跳出该loop，进入到下面那个for循环，后面的for循环才是真正维护这个pool的主循环。\n2. 这篇写的的确有些仓促。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643541735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331093,"user_name":"ゝ骑着小车去兜风。","can_delete":false,"product_type":"c1","uid":2600957,"ip_address":"","ucode":"35F9E5360DF42C","user_header":"https://static001.geekbang.org/account/avatar/00/27/af/fd/a1708649.jpg","comment_is_top":false,"comment_ctime":1642418928,"is_pvip":false,"replies":[{"id":121592,"content":"不知道 在最后实战篇的三节课 是否能初步回答你的问题。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643525140,"ip_address":"","comment_id":331093,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"看了这么长时间的专栏，感觉受益匪浅。之前虽然用过go但是一直没有系统的学习过，在开发过程中也遇到了许多坑。这段时间刷了两次函数方法和接口每次都能发掘到新的知识点，感觉对go有了全新的认识。对于今天这个小项目完全可以看的明白，但是如果说现在让我实现一个类似的协程池，就感觉自己没有这种思想头绪不知道从哪下手解决。我想问老师的是：怎么能够将自己所学的知识和实际的问题场景结合起来去解决实际问题，有哪些建议呢，还需要培养哪些技能？  感谢老师","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549035,"discussion_content":"不知道 在最后实战篇的三节课 是否能初步回答你的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643525140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331034,"user_name":"在下宝龙、","can_delete":false,"product_type":"c1","uid":1618030,"ip_address":"","ucode":"0735B64EB61CAC","user_header":"https://static001.geekbang.org/account/avatar/00/18/b0/6e/921cb700.jpg","comment_is_top":false,"comment_ctime":1642389149,"is_pvip":false,"replies":[{"id":120905,"content":"sleep的2s并没有创建worker啊。这里指定的WithPreAllocWorkers(false)，即不预创建。run阻塞在对tasks channel的读取上，直到后面main goroutine第一次调用Schedule写入一个task，这时run才会开始按需创建Worker。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1642412036,"ip_address":"","comment_id":331034,"utype":1}],"discussion_count":5,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"最后一个例子，p := workerpool.New(5, workerpool.WithPreAllocWorkers(false),workerpool.WithBlock(false))    \ntime.Sleep(time.Second * 2)\n都给了两秒创建worker 都没创建好worker 吗？，按照代码的意思，即使不允许预先分配worker，作者run里面，继续分配worker 了啊，并且一开始没有task，直接就走default break loop了，感觉是不是多此一举了这里写的，break loop之后，就开始根据active 创建worker，设置是 5，那两秒肯定创建5个worker，所以不懂为甚么说woker不够。 是不是 p.returnTask(t) 这个缘故","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546741,"discussion_content":"sleep的2s并没有创建worker啊。这里指定的WithPreAllocWorkers(false)，即不预创建。run阻塞在对tasks channel的读取上，直到后面main goroutine第一次调用Schedule写入一个task，这时run才会开始按需创建Worker。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642412036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1097315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/be/63/ad364db5.jpg","nickname":"王哲","note":"","ucode":"72FE449A06BD1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546760,"discussion_content":"但是在并发调用Schedule的时候，由于不确定 case p.tasks &lt;- t 写入 channel 的速度快还是 for t := range p.tasks 中读取 channel 的速度快，从而会导致并发写入时，可能之前写入 channel 中的 task 尚未处理（没有创建对应的worker），导致直接退出。\n将代码修改如下后可保证正常执行：\nfunc main() {\n\tp := workerpool.New(5, workerpool.WithPreAllocWorkers(false), workerpool.WithBlock(false))\n\n\ttime.Sleep(10 * time.Millisecond)\n\n\tfor i := 0; i &lt; 10; i++ {\n\t\terr := p.Schedule(func() {\n\t\t\ttime.Sleep(time.Second * 3)\n\t\t})\n\t\ttime.Sleep(10 * time.Millisecond)\n\t\tif err != nil {\n\t\t\tfmt.Printf(&#34;task[%d]: error: %s\\n&#34;, i, err.Error())\n\t\t}\n\t}\n\n\tp.Free()\n}","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1642417203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1175507,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ef/d3/241d0b84.jpg","nickname":"upup","note":"","ucode":"25DB114677EF58","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575326,"discussion_content":"“run阻塞在对tasks channel的读取上”，当没有发送端的时候，for range channel的时候，接收端会阻塞的；当来了task之后，会创建新的worker，如果有5个task，pool cap为3的话，那么只能创建3个worker，在第四次执行循环体的时候，才会执行到default分支；所以上面的两个case分支是可以用到的，也就不是“多此一举”；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654748756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548134,"discussion_content":"兄弟，我觉得你理解错了。这里的Schedule并不是并发调用的呀。只是在for循环中调用呀。你这只是添加了sleep的时间呀。我运行和老师的结果一样呀。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643036556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546824,"discussion_content":"一开始和楼主一样有疑惑，自己写代码测试了下，for t := range p.tasks 那里是会阻塞住的（因为 New 时 p.tasks 还是空的），所以调用 Schedule 之前 Sleep 的那 2 秒钟其实也是不会创建出 workers 的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642433183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331019,"user_name":"无名无姓","can_delete":false,"product_type":"c1","uid":2621412,"ip_address":"","ucode":"487BD5AA2CD305","user_header":"https://static001.geekbang.org/account/avatar/00/27/ff/e4/927547a9.jpg","comment_is_top":false,"comment_ctime":1642382389,"is_pvip":false,"replies":[{"id":120906,"content":"可以把问题提的具体一点😁。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1642412062,"ip_address":"","comment_id":331019,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"还是有些不理解","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546741,"discussion_content":"sleep的2s并没有创建worker啊。这里指定的WithPreAllocWorkers(false)，即不预创建。run阻塞在对tasks channel的读取上，直到后面main goroutine第一次调用Schedule写入一个task，这时run才会开始按需创建Worker。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642412036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1097315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/be/63/ad364db5.jpg","nickname":"王哲","note":"","ucode":"72FE449A06BD1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546760,"discussion_content":"但是在并发调用Schedule的时候，由于不确定 case p.tasks &lt;- t 写入 channel 的速度快还是 for t := range p.tasks 中读取 channel 的速度快，从而会导致并发写入时，可能之前写入 channel 中的 task 尚未处理（没有创建对应的worker），导致直接退出。\n将代码修改如下后可保证正常执行：\nfunc main() {\n\tp := workerpool.New(5, workerpool.WithPreAllocWorkers(false), workerpool.WithBlock(false))\n\n\ttime.Sleep(10 * time.Millisecond)\n\n\tfor i := 0; i &lt; 10; i++ {\n\t\terr := p.Schedule(func() {\n\t\t\ttime.Sleep(time.Second * 3)\n\t\t})\n\t\ttime.Sleep(10 * time.Millisecond)\n\t\tif err != nil {\n\t\t\tfmt.Printf(&#34;task[%d]: error: %s\\n&#34;, i, err.Error())\n\t\t}\n\t}\n\n\tp.Free()\n}","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1642417203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1175507,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ef/d3/241d0b84.jpg","nickname":"upup","note":"","ucode":"25DB114677EF58","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575326,"discussion_content":"“run阻塞在对tasks channel的读取上”，当没有发送端的时候，for range channel的时候，接收端会阻塞的；当来了task之后，会创建新的worker，如果有5个task，pool cap为3的话，那么只能创建3个worker，在第四次执行循环体的时候，才会执行到default分支；所以上面的两个case分支是可以用到的，也就不是“多此一举”；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654748756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548134,"discussion_content":"兄弟，我觉得你理解错了。这里的Schedule并不是并发调用的呀。只是在for循环中调用呀。你这只是添加了sleep的时间呀。我运行和老师的结果一样呀。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643036556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546824,"discussion_content":"一开始和楼主一样有疑惑，自己写代码测试了下，for t := range p.tasks 那里是会阻塞住的（因为 New 时 p.tasks 还是空的），所以调用 Schedule 之前 Sleep 的那 2 秒钟其实也是不会创建出 workers 的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642433183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390461,"user_name":"Geek_b745bf","can_delete":false,"product_type":"c1","uid":2104889,"ip_address":"湖北","ucode":"6EB395F6AE0C15","user_header":"","comment_is_top":false,"comment_ctime":1715399231,"is_pvip":false,"replies":[{"id":142036,"content":"专栏中的代码更多是为了讲解知识点目的使用，不建议在生产中使用。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1715418642,"ip_address":"北京","comment_id":390461,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"老师，假如是运用在生产环境，以这个示例来看大概还需要补充一些什么呢","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546743,"discussion_content":"可以把问题提的具体一点😁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642412063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383663,"user_name":"爱吃胡萝卜","can_delete":false,"product_type":"c1","uid":1459413,"ip_address":"广东","ucode":"35FCF84D1E04C5","user_header":"https://static001.geekbang.org/account/avatar/00/16/44/d5/ca522e83.jpg","comment_is_top":false,"comment_ctime":1699423974,"is_pvip":false,"replies":[{"id":139930,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1699481986,"ip_address":"辽宁","comment_id":383663,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"对于demo2个人 认为写的不好，一下是我的个人浅见\n\n```go\n&#47;&#47; New 函数代码片段\nif p.preAlloc {\n     &#47;&#47; create all goroutines and send into works channel \n     for i := 0; i &lt; p.capacity; i++ { \n        p.newWorker(i + 1) p.active &lt;- struct{}{}\n        } \n    }\n```\n\n```go\n&#47;&#47; run函数代码片段\nfor { \n    select { \n        case &lt;-p.quit: return \n        case p.active &lt;- struct{}{}: \n        &#47;&#47; create a new worker \n            idx++ \n            p.newWorker(idx) \n        } \n    }\n```\n\n这两个代码片段是等效的， 首先在new函数里 &lt;-p.quit 这个值是不可能触发的，即demo1事实上就是实现的preAlloc策略，\n我们应该只需要添加！PreAlloc策略即可","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":644674,"discussion_content":"专栏中的代码更多是为了讲解知识点目的使用，不建议在生产中使用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1715418642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":380524,"user_name":"phylony-lu","can_delete":false,"product_type":"c1","uid":1342724,"ip_address":"上海","ucode":"00666300AD0E7F","user_header":"https://static001.geekbang.org/account/avatar/00/14/7d/04/d606b6a8.jpg","comment_is_top":false,"comment_ctime":1693757832,"is_pvip":false,"replies":[{"id":138580,"content":"调用returnTask，主要是因为是在p.preAlloc=false的情况下，也就是不预先创建worker pool的情况下。当ScheduleTask后，由task来驱动worker的创建，但task已经被读取了出来，该task应该重新放回channel，由worker取出并执行。嗯，这里的确不够优雅。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1693814560,"ip_address":"北京","comment_id":380524,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"老师，我还是有些不是很明白，为什么要在run函数里执行for t := range p.tasks，tasks是无缓存得channel，默认没有推送就是会阻塞，有推送就是会进入循环，为什么还需要调用returnTask再推送一次消息给tasks得channel呢？这样做是不是要等到该task被消费才会允许再次推送值进来？\t\t\t\nfmt.Println(&quot;Add:&quot;, idx, t)\n&#47;&#47;p.returnTask(t)\n在newworkder得函数里select也一直在监听&lt;-p.task，有更新就会调用。那理论上来说，是不是可以将run得代码精简为去掉loop的剩余部分。因为p.acitve的channel堆满后也就是不会再调用goroutine了。不知道这样理解对不对，请老师帮忙解答疑惑，感谢。\n","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631388,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699481986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347732,"user_name":"Aeins","can_delete":false,"product_type":"c1","uid":1045910,"ip_address":"","ucode":"D5BF220767541D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/96/0cf9f3c7.jpg","comment_is_top":false,"comment_ctime":1654358903,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"1. demo01 的实现，已经是一种预分配的实现，demo02 在 New 里面 去预分配，没有必要\n\n2.  demo02 ，task 取出来，再放回去，总感觉不优雅。\n","like_count":3},{"had_liked":false,"id":351585,"user_name":"曾祥金","can_delete":false,"product_type":"c1","uid":2362279,"ip_address":"","ucode":"CBBB7FC1EA00D6","user_header":"","comment_is_top":false,"comment_ctime":1657960956,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"感觉退出可以用context处理","like_count":1},{"had_liked":false,"id":331863,"user_name":"gamePlayer","can_delete":false,"product_type":"c1","uid":2890781,"ip_address":"","ucode":"A340ED6240F30A","user_header":"","comment_is_top":false,"comment_ctime":1642837691,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"为什么要搞协程池，go的优势何在，心智负担极高，与其选择外边良莠不齐的实现，何不用java juc的线程池? 人云亦云，搞的go语言越来越辣鸡\n","like_count":1},{"had_liked":false,"id":351585,"user_name":"曾祥金","can_delete":false,"product_type":"c1","uid":2362279,"ip_address":"","ucode":"CBBB7FC1EA00D6","user_header":"","comment_is_top":false,"comment_ctime":1657960956,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"感觉退出可以用context处理","like_count":1},{"had_liked":false,"id":331863,"user_name":"gamePlayer","can_delete":false,"product_type":"c1","uid":2890781,"ip_address":"","ucode":"A340ED6240F30A","user_header":"","comment_is_top":false,"comment_ctime":1642837691,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"为什么要搞协程池，go的优势何在，心智负担极高，与其选择外边良莠不齐的实现，何不用java juc的线程池? 人云亦云，搞的go语言越来越辣鸡\n","like_count":1}]}