{"id":189042,"title":"23 | 数字计算：介绍线性代数和数值计算库","content":"<p>你好，我是吴咏炜。</p><p>科学计算在今天已经完全可以使用 C++ 了。我不是从事科学计算这一领域的工作的，不过，在工作中也多多少少接触到了一些计算相关的库。今天，我就给你介绍几个有用的计算库。</p><h2>Armadillo</h2><p>说到计算，你可能首先会想到矩阵、矢量这些东西吧？这些计算，确实就是科学计算中的常见内容了。这些领域的标准，即是一些 Fortran 库定下的，如：</p><ul>\n<li>BLAS <span class=\"orange\">[1]</span></li>\n<li>LAPACK <span class=\"orange\">[2]</span></li>\n<li>ARPACK <span class=\"orange\">[3]</span></li>\n</ul><p>它们的实现倒不一定用 Fortran，尤其是 BLAS：</p><ul>\n<li>OpenBLAS <span class=\"orange\">[4]</span> 是用汇编和 C 语言写的</li>\n<li>Intel MKL <span class=\"orange\">[5]</span> 有针对 Intel 的特定 CPU 指令集进行优化的汇编代码</li>\n<li>Mir GLAS <span class=\"orange\">[6]</span> 是用 D 语言写的</li>\n</ul><p>不管实现的方法是哪一种，暴露出来的函数名字是这个样子的：</p><ul>\n<li><code>ddot</code></li>\n<li><code>dgemv</code></li>\n<li><code>dsyrk</code></li>\n<li><code>sgemm</code></li>\n<li>……</li>\n</ul><p>这个接口的唯一好处，应该就是，它是跨语言并且跨实现的😅。所以，使用这些函数时，你可以切换不同的实现，而不需要更改代码。唯一需要修改的，通常就是链接库的名字或位置而已。</p><p>假设我们需要做一个简单的矩阵运算，对一个矢量进行旋转：</p><p>$$<br>\n\\begin{aligned}<br>\n\\mathbf{P} &amp;= \\begin{bmatrix} 1 \\\\\\ 0 \\end{bmatrix}\\\\\\<br>\n\\mathbf{R} &amp;= \\begin{bmatrix}<br>\n\\cos(\\theta) &amp; -\\sin(\\theta) \\\\\\<br>\n\\sin(\\theta) &amp; \\cos(\\theta)\\end{bmatrix}\\\\\\<br>\n\\mathbf{P^\\prime} &amp;= \\mathbf{R} \\cdot \\mathbf{P}<br>\n\\end{aligned}<br>\n$$</p><!-- [[[read_end]]] --><p>这么一个简单的操作，用纯 C 接口的 BLAS 来表达，有点痛苦：你需要使用的大概是 <code>dgemv_</code> 函数，而这个函数需要 11 个参数！我查阅了一下资料之后，也就放弃了给你展示一下如何调用 <code>dgemv_</code> 的企图，我们还是老老实实地看一下在现代 C++ 里的写法吧：</p><pre><code class=\"language-c++\">#include &lt;armadillo&gt;\n#include &lt;cmath&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n  // 代表位置的向量\n  arma::vec pos{1.0, 0.0};\n\n  // 旋转矩阵\n  auto&amp; pi = arma::datum::pi;\n  double angle = pi / 2;\n  arma::mat rot = {\n    {cos(angle), -sin(angle)},\n    {sin(angle), cos(angle)}};\n\n  cout &lt;&lt; \"Current position:\\n\"\n       &lt;&lt; pos;\n  cout &lt;&lt; \"Rotating \"\n       &lt;&lt; angle * 180 / pi\n       &lt;&lt; \" deg\\n\";\n\n  arma::vec new_pos = rot * pos;\n  cout &lt;&lt; \"New position:\\n\"\n       &lt;&lt; new_pos;\n}\n</code></pre><p>这就是使用 Armadillo <span class=\"orange\">[7]</span> 库来实现矢量旋转的代码。这个代码，基本就是上面的数学公式的一一对应了。代码相当直白，我只需要稍稍说明一下：</p><ul>\n<li>所有的 Armadillo 的类型和函数都定义在 <code>arma</code> 名空间下。</li>\n<li>Armadillo 在 <code>arma::datum</code> 下定义了包括 pi 和 e 在内的一些数学常量。</li>\n<li><code>vec</code> 是矢量类型，<code>mat</code> 是矩阵类型，这两个类型实际上是 <code>Col&lt;double&gt;</code> 和 <code>Mat&lt;double&gt;</code> 的缩写别名。</li>\n<li>Armadillo 支持使用 C++11 的列表初始化语法来初始化对象。</li>\n<li>Armadillo 支持使用流来输出对象。</li>\n</ul><p>上面代码的输出为：</p><blockquote>\n<p><code>Current position:</code><br>\n<code>1.0000</code><br>\n<code>0</code><br>\n<code>Rotating 90 deg</code><br>\n<code>New position:</code><br>\n<code>6.1232e-17</code><br>\n<code>1.0000e+00</code></p>\n</blockquote><p>输出里面的 <code>6.1232e-17</code> 是浮点数表示不精确的后果，把它理解成 0 就对了。</p><p>我们上面已经提到了 <code>vec</code> 实际上是 <code>Col&lt;double&gt;</code>，双精度浮点数类型的列矢量。自然，Armadillo 也有行矢量 <code>rowvec</code>（即 <code>Row&lt;double&gt;</code>），也可以使用其他的数字类型，如 <code>int</code>、 <code>float</code> 和 <code>complex&lt;float&gt;</code>。此外，除了大小不确定的线性代数对象之外，Armadillo 也提供了固定大小的子类型，如 <code>vec::fixed&lt;2&gt;</code> 和 <code>mat::fixed&lt;2, 2&gt;</code>；为方便使用，还提供了不少别名，如 <code>imat22</code> 代表 <code>Mat&lt;int&gt;::fixed&lt;2, 2&gt;</code> 等。固定大小的对象不需要动态内存分配，使用上有一定的性能优势。</p><p>Armadillo 是一个非常复杂的库，它的头文件数量超过了 500 个。我们今天不可能、也不必要描述它的所有功能，只能稍稍部分列举一下：</p><ul>\n<li>除了目前提到的列矢量、行矢量和矩阵外，Armadillo 也支持三维的数据立方体，<code>Cube</code> 模板。</li>\n<li>Armadillo 支持稀疏矩阵，<code>SpMat</code> 模板。</li>\n<li>除了数学上的加、减、乘运算，Armadillo 支持按元素的乘法、除法、相等、不等、小于比较等（使用 <code>%</code>、<code>/</code>、<code>==</code>、<code>!=</code>、<code>&lt;</code> 等）运算，结果的大小跟参数相同，每个元素是相应运算的结果。某些运算符可能不太直观，尤其是 <code>%</code>（不是取模）和 <code>==</code>（返回不是单个布尔值，而是矩阵）。</li>\n<li>Armadillo 支持对非固定大小的矢量、矩阵和立方体，改变其大小（<code>.reshape()</code> 和 <code>resize()</code>）。</li>\n<li>Armadillo 可以方便地按行（<code>.col()</code>）、列（<code>.row()</code>）、对角线（<code>.diag()</code>）读写矩阵的内容，包括用一个矢量去改写矩阵的对角线。</li>\n<li>Armadillo 可以方便地对矩阵进行转置（<code>.t()</code>）、求反（<code>.inv()</code>）。</li>\n<li>Armadillo 可以对矩阵进行特征分解（<code>eigen_sym()</code>、<code>eigen_gen()</code> 等）。</li>\n<li>Armadillo 支持傅立叶变换（<code>fft()</code>、<code>fft2()</code> 等）。</li>\n<li>Armadillo 支持常见的统计计算，如平均值、中位值、标准偏差等（<code>mean()</code>、<code>median()</code>、<code>stddev()</code> 等）。</li>\n<li>Armadillo 支持多项式方程求根（<code>roots</code>）。</li>\n<li>Armadillo 支持 k‐平均聚类（<em>k</em>-means clustering）算法（<code>kmeans</code>）。</li>\n<li>等等。</li>\n</ul><p>如果你需要用到这些功能，你可以自己去查看一下具体的细节，我们这儿只提几个与编程有关的细节。</p><h3>对象的输出</h3><p>我们上面已经展示了直接把对象输出到一个流。我们的写法是：</p><pre><code class=\"language-c++\">cout &lt;&lt; \"Current position:\\n\"\n     &lt;&lt; pos;\n</code></pre><p>实际上基本等价于调用 <code>print</code> 成员函数：</p><pre><code class=\"language-c++\">pos.print(\"Current position:\");\n</code></pre><p>这个写法可能会更简单些。此外，在这两种情况，输出的格式都是 Armadillo 自动控制的。如果你希望自己控制的话，可以使用 <code>raw_print</code> 成员函数。比如，对于上面代码里对 <code>new_pos</code> 的输出，我们可以写成（需要包含 &lt;iomanip&gt;）：</p><pre><code class=\"language-c++\">cout &lt;&lt; fixed &lt;&lt; setw(9)\n     &lt;&lt; setprecision(4);\nnew_pos.raw_print(\n  cout, \"New position:\");\n</code></pre><p>这种情况下，你可以有效地对格式、宽度和精度进行设置，能得到：</p><blockquote>\n<p><code>New position:</code><br>\n<code>0.0000</code><br>\n<code>1.0000</code></p>\n</blockquote><p>记得我们说过 <code>vec</code> 是 <code>Col&lt;double&gt;</code> 的别名，因此输出是多行的。我们要输出成单行的话，转置（transpose）一下就可以了：</p><pre><code class=\"language-c++\">cout &lt;&lt; fixed &lt;&lt; setw(9)\n     &lt;&lt; setprecision(4);\nnew_pos.t().raw_print(\n  cout, \"New position:\");\n</code></pre><p>输出为：</p><blockquote>\n<p><code>New position:</code><br>\n<code>0.0000 1.0000</code></p>\n</blockquote><h3>表达式模板</h3><p>如果你奇怪前面 <code>dgemv_</code> 为什么有 11 个参数，这里有个我没有提的细节是，它执行的实际上是个复合操作：</p><p>$$<br>\n\\mathbf{y} \\gets \\alpha\\mathbf{A}\\cdot\\mathbf{x} + \\beta\\mathbf{y}<br>\n$$</p><p>如果你只是简单地做乘法的话，就相当于 $\\alpha$ 为 1、$\\beta$ 为 0 的特殊情况。那么问题来了，如果你真的写了类似于上面这样的公式的话，编译器和线性代数库能不能转成合适的调用、而没有额外的开销呢？</p><p>答案是，至少在某些情况下是可以的。秘诀就是表达式模板（expression template）<span class=\"orange\">[8]</span>。</p><p>那什么是表达式模板呢？我们先回过去看我上面的例子。有没有注意到我写的是：</p><pre><code class=\"language-c++\">arma::vec new_pos = rot * pos;\n</code></pre><p>而没有使用 <code>auto</code> 来声明？</p><p>其中部分的原因是，<code>rot * pos</code> 的类型并不是 <code>vec</code>，而是：</p><pre><code class=\"language-c++\">const Glue&lt;Mat&lt;double&gt;, Col&lt;double&gt;, glue_times&gt;\n</code></pre><p>换句话说，结果是一个表达式，而并没有实际进行计算。如果我用 <code>auto</code> 的话，行为上似乎一切都正常，但我每次输出这个结果时，都会重新进行一次矩阵的乘法！而我用 <code>arma::vec</code> 接收的话，构造时就直接进行了计算，存储了表达式的结果。</p><p>上面的简单例子不能实际触发对 <code>dgemv_</code> 的调用，我用下面的代码实际验证出了表达式模板产生的优化（<code>fill::randu</code> 表示对矢量和矩阵的内容进行随机填充）：</p><pre><code class=\"language-c++\">#include &lt;armadillo&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\nusing namespace arma;\n\nint main()\n{\n  vec x(8, fill::randu);\n  mat r(8, 8, fill::randu);\n  vec result = 2.5 * r * x;\n  cout &lt;&lt; result;\n}\n</code></pre><p>赋值语句右边的类型是：</p><pre><code class=\"language-c++\">const Glue&lt;eOp&lt;Mat&lt;double&gt;,\n               eop_scalar_times&gt;,\n           Col&lt;double&gt;, glue_times&gt;\n</code></pre><p>当使用这个表达式构造 <code>vec</code> 时，就会实际发生对 <code>dgemv_</code> 的调用。我也确实跟踪到了，在将要调用 <code>dgemv_</code> 时，标量值 2.5 确实在参数 <code>alpha</code> 指向的位置上（这个接口的参数都是指针）。</p><p>从上面的描述可以看到，表达式模板是把双刃剑：既可以提高代码的性能，又能增加代码被误用的可能性。在可能用到表达式模板的地方，你需要注意这些问题。</p><h3>平台细节</h3><p>Armadillo 的文档里说明了如何从源代码进行安装，但在 Linux 和 macOS 下通过包管理器安装可能是更快的方式。在 CentOS 下可使用 <code>sudo yum install armadillo-devel</code>，在 macOS 下可使用 <code>brew install armadillo</code>。使用包管理器一般也会同时安装常见的依赖软件，如 ARPACK 和 OpenBLAS。</p><p>在 Windows 上，Armadillo 的安装包里自带了一个基本版本的 64 位 BLAS 和 LAPACK 库。如果需要更高性能或 32 位版本的话，就需要自己另外去安装了。除非你只是做一些非常简单的线性代数计算（就像我今天的例子），那直接告诉 Armadillo 不要使用第三方库也行。</p><blockquote>\n<p><code>cl /EHsc /DARMA_DONT_USE_BLAS /DARMA_DONT_USE_LAPACK …</code></p>\n</blockquote><h2>Boost.Multiprecision</h2><p>众所周知，C 和 C++（甚至推而广之到大部分的常用编程语言）里的数值类型是有精度限制的。比如，上一讲的代码里我们就用到了 <code>INT_MIN</code>，最小的整数。很多情况下，使用目前这些类型是够用的（最高一般是 64 位整数和 80 位浮点数）。但也有很多情况，这些标准的类型远远不能满足需要。这时你就需要一个高精度的数值类型了。</p><p>有一次我需要找一个高精度整数类型和计算库，最后找到的就是 Boost.Multiprecision <span class=\"orange\">[9]</span>。它基本满足我的需求，以及一般意义上对库的期望：</p><ul>\n<li>正确实现我需要的功能</li>\n<li>接口符合直觉、易用</li>\n<li>有良好的性能</li>\n</ul><p>正确实现功能这点我就不多讲了。这是一个基本出发点，没有太多可讨论的地方。在我上次的需求里，对性能其实也没有很高的要求。让我对 Boost.Multiprecision 满意的主要原因，就是它的接口了。</p><h3>接口易用性</h3><p>我在<a href=\"https://time.geekbang.org/column/article/179363\">[第 12 讲]</a> 提到了 CLN。它对我来讲就是个反面教材。它的整数类型不仅不提供 <code>%</code> 运算符，居然还不提供 <code>/</code> 运算符！它强迫用户在下面两个方案中做出选择：</p><ul>\n<li>使用 <code>truncate2</code> 函数，得到一个商数和余数</li>\n<li>使用 <code>exquo</code> 函数，当且仅当可以整除的时候</li>\n</ul><p>不管作者的设计原则是什么，这简直就是易用性方面的灾难了——不仅这些函数要查文档才能知晓，而且有的地方我真的只需要简单的除法呀……</p><p>哦，对了，它在 Windows 编译还很不方便，而我那时用的正是 Windows。</p><p>Boost.Multiprecision 的情况则恰恰相反，让我当即大为满意：</p><ul>\n<li>使用基本的 <code>cpp_int</code> 对象不需要预先编译库，只需要 Boost 的头文件和一个好的编译器。</li>\n<li>常用运算符 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code> 一个不缺，全部都有。</li>\n<li>可以自然地通过整数和字符串来进行构造。</li>\n<li>提供了用户自定义字面量来高效地进行初始化。</li>\n<li>在使用 IO 流时，输入输出既可以使用十进制，也可以通过 <code>hex</code> 来切换到十六进制。</li>\n</ul><p>下面的代码展示了它的基本功能：</p><pre><code class=\"language-c++\">#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\n#include &lt;boost/multiprecision/cpp_int.hpp&gt;\n\nusing namespace std;\n\nint main()\n{\n  using namespace boost::\n    multiprecision::literals;\n  using boost::multiprecision::\n    cpp_int;\n\n  cpp_int a =\n    0x123456789abcdef0_cppi;\n  cpp_int b = 16;\n  cpp_int c{\"0400\"};\n  cpp_int result = a * b / c;\n  cout &lt;&lt; hex &lt;&lt; result &lt;&lt; endl;\n  cout &lt;&lt; dec &lt;&lt; result &lt;&lt; endl;\n}\n</code></pre><p>输出是：</p><blockquote>\n<p><code>123456789abcdef</code><br>\n<code>81985529216486895</code></p>\n</blockquote><p>我们可以看到，<code>cpp_int</code> 可以通过自定义字面量（后缀 <code>_cppi</code>；只能十六进制）来初始化，可以通过一个普通整数来初始化，也可以通过字符串来初始化（并可以使用 <code>0x</code> 和 <code>0</code> 前缀来选择十六进制和八进制）。拿它可以正常地进行加减乘除操作，也可以通过 IO 流来输入输出。</p><h3>性能</h3><p>Boost.Multiprecision 使用了表达式模板和 C++11 的移动来避免不必要的拷贝。后者当然是件好事，而前者曾经坑了我一下——我第一次使用 Boost.Multiprecision 时非常困惑为什么我使用 <code>half(n - 1)</code> 调用下面的简单函数居然会编译不过：</p><pre><code class=\"language-c++\">template &lt;typename N&gt;\ninline N half(N n)\n{\n  return n / 2;\n}\n</code></pre><p>我的意图当然是 <code>N</code> 应当被推导为 <code>cpp_int</code>，<code>half</code> 的结果也是 <code>cpp_int</code>。可实际上，<code>n - 1</code> 的结果跟上面的 Armadillo 展示的情况类似，是另外一个单独的类型。我需要把 <code>half(n - 1)</code> 改写成 <code>half(N(n - 1))</code> 才能得到期望的结果。</p><p>我做的计算挺简单，并不觉得表达式模板对我的计算有啥帮助，所以我最后是禁用了表达式模板：</p><pre><code class=\"language-c++\">typedef boost::multiprecision::\n  number&lt;\n    boost::multiprecision::\n      cpp_int_backend&lt;&gt;,\n    boost::multiprecision::et_off&gt;\n    int_type;\n</code></pre><p>类似于 Armadillo 可以换不同的 BLAS 和 LAPACK 实现，Boost.Multiprecision 也可以改换不同的后端。比如，如果我们打算使用 GMP <span class=\"orange\">[10]</span> 的话，我们需要包含利用 GMP 的头文件，并把上面的 <code>int_type</code> 的定义修正一下：</p><pre><code class=\"language-c++\">#include &lt;boost/multiprecision/gmp.hpp&gt;\n\ntypedef boost::multiprecision::\n  number&lt;\n    boost::multiprecision::gmp_int,\n    boost::multiprecision::et_off&gt;\n    int_type;\n</code></pre><p>注意，我并不是推荐你换用 GMP。如果你真的对性能非常渴求的话，应当进行测试来选择合适的后端。否则缺省的后端易用性最好——比如，使用 GMP 后端就不能使用自定义字面量了。</p><p>我当时寻找高精度算术库是为了做 RSA 加解密。计算本身不复杂，属于编程几小时、运行几毫秒的情况。如果你有兴趣的话，可以看一下我那时的挑选过程和最终代码 <span class=\"orange\">[11]</span>。</p><p>Boost 里好东西很多，远远不止这一样。下一讲我们就来专门聊聊 Boost。</p><h2>内容小结</h2><p>本讲我们讨论了两个进行计算的模板库，Armadillo 和 Boost.Multiprecision，并讨论了它们用到的表达式模板技巧和相关的计算库，如 BLAS、LAPACK 和 GMP。可以看到，使用 C++ 你可以站到巨人肩上，轻松写出高性能的计算代码。</p><h2>课后思考</h2><p>性能和易用性往往是有矛盾的。你对性能和易用性有什么样的偏好呢？欢迎留言与我分享。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Wikipedia, “Basic Linear Algebra Subprograms”. <a href=\"https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms\">https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms</a> </span></p><p><span class=\"reference\">[2] Wikipedia, “LAPACK”. <a href=\"https://en.wikipedia.org/wiki/LAPACK\">https://en.wikipedia.org/wiki/LAPACK</a> </span></p><p><span class=\"reference\">[3] Wikipedia, “ARPACK”. <a href=\"https://en.wikipedia.org/wiki/ARPACK\">https://en.wikipedia.org/wiki/ARPACK</a> </span></p><p><span class=\"reference\">[4] Zhang Xianyi et al., OpenBLAS. <a href=\"https://github.com/xianyi/OpenBLAS\">https://github.com/xianyi/OpenBLAS</a> </span></p><p><span class=\"reference\">[5] Intel, Math Kernel Library. <a href=\"https://software.intel.com/mkl\">https://software.intel.com/mkl</a> </span></p><p><span class=\"reference\">[6] Ilya Yaroshenko, mir-glas. <a href=\"https://github.com/libmir/mir-glas\">https://github.com/libmir/mir-glas</a> </span></p><p><span class=\"reference\">[7] Conrad Sanderson and Ryan Curtin, “Armadillo: C++ library for linear algebra &amp; scientific computing”. <a href=\"http://arma.sourceforge.net/\">http://arma.sourceforge.net/</a> </span></p><p><span class=\"reference\">[8] Wikipedia, “Expression templates”. <a href=\"https://en.wikipedia.org/wiki/Expression_templates\">https://en.wikipedia.org/wiki/Expression_templates</a> </span></p><p><span class=\"reference\">[9] John Maddock, Boost.Multiprecision. <a href=\"https://www.boost.org/doc/libs/release/libs/multiprecision/doc/html/index.html\">https://www.boost.org/doc/libs/release/libs/multiprecision/doc/html/index.html</a> </span></p><p><span class=\"reference\">[10] The GNU MP bignum library. <a href=\"https://gmplib.org/\">https://gmplib.org/</a> </span></p><p><span class=\"reference\">[11] 吴咏炜, “Choosing a multi-precision library for C++—a critique”. <a href=\"https://yongweiwu.wordpress.com/2016/06/04/choosing-a-multi-precision-library-for-c-a-critique/\">https://yongweiwu.wordpress.com/2016/06/04/choosing-a-multi-precision-library-for-c-a-critique/</a> </span></p>","neighbors":{"left":{"article_title":"22 | 处理数据类型变化和错误：optional、variant、expected和Herbception","id":189022},"right":{"article_title":"24 | Boost：你需要的“瑞士军刀”","id":191136}},"comments":[{"had_liked":false,"id":172546,"user_name":"廖熊猫","can_delete":false,"product_type":"c1","uid":1141444,"ip_address":"","ucode":"8E8C475CD11FBC","user_header":"https://static001.geekbang.org/account/avatar/00/11/6a/c4/8679ca8a.jpg","comment_is_top":false,"comment_ctime":1579222092,"is_pvip":false,"replies":[{"id":66933,"content":"我的观点和你差不多……🤗\n\n那个在线教材真棒！谢谢推荐。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579239301,"ip_address":"","comment_id":172546,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"易用的东西灵活性就稍微弱一些，在能快速完成业务的时候，我还是比较偏向易用性，一查文档马上就可以用起来，真的出现性能瓶颈的时候再去折腾复杂性能好的东西。\n给需要学习线性代数的小伙伴推荐一个教材：http:&#47;&#47;textbooks.math.gatech.edu&#47;ila&#47;index.html\n需要点英语基础才行。","like_count":15},{"had_liked":false,"id":172587,"user_name":"三味","can_delete":false,"product_type":"c1","uid":1362403,"ip_address":"","ucode":"A580F715D1CC96","user_header":"https://static001.geekbang.org/account/avatar/00/14/c9/e3/28c16afa.jpg","comment_is_top":false,"comment_ctime":1579228473,"is_pvip":false,"replies":[{"id":66932,"content":"看来你是真正搞计算的啊……我是偶尔碰一下而已。\n\n《数学与泛型编程》绝对是好书。这本已经算是作者的另一本书的简化版本了（那本书更抽象，我也只啃了个开头而已了）。对于喜欢数学的程序员，我绝对大力推荐。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579238941,"ip_address":"","comment_id":172587,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"当然更偏向易用性。实现更重要。一个算法不确定是否能实现，先从易用的库开始快速迭代算法实现。优化是最后要考虑的。\n还有就是在选择第三方库的时候，我倾向于选择纯头文件的库。比如Eigen3。我用Eigen3无非就是矩阵计算，能够快速求解线性方程组的解就好，并没有高次方程求根这种（其实也有，为了求一个三次方程就要引用一个库，我选择找一个现成的实现）。\n当然，开篇的例子的话，我肯定也不会用Eigen去求，三维空间下的数学，还是交给glm这种用于渲染的数学库比较好，纯头文件，易于集成，而且简单好用。\n当然我说的只是图形渲染中常用的一些库。貌似还真没看到过图形学方面代码用犰狳库的，因为用不到吧。\n\n最后，我看了一下老师最后列出来的博客，提到了From Mathematics to Generic Programming，哈哈，我手头上也有一本这书！当然是中文版的。。。《数学与泛型编程》。。当时以为是接触泛型编程，顺便了解一些数学才买的。结果买来之后第六章群那里我实在看不动了。。其实第五章我就看着老吃力了。。。即使如此，也感觉收获不小。比如，看这本书之前我一直不知道质数筛。。还有古人如何计算乘法，如何计算最大公约数等等。回头我还要继续啃一下这本书。","like_count":5,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481772,"discussion_content":"我的观点和你差不多……🤗\n\n那个在线教材真棒！谢谢推荐。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579239301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1120997,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1a/e5/6899701e.jpg","nickname":"favorlm","note":"","ucode":"CFD52127AA6E1D","race_medal":3,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":655051,"discussion_content":"感谢您推荐的教材，我这一次终于学会了线性代数","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1734061398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"山东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176602,"user_name":"aL","can_delete":false,"product_type":"c1","uid":1758305,"ip_address":"","ucode":"A180F3AD9A9C7F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d4/61/19711475.jpg","comment_is_top":false,"comment_ctime":1581097307,"is_pvip":false,"replies":[{"id":68564,"content":"是的，异构计算也是新的重要方向。SYCL 就是其中之一，可以了解一下。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1581131466,"ip_address":"","comment_id":176602,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"我之前用的eigen，感觉还不错，如果涉及到大规模数值运算的话，还是得上gpu吧！","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483157,"discussion_content":"是的，异构计算也是新的重要方向。SYCL 就是其中之一，可以了解一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581131466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172824,"user_name":"花晨少年","can_delete":false,"product_type":"c1","uid":1098987,"ip_address":"","ucode":"6AA3537A6BA10E","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","comment_is_top":false,"comment_ctime":1579327042,"is_pvip":false,"replies":[{"id":67064,"content":"如何用 C++ 做异构计算，这是一个新领域。可以留意一下 SYCL。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579359712,"ip_address":"","comment_id":172824,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"科学计算这块最近几年突然热起来了，在调研xdl深度学习框架时，推理引擎cpu版本用的就是mkl库做各种矩阵运算，但是可能还是gpu版本的cuda库应用更广泛一些，听说cuda编程挺难的，需要了解很多异构硬件的细节。","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481868,"discussion_content":"如何用 C++ 做异构计算，这是一个新领域。可以留意一下 SYCL。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579359712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190044,"user_name":"Milittle","can_delete":false,"product_type":"c1","uid":1045455,"ip_address":"","ucode":"80E566639A8ABB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f3/cf/851dab01.jpg","comment_is_top":false,"comment_ctime":1584597334,"is_pvip":false,"replies":[{"id":73212,"content":"嗯，看到过这种说法。我没啥体验，因为我不用MatLab。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1584663011,"ip_address":"","comment_id":190044,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"专栏深度确实可以，我之前在做Matlab代码转C++的时候，可以说armadillo是一个比较好用的工具（最起码性能还过得去）。这个老师在专栏里面没有提到，我说一下，可以给小伙伴们提供一点帮助～万一你哪天需要把Matlab的算法做一个快速实现呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487867,"discussion_content":"嗯，看到过这种说法。我没啥体验，因为我不用MatLab。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584663011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300281,"user_name":"Geek_dddde9","can_delete":false,"product_type":"c1","uid":2652522,"ip_address":"","ucode":"D14EF94033662A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIowerMFjqhnvMUkicDpc8jKfia2sUJgUcR1ceicqoNANib79D8e5pHv2fRiblXm8zkia4MPmp5k0ByiaUbg/132","comment_is_top":false,"comment_ctime":1625095076,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"工作中感觉eigen更友好一些","like_count":0},{"had_liked":false,"id":175131,"user_name":"秀","can_delete":false,"product_type":"c1","uid":1347035,"ip_address":"","ucode":"0E7B6FAEA23CA1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJVzmZvQuYSw5IfzprjgQj9U3Jmrez8YWU1hhruUOvZpvQOwvVcjDyaBKs0Up09OaZNzKaHibVwAJA/132","comment_is_top":false,"comment_ctime":1580567380,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"我发现留言的都是大佬。学习了学习了。","like_count":0},{"had_liked":false,"id":172546,"user_name":"廖熊猫","can_delete":false,"product_type":"c1","uid":1141444,"ip_address":"","ucode":"8E8C475CD11FBC","user_header":"https://static001.geekbang.org/account/avatar/00/11/6a/c4/8679ca8a.jpg","comment_is_top":false,"comment_ctime":1579222092,"is_pvip":false,"replies":[{"id":66933,"content":"我的观点和你差不多……🤗\n\n那个在线教材真棒！谢谢推荐。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579239301,"ip_address":"","comment_id":172546,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"易用的东西灵活性就稍微弱一些，在能快速完成业务的时候，我还是比较偏向易用性，一查文档马上就可以用起来，真的出现性能瓶颈的时候再去折腾复杂性能好的东西。\n给需要学习线性代数的小伙伴推荐一个教材：http:&#47;&#47;textbooks.math.gatech.edu&#47;ila&#47;index.html\n需要点英语基础才行。","like_count":15,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481772,"discussion_content":"我的观点和你差不多……🤗\n\n那个在线教材真棒！谢谢推荐。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579239301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1120997,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1a/e5/6899701e.jpg","nickname":"favorlm","note":"","ucode":"CFD52127AA6E1D","race_medal":3,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":655051,"discussion_content":"感谢您推荐的教材，我这一次终于学会了线性代数","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1734061398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"山东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172587,"user_name":"三味","can_delete":false,"product_type":"c1","uid":1362403,"ip_address":"","ucode":"A580F715D1CC96","user_header":"https://static001.geekbang.org/account/avatar/00/14/c9/e3/28c16afa.jpg","comment_is_top":false,"comment_ctime":1579228473,"is_pvip":false,"replies":[{"id":66932,"content":"看来你是真正搞计算的啊……我是偶尔碰一下而已。\n\n《数学与泛型编程》绝对是好书。这本已经算是作者的另一本书的简化版本了（那本书更抽象，我也只啃了个开头而已了）。对于喜欢数学的程序员，我绝对大力推荐。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579238941,"ip_address":"","comment_id":172587,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"当然更偏向易用性。实现更重要。一个算法不确定是否能实现，先从易用的库开始快速迭代算法实现。优化是最后要考虑的。\n还有就是在选择第三方库的时候，我倾向于选择纯头文件的库。比如Eigen3。我用Eigen3无非就是矩阵计算，能够快速求解线性方程组的解就好，并没有高次方程求根这种（其实也有，为了求一个三次方程就要引用一个库，我选择找一个现成的实现）。\n当然，开篇的例子的话，我肯定也不会用Eigen去求，三维空间下的数学，还是交给glm这种用于渲染的数学库比较好，纯头文件，易于集成，而且简单好用。\n当然我说的只是图形渲染中常用的一些库。貌似还真没看到过图形学方面代码用犰狳库的，因为用不到吧。\n\n最后，我看了一下老师最后列出来的博客，提到了From Mathematics to Generic Programming，哈哈，我手头上也有一本这书！当然是中文版的。。。《数学与泛型编程》。。当时以为是接触泛型编程，顺便了解一些数学才买的。结果买来之后第六章群那里我实在看不动了。。其实第五章我就看着老吃力了。。。即使如此，也感觉收获不小。比如，看这本书之前我一直不知道质数筛。。还有古人如何计算乘法，如何计算最大公约数等等。回头我还要继续啃一下这本书。","like_count":5,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481783,"discussion_content":"看来你是真正搞计算的啊……我是偶尔碰一下而已。\n\n《数学与泛型编程》绝对是好书。这本已经算是作者的另一本书的简化版本了（那本书更抽象，我也只啃了个开头而已了）。对于喜欢数学的程序员，我绝对大力推荐。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579238941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176602,"user_name":"aL","can_delete":false,"product_type":"c1","uid":1758305,"ip_address":"","ucode":"A180F3AD9A9C7F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d4/61/19711475.jpg","comment_is_top":false,"comment_ctime":1581097307,"is_pvip":false,"replies":[{"id":68564,"content":"是的，异构计算也是新的重要方向。SYCL 就是其中之一，可以了解一下。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1581131466,"ip_address":"","comment_id":176602,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"我之前用的eigen，感觉还不错，如果涉及到大规模数值运算的话，还是得上gpu吧！","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481783,"discussion_content":"看来你是真正搞计算的啊……我是偶尔碰一下而已。\n\n《数学与泛型编程》绝对是好书。这本已经算是作者的另一本书的简化版本了（那本书更抽象，我也只啃了个开头而已了）。对于喜欢数学的程序员，我绝对大力推荐。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579238941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172824,"user_name":"花晨少年","can_delete":false,"product_type":"c1","uid":1098987,"ip_address":"","ucode":"6AA3537A6BA10E","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","comment_is_top":false,"comment_ctime":1579327042,"is_pvip":false,"replies":[{"id":67064,"content":"如何用 C++ 做异构计算，这是一个新领域。可以留意一下 SYCL。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579359712,"ip_address":"","comment_id":172824,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"科学计算这块最近几年突然热起来了，在调研xdl深度学习框架时，推理引擎cpu版本用的就是mkl库做各种矩阵运算，但是可能还是gpu版本的cuda库应用更广泛一些，听说cuda编程挺难的，需要了解很多异构硬件的细节。","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483157,"discussion_content":"是的，异构计算也是新的重要方向。SYCL 就是其中之一，可以了解一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581131466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190044,"user_name":"Milittle","can_delete":false,"product_type":"c1","uid":1045455,"ip_address":"","ucode":"80E566639A8ABB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f3/cf/851dab01.jpg","comment_is_top":false,"comment_ctime":1584597334,"is_pvip":false,"replies":[{"id":73212,"content":"嗯，看到过这种说法。我没啥体验，因为我不用MatLab。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1584663011,"ip_address":"","comment_id":190044,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"专栏深度确实可以，我之前在做Matlab代码转C++的时候，可以说armadillo是一个比较好用的工具（最起码性能还过得去）。这个老师在专栏里面没有提到，我说一下，可以给小伙伴们提供一点帮助～万一你哪天需要把Matlab的算法做一个快速实现呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481868,"discussion_content":"如何用 C++ 做异构计算，这是一个新领域。可以留意一下 SYCL。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579359712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300281,"user_name":"Geek_dddde9","can_delete":false,"product_type":"c1","uid":2652522,"ip_address":"","ucode":"D14EF94033662A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIowerMFjqhnvMUkicDpc8jKfia2sUJgUcR1ceicqoNANib79D8e5pHv2fRiblXm8zkia4MPmp5k0ByiaUbg/132","comment_is_top":false,"comment_ctime":1625095076,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"工作中感觉eigen更友好一些","like_count":0},{"had_liked":false,"id":175131,"user_name":"秀","can_delete":false,"product_type":"c1","uid":1347035,"ip_address":"","ucode":"0E7B6FAEA23CA1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJVzmZvQuYSw5IfzprjgQj9U3Jmrez8YWU1hhruUOvZpvQOwvVcjDyaBKs0Up09OaZNzKaHibVwAJA/132","comment_is_top":false,"comment_ctime":1580567380,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"我发现留言的都是大佬。学习了学习了。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487867,"discussion_content":"嗯，看到过这种说法。我没啥体验，因为我不用MatLab。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584663011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}