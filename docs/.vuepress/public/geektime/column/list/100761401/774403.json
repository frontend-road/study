{"id":774403,"title":"06｜循环语句：控制流让虚拟机执行复杂的运算","content":"<p>你好，我是海纳。</p><p>上一节课我们介绍了控制流中的第一种基本结构——分支语句。这一节课我们会介绍第二种基本结构——循环语句。</p><p>Python 中有两种循环结构，分别是 while 语句和 for 语句。Python 中的 while 语句和其他语言中的 while 语句差不多，但是 for 语句却和 C、C++、Java 等常见语言有很大的区别，Python 中的 for 语句本质上是一个迭代器。我们要等到实现了类机制以后，才能实现迭代器，所以这节课我们的重点是实现 while 循环。</p><h2>实现变量</h2><p>要实现循环结构，首先就要实现变量。在每次循环中，变量都应该有所变化，这样才能在若干次循环以后，破坏循环继续的条件，从而跳出这个循环。接下来我们就实现这个变量机制。我们还是从一个最简单的例子开始。</p><pre><code class=\"language-python\">a = 1\nb = a + 1\nprint(a)\nprint(b)\n</code></pre><p>我们按照以前的方法把它编译成 pyc 文件，然后通过 show_file 工具查看它的字节码。</p><pre><code class=\"language-python\">&nbsp; 1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 (1)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 STORE_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 (a)\n\n&nbsp; 2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (a)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 6 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 (1)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8 BINARY_ADD\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;10 STORE_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 (b)\n\n&nbsp; 3&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 12 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 (print)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;14 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (a)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;16 CALL_FUNCTION&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;18 POP_TOP\n\n&nbsp; 4&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 20 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 (print)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;22 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 (b)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;24 CALL_FUNCTION&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;26 POP_TOP\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;28 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 (None)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;30 RETURN_VALUE\n&nbsp; &nbsp;consts\n&nbsp; &nbsp; &nbsp; 1\n&nbsp; &nbsp; &nbsp; None\n&nbsp; &nbsp;names ('a', 'b', 'print')\n&nbsp; &nbsp;varnames ()\n&nbsp; &nbsp;freevars ()\n&nbsp; &nbsp;cellvars ()\n</code></pre><!-- [[[read_end]]] --><p>在这个反编译的结果中出现了一个新的字节码：<strong>STORE_NAME</strong>（第2行）。同时，我们注意到，names 表里除了 print 之外又出现了两个字符串，它们正好就是测试代码里使用的那两个变量：a 和 b。</p><p>在介绍 pyc 文件结构的时候，我们已经说过了，names 表里放的是 CodeObject 所使用的变量的名字，这里正好通过实例验证了这一说法。</p><p>就像名字里暗示的那样，STORE_NAME 和 LOAD_NAME 跟 names 表有关系。在第一节课的图里，除了操作数栈之外，还有一个变量表。变量表的作用是记录在程序执行过程中，变量的实际值是多少。</p><p>要实现这两个字节码，我们就必须要先实现变量表。</p><p><img src=\"https://static001.geekbang.org/resource/image/32/a7/324197e998ee7d274439d6ae1318aaa7.png?wh=2548x1264\" alt=\"图片\"></p><p>变量表是一个典型的键值（key-value）二元结构，它是一张表，每个键（key）都对应着一个值（value），键在这张表里是唯一的，不能重复。</p><p>这种结构，我们通常称之为 map。map 的实现有很多种，最常见的有基于哈希表的 HashMap，还有基于二叉排序树的 BinaryMap 等。由于 HashMap 要定义键的哈希函数，而有序的 map 又需要键之间的偏序关系，所以我们暂时都先不采用。</p><p>这里我们使用一种最简单的方式：<strong>直接使用数组实现</strong>。当插入一个键值对的时候，如果 map 里不包含 key，就直接插入。如果已经包含了 key，就把它原来的值更新成新的值。查询的时候，也是遍历整个数组，找到与查询的键相等的那个键，返回对应的值。</p><p>这里我给出一个简单的实现。</p><pre><code class=\"language-c++\">template &lt;typename K, typename V&gt;\nclass MapEntry {\npublic:\n    K _k;\n    V _v;\n    \n    MapEntry(const MapEntry&lt;K, V&gt;&amp; entry);\n    MapEntry(K k, V v) : _k(k), _v(v) {}\n    MapEntry() : _k(0), _v(0) {}\n};\n\ntemplate &lt;typename K, typename V&gt;\nclass Map {\nprivate:\n    MapEntry&lt;K, V&gt;* _entries;\n    int _size;\n    int _length;\n    \n    void expand();\npublic:\n    Map();\n\n    int  size() { return _size; }\n    void put(K k, V v);\n    V    get(K k);\n    K    get_key(int index);\n    bool has_key(K k);\n    V    remove(K k);\n    int  index(K k);\n    MapEntry&lt;K, V&gt;* entries() { return _entries; }\n};\n</code></pre><p>Map 的定义与 ArrayList 十分相似，内存都是可以按需增长的。其中，put 方法可以把键值对存入 Map 结构中。index 方法可以返回参数 k 在 _entries 数组中的序号。其他的方法，比如get、remove，都和它们名字所指示的意义一样，用于获取值和删除键值对。</p><p>接下来就可以实现 Map 里定义的所有函数了。我建议你不要照着课程中的代码抄，最好是自己实现一遍 Map 这种结构。这是一个很好的练手机会。为了提高编程水平，不断地练习是必不可少的。</p><pre><code class=\"language-c++\">template &lt;typename K, typename V&gt;\nMap&lt;K, V&gt;::Map() {\n    _entries = new MapEntry&lt;K, V&gt;[8];\n    _length  = 8;\n    _size    = 0;\n}\n\ntemplate &lt;typename K, typename V&gt;\nMapEntry&lt;K, V&gt;::MapEntry(const MapEntry&lt;K, V&gt;&amp; entry) {\n    _k = entry._k;\n    _v = entry._v;\n}\n\ntemplate &lt;typename K, typename V&gt;\nvoid Map&lt;K, V&gt;::put(K k, V v) {\n    for (int i = 0; i &lt; _size; i++) {\n        if (_entries[i]._k-&gt;equal(k) == Universe::HiTrue) {\n            _entries[i]._v = v;\n            return;\n        }\n    }\n    \n    expand();\n    _entries[_size++] = MapEntry&lt;K, V&gt;(k, v);\n}\n\ntemplate &lt;typename K, typename V&gt;\nbool Map&lt;K, V&gt;::has_key(K k) {\n    int i = index(k);\n    return i &gt;= 0;\n}\n\ntemplate &lt;typename K, typename V&gt;\nV Map&lt;K, V&gt;::get(K k) {\n    int i = index(k);\n    if (i &lt; 0)\n        return Universe::HiNone;\n    else\n        return _entries[i]._v;\n}\n\ntemplate &lt;typename K, typename V&gt;\nint Map&lt;K, V&gt;::index(K k) {\n    for (int i = 0; i &lt; _size; i++) {\n        if (_entries[i]._k-&gt;equal(k) == Universe::HiTrue) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n\ntemplate &lt;typename K, typename V&gt;\nvoid Map&lt;K, V&gt;::expand() {\n    if (_size &gt;= _length) {\n        MapEntry&lt;K, V&gt;* new_entries = new MapEntry&lt;K, V&gt;[_length &lt;&lt; 1];\n        for (int i = 0; i &lt; _size; i++) {\n            new_entries[i] = _entries[i];\n        }\n        _length &lt;&lt;= 1;\n        delete[] _entries;\n        _entries = new_entries;\n    }\n}\n\ntemplate &lt;typename K, typename V&gt;\nV Map&lt;K, V&gt;::remove(K k) {\n    int i = index(k);\n\n    if (i &lt; 0)\n        return 0; \n\n    V v = _entries[i]._v;\n    _entries[i] = _entries[--_size];\n    return v;\n}\n\ntemplate &lt;typename K, typename V&gt;\nK Map&lt;K, V&gt;::get_key(int index) {\n    return _entries[index]._k;\n}\n\ntemplate class Map&lt;HiObject*, HiObject*&gt;;\n</code></pre><p>这段代码虽然行数很多，但是逻辑都很简单。有两个地方是你需要注意的。第一处是 <strong>put 方法的实现</strong>（第15行）。由于 Map 中的 key 是唯一的，不会重复，所以在往 Map 插入键值对的时候，需要先检查 Map 中是否已经存在相同的 key 了。如果存在，就直接更新它的值，如果不存在，再插入键值对。</p><p>第二处要注意的是 <strong>remove 方法的实现</strong>。由于 Map 中的元素没有先后顺序的要求，所以我们可以将键值对任意排列。当要删除容器中的某一个元素的时候，我们只需要将最后一个元素与待删除元素交换位置，这样待删除元素就出现在最后一位了。这个时候只需要把最后一个元素删除就可以了。而我们知道，删除最后一个元素是非常高效的，把 size 变量减 1 就可以实现了。</p><p>有了 map 结构，我们就可以进一步实现变量表了。解释器中的变量表是一个以字符串为键的 map 结构，变量名存储在 CodeObject 的 names 列表中。所以，我们就可以这样实现变量表：</p><pre><code class=\"language-plain\">void Interpreter::run(CodeObject* codes) {\n    // ...\n&nbsp; &nbsp; HiList* names&nbsp; = codes-&gt;_names;\n&nbsp; &nbsp; Map&lt;HiObject*, HiObject*&gt;* locals&nbsp; = new Map&lt;HiObject*, HiObject*&gt;();\n\n    while (pc &lt; code_length) {\n        unsigned char op_code = codes-&gt;_bytecodes-&gt;value()[pc++];\n        short op_arg = (codes-&gt;_bytecodes-&gt;value()[pc++] &amp; 0xFF);\n        \n        // ....\n\n        switch (op_code) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case ByteCode::LOAD_NAME:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v = names-&gt;get(op_arg);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; w = locals-&gt;get(v);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PUSH(w);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case ByteCode::STORE_NAME:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v = names-&gt;get(op_arg);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locals-&gt;put(v, POP());\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;\n             //....\n         }\n     }\n}\n</code></pre><p>在变量表的基础上，我们进一步支持了 LOAD_NAME 和 STORE_NAME 两个字节码。</p><p>STORE_NAME 的作用是在局部变量表 locals 写入变量的值。变量的名称是一个字符串，存储在 names 中，所以要先从 names 中取出变量名（第 20 行），然后以变量名为键，将值写入变量表（第21行）。</p><p>LOAD_NAME 的过程与 STORE_NAME 相反，它负责从变量表里取出值。</p><p>由于循环结构的实现依赖于循环变量的迭代修改，所以在实现了变量的功能以后，我们才可以进一步支持循环结构。下面我们就开始实现循环结构。</p><h2>循环内的跳转</h2><p>在循环内有三种跳转，第一种是循环体正常执行，正常结束；第二种是使用 continue 语句，跳转回循环头部再进行条件判断；第三种是使用 break 语句，跳转到循环结束处。每一次循环体执行结束以后，都要跳到循环开始的地方再进行条件判断，来决定是否进入下一次循环。举一个最简单的例子，为了方便研究，我们把源代码和字节码混合在一起打印。</p><pre><code class=\"language-c++\">i = 0\n&nbsp; 1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 (0)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 STORE_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 (i)\n\nwhile i &lt; 2:\n&nbsp; 2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (i)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 6 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 (2)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8 COMPARE_OP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 (&lt;)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;10 POP_JUMP_IF_FALSE&nbsp; &nbsp; &nbsp; &nbsp;20 (to 40)\n\n    print(i)\n&nbsp; 3&nbsp; &nbsp; &nbsp;&gt;&gt;&nbsp; &nbsp;12 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 (print)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;14 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (i)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;16 CALL_FUNCTION&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;18 POP_TOP\n\n    i = i + 1\n&nbsp; 4&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 20 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (i)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;22 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 (1)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;24 BINARY_ADD\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;26 STORE_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 (i)\n\n&nbsp; 2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 28 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (i)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;30 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 (2)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;32 COMPARE_OP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 (&lt;)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;34 POP_JUMP_IF_TRUE&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 (to 12)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;36 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 (None)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;38 RETURN_VALUE\n&nbsp; &nbsp; &nbsp; &nbsp; &gt;&gt;&nbsp; &nbsp;40 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 (None)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;42 RETURN_VALUE\n</code></pre><p>从这个反编译结果中，我们可以看到，这里面只有一个新增的字节码，那就是 <strong>POP_JUMP_IF_TRUE</strong>。除了它之外，其他的字节码我们都已经很熟悉了。</p><p><span class=\"reference\">注：不同版本的编译器得到的字节码可能会有很大的不同，例如Python 2.7会使用JUMP_ABSOLUTE来实现绝对跳转。</span></p><p>如果循环判断不成功，就使用 POP_JUMP_IF_FALSE，跳过整个循环体。这个机制与 if 语句完全相同，这里不再赘述。</p><p>好了，到此为止，我们就把 while 循环所需要的字节码全部实现了。你可以编译运行一下，上面举的例子虽然简单，但都是可以运行的。比如下面的代码作用是打印 Fibonacci 数列的前10项，编译之后，在我们的虚拟机上就可以正确地打印出结果。</p><pre><code class=\"language-c++\">a = 1 \nb = 0 \ni = 0 \n\nprint(a)\nprint(b)\nprint(i)\n\nwhile i &lt; 10: \n    print(a)\n    t = a \n    a = a + b \n    b = t \n\n    i = i + 1 \n</code></pre><h2>实现continue语句</h2><p>影响 while 控制流的两个重要的关键字，分别是 continue 和 break。continue 的作用是直接跳到循环开始的地方进行条件判断，来决定是否要执行下一次循环。这种跳转将 continue 后面的循环体部分直接跳过了。</p><p>在查看 continue 的具体实现之前，我们可以猜想一下，这种跳转并不需要额外的数据结构，那是不是只要一个绝对跳转语句就可以实现呢？我们写一个例子验证一下。</p><pre><code class=\"language-python\">i = 0\n\nwhile i &lt; 10:\n\n&nbsp; 3&nbsp; &nbsp; &nbsp;&gt;&gt;&nbsp; &nbsp; 4 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (i)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 6 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 (10)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8 COMPARE_OP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 (&lt;)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;10 POP_JUMP_IF_FALSE&nbsp; &nbsp; &nbsp; &nbsp;25 (to 50)\n\n&nbsp; &nbsp; if i &lt; 2:\n\n&nbsp; 4&nbsp; &nbsp; &nbsp;&gt;&gt;&nbsp; &nbsp;12 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (i)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;14 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 (2)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;16 COMPARE_OP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 (&lt;)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;18 POP_JUMP_IF_FALSE&nbsp; &nbsp; &nbsp; &nbsp;11 (to 22)\n\n&nbsp; &nbsp; &nbsp; &nbsp; continue\n&nbsp; 5&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 20 JUMP_ABSOLUTE&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 (to 4)\n\n&nbsp; &nbsp; print(i)\n\n&nbsp; 7&nbsp; &nbsp; &nbsp;&gt;&gt;&nbsp; &nbsp;22 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 (print)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;24 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (i)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;26 CALL_FUNCTION&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;28 POP_TOP\n\n&nbsp; &nbsp; i = i + 1\n</code></pre><p>我们只展示了最关键的部分。注意位置为 20 的那条 JUMP_ABSOLUTE 指令（第 18 行），它就是continue 语句翻译出来的结果。Python 通过绝对跳转来实现 continue 语义。</p><p>JUMP_ABSOLUTE 这个字节码的作用是当循环体执行结束以后，跳到循环开始的位置，进行条件判断来决定是否进入下一次循环。它的参数是一个绝对地址，例如在刚刚那个例子里，参数是 9，就代表下一个要执行的字节码位置是9。我们看一下位置为 9 的那条字节码，恰好就是 i &lt; 2 这个比较开始的地方。所以这条字节码的实现如下：</p><pre><code class=\"language-c++\">// code/bytecode.hpp\nclass ByteCode {\n    ......\n    static const unsigned char JUMP_ABSOLUTE = 113;\n    ......\n};\n\n// runtime/interpreter.cpp\nvoid Interpreter::run(CodeObject* codes) {\n    ....\n    while (pc &lt; code_length) {\n\t    switch (op_code) {\n            case ByteCode::JUMP_ABSOLUTE:\n                pc = op_arg;\n                break;\n            ....\n        }\n    }\n}\n</code></pre><p>如果循环判断不成功，就使用 POP_JUMP_IF_FALSE 跳过整个循环体，这个机制与 if 语句完全相同，这里不再赘述。</p><p>到此为止，这节课的 continue 的例子就可以正常执行了。接下来我们实现第三种跳转——break语句。</p><p>我们先用一个简单的例子来测试一下。</p><pre><code class=\"language-c++\">i = 0\n\nwhile i &lt; 5:\n&nbsp; &nbsp; print(i)\n&nbsp; &nbsp; if i == 3:\n&nbsp; &nbsp; &nbsp; &nbsp; break\n&nbsp; &nbsp; i = i + 1\n\nprint(i)\n</code></pre><p>得到的字节码如下所示：</p><pre><code class=\"language-plain\">&nbsp; 1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 (0)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 STORE_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 (i)\n\n&nbsp; 3&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (i)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 6 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 (5)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8 COMPARE_OP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 (&lt;)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;10 POP_JUMP_IF_FALSE&nbsp; &nbsp; &nbsp; &nbsp;23 (to 46)\n\n&nbsp; 4&nbsp; &nbsp; &nbsp;&gt;&gt;&nbsp; &nbsp;12 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 (print)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;14 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (i)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;16 CALL_FUNCTION&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;18 POP_TOP\n\n&nbsp; 5&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 20 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (i)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;22 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 (3)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;24 COMPARE_OP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 (==)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;26 POP_JUMP_IF_FALSE&nbsp; &nbsp; &nbsp; &nbsp;15 (to 30)\n\n&nbsp; 6&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 28 JUMP_FORWARD&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8 (to 46)\n\n&nbsp; 7&nbsp; &nbsp; &nbsp;&gt;&gt;&nbsp; &nbsp;30 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (i)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;32 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 (1)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;34 BINARY_ADD\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;36 STORE_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 (i)\n\n&nbsp; 3&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 38 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (i)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;40 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 (5)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;42 COMPARE_OP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 (&lt;)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;44 POP_JUMP_IF_TRUE&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 (to 12)\n\n&nbsp; 9&nbsp; &nbsp; &nbsp;&gt;&gt;&nbsp; &nbsp;46 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 (print)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;48 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (i)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;50 CALL_FUNCTION&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;52 POP_TOP\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;54 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 (None)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;56 RETURN_VALUE\n</code></pre><p>第 17 行的 POP_JUMP_IF_FALSE 代表了 (i==3) 这个条件不满足的时候，应该继续执行循环体。第 19 行的 JUMP_FORWARD 则代表 (i == 3) 条件满足时，应该直接跳到循环体结尾处。</p><p>到这里，分支语句和循环语句就全部实现完了。你可以在自己的虚拟机上实验下面这个循环嵌套代码，看看是否能正确执行。</p><pre><code class=\"language-python\">i = 0\nj = 0\nwhile j &lt; 3:\n&nbsp; &nbsp; i = 0\n\n&nbsp; &nbsp; while i &lt; 10:\n&nbsp; &nbsp; &nbsp; &nbsp; if i == 3:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break\n&nbsp; &nbsp; &nbsp; &nbsp; i = i + 1\n\n&nbsp; &nbsp; j = j + 1\n</code></pre><h2>总结</h2><p>这节课我们实现了循环语句。变量的读写操作和跳转指令支撑了循环语句的实现。</p><p><strong>第一部分我们实现了变量的读写操作。</strong>在解释器里，除了操作数栈之外，最重要的数据结构就是变量表了。变量表采用关联数据结构，也就是 Map 来实现。LOAD 和 STORE 操作就是针对变量表的读写。</p><p><strong>第二部分我们重点实现了 POP_JUMP_IF_TRUE 指令。</strong>它的实现是比较简单的，这里需要你重点理解 while 语句是如何对应到这条跳转指令的。</p><p><strong>第三部分我们分析了 continue 语句和 break 语句，并重点实现了 JUMP_ABSOLUTE 指令。</strong>这是一条绝对跳转指令。通过以上几种跳转指令，循环语句就全部能运行了，包括比较复杂的嵌套循环语句也能正常执行。</p><p>相比于2.7版本的字节码，3.8版本的循环语句极大地简化了。如果你有余力的话，也可以研究一下Python 2.7的字节码是如何实现的。</p><p>到此为止，虚拟机已经具备了一定的计算能力。在过去的两节课中，我们遇到过很多次需要处理对象的情况。当时我们都是通过一些手段把问题回避过去了，那么下节课我们就应该把<strong>对象体系</strong>重新梳理一下，让它能够支持整数、浮点数、字符串等更多的基本数据类型。</p><h2>思考题</h2><p>老版本的Python字节码中，有一个BREAK_LOOP指令，你可以研究一下这条指令，然后思考为什么新版本的虚拟机中不需要这条指令了。期待你把你的答案分享到评论区，如果你觉得这节课的内容对你有帮助的话，也欢迎你分享给其他朋友。我们下节课再见！</p>","neighbors":{"left":{"article_title":"05｜分支语句：控制流让程序具备基本的运算能力","id":772703},"right":{"article_title":"07｜类型标识：虚拟机支持对象自检的基础设施","id":774409}},"comments":[{"had_liked":false,"id":390682,"user_name":"Se7en","can_delete":false,"product_type":"c1","uid":1225368,"ip_address":"北京","ucode":"93EFAE37AFB12D","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/98/82b76c88.jpg","comment_is_top":false,"comment_ctime":1715958815,"is_pvip":false,"replies":[{"id":142113,"content":"👍🌹","user_name":"作者回复","user_name_real":"编辑","uid":1360512,"ctime":1716176853,"ip_address":"上海","comment_id":390682,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100761401,"comment_content":"有人看到这里吗","like_count":3,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645448,"discussion_content":"👍🌹","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1716176853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1143015,"avatar":"https://static001.geekbang.org/account/avatar/00/11/70/e7/82cd831d.jpg","nickname":"Timothy","note":"","ucode":"A3E94236DD7A82","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645733,"discussion_content":"刚看到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1716604485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":396190,"user_name":"Se7en","can_delete":false,"product_type":"c1","uid":1225368,"ip_address":"北京","ucode":"93EFAE37AFB12D","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/98/82b76c88.jpg","comment_is_top":false,"comment_ctime":1733469900,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100761401,"comment_content":"关于思考题，我节选了一下python3.8文档的内容\nPOP_FINALLY(preserve_tos)\nCleans up the value stack and the block stack. If preserve_tos is not 0 TOS first is popped from the stack and pushed on the stack after performing other stack operations:\n\nIf TOS is NULL or an integer (pushed by BEGIN_FINALLY or CALL_FINALLY) it is popped from the stack.\n\nIf TOS is an exception type (pushed when an exception has been raised) 6 values are popped from the stack, the last three popped values are used to restore the exception state. An exception handler block is removed from the block stack.\n\nIt is similar to END_FINALLY, but doesn’t change the bytecode counter nor raise an exception. Used for implementing break, continue and return in the finally block.\n\nNew in version 3.8.","like_count":0},{"had_liked":false,"id":396188,"user_name":"Se7en","can_delete":false,"product_type":"c1","uid":1225368,"ip_address":"北京","ucode":"93EFAE37AFB12D","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/98/82b76c88.jpg","comment_is_top":false,"comment_ctime":1733469800,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100761401,"comment_content":"关于思考题，我节选了一下文档的内容\nIt is similar to END_FINALLY, but doesn’t change the bytecode counter nor raise an exception. Used for implementing break, continue and return in the finally block.","like_count":0},{"had_liked":false,"id":395117,"user_name":"ifelse","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1729491786,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":3,"score":2,"product_id":100761401,"comment_content":"学习打卡","like_count":0}]}