{"id":377913,"title":"08 | 锁：并发操作中，解决数据同步的四种方法","content":"<p>你好，我是LMOS。</p><p>我们在前面的课程中探索了，开发操作系统要了解的最核心的硬件——CPU、MMU、Cache、内存，知道了它们的工作原理。在程序运行中，它们起到了至关重要的作用。</p><p>在开发我们自己的操作系统以前，还不能一开始就把机器跑起来，而是先要弄清楚数据同步的问题。如果不解决掉数据同步的问题，后面机器跑起来，就会出现很多不可预知的结果。</p><p>通过这节课，我会给你讲清楚为什么在并发操作里，很可能得不到预期的访问数据，还会带你分析这个问题的原因以及解决方法。有了这样一个研究、解决问题的过程，对最重要的几种锁（<strong>原子变量，关中断，信号量，自旋锁</strong>），你就能做到心中有数了。</p><h2>非预期结果的全局变量</h2><p>来看看下面的代码，描述的是一个线程中的函数和中断处理函数，它们分别对一个全局变量执行加1操作，代码如下。</p><pre><code>int a = 0;\nvoid interrupt_handle()\n{\n    a++;\n}\nvoid thread_func()\n{\n    a++;\n}\n\n</code></pre><p>首先我们梳理一下编译器的翻译过程，通常编译器会把a++语句翻译成这3条指令。</p><p>1.把a加载某个寄存器中。</p><p>2.这个寄存器加1。</p><p>3.把这个寄存器写回内存。</p><p>那么不难推断，可能导致结果不确定的情况是这样的：thread_func函数还没运行完第2条指令时，中断就来了。</p><p>因此，CPU转而处理中断，也就是开始运行interrupt_handle函数，这个函数运行完a=1，CPU还会回去继续运行第3条指令，此时a依然是1，这显然是错的。</p><!-- [[[read_end]]] --><p>下面来看一下表格，你就明白了。<br>\n<img src=\"https://static001.geekbang.org/resource/image/79/4c/79bfa1d036ebb27yy17ae3edf768ba4c.jpeg?wh=1920*1080\" alt=\"\"></p><p>显然在t2时刻发生了中断，导致了t2到t4运行了interrupt_handle函数，t5时刻thread_func又恢复运行，导致interrupt_handle函数中a的操作丢失，因此出错。</p><h2>方法一：原子操作 拿下单体变量</h2><p>要解决上述场景中的问题，有这样两种思路。一种是<strong>把a++变成原子操作</strong>，这里的原子是不可分隔的，也就是说要a++这个操作不可分隔，即a++要么不执行，要么一口气执行完；另一种就是<strong>控制中断</strong>，比如在执行a++之前关掉中断，执行完了之后打开中断。</p><p>我们先来看看原子操作，显然靠编译器自动生成原子操作不太可能。第一，编译器没有这么智能，能检测哪个变量需要原子操作；第二，编译器必须要考虑代码的移植性，例如有些硬件平台支持原子操作的机器指令，有的硬件平台不支持原子操作。</p><p>既然实现原子操作无法依赖于具体编译器，那就需要我们自己动手，x86平台支持很多原子指令，我们只需要直接应用这些指令，比如原子加、原子减，原子读写等，用汇编代码写出对应的原子操作函数就行了。</p><p>好在现代C语言已经支持嵌入汇编代码，可以<strong>在C函数中按照特定的方式嵌入汇编代码</strong>了，实现原子操作就更方便了，代码如下。</p><pre><code>//定义一个原子类型\ntypedef struct s_ATOMIC{\n    volatile s32_t a_count; //在变量前加上volatile，是为了禁止编译器优化，使其每次都从内存中加载变量\n}atomic_t;\n//原子读\nstatic inline s32_t atomic_read(const atomic_t *v)\n{        \n        //x86平台取地址处是原子\n        return (*(volatile u32_t*)&amp;(v)-&gt;a_count);\n}\n//原子写\nstatic inline void atomic_write(atomic_t *v, int i)\n{\n        //x86平台把一个值写入一个地址处也是原子的 \n        v-&gt;a_count = i;\n}\n//原子加上一个整数\nstatic inline void atomic_add(int i, atomic_t *v)\n{\n        __asm__ __volatile__(&quot;lock;&quot; &quot;addl %1,%0&quot;\n                     : &quot;+m&quot; (v-&gt;a_count)\n                     : &quot;ir&quot; (i));\n}\n//原子减去一个整数\nstatic inline void atomic_sub(int i, atomic_t *v)\n{\n        __asm__ __volatile__(&quot;lock;&quot; &quot;subl %1,%0&quot;\n                     : &quot;+m&quot; (v-&gt;a_count)\n                     : &quot;ir&quot; (i));\n}\n//原子加1\nstatic inline void atomic_inc(atomic_t *v)\n{\n        __asm__ __volatile__(&quot;lock;&quot; &quot;incl %0&quot;\n                       : &quot;+m&quot; (v-&gt;a_count));\n}\n//原子减1\nstatic inline void atomic_dec(atomic_t *v)\n{\n       __asm__ __volatile__(&quot;lock;&quot; &quot;decl %0&quot;\n                     : &quot;+m&quot; (v-&gt;a_count));\n}\n\n</code></pre><p><strong>以上代码中，加上lock前缀的addl、subl、incl、decl指令都是原子操作，lock前缀表示锁定总线。</strong></p><p>我们还是来看看GCC支持嵌入汇编代码的模板，不同于其它C编译器支持嵌入汇编代码的方式，为了优化用户代码，GCC设计了一种特有的嵌入方式，它规定了汇编代码嵌入的形式和嵌入汇编代码需要由哪几个部分组成，如下面代码所示。</p><pre><code>__asm__ __volatile__(代码部分:输出部分列表: 输入部分列表:损坏部分列表);\n</code></pre><p>可以看到代码模板从__asm__开始（当然也可以是asm），紧跟着__volatile__，然后是跟着一对括号，最后以分号结束。括号里大致分为4个部分：</p><p>1.汇编代码部分，这里是实际嵌入的汇编代码。</p><p>2.输出列表部分，让GCC能够处理C语言左值表达式与汇编代码的结合。</p><p>3.输入列表部分，也是让GCC能够处理C语言表达式、变量、常量，让它们能够输入到汇编代码中去。</p><p>4.损坏列表部分，告诉GCC汇编代码中用到了哪些寄存器，以便GCC在汇编代码运行前，生成保存它们的代码，并且在生成的汇编代码运行后，恢复它们（寄存器）的代码。</p><p>它们之间用冒号隔开，如果只有汇编代码部分，后面的冒号可以省略。但是有输入列表部分而没有输出列表部分的时候，输出列表部分的冒号就必须要写，否则GCC没办法判断，同样的道理对于其它部分也一样。</p><p>这里不会过多展开讲这个技术，详情可参阅<a href=\"https://www.gnu.org/manual/manual.html\">GCC手册</a>。你可以重点看GAS相关的章节。</p><p>下面将用上面一个函数atomic_add为例子说一下，如下所示。</p><pre><code>static inline void atomic_add(int i, atomic_t *v)\n{\n        __asm__ __volatile__(&quot;lock;&quot; &quot;addl %1,%0&quot;\n                     : &quot;+m&quot; (v-&gt;a_count)\n                     : &quot;ir&quot; (i));\n}\n//&quot;lock;&quot; &quot;addl %1,%0&quot; 是汇编指令部分，%1,%0是占位符，它表示输出、输入列表中变量或表态式，占位符的数字从输出部分开始依次增加，这些变量或者表态式会被GCC处理成寄存器、内存、立即数放在指令中。 \n//: &quot;+m&quot; (v-&gt;a_count) 是输出列表部分，“+m”表示(v-&gt;a_count)和内存地址关联\n//: &quot;ir&quot; (i) 是输入列表部分，“ir” 表示i是和立即数或者寄存器关联\n</code></pre><p>有了这些原子操作函数之后 ，前面场景中的代码就变成下面这样了：无论有没有中断，或者什么时间来中断，都不会出错。</p><pre><code>atomic_t a = {0};\nvoid interrupt_handle()\n{\n    atomic_inc(&amp;a);\n}\nvoid thread_func()\n{\n    atomic_inc(&amp;a);\n}\n</code></pre><p>好，说完了原子操作，我们再看看怎么用中断控制的思路解决数据并发访问的问题。</p><h2>方法二：中断控制  搞定复杂变量</h2><p>中断是CPU响应外部事件的重要机制，时钟、键盘、硬盘等IO设备都是通过发出中断来请求CPU执行相关操作的（即执行相应的中断处理代码），比如下一个时钟到来、用户按下了键盘上的某个按键、硬盘已经准备好了数据。</p><p>但是中断处理代码中如果操作了其它代码的数据，这就需要相应的控制机制了，这样才能保证在操作数据过程中不发生中断。</p><p>你或许在想，可以用原子操作啊？不过，<strong>原子操作只适合于单体变量</strong>，如整数。操作系统的数据结构有的可能有几百字节大小，其中可能包含多种不同的基本数据类型。这显然用原子操作无法解决。</p><p>下面，我们就要写代码实现关闭开启、中断了，x86 CPU上关闭、开启中断有专门的指令，即cli、sti指令，它们主要是对CPU的eflags寄存器的<strong>IF位</strong>（第9位）进行清除和设置，CPU正是通过此位来决定是否响应中断信号。这两条指令只能Ring0权限才能执行，代码如下。</p><pre><code>//关闭中断\nvoid hal_cli()\n{\n    __asm__ __volatile__(&quot;cli&quot;: : :&quot;memory&quot;);\n}\n//开启中断\nvoid hal_sti()\n{\n    __asm__ __volatile__(&quot;sti&quot;: : :&quot;memory&quot;);\n}\n//使用场景\nvoid foo()\n{\n    hal_cli();\n    //操作数据……\n    hal_sti();\n}\nvoid bar()\n{\n    hal_cli();\n    //操作数据……\n    hal_sti();\n}\n</code></pre><p>你可以自己思考一下，前面这段代码效果如何？</p><p>它看似完美地解决了问题，其实有重大缺陷，hal_cli()，hal_sti()，<strong>无法嵌套使用</strong>，看一个例子你就明白了，代码如下。</p><pre><code>void foo()\n{\n    hal_cli();\n    //操作数据第一步……\n    hal_sti();\n}\nvoid bar()\n{\n    hal_cli();\n    foo();\n    //操作数据第二步……\n    hal_sti();\n}\n</code></pre><p>上面代码的关键问题在bar函数在关中断下调用了foo函数，foo函数中先关掉中断，处理好数据然后开启中断，回到bar函数中，bar函数还天真地以为中断是关闭的，接着处理数据，以为不会被中断抢占。</p><p>那么怎么解决上面的问题呢？我们只要修改一下开启、关闭中断的函数就行了。</p><p>我们可以这样操作：在关闭中断函数中先保存eflags寄存器，然后执行cli指令，在开启中断函数中直接恢复之前保存的eflags寄存器就行了，具体代码如下。</p><pre><code>typedef u32_t cpuflg_t;\nstatic inline void hal_save_flags_cli(cpuflg_t* flags)\n{\n     __asm__ __volatile__(\n            &quot;pushfl \\t\\n&quot; //把eflags寄存器压入当前栈顶\n            &quot;cli    \\t\\n&quot; //关闭中断\n            &quot;popl %0 \\t\\n&quot;//把当前栈顶弹出到flags为地址的内存中        \n            : &quot;=m&quot;(*flags)\n            :\n            : &quot;memory&quot;\n          );\n}\nstatic inline void hal_restore_flags_sti(cpuflg_t* flags)\n{\n    __asm__ __volatile__(\n              &quot;pushl %0 \\t\\n&quot;//把flags为地址处的值寄存器压入当前栈顶\n              &quot;popfl \\t\\n&quot;   //把当前栈顶弹出到eflags寄存器中\n              :\n              : &quot;m&quot;(*flags)\n              : &quot;memory&quot;\n              );\n}\n</code></pre><p>从上面的代码中不难发现，硬件工程师早就想到了如何解决在嵌套函数中关闭、开启中断的问题：pushfl指令把eflags寄存器压入当前栈顶，popfl把当前栈顶的数据弹出到eflags寄存器中。</p><p>hal_restore_flags_sti()函数的执行，是否开启中断完全取决于上一次eflags寄存器中的值，并且popfl指令只会影响eflags寄存器中的IF位。这样，无论函数嵌套调用多少层都没有问题。</p><h2>方法三：自旋锁 协调多核心CPU</h2><p>前面说的控制中断，看似解决了问题，那是因为以前是单CPU，同一时刻只有一条代码执行流，除了中断会中止当前代码执行流，转而运行另一条代码执行流（中断处理程序），再无其它代码执行流。这种情况下只要控制了中断，就能安全地操作全局数据。</p><p>但是我们都知道，现在情况发生了改变，CPU变成了多核心，或者主板上安装了多颗CPU，同一时刻下系统中存在多条代码执行流，控制中断只能控制本地CPU的中断，无法控制其它CPU核心的中断。</p><p>所以，原先通过控制中断来维护全局数据安全的方案失效了，这就需要全新的机制来处理这样的情况，于是就轮到自旋锁登场了。</p><p>我们先看看自旋锁的原理，它是这样的：首先读取锁变量，判断其值是否已经加锁，如果未加锁则执行加锁，然后返回，表示加锁成功；如果已经加锁了，就要返回第一步继续执行后续步骤，因而得名自旋锁。为了让你更好理解，下面来画一个图描述这个算法。</p><p><img src=\"https://static001.geekbang.org/resource/image/61/88/619c27c6400344db2310fb82ce8d5788.jpg?wh=2195*2405\" alt=\"\" title=\"自旋锁原理示意图\"></p><p>这个算法看似很好，但是想要正确执行它，就<strong>必须保证读取锁变量和判断并加锁的操作是原子执行的。</strong>否则，CPU0在读取了锁变量之后，CPU1读取锁变量判断未加锁执行加锁，然后CPU0也判断未加锁执行加锁，这时就会发现两个CPU都加锁成功，因此这个算法出错了。</p><p>怎么解决这个问题呢？这就要找硬件要解决方案了，x86 CPU给我们提供了一个原子交换指令，xchg，它可以让寄存器里的一个值跟内存空间中的一个值做交换。例如，让eax=memlock，memlock=eax这个动作是原子的，不受其它CPU干扰。</p><p>下面我们就去实现自旋锁，代码如下所示。</p><pre><code>//自旋锁结构\ntypedef struct\n{\n     volatile u32_t lock;//volatile可以防止编译器优化，保证其它代码始终从内存加载lock变量的值 \n} spinlock_t;\n//锁初始化函数\nstatic inline void x86_spin_lock_init(spinlock_t * lock)\n{\n     lock-&gt;lock = 0;//锁值初始化为0是未加锁状态\n}\n//加锁函数\nstatic inline void x86_spin_lock(spinlock_t * lock)\n{\n    __asm__ __volatile__ (\n    &quot;1: \\n&quot;\n    &quot;lock; xchg  %0, %1 \\n&quot;//把值为1的寄存器和lock内存中的值进行交换\n    &quot;cmpl   $0, %0 \\n&quot; //用0和交换回来的值进行比较\n    &quot;jnz    2f \\n&quot;  //不等于0则跳转后面2标号处运行\n    &quot;jmp 3f \\n&quot;     //若等于0则跳转后面3标号处返回\n    &quot;2:         \\n&quot; \n    &quot;cmpl   $0, %1  \\n&quot;//用0和lock内存中的值进行比较\n    &quot;jne    2b      \\n&quot;//若不等于0则跳转到前面2标号处运行继续比较  \n    &quot;jmp    1b      \\n&quot;//若等于0则跳转到前面1标号处运行，交换并加锁\n    &quot;3:  \\n&quot;     :\n    : &quot;r&quot;(1), &quot;m&quot;(*lock));\n}\n//解锁函数\nstatic inline void x86_spin_unlock(spinlock_t * lock)\n{\n    __asm__ __volatile__(\n    &quot;movl   $0, %0\\n&quot;//解锁把lock内存中的值设为0就行\n    :\n    : &quot;m&quot;(*lock));\n}\n</code></pre><p>上述代码的中注释已经很清楚了，关键点在于xchg指令，xchg %0, %1 。</p><p>其中，%0对应 “r”(1)，表示由编译器自动分配一个通用寄存器，并填入值1，例如mov eax，1。而%1对应\"m\"(*lock)，表示lock是内存地址。把1和内存中的值进行交换，若内存中是1，则不会影响；因为本身写入就是1，若内存中是0，一交换，内存中就变成了1，即加锁成功。</p><p>自旋锁依然有中断嵌套的问题，也就是说，在使用自旋锁的时候我们仍然要注意中断。</p><p>在中断处理程序访问某个自旋锁保护的某个资源时，依然有问题，所以我们要写的自旋锁函数必须适应这样的中断环境，也就是说，它需要在处理中断的过程中也能使用，如下所示。</p><pre><code>static inline void x86_spin_lock_disable_irq(spinlock_t * lock,cpuflg_t* flags)\n{\n    __asm__ __volatile__(\n    &quot;pushfq                 \\n\\t&quot;\n    &quot;cli                    \\n\\t&quot;\n    &quot;popq %0                \\n\\t&quot;\n    &quot;1:         \\n\\t&quot;\n    &quot;lock; xchg  %1, %2 \\n\\t&quot;\n    &quot;cmpl   $0,%1       \\n\\t&quot;\n    &quot;jnz    2f      \\n\\t&quot;\n    &quot;jmp    3f      \\n&quot;  \n    &quot;2:         \\n\\t&quot;\n    &quot;cmpl   $0,%2       \\n\\t&quot; \n    &quot;jne    2b      \\n\\t&quot;\n    &quot;jmp    1b      \\n\\t&quot;\n    &quot;3:     \\n&quot;     \n     :&quot;=m&quot;(*flags)\n    : &quot;r&quot;(1), &quot;m&quot;(*lock));\n}\nstatic inline void x86_spin_unlock_enabled_irq(spinlock_t* lock,cpuflg_t* flags)\n{\n    __asm__ __volatile__(\n    &quot;movl   $0, %0\\n\\t&quot;\n    &quot;pushq %1 \\n\\t&quot;\n    &quot;popfq \\n\\t&quot;\n    :\n    : &quot;m&quot;(*lock), &quot;m&quot;(*flags));\n}\n</code></pre><p>以上代码实现了关中断下获取自旋锁，以及恢复中断状态释放自旋锁。在中断环境下也完美地解决了问题。</p><h2>方法四：信号量  CPU时间管理大师</h2><p>无论是原子操作，还是自旋锁，都不适合长时间等待的情况，因为有很多资源（数据）它有一定的时间性，你想去获取它，CPU并不能立即返回给你，而是要等待一段时间，才能把数据返回给你。这种情况，你用自旋锁来同步访问这种资源，你会发现这是对CPU时间的巨大浪费。</p><p>下面我们看看另一种同步机制，既能对资源数据进行保护（同一时刻只有一个代码执行流访问），又能在资源无法满足的情况下，让CPU可以执行其它任务。</p><p>如果你翻过操作系统的理论书，应该对信号量这个词并不陌生。信号量是1965年荷兰学者Edsger Dijkstra提出的，是一种用于资源互斥或者进程间同步的机制。这里我们就来看看如何实现这一机制。</p><p>你不妨想象这样一个情境：微信等待你从键盘上的输入信息，然后把这个信息发送出去。</p><p>这个功能我们怎么实现呢？下面我们就来说说实现它的一般方法，当然具体实现中可能不同，但是原理是相通的，具体如下。</p><p>1.一块内存，相当于缓冲区，用于保存键盘的按键码。</p><p>2.需要一套控制机制，比如微信读取这个缓冲区，而该缓冲区为空时怎么处理；该缓冲区中有了按键码，却没有代码执行流来读取，又该怎么处理。</p><p>我们期望是这样的，一共有三点。</p><p>1.当微信获取键盘输入信息时，发现键盘缓冲区中是空的，就进入等待状态。</p><p>2.同一时刻，只能有一个代码执行流操作键盘缓冲区。</p><p>3.当用户按下键盘时，我们有能力把按键码写入缓冲区中，并且能看一看微信或者其它程序是否在等待该缓冲区，如果是就重新激活微信和其它的程序，让它们重新竞争读取键盘缓冲区，如果竞争失败依然进入等待状态。</p><p>其实以上所述无非是三个问题：<strong>等待、互斥、唤醒（即重新激活等待的代码执行流）。</strong></p><p>这就需要一种全新的数据结构来解决这些问题。根据上面的问题，这个数据结构至少需要一个变量来表示互斥，比如大于0则代码执行流可以继续运行，等于0则让代码执行流进入等待状态。还需要一个等待链，用于保存等待的代码执行流。</p><p>这个数据结构的实现代码如下所示。</p><pre><code>#define SEM_FLG_MUTEX 0\n#define SEM_FLG_MULTI 1\n#define SEM_MUTEX_ONE_LOCK 1\n#define SEM_MULTI_LOCK 0\n//等待链数据结构，用于挂载等待代码执行流（线程）的结构，里面有用于挂载代码执行流的链表和计数器变量，这里我们先不深入研究这个数据结构。\ntypedef struct s_KWLST\n{   \n    spinlock_t wl_lock;\n    uint_t   wl_tdnr;\n    list_h_t wl_list;\n}kwlst_t;\n//信号量数据结构\ntypedef struct s_SEM\n{\n    spinlock_t sem_lock;//维护sem_t自身数据的自旋锁\n    uint_t sem_flg;//信号量相关的标志\n    sint_t sem_count;//信号量计数值\n    kwlst_t sem_waitlst;//用于挂载等待代码执行流（线程）结构\n}sem_t;\n</code></pre><p>搞懂了信号量的结构，我们再来看看信号量的一般用法，注意信号量在使用之前需要<strong>先进行初始化</strong>。这里假定信号量数据结构中的sem_count初始化为1，sem_waitlst等待链初始化为空。</p><p>使用信号量的步骤，我已经给你列好了。</p><p><strong>第一步，获取信号量。</strong></p><p>1.首先对用于保护信号量自身的自旋锁sem_lock进行加锁。<br>\n2.对信号值sem_count执行“减1”操作，并检查其值是否小于0。<br>\n3.上步中检查sem_count如果小于0，就让进程进入等待状态并且将其挂入sem_waitlst中，然后调度其它进程运行。否则表示获取信号量成功。当然最后别忘了对自旋锁sem_lock进行解锁。</p><p><strong>第二步，代码执行流开始执行相关操作，例如读取键盘缓冲区。</strong></p><p><strong>第三步，释放信号量。</strong></p><p>1.首先对用于保护信号量自身的自旋锁sem_lock进行加锁。<br>\n2.对信号值sem_count执行“加1”操作，并检查其值是否大于0。<br>\n3.上步中检查sem_count值如果大于0，就执行唤醒sem_waitlst中进程的操作，并且需要调度进程时就执行进程调度操作，不管sem_count是否大于0（通常会大于0）都标记信号量释放成功。当然最后别忘了对自旋锁sem_lock进行解锁。</p><p>这里我给你额外分享一个小技巧，<strong>写代码之前我们常常需要先想清楚算法步骤，建议你像我这样分条列出，因为串联很容易含糊其辞，不利于后面顺畅编码。</strong></p><p>好，下面我们来看看实现上述这些功能的代码，按照理论书籍上说，信号量有两个操作：down，up，代码如下。</p><pre><code>//获取信号量\nvoid krlsem_down(sem_t* sem)\n{\n    cpuflg_t cpufg;\nstart_step:    \n    krlspinlock_cli(&amp;sem-&gt;sem_lock,&amp;cpufg);\n    if(sem-&gt;sem_count&lt;1)\n    {//如果信号量值小于1,则让代码执行流（线程）睡眠\n        krlwlst_wait(&amp;sem-&gt;sem_waitlst);\n        krlspinunlock_sti(&amp;sem-&gt;sem_lock,&amp;cpufg);\n        krlschedul();//切换代码执行流，下次恢复执行时依然从下一行开始执行，所以要goto开始处重新获取信号量\n        goto start_step; \n    }\n    sem-&gt;sem_count--;//信号量值减1,表示成功获取信号量\n    krlspinunlock_sti(&amp;sem-&gt;sem_lock,&amp;cpufg);\n    return;\n}\n//释放信号量\nvoid krlsem_up(sem_t* sem)\n{\n    cpuflg_t cpufg;\n    krlspinlock_cli(&amp;sem-&gt;sem_lock,&amp;cpufg);\n    sem-&gt;sem_count++;//释放信号量\n    if(sem-&gt;sem_count&lt;1)\n    {//如果小于1,则说数据结构出错了，挂起系统\n        krlspinunlock_sti(&amp;sem-&gt;sem_lock,&amp;cpufg);\n        hal_sysdie(&quot;sem up err&quot;);\n    }\n    //唤醒该信号量上所有等待的代码执行流（线程）\n    krlwlst_allup(&amp;sem-&gt;sem_waitlst);\n    krlspinunlock_sti(&amp;sem-&gt;sem_lock,&amp;cpufg);\n    krlsched_set_schedflgs();\n    return;\n}\n</code></pre><p>上述代码中的krlspinlock_cli，krlspinunlock_sti两个函数，只是对前面自旋锁函数的一个<strong>封装</strong>，krlschedul、krlwlst_wait、krlwlst_allup、krlsched_set_schedflgs这几个函数会在进程相关课程进行探讨。</p><h2>重点回顾</h2><p>又到了这节课结束的时候，我们回顾一下今天都讲了什么。我把这节课的内容为你梳理一下，要点如下。</p><p>1.原子变量，在只有<strong>单个变量全局数据</strong>的情况下，这种变量非常实用，如全局计数器、状态标志变量等。我们利用了CPU的原子指令实现了一组操作原子变量的函数。</p><p>2.中断的控制。当要操作的数据很多的情况下，用原子变量就不适合了。但是我们发现在单核心的CPU，同一时刻只有一个代码执行流，除了响应中断导致代码执行流切换，不会有其它条件会干扰全局数据的操作，所以我们只要在操作全局数据时关闭或者开启中断就行了，为此我们开发了控制中断的函数。</p><p>3.自旋锁。由于多核心的CPU出现，控制中断已经失效了，因为<strong>系统中同时有多个代码执行流</strong>，为了解决这个问题，我们开发了自旋锁，自旋锁要么一下子获取锁，要么循环等待最终获取锁。</p><p>4.信号量。如果长时间等待后才能获取数据，在这样的情况下，前面中断控制和自旋锁都不能很好地解决，于是我们开发了信号量。信号量由一套数据结构和函数组成，它能使获取数据的代码执行流进入睡眠，然后在相关条件满足时被唤醒，这样就能让CPU能有时间处理其它任务。所以信号量同时解决了三个问题：<strong>等待、互斥、唤醒。</strong></p><h2>思考题</h2><p>请用代码展示一下自旋锁或者信号量，可能的使用形式是什么样的？</p><p>期待你在留言区的分享，也欢迎你把这节课的内容分享给身边的朋友，跟他一起学习交流。</p><p>我是LMOS，我们下节课见！</p>","comments":[{"had_liked":false,"id":294519,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":true,"comment_ctime":1621990017,"is_pvip":false,"replies":[{"id":"106931","content":"我非常喜欢你这样的读者，你总是能抓住问题的本质，继续保持，为你点赞","user_name":"作者回复","comment_id":294519,"uid":"1345199","ip_address":"","utype":1,"ctime":1622037415,"user_name_real":"LMOS"}],"discussion_count":8,"race_medal":0,"score":"9.2233725710526996e+18","product_id":100078401,"comment_content":"今天的专栏可谓是精彩至极！<br>锁是解决并发同步问题的关键，从本文来看，锁有两个核心点，一个是原子操作，另一个则是中断；<br>通过原子操作来实现临界区标志位的改变，关闭中断来避免CPU中途离开导致数据同步失败问题。<br>自旋锁(spinlock)是锁的最小原型，其它锁都是以它为基础来实现的，自旋锁的实现也颇为简单，只需一个简单的原子标志位就可以实现了，当然还要妥善管理中断。<br>在 xv6 中，对锁的实现只有两种，一种是刚才提到的 spinlock，而另外一种则是 sleeplock，spinlock 不会让出 CPU 执行权，而 sleeplock 则是在 spinlock 的基础上，增加 sleep 功能，即如果一个执行体(线程或者进程)加锁失败，就会进入休眠状态，让出 CPU 执行权，让其它的任务也能得以执行。<br>本文中的信号量(sem)也是 sleeplock 的一种，sem 的实现更为精致，通过等待队列来记录加锁失败的执行体，并后续通过一定的策略来选择唤醒，这也是很多编程语言中信号量的实现方式。<br>当然不同的语言会有不同的优化，比如 go 的 Mutex 是非公平的唤醒机制，但是针对非公平的场景，又设有饥饿补偿，总之本文中实现的 sem 几乎是任何信号量（锁）实现的基础蓝本。<br><br>对于思考题答案，这里就顺便贴一下吧，如果有啥问题，欢迎大家交流指正：<br>  spinlock_t lock;<br>  x86_spin_lock_init(&amp;lock);<br>  &#47;&#47; 加锁，如果加锁成功则进入下面代码执行<br>  &#47;&#47; 否则，一直自旋，不断检查 lock 值为否为 0<br>  x86_spin_lock_disable_irq(&amp;lock);<br>  &#47;&#47; 处理一些数据同步、协同场景<br>  doing_something();<br>  &#47;&#47; 解锁<br>  x86_spin_unlock_enabled_irq(&amp;lock);<br><br><br>  sem_t sem;<br>  x86_sem_init(&amp;sem);<br>  &#47;&#47; 加锁，减少信号量，如果信号量已经为 0<br>  &#47;&#47; 则加锁失败，当前线程会改变为 sleeping 状态<br>  &#47;&#47; 并让出 CPU 执行权<br>  krlsem_down(&amp;sem);<br>  &#47;&#47; 处理一些数据同步、协同场景<br>  doing_something();<br>  &#47;&#47; 解锁，增加信号量，唤醒等待队列中的其它线程（若存在）<br>  krlsem_up(&amp;sem);<br>","like_count":125,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520691,"discussion_content":"我非常喜欢你这样的读者，你总是能抓住问题的本质，继续保持，为你点赞","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1622037415,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1527366,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4e/46/e037c0df.jpg","nickname":"Let go","note":"","ucode":"30EC4EC53E2A81","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376183,"discussion_content":"哈哈。真好，看完老师的在看你补充的。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1622005965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1736095,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/7d/9f/53dd1d94.jpg","nickname":"筱琲","note":"","ucode":"0896BD7CD8026C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378858,"discussion_content":"懂的人就好懂，不懂的人还是一知半解","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623467733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2780763,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/6e/5b/12a10165.jpg","nickname":"蚂蚁网络科技","note":"","ucode":"79FBD8AB9D738C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546784,"discussion_content":"关闭中断来避免CPU中途离开导致数据同步失败问题，请问一下：CPU调度切换线程了，这种CPU 中途离开是如何控制？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642424890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":3143773,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJR7XOGw5606wjgIIR43zdFTyMKpq7FiaE8RVUMpxHbOB51SYmDP6LXNfGQtlgLbxS0zT4eJRSpj8Q/132","nickname":"Geek_805547","note":"","ucode":"33F263FE96D72E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2780763,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/6e/5b/12a10165.jpg","nickname":"蚂蚁网络科技","note":"","ucode":"79FBD8AB9D738C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584438,"discussion_content":"CPU调度切换线程也是中断（时钟中断）触发的，关闭了中断就不会有这个问题了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660816881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546784,"ip_address":"内蒙古"},"score":584438,"extra":""}]},{"author":{"id":1315147,"avatar":"https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg","nickname":"xfan","note":"","ucode":"48ED8D498D7F56","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380555,"discussion_content":"你说sem是sleeplock的一种，那sem是什么时候让出cpu给其他任务执行了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624580392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1200704,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","nickname":"pedro","note":"","ucode":"F40C839DDFD599","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1315147,"avatar":"https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg","nickname":"xfan","note":"","ucode":"48ED8D498D7F56","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380564,"discussion_content":"当前进程进入sleep，调度器负责将执行权交给其它进程","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1624583954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":380555,"ip_address":""},"score":380564,"extra":""}]},{"author":{"id":1039029,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/da/b5/9d1f2f55.jpg","nickname":"朱熙","note":"","ucode":"2B9E2B8645A844","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378819,"discussion_content":"课代表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623415130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294591,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":true,"comment_ctime":1622011287,"is_pvip":false,"replies":[{"id":"106923","content":"是的，我们后面会有介绍 的 ","user_name":"作者回复","comment_id":294591,"uid":"1345199","ip_address":"","utype":1,"ctime":1622036764,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"9.2233721759157002e+18","product_id":100078401,"comment_content":"当前版本还有几个问题还没有解决，希望后面课程有进一步详解：<br>1、跨用户进程时，如何共享内核的同一个锁或信号量<br>2、没有提供锁的可重入不可重入的限制<br>3、锁自旋时不会让渡CPU时间<br>4、暂时没有提供公平锁算法<br>5、暂时没有提供乐观锁算法<br><br>基于本节，其实大家可以尝试一下：<br>1、信号量如何提供最大资源数限制<br>2、信号量如何提供扣除多个资源的支持<br>3、如何实现互斥量这一类数据结构呢<br>4、如何实现读写锁这一类数据结构呢<br><br>锁一般用来做线程间或进程间的互斥操作<br>信号量一般用来做线程间或进程间资源同步操作，比如资源的占用和释放等","like_count":32,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520728,"discussion_content":"是的，我们后面会有介绍 的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622036764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294605,"user_name":"嗣树","can_delete":false,"product_type":"c1","uid":1019334,"ip_address":"","ucode":"C6196E30F867D0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c6/e648d118.jpg","comment_is_top":true,"comment_ctime":1622015321,"is_pvip":false,"replies":[{"id":"106921","content":"你好，你学的很认真，学的很通透，总结很到位","user_name":"作者回复","comment_id":294605,"uid":"1345199","ip_address":"","utype":1,"ctime":1622036558,"user_name_real":"LMOS"}],"discussion_count":4,"race_medal":0,"score":"9.2233721673258004e+18","product_id":100078401,"comment_content":"记录下我学习本节内容的一些思考：<br>1. 学习到这里还没有引入抢占这个概念，所以讨论环境中默认进程上下文不会发生抢占，同样也没有进程切换这些东西。<br>其实讲进程上下文也不对，我们都还没有引入这些东西，暂且凑合这么用吧。<br><br>2. 首先讨论了单 cpu 情况下，保证数据一致性的方式，这一时期我们主要防中断：<br>\t- 对于单个变量我们实现了原子变量（由硬件提供支持），中断是不能打断这个操作的<br>\t- 对于复杂变量的操作，这个时候中断可以乱入了，我们通过关中断来保证单 cpu 下这些数据的正确<br><br>3. 到了多 cpu 时代，不止有中断这个小三，还有隔壁老王（其他核），关中断已经不管用了，<br>为了数据的一致需要大家在操作前都走自旋流程，自旋需要新的原子操作支持（xchg），到此我们解决了老王带来的问题。<br><br>4. 但是我们还需要面对中断的问题，自旋锁的实现是带条件的死循环，这也引入了一个问题：死锁。<br>cpu 间的互相抢锁最多抢不到等一会，但是 cpu 和本地中断之间就不同了。<br><br>当本 cpu 占有了锁，此时打来中断，假如中断中也要抢这把锁，那他抢不到嘛，只好死给你看咯。<br>而中断也可以嵌套，这种情况也可能死。所以对自旋锁升级，添加了关中断的操作。<br><br>5. 最后老师介绍了信号量，这里其实已经带入了调度的概念。<br><br>6. 最后在思考一下抢占和中断优先级带来的问题，其实也还是死锁的问题。<br>上面我们设想了两种死锁的情况。我们泛化一下，其实中断可以看作比普通进程优先级更高的进程，<br>只要是构成这种 低级持锁，高级来抢 的局面都可能死锁。而抢占和中断优先级创造了更多的阶级，<br>也就产生了更多的可能。所以 Linux 中自旋锁的实现第一步是关抢占。<br><br>错误或疏漏的地方还请指正，抱拳了老铁。","like_count":31,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520731,"discussion_content":"你好，你学的很认真，学的很通透，总结很到位","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622036558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2665197,"avatar":"","nickname":"Geek_00acf1","note":"","ucode":"B8C7A4DABA09B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380880,"discussion_content":"针对你说的第二点，单CPU，原子操作对于多核的使用也是OK的，所以不应该放在你的第二条的单CPU下，而应该是单CPU和多CPU都好使。\n不知道是否正确？可以查看下x86的lock指令，或者在群里问一下，我问过，群里一直没有人给回复很明确的答复。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624773771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1510470,"avatar":"https://static001.geekbang.org/account/avatar/00/17/0c/46/898e0a18.jpg","nickname":"Hideinsecret","note":"","ucode":"EFBAB4E423F054","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2665197,"avatar":"","nickname":"Geek_00acf1","note":"","ucode":"B8C7A4DABA09B3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586184,"discussion_content":"学习下来我觉得是的，关键点是 1.锁总线---防多核或者多CPU 2.CPU保证单条指令的原子性---防中断  3.volatile直接读写内存中的变量--防cache","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1662023786,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":380880,"ip_address":"广东"},"score":586184,"extra":""}]},{"author":{"id":2624931,"avatar":"https://static001.geekbang.org/account/avatar/00/28/0d/a3/9757c66c.jpg","nickname":"磊","note":"","ucode":"5C047DFEAF7F2E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378021,"discussion_content":"我理解的中断处理程序里别获取锁就没问题，单个核如果出现嵌套调用获取自旋锁的函数也会死锁，就是不能出现 第一层加锁完调二层，二层就肯定获取不到锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623020971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294809,"user_name":"惜心（伟祺）","can_delete":false,"product_type":"c1","uid":1067846,"ip_address":"","ucode":"393DF1A9E81332","user_header":"https://static001.geekbang.org/account/avatar/00/10/4b/46/717d5cb9.jpg","comment_is_top":true,"comment_ctime":1622098163,"is_pvip":false,"replies":[{"id":"107314","content":"很好，学到了 ","user_name":"作者回复","comment_id":294809,"uid":"1345199","ip_address":"","utype":1,"ctime":1622474056,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"9.2233720857214996e+18","product_id":100078401,"comment_content":"这个问题抽象下就是在如何在并行执行中做到串联有序<br>解决思路就两个：<br>1.在结果端（确保内存一致）<br>2.在过程端（确保cpu计算中不被打断）<br>原子性就是确保内存一致，但是因为cpu计算需要时间所以只能保证一个单位的绝对一致<br>至于锁、信号都是在对上面两种思路的组合，妙的是会出现跨代组合来实现更多样化的应用<br>老师从根本上分析问题，由简到繁，一下抓住根本和牛逼<br>其实操作系统就是对简单的功能的组合重复实现无限复杂操作<br>这种思路和软件开发是一致的，用一种语言API，各种的组合重复利用时间空间的重复解决各种复杂问题","like_count":11,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520820,"discussion_content":"很好，学到了 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622474056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295035,"user_name":"Freddy","can_delete":false,"product_type":"c1","uid":1708412,"ip_address":"","ucode":"5822B746265DB4","user_header":"https://static001.geekbang.org/account/avatar/00/1a/11/7c/bf5049b3.jpg","comment_is_top":true,"comment_ctime":1622191848,"is_pvip":false,"replies":[{"id":"107296","content":"你好，总结到位","user_name":"作者回复","comment_id":295035,"uid":"1345199","ip_address":"","utype":1,"ctime":1622472945,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"9.2233720814265999e+18","product_id":100078401,"comment_content":"本节是关于共享数据的并发修改问题，总结了不同场景下的使用方式：<br>当共享数据是单体变量时，可以尝试使用原子操作指令；<br>当共享数据是复杂的数据结构时：<br>当是单CPU环境时，只有中断和业务进程两个代码操作流，此时我们可以手动控制CPU中断关闭&#47;开启，要注意解决CPU中断关闭&#47;开启的嵌套调用问题；<br>当是多CPU环境时，就不能同时控制多个CPU的中断了，此时我们用到了自旋锁；多个CPU进程竞争自旋锁，成功加锁的进程，可以执行自己的业务流程；这里要注意的是要保证自旋锁流程中的读取锁变量和判断并加锁的操作是原子执行的；<br>在多CPU环境时，没有获取自旋锁的CPU，就会一直在循环读取锁变量和判断是否加锁的流程当中，浪费了CPU资源，为了解决这个问题，引入了信号量；<br>首先，各个进程会去竞争信号量；<br>没有获取信号量的进程放入等待队列，这样该进程所在的CPU就可以去执行其他业务进程了；<br>获取信号量的进程执行完后，会释放信号量后，同时会去唤醒在等待队列中的进程，这样等待的进程就会再次去竞争信号量；<br>思考：<br>1.那一个进程中的多个线程并发修改共享数据的模型，应该也是同样的道理吧？？<br>2.锁，应该是操作的前提条件，有了锁才能去执行业务代码；<br>但对原子操作来说，好像是加锁和业务操作一起执行了。<br>","like_count":10,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520922,"discussion_content":"你好，总结到位","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622472945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307732,"user_name":"lifetime","can_delete":false,"product_type":"c1","uid":2622088,"ip_address":"","ucode":"7E4C18D41351A0","user_header":"https://static001.geekbang.org/account/avatar/00/28/02/88/df790e16.jpg","comment_is_top":true,"comment_ctime":1629217714,"is_pvip":false,"replies":[{"id":"111429","content":"对头 ","user_name":"作者回复","comment_id":307732,"uid":"1345199","ip_address":"","utype":1,"ctime":1629251494,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"9.2233720685488005e+18","product_id":100078401,"comment_content":"看到楼上的各位都发表了那么多的总结，感觉你们都太厉害了！<br>我也跟着你们的脚步，谈谈我对这节课的理解：<br>1、对原子的理解：<br>抽象理解为一条指令，要么执行完成，要么没有执行<br>2、对中断的理解：<br>单个CPU中多个进程并发执行，是靠使用中断进行切换，关闭中断后，只有一个进程在执行这块临界区代码，其他进程无法切换执行，执行完这块代码后，再打开中断，再去切换到别的进程执行<br>3、对自旋锁的理解：<br>自旋锁解决多个CPU，多个进程并行执行的情况；<br>多个进程对同一个物理内存地址进行访问，先访问并判断为0的进程，进程加锁设置为1，执行临界区代码；<br>其他的进程陷入访问，判断为1的流程中，死循环；<br>执行完临界区的进程将地址设置为0，其他进程再去争抢<br>4、对信号量的理解：<br>信号量解决自旋锁中其他得不到执行的进程一直在轮询的问题，这个一直轮询会导致CPU无法切换到其他不需要执行该临界区的进程执行，效率低下；<br>所以引入能睡眠的机制，得不到的进程不让他们继续等了，先睡觉，负责其他进程执行的CPU去切换到别的进程执行；<br>等执行完临界区的进程OK后，再把这些睡觉的进程唤醒，他们再争抢<br>理解能力有限，只明白这么多，如果有不对的，麻烦指正！","like_count":7,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525264,"discussion_content":"对头 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629251494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294918,"user_name":"noisyes","can_delete":false,"product_type":"c1","uid":2538540,"ip_address":"","ucode":"94EC310B284AD2","user_header":"https://static001.geekbang.org/account/avatar/00/26/bc/2c/963688bb.jpg","comment_is_top":true,"comment_ctime":1622130144,"is_pvip":false,"replies":[{"id":"107073","content":"小编回复，很高兴这个专栏能够帮到你，后面更精彩，敬请期待。还有，只要有兴趣，跟着课程走，是可以跑起来操作系统的，别慌。","user_name":"编辑回复","comment_id":294918,"uid":"1501385","ip_address":"","utype":2,"ctime":1622170597,"user_name_real":"赵宇新"}],"discussion_count":1,"race_medal":0,"score":"9.2233720599517e+18","product_id":100078401,"comment_content":"真的是把锁的前生今世讲得明明白白，让我有种豁然开朗的感觉！可能到最后可能无法独自实现一个操作系统，但是真的能从底层的角度重新认识操作系统！","like_count":5,"discussions":[{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520870,"discussion_content":"小编回复，很高兴这个专栏能够帮到你，后面更精彩，敬请期待。还有，只要有兴趣，跟着课程走，是可以跑起来操作系统的，别慌。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622170597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343455,"user_name":"xiaoq","can_delete":false,"product_type":"c1","uid":1024599,"ip_address":"","ucode":"77CC98C70F8A29","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a2/57/219503c1.jpg","comment_is_top":true,"comment_ctime":1650859650,"is_pvip":false,"replies":[{"id":"125976","content":"对正确的","user_name":"作者回复","comment_id":343455,"uid":"1345199","ip_address":"","utype":1,"ctime":1652066111,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"9.223372042800599e+18","product_id":100078401,"comment_content":"# 单CPU下<br>业务函数和中断函数会存在并发访问同一资源<br>1. 对于简单资源(原型变量？)，可以把访问资源变成原子操作，使用带lock前缀的`addl subl incl decl`原子指令；<br>2. 对于复杂资源(复合类型变量)，可以把访问资源处业务函数关掉中断，保证此处是串行访问资源；需要解决嵌套问题，通过在关中断前使用pushfl、popl保存之前的中断状态，在下一次开启中断时恢复该状态；<br><br># 多CPU下<br>除了每个CPU存在业务函数和中断函数并发问题，还存在不同CPU之间并发问题；<br>在保证单CPU使用同步的情况下，还需要保证多个CPU同步；<br>1. 简单资源的原子访问操作：个人理解是因为锁了总线，所以单个、多个CPU均适用；<br>2. 自旋锁：关键指令xchg，确保 read(if) &amp; set 在多个CPU之间是原子的<br><br># 信号量<br>在复杂的上下文中保护多个复合资源<br>使用spinlock和wait_queue以及resource_count实现等待、互斥、唤醒<br><br><br>使用方法<br>&#47;&#47; spinlock<br>spinlock_t spinlock;<br>spinlock_init(&amp;spinlock)<br><br>&#47;&#47; cpu转圈圈，直到获取锁<br>spinlock_lock(&amp;spinlock)<br>&#47;&#47; dosomething()<br>spinlock_unlock(&amp;spinlock)<br><br>&#47;&#47; semaphore<br>sem_t sem;<br>sem_init(&amp;sem);<br><br>&#47;&#47; 线程会休眠 直到拿到信号量<br>sem_down(&amp;sem);<br>&#47;&#47; dosomething()<br>sem_up(&amp;sem);<br>","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571082,"discussion_content":"对正确的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652066111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":302010,"user_name":"不一样的烟火","can_delete":false,"product_type":"c1","uid":1473251,"ip_address":"","ucode":"6E305F0EE90E8B","user_header":"https://static001.geekbang.org/account/avatar/00/16/7a/e3/145adba9.jpg","comment_is_top":false,"comment_ctime":1626017238,"is_pvip":false,"replies":[{"id":"109282","content":"是的 是的 ","user_name":"作者回复","comment_id":302010,"uid":"1345199","ip_address":"","utype":1,"ctime":1626056850,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"53165624790","product_id":100078401,"comment_content":"锁用来保证资源的使用不被打断，打断的情况包括中断，其他cpu执行流，其他线程<br>保护的情况有原子操作，关中断，自旋锁，信号量<br>原子操作好比瞬时动作，动作只有一个，不被打断<br>关中断好比学习的时候关闭电话，不被分心，专心学习<br>自旋锁好比上厕所的时候锁上门，其他人只能在外面团团转，干着急，其他事儿干不了<br>信号量好比正在忙，门口挂个闲人免进，等自己办完事儿再通知他过来，他可以先去处理其他事情","like_count":12,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523151,"discussion_content":"是的 是的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626056850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294530,"user_name":"黎","can_delete":false,"product_type":"c1","uid":1008946,"ip_address":"","ucode":"B2AB6BB4D7FE9C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/65/32/74e47b74.jpg","comment_is_top":false,"comment_ctime":1621991407,"is_pvip":false,"replies":[{"id":"106929","content":"你这角度也很透彻，很好","user_name":"作者回复","comment_id":294530,"uid":"1345199","ip_address":"","utype":1,"ctime":1622037118,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":2,"score":"48866631663","product_id":100078401,"comment_content":"原子变量，中断，自旋锁，信号量，层层递进，都是在前一个技术的某些场景无法满足的情况下，更高级复杂的解决方案，当然也是基于前面的基础的封装","like_count":11,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520698,"discussion_content":"你这角度也很透彻，很好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622037118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":297834,"user_name":"Feen","can_delete":false,"product_type":"c1","uid":2646145,"ip_address":"","ucode":"E6CDC442B7213F","user_header":"https://static001.geekbang.org/account/avatar/00/28/60/81/38b00111.jpg","comment_is_top":false,"comment_ctime":1623807712,"is_pvip":false,"replies":[{"id":"108177","content":"嗯 嗯  对的","user_name":"作者回复","comment_id":297834,"uid":"1345199","ip_address":"","utype":1,"ctime":1623898302,"user_name_real":"LMOS"}],"discussion_count":3,"race_medal":0,"score":"35983546080","product_id":100078401,"comment_content":"尝试用自己的理解去消化一下本章的内容，用最少的文字在每句话表达出问题和核心和解决办法，不然显得自己都没好好学习：<br>1、几十年前的一开始，计算机内只有一个CPU，而且执行单道程序，因为当时的整机性能不强，操作方式是一次提交指令等待返回。每次执行任务都发现当前正在运行的程序内部有执行中被打乱的问题，设计程序的时候以为是按照人的思维来运算，实际发现有问题。所以增加了原子操作解决，要不全部执行，要不全部失败。那时候计算机执行任务的时候，程序员都站在计算机（还不能称之为现代电脑）面前，等待结果返回。<br>2、从各种其他设备开始接入计算机开始，为了解决这些设备也要在计算机运行时候的同时解决输入输出问题（这时CPU开始分时切片运行，表象显得可以同时运行多个程序），引入了中断的概念，CPU整个运行时间被分切为每个单位时间，单位时间之间可以持续运行同一程序，也可以打断运行其他程序，现代操作系统也开始初具雏形，区别与老计算机的标志就在于能否中断。<br>3、现代电脑蓬勃发展，电脑开始进入千家万户，中断的大量使用给用户提供了无限的可能，单核CPU的频率随着工艺和材料的提升也在提高，在奔腾时代（P2 P3 P4）你甚至可以在主板BIOS中设置中断。<br>4、万物逃离不了本质，单核CPU频率提升到一定幅度后开始减缓，频率不够，核数来凑。多核CPU进入视野，而中断只能锁定当前占有的那一个CPU核心，无法锁定其他CPU核心不去碰你执行的程序，既然无法通过中断达到锁定，因为你的程序在电脑内只会存在一个程序（如果你一个程序要多开，那通过不同的PID来区分，目前还未讲到，暂且不考虑），聪明的程序员又想到了锁你的程序变量，自旋锁开始使用(xchg)。<br>5、自旋锁的使用几乎是同时出现信号量，在使用自旋锁的时候确实排他了，但是CPU的工作却发生了变化，不止要执行当前用户程序中正在运行的那一部分代码，还得运行另一部分未执行的代码。同时还有长时间等待的问题。因为它旋转着呢，就如同排队上厕所一样，肯定得敲CPU的大门，问下前面那位占着茅坑的好了没，上不到厕所决不罢休。还好电脑不像人，没有三急来了就骂人的情绪，所以聪明的程序员又干了一件事：发筹子（count），好了叫你，没好的时候躺平。（从这里看出程序的主导权或者执行权，已经由代码本身，移交到外部信号量控制部分。）<br>6、总结：计算机经过这么多年的发展，从思路上可以看出 ，解决问题的方法就是先从单个示例下手，不管是原子操作，还是中断，还是自旋锁，还是信号量。当你解决了单个实例的问题，那就是从0到1质变，从1到99都是在此基础上的衍生，而从单个实例下手的入口点可以有多个，但从局部性原理开始考虑更轻松一点。","like_count":8,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521947,"discussion_content":"嗯 嗯  对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623898302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134694,"avatar":"https://static001.geekbang.org/account/avatar/00/11/50/66/047ee060.jpg","nickname":"Return12321","note":"","ucode":"F7A3C5ED02E1D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":410683,"discussion_content":"这个总结真的好，锁的“前世今生”变迁来说明","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635757215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1250205,"avatar":"https://static001.geekbang.org/account/avatar/00/13/13/9d/d91dc762.jpg","nickname":"喜欢吃鱼","note":"","ucode":"02F41572F53E3C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383582,"discussion_content":"你的总结很到位，谢谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626167718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319352,"user_name":"Return12321","can_delete":false,"product_type":"c1","uid":1134694,"ip_address":"","ucode":"F7A3C5ED02E1D9","user_header":"https://static001.geekbang.org/account/avatar/00/11/50/66/047ee060.jpg","comment_is_top":false,"comment_ctime":1635756572,"is_pvip":false,"replies":[{"id":"115783","content":"是的","user_name":"作者回复","comment_id":319352,"uid":"1345199","ip_address":"","utype":1,"ctime":1635813070,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"18815625756","product_id":100078401,"comment_content":"信号量理解，比如有微信、QQ、钉钉应用需要获取到键盘输入值：<br>1、初始化sem_count=1，sem_waitlst等待链为空；<br>2、通过键盘输入字符到缓冲区，并通过进程调度通知进程；<br>3、三个进程开始竞争，微信抢到，先给sem_lock加锁，此时QQ、钉钉的进程不能读取信号量，循环判断(自旋锁的逻辑)；<br>4、微信进程对sem_count执行判断sem_count不小于1(sem_count=1)，获取信号量成功，执行sem_count“减1”操作(sem_count=0)，释放自旋锁sem_lock；<br>5-1、QQ、钉钉进程此时能读取sem_lock自旋锁，此时钉钉抢到，则先给sem_lock加锁，获取sem_count值并执行判断sem_count不小于1，此时sem_count=0（小于1），钉钉进程进入等待状态，并将其挂入sem_waitlst中，释放自旋锁sem_lock。最后QQ进程重复5-1步骤，sem_count=0，sem_waitlst=[QQ, 钉钉]；<br>5-2、微信进程执行读取缓存区代码流操作；<br>6、微信代码流执行(读取键盘值)完成，先给sem_lock加锁，对sem_count执行“加1”操作(sem_count=1)，检查sem_count不小于1，则执行唤醒sem_waitlst 中进程的操作，标记信号量释放成功，给sem_lock解锁；<br>7、sem_waitlst=[QQ, 钉钉]中的进程重复从4开始的步骤。<br><br>文章中写的是先执行“减1”操作、然后sem_count和0判断，但从代码上来看，sem_count是先和1比较，然后执行“减1”操作。","like_count":5,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529602,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635813070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":297513,"user_name":"K菌无惨","can_delete":false,"product_type":"c1","uid":2194764,"ip_address":"","ucode":"97A532D588FD49","user_header":"","comment_is_top":false,"comment_ctime":1623590550,"is_pvip":false,"replies":[{"id":"108064","content":"对的 ","user_name":"作者回复","comment_id":297513,"uid":"1345199","ip_address":"","utype":1,"ctime":1623723320,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"18803459734","product_id":100078401,"comment_content":"感觉信号量好就好在与操作系统的进程&#47;线程调度整合在一起，所以就能够在没有资源时（即信号量等于0），触发进程调度，避免了自旋锁的CPU空转，在拥有资源时能够唤起对应的代码执行下去（即goto start_step）；而至于为什么要用到自旋锁，而不用普通的锁，估计只是因为自旋锁在临界区较短的时候效率更高。 不知道对不对","like_count":4,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521842,"discussion_content":"对的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623723320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":306607,"user_name":"李yong","can_delete":false,"product_type":"c1","uid":2620499,"ip_address":"","ucode":"ECA57ACFE44024","user_header":"https://static001.geekbang.org/account/avatar/00/27/fc/53/836c87d1.jpg","comment_is_top":false,"comment_ctime":1628643790,"is_pvip":false,"replies":[{"id":"111020","content":"对的 你很牛","user_name":"作者回复","comment_id":306607,"uid":"1345199","ip_address":"","utype":1,"ctime":1628649234,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"14513545678","product_id":100078401,"comment_content":"之前没有学习过操作系统，看了两遍，总结一下自己的理解,。<br>1. 原子操作，可以解决单个变量并发问题。不管后续多核cpu还是单核cpu. <br>缺点在于只对于单个变量有效。<br>实现方式，汇编lock.<br>汇编lock这种方式后续几种方法都会涉及到。<br>2. 中断。单核cpu时只有一个流，唯一可能的并发就是中断，关闭中断即可解决问题。<br>缺点，只对于单核cpu有效。<br>实现方式，关闭中断。<br>不管单核还是多核，都会存在中断引起并发的情况，所以后面两种方法都涉及关闭中断。<br>3.自旋锁。可以突破原子操作和中断的限制，即支持多个变量并发以及多核cpu. 额外增加锁变量，锁变量值为0还是1指使此时是否存在并发。存在并发时，循环判断此锁变量的值，直到其他并发结束。不存在并发时，对锁变量加锁。需要关闭中断避免中断的影响。<br>缺点，存在并发时，其他流一直试图获取锁变量，占用cpu资源。<br>实现方式，增加锁变量，指使是否存在并发。<br>4. 信号量。增加结构体，结构体中包含count信号量计数值和list用于挂载等待任务流列表。count为0，任务流进入休眠状态(释放出cpu, 可以调度其他任务流)。count为1.获取信号量，可执行后续操作，并将count置为0，表示已占用，执行完成后，将count加1，","like_count":3,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524834,"discussion_content":"对的 你很牛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628649234,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":301641,"user_name":"青玉白露","can_delete":false,"product_type":"c1","uid":2619436,"ip_address":"","ucode":"96FE2D4D2B94A0","user_header":"https://static001.geekbang.org/account/avatar/00/27/f8/2c/92969c48.jpg","comment_is_top":false,"comment_ctime":1625796000,"is_pvip":false,"replies":[{"id":"109181","content":"防止 编译器优化","user_name":"作者回复","comment_id":301641,"uid":"1345199","ip_address":"","utype":1,"ctime":1625802020,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"14510697888","product_id":100078401,"comment_content":"return (*(volatile u32_t*)&amp;(v)-&gt;a_count);<br><br>这里为什么非要这么复杂？<br>return v-&gt;a_count;<br>难道有问题嘛？还得要先取地址再取值","like_count":3,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523051,"discussion_content":"防止 编译器优化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625802020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296385,"user_name":"哇咔咔","can_delete":false,"product_type":"c1","uid":1133036,"ip_address":"","ucode":"54BF877836C591","user_header":"https://static001.geekbang.org/account/avatar/00/11/49/ec/6bae1fd7.jpg","comment_is_top":false,"comment_ctime":1622949432,"is_pvip":true,"replies":[{"id":"107571","content":"当我们用多核cpu时，问题就不同了 ","user_name":"作者回复","comment_id":296385,"uid":"1345199","ip_address":"","utype":1,"ctime":1622986682,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"14507851320","product_id":100078401,"comment_content":"“x86 CPU 给我们提供了一个原子交换指令，xchg，它可以让寄存器里的一个值跟内存空间中的一个值做交换”<br>这里说xchg是原子的，那么为什么在xchg前面还要lock呢？","like_count":3,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521421,"discussion_content":"当我们用多核cpu时，问题就不同了 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622986682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308440,"user_name":"Geek_0c1f07","can_delete":false,"product_type":"c1","uid":2007254,"ip_address":"","ucode":"21689194C2A3EA","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/k5OsGRHWreVATJ1tKJBrUJUooENFAprW0X4P5sxa0I6ia9lLWJqwdcMvkkNBAkhyL8GWvmic2dAl0ay9XP0VZCTQ/132","comment_is_top":false,"comment_ctime":1629621401,"is_pvip":false,"replies":[{"id":"111765","content":"因为开启中断有两个方法一个是sti指令，一个是操作eflags寄存器","user_name":"作者回复","comment_id":308440,"uid":"1345199","ip_address":"","utype":1,"ctime":1629771906,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"10219555993","product_id":100078401,"comment_content":"中断嵌套问题那里，我想不明白：【开启中断函数】那里到底是怎么才能打开中断的？<br>比如嵌套场景如下：<br>场景：{关闭中断函数，(关闭中断函数，操作数据，开启中断函数)，操作数据，开启中断函数}。<br>根据代码，只有在关闭中断函数中，能改变内存中的eflags寄存器的标志。而开启中断函数中永远是使用内存中的eflags寄存器的，没有改变内存中的寄存器。那么在此场景中，根据第二个关闭中断函数，内存保存的已经是关闭中断的eflags寄存器，那么开启中断函数每次从内存中读的都是关闭中断的eflags寄存器。所以很矛盾，【开启中断函数】到底是怎么打开中断的？<br>望老师解答我的迷惑！","like_count":2,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525492,"discussion_content":"因为开启中断有两个方法一个是sti指令，一个是操作eflags寄存器","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629771906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300796,"user_name":"吴国豪","can_delete":false,"product_type":"c1","uid":2635606,"ip_address":"","ucode":"0899104FDC2C97","user_header":"https://static001.geekbang.org/account/avatar/00/28/37/56/3a527963.jpg","comment_is_top":false,"comment_ctime":1625390230,"is_pvip":false,"replies":[{"id":"108993","content":"是的 是的 ","user_name":"作者回复","comment_id":300796,"uid":"1345199","ip_address":"","utype":1,"ctime":1625453967,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"10215324822","product_id":100078401,"comment_content":"单核cpu，切换进程必须通过中断，因此可以通过关中断来执行一些同步操作。<br>多核cpu，同步的数据可能会收到别的核心上的进程影响，因此不能仅仅通过关闭当前核心的中断来执行同步操作。因此通过自旋锁。自旋锁要么被获得，要么就一直循环的申请，直到被获得。<br>前面的同步操作，都要求锁的使用时间短，否则就会存在多个经常一直在等待某个进程，造成资源的浪费。信号量通过挂起的操作，让获取锁失败的进程，不再进行循环申请的操作，不再占用cpu资源。直到释放锁的进程，在释放的时候，才将挂起的进程释放，让他们进入竞争锁的状态。<br>","like_count":2,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522820,"discussion_content":"是的 是的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625453967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294779,"user_name":"老男孩","can_delete":false,"product_type":"c1","uid":1134514,"ip_address":"","ucode":"CEC6D47412F620","user_header":"https://static001.geekbang.org/account/avatar/00/11/4f/b2/1e8b5616.jpg","comment_is_top":false,"comment_ctime":1622087045,"is_pvip":false,"replies":[{"id":"106994","content":" 是的，完全不用有心理负担，慢慢学，鄙视链完全是心理作用 ，我有时还要写JS、HTML、CSS呢 ","user_name":"作者回复","comment_id":294779,"uid":"1345199","ip_address":"","utype":1,"ctime":1622093107,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"10212021637","product_id":100078401,"comment_content":"java可以会把锁的状态值放到redis中，然后让redis执行lua脚本来保证执行的原子性。<br>加锁：  if redis.call(&#39;setNx&#39;,KEYS[1],ARGV[1]) == 1 <br>        then if redis.call(&#39;get&#39;,KEYS[1]) == ARGV[1] <br>\t\tthen return redis.call(&#39;expire&#39;,KEYS[1],ARGV[2])<br>\t\telse return 0 end else return 0 end<br>\t\t<br>释放锁：if redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1] <br>        then return redis.call(&#39;del&#39;, KEYS[1]) <br>\t\telse return 0 end<br>\t\t<br>用一个while循环，退出条件是加锁成功。在循环体中把当前线程挂起，并放到一个等待列表中。<br>获得锁的执行流，最后释放锁，并唤醒等待的线程去竞争锁。<br><br>学到这里，我算是明白为什么行业里边有一个鄙视链 ：搞汇编-&gt;搞C的-&gt;搞C++-&gt;搞Java的,看来还是有些道理的。<br>java有很多类库，工具包，第三方组件来帮助程序员解决偏底层的技术实现，让java程序员更专注业务的开发，也就是java们经常自嘲的堆代码搬砖。<br>身为一个java老码农，我觉得我也不用纠结了。跟着老师还有大神们认真的学一下，目标不能搞太高，学完这门课至少能从我不知道我不知道变成我知道我不知道就可以了。如果有意外惊喜，那就更好了。这就是所谓的佛系学习法吧。哈哈！","like_count":2,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520804,"discussion_content":" 是的，完全不用有心理负担，慢慢学，鄙视链完全是心理作用 ，我有时还要写JS、HTML、CSS呢 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622093107,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294671,"user_name":"舞铲阶级","can_delete":false,"product_type":"c1","uid":2346987,"ip_address":"","ucode":"4C34D804E060C9","user_header":"https://static001.geekbang.org/account/avatar/00/23/cf/eb/0a9295e1.jpg","comment_is_top":false,"comment_ctime":1622039634,"is_pvip":true,"replies":[{"id":"107003","content":"你好，正确的","user_name":"作者回复","comment_id":294671,"uid":"1345199","ip_address":"","utype":1,"ctime":1622093885,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"10211974226","product_id":100078401,"comment_content":"一开始，从单个变量可能由于中断，而产生达不到预期结果的情况，可以通过硬件层面的原子操作，来解决相应问题；但硬件层面的的原子操作没办法适应多种多样的数据结构，这个时候就需要对中断来进行处理，保证数据处理过程中的“原子性”，对于嵌套中断的问题采用栈来保存对应的标志寄存器内容，用于还原来解决嵌套问题；但多核CPU可以绕过单个CPU的中断从而影响数据处理的“原子性”（个人理解希望老师指点），这时候通过硬件提供一个变量来形成自旋锁，保证处理的“原子性”，但是仍会由于嵌套中断从而导致占有自旋锁后进入死循环，因此引入关中断自旋锁来保证“原子性”；最后以上三种情况都不支持长时间等待情况，因此引入了信号量，注意对信号量的操作时要使用自旋锁来保证其“原子性”，如有不对希望大家指正。","like_count":2,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520764,"discussion_content":"你好，正确的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622093885,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294492,"user_name":"Fan","can_delete":false,"product_type":"c1","uid":1115232,"ip_address":"","ucode":"3BF28670FD9407","user_header":"https://static001.geekbang.org/account/avatar/00/11/04/60/64d166b6.jpg","comment_is_top":false,"comment_ctime":1621961315,"is_pvip":false,"replies":[{"id":"106860","content":"谢谢啦！欢迎分享你的收获，对梳理自己的思路有帮助，同时也能帮到其他人。","user_name":"编辑回复","user_name_real":"赵宇新","uid":"1501385","ctime":1621995324,"ip_address":"","comment_id":294492,"utype":2}],"discussion_count":1,"race_medal":0,"score":"10211895907","product_id":100078401,"comment_content":"好","like_count":2,"discussions":[{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520675,"discussion_content":"谢谢啦！欢迎分享你的收获，对梳理自己的思路有帮助，同时也能帮到其他人。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621995324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339702,"user_name":"Qfeng","can_delete":false,"product_type":"c1","uid":1466121,"ip_address":"","ucode":"1248E70012BBA2","user_header":"https://static001.geekbang.org/account/avatar/00/16/5f/09/2ec44412.jpg","comment_is_top":false,"comment_ctime":1648301279,"is_pvip":false,"replies":[{"id":"124371","content":"6666","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1648606132,"ip_address":"","comment_id":339702,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5943268575","product_id":100078401,"comment_content":"这篇文章帮助我又从新梳理了一边锁机制，温故知新，又有了新的认识。<br><br>认识锁机制（资源竞争和同步）主要抓住2条线：1）保护资源的大小；2）CPU数<br><br>从保护资源的大小由大到小排列：<br>1. 单变量资源（例如整型变量），可使用原子变量, CPU核数不影响。<br>2. 超过单变量数目的少量资源，此时操作数很多，寄存器就容不下了。<br>    1）对于单核CPU，因为单核CPU的任务调度也是通过中断发起的，在加上对普通中断函数的处理，直接关中断即可。<br>    2）对于多核CPU，引入自旋锁，同时要注意为了防止当前CPU中断嵌套拿锁造成死锁的情况，自旋锁需要关闭本地CPU中断。<br>3. 对于需要长时间等待处理完成的资源，为了避免忙等造成CPU资源的浪费，需要设计出一套既能安全的竞争又能尽可能释放CPU能力的机制，这就是信号量了。<br>   1）包含等待、互斥和唤醒等操作，当拿不到信号量时CPU可以做其他事情；<br>   2）信号量的操作同样需要用自旋锁（关中断）保证排他性；<br>   3）单核和多核CPU都适用。<br><br>以上，谢谢。","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559089,"discussion_content":"6666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648606132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321955,"user_name":"tuyu","can_delete":false,"product_type":"c1","uid":1448863,"ip_address":"","ucode":"B235325B541408","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BIRpwViaN51yynIeFonD7QRlwDCVtKibrG956NTxzEqibOZZVjhMMgibOPmd3VicfYxpknZsic1oJq8KicZvXkmmiajuQg/132","comment_is_top":false,"comment_ctime":1637117409,"is_pvip":false,"replies":[{"id":"117027","content":"66666","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1637307582,"ip_address":"","comment_id":321955,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5932084705","product_id":100078401,"comment_content":"看了好多遍. 终于有点看懂了, 我总结一下我的笔记<br><br>锁是为了解决多并发安全处理一个数据<br><br>1. 当这个数据比较简单或者处理的数据比较简单时, 如果保证只有原子操作, 就能够很好的解决这个问题<br><br>2. 当这个数据比较复杂, 比如一个数据结构, 可以同时修改数据结构中不同的属性的时候, 就需要中断来解决这个问题, 但是单CPU的中断有个问题就是嵌套会出现bug, 于是把eflag的F位值+栈+内存巧妙的解决了这个问题<br><br>3. 随着计算机的发展, 大家开始有多CPU了, Eflag的F是不能解决这个问题, 这个时候科学家用了一个自旋锁, 自旋锁的实现也很巧妙, 操作系统提供一个函数, 保证程序读取锁, 上锁, 开锁都可以是原子性的, 感觉这个是大家使用分布式锁的原型<br><br>4. 现在多个CPU, 但是不能只执行你一个多并发程序, 其他的进程可能会占用你的CPU, 所以有信令这个数据结构, 其中count=1可以抢占, 用悲观锁的思想, 抢占这个信令先锁住这个信令, 然后count-1, 然后执行doSomethins, 然后如果有新的程序来占取, 如果count &lt; 1, 则到队列中排队, 等处理完了，唤醒队列中的人物, 就count+=1, 然后释放sem的锁","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531419,"discussion_content":"66666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637307582,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313072,"user_name":"ppd0705","can_delete":false,"product_type":"c1","uid":1155646,"ip_address":"","ucode":"EB63D4E3FD1E9A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKotsBr2icbYNYlRSlicGUD1H7lulSTQUAiclsEz9gnG5kCW9qeDwdYtlRMXic3V6sj9UrfKLPJnQojag/132","comment_is_top":false,"comment_ctime":1632270682,"is_pvip":false,"replies":[{"id":"113423","content":"不想让信号量值为负","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1632272275,"ip_address":"","comment_id":313072,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5927237978","product_id":100078401,"comment_content":"获取信号量的说明`2. 对信号值 sem_count 执行“减 1”操作，并检查其值是否小于 0。` 和函数krlsem_down的逻辑不匹配：krlsem_down里面是先判断sem_count是否等于1，等于1表示获取到信号量，然后才对sem_count减一","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527217,"discussion_content":"不想让信号量值为负","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632272275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":301650,"user_name":"imzzq","can_delete":false,"product_type":"c1","uid":2678800,"ip_address":"","ucode":"D36D934D65503A","user_header":"https://static001.geekbang.org/account/avatar/00/28/e0/10/5ff0a104.jpg","comment_is_top":false,"comment_ctime":1625799034,"is_pvip":false,"replies":[{"id":"109180","content":"可是系统中不止一个CPU，内核编程人员要遵守相关规则使用自旋锁。不是给人乱用的 ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1625801977,"ip_address":"","comment_id":301650,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5920766330","product_id":100078401,"comment_content":"疑问, 自旋锁里面关闭中断的话时钟中断不就没用了吗?  代码中要到释放自旋锁的时候才会再次打开中断, 也就是说获得自旋锁的进程在释放自旋锁之前不会被调度?... 那是不是影响太大了点, 如果临界区中死循环了, 整个系统就死了?","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523056,"discussion_content":"可是系统中不止一个CPU，内核编程人员要遵守相关规则使用自旋锁。不是给人乱用的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625801977,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":297820,"user_name":"Feen","can_delete":false,"product_type":"c1","uid":2646145,"ip_address":"","ucode":"E6CDC442B7213F","user_header":"https://static001.geekbang.org/account/avatar/00/28/60/81/38b00111.jpg","comment_is_top":false,"comment_ctime":1623803195,"is_pvip":false,"replies":[{"id":"108133","content":"就是  肝！！","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1623806872,"ip_address":"","comment_id":297820,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5918770491","product_id":100078401,"comment_content":"这一章对我来说很干，非常干。内容包括程序本身的原子操作和外部中断，还有在等待期的自旋锁和信号量，将单体应用和分布式应用所能碰到的问题统一。数据同步的问题不止在高并发环境中有，在单机中也有。最后将中断+自旋锁或者中断+信号量的用法甚至中断+自旋锁+信号量的组合用法都用示例表达出来。一步一步的详细说明了如何解决数据同步，本章肝的肝疼。","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521939,"discussion_content":"就是  肝！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623806872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296384,"user_name":"哇咔咔","can_delete":false,"product_type":"c1","uid":1133036,"ip_address":"","ucode":"54BF877836C591","user_header":"https://static001.geekbang.org/account/avatar/00/11/49/ec/6bae1fd7.jpg","comment_is_top":false,"comment_ctime":1622949317,"is_pvip":true,"replies":[{"id":"107572","content":"xchg 是交换 ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622987026,"ip_address":"","comment_id":296384,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5917916613","product_id":100078401,"comment_content":"没看懂为啥x86_spin_lock这个函数上来就用xchg把lock设置为了，不应该只是读取lock的值？不为0才设置为1吗？","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521420,"discussion_content":"xchg 是交换 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622987026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2834444,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/40/0c/19b4224a.jpg","nickname":"不写出操作系统不改名","note":"","ucode":"DD40D98250B688","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":412489,"discussion_content":"用1和内存的lock置换后，如果置换回来的值是0，说明当时没有别人使用。刚才置换后的lock由0变成1，说明本次给加上锁了。如果置换回来的值是1，说明别人已经给上锁了，用自己的1置换别人的1，在数值上没有影响的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1636188760,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133036,"avatar":"https://static001.geekbang.org/account/avatar/00/11/49/ec/6bae1fd7.jpg","nickname":"哇咔咔","note":"","ucode":"54BF877836C591","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377985,"discussion_content":"那既然是寄存器和内存lock交换，lock此时不就变成1了吗？这不是就相当于直接加锁？没懂交换的含义","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622987674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295966,"user_name":"LIUYU","can_delete":false,"product_type":"c1","uid":1248057,"ip_address":"","ucode":"13AE216582EFAD","user_header":"https://static001.geekbang.org/account/avatar/00/13/0b/39/e05b4f74.jpg","comment_is_top":false,"comment_ctime":1622685496,"is_pvip":false,"replies":[{"id":"107598","content":"eax在 ABI标准 中 是无需保存的","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622989273,"ip_address":"","comment_id":295966,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5917652792","product_id":100078401,"comment_content":"4. 损坏列表那个没有明白，看了一下C语言和汇编，没有发现GCC 保存与恢复现场<br>-------C------------<br>int main()<br>{<br>   __asm__ volatile (&quot;movl $1, %%eax\\n\\t&quot;<br>                            :::&quot;%eax&quot;);<br>}<br>&#47;&#47; 生成汇编代码如下<br>#APP<br>       movl $1, %eax<br>#NO_APP<br>没看到哪里有恢复eax 之前的值","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521279,"discussion_content":"eax在 ABI标准 中 是无需保存的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622989273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295254,"user_name":"熊光红","can_delete":false,"product_type":"c1","uid":2617636,"ip_address":"","ucode":"2216C008FAD248","user_header":"https://static001.geekbang.org/account/avatar/00/27/f1/24/07ce02a0.jpg","comment_is_top":false,"comment_ctime":1622335461,"is_pvip":false,"replies":[{"id":"107273","content":"你可以想象一下 一cpu上的运行程序 获取了自旋锁 没有释放自旋锁 中断发生了， 中断处理程序 也要获取 自旋锁 会是什么情况 ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622470338,"ip_address":"","comment_id":295254,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5917302757","product_id":100078401,"comment_content":"“在中断处理程序访问某个自旋锁保护的某个资源时，依然有问题”，这句话怎么理解，能否举一个有问题的例子","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521011,"discussion_content":"你可以想象一下 一cpu上的运行程序 获取了自旋锁 没有释放自旋锁 中断发生了， 中断处理程序 也要获取 自旋锁 会是什么情况 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622470338,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1071668,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5a/34/4cbadca6.jpg","nickname":"吃饭睡觉打酱油","note":"","ucode":"95EC98C2B5045B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":572431,"discussion_content":"老师，这里获取自旋锁的中断程序是不是只会一直循环去获取锁，只要上个程序释放了锁，那么中断处理程序不就得到了自旋锁了么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652781067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":521011,"ip_address":""},"score":572431,"extra":""}]},{"author":{"id":2617636,"avatar":"https://static001.geekbang.org/account/avatar/00/27/f1/24/07ce02a0.jpg","nickname":"熊光红","note":"","ucode":"2216C008FAD248","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377282,"discussion_content":"懂了会死锁，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622589228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295020,"user_name":"的是","can_delete":false,"product_type":"c1","uid":1977717,"ip_address":"","ucode":"BA89D6AB9801E4","user_header":"https://static001.geekbang.org/account/avatar/00/1e/2d/75/4936ecc2.jpg","comment_is_top":false,"comment_ctime":1622186400,"is_pvip":false,"replies":[{"id":"107299","content":"当然有 从第十节课开始","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622473145,"ip_address":"","comment_id":295020,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5917153696","product_id":100078401,"comment_content":"东哥，到本45讲之后是否有完整的这个操作系统的源码？这样才有实操感。","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520916,"discussion_content":"当然有 从第十节课开始","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622473145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1977717,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/2d/75/4936ecc2.jpg","nickname":"的是","note":"","ucode":"BA89D6AB9801E4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377058,"discussion_content":"跟着你一起学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622473221,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294506,"user_name":"尼欧","can_delete":false,"product_type":"c1","uid":1260883,"ip_address":"","ucode":"39D4D1F5F51764","user_header":"https://static001.geekbang.org/account/avatar/00/13/3d/53/9d8a1207.jpg","comment_is_top":false,"comment_ctime":1621987694,"is_pvip":false,"replies":[{"id":"106853","content":"一步一个脚印，加油！","user_name":"编辑回复","user_name_real":"赵宇新","uid":"1501385","ctime":1621990645,"ip_address":"","comment_id":294506,"utype":2}],"discussion_count":1,"race_medal":0,"score":"5916954990","product_id":100078401,"comment_content":"打卡","like_count":1,"discussions":[{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520683,"discussion_content":"一步一个脚印，加油！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621990645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294500,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1621985062,"is_pvip":false,"replies":[{"id":"106934","content":"是的，信号量本身会被多个cpu并行访问，所以它自己也受保护","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622040023,"ip_address":"","comment_id":294500,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5916952358","product_id":100078401,"comment_content":"请问彭老师，信号量实现用的是自旋锁而不是原子变量，是不是因为原子变量在多CPU，多线程的环境下还是存在并发问题？毕竟每个CPU有自己的缓存，原子操作并不能保证CPU缓存之间的同步，原子操作并没有涉及MESI协议？","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520679,"discussion_content":"是的，信号量本身会被多个cpu并行访问，所以它自己也受保护","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622040023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1338751,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6d/7f/e1c189c7.jpg","nickname":"陈诚","note":"","ucode":"138DD00D245FEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376160,"discussion_content":"信号量实现过程中使用自旋锁，是因为锁住的是一组操作，用原子变量是无法实现的","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1621997943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2615928,"avatar":"https://static001.geekbang.org/account/avatar/00/27/ea/78/5ad7aca5.jpg","nickname":"时雨月一","note":"","ucode":"DE616156B84B12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376190,"discussion_content":"你可以看下 sem 的 down 和 up 实现中间被自旋锁加锁的那部分代码，sem 需要保证那部分代码是原子性的，这一串代码很明显光靠原子变量是实现不了的。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1622008694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357311,"user_name":"🌟","can_delete":false,"product_type":"c1","uid":1365063,"ip_address":"湖北","ucode":"74CC4686166538","user_header":"https://static001.geekbang.org/account/avatar/00/14/d4/47/af8df0e9.jpg","comment_is_top":false,"comment_ctime":1663147914,"is_pvip":false,"replies":[{"id":"130133","content":"你这个逻辑不对 每个CPU 核 都会先运行 lock; xchg %0, %1 这条指令 这条指令 不能会被 其它CPU打断的 ","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1663395920,"ip_address":"湖北","comment_id":357311,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1663147914","product_id":100078401,"comment_content":"疑问 请问老师关于自旋锁的<br>lock; xchg %0, %1<br>假设cpu四个核同时运行第一个核执行上边的语句lock中的值变为1，寄存器变为0，第二个核执行次语句时两个值就被调换了 此时如果再有进程来执行这个语句 那寄存器就又变为0了 这个自旋的效果就没有了啊 三个进程并发 那么就会有两个抢到锁啊？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587933,"discussion_content":"你这个逻辑不对 每个CPU 核 都会先运行 lock; xchg %0, %1 这条指令 这条指令 不能会被 其它CPU打断的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663395920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖北"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355145,"user_name":"xiaolver希望自己变强","can_delete":false,"product_type":"c1","uid":2722260,"ip_address":"湖北","ucode":"9771CC097E8273","user_header":"https://static001.geekbang.org/account/avatar/00/29/89/d4/c6f47fb9.jpg","comment_is_top":false,"comment_ctime":1661135948,"is_pvip":false,"replies":[{"id":"129451","content":"是的 ","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1661678311,"ip_address":"湖北","comment_id":355145,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1661135948","product_id":100078401,"comment_content":"一开始觉得关中断那里的引论有点奇怪，及时结构体很大，对其中每一个变量都做原子操作不就好了嘛？难道是懒得实现? 后来觉得一个结构体变量要保持内部状态一致，不是里面的变量原子操作即可的，可能一个方法要对结构体内的多个变量同时操作，这时原子变量就真的不能用了，它只能保证结构体变量中某个单个变量是原子操作","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585571,"discussion_content":"是的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661678311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖北"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":349717,"user_name":"功夫熊猫","can_delete":false,"product_type":"c1","uid":2732243,"ip_address":"","ucode":"D124F4FA4E816F","user_header":"https://static001.geekbang.org/account/avatar/00/29/b0/d3/200e82ff.jpg","comment_is_top":false,"comment_ctime":1656257454,"is_pvip":true,"replies":[{"id":"128068","content":"不会","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1658390688,"ip_address":"","comment_id":349717,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1656257454","product_id":100078401,"comment_content":"信号量在操作系统课上学过，期末考试有道大题就是pv操作。老师，如果不会汇编没有问题吧","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580861,"discussion_content":"不会","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658390688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348960,"user_name":"5AM","can_delete":false,"product_type":"c1","uid":2327226,"ip_address":"","ucode":"1E0248C1D0FDE8","user_header":"https://static001.geekbang.org/account/avatar/00/23/82/ba/74064f01.jpg","comment_is_top":false,"comment_ctime":1655608966,"is_pvip":true,"replies":[{"id":"128073","content":"考虑smp环境","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1658390998,"ip_address":"","comment_id":348960,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1655608966","product_id":100078401,"comment_content":"“加上 lock 前缀的 addl、subl、incl、decl 指令都是原子操作，lock 前缀表示锁定总线。”这一句不太理解，既然是硬件支持的原子操作，为什么还需要通过锁定总线来互斥呢","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580868,"discussion_content":"考虑smp环境","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658390998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346513,"user_name":"luo","can_delete":false,"product_type":"c1","uid":1716827,"ip_address":"","ucode":"1A1DA8EB916ECF","user_header":"https://static001.geekbang.org/account/avatar/00/1a/32/5b/d0c7e813.jpg","comment_is_top":false,"comment_ctime":1653208803,"is_pvip":false,"replies":[{"id":"126501","content":"GCC 是什么版本的","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1653617877,"ip_address":"","comment_id":346513,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1653208803","product_id":100078401,"comment_content":"中断那段代码编译时报错 :<br>interupt.c: Assembler messages:<br>interupt.c:10: Error: invalid instruction suffix for `pushf&#39;<br>interupt.c:12: Error: invalid instruction suffix for `pop&#39;<br><br>有谁知道怎么解决吗，在ubuntu 64位机器上<br><br>网上说文件加.code32，但是编译还是报错，而且变成一堆了：<br>interupt.c:1:1: error: expected identifier or ‘(’ before ‘.’ token<br> .code32<br> ^<br>In file included from &#47;usr&#47;include&#47;stdio.h:74:0,<br>                 from interupt.c:2:<br>&#47;usr&#47;include&#47;libio.h:302:3: error: unknown type name ‘size_t’<br>   size_t __pad5;","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573712,"discussion_content":"GCC 是什么版本的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653617877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346409,"user_name":"多喝水","can_delete":false,"product_type":"c1","uid":3006852,"ip_address":"","ucode":"AF3B6C82330C57","user_header":"https://static001.geekbang.org/account/avatar/00/2d/e1/84/64e8de07.jpg","comment_is_top":false,"comment_ctime":1653110889,"is_pvip":true,"replies":[{"id":"126504","content":"不会","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1653617939,"ip_address":"","comment_id":346409,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1653110889","product_id":100078401,"comment_content":"atomic_write原子写这里多核cpu是不是也会出问题，但是atomic_inc和atomic_add不会有问题，因为有lock锁总线了","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573715,"discussion_content":"不会","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653617939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343015,"user_name":"ljx","can_delete":false,"product_type":"c1","uid":2446982,"ip_address":"","ucode":"6133FC98C44498","user_header":"https://static001.geekbang.org/account/avatar/00/25/56/86/db4c0d1c.jpg","comment_is_top":false,"comment_ctime":1650594725,"is_pvip":true,"replies":[{"id":"125981","content":"看看 这就是基础的力量","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1652066945,"ip_address":"","comment_id":343015,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1650594725","product_id":100078401,"comment_content":"感觉java里的AQS就是利用了这种思想来实现的","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571088,"discussion_content":"看看 这就是基础的力量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652066945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341919,"user_name":"默然","can_delete":false,"product_type":"c1","uid":1521061,"ip_address":"","ucode":"A03C4C93FC5023","user_header":"https://static001.geekbang.org/account/avatar/00/17/35/a5/3c8f8cd4.jpg","comment_is_top":false,"comment_ctime":1649918608,"is_pvip":true,"replies":[{"id":"125075","content":"对的 ","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1650249348,"ip_address":"","comment_id":341919,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1649918608","product_id":100078401,"comment_content":"hal_save_flags_cli 为什么不直接把 eflags 寄存器的值存到 flags 内存里，而是要通过先压栈再弹出的方式呢？是因为没有这样的指令吗","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564450,"discussion_content":"对的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650249348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338806,"user_name":"BruceLi","can_delete":false,"product_type":"c1","uid":2441083,"ip_address":"","ucode":"ABBE2033DF9790","user_header":"https://static001.geekbang.org/account/avatar/00/25/3f/7b/ba507e92.jpg","comment_is_top":false,"comment_ctime":1647746992,"is_pvip":false,"replies":[{"id":"123871","content":"可以的 你这个写法 会很容易打乱CPU流水线","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1647829728,"ip_address":"","comment_id":338806,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1647746992","product_id":100078401,"comment_content":"您好！<br>我对加锁的那段代码有点疑问，可否简化，请看注释部分：<br>static inline void x86_spin_lock(spinlock_t * lock){ __asm__ __volatile__ <br>( &quot;1: \\n&quot; &quot;lock; xchg %0, %1 \\n&quot;&#47;&#47;把值为1的寄存器和lock内存中的值进行交换 <br>&quot;cmpl $0, %0 \\n&quot; &#47;&#47;用0和交换回来的值进行比较 <br>&quot;jnz 2f \\n&quot; &#47;&#47;不等于0，意味lock内存的值为1，属于加锁状态，则跳转后面2标号处运行，实则返回1，循环读取<br>&quot;jmp 3f \\n&quot; &#47;&#47;若等于0，则意味lock内存的值为0，加锁成功，跳转后面3标号处返回，实则结束程序<br>&quot;2: \\n&quot; <br>&quot;jmp 1b \\n&quot;<br>&quot;3: \\n&quot; : : <br>&quot;r&quot;(1), &quot;m&quot;(*lock));}<br><br>谢谢！","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557464,"discussion_content":"可以的 你这个写法 会很容易打乱CPU流水线","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647829728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333170,"user_name":"芥末八爪鱼","can_delete":false,"product_type":"c1","uid":1450316,"ip_address":"","ucode":"8AA979FE95CBE0","user_header":"https://static001.geekbang.org/account/avatar/00/16/21/4c/7ed159ec.jpg","comment_is_top":false,"comment_ctime":1644154078,"is_pvip":false,"replies":[{"id":"121780","content":"只影响可屏蔽中断","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1644284489,"ip_address":"","comment_id":333170,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1644154078","product_id":100078401,"comment_content":"“关中断”这个操作是只影响可屏蔽中断呢？还是说所有中断类型都不响应了？例如此时CPU是否可以响应SMI中断？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549862,"discussion_content":"只影响可屏蔽中断","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644284489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330372,"user_name":"~","can_delete":false,"product_type":"c1","uid":2495621,"ip_address":"","ucode":"BE5E3BD6EE3665","user_header":"https://static001.geekbang.org/account/avatar/00/26/14/85/73e55be5.jpg","comment_is_top":false,"comment_ctime":1641956476,"is_pvip":false,"replies":[{"id":"120887","content":"总结到位","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1642383788,"ip_address":"","comment_id":330372,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1641956476","product_id":100078401,"comment_content":"读后总结一下：<br>我们首先以单核 CPU 演进，首先提出了原子操作的概念，再提出中断。原子操作是对单体变量进行原子性修改，以保证共享数据的安全性，关闭中断则是防止 CPU 中途执行其他代码而导致数据同步问题。原子操作问题在于尽管能够解决同步问题，但是仅仅是作用于单体变量；而关闭中断尽管能够使 CPU 不响应中断继续执行对多个变量的操作，但是没法应对嵌套操作，于是又引入对嵌套操作的改进。<br><br>这时，我们已经拥有了足以应对单核 CPU 同步问题的工具，但是毕竟如今的 CPU 是多核的，关闭中断没法应对，原子操作还是老毛病（没法应对多个变量的同步），势必需要新的工具来应对。<br><br>首先引入自旋锁，机制很简单，按照我的理解，自旋锁的设计就是原子操作的基础，通过原子操作将一段代码的操作权交给某个线程（进程）。原子操作保证的是自旋锁的上锁和解锁，自旋锁保证的是多个操作的同步安全。当然中断的问题也是要同时解决。<br><br>既然自旋锁已经能够解决我们对于同步问题的需求，为什么还要提出「信号量」这个概念呢？能吃饱后就想吃的好，操作系统也是如此。尽管自旋锁能够解决大部分问题，但是他的性能消耗太严重了，同步代码在执行期间只允许一个线程执行，其他的线程只能自旋干等着，如果同步代码执行时间过长，其他线程岂不是一直自旋，不做其他事了？<br><br>那么就引入了「信号量」这个概念，信号量除了也能保证同步代码的安全，还同时还对没有获取到信号量的线程提供一个「休息」的地方，称之为「阻塞队列」。之后就是对信号量的操作，也不必过多解析。<br>补充一下，信号量同步的代码块是可以多个线程同时执行的（需要看信号量的设置），但是对信号量的操作是不允许同时进行的，这需要进行同步，所以我们可以看到文章中的信号量结构体中有设计一个自旋锁用于对信号量操作。<br><br>以上就是我对本课文章的一个总结，好多概念性的定义我有点模糊不清，所以如果有问题欢迎讨论指点~","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546648,"discussion_content":"总结到位","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642383788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328032,"user_name":"Geek_5aa343","can_delete":false,"product_type":"c1","uid":2635369,"ip_address":"","ucode":"535F96029C1EB7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/pNKoOAa1QXibrykHNXibW4tyaIIhicocPGXtcVnEianCyOQY9bl0P2JQ3wSialUaolcLVEWycCEBz1Oe4Tj4yghH9yw/132","comment_is_top":false,"comment_ctime":1640492050,"is_pvip":false,"replies":[{"id":"119663","content":"是的 ","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1640768557,"ip_address":"","comment_id":328032,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640492050","product_id":100078401,"comment_content":"感谢老师，结合我们在高级语言中常用到的mutex操作，差不多实现应该就是文中介绍的最后一种信号量的方式吧，思想就是以最小粒度加锁（xchg）+屏蔽中断（防止锁嵌套）+及时调度（schedule），即“能锁就锁，不锁就睡”","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542501,"discussion_content":"是的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640768557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325105,"user_name":"skyding","can_delete":false,"product_type":"c1","uid":1203386,"ip_address":"","ucode":"29F93E2AB6C5D0","user_header":"https://static001.geekbang.org/account/avatar/00/12/5c/ba/9e4b4420.jpg","comment_is_top":false,"comment_ctime":1638818332,"is_pvip":false,"replies":[{"id":"117984","content":"krlschedul()上一行 就解锁了呀 才进行切换","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1638840753,"ip_address":"","comment_id":325105,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1638818332","product_id":100078401,"comment_content":"krlwlst_wait(&amp;sem-&gt;sem_waitlst);<br>        krlspinunlock_sti(&amp;sem-&gt;sem_lock,&amp;cpufg);<br>        krlschedul();&#47;&#47;切换代码执行流，下次恢复执行时依然从下一行开始执行，所以要goto开始处重新获取信号量<br>        goto start_step; <br>    }<br><br>这里有点奇怪呀，wait就开始等待了 那就表示lock住了，其他线程也进不去代码 一直在自旋。也不能进去信号量释放的代码。这不是死锁了吗","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536640,"discussion_content":"krlschedul()上一行 就解锁了呀 才进行切换","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638840753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323953,"user_name":"树心","can_delete":false,"product_type":"c1","uid":1589523,"ip_address":"","ucode":"6C329F0FF798B9","user_header":"https://static001.geekbang.org/account/avatar/00/18/41/13/ab14ad25.jpg","comment_is_top":false,"comment_ctime":1638238626,"is_pvip":true,"replies":[{"id":"117621","content":"哈哈 谢谢","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1638323038,"ip_address":"","comment_id":323953,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1638238626","product_id":100078401,"comment_content":"小结<br>08 | 锁：并发操作中，解决数据同步的四种方法<br>非预期结果的全局变量<br>方法一：原子操作 拿下单体变量<br>方法二：中断控制 搞定复杂变量<br>方法三：自旋锁 协调多核心 CPU<br>方法四：信号量 CPU 时间管理大师<br><br>老师的脉络很清楚，了解基本概念是没问题的，再进一步学习需要多读几遍、看评论区的高质量评论、查找更多资料。","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534945,"discussion_content":"哈哈 谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638323038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321967,"user_name":"Biden","can_delete":false,"product_type":"c1","uid":2820428,"ip_address":"","ucode":"D1217E2D4DE798","user_header":"","comment_is_top":false,"comment_ctime":1637119309,"is_pvip":false,"replies":[{"id":"117026","content":"这个理解不对 仔细看课程","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1637307554,"ip_address":"","comment_id":321967,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1637119309","product_id":100078401,"comment_content":"我想问一下方法二中bar函数最后是怎么开启中断的？<br>第一个cli执行后，内存中保存的eflag是1，寄存器是中断关闭状态。然而执行完foo()后，内存中的eflag被替换为0，寄存器还是中断关闭状态。此时再执行sti函数，内存中保存的是0，没法再开启中断了。<br>出现这种情况，是因为foo执行cli后，内存中原先保存的1被替换为0了，那最后怎么开启中断呢？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531417,"discussion_content":"这个理解不对 仔细看课程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637307554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1237500,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI3jSpV7VvK6NaUH6X1LNYWGsQdFSTu4SwTZ0nQlSYGTOY2FrDCcMic9qFXnu2ZGR88hBlUQK28Whg/132","nickname":"古月弓虽1993","note":"","ucode":"86122CC701F02A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583311,"discussion_content":"每次保存状态到内存，内存是不同的地址，比如第一层函数保存在flagA地址，第二层函数保存在flagB地址","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660027216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"美国"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321780,"user_name":"达叔灬","can_delete":false,"product_type":"c1","uid":2404887,"ip_address":"","ucode":"5CCBAF13548F02","user_header":"https://static001.geekbang.org/account/avatar/00/24/b2/17/3161b49c.jpg","comment_is_top":false,"comment_ctime":1637044621,"is_pvip":false,"replies":[{"id":"116864","content":"哪里不懂欢迎提出探讨。","user_name":"编辑回复","user_name_real":"编辑","uid":"1501385","ctime":1637062921,"ip_address":"","comment_id":321780,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1637044621","product_id":100078401,"comment_content":"第二遍了  net开发人员表示 还是不懂  看看评论区大佬们的总结  准备第三遍","like_count":0,"discussions":[{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530383,"discussion_content":"哪里不懂欢迎提出探讨。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637062921,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321263,"user_name":"twigle","can_delete":false,"product_type":"c1","uid":1228894,"ip_address":"","ucode":"9D2439BFF8B99F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKRLfnpj6j5SNVFyH4bQxxKibqIDEIsYQZYmGqcEbQdxfDWMvCQFtnI9sKIa8C7sl4aYbuWZr2tK3w/132","comment_is_top":false,"comment_ctime":1636729071,"is_pvip":false,"replies":[{"id":"116768","content":"不是 这是防止编译器优化的 和硬件无关","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1636940880,"ip_address":"","comment_id":321263,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1636729071","product_id":100078401,"comment_content":"volatile 关键字 是实现锁的汇编代码防止cpu乱序执行的原因吧？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530254,"discussion_content":"不是 这是防止编译器优化的 和硬件无关","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636940880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320555,"user_name":"T------T","can_delete":false,"product_type":"c1","uid":2270365,"ip_address":"","ucode":"AC68D88893FAD7","user_header":"https://static001.geekbang.org/account/avatar/00/22/a4/9d/95900f70.jpg","comment_is_top":false,"comment_ctime":1636377687,"is_pvip":true,"replies":[{"id":"116318","content":"是的 ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1636506162,"ip_address":"","comment_id":320555,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1636377687","product_id":100078401,"comment_content":"自旋锁之所以叫自旋锁，是因为抢不到锁的时候，它在不断的循环等待锁吗？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530045,"discussion_content":"是的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636506162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320554,"user_name":"T------T","can_delete":false,"product_type":"c1","uid":2270365,"ip_address":"","ucode":"AC68D88893FAD7","user_header":"https://static001.geekbang.org/account/avatar/00/22/a4/9d/95900f70.jpg","comment_is_top":false,"comment_ctime":1636377113,"is_pvip":true,"replies":[{"id":"116319","content":"是的","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1636506174,"ip_address":"","comment_id":320554,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1636377113","product_id":100078401,"comment_content":"递归锁的实现应该和嵌套关中断类似。","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530044,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636506174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320282,"user_name":"不写出操作系统不改名","can_delete":false,"product_type":"c1","uid":2834444,"ip_address":"","ucode":"DD40D98250B688","user_header":"https://static001.geekbang.org/account/avatar/00/2b/40/0c/19b4224a.jpg","comment_is_top":false,"comment_ctime":1636198757,"is_pvip":false,"replies":[{"id":"116167","content":"赢得竞争的进程，在底层 粗暴的情况下 就是硬件总线决定 的，也可以通过算法实现 排队自旋锁","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1636332604,"ip_address":"","comment_id":320282,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1636198757","product_id":100078401,"comment_content":"有一个疑问，就是当自旋锁已经被其他进程持有，然后被释放了，那一直在自旋等待的很多进程该由谁先获得自旋锁呢？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529938,"discussion_content":"赢得竞争的进程，在底层 粗暴的情况下 就是硬件总线决定 的，也可以通过算法实现 排队自旋锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636332604,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320269,"user_name":"不写出操作系统不改名","can_delete":false,"product_type":"c1","uid":2834444,"ip_address":"","ucode":"DD40D98250B688","user_header":"https://static001.geekbang.org/account/avatar/00/2b/40/0c/19b4224a.jpg","comment_is_top":false,"comment_ctime":1636189533,"is_pvip":false,"replies":[{"id":"116168","content":"信号量有两种，一种是互斥信号量 一种是计数信号量，我的代码是防止小于0，因为我的信号量值类型是无符号类型，实现方式不同","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1636332969,"ip_address":"","comment_id":320269,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1636189533","product_id":100078401,"comment_content":"第一步，获取信号量。1. 首先对用于保护信号量自身的自旋锁 sem_lock 进行加锁。2. 对信号值 sem_count 执行“减 1”操作，并检查其值是否小于 0。3. 上步中检查 sem_count 如果小于 0，就让进程进入等待状态并且将其挂入 sem_waitlst 中，然后调度其它进程运行。否则表示获取信号量成功。当然最后别忘了对自旋锁 sem_lock 进行解锁。<br><br>----------<br>&#47;获取信号量void krlsem_down(sem_t* sem){    cpuflg_t cpufg;start_step:        krlspinlock_cli(&amp;sem-&gt;sem_lock,&amp;cpufg);    if(sem-&gt;sem_count&lt;1)    {&#47;&#47;如果信号量值小于1,则让代码执行流（线程）睡眠        krlwlst_wait(&amp;sem-&gt;sem_waitlst);        krlspinunlock_sti(&amp;sem-&gt;sem_lock,&amp;cpufg);        krlschedul();&#47;&#47;切换代码执行流，下次恢复执行时依然从下一行开始执行，所以要goto开始处重新获取信号量        goto start_step;     }    sem-&gt;sem_count--;&#47;&#47;信号量值减1,表示成功获取信号量    krlspinunlock_sti(&amp;sem-&gt;sem_lock,&amp;cpufg);    return;}<br><br>==========<br>老师，我有个疑问：<br>上面文字描述的信号量流程和下面代码的逻辑有些出入。<br>代码中是在判断sem_count&gt;=1时进行自减的，而不是文字描述中的获取到自旋锁之后就开始自减。这里是不是笔误呢？如果获取到自旋锁之后就自减的话，那sem_count的值可能会出现小于等于-1的情况，比如有10个进程申请信号量，只有第1个能成功获取，那剩下的9的进程就把sem_count搞成-9了。","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529935,"discussion_content":"信号量有两种，一种是互斥信号量 一种是计数信号量，我的代码是防止小于0，因为我的信号量值类型是无符号类型，实现方式不同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636332969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318732,"user_name":"缺少社会的毒打","can_delete":false,"product_type":"c1","uid":2814755,"ip_address":"","ucode":"2A481A4E05158D","user_header":"","comment_is_top":false,"comment_ctime":1635406338,"is_pvip":false,"replies":[{"id":"115584","content":"不会的","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1635432295,"ip_address":"","comment_id":318732,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1635406338","product_id":100078401,"comment_content":"假设cpu有2个核心，然后有2进程获取自旋锁失败，是否会发生因为中断关闭，操作系统无法切换进程，最后死机的情况？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529360,"discussion_content":"不会的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635432295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318550,"user_name":"我是谁","can_delete":false,"product_type":"c1","uid":1010796,"ip_address":"","ucode":"2362EABBFFF7C2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6c/6c/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1635329291,"is_pvip":true,"replies":[{"id":"115513","content":"加锁都是内核代码，内核代码加锁没有释放锁 说明内核代码有bug","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1635383331,"ip_address":"","comment_id":318550,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1635329291","product_id":100078401,"comment_content":"老师，问个关于自旋锁的问题。进程自旋的时候是不会释放CPU的，如果锁一直被其他进程占用，那自旋的进程是不是在CPU时间片结束后就释放了CPU呢？要不然如果一直自旋拿不到锁，岂不是这个CPU无法服务其他进程了？谢谢","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529296,"discussion_content":"加锁都是内核代码，内核代码加锁没有释放锁 说明内核代码有bug","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635383331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316761,"user_name":"linuxery","can_delete":false,"product_type":"c1","uid":2300810,"ip_address":"","ucode":"728F3CB43825A7","user_header":"https://static001.geekbang.org/account/avatar/00/23/1b/8a/9d276b39.jpg","comment_is_top":false,"comment_ctime":1634543014,"is_pvip":true,"replies":[{"id":"114792","content":"主动让出CPU 需要对很多代码进行修改成可重入函数","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1634689259,"ip_address":"","comment_id":316761,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1634543014","product_id":100078401,"comment_content":"中断问题，这里的中断是不是把硬中断和软中断区分开来比较好点。比如，网卡来数据了，通过cpu的负载均衡给某个核（架设A核）发硬中断，快来我的缓冲区取数据，不然我的缓冲区就要爆了（网络数据丢失），此时A核理论上需要1.立马去响应这个中断，首先关闭此核的中断，然后把数据从网卡缓冲区拷贝到os的缓冲区，开启中断2.接着通知相应的应用从os缓冲区取数据。显然步骤2不需要A核立马执行，可以有软中断来执行（tasklet吧）<br><br>自旋锁问题：<br>1.自旋锁不能等临界区过长时间，好奇的是内核为何不提供一个可测量等的时间或次数。以至于实际应用中需要来封装下，看锁了多少次，以评估锁的粒度。<br>2.自旋锁在等锁的时间过久的情况下内核为什么不自动执行sched_yield(),把cpu让出来？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528491,"discussion_content":"主动让出CPU 需要对很多代码进行修改成可重入函数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634689259,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313060,"user_name":"子青","can_delete":false,"product_type":"c1","uid":1200029,"ip_address":"","ucode":"F6D22EB15325FD","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/9d/72461b25.jpg","comment_is_top":false,"comment_ctime":1632237629,"is_pvip":true,"replies":[{"id":"113420","content":"我就是不想让它为负","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1632272173,"ip_address":"","comment_id":313060,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1632237629","product_id":100078401,"comment_content":"在信号量这节，文字的步骤是先-1再检查是否 &lt; 0, 而代码里实际是先检查是否&lt;1再-1，为什么呢？这样信号量永远是非负，可我记得操作系统课上的信号量可以为负，负多少说明有多少个线程&#47;进程在等这个资源","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527215,"discussion_content":"我就是不想让它为负","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632272173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312135,"user_name":"baila","can_delete":false,"product_type":"c1","uid":1103495,"ip_address":"","ucode":"95B069604234BD","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/87/b8253dc1.jpg","comment_is_top":false,"comment_ctime":1631634449,"is_pvip":false,"replies":[{"id":"113147","content":"谢谢","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1631751728,"ip_address":"","comment_id":312135,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631634449","product_id":100078401,"comment_content":"大佬，膜拜，每个点都讲的透彻易懂","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526874,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631751728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":309832,"user_name":"Vvin","can_delete":false,"product_type":"c1","uid":1459341,"ip_address":"","ucode":"664901060BDA33","user_header":"","comment_is_top":false,"comment_ctime":1630368076,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630368076","product_id":100078401,"comment_content":"信号量up小于等于0不是理论正常吗说明还有等待<br>","like_count":0},{"had_liked":false,"id":306642,"user_name":"李yong","can_delete":false,"product_type":"c1","uid":2620499,"ip_address":"","ucode":"ECA57ACFE44024","user_header":"https://static001.geekbang.org/account/avatar/00/27/fc/53/836c87d1.jpg","comment_is_top":false,"comment_ctime":1628654808,"is_pvip":false,"replies":[{"id":"111163","content":"对 对 对 ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1628824536,"ip_address":"","comment_id":306642,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1628654808","product_id":100078401,"comment_content":"之前没有学习过操作系统，看了两遍，总结一下自己的理解,。<br>1. 原子操作，可以解决单个变量并发问题。不管后续多核cpu还是单核cpu. <br>缺点在于只对于单个变量有效。<br>实现方式，汇编lock.<br>汇编lock这种方式后续几种方法都会涉及到。<br>2. 中断。单核cpu时只有一个流，唯一可能的并发就是中断，关闭中断即可解决问题。<br>缺点，只对于单核cpu有效。<br>实现方式，关闭中断。<br>不管单核还是多核，都会存在中断引起并发的情况，所以后面两种方法都涉及关闭中断。<br>3.自旋锁。可以突破原子操作和中断的限制，即支持多个变量并发以及多核cpu. 额外增加锁变量，锁变量值为0还是1指使此时是否存在并发。存在并发时，循环判断此锁变量的值，直到其他并发结束。不存在并发时，对锁变量加锁。需要关闭中断避免中断的影响。<br>缺点，存在并发时，其他流一直试图获取锁变量，占用cpu资源。<br>实现方式，增加锁变量，指使是否存在并发。<br>4. 信号量。增加结构体，结构体中包含count信号量计数值和list用于挂载等待任务流列表。count为0，任务流进入休眠状态(释放出cpu, 可以调度其他任务流)。count为1.获取信号量，可执行后续操作，并将count置为0，表示已占用，执行完成后，将count加1，","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524852,"discussion_content":"对 对 对 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628824536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":306390,"user_name":"xzy","can_delete":false,"product_type":"c1","uid":1002095,"ip_address":"","ucode":"1A44368083A19E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","comment_is_top":false,"comment_ctime":1628522212,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628522212","product_id":100078401,"comment_content":"老师可以讲一下lock指令是如何影响指令重排的吗？","like_count":0},{"had_liked":false,"id":306389,"user_name":"xzy","can_delete":false,"product_type":"c1","uid":1002095,"ip_address":"","ucode":"1A44368083A19E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","comment_is_top":false,"comment_ctime":1628522104,"is_pvip":false,"replies":[{"id":"110935","content":"这是cpu内核的问题 ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1628561552,"ip_address":"","comment_id":306389,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1628522104","product_id":100078401,"comment_content":"lock 指令除了会锁住总线外，是不是还要确保在lock指令执行期间，不能响应中断，不能在执行该指令的cpu上发生进程和线程的切换，来保证lock指令的原子性？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524742,"discussion_content":"这是cpu内核的问题 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628561552,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303361,"user_name":"yf","can_delete":false,"product_type":"c1","uid":2636690,"ip_address":"","ucode":"4D81F5FD54C7FC","user_header":"https://static001.geekbang.org/account/avatar/00/28/3b/92/d018ecbb.jpg","comment_is_top":false,"comment_ctime":1626751290,"is_pvip":false,"replies":[{"id":"109849","content":"是的 x86下的方式大同小异","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1626833746,"ip_address":"","comment_id":303361,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1626751290","product_id":100078401,"comment_content":"老师，想请教一个问题，本章实现的这些同步的方式，是我们基于X86的机制实现的吗？是以后会用在我们自己的操作系统中的吗？以前也看过linux的内核以及驱动程序中的同步机制，我们这边就是想实现和它相同的功能，完善自己的操作系统吗？看前面的课，我们是通过类似于编译内核的方式，写进去，那么这个方式下，我们的操作系统也会有自己的内核，驱动这些东西吗？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523647,"discussion_content":"是的 x86下的方式大同小异","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626833746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303015,"user_name":"Pure","can_delete":false,"product_type":"c1","uid":2693109,"ip_address":"","ucode":"AADAA289B0C742","user_header":"https://static001.geekbang.org/account/avatar/00/29/17/f5/93682e42.jpg","comment_is_top":false,"comment_ctime":1626517402,"is_pvip":false,"replies":[{"id":"109733","content":"代码都写出来了 ，这很抽象吗 ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1626661518,"ip_address":"","comment_id":303015,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1626517402","product_id":100078401,"comment_content":"这章感觉还是有点抽象啊，当初在上操作系统这门课的时候就学了信号量，感觉看起来没什么困难，但是吧，总觉得是有一点儿抽象了，整个过程只能在脑子里完成，希望大佬以后可以做几个动图辅助我们理解理解？哈哈哈哈哈","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523515,"discussion_content":"代码都写出来了 ，这很抽象吗 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626661518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303008,"user_name":"Pure","can_delete":false,"product_type":"c1","uid":2693109,"ip_address":"","ucode":"AADAA289B0C742","user_header":"https://static001.geekbang.org/account/avatar/00/29/17/f5/93682e42.jpg","comment_is_top":false,"comment_ctime":1626514731,"is_pvip":false,"replies":[{"id":"109734","content":"都是内核代码","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1626661546,"ip_address":"","comment_id":303008,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1626514731","product_id":100078401,"comment_content":"想问一下，这些代码都是内核代码还是什么类型的代码呢","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523512,"discussion_content":"都是内核代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626661546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":301974,"user_name":"Geek_4b6813","can_delete":false,"product_type":"c1","uid":1721895,"ip_address":"","ucode":"ED10C17BE368B4","user_header":"https://static001.geekbang.org/account/avatar/00/1a/46/27/eb318d12.jpg","comment_is_top":false,"comment_ctime":1626003809,"is_pvip":false,"replies":[{"id":"109268","content":"关中断是特权指令，开放给应用，应用也不能正常运行的 ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1626015748,"ip_address":"","comment_id":301974,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1626003809","product_id":100078401,"comment_content":"操作系统实现的自旋锁api不能直接暴露给应用层使用。因为涉及cpu的关中断，所以不能由用户进程来控制，否则就有可能带来灾难性的后果(比如进程忘记开中断了)。<br>自旋锁的特性决定了只能在操作系统层面使用保证操作的原子性，对于os来说自旋锁的使用是可控的，但是也需要控制关闭中断的时间，保证最小粒度的使用。","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523140,"discussion_content":"关中断是特权指令，开放给应用，应用也不能正常运行的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626015748,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300668,"user_name":"王建峰","can_delete":false,"product_type":"c1","uid":1968013,"ip_address":"","ucode":"8BF1AEFFA7EA5F","user_header":"https://static001.geekbang.org/account/avatar/00/1e/07/8d/3e76560f.jpg","comment_is_top":false,"comment_ctime":1625299032,"is_pvip":false,"replies":[{"id":"108930","content":"谢谢，后面更精彩。","user_name":"编辑回复","user_name_real":"赵宇新","uid":"1501385","ctime":1625299694,"ip_address":"","comment_id":300668,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1625299032","product_id":100078401,"comment_content":"牛逼","like_count":0,"discussions":[{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522789,"discussion_content":"谢谢，后面更精彩。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625299694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300297,"user_name":"青玉白露","can_delete":false,"product_type":"c1","uid":2619436,"ip_address":"","ucode":"96FE2D4D2B94A0","user_header":"https://static001.geekbang.org/account/avatar/00/27/f8/2c/92969c48.jpg","comment_is_top":false,"comment_ctime":1625101129,"is_pvip":false,"replies":[{"id":"108849","content":"你好，感觉怎么样","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1625103906,"ip_address":"","comment_id":300297,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1625101129","product_id":100078401,"comment_content":"这篇让我全称都头皮发麻，之前自以为了解同步的底层了，彭老师的一番讲解才发现许多的细节不甚了解。再回过头去阅读一遍","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522701,"discussion_content":"你好，感觉怎么样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625103906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":299984,"user_name":"lll..l.","can_delete":false,"product_type":"c1","uid":2665511,"ip_address":"","ucode":"12A0FF784FC558","user_header":"https://static001.geekbang.org/account/avatar/00/28/ac/27/88f21e17.jpg","comment_is_top":false,"comment_ctime":1624947900,"is_pvip":false,"replies":[{"id":"108795","content":"int","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1624958551,"ip_address":"","comment_id":299984,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1624947900","product_id":100078401,"comment_content":"s32_t是什么类型变量？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522605,"discussion_content":"int","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624958551,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2665511,"avatar":"https://static001.geekbang.org/account/avatar/00/28/ac/27/88f21e17.jpg","nickname":"lll..l.","note":"","ucode":"12A0FF784FC558","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381235,"discussion_content":"为什么是int","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624962824,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":299916,"user_name":"Geek_4b6813","can_delete":false,"product_type":"c1","uid":1721895,"ip_address":"","ucode":"ED10C17BE368B4","user_header":"https://static001.geekbang.org/account/avatar/00/1a/46/27/eb318d12.jpg","comment_is_top":false,"comment_ctime":1624914767,"is_pvip":false,"replies":[{"id":"108756","content":"第一点是对的。第二点不准确","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1624930081,"ip_address":"","comment_id":299916,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1624914767","product_id":100078401,"comment_content":"有几个问题不解<br>1.lock命令是锁住地址总线，目的是阻止多核同时访问同一块内存区域。但是仅仅只是锁住内存总线并不能保证原子性把？假设只有一核的情况下，线程先锁住地址总线，然后响应中断执行中断程序，中断程序此时访问被锁住的地址总线不就出现类似死锁的情况了吗？所以lock命令是不是不仅仅只是锁住地址总线那么简单呢<br>2.关中断函数不可嵌套调用，但是嵌套调用的情况下，用于存放eflags的内存地址不能相同。否则前面的flag位会被覆盖导致状态丢失。而自旋锁的不可嵌套调用，指的是针对同一个锁变量（用于和寄存器交换数值的区域），不能重复调用，否则被嵌套调用的函数会立刻进入死循环中，这样理解对吗？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522585,"discussion_content":"第一点是对的。第二点不准确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624930081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2085640,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/d3/08/ffd93029.jpg","nickname":"太阳","note":"","ucode":"24B8E951956789","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389558,"discussion_content":"第一点咋办？除了锁总线外还进行了什么操作才保证原子性的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629337555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":299644,"user_name":"PawN","can_delete":false,"product_type":"c1","uid":1234005,"ip_address":"","ucode":"D0678E699327DE","user_header":"https://static001.geekbang.org/account/avatar/00/12/d4/55/a5ec04f4.jpg","comment_is_top":false,"comment_ctime":1624777549,"is_pvip":false,"replies":[{"id":"108700","content":"是的","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1624844765,"ip_address":"","comment_id":299644,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1624777549","product_id":100078401,"comment_content":"现在标准库提供的 Mutex， ReadLock 这些，相当于就是一种信号量的实现吗， 在Guard 的构造和析构里面进行自旋锁的操作","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522494,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624844765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":298819,"user_name":"unuse1ess","can_delete":false,"product_type":"c1","uid":2635491,"ip_address":"","ucode":"FBDFF6CA390F43","user_header":"https://static001.geekbang.org/account/avatar/00/28/36/e3/f2f9f763.jpg","comment_is_top":false,"comment_ctime":1624336360,"is_pvip":false,"replies":[{"id":"108442","content":"不能肯定","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1624421345,"ip_address":"","comment_id":298819,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1624336360","product_id":100078401,"comment_content":"我记得x86 x开头的指令是自带lock的效果的","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522256,"discussion_content":"不能肯定","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624421345,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":298564,"user_name":"Mike_Han","can_delete":false,"product_type":"c1","uid":2616914,"ip_address":"","ucode":"C0E41AD4247A62","user_header":"https://static001.geekbang.org/account/avatar/00/27/ee/52/cda34b19.jpg","comment_is_top":false,"comment_ctime":1624197320,"is_pvip":false,"replies":[{"id":"108326","content":"你要了解自旋锁","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1624239844,"ip_address":"","comment_id":298564,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1624197320","product_id":100078401,"comment_content":"老师，我想请教下下，原子操作解决了中断和进程的同步，那多进程之间，多核之间能解决么？<br>Lock锁总线，锁的是哪条总线，都有哪些总线？这个总线上都有哪些信号通过？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522174,"discussion_content":"你要了解自旋锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624239844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":297341,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1350446,"ip_address":"","ucode":"56E8AD725D9D1A","user_header":"https://static001.geekbang.org/account/avatar/00/14/9b/2e/7c749c3f.jpg","comment_is_top":false,"comment_ctime":1623468859,"is_pvip":false,"replies":[{"id":"108072","content":"你好，只关闭了当前CPU的中断 ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1623723961,"ip_address":"","comment_id":297341,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1623468859","product_id":100078401,"comment_content":"x86_spin_lock_disable_irq函数中关闭中断是把所有cpu的中断都关闭了吗，还是只关闭了当前cpu的中断","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521802,"discussion_content":"你好，只关闭了当前CPU的中断 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623723961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296633,"user_name":"feihui","can_delete":false,"product_type":"c1","uid":1007294,"ip_address":"","ucode":"13F1D4A82BC650","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/be/9ea55f46.jpg","comment_is_top":false,"comment_ctime":1623075051,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1623075051","product_id":100078401,"comment_content":"（极客时间留言没有楼层是贼麻烦）结合进程调度时机：主动调度、系统调用返回调度、中断程序返回调度、驱动程序返回调度，在关闭中断之后，第三跟第四就没有条件，只要在用户进程中不主动ye ild或者调用阻塞方法，就能确保单CPU下的并发安全，不知道这个理解对不对","like_count":0},{"had_liked":false,"id":296557,"user_name":"feihui","can_delete":false,"product_type":"c1","uid":1007294,"ip_address":"","ucode":"13F1D4A82BC650","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/be/9ea55f46.jpg","comment_is_top":false,"comment_ctime":1623045633,"is_pvip":true,"replies":[{"id":"107730","content":"关于第二个解决方案中断控制，在单 CPU 但多任务的下也是会有并发问题，中断控制仅仅是用户代码执行流跟中断代码执行流的并发访问<br>----------------------------------------------<br>不会的，关掉中断你不能调度进程了，所以不会有问题，如果你在关中断的情况下，调度到别的进程了，这是属于自主的行为，不是机制的问题，类似于明明前面是红灯，但你就是要闯，出问题了你当然要负责","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1623072699,"ip_address":"","comment_id":296557,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1623045633","product_id":100078401,"comment_content":"老师，跟您确认下，关于第二个解决方案中断控制，在单 CPU 但多任务的下也是会有并发问题，中断控制仅仅是用户代码执行流跟中断代码执行流的并发访问。此外，第三个解决方案自旋锁，中断嵌套的问题应该是跟自旋锁无关 ( 实际上也应该相关 )，是跟嵌套开关中断的问题，之所以关中断是因为有可能导致中断代码访问自旋锁无限循环，而对于用户代码由于有时间片限制，则不是。对吗？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521486,"discussion_content":"关于第二个解决方案中断控制，在单 CPU 但多任务的下也是会有并发问题，中断控制仅仅是用户代码执行流跟中断代码执行流的并发访问\n----------------------------------------------\n不会的，关掉中断你不能调度进程了，所以不会有问题，如果你在关中断的情况下，调度到别的进程了，这是属于自主的行为，不是机制的问题，类似于明明前面是红灯，但你就是要闯，出问题了你当然要负责","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623072699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296370,"user_name":"杰良","can_delete":false,"product_type":"c1","uid":2567349,"ip_address":"","ucode":"5DC1D1C58A4731","user_header":"https://static001.geekbang.org/account/avatar/00/27/2c/b5/10141329.jpg","comment_is_top":false,"comment_ctime":1622944416,"is_pvip":false,"replies":[{"id":"107574","content":"是啊，你总结的对","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622987503,"ip_address":"","comment_id":296370,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1622944416","product_id":100078401,"comment_content":"由于调度切换运行（假并行）以及多核多处理器的同时操作（真并行），对共同数据的操作可能会存在不符合预期的结果。有四种方法应对：<br>1）使用处理器提供的原子操作指令，调度切换时不会分隔，从而保证数据一致。但该类指令有限，只能用于单体变量的操作，而且对多核处理器无效。<br>2）关闭中断，也就直接禁止了调度切换。这个同样对多核处理器无效。<br>3）自旋锁，利用了原子性的比较与交换指令，通过设置内置中变量的值，做到多核处理器之间的同步。如果其中一个进程长时间占用锁，其他进程会持续地重复尝试获取锁，这样会很浪费处理器计算资源。<br>4）信号量，在尝试获取信号量（锁）失败时会主动挂起自己切换到其他进程执行，下次调度运行时再次尝试获取。另外，信号量的使用增加了初始化步骤，可用于多个信号量的情况，而不是自旋锁的独占资源用法。","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521416,"discussion_content":"是啊，你总结的对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622987503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295793,"user_name":"莎思比亚","can_delete":false,"product_type":"c1","uid":2066849,"ip_address":"","ucode":"71A9C184E9832C","user_header":"https://static001.geekbang.org/account/avatar/00/1f/89/a1/2e2d6d0b.jpg","comment_is_top":false,"comment_ctime":1622599992,"is_pvip":false,"replies":[{"id":"107608","content":"是同样的原理 ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622989730,"ip_address":"","comment_id":295793,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1622599992","product_id":100078401,"comment_content":"老师好，请问老师，Lock-free中的CAS(Compare and Swap)原子操作，是否跟这讲中的原子操作是否是同一回事呢？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521218,"discussion_content":"是同样的原理 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622989730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295602,"user_name":"漫游者","can_delete":false,"product_type":"c1","uid":1058856,"ip_address":"","ucode":"7402D9068413D5","user_header":"https://static001.geekbang.org/account/avatar/00/10/28/28/5ffdd123.jpg","comment_is_top":false,"comment_ctime":1622509555,"is_pvip":false,"replies":[{"id":"107618","content":"后面的代码逻辑是解锁之后才会睡眠 的","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622990254,"ip_address":"","comment_id":295602,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1622509555","product_id":100078401,"comment_content":"krlspinlock_cli(&amp;sem-&gt;sem_lock,&amp;cpufg);<br>老师这里如果有多个线程竞争自旋锁，除了加锁成功的，剩下的不都在自旋忙等待中么？又怎么会执行到接下来的代码。","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521143,"discussion_content":"后面的代码逻辑是解锁之后才会睡眠 的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622990254,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295530,"user_name":"木易杨","can_delete":false,"product_type":"c1","uid":1353456,"ip_address":"","ucode":"3C6EFF05AFFACA","user_header":"https://static001.geekbang.org/account/avatar/00/14/a6/f0/50d0931d.jpg","comment_is_top":false,"comment_ctime":1622464334,"is_pvip":false,"replies":[{"id":"107255","content":"你好，就是差不多一样的东西","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622469054,"ip_address":"","comment_id":295530,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1622464334","product_id":100078401,"comment_content":"这个信号量感觉和互斥锁很类似了？这2个有什么关联嘛？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521116,"discussion_content":"你好，就是差不多一样的东西","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622469054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2720455,"avatar":"https://static001.geekbang.org/account/avatar/00/29/82/c7/743c42a2.jpg","nickname":"知寒，","note":"","ucode":"E27349073FAD6E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386913,"discussion_content":"个人认为互斥锁可以理解成一种特殊的信号量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627890627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295509,"user_name":"Geek_tgq","can_delete":false,"product_type":"c1","uid":1522000,"ip_address":"","ucode":"CA1F4AA5F2D8D6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/pV7g6NclSVCnQFX3EyQLsI0BtopYGIjmvBFSB3pXiawdxKOFn0Zhvb2l5UEGjukVAkll83amjOyM9RZK8wU191A/132","comment_is_top":false,"comment_ctime":1622455635,"is_pvip":false,"replies":[{"id":"107257","content":"执行down操作 不可以小于1的","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622469180,"ip_address":"","comment_id":295509,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1622455635","product_id":100078401,"comment_content":"```<br>if(sem-&gt;sem_count&lt;1)   &#47;&#47; 这里不是&gt;1才挂起吗？如果&lt;1就挂起，多个线程down之后，是不是没法释放了？不知道我理解得对不对？<br> {&#47;&#47;如果小于1,则说数据结构出错了，挂起系统       <br> krlspinunlock_sti(&amp;sem-&gt;sem_lock,&amp;cpufg);       <br> hal_sysdie(&quot;sem up err&quot;);    <br>}<br>```","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521110,"discussion_content":"执行down操作 不可以小于1的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622469180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294936,"user_name":"！null","can_delete":false,"product_type":"c1","uid":1242483,"ip_address":"","ucode":"4E5B7922980397","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/73/f7d3a996.jpg","comment_is_top":false,"comment_ctime":1622160642,"is_pvip":false,"replies":[{"id":"107307","content":"不是  它用来锁定总线的","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622473535,"ip_address":"","comment_id":294936,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1622160642","product_id":100078401,"comment_content":"&quot;lock; xchg  %1, %2 \\n\\t&quot;<br>lock也是汇编指令吗？咋用的？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520880,"discussion_content":"不是  它用来锁定总线的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622473535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133036,"avatar":"https://static001.geekbang.org/account/avatar/00/11/49/ec/6bae1fd7.jpg","nickname":"哇咔咔","note":"","ucode":"54BF877836C591","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377890,"discussion_content":"文章里不是说xchg是原子指令吗？为啥还要lock？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622949202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294901,"user_name":"陈超","can_delete":false,"product_type":"c1","uid":2610622,"ip_address":"","ucode":"A28CA3E9B5A5C7","user_header":"https://static001.geekbang.org/account/avatar/00/27/d5/be/183c222b.jpg","comment_is_top":false,"comment_ctime":1622125950,"is_pvip":false,"replies":[{"id":"107310","content":"嗯嗯","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622473633,"ip_address":"","comment_id":294901,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1622125950","product_id":100078401,"comment_content":"锁的防嵌套处理，就是递归锁的实现原理吗？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520861,"discussion_content":"嗯嗯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622473633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294767,"user_name":"陈超","can_delete":false,"product_type":"c1","uid":2610622,"ip_address":"","ucode":"A28CA3E9B5A5C7","user_header":"https://static001.geekbang.org/account/avatar/00/27/d5/be/183c222b.jpg","comment_is_top":false,"comment_ctime":1622084922,"is_pvip":false,"replies":[{"id":"106995","content":"你好，单核CPU下 会直接加锁成功，只要你不重复加锁","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622093190,"ip_address":"","comment_id":294767,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1622084922","product_id":100078401,"comment_content":"请问下老师，单核情况下是不是无法使用自旋锁？因为自旋锁不让出cpu时间片，单核情况下会死循环？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520798,"discussion_content":"你好，单核CPU下 会直接加锁成功，只要你不重复加锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622093190,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2610622,"avatar":"https://static001.geekbang.org/account/avatar/00/27/d5/be/183c222b.jpg","nickname":"陈超","note":"","ucode":"A28CA3E9B5A5C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376606,"discussion_content":"因为单核对锁是独占的，锁住的情况下不可能有其它线程取读取锁。谢谢老师，明白了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622209809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294705,"user_name":"WGJ","can_delete":false,"product_type":"c1","uid":1468547,"ip_address":"","ucode":"AC585A245E2509","user_header":"https://static001.geekbang.org/account/avatar/00/16/68/83/ecd4e4d6.jpg","comment_is_top":false,"comment_ctime":1622055104,"is_pvip":false,"replies":[{"id":"107000","content":"你好，我们代码中的锁是最简单的形式，方便理解原理的","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622093561,"ip_address":"","comment_id":294705,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1622055104","product_id":100078401,"comment_content":"这里的自旋锁应该会有次数的吧，不可能一直在自旋，像go里面的信号量，默认自旋4次，如果还是锁定状态，那么才会休眠","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520775,"discussion_content":"你好，我们代码中的锁是最简单的形式，方便理解原理的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622093561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294668,"user_name":"Geek_1d6510","can_delete":false,"product_type":"c1","uid":2527022,"ip_address":"","ucode":"F8A2423D49C12E","user_header":"","comment_is_top":false,"comment_ctime":1622038818,"is_pvip":false,"replies":[{"id":"106964","content":"加油呀！","user_name":"编辑回复","user_name_real":"赵宇新","uid":"1501385","ctime":1622043157,"ip_address":"","comment_id":294668,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1622038818","product_id":100078401,"comment_content":"努力加油，收获满满","like_count":0,"discussions":[{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520762,"discussion_content":"加油呀！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622043157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294647,"user_name":"AmazingYu","can_delete":false,"product_type":"c1","uid":1005587,"ip_address":"","ucode":"7608037021CC1C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/58/13/2afd6bdb.jpg","comment_is_top":false,"comment_ctime":1622031393,"is_pvip":false,"replies":[{"id":"106915","content":"你好，这还要看禁止中断之后做什么 这不一定就卡死的 ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622034851,"ip_address":"","comment_id":294647,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1622031393","product_id":100078401,"comment_content":"如果所有核上的线程同时间开启了禁止中断，那这个系统是不是就卡死了？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520753,"discussion_content":"你好，这还要看禁止中断之后做什么 这不一定就卡死的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622034851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294638,"user_name":"AmazingYu","can_delete":false,"product_type":"c1","uid":1005587,"ip_address":"","ucode":"7608037021CC1C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/58/13/2afd6bdb.jpg","comment_is_top":false,"comment_ctime":1622029148,"is_pvip":false,"replies":[{"id":"106912","content":"很开心你能有收获，搞懂的内容欢迎记录和分享哦！","user_name":"编辑回复","user_name_real":"赵宇新","uid":"1501385","ctime":1622029459,"ip_address":"","comment_id":294638,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1622029148","product_id":100078401,"comment_content":"茅塞顿开","like_count":0,"discussions":[{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520748,"discussion_content":"很开心你能有收获，搞懂的内容欢迎记录和分享哦！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622029459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294624,"user_name":"宏典","can_delete":false,"product_type":"c1","uid":2616028,"ip_address":"","ucode":"63953F36596C28","user_header":"https://static001.geekbang.org/account/avatar/00/27/ea/dc/aa699264.jpg","comment_is_top":false,"comment_ctime":1622022521,"is_pvip":true,"replies":[{"id":"106918","content":"因为多核心cpu会同时相同的指令 同时访问内存 lock 就要避免这种情况的发生 ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622035153,"ip_address":"","comment_id":294624,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1622022521","product_id":100078401,"comment_content":"加上 lock 前缀的 addl、subl、incl、decl 指令都是原子操作，lock 前缀表示锁定总线。<br><br>为何加上lock锁住总线就可以保证原子性？？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520741,"discussion_content":"因为多核心cpu会同时相同的指令 同时访问内存 lock 就要避免这种情况的发生 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622035153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294610,"user_name":"送过快递的码农","can_delete":false,"product_type":"c1","uid":1587666,"ip_address":"","ucode":"66EA81B3BADC73","user_header":"https://static001.geekbang.org/account/avatar/00/18/39/d2/845c0e39.jpg","comment_is_top":false,"comment_ctime":1622016548,"is_pvip":false,"replies":[{"id":"106920","content":"是的，你或许看到后面的处理中断 就明白了 慢慢来","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622035453,"ip_address":"","comment_id":294610,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1622016548","product_id":100078401,"comment_content":"硬着头皮看了一遍。。。 我发现一个核心的问题不懂，就是关于中断。我只知道硬中断，软中断。但是我不清楚 老师调用了开启中断的服务和关闭中断的服务到底是有什么作用。如果我们在内核里面写一个函数，关闭中断，然后无限自旋，是不是这个任务就没法打断了，cpu是不是就被无限抢占了。但是如果我开了中断，就能打断了么，这也CPU 也能执行别的任务。<br>还有就是今天总体来说讲了4个知识点，原子变量，中断控制，自旋锁，信号量 这4个为啥我没找到一个贯穿这个的点，可能是我没读明白，脑子里乱的有点麻","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520734,"discussion_content":"是的，你或许看到后面的处理中断 就明白了 慢慢来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622035453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2610622,"avatar":"https://static001.geekbang.org/account/avatar/00/27/d5/be/183c222b.jpg","nickname":"陈超","note":"","ucode":"A28CA3E9B5A5C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376331,"discussion_content":"我的理解，自旋锁是在多核CPU下才有的，不然你自旋的时候不让出CPU时间片，那就是无限死循环卡死了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622084462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294596,"user_name":"大鱼Coo","can_delete":false,"product_type":"c1","uid":1184726,"ip_address":"","ucode":"94A695648681A3","user_header":"https://static001.geekbang.org/account/avatar/00/12/13/d6/278ad881.jpg","comment_is_top":false,"comment_ctime":1622013631,"is_pvip":false,"replies":[{"id":"106922","content":"你好，你的想法很正确，所以我们要尽量少使用锁，减少加锁时间","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622036647,"ip_address":"","comment_id":294596,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1622013631","product_id":100078401,"comment_content":"”锁“的进化。想到一个问题，如果有大量的并发操作，会影响中断的处理吧（比如键盘输入），日常碰到的类似的问题是否也有这一方面的原因。","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520729,"discussion_content":"你好，你的想法很正确，所以我们要尽量少使用锁，减少加锁时间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622036647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294584,"user_name":"曾泽浩","can_delete":false,"product_type":"c1","uid":1104601,"ip_address":"","ucode":"A7E5CF9E1571A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/d9/f051962f.jpg","comment_is_top":false,"comment_ctime":1622006990,"is_pvip":false,"replies":[{"id":"106924","content":"是的，你需要先编译","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622036804,"ip_address":"","comment_id":294584,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1622006990","product_id":100078401,"comment_content":"老师，你好，我想问一下，引导的汇编语言，如果要被计算机执行，应该要被汇编程序翻译成二进制代码，那这个汇编程序是运行在哪里的？此时应该还没加载操作系统吧","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520727,"discussion_content":"是的，你需要先编译","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622036804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2610622,"avatar":"https://static001.geekbang.org/account/avatar/00/27/d5/be/183c222b.jpg","nickname":"陈超","note":"","ucode":"A28CA3E9B5A5C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376333,"discussion_content":"想起了一个有趣的问题，汇编编译软件是在哪里编译的？例如nasm这个编译器是怎么被编译的，类似于是先有鸡还是先有蛋的问题。我的理解是世界上第一个汇编程序是用二进制机器码手工编辑出来的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622084728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294574,"user_name":"曾泽浩","can_delete":false,"product_type":"c1","uid":1104601,"ip_address":"","ucode":"A7E5CF9E1571A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/d9/f051962f.jpg","comment_is_top":false,"comment_ctime":1622003727,"is_pvip":false,"replies":[{"id":"106925","content":"锁定总 防止其它cpu使用总线访问内存","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622036858,"ip_address":"","comment_id":294574,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1622003727","product_id":100078401,"comment_content":"老师，有个疑问，lock总线，这句话要怎么理解呢？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520723,"discussion_content":"锁定总 防止其它cpu使用总线访问内存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622036858,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2610622,"avatar":"https://static001.geekbang.org/account/avatar/00/27/d5/be/183c222b.jpg","nickname":"陈超","note":"","ucode":"A28CA3E9B5A5C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376334,"discussion_content":"所有的CPU核心采用同一套地址总线和数据总线","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622084773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294523,"user_name":"尼欧","can_delete":false,"product_type":"c1","uid":1260883,"ip_address":"","ucode":"39D4D1F5F51764","user_header":"https://static001.geekbang.org/account/avatar/00/13/3d/53/9d8a1207.jpg","comment_is_top":false,"comment_ctime":1621990195,"is_pvip":false,"replies":[{"id":"106930","content":"你好，很久之前是内存 现在是cache ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622037178,"ip_address":"","comment_id":294523,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1621990195","product_id":100078401,"comment_content":"問個問題。文中說lock前綴是用來鎖定總綫，那鎖定的是内存還是cache？如果鎖的是内存的話，那麽是只鎖定當前指令中用到的内存地址，還是鎖定整個内存呢？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520694,"discussion_content":"你好，很久之前是内存 现在是cache ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622037178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1724915,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/51/f3/5e993de8.jpg","nickname":"aagu","note":"","ucode":"F8A082F543801F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376178,"discussion_content":"不同代的CPU有不同的处理方式。如果是锁内存方式的话，其他CPU在这个指令周期就没办法访问内存了；锁cache的方式，其他CPU只是不能再缓存当前内存地址。\n你可以看看这篇介绍 https://albk.tech/%E8%81%8A%E8%81%8ACPU%E7%9A%84LOCK%E6%8C%87%E4%BB%A4.html","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1622004147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1064679,"avatar":"https://static001.geekbang.org/account/avatar/00/10/3e/e7/261711a5.jpg","nickname":"blentle","note":"","ucode":"AC092609A4942A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376151,"discussion_content":"我也想问这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621994467,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294522,"user_name":"springXu","can_delete":false,"product_type":"c1","uid":2064750,"ip_address":"","ucode":"F5DB0B963C894F","user_header":"","comment_is_top":false,"comment_ctime":1621990168,"is_pvip":true,"replies":[{"id":"106854","content":"小编回应，翻牌吧，预言家！料事如神！","user_name":"编辑回复","user_name_real":"赵宇新","uid":"1501385","ctime":1621991299,"ip_address":"","comment_id":294522,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1621990168","product_id":100078401,"comment_content":"这思考题中的自旋锁的应用场合代码，是不是下一讲linux上的自旋锁的内容呢？","like_count":0,"discussions":[{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520693,"discussion_content":"小编回应，翻牌吧，预言家！料事如神！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621991299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]}]}