{"id":740871,"title":"第 7 章 对象关系映射(1)","content":"<blockquote>\n<p><strong>本章内容</strong></p>\n<ul>\n<li>Hibernate 与 JPA 的基础知识</li>\n<li>通过 Spring Data 的 <code>Repository</code> 操作数据库</li>\n<li>MyBatis 的基本用法</li>\n<li>通过工具提升 MyBatis 的使用体验</li>\n</ul>\n</blockquote>\n<p>在第 6 章中，我们大概了解了如何通过 JDBC 来进行简单的数据库操作。通过 SQL 来执行操作虽然不算复杂，但在面向对象的语言中，这类操作多少显得有些格格不入，毕竟我们都是在与“对象”打交道。把对象与关系型数据库关联起来，就有了我们要讨论的对象关系映射（Object-Relational Mapping，ORM）。而 Hibernate 和 MyBatis 是目前较为主流的两种 ORM 框架，本章主要介绍如何在项目中使用它们。</p>\n<h2 id=\"nav_point_109\">7.1　通过 Hibernate 操作数据库</h2>\n<p>如果我们希望用 Java 来开发一个 MVC 模型的应用，就一定离不开 SSH 组合。早期三个字母 SSH 分别代表了应用的核心框架 Spring Framework、开发 Web 功能的 Struts，以及开发数据层的 Hibernate ORM<span class=\"comment-number\">1</span>。随着时间的推移，Struts 慢慢淡出了人们的视野，Spring MVC 取代了这个 S 的位置 <span class=\"comment-number\">2</span>，新的 SSH 变为 Spring Framework、Spring MVC 与 Hibernate。在这个组合中，Hibernate 的角色与地位一直没有发生过变化，因此，本章我们会先来了解一下 Hibernate。由于本书的主要对象是 Spring 而非 Hibernate，所以这里我们不会过多地深入讨论，对 Hibernate 感兴趣的同学，可以访问它的官网了解更多细节。</p><!-- [[[read_end]]] -->\n\n\n<h3 id=\"nav_point_110\">7.1.1　Hibernate 与 JPA</h3>\n<p>Hibernate 是一款基于 Java 语言的开源对象关系映射框架。所谓<strong>对象关系映射</strong>，简单来说就是将面向对象的领域模型与关系型数据库中的表互相映射起来。对象关系映射很好地解决了对象与关系间的阻抗不匹配（impedance mismatch）问题 <span class=\"comment-number\">3</span>。虽然有一些不太协调的地方，但两者之间还是可以相互融合的，表 7-1 简单进行了一些对比。</p>\n\n<p><strong>表 7-1　面向对象与关系型数据库的简单对比</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>对比维度</p></th>\n<th><p>面向对象概念</p></th>\n<th><p>关系型数据库</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>粒度</p></td>\n<td><p>接口、类</p></td>\n<td><p>表、视图</p></td>\n</tr>\n<tr>\n<td><p>继承与多态</p></td>\n<td><p>有</p></td>\n<td><p>没有</p></td>\n</tr>\n<tr>\n<td><p>唯一性</p></td>\n<td><p><code>a == b</code> 或 <code>a.equals(b)</code></p></td>\n<td><p>主键</p></td>\n</tr>\n<tr>\n<td><p>关联关系</p></td>\n<td><p>引用</p></td>\n<td><p>外键</p></td>\n</tr>\n</tbody>\n</table>\n<p>Hibernate 不仅将 Java 对象与数据表互相映射起来，还建立了 Java 数据类型到 SQL 数据类型的映射，提供了数据查询与操作的能力，能够自动根据操作来生成 SQL 调用。它将开发者从大量繁琐的数据层操作中释放了出来，提升了大家的开发效率。</p>\n<p>说到 Hibernate 的历史，还得追溯到 2001 年。当时开发 Java EE（那时还叫 J2EE）应用程序需要使用 EJB，而澳大利亚程序员 Gavin King 对 EJB 中的实体 Bean 并无好感，于是他在 2001 年开发了 Hibernate 的第一个版本。后来随着 Spring Framework 创始人 Rod Johnson 的那本 <em>Expert One-on- One J2EE Development without EJB</em> 的出版，作为轻量级框架代表之一的 Hibernate 也逐步得到了大家的认可。</p>\n<p>2006 年，Java 的持久化标准 JPA（Java Persistent API，Java 持久化 API）正式发布。它的目标就是屏蔽不同持久化 API 之间的差异，简化持久化代码的开发工作。当时的 JPA 标准基本就是以 Hibernate 作为蓝本来制定的，而 Gavin King 也当仁不让地在这个规范的专家组中。Hibernate 从 3.2 版本开始兼容 JPA。2010 年，Hibernate 3.5 成为了 JPA 2.0 的认证实现。表 7-2 对 Hibernate 与 JPA 的接口做了一个比较。</p>\n<p><strong>表 7-2　Hibernate 与 JPA 接口的对应关系与实现</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>JPA 接口</p></th>\n<th><p>Hibernate 接口</p></th>\n<th><p>实现类</p></th>\n<th><p>作用</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>EntityManagerFactory</code></p></td>\n<td><p><code>SessionFactory</code></p></td>\n<td><p><code>SessionFactoryImpl</code></p></td>\n<td><p>管理领域模型与数据库的映射关系</p></td>\n</tr>\n<tr>\n<td><p><code>EntityManager</code></p></td>\n<td><p><code>Session</code></p></td>\n<td><p><code>SessionImpl</code></p></td>\n<td><p>基本的工作单元，封装了连接与事务相关的内容</p></td>\n</tr>\n<tr>\n<td><p><code>EntityTransaction</code></p></td>\n<td><p><code>Transaction</code></p></td>\n<td><p><code>TransactionImpl</code></p></td>\n<td><p>用来抽象底层的事务细节</p></td>\n</tr>\n</tbody>\n</table>\n<p>虽然 <code>SessionFactory</code> 或 <code>EntityManagerFactory</code> 的创建成本比较高，好在它们是线程安全的。一般应用程序中只有一个实例，而且会在程序中共享。</p>\n<p>Spring Framework 对 Hibernate 提供了比较好的支持，后来有了 Spring Data JPA 项目，更是提供了统一的 <code>Repository</code> 操作封装，开发者只需定义接口就能自动实现简单的操作。在后续的内容中，我们会了解到相关的使用方法。现在，第一步要做的就是在 pom.xml 的 <code>&lt;dependencies/&gt;</code> 中引入 Hibernate 与 JPA 相关的依赖。这一步通过 Spring Boot 的起步依赖就能做到：</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<h3 id=\"nav_point_111\">7.1.2　定义实体对象</h3>\n<p>在早期，开发者们都是通过 XML 来做各种配置的，其中也包括 Hibernate 的映射配置。但时至今日，大家早就习惯了使用注解来进行配置，甚至会“<strong>约定优于配置</strong>”（convention over configuration），追求“零”配置。在这一节中，我们只会涉及注解的配置方式，看看如何通过 JPA 的注解 <span class=\"comment-number\">4</span> 来进行常规的配置，其中还会结合少许 Hibernate 的特有注解。</p>\n\n<ol>\n<li><p><strong>实体及主键</strong></p>\n<p>既然是对象关系映射，那自然需要定义清楚“对象”与“关系”之间的关系。这层关系是由实体对象及其上添加的注解来承载的，表 7-3 中展示了用来定义实体及其主键的四个注解。</p>\n<p><strong>表 7-3　定义实体及其主键的注解</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>注解</th><th>作用</th><th>重点属性说明</th></tr><tr><td><code>@Entity</code></td><td>标识类是实体类</td><td><code>name</code>，默认为非限定类名，用在 HQL（Hibernate query language，Hibernate 查询语言）查询中标识实体</td></tr><tr><td><code>@Table</code></td><td>指定实体对应的数据表，不加的话默认将类名作为表名</td><td><code>name</code>，默认是实体名；<code>schema</code>，默认是用户的默认 Schema</td></tr><tr><td><code>@Id</code></td><td>指定字段是实体的主键</td><td></td></tr><tr><td><code>@GeneratedValue</code></td><td>指定主键的生成策略</td><td><code>strategy</code>，指定生成策略，共有四种策略—<code>TABLE</code>、<code>SEQUENCE</code>、<code>IDENTITY</code> 和 <code>AUTO</code>；<code>generator</code>，指定生成器，用于 <code>TABLE</code> 和 <code>SEQUENCE</code> 这两种策略中</td></tr></table>\n\n<p>我们可以将之前的 <code>MenuItem</code> 类稍作修改，用 JPA 注解来进行标注，具体如代码示例 7-1<span class=\"comment-number\">5</span> 所示。类上共有六个注解 <span class=\"comment-number\">6</span>，前四个注解都是 Lombok 的，用来减少模板化的代码，为类增加构建器、构造方法、<code>Getter</code> 与 <code>Setter</code> 等方法；<code>@Entity</code> 说明这是一个实体类；<code>@Table</code> 指定该实体类对应的数据表是 <code>t_menu</code>。<code>id</code> 上的注解表明了它是表的主键，并且是自动生成主键值的——通常像 MySQL 这样的数据库我们都会定义一个自增主键，默认策略就是 <code>IDENTITY</code>。</p>\n<blockquote>\n<p><strong>代码示例 7-1</strong>　增加了 JPA 注解的 <code>MenuItem</code> 类代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Builder\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@Entity\n@Table(name = \"t_menu\")\npublic class MenuItem {\n    @Id\n    @GeneratedValue\n    private Long id;\n    // 以下省略\n}</code></pre>\n<p>除了自增主键，还可以用 <code>@SequenceGenerator</code> 和 <code>@TableGenerator</code> 来指定基于序列和表生成主键。以 <code>@SequenceGenerator</code> 为例，假设我们有个序列 <code>seq_menu</code>，上面的 <code>MenuItem</code> 可以调整成代码示例 7-2 这样。至于 <code>@TableGenerator</code>，就留给大家查阅文档去了解吧。</p>\n<blockquote>\n<p><strong>代码示例 7-2</strong>　根据注解生成主键的 <code>MenuItem</code> 类片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Builder\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@Entity\n@Table(name = \"t_menu\")\npublic class MenuItem {\n    @Id\n    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"sequence-generator\")\n    @SequenceGenerator(name = \"sequence-generator\", sequenceName = \"seq_menu\")\n    private Long id;\n    // 以下省略\n}</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>字段</strong></p>\n<p>在定义完实体和主键后，就该轮到各个字段了。表 7-4 罗列了一些字段相关的常用注解。</p>\n<p><strong>表 7-4　一些字段相关的常用注解</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>注解</th><th>作用</th><th>重点属性说明</th></tr><tr><td><code>@Basic</code></td><td>映射简单类型，例如 Java 原子类型及其封装类、日期时间类型等，一般不用添加该注解，默认就有同样的效果</td><td></td></tr><tr><td><code>@Column</code></td><td>描述字段信息</td><td><code>name</code>，字段名称，默认同属性名；<code>unique</code> 是否唯一；<code>nullable</code> 是否可为 <code>null</code>；<code>insertable</code> 是否出现在 <code>INSERT</code> 语句中；<code>updatable</code> 是否出现在 <code>UPDATE</code> 语句中</td></tr><tr><td><code>@Enumerated</code></td><td>映射枚举类型</td><td><code>value</code>，映射方式，默认是 <code>ORDINAL</code>，使用枚举的序号，也可以用 <code>STRING</code>，使用枚举值</td></tr><tr><td><code>@Type</code></td><td>定义 Hibernate 的类型映射，这是 Hibernate 的注解</td><td><code>type</code>，Hibernate 类型实现的全限定类名；<code>parameters</code>，类型所需的参数</td></tr><tr><td><code>@Temporal</code></td><td>映射日期与时间类型，适用于 <code>java.util.Date</code> 和 <code>java.util.Calendar</code></td><td><code>value</code>，要映射的内容，<code>DATE</code> 对应 <code>java.sql.Date</code>，<code>TIME</code> 对应 <code>java.sql.Time</code>，<code>TIMESTAMP</code> 对应 <code>java.sql.Timestamp</code></td></tr><tr><td><code>@CreationTimestamp</code></td><td>插入时传入当前时间，这是 Hibernate 的注解</td><td></td></tr><tr><td><code>@UpdateTimestamp</code></td><td>更新时传入当前时间，这是 Hibernate 的注解</td><td></td></tr></table>\n\n<p>在了解了映射字段信息的注解后，我们再对 <code>MenuItem</code> 类做进一步的调整，具体改动后的情况如代码示例 7-3 所示。</p>\n<blockquote>\n<p><strong>代码示例 7-3</strong>　新增的杯型 <code>Size</code> 枚举与修改后的 <code>MenuItem</code> 类</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public enum Size {\n    SMALL, MEDIUM, LARGE\n}\n\n@Builder\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@Entity\n@Table(name = \"t_menu\")\npublic class MenuItem {\n    @Id\n    @GeneratedValue\n    private Long id;\n    private String name;\n\n    @Enumerated(EnumType.STRING)\n    private Size size;\n\n    @Type(type = \"org.jadira.usertype.moneyandcurrency.joda.PersistentMoneyMinorAmount\",\n            parameters = {@org.hibernate.annotations.Parameter(name = \"currencyCode\", value = \"CNY\")})\n    private Money price;\n\n    @Column(updatable = false)\n    @Temporal(TemporalType.TIMESTAMP)\n    @CreationTimestamp\n    private Date createTime;\n\n    @Temporal(TemporalType.TIMESTAMP)\n    @UpdateTimestamp\n    private Date updateTime;\n}</code></pre>\n<p>上面的代码有几处具体的变动。</p>\n<p>(1) <code>size</code> 从 <code>String</code> 类型改为了枚举。通过 <code>@Enumerated(EnumType.STRING)</code> 指明用枚举值来做映射，也就是说数据库里的值会是 <code>SMALL</code>、<code>MEDIUM</code> 和 <code>LARGE</code>。</p>\n<p>(2) <code>price</code> 从 <code>BigDecimal</code> 换成了 Joda-Money 库 <span class=\"comment-number\">7</span> 中的 <code>Money</code> 类型。通过 <code>@Type</code> 声明了如何将数据库中 <code>Long</code> 类型的值转换为 <code>Money</code>，这里用到了一个开源的转换类，如果数据库里存的是小数类型，可以考虑把 <code>PersistentMoneyMinorAmount</code> 替换为 <code>PersistentMoneyAmount</code>。</p>\n<p>(3) <code>createTime</code> 标记为不可修改的，在创建时会填入当前时间戳。<code>@CreationTimestamp</code> 是 Hibernate 的注解，在此处 <code>@Temporal(TemporalType.TIMESTAMP)</code> 其实是可以省略的。</p>\n<p>(4) <code>updateTime</code> 会在每次修改时填入当前时间戳。<code>@UpdateTimestamp</code> 是 Hibernate 的注解，在此处 <code>@Temporal(TemporalType.TIMESTAMP)</code> 也是可以省略的。</p>\n<p>关于 Joda-Money 和对应的 Hibernate 类型 <code>PersistentMoneyMinorAmount</code>，两者均需要在 pom.xml 中加入下面两个依赖：</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.joda&lt;/groupId&gt;\n    &lt;artifactId&gt;joda-money&lt;/artifactId&gt;\n    &lt;version&gt;1.0.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.jadira.usertype&lt;/groupId&gt;\n    &lt;artifactId&gt;usertype.core&lt;/artifactId&gt;\n    &lt;version&gt;6.0.1.GA&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n<p><code>usertype.core</code> 里还有不少其他有用的类，实用性非常强。</p>\n<blockquote>\n<p><strong>茶歇时间：为什么一定要用 <code>Money</code> 类来表示金额</strong></p>\n<p>在处理金额时，千万不要想当然地使用 <code>float</code> 或者 <code>double</code> 类型。原因是在遇到浮点数运算时，精度的丢失可能带来巨大的差异，甚至会造成资金损失。虽然 <code>BigDecimal</code> 在计算时能顺利过关，但金额的内容却不止是一个数值，还有与之关联的币种（ISO-4217）、单位等内容。</p>\n<p>以人民币为例，标准的币种简写是 CNY，最小单位（代码中用 <code>Minor</code> 表示）是分，主要单位（代码中用 <code>Major</code> 表示）是元。美元、欧元、日元等货币都有各自的规范。在不同的货币之间，还有货币转换的需求。所以说，我们需要一个专门用来表示金额的类，而 Joda-Money 就是一个好的选择。举个例子，我们可以通过 <code>Money.ofMinor(CurrencyUnit.of(\"CNY\"), 1234)</code>，创建代表人民币 12.34 元的对象，<code>Money.of(CurrencyUnit.of(\"CNY\"), 12.34)</code> 与之等价。</p>\n</blockquote>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>关联关系</strong></p>\n<p>我们在学习数据库的范式时，为了适当地降低冗余，提升操作效率，会去设计不同的表之间的关系。在做对象关系映射时，这种关系也需要体现出来。表 7-5 中罗列了常用的几种关系及其对应的注解。</p>\n<p><strong>表 7-5　常见关系及其对应的注解</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>关系</th><th>数据库的实现方式</th><th>注解</th></tr><tr><td>1:1</td><td>外键</td><td><code>@OneToOne</code></td></tr><tr><td>1:<i>n</i></td><td>外键</td><td><code>@OneToMany</code>、<code>@JoinColumn</code>、<code>@OrderBy</code></td></tr><tr><td><i>n</i>:1</td><td>外键</td><td><code>@ManyToOne</code>、<code>@JoinColumn</code></td></tr><tr><td><i>n</i>:<i>n</i></td><td>关联表</td><td><code>@ManyToMany</code>、<code>@JoinTable</code>、<code>@OrderBy</code></td></tr></table>\n\n<p>为了方便大家理解这些注解的用法，我们结合二进制奶茶店的例子来看看。</p>\n<blockquote>\n<p><strong>需求描述</strong>　在二进制奶茶店中，我们会将顾客点单的信息记录在订单（即 <code>Order</code>）里。店内主要流转的信息就是订单，我们通过订单来驱动后续的工作。一个订单会有多个条目（即 <code>MenuItem</code>），每个订单又会由一名调茶师（即 <code>TeaMaker</code>）负责完成。<span class=\"comment-number\">8</span> 它们之间的关系如图 7-1 所示，订单与调茶师是多对一关系，而订单与条目是多对多关系。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00766.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 7-1　订单类与其他类的主要关联关系</strong></p>\n</blockquote>\n<p>其中，<code>TeaMaker</code> 类的代码如代码示例 7-4 所示，大部分内容与 <code>MenuItem</code> 大同小异，但其中有一个一对多关系的 <code>orders</code> 属性需要特别说明一下。<code>orders</code> 属性可以直接获取与当前调茶师关联的订单列表。<code>@OneToMany</code> 的获取方式默认是懒加载，即在使用时才会加载，<code>mappedBy</code> 标明了根据 <code>Order.maker</code> 属性来进行映射。<code>@OrderBy</code> 会对取得的结果进行排序，默认按主键排序，也可以指定多个字段，用逗号分隔，默认是升序（即 <code>asc</code>）。</p>\n<blockquote>\n<p><strong>代码示例 7-4</strong>　<code>TeaMaker</code> 的主要代码</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Builder\n@Getter\n@Setter\n@AllArgsConstructor\n@NoArgsConstructor\n@Entity\n@Table(name = \"t_tea_maker\")\npublic class TeaMaker {\n    @Id\n    @GeneratedValue\n    private Long id;\n    private String name;\n\n    @OneToMany(mappedBy = \"maker\")\n    @OrderBy(\"id desc\")\n    private List&lt;Order&gt; orders = new ArrayList&lt;&gt;();\n\n    @Column(updatable = false)\n    @CreationTimestamp\n    private Date createTime;\n\n    @UpdateTimestamp\n    private Date updateTime;\n}</code></pre>\n<p>接着，让我们来定义订单对象。每笔订单都有自己的状态，因此要先定义一个枚举来表示订单的状态机。<code>OrderStatus</code> 中有五种状态，分别是已下单、已支付、制作中、已完成和已取货，实际情况中可能还有退款、取消等状态，在本例中就一切从简了。订单及其枚举的定义如代码示例 7-5 所示。</p>\n<blockquote>\n<p><strong>代码示例 7-5</strong>　订单对象及订单状态枚举</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public enum OrderStatus {\n    ORDERED, PAID, MAKING, FINISHED, TAKEN;\n}\n\n@Builder\n@Getter\n@Setter\n@AllArgsConstructor\n@NoArgsConstructor\n@Entity\n@Table(name = \"t_order\")\npublic class Order {\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"maker_id\")\n    private TeaMaker maker;\n\n    @ManyToMany\n    @JoinTable(name = \"t_order_item\", joinColumns = @JoinColumn(name = \"item_id\"),\n            inverseJoinColumns = @JoinColumn(name = \"order_id\"))\n    @OrderBy\n    private List&lt;MenuItem&gt; items;\n\n    @Embedded\n    private Amount amount;\n\n    @Enumerated\n    private OrderStatus status;\n\n    @Column(updatable = false)\n    @CreationTimestamp\n    private Date createTime;\n\n    @UpdateTimestamp\n    private Date updateTime;\n}</code></pre>\n<p><code>maker</code> 指向了订单的调茶师，通过 <code>@ManyToOne</code> 指定了多对一的关系，这里的 <code>fetch</code> 默认是积极加载（<code>EAGER</code>）的，我们将其设定为了懒加载（<code>LAZY</code>）。<code>@JoinColumn</code> 标明了数据表中记录映射关系的字段名称。<code>items</code> 是订单中的具体内容，与 <code>MenuItem</code> 是多对多关系，二者通过关联表 <code>t_order_item</code> 进行关联，我们指定了表中用到的具体字段，还要求对 <code>List</code> 进行排序。</p>\n<blockquote>\n<p><strong>请注意</strong>　Lombok 的 <code>@Data</code> 注解相当于添加了好多注解。其中之一是 <code>@ToString</code> 注解，即提供了更可读的 <code>toString()</code> 方法，输出的内容会包含成员变量的内容。为了避免 <code>toString()</code> 触发 Hibernate 加载那些懒加载的对象，在 <code>TeaMaker</code> 和 <code>Order</code> 上将 <code>@Data</code> 改为了 <code>@Getter</code> 和 <code>@Setter</code>。</p>\n</blockquote>\n<p>订单的金额信息被我们剥离到了单独的一个对象里，此时的 <code>amount</code> 就是一个嵌套对象，用 <code>@Embedded</code> 来加以说明。而在 <code>Amount</code> 对象上也需要加上 <code>@Embeddable</code>，说明它是可以被嵌套到其他实体中的。具体见代码示例 7-6，其中也用到了前面说到的金额类型转换器 <code>PersistentMoneyMinorAmount</code>。</p>\n<blockquote>\n<p><strong>代码示例 7-6</strong>　订单的金额信息</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Builder\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@Embeddable\npublic class Amount {\n    @Column(name = \"amount_discount\")\n    private int discount;\n\n    @Column(name = \"amount_total\")\n    @Type(type = \"org.jadira.usertype.moneyandcurrency.joda.PersistentMoneyMinorAmount\",\n            parameters = {@org.hibernate.annotations.Parameter(name = \"currencyCode\", value = \"CNY\")})\n    private Money totalAmount;\n\n    @Column(name = \"amount_pay\")\n    @Type(type = \"org.jadira.usertype.moneyandcurrency.joda.PersistentMoneyMinorAmount\",\n            parameters = {@org.hibernate.annotations.Parameter(name = \"currencyCode\", value = \"CNY\")})\n    private Money payAmount;\n}</code></pre>\n<blockquote>\n<p><strong>茶歇时间：OpenSessionInView 问题</strong></p>\n<p>Hibernate 的懒加载机制有时就像一把双刃剑，虽然性能有所提升，但偶尔也会带来些麻烦，比如 OpenSessionInView 这个问题。</p>\n<p>所谓 <strong>OpenSessionInView</strong>，是指 Hibernate 在加载时并未把数据加载上来就关闭了 Session，在要用到这些数据时，Hibernate 就会尝试使用之前的 Session，但此时 Session 已经关闭，所以会导致报错。这种情况在传统的 MVC 结构应用中会比较常见，OpenSessionInView 中的 View 指的就是 MVC 中的视图层，也就是视图层会尝试加载之前被延时加载的内容，随后报错。</p>\n<p>Spring Framework 为我们提供了对应的解决方案：在 web.xml 中配置 <code>OpenSessionInViewFilter</code>，或者在 Spring 的 Web 上下文中配置 <code>OpenSessionInViewInterceptor</code>，两者都可以实现在视图层处理结束后才关闭 Session 的效果。</p>\n<p>如果用的是 JPA，那 Spring Framework 中也有对应的 <code>OpenEntityManagerInViewInterceptor</code> 拦截器可供开发者使用。</p>\n</blockquote>\n</li>\n</ol>\n\n\n\n\n<h3 id=\"nav_point_112\">7.1.3　通过 Hibernate API 操作数据库</h3>\n<p>有了定义好的实体对象后，就可以通过对应的 API 来操作它们，从而实现对数据库的操作。但在使用前，我们需要先在 Spring 上下文中做一些简单的配置。由于 Hibernate 也是 JPA 的参考实现，两者有很多配置都是相似的，因而表 7-6 将 Hibernate 与 JPA 所需的配置放到一起来展示。</p>\n<p><strong>表 7-6　Hibernate 与 JPA 需要配置的内容</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>配置内容</p></th>\n<th><p>Hibernate</p></th>\n<th><p>JPA</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>会话工厂</p></td>\n<td><p><code>LocalSessionFactoryBean</code></p></td>\n<td><p><code>LocalEntityManagerFactoryBean</code> / <code>LocalContainerEntityManagerFactoryBean</code></p></td>\n</tr>\n<tr>\n<td><p>事务管理器</p></td>\n<td><p><code>HibernateTransactionManager</code></p></td>\n<td><p><code>JpaTransactionManager</code></p></td>\n</tr>\n</tbody>\n</table>\n<p>Spring Boot 的 <code>HibernateJpaConfiguration</code> 提供了一整套完整的自动配置。如果我们不想自己动手，可以把配置的工作交给 Spring Boot，只需要确保有一个明确的主 <code>DataSource</code> Bean 即可。代码示例 7-7 演示了如何手动配置 Hibernate 的相关 Bean，<code>LocalSessionFactoryBean</code> 中设置了要扫描的包路径，在这个路径中查找要映射的实体，除此之外，还设置了一些 Hibernate 的属性：</p>\n<ul>\n<li><code>hibernate.hbm2ddl.auto</code>，自动根据实体类生成 DDL 语句并执行。一般在生产环境中，数据库都是由 DBA 来运维的，不会用程序创建表结构，但开发者在开发时偶尔还是会用到这个功能。在本节的演示中我们就需要靠它来生成表结构；</li>\n<li><code>hibernate.show_sql</code>，打印 Hibernate 具体执行的 SQL 语句；</li>\n<li><code>hibernate.format_sql</code>，对要打印的 SQL 进行格式化。</li>\n</ul>\n<p>Hibernate 有很多可以设置的属性，各位读者如果想要了解更多内容，可以查询 Hibernate 的官方文档。</p>\n<blockquote>\n<p><strong>代码示例 7-7</strong>　手动在主类中配置 Hibernate 相关 Bean</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootApplication\npublic class BinaryTeaApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(BinaryTeaApplication.class, args);\n    }\n\n    @Bean\n    public LocalSessionFactoryBean sessionFactory(DataSource dataSource) {\n        Properties properties = new Properties();\n        // 在H2内存数据库中生成对应表结构\n        properties.setProperty(\"hibernate.hbm2ddl.auto\", \"create-drop\");\n        properties.setProperty(\"hibernate.show_sql\", \"true\");\n        properties.setProperty(\"hibernate.format_sql\", \"true\");\n\n        LocalSessionFactoryBean factoryBean = new LocalSessionFactoryBean();\n        factoryBean.setDataSource(dataSource);\n        factoryBean.setHibernateProperties(properties);\n        factoryBean.setPackagesToScan(\"learning.spring.binarytea.model\");\n        return factoryBean;\n    }\n\n    @Bean\n    public PlatformTransactionManager transactionManager(SessionFactory sessionFactory) {\n        return new HibernateTransactionManager(sessionFactory);\n    }\n}</code></pre>\n<p>在第 6 章中，我们介绍了 Spring Framework 为各种模板化的操作提供了模板类，事务操作有 <code>TransactionTemplate</code>，JDBC 操作有 <code>JdbcTemplate</code>，而 Hibernate 操作也有专门的 <code>HibernateTemplate</code>。为了方便使用，Spring Framework 还更进一步提供了一个 <code>HibernateDaoSupport</code> 辅助类。代码示例 7-8 和代码示例 7-9 演示了如何通过 Spring Framework 的辅助类进行增删改查操作。</p>\n<blockquote>\n<p><strong>代码示例 7-8</strong>　通过 Hibernate 重新实现 <code>MenuRepository</code> 的查询操作</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Repository\n@Transactional\npublic class MenuRepository extends HibernateDaoSupport {\n    // 传入SessionFactory\n    public MenuRepository(SessionFactory sessionFactory) {\n        super.setSessionFactory(sessionFactory);\n    }\n\n    public long countMenuItems() {\n        // 这里的是HQL，不是SQL语句\n        return getSessionFactory().getCurrentSession()\n                .createQuery(\"select count(t) from MenuItem t\", Long.class).getSingleResult();\n    }\n\n    public List&lt;MenuItem&gt; queryAllItems() {\n        return getHibernateTemplate().loadAll(MenuItem.class);\n    }\n\n    public MenuItem queryForItem(Long id) {\n        return getHibernateTemplate().get(MenuItem.class, id);\n    }\n    // 省略插入、修改、删除方法\n}</code></pre>\n<p>上面的代码演示了通过 <code>getHibernateTemplate()</code> 获取 <code>HibernateTemplate</code> 后进行的各种查询类操作，而 <code>countMenuItems()</code> 里则直接可以获取 Session（通过 HQL 语句进行操作）。我们在 <code>MenuRepository</code> 上添加了 <code>@Transactional</code> 注解，开启了事务。实践中我们一般会把事务加在 Service 层上，这里也只是为了演示，此外，<code>getCurrentSession()</code> 也需要运行在事务里。代码示例 7-9 是 <code>MenuRepository</code> 中的增加、修改和删除操作。</p>\n<blockquote>\n<p><strong>代码示例 7-9</strong>　通过 Hibernate 重新实现 <code>MenuRepository</code> 的增删改操作</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Repository\n@Transactional\npublic class MenuRepository extends HibernateDaoSupport {\n    public void insertItem(MenuItem item) {\n        getHibernateTemplate().save(item);\n    }\n\n    public void updateItem(MenuItem item) {\n        getHibernateTemplate().update(item);\n    }\n\n    public void deleteItem(Long id) {\n        MenuItem item = getHibernateTemplate().get(MenuItem.class, id);\n        if (item != null) {\n            getHibernateTemplate().delete(item);\n        }\n    }\n}</code></pre>\n<p>为了演示这个 <code>MenuRepository</code> 的使用效果，我们需要一个简单的单元测试，可以对 <code>MenuRepositoryTest</code> 稍作修改。代码示例 7-10 是对插入操作的测试。这个测试的逻辑大致是这样的：先通过 <code>MenuRepository</code> 来进行操作，随后再用 <code>JdbcTemplate</code> 执行 SQL 语句来验证执行的效果。<code>testInsertItem()</code> 先插入了 3 条记录，通过 Lombok 生成的 <code>Builder</code> 来创建 <code>MenuItem</code>。在设置 <code>price</code> 时，我们演示了如何创建代表人民币 12 元的 <code>Money</code> 对象。明细核对的方法被单独放在了 <code>assertItem()</code> 里，以便后面的用例中能够复用。此处，与第 6 章的例子有一个区别，当时我们使用 schema.sql 和 data.sql 来初始化表结构和数据，这里为了保证测试数据不受外部影响，Spring Boot 的初始化，由 Hibernate 来实现表结构的初始化。</p>\n<blockquote>\n<p><strong>代码示例 7-10</strong>　<code>MenuRepositoryTest</code> 中针对插入操作的单元测试</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootTest(properties = {\"spring.sql.init.mode=never\", \"spring.jpa.hibernate.ddl-auto=create-drop\"})\n@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\nclass MenuRepositoryTest {\n    @Autowired\n    private MenuRepository menuRepository;\n    @Autowired\n    private DataSource dataSource;\n    private JdbcTemplate jdbcTemplate;\n\n    @BeforeEach\n    public void setUp() {\n        jdbcTemplate = new JdbcTemplate(dataSource);\n    }\n\n    @AfterEach\n    public void tearDown() {\n        jdbcTemplate = null;\n    }\n\n    @Test\n    @Order(1)\n    void testInsertItem() {\n        List&lt;MenuItem&gt; items = Stream.of(\"Go橙汁\", \"Python气泡水\", \"JavaScript苏打水\")\n                .map(n -&gt; MenuItem.builder().name(n).size(Size.MEDIUM)\n                        .price(Money.ofMinor(CurrencyUnit.of(\"CNY\"), 1200)).build())\n                .peek(m -&gt; menuRepository.insertItem(m)).collect(Collectors.toList());\n        for (int i = 0; i &lt; 3; i++) {\n            assertEquals(i + 1, items.get(i).getId());\n            assertItem(i + 1L, items.get(i).getName());\n        }\n    }\n\n    private void assertItem(Long id, String name) {\n        Map&lt;String, Object&gt; result = jdbcTemplate.queryForMap(\"select * from t_menu where id = ?\", id);\n        assertEquals(name, result.get(\"name\"));\n        assertEquals(Size.MEDIUM.name(), result.get(\"size\"));\n        assertEquals(1200L, result.get(\"price\"));\n    }\n    // 省略其他测试用例\n}</code></pre>\n<p>代码示例 7-11 是针对查询方法的相关测试，我们可以看到其中的核对大部分复用了 <code>assertItem()</code>。</p>\n<blockquote>\n<p><strong>代码示例 7-11</strong>　<code>MenuRepositoryTest</code> 中针对查询操作的单元测试</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootTest(properties = {\"spring.sql.init.mode=never\", \"spring.jpa.hibernate.ddl-auto=create-drop\"})\n@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\nclass MenuRepositoryTest {\n    @Test\n    @Order(2)\n    void testCountMenuItems() {\n        assertEquals(3, menuRepository.countMenuItems());\n    }\n\n    @Test\n    @Order(3)\n    void testQueryForItem() {\n        MenuItem item = menuRepository.queryForItem(1L);\n        assertNotNull(item);\n        assertItem(1L, \"Go橙汁\");\n    }\n\n    @Test\n    @Order(4)\n    void testQueryAllItems() {\n        List&lt;MenuItem&gt; items = menuRepository.queryAllItems();\n        assertNotNull(items);\n        assertFalse(items.isEmpty());\n        assertEquals(3, items.size());\n    }\n    // 省略其他代码\n}</code></pre>\n<p>代码示例 7-12 是与修改和删除相关的测试用例：<code>testUpdateItem()</code> 中先查出了 ID 为 <code>1</code> 的菜单项，将其中的价格修改为了 11 元，更新回数据库后又用 <code>jdbcTemplate</code> 把记录查询出来进行了核对；<code>testDeleteItem()</code> 则比较简单，直接删除 ID 为 <code>2</code> 的记录，随后再通过查询操作来看一下数据在不在。</p>\n<blockquote>\n<p><strong>代码示例 7-12</strong>　<code>MenuRepositoryTest</code> 中针对修改和删除操作的单元测试</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootTest(properties = {\"spring.sql.init.mode=never\", \"spring.jpa.hibernate.ddl-auto=create-drop\"})\n@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\nclass MenuRepositoryTest {\n    @Test\n    @Order(5)\n    void testUpdateItem() {\n        MenuItem item = menuRepository.queryForItem(1L);\n        item.setPrice(Money.ofMinor(CurrencyUnit.of(\"CNY\"), 1100));\n        menuRepository.updateItem(item);\n        Long price = jdbcTemplate.queryForObject(\"select price from t_menu where id = 1\", Long.class);\n        assertEquals(1100L, price);\n    }\n\n    @Test\n    @Order(6)\n    void testDeleteItem() {\n        menuRepository.deleteItem(2L);\n        assertNull(menuRepository.queryForItem(2L));\n    }\n    // 省略其他代码\n}</code></pre>\n<p>需要注意两点：第一，这个测试必须按照指定的顺序执行，因为测试数据是通过 <code>testInsertItem()</code> 插入的；第二，这只是一个演示用的单元测试，在实际工作中，我们还要考虑各种边界条件。</p>\n<p>Spring Framework 针对涉及数据库的操作还提供了专门的测试支持，可以在每个测试执行后回滚数据库中的各种修改，此处暂且通过简单的方式来做。更复杂的用法大家可以通过 Spring Framework 的官方手册进行了解。</p>\n<h3 id=\"nav_point_113\">7.1.4　通过 Spring Data 的 <code>Repository</code> 操作数据库</h3>\n<p>虽然与直接使用 SQL 的方式相比，Hibernate 方便了不少，但广大开发者对效率的追求是无止境的。不少日常增删改查操作的代码都“长得差不多”，而且对关系型数据库、NoSQL 数据库都有类似的操作，那么是否还可以进一步简化呢？答案是肯定的，Spring Data 项目就为不同的常见数据库提供了统一的 Repository 抽象层。我们可以通过约定好的方式定义接口，使用其中的方法来声明需要的操作，剩下的实现工作完全交由 Spring Data 来完成。Spring Data 的核心接口是 <code>Repository&lt;T, ID&gt;</code>，<code>T</code> 是实体类型，<code>ID</code> 是主键类型，一般我们会使用它的子接口 <code>CrudRepository&lt;T, ID&gt;</code> 或者 <code>PagingAndSortingRepository&lt;T, ID&gt;</code>。<code>CrudRepository&lt;T, ID&gt;</code> 的定义如下所示：</p>\n<pre class=\"code-rows\"><code>@NoRepositoryBean\npublic interface CrudRepository&lt;T, ID&gt; extends Repository&lt;T, ID&gt; {\n    &lt;S extends T&gt; S save(S var1);\n    &lt;S extends T&gt; Iterable&lt;S&gt; saveAll(Iterable&lt;S&gt; var1);\n\n    Optional&lt;T&gt; findById(ID var1);\n    boolean existsById(ID var1);\n    Iterable&lt;T&gt; findAll();\n    Iterable&lt;T&gt; findAllById(Iterable&lt;ID&gt; var1);\n\n    long count();\n\n    void deleteById(ID var1);\n    void delete(T var1);\n    void deleteAll(Iterable&lt;? extends T&gt; var1);\n    void deleteAll();\n}</code></pre>\n<p>可以看到其中已经包含了一些通用的方法，比如新增和删除实体，还有根据 ID 查找实体等。<code>PagingAndSortingRepository&lt;T, ID&gt;</code> 则是在此基础之上又增加了分页和排序功能。</p>\n<p>Spring Data JPA 是专门针对 JPA 的。在 pom.xml 中引入 <code>org.springframework.boot:spring-boot-starter-data-jpa</code> 就能添加所需的依赖。其中提供了一个专属的 <code>JpaRepository&lt;T, ID&gt;</code> 接口，可以在配置类上增加 <code>@EnableJpaRepositories</code> 来开启 JPA 的支持，通过这个注解还可以配置一些个性化的信息，比如要扫描 <code>Repository</code> 接口的包。</p>\n<p>Spring Boot 的 <code>JpaRepositoriesAutoConfiguration</code> 提供了 <code>JpaRepository</code> 相关的自动配置，只要符合条件就能完成配置。它通过 <code>@Import</code> 注解导入了 <code>JpaRepositoriesRegistrar</code> 类，其中直接定义了一个静态内部类 <code>EnableJpaRepositoriesConfiguration</code>，上面添加了 <code>@EnableJpaRepositories</code>，所以在 Spring Boot 项目里无须自己添加该注解，只要有相应的依赖，Spring Boot 的自动配置就能帮忙完成剩下的工作：</p>\n<pre class=\"code-rows\"><code>@Configuration(proxyBeanMethods = false)\n@ConditionalOnBean(DataSource.class)\n@ConditionalOnClass(JpaRepository.class)\n@ConditionalOnMissingBean({ JpaRepositoryFactoryBean.class, JpaRepositoryConfigExtension.class })\n@ConditionalOnProperty(prefix = \"spring.data.jpa.repositories\", name = \"enabled\", havingValue = \"true\",\n    matchIfMissing = true)\n@Import(JpaRepositoriesRegistrar.class)\n@AutoConfigureAfter({ HibernateJpaAutoConfiguration.class, TaskExecutionAutoConfiguration.class })\npublic class JpaRepositoriesAutoConfiguration { ... }</code></pre>\n<p>要定义自己的 <code>Repository</code> 只需扩展 <code>CrudRepository&lt;T, ID&gt;</code>、<code>PagingAndSortingRepository&lt;T, ID&gt;</code> 或 <code>JpaRepository&lt;T, ID&gt;</code>，并明确指定泛型类型即可。例如，<code>MenuItem</code> 和 <code>TeaMaker</code> 的 <code>Repository</code> 大概就是代码示例 7-13<span class=\"comment-number\">9</span> 这样的。</p>\n\n<blockquote>\n<p><strong>代码示例 7-13</strong>　<code>MenuItem</code> 和 <code>TeaMaker</code> 的 <code>Repository</code> 定义</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public interface MenuRepository extends JpaRepository&lt;MenuItem, Long&gt; {}\npublic interface TeaMakerRepository extends JpaRepository&lt;TeaMaker, Long&gt; {}</code></pre>\n<p>通用的方法基本能满足大部分需求，但是总会有一些业务所需的特殊查询需要是通用的方法所不能满足的。在 Spring Data 的帮助下，我们只需要根据它的要求定义方法，无须编写具体的实现，这就省却了很多工作。以下几种形式的方法名都可以视为有效的查询方法：</p>\n<ul>\n<li><code>find...By...</code></li>\n<li><code>read...By...</code></li>\n<li><code>query...By...</code></li>\n<li><code>get...By...</code></li>\n</ul>\n<p>如果只是想要统计数量，不用返回具体内容，可以使用 <code>count...By...</code> 的形式。</p>\n<p>其中，第一段“<code>...</code>”的内容是限定返回的结果条数，比如用 <code>TopN</code>、<code>FirstN</code> 表示返回头 <em>N</em> 个结果，还可以用 <code>Distinct</code> 起到 SQL 语句中 <code>distinct</code> 关键词的效果。第二段“<code>...</code>”的内容是查询的条件，也就是 SQL 语句中 <code>where</code> 的部分，条件所需的内容与方法的参数列表对应，可以通过 <code>And</code>、<code>Or</code> 关键词组合多个条件，用 <code>Not</code> 关键词取反。Spring Data 方法支持多种形式的条件，具体见表 7-7。</p>\n<p><strong>表 7-7　Spring Data 查询方法支持的关键词</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>作用</p></th>\n<th><p>关键词</p></th>\n<th><p>例子</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>相等</p></td>\n<td><p><code>Is</code>、<code>Equals</code>，不写的话默认就是相等</p></td>\n<td><p><code>findByNameIs(String name)</code></p></td>\n</tr>\n<tr>\n<td><p>比较</p></td>\n<td><p><code>LessThan</code>、<code>LessThanEqual</code>、<code>GreaterThan</code>、<code>GreaterThanEqual</code></p></td>\n<td><p><code>findByNumberLessThan(int number)</code></p></td>\n</tr>\n<tr>\n<td><p>比较</p></td>\n<td><p><code>Between</code>，用于日期时间的比较</p></td>\n<td><p><code>findByStartDateBetween(Date d1, Date d2)</code></p></td>\n</tr>\n<tr>\n<td><p>比较</p></td>\n<td><p><code>Before</code>、<code>After</code>，用于日期时间的比较</p></td>\n<td><p><code>findByEndDateBefore(Date date)</code></p></td>\n</tr>\n<tr>\n<td><p>是否为空</p></td>\n<td><p><code>Null</code>、<code>IsNull</code>、<code>NotNull</code>、<code>IsNotNull</code></p></td>\n<td><p><code>findBySizeIsNotNull()</code></p></td>\n</tr>\n<tr>\n<td><p>相似</p></td>\n<td><p><code>Like</code>、<code>NotLike</code></p></td>\n<td><p><code>findByNameNotLike(String name)</code></p></td>\n</tr>\n<tr>\n<td><p>字符串判断</p></td>\n<td><p><code>StartingWith</code>、<code>EndingWith</code>、<code>Containing</code></p></td>\n<td><p><code>findByNameContaining(String name)</code></p></td>\n</tr>\n<tr>\n<td><p>忽略字符串大小写进行判断</p></td>\n<td><p><code>IgnoreCase</code>、<code>AllIgnoreCase</code></p></td>\n<td><p><code>findByLastnameAndFirstnameAllIgnoreCase(String lastname, String firstname)</code></p></td>\n</tr>\n<tr>\n<td><p>集合</p></td>\n<td><p><code>In</code>、<code>NotIn</code></p></td>\n<td><p><code>findBySizeIn(List&lt;Size&gt; sizeList)</code></p></td>\n</tr>\n<tr>\n<td><p>布尔判断</p></td>\n<td><p><code>True</code>、<code>False</code></p></td>\n<td><p><code>findByActiveFalse()</code></p></td>\n</tr>\n</tbody>\n</table>\n<p>对于会返回多条结果的方法，可以在方法名结尾处增加 <code>OrderBy</code> 关键词指定排序的字段，通过 <code>Asc</code> 和 <code>Desc</code> 指定升序或者降序（默认为 <code>Asc</code>）。例如 <code>findByNameOrderByIdDesc(String name)</code>，这里也支持多个字段排序的组合，例如 <code>findByNameOrderByUpdateTimeDescId(String name)</code>。也可以在参数中增加一个 <code>Sort</code> 类型的参数来灵活地传入期望的排序方式，例如：</p>\n<pre class=\"code-rows\"><code>Sort sort = Sort.by(\"name\").descending().and(Sort.by(\"id\").ascending());</code></pre>\n<p>另一个常见的需求是分页。方法的返回值可以是 <code>Page&lt;T&gt;</code> 或集合类型，通过传入 <code>Pageable</code> 类型的参数来指定分页信息。</p>\n<p>Spring Data 的 <code>Repository</code> 接口方法支持很多种返回类型：单个返回值的，除了常见的 <code>T</code> 类型，也可以是 <code>Optional&lt;T&gt;</code>；集合类型除了 <code>Iterable</code> 相关的类型，还可以是 <code>Streamable</code> 的，方便做流式处理。</p>\n<p>既然这里用的是 JPA 的 <code>Repository</code> 接口，自然就要用 JPA 相关的配置。之前我们做的 Hibernate 的配置就可以替换一下，最简单的就是把配置都删了，完全靠 Spring Boot 的自动配置。之前 Hibernate 配置的一些属性，可以写到 <code>application.properties</code> 里，如代码示例 7-14 所示。</p>\n<blockquote>\n<p><strong>代码示例 7-14</strong>　<code>application.properties</code> 中的一些配置片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>spring.jpa.hibernate.ddl-auto=create-drop\nspring.jpa.properties.hibernate.format_sql=true\n#spring.jpa.properties.hibernate.show_sql=true\nspring.jpa.show-sql=true</code></pre>\n<p>这三个配置的效果，等同于代码示例 7-7 中用代码做的配置，其中 <code>spring.jpa.properties.hibernate.show_sql</code> 与 <code>spring.jpa.show-sql</code> 的效果相同。</p>\n<p>对于订单的操作，我们可以定义一个 <code>OrderRepository</code> 接口，具体如代码示例 7-15 所示。</p>\n<blockquote>\n<p><strong>代码示例 7-15</strong>　操作订单的 <code>OrderRepository</code> 接口</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public interface OrderRepository extends JpaRepository&lt;Order, Long&gt; {\n    List&lt;Order&gt; findByStatusOrderById(OrderStatus status);\n    List&lt;Order&gt; findByMaker_NameLikeIgnoreCaseOrderByUpdateTimeDescId(String name);\n}</code></pre>\n<p>上面的第一个方法根据 <code>Order.status</code> 进行查找，结果按照 <code>id</code> 升序排列；第二个方法比较复杂，根据 <code>Order.maker.name</code> 进行相似匹配，且忽略大小写，结果先按照 <code>updateTime</code> 降序排列，如果相同再按 <code>id</code> 升序排列。对于 <code>Order.maker.name</code> 这样的属性，可以像上面这样用 <code>_</code> 明确地表示 <code>name</code> 是 <code>Maker</code> 的属性，也可以不加 <code>_</code>，让 Spring Data 自行判断。大家可以尝试写一下这个接口的单元测试，也可以参考我们提供的代码示例中的 <code>OrderRepositoryTest</code> 类，此处就不再展开了。在取到 <code>Order</code> 后，其中懒加载的内容有可能没有被加载上来，因此我们在访问时需要增加一个事务，保证在操作时能够取得当前会话。</p>\n<p>如果有一些公共的方法希望能剥离到公共接口里，但又不希望这个公共接口被创建成 <code>Repository</code> 的 Bean，这时就可以在接口上添加 <code>@NoRepositoryBean</code> 注解。<code>JpaRepository</code> 接口就是这样的：</p>\n<pre class=\"code-rows\"><code>@NoRepositoryBean\npublic interface JpaRepository&lt;T, ID&gt; extends PagingAndSortingRepository&lt;T, ID&gt;, QueryByExampleExecutor&lt;T&gt; {}</code></pre>\n<p>这里，我们同样要为 <code>OrderRepository</code> 中的两个方法添加一些简单的单元测试，这些测试需要用到一些测试数据，它们可以和 <code>TeaMakerRepository</code> 的测试复用，因此可以将测试数据的准备工作单独剥离出来，放到 <code>src/test/java</code> 对应的位置，代码内容具体如代码示例 7-16 所示。具体的逻辑是先插入 3 条 <code>MenuItem</code> 和 2 条 <code>TeaMaker</code> 记录，随后用它们来创建订单，两条订单之间间隔 200 毫秒，这样在按照订单时间排序时可以有明确的顺序。</p>\n<blockquote>\n<p><strong>代码示例 7-16</strong>　进行测试数据准备的 <code>DataInitializationRunner</code> 类</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public class DataInitializationRunner implements ApplicationRunner {\n    @Autowired\n    private TeaMakerRepository makerRepository;\n    @Autowired\n    private MenuRepository menuRepository;\n    @Autowired\n    private OrderRepository orderRepository;\n\n    @Override\n    @Transactional\n    public void run(ApplicationArguments args) throws Exception {\n        List&lt;MenuItem&gt; menuItemList = Stream.of(\"Go橙汁\", \"Python气泡水\", \"JavaScript苏打水\")\n                .map(n -&gt; MenuItem.builder().name(n).size(Size.MEDIUM)\n                        .price(Money.ofMinor(CurrencyUnit.of(\"CNY\"), 1200)).build())\n                .map(m -&gt; {\n             menuRepository.save(m);\n             return m;\n        }).collect(Collectors.toList());\n\n        List&lt;TeaMaker&gt; makerList = Stream.of(\"LiLei\", \"HanMeimei\")\n                .map(n -&gt; TeaMaker.builder().name(n).build())\n                .map(m -&gt; {\n            makerRepository.save(m);\n            return m;\n        }).collect(Collectors.toList());\n\n        Order order = Order.builder().maker(makerList.get(0))\n                                     .amount(Amount.builder()\n                                     .discount(90).totalAmount(Money.ofMinor(CurrencyUnit.of(\"CNY\"), 1200))\n                                     .payAmount(Money.ofMinor(CurrencyUnit.of(\"CNY\"), 1080)).build())\n                                     .items(List.of(menuItemList.get(0))).status(OrderStatus.ORDERED).build();\n        orderRepository.save(order);\n\n        try {\n            Thread.sleep(200);\n        } catch (InterruptedException e) {\n        }\n\n        order = Order.builder().maker(makerList.get(0)).amount(Amount.builder().discount(100)\n                .totalAmount(Money.ofMinor(CurrencyUnit.of(\"CNY\"), 1200))\n                .payAmount(Money.ofMinor(CurrencyUnit.of(\"CNY\"), 1200)).build())\n            .items(List.of(menuItemList.get(1)))\n            .status(OrderStatus.ORDERED).build();\n        orderRepository.save(order);\n    }\n}</code></pre>\n<p>上面的 <code>DataInitializationRunner</code> 类上并未添加任何 Spring Bean 相关的注解，所以它并不会被自动扫描加载为 Bean。由于代码示例 7-12 中的 <code>MenuRepositoryTest</code> 并不需要它的数据，让它跑起来反而还会破坏原来的测试，所以我们可以有条件地选择性执行这段初始化逻辑。代码示例 7-17 就是对应的配置类，通过 <code>@ConditionalOnProperty</code> 可以实现根据 <code>data.init.enable</code> 属性的值来确定是否创建 <code>DataInitializationRunner</code> Bean：只有值为 <code>true</code> 时才会创建，为其他值或没有设置时都不会有任何效果。</p>\n<blockquote>\n<p><strong>代码示例 7-17</strong>　根据特定属性生效的 <code>DataInitializationConfig</code> 配置类</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Configuration\n@ConditionalOnProperty(name = \"data.init.enable\", havingValue = \"true\")\npublic class DataInitializationConfig {\n    @Bean\n    public DataInitializationRunner dataInitializationRunner() {\n        return new DataInitializationRunner();\n    }\n}</code></pre>\n<p>代码示例 7-18 就是针对 <code>OrderRepository</code> 的测试类，在 <code>@SpringBootTest</code> 上增加了一个 <code>data.init.enable=true</code> 的属性配置，这样就能用上前面准备的测试数据初始化逻辑了。随后的两个测试方法内容比较直观，就不再做过多说明了。</p>\n<blockquote>\n<p><strong>代码示例 7-18</strong>　针对 <code>OrderRepository</code> 的测试类</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootTest(properties = {\"data.init.enable=true\",\n        \"spring.sql.init.mode=never\", \"spring.jpa.hibernate.ddl-auto=create-drop\"})\n@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\nclass OrderRepositoryTest {\n    @Autowired\n    private OrderRepository orderRepository;\n\n    @Test\n    @Transactional\n    public void testFindByStatusOrderById() {\n        assertTrue(orderRepository.findByStatusOrderById(OrderStatus.FINISHED).isEmpty());\n        List&lt;Order&gt; list = orderRepository.findByStatusOrderById(OrderStatus.ORDERED);\n        assertEquals(2, list.size());\n        assertEquals(\"Go橙汁\", list.get(0).getItems().get(0).getName());\n        assertEquals(\"Python气泡水\", list.get(1).getItems().get(0).getName());\n        assertTrue(list.get(0).getId() &lt; list.get(1).getId());\n        assertEquals(\"LiLei\", list.get(0).getMaker().getName());\n        assertEquals(\"LiLei\", list.get(1).getMaker().getName());\n    }\n\n    @Test\n    public void testFindByMaker_NameLikeOrderByUpdateTimeDescId() {\n        assertTrue(orderRepository.findByMaker_NameLikeIgnoreCaseOrderByUpdateTimeDescId(\"%han%\").isEmpty());\n        List&lt;Order&gt; list = orderRepository.findByMaker_NameLikeIgnoreCaseOrderByUpdateTimeDescId(\"%lei%\");\n        assertEquals(2, list.size());\n        assertTrue(list.get(0).getUpdateTime().getTime() &gt;= list.get(1).getUpdateTime().getTime());\n        assertTrue(list.get(0).getId() &gt; list.get(1).getId());\n    }\n}</code></pre>\n<blockquote>\n<p><strong>茶歇时间：<code>JpaRepository</code> 背后的原理</strong></p>\n<p>在正文中有提到，Spring Boot 的自动配置导入了 <code>JpaRepositoriesRegistrar</code>，这个类的内部类添加了 <code>@EnableJpaRepositories</code>，开启了对 JPA <code>Repository</code> 的支持。相关的扩展配置则是由 <code>JpaRepositoryConfigExtension</code> 提供的，其中注册了很多 Bean，例如：</p>\n<ul>\n<li><code>EntityManagerBeanDefinitionRegistrarPostProcessor</code></li>\n<li><code>JpaMetamodelMappingContextFactoryBean</code></li>\n<li><code>PersistenceAnnotationBeanPostProcessor</code></li>\n<li><code>DefaultJpaContext</code></li>\n<li><code>JpaMetamodelCacheCleanup</code></li>\n<li><code>JpaEvaluationContextExtension</code></li>\n</ul>\n<p>此外，扫描找到的 <code>Repository</code> 接口都会对应地配置一个 <code>JpaRepositoryFactoryBean</code> 类型的工厂 Bean。可以通过这个工厂 Bean 来获得具体的 <code>JpaRepositoryFactory</code>，它是 <code>RepositoryFactorySupport</code> 的子类，其中的 <code>getRepository(Class&lt;T&gt; repositoryInterface, RepositoryFragments fragments)</code> 会返回最终的 <code>Repository</code> 实现。</p>\n<p><code>getRepository()</code> 方法为我们的接口创建了一个扩展了 <code>SimpleJpaRepository&lt;T, ID&gt;</code> 的实现，它包含了最基础的增删改查方法的实现。另外 <code>getRepository()</code> 返回的 Bean 还添加了一层动态代理，其中添加了一些 AOP 通知，根据不同情况，可能会有以下几种：</p>\n<ul>\n<li><code>MethodInvocationValidator</code></li>\n<li><code>ExposeInvocationInterceptor</code></li>\n<li><code>DefaultMethodInvokingMethodInterceptor</code></li>\n<li><code>QueryExecutorMethodInterceptor</code></li>\n<li><code>ImplementationMethodExecutionInterceptor</code></li>\n</ul>\n<p>在这些通知中，<code>QueryExecutorMethodInterceptor</code> 就负责为我们自定义的各种查询方法提供实现。<code>PartTree</code> 定义了查询方法该如何解析，关键词信息如下：</p>\n<pre class=\"code-rows\"><code>private static final String KEYWORD_TEMPLATE = \"(%s)(?=(\\\\p|\\\\P))\";\nprivate static final String QUERY_PATTERN = \"find|read|get|query|search|stream\";\nprivate static final String COUNT_PATTERN = \"count\";\nprivate static final String EXISTS_PATTERN = \"exists\";\nprivate static final String DELETE_PATTERN = \"delete|remove\";</code></pre>\n<p><code>Part</code> 类中的内部枚举 <code>Type</code> 中定义了各式条件：</p>\n<pre class=\"code-rows\"><code>private static final List&lt;Part.Type&gt; ALL = Arrays.asList(IS_NOT_NULL, IS_NULL, BETWEEN, LESS_THAN,\n    LESS_THAN_EQUAL, GREATER_THAN, GREATER_THAN_EQUAL, BEFORE, AFTER, NOT_LIKE, LIKE,\n    STARTING_WITH, ENDING_WITH, IS_NOT_EMPTY, IS_EMPTY, NOT_CONTAINING, CONTAINING, NOT_IN, IN,\n    NEAR, WITHIN, REGEX, EXISTS, TRUE, FALSE, NEGATING_SIMPLE_PROPERTY, SIMPLE_PROPERTY);</code></pre>\n<p><code>AbstractJpaQuery</code> 子类中的 <code>execute(Object[] parameters)</code> 方法负责执行具体的查询。</p>\n<p>经过这样的一路分析，可以发现整个 JPA 的 <code>Repository</code> 的实现并没有太多高深的地方，依靠动态代理和对各种情况的预先编码，最后的效果就是我们看到的：通过定义接口来实现格式操作。</p>\n</blockquote>\n","comments":[]}