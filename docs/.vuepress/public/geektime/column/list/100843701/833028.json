{"id":833028,"title":"04｜单机吞吐优化（二）：高性能数据处理三板斧","content":"<p>你好，我是徐逸。</p><p>通过上节课的学习，我们知道了提升单机吞吐的思路是定位到单机瓶颈资源。对于瓶颈资源，要么增加资源，比如提升单机CPU、内存等的规格；要么减少单个请求对瓶颈资源的消耗，让相同的资源可以处理更多请求。</p><p>对于CPU和内存瓶颈，我们也介绍了容器类型的使用方法，从而降低CPU和内存资源消耗，提升单机吞吐。</p><p>有了数据类型，自然少不了对数据的处理。今天我们就来聊聊对于CPU和内存瓶颈，有哪些常用的高性能数据处理技巧。只要能够灵活运用这些技巧，我们就能降低单个请求对CPU和内存资源消耗，提升单机吞吐。</p><p>为了便于说明，我先构造一段代码，这段代码会循环做字符串拼接、整型转字符串和字符串转字节切片操作。我们今天会基于这段代码的性能优化过程，带你掌握这些高性能技巧。</p><pre><code class=\"language-go\">package performance\n\nimport (\n    \"fmt\"\n)\n\ntype User struct {\n    Id   int\n    Name string\n}\n\n// GenerateIdsRaw 原始待优化函数\nfunc GenerateIdsRaw(users []*User) (string, string, []byte) {\n    names := \"\"\n    idStr := \"\"\n    var nameByte []byte\n    for index := range users {\n        idStr = fmt.Sprint(users[index].Id)\n        names = names + \",\" + users[index].Name\n        nameByte = []byte(users[index].Name)\n    }\n    return idStr, names, nameByte\n}\n</code></pre><!-- [[[read_end]]] --><p>接下来是Benchmark代码，也就是对前面构造的那段代码做基准测试，评估前面代码在大规模用户数据处理时的性能。</p><pre><code class=\"language-go\">package performance\n\nimport (\n    \"fmt\"\n    \"testing\"\n)\n\n// 初始化构造测试用例\nvar users []*User\n\nfunc init() {\n    for i := 0; i &lt; 1000; i++ {\n        users = append(users, &amp;User{Id: i, Name: fmt.Sprintf(\"user%d\", i)})\n    }\n}\n\nfunc BenchmarkGenerateIdsRaw(b *testing.B) {\n    for n := 0; n &lt; b.N; n++ {\n        GenerateIdsRaw(users)\n    }\n}\n</code></pre><p>后面要讲的技巧既可以降低CPU消耗，也可以降低内存消耗。为了叙述方便，我们这里以降低CPU消耗为例。但在实际应用中，如果你的资源瓶颈是内存，也可以用这些技巧降低内存占用。</p><p>现在让我们基于前面的Benchmark代码来生成并查看一下CPU火焰图，看下哪段逻辑消耗CPU资源比较高，我们再针对最消耗CPU的代码逻辑进行优化。</p><pre><code class=\"language-shell\">go test -run=none -bench=BenchmarkGenerateIdsRaw -benchtime=10s -gcflags=all=-l -cpuprofile cpu.prof\ngo tool pprof -http=\":8081\" cpu.prof\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/a0/23/a0e48982f12d0328c132dd8e596bff23.jpg?wh=3814x1600\" alt=\"\" title=\"图1 原始函数 CPU 火焰图\"></p><p>从火焰图中我们可以看到，消耗CPU最多的是runtime.concatstrings函数，而这个函数是Go语言 “+” 操作符进行字符串拼接的底层实现函数。</p><h2>高性能字符串拼接</h2><p>那这个 “+” 操作符到底是怎么拼接字符串的呢？这里面是不是有啥优化空间呢？想要解决这个问题，我们就需要先弄清楚 “+” 操作符拼接字符串的逻辑。</p><p>当<strong>用 “+” 连接符拼接两个字符串的时候，得先开辟一块新的内存空间来存放拼接后的字符串，然后把这两个字符串按照拼接的顺序拷贝到新空间</strong>。这个新空间的大小等于原来两个字符串长度的和。</p><p>比如字符串“ab” 和 字符串“cd” 要拼接，就得先给结果字符串找个地方，然后把字符串“ab” 和 “cd” 分别拷贝过去，这样就得到了新的字符串。</p><pre><code class=\"language-go\">s1 := \"ab\" + \"cd\"\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/21/35/210c1dfaf94486225dbc39d8711c7735.jpg?wh=1212x540\" alt=\"\" title=\"图2 “+” 操作符拼接字符串\"></p><p>如果是循环拼接字符串，每次循环迭代都要分配新空间的话，就需要<strong>不停地在堆上分配内存</strong>。而且每次迭代还得把拼接的字符串都拷贝到结果空间，需要<strong>不停地拷贝</strong>。而堆内存分配和拷贝都是比较消耗CPU的操作。</p><p>因此，要减少字符串拼接操作对CPU资源的消耗，就需要减少字符串拼接的内存分配和拷贝。Go 语言有没有什么好办法呢？</p><p>有。Go 语言里有个 <strong>strings.Builder 类型</strong>，这个 strings.Builder 类型可以减少内存分配和拷贝，高效地拼接字符串。</p><p>给你看看它是怎么用的：</p><pre><code class=\"language-go\">package main\n\nimport (\n        \"fmt\"\n        \"strings\"\n)\n\nfunc main() {\n    var b strings.Builder\n    for i := 3; i &gt;= 1; i-- {\n            fmt.Fprintf(&amp;b, \"%d...\", i)\n    }\n    b.WriteString(\"ignition\")\n    fmt.Println(b.String()) // 输出 3...2...1...ignition\n}\n</code></pre><p>这个 strings.Builder 类型有两个很厉害的地方。</p><p>第一个是它有<strong>内存预分配</strong>的功能。这个类型有一个 Grow 方法，可以提前把内存分配好，实现预分配功能。这样每次循环迭代时就不用重新分配内存，内存频繁分配的问题就解决了。</p><pre><code class=\"language-go\">// Grow grows b's capacity, if necessary, to guarantee space for another n bytes. \n// After Grow(n), at least n bytes can be written to b without another allocation. \nfunc (b *Builder) Grow(n int)\n</code></pre><p>第二个厉害的地方是，<strong>字符串拼接时，内存拷贝次数更少</strong>。</p><p>为啥呢？因为 Builder 底层是用 [] byte 类型来存字符串的。往 Builder 里写东西的时候，只有它的 buf 容量不够、需要扩容时，才会发生内存迁移拷贝，不像之前每次循环都得拷贝字符串。要是提前用 Grow 方法分配好足够的内存，在循环拼接的时候，就不会发生扩容迁移，导致拷贝了。</p><pre><code class=\"language-go\">type Builder struct {\n    buf  []byte\n}\n\n// WriteString appends the contents of s to b's buffer.\n// It returns the length of s and a nil error.\nfunc (b *Builder) WriteString(s string) (int, error) {\n    b.buf = append(b.buf, s...)\n    return len(s), nil\n}\n</code></pre><p>现在，让我们用这个 strings.Builder 来重新实现一下我们的函数：</p><pre><code class=\"language-go\">// GenerateIdsBuilder 使用strings.Builder拼接字符串\nfunc GenerateIdsBuilder(users []*User) (string, string, []byte) {\n    names := \"\"\n    idStr := \"\"\n    var nameByte []byte\n    length := 0\n    for index := range users {\n        idStr = fmt.Sprint(users[index].Id)\n        nameByte = []byte(users[index].Name)\n        length += len(users[index].Name) + 1\n    }\n    var builder strings.Builder\n    builder.Grow(length) // 预分配\n    for index := range users {\n        builder.WriteString(\",\")\n        builder.WriteString(users[index].Name)\n    }\n    return idStr, names, nameByte\n}\n</code></pre><p>到底 strings.Builder类型有没有我们说的这么厉害呢？咱们来做个测试，用 Benchmark 来测一测 “+” 操作符实现字符串拼接和strings.Builder实现字符串拼接的性能。</p><p>下面是我们的Benchmark脚本：</p><pre><code class=\"language-go\">package performance\n\nimport (\n    \"fmt\"\n    \"testing\"\n)\n\n// 初始化构造测试用例\nvar users []*User\n\nfunc init() {\n    for i := 0; i &lt; 1000; i++ {\n        users = append(users, &amp;User{Id: i, Name: fmt.Sprintf(\"user%d\", i)})\n    }\n}\n\nfunc BenchmarkGenerateIdsRaw(b *testing.B) {\n    for n := 0; n &lt; b.N; n++ {\n        GenerateIdsRaw(users)\n    }\n}\n\nfunc BenchmarkGenerateIdsBuilder(b *testing.B) {\n    for n := 0; n &lt; b.N; n++ {\n        GenerateIdsBuilder(users)\n    }\n}\n</code></pre><p>测试结果出来了，我们可以看到<strong>用strings.Builder拼接字符串的方式，性能有巨大的提升</strong>。</p><pre><code class=\"language-shell\">killianxu@KILLIANXU-MB0 performance % go test -run=none -benchmem&nbsp; -bench=. -gcflags=all=-l\ngoos: darwin\ngoarch: amd64\npkg: example.com/performance\ncpu: Intel(R) Core(TM) i5-7360U CPU @ 2.30GHz\nBenchmarkGenerateIdsRaw-4&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 862&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1190253 ns/op&nbsp; 4194661 B/op&nbsp; &nbsp; &nbsp; &nbsp; 3739 allocs/op\nBenchmarkGenerateIdsBuilder-4&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6018&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 167267 ns/op&nbsp; &nbsp; 30069 B/op&nbsp; &nbsp; &nbsp; &nbsp; 2735 allocs/op\n</code></pre><ul>\n<li>\n<p>从 CPU 资源消耗来看，“+” 操作符拼接字符串的方式，单次函数调用要1190253ns，而strings.Builder 拼接方式只要167267ns，节约了 86% 左右的 CPU 资源。</p>\n</li>\n<li>\n<p>从内存消耗来看，“+” 操作符拼接字符串的方式，单次函数调用要4194661字节内存，而用 strings.Builder 拼接字符串的方式，每次函数调用只要30069字节内存，节约了 99% 左右的内存资源。</p>\n</li>\n</ul><p>其实，在Golang官方文档注释中，也特意提到了strings.Builder。</p><blockquote>\n<p>A Builder is used to efficiently build a string using&nbsp;Builder.Write&nbsp;methods. It minimizes memory copying. The zero value is ready to use. Do not copy a non-zero Builder.</p>\n</blockquote><p>而且，Go本身的库函数，也有很多是用strings.Builder实现的。比如我们常用的strings.Join和strings.Replace函数。</p><pre><code class=\"language-go\">func Join(elems []string, sep string) string {\n    n := len(sep) * (len(elems) - 1)\n    for i := 0; i &lt; len(elems); i++ {\n        n += len(elems[i])\n    }\n\n    var b Builder\n    b.Grow(n)\n    b.WriteString(elems[0])\n    for _, s := range elems[1:] {\n        b.WriteString(sep)\n        b.WriteString(s)\n    }\n    return b.String()\n}\n\nfunc Replace(s, old, new string, n int) string {\n    if old == new || n == 0 {\n        return s // avoid allocation\n    }\n\n    // Compute number of replacements.\n    if m := Count(s, old); m == 0 {\n        return s // avoid allocation\n    } else if n &lt; 0 || m &lt; n {\n        n = m\n    }\n\n    // Apply replacements to buffer.\n    var b Builder\n    b.Grow(len(s) + n*(len(new)-len(old)))\n    start := 0\n    for i := 0; i &lt; n; i++ {\n        j := start\n        if len(old) == 0 {\n            if i &gt; 0 {\n                _, wid := utf8.DecodeRuneInString(s[start:])\n                j += wid\n            }\n        } else {\n            j += Index(s[start:], old)\n        }\n        b.WriteString(s[start:j])\n        b.WriteString(new)\n        start = j + len(old)\n    }\n    b.WriteString(s[start:])\n    return b.String()\n}\n</code></pre><p>现在让我们再看一下CPU火焰图，看看将字符串拼接方式优化后，我们的代码是否还有优化空间。</p><pre><code class=\"language-shell\">go test  -run=none -bench=BenchmarkGenerateIdsBuilder -benchtime=10s -gcflags=all=-l -cpuprofile cpu.prof\ngo tool pprof -http=\":8081\" cpu.prof\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/cc/cc/cc79cb9813e62875bccd8c38f6a25dcc.jpg?wh=5655x1693\" alt=\"\" title=\"图3 用 strings.Builder 优化后的火焰图\"></p><p>从火焰图中我们可以看到，用strings.Builder优化后，消耗CPU最多的函数变成了fmt.Sprint函数。</p><h2>高性能整型转字符串</h2><p>这个函数在我们代码里的作用是将整型转化为字符串。这个fmt.Sprint函数为什么会消耗CPU？这里面是不是也有优化空间呢？</p><pre><code class=\"language-go\">idStr := fmt.Sprint(user.Id)\n</code></pre><p>fmt.Sprint及其变体函数，需要用反射来识别它们正在处理的类型，然后确定如何将其格式化为字符串。而这两者都增加了时间和内存开销。</p><pre><code class=\"language-go\">func (p *pp) doPrint(a []any) {\n    prevString := false\n    for argNum, arg := range a {\n        // 反射\n        isString := arg != nil &amp;&amp; reflect.TypeOf(arg).Kind() == reflect.String\n        // Add a space between two non-string arguments.\n        if argNum &gt; 0 &amp;&amp; !isString &amp;&amp; !prevString {\n            p.buf.writeByte(' ')\n        }\n        // 格式化逻辑\n        p.printArg(arg, 'v')\n        prevString = isString\n    }\n}\n</code></pre><p>有没有开销更小的整型转字符串的方式呢？</p><p>这时候一个叫strconv&nbsp;库的东西就派上用场了。strconv库里面的函数是为特定的转换任务设计的，所以它们比更通用的&nbsp;fmt&nbsp;函数执行得更快。</p><p>让我们用strconv库来重新实现一下我们的函数：</p><pre><code class=\"language-go\">// GenerateIdsStrconv 使用strconv实现整型转字符串\nfunc GenerateIdsStrconv(users []*User) (string, string, []byte) {\n    names := \"\"\n    idStr := \"\"\n    var nameByte []byte\n    length := 0\n    for index := range users {\n        idStr = strconv.Itoa(users[index].Id)\n        nameByte = []byte(users[index].Name)\n        length += len(users[index].Name) + 1\n    }\n    var builder strings.Builder\n    builder.Grow(length) // 预分配\n    for index := range users {\n        builder.WriteString(\",\")\n        builder.WriteString(users[index].Name)\n    }\n    return idStr, names, nameByte\n}\n</code></pre><p>strconv库的使用，又能给咱们带来多大的性能提升呢？咱们继续用Benchmark来测一测。</p><p>下面是Benchmark脚本：</p><pre><code class=\"language-go\">func BenchmarkGenerateIdsStrconv(b *testing.B) {\n    for n := 0; n &lt; b.N; n++ {\n        GenerateIdsStrconv(users)\n    }\n}\n</code></pre><p>然后你会发现，<strong>使用strconv库将整型转换为字符串的方式，性能提升明显。</strong></p><pre><code class=\"language-shell\">killianxu@KILLIANXU-MB0 performance % go test -run=none -benchmem&nbsp; -bench=. -gcflags=all=-l&nbsp;\ngoos: darwin\ngoarch: amd64\npkg: example.com/performance\ncpu: Intel(R) Core(TM) i5-7360U CPU @ 2.30GHz\nBenchmarkGenerateIdsBuilder-4&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7215&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 165601 ns/op&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;30069 B/op&nbsp; &nbsp; &nbsp; &nbsp;2735 allocs/op\nBenchmarkGenerateIdsStrconv-4&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 15163&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;79333 ns/op&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;23392 B/op&nbsp; &nbsp; &nbsp; &nbsp;1901 allocs/op\n</code></pre><ul>\n<li>\n<p>从 CPU 资源消耗来看，fmt的方式，单次函数调用要165601ns，而strconv的方式，只要 79333ns，节约了 52% 左右的 CPU 资源。</p>\n</li>\n<li>\n<p>从内存消耗来看，fmt的方式，单次函数调用要30069字节内存，而strconv的方式，每次函数调用只要23392字节内存，节约了 22% 左右的内存资源。</p>\n</li>\n</ul><p>现在让我们继续看一下火焰图，看看将整型转化为字符串的方式改为strconv库后，我们的代码是否还有优化空间。</p><pre><code class=\"language-shell\">go test  -run=none -bench=GenerateIdsStrconv -benchtime=10s -gcflags=all=-l -cpuprofile cpu.prof\ngo tool pprof -http=\":8081\" cpu.prof\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/1b/96/1bce63a310977cf52b070bef2106e696.jpg?wh=3761x1213\" alt=\"\" title=\"图4 用 strconv 库优化后的火焰图\"></p><p>从火焰图中我们可以看到，用strconv库优化后，除了已经优化过的字符串拼接和整型转字符串操作，还有个runtime.stringtoslicebyte函数消耗CPU资源也比较多。</p><h2>高性能字符串转字节切片</h2><p>这个函数其实就是我们的字符串转字节切片操作。runtime.stringtoslicebyte函数是怎么实现字符串转换为字节切片的呢？这里面是不是也有优化空间呢？</p><pre><code class=\"language-shell\">nameByte = []byte(users[index].Name)\n</code></pre><p>在搞明白runtime.stringtoslicebyte函数的实现逻辑之前，咱们先看看字符串和切片的数据结构。</p><p><strong>字符串在Golang底层对应的是 stringStruct 结构，这个结构里有两个成员变量，str 指针和len，str指针指向字符串的内容，len 存储字符串的长度。</strong></p><p><strong>切片对应的是 slice 结构，这个结构里有三个成员变量，array、len 和 cap。array 是指向数组的指针，这个数组里面存的就是切片内容，len 表示切片的长度，cap 表示切片的容量。</strong></p><pre><code class=\"language-go\">// 字符串数据结构\ntype stringStruct struct {\n    str unsafe.Pointer //指针类型，指向字节数组\n    len int\n}\n\n// 切片数据结构\ntype slice struct {\n    array unsafe.Pointer // 数组指针类型，指向数据数组\n    len   int\n    cap   int\n}\n</code></pre><p>回到前面的问题，runtime.stringtoslicebyte函数是怎么实现字符串转换为字节切片的呢？这里面有三个步骤。</p><ul>\n<li>\n<p>第一步，根据字符串的长度，为字节数组申请内存。</p>\n</li>\n<li>\n<p>第二步，构建字节切片对象，设置slice结构的成员变量。</p>\n</li>\n<li>\n<p>第三步，把字符串的内容拷贝到字节切片的底层数组里。</p>\n</li>\n</ul><p>这个函数的具体实现逻辑如下：</p><pre><code class=\"language-go\">func stringtoslicebyte(s string) []byte {\n    var b []byte\n    // 分配内存，构建字节切片对象\n    b := rawbyteslice(len(s))\n    // 字符串拷贝到字节切片的array数组\n    copy(b, s)\n    return b\n}\n// rawbyteslice allocates a new byte slice. The byte slice is not zeroed.\nfunc rawbyteslice(size int) (b []byte) {\n    cap := roundupsize(uintptr(size))\n    // 分配内存\n    p := mallocgc(cap, nil, false)\n    *(*slice)(unsafe.Pointer(&amp;b)) = slice{p, size, int(cap)}\n    return\n}\n</code></pre><p>可以看出<strong>，当将字符串转换为字节切片时，会发生底层字节数组空间的内存申请和拷贝。而且随着字符串长度变长，内存拷贝的性能损耗也会变大</strong>。</p><p>有没有一种方法，可以不用申请字节数组内存和做内存拷贝，实现高性能转换呢？</p><p>在说这个方法之前，咱们先了解一些前置知识，unsafe 包和 Go 语言里几个类型的大小。</p><p><strong>unsafe 包可以做一些绕过 Go 类型安全检查的操作，更灵活地操作内存。</strong>它有两个很重要的功能。</p><p><strong>第一个是定义了 Pointer 类型，任何类型的指针都能和这个 Pointer 互相转换</strong>，有点像 C 语言里的万能指针void*。</p><pre><code class=\"language-go\">var a int = 1\np := unsafe.Pointer(&amp;a) // 其它类型指针转Pointer\nb := (*int)(p) // Pointer类型转其它类型指针\nfmt.Println(*b) // 输出1\n</code></pre><p><strong>第二个功能是定义了 uintptr 类型，Pointer 和 uintptr 可以互相转换</strong>，这样就能做指针的加减等算术运算了。</p><pre><code class=\"language-go\">type Person struct {\n    age int\n    name string\n}\nperson := Person{age:18,name:\"k哥\"}\np := unsafe.Pointer(&amp;person) // 其它类型指针转Pointer\nu := uintptr(p) // Pointer类型转为uintptr\nu=u+8 // uintptr加减操作\npName := unsafe.Pointer(u) // uintptr转换为Pointer\nname := *(*string)(pName)\nfmt.Println(name) // 输出k哥\n</code></pre><p><strong>在 Go 语言里，int、uintptr、unsafe.Pointer 这三个类型所占的大小是相等的，32 位机器上是 4 字节，64 位机器上是 8 字节。</strong></p><p>咱们可以写个小测试来看看：</p><pre><code class=\"language-go\">func TestSize(t *testing.T) {\n    var i int\n    var u uintptr\n    var p unsafe.Pointer\n    fmt.Printf(\"int size: %d byte\\n\", unsafe.Sizeof(i))\n    fmt.Printf(\"uintptr size: %d byte\\n\", unsafe.Sizeof(u))\n    fmt.Printf(\"unsafe.Pointer size: %d byte\\n\", unsafe.Sizeof(p))\n}\n</code></pre><p>运行这个测试函数，可以看到int、uintptr和unsafe.Pointer都是占了8字节。</p><pre><code class=\"language-shell\">=== RUN   TestSize\nint size: 8 byte\nuintptr size: 8 byte\nunsafe.Pointer size: 8 byte\n</code></pre><p>有了这些功能，我们就可以用 unsafe 包和这几个类型大小相等的特性，重新解释底层的数据结构，避免字节数组的内存分配和拷贝，实现高性能类型转换。</p><p>让我们用unsafe包实现一个字符串转换为字节切片的函数。</p><ul>\n<li>\n<p>第一步，可以把字符串对象想象成一个长度为 2 的 uintptr 类型数组 x，这个数组的 0 号位置其实就是字符串的 str 成员变量，1 号位置就是字符串的 len 成员变量。</p>\n</li>\n<li>\n<p>第二步，构造一个长度为 3 的 uintptr 类型数组 b，0 号位置代表字节数组指针，1 号位置代表字节切片长度，2 号位置代表字节切片容量。</p>\n</li>\n<li>\n<p>第三步，把这个 uintptr 类型数组重新解释成字节切片。</p>\n</li>\n</ul><pre><code class=\"language-go\">func Str2Bytes(s string) []byte {\n    x := (*[2]uintptr)(unsafe.Pointer(&amp;s))\n    b := [3]uintptr{x[0], x[1], x[1]}\n    res := *(*[]byte)(unsafe.Pointer(&amp;b))\n    return res\n}\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/38/60/38d75690338afaf1e57d9275a4eb3a60.jpg?wh=2703x1358\" alt=\"\" title=\"图5 unsafe 包字符串转换为字节切片\"></p><p>让我们用unsafe包来重新实现一下我们的函数：</p><pre><code class=\"language-go\">func GenerateIdsUnsafe(users []*User) (string, string, []byte) {\n    names := \"\"\n    idStr := \"\"\n    var nameByte []byte\n    length := 0\n    for index := range users {\n        idStr = strconv.Itoa(users[index].Id)\n        // unsafe包实现字符串转字节切片\n        nameByte = Str2Bytes(users[index].Name)\n        length += len(users[index].Name) + 1\n    }\n    var builder strings.Builder\n    builder.Grow(length) // 预分配\n    for index := range users {\n        builder.WriteString(\",\")\n        builder.WriteString(users[index].Name)\n    }\n    return idStr, names, nameByte\n}\n</code></pre><p>使用unsafe包将字符串转换为字节切片，又能给咱们带来多大的性能提升呢？咱们用 Benchmark 来测一测。下面是Benchmark脚本：</p><pre><code class=\"language-go\">func BenchmarkGenerateIdsUnsafe(b *testing.B) {\n    for n := 0; n &lt; b.N; n++ {\n        GenerateIdsUnsafe(users)\n    }\n}\n</code></pre><p>果然，使用 <strong>unsafe包将字符串转换为字节切片的方式，性能提升非常明显。</strong></p><pre><code class=\"language-shell\">killianxu@KILLIANXU-MB0 performance % go test -run=none -benchmem&nbsp; -bench=. -gcflags=all=-l\ngoos: darwin\ngoarch: amd64\npkg: example.com/performance\ncpu: Intel(R) Core(TM) i5-7360U CPU @ 2.30GHz\nBenchmarkGenerateIdsStrconv-4&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 14966&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;78975 ns/op&nbsp; &nbsp; 23392 B/op&nbsp; &nbsp; &nbsp; &nbsp; 1901 allocs/op\nBenchmarkGenerateIdsUnsafe-4&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;26529&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;44976 ns/op&nbsp; &nbsp; 11072 B/op&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;901 allocs/op\n</code></pre><ul>\n<li>\n<p>从 CPU 资源消耗来看，runtime.stringtoslicebyte的方式，单次函数调用要78975ns，而unsafe包的方式，只要44976ns，节约了 43% 左右的 CPU 资源。</p>\n</li>\n<li>\n<p>从内存消耗来看，runtime.stringtoslicebyte的方式，单次函数调用要23392字节内存，而unsafe包的方式，每次函数调用只要11072字节内存，节约了 52.7% 左右的内存资源。</p>\n</li>\n</ul><p>实际上，unsafe包除了可以高效地将字符串转换为字节切片，也可以高效地将字节切片转换为字符串。</p><pre><code class=\"language-go\">func Bytes2Str(b []byte) string {\n    return *(*string)(unsafe.Pointer(&amp;b))\n}\n</code></pre><p>其实用unsafe包将字节切片转换为字符串的操作，在Golang库里也很常见，比如我们在前面介绍的高性能字符串拼接，Builder类型最后转化为字符串的源码，就是用unsafe包实现的。</p><pre><code class=\"language-go\">// String returns the accumulated string.\nfunc (b *Builder) String() string {\n    return *(*string)(unsafe.Pointer(&amp;b.buf))\n}\n</code></pre><p>让我们用火焰图再看看我们的函数是否还有优化空间。</p><pre><code class=\"language-go\">go test  -run=none -bench=BenchmarkGenerateIdsUnsafe -benchtime=10s -gcflags=all=-l -cpuprofile cpu.prof\ngo tool pprof -http=\":8081\" cpu.prof\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/e2/e5/e27f9f3d73702f46099ee110e20163e5.jpg?wh=3775x1339\" alt=\"\" title=\"图6 用 unsafe 包优化后的火焰图\"></p><p>从火焰图上可以看出，经过前面几次的优化，我们的函数最耗时的操作就只剩下已经优化过之后的字符串转字节切片、整型转字符串和字符串拼接这3个操作，因此没有进一步优化的空间了。</p><p>让我们来和最初实现的函数逻辑对比下，看下经过前面几次的优化，我们的性能总体提升了多少。</p><pre><code class=\"language-go\">killianxu@KILLIANXU-MB0 performance % go test -run=none -benchmem&nbsp; -bench=. -gcflags=all=-l&nbsp;\ngoos: darwin\ngoarch: amd64\npkg: example.com/performance\ncpu: Intel(R) Core(TM) i5-7360U CPU @ 2.30GHz\nBenchmarkGenerateIdsRaw-4&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 951&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1226580 ns/op&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4194656 B/op&nbsp; &nbsp; &nbsp; &nbsp;3739 allocs/op\nBenchmarkGenerateIdsUnsafe-4&nbsp; &nbsp; &nbsp; &nbsp;26372&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;45221 ns/op&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;11072 B/op&nbsp; &nbsp; &nbsp; &nbsp; 901 allocs/op\n</code></pre><p>从Benchmark测试，可以看出来，我们对CPU资源的消耗降低了27倍，对内存的消耗降低了379倍。</p><h2>小结</h2><p>今天这节课，我以一段待优化的函数代码为例，在逐步优化其对CPU资源的消耗过程中，向你展示了能降低CPU和内存资源消耗的3个高性能数据处理技巧。</p><ul>\n<li>\n<p>高性能字符串拼接技巧。当我们代码有大量字符串拼接操作时，可以使用 <strong>strings.Builder</strong> 类型，并利用它的内存预分配功能做字符串拼接。</p>\n</li>\n<li>\n<p>高性能整型转字符串技巧。当我们代码有大量整型转字符串操作时，可以用 <strong>strconv</strong> 库做转换，避免使用fmt.Sprint函数的反射和格式化资源消耗。</p>\n</li>\n<li>\n<p>高性能字符串转字节切片技巧。当我们代码有大量字符串转字节切片操作时，可以用 <strong>unsafe</strong> 包，通过字符串和字节切片底层数组空间共用，实现高性能转换。并且，也可以用unsafe包将字节切片转换为字符串。</p>\n</li>\n</ul><p>希望你好好体会这个用火焰图寻找瓶颈，再结合Go语言底层实现分析寻找更优方案的过程。在遇到内存和CPU瓶颈时，别忘了尝试运用这些高性能操作技巧，帮你节约更多CPU和内存资源，提升单机吞吐。</p><h2>思考题</h2><p>除了这节课里提到的3种高性能数据处理技巧，你还知道哪些高性能数据处理技巧呢？</p><p>欢迎你把你的答案分享在评论区，也欢迎你把这节课的内容分享给需要的朋友，我们下节课再见！</p>","neighbors":{"left":{"article_title":"03｜单机吞吐优化（一）：无需硬件升级也能提升吞吐","id":832423},"right":{"article_title":"05｜单机吞吐优化（三）：科学复用对象和协程资源","id":833743}},"comments":[{"had_liked":false,"id":396450,"user_name":"lJ","can_delete":false,"product_type":"c1","uid":2562558,"ip_address":"江苏","ucode":"CC29D06A16FF93","user_header":"https://static001.geekbang.org/account/avatar/00/27/19/fe/d31344db.jpg","comment_is_top":false,"comment_ctime":1734507998,"is_pvip":false,"replies":[{"id":143922,"content":"👍👍，第一个高性能json处理，可以试下字节开源的sonic库https:&#47;&#47;github.com&#47;bytedance&#47;sonic，我们有个场景，把json-iterator换成sonic做list循环反序列化，接口延时从21ms降到了17ms","user_name":"作者回复","user_name_real":"编辑","uid":1313417,"ctime":1734533485,"ip_address":"广东","comment_id":396450,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100843701,"comment_content":"1. 使用标准库的 encoding&#47;json 编解码性能较低，推荐使用github.com&#47;json-iterator&#47;go。\n2. 使用 io.Reader 和 io.Writer 进行流式传输，io.Copy 方法是一个高效实现的拷贝工具，可以在两个流之间传输数据。比如，如果 src 实现了 WriterTo 接口（如 TCPConn），会直接调用 src.WriteTo(dst)。这避免了 io.Copy 手动分配缓冲区并循环读取&#47;写入的过程，将高效传输的责任交给底层类型的实现。优先尝试调用内核的 splice 系统调用，避免数据从内核空间拷贝到用户空间再拷贝回内核空间的开销。如果 spliceTo 无法处理，则回退到通用的拷贝逻辑 genericWriteTo。","like_count":1,"discussions":[{"author":{"id":1313417,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0a/89/eb8c28a4.jpg","nickname":"徐逸","note":"","ucode":"DCFDEE08FD263A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":655291,"discussion_content":"👍👍，第一个高性能json处理，可以试下字节开源的sonic库https://github.com/bytedance/sonic，我们有个场景，把json-iterator换成sonic做list循环反序列化，接口延时从21ms降到了17ms","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1734533485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":2,"child_discussions":[{"author":{"id":2562558,"avatar":"https://static001.geekbang.org/account/avatar/00/27/19/fe/d31344db.jpg","nickname":"lJ","note":"","ucode":"CC29D06A16FF93","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1313417,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0a/89/eb8c28a4.jpg","nickname":"徐逸","note":"","ucode":"DCFDEE08FD263A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":655301,"discussion_content":"👍👍👍，老师 什么样的场景需要高性能的json实现，有个疑问，k8s源码似乎没有使用第三方json，这里有哪些考虑呢？可能考虑到了兼容性和维护性。方便细说下你们当时遇到的问题，分析方法，方案选型考量嘛。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1734576491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":655291,"ip_address":"江苏","group_id":0},"score":655301,"extra":""},{"author":{"id":1313417,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0a/89/eb8c28a4.jpg","nickname":"徐逸","note":"","ucode":"DCFDEE08FD263A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":2562558,"avatar":"https://static001.geekbang.org/account/avatar/00/27/19/fe/d31344db.jpg","nickname":"lJ","note":"","ucode":"CC29D06A16FF93","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":655337,"discussion_content":"主要是json序列化反序列化cpu消耗比较大。为了通用，又不方便换成PB的情况下，在通用和性能上权衡，就需要用高性能json库","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1734617581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":655301,"ip_address":"广东","group_id":0},"score":655337,"extra":""}]}]},{"had_liked":false,"id":396461,"user_name":"jxs1211","can_delete":false,"product_type":"c1","uid":1101006,"ip_address":"重庆","ucode":"B7F1F2D84389E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","comment_is_top":false,"comment_ctime":1734576813,"is_pvip":false,"replies":[{"id":143927,"content":"👍也可以的～","user_name":"作者回复","user_name_real":"作者","uid":1313417,"ctime":1734617387,"ip_address":"广东","comment_id":396461,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100843701,"comment_content":"这种写法可以吗，benchmark测下来感觉差不多\nfunc Str2Bytes(s string) []byte {\n\treturn *(*[]byte)(unsafe.Pointer(&amp;s))\n}","like_count":0,"discussions":[{"author":{"id":1313417,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0a/89/eb8c28a4.jpg","nickname":"徐逸","note":"","ucode":"DCFDEE08FD263A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":655336,"discussion_content":"👍也可以的～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1734617387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]}]}