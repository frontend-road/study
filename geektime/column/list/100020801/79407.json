{"id":79407,"title":"33 | 我查这么多数据，会不会把数据库内存打爆？","content":"<p>我经常会被问到这样一个问题：我的主机内存只有100G，现在要对一个200G的大表做全表扫描，会不会把数据库主机的内存用光了？</p><p>这个问题确实值得担心，被系统OOM（out of memory）可不是闹着玩的。但是，反过来想想，逻辑备份的时候，可不就是做整库扫描吗？如果这样就会把内存吃光，逻辑备份不是早就挂了？</p><p>所以说，对大表做全表扫描，看来应该是没问题的。但是，这个流程到底是怎么样的呢？</p><h1>全表扫描对server层的影响</h1><p>假设，我们现在要对一个200G的InnoDB表db1. t，执行一个全表扫描。当然，你要把扫描结果保存在客户端，会使用类似这样的命令：</p><pre><code>mysql -h$host -P$port -u$user -p$pwd -e &quot;select * from db1.t&quot; &gt; $target_file\n</code></pre><p>你已经知道了，InnoDB的数据是保存在主键索引上的，所以全表扫描实际上是直接扫描表t的主键索引。这条查询语句由于没有其他的判断条件，所以查到的每一行都可以直接放到结果集里面，然后返回给客户端。</p><p>那么，这个“结果集”存在哪里呢？</p><p>实际上，服务端并不需要保存一个完整的结果集。取数据和发数据的流程是这样的：</p><ol>\n<li>\n<p>获取一行，写到net_buffer中。这块内存的大小是由参数net_buffer_length定义的，默认是16k。</p>\n</li>\n<li>\n<p>重复获取行，直到net_buffer写满，调用网络接口发出去。</p>\n</li>\n<li>\n<p>如果发送成功，就清空net_buffer，然后继续取下一行，并写入net_buffer。</p>\n</li>\n<li>\n<p>如果发送函数返回EAGAIN或WSAEWOULDBLOCK，就表示本地网络栈（socket send buffer）写满了，进入等待。直到网络栈重新可写，再继续发送。</p>\n</li>\n</ol><!-- [[[read_end]]] --><p>这个过程对应的流程图如下所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/a0/bd/a027c300d7dde8cea4fad8f34b670ebd.jpg?wh=1142*880\" alt=\"\"></p><center><span class=\"reference\">图1 查询结果发送流程</span></center><p>从这个流程中，你可以看到：</p><ol>\n<li>\n<p>一个查询在发送过程中，占用的MySQL内部的内存最大就是net_buffer_length这么大，并不会达到200G；</p>\n</li>\n<li>\n<p>socket send buffer 也不可能达到200G（默认定义/proc/sys/net/core/wmem_default），如果socket send buffer被写满，就会暂停读数据的流程。</p>\n</li>\n</ol><p>也就是说，<strong>MySQL是“边读边发的”</strong>，这个概念很重要。这就意味着，如果客户端接收得慢，会导致MySQL服务端由于结果发不出去，这个事务的执行时间变长。</p><p>比如下面这个状态，就是我故意让客户端不去读socket receive buffer中的内容，然后在服务端show processlist看到的结果。</p><p><img src=\"https://static001.geekbang.org/resource/image/18/c3/183a704d4495bebbc13c524695b5b6c3.png?wh=1024*168\" alt=\"\"></p><center><span class=\"reference\">图2 服务端发送阻塞</span></center><p>如果你看到State的值一直处于<strong>“Sending to client”</strong>，就表示服务器端的网络栈写满了。</p><p>我在上一篇文章中曾提到，如果客户端使用–quick参数，会使用mysql_use_result方法。这个方法是读一行处理一行。你可以想象一下，假设有一个业务的逻辑比较复杂，每读一行数据以后要处理的逻辑如果很慢，就会导致客户端要过很久才会去取下一行数据，可能就会出现如图2所示的这种情况。</p><p>因此，<strong>对于正常的线上业务来说，如果一个查询的返回结果不会很多的话，我都建议你使用mysql_store_result这个接口，直接把查询结果保存到本地内存。</strong></p><p>当然前提是查询返回结果不多。在<a href=\"https://time.geekbang.org/column/article/78427\">第30篇文章</a>评论区，有同学说到自己因为执行了一个大查询导致客户端占用内存近20G，这种情况下就需要改用mysql_use_result接口了。</p><p>另一方面，如果你在自己负责维护的MySQL里看到很多个线程都处于“Sending to client”这个状态，就意味着你要让业务开发同学优化查询结果，并评估这么多的返回结果是否合理。</p><p>而如果要快速减少处于这个状态的线程的话，将net_buffer_length参数设置为一个更大的值是一个可选方案。</p><p>与“Sending to client”长相很类似的一个状态是<strong>“Sending data”</strong>，这是一个经常被误会的问题。有同学问我说，在自己维护的实例上看到很多查询语句的状态是“Sending data”，但查看网络也没什么问题啊，为什么Sending data要这么久？</p><p>实际上，一个查询语句的状态变化是这样的（注意：这里，我略去了其他无关的状态）：</p><ul>\n<li>MySQL查询语句进入执行阶段后，首先把状态设置成“Sending data”；</li>\n<li>然后，发送执行结果的列相关的信息（meta data) 给客户端；</li>\n<li>再继续执行语句的流程；</li>\n<li>执行完成后，把状态设置成空字符串。</li>\n</ul><p>也就是说，“Sending data”并不一定是指“正在发送数据”，而可能是处于执行器过程中的任意阶段。比如，你可以构造一个锁等待的场景，就能看到Sending data状态。</p><p><img src=\"https://static001.geekbang.org/resource/image/76/4b/7640b0d82965bf8b305514f30425424b.png?wh=1246*278\" alt=\"\"></p><center><span class=\"reference\">图3 读全表被锁</span></center><p><img src=\"https://static001.geekbang.org/resource/image/84/c0/84533515cf36be65582309fbb85e13c0.png?wh=1224*190\" alt=\"\"></p><center><span class=\"reference\">图 4 Sending data状态</span></center><p>可以看到，session B明显是在等锁，状态显示为Sending data。</p><p>也就是说，仅当一个线程处于“等待客户端接收结果”的状态，才会显示\"Sending to client\"；而如果显示成“Sending data”，它的意思只是“正在执行”。</p><p>现在你知道了，查询的结果是分段发给客户端的，因此扫描全表，查询返回大量的数据，并不会把内存打爆。</p><p>在server层的处理逻辑我们都清楚了，在InnoDB引擎里面又是怎么处理的呢？ 扫描全表会不会对引擎系统造成影响呢？</p><h1>全表扫描对InnoDB的影响</h1><p>在<a href=\"https://time.geekbang.org/column/article/68633\">第2</a>和<a href=\"https://time.geekbang.org/column/article/73161\">第15篇</a>文章中，我介绍WAL机制的时候，和你分析了InnoDB内存的一个作用，是保存更新的结果，再配合redo log，就避免了随机写盘。</p><p>内存的数据页是在Buffer Pool (BP)中管理的，在WAL里Buffer Pool 起到了加速更新的作用。而实际上，Buffer Pool 还有一个更重要的作用，就是加速查询。</p><p>在第2篇文章的评论区有同学问道，由于有WAL机制，当事务提交的时候，磁盘上的数据页是旧的，那如果这时候马上有一个查询要来读这个数据页，是不是要马上把redo log应用到数据页呢？</p><p>答案是不需要。因为这时候内存数据页的结果是最新的，直接读内存页就可以了。你看，这时候查询根本不需要读磁盘，直接从内存拿结果，速度是很快的。所以说，Buffer Pool还有加速查询的作用。</p><p>而Buffer Pool对查询的加速效果，依赖于一个重要的指标，即：<strong>内存命中率</strong>。</p><p>你可以在show engine innodb status结果中，查看一个系统当前的BP命中率。一般情况下，一个稳定服务的线上系统，要保证响应时间符合要求的话，内存命中率要在99%以上。</p><p>执行show engine innodb status ，可以看到“Buffer pool hit rate”字样，显示的就是当前的命中率。比如图5这个命中率，就是99.0%。</p><p><img src=\"https://static001.geekbang.org/resource/image/c7/2e/c70a95ee99826812c292c46de508982e.png?wh=457*42\" alt=\"\"></p><center><span class=\"reference\">图5 show engine innodb status显示内存命中率</span></center><p>如果所有查询需要的数据页都能够直接从内存得到，那是最好的，对应的命中率就是100%。但，这在实际生产上是很难做到的。</p><p>InnoDB Buffer Pool的大小是由参数 innodb_buffer_pool_size确定的，一般建议设置成可用物理内存的60%~80%。</p><p>在大约十年前，单机的数据量是上百个G，而物理内存是几个G；现在虽然很多服务器都能有128G甚至更高的内存，但是单机的数据量却达到了T级别。</p><p>所以，innodb_buffer_pool_size小于磁盘的数据量是很常见的。如果一个 Buffer Pool满了，而又要从磁盘读入一个数据页，那肯定是要淘汰一个旧数据页的。</p><p>InnoDB内存管理用的是最近最少使用 (Least Recently Used, LRU)算法，这个算法的核心就是淘汰最久未使用的数据。</p><p>下图是一个LRU算法的基本模型。</p><p><img src=\"https://static001.geekbang.org/resource/image/e0/65/e0ac92febac50a5d881f1188ea5bfd65.jpg?wh=1142*880\" alt=\"\"></p><center><span class=\"reference\">图6 基本LRU算法</span></center><p>InnoDB管理Buffer Pool的LRU算法，是用链表来实现的。</p><ol>\n<li>\n<p>在图6的状态1里，链表头部是P1，表示P1是最近刚刚被访问过的数据页；假设内存里只能放下这么多数据页；</p>\n</li>\n<li>\n<p>这时候有一个读请求访问P3，因此变成状态2，P3被移到最前面；</p>\n</li>\n<li>\n<p>状态3表示，这次访问的数据页是不存在于链表中的，所以需要在Buffer Pool中新申请一个数据页Px，加到链表头部。但是由于内存已经满了，不能申请新的内存。于是，会清空链表末尾Pm这个数据页的内存，存入Px的内容，然后放到链表头部。</p>\n</li>\n<li>\n<p>从效果上看，就是最久没有被访问的数据页Pm，被淘汰了。</p>\n</li>\n</ol><p>这个算法乍一看上去没什么问题，但是如果考虑到要做一个全表扫描，会不会有问题呢？</p><p>假设按照这个算法，我们要扫描一个200G的表，而这个表是一个历史数据表，平时没有业务访问它。</p><p>那么，按照这个算法扫描的话，就会把当前的Buffer Pool里的数据全部淘汰掉，存入扫描过程中访问到的数据页的内容。也就是说Buffer Pool里面主要放的是这个历史数据表的数据。</p><p>对于一个正在做业务服务的库，这可不妙。你会看到，Buffer Pool的内存命中率急剧下降，磁盘压力增加，SQL语句响应变慢。</p><p>所以，InnoDB不能直接使用这个LRU算法。实际上，InnoDB对LRU算法做了改进。</p><p><img src=\"https://static001.geekbang.org/resource/image/21/28/21f64a6799645b1410ed40d016139828.png?wh=1142*880\" alt=\"\"></p><center><span class=\"reference\">图 7 改进的LRU算法</span></center><p>在InnoDB实现上，按照5:3的比例把整个LRU链表分成了young区域和old区域。图中LRU_old指向的就是old区域的第一个位置，是整个链表的5/8处。也就是说，靠近链表头部的5/8是young区域，靠近链表尾部的3/8是old区域。</p><p>改进后的LRU算法执行流程变成了下面这样。</p><ol>\n<li>\n<p>图7中状态1，要访问数据页P3，由于P3在young区域，因此和优化前的LRU算法一样，将其移到链表头部，变成状态2。</p>\n</li>\n<li>\n<p>之后要访问一个新的不存在于当前链表的数据页，这时候依然是淘汰掉数据页Pm，但是新插入的数据页Px，是放在LRU_old处。</p>\n</li>\n<li>\n<p>处于old区域的数据页，每次被访问的时候都要做下面这个判断：</p>\n<ul>\n<li>若这个数据页在LRU链表中存在的时间超过了1秒，就把它移动到链表头部；</li>\n<li>如果这个数据页在LRU链表中存在的时间短于1秒，位置保持不变。1秒这个时间，是由参数innodb_old_blocks_time控制的。其默认值是1000，单位毫秒。</li>\n</ul>\n</li>\n</ol><p>这个策略，就是为了处理类似全表扫描的操作量身定制的。还是以刚刚的扫描200G的历史数据表为例，我们看看改进后的LRU算法的操作逻辑：</p><ol>\n<li>\n<p>扫描过程中，需要新插入的数据页，都被放到old区域;</p>\n</li>\n<li>\n<p>一个数据页里面有多条记录，这个数据页会被多次访问到，但由于是顺序扫描，这个数据页第一次被访问和最后一次被访问的时间间隔不会超过1秒，因此还是会被保留在old区域；</p>\n</li>\n<li>\n<p>再继续扫描后续的数据，之前的这个数据页之后也不会再被访问到，于是始终没有机会移到链表头部（也就是young区域），很快就会被淘汰出去。</p>\n</li>\n</ol><p>可以看到，这个策略最大的收益，就是在扫描这个大表的过程中，虽然也用到了Buffer Pool，但是对young区域完全没有影响，从而保证了Buffer Pool响应正常业务的查询命中率。</p><h1>小结</h1><p>今天，我用“大查询会不会把内存用光”这个问题，和你介绍了MySQL的查询结果，发送给客户端的过程。</p><p>由于MySQL采用的是边算边发的逻辑，因此对于数据量很大的查询结果来说，不会在server端保存完整的结果集。所以，如果客户端读结果不及时，会堵住MySQL的查询过程，但是不会把内存打爆。</p><p>而对于InnoDB引擎内部，由于有淘汰策略，大查询也不会导致内存暴涨。并且，由于InnoDB对LRU算法做了改进，冷数据的全表扫描，对Buffer Pool的影响也能做到可控。</p><p>当然，我们前面文章有说过，全表扫描还是比较耗费IO资源的，所以业务高峰期还是不能直接在线上主库执行全表扫描的。</p><p>最后，我给你留一个思考题吧。</p><p>我在文章中说到，如果由于客户端压力太大，迟迟不能接收结果，会导致MySQL无法发送结果而影响语句执行。但，这还不是最糟糕的情况。</p><p>你可以设想出由于客户端的性能问题，对数据库影响更严重的例子吗？或者你是否经历过这样的场景？你又是怎么优化的？</p><p>你可以把你的经验和分析写在留言区，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p><h1>上期问题时间</h1><p>上期的问题是，如果一个事务被kill之后，持续处于回滚状态，从恢复速度的角度看，你是应该重启等它执行结束，还是应该强行重启整个MySQL进程。</p><p>因为重启之后该做的回滚动作还是不能少的，所以从恢复速度的角度来说，应该让它自己结束。</p><p>当然，如果这个语句可能会占用别的锁，或者由于占用IO资源过多，从而影响到了别的语句执行的话，就需要先做主备切换，切到新主库提供服务。</p><p>切换之后别的线程都断开了连接，自动停止执行。接下来还是等它自己执行完成。这个操作属于我们在文章中说到的，减少系统压力，加速终止逻辑。</p><p>评论区留言点赞板：</p><blockquote>\n<p>@HuaMax 的回答中提到了对其他线程的影响；<br>\n@夹心面包 @Ryoma @曾剑 同学提到了重启后依然继续做回滚操作的逻辑。</p>\n</blockquote><p></p>","comments":[{"had_liked":false,"id":64042,"user_name":"700","can_delete":false,"product_type":"c1","uid":1072896,"ip_address":"","ucode":"E4BD0CBADAF951","user_header":"","comment_is_top":true,"comment_ctime":1548646275,"is_pvip":false,"replies":[{"id":"22654","content":"好问题👍 很好的思考👍<br><br>是这样的，net_buffer_length 的最大值是 1G，这个值比 socket send buffer大（一般是几M）<br><br>比如假设一个业务，他的平均查询结果都是10M （当然这个业务有有问题，最终是要通过业务解决）<br><br>但是如果我把net_buffer_length 改成10M，就不会有“Sending to client” 的情况。虽然网络栈还是慢慢发的，但是那些没发完的都缓存在net_buffer中，对于执行器来说，都是“已经写出去了”。<br>","user_name":"作者回复","comment_id":64042,"uid":"1264162","ip_address":"","utype":1,"ctime":1548655904,"user_name_real":"林晓斌"}],"discussion_count":9,"race_medal":0,"score":"9.2233724378353992e+18","product_id":100020801,"comment_content":"老师，您好。根据文章内容，提炼如下信息：<br>如果你看到 State 的值一直处于“Sending to client”，就表示服务器端的网络栈写满了。<br>如何处理？<br>1)使用 mysql_store_result 这个接口，直接把查询结果保存到本地内存。<br>2)优化查询结果，并评估这么多的返回结果是否合理。<br>3)而如果要快速减少处于这个状态的线程的话，将 net_buffer_length 参数设置为一个更大的值是一个可选方案。<br>对于第3)方案不是很懂，“Sending to client” 表示服务器端的网路栈写满了，那不是应该加大 socket send buffer 吗？跟加大 net_buffer_length 有什么关系？net_buffer_length 加再大，但 socket send buffer 很小的话，网络栈不还是处于写满状态？","like_count":92,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437826,"discussion_content":"好问题👍 很好的思考👍\n\n是这样的，net_buffer_length 的最大值是 1G，这个值比 socket send buffer大（一般是几M）\n\n比如假设一个业务，他的平均查询结果都是10M （当然这个业务有有问题，最终是要通过业务解决）\n\n但是如果我把net_buffer_length 改成10M，就不会有“Sending to client” 的情况。虽然网络栈还是慢慢发的，但是那些没发完的都缓存在net_buffer中，对于执行器来说，都是“已经写出去了”。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548655904,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1228424,"avatar":"https://static001.geekbang.org/account/avatar/00/12/be/88/8d15796f.jpg","nickname":"John","note":"","ucode":"A46AF2906C38C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311187,"discussion_content":"Each client thread is associated with a connection buffer and result buffer. Both begin with a size given by net_buffer_length but are dynamically enlarged up to max_allowed_packet bytes as needed. The result buffer shrinks to net_buffer_length after each SQL statement.\n\nThis variable should not normally be changed, but if you have very little memory, you can set it to the expected length of statements sent by clients. If statements exceed this length, the connection buffer is automatically enlarged. The maximum value to which net_buffer_length can be set is 1MB.\n\nThe session value of this variable is read only.\n\n针对每个客户端连接都会有两个缓冲区，一个是连接缓冲一个是结果集缓冲，net_buffer_length 指定这个缓冲区的初始值，max_allowed_packet 是这个缓冲区可以达到的最大值，缓冲区随着需要扩容。结果集每次 statement 执行之后会恢复为初始值即 net_buffer_length\n\nhttps://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_net_buffer_length","likes_number":19,"is_delete":false,"is_hidden":false,"ctime":1602247471,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1368901,"avatar":"","nickname":"miu","note":"","ucode":"3D73FF3C09231A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":135116,"discussion_content":"老师，您好。\n官方文档中net_buffer_length最大可设置的值是1M，max_allowed_packet最大可设置的值是1G，“是这样的，net_buffer_length 的最大值是 1G”这句话是不是说net_buffer最大可达到1G（即max_allowed_packet的最大可设置值）。\n那么net_buffer写满是指写到net_buffer_length设置的值，还是max_allowed_packet的值呢？","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1579069958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2761358,"avatar":"","nickname":"Geek_d38758","note":"","ucode":"7BE0963E18DDDC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404657,"discussion_content":"还是没懂，被绕进去了\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1634375032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1195775,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3e/ff/657b8d76.jpg","nickname":"杨可","note":"","ucode":"F9D43CADAC2B8B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2761358,"avatar":"","nickname":"Geek_d38758","note":"","ucode":"7BE0963E18DDDC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557883,"discussion_content":"你可以这么理解，语句的查询结果如果全部放入了 net_buffer 里，就表示语句执行结束了，不会阻塞后面的语句执行。socket send buffer 只负责把结果发给客户端，不需要等 socket send buffer 里的内容都发出去了才认为语句执行结束。调大 net_buffer_length 的值可以放入更多的语句执行结果","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1648017206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":404657,"ip_address":""},"score":557883,"extra":""}]},{"author":{"id":1986739,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/50/b3/9269cd59.jpg","nickname":"LWD","note":"","ucode":"DDA444DB113C01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588093,"discussion_content":"其实可以理解为socketoutputstream外面套了一层buffer；buffer的容量就是net_buffer_length，只有达到net_buffer_length才会调用一次真正的write操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663551970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1098505,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c3/09/dc368335.jpg","nickname":"杰sir","note":"","ucode":"80BB56B3BFB71A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556926,"discussion_content":"尝试回复 @miu 的提问：\nmax_allowed_packet 限制net_buffer的最大值\n\nnet_buffer俗称连接缓冲区，服务端接受客户端查询语句的缓冲区也是用的net_buffer，当客户端发送太多会导致net_buffer增长，最大max_allowed_packet（这个值最大可配1G）\n\n服务端给客户端发送响应时先把结果缓冲到net_buffer,如果net_buffer满了会阻塞，但不会自动增长net_buffer，所以只能靠增加net_buffer_length来提高发送响应时用到的net_buffer大小","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647573972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1341276,"avatar":"https://static001.geekbang.org/account/avatar/00/14/77/5c/8d53165e.jpg","nickname":"bingo","note":"","ucode":"DD96820EC8871D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403340,"discussion_content":"如果 net_buffer_length 设置的足够大，就可以只走一次引擎层，然后所有的数据就都保存在了 server 层，客户端接着取数据就可以直接从 server 层拿到，不再进入引擎层，这样就少了很多内部步骤，提升了服务端性能。比如很明显的一个提升就是，可以减少进入 innodb 的并发线程数量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634050829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2147220,"avatar":"https://static001.geekbang.org/account/avatar/00/20/c3/94/e89ebc50.jpg","nickname":"神毓逍遥","note":"","ucode":"83351CB18B190E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307380,"discussion_content":"miu提了好问题，麻烦老师回复下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600612981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64183,"user_name":"长杰","can_delete":false,"product_type":"c1","uid":1312212,"ip_address":"","ucode":"DD52C9494005F7","user_header":"https://static001.geekbang.org/account/avatar/00/14/05/d4/e06bf86d.jpg","comment_is_top":false,"comment_ctime":1548688578,"is_pvip":false,"replies":[{"id":"22787","content":"非常好，正是我要说明的一个场景呢，直接用你的例子放在下篇答疑部分哈","user_name":"作者回复","comment_id":64183,"uid":"1264162","ip_address":"","utype":1,"ctime":1548755076,"user_name_real":"林晓斌"}],"discussion_count":4,"race_medal":0,"score":"362325941442","product_id":100020801,"comment_content":"遇到过一个场景，用mysqldump对业务db做逻辑备份保存在客户端，客户端是虚拟机，磁盘很快满了，导致server端出现sending to client状态，更糟糕的是业务db更新频繁，导致undo表空间变大，db服务堵塞，服务端磁盘空间不足。","like_count":85,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437896,"discussion_content":"非常好，正是我要说明的一个场景呢，直接用你的例子放在下篇答疑部分哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548755076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1794060,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/60/0c/e1f012cb.jpg","nickname":"frankie","note":"","ucode":"813D1352B68A21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535312,"discussion_content":"为啥不看磁盘就备份呢。。。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638410201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1986739,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/50/b3/9269cd59.jpg","nickname":"LWD","note":"","ucode":"DDA444DB113C01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588094,"discussion_content":"应该是rr才会有这种问题吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663552070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2088647,"avatar":"","nickname":"雷鹏","note":"","ucode":"1B0A3A1D969A93","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552833,"discussion_content":"net_write_timeout超时，mysqldump的报错了吧，默认60秒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645606812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":67374,"user_name":"IceGeek17","can_delete":false,"product_type":"c1","uid":1103101,"ip_address":"","ucode":"1B42D7260449B4","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/fd/43802282.jpg","comment_is_top":false,"comment_ctime":1550136373,"is_pvip":false,"replies":[{"id":"23997","content":"1. “是一行一行的扔给socket send buffer，还是把net_buffer 里的内容一下子全部扔给 socket send buffer ？” <br>---- net_buffer写满，一起发，然后清空net_buffer,组装下一批 。好问题<br>2. 跟上一个问题同一个答案；<br>3. “对于一个查询，执行器拿到的所有结果，如果可以一次性放入net_buffer, 对于执行器来说是不是意味着“全都写出去了”，也就不会有 sending to client 状态？” ----是的<br><br>4. 是的<br>5. 对，这个就是我们其他文章中介绍的，“带着邻居节点一起刷”的那个阶段。<br><br>","user_name":"作者回复","comment_id":67374,"uid":"1264162","ip_address":"","utype":1,"ctime":1550298045,"user_name_real":"林晓斌"}],"discussion_count":6,"race_medal":0,"score":"246363272245","product_id":100020801,"comment_content":"老师你好，几个问题：<br><br>按照文中所述，net_buffer是属于MySQL Server层的，在InnoDB引擎层，会使用buffer pool (以page的形式)，也就是一个查询所占用的内存是： net_buffer + buffer pool里相关的page页<br>是不是可以这么理解？<br><br>当net_buffer写满，会调用网络接口发出去，net_buffer里的内容是如何发给socket send buffer的，<br>是一行一行的扔给socket send buffer，还是把net_buffer 里的内容一下子全部扔给 socket send buffer ？<br><br>文中说发送成功然后清空net_buffer, 这里net_buffer是如何清空的，是等net_buffer里的内容全部发送成功，然后一次性清理，还是发送成功一部分清理一部分？<br><br>看了置顶的700问题和回复，几点疑问：<br>对于一个查询，执行器拿到的所有结果，如果可以一次性放入net_buffer, 对于执行器来说是不是意味着“全都写出去了”，也就不会有 sending to client 状态？<br>只有当查询的结果，不能够全部放入net_buffer，需要等net_buffer里的内容清空后再继续放入后续的结果，这时候状态才是显示 sending to client ？<br>当查询结果可以全部放入net_buffer, 执行器也不管 net_buffer是否发送给 socket send buffer，都认为执行完了 ？<br>是不是这么理解？<br><br>对buffer pool，当通过LRU 淘汰数据页的时候，如果此时该页的内容是新的（也就是磁盘上的内容是老的），是不是需要强制先走一个刷脏页的流程，等脏页刷完了，然后才能淘汰该数据页？<br>","like_count":58,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439164,"discussion_content":"1. “是一行一行的扔给socket send buffer，还是把net_buffer 里的内容一下子全部扔给 socket send buffer ？” \n---- net_buffer写满，一起发，然后清空net_buffer,组装下一批 。好问题\n2. 跟上一个问题同一个答案；\n3. “对于一个查询，执行器拿到的所有结果，如果可以一次性放入net_buffer, 对于执行器来说是不是意味着“全都写出去了”，也就不会有 sending to client 状态？” ----是的\n\n4. 是的\n5. 对，这个就是我们其他文章中介绍的，“带着邻居节点一起刷”的那个阶段。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550298045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1124075,"avatar":"https://static001.geekbang.org/account/avatar/00/11/26/eb/24e0ac9c.jpg","nickname":"嬴梦川","note":"","ucode":"104CDFD26A1711","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374879,"discussion_content":"把这些提问变成陈述句，就成了本篇文章的很好补充。受教了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621398167,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1522824,"avatar":"https://static001.geekbang.org/account/avatar/00/17/3c/88/e83528da.jpg","nickname":"uking","note":"","ucode":"41005AC547327B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373563,"discussion_content":"按其他评论中的回答来看，net_buffer一般比socket send buffer 大，那net_buffer中的数据是如何一起发给socket send buffer呢？难道不应该是按socket send buffer的大小分批发么？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1620786111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1552364,"avatar":"https://static001.geekbang.org/account/avatar/00/17/af/ec/5f5bed0f.jpg","nickname":"如 道","note":"","ucode":"C1D241B344741B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409135,"discussion_content":"之前说net buffer 比 send buffer 大，一次把netbuffer 清空怎么实现的呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635384073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1450651,"avatar":"https://static001.geekbang.org/account/avatar/00/16/22/9b/4486d287.jpg","nickname":"黄常凯","note":"","ucode":"A8D40EA8EB6BFD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1552364,"avatar":"https://static001.geekbang.org/account/avatar/00/17/af/ec/5f5bed0f.jpg","nickname":"如 道","note":"","ucode":"C1D241B344741B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556662,"discussion_content":"清空不了就剩一部分在net_buffer呗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647442831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":409135,"ip_address":""},"score":556662,"extra":""}]},{"author":{"id":1627397,"avatar":"https://static001.geekbang.org/account/avatar/00/18/d5/05/8fd8ca4c.jpg","nickname":"快快乐乐","note":"","ucode":"D093D8D5836FF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348041,"discussion_content":"写的很透彻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612410346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":67287,"user_name":"XXL","can_delete":false,"product_type":"c1","uid":1036615,"ip_address":"","ucode":"0532132BB53193","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d1/47/41e4bada.jpg","comment_is_top":false,"comment_ctime":1550123842,"is_pvip":false,"replies":[{"id":"23993","content":"对，这种一般就是用mysql_use_result<br>各有优劣吧<br><br>一次性取的好处是，对服务端只全表，只扫描一遍；坏处是可能会出现大事务。<br><br>一般更常见的做法是，分批取，然后每一批拿到最大的一个id（主键值）<br>下一批查询的时候用 where Id &gt; N 这种写法<br><br>好问题","user_name":"作者回复","comment_id":67287,"uid":"1264162","ip_address":"","utype":1,"ctime":1550297655,"user_name_real":"林晓斌"}],"discussion_count":2,"race_medal":0,"score":"212003521346","product_id":100020801,"comment_content":"请教老师一个问题， <br>之前在开发工程中实际有碰到这样的业务，批量从MySQL中查询大量数据，每次通过限制起始+limit数量的来分批次查询，后来有同事推荐使用MySQL JDBC中的fetchSize()方法，不做分页通过一次大查询然后客户端流式读取来批量查询数据，这个内部原理是否就是文中所说的使用了mysql_use_result接口读一行处理一行实现的流式？或者也是mysql_store_result方式客户端边缓存边处理？请老师指教","like_count":50,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439132,"discussion_content":"对，这种一般就是用mysql_use_result\n各有优劣吧\n\n一次性取的好处是，对服务端只全表，只扫描一遍；坏处是可能会出现大事务。\n\n一般更常见的做法是，分批取，然后每一批拿到最大的一个id（主键值）\n下一批查询的时候用 where Id &amp;gt; N 这种写法\n\n好问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550297655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194853,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3b/65/3a4fc8cf.jpg","nickname":"prepared","note":"","ucode":"00E54A5C7CDCBE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337955,"discussion_content":"公司开发规范中，对于大数据分页的常见，建议使用老师说的方案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609136113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64544,"user_name":"Leon📷","can_delete":false,"product_type":"c1","uid":1219496,"ip_address":"","ucode":"B9BBD1EFAAE5A2","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg","comment_is_top":false,"comment_ctime":1548818247,"is_pvip":false,"replies":[{"id":"22865","content":"对的<br>","user_name":"作者回复","comment_id":64544,"uid":"1264162","ip_address":"","utype":1,"ctime":1548822923,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"186232411975","product_id":100020801,"comment_content":"如果客户端读结果不及时，会堵住 MySQL 的查询过程，但是不会把内存打爆。这个是指客户端的tcp滑动窗口处理没有及时确认，导致server端的网络协议栈没有多余的空间可以发送数据，导致server的处理线程停止从db读取数据发送给client，是这样理解吗","like_count":44,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438060,"discussion_content":"对的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548822923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81609,"user_name":"清风","can_delete":false,"product_type":"c1","uid":1129749,"ip_address":"","ucode":"59932E13FAF607","user_header":"https://static001.geekbang.org/account/avatar/00/11/3d/15/7f5fd6d3.jpg","comment_is_top":false,"comment_ctime":1553961386,"is_pvip":false,"replies":[{"id":"29644","content":"你的理解是对的，每个线程(session)一个","user_name":"作者回复","comment_id":81609,"uid":"1264162","ip_address":"","utype":1,"ctime":1554047892,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"138992914858","product_id":100020801,"comment_content":"net_buffer 应该是针对每个请求线程单独分配的，还是共享net_buffer . 我的理解应该是每个线程一块。mysql 可以根据最大请求连接数，能够算出来mysql 使用net_buffer 的总大小。同时如果mysql 占用的内存不大，也将影响到Mysql 能够处理连接连接数的大小。 不知道这种猜测是否准确。  后面那个改进型的LRU 算法真的非常好，就跟JVM 中年轻带 老年代的内存区域划分和淘汰机制一样。在做系统设计的时候可以把这种设计应用一下。","like_count":33,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445267,"discussion_content":"你的理解是对的，每个线程(session)一个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554047892,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64005,"user_name":"老杨同志","can_delete":false,"product_type":"c1","uid":1246199,"ip_address":"","ucode":"3F334F0CFD3DE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg","comment_is_top":false,"comment_ctime":1548640553,"is_pvip":false,"replies":[{"id":"22638","content":"👍<br>再考虑下都是update的情况 😆","user_name":"作者回复","comment_id":64005,"uid":"1264162","ip_address":"","utype":1,"ctime":1548643265,"user_name_real":"林晓斌"}],"discussion_count":3,"race_medal":0,"score":"108922822953","product_id":100020801,"comment_content":"本身是研发没过这种经历。猜一种吧<br>如果客户端A性能慢，迟迟不去读取socket receive buffer，server端就不能发送，此时如果客户端A要读取的数据被其他线程频繁update，由于mvcc的实现，这个变更会记录到undo log，大量的日志会不会使io飙升？可能比较极端才会吧。如果此时客户端性能恢复，服务端要读取最新数据，并通过undo log计算较早的版本，是不是要也占用大量的cpu资源或者io资源？谢谢老师","like_count":26,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437805,"discussion_content":"👍\n再考虑下都是update的情况 😆","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548643265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1219198,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIEl3fX9nvzUF26ekUIicp4sgA5jZ1mGvGMhIHkwJabbjt9h5uTLw5zzU1U6JZbCSpRXBNQwuejLJg/132","nickname":"轻松的鱼","note":"","ucode":"F4FF653209C47B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369238,"discussion_content":"net_wirte_timeout默认60s，net_buffer 迟迟不清空，MySQL Server 写 net_buffer 会阻塞，超过 60s 就会报错断开连接吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618983256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2088647,"avatar":"","nickname":"雷鹏","note":"","ucode":"1B0A3A1D969A93","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1219198,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIEl3fX9nvzUF26ekUIicp4sgA5jZ1mGvGMhIHkwJabbjt9h5uTLw5zzU1U6JZbCSpRXBNQwuejLJg/132","nickname":"轻松的鱼","note":"","ucode":"F4FF653209C47B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552834,"discussion_content":"是的，会报错断开","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645606941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":369238,"ip_address":""},"score":552834,"extra":""}]}]},{"had_liked":false,"id":64044,"user_name":"Zzz","can_delete":false,"product_type":"c1","uid":1116272,"ip_address":"","ucode":"4AA47797F48315","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIu1n1DhUGGKTjelrQaLYOSVK2rsFeia0G8ASTIftib5PTOx4pTqdnfwb0NiaEFGRgS661nINyZx9sUg/132","comment_is_top":false,"comment_ctime":1548646548,"is_pvip":false,"replies":[{"id":"22652","content":"这三个问题其实是同一个<br><br>“边读边发”的意思是，算出来的结果才能发<br>像order by，得先排序得到结果，然后才发出去，如果读了数据直接发，那肯定不行，那是错误的结果。<br><br>所以要排序了以后再发，这时候就需要中间数据结构，sort buffer<br>","user_name":"作者回复","comment_id":64044,"uid":"1264162","ip_address":"","utype":1,"ctime":1548655626,"user_name_real":"林晓斌"}],"discussion_count":6,"race_medal":0,"score":"87447992468","product_id":100020801,"comment_content":"林老师，有几个问题想请教以下：<br>1、哪种查询语句下MySQL 是“边读边发的”的呢？对于order by这种语句肯定是需要先全部拿到内存再做排序处理最后返回结果。<br>2、MySQL是怎么判断出可以“边读边发的”，是不是看下语句是否带order by这种关键字？<br>3、我有办法知道该执行语句是否“边读边发的”吗？","like_count":21,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437828,"discussion_content":"这三个问题其实是同一个\n\n“边读边发”的意思是，算出来的结果才能发\n像order by，得先排序得到结果，然后才发出去，如果读了数据直接发，那肯定不行，那是错误的结果。\n\n所以要排序了以后再发，这时候就需要中间数据结构，sort buffer\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548655626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018620,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","nickname":"ipofss","note":"","ucode":"DE3061C9259F9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":205665,"discussion_content":"先把正确的结果数据进行组装，然后再进行发送，可以这样理解吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584330359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1310518,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ff/36/83281758.jpg","nickname":"L","note":"","ucode":"C18B98D3DC3387","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1018620,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","nickname":"ipofss","note":"","ucode":"DE3061C9259F9E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335636,"discussion_content":"是的，就是这样。因为计算出的结果是边算边发，所以不会oom。计算所占的空间，会利用各种buffer和磁盘，也不会oom。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1608259083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":205665,"ip_address":""},"score":335636,"extra":""},{"author":{"id":1043325,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/c9xpiakQ3OC1AlfCeW03lLnnb7mj5v35Hib8YDs66zpnVib2n2qFichFmFp2Ec4QDPR0dKh38MkBBLyD3bE4NiaanZQ/132","nickname":"龙晓","note":"","ucode":"FAF34F1C65D103","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1310518,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ff/36/83281758.jpg","nickname":"L","note":"","ucode":"C18B98D3DC3387","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358726,"discussion_content":"大量排序应该是很占内存的，具体影响很难说，不知道会不会oom","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616037175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":335636,"ip_address":""},"score":358726,"extra":""},{"author":{"id":1901428,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLwIAiaxOJWE3Ut6hRvTzvFkCIibcURojC0XrQI1lC3h58enlNcpXQ98rmUOr5lA6ST3m24micj191Gw/132","nickname":"不疾","note":"","ucode":"18AA0F294C1586","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1043325,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/c9xpiakQ3OC1AlfCeW03lLnnb7mj5v35Hib8YDs66zpnVib2n2qFichFmFp2Ec4QDPR0dKh38MkBBLyD3bE4NiaanZQ/132","nickname":"龙晓","note":"","ucode":"FAF34F1C65D103","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375144,"discussion_content":"大量排序前边提到过通过sort_buffer参数控制，内存不够会利用磁盘空间排序","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1621495387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":358726,"ip_address":""},"score":375144,"extra":""}]}]},{"had_liked":false,"id":81940,"user_name":"冰点18","can_delete":false,"product_type":"c1","uid":1112370,"ip_address":"","ucode":"0BD9DBE5D3242E","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/32/8ced1824.jpg","comment_is_top":false,"comment_ctime":1554084135,"is_pvip":false,"replies":[{"id":"30020","content":"会的","user_name":"作者回复","comment_id":81940,"uid":"1264162","ip_address":"","utype":1,"ctime":1554432652,"user_name_real":"林晓斌"}],"discussion_count":4,"race_medal":0,"score":"57388658983","product_id":100020801,"comment_content":"InnoDB改进的LRU算法，如果遇到连续两次的全表扫描，会不会就把young区的3&#47;5给覆盖掉了？因为两次扫描时间间隔会超过一秒？","like_count":14,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445399,"discussion_content":"会的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554432652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1788647,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/4a/e7/6c16af5d.jpg","nickname":"汉江","note":"","ucode":"01622D984B8F9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358443,"discussion_content":"5/8 不是 3/5","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1615982925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1136059,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epIz8Iynichoe0aF8IXFmUZMR1z364XoukxiaFbUJMsiazeM2odbWNVxDuO5KaCSqecibnFGNvM5peibhA/132","nickname":"younger","note":"","ucode":"C40C64D052CB3E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1788647,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/4a/e7/6c16af5d.jpg","nickname":"汉江","note":"","ucode":"01622D984B8F9B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591187,"discussion_content":"人家说的是young区的3/5，没问题啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666344675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":358443,"ip_address":"北京"},"score":591187,"extra":""}]},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296704,"discussion_content":"哈 所以这个时候 也可以看下其他 LRU算法，包含LRU-K,LRU-2Q，甚至LRU-MQ，根据自己的业务来","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596627459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188317,"user_name":"ipofss","can_delete":false,"product_type":"c1","uid":1018620,"ip_address":"","ucode":"DE3061C9259F9E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","comment_is_top":false,"comment_ctime":1584339281,"is_pvip":false,"replies":[{"id":"72681","content":"理解正确的👌","user_name":"作者回复","comment_id":188317,"uid":"1264162","ip_address":"","utype":1,"ctime":1584342102,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"48828979537","product_id":100020801,"comment_content":"MySQL是“边读边发”的，所以对于一个大查询，不会在server层把数据库内存打爆。<br>而对于innodb内部，也使用了改进的LRU算法，去使用内存，所以也不会把内存打爆。<br><br>老师，有个问题：<br>既然数据是“边读边发”的，对于一个读请求，如果时间太长了，而没有处理完，另外一个写请求进来了，如何保证前面的读请求不会读到脏数据？<br>我的理解是MVCC控制的，只去读取当时的数据，即使后来进行了数据的增、删、改，但是读的时候，只去读取当时的那个版本。","like_count":12,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487373,"discussion_content":"理解正确的👌","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584342102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120562,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1564929507,"is_pvip":false,"replies":[{"id":"44335","content":"你这个例子不错😆","user_name":"作者回复","comment_id":120562,"uid":"1264162","ip_address":"","utype":1,"ctime":1564983905,"user_name_real":"林晓斌"}],"discussion_count":2,"race_medal":0,"score":"35924667875","product_id":100020801,"comment_content":"用一个小勺子怎么吃完一碗米，想必大家都会，哈哈。这个和边读边发异曲同工呀!","like_count":9,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461386,"discussion_content":"你这个例子不错😆","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564983905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2161554,"avatar":"https://static001.geekbang.org/account/avatar/00/20/fb/92/17923e19.jpg","nickname":"团圆丁","note":"","ucode":"23DD0146F43C7D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340651,"discussion_content":"做成粽子，一勺子一个😊😊😊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610088140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":69006,"user_name":"几近虚年","can_delete":false,"product_type":"c1","uid":1355831,"ip_address":"","ucode":"28CD6486EED8E2","user_header":"https://static001.geekbang.org/account/avatar/00/14/b0/37/d654fbac.jpg","comment_is_top":false,"comment_ctime":1550643291,"is_pvip":false,"replies":[{"id":"24487","content":"网络栈 socket receive buffer 写满了","user_name":"作者回复","comment_id":69006,"uid":"1264162","ip_address":"","utype":1,"ctime":1550652626,"user_name_real":"林晓斌"}],"discussion_count":7,"race_medal":0,"score":"35910381659","product_id":100020801,"comment_content":"老师，看了课文和留言，有个问题有点懵。<br>Sending to client 状态，到底是体现了服务端的网络栈 socket receive buffer 写满了（客户端未及时读取），还是 net_buffer 满了，还有查询结果没有写入到 net_buffer 中？","like_count":8,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439909,"discussion_content":"网络栈 socket receive buffer 写满了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550652626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1177797,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f8/c5/6d38f3e3.jpg","nickname":"黑微狗‮‮","note":"","ucode":"D44505E7E97BB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":546610,"discussion_content":"老师 socket receive buffer 是客户端的吧？好像和文中的描述（“如果你看到 State 的值一直处于“Sending to client”，就表示服务器端的网络栈写满了。”）对不上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642348027,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":439909,"ip_address":""},"score":546610,"extra":""},{"author":{"id":1195775,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3e/ff/657b8d76.jpg","nickname":"杨可","note":"","ucode":"F9D43CADAC2B8B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1177797,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f8/c5/6d38f3e3.jpg","nickname":"黑微狗‮‮","note":"","ucode":"D44505E7E97BB3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557885,"discussion_content":"应该就是服务端的 socket send buffer，老师这里估计是复制错了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648017513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546610,"ip_address":""},"score":557885,"extra":""}]},{"author":{"id":1107690,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/ea/cf8ffc85.jpg","nickname":"shijiazo","note":"","ucode":"E2F32581829F11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":170225,"discussion_content":"我的理解是net_buffer是分批放的，每批都放满net_buffer，然后数据放从net_buffer复制到socket receive buffer中慢慢发送，虽然此时net_buffer部分可用了，但是不会清数据，也不会再放里放数据，直到发送成功了，才会清空net_buffer，放入下一批数据。所以Sending to client 状态意味着网络栈 socket receive buffer 和net_buffer都满了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581675845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1020492,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/4c/40783447.jpg","nickname":"何骧","note":"","ucode":"11DCC74CE2F300","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1107690,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/ea/cf8ffc85.jpg","nickname":"shijiazo","note":"","ucode":"E2F32581829F11","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301862,"discussion_content":"我也这么认为，但是这里的 socket receive buffer 和 socket send buffer是一个buffer 吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598688912,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":170225,"ip_address":""},"score":301862,"extra":""},{"author":{"id":1644104,"avatar":"https://static001.geekbang.org/account/avatar/00/19/16/48/09493874.jpg","nickname":"茶没喝完","note":"","ucode":"D72D88C42A1258","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020492,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/4c/40783447.jpg","nickname":"何骧","note":"","ucode":"11DCC74CE2F300","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347285,"discussion_content":"不是，socket receive buffer是客户端那边的(你使用jdbc的服务器tcp层) socket send buffer是mysql所在服务器的tcp层。我是这么理解的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612187730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301862,"ip_address":""},"score":347285,"extra":""}]},{"author":{"id":1043325,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/c9xpiakQ3OC1AlfCeW03lLnnb7mj5v35Hib8YDs66zpnVib2n2qFichFmFp2Ec4QDPR0dKh38MkBBLyD3bE4NiaanZQ/132","nickname":"龙晓","note":"","ucode":"FAF34F1C65D103","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358727,"discussion_content":"这是一个链条，就想木桶短板一样，任何一环满都可能导致问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616037388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64006,"user_name":"克劳德","can_delete":false,"product_type":"c1","uid":1323851,"ip_address":"","ucode":"F94AD5C3D607AE","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/4b/71905da9.jpg","comment_is_top":false,"comment_ctime":1548640743,"is_pvip":false,"replies":[{"id":"22641","content":"一般我们说“MySQL挂掉”，大多数情况下就是响应慢了；<br><br>如果说重启的话， 有一种是InnoDB 读 io迟迟不返回，会自己重启；<br>还有是innodb_buffer_pool_size 设置太大，再加上server层使用的内存，导致内存超过系统上限被oom。我们说一个大查询不会打爆，但是如果很多并发查询，还是可能的。<br> ","user_name":"作者回复","comment_id":64006,"uid":"1264162","ip_address":"","utype":1,"ctime":1548643687,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"35908379111","product_id":100020801,"comment_content":"最近系统出现了由于查询大量数据而导致服务不可用的情况，当时第一反应是数据库内存打满了，后来发现数据库正常，应用服务因为OOM挂掉了，虽然这个问题解决了，但一直担心如果应用服务并发这样的查询语句，MySQL是否也会OOM。所以说今天这篇文章真是太及时了。<br>一直有一个疑问，我个人理解用户进程挂掉的根本原因几乎都是来自内存（访问非法地址或者OOM等）。既然MySQL在查询大量数据时不会导致OOM，在连接数和内存大小方面如果参数设置合理应该也不会导致OOM，那还有什么情况可以使MySQL挂掉？","like_count":9,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437806,"discussion_content":"一般我们说“MySQL挂掉”，大多数情况下就是响应慢了；\n\n如果说重启的话， 有一种是InnoDB 读 io迟迟不返回，会自己重启；\n还有是innodb_buffer_pool_size 设置太大，再加上server层使用的内存，导致内存超过系统上限被oom。我们说一个大查询不会打爆，但是如果很多并发查询，还是可能的。\n ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548643687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":66836,"user_name":"zzz2","can_delete":false,"product_type":"c1","uid":1358407,"ip_address":"","ucode":"C1FB57A8FD7849","user_header":"","comment_is_top":false,"comment_ctime":1550027422,"is_pvip":false,"replies":[{"id":"23672","content":"qcache hits说的就是查询缓存命中率吧<br><br>一般我们说内存命中率，一般是指buffer pool命中率","user_name":"作者回复","comment_id":66836,"uid":"1264162","ip_address":"","utype":1,"ctime":1550047712,"user_name_real":"林晓斌"}],"discussion_count":2,"race_medal":0,"score":"31614798494","product_id":100020801,"comment_content":"老师 ，请问mysql内存命中率和缓存命中率qcache hits是什么关系？","like_count":7,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438937,"discussion_content":"qcache hits说的就是查询缓存命中率吧\n\n一般我们说内存命中率，一般是指buffer pool命中率","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550047712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1000550,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/44/66/95976d10.jpg","nickname":"一路向前","note":"","ucode":"853B90DF308425","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344912,"discussion_content":"内存命中是指innodb查询时候直接从内存取数据，不需要读盘，查询缓存是server端命中，还没到引擎。另外8.0已经默认不开启查询缓存了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1611625653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64119,"user_name":"天使梦泪","can_delete":false,"product_type":"c1","uid":1235750,"ip_address":"","ucode":"782991747DD424","user_header":"https://static001.geekbang.org/account/avatar/00/12/db/26/3c8d68fb.jpg","comment_is_top":false,"comment_ctime":1548670639,"is_pvip":false,"replies":[{"id":"22664","content":"“保存一段时间”是啥意思，LRU算法不是按照时间的哈，如果没人来淘汰，是可以一直保存的。","user_name":"作者回复","comment_id":64119,"uid":"1264162","ip_address":"","utype":1,"ctime":1548673794,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"31613441711","product_id":100020801,"comment_content":"老师，我有个问题不明白，mysql从缓存中取数据，缓存里的数据是怎么实现可以保存一段时间的？","like_count":7,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437868,"discussion_content":"“保存一段时间”是啥意思，LRU算法不是按照时间的哈，如果没人来淘汰，是可以一直保存的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1548673794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64076,"user_name":"如明如月","can_delete":false,"product_type":"c1","uid":1161049,"ip_address":"","ucode":"0D7FD0FCC11FAF","user_header":"https://static001.geekbang.org/account/avatar/00/11/b7/59/cf13fc22.jpg","comment_is_top":false,"comment_ctime":1548660463,"is_pvip":false,"replies":[{"id":"22655","content":"嗯，这个不会返回结果到客户端，所以网络上不会有问题<br><br>引擎内部的扫描机制是差不多的<br><br>唯一不同是这个过程可能对原表有行锁（如果设置的是RR）<br><br>万或者十万还好，是小数据，可以考虑拿到客户端再写回去，避免锁的问题<br><br><br>","user_name":"作者回复","comment_id":64076,"uid":"1264162","ip_address":"","utype":1,"ctime":1548663064,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"31613431535","product_id":100020801,"comment_content":"之前有特殊功能需要从主要业务库拉取指定范围的数据到另外同一个库的其他数据表的动作（insert  into xxxxx select xxx from xxx 这种操作）数据量在万级或者十万级，对于这种操作，和本文讲的应该有些不同吧？能否帮分析一下这种场景的大致情况呢？或者有什么好的建议吗？","like_count":7,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437846,"discussion_content":"嗯，这个不会返回结果到客户端，所以网络上不会有问题\n\n引擎内部的扫描机制是差不多的\n\n唯一不同是这个过程可能对原表有行锁（如果设置的是RR）\n\n万或者十万还好，是小数据，可以考虑拿到客户端再写回去，避免锁的问题\n\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548663064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":63964,"user_name":"尘封","can_delete":false,"product_type":"c1","uid":1247006,"ip_address":"","ucode":"CEE0C006387A03","user_header":"https://static001.geekbang.org/account/avatar/00/13/07/1e/bdbe93f4.jpg","comment_is_top":false,"comment_ctime":1548632364,"is_pvip":false,"replies":[{"id":"22626","content":"满16k就发给socket send buffer","user_name":"作者回复","comment_id":63964,"uid":"1264162","ip_address":"","utype":1,"ctime":1548636568,"user_name_real":"林晓斌"}],"discussion_count":5,"race_medal":0,"score":"31613403436","product_id":100020801,"comment_content":"如果一行数据超过了net buffer length的默认值16KB会如何？","like_count":7,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437785,"discussion_content":"满16k就发给socket send buffer","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548636568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1541014,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/96/73ff13a0.jpg","nickname":"天亮前说晚安","note":"","ucode":"1D82EE562A7C71","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":176536,"discussion_content":"那是不是有情况客户端只收到半行数据？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582037103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1541014,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/96/73ff13a0.jpg","nickname":"天亮前说晚安","note":"","ucode":"1D82EE562A7C71","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":178541,"discussion_content":"如果这样，程序层面会抛异常错误吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582172319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":176536,"ip_address":""},"score":178541,"extra":""},{"author":{"id":1541014,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/96/73ff13a0.jpg","nickname":"天亮前说晚安","note":"","ucode":"1D82EE562A7C71","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":180240,"discussion_content":"异常应该是有的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582287728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":178541,"ip_address":""},"score":180240,"extra":""},{"author":{"id":1986739,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/50/b3/9269cd59.jpg","nickname":"LWD","note":"","ucode":"DDA444DB113C01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1541014,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/96/73ff13a0.jpg","nickname":"天亮前说晚安","note":"","ucode":"1D82EE562A7C71","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588098,"discussion_content":"不会抛异常吧；tcp本来就是流式处理，收到的包不完整很正常，一般都是客户端阻塞获取直到构成一个完整数据报这样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663554884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":176536,"ip_address":"广东"},"score":588098,"extra":""}]}]},{"had_liked":false,"id":64164,"user_name":"Ryoma","can_delete":false,"product_type":"c1","uid":1130590,"ip_address":"","ucode":"7F692369239692","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/5e/b8fada94.jpg","comment_is_top":false,"comment_ctime":1548682520,"is_pvip":true,"replies":[{"id":"22712","content":"0  😆<br><br>1.  搜一下 innodb_buffer_pool_instances 这个参数的解释哈","user_name":"作者回复","comment_id":64164,"uid":"1264162","ip_address":"","utype":1,"ctime":1548689984,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":2,"score":"27318486296","product_id":100020801,"comment_content":"有两个问题：<br>0：MySQL 中的新生代和老生代的名字这么反人类的么<br>1：我在使用show engine innodb status看Buffer Pool时，发现Buffer Pool有8个（0~8），请问老师这个是什么策略呢？","like_count":6,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437893,"discussion_content":"0  😆\n\n1.  搜一下 innodb_buffer_pool_instances 这个参数的解释哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548689984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":63988,"user_name":"00江","can_delete":false,"product_type":"c1","uid":1391005,"ip_address":"","ucode":"70A0419B0D3D15","user_header":"https://static001.geekbang.org/account/avatar/00/15/39/9d/52107153.jpg","comment_is_top":false,"comment_ctime":1548637701,"is_pvip":false,"replies":[{"id":"22642","content":"就是客户端不去读<br><br>比如客户端压力很大，cpu没有轮转不到；<br>或者读完一行数据后，又去读别的系统（比如搜索系统），和类似的耗时操作","user_name":"作者回复","comment_id":63988,"uid":"1264162","ip_address":"","utype":1,"ctime":1548643756,"user_name_real":"林晓斌"}],"discussion_count":2,"race_medal":0,"score":"27318441477","product_id":100020801,"comment_content":"文中提到： 服务端是边读边发的<br>即服务端读取发送，读取发送，重复这个过程，那么为什么会出现客户端不能接受结果呢（ 由于客户端压力太大，迟迟不能接收结果）<br>","like_count":7,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437796,"discussion_content":"就是客户端不去读\n\n比如客户端压力很大，cpu没有轮转不到；\n或者读完一行数据后，又去读别的系统（比如搜索系统），和类似的耗时操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548643756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1227511,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ba/f7/eaa138ee.jpg","nickname":"Eric","note":"","ucode":"7D886CF30A8E22","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559871,"discussion_content":"怎么模拟故意让客户端不去读 socket receive buffer 中的内容？然后在服务端 show processlist 看到的结果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649024896,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":80896,"user_name":"是我的海","can_delete":false,"product_type":"c1","uid":1197457,"ip_address":"","ucode":"4BCE240829676A","user_header":"https://static001.geekbang.org/account/avatar/00/12/45/91/afda3094.jpg","comment_is_top":false,"comment_ctime":1553751895,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"23028588375","product_id":100020801,"comment_content":"在线上遇到过一个问题：<br>1.在慢日志中看到一条业务 sql 语句执行时间较长，但是自己在数据库中执行时瞬间返回结果，可能是什么原因？会是由于发送的数据多阻塞造成的么 ？(net_buffer_length太小 ？） <br>2.慢查询语句到底是如何定义的？处于sending to client 状态，是不是也会统计等待写入net_buffer_length 的时间呢 ？","like_count":5,"discussions":[{"author":{"id":1607424,"avatar":"https://static001.geekbang.org/account/avatar/00/18/87/00/18eea339.jpg","nickname":"🎧","note":"","ucode":"ED54DE6D0CF497","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392225,"discussion_content":"是吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630914439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1303322,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e3/1a/061e77b6.jpg","nickname":"亢星东","note":"","ucode":"5E4063E83B2BB9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331865,"discussion_content":"客户端应该是加了limit限制返回条数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606996041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64228,"user_name":"SICUN","can_delete":false,"product_type":"c1","uid":1254261,"ip_address":"","ucode":"22A384904EB9E9","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/75/2b599841.jpg","comment_is_top":false,"comment_ctime":1548723124,"is_pvip":false,"replies":[{"id":"22758","content":"1.  是 ，但是也不是“全部放到buffer pool以后”才发，读的时候是一个page 一个page 地读的<br>2. 会，好在这个是“某一页”而已，量不大。 好问题<br><br>很好的思考","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548731472,"ip_address":"","comment_id":64228,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23023559604","product_id":100020801,"comment_content":"老师，您好，有两个问题麻烦解惑一下<br>1.扫描200G的表时数据会先放到InnoDB buffer pool,然后发送时在读取到net_buffer吗？<br>2.如果是的话，异常情况导致socket send buffer被写满，是不是会出现InnoDB buffer中的某一页有可能出现读取后面的行时，超过1s，而被放到yong区域的情况？<br>不知道这样表述或者理解的对吗","like_count":6,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437913,"discussion_content":"1.  是 ，但是也不是“全部放到buffer pool以后”才发，读的时候是一个page 一个page 地读的\n2. 会，好在这个是“某一页”而已，量不大。 好问题\n\n很好的思考","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548731472,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":63959,"user_name":"Long","can_delete":false,"product_type":"c1","uid":1318970,"ip_address":"","ucode":"2417242560360A","user_header":"https://static001.geekbang.org/account/avatar/00/14/20/3a/90db6a24.jpg","comment_is_top":false,"comment_ctime":1548623421,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23023459901","product_id":100020801,"comment_content":"最近没时间看，今天终于补完了几天的课。","like_count":5},{"had_liked":false,"id":68640,"user_name":"Richard","can_delete":false,"product_type":"c1","uid":1302876,"ip_address":"","ucode":"C16AE7CE877DCA","user_header":"https://static001.geekbang.org/account/avatar/00/13/e1/5c/b32f00b1.jpg","comment_is_top":false,"comment_ctime":1550564220,"is_pvip":false,"replies":[{"id":"24390","content":"嗯，这种情况下是可能导致你的客户端应用占用内存过多的。。","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1550571983,"ip_address":"","comment_id":68640,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18730433404","product_id":100020801,"comment_content":"老师好，作为一个java后端开发人员有个疑问，如果对一个大表进行select，如：select * from big_table;<br>用一个List&lt;Object&gt;来接，那么应该是把数据都一次性读入内存了吧，是和上面的全表扫描边读边写的情况不同的吧？也就是我所说的这种操作是可能导致OOM的是吗","like_count":4,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439773,"discussion_content":"嗯，这种情况下是可能导致你的客户端应用占用内存过多的。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550571983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2086624,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/d6/e0/3ccaaa7b.jpg","nickname":"领子","note":"","ucode":"64AC4E6AB74E68","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295121,"discussion_content":"数据库端不会爆，爆的是你java调用端","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1596096004,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1812970,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","nickname":"mgs2002","note":"","ucode":"F5931108BD509B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297093,"discussion_content":"你这种情况跟数据库那边没关系了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596772659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64630,"user_name":"梁中华","can_delete":false,"product_type":"c1","uid":1006789,"ip_address":"","ucode":"52FE40242CBAD0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/c5/1231d633.jpg","comment_is_top":false,"comment_ctime":1548838055,"is_pvip":true,"replies":[{"id":"22879","content":"<br>好几个同学这么说，我都方了😆<br>这句是官方文档上的<br><br>“Accessing a page in the old sublist makes it “young”, moving it to the head of the buffer pool”<br>","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548839597,"ip_address":"","comment_id":64630,"utype":1}],"discussion_count":4,"race_medal":1,"score":"18728707239","product_id":100020801,"comment_content":"感觉young 和old 的叫法反了，后面的应该叫young 才好理解。另外文中的old 区也会有类似young 区域的淘汰策略吧","like_count":4,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438110,"discussion_content":"\n好几个同学这么说，我都方了😆\n这句是官方文档上的\n\n“Accessing a page in the old sublist makes it “young”, moving it to the head of the buffer pool”\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548839597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329618,"discussion_content":"与JVM的堆相反。也许MySQL认为老的才容易去世吧","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1606436427,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018972,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8c/5c/3f164f66.jpg","nickname":"亚林","note":"","ucode":"4A5A6D24314B79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570258,"discussion_content":"和JVM有点类似","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651718554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1098504,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c3/08/28c327d0.jpg","nickname":"冰河时代","note":"","ucode":"F4375FB7CE4FD4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339584,"discussion_content":"我最开始也懵了一哈，后面想是对的，淘汰最老的嘛，所以加到偏 tail 部","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609741003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64162,"user_name":"老杨同志","can_delete":false,"product_type":"c1","uid":1246199,"ip_address":"","ucode":"3F334F0CFD3DE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg","comment_is_top":false,"comment_ctime":1548682470,"is_pvip":false,"replies":[{"id":"22711","content":"👍","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548689925,"ip_address":"","comment_id":64162,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18728551654","product_id":100020801,"comment_content":"老师提示考虑两个客户端都进行update的情况。<br>如果第一个客户端执行select * from t for update 而迟迟不读取返回的数据，会造成server端长期占用记录的行锁，如果其他线程要更新被锁定的记录，会报锁等待超时的错误<br>","like_count":4,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437892,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548689925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64090,"user_name":"700","can_delete":false,"product_type":"c1","uid":1072896,"ip_address":"","ucode":"E4BD0CBADAF951","user_header":"","comment_is_top":false,"comment_ctime":1548664552,"is_pvip":false,"replies":[{"id":"22713","content":"写net_buffer -- &gt; net_buffer满了，调用网络接口发 --&gt;发不出去<br>这个是同一个调用链条呀<br><br>“哪个阶段”没看懂，是同一个时刻","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548690089,"ip_address":"","comment_id":64090,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18728533736","product_id":100020801,"comment_content":"老师，您好。感谢解答。<br>接上个问题。<br>Sending to client 是发生在下面哪个阶段的事件呢？<br>1)是 “获取一行，写到 net_buffer 中。”<br>2)还是“直到 net_buffer 写满，调用网络接口发出去。” &#47;&#47;即数据从 net_buffer 发到 socket send buffer？<br>3)还是“将 socket send buffer 的数据发送给 socket receive buffer”<br><br>从您的回答“但是如果我把net_buffer_length 改成10M，就不会有“Sending to client” 的情况。”，我感觉应该是属于第1)阶段的事件。但感觉这又与您说的“Sending to client 表示的是服务器端的网络栈写满了”相矛盾。","like_count":4,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437853,"discussion_content":"写net_buffer -- &amp;gt; net_buffer满了，调用网络接口发 --&amp;gt;发不出去\n这个是同一个调用链条呀\n\n“哪个阶段”没看懂，是同一个时刻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548690089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1261360,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3f/30/23f6b413.jpg","nickname":"五十九秒","note":"","ucode":"1F34F62193CFF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308690,"discussion_content":"看过几个问答后，对于为什么说多个线程处于Sending to client状态，是因为网络栈满了，但文中却说增加net_buffer的值，可以快速减少Sending to client状态的线程，是不是因为只要执行器把数据都写入net_buffer了，线程就不处于Sending to client的状态了，但这又跟网络栈满了有什么关系，如果这么做只是解决了不使多个线程处于Sending to client状态的问题，并没有解决网络栈满了的问题，这么处理不是自欺欺人吗，心中也感觉比较困惑。\n第一种情况：如果执行器读取完并把把数据写到net_buffer就认为已经是执行完了，即线程不会在处于Sending to client的状态，可能因为数据从net_buffer到socket send buffer是很快的，所以如果网络栈没有写满不会有很多线程处于这个状态，从而推测出如果有多个线程出于Sending to client的状态，是因为网络栈写满了。\n第二种情况：把数据从net_buffer到socket send buffer算是执行完，即线程不会在处于Sending to client的状态,，这种情况如果有多个线程出于Sending to client的状态，肯定是因为网络栈写满了。\n从分析问题的角度看，如果出现了多个线程处于Sending to client的状态，把关注点从Sending to client的状态，转移到瓶颈在哪里，如何降低影响。net_buffer是每个线程独有的内存，写满后很快就能发送到socket send buffer，socket send buffer是公用的，并且空间不大，所以瓶颈最可能在网络栈。而此时增大net_buffer的值目的是让inodb引擎中的操作执行完，释放锁等资源，不对其他的业务造成影响。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1601032049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64037,"user_name":"lochen","can_delete":false,"product_type":"c1","uid":1309747,"ip_address":"","ucode":"CE48502320EAB6","user_header":"https://static001.geekbang.org/account/avatar/00/13/fc/33/dd48f1c5.jpg","comment_is_top":false,"comment_ctime":1548645205,"is_pvip":false,"replies":[{"id":"22650","content":"不正常 <br>执行过程中show processlist和show engine innodb status 看看在干啥","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548655531,"ip_address":"","comment_id":64037,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18728514389","product_id":100020801,"comment_content":"才一百多万条数据 为啥查个总数花了30来秒哦 算正常吗 select count(id) from table;","like_count":4,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437824,"discussion_content":"不正常 \n执行过程中show processlist和show engine innodb status 看看在干啥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548655531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64008,"user_name":"锅子","can_delete":false,"product_type":"c1","uid":1323048,"ip_address":"","ucode":"4A9143AFB07FF2","user_header":"https://static001.geekbang.org/account/avatar/00/14/30/28/6e019a7a.jpg","comment_is_top":false,"comment_ctime":1548640919,"is_pvip":false,"replies":[{"id":"22640","content":"1. 这是一种可能哦，很好的例子<br>2. 其实net_buffer，和 socket send buffer已经是当做缓存来理解了。如果还不够，要把数据都存起来，就怕数据量太大，像我们文中提的200G的数据表扫描，那还是受不了的","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548643359,"ip_address":"","comment_id":64008,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18728510103","product_id":100020801,"comment_content":"老师好，看完这篇文章有两个疑问：<br>1、如果net_buffer设置过小，会不会造成数据页在LRU链表中超过innodb_old_blocks_time的值，降低内存命中率啊？<br>2、MySQL有没有类似缓存的东西，将查询的数据先存起来，而不是直接发送给net_buffer，避免问题1的情况呢？","like_count":4,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437807,"discussion_content":"1. 这是一种可能哦，很好的例子\n2. 其实net_buffer，和 socket send buffer已经是当做缓存来理解了。如果还不够，要把数据都存起来，就怕数据量太大，像我们文中提的200G的数据表扫描，那还是受不了的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548643359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71778,"user_name":"进阶的码农","can_delete":false,"product_type":"c1","uid":1017821,"ip_address":"","ucode":"D8991282640334","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/dd/4f53f95d.jpg","comment_is_top":false,"comment_ctime":1551430763,"is_pvip":false,"replies":[{"id":"25976","content":"你把他们当作两个单独的行为，只是刚好共同同一个文件系统而已","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1551439724,"ip_address":"","comment_id":71778,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14436332651","product_id":100020801,"comment_content":"如果客户端是在主机上呢","like_count":3,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441326,"discussion_content":"你把他们当作两个单独的行为，只是刚好共同同一个文件系统而已","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551439724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64292,"user_name":"Sinyo","can_delete":false,"product_type":"c1","uid":1307297,"ip_address":"","ucode":"57B243E7AB86A5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJAibnPX9jW8kqLcIfibjic8GbkQkEUYyFKJkc39hZhibVlNrqwTjdLozkqibI2IwACd5YzofYickNxFnZg/132","comment_is_top":false,"comment_ctime":1548735835,"is_pvip":false,"replies":[{"id":"22774","content":"还是会显示为“Sending to client”，但是语句已经执行完了。<br>不会占着资源（比如MDL读锁）","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548741010,"ip_address":"","comment_id":64292,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14433637723","product_id":100020801,"comment_content":"@700 的置顶提问 <br>老师你说：&quot;但是如果把 net_buffer_length 改成 10M，就不会有“Sending to client”的情况。虽然网络栈还是慢慢发的，但是那些没发完的都缓存在net_buffer中，对于执行器来说，都是“已经写出去了”。&quot;<br><br>假如数据量有1G，而如果要快速减少处于这个状态的线程的话，我们把net_buffer_length 从10M改成1G，快速减少的那部分操作是不是只有服务端发送到net_buffer的这部分？这样就不会有“Sending to client”的情况么？","like_count":3,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437945,"discussion_content":"还是会显示为“Sending to client”，但是语句已经执行完了。\n不会占着资源（比如MDL读锁）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548741010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64242,"user_name":"Max","can_delete":false,"product_type":"c1","uid":1302420,"ip_address":"","ucode":"E3F1CD8FCB66B3","user_header":"https://static001.geekbang.org/account/avatar/00/13/df/94/84296110.jpg","comment_is_top":false,"comment_ctime":1548725632,"is_pvip":false,"replies":[{"id":"22956","content":"1. 是的，show columns 其实不是一个好操作😄<br>2. 这个没见过，也没印象在社区中碰到这种现象，降成5.6就好了是吗？<br>3. 不会的，34、35两篇就是说这个问题的哈","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548940886,"ip_address":"","comment_id":64242,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14433627520","product_id":100020801,"comment_content":"林Sir,你好。<br>曾经发生过二个问题<br>第一个问题是show columns from table带来的临时表产生和移除<br>大量的session opening tmp tables 和removing tmp tables<br>也kill不掉会话，首先主从先切，让原主停止对外服务。在kill掉所有用户会话。<br>问题解决，同时修改innodb_thread_concurrency参数数量。<br><br>另外一个感觉是mysql bug引起的。<br>当时环境是percona-mysql-20-21主从环境<br>没有高并发所，所有的用户会话状态都是query end，会话不释放。<br>造成会话连接数暴涨。撑满了所有的会话。<br>查看engine innodb status，发现latch等待非常高 <br>OS WAIT ARRAY INFO: signal count 5607657<br>RW-shared spins 0, rounds 2702261, OS waits 70377<br>RW-excl spins 0, rounds 216191633, OS waits 1802414<br>RW-sx spins 1588, rounds 5965, OS waits 70<br><br>Spin rounds per wait: 2702261.00 RW-shared, 216191633.00 RW-excl, 3.76 RW-sx<br>MySQL thread id 79467374, OS thread handle 140327525230336, query id 949505008 10.0.2.6 apirwuser query end<br>INSERT INTO `xxxxxx` (`xxxx`,`xxxx`,`xxxx`,`xxxx`) VALUES (&#39;c2aab326-adf9-470b-940e-133fa2c7f685&#39;,&#39;android&#39;,&#39;862915033153129&#39;,1535597836)<br>---TRANSACTION 1154797559, ACTIVE (PREPARED) 1 sec<br>mysql tables in use 1, locked 1<br><br>第二个问题一直没有解决，后来把mysql 5.7 降到mysql 5.6<br><br>还有一个关于out of memory问题<br>sql如下: a是父表，b是子表<br>select a.id,a.name,b.title from a inner join b on a.id=b.aid <br>where a.create_time&gt;&#39;2010-08-01 00:00:00&#39; and a.create_time&lt;&#39;2010-08-10 23:59:59&#39; <br>它的执行计划应该是<br>1 a表和b表生产迪卡集产生虚列集合T。2从集合T筛选出 a.id(主键)=b.aid(外键)产生虚集合V 3最后从集合v筛选出where条件，得到最终结果。<br>如果二个表都超过千万条记录，产生的集合数据应该是放到内存中。如果是这样会不会打暴内存","like_count":3,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437920,"discussion_content":"1. 是的，show columns 其实不是一个好操作😄\n2. 这个没见过，也没印象在社区中碰到这种现象，降成5.6就好了是吗？\n3. 不会的，34、35两篇就是说这个问题的哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548940886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64033,"user_name":"Zzz","can_delete":false,"product_type":"c1","uid":1116272,"ip_address":"","ucode":"4AA47797F48315","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIu1n1DhUGGKTjelrQaLYOSVK2rsFeia0G8ASTIftib5PTOx4pTqdnfwb0NiaEFGRgS661nINyZx9sUg/132","comment_is_top":false,"comment_ctime":1548644796,"is_pvip":false,"replies":[{"id":"22657","content":"👍<br><br>被你一说我赶紧再去翻了下代码，嗯嗯，InnoDB确实是最近访问的叫做young 😆","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548663288,"ip_address":"","comment_id":64033,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14433546684","product_id":100020801,"comment_content":"改进后的 LRU 算法的思路有点像JVM GC里面分代回收的思想，把数据分成新生代和老年代，一个用于存储短时间内就会被清理的对象，一个用于存储存活时间长的对象。不过有趣的是对于两种区域的叫法，刚好相反：JVM里面把短时间内被清除的区域叫做”young“，InnoDB里面却是叫做”old&quot;。","like_count":3,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437821,"discussion_content":"👍\n\n被你一说我赶紧再去翻了下代码，嗯嗯，InnoDB确实是最近访问的叫做young 😆","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548663288,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":242976,"user_name":"林肯","can_delete":false,"product_type":"c1","uid":1008582,"ip_address":"","ucode":"D2C97220230DE5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/c6/d6ea3df3.jpg","comment_is_top":false,"comment_ctime":1597910032,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10187844624","product_id":100020801,"comment_content":"改良后的LRU算法和JVM的垃圾回收机制有异曲同工之妙，很多算法都是相通的啊","like_count":2},{"had_liked":false,"id":64352,"user_name":"牧鱼","can_delete":false,"product_type":"c1","uid":1360250,"ip_address":"","ucode":"0EB8FDD7A4BB2E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erFY9H3mxyTpZ9gxAmdeKic565hicicDZmv7cjswd8hdernmxib0chdQrlDNKUZQ8AticQCgDdgVEmJNuA/132","comment_is_top":false,"comment_ctime":1548751278,"is_pvip":false,"replies":[{"id":"22783","content":"看一下20和21篇哈","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548752503,"ip_address":"","comment_id":64352,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10138685870","product_id":100020801,"comment_content":"老师好，咨询一个于之前文章有关的问题，在rr隔离级别下会产生幻读，然而这个幻读mysql是通过什么机制来解决的呢？有的说是mvcc，有的说是next-key锁。有点疑惑了。另外，怎么能够验证mysql使用具体的哪种技术解决了幻读？","like_count":2,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437969,"discussion_content":"看一下20和21篇哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548752503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1466840,"avatar":"https://static001.geekbang.org/account/avatar/00/16/61/d8/3bc19bff.jpg","nickname":"恋在那时","note":"","ucode":"7F026B4B708C7D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555657,"discussion_content":"innodb通过引入间隙锁来解决了幻读问题，在rr级别下，只有当前读才会发生幻读现象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647008266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64296,"user_name":"天使梦泪","can_delete":false,"product_type":"c1","uid":1235750,"ip_address":"","ucode":"782991747DD424","user_header":"https://static001.geekbang.org/account/avatar/00/12/db/26/3c8d68fb.jpg","comment_is_top":false,"comment_ctime":1548736720,"is_pvip":false,"replies":[{"id":"22773","content":"InnoDB 的是buffer pool，是在内存里。<br><br>”内存重启了之后，缓存不就也丢失了，是怎么做到持久化保存的，老师可以帮忙详细解答下么？“<br>没有保存，重启就没有了，要访问的时候需要重新去磁盘读","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548740885,"ip_address":"","comment_id":64296,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10138671312","product_id":100020801,"comment_content":"老师好，针对我上次问您的mysql缓存中的数据储存问题，您回答可以一直保存的，具体是怎么实现一直保存的（也不是储存在磁盘上，是使用的内存）？内存重启了之后，缓存不就也丢失了，是怎么做到持久化保存的，老师可以帮忙详细解答下么？<br>","like_count":2,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437948,"discussion_content":"InnoDB 的是buffer pool，是在内存里。\n\n”内存重启了之后，缓存不就也丢失了，是怎么做到持久化保存的，老师可以帮忙详细解答下么？“\n没有保存，重启就没有了，要访问的时候需要重新去磁盘读","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548740885,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64259,"user_name":"有铭","can_delete":false,"product_type":"c1","uid":1046302,"ip_address":"","ucode":"2C7CB36CA5C04C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3XbCueYYVWTiclv8T5tFpwiblOxLphvSZxL4ujMdqVMibZnOiaFK2C5nKRGv407iaAsrI0CDICYVQJtiaITzkjfjbvrQ/132","comment_is_top":false,"comment_ctime":1548727786,"is_pvip":false,"replies":[{"id":"22759","content":"看一下 https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;73479 这篇文章的图5哈<br>有说到哦","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548731904,"ip_address":"","comment_id":64259,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10138662378","product_id":100020801,"comment_content":"感觉mysql的做法有点流式读取的意思。<br>但是，老师，虽然这篇文章讲述了Mysql是如何“边读边发”。但是更复杂的情况没有说明，比如我现在要执行一个复杂的查询，而且查询是排序的，这意味着mysql需要对整个结构排序，然后才能一条条的发出去，如果数据量极大的情况，Mysql如何完成排序过程，需要把数据全部载入内存吗？还是存储在缓存文件里搞分而治之的排序，然后再“边读边发”","like_count":2,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437926,"discussion_content":"看一下 https://time.geekbang.org/column/article/73479 这篇文章的图5哈\n有说到哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548731904,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64045,"user_name":"garming","can_delete":false,"product_type":"c1","uid":1023526,"ip_address":"","ucode":"529F405DD13F43","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9e/26/7aede07e.jpg","comment_is_top":false,"comment_ctime":1548646564,"is_pvip":false,"replies":[{"id":"22651","content":"也是不会的，跟InnoDB一样","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548655547,"ip_address":"","comment_id":64045,"utype":1}],"discussion_count":1,"race_medal":1,"score":"10138581156","product_id":100020801,"comment_content":"老师你好，如果是MyISAM存储引擎，大查询会导致内存暴涨吗？如果过，是什么原因呢？","like_count":2,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437829,"discussion_content":"也是不会的，跟InnoDB一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548655547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64043,"user_name":"杜嘉嘉","can_delete":false,"product_type":"c1","uid":1306430,"ip_address":"","ucode":"C23DE27E7886BD","user_header":"https://static001.geekbang.org/account/avatar/00/13/ef/3e/9c3a8abc.jpg","comment_is_top":false,"comment_ctime":1548646344,"is_pvip":false,"replies":[{"id":"22653","content":"不会专门讲一个工具哈，<br>可以说下你碰到的问题，然后我在答疑文章中展开，这样比较好哦","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548655661,"ip_address":"","comment_id":64043,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10138580936","product_id":100020801,"comment_content":"收获很大，老师的课程一直很用心。想问下后续会不会单独讲备份恢复章节，比如xtrabackup这种","like_count":2,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437827,"discussion_content":"不会专门讲一个工具哈，\n可以说下你碰到的问题，然后我在答疑文章中展开，这样比较好哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548655661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246548,"user_name":"Anthony","can_delete":false,"product_type":"c1","uid":1309908,"ip_address":"","ucode":"9E0C98A9123365","user_header":"https://static001.geekbang.org/account/avatar/00/13/fc/d4/743d3f02.jpg","comment_is_top":false,"comment_ctime":1599398977,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5894366273","product_id":100020801,"comment_content":"<br>老师，如果使用了change buffer,那更新一条非主键索引数据，数据写入了change buffer,是否会将这条更新写入到binlog中呢？如果是更新了binlog, binlog是使用了row格式，需要知道当前这条数据的值，而这条值又不在内存中，只能读磁盘；如果是不更新，主从又怎么做到同步呢？盼复！","like_count":1},{"had_liked":false,"id":237834,"user_name":"李飞","can_delete":false,"product_type":"c1","uid":1555180,"ip_address":"","ucode":"930458850AA05B","user_header":"https://static001.geekbang.org/account/avatar/00/17/ba/ec/2b1c6afc.jpg","comment_is_top":false,"comment_ctime":1595984527,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5890951823","product_id":100020801,"comment_content":"作为一个开发人员，感觉每节课都值得二刷","like_count":1,"discussions":[{"author":{"id":1812970,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","nickname":"mgs2002","note":"","ucode":"F5931108BD509B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297148,"discussion_content":"是的，我现在才一刷，感觉很多理解不透，必须要二刷重温","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596787691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102928,"user_name":"Jzzw","can_delete":false,"product_type":"c1","uid":1508208,"ip_address":"","ucode":"4B642AADF48BD6","user_header":"https://static001.geekbang.org/account/avatar/00/17/03/70/01dc4853.jpg","comment_is_top":false,"comment_ctime":1560330008,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5855297304","product_id":100020801,"comment_content":"老师，看官方文档上说，net_buffer如果写入数据量达到net_buffer_length的话，其大小会继续扩大到max_allowed_packet，sql执行结束后再收缩到net_buffer_length的大小","like_count":1,"discussions":[{"author":{"id":1368901,"avatar":"","nickname":"miu","note":"","ucode":"3D73FF3C09231A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":135102,"discussion_content":"也很疑惑，官方文档中net_buffer_length的值最大只能设置到1M，如何能够设置到10M，并且max_allowed_packet的值最大1G","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579068290,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":69064,"user_name":"700","can_delete":false,"product_type":"c1","uid":1072896,"ip_address":"","ucode":"E4BD0CBADAF951","user_header":"","comment_is_top":false,"comment_ctime":1550654907,"is_pvip":false,"replies":[{"id":"24493","content":"查询过程中不能用mysql_reset_connection 来释放内存，都还没执行完成呢。<br><br>是c的api，https:&#47;&#47;dev.mysql.com&#47;doc&#47;refman&#47;5.7&#47;en&#47;c-api-functions.html","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1550659635,"ip_address":"","comment_id":69064,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5845622203","product_id":100020801,"comment_content":"老师，那这个问题可以通过你介绍的函数 mysql_reset_connection 来释放连接的内存吗？这个函数是怎么使用的？","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439940,"discussion_content":"查询过程中不能用mysql_reset_connection 来释放内存，都还没执行完成呢。\n\n是c的api，https://dev.mysql.com/doc/refman/5.7/en/c-api-functions.html","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550659635,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":66876,"user_name":"700","can_delete":false,"product_type":"c1","uid":1072896,"ip_address":"","ucode":"E4BD0CBADAF951","user_header":"","comment_is_top":false,"comment_ctime":1550033738,"is_pvip":false,"replies":[{"id":"23990","content":"其他内存一般是使用的时候才申请，不用就销毁了<br><br>你这个实例的状态不太合理，你贴一下这个进程的top 结果看下？还有这几个内存参数的配置。<br>250个线程27G是太多了~","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1550297303,"ip_address":"","comment_id":66876,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5845001034","product_id":100020801,"comment_content":"老师，您好。请教 MySQL 使用的内存是一开始就根据参数设置直接分配好，还是在使用的过程中根据实际情况用多少分配多少的？<br><br>下面的分类对吗？还有没有补充的？<br>共享内存（类似于Oracle 的 SGA）<br>key_buffer_size、query_cache_size、innodb_buffer_pool_size、innodb_log_buffer_size<br><br>线程内存（类似于Oracle的 PGA）<br>binlog_cache_size、join_buffer_size、read_buffer_size、read_rnd_buffer_size、sort_buffer_size、tmp_table_size、thread_stack、net_buffer_length、max_allowed_packet<br><br>目前线上环境遇到这么个情况，机器总内存125GB，分给 innodb_buffer_pool_size 84GB，连接数大概250个。从 top 命令来看，mysqld 用了 111.9GB。其他27.9GB是给线程内存占用了？<br>","like_count":2,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438954,"discussion_content":"其他内存一般是使用的时候才申请，不用就销毁了\n\n你这个实例的状态不太合理，你贴一下这个进程的top 结果看下？还有这几个内存参数的配置。\n250个线程27G是太多了~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550297303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65012,"user_name":"Mr.Strive.Z.H.L","can_delete":false,"product_type":"c1","uid":1030198,"ip_address":"","ucode":"6D97E159E2EECD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b8/36/542c96bf.jpg","comment_is_top":false,"comment_ctime":1549001066,"is_pvip":false,"replies":[{"id":"23042","content":"好问题👍，第40篇会说这个问题哈，新年快乐","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1549008615,"ip_address":"","comment_id":65012,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5843968362","product_id":100020801,"comment_content":"老师您好：<br>我看到评论的问题，有个疑惑：<br>“<br>之前有特殊功能需要从主要业务库拉取指定范围的数据到另外同一个库的其他数据表的动作（insert into xxxxx select xxx from xxx 这种操作）数据量在万级或者十万级，对于这种操作，和本文讲的应该有些不同吧？能否帮分析一下这种场景的大致情况呢？或者有什么好的建议吗？<br><br>作者回复: 嗯，这个不会返回结果到客户端，所以网络上不会有问题<br><br>引擎内部的扫描机制是差不多的<br><br>唯一不同是这个过程可能对原表有行锁（如果设置的是RR）<br><br>万或者十万还好，是小数据，可以考虑拿到客户端再写回去，避免锁的问题<br>”<br><br>先把数据拿回客户端，再insert到另一个库。是为了避免锁的问题。<br>这里从原库拉取数据就是select语句，没有涉及到next-key锁呀，为啥会有锁的问题呢？","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438273,"discussion_content":"好问题👍，第40篇会说这个问题哈，新年快乐","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549008615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64031,"user_name":"库淘淘","can_delete":false,"product_type":"c1","uid":1310240,"ip_address":"","ucode":"90813B0C46E978","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqibSwKPg7hiapc49qoM4dibhM3fYANPjfltF2ibBZ3dHX2hibjg5EIIcziahrmjO5R2XrcRibvU39TQS7jg/132","comment_is_top":false,"comment_ctime":1548644349,"is_pvip":false,"replies":[{"id":"22658","content":"服务端没问题，这个还算是好消息吧😆","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548663341,"ip_address":"","comment_id":64031,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5843611645","product_id":100020801,"comment_content":"那客户端不用-q 使用mysql_store_result 这样的话查询20G数据,是不是就导致客户端内存溢出,而服务器端没问题？","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437820,"discussion_content":"服务端没问题，这个还算是好消息吧😆","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548663341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":63982,"user_name":"柚子","can_delete":false,"product_type":"c1","uid":1002136,"ip_address":"","ucode":"7641A699DA0CFD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/NhbRicjvf8v3K6D3v1FtOicxOciaPZQsCjCmuGCqea4vJeRVaLicKLpAcFQlcTgLvczBWY7SYDkeOtibxXj1PGl7Nug/132","comment_is_top":false,"comment_ctime":1548636880,"is_pvip":true,"replies":[{"id":"22643","content":"嗯，你这个说的是端连接问题<br><br>跟我们这篇文章说的问题不是同一个，不过也确实是挺常见的，客户端没设计好导致的服务端问题😆","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548643828,"ip_address":"","comment_id":63982,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5843604176","product_id":100020801,"comment_content":"回答问题，很low的一种情况，客户端连接没有使用单例，每次请求都会重新建立连接。","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437793,"discussion_content":"嗯，你这个说的是端连接问题\n\n跟我们这篇文章说的问题不是同一个，不过也确实是挺常见的，客户端没设计好导致的服务端问题😆","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548643828,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":178543,"discussion_content":"系统程序层面，使用连接池。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582172570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344666,"user_name":"亚林","can_delete":false,"product_type":"c1","uid":1018972,"ip_address":"","ucode":"4A5A6D24314B79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/5c/3f164f66.jpg","comment_is_top":false,"comment_ctime":1651717028,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651717028","product_id":100020801,"comment_content":"MySQL8没有图3和图4的问题","like_count":0},{"had_liked":false,"id":342307,"user_name":"宁次君","can_delete":false,"product_type":"c1","uid":1475979,"ip_address":"","ucode":"F1DD0B189C5856","user_header":"https://static001.geekbang.org/account/avatar/00/16/85/8b/dd7ecd53.jpg","comment_is_top":false,"comment_ctime":1650183602,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650183602","product_id":100020801,"comment_content":"做大查询时，由于net_buffer_length限制了数据发送的大小（服务端发给客户端），当客户端未来得及接收数据时，服务端会进入等待状态，所以大查询占用的内存是net_buffer_length实际的大小。net_buffer_length是每个线程分配一个，当并发大查询时多个线程的net_buffer_length同时占有内存，仍会可能出现oom的情况吧，这样理解正确吗","like_count":1},{"had_liked":false,"id":327448,"user_name":"zhoubo_eric","can_delete":false,"product_type":"c1","uid":1584208,"ip_address":"","ucode":"34725AA3A9D59C","user_header":"https://static001.geekbang.org/account/avatar/00/18/2c/50/64365ef7.jpg","comment_is_top":false,"comment_ctime":1640138196,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640138196","product_id":100020801,"comment_content":"提炼下<br><br>mysql client 读取本地socket receive buffer—》mysql server socket send buffer-〉 mysql net_buffer_length<br> <br><br> mysql_store_result接口可用于数据结果返回不多的 因为存储到本地加速了读取<br><br>mysql_use_result是边读边发边清理 所以用于数据量返回比较多的合适 <br><br><br>innodb的lru淘汰机制是通过区分 young和old的区域，最近被访问的放到young区的head range，空间不够从tail侧淘汰.为了避免全表扫描把所有head的空间占满造成命中率降低，设置了一个逻辑 就是对于第一次需要次磁盘读的page都x放到old区域，接下来再次需要读取该page的话如果 page页面两次读取间隔超过1s中那么放到head区域（说明数据还有再次访问的需要，需要频繁读取）剩下那些page 因为只做了一次磁盘读，都没有机会再次被内存读的机会 自然会根据随着上面的淘汰机制逐渐移到tail区域 最终被淘汰掉","like_count":0},{"had_liked":false,"id":317359,"user_name":"特立独行的猪","can_delete":false,"product_type":"c1","uid":1465344,"ip_address":"","ucode":"1440F96375740A","user_header":"https://static001.geekbang.org/account/avatar/00/16/5c/00/5d11e68d.jpg","comment_is_top":false,"comment_ctime":1634770137,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634770137","product_id":100020801,"comment_content":"文中提到“由于有 WAL 机制，当事务提交的时候，磁盘上的数据页是旧的，那如果这时候马上有一个查询要来读这个数据页，是不是要马上把 redo log 应用到数据页呢？”-答案是不需要，直接从内存返回。我的疑问是，如果这个事务是update操作，而update的这张数据页不存在内存中，是先记录到change  buffer中，当下一个事务比如select全表时，难道不会把磁盘的数据页读入内存，去执行merge操作后，在返回给客户端嘛？？？","like_count":0},{"had_liked":false,"id":316914,"user_name":"Geek_99ae14","can_delete":false,"product_type":"c1","uid":1909732,"ip_address":"","ucode":"268852986A6B69","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLY0FFoux40Negib6LrE7EwT3T2BUbpYzOzUeiaiaXBmNGDGVgIZr5NeWBTEeCuALOg3ODtWa21bHMgg/132","comment_is_top":false,"comment_ctime":1634610543,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634610543","product_id":100020801,"comment_content":"每次重新看一遍都收获满满","like_count":0},{"had_liked":false,"id":309071,"user_name":"Allen","can_delete":false,"product_type":"c1","uid":1100387,"ip_address":"","ucode":"5B168A03809557","user_header":"https://static001.geekbang.org/account/avatar/00/10/ca/63/9be9ac89.jpg","comment_is_top":false,"comment_ctime":1629933183,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629933183","product_id":100020801,"comment_content":"发现mysql的LRU和caffeine的LRU很类似，果然原理都是相通的","like_count":0},{"had_liked":false,"id":298674,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1624257874,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624257874","product_id":100020801,"comment_content":"老师，为啥每次访问少于1秒的位置不变，每次访问少于一秒更说明这个数据页使用频繁啊，应该移动到young区才对啊。","like_count":0},{"had_liked":false,"id":294896,"user_name":"大漠","can_delete":false,"product_type":"c1","uid":1124461,"ip_address":"","ucode":"B7973B9FD7CB61","user_header":"https://static001.geekbang.org/account/avatar/00/11/28/6d/d776d35a.jpg","comment_is_top":false,"comment_ctime":1622124942,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622124942","product_id":100020801,"comment_content":"InnoDB Buffer Pool 的 LRU 分区算法很有借鉴意义","like_count":0},{"had_liked":false,"id":292336,"user_name":"uking","can_delete":false,"product_type":"c1","uid":1522824,"ip_address":"","ucode":"41005AC547327B","user_header":"https://static001.geekbang.org/account/avatar/00/17/3c/88/e83528da.jpg","comment_is_top":false,"comment_ctime":1620785775,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620785775","product_id":100020801,"comment_content":"net_buffer按文中的描述来看，感觉像是全局共享的，那如何区分不同的数据发给不同的客户端呢？","like_count":0},{"had_liked":false,"id":275957,"user_name":"枫中浪子","can_delete":false,"product_type":"c1","uid":2351949,"ip_address":"","ucode":"860BEA32059B37","user_header":"https://static001.geekbang.org/account/avatar/00/23/e3/4d/8a26dbb2.jpg","comment_is_top":false,"comment_ctime":1611729866,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611729866","product_id":100020801,"comment_content":"innodb_buffer_pool_size的大小好像跟innodb_buffer_pool_chunk_size和innodb_buffer_pool_instances有关，老师能不能讲下后面两个。","like_count":0},{"had_liked":false,"id":271674,"user_name":"Sun.YuLong","can_delete":false,"product_type":"c1","uid":1127696,"ip_address":"","ucode":"AFFC9072A41A26","user_header":"https://static001.geekbang.org/account/avatar/00/11/35/10/2a6e4cb5.jpg","comment_is_top":false,"comment_ctime":1609753299,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609753299","product_id":100020801,"comment_content":"“扫描过程中，需要新插入的数据页，都被放到 old 区域 ;”<br>老师，这点不明白，新插入的不应该在young么？","like_count":0},{"had_liked":false,"id":259742,"user_name":"hao","can_delete":false,"product_type":"c1","uid":1148845,"ip_address":"","ucode":"997F2B57E2F556","user_header":"https://static001.geekbang.org/account/avatar/00/11/87/ad/50a85a04.jpg","comment_is_top":false,"comment_ctime":1604823619,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604823619","product_id":100020801,"comment_content":"当下大多数的业务场景属于多读写少，避免全表扫描覆盖掉 真·热点数据<br>mysql lru优化策略 访问yong区时用经典的lru算法  访问old区时先判断数据存活时间再晋升到yong区<br>redis lru优化策略   在redisobject对象上 设置存活时间和引用次数（增加，衰退）","like_count":0},{"had_liked":false,"id":254301,"user_name":"咖啡","can_delete":false,"product_type":"c1","uid":1413645,"ip_address":"","ucode":"7A6AE43700CC8F","user_header":"https://static001.geekbang.org/account/avatar/00/15/92/0d/909f9aab.jpg","comment_is_top":false,"comment_ctime":1603098278,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603098278","product_id":100020801,"comment_content":"请问下老师，为什么内存淘汰机制普遍使用LRU呢？","like_count":0},{"had_liked":false,"id":244128,"user_name":"听风来","can_delete":false,"product_type":"c1","uid":1422123,"ip_address":"","ucode":"DBB646BFA8BFA0","user_header":"","comment_is_top":false,"comment_ctime":1598407132,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598407132","product_id":100020801,"comment_content":"使用kettle，查询本地数据库某个表id，用id去另一个数据库查询数据，随后将查出数据落到本地数据库。本地数据库一直是sending to client状态，最后导致wait timeout，jvm满负载。这个问题出现原因我考虑应该主要在jvm，随后将数据库wait timeout由300s调大。老师这个处理可否","like_count":0},{"had_liked":false,"id":243074,"user_name":"H","can_delete":false,"product_type":"c1","uid":1793962,"ip_address":"","ucode":"04D7D030245E27","user_header":"https://static001.geekbang.org/account/avatar/00/1b/5f/aa/63e641c1.jpg","comment_is_top":false,"comment_ctime":1597939751,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597939751","product_id":100020801,"comment_content":"show engine innodb status一直没找到buffer_pool_hit_rate","like_count":0},{"had_liked":false,"id":238413,"user_name":"含章","can_delete":false,"product_type":"c1","uid":1434831,"ip_address":"","ucode":"A7CA116D5275C9","user_header":"https://static001.geekbang.org/account/avatar/00/15/e4/cf/906f47c9.jpg","comment_is_top":false,"comment_ctime":1596162548,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1596162548","product_id":100020801,"comment_content":"现在，林老师还看吗😂？一直有个问题！  内存大小8G，bufferpool设置20G，依然可以正常启动。这个参数会自动调节吗？那如果默认设置128M，又会怎样呢？<br>","like_count":0},{"had_liked":false,"id":233195,"user_name":"原军","can_delete":false,"product_type":"c1","uid":1016202,"ip_address":"","ucode":"003C988716FBCC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/81/8a/0b065758.jpg","comment_is_top":false,"comment_ctime":1594257689,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594257689","product_id":100020801,"comment_content":"老师好，之前有看过好多文章描述，设置innodb_buffer_pool_size之后，最好也手动修改下innobd_buffer_pool_instances，来增加buffer pool的数量从而提升性能，那instances到底需不需要手动指定数量？希望老师能帮忙解答下。","like_count":0},{"had_liked":false,"id":232925,"user_name":"jugg","can_delete":false,"product_type":"c1","uid":1639286,"ip_address":"","ucode":"3CD779C93609CF","user_header":"https://static001.geekbang.org/account/avatar/00/19/03/76/55df3b09.jpg","comment_is_top":false,"comment_ctime":1594170316,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594170316","product_id":100020801,"comment_content":"mysql client server 连接似乎是没有 应用层心跳。如果一个慢客户端宕机后，server 需要8小时才能检测到？","like_count":0},{"had_liked":false,"id":220212,"user_name":"张钟强","can_delete":false,"product_type":"c1","uid":1586908,"ip_address":"","ucode":"EE0D5CAEDBBAC8","user_header":"https://static001.geekbang.org/account/avatar/00/18/36/dc/97369381.jpg","comment_is_top":false,"comment_ctime":1590204716,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590204716","product_id":100020801,"comment_content":"老师，您好。<br>1. 如果我只是select部分字段，buffer pool中缓存的是完整的数据页吗？如果是的话，innodb会对的读取到的完整数据进行过滤然后返回给server层？<br>2. 像select count(1)这种还会将数据页读入到，buffer pool中？","like_count":0},{"had_liked":false,"id":205881,"user_name":"Kvicii.Y","can_delete":false,"product_type":"c1","uid":1442588,"ip_address":"","ucode":"446BFA633569EA","user_header":"https://static001.geekbang.org/account/avatar/00/16/03/1c/c9fe6738.jpg","comment_is_top":false,"comment_ctime":1586750398,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586750398","product_id":100020801,"comment_content":"如果超过了在3&#47;8头部的数据页存在时间超过了1s移动到了前5&#47;8，那么5&#47;8的尾部是怎么淘汰的？降级到3&#47;8？还是直接淘汰掉？","like_count":0},{"had_liked":false,"id":199807,"user_name":"风雪夜归人","can_delete":false,"product_type":"c1","uid":1583347,"ip_address":"","ucode":"40B4C6DB4351EB","user_header":"https://static001.geekbang.org/account/avatar/00/18/28/f3/103b5bec.jpg","comment_is_top":false,"comment_ctime":1585496218,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585496218","product_id":100020801,"comment_content":"打卡打卡","like_count":0},{"had_liked":false,"id":179100,"user_name":"陆丕山","can_delete":false,"product_type":"c1","uid":1814215,"ip_address":"","ucode":"DC82F5CED5B7FF","user_header":"https://static001.geekbang.org/account/avatar/00/1b/ae/c7/47631b20.jpg","comment_is_top":false,"comment_ctime":1581914565,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581914565","product_id":100020801,"comment_content":"老师你好，测试环境登录的时候总是很慢，uat和正式环境没问题。看了show proocesslist以后，发现是有个查询语句总是处于warting to net状态，而且时间很长。由于测试环境的数据库配置很垃圾，所有的项目用的都是这个服务器的数据库，我猜应该是网络占用的原因。请问下，会不会是其他原因或还有其他原因呢？","like_count":0},{"had_liked":false,"id":175355,"user_name":"华融科技","can_delete":false,"product_type":"c1","uid":1808280,"ip_address":"","ucode":"B6BA3C47C05073","user_header":"","comment_is_top":false,"comment_ctime":1580689081,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580689081","product_id":100020801,"comment_content":"老师，你好。 <br>关于问题“如果一个事务被 kill 之后，持续处于回滚状态，从恢复速度的角度看，你是应该重启等它执行结束，还是应该强行重启整个 MySQL 进程。”<br>方案：先做主备切换，切到新主库提供服务。 如果主库上有事务回滚没做完：<br>1. 可能切不过去，因为seconds behind master 可能过大。<br>2. 强切过去后，主库还有事务回滚，会导致两边数据不一致。这具体是怎么操作的？请老师指教。谢谢！<br>","like_count":0},{"had_liked":false,"id":174368,"user_name":"Zhaoyang","can_delete":false,"product_type":"c1","uid":1037190,"ip_address":"","ucode":"131D83AC2566D2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d3/86/b5d72c87.jpg","comment_is_top":false,"comment_ctime":1580181909,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580181909","product_id":100020801,"comment_content":"明白了innodb的最近最少使用策略：并不是全部替换，而是5&#47;8的比例才替换的，这样的话，能避免极端的效率低的情况。","like_count":0},{"had_liked":false,"id":169450,"user_name":"Apologize","can_delete":false,"product_type":"c1","uid":1503320,"ip_address":"","ucode":"F2F179241EDA4F","user_header":"https://static001.geekbang.org/account/avatar/00/16/f0/58/87104eab.jpg","comment_is_top":false,"comment_ctime":1578359320,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578359320","product_id":100020801,"comment_content":"大查询会不会把客户端内存撑爆？","like_count":0},{"had_liked":false,"id":165876,"user_name":"Anthony","can_delete":false,"product_type":"c1","uid":1309908,"ip_address":"","ucode":"9E0C98A9123365","user_header":"https://static001.geekbang.org/account/avatar/00/13/fc/d4/743d3f02.jpg","comment_is_top":false,"comment_ctime":1577337676,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577337676","product_id":100020801,"comment_content":"老师，我又一个疑问，如果将冷数据全表扫描，那是不是最后一批进buffer_pool的数据也会由old区域移到young区域，影响查询的缓存命中率呢？","like_count":0},{"had_liked":false,"id":153891,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1574326549,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574326549","product_id":100020801,"comment_content":"缓存真是个好东西，用的好大大提高了效率。","like_count":0},{"had_liked":false,"id":144169,"user_name":"天王","can_delete":false,"product_type":"c1","uid":1239337,"ip_address":"","ucode":"C074B2F9A5F007","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/29/629d9bb0.jpg","comment_is_top":false,"comment_ctime":1571874517,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1571874517","product_id":100020801,"comment_content":"33 全表扫描，会不会把内存撑爆 1 全表扫描，对server层的影响，server层把读到的一行行数据放到net_buffer，16k大小直到写满，调用网络接口发送到客户端，处理的线程处于sending to client的状态，2 全表扫描 对innodb的影响，2.1 WAL机制，innodb内存是用BP即buffer pool管理的，配合redo log，能避免随机写盘，也能加速查询，2.2 BP管理内存用的是改进后的LRU算法，前面是young区域，后面是old区域。young区域和old的比例是5比3，扫描的过程中，如果数据在young区域则把数据移到young区域的头部，如果在old区域，看下这个数据页在链表中存在的时间是否超过一秒，一秒以内位置不变，超过一秒会移到链表头部即young区域头部。新插入的数据在old区域头部，除非被二次访问，否则会被逐渐淘汰到尾部，淘汰出去。young区域保证了常访问数据的命中率。","like_count":0,"discussions":[{"author":{"id":1794060,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/60/0c/e1f012cb.jpg","nickname":"frankie","note":"","ucode":"813D1352B68A21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302675,"discussion_content":"有没有可能old区域的页从old头部淘汰到最后的时候 这个时间超过1秒呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599007872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143808,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1571794474,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571794474","product_id":100020801,"comment_content":"一点理解：单次查询的数据无法一次性全部放入  net_buffer 中，需要多次通过 net_buffer 中转处理，Sending to client 的状态才会显著出现。如果客户端处理的很慢，那 socket send buffer 发送处理慢，没办法快速取 net_buffer 的数据，net_buffer 中转处理时间就更长了，Sending to client 的状态持续更久。","like_count":0},{"had_liked":false,"id":142596,"user_name":"涅槃666","can_delete":false,"product_type":"c1","uid":1003405,"ip_address":"","ucode":"8E37DF3861AF81","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJtyy6XYfNM6kZ0c1FUu6KL0hQLlwwAko7RwCz16j4PnnGtnOJVvDKO2iajdJ3Jer8verf1AiaAyzHA/132","comment_is_top":false,"comment_ctime":1571408943,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571408943","product_id":100020801,"comment_content":"老师，你好，能说下分页的原理吗","like_count":0},{"had_liked":false,"id":135729,"user_name":"李鑫磊","can_delete":false,"product_type":"c1","uid":1101615,"ip_address":"","ucode":"D06517CFCEEE00","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/2f/4f89f22a.jpg","comment_is_top":false,"comment_ctime":1569248177,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1569248177","product_id":100020801,"comment_content":"请教老师一个问题，内存中的数据页是在 Server 层还是在 InnoDB？","like_count":0,"discussions":[{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":178542,"discussion_content":"innodb","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582172421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130948,"user_name":"渡劫达摩","can_delete":false,"product_type":"c1","uid":1465391,"ip_address":"","ucode":"A7005CBB34B698","user_header":"https://static001.geekbang.org/account/avatar/00/16/5c/2f/a9c8d42f.jpg","comment_is_top":false,"comment_ctime":1567582150,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567582150","product_id":100020801,"comment_content":"老师，当我用jdbc去权标查询的时候，会爆内存溢出，因为数据太多了。但是依照你上面的说法，它不是一批一批的返回数据吗。为什么我最受接受的list的数据量和全表的数据量是一样，最后我使用了流式查询，才逼避免了内存溢出。是不是不使用jdbc封装的流式读取，就不会是一批一批的返回数据","like_count":0},{"had_liked":false,"id":130297,"user_name":"MrVito","can_delete":false,"product_type":"c1","uid":1252169,"ip_address":"","ucode":"716FF6F8871706","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/49/ddefc656.jpg","comment_is_top":false,"comment_ctime":1567419925,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567419925","product_id":100020801,"comment_content":"原来LRU缓存淘汰策略在buffer pool也有使用，我也实现过LRU，看来这个真的是必备技能呀！","like_count":0},{"had_liked":false,"id":118714,"user_name":"飞翔","can_delete":false,"product_type":"c1","uid":1068571,"ip_address":"","ucode":"65AF6AF292DAD6","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/1b/f4b786b9.jpg","comment_is_top":false,"comment_ctime":1564423520,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1564423520","product_id":100020801,"comment_content":"为什么这样写 this.preparedStatement.executeQuery() 不会爆内存呀，this.sql是全表查询语句<br>protected void openCursor(Connection con) {<br>        try {<br>            if (this.isUseSharedExtendedConnection()) {<br>                this.preparedStatement = con.prepareStatement(this.sql, 1003, 1007, 1);<br>            } else {<br>                this.preparedStatement = con.prepareStatement(this.sql, 1003, 1007);<br>            }<br><br>            this.applyStatementSettings(this.preparedStatement);<br>            if (this.preparedStatementSetter != null) {<br>                this.preparedStatementSetter.setValues(this.preparedStatement);<br>            }<br><br>            this.rs = this.preparedStatement.executeQuery();<br>            this.handleWarnings(this.preparedStatement);<br>        } catch (SQLException var3) {<br>            this.close();<br>            throw this.getExceptionTranslator().translate(&quot;Executing query&quot;, this.getSql(), var3);<br>        }<br>    }","like_count":0},{"had_liked":false,"id":109923,"user_name":"thomas","can_delete":false,"product_type":"c1","uid":1016777,"ip_address":"","ucode":"9AB945308F1B50","user_header":"https://static001.geekbang.org/account/avatar/00/0f/83/c9/5d03981a.jpg","comment_is_top":false,"comment_ctime":1562134115,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1562134115","product_id":100020801,"comment_content":"老师你说：”查询语句由于没有其他的判断条件，所以查到的每一行都可以直接放到结果集“，若加上其他判断条件的话，为什么就不能放到结果集呢？","like_count":0},{"had_liked":false,"id":103975,"user_name":"hal","can_delete":false,"product_type":"c1","uid":1359844,"ip_address":"","ucode":"98E625F7327FD9","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/e4/45758517.jpg","comment_is_top":false,"comment_ctime":1560579159,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560579159","product_id":100020801,"comment_content":"老师，你好，文中说innodb内存管理使用LRU算法，使用链表实现，我想问一下：一个查询，或者请求吧，怎么找到这个已经在链表中的页，因为这个链表可能还会随时变动(新老交替)","like_count":0},{"had_liked":false,"id":97868,"user_name":"乔纳森","can_delete":false,"product_type":"c1","uid":1045107,"ip_address":"","ucode":"51EC9FAE071388","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f2/73/1c7bceae.jpg","comment_is_top":false,"comment_ctime":1558799476,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1558799476","product_id":100020801,"comment_content":"大表聚合呢？如 group by，放在磁盘临时表中聚合？磁盘空间多大呢？","like_count":0},{"had_liked":false,"id":68102,"user_name":"700","can_delete":false,"product_type":"c1","uid":1072896,"ip_address":"","ucode":"E4BD0CBADAF951","user_header":"","comment_is_top":false,"comment_ctime":1550413014,"is_pvip":false,"replies":[{"id":"24270","content":"这样确实看不出来😅","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1550539071,"ip_address":"","comment_id":68102,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1550413014","product_id":100020801,"comment_content":"老师您好，接我上个问题。您要的信息如下：<br><br>top 命令<br>   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                 <br>144369 mysql     20   0  132.1g 111.8g   6712 S 101.0 88.9  19261:21 mysqld                                                                                  <br>161455 root      20   0  162500   2836   1584 R   0.7  0.0   0:00.17 top  <br><br>[root@******* ~]# <br>[root@******* ~]# free -m<br>              total        used        free      shared  buff&#47;cache   available<br>Mem:         128826      115682        8053        4032        5089        7588<br>Swap:         16383         505       15878<br>[root@******* ~]# <br><br>mysql&gt;select @@version;<br>+---------------------+<br>| @@version           |<br>+---------------------+<br>| 10.2.16-MariaDB-log |<br>+---------------------+<br>1 row in set (0.00 sec)<br><br>+-------------------------+-------------+<br>| Variable_name           | Value       |<br>+-------------------------+-------------+<br>| binlog_cache_size       | 4194304     |<br>| innodb_buffer_pool_size | 90194313216 |<br>| innodb_log_buffer_size  | 16777216    |<br>| join_buffer_size        | 2097152     |<br>| key_buffer_size         | 4194304     |<br>| max_allowed_packet      | 67108864    |<br>| max_heap_table_size     | 33554432    |<br>| net_buffer_length       | 32768       |<br>| query_cache_size        | 0           |<br>| read_buffer_size        | 262144      |<br>| read_rnd_buffer_size    | 2097152     |<br>| sort_buffer_size        | 1048576     |<br>| thread_stack            | 131072      |<br>| tmp_table_size          | 33554432    |<br>+-------------------------+-------------+","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439514,"discussion_content":"这样确实看不出来😅","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550539071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1231289,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM56TmIEXDkHOfMNr7cAlCyGSQHiab7frfp59ibfuIibyPcpG1vugMLjNDeosfewg3sUkIfE0mzicqGgtw/132","nickname":"北极熊","note":"","ucode":"80B9CB59E151CA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587883,"discussion_content":"700  请问问题定位了吗 收到请reply  \n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663343654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65252,"user_name":"慕塔","can_delete":false,"product_type":"c1","uid":1302106,"ip_address":"","ucode":"5C6C668C1106A5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/A94RKUfWfwzRzb68T9xskctQ43TBgXSBIL78p0N0ria2tQxmsTTJebYmefhkbHK7zwpoxokxs43UxpgDTdwm5tg/132","comment_is_top":false,"comment_ctime":1549162418,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549162418","product_id":100020801,"comment_content":"young区域其实还有优化，频道调整LRU页的顺序为影响性能(LRU很长)，如果要读页在young区域某位置，其实是没有必要将要读页拿到头部，本身已在热点区。页的属性有一个时间戳字段，可以用于计算处于old区域的时间。😁","like_count":0},{"had_liked":false,"id":64443,"user_name":"Richie","can_delete":false,"product_type":"c1","uid":1111377,"ip_address":"","ucode":"1426E1B2E82A43","user_header":"https://static001.geekbang.org/account/avatar/00/10/f5/51/60e91438.jpg","comment_is_top":false,"comment_ctime":1548797470,"is_pvip":false,"replies":[{"id":"23186","content":"这个官方版本确实是还没有系统的地方查看~","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1549270578,"ip_address":"","comment_id":64443,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1548797470","product_id":100020801,"comment_content":"老师，怎么才能了解什么地方占用内存，查了很多资料都没有这方面的信息，MySQL5.6","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437999,"discussion_content":"这个官方版本确实是还没有系统的地方查看~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549270578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}