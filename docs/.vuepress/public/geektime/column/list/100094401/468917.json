{"id":468917,"title":"25｜表格：如何设计一个表格组件？","content":"<p>你好，我是大圣。</p><p>上一讲我们实现了树形组件，树形组件的主要难点就是对无限嵌套数据的处理。今天我们来介绍组件库中最复杂的表格组件，表格组件在项目中负责列表数据的展示，尤其是在管理系统中，比如用户信息、课程订单信息的展示，都需要使用表格组件进行渲染。</p><p>关于表单的具体交互形式和复杂程度，你可以访问<a href=\"https://element-plus.gitee.io/zh-CN/component/table.html\">ElementPlus</a>、<a href=\"https://www.naiveui.com/zh-CN/os-theme/components/data-table\">NaiveUi</a>、 <a href=\"https://www.antdv.com/components/table-cn\">AntDesignVue</a>这三个主流组件库中的表格组件去体验，并且社区还提供了单独的<a href=\"https://surely.cool\">复杂表格组件</a>，这一讲我就给你详细说说一个复杂表格组件如何去实现。</p><h2>表格组件</h2><p>大部分组件库都会内置表格组件，这是总后台最常用的组件之一，用于展示大量的结构化的数据。html也提供了内置的表格标签，由&nbsp;&lt;table&gt; 、&lt;thead&gt; 、&lt;tbody&gt; 、&lt;tr&gt; 、&lt;th&gt; 、&lt;td&gt;&nbsp;这些标签来组成一个最简单的表格标签。</p><p>我们先研究一下html的table标签。下面的代码中，table 标签负责表格的容器，thead负责表头信息的容器，tbody负责表格的主体，tr标签负责表格的每一行，th和td分别负责表头和主体的单元格。</p><p>其实标准的表格系列标签，跟 div+css 实现是有很大区别的。比如表格在做单元格合并时，要提供原生属性，这时候用 div 就很麻烦了。另外，它们的渲染原理上也有一定的区别，每一列的宽度会保持一致。</p><!-- [[[read_end]]] --><pre><code class=\"language-xml\">&lt;table&gt;\n  &lt;thead&gt;\n    &lt;tr&gt;\n      &lt;th&gt;课程&lt;/th&gt;\n      &lt;th&gt;价格&lt;/th&gt;\n    &lt;/tr&gt;\n  &lt;/thead&gt;\n  &lt;tbody&gt;\n    &lt;tr&gt;\n      &lt;td&gt;重学前端&lt;/td&gt;\n      &lt;td&gt;129&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n      &lt;td&gt;玩转Vue3全家桶&lt;/td&gt;\n      &lt;td&gt;129&lt;/td&gt;\n    &lt;/tr&gt;\n  &lt;/tbody&gt;\n&lt;/table&gt;\n</code></pre><p>简单的表格数据渲染并不需要组件，我们直接使用标准的 table 系列标签就可以。但有的时候，除了呈现数据，也会带有一些额外的功能要求，比如嵌套列、性能优化等。这时候组件的好处就很明显了，它能帮我们省去这些基础的工作。</p><p>表格组件的使用风格，从设计上说也分为了两个方向。一个方向是完全由数据驱动，这里我们可以参考Naive Ui的使用方式，n-data-table标签负责容器，直接通过data属性传递数据，通过columns传递表格的表头配置。</p><p>下面的代码中，我们在colums中去配置每行需要显示的属性，通过render函数可以返回定制化的结果，再使用h函数返回Button，渲染出对应的按钮。</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;n-data-table :columns=\"columns\" :data=\"data\" :pagination=\"pagination\" /&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport { h, defineComponent } from 'vue'\nimport { NTag, NButton, useMessage } from 'naive-ui'\nconst createColumns = ({ sendMail }) =&gt; {\n  return [\n    {\n      title: 'Name',\n      key: 'name',\n      align: 'center'\n    },\n    {\n      title: 'Age',\n      key: 'age'\n    },\n    {\n      title: 'Action',\n      key: 'actions',\n      render (row) {\n        return h(\n          NButton,\n          {\n            size: 'small',\n            onClick: () =&gt; sendMail(row)\n          },\n          { default: () =&gt; 'Send Email' }\n        )\n      }\n    }\n  ]\n}\nconst createData = () =&gt; [\n  {\n    key: 0,\n    name: 'John Brown',\n    age: 32,\n    tags: ['nice', 'developer']\n  },\n  {\n    key: 1,\n    name: 'Jim Green',\n    age: 42,\n  },\n  {\n    key: 2,\n    name: 'Joe Black',\n    age: 32\n  }\n]\nexport default defineComponent({\n  setup () {\n    const message = useMessage()\n    return {\n      data: createData(),\n      columns: createColumns({\n        sendMail (rowData) {\n          message.info('send mail to ' + rowData.name)\n        }\n      }),\n      pagination: {\n        pageSize: 10\n      }\n    }\n  }\n})\n&lt;/script&gt;\n\n</code></pre><p>还有一种是Element3现在使用的风格，配置数据之后，具体数据的展现形式交给子元素来决定，把columns当成组件去使用，我们仍然通过例子来加深理解。</p><p>下面的代码中，我们配置完data后，使用el-table-colum组件去渲染组件的每一列，通过slot的方式去实现定制化的渲染。这两种风格各有优缺点，我们后面还会结合Elemnt3的源码进行讲解.</p><pre><code class=\"language-xml\">&lt;el-table :data=\"tableData\" border style=\"width: 100%\"&gt;\n  &lt;el-table-column fixed prop=\"date\" label=\"日期\" width=\"150\"&gt;\n  &lt;/el-table-column&gt;\n  &lt;el-table-column prop=\"name\" label=\"姓名\" width=\"120\"&gt; &lt;/el-table-column&gt;\n  &lt;el-table-column prop=\"province\" label=\"省份\" width=\"120\"&gt; &lt;/el-table-column&gt;\n  &lt;el-table-column prop=\"city\" label=\"市区\" width=\"120\"&gt; &lt;/el-table-column&gt;\n  &lt;el-table-column prop=\"address\" label=\"地址\" width=\"300\"&gt; &lt;/el-table-column&gt;\n  &lt;el-table-column prop=\"zip\" label=\"邮编\" width=\"120\"&gt; &lt;/el-table-column&gt;\n  &lt;el-table-column fixed=\"right\" label=\"操作\" width=\"100\"&gt;\n    &lt;template v-slot=\"scope\"&gt;\n      &lt;el-button @click=\"handleClick(scope.row)\" type=\"text\" size=\"small\"\n        &gt;查看&lt;/el-button\n      &gt;\n      &lt;el-button type=\"text\" size=\"small\"&gt;编辑&lt;/el-button&gt;\n    &lt;/template&gt;\n  &lt;/el-table-column&gt;\n&lt;/el-table&gt;\n&lt;script&gt;\n  export default {\n    methods: {\n      handleClick(row) {\n        console.log(row)\n      }\n    },\n    data() {\n      return {\n        tableData: [\n          {\n            date: '2016-05-02',\n            name: '王小虎',\n            province: '上海',\n            city: '普陀区',\n            address: '上海市普陀区金沙江路 1518 弄',\n            zip: 200333\n          },\n          {\n            date: '2016-05-04',\n            name: '王小虎',\n            province: '上海',\n            city: '普陀区',\n            address: '上海市普陀区金沙江路 1517 弄',\n            zip: 200333\n          },\n          {\n            date: '2016-05-01',\n            name: '王小虎',\n            province: '上海',\n            city: '普陀区',\n            address: '上海市普陀区金沙江路 1519 弄',\n            zip: 200333\n          },\n          {\n            date: '2016-05-03',\n            name: '王小虎',\n            province: '上海',\n            city: '普陀区',\n            address: '上海市普陀区金沙江路 1516 弄',\n            zip: 200333\n          }\n        ]\n      }\n    }\n  }\n&lt;/script&gt;\n</code></pre><h2>表格组件的扩展</h2><p>复杂的表格组件需要对表格的显示和操作进行扩展。</p><p>首先是从表格的显示上扩展，我们可以支持表头或者某一列的锁定，在滚动的时候锁定列不受影响。一个table标签很难实现这个效果，这时候我们就需要分为table-head和table-body两个组件进行维护，通过colgroup组件限制每一列的宽度实现表格的效果，而且表头还需要支持表头嵌套。</p><p>下面的示意图中，表头就是被分组显示的。</p><p><img src=\"https://static001.geekbang.org/resource/image/f6/4a/f60dac2bf267c10d5f230e8cb03b744a.png?wh=1764x1282\" alt=\"图片\"></p><p>我们还是先分析一下需求。对于表格的操作来说，首先要和树组件一样，每一样支持复选框进行选中，方便进行批量的操作。另外，表头还需要支持点击事件，点击后对当前这一列实现排序的效果，同时每一列还可能会有详情数据的展开，甚至表格内部还会有树形组件的嵌套、底部的数据显示等等。</p><p>把这些需求组合在一起，表格就成了组件库中最复杂的组件。我们需要先分解需求，把组件内部拆分成table、table-column、table-body、table-header组件，我们挨个来看一下。</p><p>首先，在table组件的内部，我们使用table-body和table-header构成组件。table提供了整个表格的标签容器；hidden-columns负责隐藏列的显示，并且通过table-store进行表格内部的状态管理。每当table中的table-store被修改后，table-header、table-body都需要重新渲染。</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;div class=\"el-table\"&gt;\n    &lt;div class=\"hidden-columns\" ref=\"hiddenColumns\"&gt;\n      &lt;slot&gt;&lt;/slot&gt;\n    &lt;/div&gt;\n    &lt;div class=\"el-table__header-wrapper\"\n         ref=\"headerWrapper\"&gt;\n      &lt;table-header ref=\"tableHeader\"\n                    :store=\"store\"&gt;\n      &lt;/table-header&gt;\n    &lt;/div&gt;\n    &lt;div class=\"el-table__body-wrapper\"\n         ref=\"bodyWrapper\"&gt;\n      &lt;table-body :context=\"context\"\n                  :store=\"store\"&gt;                  \n      &lt;/table-body&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n</code></pre><p>然后在table组件的初始化过程中，我们首先使用createStore创建表格的store数据管理，并且通过TableLayout创建表格的布局，然后把store通过属性的方式传递给table-header和table-body。</p><pre><code class=\"language-xml\">let table = getCurrentInstance()\n    const store = createStore(table, {\n      rowKey: props.rowKey,\n      defaultExpandAll: props.defaultExpandAll,\n      selectOnIndeterminate: props.selectOnIndeterminate,\n      // TreeTable 的相关配置\n      indent: props.indent,\n      lazy: props.lazy,\n      lazyColumnIdentifier: props.treeProps.hasChildren || 'hasChildren',\n      childrenColumnName: props.treeProps.children || 'children',\n      data: props.data\n    })\n    table.store = store\n    const layout = new TableLayout({\n      store: table.store,\n      table,\n      fit: props.fit,\n      showHeader: props.showHeader\n    })\n    table.layout = layout\n\n</code></pre><p>再接着，table-header组件内部会接收传递的store，并且提供监听的事件，包括click，mousedown等鼠标操作后，计算出当前表头的宽高等数据进行显示。</p><pre><code class=\"language-xml\">const instance = getCurrentInstance()\n    const parent = instance.parent\n    const storeData = parent.store.states\n    const filterPanels = ref({})\n    const {\n      tableLayout,\n      onColumnsChange,\n      onScrollableChange\n    } = useLayoutObserver(parent)\n    const hasGutter = computed(() =&gt; {\n      return !props.fixed &amp;&amp; tableLayout.gutterWidth\n    })\n    onMounted(() =&gt; {\n      nextTick(() =&gt; {\n        const { prop, order } = props.defaultSort\n        const init = true\n        parent.store.commit('sort', { prop, order, init })\n      })\n    })\n    const {\n      handleHeaderClick,\n      handleHeaderContextMenu,\n      handleMouseDown,\n      handleMouseMove,\n      handleMouseOut,\n      handleSortClick,\n      handleFilterClick\n    } = useEvent(props, emit)\n    const {\n      getHeaderRowStyle,\n      getHeaderRowClass,\n      getHeaderCellStyle,\n      getHeaderCellClass\n    } = useStyle(props)\n    const { isGroup, toggleAllSelection, columnRows } = useUtils(props)\n\n    instance.state = {\n      onColumnsChange,\n      onScrollableChange\n    }\n    // eslint-disable-next-line\n    instance.filterPanels = filterPanels\n\n</code></pre><p>在table-body中，也是类似的实现方式和效果。不过table-body和table-header中的定制需求较多，我们需要用render函数来实现定制化的需求。</p><p>下面的代码中，我们利用h函数返回el-table__body的渲染，通过state中读取的columns数据依次进行数据的显示。</p><pre><code class=\"language-xml\">render() {\n\n    return h(\n      'table',\n      {\n        class: 'el-table__body',\n        cellspacing: '0',\n        cellpadding: '0',\n        border: '0'\n      },\n      [\n        hColgroup(this.store.states.columns.value),\n        h('tbody', {}, [\n          data.reduce((acc, row) =&gt; {\n            return acc.concat(this.wrappedRowRender(row, acc.length))\n          }, []),\n          h(\n            ElTooltip,\n            {\n              modelValue: this.tooltipVisible,\n              content: this.tooltipContent,\n              manual: true,\n              effect: this.$parent.tooltipEffect,\n              placement: 'top'\n            },\n            {\n              default: () =&gt; this.tooltipTrigger\n            }\n          )\n        ])\n      ]\n    )\n  }\n  \n</code></pre><p>整体表格组件的渲染逻辑和过程比较复杂。为了帮你抽丝剥茧，这节课我重点给你说说Element3中table标签的渲染过程，至于具体的表格实现代码，你可以课后参考Element3的源码。</p><p>表格组件除了显示的效果非常复杂、交互非常复杂之外，还有一个非常棘手的性能问题。由于表格是二维渲染，而且表格组件如果想支持表头或者某一列锁定的定制效果，内部需要渲染不止一个table标签。一旦数据量庞大之后，表格就成了最容易导致性能瓶颈的组件，那这种场景如何去做优化呢？</p><p>这里我们要快速回顾一下性能优化那一讲的思路：性能优化主要的思路就是如何能够减少计算量。比如我们的表格如果有1000行要显示，但是我们浏览器最多只能显示100条，其他的需要通过滚动条的方式进行滚动显示，屏幕之外，成千上万个dom元素就成了性能消耗的主要原因。</p><p>针对这种情况，我们可以考虑类似图片懒加载的方案，对屏幕之外的dom元素做懒渲染，也就是非常常见的<strong>虚拟列表解决方案</strong>。</p><p>在虚拟列表解决方案中，我们首先要获取窗口的高度、元素的高度以及当前滚动的距离，通过这些数据计算出当前屏幕显示出来的数据。然后创建这些元素标签，设置元素的transform属性模拟滚动效果。这样表面看是1000条数据在表格里显示，实际只渲染了屏幕中间的这100行数据，当我们滚动鼠标的同时，去维护这100个数据列表，这样就完成了标签过多的性能问题。</p><p>如果表格内部每一行的高度不同的话，我们就需要对每一个元素的高度进行估计。具体操作时，先进行渲染，然后等待渲染完毕之后获取高度并且缓存下来，即可实现虚拟列表元素高度的自适应。</p><h2>总结</h2><p>今天要我们学习了表格组件如何实现，我给你做个总结吧。</p><p>表格组件是组件库中最复杂的组件，核心的难点除了<strong>数据的嵌套渲染</strong>和<strong>复杂的交互</strong>之外，<strong>复杂的dom节点</strong>也是表格的特点之一。我们通过对table-header、table-body和table-footer的组件分析，掌握了表格组件设计思路的实现细节。</p><p>除此之外，表格也是最容易导致页面卡顿的组件，所以我们除了数据驱动渲染之外，还需要考虑通过虚拟滚动的方式进行渲染的优化，这也是列表数据常见的优化策略，属于懒渲染的解决方案。</p><p>无论数据有多少行，我们只渲染用户可视窗口之内的，控制top的属性来模拟滚动效果，通过computed计算出需要渲染的数据。最后，我还想提醒你注意，虚拟滚动也是面试的热门解决方案，你一定要手敲一遍才能加深理解。</p><h2>思考题</h2><p>最后留个思考题吧，你现在基础的复杂项目或者组件库中，有哪些组件适合用虚拟滚动做性能优化呢？欢迎你在评论区分享你的答案，也欢迎你把这一讲分享给你的同事和朋友们，我们下一讲再见</p>","neighbors":{"left":{"article_title":"24｜树：如何设计一个树形组件？","id":468036},"right":{"article_title":"26｜文档：如何给你的组件库设计一个可交互式文档？","id":468885}},"comments":[{"had_liked":false,"id":326788,"user_name":"海阔天空","can_delete":false,"product_type":"c1","uid":1327016,"ip_address":"","ucode":"16C87A0052A08B","user_header":"https://static001.geekbang.org/account/avatar/00/14/3f/a8/8da58e53.jpg","comment_is_top":false,"comment_ctime":1639699756,"is_pvip":false,"replies":[{"id":"118771","content":"我其实也更喜欢naive和ant-design的表格表格实现方式","user_name":"作者回复","comment_id":326788,"uid":"1003715","ip_address":"","utype":1,"ctime":1639791862,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"14524601644","product_id":100094401,"comment_content":"表格算是elment中比较难的组件了。感觉 Naive Ui 的使用方式配置得比较多，element 让人更好理解一点<br>","like_count":4,"discussions":[{"author":{"id":1003715,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/50/c3/0aa50246.jpg","nickname":"花果山大圣","note":"","ucode":"25C0A36D628037","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539620,"discussion_content":"我其实也更喜欢naive和ant-design的表格表格实现方式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639791862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327271,"user_name":"Ankhetsin","can_delete":false,"product_type":"c1","uid":1028469,"ip_address":"","ucode":"3CA233D08D4A72","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b1/75/60a71bbd.jpg","comment_is_top":false,"comment_ctime":1640041181,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5935008477","product_id":100094401,"comment_content":"PC端的表格一般带分页","like_count":1},{"had_liked":false,"id":359373,"user_name":"海阔天空","can_delete":false,"product_type":"c1","uid":2283970,"ip_address":"北京","ucode":"985308FA95406B","user_header":"https://static001.geekbang.org/account/avatar/00/22/d9/c2/04f9d05b.jpg","comment_is_top":false,"comment_ctime":1665481139,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1665481139","product_id":100094401,"comment_content":"这代码在哪里","like_count":0},{"had_liked":false,"id":341832,"user_name":"落风","can_delete":false,"product_type":"c1","uid":1198158,"ip_address":"","ucode":"D70B221D22A439","user_header":"https://static001.geekbang.org/account/avatar/00/12/48/4e/51896855.jpg","comment_is_top":false,"comment_ctime":1649853022,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649853022","product_id":100094401,"comment_content":"好家伙，是时候优化一下自己的组件库了","like_count":0},{"had_liked":false,"id":340085,"user_name":"CrazyMuyang","can_delete":false,"product_type":"c1","uid":1161349,"ip_address":"","ucode":"C592928715EB9E","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/85/27aa9f63.jpg","comment_is_top":false,"comment_ctime":1648599895,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648599895","product_id":100094401,"comment_content":"在移动端，如果在页面最低下有一个列表组件需要用虚拟滚动处理，该怎么实现呢。？<br>我目前了解的实现方案都要有一个固定高度的滚动区域，但这种场景下并不能给这个列表显示区域一个固定高度","like_count":0},{"had_liked":false,"id":327113,"user_name":"费城的二鹏","can_delete":false,"product_type":"c1","uid":1101293,"ip_address":"","ucode":"DE768A0CC3053D","user_header":"https://static001.geekbang.org/account/avatar/00/10/cd/ed/825d84ee.jpg","comment_is_top":false,"comment_ctime":1639920323,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639920323","product_id":100094401,"comment_content":"我们的项目中，会有超级大的列表，目前用v-for做的，数据多了dom会占用很多内存，可以用虚拟滚动优化。","like_count":0},{"had_liked":false,"id":326836,"user_name":"银太","can_delete":false,"product_type":"c1","uid":1051765,"ip_address":"","ucode":"B505D15F7CB839","user_header":"https://static001.geekbang.org/account/avatar/00/10/0c/75/e7c6c403.jpg","comment_is_top":false,"comment_ctime":1639716621,"is_pvip":false,"replies":[{"id":"118768","content":"看这个需求可以在x-table的slot#bodyCell以slot的形式传递给a-table","user_name":"作者回复","comment_id":326836,"uid":"1003715","ip_address":"","utype":1,"ctime":1639791651,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1639716621","product_id":100094401,"comment_content":"请教下，我是想对table封装成xtable，那么在page中使用的时候原来的table的slot就会写到xtable的slot，那table怎么渲染？<br>x-table：<br>&lt;div&gt;<br>  &lt;a-table&gt;<br>    &#47;&#47;&lt;template #bodyCell&gt;&lt;&#47;template&gt; 原来是在这里写的<br>  &lt;&#47;a-table&gt;<br>&lt;&#47;div&gt;<br><br><br>page：<br>&lt;page&gt;<br>  &lt;x-table&gt;<br>    &lt;template #bodyCell&gt;&lt;&#47;template&gt;<br>  &lt;&#47;x-table&gt;<br>&lt;&#47;page&gt;","like_count":0,"discussions":[{"author":{"id":1003715,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/50/c3/0aa50246.jpg","nickname":"花果山大圣","note":"","ucode":"25C0A36D628037","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539617,"discussion_content":"看这个需求可以在x-table的slot#bodyCell以slot的形式传递给a-table","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639791651,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326822,"user_name":"于三妮","can_delete":false,"product_type":"c1","uid":2464787,"ip_address":"","ucode":"36884C1BE51F7A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/7icj7X67vvABNjC284ichONicn6PFeZSUAdclWKr8FJIHfWUzx6azxPuDcCNODV8ZmqXMAUibvJZiaXsYxKCmtJfxkg/132","comment_is_top":false,"comment_ctime":1639710686,"is_pvip":false,"replies":[{"id":"118769","content":"争取后面我再写个简单迷你版，这两讲主要是想让大家感受一下demo级别的组件和实际可用组件的区别","user_name":"作者回复","comment_id":326822,"uid":"1003715","ip_address":"","utype":1,"ctime":1639791690,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1639710686","product_id":100094401,"comment_content":"这里有代码有点看不懂了","like_count":0,"discussions":[{"author":{"id":1003715,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/50/c3/0aa50246.jpg","nickname":"花果山大圣","note":"","ucode":"25C0A36D628037","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539618,"discussion_content":"争取后面我再写个简单迷你版，这两讲主要是想让大家感受一下demo级别的组件和实际可用组件的区别","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639791690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}