{"id":522342,"title":"35ï½œDI Containerï¼ˆ23ï¼‰ï¼šé¡¹ç›®å›é¡¾ä¸æ€»ç»“","content":"<p>ä½ å¥½ï¼Œæˆ‘æ˜¯å¾æ˜Šã€‚ä»Šå¤©æˆ‘ä»¬æ¥å›é¡¾ä¸€ä¸‹ç¬¬äºŒä¸ªå®æˆ˜é¡¹ç›®çš„æ•´ä¸ªè¿‡ç¨‹ã€‚</p><h2>æœ€ç»ˆçš„å®Œæˆå½¢æ€</h2><p>é¦–å…ˆï¼Œè®©æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹æœ€ç»ˆçš„å®Œæˆå½¢æ€ï¼š</p><p><video poster=\"https://media001.geekbang.org/60cdd231fbab43639433b7417175c4ce/snapshots/49e71671b9674750b164fa0fda6c29e7-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/62068975-18112dc4f01-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/69cf850cd5c14a8a82d3ea2c686e0265/0ced5149f7aa46938ef599f07d224ac9-54ff4117895c7391a73695c33c6e4fd5-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><h2>é¡¹ç›®å›é¡¾ä¸æ€»ç»“</h2><p>é¦–å…ˆæ˜¯ä»»åŠ¡åˆ†è§£ã€‚åœ¨é¡¹ç›®åˆšå¼€å§‹çš„æ—¶å€™ï¼Œæˆ‘ä»¬æ²¡æœ‰æ„æƒ³ä»»ä½•çš„æ¶æ„æ„¿æ™¯ï¼Œè€Œæ˜¯ç›´æ¥é‡‡ç”¨ç»å…¸æ¨¡å¼ï¼Œä»åŠŸèƒ½ç‚¹å‡ºå‘è¿›è¡ŒTDDå¼€å‘ã€‚ä¸€å¼€å§‹è¿›å±•æ˜¯å¾ˆé¡ºåˆ©çš„ï¼Œä»ä»»åŠ¡åˆ—è¡¨ä¸Šçœ‹ï¼Œé™¤äº†å¶æœ‰é—è½çš„åŠŸèƒ½ç‚¹ï¼ŒåŸºæœ¬ä¸Šæ˜¯æŒ‰ç…§ä»»åŠ¡åˆ—è¡¨é¡ºç•…è¿›è¡Œçš„ã€‚</p><p>ç¬¬ä¸€ä¸ªè½¬æŠ˜ç‚¹å‡ºç°åœ¨æˆ‘ä»¬ç¬¬ä¸€æ¬¡é‡æ„ä¹‹åï¼Œæˆ‘ä»¬å°†InjectionProviderä»ContextConfigä¸­åˆ†ç¦»äº†å‡ºæ¥ã€‚å¹¶å°†ä¾èµ–çš„æ£€æŸ¥ä»è¿è¡ŒæœŸæ£€æŸ¥ï¼Œå˜æˆäº†åœ¨ContextConfig.getContextæ—¶é¢„å…ˆæ£€æŸ¥ã€‚</p><p>ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬çš„<strong>æ¶æ„æ„¿æ™¯</strong>åœ¨æ­¤æ—¶å‘ç”Ÿäº†æ”¹å˜ï¼šåªè¦Contextèƒ½å¤Ÿè¢«æ„å»ºå‡ºæ¥ï¼Œå…¶ä¸­å°±ä¸å­˜åœ¨æ— æ•ˆç»„ä»¶å’Œæ— æ•ˆçš„ç»„ä»¶å…³ç³»ï¼ˆå¾ªç¯ä¾èµ–ã€ä¾èµ–ç¼ºå¤±ï¼‰ã€‚</p><p>è¿™ä¸ªæ¶æ„æ„¿æ™¯æ”¹å˜çš„ç›´æ¥å½±å“ï¼Œå°±æ˜¯è®©æˆ‘ä»¬<strong>åˆ†è§£ä»»åŠ¡çš„æ–¹å¼</strong>å‘ç”Ÿäº†å˜åŒ–ã€‚ä½“ç°åœ¨ä»»åŠ¡åˆ—è¡¨ä¸Šä¸ºï¼š</p><ul>\n<li>\n<p>æ–¹æ³•æ³¨å…¥ï¼ˆæ”¹å˜å‰ï¼‰</p>\n<ul>\n<li>é€šè¿‡Injectæ ‡æ³¨çš„æ–¹æ³•ï¼Œå…¶å‚æ•°ä¸ºä¾èµ–ç»„ä»¶</li>\n<li>é€šè¿‡Injectæ ‡æ³¨çš„æ— å‚æ•°æ–¹æ³•ï¼Œä¼šè¢«è°ƒç”¨</li>\n<li>æŒ‰ç…§å­ç±»ä¸­çš„è§„åˆ™ï¼Œè¦†ç›–çˆ¶ç±»ä¸­çš„Injectæ–¹æ³•</li>\n<li>å¦‚æœç»„ä»¶éœ€è¦çš„ä¾èµ–ä¸å­˜åœ¨ï¼Œåˆ™æŠ›å‡ºå¼‚å¸¸</li>\n<li>å¦‚æœæ–¹æ³•å®šä¹‰ç±»å‹å‚æ•°ï¼Œåˆ™æŠ›å‡ºå¼‚å¸¸</li>\n<li>å¦‚æœç»„ä»¶é—´å­˜åœ¨å¾ªç¯ä¾èµ–ï¼Œåˆ™æŠ›å‡ºå¼‚å¸¸</li>\n</ul>\n</li>\n<li>\n<p>æ–¹æ³•æ³¨å…¥ï¼ˆæ”¹å˜åï¼‰</p>\n<ul>\n<li>é€šè¿‡Injectæ ‡æ³¨çš„æ–¹æ³•ï¼Œå…¶å‚æ•°ä¸ºä¾èµ–ç»„ä»¶</li>\n<li>é€šè¿‡Injectæ ‡æ³¨çš„æ— å‚æ•°æ–¹æ³•ï¼Œä¼šè¢«è°ƒç”¨</li>\n<li>æŒ‰ç…§å­ç±»ä¸­çš„è§„åˆ™ï¼Œè¦†ç›–çˆ¶ç±»ä¸­çš„Injectæ–¹æ³•</li>\n<li>å¦‚æœæ–¹æ³•å®šä¹‰ç±»å‹å‚æ•°ï¼Œåˆ™æŠ›å‡ºå¼‚å¸¸</li>\n<li>ä¾èµ–ä¸­åº”åŒ…å«Inject Methodå£°æ˜çš„ä¾èµ–</li>\n</ul>\n</li>\n</ul><!-- [[[read_end]]] --><p>ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨è¿™ä¸€åˆ»ï¼Œé™¤äº†åŠŸèƒ½ç‚¹ä¹‹å¤–ï¼Œæˆ‘ä»¬å‡ºç°äº†ä¸¤ä¸ªåŠŸèƒ½ä¸Šä¸‹æ–‡ï¼šComponentProviderå’ŒContextConfigã€‚å¾ˆè‡ªç„¶åœ°ï¼Œè¿å¸¦ç€åˆ†è§£ä»»åŠ¡çš„æ–¹å¼ä¹Ÿå‘ç”Ÿäº†æ”¹å˜ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š</p><p><img src=\"https://static001.geekbang.org/resource/image/c3/20/c3520c517b3c890b717601ca4bee3520.jpg?wh=8000x4500\" alt=\"\"></p><p>åŒæ—¶ï¼Œæˆ‘ä»¬çš„é¡¹ç›®è¿˜å‘ç”Ÿè¿‡ä¸¤æ¬¡é‡å¤§çš„<strong>æ¨¡å‹è°ƒæ•´</strong>ï¼š</p><ul>\n<li>ç¬¬ä¸€æ¬¡æ˜¯åœ¨å¼•å…¥Provideræ¥å£çš„æ—¶å€™ã€‚ä¹Ÿå°±æ˜¯é™¤äº†èƒ½å¤Ÿç›´æ¥å¯¹ç»„ä»¶ä¾èµ–å¤–ï¼Œè¿˜å¯ä»¥é€šè¿‡Provider<t>è·å–ç»„ä»¶çš„å·¥å‚ã€‚</t></li>\n<li>ç¬¬äºŒæ¬¡åˆ™æ˜¯åœ¨å¼•å…¥Qualifierçš„æ—¶å€™ã€‚</li>\n</ul><p>ç¬¬ä¸€æ¬¡æ¨¡å‹è°ƒæ•´çš„æ—¶å€™ï¼Œæˆ‘ä»¬å‘ç°ä¹‹å‰éƒ½ä»¥Class&lt;?&gt;ä½œä¸ºè·å–ç»„ä»¶çš„æ ‡è¯†ã€‚è€Œå½“å¼•å…¥Providerä¹‹åï¼Œæˆ‘ä»¬å°±éœ€è¦é€šè¿‡Typeä½œä¸ºè·å–ç»„ä»¶çš„æ ‡è¯†ã€‚æˆ‘ä»¬ä¿®æ”¹äº†ComponentProviderçš„æ¥å£ä½“ç°äº†è¿™ç§å˜åŒ–ï¼š</p><pre><code>å¼•å…¥Providerä¹‹å‰ï¼š\n\n    public interface ComponentProvider&lt;T&gt; {\n        T get(Context context);\n        \n        default List&lt;Class&lt;?&gt;&gt; getDependencies() {\n            return List.of();\n        }\n    }\n\nå¼•å…¥Providerä¹‹åï¼š\n\n    public interface ComponentProvider&lt;T&gt; {\n        T get(Context context);\n        \n        default List&lt;Type&gt; getDependencies() {\n            return List.of();\n        }\n    }\n</code></pre><p>ç¬¬äºŒæ¬¡<strong>æ¨¡å‹è°ƒæ•´</strong>çš„æ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦å°†Typeå’ŒQualifieræ ‡æ³¨ç»„åˆåœ¨ä¸€èµ·ã€‚äºæ˜¯æˆ‘ä»¬å¼•å…¥äº†ComponentRefï¼ˆæœ€å¼€å§‹å«Refï¼‰å¯¹è±¡ï¼Œä½œä¸ºè·å–ç»„ä»¶çš„æ ‡è¯†ã€‚æˆ‘ä»¬å†æ¬¡ä¿®æ”¹äº†ComponentProviderçš„æ¥å£ï¼š</p><pre><code>public interface ComponentProvider&lt;T&gt; {\n    T get(Context context);\n    \n    default List&lt;ComponentRef&lt;?&gt;&gt; getDependencies() {\n        return List.of();\n    }\n}\n</code></pre><p><strong>æ¨¡å‹è°ƒæ•´</strong>ä¹‹åï¼ŒContextä¸­çš„ç»„ä»¶å°±ä»å®ä¾‹ç»„ä»¶ï¼ˆInstanceï¼‰å’Œæ³¨å…¥ç»„ä»¶ï¼ˆInjectable Componentï¼‰ï¼Œå˜æˆå®ä¾‹ç»„ä»¶ã€æ³¨å…¥ç»„ä»¶ã€å¸¦Qualifierçš„å®ä¾‹ç»„ä»¶ã€å¸¦Qualifierçš„æ³¨å…¥ç»„ä»¶ä»¥åŠå®ƒä»¬å¯¹åº”çš„Providerå½¢å¼<strong>ç­‰å…«ç§</strong>ã€‚</p><p>è¿™ä¹Ÿè¿›ä¸€æ­¥å¸®åŠ©æˆ‘ä»¬ç†è§£äº†è½¯ä»¶çš„éœ€æ±‚ï¼Œå¸®åŠ©æˆ‘ä»¬è¿›ä¸€æ­¥æœ‰æ•ˆç‡åœ°åˆ†è§£äº†ä»»åŠ¡ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š</p><p><img src=\"https://static001.geekbang.org/resource/image/3d/9f/3d0dd1fa1f6f235011f8cba22cce739f.jpg?wh=8000x4500\" alt=\"\"></p><p>å¸¦æ¥çš„ç»“æœæ˜¯ï¼Œä»»åŠ¡åˆ—è¡¨å‘ç”Ÿäº†æ›´ä¸ºå‰§çƒˆçš„æ”¹å˜ï¼š</p><ul>\n<li>\n<p>è‡ªå®šä¹‰Qualifierçš„ä¾èµ–ï¼ˆæœ€å¼€å§‹çš„ä»»åŠ¡ï¼‰</p>\n<ul>\n<li>æ³¨å†Œç»„ä»¶æ—¶ï¼Œå¯é¢å¤–æŒ‡å®šQualifier</li>\n<li>æ³¨å†Œç»„ä»¶æ—¶ï¼Œå¯ä»ç±»å¯¹è±¡ä¸Šæå–Qualifier</li>\n<li>å¯»æ‰¾ä¾èµ–æ—¶ï¼Œéœ€åŒæ—¶æ»¡è¶³ç±»å‹ä¸è‡ªå®šä¹‰Qualifieræ ‡æ³¨</li>\n<li>æ”¯æŒé»˜è®¤Qualifierâ€”â€”Named</li>\n</ul>\n</li>\n<li>\n<p>è‡ªå®šä¹‰Qualifierçš„ä¾èµ–ï¼ˆå®é™…å®Œæˆçš„ä»»åŠ¡ï¼‰</p>\n<ul>\n<li>\n<p>æ³¨å†Œç»„ä»¶æ—¶ï¼Œå¯é¢å¤–æŒ‡å®šQualifier</p>\n<ul>\n<li>é’ˆå¯¹instanceæŒ‡å®šä¸€ä¸ªQualifieriï¼ˆæ–°å¢ä»»åŠ¡ï¼‰</li>\n<li>é’ˆå¯¹ç»„ä»¶æŒ‡å®šä¸€ä¸ªQualiiferï¼ˆæ–°å¢ä»»åŠ¡ï¼‰</li>\n<li>é’ˆå¯¹instanceæŒ‡å®šå¤šä¸ªQualifieriï¼ˆæ–°å¢ä»»åŠ¡ï¼‰</li>\n<li>é’ˆå¯¹ç»„ä»¶æŒ‡å®šå¤šä¸ªQualiiferï¼ˆæ–°å¢ä»»åŠ¡ï¼‰</li>\n</ul>\n</li>\n<li>\n<p>æ³¨å†Œç»„ä»¶æ—¶ï¼Œå¦‚æœä¸æ˜¯åˆæ³•çš„Qualifierï¼Œåˆ™ä¸æ¥å—ç»„ä»¶æ³¨å†Œï¼ˆæ–°å¢ä»»åŠ¡ï¼‰</p>\n</li>\n<li>\n<p>å¯»æ‰¾ä¾èµ–æ—¶ï¼Œéœ€åŒæ—¶æ»¡è¶³ç±»å‹ä¸è‡ªå®šä¹‰Qualifieræ ‡æ³¨</p>\n<ul>\n<li>\n<p>åœ¨æ£€æŸ¥ä¾èµ–æ—¶ä½¿ç”¨Qualifierï¼ˆæ–°å¢ä»»åŠ¡ï¼‰</p>\n</li>\n<li>\n<p>åœ¨æ£€æŸ¥å¾ªç¯ä¾èµ–æ—¶ä½¿ç”¨Qualifierï¼ˆæ–°å¢ä»»åŠ¡ï¼‰</p>\n</li>\n<li>\n<p>æ„é€ å‡½æ•°æ³¨å…¥å¯ä»¥ä½¿ç”¨Qualifierå£°æ˜ä¾èµ–ï¼ˆæ–°å¢ä»»åŠ¡ï¼‰</p>\n<ul>\n<li>ä¾èµ–ä¸­åŒ…å«Qualifierï¼ˆæ–°å¢ä»»åŠ¡ï¼‰</li>\n<li>å¦‚æœä¸æ˜¯åˆæ³•çš„Qualifierï¼Œåˆ™ç»„ä»¶éæ³•</li>\n</ul>\n</li>\n<li>\n<p>å­—æ®µæ³¨å…¥å¯ä»¥ä½¿ç”¨Qualifierå£°æ˜ä¾èµ–ï¼ˆæ–°å¢ä»»åŠ¡ï¼‰</p>\n<ul>\n<li>ä¾èµ–ä¸­åŒ…å«Qualifierï¼ˆæ–°å¢ä»»åŠ¡ï¼‰</li>\n<li>å¦‚æœä¸æ˜¯åˆæ³•çš„Qualifierï¼Œåˆ™ç»„ä»¶éæ³•</li>\n</ul>\n</li>\n<li>\n<p>å‡½æ•°æ³¨å…¥å¯ä»¥ä½¿ç”¨Qualifierå£°æ˜ä¾èµ–ï¼ˆæ–°å¢ä»»åŠ¡ï¼‰</p>\n<ul>\n<li>ä¾èµ–ä¸­åŒ…å«Qualifierï¼ˆæ–°å¢ä»»åŠ¡ï¼‰</li>\n<li>å¦‚æœä¸æ˜¯åˆæ³•çš„Qualifierï¼Œåˆ™ç»„ä»¶éæ³•</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>æ”¯æŒé»˜è®¤Qualifierâ€”â€”Namedï¼ˆä¸éœ€è¦ï¼‰</p>\n</li>\n<li>\n<p>æ³¨å†Œç»„ä»¶æ—¶ï¼Œå¯ä»ç±»å¯¹è±¡ä¸Šæå–Qualifierï¼ˆä¸éœ€è¦ï¼‰</p>\n</li>\n</ul>\n</li>\n</ul><p>æˆ‘ä»¬é€šè¿‡<strong>é‡ç»„æµ‹è¯•</strong>ï¼Œä»ç»“æ„ä¸Šæ¢³ç†å¹¶è®°å½•äº†è¿™äº›æ”¹å˜ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š</p><p><img src=\"https://static001.geekbang.org/resource/image/e0/9c/e09ce21672d1639fec4c51b11fb11a9c.jpeg?wh=1920x1080\" alt=\"\"></p><p>è¿™ç§å¯¹äºæ ¸å¿ƒæ¨¡å‹çš„è°ƒæ•´æ˜¯<strong>ç—›è‹¦çš„</strong>ï¼Œåœ¨å¾ˆå¤šæƒ…å†µä¸‹ï¼Œæ„å‘³ç€è½¯ä»¶éœ€è¦é‡å†™ã€‚æˆ‘ä»¬å±•ç¤ºäº†å¦‚ä½•é€šè¿‡<strong>é‡æ„</strong>æ¥å®Œæˆè¿™ç§æ”¹å†™ï¼Œæ‰€ä»¥è¯·<strong>é‡ç‚¹å›çœ‹</strong>ä¸é‡æ„æœ‰å…³çš„ç« èŠ‚ï¼Œ<strong>åæ€</strong>æˆ‘ä»¬æ˜¯å¦‚ä½•åšåˆ°çš„ã€‚</p><p>æœ€åï¼Œæˆ‘çš„ä»£ç æ˜¯è¿™æ ·çš„ï¼š</p><pre><code>ComponentProvider.java\n\npackage geektime.tdd.di;\nimport java.util.List;\npublic interface ComponentProvider&lt;T&gt; {\n    T get(Context context);\n    default List&lt;ComponentRef&lt;?&gt;&gt; getDependencies() {\n        return List.of();\n    }\n}\n\nComponentRef.java\n\npackage geektime.tdd.di;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.Objects;\npublic class ComponentRef&lt;ComponentType&gt; {\n    public static &lt;ComponentType&gt; ComponentRef&lt;ComponentType&gt; of(Class&lt;ComponentType&gt; component) {\n        return new ComponentRef&lt;&gt;(component, null);\n    }\n    public static &lt;ComponentType&gt; ComponentRef&lt;ComponentType&gt; of(Class&lt;ComponentType&gt; component, Annotation qualifier) {\n        return new ComponentRef&lt;&gt;(component, qualifier);\n    }\n    public static ComponentRef&lt;?&gt; of(Type type, Annotation qualifier) {\n        return new ComponentRef&lt;&gt;(type, qualifier);\n    }\n    private Type container;\n    private ContextConfig.Component component;\n    ComponentRef(Type type, Annotation qualifier) {\n        init(type, qualifier);\n    }\n    protected ComponentRef() {\n        this(null);\n    }\n    protected ComponentRef(Annotation qualifier) {\n        Type type = ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0];\n        init(type, qualifier);\n    }\n    private void init(Type type, Annotation qualifier) {\n        if (type instanceof ParameterizedType container) {\n            this.container = container.getRawType();\n            this.component = new ContextConfig.Component((Class&lt;ComponentType&gt;) container.getActualTypeArguments()[0], qualifier);\n        } else\n            this.component = new ContextConfig.Component((Class&lt;ComponentType&gt;) type, qualifier);\n    }\n    public Type getContainer() {\n        return container;\n    }\n    public boolean isContainer() {\n        return container != null;\n    }\n    ContextConfig.Component component() {\n        return component;\n    }\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        ComponentRef&lt;?&gt; that = (ComponentRef&lt;?&gt;) o;\n        return Objects.equals(container, that.container) &amp;&amp; component.equals(that.component);\n    }\n    @Override\n    public int hashCode() {\n        return Objects.hash(container, component);\n    }\n}\n    \nConfig.java\n \npackage geektime.tdd.di;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\npublic interface Config {\n    @Documented\n    @Retention(RUNTIME)\n    @Target({ElementType.FIELD})\n    @interface Export {\n        Class&lt;?&gt; value();\n    }\n}\n    \nContext.java\n    \npackage geektime.tdd.di;\nimport java.util.Optional;\npublic interface Context {\n    &lt;ComponentType&gt; Optional&lt;ComponentType&gt; get(ComponentRef&lt;ComponentType&gt; ref);\n}\n    \nContextConfig.java\n    \npackage geektime.tdd.di;\nimport geektime.tdd.di.ContextConfig.Component;\nimport jakarta.inject.Provider;\nimport jakarta.inject.Qualifier;\nimport jakarta.inject.Scope;\nimport jakarta.inject.Singleton;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\nimport java.text.MessageFormat;\nimport java.util.*;\nimport java.util.function.Function;\nimport java.util.stream.Stream;\nimport static geektime.tdd.di.ContextConfigError.circularDependencies;\nimport static geektime.tdd.di.ContextConfigError.unsatisfiedResolution;\nimport static geektime.tdd.di.ContextConfigException.illegalAnnotation;\nimport static java.util.Arrays.spliterator;\nimport static java.util.Arrays.stream;\nimport static java.util.stream.Collectors.*;\npublic class ContextConfig {\n    private final Map&lt;Component, ComponentProvider&lt;?&gt;&gt; components = new HashMap&lt;&gt;();\n    private final Map&lt;Class&lt;?&gt;, ScopeProvider&gt; scopes = new HashMap&lt;&gt;();\n    public ContextConfig() {\n        scope(Singleton.class, SingletonProvider::new);\n    }\n    public &lt;Type&gt; void instance(Class&lt;Type&gt; type, Type instance) {\n        bind(new Component(type, null), context -&gt; instance);\n    }\n    public &lt;Type&gt; void instance(Class&lt;Type&gt; type, Type instance, Annotation... annotations) {\n        bindInstance(type, instance, annotations);\n    }\n    public &lt;Type, Implementation extends Type&gt;\n    void component(Class&lt;Type&gt; type, Class&lt;Implementation&gt; implementation, Annotation... annotations) {\n        bindComponent(type, implementation, annotations);\n    }\n    public &lt;ScopeType extends Annotation&gt; void scope(Class&lt;ScopeType&gt; scope, ScopeProvider provider) {\n        scopes.put(scope, provider);\n    }\n    public void from(Config config) {\n        new DSL(config).bind();\n    }\n    public Context getContext() {\n        components.keySet().forEach(component -&gt; checkDependencies(component, new Stack&lt;&gt;()));\n        HashMap&lt;Component, ComponentProvider&lt;?&gt;&gt; context = new HashMap&lt;&gt;(components);\n        return new Context() {\n            @Override\n            public &lt;ComponentType&gt; Optional&lt;ComponentType&gt; get(ComponentRef&lt;ComponentType&gt; ref) {\n                if (ref.isContainer()) {\n                    if (ref.getContainer() != Provider.class) return Optional.empty();\n                    return (Optional&lt;ComponentType&gt;) Optional.ofNullable(getProvider(ref))\n                            .map(provider -&gt; (Provider&lt;Object&gt;) () -&gt; provider.get(this));\n                }\n                return Optional.ofNullable(getProvider(ref)).map(provider -&gt; (ComponentType) provider.get(this));\n            }\n            private &lt;ComponentType&gt; ComponentProvider&lt;?&gt; getProvider(ComponentRef&lt;ComponentType&gt; ref) {\n                return context.get(ref.component());\n            }\n        };\n    }\n    private void bindComponent(Class&lt;?&gt; type, Class&lt;?&gt; implementation, Annotation... annotations) {\n        Bindings bindings = Bindings.component(implementation, annotations);\n        bind(type, bindings.qualifiers(), provider(implementation, bindings.scope()));\n    }\n    private void bindInstance(Class&lt;?&gt; type, Object instance, Annotation[] annotations) {\n        bind(type, Bindings.instance(type, annotations).qualifiers(), context -&gt; instance);\n    }\n    private &lt;Type&gt; void bind(Class&lt;Type&gt; type, List&lt;Annotation&gt; qualifiers, ComponentProvider&lt;?&gt; provider) {\n        if (qualifiers.isEmpty()) bind(new Component(type, null), provider);\n        for (Annotation qualifier : qualifiers)\n            bind(new Component(type, qualifier), provider);\n    }\n    private void bind(Component component, ComponentProvider&lt;?&gt; provider) {\n        if (components.containsKey(component)) throw ContextConfigException.duplicated(component);\n        components.put(component, provider);\n    }\n    private &lt;Type&gt; ComponentProvider&lt;?&gt; provider(Class&lt;Type&gt; implementation, Optional&lt;Annotation&gt; scope) {\n        ComponentProvider&lt;?&gt; injectionProvider = new InjectionProvider&lt;&gt;(implementation);\n        return scope.&lt;ComponentProvider&lt;?&gt;&gt;map(s -&gt; scoped(s, injectionProvider)).orElse(injectionProvider);\n    }\n    private ComponentProvider&lt;?&gt; scoped(Annotation scope, ComponentProvider&lt;?&gt; provider) {\n        if (!scopes.containsKey(scope.annotationType()))\n            throw ContextConfigException.unknownScope(scope.annotationType());\n        return scopes.get(scope.annotationType()).create(provider);\n    }\n    private void checkDependencies(Component component, Stack&lt;Component&gt; visiting) {\n        for (ComponentRef&lt;?&gt; dependency : components.get(component).getDependencies()) {\n            if (!components.containsKey(dependency.component()))\n                throw unsatisfiedResolution(component, dependency.component());\n            if (!dependency.isContainer()) {\n                if (visiting.contains(dependency.component()))\n                    throw circularDependencies(visiting, dependency.component());\n                visiting.push(dependency.component());\n                checkDependencies(dependency.component(), visiting);\n                visiting.pop();\n            }\n        }\n    }\n    record Component(Class&lt;?&gt; type, Annotation qualifier) {\n    }\n    static class Bindings {\n        public static Bindings component(Class&lt;?&gt; component, Annotation... annotations) {\n            return new Bindings(component, annotations, Qualifier.class, Scope.class);\n        }\n        public static Bindings instance(Class&lt;?&gt; instance, Annotation... annotations) {\n            return new Bindings(instance, annotations, Qualifier.class);\n        }\n        Class&lt;?&gt; type;\n        Map&lt;Class&lt;?&gt;, List&lt;Annotation&gt;&gt; group;\n        public Bindings(Class&lt;?&gt; type, Annotation[] annotations, Class&lt;? extends Annotation&gt;... allowed) {\n            this.type = type;\n            this.group = parse(type, annotations, allowed);\n        }\n        private static Map&lt;Class&lt;?&gt;, List&lt;Annotation&gt;&gt; parse(Class&lt;?&gt; type, Annotation[] annotations, Class&lt;? extends Annotation&gt;... allowed) {\n            Map&lt;Class&lt;?&gt;, List&lt;Annotation&gt;&gt; annotationGroups = stream(annotations).collect(groupingBy(allow(allowed), toList()));\n            if (annotationGroups.containsKey(Illegal.class))\n                throw illegalAnnotation(type, annotationGroups.get(Illegal.class));\n            return annotationGroups;\n        }\n        private static Function&lt;Annotation, Class&lt;?&gt;&gt; allow(Class&lt;? extends Annotation&gt;... annotations) {\n            return annotation -&gt; Stream.of(annotations).filter(annotation.annotationType()::isAnnotationPresent)\n                    .findFirst().orElse(Illegal.class);\n        }\n        private @interface Illegal {\n        }\n        Optional&lt;Annotation&gt; scope() {\n            List&lt;Annotation&gt; scopes = group.getOrDefault(Scope.class, from(type, Scope.class));\n            if (scopes.size() &gt; 1) throw illegalAnnotation(type, scopes);\n            return scopes.stream().findFirst();\n        }\n        List&lt;Annotation&gt; qualifiers() {\n            return group.getOrDefault(Qualifier.class, List.of());\n        }\n        private static List&lt;Annotation&gt; from(Class&lt;?&gt; implementation, Class&lt;? extends Annotation&gt; annotation) {\n            return stream(implementation.getAnnotations()).filter(a -&gt; a.annotationType().isAnnotationPresent(annotation)).toList();\n        }\n    }\n    class DSL {\n        private Config config;\n        public DSL(Config config) {\n            this.config = config;\n        }\n        void bind() {\n            for (Declaration declaration : declarations())\n                declaration.value().ifPresentOrElse(declaration::bindInstance, declaration::bindComponent);\n        }\n        private List&lt;Declaration&gt; declarations() {\n            return stream(config.getClass().getDeclaredFields()).filter(f -&gt; !f.isSynthetic()).map(Declaration::new).toList();\n        }\n        class Declaration {\n            private Field field;\n            Declaration(Field field) {\n                this.field = field;\n            }\n            void bindInstance(Object instance) {\n                ContextConfig.this.bindInstance(type(), instance, annotations());\n            }\n            void bindComponent() {\n                ContextConfig.this.bindComponent(type(), field.getType(), annotations());\n            }\n            private Optional&lt;Object&gt; value() {\n                try {\n                    return Optional.ofNullable(field.get(config));\n                } catch (IllegalAccessException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            private Class&lt;?&gt; type() {\n                Config.Export export = field.getAnnotation(Config.Export.class);\n                return export != null ? export.value() : field.getType();\n            }\n            private Annotation[] annotations() {\n                return stream(field.getAnnotations()).filter(a -&gt; a.annotationType() != Config.Export.class).toArray(Annotation[]::new);\n            }\n        }\n    }\n}\n    \nclass ContextConfigError extends Error {\n    public static ContextConfigError unsatisfiedResolution(Component component, Component dependency) {\n        return new ContextConfigError(MessageFormat.format(&quot;Unsatisfied resolution: {1} for {0} &quot;, component, dependency));\n    }\n    public static ContextConfigError circularDependencies(Collection&lt;Component&gt; path, Component circular) {\n        return new ContextConfigError(MessageFormat.format(&quot;Circular dependencies: {0} -&gt; [{1}]&quot;,\n                path.stream().map(Objects::toString).collect(joining(&quot; -&gt; &quot;)), circular));\n    }\n    ContextConfigError(String message) {\n        super(message);\n    }\n}\nclass ContextConfigException extends RuntimeException {\n    static ContextConfigException illegalAnnotation(Class&lt;?&gt; type, List&lt;Annotation&gt; annotations) {\n        return new ContextConfigException(MessageFormat.format(&quot;Unqualified annotations: {0} of {1}&quot;,\n                String.join(&quot; , &quot;, annotations.stream().map(Object::toString).toList()), type));\n    }\n    static ContextConfigException unknownScope(Class&lt;? extends Annotation&gt; annotationType) {\n        return new ContextConfigException(MessageFormat.format(&quot;Unknown scope: {0}&quot;, annotationType));\n    }\n    static ContextConfigException duplicated(Component component) {\n        return new ContextConfigException(MessageFormat.format(&quot;Duplicated: {0}&quot;, component));\n    }\n    ContextConfigException(String message) {\n        super(message);\n    }\n}\n    \nInjectionProvider.java\n    \npackage geektime.tdd.di;\nimport jakarta.inject.Inject;\nimport jakarta.inject.Qualifier;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.*;\nimport java.text.MessageFormat;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport static geektime.tdd.di.ComponentError.*;\nimport static java.util.Arrays.stream;\nimport static java.util.stream.Stream.concat;\nclass InjectionProvider&lt;T&gt; implements ComponentProvider&lt;T&gt; {\n    private final Injectable&lt;Constructor&lt;T&gt;&gt; injectConstructor;\n    private final Map&lt;Class&lt;?&gt;, List&lt;Injectable&lt;Method&gt;&gt;&gt; injectMethods;\n    private final Map&lt;Class&lt;?&gt;, List&lt;Injectable&lt;Field&gt;&gt;&gt; injectFields;\n    private final Collection&lt;Class&lt;?&gt;&gt; superClasses;\n    private final List&lt;ComponentRef&lt;?&gt;&gt; dependencies;\n    public InjectionProvider(Class&lt;T&gt; component) {\n        this.injectConstructor = getInjectConstructor(component);\n        this.superClasses = allSuperClass(component);\n        var injectFields = getInjectFields(component);\n        var injectMethods = getInjectMethods(component);\n        this.dependencies = concat(concat(Stream.of(injectConstructor), injectFields.stream()), injectMethods.stream())\n                .map(Injectable::required).flatMap(Arrays::stream).toList();\n        this.injectFields = groupByClass(injectFields);\n        this.injectMethods = groupByClass(injectMethods);\n    }\n    @Override\n    public T get(Context context) {\n        try {\n            T instance = injectConstructor.element().newInstance(injectConstructor.toDependencies(context));\n            for (Class&lt;?&gt; c : superClasses) {\n                for (Injectable&lt;Field&gt; field : injectFields.getOrDefault(c, List.of()))\n                    field.element().set(instance, field.toDependencies(context)[0]);\n                for (Injectable&lt;Method&gt; method : injectMethods.getOrDefault(c, List.of()))\n                    method.element().invoke(instance, method.toDependencies(context));\n            }\n            return instance;\n        } catch (InvocationTargetException | InstantiationException | IllegalAccessException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    @Override\n    public List&lt;ComponentRef&lt;?&gt;&gt; getDependencies() {\n        return dependencies;\n    }\n    record Injectable&lt;Element extends AccessibleObject&gt;(Element element, ComponentRef&lt;?&gt;[] required) {\n        Object[] toDependencies(Context context) {\n            return stream(required).map(context::get).map(Optional::get).toArray();\n        }\n        static &lt;Element extends Executable&gt; Injectable&lt;Element&gt; of(Element element) {\n            element.setAccessible(true);\n            return new Injectable&lt;&gt;(element, stream(element.getParameters()).map(Injectable::toComponentRef).toArray(ComponentRef&lt;?&gt;[]::new));\n        }\n        static Injectable&lt;Field&gt; of(Field field) {\n            field.setAccessible(true);\n            return new Injectable&lt;&gt;(field, new ComponentRef&lt;?&gt;[]{toComponentRef(field)});\n        }\n        private static ComponentRef&lt;?&gt; toComponentRef(Field field) {\n            return ComponentRef.of(field.getGenericType(), getQualifier(field));\n        }\n        private static ComponentRef&lt;?&gt; toComponentRef(Parameter parameter) {\n            return ComponentRef.of(parameter.getParameterizedType(), getQualifier(parameter));\n        }\n        private static Annotation getQualifier(AnnotatedElement element) {\n            List&lt;Annotation&gt; qualifiers = stream(element.getAnnotations())\n                    .filter(a -&gt; a.annotationType().isAnnotationPresent(Qualifier.class)).toList();\n            if (qualifiers.size() &gt; 1) throw ComponentError.ambiguousQualifiers(element, qualifiers);\n            return qualifiers.stream().findFirst().orElse(null);\n        }\n    }\n    private static &lt;T&gt; List&lt;Injectable&lt;Method&gt;&gt; getInjectMethods(Class&lt;T&gt; component) {\n        List&lt;Method&gt; injectMethods = traverse(component, (methods, current) -&gt; injectable(current.getDeclaredMethods())\n                .filter(m -&gt; isOverrideByInjectMethod(methods, m))\n                .filter(m -&gt; isOverrideByNoInjectMethod(component, m)).toList());\n        List&lt;Injectable&lt;Method&gt;&gt; injectableMethods = injectMethods.stream().map(Injectable::of).toList();\n        return check(component, injectableMethods, InjectionProvider::noTypeParameter, ComponentError::injectMethodsWithTypeParameter);\n    }\n    private static &lt;T&gt; List&lt;Injectable&lt;Field&gt;&gt; getInjectFields(Class&lt;T&gt; component) {\n        List&lt;Injectable&lt;Field&gt;&gt; injectableFields = InjectionProvider.&lt;Field&gt;traverse(component, (fields, current) -&gt; injectable(current.getDeclaredFields()).toList())\n                .stream().map(Injectable::of).toList();\n        return check(component, injectableFields, InjectionProvider::notFinal, ComponentError::finalInjectFields);\n    }\n    private static &lt;Type&gt; Injectable&lt;Constructor&lt;Type&gt;&gt; getInjectConstructor(Class&lt;Type&gt; implementation) {\n        if (Modifier.isAbstract(implementation.getModifiers())) throw abstractComponent(implementation);\n        List&lt;Constructor&lt;?&gt;&gt; injectConstructors = injectable(implementation.getDeclaredConstructors()).toList();\n        if (injectConstructors.size() &gt; 1) throw ambiguousInjectableConstructors(implementation);\n        return Injectable.of((Constructor&lt;Type&gt;) injectConstructors.stream().findFirst().orElseGet(() -&gt; defaultConstructor(implementation)));\n    }\n    private static &lt;Type&gt; Constructor&lt;Type&gt; defaultConstructor(Class&lt;Type&gt; implementation) {\n        try {\n            return implementation.getDeclaredConstructor();\n        } catch (NoSuchMethodException e) {\n            throw noDefaultConstructor(implementation);\n        }\n    }\n    private static &lt;E extends AccessibleObject&gt; Map&lt;Class&lt;?&gt;, List&lt;Injectable&lt;E&gt;&gt;&gt; groupByClass(List&lt;Injectable&lt;E&gt;&gt; injectFields) {\n        return injectFields.stream().collect(Collectors.groupingBy(i -&gt; ((Member)i.element()).getDeclaringClass(), Collectors.toList()));\n    }\n    private static Collection&lt;Class&lt;?&gt;&gt; allSuperClass(Class&lt;?&gt; component) {\n        List&lt;Class&lt;?&gt;&gt; result = new ArrayList&lt;&gt;();\n        for (Class superClass = component;\n             superClass != Object.class;\n             superClass = superClass.getSuperclass())\n            result.add(0, superClass);\n        return result;\n    }\n    private static &lt;T&gt; List&lt;T&gt; traverse(Class&lt;?&gt; component, BiFunction&lt;List&lt;T&gt;, Class&lt;?&gt;, List&lt;T&gt;&gt; finder) {\n        List&lt;T&gt; members = new ArrayList&lt;&gt;();\n        Class&lt;?&gt; current = component;\n        while (current != Object.class) {\n            members.addAll(finder.apply(members, current));\n            current = current.getSuperclass();\n        }\n        return members;\n    }\n    private static &lt;T extends AnnotatedElement&gt; Stream&lt;T&gt; injectable(T[] declaredFields) {\n        return stream(declaredFields).filter(f -&gt; f.isAnnotationPresent(Inject.class));\n    }\n    private static boolean isOverride(Method m, Method o) {\n        boolean visible;\n        if (m.getDeclaringClass().getPackageName().equals(o.getDeclaringClass().getPackageName()))\n            visible = !Modifier.isPrivate(o.getModifiers()) &amp;&amp; !Modifier.isPrivate(m.getModifiers());\n        else visible = (Modifier.isPublic(o.getModifiers()) || Modifier.isProtected(o.getModifiers()))\n                &amp;&amp; (Modifier.isPublic(m.getModifiers()) || Modifier.isProtected(m.getModifiers()));\n        return visible &amp;&amp; o.getName().equals(m.getName()) &amp;&amp; Arrays.equals(o.getParameterTypes(), m.getParameterTypes());\n    }\n    private static &lt;T&gt; boolean isOverrideByNoInjectMethod(Class&lt;T&gt; component, Method m) {\n        return stream(component.getDeclaredMethods()).filter(m1 -&gt; !m1.isAnnotationPresent(Inject.class)).noneMatch(o -&gt; isOverride(m, o));\n    }\n    private static boolean isOverrideByInjectMethod(List&lt;Method&gt; injectMethods, Method m) {\n        return injectMethods.stream().noneMatch(o -&gt; isOverride(m, o));\n    }\n    private static &lt;Element extends AccessibleObject&gt; List&lt;Injectable&lt;Element&gt;&gt; check(Class&lt;?&gt; component, List&lt;Injectable&lt;Element&gt;&gt; target, Predicate&lt;Element&gt; predicate,\n                                                                                      BiFunction&lt;Class&lt;?&gt;, List&lt;Element&gt;, ComponentError&gt; error) {\n        List&lt;Element&gt; found = target.stream().map(Injectable::element).filter(predicate).toList();\n        if (found.size() &gt; 0) throw error.apply(component, found.stream().toList());\n        return target;\n    }\n    private static boolean notFinal(Field field) {\n        return Modifier.isFinal(field.getModifiers());\n    }\n    private static boolean noTypeParameter(Method method) {\n        return method.getTypeParameters().length != 0;\n    }\n}\nclass ComponentError extends Error {\n    public static ComponentError abstractComponent(Class&lt;?&gt; component) {\n        return new ComponentError(MessageFormat.format(&quot;Can not be abstract: {0}&quot;, component));\n    }\n    public static ComponentError finalInjectFields(Class&lt;?&gt; component, Collection&lt;Field&gt; fields) {\n        return new ComponentError(MessageFormat.format(&quot;Injectable field can not be final: {0} in {1}&quot;,\n                String.join(&quot; , &quot;, fields.stream().map(Field::getName).toList()), component));\n    }\n    public static ComponentError injectMethodsWithTypeParameter(Class&lt;?&gt; component, Collection&lt;Method&gt; fields) {\n        return new ComponentError(MessageFormat.format(&quot;Injectable method can not have type parameter: {0} in {1}&quot;,\n                String.join(&quot; , &quot;, fields.stream().map(Method::getName).toList()), component));\n    }\n    public static ComponentError ambiguousInjectableConstructors(Class&lt;?&gt; component) {\n        return new ComponentError(MessageFormat.format(&quot;Ambiguous injectable constructors: {0}&quot;, component));\n    }\n    public static ComponentError noDefaultConstructor(Class&lt;?&gt; component) {\n        return new ComponentError(MessageFormat.format(&quot;No default constructors: {0}&quot;, component));\n    }\n    public static ComponentError ambiguousQualifiers(AnnotatedElement element, List&lt;Annotation&gt; qualifiers) {\n        Class&lt;?&gt; component;\n        if (element instanceof Parameter p) component = p.getDeclaringExecutable().getDeclaringClass();\n        else component = ((Field) element).getDeclaringClass();\n        return new ComponentError(MessageFormat.format(&quot;Ambiguous qualifiers: {0} on {1} of {2}&quot;,\n                String.join(&quot; , &quot;, qualifiers.stream().map(Object::toString).toList()), element, component));\n    }\n    ComponentError(String message) {\n        super(message);\n    }\n}\n    \nScopeProvider.java\n    \npackage geektime.tdd.di;\npublic interface ScopeProvider {\n    ComponentProvider&lt;?&gt; create(ComponentProvider&lt;?&gt; provider);\n}\n   \nSingletonProvider.java\n    \npackage geektime.tdd.di;\nimport java.util.List;\nclass SingletonProvider&lt;T&gt; implements ComponentProvider&lt;T&gt; {\n    private T singleton;\n    private ComponentProvider&lt;T&gt; provider;\n    public SingletonProvider(ComponentProvider&lt;T&gt; provider) {\n        this.provider = provider;\n    }\n    @Override\n    public T get(Context context) {\n        if (singleton == null) singleton = provider.get(context);\n        return singleton;\n    }\n    @Override\n    public List&lt;ComponentRef&lt;?&gt;&gt; getDependencies() {\n        return provider.getDependencies();\n    }\n}\n</code></pre><h2>æ€è€ƒé¢˜</h2><p>åœ¨è¿›å…¥ä¸‹èŠ‚è¯¾ä¹‹å‰ï¼Œå¸Œæœ›ä½ èƒ½è®¤çœŸæ€è€ƒå¦‚ä¸‹ä¸¤ä¸ªé—®é¢˜ã€‚</p><ol>\n<li>è¯·å¢åŠ staticæ³¨å…¥ï¼Œå¹¶é€šè¿‡Jakarta Inject TCKã€‚</li>\n<li>è¯·å›é¡¾æ•´ä¸ªé¡¹ç›®å®è·µï¼Œçœ‹çœ‹è·Ÿæœ€å¼€å§‹å­¦ä¹ TDDç›¸æ¯”ï¼Œéƒ½æœ‰å“ªäº›è¿›æ­¥å’Œæ”¹å˜ã€‚</li>\n</ol><p>ä¸æˆ‘ä»¬å®é™…å·¥ä½œä¸­çš„é¡¹ç›®ç›¸æ¯”ï¼ŒDI Containerè¿™ä¸ªæ¡†æ¶çº§å®æˆ˜çš„å¤æ‚åº¦è¦ç•¥å¾®é«˜ä¸€äº›ã€‚ç»è¿‡è¿™ä¸‰ä¸ªæœˆçš„å­¦ä¹ ï¼Œé™¤äº†æå‡ä½ çš„æŠ€æœ¯èƒ½åŠ›å¤–ï¼Œç›¸ä¿¡å¯¹ä½ çš„å­¦ä¹ èƒ½åŠ›ä¹Ÿæœ‰ä¸å°çš„ç£¨ç»ƒã€‚æ‰€ä»¥ï¼ŒåšæŒåˆ°è¿™ä¸€ç«™çš„åŒå­¦ä»¬ï¼Œè¯·ä¸ºè‡ªå·±ç‚¹ä¸ªèµå§ï¼</p>","neighbors":{"left":{"article_title":"34ï½œDI Containerï¼ˆ22ï¼‰ï¼šå¦‚ä½•å¯¹Bindçš„é€»è¾‘è¿›è¡Œé‡æ„ï¼Ÿ","id":521323},"right":{"article_title":"36ï½œå®æˆ˜ä¸­çš„TDDï¼šRESTful Web Services","id":522343}},"comments":[{"had_liked":false,"id":348200,"user_name":"æ«ä¸­çš„åˆ€å‰‘","can_delete":false,"product_type":"c1","uid":1322387,"ip_address":"","ucode":"4B086F538184AA","user_header":"https://static001.geekbang.org/account/avatar/00/14/2d/93/0f1cbf44.jpg","comment_is_top":false,"comment_ctime":1654843151,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654843151","product_id":100109401,"comment_content":"ç¬¬ä¸€æ¬¡é™è·ç¦»è§‚å¯Ÿä¸€ä¸ªå®Œæ•´é¡¹ç›®çš„TDDè¿‡ç¨‹ï¼Œæ„Ÿå—è¿˜æ˜¯æŒºæ·±çš„ã€‚ç‰¹åˆ«æ˜¯ç¬¬ä¸€æ¬¡æ¥è§¦åˆ°æµ‹è¯•é‡ç»„ã€æµ‹è¯•æ–‡æ¡£åŒ–çš„æ—¶å€™æœ‰ç§çœ¼å‰ä¸€äº®çš„æ„Ÿè§‰ã€‚è€Œå…¶ä¸­ComponentRef æ¨¡å‹å’Œ Qualifier æ¨¡å‹è°ƒæ•´çš„é‡æ„è¿‡ç¨‹æ›´åŠ è®©äººèµå¿ƒæ‚¦ç›®ã€‚æ–°çš„æ¨¡å‹å¼•å…¥æ‹“å±•äº†çŸ¥è¯†ï¼Œå¸¦æ¥ä¸ªæ›´åŠ æ˜ç¡®çš„åŠŸèƒ½ä¸Šä¸‹æ–‡åˆ’åˆ†ã€‚è€ŒåŸæœ‰æ•´ä½“çš„ç»“æ„å´æ²¡æœ‰å‘ç”Ÿå¤ªå¤šçš„å˜åŒ–ã€‚è¿™ç§ä¸€ç‚¹ç‚¹è¿›æ­¥æ˜¯èƒ½å¤Ÿå¾ˆæ¸…æ¥šçš„æ„Ÿå—åˆ°çš„ã€‚<br><br>æœ€ååœ¨é™„ä¸Šé¡¹ç›®é“¾æ¥ï¼šhttps:&#47;&#47;github.com&#47;maplestoryJin&#47;DiContainer  <br>åŒ…æ‹¬ static æ³¨å…¥å®ç°ã€‚","like_count":0},{"had_liked":false,"id":347875,"user_name":"ä¸´é£","can_delete":false,"product_type":"c1","uid":1145430,"ip_address":"","ucode":"59A7F3DDD94D76","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/56/29877cb9.jpg","comment_is_top":false,"comment_ctime":1654528963,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1654528963","product_id":100109401,"comment_content":"æœ‰ä¸ªå…³äºbindçš„å®ç°é—®é¢˜ï¼Œä¸€èˆ¬æƒ…å†µéƒ½æ˜¯bind(Component.class, Instance.class)æˆ–è€…bind(Component.class, Provider&lt;Instance.class&gt;)ã€‚å¦‚æœç›´æ¥bind(Instance.class, Instance.class)ï¼Œé‚£ä¹ˆget(Component.class)è¿˜èƒ½æ‰¾åˆ°å—ï¼Ÿ<br>å¦å¤–ï¼Œæ— è®ºbindçš„æ˜¯Intanceè¿˜æ˜¯Providerï¼Œå½“éœ€è¦æ³¨å…¥Providerç±»å‹çš„æ—¶å€™ï¼Œæ˜¯éƒ½éœ€è¦æ”¯æŒå—ï¼Ÿ<br>è¿™äº›è§„èŒƒçš„ä¸œè¥¿æˆ‘å¯ä»¥å»å“ªé‡Œæ‰¾åˆ°ï¼Œå¸Œæœ›è€å¸ˆèƒ½è§£ç­”ä¸€ä¸‹ã€‚","like_count":0},{"had_liked":false,"id":347710,"user_name":"å¼ é“æ—","can_delete":false,"product_type":"c1","uid":1108258,"ip_address":"","ucode":"4AB8BC6CDAC0A3","user_header":"https://static001.geekbang.org/account/avatar/00/10/e9/22/7606c6ba.jpg","comment_is_top":false,"comment_ctime":1654334362,"is_pvip":false,"replies":[{"id":"127875","content":"å¼€é˜”äº†çœ¼ç•Œï¼Œå¾ˆä¸é”™ğŸ‘","user_name":"ç¼–è¾‘å›å¤","user_name_real":"ç¼–è¾‘","uid":"2189689","ctime":1658043074,"ip_address":"","comment_id":347710,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1654334362","product_id":100109401,"comment_content":"ä¸»è¦è¿˜æ˜¯å¼€é˜”äº†çœ¼ç•Œï¼Œç”¨TDDæ¥åšä¸€ä¸ªç›¸å¯¹å¤æ‚çš„åŠŸèƒ½ï¼Œä¸åƒå¾ˆå¤škataé‚£æ ·ï¼ŒçŸ­çŸ­å‡ åè¡Œä»£ç é‡ï¼Œä½“ä¼šä¸åˆ°ä¸æ–­çš„é‡æ„å’Œæ·±è¿›ã€‚","like_count":0,"discussions":[{"author":{"id":2189689,"avatar":"https://static001.geekbang.org/account/avatar/00/21/69/79/b4132042.jpg","nickname":"ğŸ‘","note":"","ucode":"DE34B3B14287D1","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580252,"discussion_content":"å¼€é˜”äº†çœ¼ç•Œï¼Œå¾ˆä¸é”™ğŸ‘","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658043074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347588,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1654176164,"is_pvip":false,"replies":[{"id":"126711","content":"æˆ‘å†ç»™ä½ ç‚¹ä¸ªèµï¼åšæŒåˆ°è¿™é‡Œä¸å®¹æ˜“ï¼ç»§ç»­å˜æ²¹ï½","user_name":"ç¼–è¾‘å›å¤","user_name_real":"ç¼–è¾‘","uid":"2189689","ctime":1654182283,"ip_address":"","comment_id":347588,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1654176164","product_id":100109401,"comment_content":"è¿™æ¬¡è¦æ±‚ä¸­æœ€å®¹æ˜“åšåˆ°çš„å°±æ˜¯ä¸ºè‡ªå·±ç‚¹ä¸ªèµï¼Œæˆ‘å·²ç»ç‚¹äº†ï¼<br>æœ€å¼€å§‹å­¦ä¹  TDD ç›¸æ¯”ï¼šå­¦ä¼šä½¿ç”¨ @Nested æ ‡ç­¾ï¼›å­¦ä¼šäº†æ³›å‹ä¸­ ?ã€T ä¹‹ç±»çš„å«ä¹‰ï¼›æœ‰æµ‹è¯•åšä¿éšœæƒ³é‡æ„å°±é‡æ„","like_count":0,"discussions":[{"author":{"id":2189689,"avatar":"https://static001.geekbang.org/account/avatar/00/21/69/79/b4132042.jpg","nickname":"ğŸ‘","note":"","ucode":"DE34B3B14287D1","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574622,"discussion_content":"æˆ‘å†ç»™ä½ ç‚¹ä¸ªèµï¼åšæŒåˆ°è¿™é‡Œä¸å®¹æ˜“ï¼ç»§ç»­å˜æ²¹ï½","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1654182283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]}]}