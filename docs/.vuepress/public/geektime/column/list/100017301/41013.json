{"id":41013,"title":"06 | 链表（上）：如何实现LRU缓存淘汰算法?","content":"<p>今天我们来聊聊“链表（Linked list）”这个数据结构。学习链表有什么用呢？为了回答这个问题，我们先来讨论一个经典的链表应用场景，那就是LRU缓存淘汰算法。</p><p>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等等。</p><p>缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：先进先出策略FIFO（First In，First Out）、最少使用策略LFU（Least Frequently Used）、最近最少使用策略LRU（Least Recently Used）。</p><p>这些策略你不用死记，我打个比方你很容易就明白了。假如说，你买了很多本技术书，但有一天你发现，这些书太多了，太占书房空间了，你要做个大扫除，扔掉一些书籍。那这个时候，你会选择扔掉哪些书呢？对应一下，你的选择标准是不是和上面的三种策略神似呢？</p><p>好了，回到正题，我们今天的开篇问题就是：<strong><span class=\"orange\">如何用链表来实现LRU缓存淘汰策略呢？</span></strong> 带着这个问题，我们开始今天的内容吧！</p><h2>五花八门的链表结构</h2><p>相比数组，链表是一种稍微复杂一点的数据结构。对于初学者来说，掌握起来也要比数组稍难一些。这两个非常基础、非常常用的数据结构，我们常常会放到一块儿来比较。所以我们先来看，这两者有什么区别。</p><!-- [[[read_end]]] --><p>我们先从<strong>底层的存储结构</strong>上来看一看。</p><p>为了直观地对比，我画了一张图。从图中我们看到，数组需要一块<strong>连续的内存空间</strong>来存储，对内存的要求比较高。如果我们申请一个100MB大小的数组，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于100MB，仍然会申请失败。</p><p>而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组<strong>零散的内存块</strong>串联起来使用，所以如果我们申请的是100MB大小的链表，根本不会有问题。</p><p><img src=\"https://static001.geekbang.org/resource/image/d5/cd/d5d5bee4be28326ba3c28373808a62cd.jpg?wh=1142*699\" alt=\"\"></p><p>链表结构五花八门，今天我重点给你介绍三种最常见的链表结构，它们分别是：单链表、双向链表和循环链表。我们首先来看最简单、最常用的<strong>单链表</strong>。</p><p>我们刚刚讲到，链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的“<strong>结点</strong>”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。如图所示，我们把这个记录下个结点地址的指针叫作<strong>后继指针next</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/b9/eb/b93e7ade9bb927baad1348d9a806ddeb.jpg?wh=1142*399\" alt=\"\"></p><p>从我画的单链表图中，你应该可以发现，其中有两个结点是比较特殊的，它们分别是第一个结点和最后一个结点。我们习惯性地把第一个结点叫作<strong>头结点</strong>，把最后一个结点叫作<strong>尾结点</strong>。其中，头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个<strong>空地址NULL</strong>，表示这是链表上最后一个结点。</p><p>与数组一样，链表也支持数据的查找、插入和删除操作。</p><p>我们知道，在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是O(n)。而在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的。</p><p>为了方便你理解，我画了一张图，从图中我们可以看出，针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以对应的时间复杂度是O(1)。</p><p><img src=\"https://static001.geekbang.org/resource/image/45/17/452e943788bdeea462d364389bd08a17.jpg?wh=1142*650\" alt=\"\"></p><p>但是，有利就有弊。链表要想随机访问第k个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。</p><p>你可以把链表想象成一个队伍，队伍中的每个人都只知道自己后面的人是谁，所以当我们希望知道排在第k位的人是谁的时候，我们就需要从第一个人开始，一个一个地往下数。所以，链表随机访问的性能没有数组好，需要O(n)的时间复杂度。</p><p>好了，单链表我们就简单介绍完了，接着来看另外两个复杂的升级版，<strong>循环链表</strong>和<strong>双向链表</strong>。</p><p><strong>循环链表是一种特殊的单链表</strong>。实际上，循环链表也很简单。它跟单链表唯一的区别就在尾结点。我们知道，单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。从我画的循环链表图中，你应该可以看出来，它像一个环一样首尾相连，所以叫作“循环”链表。</p><p><img src=\"https://static001.geekbang.org/resource/image/86/55/86cb7dc331ea958b0a108b911f38d155.jpg?wh=1142*399\" alt=\"\"></p><p>和单链表相比，<strong>循环链表</strong>的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的<a href=\"https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98\">约瑟夫问题</a>。尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。</p><p>单链表和循环链表是不是都不难？接下来我们再来看一个稍微复杂的，在实际的软件开发中，也更加常用的链表结构：<strong>双向链表</strong>。</p><p>单向链表只有一个方向，结点只有一个后继指针next指向后面的结点。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针next指向后面的结点，还有一个前驱指针prev指向前面的结点。</p><p><img src=\"https://static001.geekbang.org/resource/image/cb/0b/cbc8ab20276e2f9312030c313a9ef70b.jpg?wh=1142*399\" alt=\"\"></p><p>从我画的图中可以看出来，双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。那相比单链表，双向链表适合解决哪种问题呢？</p><p>从结构上来看，双向链表可以支持O(1)时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。</p><p>你可能会说，我刚讲到单链表的插入、删除操作的时间复杂度已经是O(1)了，双向链表还能再怎么高效呢？别着急，刚刚的分析比较偏理论，很多数据结构和算法书籍中都会这么讲，但是这种说法实际上是不准确的，或者说是有先决条件的。我再来带你分析一下链表的两个操作。</p><p>我们先来看<strong>删除操作</strong>。</p><p>在实际的软件开发中，从链表中删除一个数据无外乎这两种情况：</p><ul>\n<li>\n<p>删除结点中“值等于某个给定值”的结点；</p>\n</li>\n<li>\n<p>删除给定指针指向的结点。</p>\n</li>\n</ul><p>对于第一种情况，不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再通过我前面讲的指针操作将其删除。</p><p>尽管单纯的删除操作时间复杂度是O(1)，但遍历查找的时间是主要的耗时点，对应的时间复杂度为O(n)。根据时间复杂度分析中的加法法则，删除值等于给定值的结点对应的链表操作的总时间复杂度为O(n)。</p><p>对于第二种情况，我们已经找到了要删除的结点，但是删除某个结点q需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，我们还是要从头结点开始遍历链表，直到p-&gt;next=q，说明p是q的前驱结点。</p><p>但是对于双向链表来说，这种情况就比较有优势了。因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要O(n)的时间复杂度，而双向链表只需要在O(1)的时间复杂度内就搞定了！</p><p>同理，如果我们希望在链表的某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。双向链表可以在O(1)时间复杂度搞定，而单向链表需要O(n)的时间复杂度。你可以参照我刚刚讲过的删除操作自己分析一下。</p><p>除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置p，每次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。</p><p>现在，你有没有觉得双向链表要比单链表更加高效呢？这就是为什么在实际的软件开发中，双向链表尽管比较费内存，但还是比单链表的应用更加广泛的原因。如果你熟悉Java语言，你肯定用过LinkedHashMap这个容器。如果你深入研究LinkedHashMap的实现原理，就会发现其中就用到了双向链表这种数据结构。</p><p>实际上，这里有一个更加重要的知识点需要你掌握，那就是<strong>用空间换时间</strong>的设计思想。当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用时间换空间的设计思路。</p><p>还是开篇缓存的例子。缓存实际上就是利用了空间换时间的设计思想。如果我们把数据存储在硬盘上，会比较节省内存，但每次查找数据都要询问一次硬盘，会比较慢。但如果我们通过缓存技术，事先将数据加载在内存中，虽然会比较耗费内存空间，但是每次数据查询的速度就大大提高了。</p><p>所以我总结一下，对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。你还能想到其他时间换空间或者空间换时间的例子吗？</p><p>了解了循环链表和双向链表，如果把这两种链表整合在一起就是一个新的版本：<strong>双向循环链表</strong>。我想不用我多讲，你应该知道双向循环链表长什么样子了吧？你可以自己试着在纸上画一画。</p><p><img src=\"https://static001.geekbang.org/resource/image/d1/91/d1665043b283ecdf79b157cfc9e5ed91.jpg?wh=1142*500\" alt=\"\"></p><h2>链表VS数组性能大比拼</h2><p>通过前面内容的学习，你应该已经知道，数组和链表是两种截然不同的内存组织方式。正是因为内存存储的区别，它们插入、删除、随机访问操作的时间复杂度正好相反。</p><p><img src=\"https://static001.geekbang.org/resource/image/4f/68/4f63e92598ec2551069a0eef69db7168.jpg?wh=1142*449\" alt=\"\"></p><p>不过，数组和链表的对比，并不能局限于时间复杂度。而且，在实际的软件开发中，不能仅仅利用复杂度分析就决定使用哪个数据结构来存储数据。</p><p>数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法有效预读。</p><p>数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。</p><p>你可能会说，我们Java中的ArrayList容器，也可以支持动态扩容啊？我们上一节课讲过，当我们往支持动态扩容的数组中插入一个数据时，如果数组中没有空闲空间了，就会申请一个更大的空间，将数据拷贝过去，而数据拷贝的操作是非常耗时的。</p><p>我举一个稍微极端的例子。如果我们用ArrayList存储了了1GB大小的数据，这个时候已经没有空闲空间了，当我们再插入数据的时候，ArrayList会申请一个1.5GB大小的存储空间，并且把原来那1GB的数据拷贝到新申请的空间上。听起来是不是就很耗时？</p><p>除此之外，如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java语言，就有可能会导致频繁的GC（Garbage Collection，垃圾回收）。</p><p>所以，在我们实际的开发中，针对不同类型的项目，要根据具体情况，权衡究竟是选择数组还是链表。</p><h2>解答开篇</h2><p>好了，关于链表的知识我们就讲完了。我们现在回过头来看下开篇留给你的思考题。如何基于链表实现LRU缓存淘汰算法？</p><p>我的思路是这样的：我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。</p><p>1.如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</p><p>2.如果此数据没有在缓存链表中，又可以分为两种情况：</p><ul>\n<li>\n<p>如果此时缓存未满，则将此结点直接插入到链表的头部；</p>\n</li>\n<li>\n<p>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</p>\n</li>\n</ul><p>这样我们就用链表实现了一个LRU缓存，是不是很简单？</p><p>现在我们来看下缓存访问的时间复杂度是多少。因为不管缓存有没有满，我们都需要遍历一遍链表，所以这种基于链表的实现思路，缓存访问的时间复杂度为O(n)。</p><p>实际上，我们可以继续优化这个实现思路，比如引入<strong>散列表</strong>（Hash table）来记录每个数据的位置，将缓存访问的时间复杂度降到O(1)。因为要涉及我们还没有讲到的数据结构，所以这个优化方案，我现在就不详细说了，等讲到散列表的时候，我会再拿出来讲。</p><p>除了基于链表的实现思路，实际上还可以用数组来实现LRU缓存淘汰策略。如何利用数组实现LRU缓存淘汰策略呢？我把这个问题留给你思考。</p><h2>内容小结</h2><p>今天我们讲了一种跟数组“相反”的数据结构，链表。它跟数组一样，也是非常基础、非常常用的数据结构。不过链表要比数组稍微复杂，从普通的单链表衍生出来好几种链表结构，比如双向链表、循环链表、双向循环链表。</p><p>和数组相比，链表更适合插入、删除操作频繁的场景，查询的时间复杂度较高。不过，在具体软件开发中，要对数组和链表的各种性能进行对比，综合来选择使用两者中的哪一个。</p><h2>课后思考</h2><p>如何判断一个字符串是否是回文字符串的问题，我想你应该听过，我们今天的题目就是基于这个问题的改造版本。如果字符串是通过单链表来存储的，那该如何来判断是一个回文串呢？你有什么好的解决思路呢？相应的时间空间复杂度又是多少呢？</p><p>欢迎留言和我分享，我会第一时间给你反馈。</p><hr><p><span class=\"orange\">我已将本节内容相关的详细代码更新到GitHub，<a href=\"https://github.com/wangzheng0822/algo\">戳此</a>即可查看。</span></p>","neighbors":{"left":{"article_title":"05 | 数组：为什么很多编程语言中数组都从0开始编号？","id":40961},"right":{"article_title":"07 | 链表（下）：如何轻松写出正确的链表代码？","id":41149}},"comments":[{"had_liked":true,"id":29919,"user_name":"Rain","can_delete":false,"product_type":"c1","uid":1238221,"ip_address":"","ucode":"6A270D922A3B9D","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","comment_is_top":true,"comment_ctime":1538609143,"is_pvip":false,"replies":[{"id":"10829","content":"同学，太爱你了。写的太好了！就喜欢你这样的，减轻了我很多回复留言的工作量。👍","user_name":"作者回复","comment_id":29919,"uid":"1190123","ip_address":"","utype":1,"ctime":1538658544,"user_name_real":"gg"}],"discussion_count":69,"race_medal":0,"score":"9.2233787643121992e+18","product_id":100017301,"comment_content":"Re Ydyhm:<br><br>“数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。” 这里的CPU缓存机制指的是什么？为什么就数组更好了？<br><br>----<br><br>我没有百度也没有Google。之前开发时遇到过，我斗胆说下。<br>CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块(这个大小我不太确定。。)并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义:为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入。<br><br>对于数组来说，存储空间是连续的，所以在加载某个下标的时候可以把以后的几个下标元素也加载到CPU缓存这样执行速度会快于存储空间不连续的链表存储。<br><br>大牛请指正哈！","like_count":1566,"discussions":[{"author":{"id":1152037,"avatar":"https://static001.geekbang.org/account/avatar/00/11/94/25/e58ac9f4.jpg","nickname":"存","note":"","ucode":"62B29AE46712BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":112638,"discussion_content":"多级缓存策略，L1L2L3，每次读取一个cache line，大小为64字节","likes_number":32,"is_delete":false,"is_hidden":false,"ctime":1577875879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1152037,"avatar":"https://static001.geekbang.org/account/avatar/00/11/94/25/e58ac9f4.jpg","nickname":"存","note":"","ucode":"62B29AE46712BF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":112680,"discussion_content":"手动点赞","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577878970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":112638,"ip_address":""},"score":112680,"extra":""},{"author":{"id":1982179,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/3e/e3/1cde2e58.jpg","nickname":"Mr.wang","note":"","ucode":"8EE65E086FF178","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1152037,"avatar":"https://static001.geekbang.org/account/avatar/00/11/94/25/e58ac9f4.jpg","nickname":"存","note":"","ucode":"62B29AE46712BF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268517,"discussion_content":"也有的是32个字节，好像可以配","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1589794727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":112638,"ip_address":""},"score":268517,"extra":""},{"author":{"id":1138792,"avatar":"https://static001.geekbang.org/account/avatar/00/11/60/68/540a9004.jpg","nickname":"戒修","note":"","ucode":"EAECD493E06B66","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1152037,"avatar":"https://static001.geekbang.org/account/avatar/00/11/94/25/e58ac9f4.jpg","nickname":"存","note":"","ucode":"62B29AE46712BF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268834,"discussion_content":"不同的CPU架构或版本有差异。不过每次都是操作一个cache line 是没错的。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1589820687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":112638,"ip_address":""},"score":268834,"extra":""}]},{"author":{"id":1299673,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d4/d9/c3296187.jpg","nickname":"airmy丶","note":"","ucode":"41959C9F5B4B65","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57336,"discussion_content":"从深入浅出计算机组成原理过来，为了充分利用CPU的高速缓存的高速访问，java的开源项目Disruptor就是通过缓存行填充这个策略来保持数据保持在CPU的高速缓存中。得益于CPU缓存从内存中加载数据是按块加载（也可以说一整个缓存行，看操作系统位数决定），数组的连续地址空间会一并加载到CPU的高速缓存中，访问速度和内存不是一个量级。","likes_number":26,"is_delete":false,"is_hidden":false,"ctime":1574598517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1299673,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d4/d9/c3296187.jpg","nickname":"airmy丶","note":"","ucode":"41959C9F5B4B65","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":57912,"discussion_content":"厉害👍🏻我也是从disruptor学的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574646189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":57336,"ip_address":""},"score":57912,"extra":""},{"author":{"id":1647744,"avatar":"","nickname":"Aiome","note":"","ucode":"6BE828AD03C86B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60744,"discussion_content":"+1  在看美团的一片技术文章将disruptor才知道的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574751387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":57912,"ip_address":""},"score":60744,"extra":""},{"author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1647744,"avatar":"","nickname":"Aiome","note":"","ucode":"6BE828AD03C86B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60948,"discussion_content":"Disruptor 可谓是将硬件用到了极致……线程和CPU 核心之间的亲和性都考虑到了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1574766416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":60744,"ip_address":""},"score":60948,"extra":""}]},{"author":{"id":1041217,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e3/41/abb7bfe3.jpg","nickname":"CozyThinker","note":"","ucode":"996D8B8C993C5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":139,"discussion_content":"原来如此：\nCPU缓存是加载一个内存数据块，数组是连续的内存，链表是非连续内存，所以数组里面的数据更可能被全部加载到缓存里面去，如此就更加友好啦","likes_number":15,"is_delete":false,"is_hidden":false,"ctime":1561168509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1691500,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cf/6c/87faa554.jpg","nickname":"MoeRookie","note":"","ucode":"E860D73EE91F00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1041217,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e3/41/abb7bfe3.jpg","nickname":"CozyThinker","note":"","ucode":"996D8B8C993C5C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328620,"discussion_content":"我累个槽   我就是这么想的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606196465,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":139,"ip_address":""},"score":328620,"extra":""},{"author":{"id":2890821,"avatar":"","nickname":"Geek_ad8cd9","note":"","ucode":"2187752C43FC31","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1041217,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e3/41/abb7bfe3.jpg","nickname":"CozyThinker","note":"","ucode":"996D8B8C993C5C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546216,"discussion_content":"局部性原理","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1642233480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":139,"ip_address":""},"score":546216,"extra":""}]},{"author":{"id":2067839,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/8d/7f/5a623195.jpg","nickname":"JustToFaith","note":"","ucode":"2E04AC5C418812","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292460,"discussion_content":"原来在大学里学的计算机组成原理还真的有用。","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1595233643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1263678,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er96OxUXwmONhgCAk2hpSkPqdQNuYpPC05JPeqZwL3pO0Aexom4CKj9vauXqMkZibPCIEbRNj6S6Cw/132","nickname":"NicholasKong","note":"","ucode":"AD35217CA0C76D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":138,"discussion_content":"Cache Line 是 Cache 与 DRAM 同步的最小单位. 典型的虚拟内存页面大小为 4KB,而典型的 Cache line 通常的大小为 32 或 64 字节","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1561166175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2419824,"avatar":"","nickname":"Geek_c11ea0","note":"","ucode":"82D5212A7C0175","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346312,"discussion_content":"和数据库一次IO读取一页数据到内存而不是读一行有点点相似","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1611906307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2419824,"avatar":"","nickname":"Geek_c11ea0","note":"","ucode":"82D5212A7C0175","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346842,"discussion_content":"学到了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612080246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":346312,"ip_address":""},"score":346842,"extra":""},{"author":{"id":2728400,"avatar":"https://static001.geekbang.org/account/avatar/00/29/a1/d0/785543e1.jpg","nickname":"xsl","note":"","ucode":"57B979684AFD53","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2419824,"avatar":"","nickname":"Geek_c11ea0","note":"","ucode":"82D5212A7C0175","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583529,"discussion_content":"我也想到了这个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660184211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":346312,"ip_address":"河南"},"score":583529,"extra":""}]},{"author":{"id":1255160,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/NnefngARTSPK2qLfYenRjDCNSv7NdGpia05NowusiarIvglJibkJn1WMnj2EzicgBay3XWbWpiaCfQJVr3PAeXcghzw/132","nickname":"民工哦","note":"","ucode":"6B6585EBBFC18A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250816,"discussion_content":"因为数组是连续的，所以下cpu内存寻址的时候是是在一块内存端里面顺序读取。\b链表的数据可能分散在多个内存端，寻址的时候会多做一些寻址计算，还有跨内存页，内存段读取数据。所以数组要快一些。","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1588041714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1022247,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","nickname":"阿卡牛","note":"","ucode":"0BC43A904C3199","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42909,"discussion_content":"其实里面有个空间局部性原理在起指导，如果没这个原理的话，试想，预取多的数据放入cpu，如果这些数据都不合适，cpu先判断缓存还是要再判断内存，耗时反而更多","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1572825364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2019760,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/d1/b0/f4e91c7b.jpg","nickname":"吴亦凡","note":"","ucode":"A785AD9C98D657","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392326,"discussion_content":"这个其实像mysql的预读机制，每页大小16k，如果连续读的页数超过配置阈值，会预加载后续的页数据，直接置入缓存中","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1630952968,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1240465,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ed/91/1d332031.jpg","nickname":"我能走多远","note":"","ucode":"07DF5D5DADFA3C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65092,"discussion_content":"做过dpdk和vpp的就知道cacheline的对齐的重要性。充分利用cache资源","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1574982530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2067660,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/8c/cc/f11a17d1.jpg","nickname":"Simon_real","note":"","ucode":"C84A03DCEA885A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367811,"discussion_content":"缓存的数据块是64个字节我好像记得，Redis中在选择集合实现的时候就是一定阈值内可以用压缩表和整数数组来实现，可以利用CPU缓存。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1618473967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1162862,"avatar":"https://static001.geekbang.org/account/avatar/00/11/be/6e/46a5da10.jpg","nickname":"Hong","note":"","ucode":"2E7FB03BFEC8F9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":317061,"discussion_content":"每次读取一个cacheline，一般512或256Byte","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1603503564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2528636,"avatar":"https://static001.geekbang.org/account/avatar/00/26/95/7c/cf4fc9e0.jpg","nickname":"Insolence","note":"","ucode":"9FE0AA6CA47724","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360351,"discussion_content":"空间局部性原理吧，操作系统有讲，看的王道论坛的咸鱼学长","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1616422161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014621,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/5d/559fb6a6.jpg","nickname":"去浪","note":"","ucode":"66DDFCC9C5D052","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286900,"discussion_content":"[高性能队列——Disruptor - 美团技术团队](https://tech.meituan.com/2016/11/18/disruptor.html)","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1593322164,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286830,"discussion_content":"题主想表达的是CPU缓存行+预读性原理的意思。可以这样理解：每次都取固定量数据（也就是缓存行），这种机制的底层理论是计算机预读性原理","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1593307069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1182372,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0a/a4/828a431f.jpg","nickname":"张申傲","note":"","ucode":"22D46BC529BA8A","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366534,"discussion_content":"所谓“局部性原理”","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1618107205,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2351829,"avatar":"https://static001.geekbang.org/account/avatar/00/23/e2/d5/c0b814ad.jpg","nickname":"stan","note":"","ucode":"F45B855C8BACD1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352007,"discussion_content":"这就是计算机组成原理里面讲的Cache缓存命中，cpu指标里面提到的一级缓存可能就是cpu缓存大小的这个说法吧","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1614565771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1990585,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/5f/b9/6dbac933.jpg","nickname":"Faddei","note":"","ucode":"0D31C24E4878B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342108,"discussion_content":"程序的局部性原理","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1610594826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194853,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3b/65/3a4fc8cf.jpg","nickname":"prepared","note":"","ucode":"00E54A5C7CDCBE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294697,"discussion_content":"每次读取 4k","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1595975871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1721718,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/45/76/2b1354f6.jpg","nickname":"张亚运","note":"","ucode":"2D0C667E0D7B07","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1194853,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3b/65/3a4fc8cf.jpg","nickname":"prepared","note":"","ucode":"00E54A5C7CDCBE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312049,"discussion_content":"是64个字节吧？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602574617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":294697,"ip_address":""},"score":312049,"extra":""}]},{"author":{"id":1359878,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLDuUeF7u9lAY3qmfKSfDBQzCJuveFVyIGE7D1PEI8ZQ1kTScwvRdruYHff0zpEnJWlsYicLlWGvcTg/132","nickname":"小虎","note":"","ucode":"66CCAB2C757B3C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41367,"discussion_content":"这条评论说的真好，让我想起了disquptor","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1572410169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1359878,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLDuUeF7u9lAY3qmfKSfDBQzCJuveFVyIGE7D1PEI8ZQ1kTScwvRdruYHff0zpEnJWlsYicLlWGvcTg/132","nickname":"小虎","note":"","ucode":"66CCAB2C757B3C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":44469,"discussion_content":"我当年就是学习disruptor的时候了解到的😇","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572952259,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":41367,"ip_address":""},"score":44469,"extra":""}]},{"author":{"id":1162527,"avatar":"https://static001.geekbang.org/account/avatar/00/11/bd/1f/e9fbc712.jpg","nickname":"嗨喽","note":"","ucode":"E13573559A50D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6484,"discussion_content":"cpu的空间局部","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1566918876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2707626,"avatar":"https://static001.geekbang.org/account/avatar/00/29/50/aa/dca4eb39.jpg","nickname":"慎始敬终","note":"","ucode":"4697B3FF562542","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589090,"discussion_content":"多线程下又会引来伪共享问题，导致并发性能降低。解决办法，就是填充缓存行，保证一个缓存行里只有一个变量值，这样既可以利用cpu的高速缓存，也不影响并发性能。disruptor的实现是这个思路吗？我的理解对吗？感谢老师的回答。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1664411830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"陕西"},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1213078,"avatar":"https://static001.geekbang.org/account/avatar/00/12/82/96/aa795685.jpg","nickname":"mghio","note":"","ucode":"74883EDE4FD0DC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392527,"discussion_content":"这就是著名的「局部性原理」","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1631028649,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2449748,"avatar":"https://static001.geekbang.org/account/avatar/00/25/61/54/5bf767e7.jpg","nickname":"没有心的人","note":"","ucode":"F27D5894087B11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1213078,"avatar":"https://static001.geekbang.org/account/avatar/00/12/82/96/aa795685.jpg","nickname":"mghio","note":"","ucode":"74883EDE4FD0DC","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":405725,"discussion_content":"空间局部性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634631027,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":392527,"ip_address":""},"score":405725,"extra":""}]},{"author":{"id":1046248,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f6/e8/2888c8e0.jpg","nickname":"许志浩","note":"","ucode":"E4232C8B76BE05","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381032,"discussion_content":"计算机组成原理中的cache","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1624872471,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2324722,"avatar":"https://static001.geekbang.org/account/avatar/00/23/78/f2/02eb3b5c.jpg","nickname":"j","note":"","ucode":"96BAF9A9524C9F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337317,"discussion_content":"读取硬盘或者内存中数据，最小单位是数据块，块的大小可以由程序指定","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1608872166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2216696,"avatar":"https://static001.geekbang.org/account/avatar/00/21/d2/f8/bb75ce47.jpg","nickname":"Conscious","note":"","ucode":"9863284FD5D18E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310899,"discussion_content":"好像是计算机组成原理那本书的分组映射思想  谢大佬","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1602119029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238865,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e7/51/9a357c5b.jpg","nickname":"Story","note":"","ucode":"433F18FA8E28F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309570,"discussion_content":"程序的空间和时间局部性原理","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1601350150,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1464493,"avatar":"https://static001.geekbang.org/account/avatar/00/16/58/ad/6abb57c4.jpg","nickname":"有爱有波哥","note":"","ucode":"DD9A023563151F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302280,"discussion_content":"虽然不连续，但是链表访问在缓存是不是就可以 直接就获取到？\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1598866575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1271370,"avatar":"https://static001.geekbang.org/account/avatar/00/13/66/4a/9c729924.jpg","nickname":"LSY","note":"","ucode":"59D35E80045224","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221978,"discussion_content":"程序局部最优性原理，之前在另外一个博文里看到","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1586090826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425779,"discussion_content":"同学，太爱你了。写的太好了！就喜欢你这样的，减轻了我很多回复留言的工作量。👍","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1538658544,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":4,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1344409,"avatar":"https://static001.geekbang.org/account/avatar/00/14/83/99/2a575595.jpg","nickname":"伽罗","note":"","ucode":"2F23F063F963BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387708,"discussion_content":"nice","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1628360541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1698551,"avatar":"https://static001.geekbang.org/account/avatar/00/19/ea/f7/d08ffd72.jpg","nickname":"公众号：技术能量站","note":"","ucode":"81FBCD0DEED201","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383592,"discussion_content":"之前在书上看到过，好像是并发编程之美","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626173806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2584721,"avatar":"https://static001.geekbang.org/account/avatar/00/27/70/91/e4729107.jpg","nickname":"山海观雾","note":"","ucode":"7EF8338024B5EE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370474,"discussion_content":"鸟哥的linux私房菜里边也有讲这个","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1619426307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2299542,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/FSk6ksZtTSAEKgsDRdLDEHibEPyjIFU2IQbSQnUSZmKbFSZtFyDtRhw1PAwlw3mRYSfC93bI5c5p0Agr6yvNv0A/132","nickname":"Geek_f144c2","note":"","ucode":"9CCFE862BB11BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352858,"discussion_content":"nice","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614870991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2428259,"avatar":"https://static001.geekbang.org/account/avatar/00/25/0d/63/db00fae4.jpg","nickname":"Johnson","note":"","ucode":"FA65861FEF221D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350180,"discussion_content":"cache命中机制？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1613737314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2428259,"avatar":"https://static001.geekbang.org/account/avatar/00/25/0d/63/db00fae4.jpg","nickname":"Johnson","note":"","ucode":"FA65861FEF221D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350523,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613902677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":350180,"ip_address":""},"score":350523,"extra":""}]},{"author":{"id":1382708,"avatar":"https://static001.geekbang.org/account/avatar/00/15/19/34/ae09b6d4.jpg","nickname":"无道","note":"","ucode":"3994A9DE7974BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341726,"discussion_content":"缓存行的概念吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610506095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2188198,"avatar":"https://static001.geekbang.org/account/avatar/00/21/63/a6/5b5879e7.jpg","nickname":"Wim","note":"","ucode":"82CDA3F0F0CC51","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334285,"discussion_content":"敢问一下大佬，实际的计算机系统是用数组还是链表实现缓存呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1607784513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2312849,"avatar":"https://static001.geekbang.org/account/avatar/00/23/4a/91/271128a2.jpg","nickname":"吕名洋","note":"","ucode":"B0FC85A0DF47FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2188198,"avatar":"https://static001.geekbang.org/account/avatar/00/21/63/a6/5b5879e7.jpg","nickname":"Wim","note":"","ucode":"82CDA3F0F0CC51","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334375,"discussion_content":"好像是链表+哈希表","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1607831400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":334285,"ip_address":""},"score":334375,"extra":""},{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2188198,"avatar":"https://static001.geekbang.org/account/avatar/00/21/63/a6/5b5879e7.jpg","nickname":"Wim","note":"","ucode":"82CDA3F0F0CC51","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340802,"discussion_content":"链表","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610163068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":334285,"ip_address":""},"score":340802,"extra":""}]},{"author":{"id":1099324,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c6/3c/8ab9deb0.jpg","nickname":"@许还真","note":"","ucode":"6D754D5AE44CEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333060,"discussion_content":"贊，cpu命中率","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1607425660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2223198,"avatar":"","nickname":"Geek_1d3fdc","note":"","ucode":"A9E79B272B3608","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311614,"discussion_content":"太赞了，谢谢分享","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602421315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1382708,"avatar":"https://static001.geekbang.org/account/avatar/00/15/19/34/ae09b6d4.jpg","nickname":"无道","note":"","ucode":"3994A9DE7974BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304250,"discussion_content":"是不是就是缓存行的概念","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599529888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2151836,"avatar":"https://static001.geekbang.org/account/avatar/00/20/d5/9c/842eda55.jpg","nickname":"一步两步","note":"","ucode":"B59D1F5293B5C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302021,"discussion_content":"是不是高速缓存呢，我记得能把相连数据放在高速缓存中","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598759990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2056201,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/60/09/a8e7913b.jpg","nickname":"SandCarving","note":"","ucode":"6B97DB71613A46","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295456,"discussion_content":"多谢你的指点迷津","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596198754,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1318633,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1e/e9/dcc63d8f.jpg","nickname":"怕什么，抱紧我","note":"","ucode":"CBCEA76E9EF33B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267223,"discussion_content":"多虑了:链表的内存空间不一定是零散的,也可以是连续的,数组的内存空间一定是连续的;\n当Cpu把内存的中的链表数据放到Cpu缓存中,完全可以开辟一个连续的空间来存放,和数据结构没有半点关系!","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589617569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1467619,"avatar":"https://static001.geekbang.org/account/avatar/00/16/64/e3/6e469d05.jpg","nickname":"braincy","note":"","ucode":"B1DE2447CD5102","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1318633,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1e/e9/dcc63d8f.jpg","nickname":"怕什么，抱紧我","note":"","ucode":"CBCEA76E9EF33B","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":282166,"discussion_content":"cpu可不管你的数据结构是什么，你就读那一个数据，cpu怎么把链表缓存","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1591897576,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":267223,"ip_address":""},"score":282166,"extra":""},{"author":{"id":1318633,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1e/e9/dcc63d8f.jpg","nickname":"怕什么，抱紧我","note":"","ucode":"CBCEA76E9EF33B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1467619,"avatar":"https://static001.geekbang.org/account/avatar/00/16/64/e3/6e469d05.jpg","nickname":"braincy","note":"","ucode":"B1DE2447CD5102","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283535,"discussion_content":"cpu不管，但是数据结构是要放cpu缓存的吧！例如遍历链表！难道我遍历一次，去内存读取一次？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592292708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":282166,"ip_address":""},"score":283535,"extra":""}]},{"author":{"id":1294797,"avatar":"https://static001.geekbang.org/account/avatar/00/13/c1/cd/cdb510ae.jpg","nickname":"向科","note":"","ucode":"6EFC2C4FB11A24","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206163,"discussion_content":"你说的这个是内存和CPU之间缓存的机制，","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584369879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1212873,"avatar":"https://static001.geekbang.org/account/avatar/00/12/81/c9/9194612b.jpg","nickname":"百里","note":"","ucode":"2CE96129AA7F78","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":23026,"discussion_content":"内存与cpu数据置换采取不同策略，LRU就是其中的一种。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1569743243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1843371,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK5dh80UCnDwic7jHWRGVMbqFBjFbBAKO4bqzB5Sr39iaib5JPmF3d06dV1ibXHflNdQKgcKBsEkfXc6g/132","nickname":"Geek_16e01a","note":"","ucode":"791D5AA6BAA018","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586834,"discussion_content":"一次读取4KB的数据应该是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662535317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江"},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2699316,"avatar":"https://static001.geekbang.org/account/avatar/00/29/30/34/2c487821.jpg","nickname":"HashWky","note":"","ucode":"3F95646EA9725A","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584049,"discussion_content":"程序局部性原理，时间局部性和空间局部性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660575699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖北"},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1699086,"avatar":"https://static001.geekbang.org/account/avatar/00/19/ed/0e/155a6ef4.jpg","nickname":"万歳","note":"","ucode":"6C86DB96A14BF1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547209,"discussion_content":"相对于计算机组成原理中的多级cache？解决cpu与内存速度不一致的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642580749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2846365,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/6e/9d/a25fd7aa.jpg","nickname":"西出阳关无故人。","note":"","ucode":"313CB207438AE2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534732,"discussion_content":"不过，也要看具体对数组元素的访问顺序，这样才能命中cache","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638264355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2821728,"avatar":"","nickname":"600988292","note":"","ucode":"24BAE2B7A7B1E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":410308,"discussion_content":"计组和OS中的东西","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635658136,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1298448,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d0/10/f335c006.jpg","nickname":"阿启阿南","note":"","ucode":"CA11E4A187E820","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49682,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573620242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":7,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29883,"user_name":"andavid","can_delete":false,"product_type":"c1","uid":1018739,"ip_address":"","ucode":"4CA32B155A682F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8b/73/5d4dca26.jpg","comment_is_top":true,"comment_ctime":1538579078,"is_pvip":false,"replies":[{"id":"10839","content":"思路正确，不过空间复杂度计算的不对，应该是O(1)，不是O(n)。我们要看额外的内存消耗，不是看链表本身存储需要多少空间。","user_name":"作者回复","comment_id":29883,"uid":"1190123","ip_address":"","utype":1,"ctime":1538659791,"user_name_real":"gg"}],"discussion_count":31,"race_medal":0,"score":"9.2233738895242998e+18","product_id":100017301,"comment_content":"思考题：<br><br>使用快慢两个指针找到链表中点，慢指针每次前进一步，快指针每次前进两步。在慢指针前进的过程中，同时修改其 next 指针，使得链表前半部分反序。最后比较中点两侧的链表是否相等。<br><br>时间复杂度：O(n)<br>空间复杂度：O(1)<br><br>https:&#47;&#47;github.com&#47;andavid&#47;leetcode-java&#47;blob&#47;master&#47;note&#47;234&#47;README.md","like_count":431,"discussions":[{"author":{"id":2641303,"avatar":"https://static001.geekbang.org/account/avatar/00/28/4d/97/1d99a0a3.jpg","nickname":"柒城","note":"","ucode":"CAC7861175232A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377071,"discussion_content":"前半部分压栈。然后再取出来和后面的对比。","likes_number":19,"is_delete":false,"is_hidden":false,"ctime":1622476600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2370758,"avatar":"https://static001.geekbang.org/account/avatar/00/24/2c/c6/416bd86e.jpg","nickname":"阿杰","note":"","ucode":"B9C504269C8CD3","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338136,"discussion_content":"看了这位大佬写的代码，感觉太赞了。\n写一下心得体会：\n1.原来用JAVA实现链表的数据结构是这么个写法，把每个链表节点当做一个对象封装成一个类，然后包含对下一节点的指向，传链表的时候，只需要把该链表的头节点传过来就好，而不需要传递所有的节点过来（相当于传数组其实也只是传递了数组的基地址过来一样，而并不需要传递整个数组元素）。\n2.快慢节点找中点有点优秀，如果是奇数快节点正好处于fast.next=null的状态，此时slow处于最中间的位置，如果是偶数slow处（len/2）+1（从1开始计数）的位置  此时fast=null，且如果是奇数（fast.next=null fast不等于null的情况 让slow多next一下为了把中点给“过了”。\n3.走的时候，用prev记录slow的上一个节点，并且把中点前的每个节点的next都指向上一个元素，做到前半部分（后节点->前节点）和后半部分（中点以后 前节点->后节点）以相反的方向指向。\n4.达到临界值也就是slow过了中点，循环比较前半部分（因为前半部分已经逆序且prev指在了中点以前的前一个位置  所以prev相当于前半部分head）和后半部分（slow已经指在了后半部分的head位置），因此循环比较此两部分即可，一直到slow.next=null","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1609199079,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1128318,"avatar":"https://static001.geekbang.org/account/avatar/00/11/37/7e/219dd994.jpg","nickname":"liuyong","note":"","ucode":"D68555E8057F6E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21391,"discussion_content":"一个判断回文的操作，把原始数据修改掉也行？","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1569475695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1714081,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJu4p8ZheJ4KCLo6gI6VficSp1U4XCicfquprCavib6Xm0iaoXuwlLDgXxcosUSfiawfE1qFZhp9TG86Rg/132","nickname":"Geek_ttjjttjj","note":"","ucode":"6FE6FC8BBF0EBC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":157997,"discussion_content":"看了代码也撸了一下，测试奇偶ok，赞","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1580539876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425756,"discussion_content":"思路正确，不过空间复杂度计算的不对，应该是O(1)，不是O(n)。我们要看额外的内存消耗，不是看链表本身存储需要多少空间。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1538659791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1768852,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/fd/94/8704d2b0.jpg","nickname":"spoofer","note":"","ucode":"6723F64ACC3F27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330884,"discussion_content":"不能改变原指针吧，如果改变了，那么这个字符串就不支持并发访问了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1606726563,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1162527,"avatar":"https://static001.geekbang.org/account/avatar/00/11/bd/1f/e9fbc712.jpg","nickname":"嗨喽","note":"","ucode":"E13573559A50D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6485,"discussion_content":"不错，这种思路在判断链表是否有环差不多","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1566918998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1073369,"avatar":"https://static001.geekbang.org/account/avatar/00/10/60/d9/829ac53b.jpg","nickname":"fangxuan","note":"","ucode":"3870F2BF5679A2","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1639,"discussion_content":"实现的很棒！反转后半段链表，不用对slow指针做特殊处理，但是需要遍历两遍链表","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1562751967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1686198,"avatar":"https://static001.geekbang.org/account/avatar/00/19/ba/b6/cafb4000.jpg","nickname":"yym","note":"","ucode":"A21FF2C7FA1501","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1073369,"avatar":"https://static001.geekbang.org/account/avatar/00/10/60/d9/829ac53b.jpg","nickname":"fangxuan","note":"","ucode":"3870F2BF5679A2","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":133718,"discussion_content":"问一下,为什么是反转后半段链表?这个代码的实现,我看是3根指针,slow,fast都是从头跑到尾,prev是反转前半段链表的指针,最后是slow的后半段和prev进行比较,为啥是后半段反转?","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578983289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":1639,"ip_address":""},"score":133718,"extra":""}]},{"author":{"id":1018739,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/73/5d4dca26.jpg","nickname":"andavid","note":"","ucode":"4CA32B155A682F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62958,"discussion_content":"https://andavid.github.io/leetcode-java/note/234/","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574864642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1122121,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1f/49/e4ab004b.jpg","nickname":"波拉拉","note":"","ucode":"586F66351219E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514,"discussion_content":"。。。这个思路很清晰，可是测试起来。。。不知怎么测。。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1561628561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2297351,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Urru5Bvib5z8SjmiacqY8SyjUXpIVNu27fH7H8vvxibbiaHOtUulNW8kQNuTibOFGG8jiay99EcD339jBqf1Mm2fqNwQ/132","nickname":"Geek_97d956","note":"","ucode":"D4FAC98907E1D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1122121,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1f/49/e4ab004b.jpg","nickname":"波拉拉","note":"","ucode":"586F66351219E8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542514,"discussion_content":"class PalindromeLinkedListDemo {\n\n    public static void main(String[] args) {\n        ListNodeList listNodeList = new ListNodeList();\n        listNodeList.add(new ListNode(1));\n        listNodeList.add(new ListNode(2));\n        listNodeList.add(new ListNode(3));\n        listNodeList.add(new ListNode(4));\n        listNodeList.add(new ListNode(4));\n        listNodeList.add(new ListNode(3));\n        listNodeList.add(new ListNode(2));\n        listNodeList.add(new ListNode(1));\n\n        boolean palindrome = listNodeList.isPalindrome();\n        System.out.println(&#34;palindrome = &#34; + palindrome);\n    }\n\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640770611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":514,"ip_address":""},"score":542514,"extra":""},{"author":{"id":2297351,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Urru5Bvib5z8SjmiacqY8SyjUXpIVNu27fH7H8vvxibbiaHOtUulNW8kQNuTibOFGG8jiay99EcD339jBqf1Mm2fqNwQ/132","nickname":"Geek_97d956","note":"","ucode":"D4FAC98907E1D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1122121,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1f/49/e4ab004b.jpg","nickname":"波拉拉","note":"","ucode":"586F66351219E8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542515,"discussion_content":"public class ListNodeList {\n\n    private ListNode head = null;\n\n\n    public void add(ListNode node) {\n        if (head == null) {\n            this.head = node;\n            return;\n        }\n        //当我们想添加节点时,肯定是在当前链表的最后一个节点后面添加节点,而最后一个节点的数据Data有数据,next的指向为null\n        ListNode temp = head; //用于遍历时指向每个被遍历的节点(指针),从头节点开始\n        //遍历链表\n        while (true) {\n            //找到链表的最后\n            if (temp.next == null) {\n                break;\n            }\n            //没有到最后,将temp指针后移\n            temp = temp.next;\n        }\n        //当退出while循环时,temp就指向了链表的最后\n        temp.next = node;\n    }\n\n    /**\n     * 判断是否是回文字符串\n     *\n     * @param\n     * @return\n     */\n    public boolean isPalindrome() {\n        if (head == null || head.next == null) {\n            return true;\n        }\n\n        // 定义快指针和慢指针，以及一个逆向指针\n        ListNode prev = null;\n        ListNode slow = head;\n        ListNode fast = head;\n\n        // 快指针一次两步，慢指针一次一步，当快指针走完时，慢指针走到中点位置\n        while (fast != null &amp;&amp; fast.next != null) {\n            fast = fast.next.next;\n            ListNode next = slow.next;\n            // 把慢指针的next赋成prev，再把当前慢指针记录为prev，慢指针向后移动\n            // 作用：将前半部分链表逆序\n            slow.next = prev;\n            prev = slow;\n            slow = next;\n        }\n        // 经过上面遍历，slow正好在中心点且前半部分都为逆序，将其赋给一个新指针进行反向遍历\n        // 当fast不为null时，说明链表长度为奇数，slow正好在中心点，需要从中心点后一位开始判断\n        if (fast != null) {\n            slow = slow.next;\n        }\n        // 遍历两个指针，比较对应元素值是否相等\n        while (slow != null) {\n            if (slow.val != prev.val) {\n                return false;\n            }\n            slow = slow.next;\n            prev = prev.next;\n        }\n\n        return true;\n    }\n}","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1640770644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":514,"ip_address":""},"score":542515,"extra":""}]},{"author":{"id":1122121,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1f/49/e4ab004b.jpg","nickname":"波拉拉","note":"","ucode":"586F66351219E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505,"discussion_content":"看了代码，很有启发，感谢🙏","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1561624018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1168127,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/ff/99d2e7f5.jpg","nickname":"|G. XIAO|","note":"","ucode":"75DA0B3047A2F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1122121,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1f/49/e4ab004b.jpg","nickname":"波拉拉","note":"","ucode":"586F66351219E8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2875,"discussion_content":"看的什么代码？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564013938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":505,"ip_address":""},"score":2875,"extra":""},{"author":{"id":1018739,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/73/5d4dca26.jpg","nickname":"andavid","note":"","ucode":"4CA32B155A682F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1168127,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/ff/99d2e7f5.jpg","nickname":"|G. XIAO|","note":"","ucode":"75DA0B3047A2F0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4108,"discussion_content":"https://github.com/andavid/leetcode-java/blob/master/note/234/README.md\n\n这个链接里面有 Java 实现代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565140134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2875,"ip_address":""},"score":4108,"extra":""}]},{"author":{"id":1183518,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0f/1e/6b6eb987.jpg","nickname":"我们在路上","note":"","ucode":"0DB77DB7C64C47","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583335,"discussion_content":"使用首尾指针，一起向中点进发，判断每一个字符是否相等，直到指针重合","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660039754,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2914259,"avatar":"","nickname":"Geek_c2a2be","note":"","ucode":"ECAE3C732915CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559107,"discussion_content":"如果在已构建的链表上做操作，那还不如数组呢\nfunc isPalindrome(bs []byte) bool  {\n\tif len(bs) &lt;= 0 || len(bs) == 1 {\n\t\treturn true\n\t}\n\n\ti, j := 0, len(bs) -1\n\tfor i &lt; j {\n\t\tif bs[i] != bs[j] {\n\t\t\treturn false\n\t\t}\n\t\t\n\t\ti++\n\t\tj--\n\t}\n\t\n\treturn true\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648611481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2842127,"avatar":"","nickname":"沈振国","note":"","ucode":"592A403CBA43D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530730,"discussion_content":"「快慢指针」是指设定两个指针，其中快的指针的移动速度是慢的指针的移动速度的两倍；“快慢指针”方法主要用来解决两类问题，即“判断一个链表是否为循环链表”以及“寻找一个有序链表的中位数”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637135589,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2154488,"avatar":"https://static001.geekbang.org/account/avatar/00/20/df/f8/e17f8ab5.jpg","nickname":"魏汉武","note":"","ucode":"D65B21B01202D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389335,"discussion_content":"如果想把前半部分逆序就得重新申请节点去存储，否则就改变原结构了，随意空间复杂度还是O(n)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629242934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1326199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/3c/77/9d90e9b1.jpg","nickname":"Richard","note":"","ucode":"860BEEAE94A8C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2154488,"avatar":"https://static001.geekbang.org/account/avatar/00/20/df/f8/e17f8ab5.jpg","nickname":"魏汉武","note":"","ucode":"D65B21B01202D4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411049,"discussion_content":"我没看链接中的内容, 就是单纯尝试解答你的疑问, 方便后面看到的有同样疑问的同学.\n快慢指针找到单链表的中点, 在慢指针出发到找到中点的过程中将单链表的前半部分逆序(单链表反转), 然后遍历判断前半段和后半段每个节点的值是否相等(判断是否回文); 最后再将上面逆序的前半部分链表顺序恢复. 在整个过程中只是增加了几个有限的变量, 没有申请额外的空间所以空间复杂度是: O(1).","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1635838141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":389335,"ip_address":""},"score":411049,"extra":""}]},{"author":{"id":1397631,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKVUskibDnhMt5MCIJ8227HWkeg2wEEyewps8GuWhWaY5fy7Ya56bu2ktMlxdla3K29Wqia9efCkWaQ/132","nickname":"衬衫的价格是19美元","note":"","ucode":"655F925451F772","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307734,"discussion_content":"最后再把前半段反过来恢复原样就行了，时间复杂度还是O(n)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600745875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1397631,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKVUskibDnhMt5MCIJ8227HWkeg2wEEyewps8GuWhWaY5fy7Ya56bu2ktMlxdla3K29Wqia9efCkWaQ/132","nickname":"衬衫的价格是19美元","note":"","ucode":"655F925451F772","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312374,"discussion_content":"假如不是回文呢？怎么还原？再倒一下？O（2n）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602671828,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":307734,"ip_address":""},"score":312374,"extra":""},{"author":{"id":1523907,"avatar":"https://static001.geekbang.org/account/avatar/00/17/40/c3/2f673a37.jpg","nickname":"玉順","note":"","ucode":"A7290E57AA1F13","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327323,"discussion_content":"O(2n) = O(n)","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605790919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312374,"ip_address":""},"score":327323,"extra":""}]},{"author":{"id":1068724,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4e/b4/335e58d6.jpg","nickname":"华新","note":"","ucode":"B6DB20898F5F99","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":183952,"discussion_content":"这样岂不是修改了原字符串内容，在不改变原有内容的情况下呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582535769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1730576,"avatar":"","nickname":"27","note":"","ucode":"B5D7A54EA47206","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1068724,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4e/b4/335e58d6.jpg","nickname":"华新","note":"","ucode":"B6DB20898F5F99","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":210922,"discussion_content":"不改变原有内容，借助栈， 空间复杂度O(n) 时间复杂度O(n) + O(n) = O(n)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584791334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":183952,"ip_address":""},"score":210922,"extra":""},{"author":{"id":1730576,"avatar":"","nickname":"27","note":"","ucode":"B5D7A54EA47206","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1068724,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4e/b4/335e58d6.jpg","nickname":"华新","note":"","ucode":"B6DB20898F5F99","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":210925,"discussion_content":"借助栈2：快慢指针找中点 同时前半段入栈 ， 只需要一次遍历即可完成， 时间复杂度O（n）空间复杂度O（n/2）= O(n)","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1584791527,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":183952,"ip_address":""},"score":210925,"extra":""},{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1730576,"avatar":"","nickname":"27","note":"","ucode":"B5D7A54EA47206","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379440,"discussion_content":"这思路不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623904233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":210925,"ip_address":""},"score":379440,"extra":""}]},{"author":{"id":1744376,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/9d/f8/bb4ab0d9.jpg","nickname":"Blmyun","note":"","ucode":"E9C4B814E93F28","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65626,"discussion_content":"老师的回复我没弄明白.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575016549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1018739,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/73/5d4dca26.jpg","nickname":"andavid","note":"","ucode":"4CA32B155A682F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1744376,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/9d/f8/bb4ab0d9.jpg","nickname":"Blmyun","note":"","ucode":"E9C4B814E93F28","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":66913,"discussion_content":"老师应该是看串了","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1575115809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":65626,"ip_address":""},"score":66913,"extra":""}]},{"author":{"id":1042685,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/fd/abb7bfe3.jpg","nickname":"Langzi233","note":"","ucode":"5A21AC08FC089B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3777,"discussion_content":"中间位置和链表的个数以及单步先走还是双步先有有关","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564803746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29830,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":true,"comment_ctime":1538555504,"is_pvip":false,"replies":[{"id":"10720","content":"回答的很好！👍","user_name":"作者回复","comment_id":29830,"uid":"1190123","ip_address":"","utype":1,"ctime":1538581540,"user_name_real":"gg"}],"discussion_count":7,"race_medal":0,"score":"9.2233730262357996e+18","product_id":100017301,"comment_content":"1 快慢指针定位中间节点<br>2 从中间节点对后半部分逆序<br>3 前后半部分比较，判断是否为回文<br>4 后半部分逆序复原<br><br>时间复杂度On, 空间复杂度O1<br>把LRU和回文都实现了一遍~~<br><br>如果是双向链表，时间效率更高，看了下LinkedList，底层也是用双向链表实现","like_count":230,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425732,"discussion_content":"回答的很好！👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538581540,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2890949,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/1c/c5/3df9fa5e.jpg","nickname":"路远","note":"","ucode":"46DCE2D12D38C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545969,"discussion_content":"小白百度：快慢指针是指设定两个指针，其中快的指针的移动速度是慢的指针的移动速度的两倍；“快慢指针”方法主要用来解决两类问题，即“判断一个链表是否为循环链表”以及“寻找一个有序链表的中位数”","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1642114844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2275817,"avatar":"https://static001.geekbang.org/account/avatar/00/22/b9/e9/19cd7d9c.jpg","nickname":"落","note":"","ucode":"79525752D3A1B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374066,"discussion_content":"大佬，为啥空间复杂度是O(1),存所有数据不就用了O(n)了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620984733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1801420,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/7c/cc/20cfb337.jpg","nickname":"YB","note":"","ucode":"C6D60343C3DB6D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2275817,"avatar":"https://static001.geekbang.org/account/avatar/00/22/b9/e9/19cd7d9c.jpg","nickname":"落","note":"","ucode":"79525752D3A1B1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375368,"discussion_content":"看额外内存消耗，已有的内存不算","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621589101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":374066,"ip_address":""},"score":375368,"extra":""}]},{"author":{"id":1935158,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/87/36/0b115475.jpg","nickname":"Ryan李","note":"","ucode":"F425B420DDE254","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223481,"discussion_content":"这个方法怎么实现LRU了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586229397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1926508,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/65/6c/be97a3ae.jpg","nickname":"Geek_bb2310","note":"","ucode":"022885B257DEB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1935158,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/87/36/0b115475.jpg","nickname":"Ryan李","note":"","ucode":"F425B420DDE254","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":257545,"discussion_content":"不是啊\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588586701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":223481,"ip_address":""},"score":257545,"extra":""}]},{"author":{"id":1019807,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8f/9f/e49b68ea.jpg","nickname":"幽弥狂","note":"","ucode":"5AECEA7D6ADF33","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214939,"discussion_content":"简单精炼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585246793,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31589,"user_name":"glbfor.gtw","can_delete":false,"product_type":"c1","uid":1225344,"ip_address":"","ucode":"20BAD3CB52366F","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/80/e9223398.jpg","comment_is_top":true,"comment_ctime":1539239466,"is_pvip":false,"replies":[{"id":"11381","content":"👍 回答的非常好","user_name":"作者回复","comment_id":31589,"uid":"1190123","ip_address":"","utype":1,"ctime":1539256305,"user_name_real":"gg"}],"discussion_count":9,"race_medal":0,"score":"9.2233725537900995e+18","product_id":100017301,"comment_content":"1 快慢指针定位中间节点（这里要区分奇偶情况）<br>1.1 奇数情况，中点位置不需要矫正<br>1.2 偶数情况，使用偶数定位中点策略，要确定是返回上中位数或下中位数<br>1.2.1 如果是返回上中位数，后半部分串头取next<br>1.2.2 如果是返回下中位数，后半部分串头既是当前节点位置，但前半部分串尾要删除掉当前节点<br>2 从中间节点对后半部分逆序，或者将前半部分逆序<br>3 一次循环比较，判断是否为回文<br>4 恢复现场<br><br>题外话，这种操作有点BT啊？实际运用场景中，也真的直接改变引用值吗？至少在多线程情况，要加N多锁（Read Write都要加锁），这个时间成本就不能简单用时间复杂度来衡量了。如果是用copy 机制，不论是倒置前半段还是后半段，至少有一段是需要n&#47;2个节点副本的空间消耗的，那么空间复杂度就是O（n）？？啦~跑题了，跑题了~~<br><br>老师，你给我评价被~ 我比较容易钻牛角尖。。<br>","like_count":120,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426419,"discussion_content":"👍 回答的非常好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539256305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":160680,"discussion_content":"现实中如果是单链表，直接反转整个单链表，然后循环比较相同位置上的值，这样简单粗暴也管用，时间复杂度O(n)，空间复杂度O(n)","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1580823366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1295609,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRFRX8kNzNet7FibNvtavbVpAwK09AhIhrib9k762qWtH6mre8ickP7hM5mgZC4ytr8NnmIfmAhxMSQ/132","nickname":"老大不小","note":"","ucode":"35BCDD3CB13467","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580058,"discussion_content":"我理解是需要从原链表拷贝成新链表，然后新链表反转，再和原链表相同位置做对比对吧。\n这种空间复杂度确实是O(n)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657853883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":160680,"ip_address":""},"score":580058,"extra":""}]},{"author":{"id":1283461,"avatar":"https://static001.geekbang.org/account/avatar/00/13/95/85/15cd21c2.jpg","nickname":"杨锋","note":"","ucode":"85A7828A538FB0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274608,"discussion_content":"回文不存在偶数吧。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590593888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2247846,"avatar":"https://static001.geekbang.org/account/avatar/00/22/4c/a6/81c0ed8a.jpg","nickname":"晨曦感恩","note":"","ucode":"ED2324D6057575","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1283461,"avatar":"https://static001.geekbang.org/account/avatar/00/13/95/85/15cd21c2.jpg","nickname":"杨锋","note":"","ucode":"85A7828A538FB0","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":352699,"discussion_content":"叠词都是啊，比如“星星”，“点点”等","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614822118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":274608,"ip_address":""},"score":352699,"extra":""}]},{"author":{"id":1042685,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/fd/abb7bfe3.jpg","nickname":"Langzi233","note":"","ucode":"5A21AC08FC089B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3729,"discussion_content":"不对，应该是如果快指针先走，那么慢指针处于上中位，反之也是下中位","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564736042,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1339586,"avatar":"https://static001.geekbang.org/account/avatar/00/14/70/c2/0df5cc71.jpg","nickname":"Melon","note":"","ucode":"8E4A96B3BA0239","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369172,"discussion_content":"这个细节在写代码的时候要着重考虑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618967525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1372744,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f2/48/d5b30171.jpg","nickname":"凤梨酥","note":"","ucode":"1049FF29532AA0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57360,"discussion_content":"实际情况我猜双向循环链表就完了，不会这么奇葩","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574600806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042685,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/fd/abb7bfe3.jpg","nickname":"Langzi233","note":"","ucode":"5A21AC08FC089B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3728,"discussion_content":"偶数的话，快指针先达到尾部的时候慢指针应该处于上中位数。感谢能想到这么好的思路，还给出关键细节","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564735790,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30891,"user_name":"sky","can_delete":false,"product_type":"c1","uid":1060892,"ip_address":"","ucode":"B29CA98AC45F88","user_header":"https://static001.geekbang.org/account/avatar/00/10/30/1c/e160955d.jpg","comment_is_top":true,"comment_ctime":1539044544,"is_pvip":false,"replies":[{"id":"11095","content":"对的！👍","user_name":"作者回复","comment_id":30891,"uid":"1190123","ip_address":"","utype":1,"ctime":1539048744,"user_name_real":"gg"}],"discussion_count":3,"race_medal":0,"score":"9.2233723476314993e+18","product_id":100017301,"comment_content":"用快慢指针先找到中点，然后把后半段链表reversed，然后一个指针在头部，一个指针再中点，开始逐个比较，时间复杂度是O（n)","like_count":72,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426134,"discussion_content":"对的！👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539048744,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2397463,"avatar":"https://static001.geekbang.org/account/avatar/00/24/95/17/bfc95ae8.jpg","nickname":"geek","note":"","ucode":"ECB46425B33577","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371964,"discussion_content":"思路清晰 👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620107277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2264679,"avatar":"https://static001.geekbang.org/account/avatar/00/22/8e/67/afb412fb.jpg","nickname":"陈威洋","note":"","ucode":"DCF84B4D3A7354","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351374,"discussion_content":"就你描述的这个算法通俗易懂，上面几个评论感觉加了很多戏","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614254663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30434,"user_name":"molybdenum","can_delete":false,"product_type":"c1","uid":1251208,"ip_address":"","ucode":"DA24BDFCFF416C","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/88/be4fe19e.jpg","comment_is_top":false,"comment_ctime":1538843467,"is_pvip":false,"discussion_count":42,"race_medal":0,"score":"3020900852555","product_id":100017301,"comment_content":"看了大家的评论学习到了快慢指针法，看语言描述没太懂，自己用代码写了下才明白。<br>大致思路如下<br>由于回文串最重要的就是对称，那么最重要的问题就是找到那个中心，用快指针每步两格走，当他到达链表末端的时候，慢指针刚好到达中心，慢指针在过来的这趟路上还做了一件事，他把走过的节点反向了，在中心点再开辟一个新的指针用于往回走，而慢指针继续向前，当慢指针扫完整个链表，就可以判断这是回文串，否则就提前退出，总的来说时间复杂度按慢指针遍历一遍来算是O(n),空间复杂度因为只开辟了3个额外的辅助，所以是o(1)","like_count":703,"discussions":[{"author":{"id":1237305,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e1/39/86b611b8.jpg","nickname":"沫非","note":"","ucode":"2D95C7FDCBEFD5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330846,"discussion_content":"慢指针已经将前半段反向了，新的指针接着从头部遍历，跟慢指针接着下半部分遍历结果比较，判断是否为回文；新指针在从头部遍历的同时再做一遍反向操作，将原链表还原。","likes_number":15,"is_delete":false,"is_hidden":false,"ctime":1606721588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2133532,"avatar":"https://static001.geekbang.org/account/avatar/00/20/8e/1c/50381b1d.jpg","nickname":"经纬","note":"","ucode":"80573A9506AEEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361757,"discussion_content":"这个是说的最清楚的","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1616746697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2529532,"avatar":"https://static001.geekbang.org/account/avatar/00/26/98/fc/df6a9ed7.jpg","nickname":"ZzzL","note":"","ucode":"01B09ACD8BEF4E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2133532,"avatar":"https://static001.geekbang.org/account/avatar/00/20/8e/1c/50381b1d.jpg","nickname":"经纬","note":"","ucode":"80573A9506AEEC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385020,"discussion_content":"确实","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626852361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":361757,"ip_address":""},"score":385020,"extra":""}]},{"author":{"id":1370456,"avatar":"https://static001.geekbang.org/account/avatar/00/14/e9/58/397a4ab2.jpg","nickname":"daniel","note":"","ucode":"3516AF7F9A4DEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2369,"discussion_content":"“在中心点再开辟一个新的指针用于往回走”单链表指针如何往回走？","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1563521933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1050191,"avatar":"https://static001.geekbang.org/account/avatar/00/10/06/4f/14cc4b53.jpg","nickname":"不专注的linuxer","note":"","ucode":"28ED11C1E2942C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306390,"discussion_content":"一看就是写过代码的人，写得很明白呀，nb，前面会说的不一定能写出来代码，肯定的，这么好的答案老师没点赞回复，可惜了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1600260894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2032840,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/04/c8/3c7af100.jpg","nickname":"Javatar","note":"","ucode":"E216645CDF632C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281590,"discussion_content":"感觉没办法直接反向前半段，应该新建一个链表，相当于把前半段反向复制进去，这样会占用n/2的空间","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1591771388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":2112661,"avatar":"","nickname":"Geek_0b819f","note":"","ucode":"F7C0768D90A574","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2032840,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/04/c8/3c7af100.jpg","nickname":"Javatar","note":"","ucode":"E216645CDF632C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305192,"discussion_content":"在前半段慢指针迭代的时候，可以这样逆序slow.next.prev=slow,这样回来的时候就可以顺着prev指针往回迭代了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599813321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":281590,"ip_address":""},"score":305192,"extra":""},{"author":{"id":2244374,"avatar":"https://static001.geekbang.org/account/avatar/00/22/3f/16/97de12e5.jpg","nickname":"hunter_w","note":"","ucode":"C088203381C568","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2112661,"avatar":"","nickname":"Geek_0b819f","note":"","ucode":"F7C0768D90A574","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":315255,"discussion_content":"你这是双向链表不符合单链表的要求吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603256305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":305192,"ip_address":""},"score":315255,"extra":""},{"author":{"id":2118209,"avatar":"https://static001.geekbang.org/account/avatar/00/20/52/41/31d4cbc5.jpg","nickname":"云深","note":"","ucode":"78223E53E0B167","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2112661,"avatar":"","nickname":"Geek_0b819f","note":"","ucode":"F7C0768D90A574","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392459,"discussion_content":"单链表咋反转 哪来的prev","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631012546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":305192,"ip_address":""},"score":392459,"extra":""}]},{"author":{"id":1427453,"avatar":"https://static001.geekbang.org/account/avatar/00/15/c7/fd/b6dec088.jpg","nickname":"布衣小酱","note":"","ucode":"46D4676C39E951","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1671,"discussion_content":"看到这终于懂了快慢指针了。但是空间复杂度是o（n）吧，还要用链表存储字符串","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1562807483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2050135,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/48/57/f81acea8.jpg","nickname":"航","note":"","ucode":"FFAE304D6D4AD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288526,"discussion_content":"牛B啊，瞬间明白","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1593774700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2334433,"avatar":"https://static001.geekbang.org/account/avatar/00/23/9e/e1/dfe58110.jpg","nickname":"emmm","note":"","ucode":"7FACBCF7FC7870","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329139,"discussion_content":"不对呀，慢指针怎么反向，是指从头结点再跑一次反转吗？找到中点断链之后，把后半部分反转他不香嘛","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606316922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2054857,"avatar":"","nickname":"201201511","note":"","ucode":"1B36FFAF9DD9E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2334433,"avatar":"https://static001.geekbang.org/account/avatar/00/23/9e/e1/dfe58110.jpg","nickname":"emmm","note":"","ucode":"7FACBCF7FC7870","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369991,"discussion_content":"这样需要空间额外的空间来存储后半段了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619241624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":329139,"ip_address":""},"score":369991,"extra":""}]},{"author":{"id":1368038,"avatar":"https://static001.geekbang.org/account/avatar/00/14/df/e6/bd1b3c0b.jpg","nickname":"Jesse","note":"","ucode":"727CA882B84DA0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53117,"discussion_content":"“在中心点再开辟一个新的指针用于往回走”单向链表不能往回走吧，可以把一个指针停在表头吧。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574134548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1717549,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/35/2d/a2bde67e.jpg","nickname":"SapereAude","note":"","ucode":"C5D61C535B7B10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52166,"discussion_content":"牛","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574000683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1448864,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1b/a0/7c7d1b4a.jpg","nickname":"徐帅","note":"","ucode":"BDF904280E2330","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":14510,"discussion_content":"不能提前退出，要把前半段慢指针走过的路反向，不然单链表就变了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568768486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1228241,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bd/d1/8df43129.jpg","nickname":"李辰","note":"","ucode":"0CFDD94BFA609B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1448864,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1b/a0/7c7d1b4a.jpg","nickname":"徐帅","note":"","ucode":"BDF904280E2330","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53079,"discussion_content":"没必要都走完，这道题主要就是为了判断是否回文串。哪怕全走完，整个单链表也是变了，变成之前的反向单链表了，没意义。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574129619,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":14510,"ip_address":""},"score":53079,"extra":""}]},{"author":{"id":1144219,"avatar":"https://static001.geekbang.org/account/avatar/00/11/75/9b/7b228bee.jpg","nickname":"小肥羔","note":"","ucode":"C5256075A3CE49","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1038,"discussion_content":"写的很不错呀，之前看上面的还有点懵，看了你的一下就通了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1562291044,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1299189,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d2/f5/b2c95027.jpg","nickname":"waldow","note":"","ucode":"A1E35BEFE5C052","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326,"discussion_content":"指针的灵活运用","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1561451509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2405955,"avatar":"https://static001.geekbang.org/account/avatar/00/24/b6/43/21b2c2d4.jpg","nickname":"王兴鹏","note":"","ucode":"F3540E3B2CDDC9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574561,"discussion_content":"1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654144956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2897809,"avatar":"","nickname":"Geek_d2d629","note":"","ucode":"1F3AEAD3902487","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554302,"discussion_content":"看懂思路了，牛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646308433,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1299347,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d3/93/c3fb8566.jpg","nickname":"ProcessIsTheKey","note":"","ucode":"BE02EFD75F7D98","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550830,"discussion_content":"    //Java版实现代码\n    public boolean isPalindromePerf() {\n        if (this.head == null) {\n            return false;\n        }\n        if (this.head.next == null) {\n            return true;\n        }\n        Node thisSlowNode = head;//慢指针\n        Node thisFastNode = head;//快指针\n        Node beforeReverseHead = null;//反向后头部结点\n        boolean isOdd = true;//是否为奇数\n        //使用快指针找到中间结点\n        //慢指针将走过的结点反向\n        while (thisFastNode != null &amp;&amp; thisFastNode.next != null) {\n            //快指针要先执行\n            thisFastNode = thisFastNode.next.next;\n            if (thisFastNode == null) {\n                isOdd = false;\n            }\n            //开始慢指针的操作\n            Node curNode = thisSlowNode.next;\n            thisSlowNode.next = beforeReverseHead;\n            beforeReverseHead = thisSlowNode;\n            thisSlowNode = curNode;\n        }\n        //链表总体个数为奇数，则慢指针需要越过一个结点再比较;否则，直接比较即可。\n        Node thisAfterHeadNode = thisSlowNode;//后半部分链表的头部结点\n        if (isOdd) {\n            thisSlowNode = thisSlowNode.next;\n        }\n        //判断是否为回文\n        boolean isPalindrome = true;\n        Node originHead = null;//原被反向的结点再被反向的头\n        Node thisBeforeLastNode = null;//反向回来的前半部分的链表的最后一个结点\n        while (thisSlowNode != null) {\n            //只要有一个数值不等，即可判断不是回文\n            if (isPalindrome &amp;&amp; thisSlowNode.data != beforeReverseHead.data) {\n                isPalindrome = false;\n            }\n            //将原先被反转的结点再反向回来\n            Node originNode = beforeReverseHead.next;\n            beforeReverseHead.next = originHead;\n            if (beforeReverseHead.next == null) {\n                thisBeforeLastNode = beforeReverseHead;\n            }\n            originHead = beforeReverseHead;//头部更新\n            beforeReverseHead = originNode;\n            //慢指针走完\n            thisSlowNode = thisSlowNode.next;\n        }\n        //复原原链表\n        thisBeforeLastNode.next = thisAfterHeadNode;\n        return isPalindrome;\n    }","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644750850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2654925,"avatar":"","nickname":"笙箫","note":"","ucode":"FC8AD39BD862E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404638,"discussion_content":"确实很好，这样的时间复杂度也才o(n),这里只是开辟了三个辅助指针。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634368798,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2118209,"avatar":"https://static001.geekbang.org/account/avatar/00/20/52/41/31d4cbc5.jpg","nickname":"云深","note":"","ucode":"78223E53E0B167","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392461,"discussion_content":"再来个新指针不就是相当于new 了一个新链表吗 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631012774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2529532,"avatar":"https://static001.geekbang.org/account/avatar/00/26/98/fc/df6a9ed7.jpg","nickname":"ZzzL","note":"","ucode":"01B09ACD8BEF4E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385019,"discussion_content":"懂了，谢谢大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626852350,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1082565,"avatar":"https://static001.geekbang.org/account/avatar/00/10/84/c5/31421460.jpg","nickname":"宋枝茂","note":"","ucode":"E82917B3CAF221","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344509,"discussion_content":"请问下这是什么画图的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611481873,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1172090,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e2/7a/38a27e47.jpg","nickname":"蓦然回首","note":"","ucode":"B17658DCFE6402","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332119,"discussion_content":"既然都已经用双向链表了，为啥还要这样操作，找中点意义何在，还不都是要比较，直接首尾进行比较不行吗？双向链表本来就有尾结点。如果是单链表，因为无法直接从尾部遍历，所以考虑找中点这种方式，但双向链表完全没必要，都是要进行首尾逐个比较，难道能逃脱这个规律，还进行那么多其他操作干嘛，还把链表本身反转干嘛，楼主的意思是针对单链表来的，双向链表完全没有必要这么多复杂操作，天然支持两端遍历!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607069092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1939316,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/97/74/a933d664.jpg","nickname":"莜戏","note":"","ucode":"C3488A2BB44359","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1172090,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e2/7a/38a27e47.jpg","nickname":"蓦然回首","note":"","ucode":"B17658DCFE6402","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":347129,"discussion_content":"用的单链表，如果双向链表哪里还需要逆置操作","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1612159372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":332119,"ip_address":""},"score":347129,"extra":""},{"author":{"id":1237628,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e2/7c/9bc7094a.jpg","nickname":"那只猫帅呆了","note":"","ucode":"4A421D38B67102","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1172090,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e2/7a/38a27e47.jpg","nickname":"蓦然回首","note":"","ucode":"B17658DCFE6402","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":555521,"discussion_content":"双链表刚开始也不知道尾指针是哪个吧，得遍历一遍才能知道","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646958061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":332119,"ip_address":""},"score":555521,"extra":""}]},{"author":{"id":1758307,"avatar":"","nickname":"韩方兴","note":"","ucode":"3C02DC65F3BB83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214626,"discussion_content":"前半段反向，判断是没问题了，链表也被毁掉了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585218737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2050321,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/rmNvR2XOVXSgicicLt3u9ZM7DhLGlmUNpH0jO9VC0NicLLFAqTTwnCau95F6WUcSKXJd54F3gMickicIMH4Yw3OQ3rQ/132","nickname":"Geek_389f8b","note":"","ucode":"3093DBF70FE560","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1758307,"avatar":"","nickname":"韩方兴","note":"","ucode":"3C02DC65F3BB83","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287738,"discussion_content":"找到中点后判断回文时候可以再将链表恢复过来，不过这样时间复杂度就变高了点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593524730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":214626,"ip_address":""},"score":287738,"extra":""}]},{"author":{"id":1848474,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/34/9a/1587bc6f.jpg","nickname":"JDY","note":"","ucode":"4B6F55332BE6DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":188948,"discussion_content":"双链表是往回走吧，单链表怎么能往回走呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582824798,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1721168,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/43/50/abb4ca1e.jpg","nickname":"凡","note":"","ucode":"80C2A6452AB9EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1848474,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/34/9a/1587bc6f.jpg","nickname":"JDY","note":"","ucode":"4B6F55332BE6DC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":188952,"discussion_content":"慢指针在到达中心之前把走过的节点的 next 执行指向之前遍历的节点，即 表头到中心的方向变成 1<-2<-3 4->5->6  类似这样","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1582825344,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":188948,"ip_address":""},"score":188952,"extra":""},{"author":{"id":1926508,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/65/6c/be97a3ae.jpg","nickname":"Geek_bb2310","note":"","ucode":"022885B257DEB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1721168,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/43/50/abb4ca1e.jpg","nickname":"凡","note":"","ucode":"80C2A6452AB9EA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":257547,"discussion_content":"yep\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588586859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":188952,"ip_address":""},"score":257547,"extra":""}]},{"author":{"id":1648177,"avatar":"https://static001.geekbang.org/account/avatar/00/19/26/31/8ac99e03.jpg","nickname":"Jason_liang","note":"","ucode":"7D66AED037AC9C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88510,"discussion_content":"为什么慢指针是反向了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576717438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1143372,"avatar":"https://static001.geekbang.org/account/avatar/00/11/72/4c/4d636a23.jpg","nickname":"在路上","note":"","ucode":"335960F683C23C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64466,"discussion_content":"用了几个指针，单链表怎么往回走，还是不能明白啊？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574948947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1730576,"avatar":"","nickname":"27","note":"","ucode":"B5D7A54EA47206","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1143372,"avatar":"https://static001.geekbang.org/account/avatar/00/11/72/4c/4d636a23.jpg","nickname":"在路上","note":"","ucode":"335960F683C23C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":210930,"discussion_content":"比较的时候是从中间开始向两边比较的，所以慢指针(此时在中间)向回走，但是是单链表，指针怎么向会回走呢？  就需要将前半段逆序。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1584791960,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":64466,"ip_address":""},"score":210930,"extra":""},{"author":{"id":1640978,"avatar":"https://static001.geekbang.org/account/avatar/00/19/0a/12/f8b988b8.jpg","nickname":"Kyle(","note":"","ucode":"0C14C4C086CAA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1730576,"avatar":"","nickname":"27","note":"","ucode":"B5D7A54EA47206","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351151,"discussion_content":"你品 你细品","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614167229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":210930,"ip_address":""},"score":351151,"extra":""}]},{"author":{"id":1716067,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/2f/63/7a048d46.jpg","nickname":"梨子苹果","note":"","ucode":"3666813FEE31D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46537,"discussion_content":"厉害了，长见识了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573178762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1291529,"avatar":"https://static001.geekbang.org/account/avatar/00/13/b5/09/874f7275.jpg","nickname":"G~旖旎中子","note":"","ucode":"9E15D7CF3AC78D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":34349,"discussion_content":"你这是双俩表吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571194931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1125452,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2c/4c/42596eb4.jpg","nickname":"westboy","note":"","ucode":"A2B33609A89C66","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5056,"discussion_content":"空间复杂度是O（1），因为前半部分只是反转而已，并没有引入额外的内存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565917700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1599165,"avatar":"","nickname":"memdreams","note":"","ucode":"0AE081B72CF0C0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1571,"discussion_content":"棒👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562707888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29765,"user_name":"姜威","can_delete":false,"product_type":"c1","uid":1244051,"ip_address":"","ucode":"C58EB9A5AD634D","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/93/f19a5364.jpg","comment_is_top":false,"comment_ctime":1538534343,"is_pvip":false,"replies":[{"id":"10729","content":"👍","user_name":"作者回复","comment_id":29765,"uid":"1190123","ip_address":"","utype":1,"ctime":1538582222,"user_name_real":"gg"}],"discussion_count":21,"race_medal":0,"score":"1577791531975","product_id":100017301,"comment_content":"五、应用<br>1.如何分别用链表和数组实现LRU缓冲淘汰策略？<br>1）什么是缓存？<br>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等等。<br>2）为什么使用缓存？即缓存的特点<br>缓存的大小是有限的，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？就需要用到缓存淘汰策略。<br>3）什么是缓存淘汰策略？<br>指的是当缓存被用满时清理数据的优先顺序。<br>4）有哪些缓存淘汰策略？<br>常见的3种包括先进先出策略FIFO（First In，First Out）、最少使用策略LFU（Least Frenquently Used）、最近最少使用策略LRU（Least Recently Used）。<br>5）链表实现LRU缓存淘汰策略<br>当访问的数据没有存储在缓存的链表中时，直接将数据插入链表表头，时间复杂度为O(1)；当访问的数据存在于存储的链表中时，将该数据对应的节点，插入到链表表头,时间复杂度为O(n)。如果缓存被占满，则从链表尾部的数据开始清理，时间复杂度为O(1)。<br>6）数组实现LRU缓存淘汰策略<br>方式一：首位置保存最新访问数据，末尾位置优先清理<br>当访问的数据未存在于缓存的数组中时，直接将数据插入数组第一个元素位置，此时数组所有元素需要向后移动1个位置，时间复杂度为O(n)；当访问的数据存在于缓存的数组中时，查找到数据并将其插入数组的第一个位置，此时亦需移动数组元素，时间复杂度为O(n)。缓存用满时，则清理掉末尾的数据，时间复杂度为O(1)。<br>方式二：首位置优先清理，末尾位置保存最新访问数据<br>当访问的数据未存在于缓存的数组中时，直接将数据添加进数组作为当前最有一个元素时间复杂度为O(1)；当访问的数据存在于缓存的数组中时，查找到数据并将其插入当前数组最后一个元素的位置，此时亦需移动数组元素，时间复杂度为O(n)。缓存用满时，则清理掉数组首位置的元素，且剩余数组元素需整体前移一位，时间复杂度为O(n)。（优化：清理的时候可以考虑一次性清理一定数量，从而降低清理次数，提高性能。）<br>2.如何通过单链表实现“判断某个字符串是否为水仙花字符串”？（比如 上海自来水来自海上）<br>1）前提：字符串以单个字符的形式存储在单链表中。<br>2）遍历链表，判断字符个数是否为奇数，若为偶数，则不是。<br>3）将链表中的字符倒序存储一份在另一个链表中。<br>4）同步遍历2个链表，比较对应的字符是否相等，若相等，则是水仙花字串，否则，不是。<br>六、设计思想<br>时空替换思想：“用空间换时间” 与 “用时间换空间”<br>当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高，时间复杂度小相对较低的算法和数据结构，缓存就是空间换时间的例子。如果内存比较紧缺，比如代码跑在手机或者单片机上，这时，就要反过来用时间换空间的思路。","like_count":367,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425710,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538582222,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1676658,"avatar":"https://static001.geekbang.org/account/avatar/00/19/95/72/ce90c1c7.jpg","nickname":"星期五","note":"","ucode":"A66B9E7113FB51","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50401,"discussion_content":"不好意思，我没有懂用单链表实现回文字符串解答的第二步，判断奇偶有什么关系","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573716830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1312130,"avatar":"https://static001.geekbang.org/account/avatar/00/14/05/82/51cd0a50.jpg","nickname":"zhimin","note":"","ucode":"DF6DFBEF6FA297","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1676658,"avatar":"https://static001.geekbang.org/account/avatar/00/19/95/72/ce90c1c7.jpg","nickname":"星期五","note":"","ucode":"A66B9E7113FB51","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96562,"discussion_content":"这里错了，奇数的也可以是回文字符串 ","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1577075296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":50401,"ip_address":""},"score":96562,"extra":""}]},{"author":{"id":1396815,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/4f/78549650.jpg","nickname":"safly","note":"","ucode":"9A2439CEAD1DEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49741,"discussion_content":"关于数组a[n]实现LRU的地方，方式2，有一个地方可以优化。利用循环数组，使用一个Flag记录最新数据的下标。如果数组满，则将最新的数据存于a[0]，此时flag为0，以此类推，这样可以省去一次将数据整体移位的情况。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573627805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1672805,"avatar":"https://static001.geekbang.org/account/avatar/00/19/86/65/ff4d03db.jpg","nickname":"老乡长","note":"","ucode":"887F4C1012C7F9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41394,"discussion_content":"时间复杂度O(n),空间复杂度都是O(n),而且你这种方式不需要判断是不是奇偶数","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572419061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2929807,"avatar":"","nickname":"李杰","note":"","ucode":"02B53F355FCC0A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572817,"discussion_content":"姜威，你是在北京工作过吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652974684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1241309,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJiarYOz2LwIDnz0lKaic7LtkrwelWBdNgQorzhMpbXlHFEcAmb15Fibeey9dib7ZCf3LnAhuJYsE8HoQ/132","nickname":"小如","note":"","ucode":"0E06F7844B3FD0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550454,"discussion_content":"绝了 非常感谢梳理 豁然开朗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644549347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1530594,"avatar":"https://static001.geekbang.org/account/avatar/00/17/5a/e2/698ec825.jpg","nickname":"wpl","note":"","ucode":"2E6E91BC0DD43E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387580,"discussion_content":"看评论获益良多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628262110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1410249,"avatar":"https://static001.geekbang.org/account/avatar/00/15/84/c9/0a425ccc.jpg","nickname":"Rx.钟直男","note":"","ucode":"07055F07DBA0AD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375626,"discussion_content":"对啊，回文字符串跟奇偶没关系吧？ “ABBA” 一样是回文字符串撒。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621778480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2654925,"avatar":"","nickname":"笙箫","note":"","ucode":"FC8AD39BD862E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1410249,"avatar":"https://static001.geekbang.org/account/avatar/00/15/84/c9/0a425ccc.jpg","nickname":"Rx.钟直男","note":"","ucode":"07055F07DBA0AD","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":410674,"discussion_content":"靓仔疑惑\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635756622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":375626,"ip_address":""},"score":410674,"extra":""}]},{"author":{"id":2228151,"avatar":"","nickname":"Geek从不换行","note":"","ucode":"FD791D375C5CEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":313154,"discussion_content":"这里总结的第5点，链表的LRU实现，每次都需要遍历链表，所以不管什么条件下，时间复杂度都是O(n)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602982113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1607832,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/HHryCCVzcAkYibxZ6B5jNRVd26NjzRZRVWff6gR9ibbmHx8JN2A6icPA48NgtLkIg1kFtiaI1ZzV1RT9UrYywLTicvw/132","nickname":"Geek_855fe4","note":"","ucode":"3860C305E7A6C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":272040,"discussion_content":"你好，“当访问的数据没有存储在缓存的链表中时，直接将数据插入链表表头，时间复杂度为O(1)；”这里判断需要访问的数据是否在链表(或数组)中，需要首先遍历(或数组)把，插入链表表头时间复杂度是O(1), 整体时间复杂度应该是O(n) + O(1) = O(n)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590241311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1972810,"avatar":"","nickname":"Geek_123d4e","note":"","ucode":"3E10A793C90C31","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1607832,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/HHryCCVzcAkYibxZ6B5jNRVd26NjzRZRVWff6gR9ibbmHx8JN2A6icPA48NgtLkIg1kFtiaI1ZzV1RT9UrYywLTicvw/132","nickname":"Geek_855fe4","note":"","ucode":"3860C305E7A6C2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278143,"discussion_content":"yes right","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591154187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":272040,"ip_address":""},"score":278143,"extra":""}]},{"author":{"id":1246680,"avatar":"https://static001.geekbang.org/account/avatar/00/13/05/d8/8d4885ce.jpg","nickname":"麻瓜","note":"","ucode":"78AA04402A007D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87239,"discussion_content":"将链表中的字符倒序存储一份在另一个链表中，单链表实现倒序怎么倒？先从1走到n,再从1走到n-1,n-2这么一个一个存入新的链表中吗？基础差，可能问的有点low","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576654390,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1140830,"avatar":"https://static001.geekbang.org/account/avatar/00/11/68/5e/5676ece1.jpg","nickname":"Exler","note":"","ucode":"41E5FCD39698D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1246680,"avatar":"https://static001.geekbang.org/account/avatar/00/13/05/d8/8d4885ce.jpg","nickname":"麻瓜","note":"","ucode":"78AA04402A007D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128419,"discussion_content":"单向链表无法反向遍历，你只能在遍历0->(n-1)的路上，对每个节点的指针进行反向","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1578637470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":87239,"ip_address":""},"score":128419,"extra":""},{"author":{"id":1050724,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/f9cSgw91q5Bo9HnOLAhZMGa6FRmeia37FoWicQ4NaeKJOOwdicLsKiaCWIqOawVCibOWvVjr93gzg55OliaCISdfibjRw/132","nickname":"Lonepuma","note":"","ucode":"3F54FD6041769F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1246680,"avatar":"https://static001.geekbang.org/account/avatar/00/13/05/d8/8d4885ce.jpg","nickname":"麻瓜","note":"","ucode":"78AA04402A007D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302217,"discussion_content":"单链表遍历一次，也可以反序的，先访问第一个 节点，访问第二个节点，让第二个指向第一个，同理让第三个指向第二个，这样来反序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598844462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":87239,"ip_address":""},"score":302217,"extra":""},{"author":{"id":2370758,"avatar":"https://static001.geekbang.org/account/avatar/00/24/2c/c6/416bd86e.jpg","nickname":"阿杰","note":"","ucode":"B9C504269C8CD3","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1246680,"avatar":"https://static001.geekbang.org/account/avatar/00/13/05/d8/8d4885ce.jpg","nickname":"麻瓜","note":"","ucode":"78AA04402A007D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339513,"discussion_content":"可以用两个指针，往下next的同时逆序指向，但是逆序指向的结果存放于新的链表中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609714637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":87239,"ip_address":""},"score":339513,"extra":""}]},{"author":{"id":1245341,"avatar":"https://static001.geekbang.org/account/avatar/00/13/00/9d/8e605115.jpg","nickname":"蒋委员长夸我帅","note":"","ucode":"727C2CC7229615","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60886,"discussion_content":"数组实现LRU方式1最后这里错了：“缓存用满时，则清理掉末尾的数据，时间复杂度为O(1)。”因为最新的要插入首位，清理掉之后还需要挨个后移一位，所以时间复杂度为O（n）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574762512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1798068,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/6f/b4/d465acef.jpg","nickname":"啊噗！","note":"","ucode":"C911E772E1E800","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1245341,"avatar":"https://static001.geekbang.org/account/avatar/00/13/00/9d/8e605115.jpg","nickname":"蒋委员长夸我帅","note":"","ucode":"727C2CC7229615","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":122890,"discussion_content":"不是清理要挨个后移一位所以是O(n)，是不管满没满，都需要查找遍历一遍链表已经是O（n）了，直接插入首位只是O（1）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578378791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":60886,"ip_address":""},"score":122890,"extra":""},{"author":{"id":1798950,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/73/26/c4a50429.jpg","nickname":"王瑄","note":"","ucode":"AFFBD62DB78C11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1245341,"avatar":"https://static001.geekbang.org/account/avatar/00/13/00/9d/8e605115.jpg","nickname":"蒋委员长夸我帅","note":"","ucode":"727C2CC7229615","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213401,"discussion_content":"链表不是连续的内存空间，不需后移来腾出第一个位置。待插入结点的next指针指向当前的首节点即可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585067365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":60886,"ip_address":""},"score":213401,"extra":""}]},{"author":{"id":1746333,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/QVMndCKAx6AwmPia3a6woon0iarW06CMyIeRZd2PzEREbWjuyE4pPNueYzNIurEicKQvuzl6LVrr1vibx2uH7MQhSQ/132","nickname":"Geek_c56120","note":"","ucode":"69B7E784FAD57D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52056,"discussion_content":"你写错了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573990467,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29764,"user_name":"姜威","can_delete":false,"product_type":"c1","uid":1244051,"ip_address":"","ucode":"C58EB9A5AD634D","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/93/f19a5364.jpg","comment_is_top":false,"comment_ctime":1538534253,"is_pvip":false,"replies":[{"id":"10730","content":"👍","user_name":"作者回复","comment_id":29764,"uid":"1190123","ip_address":"","utype":1,"ctime":1538582236,"user_name_real":"gg"}],"discussion_count":6,"race_medal":0,"score":"645783628653","product_id":100017301,"comment_content":"总结<br>一、什么是链表？<br>1.和数组一样，链表也是一种线性表。<br>2.从内存结构来看，链表的内存结构是不连续的内存空间，是将一组零散的内存块串联起来，从而进行数据存储的数据结构。<br>3.链表中的每一个内存块被称为节点Node。节点除了存储数据外，还需记录链上下一个节点的地址，即后继指针next。<br>二、为什么使用链表？即链表的特点<br>1.插入、删除数据效率高O(1)级别（只需更改指针指向即可），随机访问效率低O(n)级别（需要从链头至链尾进行遍历）。<br>2.和数组相比，内存空间消耗更大，因为每个存储数据的节点都需要额外的空间存储后继指针。<br>三、常用链表：单链表、循环链表和双向链表<br>1.单链表<br>1）每个节点只包含一个指针，即后继指针。<br>2）单链表有两个特殊的节点，即首节点和尾节点。为什么特殊？用首节点地址表示整条链表，尾节点的后继指针指向空地址null。<br>3）性能特点：插入和删除节点的时间复杂度为O（1），查找的时间复杂度为O(n)。<br>2.循环链表<br>1）除了尾节点的后继指针指向首节点的地址外均与单链表一致。<br>2）适用于存储有循环特点的数据，比如约瑟夫问题。<br>3.双向链表<br>1）节点除了存储数据外，还有两个指针分别指向前一个节点地址（前驱指针prev）和下一个节点地址（后继指针next）。<br>2）首节点的前驱指针prev和尾节点的后继指针均指向空地址。<br>3）性能特点：<br>和单链表相比，存储相同的数据，需要消耗更多的存储空间。<br>插入、删除操作比单链表效率更高O(1)级别。以删除操作为例，删除操作分为2种情况：给定数据值删除对应节点和给定节点地址删除节点。对于前一种情况，单链表和双向链表都需要从头到尾进行遍历从而找到对应节点进行删除，时间复杂度为O(n)。对于第二种情况，要进行删除操作必须找到前驱节点，单链表需要从头到尾进行遍历直到p-&gt;next = q，时间复杂度为O(n)，而双向链表可以直接找到前驱节点，时间复杂度为O(1)。<br>对于一个有序链表，双向链表的按值查询效率要比单链表高一些。因为我们可以记录上次查找的位置p，每一次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。<br>4.双向循环链表：首节点的前驱指针指向尾节点，尾节点的后继指针指向首节点。<br>四、选择数组还是链表？<br>1.插入、删除和随机访问的时间复杂度<br>数组：插入、删除的时间复杂度是O(n)，随机访问的时间复杂度是O(1)。<br>链表：插入、删除的时间复杂度是O(1)，随机访问的时间复杂端是O(n)。<br>2.数组缺点<br>1）若申请内存空间很大，比如100M，但若内存空间没有100M的连续空间时，则会申请失败，尽管内存可用空间超过100M。<br>2）大小固定，若存储空间不足，需进行扩容，一旦扩容就要进行数据复制，而这时非常费时的。<br>3.链表缺点<br>1）内存空间消耗更大，因为需要额外的空间存储指针信息。<br>2）对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java语言，还可能会造成频繁的GC（自动垃圾回收器）操作。<br>4.如何选择？<br>数组简单易用，在实现上使用连续的内存空间，可以借助CPU的缓冲机制预读数组中的数据，所以访问效率更高，而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法预读。<br>如果代码对内存的使用非常苛刻，那数组就更适合。<br>","like_count":150,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425709,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538582236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1163504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c0/f0/1aabc056.jpg","nickname":"Jiantao","note":"","ucode":"444580EC5EF109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297410,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596905195,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1928441,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/cfNtHoAbHvia1O0jIopiafYbnppEPiawgicKa8vdI2FxMMEdqORB4VLzkYTuGJGA7HibustnU0hDTOD7YSDAWuxhmrg/132","nickname":"Geek_299a34","note":"","ucode":"79AECE06F08E87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294847,"discussion_content":"啥时候选用链表呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596014996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1502877,"avatar":"https://static001.geekbang.org/account/avatar/00/16/ee/9d/3266d88b.jpg","nickname":"listen","note":"","ucode":"B9FDCC1ED1F659","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":280761,"discussion_content":"总结到位，记在小本本","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591608925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1290874,"avatar":"https://static001.geekbang.org/account/avatar/00/13/b2/7a/cedce3fd.jpg","nickname":"Sylvan","note":"","ucode":"2DD646D2B42A60","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261655,"discussion_content":"学习 很通透","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588989413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1339625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/70/e9/26243f4f.jpg","nickname":"王遥","note":"","ucode":"DFAA29C57C4B9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":45790,"discussion_content":"学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573086887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29738,"user_name":"徐凯","can_delete":false,"product_type":"c1","uid":1244991,"ip_address":"","ucode":"12F82BA3649CD5","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/3f/bbb8a88c.jpg","comment_is_top":false,"comment_ctime":1538527476,"is_pvip":false,"discussion_count":14,"race_medal":0,"score":"310776172788","product_id":100017301,"comment_content":"通过一个栈  遍历整个链表   然后再从栈中弹出  如果元素都匹配则为回文","like_count":72,"discussions":[{"author":{"id":1631216,"avatar":"https://static001.geekbang.org/account/avatar/00/18/e3/f0/e7977337.jpg","nickname":"hoverq","note":"","ucode":"82F18CF592977E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7278,"discussion_content":"栈的话，如果链表元素都不一样，那就可以。如果有重复元素的话，可能会把非回文也判定为回文，比如：111221","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1567472623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1057136,"avatar":"https://static001.geekbang.org/account/avatar/00/10/21/70/5dbb96b0.jpg","nickname":"David Wu","note":"","ucode":"1A19D2963D8936","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1631216,"avatar":"https://static001.geekbang.org/account/avatar/00/18/e3/f0/e7977337.jpg","nickname":"hoverq","note":"","ucode":"82F18CF592977E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":15990,"discussion_content":"不太懂你在说什么。。。作者就是reverse一下链表，然后做对比。虽然不是很elegant，但是是正确的。111221搞一下弹出来是122111，马上就判定非回文来。。。","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1568867477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7278,"ip_address":""},"score":15990,"extra":""}]},{"author":{"id":2370758,"avatar":"https://static001.geekbang.org/account/avatar/00/24/2c/c6/416bd86e.jpg","nickname":"阿杰","note":"","ucode":"B9C504269C8CD3","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339515,"discussion_content":"楼主的意思应该是，先遍历一次整个链表，然后在遍历链表的同时把链表中的节点存放在栈中，应该是整个链表中的节点，然后等遍历完这一次之后根据栈的特性，后进先出，先弹出的肯定是链表中的最后一个节点，倒数第二个节点......第一个节点。同时再从链表首节点位置开始遍历，与栈弹出的节点值开始做对比（回文的定义，正着读和反着读一样。），这样做空间复杂度为o（n） 时间复杂度o(n+n)=o(n)","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1609716255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1033021,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c3/3d/abb7bfe3.jpg","nickname":"林炳强","note":"","ucode":"B1DA2D7D4AC177","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41200,"discussion_content":"前半部分入栈，后半部分开始出栈比较","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572363128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1544135,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8f/c7/ac1dd787.jpg","nickname":"开营","note":"","ucode":"CB0F04BA7946E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296896,"discussion_content":"用栈的方式还是有问题的，中间节点不好判断，如：1235321，这个5","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596697812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1244991,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ff/3f/bbb8a88c.jpg","nickname":"徐凯","note":"","ucode":"12F82BA3649CD5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1544135,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8f/c7/ac1dd787.jpg","nickname":"开营","note":"","ucode":"CB0F04BA7946E0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298330,"discussion_content":"当栈顶为5  链表也遍历为5时  自然相等 链表向后继续遍历  栈顶出栈 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597246403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":296896,"ip_address":""},"score":298330,"extra":""}]},{"author":{"id":2053825,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/56/c1/76d3e44a.jpg","nickname":"Scevola","note":"","ucode":"433A633884914C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289881,"discussion_content":"感觉链表全部压栈之后正序遍历链表与出栈元素 应该就是这个意思吧？ 不知道这种情况时间复杂度怎么算 我猜的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594257470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1283461,"avatar":"https://static001.geekbang.org/account/avatar/00/13/95/85/15cd21c2.jpg","nickname":"杨锋","note":"","ucode":"85A7828A538FB0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274614,"discussion_content":"不管怎么操作。都要找到中间位置。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590594250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1334855,"avatar":"https://static001.geekbang.org/account/avatar/00/14/5e/47/b8d03d92.jpg","nickname":"TigerLee","note":"","ucode":"45E3F608AF7A85","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1283461,"avatar":"https://static001.geekbang.org/account/avatar/00/13/95/85/15cd21c2.jpg","nickname":"杨锋","note":"","ucode":"85A7828A538FB0","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":391810,"discussion_content":"栈这种方式来判断，中间位置可以不需要！你出栈的过程就是把整个链表反转了再跟原链表做正反对比 全部相等 就刚好满足回文 (正反都是一样)的条件了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630638937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":274614,"ip_address":""},"score":391810,"extra":""}]},{"author":{"id":1133055,"avatar":"https://static001.geekbang.org/account/avatar/00/11/49/ff/34a47dca.jpg","nickname":"4567890","note":"","ucode":"23BC97FD1DADF0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213536,"discussion_content":"使用栈来判断的方式，也需要得到单链表的中间节点位置，否则会将非回文判断成回文~~~至于有没有可能将回文判断成非回文，这个得看你的实现了~~~\n正常来说，回文的判断如果用栈实现，就得中间节点前的全部做入栈操作，中点节点后的判断相等后做出栈操作~~~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585102665,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1244991,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ff/3f/bbb8a88c.jpg","nickname":"徐凯","note":"","ucode":"12F82BA3649CD5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1133055,"avatar":"https://static001.geekbang.org/account/avatar/00/11/49/ff/34a47dca.jpg","nickname":"4567890","note":"","ucode":"23BC97FD1DADF0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215056,"discussion_content":"你可以举个使用这种方法会将非回文判为回文的例子出来么。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1585278188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":213536,"ip_address":""},"score":215056,"extra":""}]},{"author":{"id":1105513,"avatar":"https://static001.geekbang.org/account/avatar/00/10/de/69/113da382.jpg","nickname":"宇飞","note":"","ucode":"D64C53CD189164","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64024,"discussion_content":"这种情况的时间复杂度和空间复杂度都是O(n)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574930865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1708098,"avatar":"","nickname":"楚云兮","note":"","ucode":"906482F32B46F1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38101,"discussion_content":"妙啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571726697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111610,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f6/3a/ab7cc2c2.jpg","nickname":"随风而逝","note":"","ucode":"BA3044C2E64123","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24561,"discussion_content":"需要判断何时压，何时弹。不然就变成了元素是不是一对的解决方案了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570179927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29739,"user_name":"_stuView","can_delete":false,"product_type":"c1","uid":1244561,"ip_address":"","ucode":"C2D4AAB08515F1","user_header":"https://static001.geekbang.org/account/avatar/00/12/fd/91/65ff3154.jpg","comment_is_top":false,"comment_ctime":1538527733,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"259236565493","product_id":100017301,"comment_content":"双向链表存储，两个指针分别从头节点和尾节点开始遍历，依次比较节点value，判断是否为回文序列","like_count":60,"discussions":[{"author":{"id":1118111,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","nickname":"见南山","note":"","ucode":"6A8BB82B7573CA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263774,"discussion_content":"双向链表就直接用循环双向链表，不需要遍历两边。可惜题是单链表","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589246546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1672805,"avatar":"https://static001.geekbang.org/account/avatar/00/19/86/65/ff4d03db.jpg","nickname":"老乡长","note":"","ucode":"887F4C1012C7F9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41391,"discussion_content":"兄弟看题，单链表存储","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572418877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1681512,"avatar":"https://static001.geekbang.org/account/avatar/00/19/a8/68/70392fdd.jpg","nickname":"black","note":"","ucode":"9B5E0909926674","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":26954,"discussion_content":"时间复杂度虽说是O(n),但是两次遍历还是有点问题，应该还是需要找到中点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570625698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1249459,"avatar":"","nickname":"mfayz","note":"","ucode":"28569DD162D1DD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":16202,"discussion_content":"哦哦，老师的题目是单链表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568876393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1249459,"avatar":"","nickname":"mfayz","note":"","ucode":"28569DD162D1DD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":15967,"discussion_content":"老师没评论，那这个到底正确么？我怎么感觉更简单啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568865702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29958,"user_name":"JStFs","can_delete":false,"product_type":"c1","uid":1241121,"ip_address":"","ucode":"636E85653555DD","user_header":"https://static001.geekbang.org/account/avatar/00/12/f0/21/7168f973.jpg","comment_is_top":false,"comment_ctime":1538616009,"is_pvip":false,"replies":[{"id":"10827","content":"哈哈 形象！","user_name":"作者回复","comment_id":29958,"uid":"1190123","ip_address":"","utype":1,"ctime":1538658422,"user_name_real":"gg"}],"discussion_count":3,"race_medal":0,"score":"237761817289","product_id":100017301,"comment_content":"LRU：活在当下。比如在公司中，一个新员工做出新业绩，马上会得到重用。<br><br>LFU：以史为镜。还是比如在公司中，新员工必须做出比那些功勋卓著的老员工更多更好的业绩才可以受到老板重视，这样的方式比较尊重“前辈”。","like_count":55,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425789,"discussion_content":"哈哈 形象！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538658422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1231623,"avatar":"https://static001.geekbang.org/account/avatar/00/12/cb/07/482b7155.jpg","nickname":"牛玉富","note":"","ucode":"DD962676F8FAF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545137,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641862998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1193385,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/a9/e2a0ad48.jpg","nickname":"懒散","note":"","ucode":"6FC704ABE5A9E1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287562,"discussion_content":"这两种类型区别简单明了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593482248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37871,"user_name":"Kevin.zhang🌏","can_delete":false,"product_type":"c1","uid":1247039,"ip_address":"","ucode":"5C52AE51538906","user_header":"https://static001.geekbang.org/account/avatar/00/13/07/3f/53ae01f6.jpg","comment_is_top":false,"comment_ctime":1541759547,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"194815287867","product_id":100017301,"comment_content":"习题解，大部分同学都说到了方法一：半栈法<br>　　　　　１．用快慢两个指针遍历，同时用栈copy慢指针指向的data。<br>　　　　　２．完成后，慢指针指向中间节点，耗时为N&#47;2.<br>　　　　　３．最后用pop栈中的data和慢指针指向的data比较，耗时也是N&#47;2.<br>          所以时间复杂度为：Ｏ(N)，空间复杂度因栈额外存储了一半的data，故为O(N&#47;2)<br><br>方法二：全栈法<br>　　　　　１．全部遍历，data压栈，额外空间消耗N<br>                    ２．再次全部遍历取data，同时pop栈取data, 二者比较，时间消耗2N<br>          所以时间复杂度为O(3N)，空间复杂度为O(N)<br>          该法算法最简单，但复杂度高。可以用栈存储节点指针，而非data来改进。<br><br>方法三：硬干法<br>　　　　　1. 一个指针从头取data，另一个指针遍历到底取data，比较二者<br>　　　　　２．删除尾部节点，重复１．<br>　　　时间复杂度高达　O(N^2)，空间复杂度却最低Ｏ(1)","like_count":45,"discussions":[{"author":{"id":1837716,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/0a/94/736a4d51.jpg","nickname":"zhaoyou","note":"","ucode":"D6C5C26A989C02","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284883,"discussion_content":"方法二实现起来最简单\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592666671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188627,"avatar":"https://static001.geekbang.org/account/avatar/00/12/23/13/6ba35b43.jpg","nickname":"leejunhui","note":"","ucode":"A957C0034B9F4D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":240459,"discussion_content":"很形象的总结","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587366027,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1334015,"avatar":"https://static001.geekbang.org/account/avatar/00/14/5a/ff/e89eb122.jpg","nickname":"LipLipLip","note":"","ucode":"6D5EC6B5BEC600","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":230342,"discussion_content":"这个硬干法很形象了，哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586740451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1744888,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/9f/f8/d851a100.jpg","nickname":"世界以痛吻我，我却报之以歌","note":"","ucode":"04B06339A815E9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70471,"discussion_content":"如果长度是偶数，那没问题，那要是奇数呢，一半压栈是多少","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575359883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135761,"avatar":"https://static001.geekbang.org/account/avatar/00/11/54/91/845de758.jpg","nickname":"L","note":"","ucode":"68954D2A92AB01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21769,"discussion_content":"有意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569514853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1639787,"avatar":"https://static001.geekbang.org/account/avatar/00/19/05/6b/d9d6d68b.jpg","nickname":"Vettel","note":"","ucode":"FB3E71DD1E8E7C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21399,"discussion_content":"不需要栈也能reverse啊,通过额外的指针来完成啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569478020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1227107,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b9/63/a3b11794.jpg","nickname":"麦抠","note":"","ucode":"875DEA26F38BAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2421,"discussion_content":"哈哈哈 硬干法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563589368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29737,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1538526817,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"194812055137","product_id":100017301,"comment_content":"老师，关于解答开篇那边，能不能附加一些代码示例，这样配合代码跟思路讲解，可能更好的理解呢。","like_count":45},{"had_liked":false,"id":29733,"user_name":"雨山","can_delete":false,"product_type":"c1","uid":1236807,"ip_address":"","ucode":"A163BE0F9B1B25","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/47/9a425604.jpg","comment_is_top":false,"comment_ctime":1538526139,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"190517087163","product_id":100017301,"comment_content":"果然有程序员风格，放假还更新，昨天临睡前就看完了，但是没有评价，总之这个课绝对物有所值。","like_count":44},{"had_liked":false,"id":29727,"user_name":"Joshua 兆甲","can_delete":false,"product_type":"c1","uid":1244179,"ip_address":"","ucode":"473223055AC083","user_header":"https://static001.geekbang.org/account/avatar/00/12/fc/13/11f8062e.jpg","comment_is_top":false,"comment_ctime":1538524458,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"181927150890","product_id":100017301,"comment_content":"习题解答<br>1.快进慢进法[两组指针，从头开始，a组一次进一，b组一次进二，b组到终点时，a组位置即为链表中间结点，循环次数为链表除去中间结点后前后两组的长度] 求得单向链表“中间”节点。并计算遍历次数，经过验证，遍历次数为‘’半链表‘’长度<br>2.从中间结点开始，以动态步长[每第i次步长是半链表长度-i+1]遍历链表，同时，从头节点开始，以1步长遍历。比较两组对应元素是否相同，相同继续，不同退出，返回不是回文字符串的结论。<br>3.返回是回文字符串的结论，退出.<br>空间复杂度O(n). 不用连续内存，可以磁盘操作<br>时间复杂度度O(n). 主要费时操作遍历<br><br>  算了，不够直观，不易别人看懂。还是先把单项链表转存为线性表。<br>1.单向遍历，获得对应的线性表Arr，求线性表长度为L<br>2.运用线性表可以任意访问的性质，遍历Arr，令下标i从0。比较Arr[i]和Arr[L－i]是否相等 相等继续，不等报告不是回文字符串结论，退出<br>3.报告是回文字符串结论，结束。<br>空间复杂度O(n)<br>时间复杂度O(n)<br>看起来一样，这个就需要字符串不太大，有足够的连续内存可以分配，而且，预先不知道链表多长，可能还会遇到扩容问题。","like_count":42,"discussions":[{"author":{"id":1907362,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/1a/a2/8484b2cf.jpg","nickname":"为光","note":"","ucode":"70E21C9BA5B791","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":226595,"discussion_content":"说线性表不准确吧，线性表也是分数组和链表实现的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586436786,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1433815,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e0/d7/744bd8c3.jpg","nickname":"空白昵称","note":"","ucode":"91F50CA25102AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":177409,"discussion_content":"在这里使用数组 跟使用双向循环链表一样。这里空间复杂度因没产生额外空间是否为O（1）？时间复杂度是否为O（N/2）？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582104425,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1670786,"avatar":"https://static001.geekbang.org/account/avatar/00/19/7e/82/5e269b4e.jpg","nickname":"阿棱","note":"","ucode":"AB93F65338959E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":23060,"discussion_content":"是比较Arr[i]和Arr[L-1－i]是否相等吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569748661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1682698,"avatar":"https://static001.geekbang.org/account/avatar/00/19/ad/0a/4ced2bcb.jpg","nickname":"小雷","note":"","ucode":"D326F0871DA62A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1670786,"avatar":"https://static001.geekbang.org/account/avatar/00/19/7e/82/5e269b4e.jpg","nickname":"阿棱","note":"","ucode":"AB93F65338959E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49787,"discussion_content":"对，感觉还是用数组更直观些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573636928,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":23060,"ip_address":""},"score":49787,"extra":""}]}]},{"had_liked":false,"id":82987,"user_name":"listen2099","can_delete":false,"product_type":"c1","uid":1385078,"ip_address":"","ucode":"F4FDCA1CBA9E90","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIiam52mLdqzU3xZAdk2C8gjWQgILhAp6w5cJtYUN99VT2wp6IwTTmEL2ibaz9CRBxUV5euLuIEZhhA/132","comment_is_top":false,"comment_ctime":1554365846,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"160468155798","product_id":100017301,"comment_content":"花了三天时间, 实现了单链表LRU","like_count":37,"discussions":[{"author":{"id":1576826,"avatar":"https://static001.geekbang.org/account/avatar/00/18/0f/7a/420b41cd.jpg","nickname":"Geek_183f9e","note":"","ucode":"70405BB513AA9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":410957,"discussion_content":"需不需要我帮你review下","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635817790,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30114,"user_name":"顾言","can_delete":false,"product_type":"c1","uid":1184481,"ip_address":"","ucode":"79DDEDCADD1F49","user_header":"https://static001.geekbang.org/account/avatar/00/12/12/e1/6d0114fe.jpg","comment_is_top":false,"comment_ctime":1538669286,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"138977622758","product_id":100017301,"comment_content":"用数组解决Lru缓存问题：<br>维护一个有序的数组，越靠近数组首位置的数据越是最早访问的。<br>1.如果这个数据已经存在于数组中，把对应位置的数据删掉，直接把这个数据加到数组的最后一位。时间复杂度为o(n)<br>2.如果数据不存在这个数组中，数据还有空间的话，就把数据直接插到最后一位。没有的话，就把第一个数据删掉，然后把数据插入到数组最后一个。这样的时间复杂度为o(n）。<br><br>第一个小伙伴的留言有点问题。判断是否为回文串和奇偶数没关系吧，偶数个字符串也可以是哈，比如abccba。<br>","like_count":32,"discussions":[{"author":{"id":1435611,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e7/db/1ad86e94.jpg","nickname":"geosmart","note":"","ucode":"7DCBA2F120442D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":67970,"discussion_content":"与有序单链表的实现相比，数组实现的lru在缓存已满时，多了个数据搬移的消耗，时间复杂度是o(n),链表o(1)","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575192034,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1853238,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/47/36/57f69b44.jpg","nickname":"马海东","note":"","ucode":"EA46828BF61038","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288322,"discussion_content":"实际中缓存是不是经常满的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593708545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31927,"user_name":"岁月如歌","can_delete":false,"product_type":"c1","uid":1114542,"ip_address":"","ucode":"29FA49EEDBFF92","user_header":"https://static001.geekbang.org/account/avatar/00/11/01/ae/f298ef27.jpg","comment_is_top":false,"comment_ctime":1539331521,"is_pvip":false,"replies":[{"id":"11608","content":"👍 总结的很好","user_name":"作者回复","comment_id":31927,"uid":"1190123","ip_address":"","utype":1,"ctime":1539403450,"user_name_real":"gg"}],"discussion_count":2,"race_medal":0,"score":"108913513921","product_id":100017301,"comment_content":"设计lru算法的思路，不管用什么数据结构，都要考虑的几个问题。<br>1、如何表示最近访问的数据和最早访问的数据<br>2、如何查找是否缓存了<br>3、数据有缓存，如何处理<br>4、数据没有缓存，如何处理<br>      1.缓存未满<br>      2.缓存已满","like_count":25,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426568,"discussion_content":"👍 总结的很好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539403450,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1052749,"avatar":"https://static001.geekbang.org/account/avatar/00/10/10/4d/efe9e272.jpg","nickname":"易水","note":"","ucode":"B677F978CE054E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359263,"discussion_content":"赞啊，一个实际的业务问题，思考顺序应该是这样：先把业务转成如你所述的算法思路，然后依据业务场景特点和逻辑结构，从中确定数据结构。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616153936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31360,"user_name":"5ispy","can_delete":false,"product_type":"c1","uid":1119481,"ip_address":"","ucode":"017FD3573B899F","user_header":"https://static001.geekbang.org/account/avatar/00/11/14/f9/5e08a350.jpg","comment_is_top":false,"comment_ctime":1539159804,"is_pvip":false,"replies":[{"id":"11311","content":"你理解的没错","user_name":"作者回复","comment_id":31360,"uid":"1190123","ip_address":"","utype":1,"ctime":1539222521,"user_name_real":"gg"}],"discussion_count":2,"race_medal":0,"score":"83143538428","product_id":100017301,"comment_content":"老师好，关于这节的内容有个疑问不太确定。<br>因为我看有人用java实现了链表有人也可以用c来实现。是不是数组属于编程语言“自带”的，而链表是 人 用编程语言 “实现”的。<br>比如对于java来说，如果项目中用到了链表，我们可以说是用到了某个类，而这个类就是 链表（实现了链表的功能）。<br>恳请老师指正！","like_count":19,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426307,"discussion_content":"你理解的没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539222521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1704007,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/00/47/d1364d17.jpg","nickname":"huajay","note":"","ucode":"C0880B183A2213","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46003,"discussion_content":"想看C的示例代码，老师的github上好像没有。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573108435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30565,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1538926724,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"83143305348","product_id":100017301,"comment_content":"老师，您回复 JK David 说到：<br>空间复杂度计算的不对，应该是O(1)，不是O(n)。我们要看额外的内存消耗，不是看链表本身存储需要多少空间。<br><br><br>在《复杂度分析（上）》提到：<br>第 3 行申请了一个大小为 n 的 int 类型数组，所以整段代码的空间复杂度就是 O(n)。<br><br><br>----<br><br><br>疑问一：<br>为什么两处计算空间复杂度的方法不一致，回复评论是以额外消耗为准，而文章中是以分配存储的空间为准？<br><br><br>疑问二：<br>《复杂度分析（上）》中介绍空间复杂度没有时间复杂度详细且带例子，看到老师您回复 JK David 以额外消耗为分析对象，就更懵圈了。<br>如果说：<br>1. 额外消耗常量值内存的空间复杂度是 O(1)；<br>2. 额外消耗 n 内存的空间复杂度是 O(n)；<br>那么空间复杂度是 O(n 的平方)，如何才能额外消耗 n 的平方空间呀？<br>老师能否针对空间复杂度，有一个更详细的说明和举例呢？<br><br><br>谢谢老师","like_count":19,"discussions":[{"author":{"id":1814542,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/6MFOTicBvia6hWE5EVpicAWzibxNpaM6iaRLQugcf6ib9TUianqX0PpoTTmgiccKXUYxicnpo21rhN4V7YCJ1sAV9gyI0OQ/132","nickname":"Geek_367e88","note":"","ucode":"BB92172A420AB0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":170032,"discussion_content":"链表在运行这个算法之前本来就存在啊，并不是运行这个算法所消耗的空间。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1581665145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1003327,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4f/3f/6f62f982.jpg","nickname":"王坤祥","note":"","ucode":"FB988B9F381A33","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217300,"discussion_content":"上面讨论到的空间复杂度为O(1)是因为对原有的链表（n个元素）进行操作，不需要申请额外的链表或其他空间存储链表元素","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585540211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1652836,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epKJlW7sqts2ZbPuhMbseTAdvHWnrc4ficAeSZyKibkvn6qyxflPrkKKU3mH6XCNmYvDg11tB6y0pxg/132","nickname":"pc","note":"","ucode":"1AD538B9A900B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":166818,"discussion_content":"只需new三个指针就可以解题，不包括原来链表所占用的空间。故为O(1)","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581429410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29838,"user_name":"阳仔","can_delete":false,"product_type":"c1","uid":1046920,"ip_address":"","ucode":"79F73D85EDF3E2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/88/cdda9e6f.jpg","comment_is_top":false,"comment_ctime":1538557455,"is_pvip":false,"replies":[{"id":"10718","content":"👍","user_name":"作者回复","comment_id":29838,"uid":"1190123","ip_address":"","utype":1,"ctime":1538581431,"user_name_real":"gg"}],"discussion_count":1,"race_medal":0,"score":"65963066895","product_id":100017301,"comment_content":"学习反馈：<br>链表也是一种基础的线性表结构。由于它的很多特点跟数组是相反的，因此可以与数组一起对比着学习。<br>数组的存储空间是连续，而链表不是；数组可以通过寻址公式计算通过下标来访问，而链表访问元素需要遍历。<br>常见的链表有：<br>单链表、双向链表、循环链表、双向循环链表。<br>链表擅长插入、删除操作，时间复杂度为O(1)；查询的效率不高，时间复杂度为O(n)。<br>数组擅长通过下标随机访问元素，时间复杂度为O(1)；插入、删除的效率不高，时间复杂度为O(n)。<br>在实际项目开发中，选择数组或者链表不能只关注时间复杂度，还需要考虑具体业务，综合考虑选择数组还是链表。<br>了解了链表的数据结构，那么实现一个机遇链表数据结构的LRU算法就比较简单了：<br>从链表中查询此缓存数据是否存在：<br>1、如果存在，则删除该缓存数据节点，并把数据插入到链表头部的位置；<br>1、如果不存在，则也考虑两种情况：<br>    1、如果缓存充足，则把数据插入到链表头部的位置；<br>    2、如果缓存不足，则把链表中的末尾节点删除，再把缓存数据插入到头部。<br>思考题：<br>如果是只使用单链表的话，假设存储回文的链表是L1，再用一个链表L2来存储逆文；<br>我的思路是这样：<br>1、循环这个回文链表L1，在遍历到一半之前把逆文存在一个L2中；<br>例如L1 为A-&gt;B-&gt;C-&gt;B-&gt;A，那么遍历到一半时，L2为：B-&gt;A；<br>偶数和奇数的区别在与中间的节点要不要放在L2中。<br>2、继续遍历比较L1,L2两个链表各个元素是否相等，如果不相等则立即返回；如果比较到最后遍历结束，则说明是回文；<br>因此通过一次遍历就知道这个链表是否为回文。时间复杂度为O(n)。<br>","like_count":15,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425734,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538581431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29760,"user_name":"luxinfeng","can_delete":false,"product_type":"c1","uid":1259853,"ip_address":"","ucode":"51D0046C4D31AD","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/4d/9ce28826.jpg","comment_is_top":false,"comment_ctime":1538532880,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"65963042320","product_id":100017301,"comment_content":"单链表存储，设置两组指针A和B，从链表头部开始遍历，指针A每次前进一位，指针B每次前进两位；指针A每到一个位置，就将该位置的字符压入栈中，直到指针B到达链表尾部，此时指针A到达字符串的中间位置。然后，每当指针A前进一步，就将栈中的字符弹出一位，比较指针A所指字符与弹出字符是否相等，如果相等，则继续运行；不等，则退出程序，说明该字符串不是回文序列。<br>时间渐进复杂度O（n），空间渐进复杂度O（n）。","like_count":15,"discussions":[{"author":{"id":2264679,"avatar":"https://static001.geekbang.org/account/avatar/00/22/8e/67/afb412fb.jpg","nickname":"陈威洋","note":"","ucode":"DCF84B4D3A7354","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351386,"discussion_content":"清晰，易懂，厉害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614255821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29743,"user_name":"CH_CB","can_delete":false,"product_type":"c1","uid":1236227,"ip_address":"","ucode":"49C07562DA527E","user_header":"https://static001.geekbang.org/account/avatar/00/12/dd/03/77a80775.jpg","comment_is_top":false,"comment_ctime":1538528720,"is_pvip":false,"replies":[{"id":"10731","content":"链表是有序链表，按照访问时间排序，访问时间值最小的放到链表尾部，最大的放到链表头。当要淘汰一个数据时，直接删除链表尾部的结点，当要加入一个数据时，直接插入链表头部。<br>当然，你要想按照相反的方式组织，也是可以的啊，只要是满足LRU就可以了。","user_name":"作者回复","comment_id":29743,"uid":"1190123","ip_address":"","utype":1,"ctime":1538582455,"user_name_real":"gg"}],"discussion_count":2,"race_medal":0,"score":"61668070864","product_id":100017301,"comment_content":"越靠近链表尾部的结点是越早之前访问的<br><br>这里不懂 😳老师可以解答一下吗，谢谢","like_count":14,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425701,"discussion_content":"链表是有序链表，按照访问时间排序，访问时间值最小的放到链表尾部，最大的放到链表头。当要淘汰一个数据时，直接删除链表尾部的结点，当要加入一个数据时，直接插入链表头部。\n当然，你要想按照相反的方式组织，也是可以的啊，只要是满足LRU就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538582455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2264679,"avatar":"https://static001.geekbang.org/account/avatar/00/22/8e/67/afb412fb.jpg","nickname":"陈威洋","note":"","ucode":"DCF84B4D3A7354","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351385,"discussion_content":"听懂了，开心！~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614255638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29721,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1538519512,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"61668061656","product_id":100017301,"comment_content":"思考题：根据原有单链表回文创建一个逆向的单链表回文，while 循环遍历比较，复杂度为 O(N)。","like_count":14},{"had_liked":false,"id":31548,"user_name":"拔剑四顾心惘然","can_delete":false,"product_type":"c1","uid":1246309,"ip_address":"","ucode":"80BC9A68935190","user_header":"","comment_is_top":false,"comment_ctime":1539226597,"is_pvip":false,"replies":[{"id":"11416","content":"👍","user_name":"作者回复","comment_id":31548,"uid":"1190123","ip_address":"","utype":1,"ctime":1539268933,"user_name_real":"gg"}],"discussion_count":3,"race_medal":0,"score":"48783866853","product_id":100017301,"comment_content":"单向链表回文判断代码： https:&#47;&#47;github.com&#47;guyuqi&#47;yuqi-repo&#47;blob&#47;master&#47;palindrome&#47;palindrome.c","like_count":11,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426394,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539268933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2869118,"avatar":"","nickname":"Geek_73c432","note":"","ucode":"3E11EB02B14DE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586739,"discussion_content":"写得太好了，看完醍醐灌顶","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662471265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1744376,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/9d/f8/bb4ab0d9.jpg","nickname":"Blmyun","note":"","ucode":"E9C4B814E93F28","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583815,"discussion_content":"这个答案，顺滑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660401037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"中国香港"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29868,"user_name":"六六六","can_delete":false,"product_type":"c1","uid":1252230,"ip_address":"","ucode":"933BC99EC09001","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/86/22a9362f.jpg","comment_is_top":false,"comment_ctime":1538572795,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"48783213051","product_id":100017301,"comment_content":"判断单链表是否是回文，只想到了这种low一些的做法，时间复杂度为O(n^2)：<br>public static boolean isHuiwen(LinkedList linkedList) {<br>        Node first = linkedList.getFirst();<br>        int size = linkedList.getSize();<br>        Node head = null;<br>        Node foot = null;<br>        for (int a = 0; a &lt; size &#47; 2; a++) {<br>            head = head == null ? first : head.next;<br>            foot = head;<br>            for (int i = a; i &lt; size - 1 - a; i++) {<br>                foot = foot.next;<br>            }<br>            if (!head.getData().equals(foot.getData())) {<br>                return false;<br>            }<br>        }<br>        return true;<br>    }<br>","like_count":11,"discussions":[{"author":{"id":1007000,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/98/98fe8de3.jpg","nickname":"zcqshine","note":"","ucode":"9DABA78369344E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3919,"discussion_content":"你用到了Java里面的linkedlist，而linkedlist是双向链表，利用双向链表的特性来做的话时间复杂度是O（n），头尾同时遍历比较即可","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1564981420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33233,"user_name":"hello,武招招","can_delete":false,"product_type":"c1","uid":1150472,"ip_address":"","ucode":"FBF4FCBBDA8904","user_header":"https://static001.geekbang.org/account/avatar/00/11/8e/08/b64c9ac6.jpg","comment_is_top":false,"comment_ctime":1539762690,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"40194468354","product_id":100017301,"comment_content":"golang使用快慢指针实现的回文字符串判断<br>type node struct {<br>\tdata interface{}<br>\tnext *node<br>}<br><br>type linkList struct {<br>\thead *node<br>\ttail *node<br>\tsize int32<br>}<br><br>func (l *linkList) reverseList() {<br>\tl.tail = l.head<br>\tvar after *node<br>\tvar pre *node<br>\troot := l.head<br>\tif l.head != nil &amp;&amp; l.head.next != nil {<br>\t\tfor root.next != nil {<br>\t\t\tafter = root.next<br>\t\t\troot.next = pre<br>\t\t\tpre = root<br>\t\t\troot = after<br>\t\t}<br>\t\troot.next = pre<br>\t\tl.head = root<br>\t}<br>}<br><br>func (l *linkList) getMidNode() *node {<br>\tslow := l.head<br>\tfast := l.head<br>\tfor fast != nil {<br>\t\t&#47;&#47; 已指向最后一个节点 奇数<br>\t\tif fast.next == nil || fast.next.next == nil {<br>\t\t\treturn slow<br>\t\t}<br>\t\tslow = slow.next<br>\t\tfast = fast.next.next<br>\t}<br>\treturn nil<br>}<br><br>&#47;&#47; 快慢指针判断回文字符串 奇数的话快指针刚好指向最后一个节点 偶数的话快指针指向空<br>&#47;&#47; 根据慢指针来定位中间节点<br>func isPalindrome(l *linkList) bool {<br>\tmid := l.getMidNode()<br>\tlength := l.getLength()<br>\tbackLinkList := creatLinkList()<br><br>\tif length%2 != 0 {<br>\t\tmid = mid.next<br>\t}<br>\tbackLinkList.setHeadNode(mid)<br>\tbackLinkList.reverseList()<br><br>\tpreHead := l.head<br>\tp := backLinkList.head<br>\tfor p != nil {<br>\t\tif preHead.data != p.data {<br>\t\t\treturn false<br>\t\t}<br>\t\tpreHead = preHead.next<br>\t\tp = p.next<br>\t}<br>\treturn true<br>}","like_count":9,"discussions":[{"author":{"id":1802896,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLFfibM3pkQJ5ZVGGjr4f9Aa1EaxmcFfSe5LibGicek2DVxseJ60mhCYwquEF1fUmRxNcVvLia5zm9w5A/132","nickname":"Geek_Demon","note":"","ucode":"FD4142C159F911","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":228706,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586570753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30168,"user_name":"我瑟瑟的方法","can_delete":false,"product_type":"c1","uid":1065819,"ip_address":"","ucode":"1364CD531E1B72","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/5b/17fef3ba.jpg","comment_is_top":false,"comment_ctime":1538710833,"is_pvip":false,"replies":[{"id":"10883","content":"麻烦自己百度一下吧 亲 百度一下好几十页都是讲回文串的","user_name":"作者回复","comment_id":30168,"uid":"1190123","ip_address":"","utype":1,"ctime":1538748543,"user_name_real":"gg"}],"discussion_count":3,"race_medal":0,"score":"27308514609","product_id":100017301,"comment_content":"什么是回文串","like_count":6,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425878,"discussion_content":"麻烦自己百度一下吧 亲 百度一下好几十页都是讲回文串的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538748543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1537064,"avatar":"https://static001.geekbang.org/account/avatar/00/17/74/28/f2bd28f7.jpg","nickname":"王小白","note":"","ucode":"31F29F3FFB6A06","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46219,"discussion_content":"上海自来水来自海上","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1573132312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1334015,"avatar":"https://static001.geekbang.org/account/avatar/00/14/5a/ff/e89eb122.jpg","nickname":"LipLipLip","note":"","ucode":"6D5EC6B5BEC600","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":230356,"discussion_content":"abccba","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586740958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29809,"user_name":"A漩","can_delete":false,"product_type":"c1","uid":1104060,"ip_address":"","ucode":"6E087D15CFE09B","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/bc/a20dc219.jpg","comment_is_top":false,"comment_ctime":1538547732,"is_pvip":false,"replies":[{"id":"10726","content":"字面上是你的理解 不过请百度百科一下LRU 我讲的没错呢","user_name":"作者回复","comment_id":29809,"uid":"1190123","ip_address":"","utype":1,"ctime":1538582047,"user_name_real":"gg"}],"discussion_count":4,"race_medal":0,"score":"27308351508","product_id":100017301,"comment_content":"最近最少使用策略 LRU（Least Recently Used）<br>老师此处的例子是着重体现了”最近“的场景吧！<br>如果想体现”最少“是不是还得为LinkedList加个”访问次数“的属性？","like_count":6,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425724,"discussion_content":"字面上是你的理解 不过请百度百科一下LRU 我讲的没错呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538582047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1672152,"avatar":"https://static001.geekbang.org/account/avatar/00/19/83/d8/d1b23905.jpg","nickname":"Stories","note":"","ucode":"B7E510C86079EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":19347,"discussion_content":"LFU为“最少使用的”，LRU为“上次使用离现在最久的”，这样理解更准确些，“最近最少使用”容易让人误解。","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1569163905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2217648,"avatar":"https://static001.geekbang.org/account/avatar/00/21/d6/b0/af0bf43e.jpg","nickname":"Banned404","note":"","ucode":"E36C481527388E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366914,"discussion_content":"你将least和recently理解成并列结构了，实际上least 是修饰 recently的，意思是 最不最近使用的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1618216972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1000023,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/57/3a7abbe9.jpg","nickname":"古思为","note":"","ucode":"5B01DD4BAEE130","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3292,"discussion_content":"Least Recently 的 Least 不是指次数最少，而是指 Recently 的 &#34;极小&#34;。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564377990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29768,"user_name":"Kudo","can_delete":false,"product_type":"c1","uid":1036948,"ip_address":"","ucode":"21965914B72AEB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d2/94/8bd217f1.jpg","comment_is_top":false,"comment_ctime":1538535132,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27308338908","product_id":100017301,"comment_content":"&gt;&gt; 思考题：用数组来实现 LRU 缓存淘汰策略。<br>为了使访问更有效率，我们用数组尾部的结点存储最近访问的数据。<br>1. 如果此数据之前已经被缓存在数组中了，反向遍历得到这个数据对应的结点，将其放在数组尾部，并将原先该结果后面的结点分别向前移动一个单位。<br>2. 如果此数据没有在缓存数组中，又可分两种情况。<br>（1）如果此时缓存未满，则将此结点插入到数组的尾部；<br>（2）如果此时缓存已满，则将数组头部结点删除，将新的数据结点插入数组尾部，并将其它所有节点分别前移一个单位。<br>该操作的时间复杂度为O(n)，相对链表实现方式涉及更多的数据移动动操作，因此访问效率要低一些。","like_count":6,"discussions":[{"author":{"id":1212438,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJpaa2pEggFCtaX455yukBbnhoD95AG2WAfyUxG69xFnYyR93A0PibACNgZaEZpDq8t8XkgTAibzaRw/132","nickname":"barnabas","note":"","ucode":"87FB55480C5C84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587750,"discussion_content":"增加指针表示头和淘汰位子，把数组看成环形结构，满时只需直接替换淘汰指针的数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663251306,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225810,"user_name":"TANMIYOO","can_delete":false,"product_type":"c1","uid":1375256,"ip_address":"","ucode":"BC3556131D4D61","user_header":"https://static001.geekbang.org/account/avatar/00/14/fc/18/8e69f7cf.jpg","comment_is_top":false,"comment_ctime":1591865083,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23066701563","product_id":100017301,"comment_content":"链表反转的代码理解了整整三个钟头","like_count":5},{"had_liked":false,"id":189081,"user_name":"林绍灏","can_delete":false,"product_type":"c1","uid":1242340,"ip_address":"","ucode":"AA2CB00DB0C97C","user_header":"https://static001.geekbang.org/account/avatar/00/12/f4/e4/e7f7ca92.jpg","comment_is_top":false,"comment_ctime":1584454511,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"23059290991","product_id":100017301,"comment_content":"leetcode上的题号是: 234 , 说下思路:<br>1) 首先是利用快慢指针找到链表的中点, 其思路是:<br>快指针与慢指针均从头出发,但快指针的速度是慢指针的两倍, 故当快指针到达链表的尾部时, 慢指针的位置就是终点;<br>2) 由于链表的节点数可能为偶数,对于偶数的情形, 快指针所在的终点其实并非是真的在最后一个节点上, 而是指向倒数第二个,故此时慢指针所指向的其实是在前半段链表中, 所以对于这种情形,需要调整下慢指针的位置,将其移后一位;<br>3) 以慢指针作为起点,反转后半段链表, 并用一个新指针指向反转后的链表头;<br>4) 前后两段链表进行逐个节点的比较, 循环终止条件是前半段链表的指针不等于慢指针, 此时慢指针充当中间界碑; <br>5) 链表恢复,其实就是将后半段,再反转回来.","like_count":5,"discussions":[{"author":{"id":2247846,"avatar":"https://static001.geekbang.org/account/avatar/00/22/4c/a6/81c0ed8a.jpg","nickname":"晨曦感恩","note":"","ucode":"ED2324D6057575","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352769,"discussion_content":"前提是快指针先走","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614845732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2247846,"avatar":"https://static001.geekbang.org/account/avatar/00/22/4c/a6/81c0ed8a.jpg","nickname":"晨曦感恩","note":"","ucode":"ED2324D6057575","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352767,"discussion_content":"不需要分节点数为奇数偶数，这两种情况下，都是比较中点的下一位，也就是说，都是从中点的下一位开始比较的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614845678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81711,"user_name":"Geek_cxz","can_delete":false,"product_type":"c1","uid":1482158,"ip_address":"","ucode":"AAEC9BDEE492E3","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q8tVHVrialm0x9iaF9aLoibq8MQ7oI1QPZMHz4EabKPkHdy6gFklQTUXIEAp3iaRKficRLhCravEp56u6euXMOgavbA/132","comment_is_top":false,"comment_ctime":1554015674,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23028852154","product_id":100017301,"comment_content":"用单向循环链表解决约瑟夫环问题：<br>public class JosephProblem&lt;T&gt; {<br>    private Node first;<br>    private Node last;<br><br>    public void add(T data) {<br>        if (last == null) {<br>            first = new Node(data);<br>            last = first;<br>        } else {<br>            Node node = new Node(data);<br>            last.next = node;<br>            last = node;<br>        }<br>        last.next = first;<br>    }<br><br>    private class Node {<br>        private Node next;<br>        private T data;<br><br>        public Node(T data) {<br>            this.data = data;<br>        }<br>    }<br><br>    &#47;**<br>     * @param x 约瑟夫问题中从1开始，到第x个被去除<br>     *&#47;<br>    public void solveProblem(int x) {<br>        Node t = first;<br>        &#47;&#47;循环终止条件，只剩一个节点<br>        while (t.next != t) {<br>            &#47;&#47;找到要去除节点的前一个节点t<br>            for (int i = 1; i &lt;x-1; i++) {<br>                t=t.next;<br>            }<br>            System.out.println(t.next.data);<br>            &#47;&#47;记录被去除节点<br>            Node temp=t.next;<br>            &#47;&#47;去除节点<br>            t.next=temp.next;<br>            &#47;&#47;t指向被去除节点的后一个节点<br>            t=temp.next;<br>        }<br>    }<br>    &#47;&#47; 1 2 3 4 5<br>    &#47;&#47; 1 3 4 5<br>    &#47;&#47; 1 3 5<br>    &#47;&#47; 3 5<br>    &#47;&#47; 3<br>    public static void main(String[] args) {<br>        JosephProblem&lt;Integer&gt; josephProblem=new JosephProblem&lt;Integer&gt;(){<br>            {<br>                add(1);<br>                add(2);<br>                add(3);<br>                add(4);<br>                add(5);<br>            }<br>        };<br>        josephProblem.solveProblem(2);<br>    }<br>}","like_count":5,"discussions":[{"author":{"id":2915218,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/7b/92/ce884691.jpg","nickname":"云水禅心🌓","note":"","ucode":"1B0782009BC5B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552884,"discussion_content":"写的清晰易懂！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645624964,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71172,"user_name":"令仔很忙","can_delete":false,"product_type":"c1","uid":1180427,"ip_address":"","ucode":"485314E2BE327A","user_header":"https://static001.geekbang.org/account/avatar/00/12/03/0b/c32a7e97.jpg","comment_is_top":false,"comment_ctime":1551276658,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23026113138","product_id":100017301,"comment_content":"CPU缓存也是分级别的，L1，L2，L3，L3最靠近内存，查询缓存时会先查询L1、没有的情况下依次查询L2、L3，因此响应的速度L1&gt;L2&gt;L3，L1应该也叫缓存行吧，通常是64个字节的，因为数组在内存中的分配是连续的，如果你申请的内存正好在64字节内，那么响应速度肯定是非常快的，而链表在内存中是不连续的，没办法直接使用缓存行。","like_count":5},{"had_liked":false,"id":55801,"user_name":"逍遥一叹","can_delete":false,"product_type":"c1","uid":1358759,"ip_address":"","ucode":"9FCAEB2E57DB70","user_header":"https://static001.geekbang.org/account/avatar/00/14/bb/a7/03f90dc4.jpg","comment_is_top":false,"comment_ctime":1546311843,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"23021148323","product_id":100017301,"comment_content":"课后作业好多人都是使用：快慢指针定位中间节点的方法。为啥没人使用最基本的方法：<br>1、先找到链表尾(时间复杂度o(n))<br>2、一个指针从链表头往后遍历，一个指针从链表尾往前遍历，同时比较字符内容<br>3、如果发现有不一样的就表示不是回文数，如果两个指针最后指到一起或者相邻就表示回文数<br><br>上面的操作第一步复杂度最高，如果使用有指针保存链表尾，第二、三步平均复杂度才o(1)","like_count":5,"discussions":[{"author":{"id":1042685,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/fd/abb7bfe3.jpg","nickname":"Langzi233","note":"","ucode":"5A21AC08FC089B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3772,"discussion_content":"单链表，不是双向链表","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1564802675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1901428,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLwIAiaxOJWE3Ut6hRvTzvFkCIibcURojC0XrQI1lC3h58enlNcpXQ98rmUOr5lA6ST3m24micj191Gw/132","nickname":"不疾","note":"","ucode":"18AA0F294C1586","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":226014,"discussion_content":"单链表没有指向上个结点的指针，从尾向前遍历不现实","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586415374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2062645,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/79/35/aa73b295.jpg","nickname":"莫失莫忘","note":"","ucode":"F5E101EF08FA4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291854,"discussion_content":"双向链表才能这样弄吧\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594976140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1025093,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a4/45/3cb5cdc6.jpg","nickname":"拾迹","note":"","ucode":"38F367B77FF2D7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":176726,"discussion_content":"我的思路跟你差不多，不过我是将单链表变为双链表。这样的空间复杂度是 O(n)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582039999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29825,"user_name":"小帅b","can_delete":false,"product_type":"c1","uid":1234521,"ip_address":"","ucode":"D866A428967480","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/59/cb4e7ed8.jpg","comment_is_top":false,"comment_ctime":1538554959,"is_pvip":false,"replies":[{"id":"10722","content":"👍","user_name":"作者回复","comment_id":29825,"uid":"1190123","ip_address":"","utype":1,"ctime":1538581610,"user_name_real":"gg"}],"discussion_count":1,"race_medal":0,"score":"23013391439","product_id":100017301,"comment_content":"--------总结一下--------<br><br><br>常见的链表结构<br>1.单链表：<br>每个节点除了存储数据之外，还有记录下一个节点的地址，这样才能串联起来，记录下一个节点地址的指针就是「后续指针next」。<br>其中有两个特殊的节点为「头结点」和「尾节点」，头结点记录链表的基地址，尾节点记录下一个节点地址是NULL，代表链表的最后一个节点。<br><br>链表增删效率高<br>对于链表（存储数据无需连续性）的增删，只需要考虑指针的改变，复杂度为O（1）。<br><br>链表访问慢<br>由于不像数组那样可以根据首选地址和下标计算出内存地址，只能通过遍历节点获取地址。时间复杂度为0（n）。<br><br>2.循环链表<br>是特殊的单链表，尾节点指针指向链表的头结点。<br><br>3.双向链表<br>支持双向，除了「后续指针next」还有「前驱指针prev」<br><br>相比单链表和双链表，增删查效率高，内存消耗高。<br><br>空间换时间，时间换空间<br>对于执行慢的程序--&gt;空间换时间<br>对于消耗内存多的程序--&gt;时间换空间<br><br>链表和数组的区别<br><br>底层存储结构：<br>数组需要一块连续的内存空间存储<br>链表通过“指针”将一组零散的内存块串联起来使用<br><br>性能：<br>1.链表和数组的（增删查）时间复杂度正好相反。<br><br>2.数组使用连续的内存空间，可以借助缓存机制提高效率。<br>链表不连续，所以无法借助缓存机制。<br><br>3.数组大小固定，当要申请更大的空间，需要拷贝数据，很耗时。<br>链表则支持动态扩容。<br><br>4.相对来说链表比较耗内存，因为需要记录节点指针，内存消耗翻倍。","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425730,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538581610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29806,"user_name":"James Scott","can_delete":false,"product_type":"c1","uid":1255048,"ip_address":"","ucode":"E673BD69503693","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/88/e8098480.jpg","comment_is_top":false,"comment_ctime":1538547172,"is_pvip":false,"replies":[{"id":"10732","content":"谢谢你🙏 不过我没有写错。已经回复给他。不过，你为什么觉得我写错了呢？","user_name":"作者回复","comment_id":29806,"uid":"1190123","ip_address":"","utype":1,"ctime":1538582621,"user_name_real":"gg"}],"discussion_count":2,"race_medal":0,"score":"23013383652","product_id":100017301,"comment_content":"回复一下CaiBird的提问：应该是写错了，应该是越靠近链表头部的节点是越早被访问的。","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425722,"discussion_content":"谢谢你🙏 不过我没有写错。已经回复给他。不过，你为什么觉得我写错了呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538582621,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2264679,"avatar":"https://static001.geekbang.org/account/avatar/00/22/8e/67/afb412fb.jpg","nickname":"陈威洋","note":"","ucode":"DCF84B4D3A7354","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351387,"discussion_content":"哈哈\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614256064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29751,"user_name":"yaya","can_delete":false,"product_type":"c1","uid":1233856,"ip_address":"","ucode":"8C7FAC8F828BA4","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/c0/d38daa2d.jpg","comment_is_top":false,"comment_ctime":1538530417,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23013366897","product_id":100017301,"comment_content":"思考题:先用快慢指针得中点，然后将后段链表逆序，比较是否是回文串。再将链表逆序回来，时间复杂度o（n）,空间复杂度o（1）.<br>利用数组实现lru,想法是利用堆的思想，根据时间最远最少用的规则建立堆，利用结构体维护最近的访问时间，根据其建堆，如果一个新的元素来，遍历数组，如果能找到，更新他的参数，调整堆。如果不能就将堆的头元素删除，插入该元素","like_count":5},{"had_liked":false,"id":30197,"user_name":"章光辉","can_delete":false,"product_type":"c1","uid":1046152,"ip_address":"","ucode":"49ACA750CAF19E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f6/88/ee32fde9.jpg","comment_is_top":false,"comment_ctime":1538721365,"is_pvip":true,"replies":[{"id":"10893","content":"对的","user_name":"作者回复","comment_id":30197,"uid":"1190123","ip_address":"","utype":1,"ctime":1538749196,"user_name_real":"gg"}],"discussion_count":2,"race_medal":0,"score":"18718590549","product_id":100017301,"comment_content":"判断访问的数据是否存在于缓存里的时候，无论是链表还是数组，时间复杂度都是O(n)对吧？那么在此基础上做的增删改，最高的复杂度也只是O(n)。根据加法法则，总的复杂度都是O(n)。不知道我理解得对不对？","like_count":4,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425891,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538749196,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1792714,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/5a/ca/4d5d23d1.jpg","nickname":"Im me","note":"","ucode":"FF7DEED4BB4C37","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371054,"discussion_content":"争哥，那这样的话岂不是只要是涉及到增删改链表和数组的复杂度一样，用什么都可以了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619619466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102643,"user_name":"卓修武","can_delete":false,"product_type":"c1","uid":1105385,"ip_address":"","ucode":"21B8FFBDCACBDF","user_header":"https://static001.geekbang.org/account/avatar/00/10/dd/e9/40a98e2f.jpg","comment_is_top":false,"comment_ctime":1560269362,"is_pvip":false,"replies":[{"id":"37276","content":"👍！你说的很对的！确实不够严谨。实际情况也不会确实不一定会翻倍。","user_name":"作者回复","comment_id":102643,"uid":"1190123","ip_address":"","utype":1,"ctime":1560382324,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"14445171250","product_id":100017301,"comment_content":"&quot;因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个节点的指针，所以内存消耗会翻倍&quot;，这句话似乎有点不太严谨，存储的只是指针，内存消耗会翻倍是跟什么比较的？","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453515,"discussion_content":"👍！你说的很对的！确实不够严谨。实际情况也不会确实不一定会翻倍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560382324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2168076,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/gCicXWnGF3F3mlHGfzMVfkZfedzBxlg4E0Zul0IkIHickNTr4PboPuq3B3bicEPibzooOOdaL6D4ftiaDssgaxyyUpQ/132","nickname":"Geek_886387","note":"","ucode":"021CC8A049FCFD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304395,"discussion_content":"当数据本身非常大的时候，指针所消耗的空间就可以不计了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599561735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72200,"user_name":"Bufan","can_delete":false,"product_type":"c1","uid":1387704,"ip_address":"","ucode":"A5EC0391C412DE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eriaIgoPa8abNTaUm7o6oa6mvL9iagRTdD1vhovWPyfiaS82f409Sz3kMFzYLNa4ibnHagA7M33l8XnIQ/132","comment_is_top":false,"comment_ctime":1551533496,"is_pvip":false,"replies":[{"id":"26268","content":"数组中存储的应该是元素的内存地址，元素是散落存储在内存中的。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551665836,"ip_address":"","comment_id":72200,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14436435384","product_id":100017301,"comment_content":"我有一个疑问，javascript数组的每一个元素大小不是一样的，那查找的时间复杂度还是O（1）吗？","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441492,"discussion_content":"数组中存储的应该是元素的内存地址，元素是散落存储在内存中的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551665836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2049021,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/43/fd/cf190699.jpg","nickname":"Geek_frank","note":"","ucode":"CF973E61ED2E59","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339902,"discussion_content":"Js中的数组实质上是对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609835405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":68740,"user_name":"大大大侠饶命","can_delete":false,"product_type":"c1","uid":1253975,"ip_address":"","ucode":"9C59655D514AA2","user_header":"https://static001.geekbang.org/account/avatar/00/13/22/57/0ecc24e8.jpg","comment_is_top":false,"comment_ctime":1550589461,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14435491349","product_id":100017301,"comment_content":"我靠，看文章20分钟，看评论估计得要1小时，这课可以。分享到朋友圈","like_count":3},{"had_liked":false,"id":30090,"user_name":"🤔","can_delete":false,"product_type":"c1","uid":1066834,"ip_address":"","ucode":"4DAE32D4820509","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/52/5205764a.jpg","comment_is_top":false,"comment_ctime":1538656010,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14423557898","product_id":100017301,"comment_content":"理论大概明白，但是还有个问题，用js实现了个链表类，并且模拟Array.prototype.splice实现了链表的在指定下标插入操作，因为要循环遍历找到指定下标前的节点所以时间复杂度应该是O(n)，splice应该也是O(n)，但用console.time测了下循环10000次插入操作，链表插入比数组splice快了6ms，仅仅是因为splice执行了其他额外操作吗？怎么理解这种相同复杂度下两种不同结构造成的差异呢？","like_count":3},{"had_liked":false,"id":29860,"user_name":"港","can_delete":false,"product_type":"c1","uid":1122464,"ip_address":"","ucode":"35931FC6198180","user_header":"https://static001.geekbang.org/account/avatar/00/11/20/a0/1fca96c0.jpg","comment_is_top":false,"comment_ctime":1538567539,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14423469427","product_id":100017301,"comment_content":"创建一个与原来链表相同的反向链表，然后一个一个结点比对，时间复杂度是O(n)，空间复杂度是O(n)。","like_count":3},{"had_liked":false,"id":29769,"user_name":"Astrian 🦊","can_delete":false,"product_type":"c1","uid":1025934,"ip_address":"","ucode":"760304E6534FE1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a7/8e/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1538535248,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14423437136","product_id":100017301,"comment_content":"简单写了一下 JS 下的链表实现，https:&#47;&#47;gist.github.com&#47;Astrian&#47;0fab823f41e288cc2fc324ba3991d1b8，希望可以有帮助+求大佬指点 (=ﾟωﾟ)ﾉ","like_count":3},{"had_liked":false,"id":240432,"user_name":"Jiantao","can_delete":false,"product_type":"c1","uid":1163504,"ip_address":"","ucode":"444580EC5EF109","user_header":"https://static001.geekbang.org/account/avatar/00/11/c0/f0/1aabc056.jpg","comment_is_top":false,"comment_ctime":1596905372,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10186839964","product_id":100017301,"comment_content":"#cp<br>总结<br>一、什么是链表？<br>1.和数组一样，链表也是一种线性表。<br>2.从内存结构来看，链表的内存结构是不连续的内存空间，是将一组零散的内存块串联起来，从而进行数据存储的数据结构。<br>3.链表中的每一个内存块被称为节点Node。节点除了存储数据外，还需记录链上下一个节点的地址，即后继指针next。<br>二、为什么使用链表？即链表的特点<br>1.插入、删除数据效率高O(1)级别（只需更改指针指向即可），随机访问效率低O(n)级别（需要从链头至链尾进行遍历）。<br>2.和数组相比，内存空间消耗更大，因为每个存储数据的节点都需要额外的空间存储后继指针。<br>三、常用链表：单链表、循环链表和双向链表<br>1.单链表<br>1）每个节点只包含一个指针，即后继指针。<br>2）单链表有两个特殊的节点，即首节点和尾节点。为什么特殊？用首节点地址表示整条链表，尾节点的后继指针指向空地址null。<br>3）性能特点：插入和删除节点的时间复杂度为O（1），查找的时间复杂度为O(n)。<br>2.循环链表<br>1）除了尾节点的后继指针指向首节点的地址外均与单链表一致。<br>2）适用于存储有循环特点的数据，比如约瑟夫问题。<br>3.双向链表<br>1）节点除了存储数据外，还有两个指针分别指向前一个节点地址（前驱指针prev）和下一个节点地址（后继指针next）。<br>2）首节点的前驱指针prev和尾节点的后继指针均指向空地址。<br>3）性能特点：<br>和单链表相比，存储相同的数据，需要消耗更多的存储空间。<br>插入、删除操作比单链表效率更高O(1)级别。以删除操作为例，删除操作分为2种情况：给定数据值删除对应节点和给定节点地址删除节点。对于前一种情况，单链表和双向链表都需要从头到尾进行遍历从而找到对应节点进行删除，时间复杂度为O(n)。对于第二种情况，要进行删除操作必须找到前驱节点，单链表需要从头到尾进行遍历直到p-&gt;next = q，时间复杂度为O(n)，而双向链表可以直接找到前驱节点，时间复杂度为O(1)。<br>对于一个有序链表，双向链表的按值查询效率要比单链表高一些。因为我们可以记录上次查找的位置p，每一次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。<br>4.双向循环链表：首节点的前驱指针指向尾节点，尾节点的后继指针指向首节点。<br>四、选择数组还是链表？<br>1.插入、删除和随机访问的时间复杂度<br>数组：插入、删除的时间复杂度是O(n)，随机访问的时间复杂度是O(1)。<br>链表：插入、删除的时间复杂度是O(1)，随机访问的时间复杂端是O(n)。<br>2.数组缺点<br>1）若申请内存空间很大，比如100M，但若内存空间没有100M的连续空间时，则会申请失败，尽管内存可用空间超过100M。<br>2）大小固定，若存储空间不足，需进行扩容，一旦扩容就要进行数据复制，而这时非常费时的。<br>3.链表缺点<br>1）内存空间消耗更大，因为需要额外的空间存储指针信息。<br>2）对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java语言，还可能会造成频繁的GC（自动垃圾回收器）操作。<br>4.如何选择？<br>数组简单易用，在实现上使用连续的内存空间，可以借助CPU的缓冲机制预读数组中的数据，所以访问效率更高，而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法预读。<br>如果代码对内存的使用非常苛刻，那数组就更适合。","like_count":2},{"had_liked":false,"id":103353,"user_name":"小白菜","can_delete":false,"product_type":"c1","uid":1568340,"ip_address":"","ucode":"ACD1267D329B96","user_header":"https://static001.geekbang.org/account/avatar/00/17/ee/54/dac0a6b6.jpg","comment_is_top":false,"comment_ctime":1560418743,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10150353335","product_id":100017301,"comment_content":"打卡学习，老师写的文章质量很高，要细细品问，反复研读。","like_count":2},{"had_liked":false,"id":88757,"user_name":"黑白之间","can_delete":false,"product_type":"c1","uid":1504541,"ip_address":"","ucode":"13D3C767F63C1B","user_header":"https://static001.geekbang.org/account/avatar/00/16/f5/1d/f17db8b8.jpg","comment_is_top":false,"comment_ctime":1555993661,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10145928253","product_id":100017301,"comment_content":"检测链表有环我们可以创建两个指针，一个指针每次走一位，另一个指针走两位，然后判断两个指针如果指向同一个地址，说明有环","like_count":2},{"had_liked":false,"id":64863,"user_name":"京","can_delete":false,"product_type":"c1","uid":1267526,"ip_address":"","ucode":"F69476C14C5405","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIWgpgEACljAII095cibNoPxlR6X3sIY1fmf4KjNjIoZ8icUOYL206lAcsqMsMl80pc4IbnsrpE28rQ/132","comment_is_top":false,"comment_ctime":1548928097,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10138862689","product_id":100017301,"comment_content":"用数组实现LRU 缓存淘汰策略<br>思路：<br> 1、维护一个固定大小的有序数组<br>*2、如果访问的元素在数组中，获取元素的原位置，将原位置之前的所有元素整体向后移动一位，访问的元素放在数组第一个位置<br> 3、如果访问的元素不在数组中，获取需要重新排序的元素位置，将该位置之前的所有元素整体向后移动一位，访问的元素放在数组第一个位置<br><br>代码实现：<br>public class LRUBaseArrayList {<br>\t&#47;&#47; 数组长度<br>\tString array[] = new String[10];\t<br>\tpublic void add (String str) {<br>\t\t&#47;&#47; 判断新访问的元素是否在数组中<br>\t\tInteger in = isInArray(str);<br>\t\tif (in == null) {&#47;&#47; 不在数组中<br>\t\t\t&#47;&#47; 获取需要重新排序的元素位置<br>\t\t\tint i = getPox();<br>\t\t\tputStrToFirst(str,i);<br>\t\t} else {&#47;&#47; 在数组中<br>\t\t\t&#47;&#47; in位置之前的元素重新排序，新元素放在数组第一个位置<br>\t\t\tputStrToFirst(str,in);<br>\t\t}<br>\t}<br>\tprivate int getPox() {<br>\t\tint i = 0;<br>\t\twhile (array[i] != null) {<br>\t\t\tif (i == array.length-1) {<br>\t\t\t\tbreak;<br>\t\t\t}<br>\t\t\ti++;<br>\t\t}<br>\t\treturn i;\t<br>\t}<br>\t<br>\tprivate void putStrToFirst(String str,int count) {<br>\t\tfor (; count &gt; 0; count--) {<br>\t\t\tarray[count] = array[count-1];\t\t\t<br>\t\t}<br>\t\tarray[0] = str;<br>\t}<br><br>\tprivate Integer isInArray(String str) {<br>\t\tfor (int i = 0; i &lt; array.length; i++) {<br>\t\t\tif (str.equals(array[i])) {<br>\t\t\t\treturn i;<br>\t\t\t}<br>\t\t}<br>\t\treturn null;<br>\t}<br>\t<br>\tpublic void printAll() {<br>\t\tfor (int i = 0; i &lt; array.length; i++) {<br>\t\t\tSystem.out.print(array[i]+&quot;,&quot;);<br>\t\t}<br>\t\tSystem.out.println();<br>\t}<br>\t<br>\tpublic static void main(String[] args) {<br>\t\tLRUBaseArrayListBy list = new LRUBaseArrayListBy();<br>\t\tScanner sc = new Scanner(System.in);<br>        while (true) {<br>        \tlist.add(sc.next());<br>        \tlist.printAll();<br>        }<br>\t}<br>}<br>","like_count":2},{"had_liked":false,"id":60613,"user_name":"Apollo","can_delete":false,"product_type":"c1","uid":1183821,"ip_address":"","ucode":"3A0C79CCB21FD9","user_header":"https://static001.geekbang.org/account/avatar/00/12/10/4d/f548bc68.jpg","comment_is_top":false,"comment_ctime":1547518967,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10137453559","product_id":100017301,"comment_content":"关于缓存行不了解的同学请参考：http:&#47;&#47;blog.jobbole.com&#47;89759","like_count":2},{"had_liked":false,"id":34333,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1540113800,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10130048392","product_id":100017301,"comment_content":"阅后留痕<br><br>1：链表——这种数据结构的特点如下<br>1-1）线性表结构，元素之间有前后关系，逻辑结构上相邻<br>1-2）通过指针关联，元素之间在物理内存上是割裂的或者不连续的<br>1-3）和数组非常的相像区别在于，数组在逻辑和物理上元素之间都是连续，链表的元素则在逻辑上有连续的物理上则是不连续的，链表采用了以空间换时间的改进策略，至少在元素的删除和插入操作上可以这么认为，不需要移动数据只需要改变指针的指向，另外就是能够充分利用零碎的内存空间<br><br>2：链表的分类，主要通过指针的前后指向和尾指针的指向这两个维度的特点来分类的<br>2-1）单向链表<br>         体育课上，同学们排成一列，全部面向南向，都用左手搭在前面一位同学的肩上的样子，最后一位同学除外<br>2-2）双向链表<br>         体育课上，同学们排成一列，全部面向南向，都用左手搭在前面一位同学的肩上，<br>都用右手搭在后面一位同学的肩上的样子，第一位同学的右手和最后一位同学的左手除外<br>2-3）单向循环链表<br>         体育课上，同学们排成一列，全部面向南向，都用左手搭在前面一位同学的肩上的样子，最后一位的左手搭在了第一位同学的肩上<br>2-4）双向循环链表<br>         体育课上，同学们排成一列，全部面向南向，都用左手搭在前面一位同学的肩上，<br>都用右手搭在后面面一位同学的肩上的样子，第一位同学的右手搭在最后一位同学的肩上，最后一位同学的左手搭在第一位同学的肩上<br><br>同学的左手，类似指向下一个元素的指针<br>同学的右手，类似指向上一个元素的指针<br>构成循环与否的关键在于尾元素指针的指向<br><br>3：结构决定功能，所以，和数组相比，链表查询较耗时，插入和删除则性能较好，不过也要看插入和删除的位置的，如果必须以查询为前提，则总体性能也一般，则其最大的优势在于天然支持动态扩容<br>数组和链表的时间复杂度比较，如下所示<br>               数组   链表<br>插入删除  O(n)   O(1)<br>随机访问  O(1)   O(n)<br><br>4：空间换时间，是性能优化的一种重要思路，缓存机制应用的非常广泛，他是典型的使用空间换时间的实现方案，当然，缓存的空间也是有限的，如果缓存满了，该怎么办？那只能淘汰一些缓存的内容呗！淘汰那些内容呢？目前思路有三种，一是先进先出，二是最少使用先出，三是最近最少使用先出<br>当然，如果空间紧张，也可以采用时间换空间的思路来解决问题<br><br>5：算法是基于数据结构来讲的，毕竟对于数据而言，无非是增删改查四种操作，排序也主要是为了更快的查找，毕竟对于数据而言，查询的需求一般总是比其他的操作要更多的，使用不同的数据结构存储数据是视具体的业务场景来说，看看哪种更能满足或者符合我们的也许需要，所谓的符合业务操作，我认为就是我们想要的操作，选择对了对应的数据结构后会操作的更加得心应手和高效，高效性是常常我们的需求核心。<br><br>6：最后的思考题，如果限定只能使用单向链表，则其他同学的回答我认为非常好，我目前没有相出更好的法子，思路这里记上一笔<br>6-1）定位中心，快慢指针的方式<br>6-2）逆转部分链表，前后都应该可以<br>6-3）对比，看看是否为回文<br>6-4）回复原状<br>回文，奇偶的例子都比较容易造，比如：AA,ABA","like_count":2},{"had_liked":false,"id":31637,"user_name":"(≧ω≦)罗敏","can_delete":false,"product_type":"c1","uid":1131416,"ip_address":"","ucode":"F7AE0F4F717115","user_header":"https://static001.geekbang.org/account/avatar/00/11/43/98/d1f6c524.jpg","comment_is_top":false,"comment_ctime":1539251715,"is_pvip":false,"replies":[{"id":"11402","content":"好像空间复杂度有点高了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539268617,"ip_address":"","comment_id":31637,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10129186307","product_id":100017301,"comment_content":"单链表判断是否是回文串:<br>把原先的单链表倒序复制一遍，然后比较两个链表是否值相同","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426442,"discussion_content":"好像空间复杂度有点高了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539268617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1006768,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5c/b0/77e5f8c8.jpg","nickname":"李孟","note":"","ucode":"AD2349CB12F130","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288005,"discussion_content":"单链表回文 \npublic boolean isPalindrome(){\n        Link tmp1 = first;\n        int n = count/2;\n        int i=0;\n\n        Link tmp2 = null;\n        while (i < n){\n            tmp1 = tmp1.getNext();\n            i++;\n        }\n        tmp2 = tmp1.getNext();\n\n        Link cur = tmp2.getNext();\n        Link tmp ;\n        while (cur !=null){\n            tmp = cur.getNext();\n            cur.setNext(tmp2);\n            //反向指针\n            tmp2 = cur;\n            cur = tmp;\n        }\n\n        i=0;\n        tmp1 = first;\n        boolean result = true;\n        while (i < n){\n            if(tmp2 == null) break;\n\n            if(!tmp1.getData().equals(tmp2.getData())) {\n                result = false;\n            }\n            tmp1 = tmp1.getNext();\n            tmp2 = tmp2.getNext();\n\n            i++;\n        }\n        return result;\n    }","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593612308,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31521,"user_name":"小志","can_delete":false,"product_type":"c1","uid":1037841,"ip_address":"","ucode":"11C9EAB9746D8B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d6/11/808eb5f8.jpg","comment_is_top":false,"comment_ctime":1539221980,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10129156572","product_id":100017301,"comment_content":"印象中，还记得CPU还有一级、二级、三级缓存呢吧","like_count":2},{"had_liked":false,"id":31446,"user_name":"xdargs","can_delete":false,"product_type":"c1","uid":1063740,"ip_address":"","ucode":"EB8326D3A72DE5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoH9Mlw0kLK0p39vhQpdvkbQP5TX96DB9HMJ1POaTVDpMZg4rjlO3WCAqiaWWMc77ffS3vTo8qWdXA/132","comment_is_top":false,"comment_ctime":1539181827,"is_pvip":true,"replies":[{"id":"11429","content":"多谢认可🙏","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539269905,"ip_address":"","comment_id":31446,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10129116419","product_id":100017301,"comment_content":"讲得很容易理解，不多的篇幅讲知识点和应用，润物无声","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426343,"discussion_content":"多谢认可🙏","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539269905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30632,"user_name":"Geek_41d472","can_delete":false,"product_type":"c1","uid":1247965,"ip_address":"","ucode":"DEC2B6329460CF","user_header":"https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg","comment_is_top":false,"comment_ctime":1538962555,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10128897147","product_id":100017301,"comment_content":"除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。<br>﹉﹉﹉<br>老师，上面这段话什么意思，有点理解不了！双向链表查询效率为什么比单链表要高？记录上次查找的P又是啥意思？在哪里记录，在链表还是自己单独用一个内存(变量）记录？","like_count":2,"discussions":[{"author":{"id":2991178,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/a4/4a/43ffc522.jpg","nickname":"噢，必胜耶","note":"","ucode":"9F18D4A2B620F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568402,"discussion_content":"时隔4年，居然还没有人回复这个问题，真是 悲哀！今天，我打算回答一下这个问题，留下答案，是为了 后面的人，看到这样的问题时，能够及时醒悟，少走弯路！\n首先，这个 问题有个2个关键点， （1） 为什么需要有序的链表？ （2）什么是 按值查询？第一个点好解释， 有序 是为了 保证，双向链表，向前 或者 向后 遍历的时候，能够仅仅根据数值的大小，然后 朝一个 方向，就能找到该元素（你想想，如果不是有序的，你朝着一个方向，就可能找不到该元素）； 第二个点可能才是 导致 误解的根本因素， 所谓的 “按值查询”---》这四个字，理解起来就是 已经知道元素的位置，然后从链表上把他找出来（所以，对于已经排好序的双向链表而言，我们只需要 比较 该元素 与 二分之一处的位置大小，就知道 时 从 head 指针开始 遍历，还是 从 last指针 遍历了,这时候你就会发现，通常最多只需要遍历一半的元素，就可以找到了，此时 ，时间复杂度降低为O(n/2)）；\n\n很多人因此误解，“随机访问”  --》是在原本的数据结构下，直接找到元素的内存地址。在这个情况下，我们是不知道元素的位置的，只能 从头到尾，遍历 链表，因此，不论是 双向的。还是 单向的链表，他们的时间复杂度 都是 O(n),是不可能被算法优化的。\n我们再来读一下这句话，\n“我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据”  -----》 所以，不要被这一句话误导，这一句话，其实就是指 “按值查询”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651126240,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29983,"user_name":"猫头鹰爱拿铁","can_delete":false,"product_type":"c1","uid":1105958,"ip_address":"","ucode":"24266B58968428","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/26/4942a09e.jpg","comment_is_top":false,"comment_ctime":1538619262,"is_pvip":true,"replies":[{"id":"10824","content":"方法很巧妙，不过借助了栈，空间复杂度就是O(n)了。可以想想有没有空间复杂度是O(1)的算法。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538658348,"ip_address":"","comment_id":29983,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10128553854","product_id":100017301,"comment_content":"判断字符串是否为回文字符串？遍历单链表同时放到一个栈里面，然后再遍历一遍单链表，遍历的同时和栈pop出的数据对比，全都一致则说明为回文字符串。","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425800,"discussion_content":"方法很巧妙，不过借助了栈，空间复杂度就是O(n)了。可以想想有没有空间复杂度是O(1)的算法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538658348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29856,"user_name":"小喵喵","can_delete":false,"product_type":"c1","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1538566364,"is_pvip":false,"replies":[{"id":"10714","content":"1. 因为链表是有序的，按照访问时间排序；<br>2. cache怎么过期的呢？麻烦说详细点。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538581188,"ip_address":"","comment_id":29856,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10128500956","product_id":100017301,"comment_content":"如果此数据之前已经被缓存在链表中了,我们遍历得到这个数据对应的结点,并将其从原来的位置删除，然后再插入到链表的头部。<br>1。LRU算法这点不太理解，为什么都在cache中，还有删除掉重新插入呢？<br>2.  这个LRU算法，cache过期了，如何更新呢？请老师指点一下。<br><br><br><br><br><br>","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425742,"discussion_content":"1. 因为链表是有序的，按照访问时间排序；\n2. cache怎么过期的呢？麻烦说详细点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538581188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29820,"user_name":"辰陌","can_delete":false,"product_type":"c1","uid":1245043,"ip_address":"","ucode":"961C874D36C958","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/73/8c64ed7f.jpg","comment_is_top":false,"comment_ctime":1538553702,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10128488294","product_id":100017301,"comment_content":"日常打卡，总结到笔记本了，，就不打出来了，，希望各位大神踊跃发言，可以更好地给我等菜鸟解惑创造有利环境。","like_count":2},{"had_liked":false,"id":29811,"user_name":"🍀  Rice","can_delete":false,"product_type":"c1","uid":1252229,"ip_address":"","ucode":"415F3886100BD2","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/85/c743120c.jpg","comment_is_top":false,"comment_ctime":1538548514,"is_pvip":false,"replies":[{"id":"10725","content":"同学，能认真看看我的文章吗？我不是讲了的嘛！后面还特意强调的！","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538581884,"ip_address":"","comment_id":29811,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10128483106","product_id":100017301,"comment_content":"为什么单链表插入删除的时间复杂度是O(1)呢？如果插入一个数在下标是K的位置，不是要先遍历获取到a(k-1)吗?","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425725,"discussion_content":"同学，能认真看看我的文章吗？我不是讲了的嘛！后面还特意强调的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538581884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1249459,"avatar":"","nickname":"mfayz","note":"","ucode":"28569DD162D1DD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":15971,"discussion_content":"双向链表的插入删除时间复杂度是O(1)，下标为k位置直接用起始地址加k偏移量，但是后面的都需要后移","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568866113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29786,"user_name":"niulixin","can_delete":false,"product_type":"c1","uid":1248873,"ip_address":"","ucode":"E61FB492DADE7B","user_header":"https://static001.geekbang.org/account/avatar/00/13/0e/69/6c085caf.jpg","comment_is_top":false,"comment_ctime":1538540464,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10128475056","product_id":100017301,"comment_content":"public static boolean isPalindrome(Node root) {<br>\t\tif (root == null) {<br>\t\t\treturn false;<br>\t\t}<br><br>\t\tNode head = root;<br>\t\tNode reserve = null;<br><br>\t\twhile (head != null) {<br>\t\t\tNode next = head.next;<br>\t\t\thead.next = reserve;<br>\t\t\treserve = head;<br>\t\t\thead = next;<br>\t\t}<br><br>\t\twhile (root != null &amp;&amp; reserve != null) {<br>\t\t\tif (root.c == reserve.c) {<br>\t\t\t\troot = root.next;<br>\t\t\t\treserve = reserve.next;<br>\t\t\t} else {<br>\t\t\t\treturn false;<br>\t\t\t}<br>\t\t}<br>\t\treturn true;<br>\t}<br>我是这样想的，先反转单链表，在while循环判断两个链表的字符是否相等","like_count":2},{"had_liked":false,"id":297003,"user_name":"PG","can_delete":false,"product_type":"c1","uid":1249747,"ip_address":"","ucode":"722E7668E5F0E5","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/d3/795d79af.jpg","comment_is_top":false,"comment_ctime":1623255011,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5918222307","product_id":100017301,"comment_content":"数组和链表 讲的真好","like_count":1},{"had_liked":false,"id":226904,"user_name":"CoderArthur","can_delete":false,"product_type":"c1","uid":1625233,"ip_address":"","ucode":"5B591914F0F67C","user_header":"https://static001.geekbang.org/account/avatar/00/18/cc/91/d56a81af.jpg","comment_is_top":false,"comment_ctime":1592227176,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5887194472","product_id":100017301,"comment_content":"（自己的）思路一：<br>链表反转，比较两个链表是否一样。<br>时间复杂度：O(n)<br>空间复杂度：O(n)<br><br><br>（评论区摘抄）思路二：<br>使用快慢两个指针找到链表中点，慢指针每次前进一步，快指针每次前进两步。在慢指针前进的过程中，同时修改其 next 指针，使得链表前半部分反序。最后比较中点两侧的链表是否相等。<br>时间复杂度：O(n)<br>空间复杂度：O(1)<br><br>缺点是改变了原有链表。<br><br>（评论区摘抄）思路三：<br>快慢指针找中点 同时前半段入栈 ， 只需要一次遍历即可完成， 时间复杂度O（n）空间复杂度O（n&#47;2）= O(n)","like_count":1},{"had_liked":false,"id":207263,"user_name":"₯㎕","can_delete":false,"product_type":"c1","uid":1080182,"ip_address":"","ucode":"6E06492D0FBA54","user_header":"https://static001.geekbang.org/account/avatar/00/10/7b/76/69aada7c.jpg","comment_is_top":false,"comment_ctime":1587039496,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5882006792","product_id":100017301,"comment_content":"数组需要提前指定大小，当空间不够时需要进行搬移数据，数据查询根据下标直接访问速度快，插入和删除需要遍历操作速度慢但是可以通过cpu预先缓存提高效率<br>链表通过地址进行访问，不需要搬移数据，插入删除速度比较快不需要搬移数据，查询比较慢需要遍历<br>链表主要有单向链表，单向循环链表，双向链表，双向循环链表<br><br>使用单项有序链表实现lru缓存淘汰算法，将经常访问的数据搬移到首部，长期不需要的就会在尾部，当链表满时将尾部的数据丢弃。<br><br>使用数组实现lru缓存淘汰算法，判断访问到的数据是否在数组中，在的话放到第一个，其他数据向后搬移，不在的话插入第一个，其他数据向后搬移，超过数组大小的元素删除掉<br>","like_count":1},{"had_liked":false,"id":200995,"user_name":"仲夏","can_delete":false,"product_type":"c1","uid":1690965,"ip_address":"","ucode":"2849869C765CDE","user_header":"https://static001.geekbang.org/account/avatar/00/19/cd/55/8c1243dc.jpg","comment_is_top":false,"comment_ctime":1585703725,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5880671021","product_id":100017301,"comment_content":"老师。链表插入和删除数据不是要先找到前驱结点吗，这个要遍历啊，时间复杂度不应该是O(n)吗","like_count":1,"discussions":[{"author":{"id":1474903,"avatar":"https://static001.geekbang.org/account/avatar/00/16/81/57/16b1c23b.jpg","nickname":"养猪专业户","note":"","ucode":"6C3130A3088376","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":235552,"discussion_content":"单纯指插入/删除这个操作，不算前面的查找访问前驱的时间。\n\n加到一起总体看的话，比如要删除第N个元素，链表是查找访问第N-1个节点费时间，删除操作非常快；数组是找到第N个节点非常快，但是删除操作费时间。\n\n但是考虑到数组要做的数据移动操作，比内存查找访问操作要费时间，所以总体来看链表的插入/删除比数组要好。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1587044406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1690965,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cd/55/8c1243dc.jpg","nickname":"仲夏","note":"","ucode":"2849869C765CDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1474903,"avatar":"https://static001.geekbang.org/account/avatar/00/16/81/57/16b1c23b.jpg","nickname":"养猪专业户","note":"","ucode":"6C3130A3088376","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288132,"discussion_content":"明白了，谢谢兄弟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593656127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":235552,"ip_address":""},"score":288132,"extra":""}]}]},{"had_liked":false,"id":192370,"user_name":"侯代烨","can_delete":false,"product_type":"c1","uid":1327868,"ip_address":"","ucode":"77C83CB1858DE7","user_header":"https://static001.geekbang.org/account/avatar/00/14/42/fc/c89243d8.jpg","comment_is_top":false,"comment_ctime":1584847884,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5879815180","product_id":100017301,"comment_content":"大厂是非常注重基础的，操作系统，编译原理，网络，算法，这四座大山一定要跨过","like_count":1,"discussions":[{"author":{"id":1132312,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/18/293cd24d.jpg","nickname":"o0oi1i","note":"","ucode":"D1F6AD4AAEAFBE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":235115,"discussion_content":"是不是还漏了个数据库","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587021226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158054,"user_name":"猫切切切切切","can_delete":false,"product_type":"c1","uid":1075033,"ip_address":"","ucode":"F350BA1B7FFDC4","user_header":"https://static001.geekbang.org/account/avatar/00/10/67/59/017b5726.jpg","comment_is_top":false,"comment_ctime":1575303809,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5870271105","product_id":100017301,"comment_content":"思路：<br>1. 先用双指针找到中间节点<br>2. 在第一指针移动过程中，将遍历节点入栈<br>3. 从中间节点开始移动，将遍历节点与栈顶节点比较<br>4. 如果相等则出栈继续，不相等则非回文，最后栈空则为回文<br><br>时间复杂度分析：<br>1 和 2 的时间复杂度为 O(n&#47;2)<br>3 和 4 的时间复杂度为 O(n&#47;2)<br>所以总的时间复杂度为 O(n)<br><br> 空间复杂度分析：<br>栈中需要存储 n&#47;2 个节点<br>所以空间复杂度为 O(n)<br>","like_count":1},{"had_liked":false,"id":157447,"user_name":"第四单元","can_delete":false,"product_type":"c1","uid":1747184,"ip_address":"","ucode":"3ED9D553E1DE17","user_header":"https://static001.geekbang.org/account/avatar/00/1a/a8/f0/529f15e9.jpg","comment_is_top":false,"comment_ctime":1575165954,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870133250","product_id":100017301,"comment_content":"笔记：<br>1.链表的存储结构。链表不需要连续的存储空间。对于每个链表中的结点，除了存储信息外还要维护一个指向下一个结点的指针。这样通过这个next指针就把所有的结点给串联起来，形成链表。链表的中的结点在内存里不需要是连续的，只在逻辑上用next指针连接。<br>2.链表中的插入和删除操作。如果给出一个链表结点在其后插入或删除一个结点的时间复杂度为O(1)。因为这种情况下的插入和删除只需要改变相关结点的next指针指向，不需要想数组那样移动元素。<br>3.随机访问链表的第n个元素。需要从头结点开始遍历直到找到第n个元素或到达尾结点，时间复杂度尾O(n)。<br>4.单链表、双向链表、循环链表、双向循环链表。单链表中每个结点只有指向下一个元素的一个next指针。双向链表还有一个指向前一个结点的指针。循环链表指最后一个结点的next指针指向头结点。双向循环链表指双向链表和循环链表的结合体。<br>5.链表 VS 数组。(1).相比于数组链表的好处是不用申请一块连续的存储空间，对空间的连续性没有要求。<br>(2).同时不需要在定义时定义一个长度，在扩容方面比较灵活。<br>(3).随机访问的时间复杂度是链表不如数组的地方。<br>(4).如果给定了一个结点要在其后插入或删除元素，链表的时间复杂度表现比数组好。<br>","like_count":1},{"had_liked":false,"id":157288,"user_name":"阴慧辉","can_delete":false,"product_type":"c1","uid":1484550,"ip_address":"","ucode":"996F003844CA22","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKzGXqIwibiaS9CHZP9Zcnia3vEenBgibvW68L1mECiaW3jGPnmBQL7zaJAocticx8VH9tROZgIuYbWibehg/132","comment_is_top":false,"comment_ctime":1575103290,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870070586","product_id":100017301,"comment_content":"用单链表判断是否是回文字符串。<br>我的基本思路是字符串折半比对，即若长度为奇数，则以中位数开始，两边的字符串若每一位都相同.若为偶数，则中位数与要开始查找比对的元素重回。<br>假设链表a的下标从0开始<br>1.遍历字符串求得其长度m。<br>2.若为奇数m=2k+1，在从第k个元素开始，向后取a(k+1)=a(k).next，再查找单链表元素a(k)的前驱a(k-1)，<br>  if a(k+1)==a(k-1) <br>     则继续先前，向后取值<br>     判断是否a(k+i)==a(k-i)<br>     直到k+i &gt;=m<br>     若所有折半后对应为字符相同，则为回文字符串。<br>3. 这个求解算法的时间复杂度为O（m）.<br>还没上机去试，但感觉是正确的。<br><br>","like_count":1},{"had_liked":false,"id":157012,"user_name":"Ronnyz","can_delete":false,"product_type":"c1","uid":1488280,"ip_address":"","ucode":"9F34527B1D343D","user_header":"https://static001.geekbang.org/account/avatar/00/16/b5/98/ffaf2aca.jpg","comment_is_top":false,"comment_ctime":1575013057,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869980353","product_id":100017301,"comment_content":"基于数组实现LRU缓存淘汰算法：<br>当有一个新的数据被访问时，从数组第一个元素开始遍历数组。<br>1.如果此元素之前已经在数组中，遍历得到这个数据对应的数组下标，将该元素与移到数组第一位。<br>2.如果此数据没有在数组中，又可以分为两种情况：<br>- 如果此时数组未满，则将所有元素后移以为，插入到数组第一位；<br>- 如果此时数组已满，则将数组最后以为元素删除，剩余元素后移一位，插入到数组第一位。<br><br>如果字符串是通过单链表来存储的，那该如何来判断是一个回文串呢？<br>使用快慢两个指针找到链表中点，慢指针每次前进一步，快指针每次前进两步。在慢指针前进的过程中，同时修改其 next 指针，使得链表前半部分反序。最后比较中点两侧的链表是否相等。","like_count":1},{"had_liked":false,"id":138070,"user_name":"Zkerhcy","can_delete":false,"product_type":"c1","uid":1231133,"ip_address":"","ucode":"43A883F6FB6070","user_header":"https://static001.geekbang.org/account/avatar/00/12/c9/1d/c7586cfc.jpg","comment_is_top":false,"comment_ctime":1570008703,"is_pvip":false,"replies":[{"id":"53770","content":"思路很活跃啊 这都能联想到😂","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1570661213,"ip_address":"","comment_id":138070,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5864975999","product_id":100017301,"comment_content":"请问Windows 和类 Unix 两大操作系统阵营的设计思路是不是也类似链表和数据的特点，Windows 开机启动后不会占据太多的内存，而像 Linux 以及 macOS 这些，开机启动应用后会首先“霸占”很多内存，不管用没用到，就像数组一样预先申请了较多的内存。再对比实际的应用程序，相同启动规模的应用程序在 Windows 内存占用好像就回比 Linux 下多一些。不知道这样类比是否合理。","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469372,"discussion_content":"思路很活跃啊 这都能联想到😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570661213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130876,"user_name":"Skrpy","can_delete":false,"product_type":"c1","uid":1524904,"ip_address":"","ucode":"BB6CB4E9AA1712","user_header":"https://static001.geekbang.org/account/avatar/00/17/44/a8/0ce75c8c.jpg","comment_is_top":false,"comment_ctime":1567563204,"is_pvip":false,"replies":[{"id":"49797","content":"ipad Paper这个软件","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1567723565,"ip_address":"","comment_id":130876,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5862530500","product_id":100017301,"comment_content":"可以问一下老师，文章里美妙的插图都是怎么做的吗","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466171,"discussion_content":"ipad Paper这个软件","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567723565,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128235,"user_name":"林林","can_delete":false,"product_type":"c1","uid":1613227,"ip_address":"","ucode":"7B6318B971E430","user_header":"https://static001.geekbang.org/account/avatar/00/18/9d/ab/6589d91a.jpg","comment_is_top":false,"comment_ctime":1566865179,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5861832475","product_id":100017301,"comment_content":"如果空间允许的话，复制单链表并反转，然后对","like_count":1},{"had_liked":false,"id":125567,"user_name":"够浪","can_delete":false,"product_type":"c1","uid":1534745,"ip_address":"","ucode":"BE2F739BA747AE","user_header":"https://static001.geekbang.org/account/avatar/00/17/6b/19/6e17efb2.jpg","comment_is_top":false,"comment_ctime":1566204720,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5861172016","product_id":100017301,"comment_content":"双向循环链表回文字符串判定代码：https:&#47;&#47;github.com&#47;AuglyXu&#47;DataStructure&#47;blob&#47;master&#47;%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2(%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8).js","like_count":1},{"had_liked":false,"id":110890,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1562383937,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5857351233","product_id":100017301,"comment_content":"<br>算法_006<br># 作业<br>1. 数组实现LRU缓存淘汰算法<br>(1) 数组未缓存该数据，所有元素后移一位(最后一个直接覆盖)，该数据为插入数组，下标为0。<br>(2) 数组已缓存该数据，该元素之前的所有元素后移一位，该数据移动至下标为0的元素。<br>时间复杂度O(n)<br><br>2. 单链表判断回文数<br>(1) 快慢两个指针，这样的策略用于寻找中点,O(n)<br>(2) 找到中点后,在比较左右两个链表是否一致O(n)<br><br># 内容<br><br>链表：指针串起来的零散内存。<br>分类：单链表、双向链表、循环链表。<br>优点：插入、删除快O(1)<br>缺点：随机访问慢O(n)<br><br>软件工程思路：空间换时间(比如Chrome)<br><br># 感受<br>数组与链表的本质区别，就是对于内存的处理方式。<br><br>与前面的不同，这次用代码实现了回文数和单链表的基础操作，还是那句话，原理都明白，代码写出来的过程中会出现一些小问题，解决这些问题的过程就是缩小想象与现实间的差距。","like_count":1},{"had_liked":false,"id":93711,"user_name":"龙","can_delete":false,"product_type":"c1","uid":1528876,"ip_address":"","ucode":"A81E6D6AD0A2A3","user_header":"https://static001.geekbang.org/account/avatar/00/17/54/2c/c4ebd3ab.jpg","comment_is_top":false,"comment_ctime":1557566271,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5852533567","product_id":100017301,"comment_content":"1.首先描述一下用单链表实现LRU的过程。<br>  假设下一次要替换的数据是data。<br>  1）不管如何，先遍历一遍单链表，直到找到data为止。O(n)<br>  2). 如果找到了：删除当前位置的节点，然后将data插入到头节点。<br>      如果没有找到，<br>          如果缓存满了，删除最后一个节点，然后将data插入到头节点。<br>          如果没有满，那么直接将data插入到头节点。<br>2.如果用数组来实现上述过程。<br>  对于上述的插入到头节点。我们可以先插入到最后，然后交换头尾节点。但是问题又来了，假设下一次数据是前一个的头，那么岂不是要遍历整个数组才能找到，但是明显人家应该排第二。<br>所以，没有想好用数组应该怎么实现。<br>3.单链表的回文串。<br>1.第一次的想法：如果是数组，那么可以用首尾指针在O(n)时间判断。所以就开辟一个数组来存遍历单链表一遍的数据。总体时间复杂度O(n),空间O(n)<br>2.然后想了一下，遍历一遍数据肯定是少不了的，那么可不可以不要空间来存。<br>那么只能在单链表上来操作。那么我又想了，如果我能找到单链表的中点，然后不就可以实现我的梦想了吗？于是就想到了之前刷题的时候用到的快慢指针。于是整个问题就迎刃而解了。时间复杂度O(n)，空间O(1)","like_count":1},{"had_liked":false,"id":81262,"user_name":"松间明月","can_delete":false,"product_type":"c1","uid":1457259,"ip_address":"","ucode":"C86ACBE74FEC1A","user_header":"https://static001.geekbang.org/account/avatar/00/16/3c/6b/27f7577d.jpg","comment_is_top":false,"comment_ctime":1553844066,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5848811362","product_id":100017301,"comment_content":"我的思路是这样的：<br>一个head指针，一个tail指针。<br>第一步，用head指针记录字符串单链表头部，并删除单链表的头部。<br>第二步，找到单链表的尾部，用tail指针记录，并删除尾部。<br>第三步，比较两个指针所指数据是否相同。不同，返回false。相同，则跳到第一步，继续比较。<br>这里的时间复杂度大致是：逐渐递减的2&#47;n次查找链表尾部操作，（(n-1)+(n-3)+(n-5)......+1)&#47;(n&#47;2),最终算得的时间复杂度也是O(n).<br>不知道我这种操作是否可行。","like_count":1,"discussions":[{"author":{"id":1681512,"avatar":"https://static001.geekbang.org/account/avatar/00/19/a8/68/70392fdd.jpg","nickname":"black","note":"","ucode":"9B5E0909926674","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":26980,"discussion_content":"一直没想起来双向链表怎么实现找到中点，谢谢哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570626397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1631655,"avatar":"https://static001.geekbang.org/account/avatar/00/18/e5/a7/bf2ca8fc.jpg","nickname":"kyle","note":"","ucode":"53F0E544933798","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5880,"discussion_content":"对于双向链表这样应当是可以的吧，但是tail 指针在删除尾部记录的时候，并不还指向尾部，而是指向未知内存区间了吧？  单链表怕是不行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566523791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75152,"user_name":"与雨日肇事的爱","can_delete":false,"product_type":"c1","uid":1288032,"ip_address":"","ucode":"A3B88A1F4AF2D5","user_header":"https://static001.geekbang.org/account/avatar/00/13/a7/60/f175d953.jpg","comment_is_top":false,"comment_ctime":1552358972,"is_pvip":false,"replies":[{"id":"27718","content":"因为要保证数据在链表中的有序性（时间有序）。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1552532558,"ip_address":"","comment_id":75152,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5847326268","product_id":100017301,"comment_content":"老师，关于Lru算法的实现思路我有一点疑问：<br> 1. 如果此数据之前已经被缓存在链表中了， 我们遍历得到这个数据对应的结点，并将其从原来的位置删 <br> 除，然后再插入到链表的头部。这里为什么要将原来的数据删除呢？我记得之前学操作系统概论的时候讲的lru页面置换算法中，如果队列中存在该数据的话没有做任何操作，没有删除。<br><br>希望老师可以帮忙解答，谢谢！<br>","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442807,"discussion_content":"因为要保证数据在链表中的有序性（时间有序）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552532558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042685,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/fd/abb7bfe3.jpg","nickname":"Langzi233","note":"","ucode":"5A21AC08FC089B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3776,"discussion_content":"保证链表从头到尾是按时间最近到最远排序的，这样如果链表满了要删除的就是最后一个节点即可，那个节点是最久没被访问的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564803231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35782,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1540798279,"is_pvip":false,"replies":[{"id":"12734","content":"题设是单链表呢","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540811669,"ip_address":"","comment_id":35782,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5835765575","product_id":100017301,"comment_content":"判断是否是回文<br>回文：level noon这样，对称的字符串<br>手机回复，所以不写代码了，就写一下思路。<br>1.创建一个双向链表存储该字符串<br>2.循环找到中间节点 长度\\2 再+1（长度为10，就访问第6个，长度为7就访问4）<br>4.定义两节点，两种情况 <br>      1.如果长度是奇数，两个节点都指向已找到的中间节点。<br>     2.如果长度是偶数，那么分别指向之前找到的节点的前一个节点。<br>5.两变量分别取上一个节点和下一个节点对比并复制给自己。直到上一个节点为空时。代表链表遍历结束。<br>6.中间任意一次数值不相等则返回false，到最后都相等则返回ture。<br>时间复杂度应该是O（n），这样处理对吗？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427666,"discussion_content":"题设是单链表呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540811669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35211,"user_name":"王","can_delete":false,"product_type":"c1","uid":1241334,"ip_address":"","ucode":"3301C496760261","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJibr1EW9cGq5zRX7V0Arn21wXldy9cPWpL7lUzyrqLeuLQgCC0icvZziaIOJ8nxWibOmuawhxevcfUNg/132","comment_is_top":false,"comment_ctime":1540461230,"is_pvip":false,"replies":[{"id":"12572","content":"小规模数据确实没啥差别","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540516067,"ip_address":"","comment_id":35211,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5835428526","product_id":100017301,"comment_content":"数组如果不通过下标查询 而是通过遍历来查询的话是否代表着除了因为CPU缓存而比链表快在未排序的情况下 时间复杂度都是O(n) ，目前一般真实开发中更多的是通过遍历未排序的数组来查询数组里数据进行判断，那给我的感觉真实开发中数组和链表查询性能没有想象中差距那么大","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427478,"discussion_content":"小规模数据确实没啥差别","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540516067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32717,"user_name":"Zherlock","can_delete":false,"product_type":"c1","uid":1248208,"ip_address":"","ucode":"02D321D434E72C","user_header":"https://static001.geekbang.org/account/avatar/00/13/0b/d0/a5eacd8c.jpg","comment_is_top":false,"comment_ctime":1539677404,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5834644700","product_id":100017301,"comment_content":"我的方案是，对于单纯的单链表<br>1。从头部遍历到尾部。<br>2。判断第一个和最后一个是否相等<br>3。删除第一个和最后一个，然后循环<br>这个方案时间复杂度，O(n×n)，空间复杂度n<br><br>或者把单链表复制到一个数组里面去，直接进行比较，时间复杂度O(n),空间复杂度2n<br><br>或者用一个循环链表，时间复杂度也能下降到O(n)","like_count":1},{"had_liked":false,"id":31707,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1539268469,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5834235765","product_id":100017301,"comment_content":"1、如何用数组实现LRU缓存淘汰策略：<br>维护一个有序的数组a，越靠近数组尾部的元素是越早访问的。<br>1）当前访问数据在缓存中，遍历数组将当前数据对应元素item前的元素后移一位，并将item放入0位置。<br>2）当前访问数据不在缓存，又分为两种情况<br>2.1）缓存未满，则将当前数组所有元素后移一位，再将当前数据对应元素放入a[0]。<br>2.2）缓存满了，先删除数组最后一个元素删除，然后把数组所有元素后移一位，最后将当前数据对应元素放入a[0]。<br><br>2、思考题：<br>方案一<br>1）遍历链表将元素放入数组A中<br>2）利用数组随机访问特性，分别从头和尾往中间遍历，并将元素进行比较，直到有元素不相等或者数组A的中点结束。<br>此方案的空间复杂度为O(n）。<br>方案二<br>1）快慢两个指针定位链表中点，同时逆序前半部分链表<br>2）已逆序的前半部分与后半部分进行比较<br>3）再次逆序前半部分链表<br>此方案的空间复杂度为O(1)。","like_count":1},{"had_liked":false,"id":30823,"user_name":"一棵开花的树","can_delete":false,"product_type":"c1","uid":1254814,"ip_address":"","ucode":"01688DC32E4F8B","user_header":"https://static001.geekbang.org/account/avatar/00/13/25/9e/69b65b6f.jpg","comment_is_top":false,"comment_ctime":1539005027,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5833972323","product_id":100017301,"comment_content":"用python写的，仅供参考！考虑奇偶，否则会报错：AttributeError: &#39;NoneType&#39; object has no attribute &#39;next&#39;<br>&#39;&#39;&#39;<br>参考：https:&#47;&#47;blog.csdn.net&#47;whm114336793&#47;article&#47;details&#47;79996943<br>&#39;&#39;&#39;<br>class Node(object):<br>    def __init__(self, data, next=None):<br>        &quot;Instantiates a Node with a default next of None.&quot;<br>        self.data = data<br>        self.next = next<br>def getLinkedList(str):<br>    head = None<br>    # Add nodes to the linked structure<br>    for item in str:<br>        # print(item)<br>        head = Node(item, head)<br>        # print(&quot;head.data:&quot;, head.data)<br>        # print(&quot;before:&quot;, head.next)<br>    return head<br><br>def isPalindrome(node, isEven):<br>    if (node == None):<br>        return True<br>    elif (node.next == None):<br>        return True<br>    else:<br>        fast = node<br>        slow = node<br>        while ((fast != None) &amp; (fast.next != None) &amp; (fast.next.next != None) &amp; (isEven == True)):<br>            fast = fast.next.next<br>            slow = slow.next<br>        while ((fast != None) &amp; (fast.next != None) &amp; (isEven == False)):<br>            fast = fast.next.next<br>            slow = slow.next<br>        if (fast != None):<br>            slow = slow.next<br>        print(&quot;slow.data:&quot;,slow.data)<br>        high = slow.next<br>        slow.next = None<br>        temp = None<br>        while (high != None):<br>            temp = high.next<br>            high.next = slow<br>            slow = high<br>            high = temp<br>        temp = node<br>        high = slow<br>        flag = True<br>        while ((temp != None) &amp; (high != None)):<br>            if (temp.data != high.data):<br>                flag = False<br>                break<br>            temp = temp.next<br>            high = high.next<br>        return flag<br><br><br>def main():<br>    if __name__ == &#39;__main__&#39;:<br>        isEven = False<br>        str = &quot;abcddcbafg&quot;<br>        length = len(str)<br>        if (length % 2) == 0:<br>            isEven = True<br>        else:<br>            isEven = False<br>        node = getLinkedList(str)<br>        print(&quot;isEven:&quot;, isEven)<br>        flag = isPalindrome(node, isEven)<br>        print(&quot;result:&quot;, flag)<br><br>main()<br>","like_count":1},{"had_liked":false,"id":30650,"user_name":"CozyThinker","can_delete":false,"product_type":"c1","uid":1041217,"ip_address":"","ucode":"996D8B8C993C5C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e3/41/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1538965476,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5833932772","product_id":100017301,"comment_content":"耗时28分钟学习完毕","like_count":1},{"had_liked":false,"id":30444,"user_name":"李皮皮皮皮皮","can_delete":false,"product_type":"c1","uid":1200281,"ip_address":"","ucode":"3BF1DEE4A12359","user_header":"https://static001.geekbang.org/account/avatar/00/12/50/99/44378317.jpg","comment_is_top":false,"comment_ctime":1538868649,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5833835945","product_id":100017301,"comment_content":"个人认为链表还是增加一个表头节点，存储一些信息，比如首节点，尾节点，长度等。这样使用起来比较方便","like_count":1},{"had_liked":false,"id":29793,"user_name":"aof","can_delete":false,"product_type":"c1","uid":1062864,"ip_address":"","ucode":"5815D63C4926BC","user_header":"https://static001.geekbang.org/account/avatar/00/10/37/d0/26975fba.jpg","comment_is_top":false,"comment_ctime":1538542897,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5833510193","product_id":100017301,"comment_content":"1，基于内存计算的Spark相比基于磁盘计算的Hadoop应该就是空间换时间吧<br>2，数组实现LRU<br>      分析了一下，数组实现LRU会造成大量数据迁移带来的耗时，而且缓存不满时，数组满了，这时数组要扩容，扩容还得考虑扩容是否能请求到足够的缓存问题，会变得很复杂......<br>3，思考题<br>     (1)遍历单链表并取出数据放入数组中<br>     (2)正向遍历数组取出每个字符并生产一个字符串s1<br>     (3)逆向遍历数组取出每个字符并生产一个字符串s2<br>     (4)判断s1的值跟s2的值是否相同，相同就是回文串，否则不是<br>      时间复杂度：n+n+n=3n推断时间复杂度为O(n)<br>      空间复杂度：多申请了一个数组的大小","like_count":1},{"had_liked":false,"id":29766,"user_name":"liangjf","can_delete":false,"product_type":"c1","uid":1058812,"ip_address":"","ucode":"681A6CCF098F55","user_header":"https://static001.geekbang.org/account/avatar/00/10/27/fc/b8d83d56.jpg","comment_is_top":false,"comment_ctime":1538534542,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5833501838","product_id":100017301,"comment_content":"习题解答方法<br>1.快慢指针。通过得到中间结点，同时从开始，尾部向中间遍历并对比，不满足则退出直到全部匹配<br><br>2.借助 栈。对比入栈前，出栈后的字符串，相同则满足条件。<br><br>3.字符串插入到数组。利用求出数组长度，利用数组下标访问特性，循环判断arr[i] == arr[L-i] ，直到不满足退出。<br><br>数组和链表各有各的优点缺点，不能一概而论，同时抛开需求业务谈性能都是耍流氓，比如在嵌入式开发时，一些芯片的栈内存资源是很紧张的，如果申请较大的局部数组会造成栈溢出，这时可以用链表替换。","like_count":1},{"had_liked":false,"id":29744,"user_name":"Mr.Panda","can_delete":false,"product_type":"c1","uid":1238864,"ip_address":"","ucode":"655A3013B5E849","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/50/d476ed6c.jpg","comment_is_top":false,"comment_ctime":1538528895,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5833496191","product_id":100017301,"comment_content":"打卡学习！","like_count":1},{"had_liked":false,"id":29724,"user_name":"大可可","can_delete":false,"product_type":"c1","uid":1186458,"ip_address":"","ucode":"BC635013E7B87E","user_header":"https://static001.geekbang.org/account/avatar/00/12/1a/9a/7b246eb1.jpg","comment_is_top":false,"comment_ctime":1538521945,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5833489241","product_id":100017301,"comment_content":"数据库的宽表是不是空间换时间","like_count":1},{"had_liked":false,"id":360834,"user_name":"Geek_a4b87f","can_delete":false,"product_type":"c1","uid":3210102,"ip_address":"山西","ucode":"0B026EF1061460","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/jv4H7MhH48JspXaXiaSVxzslEsj3XUvGVu7qibat1B40uB8ibfEb7ddlBJDUStvQdTyNbVyaeeWhDjG2siacujkhMA/132","comment_is_top":false,"comment_ctime":1666893885,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666893885","product_id":100017301,"comment_content":"头结点不应该和哨兵结点是一个意思吗","like_count":0},{"had_liked":false,"id":359102,"user_name":"Geek_821730","can_delete":false,"product_type":"c1","uid":1157237,"ip_address":"四川","ucode":"768B38D942C5CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/a8/75/3749297c.jpg","comment_is_top":false,"comment_ctime":1665238496,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665238496","product_id":100017301,"comment_content":"双向链表的尾节点也应该指向null，没有画出来","like_count":0},{"had_liked":false,"id":358264,"user_name":"111","can_delete":false,"product_type":"c1","uid":3109487,"ip_address":"北京","ucode":"D6E8E83A118A3E","user_header":"https://static001.geekbang.org/account/avatar/00/2f/72/6f/44c10658.jpg","comment_is_top":false,"comment_ctime":1664155984,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664155984","product_id":100017301,"comment_content":"1. 链表的基本组成<br>2. 链表的变种 循环 双向<br>3. 链表一种运用LRU<br>双指针，一个从中间开始，一个从开头开始，如果都相同就是回文（如果字符是奇数个，就从中间的后一个比较）","like_count":0},{"had_liked":false,"id":358086,"user_name":"Edon du","can_delete":false,"product_type":"c1","uid":1074742,"ip_address":"河南","ucode":"1648624751AAE9","user_header":"https://static001.geekbang.org/account/avatar/00/10/66/36/b4a4e6fb.jpg","comment_is_top":false,"comment_ctime":1663903717,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663903717","product_id":100017301,"comment_content":"数组简单易用，支持随机下标访问，在于其使用连续的内存，有利于cpu的缓存机制。<br>每一个cpu由多个物理核组成，每个物理核存储了私有的L1,L2缓存，这两个缓存会缓存一些高频的指令和数据（频繁使用的运行时信息），但空间一般较小，只有kb级别。多个物理核共享一个L3缓存(CPU私有缓存)，L3缓存较大，通常有几十M，通常会缓存一些要处理的数据缓存，就比如说数组，刚创建时数据的内存空间在主存中，当要处理时，cpuL3缓存会读取数组的数据，会按照cacheline进行读取，因为是连续的内存，一次会读取较多的数组元素，从而简化其数据加载到CPU缓存的时间。<br><br>链表使用在于其不需要连续的内存空间，可以利用到内存中的一些碎片空间，支持O(1)的插入，因为其内存不是连续的，cpu加载数据处理时，需要一个个的进行读取到L3缓存从而进行处理","like_count":0},{"had_liked":false,"id":357769,"user_name":"黎明的雾","can_delete":false,"product_type":"c1","uid":1548569,"ip_address":"江苏","ucode":"6BE3737F0E7067","user_header":"https://static001.geekbang.org/account/avatar/00/17/a1/19/a9d50cc0.jpg","comment_is_top":false,"comment_ctime":1663633098,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663633098","product_id":100017301,"comment_content":"一、实现LRU缓存淘汰算法的流程<br>动作：读取一个数据<br>1、数据已缓存<br>     -把已缓存数据取出放到首位<br>2、数据没有缓存<br>     -缓存空间满了<br>         去掉末尾的数据，把新数据放到首位<br>     -缓存空间未满<br>          把新数据放到首位<br><br>二、数组与链表的优缺点比较<br>     数组：内存，查看，删除，新增   ， 适用场景， cup缓存机制   ，产生内存碎边<br><br> 数组：     连续     o(1)   O(n)  O(n)     读               更适合                      无  <br> 单链表：不连续    o(n)   O(n)  O(1)    增删              不适合      额外内存消耗且不连续，更易触发GC<br><br>","like_count":0},{"had_liked":false,"id":356763,"user_name":"在路上","can_delete":false,"product_type":"c1","uid":1476245,"ip_address":"重庆","ucode":"2668A965FA79F2","user_header":"https://static001.geekbang.org/account/avatar/00/16/86/95/b9d960d9.jpg","comment_is_top":false,"comment_ctime":1662562858,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662562858","product_id":100017301,"comment_content":"数组的大小在声明数组的时候就确定了，在内存中占用一段连续的存储空间，链表由一个个节点组成，前一个节点的指针保存了后一个节点的对象引用，大小可以动态变化。因此数组可以通过索引访问到随机元素，链表需要遍历才能访问；更新则是链表更加高效","like_count":0},{"had_liked":false,"id":356379,"user_name":"Sherk","can_delete":false,"product_type":"c1","uid":2156245,"ip_address":"重庆","ucode":"AFE3E7F158258D","user_header":"https://static001.geekbang.org/account/avatar/00/20/e6/d5/4f1fc074.jpg","comment_is_top":false,"comment_ctime":1662219486,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662219486","product_id":100017301,"comment_content":"思考题：java中的字符串底层是数组，将头部指针和尾部指针一一对比，都相等就是字符串。如果是单链表，就将链表逆置，判断原链表和现在的链表是否相等，相等是回文串。空间复杂度O(n)。<br><br>这一节主要讲了链表：<br>    what:<br>         链表由一堆节点组成，节点之间通过一个指针相连。特点插入，删除方便。不能随机访问。<br><br>  和数组的区别： 由于多存储一个指针，相对更占空间，不能随机访问。但插入删除方便。<br><br>应用场景： LRU缓存。","like_count":0},{"had_liked":false,"id":355855,"user_name":"🐻","can_delete":false,"product_type":"c1","uid":1043072,"ip_address":"北京","ucode":"534EDAD496A0E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ea/80/8759e4c1.jpg","comment_is_top":false,"comment_ctime":1661786335,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661786335","product_id":100017301,"comment_content":"插入排序中可以在数组头部加上一个哨兵元素，让哨兵元素等于当前需要比较的元素。<br><br>这样在比较的时候，就可以用 current &gt; arr[0] 来防止索引溢出了。省略掉了一个判断索引是否大于0的条件。<br><br>代码见: <br><br>https:&#47;&#47;github.com&#47;bwangelme&#47;LeetCode-Go&#47;blob&#47;daa34b2e96c5b13eab4e908930688c4120085d3d&#47;algo&#47;sort&#47;insert_sort.go","like_count":0},{"had_liked":false,"id":355612,"user_name":"蒋慕平","can_delete":false,"product_type":"c1","uid":2302901,"ip_address":"重庆","ucode":"57B8FF7F00C042","user_header":"https://static001.geekbang.org/account/avatar/00/23/23/b5/639a12ec.jpg","comment_is_top":false,"comment_ctime":1661563153,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661563153","product_id":100017301,"comment_content":"1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的数据(O(n))，并将其从原来的位置数据做删除操作，然后再插入到链表的头部(O(n))。<br>2. 如果此数据没有在缓存链表中，又可以分为两种情况：<br>- 如果此时缓存未满，则将此结点直接插入到链表的头部；O(n)<br>- 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。O(n)<br>","like_count":0},{"had_liked":false,"id":355610,"user_name":"蒋慕平","can_delete":false,"product_type":"c1","uid":2302901,"ip_address":"重庆","ucode":"57B8FF7F00C042","user_header":"https://static001.geekbang.org/account/avatar/00/23/23/b5/639a12ec.jpg","comment_is_top":false,"comment_ctime":1661562687,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661562687","product_id":100017301,"comment_content":"链表特点<br>1. 不需要连续的内存<br>2. 结点、关联指针(prev,next),头结点、尾结点<br>3. 单链表、循环链表、双向链表、循环双向链表<br>- 删除操作<br>1. 删除结点中 “值等于戴个给定值”的结点 (所有链表先定位置O(n),再操作O(1))<br>2. 删除给定指针指向的结点(单向链表O(n)-不知道前驱,双向链表O(1))<br>- mysql页中数据也是单向链表，有跳表概念，“槽”，带头大哥。帮助快速找到这组第一个或最后一个<br>3. 双向链表结构多个前驱指针，方便找prev.简单空间换时间。mysql设计中许多 buffer pool,同样道理。","like_count":0},{"had_liked":false,"id":355308,"user_name":"creasylai19","can_delete":false,"product_type":"c1","uid":1128420,"ip_address":"广东","ucode":"F9B04060FCFD3F","user_header":"https://static001.geekbang.org/account/avatar/00/11/37/e4/5d7a32c6.jpg","comment_is_top":false,"comment_ctime":1661256447,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1661256447","product_id":100017301,"comment_content":"思考题也是计划用一个栈，两个指针，一个每次后移一位代表入栈的位置，一个每次后移两位，判断何时链表结束。当第二个指针判断链表结束时，每次从栈中取数据再和第一个指针数据对比。（第二个指针移不了两位，代笔链表个树为基数，第一个指针直接再走一步，然后再开始判断）","like_count":0},{"had_liked":false,"id":354600,"user_name":"樹","can_delete":false,"product_type":"c1","uid":3119609,"ip_address":"江苏","ucode":"41E789F4062EAF","user_header":"https://static001.geekbang.org/account/avatar/00/2f/99/f9/10c6d492.jpg","comment_is_top":false,"comment_ctime":1660577212,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660577212","product_id":100017301,"comment_content":"指针遍历到最后，对比第一个，如果相同，则去掉头尾节点，以此类推，最后剩余0个或者1个，则为回文。时间复杂度O(n)，空间复杂度O(1)","like_count":0},{"had_liked":false,"id":354500,"user_name":"周洁","can_delete":false,"product_type":"c1","uid":3038838,"ip_address":"广东","ucode":"C4CB796B1D7513","user_header":"https://static001.geekbang.org/account/avatar/00/2e/5e/76/f72d9ac6.jpg","comment_is_top":false,"comment_ctime":1660467255,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660467255","product_id":100017301,"comment_content":"链表(C—CPP)代码可否加上注释，这样代码方便我们学习，感谢老师课讲得好","like_count":0},{"had_liked":false,"id":354350,"user_name":"高志奇","can_delete":false,"product_type":"c1","uid":3006284,"ip_address":"上海","ucode":"AEF11F4652A2C3","user_header":"","comment_is_top":false,"comment_ctime":1660295022,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660295022","product_id":100017301,"comment_content":"一个简单的疑问：通常在开发中我们不会知道要存储多少条数据，也不会通过get(i)的方式去拿数据，而是通过迭代的方式，循环比较拿到想要的数据，但是为什么大家都用arrayList比较多呢？","like_count":0},{"had_liked":false,"id":354044,"user_name":"我们在路上","can_delete":false,"product_type":"c1","uid":1183518,"ip_address":"北京","ucode":"0DB77DB7C64C47","user_header":"https://static001.geekbang.org/account/avatar/00/12/0f/1e/6b6eb987.jpg","comment_is_top":false,"comment_ctime":1660039632,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660039632","product_id":100017301,"comment_content":"```Python<br>def balancestr(string: str) -&gt; bool:<br>    if string is None or len(string) &lt; 2:<br>        return False<br>    if len(string) == 2 and string[0] != string[1]:<br>        return False<br>    head = 0<br>    tail = len(string) - 1<br>    while head != tail and head &lt; len(string):<br>        if string[head] != string[tail]:<br>            return False<br>        head += 1<br>        tail -= 1<br>    return True<br><br><br>print(&quot;a是否回文字符串：%s&quot; % balancestr(&quot;a&quot;))<br>print(&quot;aa是否回文字符串：%s&quot; % balancestr(&quot;aa&quot;))<br>print(&quot;abba是否回文字符串：%s&quot; % balancestr(&quot;abba&quot;))<br>print(&quot;level是否回文字符串：%s&quot; % balancestr(&quot;level&quot;))<br>print(&quot;levee是否回文字符串：%s&quot; % balancestr(&quot;levee&quot;))<br>print(&quot;madam是否回文字符串：%s&quot; % balancestr(&quot;madam&quot;))<br>```","like_count":0},{"had_liked":false,"id":353624,"user_name":"iron bo","can_delete":false,"product_type":"c1","uid":2094925,"ip_address":"四川","ucode":"4BFB1331637AA3","user_header":"https://static001.geekbang.org/account/avatar/00/1f/f7/4d/09554c96.jpg","comment_is_top":false,"comment_ctime":1659613700,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659613700","product_id":100017301,"comment_content":"1.先快慢指针找到中点，以中点为分界线，后半部分翻转，然后逐个比较(注意链表长度奇偶的中点，O(n)，O(1))<br>2.使用递归遍历链表，遍历的同时使用新链表记录下来，此时与原链表的顺序正好相反，然后逐个比较(这里利用了栈帧栈的特点，O(n)，O(n))<br>3.遍历链表，遍历时使用栈保存，然后再遍历一次链表的同时弹出栈内元素，进行比较O(n)，O(n))<br>4.遍历链表，遍历时使用双向队列(比如LinkedList)保存，然后遍历依次比较(O(n)，O(n))<br>2、3、4一路一样且实现简单，1，思路与2、3、4不一样，且实现略微复杂，需要知道快慢指针找中点，翻转单链表的实现","like_count":0},{"had_liked":false,"id":352830,"user_name":"Geek_d21829","can_delete":false,"product_type":"c1","uid":2839241,"ip_address":"","ucode":"CC016B2679A1FF","user_header":"","comment_is_top":false,"comment_ctime":1658975333,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658975333","product_id":100017301,"comment_content":"每次比较链表头和尾，相同则移除头和尾，继续比较，以此类推 知道链表没有节点，或剩一个节点。","like_count":0},{"had_liked":false,"id":351539,"user_name":"Geek从不换行","can_delete":false,"product_type":"c1","uid":2228151,"ip_address":"","ucode":"FD791D375C5CEE","user_header":"","comment_is_top":false,"comment_ctime":1657876156,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657876156","product_id":100017301,"comment_content":"public static boolean isPalindrome(Node node) {<br>        Node s = node;<br>        Node f = node;<br>        Node pre = null, next= null;<br><br>        while (!(f == null || f.next == null)) {<br>            &#47;&#47; 快指针往前迭代<br>            f = f.next.next;<br>            &#47;&#47; 慢指针对前面节点进行反转<br>            next = s.next;<br>            s.next = pre;<br>            pre = s;<br>            s = next;<br>        }<br>        &#47;&#47; 当节点是奇数个，需要排除中间节点<br>        if (f != null) {<br>            s = s.next;<br>        }<br><br>        while (s != null) {<br>            if (!s.val.equals(pre.val)) {<br>                return false;<br>            }<br>            s = s.next;<br>            pre = pre.next;<br>        }<br>        return true;<br>    }","like_count":0},{"had_liked":false,"id":350614,"user_name":"mason","can_delete":false,"product_type":"c1","uid":1587652,"ip_address":"","ucode":"92ED8298143047","user_header":"https://static001.geekbang.org/account/avatar/00/18/39/c4/b59a9229.jpg","comment_is_top":false,"comment_ctime":1657039524,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657039524","product_id":100017301,"comment_content":"leetcode 146 Lru Java 实现<br><br>class LRUCache {<br>    int capacity;<br>    int size;<br>    LruNode head;<br>    LruNode tail;<br>    Map&lt;Integer ,LruNode&gt; map;<br><br>    public LRUCache(int capacity) {<br>        this.capacity=capacity;<br>        this.size=0;<br>        map=new HashMap&lt;&gt;(capacity);<br>        head=new LruNode();<br>        tail=new LruNode();<br>        head.next=tail;<br>        tail.pre=head;<br>    }<br>    <br>    public int get(int key) {<br>        LruNode node= map.get(key);<br>        if(node==null){<br>            return -1;<br>        }<br>        moveToHead(node);<br>        return node.value;<br>    }<br>    <br>    public void put(int key, int value) {<br>        LruNode node= map.get(key);<br>        if(node==null){<br>            node=new LruNode(key,value);<br>            addToHead(node);<br>            map.put(key,node);<br>            ++size;<br>            if(size&gt;capacity){<br>                LruNode tail= removeTail();<br>                map.remove(tail.key);<br>                --size;<br>            }<br>        }else{<br>            node.value=value;<br>            moveToHead(node);<br>        }<br>    }<br><br>    private void moveToHead(LruNode node){<br>        remove(node);<br>        addToHead(node);<br>    }<br><br>    private void remove(LruNode node){<br>        node.next.pre=node.pre;<br>        node.pre.next=node.next;<br><br>    }<br><br>    private void addToHead(LruNode node){<br>        node.next=head.next;<br>        node.next.pre=node;<br>        head.next=node;<br>        node.pre=head;<br>    }<br><br>    private LruNode removeTail(){<br>            LruNode pre=tail.pre;<br>            remove(pre);<br>            return pre;<br>    }<br><br>    class LruNode{<br>        int key;<br>        int value;<br>        LruNode pre;<br>        LruNode next;<br><br>        public LruNode(){<br><br>        }<br><br>        public LruNode(int key,int value){<br>            this.key=key;<br>            this.value=value;<br>        }<br>    } <br><br>}","like_count":0},{"had_liked":false,"id":349772,"user_name":"余生还要走多久","can_delete":false,"product_type":"c1","uid":1625743,"ip_address":"","ucode":"F4F53F93FB3320","user_header":"https://static001.geekbang.org/account/avatar/00/18/ce/8f/eec9f6ca.jpg","comment_is_top":false,"comment_ctime":1656319690,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1656319690","product_id":100017301,"comment_content":"function lru(leng: number) {<br>  let arr: Array&lt;any&gt; = [];<br>  return function (node) {<br>    let index = arr.findIndex((item) =&gt; item === node);<br>    &#47;&#47;1.第一种情况之前已经存在<br>    if (index &gt;= 0) {<br>      arr.splice(index, 1);<br>      arr.unshift(node);<br>      return arr;<br>    }<br>    if (index === -1 &amp;&amp; arr.length === leng) {<br>      arr.pop();<br>      arr.unshift(node);<br>    } else {<br>      arr.unshift(node);<br>    }<br>    return arr;<br>  };<br>}<br><br>let lruFn = lru(5);<br>lruFn(1);<br>lruFn(2);<br>lruFn(3);<br>lruFn(4);<br>lruFn(5);<br>console.log(lruFn(6));<br>console.log(lruFn(0));<br>console.log(lruFn(6));<br><br>&#47;**<br> * 采用链表方式类似只是调用插入到链表头结点和尾结点方法不一样而已<br> *&#47;<br>","like_count":0},{"had_liked":false,"id":349411,"user_name":"Darricklin","can_delete":false,"product_type":"c1","uid":1531572,"ip_address":"","ucode":"149C383DB03136","user_header":"https://static001.geekbang.org/account/avatar/00/17/5e/b4/2e8bcd53.jpg","comment_is_top":false,"comment_ctime":1655955919,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655955919","product_id":100017301,"comment_content":"看完了06,07两节课，练了一个链表基础操作题，才用go基本实现了LRU，继续努力。<br>type Node struct {<br>\tData int<br>\tNext *Node<br>}<br>func (s *Node) Num() int {<br>\treturn Num(s)<br>}<br>func Num(s *Node) int {<br>\tif s != nil {<br>\t\tif s.Next == nil {<br>\t\t\treturn 1<br>\t\t} else {<br>\t\t\treturn Num(s.Next) + 1<br>\t\t}<br>\t} else {<br>\t\treturn 0<br>\t}<br>}<br>func GetBackNode(head *Node,n int)*Node{<br>\tnodeCounts:=head.Num()<br>\tfor i:=1;i&lt;nodeCounts-n+1;i++{<br>\t\thead=head.Next<br>\t}<br>\treturn head<br>}<br>func GetFrontNode(head *Node,n int)*Node{<br>\tnodeCounts:=head.Num()<br>\tif n&gt;nodeCounts{<br>\t\treturn head<br>\t}<br>\tfor i:=1;i&lt;n;i++{<br>\t\thead=head.Next<br>\t}<br>\treturn head<br>}<br>func LRU(head,new *Node,mem int)*Node{<br>\tnodeCounts:=head.Num()<br>\ttmp:=head<br>\tn:=0<br>\tfor i:=1;i&lt;=nodeCounts;i++{<br>\t\tif head.Data==new.Data{<br>\t\t\tn=i<br>\t\t\tbreak<br>\t\t}else {<br>\t\t\thead=head.Next<br>\t\t}<br>\t}<br>\tfmt.Printf(&quot;n is %v\\n&quot;,n)<br>\tif n==0{<br>\t\tif nodeCounts&lt;mem{<br>\t\t\tnew.Next=tmp<br>\t\t\treturn new<br>\t\t}else{<br>\t\t\tsecondLast:=GetBackNode(tmp,2)<br>\t\t\tsecondLast.Next=nil<br>\t\t\tnew.Next=tmp<br>\t\t\treturn new<br>\t\t}<br>\t}else{<br>\t\tpre:=GetFrontNode(tmp,n-1)<br>\t\tpre.Next=pre.Next.Next<br>\t\tnew.Next=tmp<br>\t\treturn new<br>\t}<br>}","like_count":0},{"had_liked":false,"id":349219,"user_name":"跳舞的书","can_delete":false,"product_type":"c1","uid":1154021,"ip_address":"","ucode":"A724DEAD219F19","user_header":"https://static001.geekbang.org/account/avatar/00/11/9b/e5/161e10fb.jpg","comment_is_top":false,"comment_ctime":1655807549,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655807549","product_id":100017301,"comment_content":"链表的插入和删除，时间复杂度应该是O（n），因为首先要找到该结点位置，才能执行删除和插入操作。","like_count":0},{"had_liked":false,"id":348929,"user_name":"东方拓睿","can_delete":false,"product_type":"c1","uid":1605058,"ip_address":"","ucode":"1FD25D75CAC7C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/7d/c2/e6332a1b.jpg","comment_is_top":false,"comment_ctime":1655563132,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655563132","product_id":100017301,"comment_content":"老师有没有微信群或者QQ群之类的","like_count":0},{"had_liked":false,"id":348804,"user_name":"东方拓睿","can_delete":false,"product_type":"c1","uid":1605058,"ip_address":"","ucode":"1FD25D75CAC7C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/7d/c2/e6332a1b.jpg","comment_is_top":false,"comment_ctime":1655425716,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655425716","product_id":100017301,"comment_content":"申请一块数组，元素值为内存使用次数，做一次排序，总是从最小值删除","like_count":0},{"had_liked":false,"id":348403,"user_name":"叁木","can_delete":false,"product_type":"c1","uid":3017117,"ip_address":"","ucode":"B3F95E585A20D4","user_header":"https://static001.geekbang.org/account/avatar/00/2e/09/9d/f3edb929.jpg","comment_is_top":false,"comment_ctime":1655081329,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655081329","product_id":100017301,"comment_content":"双向循环链表示意图中的两个长箭头为什么都指向了data","like_count":0},{"had_liked":false,"id":346235,"user_name":"杨冬武","can_delete":false,"product_type":"c1","uid":1800054,"ip_address":"","ucode":"87D414D3F90F85","user_header":"https://static001.geekbang.org/account/avatar/00/1b/77/76/739a173e.jpg","comment_is_top":false,"comment_ctime":1652935645,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652935645","product_id":100017301,"comment_content":"请教老师一个问题，一般一个LRU缓存可以通过一个链表和一个哈希表，这种移动端进行持久化缓存一般采取什么方案啊？","like_count":0},{"had_liked":false,"id":343226,"user_name":"Tyrone","can_delete":false,"product_type":"c1","uid":2710279,"ip_address":"","ucode":"46EE691EABAAB1","user_header":"https://static001.geekbang.org/account/avatar/00/29/5b/07/6b3a8d78.jpg","comment_is_top":false,"comment_ctime":1650719024,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650719024","product_id":100017301,"comment_content":"思考题：1. 快慢指针查找中间节点。2. 转换后半部分节点链表。3. 比较。<br>python 解法（未保留原链表）：<br>def is_palindrome(head) -&gt; bool:<br>    if not head:<br>        return False<br><br>    if head.next == None:<br>        return True<br><br>    slow = reverse_node(find_middle_node(head))<br>    traverse(slow)<br>    traverse(head)<br>    while slow:<br>        if head.data != slow.data:<br>            return False<br>        slow = slow.next<br>        head = head.next<br>    return True<br><br>def find_middle_node(head):<br>    fast, slow = head, head<br>    while fast.next and fast.next.next:<br>        fast = fast.next.next<br>        slow = slow.next<br>    return slow<br><br><br>def reverse_node(head):<br>    p, rev = head, None<br><br>    while p:<br>        rev, rev.next, p = p, rev, p.next<br><br>    return rev<br><br>def traverse(node):<br>    cur = node<br>    while cur != None:<br>        print(cur.data, end=&#39;-***-&#39;)<br>        cur = cur.next<br>    print()<br><br><br>if __name__ == &#39;__main__&#39;:<br>    my_str = &quot;1012101&quot;<br>    c = Chain()<br>    for v in my_str:<br>        c.append(v)<br><br>    print(is_palindrome(c.head))","like_count":0},{"had_liked":false,"id":343011,"user_name":"泥鳅儿","can_delete":false,"product_type":"c1","uid":1323000,"ip_address":"","ucode":"26B47C8FC67615","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ojfRyNRvy1x3Mia0nssz6CNPHrHXwPPmibvds1URgoHQuKXrGiaxrEbsT6sAvuK4N4AOicySh8S9iaWcOLjteOl6Kgg/132","comment_is_top":false,"comment_ctime":1650592249,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650592249","product_id":100017301,"comment_content":"为什么说headNode.getNext()==null就是空链表呢，它本身的data如果不为空不就是还有一个节点吗","like_count":0},{"had_liked":false,"id":340619,"user_name":"冯琦","can_delete":false,"product_type":"c1","uid":1237163,"ip_address":"","ucode":"17AEE214897924","user_header":"https://static001.geekbang.org/account/avatar/00/12/e0/ab/fb5a0b66.jpg","comment_is_top":false,"comment_ctime":1648974655,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648974655","product_id":100017301,"comment_content":"#### 数组是否能实现LRU缓存呢？<br><br>1. 我们需要两个索引，一个索引标识我们的第一个数据的位置first ， 一个索引标识我们最后一个数据的位置last。不管是first还是last都是一个循环向量，这样就可以把我们的**数组当作一个环**来处理<br>2. last 表示最后一个数据的后一个位置<br>3. 在插入数据的时候和链表的也类似，需要先便利看数据是否已经在数组中存在：<br>   1. 如果存在则该元素当前位置之前的数据后移，然后该数据放到last的位置<br>   2. 如果不存在判断数据是否已满(count和数组.length的相等就是满了)<br>      * 已满：将最新的数据放在last的位置（此时last和first重合直接替换就能将最早的数据清理出缓存）。last和first位置同时后移一位<br>      * 未满：将最新的数据放在last的位置，last位置后移一位<br><br>代码我这里使用java实现不会使用到复杂的语法很容易看懂请大家指正（链接中的链表一节中的标题：#### 数组是否能实现LRU缓存呢？部分有我写的代码）：<br><br>https:&#47;&#47;github.com&#47;Alan-Jun&#47;study-note&#47;blob&#47;master&#47;note&#47;%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#47;%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95.md","like_count":0},{"had_liked":false,"id":340617,"user_name":"冯琦","can_delete":false,"product_type":"c1","uid":1237163,"ip_address":"","ucode":"17AEE214897924","user_header":"https://static001.geekbang.org/account/avatar/00/12/e0/ab/fb5a0b66.jpg","comment_is_top":false,"comment_ctime":1648974316,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648974316","product_id":100017301,"comment_content":"#### 数组是否能实现LRU缓存呢？<br>这里是我的思考<br>1. 我们需要两个索引，一个索引标识我们的第一个数据的位置first ， 一个索引标识我们最后一个数据的位置last。不管是first还是last都是一个循环向量，这样就可以把我们的**数组当作一个环**来处理<br>2. last 表示最后一个数据的后一个位置<br>3. 在插入数据的时候和链表的也类似，需要先便利看数据是否已经在数组中存在：<br>   1. 如果存在则该元素当前位置之前的数据后移，然后该数据放到last的位置<br>   2. 如果不存在判断数据是否已满(count和数组.length的相等就是满了)<br>      * 已满：将最新的数据放在last的位置（此时last和first重合直接替换就能将最早的数据清理出缓存）。last和first位置同时后移一位<br>      * 未满：将最新的数据放在last的位置，last位置后移一位<br><br>代码我这里使用java实现不会使用复杂的语法很容易看懂请大家指正：","like_count":0},{"had_liked":false,"id":338371,"user_name":"hyx","can_delete":false,"product_type":"c1","uid":2217004,"ip_address":"","ucode":"7987F771C78357","user_header":"https://static001.geekbang.org/account/avatar/00/21/d4/2c/d8f626f3.jpg","comment_is_top":false,"comment_ctime":1647441571,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647441571","product_id":100017301,"comment_content":"判断一个字符串是否为回文字符串，<br>时间复杂度：O(n^2)，空间复杂度：O(n)<br>思路：获取该字符串链表长度n， 循环比对链表的第i，及n-1-i个节点是否值相同 <br><br>以下是golang的代码：<br>1. 单向链表实现<br>```golang<br>package linked_list<br><br>import &quot;fmt&quot;<br><br>&#47;&#47; Node 单向链表节点<br>type Node struct {<br>\tData any<br>\tnext *Node<br>}<br><br>&#47;&#47; GetNext 获取下一个节点<br>func (n *Node) GetNext() *Node {<br>\treturn n.next<br>}<br><br>&#47;&#47; SetNext 设置下一个节点<br>func (n *Node) SetNext(nextNode *Node) {<br>\tn.next = nextNode<br>}<br><br>&#47;&#47; SinglyLinkedList 单向链表<br>type SinglyLinkedList struct {<br>\tfirstNode *Node<br>}<br><br>&#47;&#47; Append 单向链表末尾增加一个节点<br>func (l *SinglyLinkedList) Append(n *Node) {<br>\tif l.firstNode == nil {<br>\t\tl.firstNode = n<br>\t\treturn<br>\t}<br>\tnodeNow := l.firstNode<br>\tfor {<br>\t\tnext := nodeNow.GetNext()<br>\t\tif next != nil {<br>\t\t\tnodeNow = next<br>\t\t\tcontinue<br>\t\t}<br>\t\tnodeNow.SetNext(n)<br>\t\tbreak<br>\t}<br>}<br><br>&#47;&#47; GetNthNode 获取单向链表的第N个节点(节点计数从0开始到len-1)<br>func (l *SinglyLinkedList) GetNthNode(n int) (*Node, error) {<br>\tnode := l.firstNode<br>\tfor i := 0; i &lt; n; i++ {<br>\t\tnode = node.GetNext()<br>\t\tif node == nil {<br>\t\t\treturn nil, fmt.Errorf(&quot;第%v个节点为链表的最后一个节点，请求节点%v，超出链表范围&quot;, i, n)<br>\t\t}<br>\t}<br>\treturn node, nil<br>}<br><br>&#47;&#47; Len 获取链表长度<br>func (l *SinglyLinkedList) Len() int {<br>\tnode := l.firstNode<br>\tfor i := 1; true; i++ {<br>\t\tnode = node.GetNext()<br>\t\tif node == nil {<br>\t\t\treturn i<br>\t\t}<br>\t}<br>\treturn -1<br>}<br><br>&#47;&#47; InitSinglyLinkedList 将一个array初始化为一个单向链表<br>func InitSinglyLinkedList[T any](data []T) *SinglyLinkedList {<br>\tl := SinglyLinkedList{}<br>\tfor _, v := range data {<br>\t\tnode := Node{<br>\t\t\tData: v,<br>\t\t}<br>\t\tl.Append(&amp;node)<br>\t}<br>\treturn &amp;l<br>}<br>```<br><br>2. 测试回文字符串检测<br>```golang<br><br>func CheckPalindrome(s []string) (bool, error) {<br>\tl := InitSinglyLinkedList[string](s)<br>\tn := l.Len()<br>\tfor i := 0; i &lt;= n-1-i; i++ {<br>\t\tchar1, err := l.GetNthNode(i)<br>\t\tif err != nil {<br>\t\t\treturn false, err<br>\t\t}<br>\t\tchar2, err := l.GetNthNode(n - 1 - i)<br>\t\tif err != nil {<br>\t\t\treturn false, err<br>\t\t}<br>\t\tif char1.Data != char2.Data {<br>\t\t\treturn false, nil<br>\t\t}<br>\t}<br>\treturn true, nil<br>}<br>```","like_count":0},{"had_liked":false,"id":337335,"user_name":"H.H","can_delete":false,"product_type":"c1","uid":2668479,"ip_address":"","ucode":"3C0BB1E2A3EC51","user_header":"https://static001.geekbang.org/account/avatar/00/28/b7/bf/815f0ec6.jpg","comment_is_top":false,"comment_ctime":1646758684,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646758684","product_id":100017301,"comment_content":"我想的，我手画的和我写的代码要经过一段艰难的沟通才能表现一致...","like_count":0},{"had_liked":false,"id":336499,"user_name":"谭雪娇","can_delete":false,"product_type":"c1","uid":1375252,"ip_address":"","ucode":"B20AB23E0D20E0","user_header":"https://static001.geekbang.org/account/avatar/00/14/fc/14/b6b50f91.jpg","comment_is_top":false,"comment_ctime":1646190897,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646190897","product_id":100017301,"comment_content":"一开始不明白，慢指针走（同时修改next指向）到到链表中点，然后比较前后两段，就可以判断是否为回文了，那么快指针好像没啥用呀（恕我小白），后来突然想起来，利用快指针每次都比慢指针快一步，等快指针的next为null时，说明慢指针到了中点，所以说快指针的作用是为了帮慢指针找中点的，我的理解是对的吗？","like_count":0},{"had_liked":false,"id":335977,"user_name":"Today","can_delete":false,"product_type":"c1","uid":1235000,"ip_address":"","ucode":"4FA397F0BD8C6E","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/38/41027bda.jpg","comment_is_top":false,"comment_ctime":1645801026,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645801026","product_id":100017301,"comment_content":"数组和链表的特性：<br>1. 数组最典型的特性是具有连续的内存空间， 删除或插入元素， 由于会搬移数据会影响性能, 效率 O(n); 优点是访问效率较高 O(1)<br>2. 链表最典型的特征是内存空间不连续， 可以通过指针串联内存块，访问效率不高 O(n)（但可以配合其它哈希表结构进行加强）， 移动， 删除和插入元素效率高 O(1)。<br><br>做下课后的思考题，挫败感还是挺重的，加强练习把！<br>【回文链表判断题】https:&#47;&#47;leetcode-cn.com&#47;problems&#47;palindrome-linked-list&#47;<br>空间复杂度 O(n)的方法：把链表反向复制一份保存， 再逐一进行比较<br><br>空间复杂度 O(1) 的方法：<br>1. 利用快慢指针快速找到中间结点位置 （一开始想通过数组索引除2的惯性思维去找中点， 并没有考虑到链表不具备高效索引访问的特性）<br>2. 使用翻转链表的模板进行后半段链表翻转 （一开始想的是前半段翻转， 其实也可以， 没写出来）<br>3. 判断回文<br>4. 恢复链表， 返回结果<br>【LRU缓存题】https:&#47;&#47;leetcode-cn.com&#47;problems&#47;lru-cache&#47;<br>时间复杂度 O(1): <br>1. 用双向链表按 key-value 存储<br>2. 用HashMap&lt;key, Node&gt; 存储 key 和 链表节点<br>3. key的访问有三种情况：<br>修改：把原节点更新值后新增到头节点<br>新增：缓存已满，移除末尾节点， 创建新节点添加到头部； 未满则直接添加，map 同步更新<br>获取：存在节点，返回值并移动到头部；否则返回找不到","like_count":0},{"had_liked":false,"id":335738,"user_name":"所谓伊人","can_delete":false,"product_type":"c1","uid":1509095,"ip_address":"","ucode":"71D52303A68210","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/e7/3cd572c6.jpg","comment_is_top":false,"comment_ctime":1645669589,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1645669589","product_id":100017301,"comment_content":" newNode.next = q.next;<br> q.next = newNode;<br>请问一下单链表的尾插法为什么要有 newNode.next = q.next;？直接 q.next = newNode;不久让最后一个节点指向新节点了吗？","like_count":0},{"had_liked":false,"id":335616,"user_name":"所谓伊人","can_delete":false,"product_type":"c1","uid":1509095,"ip_address":"","ucode":"71D52303A68210","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/e7/3cd572c6.jpg","comment_is_top":false,"comment_ctime":1645604917,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1645604917","product_id":100017301,"comment_content":"作者你好，这个有交流群没有？有些资料代码有些疑惑也没人交流。lru的数组实现的代码为什么要有一个map？也就在访问的时候查询了一下map里面是否有这个数据，但数组不也可以查询吗？","like_count":0},{"had_liked":false,"id":335414,"user_name":"小苗晓雪","can_delete":false,"product_type":"c1","uid":1334583,"ip_address":"","ucode":"B15FDF455853D2","user_header":"https://static001.geekbang.org/account/avatar/00/14/5d/37/061e7fac.jpg","comment_is_top":false,"comment_ctime":1645512124,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1645512124","product_id":100017301,"comment_content":"我第一时间想到的还是用数组 , 把字符串的每一个字符放入数组中,  然后循环比较 array[ i ] 与 array[ array.count - 1 - i ] 的值 , 如果相等就是回文 , 如果不是就跳出循环 , 就不是回文串~可能不够严谨~<br>","like_count":0},{"had_liked":false,"id":334726,"user_name":"Geek_bd4376","can_delete":false,"product_type":"c1","uid":2910297,"ip_address":"","ucode":"7C30E7538E281D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIxEuD0ytJhQUFGXxtric0OxtpFx95GYmkB9RMJXFsgH0eWKiayzTg91v3GpCHyRTc5outbwe5WBtng/132","comment_is_top":false,"comment_ctime":1645091609,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645091609","product_id":100017301,"comment_content":"这是一个神奇的网站","like_count":0},{"had_liked":false,"id":334412,"user_name":"独孤九剑","can_delete":false,"product_type":"c1","uid":2912555,"ip_address":"","ucode":"478E97D012AD66","user_header":"https://static001.geekbang.org/account/avatar/00/2c/71/2b/7d636be0.jpg","comment_is_top":false,"comment_ctime":1644925134,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644925134","product_id":100017301,"comment_content":"LRU链表实现，有代码吗？高级语言都支持数组，但是，没看到有链表这种类型，需要手动定义链表类型吗，感谢","like_count":0},{"had_liked":false,"id":332266,"user_name":"cw","can_delete":false,"product_type":"c1","uid":1264296,"ip_address":"","ucode":"82A6B50462F9F9","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/a8/b7e36dd2.jpg","comment_is_top":false,"comment_ctime":1643129430,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643129430","product_id":100017301,"comment_content":" &#47;**<br>     * 单向链表 判断数组是否是回文子串<br>     * 不能额外空间<br>     * 思路:中间翻转<br>     * @param head<br>     *&#47;<br>    public void test06(Node head) {<br>        Node fast = head;<br>        Node slow = head;<br>        Node curr = head;<br>        Node prev = null;<br>        while (fast != null &amp;&amp; fast.next != null) {<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        }<br>        if (fast != null) {<br>            &#47;&#47;偶数<br>            fast = slow.next;<br>            &#47;&#47;revert slow;<br><br>            while (curr != slow) {<br>                Node temp = curr.next;<br>                curr.next = prev;<br>                prev = curr;<br>                curr = temp;<br>            }<br>        } else {<br>            &#47;&#47;奇数<br>            fast = slow.next;<br>            &#47;&#47;revert slow;<br>            while (curr != slow) {<br>                Node temp = curr.next;<br>                curr.next = prev;<br>                prev = curr;<br>                curr = temp;<br>            }<br>            slow = slow.next;<br><br>        }<br>        while (slow != null) {<br>            if (slow != fast) {<br>                System.out.println(Boolean.FALSE);<br>            }<br>            slow = slow.next;<br>            fast = fast.next;<br>        }<br>    }","like_count":0},{"had_liked":false,"id":330677,"user_name":"路远","can_delete":false,"product_type":"c1","uid":2890949,"ip_address":"","ucode":"46DCE2D12D38C4","user_header":"https://static001.geekbang.org/account/avatar/00/2c/1c/c5/3df9fa5e.jpg","comment_is_top":false,"comment_ctime":1642115196,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642115196","product_id":100017301,"comment_content":"满满的干货，笔记比内容还多，是我太菜亦是内容太好。","like_count":0},{"had_liked":false,"id":326508,"user_name":"petit_kayak","can_delete":false,"product_type":"c1","uid":1025214,"ip_address":"","ucode":"6889CCCBFA0180","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/be/39cc22f5.jpg","comment_is_top":false,"comment_ctime":1639547401,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1639547401","product_id":100017301,"comment_content":"有个问题，对于链表删除指定位置数据的时间复杂度，删除首先需要找到该位置吧，寻找位置的时间复杂度已经是O(n)了，那删除操作总的时间复杂度应该也是O(n)吧，同样的道理，指定位置插入应该也是O(n)？","like_count":0},{"had_liked":false,"id":326453,"user_name":"今年也没有猫","can_delete":false,"product_type":"c1","uid":1546547,"ip_address":"","ucode":"99379F3E276746","user_header":"https://static001.geekbang.org/account/avatar/00/17/99/33/1981b0cc.jpg","comment_is_top":false,"comment_ctime":1639532638,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639532638","product_id":100017301,"comment_content":"有个疑惑 不知道对错：<br>进程申请的内存是虚拟内存，虚拟内存通过页表对应的不一定是连续的物理内存，  这里说的  数组是连续的内存，  是指 数组是连续的（已经映射物理内存）虚拟内存。  这样理解是否正确。","like_count":0},{"had_liked":false,"id":326073,"user_name":"","can_delete":false,"product_type":"c1","uid":1248994,"ip_address":"","ucode":"F77B453D15A848","user_header":"https://static001.geekbang.org/account/avatar/00/13/0e/e2/86e4c7ca.jpg","comment_is_top":false,"comment_ctime":1639363340,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1639363340","product_id":100017301,"comment_content":"作业，没有用快慢指针的思路，单纯的拿到反转链表后对比，时间复杂度O(n)，空间复杂度又创建了一个单链表因此是O(n)<br>type LISTNODE = ListNode | null<br><br>class ListNode {<br>  data: string<br>  next: LISTNODE<br>  constructor(data: string) {<br>    this.data = data<br>    this.next = null<br>  }<br>}<br><br>class LinkedList {<br>  _head: LISTNODE<br>  constructor(head: LISTNODE) {<br>    this._head = head<br>  }<br><br>  size() {<br>    let count = 0<br>    let node = this._head<br>    while (node) {<br>      count++<br>      if (this._head) {<br>        node = this._head.next<br>      }<br>    }<br>    return count<br>  }<br><br>  clear() {<br>    this._head = null<br>  }<br><br>  getList() {<br>    let lastNode = this._head<br>    if (lastNode) {<br>      while (lastNode.next) {<br>        lastNode = lastNode.next<br>      }<br>    }<br>    return lastNode<br>  }<br><br>  getFirst() {<br>    return this._head<br>  }<br>}<br><br>let node1 = new ListNode(&#39;n&#39;)<br>let node2 = new ListNode(&#39;s&#39;)<br>let node3 = new ListNode(&#39;x&#39;)<br>let node4 = new ListNode(&#39;n&#39;)<br><br>node1.next = node2<br>node2.next = node3<br>node3.next = node4<br><br>let list = new LinkedList(node1)<br><br>&#47;**<br> * @param head:LISTNODE<br> * @return prev:LISTNODE<br> * 反转链表<br> * *&#47;<br>const reverseList = (head: LISTNODE) =&gt; {<br>  let prev: LISTNODE = null<br>  let cur: LISTNODE = head<br>  while (cur !== null) {<br>    let next: LISTNODE = cur.next<br>    cur.next = prev<br>    prev = cur<br>    cur = next<br>  }<br>  return prev<br>}<br><br>&#47;**<br> * 判断给定的链表是否为回文<br> * @return boolean<br> * *&#47;<br>const isRe = () =&gt; {<br>  let listNode = list.getFirst()<br>  let lastNode = reverseList(listNode)<br>  let result = false<br>  while (lastNode &amp;&amp; listNode) {<br>    if (listNode.data === lastNode.data) {<br>      result = true<br>    } else {<br>      result = false<br>      break<br>    }<br>    lastNode = lastNode.next<br>    listNode = listNode.next<br>  }<br>  return result<br>}<br><br><br>","like_count":0},{"had_liked":false,"id":324666,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1638532120,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1638532120","product_id":100017301,"comment_content":"评论跟专栏一样精彩，本来我觉得可以用数组，但是没有办法确定数量，看了快慢指针突然眼前一亮，还能这么做。","like_count":0},{"had_liked":false,"id":324568,"user_name":"任锋","can_delete":false,"product_type":"c1","uid":1086592,"ip_address":"","ucode":"8C32C85A61C426","user_header":"https://static001.geekbang.org/account/avatar/00/10/94/80/70e483f6.jpg","comment_is_top":false,"comment_ctime":1638502596,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638502596","product_id":100017301,"comment_content":"双向链表的我指来指去，又迷糊了有没有大佬解释一下？<br>比如 a节点 有pre和next两个指针，b节点也有两个指针，但是要再 a, b节点之间插入一个x节点<br>我只知道：<br>假设指针p指向a节点则：<br>x-&gt;next = p-&gt;next;<br>p-&gt;next = x-&gt;pre;<br>x-&gt;pre = p-&gt;next;<br>但是b的pre指针也要指向x的next指针啊？<br>首先第一个就是不知道我写的对不对，第二就是b的这个pre如何指向x的next呢？<br>","like_count":0},{"had_liked":false,"id":324027,"user_name":"Guit","can_delete":false,"product_type":"c1","uid":2115605,"ip_address":"","ucode":"70012D16C9117D","user_header":"https://static001.geekbang.org/account/avatar/00/20/48/15/63cc2633.jpg","comment_is_top":false,"comment_ctime":1638262680,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638262680","product_id":100017301,"comment_content":"  基于老师仓库 06_linkedlist的代码 写了一下链表翻转 望大佬指点(JavaScript版)<br>  class LinkedList{<br>    ...<br>    Flip() {<br>      let currentNode = this.head.next<br>      while (currentNode.next !== null) {<br>        currentNode = currentNode.next<br>      }<br>      this.head = this._Flip(currentNode)<br>    }<br>    _Flip(currentNode) {<br>      let Prev = this.findPrev(currentNode.element)<br>      Prev !== -1 ? currentNode.next = this._Flip(Prev) : currentNode.next = null<br>      return currentNode<br>    }<br>  }","like_count":0},{"had_liked":false,"id":322986,"user_name":"Tina","can_delete":false,"product_type":"c1","uid":2851354,"ip_address":"","ucode":"8D6D9F6E3D0A99","user_header":"https://static001.geekbang.org/account/avatar/00/2b/82/1a/30676c2e.jpg","comment_is_top":false,"comment_ctime":1637679487,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637679487","product_id":100017301,"comment_content":"链表也是一种线性结构，与数组最明显的区别就是，数组是连续存储的，需要申请一块连续的内存空间，而链表不需要连续，靠每个节点中的next指向下一个节点，从而会比数组占用更大的内存空间。<br><br>数组的连续性导致数组查找快，很容易实现通过下标进行随机访问，时间复杂度为O(1)，而增删慢，要移动很多元素，时间复杂度为O(n)，而链表增删只需要改变指针的指向，时间复杂度为O(1)，而查找需要从头节点开始一个个往后找，时间复杂度为O(n)。<br><br>还有就是缓存，数组是连续的内存空间，可以事先将数据加载到内存中，从而加快访问速度，而链表不是连续存储，不能预读。<br>数组的缺点是大小固定，开始最好还要指定好内存空间，不够要进行动态扩容，非常费时。而链表没有大小限制，自然的实现动态扩容。<br><br>以上表示的是单链表，还有循环链表和双向链表。循环链表，顾名思义，便是将将链表连成一个环，最后一个节点的next不是null，而是指向头节点，适合环形的问题，例如约瑟夫问题。查找的时间复杂度为O(n)，增删的时间复杂度为O(1)。<br>双向链表不仅有next指针指向下一个节点，还有prev指针指向前一个节点。头节点的prev指向尾节点，尾节点的next指向头节点，因为有prev，双向链表的查找的时间复杂度为O(n)，但如果找前驱节点的话就是O(1)，前两种链表都是O(n)，增删是O(1)，更高效同时也要花费更多的内存空间来储存前后指针。<br><br>对于删除操作，如果是删除指定的节点，单链表和双向链表都需要遍历查找，时间复杂度为O(n)，单纯删除是O(1)，但是查找过程是O(n)，加法法则得出最终是O(n)，而已经找到要删除的节点，双向链表可以直接得到前驱节点和后继节点，时间复杂度为O(1)，单项链表还要遍历找到前面的节点，时间复杂度为O(n)。<br><br>如果是有序链表，双向链表还可以记录上一次查找的位置，下次查找时直接与记录的进行比较，然后就可以省下差不多一半的数据遍历时间。<br><br>如果内存空间充足，更追求速度的话，可以用空间换时间，选择空间复杂度较高，而时间复杂度较低的算法或数据结构，相反，如果内存紧缺，要进行用时间换空间。<br><br>LRU（Least Recently Used）算法，最近最少使用，也就是当有一个新的数据时，如果本来链表中没有这个数据，且缓存未满，则直接插入到头部，如果缓存满了，就要将链表尾部的节点删除，将新节点插入到头部；如果链表中本来就有这个节点，则将其从原来的位置删除，然后插入到链表头部。时间复杂度为O(n)。<br><br>判断一个字符串是否是回文字符串，用快慢指针，快的一次走两个，慢的一次走一个并反转，当走到中间时，slow继续往后走，prev往前走，进行比较。","like_count":0},{"had_liked":false,"id":321834,"user_name":"啊良梓是我","can_delete":false,"product_type":"c1","uid":1655117,"ip_address":"","ucode":"E42FC1A60D331C","user_header":"https://static001.geekbang.org/account/avatar/00/19/41/4d/f6d6d13a.jpg","comment_is_top":false,"comment_ctime":1637056131,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1637056131","product_id":100017301,"comment_content":"LRU 我手写过，就是双端链表+HashMap 实现的， 之前在LeetCode里面的一个中等难度题 哈哈哈","like_count":0},{"had_liked":false,"id":321406,"user_name":"Geek_ebfa80","can_delete":false,"product_type":"c1","uid":2750033,"ip_address":"","ucode":"37F90E04D7C619","user_header":"","comment_is_top":false,"comment_ctime":1636856877,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636856877","product_id":100017301,"comment_content":"强烈建议代码国内网站也放下，github要么访问不了要么打开特别慢","like_count":0},{"had_liked":false,"id":320696,"user_name":"凉人。","can_delete":false,"product_type":"c1","uid":1659177,"ip_address":"","ucode":"4DB16004A62015","user_header":"https://static001.geekbang.org/account/avatar/00/19/51/29/24739c58.jpg","comment_is_top":false,"comment_ctime":1636457995,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636457995","product_id":100017301,"comment_content":"将单链表的数据取出来存到 数组里 ，利用数组随机访问比较第一个和最后一个 第二个和倒数第二个","like_count":0},{"had_liked":false,"id":319159,"user_name":"Ace","can_delete":false,"product_type":"c1","uid":2826595,"ip_address":"","ucode":"B6491A50F8C3A8","user_header":"https://static001.geekbang.org/account/avatar/00/2b/21/63/bfd4ad3a.jpg","comment_is_top":false,"comment_ctime":1635647199,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635647199","product_id":100017301,"comment_content":"删除给定指针指向的节点，这个是说只知道给定指针，但是不知道这个给定指针所在的节点吗？","like_count":0},{"had_liked":false,"id":317275,"user_name":"善护念","can_delete":false,"product_type":"c1","uid":2817756,"ip_address":"","ucode":"2F4F12FEA270C9","user_header":"https://static001.geekbang.org/account/avatar/00/2a/fe/dc/564c7f3e.jpg","comment_is_top":false,"comment_ctime":1634730069,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634730069","product_id":100017301,"comment_content":"概述<br><br>记录一下LRU缓存淘汰算法的实现。<br><br>原理<br><br>LRU（Least recently used，最近最少使用）缓存算法根据数据最近被访问的情况来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。<br><br>介绍<br><br>下图中，介绍了一个缓存空间为5的缓存队列，当访问数据的顺序是:1,2,3,4,5,6,7,6,4,0时空间中数据的变化过程。 <br>这里写图片描述<br>可以发现: <br>1. 当缓存空间未满时，数据一直往新的空间写；<br>2. 当缓存满，并且缓存中没有需要访问的数据时，最先进入缓存的数据被淘汰掉； <br>3. 当缓存满，并且缓存中有需要访问的数据时，做了一个数据交换，把访问的数据拿出来，其余数据往下压，最后把访问的数据放到顶部 <br>在这里，可能有疑问，就是把“数据交换”于“数据完全新增和删除”有什么区别呢？答案是性能，前者是移动指针，后者是更新整个内存空间，后者所花费的系统开销远比前者大得多。","like_count":0},{"had_liked":false,"id":315384,"user_name":"付伟","can_delete":false,"product_type":"c1","uid":1397649,"ip_address":"","ucode":"97DC8054E30D97","user_header":"https://static001.geekbang.org/account/avatar/00/15/53/91/5a160371.jpg","comment_is_top":false,"comment_ctime":1633872617,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633872617","product_id":100017301,"comment_content":"快指针和慢指针，这两个东西先前实际应用中还没用到过，这次发现原来还有这个东西，不过想想有这个东西也正常，哈哈。。","like_count":0},{"had_liked":false,"id":314385,"user_name":"倔强","can_delete":false,"product_type":"c1","uid":2792413,"ip_address":"","ucode":"4C588A1E7C0F7C","user_header":"https://static001.geekbang.org/account/avatar/00/2a/9b/dd/97a690a2.jpg","comment_is_top":false,"comment_ctime":1632992922,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632992922","product_id":100017301,"comment_content":"思考题：<br>（我是一个小萌新，刚接触数据结构与算法，只是刚刚听完，有了一个小想法想说一说）<br>本文中正好讲了双向链表，我认为可以用双向链表来判断是否为回文串，应该可以两边同时开始一边从头开始，一边从尾开始，判断语句可以写成p-&gt;next=q和p-&gt;next=q-&gt;prior(p是从头一个个向后，q是从尾一个个向前，然后之所以是两个是因为有奇偶之分。)<br><br><br>萌新第一次大胆发言，因为看了那么久，总算看到一个有自己思路的了。","like_count":0},{"had_liked":false,"id":314213,"user_name":"俯瞰风景.","can_delete":false,"product_type":"c1","uid":1044166,"ip_address":"","ucode":"A6DB68B7B84AEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/c6/bebcbcf0.jpg","comment_is_top":false,"comment_ctime":1632902515,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632902515","product_id":100017301,"comment_content":"数组直接了利用物理空间的连续性来排布数据，不需要指针来记录数据节点之间的前后关系，由于对空间连续性有要求，所以会遇到无法分配合适存储空间的情况。由于CPU的预读，所以数据对CPU缓存友好。<br>  已知数组的下标，访问数组元素的时间复杂度为O(1)。<br>  通过值查找数组元素的话，有序数组查找时间复杂度为O(logn)，无序数组查找时间复杂度为O(n)。<br><br>链表利用指针来连接前后两个数据节点，对物理空间的连续性不做要求，所以天然具备动态扩容的特性。<br>  对链表上的节点进行插入和删除操作，需要知道操作位置前后的两个节点。<br>  已知链表前后两个节点的前提下，对链表进行插入和删除操作，时间复杂度为O(1)。","like_count":0},{"had_liked":false,"id":313245,"user_name":"恬毅","can_delete":false,"product_type":"c1","uid":1015240,"ip_address":"","ucode":"914ED16F3BE714","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/c8/e4727683.jpg","comment_is_top":false,"comment_ctime":1632323075,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632323075","product_id":100017301,"comment_content":"如何判断一个字符串是否是回文字符串的问题<br>方法一，快慢指针，然后中间往后做逆序，然后开始和中间开始做对比，完了以后要再次逆序回来<br>方法二，用栈，压栈，然后做对比<br>方法三，快慢指针，然后从中间开始压栈，然后弹出比较，这样省一半空间","like_count":0},{"had_liked":false,"id":312976,"user_name":"lyt","can_delete":false,"product_type":"c1","uid":1526706,"ip_address":"","ucode":"8C179F339C2A27","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/OwolYO3ppfrxTcX81cswxNkD4tIlHM7vrnfroMzoTx878mDCnfJ3esicvbhm7ricUAbR7T9DjEDstVklh9z6uzjQ/132","comment_is_top":false,"comment_ctime":1632177002,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632177002","product_id":100017301,"comment_content":"1.快慢指针都从头结点开始，快指针每次向后两步，慢指针每次向后一步，并用left记录前半段反序2.当快指针为空，慢指针指向中间结点（链表长度为奇数）或前半段末尾的结点（长度为偶）3.慢指针继续遍历链表后半段，并和left比较","like_count":0},{"had_liked":false,"id":308807,"user_name":"Nicer","can_delete":false,"product_type":"c1","uid":2725703,"ip_address":"","ucode":"75E5DAB1A5CE8A","user_header":"https://static001.geekbang.org/account/avatar/00/29/97/47/9bc9b07d.jpg","comment_is_top":false,"comment_ctime":1629806073,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629806073","product_id":100017301,"comment_content":"1.数组和链表都是线性表结构；<br>2.数组是一段连续的内存空间，链表可以不用；<br>3.数组查询快，时间复杂度为O(1)，增删慢，时间复杂度为O(n)，链表相反，因为2的特性；<br>4.链表需要多一倍空间存地址，空间换时间；<br>5.数组对CPU缓存友好，因为CPU加载内存时是加载一段数据块，数组只需存首地址即可拿到整段数据，而不是去存所有结点的地址，如链表，所以链表对CPU缓存不友好；<br>6.判断是否回文字符串算法和LRU缓存淘汰算法。","like_count":0},{"had_liked":false,"id":308494,"user_name":"晚风。","can_delete":false,"product_type":"c1","uid":2066225,"ip_address":"","ucode":"19E54449690823","user_header":"","comment_is_top":false,"comment_ctime":1629643808,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629643808","product_id":100017301,"comment_content":"链表实现lru：缓存时间越久放的越靠后，遍历链表，若存在缓存则移动到链表头，若没有缓存直接插入点链表头，若链表已满删除链表尾部节点，执行插入","like_count":0},{"had_liked":false,"id":307554,"user_name":"Martin","can_delete":false,"product_type":"c1","uid":1760944,"ip_address":"","ucode":"F5F0BFF3821F94","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM71l44qhodDo6gXyQ3lib8tg5yUjBLBmaqGEV4ybMic90uUFKQkticrUOP3qtsJbcBY5zczoInE9gErw/132","comment_is_top":false,"comment_ctime":1629159121,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629159121","product_id":100017301,"comment_content":"思考题，每次都比较头尾两个元素值，相等则去头尾继续比较头尾。","like_count":0},{"had_liked":false,"id":307549,"user_name":"李叶","can_delete":false,"product_type":"c1","uid":1470449,"ip_address":"","ucode":"41B33FA8526E48","user_header":"https://static001.geekbang.org/account/avatar/00/16/6f/f1/35f9f16f.jpg","comment_is_top":false,"comment_ctime":1629157894,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629157894","product_id":100017301,"comment_content":"链表占用内存空间大，可以不连续，查询的时间复杂度是O(n)，插入删除复杂度O(1)；数据需要连续的内存空间，并且支持cpu缓存，时间复杂度相反，基本数据类型只能使用数组存储。","like_count":0},{"had_liked":false,"id":307503,"user_name":"雾深","can_delete":false,"product_type":"c1","uid":2672980,"ip_address":"","ucode":"947C77DEBEAF4C","user_header":"https://static001.geekbang.org/account/avatar/00/28/c9/54/c68ea92f.jpg","comment_is_top":false,"comment_ctime":1629126564,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629126564","product_id":100017301,"comment_content":"判断是否为回文串：<br>1. 将字符串以单个字符的形式存储在单链表中。<br>2. 将链表长度 &#47; 2 （取整），并存入新链表中。<br>3. 同时倒序遍历两个链表并判断节点元素是否相等，遍历的次数为截取的链表长度。<br>4. 遍历结束时全部都相等则为回文串。","like_count":0},{"had_liked":false,"id":304343,"user_name":"Geek_26c95d","can_delete":false,"product_type":"c1","uid":1466617,"ip_address":"","ucode":"AA1F4E9548439F","user_header":"https://static001.geekbang.org/account/avatar/00/16/60/f9/0417a5dc.jpg","comment_is_top":false,"comment_ctime":1627361278,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1627361278","product_id":100017301,"comment_content":"回文字符串判断：直接把单链表倒叙排列和原字符串比较是否相等。时间复杂度O(n)","like_count":0},{"had_liked":false,"id":303733,"user_name":"1979104101ng","can_delete":false,"product_type":"c1","uid":2138770,"ip_address":"","ucode":"95204E6CBA81D6","user_header":"https://static001.geekbang.org/account/avatar/00/20/a2/92/6bbcb80b.jpg","comment_is_top":false,"comment_ctime":1626948613,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626948613","product_id":100017301,"comment_content":"评论区看了半天，这个快慢指针法，是不是将慢指针遍历过的结点存在数组 A 里，等快指针遍历完后，慢指针一边继续移动，一边与数组 A 里的元素（从数组最后一个元素开始）比较，得出结果。如果理解有误，请帮忙指出","like_count":0},{"had_liked":false,"id":302977,"user_name":"Pz_","can_delete":false,"product_type":"c1","uid":2662744,"ip_address":"","ucode":"A35E576C40FFFC","user_header":"https://static001.geekbang.org/account/avatar/00/28/a1/58/3195a8b5.jpg","comment_is_top":false,"comment_ctime":1626490492,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626490492","product_id":100017301,"comment_content":"Q：选用ArrayList还是LinkedList<br>A：<br>可从四个角度回答<br>1.时间复杂度角度：数组适合随机访问，链表适合中间插入删除。<br>2.缓存角度：数组可以利用CPU的缓存机制，而链表不行（因为数组是连续地址空间）<br>3.内存分配角度：存储较大量的数据，数组需求的连续内存过大可能导致内存不足；链表内存离散，则没有这个问题。<br>4.内存使用角度：链表花费了多余的空间存储链指针，会耗费更多内存，并在插入删除时易造成内存碎片，导致频繁GC，而数组对内存的使用率更高。","like_count":0},{"had_liked":false,"id":302838,"user_name":"eminem-xiao","can_delete":false,"product_type":"c1","uid":1998512,"ip_address":"","ucode":"CF07B647012514","user_header":"https://static001.geekbang.org/account/avatar/00/1e/7e/b0/7eed6726.jpg","comment_is_top":false,"comment_ctime":1626403992,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1626403992","product_id":100017301,"comment_content":"上边所说的LRU（最近最少使用）缓存算法，在我看来只实现了“最近”这一点，而最少并未实现，请问我理解的有问题么？","like_count":0},{"had_liked":false,"id":302770,"user_name":"Alex_GT","can_delete":false,"product_type":"c1","uid":1312926,"ip_address":"","ucode":"86ADB50A2736FA","user_header":"https://static001.geekbang.org/account/avatar/00/14/08/9e/ac07b0c8.jpg","comment_is_top":false,"comment_ctime":1626358710,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626358710","product_id":100017301,"comment_content":"06 链表(上)：如何实现LRU缓存淘汰算法<br><br>1 链表与数组的空间<br>链表的内存可以不连续<br><br>2 几种常见的链表<br>单链表、双向链表、循环链表<br><br>与数组相反，链表进行插入、删除操作非常方便，O(1)复杂度。相应的，随机访问k个结点，则需要从首地址逐个寻址，即O(n)。<br>双向链表再增加、删除时比单链表还要简洁。（想想增删时的前后节点寻址）。再java中，LinkedHashMap就用到了双向链表。本质上双向链表是在增加一个指针的情况下，以空间换时间。<br><br>3 链表vs.数组性能<br>在实际开发中，如果内存要求苛刻，使用数组，节省指针空间。使用链表虽然增删方便，但是java中过于频繁的增删，需要申请、释放内存，导致GC频繁。All in all，性能测试，按照实际需要使用。<br><br>4 解答开篇<br>实现LRU（Least Resently Used）缓存淘汰算法，使用有序单链表。<br>继续优化的话使用散列表（后续学习）<br><br>5 思考题<br>字符串回文判断：快慢指针、寻找中点，慢指针reverse前一半节点，而后判断想等与否。<br>","like_count":0},{"had_liked":false,"id":302492,"user_name":"Geek_842f07","can_delete":false,"product_type":"c1","uid":2698987,"ip_address":"","ucode":"ED772AF755FE7E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/WP4Ge8ABcINFkccKaNYKibicFnI0JAoojBBAUGrichNeRAgzm5RGbHG7GqYrFX3ELEzenuEbicQHJy2HZ72RxSOuMA/132","comment_is_top":false,"comment_ctime":1626239353,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626239353","product_id":100017301,"comment_content":"请问有没有LRU列表实现的代码呢?","like_count":0},{"had_liked":false,"id":301658,"user_name":"fei","can_delete":false,"product_type":"c1","uid":2691974,"ip_address":"","ucode":"CEB9A1C195A074","user_header":"https://static001.geekbang.org/account/avatar/00/29/13/86/89e255c3.jpg","comment_is_top":false,"comment_ctime":1625801661,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625801661","product_id":100017301,"comment_content":"如何利用数组实现 LRU 缓存淘汰策略：1. 初始化一个私有的数组。2.提供访问该数组的指针，并初始化为尾指针。3.提供从后向前访问改数组的方法来进行缓存的数组保存，并更新指针。<br>回文字符串判断： 单链表反转遍历，比较是否和原链表每次访问下一个的值都一样。","like_count":0},{"had_liked":false,"id":300984,"user_name":"lmtoo","can_delete":false,"product_type":"c1","uid":1133918,"ip_address":"","ucode":"FCD5B9C941D448","user_header":"https://static001.geekbang.org/account/avatar/00/11/4d/5e/c5c62933.jpg","comment_is_top":false,"comment_ctime":1625476031,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625476031","product_id":100017301,"comment_content":"用双向链表，分别从开头和末尾依次读取元素，然后依次比较元素是否一致，遍历完之后完全一致的就是回文","like_count":0},{"had_liked":false,"id":300157,"user_name":"红尘","can_delete":false,"product_type":"c1","uid":1445504,"ip_address":"","ucode":"CCCD5736755DF5","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/gVfU7icdia3o5ZNaHjaWAdgkSYIpU1rdhIlVYiahYCvRlDZu2K6oPSvVobNjzwZbUaiayQcKjicZ44WjfWJCj5xdlPA/132","comment_is_top":false,"comment_ctime":1625023499,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625023499","product_id":100017301,"comment_content":"链表<br>缓存淘汰算法，FIFO先进先出淘汰算法，LFU最少使用缓存淘汰算法，LRU最近最少使用缓存淘汰算法<br>什么是链表<br>和数组一样，链表也是一种线性表<br>从内存结构来看，链表的内存结构是不连续的内存空间，将一组零散的内存串联起来，从而进行数据存储的数据结构<br>链表中的每一块内存都被称为节点Node，节点除了存储数据外，还需记录链上下一个节点的地址，<br>为什么使用链表，链表的特点<br>插入删除效率高O（1），只需要修改指针就可以，随机访问效率低O（n），需要从头到尾循环进行遍历<br>和数组相比，内存空间消耗更大，因为每个存储数据的节点不止要存储该节点的数据，还要存储下一个节点的内存地址<br>链表分为单链表，双向链表，循环链表<br>单链表<br>每一个节点就一个指针，既后续指针，<br>单链表有两个特殊的节点，即首节点和尾节点，用首地址表示整个链表，尾节点的后续节点为空<br>性能特点：插入和删除节点的时间复杂度为O（1），查找的时间复杂度为O（n)<br>循环链表<br>除了尾节点的后续指针指向首节点的地址外均为单链表一致<br>适用于存储循环数据的数据结构<br>双向链表<br>节点除了存储数据外，还有两个分别指向上一个节点和下一个节点地址的指针<br>首节点指向上一个节点的指针为空，尾节点指向下一个节点的指针为空。<br>性能特点：和单链表相比，需要消耗更多的内存空间，插入删除操作比单链表效率更高O（1），以删除操作为例，删除操作分为2中情况，给定数组值删除对应节点进行删除，这种情况，单链表和双向链表都需要循环整个链表，所以复杂度都是O（n)，删除给定指针指向的节点，单向链表还是需要遍历链表获取到对应的节点时间复杂度为O（n），双向链表只需要知道删除节点的前序节点和后续节点地址，然后找到前序节点和后续节点，通过修改两个节点里面指向的后续节点和前序节点的指针进行删除，时间复杂度为O（1）,<br>一个有序的链表，双向链表的按值查询效率要比单链表高一些，因为双向链表可以记录上一次最后操作的节点，这样下一次操作就可以从保存的节点入手，进行前进还是后退。<br>数组和链表的区别<br>数组是一个连续存储的内存空间，链表可以不用是一个乱序存储的内存空间，数组的大小是固定的，不能进行扩容，可以创建一个新的数组将原来的数组里面的值放进去，效率低，链表可以动态扩容，链表内存消耗比数组大，随机查找数组比链表更快，因为cpu每次操作都会预读一些内存数据到缓存，因为内存是一块连续的内存空间，所以就可以直接走缓存读取下一个数据，但是链表的话不是一块连续的内存空间，所以每次查询还是需要到存储指针存储的下一个数据，如果采用空间换时间的话用链表，时间换空间的话可以采用数组。<br>用链表实现LRU缓存淘汰算法<br>如果数据已经在链表中，遍历到数据的位置，将数据删除，然后再讲数据添加到链表的头部<br>如果数据不再链表中<br>缓存未满的情况，直接将数据放在链表表头<br>如果缓存满了的情况，先删除链表最后的一个数据，然后将数据放在链表的表头。","like_count":0},{"had_liked":false,"id":296978,"user_name":"谷氨酸钠","can_delete":false,"product_type":"c1","uid":1902750,"ip_address":"","ucode":"DA4F1A48FB0CDD","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/wiaQmkQdIh84RibSLrDkIA3POPhxYU2kjRFvVeLynfm3JjzKc5VEOUpbGT0QxYzKoR6V0mmcLxdqKibqy8hiasUZ4g/132","comment_is_top":false,"comment_ctime":1623247240,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623247240","product_id":100017301,"comment_content":"创建原始链表的Reverse链表，然后再逐个比较","like_count":0},{"had_liked":false,"id":295992,"user_name":"海崖","can_delete":false,"product_type":"c1","uid":2552745,"ip_address":"","ucode":"9D42E0B0D30A56","user_header":"https://static001.geekbang.org/account/avatar/00/26/f3/a9/bb9d8450.jpg","comment_is_top":false,"comment_ctime":1622695493,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622695493","product_id":100017301,"comment_content":"叮~打卡","like_count":0},{"had_liked":false,"id":295202,"user_name":"kenshin","can_delete":false,"product_type":"c1","uid":1653234,"ip_address":"","ucode":"10A09FF2097340","user_header":"https://static001.geekbang.org/account/avatar/00/19/39/f2/23506d84.jpg","comment_is_top":false,"comment_ctime":1622296194,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1622296194","product_id":100017301,"comment_content":"数组实现LRU <br><br>首先由于数组操作第一个元素会消耗更多时间做数据搬迁，所以我考虑反向遍历数组查询缓存，如果查到缓存，删除对应元素，然后直接将缓存add到最后。由于是反向遍历，所以还是会第一个遍历到它。如果数组中没有缓存，缓存充足，也add查询到的元素到数组最后。如果缓存不足，则删除数组最后一个元素。","like_count":0},{"had_liked":false,"id":295014,"user_name":"苏杭天下","can_delete":false,"product_type":"c1","uid":2626287,"ip_address":"","ucode":"C6080021BA450F","user_header":"https://static001.geekbang.org/account/avatar/00/28/12/ef/cb0b57ec.jpg","comment_is_top":false,"comment_ctime":1622183571,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622183571","product_id":100017301,"comment_content":"我理解的linkedHashMap其实可以想象成数组每个节点之间用双链条穿起来的，这里就直接先忽略哈希冲突了。当添加一个数据的时候，会hash出该数据的值，然后&amp;（n-1）定位到数组中的位置存进去，同时添加数据的时候把前后节点的地址也存进去，一起放到数组中，这样相当于跟上面双链表一个意思。当下次查询该数据的时候同样使用上面的过程定位在数组的位置，利用数组的特性O(1)查出数据。该数据既包含value，又包含前后节点的位置，所以遍历的时候就跟链表一样是有序的，get的时候又有MapO(1)的优点。","like_count":0},{"had_liked":false,"id":295007,"user_name":"随穆","can_delete":false,"product_type":"c1","uid":1796209,"ip_address":"","ucode":"D895151046D49F","user_header":"https://static001.geekbang.org/account/avatar/00/1b/68/71/f17e5c13.jpg","comment_is_top":false,"comment_ctime":1622182003,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1622182003","product_id":100017301,"comment_content":"收一个LRU场景。 删除不常用APP。","like_count":0},{"had_liked":false,"id":292543,"user_name":"Bla bla bla","can_delete":false,"product_type":"c1","uid":2612053,"ip_address":"","ucode":"26662A6879A366","user_header":"https://static001.geekbang.org/account/avatar/00/27/db/55/f89f36b5.jpg","comment_is_top":false,"comment_ctime":1620874390,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620874390","product_id":100017301,"comment_content":"空间换时间,或者时间换空间,可不可以这样理解.拿手机说例子,当你手机内存充足的时候,不需要太多的内存,使用app就会流畅一些.当内存紧张的时候,使用app就会慢一些","like_count":0},{"had_liked":false,"id":291847,"user_name":"二小","can_delete":false,"product_type":"c1","uid":1593919,"ip_address":"","ucode":"5377CB552237B2","user_header":"https://static001.geekbang.org/account/avatar/00/18/52/3f/c8b40efe.jpg","comment_is_top":false,"comment_ctime":1620549901,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620549901","product_id":100017301,"comment_content":"链表不能像数组那样随机访问，所以链表的插入和删除不是需要找到对应的位置的吗，那么怎么回事O(1)的时间复杂度？","like_count":0},{"had_liked":false,"id":291445,"user_name":"仰望星空","can_delete":false,"product_type":"c1","uid":1149084,"ip_address":"","ucode":"A9E46C9FDB3275","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/9c/cbc463e6.jpg","comment_is_top":false,"comment_ctime":1620289644,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620289644","product_id":100017301,"comment_content":"单链表实现LRU代码链接：https:&#47;&#47;iflydocs.com&#47;h&#47;s&#47;doc&#47;TOx8qZtl6s8dho7M","like_count":0},{"had_liked":false,"id":290714,"user_name":"Allan","can_delete":false,"product_type":"c1","uid":1310388,"ip_address":"","ucode":"8DA4DBECC2C45C","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","comment_is_top":false,"comment_ctime":1619698937,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619698937","product_id":100017301,"comment_content":"public static boolean isHuiwen(LinkedNode str) {<br><br>        LinkedNode node = str;<br>        int len = 0;<br>        while (node != null) {<br>            node = node.next;<br>            len++;<br>        }<br><br>        int[] array = new int[len];<br>        int index = 0;<br>        node = str;<br>        while (node != null) {<br>            array[index] = node.val;<br>            node = node.next;<br>            index++;<br>        }<br><br>        int start = 0, end = array.length - 1;<br>        while (start &lt; end) {<br>            if (array[start] != array[end]) {<br>                return false;<br>            }<br><br>            start++;<br>            end--;<br>        }<br><br>        return true;<br><br>    }<br><br>时间复杂度：O(n) 空间复杂度：O(n)","like_count":0},{"had_liked":false,"id":289804,"user_name":"颜桦","can_delete":false,"product_type":"c1","uid":1099576,"ip_address":"","ucode":"1CD7250E052B32","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/38/d1a50cd6.jpg","comment_is_top":false,"comment_ctime":1619180701,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619180701","product_id":100017301,"comment_content":"链表想要在某个位置插入元素的时候不一样需要先找到对应位置的元素进而找到指针才能操作吗？怎么能直接找到某个指针的地址呢？","like_count":0},{"had_liked":false,"id":288990,"user_name":"eightAge","can_delete":false,"product_type":"c1","uid":1031336,"ip_address":"","ucode":"FF7AB24E25ABA9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bc/a8/4a1a4166.jpg","comment_is_top":false,"comment_ctime":1618811743,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618811743","product_id":100017301,"comment_content":"&#47;**<br> * 使用单向链表实现一个LRU缓存<br> *&#47;<br>public class LRUDemo {<br><br>    private static final int MAX_LENGTH = 5;<br><br>    private static ListNode head;<br><br>    public static ListNode add(ListNode newNode) {<br>        if (isFull(head)) {<br>            removeOld(head);<br>        }<br>        newNode.next = head;<br>        head = newNode;<br>        return head;<br>    }<br>    public static boolean isFull(ListNode node) {<br>        int listSize = 0;<br>        while (node != null) {<br>            listSize++;<br>            node = node.next;<br>        }<br>        return listSize == MAX_LENGTH;<br>    }<br>    private static void removeOld(ListNode node) {<br>        while (node.next.next != null) {<br>            node = node.next;<br>        }<br>        node.next = null;<br>    }<br><br>    public static ListNode get(ListNode node) {<br>        ListNode cursor = head;<br>        ListNode pre = cursor;<br>        while (cursor != null) {<br>            int val = cursor.val;<br>            if (val == node.val) {<br>                if (pre == cursor) {<br>                    break;<br>                }<br>                &#47;&#47; 把这个节点放到头部，删除+新增<br>                pre.next = cursor.next;<br>                add(cursor);<br>                break;<br>            }<br>            pre = cursor;<br>            cursor = cursor.next;<br>        }<br>        return head;<br>    }<br>}","like_count":0},{"had_liked":false,"id":287828,"user_name":"小甘","can_delete":false,"product_type":"c1","uid":1376733,"ip_address":"","ucode":"17E68EF8D1AE85","user_header":"https://static001.geekbang.org/account/avatar/00/15/01/dd/169c2c54.jpg","comment_is_top":false,"comment_ctime":1618188558,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618188558","product_id":100017301,"comment_content":"课后题<br>数组法： <br>1. 将链表内的值依次push到数组内。<br>2. 依次对比数组第 index项和 length - index -1项的值是否相同<br><br>双指针：<br>1. 快慢指针找中点；<br>2. 反转后半段链表<br>3. 依次比较两段链表的值","like_count":0},{"had_liked":false,"id":287225,"user_name":"张知信","can_delete":false,"product_type":"c1","uid":2144474,"ip_address":"","ucode":"7C896BB3214B3D","user_header":"https://static001.geekbang.org/account/avatar/00/20/b8/da/42284f64.jpg","comment_is_top":false,"comment_ctime":1617846710,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617846710","product_id":100017301,"comment_content":"1. 如何利用数组实现 LRU 缓存淘汰策略呢？<br>可以利用循环数组（下标取余，模拟循环），记录数组开头（head）和结尾（tail），越靠近head越早进入，当有新数据访问时，从head开始遍历寻找该数据在数组中的位置。<br>如果找到了，从原位置删除（需要移动后面的元素O(n)），插入尾部。<br>如果没有找到：a.缓存未满，插入尾部；b.缓存已满，插入删除头，插入尾部。<br><br>2. 单链表回文字符串判断<br>找到中间节点 mid（长度奇数正中节点，长度偶数正中两个节点右边那个），逆转mid开头的链表（可以选择断开mid开头的链表，这样需要mid的前驱节点），从原始链表的头节点和尾节点开始，双指针遍历，依次比较节点值是否相等，全等就是回文串。","like_count":0},{"had_liked":false,"id":286897,"user_name":"林敏健","can_delete":false,"product_type":"c1","uid":1101426,"ip_address":"","ucode":"EF0CE23273878C","user_header":"https://static001.geekbang.org/account/avatar/00/10/ce/72/638a2804.jpg","comment_is_top":false,"comment_ctime":1617674082,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617674082","product_id":100017301,"comment_content":"回文问题，可以弄多一个链表，只用一个两步跳的指针，每跳一次，就从头部删除一个元素，插入到另外一个链表的头部，等找到中点后，就从头遍历两个链表，逐一进行对比","like_count":0},{"had_liked":false,"id":286609,"user_name":"Binfun","can_delete":false,"product_type":"c1","uid":1015952,"ip_address":"","ucode":"B0CAAD6C23C2C7","user_header":"","comment_is_top":false,"comment_ctime":1617424782,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617424782","product_id":100017301,"comment_content":"因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。<br><br>原文这一段，内存消耗不一定是翻倍呀，在32位系统中，增加一个4字节的指针而已","like_count":0},{"had_liked":false,"id":285327,"user_name":"Mmi223","can_delete":false,"product_type":"c1","uid":1150430,"ip_address":"","ucode":"A49A024333C01C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/HOIjvMJfj8Qg9EdLyvLXEldpo3qEhHOpsibFaAb7kc4wc6xoHQqKX7gUO3YHhnAJHFdibdI7Mef0cZ9zLsRlpQ2Q/132","comment_is_top":false,"comment_ctime":1616741561,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616741561","product_id":100017301,"comment_content":"从大家评论里学到很多，大致步骤是：快慢指针遍历，快指针到终点时，慢指针开始将接下来的节点逆序+遍历；之后两个指针从原来的头尾，遍历比较。时间上时on，空间上为常量 o1","like_count":0},{"had_liked":false,"id":284797,"user_name":"无","can_delete":false,"product_type":"c1","uid":1266245,"ip_address":"","ucode":"EBB0150385B89E","user_header":"https://static001.geekbang.org/account/avatar/00/13/52/45/19bacca9.jpg","comment_is_top":false,"comment_ctime":1616477141,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616477141","product_id":100017301,"comment_content":"请问GC（垃圾回收）是导致内存碎片出现的原因，还是GC可以回收内存碎片得到完整的内存空间","like_count":0},{"had_liked":false,"id":283623,"user_name":"lobby","can_delete":false,"product_type":"c1","uid":1181960,"ip_address":"","ucode":"8D81722BE36AD4","user_header":"https://static001.geekbang.org/account/avatar/00/12/09/08/f3547e77.jpg","comment_is_top":false,"comment_ctime":1615859594,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615859594","product_id":100017301,"comment_content":"cpu角度的数组和链表差异真的是体现功力了，厉害👍","like_count":0},{"had_liked":false,"id":283234,"user_name":"起风了","can_delete":false,"product_type":"c1","uid":1160219,"ip_address":"","ucode":"4356EDCECC612A","user_header":"https://static001.geekbang.org/account/avatar/00/11/b4/1b/5a8c0c11.jpg","comment_is_top":false,"comment_ctime":1615632968,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615632968","product_id":100017301,"comment_content":"**谍战片里的不同接头人之间的关系最好使用单向链表这种数据结构**<br>组织级别最高的人为链表的头，组织级别最低的人为链表的尾。可以即使策反了级别低的人，也很难向上查找找到更高级别的人。这里只考虑的每个节点只有一人，如果一个人对应多个人，那么就是单向树（如果有）这种数据结构。","like_count":0},{"had_liked":false,"id":283161,"user_name":"zhangdroid","can_delete":false,"product_type":"c1","uid":1120940,"ip_address":"","ucode":"6254CEAEC274D3","user_header":"https://static001.geekbang.org/account/avatar/00/11/1a/ac/cec17283.jpg","comment_is_top":false,"comment_ctime":1615601726,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615601726","product_id":100017301,"comment_content":"用数组实现<br><br>public static boolean check(String str){<br>    if(null == str || &quot;&quot;.equals(str)){<br>            return false<br>     }<br>     int i = 0;<br>     int j = str.length() - 1;<br>     String[] strings = str.split(&quot;&quot;);<br>     boolean flag = false;<br>     for (; i &lt;= j; i++,j--) {<br>         if(!strings[i].equals(strings[j])){<br>             return false;<br>         }<br>     }<br>     return true;<br>}","like_count":0},{"had_liked":false,"id":282967,"user_name":"Charles","can_delete":false,"product_type":"c1","uid":1088301,"ip_address":"","ucode":"996D0F4B6196E5","user_header":"https://static001.geekbang.org/account/avatar/00/10/9b/2d/8afd979f.jpg","comment_is_top":false,"comment_ctime":1615478178,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615478178","product_id":100017301,"comment_content":"我想到的办法是这样的，用数组做 LRU 的时候，我们把最新的数据放到数组的下一个空格，并用一个下标 head，记住这个位置，下次放最新数据的时候，就放到 (head + 1) % length，这样如果到底了，又会绕回开头。最古老的数据，就是 head + 1 指向的数据。如果数据之前已经在数组里了，我们可以需要遍历才能找到平均复杂度O(n)，然后把这个数据搬移到 head + 1，然后 head = head + 1 就好了。至于要不要把空洞填上，可以看情况了。","like_count":0},{"had_liked":false,"id":282952,"user_name":"Geek","can_delete":false,"product_type":"c1","uid":2009059,"ip_address":"","ucode":"E4E5A25AF08961","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLT5FUVKibUC0YcbkIkDmaoXBTP872icNbL4mTgiaQO97yOZ6Ff5r3IhYibpInia153858libloqw7n2obw/132","comment_is_top":false,"comment_ctime":1615473615,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1615473615","product_id":100017301,"comment_content":"1. 在数组中，直接双指针遍历<br>2.在链表中，利用快慢指针","like_count":0},{"had_liked":false,"id":282234,"user_name":"这就是生活","can_delete":false,"product_type":"c1","uid":2378295,"ip_address":"","ucode":"847EE53DA017C8","user_header":"https://static001.geekbang.org/account/avatar/00/24/4a/37/fb06fb79.jpg","comment_is_top":false,"comment_ctime":1615168524,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615168524","product_id":100017301,"comment_content":"用数组和链表实现LRU<br>数组最后一位为最近使用<br>添加<br>      查找元素是否存在O(n)，如果不存在且容量不满   都是O(1)<br>                                           如果不存在且容量已满   链表O(1)    数组O(n)<br>                                           如果存在     链表O(1)  数组O(n)<br><br>使用链表还是数组<br>结合时间，内存，效率考虑<br><br>回文字符串<br>单链表申请字符串长度一半的内存n&#47;2   即O(n)<br>循环遍历字符串每遇到一个字符串向链表头添加一个链表节点<br>等链表节点个数达到了字符串长度的一半之后，就应该从头开始删除链表节点<br>下一个字符和链表头的字符不相同则不是回文字符串。<br>如果相同则删除链表头，链表头的下一个节点为链表头<br>最坏时间复杂度为O(n)   最好时间复杂度为O(n&#47;2)    时间复杂度为O(n)","like_count":0},{"had_liked":false,"id":281968,"user_name":"一点点就好","can_delete":false,"product_type":"c1","uid":1055913,"ip_address":"","ucode":"3082B6E93FA7D8","user_header":"https://static001.geekbang.org/account/avatar/00/10/1c/a9/49ffc8c7.jpg","comment_is_top":false,"comment_ctime":1614998595,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1614998595","product_id":100017301,"comment_content":"请教一下，思考题中，是怎么想到用快慢指针的方式呢？有和依据吗？","like_count":0,"discussions":[{"author":{"id":2687339,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/NGib8v9Lml2JBfP5hIKib85d3jQpWibbXwfjaGnKmmGOzX45a3AQN67E5QnuKwaKc4MPfOe5qqLmW4tJxqZ8RCiawg/132","nickname":"Geek_ting_2021","note":"","ucode":"A6D5C57FA6806F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541922,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640603389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281967,"user_name":"征服天堂","can_delete":false,"product_type":"c1","uid":2445066,"ip_address":"","ucode":"686ED7ECC00004","user_header":"https://static001.geekbang.org/account/avatar/00/25/4f/0a/0ebfbb01.jpg","comment_is_top":false,"comment_ctime":1614997705,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614997705","product_id":100017301,"comment_content":"可以两次遍历单链表，第一次遍历直接记录节点数n，创建n大小的数组，第二次遍历将单链表中数据依次存放入数组中，然后通过数组检查是否为回文串，时间复杂度O(n)，空间复杂度也为O(n)","like_count":0},{"had_liked":false,"id":281390,"user_name":"十七","can_delete":false,"product_type":"c1","uid":2061208,"ip_address":"","ucode":"038F8EBFA8D2A2","user_header":"https://static001.geekbang.org/account/avatar/00/1f/73/98/60f8d766.jpg","comment_is_top":false,"comment_ctime":1614736583,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614736583","product_id":100017301,"comment_content":"x-&gt;next = p-&gt;next;  &#47;&#47; 将x的结点的next指针指向b结点；<br>p-&gt;next = x;  &#47;&#47; 将p的next指针指向x结点；<br>这个为什么颠倒一下就对了呢？<br><br>","like_count":0},{"had_liked":false,"id":280660,"user_name":"stan","can_delete":false,"product_type":"c1","uid":2351829,"ip_address":"","ucode":"F45B855C8BACD1","user_header":"https://static001.geekbang.org/account/avatar/00/23/e2/d5/c0b814ad.jpg","comment_is_top":false,"comment_ctime":1614307131,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614307131","product_id":100017301,"comment_content":"github  java源码里面  62 行 <br> newNode.next = q.next;  <br>这么写是什么意思？求讲解","like_count":0},{"had_liked":false,"id":280595,"user_name":"陈威洋","can_delete":false,"product_type":"c1","uid":2264679,"ip_address":"","ucode":"DCF84B4D3A7354","user_header":"https://static001.geekbang.org/account/avatar/00/22/8e/67/afb412fb.jpg","comment_is_top":false,"comment_ctime":1614260111,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614260111","product_id":100017301,"comment_content":"读完老师的文章，带着问题看完评论区全部内容，困惑自然就解了。去年我刚学习数据结构与算法，心中有很多困惑，但说不出来，今天看了老师的链表，把我心中很多疑惑扫清，很踏实的感觉。<br><br>思考题：<br>单链表存储，设置两组指针A和B，从链表头部开始遍历，指针A每次前进一位，指针B每次前进两位；指针A每到一个位置，就将该位置的字符压入栈中，直到指针B到达链表尾部，此时指针A到达字符串的中间位置。然后，每当指针A前进一步，就将栈中的字符弹出一位，比较指针A所指字符与弹出字符是否相等，如果相等，则继续运行；不等，则退出程序，说明该字符串不是回文序列。<br>时间O（n），空间O（n）。<br>","like_count":0},{"had_liked":false,"id":280296,"user_name":"罗耀龙@坐忘","can_delete":false,"product_type":"c1","uid":1917663,"ip_address":"","ucode":"3CEA258DE7F3C7","user_header":"https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg","comment_is_top":false,"comment_ctime":1614154545,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1614154545","product_id":100017301,"comment_content":"茶艺师学编程<br><br>1、如何用数组实现lru缓存淘汰<br>我想到的是<br>如果所需的数据已经在数组里了，把原来［0］位的和这数据互换位置<br>如果是新进来的数据，如果数组没满，那么数组尾＋1和［0］互换，新数据进［0］；<br>如果数组满了，把数组尾的去掉，再进行上面步骤。<br>这样操作的时间复杂度，是O（1）<br><br>2、思考题<br>回文，用快慢指针，不是回文两者不会相遇，否则相遇。","like_count":0},{"had_liked":false,"id":279314,"user_name":"八九","can_delete":false,"product_type":"c1","uid":1191617,"ip_address":"","ucode":"B996A884BFA474","user_header":"https://static001.geekbang.org/account/avatar/00/12/2e/c1/0fcd29ab.jpg","comment_is_top":false,"comment_ctime":1613717393,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613717393","product_id":100017301,"comment_content":"总结：<br>1.链表应用： LRU 缓存淘汰算法<br>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用。<br>硬件中的缓存: CPU缓存，而cpu缓存又可以分为寄存器，一级缓存，二级缓存，三级缓存。（笔记：冰） <br>软件中的缓存: 数据库缓存，数据库本身产品就自带缓存。redis也可以作为数据库缓存。<br>浏览器缓存，就是我们常说的Cookie,本质上就是一个文件。<br>缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。<br>常见的策略有三种：先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used）。<br><br>LRU 缓存淘汰算法：时间复杂度为 O(n)<br>LRU的算法思路（尾旧头新）：(笔记：EJoft)<br>使用定长链表来保存所有缓存的值，并且最老的值放在链表最后面。 <br>当访问的值在链表中时： 将找到链表中值将其删除，并重新在链表头添加该值（保证链表中 数值的顺序是从新到旧） <br>当访问的值不在链表中时： 当链表已满：删除链表最后一个值，将要添加的值放在链表头 当链表未满：直接在链表头添加。<br><br>2.数组与链表对比<br>底层存储结构：数组需要连续的内存空间，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于申请内存，仍然会申请失败。<br>\t\t      链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用。<br>插入删除：数组O(n)、链表O(1)<br>随机访问：数组O(1)、链表O(n)\t<br>\t\t  <br>3.链表种类：<br>1)单链表：<br>-&gt;data|next-&gt;data|next-&gt;data|next-&gt; null\t（每一个内存块称为链表的“结点”:-&gt;node1-&gt;node2-&gt;node3-&gt;null）<br>data:存储数据<br>next：后继指针 next，记录下个结点地址的指针<br>第一个结点（头结点）:头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表<br>最后一个结点（尾节点）:尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个空地址 NULL，表示这是链表上最后一个结点。<br>链表的插入和删除：O(1) 不考虑内存的连续性，只需要考虑相邻结点的指针改变。<br>链表的随机访问：O(n)  从头遍历，顺序访问<br>2)循环链表：当要处理的数据具有环型结构特点时，就特别适合采用循环链表。<br>-&gt;node1-&gt;node2-&gt;node3-&gt;node1<br>循环链表是一种特殊的单链表。它跟单链表唯一的区别就在尾结点。单链表的尾结点指针指向空地址，而循环链表的尾结点指针是指向链表的头结点。<br>3)双向链表:<br>-&gt;prev|data|next&lt;-&gt;prev|data|next&lt;-&gt;prev|data|next<br>单向链表只有一个后继指针 next 指向后面的结点。而双向链表每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。<br>链表的删除和插入：O(1),双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点。<br>链表的按值查询:可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。<br>4)双向循环链表:循环链表和双向链表整合在一起<br>头结点的prev是尾结点，尾结点的next是头结点<br><br>4.用空间换时间的设计思想<br>对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；<br>对于消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。<br><br>谢谢老师及各位小伙伴！","like_count":0},{"had_liked":false,"id":279073,"user_name":"陈峯","can_delete":false,"product_type":"c1","uid":2414165,"ip_address":"","ucode":"7337EB89B92E99","user_header":"https://static001.geekbang.org/account/avatar/00/24/d6/55/7031ebdc.jpg","comment_is_top":false,"comment_ctime":1613606286,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613606286","product_id":100017301,"comment_content":"数组实现LRU与链表逻辑类似，维护一个定量的数组，第0位存储的是最近少用的数据，遍历数组访问；<br>1、存在缓存，则删除再插入数组末端<br>2、未存在，分两种情况<br>a,数组未满，插入数组末端<br>b、数组已满，删除第0位，插入数组末端<br>无论访问、删除、插入都是要遍历，所以时间复杂度是O(n)","like_count":0},{"had_liked":false,"id":279070,"user_name":"陈峯","can_delete":false,"product_type":"c1","uid":2414165,"ip_address":"","ucode":"7337EB89B92E99","user_header":"https://static001.geekbang.org/account/avatar/00/24/d6/55/7031ebdc.jpg","comment_is_top":false,"comment_ctime":1613603037,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613603037","product_id":100017301,"comment_content":"方法一：<br>遍历链表n次，对比首尾节点是否相同；相同则进行n-2次遍历；直到对比首尾结点指针相等或遍历次数为0为止  <br>空间复杂度O(n)<br>时间复杂度O(n²）<br>方法二：<br>遍历链表n次，创建一个双向循环链表；遍历双向循环链表n&#47;2次，对比首尾结点是否相等<br>空间复杂度O(n)<br>时间复杂度O(n)","like_count":0},{"had_liked":false,"id":278554,"user_name":"啦啦啦","can_delete":false,"product_type":"c1","uid":1131687,"ip_address":"","ucode":"6B12EC90A62525","user_header":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","comment_is_top":false,"comment_ctime":1613051471,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613051471","product_id":100017301,"comment_content":"现在是2021年2月11的21点50分，是除夕夜，我不看春晚，我在看数据结构和算法，有没有和我一样的","like_count":0},{"had_liked":false,"id":272578,"user_name":"下个目标45k","can_delete":false,"product_type":"c1","uid":1066508,"ip_address":"","ucode":"193BA8C3AA9A61","user_header":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","comment_is_top":false,"comment_ctime":1610163389,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610163389","product_id":100017301,"comment_content":"Redis数据淘汰策略用到了 LRU和LFU","like_count":0},{"had_liked":false,"id":272430,"user_name":"InfoQ_ec4731fa53ab","can_delete":false,"product_type":"c1","uid":2123956,"ip_address":"","ucode":"66E2DD0529FEA5","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/vf8s3HjicVyOxLJjWAgsnv3WvgCialNLYsPcNP290VRTPEzN6F7Hox0Maia7IqDDR0pIbDF4nnT8CxDNicOziaQeWkg/132","comment_is_top":false,"comment_ctime":1610088776,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610088776","product_id":100017301,"comment_content":"单链表删除给定指针指向的结点，是不是可以做到时间复杂度为O(1)呢？比如要删除的节点是p，将p节点的下一个节点的data赋值给p，然后删除下一个节点，这样是不是就可以做到删除给定指针指向的结点的时间复杂度为O(1)呢","like_count":0},{"had_liked":false,"id":272307,"user_name":"客舟听雨来coding","can_delete":false,"product_type":"c1","uid":1026219,"ip_address":"","ucode":"753F4B779CC416","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a8/ab/5d25cd32.jpg","comment_is_top":false,"comment_ctime":1610026242,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1610026242","product_id":100017301,"comment_content":"为什么说单链表插入和删除时间复杂度是O(1)，不是需要先找到节点在插入或者删除吗，这样不是O(n)吗？<br><br>老师指点一下这个问题。","like_count":0},{"had_liked":false,"id":271961,"user_name":"xxx","can_delete":false,"product_type":"c1","uid":1356978,"ip_address":"","ucode":"E78B1F15BC10F7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIcLjatV3GHdibZXCTIgL1X2A7jpByIeLH3Zyia8KXdT4JRcicmVSgq5ekRHCFCFenMqicsAwaWYibHkTw/132","comment_is_top":false,"comment_ctime":1609896626,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609896626","product_id":100017301,"comment_content":"链表和数组一样，也是线性表。不同的是，链表的存储是非连续的，其插入和删除时间复杂度是O(1)，查找复杂度是O(n)。<br>练习题单链表存储字符串验证回文，使用快慢指针，找到链表中间点，同时前半部分的链表反序，再进行比较。","like_count":0},{"had_liked":false,"id":270608,"user_name":"阿杰","can_delete":false,"product_type":"c1","uid":2370758,"ip_address":"","ucode":"B9C504269C8CD3","user_header":"https://static001.geekbang.org/account/avatar/00/24/2c/c6/416bd86e.jpg","comment_is_top":false,"comment_ctime":1609169820,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1609169820","product_id":100017301,"comment_content":"数组实现LRU：<br>1.维护一个数组，越靠近数组尾部表示越经常使用。<br>2.当有新的数据被访问时，遍历数组，如果该数据在数组中则把该数据和尾数据位置进行交换。<br>3.如果该数据不在数组中：<br>  3.1缓存还没满的情况下（数组还没满），直接把该元素插入到最后一个位置上。<br>  3.2如果缓存已满（代表数组已经满了，无法使用标记法批量删除），则删除第一个位置上的数据，并且将其余数据集体前移，将新来的数据插入到最后一个位置上。这个操作时间复杂度为O（n）因为需要集体前移一位。<br>另外关于LRU的链表实现有个问题想请教下老师，老师说的维护一个&quot;有序&quot;的链表  这个有序指的是什么呢，如果是针对数据大小而言的话，每次插入最新的数据感觉好像会破坏掉顺序，望老师指点迷津。","like_count":0},{"had_liked":false,"id":270000,"user_name":"j","can_delete":false,"product_type":"c1","uid":2324722,"ip_address":"","ucode":"96BAF9A9524C9F","user_header":"https://static001.geekbang.org/account/avatar/00/23/78/f2/02eb3b5c.jpg","comment_is_top":false,"comment_ctime":1608871063,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608871063","product_id":100017301,"comment_content":"判断字符串是否是回文串，如果是[]byte存储，O(n&#47;2)时间复杂度，如果是单链表存储，需要额外空间复杂度O(n),n表示字符串长度，用于存储指针（64位系统8字节大小）。目前想到的方法是字符串倒转遍历，生成一个新的单链表，然后遍历一次，比较链表中的data，字符是否相等。时间复杂度O(n)...不知道是否还有更好的思路？","like_count":0},{"had_liked":false,"id":269862,"user_name":"olivia-byte","can_delete":false,"product_type":"c1","uid":1273891,"ip_address":"","ucode":"D54B3833995923","user_header":"https://static001.geekbang.org/account/avatar/00/13/70/23/92d188aa.jpg","comment_is_top":false,"comment_ctime":1608815670,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608815670","product_id":100017301,"comment_content":"&#47;**<br> * Definition for singly-linked list.<br> * public class ListNode {<br> *     int val;<br> *     ListNode next;<br> *     ListNode(int x) { val = x; }<br> * }<br> *&#47;<br>class Solution {<br>    public boolean isPalindrome(ListNode head) {<br>        if (null == head) {<br>            return true;<br>        }<br><br>        ListNode half = this.findHalf(head);<br><br>        &#47;&#47; 链表反转<br>        ListNode secondStart = this.reverse(half.next);<br><br>        &#47;&#47; 2个链表元素依次比较<br>        while (null != secondStart) {<br>            if (head.val != secondStart.val) {<br>                return false;<br>            }<br><br>            head = head.next;<br>            secondStart = secondStart.next;<br>        }<br>        return true;<br>    }<br><br>    &#47;**<br>     * 确定链表中位<br>     *&#47;<br>    private ListNode findHalf(ListNode head) {<br>        &#47;&#47; 定义slow、fast快慢指针<br>        ListNode slow = head, fast = head;<br>        while (null != fast.next &amp;&amp; null != fast.next.next) {<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        }<br>        return slow;<br>    }<br><br>    &#47;**<br>     * 链表反转<br>     * @param curNode<br>     * @return<br>     *&#47;<br>    public ListNode reverse(ListNode curNode) {<br>        ListNode head = curNode;<br>        ListNode pre = null;<br>        ListNode nextNode;<br>        while (null != head) {<br>            nextNode = head.next;<br>            head.next = pre;<br>            pre = head;<br>            head = nextNode;<br>        }<br>        return pre;<br>    }<br>}","like_count":0},{"had_liked":false,"id":268595,"user_name":"bowen","can_delete":false,"product_type":"c1","uid":1073569,"ip_address":"","ucode":"B0979D12090C7D","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/a1/f2ddc098.jpg","comment_is_top":false,"comment_ctime":1608267896,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608267896","product_id":100017301,"comment_content":"总结：缓存的作用，以CPU缓存为例，CPU从内存中取一块地址，并非要访问数据的特定大小，而是一个数据库块，放入缓存，再从缓存中读取数据，能优化内存慢而CPU快的问题，数组是连续空间，所以刚好利用了CPU缓存的这个特性，所以访问效率高。<br>缓存淘汰策略，包括FIFO先入先出，LRU最近最少使用，用链表实现LRU是因为链表是非连续空间，所以支持快速插入和删除操作，如果用数组会导致频繁的数据搬移操作<br>链表检测回文字符串，使用快慢指针定链表中点，奇数定中间节点，偶数放中下节点，慢指针将前半部分反序，之后再遍历判断是否想等。。单链表反转貌似也是一道题，这么写挺复杂的，不如直接复制一个反序链表出来看是否相等","like_count":0},{"had_liked":false,"id":267286,"user_name":"Geek_a172a8","can_delete":false,"product_type":"c1","uid":2254320,"ip_address":"","ucode":"AD89F453957BA3","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/oXudqhU3yGOtEibnWRnp6vAE8PjicHRguxWKDMH2sUtMPZbAZpLnictdRrwn8vFHvIfjqDRCuKSdYr6ITEGPlWhnQ/132","comment_is_top":false,"comment_ctime":1607669441,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607669441","product_id":100017301,"comment_content":"有序的双向链表是怎么实现 只查询一半呢？ 没看懂 ","like_count":0},{"had_liked":false,"id":266160,"user_name":"慕高迪","can_delete":false,"product_type":"c1","uid":1448126,"ip_address":"","ucode":"EB1CB5EA4E3A90","user_header":"https://static001.geekbang.org/account/avatar/00/16/18/be/ad3127e0.jpg","comment_is_top":false,"comment_ctime":1607221879,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607221879","product_id":100017301,"comment_content":"总结：<br><br>链表作为一种数据结构，在内存上的地址不需要具有连续性，元素之间的寻址，主要通过为每个元素附加指针指向周围元素，从而完成整个链表的访问。<br><br>链表又分为两类：为每个元素附加指向下一次元素地址的指针从而形成的链表，称为单链表；在单链表的基础上，在每个元素上额外附加一个指向上一个元素地址的指针，就形成了双向链表。<br>正常情况下，单链表最后一个元素指向的下一个元素的地址为null，如果将最后一个元素的地址指向链表头元素的地址，那么就形成了环状链表。同理，双向链表也可以通过改变指针的指向从而形成双向环状链表<br><br>链表由于在地址空间上不是连续的，所以不支持像数组那样可以按照寻址公式进行随机访问，所以在链表中查找元素的时间复杂度为O(N)；但是在添加或删除元素上，由于不需要进行数据的移位，只需要改变指针的指向即可，所以时间复杂度为O(1);<br>我们会发现链表的查找，添加或删除的时间复杂度正好与数组相反。这一点的不同，往往是我们在选择使用数组还是链表时，起到了关键的作用。<br><br>下面我们在来看看由单链表衍生出来的链表，都会带来哪些改变：<br><br>环状链表，从链表尾到链表头部比较方便，适合需要环状存储的数据。例如：可以使用环状链表，处理约瑟夫问题（俗称：丢手绢问题）<br><br>双向链表，由于存在了指向上一个元素的指针。当给定一个元素的地址，需要在该元素的前面添加一个元素时，双向链表可以很高的解决这种问题，时间复杂度为O(1)。而采用单向链表往往需要遍历，找到该地址的元素并且还需要记录上一个元素的地址，时间复杂度为O(n).<br>双向链表虽好，却是有代价的。它占用的空间比单链表要大。如果在一些内存要求比较严格的场景下，例如移动端设备，内存往往较小，这种以空间换时间的策略就不适用。相反则适用。<br><br>在实际应用中，数组和链表总是放在一起进行比较，那到底是数据还是选择链表呢？下面有几点需要考虑：<br><br>1. 上述所说的时间复杂度问题。<br><br>如果你的应用场景需要频繁的添加和删除，那链表比较适合你；如果是查询操作比较多，数组更合适；如果场景需要查找到指定元素，并在该元素上进行添加或者是删除元素，此时无论是采用数组还是链表，时间的复杂度均为O(N)<br><br>2. 数组由于是连续的内存地址结构，可以利用上CPU的缓存，预读数据中的数据，从而使访问效率更高。而链表由于不连续，则无法利用上CPU的缓存。<br><br>3. 数组的大小是固定的，容量满了之后需要扩容，扩容涉及到新旧数组的拷贝非常耗时。在内存的分配上即使内存中存在满足条件的大小空间，也会因为地址不连续从而导致数组创建失败，从而出现OOM的现象。 而链表就没有这个问题，只要内存空间足够就可以继续添加元素节点。<br><br>4. 在一些内存空间受限的场景下，数组比链表更加实用，因为链表需要额外的存储空间来存储指针信息。<br><br>总结起来就是要分析如下几点：<br><br>1. 数组与链表在内存分配上的差异<br><br>2. 数组与链表执行查询，添加和删除在效率上的差异<br><br>3. 数组与链表在元素空间占用上的差异<br><br>4. 数组和链表在与系统内其他组件合作时，所带来的好处<br><br><br>综上所述，你需要结合当前环境的内存大小和分布，业务特点，是否能与系统内其他组件配合从而带来性能上提升等条件综合考虑","like_count":0},{"had_liked":false,"id":265190,"user_name":"汤梦飞","can_delete":false,"product_type":"c1","uid":2326661,"ip_address":"","ucode":"1C6871E69CA119","user_header":"https://static001.geekbang.org/account/avatar/00/23/80/85/e7d6750f.jpg","comment_is_top":false,"comment_ctime":1606809779,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606809779","product_id":100017301,"comment_content":"提供的示例中判断回文的函数（isPalindrome）不对，不应该是while(i&lt;=length)，而是while(i&lt;length)","like_count":0},{"had_liked":false,"id":264772,"user_name":"大力","can_delete":false,"product_type":"c1","uid":1364353,"ip_address":"","ucode":"1B2125C519443D","user_header":"https://static001.geekbang.org/account/avatar/00/14/d1/81/89ba9d81.jpg","comment_is_top":false,"comment_ctime":1606640921,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606640921","product_id":100017301,"comment_content":"不同意老师关于单链表删除操作中，“删除给定指针指向的结点”需要 O(n) 的时间复杂度的说法。<br>我只需要使用快慢指针，两指针相差一结点，这样当快指针指向待删除结点时，慢指针不就指向了待删除结点的前一结点了吗？所以时间复杂度还能维持是 O(1) 啊。","like_count":0},{"had_liked":false,"id":264222,"user_name":"jeff","can_delete":false,"product_type":"c1","uid":1026894,"ip_address":"","ucode":"68456DD035BDF4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ab/4e/82e9657c.jpg","comment_is_top":false,"comment_ctime":1606383293,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606383293","product_id":100017301,"comment_content":"链表需要初始化100m内存吗？什么情况下需要呢？","like_count":0},{"had_liked":false,"id":263861,"user_name":"jeff","can_delete":false,"product_type":"c1","uid":1026894,"ip_address":"","ucode":"68456DD035BDF4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ab/4e/82e9657c.jpg","comment_is_top":false,"comment_ctime":1606282954,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606282954","product_id":100017301,"comment_content":"1、定位中点：O(n)<br>2、指针移动到中间O(n&#47;2),前半截逆序<br>3、同步遍历两部分并对比，O(n&#47;2)<br>大O表示法去掉常数、系数，O(2n)=O(n)","like_count":0},{"had_liked":false,"id":263859,"user_name":"jeff","can_delete":false,"product_type":"c1","uid":1026894,"ip_address":"","ucode":"68456DD035BDF4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ab/4e/82e9657c.jpg","comment_is_top":false,"comment_ctime":1606282799,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606282799","product_id":100017301,"comment_content":"思考：<br>1、定位中间节点，时间复杂度：O(n)<br>2、将指针移动到中间O(n&#47;2)，移动时顺便将前半截逆序。","like_count":0},{"had_liked":false,"id":262980,"user_name":"晚来秋","can_delete":false,"product_type":"c1","uid":1256316,"ip_address":"","ucode":"3BAAB2F38A3109","user_header":"https://static001.geekbang.org/account/avatar/00/13/2b/7c/7bc030e6.jpg","comment_is_top":false,"comment_ctime":1605930788,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605930788","product_id":100017301,"comment_content":"完全不懂链表怎么逆序或者反转的原理，老师有没有比较好的文章推荐看看的","like_count":0},{"had_liked":false,"id":259279,"user_name":"Z7k","can_delete":false,"product_type":"c1","uid":1238680,"ip_address":"","ucode":"39373D7A6E6EE1","user_header":"https://static001.geekbang.org/account/avatar/00/12/e6/98/5853eb73.jpg","comment_is_top":false,"comment_ctime":1604669959,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604669959","product_id":100017301,"comment_content":"遍历链表，用数组记录下来，哈哈，然后用数组来判断。O(n)  ","like_count":0},{"had_liked":false,"id":259109,"user_name":"YUAN元","can_delete":false,"product_type":"c1","uid":2278571,"ip_address":"","ucode":"3E61E785BAA7AB","user_header":"https://static001.geekbang.org/account/avatar/00/22/c4/ab/49f21c62.jpg","comment_is_top":false,"comment_ctime":1604631802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604631802","product_id":100017301,"comment_content":"单链表的查询次数是 n, n-1,...,1，所以时间复杂度是O(n^2)，空间复杂度是O(n)。","like_count":0},{"had_liked":false,"id":258309,"user_name":"dyh_zero","can_delete":false,"product_type":"c1","uid":2052088,"ip_address":"","ucode":"98029D72597EF2","user_header":"","comment_is_top":false,"comment_ctime":1604379585,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604379585","product_id":100017301,"comment_content":"看了下老师的GitHub才理解了实现，惭愧","like_count":0},{"had_liked":false,"id":258258,"user_name":"klchang","can_delete":false,"product_type":"c1","uid":2281046,"ip_address":"","ucode":"792355B14607ED","user_header":"","comment_is_top":false,"comment_ctime":1604362646,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604362646","product_id":100017301,"comment_content":"如果字符串是通过单链表来存储的，回文的判断方法：复制链表并反转，遍历两个链表进行比较。时间复杂度和空间复杂度都是O(n)；或者新建为双向链表，使用两个指针，一个指针指向尾结点，使用前驱指针，另一个指针指向头结点，使用后继指针，依次比较，此时时间复杂度和空间复杂度均为O(n)","like_count":0},{"had_liked":false,"id":258256,"user_name":"klchang","can_delete":false,"product_type":"c1","uid":2281046,"ip_address":"","ucode":"792355B14607ED","user_header":"","comment_is_top":false,"comment_ctime":1604362278,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604362278","product_id":100017301,"comment_content":"用数组来实现 LRU 缓存淘汰策略：i为当前下标，指向最近访问数据。通过另一下标j=i开始，开始递减 j 访问下标为 j%n 数组元素，遍历数组，其中n为数组大小。当数据在缓存中存在，将此数据从数组中删除，将当前下标 i位置插入此数据；当数据在缓存中不存在，则直接在当前下标i+1位置插入数据，然后将i递增。","like_count":0},{"had_liked":false,"id":256002,"user_name":"许凯","can_delete":false,"product_type":"c1","uid":1604645,"ip_address":"","ucode":"4F11AD41CB0244","user_header":"https://static001.geekbang.org/account/avatar/00/18/7c/25/70134099.jpg","comment_is_top":false,"comment_ctime":1603503947,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1603503947","product_id":100017301,"comment_content":"链表中存储的元素，按理可以是不同数据类型的吧？","like_count":0},{"had_liked":false,"id":255410,"user_name":"郭丽娇","can_delete":false,"product_type":"c1","uid":2009233,"ip_address":"","ucode":"56A6F1A0089F48","user_header":"https://static001.geekbang.org/account/avatar/00/1e/a8/91/98741e31.jpg","comment_is_top":false,"comment_ctime":1603337968,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603337968","product_id":100017301,"comment_content":"我写的反转链表实现，<br>&#47;&#47;反转链表：实际上创建一个新的链表，新链表的顺序和原来链表相反\t&#47;&#47;思路：把旧链表节点一个个取下来，逆序放在新的链表上<br>\tstatic ListNode reverse(ListNode head) {\t    ListNode newNode = null;\t  <br>  ListNode cur = head;\t   <br> while (cur != null) {\t     <br>   ListNode newNext = cur.next;        <br>cur.next = newNode;&#47;&#47;第一次循环的时候，把第一个节点指向 pre=null；之后每次循环，把旧的节点一个个加在新的链表首节点上\t      <br>  newNode = cur;\t       <br> cur = newNext;\t   <br> }\t   <br> return newNode;\t}","like_count":0},{"had_liked":false,"id":251932,"user_name":"琳小呆","can_delete":false,"product_type":"c1","uid":2220269,"ip_address":"","ucode":"407A4CA6AD498A","user_header":"https://static001.geekbang.org/account/avatar/00/21/e0/ed/361c36ab.jpg","comment_is_top":false,"comment_ctime":1601983443,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601983443","product_id":100017301,"comment_content":"老师我想问一下，双向循环链表那里，我以为是前一个结点的next指向下一个结点的prev，但是在头结点和为结点那里它们都指向了data，我们这个具体应当指向什么呢？还是说不区分这个？","like_count":0},{"had_liked":false,"id":251787,"user_name":"LeonardRon","can_delete":false,"product_type":"c1","uid":1026808,"ip_address":"","ucode":"1B3ACC61DE1877","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/f8/4b89254e.jpg","comment_is_top":false,"comment_ctime":1601869547,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601869547","product_id":100017301,"comment_content":"关于文中“除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据”的描述，有点疑问：单链表不也可以记录上次查询的位置p，如果大于p，则往后查询；如果小于p，则从头查询？<br>","like_count":0},{"had_liked":false,"id":251749,"user_name":"朱润杰","can_delete":false,"product_type":"c1","uid":1738957,"ip_address":"","ucode":"6436C3D58D0FC3","user_header":"https://static001.geekbang.org/account/avatar/00/1a/88/cd/7ee7e9db.jpg","comment_is_top":false,"comment_ctime":1601823518,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601823518","product_id":100017301,"comment_content":"老师，您在讲解双向链表相对于单向链表删除指定节点时更有优势，复杂度可以是O(1)，但是我有个疑问。不管是双向还是单向链表，要删除某个节点n，首先都要遍历链表，直到某一节点m的next是n，显然我可以获得n的前一节点是m，双向联表相对于单向链表好像没有优势，不知道我这样理解对吗？","like_count":0},{"had_liked":false,"id":251338,"user_name":"奶油糖呢","can_delete":false,"product_type":"c1","uid":1657317,"ip_address":"","ucode":"D15BC9080E6081","user_header":"https://static001.geekbang.org/account/avatar/00/19/49/e5/47dfc54b.jpg","comment_is_top":false,"comment_ctime":1601470442,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601470442","product_id":100017301,"comment_content":"★ 回文字符串，python版<br>class ListNode:<br>    def __init__(self,x):<br>        self.val = x<br>        self.next = None<br>head = ListNode(&#39;A&#39;)<br>node1 = ListNode(&#39;B&#39;)<br>node2 = ListNode(&#39;C&#39;)<br>node3 = ListNode(&#39;C&#39;)<br>node4 = ListNode(&#39;B&#39;)<br>node5 = ListNode(&#39;A&#39;)<br>head.next = node1<br>node1.next = node2<br>node2.next = node3<br>node3.next = node4<br>node4.next = node5<br>node5.next = None<br><br>pre = None      # 新链表的头结点<br>slow = head     # 慢指针<br>fast = head     # 快指针<br>while fast != None and fast.next != None:    # fast为空或者fast.next为空<br>    fast = fast.next.next     # 快指针走两步<br>    temp = slow.next          # 存下慢指针的下一个结点<br>    slow.next = pre           # 慢指针指向新节点<br>    pre = slow<br>    slow = temp<br><br>if fast != None:             # 如果fast.next为空，慢节点要向后一个<br>    slow = slow.next<br><br>while slow:<br>    if slow.val != pre.val:      # 比较slow和pre两个链表的值<br>        print(slow.val,pre.val,False)<br>        break<br>    slow = slow.next<br>    pre = pre.next<br>print(True)","like_count":0},{"had_liked":false,"id":251273,"user_name":"willxiao","can_delete":false,"product_type":"c1","uid":1336715,"ip_address":"","ucode":"6E497DDA1A7286","user_header":"https://static001.geekbang.org/account/avatar/00/14/65/8b/e97e5d3d.jpg","comment_is_top":false,"comment_ctime":1601447430,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601447430","product_id":100017301,"comment_content":"“在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是 O(n)“ -- 这里是考虑到数组扩容吗？","like_count":0},{"had_liked":false,"id":251112,"user_name":"杨","can_delete":false,"product_type":"c1","uid":1971269,"ip_address":"","ucode":"7EFEFE285975C6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/oltLEqTrmHm2aJP99BK6tHu5h7hp4aj08wR5Wt6H31iadFduDAVvjYKmhQ2nvGbLV3lkVdiat2GRasgWXoJeTibUg/132","comment_is_top":false,"comment_ctime":1601367484,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601367484","product_id":100017301,"comment_content":"（使用快慢两个指针找到链表中点，慢指针每次前进一步，快指针每次前进两步。在慢指针前进的过程中，同时修改其 next 指针，使得链表前半部分反序。最后比较中点两侧的链表是否相等。）  每个链表指针地址都不同 不可能相等  应该还需要遍历一遍吧   无法直接在那条评论下评论  只能复制过来了","like_count":0},{"had_liked":false,"id":249640,"user_name":"绝影","can_delete":false,"product_type":"c1","uid":1437760,"ip_address":"","ucode":"EA3C85D21DE210","user_header":"https://static001.geekbang.org/account/avatar/00/15/f0/40/219be32a.jpg","comment_is_top":false,"comment_ctime":1600737821,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600737821","product_id":100017301,"comment_content":"基于链表实现LRU时间复杂度分析<br>1.最好时间复杂度：当查找的缓存存在于链表中的第一个位置，不用做任何操作，时间复杂度为O(1)<br>2.最坏时间复杂度：查找的缓存不存在与链表中或者存在于链表尾，时间复杂度O(N)<br>3.平均时间复杂度：<br>1）查找的缓存存在于链表和不存在于链表的概率都为1&#47;2<br>2）如果不存在链表中要循环n+1次得到不存在链表中这个结论<br>3）如果存在于链表中，那么就有存在于n个位置的哪一个，每个位置出现的概率相同都为1&#47;n<br>4)所以存在于链表中在每个位置出现的概率为(1&#47;2)*(1&#47;n)<br>1&#47;2n*(1+2+3+....+n)+1&#47;2*(n+1)=（1+n）&#47;4+(n+1)&#47;2=(3+3n)&#47;4<br>所以平均时间复杂度为O(N)","like_count":0},{"had_liked":false,"id":249373,"user_name":"Belizer","can_delete":false,"product_type":"c1","uid":2175243,"ip_address":"","ucode":"17DA133DC0BDDF","user_header":"https://static001.geekbang.org/account/avatar/00/21/31/0b/91f317a0.jpg","comment_is_top":false,"comment_ctime":1600613396,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600613396","product_id":100017301,"comment_content":"你们好，我对单向链表插入和删除的那个例子有疑问，从图中可以看出，插入是在b后面插入，删除是删除数据b，那么插入和删除我是不是都需要找到b？","like_count":0},{"had_liked":false,"id":249303,"user_name":"大力","can_delete":false,"product_type":"c1","uid":1364353,"ip_address":"","ucode":"1B2125C519443D","user_header":"https://static001.geekbang.org/account/avatar/00/14/d1/81/89ba9d81.jpg","comment_is_top":false,"comment_ctime":1600581122,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600581122","product_id":100017301,"comment_content":"--- 如何利用数组实现 LRU 缓存淘汰策略呢？<br>通过队列实现。<br>被访问数据按时间顺序被插入队列中。<br>有新数据需要被访问时，从队列头开始遍历。<br>1.假如该数据在队列中：<br>将该数据从队列原位置清除，并从队列头插入该元素；<br>2.假如该数据不在队列中：<br>（1）队列未满：<br>将新数据插入队列头；<br>（2）队列已满：<br>将队列最末元素移除，将新数据插入队列头。<br><br>---如果字符串是通过单链表来存储的，那该如何来判断是一个回文串呢？<br>你有什么好的解决思路呢？<br>相应的时间空间复杂度又是多少呢？<br>1.新建一数组，长度为原单链表的一半（取整，Math.floor()）；<br>2.从链表头开始遍历链表，每读取一个元素就复制到数组中；<br>3.当数组填满后，设此时链表索引为 n；若链表长度为奇数，则链表索引直接+1；<br>4.此后链表每读取一个新元素A，数组都会从末端弹出一个元素B，A 与 B 相比较；若每次比较 A 与 B 均相等，则此字符串为回文串，否则不是。<br><br>时间复杂度：<br>需要遍历一编字符串，因此为 O(n)。","like_count":0},{"had_liked":false,"id":247481,"user_name":"R","can_delete":false,"product_type":"c1","uid":2172520,"ip_address":"","ucode":"3721FC8C8DE174","user_header":"https://static001.geekbang.org/account/avatar/00/21/26/68/b86dc4df.jpg","comment_is_top":false,"comment_ctime":1599719928,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1599719928","product_id":100017301,"comment_content":"请老师帮我看看完整C语言代码：<br>https:&#47;&#47;github.com&#47;RingoTangs&#47;LearningNote&#47;blob&#47;master&#47;c-language&#47;C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.md#143%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87<br><br>&#47;**<br>* 判断是否是回文<br>*<br>* 定义指针p指向双向链表的head, 指针q指向双向链表的tail。<br>* 判断回文，只需要将p向后移,q向前移即可，并判断p和q对应字符是否相等。<br>*<br>* 当链表结点数为奇数时,while循环的条件时p != q; <br>* 当链表结点数为偶数时,do-while循环的条件为 q-&gt;next != q; <br>*&#47;<br>int isPalindrome(DouLinkedList* list) {<br>\tNode* p = list-&gt;head;<br>\tNode* q = list-&gt;tail;<br><br>\tint flag = 1;         &#47;&#47; 1是回文数 0不是回文数<br><br>\tif(list-&gt;size % 2 ) {<br>\t\t&#47;&#47; 结点是奇数<br>\t\twhile(p != q) {<br>\t\t\tif(p-&gt;ch != q-&gt;ch) {<br>\t\t\t\t&#47;&#47; 不是回文数<br>\t\t\t\tflag = 0;<br>\t\t\t\tbreak;<br>\t\t\t}<br>\t\t\tp = p-&gt;next;<br>\t\t\tq = q-&gt;prev;<br>\t\t}<br>\t} else {<br>\t\t&#47;&#47; 结点是偶数<br>\t\tdo {<br>\t\t\tif(p-&gt;ch != q-&gt;ch) {<br>\t\t\t\t&#47;&#47; 不是回文数<br>\t\t\t\tflag = 0;<br>\t\t\t\tbreak;<br>\t\t\t}<br>\t\t\tp = p-&gt;next;<br>\t\t\tq = q-&gt;prev;<br>\t\t} while(q-&gt;next != p);<br>\t}<br><br>\treturn flag;<br>}","like_count":0},{"had_liked":false,"id":247037,"user_name":"WilliamVector","can_delete":false,"product_type":"c1","uid":1898112,"ip_address":"","ucode":"E0D3C3D4FCB7C9","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f6/80/85ec2c2a.jpg","comment_is_top":false,"comment_ctime":1599566089,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599566089","product_id":100017301,"comment_content":"【要点】<br>1、什么是列表：链表通过指针将一组零散的内存块串联在一起。这些零散的内存块称为链表的“结点”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。我们把这个记录下个结点地址的指针叫作后继指针 next。<br>2、列表的特点：插入、删除数据效率为O(1)，元素查询效率为O(n)。和数组相比消耗的存储空间更大，因为每个节点都需要额外的空间存储下一个指向节点的指针。<br>3、常用的链表结构：单链表、双向列表、循环列表。其中，单链表的节点只包含一个后继指针，双向链表的节点包含一个后继指针和一个前驱指针，循环列表的尾节点不指向NULL，而是指向头结点。双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。<br>【思考】<br>验证单项列表是否是回文的方法：<br>1、快慢指针+列表翻转：<br>(1)快指针走两步，慢指针走一步，慢指针走的过程中翻转列表的前半部分，当快指针到达结尾，记录中心位置。<br>(2)中心位置需要区分奇偶，判断依据为，如果快指针可走两步到达末尾则为奇数，否则为偶数。<br>(3)慢指针继续向前遍历，快指针改为记录中心点，向前遍历。对比快慢指针的值。<br>2、快慢指针+栈：<br>(1)开辟一个栈。快慢指针遍历过程中，到达中心点前，将慢指针遍历的节点值做压栈处理。<br>(2)快指针达到末尾后，慢指针继续前进，栈内元素依次出栈，与慢指针遍历的节点值对比。","like_count":0},{"had_liked":false,"id":245384,"user_name":"王世林","can_delete":false,"product_type":"c1","uid":1076155,"ip_address":"","ucode":"2BB56D0FD71417","user_header":"https://static001.geekbang.org/account/avatar/00/10/6b/bb/10aaf123.jpg","comment_is_top":false,"comment_ctime":1598929065,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598929065","product_id":100017301,"comment_content":"根据快慢指针，判断快指针的下个节点或者下个节点的下个节点是否为空，进而判断中间节点，进而比较是否是回文字符串","like_count":0},{"had_liked":false,"id":244004,"user_name":"剑影梦残","can_delete":false,"product_type":"c1","uid":1284481,"ip_address":"","ucode":"A5C5DAA49F6996","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/XSnxM4uP67mVu7ZtPxWqUIvFH15pibGt1rFd34EiblN6NFfgKEKBuibLlI1kUjOIfbY56icwBibn6MmXzSEXm7AHicdQ/132","comment_is_top":false,"comment_ctime":1598349547,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598349547","product_id":100017301,"comment_content":"lru使用链表会比较友好，数组中插入头部会导致后面数据后移。回文：1.快慢指针定位中间点，注意长度是单双的情况。2.在慢指针的时候可以把next反转，到时候从头指针和中间指针开始进行比较  时间复杂度O(n)","like_count":0},{"had_liked":false,"id":242524,"user_name":"Geek_d08884","can_delete":false,"product_type":"c1","uid":2097818,"ip_address":"","ucode":"E4A24C746B6F21","user_header":"","comment_is_top":false,"comment_ctime":1597751200,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597751200","product_id":100017301,"comment_content":"&#47;*<br>实现LRU<br>*&#47;<br>func (this *MyLinkedList) Lru(v, len int) {<br>    pre := this.head<br>    cur := pre.next<br>    <br>    for cur.next != nil {<br>        next := cur.next<br>        if cur.val == v {<br>            break<br>        }<br>        pre = cur<br>        cur = next<br>        <br>    }<br>    &#47;*1、如果数据之前已存在于链表中，则删除原位置结点，然后再插入到头结点<br>      2、如果此数据没有在链表中，则分为两部分：<br>      （1）如果链表未满，则将结点插入链表头部<br>      （2）如果链表已满，则删除尾结点，将新结点插入头部<br>    *&#47;<br>    if cur.val == v {<br>        pre.next = pre.next.next &#47;&#47;删除原位置结点<br>        this.length--<br>        newNode := NewLinkNode(v)<br>        newNode.next = this.head.next  &#47;&#47;插入到头结点<br>        this.head.next = newNode<br>        this.length++<br>    } else {<br>        if this.length == len {  &#47;&#47;链表已满<br>            pre.next = pre.next.next &#47;&#47;删除尾结点<br>            this.length--<br>            newNode := NewLinkNode(v)<br>            newNode.next = this.head.next &#47;&#47;插入到头结点<br>            this.head.next = newNode<br>            this.length++<br>        } else {                 &#47;&#47;链表未满<br>            newNode := NewLinkNode(v)<br>            newNode.next = this.head.next<br>            this.head.next = newNode<br>            this.length++<br>        }<br>    }<br><br>}<br><br>func Test(t *testing.T) {<br>    l := Constructor()<br>    l.AddAtIndex(0,1)<br>    l.AddAtIndex(0,2)<br>    l.AddAtIndex(0,3)<br>    l.AddAtIndex(0,4)<br>    l.Lru(6, 5)<br>    t.Log(l.Get(0))<br>    t.Log(l.Get(1))<br>    t.Log(l.Get(4))<br><br><br>}<br><br><br>=== RUN   Test<br>--- PASS: Test (0.00s)<br>        linklist_test.go:13: 6<br>        linklist_test.go:14: 4<br>        linklist_test.go:15: 1<br>PASS<br>ok      _&#47;data&#47;code&#47;linklist    0.003s","like_count":0},{"had_liked":false,"id":240750,"user_name":"李和桃","can_delete":false,"product_type":"c1","uid":1015877,"ip_address":"","ucode":"97E66953070EE0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/45/d719f7df.jpg","comment_is_top":false,"comment_ctime":1597052468,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597052468","product_id":100017301,"comment_content":"1、如何使用数组实现LRU。<br>使用数组实现LRU，主要是考虑到数组的插入和删除的操作，在插入的时候，需要插入数据到头部，相应的其他数据向后迁移1位，可能会涉及到扩容，时间复杂度为O(n)。删除的时候，将数组末尾的数据删除即可，时间复杂度为O(1).查询的话，时间复杂度为O(n)。<br>2、判断字符串是否是回文。<br>我想到是用deque的方式，先把数据入队，然后分别对两头的值进行弹出判断是否相等，如果不相等，则提前结束判断，如果相等则继续弹出判断。直到最后deque是空的或者只剩下一个元素。时间复杂度为O（n），空间复杂度为O(n)","like_count":0},{"had_liked":false,"id":240343,"user_name":"Mr.wang","can_delete":false,"product_type":"c1","uid":1758718,"ip_address":"","ucode":"68909DB2B0449C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTINZD6FrxFcwlmbg8q3fV8ic0VcUqYoxcFtEMDwegUJEWGHGKla5KYkUjkVoaicjFNgUmZEHYuYohvA/132","comment_is_top":false,"comment_ctime":1596871478,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596871478","product_id":100017301,"comment_content":"“我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。”这句话有点不理解，为什么链表尾部的节点是越早之前访问的呢？","like_count":0},{"had_liked":false,"id":238845,"user_name":"Geek_6bdfc8","can_delete":false,"product_type":"c1","uid":2054527,"ip_address":"","ucode":"9940EB559AF505","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/bFaldpeHffSdNTtgib3bDaa3dq1ibJQrqon9ION1AKZSSGZphG2gUNCrSroq0SgxEB7nTYNcJDVG97luoNL0ZAzg/132","comment_is_top":false,"comment_ctime":1596341852,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596341852","product_id":100017301,"comment_content":"public boolean huiwen(){ &#47;&#47;O(3n)<br>        &#47;&#47; 先让一个结点指向原head<br>        Node&lt;T&gt; org=head;<br>        &#47;&#47; 反转<br>        reverse(); &#47;&#47;O(n)<br>        &#47;&#47; 再让一个结点指向新的head<br>        Node&lt;T&gt; now=head;<br>        &#47;&#47; 再进行判断<br>        while (org!=null){  &#47;&#47;O(2n)<br>            if(org.value!=now.value) { &#47;&#47;这条语句执行一次<br>                &#47;&#47;不是回文要反转<br>                reverse(); &#47;&#47; O(n)<br>                return false;<br>            }<br>            now=now.next;<br>            org=org.next;<br>        }<br>        return true;&#47;&#47; 全部比较完毕<br><br>    }","like_count":0},{"had_liked":false,"id":238728,"user_name":"一格状语","can_delete":false,"product_type":"c1","uid":1622696,"ip_address":"","ucode":"EBA9ED5F97416D","user_header":"https://static001.geekbang.org/account/avatar/00/18/c2/a8/f3f8f5d2.jpg","comment_is_top":false,"comment_ctime":1596274367,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596274367","product_id":100017301,"comment_content":"（有序双向链表，按照节点值查询，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找。）<br>老师我这段逻辑没懂，这里说的比较值与p的大小关系，值是位置吗？😅","like_count":0},{"had_liked":false,"id":238583,"user_name":"talor","can_delete":false,"product_type":"c1","uid":1350638,"ip_address":"","ucode":"245EE908DA39EC","user_header":"https://static001.geekbang.org/account/avatar/00/14/9b/ee/211e86cd.jpg","comment_is_top":false,"comment_ctime":1596204137,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596204137","product_id":100017301,"comment_content":"直接上代码:<br>1 #include &lt;iostream&gt;<br>  2 #include &lt;list&gt;<br>  3        <br>  4 bool is_huiwen(const std::list&lt;char&gt;&amp; txt)<br>  5 {<br>  6         std::list&lt;char&gt;::const_iterator fd, bk;<br>  7         fd = txt.begin();<br>  8         bk = txt.end();<br>  9         --bk;<br> 10         for(; bk!=fd; ++fd, --bk) {<br> 11                 if(*fd != *bk)<br> 12                         return false;<br> 13         }<br> 14         return true;<br> 15 }<br> 16 <br> 17 int main()<br> 18 {<br> 19         std::list&lt;char&gt; text {&#39;h&#39;, &#39;i&#39;, &#39;x&#39;, &#39;i&#39;, &#39;h&#39;};<br> 20         std::list&lt;char&gt; text1 {&#39;h&#39;, &#39;i&#39;, &#39;x&#39;, &#39;p&#39;, &#39;h&#39;};<br> 21 <br> 22         if(is_huiwen(text))<br> 23                 std::cout &lt;&lt; &quot;yes&quot; &lt;&lt; std::endl;<br> 24         else<br> 25                 std::cout &lt;&lt; &quot;no&quot; &lt;&lt; std::endl;<br> 26 <br> 27         if(is_huiwen(text1))<br> 28                 std::cout &lt;&lt; &quot;yes&quot; &lt;&lt; std::endl;<br> 29         else<br> 30                 std::cout &lt;&lt; &quot;no&quot; &lt;&lt; std::endl;<br> 31 <br> 32         return 0;<br> 33 }","like_count":0},{"had_liked":false,"id":238561,"user_name":"SandCarving","can_delete":false,"product_type":"c1","uid":2056201,"ip_address":"","ucode":"6B97DB71613A46","user_header":"https://static001.geekbang.org/account/avatar/00/1f/60/09/a8e7913b.jpg","comment_is_top":false,"comment_ctime":1596198682,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596198682","product_id":100017301,"comment_content":"链表较之于数组有着很大的优点，就是数据的存储不用局限在连续的存储空间，虽然会付出一点空间代价，但你想想，假如内存里的空间碎片又小又多，无法满足一次性申请一个大块的内存时，链表就有了用武之地。<br>链表可分为单链表、循环链表、双链表，其实在操作链表上面，也有很大的讲究，有带头节点的链表，也有没带头节点的链表，它们的区别就是带头节点的链表能够使用空间来换取操作链表上的一些便利，在操作上有分头插法和尾插法，具体用哪个就要看怎么去操作链表。<br>关于回文数，如果使用不同的链表还会有不同的效果，在这里，有一个比较好的方法，就是使用带尾指针的双向链表，只需遍历n&#47;2，每次判断头指针指向的是否和尾指针指向的相等就行了。","like_count":0},{"had_liked":false,"id":238507,"user_name":"朱雯","can_delete":false,"product_type":"c1","uid":1035744,"ip_address":"","ucode":"064C45FBF6B51F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cd/e0/c85bb948.jpg","comment_is_top":false,"comment_ctime":1596185746,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1596185746","product_id":100017301,"comment_content":"老师我一直被一个很蠢的问题所干扰，那就是<br>```<br>typedef struct Node{<br>    int data;<br>    struct Node * next;<br>} Node;<br>```<br>我无论如何都理解不了这三行代码，为什么node类型的数据，他还没声明完成，在他的内部就可以使用指向node类型的指针了呢。","like_count":0,"discussions":[{"author":{"id":2312214,"avatar":"https://static001.geekbang.org/account/avatar/00/23/48/16/df9b9f53.jpg","nickname":"纳兰小狐獴","note":"","ucode":"882182192B89FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324692,"discussion_content":"这个涉及编译器问题了 可能是先记下要创建什么类型的数据 然后再去考虑这个类型的数据怎么实现 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605153198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237098,"user_name":"朱雯","can_delete":false,"product_type":"c1","uid":1035744,"ip_address":"","ucode":"064C45FBF6B51F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cd/e0/c85bb948.jpg","comment_is_top":false,"comment_ctime":1595675456,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1595675456","product_id":100017301,"comment_content":"看了一下链表的相关内容，有个疑惑点，那就是链表到底有啥用呢。文章中提到两点：1.lru缓存淘汰算法，2 面试的时候使用。其他有比较用的多的点吗","like_count":0},{"had_liked":false,"id":236944,"user_name":"Geek_6725b5","can_delete":false,"product_type":"c1","uid":1991426,"ip_address":"","ucode":"379B3DDD67B774","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/JuoHr2r7lA9Sh7Phmrw86JVObha0hKsSYraibvicmVHdYe4UibB3htibR3IqdXGbzHYGicViblSseqdzG2hrSMD1OewA/132","comment_is_top":false,"comment_ctime":1595598372,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1595598372","product_id":100017301,"comment_content":"LRU缓存淘汰算法用清除多余的书来比喻非常贴切。<br>在算法中，时间换空间，空间换时间是设计的一个核心概念。<br>链表和数组的应用中，数组连续性保存更符合CPU的工作原理，链表不连续保存更容易在内存琐碎的应用场景使用。但是数组可能存在超过需要申请空间复制的情况，链表可能存在不停释放回收的情况。","like_count":0},{"had_liked":false,"id":236726,"user_name":"Xin","can_delete":false,"product_type":"c1","uid":2079030,"ip_address":"","ucode":"391272604AEDF7","user_header":"https://static001.geekbang.org/account/avatar/00/1f/b9/36/a83eefe2.jpg","comment_is_top":false,"comment_ctime":1595511974,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595511974","product_id":100017301,"comment_content":"快慢指针法确定中点，若快指针刚好指到尾节点的情况，为奇数，慢指针指向中间节点；快指针指向NULL的情况，为偶数，慢指针指向后半段链表的头节点。然后逆序其中一段，遍历比较。<br>简单的做法：先遍历一遍计数，直接确定中点。然后根据奇偶数截断，逆序其中一段，最后比较。<br>两种方法具有相同的时间复杂度。","like_count":0},{"had_liked":false,"id":235327,"user_name":"莫失莫忘","can_delete":false,"product_type":"c1","uid":2062645,"ip_address":"","ucode":"F5E101EF08FA4C","user_header":"https://static001.geekbang.org/account/avatar/00/1f/79/35/aa73b295.jpg","comment_is_top":false,"comment_ctime":1594976041,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594976041","product_id":100017301,"comment_content":"https:&#47;&#47;blog.csdn.net&#47;Freedom_cao&#47;article&#47;details&#47;107408721<br>","like_count":0},{"had_liked":false,"id":235168,"user_name":"asia","can_delete":false,"product_type":"c1","uid":1344529,"ip_address":"","ucode":"1876DD836EFCE3","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI85Y2Va9sKp8bOCCsjK7ABt6H6qzxunXk2zUJpdrOgoXergdAGfibEVoqKs0Zz8RicxmQyQiaRcx5nA/132","comment_is_top":false,"comment_ctime":1594912364,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594912364","product_id":100017301,"comment_content":"“对于第二种情况，我们已经找到了要删除的结点，但是删除某个结点 q 需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，我们还是要从头结点开始遍历链表，直到 p-&gt;next=q，说明 p 是 q 的前驱结点。” <br>争哥，对于这个情况，单链表应该遍历到要删除节点的前一个节点。这样单链表的删除也是O(1)的时间复杂度了。","like_count":0},{"had_liked":false,"id":234877,"user_name":"Geek_92b89e","can_delete":false,"product_type":"c1","uid":2061044,"ip_address":"","ucode":"6ECC4DC862DEAF","user_header":"","comment_is_top":false,"comment_ctime":1594816963,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594816963","product_id":100017301,"comment_content":"数组实现LRU：<br>1、申请一块固定大小地址，并初始化<br>2、当一个新的访问数据来临时，遍历数组：<br>（1）在数组中：把该值提到最靠前的，并移动初始数据与原来位置之间的数<br>（2）不在数组中：<br>（（1））数组已满：删除最后一个，并全部移动，该数据放在第一个数组位置中<br>（（2））数组未满：放在初始前一个位置上<br>时间复杂度：O(n)<br><br>回文字符串判断：<br>遍历一遍，然后取逆<br>时间：O(n)<br>空间：O(n)","like_count":0},{"had_liked":false,"id":234788,"user_name":"dayday","can_delete":false,"product_type":"c1","uid":1478294,"ip_address":"","ucode":"960C08A6618FE2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/glMH9jUOFS96sukOzshKWgYbZNxOB39RCemvsZ9ziciaWhJIN2GbziavvCR3rthicicGVf9AU5yoH1hrV6rVqE1swLA/132","comment_is_top":false,"comment_ctime":1594795813,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594795813","product_id":100017301,"comment_content":"2个指针一起扫","like_count":0},{"had_liked":false,"id":234402,"user_name":"醉梦了红尘","can_delete":false,"product_type":"c1","uid":1889141,"ip_address":"","ucode":"DB742865BAD6B6","user_header":"","comment_is_top":false,"comment_ctime":1594686530,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594686530","product_id":100017301,"comment_content":"数组是一段连续的存储空间符合空间局部性，所以缓存的命中更高，但是对内存设备的要求高，链表对内存设备要求不高，空间局部性差容易产生内存碎片。数组长度本身无法做到动态扩容，只能够重新定义更长数组进行数据拷贝，链表可以无限制扩展。<br>按照节点数据检索数组和链表的时间复杂度都是o(n)。数组内存地址是连续的，链表内存地址是散列的，在定义数组可以拿到数组首地址，通过数组索引可以推算节点指针时间复杂度o(1),链表只有相邻节点才记录指针，且地址散列所以无法推算复杂度为o(n)<br>数组指定索引节点删除涉及到内存指针偏移保证内存连续时间复杂o(n),链表删除指针确定的节点时间复杂度o(1)","like_count":0},{"had_liked":false,"id":234054,"user_name":"Merry","can_delete":false,"product_type":"c1","uid":1024036,"ip_address":"","ucode":"E2A114E10814BA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a0/24/68c679c8.jpg","comment_is_top":false,"comment_ctime":1594566667,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594566667","product_id":100017301,"comment_content":"课后思考：<br>1.申请一个栈，int i=0<br>2.i小于n&#47;2&#47;时，顺序访问单链表中节点且将节点的值存入栈中<br>3.判断n的奇偶性，若为偶数则执行- -i<br>4.此时从i处继续依次访问单链表节点，但在循环中进行出栈操作，且判断出栈元素与链表节点进行比较，若相等，循环继续，否则退出循环，输出结果为非回文字符串","like_count":0},{"had_liked":false,"id":233500,"user_name":"Geek_6a1f2b","can_delete":false,"product_type":"c1","uid":1809511,"ip_address":"","ucode":"F20CA0DDFAE911","user_header":"https://static001.geekbang.org/account/avatar/00/1b/9c/67/ca896c09.jpg","comment_is_top":false,"comment_ctime":1594344167,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594344167","product_id":100017301,"comment_content":"问个小白问题:双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点。这个为啥不是O(n)复杂度啊，不也得遍历一遍链表么","like_count":0},{"had_liked":false,"id":231810,"user_name":"航","can_delete":false,"product_type":"c1","uid":2050135,"ip_address":"","ucode":"FFAE304D6D4AD6","user_header":"https://static001.geekbang.org/account/avatar/00/1f/48/57/f81acea8.jpg","comment_is_top":false,"comment_ctime":1593774241,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593774241","product_id":100017301,"comment_content":"如果是回文的话，确实双链表会比单链表好实现很多。双链表的话可。我们遍历到双链表中间的节点nodemiddle，然后看看nodemiddle-&gt;pre是否等于nodemiddle-&gt;next就好。整个运行只要复杂度O（n）<br><br>但如果是单链表的话，找到nodemiddle之后，因为每次都要重新遍历一次才能找到node middle的前一个，所以运用乘法原理，O（n*n）,那么应该是要O（n平方的复杂度）","like_count":0},{"had_liked":false,"id":231800,"user_name":"航","can_delete":false,"product_type":"c1","uid":2050135,"ip_address":"","ucode":"FFAE304D6D4AD6","user_header":"https://static001.geekbang.org/account/avatar/00/1f/48/57/f81acea8.jpg","comment_is_top":false,"comment_ctime":1593772857,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593772857","product_id":100017301,"comment_content":"用数组的话可以像链表一样吗？于是就也是根据下标找到遍历一遍，如果找到对应的缓存（这里的复杂度为O（n）（如果是根据下标能找到的话那就O（1））），然后插入咯（O（n））<br><br>如果找不到，那就插入新的，删掉最后的 （这样也是两个O（n））的复杂度。<br><br>总之要花费寻找和插入都要两个O（n）的复杂度（不用回复了，我看看下面的答案嘻嘻）","like_count":0},{"had_liked":false,"id":231564,"user_name":"马海东","can_delete":false,"product_type":"c1","uid":1853238,"ip_address":"","ucode":"EA46828BF61038","user_header":"https://static001.geekbang.org/account/avatar/00/1c/47/36/57f69b44.jpg","comment_is_top":false,"comment_ctime":1593708193,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593708193","product_id":100017301,"comment_content":"刚接触算法还看不太懂评论区给的案例，小白开始注重算法了","like_count":0},{"had_liked":false,"id":231550,"user_name":"荣北","can_delete":false,"product_type":"c1","uid":1288871,"ip_address":"","ucode":"E3CF718D8F2A74","user_header":"https://static001.geekbang.org/account/avatar/00/13/aa/a7/2c4a5a37.jpg","comment_is_top":false,"comment_ctime":1593703915,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593703915","product_id":100017301,"comment_content":"约瑟夫环在什么场景下会使用到呢？","like_count":0},{"had_liked":false,"id":231528,"user_name":"Sheamus","can_delete":false,"product_type":"c1","uid":1248510,"ip_address":"","ucode":"F6EBDFF3575ADA","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/fe/4a1f045e.jpg","comment_is_top":false,"comment_ctime":1593699997,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593699997","product_id":100017301,"comment_content":"1、判断奇偶取一半长度；<br>2、遍历单项链表元素储存到hashmap中；key 链表值，value是下标，只保存上面记录的一半元素<br>3、 继续遍历后面元素，get方法得到索引，将索引取模判断是否相等<br>空间复杂度 o(n) ，时间复杂度o(n)","like_count":0},{"had_liked":false,"id":231449,"user_name":"绿罗裙 ","can_delete":false,"product_type":"c1","uid":1718097,"ip_address":"","ucode":"DB3BBD5B11C85E","user_header":"https://static001.geekbang.org/account/avatar/00/1a/37/51/21e0e7ec.jpg","comment_is_top":false,"comment_ctime":1593679077,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593679077","product_id":100017301,"comment_content":"遍历一次链表得到链表个数，然后分配一块连续空间存链表数据，分别从头尾访问 往中间靠近，比较数据是否一样","like_count":0},{"had_liked":false,"id":231371,"user_name":"LostGeneration","can_delete":false,"product_type":"c1","uid":1700504,"ip_address":"","ucode":"3DC1536ACCE985","user_header":"https://static001.geekbang.org/account/avatar/00/19/f2/98/150f51db.jpg","comment_is_top":false,"comment_ctime":1593658694,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593658694","product_id":100017301,"comment_content":"判断回文字符串的问题，结合实际情况来说。C&#47;C++可以通过指针（链表）的方式来做。但是在Java中String的底层实际是char数组。Java中两个char表示一个Unicode码，所以在Java中一般情况下可以找到字符串数组的中位数来对比判断。时间复杂度为O（n）空间复杂度为0（不需要申请新的内存）","like_count":0},{"had_liked":false,"id":231232,"user_name":"李孟","can_delete":false,"product_type":"c1","uid":1006768,"ip_address":"","ucode":"AD2349CB12F130","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/b0/77e5f8c8.jpg","comment_is_top":false,"comment_ctime":1593612215,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1593612215","product_id":100017301,"comment_content":"单链表回文<br> public boolean isPalindrome(){<br>        Link tmp1 = first;<br>        int n = count&#47;2;<br>        int i=0;<br><br>        Link tmp2 = null;<br>        while (i &lt; n){<br>            tmp1 = tmp1.getNext();<br>            i++;<br>        }<br>        tmp2 = tmp1.getNext();<br><br>        Link cur = tmp2.getNext();<br>        Link tmp ;<br>        while (cur !=null){<br>            tmp = cur.getNext();<br>            cur.setNext(tmp2);<br>            &#47;&#47;反向指针<br>            tmp2 = cur;<br>            cur = tmp;<br>        }<br><br>        i=0;<br>        tmp1 = first;<br>        boolean result = true;<br>        while (i &lt; n){<br>            if(tmp2 == null) break;<br><br>            if(!tmp1.getData().equals(tmp2.getData())) {<br>                result = false;<br>            }<br>            tmp1 = tmp1.getNext();<br>            tmp2 = tmp2.getNext();<br><br>            i++;<br>        }<br>        return result;<br>    }","like_count":0},{"had_liked":false,"id":231120,"user_name":"憎爱不关心","can_delete":false,"product_type":"c1","uid":1133580,"ip_address":"","ucode":"A868ACB200C798","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/0c/ada45f25.jpg","comment_is_top":false,"comment_ctime":1593588623,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593588623","product_id":100017301,"comment_content":"1.没看评论之前，先遍历得到链表长度，时间复杂度为O（n)，然后循环遍历每一个节点与倒数的节点比较，每次的时间复杂度为O(n)，，总复杂度为O(n2)，空间复杂度因为没有分配新空间，为O(1)<br>2.好的算法还不会，快慢指针法","like_count":0},{"had_liked":false,"id":230976,"user_name":"jack","can_delete":false,"product_type":"c1","uid":1898292,"ip_address":"","ucode":"A2253AC8570C5E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/jibauP3icEFic4w56L2ddVghL7h2gGKhFdW8lBfE9rpwwRgzUKkLFY9wb4w70AXz7retME96a6EBRTA0LvSLn0ib8A/132","comment_is_top":false,"comment_ctime":1593538281,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1593538281","product_id":100017301,"comment_content":"利用数组实现LRU算法：<br>1.如果数组中存在该元素，找出该元素的并放置于数组首部，把首部到该元素原来位置之间的元素均向后移动一个位置；<br>2.如果数组中不存在该元素：当数组未满，就把原来数组中的元素均向后移动一个位置，用该元素替换数组首部的元素；当数组已满，就把该元素的最后一个元素删除，再把剩下的元素向后移动一个位置，用该元素替换数组首部的元素。<br>平均时间复杂度：O(n)<br>平均空间复杂度：O(1)<br><br>利用单链表存储字符串并判断其是否属于“回文字符串”？<br>1.利用快慢指针：首先两个指针均定位于链表头部，快指针走两步，慢指针走一步；<br>2.当快指针走到链表尾部，慢指针正好在链表中部，此时将链表后半部分倒序，再与链表前半部分的元素一一比较；<br>3.如果链表前后部分均相同，则为回文字符串，否则不是。<br>时间复杂度：O(n)<br>空间复杂度：O(1)<br>","like_count":0},{"had_liked":false,"id":230153,"user_name":"罗樱罂","can_delete":false,"product_type":"c1","uid":2045997,"ip_address":"","ucode":"9072E79E625ED1","user_header":"https://static001.geekbang.org/account/avatar/00/1f/38/2d/f3c6493e.jpg","comment_is_top":false,"comment_ctime":1593284905,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593284905","product_id":100017301,"comment_content":"单链表删除操作需要 O(n) 的时间复杂度 -&gt; leetcode 上不是有一道题可以O(1)删除吗？直接让当前要删除的节点val等于下一个node的value，并且让next指向下一个节点的下一个节点的地址？","like_count":0},{"had_liked":false,"id":230061,"user_name":"性林的木木","can_delete":false,"product_type":"c1","uid":2048047,"ip_address":"","ucode":"BFB36D0B8BF66E","user_header":"https://static001.geekbang.org/account/avatar/00/1f/40/2f/574f8de5.jpg","comment_is_top":false,"comment_ctime":1593248859,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593248859","product_id":100017301,"comment_content":"利用数组和单向循环链表进行缓存数据淘汰处理:数组存放数据，链表记录每个数据的使用量，从大到小排布，每次操作更新使用量大小。在遍寻数据时，先根据链表查找对应的存放在数组的数据，时间复杂度为n。若内存不够，直接将链表最后一位更新即可，并更新对应的数组的值。<br>此算法结合两种数据结构","like_count":0},{"had_liked":false,"id":230009,"user_name":"fsdkf","can_delete":false,"product_type":"c1","uid":1826822,"ip_address":"","ucode":"2A55AD53FAEE71","user_header":"","comment_is_top":false,"comment_ctime":1593241115,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593241115","product_id":100017301,"comment_content":"课后思考：<br>反转链表，然后一一比较，能走到最后一个节点即为回文串，反之亦然，时间复杂度和空间复杂度均为O(n)","like_count":0},{"had_liked":false,"id":229858,"user_name":"Ray","can_delete":false,"product_type":"c1","uid":2046685,"ip_address":"","ucode":"37E86CE67F004B","user_header":"https://static001.geekbang.org/account/avatar/00/1f/3a/dd/e44bacb8.jpg","comment_is_top":false,"comment_ctime":1593165693,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593165693","product_id":100017301,"comment_content":"因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。<br>这个是什么意思？又没排序，怎么知道的？？？","like_count":0},{"had_liked":false,"id":228589,"user_name":"耿耿","can_delete":false,"product_type":"c1","uid":1817461,"ip_address":"","ucode":"37084BB64BAA94","user_header":"https://static001.geekbang.org/account/avatar/00/1b/bb/75/a62eca9b.jpg","comment_is_top":false,"comment_ctime":1592745262,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592745262","product_id":100017301,"comment_content":"老师讲的太棒了，有个问题想请问一下，双向链表的在指定节点前添加和删除的时间复杂度为什么是O(1)？在查找双向链表中指定节点的时间复杂度是O(n),单向链表中查找指定节点且找到指定节点前的节点的时间复杂度算起来也是O(n)吧？<br><br>其实为了实现在指定节点前插入&#47;删除节点不一定要用双向链表，用单链表的实现方式可以优化，遍历的过程中保存当前节点的上一个节点即可，这样比双向链表占用内存更小。<br><br>如果有理解错的地方还请老师和各位小伙伴多多指教。","like_count":0},{"had_liked":false,"id":228265,"user_name":"Swift_yong","can_delete":false,"product_type":"c1","uid":1260782,"ip_address":"","ucode":"19AE116EB7BCF0","user_header":"https://static001.geekbang.org/account/avatar/00/13/3c/ee/18f48590.jpg","comment_is_top":false,"comment_ctime":1592627322,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592627322","product_id":100017301,"comment_content":"1.用数组实现， 用数组长度除以2再减1， 计算需要循环的次数， 然后对比。时间复杂度O(n), 空间复杂度O(1)。<br>2.这个问题用双向链表实现， 时间复杂度O(n),空间复杂度O(1)。<br>3.题目中用单链表来实现， 没想到， 看了评论区， 学习到了快慢指针法， 👍。","like_count":0},{"had_liked":false,"id":228123,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1592561811,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592561811","product_id":100017301,"comment_content":"&#47;&#47;大家看看正确与否<br>public class LRUCache {<br><br>    LinkedList&lt;Integer&gt; cacheList;<br>    private static final int capacity = 10;<br><br>    public LinkedList&lt;Integer&gt; getCacheList(){<br>        if(cacheList == null){<br>            cacheList = new LinkedList&lt;&gt;();<br>        }<br>        return cacheList;<br>    }<br><br>    &#47;&#47;作为缓存，就没多少容量，所以时间复杂度：O(1),空间复杂度：O(1)<br>    &#47;&#47;如果缓存可以存n个数，那时间复杂度：o(n)主要在删除节点和插入尾部的操作,空间复杂度O(n)<br>    public int getCacheData(Integer data){<br>        LinkedList&lt;Integer&gt; cacheList = getCacheList();<br>        if(cacheList.contains(data)){<br>            boolean remove = cacheList.remove(data);<br>            if(remove){<br>                cacheList.addFirst(data);<br>            }<br>        } else {<br>            if(cacheList.size() == capacity){<br>                cacheList.removeLast();<br>                cacheList.addFirst(data);<br>            } else {<br>                cacheList.addFirst(data);<br>            }<br>        }<br>        return data;<br>    }<br>}","like_count":0},{"had_liked":false,"id":228109,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1592558477,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592558477","product_id":100017301,"comment_content":"思考题其实就是判断链表中有没有环的问题，字符串有回文，说明出现重复的字符串了，同样是用快慢指针操作","like_count":0},{"had_liked":false,"id":226120,"user_name":"dream7519","can_delete":false,"product_type":"c1","uid":1098624,"ip_address":"","ucode":"55E229FA55E15C","user_header":"","comment_is_top":false,"comment_ctime":1591953981,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591953981","product_id":100017301,"comment_content":"思考题：<br>反转链表，然后逐个节点判断是不是一样的。时间复杂度O(n)，空间复杂度O(n)<br>","like_count":0},{"had_liked":false,"id":225724,"user_name":".","can_delete":false,"product_type":"c1","uid":2014980,"ip_address":"","ucode":"BB4B7F14090383","user_header":"https://static001.geekbang.org/account/avatar/00/1e/bf/04/eb4895af.jpg","comment_is_top":false,"comment_ctime":1591840894,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591840894","product_id":100017301,"comment_content":"学习到快慢指针这一骚操作了","like_count":0},{"had_liked":false,"id":225672,"user_name":"sam","can_delete":false,"product_type":"c1","uid":1000417,"ip_address":"","ucode":"8D48F4B9045947","user_header":"https://static001.geekbang.org/account/avatar/00/0f/43/e1/b7be5560.jpg","comment_is_top":false,"comment_ctime":1591829094,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591829094","product_id":100017301,"comment_content":"数组实现LRU缓存淘汰策略，时间复杂度是O(N)","like_count":0},{"had_liked":false,"id":225627,"user_name":"海棠头场雪","can_delete":false,"product_type":"c1","uid":1880627,"ip_address":"","ucode":"F8FF4C6E55693C","user_header":"https://static001.geekbang.org/account/avatar/00/1c/b2/33/e9c2c1dd.jpg","comment_is_top":false,"comment_ctime":1591801571,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591801571","product_id":100017301,"comment_content":"数组实现LRU的思路其实也没啥特殊的。","like_count":0},{"had_liked":false,"id":224392,"user_name":"Justin","can_delete":false,"product_type":"c1","uid":1788538,"ip_address":"","ucode":"40C589085FB66C","user_header":"https://static001.geekbang.org/account/avatar/00/1b/4a/7a/14af802c.jpg","comment_is_top":false,"comment_ctime":1591363026,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591363026","product_id":100017301,"comment_content":"mysql就是用的lru算法淘汰bufferpool的缓存页，而且采用冷热分离的模式。这种思想也非常值得学习","like_count":0},{"had_liked":false,"id":223857,"user_name":"Geek_849f9f","can_delete":false,"product_type":"c1","uid":2027473,"ip_address":"","ucode":"67601F35A91999","user_header":"","comment_is_top":false,"comment_ctime":1591197485,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591197485","product_id":100017301,"comment_content":"链表适用于内存小且不连续的情况<br>","like_count":0},{"had_liked":false,"id":223817,"user_name":"鲸鱼少年丶","can_delete":false,"product_type":"c1","uid":2017876,"ip_address":"","ucode":"552898FF528561","user_header":"https://static001.geekbang.org/account/avatar/00/1e/ca/54/fecdc655.jpg","comment_is_top":false,"comment_ctime":1591189357,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591189357","product_id":100017301,"comment_content":"&lt;body&gt;<br><br>  &lt;p id=&quot;cache&quot;&gt;&lt;&#47;p&gt;<br>  &lt;button onclick=&quot;addData()&quot;&gt;加入数据&lt;&#47;button&gt;<br>  &lt;button onclick=&quot;showCache()&quot;&gt;显示缓存&lt;&#47;button&gt;<br>  &lt;script&gt;<br>    &#47;*<br>     *LRU缓存淘汰策略：先进先出策略FIFO，最少使用策略LFU，z最近最少使用策略<br>     *&#47;<br>    &#47;&#47;用一个数组模拟缓存cache<br>    var cache = new Array(10);<br><br>    &#47;&#47;设置插入操作<br>    function addData() {<br>      var data = Math.round(Math.random() * 100);<br>      console.log(&quot;加入的数为：&quot; + data);<br>      for (let i = 0; i &lt; cache.length; i++) {<br>        if (cache[i] == data) {<br>          cache[i] = &quot;&quot;;<br>          organizeDelCache(cache);<br>        }<br>      }<br>      organizeCache(cache);<br>      cache[0] = data;<br>      cache.length = 10;<br>    }<br>    &#47;&#47;腾出cache首空间<br>    function organizeCache(array) {<br><br>      for (let i = cache.length - 1; i &gt;= 0; i--) {<br>        if (cache[i] != &quot;&quot;) {<br>          cache[i + 1] = cache[i]<br>        }<br>      }<br>      cache[0] = &quot;&quot;;<br>    }<br>    &#47;&#47;删除后整理缓存<br>    function organizeDelCache(array) {<br>      for (let i = 0; i &lt; cache.length; i++) {<br>        if (array[i] == &quot;&quot;) {<br>          for (let j = i; j &lt; cache.length - 1; j++) {<br>            array[j] = array[j + 1];<br>          }<br>        }<br>      }<br>    }<br>    &#47;&#47;时刻显示缓存信息<br>    function showCache() {<br>      document.getElementById(&#39;cache&#39;).innerHTML = cache;<br>      setTimeout(&#39;showCache()&#39;, &#39;1000&#39;);<br>    }<br>    showCache();<br>  &lt;&#47;script&gt;<br>&lt;&#47;body&gt;<br>这样不知道对不对，希望大佬们能指出错误","like_count":0},{"had_liked":false,"id":223781,"user_name":"Geek_123d4e","can_delete":false,"product_type":"c1","uid":1972810,"ip_address":"","ucode":"3E10A793C90C31","user_header":"","comment_is_top":false,"comment_ctime":1591179001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591179001","product_id":100017301,"comment_content":"数组的实现思路：<br>维护一个有序的数组 ，之前访问的数据靠近头部，当访问一个新数据时，<br>从后开始往前遍历：<br>1.如果新数据存在于数组中，把此数据从数组中删除，插入点之后的数据往前搬移，新数据添加到最后<br>2.如果新数据不存在于数组中，分为两种情况：<br>数组已满，申请新的更大存储空间，之前的数据拷贝到新空间，新数据插入到数组尾部<br>数组未满，直接插入到数组尾部<br><br>这种数组的思路，缓存访问的时间复杂度也是O(n)","like_count":0},{"had_liked":false,"id":222714,"user_name":"文康","can_delete":false,"product_type":"c1","uid":2019485,"ip_address":"","ucode":"449AEA16A1ABE7","user_header":"https://static001.geekbang.org/account/avatar/00/1e/d0/9d/1d48fa4d.jpg","comment_is_top":false,"comment_ctime":1590897977,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590897977","product_id":100017301,"comment_content":"请问：链表是可以存储不同类型的数据吗？","like_count":0},{"had_liked":false,"id":218198,"user_name":"Yasha","can_delete":false,"product_type":"c1","uid":1803481,"ip_address":"","ucode":"CE9FC0773DD846","user_header":"https://static001.geekbang.org/account/avatar/00/1b/84/d9/55b3eb37.jpg","comment_is_top":false,"comment_ctime":1589744313,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589744313","product_id":100017301,"comment_content":"其实没看懂，快慢指针，直接跳过，不纠结这个问题","like_count":0},{"had_liked":false,"id":217807,"user_name":"怕什么，抱紧我","can_delete":false,"product_type":"c1","uid":1318633,"ip_address":"","ucode":"CBCEA76E9EF33B","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/e9/dcc63d8f.jpg","comment_is_top":false,"comment_ctime":1589616970,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1589616970","product_id":100017301,"comment_content":"老师,链表get(i)的方式,时间复杂度为O(n),获取下标,不等于就获取到了节点<br>一、穷举的方式:<br>1.从链表中间往后遍历时间复杂度为O(n);<br>2.从链表中间往前遍历,总次数为n&#47;2+(n&#47;2-1)+....+3+2+1,时间复杂度为O(n²);<br>整体时间复杂度为T(n)=O(n²+n),就是O(n²)<br>二、额外数组,空间换时间;<br>1.创建链表长度一半的数组:length=n&#47;2;<br>2.遍历链表前一半,并把所遍历到的节点保存到数组中;<br>3.遍历链表后一半,同时倒叙遍历数组,对比内容是否相同;<br>整体来说:遍历链表的时间复杂度O(n),遍历数组的时间复杂度O(n&#47;2),总花费T(n)=O(n+n&#47;2),即O(n);<br>空间上多花费了n&#47;2;<br><br>再次强调,遍历的方式是通过指针的下一节点,时间复杂度为O(1),通过指针位置得到节点时间复杂度为O(n)<br><br>","like_count":0},{"had_liked":false,"id":217776,"user_name":"怕什么，抱紧我","can_delete":false,"product_type":"c1","uid":1318633,"ip_address":"","ucode":"CBCEA76E9EF33B","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/e9/dcc63d8f.jpg","comment_is_top":false,"comment_ctime":1589611260,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1589611260","product_id":100017301,"comment_content":"删除结点中“值等于某个给定值”的结点=遍历节点O(n)+删除节点O(1)=O(n);<br>删除给定指针指向的结点=查找节点O(n)+删除节点O(1)=O(n);<br>老师:给定指针,不代表就已经找到目标了;<br>单向&#47;双向链表查找到指定节点前,会记住它的上一个节点,并不需要额外的再去重头找;<br>所以:单向和双向链表删除节点的时间复杂度同是O(n);<br>双向链表的优势是,向前查找指定节点的第几个节点;<br>如果有错误,还望指出!","like_count":0},{"had_liked":false,"id":217746,"user_name":"Geek_a63040","can_delete":false,"product_type":"c1","uid":2002730,"ip_address":"","ucode":"5E71A86C6A8917","user_header":"","comment_is_top":false,"comment_ctime":1589601460,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589601460","product_id":100017301,"comment_content":"<br>对于第二种情况，我们已经找到了要删除的结点，但是删除某个结点 q 需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，我们还是要从头结点开始遍历链表，直到 p-&gt;next=q，说明 p 是 q 的前驱结点。<br>|------------------------------<br><br>疑问：<br>对于删除单链表中的某一个节点，可以使用两个指针一前一后进行遍历链表呀！为什么还非得再次遍历一下？在一次遍历中就可以找到被删的节点和被删的前一个节点。","like_count":0},{"had_liked":false,"id":216937,"user_name":"iris","can_delete":false,"product_type":"c1","uid":1986106,"ip_address":"","ucode":"8D54D1DBEA6F64","user_header":"https://static001.geekbang.org/account/avatar/00/1e/4e/3a/1932100c.jpg","comment_is_top":false,"comment_ctime":1589371974,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589371974","product_id":100017301,"comment_content":"思考题：<br>我的第一解决想法是，用另一个单向列表逆向复制一份这个链表，然后互相比较是否一致。后了看到有人说这是用空间换时间的算法，也是，好像不怎么好这样搞。<br>看了各位的留言理解了快慢指针去判断的方法，让慢指针从头走到中间节点去完成前半截的链表节点的反序，过程中开辟一个新的节点去向前指向，快指针走到结束时说明慢指针走到了中间节点。然后去用慢指针走完后半截链表，新开辟的反序指针逆向走前半截链表，进行比较，遇到不相等值说明非回文。另外，如果链表个数为偶数也不是回文。<br>大佬代码示例：<br>https:&#47;&#47;github.com&#47;andavid&#47;leetcode-java&#47;blob&#47;master&#47;note&#47;234&#47;README.md<br>本篇收获：关于CPU缓存对数组友好而对链表不友好的知识，写了个笔记记录一下<br>https:&#47;&#47;blog.csdn.net&#47;qq_38721734&#47;article&#47;details&#47;106104541","like_count":0},{"had_liked":false,"id":215626,"user_name":"guan0078","can_delete":false,"product_type":"c1","uid":1090467,"ip_address":"","ucode":"53B15FF3752A40","user_header":"https://static001.geekbang.org/account/avatar/00/10/a3/a3/804fb3e9.jpg","comment_is_top":false,"comment_ctime":1589035258,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589035258","product_id":100017301,"comment_content":"如果只从判断字符串是否是回文字符串来讲的话，可以直接用String的charAt判断0和length-1, 1和length-2...判断是否两两相等就可以了。<br>如果用数组的话，因为charAt本身就是把String转成char[]的，只是自己又实现了一遍，本质是一个东西。<br>如果用单链表的话，从头遍历的时候把0~(size&#47;2-1)的数据放在一个新的链表中，将其中一个链表反转，然后两个链表从0开始比较。<br>如果用双向链表的话也简单了，找到链表中间，一个找pre，一个找next。","like_count":0},{"had_liked":false,"id":215112,"user_name":"tjxcoding","can_delete":false,"product_type":"c1","uid":1317640,"ip_address":"","ucode":"7DEA9ECAF4A75B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKWXs9ibD6uTSK6bFXbibNibMibUIMyKxUtl8KP9zDHgFyPa2w2icLxLKGOmibpuA2qqDMMkGABa0PJicUiaA/132","comment_is_top":false,"comment_ctime":1588906844,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588906844","product_id":100017301,"comment_content":"基于数组实现LRU: 维护一个固定大小的数据size，记录有效数据开始下表head，记录有效数据结束下表tail。<br>插入数据：如果tail + 1 &lt; size, 在tail + 1处放入新插入的数据；如果tail + 1 &lt; size &amp;&amp; head &gt; 0 对数据进行迁移<br>删除数据：标记删除head处的数据","like_count":0},{"had_liked":false,"id":213769,"user_name":"Geek_fa5cb8","can_delete":false,"product_type":"c1","uid":1648729,"ip_address":"","ucode":"D71C177A139658","user_header":"","comment_is_top":false,"comment_ctime":1588557178,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588557178","product_id":100017301,"comment_content":"课后思考<br>1.首先使用快慢指针找到字符串的中间位置<br>2.然后通过分割比较是否是回文字符串<br>时间复杂度 O(N) 空间复杂度 O(1)<br>","like_count":0},{"had_liked":false,"id":212937,"user_name":"Geek_ac7784","can_delete":false,"product_type":"c1","uid":1981613,"ip_address":"","ucode":"62F0E5E6D6F4BA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/8Dj4ugujXwY24G8pcpgDFGiciarXetG3ItQ4M9mSQMLyRdRRXEXXJVfib48mGUQAu87QcvImwyJIVJlEFeEguV44w/132","comment_is_top":false,"comment_ctime":1588240481,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588240481","product_id":100017301,"comment_content":"学习笔记：<br>1. 常用链表有单链表、双向链表、循环链表和双向循环链表几种<br>2. 循环链表在环结构的问题中有优势，如求解约瑟夫环<br>3. 双向链表在实际开发中更常用，尽管多占据一个空间。空间换时间的思想<br>4. Java的LinkedHashmap中用到了双向链表。<br>5. 单链表和双向链表在数据删除上有所区别<br>  通过指针删除：单链表得从头循环一遍才能操作，所以是O(n)，而双向链表是O(1)<br>  删除给定值的数据：都得是O(n)，而单链表得有一个快慢指针。<br>6. 数组与链表对比：<br>数组优势：能随机访问，可通过CPU的缓存预读，速度更快。劣势：大小固定，太大占空间，且有时不容易找到连续空间，太小不断的重新申请，增加复制成本<br>链表优势：不需要连续空间，插入删除友好。劣势：数据占据更大空间，不连续空间容易产生碎片。<br><br>3. 缓存机制有几种，FIFO，LFU，LRU，本节课谈论LRU(最近最少使用策略)<br>   单链表描述：一个对象先判断是否被用过(在缓存内)，如果在，则放在链表前面，如果不在，判断缓存是否满了，满了就释放最后的缓存，在最前面创建该对象；没满就直接在前面创建对象；<br>  数组实现：(效率很慢)<br>每次放值时先判断是否在已经在缓存中<br>如果是，将它左边的元素全部右移一个，然后将它放置在数组头中<br>如果不是，判断数组是否还有空间<br>有空间，将全部元素右移，然后放置在数组头中，同时更新map中角标<br>如果没有，将角标0到数组长度-1的元素右移，然后放置在数组头中，同时更新map中角标，并在map中删除刚才的元素<br>回文链表：看了评论道理懂了，但是写不出来。查找资料<br>https:&#47;&#47;www.cnblogs.com&#47;paulprayer&#47;p&#47;9891019.html","like_count":0},{"had_liked":false,"id":212830,"user_name":"风，大风","can_delete":false,"product_type":"c1","uid":1811611,"ip_address":"","ucode":"1A0F4D461BBC77","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a4/9b/0967f397.jpg","comment_is_top":false,"comment_ctime":1588217848,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588217848","product_id":100017301,"comment_content":"我觉得这种判断回文字符串的问题，如果字符串是存在数组中的话就能很容易判断。那我第一步要做的就是把这个单链表的数据遍历存到一个数组中，数组的大小我们知道，这时就很容易知道中点，然后把中点两边的数据进行比较这个算法的时间复杂度是O(n),空间复杂度是O(n)。看大家都使用快慢指针去判断,相对来说，时间复杂度是一样的，空间复杂度是O(1).所以还是要好一点。","like_count":0},{"had_liked":false,"id":212826,"user_name":"风，大风","can_delete":false,"product_type":"c1","uid":1811611,"ip_address":"","ucode":"1A0F4D461BBC77","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a4/9b/0967f397.jpg","comment_is_top":false,"comment_ctime":1588217086,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588217086","product_id":100017301,"comment_content":"我觉得数组在实现缓存方面比用链表要好，首先缓存的大小是固定的，这一点和数组一样。在新增缓存的时候不需要重新申请内存。而且数组支持随机访问，这样在缓存的清理时，时间复杂度是O(1),而使用链表，除非使用双向循环链表，不然都是O(n).但是使用双向循环链表就有一点用空间换时间的概念了。<br><br>但是，如果是LRU缓存淘汰，就不太适合数组来实现，主要是每次更新缓存时，缓存数据的迁移的时间复杂度是O(n),而使用链表的时间复杂度是O(1).所以不同的缓存实现策略需要选择不同的数据结构去实现。","like_count":0},{"had_liked":false,"id":212565,"user_name":"晴天","can_delete":false,"product_type":"c1","uid":1100637,"ip_address":"","ucode":"9796E0EF8DD9A8","user_header":"https://static001.geekbang.org/account/avatar/00/10/cb/5d/f3b20f07.jpg","comment_is_top":false,"comment_ctime":1588150436,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588150436","product_id":100017301,"comment_content":"用快慢指针的方式可以找到中点的，不过我想问的时候能不能一开始构建字符串的时候就存好头节点和尾结点、、这样的话不是不是更方便么，就像redis一开始就存了字符串的长度一样","like_count":0},{"had_liked":false,"id":212083,"user_name":"Obed","can_delete":false,"product_type":"c1","uid":1399904,"ip_address":"","ucode":"8717488DD14AB4","user_header":"https://static001.geekbang.org/account/avatar/00/15/5c/60/3754399d.jpg","comment_is_top":false,"comment_ctime":1588058591,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588058591","product_id":100017301,"comment_content":"没看评论前,想到的办法是用头插法,在创建一个倒序的链表 ,然后比较原链表和倒序链表的每一个node<br>空间复杂度O(n)<br>时间复杂度O(n)<br>想了想 感觉还是有问题 如果node节点是私有的内部类,数据对象没有提供头插法,就做不了了..","like_count":0},{"had_liked":false,"id":212074,"user_name":"叶紫真","can_delete":false,"product_type":"c1","uid":1547763,"ip_address":"","ucode":"9CD7567FDB7F1F","user_header":"https://static001.geekbang.org/account/avatar/00/17/9d/f3/3f6dd32b.jpg","comment_is_top":false,"comment_ctime":1588057563,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588057563","product_id":100017301,"comment_content":"单链表的删除，当查找到目标删除节点时，我有一万种方式知道前驱节点地址，并且复杂度为O(1)，为什么要说双向链表删除的复杂度要好一些？","like_count":0},{"had_liked":false,"id":211151,"user_name":"秋刀鱼","can_delete":false,"product_type":"c1","uid":1204997,"ip_address":"","ucode":"61509647A587FE","user_header":"https://static001.geekbang.org/account/avatar/00/12/63/05/e2edfc5c.jpg","comment_is_top":false,"comment_ctime":1587905577,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587905577","product_id":100017301,"comment_content":"不太明白，如果查找的时候根据二分查找不就是对数的效率了吗？","like_count":0},{"had_liked":false,"id":209923,"user_name":"非你不可","can_delete":false,"product_type":"c1","uid":1409531,"ip_address":"","ucode":"16F560F44EC9A2","user_header":"https://static001.geekbang.org/account/avatar/00/15/81/fb/1e4f005a.jpg","comment_is_top":false,"comment_ctime":1587635887,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587635887","product_id":100017301,"comment_content":"func main() {<br>\t&#47;&#47;sample := []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;}<br>\tsample := []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;}<br>\t&#47;&#47;sample := []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;}<br>\t&#47;&#47;sample := []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;}<br>\tl := list.New()<br>\tfor _, v := range sample {<br>\t\tl.PushBack(v)<br>\t}<br>\t&#47;&#47; is palindrome?<br>\tlimit := int(math.Floor(float64(l.Len() &#47; 2)))<br>\titem := l.Front()<br>\tfor i := 0; i &lt; limit; i++ {<br>\t\trItem := item<br>\t\tfor j := 0; j &lt; l.Len()-1-2*i; j++ {<br>\t\t\trItem = rItem.Next()<br>\t\t}<br>\t\tif item.Value != rItem.Value {<br>\t\t\tfmt.Println(&quot;不是回文字符串&quot;)<br>\t\t\treturn<br>\t\t}<br>\t\titem = item.Next()<br>\t}<br>\tfmt.Println(&quot;是回文字符串&quot;)<br>\treturn<br>}<br>&#47;&#47; T(n) = O(n&#47;2) * O(n&#47;2) = O(n2)<br><br>请问我这种方式的时间复杂度怎么算","like_count":0},{"had_liked":false,"id":209240,"user_name":"Geek_ca540c","can_delete":false,"product_type":"c1","uid":1903258,"ip_address":"","ucode":"DA56EE2C0CD480","user_header":"","comment_is_top":false,"comment_ctime":1587522748,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587522748","product_id":100017301,"comment_content":"空间换时间的例子：数组的删除优化思想，就是先记录已经被删除的数据的地址，然后统一删除","like_count":0},{"had_liked":false,"id":208993,"user_name":"海晏","can_delete":false,"product_type":"c1","uid":1915554,"ip_address":"","ucode":"38E998D2036115","user_header":"https://static001.geekbang.org/account/avatar/00/1d/3a/a2/d9f736c6.jpg","comment_is_top":false,"comment_ctime":1587478636,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587478636","product_id":100017301,"comment_content":"疑问4：下面删除的实际上是倒数第n+2个节点<br>    def delete_last_n_node(self, n):<br>        &quot;&quot;&quot;删除链表中倒数第N个节点.<br>        主体思路：<br>            设置快、慢两个指针，快指针先行，慢指针不动；当快指针跨了N步以后，快、慢指针同时往链表尾部移动，<br>            当快指针到达链表尾部的时候，慢指针所指向的就是链表的倒数第N个节点<br>        参数:<br>            n:需要删除的倒数第N个序数<br>        &quot;&quot;&quot;<br>        fast = self.__head<br>        slow = self.__head<br>        step = 0<br><br>        while step &lt;= n:<br>            fast = fast.next_node<br>            step += 1<br><br>        while fast.next_node is not None:<br>            tmp = slow<br>            fast = fast.next_node<br>            slow = slow.next_node<br><br>        tmp.next_node = slow.next_node<br>        #【推算在只有四个节点的时候删除倒数第1个节点，实际删除的是倒数第3个节点，待检验<br>        # 由于头节点不能删除，应该加一个前提条件:链表的长度&gt;n】<br>list = [1,2,3,3,4]<br>l = SinglyLinkedList()<br>for i in list:<br>    l.insert_to_head(i)<br>l.print_all()           #输出：4 --&gt; 3 --&gt; 3 --&gt; 2 --&gt; 1<br><br>l.delete_by_node(Node(3))<br>l.print_all()           #输出：4 --&gt; 3 --&gt; 3 --&gt; 2 --&gt; 1<br>#【并没有预想中的任何一种结果，这个函数怎么调用呢？什么样的情况下用呢？】<br><br>l.delete_by_value(3)    #验证是否只删除第一个value==3 的节点<br>l.print_all()           #猜想为真，输出：4 --&gt; 3 --&gt; 2 --&gt; 1<br><br>l.delete_last_n_node(1) #验证是否删除的是倒数第3个节点<br>l.print_all()           #猜想为真，输出：4 --&gt; 2 --&gt; 1<br>","like_count":0},{"had_liked":false,"id":208991,"user_name":"海晏","can_delete":false,"product_type":"c1","uid":1915554,"ip_address":"","ucode":"38E998D2036115","user_header":"https://static001.geekbang.org/account/avatar/00/1d/3a/a2/d9f736c6.jpg","comment_is_top":false,"comment_ctime":1587478518,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587478518","product_id":100017301,"comment_content":"疑问3：node参数形式是怎么样的？不会调用。什么样的情况会删除指定节点？<br>def delete_by_node(self, node):<br>        &quot;&quot;&quot;在链表中删除指定Node的节点.<br>        参数:<br>            node:指定的Node节点<br>        &quot;&quot;&quot;<br>        if self.__head is None:  # 如果链表是空的，则什么都不做<br>            return<br><br>        if node == self.__head:  # 如果指定删除的Node节点是链表的头节点<br>            self.__head = node.next_node<br>            return<br>            # 【把下一个节点定义为头节点，原来的头节点还在内存中吗？】<br><br>        pro = self.__head<br>        not_found = False  # 如果在整个链表中都没有找到指定删除的Node节点，则该标记量设置为True<br>        while pro.next_node != node:<br>            if pro.next_node is None:  # 如果已经到链表的最后一个节点，则表明该链表中没有找到指定删除的Node节点<br>                not_found = True<br>                break<br>            else:<br>                pro = pro.next_node<br>        if not not_found:<br>            pro.next_node = node.next_node<br><br>    def delete_by_value(self, value):<br>        &quot;&quot;&quot;在链表中删除指定存储数据的Node节点.<br>        参数:<br>            value:指定的存储数据<br>        &quot;&quot;&quot;<br>        if self.__head is None:  # 如果链表是空的，则什么都不做<br>            return<br><br>        if self.__head.data == value:  # 如果链表的头Node节点就是指定删除的Node节点<br>            self.__head = self.__head.next_node<br><br>        pro = self.__head<br>        node = self.__head.next_node<br>        not_found = False<br>        while node.data != value:<br>            if node.next_node is None:  # 如果已经到链表的最后一个节点，则表明该链表中没有找到执行Value值的Node节点<br>                not_found = True<br>                break<br>            else:<br>                pro = node<br>                node = node.next_node<br>        if not_found is False:<br>            pro.next_node = node.next_node<br>            # 【函数delete_by_node与函数delete_by_value调用区别在哪呢?】","like_count":0},{"had_liked":false,"id":208989,"user_name":"海晏","can_delete":false,"product_type":"c1","uid":1915554,"ip_address":"","ucode":"38E998D2036115","user_header":"https://static001.geekbang.org/account/avatar/00/1d/3a/a2/d9f736c6.jpg","comment_is_top":false,"comment_ctime":1587478494,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587478494","product_id":100017301,"comment_content":"昨天花了将近五个小时都没有自己实现一个链表，今天晚上看了小争哥的源码 singlyLinkedList.py 才明白，写的实在是太清楚了。从晚饭后津津有味地看了4个小时，还有一些些问题不清楚想问一下。<br><br>疑问1： 为什么这样写而不是直接定义变量呢？<br>def __init__(self, data, next_node=None):   <br>        &quot;&quot;&quot;Node节点的初始化方法.                <br>        参数:<br>            data:存储的数据<br>            next:下一个Node节点的引用地址<br>        &quot;&quot;&quot;<br>        self.__data = data<br>        self.__next = next_node<br>        #__init__这么写是可以作成员判断吗？】<br><br>疑问2：被删除地节点哪去了？<br>def insert_to_head(self, value):<br>        &quot;&quot;&quot;在链表的头部插入一个存储value数值的Node节点.<br>        参数:<br>            value:将要存储的数据<br>        &quot;&quot;&quot;<br>        node = Node(value)<br>        node.next_node = self.__head<br>        self.__head = node<br>        #【1.调用Node类，新建一个存储了数据Value的节点<br>        #2.先把这个待插入节点指向原来的头节点<br>        #3.把这个存储数据value的节点定义为新的头节点<br>        #所以这是一个不带头的单链表吗？】<br><br>","like_count":0},{"had_liked":false,"id":207823,"user_name":"收","can_delete":false,"product_type":"c1","uid":1599768,"ip_address":"","ucode":"EC3338DB7AEF34","user_header":"https://static001.geekbang.org/account/avatar/00/18/69/18/ca8a5c22.jpg","comment_is_top":false,"comment_ctime":1587190571,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587190571","product_id":100017301,"comment_content":"课后思考：<br>1. 快慢指针找到中间位置，同时逆序前半部分;<br>2. 比较回文；<br>3. 逆序恢复(偷懒省略掉了)；","like_count":0},{"had_liked":false,"id":207566,"user_name":"Jussi Lee","can_delete":false,"product_type":"c1","uid":1211190,"ip_address":"","ucode":"F2F5948CCD52A2","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/36/fd46331c.jpg","comment_is_top":false,"comment_ctime":1587109755,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587109755","product_id":100017301,"comment_content":"虽然之前对数组和链表都有学习和了解，但是再阅读一次感觉受益慢慢，特别是很多同学的回答，都非常有道理。。","like_count":0},{"had_liked":false,"id":207519,"user_name":"Allan","can_delete":false,"product_type":"c1","uid":1310388,"ip_address":"","ucode":"8DA4DBECC2C45C","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","comment_is_top":false,"comment_ctime":1587099294,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587099294","product_id":100017301,"comment_content":"60天攻克算法打卡行动第4天<br><br>学习内容 : <br>链表（上）：如何实现LRU缓存淘汰算法?<br><br>清理缓存通常有三种缓存淘汰策略，掌握链表的基础知识，就能实现 LRU 缓存淘汰算法。<br>1.五花八门的链表结构 <br>单链表：后继无前驱；双链表：前驱，后继；循环链表：尾部接头部。<br>空间换时间：追求速度，那么我选择空间复杂度相对高的，但时间复杂度较低的算法或数据结构。<br>时间换空间：如果我们代码跑在手机或者单片机上，那么我空间就不够了，所以就需要空间复杂度低的，可能时间复杂度较高的算法或数据结构。<br>双向循环链表：方向双向并且循环。<br>2.链表 VS 数组性能大比拼<br>数组内存连续对cpu友好，链表不连续对cpu不友好；数组大小固定，需要扩容还得把原先的复制，数据量大比较耗时，链表 没有大小的限制，天然支持动态扩容；<br>数组实现LRU思路：1、我们有数组A；数据进来，我们查看数组是否已满，-不满，插入A第一位，后面的依次向后移动，所以对A 插入是O（n）-满 则需要删除最后一位，然后前面的先后移动复杂度 o(n).","like_count":0},{"had_liked":false,"id":207320,"user_name":"CJJ","can_delete":false,"product_type":"c1","uid":1194060,"ip_address":"","ucode":"7E02A6A8547559","user_header":"https://static001.geekbang.org/account/avatar/00/12/38/4c/5426e2e0.jpg","comment_is_top":false,"comment_ctime":1587047174,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1587047174","product_id":100017301,"comment_content":"今天学完这章，我突然发现自己生活中也有用到类似LRU的淘汰算法，比如我们每天晾衣服，杆子的长度是有限的，我每天把干了的衣服收下来，把剩下的挪到尾部，在头部晾上今天洗好的衣服，果然编程源于生活，这是不是可以命名为 最近最早干了(ERD)淘汰算法 哈哈😂😂","like_count":0},{"had_liked":false,"id":207188,"user_name":"小阳","can_delete":false,"product_type":"c1","uid":1296135,"ip_address":"","ucode":"97A162992E6A81","user_header":"https://static001.geekbang.org/account/avatar/00/13/c7/07/5798c17e.jpg","comment_is_top":false,"comment_ctime":1587021631,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587021631","product_id":100017301,"comment_content":"LRU 使用数组实现思路：<br>   <br>        数据结构使用散列表+数组，散列表存储缓存数据在数组中的位置。缓存命中时，将命中元素与数组首位元素交换位置；新缓存元素加入时，将新元素置于数组首位，然后将原首位的元素置于数组最后一位；当缓存满了时，删除元素最后一个数据，新元素置于首位，原首位元素置于最后一位。<br><br>链表检查回文字符串：<br>       我的思路是先将链表逆序，逆序后的链表。逆序后的链表再与原链表逐个比对元素。时间复杂度O（n），空间复杂度O(n)","like_count":0},{"had_liked":false,"id":207178,"user_name":"o0oi1i","can_delete":false,"product_type":"c1","uid":1132312,"ip_address":"","ucode":"D1F6AD4AAEAFBE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/18/293cd24d.jpg","comment_is_top":false,"comment_ctime":1587020938,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587020938","product_id":100017301,"comment_content":"请问老师的课后思考题是“判断一个链表是否为回文链表”吗？","like_count":0},{"had_liked":false,"id":207041,"user_name":"70","can_delete":false,"product_type":"c1","uid":1081899,"ip_address":"","ucode":"A5884B2BDDAB70","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/2b/cf93c499.jpg","comment_is_top":false,"comment_ctime":1586999073,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586999073","product_id":100017301,"comment_content":"其实单向链表在删除和插入时，可以对老师的思路简单优化，每次判断链表指针的下一个节点值，在查找到位置后新增和删除就可以直接操作，不重新遍历一次。","like_count":0},{"had_liked":false,"id":206886,"user_name":"Leon","can_delete":false,"product_type":"c1","uid":1963935,"ip_address":"","ucode":"6FB3AFDEC161FB","user_header":"https://static001.geekbang.org/account/avatar/00/1d/f7/9f/9740d816.jpg","comment_is_top":false,"comment_ctime":1586952106,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586952106","product_id":100017301,"comment_content":"看到大家都用到了链表反向，请问如何做的呢？","like_count":0},{"had_liked":false,"id":206862,"user_name":"默默","can_delete":false,"product_type":"c1","uid":1006635,"ip_address":"","ucode":"AF798B9D327F24","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/2b/8b771383.jpg","comment_is_top":false,"comment_ctime":1586946301,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586946301","product_id":100017301,"comment_content":"一开始的想法：<br>1、构造一个新的反序单列表；时间复杂度为：O(n)，空间复杂度为：O(n)<br>2、同步比较新老链表数据，每次比较一致为回文，否则不是。时间复杂度为：O(n)<br>总的时间复杂度：O(n)，总的空间复杂度：O(n)<br>看了同学的思路后，空间复杂度可以降为O(1),时间复杂度虽都为O(n)，但我的方法是O(2n)，同学的是O(1.5n)","like_count":0},{"had_liked":false,"id":206752,"user_name":"鱼丸粗面","can_delete":false,"product_type":"c1","uid":1785016,"ip_address":"","ucode":"B2F3F75B0D1422","user_header":"https://static001.geekbang.org/account/avatar/00/1b/3c/b8/9489387c.jpg","comment_is_top":false,"comment_ctime":1586928948,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586928948","product_id":100017301,"comment_content":"以下是我的代码实现，今天还特意学习了快慢指针的其他功能，比如找链表的环入口，双链交叉点<br><br>&#47;**<br>     * 是否是回文串  123321<br>     * 不考虑有环<br>     *&#47;<br>    public static boolean isPlalindrome(Node node) {<br>        &#47;&#47; 先找到中间节点<br>        Node fast = node;<br>        Node slow = node;<br><br>        Node pre = null;<br>        while (fast != null) {<br>            Node fastNext = fast.getNext();<br>            &#47;&#47; 奇数个节点,slow 是正中间<br>            if (fastNext == null) {<br>                if (slow == node) {<br>                    return true;<br>                }<br>                slow = slow.getNext();<br>                while (slow.getValue().equals(pre.getValue())) {<br>                    slow = slow.getNext();<br>                    pre = pre.getNext();<br>                    if (slow == null) {<br>                        return true;<br>                    }<br>                }<br>                return false;<br>            }<br>            &#47;&#47; 偶数个节点<br>            else if (fastNext.getNext() == null) {<br>                Node slowNext = slow.getNext();<br>                slow.setNext(pre);<br>                pre = slow;<br>                slow = slowNext;<br>                while (slow.getValue().equals(pre.getValue())) {<br>                    slow = slow.getNext();<br>                    pre = pre.getNext();<br>                    if (slow == null) {<br>                        return true;<br>                    }<br>                }<br>                return false;<br>            } else {<br>                Node slowNext = slow.getNext();<br>                slow.setNext(pre);<br>                pre = slow;<br>                slow = slowNext;<br>                fast = fastNext.getNext();<br>            }<br><br>        }<br>        return false;<br>    }","like_count":0},{"had_liked":false,"id":206312,"user_name":"Gasnerd","can_delete":false,"product_type":"c1","uid":1440263,"ip_address":"","ucode":"3630276571AF66","user_header":"https://static001.geekbang.org/account/avatar/00/15/fa/07/1d50f530.jpg","comment_is_top":false,"comment_ctime":1586838102,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586838102","product_id":100017301,"comment_content":"大O表示法，感觉粒度很粗，那有是怎么区分出算法的效率的呢？怎么可以这么粗放？通过老师之前的讲解我能知道什么时候是O（1）、O（n），但对为什么可以忽略、可以转化为O（n）之类的没有理解。","like_count":0},{"had_liked":false,"id":206072,"user_name":"炒鸡辣鸡","can_delete":false,"product_type":"c1","uid":1116610,"ip_address":"","ucode":"4FE8E6AA361673","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/c2/4e086a4b.jpg","comment_is_top":false,"comment_ctime":1586783929,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586783929","product_id":100017301,"comment_content":"我认为链表的插入时间复杂度应该是O(n)，链表要插入某个节点为O(1)的时间复杂度的条件是，你有要插入节点的指针，而获取这个指针，最坏时间复杂度也是O(n)，所以链表用处并不多。","like_count":0},{"had_liked":false,"id":205598,"user_name":"晓森","can_delete":false,"product_type":"c1","uid":1112603,"ip_address":"","ucode":"3D5EB11B9E0FD7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/1b/5d82d759.jpg","comment_is_top":false,"comment_ctime":1586680958,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586680958","product_id":100017301,"comment_content":"回文字符串？<br><br>- 使用单链表或数组<br>    - 思路：字符串的字符从低到高放入链表中，低位索引放入链表末尾，高位索引放入链表开头<br>    - 查询：<br>        - 如果链表从头到尾遍历，组成的字符串与输入字符串一致，则代表是回文字符串<br>    - 时间复杂度：<br>        - 将字符串的字符遍历存入链表，O(n)<br>        - 遍历当前链表，O(n)","like_count":0},{"had_liked":false,"id":205597,"user_name":"晓森","can_delete":false,"product_type":"c1","uid":1112603,"ip_address":"","ucode":"3D5EB11B9E0FD7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/1b/5d82d759.jpg","comment_is_top":false,"comment_ctime":1586680945,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586680945","product_id":100017301,"comment_content":"回文字符串？<br><br>- 使用单链表或数组<br>    - 思路：字符串的字符从低到高放入链表中，低位索引放入链表末尾，高位索引放入链表开头<br>    - 查询：<br>        - 如果链表从头到尾遍历，组成的字符串与输入字符串一致，则代表是回文字符串<br>    - 时间复杂度：<br>        - 将字符串的字符遍历存入链表，O(n)<br>        - 遍历当前链表，O(n)","like_count":0},{"had_liked":false,"id":205539,"user_name":"晓森","can_delete":false,"product_type":"c1","uid":1112603,"ip_address":"","ucode":"3D5EB11B9E0FD7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/1b/5d82d759.jpg","comment_is_top":false,"comment_ctime":1586666883,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586666883","product_id":100017301,"comment_content":"LRU 策略实现方式？<br><br>- 使用数组<br>    - 思路：最新的缓存放在数组末尾，最老的缓存放在数组开头，同时使用一个变量记录最新的缓存索引值<br>    - 缓存逻辑<br>        - 命中：O(n)<br>            - 从最新缓存索引值从后向前找到指定缓存 O(n)<br>            - 将该缓存复制到最新缓存索引后面 O(1)<br>            - 从该缓存索引到最新缓存中间的数据挨个向前移动 O(n)<br>        - 未命中：<br>            - 缓存未满：O(1)<br>                - 直接在最新的索引后面填入缓存数据 O(1)<br>            - 缓存已满：O(n)<br>                - 删除数组头部索引数据 O(1)<br>                - 将其余数据挨个复制到新的数组中（可以复用当前数组） O(n)<br>                - 末尾填入最新索引 O(1)<br>    - 时间复杂度：查询缓存 O(n)，更新缓存 O(n)<br>- 使用单链表<br>    - 思路：最新的缓存放在链表开头，最老的缓存放在链表末尾（这样是为了方便查询，每次从链表开头查询，耗时降低）<br>    - 缓存逻辑<br>        - 命中：O(n)<br>            - 从头结点开始遍历，找到指定缓存，O(n)<br>            - 并且将该节点移到头结点 O(1)<br>        - 未命中：<br>            - 缓存未满 O(1)<br>                - 直接在链表头插入一个新的缓存节点 O(1)<br>            - 缓存已满 O(1)<br>                - 移除链表尾结点 O(1)<br>                - 头部插入新的缓存节点 O(1)<br>    - 时间复杂度：查询缓存 O(n)，更新缓存 O(1)","like_count":0},{"had_liked":false,"id":205134,"user_name":"大个仔","can_delete":false,"product_type":"c1","uid":1907518,"ip_address":"","ucode":"80AA85390CBEE0","user_header":"https://static001.geekbang.org/account/avatar/00/1d/1b/3e/77bd7995.jpg","comment_is_top":false,"comment_ctime":1586536026,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586536026","product_id":100017301,"comment_content":"总结：单链表与双链表的对比优点是占用空间不大<br>","like_count":0},{"had_liked":false,"id":205031,"user_name":"BiJim","can_delete":false,"product_type":"c1","uid":1314315,"ip_address":"","ucode":"39D4FB0F5E120B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLUqttGWcsXMIRGNEHedAiavt7q9RSNmTdvSGqmvO8kiaafMo6CXdVMf03FWn0gCS1Bibkumq3gp6g4g/132","comment_is_top":false,"comment_ctime":1586511644,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586511644","product_id":100017301,"comment_content":"LinkedList 和 LinkedHashMap 都有双向链表数据结构的支撑；<br>Android常用的开源库，比如图片框架Glide，OkHttp的cache机制都会使用到LRU算法做内存或磁盘缓存；<br>Android SDK中提供的LruCache类就是利用LinkedHashMap(accessOrder=true)去实现的。","like_count":0},{"had_liked":false,"id":204166,"user_name":"yoummg","can_delete":false,"product_type":"c1","uid":1067856,"ip_address":"","ucode":"1B809CFDD7A508","user_header":"https://static001.geekbang.org/account/avatar/00/10/4b/50/fdecd51a.jpg","comment_is_top":false,"comment_ctime":1586345240,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586345240","product_id":100017301,"comment_content":"数组支持随机访问，链表支持高效新增，删除。<br><br>Java LinkedHashMap LRU = hash + 双向链表<br><br>思考：如何利用数组实现LRU<br>申请一个较大的数组，数组头放常访问，尾放未访问。<br>新增元素，进行比较，若满，删除尾，移动O(n)，插头；若不满，头以后进行移位，插头。<br><br>课后题：回文，利用数组（额外空间存储数据），数组倒序，链表正序进行比较，如果都相等，则是回文。","like_count":0},{"had_liked":false,"id":203919,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1586306902,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586306902","product_id":100017301,"comment_content":"public class List06 {<br>    public boolean isPalindrome(ListNode listNode) {<br>        if (listNode == null) {<br>            return false;<br>        }<br>        ListNode reverse = new ListNode(null, listNode.var);<br>        ListNode point = listNode.next;<br>        &#47;&#47; 翻转<br>        while (point != null) {<br>            reverse = new ListNode(reverse, point.var);<br>            point   = point.next;<br>        }<br><br>        &#47;&#47; 比较翻转后和原链表是否相同<br>        while (listNode != null) {<br>            if (listNode.var != reverse.var) {<br>                return false;<br>            }<br>            listNode = listNode.next;<br>            reverse  = reverse.next;<br>        }<br>        return true;<br>    }<br>}<br><br><br>class ListNode {<br>    ListNode next;<br><br>    int var;<br><br>    ListNode(ListNode next, int var) {<br>        this.next = next;<br>        this.var  = var;<br>    }<br>}<br><br><br>时间复杂度 O(2n), 空间复杂度O(n)","like_count":0},{"had_liked":false,"id":203910,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1586305849,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586305849","product_id":100017301,"comment_content":"基于数组的LRU<br>思路：把数组当做一个循环数组，不断的往头部插入，还需要一个额外记录头部位置， 不过每次插入都需要移动很多数据。头部右侧就是新数组，头部左侧就是需要删除的数据","like_count":0},{"had_liked":false,"id":203477,"user_name":"林毅鑫","can_delete":false,"product_type":"c1","uid":1917916,"ip_address":"","ucode":"1BB3D186E90D96","user_header":"https://static001.geekbang.org/account/avatar/00/1d/43/dc/95d4f2c5.jpg","comment_is_top":false,"comment_ctime":1586219255,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586219255","product_id":100017301,"comment_content":"一遍真的不够，基础太差，要多听几遍。","like_count":0},{"had_liked":false,"id":203476,"user_name":"林毅鑫","can_delete":false,"product_type":"c1","uid":1917916,"ip_address":"","ucode":"1BB3D186E90D96","user_header":"https://static001.geekbang.org/account/avatar/00/1d/43/dc/95d4f2c5.jpg","comment_is_top":false,"comment_ctime":1586219083,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586219083","product_id":100017301,"comment_content":"程序报内存不足，有可能是数据结构使用不对，学习了。","like_count":0},{"had_liked":false,"id":203412,"user_name":"亢（知行合一的路上）","can_delete":false,"product_type":"c1","uid":1347013,"ip_address":"","ucode":"958AF7C96EB9E8","user_header":"https://static001.geekbang.org/account/avatar/00/14/8d/c5/898b13b4.jpg","comment_is_top":false,"comment_ctime":1586185798,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586185798","product_id":100017301,"comment_content":"LRU 淘汰算法：有序单链表，越靠近链表尾部的结点是越早之前访问的。也可以是链表头部结点是越早之前访问的吧？想了想好像没差别。","like_count":0},{"had_liked":false,"id":200493,"user_name":"无言ing","can_delete":false,"product_type":"c1","uid":1882139,"ip_address":"","ucode":"BC4058F20BA5B3","user_header":"https://static001.geekbang.org/account/avatar/00/1c/b8/1b/06b10cc3.jpg","comment_is_top":false,"comment_ctime":1585613028,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585613028","product_id":100017301,"comment_content":"通过老师这节课，对链表结构有了更深入的了解，继续学习，奥利给","like_count":0},{"had_liked":false,"id":200255,"user_name":"王坤祥","can_delete":false,"product_type":"c1","uid":1003327,"ip_address":"","ucode":"FB988B9F381A33","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4f/3f/6f62f982.jpg","comment_is_top":false,"comment_ctime":1585564170,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585564170","product_id":100017301,"comment_content":"最近在看计算机方面的书籍和资料，关于为什么数组可以借助CPU缓存机制，访问效率更高，总结如下：<br><br>我们先将计算机分为数个层次：<br>&gt;&gt;&gt;寄存器  64位<br>&gt;&gt;&gt;一级缓存L1 4×64KB<br>&gt;&gt;&gt;二级缓存L2 4×256KB<br>&gt;&gt;&gt;三级缓存L3 8MB<br>&gt;&gt;&gt;内存 4GB<br>&gt;&gt;&gt;磁盘 1TB<br>可以看到这些层次一个比一个更大。<br>寄存器，既是CPU的工作台，是存放计算数据的地方CPU要工作了，它需要数据或者地址，先从一级缓存里面找，找不到就从二级缓存里面找，依次类推。假如CPU到磁盘才有，那么这个数据就会存入内存，再存入三级缓存、二级缓存、一级缓存，最后存入寄存器，CPU用它来计算了。<br><br>所以说，可以这么看， L1是寄存器的缓存，L2是L1的缓存，依次这样下去，下面一层是上面一层的缓存。<br><br>&lt;现在来讲局部性原理&gt;<br><br>CPU的工作要高速，我们希望CPU需要的数据更多的就在L1里面，一找就找着。不希望更多的跑到下面内存乃至磁盘里面去找，这样会花更多的时间。所以当CPU用了一个数据，计算机会遇见性地存入CPU未来可能会用到的数据到L123内存，用到的可能性越大，就能存到越接近寄存器的层次。这也才是缓存的真正意义。<br><br>那么，计算机怎样才能判断一个数据接下来可能被用到？<br>时间局部性：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。这无疑是正确的，用过的数据大概率再次被用到。<br>空间局部性：在最近的将来将用到的信息很可能与现在正在使用的信息在空间地址上是临近的。正在使用的这个数据地址旁边的数据，当然也是很可能被用到的。<br><br>数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。","like_count":0},{"had_liked":false,"id":200237,"user_name":"蜗牛","can_delete":false,"product_type":"c1","uid":1086220,"ip_address":"","ucode":"01CC18F12E556D","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/0c/0a6a0d5e.jpg","comment_is_top":false,"comment_ctime":1585561611,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585561611","product_id":100017301,"comment_content":"慢快指针法<br>1. 慢指针走一步，快指针走2步骤。找到中点<br>2. 偏转头节点-中节点<br>3. 比较偏转后的和中节点-为节点<br>时间：O(n) ,空间O(1)","like_count":0},{"had_liked":false,"id":199271,"user_name":"yezi","can_delete":false,"product_type":"c1","uid":1935780,"ip_address":"","ucode":"B2E5CC51D37C44","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/AiaYGqeT5oDEUaRq2vVLOIesrnPwJH3VfN8tb3CZlAbxW9QYo6TfPqUS8c4ibAyibsn1955GK3EOJsjFFKXRbSYvA/132","comment_is_top":false,"comment_ctime":1585485458,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585485458","product_id":100017301,"comment_content":"数组，支持随机查找，链表支持动态扩容","like_count":0},{"had_liked":false,"id":198213,"user_name":"片子有毒","can_delete":false,"product_type":"c1","uid":1664594,"ip_address":"","ucode":"8C9B49D3070EB4","user_header":"https://static001.geekbang.org/account/avatar/00/19/66/52/b2d14b3a.jpg","comment_is_top":false,"comment_ctime":1585415403,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585415403","product_id":100017301,"comment_content":"class Solution {<br>    public boolean isPalindrome(ListNode head) {<br>        if(head == null){<br>            return true;<br>        }<br>        ListNode node = head;<br>        ListNode fastNode = head;<br>        ListNode last = null;<br>        ListNode next = null;<br>        while(fastNode.next !=null &amp;&amp; fastNode.next.next != null){<br>            fastNode = fastNode.next.next;<br>            &#47;&#47;反转前半部分<br>            next = node.next;<br>            node.next = last;<br>            last = node;<br>            node = next;<br>        }<br>        &#47;&#47;结束循环后情况：<br>        &#47;&#47;长度为奇数：node 指向中间节点，last 指向中间前面的一个节点<br>        &#47;&#47;长度为偶数：node 指向第 n&#47;2 个节点，last 指向第 n&#47;2 - 1 个节点<br><br>        ListNode pre,after;<br>        if(fastNode.next != null){<br>            &#47;&#47;长度为偶数，从node往前、node+1往后开始比较<br>            after = node.next;<br>            node.next = last;<br>            pre = node;<br>        }else{<br>            &#47;&#47;长度为奇数，从node-1往前、node+1往后开始比较<br>            pre = last;<br>            after = node.next;<br>        }<br>        while(pre!=null &amp;&amp; after!=null){ &#47;&#47;对比两个链表是否相等即可<br>            if(pre.val != after.val){<br>                return false;<br>            }<br>            pre = pre.next;<br>            after = after.next;<br>        }<br>        return true;<br>    }<br>}","like_count":0},{"had_liked":false,"id":198069,"user_name":"涛声依旧","can_delete":false,"product_type":"c1","uid":1013593,"ip_address":"","ucode":"E0F22ECA010A5C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/77/59/8bb1f879.jpg","comment_is_top":false,"comment_ctime":1585408196,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585408196","product_id":100017301,"comment_content":"我是来补课的。","like_count":0},{"had_liked":false,"id":197110,"user_name":"潘腾","can_delete":false,"product_type":"c1","uid":1566689,"ip_address":"","ucode":"04FEC6FFD62F43","user_header":"","comment_is_top":false,"comment_ctime":1585358240,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585358240","product_id":100017301,"comment_content":"学习了","like_count":0},{"had_liked":false,"id":196046,"user_name":"shadow","can_delete":false,"product_type":"c1","uid":1598637,"ip_address":"","ucode":"B5B8018157DA23","user_header":"https://static001.geekbang.org/account/avatar/00/18/64/ad/467b6471.jpg","comment_is_top":false,"comment_ctime":1585232410,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585232410","product_id":100017301,"comment_content":"思考题：根据原有单链表回文创建一个逆向的单链表回文，while 循环遍历比较，复杂度为 O(N)。","like_count":0},{"had_liked":false,"id":195702,"user_name":"Geek_112e68","can_delete":false,"product_type":"c1","uid":1644011,"ip_address":"","ucode":"82843584C97F43","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/WhoLIb4HZtuwErPetUjHj9JVOYFibDXDAcIic3K0CSzJp4zibe1cemraIq1S8YSN5KSCJcUdicm9f4aKTwZHxFBwTw/132","comment_is_top":false,"comment_ctime":1585213477,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585213477","product_id":100017301,"comment_content":"快慢指针","like_count":0},{"had_liked":false,"id":194298,"user_name":"Dybala不缺钙","can_delete":false,"product_type":"c1","uid":1805130,"ip_address":"","ucode":"F51EE2BA41C40B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/8b/4a/66a1cb50.jpg","comment_is_top":false,"comment_ctime":1585047249,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585047249","product_id":100017301,"comment_content":"看评论没有用go语言实现LRU寻址算法的，我用go实现一个吧<br><br>package main<br><br>&#47;&#47; LRU缓存淘汰策略的demo<br><br>&#47;&#47; 这是一个单向链表的节点<br>type Node struct {<br>\tNext *Node<br>\tValue *interface{}<br>}<br><br><br>&#47;&#47; 缓存模型<br>type Memory struct {<br>\tHead *Node &#47;&#47; 头节点<br>\tMax int32 &#47;&#47; 链表的最大长度<br>}<br><br>&#47;&#47; 向内存中插入变量的指针，若链表为空，则插入头节点<br>func (m *Memory) Insert(newNode *interface{})  {<br>\tif m.Head == nil {<br>\t\tm.Head = &amp;Node {<br>\t\t\tNext: nil,<br>\t\t\tValue: newNode,<br>\t\t}<br>\t}<br><br>\tvar pre *Node &#47;&#47; 前节点的指针<br>\tcurrent := m.Head &#47;&#47; 当前节点所有位置<br>\tvar i int32 = 1 &#47;&#47; 计数，第一个节点<br><br>\tn := &amp;Node{<br>\t\tNext: m.Head,<br>\t\tValue: newNode,<br>\t}<br><br>\tfor {<br>\t\t&#47;&#47; 若当前节点是尾节点，则将变量指针插入链表头部，若长度超出了链表长度，则将链表最后一个节点删除<br>\t\tif current.Next == nil {<br>\t\t\tif i &gt;= m.Max {<br>\t\t\t\tpre.Next = nil<br>\t\t\t\tm.Head = n<br>\t\t\t} else {<br>\t\t\t\tm.Head = n<br>\t\t\t}<br>\t\t\tbreak<br>\t\t}<br><br>\t\t&#47;&#47; 若该记录在内存中存在，则将其在链表相应位置删除，并插入链表的头部，若已在头部，则不变<br>\t\tif current.Value == newNode {<br>\t\t\tif pre != nil {<br>\t\t\t\tpre.Next = current.Next<br>\t\t\t\tm.Head = n<br>\t\t\t}<br>\t\t}<br><br>\t\ti++<br>\t}<br>}","like_count":0},{"had_liked":false,"id":194236,"user_name":"SteelHuaSheng","can_delete":false,"product_type":"c1","uid":1396126,"ip_address":"","ucode":"BC8127FC5207FC","user_header":"https://static001.geekbang.org/account/avatar/00/15/4d/9e/04ec08bf.jpg","comment_is_top":false,"comment_ctime":1585039948,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585039948","product_id":100017301,"comment_content":"有两个维度：单向or双向、是否循环，排列组合成了4种情况<br><br>用数组还是链表，看【空间连续性、访问速度、扩容问题、内存大小】等具体实际情况<br><br>实际应用：LRU、回文串等","like_count":0},{"had_liked":false,"id":192830,"user_name":"小飞","can_delete":false,"product_type":"c1","uid":1000347,"ip_address":"","ucode":"4C126548FBA94C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/43/9b/50927dfc.jpg","comment_is_top":false,"comment_ctime":1584874672,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584874672","product_id":100017301,"comment_content":"回文链表： https:&#47;&#47;leetcode-cn.com&#47;problems&#47;palindrome-linked-list-lcci&#47;<br><br>&#47;**<br> * 时间复杂度： O(n) : 因为整个链表需要进行遍历。<br> * 空间复杂度： O(1)： 申请里有限个变量。<br> * 思路：<br> * 1. 先进行条件判断： 节点数量为0，或者1 ， 直接返回为true。 (这种情况也可以不判断。一般为false 情况进行判断)<br> * 2. 先找出中间节点。 这里需要注意链表长度为奇数、偶数来判断哪个部分为后半部分链表起点。(枚举方式推到出，记住进行)<br> *                     若为奇数： fast == null ; 中间节点为slow , 则后半部分起点为 slow.next ;<br> *                     若为偶数： fast != null;  有2个中间节点， slow 次数落在后半部分。刚好是起点。不用移动。  <br> * 3。对后半部分节点，进行反转。(链表反转需要非常熟悉。1min 内写完)<br> * 4. 前后2个链表进行遍历， 比较是否相等。<br> *&#47;<br>class Solution {<br>    public boolean isPalindrome(ListNode head) {<br>        if (head == null || head.next == null) {<br>            return true;<br>        }<br>        &#47;&#47; Step 1: 找到中间节点。<br>        ListNode fast = head;<br>        ListNode slow = head;<br><br>        while (fast != null &amp;&amp; fast.next != null) {<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        }<br><br>        &#47;&#47; Step 1.2  确定后续节点。<br>        &#47;&#47; 若节点数量为奇数， 中间节点刚好落在中间， 则后部分链表， 是中间节点的next;<br>        &#47;&#47; 若节点数量为偶数， 遍历结束时， slow 节点刚好落在后部分节点开头。 后部链表就是slow 节点。<br>        if (fast != null) {<br>            slow = slow.next;<br>        }<br><br>        &#47;&#47; Step2:  反转后续的链表<br><br>        ListNode newHead = reserve(slow);<br><br>        &#47;&#47; Step3： 两个链表进行直接比较。<br>        while (head != null &amp;&amp; newHead != null) {<br>            if (head.val != newHead.val) {<br>                return false;<br>            }<br>            head = head.next;<br>            newHead = newHead.next;<br>        }<br>        return true;<br><br>    }<br><br>    &#47;&#47; 链表的反转， 一定需要非常的熟悉! 使用的时候，很快可以拿来。<br>    private ListNode reserve(ListNode head) {<br>        ListNode pre = null;<br>        ListNode curr = head;<br>        ListNode temp = null;<br>        while (curr != null) {<br>            temp = curr.next;<br>            curr.next = pre;<br>            pre = curr;<br>            curr = temp;<br>        }<br>        return pre;<br>    }<br>}","like_count":0},{"had_liked":false,"id":191841,"user_name":"獨自去遠方","can_delete":false,"product_type":"c1","uid":1503941,"ip_address":"","ucode":"E246B33F397441","user_header":"https://static001.geekbang.org/account/avatar/00/16/f2/c5/2a441c27.jpg","comment_is_top":false,"comment_ctime":1584799729,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584799729","product_id":100017301,"comment_content":"链表（1）<br>\t缓存淘汰策略：<br>\t\t先进先出策略 FIFO（First In，First Out）<br>\t\t最少使用策略 LFU（Least Frequently Used）<br>\t\t最近最少使用策略 LRU（Least Recently Used）<br><br>\t？如何使用链表实现LRU<br>\t\t单链表，尾部是访问较早的数据，新数据访问<br>\t\t\t1.如果已经存在，删除，然后插入头部<br>\t\t\t2.如果不存在<br>\t\t\t\t链表满了<br>\t\t\t\t\t删除尾部，插入头部<br>\t\t\t\t未满<br>\t\t\t\t\t插入头部<br>\t\t优化<br>\t\t\t使用散列表记录数据的位置<br>\t<br><br>\t单链表<br>\t\t链表不需要连续内存<br><br>\t\t概念：<br>\t\t\t节点\t\t后继指针<br>\t\t\t头结点（记录链表的基地址）<br>\t\t\t尾结点（指针指向NULL）<br><br><br>\t循环链表<br>\t\t尾结点指针指向头结点<br><br>\t双链表<br>\t\t前驱指针<br><br>\t\t删除操作<br>\t\t\t1.删除给定值的节点<br>\t\t\t2.删除给定指针指向的节点<br>\t\t\t\t需要知道前驱节点，单链表无法直接获取，需要从头开始遍历<br>\t\t\t\tLinkedList<br><br>\t双向循环链表<br><br><br>","like_count":0},{"had_liked":false,"id":191170,"user_name":"雨落千木的时节","can_delete":false,"product_type":"c1","uid":1796430,"ip_address":"","ucode":"A268063299F0D6","user_header":"https://static001.geekbang.org/account/avatar/00/1b/69/4e/7ef7604b.jpg","comment_is_top":false,"comment_ctime":1584752384,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584752384","product_id":100017301,"comment_content":"链表反转，求两个链表相交点，是快手常见的面试题","like_count":0},{"had_liked":false,"id":189304,"user_name":"可乐","can_delete":false,"product_type":"c1","uid":1761176,"ip_address":"","ucode":"89699B8C2D74B9","user_header":"https://static001.geekbang.org/account/avatar/00/1a/df/98/3ec32229.jpg","comment_is_top":false,"comment_ctime":1584497979,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584497979","product_id":100017301,"comment_content":"<br>SNode tmp = ptr.getNext();<br>        ptr.setNext(null);<br>        tmp = null;<br>看了下，老师的单链表实现的代码，其中在方法deleteElemAtEnd中，没太明白上面1、3行的作用，如果是为了有助于垃圾回收，第2行代码执行过后，原pre.next的对象不就没有“被引用”了吗，最终gc在标记垃圾对象时原对象应该也能成功被标记吧。所以没太明白1、3行代码的作用，有大神能帮忙解释一下吗","like_count":0},{"had_liked":false,"id":189171,"user_name":"invisibleTattoo","can_delete":false,"product_type":"c1","uid":1291743,"ip_address":"","ucode":"225E21F56529F3","user_header":"https://static001.geekbang.org/account/avatar/00/13/b5/df/b8aa90c7.jpg","comment_is_top":false,"comment_ctime":1584463107,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584463107","product_id":100017301,"comment_content":"删除单链表上的节点也并不一定需要有前序节点的指针吧，有复制后序节点值的方法","like_count":0},{"had_liked":false,"id":188976,"user_name":"滴答丶滴","can_delete":false,"product_type":"c1","uid":1181206,"ip_address":"","ucode":"2093C2948B4327","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/16/e85c1fa8.jpg","comment_is_top":false,"comment_ctime":1584440850,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584440850","product_id":100017301,"comment_content":"数组进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，也有可能会导致频繁的 GC（Garbage Collection，垃圾回收吧？","like_count":0},{"had_liked":false,"id":188938,"user_name":"Vesen","can_delete":false,"product_type":"c1","uid":1472092,"ip_address":"","ucode":"4DDC2BB56A70FD","user_header":"https://static001.geekbang.org/account/avatar/00/16/76/5c/2d058aed.jpg","comment_is_top":false,"comment_ctime":1584436299,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584436299","product_id":100017301,"comment_content":"各位同学的快慢指针打开我的新世纪😂😂","like_count":0},{"had_liked":false,"id":188850,"user_name":"江中猴姑饼干","can_delete":false,"product_type":"c1","uid":1238992,"ip_address":"","ucode":"4F288845CC70FA","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/d0/d145c11f.jpg","comment_is_top":false,"comment_ctime":1584426182,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584426182","product_id":100017301,"comment_content":"- 删除给定指针指向的结点<br>某些情况下，单向链表可以直接把后继节点的值和后继节点的后继节点地址依次赋值给当前节点，时间复杂度 O(1)","like_count":0},{"had_liked":false,"id":188501,"user_name":"凉人。","can_delete":false,"product_type":"c1","uid":1659177,"ip_address":"","ucode":"4DB16004A62015","user_header":"https://static001.geekbang.org/account/avatar/00/19/51/29/24739c58.jpg","comment_is_top":false,"comment_ctime":1584361866,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584361866","product_id":100017301,"comment_content":"实践","like_count":0},{"had_liked":false,"id":186987,"user_name":"o0oi1i","can_delete":false,"product_type":"c1","uid":1132312,"ip_address":"","ucode":"D1F6AD4AAEAFBE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/18/293cd24d.jpg","comment_is_top":false,"comment_ctime":1583983928,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583983928","product_id":100017301,"comment_content":"打卡6","like_count":0},{"had_liked":false,"id":184848,"user_name":"三三","can_delete":false,"product_type":"c1","uid":1189553,"ip_address":"","ucode":"EF2991CAAB2FA6","user_header":"https://static001.geekbang.org/account/avatar/00/12/26/b1/cc902a24.jpg","comment_is_top":false,"comment_ctime":1583417977,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583417977","product_id":100017301,"comment_content":"头结点用来记录链表的基地址。这就话我不理解，求答疑。结点有data和next，next存储下一结点的地址，那这句话是说data里面存的是基地址？","like_count":0},{"had_liked":false,"id":184748,"user_name":"谭方敏","can_delete":false,"product_type":"c1","uid":1710960,"ip_address":"","ucode":"728DC7ECB7C902","user_header":"https://static001.geekbang.org/account/avatar/00/1a/1b/70/547042ee.jpg","comment_is_top":false,"comment_ctime":1583395810,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583395810","product_id":100017301,"comment_content":"如果是回文串的话，一定是对半开的，可以建立一个双向链表，支持前驱和后继指针，同时设立两个工资指针，head以及tail，head不断遍历后继指针得到值m，而，tail指针不断遍历前驱指针得到值n，如果直到head跟tail指针相等，m都等于n，则说明是回文，否则说明不是回文。","like_count":0},{"had_liked":false,"id":183331,"user_name":"凡","can_delete":false,"product_type":"c1","uid":1721168,"ip_address":"","ucode":"80C2A6452AB9EA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/43/50/abb4ca1e.jpg","comment_is_top":false,"comment_ctime":1582998708,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582998708","product_id":100017301,"comment_content":"https:&#47;&#47;github.com&#47;yefan813&#47;algorithm&#47;tree&#47;master&#47;src&#47;main&#47;java&#47;com&#47;yefan&#47;demo&#47;huiwen<br>分表实现了三种判断是否为回文的方法，时间&#47;空间复杂度在类上有注释","like_count":0},{"had_liked":false,"id":181814,"user_name":"Eternal","can_delete":false,"product_type":"c1","uid":1188023,"ip_address":"","ucode":"EA6FE7CC98F740","user_header":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","comment_is_top":false,"comment_ctime":1582638681,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582638681","product_id":100017301,"comment_content":"两个指针，fast，slow向前走，fast一次走2步，slow一次走1步；不管走多少次，fast走的步数都是slow的2倍数，因此当fast走到末尾的时候，slow刚好走到中间，先把这个想明白；<br><br>然后如果单链表的节点个数是奇数，slow的当前位置就是中间，如果链表节点个数是偶数，p刚好走到一半<br><br>然后再考虑链表反转，然后怎么比较是否相当；<br><br><br>我觉得关键是理解回文字符串的特点，先找到中间节点，这个搞明白了，算法就明白了一大半","like_count":0},{"had_liked":false,"id":181425,"user_name":"华新","can_delete":false,"product_type":"c1","uid":1068724,"ip_address":"","ucode":"B6DB20898F5F99","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/b4/335e58d6.jpg","comment_is_top":false,"comment_ctime":1582538482,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582538482","product_id":100017301,"comment_content":"&#47;&#47;不改变原有链表内容的前提下<br>&#47;**<br>* 1 快慢指针定位中间节点，定位过程中新建链表逆向存储链表<br>* 2 链表节点数为奇数时，忽略最中间结点<br>* 3 后半部分与逆序新链表比对，一致则为回文否则不是<br>* 4、时间复杂度O(n),空间复杂度O(n)<br>*&#47;<br>public boolean isPalindrome(Node head){<br>        if(head == null){<br>            return false;<br>        }<br>        if(head.next == null){<br>            return true;<br>        }<br>        Node slow = head;<br>        Node fast = head;<br>        Node nowNode = new Node(slow.data,null);<br>        &#47;&#47;寻找中间结点，前半部分新建一个新的倒叙链表<br>        while(fast != null &amp;&amp; fast.next != null){<br>            fast = fast.next.next;<br>            nowNode = new Node(slow.data,nowNode);<br>            slow = slow.next;<br>        }<br><br>        &#47;&#47;如果节点数为基数，最中间一个结点忽略，跳到下一个结点。新列表不需要处理。<br>        if (fast != null) {<br>            slow = slow.next;<br>        }<br><br>        &#47;&#47;比较剩余链表和新链表内容是否一致。<br>        while (slow != null) {<br>            if (slow.data != nowNode.data) {<br>                return false;<br>            }<br>            slow = slow.next;<br>            nowNode = nowNode.next;<br>        }<br>        return true;<br>    }<br><br>&#47;&#47;请赐教。。","like_count":0},{"had_liked":false,"id":180619,"user_name":"Purson","can_delete":false,"product_type":"c1","uid":1446120,"ip_address":"","ucode":"5F0C1BB3C0C0A2","user_header":"https://static001.geekbang.org/account/avatar/00/16/10/e8/ec11e306.jpg","comment_is_top":false,"comment_ctime":1582353256,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582353256","product_id":100017301,"comment_content":"1.用快慢指针找出链表的中点，<br>2.如果是奇数结点的链表，当快指针访问到第一次next等于NULL的时候，慢指针所在位置为中点；<br>3.如果是偶数结点的链表，当快指针访问到一个结点，都将前面的结点的后继结点指向前一个结点；<br>4.在中点再新建一个慢指针往前遍历，原来慢指针继续走，一直走到尾，如果遇到不一样就跳出；<br>5.如果能走到尾结点，说明是回文，如果中途跳出说明不是回文，<br><br>时间复杂度是O(n)<br>空间复杂度是O(1)不算链表的空间","like_count":0},{"had_liked":false,"id":179619,"user_name":"拾迹","can_delete":false,"product_type":"c1","uid":1025093,"ip_address":"","ucode":"38F367B77FF2D7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/45/3cb5cdc6.jpg","comment_is_top":false,"comment_ctime":1582039887,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1582039887","product_id":100017301,"comment_content":"基于链表实现 LRU 缓存淘汰算法：<br>* 维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的，当有一个新的数据被访问时，就从链表头开始顺序遍历链表O(n)<br>* 1.如果此数据之前已经被缓存在链表中，遍历得到这个数据对应的结点O(n)，并将其从原来的位置删除O(1)，然后再插入到链表的头部O(1)<br>* 2.如果此数据没有被缓存在链表中，<br>    * 如果此时缓存未满，则将此结点直接插入到链表的头部O(1)<br>    * 如果此时链表已满，则链表尾结点删除O(1)，将新的数据结点插入链表的头部O(1)<br><br>==&gt;缓存访问的时间复杂度 O(n)<br><br>基于数组实现 LRU 缓存淘汰算法：<br>* 维护一个数组，排在越前的结点（位置越小）是越早之前访问的，当有一个新的数据被访问时，就从链表头开始顺序遍历链表O(n)<br>* 1.如果此数据之前已经在数组中，遍历得到这个数据对应的位置 O(n)，并将其从原来的位置删除 O(n)，然后在插入到数组尾部 O(1)<br>* 2.如果此数据不在数组中，<br>    * 如果此时缓存未满，则将此数据直接插入到数组尾部 O(1)<br>    * 如果此时缓存已满，则删除数组第一个元素 O(n)（涉及到后面的数据往前移），将新的数据插入到数组尾部 O(1)<br>==&gt;缓存访问的时间复杂度 O(n)<br><br>课后思考：判断一个通过单链表存储的字符串是否是回文串？相应的时空复杂度？<br>1.单链表变双链表<br>遍历单链表给每个节点新增一个前驱指针，直到尾结点，并得到链表结点数n。维护两个指针 p 和 q，分别指向头结点和尾结点，循环 n&#47;2 次比较，如果均相等则为回文串<br>时间复杂度 O(n)<br>空间复杂度 O(n)<br><br>2.快慢指针法<br>慢指针一次前进一格，并逆序。快指针一次前进两格。找到中点。两段链表进行比较<br>时间复杂度 O(n)<br>空间复杂度 O(1)<br>","like_count":0},{"had_liked":false,"id":179086,"user_name":"发霉的宅大人","can_delete":false,"product_type":"c1","uid":1738243,"ip_address":"","ucode":"6757E30FE5E48D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/03/95004954.jpg","comment_is_top":false,"comment_ctime":1581910834,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581910834","product_id":100017301,"comment_content":"看了很多评论的过程大致是<br>1、快慢两指针找寻链表中间点（注意分辨奇数偶数节点）<br>2、在找寻中间节点的过程中把前半段节点颠倒（比如&quot;level&quot;，找到中间节点时就是elvel）。<br>3、指向头结点的指针和中间节点的指针开始遍历比较。<br>时间复杂度：O(n)；因为慢指针要遍历链表<br>空间复杂度：O(1)；只有指针申请了空间<br>颠倒前半部分节点的操作可以当做把前半部分剥离出来，然后用头插法就能得到反序链表了。","like_count":0},{"had_liked":false,"id":178970,"user_name":"烈鸟","can_delete":false,"product_type":"c1","uid":1160050,"ip_address":"","ucode":"F568728E862D50","user_header":"https://static001.geekbang.org/account/avatar/00/11/b3/72/8c6366aa.jpg","comment_is_top":false,"comment_ctime":1581865049,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581865049","product_id":100017301,"comment_content":"我有个疑问，在数组vs链表大比拼那部分，说数组的插入&#47;删除操作时间复杂度是O(n)，时间主要浪费在挪数据上。链表的删除操作时间复杂度是O(1)，但是链表也是查找要删除哪个节点的，时间复杂度不还是O(n)么？何来性能更优一说呢","like_count":0},{"had_liked":false,"id":178136,"user_name":"起而行","can_delete":false,"product_type":"c1","uid":1131399,"ip_address":"","ucode":"4F116B0B740776","user_header":"https://static001.geekbang.org/account/avatar/00/11/43/87/7604d7a4.jpg","comment_is_top":false,"comment_ctime":1581596355,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1581596355","product_id":100017301,"comment_content":"1. 用数组实现LRU算法的思路和链表一样：array[新.....旧]<br> A. 未击中缓存，数组未满时：在array[0]的位置插入新元素<br> B. 未击中缓存，当数组满时：删除数组最后一个元素，在array[0]的位置插入新元素<br> C. 击中缓存，更新：在数组中删除该元素，将该元素插入到array[0]的位置<br>线性表是逻辑概念，所以链表与数组只是存储结构有区别。数组LRU算法的时间复杂度为O(n),空间复杂度为O(1)<br>2.回文字符串判断方法<br>A. 获取head指针指向链表头，tail指针指向链表尾，用count保存链表长度<br>B. While(head!=tail)<br>     头尾数据相同时：<br>     头尾向中间各移一位<br>     头尾数据不同时：<br>     返回（非回文串）<br>C while循环结束后，返回(回文串）<br>D 时间复杂度O(n),空间复杂度O（1）   <br>","like_count":0},{"had_liked":false,"id":176946,"user_name":"王jojo","can_delete":false,"product_type":"c1","uid":1812840,"ip_address":"","ucode":"1ABE7FA2614F86","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/68/ec442a70.jpg","comment_is_top":false,"comment_ctime":1581233126,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581233126","product_id":100017301,"comment_content":"查找前驱结点这个, 快慢指针+单链表也能搞笑实现双链表的效果吧","like_count":0},{"had_liked":false,"id":175369,"user_name":"未来怎样","can_delete":false,"product_type":"c1","uid":1652085,"ip_address":"","ucode":"4E54EB62595B27","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKORTofsU89GYKtywquzKuEiabvZnEOonfMYKuCPlo8GDlXqZuJdBicu0XtlaeodH4BnmHV1kldSAwQ/132","comment_is_top":false,"comment_ctime":1580695288,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580695288","product_id":100017301,"comment_content":"数组是连续的内存空间，对cpu缓存预读友好，但是正因为连续的内存空间，扩容需要进行数据拷贝，比较消耗性能，链表相反。<br>有一个问题：<br>双向链表因为有前驱节点，所以删除操作的时间复杂度是O(1)。而单向链表在查到具体需要删除的的元素之后，在进行删除的时候还需要再次查找该节点的前一个节点，所以时间复杂度是O(n)。我的问题是如果单向链表这么操作: if (p.next.key == key) {p.next = p.next.next}，这样操作的时间复杂度和双向链表的一样吧？","like_count":0},{"had_liked":false,"id":174924,"user_name":"明月关","can_delete":false,"product_type":"c1","uid":1298506,"ip_address":"","ucode":"F9464EEC269BFF","user_header":"https://static001.geekbang.org/account/avatar/00/13/d0/4a/187721e0.jpg","comment_is_top":false,"comment_ctime":1580460634,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580460634","product_id":100017301,"comment_content":"复制一份链表,反转，和之前的炼表进行对比，如果到尾部，一直相等，即是回文。<br>时间复杂度和空间复杂度都是O(n)","like_count":0},{"had_liked":false,"id":174862,"user_name":"谢真","can_delete":false,"product_type":"c1","uid":1124650,"ip_address":"","ucode":"8C3402DE107C9F","user_header":"https://static001.geekbang.org/account/avatar/00/11/29/2a/9079f152.jpg","comment_is_top":false,"comment_ctime":1580441380,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580441380","product_id":100017301,"comment_content":"学习到了用快慢指针找链表中央的方法","like_count":0},{"had_liked":false,"id":174699,"user_name":"搬铁少年ai","can_delete":false,"product_type":"c1","uid":1031045,"ip_address":"","ucode":"01D4A830A088D7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bb/85/191eea69.jpg","comment_is_top":false,"comment_ctime":1580355821,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580355821","product_id":100017301,"comment_content":"老师，insert不是list adt的接口，那我们实现链表的时候要实现insert吗","like_count":0},{"had_liked":false,"id":174418,"user_name":"马志远","can_delete":false,"product_type":"c1","uid":1480892,"ip_address":"","ucode":"AAD8875343E5FC","user_header":"https://static001.geekbang.org/account/avatar/00/16/98/bc/6d5affd3.jpg","comment_is_top":false,"comment_ctime":1580201645,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580201645","product_id":100017301,"comment_content":"06 | 链表（上）：如何实现LRU缓存淘汰算法?<br>一.why-为什么使用数组这种链表结构<br>1.历史介绍-来源维基百科<br>链表开发于1955-56，由当时所属于兰德公司（英语：RAND Corporation）的艾伦纽维尔（Allen Newell），克里夫肖（Cliff Shaw）和赫伯特西蒙（Herbert Simon）在他们编写的信息处理语言（IPL）中做为原始数据类型所编写。IPL被作者们用来开发几种早期的人工智能程序，包括逻辑推理机，通用问题解算器和一个计算机象棋程序。<br>手写单链表<br>https:&#47;&#47;zhuanlan.zhihu.com&#47;p&#47;87767060<br>时间复杂度分析<br>https:&#47;&#47;blog.csdn.net&#47;gaoxiangnumber1&#47;article&#47;details&#47;44634485<br>what-链表的概念&#47;定义<br>1.底层的存储结构: <br>数组需要一块连续的内存空间来存储，对内存的要求比较高。<br>链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用。<br>2.元素结构<br>链表串联零散内存块，节点除元素信息外，同时需要前后节点的地址信息。<br><br>三.how-怎样操作链表<br>1.删除操作<br>删除结点中“值等于某个给定值”的结点；定位O(n) 删除O(1)<br>删除给定指针指向的结点。定位 O(1) 删除非双向链表O(n) 双向链表O(1)<br><br>四.应用场景-单链表-循环链表-双向链表-双向循环链表<br><br>LRU<br>维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。<br>1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。<br>2. 如果此数据没有在缓存链表中，又可以分为两种情况：<br>如果此时缓存未满，则将此结点直接插入到链表的头部；如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部","like_count":0},{"had_liked":false,"id":171606,"user_name":"naku","can_delete":false,"product_type":"c1","uid":1528610,"ip_address":"","ucode":"B49EF5B5B38400","user_header":"https://static001.geekbang.org/account/avatar/00/17/53/22/cce9a2e5.jpg","comment_is_top":false,"comment_ctime":1578974665,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578974665","product_id":100017301,"comment_content":"花了小半天解决了实现了评论中的单链表中右半部分反转比较判断是否是回文串的方法。 <br>步骤:<br>1、遍历一遍确定字符个数 strlen<br>2、遍历一半长度找到左半部分的末尾位置 leftnodeend<br>3、定义Linknode, 如果strlen是奇数，那么linknode=leftnodeend. 否则 linknode=leftnodeend.next;<br>4、翻转右半部分，即linknode.next部分<br>   翻转思路: 将第一个node看做已经反转的，剩下的部分看做未翻转的。定义三个变量:fristNode，已翻转的部分第一个节点.lastnode已翻转的部分最后一个节点(该节点不变，一直是头结点，加上为了好理解)，nextNode【lastnode的下一个节点】，nextnextnode【lastnode的下下个节点】。初始化:firstNode=lastNode=第一个节点，nextNode=lastnode.next;   开始循环:因为nextnode不为null才可以求nextnextnode，所以nextnextnode的赋值是在循环中进行的，循环的判断条件就是nextnode不为null.<br>然后就是进行交换了. <br>         nextnextnode=lastnode.next.next;<br>          nextnode.next=firstnode;<br>          lastnode.next=nextnextnode;<br>          firstnode=nextnode;<br><br>循环结束后return firstnode就可以了<br>5、翻转时注意将firstnode赋值给linknode.next<br>6、进行比较，提前定义一个变量ret=true;  比较时如果出现不等情况ret=false,break即可<br>7、恢复<br>8、return ret<br>","like_count":0},{"had_liked":false,"id":171364,"user_name":"naku","can_delete":false,"product_type":"c1","uid":1528610,"ip_address":"","ucode":"B49EF5B5B38400","user_header":"https://static001.geekbang.org/account/avatar/00/17/53/22/cce9a2e5.jpg","comment_is_top":false,"comment_ctime":1578908102,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578908102","product_id":100017301,"comment_content":"评论区大佬多啊。 如果我写的话，可能就是把单链表转换成数组，同时从前后进行遍历来判断是否是回文字符串。  评论中用的多是空间复杂度更小，但操作更麻烦的方法，我怎么想不到他们的方法呢。<br><br>我看评论中还有实现约瑟夫环的，这篇文章中就一句话提到了，向你们学习。 今天任务把这两个题目实现一遍。课后思考的用空间复杂度O(1)的高级方法，加油","like_count":0},{"had_liked":false,"id":170104,"user_name":"再见孙悟空","can_delete":false,"product_type":"c1","uid":1025518,"ip_address":"","ucode":"57E12A2F9CD915","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a5/ee/6bbac848.jpg","comment_is_top":false,"comment_ctime":1578532212,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578532212","product_id":100017301,"comment_content":"链表<br><br>链表就像是玩解谜游戏时里面的线索，一开始会给你第一个线索，然后根据第一个线索解出谜题得到第二个线索。如果跳过第二个线索，你是得不出第三个线索的，也就是不支持随机访问。<br><br>数组<br>就像幼儿园的小朋友排排坐，老师给大家发零食，第一个小朋友，第二个小朋友，等老师可以一眼看出哪个小朋友没有零食，然后叫他来拿。因为他们的位置是连续的。","like_count":0},{"had_liked":false,"id":169407,"user_name":"hhk","can_delete":false,"product_type":"c1","uid":1138826,"ip_address":"","ucode":"72EC677FBDC79B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/gvfibNc3Bol6DzLMG5ia9wSLVYseoq326iae7TczmgmBj9u3Jwt8c0hl9KSzY4GNTFn0ic9m1ibzicqJ3aGzeQemec2Q/132","comment_is_top":false,"comment_ctime":1578328470,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578328470","product_id":100017301,"comment_content":"“最近最少使用” 这个翻译实在太拗口了  ","like_count":0},{"had_liked":false,"id":169112,"user_name":"王凯","can_delete":false,"product_type":"c1","uid":1746317,"ip_address":"","ucode":"3A8FE67E83E73F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/a5/8d/839becc5.jpg","comment_is_top":false,"comment_ctime":1578276332,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578276332","product_id":100017301,"comment_content":"快指针走一次，快指针与满指针之间就相差一步，走两次相差两步，差的部数就是两个指针的距离，这个距离恰巧等于慢指针走的部数，所以，可以通过快慢指针找到中间结点。不知道对不对","like_count":0},{"had_liked":false,"id":167888,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1640973,"ip_address":"","ucode":"2C0D1D26853DB3","user_header":"https://static001.geekbang.org/account/avatar/00/19/0a/0d/7bac5bcb.jpg","comment_is_top":false,"comment_ctime":1577957884,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577957884","product_id":100017301,"comment_content":"思路：定义快慢两个指针，满指针一次前进一个节点，快指针一次前进两个节点，当快指针下一次指向空的时候，慢指针指向了链表的中间位置，此时将快指针重新指向链表头，并以慢指针作为新表头反转剩下的链表，再同时遍历快慢指针（每次前进一个节点），比较是否是回文字符串<br>public class Main {<br>    private class ListNode {<br>        char val;<br>        ListNode next;<br>        ListNode(char x) {<br>            val = x;<br>        }<br>        ListNode(char[] arr) {<br>            if (arr == null || arr.length &lt; 1) {<br>                throw new IllegalArgumentException(&quot;Illegal arr. &quot;);<br>            }<br>            this.val = arr[0];<br>            ListNode cur = this;<br>            for (int i = 1; i &lt; arr.length; i++) {<br>                cur.next = new ListNode(arr[i]);<br>                cur = cur.next;<br>            }<br>        }<br>    public boolean isCycString(String str) {<br>        if (str.isEmpty()) {<br>            return true;<br>        }<br>        ListNode head = new ListNode(str.toCharArray());<br>        &#47;&#47;定义快慢指针<br>        ListNode slow = head;<br>        ListNode fast = head;<br>        &#47;&#47;偶数<br>        if (str.length() % 2 == 0) {<br>            while (fast.next.next != null) {<br>                slow = slow.next;<br>                fast = fast.next.next;<br>            }<br>            ListNode reverse = reverse(slow.next);<br>            fast = head;<br>            while (reverse != null) {<br>                if (reverse.val != fast.val) {<br>                    return false;<br>                }<br>                reverse = reverse.next;<br>                fast = fast.next;<br>            }<br>            return true;<br>        } else {<br>            &#47;&#47;奇数<br>            while (fast.next != null) {<br>                slow = slow.next;<br>                fast = fast.next.next;<br>            }<br>            ListNode reverse = reverse(slow);<br>            fast = head;<br>            while (fast != null) {<br> if (reverse.val != fast.val) {<br> return false;<br> }<br> fast = fast.next;<br> reverse = reverse.next;<br> }<br> return true;<br> }<br> }<br> &#47;&#47;反转链表<br>private ListNode reverse(ListNode head) {<br>ListNode newhead = null;<br>while (head != null) {<br>ListNode next = head.next;<br>head.next = newhead;<br>newhead = head;<br>head = next;}<br>return newhead;<br>}<br>}<br>有错误请大家指正","like_count":0},{"had_liked":false,"id":167854,"user_name":"幻灵尔依","can_delete":false,"product_type":"c1","uid":1620407,"ip_address":"","ucode":"F40BD2B906AB17","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLTQnQ7ZKZvsTfSg2iccRGvO3ibm2ds7k4FhbRDAZoSy6KQCBAZT9iborPC0xk494PPyCrmBuN6NEB0Q/132","comment_is_top":false,"comment_ctime":1577951561,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577951561","product_id":100017301,"comment_content":"链表在实现上不是连续的内存空间，是因为链表在插两项数据之间可能有别的内存存储操作吗？","like_count":0},{"had_liked":false,"id":167838,"user_name":"王先森","can_delete":false,"product_type":"c1","uid":1022267,"ip_address":"","ucode":"1AF1A395107479","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/3b/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1577947965,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577947965","product_id":100017301,"comment_content":"思考题这个用链表实现有点复杂了,翻转前后一样,利用取余数简单些...","like_count":0},{"had_liked":false,"id":167785,"user_name":"毛玉娇","can_delete":false,"product_type":"c1","uid":1249192,"ip_address":"","ucode":"BC0F0FEEEAD5DD","user_header":"https://static001.geekbang.org/account/avatar/00/13/0f/a8/5bec6811.jpg","comment_is_top":false,"comment_ctime":1577934014,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577934014","product_id":100017301,"comment_content":"需要知道，数组和链表是2中不同的底层数据结构，有不同的优劣。对于一个算法，我们应该选择合适的数据结构，那么代码实现就更会如鱼得水","like_count":0},{"had_liked":false,"id":167405,"user_name":"liyghting","can_delete":false,"product_type":"c1","uid":1108970,"ip_address":"","ucode":"439794ECEEFD26","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/ea/7d00f657.jpg","comment_is_top":false,"comment_ctime":1577784895,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577784895","product_id":100017301,"comment_content":"本节总结：链表 LinkedList 和数组一样，是基础的常用的数据结构，从底层的存储结构来看，使用内存结构和数组不一样，是用指针来将零散的内存块串联起来的，不是用一块连续的内存结构，因此就可以快速插入和删除，因为不需要保证内存使用的连续性。<br>常用的链表有单向链表、循环链表，双向链表，循环双向链表。<br>单向链表中有些概念：结点，结点中包含数据和后继指针，后继指针用于指向下一个结点，有两个特殊，头结点，尾结点指针指向null<br>循环链表：就是尾结点指向头节点，形成循环，如果数据是循环的话，可以用，比如解决约瑟夫问题<br>双向链表：就是结点中不止有后继指针，还有前驱指针，指向前一个结点，这样的结构在某些情况下查找比单向链表要快，比如有序单向链表，比如查找某个值，双向的话，可以先记录上次查找的位置p，查找时，比较大小，看从前往后查，还是从后往前查，有时可以减少一半的查找时间。这样其中就隐含了一种设计思想，以空间换时间，多存一个指针，意味着多占一份内存，却减少了查找的时间，所以在实际软件开发中，一般是用的双向链表。<br>还有其他的空间换时间的例子，比如各种缓存，CPU缓存，数据库缓存，浏览器缓存，CDN，把数据存到离用户最近的地方。<br><br>思考题<br>如何用数组实现LRU缓存淘汰策略？<br>维护一个有序的固定大小的数组，越靠近数组后面的就越是最新的数据，当有新的数据访问时，我们从数组头开始遍历<br>1，数据已经在数组中，找到他，移动后面的数据，他移动到末尾<br>2，数据不在数组中，又可以分为2种情况<br>2.1，没有超过缓存大小，追加到数组后面<br>2.2，超过缓存大小，移动首位以后的数据，在把数据追加到数组后面<br><br>其时间复杂度为O(n)，因为不管在不在缓存中，都要遍历一遍<br><br>假设字符串是用单向链表存储，如何判断是一个回文串？<br>使用快慢指针法来遍历，慢指针前进一步，快指针前进两步，快指针指向null时，找到链表中点<br>比较中点和中点后结点相等，则为字符串长度偶数，否则为奇数<br>偶数时，再次从头开始遍历到中点，遍历的同时逐一比较，另一个结点从中点后一个开始，<br>奇数时，再次从头开始遍历到中点前一个，遍历的同时逐一比较，另一个结点也从中点后一个开始<br><br>时间复杂度为O(n),空间复杂度为O(1),<br>我看留言中，有说空间复杂度为O(n)，这个是基于一个前提，从头开始实现单链表，在用单链表来存储字符串，再来判断是否回文。<br>如果单讲判断是否回文这个方法，这样空间复杂度就是O(1)。","like_count":0},{"had_liked":false,"id":167390,"user_name":"pikachu122","can_delete":false,"product_type":"c1","uid":1689365,"ip_address":"","ucode":"43FE4DBC872FFA","user_header":"https://static001.geekbang.org/account/avatar/00/19/c7/15/24bf166a.jpg","comment_is_top":false,"comment_ctime":1577782462,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577782462","product_id":100017301,"comment_content":"如何利用数组实现 LRU 缓存淘汰策略：<br>建立一个一定长度的数组，如果一个数据没有在数组中，则加在第一位，把原数组的所有数据向后挪一位<br>如果在数组中，把它放到第一位，所有它原先位置之前的数据往后挪一位，时间复杂度都为O(n)。数组满了的时候删除最后一位，时间复杂度为O(1)。<br><br>如何判断一个字符串是否是回文字符串：<br>还没有看其他人的答案，只想到一个笨办法。 先遍历一遍链表得到数字的个数，然后每次分别比较第一个数和第n个数，第2个数和第n-1个数，...，直至比较到n&#47;2为止全部相等。该操作需要的时间复杂度为O(n^2)，空间复杂度为O(1)。","like_count":0},{"had_liked":false,"id":167233,"user_name":"隰有荷","can_delete":false,"product_type":"c1","uid":1357944,"ip_address":"","ucode":"2BE9A32AB28963","user_header":"https://static001.geekbang.org/account/avatar/00/14/b8/78/2828195b.jpg","comment_is_top":false,"comment_ctime":1577724069,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577724069","product_id":100017301,"comment_content":"有个疑问，既然是删除或插入链表中的某一个数据，那不是要先知道这个数据的地址吗，不需要先从基地址那里顺着链表找到这个数据以后才能执行删除吗？如果是这样时间复杂度不是O（n）吗","like_count":0},{"had_liked":false,"id":165950,"user_name":"ericlf","can_delete":false,"product_type":"c1","uid":1242217,"ip_address":"","ucode":"08345AB709CB60","user_header":"https://static001.geekbang.org/account/avatar/00/12/f4/69/be6c8fc1.jpg","comment_is_top":false,"comment_ctime":1577349765,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577349765","product_id":100017301,"comment_content":"LRUBasedArray.java中的removeAndCache目前的逻辑应该固定删除数组最末尾的元素然后插入到数组最前面，但我们需要的应该是删除object所在下标的元素，然后插入到数组最前面<br>public void removeAndCache(T object) {<br>        T key = value[--count];<br>        holder.remove(key);<br>        cache(object, count);<br>    }","like_count":0},{"had_liked":false,"id":164746,"user_name":"别看我，学习呢","can_delete":false,"product_type":"c1","uid":1792573,"ip_address":"","ucode":"5485C64247766C","user_header":"https://static001.geekbang.org/account/avatar/00/1b/5a/3d/40871fb6.jpg","comment_is_top":false,"comment_ctime":1577085311,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577085311","product_id":100017301,"comment_content":"链表和数组是相对的数据结构<br>数组是连续的空间，而链表是零散的空间，为了保证这个离散的空间在逻辑上是连续的，能连成一片，所以每个离散空间会存储下一个离散空间的地址（有时还有上一个地址），所以对每个点来说，只能访问前一个点和后一个点，这样就不能随机访问，而是遍历访问了<br>正是由于下一个元素的位置，由上一个元素存储地址，所以增删元素就很简单，更改上一个元素存储的地址就可以了，而不用像数组要大量移动，其他元素还在内存中原来的位置，知识上一个元素存储的地址更改了，下一个元素的地址有新的元素存储。<br>这样一环扣一环的锁链就很考验程序员的逻辑，如果赋值顺序错位的话，就会丢失节点。所以在增删元素的时候要小心赋值语句的顺序","like_count":0},{"had_liked":false,"id":164349,"user_name":"耀","can_delete":false,"product_type":"c1","uid":1634462,"ip_address":"","ucode":"3692BEC242A399","user_header":"https://static001.geekbang.org/account/avatar/00/18/f0/9e/cf6570f7.jpg","comment_is_top":false,"comment_ctime":1576942696,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576942696","product_id":100017301,"comment_content":"判断回文，可以从两边到中间，这显然对单链表不适用。对于数组和双链表适用。单链表适合先找到中点。要找到中点，又要有一半逆序访问。<br>找中点的办法简单，从头结点出发，使用两个指针遍历，一个速度是另外的一个的两倍，这样一个遍历到尾部的时候，一个正好在中点。<br>而逆序访问的问题，可以在慢的指针找中点的过程中，遍历一个调整一个指针的指向，遍历到中点的时候，这时候逆序就变成顺序了，在中点两个指针分别向两头遍历比较。<br>从中点往开头遍历的节点需要再次调整指针的指向，这样前半部分的指针被调整了两次指向，恢复到了原来的指向。时间复杂度O(n) ,空间复杂度O(1)","like_count":0},{"had_liked":false,"id":161658,"user_name":"巴西","can_delete":false,"product_type":"c1","uid":1119116,"ip_address":"","ucode":"6E68AA02011541","user_header":"https://static001.geekbang.org/account/avatar/00/11/13/8c/c86340ca.jpg","comment_is_top":false,"comment_ctime":1576288533,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576288533","product_id":100017301,"comment_content":"动手实现了一下课后思考题https:&#47;&#47;github.com&#47;84yy&#47;algorithm&#47;commit&#47;59d946a676e81383b2c07a865446e9de8a2cbb7d","like_count":0},{"had_liked":false,"id":161108,"user_name":"灰灰","can_delete":false,"product_type":"c1","uid":1122397,"ip_address":"","ucode":"907A2FD339E158","user_header":"https://static001.geekbang.org/account/avatar/00/11/20/5d/69170b96.jpg","comment_is_top":false,"comment_ctime":1576119824,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576119824","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":160869,"user_name":"D0 N0W","can_delete":false,"product_type":"c1","uid":1602108,"ip_address":"","ucode":"F7A82748E15BAA","user_header":"https://static001.geekbang.org/account/avatar/00/18/72/3c/b5c70806.jpg","comment_is_top":false,"comment_ctime":1576050868,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576050868","product_id":100017301,"comment_content":"如果遍历后发现已存在，则将该元素之前的元素都向后移一个，将该元素插入到第一个位置；<br>如果不存在，且缓存满了，将最后一个元素删除，所有元素向后移一个，将新元素插入到第一个位置，如果缓存未满，直接将所有元素后移一个，将新元素插入到第一个位置","like_count":0},{"had_liked":false,"id":159692,"user_name":"HoshinoKanade","can_delete":false,"product_type":"c1","uid":1770245,"ip_address":"","ucode":"AA8B4F90FB9E5F","user_header":"https://static001.geekbang.org/account/avatar/00/1b/03/05/140068f9.jpg","comment_is_top":false,"comment_ctime":1575729383,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575729383","product_id":100017301,"comment_content":"不知道為何留言倒是很少討論時間換空間或者空間換時間的例子<br>可能是鏈表很難 應該是說應用很難 快慢指針開出來比老師還颿車<br>像我這種解題從來就array, dictionary跑天下很少會想起linked list...<br><br>回正題<br>空間換時間: 資料庫索引<br>如果沒有索引一句SQL能跑到天亮吧...<br><br>時間換空間: 檔案流<br>不如道是不是貼切的例子<br>有時資料太多 不會一次全加載到內存<br>這時候檔案流比較有用<br>另外就是各種壓縮的應用 不只是不動的數據<br>呼叫API很常會回傳回來一個GZIP<br>但是這裡想提問 為何像web這些對反應速度感冒的應用還會使用壓縮算法?","like_count":0},{"had_liked":false,"id":159276,"user_name":"明月","can_delete":false,"product_type":"c1","uid":1476588,"ip_address":"","ucode":"D3C649B954A519","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJayib1ZcRfOaoLsdsWZokiaO5tLAdC4uNAicQJRIVXrz9fIchib7QwXibnRrsJaoh5TUlia7faUf36g8Bw/132","comment_is_top":false,"comment_ctime":1575594244,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575594244","product_id":100017301,"comment_content":"老师 我认为单链表也可以达到第二种情况下O（1）的时间复杂度 用一个单独的临时变量存储上一个节点和下一个节点 这样就可以达到双向链表同样的效果 我这样子说对吗","like_count":0},{"had_liked":false,"id":158487,"user_name":"大禾","can_delete":false,"product_type":"c1","uid":1742323,"ip_address":"","ucode":"841369DDF985A8","user_header":"https://static001.geekbang.org/account/avatar/00/1a/95/f3/2fcbeb0a.jpg","comment_is_top":false,"comment_ctime":1575382328,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575382328","product_id":100017301,"comment_content":"&#47;&#47; 回文判断 go实现,时间复杂度O(n),空间复杂度O(1)<br>&#47;&#47; https:&#47;&#47;github.com&#47;andavid&#47;leetcode-java&#47;tree&#47;master&#47;note&#47;234 参考文章<br><br>func isPalindrome(list *linkedList) bool {<br>\tr := true<br>\t&#47;&#47;慢指针移动并反转目前的对象<br>\t&#47;&#47;快指针没有下一个结点（偶数）或者下一个结点的下一个结点（奇数）时停止<br>\tvar fast, slow, slownew *linkedList<br>\tslow = list<br>\tfast = list<br>\tslownew = list.next<br>\tfor fast.next != nil &amp;&amp; fast.next.next != nil { &#47;&#47;O(n&#47;2)<br>\t\tfast = fast.next.next<br>\t\tslownew = slow.next      &#47;&#47;待处理链表b后,要移动结点<br>\t\tslow.next = slownew.next &#47;&#47;断开bc连ac,要移动结点后的待处理结点由slow保持，待下个循环获取<br>\t\tslownew.next = list      &#47;&#47;断开结点放到首位，对断开的节点slownew来说原来list已经找不到slownew结点<br>\t\tlist = slownew           &#47;&#47;最新值回填回去，否则list会逐渐少值<br>\t}<br>\t&#47;&#47;原来慢指针根据奇偶判断中间结点，新的慢指针指向头，两个指针共同往后移动，对比每个结点值都一样确认时为回文<br>\t&#47;&#47;O(n&#47;2)<br>\tif fast.next == nil { &#47;&#47;奇数，已经到链尾<br>\t\t&#47;&#47;已经把中心结点移到链首，slow.next结点为回文后半部分结点<br>\t\tfor n0, n1 := slow.next, slownew.next; n0 != nil; n0, n1 = n0.next, n1.next {<br>\t\t\tif n0.data != n1.data {<br>\t\t\t\tr = false<br>\t\t\t\tbreak<br>\t\t\t}<br>\t\t}<br>\t} else { &#47;&#47;偶数<br>\t\tfor n0, n1 := slow.next, slownew      ; n0 != nil; n0, n1 = n0.next, n1.next {<br>\t\t\tif n0.data != n1.data {<br>\t\t\t\tr = false<br>\t\t\t\tbreak<br>\t\t\t}<br>\t\t}<br>\t}<br>\treturn r<br>}<br><br>type linkedList struct {<br>\tdata interface{}<br>\tnext *linkedList<br>}<br><br>func (l *linkedList) append(d []interface{}) {<br>\ttl := l<br>\tfor _, t := range d {<br>\t\ttl.data = t<br>\t\tv := &amp;linkedList{}<br>\t\ttl.next = v<br>\t\ttl = v<br>\t}<br>\tfor t := l.next; t != nil; { &#47;&#47;remove last<br>\t\tte := t.next<br>\t\tif tl == te {<br>\t\t\tt.next = nil<br>\t\t\tbreak<br>\t\t}<br>\t\tt = te<br>\t}<br>}<br><br>func main() {<br>\ti := []interface{}{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;}<br>\tlist := createASingleLinkedList(i)<br>\tfmt.Println(&quot;是否回文&quot;, isPalindrome(&amp;list)) &#47;&#47;true<br>\ti = []interface{}{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}<br>\tlist = createASingleLinkedList(i)<br>\tfmt.Println(&quot;是否回文&quot;, isPalindrome(&amp;list)) &#47;&#47;false<br>\ti = []interface{}{&quot;a&quot;, &quot;b&quot;, &quot;a&quot;} &#47;&#47;true<br>\ti = []interface{}{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;}&#47;&#47;false<br>\ti = []interface{}{&quot;a&quot;, &quot;a&quot;} &#47;&#47;true<br><br>}<br><br>func createASingleLinkedList(i []interface{}) linkedList {<br>\tlist := linkedList{}<br>\tlist.append(i)<br>\treturn list<br>}","like_count":0},{"had_liked":false,"id":157984,"user_name":"对方正在输入...","can_delete":false,"product_type":"c1","uid":1074186,"ip_address":"","ucode":"B010A161A83300","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/0a/26cb0133.jpg","comment_is_top":false,"comment_ctime":1575294946,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575294946","product_id":100017301,"comment_content":"数组和链表的区别<br>1.时间复杂度不同<br>数组支持随机访问，根据数组随机访问的时间复杂度是O(1)，根据元素内容查找时间复杂度为O(n)，插入删除操作需要做搬移，所以也是O(n)，<br>而链表随机访问第k个元素没有数组那么高效，需要根据指针一个节点一个节点的依次遍历，所以查找的时间复杂度为O(n)，但插入删除不需要数据搬移所以是O(1)。<br>2.底层的存储结构不同<br>数组需要一块连续的内存空间，对内存的要求比较高<br>链表恰恰相反，不需要连续的内存空间，它通过指针将一组零散的内存块串联起来。<br>3.动态扩容<br>数组的缺点是内存固定，一经申明就要占用整块连续内存空间，若声明过大，系统可能没有足够的连续内存空间分配给它，就会导致“内存资源不足”，若声明过小，可能出现不够用的情况，就需要申请更大的内存空间，把原数组拷贝到进去，非常耗时。<br>而链表天然支持动态扩容，大小不受限制。<br>4.应用场景<br>数组适用于以下场景:<br>a.对内存的使用比较苛刻，比如手机或单片机，内存不大的系统中。使用以时间换空间的设计思路。<br>链表适用于以下场景:<br>a.需要频繁删除、插入操作。使用以空间换时间的设计思路","like_count":0},{"had_liked":false,"id":157926,"user_name":"小遥子","can_delete":false,"product_type":"c1","uid":1754666,"ip_address":"","ucode":"E2CCF654F4F9D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/c6/2a/e6281f10.jpg","comment_is_top":false,"comment_ctime":1575283792,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575283792","product_id":100017301,"comment_content":"LRU的数组实现：<br>设置静态变量n，初始化为0；<br>查询A时，如果n＝0，直接插入，否则遍历数组查找A，找到了则将A之前的数据都往后移一位，没找到则将前n－1个数后移一位，将A放到第一位。<br>回文字符串判断：<br>ps:题目的意思有点没看懂，在这里我假设每个节点存储一个字母<br>将两个存储字符串的链表从第一个字母开始做比较直到最后一个，中间如果有不相同的情况直接返回-1(代表错误)，比较到最后返回0(代表正确)。<br>","like_count":0},{"had_liked":false,"id":157698,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1575248389,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575248389","product_id":100017301,"comment_content":"链表：<br>\t1，链表的经典应用场景：LRU缓存淘汰算法。<br><br>\t2，缓存的常用三种淘汰策略：先进先出策略FIFO(First In，First Out)，最少使用策略LFU(Least Frequently Used)，最近最少使用策略LRU(Least Recently Used)。<br><br>3，链表的常见的三种结构：单链表，双向链表和循环链表<br>\t循环链表：是一种特殊的单链表。<br>\t双向链表：在实际开发中比单向链表更加常用。<br>\t\t（1）存储同样多的数据，双向链表要比单链表占用更多的内存空间。<br>\t\t（2）从结构上看，双向链表可支持O(1)时间复杂度的查找前驱结点，这个特点使双向链表在某些情况下的插入，删除等操作都要比单链表简单，高效。<br>\t\t（3）删除：<br>对于删除结点中“值等于某个给定值”的结点，操作的总时间复杂度为O(n)。<br>删除给定指针指向的结点，单链表删除操作需要O(n)的时间复杂度，而双向链表的时间复杂度为O(1) <br>\t\t（4）对于一个有序链表，双向链表按值查询的效率也有比单链表高，平均只要查找一半的数据。<br><br>4，LinkedHashMap的实现原理，其中就用到了双向链表这种数据结构。<br><br>5，链表 与 数组性能对比：<br>\t（1）数组和链表是两种截然不同的内存组织方式，正是因为内存存储的区别，他们插入，删除，随机访问操作的时间复杂度正好相反。<br>\t（2）数组简单易用，使用连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对CPU缓存不友好，无法有效预读。<br>\t（3）数组的缺点是大小固定，已经声明就要占用整块连续内存空间。如果声明数组过大，系统没有足够的连续空间分配给它，导致“内存不足”，声明过小则可能不够用，这时只能申请更大的内存空间，把原数组拷贝进去，非常费时。<br>\t\t链表本身没有大小限制，天然支持动态扩容。<br>\t（4）若对内存的使用非常苛刻，数组更合适，因为链表中的每个结点都需要消耗额外的存储空间去存储指针，内存翻倍。并且对链表进行频繁的插入，删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，若是java，就可能触发频繁的GC。<br>\t<br>6，数组实现LRU缓存淘汰策略<br>\tA ：首位置保存最新访问数据，末位置优先清理<br>\t（1）当访问的数据未存于缓存的数组中时，直接将数据插入数组第一个元素位置，此时数组所有元素需要向后移动1个位置，时间复杂度为O(n)；<br>\t（2）当访问数据存于缓存的数组中时，查找到数据并将其插入数组的第一个位置，此时亦要移动数组元素，时间复杂度为O(n)。<br>\t（3）缓存用满时，清理末位的数据，时间复杂度为O(1)。<br>\tB ：首位置优先清理，末位置保存最新访问数据<br>\t（1）当访问数据未被缓存时，直接讲数据添加进数组末位，时间复杂为O(1)。<br>\t（2）当访问数据已被缓存时，查找到数据并将其插入数组末位，此时需要移动数据元素位置，时间复杂度为O(n)<br>\t（3）缓存用满时，清理末位的数据，时间复杂度为O(1)<br>7 链表实现LRU缓存淘汰策略<br>\t（1）当访问数据不在缓存中时，直接将数据插入链表表头，时间复杂度为O(1);<br>\t（2）当访问数据在缓存中时，将该数据对应的节点，插入到链表表头，时间复杂度为O(n).<br>\t（3）如果缓存占满，则从链表尾部的数据开始清理，时间复杂度为O(1).<br>","like_count":0},{"had_liked":false,"id":157405,"user_name":"浑浑噩噩cium","can_delete":false,"product_type":"c1","uid":1617939,"ip_address":"","ucode":"358C0BCFF62B40","user_header":"https://static001.geekbang.org/account/avatar/00/18/b0/13/5cb3459c.jpg","comment_is_top":false,"comment_ctime":1575133390,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575133390","product_id":100017301,"comment_content":"数组解决LRU:<br>申请两个变量:<br>一个保存数组长度lenght;<br>一个保存添加数据的位置pos，初始化为0;<br>添加方式:添加到pos位置，然后pos加1，如果pos==lenght，则令pos=0，即可。<br>这样时间复杂的度O(1)。","like_count":0},{"had_liked":false,"id":157372,"user_name":"攀","can_delete":false,"product_type":"c1","uid":1686829,"ip_address":"","ucode":"4E126AD22A43B1","user_header":"https://static001.geekbang.org/account/avatar/00/19/bd/2d/d4ea6b52.jpg","comment_is_top":false,"comment_ctime":1575123959,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575123959","product_id":100017301,"comment_content":"双向链表删除指定指针指向的数据的优越性，我的理解是，删除数据后，需要将断掉的前后两段重新接起来，而单链表仅next指针已知，prev未知，没办法重连，因此需要遍历","like_count":0},{"had_liked":false,"id":157224,"user_name":"技术修行者","can_delete":false,"product_type":"c1","uid":1013147,"ip_address":"","ucode":"28CA41A1214D6B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/9b/611e74ab.jpg","comment_is_top":false,"comment_ctime":1575088419,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1575088419","product_id":100017301,"comment_content":"思维导图：https:&#47;&#47;mubu.com&#47;doc&#47;khCxXorSG0<br><br>思考题：快慢指针方法，时间复杂度O（n），空间复杂度O（1）","like_count":0},{"had_liked":false,"id":157156,"user_name":"HoSalt","can_delete":false,"product_type":"c1","uid":1156074,"ip_address":"","ucode":"610B03E2A002D1","user_header":"https://static001.geekbang.org/account/avatar/00/11/a3/ea/53333dd5.jpg","comment_is_top":false,"comment_ctime":1575046922,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575046922","product_id":100017301,"comment_content":"「除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据」 个人感觉这个双链表并没有优势，因为单链表可以根据查找的值与 p 的大小关系，决定是往头开始还是往后查找，不知道这样理解对不对","like_count":0},{"had_liked":false,"id":157142,"user_name":"追风筝的人","can_delete":false,"product_type":"c1","uid":1488020,"ip_address":"","ucode":"2993D60F94C396","user_header":"https://static001.geekbang.org/account/avatar/00/16/b4/94/2796de72.jpg","comment_is_top":false,"comment_ctime":1575041023,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575041023","product_id":100017301,"comment_content":"快慢双指针，一个指针一次走2步，另一个走2步","like_count":0},{"had_liked":false,"id":156983,"user_name":"微凉","can_delete":false,"product_type":"c1","uid":1178156,"ip_address":"","ucode":"F6BD0AE11AE224","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/2c/9a0c45e6.jpg","comment_is_top":false,"comment_ctime":1575008753,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575008753","product_id":100017301,"comment_content":"1. 新数据插入到链表头部（如果链表已满则先删除尾部节点再插入新数据到链表头部）；<br>2. 每当缓存命中（即缓存数据被访问），则将数据移到链表头部（原位置数据删除）；<br>3. 当链表满的时候，将链表尾部的数据丢弃。","like_count":0},{"had_liked":false,"id":156729,"user_name":"big智慧","can_delete":false,"product_type":"c1","uid":1202616,"ip_address":"","ucode":"272C32E19EAE1A","user_header":"https://static001.geekbang.org/account/avatar/00/12/59/b8/2a4624c3.jpg","comment_is_top":false,"comment_ctime":1574942982,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574942982","product_id":100017301,"comment_content":"打卡Day4：<br>1、日期：<br>* 2019年11月28日<br><br>2、是什么<br>* 链表是存储在非连续内存上。 存储内容为数据+结点地址（next或者next、preview等）<br><br>3、为什么<br>* 链表支持动态扩容 <br>* 删除给定指针结点或定指针结点后插入数据，两种情况的时间复杂度为O(1)  <br>4、什么场景适合<br>* 在需要频繁插入和删除的场景选择链表 <br>* 可以牺牲空间换取时间的场景可以选择<br>* 在可能需要动态扩容的场景选择  <br>5、数组、链表的选择，在项目管理场景下的思考<br>* “链表”思路：加班（996、007）、加人来赶工期，其实投入的时间和人力并不能带来线性的提升，就像10个人不能1个月生出孩子来，但是在时间高要求的场景下可以拿成本换时间<br>* “数组”思路：在固定的时间段内，安排相同颗粒度大小、清晰的任务项，确保任务的熟悉、获取成本最小化，从而来保证效率最大化  <br>6、对应项目管理的关键点：<br>* 任务的标准、任务的拆解、固定的机制","like_count":0},{"had_liked":false,"id":156585,"user_name":"testerman","can_delete":false,"product_type":"c1","uid":1473556,"ip_address":"","ucode":"8DDC62262FA5DE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoDbVIx6bXBFTCDtBUPXzIJzEiaSCfjP7wRA95dGIAGJRnOCutFcIRFkEaUqrEF2fE0HJ1WaFsKn8w/132","comment_is_top":false,"comment_ctime":1574917849,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574917849","product_id":100017301,"comment_content":"插入删除的前提是得找到操作点，从这点来看，插入删除的整体时间复杂度=查找复杂度+更新复杂度，这样算数组和链表是不是就都变成O(n)了？","like_count":0},{"had_liked":false,"id":156520,"user_name":"SteveYang","can_delete":false,"product_type":"c1","uid":1754829,"ip_address":"","ucode":"C42BCA4F40A9EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKCbnOvEatUN4ysE2cl6zJNoAJVXXuQVhicQ1jxh6Z2Towrmmc1I6PndaicuQQ0RyyJPyJQicv4tSib9Q/132","comment_is_top":false,"comment_ctime":1574905386,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574905386","product_id":100017301,"comment_content":"使用快慢指针，慢指针每次走一步，快指针每次走两步，当快指针走到底，慢指针就走到中点。在慢指针前进过程中进行反序。遍历中点两边的链表判断是否相等。时间复杂度：O(n)，空间复杂度：O(1)。","like_count":0},{"had_liked":false,"id":156488,"user_name":"梦想的优惠券","can_delete":false,"product_type":"c1","uid":1257418,"ip_address":"","ucode":"D3B44F6C618CA7","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/ca/cbce6e94.jpg","comment_is_top":false,"comment_ctime":1574902150,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1574902150","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":156462,"user_name":"刘丶小备","can_delete":false,"product_type":"c1","uid":1102106,"ip_address":"","ucode":"F4D5EF592B7030","user_header":"https://static001.geekbang.org/account/avatar/00/10/d1/1a/3564c9da.jpg","comment_is_top":false,"comment_ctime":1574896553,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574896553","product_id":100017301,"comment_content":"思考题：可以使用快慢指针来判断。时间复杂度是O(n)，空间复杂度是O(1)","like_count":0},{"had_liked":false,"id":156350,"user_name":"在路上","can_delete":false,"product_type":"c1","uid":1143372,"ip_address":"","ucode":"335960F683C23C","user_header":"https://static001.geekbang.org/account/avatar/00/11/72/4c/4d636a23.jpg","comment_is_top":false,"comment_ctime":1574860801,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574860801","product_id":100017301,"comment_content":"数组来实现LRU缓存策略：最靠近数组尾部的数是最早访问的，当访问一个新数字时，从头开始访问<br>1. 当数字在数组中时，删除其中的数据，并将前面的往后移动，头部插入新数字，移动数据时间复杂度是O(n)<br>2. 当数字不在数组中时<br>    数组空间未满，直接将数据往后移动，头部插入新数字，时间复杂度未O(n)<br>    数组空间已满，新建一个更大的数组，将新数字插在第一位，旧数组数据一一往后拷贝，拷贝完成后请空旧数据，时间复杂度也是为O(n)","like_count":0},{"had_liked":false,"id":156343,"user_name":"NEVER SETTLE","can_delete":false,"product_type":"c1","uid":1101894,"ip_address":"","ucode":"9C86BDAFDBF768","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","comment_is_top":false,"comment_ctime":1574859333,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574859333","product_id":100017301,"comment_content":"学习笔记：<br><br>1、经典的链表应用场景：LRU 缓存淘汰算法。<br>      常见的缓存淘汰策略：<br>先进先出策略 FIFO（First In，First Out）<br>最少使用策略 LFU（Least Frequently Used）<br>最近最少使用策略 LRU（Least Recently Used）<br><br>2、链表是逻辑上连续，但物理上不需要连续的线性结构。<br><br><br>3、三种最常见的链表结构：单链表、双向链表和循环链表。<br><br>4、单链表<br>链表通过指针将一组零散的内存块串联在一起。<br>内存块称为链表的“结点”。<br>每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址，<br>这个这个记录下个结点地址的指针叫作后继指针 next。<br>链表第一个节点叫作头结点，最后一个结点叫作尾结点。<br>头结点用来记录链表的基地址。<br>尾结点的后继指针是指向一个空地址 NULL 。<br><br>链表的插入和删除操作，只需要把相邻结点的指针改变，时间复杂度是 O(1)。<br><br>链表要随机访问第 k 个元素，需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点，（链表中的数据并非连续存储的）时间复杂度是 O(n)。<br><br>5、循环链表<br>循环链表是一种特殊的单链表。<br>循环链表与单链表唯一的区别就在尾结点，<br>循环链表的尾结点指针是指向链表的头结点。<br><br>和单链表相比，循环链表的优点是从链尾到链头比较方便。<br>当要处理的数据具有环型结构特点时，就特别适合采用循环链表。（约瑟夫问题）<br><br>6、双向链表<br>双向链表支持两个方向，每个结点有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。<br>双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。<br>如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。<br>虽然两个指针比较浪费存储空间，但可以支持双向遍历，带来了操作的灵活性。<br>双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点。<br><br>7、链表的删除操作<br>1). 删除结点中“值等于某个给定值”的结点；<br>遍历查找要删除结点时间复杂度为 O(n)，删除操作时间复杂度是 O(1)，<br>总时间复杂度为 O(n)。<br><br>2). 删除给定指针指向的结点。<br>要删除的某个结点， 需要知道其前驱结点。<br>单链表不支持直接获取前驱结点，需要从头结点开始遍历链表，<br>找到其前驱结点，时间复杂度为 O(n)。<br>双向链表中的结点已经保存了前驱结点的指针，时间复杂度为 O(1)。<br><br>插入操作与删除操作同理。<br><br>8、有序链表查找<br>双向链表的按值查询的效率也要比单链表高。<br>每次记录上次查找的位置，根据这次查找的值与上次查找值的大小关系，<br>决定是往前还是往后查找，所以平均只需要查找一半的数据。<br><br>9、用空间换时间<br>当内存空间充足的时候，如果要求代码的执行速度，可以选择空间复杂度相对较高、\t<br>但时间复杂度相对很低的算法或者数据结构。<br>当内存比较紧缺，采用时间换空间的设计思路。<br>缓存实际上就是利用了空间换时间的设计思想。<br><br>10、双向循环链表<br><br>11、链表与数组性能比拼<br><br>在实际的软件开发中，不能仅仅利用复杂度分析就决定使用哪个数据结构来存储数据。<br><br>数组的缺点：大小固定，一经声明就要占用整块连续内存空间。<br>如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，<br>导致“内存不足（out of memory）”。<br>如果声明的数组过小，则可能出现不够用的情况。<br>这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。<br><br>链表的缺点：每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。<br>对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，可能会导致频繁的 GC。<br><br>12、如何基于链表实现 LRU 缓存淘汰算法？<br>维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。<br>当有一个新的数据被访问时，需要从链表头开始顺序遍历链表。<br>1). 如果此数据之前已经被缓存在链表中，遍历得到这个数据对应的结点，<br>     并将其从原来的位置删除，然后再插入到链表的头部。<br>2). 如果此数据没有在缓存链表，又可以分为两种情况：<br>如果此时缓存未满，则将此结点直接插入到链表的头部；<br>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。<br><br>不管缓存有没有满，都需要遍历一遍链表，所以缓存访问的时间复杂度为 O(n)。<br>可以引入散列表来记录每个数据的位置，将缓存访问的时间复杂度降到 O(1)。<br><br>","like_count":0},{"had_liked":false,"id":156313,"user_name":"迩、卜懂莪","can_delete":false,"product_type":"c1","uid":1754378,"ip_address":"","ucode":"0EA96E6A89F3A1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/c5/0a/c7267f5b.jpg","comment_is_top":false,"comment_ctime":1574855514,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574855514","product_id":100017301,"comment_content":"循环链表看怎么理解了<br>关于循环链表是一种特殊的单向链表这句话没错<br>不过循环链表 -可以分为 单向循环链表和双向循环链表,换个角度又是另外一种说法","like_count":0},{"had_liked":false,"id":156154,"user_name":"Rickieslove","can_delete":false,"product_type":"c1","uid":1751095,"ip_address":"","ucode":"47A1A53F2E1FAE","user_header":"https://static001.geekbang.org/account/avatar/00/1a/b8/37/d22456d5.jpg","comment_is_top":false,"comment_ctime":1574825762,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574825762","product_id":100017301,"comment_content":"为什么说链表插入时简单的呢？是插入操作简单吧，首先的知道往哪插吧，数值根据索引就知道往哪里插入，链表如果不是向头&#47;尾部插入的话是不是要遍历？那我感觉一样很烦啊？<br>&#47;&#47;奇数偶数感觉不用管<br>public class Node {<br>    private Node next;<br>    private String value;<br>    public Node(String value) {<br>        this.value = value;<br>    }<br>    public static void main(String[] args){<br>        Node node1 = new Node(&quot;1&quot;);<br>        Node head = node1;<br>        node1.next = new Node(&quot;2&quot;);<br>        node1.next.next = new Node(&quot;8&quot;);<br>        node1.next.next.next = new Node(&quot;10&quot;);<br>        node1.next.next.next.next = new Node(&quot;82&quot;);<br>        node1.next.next.next.next.next = new Node(&quot;2&quot;);<br>        node1.next.next.next.next.next.next = new Node(&quot;1&quot;);<br>        System.out.println(isHuiWen(head));<br>    }<br>    public static Node reverse(Node head){<br>        if (null==head||null==head.next)<br>        return head;<br>        Node pre = null;<br>        Node cur = head;<br>        Node tmp = null;<br>        while (null!=cur){<br>            tmp = cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = tmp;<br>        }<br>        return pre;<br>    }<br>    public static boolean isHuiWen(Node node) {<br>        Node head = node;<br>        Node tail;<br>        Node step1 = node;<br>        Node step2 = node;<br>        Node mid = null;<br>        while(step2!=null){<br>            if (step2.next==null||step2.next.next==null){<br>                mid = step1;<br>                break;<br>            }else{<br>                step1 = step1.next;<br>                step2 = step2.next.next;<br>            }<br>        }<br>        tail = reverse(mid);<br>        if (head.value!=tail.value)<br>            return false;<br>        while (head!=mid&amp;&amp;tail!=mid){<br>            if (head.value!=tail.value)<br>                return false;<br>            head = head.next;<br>            tail = tail.next;<br>        }<br>        return true;<br>    }<br>}","like_count":0},{"had_liked":false,"id":155957,"user_name":"李湘河","can_delete":false,"product_type":"c1","uid":1349528,"ip_address":"","ucode":"DB078B5DAAE82E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoViaN0hP07cXOl7vOIvHPu7DZ3wxHBz4iaLVEqG1TFfiagm1wUaiczbCyicwib7oDWw0vD4cXg9eZ0Okqg/132","comment_is_top":false,"comment_ctime":1574782820,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574782820","product_id":100017301,"comment_content":"先找链表的中间节点，将链表的右半部分反转然后与左半部分比对，比对完再次将右半部分反转链接到左半部分，还原链表。找中间节点的时间复杂度为O(1&#47;2*n)，两次反转右半部分链表的时间复杂度均为O(1&#47;2*n)，一次比对时间复杂度为O(1&#47;2*n)，时间复杂度与系数无关，所以时间复杂度为O(n)，找中间节点时需要两个临时节点变量，此外申请两个临时节点变量分别保存右半部分反转后的头结点以及原链表的头结点，总共额外申请了四个临时变量，所以空间复杂度为O(1)。","like_count":0},{"had_liked":false,"id":155944,"user_name":"Cutler","can_delete":false,"product_type":"c1","uid":1228136,"ip_address":"","ucode":"2EDECFE039845B","user_header":"https://static001.geekbang.org/account/avatar/00/12/bd/68/3fd6428d.jpg","comment_is_top":false,"comment_ctime":1574781183,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574781183","product_id":100017301,"comment_content":"```golang<br><br>type Node struct {<br>\tVal byte<br>\tNext *Node<br>}<br><br>func judgePalindrome(node *Node) bool {<br>\tvar prev *Node<br>\tfast := node<br>\tslow := node<br>\t&#47;&#47; 找中点<br>\tfor fast != nil &amp;&amp; fast.Next != nil {<br>\t\tfast = fast.Next.Next<br>\t\tnext := slow.Next<br>\t\tslow.Next = prev<br>\t\tprev = slow<br>\t\tslow = next<br>\t}<br>\tif fast != nil {<br>\t\tslow = slow.Next<br>\t}<br>\t&#47;&#47; 比较<br>\tfor slow != nil &amp;&amp; prev != nil {<br>\t\tif slow.Val != prev.Val {<br>\t\t\treturn false<br>\t\t}<br>\t\tslow = slow.Next<br>\t\tprev = prev.Next<br>\t}<br>\treturn true<br>}<br>```<br>时间复杂度O(n)<br>空间复杂度O(1)","like_count":0},{"had_liked":false,"id":155823,"user_name":"大禾","can_delete":false,"product_type":"c1","uid":1742323,"ip_address":"","ucode":"841369DDF985A8","user_header":"https://static001.geekbang.org/account/avatar/00/1a/95/f3/2fcbeb0a.jpg","comment_is_top":false,"comment_ctime":1574761478,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574761478","product_id":100017301,"comment_content":"&#47;**<br>\tLRU 基于数组实现 ,待验证，按照我目前理解的复杂度我好像写了个立方复杂度的代码，想求助老师和同学我的计算是否有问题，如何改进<br> *&#47;<br>type cacheOfLRU struct {<br>\tt [5]int<br>\tindex int &#47;&#47;equal len(t)-1<br>}<br><br>func (lru *cacheOfLRU) Append(v ...int) [5]int { &#47;&#47;O(n^2)*O(n) = O(n^3)<br>\tfor _,val := range v { &#47;&#47;O(n)<br>\t\tlru.addSingleV(val) &#47;&#47;O(n^2)<br>\t}<br>\treturn lru.t<br>}<br><br>func (lru *cacheOfLRU) addSingleV(v int) bool { &#47;&#47;O(n)+O(n^2) = O(n^2)<br>\tflag := true<br>\tfor i:=len(lru.t)-1; i&gt;lru.index; i-- { &#47;&#47;添加重复v &#47;&#47;O(n)*O(n) = O(n^2)<br>\t\tif lru.t[i] == v {<br>\t\t\tlru.merge(v,i) &#47;&#47;O(n)<br>\t\t\tflag = false<br>\t\t\tbreak<br>\t\t}<br>\t}<br>\tif flag {<br>\t\tif lru.index ==-1 { &#47;&#47;满队,且无重复<br>\t\t\tlru.merge(v,len(lru.t)-1) &#47;&#47;O(n)<br>\t\t\tflag = false<br>\t\t}else{<br>\t\t\tlru.t[lru.index] = v<br>\t\t\tlru.index--<br>\t\t\tflag = false<br>\t\t}<br>\t}<br>\treturn !flag<br>}<br><br>func (lru *cacheOfLRU) merge(v int, startIndex int) bool{ &#47;&#47;O(n)<br>\tflag := true<br>\tfor j,k := startIndex,startIndex-1 ; k&gt;lru.index; j,k = j-1,k-1 {<br>\t\tlru.t[j] = lru.t[k]<br>\t}<br>\tlru.t[lru.index+1] = v<br>\treturn flag<br>}<br><br>func main() {<br>\tlru := cacheOfLRU{[5]int{},4}&#47;&#47;不可插入0<br>\tvar cache [5]int = lru.Append(1,2,2) &#47;&#47;重复  1，2<br>\tcache1 := lru.Append(3, 4, 5, 6)     &#47;&#47;满不重复<br>\tcache2 := lru.Append(3)                &#47;&#47;满 重复<br>\tfmt.Println(cache,cache1,cache2,lru)<br>}","like_count":0},{"had_liked":false,"id":155628,"user_name":"nico","can_delete":false,"product_type":"c1","uid":1209075,"ip_address":"","ucode":"DDB5EFE9F3A70E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Pr8laRQY3skrzzgen37ZIt4HQvtaThAcqvyK8eAzc9DRiak803q5HS7gCnXFxpx6CWibqT1Sic0h1TLMmVNUpJRibA/132","comment_is_top":false,"comment_ctime":1574730305,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574730305","product_id":100017301,"comment_content":"老师，数组分配不使用vms吗？虚拟地址中的连续在物理内存中也连续吗？","like_count":0},{"had_liked":false,"id":155575,"user_name":"大海","can_delete":false,"product_type":"c1","uid":1001446,"ip_address":"","ucode":"20913D0265971B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/47/e6/67b0b711.jpg","comment_is_top":false,"comment_ctime":1574702917,"is_pvip":false,"replies":[{"id":"60060","content":"java版本的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1574858907,"ip_address":"","comment_id":155575,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574702917","product_id":100017301,"comment_content":"GitHub仓库里面的代码，很多看提交都是学员提交的吧，很多内容和文章不一样，老师的版本是哪个呢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475795,"discussion_content":"java版本的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574858907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155517,"user_name":"大禾","can_delete":false,"product_type":"c1","uid":1742323,"ip_address":"","ucode":"841369DDF985A8","user_header":"https://static001.geekbang.org/account/avatar/00/1a/95/f3/2fcbeb0a.jpg","comment_is_top":false,"comment_ctime":1574694781,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574694781","product_id":100017301,"comment_content":"尝试go版本实现 约瑟夫问题,不过我算法复杂度分析不知道是多少🤣欢迎指教<br>func main() {<br>\tlist := cycleLinkList{}<br>\tleft,_ := list.Init(10).Start(2,2)<br>\tfmt.Println(&quot;总共&quot;, list.num, &quot;存活&quot;, left)<br>}<br><br>type cycleLinkList struct {<br>\tnodeR node<br>\tnum   int<br>\tskip  int<br>\tstart int<br>}<br><br>func (list *cycleLinkList) Init(num int) *cycleLinkList {&#47;&#47;时间复杂度O(n)<br>\tr := node{data:1}<br>\tt1 := &amp;r<br>\tfor i := 2; i &lt;= num; i++ {<br>\t\tt1 = list.addNode(t1,i)<br>\t}<br>\tt1.next = &amp;r<br>\tlist.nodeR = r<br>\tlist.num = num<br>\treturn list<br>}<br><br>func (list *cycleLinkList) addNode(t *node, i int) *node {<br>\tte := node{data:i}<br>\tt.next = &amp;te<br>\treturn &amp;te<br>}<br><br>func (list *cycleLinkList) Start(start,skip int) (int,error) { &#47;&#47;时间复杂度O(n)<br>\tif list.num &gt; 0 &amp;&amp; &amp;list.nodeR != nil{<br>\t\tt := &amp;list.nodeR<br>\t\tfor i:= 1; i&lt;=list.num; i++ {<br>\t\t\tif t.data == start{<br>\t\t\t\tbreak<br>\t\t\t}else{<br>\t\t\t\tt = t.next<br>\t\t\t}<br>\t\t}<br>\t\treturn killSkip(skip,t)<br>\t}<br>\treturn -1,errors.New(&quot;ERROR USE&quot;)<br>}<br><br>func killSkip(skip int, t *node) (int, error) {&#47;&#47;时间复杂度？<br>\tfor true {<br>\t\tfor i :=0; i&lt;skip; i++ {<br>\t\t\tt = t.next<br>\t\t}<br>\t\tkilled := t.next<br>\t\tfmt.Println(&quot;kill &quot;,killed.data)<br>\t\tt.next = killed.next<br>\t\tif t.next.data == t.data {<br>\t\t\tbreak<br>\t\t}<br>\t}<br>\treturn t.data,nil<br>}<br><br>type node struct {<br>\tdata int<br>\tnext *node<br>}","like_count":0},{"had_liked":false,"id":155437,"user_name":"scott","can_delete":false,"product_type":"c1","uid":1276032,"ip_address":"","ucode":"A3C507695AAF9D","user_header":"https://static001.geekbang.org/account/avatar/00/13/78/80/d2547579.jpg","comment_is_top":false,"comment_ctime":1574689069,"is_pvip":false,"replies":[{"id":"60054","content":"ipad paper","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1574858451,"ip_address":"","comment_id":155437,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574689069","product_id":100017301,"comment_content":"文章里的插图是怎么配的，用的什么工具画的？看起来很有美感","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475753,"discussion_content":"ipad paper","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574858451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155366,"user_name":"奔跑","can_delete":false,"product_type":"c1","uid":1361556,"ip_address":"","ucode":"A64A0DCA50D9FA","user_header":"https://static001.geekbang.org/account/avatar/00/14/c6/94/48ca3281.jpg","comment_is_top":false,"comment_ctime":1574682473,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574682473","product_id":100017301,"comment_content":"创建char数字，遍历字符串复制进数组，然后随机访问随便造啊。OnOn","like_count":0},{"had_liked":false,"id":155082,"user_name":"大海","can_delete":false,"product_type":"c1","uid":1001446,"ip_address":"","ucode":"20913D0265971B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/47/e6/67b0b711.jpg","comment_is_top":false,"comment_ctime":1574643858,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574643858","product_id":100017301,"comment_content":"思考题看到留言蔡知道怎么做，回头写代码实现一遍","like_count":0},{"had_liked":false,"id":154304,"user_name":"Scorpio","can_delete":false,"product_type":"c1","uid":1310855,"ip_address":"","ucode":"CB8672DA73FA88","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/87/bcd6fb00.jpg","comment_is_top":false,"comment_ctime":1574406903,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574406903","product_id":100017301,"comment_content":"LRU算法数组的实现:<br>   每次访问某条数据,若存在该数据,则将这个数据前面的数据全部后移一位,把该数据放在首位,访问的数据不存在时,若此时缓存未满,将该数据放入数组首位,其他数据全部后移一位,若缓存已满,删掉最后一条数据,该数据放入首位,其他数据依次后移一位.访问时间复杂度是O(n).<br>回文字符串:<br>    新建一个数组,数组长度为字符串的长度,从0到n遍历字符串拆分得到的数组,里层再次从n到0遍历新数组,依次填入数据,新数组的数据拼成字符串和原字符串对比.时间复杂度是O(n*n).<br>    单链表:使用快慢指针,慢指针每次移动一个节点,快指针每次移动两个节点:<br>慢指针移动到中点的数据依次倒序存储,<br>若字符串长度为奇数:过中点后慢指针继续往前移动(从index为0开始),跟存储的字符比较,若某个位置字符不同则不是回文,若能顺利遍历玩,则是回文.<br><br>","like_count":0},{"had_liked":false,"id":154143,"user_name":"黄嘉治","can_delete":false,"product_type":"c1","uid":1125505,"ip_address":"","ucode":"CACA8E2863ED12","user_header":"https://static001.geekbang.org/account/avatar/00/11/2c/81/9225767a.jpg","comment_is_top":false,"comment_ctime":1574384631,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574384631","product_id":100017301,"comment_content":"对于第二种情况，我们已经找到了要删除的结点，但是删除某个结点 q 需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，我们还是要从头结点开始遍历链表，直到 p-&gt;next=q，说明 p 是 q 的前驱结点。<br><br>对于单纯的插入和删除，我们可以记录上一次的节点位置，从而减少二次查询，也算是简单的空间换时间了","like_count":0},{"had_liked":false,"id":153886,"user_name":"神执念の浅言多行","can_delete":false,"product_type":"c1","uid":1373637,"ip_address":"","ucode":"59C0659C7E3ACC","user_header":"https://static001.geekbang.org/account/avatar/00/14/f5/c5/9b06bdb5.jpg","comment_is_top":false,"comment_ctime":1574325707,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574325707","product_id":100017301,"comment_content":"&#47;*<br>    缓存淘汰算法，<br>    LRU，最近最少使用的缓存淘汰掉<br>    最终优化，以类的方式编写，用数组这种数据结构<br><br>    默认数组的length 是 10，可以在new时传入<br><br>    getCache，根据key值返回缓存，如没有则返回null<br>    setCache，根据key值来存储缓存，如果已有则取消存储<br>    sortCache，根据position来排序，其中position值越大，说明该缓存是最新使用，越小，说明该缓存最近最少使用，可以淘汰<br> *&#47;<br>class CacheLRU {<br>    CACHE_ARR = []<br><br>    constructor(len = 10) {<br>        this.len = len<br>    }<br><br>    getCache(key) {<br>        if (!this.CACHE_ARR.length) {<br>            return null<br>        }<br>        let r = null<br>        this.CACHE_ARR.some((c, i) =&gt; {<br>            if (c.key === key) {<br>                c.position = this.CACHE_ARR[0].position + 1<br>                r = c.data<br>                return true<br>            }<br>        })<br>        return r<br>    }<br><br>    setCache(key, data) {<br>        if (this.getCache(key)) {<br>            return &#39;have&#39;<br>        }<br>        const i = this.CACHE_ARR.length<br>        if (i &lt; this.len - 1) {<br>            this.CACHE_ARR[i] = {key: key, data: data, position: this.CACHE_ARR[0] ? this.CACHE_ARR[0].position + 1 : 0}<br>        } else {<br>            this.CACHE_ARR[this.len - 1] = {key: key, data: data, position: this.CACHE_ARR[0].position + 1}<br>        }<br>        this.sortCache()<br>        return data<br>    }<br><br>    sortCache() {<br>        this.CACHE_ARR.sort((a, b) =&gt; {<br>            return b.position - a.position<br>        })<br>    }<br>}<br><br>let cache = new CacheLRU(5)<br>cache.getCache(&#39;geekbang&#39;) ? cache.getCache(&#39;geekbang&#39;) :  cache.setCache(&#39;geekbang&#39;, &#39;数据结构与算法之美&#39;)","like_count":0},{"had_liked":false,"id":153082,"user_name":"William Ning","can_delete":false,"product_type":"c1","uid":1592279,"ip_address":"","ucode":"4DB8D05E69E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","comment_is_top":false,"comment_ctime":1574154967,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574154967","product_id":100017301,"comment_content":"首先，理解什么是回文字符串，简单的一句话概括就是关于中心左右对称的字符串。例如：ABCBA或者AACCAA是回文字符串；ABCCA或者AABBCC不是回文字符串。<br>判断方法就是，依次看两端的字符是否相等。例如:ABCBA，第一个字符与最后一个字符相等，第二个字符与倒数第二个字符相等，第三个字符是中心字符，无需判断。如果是AACCAA就要判断。所以上面的字符串是回文字符串。<br>以下是C语言实现判断回文字符串的代码。<br>#include&lt;stdio.h&gt;<br>#include&lt;string.h&gt;<br>int main(void)<br>{<br>    char s[30];<br>    int b=0;  &#47;&#47;1表示不是回文字符串<br>    puts(&quot;请输入一个字符串:&quot;);<br>    scanf(&quot;%s&quot;,s);<br>    for(int i=0;i&lt;strlen(s)&#47;2;i++)<br>        if(s[i]!=s[strlen(s)-i-1])<br>        {<br>            b++;<br>            break;<br>        }<br>     if(b)<br>         printf(&quot;这不是回文字符串。&quot;);<br>     else<br>         printf(&quot;这是回文字符串。&quot;);<br>     return 0;<br>}","like_count":0},{"had_liked":false,"id":152155,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1573894406,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1573894406","product_id":100017301,"comment_content":"这边之前有个疑问(链表插入删除时间复杂度O(1), 难道链表的查询时间不算么?),<br>现在记录下来<br>其实:链式存储插入和删除的时间复杂度为O(1)的前提应该是“已知元素当前的位置”，<br>否则实现在第i个位置插入或删除一个元素.顺序存储和链式存储的时间复杂度是一样的，都是O(n).<br><br>数组查找 O(1) + 操作O(n) -&gt; 最终O(n)<br>链表查找 O(n) + 操作O(1) -&gt; 最终O(n)<br>","like_count":0},{"had_liked":false,"id":151710,"user_name":"york","can_delete":false,"product_type":"c1","uid":1318852,"ip_address":"","ucode":"EE938B81A7FC04","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epGMibYc0m7cDHMsNRBUur2NPVnlBZFXoNjWomibfjnHeAO3XRt27VaH3WNtdUX11d3uIT1ZHWCxLeg/132","comment_is_top":false,"comment_ctime":1573780849,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573780849","product_id":100017301,"comment_content":"用数组实现LRU的算法：<br>1. 用变量（latest）记录数组中最近访问的缓存下标，latest从后往前表示从新到旧的顺序。<br>2. 查询时，从latest往前遍历，到达数组头后，再从数组尾遍历到latest。<br>3. 插入数据时，如果数组内没有相同的，不管数组（缓存）有没有满，都在latest+1位置写入数据，再令latest=latest+1。<br>4. 插入数据时，如果数组内有相同的，则将latest至该数据位置的值做前向搬移，再将数据写入latest位置，latest不变","like_count":0},{"had_liked":false,"id":151389,"user_name":"沫粢泪虞","can_delete":false,"product_type":"c1","uid":1716721,"ip_address":"","ucode":"538C5A3229F24A","user_header":"https://static001.geekbang.org/account/avatar/00/1a/31/f1/cfedceb9.jpg","comment_is_top":false,"comment_ctime":1573712133,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573712133","product_id":100017301,"comment_content":"1.创建双向链表<br>2.定义两个指针 一个指向头 一个指向尾<br>3.每次循环 头指针指向当前结点的next 尾指针指向当前结点的prev<br>4.判断两个指针的data 只要有一次不想等就结束循环<br>5.直到头指针与尾指针相等，或尾指针的next与头指针相等 结束<br>6.如果当然字符串长度等于0或1不用判断<br>不知道对不对，请各位大神指正","like_count":0},{"had_liked":false,"id":150853,"user_name":"时光流逝x","can_delete":false,"product_type":"c1","uid":1695455,"ip_address":"","ucode":"D7334E717D9ED0","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqUMEsVYklTc7akT2e6pfytu4jTQ88EVe1H6L2eHdXC6G8sbKCvfrnSDUIRq229M2Wt419LX2q8SQ/132","comment_is_top":false,"comment_ctime":1573616996,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573616996","product_id":100017301,"comment_content":"遍历链表然后压栈,然后拿遍历链表的结果和弹栈结果比较如果一致则为回文字符串。","like_count":0},{"had_liked":false,"id":150852,"user_name":"握不住手中沙","can_delete":false,"product_type":"c1","uid":1097132,"ip_address":"","ucode":"F194E47C4D42C9","user_header":"https://static001.geekbang.org/account/avatar/00/10/bd/ac/49494ed8.jpg","comment_is_top":false,"comment_ctime":1573616925,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573616925","product_id":100017301,"comment_content":"课后思考题：链表存储字符串，判断字符串是否为回文串？<br>1、快慢指针的方式（slow,fast），寻找中间节点<br>2、在慢指针走到中间节点的过程中对前半段的链表进行反转（Linked List Reverse）<br>3、遍历前后半段链表，比较前半段和后半段节点值是否相同","like_count":0},{"had_liked":false,"id":150839,"user_name":"eviltion","can_delete":false,"product_type":"c1","uid":1515445,"ip_address":"","ucode":"022DE8510B825E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/mWicFKgbjL299CQPEhoFdSAphVb4UpibkhF8loRxryBRt3H7ZGkibibhaKANTxvSiatic4PLCy2MsbEMH1hc76YefPUw/132","comment_is_top":false,"comment_ctime":1573615288,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1573615288","product_id":100017301,"comment_content":"链表：有单链表，双向链表，循环列表，双向循环链表,都是在内存中不连续的内存空间，用指针方式指向下一个节点。<br>单链表：一个节点有两部分构成，data 和next  头结点用来记录链表的基地址 尾结点指向null<br>循环链表：结构和单链表相同，头结点是用来记录链表的基地址，区别是 尾结点指向的是头结点<br>双向列表：1、结构上是一个节点由三部分构成，pre 、data、next ,双向列表相对于单链表更耗内存，但是效率更高，具体表现在删除一个节点时单链表没有指向前驱节点的指针还需要经过O（n）的时间复杂度寻找 p-&gt; next=p 的节点，<br>双向循环列表：与循环链表有相似点，即头结点的pre 指向尾结点的data,尾结点的next 指向头结点的data<br>","like_count":0},{"had_liked":false,"id":150425,"user_name":"york","can_delete":false,"product_type":"c1","uid":1318852,"ip_address":"","ucode":"EE938B81A7FC04","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epGMibYc0m7cDHMsNRBUur2NPVnlBZFXoNjWomibfjnHeAO3XRt27VaH3WNtdUX11d3uIT1ZHWCxLeg/132","comment_is_top":false,"comment_ctime":1573532746,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573532746","product_id":100017301,"comment_content":"判断是否回文的问题，看了同学们的留言，好多都提到了用快慢指针来实现，我自己研究了半天，也没把快慢指针的逻辑实现（可能是我比较菜）。我自己想了个算法（Java语言）：<br>1. 将文字链表做一个深度复制（一次序列化、反序列化）<br>2.将得到的复制链表做指针反转（reverse）操作（实现代码比较简单），时间复杂度为O(n)<br>3.将原链表与反转后的链表做逐个比较，比较次数为n&#47;2，时间复杂度为O(n&#47;2)<br>4.根据复杂度加法法则，总的时间复杂度为O(n)+O(n&#47;2)=O(3n&#47;2)=O(n)<br>不知道对不对，请指正！","like_count":0},{"had_liked":false,"id":150006,"user_name":"大明的微信","can_delete":false,"product_type":"c1","uid":1644922,"ip_address":"","ucode":"687341327E704B","user_header":"https://static001.geekbang.org/account/avatar/00/19/19/7a/67e245ca.jpg","comment_is_top":false,"comment_ctime":1573444127,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573444127","product_id":100017301,"comment_content":"我一直没想到判断字符串可以去用List去做。之前被面过。准备就用几个索引变量通过遍历字符串去实现。然后果然没写出来。<br><br>用List去做，简单多了。写出来了。","like_count":0},{"had_liked":false,"id":149788,"user_name":"zzh","can_delete":false,"product_type":"c1","uid":1174510,"ip_address":"","ucode":"0FC6BD729E5801","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJmcPTvjtSbhBNic4wb61Pj77nIHcLG64MnAXicsHBrMWvjCQPoiaHTtYmbnlVSkSWZEnN2QlicekqLhg/132","comment_is_top":false,"comment_ctime":1573378235,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573378235","product_id":100017301,"comment_content":"2019年11月10日 17点30 打卡 ","like_count":0},{"had_liked":false,"id":149081,"user_name":"月马穿关","can_delete":false,"product_type":"c1","uid":1338088,"ip_address":"","ucode":"2CE20CA1EB827D","user_header":"https://static001.geekbang.org/account/avatar/00/14/6a/e8/4bb87c34.jpg","comment_is_top":false,"comment_ctime":1573138016,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573138016","product_id":100017301,"comment_content":"老师写的好 我看懂了","like_count":0},{"had_liked":false,"id":149080,"user_name":"月马穿关","can_delete":false,"product_type":"c1","uid":1338088,"ip_address":"","ucode":"2CE20CA1EB827D","user_header":"https://static001.geekbang.org/account/avatar/00/14/6a/e8/4bb87c34.jpg","comment_is_top":false,"comment_ctime":1573138003,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573138003","product_id":100017301,"comment_content":"哇最后思考题这题好厉害啊，我看懂了，我也好好想了，为啥我想不到这种方法啊，，，继续看","like_count":0},{"had_liked":false,"id":148994,"user_name":"渴望做梦","can_delete":false,"product_type":"c1","uid":1398219,"ip_address":"","ucode":"9EB47530A69C91","user_header":"https://static001.geekbang.org/account/avatar/00/15/55/cb/1efe460a.jpg","comment_is_top":false,"comment_ctime":1573124839,"is_pvip":false,"replies":[{"id":"57575","content":"ipad paper","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1573339185,"ip_address":"","comment_id":148994,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573124839","product_id":100017301,"comment_content":"老师，我想问一下，文档里面的图是用什么画的啊，看着像手写的一样。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473700,"discussion_content":"ipad paper","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573339185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147973,"user_name":",","can_delete":false,"product_type":"c1","uid":1439568,"ip_address":"","ucode":"191431A878D7B6","user_header":"https://static001.geekbang.org/account/avatar/00/15/f7/50/cbfe1bc0.jpg","comment_is_top":false,"comment_ctime":1572923881,"is_pvip":false,"replies":[{"id":"57067","content":"都可以啊，看数据的更新时间是从小到大还是从大到小","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1572948543,"ip_address":"","comment_id":147973,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572923881","product_id":100017301,"comment_content":"在用链表实现LRU时，为啥是头部插入、尾部删除，而不是尾部插入、头部弹出呢。如果头部插入和尾部删除的话，在尾部删除的时候需要维护头节点和尾部节点的父节点，感觉有点怪怪的。相反，如果是头部删除和尾部插入的话，只需要维护头节点和尾节点。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473357,"discussion_content":"都可以啊，看数据的更新时间是从小到大还是从大到小","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572948543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147213,"user_name":"Geek_c9a012","can_delete":false,"product_type":"c1","uid":1315231,"ip_address":"","ucode":"839BD7B5D348E7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJPZN07CicHGCjkv5FuD013mpLxHN3y78UZA8FhvYkuNyqzqyA7A2XxxkUC1ax3V2JfdfJWWZgkVmg/132","comment_is_top":false,"comment_ctime":1572841425,"is_pvip":true,"replies":[{"id":"57065","content":"好像没画错呢，为啥非得指向prev和next呢，prev+data+next是一个结点呢","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1572948445,"ip_address":"","comment_id":147213,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572841425","product_id":100017301,"comment_content":"双向循环链表   这张示意图可能有问题。<br>头结点的prev应该是指向尾节点的next<br>同样的，尾节点的next应该指向头结点的prev<br>希望作者有空能改一下。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473200,"discussion_content":"好像没画错呢，为啥非得指向prev和next呢，prev+data+next是一个结点呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572948445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146726,"user_name":"Geek_c9a012","can_delete":false,"product_type":"c1","uid":1315231,"ip_address":"","ucode":"839BD7B5D348E7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJPZN07CicHGCjkv5FuD013mpLxHN3y78UZA8FhvYkuNyqzqyA7A2XxxkUC1ax3V2JfdfJWWZgkVmg/132","comment_is_top":false,"comment_ctime":1572620921,"is_pvip":true,"replies":[{"id":"56806","content":"是的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1572824931,"ip_address":"","comment_id":146726,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572620921","product_id":100017301,"comment_content":"双向循环链表的头结点，prev应该是指向尾节点的next吧？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472998,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572824931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145045,"user_name":"yin","can_delete":false,"product_type":"c1","uid":1711450,"ip_address":"","ucode":"9F3D55A1D435A2","user_header":"https://static001.geekbang.org/account/avatar/00/1a/1d/5a/937f0d4c.jpg","comment_is_top":false,"comment_ctime":1572169126,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572169126","product_id":100017301,"comment_content":"看留言百家争鸣,思考题最优解快慢指针的方法，算法真奇妙","like_count":0},{"had_liked":false,"id":144396,"user_name":"仰望星空","can_delete":false,"product_type":"c1","uid":1149084,"ip_address":"","ucode":"A9E46C9FDB3275","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/9c/cbc463e6.jpg","comment_is_top":false,"comment_ctime":1571910748,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571910748","product_id":100017301,"comment_content":"维护一个长度为n（n &gt; 1）的数组，越靠近首部就是越早访问的。当访问一个新元素时，首先在数组中查询：<br>一、如果找到，假设下标为k且当前共有j个元素，分两种情况：<br>1、k最靠近尾部，不用做任何处理 。<br>2、k不是最靠近尾部，将下标为k+1~j-1的元素统一向首部移动一个位置，再将k移动到最靠近尾部的位置。<br>二、如果未找到，又分两种情况：<br>1、当前数组未满，则将该元素直接插入到最靠近尾部的位置<br>2、当前数组已满，删除下标为0的元素，将下标为1~n-1的元素统一向首部移动一个位置，然后再将该元素插入到尾部<br>时间复杂度为O(n)","like_count":0},{"had_liked":false,"id":144036,"user_name":"小菜鸟学php","can_delete":false,"product_type":"c1","uid":1683755,"ip_address":"","ucode":"C417C76E18B062","user_header":"https://static001.geekbang.org/account/avatar/00/19/b1/2b/9406d19a.jpg","comment_is_top":false,"comment_ctime":1571829896,"is_pvip":false,"replies":[{"id":"55989","content":"别急啊，都有一个过程的。你可以先看看别人怎么写的，抄一抄，多抄几遍，慢慢就会了","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1572230809,"ip_address":"","comment_id":144036,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1571829896","product_id":100017301,"comment_content":"感觉自己好笨呢，单链表回文和  链表的LRU算法，一个都做不出来。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471789,"discussion_content":"别急啊，都有一个过程的。你可以先看看别人怎么写的，抄一抄，多抄几遍，慢慢就会了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572230809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1683755,"avatar":"https://static001.geekbang.org/account/avatar/00/19/b1/2b/9406d19a.jpg","nickname":"小菜鸟学php","note":"","ucode":"C417C76E18B062","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40540,"discussion_content":"谢谢老师，我必须得跟着您学会它！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572232035,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143645,"user_name":"Lamperouge","can_delete":false,"product_type":"c1","uid":1655889,"ip_address":"","ucode":"0B8D13EA1802EA","user_header":"https://static001.geekbang.org/account/avatar/00/19/44/51/96bd0eb3.jpg","comment_is_top":false,"comment_ctime":1571751036,"is_pvip":false,"replies":[{"id":"55992","content":"可以解决问题，但不是最优的。实际上可以在原链表上完成的。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1572230954,"ip_address":"","comment_id":143645,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571751036","product_id":100017301,"comment_content":"思考题: 遍历链表一次将链表反转复制一边，然后和原链表比较一次，不知道思路对不对","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471633,"discussion_content":"可以解决问题，但不是最优的。实际上可以在原链表上完成的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572230954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143403,"user_name":"活力的高蛋蛋","can_delete":false,"product_type":"c1","uid":1121821,"ip_address":"","ucode":"6CDC80359D1AF3","user_header":"https://static001.geekbang.org/account/avatar/00/11/1e/1d/ba1c43ff.jpg","comment_is_top":false,"comment_ctime":1571706087,"is_pvip":false,"replies":[{"id":"55995","content":"Linkedlist就是链表，还有LinkedHashmap也用到了链表","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1572231121,"ip_address":"","comment_id":143403,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571706087","product_id":100017301,"comment_content":"请问下链表在实际工作中的常见使用场景有哪些呢？java","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471518,"discussion_content":"Linkedlist就是链表，还有LinkedHashmap也用到了链表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572231121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142836,"user_name":"Geek_272a2e","can_delete":false,"product_type":"c1","uid":1691776,"ip_address":"","ucode":"C3F82497030D0C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLibX06ACicicBdkD4hkSTkVm9fIT1xwdXV52GvQahFmTVSFHhxbDWjNOk5mdwE3hRFLO6QjRYIKoffA/132","comment_is_top":false,"comment_ctime":1571554393,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571554393","product_id":100017301,"comment_content":"课后思考题目前能想到的解决办法：<br>这个问题可以转化为如何对一个单链表进行倒序的问题，然后比较倒序前和倒序后遍历链表得到的字符串内容进行比较就可以了。<br>1）新建一个链表，对原来的链表进行遍历，并将每个节点依次插入新链表的头部，同时得到正序字符串，此时新链表已经是原来链表的倒序排列<br>2）遍历新链表，得到倒序字符串，与正序字符串进行比较<br>时间复杂度：需要遍历两个链表各一次，复杂度为O(n), 需要执行n次插入操作，复杂度为O(1)<br>空间复杂度：需要额外占用一个链表的空间<br><br>如果是双向链表，则直接正向和逆向遍历一遍就好了","like_count":0},{"had_liked":false,"id":142751,"user_name":"莫奈","can_delete":false,"product_type":"c1","uid":1644960,"ip_address":"","ucode":"A1E1DDFD0AEBED","user_header":"https://static001.geekbang.org/account/avatar/00/19/19/a0/84f95280.jpg","comment_is_top":false,"comment_ctime":1571490596,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571490596","product_id":100017301,"comment_content":"js版本的代码加注释<br>function isPalindrome(headNode) {<br>  let slow = headNode;<br>  let fast = headNode;<br>  let prev = null;<br>  &#47;&#47;使用快慢两指针，快指针一次走两步，慢指针一次走一步<br>  &#47;&#47;当链表个数为单数时，快指针走到末尾时，慢指针正好走到中间<br>  &#47;&#47;当链表个数为双数时，快指针指向null，慢指针指向后半段数据的第一个<br>  &#47;&#47;慢指针每前进一次，把当前节点的next指向改为上一个节点，这样就达到了反转前半段节点的目的，并且数据被分割成了前后两段<br>  while (fast !== null &amp;&amp; fast.next !== null) {<br>    fast = fast.next.next;<br>    &#47;&#47;慢指针每前进一次，把当前节点的next指向改为前一个节点（prev），这样就达到了反转前半段节点的目的<br>    let next = slow.next;<br>    slow.next = prev;<br>    &#47;&#47;把prev和slow的指针都往前移动一格<br>    prev = slow;<br>    slow = next;<br>  }<br><br>  &#47;&#47;如果fast不为null，说明链表个数为单数，慢指针指向两段数据的正中间，需要把慢指针移动到第二段数据的第一个<br>  if (fast !== null) {<br>    slow = slow.next;<br>  }<br>  &#47;&#47;此时prev处于第一段数据的头结点（因为数据被反转了），slow处于第二段数据的头结点，此时逐个遍历对比就好<br>  while (slow.next !== null) {<br>    if (slow.element !== prev.element) {<br>      return false;<br>    }<br>    slow = slow.next;<br>    prev = prev.next;<br>  }<br>  return true;<br>}","like_count":0},{"had_liked":false,"id":142128,"user_name":"晓荷","can_delete":false,"product_type":"c1","uid":1381682,"ip_address":"","ucode":"BA1E1418E63250","user_header":"https://static001.geekbang.org/account/avatar/00/15/15/32/50aa4084.jpg","comment_is_top":false,"comment_ctime":1571297725,"is_pvip":false,"replies":[{"id":"55225","content":"https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;Md8tprLiESR6oQKXs_Aihw","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1571618792,"ip_address":"","comment_id":142128,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571297725","product_id":100017301,"comment_content":"关于单链表的删除和插入，之前看到过：<br>删除时，将后继结点赋给当前节点，然后删除后继节点。<br>同理，在前插入时，将当前节点复制并插入后面，替换当前节点为新节点。<br><br>这样双向链表的时间复杂度优势就不明显了。<br>不知双向链表还有什么更好的优势（或者说为什么要用双向链表）？<br>希望老师能指点一二，谢谢。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470995,"discussion_content":"https://mp.weixin.qq.com/s/Md8tprLiESR6oQKXs_Aihw","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571618792,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142086,"user_name":"微风","can_delete":false,"product_type":"c1","uid":1701782,"ip_address":"","ucode":"C448DEF37B2500","user_header":"https://static001.geekbang.org/account/avatar/00/19/f7/96/06fc7f1c.jpg","comment_is_top":false,"comment_ctime":1571292854,"is_pvip":true,"replies":[{"id":"54892","content":"不是的，第二个节点prev还是指向第一个结点。第四个结点的prev结点指向第二个结点。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1571359881,"ip_address":"","comment_id":142086,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571292854","product_id":100017301,"comment_content":"老师您好，有个问题想请教一下：<br><br>如果双向循环链表的环产生在，双向循环链表图的第二三四个节点，那么第二个节点的prev是不是既指向第一个节点又指向最后一个节点呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470981,"discussion_content":"不是的，第二个节点prev还是指向第一个结点。第四个结点的prev结点指向第二个结点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571359881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142040,"user_name":"学个球","can_delete":false,"product_type":"c1","uid":1019725,"ip_address":"","ucode":"7343F3C0CA981D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8f/4d/65fb45e6.jpg","comment_is_top":false,"comment_ctime":1571282083,"is_pvip":false,"replies":[{"id":"54895","content":"嗯嗯，是的，多谢指出。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1571359986,"ip_address":"","comment_id":142040,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571282083","product_id":100017301,"comment_content":"删除结点中“值等于某个给定值”的结点；<br>是不是应该改成 删除链表中“值等于某个给定值”的结点？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470963,"discussion_content":"嗯嗯，是的，多谢指出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571359986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141804,"user_name":"Hou","can_delete":false,"product_type":"c1","uid":1621793,"ip_address":"","ucode":"92BF011EF961B4","user_header":"https://static001.geekbang.org/account/avatar/00/18/bf/21/44eb3aee.jpg","comment_is_top":false,"comment_ctime":1571228693,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1571228693","product_id":100017301,"comment_content":"快慢指针遍历，遍历时将前半段逆置，之后在分别向前向后挨个判断并且在将前半段逆置回来。","like_count":0},{"had_liked":false,"id":140890,"user_name":"Geek_949cc1","can_delete":false,"product_type":"c1","uid":1690476,"ip_address":"","ucode":"F8ACDBF2FA8CC2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKFRiaFrpOTVBuKicMficasBFuF2VY7EnUnLeFcvIn0R5OiaQsOcpJHNM5TusoPHMjIvSfia46c0EWH9mQ/132","comment_is_top":false,"comment_ctime":1571067873,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571067873","product_id":100017301,"comment_content":"哈哈 老师的解释真的好，在看了链表的LRU之后，我感觉其实数组是一样的，首先针对一个我们需要访问的数据，如果数据在数组中，那么我们将该数据放到数组头，其余数据依次后移，如果数据不在内存中，一种情况就是内存满了，不就是老师哪里的书架放不下了吗，那么我们这个时候就可以采用先进先出的策略，删除最先进来的数据，也就是数组最后一个数据了。如果内存没满，直接存储在数组头。<br>2：针对回文字符串判断的话，对于单链表的话，我只能先把所有字符提取出来组合成字符串，在正常的进行回文判断。但是对于回文字符串的话用双链表就特别简单了，直接双向检索判断就行了","like_count":0},{"had_liked":false,"id":140344,"user_name":"技术小生","can_delete":false,"product_type":"c1","uid":1692743,"ip_address":"","ucode":"18B7751498029F","user_header":"https://static001.geekbang.org/account/avatar/00/19/d4/47/0deb44d6.jpg","comment_is_top":false,"comment_ctime":1570884975,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570884975","product_id":100017301,"comment_content":"我的想法是借助栈，将链表压进栈，再一个个弹出和原链表做比对，时间复杂度是O(n)","like_count":0},{"had_liked":false,"id":139572,"user_name":"loCust","can_delete":false,"product_type":"c1","uid":1297583,"ip_address":"","ucode":"A5CFECA44045A1","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/af/25509210.jpg","comment_is_top":false,"comment_ctime":1570682077,"is_pvip":false,"replies":[{"id":"53983","content":"如果按照访问时间从大到小排列的话，那是要从尾部删除结点，是要记录尾结点。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1570747433,"ip_address":"","comment_id":139572,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570682077","product_id":100017301,"comment_content":"基于有序单链表实现LRU，缓存满时，删除尾节点还是需要遍历一遍链表才能找到尾节点，实际运用中是否会记录尾节点，省去遍历？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470005,"discussion_content":"如果按照访问时间从大到小排列的话，那是要从尾部删除结点，是要记录尾结点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570747433,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139551,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1570677542,"is_pvip":false,"replies":[{"id":"53989","content":"理解的差不多~","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1570748349,"ip_address":"","comment_id":139551,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570677542","product_id":100017301,"comment_content":"文中提到在java中链表频繁插入、删除可能导致大量内存碎片，但同时链表的插入和删除效率又很高。这个其实就是在时间和空间之间的一种权衡，根据需求去决定使用哪种数据结构。不知理解是否有误。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469996,"discussion_content":"理解的差不多~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570748349,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139490,"user_name":"奔跑小电驴","can_delete":false,"product_type":"c1","uid":1670951,"ip_address":"","ucode":"36950F0FB59F58","user_header":"https://static001.geekbang.org/account/avatar/00/19/7f/27/9c5ac353.jpg","comment_is_top":false,"comment_ctime":1570668284,"is_pvip":false,"replies":[{"id":"53986","content":"有的，https:&#47;&#47;github.com&#47;wangzheng0822&#47;algo<br>不过建议先找本编程语言的书籍看看","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1570747760,"ip_address":"","comment_id":139490,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570668284","product_id":100017301,"comment_content":"运维小白从零学的，想知道从哪里写代码练起来呢，没看到代码示例呢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469967,"discussion_content":"有的，https://github.com/wangzheng0822/algo\n不过建议先找本编程语言的书籍看看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570747760,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139185,"user_name":"心境若水天下无敌","can_delete":false,"product_type":"c1","uid":1213180,"ip_address":"","ucode":"5E6273A6AF67C7","user_header":"https://static001.geekbang.org/account/avatar/00/12/82/fc/bf1e85cb.jpg","comment_is_top":false,"comment_ctime":1570583097,"is_pvip":false,"replies":[{"id":"53765","content":"可以参考lru呀，lru也是一种根据访问时间有序的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1570659953,"ip_address":"","comment_id":139185,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570583097","product_id":100017301,"comment_content":"老铁，有序单链表 怎么实现？ java有没有现成的容器 <br> ","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469834,"discussion_content":"可以参考lru呀，lru也是一种根据访问时间有序的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570659953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139069,"user_name":"积微","can_delete":false,"product_type":"c1","uid":1378111,"ip_address":"","ucode":"373DF8B1DC002B","user_header":"https://static001.geekbang.org/account/avatar/00/15/07/3f/43872dff.jpg","comment_is_top":false,"comment_ctime":1570539967,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570539967","product_id":100017301,"comment_content":"单链表回文串：<br>1.先遍历链表获得字符串长度n（区分技术和偶数）<br>2.一个指针向前走n&#47;2步，并将字符入栈<br>3.区分奇数或者偶数，指针继续遍历，每走一步出栈一个元素，不相等则不是回文串，相等则继续走，直到走完","like_count":0},{"had_liked":false,"id":134988,"user_name":"厚积薄发","can_delete":false,"product_type":"c1","uid":1657999,"ip_address":"","ucode":"6FE711F65C8C66","user_header":"https://static001.geekbang.org/account/avatar/00/19/4c/8f/83eefcff.jpg","comment_is_top":false,"comment_ctime":1568969858,"is_pvip":false,"replies":[{"id":"51936","content":"可以的 加了更灵活些","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1569193542,"ip_address":"","comment_id":134988,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568969858","product_id":100017301,"comment_content":"老师，有一个问题：我自己用python实现了单向链表的一些操作，也对比了你github上的实现，例如插入操作：有插入头部、插入尾部、插入某个节点前&#47;后、插入某个位置等，如果要更加灵活，是否需要在再SinglyLinkedList加入一个self.tail标识尾部","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467989,"discussion_content":"可以的 加了更灵活些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569193542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134937,"user_name":"厚积薄发","can_delete":false,"product_type":"c1","uid":1657999,"ip_address":"","ucode":"6FE711F65C8C66","user_header":"https://static001.geekbang.org/account/avatar/00/19/4c/8f/83eefcff.jpg","comment_is_top":false,"comment_ctime":1568959594,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568959594","product_id":100017301,"comment_content":"前面说对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，后面又说链表适合插入、删除操作频繁的场景，这个感觉有点小矛盾","like_count":0},{"had_liked":false,"id":134897,"user_name":"Cola_","can_delete":false,"product_type":"c1","uid":1264718,"ip_address":"","ucode":"99996D04CA4171","user_header":"https://static001.geekbang.org/account/avatar/00/13/4c/4e/91267714.jpg","comment_is_top":false,"comment_ctime":1568948140,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568948140","product_id":100017301,"comment_content":"1.快慢指针解决以单链表结构存储的字符串是否为回文串，即在中间节点时将慢指针之前走过的逆序与快指针的后半部分比较，相同即是回文串<br>2.LRU缓存淘汰算法，最近最少使用的算法，将不经常使用的数据删除，节省内存空间<br>3.单链表、循环链表、双向链表的区别<br>4.链表和数组的时间复杂度比较及各自的优缺点<br>5.链表结构的概念和缓存的概念其实就是拿空间换时间的设计思想","like_count":0},{"had_liked":false,"id":133843,"user_name":"云师兄","can_delete":false,"product_type":"c1","uid":1010459,"ip_address":"","ucode":"4475AF1598FBFD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/1b/4b397b80.jpg","comment_is_top":false,"comment_ctime":1568682996,"is_pvip":false,"replies":[{"id":"51414","content":"这要看具体应用场景 很难一概而论而","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1568759990,"ip_address":"","comment_id":133843,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568682996","product_id":100017301,"comment_content":"文中提到链表不适合频繁的插入和删除，因为会造成内存空间申请与释放，导致内存碎片化严重，是建议这种情况下使用数组吗","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467528,"discussion_content":"这要看具体应用场景 很难一概而论而","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568759990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133375,"user_name":"David","can_delete":false,"product_type":"c1","uid":1023472,"ip_address":"","ucode":"1C76747719CD3B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9d/f0/6c34b90f.jpg","comment_is_top":false,"comment_ctime":1568536209,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568536209","product_id":100017301,"comment_content":"1.数组实现lru：申请固定长度数组，每次访问移动到数组尾部，数组满的时候淘汰首部。<br>2.回文字判断：单链表，通过快慢指针，时间复杂度O（n），空间复杂度O（1）。双向链表判断更优，一个从首部，一个从尾部，判断是否相同。","like_count":0},{"had_liked":false,"id":132919,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1568274730,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568274730","product_id":100017301,"comment_content":"数组是通过物理连续来保证线性关系，这种线性关系很紧密，可以通过指针偏移量快速得到任意和该元素距离为n的元素。物理连续在初始化就确定了，要增加就得全部搬动，而且元素之间的相对位置关系也敲定了，要调整一个元素和多个元素的相对位置关系，也得全局调整。<br>链表是通过逻辑连接保证元素的相邻关系，只有相邻的元素通过指针联系，其他元素之间没有全局的联系。链表可以动态扩容，插入和删除就可以调整一个元素和之前之后所有元素的相对关系。链表不存在全局关系，也就不可能像数组那样通过偏移量来定位元素。","like_count":0},{"had_liked":false,"id":132891,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1568260939,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568260939","product_id":100017301,"comment_content":"思考题<br>先把后半部链表倒置，然后比较，再倒置回来，这样在没有用额外空间的情况下完成回文验证，复杂度是O（n）。当然也可以用额外空间把后半链表拷贝到倒置状态，这样就需要额外的空间，但是速度会快一点，因为不用再倒置了。","like_count":0},{"had_liked":false,"id":132869,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1568255354,"is_pvip":false,"replies":[{"id":"51242","content":"好像没有呢。你再看下文章。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1568591923,"ip_address":"","comment_id":132869,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568255354","product_id":100017301,"comment_content":"删除操作部分，两种情况是不是讲反了啊，第一种情况，删除给定值的节点需要先找到点，再找到前区节点，然后删除操作，第二种情况，已经知道了要删除节点的前区，找到节点，直接删除","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467153,"discussion_content":"好像没有呢。你再看下文章。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568591923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132162,"user_name":"歩T_T歩T_T","can_delete":false,"product_type":"c1","uid":1450195,"ip_address":"","ucode":"DDC2F6A3EA2A4D","user_header":"https://static001.geekbang.org/account/avatar/00/16/20/d3/d4d7500c.jpg","comment_is_top":false,"comment_ctime":1568034546,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568034546","product_id":100017301,"comment_content":"好像平时直接用数组就完事了，大佬留下的问题要用单链表，估计就是为了引出找中点以及单链表逆转俩个问题吧","like_count":0},{"had_liked":false,"id":131688,"user_name":"jaynnay","can_delete":false,"product_type":"c1","uid":1436995,"ip_address":"","ucode":"0BD3F99A29ED57","user_header":"https://static001.geekbang.org/account/avatar/00/15/ed/43/7d91b07a.jpg","comment_is_top":false,"comment_ctime":1567845760,"is_pvip":false,"replies":[{"id":"51229","content":"缓存大小是预先设定好的，比如大小是1000，如果链表中结点个数到了1000个，就说明满了。这个是否满，是从业务概念上定义的。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1568589344,"ip_address":"","comment_id":131688,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567845760","product_id":100017301,"comment_content":"如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。<br>- - - <br>单链表怎么判断已满？理论上是无限增长的吧，本人小白，请老师解答一下","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466572,"discussion_content":"缓存大小是预先设定好的，比如大小是1000，如果链表中结点个数到了1000个，就说明满了。这个是否满，是从业务概念上定义的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568589344,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131566,"user_name":"胡永","can_delete":false,"product_type":"c1","uid":1200543,"ip_address":"","ucode":"6C8BA1E0BED9C0","user_header":"https://static001.geekbang.org/account/avatar/00/12/51/9f/1840385e.jpg","comment_is_top":false,"comment_ctime":1567814977,"is_pvip":false,"replies":[{"id":"50408","content":"👍","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1567986098,"ip_address":"","comment_id":131566,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567814977","product_id":100017301,"comment_content":"第一遍25分钟看完笔记：LRU缓存淘汰算法需要继续查资料，今天讲了几种链表：单项链表，双向链表，循环链表，双向循环链表，在插入和删除数据中的算法分析和数据进行了对比，在实战中如何权衡使用改如何使用，通过时间换空间还是空间换时间，老师讲的很不错，会推荐给身边学习的朋友","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466517,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567986098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131001,"user_name":"A米fans1111","can_delete":false,"product_type":"c1","uid":1239504,"ip_address":"","ucode":"99BE48333DD919","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/d0/af96c86a.jpg","comment_is_top":false,"comment_ctime":1567595258,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567595258","product_id":100017301,"comment_content":"空间换时间，双向信息量更足。","like_count":0},{"had_liked":false,"id":130276,"user_name":"铮","can_delete":false,"product_type":"c1","uid":1130721,"ip_address":"","ucode":"547EE7EA88EEF0","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/e1/e550fe7d.jpg","comment_is_top":false,"comment_ctime":1567416557,"is_pvip":false,"replies":[{"id":"48659","content":"这篇文章能解答你疑惑<br>https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;Md8tprLiESR6oQKXs_Aihw","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1567466658,"ip_address":"","comment_id":130276,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567416557","product_id":100017301,"comment_content":"关于这节有个疑问，还望解答：<br>文中说：对于第二种情况（删除给定指针指向的结点），单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要 O(1)。疑问：java中的LinkedList源码：<br>public E remove(int index) {<br>    checkElementIndex(index);<br>    return unlink(node(index));<br>}<br>其中node方法的时间复杂度就是O(n)，所以双向链表的删除指定索引结点的操作应该也是O(n)吧？我理解，您说的是针对单链表和双链表对于unlink这个方法的时间复杂度分析吧！<br><br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465887,"discussion_content":"这篇文章能解答你疑惑\nhttps://mp.weixin.qq.com/s/Md8tprLiESR6oQKXs_Aihw","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567466658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130011,"user_name":"wrzgeek","can_delete":false,"product_type":"c1","uid":1031589,"ip_address":"","ucode":"69C4980053E388","user_header":"","comment_is_top":false,"comment_ctime":1567351220,"is_pvip":false,"replies":[{"id":"48492","content":"怎么从链表的开头 跟后半部分比较呢，你可以自己写代码实现一下，你的思路不怎么对呢","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1567378639,"ip_address":"","comment_id":130011,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1567351220","product_id":100017301,"comment_content":"有个疑问，看评论里都说用快慢指针，然后对后半部分进行逆序，然后判断回文，如果不逆序，直接从单链表的头开始，跟后半部分进行比较，会有什么问题吗？求指教","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465763,"discussion_content":"怎么从链表的开头 跟后半部分比较呢，你可以自己写代码实现一下，你的思路不怎么对呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567378639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1031589,"avatar":"","nickname":"wrzgeek","note":"","ucode":"69C4980053E388","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7102,"discussion_content":"啊啊，是我想错了，脑袋没转过弯来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567386344,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128956,"user_name":"Hazy","can_delete":false,"product_type":"c1","uid":1324572,"ip_address":"","ucode":"D324003E167638","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL4XcqiaZHCzSRZmEB4DP1ibSfTwVOZTBukzmhL8ibjGk0Yt2xsmHK1nMicNg1UsuW4jiaaQVGvC56rIHg/132","comment_is_top":false,"comment_ctime":1566993692,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566993692","product_id":100017301,"comment_content":"总体思路是将 链表的一半反转，然后对比即可。<br><br>寻找链表一半可用快慢指针。<br><br>看了课后的答案，慢指针做反转工作。<br>不错的思考题","like_count":0},{"had_liked":false,"id":127341,"user_name":"氧气🌙 🐟 🌺","can_delete":false,"product_type":"c1","uid":1591015,"ip_address":"","ucode":"8E23C210A9F09E","user_header":"https://static001.geekbang.org/account/avatar/00/18/46/e7/e20279ea.jpg","comment_is_top":false,"comment_ctime":1566657999,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566657999","product_id":100017301,"comment_content":"判断字符串是否为回文的代码：<br>https:&#47;&#47;github.com&#47;zgq25302111&#47;DataStructure&#47;blob&#47;master&#47;DataStructure&#47;src&#47;Palindrome.java","like_count":0},{"had_liked":false,"id":127337,"user_name":"氧气🌙 🐟 🌺","can_delete":false,"product_type":"c1","uid":1591015,"ip_address":"","ucode":"8E23C210A9F09E","user_header":"https://static001.geekbang.org/account/avatar/00/18/46/e7/e20279ea.jpg","comment_is_top":false,"comment_ctime":1566657545,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566657545","product_id":100017301,"comment_content":"1、实现字符数组的回文算法<br>2、将单链表数据逐个取出放入字符数组<br>3、判断字符数组是否回文<br>时间复杂度O(n)<br>code:<br>1、字符数组回文算法<br>public boolean palindrome(String inStr) {<br>    \tboolean flag = true;<br>    \tchar[] str = inStr.toCharArray();<br>        int len = inStr.length();<br>        int midPos = len&#47;2;<br>        for (int i = 0; i &lt; midPos; i++) {<br>            if (str[i] != str[len-1-i]) {<br>                flag = false;<br>                break;<br>            }<br>        }<br>    \treturn flag;<br>    }","like_count":0},{"had_liked":false,"id":126980,"user_name":"苏忆","can_delete":false,"product_type":"c1","uid":1042793,"ip_address":"","ucode":"B8BE78280CCB99","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e9/69/779b48c2.jpg","comment_is_top":false,"comment_ctime":1566530228,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1566530228","product_id":100017301,"comment_content":"我感觉 缓存不算空间换时间的例子 .  因为 内存也是在使用空间的, 硬盘也是在用空间 只不过效率不一样而已.  时间换空间 应该理解为一种算法或者操作(逻辑)会慢 但是存储的变量或者元素少 但是就算的多. ","like_count":0,"discussions":[{"author":{"id":1042793,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e9/69/779b48c2.jpg","nickname":"苏忆","note":"","ucode":"B8BE78280CCB99","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6315,"discussion_content":"不过缓存肯定是在数据库的基础上，或者硬盘上多存一份，这个是利用了空间来换时间的例子。侧重点不同可能不一样。抱歉，可能理解的不够深刻。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566830516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126780,"user_name":"大白先生","can_delete":false,"product_type":"c1","uid":1615335,"ip_address":"","ucode":"7EF709EF8FFE6B","user_header":"https://static001.geekbang.org/account/avatar/00/18/a5/e7/ed0a0131.jpg","comment_is_top":false,"comment_ctime":1566473895,"is_pvip":false,"replies":[{"id":"47242","content":"看这个：https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;Md8tprLiESR6oQKXs_Aihw","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1566773866,"ip_address":"","comment_id":126780,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566473895","product_id":100017301,"comment_content":"我这边自己实现了一个单向链表，我觉得，如果是每次都向最后插入一个节点的话，每次都需要顺序找到最后一个节点，那时间复杂度不是O(n)么，请问为什么是O(1)呢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464163,"discussion_content":"看这个：https://mp.weixin.qq.com/s/Md8tprLiESR6oQKXs_Aihw","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566773866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126751,"user_name":"大眼睛charlyne","can_delete":false,"product_type":"c1","uid":1200597,"ip_address":"","ucode":"74BC5988BA2453","user_header":"https://static001.geekbang.org/account/avatar/00/12/51/d5/c0a4ec9f.jpg","comment_is_top":false,"comment_ctime":1566464139,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566464139","product_id":100017301,"comment_content":"1.使用快慢指针slow，fast，遍历链表，找到中间节点；<br>2.遍历的同时，反转前一半链表（因为需要记录slow的位置，所以使用pre，prepre反转）<br>3.比较前一半链表和后一半链表<br>复杂度：因为没有使用额外的空间，故空间复杂度O(1),<br>时间复杂度(使用加法法则)<br>T(n)=O(1&#47;2 n)+O(1&#47;2 n)=O(max{1&#47;2 n,1&#47;2 n})=O(1&#47;2 n)=O(n)<br>class Solution {<br>    public boolean isPalindrome(ListNode head) {<br>        if(head==null||head.next==null)return true;<br>        ListNode slow=head;<br>        ListNode fast=head.next;<br>        ListNode pre=null;<br>        ListNode prePre=null;<br>        while(fast!=null&amp;&amp;fast.next!=null){<br>            pre=slow;<br>            slow=slow.next;<br>            fast=fast.next.next;<br>            pre.next=prePre;<br>            prePre=pre;<br>        }<br>        ListNode q=slow.next;<br>        slow.next=pre;<br>        ListNode p=(fast==null)?pre:slow;<br>        while(q!=null){<br>            if(p.val!=q.val){<br>                return false;<br>            }<br>            p=p.next;<br>            q=q.next;<br>        }<br>        return true;<br>      <br>        <br>    }<br>}","like_count":0},{"had_liked":false,"id":124186,"user_name":"sunxx","can_delete":false,"product_type":"c1","uid":1017145,"ip_address":"","ucode":"64C2B1671160FE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/85/39/0175b989.jpg","comment_is_top":false,"comment_ctime":1565833152,"is_pvip":false,"replies":[{"id":"45682","content":"p=p-&gt;next-&gt;next;","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1565907262,"ip_address":"","comment_id":124186,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1565833152","product_id":100017301,"comment_content":"单链表只有一个指向next的地址，那快指针是如何实现走两步的？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463047,"discussion_content":"p=p-&amp;gt;next-&amp;gt;next;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565907262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1017145,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/85/39/0175b989.jpg","nickname":"sunxx","note":"","ucode":"64C2B1671160FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4934,"discussion_content":"走两步=>指针向前推两次，每次还只是走一步","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565843413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123837,"user_name":"°山°","can_delete":false,"product_type":"c1","uid":1442785,"ip_address":"","ucode":"4A454F627F8F6D","user_header":"https://static001.geekbang.org/account/avatar/00/16/03/e1/fdaa7a53.jpg","comment_is_top":false,"comment_ctime":1565769280,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565769280","product_id":100017301,"comment_content":"删除给定指针指向的结点，用单链表也是可以达到O（1）的<br>思路：可以把要删除结点看做“前驱结点”，用删除结点的下一个结点覆盖要删除结点的内容，最后再释放删除结点的下一个结点的空间。简而言之，就是进行数据拷贝，并删除下一个结点。<br>操作：假设要删除节点为node，temp=node-&gt;next，<br>node-&gt;data=temp-&gt;data, node-&gt;next=temp-&gt;next<br>free(temp)","like_count":0},{"had_liked":false,"id":123174,"user_name":"行知","can_delete":false,"product_type":"c1","uid":1052542,"ip_address":"","ucode":"457876AFC0D8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/0f/7e/f10ff251.jpg","comment_is_top":false,"comment_ctime":1565619972,"is_pvip":false,"replies":[{"id":"45690","content":"链表头放最早访问的还是链表尾部放最早访问的，都可以的，看你自己怎么设计了。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1565908919,"ip_address":"","comment_id":123174,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565619972","product_id":100017301,"comment_content":"我的思路是这样的：我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。 不是链表头部是最早访问的吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462568,"discussion_content":"链表头放最早访问的还是链表尾部放最早访问的，都可以的，看你自己怎么设计了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565908919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123125,"user_name":"冰风落叶","can_delete":false,"product_type":"c1","uid":1128059,"ip_address":"","ucode":"E4DE480B95A17D","user_header":"https://static001.geekbang.org/account/avatar/00/11/36/7b/3788ca13.jpg","comment_is_top":false,"comment_ctime":1565611389,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565611389","product_id":100017301,"comment_content":"知识点总结：<br>1. 缓存可以提高数据读取性能，但是当缓存满了之后，如何清理缓存呢？有三种策略：先进先出策略 FIFO、最少使用策略LFU、最近最少使用策略LRU(核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”，即删除长期不用的)<br>2. 链表是零散的内存块，插入和删除的时间复杂度是O(1)，查找的时间复杂度是O(n)<br>3. 数组是连续的内存空间，插入和删除的时间复杂度O(n)，按下标查找的时间复杂度是O(1)<br>4. 链表分为：单向链表（后继指针指向下一个节点，尾结点的指向NULL）、循环链表（尾结点的后继指针指向头结点的数据）、双向链表（多了一个前驱指针指向前边的节点）、双向循环链表（多前驱指针和尾结点指向头结点）<br>5. 如果对内存要求非常苛刻，数组适合你，因为链表的每个节点都需要耗费额外的空间去存放下一个节点的指针，而且对链表频繁的插入、删除，会导致频繁的内存申请和释放，容易造成内存碎片<br>6. 数组连续的内存空间，借助CPU缓存机制可以预读数据，而链表因为内存的不连续性，所以对CPU缓存不友好，没办法有效预读<br><br>课后作业：<br>一、LRU缓存淘汰算法-链表实现：<br> 1. 如果缓存中已存在，将链表中的此元素删除，并且将新数据放入头结点<br> 2. 如果不在缓存中：<br>  (1). 缓存未满，直接插入到头结点<br>  (2). 缓存已满，删除尾结点，将新数据插入到头结点<br> 总时间复杂度：O(n) , 因为查找是否在缓存中需要按个判断<br>二、LRU缓存淘汰算法-数组实现：<br> 1.如果数组中已存在此数据，删除数组中的此数据，并将新数据放入数组尾部，时间复杂度为O(n)<br> 2.如果不在缓存中：<br>  (1). 缓存未满，插入数组尾部，时间复杂度O(1)<br>  (2). 缓存已满，删除数组头元素，并将新数据插入到数组尾部，时间复杂度O(n)<br> 总时间复杂度：O(n)<br>三、字符串用单向链表存储，如果判断此字符串是一个回文串呢？（level 返过来也是 level）<br> 1. 设定一个步长为1的慢指针，和一个步长为2的快指针，当快指针走完整个链表时，慢指针刚好走到一半<br> 2. 慢指针边走边将后继指针指向前一个节点，造成前半个链表反序<br> 3. 当慢指针指向中间时，新设定初始化一个指针，指向前半个反序链表的第一个，然逐个与慢指针的数据做比较，如果完全一致，则为回文串，否则不是<br> 4. 做完对比之后，将前半个反序的链表还原<br> 总时间复杂度：O(n)<br> 总空间复杂度：O(1)","like_count":0},{"had_liked":false,"id":121709,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1565188664,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565188664","product_id":100017301,"comment_content":"看了答案之后尽然有快慢指针的这种操作啊，我了个去去去～～～佩服～～～","like_count":0},{"had_liked":false,"id":121708,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1565188557,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565188557","product_id":100017301,"comment_content":"判断是否是回文字符串，这个是个算法题目，我之前的解法是 for 循环从字符串的头和尾巴向内部遍历，比较。但是是类似于数组的解法；<br><br>如果是单链表的话，那么需要遍历一次链表，然后记录下元素和链表的位置到数组中，这样处理。","like_count":0},{"had_liked":false,"id":119942,"user_name":"Langzi233","can_delete":false,"product_type":"c1","uid":1042685,"ip_address":"","ucode":"5A21AC08FC089B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e8/fd/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1564734070,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564734070","product_id":100017301,"comment_content":"看了留言的答案好惭愧，高手们都是用链表折中反转来实现的，我得好好总结整理下一下链表的的使用了","like_count":0},{"had_liked":false,"id":119936,"user_name":"Langzi233","can_delete":false,"product_type":"c1","uid":1042685,"ip_address":"","ucode":"5A21AC08FC089B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e8/fd/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1564733574,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564733574","product_id":100017301,"comment_content":"这个留言太不走好了没点发布也给发出去了，但愿老师能看到。简单说吧，用单链表实现回文字符串的检测不能像数组那样从两头遍历了。但是可以从回文字符串本事的特性入手，在不加入其他数据结构辅助的前提下，解题思路是：从链表的第一个节点开始，能找和节点数据域相同的节点(暂且理解为镜像节点）且这个节点是紧挨着上一个镜像节点。想象一下，节点从头部开始往后挪，镜像节点从尾部往前挪，只要记录这个镜像节点并以它为参照，就不需要遍历已经检查过的尾部节点啦","like_count":0},{"had_liked":false,"id":119929,"user_name":"Langzi233","can_delete":false,"product_type":"c1","uid":1042685,"ip_address":"","ucode":"5A21AC08FC089B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e8/fd/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1564732922,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564732922","product_id":100017301,"comment_content":"想了半天，编码的时候又有些灵感优化，鉴于老师说的是用单链表实现，所以不能像数组那样从两头往中间逐步鉴别。所以只能从回文字符串本身的特性出发，我的解题思路是：从头开始字符串还是依次取的，那么对应的镜像字符","like_count":0},{"had_liked":false,"id":117858,"user_name":"Geek_2a6093","can_delete":false,"product_type":"c1","uid":1395560,"ip_address":"","ucode":"9C216A0B09A7AF","user_header":"https://static001.geekbang.org/account/avatar/00/15/4b/68/a6198a59.jpg","comment_is_top":false,"comment_ctime":1564151301,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564151301","product_id":100017301,"comment_content":"在单向链表中，按指针删除结点同样可以做到O(1)的时间复杂度。因为可以把下一个结点存储的值赋值给当前指针指向的结点，然后删除下一个结点，使当前结点指向下下个结点。同理，在插入前一个结点的方式，同样可以采用这种赋值的方法实现。","like_count":0},{"had_liked":false,"id":116756,"user_name":"lyh","can_delete":false,"product_type":"c1","uid":1520381,"ip_address":"","ucode":"EF7C85CD278A94","user_header":"","comment_is_top":false,"comment_ctime":1563912687,"is_pvip":false,"replies":[{"id":"42889","content":"赋值的方法是另一种思路，但有时候数据比较大或者不适合赋值，那就没法用你方法了。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1564009067,"ip_address":"","comment_id":116756,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563912687","product_id":100017301,"comment_content":"老师好，有个问题冒昧请教。对于您所说的单向链表给定节点的删除问题。我觉得是存在O（1）的复杂度的。若给定节点位于表头或表中间。则可以将给定节点的下一个节点val赋给给定节点，并将给定节点.next指向给定节点.next.next。然后删除给定节点的下一个节点。由于单链表是可以便捷查询next节点的。因此除开表尾节点无法使用该方法，只能遍历链表，复杂度为O(1)外。表中和表头的删除都可以做到O(1)。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459674,"discussion_content":"赋值的方法是另一种思路，但有时候数据比较大或者不适合赋值，那就没法用你方法了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564009067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":116274,"user_name":"Cooper","can_delete":false,"product_type":"c1","uid":1607867,"ip_address":"","ucode":"D940921B53F1DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/88/bb/f569045d.jpg","comment_is_top":false,"comment_ctime":1563811823,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563811823","product_id":100017301,"comment_content":"很多方法是：<br>01: 字符串长度必须是奇数字，否则 return false<br>02: 额外创建两个Array&#47;List，遍历字符串 O(n)，分别正向&#47;逆向存储字符串<br>03: 遍历单个Array&#47;List 分别去除对应index的值，进行Equals比较 O(n)<br>会产生两个O(n)的复杂度，当然 O(n) = O(n) + O(n)<br><br>优化方案01:<br>判断是否是水仙花数组时间复杂度 = 0.5 * O(n) ～= O(n)<br>充分利用水仙花字符串特点，找出位于中位数的index，可以在一次遍历中取出左右对称Index，并且不会带来额外空间开支。<br>&#47;&#47; declare<br>String string = &quot;01234543210&quot;;<br><br>char[] arr = string.toCharArray();<br>int size = arr.length;<br>Assert.assertTrue(size % 2 == 1);<br><br>int meanIndex = (int) Math.floor(size &#47; 2);<br>for (int i = 0; i &lt; meanIndex; i++) {<br>    Assert.assertEquals(arr[i], arr[size - i - 1]);<br>}<br><br>&#47;&#47; alternative loop, same O()<br>&#47;&#47;for (int i = meanIndex - 1; i &lt;= 0; i--) {<br>&#47;&#47;    Assert.assertEquals(arr[i], arr[size - i - 1]);<br>&#47;&#47;}","like_count":0},{"had_liked":false,"id":113697,"user_name":"大润","can_delete":false,"product_type":"c1","uid":1160266,"ip_address":"","ucode":"56111928F02BE4","user_header":"https://static001.geekbang.org/account/avatar/00/11/b4/4a/27aba93f.jpg","comment_is_top":false,"comment_ctime":1563120521,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563120521","product_id":100017301,"comment_content":"都这么厉害吗哈哈","like_count":0},{"had_liked":false,"id":113521,"user_name":"cliff(亮剑)","can_delete":false,"product_type":"c1","uid":1314866,"ip_address":"","ucode":"A8D1A92331AE20","user_header":"https://static001.geekbang.org/account/avatar/00/14/10/32/e37aacfe.jpg","comment_is_top":false,"comment_ctime":1563066778,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563066778","product_id":100017301,"comment_content":"没有讲头指针","like_count":0},{"had_liked":false,"id":112777,"user_name":"逻各斯与努斯","can_delete":false,"product_type":"c1","uid":1476477,"ip_address":"","ucode":"148F124E649B0F","user_header":"https://static001.geekbang.org/account/avatar/00/16/87/7d/5b331647.jpg","comment_is_top":false,"comment_ctime":1562824837,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562824837","product_id":100017301,"comment_content":"一、什么是回文字符串？<br>回文字符串简单来说就是关于中点左右对称的字符串。<br>二、练习题思路<br>1、快慢指针找到链表中点。具体做法是定义a,b两个指针，a的步长是b的一半。a,b同时从头结点开始遍历，因为b的速度比a快一倍，相同时间下，当b遍历到最后一个节点（尾结点）时，a恰好到达链表的中部节点。<br>2、将中点之后的链表指针方向反转，即逆转。<br>3、前半段链表从头节点开始遍历，后半段聊表从尾结点开始遍历，一一对比节点字母是否相同。<br>","like_count":0},{"had_liked":false,"id":112264,"user_name":"memdreams","can_delete":false,"product_type":"c1","uid":1599165,"ip_address":"","ucode":"0AE081B72CF0C0","user_header":"","comment_is_top":false,"comment_ctime":1562707574,"is_pvip":false,"replies":[{"id":"40901","content":"靠自己的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1562739314,"ip_address":"","comment_id":112264,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562707574","product_id":100017301,"comment_content":"是不是学完一篇就应该到github上根据对应章节的练习题来自己编程实现啊？还是有专门的课程讲对应题目呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457645,"discussion_content":"靠自己的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562739314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111706,"user_name":"Yocn","can_delete":false,"product_type":"c1","uid":1348568,"ip_address":"","ucode":"35BDF12EA130C3","user_header":"https://static001.geekbang.org/account/avatar/00/14/93/d8/8bab3fb5.jpg","comment_is_top":false,"comment_ctime":1562587461,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562587461","product_id":100017301,"comment_content":"LinkedHashmap就是集hashmap跟双向链表的优点于一身","like_count":0},{"had_liked":false,"id":111422,"user_name":"A Kevin🍰","can_delete":false,"product_type":"c1","uid":1597650,"ip_address":"","ucode":"FF8212AB0DBEAD","user_header":"https://static001.geekbang.org/account/avatar/00/18/60/d2/360eff88.jpg","comment_is_top":false,"comment_ctime":1562555714,"is_pvip":false,"replies":[{"id":"40678","content":"请问讲解什么呢？","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1562631775,"ip_address":"","comment_id":111422,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562555714","product_id":100017301,"comment_content":"class Solution {<br>    private static final char[]charMap = new char[256];<br>    static{<br>        for(int i=0;i&lt;10;i++){<br>            charMap[i+&#39;0&#39;] = (char)(1+i);  &#47;&#47; numeric<br>        }<br>        for(int i=0;i&lt;26;i++){<br>            charMap[i+&#39;a&#39;] = charMap[i+&#39;A&#39;] = (char)(11+i);  &#47;&#47;alphabetic, ignore cases<br>        }<br>    }<br>    <br>    public boolean isPalindrome(String s) {<br>        char[]pChars = s.toCharArray();<br>        int start = 0,end=pChars.length-1;<br>        char cS,cE;<br>        while(start&lt;end){<br>            cS = charMap[pChars[start]];<br>            cE = charMap[pChars[end]];<br>            if(cS!=0 &amp;&amp; cE!=0){<br>                if(cS!=cE)return false;<br>                start++;<br>                end--;<br>            }else{<br>                if(cS==0)start++;<br>                if(cE==0)end--;<br>            }<br>        }<br>        return true;<br>    }<br>}<br>LeetCode上的 大神能否讲解下 这个1ms执行完毕","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457349,"discussion_content":"请问讲解什么呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562631775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110129,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1562199618,"is_pvip":false,"replies":[{"id":"40132","content":"“链表最原始的定义是指针指向下一个节点”这个理解不对呢，链表结点中的next指针是存储的下一个结点的地址。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1562281707,"ip_address":"","comment_id":110129,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562199618","product_id":100017301,"comment_content":"用Python实现链表时，我看代码中比较连个节点都是实用“==”操作符。这样应该是有问题的吧？<br><br>既然链表最原始的定义是指针指向下一个节点，那么和地址相关的比较应该用“is”，否则如果是一个循环链表，用“==”去比较两个节点是否相等会导致一致递归的比较next所指对象是否相同，从而导致解释器抛出异常","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456735,"discussion_content":"“链表最原始的定义是指针指向下一个节点”这个理解不对呢，链表结点中的next指针是存储的下一个结点的地址。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562281707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109918,"user_name":"Geek_972dec","can_delete":false,"product_type":"c1","uid":1593195,"ip_address":"","ucode":"85CA7042F5BC35","user_header":"","comment_is_top":false,"comment_ctime":1562133760,"is_pvip":false,"replies":[{"id":"40134","content":"当知道了前驱结点的时候，插入操作时间复杂度是O(1)。当不知道前驱结点的时候，我们要遍历链表，找到结点的前驱结点，这个时候，时间复杂度就是O(n)。<br><br>但在实际的软件开发中，这两种情况都是存在的，所以，不能一概而论说都是O(n)","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1562281885,"ip_address":"","comment_id":109918,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562133760","product_id":100017301,"comment_content":"文中说链表的删除，插入操作复杂度是O(1),但在实际开发中，单向链表删除或插入操作由于需要查找前驱节点所以复杂度是O(n)，那岂不是和数组复杂度相同了吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456640,"discussion_content":"当知道了前驱结点的时候，插入操作时间复杂度是O(1)。当不知道前驱结点的时候，我们要遍历链表，找到结点的前驱结点，这个时候，时间复杂度就是O(n)。\n\n但在实际的软件开发中，这两种情况都是存在的，所以，不能一概而论说都是O(n)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562281885,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109750,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1562104379,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562104379","product_id":100017301,"comment_content":"相对于数组，链表是通过指针链接的线性结构，因而比较松散。松散带来的好处是可轻易收缩扩展，可以利用碎片化的内存。付出的主要成本是随机访问，不能通过一个偏移量访问其他元素，指针的存储是另外一项成本。<br><br><br>","like_count":0},{"had_liked":false,"id":108295,"user_name":"Monroe  He","can_delete":false,"product_type":"c1","uid":1348219,"ip_address":"","ucode":"D04ECB2EF2E0DA","user_header":"https://static001.geekbang.org/account/avatar/00/14/92/7b/8c7e3e61.jpg","comment_is_top":false,"comment_ctime":1561714740,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561714740","product_id":100017301,"comment_content":"判断回文字符串：<br>先判断链表长度1）奇数：找到中间位置，将其删除，再比较中间两个位置是否相等，若相等则删掉这两个元素，若不等则返回不是回文<br>2）偶数，直接比较中间两个元素值是否相等<br>时间复杂度：每次删除都需要查找后一个元素的前一个位置，时间复杂度O(n2)，空间复杂度O(n)","like_count":0},{"had_liked":false,"id":107681,"user_name":"谢烟客","can_delete":false,"product_type":"c1","uid":1004766,"ip_address":"","ucode":"DC9E1F82AFE67D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/de/fabe5f93.jpg","comment_is_top":false,"comment_ctime":1561596474,"is_pvip":false,"replies":[{"id":"38948","content":"@编辑","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1561598002,"ip_address":"","comment_id":107681,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561596474","product_id":100017301,"comment_content":"【链表要想随机访问第 k 个元素，就没有数组那么高效了。】这段语音读的是：第 n 个元素","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455625,"discussion_content":"@编辑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561598002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107425,"user_name":"x","can_delete":false,"product_type":"c1","uid":1472233,"ip_address":"","ucode":"75FA829EA820AB","user_header":"https://static001.geekbang.org/account/avatar/00/16/76/e9/73ed6cc1.jpg","comment_is_top":false,"comment_ctime":1561534336,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1561534336","product_id":100017301,"comment_content":"作为一个前端有点不知所措","like_count":0},{"had_liked":false,"id":107048,"user_name":"waldow","can_delete":false,"product_type":"c1","uid":1299189,"ip_address":"","ucode":"A1E35BEFE5C052","user_header":"https://static001.geekbang.org/account/avatar/00/13/d2/f5/b2c95027.jpg","comment_is_top":false,"comment_ctime":1561448136,"is_pvip":false,"replies":[{"id":"38957","content":"也可以的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1561598889,"ip_address":"","comment_id":107048,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561448136","product_id":100017301,"comment_content":"有个问题，lru实现时，文中提到数据如果已在链表中，要先删除后在链表头插入新节点，为什么不直接把此节点的pre置为null，next置为瘦节点尼","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455340,"discussion_content":"也可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561598889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106988,"user_name":"cjxz","can_delete":false,"product_type":"c1","uid":1588610,"ip_address":"","ucode":"9735F51D4721E9","user_header":"","comment_is_top":false,"comment_ctime":1561432741,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561432741","product_id":100017301,"comment_content":"如果是基于数组实现LRU算法可以考虑两种结果，例如数组长度为n，现在需要得到一个缓存数据x，需要遍历这个n。有两种情况：<br>1.在n中找到了数据x，索引是i，则将索引i的数据和索引为0的数据进行交换。当然还有另一种方案，就是将索引0-i的数据后移一位。<br>2.如果n中没有找到数据x，则直接将索引为0的数据设置为x，然后数组内容依次后移一位。<br>个人觉得使用数组实现效率没有链表高。因为在查找效率上面来说链表和数组的时间复杂度都是O(n)但是在移动数据效率上面，链表是O(1)而数组是O(n)","like_count":0},{"had_liked":false,"id":105612,"user_name":"NELSONLIN","can_delete":false,"product_type":"c1","uid":1581899,"ip_address":"","ucode":"F3A45E93B00337","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eokorAhvqntTcyNLEtrAx5ricAAaeibEYibELtNKIVK5jtfib77TKUiacNsMrhp2eKph4I2KVYyGxCfQ2g/132","comment_is_top":false,"comment_ctime":1561041666,"is_pvip":false,"replies":[{"id":"38640","content":"对于链表的删除操作来说，必须知道其前驱结点。你可以自己写代码实现一下，就知道了。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1561419850,"ip_address":"","comment_id":105612,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561041666","product_id":100017301,"comment_content":"我有一个疑惑关于链表的删除操作的第二种： 删除给定指针指向的结点，既然已经给定指针指向，不就直接删除就可以了吗，为什么删除它还需要知道他的前驱结点?","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454740,"discussion_content":"对于链表的删除操作来说，必须知道其前驱结点。你可以自己写代码实现一下，就知道了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561419850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104589,"user_name":"tong467","can_delete":false,"product_type":"c1","uid":1560667,"ip_address":"","ucode":"544F6FB2C5A936","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJjw7KXibCGnibOm3O73xCGyCzdmgKuc017X8IQZCdNvAWxoWxHSgMTLgd7rGs1LCBPaU5oHbO16F0A/132","comment_is_top":false,"comment_ctime":1560780215,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560780215","product_id":100017301,"comment_content":"课后思考题 单链表判断回文<br><br>class Scratch {<br><br>    public static void main(String[] args) {<br>        System.out.println(palindrome(&quot;cabb1bbac&quot;));<br>    }<br><br>    public static boolean palindrome(String str) {<br>        char[] cArray = str.toCharArray();<br>        Node node = new Node(cArray[0], null);<br>        Node head = node;<br>        for (int i = 1; i &lt; cArray.length; i++) {<br>            node.next = new Node(cArray[i], null);<br>            node = node.next;<br>        }<br>        Node fast = head, slow = head, reverse = null;<br>        while (true) {<br>            &#47;&#47;单数并且已经到达中间节点<br>            if (fast.next == null) {<br>                &#47;&#47;慢节点像前走一步对齐反转节点<br>                slow = slow.next;<br>                while (slow.next != null) {<br>                    if (slow.c != reverse.c) {<br>                        return false;<br>                    }<br>                    slow = slow.next;<br>                    reverse = reverse.next;<br>                }<br>                return true;<br>            }<br>            &#47;&#47;双数到达终点慢指到中间节点<br>            if (fast.next != null &amp;&amp; fast.next.next == null) {<br>                &#47;&#47;慢节点与下一个节点对比两个中心点是否相同<br>                if (slow.c != slow.next.c) {<br>                    return false;<br>                }<br>                &#47;&#47;慢节点像前走一步对齐反转节点<br>                slow = slow.next.next;<br>                while (slow.next != null) {<br>                    if (slow.c != reverse.c) {<br>                        return false;<br>                    }<br>                    slow = slow.next;<br>                    reverse = reverse.next;<br>                }<br>                return true;<br>            }<br>            Node temp = slow;<br>            fast = fast.next.next;<br>            slow = slow.next;<br>            temp.next = reverse;<br>            reverse = temp;<br>        }<br><br><br>    }<br>}<br><br>class Node {<br><br>    &#47;**<br>     * 初始站位<br>     *&#47;<br>    char c;<br>    &#47;**<br>     * 下一个节点<br>     *&#47;<br>    Node next;<br><br>    public Node(char c, Node next) {<br>        this.c = c;<br>        this.next = next;<br>    }<br>}","like_count":0},{"had_liked":false,"id":104387,"user_name":"tong467","can_delete":false,"product_type":"c1","uid":1560667,"ip_address":"","ucode":"544F6FB2C5A936","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJjw7KXibCGnibOm3O73xCGyCzdmgKuc017X8IQZCdNvAWxoWxHSgMTLgd7rGs1LCBPaU5oHbO16F0A/132","comment_is_top":false,"comment_ctime":1560742041,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560742041","product_id":100017301,"comment_content":"import java.util.Arrays;<br><br>&#47;**<br> * 约瑟夫问题<br> *&#47;<br>class Scratch {<br><br>    public static void main(String[] args) {<br>        System.out.println(Arrays.toString(joseph(30, 9, 15)));<br>    }<br><br>    &#47;**<br>     * 约瑟夫问题<br>     *<br>     * @param totle 总数<br>     * @param killNum 死亡间隔<br>     * @param survivor 幸存者数量<br>     * @return 站位<br>     *&#47;<br>    public static int[] joseph(int totle, int killNum, int survivor) {<br>        int[] sArray = new int[survivor];<br>        &#47;&#47;初始化数据<br>        Node head = new Node(1, null);<br>        &#47;&#47;临时存储头节点<br>        Node temp = head;<br>        for (int i = 1; i &lt; totle; i++) {<br>            head.next = new Node(i + 1, null);<br>            head = head.next;<br>        }<br>        &#47;&#47;建立环形链表<br>        head.next = temp;<br>        &#47;&#47;开始击杀<br>        int currentKill = 0, killIndex = 1;<br>        while ((totle - currentKill) != survivor) {<br>            &#47;&#47;找到该节点的前节点<br>            while (killIndex != killNum - 1) {<br>                temp = temp.next;<br>                killIndex++;<br>            }<br>            &#47;&#47;杀掉 通过该节点的前节点指向该节点的后节点杀掉该节点<br>            temp.next = temp.next.next;<br>            &#47;&#47;重新计数<br>            killIndex = 1;<br>            &#47;&#47;记录以杀个数<br>            currentKill++;<br>            &#47;&#47;从下一个人开始读数<br>            temp = temp.next;<br>        }<br>        getIndex(temp, sArray);<br>        return sArray;<br><br>    }<br><br>    public static void getIndex(Node head, int[] iArray) {<br>        &#47;&#47;存储头节点用于判断是否遍历一圈<br>        Node temp = head;<br>        int i = 0;<br>        do {<br>            iArray[i++] = head.i;<br>            head = head.next;<br>        } while (temp != head);<br>    }<br>}<br><br>class Node {<br>    &#47;**<br>     * 初始站位<br>     *&#47;<br>    int i;<br>    &#47;**<br>     * 下一个节点<br>     *&#47;<br>    Node next;<br><br>    public Node(int i, Node next) {<br>        this.i = i;<br>        this.next = next;<br>    }<br>}","like_count":0},{"had_liked":false,"id":104043,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1560599940,"is_pvip":false,"replies":[{"id":"37641","content":"当然可以学好，你只要能坚持学一年，你就自然有答案了。就怕坚持不下去。你可以看看我后面写的加餐文章，对你坚持学习应该有帮助。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560640617,"ip_address":"","comment_id":104043,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560599940","product_id":100017301,"comment_content":"老师，我是面向CRUD的boy。<br><br>我今天把数组那一节的实现写了一下，也兑了一下。<br><br>老师，我不是科班出身，毕业三年了。<br>有没有可能学好数据结构与算法，做一个不是二三流的开发者。  可能是我想让老师鼓励一下吧，但是还是想听老师的看法。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454100,"discussion_content":"当然可以学好，你只要能坚持学一年，你就自然有答案了。就怕坚持不下去。你可以看看我后面写的加餐文章，对你坚持学习应该有帮助。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560640617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104012,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1560589245,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560589245","product_id":100017301,"comment_content":"数组vs链表<br>从数据结构操作的角度看，可以从插入和查询的时间复杂度和存储的空间复杂度角度入手；<br>从操作系统的角度看，数组更好利用局部性原理来利用缓存，但其容量一旦申请除非全量拷贝否则无法扩展，链表则没有这种限制，但其无法充分利用CPU缓存，且会因为频繁的插入和删除操作导致内存碎片增加，导致GC频繁；<br>从网络的数据交换格式的角度看，如JSON，最终依然是以数组的形式表现。","like_count":0},{"had_liked":false,"id":103994,"user_name":"时光剪影","can_delete":false,"product_type":"c1","uid":1093159,"ip_address":"","ucode":"CC6F24C30AE3E6","user_header":"https://static001.geekbang.org/account/avatar/00/10/ae/27/3dfcc699.jpg","comment_is_top":false,"comment_ctime":1560584549,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560584549","product_id":100017301,"comment_content":"缓存算法：<br>FIFO；<br>LFU；<br>LRU；<br><br>数组和链表都是线性表。<br><br>内存方面：<br>数组分配的是连续内存空间；<br>链表分配的是不连续的内存空间；<br><br>链表包含如下结构<br>单链表：<br>删除 新增时间复杂度为O(1)，查询O(n)<br>结点=data + next 指针<br>只能往一个方向遍历<br>尾结点的next指针为空<br><br>双向链表：<br>删除 新增时间复杂度为O(1)，查询O(n)<br>结点=prev指针+ data + next 指针<br>通过一个结点可以查询到前驱结点和后继结点<br><br>循环链表：<br>是特殊的单链表<br>尾结点指向链表的头结点<br><br><br>双向循环链表：<br>删除 新增时间复杂度为O(1)，查询O(n)<br>结点=prev指针+ data + next 指针<br>通过一个结点可以查询到前驱结点和后继结点<br>last的next指向first，first的prev指向last<br><br>回文字符串如何使用单链表实现？<br>先判断<br>first.data==last.data <br><br>","like_count":0},{"had_liked":false,"id":103649,"user_name":"tong467","can_delete":false,"product_type":"c1","uid":1560667,"ip_address":"","ucode":"544F6FB2C5A936","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJjw7KXibCGnibOm3O73xCGyCzdmgKuc017X8IQZCdNvAWxoWxHSgMTLgd7rGs1LCBPaU5oHbO16F0A/132","comment_is_top":false,"comment_ctime":1560482833,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560482833","product_id":100017301,"comment_content":"因字数限制，删除了getset方法，注释，及其输出信息，数组lru算法。<br>import java.util.HashMap;<br>import java.util.Map;<br>import java.util.Random;<br><br>class Scratch {<br><br>    private static Entity[] cache = new Entity[10];<br>    private static Map&lt;Integer, Entity&gt; disk = new HashMap&lt;&gt;();<br><br>    static {<br>        Random random = new Random();<br>        for (int i = 0; i &lt; 1000; i++) {<br>            disk.put(i, new Entity(i, random.nextDouble()));<br>        }<br>    }<br><br>    public static void main(String[] args) {<br>        int j = 0;<br>        Random random = new Random();<br>        do {<br>            int i = random.nextInt(10);<br>            getValueByCache(i);<br>            j++;<br>        } while (j &lt; 100);<br>    }<br><br>    public static Entity getValueByDisk(int key) {<br>        try {<br>            Thread.sleep(1000);<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        return disk.get(key);<br>    }<br>    <br>    public static Entity getValueByCache(int key) {<br>        Entity entity = null;<br>        boolean hit = false;<br>        for (int i = 0; i &lt; cache.length; i++) {<br>            Entity temp = cache[i];<br>            if (temp == null) {<br>                break;<br>            }<br>            if (temp.key == key) {<br>                entity = temp;<br>                for (int j = i; j &gt; 0; j--) {<br>                    cache[j] = cache[j - 1];<br>                }<br>                cache[0] = temp;<br>                hit = true;<br>                break;<br>            }<br>        }<br>        if (!hit) {<br>            Entity entityByDisk = getValueByDisk(key);<br>            for (int i = cache.length - 1; i &gt; 0; i--) {<br>                cache[i] = cache[i - 1];<br>            }<br>            cache[0] = entityByDisk;<br>            entity = entityByDisk;<br>        }<br>        return entity;<br>    }<br>}<br><br>class Entity {<br><br>    public int key;<br>    public double value;<br><br>    public Entity(int key, double value) {<br>        this.key = key;<br>        this.value = value;<br>    }<br>}<br>不只是否对。","like_count":0},{"had_liked":false,"id":103185,"user_name":"Charley Choi 🎃","can_delete":false,"product_type":"c1","uid":1235154,"ip_address":"","ucode":"E43371C6B2BBDA","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/d2/8bc05ccf.jpg","comment_is_top":false,"comment_ctime":1560392981,"is_pvip":false,"replies":[{"id":"37462","content":"为啥是最少呢？并没有记录次数呀","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560472694,"ip_address":"","comment_id":103185,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560392981","product_id":100017301,"comment_content":"老师，你用链表实现的LRU 缓存淘汰算法，我怎么感觉是LFU算法的实现呢？因为靠近尾部的节点始终是最少访问的，当数组没有空间时，删除的也是该节点，达不到“最近”的这种实现思想吧","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453776,"discussion_content":"为啥是最少呢？并没有记录次数呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560472694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102338,"user_name":"ILoveKindness","can_delete":false,"product_type":"c1","uid":1559444,"ip_address":"","ucode":"A6210B034AAC62","user_header":"https://static001.geekbang.org/account/avatar/00/17/cb/94/eedbace3.jpg","comment_is_top":false,"comment_ctime":1560210209,"is_pvip":false,"replies":[{"id":"37270","content":"看你具体的需求了，一般不需要。除非你有需求是频繁的计算链表中数据的个数。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560381972,"ip_address":"","comment_id":102338,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560210209","product_id":100017301,"comment_content":"老师好，我对于实际情况构建链表有一个疑问，我们是否需要将链表的节点总数保存在结构中。比如在c语言中，使用一个struct里面存放链表头和节点总数，请老师指点","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453369,"discussion_content":"看你具体的需求了，一般不需要。除非你有需求是频繁的计算链表中数据的个数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560381972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101495,"user_name":"Ooooo","can_delete":false,"product_type":"c1","uid":1236511,"ip_address":"","ucode":"3C20873BF04FD3","user_header":"https://static001.geekbang.org/account/avatar/00/12/de/1f/936c98c2.jpg","comment_is_top":false,"comment_ctime":1559827161,"is_pvip":false,"replies":[{"id":"36774","content":"代码二在哪里呢？06讲没有呢","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560122600,"ip_address":"","comment_id":101495,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559827161","product_id":100017301,"comment_content":"代码二有点问题，最后的if中i==n-1中，应该再判断下n-1的值是否等于key","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452989,"discussion_content":"代码二在哪里呢？06讲没有呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560122600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101198,"user_name":"申鹏飞","can_delete":false,"product_type":"c1","uid":1331464,"ip_address":"","ucode":"429211A63F6314","user_header":"https://static001.geekbang.org/account/avatar/00/14/51/08/0460f6eb.jpg","comment_is_top":false,"comment_ctime":1559739277,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559739277","product_id":100017301,"comment_content":"相对于数组，链表不需要连续的内存空间，分散存储数据，但是需要一个next 指针指向后续节点，要比数组需要更多的内存空间。<br>能避免因为数组过大而申请不到内存的空间，同时，天然支持动态扩容。<br><br>常见的链表有：单链表，循环链表，双链表。<br><br>单纯的 链表的插入删除操作时间复杂度为O(1)<br>但是 删除某个值 或者 删除某个节点的 操作 单链表 与 双链表 时间复杂度不同。<br>双链表效率更高，思想 ：用空间换时间。<br><br>使用数组还是链表 要具体情况。<br>数组不支持扩容，ArrayList，扩容是拷贝原数组是耗时操作。<br>链表频繁插入删除 会 造成内存碎片，引发频繁GC<br><br>提示：对于链表的操作一定不能把链表后续内容弄丢，既链表不能丢","like_count":0},{"had_liked":false,"id":99504,"user_name":"散淡","can_delete":false,"product_type":"c1","uid":1461859,"ip_address":"","ucode":"C95D9B2DA4E31B","user_header":"https://static001.geekbang.org/account/avatar/00/16/4e/63/9c969927.jpg","comment_is_top":false,"comment_ctime":1559231214,"is_pvip":false,"replies":[{"id":"36272","content":"你说的没错，是一个变量。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559612689,"ip_address":"","comment_id":99504,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559231214","product_id":100017301,"comment_content":"刚看到这里，要请教老师一个比较小白的问题……<br>文中说“头结点用来记录链表的基地址。”<br>这里的头结点指的并不是内存块的第一个节点，这个头结点反映在代码中是不是就是我们声明的链表的变量名了？平时代码中写的head才是内存块中的第一个节点而不是这个头结点？程序员并不需要关心这个存储基地址的头结点，只处理内存块的部分就可以了？<br>不知道我说明白了没有，想请问我理解的对不对？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452141,"discussion_content":"你说的没错，是一个变量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559612689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99021,"user_name":"冬瓜蔡","can_delete":false,"product_type":"c1","uid":1117673,"ip_address":"","ucode":"2F04A446D28201","user_header":"https://static001.geekbang.org/account/avatar/00/11/0d/e9/2f02a383.jpg","comment_is_top":false,"comment_ctime":1559131408,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559131408","product_id":100017301,"comment_content":"循环链表如果只有一个节点的时候，是不是这个唯一节点既是头结点，也是尾节点，并且这个节点的next指针指向自己","like_count":0},{"had_liked":false,"id":97854,"user_name":"88591","can_delete":false,"product_type":"c1","uid":1254656,"ip_address":"","ucode":"04CE3E46455185","user_header":"https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg","comment_is_top":false,"comment_ctime":1558795616,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558795616","product_id":100017301,"comment_content":"1-链表，主要解决的是存储空间不连续的问题。数组是，连续的存储空间。由于数组等我空间连续，所以更容易cpu缓存命中，因为CPU每次读数据是以一个缓存行为单位 。<br><br>2-链表还是一种用空间换时间的数据结构。双向链表的设计，提升了链表删除，插入的效率。<br><br>3-LRU算法，数组版本实现，hash版本实现。","like_count":0},{"had_liked":false,"id":96935,"user_name":"卢仲云","can_delete":false,"product_type":"c1","uid":1524873,"ip_address":"","ucode":"3609543FBB1B8F","user_header":"https://static001.geekbang.org/account/avatar/00/17/44/89/59f0e60c.jpg","comment_is_top":false,"comment_ctime":1558538844,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1558538844","product_id":100017301,"comment_content":"使用双向链表，首先找到中间结点，然后向两边展开，依次比较。<br>（第一感想到这个，不知道可不可行。）","like_count":0},{"had_liked":false,"id":96818,"user_name":"赫小僧","can_delete":false,"product_type":"c1","uid":1454471,"ip_address":"","ucode":"58A77BF59616F5","user_header":"https://static001.geekbang.org/account/avatar/00/16/31/87/1a0377fa.jpg","comment_is_top":false,"comment_ctime":1558515049,"is_pvip":false,"replies":[{"id":"34668","content":"这个问题你可以看下留言区，我对其他同学的回复。或者看下这篇文章：<br>https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;Md8tprLiESR6oQKXs_Aihw","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1558568406,"ip_address":"","comment_id":96818,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558515049","product_id":100017301,"comment_content":"数组和链表的插入和删除操作. 如果算上数组和链表查找过程, 是不是数组和链表的插入和删除都是O(n)呀?(根据index去插入或删除)","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451026,"discussion_content":"这个问题你可以看下留言区，我对其他同学的回复。或者看下这篇文章：\nhttps://mp.weixin.qq.com/s/Md8tprLiESR6oQKXs_Aihw","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558568406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96736,"user_name":"糖","can_delete":false,"product_type":"c1","uid":1542834,"ip_address":"","ucode":"784DDA19104392","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJzP9yB6eIRRyVNe3iab0gXB6yOeaNRHGx6raTQz2grfE5N2LWl6uIj1mrSU7nxiaEzeSLp6xAkE3iaQ/132","comment_is_top":false,"comment_ctime":1558494817,"is_pvip":true,"replies":[{"id":"34672","content":"1. 第一个问题，你理解的是对的，具体的解释，可以看下这篇文章：<br>https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;PdvdZoa-SGk_Ojkv2pC2tQ<br><br>2. 我的意思的是：当对有序链表进行两次不同的查询的时候，第一次查询完成后，我们可以用一个指针记录查询到的结点p。当第二次查询不同数据的时候，我们可以先拿p跟要查询的数据对比，如果p小于要查询的数据，就直接从p位置开始遍历查询就可以了，不用从链表头开始了。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1558569011,"ip_address":"","comment_id":96736,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558494817","product_id":100017301,"comment_content":"老师我有几点疑问想请教<br>1. 双向链表，单向链表相对于数组来讲其多存储的空间仅仅是两个或一个指针，而指针所占用的空间很多情况下是小于所存储数据本身的，所以链表相对于数组来讲空间占用没有多出很多？<br>2. 老师上面讲到的双向有序链表相对于单向有序链表其按值查找时间平均减小一半没太理解，在有序链表中不都得从头指针向后遍历，一直找到所查询的位置为止吗？无论单链表还是双向链表<br>希望老师和各位大佬帮忙解答一下疑问，谢谢！","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450995,"discussion_content":"1. 第一个问题，你理解的是对的，具体的解释，可以看下这篇文章：\nhttps://mp.weixin.qq.com/s/PdvdZoa-SGk_Ojkv2pC2tQ\n\n2. 我的意思的是：当对有序链表进行两次不同的查询的时候，第一次查询完成后，我们可以用一个指针记录查询到的结点p。当第二次查询不同数据的时候，我们可以先拿p跟要查询的数据对比，如果p小于要查询的数据，就直接从p位置开始遍历查询就可以了，不用从链表头开始了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558569011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96649,"user_name":"小予","can_delete":false,"product_type":"c1","uid":1442580,"ip_address":"","ucode":"3F5EAEE1746074","user_header":"https://static001.geekbang.org/account/avatar/00/16/03/14/e9ca2d09.jpg","comment_is_top":false,"comment_ctime":1558484163,"is_pvip":false,"replies":[{"id":"34669","content":"反序之后存在哪里呢？空间复杂度就不是O（1）了吧","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1558568591,"ip_address":"","comment_id":96649,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558484163","product_id":100017301,"comment_content":"将链表反序后和原来的链表比较，相等则为回文字符串。时间复杂度O（n），空间复杂度O（1）。  感觉这样实现比较简单，不知道对不对，是不是没有快慢遍历找中间节点的效率高。希望老师回答下。。。 我是最近刚开始这个课程的，不知道老师还有没有在关注这个专栏","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450954,"discussion_content":"反序之后存在哪里呢？空间复杂度就不是O（1）了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558568591,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95663,"user_name":"Mr.Ren","can_delete":false,"product_type":"c1","uid":1392846,"ip_address":"","ucode":"5FDD50CFB1CBBF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLCQX614vYChuhGrYJSichTb5gpEPnb5YdSpeBicFician56GRDaQT6Jfg4cax8MR8gvtw0E9fHwrGXjA/132","comment_is_top":false,"comment_ctime":1558136759,"is_pvip":false,"replies":[{"id":"34385","content":"你可以看下这篇文章：<br>https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;Md8tprLiESR6oQKXs_Aihw","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1558338897,"ip_address":"","comment_id":95663,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558136759","product_id":100017301,"comment_content":"文中说的单列表删除时间复杂度为o(n),我认为可以优化到o(1)的。链表删除或者查找等操作都会先遍历链表，此时我们保存两个指针。一个指向当前数据项位置另一个指向当前项的前一个数据项位置。就避免了找到目标项时还要去寻找其前驱操作了。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450548,"discussion_content":"你可以看下这篇文章：\nhttps://mp.weixin.qq.com/s/Md8tprLiESR6oQKXs_Aihw","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558338897,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95222,"user_name":"dombro🍃","can_delete":false,"product_type":"c1","uid":1535680,"ip_address":"","ucode":"4C328C30A250C3","user_header":"https://static001.geekbang.org/account/avatar/00/17/6e/c0/06d4046b.jpg","comment_is_top":false,"comment_ctime":1557991347,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557991347","product_id":100017301,"comment_content":"package list<br><br>import &quot;unsafe&quot;<br>const (<br>\tCACHE_NODE_SIZE = int(unsafe.Sizeof(CacheLinkedNode{}))\t&#47;&#47; 缓存节点大小<br>\tMAX_CACHE_SIZE = 1024*CACHE_NODE_SIZE\t&#47;&#47; 默认的缓存大小<br>)<br><br>type(<br>\tCache struct {<br>\t\thead *CacheLinkedNode\t&#47;&#47; 首节点<br>\t\tsize int\t\t\t\t&#47;&#47; 缓存大小<br>\t}<br><br>\tCacheLinkedNode struct {<br>\t\tcacheVal int\t\t\t&#47;&#47; 缓存数据<br>\t\tnext *CacheLinkedNode\t&#47;&#47; next 指针<br>\t}<br>)<br>&#47;&#47; 初始化缓存, 给首节点一个默认值<br>func OpenCache() *Cache {<br>\tcache := Cache{<br>\t\thead: nil,<br>\t\tsize: 0,<br>\t}<br>\treturn &amp;cache<br>}<br><br>&#47;&#47; 向缓存中链表插入数据<br>func (cache *Cache) InsertCacheNode(val int) {<br>\tnewNode := &amp;CacheLinkedNode{<br>\t\tcacheVal: val,<br>\t\tnext: nil,<br>\t}<br>    node := cache.SearchCacheNode(val)<br>    &#47;&#47; 若该数据节点存在<br>    if node != nil {<br>    \t&#47;&#47; 删除该节点，将该节点插入链表头部<br>\t\tcache.DelCacheNode(node)<br>  \t}else if cache.size &gt;= MAX_CACHE_SIZE{<br>  \t\t&#47;&#47; 若该数据节点不存在，查看缓存大小，超过缓存删除链表尾部节点，将新节点插入链表头部<br>\t\tcache.DelCacheTail()<br>\t}<br>\tnewNode.next = cache.head<br>\tcache.head = newNode<br>\tcache.size = cache.size+CACHE_NODE_SIZE<br>}<br><br>&#47;&#47; 在缓存队列中查找数据节点是否存在<br>func (cache *Cache) SearchCacheNode(val int) *CacheLinkedNode {<br>\tpNode := cache.head<br>\tfor pNode != nil &amp;&amp; pNode.cacheVal != val {<br>\t\tpNode = pNode.next<br>\t}<br>\treturn pNode<br>}<br><br>func (cache *Cache) DelCacheNode(delNode *CacheLinkedNode)   {<br>\tpNode := cache.head<br>\tfor pNode.next != delNode {<br>\t\tpNode = pNode.next<br>\t}<br>\tnextNode := delNode.next<br>\tpNode.next = nextNode<br>}<br><br>&#47;&#47; 删除链表尾部数据节点<br>func (cache *Cache) DelCacheTail()  {<br>\tpNode := cache.head<br>\tnextNode := pNode.next<br>\tfor nextNode.next != nil {<br>\t\tpNode = nextNode<br>\t\tnextNode = nextNode.next<br>\t}<br>\tpNode.next = nextNode.next<br>}<br>测试结果：<br>func TestCache_InsertCacheNode(t *testing.T) {<br>\tcache := OpenCache()<br>\tcache.InsertCacheNode(1)<br>\tcache.InsertCacheNode(2)<br>\tcache.InsertCacheNode(3)<br>\tcache.InsertCacheNode(4)<br>\tcache.InsertCacheNode(5)<br>\tpNode := cache.head<br>\tfor pNode != nil {<br>\t\tfmt.Println(pNode.cacheVal)<br>\t\tpNode = pNode.next<br>\t}<br>\tcache.InsertCacheNode(1)<br>\tfmt.Println()<br>\tpNode = cache.head<br>\tfor pNode != nil {<br>\t\tfmt.Println(pNode.cacheVal)<br>\t\tpNode = pNode.next<br>\t}<br>}<br>=== RUN   TestCache_InsertCacheNode<br>5<br>4<br>3<br>2<br>1<br><br>1<br>5<br>4<br>3<br>2","like_count":0},{"had_liked":false,"id":94784,"user_name":"矢函","can_delete":false,"product_type":"c1","uid":1486994,"ip_address":"","ucode":"839F1051B229B3","user_header":"https://static001.geekbang.org/account/avatar/00/16/b0/92/bb200b22.jpg","comment_is_top":false,"comment_ctime":1557897103,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557897103","product_id":100017301,"comment_content":"判断回文字符串，模仿学习，可以一口气敲下来。 继续努力","like_count":0},{"had_liked":false,"id":94744,"user_name":",","can_delete":false,"product_type":"c1","uid":1439568,"ip_address":"","ucode":"191431A878D7B6","user_header":"https://static001.geekbang.org/account/avatar/00/15/f7/50/cbfe1bc0.jpg","comment_is_top":false,"comment_ctime":1557888421,"is_pvip":false,"replies":[{"id":"34389","content":"很tricky的做法，如果忽略copy操作的耗时的话，没问题","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1558339113,"ip_address":"","comment_id":94744,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557888421","product_id":100017301,"comment_content":"在单链表中指定节点前进行插入新节点时，可以在当前节点后新增一个节点，把当前节点的内容复制到新增节点，插入的内容幅值到当前节点，这样就可以做到和双链表的一样的效率。这样实现的话有没有什么问题？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450191,"discussion_content":"很tricky的做法，如果忽略copy操作的耗时的话，没问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558339113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94471,"user_name":"wuxbeyond","can_delete":false,"product_type":"c1","uid":1318668,"ip_address":"","ucode":"F665896CF1DC3D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/fC4DvPtDPjJjWsMkrRTk4oC9aXnmH7PfBpL3YXichibuib7BXmqteiaQ09jWb7jOFPI5omZCXSmicnmoKXiacYZhqibxg/132","comment_is_top":false,"comment_ctime":1557818901,"is_pvip":false,"replies":[{"id":"33861","content":"啥问题呢？","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1557881596,"ip_address":"","comment_id":94471,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557818901","product_id":100017301,"comment_content":"def delete_last_N_node(self, n):<br>        &#39;&#39;&#39;删除链表中倒数第N个节点.<br>        主体思路：<br>            设置快、慢两个指针，快指针先行，慢指针不动；当快指针跨了N步以后，快、慢指针同时往链表尾部移动，<br>            当快指针到达链表尾部的时候，慢指针所指向的就是链表的倒数第N个节点<br>        参数:<br>            n:需要删除的倒数第N个序数<br>        &#39;&#39;&#39;<br>        fast = self.__head<br>        slow = self.__head<br>        step = 0<br><br>        while step &lt;= n:<br>            fast = fast.next<br>            step += 1<br><br>        while fast.next != None:<br>            tmp = slow<br>            fast = fast.next<br>            slow = slow.next<br><br>        tmp.next = slow.next <br><br>这里的代码是不是有有点问题？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450074,"discussion_content":"啥问题呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557881596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94098,"user_name":"httvc","can_delete":false,"product_type":"c1","uid":1328883,"ip_address":"","ucode":"3E21CC740976B0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLeocOtQchqJhmQjrSLVvkIfGmhK1STust04THMVxWB0ibGMWOaKWJKnSgb6PbEHELXknGdEbHSkjQ/132","comment_is_top":false,"comment_ctime":1557718534,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557718534","product_id":100017301,"comment_content":"您好，您github上的LRU java代码，我觉得如果查询取第一个数，就是头结点的数，是查寻不到的。","like_count":0},{"had_liked":false,"id":93465,"user_name":"Poppy","can_delete":false,"product_type":"c1","uid":1501505,"ip_address":"","ucode":"AF656A00521037","user_header":"https://static001.geekbang.org/account/avatar/00/16/e9/41/7cb2cf64.jpg","comment_is_top":false,"comment_ctime":1557475580,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557475580","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":93419,"user_name":"Edwin","can_delete":false,"product_type":"c1","uid":1105199,"ip_address":"","ucode":"04DC152E82B835","user_header":"https://static001.geekbang.org/account/avatar/00/10/dd/2f/7f0d19a8.jpg","comment_is_top":false,"comment_ctime":1557467264,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557467264","product_id":100017301,"comment_content":"问题分析:<br>1)回文，顾名思义即若一个字符串的正序与倒序相同，如LeveL、repaper，回文必须是对称的.<br>2)数据结构为单链表，即我们需要将数据按照中位数拆分，然后循环比较每个节点，如果首尾不一致说明无法非回文，<br>3)根据栈的特性(先进后出) 这里我们可以将节点全部压入栈，然后在循环取出栈的每个元素与节点做比较<br>具体实现:<br><br>public static boolean isPalindromeStack(Node node){<br>        if (node == null || node.getNext() == null) {<br>            return true;<br>        }<br>        Stack&lt;Node&gt;  stackNode = new Stack&lt;&gt;();<br>        Node curNode = node;<br>        &#47;&#47;将节点压入栈<br>        while (curNode != null){<br>            stackNode.push(curNode);<br>            curNode = curNode.getNext();<br>        }<br><br>        &#47;&#47; 弹出栈进行比较<br>        while (node != null) {<br>            &#47;&#47;如果当前节点的值不等于出栈元素值，则说明非对称不是回文<br>            if(!node.getValue().equals(stackNode.pop().getValue())){<br>                return false;<br>            }<br>            node = node.getNext();<br>        }<br>        return true;<br>    }<br><br><br><br><br><br><br><br><br><br>","like_count":0},{"had_liked":false,"id":93389,"user_name":"httvc","can_delete":false,"product_type":"c1","uid":1328883,"ip_address":"","ucode":"3E21CC740976B0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLeocOtQchqJhmQjrSLVvkIfGmhK1STust04THMVxWB0ibGMWOaKWJKnSgb6PbEHELXknGdEbHSkjQ/132","comment_is_top":false,"comment_ctime":1557462333,"is_pvip":false,"replies":[{"id":"33707","content":"不一定要非得从头查啊。我这里说的是有序的链表，也就是说链表中的数据从小到大排好序了的。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1557792257,"ip_address":"","comment_id":93389,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557462333","product_id":100017301,"comment_content":"“对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需查找一半的数据” 。要查找一个值，对于有序的双向还是单链表都是从头开始查找的，感觉不到查找会减少一半。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449609,"discussion_content":"不一定要非得从头查啊。我这里说的是有序的链表，也就是说链表中的数据从小到大排好序了的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557792257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93042,"user_name":"蔡大少","can_delete":false,"product_type":"c1","uid":1014103,"ip_address":"","ucode":"46FB0BF4BFB75F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/79/57/59e6747a.jpg","comment_is_top":false,"comment_ctime":1557382892,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557382892","product_id":100017301,"comment_content":"如果用数组，这个实现更简单","like_count":0},{"had_liked":false,"id":92815,"user_name":"某小浩","can_delete":false,"product_type":"c1","uid":1511556,"ip_address":"","ucode":"F0A65F516B17BB","user_header":"","comment_is_top":false,"comment_ctime":1557330008,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557330008","product_id":100017301,"comment_content":"依赖评论区的提示，大概写了一些Javascript的链表判断回文写法不知道对不对：<br>链表分别步进1和步进2，当步进2到达链表结尾当时候，步进1刚好到达链表中间（回文一定是偶数字符），对于链表的时间复杂度是O(n)，因为要遍历玩整个链表，空间复杂度是O(n)，因为有一个链表长度n，同时一个存放一半链表的n&#47;2<br><br>&#47;&#47; 判断是否回文<br>function fn(str) {<br>    &#47;&#47; 讲字符串转换为单链表<br>    let dn = cur = linkData = Link(str.split(&#39;&#39;), 0);<br>    let half = null<br>    &#47;&#47; 判断是否执行到链表最后<br>    while(cur.next !== null) {<br>        &#47;&#47; 判断步进2的对象是否执行到最后，步进2到达最后，此时步进1到达一半处，开始判断链表是否回文<br>        if (dn === null) {<br>            &#47;&#47; 判断data是否一致，如果一致继续执行，否则不是回文<br>            if (cur.data !== half.data) {<br>                return false<br>            } else {<br>                cur = cur.next<br>                half = half.next<br>            }<br>        } else {<br>            &#47;&#47; 存放交换顺序的步进1的数据<br>            half = {data: cur.data, next: half}<br>            &#47;&#47; 步进1对象进1<br>            cur = cur.next<br>            &#47;&#47; 步进2对象进2<br>            dn = dn.next ? dn.next.next: null;<br>        }<br>    }<br>    return true<br>}<br>&#47;&#47; 用于构建单链表结构<br>function Link(arr, i) {<br>    return {data: arr[i], next: arr[i+1] ? Link(arr, i+1) : null}<br>}<br>","like_count":0},{"had_liked":false,"id":92299,"user_name":"xk_","can_delete":false,"product_type":"c1","uid":1514305,"ip_address":"","ucode":"DFE1AC38EA78A7","user_header":"https://static001.geekbang.org/account/avatar/00/17/1b/41/dbb7d785.jpg","comment_is_top":false,"comment_ctime":1557225030,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557225030","product_id":100017301,"comment_content":"什么是缓存淘汰策略？<br>指的是当缓存被用满时清理数据的优先顺序。<br><br>有哪些缓存淘汰策略？<br>常见的3种包括先进先出策略FIFO（First In，First Out）、最少使用策略LFU（Least Frenquently Used）、最近最少使用策略LRU（Least Recently Used）。<br><br>LRU算法，链表的实现：<br>访问数据，从头开始遍历数据。<br> <br>a.存在数据，删除该节点，添加到头部。<br>b.不存在:<br><br>缓存满了，删除末尾节点，新增头部节点将新数据添加到头部。<br>缓存没满，直接添加到新增的头部节点。","like_count":0},{"had_liked":false,"id":91498,"user_name":"郑佳宇","can_delete":false,"product_type":"c1","uid":1239639,"ip_address":"","ucode":"538EE8AA8EA375","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/57/5d4bc563.jpg","comment_is_top":false,"comment_ctime":1557043826,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557043826","product_id":100017301,"comment_content":"数组与链表的区别之一：数组申请空间的时候一定要是连续的，链表可不用。单链表存储数据和next，尾结点指向null。循环链表是在单链表的基础上，就尾结点指向头结点。双向链表存储pre 数据 next，查找数据时的效率高于单链表。链表插入数据效率高于数组。利用链表实现lru缓存原理。","like_count":0},{"had_liked":false,"id":91438,"user_name":"你在不远的未来","can_delete":false,"product_type":"c1","uid":1318404,"ip_address":"","ucode":"5B34C8BD03B71A","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/04/f902047e.jpg","comment_is_top":false,"comment_ctime":1557038904,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557038904","product_id":100017301,"comment_content":"思考题我想了两种思路：<br>想到的最优时间：设置一个长度n&#47;2的数组，开始遍历单链表，从头节点依次填入值，直至填充到中间节点（中间节点不填）。继续遍历下半部分数据，并判断是否和前面数组中的 l - i 等值，其实就是高斯问题解法。 时间O（n），空间O（n）<br>想到的最优空间：每次while（剩余节点数&gt;1）遍历单链表并获取中间节点，假设中间左节点和中间右节点相等则删除中间左右节点，否则直接跳出遍历。当剩余节点数&gt; 1（奇个数会剩余中间节点）就说明不是回文。 时间O（n^2），空间O（1）<br><br>额，判断回文数组或者双向链表可能更适合一点，考虑到空间复杂度，推荐数组。","like_count":0},{"had_liked":false,"id":91277,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1194572,"ip_address":"","ucode":"FBFAE23E8E48B7","user_header":"https://static001.geekbang.org/account/avatar/00/12/3a/4c/b6200773.jpg","comment_is_top":false,"comment_ctime":1556961475,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556961475","product_id":100017301,"comment_content":"原链表复制一份；<br>保存头的值并删除头结点；<br>遍历到尾结点，用保存的值与尾结点的值比较，相等时删除尾结点；<br>重复上述2，3步；<br>最后只剩一个结点。<br><br>时间复杂度O(n)？<br>空间复杂度O(n)？<br><br>","like_count":0},{"had_liked":false,"id":91248,"user_name":"徐帅","can_delete":false,"product_type":"c1","uid":1448864,"ip_address":"","ucode":"BDF904280E2330","user_header":"https://static001.geekbang.org/account/avatar/00/16/1b/a0/7c7d1b4a.jpg","comment_is_top":false,"comment_ctime":1556951581,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556951581","product_id":100017301,"comment_content":"关于留言区第二位大神JK David 的解答，不敢苟同，以下是他的解答。<br><br>使用快慢两个指针找到链表中点，慢指针每次前进一步，快指针每次前进两步。在慢指针前进的过程中，同时修改其 next 指针，使得链表前半部分反序。最后比较中点两侧的链表是否相等。<br>时间复杂度：O(n)<br>空间复杂度：O(1)<br>https:&#47;&#47;github.com&#47;andavid&#47;leetcode-java&#47;blob&#47;master&#47;note&#47;234&#47;README.md<br><br>以下个人观点：<br>他发的链接有2个问题：<br>1.当判断是回文串时，并不能还原原串。（逻辑问题）<br>2.当判断不是时，中途return了，不能还原原串。（思路问题）<br>不一定对哈，请老师指导。","like_count":0},{"had_liked":false,"id":91096,"user_name":"Allan","can_delete":false,"product_type":"c1","uid":1310388,"ip_address":"","ucode":"8DA4DBECC2C45C","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","comment_is_top":false,"comment_ctime":1556854705,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556854705","product_id":100017301,"comment_content":"用链表存放字符串求回文，找到中间位置，后半部分从后往前走，前半部分顺序走，前后对比。时间复杂度O（n ），空间复杂度O（1）。","like_count":0},{"had_liked":false,"id":90696,"user_name":"cyh","can_delete":false,"product_type":"c1","uid":1517646,"ip_address":"","ucode":"08CD3C92B53EB9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTITNE98cfqaFcnXQIqKibqM9EsFPIJ9Frcz8ibHzLlzqQxRtSCT2PyMta8fSCsSib6IoCIgiby37tmUvA/132","comment_is_top":false,"comment_ctime":1556611482,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556611482","product_id":100017301,"comment_content":"github上的实现感觉有点问题，假设回文为abccba,单链表插入第二个c之后再插后面的b时:<br>list.insert(&quot;b&quot;,&quot;c&quot;)会找到第一个c然后链表就变成了abcbc了。","like_count":0},{"had_liked":false,"id":90250,"user_name":"Zyt","can_delete":false,"product_type":"c1","uid":1476013,"ip_address":"","ucode":"17EE44017A4CFB","user_header":"https://static001.geekbang.org/account/avatar/00/16/85/ad/800f6b67.jpg","comment_is_top":false,"comment_ctime":1556459294,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556459294","product_id":100017301,"comment_content":"我在百度上看了好多解决回文的，为啥有些是从中间往两头扫，或者两头往中间扫， 和评论区好多人的快慢指针有什么区别呢，哪个是最优的","like_count":0},{"had_liked":false,"id":90195,"user_name":"菜头","can_delete":false,"product_type":"c1","uid":1456964,"ip_address":"","ucode":"C5E95519F9EA21","user_header":"https://static001.geekbang.org/account/avatar/00/16/3b/44/dd534c9b.jpg","comment_is_top":false,"comment_ctime":1556445170,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556445170","product_id":100017301,"comment_content":"&#47;&#47; 使用单向链表实现 LRU<br>class Node {<br>\tlet value: String<br>\tvar next: Node?<br><br>\tinit(value: String) {<br>\t\tself.value = value<br>\t}<br>}<br><br>class LRUManager {<br>\tvar head: Node<br><br>\topen func add(aNode: Node) {<br>\t\tvar pre = head<br>\t\tvar exist = nil<br>\t\twhile(head != nil) {<br>\t\t\tif aNode.value == head.value {<br>\t\t\t\texistValue = head<br>\t\t\t\tbreak<br>\t\t\t}<br>\t\t\tpre = head<br>\t\t\thead = head.next<br>\t\t}<br><br>\t\tif exist != nil {<br>\t\t\tlet next = exist.next<br>\t\t\taNode.next = next<br>\t\t\tpre.next = aNode<br>\t\t\texist == nil<br>\t\t} else {<br>\t\t\tif head == nil {<br>\t\t\t\thead = aNode<br>\t\t\t} else {<br>\t\t\t\taNode.next = head<br>\t\t\t}<br>\t\t}<br>\t}<br>}","like_count":0},{"had_liked":false,"id":87055,"user_name":"SherlockBlaze","can_delete":false,"product_type":"c1","uid":1003510,"ip_address":"","ucode":"71440BB4E40F03","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4f/f6/788f3556.jpg","comment_is_top":false,"comment_ctime":1555504227,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555504227","product_id":100017301,"comment_content":"关于姜威老哥的数组LRU、其实不一定要清理数组、毕竟数组的值是可以覆盖的、","like_count":0},{"had_liked":false,"id":85012,"user_name":"小邓","can_delete":false,"product_type":"c1","uid":1474505,"ip_address":"","ucode":"1E903D5622D39F","user_header":"https://static001.geekbang.org/account/avatar/00/16/7f/c9/40c609ee.jpg","comment_is_top":false,"comment_ctime":1554955425,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554955425","product_id":100017301,"comment_content":"我的回文检测代码：https:&#47;&#47;github.com&#47;CaigerDeng&#47;-DataStructure-BeautyOfAlgorithm-Homework&#47;blob&#47;master&#47;Main&#47;Main&#47;Chapter06.cs<br>搜索IsHuiwen即可","like_count":0},{"had_liked":false,"id":84745,"user_name":"Geek_c33c8e","can_delete":false,"product_type":"c1","uid":1467234,"ip_address":"","ucode":"A5B70E0A346BDC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BpprxVMjsB0Ok4wGunDLHOLEI9wJX5HIEVsqs2EaXpuODfM7tuiaNfjPcxKWc60TwTaJnTuSicGMicib4r4um02qicQ/132","comment_is_top":false,"comment_ctime":1554901514,"is_pvip":false,"replies":[{"id":"30468","content":"不是的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1554938974,"ip_address":"","comment_id":84745,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554901514","product_id":100017301,"comment_content":"老师，数组的内存空间是连续的，list集合申请的内存空间是不是也是连续？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446435,"discussion_content":"不是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554938974,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83641,"user_name":"Tree","can_delete":false,"product_type":"c1","uid":1064664,"ip_address":"","ucode":"F53C863FF9159C","user_header":"https://static001.geekbang.org/account/avatar/00/10/3e/d8/8608ec03.jpg","comment_is_top":false,"comment_ctime":1554688990,"is_pvip":false,"replies":[{"id":"31024","content":"是的。这个要看具体情况。不过，链表频繁的更新的话，实际上会导致更多的内存碎片，理论上更容易触发gc","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1555381862,"ip_address":"","comment_id":83641,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554688990","product_id":100017301,"comment_content":"老师问个问题。Java环境中数组进行动态扩容的时候如果发现内存不够不也是会触发gc。数组和链表哪一个更容易触发gc这个应该不好确定吧。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446110,"discussion_content":"是的。这个要看具体情况。不过，链表频繁的更新的话，实际上会导致更多的内存碎片，理论上更容易触发gc","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555381862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83438,"user_name":"黄龙","can_delete":false,"product_type":"c1","uid":1460189,"ip_address":"","ucode":"B243B05598A826","user_header":"https://static001.geekbang.org/account/avatar/00/16/47/dd/fd222a91.jpg","comment_is_top":false,"comment_ctime":1554599837,"is_pvip":false,"replies":[{"id":"30231","content":"不用的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1554679830,"ip_address":"","comment_id":83438,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554599837","product_id":100017301,"comment_content":"老师我有个问题，analylist再删除删除数据时，是否需要重新复制数据到新的数组呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446022,"discussion_content":"不用的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554679830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82673,"user_name":"rachelllll","can_delete":false,"product_type":"c1","uid":1446064,"ip_address":"","ucode":"D9DED9696901E4","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLLFZlMALuORFib0yZLK7hnhfKd4fmVNOMib7iazAMibZw9osBNmS5CrMxGwex9HcHxUatDuurpmpOh8g/132","comment_is_top":false,"comment_ctime":1554273836,"is_pvip":false,"replies":[{"id":"30234","content":"不是内存 是cpu缓存","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1554679953,"ip_address":"","comment_id":82673,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554273836","product_id":100017301,"comment_content":"cpu缓存机制是不是指在把程序或者数据调入内存时是基于局部性原理的？局部性原理强调的就是时间和空间的连续性。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445678,"discussion_content":"不是内存 是cpu缓存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554679953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82375,"user_name":"拉环","can_delete":false,"product_type":"c1","uid":1247277,"ip_address":"","ucode":"5F81F2746CEF61","user_header":"https://static001.geekbang.org/account/avatar/00/13/08/2d/fb0831a9.jpg","comment_is_top":false,"comment_ctime":1554195256,"is_pvip":false,"replies":[{"id":"30235","content":"看下我回复其他同学的留言 有解释的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1554679988,"ip_address":"","comment_id":82375,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554195256","product_id":100017301,"comment_content":"为什么说链表的删除时间复杂度是O（1）呢 <br>这一点不理解<br>假设根据坐标删除 在我的理解里 链表的删除 应该是先遍历链表O（n）， 找到了对应的坐标的之后才是做O（1）删除的操作  还是说这里的时间复杂度 是不计算遍历的时间的","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445571,"discussion_content":"看下我回复其他同学的留言 有解释的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554679988,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82290,"user_name":"Kevin_耿","can_delete":false,"product_type":"c1","uid":1459323,"ip_address":"","ucode":"0D273DDBF88566","user_header":"https://static001.geekbang.org/account/avatar/00/16/44/7b/c02d1338.jpg","comment_is_top":false,"comment_ctime":1554177029,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554177029","product_id":100017301,"comment_content":"老师好，看到教材（清华大学殷人昆老师的《数据结构（c++描述）》）上的一个单链表插入算法，第二个参数x为什么要用引用类型呢？想不通，求解答。或者是不使用引用类型也可以？<br>bool palindromeStr::insertData(int i, int&amp; x){<br>    if (first == NULL || i == 0) {&#47;&#47;如果是空表或者非空表的第一个结点之前<br>        linkNode * newNode = new linkNode(x);<br>        if (newNode == NULL) {&#47;&#47;存储分配失败<br>            std::cerr &lt;&lt; &quot;memory allocation failed\\n&quot;;<br>            exit(1);<br>        }<br>        newNode-&gt;next = first;<br>        first = newNode;<br>    }else{<br>        linkNode * current = first;<br>        for (int k = 1; k &lt; i; k++) {&#47;&#47;从第一个结点开始检测，查到第i个结点<br>            if (current == NULL) break;<br>            else current = current -&gt;next;<br>        }<br>        if (current == NULL) {<br>            std::cerr &lt;&lt;&quot;invalid position \\n&quot;;<br>            return false;<br>        }else{&#47;&#47;建立一个新节点，插入<br>            linkNode * newNode = new linkNode(x);<br>            if (newNode == NULL) {<br>                std::cerr &lt;&lt; &quot;memory allocation failed\\n&quot;;<br>                exit(1);<br>            }<br>            newNode-&gt;next = current-&gt;next;<br>            current-&gt;next = newNode;<br>        }<br>    }<br>    return true;<br>}","like_count":0},{"had_liked":false,"id":82135,"user_name":"Lucus","can_delete":false,"product_type":"c1","uid":1198800,"ip_address":"","ucode":"CE8EB70CB9D9F1","user_header":"https://static001.geekbang.org/account/avatar/00/12/4a/d0/d319c44a.jpg","comment_is_top":false,"comment_ctime":1554128727,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554128727","product_id":100017301,"comment_content":"双向链表判断回文字符串","like_count":0},{"had_liked":false,"id":82083,"user_name":"Tree","can_delete":false,"product_type":"c1","uid":1064664,"ip_address":"","ucode":"F53C863FF9159C","user_header":"https://static001.geekbang.org/account/avatar/00/10/3e/d8/8608ec03.jpg","comment_is_top":false,"comment_ctime":1554115763,"is_pvip":false,"replies":[{"id":"29788","content":"你说的没错。不过结合散列表可以快速找到这个结点","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1554162082,"ip_address":"","comment_id":82083,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554115763","product_id":100017301,"comment_content":"链表的删除操作一般是先要找到删除的位置在进行删除操作是不是时间复杂度为o（n）呢<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445460,"discussion_content":"你说的没错。不过结合散列表可以快速找到这个结点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554162082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81826,"user_name":"小k","can_delete":false,"product_type":"c1","uid":1304236,"ip_address":"","ucode":"AE0C5ADEB489F5","user_header":"https://static001.geekbang.org/account/avatar/00/13/e6/ac/5b99aa18.jpg","comment_is_top":false,"comment_ctime":1554044376,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554044376","product_id":100017301,"comment_content":"lru为什么开始时用有序的单链表呢","like_count":0},{"had_liked":false,"id":81693,"user_name":"天王","can_delete":false,"product_type":"c1","uid":1239337,"ip_address":"","ucode":"C074B2F9A5F007","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/29/629d9bb0.jpg","comment_is_top":false,"comment_ctime":1554009113,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554009113","product_id":100017301,"comment_content":"总结：链表和数组相比，是不连续存储的线性结构。<br>链表包括，单向链表，双向链表，循环链表。<br>链表的每一个元素叫节点，有比较特殊的2个节点，<br>一个是头节点，一个是尾节点。<br>头节点记录的是链表的基地址，指向第一个节点，尾节点指向null。<br>单向链表的节点，包括2部分，一个存储数据，一个存储指针。<br>单向链表，通过下标访问链表的时间复杂度是O(n)。<br>如果确定了节点，在这个节点之后增加和删除的时间复杂度是O(1)，<br>增加的话，新建一个节点，把确定节点的指针指向新节点，把新节点的指针，指向确定节点原来的指针。<br>删除的话，也一样。<br>循环链表，尾指针指向第一个节点。<br>双向链表，一个节点存储了一个前驱指针，一个后继指针，一个数据。<br>双向链表相对于单向链表的区别，<br>单向链表删除给定的指针指向的节点，因为要获取前驱指针，需要遍历，实际的时间复杂度是O(n)，不是O(1)。<br>而双向链表是真正的O(1)。","like_count":0},{"had_liked":false,"id":81134,"user_name":"赵加兴","can_delete":false,"product_type":"c1","uid":1117072,"ip_address":"","ucode":"B5730C4175B05D","user_header":"https://static001.geekbang.org/account/avatar/00/11/0b/90/f161b09a.jpg","comment_is_top":false,"comment_ctime":1553821570,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553821570","product_id":100017301,"comment_content":"&lt;?php<br><br>&#47;**<br> * Class Node 链表节点<br> *&#47;<br>class Node<br>{<br>    public $data;<br>    public $next;<br><br><br>    public function __construct($data, $next)<br>    {<br>        $this-&gt;data = $data;<br>        $this-&gt;next = $next;<br>    }<br>}<br><br>&#47;**<br> * 根据字符串获取链表<br> * @param $str<br> * @return Node|null<br> *&#47;<br>function getLinkedList($str)<br>{<br>    $strArr = str_split($str);<br>    $head = null;<br>    foreach ($strArr as $val){<br>        $head = new Node($val, $head);<br>    }<br>    return $head;<br>}<br><br>&#47;**<br> * 判断是否为回文<br> * @param $head<br> * @return bool<br> *&#47;<br>function isPalindrome($head)<br>{<br>    if ($head == null || $head-&gt;next == null) {<br>        return true;<br>    }<br><br>    $prev = null;<br>    $slow = $head;<br>    $fast = $head;<br><br>    while ($fast != null &amp;&amp; $fast-&gt;next != null) {<br>        $fast = $fast-&gt;next-&gt;next;<br>        $next = $slow-&gt;next;<br>        $slow-&gt;next = $prev;<br>        $prev = $slow;<br>        $slow = $next;<br>    }<br><br>    if ($fast != null) {<br>        $slow = $slow-&gt;next;<br>    }<br><br>    while ($slow != null) {<br>        if ($slow-&gt;data != $prev-&gt;data) {<br>            return false;<br>        }<br>        $slow = $slow-&gt;next;<br>        $prev = $prev-&gt;next;<br>    }<br><br>    return true;<br>}<br><br>$str = &quot;qwq&quot;;<br>$linkedList = getLinkedList($str);<br>$res = isPalindrome($linkedList);<br>var_dump($res);","like_count":0},{"had_liked":false,"id":81042,"user_name":"风中追风","can_delete":false,"product_type":"c1","uid":1466547,"ip_address":"","ucode":"D8F2DF81CBFD6E","user_header":"https://static001.geekbang.org/account/avatar/00/16/60/b3/0717471f.jpg","comment_is_top":false,"comment_ctime":1553783742,"is_pvip":false,"replies":[{"id":"29628","content":"是先通过散列表定位到这个数据的。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1554031272,"ip_address":"","comment_id":81042,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553783742","product_id":100017301,"comment_content":"但是对于双向链表来说，这种情况就比较有优势了。因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要在 O(1) 的时间复杂度内就搞定了！<br><br>老师有点不明白，如果双向链表找到这个数不也是o(n)么，因为不知道这个数在哪里，从头开始遍历。怎么能是o(1)呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445057,"discussion_content":"是先通过散列表定位到这个数据的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554031272,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":80745,"user_name":"duang_duang","can_delete":false,"product_type":"c1","uid":1392130,"ip_address":"","ucode":"77AE4ADD4BF3F3","user_header":"https://static001.geekbang.org/account/avatar/00/15/3e/02/45e25bab.jpg","comment_is_top":false,"comment_ctime":1553729549,"is_pvip":false,"replies":[{"id":"29371","content":"要考虑时间 空间复杂度的","user_name":"作者回复","user_name_real":"王争-公众号小争哥","uid":"1190123","ctime":1553736161,"ip_address":"","comment_id":80745,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553729549","product_id":100017301,"comment_content":"关于回文串，为什么要选中间点呢，直接整个链表逆序不就可以了？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444960,"discussion_content":"要考虑时间 空间复杂度的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553736161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":80634,"user_name":"haiker","can_delete":false,"product_type":"c1","uid":1131183,"ip_address":"","ucode":"4C4C799CACCF79","user_header":"https://static001.geekbang.org/account/avatar/00/11/42/af/8c37ca95.jpg","comment_is_top":false,"comment_ctime":1553691609,"is_pvip":false,"replies":[{"id":"29373","content":"不会的，因为我们是按照访问时间排序的，一个节点删除并放到链头，相应的访问时间也更新了","user_name":"作者回复","user_name_real":"王争-公众号小争哥","uid":"1190123","ctime":1553736364,"ip_address":"","comment_id":80634,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1553691609","product_id":100017301,"comment_content":"维护一个有序链表是指里面的值递增或者递减吗？如果一个元素在链表里从原来位置删掉放到链表头部，这个时候有序性不就破坏了吗？这个时候需要重新对链表排序吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444927,"discussion_content":"不会的，因为我们是按照访问时间排序的，一个节点删除并放到链头，相应的访问时间也更新了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553736364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":80397,"user_name":"Geek_Captain","can_delete":false,"product_type":"c1","uid":1235165,"ip_address":"","ucode":"B568129ADC59FF","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/dd/ae43b0fd.jpg","comment_is_top":false,"comment_ctime":1553655295,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553655295","product_id":100017301,"comment_content":"## 双向链表<br>支持两个方向，每个节点不只有后继指针next指向前面的节点，还有一个前驱指针prev指向前面的节点<br><br>### 优点<br>支持双向便利，带来了双向链表操作的灵活性<br><br>### 缺点<br>需要额外的两个空间来存储后继节点和前驱节点的地址，所以比单链表要占用更多的内存空间<br><br>## 缓存淘汰策略<br>- 先进先出策略FIFO<br>- 最少使用策略LFU<br>- 最近最少使用策略LRU<br>  <br>## 链表实现LRU缓存淘汰算法<br>维护一个有序单链表，越靠近链表尾部的节点是越早之前访问的，当有一个新的数据被访问时，我们从链表头开始顺序遍历链表<br>- 如果此数据之前已经被缓存再链表中了，我们遍历得到这个数据对应的节点，并将其从原来的位置删除，然后再插入链表的头部。<br>- 如果此数据没有再缓存链表中，又可以分为两种情况：<br>  - 如果此时缓存未满，则将此节点直接插入到链表的头部<br>  - 如果此时缓存已满，则链表尾节点删除，将新的数据节点插入到链表的头部<br>","like_count":0},{"had_liked":false,"id":80006,"user_name":"ggsk","can_delete":false,"product_type":"c1","uid":1450435,"ip_address":"","ucode":"83D63303FEF7EA","user_header":"https://static001.geekbang.org/account/avatar/00/16/21/c3/98708266.jpg","comment_is_top":false,"comment_ctime":1553591566,"is_pvip":false,"replies":[{"id":"29246","content":"要考虑时间、空间复杂度的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1553648966,"ip_address":"","comment_id":80006,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553591566","product_id":100017301,"comment_content":"弱弱的问一下，为什么一定要用快慢指针呢？这里不是很明白。想着是不是只要将链表反转，再和之前的链表比较是不是相同就可以了呢？具体过程可能需要：反转、克隆、反转、比较...","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444718,"discussion_content":"要考虑时间、空间复杂度的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553648966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79959,"user_name":"笙南","can_delete":false,"product_type":"c1","uid":1218163,"ip_address":"","ucode":"39F2B7F155EAEF","user_header":"https://static001.geekbang.org/account/avatar/00/12/96/73/b5158f6c.jpg","comment_is_top":false,"comment_ctime":1553583510,"is_pvip":false,"replies":[{"id":"29252","content":"你咋知道数据不在缓存里的呢","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1553649336,"ip_address":"","comment_id":79959,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553583510","product_id":100017301,"comment_content":"文中提到不管缓存满不满，都需要遍历一遍链表。想问一下，如果数据不在缓存内，并且缓存未满，直接将数据插入到链表的头结点，时间复杂度是O(1)，这种情况为什么要遍历链表呀？又为什么时间复杂度是O(n)呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444703,"discussion_content":"你咋知道数据不在缓存里的呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553649336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79733,"user_name":"吕显超","can_delete":false,"product_type":"c1","uid":1078559,"ip_address":"","ucode":"C2DB2E1986841E","user_header":"https://static001.geekbang.org/account/avatar/00/10/75/1f/783801f9.jpg","comment_is_top":false,"comment_ctime":1553528119,"is_pvip":false,"replies":[{"id":"29251","content":"不需要的，前驱结点已经知道了的，不需要再遍历去查找了的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1553649291,"ip_address":"","comment_id":79733,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553528119","product_id":100017301,"comment_content":"但是对于双向链表来说，这种情况就比较有优势了。因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要在 O(1) 的时间复杂度内就搞定了！<br><br>这段中的：双向链表已经保存了前驱节点的指针，不需要像单链表那样遍历，为什么双向链表的复杂度就是 O(1) 了呢？<br><br>按照我的理解，双向链表想要删除一个节点，还是需要从头结点向后遍历找到 Q，或者从尾结点向前找到 Q + Prev ，如果是这样的话，那么复杂度还是 O(n) 。<br><br>老师，我该如何理解这个问题呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444600,"discussion_content":"不需要的，前驱结点已经知道了的，不需要再遍历去查找了的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553649291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79713,"user_name":"吕显超","can_delete":false,"product_type":"c1","uid":1078559,"ip_address":"","ucode":"C2DB2E1986841E","user_header":"https://static001.geekbang.org/account/avatar/00/10/75/1f/783801f9.jpg","comment_is_top":false,"comment_ctime":1553524972,"is_pvip":false,"replies":[{"id":"29250","content":"抛异常吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1553649215,"ip_address":"","comment_id":79713,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553524972","product_id":100017301,"comment_content":"请问老师文章中这一段：<br><br>我举一个稍微极端的例子。如果我们用 ArrayList 存储了了 1GB 大小的数据，这个时候已经没有空闲空间了，当我们再插入数据的时候，ArrayList 会申请一个 1.5GB 大小的存储空间，并且把原来那 1GB 的数据拷贝到新申请的空间上。听起来是不是就很耗时？<br><br>如果此时系统的内存容量只有 2G，在原本的 ArrayList 已经占用了 1G 的时候，假设剩下的空间仅有 500M，不足 1.5G ，这种情况程序是如何处理的呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444590,"discussion_content":"抛异常吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553649215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79209,"user_name":"莫问流年","can_delete":false,"product_type":"c1","uid":1249663,"ip_address":"","ucode":"23140E031AED4B","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/7f/80d56c1c.jpg","comment_is_top":false,"comment_ctime":1553402134,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553402134","product_id":100017301,"comment_content":"用数组实现LRU算法和用链表实现思路是一致的，大致过程为：遍历数组，查看元素是否已在数组中。<br>1.如果已经在数组中，则删除该元素，并将数组中该位置以前的元素依次后移一个位置，然后将该元素插入到数组的第一个位置。 <br>2.如果未在数组中 ，则又分两种情况：<br>a.数组未满，将数组所有元素后移一个位置，然后将该元素插入到数组的第一个位置；<br>b.数组已满，将数组最后一个元素删除后，将数组剩余元素后移一个位置，然后将该元素插入到数组的第一个位置。","like_count":0},{"had_liked":false,"id":77612,"user_name":"Mirss.zhao","can_delete":false,"product_type":"c1","uid":1330632,"ip_address":"","ucode":"4A8F20B1A9D142","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTItudDLPfbZabQLjk1NE8NSibQocdRy88rerQdxHFKx4KzUyaEnSLPbszcKAaPX8NgG3sHbZXib41aQ/132","comment_is_top":false,"comment_ctime":1552972260,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552972260","product_id":100017301,"comment_content":"又看了一遍，发现双向链表的图，数据与指针的颜色，跟之前的是反着呢","like_count":0},{"had_liked":false,"id":77244,"user_name":"Geek_d2f664","can_delete":false,"product_type":"c1","uid":1462231,"ip_address":"","ucode":"D0B27B24F6F57D","user_header":"https://static001.geekbang.org/account/avatar/00/16/4f/d7/d1bab9be.jpg","comment_is_top":false,"comment_ctime":1552896284,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552896284","product_id":100017301,"comment_content":"最近最少使用策略 LRU，文中的实现我理解是最近使用，没有最少使用这个条件的限制，","like_count":0},{"had_liked":false,"id":76839,"user_name":"Quentiny","can_delete":false,"product_type":"c1","uid":1116887,"ip_address":"","ucode":"556353AE3F0774","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/laPhpJvF09EQqor6icRhGG5SUBiah109uQEQhzCzvibUbXn5hibiaxS1qCCM9H8r1lWTz8DMqnqC5ziaBhndRVd5Bmicg/132","comment_is_top":false,"comment_ctime":1552724782,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552724782","product_id":100017301,"comment_content":"from Prev == null<br>element.next = Prev;<br>Prev = Head;<br>Head = Next;<br>Next = Next.next;<br>to Head == null;","like_count":0},{"had_liked":false,"id":76596,"user_name":"机遇号","can_delete":false,"product_type":"c1","uid":1105053,"ip_address":"","ucode":"A2940DE77BCAEA","user_header":"https://static001.geekbang.org/account/avatar/00/10/dc/9d/e20b37d7.jpg","comment_is_top":false,"comment_ctime":1552637340,"is_pvip":false,"replies":[{"id":"28119","content":"是的，可以去掉。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1552875585,"ip_address":"","comment_id":76596,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552637340","product_id":100017301,"comment_content":"您好，我看了一下源码。关于链表操作的。有点疑问❓<br> public void insertTail(int value){<br><br>        Node newNode = new Node(value, null);<br>        &#47;&#47;空链表，可以插入新节点作为head，也可以不操作<br>        if (head == null){<br>            head = newNode;<br><br>        }else{<br>            Node q = head;<br>            while(q.next != null){<br>                q = q.next;<br>            }<br>            newNode.next = q.next;&#47;&#47;这个是不是可以去掉？<br>            q.next = newNode;<br>        }<br>    }","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443370,"discussion_content":"是的，可以去掉。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552875585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76298,"user_name":"孙清海","can_delete":false,"product_type":"c1","uid":1440043,"ip_address":"","ucode":"959915F8788332","user_header":"https://static001.geekbang.org/account/avatar/00/15/f9/2b/afa78ed8.jpg","comment_is_top":false,"comment_ctime":1552568791,"is_pvip":false,"replies":[{"id":"27862","content":"不用的，用Javascript就可以了。你可以配合我之前推荐的Javascript的书籍来看。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1552615281,"ip_address":"","comment_id":76298,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552568791","product_id":100017301,"comment_content":"老师你好!以前大学的时候学过方面知识，现在初入前端 感觉JavaScript 数组叫做数组，好想又不是数组，今天的链表 指针都没有(还是我不会用) 是不是JavaScript里面数据结构不太齐全!!有点纠结 要不要用其他语言来学习数据结构!","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443246,"discussion_content":"不用的，用Javascript就可以了。你可以配合我之前推荐的Javascript的书籍来看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552615281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76170,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1322811,"ip_address":"","ucode":"02C3847652D3CF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKHfQPjwdyOLYsbF6T2rUSILRc3VsNmMcNJkEEd3TvbfcYProhE8jrKD7EozLTpJ94N7SnbBcTnOA/132","comment_is_top":false,"comment_ctime":1552542822,"is_pvip":true,"replies":[{"id":"27864","content":"”递归那种运算“ 你指的是什么呢？","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1552615374,"ip_address":"","comment_id":76170,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552542822","product_id":100017301,"comment_content":"老师突然想到一个问题，对于递归那种运算，他的时间复杂度应该是多少呢？是O(n)还是应该是O(n^n)呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443205,"discussion_content":"”递归那种运算“ 你指的是什么呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552615374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75515,"user_name":"倚梦流","can_delete":false,"product_type":"c1","uid":1435045,"ip_address":"","ucode":"7CB442D629534B","user_header":"https://static001.geekbang.org/account/avatar/00/15/e5/a5/fae40ac3.jpg","comment_is_top":false,"comment_ctime":1552405962,"is_pvip":false,"replies":[{"id":"27711","content":"是可以用栈实现，但得考虑时间、空间复杂度啊。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1552531825,"ip_address":"","comment_id":75515,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552405962","product_id":100017301,"comment_content":"我之前完全没有接触过回文字符串的检验问题，不过在我看来，用栈的结构也是可以实现的，请问老师，我的想法有道理不？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442923,"discussion_content":"是可以用栈实现，但得考虑时间、空间复杂度啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552531825,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75401,"user_name":"蜗牛","can_delete":false,"product_type":"c1","uid":1086220,"ip_address":"","ucode":"01CC18F12E556D","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/0c/0a6a0d5e.jpg","comment_is_top":false,"comment_ctime":1552391369,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552391369","product_id":100017301,"comment_content":"使用数组实现LRU应该也差不多。如果该数据不存在，就放在数组最后，如果存在就拿出来，放在最后。然后移动节点吧？最后代表最新","like_count":0},{"had_liked":false,"id":75172,"user_name":"Geek_68a3d8","can_delete":false,"product_type":"c1","uid":1244905,"ip_address":"","ucode":"A8D4DF5460F50B","user_header":"https://static001.geekbang.org/account/avatar/00/12/fe/e9/8fc7a875.jpg","comment_is_top":false,"comment_ctime":1552360034,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552360034","product_id":100017301,"comment_content":"public class SinglyLinkedList&lt;T&gt; {<br><br>    private SinglyLinkedNode&lt;T&gt; header;<br><br>    private int size;<br><br>    private static final int MAX = 5;<br><br>    public SinglyLinkedNode&lt;T&gt; getHeader() {<br>        return header;<br>    }<br><br>    public void setHeader(SinglyLinkedNode&lt;T&gt; header) {<br>        this.header = header;<br>    }<br><br>    public int getSize() {<br>        return size;<br>    }<br><br>    public void setSize(int size) {<br>        this.size = size;<br>    }<br><br>    @Override<br>    public String toString() {<br>        if (header == null) {<br>            return &quot;empty list&quot;;<br>        }<br>        StringBuilder sb = new StringBuilder();<br>        SinglyLinkedNode&lt;T&gt; item = header;<br>        for (int i = 0; i &lt; size; i++) {<br>            T data = item.getData();<br>            sb.append(&quot;index[&quot;).append(i).append(&quot;] : &quot;).append(data).append(&quot;\\n&quot;);<br><br>            item = item.getNext();<br>        }<br>        return sb.toString();<br>    }<br><br>    class SinglyLinkedNode&lt;T&gt; {<br><br>        private T data;<br><br>        private SinglyLinkedNode&lt;T&gt; next;<br><br>        public T getData() {<br>            return data;<br>        }<br><br>        public void setData(T data) {<br>            this.data = data;<br>        }<br><br>        public SinglyLinkedNode&lt;T&gt; getNext() {<br>            return next;<br>        }<br><br>        public void setNext(SinglyLinkedNode&lt;T&gt; next) {<br>            this.next = next;<br>        }<br><br>        public SinglyLinkedNode(T data) {<br>            this.data = data;<br>        }<br>    }<br><br>}","like_count":0},{"had_liked":false,"id":74840,"user_name":"子鱼","can_delete":false,"product_type":"c1","uid":1257137,"ip_address":"","ucode":"583A2B2B3D0E97","user_header":"https://static001.geekbang.org/account/avatar/00/13/2e/b1/d920a3de.jpg","comment_is_top":false,"comment_ctime":1552303487,"is_pvip":false,"replies":[{"id":"27715","content":"普通单链表也可以的。顺序不会乱的。因为我们每次都是在链头或者链尾，进行删除或者添加操作。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1552532278,"ip_address":"","comment_id":74840,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552303487","product_id":100017301,"comment_content":"老师，有链表实现一个LRU缓存淘汰算法时，去维护一个有序单链表，这里的“有序”怎么理解？是不是为了初次查找数据快，每次查一半，如果按照这个思路下去，缓存一段时间，顺序应该就乱了。另外，如果是普通单链表也是可以的嘛？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442702,"discussion_content":"普通单链表也可以的。顺序不会乱的。因为我们每次都是在链头或者链尾，进行删除或者添加操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552532278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74425,"user_name":"月小水长","can_delete":false,"product_type":"c1","uid":1220458,"ip_address":"","ucode":"A64AA379980CF7","user_header":"https://static001.geekbang.org/account/avatar/00/12/9f/6a/08d63f4e.jpg","comment_is_top":false,"comment_ctime":1552223336,"is_pvip":false,"replies":[{"id":"27713","content":"你说的没错。但是，如果我定义的函数是这样子的呢？<br>void remove(Node *p); &#47;&#47; 删除p节点","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1552532002,"ip_address":"","comment_id":74425,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552223336","product_id":100017301,"comment_content":"疑问：对于第二种删除的情况，单链表和循环链表的比较时，我觉得在找到目标节点p后，单链表和循环链表，都可以通过保存目标节点的前驱节点q来遍历，比如q = head;while(q-&gt;next !=p){q=q-&gt;next;}这样，完全没必要在找到目标节点后，再遍历找前驱节点啊，而且，循环链表要拆除的指针比但链表多，不是更复杂吗，求老师指导。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442572,"discussion_content":"你说的没错。但是，如果我定义的函数是这样子的呢？\nvoid remove(Node *p); // 删除p节点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552532002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73250,"user_name":"JD_Ahoi","can_delete":false,"product_type":"c1","uid":1445281,"ip_address":"","ucode":"2188A07A5FF7A5","user_header":"https://static001.geekbang.org/account/avatar/00/16/0d/a1/a6e16f9e.jpg","comment_is_top":false,"comment_ctime":1551844472,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551844472","product_id":100017301,"comment_content":"老师，之前理解错了，应该用链表实现，而不是用数组。。","like_count":0},{"had_liked":false,"id":73075,"user_name":"Anthony","can_delete":false,"product_type":"c1","uid":1309908,"ip_address":"","ucode":"9E0C98A9123365","user_header":"https://static001.geekbang.org/account/avatar/00/13/fc/d4/743d3f02.jpg","comment_is_top":false,"comment_ctime":1551792377,"is_pvip":false,"replies":[{"id":"26807","content":"是的，你说的这种场景是没错的。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551926044,"ip_address":"","comment_id":73075,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551792377","product_id":100017301,"comment_content":"老师，我有一个疑问，如果遍历单链表的时候，如果在一次for循环中同时记录prev元素和它本身，是不是这样就和双向链表插入删除同样的时间复杂度呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441898,"discussion_content":"是的，你说的这种场景是没错的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551926044,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73043,"user_name":"JD_Ahoi","can_delete":false,"product_type":"c1","uid":1445281,"ip_address":"","ucode":"2188A07A5FF7A5","user_header":"https://static001.geekbang.org/account/avatar/00/16/0d/a1/a6e16f9e.jpg","comment_is_top":false,"comment_ctime":1551783206,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551783206","product_id":100017301,"comment_content":"老师，有一个问题，我用java实现快慢指针法判断回文，感觉有点吃力呢？我的实现方式是定义一个内部内Node（类似LinkedList的Node），然后给定一个字符串，将之一一拆解为单个字符并放入node，再将这个node放入一个数组；<br>接下来遍历数组，用快慢指针法：<br>当快指针到达终点前，将node的next逆指；<br>当快指针到达终点时，将上一个node的next置空，并生成一个新的数组，用于存放后面的node；<br>遍历结束后，比较两个list内的node拼接后的字符串是否相等。<br>整个过程感觉很变扭。。。请老师给出意见。。","like_count":0},{"had_liked":false,"id":72385,"user_name":"李宁","can_delete":false,"product_type":"c1","uid":1427718,"ip_address":"","ucode":"6F2E7681D2BEBE","user_header":"https://static001.geekbang.org/account/avatar/00/15/c9/06/6cbc7eb6.jpg","comment_is_top":false,"comment_ctime":1551604899,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551604899","product_id":100017301,"comment_content":"看到大家回复，关于回文的判断，大家都用链表实现，我觉得用数组实现比较容易些，当然如果数据量太大的话，估计就不合适了","like_count":0},{"had_liked":false,"id":72367,"user_name":"好雨当春","can_delete":false,"product_type":"c1","uid":1241934,"ip_address":"","ucode":"64B1C92911B898","user_header":"https://static001.geekbang.org/account/avatar/00/12/f3/4e/bcb436aa.jpg","comment_is_top":false,"comment_ctime":1551599084,"is_pvip":false,"replies":[{"id":"26264","content":"看你删除的时候是怎么指定删除目标的。<br><br>void remove(int data);<br>void remove(Node * toBeDeletedNode);<br>void remove(Node *prevNodeOfToBeDeletedNode)","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551665136,"ip_address":"","comment_id":72367,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551599084","product_id":100017301,"comment_content":"链表的插入删除都要先遍历查找出目标index位置吧，那整体的时间复杂度还是1？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441559,"discussion_content":"看你删除的时候是怎么指定删除目标的。\n\nvoid remove(int data);\nvoid remove(Node * toBeDeletedNode);\nvoid remove(Node *prevNodeOfToBeDeletedNode)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551665136,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71167,"user_name":"冷颜〆","can_delete":false,"product_type":"c1","uid":1237101,"ip_address":"","ucode":"8FE0FB27AFA31C","user_header":"https://static001.geekbang.org/account/avatar/00/12/e0/6d/a55c6ec4.jpg","comment_is_top":false,"comment_ctime":1551275870,"is_pvip":false,"replies":[{"id":"25516","content":"m是什么呢？你后面的表述是正确的。是要先找到c。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551318787,"ip_address":"","comment_id":71167,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551275870","product_id":100017301,"comment_content":"链表插入跟删除是不是应该为O（m-n） 因为假设我要将x插入到abcd的c节点 不应该是先找到c节点然后把c节点的next指向x 的next指向d吗 <br>理解可能不透彻 如果理解有误麻烦指明 谢谢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441022,"discussion_content":"m是什么呢？你后面的表述是正确的。是要先找到c。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551318787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71057,"user_name":"cjy","can_delete":false,"product_type":"c1","uid":1422331,"ip_address":"","ucode":"8B4451CAD354D7","user_header":"https://static001.geekbang.org/account/avatar/00/15/b3/fb/de1c1e64.jpg","comment_is_top":false,"comment_ctime":1551255762,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551255762","product_id":100017301,"comment_content":"老师  我说的意思是<br>p-&gt;next-&gt;成员 条件 条件值   这样判断（这是前一个结点判断）<br><br> p-&gt;成员 条件 条件值 （这是当前结点判断）","like_count":0},{"had_liked":false,"id":70723,"user_name":"cjy","can_delete":false,"product_type":"c1","uid":1422331,"ip_address":"","ucode":"8B4451CAD354D7","user_header":"https://static001.geekbang.org/account/avatar/00/15/b3/fb/de1c1e64.jpg","comment_is_top":false,"comment_ctime":1551169758,"is_pvip":false,"replies":[{"id":"25398","content":"没太看懂你说的意思呢，你能再描述一下吗","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551232449,"ip_address":"","comment_id":70723,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551169758","product_id":100017301,"comment_content":"老师问一下下：单链表在查询得时候是以当前结点来查，为什么不用前一个结点指向下一个结点得内容来查，这样就没有必要从头结点再遍历一遍了（是语言的不一样嘛？我只看了c的）。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440796,"discussion_content":"没太看懂你说的意思呢，你能再描述一下吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551232449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":70461,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1551102167,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551102167","product_id":100017301,"comment_content":"记下lru算法的实现方法，方便复习:先维护一串单向链表，每次查找都是从头开始遍历，离尾端最近的数据访问时间肯定是最早的，当要查询一个数据的时候，假如数据本来就在链表中，那么直接把该数据删除并且插入到最顶端，假如要查的数据不在链表中，那么假如链表未满则直接存入到链表头部，满了就把离尾端最近的删除掉，然后再插入到顶端。。。","like_count":0},{"had_liked":false,"id":70039,"user_name":"LEO","can_delete":false,"product_type":"c1","uid":1396809,"ip_address":"","ucode":"4268DB35C3F3E9","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/49/898cb635.jpg","comment_is_top":false,"comment_ctime":1550973097,"is_pvip":false,"replies":[{"id":"25058","content":"1. 从小到大、从大到小都可以，看你怎么淘汰数据<br>2. 链表中的数据是动态变化的，每次插入数据，都找到这个数据应该插入的位置，这样就可以保持它一直有序了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551061359,"ip_address":"","comment_id":70039,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1550973097","product_id":100017301,"comment_content":"老师，您讲的LRU算法那块我不是很理解，根据您在评论里说的“有序链表是根据访问时间进行排序的”这句话，我有两个问题想向您确认一下：<br>1.有序链表是不是默认按访问时间从大到小进行排序的？<br>2.链表都是有序的吗？如果都是，那排序是不是它内部自动执行的？<br>希望老师能帮我解答","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440411,"discussion_content":"1. 从小到大、从大到小都可以，看你怎么淘汰数据\n2. 链表中的数据是动态变化的，每次插入数据，都找到这个数据应该插入的位置，这样就可以保持它一直有序了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551061359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":69862,"user_name":"kbheart","can_delete":false,"product_type":"c1","uid":1131921,"ip_address":"","ucode":"7EF37E172C2615","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/91/15d9de2e.jpg","comment_is_top":false,"comment_ctime":1550891950,"is_pvip":false,"replies":[{"id":"25059","content":"你说的这个过程是O(1)的。但是如果我们是这么删除呢？<br><br>void remove(Node *p); 删除节点p","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551061535,"ip_address":"","comment_id":69862,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1550891950","product_id":100017301,"comment_content":"关于单链表删除指定节点，可以在O(1)实现啊，不用去找前驱节点吧？把要删除的节点的后继节点值赋值给当前节点，然后删除后继节点就好，时间复杂度是O(1)吧！请大牛指教～","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440320,"discussion_content":"你说的这个过程是O(1)的。但是如果我们是这么删除呢？\n\nvoid remove(Node *p); 删除节点p","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551061535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":69592,"user_name":"陈园","can_delete":false,"product_type":"c1","uid":1353753,"ip_address":"","ucode":"21BC5886297707","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJnguccGyM8nvOb0N9B0kCnBV6OwNjvG9trYdiakmgYWVyfJkpD1vJBfnicmaQseupa7A7ic1rian0NlA/132","comment_is_top":false,"comment_ctime":1550795295,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550795295","product_id":100017301,"comment_content":"指针一直是困扰自己的问题，这次通过链表的学习和练习，对指针有更深入的理解","like_count":0},{"had_liked":false,"id":69474,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1550753008,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550753008","product_id":100017301,"comment_content":"一：快慢指针找出中间点<br>二：慢针到中间点前，从左往右拼接字符串<br>三：过中间点（奇数时中间数跳过），从右望左拼接字符串。<br>四：慢针到中间点时比较两个字符串是否相等。<br><br>时间空间复杂度都为O(n)<br><br>备注：如果不拼接字符串比较。将到中间点前的链表逆转，到达中间点时（奇数时中间数还是跳过），双向走对每个元素判等。这样空间复杂度可以降低为O（1）。<br><br>注：个人比较注重时间，毕竟空间可扩，时间难求。所以非空间条件极端苛刻时，我会选择第一种方式，拿空间换时间。","like_count":0},{"had_liked":false,"id":69205,"user_name":"locke.wei","can_delete":false,"product_type":"c1","uid":1351535,"ip_address":"","ucode":"58C70AC52A0C84","user_header":"https://static001.geekbang.org/account/avatar/00/14/9f/6f/aee1732a.jpg","comment_is_top":false,"comment_ctime":1550677073,"is_pvip":false,"replies":[{"id":"24617","content":"貌似也不是时间周期。“LFU（Least Frequently Used）算法根据数据的历史访问频率来淘汰数据，其核心思想是如果数据过去被访问多次，那么将来被访问的频率也更高”","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550718858,"ip_address":"","comment_id":69205,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1550677073","product_id":100017301,"comment_content":"LFU需要一个时间周期，所以实现起来比LRU要复杂，对吗","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439999,"discussion_content":"貌似也不是时间周期。“LFU（Least Frequently Used）算法根据数据的历史访问频率来淘汰数据，其核心思想是如果数据过去被访问多次，那么将来被访问的频率也更高”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550718858,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":68969,"user_name":"任大鹏","can_delete":false,"product_type":"c1","uid":1069049,"ip_address":"","ucode":"75D14B0FC68DA5","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/f9/1f0a9665.jpg","comment_is_top":false,"comment_ctime":1550635486,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550635486","product_id":100017301,"comment_content":"刚买了课程，试着回答一下课后思考题吧。题目没有指明是否可以对原链表进行修改，我暂时想到的算法对原链表有改动，当然还可以还原。时间复杂度O(n)，空间复杂度O(1)。<br>看之前几篇文章，发现评论区大神很多，回答这道题的时候还没来得及拜读评论区的内容（太多了，比原文都多），等拜读后再对算法进行优化。<br>代码如下（顺便吐槽极客时间，评论居然不能加图片）:<br>class Solution {<br>    public boolean isPalindrome(ListNode head) {<br>        if (head == null || head.next == null)<br>            return true;<br>        ListNode quick = head;<br>        ListNode slow = head;<br>        while (quick.next != null &amp;&amp; quick.next.next != null) {<br>            quick = quick.next.next;<br>            slow = slow.next;<br>        }<br>        quick = reverse(slow.next);<br>        slow = head;<br>        while (quick != null) {<br>            if (slow.val != quick.val)<br>                return false;<br>            slow = slow.next;<br>            quick = quick.next;<br>        }<br>        return true;<br>    }<br>    <br>    private ListNode reverse(ListNode head) {<br>        if (head == null)<br>            return head;<br>        ListNode pre = null;<br>        ListNode curr = head;<br>        ListNode next = null;<br>        while (curr != null) {<br>            next = curr.next;<br>            curr.next = pre;<br>            pre = curr;<br>            curr = next;<br>        }<br>        return pre;<br>    }<br>}","like_count":0},{"had_liked":false,"id":68712,"user_name":"阿信","can_delete":false,"product_type":"c1","uid":1389604,"ip_address":"","ucode":"50616ED68A5B40","user_header":"https://static001.geekbang.org/account/avatar/00/15/34/24/34ca1d23.jpg","comment_is_top":false,"comment_ctime":1550582980,"is_pvip":false,"replies":[{"id":"24601","content":"这个问题有点大了。不过套路跟我讲的是差不多的。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550715778,"ip_address":"","comment_id":68712,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1550582980","product_id":100017301,"comment_content":"请问CPU缓存怎么更新呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439809,"discussion_content":"这个问题有点大了。不过套路跟我讲的是差不多的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550715778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":67699,"user_name":"nullz","can_delete":false,"product_type":"c1","uid":1156066,"ip_address":"","ucode":"A9D997C41D6DE3","user_header":"https://static001.geekbang.org/account/avatar/00/11/a3/e2/d2cf7a81.jpg","comment_is_top":false,"comment_ctime":1550224902,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550224902","product_id":100017301,"comment_content":"回文串<br>class Solution {<br>    public boolean isPalindrome(ListNode head) {<br>        if (head == null || head.next == null)return true; <br>        ListNode midNode = getMin(head);<br>        ListNode minNext = reverse(midNode.next); &#47;&#47; 获得后半部分转置后的链表<br>        ListNode p1 = head, p2 = minNext;<br>        while (p2 != null) {<br>            if (p1.val != p2.val)return false; &#47;&#47; 这里注意不应该比较结点，比较值<br>            p1 = p1.next;<br>            p2 = p2.next;<br>        }<br>        midNode.next = reverse(minNext); &#47;&#47; 恢复链表<br>        return true;<br>    }<br>    <br>    private ListNode getMin(ListNode head) {<br>        if (head == null)return null;<br>        ListNode fast = head, slow = head;<br>        while (fast.next != null &amp;&amp; fast.next.next != null) {<br>            fast = fast.next.next;<br>            slow = slow.next;<br>        }<br>        return slow;<br>    }<br>    <br>    private ListNode reverse(ListNode head) {<br>        ListNode cur = head, prev = null;<br>        while (cur != null) {<br>            ListNode temp = cur.next;<br>            cur.next = prev;<br>            prev = cur;<br>            cur = temp;<br>        }<br>        return prev;<br>    }<br>}","like_count":0},{"had_liked":false,"id":67309,"user_name":"hailowell","can_delete":false,"product_type":"c1","uid":1195572,"ip_address":"","ucode":"557DCAB01710AB","user_header":"","comment_is_top":false,"comment_ctime":1550128031,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550128031","product_id":100017301,"comment_content":"思考了下LRU的那个例子，<br>可能是经历的少，感觉单只用链表(例子中的那个)好像也不能用于实际使用？<br>应该还要配合其他存储方式吧，链表中只存一个key,在map中存储key-value。当链表中要删除时 在map中删除相应的数据，相当于用链表做一个过期检测？<br>不知道说的对不对，请老师指正","like_count":0},{"had_liked":false,"id":66680,"user_name":"biepa","can_delete":false,"product_type":"c1","uid":1399708,"ip_address":"","ucode":"12F8B646000A66","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6vz8MgZia6XzLCTJcuTLCgsJJt2OvE90XPibxjojybic081Zhso0mwBohUn8ovnnXarYJq0geWjxH1AfcX5cGib8fQ/132","comment_is_top":false,"comment_ctime":1549979989,"is_pvip":false,"replies":[{"id":"24607","content":"后面散列表那一节还会再讲的，循序渐进哈，别急。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550716773,"ip_address":"","comment_id":66680,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1549979989","product_id":100017301,"comment_content":"关于开篇问题写得有些少吧，而且我觉得用数组实习lru缓存明显比较复杂，是不是讲一下比较好","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438865,"discussion_content":"后面散列表那一节还会再讲的，循序渐进哈，别急。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550716773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65925,"user_name":"解忧杂货店。","can_delete":false,"product_type":"c1","uid":1394815,"ip_address":"","ucode":"BADCAE2C955902","user_header":"https://static001.geekbang.org/account/avatar/00/15/48/7f/0f1f861f.jpg","comment_is_top":false,"comment_ctime":1549778004,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549778004","product_id":100017301,"comment_content":"好尴尬，不懂快慢指针赶紧去百度","like_count":0},{"had_liked":false,"id":65620,"user_name":"daniel","can_delete":false,"product_type":"c1","uid":1370456,"ip_address":"","ucode":"3516AF7F9A4DEA","user_header":"https://static001.geekbang.org/account/avatar/00/14/e9/58/397a4ab2.jpg","comment_is_top":false,"comment_ctime":1549512218,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549512218","product_id":100017301,"comment_content":"LRU也叫页面置换机制，缓存页表中爆满时需要把一个最久未使用的页面调出以从内存加载一个新的页面。<br>显然答案里面的单链表实现LRU是有规定的，他规定头节点插入（因为是单链表，从哪里插入都是随便找一个内存空间给你放的），尾节点是最久未使用的（因为他很久没有被访问，当他被访问时候，他会被删除，然后插入到头节点，相当于移位到头部，访问是指删除和插入，并不是简单的查看）<br>数组的实现的话，制定类似上面的规则就好，如数组一般尾插入，按照顺序。那就变成数组头是最久未访问的，被访问了的元素会被刷新位置放到尾部。<br>回文字符串：上面链表可以实现，很多同学已经回答了， 当然使用数组也可以，直接定位到元素中间，然后两个下标，一前一后i- -和j+ +判断前后元素是否相同。leetcode上面有个判断字符串里面最长的回文字符串，那个就是用数组下标做的，主要是理解回文就是找到中间向两边散开","like_count":0},{"had_liked":false,"id":65330,"user_name":"Pre-Y","can_delete":false,"product_type":"c1","uid":1396900,"ip_address":"","ucode":"A13D13A37F3ABC","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/a4/8d2e454b.jpg","comment_is_top":false,"comment_ctime":1549246928,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549246928","product_id":100017301,"comment_content":"对于思考题看了大佬们的解答涨姿势了。<br><br>个人所学甚少，只能想到这些：<br>一：硬干<br>先记录头结点data，再用另两个指针遍历单链表到最后一个结点，比较两者data值。相同就删除这两端的结点，并重复操作；不同就返回No<br>时间复杂度应该是O（n²）<br>空间复杂度应该是O（1）<br>二：将单链表转存到双链表<br>用两指针记录首尾两结点，比较它们的data值。相同就往中间移动；不同返回No<br>时间复杂度，虽然判断简单，但涉及数据搬家所以应该是O（n）<br>空间复杂度因为额外用了内存，应该也是O（n）<br>","like_count":0},{"had_liked":false,"id":64367,"user_name":"金龟","can_delete":false,"product_type":"c1","uid":1228500,"ip_address":"","ucode":"1C7D35C8AE8D9D","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/d4/ff1c1319.jpg","comment_is_top":false,"comment_ctime":1548755178,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548755178","product_id":100017301,"comment_content":"大概思路：如果允许空间复杂度是O(n)的话，可以另外起一个stack，前半部分都入站，后面部分都出站。只不过要分奇偶数。","like_count":0},{"had_liked":false,"id":63659,"user_name":"极客鱼","can_delete":false,"product_type":"c1","uid":1353133,"ip_address":"","ucode":"554F0DF1749B16","user_header":"","comment_is_top":false,"comment_ctime":1548439953,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548439953","product_id":100017301,"comment_content":"“双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。”老师，这个是不是说错了，双向链表只是需要额外的一个空间来记录前驱结点的，因为本身单向链表也储存后继结点。求指教","like_count":0},{"had_liked":false,"id":63259,"user_name":"lll","can_delete":false,"product_type":"c1","uid":1303582,"ip_address":"","ucode":"8D05C57E4656C3","user_header":"https://static001.geekbang.org/account/avatar/00/13/e4/1e/2d9181bb.jpg","comment_is_top":false,"comment_ctime":1548313573,"is_pvip":false,"replies":[{"id":"22474","content":"都可以啊，看你怎么定义了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1548404622,"ip_address":"","comment_id":63259,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1548313573","product_id":100017301,"comment_content":"“我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的...”<br>为什么越靠近尾部的节点是越早之前访问，正常逻辑，越靠近尾部那就是越靠后遍历，那应该是比较晚访问的？<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437525,"discussion_content":"都可以啊，看你怎么定义了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548404622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":62985,"user_name":"isea_you","can_delete":false,"product_type":"c1","uid":1015440,"ip_address":"","ucode":"8D6CBABACED5FE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/90/21db58fd.jpg","comment_is_top":false,"comment_ctime":1548220667,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548220667","product_id":100017301,"comment_content":"第一次遍历链表，在使用一个栈将数据全部读进来，<br><br>第二次遍历链表，在出栈，对比即可<br><br>都是ON，但是贼简单，适合做对数器","like_count":0},{"had_liked":false,"id":62847,"user_name":"双子座的马克思","can_delete":false,"product_type":"c1","uid":1150663,"ip_address":"","ucode":"4D43FB644E9870","user_header":"https://static001.geekbang.org/account/avatar/00/11/8e/c7/6d08d502.jpg","comment_is_top":false,"comment_ctime":1548172276,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548172276","product_id":100017301,"comment_content":"单链表的特性是遍历方向为从前往后，而不能从后往前，如果要判断一个单链表的字符串是不是一个回文串，就判断第1位和第n位是否相等，第2位和第n-1是否相等...一直到中间位置。时间复杂度是O(n^2)","like_count":0},{"had_liked":false,"id":62843,"user_name":"双子座的马克思","can_delete":false,"product_type":"c1","uid":1150663,"ip_address":"","ucode":"4D43FB644E9870","user_header":"https://static001.geekbang.org/account/avatar/00/11/8e/c7/6d08d502.jpg","comment_is_top":false,"comment_ctime":1548171147,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548171147","product_id":100017301,"comment_content":"通过数组实现LRU缓存：分数据在或不在数组中的两种情况。如果在，则将数组中的数据从原位置上删除，并添加至头部。如果不在，那么直接添加至头部，这里需要注意，如果数组空间满了，那么把最后的数据从数组中移除。","like_count":0},{"had_liked":false,"id":62783,"user_name":"杜鹏","can_delete":false,"product_type":"c1","uid":1197300,"ip_address":"","ucode":"7D43939C1B32DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/44/f4/6b456c12.jpg","comment_is_top":false,"comment_ctime":1548157190,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548157190","product_id":100017301,"comment_content":"JK David的解法虽然是对的，但我不认同的是，它改变了链表原来的内容。<br><br>可以先遍历链表拿到链表的长度n<br>递归的判断长度为n-2的head-&gt;next链表是否回文，并且返回这个长度为n-2的链表的后继节点tail，判断head和tail的内容是否相等。只有两个条件都满足才返回true。","like_count":0},{"had_liked":false,"id":62483,"user_name":"双子座的马克思","can_delete":false,"product_type":"c1","uid":1150663,"ip_address":"","ucode":"4D43FB644E9870","user_header":"https://static001.geekbang.org/account/avatar/00/11/8e/c7/6d08d502.jpg","comment_is_top":false,"comment_ctime":1548068137,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548068137","product_id":100017301,"comment_content":"举一个实际中的例子，增大服务器带宽，就是空间换时间的例子。","like_count":0},{"had_liked":false,"id":62479,"user_name":"双子座的马克思","can_delete":false,"product_type":"c1","uid":1150663,"ip_address":"","ucode":"4D43FB644E9870","user_header":"https://static001.geekbang.org/account/avatar/00/11/8e/c7/6d08d502.jpg","comment_is_top":false,"comment_ctime":1548067170,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548067170","product_id":100017301,"comment_content":"用空间换时间真的很重要，前面讲的很多都有这个的体现，比如数组到链表，牺牲了连续内存增加了指针，虽然增加了空间，但增删查都节约了时间，计算机中，空间可以增加，但时间就这么多，是没办法改变的。不止算法，其实很多事也是这样。","like_count":0},{"had_liked":false,"id":62333,"user_name":"无星","can_delete":false,"product_type":"c1","uid":1248039,"ip_address":"","ucode":"F19F3F6D54EAC4","user_header":"https://static001.geekbang.org/account/avatar/00/13/0b/27/e67b238d.jpg","comment_is_top":false,"comment_ctime":1548034105,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548034105","product_id":100017301,"comment_content":"看完散列表从头看链表，课程真的是连起来的","like_count":0},{"had_liked":false,"id":62332,"user_name":"无星","can_delete":false,"product_type":"c1","uid":1248039,"ip_address":"","ucode":"F19F3F6D54EAC4","user_header":"https://static001.geekbang.org/account/avatar/00/13/0b/27/e67b238d.jpg","comment_is_top":false,"comment_ctime":1548034104,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548034104","product_id":100017301,"comment_content":"看完散列表从头看链表，课程真的是连起来的","like_count":0},{"had_liked":false,"id":62157,"user_name":"双子座的马克思","can_delete":false,"product_type":"c1","uid":1150663,"ip_address":"","ucode":"4D43FB644E9870","user_header":"https://static001.geekbang.org/account/avatar/00/11/8e/c7/6d08d502.jpg","comment_is_top":false,"comment_ctime":1547964185,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547964185","product_id":100017301,"comment_content":"提个小建议，插入x节点的图，最好不要用x，因为x和“叉号”很像……","like_count":0},{"had_liked":false,"id":62153,"user_name":"海军上校","can_delete":false,"product_type":"c1","uid":1104290,"ip_address":"","ucode":"7B0D9EC01A3F36","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/a2/afbc447c.jpg","comment_is_top":false,"comment_ctime":1547959629,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547959629","product_id":100017301,"comment_content":"看评论，学习快慢指针法～","like_count":0},{"had_liked":false,"id":58963,"user_name":"远方","can_delete":false,"product_type":"c1","uid":1233678,"ip_address":"","ucode":"0204484866E43F","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/0e/c057ff45.jpg","comment_is_top":false,"comment_ctime":1547261293,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547261293","product_id":100017301,"comment_content":"对于双向链表，删除的第二种情况，为什么知道了指针位置，时间复杂度为1了，为什么不需要遍历查找了，前驱节点不也是只知道一个节点的前面一个人是谁吗。求教","like_count":0},{"had_liked":false,"id":58555,"user_name":"randomx","can_delete":false,"product_type":"c1","uid":1238993,"ip_address":"","ucode":"FC93786244932F","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/d1/9d1c283b.jpg","comment_is_top":false,"comment_ctime":1547111869,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547111869","product_id":100017301,"comment_content":"数组来实现 LRU 缓存淘汰策略思路：<br>数组大小应该是固定的，<br>索引越小说明使用越早，每次向数组中插入一个数据之前同样两种情况，<br>如果已经存在将对应索引的值改为空，如果不存在，如果数组满了删除为空的和最近使用的，请老师指点","like_count":0},{"had_liked":false,"id":57720,"user_name":"鱼子酱","can_delete":false,"product_type":"c1","uid":1074872,"ip_address":"","ucode":"9D9B33A7B78142","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJic27dia65Z8OdictLLDOWic2fjFtiaQNQ1ou4icQ7AOjic4gK2iaOlYAUkNX7OoFnLs1hr1u5ib4Khcjib4DA/132","comment_is_top":false,"comment_ctime":1546875065,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546875065","product_id":100017301,"comment_content":"1. 链表与数组不同，特点是内存不连续，插入删除高效，复杂度是O(1)；而随机访问的复杂度是O(n)。<br>2. 几种常见的链表：单列表、双向链表、循环列表；<br><br>3. 单列表：包含一个数据元素和指向下一个阶段的指针，也就是pNext，并为尾节点的next指针为空。<br>循环列表：与单列表相似，不同的是尾节点的next指针指向头节点。<br>双向列表：每个节点包含两个指针，分别是指向前驱节点的prev指针和指向后继节点的next指针。在某些情况下，双向列表比单链表要高效。<br><br>4.空间换时间的思想：当内存空间足够时，如果追求代码的执行效率，可以采用空间复杂度较高，时间复杂度较低的算法，其中缓存就是利用了空间换时间的设计思想：<br><br>5.用链表判断一个字符串是否是回文字符串；<br>6.用链表实现LRU缓存淘汰算法。<br>","like_count":0},{"had_liked":false,"id":57288,"user_name":"pplegend","can_delete":false,"product_type":"c1","uid":1367329,"ip_address":"","ucode":"BD1AEE18CC4106","user_header":"","comment_is_top":false,"comment_ctime":1546718139,"is_pvip":false,"replies":[{"id":"21848","content":"都是回文。不啊，两个都适合的。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1547708558,"ip_address":"","comment_id":57288,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546718139","product_id":100017301,"comment_content":"abba 跟bacab 这两种都属于回文吧？ 设置两个指针的方法怎么感觉只适用后面那情况。或者说这两种情况需要分开来说吧？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435507,"discussion_content":"都是回文。不啊，两个都适合的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547708558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56537,"user_name":"garryfu","can_delete":false,"product_type":"c1","uid":1257714,"ip_address":"","ucode":"43AAF50CBB7273","user_header":"https://static001.geekbang.org/account/avatar/00/13/30/f2/249a7ed5.jpg","comment_is_top":false,"comment_ctime":1546484155,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546484155","product_id":100017301,"comment_content":"我认为这句话会有点误导：在链表中插入或者删除一个数据，，，，对应的时间复杂度是 O(1)。<br>比如我想删除链表中的第K个元素，那首先通过遍历找到这个元素，时间复杂度是O(n)，然后改变相邻元素的指针地址，时间复杂度是O(1)，那这样说来，插入或者删除链表的一个数据，对应的时间复杂度不就是O(n)嘛。","like_count":0},{"had_liked":false,"id":56488,"user_name":"钦","can_delete":false,"product_type":"c1","uid":1346929,"ip_address":"","ucode":"77D7B315D8FD72","user_header":"https://static001.geekbang.org/account/avatar/00/14/8d/71/ec84719c.jpg","comment_is_top":false,"comment_ctime":1546476989,"is_pvip":false,"replies":[{"id":"21318","content":"仔细看下文章吧，文章都有解释的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1547262003,"ip_address":"","comment_id":56488,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546476989","product_id":100017301,"comment_content":"单链删除插入跟数组比复杂度是O(1),跟双向链比又是O(n),麻烦说明一下","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435067,"discussion_content":"仔细看下文章吧，文章都有解释的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547262003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":55682,"user_name":"Dylan","can_delete":false,"product_type":"c1","uid":1040236,"ip_address":"","ucode":"58064D0C9F9F5F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/df/6c/5af32271.jpg","comment_is_top":false,"comment_ctime":1546260640,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546260640","product_id":100017301,"comment_content":"&#47;&#47;在leetcode上AC的，O(n)时间复杂度，O(1)空间复杂度，关键点已经注释了<br>func isPalindrome(head *ListNode) bool {<br>\tif head == nil || head.Next == nil {<br>\t\treturn true<br>\t}<br><br>\tvar cur, fast = head, head<br>\tvar prev *ListNode<br>\tfor fast != nil &amp;&amp; fast.Next != nil {&#47;&#47;快慢指针，到链表中间，顺便把前半部分逆序<br>\t\tcur.Next, prev, cur, fast = prev, cur, cur.Next, fast.Next.Next<br>\t}<br>\tif fast != nil {&#47;&#47;奇数的情况<br>\t\tcur = cur.Next<br>\t}<br><br>\tfor prev != nil &amp;&amp; cur != nil {&#47;&#47;将逆序的前半部分和后半部分一一比对<br>\t\tif prev.Val != cur.Val {<br>\t\t\treturn false<br>\t\t}<br><br>\t\tcur = cur.Next<br>\t\tprev = prev.Next<br>\t}<br>\treturn true<br>}<br>","like_count":0},{"had_liked":false,"id":53594,"user_name":"wordMan","can_delete":false,"product_type":"c1","uid":1335088,"ip_address":"","ucode":"3C8A681EF5E278","user_header":"https://static001.geekbang.org/account/avatar/00/14/5f/30/4ae82e16.jpg","comment_is_top":false,"comment_ctime":1545699044,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545699044","product_id":100017301,"comment_content":"既然链表再插入的时候涉及到先查找，复杂度为O(n),这样的话相对于数组的插入操作时间复杂度并没有优势啊。单纯讲链表插入为O（1）并没有什么意义啊？？","like_count":0},{"had_liked":false,"id":52960,"user_name":"happiness","can_delete":false,"product_type":"c1","uid":1026587,"ip_address":"","ucode":"C5F25D57C7A1DC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/1b/b43c8519.jpg","comment_is_top":false,"comment_ctime":1545558749,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545558749","product_id":100017301,"comment_content":"单链表类中增加一个链表长度的字段length。实现思路如下，从链表头遍历链表，截止条件为遍历次数达到length&#47;2或者前后。<br>从链表头依次遍历到链表中部，每次遍历取逻辑为从当前节点（假设位置为i，从0）往后搜索链表，到length-i-1的位置为止。比较两个节点value的值是否相等，相等的话进入一下次循环；不相等的话判断为非回文直接退出。<br>时间复杂度分析：正向遍历的时间复杂度为O(n平方&#47;4)【1+2+...n&#47;2】，反向的时间复杂度为O(n平方)【n-1+n-2+...+1】。总体时间复杂度为O(n平方)。","like_count":0},{"had_liked":false,"id":52555,"user_name":"CathyLin","can_delete":false,"product_type":"c1","uid":1240546,"ip_address":"","ucode":"F7CDFF5E1A235F","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/e2/0e1c6c5a.jpg","comment_is_top":false,"comment_ctime":1545432295,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545432295","product_id":100017301,"comment_content":"不好意思到现在才开始学习这一章，经历了一个很忙很忙的 quarter。但是不给自己找借口了，该补上的还是得补上！<br><br>自己的课程总结：（因为链表之前有接触过，所以一些基础的知识就没有放上去）<br>如何实现 LRU 缓存淘汰算法?<br>缓存是一种提高数据读取性能的技术，例如常见的 cpu 缓存、数据库缓存和浏览器缓存等。<br><br>但是缓存大小有限，如果满了我们要将它们清理出去。有以下几种缓存淘汰策略：<br>先进先出策略 FIFO (first in first out)，最少使用策略 LFU (least frequently used)，最近最少使用策略 (least recently used)。<br><br>链表和数组的区别<br>链表申请的内存空间可以不是连续的；而数组的内存空间是一定要连续的。<br><br>单链表<br>通过指针把零散的内存块联系在一起。然后内存块被称为是链表的&quot;结点&quot;。<br>头结点用来记录链表的基地址。<br>尾结点则指向 NULL，是最后一个结点。<br><br>循环链表<br>循环链表是一种特殊的单链表。只不过尾指针指向的是头结点。<br><br>当要处理的数据具有环形结构时，那么就适合采用循环链表。例如约瑟夫问题。<br><br>双向链表<br>双向链表，每个结点都有一个向后的指针连接后面，以及一个 prev 指针指向前一个结点。<br><br>需要占用更多的内存空间。<br>但是当我们知道当前指针指向链表的哪个位置（某个指定位置的结点）时，那么删除和插入对于双向链表来说就只是 O(1) 的复杂度了，而单链表来得找它的前一个位置的链表，所以是 O(n) 的复杂度了。<br><br>空间换时间的 Idea!<br>缓存就是空间换时间。将数据存在硬盘里面会比较省内存，但是花时间。所以将其存在了内存中，虽然耗空间，但是运行速度就大大提升了。<br><br>双向循环链表<br><br>链表 vs 数组性能<br><br>它们插入删除、随机访问的时间复杂度刚好相反。<br><br>思考题 - 怎样利用链表实现 LRU 缓存淘汰算法<br>LRU(最近最少使用)，所以我们可以维护一个链表，然后最常访问的放在链表的头部，然后不经常访问的放在链表的尾部，然后如果有新的数据被访问时，分为两种情况：<br>\t1. 这个数据已经在链表的结点中了，那么我们将其从原位置删除，然后重新将它插入到链表的头部。<br>\t2. 这个数据没有在链表的结点中，又得分成两种情况：<br>\t\ta. 当前缓存已经满了，那么我们得先删除链表的尾部，然后再将当前这个数据插入到链表的头部。<br>\t\tb. 当前缓存没有满，那么我们直接将数据插入到链表的头部就好了！<br>复杂度：因为我们都得遍历一遍链表，所以最后的复杂度为 O(n)。<br><br>思考题我还没有想出来，先放着，不打算直接看答案。容我想一想然后再来评论区给答案！加油加油！！！","like_count":0},{"had_liked":false,"id":52183,"user_name":"陈悬高","can_delete":false,"product_type":"c1","uid":1065981,"ip_address":"","ucode":"457213A8351202","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/fd/908706cc.jpg","comment_is_top":false,"comment_ctime":1545331936,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545331936","product_id":100017301,"comment_content":"通过定位中间节点，可以检查链表的前半部分和进行反转后的后半部分是否相等，从而确定链表数据是否是回文格式。具体步骤如下：<br><br>1. 使用快慢指针定位中间节点。当链表的大小是偶数时，将返回中间的两个节点，要求它们必须相等。<br>2. 反转链表的后半部分（不包含中间节点）。<br>3. 遍历比较两部分数据，要求必须相等。<br>4. 再次反转链表的后半部分（不包含中间节点），恢复原始链表。<br>\t<br>为了简化实现，在查找链表的中间节点时，有可能会返回两个节点。如果链表的大小是奇数，返回的恰好是中间节点；如果链表的大小是偶数，返回的则是中间的两个节点。在实现上使用了一个表示两个节点的*二维元组* `TwoTuple&lt;Node, Node&gt;`。如果链表的大小是奇数，那么二维元组的第一项将是中间节点，第二项为 `null`；如果链表的大小是偶数，那么第一项将是上中位节点，第二项将是下中位节点。<br>\t<br>定位中间节点需要遍历 N&#47;2 次，反转链表的一半需要遍历 N&#47;2 次，遍历比较链表的一半需要遍历 N&#47;2 次，所以总共的遍历次数是 2N 次。时间复杂度为 O(N)。但是，该实现不需要额外的内存空间，空间复杂度为 O(1)。<br><br>```java<br>&#47;**<br> * 检查链表数据是否是回文格式。<br> * <br> * @param head<br> * @return<br> *&#47;<br>public static &lt;Item extends Comparable&lt;? super Item&gt;&gt; boolean isPalindrome(Node&lt;Item&gt; head) {<br>\tif (head == null) &#47;&#47; 链表为空<br>\t\tthrow new NullPointerException(&quot;head is null&quot;);<br><br>\tif (head.next == null) &#47;&#47; 只有一个节点<br>\t\treturn true;<br><br>\t&#47;&#47; 1. 使用快慢指针定位中间节点。<br>\tTwoTuple&lt;Node&lt;Item&gt;, Node&lt;Item&gt;&gt; tuple = getMiddleNode(head);<br>\tNode&lt;Item&gt; first = tuple.first; &#47;&#47; 中间节点或上中位节点<br>\tNode&lt;Item&gt; second = tuple.second; &#47;&#47; 下中位节点<br>\t&#47;&#47; 若链表的大小是偶数，则有两个中间节点；要求它们必须相等。<br>\tif (second != null) {<br>\t\tif (first.item.compareTo(second.item) != 0)<br>\t\t\treturn false;<br>\t}<br><br>\t&#47;&#47; 2. 反转链表的后半部分（不包含中间节点）。<br>\tNode&lt;Item&gt; probe = first;<br>\tif (second != null) {<br>\t\tprobe = second;<br>\t}<br>\tprobe.next = reverse(probe.next);<br><br>\t&#47;&#47; 3. 对链表的前半部分，以及反转后的链表的后半部分执行遍历比较，要求必须相等。<br>\tboolean result = true;<br>\tNode&lt;Item&gt; p1 = head;<br>\tNode&lt;Item&gt; p2 = probe.next;<br>\twhile (p2 != null) {<br>\t\tif (p1.item.compareTo(p2.item) != 0) {<br>\t\t\tresult = false;<br>\t\t\tbreak;<br>\t\t}<br>\t\tp1 = p1.next;<br>\t\tp2 = p2.next;<br>\t}<br><br>\t&#47;&#47; 4. 再次反转链表的后半部分（不包含中间节点），恢复原始链表。<br>\tprobe.next = reverse(probe.next);<br><br>\treturn result;<br>}<br>```","like_count":0},{"had_liked":false,"id":51667,"user_name":"咔咔NG","can_delete":false,"product_type":"c1","uid":1022449,"ip_address":"","ucode":"5CADAF3044ADFE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/f1/68f5c089.jpg","comment_is_top":false,"comment_ctime":1545220305,"is_pvip":false,"replies":[{"id":"18789","content":"如果要删除p 那只需要p-&gt;previous-&gt;next =p-&gt;next就可以了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545271429,"ip_address":"","comment_id":51667,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545220305","product_id":100017301,"comment_content":"老师，为什么双向链表删除的复杂度是O（1）？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433563,"discussion_content":"如果要删除p 那只需要p-&amp;gt;previous-&amp;gt;next =p-&amp;gt;next就可以了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545271429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51583,"user_name":"Ewing","can_delete":false,"product_type":"c1","uid":1184341,"ip_address":"","ucode":"D31B0F66492D6D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIYIAkP3iaQzq8z3V2FibVX13g897ibnBt0g6Ps6QsN007JIpObLVia855GY0q842ljPbw3u54YEzmWxw/132","comment_is_top":false,"comment_ctime":1545203567,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545203567","product_id":100017301,"comment_content":"老师，我在看你gitlab上的代码的时候，发现这段代码有问题。<br>&#47;**<br>     * 模拟访问某个值<br>     * @param object<br>     *&#47;<br>    public void offer(T object) {<br>        if (object == null) {<br>            throw new IllegalArgumentException(&quot;该缓存容器不支持null!&quot;);<br>        }<br>        Integer index = holder.get(object);<br>        if (index == null) {<br>            if (isFull()) {<br>                removeAndCache(object);<br>            } else {<br>                cache(object, count);<br>            }<br>        } else {<br>            update(index);<br>        }<br>    }<br>在调用cache()方法的时候，传入的第二个参数应该是 index 索引吧？<br>希望得到老师的指点，谢谢！","like_count":0},{"had_liked":false,"id":51439,"user_name":"yann [扬] :曹同学","can_delete":false,"product_type":"c1","uid":1199315,"ip_address":"","ucode":"C449253263E796","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/d3/365fe5a1.jpg","comment_is_top":false,"comment_ctime":1545183099,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545183099","product_id":100017301,"comment_content":"cpu带几块小缓存，以KB为单位，比内存还快，其实是硬盘，内存，cpu缓存接力的<br><br>另，什么是回文字串？","like_count":0},{"had_liked":false,"id":51224,"user_name":"那样的月色","can_delete":false,"product_type":"c1","uid":1237353,"ip_address":"","ucode":"23B1298C465D2C","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/69/0db70c84.jpg","comment_is_top":false,"comment_ctime":1545139190,"is_pvip":false,"replies":[{"id":"18551","content":"都是的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545184869,"ip_address":"","comment_id":51224,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545139190","product_id":100017301,"comment_content":"学习了，快慢指针  ，，弱弱的问一句：ABCDEDCBA 和ABCDDCBA 这两个都是回文，还是说只有后面一个是回文？  ","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433351,"discussion_content":"都是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545184869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50718,"user_name":"abs","can_delete":false,"product_type":"c1","uid":1181674,"ip_address":"","ucode":"04CF4E57913A41","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/ea/b82fd545.jpg","comment_is_top":false,"comment_ctime":1545034533,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545034533","product_id":100017301,"comment_content":"根据程序的局部性原理，最近的、将来要使用的数据和指令大多局限于正在使用的指令和数据，或存放于与这些指令数据临近的单元中。计算机就是基于这个原理把将要用到的数据替换缓存到cache中，所以访问数组中的一个元素，计算机可能把整个数组都给缓存，这样不需要多次访问主存，可以极大加速遍历等操作，由于使用链表存储的数据可以不是连续的，根据局部性原理设计的缓存就无用武之地了，造成链表中数据cache命中率低","like_count":0},{"had_liked":false,"id":50415,"user_name":"Geek_04e22a","can_delete":false,"product_type":"c1","uid":1184505,"ip_address":"","ucode":"B64FF12EA28BA6","user_header":"https://static001.geekbang.org/account/avatar/00/12/12/f9/7e6e3ac6.jpg","comment_is_top":false,"comment_ctime":1544970185,"is_pvip":false,"replies":[{"id":"18147","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545009299,"ip_address":"","comment_id":50415,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1544970185","product_id":100017301,"comment_content":"时间换空间:请求分页，请求分段<br>空间换时间:缓存技术<br><br>数组:简单易用，随机访问，借助CPU缓存，访问效率高<br><br>链表:支持动态扩容<br><br>LRU数组实现：<br>如果有，后移，放到首位<br>没有，够用，后移，放到首位<br>没有，不够用，删除末尾，后移，加到开始<br><br>回文算法:<br>单链表<br>一个快指针，寻找中间位置<br>慢指针，前半部分反序<br>时间复杂度：O(n)<br>空间复杂度：&#39;O(1)<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432977,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545009299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50284,"user_name":"Ben","can_delete":false,"product_type":"c1","uid":1252353,"ip_address":"","ucode":"70351D4FAE47F7","user_header":"https://static001.geekbang.org/account/avatar/00/13/1c/01/5aaaf5b6.jpg","comment_is_top":false,"comment_ctime":1544943624,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544943624","product_id":100017301,"comment_content":"&#47;&#47;约瑟夫问题 循环链表实现<br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>struct Human {<br>\tint\t\tlive;<br>\tint\t\tID;<br>\tstruct Human\t*next;<br>};<br>void printJosephus( struct Human *n, int count )<br>{<br>\tint interval = 3;<br>\twhile ( count &gt; 0 )<br>\t{<br>\t\tif ( n-&gt;live == 1 )<br>\t\t{<br>\t\t\tinterval = interval - 1;<br><br>\t\t\tif ( interval == 0 )<br>\t\t\t{<br>\t\t\t\tn-&gt;live\t\t= 0;<br>\t\t\t\tinterval\t= 3;<br>\t\t\t\tprintf( &quot; %d &quot;, n-&gt;ID );<br><br>\t\t\t\tcount = count - 1;<br>\t\t\t}<br>\t\t}<br>\t\tn = n-&gt;next;<br>\t}<br>}<br><br>int main()<br>{<br>\tstruct Human\t* head\t= NULL;<br>\tstruct Human\t* sec\t= NULL;<br>\tstruct Human\t* third = NULL;<br>\tstruct Human\t* four\t= NULL;<br>\tstruct Human\t* fiv\t= NULL;<br>\thead\t= (struct Human *) malloc( sizeof(struct Human) );<br>\tsec\t= (struct Human *) malloc( sizeof(struct Human) );<br>\tthird\t= (struct Human *) malloc( sizeof(struct Human) );<br>\tfour\t= (struct Human *) malloc( sizeof(struct Human) );<br>\tfiv\t= (struct Human *) malloc( sizeof(struct Human) );<br><br>\thead-&gt;ID\t= 1; head-&gt;live = 1; head-&gt;next = sec;<br>\tsec-&gt;ID\t\t= 2; sec-&gt;live = 1; sec-&gt;next = third;<br>\tthird-&gt;ID\t= 3; third-&gt;live = 1; third-&gt;next = four;<br>\tfour-&gt;ID\t= 4; four-&gt;live = 1; four-&gt;next = fiv;<br>\tfiv-&gt;ID\t\t= 5; fiv-&gt;live = 1; fiv-&gt;next = head;<br><br>\tprintJosephus( head, 5 );<br>}","like_count":0},{"had_liked":false,"id":50244,"user_name":"废材","can_delete":false,"product_type":"c1","uid":1347916,"ip_address":"","ucode":"DDB85EACFB257A","user_header":"https://static001.geekbang.org/account/avatar/00/14/91/4c/32c9403c.jpg","comment_is_top":false,"comment_ctime":1544931463,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544931463","product_id":100017301,"comment_content":"自己查了下快慢指针，觉着无论快慢指针都是要遍历整个链表的，那么块指针的遍历时间复杂度是logn吧？<br>我的思路是：<br>直接遍历全部链表，链表数据用stringbuffer存储，这样遍历完时间复杂度是O(n),然后字符串recover之后比较，但是，recover本身的复杂度应该就是O(n),这样总体时间是2n的遍历时间。","like_count":0},{"had_liked":false,"id":50194,"user_name":"融梨","can_delete":false,"product_type":"c1","uid":1033405,"ip_address":"","ucode":"66D0A4054612C6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c4/bd/72180435.jpg","comment_is_top":false,"comment_ctime":1544898968,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544898968","product_id":100017301,"comment_content":"链表不同于数组，链表的底层数据结构是一段不连续性的内存块，不像数组需要连续性的内存空间。链表，是一个个内存块通过后继指针连接下一个内存块。","like_count":0},{"had_liked":false,"id":50027,"user_name":"陈悬高","can_delete":false,"product_type":"c1","uid":1065981,"ip_address":"","ucode":"457213A8351202","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/fd/908706cc.jpg","comment_is_top":false,"comment_ctime":1544843492,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544843492","product_id":100017301,"comment_content":"如何用单链表来实现 LRU 缓存？<br><br>*答案*：在 LRU 的链表实现中，链表节点按访问时间排序。当从链表缓存中访问节点时，该节点将成为最近访问的（MRU，Most Recently Used）节点。如果缓存已满，在插入新节点前，还需要删除最久以前访问的（LRU，Least Recently Used）节点。<br><br>单链表可以有两种排序方式：<br><br>1.  链表节点按访问时间从近到远排序：链表的头节点是最近访问的，链表的尾节点是最久以前访问的。在实现上，我们首先遍历链表来查找指定的节点，<br><br>\t1. 如果该节点已存在，我们会将该节点移动到链表的头部：先删除该节点，然后将其插入到链表的头部。<br><br>\t2. 如果该节点不存在，我们会直接将该节点插入到链表的头部。要注意的是，在插入新节点前需要检查缓存是否已满，如果缓存已满，那么需要先删除链表的尾节点。<br><br>2.  链表节点按访问时间从远到近排序：链表的头节点是最久以前访问的，链表的尾节点是最近访问的。在实现上，我们首先遍历链表来查找指定的节点，<br><br>\t1. 如果该节点已存在，我们会将该节点移动到链表的尾部：先删除该节点，然后将其插入到链表的尾部。<br><br>\t2. 如果该节点不存在，我们会直接将该节点插入到链表的尾部。要注意的是，在插入新节点前需要检查缓存是否已满，如果缓存已满，那么需要先删除链表的头节点。<br>\t<br>如果链表节点按访问时间从近到远排序，在删除链表的尾节点时，还需要遍历链表找到倒数第二个节点并将其指 `null`。如果链表节点按访问时间从远到近排序，为了便于在链表的尾部插入，需要维护一个额外的指向链表尾节点的引用变量。<br><br>不管对链表采用哪种排序方式，我们都需要遍历链表来查找指定的节点。所以，缓存访问的时间复杂度都是 O(N)。","like_count":0},{"had_liked":false,"id":49920,"user_name":"-{Wo^0}","can_delete":false,"product_type":"c1","uid":1346934,"ip_address":"","ucode":"DC2B976CC53ACD","user_header":"https://static001.geekbang.org/account/avatar/00/14/8d/76/48529fb5.jpg","comment_is_top":false,"comment_ctime":1544789795,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544789795","product_id":100017301,"comment_content":"老师，现在留言您还看的到吗？我看了您在GitHub上的代码，感觉在重复删除value链表的地方，不太严谨：<br>if (head != null &amp;&amp; head.data == value) {<br>           head = head.next;<br>           }<br>           Node pNode = head;<br>如果头节点的下一个节点值也时value怎么办？我是这样改的：<br>if (head != null)<br>      while (head.data == value)<br>             head = head.next;<br>if (head == null)return;<br>老师您看下，我这样写合适吗？<br>","like_count":0},{"had_liked":false,"id":49069,"user_name":"泉","can_delete":false,"product_type":"c1","uid":1099760,"ip_address":"","ucode":"914709BE802A8D","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/f0/aa2e0749.jpg","comment_is_top":false,"comment_ctime":1544598254,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1544598254","product_id":100017301,"comment_content":"双向链表练习。<br>链表和数组对比。","like_count":0},{"had_liked":false,"id":47813,"user_name":"Xiaoqi","can_delete":false,"product_type":"c1","uid":1072043,"ip_address":"","ucode":"9C021D946B3CF0","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/ab/ce1f9a7f.jpg","comment_is_top":false,"comment_ctime":1544219176,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544219176","product_id":100017301,"comment_content":"Python Implementation: leetcode 234 palindrome-linked-list<br># Definition for singly-linked list.<br>class ListNode(object):<br>    def __init__(self, x):<br>        self.val = x<br>        self.next = None<br><br>class Solution(object):<br>    def isPalindrome(self, head):<br>        &quot;&quot;&quot;<br>        :type head: ListNode<br>        :rtype: bool<br>        &quot;&quot;&quot;<br>        def reverseList(root):<br>            pre = None<br>            cur = root<br>            while cur:<br>                tmp = cur.next<br>                cur.next = pre<br>                pre = cur<br>                cur = tmp<br>            return pre<br>            <br>        slow = fast = head<br>        while fast and fast.next:<br>            slow = slow.next<br>            fast = fast.next.next<br>            <br>        newHead = reverseList(slow)<br>        p1 = head<br>        p2 = newHead<br>        while p1 and p2:<br>            if p1.val != p2.val:<br>                return False<br>            p1 = p1.next<br>            p2 = p2.next<br>        return True","like_count":0},{"had_liked":false,"id":47593,"user_name":"扬～","can_delete":false,"product_type":"c1","uid":1208163,"ip_address":"","ucode":"6FA7D8FE188341","user_header":"https://static001.geekbang.org/account/avatar/00/12/6f/63/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1544161242,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544161242","product_id":100017301,"comment_content":"LRU有对应的实例代码吗？？？","like_count":0},{"had_liked":false,"id":47326,"user_name":"吴涛","can_delete":false,"product_type":"c1","uid":1175639,"ip_address":"","ucode":"14248ED0C2CA6E","user_header":"https://static001.geekbang.org/account/avatar/00/11/f0/57/205cef6e.jpg","comment_is_top":false,"comment_ctime":1544107537,"is_pvip":false,"replies":[{"id":"16927","content":"弄个循环链表可以解决吗","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544148657,"ip_address":"","comment_id":47326,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1544107537","product_id":100017301,"comment_content":"想起一个之前遇到的问题，请教一下。我自己写过一个C语言的双向链表，存储的数据是一个short数组，当链表元素存满之后，存储新的元素时我选择的是把链表尾部的node解除前后指针挪到头部复用，达到节省内存的效果，但是实际应用中却数据出错了，当时没找到具体原因。最后解决办法是当链表存满后释放尾部的node，重新创建新的node放到头部，解决了问题。当时项目紧急就没深究原因了，现在学到这里，又想起来了，还请赐教！","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431737,"discussion_content":"弄个循环链表可以解决吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544148657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":47252,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1544089493,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544089493","product_id":100017301,"comment_content":"五花八门的链表 ------<br>单链表：尾节点指向空<br>双向链表：更常用<br>循环链表：特点是到头结点方便，如约瑟夫问题<br><br><br>来历：克服连续空间有限的问题<br>特点：删除和插入块，但是定位删除和插入点应该也是查询操作；除了不需要连续空间，没有任何优势啊，对比数组来说<br>适合解决的问题：几乎没什么优势<br>实际应用：LRU就是一个队列，链表和数组都可以搞定<br><br>思考题：单链表翻转，^_^","like_count":0},{"had_liked":false,"id":47126,"user_name":"Kevin","can_delete":false,"product_type":"c1","uid":1002974,"ip_address":"","ucode":"844B3E137C9A58","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/de/1a63cef1.jpg","comment_is_top":false,"comment_ctime":1544060713,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544060713","product_id":100017301,"comment_content":"从单向链表删除节点遍历的时候判断当前节点的next节点是不是要删除的元素就行了吧，不用再重新遍历一遍找","like_count":0},{"had_liked":false,"id":47094,"user_name":"融梨","can_delete":false,"product_type":"c1","uid":1033405,"ip_address":"","ucode":"66D0A4054612C6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c4/bd/72180435.jpg","comment_is_top":false,"comment_ctime":1544056037,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544056037","product_id":100017301,"comment_content":"既然是链表，那么要基于链表的知识来思考。链表有单链表，双链表，循环链表。答案在这三个中。你问我，什么是链表，我只能说它是一段不连续性的内存空间。","like_count":0},{"had_liked":false,"id":46879,"user_name":"chilion","can_delete":false,"product_type":"c1","uid":1325600,"ip_address":"","ucode":"6E24757952BD5B","user_header":"https://static001.geekbang.org/account/avatar/00/14/3a/20/eefeb0e3.jpg","comment_is_top":false,"comment_ctime":1543996141,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543996141","product_id":100017301,"comment_content":"感觉看评论能学习更多....","like_count":0},{"had_liked":false,"id":46451,"user_name":"Geek_abf512","can_delete":false,"product_type":"c1","uid":1339031,"ip_address":"","ucode":"C9797FADF918FC","user_header":"","comment_is_top":false,"comment_ctime":1543928846,"is_pvip":false,"replies":[{"id":"16668","content":"都可以的 建议继续看后面的章节 会有解答","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543974150,"ip_address":"","comment_id":46451,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1543928846","product_id":100017301,"comment_content":"LRU通常使用双向链表LinkedHashMap实现，为什么老师解答单链表的插入模式？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431463,"discussion_content":"都可以的 建议继续看后面的章节 会有解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543974150,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":46422,"user_name":"X","can_delete":false,"product_type":"c1","uid":1150623,"ip_address":"","ucode":"BA4C2F83953C54","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erxia5dpTeXMHR1e4ibicyRkS6fAuxarFicFZ3kwlrosFszjazFDJaRrrAiaH9hX0ia45xTKE6GetKIrgqg/132","comment_is_top":false,"comment_ctime":1543920753,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543920753","product_id":100017301,"comment_content":"老师，对于有序链表按值查找，双向链表相对于单链表的优势是只需平均查找一半，这个表述不准确吧？平均查找一半是因为记录了上次查找的P这一做法带来的优化，而非双向链表！因为单向链表也可以记录上次的P！<br>1）假设被查找的数据一定在链表中，如果本次查找的值大于P即往后查，单双两者所需时间一样，如果小于P，单链表从头往后查，双向链表从P的前一个开始往前查，如果分布均匀的话，两个方向查找复杂度一样！<br>2）如果被查的不在链表中，那么大于P往后查两者时间依然一样，只有小于P时，单链表需要遍历所有，而双向链表只需遍历P以前的部分。","like_count":0},{"had_liked":false,"id":45581,"user_name":"卡佩罗🍀","can_delete":false,"product_type":"c1","uid":1182943,"ip_address":"","ucode":"47B24D7D41B4EF","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/df/c94bf568.jpg","comment_is_top":false,"comment_ctime":1543713443,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543713443","product_id":100017301,"comment_content":"讲得很好 结合实际例子更好","like_count":0},{"had_liked":false,"id":45234,"user_name":"Leo","can_delete":false,"product_type":"c1","uid":1220277,"ip_address":"","ucode":"7A11B26AEA5510","user_header":"https://static001.geekbang.org/account/avatar/00/12/9e/b5/17ff83e6.jpg","comment_is_top":false,"comment_ctime":1543564361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543564361","product_id":100017301,"comment_content":"单链表回文判断按照我的理解：<br>首先需要知道单链表如何反转。<br>其次需要知道如何查找单链表的中间结点。<br><br>先弄清楚这两个算法是如何实现的，之后再去看评论里面大佬们说的算法就会清楚多了。<br>","like_count":0},{"had_liked":false,"id":44786,"user_name":"匆匆","can_delete":false,"product_type":"c1","uid":1333414,"ip_address":"","ucode":"4DB39C6CD5743B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/H8NxrljQXliccaT5fjdXJQYS3ou3Z9ykAuKw6EgicicEA9L4jQLz3h85P0odgDSaK0cA9oTyUKibbiagdNvnHuuV5mQ/132","comment_is_top":false,"comment_ctime":1543492736,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543492736","product_id":100017301,"comment_content":"链表总结<br><br>链表特点 ：1、线性表；2、内存可不连续<br><br>链表种类：单链表、循环链表、双链表、循环双链表；<br><br>链表和数组是两种优劣刚好相反的数据结构。数组的随机访问时间复杂度为O(1)，插入和删除的时间的时间复杂度为O(n)（因为需要遍历移动数组）,而链表则刚好相反。当然相反的是双链表。对于单链表则插入和删除也需要O(n),因为需要知道前一个节点的指针next，那就需要遍历查找。<br><br>以上说的链表删除节点其实有两种情况，一种是删除指定指针处的节点，那么时间复杂度O(1)；另一种是删除指定内容的节点，那么则需要遍历查找该内容，时间复杂度为O(n)；<br><br><br>PS：空间换时间的思想：双链表效率提高了，同时空间占用也增多了，其实是一种空间换时间的思想，很多设计中会用到类似的思想。<br><br>最后：实现LRU缓存淘汰法：将刚访问的内容进行遍历查找，如果缓存中存在，则将其删除，然后在添加新节点到头部；如果缓存中不存在，则直接添加新节点到头部，同时将尾部的节点删除；","like_count":0},{"had_liked":false,"id":44436,"user_name":"少盐","can_delete":false,"product_type":"c1","uid":1305743,"ip_address":"","ucode":"BCC7E264B75702","user_header":"https://static001.geekbang.org/account/avatar/00/13/ec/8f/8299495a.jpg","comment_is_top":false,"comment_ctime":1543448402,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543448402","product_id":100017301,"comment_content":"写的太好了，留言质量高","like_count":0},{"had_liked":false,"id":44039,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1543366104,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543366104","product_id":100017301,"comment_content":"11月28日:<br>把该讲内容总结为几个问题, 大家复习的时候可以先尝试回答这些问题检查自己的掌握程度:<br><br>\t1. <br>单向链表, 循环链表, 双向链表, 双向循环链表的数据结构各是什么样的?<br>\t2. <br>双向链表相比单向链表有什么特点?<br>\t3. <br>链表如何实现插入, 删除, 和随机遍历等操作?<br>\t4. <br>结合CPU, 内存与缓存分析链表和数组在性能上各自有什么特点? <br><br>","like_count":0},{"had_liked":false,"id":44025,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1543365556,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543365556","product_id":100017301,"comment_content":"思考题:<br>把字符串拆成char[]放到双向循环链表里, 然后从头结点找到尾节点, 从头尾两个方法向中间遍历, 这样是不是也可以实现, 请老师指正.","like_count":0},{"had_liked":false,"id":43851,"user_name":"饺子","can_delete":false,"product_type":"c1","uid":1251229,"ip_address":"","ucode":"88FEB4B0D68975","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/9d/a3706e4f.jpg","comment_is_top":false,"comment_ctime":1543309697,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543309697","product_id":100017301,"comment_content":"单链表<br>循环链表<br>双链表<br>数组 链表插入、删除、访问时间复杂度。<br>","like_count":0},{"had_liked":false,"id":43805,"user_name":"不知不觉","can_delete":false,"product_type":"c1","uid":1273519,"ip_address":"","ucode":"0F0996D20C3AD7","user_header":"https://static001.geekbang.org/account/avatar/00/13/6e/af/1c21e7d6.jpg","comment_is_top":false,"comment_ctime":1543299728,"is_pvip":false,"replies":[{"id":"15786","content":"兄弟 没看懂你说的啥啊","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543404632,"ip_address":"","comment_id":43805,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1543299728","product_id":100017301,"comment_content":"单链表的时间复杂度是O(1)?这个不对吧，遍历查找的时候如果考虑最坏情况，时间复杂度为O（n）吧","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430505,"discussion_content":"兄弟 没看懂你说的啥啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543404632,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":43108,"user_name":"云学","can_delete":false,"product_type":"c1","uid":1027233,"ip_address":"","ucode":"366AE90BA06356","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ac/a1/43d83698.jpg","comment_is_top":false,"comment_ctime":1543164602,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543164602","product_id":100017301,"comment_content":"对于单向链表，在不知道前驱节点时也可以极快增删，只要交换后面2节点，参考《编程之美》《剑指offer》","like_count":0},{"had_liked":false,"id":42194,"user_name":"Mr.Lee","can_delete":false,"product_type":"c1","uid":1240758,"ip_address":"","ucode":"F732D98D262703","user_header":"https://static001.geekbang.org/account/avatar/00/12/ee/b6/f99db3e7.jpg","comment_is_top":false,"comment_ctime":1542933313,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542933313","product_id":100017301,"comment_content":"老师，有个问题想问一下，就是在链表删除操作中，删除给定指针的节点为啥要知道前一个节点？已经知道了，直接删除不就行了吗？","like_count":0},{"had_liked":false,"id":42051,"user_name":"特普特","can_delete":false,"product_type":"c1","uid":1150016,"ip_address":"","ucode":"F216A5512F9BF6","user_header":"https://static001.geekbang.org/account/avatar/00/11/8c/40/96fd39ce.jpg","comment_is_top":false,"comment_ctime":1542898124,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542898124","product_id":100017301,"comment_content":"LRU那段没看懂，请问清理缓存的意思是什么？是去掉链表之间的碎片吗？","like_count":0},{"had_liked":false,"id":41638,"user_name":"S","can_delete":false,"product_type":"c1","uid":1292920,"ip_address":"","ucode":"5DD89023B9FC3C","user_header":"https://static001.geekbang.org/account/avatar/00/13/ba/78/bbf723ff.jpg","comment_is_top":false,"comment_ctime":1542812825,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542812825","product_id":100017301,"comment_content":"思考题 ：设置两个指针 一个一次走一个单位 第二个一次走另个单位 每循环一次比较一次","like_count":0},{"had_liked":false,"id":40909,"user_name":"对方正在输入","can_delete":false,"product_type":"c1","uid":1257515,"ip_address":"","ucode":"57C3A444E33832","user_header":"https://static001.geekbang.org/account/avatar/00/13/30/2b/bc5873c6.jpg","comment_is_top":false,"comment_ctime":1542693301,"is_pvip":false,"replies":[{"id":"14805","content":"你的方法借助了栈 实际上可以在链表原地实现","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542766247,"ip_address":"","comment_id":40909,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542693301","product_id":100017301,"comment_content":"课后思考<br><br>1. 快慢指针找到链表中间位置节点<br>2. 将链表前半部入栈，然后在遍历后半部分时，将元素逐一弹出，进行比较<br>3. 处理链表的奇偶，如果为奇，跳过中间节点<br><br>请问老师这种快慢指针是不是最优解呢<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429645,"discussion_content":"你的方法借助了栈 实际上可以在链表原地实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542766247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":40877,"user_name":"Edison","can_delete":false,"product_type":"c1","uid":1135701,"ip_address":"","ucode":"734A561F363720","user_header":"https://static001.geekbang.org/account/avatar/00/11/54/55/613ddc42.jpg","comment_is_top":false,"comment_ctime":1542686745,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542686745","product_id":100017301,"comment_content":"  老师，假如要插入或删除双向链表指定位置的结点，按理来说应该要先找到指定位置的结点，寻找指定结点的过程不需要遍历链表吗？","like_count":0},{"had_liked":false,"id":40337,"user_name":"格勒","can_delete":false,"product_type":"c1","uid":1216191,"ip_address":"","ucode":"E479F7CB054EB6","user_header":"https://static001.geekbang.org/account/avatar/00/12/8e/bf/996c3aa6.jpg","comment_is_top":false,"comment_ctime":1542595172,"is_pvip":false,"replies":[{"id":"14677","content":"这不是应试考试 你可以自己去假设的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542679202,"ip_address":"","comment_id":40337,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542595172","product_id":100017301,"comment_content":"思考题应该说明，一，是否知道链表长度，二，是否可以对链表进行修改。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429481,"discussion_content":"这不是应试考试 你可以自己去假设的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542679202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":40084,"user_name":"smartzs","can_delete":false,"product_type":"c1","uid":1062867,"ip_address":"","ucode":"CE190E031818E1","user_header":"https://static001.geekbang.org/account/avatar/00/10/37/d3/9febe49d.jpg","comment_is_top":false,"comment_ctime":1542466857,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542466857","product_id":100017301,"comment_content":"对于再使用一个栈来存值的方法能看懂，而对上面的同学用指针移动直接反转链表的方法都没看懂 <br>class ListNode:<br>    def __init__(self, x):<br>        self.val = x<br>        self.next = None<br> <br>class Palindrome:<br>    def isPalindrome(self, pHead):<br>        if pHead == None or pHead.next == None:<br>            return True<br>        pslow = pHead<br>        pfast = pHead<br>        stack = [pslow.val]<br>        # 查找链表中心<br>        while True:<br>            # 奇数链，比较从后半部分第一个开始<br>            if not pfast.next:<br>                mid = pslow<br>                break<br>            # 偶数链，比较从后半部分第一个开始<br>            elif pfast and not pfast.next.next:<br>                mid = pslow.next<br>                break<br>            pslow = pslow.next<br>            pfast = pfast.next.next<br>            stack.append(pslow.val)<br>        # 回文对比<br>        print stack<br>        while stack and mid.next:<br>            tmp = stack.pop()<br>            if mid.val != tmp:<br>                return False<br>            print mid.val, tmp<br>            mid = mid.next<br>        return True<br>node1 = ListNode(1)<br>node2 = ListNode(2)<br>node3 = ListNode(3)<br># node4 = ListNode(3)<br>node5 = ListNode(2)<br>node6 = ListNode(1)<br>node1.next = node2<br>node2.next = node3<br>node3.next = node5<br># node4.next = node5<br>node5.next = node6<br>S = Palindrome()<br>p = S.isPalindrome(node1)<br>print(p)<br>","like_count":0},{"had_liked":false,"id":39968,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1542424377,"is_pvip":false,"replies":[{"id":"14686","content":"可以存 也可以不存。带头链表就不存储数据","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542680015,"ip_address":"","comment_id":39968,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542424377","product_id":100017301,"comment_content":"一般单链表的头结点存储数据吗","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429311,"discussion_content":"可以存 也可以不存。带头链表就不存储数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542680015,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39936,"user_name":"Edison","can_delete":false,"product_type":"c1","uid":1135701,"ip_address":"","ucode":"734A561F363720","user_header":"https://static001.geekbang.org/account/avatar/00/11/54/55/613ddc42.jpg","comment_is_top":false,"comment_ctime":1542411973,"is_pvip":false,"replies":[{"id":"14688","content":"能说下为什么要遍历吗。你是怎么理解的呢","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542680196,"ip_address":"","comment_id":39936,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542411973","product_id":100017301,"comment_content":"老师，为什么双向链表在执行节点的插入与删除时，时间复杂度为O(1)，按理来说，在双向链表插入元素与删除元素，应该也要遍历链表的。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429300,"discussion_content":"能说下为什么要遍历吗。你是怎么理解的呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542680196,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39775,"user_name":"Geek_987169","can_delete":false,"product_type":"c1","uid":1180853,"ip_address":"","ucode":"4B2955A044805D","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/b5/8bc4790b.jpg","comment_is_top":false,"comment_ctime":1542354624,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542354624","product_id":100017301,"comment_content":"老师，使用git代码java-&gt;06_linkedlist-&gt;SinglyLinkedList.java测试序列int data[] = {1,2,3,3,2,1};结果为不是回文序列，请老师看下。","like_count":0},{"had_liked":false,"id":39669,"user_name":"杨旭","can_delete":false,"product_type":"c1","uid":1276526,"ip_address":"","ucode":"D7C527BEB4407F","user_header":"https://static001.geekbang.org/account/avatar/00/13/7a/6e/2118909c.jpg","comment_is_top":false,"comment_ctime":1542334101,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542334101","product_id":100017301,"comment_content":"关于用单链表进行回文字符串判断时，有两种方法：<br>1) 快慢指针，时间复杂度O（n），空间复杂度O（1）<br>2) 复制一个逆序单链表，然后从表头比较，时间复杂度O（n），空间复杂度O（n）<br><br>如有问题，希望各位大牛指正。","like_count":0},{"had_liked":false,"id":39441,"user_name":"小糊涂仙丶","can_delete":false,"product_type":"c1","uid":1076259,"ip_address":"","ucode":"98F1BB4314A9F1","user_header":"https://static001.geekbang.org/account/avatar/00/10/6c/23/833eb7f4.jpg","comment_is_top":false,"comment_ctime":1542276619,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542276619","product_id":100017301,"comment_content":"LFU最少使用策略是根据节点访问的次数来判断的：如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小，每次删除的都是访问次数最少的那个；<br>LRU最近最少使用策略是根据时间的纬度来的：如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小，每次删除的都是最后那个没有被访问的","like_count":0},{"had_liked":false,"id":39421,"user_name":"阿U","can_delete":false,"product_type":"c1","uid":1171359,"ip_address":"","ucode":"161A8E74E0D612","user_header":"https://static001.geekbang.org/account/avatar/00/11/df/9f/6e3e1b77.jpg","comment_is_top":false,"comment_ctime":1542272204,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542272204","product_id":100017301,"comment_content":"老哥 没太懂 链表实现lru缓存淘汰策略，文中说的当有一个新的数据被访问什么意思 ，从头遍历链表 那链表里存的是什么数据？ 不是要删除缓存中满了的数据么 这些数据是存在链表中? 为啥要把数据插到链表头部 从头部删?还有为啥越靠近链表尾部的节点越早被访问? 我这全篇看的都还能懂 最后一个算法思路直接给我说懵逼 ","like_count":0},{"had_liked":false,"id":39335,"user_name":"ning~","can_delete":false,"product_type":"c1","uid":1108374,"ip_address":"","ucode":"0ED5894F05BF90","user_header":"https://static001.geekbang.org/account/avatar/00/10/e9/96/38f54972.jpg","comment_is_top":false,"comment_ctime":1542250490,"is_pvip":false,"replies":[{"id":"14110","content":"空间复杂度比较简单 没那么多花样","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542280302,"ip_address":"","comment_id":39335,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542250490","product_id":100017301,"comment_content":"大神，之前讲复杂度时，只详讲了时间复杂度，对于空间复杂度没怎么讲，空间复杂度怎么计算呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429015,"discussion_content":"空间复杂度比较简单 没那么多花样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542280302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":38881,"user_name":"LAMBO","can_delete":false,"product_type":"c1","uid":1214041,"ip_address":"","ucode":"10EDE0FC134FA8","user_header":"https://static001.geekbang.org/account/avatar/00/12/86/59/e8f58a2a.jpg","comment_is_top":false,"comment_ctime":1542156772,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542156772","product_id":100017301,"comment_content":"有个问题不是很明白。<br>数组和链表要增删元素，不都要先找到该元素然后再增删元素吗？<br>数组根据寻址公式O(1)就能找到该元素，增删需要移动元素所以为O(n)。<br>链表想要增删某元素，也要先找到它O(n)，然后增删元素O(1)，根据加法原则不是O(n)吗？为什么说链表增删元素只要O(1)？","like_count":0},{"had_liked":false,"id":38410,"user_name":"我们都是大好青年🙌","can_delete":false,"product_type":"c1","uid":1294094,"ip_address":"","ucode":"E09F8E2F17C996","user_header":"https://static001.geekbang.org/account/avatar/00/13/bf/0e/eae05ad9.jpg","comment_is_top":false,"comment_ctime":1542032324,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542032324","product_id":100017301,"comment_content":"老师您好，我想问下python中链表是如何存在的呢？","like_count":0},{"had_liked":false,"id":38267,"user_name":"aguan(^･ｪ･^)","can_delete":false,"product_type":"c1","uid":1107177,"ip_address":"","ucode":"04833EF2D18E1A","user_header":"https://static001.geekbang.org/account/avatar/00/10/e4/e9/0dd3829f.jpg","comment_is_top":false,"comment_ctime":1542009914,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542009914","product_id":100017301,"comment_content":"思考题思路：<br>1、顺序读取列表内容，得到串str1; 时间复杂度O(n)<br>2、获取反向列表 reverseList （思路：保存前驱pre和后继next两个结点，循环遍历列表，改变当前结点cur.next指针的方向为pre) 此处时间复杂度O(n)，并输出反向列表的内容，得到串str2<br>3、比较str1.equals(str2) 此处时间复杂度为 O(1)<br>最终得出用单向列表存储文符串，判断是否为回文串的时间复杂度为O(n).","like_count":0},{"had_liked":false,"id":38241,"user_name":"Android 技师","can_delete":false,"product_type":"c1","uid":1005842,"ip_address":"","ucode":"F7691906C86655","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/12/2034b163.jpg","comment_is_top":false,"comment_ctime":1541999284,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541999284","product_id":100017301,"comment_content":"如何利用数组实现 LRU 缓存淘汰策略呢？<br><br>使用数组实现一个循环队列，这样可以省去数据搬移的操作，缓存的存入与删除就对应着队列的出队与入队。","like_count":0},{"had_liked":false,"id":38172,"user_name":"cw","can_delete":false,"product_type":"c1","uid":1264296,"ip_address":"","ucode":"82A6B50462F9F9","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/a8/b7e36dd2.jpg","comment_is_top":false,"comment_ctime":1541983300,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541983300","product_id":100017301,"comment_content":"回文串问题：用双向链表数据结构放字符串，每个节点只放一个字符。从头节点往后遍历与尾节点往前便利结果相同","like_count":0},{"had_liked":false,"id":37856,"user_name":"剑影梦残","can_delete":false,"product_type":"c1","uid":1284481,"ip_address":"","ucode":"A5C5DAA49F6996","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/XSnxM4uP67mVu7ZtPxWqUIvFH15pibGt1rFd34EiblN6NFfgKEKBuibLlI1kUjOIfbY56icwBibn6MmXzSEXm7AHicdQ/132","comment_is_top":false,"comment_ctime":1541753234,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541753234","product_id":100017301,"comment_content":"笔记：<br>1.快慢指针定位中间<br>2.逆序前或者后半段，再循环比较，判断回文<br>3.时间跟空间的互换","like_count":0},{"had_liked":false,"id":37376,"user_name":"Geek_41d472","can_delete":false,"product_type":"c1","uid":1247965,"ip_address":"","ucode":"DEC2B6329460CF","user_header":"https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg","comment_is_top":false,"comment_ctime":1541561506,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541561506","product_id":100017301,"comment_content":"回头复习下，之前没做课后思考题，现在补上代码，注释写的比较详细了。希望可以帮助不好理解的同学<br>public class Node&lt;T&gt; {<br>    Node next = null;<br>    T data;<br>    Node(T data){<br>        this.data = data;<br>    }<br>}<br>public static boolean isHuiwen(Node&lt;String&gt; A){<br>    Node&lt;String&gt; fast = A;<br>    Node&lt;String&gt; slow = A;<br>    while(fast.next!=null &amp;&amp; fast.next.next!=null){<br>        fast = fast.next.next;<br>        slow = slow.next;<br>    }<br>    Node&lt;String&gt; head = slow.next;<br>    &#47;&#47;翻转Node过程<br>    Node&lt;String&gt; headNext = null;&#47;&#47;保存当前节点的下一个节点<br>    Node&lt;String&gt; pre = null;&#47;&#47;保存当前节点的前一个节点<br>    while(head!=null){<br>        headNext = head.next;<br>        head.next = pre;&#47;&#47;当前节点的下个节点指向前一个节点<br>        pre = head;&#47;&#47;将当前节点保存起来<br>        head = headNext;&#47;&#47;当前节点向后移动<br>    }<br>    &#47;&#47;对比过程<br>    Node&lt;String&gt; n1 = pre;<br>    Node&lt;String&gt; n2 = A;<br>    while(n1!= null){<br>        if(!n1.data.equals(n2.data)){<br>            return false;<br>        }<br>        n1 = n1.next;<br>        n2 = n2.next;<br>    }<br>    return true;<br>}","like_count":0},{"had_liked":false,"id":37269,"user_name":"What for","can_delete":false,"product_type":"c1","uid":1254381,"ip_address":"","ucode":"1308573CE047B0","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/ed/a4a774a8.jpg","comment_is_top":false,"comment_ctime":1541513568,"is_pvip":false,"replies":[{"id":"13464","content":"也不一定知道长度啊","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541642902,"ip_address":"","comment_id":37269,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541513568","product_id":100017301,"comment_content":"判断一个字符串是不是回文串，为什么要用快慢指针找中点呢，既然给定了字符串，那长度应该是已知的吧？求老师解惑～","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428270,"discussion_content":"也不一定知道长度啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541642902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36658,"user_name":"胡升权","can_delete":false,"product_type":"c1","uid":1282240,"ip_address":"","ucode":"56296865243DA4","user_header":"https://static001.geekbang.org/account/avatar/00/13/90/c0/34af254c.jpg","comment_is_top":false,"comment_ctime":1541221177,"is_pvip":false,"replies":[{"id":"13107","content":"嗯嗯 👌","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541383475,"ip_address":"","comment_id":36658,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541221177","product_id":100017301,"comment_content":"老师，您好，我是一名刚学习数据结构的初学者，老师，有些代码您看能不能给点注释，这样也好让我们这些初学者能够更好的理解","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427959,"discussion_content":"嗯嗯 👌","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541383475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36437,"user_name":"leleba","can_delete":false,"product_type":"c1","uid":1281735,"ip_address":"","ucode":"C868F6ABF509B2","user_header":"https://static001.geekbang.org/account/avatar/00/13/8e/c7/f05f9fd0.jpg","comment_is_top":false,"comment_ctime":1541118288,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541118288","product_id":100017301,"comment_content":"别的同学用快慢指针，用数组空间复杂度是不是O(n)？<br><br>1遍历单链表取数组长度<br>2再遍历单链表拷贝到数组中<br>3用数组对比首尾是不是相等来判断是不是回文<br><br>谢谢老师","like_count":0},{"had_liked":false,"id":36363,"user_name":"吴昊","can_delete":false,"product_type":"c1","uid":1234479,"ip_address":"","ucode":"19780C470D32EF","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/2f/b3090d20.jpg","comment_is_top":false,"comment_ctime":1541059156,"is_pvip":false,"replies":[{"id":"12962","content":"20节中会讲","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541124559,"ip_address":"","comment_id":36363,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541059156","product_id":100017301,"comment_content":"引入hash表将缓存访问的时间复杂度降为O(1)<br>===================================<br>如果是单链表实现的缓存，即使有hash，时间复杂度也不是O(1)吧？<br>不命中缓存的情况下，插入链表头节点的时间复杂度是O(1)，命中缓存的情况下，调整链表节点顺序的时间复杂度是O(n)，因为需要遍历链表找到被命中节点的前节点，才能完成被命中节点前后的拼接工作。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427842,"discussion_content":"20节中会讲","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541124559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36016,"user_name":"张申傲","can_delete":false,"product_type":"c1","uid":1182372,"ip_address":"","ucode":"22D46BC529BA8A","user_header":"https://static001.geekbang.org/account/avatar/00/12/0a/a4/828a431f.jpg","comment_is_top":false,"comment_ctime":1540891829,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1540891829","product_id":100017301,"comment_content":"https:&#47;&#47;leetcode.com&#47;problems&#47;palindrome-linked-list&#47;<br>使用递归，依次判断两头的节点是否相等：<br>class Solution {<br>    private ListNode tmp;<br>    <br>    public boolean isPalindrome(ListNode head) {<br>        tmp = head;        <br>        return check(head);<br>    }<br>    <br>    public boolean check(ListNode node){<br>        if(node == null){<br>            return true;<br>        }<br>        boolean result = check(node.next);<br>        boolean equals = (tmp.val == node.val); <br>        tmp = tmp.next;<br>        return result &amp;&amp; equals;<br>    }<br>}<br>时间复杂度:O(n)<br>空间复杂度:O(1)","like_count":0},{"had_liked":false,"id":35646,"user_name":"allean","can_delete":false,"product_type":"c1","uid":1051470,"ip_address":"","ucode":"A0D2DB4F219EAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/0b/4e/fd946cb2.jpg","comment_is_top":false,"comment_ctime":1540727066,"is_pvip":false,"replies":[{"id":"12669","content":"我不是也是这么讲的吗？","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540739920,"ip_address":"","comment_id":35646,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540727066","product_id":100017301,"comment_content":"有一点疑问：链表的插入删除时间复杂度为O(1)这个应该针对性的讲吧?<br>1.单向链表的插入删除时间复杂度是O(n),<br>2.双向链表的时间复杂度为O(1)","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427612,"discussion_content":"我不是也是这么讲的吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540739920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35589,"user_name":"芒果","can_delete":false,"product_type":"c1","uid":1154458,"ip_address":"","ucode":"08E6D77030CEE8","user_header":"https://static001.geekbang.org/account/avatar/00/11/9d/9a/4cf0e500.jpg","comment_is_top":false,"comment_ctime":1540696054,"is_pvip":false,"replies":[{"id":"12706","content":"head本身是一个节点 你的方法是将数据插到head所指节点的后面","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540777807,"ip_address":"","comment_id":35589,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540696054","product_id":100017301,"comment_content":"打扰一下，请求您帮我解决一下困扰我好几天的困惑(இдஇ; )，在单链表头插中，为什么是newNode.next = head;head = newNode;而不是，newNode.next=head.next;head.next=newNode.真的请你帮忙解答一下，感谢！","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427588,"discussion_content":"head本身是一个节点 你的方法是将数据插到head所指节点的后面","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540777807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35381,"user_name":"太空土豆","can_delete":false,"product_type":"c1","uid":1247622,"ip_address":"","ucode":"636253D0DE1384","user_header":"","comment_is_top":false,"comment_ctime":1540529594,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540529594","product_id":100017301,"comment_content":"最近很忙好久没来。赞一个。数组与链表优缺点分析很到位。","like_count":0},{"had_liked":false,"id":35366,"user_name":"张洋","can_delete":false,"product_type":"c1","uid":1182914,"ip_address":"","ucode":"549BE5DEEF8417","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/c2/bad34a50.jpg","comment_is_top":false,"comment_ctime":1540524993,"is_pvip":true,"replies":[{"id":"12689","content":"没有好坏 实际上循环链表不怎么常用 你知道概念就好了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540740769,"ip_address":"","comment_id":35366,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540524993","product_id":100017301,"comment_content":"老师有一个疑问 循环链表一定比不循环链表好吗  他有什么缺点呢 先对于 不循环的链表","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427521,"discussion_content":"没有好坏 实际上循环链表不怎么常用 你知道概念就好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540740769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35135,"user_name":"msupercoder","can_delete":false,"product_type":"c1","uid":1155151,"ip_address":"","ucode":"0A370CD8820E94","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/4f/33a7e39c.jpg","comment_is_top":false,"comment_ctime":1540433732,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540433732","product_id":100017301,"comment_content":"最少使用策略和最近最少使用策略的区别是什么？为什么觉得老师讲这个应该是最近使用策略？老师讲这个LRU感觉没有“最少”这个属性呀？","like_count":0},{"had_liked":false,"id":34956,"user_name":"alex","can_delete":false,"product_type":"c1","uid":1012579,"ip_address":"","ucode":"2DB95B3815F728","user_header":"https://static001.geekbang.org/account/avatar/00/0f/73/63/f008057a.jpg","comment_is_top":false,"comment_ctime":1540369350,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540369350","product_id":100017301,"comment_content":"        String input = &quot;qwertyuioppoiuytrewq&quot;;<br>        LinkedList&lt;String&gt; l = new LinkedList&lt;String&gt;();<br><br>        for (String b : input.split(&quot;&quot;)) {<br>            l.add(b);<br>        }<br>        if (l.size() % 2 != 0) {<br>            System.out.println(&quot;no&quot;);<br>        }<br>        int mid = l.size() &gt;&gt; 1;<br>        boolean flag = true;<br>        while (mid != 0) {<br>            if (!l.get(mid - 1).equals(l.get(l.size() - (mid - 1) - 1))) {<br>                flag = false;<br>                break;<br>            }<br>            mid--;<br>        }<br><br>        if (flag) System.out.println(&quot;yes&quot;);<br>        else System.out.println(&quot;no&quot;);","like_count":0},{"had_liked":false,"id":34820,"user_name":"Miles Shuai","can_delete":false,"product_type":"c1","uid":1234783,"ip_address":"","ucode":"F15B504C88C97C","user_header":"https://static001.geekbang.org/account/avatar/00/12/d7/5f/428a79e3.jpg","comment_is_top":false,"comment_ctime":1540311310,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540311310","product_id":100017301,"comment_content":"Java实现回文判断<br><br>public class Node&lt;T&gt; {<br>    Node next = null;<br>    T data;<br><br>    Node(T data) {<br>        this.data = data;<br>    }<br>}<br><br>&#47;**<br>     * 用链表校验是否为回文<br>     * @param node<br>     * @return<br>     *&#47;<br>    public static boolean isHuiWen(Node&lt;String&gt; node) {<br>        Node&lt;String&gt; fast = node;<br>        Node&lt;String&gt; slow = node;<br>        while (fast.next != null &amp;&amp; fast.next.next != null) {<br>            fast = fast.next.next;<br>            slow = slow.next;<br>        }<br>        slow = fanZhuanNode(slow);<br>        while (slow.next != null) {<br>            if (slow.data.equalsIgnoreCase(node.data)) {<br>                slow = slow.next;<br>                node = node.next;<br>            } else {<br>                return false;<br>            }<br>        }<br>        return true;<br>    }<br><br>    &#47;**<br>     * 反转链表指针<br>     * @param slow<br>     * @return<br>     *&#47;<br>    public static Node fanZhuanNode(Node&lt;String&gt; slow) {<br>        Node&lt;String&gt; pri = slow;<br>        Node&lt;String&gt; now = slow.next;<br>        while (now != null) {<br>            Node&lt;String&gt; next = now.next;<br>            now.next = pri;<br>            pri = now;<br>            now = next;<br>        }<br>        slow.next = null;<br>        return pri;<br>    }","like_count":0},{"had_liked":false,"id":34683,"user_name":"懒猫","can_delete":false,"product_type":"c1","uid":1206544,"ip_address":"","ucode":"B4B567A11B491D","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/10/275ae749.jpg","comment_is_top":false,"comment_ctime":1540258513,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540258513","product_id":100017301,"comment_content":"为什么需要前一半或后一半反转呢，直接从头结点遍历到中间节点，再从中间节点遍历到尾节点，遍历的时候两两比较，应该就能得出结果吧","like_count":0},{"had_liked":false,"id":34627,"user_name":"小小鹿","can_delete":false,"product_type":"c1","uid":1234101,"ip_address":"","ucode":"7A401F2EE87C67","user_header":"https://static001.geekbang.org/account/avatar/00/12/d4/b5/b72b83f8.jpg","comment_is_top":false,"comment_ctime":1540223993,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540223993","product_id":100017301,"comment_content":"弱弱问一下，java 版本 SinglyLinkedList 里 静态类Node里声明私有对象成员mData 和 mNext 是不是一个语法错误唉？","like_count":0},{"had_liked":false,"id":34626,"user_name":"懒猫","can_delete":false,"product_type":"c1","uid":1206544,"ip_address":"","ucode":"B4B567A11B491D","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/10/275ae749.jpg","comment_is_top":false,"comment_ctime":1540223884,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540223884","product_id":100017301,"comment_content":"我想问，为什么非要反转链表呢，找到中间节点后，头结点往中间遍历，中间往表尾遍历，两个比较，难道不行吗","like_count":0},{"had_liked":false,"id":34002,"user_name":"turbopan","can_delete":false,"product_type":"c1","uid":1132832,"ip_address":"","ucode":"6646BAD4CC959B","user_header":"https://static001.geekbang.org/account/avatar/00/11/49/20/33bca37a.jpg","comment_is_top":false,"comment_ctime":1539945030,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539945030","product_id":100017301,"comment_content":"老师您好，在进行数组的插入删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，您这句话，我用java写了个demo，您说的数组插入是指数组空间不够了，重新开辟了一块内存空间么？为什么会大量的数据搬移呢？删除的话 我也不理解，a{1,2,3,4}，我将a[2]置成null,然后打印a[3]还可以打印出来呢，数据搬移指的是？求解","like_count":0},{"had_liked":false,"id":33888,"user_name":"　　　　　　　　","can_delete":false,"product_type":"c1","uid":1131305,"ip_address":"","ucode":"F914EA5C2FDEDB","user_header":"https://static001.geekbang.org/account/avatar/00/11/43/29/30a132f8.jpg","comment_is_top":false,"comment_ctime":1539915425,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539915425","product_id":100017301,"comment_content":"其实如果讲解的时候配上代码就完美了","like_count":0},{"had_liked":false,"id":33744,"user_name":"张翀","can_delete":false,"product_type":"c1","uid":1241064,"ip_address":"","ucode":"835A01424FDD5E","user_header":"https://static001.geekbang.org/account/avatar/00/12/ef/e8/076a6f59.jpg","comment_is_top":false,"comment_ctime":1539870161,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1539870161","product_id":100017301,"comment_content":"学习了数组与链表的时间复杂度区别，<br>LRU最近最少使用策略实现的缓存，数据结构采用双向链表，数组也能实现同样的功能。<br>回文字符串问题如果采用单向链表解决，可以首先分为前后两半部分两个链表A，B，然后将后半部分B首尾颠倒成B1，再顺序比较A，B1，时间复杂度O(n)","like_count":0},{"had_liked":false,"id":33721,"user_name":"1024","can_delete":false,"product_type":"c1","uid":1086407,"ip_address":"","ucode":"DCC31F6EC54F43","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/c7/86352ccc.jpg","comment_is_top":false,"comment_ctime":1539863056,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539863056","product_id":100017301,"comment_content":"今日所学：<br>单链表、循环链表、双向链表、双向循环链表<br>单链表通过一个指针指向下一个节点的地址。这样存储数据的内存空间可以不连续，不需要分配一整块「大」内存<br>链表适合增删、数组适合随机访问<br>如何选择用哪种链表：时间换空间的思维<br>双向链表访问指定「指针」的效率优于单向链表<br>LRU 最近用的数据存到链表头，删掉链表尾的数据。如果数据在链表中存在，这直接将该数据放到链表头<br>选用链表作为缓存的优势：数据频繁被使用，链表中已经缓存了最近用的，可能头几个节点就是要查找的数据（查找的最好复杂度O(1)，替换节点的复杂度O(1))<br>使用数组做LRU，即使是数组中存在缓存数据，也会造成O(n)移动数据造成的问题<br>","like_count":0},{"had_liked":false,"id":33708,"user_name":"水雕歌","can_delete":false,"product_type":"c1","uid":1199982,"ip_address":"","ucode":"280FAE14574299","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/6e/c8862883.jpg","comment_is_top":false,"comment_ctime":1539859536,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539859536","product_id":100017301,"comment_content":"func isPalindrome(head *Node)  bool {<br>\tvar slowOld *Node = nil<br>\tslow, fast := head, head.next<br>\tif fast == nil {<br>\t\treturn true<br>\t}<br><br>\tvar isEven bool<br>\t&#47;&#47; find middle<br>\tfor true {<br>\t\tif fast.next == nil {<br>\t\t\tisEven = true<br>\t\t\tbreak<br>\t\t}<br>\t\tif fast.next.next == nil {<br>\t\t\tisEven = false<br>\t\t\tbreak<br>\t\t}<br><br>\t\tfast = fast.next.next<br><br>\t\t&#47;&#47; next and reverse<br>\t\ttmp := slow<br>\t\tslow = slow.next<br>\t\ttmp.next = slowOld<br>\t\tslowOld = tmp<br>\t}<br><br>\tvar slowNext *Node<br>\tif isEven {<br>\t\tslowNext = slow.next<br>\t} else {<br>\t\tslowNext = slow.next.next<br>\t}<br><br>\tret := true<br>\tfor true {<br>\t\tif slow.val != slowNext.val {<br>\t\t\tret = false<br>\t\t}<br><br>\t\tif slowNext.next == nil {<br>\t\t\tbreak<br>\t\t}<br><br>\t\tslowNext = slowNext.next<br><br>\t\t&#47;&#47; next and reverse<br>\t\ttmp := slowOld<br>\t\tslowOld = slowOld.next<br>\t\ttmp.next = slow<br>\t\tslow = tmp<br>\t}<br><br>\treturn ret<br>}","like_count":0},{"had_liked":false,"id":33681,"user_name":"Novapath ☀","can_delete":false,"product_type":"c1","uid":1256605,"ip_address":"","ucode":"A65E5AB8B58E1C","user_header":"https://static001.geekbang.org/account/avatar/00/13/2c/9d/e5af3fd4.jpg","comment_is_top":false,"comment_ctime":1539851944,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539851944","product_id":100017301,"comment_content":"一、链表<br>1.链表是一种线性表；<br>2.从内存结构来看，链表的内存结构是不连续的内存空间，通过“指针”把一组零散的内存块串联起来，从而进行数据存储的数据结构；<br>3.链表中的每一个内存块被称为节点N。节点除了存储数据外，还需记录链上的下一个节点的地址，叫作后继指针next。<br><br><br>二、链表的特点<br>1.插入、删除数据效率高，时间复杂度为O(1)，只需更改指针指向即可；随机访问效率低，因为为非连续存储，需要从链头至链尾进行遍历，时间复杂度为O(n)。<br>2.链表数组相比，内存空间消耗更大，因为每个存储数据的节点都需要额外的空间存储后继指针。<br><br>三、常用链表：单链表、循环链表和双向链表<br>3.1 单链表<br>1）每个节点只包含一个指针，即后继指针。<br>2）单链表有两个特殊节点，即首节点和尾节点。头结点记录链表基地址，为节点指向一个空地址NULL。<br>3）性能特点：插入和删除节点的时间复杂度为O(1)，查找的时间复杂度为O(n)。<br><br>3.2 循环链表<br>1）除了尾节点的后继指针指向首节点的地址，其他与均与单链表一致。<br><br>3.3 双向链表<br>1）节点除了存储数据外，还有两个指针分别指向前一个节点地址（前驱指针prev）和下一个节点地址（后继指针next）。<br>2）首节点的前驱指针prev和尾节点的后继指针均指向空地址。<br>3）性能特点：和单链表相比，存储相同的数据，需要消耗更多的存储空间；插入、删除操作比单链表效率更高。<br><br>i. 以删除操作为例，删除操作分为2种情况：删除特定值的节点，删除指针指向的节点。<br>前一种情况，单链表和双向链表都需要从头到尾进行遍历从而找到对应节点进行删除，时间复杂度为O(n)。<br>第二种情况，要进行删除操作必须找到前驱节点，单链表需要从头到尾进行遍历直到p-&gt;next = q，时间复杂度为O(n)，而双向链表可以直接找到前驱节点，时间复杂度为O(1)。<br><br>ii.对于一个有序链表，双向链表的按值查询效率要比单链表更高。可以记录上次查找的位置p，每一次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。<br><br>3.4 双向循环链表：首节点的前驱指针指向尾节点，尾节点的后继指针指向首节点。<br><br>四、链表和数组性能比较<br>4.1 插入、删除和随机访问的时间复杂度<br>数组：插入、删除的时间复杂度是O(n)，随机访问的时间复杂度是O(1)。<br>链表：插入、删除的时间复杂度是O(1)，随机访问的时间复杂度是O(n)。<br><br><br>4.2 数组缺点<br>1）大小固定，声明了一个数组，就回去申请占用连续的内存空间，可能系统没有足够的连续的内存空间分配；<br>2）声明的数组过小，则需要申请更大的内存，把原数组拷贝进去，操作非常的耗时。<br><br>4.3 链表缺点<br>1）内存空间消耗更大，链表需要额外的空间存储指针信息；<br>2）对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片。<br><br>4.4 链表，数组选择<br>1.链表和数组的（增删查）时间复杂度正好相反。<br>2.数组使用连续的内存空间，可以借助缓存机制提高效率；链表不连续，所以无法借助CPU缓存机制。<br>3.数组大小固定，当要申请更大的空间，需要拷贝数据，很耗时；链表则支持动态扩容。<br>4.相对来说链表比较耗内存，因为需要记录节点指针，内存消耗翻倍。<br><br>五、缓存及链表的应用<br>5.1 缓存<br>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等等。<br>5.2 缓存的特点<br>缓存的大小是有限的，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留，这就有一个优先顺序，则需要用到缓存淘汰策略。<br>5.3 缓存淘汰策略<br>常见的三种策略：先进先出策略FIFO（First In，First Out）、最少使用策略LFU（Least Frenquently Used）、最近最少使用策略LRU（Least Recently Used）。<br>5.4 链表实现LRU缓存淘汰算法<br>1.缓存数据在链表中：遍历得到数据对应节点并删除，插入到链表头部，时间复杂度为O(n)。<br>2.缓存数据不在缓存链表中：<br>i.缓存充足，将节点插入链表头部，时间复杂度为O(1)<br>ii.缓存不足，删除链表的尾节点，将新的数据插入链表头部，时间复杂度为O(1)。<br><br>五、设计思想<br>对于执行慢的程序--&gt;空间换时间<br>对于消耗内存多的程序--&gt;时间换空间<br><br>六、课后思考<br>Q.：如何通过单链表实现判断字符串是否为回文字符串？<br>A：倒序输出链表，与原链表进行比较，时间复杂度为O(n)。<br>同学的答案：1 快慢指针定位中间节点 2 从中间节点对后半部分逆序 3 前后半部分比较，判断是否为回文 4 后半部分逆序复原。<br>","like_count":0},{"had_liked":false,"id":33660,"user_name":"涂海生","can_delete":false,"product_type":"c1","uid":1015911,"ip_address":"","ucode":"E3DA62CF9A7745","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/67/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1539847761,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539847761","product_id":100017301,"comment_content":"针对删除给定指针指向的结点， 单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要0(1),这个是指删除耗时吧，找到指定的结点，耗时都要O(n)","like_count":0},{"had_liked":false,"id":33587,"user_name":"耿旭涵gg","can_delete":false,"product_type":"c1","uid":1111448,"ip_address":"","ucode":"6139D066F0CCD8","user_header":"https://static001.geekbang.org/account/avatar/00/10/f5/98/fd56adc4.jpg","comment_is_top":false,"comment_ctime":1539829107,"is_pvip":false,"replies":[{"id":"12090","content":"👌","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539855288,"ip_address":"","comment_id":33587,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539829107","product_id":100017301,"comment_content":"提个意见git代码里最好带一些详细的注释，有的方法都不知道干什么用的，还需要看完了之后才明白 ","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427006,"discussion_content":"👌","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539855288,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33549,"user_name":"万利","can_delete":false,"product_type":"c1","uid":1243194,"ip_address":"","ucode":"F06D7ED8CA60B6","user_header":"https://static001.geekbang.org/account/avatar/00/12/f8/3a/45a21606.jpg","comment_is_top":false,"comment_ctime":1539824316,"is_pvip":false,"replies":[{"id":"12095","content":"没怎么看懂你说的呢","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539856530,"ip_address":"","comment_id":33549,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539824316","product_id":100017301,"comment_content":"有个疑问…实际项目中虽然说，链表插入和删除效率高…其实都是之前要查找的…所以整体复杂度和属于，应该是一样的对么？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426991,"discussion_content":"没怎么看懂你说的呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539856530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33110,"user_name":"何言何语","can_delete":false,"product_type":"c1","uid":1005605,"ip_address":"","ucode":"872D12DA61961F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/58/25/5937fa4d.jpg","comment_is_top":false,"comment_ctime":1539745526,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539745526","product_id":100017301,"comment_content":"确实讲的通俗易懂，之前看别人视频 感觉都是懵的，现在清晰了很多","like_count":0},{"had_liked":false,"id":32732,"user_name":"CrazyGoMan","can_delete":false,"product_type":"c1","uid":1114035,"ip_address":"","ucode":"6B6FA4612B91C3","user_header":"https://static001.geekbang.org/account/avatar/00/10/ff/b3/a236be3c.jpg","comment_is_top":false,"comment_ctime":1539682529,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1539682529","product_id":100017301,"comment_content":"你们好厉害，都知道使用快慢指针的思路来做","like_count":0},{"had_liked":false,"id":32669,"user_name":"vaccywen","can_delete":false,"product_type":"c1","uid":1115128,"ip_address":"","ucode":"077FDB50831921","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/f8/f98df0a7.jpg","comment_is_top":false,"comment_ctime":1539659987,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539659987","product_id":100017301,"comment_content":"redis的linkedlist数据类型就是采用双向链表数据结构实现的，用空间换时间。","like_count":0},{"had_liked":false,"id":32632,"user_name":"小奇","can_delete":false,"product_type":"c1","uid":1256725,"ip_address":"","ucode":"E016D4FE931DCB","user_header":"https://static001.geekbang.org/account/avatar/00/13/2d/15/8ed0ba3f.jpg","comment_is_top":false,"comment_ctime":1539652830,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539652830","product_id":100017301,"comment_content":"留言的很都好厉害👍，文中学习到很多东西，看评论中也长了好多知识","like_count":0},{"had_liked":false,"id":32617,"user_name":"saikida","can_delete":false,"product_type":"c1","uid":1228928,"ip_address":"","ucode":"9D4293CA7C9362","user_header":"https://static001.geekbang.org/account/avatar/00/12/c0/80/0c92e0b8.jpg","comment_is_top":false,"comment_ctime":1539649138,"is_pvip":false,"replies":[{"id":"11949","content":"变量如何访问要看 编译器的设计了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539703326,"ip_address":"","comment_id":32617,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539649138","product_id":100017301,"comment_content":"老师您好，突然想到，我们平常通过变量名来访问内存中的变量值，那么这个访问过程的时间复杂度是O(n)吗？访问变量过程是否跟访问单向链条一样需要遍历查找？谢谢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426838,"discussion_content":"变量如何访问要看 编译器的设计了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539703326,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32503,"user_name":"djane","can_delete":false,"product_type":"c1","uid":1249032,"ip_address":"","ucode":"5315AA246AFDD8","user_header":"","comment_is_top":false,"comment_ctime":1539593290,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539593290","product_id":100017301,"comment_content":"【笔记】<br>缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：先进先出策略 FIFO（First In，First Out）、最少使用策略 （LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used）。<br><br>一、五花八门的链表结构<br>1、链表通过指针将一组零散的内存块串联在一起。把内存块称为链表的“结点”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。<br>把这个记录下个结点地址的指针叫作后继指针 next。<br>把第一个结点叫作头结点，把最后一个结点叫作尾结点。头结点用来记录链表的基地址。<br>2、最常见的链表结构：单链表、双向链表、循环链表、双向循环链表。<br>1）尾结点特殊的地方：指针不是指向下一个结点，而是指向一个空地址 NULL，表示这是链表上最后一个结点。<br>链表的存储空间不是连续的。它并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用。<br>2）双向链表，支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。<br>如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。<br>3）循环链表是一种特殊的单链表。跟单链表唯一的区别就在尾结点。循环链表的尾结点指针是指向链表的头结点。<br>和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的约瑟夫问题。<br>3、用空间换时间的设计思想。<br>当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用时间换空间的设计思路。<br>对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。<br><br>二、链表 VS 数组性能大比拼<br>1、数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。<br>2、数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容。<br>3、如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。<br><br>三、如何基于链表实现 LRU 缓存淘汰算法？<br>我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。<br>1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。<br>2. 如果此数据没有在缓存链表中，又可以分为两种情况：<br>如果此时缓存未满，则将此结点直接插入到链表的头部；<br>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。<br><br><br>【习题】<br>回文字符串：一个正读和反读都一样的字符串，比如“level”或“noon”等。<br>1、遍历字符串，从后往前取值，组成一个新的字符串，比较原字符串和新字符串是否一致。<br>2、遍历字符串，判断字符串从前往后读和从后往前读的值是否一一对应。<br><br>（感觉偏题了，没用到单链表的存储方式。看到评论区回答挺好的，搬运下他思路。不过还是不太清楚具体该怎么实现。）<br>1 快慢指针定位中间节点（这里要区分奇偶情况）<br>1.1 奇数情况，中点位置不需要矫正<br>1.2 偶数情况，使用偶数定位中点策略，要确定是返回上中位数或下中位数<br>1.2.1 如果是返回上中位数，后半部分串头取next<br>1.2.2 如果是返回下中位数，后半部分串头既是当前节点位置，但前半部分串尾要删除掉当前节点<br>2 从中间节点对后半部分逆序，或者将前半部分逆序<br>3 一次循环比较，判断是否为回文<br>4 恢复现场","like_count":0},{"had_liked":false,"id":32420,"user_name":"梅坊帝卿","can_delete":false,"product_type":"c1","uid":1240270,"ip_address":"","ucode":"702F019BA3356C","user_header":"","comment_is_top":false,"comment_ctime":1539567655,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539567655","product_id":100017301,"comment_content":"这个快慢指针的想法真是赞 我的直接想法是来一个栈 这样空间复杂度是o(n) 不如快慢方案的o(1) 另外虽然两者都是同样量级的时间复杂度 但栈的常数系数会小一点 不知理解的对否。","like_count":0},{"had_liked":false,"id":32328,"user_name":"canoejun","can_delete":false,"product_type":"c1","uid":1250222,"ip_address":"","ucode":"EA2246D0F8133E","user_header":"https://static001.geekbang.org/account/avatar/00/13/13/ae/cdd8a129.jpg","comment_is_top":false,"comment_ctime":1539532856,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539532856","product_id":100017301,"comment_content":"不知道这样子思考对不对。采用牺牲空间换取时间。<br>首先采用一个循环双向链表，在循环里，一个从头开始，一个从尾开始，循环条件为遍历的两个指针地址不相等。循环体判断结构体的值是否相等。中间若有不同，退出循环结束，否则就是回文。<br>时间复杂度为o(n) ","like_count":0},{"had_liked":false,"id":32304,"user_name":"子 非 ","can_delete":false,"product_type":"c1","uid":1236439,"ip_address":"","ucode":"BAB9EFE40470EB","user_header":"https://static001.geekbang.org/account/avatar/00/12/dd/d7/8faa8bde.jpg","comment_is_top":false,"comment_ctime":1539519265,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539519265","product_id":100017301,"comment_content":"每次认真读完文章和留言，都受益匪浅","like_count":0},{"had_liked":false,"id":32283,"user_name":"黑桃K","can_delete":false,"product_type":"c1","uid":1234939,"ip_address":"","ucode":"1439F7F46B4982","user_header":"https://static001.geekbang.org/account/avatar/00/12/d7/fb/384ef0a1.jpg","comment_is_top":false,"comment_ctime":1539511713,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539511713","product_id":100017301,"comment_content":"总结：<br>几种链表，单向，双向，循环，双向循环，以及双向体现的，空间换时间思想<br>链表和数组，数组缺点，大小固定，申请过大过小带来的问题，但在cpu缓存读取更快<br>lru缓存淘汰算法，实现思路，头结点表示最新使用的。在链表，放入头，不在，放入头或删除尾放入头<br>思考题：<br>lru数组实现，评论中有队列，有普通实现<br>单链表判断回文，快慢指针，逆序，判断，复位。后续要重新实现下代码到我的github，再消化下这篇","like_count":0},{"had_liked":false,"id":32280,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1539510476,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539510476","product_id":100017301,"comment_content":"，数组和链表的对比，并不能局限于时间复杂度。而且，在实际的软件开发中，不能仅仅利用复杂度分析就决定使用哪个数据结构来存储数据。  除了时间复杂度还有什么因素？","like_count":0},{"had_liked":false,"id":32275,"user_name":"kakasi","can_delete":false,"product_type":"c1","uid":1237297,"ip_address":"","ucode":"64F357E6A08CA5","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/31/eb103bdc.jpg","comment_is_top":false,"comment_ctime":1539509313,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539509313","product_id":100017301,"comment_content":"链表: 线性表数据结构，不连续的存储空间，插入、删除时间复杂度为O（1），而查找为O（n），特点与数组相反。单链表，双向链表，循环链表，双向循环链表，其中单链表和双向链表较常用。<br><br>其实链表的插入、删除真正意义上并不是O（1）。一般有两种情况: 1. 删除「与给定值相等的值」。这个时候无论是单链表还是双向链表都要用O（n）来查找，然后再删除。2. 删除「给定结点」，这个时候单链表要重新查找到这个节点的前结点然后执行删除，而双向链表直接可以拿到前结点，是真正意义的O（1）。因此实际运用中还是双向链表最多，不过这个是采用了空间换时间的方式，一般来说空换时或时换空都是视情况而定的。<br><br>LRU缓存算法（最近最少使用）: <br>1. 用链表实现方式。当数据已经在链表中时，将那个数据移到头部；当数据不存在，如果缓存链表没满直接添加到头部，如果满了就删除最后一个结点然后添加到头部。<br>2. 数组实现方式: 当数据已经在数组中时，将那个数据移到数组尾部；当数据不存在，如果缓存数组没满直接添加到尾部，如果满了就删除第一个元素，然后添加到尾部。<br>3. 散列表方式等待老师的讲解。<br><br>单链表实现回文姑且记录下: 用快慢指针找到中点，前半部分逆序，直接对比两部分。","like_count":0},{"had_liked":false,"id":32196,"user_name":"kakasi","can_delete":false,"product_type":"c1","uid":1237297,"ip_address":"","ucode":"64F357E6A08CA5","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/31/eb103bdc.jpg","comment_is_top":false,"comment_ctime":1539481956,"is_pvip":false,"replies":[{"id":"11751","content":"leetcode上有的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539528529,"ip_address":"","comment_id":32196,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539481956","product_id":100017301,"comment_content":"老师，虽说知道阅读，输出，实战是整个学习的方法，但是实战方面能给出一道对应的编程题吗？看完之后花个20来分钟的题能巩固知识，感觉这些题目不好找。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426676,"discussion_content":"leetcode上有的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539528529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32163,"user_name":"qinggeouye","can_delete":false,"product_type":"c1","uid":1251536,"ip_address":"","ucode":"5B53EEDD7BEC9C","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/d0/49b06424.jpg","comment_is_top":false,"comment_ctime":1539448755,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539448755","product_id":100017301,"comment_content":"一、利用数组实现 LRU 缓存淘汰策略<br><br>利用数组实现 LRU 缓存淘汰策略：<br><br>维护一个有序数组，越靠近数组尾部元素是越早之前访问的。当有一个新数据被访问，从数组起始位置开始遍历数组：<br><br>1、如果该数据之前已经被缓存在数组中，则遍历数组得到该数据对应的位置，并将其从原来的位置删除，将这个位置前面的数组元素依次向后搬移一位，再把这个数据插入到数组的第一个位置。<br><br>2、如果该数据没有在缓存数组中：<br><br>- 若缓存未满，则将数组元素依次向后搬移一位，把这个数据插入到数组的第一个位置<br>- 若缓存已满，则删除数组中最后一个元素，搬移数组元素，插入新数据到数组的第一个位置。<br><br><br>二、如何判断一个字符串是否是回文字符串<br><br>问：字符串通过单链表存储，如何判断字符串是一个回文串？<br><br>1、定义两个指针：快指针 fast、慢指针 slow。<br><br>2、每次，快指针前进两步即 fast.next.next ，慢指针前进一步即 slow.next ；<br><br>3、慢指针每前进一步，取得到达链表结点的 next 指针，同时改变到达链表结点的 next 指针的指向，使链表前半部分反序；<br><br>4、快指针到达链表尾结点时，慢指针即到达链表中间结点，此时再定义一个新指针从链表中间结点往回走，而慢指针继续向后走，但不改变链表后半部分结点中next指针的指向；<br><br>5、新指针与慢指针每前进一步，比较它们所指向的值，判断是否相等；同时，新指针每前进一步，改变到达链表结点的 next 指针的指向，使链表前半部分再次反序；<br><br>如有不正确，还请老师指正，谢谢~","like_count":0},{"had_liked":false,"id":32157,"user_name":"gesanri","can_delete":false,"product_type":"c1","uid":1121174,"ip_address":"","ucode":"AE3B97DC3ED668","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELtOO0HKrj5SI5JSlmwiaCvaF6GLiaTmf5NX88OZaO3HymTAGTeIoicBUjqzmMF6sF5raPFjuqLFibrrw/132","comment_is_top":false,"comment_ctime":1539442581,"is_pvip":false,"replies":[{"id":"11761","content":"关注的点有点跑偏了，不管是哪个节点，prev和next都是指向结点，既不是data也不是prev&#47;next","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539529060,"ip_address":"","comment_id":32157,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539442581","product_id":100017301,"comment_content":"关于双向循环链表那个手画的图有点没明白，中间的节点都是前面节点的next指向后面节点的prev，后面节点的prev指向前面节点的next，但首尾节点的prev和next却指向的是对方的data，不太明白这里首尾节点的特殊性","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426656,"discussion_content":"关注的点有点跑偏了，不管是哪个节点，prev和next都是指向结点，既不是data也不是prev/next","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539529060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32094,"user_name":"空白","can_delete":false,"product_type":"c1","uid":1234555,"ip_address":"","ucode":"675643BCCA7F32","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/7b/7035a4f7.jpg","comment_is_top":false,"comment_ctime":1539413225,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539413225","product_id":100017301,"comment_content":"最上面的大佬说的东西,怎么看着很像计算机组成原理 里面的存储的部分。 不是很明白的可以看一看计算机原理哦","like_count":0},{"had_liked":false,"id":31988,"user_name":"鹏程万里","can_delete":false,"product_type":"c1","uid":1114675,"ip_address":"","ucode":"5E23BBEC9E8209","user_header":"https://static001.geekbang.org/account/avatar/00/11/02/33/57678ea3.jpg","comment_is_top":false,"comment_ctime":1539350656,"is_pvip":false,"replies":[{"id":"11593","content":"头结点为啥没意义呢？好像你理解的跟我理解的有点不一致。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539401602,"ip_address":"","comment_id":31988,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539350656","product_id":100017301,"comment_content":"文中的头结点是不是有歧义？真正的头结点是没有意义，也不存放数据的，文章图中应该指的是第一个元素结点吧？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426597,"discussion_content":"头结点为啥没意义呢？好像你理解的跟我理解的有点不一致。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539401602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31968,"user_name":"feifei","can_delete":false,"product_type":"c1","uid":1105431,"ip_address":"","ucode":"B1F8AE3AD82C51","user_header":"https://static001.geekbang.org/account/avatar/00/10/de/17/75e2b624.jpg","comment_is_top":false,"comment_ctime":1539345113,"is_pvip":false,"replies":[{"id":"11588","content":"你的思路的时间、空间复杂度都有点高，你再想想有改进方法吗","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539401532,"ip_address":"","comment_id":31968,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539345113","product_id":100017301,"comment_content":"使用单链表来判断是否为回文串，我的思路是这样子的<br>遍历，从链表的尾部移除字符串，然后还有一个索引从链表头开始读取，再进行比较，<br>如果发现首尾不相等，则直接判断返回false<br>一直到遍历结束，都能相等，则说明为回文串<br><br>我的这个实现代码，由于是单链表，未经优化，时间复杂度为O(N*N),但空间复杂度占用为O(N),即字符串点用链表的空间，<br>以下是我实现的回文串判断代码，<br>https:&#47;&#47;github.com&#47;kkzfl22&#47;datastruct&#47;blob&#47;master&#47;src&#47;test&#47;java&#47;com&#47;liujun&#47;datastruct&#47;linkedlist&#47;StrCheck.java<br>其他为自己实现的单链表的代码<br><br>希望得到老师您的指正，谢谢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426585,"discussion_content":"你的思路的时间、空间复杂度都有点高，你再想想有改进方法吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539401532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31942,"user_name":"曾经瘦过","can_delete":false,"product_type":"c1","uid":1240106,"ip_address":"","ucode":"57C32575A1C1FD","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/2a/b11d5ad8.jpg","comment_is_top":false,"comment_ctime":1539335716,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539335716","product_id":100017301,"comment_content":"数组实现LRU 思路 <br>1.创建一个数组 <br>2.再插入数据时候查找数组中是否存在该数据，如果存在将该数据和数组0下标的数据进行兑换<br>3.如果不存在则在数组头部插入数据（头部数据替换到空余数组位置）<br>4.如果数组满了，并且数组中不存在删除数组尾部数据，在数组头部插入<br><br>感觉可能实现起来有点麻烦，暂时的一个思路，也可以通过数组+指针的方式实现","like_count":0},{"had_liked":false,"id":31817,"user_name":"黑boy","can_delete":false,"product_type":"c1","uid":1109144,"ip_address":"","ucode":"9CD3C498A6E1D0","user_header":"https://static001.geekbang.org/account/avatar/00/10/ec/98/e8ebdec7.jpg","comment_is_top":false,"comment_ctime":1539306785,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1539306785","product_id":100017301,"comment_content":"之前面试被问到链表的随机访问问题，我回答的也是散列，嘻嘻。","like_count":0,"discussions":[{"author":{"id":1246664,"avatar":"https://static001.geekbang.org/account/avatar/00/13/05/c8/2f849dfb.jpg","nickname":"山顶的洞","note":"","ucode":"D3E9E928A3FA62","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574,"discussion_content":"怎么散列？链表是无序的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561713555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31710,"user_name":"saikida","can_delete":false,"product_type":"c1","uid":1228928,"ip_address":"","ucode":"9D4293CA7C9362","user_header":"https://static001.geekbang.org/account/avatar/00/12/c0/80/0c92e0b8.jpg","comment_is_top":false,"comment_ctime":1539268631,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539268631","product_id":100017301,"comment_content":"评论比正文还精彩👍","like_count":0},{"had_liked":false,"id":31687,"user_name":"Tattoo","can_delete":false,"product_type":"c1","uid":1036503,"ip_address":"","ucode":"CE926AC8582C96","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d0/d7/a09ef784.jpg","comment_is_top":false,"comment_ctime":1539264965,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1539264965","product_id":100017301,"comment_content":"LRU 的淘汰规则是基于访问时间，而 LFU 是基于访问次数的 。所以作者說的是正確的．","like_count":0},{"had_liked":false,"id":31567,"user_name":"芒果","can_delete":false,"product_type":"c1","uid":1154458,"ip_address":"","ucode":"08E6D77030CEE8","user_header":"https://static001.geekbang.org/account/avatar/00/11/9d/9a/4cf0e500.jpg","comment_is_top":false,"comment_ctime":1539232821,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539232821","product_id":100017301,"comment_content":"数组和链表各有利弊，它们插入、删除与随机访问操作的时间复杂度正好相反，链表支持动态扩容，这也是它与数组最大的区别。","like_count":0},{"had_liked":false,"id":31404,"user_name":"范特西","can_delete":false,"product_type":"c1","uid":1213367,"ip_address":"","ucode":"E16372285CB6BB","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/b7/971a00c7.jpg","comment_is_top":false,"comment_ctime":1539173407,"is_pvip":false,"replies":[{"id":"11437","content":"算是个思路 不过空间复杂度高了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539270141,"ip_address":"","comment_id":31404,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539173407","product_id":100017301,"comment_content":"单链表判断回文：思路(比较low,😂)<br>遍历组装两个<br>While<br>   String1=string1+value<br>   String2=value+string2<br>最终判断两字符串是否相同。<br>时间复杂度O(n)<br>空间复杂度O(n)<br>Ps:如错误，望老师指正🤣<br><br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426325,"discussion_content":"算是个思路 不过空间复杂度高了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539270141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31359,"user_name":"宗子豪","can_delete":false,"product_type":"c1","uid":1237400,"ip_address":"","ucode":"7EA03DF1151206","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/98/c99c6d36.jpg","comment_is_top":false,"comment_ctime":1539159215,"is_pvip":false,"replies":[{"id":"11312","content":"不一定 也可以存数据的。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539222563,"ip_address":"","comment_id":31359,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539159215","product_id":100017301,"comment_content":"单链表的头结点一定是没有数据的吗?","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426306,"discussion_content":"不一定 也可以存数据的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539222563,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31336,"user_name":"王爷","can_delete":false,"product_type":"c1","uid":1037307,"ip_address":"","ucode":"818AF28E274539","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d3/fb/da4aeff8.jpg","comment_is_top":false,"comment_ctime":1539153984,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539153984","product_id":100017301,"comment_content":"思考题根据大神留言整理的思路：找到链表“中间位置”，中间之前的反转放在一个新链表中，然后和中间位置后的链表数据比较是否相等。go 实现如下，时间复杂度O(n)<br>&#47;**<br>单向链表结构<br>*&#47;<br>type Link struct {<br>\tvalue string<br>\tnext  *Link &#47;&#47;下一个节点<br>}<br>&#47;**<br>链表集合<br>*&#47;<br>type LinkList struct {<br>\tnode  *Link<br>\tcount int<br>}<br>&#47;**<br>链表中添加一个元素，新插入的再链表尾部<br>*&#47;<br>func (l *LinkList) Add(value string) {<br>\tn := Link{}<br>\tn.value = value<br>\tif l.node == nil {<br>\t\tl.node = &amp;n<br>\t} else {<br>\t\tnode := l.node<br>\t\tfor {<br>\t\t\tif node.next == nil {<br>\t\t\t\tbreak<br>\t\t\t} else {<br>\t\t\t\tnode = node.next<br>\t\t\t}<br>\t\t}<br>\t\tnode.next = &amp;n<br>\t}<br>\tl.count = l.count + 1<br>}<br>&#47;**<br>链表中添加一个元素，新插入的在链表头<br>*&#47;<br>func (l *LinkList) Enqueue(value string) {<br>\tn := Link{}<br>\tn.value = value<br>\tif l.node == nil {<br>\t\tl.node = &amp;n<br>\t} else {<br>\t\tnode := l.node<br>\t\tn.next = node<br>\t\tl.node = &amp;n<br>\t}<br>\tl.count = l.count + 1<br>}<br>&#47;**<br>判断存储的是否是回文字符串<br>*&#47;<br>func (l *LinkList) IsPadlindrome() bool {<br>\tboolean := false<br>\tcurrent := l.node<br>\tif l.count == 0 {<br>\t\treturn false<br>\t} else if l.count == 1 {<br>\t\treturn true<br>\t} else if l.count == 2 {<br>\t\treturn current.value == current.next.value<br>\t} else {<br>\t\t&#47;&#47;找到链表“中间位置”<br>\t\tp := 1<br>\t\t&#47;&#47;“中间位置”之后的节点<br>\t\tvar rightLink *Link<br>\t\t&#47;&#47;“中间位置”之前的元素要逆序放入新链表中<br>\t\tvar leftlink = LinkList{}<br>\t\t&#47;&#47;参考留言中的快进慢进法<br>\t\tfor {<br>\t\t\tleftlink.Enqueue(current.value)<br>\t\t\tcurrent = current.next<br>\t\t\trightLink = current<br>\t\t\tp = p + 2<br>\t\t\tif p == l.count {<br>\t\t\t\t&#47;&#47;长度是奇数，中间节点的元素不参与比较，直接从中间节点的下一个节点开始<br>\t\t\t\trightLink = rightLink.next<br>\t\t\t\tbreak<br>\t\t\t} else if p &gt; l.count {<br>\t\t\t\tbreak<br>\t\t\t}<br>\t\t}<br>\t\t&#47;&#47;比较两个链表中的值是否相等<br>\t\tvar l1 = leftlink.node<br>\t\tvar l2 = rightLink<br>\t\tfor {<br>\t\t\tif l1 == nil {<br>\t\t\t\tbreak<br>\t\t\t} else {<br>\t\t\t\tif l1.value == l2.value {<br>\t\t\t\t\tl1 = l1.next<br>\t\t\t\t\tl2 = l2.next<br>\t\t\t\t\tboolean = true<br>\t\t\t\t} else {<br>\t\t\t\t\tboolean = false<br>\t\t\t\t\tbreak<br>\t\t\t\t}<br>\t\t\t}<br>\t\t}<br>\t}<br>\treturn boolean<br>}<br>func main() {<br>\tlist := LinkList{}<br>\tlist.Add(&quot;5&quot;)<br>\tlist.Add(&quot;0&quot;)<br>\tlist.Add(&quot;1&quot;)<br>\tlist.Add(&quot;1&quot;)<br>\tlist.Add(&quot;0&quot;)<br>\tlist.Add(&quot;5&quot;)<br>\tfmt.Println(list)<br>\tfmt.Println(list.IsPadlindrome())<br>}","like_count":0},{"had_liked":false,"id":31296,"user_name":"꧁꫞꯭高꯭峰꯭꫞꧂","can_delete":false,"product_type":"c1","uid":1235060,"ip_address":"","ucode":"27A29D5F949A0B","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/74/399c5d99.jpg","comment_is_top":false,"comment_ctime":1539144156,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539144156","product_id":100017301,"comment_content":"public static boolean isBackWord(String str) {<br>\t\tboolean flag = true;<br>\t\tString[] arrs = str.split(&quot;&quot;);<br>\t\tint len = arrs.length;<br>\t\tif (str.length() % 2 != 0) {<br>\t\t\tfor (int i = 0; i &lt; len; i++) {<br>\t\t\t\tif (!arrs[i].equals(arrs[len - 1 - i])) {<br>\t\t\t\t\tflag = false;<br>\t\t\t\t\tbreak;<br>\t\t\t\t}<br>\t\t\t}<br>\t\t} else {<br>\t\t\tflag = false;<br>\t\t}<br><br>\t\treturn flag;<br>\t}<br>时间复杂度O(n&#47;2);","like_count":0},{"had_liked":false,"id":31271,"user_name":"木子皿","can_delete":false,"product_type":"c1","uid":1242778,"ip_address":"","ucode":"3FDEAFABB4C427","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJUzv6S9wroyXaoFIwvC1mdDiav4BVS4BbPTuwtvWibthL5PyMuxFNicY06QJMZicVpib7E88S19nH4I9Q/132","comment_is_top":false,"comment_ctime":1539140825,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539140825","product_id":100017301,"comment_content":"关于如何用数组实现LRU写了一篇博客：https:&#47;&#47;blog.csdn.net&#47;SlowIsFastLemon&#47;article&#47;details&#47;82985685","like_count":0},{"had_liked":false,"id":31130,"user_name":"双","can_delete":false,"product_type":"c1","uid":1031605,"ip_address":"","ucode":"D0AC0A69A611C8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bd/b5/b8dfa30a.jpg","comment_is_top":false,"comment_ctime":1539098367,"is_pvip":false,"replies":[{"id":"11236","content":"不是。但是那是因为java语言本身的特性 数组中存储的是对象的地址 并非对象本身 虽然对象是非连续的 没法利用cpu缓存 但地址在数组中是连续存储的 可以利用cpu缓存。你也可以去看下c语言 处理方式就跟java不一样","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539136669,"ip_address":"","comment_id":31130,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539098367","product_id":100017301,"comment_content":"对于cpu对数组的缓存问题，高级语言如java，生成一个对象数组，数组里面保存了大对象，这个时候和cpu缓存就没关系了吧？这些大对象数组读到cpu的cache中还是连续的吗","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426242,"discussion_content":"不是。但是那是因为java语言本身的特性 数组中存储的是对象的地址 并非对象本身 虽然对象是非连续的 没法利用cpu缓存 但地址在数组中是连续存储的 可以利用cpu缓存。你也可以去看下c语言 处理方式就跟java不一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539136669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31086,"user_name":"weirdo","can_delete":false,"product_type":"c1","uid":1138593,"ip_address":"","ucode":"BC6E7D7DAAC485","user_header":"https://static001.geekbang.org/account/avatar/00/11/5f/a1/8f91ec43.jpg","comment_is_top":false,"comment_ctime":1539085831,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539085831","product_id":100017301,"comment_content":"请问回文串一定得是奇数吗？ 如果偶数也可以的话 那用快慢指针法怎么才能到中点呢？偶数长度的字符串中点没有元素 该怎么处理呢？","like_count":0},{"had_liked":false,"id":31010,"user_name":"园园","can_delete":false,"product_type":"c1","uid":1257028,"ip_address":"","ucode":"2A34FD1FC31042","user_header":"https://static001.geekbang.org/account/avatar/00/13/2e/44/b6f5b1fd.jpg","comment_is_top":false,"comment_ctime":1539065398,"is_pvip":false,"replies":[{"id":"11174","content":"这个不好说 你可以直接存要缓存的对象 也可以存对象的地址 比如指针或者引用","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539082942,"ip_address":"","comment_id":31010,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539065398","product_id":100017301,"comment_content":"用链表实现LRU，那么链表中的节点存的是什么数据呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426180,"discussion_content":"这个不好说 你可以直接存要缓存的对象 也可以存对象的地址 比如指针或者引用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539082942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30966,"user_name":"张洋","can_delete":false,"product_type":"c1","uid":1182914,"ip_address":"","ucode":"549BE5DEEF8417","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/c2/bad34a50.jpg","comment_is_top":false,"comment_ctime":1539054216,"is_pvip":true,"replies":[{"id":"11176","content":"哦哦哦 应该需要另一个指针来存储 文章里描述的不清楚","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539083095,"ip_address":"","comment_id":30966,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539054216","product_id":100017301,"comment_content":"老师您好 我刚才问的那个的问题意思就是。单双向链表的基地址存储的位置分别在头节点的那个位置。     ","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426160,"discussion_content":"哦哦哦 应该需要另一个指针来存储 文章里描述的不清楚","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539083095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30960,"user_name":"IT蛇精病","can_delete":false,"product_type":"c1","uid":1199110,"ip_address":"","ucode":"36C6BC72412C2D","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/06/634b7db7.jpg","comment_is_top":false,"comment_ctime":1539053252,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539053252","product_id":100017301,"comment_content":"LRU就是淘汰算法，在计算机的高速缓存中有具体实现。在之前已接触过这方面的问题。基于局部性原则，时间局部性和空间局部性，时间局部性说的是一个数据被访问，那么在一定时间内可能会被频繁访问，空间局部性说的是一个数据被访问到，那么附近的空间在一段时间内也会可能频繁被访问。","like_count":0},{"had_liked":false,"id":30944,"user_name":"一棵开花的树","can_delete":false,"product_type":"c1","uid":1254814,"ip_address":"","ucode":"01688DC32E4F8B","user_header":"https://static001.geekbang.org/account/avatar/00/13/25/9e/69b65b6f.jpg","comment_is_top":false,"comment_ctime":1539050943,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539050943","product_id":100017301,"comment_content":"总结的一篇博客，用python实现的，仅供参考：https:&#47;&#47;blog.csdn.net&#47;phyllisyuell&#47;article&#47;details&#47;82974345","like_count":0},{"had_liked":false,"id":30938,"user_name":"Stephan.Wang","can_delete":false,"product_type":"c1","uid":1245646,"ip_address":"","ucode":"74D59479FD9438","user_header":"https://static001.geekbang.org/account/avatar/00/13/01/ce/4bd67683.jpg","comment_is_top":false,"comment_ctime":1539050210,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539050210","product_id":100017301,"comment_content":"如何判断回文字符串。<br>读首节点和尾节点，两种情况<br>1.相等 --&gt; 删除首尾节点，继续读下一组首尾节点<br>2.不想等 --&gt; 判断不是回文字符串<br><br>一直读到单链表长度为1","like_count":0},{"had_liked":false,"id":30909,"user_name":"Marnie","can_delete":false,"product_type":"c1","uid":1001912,"ip_address":"","ucode":"ECF9B22574F868","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/b8/fb19aa6a.jpg","comment_is_top":false,"comment_ctime":1539046436,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539046436","product_id":100017301,"comment_content":"链表与数组的最大区别是，链表支持动态扩容，数组不支持。","like_count":0},{"had_liked":false,"id":30899,"user_name":"张洋","can_delete":false,"product_type":"c1","uid":1182914,"ip_address":"","ucode":"549BE5DEEF8417","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/c2/bad34a50.jpg","comment_is_top":false,"comment_ctime":1539045298,"is_pvip":true,"replies":[{"id":"11093","content":"没太看懂您说的 不好意思 能重新表述一下吗","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539048683,"ip_address":"","comment_id":30899,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1539045298","product_id":100017301,"comment_content":"双向链表的地址存在的是 头结点的前驱指针上吗？<br>单向链表的地址存的是头结点的data区吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426139,"discussion_content":"没太看懂您说的 不好意思 能重新表述一下吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539048683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1064752,"avatar":"","nickname":"码农翻身的小粉丝","note":"","ucode":"1FB018F749CE84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309123,"discussion_content":"单向链表是当前节点只存了业务数据和后一个节点的内存地址，双向链表是存了业务数据和前一个以及后一个节点的内存地址","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601193117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30861,"user_name":"大坏蛋","can_delete":false,"product_type":"c1","uid":1240376,"ip_address":"","ucode":"E5728F85273D14","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/38/217ecccb.jpg","comment_is_top":false,"comment_ctime":1539014132,"is_pvip":false,"replies":[{"id":"11108","content":"不用呢 gc是分析可达性 分析的是指向这个节点的 而不是这个节点指向的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539050179,"ip_address":"","comment_id":30861,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539014132","product_id":100017301,"comment_content":"请教老师和留言区大佬：https:&#47;&#47;github.com&#47;wangzheng0822&#47;algo老师的Java版链表demo中，删除结点，是否需要将被删除结点next引用指向null？以便GC时可以及时清理。谢谢解答！","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426119,"discussion_content":"不用呢 gc是分析可达性 分析的是指向这个节点的 而不是这个节点指向的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539050179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30828,"user_name":"徐","can_delete":false,"product_type":"c1","uid":1149095,"ip_address":"","ucode":"04D99F991ECE2D","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/a7/cd469379.jpg","comment_is_top":false,"comment_ctime":1539006488,"is_pvip":false,"replies":[{"id":"11182","content":"不啊 偶数的话大概处理思路是一样的 只会有很小的区别","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539083932,"ip_address":"","comment_id":30828,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539006488","product_id":100017301,"comment_content":"老师， 看很多人提到用快慢指针找中点， 如果是奇数链表我能理解， 如果是偶数的回文串，怎么处理呢？ 是不是快慢指针只能用于奇数链表里？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426112,"discussion_content":"不啊 偶数的话大概处理思路是一样的 只会有很小的区别","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539083932,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30808,"user_name":"惜纸","can_delete":false,"product_type":"c1","uid":1246253,"ip_address":"","ucode":"F727724F091898","user_header":"https://static001.geekbang.org/account/avatar/00/13/04/2d/15d254d4.jpg","comment_is_top":false,"comment_ctime":1539001074,"is_pvip":false,"replies":[{"id":"11070","content":"先进后出 和后进先出不是一个意思吗","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539003381,"ip_address":"","comment_id":30808,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539001074","product_id":100017301,"comment_content":"老师你好，后进先出应该使用哪种算法？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426105,"discussion_content":"先进后出 和后进先出不是一个意思吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539003381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30807,"user_name":"Durian","can_delete":false,"product_type":"c1","uid":1240859,"ip_address":"","ucode":"22C66AEF8F7E49","user_header":"https://static001.geekbang.org/account/avatar/00/12/ef/1b/b2be3e68.jpg","comment_is_top":false,"comment_ctime":1539000489,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539000489","product_id":100017301,"comment_content":"单链表存字符串 并且判断该字符串是否是回文<br>创建第二个单链表为该链表的转置 如果该单链表的字符串是回文的话，那么转置后的单链表每个值都跟原单链表相等。如果不相等，则就不是回文<br>第一步，转置单链表<br>第二步，循环判断值是否相等<br>时间复杂度为O(n)<br>空间复杂度为O(n)","like_count":0},{"had_liked":false,"id":30771,"user_name":"千方残光","can_delete":false,"product_type":"c1","uid":1248463,"ip_address":"","ucode":"BD22169CFA307F","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/cf/3586a7e5.jpg","comment_is_top":false,"comment_ctime":1538993559,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538993559","product_id":100017301,"comment_content":"public class Plalindrome {<br>\tpublic static void main(String[] args) {<br>\t\ttest(&quot;&quot;);<br>\t\ttest(&quot;1&quot;);<br>\t\ttest(&quot;123&quot;);<br>\t\ttest(&quot;123432&quot;);<br>\t\ttest(&quot;123321&quot;);<br>\t\ttest(&quot;1234321&quot;);<br>\t}<br>\t<br>\tstatic void test(String s) {<br>\t\tboolean isPlalindrome = isPlalindrome(getNodeHeadFromString(s));<br>\t\tSystem.out.println(s + &quot; is plalindrome ? &quot; + isPlalindrome);<br>\t\tSystem.out.println();<br>\t}<br>\t<br>\tstatic boolean isPlalindrome(Node head) {<br>\t\tSystem.out.print(&quot;before convert is:&quot;);<br>\t\tprint(head);<br>\t\t<br>\t\tif(head == null || head.next == null) {<br>\t\t\treturn true;<br>\t\t}<br>\t\t<br>\t\tNode slow = head;<br>\t\tNode fast = head;<br>\t\twhile(fast.next != null &amp;&amp; fast.next.next != null) {<br>\t\t\tslow = slow.next;<br>\t\t\tfast = fast.next.next;<br>\t\t}<br>\t\t<br>\t\tNode afterHead = slow.next;<br>\t\t&#47;&#47;反转后半部分<br>\t\tafterHead = converse(afterHead);<br>\t\t<br>\t\tboolean result = true;<br>\t\tfor(<br>\t\t\tNode beforeCur = head, afterCur = afterHead;<br>\t\t\tbeforeCur != null &amp;&amp; afterCur != null;<br>\t\t\tbeforeCur = beforeCur.next, afterCur = afterCur.next<br>\t\t\t) {\t\t\t<br>\t\t\tif(beforeCur.c != afterCur.c) {<br>\t\t\t\tresult = false;<br>\t\t\t\tbreak;<br>\t\t\t}<br>\t\t}<br>\t\t&#47;&#47;反转的部分恢复<br>\t\tslow.next = converse(afterHead);<br><br>\t\tSystem.out.print(&quot;after convert is:&quot;);<br>\t\tprint(head);<br>\t\treturn result;<br>\t}<br>\t<br>\tstatic Node converse(Node head) {<br>\t\tif(head == null || head.next == null) {<br>\t\t\treturn head;<br>\t\t}<br>\t\tNode prev = null;<br>\t\tNode cur = head;<br>\t\tNode next = head.next;<br>\t\t<br>\t\twhile(next != null) {<br>\t\t\tcur.next = prev;<br>\t\t\tprev = cur;<br>\t\t\tcur = next;<br>\t\t\tnext = cur.next;<br>\t\t}<br>\t\tcur.next = prev;<br>\t\treturn cur;<br>\t}<br>\t<br>\tstatic void print(Node head) {<br>\t\tfor(; head != null; head = head.next) {<br>\t\t\tSystem.out.print(head.c);<br>\t\t}<br>\t\tSystem.out.println();<br>\t}<br>\t<br>\tstatic Node getNodeHeadFromString(String s) {<br>\t\tNode head = null;<br>\t\tif(null == s || &quot;&quot;.equals(s)) {<br>\t\t\treturn head;<br>\t\t}<br>\t\thead = new Node(s.charAt(0));<br>\t\tNode prev = head;<br>\t\tfor(int i = 1; i &lt; s.length(); i++) {<br>\t\t\tNode cur = new Node(s.charAt(i));<br>\t\t\tprev.next = cur;<br>\t\t\tprev = cur;<br>\t\t}<br>\t\tprev.next = null;\t\t<br>\t\treturn head;<br>\t}<br>\t<br>\tstatic class Node {<br>\t\tchar c;<br>\t\tNode next;<br>\t\tNode(char c) {<br>\t\t\tthis.c = c;<br>\t\t}<br>\t}<br>}","like_count":0},{"had_liked":false,"id":30751,"user_name":"SODA-M","can_delete":false,"product_type":"c1","uid":1246727,"ip_address":"","ucode":"E1F84A195827C6","user_header":"","comment_is_top":false,"comment_ctime":1538988468,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538988468","product_id":100017301,"comment_content":"看到评论里面有朋友说水仙花串，如果按照对水仙花数的理解，回文串和水仙花字串好像没什么关系吧，有点困惑。不过如果所提到的解法是一种判断回文的方式","like_count":0},{"had_liked":false,"id":30699,"user_name":"Alan","can_delete":false,"product_type":"c1","uid":1243563,"ip_address":"","ucode":"EF3B6A90054B34","user_header":"https://static001.geekbang.org/account/avatar/00/12/f9/ab/374fe105.jpg","comment_is_top":false,"comment_ctime":1538978550,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538978550","product_id":100017301,"comment_content":"回复：myj：<br>您好，请问双向循环链表的最后一个节点的next指针为什么不是指向第一个节点的prev，而是指向了它的data部分，同样的，第一个节点的prev也指向了最后一个节点的data部分而不是它的next，这个图中prev的指向您是希望表达指向next指针呢？还是想表达指向整个节点对象呢？<br>---------------<br>链表中的每个节点（包括数据域，指针域）为一个整体，指针域中每个指针保存的是当前节点的上一个、下一个或更多节点的内存地址值，利用保存有地址值的指针可以定位到该地址所在的节点。因此图中箭头指向的是节点整体，而不是指向数据域或者指针域。我的理解就是这样，如果有不正确的地方还请老师指正~","like_count":0},{"had_liked":false,"id":30677,"user_name":"青石","can_delete":false,"product_type":"c1","uid":1092633,"ip_address":"","ucode":"01B96E494AC040","user_header":"https://static001.geekbang.org/account/avatar/00/10/ac/19/d6fe6ada.jpg","comment_is_top":false,"comment_ctime":1538971311,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538971311","product_id":100017301,"comment_content":"老师你好，我是一名js程序员，链表和数组的区别主要是内存是否连续，增删查的复杂度区别。<br><br>对于js这类的高级语言来说，这些区别是否无法利用呢？平常编码中主要的也是堆栈这样机构。链表比较少接触到。","like_count":0},{"had_liked":false,"id":30674,"user_name":"z4ul","can_delete":false,"product_type":"c1","uid":1260163,"ip_address":"","ucode":"50CB99D6A8B78C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ3eIjoCa5HXS3pVLX1hD7gXkmrfd51IGBqZ6Wx5SPhwS5wibzgiaYNQK7Xhpcu45EVp6hw9eZGmyeg/132","comment_is_top":false,"comment_ctime":1538971116,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538971116","product_id":100017301,"comment_content":"老师，课后思考题有推荐的答案吗？","like_count":0},{"had_liked":false,"id":30658,"user_name":"myj","can_delete":false,"product_type":"c1","uid":1141802,"ip_address":"","ucode":"C65EC488631ABE","user_header":"https://static001.geekbang.org/account/avatar/00/11/6c/2a/43101709.jpg","comment_is_top":false,"comment_ctime":1538966617,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538966617","product_id":100017301,"comment_content":"您好，请问双向循环链表的最后一个节点的next指针为什么不是指向第一个节点的prev，而是指向了它的data部分，同样的，第一个节点的prev也指向了最后一个节点的data部分而不是它的next，这个图中prev的指向您是希望表达指向next指针呢？还是想表达指向整个节点对象呢？","like_count":0},{"had_liked":false,"id":30649,"user_name":"CozyThinker","can_delete":false,"product_type":"c1","uid":1041217,"ip_address":"","ucode":"996D8B8C993C5C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e3/41/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1538965475,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538965475","product_id":100017301,"comment_content":"耗时28分钟学习完毕","like_count":0},{"had_liked":false,"id":30570,"user_name":"执__生","can_delete":false,"product_type":"c1","uid":1141545,"ip_address":"","ucode":"F74B5AB30A9D8A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Gkedlmv1ibTmUcALf69BCDhg5j0CGtqxaHHtpnbWc6yF8Wld7ILmgoScJtk4QiblfqoUJl9jyNhjgib9aEBGlIh8Q/132","comment_is_top":false,"comment_ctime":1538927932,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1538927932","product_id":100017301,"comment_content":"https:&#47;&#47;github.com&#47;TieChi&#47;aboutAlgs&#47;blob&#47;master&#47;linkedList.js<br>本节内容的js实现，望批评指正。","like_count":0},{"had_liked":false,"id":30543,"user_name":"Veigar","can_delete":false,"product_type":"c1","uid":1258773,"ip_address":"","ucode":"FAD1CBB0677D94","user_header":"https://static001.geekbang.org/account/avatar/00/13/35/15/0b7de6b0.jpg","comment_is_top":false,"comment_ctime":1538917011,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538917011","product_id":100017301,"comment_content":"def determine(str):<br>    str_01 = list(str)<br>    str_02 = list(str)[::-1]<br>    for i in range(0, len(str) &#47; 2):<br>        if str_01[i] != str_02[i]:<br>            return False<br><br>    # print str_02<br>    return True<br><br><br>if __name__ == &#39;__main__&#39;:<br>    str = raw_input(&#39;请输入判定字符串：&#39;)<br>    print &#39;是否为回文字符串：&#39;, determine(str)","like_count":0},{"had_liked":false,"id":30535,"user_name":"菜菜","can_delete":false,"product_type":"c1","uid":1243536,"ip_address":"","ucode":"888AC33663B774","user_header":"https://static001.geekbang.org/account/avatar/00/12/f9/90/f90903e5.jpg","comment_is_top":false,"comment_ctime":1538913118,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538913118","product_id":100017301,"comment_content":"用数组实现LRU缓存淘汰算法<br>能不能用空间换时间呢，就是维护另一个和原数组同样大小的数组，就叫做权重数组吧。<br>当一个新的数据被访问时：<br>1. 此数据之前已经被缓存在数组中了：<br>访问到的数据所对应的权重数组对应下标的权重变为0。如果数组是满的，填充过数据但此次未被访问到的数据权重加1；如果不满，没有填充数据的数组的权重还是为0，填充过数据但此次未被访问到的数据权重加1<br>2. 数据之前未被缓存<br>数组未满：寻找一个没有填充数据的位置，填入数据，权重为0；填充过数据但此次未被访问到的数据权重加1<br>数组已满：删除权重最大的，填入数据，权重为0；填充过数据但此次未被访问到的数据权重加1<br><br>","like_count":0},{"had_liked":false,"id":30530,"user_name":"毛玉娇","can_delete":false,"product_type":"c1","uid":1249192,"ip_address":"","ucode":"BC0F0FEEEAD5DD","user_header":"https://static001.geekbang.org/account/avatar/00/13/0f/a8/5bec6811.jpg","comment_is_top":false,"comment_ctime":1538910411,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538910411","product_id":100017301,"comment_content":"回文字符串判断（前提单链表实现）：可以采用新建链表，单用链表前插的方式，遍历新建后的链表拼接成新的字符串，若两个字符串相同则为回文字符串","like_count":0},{"had_liked":false,"id":30509,"user_name":"王虹凯","can_delete":false,"product_type":"c1","uid":1018862,"ip_address":"","ucode":"CA01E64E125CFF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8b/ee/56823fd7.jpg","comment_is_top":false,"comment_ctime":1538898329,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538898329","product_id":100017301,"comment_content":"空间换时间：数据库索引、缓存<br>时间换空间：jms消息中间件","like_count":0},{"had_liked":false,"id":30505,"user_name":"Haoz","can_delete":false,"product_type":"c1","uid":1022665,"ip_address":"","ucode":"DBDBF78877A7B7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9a/c9/08852337.jpg","comment_is_top":false,"comment_ctime":1538895955,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538895955","product_id":100017301,"comment_content":"什么是链表？<br>链表是一种不需要一块连续的内存空间，通过「指针」将一组零散的内存块串联起来使用的数据结构<br><br>最常见的链表结构<br>单链表：每个链表的节点除了存储数据之外，还需要记录链上的下一个结点的地址<br><br>循环链表：与单链表唯一的区别就在于尾结点，循环链表的尾结点指针指向链表的头结点，像一个环一样首尾相连<br><br>双向链表：支持两个方向，每个结点不止有后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点 <br><br>双向链表的优点<br>- 删除给定指针指向的结点时，时间复杂度为 O( 1 )<br>- 对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些<br><br>链表和数组的性能对比<br>- 数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高，而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读<br><br>- 数组的缺点是大小固定，一申明就要占用整块连续内存空间。如果申明的数组过大， 系统可能没有足够的连续内存空间分配给它，导致「内存不足」。如果申明的数组过小，可能出现不够用的情况，这时只能再申请一个更大的内存空间， 把原数组拷贝进去，非常耗时，而链表本身没有大小的限制，天然地支持动态扩容，这也是它和数组最大的区别<br><br>- 如果代码对内存的使用非常严苛，则数组更加合适，因为链表中的每个结点都需要消耗额外的存储空间来存储指向下一个结点的指针。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片<br><br>如何基于链表实现 LRU 算法？<br>维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的，当有一个新的数据被访问时，从链表头开始顺序遍历链表<br><br>1、如果此数据已经被缓存在链表中，遍历链表得到这个数据对应的结点，并将其从原来的位置删除，然后插入到链表的头部<br><br>2、如果此数据没有在缓存链表中，可分为两种情况<br>- 如果此时缓存未满，则将此结点直接插入到链表的头部<br>- 如果缓存已满，则将尾部的结点删除，将新的数据结点插入链表的头部","like_count":0},{"had_liked":false,"id":30488,"user_name":"GeekNA","can_delete":false,"product_type":"c1","uid":1186958,"ip_address":"","ucode":"6A9CD140314B18","user_header":"https://static001.geekbang.org/account/avatar/00/12/1c/8e/e54277e1.jpg","comment_is_top":false,"comment_ctime":1538885182,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538885182","product_id":100017301,"comment_content":"数组实现LRU<br>可以动态调整数组的开端，这样在保证数组连续性的时候可以选择移动数组的前端还是后端来减少开销。<br>1)如果未找到元素，则将新元素放在队头之前一位，并将其下标设置成数组开端的。如果原数组的开端为0下标，新的数组开端则为[n-1]。<br>1.1)如果数组已满，即从开端开始找了一圈之后又回到开端，则将新的元素放入队头前一位，即覆盖队尾元素，实现去除LRU元素。<br>2)如果在队列前半段找到元素，可以将其之前的元素往后移一位，然后将其放入队列开端。此时队列开端不变。<br>3)如果在队列后半段找到元素，可以将其之后元素往前移一位，然后将其放入队头前一位，并将其下标设置为新的数列开端。<br>总结：该方法保证数组移动的最大开销为n&#47;2。且若经常有新元素加入时，无需移动数组任何元素，仅移动队头的标记。","like_count":0},{"had_liked":false,"id":30454,"user_name":"MARS","can_delete":false,"product_type":"c1","uid":1187763,"ip_address":"","ucode":"FC2CB43C38FE47","user_header":"https://static001.geekbang.org/account/avatar/00/12/1f/b3/552c35f2.jpg","comment_is_top":false,"comment_ctime":1538872885,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538872885","product_id":100017301,"comment_content":"单链表的删除似乎不用重新遍历寻找指定节点的前一个节点，只需要使用一个指针变量在寻找删除节点的同时存下上一个节点的指针就好了","like_count":0},{"had_liked":false,"id":30432,"user_name":"SunshlnW","can_delete":false,"product_type":"c1","uid":1211252,"ip_address":"","ucode":"7B82BBC5F30633","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/74/63563202.jpg","comment_is_top":false,"comment_ctime":1538840425,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538840425","product_id":100017301,"comment_content":"双向链表的优势那块，单链表的删除可以通过<br>p.setData(p.getNext().getData());<br>p.setNext(p.getNext().getNext());<br>来实现。<br>单链表的插入可以通过如此赋值来实现。<br>这个时候复杂度就是O（1）了","like_count":0},{"had_liked":false,"id":30412,"user_name":"周平","can_delete":false,"product_type":"c1","uid":1259488,"ip_address":"","ucode":"4954DC474C4FDF","user_header":"https://static001.geekbang.org/account/avatar/00/13/37/e0/23f288ae.jpg","comment_is_top":false,"comment_ctime":1538832040,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538832040","product_id":100017301,"comment_content":"看到留言中，使用快慢指针的方法，解决 单链表判断是否 回文字符串的问题，很受启发。<br><br>同时，<br><br>JK David的思路，修改了 单向链表的存储内容，这个不太好吧。<br><br>兆甲 使用快慢指针的方法，我觉得是合理的。他通过 动态步长 来移动指针， 对比两组指针对应的元素是否一致来判断是否回文字串。","like_count":0},{"had_liked":false,"id":30386,"user_name":"王振华 程序员","can_delete":false,"product_type":"c1","uid":1131957,"ip_address":"","ucode":"31BB337642B882","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/b5/c3cfb198.jpg","comment_is_top":false,"comment_ctime":1538818616,"is_pvip":false,"replies":[{"id":"10955","content":"头结点对应的内存地址是基地址。头结点中的next指针记录的是下一个结点的地址。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538838199,"ip_address":"","comment_id":30386,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538818616","product_id":100017301,"comment_content":"“我们习惯性地把第一个结点叫做头结点，把最后一个结点叫做尾结点。其中，头结点用来记录链表的基地址。”这段话中的最后一句是不是有错误？<br>应该是“头指针用来记录链表的基地址”吧？头结点中应该记录的是下一个结点的内存地址呀？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425973,"discussion_content":"头结点对应的内存地址是基地址。头结点中的next指针记录的是下一个结点的地址。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538838199,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30374,"user_name":"0xFFFFFFFF","can_delete":false,"product_type":"c1","uid":1110672,"ip_address":"","ucode":"E06B669AF2DD0D","user_header":"https://static001.geekbang.org/account/avatar/00/10/f2/90/e3e19c6e.jpg","comment_is_top":false,"comment_ctime":1538814333,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538814333","product_id":100017301,"comment_content":"Java解法<br>```java<br>class Node {<br>    char val;<br>    Node next;<br>}<br>boolean fastAndSlowPointer(Node node) {<br>        if (node == null) {<br>            return false;<br>        }<br>        if (node.next == null) {<br>            return true; &#47;&#47; 定义单节点返回true<br>        }<br>        Node fast = node.next;<br>        Node slow = node;<br>        Node prev = null; &#47;&#47; slow指针的前驱节点，用来反转指针<br>        while (fast != null) {<br>            Node next = slow.next;<br>            slow.next = prev;<br>            prev = slow;<br>            slow = next;<br>            fast = fast.next;<br>            if (fast != null) {<br>                fast = fast.next;<br>                if (fast == null) {<br>                    &#47;&#47; 说明链表有奇数个节点(因为此时fast节点是第2n位置的节点，单是为null)<br>                    &#47;&#47; slow指针跳过最中间节点。奇数长度回文一定是中间节点两边对称<br>                    slow = slow.next;<br>                }<br>            }<br>        }<br>        while (prev != null) {<br>            if (prev.val != slow.val) {<br>                return false;<br>            }<br>            prev = prev.next;<br>            slow = slow.next;<br>        }<br>        return slow == null;<br>    }<br>```","like_count":0},{"had_liked":false,"id":30332,"user_name":"Wayne","can_delete":false,"product_type":"c1","uid":1244227,"ip_address":"","ucode":"EF482BB711AD63","user_header":"https://static001.geekbang.org/account/avatar/00/12/fc/43/3438409b.jpg","comment_is_top":false,"comment_ctime":1538796741,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538796741","product_id":100017301,"comment_content":"数组实现LRU:<br>数据元素定义为｛data,valid｝，<br>插入元素时，如果数组未满，头与尾-1个元素间存在这个元素都标记为invalid，然后将元素插入到数组的尾部，尾部相同则不重复添加。如果数组满，则触发数组清理，然后同上。<br>数组清理，倒序遍历数组，如遇invalid元素则计算连续最大的invalid个数，再将后面的元素前移相应步数。如果没有invalid，则整体向前移动适当数量的步数。<br><br>集中清理，优化效率。","like_count":0},{"had_liked":false,"id":30288,"user_name":"Wy 🐠","can_delete":false,"product_type":"c1","uid":1261176,"ip_address":"","ucode":"F37AAED71DBAC3","user_header":"https://static001.geekbang.org/account/avatar/00/13/3e/78/0654bcc1.jpg","comment_is_top":false,"comment_ctime":1538760161,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538760161","product_id":100017301,"comment_content":"这一章内容配上leetcode里LRU那道设计题，以及题解就更直白啦","like_count":0},{"had_liked":false,"id":30258,"user_name":"勤劳的小胖子-libo","can_delete":false,"product_type":"c1","uid":1158344,"ip_address":"","ucode":"5BB20CD5A56568","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/c8/4b1c0d40.jpg","comment_is_top":false,"comment_ctime":1538746150,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538746150","product_id":100017301,"comment_content":"乍一想来，直接双向链表，二个指针，一个指头向后，一个指尾向前，对指向的值一一比较，到都指向null，表示相同。时间复杂度，O(n)遍历，空间复杂度是O(1)，保存二个指针。<br>但应该有优化的方法，结束的条件应该可以优化。","like_count":0},{"had_liked":false,"id":30257,"user_name":"张飞online","can_delete":false,"product_type":"c1","uid":1249136,"ip_address":"","ucode":"C9787E4B35888C","user_header":"https://static001.geekbang.org/account/avatar/00/13/0f/70/759b1567.jpg","comment_is_top":false,"comment_ctime":1538744804,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538744804","product_id":100017301,"comment_content":"其实链表还好，一个链表加多线程操作，再加性能优化，也就是你加锁的粒度不能太大，要到链表里面加","like_count":0},{"had_liked":false,"id":30256,"user_name":"明翼","can_delete":false,"product_type":"c1","uid":1068361,"ip_address":"","ucode":"E77F86BEB3D5C1","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","comment_is_top":false,"comment_ctime":1538744187,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538744187","product_id":100017301,"comment_content":"几个问题请教下：1.单项链表用一个变量保存前一个节点，删除时候应该和双向链表时间复杂度一样啊。<br>2.&quot;当访问的数据没有存储在缓存的链表中时，直接将数据插入链表表头，时间复杂度为O(1)；&quot;这个是有问题的，如何知道访问数据不在链表中，这本身也需要一次遍历。<br><br>至于回文问题，用一个双向链表表示，从头到尾遍历再返回来遍历得到的字符串比较即可","like_count":0},{"had_liked":false,"id":30235,"user_name":"智慧树叶","can_delete":false,"product_type":"c1","uid":1246066,"ip_address":"","ucode":"58DA4631AA3584","user_header":"","comment_is_top":false,"comment_ctime":1538735417,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538735417","product_id":100017301,"comment_content":"课后思考:可以用双链表，先将字符串单个写入双链表，然后取中间节点向两头发散比较是否相等。核心算法的时间复杂度的话是O(n)。","like_count":0},{"had_liked":false,"id":30226,"user_name":"wean","can_delete":false,"product_type":"c1","uid":1239735,"ip_address":"","ucode":"3E069F95C25EAD","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/b7/1f7316e6.jpg","comment_is_top":false,"comment_ctime":1538731061,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538731061","product_id":100017301,"comment_content":"数组简单易用，在实现上是使用连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中不是连续存储，对 CPU 缓存不友好，没办法有效预读。<br><br>但数组的特点也是它的不足，他的内存空间是固定的，如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致内存不足(out of memory)，例如如果现在系统由 100M 不连续的内存空间，声明 100M 数组就会失败，另外到数组扩容时，复制原数组的内容到新数组也很费时。这就是数组和链表最大的区别。<br><br>另外如果我们的代码对内存使用非常苛刻，那应该使用数组，比如安卓之类的，因为链表需要维护额外的空间去存储指针。而且对链表进行频繁的插入、删除操作，还对导致频繁的内存申请和释放，容易造成内存碎片。如果是 Java 语言，就可能导致频繁的 gc。","like_count":0},{"had_liked":false,"id":30218,"user_name":"liu","can_delete":false,"product_type":"c1","uid":1129567,"ip_address":"","ucode":"DA9F9FBD96A9A0","user_header":"https://static001.geekbang.org/account/avatar/00/11/3c/5f/cc30c10c.jpg","comment_is_top":false,"comment_ctime":1538729128,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538729128","product_id":100017301,"comment_content":"##数据结构与算法<br><br>###第五课，链表上（Linked List）<br><br>#### 开篇题目，如何实现LRU的缓存淘汰算法<br>1、缓存算法：一种高性能的数据读取技术，如CPU缓存，数据库缓存，浏览器缓存<br>2、三种缓存淘汰策略：先进先出（FIFO），最少使用策略（LFU），最近最少使用车策略（LRU）<br><br>#### 链表和数组的底层存储结构<br>1、数组需要一组连续的内存空间存储，如果连续的内存不够，则申请失败，对内存要求较高<br>2、链表则与数组相反，它不需要连续的内存空间，它是将一组零散的内存块组合起来使用，只要内存足够，都可以申请<br>    支持动态扩容。<br><br>#### 链表结构<br><br>##### 单链表<br>1、内存块，即链表节点，用来存储数据和下一个节点指针next<br>2、头结点和尾节点（NULL）比较特殊<br>3、支持插入（O(1)）、删除（O(1)）、查找（O（n)）等操作<br><br>##### 循环链表<br>1、循环链表是一种特殊的单链表，首尾相连的<br>2、优点：从尾到头遍历方便，在处理的数据有环形结构特点的时候适用，如约瑟夫问题<br><br>##### 双向链表<br>1、不仅包含后继指针next，还有前驱指针prev<br>2、支持双向遍历，灵活性高<br>3、删除操作<br>    1、删除节点中“某个值等于指定值“的节点，算法时间复杂度为O(n)<br>    2、删除某个指针指向的节点，可以根据前驱节点直接获取前一个指定，无需从头遍历，性能要比单链表高，<br>        算法时间复杂度为O(1)<br>4、查询操作，对于无序的数据来说，效率跟单链表一样为O(n)，如果数据为有序的，平均只需要查找一半的数据        <br><br>##### 双向循环链表<br>1、双向链表差不多，区别在于首尾节点相连<br><br>#### 设计思想<br>1、用空间换取时间的设计思想，如果内存足够，但追求代码的执行速度的时候，可选择空间复杂度高、时间复杂度低的<br>    的算法或数据结构。<br>2、用时间换取空间的设计思想，如果内存吃紧，则选择空间复杂度低，时间复杂度高的算法或数据结构<br>3、缓存技术就是用了空间换取时间的设计思想<br><br>#### 链表数组性能对比<br>1、数组，插入删除（O（n）），随机访问（O（1））<br>2、链表，插入删除（O（1）），随机访问（O（n））<br><br>#### 开篇解答，基于链表实现LRU缓存算法<br>1、维护一个单链表，越靠近尾节点则表示越早之前访问，如果有数据来，则先遍历后插入<br>2、判断此数据是否已经在链表中<br>    1、如果已经在缓存链表中了，先把数据取出来然后放到链表头<br>    2、如果不在在缓存链表中，则判断缓存链表是否已满<br>        1、如果已满，则把最后一个剔除，然后把新数据放到头结点<br>        2、如果未满，则直接把新数据放到头结点<br>3、此缓存算法时间复杂度O(n)<br>4、优化思路，使用散列表记录每个数据的位置，降低缓存访问时间<br><br>#### 开篇解答，基于数组的LRU缓存算法的实现<br>1、维护一个数组，越靠近尾部则表示越早之前访问，如果有数据来，则先遍历后插入<br>2、判断此数据是否已经在数组中<br>    1、如果已经在缓存链表中，先把数据取出来，然后把之前的数据往后搬移一位，最后把刚才取出的数据放到头<br>    2、如果不在在缓存链表中，则判断缓存链表是否已满<br>        1、如果已满，则把最后一个剔除，然后把之前的数据往后搬移一位，最后把数据放到头<br>        2、如果未满，先把所有数据往后搬移一位，然后把新数据放到头结点<br>3、此缓存算法时间复杂度O(n)（查找O(n)，数据搬移O(n)），因为涉及数据搬移，所以该算法比基于链表的效率低<br><br>#### 课后思考，基于单链表的回文字符串判断<br>1、声明两个指针a，b，指向链表头结点<br>2、a，b指针向前移动，a每次移动一格，b每次移动两个，直到b为null或者b.next为null，此时a的位置恰好在链表中间<br>3、使用栈c存储每次a指针指向的节点<br>4、循环结束<br>5、接着b指针继续向前移动，栈c弹栈并且跟b节点值比较<br>6、如果不相等则循环结束，说明不是回文字符串返回false<br>7、否则继续5、6步骤，直到b.next为null<br>8、是回文字符串，返回true","like_count":0},{"had_liked":false,"id":30183,"user_name":"学渣！！！","can_delete":false,"product_type":"c1","uid":1224654,"ip_address":"","ucode":"A224265D9E7CCC","user_header":"https://static001.geekbang.org/account/avatar/00/12/af/ce/d7ae8da9.jpg","comment_is_top":false,"comment_ctime":1538716028,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538716028","product_id":100017301,"comment_content":"思考题采用快慢指针：<br>public static boolean isPalindrome(Node head){<br>        Node pre = null;<br>        Node slow = head;<br>        Node fast = head;<br>        while(fast != null &amp;&amp; fast.next != null){<br>            fast = fast.next.next;<br>            Node next = slow.next;<br>            slow.next = pre; &#47;&#47;把slow的下一个节点指向pre,使前半段节点反序<br>            pre = slow;<br>            slow = next;<br>        }<br><br>        &#47;&#47;当是奇数个元素时，slow要跳过最中间过素<br>        if(fast != null){<br>            slow = slow.next;<br>        }<br><br>        while(slow != null){<br>            if(slow.data != pre.data){<br>                return false;<br>            }<br>            slow = slow.next;<br>            pre = pre.next;<br>        }<br>        return true;<br>    }<br><br>    public static void main(String[] args) {<br>        Node node1_1 = new Node(&quot;n&quot;);<br>        Node node1_2 = new Node(&quot;o&quot;);<br>        Node node1_3 = new Node(&quot;o&quot;);<br>        Node node1_4 = new Node(&quot;n&quot;);<br>        node1_1.next = node1_2;<br>        node1_2.next = node1_3;<br>        node1_3.next = node1_4;<br>        node1_4.next = null;<br>        System.out.println(isPalindrome(node1_1));<br><br><br>        Node node2_1 = new Node(&quot;l&quot;);<br>        Node node2_2 = new Node(&quot;e&quot;);<br>        Node node2_3 = new Node(&quot;v&quot;);<br>        Node node2_4 = new Node(&quot;e&quot;);<br>        Node node2_5 = new Node(&quot;l&quot;);<br>        node2_1.next = node2_2;<br>        node2_2.next = node2_3;<br>        node2_3.next = node2_4;<br>        node2_4.next = node2_5;<br>        node2_5.next = null;<br>        System.out.println(isPalindrome(node2_1));<br>    }<br><br>    static class Node {<br>        private String data;<br>        private Node next;<br><br>        public Node(String data) {<br>            this.data = data;<br>        }<br>    }<br>因为没有额外增加内存所以空间复杂度为O(1),时间复杂度为O(n)<br>老师，想问下你文章里的图用什么画图工具完成的","like_count":0},{"had_liked":false,"id":30165,"user_name":"Nuko","can_delete":false,"product_type":"c1","uid":1236899,"ip_address":"","ucode":"2C258BBA17B20E","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/a3/7b36b257.jpg","comment_is_top":false,"comment_ctime":1538709499,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538709499","product_id":100017301,"comment_content":"将单链表反转，时间O（n），在对两条链表遍历比较，时间O（n）","like_count":0},{"had_liked":false,"id":30163,"user_name":"刘十一","can_delete":false,"product_type":"c1","uid":1035899,"ip_address":"","ucode":"5927D77D248E30","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ce/7b/fa0f9368.jpg","comment_is_top":false,"comment_ctime":1538708067,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538708067","product_id":100017301,"comment_content":"思考题：利用链表判断一个字符串是否是回文，基本思想就是首尾进行对比，时间复杂度是O(n)，老师可不可以往后将思考题的答案或者说您的思路，在下一篇文章中提供出来呢？","like_count":0},{"had_liked":false,"id":30140,"user_name":"code047","can_delete":false,"product_type":"c1","uid":1241330,"ip_address":"","ucode":"7223DB00BC8016","user_header":"","comment_is_top":false,"comment_ctime":1538698551,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538698551","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":30120,"user_name":"SunshlnW","can_delete":false,"product_type":"c1","uid":1211252,"ip_address":"","ucode":"7B82BBC5F30633","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/74/63563202.jpg","comment_is_top":false,"comment_ctime":1538671109,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538671109","product_id":100017301,"comment_content":"数组实现LRU：可以采用“空间换时间”策略，申请足够大内存的数组，然后定义一个变量count记录位置，count位置的数字代表最近最久未使用的数据，定义一个标志Nan，表示数据为Nan的这个位置被置换过。从数组起始位置开始存放数据。<br>1）当缓存区没有满时，直接放入数组，需要置换的数据被置为Nan，被置换的数据加入数组。<br>2）当缓存区满的时候，利用count记录最近最久未使用的数据，如果该位置数据被置换，则count后移一位。如果不是该位置被置换，则被置换的数据被置为Nan，被置换的数据放加入数组。<br>思考：<br>https:&#47;&#47;wizardforcel.gitbooks.io&#47;the-art-of-programming-by-july&#47;content&#47;01.04.html<br>1、首先利用快慢指针找到单链表中间结点点，同时将链表的前半部分逆序<br>2、利用中间结点指针和头结点指针判断链表前半部分和后半部分是否相等。","like_count":0},{"had_liked":false,"id":30111,"user_name":"小苏饼","can_delete":false,"product_type":"c1","uid":1247539,"ip_address":"","ucode":"80868F7477E2BB","user_header":"https://static001.geekbang.org/account/avatar/00/13/09/33/57757a23.jpg","comment_is_top":false,"comment_ctime":1538667375,"is_pvip":false,"replies":[{"id":"10887","content":"这个貌似不行，你可以说说你的思路：）","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538748941,"ip_address":"","comment_id":30111,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538667375","product_id":100017301,"comment_content":"LRU这个缓存淘汰算法能不能用优先队列呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425857,"discussion_content":"这个貌似不行，你可以说说你的思路：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538748941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30107,"user_name":"blacksmith","can_delete":false,"product_type":"c1","uid":1241139,"ip_address":"","ucode":"63E0F325B706B3","user_header":"https://static001.geekbang.org/account/avatar/00/12/f0/33/7eea7af1.jpg","comment_is_top":false,"comment_ctime":1538664267,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538664267","product_id":100017301,"comment_content":"用数组实现LRU缓存淘汰算法思路：<br>维护一个数组，在数组中越靠前位置的数据是越早之前访问的。当有一个新的数据被访问时，我们从数组的0位置开始循环遍历数组。<br>1.如果此数据已经在缓存的数组中，我们遍历得到这个数据对应的位置，将其从原位置删除，后续位置的数组往前移动一个内存单元，然后将被访问的数据存储在数组的末尾。<br>2.如果此数据没有在缓存数组中，将其添加到数组的末尾，如果缓存已满，则将此数据存储在数组的开始位置（0位置）。","like_count":0},{"had_liked":false,"id":30101,"user_name":"dead_lock","can_delete":false,"product_type":"c1","uid":1135475,"ip_address":"","ucode":"BE4398D8DF32C6","user_header":"https://static001.geekbang.org/account/avatar/00/11/53/73/b0e54c79.jpg","comment_is_top":false,"comment_ctime":1538662195,"is_pvip":false,"replies":[{"id":"10888","content":"删除是O(1)是有前提的，就是已经知道前驱结点的情况下，删除是O(1)。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538748999,"ip_address":"","comment_id":30101,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538662195","product_id":100017301,"comment_content":"不理解链表删除为什么是O(1)，因为单向链表删除需要找到前驱节点复杂度为O(n)，谢谢老师解答","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425855,"discussion_content":"删除是O(1)是有前提的，就是已经知道前驱结点的情况下，删除是O(1)。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538748999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30089,"user_name":"Flying","can_delete":false,"product_type":"c1","uid":1239009,"ip_address":"","ucode":"2E9D9813E329E1","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/e1/2e27eabf.jpg","comment_is_top":false,"comment_ctime":1538655862,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538655862","product_id":100017301,"comment_content":"『在实际的软件开发中，从链表中删除一个数据无外乎这两种情况：<br>删除结点中“值等于某个给定值”的结点；<br>删除给定指针指向的结点。』<br>问题1（删除结点中值等于某个给定值的结点）是什么意思，是用空值替代吗，还是其他操作。<br>问题2:（删除给定指针指向的结点），比如删除中间的一个结点，是不是应该这样操作:把前一个的next指向后一个的previous，这样就相当于删除了中间的结点了。<br>希望老师解答一下。","like_count":0},{"had_liked":false,"id":30075,"user_name":"Snail","can_delete":false,"product_type":"c1","uid":1242674,"ip_address":"","ucode":"58346C4D80AA94","user_header":"https://static001.geekbang.org/account/avatar/00/12/f6/32/c9d8fd60.jpg","comment_is_top":false,"comment_ctime":1538648320,"is_pvip":false,"replies":[{"id":"10797","content":"java语言可以的，但是其他语言，比如C语言，要程序员自己free这块内存空间","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538656404,"ip_address":"","comment_id":30075,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538648320","product_id":100017301,"comment_content":"如果链表中3个连续的元素A,B,C，删除元素B，只需要将A的next设置为C即可，对吗？B会自动被垃圾回收吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425846,"discussion_content":"java语言可以的，但是其他语言，比如C语言，要程序员自己free这块内存空间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538656404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30050,"user_name":"Ad","can_delete":false,"product_type":"c1","uid":1052430,"ip_address":"","ucode":"BB043E37C45BA7","user_header":"https://static001.geekbang.org/account/avatar/00/10/0f/0e/e85fb4f9.jpg","comment_is_top":false,"comment_ctime":1538635871,"is_pvip":false,"replies":[{"id":"10801","content":"嗯嗯","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538656694,"ip_address":"","comment_id":30050,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538635871","product_id":100017301,"comment_content":"雖然要花點時間了解，但是對準備考研也是很有用處的!","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425835,"discussion_content":"嗯嗯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538656694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30031,"user_name":"Marnie","can_delete":false,"product_type":"c1","uid":1001912,"ip_address":"","ucode":"ECF9B22574F868","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/b8/fb19aa6a.jpg","comment_is_top":false,"comment_ctime":1538630143,"is_pvip":false,"replies":[{"id":"10804","content":"是的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538656806,"ip_address":"","comment_id":30031,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538630143","product_id":100017301,"comment_content":"数组，查找方便，插入删除不方便。<br>链表，插入删除方便，查找不方便。<br>链表是以空间换时间，因为链表指针也要存储。如果对空间要求比较高的程序，优先考虑数组。<br><br><br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425824,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538656806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30030,"user_name":"A.....","can_delete":false,"product_type":"c1","uid":1178258,"ip_address":"","ucode":"8078CD50894D59","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/92/3c6a224c.jpg","comment_is_top":false,"comment_ctime":1538629561,"is_pvip":false,"replies":[{"id":"10805","content":"每周三篇 已经有同学跟不上了！你这种尖子生就迁就一下吧：）","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538656845,"ip_address":"","comment_id":30030,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538629561","product_id":100017301,"comment_content":"老师,快点更啊,等不及了","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425823,"discussion_content":"每周三篇 已经有同学跟不上了！你这种尖子生就迁就一下吧：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538656845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30025,"user_name":"煜","can_delete":false,"product_type":"c1","uid":1249421,"ip_address":"","ucode":"6A8073873C3608","user_header":"https://static001.geekbang.org/account/avatar/00/13/10/8d/80959fd8.jpg","comment_is_top":false,"comment_ctime":1538627879,"is_pvip":false,"replies":[{"id":"10806","content":"我这里的前提是指针已经指向要删除的结点了。所以没法通过p-&gt;next来判定是否是要删除的结点了。你可能会问，指针是怎么指向要删除结点的呢？这个等到我们讲到散列表的时候，会有相应的一个例子。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538657044,"ip_address":"","comment_id":30025,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538627879","product_id":100017301,"comment_content":"单链表删除指针指向的节点的时候，为什么不用p-&gt;next-&gt;next来判断是不是为要删除的节点呢？这样就不用找到相应的前驱节，时间复杂度和双链表一样的","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425822,"discussion_content":"我这里的前提是指针已经指向要删除的结点了。所以没法通过p-&amp;gt;next来判定是否是要删除的结点了。你可能会问，指针是怎么指向要删除结点的呢？这个等到我们讲到散列表的时候，会有相应的一个例子。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538657044,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30024,"user_name":"煜","can_delete":false,"product_type":"c1","uid":1249421,"ip_address":"","ucode":"6A8073873C3608","user_header":"https://static001.geekbang.org/account/avatar/00/13/10/8d/80959fd8.jpg","comment_is_top":false,"comment_ctime":1538627878,"is_pvip":false,"replies":[{"id":"10807","content":"我这里的前提是指针已经指向要删除的结点了。所以没法通过p-&gt;next来判定是否是要删除的结点了。你可能会问，指针是怎么指向要删除结点的呢？这个等到我们讲到散列表的时候，会有相应的一个例子。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538657052,"ip_address":"","comment_id":30024,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538627878","product_id":100017301,"comment_content":"单链表删除指针指向的节点的时候，为什么不用p-&gt;next-&gt;next来判断是不是为要删除的节点呢？这样就不用找到相应的前驱节，时间复杂度和双链表一样的","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425821,"discussion_content":"我这里的前提是指针已经指向要删除的结点了。所以没法通过p-&amp;gt;next来判定是否是要删除的结点了。你可能会问，指针是怎么指向要删除结点的呢？这个等到我们讲到散列表的时候，会有相应的一个例子。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538657052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30021,"user_name":"起点·终站","can_delete":false,"product_type":"c1","uid":1239857,"ip_address":"","ucode":"A5AD31F28C240E","user_header":"https://static001.geekbang.org/account/avatar/00/12/eb/31/96b76ca8.jpg","comment_is_top":false,"comment_ctime":1538626535,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538626535","product_id":100017301,"comment_content":"回文的那个，for循环倒序插入一个新数组在判断相等，所以是O(n)………有现成的方法reverse()","like_count":0},{"had_liked":false,"id":30020,"user_name":"疾风知劲草","can_delete":false,"product_type":"c1","uid":1184919,"ip_address":"","ucode":"B6E73CA240AA29","user_header":"https://static001.geekbang.org/account/avatar/00/12/14/97/8a3aa317.jpg","comment_is_top":false,"comment_ctime":1538626105,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538626105","product_id":100017301,"comment_content":"单链表判断是否为回文字符串，最直接的思路就是从字符串两端开始判断，首先是第一个字符与最后一个字符，依次判断所有字符串，如果出现一次不相等，那么就能得出结论。<br>Python代码实现如下：<br>(篇幅限制，没有注释，另外代码只给出了用到的方法，完整代码见https:&#47;&#47;github.com&#47;linsanityHuang&#47;python_data_and_algorithms&#47;blob&#47;master&#47;Reverse_String.py)<br>单向链表实现：<br>class Node(object):<br>\tdef __init__(self, value=None, next=None):<br>\t\tself.value, self.next = value, next<br>class LinkedList(object):<br>\tdef __init__(self, maxsize=None):<br>\t\tself.maxsize = maxsize<br>\t\tself.root = Node()<br>\t\tself.tailnode = None<br>\t\tself.length = 0<br><br>\tdef __len__(self):<br>\t\treturn self.length<br>\t<br>\tdef append(self, value):<br>\t\tif self.maxsize is not None and len(self) &gt;= self.maxsize:<br>\t\t\traise Exception(&quot;LinkedList is Full&quot;)<br>\t\tnode = Node(value)<br>\t\ttailnode = self.tailnode<br>\t\t# 还没有append过，length=0，追加到root后<br>\t\tif tailnode is None:<br>\t\t\tself.root.next = node<br>\t\t# 否则追加到最后一个节点的后边，并且更新最后一个节点是刚append的节点<br>\t\telse:<br>\t\t\ttailnode.next = node<br>\t\tself.tailnode = node<br>\t\tself.length += 1<br>\t<br>\t# 删除尾节点<br>\tdef pop(self):<br>\t\tif self.root.next is None:<br>\t\t\traise Exception(&#39;pop from empty LinkedList&#39;)<br>\t\tprevnode = self.root<br>\t\tfor curnode in self.iter_node():<br>\t\t\tif curnode is self.tailnode and curnode is not self.root:<br>\t\t\t\tvalue = curnode.value<br>\t\t\t\t# 删除当前尾节点<br>\t\t\t\tdel curnode<br>\t\t\t\tprevnode.next = None<br>\t\t\t\tself.tailnode = prevnode<br>\t\t\t\tself.length -= 1<br>\t\t\t\treturn value<br>\t\t\telse:<br>\t\t\t\tprevnode = curnode<br><br>\tdef popleft(self):<br>\t\tif self.root.next is None:<br>\t\t\traise Exception(&#39;pop from empty LinkedList&#39;)<br>\t\theadnode = self.root.next<br>\t\tself.root.next = headnode.next<br>\t\tself.length -= 1<br>\t\tvalue = headnode.value<br>\t\t<br>\t\t# 如果删除的是尾节点，需要把尾节点置为None<br>\t\tif self.tailnode is headnode:<br>\t\t\tself.tailnode = None<br>\t\tdel headnode<br>\t\treturn value<br><br>判断是否会问字符串：<br>def is_reversed_str(word):<br>\tif not isinstance(word, str):<br>\t\treturn<br>\tstr_linkedlist = LinkedList(maxsize=len(word))<br>       # O(n)<br>\tfor item in word:<br>\t\tstr_linkedlist.append(item)<br>\t<br>\tsize = len(str_linkedlist)<br>\tflag = True<br>        #O(n^2)<br>\tfor _ in range(size &#47;&#47; 2):<br>\t\tif str_linkedlist.pop() != str_linkedlist.popleft():<br>\t\t\tflag = False<br>\t\t\tbreak<br>\treturn flag<br><br>复杂度分析：<br>O(n^2)","like_count":0},{"had_liked":false,"id":30018,"user_name":"dead_lock","can_delete":false,"product_type":"c1","uid":1135475,"ip_address":"","ucode":"BE4398D8DF32C6","user_header":"https://static001.geekbang.org/account/avatar/00/11/53/73/b0e54c79.jpg","comment_is_top":false,"comment_ctime":1538625059,"is_pvip":false,"replies":[{"id":"10809","content":"同学，你觉得应该是O(1)还是O(n)呢？或者你觉得其中哪一个不理解呢？你可以自己试着分析一下时间复杂度的。如果还不清楚，再给我留言吧。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538657184,"ip_address":"","comment_id":30018,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538625059","product_id":100017301,"comment_content":"针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 O(1)。<br><br>老师您好，文中单向链表删除和插入操作时间复杂度为O(1)，后面讲解中有提到 单向链表在删除指定指针节点或者删除值相等节点的时候，需要找到前驱节点，复杂度为O(n)，<br>我理解的是这两个时间复杂度都是在说明单向链表的删除，为什么一个是O(1)一个是O(n)","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425818,"discussion_content":"同学，你觉得应该是O(1)还是O(n)呢？或者你觉得其中哪一个不理解呢？你可以自己试着分析一下时间复杂度的。如果还不清楚，再给我留言吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538657184,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29996,"user_name":"途","can_delete":false,"product_type":"c1","uid":1178240,"ip_address":"","ucode":"7715FE183557FF","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/80/f8be387d.jpg","comment_is_top":false,"comment_ctime":1538621660,"is_pvip":false,"replies":[{"id":"10777","content":"不是 我后面讲到散列那节课会讲","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538624685,"ip_address":"","comment_id":29996,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538621660","product_id":100017301,"comment_content":"链表+hash实现lru不就是jdk的LinkedHashmap么","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425805,"discussion_content":"不是 我后面讲到散列那节课会讲","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538624685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29989,"user_name":"Vincen","can_delete":false,"product_type":"c1","uid":1218185,"ip_address":"","ucode":"1029A901EC7BA0","user_header":"https://static001.geekbang.org/account/avatar/00/12/96/89/9312b3a2.jpg","comment_is_top":false,"comment_ctime":1538620575,"is_pvip":false,"replies":[{"id":"10823","content":"你说的稍微有点笼统，要具体看代码怎么写的。比如增加一个数据，是在p指针之后增加、还是之前增加、还是直接增加到链表的头部，这个时间复杂度都是不一样的。删除操作也是类似的，是删除某个指针指向的结点，还是删除值等于某个值的结点等等，要具体看的。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538658271,"ip_address":"","comment_id":29989,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538620575","product_id":100017301,"comment_content":"老师，我用go语言实现了一个单链表，为什么除了增加一个数据的时间复杂度为O(1)，删改查的时间复杂度都为O(n)?","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425802,"discussion_content":"你说的稍微有点笼统，要具体看代码怎么写的。比如增加一个数据，是在p指针之后增加、还是之前增加、还是直接增加到链表的头部，这个时间复杂度都是不一样的。删除操作也是类似的，是删除某个指针指向的结点，还是删除值等于某个值的结点等等，要具体看的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538658271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29979,"user_name":"阿伟","can_delete":false,"product_type":"c1","uid":1162801,"ip_address":"","ucode":"92CC40C035816D","user_header":"https://static001.geekbang.org/account/avatar/00/11/be/31/d7386dd0.jpg","comment_is_top":false,"comment_ctime":1538619125,"is_pvip":false,"replies":[{"id":"10825","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538658364,"ip_address":"","comment_id":29979,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538619125","product_id":100017301,"comment_content":"https:&#47;&#47;github.com&#47;sunpengwei1992&#47;go_common.git<br>跟随作者讲解，所有练习会在里面用代码实现，有兴趣的可以探讨，互相学习。已经有一些实现了，大家可以看看，有不对的地方，望指正，邮箱：sunpengwei1992@aliyun.com","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425798,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538658364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29954,"user_name":"James Scott","can_delete":false,"product_type":"c1","uid":1255048,"ip_address":"","ucode":"E673BD69503693","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/88/e8098480.jpg","comment_is_top":false,"comment_ctime":1538615141,"is_pvip":false,"replies":[{"id":"10778","content":"嗯嗯 理解就好 🤝","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538624830,"ip_address":"","comment_id":29954,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538615141","product_id":100017301,"comment_content":"王老师：您好！起初我是这样考虑的，访问单链表从链表头部开始访问的，那么越靠近链表尾部的节点应该被访问的时间越晚，刚刚看了您回复给CaiBird的留言就明白了。谢谢王老师的指点","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425787,"discussion_content":"嗯嗯 理解就好 🤝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538624830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29910,"user_name":"缓哟","can_delete":false,"product_type":"c1","uid":1241391,"ip_address":"","ucode":"0D560AFCA6BECA","user_header":"https://static001.geekbang.org/account/avatar/00/12/f1/2f/3ec9fcfb.jpg","comment_is_top":false,"comment_ctime":1538588783,"is_pvip":false,"replies":[{"id":"10830","content":"1. 可行<br>2. 不可行","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538659506,"ip_address":"","comment_id":29910,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538588783","product_id":100017301,"comment_content":"一个数组，头部是最久没有访问的。当访问一个新数据的时候，遍历数组，如果存在，且内存空间没满，就删除，重新插入到后面。如果不存在，且内存空间没满，直接插入，如果满了，删除数组第一个数据，1～ n-1位置的数据前移，再插入到n-1的位置。<br>数组实现LRU，不知道对不对;-)<br><br>回文<br>如果是用循环单链表存储，那么维护一个尾指针，当尾结点和头结点相等的时候，删除这两个结点，一直这样子，当链表为空或者只有一个结点的时候，就是回文。<br>这样子行不行嘿;-)<br><br>评论里有讲双链表和栈，看题目说是用单链表","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425775,"discussion_content":"1. 可行\n2. 不可行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538659506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29880,"user_name":"天宇星旋","can_delete":false,"product_type":"c1","uid":1198895,"ip_address":"","ucode":"69D10D5F4EB782","user_header":"https://static001.geekbang.org/account/avatar/00/12/4b/2f/a93ff216.jpg","comment_is_top":false,"comment_ctime":1538578230,"is_pvip":false,"replies":[{"id":"10843","content":"我没说错，我说的前提是有一个指针指向了p结点，我现在要删除p结点，如何做？你可以看我github上的代码！同学 再认真看遍我写的文章吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538660396,"ip_address":"","comment_id":29880,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538578230","product_id":100017301,"comment_content":"删除给定指针指向的结点。对于这个问题，老师你文中说错了，无论是单向链表还是双向链表，其删除的时间复杂度都是O(1)。单向链表只需要将待删除结点的指针只想next→next，并将下一个结点的值赋值给待删除结点，这样就可以达到删除指定结点。替换的思想。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425754,"discussion_content":"我没说错，我说的前提是有一个指针指向了p结点，我现在要删除p结点，如何做？你可以看我github上的代码！同学 再认真看遍我写的文章吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538660396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29859,"user_name":"飞羽","can_delete":false,"product_type":"c1","uid":1241451,"ip_address":"","ucode":"6779BCE78AA636","user_header":"https://static001.geekbang.org/account/avatar/00/12/f1/6b/c95dab3c.jpg","comment_is_top":false,"comment_ctime":1538567453,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538567453","product_id":100017301,"comment_content":"我的思路是与栈结合，循环遍历一次链表，并将数据压栈，由于栈先进后出的特性，相当于反转了链表的数据。<br>之后再遍历一次，依次出栈并与链表节点上的数据进行比较，如果完全相同，就说明是回文。<br><br>实现语言是JavaScript（直接用js的数组模拟栈的行为）<br>时间复杂度是O(n)<br>空间复杂度是O(n)<br><br>class Link {<br>  constructor(data, next){<br>    this.data = data;<br>    this.next = next;<br>  }<br>}<br><br>class Stack {<br>  constructor(){<br>    this.datas = []<br>  }<br>  add(data){<br>    this.datas.push(data);<br>  }<br>  get(){<br>    return this.datas.pop();<br>  }<br>}<br><br>const a = new Link(&#39;a&#39;, null);<br>let next = a.next = new Link(&#39;b&#39;, null);<br>next = next.next = new Link(&#39;c&#39;, null);<br>next = next.next = new Link(&#39;b&#39;, null);<br>next = next.next = new Link(&#39;a&#39;, null);<br><br>function isRev(link){<br>  if(!link.data || !link.next) return false;<br>  const cache = new Stack();<br>  let _link = link<br>  let i = 0;<br>  while (_link) {<br>    cache.add(_link.data);<br>    _link = _link.next;<br>  }<br>  while (link) {<br>    const data  = cache.get()<br>    if(link.data !== data){<br>      return false;<br>    }<br>    link = link.next;<br>  }<br>  return true;<br>}<br><br>console.log(isRev(a));<br>","like_count":0},{"had_liked":false,"id":29851,"user_name":"小老鼠","can_delete":false,"product_type":"c1","uid":1257460,"ip_address":"","ucode":"C663A0C863A515","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/f4/2dede51a.jpg","comment_is_top":false,"comment_ctime":1538561267,"is_pvip":false,"replies":[{"id":"10841","content":"1. 你可以根据数组和链表的特点，结合业务需求来看。比如，你存储的数据需要支持排序，那用数组比较合适了。要支持快速查找，那也是数组比较合适了。如果要做频繁的删除、插入，就像举的LRU的例子，那就比较适合链表。<br>2. 这个要具体看了。如果数组申请的空间不大，内存可以满足，那就用数组吧。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538660130,"ip_address":"","comment_id":29851,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538561267","product_id":100017301,"comment_content":"1,可否总结下什么时候用数组？什么时候用链表？<br>2,对于嵌入式系统，空间比较缺乏，是不是应该用数组？但数组又要连续的空间，应该如何处理？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425739,"discussion_content":"1. 你可以根据数组和链表的特点，结合业务需求来看。比如，你存储的数据需要支持排序，那用数组比较合适了。要支持快速查找，那也是数组比较合适了。如果要做频繁的删除、插入，就像举的LRU的例子，那就比较适合链表。\n2. 这个要具体看了。如果数组申请的空间不大，内存可以满足，那就用数组吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538660130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29843,"user_name":"DADDYHINS","can_delete":false,"product_type":"c1","uid":1189131,"ip_address":"","ucode":"C5676EF53CA248","user_header":"https://static001.geekbang.org/account/avatar/00/12/25/0b/f9fc5255.jpg","comment_is_top":false,"comment_ctime":1538558733,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1538558733","product_id":100017301,"comment_content":"我的思路比较弱智，把原本的单链表逆置，写两个指针，遍历两个链表并比较它们指向的元素是否相同，这样做的时间复杂度是O(n^2)，但是空间需求大🤔。坐等更好的解答","like_count":0},{"had_liked":false,"id":29835,"user_name":"PoetAndPoem","can_delete":false,"product_type":"c1","uid":1240028,"ip_address":"","ucode":"5BA46BFE497F32","user_header":"https://static001.geekbang.org/account/avatar/00/12/eb/dc/ae5485bb.jpg","comment_is_top":false,"comment_ctime":1538556458,"is_pvip":false,"replies":[{"id":"10719","content":"注意是单链表","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538581481,"ip_address":"","comment_id":29835,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538556458","product_id":100017301,"comment_content":"回文问题关键在于两点:1.判断链表的中间位置2.从中间位置向两边开始依次比较是否相等。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425733,"discussion_content":"注意是单链表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538581481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29831,"user_name":"韩","can_delete":false,"product_type":"c1","uid":1218674,"ip_address":"","ucode":"75BB3E48AE7E45","user_header":"https://static001.geekbang.org/account/avatar/00/12/98/72/0dccb3e7.jpg","comment_is_top":false,"comment_ctime":1538555700,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538555700","product_id":100017301,"comment_content":"回文字符串用双向链表。<br>从头结点和尾结点逐个删除结点。头尾相同则删除。<br>最后判断剩余链表长度是否≤1，是则是回文字符串。<br>时间复杂度O(n),空间复杂度O(n)","like_count":0},{"had_liked":false,"id":29829,"user_name":"蝴蝶","can_delete":false,"product_type":"c1","uid":1193167,"ip_address":"","ucode":"8019924D99182F","user_header":"https://static001.geekbang.org/account/avatar/00/12/34/cf/0a316b48.jpg","comment_is_top":false,"comment_ctime":1538555245,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1538555245","product_id":100017301,"comment_content":"关于数组做LRU算法,我有一个想法,就是申明一个指定长度(n)的数组,将缓存的对象按照时间顺序一一保存,同时也保存一个缓存对象操作时的索引index.当去数组中查找缓存的对象时,按照从头至尾的方向遍历,时间复杂度O(n),当有找到指定的对象时,那就直接取出.当没有找到对象时,按照index的位置,向后算一位(如果后一位不存在,那就从头开始),并将对象缓存到那个位置,然后index向后移动1位.这样的情况,就保证了index处总是新的那个.","like_count":0},{"had_liked":false,"id":29822,"user_name":"就酱","can_delete":false,"product_type":"c1","uid":1193567,"ip_address":"","ucode":"9B6456702913C3","user_header":"https://static001.geekbang.org/account/avatar/00/12/36/5f/3350f4d2.jpg","comment_is_top":false,"comment_ctime":1538554303,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1538554303","product_id":100017301,"comment_content":"一个链表节点指针每次都从头节点开始遍历链表，到达尾节点时和头节点比较值，不同则返回结果；相同则把头尾节点都删除；循环直到游走的指针节点和头节点相同。<br>时间复杂度分析：循环次数 n+(n-2)+...+(n-2k+2) 其中 k 为循环次数，最坏情况 k = n&#47;2，最好情况 1，所以平均时间复杂度 O(n)","like_count":0,"discussions":[{"author":{"id":1042685,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/fd/abb7bfe3.jpg","nickname":"Langzi233","note":"","ucode":"5A21AC08FC089B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3727,"discussion_content":"不用删掉，删掉破坏了链表。只需要设置上一个回文字符作为新的循环的末尾即可。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564734830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29814,"user_name":"旅途","can_delete":false,"product_type":"c1","uid":1212902,"ip_address":"","ucode":"5022477E8E9441","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","comment_is_top":false,"comment_ctime":1538551364,"is_pvip":false,"replies":[{"id":"10724","content":"1. 为什么呢？能说一下你的理由吗？<br>2. 嗯，对的，文章里也并没有要遍历两遍呢","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1538581833,"ip_address":"","comment_id":29814,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538551364","product_id":100017301,"comment_content":"有一些问题<br>1.如果创建不了100个对象的数组，100个对象的链表也应该创建不了吧？<br>2.关于单向链表删除的问题，删除时使用遍历找到被删除的元素，被删除的前一个就是前置节点啊，不用需要再遍历一遍了吧","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425727,"discussion_content":"1. 为什么呢？能说一下你的理由吗？\n2. 嗯，对的，文章里也并没有要遍历两遍呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538581833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29805,"user_name":"Mr.钧👻","can_delete":false,"product_type":"c1","uid":1249939,"ip_address":"","ucode":"D781E030E79245","user_header":"https://static001.geekbang.org/account/avatar/00/13/12/93/3470fc43.jpg","comment_is_top":false,"comment_ctime":1538547073,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538547073","product_id":100017301,"comment_content":"链表，是一种线性的，一堆零散内存组成的数据结构。它删除和插入的时间复杂度是O(1)，查询的时间复杂度是O(n)。和数组正好相反。注意时间换空间，空间换时间的设计思路。","like_count":0},{"had_liked":false,"id":29801,"user_name":"牵手约定","can_delete":false,"product_type":"c1","uid":1249461,"ip_address":"","ucode":"01AF328FDDD38C","user_header":"https://static001.geekbang.org/account/avatar/00/13/10/b5/0813608c.jpg","comment_is_top":false,"comment_ctime":1538546402,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538546402","product_id":100017301,"comment_content":"一直跟着老师的步伐走。","like_count":0},{"had_liked":false,"id":29800,"user_name":"张初炼","can_delete":false,"product_type":"c1","uid":1023546,"ip_address":"","ucode":"FED261D077DC8F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9e/3a/7d70960c.jpg","comment_is_top":false,"comment_ctime":1538544366,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538544366","product_id":100017301,"comment_content":"暂时想到了两个办法。<br>1. 创建一个新的单向链表。遍历原有的链表，遍历过程中把每一个节点存储的字符拷贝一份并插入到新链表的头部。得到的新链表相当于是把原有链表“倒置”了。最后同时遍历两个链表并比较每个节点，如果都相同则是回文字符串，否则不是。时间复杂度是 O(n)，空间复杂度也是 O(n)。<br><br>2. 遍历原有链表从而计算节点总个数 list_len。(list_len &#47; 2) 便是这个链表的“中间位置”。再次遍历链表，进行到“中间位置”后，依次把后面所有节点“转向”，即指向 prev 而非 next。结束后从链表的头和尾同时开始再做一个遍历(只进行到“中间位置”)，比较每次访问到节点字符，如果一直相等则是回文字符串，否则不是。时间复杂度是 O(n)，空间复杂度是 O(1)。","like_count":0},{"had_liked":false,"id":29797,"user_name":"hope","can_delete":false,"product_type":"c1","uid":1250784,"ip_address":"","ucode":"468A802184AB32","user_header":"https://static001.geekbang.org/account/avatar/00/13/15/e0/bc9f556c.jpg","comment_is_top":false,"comment_ctime":1538543315,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538543315","product_id":100017301,"comment_content":"看完了，打卡，希望老师上一些代码，个人觉得只有实践才会理解的更牢固，再就是评论区都是大神，可以多看","like_count":0},{"had_liked":false,"id":29795,"user_name":"甘远林","can_delete":false,"product_type":"c1","uid":1178148,"ip_address":"","ucode":"36048DAB42DC13","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/24/e1329796.jpg","comment_is_top":false,"comment_ctime":1538543129,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538543129","product_id":100017301,"comment_content":"刚查了一下什么是回文，哈哈。","like_count":0},{"had_liked":false,"id":29784,"user_name":"H~Z~G","can_delete":false,"product_type":"c1","uid":1199590,"ip_address":"","ucode":"1E0F51ECEC0566","user_header":"https://static001.geekbang.org/account/avatar/00/12/4d/e6/e530c9ee.jpg","comment_is_top":false,"comment_ctime":1538539593,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538539593","product_id":100017301,"comment_content":"回文这个是不是可以判断字符的右边界位置，通过递归每次二分判断呢？","like_count":0},{"had_liked":false,"id":29778,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1538538529,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538538529","product_id":100017301,"comment_content":"LRU-k算法时间复杂度和空间复杂度怎样？","like_count":0},{"had_liked":false,"id":29755,"user_name":"刘远通","can_delete":false,"product_type":"c1","uid":1253307,"ip_address":"","ucode":"4D3EE819E4B235","user_header":"https://static001.geekbang.org/account/avatar/00/13/1f/bb/c488d5db.jpg","comment_is_top":false,"comment_ctime":1538531783,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538531783","product_id":100017301,"comment_content":"遍历把链表存到数组里面 然后用数组随机访问的特点 判断是否是回文？","like_count":0},{"had_liked":false,"id":29753,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1538531023,"is_pvip":true,"discussion_count":1,"race_medal":1,"score":"1538531023","product_id":100017301,"comment_content":"请教一个问题啊，就是当数组的内存不够用的时候，去申请新的内存，为什么不先判断是否有靠近已申请内存的连续内存呢？有的话，是不是就可以利用上数组原来申请的内存了呢？在原内存上进行扩容呢？","like_count":0,"discussions":[{"author":{"id":1064752,"avatar":"","nickname":"码农翻身的小粉丝","note":"","ucode":"1FB018F749CE84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309113,"discussion_content":"如何在原内存上扩容呢，就算想用原来的内存，根据数组的定义也要先回收清空了再重新分配，不能直接append吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601190666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29750,"user_name":"张岳文","can_delete":false,"product_type":"c1","uid":1196820,"ip_address":"","ucode":"1CBAE7CE572E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/43/14/99aeb30d.jpg","comment_is_top":false,"comment_ctime":1538530034,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538530034","product_id":100017301,"comment_content":"用链表实现栈，很容易匹配这种成对出现的东西。<br>c++中的栈变量感觉就是这样的。比如int a; int b; 释放的时候就反过来release b; release a; 这不就是回文吗。还有函数调用栈。。还有xml各种成对匹配的文本格式。。<br><br>m缓存是什么。？","like_count":0},{"had_liked":false,"id":29745,"user_name":"涛","can_delete":false,"product_type":"c1","uid":1245815,"ip_address":"","ucode":"555B9877F6AA4D","user_header":"https://static001.geekbang.org/account/avatar/00/13/02/77/f307372e.jpg","comment_is_top":false,"comment_ctime":1538529011,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538529011","product_id":100017301,"comment_content":"如果解答需要经过别的数据结构去转换单链表，我不知道这个习题的意义是什么。老师给出的存储就是单链表，难道不是思考单链表的操作去判断回文吗？","like_count":0},{"had_liked":false,"id":29729,"user_name":"钢","can_delete":false,"product_type":"c1","uid":1106184,"ip_address":"","ucode":"A49848BF63A579","user_header":"https://static001.geekbang.org/account/avatar/00/10/e1/08/3dc76043.jpg","comment_is_top":false,"comment_ctime":1538524791,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538524791","product_id":100017301,"comment_content":"取中间节点，分割为两个链表，并将其中一个链表反序，然后匹配是否相等","like_count":0}]}