{"id":740880,"title":"第 10 章 保护 Web 安全(2)","content":"<h2 id=\"nav_point_158\">10.3　访问授权</h2>\n<p>通过上一节的学习，我们可以使用身份认证来判断谁能访问系统了，但一个系统通常会有很多功能，如果只是笼统地通过登录来控制，未免粒度太粗了。在登录进系统后，我们还希望能判断用户具体能访问哪个功能，这就是访问授权。每个用户可以有不同的权限，能访问什么，不能访问什么，都可以用 Spring Security 管理起来。</p>\n<h3 id=\"nav_point_159\">10.3.1　访问授权的判断方式</h3>\n<p>用户登录后，我们可以取得 Authentication 对象，其中有一系列 GrantedAuthority，它们就代表了当前用户拥有的权限，AccessDecisionManager 会读取这些权限进行判断：决策用户对于正在访问的目标是否拥有对应的权限。</p>\n<p>Spring Security 内置的 <code>AccessDecisionManager</code> 实现采用了投票的方式，一共有三种不同的决策方式，具体如表 10-7 所示。对于 Web 工程而言，<code>AbstractInterceptUrlConfigurer</code> 中默认使用了 <code>AffirmativeBased</code> 这个实现。</p>\n<p><strong>表 10-7　Spring Security 内置的 <code>AccessDecisionManager</code> 实现类</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>实现类</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>AffirmativeBased</code></p></td>\n<td><p>只需要有一票赞同即视为同意</p></td>\n</tr>\n<tr>\n<td><p><code>UnanimousBased</code></p></td>\n<td><p>需要所有成员都投赞同票才能视为同意</p></td>\n</tr>\n<tr>\n<td><p><code>ConsensusBased</code></p></td>\n<td><p>多数人投赞同票即视为同意</p></td>\n</tr>\n</tbody>\n</table>\n<p>那具体的投票动作又该谁来做呢？<code>AccessDecisionManager</code> 的实现类中都会注入一系列的 <code>AccessDecisionVoter</code>，<code>vote()</code> 方法负责具体的投票，返回可以是<strong>赞同</strong>（<code>ACCESS_GRANTED</code>，值是 <code>1</code>）、<strong>弃权</strong>（<code>ACCESS_ABSTAIN</code>，值是 <code>0</code>）和<strong>反对</strong>（<code>ACCESS_DENIED</code>，值是 <code>-1</code>）。Spring Security 中同样也内置了不少实现，例如，<code>RoleVoter</code> 就可以根据当前用户的角色来进行投票，拥有指定角色即投赞同票，否则投反对票。在 Spring Security 中，角色可以视为特殊的权限，以 <code>ROLE_</code> 打头，当然也可以设置别的前缀，不过一般不去调整。</p><!-- [[[read_end]]] -->\n<h3 id=\"nav_point_160\">10.3.2　基本的权限配置</h3>\n<p>在了解了框架中权限管理的基本知识后，让我们通过二进制奶茶店的例子来看看 Spring Security 权限的具体用法。</p>\n<blockquote>\n<p><strong>需求描述</strong>　二进制奶茶店的经营逐渐步入正规，生意越来越好了，两个员工已经无法满足日常的经营需要，店长打算再招一些员工。人多了，管理权限就要设置得更细一点儿。现在希望按表 10-8 这样来设计对菜单和订单的权限。</p>\n<p><strong>表 10-8　不同用户对菜单和订单的访问权限</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>角色</p></th>\n<th><p>权限</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>路人</p></td>\n<td><p>看菜单</p></td>\n</tr>\n<tr>\n<td><p>到店顾客</p></td>\n<td><p>看菜单，看订单</p></td>\n</tr>\n<tr>\n<td><p>调茶师</p></td>\n<td><p>看菜单，看订单，下订单</p></td>\n</tr>\n<tr>\n<td><p>店长</p></td>\n<td><p>看菜单，改菜单，看订单，下订单</p></td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<p>根据需求，我们得知一共需要四种权限，即 <code>READ_MENU</code>、<code>WRITE_MENU</code>、<code>READ_ORDER</code> 和 <code>WRITE_ORDER</code>。路人其实就是我们通常所说的匿名用户，在 Spring Security 中，无须权限控制，可以像之前那样配置 <code>permitAll()</code>，但如果是既希望开放给未登录的人访问，又希望这个 URL 的访问是有权限要求的，就可以使用匿名用户，为匿名用户赋予一定的权限。</p>\n<p>通过 <code>HttpSecurity</code> 的 <code>anonymous()</code> 方法可以设置匿名用户相关的内容，例如 <code>authorities()</code> 可以设置拥有的权限，<code>key()</code> 可以设置流程中传递匿名身份信息的参数名。</p>\n<p>代码示例 10-23<span class=\"comment-number\">16</span> 中就配置了匿名用户的相关选项，还有各个路径对应的权限信息。可以看到，我们为匿名用户赋予了 <code>READ_MENU</code> 的权限，针对 <code>/menu</code> 及 <code>/menu/**</code> 的 <code>GET</code> 请求都需要这个权限。对 <code>/menu</code> 和 <code>/order</code> 的 <code>GET</code> 和 <code>POST</code> 请求，我们都做了相应的权限控制。</p>\n\n<blockquote>\n<p><strong>代码示例 10-23</strong>　针对各个 URL 的访问权限配置</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.anonymous()\n                .key(\"binarytea_anonymous\")\n                .authorities(\"READ_MENU\").and()\n            .authorizeRequests()\n                .antMatchers(\"/\").permitAll()\n                .mvcMatchers(\"/actuator/*\").permitAll()\n                .mvcMatchers(HttpMethod.GET, \"/menu\", \"/menu/**\").hasAuthority(\"READ_MENU\")\n                .mvcMatchers(HttpMethod.POST, \"/menu\").hasAuthority(\"WRITE_MENU\")\n                .mvcMatchers(HttpMethod.GET, \"/order\").hasAuthority(\"READ_ORDER\")\n                .mvcMatchers(HttpMethod.POST, \"/order\").hasAuthority(\"WRITE_ORDER\")\n                .anyRequest().authenticated().and()\n            // 省略其他配置\n    }\n    // 省略其他代码\n}</code></pre>\n<p>假设我们最早的 <code>LiLei</code> 和 <code>HanMeimei</code> 分别是调茶师和经理的角色，那他们就要有相应的权限，<code>HanMeimei</code> 是用代码创建的，那这段代码就要调整为代码示例 10-24 那样，配置完整的权限。</p>\n<blockquote>\n<p><strong>代码示例 10-24</strong>　调整了权限的 <code>HanMeimei</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Bean\npublic UserDetailsService userDetailsService(ObjectProvider&lt;DataSource&gt; dataSources) {\n    JdbcUserDetailsManager userDetailsManager = new JdbcUserDetailsManager();\n    userDetailsManager.setDataSource(dataSources.getIfAvailable());\n    UserDetails manager = User.builder().username(\"HanMeimei\")\n        .password(\"$2a$10$iAty2GrJu9WfpksIen6qX.vczLmXlp.1q1OHBxWEX8BIldtwxHl3u\")\n        .authorities(\"READ_MENU\", \"WRITE_MENU\", \"READ_ORDER\", \"WRITE_ORDER\").build();\n    userDetailsManager.createUser(manager);\n    return userDetailsManager;\n}</code></pre>\n<p>而 <code>LiLei</code> 则是在 data.sql 中通过 SQL 代码初始化的，顺便我们再加一位普通用户张三，截取出的具体 SQL 如代码示例 10-25 所示。</p>\n<blockquote>\n<p><strong>代码示例 10-25</strong>　<code>LiLei</code> 和 <code>ZhangSan</code> 的初始化 SQL</p>\n</blockquote>\n<pre class=\"code-rows\"><code>insert into users (username, password, enabled) values ('LiLei', '$2a$10$iAty2GrJu9WfpksIen6qX.vczLmXlp.1q1OHBxWEX8BIldtwxHl3u', true);\ninsert into authorities (username, authority) values ('LiLei', 'READ_MENU');\ninsert into authorities (username, authority) values ('LiLei', 'READ_ORDER');\ninsert into authorities (username, authority) values ('LiLei', 'WRITE_ORDER');\n\ninsert into users (username, password, enabled) values ('ZhangSan',\n    '$2a$10$iAty2GrJu9WfpksIen6qX.vczLmXlp.1q1OHBxWEX8BIldtwxHl3u', true);\ninsert into authorities (username, authority) values ('ZhangSan', 'READ_MENU');\ninsert into authorities (username, authority) values ('ZhangSan', 'READ_ORDER');</code></pre>\n<p>上面的例子中，我们为一个用户配置了好多权限，不免有些麻烦，如果配置能简单些就更好了。根据表 10-8，我们设置四种不同的角色，分别是 <code>ROLE_ANONYMOUS</code>、<code>ROLE_USER</code>、<code>ROLE_TEA_MAKER</code> 和 <code>ROLE_MANAGER</code>，对应有用表中的不同权限。然后调整 <code>HanMeimei</code>、<code>LiLei</code> 和 <code>ZhangSan</code> 的角色，不再配置详细的权限，直接配置不同的角色，就像代码示例 10-26<span class=\"comment-number\">17</span> 与代码示例 10-27 那样。代码示例 10-26 中通过 <code>UserBuilder.roles()</code> 方法可以直接设置角色，设置时无须带 <code>ROLE_</code> 前缀，Spring Security 会自动根据配置为我们带上前缀。</p>\n\n<blockquote>\n<p><strong>代码示例 10-26</strong>　为 <code>HanMeimei</code> 设置角色</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Bean\npublic UserDetailsService userDetailsService(ObjectProvider&lt;DataSource&gt; dataSources) {\n    JdbcUserDetailsManager userDetailsManager = new JdbcUserDetailsManager();\n    userDetailsManager.setDataSource(dataSources.getIfAvailable());\n    UserDetails manager = User.builder().username(\"HanMeimei\")\n        .password(\"$2a$10$iAty2GrJu9WfpksIen6qX.vczLmXlp.1q1OHBxWEX8BIldtwxHl3u\")\n        .roles(\"MANAGER\").build();\n    userDetailsManager.createUser(manager);\n    return userDetailsManager;\n}</code></pre>\n<blockquote>\n<p><strong>代码示例 10-27</strong>　为 <code>LiLei</code> 和 <code>ZhangSan</code> 设置角色</p>\n</blockquote>\n<pre class=\"code-rows\"><code>insert into users (username, password, enabled) values ('LiLei',\n    '$2a$10$iAty2GrJu9WfpksIen6qX.vczLmXlp.1q1OHBxWEX8BIldtwxHl3u', true);\ninsert into authorities (username, authority) values ('LiLei', 'ROLE_TEA_MAKER');\n\ninsert into users (username, password, enabled) values ('ZhangSan',\n    '$2a$10$iAty2GrJu9WfpksIen6qX.vczLmXlp.1q1OHBxWEX8BIldtwxHl3u', true);\ninsert into authorities (username, authority) values ('ZhangSan', 'ROLE_USER');</code></pre>\n<p>URL 对应的权限配置可以调整成下面这样，不过这种方式看起来也很复杂，只是把原本加在用户上的那些要不断重复的权限管理搬到了代码里，只需要配置一次就可以了：<span class=\"comment-number\">18</span></p>\n\n<pre class=\"code-rows\"><code>@Override\nprotected void configure(HttpSecurity http) throws Exception {\n    http.anonymous()\n        .key(\"binarytea_anonymous\").and()\n        .authorizeRequests()\n            .antMatchers(\"/\").permitAll()\n            .mvcMatchers(\"/actuator/*\").permitAll()\n            .mvcMatchers(HttpMethod.GET, \"/menu\", \"/menu/**\")\n            .hasAnyRole(\"ANONYMOUS\", \"USER\", \"TEA_MAKER\", \"MANAGER\")\n            .mvcMatchers(HttpMethod.POST, \"/menu\").hasRole(\"MANAGER\")\n            .mvcMatchers(HttpMethod.GET, \"/order\").hasAnyRole(\"USER\", \"TEA_MAKER\", \"MANAGER\")\n            .mvcMatchers(HttpMethod.POST, \"/order\").hasAnyRole(\"TEA_MAKER\", \"MANAGER\")\n            .anyRequest().authenticated().and()\n        // 省略其他配置\n}</code></pre>\n<p>那有没有更简单的方式呢？答案是肯定的。我们可以建立一个角色与权限的映射关系，通常在实际生产中会将这些信息与用户一起配置在数据库里，这里我们简单一些，将这些映射固化在代码中。我们可以像代码示例 10-28 那样实现自己的 <code>UserDetailsManager</code>，通过 <code>JdbcUserDetailsManager</code> 预留的 <code>addCustomAuthorities()</code> 扩展点，根据已知权限中有用的角色信息（即 <code>ROLE_</code> 打头的权限），添加该角色对应的权限。这样一来，在用户侧就只需要配置角色，每个 URL 也只需要配置所需权限就可以了。<code>WebSecurityConfiguration</code> 的 <code>configure()</code> 改回代码示例 10-23，<code>userDetailsService()</code> 方法返回的 Bean 从 <code>JdbcUserDetailsManager</code> 改为 <code>RoleBasedJdbcUserDetailsManager</code> 类型就可以了。</p>\n<blockquote>\n<p><strong>代码示例 10-28</strong>　包含用户角色配置的 <code>RoleBasedJdbcUserDetailsManager</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Setter\npublic class RoleBasedJdbcUserDetailsManager extends JdbcUserDetailsManager {\n    private Map&lt;String, List&lt;GrantedAuthority&gt;&gt; roleAuthoritiesMap = new HashMap&lt;&gt;();\n\n    public RoleBasedJdbcUserDetailsManager() {\n        roleAuthoritiesMap.put(\"ROLE_USER\", AuthorityUtils.createAuthorityList(\"READ_MENU\", \"READ_ORDER\"));\n        roleAuthoritiesMap.put(\"ROLE_TEA_MAKER\", AuthorityUtils.createAuthorityList(\"READ_MENU\", \"READ_ORDER\", \"WRITE_ORDER\"));\n        roleAuthoritiesMap.put(\"ROLE_MANAGER\", AuthorityUtils.createAuthorityList(\"READ_MENU\", \"WRITE_MENU\", \"READ_ORDER\", \"WRITE_ORDER\"));\n    }\n\n    @Override\n    protected void addCustomAuthorities(String username, List&lt;GrantedAuthority&gt; authorities) {\n        new ArrayList&lt;&gt;(authorities).stream().filter(ga -&gt; ga.getAuthority().toUpperCase()\n            .startsWith(\"ROLE_\")).forEach(r -&gt; authorities.addAll(roleAuthoritiesMap.get(r.getAuthority())));\n    }\n}</code></pre>\n<p>在设置 URL 的权限时，我们可以使用表 10-9 中的方法，在上面的例子里其实已经用到了 <code>hasAuthority()</code>、<code>hasAnyAuthority()</code> 和 <code>hasRole()</code>。</p>\n<p><strong>表 10-9　设置权限时的常用方法</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>配置方法</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>hasAuthority()</code></p></td>\n<td><p>拥有某种权限</p></td>\n</tr>\n<tr>\n<td><p><code>hasAnyAuthority()</code></p></td>\n<td><p>拥有指定权限中的一种或几种</p></td>\n</tr>\n<tr>\n<td><p><code>hasRole()</code></p></td>\n<td><p>拥有某种角色，这里写角色时不需要 <code>ROLE_</code> 前缀</p></td>\n</tr>\n<tr>\n<td><p><code>hasAnyRole()</code></p></td>\n<td><p>拥有指定角色中的一种或几种，这里写角色时不需要 <code>ROLE_</code> 前缀</p></td>\n</tr>\n<tr>\n<td><p><code>anonymous()</code></p></td>\n<td><p>当前是匿名用户</p></td>\n</tr>\n<tr>\n<td><p><code>authenticated()</code></p></td>\n<td><p>当前是经过认证的用户，通过“记住我”获取到信息的用户也算认证过的</p></td>\n</tr>\n<tr>\n<td><p><code>fullyAuthenticated()</code></p></td>\n<td><p>当前用户是经过完整身份认证的，也就是非“记住我”的用户</p></td>\n</tr>\n<tr>\n<td><p><code>rememberMe()</code></p></td>\n<td><p>当前是“记住我”认证的用户</p></td>\n</tr>\n<tr>\n<td><p><code>hasIpAddress()</code></p></td>\n<td><p>符合特定 IP 地址规则，例如 192.168.0.0/16</p></td>\n</tr>\n<tr>\n<td><p><code>permitAll()</code></p></td>\n<td><p>所有人都可以访问</p></td>\n</tr>\n<tr>\n<td><p><code>denyAll()</code></p></td>\n<td><p>所有人都不能访问</p></td>\n</tr>\n<tr>\n<td><p><code>not()</code></p></td>\n<td><p>规则取反</p></td>\n</tr>\n<tr>\n<td><p><code>access()</code></p></td>\n<td><p>通过表达式指定复杂的规则</p></td>\n</tr>\n</tbody>\n</table>\n<p>关于最后一个 <code>access()</code> 方法，可以指定比较复杂的表达式，我们可以将代码示例 10-23 中的 <code>configure()</code> 稍作修改，变成代码示例 10-29 这样。无须再为匿名用户指定某个权限，而是在 <code>/menu</code> 和 <code>/menu/**</code> 的规则中指定是匿名用户或者有 <code>READ_MENU</code> 权限都可访问。</p>\n<blockquote>\n<p><strong>代码示例 10-29</strong>　使用 <code>access()</code> 配置的代码</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Override\nprotected void configure(HttpSecurity http) throws Exception {\n    http.anonymous()\n            .key(\"binarytea_anonymous\").and()\n        .authorizeRequests()\n            .antMatchers(\"/\").permitAll()\n            .mvcMatchers(\"/actuator/*\").permitAll()\n            .mvcMatchers(HttpMethod.GET, \"/menu\", \"/menu/**\")\n            .access(\"isAnonymous() or hasAuthority('READ_MENU')\")\n            .mvcMatchers(HttpMethod.POST, \"/menu\").hasAuthority(\"WRITE_MENU\")\n            .mvcMatchers(HttpMethod.GET, \"/order\").hasAuthority(\"READ_ORDER\")\n            .mvcMatchers(HttpMethod.POST, \"/order\").hasAuthority(\"WRITE_ORDER\")\n            .anyRequest().authenticated().and()\n        // 省略其他配置\n}</code></pre>\n<p><code>access()</code> 中可用的表达式大部分与表 10-9 中的方法差不多，例如 <code>hasAuthority()</code>、<code>hasAnyAuthority()</code>、<code>hasRole</code> 和 <code>hasAnyRole()</code>；“所有人都可以访问”和“所有人都不能访问”不再是方法了，而是用 <code>permitAll</code> 和 <code>denyAll</code>，直接代表了返回 <code>true</code> 和 <code>false</code>；对于是否经过认证的判断加上了 <code>is</code> 前缀，变为了 <code>isAnonymous()</code>、<code>isRememberMe()</code>、<code>isAuthenticated()</code> 和 <code>isFullyAuthenticated()</code>；<code>principal</code> 和 <code>authentication</code> 则分别表示了当前登录用户的主体信息，以及 <code>SecurityContext</code> 中的 <code>Authentication</code> 对象。</p>\n<h3 id=\"nav_point_161\">10.3.3　面向方法的访问授权</h3>\n<p>之前我们介绍的授权都是与 Web 相关的，在 Web 页面或者 REST 服务上进行控制，但实际上 Spring Security 能做到的还不止于此，它能根据当前用户的情况在方法级别上进行校验，决定当前登录的用户能否调用特定的方法。<span class=\"comment-number\">19</span> 通过 Spring Security 提供的注解，或者是 JSR 250<span class=\"comment-number\">20</span> 的注解，可以在方法执行前后做些相对简单的判断，例如是否拥有某种角色，从而决定能否执行方法。这些注解一般是加在领域服务层的方法上的。</p>\n\n\n<p>在 Java 配置类上添加 <code>@EnableGlobalMethodSecurity</code> 注解就能开启方法权限控制的功能，表 10-10 列出了其中的几个重要属性，它们的默认值都是 <code>false</code>。</p>\n<p><strong>表 10-10　<code>@EnableGlobalMethodSecurity</code> 注解的重要属性</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>属性</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>securedEnabled</code></p></td>\n<td><p>是否开启 <code>@Secured</code> 注解支持</p></td>\n</tr>\n<tr>\n<td><p><code>prePostEnabled</code></p></td>\n<td><p>是否开启 <code>@PreAuthorize</code>、<code>@PostAuthorize</code>、<code>@PreFilter</code> 和 <code>@PostFilter</code> 注解的支持</p></td>\n</tr>\n<tr>\n<td><p><code>jsr250Enabled</code></p></td>\n<td><p>是否开启 JSR 250 注解的支持，例如 <code>@DenyAll</code> 和 <code>@PermitAll</code></p></td>\n</tr>\n</tbody>\n</table>\n<p><code>@Secured</code>、<code>@PreXxx</code> 和 <code>@PostXxx</code> 注解都是 Spring Security 提供的注解，<code>@Secured</code> 是 Spring Security 2.0 引入的，在配置上的灵活性稍差，3.0 的时候又引入了新的几个注解，能够支持较为复杂的表达式，使用上一部分最后提到的表达式进行配置。</p>\n<p>依然是前面用到的权限控制的需求，我们来看看如果要在服务层的方法上进行控制该如何实现。先在 <code>WebSecurityConfiguration</code> 上添加 <code>@EnableGlobalMethodSecurity</code> 注解，开启各种注解支持，然后尝试在 <code>MenuService</code> 和 <code>OrderService</code> 上使用不同类型的注解：</p>\n<pre class=\"code-rows\"><code>@Configuration\n@EnableWebSecurity\n@EnableGlobalMethodSecurity(securedEnabled = true,\n                               prePostEnabled = true,\n                               jsr250Enabled = true)\npublic class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {...}</code></pre>\n<p>代码示例 10-30 中，我们为两个修改菜单的方法加上了 <code>@PreAuthorize</code> 注解，判断是否拥有写菜单的权限。<span class=\"comment-number\">21</span> 所谓 <code>Pre</code> 就是在某操作之前，<code>@PreAuthorize</code> 会在方法执行前进行权限判断，而 <code>@PostAuthorize</code> 则是在方法执行后，表达式中使用 <code>returnObject</code> 可以取得方法的返回值；<code>@PreFilter</code> 和 <code>@PostFilter</code> 则是用来对集合进行过滤的，表达式中使用 <code>filterObject</code> 可以取得集合中当前的元素，判断它是否要被过滤。</p>\n\n<blockquote>\n<p><strong>代码示例 10-30</strong>　增加了 <code>@PreAuthorize</code> 注解的 <code>MenuService</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Service\n@Transactional\n@CacheConfig(cacheNames = \"menu\")\npublic class MenuService {\n    @Autowired\n    private MenuRepository menuRepository;\n\n    @PreAuthorize(\"hasAuthority('WRITE_MENU')\")\n    public Optional&lt;MenuItem&gt; save(MenuItem menuItem) {\n        return Optional.ofNullable(menuRepository.save(menuItem));\n    }\n\n    @PreAuthorize(\"hasAuthority('WRITE_MENU')\")\n    public List&lt;MenuItem&gt; save(List&lt;MenuItem&gt; items) {\n        return menuRepository.saveAll(items);\n    }\n    // 省略其他代码\n}</code></pre>\n<p>代码示例 10-31 则演示了 <code>@Secured</code> 注解和 JSR 250 注解的用法。<code>@Secured</code> 注解里可以直接添加要判断的权限，因为角色其实就是带了 <code>ROLE_</code> 前缀的权限，所以可以像 <code>getAllOrders()</code> 那样判断是否拥有 <code>MANAGER</code>、<code>TEA_MAKER</code> 和 <code>USER</code> 角色。JSR 250 中权限相关的注解有代表全都允许的 <code>@PermitAll</code>，全不允许的 <code>@DenyAll</code>，允许某些角色的 <code>@RolesAllowed</code>，以某个角色运行的 <code>@RunAs</code>，还有定义安全角色的 <code>@DeclareRoles</code>。在代码示例 10-31 中我们就用到了 <code>@RolesAllowed</code>，指定需要有 <code>MANAGER</code> 或者 <code>TEA_MAKER</code> 角色才能执行 <code>createOrder()</code> 方法。</p>\n<blockquote>\n<p><strong>代码示例 10-31</strong>　增加了 <code>@Secured</code> 注解和 <code>@RolesAllowed</code> 注解的 <code>OrderService</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Service\n@Transactional\npublic class OrderService {\n    @Autowired\n    private OrderRepository orderRepository;\n\n    @Secured({ \"ROLE_MANAGER\", \"ROLE_TEA_MAKER\", \"ROLE_USER\" })\n    public List&lt;Order&gt; getAllOrders() {\n        return orderRepository.findAll();\n    }\n\n    @RolesAllowed({ \"MANAGER\", \"TEA_MAKER\" })\n    public Order createOrder(List&lt;MenuItem&gt; itemList, int discount) {\n        // 省略具体代码\n    }\n    // 省略其他代码\n}</code></pre>\n<p>由于方法上增加了权限校验，我们之前的单元测试也要稍作调整。例如，<code>OrderControllerTest</code> 中的 <code>testOrderPageWithAuthenticatedUser()</code> 需要在用户上添加一些权限，如代码示例 10-32 所示。这里的 <code>authorities()</code> 和 <code>roles()</code> 最终都是设置模拟用户的权限，两者只能选择其一，因为需要 <code>READ_ORDER</code> 权限，所以这里只能用 <code>authorities()</code>。</p>\n<blockquote>\n<p><strong>代码示例 10-32</strong>　增加了权限的测试用例</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Test\nvoid testOrderPageWithAuthenticatedUser() throws Exception {\n    mockMvc.perform(get(\"/order\").with(user(\"LiLei\")\n            .authorities(AuthorityUtils.createAuthorityList(\"READ_ORDER\", \"ROLE_TEA_MAKER\"))))\n            .andExpect(status().is2xxSuccessful());\n    mockMvc.perform(get(\"/order\").with(httpBasic(\"LiLei\", \"binarytea\")))\n            .andExpect(status().is2xxSuccessful());\n}</code></pre>\n<blockquote>\n<p><strong>茶歇时间：如何忽略权限校验</strong></p>\n<p>在一个真实的 Web 系统中，或多或少有些 URL 是无须登录就能访问的，或者是彻底不需要安全校验的，例如 CSS 和图片这样的静态资源。这里就以 <code>/static</code> 为例，说明一下在 Spring Security 中如何对符合特定规则的 URL 设置放行，例如：</p>\n<ul>\n<li>将 <code>/static/**</code> 设置为匿名用户和登录用户都可访问的，就像代码示例 10-29 那样；</li>\n<li>通过 <code>permitAll()</code>，将 <code>/static/**</code> 设置为允许所有人访问的；</li>\n<li>通过 <code>WebSecurity</code> 的 <code>ignoring()</code> 方法，直接将 <code>/static/**</code> 忽略掉。</li>\n</ul>\n<p>代码示例 10-33 演示了第三种方法，也是在继承了 <code>WebSecurityConfigurerAdapter</code> 的 Java 配置类中，覆盖 <code>configure()</code>，通过参数中传入的 <code>WebSecurity</code> 来进行设置。</p>\n<p><strong>代码示例 10-33</strong>　调用 <code>WebSecurity.ignoring()</code> 设置忽略的路径</p>\n<pre class=\"code-rows\"><code>public class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {\n    @Override\n    public void configure(WebSecurity web) throws Exception {\n        web.ignoring().antMatchers(\"/error\", \"/static/**\");\n    }\n    // 省略其他代码\n}</code></pre>\n<p>再次强调，<strong>如果条件允许，静态资源应该放置在静态资源服务器上</strong>，哪怕与 Java 应用放在同一台服务器上，也推荐由 Nginx 这样的 Web 服务器来专门提供静态资源服务，而不是让 Java 应用来响应静态资源请求。</p>\n</blockquote>\n<h2 id=\"nav_point_162\">10.4　常见 Web 攻击防护</h2>\n<p>普通用户的正常访问一般不会对系统有什么大的风险，但是，只要攻击能够带来收益，就会有人惦记我们的系统。正所谓“害人之心不可有，防人之心不可无”，我们心中最好还是能够紧绷一根弦，时刻担心“总有刁民想害朕”——本节就让我们来了解几种常见的 Web 攻击方式及其对应的防御手段。</p>\n<h3 id=\"nav_point_163\">10.4.1　跨站请求伪造攻击防护</h3>\n<p><strong>跨站请求伪造</strong>（Cross Site Request Forgery）被简称为 CSRF 或 XSRF，这种攻击通常指通过某种手段在用户已登录的 Web 程序上执行不是用户本意的操作。维基百科中有一个定义：</p>\n<blockquote>\n<p>CSRF 是对 Web 站点的一种恶意攻击，攻击者通过 Web 站点信任的用户发出了未经授权的请求。</p>\n</blockquote>\n<p>举个例子，假设 A 银行有个转账的 URL 是 <code>/transfer</code>，接收 HTTP <code>POST</code> 请求，请求参数中包含了转出卡号和目标转入卡号。接收请求后，系统会判断当前登录的账户中是否包含了转出卡号，如果有，就代表了是当前账户想从自己的银行卡转钱到他人的银行卡。张三 1 分钟前刚登录了 A 银行的网银，攻击者发给了他一个 X 网站的 URL，说是有促销活动，诱导张三打开了这个网页，在网页里嵌了一段用户不可见的 JavaScript 代码，就是通过 AJAX 向 A 银行的 <code>/transfer</code> 地址发起 <code>POST</code> 请求，给攻击者转 1000 元。这时由于张三在 A 银行网银的 Cookies 还未失效，所以网银会认为这就是张三自己发出的请求，执行了转账的指令。</p>\n<p>当然，我们必须要说明一下，这里的例子只是设想出来的，真实的银行系统可比这要复杂得多，有着多重校验和安全保护，不是这么脆弱的。但这个例子应该能够说明整个 CSRF 的攻击原理了，那么我们该如何对敌呢？</p>\n<p>首先想到的应该就是针对重要的页面和接口，只信任自己站点发来的请求。回到上面的例子，就是 <code>/transfer</code> 只接收来自 A 银行网页页面发起的请求，X 网站发来的就不行。HTTP 协议中的 <code>Referer</code> 头就是用来标明请求来源的，通过这个 <code>Referer</code> 可以识别哪些请求是可以信任的。但对于攻击者而言，<code>Referer</code> 的内容太容易伪造了，基本就和改请求的 <code>Agent</code> 没什么区别，所以这种方式的防御效果并不理想。</p>\n<p>要禁止他人伪造请求，可以给一个一次性使用的令牌，请求过来一次就核销掉，不能二次使用，这样即使攻击者拿到了之前的令牌也不能重复发起请求。令牌本身也需要有过期时间，万一没被使用过，就被攻击者获取了，有个较短的过期时间也能规避一定风险。所以，<strong>我们可以考虑在重要的请求里带上一个 CSRF 令牌</strong>。</p>\n<p>Spring Security 中已经内置了对 CSRF 令牌的支持，之前身份认证的例子中其实已经用到了 CSRF 令牌，只是当时没有展开。可以通过 <code>HttpSecurity</code> 的 <code>csrf()</code> 方法对各种需要或者不需要 CSRF 防护的 URL 进行设置，表 10-11 中列出了几个常用的配置方法。</p>\n<p><strong>表 10-11　常用的 CSRF 相关配置方法</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>配置方法</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>disable()</code></p></td>\n<td><p>禁用 CSRF 防护</p></td>\n</tr>\n<tr>\n<td><p><code>ignoringAntMatchers()</code></p></td>\n<td><p>要忽略 CSRF 防护的 URL 规则</p></td>\n</tr>\n<tr>\n<td><p><code>requireCsrfProtectionMatcher()</code></p></td>\n<td><p>需要 CSRF 防护的 <code>RequestMatcher</code>，<code>RequestMatcher</code> 可以对请求做详细的规则判断，默认忽略 <code>GET</code>、<code>HEAD</code>、<code>TRACE</code> 和 <code>OPTIONS</code> 的请求</p></td>\n</tr>\n<tr>\n<td><p><code>ignoringRequestMatchers()</code></p></td>\n<td><p>要忽略 CSRF 防护的 <code>RequestMatcher</code>，即使命中 <code>requireCsrfProtectionMatcher()</code> 的规则，也会忽略</p></td>\n</tr>\n<tr>\n<td><p><code>csrfTokenRepository()</code></p></td>\n<td><p>传入用于存储 CSRF 令牌的 <code>CsrfTokenRepository</code>，例如 <code>HttpSessionCsrfTokenRepository</code></p></td>\n</tr>\n<tr>\n<td><p><code>sessionAuthenticationStrategy()</code></p></td>\n<td><p>传入认证用的 <code>HttpSession</code> 相关策略，例如 <code>CsrfAuthenticationStrategy</code> 会移除当前令牌，再重新生成一个新的放进 <code>CsrfTokenRepository</code></p></td>\n</tr>\n</tbody>\n</table>\n<p>二进制奶茶店也有一些页面容易受到 CSRF 攻击的威胁，出于安全考虑，我们需要对它们进行加固。</p>\n<blockquote>\n<p><strong>需求描述</strong>　下单后，用户需要进行支付，随后才能开始饮品制作等步骤。支付这个动作涉及二进制奶茶店的营收，需要保证页面上的支付收银操作的确是由店员执行的。</p>\n</blockquote>\n<p>在修改订单状态的表单中，我们可以通过引入 CSRF 令牌来避免恶意的攻击。Spring Security 的 <code>CsrfFilter</code> 为我们提供了 CSRF 令牌相关的支持，如果请求中没有令牌，则生成一个令牌，放到 <code>HttpServletRequest</code> 中，默认使用的属性名是 <code>_csrf</code>（如果是在 HTTP 头里包含令牌，则默认用的头是 <code>X-CSRF-TOKEN</code>），这个属性名可以在 <code>CsrfTokenRepository</code> 中进行调整。我们可以像下面这样在 HTML 表单中引入一个包含 CSRF 令牌的隐藏域。如果使用 Thymeleaf 模板，Thymeleaf 会自动将请求中的 CSRF 令牌带到表单中，省去了自己设置的麻烦。</p>\n<pre class=\"code-rows\"><code>&lt;input type=\"hidden\" name=\"$\" value=\"$\"/&gt;</code></pre>\n<p>我们需要在订单的控制器中增加一个修改订单状态的方法，HTTP 的 <code>PUT</code> 方法是用来修改资源的，我们就用 <code>@PutMapping</code> 来声明一个 <code>/order</code> 的 <code>PUT</code> 方法，提交的内容中包含要改为已支付状态的订单编号，具体如代码示例 10-34 所示，这段代码将请求内的参数转换为指定的形式传给服务层。<span class=\"comment-number\">22</span></p>\n\n<blockquote>\n<p><strong>代码示例 10-34</strong>　增加了修改订单为已支付状态的 <code>OrderController</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Controller\n@RequestMapping(\"/order\")\n@Slf4j\npublic class OrderController {\n    @PutMapping\n    public String modifyOrdersToPaid(@RequestParam(\"id\") String id, ModelMap modelMap) {\n        int successCount = 0;\n        if (StringUtils.isNotBlank(id)) {\n            List&lt;Long&gt; orderIdList = Arrays.stream(id.split(\",\"))\n                .map(s -&gt; NumberUtils.toLong(s, -1))\n                .filter(l -&gt; l &gt; 0)\n                .collect(Collectors.toList());\n            successCount = orderService.modifyOrdersState(orderIdList, OrderStatus.ORDERED, OrderStatus.PAID);\n        }\n        modelMap.addAttribute(new NewOrderForm());\n        modelMap.addAttribute(\"success_count\", successCount);\n        modelMap.addAttribute(\"orders\", orderService.getAllOrders());\n        return \"order\";\n    }\n    // 省略其他代码\n}</code></pre>\n<p>代码示例 10-35 的方法负责将指定订单取出，同时增加了条件，取出的订单必须是指定原始状态的，这样就过滤了其他状态的订单，再为它们设置新的状态保存起来。<code>WebSecurityConfiguration</code> 中我们只对 <code>GET</code> 和 <code>POST</code> 的 HTTP 方法设置了权限，可以考虑为 <code>PUT</code> 方法也增加权限控制，在示例中我们选择了在具体的服务层方法上增加 <code>@RolesAllowed</code> 注解来控制执行的权限。</p>\n<blockquote>\n<p><strong>代码示例 10-35</strong>　将订单从一个状态变为另一个状态的 <code>modifyOrdersState()</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Service\n@Transactional\npublic class OrderService {\n    @RolesAllowed({ \"MANAGER\", \"TEA_MAKER\" })\n    public int modifyOrdersState(List&lt;Long&gt; idList, OrderStatus oldState, OrderStatus newState) {\n        List&lt;Order&gt; orders = orderRepository.findByStatusEqualsAndIdInOrderById(oldState, idList);\n        orders.forEach(o -&gt; o.setStatus(newState));\n        return orderRepository.saveAll(orders).size();\n    }\n    // 省略其他代码\n}</code></pre>\n<p>由于使用了 Spring Data JPA，我们无须提供具体的实现，只需要在 <code>OrderRepository</code> 中定义如下的方法就行了：</p>\n<pre class=\"code-rows\"><code>List&lt;Order&gt; findByStatusEqualsAndIdInOrderById(OrderStatus status, List&lt;Long&gt; idList);</code></pre>\n<p>后台的方法准备就绪了，再来看看前台的页面模板。我们在订单页面 order.html 中做一些简单的修改，在页面下半部分的订单表格外面加一层 <code>&lt;form /&gt;</code> 表单，表格第一列增加一个复选框，一次可以选中多个订单，点击按钮提交。具体如代码示例 10-36 所示。</p>\n<blockquote>\n<p><strong>代码示例 10-36</strong>　增加了修改订单为“已付款”状态的 Thymeleaf 模板</p>\n</blockquote>\n<pre class=\"code-rows\"><code>&lt;h2&gt;订单&lt;/h2&gt;\n&lt;div&gt;\n    &lt;form action=\"#\" th:action=\"@{/order}\" method=\"post\"&gt;\n        &lt;p th:if=\"$\"&gt;更新了&lt;span th:text=\"$\"&gt;N&lt;/span&gt;条记录&lt;/p&gt;\n        &lt;p&gt;\n            &lt;table border=\"1px\"&gt;\n                &lt;thead&gt;\n                &lt;tr&gt;\n                    &lt;th&gt;选择&lt;/th&gt;\n                    &lt;th&gt;订单编号&lt;/th&gt;\n                    &lt;th&gt;总价&lt;/th&gt;\n                    &lt;th&gt;实付&lt;/th&gt;\n                    &lt;th&gt;状态&lt;/th&gt;\n                    &lt;th&gt;内容&lt;/th&gt;\n                &lt;/tr&gt;\n                &lt;/thead&gt;\n                &lt;tbody&gt;\n                &lt;tr th:each=\"order : $\"&gt;\n                    &lt;td&gt;&lt;input name=\"id\" type=\"checkbox\" th:value=\"$\" value=\"1\"/&gt;&lt;/td&gt;\n                    &lt;td th:text=\"$\"&gt;1&lt;/td&gt;\n                    &lt;td th:text=\"$\"&gt;CNY 12.0&lt;/td&gt;\n                    &lt;td th:text=\"$\"&gt;CNY 12.0&lt;/td&gt;\n                    &lt;td th:text=\"$\"&gt;ORDERED&lt;/td&gt;\n                    &lt;td&gt;\n                        &lt;div th:each=\"item : $\"&gt;\n                            &lt;label th:text=\"$\"&gt;Java咖啡&lt;/label&gt;-\n                            &lt;label th:text=\"$\"&gt;MEDIUM&lt;/label&gt;&lt;br/&gt;\n                        &lt;/div&gt;\n                    &lt;/td&gt;\n                &lt;/tr&gt;\n                &lt;/tbody&gt;\n            &lt;/table&gt;\n        &lt;/p&gt;\n        &lt;p&gt;\n            &lt;input type=\"submit\" value=\"已付款\" /&gt;\n            &lt;input type=\"hidden\" name=\"_method\" value=\"put\" /&gt;\n        &lt;/p&gt;\n    &lt;/form&gt;\n&lt;/div&gt;</code></pre>\n<p>由于浏览器只能发起 <code>GET</code> 和 <code>POST</code> 方法，所以 Spring MVC 为我们提供了模拟其他 HTTP 方法的方案，上面代码最后的 <code>_method</code> 隐藏域就提示了 Spring MVC 将这个 <code>POST</code> 提交的请求视为 <code>PUT</code>，整个过程是由 <code>HiddenHttpMethodFilter</code> 来实现的，Spring Boot 默认不自动创建这个 <code>Filter</code>，我们可以在 <code>application.properties</code> 中增加如下配置来开启相关支持：</p>\n<pre class=\"code-rows\"><code>spring.mvc.hiddenmethod.filter.enabled=true</code></pre>\n<p>因为 <code>_csrf</code> 太容易猜到了，所以我们想换个参数。在 <code>WebSecurityConfiguration</code> 里，我们自己定义一个 <code>CsrfTokenRepository</code>，就像代码示例 10-37 那样。</p>\n<blockquote>\n<p><strong>代码示例 10-37</strong>　增加了 <code>CsrfTokenRepository</code> 配置的 <code>WebSecurityConfiguration</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Configuration\n@EnableWebSecurity\n@EnableGlobalMethodSecurity(securedEnabled = true, prePostEnabled = true, jsr250Enabled = true)\npublic class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http// 省略其他配置\n            .csrf()\n            .csrfTokenRepository(tokenRepository());\n    }\n\n    @Bean\n    public CsrfTokenRepository tokenRepository() {\n        HttpSessionCsrfTokenRepository tokenRepository = new HttpSessionCsrfTokenRepository();\n        tokenRepository.setParameterName(\"_token\");\n        return tokenRepository;\n    }\n// 省略其他代码\n}</code></pre>\n<p>再查看 Thymeleaf 呈现出的 HTML 源码时，我们就会看到隐藏域的名称已经换成了 <code>_token</code>：</p>\n<pre class=\"code-rows\"><code>&lt;input type=\"hidden\" name=\"_token\" value=\"893814bc-4123-4da0-95a9-332a05fbe3bc\"/&gt;</code></pre>\n<p>为了保证代码的正确性，我们为 <code>modifyOrdersToPaid()</code> 增加几个测试用例。代码示例 10-38 中包含了两个用例，第一个是 CSRF 验证失败的情况，包括未带 CSRF 令牌和提供了无效的令牌；第二个是正常成功的情况。</p>\n<blockquote>\n<p><strong>代码示例 10-38</strong>　针对订单支付的测试用例</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootTest\nclass OrderControllerTest {\n    @Test\n    void testModifyOrdersToPaidWithCsrfFail() throws Exception {\n        mockMvc.perform(put(\"/order\")\n                .param(\"id\", \"1\").with(userLiLei()))\n                .andExpect(status().is4xxClientError());\n        mockMvc.perform(put(\"/order\")\n                .param(\"id\", \"1\").with(userLiLei())\n                .with(csrf().useInvalidToken()))\n                .andExpect(status().is4xxClientError());\n    }\n\n    @Test\n    void testModifyOrdersToPaid() throws Exception {\n        mockMvc.perform(put(\"/order\").param(\"id\", \"1\")\n                .with(userLiLei()).with(csrf()))\n                .andExpect(status().isOk())\n                .andExpect(view().name(\"order\"))\n                .andExpect(model().attribute(\"success_count\", 1));\n    }\n\n    private SecurityMockMvcRequestPostProcessors.UserRequestPostProcessor userLiLei() {\n        return user(\"LiLei\").authorities(AuthorityUtils.createAuthorityList(\"READ_ORDER\", \"ROLE_TEA_MAKER\"));\n    }\n    // 省略其他代码\n}</code></pre>\n<h3 id=\"nav_point_164\">10.4.2　会话固定攻击防护</h3>\n<p>如果一个系统的会话标识符能被很轻松地固定下来（或者是被人猜出来），那攻击者就能将一个已知的会话发给受害者，让他用这个固定会话登录，从而获得该用户的权限，这就是<strong>会话固定攻击</strong>（Session Fixation Attack）。<span class=\"comment-number\">23</span> 在 Java Web 系统里，通常使用 <code>JSESSIONID</code> 来传递会话 ID，请求里带上这个属性很容易就能要求系统使用该会话 ID。假设攻击者一开始访问系统，拿到了一个 <code>JSESSIONID</code> 为 <code>12345</code> 的会话 ID，他还没有登录系统，随后他诱导用户张三访问了网站的 <code>login.html?JESSIONID=12345</code> 页面，张三登录了，这时攻击者再用相同的会话 ID 进行操作，他就有了张三的权限。</p>\n\n<p>好在 Spring　Security 为我们内置了解决方案，针对会话固定攻击，有四种处理方式，具体见表 10-12。</p>\n<p><strong>表 10-12　<code>SessionFixationConfigurer</code> 中的配置方法</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>配置方法</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>none()</code></p></td>\n<td><p>什么都不做，攻击成功了</p></td>\n</tr>\n<tr>\n<td><p><code>newSession()</code></p></td>\n<td><p>创建一个新会话，已有会话中除了 Spring Security 相关的属性外都不会被复制过来</p></td>\n</tr>\n<tr>\n<td><p><code>migrateSession()</code></p></td>\n<td><p>创建一个新会话，将已有会话中的内容复制过来，这是 Servlet 3.0 及更早之前的容器中的默认方案</p></td>\n</tr>\n<tr>\n<td><p><code>changeSessionId()</code></p></td>\n<td><p>已有会话可以继续使用，但是会话 ID 会变，并通知 <code>HttpSessionIdListener</code>，攻击者手上的会话 ID 就没用了，这是 Servlet 3.1 容器开始的默认方案</p></td>\n</tr>\n</tbody>\n</table>\n<p>例如，在扩展了 <code>WebSecurityConfigurerAdapter</code> 的配置类里，可以这样进行设置：</p>\n<pre class=\"code-rows\"><code>protected void configure(HttpSecurity http) throws Exception {\n    http.sessionManagement().sessionFixation().migrateSession();\n        .and(); // 省略后续的其他配置\n}</code></pre>\n<p>Spring Security 在会话的管理方面还有很多其他配置方法，表 10-13 里就罗列了一些。</p>\n<p><strong>表 10-13　<code>SessionManagementConfigurer</code> 中的配置方法</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>配置方法</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>sessionCreationPolicy()</code></p></td>\n<td><p>会话创建策略，用的是 <code>SessionCreationPolicy</code> 枚举，<code>ALWAYS</code> 是始终创建，<code>NEVER</code> 不创建但如果有会话就用，<code>IF_REQUIRED</code> 有需要就建，<code>STATELESS</code> 无状态，也不会用会话</p></td>\n</tr>\n<tr>\n<td><p><code>sessionFixation()</code></p></td>\n<td><p>有关会话固定攻击的相关配置</p></td>\n</tr>\n<tr>\n<td><p><code>maximumSessions()</code></p></td>\n<td><p>允许的最大会话数</p></td>\n</tr>\n<tr>\n<td><p><code>invalidSessionUrl()</code></p></td>\n<td><p>遇到无效会话 ID 时，将用户重定向到指定 URL</p></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"nav_point_165\">10.4.3　跨站脚本攻击防护</h3>\n<p><strong>跨站脚本</strong>（Cross Site Scripting，简称 XSS）<strong>攻击</strong>是一种常见的 Web 安全漏洞，攻击者通过网站的一些漏洞，在其页面上注入恶意代码。这些代码通常都是针对用户浏览器的脚本，浏览器本身很难分辨正在执行的脚本是网站本身的脚本，还是攻击者的恶意脚本。只要网站允许上传内容，在输出这些内容时又把关不严，就会给攻击者留下可乘之机，XSS 攻击注入的脚本可以读取用户的 Cookies、正在访问的页面上的敏感信息，甚至修改页面的内容，造成更严重的危害。</p>\n<p>无论是反射型的 XSS，还是持久型的 XSS，防御的思路都差不多，要么就是在收到输入的内容时进行编码或者过滤处理，要么就是在输出内容时进行处理，总之是让恶意代码无法发挥作用。OWASP 提供了一个高效简单的 Java Encoder，用类似下面的代码就能实现内容的处理：</p>\n<pre class=\"code-rows\"><code>String cleanHtml = Encode.forHtmlContent(rawHtml);\nString cleanCss = Encode.forCssString(rawCss);\nString cleanJs = Encode.forJavaScript(rawJs);</code></pre>\n<p>现代的主流浏览器也针对 XSS 攻击提供了一些防护，甚至可以直接阻断攻击，Spring Security 就提供了设置 <code>X-XSS-Protection</code> 头的机制。在扩展了 <code>WebSecurityConfigurerAdapter</code> 的配置类里，可以像下面这样设置 <code>XXssProtectionHeaderWriter</code>，默认就是开启保护，阻断攻击：</p>\n<pre class=\"code-rows\"><code>protected void configure(HttpSecurity http) throws Exception {\n    http.headers().xssProtection().xssProtectionEnabled(true)\n        .block(true).and(); // 省略后续的其他配置\n}</code></pre>\n<p>这段配置会在 HTTP 响应里带上 <code>X-XSS-Protection</code> 头，类似下面这样：</p>\n<pre class=\"code-rows\"><code>X-XSS-Protection: 1; mode=block</code></pre>\n<p>上面的配置是默认开启的，Spring Security 还有一个默认不开启的 CSP（Content Security Policy，内容安全策略）<span class=\"comment-number\">24</span>，也就是 HTTP 的 <code>Content-Security-Policy</code> 头配置，需要开发者根据实际情况进行配置。CSP 相当于一个白名单，告诉浏览器某一类型的资源有哪些是能加载的，除此以外的一概不能加载，这在一定程度上提高了注入恶意内容的门槛。</p>\n\n<p>同样是配置 HTTP 的头，在扩展了 <code>WebSecurityConfigurerAdapter</code> 的配置类里添加下面这样的代码，让浏览器只能从当前域名加载脚本，不加载任何 <code>&lt;object/&gt;</code> 标签的资源，把注入行为报告给 <code>/csp-report-endpoint/</code> 这个地址。由于还加了 <code>reportOnly()</code>，所以在发生攻击时，只会上报威胁，并不实际阻断攻击，这相当于在响应里添加了 <code>Content-Security-Policy-Report-Only</code> 头。</p>\n<pre class=\"code-rows\"><code>protected void configure(HttpSecurity http) throws Exception {\n    http.headers()\n        .contentSecurityPolicy(\"script-src 'self'; object-src 'none'; report-uri /csp-report-endpoint/\")\n        .reportOnly()\n        .and(); // 省略后续的其他配置\n}</code></pre>\n<h3 id=\"nav_point_166\">10.4.4　点击劫持攻击防护</h3>\n<p><strong>点击劫持</strong>（Clickjacking）<strong>攻击</strong>是指攻击者通过某些方式，将恶意代码伪装起来，诱导用户在不知情的情况下点击触发恶意的命令。通常的做法可以是将某个正常网页用 iframe 嵌入进来，上面覆盖一个透明的层（也可以是另一个 iframe），用户以为自己在操作正常网页，其实点击的都是透明层里的东西。根据其攻击的手段，也有人将其称为<strong>界面伪装攻击</strong>（UI redress attack）。<span class=\"comment-number\">25</span></p>\n\n<p>既然攻击者在恶意伪装的页面里会用 iframe 嵌入正常页面，那我们在防御时就会想到不让自己的网页被嵌入恶意页面中。2008 年点击劫持攻击被正式提出后，2009 年 Internet Explorer 8 中就增加了一个 <code>X-Frame-Options</code> 头，后来其他主流浏览器也纷纷跟进。这个 HTTP 头可以取如下几个值：</p>\n<ul>\n<li><code>DENY</code>，拒绝被任何网页用 iframe 嵌入；</li>\n<li><code>SAMEORGIN</code>，只允许同源网页嵌入；</li>\n<li><code>ALLOW-FROM</code> 具体 <code>URI</code>，允许特定 URI 页面嵌入（有些框架不提供这个选项，例如 Spring Security）。</li>\n</ul>\n<p>我们可以在负载均衡层统一增加 <code>X-Frame-Options</code>，也可以交给 Java 应用来实现，比如，在 Spring Security 里就可以这么来配置：</p>\n<pre class=\"code-rows\"><code>protected void configure(HttpSecurity http) throws Exception {\n    http.headers().frameOptions().sameOrigin()\n        .and(); // 省略后续的其他配置\n}</code></pre>\n<h3 id=\"nav_point_167\">10.4.5　引导使用 HTTPS</h3>\n<p>早期的网站基本都是 HTTP 的，大多通过明文在网络上进行传输，随着大家对隐私保护、敏感信息等方面的重视程度的提高，越来越多的网站开始支持 HTTPS 协议，尤其是涉及资金的网银、第三方支付平台等系统，更是应该强制使用 HTTPS。</p>\n<p>大多数网站都会同时支持 HTTP 和 HTTPS，假设用户始终在使用 HTTP 访问该网站（实际上大多数人在浏览器中输入地址时也不会输协议 <code>https://</code>），那 HTTPS 的支持也就形同虚设。2012 年发布的 HTTP 严格传输安全协议（HTTP Strict Transport Security，简称 HSTS）正是用来引导浏览器强制使用 HTTPS 的。添加了 <code>Strict-Transport-Security</code> 头后，浏览器在首次访问时会用 HTTP 请求，在响应里发现了这个头，后续就会强制转为使用 HTTPS。此外，使用了 HSTS 后，针对证书校验不通过等情况，原本用户可以选择忽略报错，现在就不再能够忽略这种错误，又进一步提升了安全性。</p>\n<p>例如下面这个头就要求浏览器在未来的 1 年里，对于当前网站及其子域名都直接使用 HTTPS 来进行访问：</p>\n<pre class=\"code-rows\"><code>Strict-Transport-Security: max-age=31536000; includeSubDomains</code></pre>\n<p>在 Spring Security 里可以这样来做配置：</p>\n<pre class=\"code-rows\"><code>protected void configure(HttpSecurity http) throws Exception {\n    http.headers().httpStrictTransportSecurity()\n        .maxAgeInSeconds(365*24*3600).includeSubDomains(true);\n        .and(); // 省略后续的其他配置\n}</code></pre>\n<p>针对知名的网站，主流浏览器（例如 Chrome）还内置了一份 HSTS 的预加载清单，记录了哪些网站直接就使用 HTTPS。针对这种添加进清单的情况，<code>Strict-Transport-Security</code> 头的值里会加上 <code>preload</code>。</p>\n<p>另外，我们也可以在代码里要求特定的 HTTP 请求必须转为 HTTPS，可以像下面这样要求所有请求都使用 HTTPS，也可以用 <code>antMatchers()</code> 指定特定的请求走 HTTPS：</p>\n<pre class=\"code-rows\"><code>protected void configure(HttpSecurity http) throws Exception {\n    http.requiresChannel().anyRequest().requiresSecure()\n        .and(); // 省略后续的其他配置\n}</code></pre>\n<h2 id=\"nav_point_168\">10.5　客户端程序的认证</h2>\n<p>前面的几节，我们聊的大多是针对人在操作 Web 界面时的认证，即通过登录界面进行登录，拿到所登录用户的权限后再进行后续的操作。在实际工作中，系统内部还有很多操作都是通过 API 的方式进行的。在二进制奶茶店的例子里，我们也写了代表客户端的程序，它就是通过 REST 服务与奶茶店交互的。因此，在本章的最后，我们要一起来看一下客户端程序该如何进行身份认证。</p>\n<h3 id=\"nav_point_169\">10.5.1　几种常见的认证方式</h3>\n<p>在 HTTP 协议里直接定义了一些认证的方式，比如 <code>Authorization</code> 这个 HTTP 头就是专门用来做认证的。其中最基本，也是最简单的就是 <strong>HTTP Basic 认证</strong>，直接将用户名和密码用 BASE64 编码后放在请求头里，每个请求都带着这些信息，省去了登录页、Cookies、Session 等麻烦，就像下面这样。但与之相伴的安全问题也显而易见，这里的身份信息几乎就是用明文放在网上传输的，很容易就能被人截获，所以至少应该使用 HTTPS 对整个通信过程进行加密。</p>\n<pre class=\"code-rows\"><code>Authorization: Basic &lt;BASE64编码值&gt;</code></pre>\n<p>另一种方式是<strong>基于令牌的认证</strong>，也可以称为 Bearer 认证，即告诉系统可以把权限赋予这个令牌的携带者。它同样也是结合 <code>Authorization</code> 这个 HTTP 来使用的，像下面这样。它最早是在 RFC 6750 里提出的，作为 OAuth 2.0 的一部分，但现在也经常单独使用。JWT 就是目前较为常见的令牌，我们在稍后的例子里也会用到。虽然令牌里一般没有密码这样的敏感信息，但被截获下来也能在令牌有效期内被攻击者利用，所以也建议搭配 HTTPS 一起来用。</p>\n<pre class=\"code-rows\"><code>Authorization: Bearer &lt;令牌&gt;</code></pre>\n<p>现在的几家公有云服务厂商，像亚马逊云、阿里云、腾讯云等公有云都无一例外地提供了 API 密钥的方式来让用户访问自己的服务。在实践中 API 密钥可以放在 HTTP 头里（<code>Authorization</code> 就很合适），也可以放在 URL 或者请求正文里。腾讯云选择的是前者，在 <code>Authorization</code> 头中的 <code>Credential</code> 里就包含了 <code>SecretId</code>，下面的示例就是腾讯云文档中的一个 <code>POST</code> 请求样例，调用了 CVM 的接口。阿里云选择了后者，在 Query String 里携带 <code>AccessKeyId</code>。此外，为了保证请求的安全性，还会对请求头和正文进行签名，防止请求被篡改，请求中的时间戳除了标记请求发起的时间，还可以在遇到重放时起到一定的防御作用（这时如果请求里带了唯一的随机数效果会更好）。不过在实际使用时，我们一般并不会自己来拼装请求报文，而是会使用云服务厂商提供的 SDK。</p>\n<pre class=\"code-rows\"><code>https://cvm.tencentcloudapi.com/\n\nAuthorization: TC3-HMAC-SHA256 Credential=AKID********EXAMPLE/2018-05-30/cvm/tc3_request,\nSignedHeaders=content-type;host, Signature=582c400e06b5924a6f2b5d7d672d79c15b13162d9279b0855cfba6789a8edb4c\nContent-Type: application/json\nHost: cvm.tencentcloudapi.com\nX-TC-Action: DescribeInstances\nX-TC-Version: 2017-03-12\nX-TC-Timestamp: 1527672334\nX-TC-Region: ap-guangzhou\n\n{\"Offset\":0,\"Limit\":10}</code></pre>\n<p>除此之外，OAuth 2.0<span class=\"comment-number\">26</span> 和 SAML 2.0（安全断言标记语言 2.0）这两种开放标准在生产环境中也有非常广泛的使用，如果已经有相应的认证机制，可以考虑接入进去。</p>\n\n<h3 id=\"nav_point_170\">10.5.2　用 <code>RestTemplate</code> 实现简单的认证</h3>\n<p>既然是发送 HTTP 请求，调用 <code>REST</code> 接口，自然就会联想到使用我们在上一章里学到的 <code>RestTemplate</code>，而且 Spring Boot 早就为它准备好了辅助类，可以让我们方便地操作 <code>Authorization</code> 头。下面就让我们简单地看一下，如何在 Spring Boot 工程里使用 <code>RestTemplate</code> 完成 HTTP Basic 认证和基于 JWT 的认证。</p>\n<blockquote>\n<p><strong>需求描述</strong>　二进制奶茶店的顾客可以使用客户端程序来查询菜单并下单，但很多操作都需要实现认证，那么客户端程序该如何来完成请求的认证呢？</p>\n</blockquote>\n<p>因为请求是直接由客户端程序发起的，所以服务提供方需要关闭 CSRF 防护，就像下面这样，本书后面的 BinaryTea 工程中都要关闭 CSRF 防护：</p>\n<pre class=\"code-rows\"><code>protected void configure(HttpSecurity http) throws Exception {\n    http.csrf().disable().and(); // 省略后续的其他配置\n}</code></pre>\n<ol>\n<li><p><strong>HTTP Basic 认证</strong></p>\n<p>先来看看最基本的 HTTP Basic 认证，这里通过 <code>RestTemplateBuilder.basicAuthentication()</code> 方法设置了用户名与密码。其本质是创建一个 <code>RestTemplateBuilderClientHttpRequestInitializer</code> 实例，将它添加到 <code>RestTemplate</code> 的 <code>clientHttpRequestInitializers</code> 集合里。在创建 <code>ClientHttpRequest</code> 时，会执行集合里的 <code>ClientHttpRequestInitializer</code> 对请求做初始化。在请求里不包含 <code>Authorization</code> 头时，<code>RestTemplate</code> 会自动根据设置添加相应的认证信息。具体如代码示例 10-39 所示。<span class=\"comment-number\">27</span></p>\n<blockquote>\n<p><strong>代码示例 10-39</strong>　添加了 HTTP Basic 认证的 <code>RestTemplate</code> 初始化代码</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Bean\npublic RestTemplate restTemplate(RestTemplateBuilder builder) {\n    return builder.requestFactory(this::requestFactory)\n                   .setConnectTimeout(Duration.ofSeconds(1)) // 连接超时\n                   .setReadTimeout(Duration.ofSeconds(5)) // 读取超时\n                   .basicAuthentication(\"LiLei\", \"binarytea\") // HTTP Basic认证信息\n                   .build();\n}</code></pre>\n<p>BinaryTea 工程也要稍作修改，<code>OrderController</code> 要同时能够处理表单提交与 <code>REST</code> 接口调用，两个 <code>createNewOrder()</code> 方法接受的请求内容类型不同，接受表单的返回 Thymeleaf 视图，而接受 JSON 的返回值也是 JSON，它们可以共享订单创建的方法。具体如代码示例 10-40 所示。<span class=\"comment-number\">28</span></p>\n<blockquote>\n<p><strong>代码示例 10-40</strong>　同时处理表单与 <code>REST</code> 请求的 <code>OrderController</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Controller\n@RequestMapping(\"/order\")\n@Slf4j\npublic class OrderController {\n    @PostMapping(consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE)\n    public String createNewOrder(@Valid NewOrderForm form, BindingResult result, ModelMap modelMap) {\n        // 省略代码\n    }\n\n    @ResponseBody\n    @PostMapping(consumes = MediaType.APPLICATION_JSON_VALUE,\n                  produces = MediaType.APPLICATION_JSON_VALUE)\n    public ResponseEntity&lt;Order&gt; createNewOrder(@RequestBody @Valid NewOrderForm form, BindingResult result) {\n        if (result.hasErrors()) {\n            return ResponseEntity.badRequest().body(null);\n        }\n        Order order = createOrder(form);\n        URI uri = ServletUriComponentsBuilder.fromCurrentRequestUri().build().toUri();\n        return ResponseEntity.created(uri).body(order);\n    }\n\n    private Order createOrder(NewOrderForm form) {\n        List&lt;MenuItem&gt; itemList = form.getItemIdList().stream()\n            .map(i -&gt; NumberUtils.toLong(i))\n            .collect(Collectors.collectingAndThen(Collectors.toList(), list -&gt; menuService.getByIdList(list)));\n        Order order = orderService.createOrder(itemList, form.getDiscount());\n        log.info(\"创建新订单，Order={}\", order);\n        return order;\n    }\n    // 省略其他代码\n}</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>基于 JWT 的认证</strong></p>\n<p>在 10.2.4 节中，我们开发好了一个使用 JWT 认证的服务端程序，那客户端又该如何来获取 JWT 令牌，在请求中带上令牌做认证呢？<code>RestTemplate</code> 的 HTTP Basic 认证是自动在每个请求里添加 <code>Authorization</code> 头，我们可以写一个自己的 <code>RestTemplateRequestCustomizer</code> 实现类似的功能，如代码示例 10-41 所示。<span class=\"comment-number\">29</span></p>\n<blockquote>\n<p><strong>代码示例 10-41</strong>　获取 JWT 令牌并设置到请求中的 <code>JwtClientHttpRequestInitializer</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Slf4j\npublic class JwtClientHttpRequestInitializer implements RestTemplateRequestCustomizer {\n    @Autowired\n    private ClientHttpRequestFactory requestFactory;\n    @Value(\"$\")\n    private String username;\n    @Value(\"$\")\n    private String password;\n    @Value(\"$\")\n    private String binarytea;\n    private String token;\n\n    @PostConstruct\n    public void initToken() {\n        ResponseEntity&lt;TokenResponse&gt; entity = acquireToken();\n        if (HttpStatus.OK == entity.getStatusCode() &amp;&amp; entity.getBody() != null) {\n            token = entity.getBody().getToken();\n            log.info(\"获得Token：{}\", token);\n        } else {\n            log.warn(\"获取Token失败，原因：{}\", entity.getBody());\n        }\n    }\n\n    @Override\n    public void customize(ClientHttpRequest request) {\n        if (StringUtils.isBlank(token)) {\n            initToken();\n        }\n        if (StringUtils.isNotBlank(token) &amp;&amp;!request.getHeaders()\n            .containsKey(HttpHeaders.AUTHORIZATION)) {\n            request.getHeaders().setBearerAuth(token);\n        }\n    }\n\n    private ResponseEntity&lt;TokenResponse&gt; acquireToken() {\n        return new RestTemplate(requestFactory) // 用个简单的RestTemplate来获取Token\n                    .postForEntity(binarytea + \"/token\",\n                    new TokenRequest(username, password),\n                    TokenResponse.class);\n    }\n}</code></pre>\n<p>上面的代码主要做了两件事：一件是 <code>initToken()</code> 使用用户名与密码来获得令牌，上面添加了 <code>@PostConstruct</code>，在完成依赖注入后自动运行该方法，在第一时间获得令牌，如果初始化失败，后续在使用时还会再尝试获取；另一件是 <code>customize()</code> 往每个请求的 HTTP 头里塞一个 <code>Authorization</code> 头，里面是 <code>Bearer</code> 加令牌。以上对应的配置代码如代码示例 10-42 所示。<span class=\"comment-number\">30</span></p>\n<blockquote>\n<p><strong>代码示例 10-42</strong>　JWT 令牌对应的配置代码</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootApplication\n@Slf4j\npublic class CustomerApplication {\n    @Bean\n    public RestTemplate restTemplate(RestTemplateBuilder builder) {\n        return builder\n                .requestFactory(this::requestFactory)\n                .setConnectTimeout(Duration.ofSeconds(1)) // 连接超时\n                .setReadTimeout(Duration.ofSeconds(5)) // 读取超时\n                .additionalRequestCustomizers(jwtClientHttpRequestInitializer())\n                .build();\n    }\n\n    @Bean\n    public JwtClientHttpRequestInitializer jwtClientHttpRequestInitializer() {\n        return new JwtClientHttpRequestInitializer();\n    }\n    // 省略其他代码\n}</code></pre>\n<p>我们在 <code>application.properties</code> 里添加下面的配置，用用户名 <code>LiLei</code> 登录：</p>\n<pre class=\"code-rows\"><code>binarytea.url=http://localhost:8080\njwt.username=LiLei\njwt.password=binarytea</code></pre>\n<p>运行程序后会看到类似下面这样的输出，还有另外的一些日志：</p>\n<pre class=\"code-rows\"><code>2021-02-11 22:19:01.219 INFO 83964 --- [main] l.s.c.JwtClientHttpRequestInitializer : 获得Token：\neyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJMaUxlaSIsImlzcyI6IkJpbmFyeVRlYSIsImlhdCI6MTYxMzA1MzE0MSwiZXhwIjoxNjEzMDU2\nNzQxfQ.stQWgDPW1dx8Z8kuH_jX-fD1iphashp1uf8QHTW_4DzWA0SwRQAmhxORTq8uLNQnwGUX_cHbM95F0nEvoTn-9A</code></pre>\n<p>如果把用户名换成 <code>ZhangSan</code>，那执行后会报错，因为他没有调用 <code>/order</code> 的权限，访问会返回 <code>403 Forbidden</code>。</p>\n</li>\n</ol>\n\n\n\n\n","comments":[]}