{"id":446949,"title":"37｜阶段实操（5）：构建一个简单的KV server-网络安全","content":"<p>你好，我是陈天。</p><p>上一讲我们完成了KV server整个网络部分的构建。而安全是和网络密不可分的组成部分，在构建应用程序的时候，一定要把网络安全也考虑进去。当然，如果不考虑极致的性能，我们可以使用诸如 gRPC 这样的系统，在提供良好性能的基础上，它还通过 <a href=\"https://en.wikipedia.org/wiki/Transport_Layer_Security\">TLS</a> 保证了安全性。</p><p>那么，当我们的应用架构在 TCP 上时，如何使用 TLS 来保证客户端和服务器间的安全性呢？</p><h2>生成 x509 证书</h2><p>想要使用 TLS，我们首先需要 <a href=\"https://en.wikipedia.org/wiki/X.509\">x509 证书</a>。TLS 需要 x509 证书让客户端验证服务器是否是一个受信的服务器，甚至服务器验证客户端，确认对方是一个受信的客户端。</p><p>为了测试方便，我们要有能力生成自己的 CA 证书、服务端证书，甚至客户端证书。证书生成的细节今天就不详细介绍了，我之前做了一个叫 <a href=\"https://github.com/tyrchen/certify\">certify</a> 的库，可以用来生成各种证书。我们可以在 Cargo.toml 里加入这个库：</p><pre><code class=\"language-rust\">[dev-dependencies]\n...\ncertify = \"0.3\"\n...\n</code></pre><p>然后在根目录下创建 fixtures 目录存放证书，再创建 examples/gen_cert.rs 文件，添入如下代码：</p><pre><code class=\"language-rust\">use anyhow::Result;\nuse certify::{generate_ca, generate_cert, load_ca, CertType, CA};\nuse tokio::fs;\n\nstruct CertPem {\n    cert_type: CertType,\n    cert: String,\n    key: String,\n}\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;()&gt; {\n    let pem = create_ca()?;\n    gen_files(&amp;pem).await?;\n    let ca = load_ca(&amp;pem.cert, &amp;pem.key)?;\n    let pem = create_cert(&amp;ca, &amp;[\"kvserver.acme.inc\"], \"Acme KV server\", false)?;\n    gen_files(&amp;pem).await?;\n    let pem = create_cert(&amp;ca, &amp;[], \"awesome-device-id\", true)?;\n    gen_files(&amp;pem).await?;\n    Ok(())\n}\n\nfn create_ca() -&gt; Result&lt;CertPem&gt; {\n    let (cert, key) = generate_ca(\n        &amp;[\"acme.inc\"],\n        \"CN\",\n        \"Acme Inc.\",\n        \"Acme CA\",\n        None,\n        Some(10 * 365),\n    )?;\n    Ok(CertPem {\n        cert_type: CertType::CA,\n        cert,\n        key,\n    })\n}\n\nfn create_cert(ca: &amp;CA, domains: &amp;[&amp;str], cn: &amp;str, is_client: bool) -&gt; Result&lt;CertPem&gt; {\n    let (days, cert_type) = if is_client {\n        (Some(365), CertType::Client)\n    } else {\n        (Some(5 * 365), CertType::Server)\n    };\n    let (cert, key) = generate_cert(ca, domains, \"CN\", \"Acme Inc.\", cn, None, is_client, days)?;\n\n    Ok(CertPem {\n        cert_type,\n        cert,\n        key,\n    })\n}\n\nasync fn gen_files(pem: &amp;CertPem) -&gt; Result&lt;()&gt; {\n    let name = match pem.cert_type {\n        CertType::Client =&gt; \"client\",\n        CertType::Server =&gt; \"server\",\n        CertType::CA =&gt; \"ca\",\n    };\n    fs::write(format!(\"fixtures/{}.cert\", name), pem.cert.as_bytes()).await?;\n    fs::write(format!(\"fixtures/{}.key\", name), pem.key.as_bytes()).await?;\n    Ok(())\n}\n</code></pre><!-- [[[read_end]]] --><p>这个代码很简单，它先生成了一个 CA 证书，然后再生成服务器和客户端证书，全部存入刚创建的 fixtures 目录下。你需要 <code>cargo run --examples gen_cert</code> 运行一下这个命令，待会我们会在测试中用到这些证书和密钥。</p><h2>在 KV server 中使用 TLS</h2><p>TLS 是目前最主要的应用层安全协议，被广泛用于保护架构在 TCP 之上的，比如 MySQL、HTTP 等各种协议。一个网络应用，即便是在内网使用，如果没有安全协议来保护，都是很危险的。</p><p>下图展示了客户端和服务器进行 TLS 握手的过程，来源<a href=\"https://commons.wikimedia.org/wiki/File:Full_TLS_1.3_Handshake.svg\">wikimedia</a>：<br>\n<img src=\"https://static001.geekbang.org/resource/image/71/f7/71befa0bbf5225582dd01a7330c641f7.png?wh=1280x877\" alt=\"\"></p><p>对于 KV server 来说，使用 TLS 之后，整个协议的数据封装如下图所示：<br>\n<img src=\"https://static001.geekbang.org/resource/image/07/13/077659d231dd45b1617ed3707c74cf13.jpg?wh=2364x1027\" alt=\"\"></p><p>所以今天要做的就是在上一讲的网络处理的基础上，添加 TLS 支持，使得 KV server 的客户端服务器之间的通讯被严格保护起来，确保最大程度的安全，免遭第三方的偷窥、篡改以及仿造。</p><p>好，接下来我们看看 TLS 怎么实现。</p><p>估计很多人一听 TLS 或者 SSL，就头皮发麻，因为之前跟 <a href=\"https://www.openssl.org/\">openssl</a> 打交道有过很多不好的经历。openssl 的代码库太庞杂，API 不友好，编译链接都很费劲。</p><p>不过，在 Rust 下使用 TLS 的体验还是很不错的，Rust 对 openssl 有很不错的<a href=\"https://github.com/sfackler/rust-openssl\">封装</a>，也有不依赖 openssl 用 Rust 撰写的 <a href=\"https://github.com/rustls/rustls\">rustls</a>。tokio 进一步提供了符合 tokio 生态圈的 <a href=\"https://github.com/tokio-rs/tls\">tls 支持</a>，有 openssl 版本和 rustls 版本可选。</p><p>我们今天就用 <a href=\"https://github.com/tokio-rs/tls/tree/master/tokio-rustls\">tokio-rustls</a> 来撰写 TLS 的支持。相信你在实现过程中可以看到，在应用程序中加入 TLS 协议来保护网络层，是多么轻松的一件事情。</p><p>先在 Cargo.toml 中添加 tokio-rustls：</p><pre><code class=\"language-rust\">[dependencies]\n...\ntokio-rustls = \"0.22\"\n...\n</code></pre><p>然后创建 src/network/tls.rs，撰写如下代码（记得在 src/network/mod.rs 中引入这个文件哦）：</p><pre><code class=\"language-rust\">use std::io::Cursor;\nuse std::sync::Arc;\n\nuse tokio::io::{AsyncRead, AsyncWrite};\nuse tokio_rustls::rustls::{internal::pemfile, Certificate, ClientConfig, ServerConfig};\nuse tokio_rustls::rustls::{AllowAnyAuthenticatedClient, NoClientAuth, PrivateKey, RootCertStore};\nuse tokio_rustls::webpki::DNSNameRef;\nuse tokio_rustls::TlsConnector;\nuse tokio_rustls::{\n    client::TlsStream as ClientTlsStream, server::TlsStream as ServerTlsStream, TlsAcceptor,\n};\n\nuse crate::KvError;\n\n/// KV Server 自己的 ALPN (Application-Layer Protocol Negotiation)\nconst ALPN_KV: &amp;str = \"kv\";\n\n/// 存放 TLS ServerConfig 并提供方法 accept 把底层的协议转换成 TLS\n#[derive(Clone)]\npub struct TlsServerAcceptor {\n    inner: Arc&lt;ServerConfig&gt;,\n}\n\n/// 存放 TLS Client 并提供方法 connect 把底层的协议转换成 TLS\n#[derive(Clone)]\npub struct TlsClientConnector {\n    pub config: Arc&lt;ClientConfig&gt;,\n    pub domain: Arc&lt;String&gt;,\n}\n\nimpl TlsClientConnector {\n    /// 加载 client cert / CA cert，生成 ClientConfig\n    pub fn new(\n        domain: impl Into&lt;String&gt;,\n        identity: Option&lt;(&amp;str, &amp;str)&gt;,\n        server_ca: Option&lt;&amp;str&gt;,\n    ) -&gt; Result&lt;Self, KvError&gt; {\n        let mut config = ClientConfig::new();\n\n        // 如果有客户端证书，加载之\n        if let Some((cert, key)) = identity {\n            let certs = load_certs(cert)?;\n            let key = load_key(key)?;\n            config.set_single_client_cert(certs, key)?;\n        }\n\n        // 加载本地信任的根证书链\n        config.root_store = match rustls_native_certs::load_native_certs() {\n            Ok(store) | Err((Some(store), _)) =&gt; store,\n            Err((None, error)) =&gt; return Err(error.into()),\n        };\n\n        // 如果有签署服务器的 CA 证书，则加载它，这样服务器证书不在根证书链\n        // 但是这个 CA 证书能验证它，也可以\n        if let Some(cert) = server_ca {\n            let mut buf = Cursor::new(cert);\n            config.root_store.add_pem_file(&amp;mut buf).unwrap();\n        }\n\n        Ok(Self {\n            config: Arc::new(config),\n            domain: Arc::new(domain.into()),\n        })\n    }\n\n    /// 触发 TLS 协议，把底层的 stream 转换成 TLS stream\n    pub async fn connect&lt;S&gt;(&amp;self, stream: S) -&gt; Result&lt;ClientTlsStream&lt;S&gt;, KvError&gt;\n    where\n        S: AsyncRead + AsyncWrite + Unpin + Send,\n    {\n        let dns = DNSNameRef::try_from_ascii_str(self.domain.as_str())\n            .map_err(|_| KvError::Internal(\"Invalid DNS name\".into()))?;\n\n        let stream = TlsConnector::from(self.config.clone())\n            .connect(dns, stream)\n            .await?;\n\n        Ok(stream)\n    }\n}\n\nimpl TlsServerAcceptor {\n    /// 加载 server cert / CA cert，生成 ServerConfig\n    pub fn new(cert: &amp;str, key: &amp;str, client_ca: Option&lt;&amp;str&gt;) -&gt; Result&lt;Self, KvError&gt; {\n        let certs = load_certs(cert)?;\n        let key = load_key(key)?;\n\n        let mut config = match client_ca {\n            None =&gt; ServerConfig::new(NoClientAuth::new()),\n            Some(cert) =&gt; {\n                // 如果客户端证书是某个 CA 证书签发的，则把这个 CA 证书加载到信任链中\n                let mut cert = Cursor::new(cert);\n                let mut client_root_cert_store = RootCertStore::empty();\n                client_root_cert_store\n                    .add_pem_file(&amp;mut cert)\n                    .map_err(|_| KvError::CertifcateParseError(\"CA\", \"cert\"))?;\n\n                let client_auth = AllowAnyAuthenticatedClient::new(client_root_cert_store);\n                ServerConfig::new(client_auth)\n            }\n        };\n\n        // 加载服务器证书\n        config\n            .set_single_cert(certs, key)\n            .map_err(|_| KvError::CertifcateParseError(\"server\", \"cert\"))?;\n        config.set_protocols(&amp;[Vec::from(&amp;ALPN_KV[..])]);\n\n        Ok(Self {\n            inner: Arc::new(config),\n        })\n    }\n\n    /// 触发 TLS 协议，把底层的 stream 转换成 TLS stream\n    pub async fn accept&lt;S&gt;(&amp;self, stream: S) -&gt; Result&lt;ServerTlsStream&lt;S&gt;, KvError&gt;\n    where\n        S: AsyncRead + AsyncWrite + Unpin + Send,\n    {\n        let acceptor = TlsAcceptor::from(self.inner.clone());\n        Ok(acceptor.accept(stream).await?)\n    }\n}\n\nfn load_certs(cert: &amp;str) -&gt; Result&lt;Vec&lt;Certificate&gt;, KvError&gt; {\n    let mut cert = Cursor::new(cert);\n    pemfile::certs(&amp;mut cert).map_err(|_| KvError::CertifcateParseError(\"server\", \"cert\"))\n}\n\nfn load_key(key: &amp;str) -&gt; Result&lt;PrivateKey, KvError&gt; {\n    let mut cursor = Cursor::new(key);\n\n    // 先尝试用 PKCS8 加载私钥\n    if let Ok(mut keys) = pemfile::pkcs8_private_keys(&amp;mut cursor) {\n        if !keys.is_empty() {\n            return Ok(keys.remove(0));\n        }\n    }\n\n    // 再尝试加载 RSA key\n    cursor.set_position(0);\n    if let Ok(mut keys) = pemfile::rsa_private_keys(&amp;mut cursor) {\n        if !keys.is_empty() {\n            return Ok(keys.remove(0));\n        }\n    }\n\n    // 不支持的私钥类型\n    Err(KvError::CertifcateParseError(\"private\", \"key\"))\n}\n</code></pre><p>这个代码创建了两个数据结构 TlsServerAcceptor / TlsClientConnector。虽然它有 100 多行，但主要的工作其实就是<strong>根据提供的证书，来生成 tokio-tls 需要的 ServerConfig / ClientConfig</strong>。</p><p>因为 TLS 需要验证证书的 CA，所以还需要加载 CA 证书。虽然平时在做 Web 开发时，我们都只使用服务器证书，但其实 TLS 支持双向验证，服务器也可以验证客户端的证书是否是它认识的 CA 签发的。</p><p>处理完 config 后，这段代码的核心逻辑其实就是客户端的 connect() 方法和服务器的 accept() 方法，它们都接受一个满足 AsyncRead + AsyncWrite + Unpin + Send 的 stream。类似上一讲，我们不希望 TLS 代码只能接受 TcpStream，所以这里提供了一个泛型参数 S：</p><pre><code class=\"language-rust\">/// 触发 TLS 协议，把底层的 stream 转换成 TLS stream\npub async fn connect&lt;S&gt;(&amp;self, stream: S) -&gt; Result&lt;ClientTlsStream&lt;S&gt;, KvError&gt;\nwhere\n    S: AsyncRead + AsyncWrite + Unpin + Send,\n{\n    let dns = DNSNameRef::try_from_ascii_str(self.domain.as_str())\n        .map_err(|_| KvError::Internal(\"Invalid DNS name\".into()))?;\n\n    let stream = TlsConnector::from(self.config.clone())\n        .connect(dns, stream)\n        .await?;\n\n    Ok(stream)\n}\n\n/// 触发 TLS 协议，把底层的 stream 转换成 TLS stream\npub async fn accept&lt;S&gt;(&amp;self, stream: S) -&gt; Result&lt;ServerTlsStream&lt;S&gt;, KvError&gt;\nwhere\n    S: AsyncRead + AsyncWrite + Unpin + Send,\n{\n    let acceptor = TlsAcceptor::from(self.inner.clone());\n    Ok(acceptor.accept(stream).await?)\n}\n</code></pre><p>在使用 TlsConnector 或者 TlsAcceptor 处理完 connect/accept 后，我们得到了一个 TlsStream，它也满足 AsyncRead + AsyncWrite + Unpin + Send，后续的操作就可以在其上完成了。百来行代码就搞定了 TLS，是不是很轻松？</p><p>我们来顺着往下写段测试：</p><pre><code class=\"language-rust\">#[cfg(test)]\nmod tests {\n\n    use std::net::SocketAddr;\n\n    use super::*;\n    use anyhow::Result;\n    use tokio::{\n        io::{AsyncReadExt, AsyncWriteExt},\n        net::{TcpListener, TcpStream},\n    };\n\n    const CA_CERT: &amp;str = include_str!(\"../../fixtures/ca.cert\");\n    const CLIENT_CERT: &amp;str = include_str!(\"../../fixtures/client.cert\");\n    const CLIENT_KEY: &amp;str = include_str!(\"../../fixtures/client.key\");\n    const SERVER_CERT: &amp;str = include_str!(\"../../fixtures/server.cert\");\n    const SERVER_KEY: &amp;str = include_str!(\"../../fixtures/server.key\");\n\n    #[tokio::test]\n    async fn tls_should_work() -&gt; Result&lt;()&gt; {\n        let ca = Some(CA_CERT);\n\n        let addr = start_server(None).await?;\n\n        let connector = TlsClientConnector::new(\"kvserver.acme.inc\", None, ca)?;\n        let stream = TcpStream::connect(addr).await?;\n        let mut stream = connector.connect(stream).await?;\n        stream.write_all(b\"hello world!\").await?;\n        let mut buf = [0; 12];\n        stream.read_exact(&amp;mut buf).await?;\n        assert_eq!(&amp;buf, b\"hello world!\");\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn tls_with_client_cert_should_work() -&gt; Result&lt;()&gt; {\n        let client_identity = Some((CLIENT_CERT, CLIENT_KEY));\n        let ca = Some(CA_CERT);\n\n        let addr = start_server(ca.clone()).await?;\n\n        let connector = TlsClientConnector::new(\"kvserver.acme.inc\", client_identity, ca)?;\n        let stream = TcpStream::connect(addr).await?;\n        let mut stream = connector.connect(stream).await?;\n        stream.write_all(b\"hello world!\").await?;\n        let mut buf = [0; 12];\n        stream.read_exact(&amp;mut buf).await?;\n        assert_eq!(&amp;buf, b\"hello world!\");\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn tls_with_bad_domain_should_not_work() -&gt; Result&lt;()&gt; {\n        let addr = start_server(None).await?;\n\n        let connector = TlsClientConnector::new(\"kvserver1.acme.inc\", None, Some(CA_CERT))?;\n        let stream = TcpStream::connect(addr).await?;\n        let result = connector.connect(stream).await;\n\n        assert!(result.is_err());\n\n        Ok(())\n    }\n\n    async fn start_server(ca: Option&lt;&amp;str&gt;) -&gt; Result&lt;SocketAddr&gt; {\n        let acceptor = TlsServerAcceptor::new(SERVER_CERT, SERVER_KEY, ca)?;\n\n        let echo = TcpListener::bind(\"127.0.0.1:0\").await.unwrap();\n        let addr = echo.local_addr().unwrap();\n\n        tokio::spawn(async move {\n            let (stream, _) = echo.accept().await.unwrap();\n            let mut stream = acceptor.accept(stream).await.unwrap();\n            let mut buf = [0; 12];\n            stream.read_exact(&amp;mut buf).await.unwrap();\n            stream.write_all(&amp;buf).await.unwrap();\n        });\n\n        Ok(addr)\n    }\n}\n</code></pre><p>这段测试代码使用了 include_str! 宏，在编译期把文件加载成字符串放在 RODATA 段。我们测试了三种情况：标准的 TLS 连接、带有客户端证书的 TLS 连接，以及客户端提供了错的域名的情况。运行 <code>cargo test</code> ，所有测试都能通过。</p><h2>让 KV client/server 支持 TLS</h2><p>在 TLS 的测试都通过后，就可以添加 kvs和 kvc对 TLS 的支持了。</p><p>由于我们一路以来良好的接口设计，尤其是 ProstClientStream / ProstServerStream 都接受泛型参数，使得 TLS 的代码可以无缝嵌入。比如客户端：</p><pre><code class=\"language-rust\">// 新加的代码\nlet connector = TlsClientConnector::new(\"kvserver.acme.inc\", None, Some(ca_cert))?;\n\nlet stream = TcpStream::connect(addr).await?;\n\n// 新加的代码\nlet stream = connector.connect(stream).await?;\n\nlet mut client = ProstClientStream::new(stream);\n</code></pre><p>仅仅需要把传给 ProstClientStream 的 stream，从 TcpStream 换成生成的 TlsStream，就无缝支持了 TLS。</p><p>我们看完整的代码，src/server.rs：</p><pre><code class=\"language-rust\">use anyhow::Result;\nuse kv3::{MemTable, ProstServerStream, Service, ServiceInner, TlsServerAcceptor};\nuse tokio::net::TcpListener;\nuse tracing::info;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;()&gt; {\n    tracing_subscriber::fmt::init();\n    let addr = \"127.0.0.1:9527\";\n\n    // 以后从配置文件取\n    let server_cert = include_str!(\"../fixtures/server.cert\");\n    let server_key = include_str!(\"../fixtures/server.key\");\n\n    let acceptor = TlsServerAcceptor::new(server_cert, server_key, None)?;\n    let service: Service = ServiceInner::new(MemTable::new()).into();\n    let listener = TcpListener::bind(addr).await?;\n    info!(\"Start listening on {}\", addr);\n    loop {\n        let tls = acceptor.clone();\n        let (stream, addr) = listener.accept().await?;\n        info!(\"Client {:?} connected\", addr);\n        let stream = tls.accept(stream).await?;\n        let stream = ProstServerStream::new(stream, service.clone());\n        tokio::spawn(async move { stream.process().await });\n    }\n}\n</code></pre><p>src/client.rs：</p><pre><code class=\"language-rust\">use anyhow::Result;\nuse kv3::{CommandRequest, ProstClientStream, TlsClientConnector};\nuse tokio::net::TcpStream;\nuse tracing::info;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;()&gt; {\n    tracing_subscriber::fmt::init();\n\n    // 以后用配置替换\n    let ca_cert = include_str!(\"../fixtures/ca.cert\");\n\n    let addr = \"127.0.0.1:9527\";\n    // 连接服务器\n    let connector = TlsClientConnector::new(\"kvserver.acme.inc\", None, Some(ca_cert))?;\n    let stream = TcpStream::connect(addr).await?;\n    let stream = connector.connect(stream).await?;\n\n    let mut client = ProstClientStream::new(stream);\n\n    // 生成一个 HSET 命令\n    let cmd = CommandRequest::new_hset(\"table1\", \"hello\", \"world\".to_string().into());\n\n    // 发送 HSET 命令\n    let data = client.execute(cmd).await?;\n    info!(\"Got response {:?}\", data);\n\n    Ok(())\n}\n</code></pre><p>和上一讲的代码项目相比，更新后的客户端和服务器代码，各自仅仅多了一行，就把 TcpStream 封装成了 TlsStream。这就是使用 trait 做面向接口编程的巨大威力，系统的各个组件可以来自不同的 crates，但只要其接口一致（或者我们创建 adapter 使其接口一致），就可以无缝插入。</p><p>完成之后，打开一个命令行窗口，运行：<code>RUST_LOG=info cargo run --bin kvs --quiet</code>。然后在另一个命令行窗口，运行：<code>RUST_LOG=info cargo run --bin kvc --quiet</code>。此时，服务器和客户端都收到了彼此的请求和响应，并且处理正常。</p><p>现在，我们的 KV server 已经具备足够的安全性了！以后，等我们使用配置文件，就可以根据配置文件读取证书和私钥。这样可以在部署的时候，才从 vault 中获取私钥，既保证灵活性，又能保证系统自身的安全。</p><h2>小结</h2><p>网络安全是开发网络相关的应用程序中非常重要的一个环节。虽然 KV Server 这样的服务基本上会运行在云端受控的网络环境中，不会对 internet 提供服务，然而云端内部的安全性也不容忽视。你不希望数据在流动的过程中被篡改。</p><p>TLS 很好地解决了安全性的问题，可以保证整个传输过程中数据的机密性和完整性。如果使用客户端证书的话，还可以做一定程度的客户端合法性的验证。比如你可以在云端为所有有权访问 KV server 的客户端签发客户端证书，这样，只要客户端的私钥不泄露，就只有拥有证书的客户端才能访问 KV server。</p><p>不知道你现在有没有觉得，在 Rust 下使用 TLS 是非常方便的一件事情。并且，我们构建的 ProstServerStream / ProstClientStream，因为<strong>有足够好的抽象，可以在 TcpStream 和 TlsStream 之间游刃有余地切换</strong>。当你构建好相关的代码，只需要把 TcpStream 换成 TlsStream，KV server 就可以无缝切换到一个安全的网络协议栈。</p><h3>思考题</h3><ol>\n<li>目前我们的 kvc / kvs 只做了单向的验证，如果服务器要验证客户端的证书，该怎么做？如果你没有头绪，可以再仔细看看测试 TLS 的代码，然后改动 kvc/kvs 使得双向验证也能通过吧。</li>\n<li>除了 TLS，另外一个被广泛使用的处理应用层安全的协议是 <a href=\"https://noiseprotocol.org/\">noise protocol</a>。你可以阅读我的<a href=\"https://zhuanlan.zhihu.com/p/96944134\">这篇文章</a>了解 noise protocol。Rust 下有 <a href=\"https://github.com/mcginty/snow\">snow</a> 这个很优秀的库处理 noise protocol。对于有余力的同学，你们可以看看它的文档，尝试着写段类似 <a href=\"http://tls.rs\">tls.rs</a> 的代码，让我们的 kvs / kvc 可以使用 noise protocol。</li>\n</ol><p>欢迎在留言区分享你的思考，感谢你的收听，如果你觉得有收获，也欢迎你分享给身边的朋友，邀他一起讨论。</p><p>恭喜你完成了第37次打卡，我们的Rust学习之旅已经过一大半啦，曙光就在前方，坚持下去，我们下节课见～</p>","comments":[{"had_liked":false,"id":323019,"user_name":"罗同学","can_delete":false,"product_type":"c1","uid":1649119,"ip_address":"","ucode":"909B9EC768B9AD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/vHujib2CCrUYNBaia32eIwTyJoAcl27vASZ9KGjSdnH1dJhD7CrSUicBib19Tf8nDibWaHjzIsvIfdqcXX6vGrH8bicw/132","comment_is_top":false,"comment_ctime":1637710773,"is_pvip":false,"replies":[{"id":"118898","content":"TLS 使用非对称加密（比如 ECDH）来协商出本次 session 的密钥。问题是客户端如何信任服务器提供的公钥就是服务器本人？此时需要有人对服务器的公钥进行签名，为其背书，这个背书着就是 CA。那 CA 又是谁来背书？小 CA 由大 CA 背书，大 CA 再被 Root CA 背书。全世界也就几个十几个 Root CA。这些 Root CA 会被你所使用的操作系统信任。这样，某个服务器的证书就可以被一层层追溯到 Root CA，最终客户端可以信任它。这是 PKI 体系的基础。所有的网站，如果要支持 HTTPS，都需要有一个受信的证书。以前需要购买，现在有了 letsencrypt（背后有 google 的支持），所以可以免费得到受信的证书。<br><br>当你把 TLS 直接用在 TCP 之上时，可以自己生成 CA 证书。因为此刻，客户端和服务端都是你自己的代码，你可以在客户端内置信任的 CA 证书，这样就可以不依赖 PKI 体系来在服务器和客户端之间构建安全信道。","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639851517,"ip_address":"","comment_id":323019,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35997449141","product_id":100085301,"comment_content":"ca 证书和 tls什么关系呢？<br>另外为何以前做网站的时候证书都要向运营商购买申请？那个是什么证书","like_count":9,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539859,"discussion_content":"TLS 使用非对称加密（比如 ECDH）来协商出本次 session 的密钥。问题是客户端如何信任服务器提供的公钥就是服务器本人？此时需要有人对服务器的公钥进行签名，为其背书，这个背书着就是 CA。那 CA 又是谁来背书？小 CA 由大 CA 背书，大 CA 再被 Root CA 背书。全世界也就几个十几个 Root CA。这些 Root CA 会被你所使用的操作系统信任。这样，某个服务器的证书就可以被一层层追溯到 Root CA，最终客户端可以信任它。这是 PKI 体系的基础。所有的网站，如果要支持 HTTPS，都需要有一个受信的证书。以前需要购买，现在有了 letsencrypt（背后有 google 的支持），所以可以免费得到受信的证书。\n\n当你把 TLS 直接用在 TCP 之上时，可以自己生成 CA 证书。因为此刻，客户端和服务端都是你自己的代码，你可以在客户端内置信任的 CA 证书，这样就可以不依赖 PKI 体系来在服务器和客户端之间构建安全信道。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639851517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345672,"user_name":"新新人类","can_delete":false,"product_type":"c1","uid":2912722,"ip_address":"","ucode":"97EACC93996CCB","user_header":"","comment_is_top":false,"comment_ctime":1652501714,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652501714","product_id":100085301,"comment_content":"思考题1: 将 ServerConfig 的 ClientCertVerifier 改成 AllowAnyAuthenticatedClient<br><br>pub fn new(cert: &amp;str, key: &amp;str, client_ca: Option&lt;&amp;str&gt;) -&gt; Result&lt;Self, KvError&gt; {<br>    let certs = load_certs(cert)?;<br>    let key = load_key(key)?;<br><br>    let mut root_store = match rustls_native_certs::load_native_certs() {<br>      Ok(store) | Err((Some(store), _)) =&gt; store,<br>      Err((None, err)) =&gt; {<br>        return Err(err.into());<br>      }<br>    };<br>    &#47;&#47; 如果有签署客户端的 CA 证书，则加载它，这样客户端证书不在根证书链<br>    &#47;&#47; 但是这个 CA 证书能验证它，也可以<br>    if let Some(cert) = client_ca {<br>      let mut buf = Cursor::new(cert);<br>      root_store.add_pem_file(&amp;mut buf).unwrap();<br>    }<br>    &#47;&#47; 加载 server cert &#47; CA cert，生成 ServerConfig<br>    let mut config = ServerConfig::new(AllowAnyAuthenticatedClient::new(root_store));<br><br>    &#47;&#47; 加载服务器证书<br>    config<br>      .set_single_cert(certs, key)<br>      .map_err(|_| KvError::CertificateParseError(&quot;server&quot;, &quot;cert&quot;))?;<br>    config.set_protocols(&amp;[Vec::from(&amp;ALPN_KV[..])]);<br><br>    Ok(Self {<br>      inner: Arc::new(config),<br>    })<br>  }","like_count":0},{"had_liked":false,"id":323066,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1637718304,"is_pvip":false,"replies":[{"id":"118896","content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639850786,"ip_address":"","comment_id":323066,"utype":1}],"discussion_count":1,"race_medal":2,"score":"1637718304","product_id":100085301,"comment_content":"生成证书这块是我比较欠缺的知识，可以好好补充一下了。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539857,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639850787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}