{"id":213230,"title":"11 | MySQL如何应对高并发（一）：使用缓存保护MySQL","content":"<p>你好，我是李玥。</p><p>通过前面几节课的学习，相信你对MySQL这类关系型数据库的能力，已经有了定量的认知。</p><p>我们知道，大部分面向公众用户的互联网系统，它的并发请求数量是和在线用户数量正相关的，而MySQL能承担的并发读写的量是有上限的，当系统的在线用户超过几万到几十万这个量级的时候，单台MySQL就很难应付了。</p><p>绝大多数互联网系统，都使用MySQL加上Redis这对儿经典的组合来解决这个问题。Redis作为MySQL的前置缓存，可以替MySQL挡住绝大部分查询请求，很大程度上缓解了MySQL并发请求的压力。</p><p>Redis之所以能这么流行，非常重要的一个原因是，它的API非常简单，几乎没有太多的学习成本。但是，要想在生产系统中用好Redis和MySQL这对儿经典组合，并不是一件很简单的事儿。我在《<a href=\"https://time.geekbang.org/column/article/211008\">08 | 一个几乎每个系统必踩的坑儿：访问数据库超时</a>》举的社交电商数据库超时故障的案例，其中一个重要的原因就是，对缓存使用不当引发了缓存穿透，最终导致数据库被大量查询请求打死。</p><p>今天这节课，我们就来说一下，在电商的交易类系统中，如何正确地使用Redis这样的缓存系统，以及如何正确应对使用缓存过程中遇到的一些常见的问题。</p><!-- [[[read_end]]] --><h2>更新缓存的最佳方式</h2><p>要正确地使用好任何一个数据库，你都需要先了解它的能力和弱点，扬长避短。Redis是一个使用内存保存数据的高性能KV数据库，它的高性能主要来自于：</p><ol>\n<li>简单的数据结构；</li>\n<li>使用内存存储数据。</li>\n</ol><p>上节课我们讲到过，数据库可以分为执行器和存储引擎两部分，Redis的执行器这一层非常的薄，所以Redis只能支持有限的几个API，几乎没有聚合查询的能力，也不支持SQL。它的存储引擎也非常简单，直接在内存中用最简单的数据结构来保存数据，你从它的API中的数据类型基本就可以猜出存储引擎中数据结构。</p><p>比如，Redis的LIST在存储引擎的内存中的数据结构就是一个双向链表。内存是一种易失性存储，所以使用内存保存数据的Redis不能保证数据可靠存储。从设计上来说，Redis牺牲了大部分功能，牺牲了数据可靠性，换取了高性能。但也正是这些特性，使得Redis特别适合用来做MySQL的前置缓存。</p><p>虽然说，Redis支持将数据持久化到磁盘中，并且还支持主从复制，但你需要知道，<strong>Redis仍然是一个不可靠的存储，它在设计上天然就不保证数据的可靠性</strong>，所以一般我们都使用Redis做缓存，很少使用它作为唯一的数据存储。</p><p>即使只是把Redis作为缓存来使用，我们在设计Redis缓存的时候，也必须要考虑Redis的这种“数据不可靠性”，或者换句话说，我们的程序在使用Redis的时候，要能兼容Redis丢数据的情况，做到即使Redis发生了丢数据的情况，也不影响系统的数据准确性。</p><p>我们仍然用电商的订单系统来作为例子说明一下，如何正确地使用Redis做缓存。在缓存MySQL的一张表的时候，通常直接选用主键来作为Redis中的Key，比如缓存订单表，那就直接用订单表的主键订单号来作为Redis中的key。</p><p>如果说，Redis的实例不是给订单表专用的，还需要给订单的Key加一个统一的前缀，比如“orders:888888”。Value用来保存序列化后的整条订单记录，你可以选择可读性比较好的JSON作为序列化方式，也可以选择性能更好并且更节省内存的二进制序列化方式，都是可以的。</p><p>然后我们来说，缓存中的数据要怎么来更新的问题。我见过很多同学都是这么用缓存的：在查询订单数据的时候，先去缓存中查询，如果命中缓存那就直接返回订单数据。如果没有命中，那就去数据库中查询，得到查询结果之后把订单数据写入缓存，然后返回。在更新订单数据的时候，先去更新数据库中的订单表，如果更新成功，再去更新缓存中的数据。</p><p><img src=\"https://static001.geekbang.org/resource/image/c7/5e/c76155eaf8c6ac1e231d9bfb0e22ba5e.png?wh=1142*422\" alt=\"\"></p><p>这其实是一种经典的缓存更新策略: <strong>Read/Write Through</strong>。这样使用缓存的方式有没有问题？绝大多数情况下可能都没问题。但是，在并发的情况下，有一定的概率会出现“脏数据”问题，缓存中的数据可能会被错误地更新成了旧数据。</p><p>比如，对同一条订单记录，同时产生了一个读请求和一个写请求，这两个请求被分配到两个不同的线程并行执行，读线程尝试读缓存没命中，去数据库读到了订单数据，这时候可能另外一个读线程抢先更新了缓存，在处理写请求的线程中，先后更新了数据和缓存，然后，拿着订单旧数据的第一个读线程又把缓存更新成了旧数据。</p><p>这是一种情况，还有比如两个线程对同一个条订单数据并发写，也有可能造成缓存中的“脏数据”，具体流程类似于我在之前“<a href=\"https://time.geekbang.org/column/article/204673\">如何保证订单数据准确无误？</a>”这节课中讲到的ABA问题。你不要觉得发生这种情况的概率比较小，出现“脏数据”的概率是和系统的数据量以及并发数量正相关的，当系统的数据量足够大并且并发足够多的情况下，这种脏数据几乎是必然会出现的。</p><p>我在“<a href=\"https://time.geekbang.org/column/article/204688\">商品系统的存储该如何设计</a>”这节课中，在讲解如何缓存商品数据的时候，曾经简单提到过缓存策略。其中提到的Cache Aside模式可以很好地解决这个问题，在大多数情况下是使用缓存的最佳方式。</p><p>Cache Aside模式和上面的Read/Write Through模式非常像，它们处理读请求的逻辑是完全一样的，唯一的一个小差别就是，Cache Aside模式在更新数据的时候，并不去尝试更新缓存，而是去删除缓存。</p><p><img src=\"https://static001.geekbang.org/resource/image/0b/31/0b9c9cb74f017c632136280a63015931.png?wh=1142*161\" alt=\"\"></p><p>订单服务收到更新数据请求之后，先更新数据库，如果更新成功了，再尝试去删除缓存中订单，如果缓存中存在这条订单就删除它，如果不存在就什么都不做，然后返回更新成功。这条更新后的订单数据将在下次被访问的时候加载到缓存中。使用Cache Aside模式来更新缓存，可以非常有效地避免并发读写导致的脏数据问题。</p><h2>注意缓存穿透引起雪崩</h2><p>如果我们的缓存命中率比较低，就会出现大量“缓存穿透”的情况。缓存穿透指的是，在读数据的时候，没有命中缓存，请求“穿透”了缓存，直接访问后端数据库的情况。</p><p>少量的缓存穿透是正常的，我们需要预防的是，短时间内大量的请求无法命中缓存，请求穿透到数据库，导致数据库繁忙，请求超时。大量的请求超时还会引发更多的重试请求，更多的重试请求让数据库更加繁忙，这样恶性循环导致系统雪崩。</p><p>当系统初始化的时候，比如说系统升级重启或者是缓存刚上线，这个时候缓存是空的，如果大量的请求直接打过来，很容易引发大量缓存穿透导致雪崩。为了避免这种情况，可以采用灰度发布的方式，先接入少量请求，再逐步增加系统的请求数量，直到全部请求都切换完成。</p><p>如果系统不能采用灰度发布的方式，那就需要在系统启动的时候对缓存进行预热。所谓的缓存预热就是在系统初始化阶段，接收外部请求之前，先把最经常访问的数据填充到缓存里面，这样大量请求打过来的时候，就不会出现大量的缓存穿透了。</p><p>还有一种常见的缓存穿透引起雪崩的情况是，当发生缓存穿透时，如果从数据库中读取数据的时间比较长，也容易引起数据库雪崩。</p><p>这种情况我在《<a href=\"https://time.geekbang.org/column/article/211008\">08 | 一个几乎每个系统必踩的坑儿：访问数据库超时</a>》这节课中也曾经提到过。比如说，我们缓存的数据是一个复杂的数据库联查结果，如果在数据库执行这个查询需要10秒钟，那当缓存中这条数据过期之后，最少10秒内，缓存中都不会有数据。</p><p>如果这10秒内有大量的请求都需要读取这个缓存数据，这些请求都会穿透缓存，打到数据库上，这样很容易导致数据库繁忙，当请求量比较大的时候就会引起雪崩。</p><p>所以，如果说构建缓存数据需要的查询时间太长，或者并发量特别大的时候，Cache Aside或者是Read/Write Through这两种缓存模式都可能出现大量缓存穿透。</p><p>对于这种情况，并没有一种方法能应对所有的场景，你需要针对业务场景来选择合适解决方案。比如说，可以牺牲缓存的时效性和利用率，缓存所有的数据，放弃Read Through策略所有的请求，只读缓存不读数据库，用后台线程来定时更新缓存数据。</p><h2>小结</h2><p>使用Redis作为MySQL的前置缓存，可以非常有效地提升系统的并发上限，降低请求响应时延。绝大多数情况下，使用Cache Aside模式来更新缓存都是最佳的选择，相比Read/Write Through模式更简单，还能大幅降低脏数据的可能性。</p><p>使用Redis的时候，还需要特别注意大量缓存穿透引起雪崩的问题，在系统初始化阶段，需要使用灰度发布或者其他方式来对缓存进行预热。如果说构建缓存数据需要的查询时间过长，或者并发量特别大，这两种情况下使用Cache Aside模式更新缓存，会出现大量缓存穿透，有可能会引发雪崩。</p><p>顺便说一句，我们今天这节课中讲到的这些缓存策略，都是非常经典的理论，早在互联网大规模应用之前，这些缓存策略就已经非常成熟了，在操作系统中，CPU Cache的缓存、磁盘文件的内存缓存，它们也都应用了我们今天讲到的这些策略。</p><p>所以无论技术发展的多快，计算机的很多基础的理论的知识都是相通的，你绞尽脑汁想出的解决工程问题的方法，很可能早都写在几十年前出版的书里。学习算法、数据结构、设计模式等等这些基础的知识，并不只是为了应付面试。</p><h2>思考题</h2><p>课后请你想一下，具体什么情况下，使用Cache Aside模式更新缓存会产生脏数据？欢迎你在评论区留言，通过一个例子来说明情况。</p><p>感谢阅读，如果你觉得今天的内容对你有帮助，也欢迎把它分享给你的朋友。</p>","neighbors":{"left":{"article_title":"10 | 走进黑盒：SQL是如何在数据库中执行的？","id":213176},"right":{"article_title":"12 | MySQL如何应对高并发（二）：读写分离","id":215330}},"comments":[{"had_liked":false,"id":191359,"user_name":"李玥","can_delete":false,"product_type":"c1","uid":1501046,"ip_address":"","ucode":"B19E91EE248591","user_header":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","comment_is_top":true,"comment_ctime":1584765501,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"9.2233721715835003e+18","product_id":100046801,"comment_content":"Hi，我是李玥。<br><br>这里回顾一下上节课的思考题：<br><br>课后请你选一种你熟悉的非关系型数据库，最好是支持 SQL 的，当然，不支持 SQL 有自己的查询语言也可以。比如说 HBase、Redis 或者 MongoDB 等等都可以，尝试分析一下查询的执行过程，对比一下它的执行器和存储引擎与 MySQL 有什么不同。<br><br>谈一下我的理解：<br><br>我们拿一个分布式数据库Hive来看一下它的执行器和存储引擎。严格来说，Hive并不是一个数据库，它只是一个执行器，它的存储引擎就是HDFS加上Map-Reduce。在Hive中，一条SQL的执行过程是和MySQL差不多的，Hive会解析SQL，生成并优化逻辑执行计划，然后它就会把逻辑执行计划交给Map-Reduce去执行了，后续生成并优化物理执行计划，在HDFS上执行查询这些事儿，都是Map-Reduce去干的。顺便说一下，Hive的执行引擎（严格来说是物理执行引擎）是可以替换的，所以就有了Hive on Spark，Hive on Tez这些。","like_count":32},{"had_liked":false,"id":191919,"user_name":"Geek_3894f9","can_delete":false,"product_type":"c1","uid":1594820,"ip_address":"","ucode":"FD04B8163FC5A8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKrzZT06vXeP6IfR9iasoiaaDeYiaUmmN6pgwvNUpLhrauiasU9acvNcdSuicrhicMmBhvEufcjPTS7ZXRA/132","comment_is_top":false,"comment_ctime":1584803267,"is_pvip":false,"replies":[{"id":"73515","content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1584846253,"ip_address":"","comment_id":191919,"utype":1}],"discussion_count":19,"race_medal":0,"score":"272167742915","product_id":100046801,"comment_content":"数据加版本号，写库时自动增一。更新缓存时，只允许高版本数据覆盖低版本数据。","like_count":64,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488285,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584846253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1448893,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKj4w4lW7ibGEVxPv8wS1CrXKDeBz3RAaAdISxQSD23uUpV3wicsIMepaYZE8GzRcWmSpjet5NDN4MA/132","nickname":"Zm","note":"","ucode":"831FF80F07E965","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373848,"discussion_content":"不可以的，如果A/B两个线程并发进来，此时缓存恰好到了过期时间失效了。\nA线程：\n1、读缓存，没读取到，读数据库，读到了数据v1。\n2、把数据v1写到缓存中。\nB线程：\n1、更新数据库。\n2、删除缓存。\n如果A1在B1、B2之前，A2在B1、B2之后这样子加版本号根本没办法解决的。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1620893157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1500391,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e4/e7/31944ee7.jpg","nickname":"千军万马万马@","note":"","ucode":"0BDAD22123435A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1448893,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKj4w4lW7ibGEVxPv8wS1CrXKDeBz3RAaAdISxQSD23uUpV3wicsIMepaYZE8GzRcWmSpjet5NDN4MA/132","nickname":"Zm","note":"","ucode":"831FF80F07E965","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556359,"discussion_content":"那到底怎么办啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647328365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":373848,"ip_address":""},"score":556359,"extra":""}]},{"author":{"id":1484192,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/a0/e0cccf7e.jpg","nickname":"圆圆满满","note":"","ucode":"396E7A822014D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215558,"discussion_content":"更新缓存时，还是第一步查缓存，第二步比较版本决定是否更新缓存。这两步之间还是有可能被别的线程更新数据。此时用lua保证这两步的原子性？","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1585356083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1034001,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c7/11/89ba9915.jpg","nickname":"永远的草莓地","note":"","ucode":"D4BD8DD42350CC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1484192,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/a0/e0cccf7e.jpg","nickname":"圆圆满满","note":"","ucode":"396E7A822014D1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":235404,"discussion_content":"同问，最后一步，compare and set 必须得原子才可以吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587039391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":215558,"ip_address":""},"score":235404,"extra":""},{"author":{"id":1433535,"avatar":"https://static001.geekbang.org/account/avatar/00/15/df/bf/96b50d1e.jpg","nickname":"😚 46","note":"","ucode":"EED0EBBBF80A43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1484192,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/a0/e0cccf7e.jpg","nickname":"圆圆满满","note":"","ucode":"396E7A822014D1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265815,"discussion_content":"很棒的问题，差点遗漏了这种情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589441825,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":215558,"ip_address":""},"score":265815,"extra":""}]},{"author":{"id":1320730,"avatar":"https://static001.geekbang.org/account/avatar/00/14/27/1a/77fb1e4e.jpg","nickname":"Lingjun","note":"","ucode":"5CE38C19231D3B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211695,"discussion_content":"read/write through + 版本貌似是比较完美的方案了👍","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1584880507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534716,"discussion_content":"首先回答下老师的问题：\n理论上总是存在这种情况。比方说 缓存失效发生在写库与失效缓存之间 那么此时读请求读出来的数据就是旧的。但是这种场景通常概率极低，因为读总是快于写 所以工程上不多见。再来说下如何解决，两种方法：\n1. 不解决 。通常也是这么做 即接受这种问题\n2. 使用容错窗口。原理类似老师上节课提出的 spu改动价格，允许一段时间内旧价格下单成功\n\n下面再来说说为什么write through / read through 不适合这种场景\n本质上是由于两个并发写（读请求与写请求）会存在彼此脏写覆盖 因为最终写入其实没有锁或同步机制来做协调。\n这个问题在《Why does Facebook use delete to remove the key-value pair in Memcached instead of updating the Memcached during write request to the backend?》有讨论过","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638260722,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1162660,"avatar":"https://static001.geekbang.org/account/avatar/00/11/bd/a4/cf4744ce.jpg","nickname":"老邪","note":"","ucode":"DACC50B0E3688E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275513,"discussion_content":"这里不行的，版本对比不是原子的，同时来两个不同的新版本，都可以更新。老一些的新版本可能覆盖最新的。 大佬怎么看？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590722834,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1594820,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKrzZT06vXeP6IfR9iasoiaaDeYiaUmmN6pgwvNUpLhrauiasU9acvNcdSuicrhicMmBhvEufcjPTS7ZXRA/132","nickname":"Geek_3894f9","note":"","ucode":"FD04B8163FC5A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1162660,"avatar":"https://static001.geekbang.org/account/avatar/00/11/bd/a4/cf4744ce.jpg","nickname":"老邪","note":"","ucode":"DACC50B0E3688E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":280797,"discussion_content":"更新缓存是串行操作（某一版本更新完成后才会开始另一个版本的更新）。缓存要么逐次更新到最新版本，要么先更新到最新版本，次新版本在更新时被忽略。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1591612564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":275513,"ip_address":""},"score":280797,"extra":""},{"author":{"id":1484184,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","nickname":"djfhchdh","note":"","ucode":"E71D75328CE398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1162660,"avatar":"https://static001.geekbang.org/account/avatar/00/11/bd/a4/cf4744ce.jpg","nickname":"老邪","note":"","ucode":"DACC50B0E3688E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306209,"discussion_content":"明飞大佬？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600218950,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":275513,"ip_address":""},"score":306209,"extra":""}]},{"author":{"id":1295883,"avatar":"https://static001.geekbang.org/account/avatar/00/13/c6/0b/eb3589f1.jpg","nickname":"🐳大海全是水","note":"","ucode":"8FB523F8D54D8B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220447,"discussion_content":"加版本号一样在cache aside下一样会出现脏数据。a线程读缓存发现没有数据，去数据库读取了，旧版本数据出来，b线程稍后，更新了数据库，删除缓存，之后a线程写入旧版本数据。这样后面的读取都是脏数据了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585878105,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":1594820,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKrzZT06vXeP6IfR9iasoiaaDeYiaUmmN6pgwvNUpLhrauiasU9acvNcdSuicrhicMmBhvEufcjPTS7ZXRA/132","nickname":"Geek_3894f9","note":"","ucode":"FD04B8163FC5A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1295883,"avatar":"https://static001.geekbang.org/account/avatar/00/13/c6/0b/eb3589f1.jpg","nickname":"🐳大海全是水","note":"","ucode":"8FB523F8D54D8B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221314,"discussion_content":"赞同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586002875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":220447,"ip_address":""},"score":221314,"extra":""},{"author":{"id":1046664,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/88/96b870fd.jpg","nickname":"zcc","note":"","ucode":"58FB42400517A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1594820,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKrzZT06vXeP6IfR9iasoiaaDeYiaUmmN6pgwvNUpLhrauiasU9acvNcdSuicrhicMmBhvEufcjPTS7ZXRA/132","nickname":"Geek_3894f9","note":"","ucode":"FD04B8163FC5A8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221676,"discussion_content":"或者读写分离，查询服务启动时查询预热缓存（之后读请求不再更新缓存），更新记录时必须更新缓存。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586045287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":221314,"ip_address":""},"score":221676,"extra":""},{"author":{"id":1615539,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI6LXcIqb5K48nia8d4zmdsD1M9AZeyXoGrLzX5xvqfN0fqXOsYKUWLbZvZ8TtJCXWmYbCkCXg93dQ/132","nickname":"漏脚脖","note":"","ucode":"214AE52EC201E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1295883,"avatar":"https://static001.geekbang.org/account/avatar/00/13/c6/0b/eb3589f1.jpg","nickname":"🐳大海全是水","note":"","ucode":"8FB523F8D54D8B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":230263,"discussion_content":"后边再来个c线程，如果版本号大于redis里的版本号，就再更新redis呗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586738608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":220447,"ip_address":""},"score":230263,"extra":""}]},{"author":{"id":1332557,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbY9UsqHZhhVoI69yXNibBBg0TRdUVsKLMg2UZ1R3NJxXdMicqceI5yhdKZ5Ad6CJYO0XpFHlJzIYQ/132","nickname":"饭团","note":"","ucode":"E24F240CC91BE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212386,"discussion_content":"好办法！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584966803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191525,"user_name":"公号-技术夜未眠","can_delete":false,"product_type":"c1","uid":1013683,"ip_address":"","ucode":"83825B57CBD952","user_header":"https://static001.geekbang.org/account/avatar/00/0f/77/b3/991f3f9b.jpg","comment_is_top":false,"comment_ctime":1584779066,"is_pvip":true,"discussion_count":13,"race_medal":0,"score":"203448241978","product_id":100046801,"comment_content":"Cache Aside 在高并发场景下也会出现数据不一致。<br>读操作A，没有命中缓存，就会到数据库中取数据v1。<br>此时来了一个写操作B，将v2写入数据库，让缓存失效；<br>读操作A在把v1放入缓存，这样就会造成脏数据。因为缓存中是v1，数据库中是v2.<br>","like_count":48,"discussions":[{"author":{"id":1259218,"avatar":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","nickname":"发条橙子 。","note":"","ucode":"ED076F4534FFED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211483,"discussion_content":"这种概率比较小 因为大多数读都会比写快","likes_number":19,"is_delete":false,"is_hidden":false,"ctime":1584856356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1004349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/3d/1189e48a.jpg","nickname":"微思","note":"","ucode":"853C48AA183A7B","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":1259218,"avatar":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","nickname":"发条橙子 。","note":"","ucode":"ED076F4534FFED","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370763,"discussion_content":"对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619526590,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":211483,"ip_address":""},"score":370763,"extra":""}]},{"author":{"id":1314879,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/2nvw0GuJKcxfAsMrevuetMTXZNM2pf6vTL0LKNibH1tj7PhualK888g1MYRuo8hooGEgfcrc93IFY757C3AXiaTA/132","nickname":"peekaboo","note":"","ucode":"507BCFF01B3A39","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556848,"discussion_content":"实际场景中，会使用延迟双删的策略，也就是说先更新db, 接着立马删除redis中的key，睡眠0.5s(根据业务场景来定)，再删除一次key","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1647534990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2328990,"avatar":"","nickname":"Geek4870","note":"","ucode":"30DBE32C77FFE1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1314879,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/2nvw0GuJKcxfAsMrevuetMTXZNM2pf6vTL0LKNibH1tj7PhualK888g1MYRuo8hooGEgfcrc93IFY757C3AXiaTA/132","nickname":"peekaboo","note":"","ucode":"507BCFF01B3A39","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":557267,"discussion_content":"这样又可能会出现缓存击穿的场景","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647746698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":556848,"ip_address":""},"score":557267,"extra":""}]},{"author":{"id":1187478,"avatar":"https://static001.geekbang.org/account/avatar/00/12/1e/96/c735ad6b.jpg","nickname":"滩涂曳尾","note":"","ucode":"40F650F2A419D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554519,"discussion_content":"例如，读线程 在读db后，回种cache前，发生java GC，或其他情况线程卡顿，就能出现这种情况","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1646437313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1290791,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLgIx7TUqhftK68PyEUt5mNBX4ruvprm0EPnvusrSdibqCdygia0w8dCNr5Tuib4HUJnUlFaP0KDllPw/132","nickname":"Geek_076d5e","note":"","ucode":"C3C1A32AB9457B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":280802,"discussion_content":"A先来的话，这个场景正常啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591613211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1902999,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/09/97/502e8869.jpg","nickname":"Colorful","note":"","ucode":"2D6AD65B28239E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1290791,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLgIx7TUqhftK68PyEUt5mNBX4ruvprm0EPnvusrSdibqCdygia0w8dCNr5Tuib4HUJnUlFaP0KDllPw/132","nickname":"Geek_076d5e","note":"","ucode":"C3C1A32AB9457B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297639,"discussion_content":"赞成","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596991509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":280802,"ip_address":""},"score":297639,"extra":""},{"author":{"id":1228313,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/vQiadbkZYR239J80hjekw7jzY9vy6otLKPNDSuz2lruDiaXlKGkcsX5wwiaFevicgqV8odlRG4UITiadDF3fgicrHPcw/132","nickname":"疯码","note":"","ucode":"7FF11EC80439EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1902999,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/09/97/502e8869.jpg","nickname":"Colorful","note":"","ucode":"2D6AD65B28239E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334050,"discussion_content":"对A来说正常 但是缓存数据坏了，后续的其他请求都不对了","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1607705379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":297639,"ip_address":""},"score":334050,"extra":""}]},{"author":{"id":2115387,"avatar":"https://static001.geekbang.org/account/avatar/00/20/47/3b/70198ceb.jpg","nickname":"Aibo","note":"","ucode":"2CE3E77BD2D014","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553004,"discussion_content":"所以如果业务要保证数据的高一致性，不管是哪种模式，都需要格外的手段。比如基于消息队列的重试，达到最终一致性；基于 2pc、tcc通过分布式锁达到强一致","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645685331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534695,"discussion_content":"实际上就是保证失效的那一刻 正好读请求能拿到老版本数据 但这种情况就像楼上同学说的是小概率 所以工程上忽略不计","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638257811,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1131477,"avatar":"https://static001.geekbang.org/account/avatar/00/11/43/d5/5af042f6.jpg","nickname":"张世柏","note":"","ucode":"F43CF5BF9356A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368927,"discussion_content":"可以使用延时双写策略","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618883715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1333094,"avatar":"https://static001.geekbang.org/account/avatar/00/14/57/66/e57bdb18.jpg","nickname":"liliumss","note":"","ucode":"A52AC5042F3115","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219050,"discussion_content":"谢谢分享","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585727809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1469608,"avatar":"https://static001.geekbang.org/account/avatar/00/16/6c/a8/1922a0f5.jpg","nickname":"郑祖煌","note":"","ucode":"49A0D2E3279826","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215748,"discussion_content":"原来如此","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585378764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191455,"user_name":"GaGi","can_delete":false,"product_type":"c1","uid":1099053,"ip_address":"","ucode":"CC8D22E1DD8CA2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c5/2d/1eebfc3c.jpg","comment_is_top":false,"comment_ctime":1584774708,"is_pvip":false,"replies":[{"id":"73513","content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1584846086,"ip_address":"","comment_id":191455,"utype":1}],"discussion_count":16,"race_medal":0,"score":"156203597364","product_id":100046801,"comment_content":"对于Cache aside和read&#47;write through而带来的数据不一致问题，工作中是这样解决：<br>a写线程，b读线程：<br>b线程：读缓存-&gt;未命中-&gt;上写锁&gt;从db读数据到缓存-&gt;释放锁；<br>a线程：上写锁-&gt;写db-&gt;删除缓存&#47;改缓存-&gt;释放锁；<br>这样来保证a，b线程并发读写缓存带来的脏数据问题；<br><br>","like_count":37,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488178,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584846086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1691516,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cf/7c/2e99d0ad.jpg","nickname":"一新","note":"","ucode":"1915C6C655C31F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281581,"discussion_content":"只要缓存命中率不是太低，感觉还是可取的 ，奶思","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591769829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1446375,"avatar":"https://static001.geekbang.org/account/avatar/00/16/11/e7/044a9a6c.jpg","nickname":"book尾汁","note":"","ucode":"AE2B8DFC643ACC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215990,"discussion_content":"感觉只要读线程上个读锁就够了吧，保证读线程读取数据到内存的时候，该行数据不能被更改就行了吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585401726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1173129,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e6/89/d8aec012.jpg","nickname":"Liang","note":"","ucode":"E1A816EE5CE7DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1446375,"avatar":"https://static001.geekbang.org/account/avatar/00/16/11/e7/044a9a6c.jpg","nickname":"book尾汁","note":"","ucode":"AE2B8DFC643ACC","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":305464,"discussion_content":"写线程也要加写锁的，不然还是有可能造成数据不一致","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599930294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":215990,"ip_address":""},"score":305464,"extra":""},{"author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1173129,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e6/89/d8aec012.jpg","nickname":"Liang","note":"","ucode":"E1A816EE5CE7DC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366287,"discussion_content":"读线程加读锁，可以增加读并发","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618021647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":305464,"ip_address":""},"score":366287,"extra":""}]},{"author":{"id":2226157,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/0yfPt7iaQXLHH6LT41jfWhUZwdKwaPxPJGuzAVFf7nsvWd0cNXFoxMxTNtBX1N58AJQPzPAZVDo4FoOxh5BDlFQ/132","nickname":"zhangzhijun","note":"","ucode":"AAA2B2F4287D62","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570057,"discussion_content":"这种场景只适合单机版的场景吧，集群实例下高并发来读，加写锁会有性能问题。还是建议采用延时双删来保证。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651650642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1433535,"avatar":"https://static001.geekbang.org/account/avatar/00/15/df/bf/96b50d1e.jpg","nickname":"😚 46","note":"","ucode":"EED0EBBBF80A43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265805,"discussion_content":"使用redisson提供的RReadWriteLock读写锁会不会更好呢？线程a上写锁，线程b读锁，但我还没验证过可行性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589441306,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005217,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/56/a1/abb7bfe3.jpg","nickname":"skyitachi","note":"","ucode":"FED5D96CC717B0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":252946,"discussion_content":"多机器的情况要上分布式锁吧，你的写锁应该都是本地锁吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588207450,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1691516,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cf/7c/2e99d0ad.jpg","nickname":"一新","note":"","ucode":"1915C6C655C31F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1005217,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/56/a1/abb7bfe3.jpg","nickname":"skyitachi","note":"","ucode":"FED5D96CC717B0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281579,"discussion_content":"for update","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591769678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":252946,"ip_address":""},"score":281579,"extra":""}]},{"author":{"id":1798979,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/73/43/ae139b1f.jpg","nickname":"博","note":"","ucode":"F7CA69FF5D09BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216028,"discussion_content":"起初觉得上锁是个好办法，但是锁的粒度和性能成反比，需要慎重","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585402787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1039069,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/da/dd/1e5e7b0c.jpg","nickname":"image","note":"","ucode":"A45BFF284F8933","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214820,"discussion_content":"锁粒度较大，但也是好方法，版本号方法可以性能更高","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585235293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1554570,"avatar":"https://static001.geekbang.org/account/avatar/00/17/b8/8a/7367a69e.jpg","nickname":"嘉兴","note":"","ucode":"6997E7A3E25EE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213482,"discussion_content":"有个问题，n个并发读线程只有一个加写锁成功，那其他n-1个怎么办？\n1.  其他n-1个线程直接返回重试的提示\n2. 其他n-1个线程等待（sleep），但等待多久又是个问题，太短无效，太久浪费资源","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585098627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1433535,"avatar":"https://static001.geekbang.org/account/avatar/00/15/df/bf/96b50d1e.jpg","nickname":"😚 46","note":"","ucode":"EED0EBBBF80A43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1554570,"avatar":"https://static001.geekbang.org/account/avatar/00/17/b8/8a/7367a69e.jpg","nickname":"嘉兴","note":"","ucode":"6997E7A3E25EE4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265790,"discussion_content":"这种情况，通常是大流量冲击，我认为直接返回失败，让用户手动重试会更好些。如果采用系统自动重试或等待，不仅占用系统资源影响吞吐量还可能因为重试而引发雪崩","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589439512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":213482,"ip_address":""},"score":265790,"extra":""}]},{"author":{"id":1112651,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fa/4b/c385f755.jpg","nickname":"向前走","note":"","ucode":"8956E92DCEFB60","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211850,"discussion_content":"这里是线程a,b都上写锁么,还是只有写的线程a上写锁呢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584890375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1691516,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cf/7c/2e99d0ad.jpg","nickname":"一新","note":"","ucode":"1915C6C655C31F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1112651,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fa/4b/c385f755.jpg","nickname":"向前走","note":"","ucode":"8956E92DCEFB60","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281580,"discussion_content":"select ... for update","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591769769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":211850,"ip_address":""},"score":281580,"extra":""}]},{"author":{"id":1259218,"avatar":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","nickname":"发条橙子 。","note":"","ucode":"ED076F4534FFED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211484,"discussion_content":"直接上锁 并发量大的时候是否会产生瓶颈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584856557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235132,"user_name":"二进制之路","can_delete":false,"product_type":"c1","uid":1008395,"ip_address":"","ucode":"67C84B013147B1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/0b/ad56aeb4.jpg","comment_is_top":false,"comment_ctime":1594901385,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"70314378121","product_id":100046801,"comment_content":"老师，看了你对缓存模式的解读之后，跟我之前的理解感觉有比较大的冲突。<br><br>在文中，你提到的 Read&#47;Write Through 策略，我看到的更多的是把这种方式称为Cache Aside。<br>而Cache Aside 和 Read&#47;Write Throug的差别，也不是是否去删除缓存。<br><br>我看的一些文章，包括买的书籍，大部分都跟ehcache caching-patterns描述的意思差不多，总结如下：<br><br># Cache Aside<br><br>应用程序直接与DB、缓存交互，并负责对缓存的维护。<br><br>读数据时，先访问缓存，命中则直接返回。<br>如果不命中，则先查询DB，并将数据写到缓存，最后返回数据。<br><br>写数据时，同时更新DB和缓存。<br><br><br># Read-Through<br><br>应用程序只与缓存交互，而对DB的读取由缓存来代理。<br><br>读数据时，先访问缓存，命中则直接返回。<br>如果不命中，则由缓存查询DB，并将数据写到缓存，最后返回数据。<br><br><br># Write-Through<br><br>应用程序只与缓存交互，而对DB的写由缓存来代理。<br><br>写数据时，访问缓存，由缓存将数据写到DB，并将数据缓存起来。<br><br><br>例如使用Redis来缓存MySQL的数据，一般都是通过应用程序来直接与Redis、MySQL交互，我的理解是Cache Aside，包&quot;是&#47;否&quot;删除Cache在内。<br><br>而Read-Through，像Guava LoadingCache，在load里面定义好访问DB的代码，后续的读操作都是直接与Cache交互了。<br><br><br>https:&#47;&#47;www.ehcache.org&#47;documentation&#47;3.8&#47;caching-patterns.html<br>https:&#47;&#47;docs.oracle.com&#47;cd&#47;E15357_01&#47;coh.360&#47;e15723&#47;cache_rtwtwbra.htm#COHDG5178<br>https:&#47;&#47;dzone.com&#47;articles&#47;using-read-through-amp-write-through-in-distribute<br>https:&#47;&#47;docs.microsoft.com&#47;en-us&#47;azure&#47;architecture&#47;patterns&#47;cache-aside<br>《亿级流量网站架构核心技术》<br>","like_count":17,"discussions":[{"author":{"id":1481979,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9c/fb/7fe6df5b.jpg","nickname":"陈卧虫","note":"","ucode":"44BB84712436AB","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590490,"discussion_content":"应用程序只与缓存交互，还是直接与mysql交互，难道不是代码分装方式的不同吗？本质流程还是一样的啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665815710,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111624,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f6/48/b7054856.jpg","nickname":"原来只是梦","note":"","ucode":"C12C59BA333C5D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371095,"discussion_content":"我学到的也是跟你的一样。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619652395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":192066,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1584835961,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35944574329","product_id":100046801,"comment_content":"思考题<br>Cache Aside 模式如何产生脏数据？<br>首先 Cache Aside 这种模式和 Read&#47;Write Through    模式的读取操作一样，都是先尝试读缓存，如果命中直接返回;未命中的话读数据库，然后更新缓存。<br>写操作不是更新缓存，而是把缓存中的数据删掉<br>那怎么出现脏数据？<br>假设有下面两个线程对 key 分别进行读写操作<br>读线程 t1<br>写线程 t2<br>按照下面的流程进行操作<br>1. t1 读缓存未命中，然后从数据库中读到 value1<br>2. t2 更新 key 为 value2，并尝试删缓存(此时缓存中并没有)<br>3. t1 把从 db 中读到的 value1写回缓存<br><br>这时 db 中 key 的 value 为新数据 value2，缓存中为旧数据 value1，产生了不一致。<br>这种情况只发生在读线程从 bd 读到旧数据往 cache    中写前，有写线程更新了 db，然后读线程把老数据写回 cache<br><br><br>Read&#47;Write Through 发生脏数据的情况<br>第一种情况是并发读写<br>对 key 进行读写的两个线程<br>读线程 t1<br>写线程 t2<br><br>按照如下时间顺序操作<br>1.t1 尝试读缓存但未命中，然后去 db 中读取到了数据 value1，但还未更新缓存兄弟的数据<br>2. t2 更新数据库 value2，更新成功后常识读取缓存，未命中，所以更新缓存为 value2<br>3.t1 线程继续把之前从 db 中读到的旧数据 value1 写回缓存<br>这样 db 中是新数据，但缓存中是旧数据<br><br>第二种情况是并发写<br>这种情况是db 中产生了 ABA 问题<br>比如有两个写线程 t1,t2，分别按下面的先后顺序操作<br>1.t1 尝试把 key 更新为 value1，但响应丢失<br>2.t2 尝试把 key 更新为 value2，还未响应结果<br>3.t1 发生重试操作<br>4.t2 响应成功<br>5.t1 响应成功<br>本来写应该按先后顺序的，t2后到，数据库和缓存中应该是 value2，但因为 t1 发生了重试，导致数据库和缓存中是 value1了，产生了ABA问题，解决办法是在更新时加上 version 版本号判断<br><br>所以没啥万能的方法，需要根据业务场景来制定方法","like_count":8},{"had_liked":false,"id":210725,"user_name":"seg-上海","can_delete":false,"product_type":"c1","uid":1760320,"ip_address":"","ucode":"46BA8DCB06ED5E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLBllicLBj61g1ibmCeWzLYpQYEteTOtAAAypoIg6CD19ibXQBbM09VsME9Ta1G8ubwk0ibjiacItavibaeg/132","comment_is_top":false,"comment_ctime":1587815782,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23062652262","product_id":100046801,"comment_content":"1）缓存刚好失效<br>（2）请求A查询数据库，得一个旧值<br>（3）请求B将新值写入数据库<br>（4）请求B删除缓存<br>（5）请求A将查到的旧值写入缓存<br>","like_count":5,"discussions":[{"author":{"id":1031970,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/bf/22/26530e66.jpg","nickname":"趁早","note":"","ucode":"949FB3AA250D80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299337,"discussion_content":"你这种并不会产生脏数据，请求A不会将旧值写入缓存，出现脏数据是做了读写分离，并且有延迟的情况才会产生","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597661422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191139,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1584748539,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"23059585019","product_id":100046801,"comment_content":"A,B两个进程<br>B read cache  x=null<br>B read DB x=1<br>A write DB x=2<br>A delete cache<br>B write cache x=1<br>这时数据库里x=2，缓存中x=1，直到缓存过期之前一直是脏数据。这种概率算是比较小的了。<br><br>文章中提到用灰度来解决问题，似乎解决不了基于类似redis这种做分布式缓存时的问题。<br><br>","like_count":5,"discussions":[{"author":{"id":1367361,"avatar":"https://static001.geekbang.org/account/avatar/00/14/dd/41/1205154f.jpg","nickname":"Ian","note":"","ucode":"AA69F4F216BDA5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211309,"discussion_content":"实在搞不懂这种逻辑，B读数据库时间在前，A写数据库时间在后，为啥B要等A删完缓存再写缓存呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584839905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1046714,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","nickname":"约书亚","note":"","ucode":"81EA27ADD9EC1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1367361,"avatar":"https://static001.geekbang.org/account/avatar/00/14/dd/41/1205154f.jpg","nickname":"Ian","note":"","ucode":"AA69F4F216BDA5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211966,"discussion_content":"B没有故意等，是由于各种不可控因素，比如:网络延迟，GC，或者根本就是B的线程失去时间片一直得不到执行。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1584917249,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":211309,"ip_address":""},"score":211966,"extra":""}]}]},{"had_liked":false,"id":207786,"user_name":"mickey","can_delete":false,"product_type":"c1","uid":1051663,"ip_address":"","ucode":"8B490C2DDE4010","user_header":"https://static001.geekbang.org/account/avatar/00/10/0c/0f/93d1c8eb.jpg","comment_is_top":false,"comment_ctime":1587179221,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18767048405","product_id":100046801,"comment_content":"老师好。文中写“订单服务收到更新数据请求之后，先更新数据库，如果更新成功了，再尝试去删除缓存中订单，如果缓存中存在这条订单就删除它，如果不存在就什么都不做，然后返回更新成功。这条更新后的订单数据将在下次被访问的时候加载到缓存中。”<br><br>请问，前面的读线程没命中，去数据库读到了订单数据，这是写进程进来完成后，读线程将原来读的脏数据生成了缓存，这样还是不能解决问题啊？","like_count":4},{"had_liked":false,"id":196837,"user_name":"丁小明","can_delete":false,"product_type":"c1","uid":1207622,"ip_address":"","ucode":"CC23857B8D75D5","user_header":"https://static001.geekbang.org/account/avatar/00/12/6d/46/e16291f8.jpg","comment_is_top":false,"comment_ctime":1585316793,"is_pvip":false,"replies":[{"id":"74831","content":"首先这是个经典的方案，靠谱是没问题的。它可以解决问题是，不用真正去查询数据集，就可以判断，请求的数据是不是，不在数据集内。如果不在就不用去查询数据集了。<br><br>不少数据库都内置了布隆过滤器来提升查询效率，比如HBase。<br><br>布隆过滤器的缺点就是有点复杂，实现难度还是挺大的。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1585533305,"ip_address":"","comment_id":196837,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18765185977","product_id":100046801,"comment_content":"老师，经常看到说用布隆过滤来解决缓存穿透问题，这个方案有实际的案例吗？<br>如果是真的可以那么怎么去操作呢？<br>先初始化所有可能存到缓存里面数据的key到一个足够大的布隆过滤器，然后如果有新增数据就就继续往过滤器中放，删除就从过滤器里面删（又看到说不用bit的话支持累加删除）<br>如果发现不在过滤器中就表示一定不存在，就无需查询了。如果在过滤器中也有可能不存在，这个时候在配合null值。<br>这个方案靠谱么，希望老师能解答一下","like_count":4,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489401,"discussion_content":"首先这是个经典的方案，靠谱是没问题的。它可以解决问题是，不用真正去查询数据集，就可以判断，请求的数据是不是，不在数据集内。如果不在就不用去查询数据集了。\n\n不少数据库都内置了布隆过滤器来提升查询效率，比如HBase。\n\n布隆过滤器的缺点就是有点复杂，实现难度还是挺大的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585533305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219520,"user_name":"任鹏斌","can_delete":false,"product_type":"c1","uid":1104086,"ip_address":"","ucode":"34319B05EA6E74","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/d6/47da34bf.jpg","comment_is_top":false,"comment_ctime":1590035391,"is_pvip":false,"replies":[{"id":"81472","content":"严格来说，在并发情况下，二种方式都有可能产生脏数据。Cache Aside Pattern建议，先操作数据库，再操作缓存。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1590370248,"ip_address":"","comment_id":219520,"utype":1}],"discussion_count":4,"race_medal":0,"score":"14474937279","product_id":100046801,"comment_content":"老师Cache Aside应该是先删缓存后更新数据库吧？先更新数据库的话一旦缓存删除失败了，就会产生脏数据","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495838,"discussion_content":"严格来说，在并发情况下，二种方式都有可能产生脏数据。Cache Aside Pattern建议，先操作数据库，再操作缓存。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590370248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1144579,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKpSMbVNXBjCubrNiccEMImicVuK47fjWgkl3NPIKB2n7nrLSPdFz66ZXro7rh06zZIbwE5UNZbwJkw/132","nickname":"知之善询","note":"","ucode":"DB0D1E5CAC40A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352527,"discussion_content":"好像有个文章里是说，更新前先删缓存，更新后再删一次缓存，避免这里提到的问题。不过想想，高并发的情况下，好像更新前删缓存，作用也不大。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614762839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1144579,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKpSMbVNXBjCubrNiccEMImicVuK47fjWgkl3NPIKB2n7nrLSPdFz66ZXro7rh06zZIbwE5UNZbwJkw/132","nickname":"知之善询","note":"","ucode":"DB0D1E5CAC40A7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366289,"discussion_content":"对，因为在高并发场景下仍然可能有读线程在第一次删除缓存，加载旧数据进缓存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618021872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":352527,"ip_address":""},"score":366289,"extra":""}]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534696,"discussion_content":"先删缓存 此时数据库还没更新 微观上读请求拿到旧数据是合理的。\n这就像缓存失效 读请求读出旧数据一样 总是合理的。但是这种在宏观上 业务上可能就不合理 这就要求在后续流程里对旧版本数据允许一段时间内的容错率","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638257971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":209873,"user_name":"握了个大蚂蚱","can_delete":false,"product_type":"c1","uid":1488356,"ip_address":"","ucode":"AD34AD4FA37371","user_header":"https://static001.geekbang.org/account/avatar/00/16/b5/e4/e6faf686.jpg","comment_is_top":false,"comment_ctime":1587630400,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14472532288","product_id":100046801,"comment_content":"总结：<br>1.为什么先更新mysql再更新（删除）redis比反过来好？<br><br>降低了脏数据出现的概率，前者产生脏数据是由于并发，后者几乎是必然，只要先写再读的请求发生，都会造成脏数据：先把redis中的缓存清了，然后读请求读不到去数据库中找到并更新在redis中。<br>2.为什么aside cache比read&#47;write through好？<br>也是降低了脏数据出现的概率。前者只有读写先后访问数据库，又调转顺序访问redis时redis中出现脏数据，这个概率很小，而并发写时相当于不操作redis；而后者在并发写的情况下也容易脏。","like_count":3},{"had_liked":false,"id":207801,"user_name":"王杰","can_delete":false,"product_type":"c1","uid":1944186,"ip_address":"","ucode":"53CC01032E4A25","user_header":"","comment_is_top":false,"comment_ctime":1587182664,"is_pvip":false,"replies":[{"id":"77840","content":"mvcc可以很好的解决读写冲突，但是对于写写冲突，要么加锁，要么引入冲突检测机制，否则就会导致写倾斜的问题。这个在23中有详细的说明。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1587351948,"ip_address":"","comment_id":207801,"utype":1}],"discussion_count":5,"race_medal":0,"score":"14472084552","product_id":100046801,"comment_content":"作者回复: 你可以参考一下“GaGi”同学的留言，用锁来解决并发问题。------------------------------------------------------老师，在读线程上写锁（说独占锁比较合适），是否跟MVCC相违背，MVCC不就是为了用来解决高并发带来的读写阻塞问题吗？我这边有两种解决思路不知可否：第一用版本控制，类似MVCC，第二种用Read&#47;Write Through，写写并发在MVCC模式下依然是阻塞的，不算违背，所以只要把更新数据库与更新缓存放入统一事务中就行。读写并发不阻塞，是因为mysql用了快照读原因，那我们可以继续写线程更新缓存，读线程采用redis的setnx方式解决覆盖","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492244,"discussion_content":"mvcc可以很好的解决读写冲突，但是对于写写冲突，要么加锁，要么引入冲突检测机制，否则就会导致写倾斜的问题。这个在23中有详细的说明。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587351948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534713,"discussion_content":"mvcc解决的是读写并发 以及本地因果一致性。但是对于写写并发mysql官方至今还没有一个推荐的方案。通常我们都是用乐观锁来做的。\n因为这会牵涉到两个线程之间锁互斥 或者写协调（写同步）。通常需要设计一个类似snoopy协议或是上一把大锁之类的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638260593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1944186,"avatar":"","nickname":"王杰","note":"","ucode":"53CC01032E4A25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":244571,"discussion_content":"是的，MVCC模式下，mysql的普通读是快照读，但是写是实时写（存在独占锁的说法），但是对于GaGi同学在读缓存没读到上写锁（for update）的做法不敢苟同啊，会有性能风险","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587613867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1944186,"avatar":"","nickname":"王杰","note":"","ucode":"53CC01032E4A25","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366294,"discussion_content":"我觉得读线程可以加读锁，lock in share mode\n但是读写锁的问题在于读线程多，写线程少，容易导致写线程饥饿\n因此读未命中，更新缓存\n写更新，更新数据库后，更新缓存\n尽量保证读从缓存，写到数据库，两者数据一致","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618022366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":244571,"ip_address":""},"score":366294,"extra":""},{"author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1944186,"avatar":"","nickname":"王杰","note":"","ucode":"53CC01032E4A25","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366298,"discussion_content":"你提到的redis的setnx也是互斥锁，只是由数据库的独占锁改为分布式的独占锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618022519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":244571,"ip_address":""},"score":366298,"extra":""}]}]},{"had_liked":false,"id":196107,"user_name":"image","can_delete":false,"product_type":"c1","uid":1039069,"ip_address":"","ucode":"A45BFF284F8933","user_header":"https://static001.geekbang.org/account/avatar/00/0f/da/dd/1e5e7b0c.jpg","comment_is_top":false,"comment_ctime":1585235906,"is_pvip":false,"replies":[{"id":"74412","content":"这种情况理论上也没有完美的解决方案，来说说实际上的一些处理经验。<br><br>首先，避免短时间大量人为的空值攻击，这个事儿应该在上层安全或者风控层面去解决。（即使无法判断是否空值攻击，至少要拦截住短时间大量的不正常访问请求）<br><br>剩余下来的就是业务上正常的查询返回空的情况，这种可能要从业务上来设计一下，尽量避免大量可能的空值查询。<br><br>以上2点做了之后，空值查询就会少多了，这个时候可以根据实际情况选择缓存空值，或者让空值穿透。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1585274710,"ip_address":"","comment_id":196107,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14470137794","product_id":100046801,"comment_content":"如果缓存时有大量命中为null如何处理？如果命中null 也进行缓存，会导致缓存增长太快，容易被攻击<br>如果不缓存，又容易引起大量穿透","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489226,"discussion_content":"这种情况理论上也没有完美的解决方案，来说说实际上的一些处理经验。\n\n首先，避免短时间大量人为的空值攻击，这个事儿应该在上层安全或者风控层面去解决。（即使无法判断是否空值攻击，至少要拦截住短时间大量的不正常访问请求）\n\n剩余下来的就是业务上正常的查询返回空的情况，这种可能要从业务上来设计一下，尽量避免大量可能的空值查询。\n\n以上2点做了之后，空值查询就会少多了，这个时候可以根据实际情况选择缓存空值，或者让空值穿透。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585274710,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248121,"user_name":"程堃","can_delete":false,"product_type":"c1","uid":1549808,"ip_address":"","ucode":"50D02D13CAD09A","user_header":"https://static001.geekbang.org/account/avatar/00/17/a5/f0/c4eba20f.jpg","comment_is_top":false,"comment_ctime":1600038229,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10189972821","product_id":100046801,"comment_content":"问题：读线程查到缓存为空后，读db数据并写入缓存，在写入之前另一个更新操作修改了db数据，会导致db与缓存数据不一致。<br>方案：将Cache Aside的删除操作改成设置缓存几秒后失效，或者加分布式锁","like_count":2},{"had_liked":false,"id":204279,"user_name":"夏目","can_delete":false,"product_type":"c1","uid":1212750,"ip_address":"","ucode":"67C075A01CF4D2","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/4e/d71092f4.jpg","comment_is_top":false,"comment_ctime":1586359152,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10176293744","product_id":100046801,"comment_content":"线程1读取缓存未命中，查询当前数据库数据<br>线程2更新当前数据库数据，删除缓存(不存在)<br>线程1讲老数据更新至缓存，导致当前数据库数据与缓存不一致","like_count":2},{"had_liked":false,"id":192496,"user_name":"陶金","can_delete":false,"product_type":"c1","uid":1647666,"ip_address":"","ucode":"14ECFE57ABC162","user_header":"https://static001.geekbang.org/account/avatar/00/19/24/32/c712d415.jpg","comment_is_top":false,"comment_ctime":1584855477,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10174790069","product_id":100046801,"comment_content":"package main<br><br>import (<br>\t&quot;fmt&quot;<br>\t&quot;sync&quot;<br>\t&quot;time&quot;<br>)<br><br>type BaseModel struct {<br>\tdata int<br>\tmu sync.RWMutex<br>}<br><br><br>var cache *BaseModel<br>var db *BaseModel<br>const FIRST_DATA = 1<br>const SECNOD_DATA = 2<br>const EMPTY_DATA = 0<br><br>func init() {<br>\tcache = new (BaseModel)<br>\tdb = new (BaseModel)<br>\tdb.setData(FIRST_DATA)<br>}<br><br><br>func main() {<br><br>\tgo read()<br>\tgo write(SECNOD_DATA)<br><br>\ttime.Sleep(3 * time.Second)<br>\tfmt.Println(&quot;db&#39;s data is %d, cache&#39;s data is %d&quot;, db.getData(), cache.getData())<br>}<br><br><br>func read() {<br>\tdata := cache.getData()<br>\tif data == 0 {<br>\t\tdata = db.getData()<br>\t\ttime.Sleep(2* time.Second)<br>\t\tcache.setData(data)<br>\t}<br>}<br><br><br>func write(data int) {<br>\ttime.Sleep(1*time.Second)<br>\tdb.setData(data)<br>\tcache.setData(EMPTY_DATA)<br>}<br><br><br>func (self *BaseModel) getData() int {<br>\tself.mu.RLock()<br>\tdefer self.mu.RUnlock()<br>\treturn self.data<br>}<br><br>func (self *BaseModel) setData(data int) {<br>\tself.mu.Lock()<br>\tdefer self.mu.Unlock()<br>\tself.data = data<br>}<br><br>大概场景如下：<br>1. 初始数据库中数据为“1”，缓存无数据<br>2. 线程A为读线程，读取缓存未果，然后读取数据库中的记录为“1”，这时候缓存阻塞住。<br>3. 线程B为写线程，先把数据库中的数据更新为“2”，再删除缓存，结束。<br>4. 此时线程A解除阻塞，然后把记录“1”更新到缓存中。<br><br>此时缓存中数据为“1”， 数据库中数据为“2”， 缓存落后于数据库中的数据。<br>","like_count":2},{"had_liked":false,"id":191173,"user_name":"R20114","can_delete":false,"product_type":"c1","uid":1046260,"ip_address":"","ucode":"883B7FD07443BC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f6/f4/95191165.jpg","comment_is_top":false,"comment_ctime":1584752562,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10174687154","product_id":100046801,"comment_content":"Cache Aside 模式在下面的场景下：<br>读写线程之间在执行 Cache Aside Pattern 操作的时候，写线程删除了缓存，读线程从 DB 读到老的数据，把老的数据放到了缓存中，这样就会在缓存中产生脏数据。","like_count":2,"discussions":[{"author":{"id":1016905,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","nickname":"观弈道人","note":"","ucode":"F3BB619A33C605","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":210800,"discussion_content":"先写dB 数据，再删缓存，缓存删除的时候，db数据已经落库，读线程读不到缓存的时候，再去读db,此时db已经是新数据，感觉不会有问题，虽然有还几个留言提出问题了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584776290,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1046260,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f6/f4/95191165.jpg","nickname":"R20114","note":"","ucode":"883B7FD07443BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1016905,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","nickname":"观弈道人","note":"","ucode":"F3BB619A33C605","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211280,"discussion_content":"在如下场景，这种情况很容易发生：\n1. DB 通过主从复制做读写分离，写操作在主库执行，读操作在从库执行，主从复制之间存在延时。\n2. 一个 Java 语言开发的服务集群，读操作发生在进程A, 写操作发生在进城B, t1时刻进程 A 读到旧的数据然后发生了 GC，t2 时刻进程 B 中写操作更新了 DB 并且删除了缓存，t3 时刻进程 A 中业务线程恢复更新了缓存。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584838057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":210800,"ip_address":""},"score":211280,"extra":""}]}]},{"had_liked":false,"id":255395,"user_name":"翠羽香凝","can_delete":false,"product_type":"c1","uid":1119933,"ip_address":"","ucode":"54F3762F0E545F","user_header":"https://static001.geekbang.org/account/avatar/00/11/16/bd/e14ba493.jpg","comment_is_top":false,"comment_ctime":1603335125,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5898302421","product_id":100046801,"comment_content":"有一个问题，一直没搞明白。如果使用redis作为mysql的前置，在写数据的时候，需要同时写Mysql和redis，如果更新mysql成功后，更新redis没成功，造成了两者之间的不一致，这种情况怎么办？","like_count":1},{"had_liked":false,"id":207795,"user_name":"王杰","can_delete":false,"product_type":"c1","uid":1944186,"ip_address":"","ucode":"53CC01032E4A25","user_header":"","comment_is_top":false,"comment_ctime":1587181627,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5882148923","product_id":100046801,"comment_content":"你好，使用 Cache Aside 模式更新缓存好像也会产生脏数据。就如文章里所说，当一个读线程没有从缓存中读到数据，进而去查数据库获取到数据，这时一个写线程更新了数据库并删除缓存，可能由于读线程放入旧数据到缓存时机比较晚写线程没法删到，导致缓存中可能不是最新的数据，后面再有线程过来查询自然也读不到新数据了","like_count":1},{"had_liked":false,"id":191148,"user_name":"Mq","can_delete":false,"product_type":"c1","uid":1178359,"ip_address":"","ucode":"041F572AFAB275","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/f7/91ac44c5.jpg","comment_is_top":false,"comment_ctime":1584750168,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5879717464","product_id":100046801,"comment_content":"老师好，写数据跟删缓存不是一致的，写完数据到删缓存这段时间内其他并发访问都是脏数据，这种思维方式感觉不解决一致性问题，都会有可能出现脏读，只是时间长短问题","like_count":1,"discussions":[{"author":{"id":1332557,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbY9UsqHZhhVoI69yXNibBBg0TRdUVsKLMg2UZ1R3NJxXdMicqceI5yhdKZ5Ad6CJYO0XpFHlJzIYQ/132","nickname":"饭团","note":"","ucode":"E24F240CC91BE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214994,"discussion_content":"加版本号靠谱","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585270897,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338264,"user_name":"过year的year","can_delete":false,"product_type":"c1","uid":1249899,"ip_address":"","ucode":"D02971800EEB57","user_header":"https://static001.geekbang.org/account/avatar/00/13/12/6b/c5ca7d9e.jpg","comment_is_top":false,"comment_ctime":1647398906,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1647398906","product_id":100046801,"comment_content":"有点说的不够准确，脏数据的概率不是和系统的并发量正相关，而是和单key(此处指单用户、单订单)的并发度，其实即使业务规模很大，脏数据的概率也未必大。","like_count":0},{"had_liked":false,"id":324913,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1638714432,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638714432","product_id":100046801,"comment_content":"思考题：<br>Cache Aside产生脏数据，个人肤浅理解也是有两种情况：<br>1、当两个线程同时更新数据时，一个因为网络原因更新失败，一个成功，而后，失败的那个再次重试更新，覆盖了更新成功的那个数据，也就是ABA的情况；<br>2、两个线程一个更新数据，一个读数据，前者在数据更新完成后，在还未删除缓存的情况下，第二个线程恰好读到了缓存，这时第二个线程就是脏数据。","like_count":0},{"had_liked":false,"id":324020,"user_name":"凯文小猪","can_delete":false,"product_type":"c1","uid":1980201,"ip_address":"","ucode":"36D8AD0229547F","user_header":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","comment_is_top":false,"comment_ctime":1638260665,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638260665","product_id":100046801,"comment_content":"首先回答下老师的问题：<br>理论上总是存在这种情况。比方说 缓存失效发生在写库与失效缓存之间 那么此时读请求读出来的数据就是旧的。但是这种场景通常概率极低，因为读总是快于写 所以工程上不多见。再来说下如何解决，两种方法：<br>1. 不解决 。通常也是这么做 即接受这种问题<br>2. 使用容错窗口。原理类似老师上节课提出的 spu改动价格，允许一段时间内旧价格下单成功<br><br>下面再来说说为什么write through &#47; read through 不适合这种场景<br>本质上是由于两个并发写（读请求与写请求）会存在彼此脏写覆盖 因为最终写入其实没有锁或同步机制来做协调。<br>这个问题在《Why does Facebook use delete to remove the key-value pair in Memcached instead of updating the Memcached during write request to the backend?》有讨论过","like_count":0},{"had_liked":false,"id":322310,"user_name":"董俊俊","can_delete":false,"product_type":"c1","uid":1297887,"ip_address":"","ucode":"732300A779660B","user_header":"https://static001.geekbang.org/account/avatar/00/13/cd/df/c520d418.jpg","comment_is_top":false,"comment_ctime":1637299718,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637299718","product_id":100046801,"comment_content":"用分布式锁更新缓存啊，大量的请求过年，只允许一个请求请求数据库并更新缓存","like_count":0},{"had_liked":false,"id":317408,"user_name":"张凯","can_delete":false,"product_type":"c1","uid":1136254,"ip_address":"","ucode":"27566AD22CCAA1","user_header":"https://static001.geekbang.org/account/avatar/00/11/56/7e/64730c47.jpg","comment_is_top":false,"comment_ctime":1634787687,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634787687","product_id":100046801,"comment_content":"文中一直在说缓存穿透，其实文中举例缓存失效，数据库中数据存在的这种情景，应该为缓存击穿。","like_count":0},{"had_liked":false,"id":307570,"user_name":"注意力$","can_delete":false,"product_type":"c1","uid":1142316,"ip_address":"","ucode":"7FB3399A1EAB72","user_header":"https://static001.geekbang.org/account/avatar/00/11/6e/2c/e2f3cfc0.jpg","comment_is_top":false,"comment_ctime":1629163926,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629163926","product_id":100046801,"comment_content":"老师，传统行业前台业务比较更新频繁的数据，这个能做缓存吗？还是也能实现，业务SQL写的慢，导致很多压力都在数据库上。","like_count":0},{"had_liked":false,"id":274928,"user_name":"Geek6561","can_delete":false,"product_type":"c1","uid":2028940,"ip_address":"","ucode":"D44141D4AD2587","user_header":"","comment_is_top":false,"comment_ctime":1611219515,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611219515","product_id":100046801,"comment_content":"Cache Aside遇到主从就难了","like_count":0},{"had_liked":false,"id":260126,"user_name":"anthony","can_delete":false,"product_type":"c1","uid":1032896,"ip_address":"","ucode":"BA716F89900570","user_header":"","comment_is_top":false,"comment_ctime":1604928116,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604928116","product_id":100046801,"comment_content":"老师好  单个mysql的并发 你那边有它的并发数据吗","like_count":0},{"had_liked":false,"id":250576,"user_name":"PhilZhang","can_delete":false,"product_type":"c1","uid":1088010,"ip_address":"","ucode":"383F1A792C7DF9","user_header":"https://static001.geekbang.org/account/avatar/00/10/9a/0a/922615cf.jpg","comment_is_top":false,"comment_ctime":1601135851,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601135851","product_id":100046801,"comment_content":"两种缓存更新模式产生脏数据的场景是一样的，都是写线程对缓存的失效或更新操作，发生在读线程之前，被读线程的旧数据覆盖，从而产生脏数据。<br><br>想到一个在Read&#47;Write Through模式下比较简单的实现方式，就是读线程更新缓存的时候不用put，而是用putIfAbsent，意思就是读线程在更新数据的时候，如果发现这个key对应的缓存已经存在，就放弃更新，因为刚刚查的时候没有，现在又有了，肯定是其他读线程或者写线程更新进来的，肯定比我本身的值相同或更新。","like_count":0},{"had_liked":false,"id":247358,"user_name":"无道win","can_delete":false,"product_type":"c1","uid":1461075,"ip_address":"","ucode":"0C026BB03A53EA","user_header":"https://static001.geekbang.org/account/avatar/00/16/4b/53/f797f031.jpg","comment_is_top":false,"comment_ctime":1599668040,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1599668040","product_id":100046801,"comment_content":"一旦发生了如下场景：<br>a线程读取缓存，缓存没有值＞a线程读取了db＞b线程更新db＞b线程删除缓存＞a线程使用旧值更新缓存。<br>这样就会发生数据不一致的现象。<br><br>其实换个角度来看，cache aside模式造成数据不一致的情况出现在a读取db＋写入缓存这个操作不是原子性的操作，如果我们能够保证这两个操作的原子性就完全可以避免这种情况了。<br><br>具体的解决方案可以像Gagi同学那样采用加锁的方式来解决。<br>","like_count":0},{"had_liked":false,"id":226345,"user_name":"开落在","can_delete":false,"product_type":"c1","uid":1108480,"ip_address":"","ucode":"8A5A6BA483DFB0","user_header":"https://static001.geekbang.org/account/avatar/00/10/ea/00/e97fe767.jpg","comment_is_top":false,"comment_ctime":1592042428,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1592042428","product_id":100046801,"comment_content":"update数据库之后sleep一段时间再去删除cache","like_count":0,"discussions":[{"author":{"id":1019568,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8e/b0/ef201991.jpg","nickname":"CcczzZ","note":"","ucode":"5F46DA5053D2BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292940,"discussion_content":"睡眠大法😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595389660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206415,"user_name":"闫冬","can_delete":false,"product_type":"c1","uid":1109691,"ip_address":"","ucode":"1725E869D5A3D3","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/bb/7afd6824.jpg","comment_is_top":false,"comment_ctime":1586857587,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586857587","product_id":100046801,"comment_content":"缓存策略<br>1.read write through 可能回造成脏数据<br>2.catch aset 清缓存 加预热缓存方式比较好些<br>3.redis 作为mysql的前置缓存","like_count":0},{"had_liked":false,"id":193714,"user_name":"AAAAAAres","can_delete":false,"product_type":"c1","uid":1243939,"ip_address":"","ucode":"B12540906635C7","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/23/e5c346e7.jpg","comment_is_top":false,"comment_ctime":1584952596,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584952596","product_id":100046801,"comment_content":"如果读缓存不存在，然后去从库读数据来写缓存的话，主从延迟也会导致缓存中有脏数据","like_count":0},{"had_liked":false,"id":193568,"user_name":"1","can_delete":false,"product_type":"c1","uid":1895904,"ip_address":"","ucode":"44133D009755C7","user_header":"https://static001.geekbang.org/account/avatar/00/1c/ed/e0/c63d6a80.jpg","comment_is_top":false,"comment_ctime":1584928396,"is_pvip":false,"replies":[{"id":"73921","content":"这个还是得看业务，很多列表也可以缓存的，比如说一些排行榜数据。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1585025238,"ip_address":"","comment_id":193568,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1584928396","product_id":100046801,"comment_content":"是不是model的话使用缓存，列表的话是不是不适合用缓存？列表应该怎么去缓存？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488589,"discussion_content":"这个还是得看业务，很多列表也可以缓存的，比如说一些排行榜数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585025238,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":192584,"user_name":"刘楠","can_delete":false,"product_type":"c1","uid":1120773,"ip_address":"","ucode":"9F19D44CBEE039","user_header":"https://static001.geekbang.org/account/avatar/00/11/1a/05/f154d134.jpg","comment_is_top":false,"comment_ctime":1584861702,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584861702","product_id":100046801,"comment_content":"一直用的Cache Aside,","like_count":0},{"had_liked":false,"id":191944,"user_name":"Aliliin","can_delete":false,"product_type":"c1","uid":1025239,"ip_address":"","ucode":"61F9A09BB6650F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/d7/5d2bfaa7.jpg","comment_is_top":false,"comment_ctime":1584804989,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584804989","product_id":100046801,"comment_content":"a读到老数据的同时并没来得及写入缓存，然后b正好更新了db清空缓存，a写入之前读到的数据写入缓存。<br>只想到这种情况，不知道靠谱吗。","like_count":0},{"had_liked":false,"id":191520,"user_name":"正在减肥的胖籽。","can_delete":false,"product_type":"c1","uid":1033728,"ip_address":"","ucode":"99E2E4DF599236","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c6/00/683bb4f0.jpg","comment_is_top":false,"comment_ctime":1584778686,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1584778686","product_id":100046801,"comment_content":"任何一种方式缓存使用方式和数据库之间都会有脏数据的产生，我现在的解决方案就是看业务方能接受多长时间的脏数据，然后缓存就设置多久的过期时间。2.或者数据库更新成功后，用MQ去通知刷新缓存。","like_count":0,"discussions":[{"author":{"id":1433535,"avatar":"https://static001.geekbang.org/account/avatar/00/15/df/bf/96b50d1e.jpg","nickname":"😚 46","note":"","ucode":"EED0EBBBF80A43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265710,"discussion_content":"binlog相比MQ应该是更优的选择吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589429324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191373,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1584767621,"is_pvip":false,"replies":[{"id":"73514","content":"你可以参考一下“GaGi”同学的留言，用锁来解决并发问题。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1584846220,"ip_address":"","comment_id":191373,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1584767621","product_id":100046801,"comment_content":"Cache Aside解决的只是并发写请求导致的缓存数据不一致问题。对于读写这种场景并没有彻底解决。<br>A：读，缓存穿透，查库。<br>B：写，更新数据库。<br>B：写，删除缓存。<br>A：读，回写缓存。导致不一致。<br>目前针对这种问题我们这边才去的方案是写请求后用MQ延迟删除缓存。老师有什么好的方法和实践吗？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488162,"discussion_content":"你可以参考一下“GaGi”同学的留言，用锁来解决并发问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584846220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1944186,"avatar":"","nickname":"王杰","note":"","ucode":"53CC01032E4A25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":237757,"discussion_content":"老师，在读线程上写锁（说独占锁比较合适），是否跟MVCC相违背，MVCC不就是为了用来解决高并发带来的读写阻塞问题吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587182047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191263,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1584759392,"is_pvip":false,"replies":[{"id":"73512","content":"使用Redis命令INCR是可以保存原子性的。<br><br>如果是GET出来，在程序内加一，在SET回去，确实会存在并发问题。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1584845767,"ip_address":"","comment_id":191263,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1584759392","product_id":100046801,"comment_content":"老师有个问题请教你，我这边有个业务，合同编号，存在redis 🀄️和数据库中，每次先查redis 获取合同编号后面虚寒，然好加1⃣️，保存回去，外去更新数据库，做了数据库合同编号重复，检验，但是每次还是有合通编号重复的，请问这个怎么解决？市并发导致？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488143,"discussion_content":"使用Redis命令INCR是可以保存原子性的。\n\n如果是GET出来，在程序内加一，在SET回去，确实会存在并发问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584845767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1435733,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","nickname":"MClink","note":"","ucode":"F479190923355C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285085,"discussion_content":"兄弟打字可以认真一点吗\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592734851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1484192,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/a0/e0cccf7e.jpg","nickname":"圆圆满满","note":"","ucode":"396E7A822014D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215248,"discussion_content":"并发情况下会有问题。做个发号服务，保证唯一性即可。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585307439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191246,"user_name":"肥low","can_delete":false,"product_type":"c1","uid":1043480,"ip_address":"","ucode":"A158AFAAB8C742","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/18/bf7254d3.jpg","comment_is_top":false,"comment_ctime":1584757818,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1584757818","product_id":100046801,"comment_content":"我觉得Cache Aside还是没有解决主从延迟带来的问题😱","like_count":0,"discussions":[{"author":{"id":1488356,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b5/e4/e6faf686.jpg","nickname":"握了个大蚂蚱","note":"","ucode":"AD34AD4FA37371","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":244788,"discussion_content":"主从延迟？redis一般不做读写分离","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587630459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1488356,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b5/e4/e6faf686.jpg","nickname":"握了个大蚂蚱","note":"","ucode":"AD34AD4FA37371","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366218,"discussion_content":"redis主从架构不就是读写分离嘛？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617982334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":244788,"ip_address":""},"score":366218,"extra":""},{"author":{"id":1488356,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b5/e4/e6faf686.jpg","nickname":"握了个大蚂蚱","note":"","ucode":"AD34AD4FA37371","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369840,"discussion_content":"从节点只是备份作用，用于主节点宕机时切换。redis的并发一般来说足够，并且考虑到作为缓存写的频率也十分高，读写隔离意义有限，而且不支持写到从节点再返回的这种分布式存储特性配置，所以读写分离带来的麻烦比好处多多了，基本不用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619171137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":366218,"ip_address":""},"score":369840,"extra":""}]}]},{"had_liked":false,"id":191195,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1584753757,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584753757","product_id":100046801,"comment_content":"只有一个体会: 清楚各种缓存策略的缺陷，想用缓存只能是结合当前业务来是否用，用什么策略","like_count":0}]}