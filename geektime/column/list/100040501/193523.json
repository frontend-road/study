{"id":193523,"title":"27 | C++ REST SDK：使用现代C++开发网络应用","content":"<p>你好，我是吴咏炜。</p><p>在实战篇，我们最后要讲解的一个库是 C++ REST SDK（也写作 cpprestsdk）<span class=\"orange\">[1]</span>，一个支持 HTTP 协议 <span class=\"orange\">[2]</span>、主要用于 RESTful <span class=\"orange\">[3]</span> 接口开发的 C++ 库。</p><h2>初识 C++ REST SDK</h2><p>向你提一个问题，你认为用多少行代码可以写出一个类似于 curl <span class=\"orange\">[4]</span> 的 HTTP 客户端？</p><p>使用 C++ REST SDK 的话，答案是，只需要五十多行有效代码（即使是适配到我们目前的窄小的手机屏幕上）。请看：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#ifdef _WIN32\n#include &lt;fcntl.h&gt;\n#include &lt;io.h&gt;\n#endif\n#include &lt;cpprest/http_client.h&gt;\n\nusing namespace utility;\nusing namespace web::http;\nusing namespace web::http::client;\nusing std::cerr;\nusing std::endl;\n\n#ifdef _WIN32\n#define tcout std::wcout\n#else\n#define tcout std::cout\n#endif\n\nauto get_headers(http_response resp)\n{\n  auto headers = resp.to_string();\n  auto end =\n    headers.find(U(\"\\r\\n\\r\\n\"));\n  if (end != string_t::npos) {\n    headers.resize(end + 4);\n  };\n  return headers;\n}\n\nauto get_request(string_t uri)\n{\n  http_client client{uri};\n  // 用 GET 方式发起一个客户端请求\n  auto request =\n    client.request(methods::GET)\n      .then([](http_response resp) {\n        if (resp.status_code() !=\n            status_codes::OK) {\n          // 不 OK，显示当前响应信息\n          auto headers =\n            get_headers(resp);\n          tcout &lt;&lt; headers;\n        }\n        // 进一步取出完整响应\n        return resp\n          .extract_string();\n      })\n      .then([](string_t str) {\n        // 输出到终端\n        tcout &lt;&lt; str;\n      });\n  return request;\n}\n\n#ifdef _WIN32\nint wmain(int argc, wchar_t* argv[])\n#else\nint main(int argc, char* argv[])\n#endif\n{\n#ifdef _WIN32\n  _setmode(_fileno(stdout),\n           _O_WTEXT);\n#endif\n\n  if (argc != 2) {\n    cerr &lt;&lt; \"A URL is needed\\n\";\n    return 1;\n  }\n\n  // 等待请求及其关联处理全部完成\n  try {\n    auto request =\n      get_request(argv[1]);\n    request.wait();\n  }\n  // 处理请求过程中产生的异常\n  catch (const std::exception&amp; e) {\n    cerr &lt;&lt; \"Error exception: \"\n         &lt;&lt; e.what() &lt;&lt; endl;\n    return 1;\n  }\n}\n</code></pre><!-- [[[read_end]]] --><p>这个代码有点复杂，需要讲解一下：</p><ul>\n<li>第 14–18 行，我们根据平台来定义 <code>tcout</code>，确保多语言的文字能够正确输出。</li>\n<li>第 20–29 行，我们定义了 <code>get_headers</code>，来从 <code>http_response</code> 中取出头部的字符串表示。</li>\n<li>第 36 行，构造了一个客户端请求，并使用 <code>then</code> 方法串联了两个下一步的动作。<code>http_client::request</code> 的返回值是 <code>pplx::task&lt;http_response&gt;</code>。<code>then</code> 是 <code>pplx::task</code> 类模板的成员函数，参数是能接受其类型参数对象的函数对象。除了最后一个 <code>then</code> 块，其他每个 <code>then</code> 里都应该返回一个  <code>pplx::task</code>，而 <code>task</code> 的内部类型就是下一个 <code>then</code> 块里函数对象接受的参数的类型。</li>\n<li>第 37 行开始，是第一段异步处理代码。参数类型是 <code>http_response</code>——因为<code>http_client::request</code> 的返回值是 <code>pplx::task&lt;http_response&gt;</code>。代码中判断如果响应的 HTTP 状态码不是 200 OK，就会显示响应头来帮助调试。然后，进一步取出所有的响应内容（可能需要进一步的异步处理，等待后续的 HTTP 响应到达）。</li>\n<li>第 49 行开始，是第二段异步处理代码。参数类型是 <code>string_t</code>——因为上一段 <code>then</code> 块的返回值是 <code>pplx::task&lt;string_t&gt;</code>。代码中就是简单地把需要输出的内容输出到终端。</li>\n<li>第 56–60 行，我们根据平台来定义合适的程序入口，确保命令行参数的正确处理。</li>\n<li>第 62–65 行，在 Windows 上我们把标准输出设置成宽字符模式，来确保宽字符（串）能正确输出（参考<a href=\"https://time.geekbang.org/column/article/179357\">[第 11 讲]</a> ）。注意 <code>string_t</code> 在 Windows 上是 <code>wstring</code>，在其他平台上是 <code>string</code>。</li>\n<li>第 72–83 行，如注释所言，产生 HTTP 请求、等待 HTTP 请求完成，并处理相关的异常。</li>\n</ul><p>整体而言，这个代码还是很简单的，虽然这种代码风格，对于之前没有接触过这种函数式编程风格的人来讲会有点奇怪——这被称作持续传递风格（continuation-passing style），显式地把上一段处理的结果传递到下一个函数中。这个代码已经处理了 Windows 环境和 Unix 环境的差异，底下是相当复杂的。</p><p>另外提醒一下，在 Windows 上如果你把源代码存成 UTF-8 的话，需要确保文件以 BOM 字符打头。Windows 的编辑器通常缺省就会做到；在 Vim 里，可以通过 <code>set bomb</code> 命令做到这一点。</p><h2>安装和编译</h2><p>上面的代码本身虽然简单，但要把它编译成可执行文件比我们之前讲的代码都要复杂——C++ REST SDK 有外部依赖，在 Windows 上和 Unix 上还不太一样。它的编译和安装也略复杂，如果你没有这方面的经验的话，建议尽量使用平台推荐的二进制包的安装方式。</p><p>由于其依赖较多，使用它的编译命令行也较为复杂。正式项目中绝对是需要使用项目管理软件的（如 cmake）。此处，我给出手工编译的典型命令行，仅供你尝试编译上面的例子作参考。</p><p>Windows MSVC：</p><blockquote>\n<p><code>cl /EHsc /std:c++17 test.cpp cpprest.lib zlib.lib libeay32.lib ssleay32.lib winhttp.lib httpapi.lib bcrypt.lib crypt32.lib advapi32.lib gdi32.lib user32.lib</code></p>\n</blockquote><p>Linux GCC：</p><blockquote>\n<p><code>g++ -std=c++17 -pthread test.cpp -lcpprest -lcrypto -lssl -lboost_thread -lboost_chrono -lboost_system</code></p>\n</blockquote><p>macOS Clang：</p><blockquote>\n<p><code>clang++ -std=c++17 test.cpp -lcpprest -lcrypto -lssl -lboost_thread-mt -lboost_chrono-mt</code></p>\n</blockquote><h2>概述</h2><p>有了初步印象之后，现在我们可以回过头看看 C++ REST SDK 到底是什么了。它是一套用来开发 HTTP 客户端和服务器的现代异步 C++ 代码库，支持以下特性（随平台不同会有所区别）：</p><ul>\n<li>HTTP 客户端</li>\n<li>HTTP 服务器</li>\n<li>任务</li>\n<li>JSON</li>\n<li>URI</li>\n<li>异步流</li>\n<li>WebSocket 客户端</li>\n<li>OAuth 客户端</li>\n</ul><p>上面的例子里用到了 HTTP 客户端、任务和 URI（实际上是由 <code>string_t</code> 隐式构造了 <code>uri</code>），我们下面再介绍一下异步流、JSON 和 HTTP 服务器。</p><h2>异步流</h2><p>C++ REST SDK 里实现了一套异步流，能够实现对文件的异步读写。下面的例子展示了我们如何把网络请求的响应异步地存储到文件 results.html 中：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;utility&gt;\n#ifdef _WIN32\n#include &lt;fcntl.h&gt;\n#include &lt;io.h&gt;\n#endif\n#include &lt;stddef.h&gt;\n#include &lt;cpprest/http_client.h&gt;\n#include &lt;cpprest/filestream.h&gt;\n\nusing namespace utility;\nusing namespace web::http;\nusing namespace web::http::client;\nusing namespace concurrency::streams;\nusing std::cerr;\nusing std::endl;\n\n#ifdef _WIN32\n#define tcout std::wcout\n#else\n#define tcout std::cout\n#endif\n\nauto get_headers(http_response resp)\n{\n  auto headers = resp.to_string();\n  auto end =\n    headers.find(U(\"\\r\\n\\r\\n\"));\n  if (end != string_t::npos) {\n    headers.resize(end + 4);\n  };\n  return headers;\n}\n\nauto get_request(string_t uri)\n{\n  http_client client{uri};\n  // 用 GET 方式发起一个客户端请求\n  auto request =\n    client.request(methods::GET)\n      .then([](http_response resp) {\n        if (resp.status_code() ==\n            status_codes::OK) {\n          // 正常的话\n          tcout &lt;&lt; U(\"Saving...\\n\");\n          ostream fs;\n          fstream::open_ostream(\n            U(\"results.html\"),\n            std::ios_base::out |\n              std::ios_base::trunc)\n            .then(\n              [&amp;fs,\n               resp](ostream os) {\n                fs = os;\n                // 读取网页内容到流\n                return resp.body()\n                  .read_to_end(\n                    fs.streambuf());\n              })\n            .then(\n              [&amp;fs](size_t size) {\n                // 然后关闭流\n                fs.close();\n                tcout\n                  &lt;&lt; size\n                  &lt;&lt; U(\" bytes \"\n                       \"saved\\n\");\n              })\n            .wait();\n        } else {\n          // 否则显示当前响应信息\n          auto headers =\n            get_headers(resp);\n          tcout &lt;&lt; headers;\n          tcout\n            &lt;&lt; resp.extract_string()\n                 .get();\n        }\n      });\n  return request;\n}\n\n#ifdef _WIN32\nint wmain(int argc, wchar_t* argv[])\n#else\nint main(int argc, char* argv[])\n#endif\n{\n#ifdef _WIN32\n  _setmode(_fileno(stdout),\n           _O_WTEXT);\n#endif\n\n  if (argc != 2) {\n    cerr &lt;&lt; \"A URL is needed\\n\";\n    return 1;\n  }\n\n  // 等待请求及其关联处理全部完成\n  try {\n    auto request =\n      get_request(argv[1]);\n    request.wait();\n  }\n  // 处理请求过程中产生的异常\n  catch (const std::exception&amp; e) {\n    cerr &lt;&lt; \"Error exception: \"\n         &lt;&lt; e.what() &lt;&lt; endl;\n  }\n}\n</code></pre><p>跟上一个例子比，我们去掉了原先的第二段处理统一输出的异步处理代码，但加入了一段嵌套的异步代码。有几个地方需要注意一下：</p><ul>\n<li>C++ REST SDK 的对象基本都是基于 <code>shared_ptr</code> 用引用计数实现的，因而可以轻松大胆地进行复制。</li>\n<li>虽然 <code>string_t</code> 在 Windows 上是 <code>wstring</code>，但文件流无论在哪个平台上都是以 UTF-8 的方式写入，符合目前的主流处理方式（<code>wofstream</code> 的行为跟平台和环境相关）。</li>\n<li><code>extract_string</code> 的结果这次没有传递到下一段，而是直接用 <code>get</code> 获得了最终结果（类似于<a href=\"https://time.geekbang.org/column/article/186689\">[第 19 讲]</a> 中的 <code>future</code>）。</li>\n</ul><p>这个例子的代码是基于 <a href=\"https://github.com/Microsoft/cpprestsdk/wiki/Getting-Started-Tutorial\">cpprestsdk 官方的例子</a>改编的。但我做的下面这些更动值得提一下：</p><ul>\n<li>去除了不必要的 <code>shared_ptr</code> 的使用。</li>\n<li><code>fstream::open_ostream</code> 缺省的文件打开方式是 <code>std::ios_base::out</code>，官方例子没有用 <code>std::ios_base::trunc</code>，导致不能清除文件中的原有内容。此处 C++ REST SDK 的 <code>file_stream</code> 行为跟标准 C++ 的 <code>ofstream</code> 是不一样的：后者缺省打开方式也是 <code>std::ios_base::out</code>，但此时文件内容<strong>会</strong>被自动清除。</li>\n<li>沿用我的前一个例子，先进行请求再打开文件流，而不是先打开文件流再发送网络请求，符合实际流程。</li>\n<li>这样做的一个结果就是 <code>then</code> 不完全是顺序的了，有嵌套，增加了复杂度，但展示了实际可能的情况。</li>\n</ul><h2>JSON 支持</h2><p>在基于网页的开发中，JSON <span class=\"orange\">[5]</span> 早已取代 XML 成了最主流的数据交换方式。REST 接口本身就是基于 JSON 的，自然，C++ REST SDK 需要对 JSON 有很好的支持。</p><p>JSON 本身可以在网上找到很多介绍的文章，我这儿就不多讲了。有几个 C++ 相关的关键点需要提一下：</p><ul>\n<li>JSON 的基本类型是空值类型、布尔类型、数字类型和字符串类型。其中空值类型和数字类型在 C++ 里是没有直接对应物的。数字类型在 C++ 里可能映射到 <code>double</code>，也可能是 <code>int32_t</code> 或 <code>int64_t</code>。</li>\n<li>JSON 的复合类型是数组（array）和对象（object）。JSON 数组像 C++ 的 <code>vector</code>，但每个成员的类型可以是任意 JSON 类型，而不像 <code>vector</code> 通常是同质的——所有成员属于同一类型。JSON 对象像 C++ 的 <code>map</code>，键类型为 JSON 字符串，值类型则为任意 JSON 类型。JSON 标准不要求对象的各项之间有顺序，不过，从实际项目的角度，我个人觉得保持顺序还是非常有用的。</li>\n</ul><p>如果你去搜索“c++ json”的话，还是可以找到一些不同的 JSON 实现的。功能最完整、名声最响的目前似乎是 nlohmann/json <span class=\"orange\">[6]</span>，而腾讯释出的 RapidJSON <span class=\"orange\">[7]</span> 则以性能闻名 <span class=\"orange\">[8]</span>。需要注意一下各个实现之间的区别：</p><ul>\n<li>nlohmann/json 不支持对 JSON 的对象（object）保持赋值顺序；RapidJSON 保持赋值顺序；C++ REST SDK 可选保持赋值顺序（通过 <code>web::json::keep_object_element_order</code> 和 <code>web::json::value::object</code> 的参数）。</li>\n<li>nlohmann/json 支持最友好的初始化语法，可以使用初始化列表和 JSON 字面量；C++ REST SDK 只能逐项初始化，并且一般应显式调用 <code>web::json::value</code> 的构造函数（接受布尔类型和字符串类型的构造函数有 <code>explicit</code> 标注）；RapidJSON 介于中间，不支持初始化列表和字面量，但赋值可以直接进行。</li>\n<li>nlohmann/json 和 C++ REST SDK 支持直接在用方括号 <code>[]</code> 访问不存在的 JSON 数组（array）成员时改变数组的大小；RapidJSON 的接口不支持这种用法，要向 JSON 数组里添加成员要麻烦得多。</li>\n<li>作为性能的代价，RapidJSON 里在初始化字符串值时，只会传递指针值；用户需要保证字符串在 JSON 值使用过程中的有效性。要复制字符串的话，接口要麻烦得多。</li>\n<li>RapidJSON 的 JSON 对象没有 <code>begin</code> 和 <code>end</code> 方法，因而无法使用标准的基于范围的 for 循环。总体而言，RapidJSON 的接口显得最特别、不通用。</li>\n</ul><p>如果你使用 C++ REST SDK 的其他功能，你当然也没有什么选择；否则，你可以考虑一下其他的 JSON 实现。下面，我们就只讨论 C++ REST SDK 里的 JSON 了。</p><p>在 C++ REST SDK 里，核心的类型是 <code>web::json::value</code>，这就对应到我前面说的“任意 JSON 类型”了。还是拿例子说话（改编自 RapidJSON 的例子）：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;utility&gt;\n#include &lt;assert.h&gt;\n#ifdef _WIN32\n#include &lt;fcntl.h&gt;\n#include &lt;io.h&gt;\n#endif\n#include &lt;cpprest/json.h&gt;\n\nusing namespace std;\nusing namespace utility;\nusing namespace web;\n\n#ifdef _WIN32\n#define tcout std::wcout\n#else\n#define tcout std::cout\n#endif\n\nint main()\n{\n#ifdef _WIN32\n  _setmode(_fileno(stdout),\n           _O_WTEXT);\n#endif\n\n  // 测试的 JSON 字符串\n  string_t json_str = U(R\"(\n    {\n      \"s\": \"你好，世界\",\n      \"t\": true,\n      \"f\": false,\n      \"n\": null,\n      \"i\": 123,\n      \"d\": 3.1416,\n      \"a\": [1, 2, 3]\n    })\");\n  tcout &lt;&lt; \"Original JSON:\"\n        &lt;&lt; json_str &lt;&lt; endl;\n\n  // 保持元素顺序并分析 JSON 字符串\n  json::keep_object_element_order(\n    true);\n  auto document =\n    json::value::parse(json_str);\n\n  // 遍历对象成员并输出类型\n  static const char* type_names[] =\n    {\n      \"Number\", \"Boolean\", \"String\",\n      \"Object\", \"Array\",   \"Null\",\n    };\n  for (auto&amp;&amp; value :\n       document.as_object()) {\n    tcout &lt;&lt; \"Type of member \"\n          &lt;&lt; value.first &lt;&lt; \" is \"\n          &lt;&lt; type_names[value.second\n                          .type()]\n          &lt;&lt; endl;\n  }\n\n  // 检查 document 是对象\n  assert(document.is_object());\n\n  // 检查 document[\"s\"] 是字符串\n  assert(document.has_field(U(\"s\")));\n  assert(\n    document[U(\"s\")].is_string());\n  tcout &lt;&lt; \"s = \"\n        &lt;&lt; document[U(\"s\")] &lt;&lt; endl;\n\n  // 检查 document[\"t\"] 是字符串\n  assert(\n    document[U(\"t\")].is_boolean());\n  tcout\n    &lt;&lt; \"t = \"\n    &lt;&lt; (document[U(\"t\")].as_bool()\n          ? \"true\"\n          : \"false\")\n    &lt;&lt; endl;\n\n  // 检查 document[\"f\"] 是字符串\n  assert(\n    document[U(\"f\")].is_boolean());\n  tcout\n    &lt;&lt; \"f = \"\n    &lt;&lt; (document[U(\"f\")].as_bool()\n          ? \"true\"\n          : \"false\")\n    &lt;&lt; endl;\n\n  // 检查 document[\"f\"] 是空值\n  tcout\n    &lt;&lt; \"n = \"\n    &lt;&lt; (document[U(\"n\")].is_null()\n          ? \"null\"\n          : \"?\")\n    &lt;&lt; endl;\n\n  // 检查 document[\"i\"] 是整数\n  assert(\n    document[U(\"i\")].is_number());\n  assert(\n    document[U(\"i\")].is_integer());\n  tcout &lt;&lt; \"i = \"\n        &lt;&lt; document[U(\"i\")] &lt;&lt; endl;\n\n  // 检查 document[\"d\"] 是浮点数\n  assert(\n    document[U(\"d\")].is_number());\n  assert(\n    document[U(\"d\")].is_double());\n  tcout &lt;&lt; \"d = \"\n        &lt;&lt; document[U(\"d\")] &lt;&lt; endl;\n\n  {\n    // 检查 document[\"a\"] 是数组\n    auto&amp; a = document[U(\"a\")];\n    assert(a.is_array());\n\n    // 测试读取数组元素并转换成整数\n    int y = a[0].as_integer();\n    (void)y;\n\n    // 遍历数组成员并输出\n    tcout &lt;&lt; \"a = \";\n    for (auto&amp;&amp; value :\n         a.as_array()) {\n      tcout &lt;&lt; value &lt;&lt; ' ';\n    }\n    tcout &lt;&lt; endl;\n  }\n\n  // 修改 document[\"i\"] 为长整数\n  {\n    uint64_t bignum = 65000;\n    bignum *= bignum;\n    bignum *= bignum;\n    document[U(\"i\")] = bignum;\n\n    assert(!document[U(\"i\")]\n              .as_number()\n              .is_int32());\n    assert(document[U(\"i\")]\n             .as_number()\n             .to_uint64() ==\n           bignum);\n    tcout &lt;&lt; \"i is changed to \"\n          &lt;&lt; document[U(\"i\")]\n          &lt;&lt; endl;\n  }\n\n  // 在数组里添加数值\n  {\n    auto&amp; a = document[U(\"a\")];\n    a[3] = 4;\n    a[4] = 5;\n    tcout &lt;&lt; \"a is changed to \"\n          &lt;&lt; document[U(\"a\")]\n          &lt;&lt; endl;\n  }\n\n  // 在 JSON 文档里添加布尔值：等号\n  // 右侧 json::value 不能省\n  document[U(\"b\")] =\n    json::value(true);\n\n  // 构造新对象，保持多个值的顺序\n  auto temp =\n    json::value::object(true);\n  // 在新对象里添加字符串：等号右侧\n  // json::value 不能省\n  temp[U(\"from\")] =\n    json::value(U(\"rapidjson\"));\n  temp[U(\"changed for\")] =\n    json::value(U(\"geekbang\"));\n\n  // 把对象赋到文档里；json::value\n  // 内部使用 unique_ptr，因而使用\n  // move 可以减少拷贝\n  document[U(\"adapted\")] =\n    std::move(temp);\n\n  // 完整输出目前的 JSON 对象\n  tcout &lt;&lt; document &lt;&lt; endl;\n}\n</code></pre><p>例子里我加了不少注释，应当可以帮助你看清 JSON 对象的基本用法了。唯一遗憾的是宏 <code>U</code>（类似于<a href=\"https://time.geekbang.org/column/article/179357\">[第 11 讲]</a> 里提到过的 <code>_T</code>）的使用有点碍眼：要确保代码在 Windows 下和 Unix 下都能工作，目前这还是必要的。</p><p>建议你测试一下这个例子。查看一下结果。</p><p>C++ REST SDK 里的 <code>http_request</code> 和 <code>http_response</code> 都对 JSON 有原生支持，如可以使用 <code>extract_json</code> 成员函数来异步提取 HTTP 请求或响应体中的 JSON 内容。</p><h2>HTTP 服务器</h2><p>前面我们提到了如何使用 C++ REST SDK 来快速搭建一个 HTTP 客户端。同样，我们也可以使用 C++ REST SDK 来快速搭建一个 HTTP 服务器。在三种主流的操作系统上，C++ REST SDK 的 <code>http_listener</code> 会通过调用 Boost.Asio <span class=\"orange\">[9]</span> 和操作系统的底层接口（IOCP、epoll 或 kqueue）来完成功能，向使用者隐藏这些细节、提供一个简单的编程接口。</p><p>我们将搭建一个最小的 REST 服务器，只能处理一个 sayHi 请求。客户端应当向服务器发送一个 HTTP 请求，URI 是：</p><blockquote>\n<p><code>/sayHi?name=…</code></p>\n</blockquote><p>“…”部分代表一个名字，而服务器应当返回一个 JSON 的回复，形如：</p><pre><code class=\"language-json\">{\"msg\": \"Hi, …!\"}\n</code></pre><p>这个服务器的有效代码行同样只有六十多行，如下所示：</p><pre><code class=\"language-c++\">#include &lt;exception&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\n#ifdef _WIN32\n#include &lt;fcntl.h&gt;\n#include &lt;io.h&gt;\n#endif\n#include &lt;cpprest/http_listener.h&gt;\n#include &lt;cpprest/json.h&gt;\n\nusing namespace std;\nusing namespace utility;\nusing namespace web;\nusing namespace web::http;\nusing namespace web::http::\n  experimental::listener;\n\n#ifdef _WIN32\n#define tcout std::wcout\n#else\n#define tcout std::cout\n#endif\n\nvoid handle_get(http_request req)\n{\n  auto&amp; uri = req.request_uri();\n\n  if (uri.path() != U(\"/sayHi\")) {\n    req.reply(\n      status_codes::NotFound);\n    return;\n  }\n\n  tcout &lt;&lt; uri::decode(uri.query())\n        &lt;&lt; endl;\n\n  auto query =\n    uri::split_query(uri.query());\n  auto it = query.find(U(\"name\"));\n  if (it == query.end()) {\n    req.reply(\n      status_codes::BadRequest,\n      U(\"Missing query info\"));\n    return;\n  }\n\n  auto answer =\n    json::value::object(true);\n  answer[U(\"msg\")] = json::value(\n    string_t(U(\"Hi, \")) +\n    uri::decode(it-&gt;second) +\n    U(\"!\"));\n\n  req.reply(status_codes::OK,\n            answer);\n}\n\nint main()\n{\n#ifdef _WIN32\n  _setmode(_fileno(stdout),\n           _O_WTEXT);\n#endif\n\n  http_listener listener(\n    U(\"http://127.0.0.1:8008/\"));\n  listener.support(methods::GET,\n                   handle_get);\n\n  try {\n    listener.open().wait();\n\n    tcout &lt;&lt; \"Listening. Press \"\n             \"ENTER to exit.\\n\";\n    string line;\n    getline(cin, line);\n\n    listener.close().wait();\n  }\n  catch (const exception&amp; e) {\n    cerr &lt;&lt; e.what() &lt;&lt; endl;\n    return 1;\n  }\n}\n</code></pre><p>如果你熟悉 HTTP 协议的话，上面的代码应当是相当直白的。只有少数几个细节我需要说明一下：</p><ul>\n<li>我们调用 <code>http_request::reply</code> 的第二个参数是 <code>json::value</code> 类型，这会让 HTTP 的内容类型（Content-Type）自动置成“application/json”。</li>\n<li><code>http_request::request_uri</code> 函数返回的是 <code>uri</code> 的引用，因此我用 <code>auto&amp;</code> 来接收。<code>uri::split_query</code> 函数返回的是一个普通的 <code>std::map</code>，因此我用 <code>auto</code> 来接收。</li>\n<li><code>http_listener::open</code> 和 <code>http_listener::close</code> 返回的是 <code>pplx::task&lt;void&gt;</code>；当这个任务完成时（<code>wait</code> 调用返回），表示 HTTP 监听器上的对应操作（打开或关闭）真正完成了。</li>\n</ul><p>运行程序，然后在另外一个终端里使用我们的第一个例子生成的可执行文件（或 curl）：</p><blockquote>\n<p><code>curl \"http://127.0.0.1:8008/sayHi?name=Peter\"</code></p>\n</blockquote><p>我们就应该会得到正确的结果：</p><blockquote>\n<p><code>{\"msg\":\"Hi, Peter!\"}</code></p>\n</blockquote><p>你也可以尝试把路径和参数写错，查看一下程序对出错的处理。</p><h2>关于线程的细节</h2><p>C++ REST SDK 使用异步的编程模式，使得写不阻塞的代码变得相当容易。不过，底层它是使用一个线程池来实现的——在 C++20 的协程能被使用之前，并没有什么更理想的跨平台方式可用。</p><p>C++ REST SDK 缺省会开启 40 个线程。在目前的实现里，如果这些线程全部被用完了，会导致系统整体阻塞。反过来，如果你只是用 C++ REST SDK 的 HTTP 客户端，你就不需要这么多线程。这个线程数量目前在代码里是可以控制的。比如，下面的代码会把线程池的大小设为 10：</p><pre><code class=\"language-c++\">#include &lt;pplx/threadpool.h&gt;\n…\ncrossplat::threadpool::\n  initialize_with_threads(10);\n</code></pre><p>如果你使用 C++ REST SDK 开发一个服务器，则不仅应当增加线程池的大小，还应当对并发数量进行统计，在并发数接近线程数时主动拒绝新的连接——一般可返回 <code>status_codes::ServiceUnavailable</code>——以免造成整个系统的阻塞。</p><h2>内容小结</h2><p>今天我们对 C++ REST SDK 的主要功能作了一下概要的讲解和演示，让你了解了它的主要功能和这种异步的编程方式。还有很多功能没有讲，但你应该可以通过查文档了解如何使用了。</p><p>这只能算是我们旅程中的一站——因为随着 C++20 的到来，我相信一定会有更多好用的网络开发库出现的。</p><h2>课后思考</h2><p>作为实战篇的最后一讲，内容还是略有点复杂的。如果你一下子消化不了，可以复习前面的相关内容。</p><p>如果对这讲的内容本身没有问题，则可以考虑一下，你觉得 C++ REST SDK 的接口好用吗？如果好用，原因是什么？如果不好用，你有什么样的改进意见？</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Microsoft, cpprestsdk. <a href=\"https://github.com/microsoft/cpprestsdk\">https://github.com/microsoft/cpprestsdk</a> </span></p><p><span class=\"reference\">[2] Wikipedia, “Hypertext Transfer Protocol”. <a href=\"https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol\">https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol</a> </span></p><p><span class=\"reference\">[2a] 维基百科, “超文本传输协议”. <a href=\"https://zh.m.wikipedia.org/zh-hans/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE\">https://zh.m.wikipedia.org/zh-hans/超文本传输协议</a> </span></p><p><span class=\"reference\">[3] RESTful. <a href=\"https://restfulapi.net/\">https://restfulapi.net/</a> </span></p><p><span class=\"reference\">[4] curl. <a href=\"https://curl.haxx.se/\">https://curl.haxx.se/</a> </span></p><p><span class=\"reference\">[5] JSON. <a href=\"https://www.json.org/\">https://www.json.org/</a> </span></p><p><span class=\"reference\">[6] Niels Lohmann, json. <a href=\"https://github.com/nlohmann/json\">https://github.com/nlohmann/json</a> </span></p><p><span class=\"reference\">[7] Tencent, rapidjson. <a href=\"https://github.com/Tencent/rapidjson\">https://github.com/Tencent/rapidjson</a> </span></p><p><span class=\"reference\">[8] Milo Yip, nativejson-benchmark. <a href=\"https://github.com/miloyip/nativejson-benchmark\">https://github.com/miloyip/nativejson-benchmark</a> </span></p><p><span class=\"reference\">[9] Christopher Kohlhoff, Boost.Asio. <a href=\"https://www.boost.org/doc/libs/release/doc/html/boost_asio.html\">https://www.boost.org/doc/libs/release/doc/html/boost_asio.html</a> </span></p>","comments":[{"had_liked":false,"id":175490,"user_name":"幻境之桥","can_delete":false,"product_type":"c1","uid":1061517,"ip_address":"","ucode":"F9F4DD94CB554E","user_header":"https://static001.geekbang.org/account/avatar/00/10/32/8d/91cd624b.jpg","comment_is_top":false,"comment_ctime":1580733231,"is_pvip":false,"replies":[{"id":68260,"content":"这要花时间的……用 CMake 的来顶这个评论，人多我就考虑一下。\n\n更新：我听到大家的声音了。CMake 用户的福利在这里：\n\nhttps:&#47;&#47;github.com&#47;adah1972&#47;geek_time_cpp\n\n有空时我会继续更新。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1580783381,"ip_address":"","comment_id":175490,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"吴老师要是可以把所有的内容都使用 cmake 来构建，以后参考起来可以更方便啊","like_count":93},{"had_liked":false,"id":203661,"user_name":"大土豆","can_delete":false,"product_type":"c1","uid":1121636,"ip_address":"","ucode":"67445DC3EC9DB0","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/64/52a5863b.jpg","comment_is_top":false,"comment_ctime":1586249503,"is_pvip":false,"replies":[{"id":76163,"content":"使用C++的话：\n\n得——性能；\n\n失——开发效率。\n\n关键在于损失的开发效率跟获得的性能比，值不值。如果你的应用瓶颈在数据库，显然不值。如果瓶颈在CPU和内存，可能就值了——如果你的应用很热门，需要很多台服务器部署的话。单台服务器的应用很可能就不值了，因为服务器便宜，开发人员的工资贵。\n\n游戏后台之类的服务器常常是用C++写的。没记错的话，Google的搜索引擎也是C++。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1586274052,"ip_address":"","comment_id":203661,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，您认为现在这种前后端分离的架构，服务端不输出页面，纯粹只输出json的情况下，为什么C++在Http Rest API的服务端还没有广泛的应用？目前大多数还是Java(spring)或者PHP，C++基本没份额","like_count":8,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482759,"discussion_content":"这要花时间的……用 CMake 的来顶这个评论，人多我就考虑一下。\n\n更新：我听到大家的声音了。CMake 用户的福利在这里：\n\nhttps://github.com/adah1972/geek_time_cpp\n\n有空时我会继续更新。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580783381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1198377,"avatar":"https://static001.geekbang.org/account/avatar/00/12/49/29/bbeccb9f.jpg","nickname":"风羽星泉","note":"","ucode":"CBC63AA00C5D70","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161110,"discussion_content":"支持支持，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580868864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217720,"user_name":"阿鼎","can_delete":false,"product_type":"c1","uid":1042634,"ip_address":"","ucode":"EE763513563F50","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e8/ca/2a7cc193.jpg","comment_is_top":false,"comment_ctime":1589596588,"is_pvip":false,"replies":[{"id":80557,"content":"第一步，升级。你在用十年前的老工具诶。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1589640617,"ip_address":"","comment_id":217720,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"项目用vs2010，而目前可选的restful库大多是c++11的。请问老师，通过何种手段，可以使用c11库？","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490924,"discussion_content":"使用C++的话：\n\n得——性能；\n\n失——开发效率。\n\n关键在于损失的开发效率跟获得的性能比，值不值。如果你的应用瓶颈在数据库，显然不值。如果瓶颈在CPU和内存，可能就值了——如果你的应用很热门，需要很多台服务器部署的话。单台服务器的应用很可能就不值了，因为服务器便宜，开发人员的工资贵。\n\n游戏后台之类的服务器常常是用C++写的。没记错的话，Google的搜索引擎也是C++。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586274052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175413,"user_name":"心情难以平静","can_delete":false,"product_type":"c1","uid":1022080,"ip_address":"","ucode":"F564EFB9963713","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/80/d958b445.jpg","comment_is_top":false,"comment_ctime":1580712996,"is_pvip":false,"replies":[{"id":68184,"content":"（C++20）协程是第 30 讲的内容。在 MSVC 和 Clang 已经基本可用了。坑，总得用了之后才知道有多少的……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1580728188,"ip_address":"","comment_id":175413,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"coroutine现在有好多轮子。希望标准实现快点到来。据说里面的坑较多，希望有人能先帮忙踩一踩。","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495234,"discussion_content":"第一步，升级。你在用十年前的老工具诶。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589640617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335503,"user_name":"在水一方","can_delete":false,"product_type":"c1","uid":1414215,"ip_address":"","ucode":"D8371EFEBED2C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiboeh23vhCNruZ7odUjROiac6N9fx0VWAE6zBNRxJIJFZspSUTQdgu9ajg4F0fAZgdk1vBsicnib3QQ/132","comment_is_top":false,"comment_ctime":1645541618,"is_pvip":false,"replies":[{"id":122694,"content":"无所谓了……这个项目只能是了解、学习一下。微软目前放弃这个项目了，因此不建议用于生产使用。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1645703766,"ip_address":"","comment_id":335503,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"支持长链接吗？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482721,"discussion_content":"（C++20）协程是第 30 讲的内容。在 MSVC 和 Clang 已经基本可用了。坑，总得用了之后才知道有多少的……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580728188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":298270,"user_name":"Geek_c18718","can_delete":false,"product_type":"c1","uid":2662893,"ip_address":"","ucode":"8EDDFFDE78D743","user_header":"","comment_is_top":false,"comment_ctime":1623988518,"is_pvip":false,"replies":[{"id":108280,"content":"命令行上输入。假设你用的是Windows，用的是我给出的命令行，一个示例执行可能就是：\n\ntest.exe &quot;http:&#47;&#47;wyw.dcweb.cn&#47;&quot;\n\n最后一问的意思我没看明白。请另起一个新问题，详细描述一下。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1624113663,"ip_address":"","comment_id":298270,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"吴老师，运行结果为A URL is needed，我应该去哪输入URL；完整的输入输出调用函数应该是什么样的呢？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522078,"discussion_content":"命令行上输入。假设你用的是Windows，用的是我给出的命令行，一个示例执行可能就是：\n\ntest.exe &amp;quot;http://wyw.dcweb.cn/&amp;quot;\n\n最后一问的意思我没看明白。请另起一个新问题，详细描述一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624113663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":272509,"user_name":"Geek_611a57","can_delete":false,"product_type":"c1","uid":1811312,"ip_address":"","ucode":"C5E2756205902F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoUlR8EWYGknKf3CG3n1gFhFKtPoticmN6AqJbbmLVibWvberBFIq3pHCHiakTI5juHVqrSnBz9lL6TQ/132","comment_is_top":false,"comment_ctime":1610103159,"is_pvip":false,"replies":[{"id":98801,"content":"所谓异步，是指你不是等待系统返回上一次的结果后进行下一步的操作（常见的同步做法），而是告诉系统，在上一次的操作执行结束后，然后给我去执行某段代码（then）。但异步的代码也会有个同步点，叫wait、get之类。程序整体还是用continuation的方式实现的，用then串起来。\n\nC++ REST SDK还是有个缺点，它虽然使用了异步的编程模式，但它的实现使用了多个线程，而非类似协程那种的真正异步，因此并发数有上限（默认是40）。如果你的并发数不高，或者手工调整这个数值，做网关是没有问题的，我实际就拿它做过请求缓存网关。比起用libcurl这种，代码应该是简洁了不少，但调试起来复杂些，坑也不一样。不同的人会有不同的取舍吧。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1610153634,"ip_address":"","comment_id":272509,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"在准备搭建一个HTTP网关，有两个问题请教：\n1. 异步流例子里哪里体现异步？看着好像是要等所有task都完成才返回？异步的需求是发送之后不等，有结果返回时候回调。\n2. 跟libcurl相比，哪个更适合应用于HTTP网关？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513297,"discussion_content":"所谓异步，是指你不是等待系统返回上一次的结果后进行下一步的操作（常见的同步做法），而是告诉系统，在上一次的操作执行结束后，然后给我去执行某段代码（then）。但异步的代码也会有个同步点，叫wait、get之类。程序整体还是用continuation的方式实现的，用then串起来。\n\nC++ REST SDK还是有个缺点，它虽然使用了异步的编程模式，但它的实现使用了多个线程，而非类似协程那种的真正异步，因此并发数有上限（默认是40）。如果你的并发数不高，或者手工调整这个数值，做网关是没有问题的，我实际就拿它做过请求缓存网关。比起用libcurl这种，代码应该是简洁了不少，但调试起来复杂些，坑也不一样。不同的人会有不同的取舍吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610153634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220879,"user_name":"可爱的小奶狗","can_delete":false,"product_type":"c1","uid":1178236,"ip_address":"","ucode":"DC810503571DD2","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/7c/f8f38ad0.jpg","comment_is_top":false,"comment_ctime":1590333152,"is_pvip":false,"replies":[{"id":81452,"content":"都有。最早就是在各平台上自己查文档、试验出来的。后来用了cmake，就会去参考它的规则。这种项目，确实用cmake轻松多了，因为在各个平台上需要链接的库是不一样的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1590367645,"ip_address":"","comment_id":220879,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"g++ -std=c++17 -pthread test.cpp -lcpprest -lcrypto -lssl -lboost_thread -lboost_chrono -lboost_system\n老师，这段手工在linux上编译test.cpp的命令，你咋知道要链接这些库呢？纯靠经验还是根据github上cpprestsdk这个项目release下的cmakelists.txt推断出出来的。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513297,"discussion_content":"所谓异步，是指你不是等待系统返回上一次的结果后进行下一步的操作（常见的同步做法），而是告诉系统，在上一次的操作执行结束后，然后给我去执行某段代码（then）。但异步的代码也会有个同步点，叫wait、get之类。程序整体还是用continuation的方式实现的，用then串起来。\n\nC++ REST SDK还是有个缺点，它虽然使用了异步的编程模式，但它的实现使用了多个线程，而非类似协程那种的真正异步，因此并发数有上限（默认是40）。如果你的并发数不高，或者手工调整这个数值，做网关是没有问题的，我实际就拿它做过请求缓存网关。比起用libcurl这种，代码应该是简洁了不少，但调试起来复杂些，坑也不一样。不同的人会有不同的取舍吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610153634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175740,"user_name":"莫珣","can_delete":false,"product_type":"c1","uid":1117933,"ip_address":"","ucode":"CAFE6F2AC5C177","user_header":"https://static001.geekbang.org/account/avatar/00/11/0e/ed/1c662e93.jpg","comment_is_top":false,"comment_ctime":1580815521,"is_pvip":false,"replies":[{"id":68374,"content":"遇到特定困难可以网上搜一下。我印象里，依赖装好之后，Linux上编译还是不麻烦的。你不是因为 GCC 版本太低吧？\n\n实际上，这虽然是微软出的，我觉得还是在 Windows 上编译更麻烦呢……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1580874561,"ip_address":"","comment_id":175740,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"cpprest这个库在linux下编译起来真是太麻烦了，今天折腾了大半天竟然没有编译出来。github上给出的编译步骤过于简单。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496260,"discussion_content":"都有。最早就是在各平台上自己查文档、试验出来的。后来用了cmake，就会去参考它的规则。这种项目，确实用cmake轻松多了，因为在各个平台上需要链接的库是不一样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590367645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175561,"user_name":"hey","can_delete":false,"product_type":"c1","uid":1014997,"ip_address":"","ucode":"276BD331772A8A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7c/d5/5d6b3d34.jpg","comment_is_top":false,"comment_ctime":1580743540,"is_pvip":false,"replies":[{"id":68258,"content":"支持。客户端直接用。服务器端麻烦点，根据平台不同有不同的配置方法。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1580783138,"ip_address":"","comment_id":175561,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"支持https吗 ","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482881,"discussion_content":"遇到特定困难可以网上搜一下。我印象里，依赖装好之后，Linux上编译还是不麻烦的。你不是因为 GCC 版本太低吧？\n\n实际上，这虽然是微软出的，我觉得还是在 Windows 上编译更麻烦呢……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580874561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1117933,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0e/ed/1c662e93.jpg","nickname":"莫珣","note":"","ucode":"CAFE6F2AC5C177","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161191,"discussion_content":"我弄好了，在一个空白机器上用源码编译的，现在回头来看，其实也不麻烦，归根到底还是自己对cmake不熟悉，又过于急躁，有些编译问题应该是能及时发现的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580875210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175490,"user_name":"幻境之桥","can_delete":false,"product_type":"c1","uid":1061517,"ip_address":"","ucode":"F9F4DD94CB554E","user_header":"https://static001.geekbang.org/account/avatar/00/10/32/8d/91cd624b.jpg","comment_is_top":false,"comment_ctime":1580733231,"is_pvip":false,"replies":[{"id":68260,"content":"这要花时间的……用 CMake 的来顶这个评论，人多我就考虑一下。\n\n更新：我听到大家的声音了。CMake 用户的福利在这里：\n\nhttps:&#47;&#47;github.com&#47;adah1972&#47;geek_time_cpp\n\n有空时我会继续更新。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1580783381,"ip_address":"","comment_id":175490,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"吴老师要是可以把所有的内容都使用 cmake 来构建，以后参考起来可以更方便啊","like_count":93,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482759,"discussion_content":"这要花时间的……用 CMake 的来顶这个评论，人多我就考虑一下。\n\n更新：我听到大家的声音了。CMake 用户的福利在这里：\n\nhttps://github.com/adah1972/geek_time_cpp\n\n有空时我会继续更新。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580783381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1198377,"avatar":"https://static001.geekbang.org/account/avatar/00/12/49/29/bbeccb9f.jpg","nickname":"风羽星泉","note":"","ucode":"CBC63AA00C5D70","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161110,"discussion_content":"支持支持，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580868864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203661,"user_name":"大土豆","can_delete":false,"product_type":"c1","uid":1121636,"ip_address":"","ucode":"67445DC3EC9DB0","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/64/52a5863b.jpg","comment_is_top":false,"comment_ctime":1586249503,"is_pvip":false,"replies":[{"id":76163,"content":"使用C++的话：\n\n得——性能；\n\n失——开发效率。\n\n关键在于损失的开发效率跟获得的性能比，值不值。如果你的应用瓶颈在数据库，显然不值。如果瓶颈在CPU和内存，可能就值了——如果你的应用很热门，需要很多台服务器部署的话。单台服务器的应用很可能就不值了，因为服务器便宜，开发人员的工资贵。\n\n游戏后台之类的服务器常常是用C++写的。没记错的话，Google的搜索引擎也是C++。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1586274052,"ip_address":"","comment_id":203661,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，您认为现在这种前后端分离的架构，服务端不输出页面，纯粹只输出json的情况下，为什么C++在Http Rest API的服务端还没有广泛的应用？目前大多数还是Java(spring)或者PHP，C++基本没份额","like_count":8,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490924,"discussion_content":"使用C++的话：\n\n得——性能；\n\n失——开发效率。\n\n关键在于损失的开发效率跟获得的性能比，值不值。如果你的应用瓶颈在数据库，显然不值。如果瓶颈在CPU和内存，可能就值了——如果你的应用很热门，需要很多台服务器部署的话。单台服务器的应用很可能就不值了，因为服务器便宜，开发人员的工资贵。\n\n游戏后台之类的服务器常常是用C++写的。没记错的话，Google的搜索引擎也是C++。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586274052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217720,"user_name":"阿鼎","can_delete":false,"product_type":"c1","uid":1042634,"ip_address":"","ucode":"EE763513563F50","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e8/ca/2a7cc193.jpg","comment_is_top":false,"comment_ctime":1589596588,"is_pvip":false,"replies":[{"id":80557,"content":"第一步，升级。你在用十年前的老工具诶。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1589640617,"ip_address":"","comment_id":217720,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"项目用vs2010，而目前可选的restful库大多是c++11的。请问老师，通过何种手段，可以使用c11库？","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495234,"discussion_content":"第一步，升级。你在用十年前的老工具诶。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589640617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175413,"user_name":"心情难以平静","can_delete":false,"product_type":"c1","uid":1022080,"ip_address":"","ucode":"F564EFB9963713","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/80/d958b445.jpg","comment_is_top":false,"comment_ctime":1580712996,"is_pvip":false,"replies":[{"id":68184,"content":"（C++20）协程是第 30 讲的内容。在 MSVC 和 Clang 已经基本可用了。坑，总得用了之后才知道有多少的……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1580728188,"ip_address":"","comment_id":175413,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"coroutine现在有好多轮子。希望标准实现快点到来。据说里面的坑较多，希望有人能先帮忙踩一踩。","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482721,"discussion_content":"（C++20）协程是第 30 讲的内容。在 MSVC 和 Clang 已经基本可用了。坑，总得用了之后才知道有多少的……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580728188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335503,"user_name":"在水一方","can_delete":false,"product_type":"c1","uid":1414215,"ip_address":"","ucode":"D8371EFEBED2C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiboeh23vhCNruZ7odUjROiac6N9fx0VWAE6zBNRxJIJFZspSUTQdgu9ajg4F0fAZgdk1vBsicnib3QQ/132","comment_is_top":false,"comment_ctime":1645541618,"is_pvip":false,"replies":[{"id":122694,"content":"无所谓了……这个项目只能是了解、学习一下。微软目前放弃这个项目了，因此不建议用于生产使用。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1645703766,"ip_address":"","comment_id":335503,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"支持长链接吗？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553061,"discussion_content":"无所谓了……这个项目只能是了解、学习一下。微软目前放弃这个项目了，因此不建议用于生产使用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645703766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":298270,"user_name":"Geek_c18718","can_delete":false,"product_type":"c1","uid":2662893,"ip_address":"","ucode":"8EDDFFDE78D743","user_header":"","comment_is_top":false,"comment_ctime":1623988518,"is_pvip":false,"replies":[{"id":108280,"content":"命令行上输入。假设你用的是Windows，用的是我给出的命令行，一个示例执行可能就是：\n\ntest.exe &quot;http:&#47;&#47;wyw.dcweb.cn&#47;&quot;\n\n最后一问的意思我没看明白。请另起一个新问题，详细描述一下。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1624113663,"ip_address":"","comment_id":298270,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"吴老师，运行结果为A URL is needed，我应该去哪输入URL；完整的输入输出调用函数应该是什么样的呢？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553061,"discussion_content":"无所谓了……这个项目只能是了解、学习一下。微软目前放弃这个项目了，因此不建议用于生产使用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645703766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":272509,"user_name":"Geek_611a57","can_delete":false,"product_type":"c1","uid":1811312,"ip_address":"","ucode":"C5E2756205902F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoUlR8EWYGknKf3CG3n1gFhFKtPoticmN6AqJbbmLVibWvberBFIq3pHCHiakTI5juHVqrSnBz9lL6TQ/132","comment_is_top":false,"comment_ctime":1610103159,"is_pvip":false,"replies":[{"id":98801,"content":"所谓异步，是指你不是等待系统返回上一次的结果后进行下一步的操作（常见的同步做法），而是告诉系统，在上一次的操作执行结束后，然后给我去执行某段代码（then）。但异步的代码也会有个同步点，叫wait、get之类。程序整体还是用continuation的方式实现的，用then串起来。\n\nC++ REST SDK还是有个缺点，它虽然使用了异步的编程模式，但它的实现使用了多个线程，而非类似协程那种的真正异步，因此并发数有上限（默认是40）。如果你的并发数不高，或者手工调整这个数值，做网关是没有问题的，我实际就拿它做过请求缓存网关。比起用libcurl这种，代码应该是简洁了不少，但调试起来复杂些，坑也不一样。不同的人会有不同的取舍吧。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1610153634,"ip_address":"","comment_id":272509,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"在准备搭建一个HTTP网关，有两个问题请教：\n1. 异步流例子里哪里体现异步？看着好像是要等所有task都完成才返回？异步的需求是发送之后不等，有结果返回时候回调。\n2. 跟libcurl相比，哪个更适合应用于HTTP网关？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522078,"discussion_content":"命令行上输入。假设你用的是Windows，用的是我给出的命令行，一个示例执行可能就是：\n\ntest.exe &amp;quot;http://wyw.dcweb.cn/&amp;quot;\n\n最后一问的意思我没看明白。请另起一个新问题，详细描述一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624113663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220879,"user_name":"可爱的小奶狗","can_delete":false,"product_type":"c1","uid":1178236,"ip_address":"","ucode":"DC810503571DD2","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/7c/f8f38ad0.jpg","comment_is_top":false,"comment_ctime":1590333152,"is_pvip":false,"replies":[{"id":81452,"content":"都有。最早就是在各平台上自己查文档、试验出来的。后来用了cmake，就会去参考它的规则。这种项目，确实用cmake轻松多了，因为在各个平台上需要链接的库是不一样的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1590367645,"ip_address":"","comment_id":220879,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"g++ -std=c++17 -pthread test.cpp -lcpprest -lcrypto -lssl -lboost_thread -lboost_chrono -lboost_system\n老师，这段手工在linux上编译test.cpp的命令，你咋知道要链接这些库呢？纯靠经验还是根据github上cpprestsdk这个项目release下的cmakelists.txt推断出出来的。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496260,"discussion_content":"都有。最早就是在各平台上自己查文档、试验出来的。后来用了cmake，就会去参考它的规则。这种项目，确实用cmake轻松多了，因为在各个平台上需要链接的库是不一样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590367645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175740,"user_name":"莫珣","can_delete":false,"product_type":"c1","uid":1117933,"ip_address":"","ucode":"CAFE6F2AC5C177","user_header":"https://static001.geekbang.org/account/avatar/00/11/0e/ed/1c662e93.jpg","comment_is_top":false,"comment_ctime":1580815521,"is_pvip":false,"replies":[{"id":68374,"content":"遇到特定困难可以网上搜一下。我印象里，依赖装好之后，Linux上编译还是不麻烦的。你不是因为 GCC 版本太低吧？\n\n实际上，这虽然是微软出的，我觉得还是在 Windows 上编译更麻烦呢……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1580874561,"ip_address":"","comment_id":175740,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"cpprest这个库在linux下编译起来真是太麻烦了，今天折腾了大半天竟然没有编译出来。github上给出的编译步骤过于简单。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482881,"discussion_content":"遇到特定困难可以网上搜一下。我印象里，依赖装好之后，Linux上编译还是不麻烦的。你不是因为 GCC 版本太低吧？\n\n实际上，这虽然是微软出的，我觉得还是在 Windows 上编译更麻烦呢……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580874561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1117933,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0e/ed/1c662e93.jpg","nickname":"莫珣","note":"","ucode":"CAFE6F2AC5C177","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161191,"discussion_content":"我弄好了，在一个空白机器上用源码编译的，现在回头来看，其实也不麻烦，归根到底还是自己对cmake不熟悉，又过于急躁，有些编译问题应该是能及时发现的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580875210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175561,"user_name":"hey","can_delete":false,"product_type":"c1","uid":1014997,"ip_address":"","ucode":"276BD331772A8A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7c/d5/5d6b3d34.jpg","comment_is_top":false,"comment_ctime":1580743540,"is_pvip":false,"replies":[{"id":68258,"content":"支持。客户端直接用。服务器端麻烦点，根据平台不同有不同的配置方法。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1580783138,"ip_address":"","comment_id":175561,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"支持https吗 ","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482799,"discussion_content":"支持。客户端直接用。服务器端麻烦点，根据平台不同有不同的配置方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580783138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":396092,"user_name":"小侠","can_delete":false,"product_type":"c1","uid":1045025,"ip_address":"陕西","ucode":"A35A61061E41B2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f2/21/00600713.jpg","comment_is_top":false,"comment_ctime":1733063815,"is_pvip":false,"replies":[{"id":143803,"content":"Asio 就可以。其他也有一些可以试试的：\n\nhttps:&#47;&#47;github.com&#47;alibaba&#47;PhotonLibOS 阿里的\nhttps:&#47;&#47;github.com&#47;alibaba&#47;yalantinglibs 还是阿里的\nhttps:&#47;&#47;github.com&#47;netcan&#47;asyncio 这个适合学习，代码量较低","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1733111875,"ip_address":"上海","comment_id":396092,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"现在（2024.12）有没有支持C++20协程的高效稳定的网络库？","like_count":0},{"had_liked":false,"id":348160,"user_name":"江湖中人","can_delete":false,"product_type":"c1","uid":3022855,"ip_address":"","ucode":"5D04FA57BD5C83","user_header":"https://static001.geekbang.org/account/avatar/00/2e/20/07/80337e76.jpg","comment_is_top":false,"comment_ctime":1654788140,"is_pvip":false,"replies":[{"id":126883,"content":"RPC 是个很通用的名词，不是一种具体协议，所以，这个问题不那么好回答……从理论上讲，当然时可以的。取决于你使用什么 RPC 方式，性能有可能会受到影响；具体是不是一个问题，就需要你自己评估了。\n\n往好里讲，一个通用的 RPC 方式会让代码更加简单和可维护，比起手写传输代码还是有很大优势的。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1654924662,"ip_address":"","comment_id":348160,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，我想把老项目里自定义消息体TCP传输的方式都改成RPC接口方式，不知道可行不，您有什么建议吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575534,"discussion_content":"RPC 是个很通用的名词，不是一种具体协议，所以，这个问题不那么好回答……从理论上讲，当然时可以的。取决于你使用什么 RPC 方式，性能有可能会受到影响；具体是不是一个问题，就需要你自己评估了。\n\n往好里讲，一个通用的 RPC 方式会让代码更加简单和可维护，比起手写传输代码还是有很大优势的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654924662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330080,"user_name":"天亮了","can_delete":false,"product_type":"c1","uid":1402260,"ip_address":"","ucode":"F5CEFC4B8F06EA","user_header":"https://static001.geekbang.org/account/avatar/00/15/65/94/829f321f.jpg","comment_is_top":false,"comment_ctime":1641790044,"is_pvip":false,"replies":[{"id":120361,"content":"是的，不过两年前写专栏的时候，项目还是正常状态的……","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1641903374,"ip_address":"","comment_id":330080,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"cpprest 微软自己都不推荐在新项目使用了。参见 github README. ","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545314,"discussion_content":"是的，不过两年前写专栏的时候，项目还是正常状态的……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641903374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1212044,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7e/8c/f029535a.jpg","nickname":"hallo128","note":"","ucode":"3921D6E11CFCB1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":582549,"discussion_content":"那现在有更好的网络开发库推荐吗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1659504441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":545314,"ip_address":"云南","group_id":0},"score":582549,"extra":""}]}]},{"had_liked":false,"id":326203,"user_name":"NiceBlueChai","can_delete":false,"product_type":"c1","uid":2038718,"ip_address":"","ucode":"2043333890C448","user_header":"https://static001.geekbang.org/account/avatar/00/1f/1b/be/525e05ae.jpg","comment_is_top":false,"comment_ctime":1639417368,"is_pvip":true,"replies":[{"id":118571,"content":"crow 看起来不错。哎，但它比 C++ REST SDK 更早就没有后续维护了……好歹在我写专栏的时候 C++ REST SDK 还是个活跃项目。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1639547208,"ip_address":"","comment_id":326203,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"用crow只用10行不到可能","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538881,"discussion_content":"crow 看起来不错。哎，但它比 C++ REST SDK 更早就没有后续维护了……好歹在我写专栏的时候 C++ REST SDK 还是个活跃项目。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639547208,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":287367,"user_name":"Geek_227a72","can_delete":false,"product_type":"c1","uid":2417911,"ip_address":"","ucode":"385B764D9AEAE8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKsI6VdljHFtMx4cgEPpqhXiaIYQicqGcal8sIoBYQZn7tYQyPLH1FuOVP8SaYPghPIsqSa1DWjRT2A/132","comment_is_top":false,"comment_ctime":1617904380,"is_pvip":false,"replies":[{"id":104407,"content":"你漏打那行 return 1; 了吗？在命令行上需要提供一个访问的 URL，不满足这个格式就会打印错误信息退出。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1618014740,"ip_address":"","comment_id":287367,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"运行第一个例子后出现：A URL is needed   段错误（核心已转储）   是什么原因呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518279,"discussion_content":"你漏打那行 return 1; 了吗？在命令行上需要提供一个访问的 URL，不满足这个格式就会打印错误信息退出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618014740,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236797,"user_name":"造梦师","can_delete":false,"product_type":"c1","uid":1983429,"ip_address":"","ucode":"705FCED828DC71","user_header":"https://static001.geekbang.org/account/avatar/00/1e/43/c5/288c59ab.jpg","comment_is_top":false,"comment_ctime":1595552579,"is_pvip":false,"replies":[{"id":87516,"content":"根据你的实际最高并发量比较好。如果是认真写一个产品级服务器的话，还真的需要有拒绝新连接的熔断措施才可靠。\n\n你可以在 handle_get 的开始和结束对一个原子量做 ++ 和 -- 操作，并记录下运行中的最大值。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1595566634,"ip_address":"","comment_id":236797,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"  initialize_with_threads 设置多少比较合理，或者说根据哪些条件设置","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502212,"discussion_content":"根据你的实际最高并发量比较好。如果是认真写一个产品级服务器的话，还真的需要有拒绝新连接的熔断措施才可靠。\n\n你可以在 handle_get 的开始和结束对一个原子量做 ++ 和 -- 操作，并记录下运行中的最大值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595566634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175848,"user_name":"申学晋","can_delete":false,"product_type":"c1","uid":1748750,"ip_address":"","ucode":"3F329A4DEBEE97","user_header":"https://static001.geekbang.org/account/avatar/00/1a/af/0e/ac955022.jpg","comment_is_top":false,"comment_ctime":1580869741,"is_pvip":false,"replies":[{"id":68373,"content":"还行吧，坑我也标出来了。全部用 wcout（tcout）一般就可以用。\n\nWebSocket支持我没用过，给不了建议。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1580874396,"ip_address":"","comment_id":175848,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"只用过cpprest开发客户端，在windows下字符串处理还是有点麻烦。最近想开发WebSocket服务器，不知道是否能用？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482927,"discussion_content":"还行吧，坑我也标出来了。全部用 wcout（tcout）一般就可以用。\n\nWebSocket支持我没用过，给不了建议。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580874396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161781,"discussion_content":"在Windows上，这个转换是少不了的。操作系统喜欢 UTF-16，但输入输出上基本没人用 UTF-16。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580917270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1748750,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/af/0e/ac955022.jpg","nickname":"申学晋","note":"","ucode":"3F329A4DEBEE97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161698,"discussion_content":"主要麻烦是需要处理字符串编码转换，有性能损失","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580915059,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175535,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1580740272,"is_pvip":false,"replies":[{"id":68261,"content":"那是肯定的，否则我介绍它干嘛……\n\n但话说回来，如果你的服务器性能要求非常高，这个方案就不一定适合了。一个并发连接目前还是需要一个线程的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1580783800,"ip_address":"","comment_id":175535,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"我觉得纯从网路编程上来说，比起直接用EPOLL，然后加上一堆线程、队列、锁、条件变量啥的方便多了，隐藏了事件和循环，还是方便多了。\n和JAVASCRIPT中的PROMISE已经非常像了。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482784,"discussion_content":"那是肯定的，否则我介绍它干嘛……\n\n但话说回来，如果你的服务器性能要求非常高，这个方案就不一定适合了。一个并发连接目前还是需要一个线程的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580783800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1584234,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/yRMlybhILtPMrSOz5Bo7ztj91z0nawFtFc8O9JeSjm8TevqicUeiaR7J091bicOAKIqmibRuSSjic0Fav4HksOLX12g/132","nickname":"KingHowe","note":"","ucode":"2A0BC8E9A1424B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":239411,"discussion_content":"用libuv吧，一个线程处理异步的io。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587299437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":396092,"user_name":"小侠","can_delete":false,"product_type":"c1","uid":1045025,"ip_address":"陕西","ucode":"A35A61061E41B2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f2/21/00600713.jpg","comment_is_top":false,"comment_ctime":1733063815,"is_pvip":false,"replies":[{"id":143803,"content":"Asio 就可以。其他也有一些可以试试的：\n\nhttps:&#47;&#47;github.com&#47;alibaba&#47;PhotonLibOS 阿里的\nhttps:&#47;&#47;github.com&#47;alibaba&#47;yalantinglibs 还是阿里的\nhttps:&#47;&#47;github.com&#47;netcan&#47;asyncio 这个适合学习，代码量较低","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1733111875,"ip_address":"上海","comment_id":396092,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"现在（2024.12）有没有支持C++20协程的高效稳定的网络库？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":654612,"discussion_content":"Asio 就可以。其他也有一些可以试试的：\n\nhttps://github.com/alibaba/PhotonLibOS 阿里的\nhttps://github.com/alibaba/yalantinglibs 还是阿里的\nhttps://github.com/netcan/asyncio 这个适合学习，代码量较低","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1733111875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348160,"user_name":"江湖中人","can_delete":false,"product_type":"c1","uid":3022855,"ip_address":"","ucode":"5D04FA57BD5C83","user_header":"https://static001.geekbang.org/account/avatar/00/2e/20/07/80337e76.jpg","comment_is_top":false,"comment_ctime":1654788140,"is_pvip":false,"replies":[{"id":126883,"content":"RPC 是个很通用的名词，不是一种具体协议，所以，这个问题不那么好回答……从理论上讲，当然时可以的。取决于你使用什么 RPC 方式，性能有可能会受到影响；具体是不是一个问题，就需要你自己评估了。\n\n往好里讲，一个通用的 RPC 方式会让代码更加简单和可维护，比起手写传输代码还是有很大优势的。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1654924662,"ip_address":"","comment_id":348160,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，我想把老项目里自定义消息体TCP传输的方式都改成RPC接口方式，不知道可行不，您有什么建议吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":654612,"discussion_content":"Asio 就可以。其他也有一些可以试试的：\n\nhttps://github.com/alibaba/PhotonLibOS 阿里的\nhttps://github.com/alibaba/yalantinglibs 还是阿里的\nhttps://github.com/netcan/asyncio 这个适合学习，代码量较低","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1733111875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330080,"user_name":"天亮了","can_delete":false,"product_type":"c1","uid":1402260,"ip_address":"","ucode":"F5CEFC4B8F06EA","user_header":"https://static001.geekbang.org/account/avatar/00/15/65/94/829f321f.jpg","comment_is_top":false,"comment_ctime":1641790044,"is_pvip":false,"replies":[{"id":120361,"content":"是的，不过两年前写专栏的时候，项目还是正常状态的……","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1641903374,"ip_address":"","comment_id":330080,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"cpprest 微软自己都不推荐在新项目使用了。参见 github README. ","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575534,"discussion_content":"RPC 是个很通用的名词，不是一种具体协议，所以，这个问题不那么好回答……从理论上讲，当然时可以的。取决于你使用什么 RPC 方式，性能有可能会受到影响；具体是不是一个问题，就需要你自己评估了。\n\n往好里讲，一个通用的 RPC 方式会让代码更加简单和可维护，比起手写传输代码还是有很大优势的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654924662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326203,"user_name":"NiceBlueChai","can_delete":false,"product_type":"c1","uid":2038718,"ip_address":"","ucode":"2043333890C448","user_header":"https://static001.geekbang.org/account/avatar/00/1f/1b/be/525e05ae.jpg","comment_is_top":false,"comment_ctime":1639417368,"is_pvip":true,"replies":[{"id":118571,"content":"crow 看起来不错。哎，但它比 C++ REST SDK 更早就没有后续维护了……好歹在我写专栏的时候 C++ REST SDK 还是个活跃项目。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1639547208,"ip_address":"","comment_id":326203,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"用crow只用10行不到可能","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545314,"discussion_content":"是的，不过两年前写专栏的时候，项目还是正常状态的……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641903374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1212044,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7e/8c/f029535a.jpg","nickname":"hallo128","note":"","ucode":"3921D6E11CFCB1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":582549,"discussion_content":"那现在有更好的网络开发库推荐吗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1659504441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":545314,"ip_address":"云南","group_id":0},"score":582549,"extra":""}]}]},{"had_liked":false,"id":287367,"user_name":"Geek_227a72","can_delete":false,"product_type":"c1","uid":2417911,"ip_address":"","ucode":"385B764D9AEAE8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKsI6VdljHFtMx4cgEPpqhXiaIYQicqGcal8sIoBYQZn7tYQyPLH1FuOVP8SaYPghPIsqSa1DWjRT2A/132","comment_is_top":false,"comment_ctime":1617904380,"is_pvip":false,"replies":[{"id":104407,"content":"你漏打那行 return 1; 了吗？在命令行上需要提供一个访问的 URL，不满足这个格式就会打印错误信息退出。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1618014740,"ip_address":"","comment_id":287367,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"运行第一个例子后出现：A URL is needed   段错误（核心已转储）   是什么原因呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538881,"discussion_content":"crow 看起来不错。哎，但它比 C++ REST SDK 更早就没有后续维护了……好歹在我写专栏的时候 C++ REST SDK 还是个活跃项目。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639547208,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236797,"user_name":"造梦师","can_delete":false,"product_type":"c1","uid":1983429,"ip_address":"","ucode":"705FCED828DC71","user_header":"https://static001.geekbang.org/account/avatar/00/1e/43/c5/288c59ab.jpg","comment_is_top":false,"comment_ctime":1595552579,"is_pvip":false,"replies":[{"id":87516,"content":"根据你的实际最高并发量比较好。如果是认真写一个产品级服务器的话，还真的需要有拒绝新连接的熔断措施才可靠。\n\n你可以在 handle_get 的开始和结束对一个原子量做 ++ 和 -- 操作，并记录下运行中的最大值。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1595566634,"ip_address":"","comment_id":236797,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"  initialize_with_threads 设置多少比较合理，或者说根据哪些条件设置","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518279,"discussion_content":"你漏打那行 return 1; 了吗？在命令行上需要提供一个访问的 URL，不满足这个格式就会打印错误信息退出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618014740,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175848,"user_name":"申学晋","can_delete":false,"product_type":"c1","uid":1748750,"ip_address":"","ucode":"3F329A4DEBEE97","user_header":"https://static001.geekbang.org/account/avatar/00/1a/af/0e/ac955022.jpg","comment_is_top":false,"comment_ctime":1580869741,"is_pvip":false,"replies":[{"id":68373,"content":"还行吧，坑我也标出来了。全部用 wcout（tcout）一般就可以用。\n\nWebSocket支持我没用过，给不了建议。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1580874396,"ip_address":"","comment_id":175848,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"只用过cpprest开发客户端，在windows下字符串处理还是有点麻烦。最近想开发WebSocket服务器，不知道是否能用？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502212,"discussion_content":"根据你的实际最高并发量比较好。如果是认真写一个产品级服务器的话，还真的需要有拒绝新连接的熔断措施才可靠。\n\n你可以在 handle_get 的开始和结束对一个原子量做 ++ 和 -- 操作，并记录下运行中的最大值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595566634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175535,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1580740272,"is_pvip":false,"replies":[{"id":68261,"content":"那是肯定的，否则我介绍它干嘛……\n\n但话说回来，如果你的服务器性能要求非常高，这个方案就不一定适合了。一个并发连接目前还是需要一个线程的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1580783800,"ip_address":"","comment_id":175535,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"我觉得纯从网路编程上来说，比起直接用EPOLL，然后加上一堆线程、队列、锁、条件变量啥的方便多了，隐藏了事件和循环，还是方便多了。\n和JAVASCRIPT中的PROMISE已经非常像了。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482927,"discussion_content":"还行吧，坑我也标出来了。全部用 wcout（tcout）一般就可以用。\n\nWebSocket支持我没用过，给不了建议。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580874396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161781,"discussion_content":"在Windows上，这个转换是少不了的。操作系统喜欢 UTF-16，但输入输出上基本没人用 UTF-16。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580917270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1748750,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/af/0e/ac955022.jpg","nickname":"申学晋","note":"","ucode":"3F329A4DEBEE97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161698,"discussion_content":"主要麻烦是需要处理字符串编码转换，有性能损失","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580915059,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}