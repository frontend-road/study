{"id":77849,"title":"15 | 从树到图：如何让计算机学会看地图？","content":"<p>你好，我是黄申。</p><p>我们经常使用手机上的地图导航App，查找出行的路线。那计算机是如何在多个选择中找到最优解呢？换句话说，计算机是如何挑选出最佳路线的呢？</p><p>前几节，我们讲了数学中非常重要的图论中的概念，图，尤其是树中的广度优先搜索。在广度优先的策略中，因为社交网络中的关系是双向的，所以我们直接用无向边来求解图中任意两点的最短通路。</p><p>这里，我们依旧可以用图来解决这个问题，但是，影响到达最终目的地的因素有很多，比如出行的交通工具、行驶的距离、每条道路的交通状况等等，因此，我们需要赋予到达目的地的每条边，不同的权重。而我们想求的最佳路线，其实就是各边权重之和最小的通路。</p><p>我们前面说了，广度优先搜索只测量通路的长度，而不考虑每条边上的权重。那么广度优先搜索就无法高效地完成这个任务了。那我们能否把它改造或者优化一下呢？</p><p>我们需要先把交通地图转为图的模型。图中的每个结点表示一个地点，每条边表示一条道路或者交通工具的路线。其中，边是有向的，表示单行道等情况；其次，边是有权重的。</p><p>假设你关心的是路上所花费的时间，那么权重就是从一点到另一点所花费的时间；如果你关心的是距离，那么权重就是两点之间的物理距离。这样，我们就把交通导航转换成图论中的一个问题：在边有权重的图中，如何让计算机查找最优通路？</p><!-- [[[read_end]]] --><h2>基于广度优先或深度优先搜索的方法</h2><p>我们以寻找耗时最短的路线为例来看看。</p><p>一旦我们把地图转换成了图的模型，就可以<strong>运用广度优先搜索，计算从某个出发点，到图中任意一个其他结点的总耗时</strong>。</p><p>基本思路是，从出发点开始，广度优先遍历每个点，当遍历到某个点的时候，如果该点还没有耗时的记录，记下当前这条通路的耗时。如果该点之前已经有耗时记录了，那就比较当前这条通路的耗时是不是比之前少。如果是，那就用当前的替换掉之前的记录。</p><p>实际上，地图导航和之前社交网络最大的不同在于，每个结点被访问了一次还是多次。在之前的社交网络的案例中，使用广度优先策略时，对每个结点的首次访问就能获得最短通路，因此每个结点只需要被访问一次，这也是为什么广度优先比深度优先更有效。</p><p>而在地图导航的案例中，从出发点到某个目的地结点，可能有不同的通路，也就意味着耗时不同。而耗时是通路上每条边的权重决定的，而不是通路的长度。因此，为了获取达到某个点的最短时间，我们必须遍历所有可能的路线，来取得最小值。这也就是说，我们对某些结点的访问可能有多次。</p><p>我画了一张图，方便你理解多条通路对最终结果的影响。这张图中有A、B、C、D、E五个结点，分别表示不同的地点。</p><p><img src=\"https://static001.geekbang.org/resource/image/c1/b2/c155d6b1babe59e0c42928337686f9b2.jpg?wh=1142*654\" alt=\"\"></p><p>从这个图中可以看出，从A点出发到目的地B点，一共有三条路线。</p><ul>\n<li>如果你直接从A点到B点，度数为1，需要50分钟。</li>\n<li>从A点到C点再到B点，虽然度数为2，但总共只要40分钟。</li>\n<li>从A点到D点，到E点，再到最后的B点，虽然度数为3，但是总耗时只有35分钟，比其他所有的路线更优。</li>\n</ul><p>这种情形之下，使用广度优先找到的最短通路，不一定是最优的路线。所以，对于在地图上查找最优路线的问题，无论是广度优先还是深度优先的策略，都需要遍历所有可能的路线，然后取最优的解。</p><p>在遍历所有可能的路线时，有几个问题需要注意。</p><p>第一，由于要遍历所有可能的通路，因此一个点可能会被访问多次。当然，这个“多次“是指某个结点出现在不同通路中，而不是多次出现在同一条通路中。因为我们不想让用户总是兜圈子，所以需要避免回路。</p><p>第二，如果某个结点x和起始点s之间存在多个通路，每当x到s之间的最优路线被更新之后，我们还需要更新所有和x相邻的结点之最优路线，计算复杂度会很高。</p><h2>一个优化的版本：Dijkstra算法</h2><p>无论是广度优先还是深度优先的实现，算法对每个结点的访问都可能多于一次。而访问多次，就意味着要消耗更多的计算机资源。那么，有没有可能在保证最终结果是正确的情况下，尽可能地减少访问结点的次数，来提升算法的效率呢？</p><p>首先，我们思考一下，对于某些结点，是不是可以提前获得到达它们的最终的解（例如最短耗时、最短距离、最低价格等等），从而把它们提前移出遍历的清单？如果有，是哪些结点呢？什么时候可以把它们移除呢？Dijkstra算法要登场了！它简直就是为了解决这些问题量身定制的。</p><p>Dijkstra算法的核心思想是，对于某个结点，如果我们已经发现了最优的通路，那么就无需在将来的步骤中，再次考虑这个结点。Dijkstra算法很巧妙地找到这种点，而且能确保已经为它找到了最优路径。</p><h3>1.Dijkstra算法的主要步骤</h3><p>让我们先来看看Dijkstra算法的主要步骤，然后再来理解，它究竟是如何确定哪些结点已经拥有了最优解。</p><p>首先你需要了解几个符号。</p><p>第一个是source，我们用它表示图中的起始点，缩写是s。</p><p>然后是weight，表示二维数组，保存了任意边的权重，缩写为w。w[m, n]表示从结点m到结点n的有向边之权重，大于等于0。如果m到n有多条边，而且权重各自不同，那么取权重最小的那条边。</p><p>接下来是min_weight，表示一维数组，保存了从s到任意结点的最小权重，缩写为mw。假设从s到某个结点m有多条通路，而每条通路的权重是这条通路上所有边的权重之和，那么mw[m]就表示这些通路权重中的最小值。mw[s]=0，表示起始点到自己的最小权重为0。</p><p>最后是Finish，表示已经找到最小权重的结点之集合，缩写为F。一旦结点被放入集合F，这个结点就不再参与将来的计算。</p><p>初始的时候，Dijkstra算法会做三件事情。第一，把起始点s的最小权重赋为0，也就是mw[s] = 0。第二，往集合F里添加结点s，F包含且仅包含s。第三，假设结点 s 能直接到达的边集合为M，对于其中的每一个对端节点m，则把mw[m]设为w[s, m]，同时对于所有其他s不能直接到达的结点，将通路的权重设为无穷大。</p><p>然后，Dijkstra算法会重复下列两个步骤。</p><p><strong>第一步，查找最小mw</strong>。从mw数组选择最小值，则这个值就是起始点s到所对应的结点的最小权重，并且把这个点加入到F中，针对这个点的计算就算完成了。</p><p>比如，当前mw中最小的值是mw[x]=10，那么结点s到结点x的最小权重就是10，并且把结点x放入集合F，将来没有必要再考虑点x，mw[x]可能的最小值也就确定为10了。</p><p><strong>第二步，更新权重</strong>。然后，我们看看，新加入F的结点x，是不是可以直接到达其他结点。如果是，看看通过x到达其他点的通路权重，是否比这些点当前的mw更小，如果是，那么就替换这些点在mw中的值。</p><p>例如，x可以直接到达y，那么把(mw[x] + w[x, y])和mw[y]比较，如果(mw[x] + w[x, y])的值更小，那么把mw[y]更新为这个更小的值，而我们把x称为y的前驱结点。</p><p>然后，重复上述两步，再次从mw中找出最小值，此时要求mw对应的结点不属于F，重复上述动作，直到集合F包含了图的所有结点，也就是说，没有结点需要处理了。</p><p>字面描述有些抽象，我用一个具体的例子来解释一下。你可以看我画的这个图。</p><p><img src=\"https://static001.geekbang.org/resource/image/79/aa/796ad4473319311570c64646875370aa.jpg?wh=1142*634\" alt=\"\"></p><p>我们把结点s放入集合F。同s直接相连的结点有a、b、c和d，我把它们的mw更新为w数组中的值，就可以得到如下结果：</p><p><img src=\"https://static001.geekbang.org/resource/image/85/7e/85d93aaa912327053fa18157f02c067e.png?wh=1580*224\" alt=\"\"></p><p>然后，我们从mw选出最小的值0.2，把对应的结点c加入集合F，并更新和c直接相连的结点f、h的mw值，得到如下结果：</p><p><img src=\"https://static001.geekbang.org/resource/image/7a/bf/7abb384727aa14482c5c1a99e841fabf.png?wh=1550*376\" alt=\"\"></p><p>然后，我们从mw选出最小的值0.3，把对应的结点b加入集合F，并更新和b直接相连的结点a和f的mw值。以此逐步类推，可以得到如下的最终结果：</p><p><img src=\"https://static001.geekbang.org/resource/image/ac/46/acfbc2ef21b572cb0b7d1a8ea248d346.png?wh=1768*1464\" alt=\"\"></p><p>你可以试着自己从头到尾推导一下，看看结果是不是和我的一致。</p><p>说到这里，你可能会产生一个疑问：Dijkstra算法提前把一些结点排除在计算之外，而且没有遍历全部可能的路径，那么它是如何确保找到最优路径的呢？</p><p>下面，我们就来看看这个问题的答案。Dijkstra算法的步骤看上去有点复杂，不过其中最关键的两步是：第一个是每次选择最小的mw；第二个是，假设被选中的最小mw，所对应的结点是x，那么查看和x直接相连的结点，并更新它们的mw。</p><h3>2.为什么每次都要选择最小的mw？</h3><p>最小的、非无穷大的mw值，对应的结点是还没有加入F集合的、且和s有通路的那些结点。假设当前mw数组中最小的值是mw[x]，对应的结点是x。如果边的权重都是正值，那么通路上的权重之和是单调递增的，所以其他通路的权重之和一定大于当前的mw[x]，因此即使存在其他的通路，其权重也会比mw[x]大。</p><p>你可以结合这个图，来理解我刚才这段话。</p><p><img src=\"https://static001.geekbang.org/resource/image/c6/d3/c6d1365f398861d997a8b443a6fdfbd3.jpg?wh=1142*654\" alt=\"\"></p><p>图中的虚线表示省去了通路中间的若干结点。mw[x]是当前mw数组中的最小值，所以它小于等于任何一个mw[xn]，其中xn不等于x。</p><p>我们假设存在另一个通路，通过$x_{n}$达到x，那么通路的权重总和为mw[$x_{n}$] + w[$x_{n}$, x] ≥ mw[$x_{n}$] ≥ mw[x]。所以我们可以得到一个结论：拥有最小mw值的结点x不可能再找到更小的mw值，可以把它放入“已完成“的集合F。</p><p>这就是为什么每次都要选择最小的mw值，并认为对应的结点已经完成了计算。和广度优先或者深度优先的搜索相比，Dijkstra算法可以避免对某些结点，重复而且无效的访问。因此，每次选择最小的mw，就可以提升了搜索的效率。</p><h3>3.为什么每次都要看x直接相连的结点？</h3><p>我们已经确定mw[x]是从点s到点x的最小权重，那么就可以把这个确定的值传播到和x直接相连、而且不在F中的结点。通过这一步，我们就可以获得从点s到这些点、而且经过x的通路中最小的那个权重。我画了张图帮助你理解。</p><p><img src=\"https://static001.geekbang.org/resource/image/ec/f2/ec5b72711eba1bf5c4e2f9c03beedaf2.jpg?wh=1142*584\" alt=\"\"></p><p>在这个图中，x直接相连$y_{1}$，$y_{2}$，…，$y_{n}$。从点s到点x的mw[x]已经确定了，那么对于从s到yn的所有通路，只有两种可能，经过x和不经过x。如果这条通路经过x，那么其权重的最小值就是mw’[$y_{i}$] = mw[x] + w[x, $y_{i}$]中的一个（1≤i≤n），我们只需要把这个值和其他未经过x结点的通路之权重对比就足够了。这就是为什么每次要更新和x直接相连的结点之mw。</p><p>这一步和广度优先策略中的查找某个结点的所有相邻结点类似。但是，之后，Dijkstra算法重复挑选最小权重的步骤，既没有遵从广度优先，也没有遵从深度优先。即便如此，它仍然保证了不会遗漏任意一点和起始点s之间、拥有最小权重的通路，从而保证了搜索的覆盖率。你可能会奇怪，这是如何得到保证的？我使用数学归纳法，来证明一下。</p><p>你还记得数学归纳法的一般步骤吗？刚好借由这个例子我们也来复习一下。</p><p><strong>我们的命题是，对于任意一个点，Dijkstra算法都可以找到它和起始点s之间拥有最小权重的通路。</strong></p><p>首先，当n=1的时候，也就是只有起始点s和另一个终止点的时候，Dijkstra算法的初始化阶段的第3步，保证了命题的成立。</p><p>然后，我们假设n=k-1的时候命题成立，同时需要证明n=k的时候命题也成立。命题在n=k-1时成立，表明从点s到k-1个终点的任何一个时，Dijkstra算法都能找到拥有最小权重的通路。那么再增加一个结点x，Dijkstra算法同样可以为包含x的k个终点找到最小权重通路。</p><p>这里我们只需要考虑x和这k-1个点连通的情况。因为如果不连通，就没有必要考虑x了。既然连通，x可能会指向之前k-1个结点，也有可能被这k-1个结点所指向。假设x指向了y，而z指向了x，y和z都是之前k-1个结点中的一员。</p><p><img src=\"https://static001.geekbang.org/resource/image/59/b1/59dfee4aefe052d5a7da2cea7bf20cb1.jpg?wh=1142*690\" alt=\"\"></p><p>我们先来看x对y的影响。如果x不在从s到y的最小权重通路上，那么x的加入并不影响mw[y]的最终结果。如果x在从s到y的最小权重通路上，那么就意味着mw[x] + w[x, y]≤mw’[y]，mw’表示没有引入结点x的时候，mw的值。</p><p>所以有mw[x]≤mw’[y]，这就意味着Dijkstra算法在查找最小mw的步骤中，会在mw’[y]之前挑出mw[x]，也就是找到了从s到y，且经过x的最小权重通路。</p><p>我们再来看z对x的影响。假设有多个z指向x，分别是$z_{1}$, $z_{2}$, …,$z_{m}$，从s到x的通路必定会经过这m个z结点中的一个。Dijkstra算法中找最小mw的步骤，一定会遍历mw[$z_{i}$]（1&lt;=i&lt;=m），而更新权重的步骤，可以并保证从(mw[$z_{i}$] + w[$z_{i}$, x])中找出最小值，最终找到从s到x的最优通路。</p><p>有了详细的推导，想要写出代码就不难了。我这里只给你说几点需要注意的地方。</p><p>在自动生成图的函数中，你需要把广度优先搜索的相应代码做两处修改。第一，现在边是有向的了，所以生成的边只需要添加一次；第二，要给边赋予一个权重值，例如可以把边的权重设置为[0,1.0)之间的float型数值。</p><p>为了更好地模块化，你可以实现两个函数：findGeoWithMinWeight和updateWeight。它们分别对应于我之前提到的最重要的两步：每次选择最小的mw；更新和x直接相连的结点之mw。</p><p>每次查找最小mw的时候，我们需要跳过已经完成的结点，只考虑那些不在F集合中的点。这也是Dijkstra算法比较高效的原因。此外，如果你想输出最优路径上的每个结点，那么在updateWeight函数中就要记录每个结点的前驱结点。</p><p>如果你能跟着我进行一步步的推导，并且手写代码进行练习，相信你对Dijkstra算法会有更深刻的印象。</p><h2>小结</h2><p>我们使用Dijkstra算法来查找地图中两点之间的最短路径，而今天我所介绍的Dijkstra使用了更为抽象的“权重”。如果我们把结点作为地理位置，边的权重设置为路上所花费的时间，那么Dijkstra算法就能帮助我们找到，任意两个点之间耗时最短的路线。</p><p>除了时间之外，你也可以对图的边设置其他类型的权重，比如距离、价格，这样Dijkstra算法可以让用户找到地图任意两点之间的最短路线，或者出行的最低价格等等。有的时候，边的权重越大越好，比如观光车开过某条路线的车票收入。对于这种情况，Dijkstra算法就需要调整一下，每次找到最大的mw，更新邻近结点时也要找更大的值。所以，你只要掌握核心的思路就可以了，具体的实现可以根据情况去灵活调整。</p><p><img src=\"https://static001.geekbang.org/resource/image/48/9f/48b3029c0e5310bf9b5f2e5564463a9f.jpg?wh=1242*1441\" alt=\"\"></p><h2>思考题</h2><p>今天的思考题和地图数据的特殊情况有关。</p><ol>\n<li>\n<p>如果边的权重是负数，我们还能用今天讲的Dijkstra算法吗？</p>\n</li>\n<li>\n<p>如果地图中存在多条最优路径，也就是说多条路径的权重和都是相等的，那么我刚刚介绍的Dijkstra算法应该如何修改呢？</p>\n</li>\n</ol><p><span class=\"orange\">欢迎在留言区交作业，并写下你今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p>","neighbors":{"left":{"article_title":"14 | 树的广度优先搜索（下）：为什么双向广度优先搜索的效率更高？","id":77474},"right":{"article_title":"16 | 时间和空间复杂度（上）：优化性能是否只是“纸上谈兵”？","id":78186}},"comments":[{"had_liked":false,"id":61464,"user_name":"Being","can_delete":false,"product_type":"c1","uid":1152227,"ip_address":"","ucode":"80A8783927B650","user_header":"https://static001.geekbang.org/account/avatar/00/11/94/e3/ed118550.jpg","comment_is_top":false,"comment_ctime":1547703823,"is_pvip":false,"replies":[{"id":"21874","content":"回答思路很清晰，封面要感谢编辑帮忙 :)","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1547748307,"ip_address":"","comment_id":61464,"utype":1}],"discussion_count":3,"race_medal":0,"score":"57382278671","product_id":100021201,"comment_content":"思考1: 如果边权值为负数就不能使用Dijkstra了，因为该算法是贪心算法，即每步都找最优解，在当前步的最优基础上找下一步最优，一定是单调递增的，而出现负权边，这样的前提就不满足了。<br>而且也不能有带负权值的环，这个样就会一直找当前最优，而且总是满足。<br>思考2:就在找最小值时返回最小值集合，更新集合内所有点的直连边权值的最小值，且把集合点都加入F。<br>（by the way这张封面图挺好看的🙂）","like_count":13,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436878,"discussion_content":"回答思路很清晰，封面要感谢编辑帮忙 :)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547748307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1082785,"avatar":"https://static001.geekbang.org/account/avatar/00/10/85/a1/2442332c.jpg","nickname":"郭俊杰","note":"","ucode":"D328E5738A4413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":244924,"discussion_content":"思考一说的很棒，环都想到了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587642233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1082785,"avatar":"https://static001.geekbang.org/account/avatar/00/10/85/a1/2442332c.jpg","nickname":"郭俊杰","note":"","ucode":"D328E5738A4413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":244921,"discussion_content":"思考2， 老师课中的例子，d f两点mw都是0.4, 都是最小，但老师先选了d点, 然后选f点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587642132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64564,"user_name":"失火的夏天","can_delete":false,"product_type":"c1","uid":1241770,"ip_address":"","ucode":"10C6E66EB2A65F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","comment_is_top":false,"comment_ctime":1548822727,"is_pvip":false,"replies":[{"id":"22891","content":"Dijkstra是贪心，还是动态规划，确实有些不同意见。我个人觉得Dijkstra不算是贪心，因为贪心算法往往无法得到最优解，胜在简单和效率。而Dijkstra是可以找到最优的。我觉得Dijkstra更接近动态规划","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1548868047,"ip_address":"","comment_id":64564,"utype":1}],"discussion_count":3,"race_medal":0,"score":"48793462983","product_id":100021201,"comment_content":"Dijkstra好像是基于贪心算法的思想，因为老师用数学归纳法证明了贪心选择可以得到最优，但是出现了负数，就不满足贪心选择了，算法思路应该就变成了动态规划","like_count":11,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438076,"discussion_content":"Dijkstra是贪心，还是动态规划，确实有些不同意见。我个人觉得Dijkstra不算是贪心，因为贪心算法往往无法得到最优解，胜在简单和效率。而Dijkstra是可以找到最优的。我觉得Dijkstra更接近动态规划","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548868047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1264707,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4c/43/150c70c2.jpg","nickname":"陈松Plus","note":"","ucode":"0074BDECFA3D1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385172,"discussion_content":"臣附议","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626931297,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1082785,"avatar":"https://static001.geekbang.org/account/avatar/00/10/85/a1/2442332c.jpg","nickname":"郭俊杰","note":"","ucode":"D328E5738A4413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":244925,"discussion_content":"我同意老师的观点，哈哈，更像dp","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587642314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83629,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1554686717,"is_pvip":false,"replies":[{"id":"30297","content":"如果全都是负数也是可以的，只要保证单调性。如果同时有正有负就不行了，无法保证单调性，没法按照Dijkstra算法的方式进行优化。","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1554740334,"ip_address":"","comment_id":83629,"utype":1}],"discussion_count":2,"race_medal":0,"score":"35914425085","product_id":100021201,"comment_content":"负数也可以吧，我们取负数的最小值，然后所有边全部加上这个负数的最小值，转换一下不就可以了吗？","like_count":8,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446103,"discussion_content":"如果全都是负数也是可以的，只要保证单调性。如果同时有正有负就不行了，无法保证单调性，没法按照Dijkstra算法的方式进行优化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554740334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1900725,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKPdEnYlEFicKq32JlBxD0dj5UGpoee7qAbuVZlKYc6IjzgUkibVjhd0Xb6d1FRDlKEOBx4sToJCh1w/132","nickname":"201200814","note":"","ucode":"02FF0B8F4FEC09","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309285,"discussion_content":"假设一条通路前面权重很大，最后一段权重是负无穷大，另外一条通路权重都是比较小的正数，那算法会找到后面这条，负无穷大没有机会参与运算","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601253521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72263,"user_name":"qinggeouye","can_delete":false,"product_type":"c1","uid":1251536,"ip_address":"","ucode":"5B53EEDD7BEC9C","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/d0/49b06424.jpg","comment_is_top":false,"comment_ctime":1551547037,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18731416221","product_id":100021201,"comment_content":"# python 实现<br>https:&#47;&#47;github.com&#47;qinggeouye&#47;GeekTime&#47;blob&#47;master&#47;MathematicProgrammer&#47;15_theShortestPath&#47;lesson15_1.py<br><br># 实现效果<br>用户 0 的好友: [5], \t权重值 [0.42]<br>用户 1 的好友: [4, 9, 0, 6, 3], \t权重值 [0.99, 0.16, 0.2, 0.6, 0.1]<br>用户 2 的好友: 不存在<br>用户 3 的好友: 不存在<br>用户 4 的好友: [2, 5, 3], \t权重值 [0.17, 0.03, 0.03]<br>用户 5 的好友: [7], \t权重值 [0.19]<br>用户 6 的好友: [4], \t权重值 [0.38]<br>用户 7 的好友: [8, 1], \t权重值 [0.86, 0.63]<br>用户 8 的好友: [7, 3], \t权重值 [0.8, 0.19]<br>用户 9 的好友: [1], \t权重值 [0.97]<br><br>------------- Dijkstra 单源最短路径算法 --------------<br>各下标节点对应的前驱节点： [1, None, 4, 1, 6, 0, 1, 5, 7, 1] <br>------------- 源点 1 到其它各节点的最短路径 ----------<br>源点 1 到 0 的最短路径：1 -&gt; 0<br>源点 1 到 1 的最短路径：不存在<br>源点 1 到 2 的最短路径：1 -&gt; 6 -&gt; 4 -&gt; 2<br>源点 1 到 3 的最短路径：1 -&gt; 3<br>源点 1 到 4 的最短路径：1 -&gt; 6 -&gt; 4<br>源点 1 到 5 的最短路径：1 -&gt; 0 -&gt; 5<br>源点 1 到 6 的最短路径：1 -&gt; 6<br>源点 1 到 7 的最短路径：1 -&gt; 0 -&gt; 5 -&gt; 7<br>源点 1 到 8 的最短路径：1 -&gt; 0 -&gt; 5 -&gt; 7 -&gt; 8<br>源点 1 到 9 的最短路径：1 -&gt; 9","like_count":5},{"had_liked":false,"id":62776,"user_name":"caohuan","can_delete":false,"product_type":"c1","uid":1256428,"ip_address":"","ucode":"4B092E33F3DF1E","user_header":"https://static001.geekbang.org/account/avatar/00/13/2b/ec/af6d0b10.jpg","comment_is_top":false,"comment_ctime":1548154847,"is_pvip":false,"replies":[{"id":"22224","content":"你的建议很好，我后面会注意用更形象的方式来讲解。<br><br>至于边的权重，至少在目前的Dijkstra算法中，权重必须是正的。因为只有正的，我们才可以不去考虑已经进入F集合的结点。这个在证明过程中也提到了为什么。<br><br>一般地图搜索还是用Dijkstra偏多，当然也有一些优化的算法。<br><br>最后，我在后面两大模块讲解时，也会使用工作中实际的案例，加强学习的体验。","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1548192923,"ip_address":"","comment_id":62776,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18728024031","product_id":100021201,"comment_content":"黄老师 说的老长了，如果给我们讲个故事 听得会更有趣。<br>记得 《大话数据结构》里面有说到 广度优先和深度优先算法里，作者 用找东西的例子，广度优先是 到各个地方 比如每个房价 扫一眼，如果没有 再慢慢深入到角落，深度优先 就是 因为有个大概记忆，然后 跟随 记忆 从一个房间 比如抽屉开始 寻找，没有 再去最有可能的角落 找寻，所以 广度优先是 把所有的地方快速扫一眼，没有再慢慢进入小范围 区域，深度优先 就是去指定位置 寻找。<br>本篇的 Dikstra 大概可以理解：把计算好的节点放入黑箱里，有新的节点加入 只需要与 箱子 的节点连接，然后把新节点与箱子中临近的节点连接起来，计算新节点与临近节点的距离，更新最值，已有的节点间的距离不需要重复计算，总之 Dikstra算法 是没有重复的计算，所以效率会很高，总的计算量会少很多，不像深度优先算法 有大量重复的计算，广度优先算法在添加新节点 时 也会更新已有的计算。<br>所以Dijstra模块化的思想很节能，它包括 1.寻找MW的最小值或者最大值;2.update更新新节点时，再计算MW的最值。<br><br>回答老师的问题：问题一，权限值可以为正为负，例子：跑车游戏中，获胜方为规定时间内奔跑的路程最多，规则为 路线中有不同 奖励，其中有多增加时间的道路，也有减少跑车时间的路线，就是权限值 有正有负。<br>问题二：多条优先路线，照样可以运用Dijkstra算法，把 多条路线 同时与接入 新节点，然后计算距离，算出MW的值。<br><br>有个问题 请教老师：一般地图搜索场景使用Dijkstra多一点还是 动态规划多一点，还是其他算法，地图可以用 百度地图、Google地图 举例。<br><br>老师 在专栏里 会谈到 机器学习算法 在生活和产品中的运用吗?","like_count":4,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437346,"discussion_content":"你的建议很好，我后面会注意用更形象的方式来讲解。\n\n至于边的权重，至少在目前的Dijkstra算法中，权重必须是正的。因为只有正的，我们才可以不去考虑已经进入F集合的结点。这个在证明过程中也提到了为什么。\n\n一般地图搜索还是用Dijkstra偏多，当然也有一些优化的算法。\n\n最后，我在后面两大模块讲解时，也会使用工作中实际的案例，加强学习的体验。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548192923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":197258,"user_name":"拉普达","can_delete":false,"product_type":"c1","uid":1930686,"ip_address":"","ucode":"0E524C0D99B2A0","user_header":"https://static001.geekbang.org/account/avatar/00/1d/75/be/6f3ab95e.jpg","comment_is_top":false,"comment_ctime":1585365779,"is_pvip":false,"replies":[{"id":"75055","content":"我理解留言里说的是所有的边权重都加上一个值，让所有权重的数值往坐标轴右移，直到没有负数。<br>第2点是可以的👍","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1585630453,"ip_address":"","comment_id":197258,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10175300371","product_id":100021201,"comment_content":"1.纯负数可以，否则不行。留言里那个所有权重加上最小负数绝对值的方法，没有考虑到路径中边的条数是不一样的。<br>2.如果有多条代价相等的最短路径，需要第二步修改，记录mw[y]=mw[x]+w(x，y)的解<br>","like_count":2,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489483,"discussion_content":"我理解留言里说的是所有的边权重都加上一个值，让所有权重的数值往坐标轴右移，直到没有负数。\n第2点是可以的👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585630453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231420,"user_name":"跳刀躲梅肯","can_delete":false,"product_type":"c1","uid":2018673,"ip_address":"","ucode":"9221F2DF3DDAF1","user_header":"","comment_is_top":false,"comment_ctime":1593673021,"is_pvip":false,"replies":[{"id":"86119","content":"确实是，因为车票是单调递增的，而不是递减，如果边上的权重都是负的，那么才能求最大值。我让编辑帮忙修改","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1594312879,"ip_address":"","comment_id":231420,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5888640317","product_id":100021201,"comment_content":"文章最后这段话，”有的时候，边的权重越大越好，比如观光车开过某条路线的车票收入。对于这种情况，Dijkstra 算法就需要调整一下，每次找到最大的 mw，更新邻近结点时也要找更大的值“，应该是有问题的，Dijkstra算法不能用于求最长路径。 ","like_count":1,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500294,"discussion_content":"确实是，因为车票是单调递增的，而不是递减，如果边上的权重都是负的，那么才能求最大值。我让编辑帮忙修改","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594312879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203695,"user_name":"罗耀龙@坐忘","can_delete":false,"product_type":"c1","uid":1917663,"ip_address":"","ucode":"3CEA258DE7F3C7","user_header":"https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg","comment_is_top":false,"comment_ctime":1586255403,"is_pvip":true,"discussion_count":2,"race_medal":5,"score":"5881222699","product_id":100021201,"comment_content":"茶艺师学编程<br><br>今天的主角，正是Dijkstra算法<br><br>思考题1：如果边的权重是负数，还能用Dijkstra 算法吗？<br><br>本来在计算的图是有向图，点到点是有方向的，那么负的边权重是什么意思?是向着相反方向走一段距离吗？但落地的点是不存在原来的图上的哦?到这时，算法就不能用了。<br><br>思考题2：如果地图中存在多条最优路径，也就是说多条路径的权重和都是相等的，那么Dijkstra 算法应该如何修改呢？<br><br>既然是相等的，那在选择候选项时限定数量。比如有10个候选的权重都是一样的，只要选其中的几个（看情况）输出为结果就好了。","like_count":1,"discussions":[{"author":{"id":1524357,"avatar":"","nickname":"杨阳","note":"","ucode":"D838AFD9800E75","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307625,"discussion_content":"手动狗头","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600700213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1524357,"avatar":"","nickname":"杨阳","note":"","ucode":"D838AFD9800E75","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307624,"discussion_content":"茶艺师的意思是品茶，PC= 女票女昌，翻译过来就是嫖客学编程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600700202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":352852,"user_name":"013923","can_delete":false,"product_type":"c1","uid":3035193,"ip_address":"北京","ucode":"1214DAADBCA848","user_header":"","comment_is_top":false,"comment_ctime":1658981522,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658981522","product_id":100021201,"comment_content":"谢谢！","like_count":0},{"had_liked":false,"id":297667,"user_name":"张祈璟","can_delete":false,"product_type":"c1","uid":1400950,"ip_address":"","ucode":"DC7DDB3881633F","user_header":"https://static001.geekbang.org/account/avatar/00/15/60/76/be584def.jpg","comment_is_top":false,"comment_ctime":1623720972,"is_pvip":false,"replies":[{"id":"108260","content":"是的","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1624026683,"ip_address":"","comment_id":297667,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1623720972","product_id":100021201,"comment_content":"Dijkstra算法提出的最重要的一点：如果存在一个结点x，到它周边的所有结点中存在一个最小权值的点y，这个点x到点y的最优路径必是该路径。 不可能还存在其他x到y的最小路径，原因是其他的路径在一开始已经大于了该路径。","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521899,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624026683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":297275,"user_name":"cheers !🍻","can_delete":false,"product_type":"c1","uid":2531505,"ip_address":"","ucode":"6A57DF550FF6ED","user_header":"https://static001.geekbang.org/account/avatar/00/26/a0/b1/53930aa1.jpg","comment_is_top":false,"comment_ctime":1623401783,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623401783","product_id":100021201,"comment_content":"思考1：负数就不能用Dijkstra算法了，而且我感觉Dijkstra算方法并不是贪心，因为贪心是只会获取当前情况的最优解，但是Dijkstra是可以求出整体最优解的，另外Dijkstra本身也是动态规划。<br>思考2：如果有多跳相同权重的结果，要看是什么需求了，如果需求只要一条权重最少的解那就直接返回并阻断搜索就好了，如果想得出最优解数组，那就在放入最优解数组时做比较判断，如果是当前最优-加入数组，不过是更有解那就清楚数组放入最优解，然后遍历所有路径返回数组","like_count":0},{"had_liked":false,"id":230154,"user_name":"Geek_13e8db","can_delete":false,"product_type":"c1","uid":2046639,"ip_address":"","ucode":"3E214016FC2862","user_header":"","comment_is_top":false,"comment_ctime":1593285857,"is_pvip":false,"replies":[{"id":"85070","content":"对，这样描述更准确","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1593404320,"ip_address":"","comment_id":230154,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593285857","product_id":100021201,"comment_content":"“第三，假设结点 s 能直接到达的边集合为 M，对于其中的每一条边 m，则把 mw[m]设为 w[s, m]”<br>我认为这里应该将“每一条边m”，改为“每一个对端节点m”","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499787,"discussion_content":"对，这样描述更准确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593404320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188962,"user_name":"喻茂","can_delete":false,"product_type":"c1","uid":1318661,"ip_address":"","ucode":"C8BD8086A17365","user_header":"https://static001.geekbang.org/account/avatar/00/14/1f/05/8a06692e.jpg","comment_is_top":false,"comment_ctime":1584439787,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584439787","product_id":100021201,"comment_content":"<br>$nodesArr = [];&#47;&#47; 节点列表<br>$nodeNum = 100;<br>$relation_num = 1000;<br>&#47;&#47; 生成100个用户<br>for($i=0;$i&lt;$nodeNum;$i++) {<br>\t$nodesArr[$i] = new Node($i);<br>}<br>&#47;&#47; 随机生成各边权重和相邻关系<br>for($i=0;$i&lt;$relation_num;$i++) {<br>\t$nodeIdA = mt_rand(0,$nodeNum-1);<br>\t$nodeIdB = mt_rand(0,$nodeNum-1);<br>\t<br>\tif ($nodeIdA == $nodeIdB) { &#47;&#47; 相同节点没必要建立相邻关系<br>\t\tcontinue;<br>\t}<br>\t$weight = mt_rand(1,1000); &#47;&#47; 随机生成权重<br>\t$adjacent = $nodesArr[$nodeIdA]-&gt;adjacent;<br>\tif (!empty($adjacent[$nodeIdB])) { &#47;&#47; a b已经建立相邻关系<br>\t\tcontinue;<br>\t}<br>\t$nodesArr[$nodeIdA]-&gt;adjacent[$nodeIdB] = $weight;<br>}<br><br>getMinWeightRoute($nodesArr,10,20);","like_count":0},{"had_liked":false,"id":188961,"user_name":"喻茂","can_delete":false,"product_type":"c1","uid":1318661,"ip_address":"","ucode":"C8BD8086A17365","user_header":"https://static001.geekbang.org/account/avatar/00/14/1f/05/8a06692e.jpg","comment_is_top":false,"comment_ctime":1584439775,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584439775","product_id":100021201,"comment_content":"&#47;&#47; 选择权重最小的mv<br>function findGeoWithMinWeight($weightAll,&amp;$findedNodeArr){<br>\t$nodeIdMin = -1;<br>\t$weightMin = -1;<br>\tforeach ($weightAll as $nodeId=&gt;$weightAllOne) {<br>\t\tif (in_array($nodeId,$findedNodeArr)) { &#47;&#47; 当前节点已经被选择过<br>\t\t\tcontinue;<br>\t\t}<br>\t\tif ($weightMin == -1 || $weightAllOne &lt; $weightMin) {<br>\t\t\t$weightMin = $weightAllOne;<br>\t\t\t$nodeIdMin = $nodeId;<br>\t\t}<br>\t}<br>\t$findedNodeArr[] = $nodeIdMin;&#47;&#47; 添加到已经被选择列表<br>\treturn $nodeIdMin;<br>\t<br>} <br><br>&#47;&#47; 找出从nodeIdA到nodeIdB的权重最小路径和权重值<br>function getMinWeightRoute($nodesArr,$nodeIdA,$nodeIdB) {<br>\tif(empty($nodesArr[$nodeIdA]) || empty($nodesArr[$nodeIdB])) { &#47;&#47; 节点a或者b不存在<br>\t\techo &quot;节点a或者b不存在&lt;br&gt;&quot;;<br>\t\treturn;<br>\t}<br>\t<br>\t$findedNodeArr = []; &#47;&#47; 已经处理过的节点<br>\t$nodesArr[$nodeIdA]-&gt;weightAll[$nodeIdA] = 0; &#47;&#47; 到自己本身的权重为0<br>\t$nodesArr[$nodeIdA]-&gt;routeArr[$nodeIdA] = &quot;&quot;;<br>\t&#47;&#47; $findedNodeArr[] = $nodeIdA;<br>\twhile (true) {<br>\t\t$nodeIdMin = findGeoWithMinWeight($nodesArr[$nodeIdA]-&gt;weightAll,$findedNodeArr);&#47;&#47; 取出最小权重节点，并加入到已经取出列表<br>\t\tif ($nodeIdMin == -1) { &#47;&#47; 所有节点已经遍历完毕<br>\t\t\tbreak;<br>\t\t}<br>\t\t$undealNodeArr = $nodesArr[$nodeIdMin]-&gt;adjacent;&#47;&#47; 查找最小节点的相邻节点<br>\t\tforeach ($undealNodeArr as $curNodeId=&gt;$curNodeWeight) {<br>\t\t\t&#47;&#47; 如果到当前子节点curNodeId还没有权重，<br>\t\t\t&#47;&#47; 或者权重大于他到当前节点curDealnodeId权重+当前节点curDealnodeId到本相邻节点curNodeId<br>\t\t\t&#47;&#47; 需要更新nodeIdA到curNodeId节点的权重和路径<br>\t\t\tif (empty($nodesArr[$nodeIdA]-&gt;weightAll[$curNodeId]) || <br>\t\t\t($nodesArr[$nodeIdA]-&gt;weightAll[$curNodeId] &gt; <br>\t\t\t$nodesArr[$nodeIdA]-&gt;weightAll[$nodeIdMin] + $curNodeWeight) ) {<br>\t\t\t\t$nodesArr[$nodeIdA]-&gt;weightAll[$curNodeId] = <br>\t\t\t\t\t$nodesArr[$nodeIdA]-&gt;weightAll[$nodeIdMin] + $curNodeWeight;<br>\t\t\t\t$nodesArr[$nodeIdA]-&gt;routeArr[$curNodeId] = <br>\t\t\t\t\t$nodesArr[$nodeIdA]-&gt;routeArr[$nodeIdMin] . &#39;,&#39;.$curNodeId;<br>\t\t\t}\t\t\t\t<br>\t\t}<br>\t}<br>\t<br>\t&#47;&#47; 打印出a到b之间的权重和路径<br>\tif (!empty($nodesArr[$nodeIdA]-&gt;weightAll[$nodeIdB])) {<br>\t\techo &quot;节点{$nodeIdA}和节点{$nodeIdB}最小权重为：&quot;.$nodesArr[$nodeIdA]-&gt;weightAll[$nodeIdB].&quot;&lt;br&gt;&quot;;<br>\t\techo &quot;路径为:&quot;.$nodesArr[$nodeIdA]-&gt;routeArr[$nodeIdB];<br>\t\t<br>\t} else {<br>\t\techo &quot;节点{$nodeIdA}和节点{$nodeIdB}没有联通&quot;;<br>\t}<br>\t<br>}","like_count":0},{"had_liked":false,"id":188959,"user_name":"喻茂","can_delete":false,"product_type":"c1","uid":1318661,"ip_address":"","ucode":"C8BD8086A17365","user_header":"https://static001.geekbang.org/account/avatar/00/14/1f/05/8a06692e.jpg","comment_is_top":false,"comment_ctime":1584439762,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584439762","product_id":100021201,"comment_content":"php示例<br>&lt;?php<br>&#47;&#47; 用户节点相关类<br>class Node {<br>\tpublic $nodeId;&#47;&#47; 节点id<br>\tpublic $adjacent = []; &#47;&#47; 相邻节点id和权重<br>\tpublic $weightAll;&#47;&#47; 与所有节点之间的权重<br>\tpublic $routeArr = []; &#47;&#47; 与所有节点之间的权重最小路径<br>\tpublic function __construct($nodeId) {<br>\t\t$this-&gt;nodeId = $nodeId;<br>\t}<br>}","like_count":0},{"had_liked":false,"id":172934,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1579361307,"is_pvip":false,"replies":[{"id":"67097","content":"如果有负数是不能直接相加的","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1579407054,"ip_address":"","comment_id":172934,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1579361307","product_id":100021201,"comment_content":"思考题1：<br>如果边的权重是负数，运用Dijksta算法得到是任意两个点之间的最大距离，因为负数比较时，绝对值越大则其值越小，因此算法运行后，两个点之间距离的绝对值是这两个点的最大距离。<br><br>思考题2：<br>存在多条路径情况下，算法修改如下：<br>(1)增加一个一维数组，path，存贮从源点到各个节点的最优路径数，path[i]，即表示从源点S到节点i的最优路径数，除源节点path[s]=1外，其余各个节点的路径数都初始化为0。<br>(2)每当新加入一个节点i，则path[i]的值加1。<br>(3)每当新加入一个节点i，除了更新权重数组MW，还要对F集合中的节点进行检查，对于F中的某个节点k，如果有mw[i] + mw[i,k] = mw[k]，则说明从源点S到节点k至少存在着两条最优权重的路径，因此path[k]也要加1<br><br>最后path数组中即为源点到各节点的最优路径数。","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481906,"discussion_content":"如果有负数是不能直接相加的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579407054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167998,"user_name":"cwtxz","can_delete":false,"product_type":"c1","uid":1778151,"ip_address":"","ucode":"4F35AEDB8F5D5D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BAuQlia9Dc07m3icOkibIqu2lhbnLD6cjgCNE8FSzG5Aj4cd26eRgspicTsWvA7WK1ftlQBD34PYRucZRXML5FA27A/132","comment_is_top":false,"comment_ctime":1577973659,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577973659","product_id":100021201,"comment_content":"通过对《程序员的数学基础课》为期两周左右的系统性学习。大致理解了程序员学习数学的作用。那就是从最根本的思维方式来革新自己的编程手段，让你脱离重复而机械性的code，能从更宏观的层面来处理编程问题，成为一个thinker。让你从被业务驱动到驱动业务，这是根本性的改变。说得再直白来，就是让你能更快、更有效地完成工作，更随心所欲地驾驭编程这件事儿。总之，我已经有所领悟，数学，作为工具，很强大，其指导思维，很有用，所以，加油，争取再上一层楼！！！","like_count":0},{"had_liked":false,"id":146439,"user_name":"南边","can_delete":false,"product_type":"c1","uid":1504736,"ip_address":"","ucode":"7967C01AAB4A70","user_header":"https://static001.geekbang.org/account/avatar/00/16/f5/e0/76822dd9.jpg","comment_is_top":false,"comment_ctime":1572524135,"is_pvip":false,"replies":[{"id":"56573","content":"很细致的点👍","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1572545677,"ip_address":"","comment_id":146439,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572524135","product_id":100021201,"comment_content":"有一个地方需要注意一下，应该有两个mw的映射，一个是findGeoWithMinWeight用的（这是个临时映射tempMw），用完了需要把找到的最小mw移除tempMw映射，否则findGeoWithMinWeight永远都只能找到那个固定的最小值（例子里是c点），另一个是已确定的mw映射（是结果映射resultMw），在updateWeight时候需要获取上一步的最小总权重值和更新到已确定的resultMw映射中","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472862,"discussion_content":"很细致的点👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572545677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128505,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1566891332,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566891332","product_id":100021201,"comment_content":"总结<br>广度优先：按照队列逐渐发现未知的点，遍历的顺序按照和源顶点的边数从小到大遍历。<br>深度优先：按照栈逐渐发现未知的点，遍历的顺序类似于树的后序遍历，先深入腹地，逐级后退。<br>最小距离遍历：按照距离的堆逐渐发现未知的点，遍历的顺序安装距离单调递增遍历所有点。","like_count":0},{"had_liked":false,"id":128220,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1566864454,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566864454","product_id":100021201,"comment_content":"思考题2<br>对于存在相同距离的情况下，更新权重的时候只更新距离减小的情况，选择最小的时候，最小的有多个，随便选一个就好。","like_count":0},{"had_liked":false,"id":128182,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1566857316,"is_pvip":false,"replies":[{"id":"47733","content":"没错","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1566935811,"ip_address":"","comment_id":128182,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566857316","product_id":100021201,"comment_content":"思考题1<br>边如果有负数，这个方法就不可用了，因为这个方法在证明的时候用了增强归纳，也就是第k远的点必定经过前k-1远的节点外加一条边，一旦引入负数边以后，这点就不成立了，因为完全可以用k-1远的节点外加n条边。<br>这个方法之所以能成立，用到了一个隐含假设，可达的所有顶点中，存在边数最短的点距离距离也最短，其他点的距离是通过距离较短的点计算出来的。","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464829,"discussion_content":"没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566935811,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109718,"user_name":"钠镁铝硅磷😒","can_delete":false,"product_type":"c1","uid":1575196,"ip_address":"","ucode":"40B91112F1F969","user_header":"https://static001.geekbang.org/account/avatar/00/18/09/1c/40a47446.jpg","comment_is_top":false,"comment_ctime":1562081714,"is_pvip":false,"replies":[{"id":"39813","content":"很高兴这个专栏对你有用","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1562136768,"ip_address":"","comment_id":109718,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562081714","product_id":100021201,"comment_content":"之前看过好几次dijkstra的文章，但是每次都感觉只是一知半解，过会又忘了，看完老师的这篇文章，算是真正弄明白了dijkstra算法的原理，给老师点个赞！<br>除了地图导航之外，在网络中路由表的生成使用的也是dijkstra算法。","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456535,"discussion_content":"很高兴这个专栏对你有用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562136768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87335,"user_name":"tangerine","can_delete":false,"product_type":"c1","uid":1243792,"ip_address":"","ucode":"95049C171751E7","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/90/159a8b89.jpg","comment_is_top":false,"comment_ctime":1555570787,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555570787","product_id":100021201,"comment_content":"caohuan 同学的脑子很乱， 要多看问题，多思考一些严谨的思路， 沉下心来!  老师来龙去脉说的很清楚!","like_count":0},{"had_liked":false,"id":63535,"user_name":"会飞的猪","can_delete":false,"product_type":"c1","uid":1340194,"ip_address":"","ucode":"05EB9BF31F603D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIEONynt1pibq4AInxllIgSz3zJrB4tiabJwibYAohfcGTvScicboZkM03Wgic4dA4H1obcyAm9nbGR4pA/132","comment_is_top":false,"comment_ctime":1548394805,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548394805","product_id":100021201,"comment_content":"a=node(&#39;a&#39;,{&#39;b&#39;:0.2,&#39;c&#39;:0.3})<br>b=node(&#39;b&#39;,{&#39;d&#39;:0.2,&#39;f&#39;:0.3})<br>c=node(&#39;c&#39;,{&#39;d&#39;:0.4,&#39;e&#39;:0.1})<br>d=node(&#39;d&#39;,{&#39;e&#39;:0.3})<br>e=node(&#39;e&#39;,{&#39;f&#39;:0.2})<br>f=node(&#39;f&#39;,{})<br>mw={}<br>lastMw={}<br>nolist={&#39;a&#39;:a,&#39;b&#39;:b,&#39;c&#39;:c,&#39;d&#39;:d,&#39;e&#39;:e,&#39;f&#39;:f}<br>def getLastNode(mw,lastMw):<br>    last=min(mw, key=mw.get)<br>    print(&#39;获取到mw最小值&#39;,last)<br>    lastMw[last]=mw[last]<br><br>    for k,v in nolist[last].son.items():<br>        newMw=v+mw[last]<br>        if k in mw:<br>            if newMw&lt;mw[k]:<br>                mw[k]=newMw<br>        else:<br>            mw[k] = newMw<br>    mw.pop(last)<br><br>    if mw:<br>        getLastNode(mw,lastMw)<br>    return lastMw<br>acc=getLastNode(a.son,lastMw)<br>print(acc)<br>结果输出：<br>获取到mw最小值 b<br>获取到mw最小值 c<br>获取到mw最小值 d<br>获取到mw最小值 e<br>获取到mw最小值 f<br>{&#39;b&#39;: 0.2, &#39;c&#39;: 0.3, &#39;d&#39;: 0.4, &#39;e&#39;: 0.4, &#39;f&#39;: 0.5}","like_count":0},{"had_liked":false,"id":62262,"user_name":"菩提","can_delete":false,"product_type":"c1","uid":1309278,"ip_address":"","ucode":"19586AC50BEF1E","user_header":"","comment_is_top":false,"comment_ctime":1547997717,"is_pvip":false,"replies":[{"id":"22015","content":"细节注意的很好，点赞👍","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1548008087,"ip_address":"","comment_id":62262,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1547997717","product_id":100021201,"comment_content":"&#47;&#47; 执行测试<br>\tpublic static void main(String[] args) {<br>\t\tNode tree = init();<br>\t\tMap&lt;String, Double&gt; mw = new HashMap&lt;&gt;();<br>\t\tMap&lt;String, Double&gt; result_mw = new HashMap&lt;&gt;();<br><br>\t\tList&lt;Node&gt; children = tree.children;<br>\t\tMap&lt;String, Double&gt; weights = tree.weights;<br>\t\tfor (Map.Entry&lt;String, Double&gt; entry : weights.entrySet()) {<br>\t\t\tmw.put(entry.getKey(), entry.getValue());<br>\t\t}<br><br>\t\twhile (mw.size() != 0) {<br>\t\t\tString label = findGeoWithMinWeight(mw);<br>\t\t\tupdateWeight(label, mw.get(label), result_mw);<br>\t\t\tNode min = getMinNode(children, label);<br>\t\t\tSystem.out.println(&quot;获取最小值：&quot; + label);<br>\t\t\tList&lt;Node&gt; nodes = min.children;<br>\t\t\tif (nodes != null &amp;&amp; nodes.size() &gt; 0) {<br>\t\t\t\tchildren.addAll(nodes);<br>\t\t\t\tfor (Node node : nodes) {<br>\t\t\t\t\tmw.put(node.label, BigDecimal.valueOf(result_mw.get(label))<br>\t\t\t\t\t\t\t.add(BigDecimal.valueOf(min.weights.get(node.label))).doubleValue());<br>\t\t\t\t}<br>\t\t\t}<br>\t\t\tmw.remove(label);<br>\t\t}<br><br>\t\tSystem.out.println(result_mw);<br>\t}<br>}<br><br>运行结果如下：<br>获取最小值：c<br>获取最小值：b<br>获取最小值：d<br>获取最小值：f<br>获取最小值：a<br>获取最小值：c<br>获取最小值：f<br>获取最小值：e<br>获取最小值：g<br>获取最小值：h<br>获取最小值：g<br>{a=0.5, b=0.3, c=0.2, d=0.4, e=0.5, f=0.4, g=0.6, h=0.6}","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437151,"discussion_content":"细节注意的很好，点赞👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548008087,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":62261,"user_name":"菩提","can_delete":false,"product_type":"c1","uid":1309278,"ip_address":"","ucode":"19586AC50BEF1E","user_header":"","comment_is_top":false,"comment_ctime":1547997645,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547997645","product_id":100021201,"comment_content":"children = new ArrayList&lt;&gt;();<br>\t\tchildren.add(e);<br>\t\tchildren.add(h);<br>\t\tweights = new HashMap&lt;&gt;();<br>\t\tweights.put(&quot;e&quot;, 0.1);<br>\t\tweights.put(&quot;h&quot;, 0.2);<br>\t\tf.children = children;<br>\t\tf.weights = weights;<br><br>\t\tchildren = new ArrayList&lt;&gt;();<br>\t\tchildren.add(g);<br>\t\tweights = new HashMap&lt;&gt;();<br>\t\tweights.put(&quot;g&quot;, 0.4);<br>\t\th.children = children;<br>\t\th.weights = weights;<br><br>\t\treturn start;<br>\t}<br><br>children = new ArrayList&lt;&gt;();<br>\t\tchildren.add(e);<br>\t\tchildren.add(h);<br>\t\tweights = new HashMap&lt;&gt;();<br>\t\tweights.put(&quot;e&quot;, 0.1);<br>\t\tweights.put(&quot;h&quot;, 0.2);<br>\t\tf.children = children;<br>\t\tf.weights = weights;<br><br>\t\tchildren = new ArrayList&lt;&gt;();<br>\t\tchildren.add(g);<br>\t\tweights = new HashMap&lt;&gt;();<br>\t\tweights.put(&quot;g&quot;, 0.4);<br>\t\th.children = children;<br>\t\th.weights = weights;<br><br>\t\treturn start;<br>\t}<br><br>\t&#47;&#47; 获取最小权重<br>\tpublic static String findGeoWithMinWeight(Map&lt;String, Double&gt; mw) {<br>\t\tdouble min = Double.MAX_VALUE;<br>\t\tString label = &quot;&quot;;<br>\t\tfor (Map.Entry&lt;String, Double&gt; entry : mw.entrySet()) {<br>\t\t\tif (entry.getValue() &lt; min) {<br>\t\t\t\tmin = entry.getValue();<br>\t\t\t\tlabel = entry.getKey();<br>\t\t\t}<br>\t\t}<br>\t\treturn label;<br>\t}<br><br>\t&#47;&#47; 更新权重<br>\tpublic static void updateWeight(String key, Double value, Map&lt;String, Double&gt; result_mw) {<br>\t\tif (result_mw.containsKey(key)) {<br>\t\t\tif (value &lt; result_mw.get(key)) {<br>\t\t\t\tresult_mw.put(key, value);<br>\t\t\t}<br>\t\t} else {<br>\t\t\tresult_mw.put(key, value);<br>\t\t}<br>\t}<br><br>\t&#47;&#47; 获取最小节点<br>\tpublic static Node getMinNode(List&lt;Node&gt; l, String label) {<br>\t\tfor (Node node : l) {<br>\t\t\tif (label.equals(node.label)) {<br>\t\t\t\treturn node;<br>\t\t\t}<br>\t\t}<br>\t\treturn null;<br>\t}","like_count":0},{"had_liked":false,"id":62260,"user_name":"菩提","can_delete":false,"product_type":"c1","uid":1309278,"ip_address":"","ucode":"19586AC50BEF1E","user_header":"","comment_is_top":false,"comment_ctime":1547997549,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547997549","product_id":100021201,"comment_content":"1.思考题，如果权重为负数，Dijkstra算法的方式就不能用了。您在文中也提到了，每次取到最小的mw，如果后面出现负数，那前面的权重就不能保证最小了。如果存在多条最优路径，则应该加一个字段记录节点从开始到结束的轨迹。如果权重有多个最优解，则运行轨迹才是需要求解的结果，而不是权重。<br><br>2.我将您讲解的推导过程用代码实现了，为了避免小数位数计算导致的精度问题，先转为BigDecimal，再转成了double.由于留言区字数限制，我分开进行提交。<br>public class Lesson15 {<br><br>\t&#47;&#47; 定义节点<br>\tstatic class Node {<br>\t\tpublic String label;<br>\t\tpublic List&lt;Node&gt; children;<br>\t\tpublic Map&lt;String, Double&gt; weights;<br><br>\t\tpublic Node(String label) {<br>\t\t\tthis.label = label;<br>\t\t}<br>\t}<br><br>\t&#47;&#47; 初始化<br>\tpublic static Node init() {<br>\t\tNode start = new Node(&quot;s&quot;);<br>\t\tNode a = new Node(&quot;a&quot;);<br>\t\tNode b = new Node(&quot;b&quot;);<br>\t\tNode c = new Node(&quot;c&quot;);<br>\t\tNode d = new Node(&quot;d&quot;);<br>\t\tNode e = new Node(&quot;e&quot;);<br>\t\tNode f = new Node(&quot;f&quot;);<br>\t\tNode g = new Node(&quot;g&quot;);<br>\t\tNode h = new Node(&quot;h&quot;);<br><br>\t\tList&lt;Node&gt; children = new ArrayList&lt;&gt;();<br>\t\tchildren.add(a);<br>\t\tchildren.add(b);<br>\t\tchildren.add(c);<br>\t\tchildren.add(d);<br>\t\tMap&lt;String, Double&gt; weights = new HashMap&lt;&gt;();<br>\t\tweights.put(&quot;a&quot;, 0.5);<br>\t\tweights.put(&quot;b&quot;, 0.3);<br>\t\tweights.put(&quot;c&quot;, 0.2);<br>\t\tweights.put(&quot;d&quot;, 0.4);<br>\t\tstart.children = children;<br>\t\tstart.weights = weights;<br><br>\t\tchildren = new ArrayList&lt;&gt;();<br>\t\tchildren.add(e);<br>\t\tweights = new HashMap&lt;&gt;();<br>\t\tweights.put(&quot;e&quot;, 0.3);<br>\t\ta.children = children;<br>\t\ta.weights = weights;<br><br>\t\tchildren = new ArrayList&lt;&gt;();<br>\t\tchildren.add(a);<br>\t\tchildren.add(f);<br>\t\tweights = new HashMap&lt;&gt;();<br>\t\tweights.put(&quot;a&quot;, 0.2);<br>\t\tweights.put(&quot;f&quot;, 0.1);<br>\t\tb.children = children;<br>\t\tb.weights = weights;<br><br>\t\tchildren = new ArrayList&lt;&gt;();<br>\t\tchildren.add(f);<br>\t\tchildren.add(h);<br>\t\tweights = new HashMap&lt;&gt;();<br>\t\tweights.put(&quot;f&quot;, 0.4);<br>\t\tweights.put(&quot;h&quot;, 0.8);<br>\t\tc.children = children;<br>\t\tc.weights = weights;<br><br>\t\tchildren = new ArrayList&lt;&gt;();<br>\t\tchildren.add(c);<br>\t\tchildren.add(h);<br>\t\tweights = new HashMap&lt;&gt;();<br>\t\tweights.put(&quot;c&quot;, 0.1);<br>\t\tweights.put(&quot;h&quot;, 0.6);<br>\t\td.children = children;<br>\t\td.weights = weights;<br><br>\t\tchildren = new ArrayList&lt;&gt;();<br>\t\tchildren.add(g);<br>\t\tweights = new HashMap&lt;&gt;();<br>\t\tweights.put(&quot;g&quot;, 0.1);<br>\t\te.children = children;<br>\t\te.weights = weights;","like_count":0},{"had_liked":false,"id":61494,"user_name":"strentchRise","can_delete":false,"product_type":"c1","uid":1230610,"ip_address":"","ucode":"4F0E86DD5C9A97","user_header":"https://static001.geekbang.org/account/avatar/00/12/c7/12/4158bfdc.jpg","comment_is_top":false,"comment_ctime":1547707719,"is_pvip":false,"replies":[{"id":"21875","content":"我理解你说的递归分治是深度优先搜索？如果是这样，也是可以的，但是某个结点会被访问多次，效率不高。另外，当前结点的最小距离还是要缓存的，因为最终需要知道起始点到某个结点的最小距离","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1547752927,"ip_address":"","comment_id":61494,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1547707719","product_id":100021201,"comment_content":"第二张图，也就是基于距离的有向有权重的图，难道不可以用递归的分而治之来做么？<br>每次找出距离我最近的前方节点，这样似乎不用缓存到某节点的最小距离了吧？","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436888,"discussion_content":"我理解你说的递归分治是深度优先搜索？如果是这样，也是可以的，但是某个结点会被访问多次，效率不高。另外，当前结点的最小距离还是要缓存的，因为最终需要知道起始点到某个结点的最小距离","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547752927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}