{"id":693540,"title":"07｜类加载子系统（下）：如何打造一个属于你的类加载器？","content":"<p>你好，我是康杨。</p><p>上节课我们学习了JVM中的类加载流程和机制，接下来我们一起来执行这个流程的类加载器。在这个过程中，你将了解到JVM中的类加载器家族及其在最新的JVM版本中的演进。最后我还会带你打造一个专属于你自己的自定义类加载器，它可以帮助你更好地管理和使用Java应用程序，提高可靠性和安全性，并满足我们的特定需求。</p><h2>类加载器家族</h2><p><img src=\"https://static001.geekbang.org/resource/image/f1/12/f1063a739064846562ec04d1a9059e12.png?wh=1920x1173\" alt=\"图片\"></p><p>JVM中的类加载器家族有5个成员，下面我们就来一个个看。</p><h3>启动类加载器（Bootstrap ClassLoader）</h3><p>这是所有类加载器中唯一一个用C++代码实现的，没有对应的类，也是JVM 实现的一部分，主要负责加载Java 核心库。</p><h3>扩展类加载器（Extension ClassLoader）</h3><p>扩展类加载器负责加载的目录是 jre/lib/ext，这个目录下的具体文件和类库实际上会因 Java 版本和平台的不同而不同。例如，在 Windows 系统的 Oracle JDK 8 中，通常你可以找到access-bridge-64.jar、cldrdata.jar等文件。</p><p>这些文件里主要是Java的扩展类库，包括各种IO、网络协议、加密、字符集支持等等。然而在部分 Linux 发布版和 Docker 环境中，你可能发现 ext 目录是空的。</p><!-- [[[read_end]]] --><p>在Java 9及以后的版本中，由于引入了新的模块系统，这个机制发生了一些变化。JDK 9 之后的版本不再有 jre/lib/ext 这个路径，扩展类加载器也被平台类加载器（Platform ClassLoader）替代。</p><h3>应用类加载器（Application ClassLoader）</h3><p>应用类加载器应该是我们日常接触最多的类加载器，也是系统默认的类加载器，ClassLoader.getSystemClassLoader() 系统类加载器说的就是它，你可以直接使用。</p><p>应用类加载器主要从哪些路径加载呢？我整理在表格中了，你可以参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/69/b3/69a813c1e19251940afe27276d6267b3.jpg?wh=1920x849\" alt=\"图片\"></p><p>例如，如果我们编译一个名为 com.future.Food 的 Java 类，把它放在当前目录下名为 classes 的目录里，在命令行中，我们可以通过运行 <code>java -cp ./classes com.future.Food</code> 来加载和运行这个类。</p><p>当我们使用IDE（如Eclipse、IntelliJ IDEA等）开发Java应用程序的时候，IDE通常会自动设定CLASSPATH，这个 CLASSPATH 里有项目的bin或target（由构建工具如Maven、Gradle设定）目录以及所有的依赖库。</p><h2>自定义类加载器</h2><p>复杂的日常工作中会存在一些场景，没办法用上述的类加载器来完成类加载的工作，这时候我们可以根据业务需求来打造一个自定义类加载器，满足特定场景的定制化需求。</p><p>要想打造一个线上核心业务系统的自定义类加载器，需要遵循一些重要的设计原则。</p><p><img src=\"https://static001.geekbang.org/resource/image/1b/7e/1b13bce735b4e5e74a20a99dc8030f7e.jpg?wh=1920x560\" alt=\"图片\"></p><p>除了这些需要遵守的原则，你还需要注意规避几个常见的错误。首先在重写 loadClass() 方法的时候，要<strong>确保优先委托给父类加载器，<strong>否则，可能会导致类的重复加载和类版本不一致等问题。还有在自定义类加载器的实现中，需要</strong>对异常情况进行良好的处理</strong>，比如类未找到、读取文件错误等。这些异常一般需要抛出一个 java.lang.ClassNotFoundException，方便上层调用者进行相应的处理。</p><p>下面我实现了一个完整的实例，你可以参考下。</p><pre><code class=\"language-java\">import java.io.*;\nimport java.util.HashMap;\n// 自定义ClassLoader类，继承自ClassLoader\npublic class CustomClassLoader extends ClassLoader {\n    // 定义了类文件的根路径\n    private String rootDir;\n    // 缓存已经加载的类\n    private HashMap&lt;String, Class&lt;?&gt;&gt; loadedClasses;\n    \n    /**\n     * Constructor\n     * @param rootDir 类文件的根目录路径\n     */\n    public CustomClassLoader(String rootDir) {\n        this.rootDir = rootDir;\n        // 初始化缓存Hashmap\n        loadedClasses = new HashMap&lt;&gt;();\n    }\n    /**\n     * 加载类文件并返回Class实例\n     * @param className 类的全限定名\n     * @return 加载的类的Class实例\n     * @throws ClassNotFoundException 如果类未被找到或加载\n     */\n    @Override\n    protected Class&lt;?&gt; findClass(String className) throws ClassNotFoundException {\n        // 从已加载的类缓存中查找类\n        Class&lt;?&gt; loadedClass = loadedClasses.get(className);\n        // 如果类已经被加载，从缓存中返回\n        if (loadedClass != null) {\n            return loadedClass;\n        }\n        // 否则读取类文件的字节码\n        byte[] classBytes = getClassBytes(className);\n        if (classBytes == null) {\n            throw new ClassNotFoundException();\n        }\n        // 在锁定的环境中，定义类并将类放入已加载的类缓存中\n        synchronized (loadedClasses) {\n            loadedClass = defineClass(className, classBytes, 0, classBytes.length);\n            loadedClasses.put(className, loadedClass);\n        }\n        return loadedClass;\n    }\n    /**\n     * 根据类名读取类文件的字节码\n     * @param className 类的全名（包括包名）\n     * @return 类文件的字节码\n     */\n    private byte[] getClassBytes(String className) {\n        // 将全名转换为文件名\n        String classPath = rootDir + '/' +\n                className.replace('.', '/') + \".class\";\n        FileInputStream fis = null;\n        ByteArrayOutputStream baos = null;\n        try {\n            fis = new FileInputStream(classPath);\n            baos = new ByteArrayOutputStream();\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            // 循环读取文件直到文件结束\n            while ((bytesRead = fis.read(buffer)) != -1) {\n                baos.write(buffer, 0, bytesRead);\n            }\n            // 返回字节流的字节数组\n            return baos.toByteArray();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            // 关闭资源\n            try {\n                if (fis != null) {\n                    fis.close();\n                }\n                if (baos != null) {\n                    baos.close();\n                }\n            } catch (IOException e2) {\n                e2.printStackTrace();\n            }\n        }\n        return null;\n    }\n    public static void main(String[] args) {\n        // 创建新的CustomClassLoader实例\n        CustomClassLoader customClassLoader = new CustomClassLoader(\"/path/to/classes\");\n        try {\n            // 通过自定义的类加载器加载一个类，输出其类名\n            Class&lt;?&gt; sampleClass = customClassLoader.loadClass(\"com.example.SampleClass\");\n            System.out.println(\"Class loaded successfully: \" + sampleClass.getName());\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre><p>你可以动动手跟着我一起实现这个自定义的类加载器，欢迎你把你的代码分享到评论区。</p><h2>双亲委派模型</h2><p>双亲委派模型是JVM类加载器进行类加载时遵循的基本原则。当类加载器需要加载一个类时，它会先将加载请求委派给父类加载器，如果父类加载器能够加载成功，则直接返回加载的类。只有当父类加载器没办法加载的时候，才由当前类加载器尝试加载。</p><p>通过双亲委派模型，核心类库由启动类加载器加载，避免不可信的类对核心类库造成破坏。同时，通过这种有层次的类加载器结构，确保同一个类只会被加载一次，保证了类的一致性。</p><h3>核心流程</h3><ol>\n<li>类加载请求：当 Class.forName() 或ClassLoader.loadClass() 方法被调用时，类加载器会根据类的全限定名来加载类。</li>\n<li>委派给父类加载器：类加载器首先将加载请求委派给父类加载器进行处理。</li>\n<li>父类加载器处理：父类加载器按照相同的委派机制，将加载请求继续委派给其父类加载器，直至达到顶层的启动类加载器。</li>\n<li>加载类：如果父类加载器无法加载类，当前类加载器会尝试自己加载类。如果加载成功，就返回加载的 Class 对象；如果加载失败，将会抛出 ClassNotFoundException 异常。</li>\n</ol><p><img src=\"https://static001.geekbang.org/resource/image/95/bd/95f5377d57647438ce25073cdaab2cbd.png?wh=1920x1214\" alt=\"图片\"></p><h3>应用场景</h3><p>双亲委派模型主要应用于哪些场景呢？</p><ol>\n<li><strong>类加载隔离：</strong>通过使用不同的类加载器加载不同的类，实现类加载的隔离性，避免类之间的互相影响和冲突。</li>\n<li><strong>安全沙箱隔离</strong>通过自定义类加载器实现安全沙箱的机制，对不可信的类进行隔离加载和限制权限，提高系统的安全性。</li>\n<li><strong>动态扩展和插件化</strong>通过自定义类加载器实现动态加载和卸载功能，实现系统的动态扩展和插件化，提升程序的灵活性和可扩展性。</li>\n<li><strong>多版本隔离</strong>通过使用不同的类加载器加载不同版本的类，实现在同一个程序中使用不同版本的库文件，避免版本冲突。</li>\n</ol><h3>限制</h3><p>不过这个模型一旦决定了一个类被ClassLoader加载，那么它在运行期间就会一直保持被加载的状态，即使类的定义已经发生了变化也是如此，除非重新启动JVM。因此，这种模型限制了我们动态加载新类的能力。</p><p>这种限制的主要原因在于Java内存管理机制的设计。一旦类被加载，它的Class对象就会被ClassLoader持有并缓存起来，只有当ClassLoader、Class对象还有它所有的实例对象全部不可达的时候，GC才会回收这个类。</p><h3>Tomcat 为什么能够突破限制？</h3><p>Tomcat 使用自定义类加载器的方式突破了双亲委派模型的限制。它使用了共同的父加载器（common ClassLoader），隔离了不同的Web模块，使每个Web模块都有自己的类加载器。这样不同Web模块的类可以相互访问，而和父加载器无关。除了Tomcat，SPI机制也是突破双亲委派模型的典型场景，后面我们还会详细介绍。</p><h2>类加载器的演进</h2><p>随着JVM的迭代，在不同的 JDK 版本中，类加载器也在发生着变化。</p><p>从JDK 9开始，JVM 引入了新的模块系统JPMS（Java Platform Module System），将 Java 核心库分成了一系列的模块，每个模块只包含相关的功能，使得代码更加清晰和可维护。原本的引导类加载器也被拆分成了两个不同的加载器，分别是平台类加载器（Platform ClassLoader）和系统类加载器（System ClassLoader）。</p><p>而到了JDK 11，为了提高性能，JVM 使用类数据共享（CDS）技术，允许不同的 Java 进程共享相同的 JVM 类元数据。到JDK 17的时候，JVM 则是直接移除了系统类加载器，所有的类加载操作由原本的应用类加载器接管。这个改动简化了 JVM 架构，也减小潜在的安全风险。</p><h2>重点回顾</h2><p>今天我们介绍了JVM中的类加载器家族，包括引导类加载器、扩展类加载器和应用类加载器。引导类加载器负责加载Java核心库，扩展类加载器负责加载Java扩展库，应用类加载器是系统默认的类加载器。</p><p>除了系统提供的类加载器，我们还可以自定义类加载器来满足特定的业务需求。此外我们还介绍了双亲委派模型的原则，就是当类加载器需要加载一个类的时候，会先委派给父类加载器，只有父类加载器没办法加载的时候，才由当前类加载器加载。这个模型保证了核心类库的安全性和类的一致性。同时，我们还了解了类加载器的演进，在不同的JDK版本中，类加载器也有所变化，比如引入模块系统和类数据共享等。</p><h2>思考题</h2><ol>\n<li>为什么要使用双亲委派模型进行类加载？它的优势是什么？</li>\n<li>在JDK的演进过程中，类加载器发生了哪些变化？</li>\n</ol><p>欢迎你把答案分享到评论区，也欢迎你把这节课的内容分享给需要的朋友，邀请他们一起学习，我们下节课再见！</p><h2>💡 点亮你的知识框架图</h2><p><img src=\"https://static001.geekbang.org/resource/image/33/45/33d5f2cd5yy6a454a1629fc09d314945.jpg?wh=5476x3900\" alt=\"图片\"></p>","neighbors":{"left":{"article_title":"06｜类加载子系统 （上）：类加载的流程与机制","id":692897},"right":{"article_title":"08｜反射机制：给你一把打开JVM后门的钥匙","id":696610}},"comments":[{"had_liked":false,"id":381371,"user_name":"C.","can_delete":false,"product_type":"c1","uid":1444698,"ip_address":"江苏","ucode":"5AE269220EFD73","user_header":"https://static001.geekbang.org/account/avatar/00/16/0b/5a/453ad411.jpg","comment_is_top":false,"comment_ctime":1695113874,"is_pvip":false,"replies":[{"id":139131,"content":"比如，对于 Java 的模块化有更好的支持，系统类加载器在加载模块时可能存在映射关系混乱的情况，移除系统类加载器使得在模块间的加载关系上有更直接的管理，提高了模块化系统的安全性。提高了运行时性能，因为系统类加载器通常需要搜索本地文件系统上的多个路径，而应用类加载器可以从 JVM 类路径中更直接地寻找和加载类。 ","user_name":"作者回复","user_name_real":"编辑","uid":1366588,"ctime":1696514963,"ip_address":"北京","comment_id":381371,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"到 JDK 17 的时候，JVM 则是直接移除了系统类加载器，所有的类加载操作由原本的应用类加载器接管。这个改动简化了 JVM 架构，也减小潜在的安全风险。\n这个潜在风险是什么？","like_count":1,"discussions":[{"author":{"id":1366588,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/3c/6ca50139.jpg","nickname":"Arthur king 微信超級會員","note":"","ucode":"79637F55F0ED85","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629015,"discussion_content":"比如，对于 Java 的模块化有更好的支持，系统类加载器在加载模块时可能存在映射关系混乱的情况，移除系统类加载器使得在模块间的加载关系上有更直接的管理，提高了模块化系统的安全性。提高了运行时性能，因为系统类加载器通常需要搜索本地文件系统上的多个路径，而应用类加载器可以从 JVM 类路径中更直接地寻找和加载类。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1696514963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":381725,"user_name":"记得晚睡","can_delete":false,"product_type":"c1","uid":3720824,"ip_address":"北京","ucode":"C3DA9EDA2DBDB7","user_header":"https://static001.geekbang.org/account/avatar/00/38/c6/78/dc201b84.jpg","comment_is_top":false,"comment_ctime":1695739012,"is_pvip":false,"replies":[{"id":139123,"content":"比如那些名词呢，其实可以先有逻辑上整体的认知，然后逐个攻克","user_name":"作者回复","user_name_real":"编辑","uid":1366588,"ctime":1696512336,"ip_address":"北京","comment_id":381725,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"感觉很多名词都不懂是什么意思 很难理解","like_count":0,"discussions":[{"author":{"id":1366588,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/3c/6ca50139.jpg","nickname":"Arthur king 微信超級會員","note":"","ucode":"79637F55F0ED85","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629003,"discussion_content":"比如那些名词呢，其实可以先有逻辑上整体的认知，然后逐个攻克","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1696512336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":382896,"user_name":"王盛武","can_delete":false,"product_type":"c1","uid":1182516,"ip_address":"北京","ucode":"DE7EF246D3DCE8","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/34/f41d73a4.jpg","comment_is_top":false,"comment_ctime":1698156846,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"这样不同 Web 模块的类可以相互访问\n\n准确说是web模块能访问common lib目录的类。  web模块的类并不能相互访问","like_count":1},{"had_liked":false,"id":382200,"user_name":"Geek_320730","can_delete":false,"product_type":"c1","uid":3035552,"ip_address":"北京","ucode":"CF7E6C8E91D2C4","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/XWv3mvIFORNgRk9wF8QLb9aXfh1Uz1hADtUmlFwQJVxIzhBf8HWc4QqU7iaTzj8wB5p5QJLRAvlQNrOqXtrg1Og/132","comment_is_top":false,"comment_ctime":1696869873,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"示例文件直接运行，通过getClassLoader获取类的classLoader,获取的是AppClassLoader，并没有走定义的类加载器，此时debug也不会进入断点。然后删除编译后的SampleClass文件，使AppClassLoader不能正常加载类，再进行debug，就会进入断点，说明先在父类加载器AppClassLoader中加载，失败后，在使用当前自定义加载器。\n提供另一个实例：https:&#47;&#47;github.com&#47;kuifir&#47;practice&#47;blob&#47;master&#47;jvm-module&#47;src&#47;main&#47;java&#47;com&#47;kuifir&#47;classloader&#47;CompileClassLoader.java\n此实例可以加载没有class文件的目标类，当class文件存在的时候，ClassLoader为AppClassLoader，当class文件不存在时，ClassLoader为自定义类加载器。","like_count":0},{"had_liked":false,"id":381689,"user_name":"浩仔是程序员","can_delete":false,"product_type":"c1","uid":1104601,"ip_address":"广东","ucode":"A7E5CF9E1571A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/d9/f051962f.jpg","comment_is_top":false,"comment_ctime":1695690989,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"老师，普通的应用中有什么场景可以用到自定义类加载器吗？如果我想要覆盖第三方库的某一个类，可以怎么做呢","like_count":0,"discussions":[{"author":{"id":1384043,"avatar":"https://static001.geekbang.org/account/avatar/00/15/1e/6b/ccee30e3.jpg","nickname":"枫叶","note":"","ucode":"8F85C3FA6D1ABA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631427,"discussion_content":"好好写你的crud得了，如果想自定义，看下Tomcat怎么做的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699518478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":380584,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"河南","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1693869149,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"请教老师几个问题：\nQ1：jre\\lib下面哪一个是启动类加载器？此目录下面并没有Bootstrap ClassLoader一类的文件。jre\\lib\\ext下面哪个是扩展类加载器？此目录下面并没有ExtClassLoader一类的文件。\nQ2：我的笔记本电脑上没有定义CLASSPATH环境变量，这说明没有应用类加载器吗？\nQ3：Java核心库主要包含哪些功能？\nQ4：Idea中的CLASSPATH在哪里可以找到？\nQ5：自定义类加载器实现以后，需要做什么操作才能被JVM使用？\nQ6：本课中的自定义类加载器例子，委托父类实现吗？好像没有看到哪部分代码是用来委托父类实现的。\nQ7：Tomcat每个WEB模块有自己的类加载器，这些模块的类加载器都有一个共同的父加载器，对吗？ 此外，在这种模式下，还有启动类加载器、扩展类加载器吗？\nQ8：“引导类加载器”是指启动类加载器吗？\nQ9：平台类加载器和系统类加载器的区别是什么？","like_count":0},{"had_liked":false,"id":380569,"user_name":"sc","can_delete":false,"product_type":"c1","uid":1025718,"ip_address":"浙江","ucode":"46D659C89BA8C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a6/b6/27412d76.jpg","comment_is_top":false,"comment_ctime":1693827998,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":1,"score":2,"product_id":100613601,"comment_content":"请问老师，在 类加载器的演进 小节中讲到，jdk9 『原本的引导类加载器也被拆分成了两个不同的加载器，分别是平台类加载器（Platform ClassLoader）和系统类加载器（System ClassLoader）。』是指在 jdk9 中的 Bootstrap ClassLoader 被拆分为两部分了吗，那 Bootstrap ClassLoader 还存在吗，这里说的拆飞之后的系统类加载器和之前说的的应用类加载器不是一种加载器吗，之后说 jdk17 又取消了系统类加载，那在 jdk17 中，还是引导类加载器-平台类加载器-应用类加载器-自定义类加载器 这样吗","like_count":0}]}