{"id":217395,"title":"63 | 职责链模式（下）：框架中常用的过滤器、拦截器是如何实现的？","content":"<p>上一节课，我们学习职责链模式的原理与实现，并且通过一个敏感词过滤框架的例子，展示了职责链模式的设计意图。本质上来说，它跟大部分设计模式一样，都是为了解耦代码，应对代码的复杂性，让代码满足开闭原则，提高代码的可扩展性。</p><p>除此之外，我们还提到，职责链模式常用在框架的开发中，为框架提供扩展点，让框架的使用者在不修改框架源码的情况下，基于扩展点添加新的功能。实际上，更具体点来说，职责链模式最常用来开发框架的过滤器和拦截器。今天，我们就通过Servlet Filter、Spring Interceptor这两个Java开发中常用的组件，来具体讲讲它在框架开发中的应用。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>Servlet Filter</h2><p>Servlet Filter是Java Servlet规范中定义的组件，翻译成中文就是过滤器，它可以实现对HTTP请求的过滤功能，比如鉴权、限流、记录日志、验证参数等等。因为它是Servlet规范的一部分，所以，只要是支持Servlet的Web容器（比如，Tomcat、Jetty等），都支持过滤器功能。为了帮助你理解，我画了一张示意图阐述它的工作原理，如下所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/32/21/3296abd63a61ebdf4eff3a6530979e21.jpg?wh=2103*1143\" alt=\"\"></p><p>在实际项目中，我们该如何使用Servlet Filter呢？我写了一个简单的示例代码，如下所示。添加一个过滤器，我们只需要定义一个实现javax.servlet.Filter接口的过滤器类，并且将它配置在web.xml配置文件中。Web容器启动的时候，会读取web.xml中的配置，创建过滤器对象。当有请求到来的时候，会先经过过滤器，然后才由Servlet来处理。</p><!-- [[[read_end]]] --><pre><code>public class LogFilter implements Filter {\n  @Override\n  public void init(FilterConfig filterConfig) throws ServletException {\n    // 在创建Filter时自动调用，\n    // 其中filterConfig包含这个Filter的配置参数，比如name之类的（从配置文件中读取的）\n  }\n\n  @Override\n  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    System.out.println(&quot;拦截客户端发送来的请求.&quot;);\n    chain.doFilter(request, response);\n    System.out.println(&quot;拦截发送给客户端的响应.&quot;);\n  }\n\n  @Override\n  public void destroy() {\n    // 在销毁Filter时自动调用\n  }\n}\n\n// 在web.xml配置文件中如下配置：\n&lt;filter&gt;\n  &lt;filter-name&gt;logFilter&lt;/filter-name&gt;\n  &lt;filter-class&gt;com.xzg.cd.LogFilter&lt;/filter-class&gt;\n&lt;/filter&gt;\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;logFilter&lt;/filter-name&gt;\n    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n&lt;/filter-mapping&gt;\n</code></pre><p>从刚刚的示例代码中，我们发现，添加过滤器非常方便，不需要修改任何代码，定义一个实现javax.servlet.Filter的类，再改改配置就搞定了，完全符合开闭原则。那Servlet Filter是如何做到如此好的扩展性的呢？我想你应该已经猜到了，它利用的就是职责链模式。现在，我们通过剖析它的源码，详细地看看它底层是如何实现的。</p><p>在上一节课中，我们讲到，职责链模式的实现包含处理器接口（IHandler）或抽象类（Handler），以及处理器链（HandlerChain）。对应到Servlet Filter，javax.servlet.Filter就是处理器接口，FilterChain就是处理器链。接下来，我们重点来看FilterChain是如何实现的。</p><p>不过，我们前面也讲过，Servlet只是一个规范，并不包含具体的实现，所以，Servlet中的FilterChain只是一个接口定义。具体的实现类由遵从Servlet规范的Web容器来提供，比如，ApplicationFilterChain类就是Tomcat提供的FilterChain的实现类，源码如下所示。</p><p>为了让代码更易读懂，我对代码进行了简化，只保留了跟设计思路相关的代码片段。完整的代码你可以自行去Tomcat中查看。</p><pre><code>public final class ApplicationFilterChain implements FilterChain {\n  private int pos = 0; //当前执行到了哪个filter\n  private int n; //filter的个数\n  private ApplicationFilterConfig[] filters;\n  private Servlet servlet;\n  \n  @Override\n  public void doFilter(ServletRequest request, ServletResponse response) {\n    if (pos &lt; n) {\n      ApplicationFilterConfig filterConfig = filters[pos++];\n      Filter filter = filterConfig.getFilter();\n      filter.doFilter(request, response, this);\n    } else {\n      // filter都处理完毕后，执行servlet\n      servlet.service(request, response);\n    }\n  }\n  \n  public void addFilter(ApplicationFilterConfig filterConfig) {\n    for (ApplicationFilterConfig filter:filters)\n      if (filter==filterConfig)\n         return;\n\n    if (n == filters.length) {//扩容\n      ApplicationFilterConfig[] newFilters = new ApplicationFilterConfig[n + INCREMENT];\n      System.arraycopy(filters, 0, newFilters, 0, n);\n      filters = newFilters;\n    }\n    filters[n++] = filterConfig;\n  }\n}\n</code></pre><p>ApplicationFilterChain中的doFilter()函数的代码实现比较有技巧，实际上是一个递归调用。你可以用每个Filter（比如LogFilter）的doFilter()的代码实现，直接替换ApplicationFilterChain的第12行代码，一眼就能看出是递归调用了。我替换了一下，如下所示。</p><pre><code>  @Override\n  public void doFilter(ServletRequest request, ServletResponse response) {\n    if (pos &lt; n) {\n      ApplicationFilterConfig filterConfig = filters[pos++];\n      Filter filter = filterConfig.getFilter();\n      //filter.doFilter(request, response, this);\n      //把filter.doFilter的代码实现展开替换到这里\n      System.out.println(&quot;拦截客户端发送来的请求.&quot;);\n      chain.doFilter(request, response); // chain就是this\n      System.out.println(&quot;拦截发送给客户端的响应.&quot;)\n    } else {\n      // filter都处理完毕后，执行servlet\n      servlet.service(request, response);\n    }\n  }\n</code></pre><p>这样实现主要是为了在一个doFilter()方法中，支持双向拦截，既能拦截客户端发送来的请求，也能拦截发送给客户端的响应，你可以结合着LogFilter那个例子，以及对比待会要讲到的Spring Interceptor，来自己理解一下。而我们上一节课给出的两种实现方式，都没法做到在业务逻辑执行的前后，同时添加处理代码。</p><h2>Spring Interceptor</h2><p>刚刚讲了Servlet Filter，现在我们来讲一个功能上跟它非常类似的东西，Spring Interceptor，翻译成中文就是拦截器。尽管英文单词和中文翻译都不同，但这两者基本上可以看作一个概念，都用来实现对HTTP请求进行拦截处理。</p><p>它们不同之处在于，Servlet Filter是Servlet规范的一部分，实现依赖于Web容器。Spring Interceptor是Spring MVC框架的一部分，由Spring MVC框架来提供实现。客户端发送的请求，会先经过Servlet Filter，然后再经过Spring Interceptor，最后到达具体的业务代码中。我画了一张图来阐述一个请求的处理流程，具体如下所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/fe/68/febaa9220cb9ad2f0aafd4e5c3c19868.jpg?wh=2283*903\" alt=\"\"></p><p>在项目中，我们该如何使用Spring Interceptor呢？我写了一个简单的示例代码，如下所示。LogInterceptor实现的功能跟刚才的LogFilter完全相同，只是实现方式上稍有区别。LogFilter对请求和响应的拦截是在doFilter()一个函数中实现的，而LogInterceptor对请求的拦截在preHandle()中实现，对响应的拦截在postHandle()中实现。</p><pre><code>public class LogInterceptor implements HandlerInterceptor {\n\n  @Override\n  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n    System.out.println(&quot;拦截客户端发送来的请求.&quot;);\n    return true; // 继续后续的处理\n  }\n\n  @Override\n  public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n    System.out.println(&quot;拦截发送给客户端的响应.&quot;);\n  }\n\n  @Override\n  public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n    System.out.println(&quot;这里总是被执行.&quot;);\n  }\n}\n\n//在Spring MVC配置文件中配置interceptors\n&lt;mvc:interceptors&gt;\n   &lt;mvc:interceptor&gt;\n       &lt;mvc:mapping path=&quot;/*&quot;/&gt;\n       &lt;bean class=&quot;com.xzg.cd.LogInterceptor&quot; /&gt;\n   &lt;/mvc:interceptor&gt;\n&lt;/mvc:interceptors&gt;\n</code></pre><p>同样，我们还是来剖析一下，Spring Interceptor底层是如何实现的。</p><p>当然，它也是基于职责链模式实现的。其中，HandlerExecutionChain类是职责链模式中的处理器链。它的实现相较于Tomcat中的ApplicationFilterChain来说，逻辑更加清晰，不需要使用递归来实现，主要是因为它将请求和响应的拦截工作，拆分到了两个函数中实现。HandlerExecutionChain的源码如下所示，同样，我对代码也进行了一些简化，只保留了关键代码。</p><pre><code>public class HandlerExecutionChain {\n private final Object handler;\n private HandlerInterceptor[] interceptors;\n \n public void addInterceptor(HandlerInterceptor interceptor) {\n  initInterceptorList().add(interceptor);\n }\n\n boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception {\n  HandlerInterceptor[] interceptors = getInterceptors();\n  if (!ObjectUtils.isEmpty(interceptors)) {\n   for (int i = 0; i &lt; interceptors.length; i++) {\n    HandlerInterceptor interceptor = interceptors[i];\n    if (!interceptor.preHandle(request, response, this.handler)) {\n     triggerAfterCompletion(request, response, null);\n     return false;\n    }\n   }\n  }\n  return true;\n }\n\n void applyPostHandle(HttpServletRequest request, HttpServletResponse response, ModelAndView mv) throws Exception {\n  HandlerInterceptor[] interceptors = getInterceptors();\n  if (!ObjectUtils.isEmpty(interceptors)) {\n   for (int i = interceptors.length - 1; i &gt;= 0; i--) {\n    HandlerInterceptor interceptor = interceptors[i];\n    interceptor.postHandle(request, response, this.handler, mv);\n   }\n  }\n }\n\n void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, Exception ex)\n   throws Exception {\n  HandlerInterceptor[] interceptors = getInterceptors();\n  if (!ObjectUtils.isEmpty(interceptors)) {\n   for (int i = this.interceptorIndex; i &gt;= 0; i--) {\n    HandlerInterceptor interceptor = interceptors[i];\n    try {\n     interceptor.afterCompletion(request, response, this.handler, ex);\n    } catch (Throwable ex2) {\n     logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2);\n    }\n   }\n  }\n }\n}\n</code></pre><p>在Spring框架中，DispatcherServlet的doDispatch()方法来分发请求，它在真正的业务逻辑执行前后，执行HandlerExecutionChain中的applyPreHandle()和applyPostHandle()函数，用来实现拦截的功能。具体的代码实现很简单，你自己应该能脑补出来，这里就不罗列了。感兴趣的话，你可以自行去查看。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>职责链模式常用在框架开发中，用来实现框架的过滤器、拦截器功能，让框架的使用者在不需要修改框架源码的情况下，添加新的过滤拦截功能。这也体现了之前讲到的对扩展开放、对修改关闭的设计原则。</p><p>今天，我们通过Servlet Filter、Spring Interceptor两个实际的例子，给你展示了在框架开发中职责链模式具体是怎么应用的。从源码中，我们还可以发现，尽管上一节课中我们有给出职责链模式的经典代码实现，但在实际的开发中，我们还是要具体问题具体对待，代码实现会根据不同的需求有所变化。实际上，这一点对于所有的设计模式都适用。</p><h2>课堂讨论</h2><ol>\n<li>前面在讲代理模式的时候，我们提到，Spring AOP是基于代理模式来实现的。在实际的项目开发中，我们可以利用AOP来实现访问控制功能，比如鉴权、限流、日志等。今天我们又讲到，Servlet Filter、Spring Interceptor也可以用来实现访问控制。那在项目开发中，类似权限这样的访问控制功能，我们该选择三者（AOP、Servlet Filter、Spring Interceptor）中的哪个来实现呢？有什么参考标准吗？</li>\n<li>除了我们讲到的Servlet Filter、Spring Interceptor之外，Dubbo Filter、Netty ChannelPipeline也是职责链模式的实际应用案例，你能否找一个你熟悉的并且用到职责链模式的框架，像我一样分析一下它的底层实现呢？</li>\n</ol><p>欢迎留言和我分享你的想法。如果有收获，欢迎你把这篇文章分享给你的朋友。</p>","comments":[{"had_liked":false,"id":196334,"user_name":"cricket1981","can_delete":false,"product_type":"c1","uid":1001715,"ip_address":"","ucode":"758262F5958DA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/f3/f1034ffd.jpg","comment_is_top":false,"comment_ctime":1585273553,"is_pvip":false,"discussion_count":19,"race_medal":0,"score":"697369975505","product_id":100039001,"comment_content":"Filter 可以拿到原始的http请求，但是拿不到你请求的控制器和请求控制器中的方法的信息; Interceptor 可以拿到你请求的控制器和方法，却拿不到请求方法的参数; Aop 可以拿到方法的参数，但是却拿不到http请求和响应的对象","like_count":163},{"had_liked":false,"id":264648,"user_name":"万历十五年","can_delete":false,"product_type":"c1","uid":1122150,"ip_address":"","ucode":"3D8CF5DF847AE8","user_header":"https://static001.geekbang.org/account/avatar/00/11/1f/66/59e0647a.jpg","comment_is_top":false,"comment_ctime":1606559195,"is_pvip":false,"replies":[{"id":"96067","content":"嗯嗯 ������<br>","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606700569,"ip_address":"","comment_id":264648,"utype":1}],"discussion_count":5,"race_medal":0,"score":"375268713947","product_id":100039001,"comment_content":"三者应用范围不同: web filter 作用于容器，应用范围影响最大；spring interceptor 作用于框架，范围影响适中；aop 作用于业务逻辑，精细化处理，范围影响最小。","like_count":88,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510639,"discussion_content":"嗯嗯 ������\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2142423,"avatar":"","nickname":"Geek_7e0e83","note":"","ucode":"554DEE2AAAE33C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574987,"discussion_content":"楼主说的很对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654509010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330632,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTItudDLPfbZabQLjk1NE8NSibQocdRy88rerQdxHFKx4KzUyaEnSLPbszcKAaPX8NgG3sHbZXib41aQ/132","nickname":"Mirss.zhao","note":"","ucode":"4A8F20B1A9D142","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375204,"discussion_content":"为啥感觉aop. 范围也不小呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621513737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1320117,"avatar":"https://static001.geekbang.org/account/avatar/00/14/24/b5/c62b9027.jpg","nickname":"夜猫~_~","note":"","ucode":"1D2291C659901D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1330632,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTItudDLPfbZabQLjk1NE8NSibQocdRy88rerQdxHFKx4KzUyaEnSLPbszcKAaPX8NgG3sHbZXib41aQ/132","nickname":"Mirss.zhao","note":"","ucode":"4A8F20B1A9D142","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382568,"discussion_content":"这里说的是aop的可空性更强，不想web filter只要请求这个servlet，都会被拦截","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625633146,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":375204,"ip_address":""},"score":382568,"extra":""}]},{"author":{"id":1438860,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","nickname":"子房","note":"","ucode":"CB05938C248BB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344089,"discussion_content":"有点那个意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611286801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196168,"user_name":"PCMD","can_delete":false,"product_type":"c1","uid":1842844,"ip_address":"","ucode":"76A1106F42AEAC","user_header":"https://static001.geekbang.org/account/avatar/00/1c/1e/9c/39f5ff2a.jpg","comment_is_top":false,"comment_ctime":1585241852,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"259283279612","product_id":100039001,"comment_content":"针对问题1而言，其实要实现一个鉴权的过滤器，通过以上3种方式都是可以去实现的，然而从粒度，场景，和方式上边有有所区别，主要采取用哪个，还是有业务来决定去用，没有统一的参考标准。比如要对所有的web接口，进行统一的权限处理，不需要区分动作，写或者读，所有一视同仁，这种情况下，servlet的更加适合。针对一些存在状态的，比如做一些统一的去参数转换，cookie转uid之类，以及通用检验uid是否符合当前权限，则很用mvc较好，而aop粒度就可以分的更加细致了，在一些更新需要，查询不需要的，如分控，日志记录等，就比较适合","like_count":61,"discussions":[{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369186,"discussion_content":"感觉&#34;针对一些存在状态的，比如做一些统一的去参数转换，cookie转uid之类，以及通用检验uid是否符合当前权限，则很用mvc较好&#34;这没有说服力, Filter也可以做","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618969796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":198367,"user_name":"webmin","can_delete":false,"product_type":"c1","uid":1047014,"ip_address":"","ucode":"98B0CA882454E8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/e6/47742988.jpg","comment_is_top":false,"comment_ctime":1585448152,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"220628780248","product_id":100039001,"comment_content":"AOP、Servlet Filter、Spring Interceptor这三者可以从不同权限检查的范围大小的视角来应用：<br>1. Servlet Filter<br>  运维部门需要对只供内部访问的服务进行IP限制或访问审查时，在容器这一层增加一个Filter，在发布时发布系统自动加挂这个Filter，这样对上层应用就是透明的，内网IP地址段增减或审查规则调整都不需要上层应用的开发人员去关心。<br>2. Spring Interceptor<br>  由框架或基础服务部门来提供的微服务间相互调用的授权检查时，可以提供统一的SDK，由程序员在需要的服务上配置。<br>3.  AOP<br>  业务应用内权限检查，可以把权限检查在统一模块中实现，通过配置由AOP加插拦截检查。","like_count":52,"discussions":[{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369187,"discussion_content":"有道理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618969861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196464,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1585283870,"is_pvip":false,"discussion_count":2,"race_medal":1,"score":"108959466270","product_id":100039001,"comment_content":"首先需要明确“访问控制功能”的粒度，如果访问控制功能要精确到每个请求，那么要使用AOP，AOP可以配置每个controller的访问权限。而Spring interceptor和servlet filter的粒度会粗一些，控制HttpRequest, HttpResponse的访问。另外servlet filter不能够使用 Spring 容器资源，只能在容器（如tomcat）启动时调用一次，而Spring Interceptor是一个Spring的组件，归Spring管理，配置在Spring文件中，因此能使用Spring里的任何资源、对象，例如 Service对象、数据源、事务管理等，通过IoC注入到Interceptor即可。相比较而言，Spring interceptor更灵活一些。<br>\t","like_count":26,"discussions":[{"author":{"id":1144132,"avatar":"https://static001.geekbang.org/account/avatar/00/11/75/44/ee170215.jpg","nickname":"Jasper","note":"","ucode":"7AEF50986C7D8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306958,"discussion_content":"springboot 中的@ServletComponentScan注解可以使spring容器管理filter，从而可以在filter中使用IOC注入对象","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1600430968,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1832751,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/HrblKDLM0uaYNgJo3ZbG3qzgvpq15vRDKadOkvktJuI6sWf4kUymXXXCM4ibicLcek22qAkd5oysSEVCTZuZJXGA/132","nickname":"推车的老王","note":"","ucode":"568A2E436CCFBE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1144132,"avatar":"https://static001.geekbang.org/account/avatar/00/11/75/44/ee170215.jpg","nickname":"Jasper","note":"","ucode":"7AEF50986C7D8C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311385,"discussion_content":"加@Component都行，只要这个filter被spring容器加载就可以使用了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602322535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":306958,"ip_address":""},"score":311385,"extra":""}]}]},{"had_liked":false,"id":196182,"user_name":"筱乐乐哦","can_delete":false,"product_type":"c1","uid":1307611,"ip_address":"","ucode":"AE92539F0419C3","user_header":"https://static001.geekbang.org/account/avatar/00/13/f3/db/5b7a8fd8.jpg","comment_is_top":false,"comment_ctime":1585243951,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"78894655279","product_id":100039001,"comment_content":"1、个人感觉权限的话，属于api的调用，应该放在调用链比较靠前的位置，早发现早处理，所以用Servlet Filter会更好一些吧，如果是rpc层的话，例如dubbo，就需要 在实现filter的时候通过order吧filter得优先级提高一些，让这个filter先执行，个人感觉哈<br>2、Dubbo Filter的核心处理逻辑在ProtocolFilterWrapper类下的buildInvokerChain这个方法中，属于把所有的filter的类对象搞成一个list，通过遍历list去调用所有的filter，Netty ChannelPipeline我记得是一个双向链表，pipeline 中的节点的数据结构是 ChannelHandlerContext 类，每个 ChannelHandlerContext 包含一个 ChannelHandler这种，支持从头尾开始传播事件，也就是触发调用，也可以从中间节点进行调用，入栈(read)是从head开始传播，也就是开始依次调用，出栈(write)是从tail开始传播，倒着调用。感觉算是对责任链的一个拓展使用，记不清了，得去看看代码，如果说错了，欢迎指点","like_count":18},{"had_liked":false,"id":198603,"user_name":"楊_宵夜","can_delete":false,"product_type":"c1","uid":1019302,"ip_address":"","ucode":"7BA0CADC5F23BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/a6/22c37c91.jpg","comment_is_top":false,"comment_ctime":1585459080,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"66009968520","product_id":100039001,"comment_content":"针对问题1，一把泪水想起了项目中的坑. 个人觉得最大的不同还是生效粒度的问题.<br>1. Servlet Filter是针对Servlet容器里的方法都能生效. 就是说Servlet容器里就算要把Spring换成别的框架，鉴权代码依然能生效.<br>2. Spring开头的就只能在Spring中生效，<br>2.1. 但更好还是在interceptor，因为interceptor天然的设计背景就是[在请求前，在相应后.]<br>2.2. 如果用AOP实现，就很依赖于AOP的pointcut设置，一不小心就会在[一次请求响应里]执行了[多次重复的鉴权服务]……<br>","like_count":16},{"had_liked":false,"id":211165,"user_name":"xk_","can_delete":false,"product_type":"c1","uid":1514305,"ip_address":"","ucode":"DFE1AC38EA78A7","user_header":"https://static001.geekbang.org/account/avatar/00/17/1b/41/dbb7d785.jpg","comment_is_top":false,"comment_ctime":1587908317,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"48832548573","product_id":100039001,"comment_content":"课后题1，当然是全部都是用啊。<br>filter，可以控制所有的请求，用来处理网络攻击什么的。<br>interceptor可以控制用户和非用户的登录啊。<br>AOP可以控制用户角色对方方法的访问权限。<br>详情请见shiro，或者spring security。","like_count":12},{"had_liked":false,"id":270840,"user_name":"David","can_delete":false,"product_type":"c1","uid":1021825,"ip_address":"","ucode":"22CBBC13FC97A9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/97/81/e1eaf621.jpg","comment_is_top":false,"comment_ctime":1609298407,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"31674069479","product_id":100039001,"comment_content":"Servlet Fillter，Spring Interceptor，Spring AOP三者粒度是越来越细的。根据业务场景的覆盖度选择。<br>1. 比如限流就可以在Filter层去做，因为全局都需要限流防止服务被压垮。<br>2. 用户是否登录权限等可以使用Interceptor做。<br>3. 细粒度到类或者方法的控制使用AOP去做，比如日志 事务 方法级别权限。","like_count":8},{"had_liked":false,"id":200544,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1585617399,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23060453879","product_id":100039001,"comment_content":"设计模式_63:<br># 作业<br>1. 这个问题确实不懂，看了大家的回答，了解到对于颗粒度的考虑。<br>2. 有一个Java&#47;Kotlin的网络库叫Okhttp，也用到了职责链模式，用来做一些日志记录等。<br><br># 感想<br>第一次看Okhttp源码涉及Interceptor的时候，绕来绕去，一会儿Interceptor调用Chain，一会儿又反过来，云里雾里。。。看了几遍又画了图，才明白了流程。<br>当时不知道叫职责链模式，只是感觉写得很妙。","like_count":6},{"had_liked":false,"id":268658,"user_name":"Geek_3e636e","can_delete":false,"product_type":"c1","uid":1679267,"ip_address":"","ucode":"ADF9E346F87A63","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL8D6wvhCszzJeTsMS3F9yAib2icialw2gibFgDibvehKzeujSxn2GACMPqGhdQOHqmZS791148gibAVBLA/132","comment_is_top":false,"comment_ctime":1608284367,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18788153551","product_id":100039001,"comment_content":"一个请求从客户端到服务端再到响应，假设Filter、Interceptor、AOP都存在，经过的路径大概是：请求-&gt;Filter-&gt;Interceptor-&gt;AOP-&gt;核心业务处理-&gt;AOP-&gt;Interceptor-&gt;Filter-&gt;响应。<br>Filter、Interceptor、 AOP在不同的节点所能感知到的数据状态都是不同的，姑且理解为域不同吧，要实现权限访问控制，肯定是在到达核心业务前植入权限控制逻辑，那就在“请求-&gt;Filter-&gt;Interceptor-&gt;AOP-&gt;核心业务处理”。<br>权限控制逻辑需要三个核心属性：资源、角色、角色资源映射。资源：一般我们用uri来标识某一个资源，或者可以通过注解等方式在方法上声明一个资源标识；角色和角色资源映射一般通过读取Session获取。那么权限控制逻辑放在那里取决于哪里可以拿到这两个信息？理论上角色和角色资源映射在哪里都可以读取到的。就看资源怎么表示了，如果你的资源是标识的servlet，那就通过Filter控制，如果你的资源是标识的Controller，可以在Interceptor控制，如果你的资源是标识的很深层的方法，可以在AOP控制","like_count":5},{"had_liked":false,"id":216197,"user_name":"Ifdevil","can_delete":false,"product_type":"c1","uid":1212912,"ip_address":"","ucode":"79DB0ADE9AD082","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/f0/695ca05f.jpg","comment_is_top":false,"comment_ctime":1589204099,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18769073283","product_id":100039001,"comment_content":"AOP的优势是灵活，万物皆可AOP，嘿嘿，但是职责链特性是链，更好处理一些连续处理的工作，个人浅见","like_count":4},{"had_liked":false,"id":200068,"user_name":"Geek_27a248","can_delete":false,"product_type":"c1","uid":1542778,"ip_address":"","ucode":"6AC3AC42E6EEC9","user_header":"https://static001.geekbang.org/account/avatar/00/17/8a/7a/54003392.jpg","comment_is_top":false,"comment_ctime":1585539468,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18765408652","product_id":100039001,"comment_content":"比如鉴权，限流，日志三个方面的话，鉴权可以使用spring interceptor，spring管理的获取的信息比较多，方便做更细的鉴权；限流的话可以使用servlet filter，执行比较考前，最大程度降低后方请求数量。日志的话使用aop，最大细度的记录日志信息。不知道这样理解的对不对，对这些的理解还是比较片面的不够深入，还有待加深","like_count":5},{"had_liked":false,"id":196533,"user_name":"马球先生","can_delete":false,"product_type":"c1","uid":1119609,"ip_address":"","ucode":"858C2CE0E494C5","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/79/efde2a69.jpg","comment_is_top":false,"comment_ctime":1585290710,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18765159894","product_id":100039001,"comment_content":"安卓的网络请求框架 okhttp中使用了责任链","like_count":4,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510473,"discussion_content":"还好吧，理解思路为主","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196466,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1585283914,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18765153098","product_id":100039001,"comment_content":"偏业务的使用AOP，全局的使用servlet filter","like_count":4},{"had_liked":false,"id":196307,"user_name":"Xs.Ten","can_delete":false,"product_type":"c1","uid":1128376,"ip_address":"","ucode":"2368B9BDDDEE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/37/b8/c887a5ea.jpg","comment_is_top":false,"comment_ctime":1585271428,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"18765140612","product_id":100039001,"comment_content":"即时通讯里面的消息分发可以用到责任链模式。可以添加不同的分发规则来分发不同的消息类型到各个消息处理器。","like_count":4},{"had_liked":false,"id":209741,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1587606955,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14472508843","product_id":100039001,"comment_content":"在Netty里面，pipeline组件就是使用职责链模式进行组装的。底层是双向链表（首尾节点是哨兵节点，用于处理某些buffer的释放）。详细可以参考这个文章   https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;Lh1GnhYf36C2Y2gdBJvKQQ","like_count":3,"discussions":[{"author":{"id":2757030,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/11/a6/50c3e4a2.jpg","nickname":"白云苍饭勇往直前！","note":"","ucode":"11EA43531E2845","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566856,"discussion_content":"jdk stream的底层也是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650779580,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":272111,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1609936017,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10199870609","product_id":100039001,"comment_content":"卧槽。醍醐灌顶。怪不得之前的有的项目拦截器实现HandlerInterceptorAdapter来完成权限拦截，有的实现Filter来实现拦截。原来会先经过 Servlet Filter，然后再经过 Spring Interceptor。都在一个调用链路上，还有就是责任链模式原来这么简单。看了老师分享的源码，各类框架还是使用数组来存储处理器。真是有收获！！！","like_count":2},{"had_liked":false,"id":196711,"user_name":"袁帅","can_delete":false,"product_type":"c1","uid":1084993,"ip_address":"","ucode":"A71A89B9F1BD69","user_header":"https://static001.geekbang.org/account/avatar/00/10/8e/41/709e9677.jpg","comment_is_top":false,"comment_ctime":1585304976,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10175239568","product_id":100039001,"comment_content":"1、权限应该使用servlet filter , servlet filter 是对早被执行的，可为所有request加拦截，如果仅仅想对web请求加权限，那么使用spring interceptor ","like_count":2},{"had_liked":false,"id":196678,"user_name":"LiG❄️","can_delete":false,"product_type":"c1","uid":1357566,"ip_address":"","ucode":"0FE01F25ADD1F9","user_header":"https://static001.geekbang.org/account/avatar/00/14/b6/fe/c5d7f0dc.jpg","comment_is_top":false,"comment_ctime":1585302054,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10175236646","product_id":100039001,"comment_content":"老师，请问Servlet Filter中采用递归方式调用职责链中元素，Spring Interceptor中采用数组变量方式调用职责链中元素，这两种调用方式，是基于什么考虑的，有什么优劣呢？","like_count":2},{"had_liked":false,"id":196301,"user_name":"迷羊","can_delete":false,"product_type":"c1","uid":1286251,"ip_address":"","ucode":"85AF8CED3436C8","user_header":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","comment_is_top":false,"comment_ctime":1585271036,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10175205628","product_id":100039001,"comment_content":"但在实际的开发中，我们还是要具体问题具体对待，代码实现会根据不同的需求有所变化。实际上，这一点对于所有的设计模式都适用。<br>这句话很精辟","like_count":2},{"had_liked":false,"id":316966,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1634630060,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5929597356","product_id":100039001,"comment_content":"思考：<br>1.首先 过滤器，拦截器，AOP的作用范围依次降低，过滤器是整个Web容器，拦截器是作用Spring容器，AOP则作用于具体的方法。<br>2.关于使用场景:  类似像URL黑名单拦截，则在网关层面即过滤器就要进行拦截。如果需要拿到Spring容器中的Bean进行相关拦截处理，则可以用拦截器，比如鉴权等。  如果是对代码层面的增强解耦，则用AOP","like_count":1},{"had_liked":false,"id":272898,"user_name":"大力水手Jerry","can_delete":false,"product_type":"c1","uid":1227840,"ip_address":"","ucode":"E4A6C71E275DB5","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg","comment_is_top":false,"comment_ctime":1610349785,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5905317081","product_id":100039001,"comment_content":"感觉职责链模式与观察者模式很类似。观察者模式中，在被观察者中注册观察者，当被观察者进行一定处理后，使用结果消息顺序调用注册的观察者，这些观察者基于该消息对象执行不同的业务逻辑，两者的核心差异：职责链handlers围绕消息，以更新该消息为第一要务，而观察者模式中的observer基于消息，以处理观察者的业务为第一要务。如果说职责链中handler更新消息即是业务，那么职责链的handler是一种特殊场景下的观察者。实际上，职责链中的handler命名，即表明是对消息本身的处理，如果消息表征为一种状态，那么简单的叠加顺序处理即可；如果消息表征为&lt;请求，响应&gt;，则handler需要采用递归，或者分解处理逻辑（比如preHandler，postHandler，afterCompletion），实现对请求和响应的分别处理。","like_count":1},{"had_liked":false,"id":258583,"user_name":"Geek_d61308","can_delete":false,"product_type":"c1","uid":2109103,"ip_address":"","ucode":"FDEE38E49EAE54","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI6nskCoqMibz98cHQIqTSotVeLd6Hzwk6rPG60yrwBgkCibfzB5Yu7Vw1ic6iaxo9P3RoBZcZo37kZXQ/132","comment_is_top":false,"comment_ctime":1604491601,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5899458897","product_id":100039001,"comment_content":"文中说ApplicationFilterChain中支持双向拦截，既能拦截客户端发送来的请求，也能拦截发送给客户端的响应。我看了下源码，以MetricsFilter为例：<br>StopWatch stopWatch = createStopWatchIfNecessary(request);<br>\t\tint status = HttpStatus.INTERNAL_SERVER_ERROR.value();<br>\t\ttry {<br>\t\t\tchain.doFilter(request, response);<br>\t\t\tstatus = getStatus(response);<br>\t\t}<br>\t\tfinally {<br>\t\t\tif (!request.isAsyncStarted()) {<br>\t\t\t\tif (response.isCommitted()) {<br>\t\t\t\t\tstatus = getStatus(response);<br>\t\t\t\t}<br>\t\t\t\tstopWatch.stop();<br>\t\t\t\trequest.removeAttribute(ATTRIBUTE_STOP_WATCH);<br>\t\t\t\trecordMetrics(request, status, stopWatch.getTotalTimeMillis());<br>\t\t\t}<br>\t\t}<br>老师说的拦截响应，是指调用完chain.doFilter(request, response)之后的内容吗？？","like_count":1},{"had_liked":false,"id":253789,"user_name":"Hector","can_delete":false,"product_type":"c1","uid":1496889,"ip_address":"","ucode":"110CAF87ADDC01","user_header":"https://static001.geekbang.org/account/avatar/00/16/d7/39/6698b6a9.jpg","comment_is_top":false,"comment_ctime":1602897572,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5897864868","product_id":100039001,"comment_content":"go的框架，gin里的HandlerFunc也算是职责链模式。像Servlet Filter一样请求和响应都会经过HandlerFunc, 但是请求链路可以进行不终止，也可以中断，职责链模式的两种模式都可以进行切换。在实现方式上职责链的每个节点并没有做成数组或者链表，而是挂载到树结构。","like_count":1},{"had_liked":false,"id":232252,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1593935758,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5888903054","product_id":100039001,"comment_content":"职责链模式，解决的是扩展问题。对于一个请求我们可以增加对这个请求的处理功能。<br>使用aop代理模式还是servletFilter，或者spring的interceptor需要看下以下情况：<br>1.是否存在顺序性，即要求对于一个请求或业务处理的功能是有序的。<br>如果存在这个特性，用职责链会比较合适。<br>2.对于一个请求或业务，如果本身是没有用servlet，或spring mvc，则这时只能用aop了","like_count":1},{"had_liked":false,"id":202771,"user_name":"花儿少年","can_delete":false,"product_type":"c1","uid":1318540,"ip_address":"","ucode":"CFE4F64243673B","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/8c/450fe5cb.jpg","comment_is_top":false,"comment_ctime":1586066246,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5881033542","product_id":100039001,"comment_content":"doFilter在拦截请求和拦截响应都执行，实际上应该是递归调用返回的原因。<br>一般来说都是拦截请求，所以doFilter 记得写在函数最后一行，或者 doFilter 后补一个 return；","like_count":1},{"had_liked":false,"id":196691,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1585303224,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880270520","product_id":100039001,"comment_content":"思考题一：首先要区分三者的特点，Spring AOP的使用粒度是类，是对类的一个包装；servlet filter和spring interceptor主要是对httpRequest、httpResponse做处理，servlet filterChain的实现依赖于具体的Web容器，而spring interceptor和spring AOP都依赖于spring框架，servlet filter在一个函数里拦截请求和响应，而spring interceptor将请求、响应的拦截分成了两个函数；其次，针对特定的应用场景，选择适合的。","like_count":1},{"had_liked":false,"id":348261,"user_name":"寒光","can_delete":false,"product_type":"c1","uid":1206187,"ip_address":"","ucode":"061BE413595F21","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/ab/fcf0cec4.jpg","comment_is_top":false,"comment_ctime":1654909673,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654909673","product_id":100039001,"comment_content":"准确地讲，servlet的filter和spring的intercepter都是通过职责链模式达到了AOP的目的，而AOP又是代理模式的典型应用。这也进一步说明，实际应用中，不能孤立地看每一个设计模式，经典的23个设计模式，只是一个个音符，而把这些音符灵活组合，才能形成完整的乐曲。","like_count":0},{"had_liked":false,"id":347842,"user_name":"Geek_7e0e83","can_delete":false,"product_type":"c1","uid":2142423,"ip_address":"","ucode":"554DEE2AAAE33C","user_header":"","comment_is_top":false,"comment_ctime":1654509181,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654509181","product_id":100039001,"comment_content":"三者控制的影响范围各不相同，filter interceptor aop 依次影响范围减小。根据自己的场景，选择。aop更适合业务场景，偏向代码中的代理，会相对具体一些。servelet的filter会比较专注于http的请求的过滤。Interceptor 则是MVC的拦截器 和框架绑定","like_count":0},{"had_liked":false,"id":347530,"user_name":"mkii","can_delete":false,"product_type":"c1","uid":1674466,"ip_address":"","ucode":"534914EC7EA304","user_header":"https://static001.geekbang.org/account/avatar/00/19/8c/e2/48f4e4fa.jpg","comment_is_top":false,"comment_ctime":1654131150,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654131150","product_id":100039001,"comment_content":"为什么tomcat和mvc的handler列表不用list而用数组呢？<br>ApplicationFilterConfig[] filters;<br> HandlerInterceptor[] interceptors;","like_count":0},{"had_liked":false,"id":339936,"user_name":"夏天","can_delete":false,"product_type":"c1","uid":1285986,"ip_address":"","ucode":"F29D56F9265751","user_header":"https://static001.geekbang.org/account/avatar/00/13/9f/62/960eecc3.jpg","comment_is_top":false,"comment_ctime":1648471801,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648471801","product_id":100039001,"comment_content":"aop 可以支持到方法级别 功能更强大","like_count":0},{"had_liked":false,"id":339804,"user_name":"海阔天空","can_delete":false,"product_type":"c1","uid":1179385,"ip_address":"","ucode":"01889619D23407","user_header":"https://static001.geekbang.org/account/avatar/00/11/fe/f9/f3e3fc17.jpg","comment_is_top":false,"comment_ctime":1648393422,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648393422","product_id":100039001,"comment_content":"FilterChain这个递归设计的真好，把调用栈画了个图才看懂","like_count":0},{"had_liked":false,"id":328655,"user_name":"frogs eyes","can_delete":false,"product_type":"c1","uid":1747522,"ip_address":"","ucode":"E395668FCDFF9A","user_header":"https://static001.geekbang.org/account/avatar/00/1a/aa/42/b8780e94.jpg","comment_is_top":false,"comment_ctime":1640828227,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640828227","product_id":100039001,"comment_content":"假如有a、b、c三个filter，ab是或的关系，ab与c有序，是且的关系。那么责任链可以改造下，并发执行ab，得到结果后判断是否继续往下走<br> ","like_count":0},{"had_liked":false,"id":320313,"user_name":"Dale","can_delete":false,"product_type":"c1","uid":1242602,"ip_address":"","ucode":"AD19A33FE5EEDF","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/ea/5f046856.jpg","comment_is_top":false,"comment_ctime":1636224140,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636224140","product_id":100039001,"comment_content":"webpack在使用时，会配置不同的 loader，每个 loader 都有一个正则表达式类型的 test 属性，所有 loader 都放在一个数组中。当需要为模块选择 loader 的时候，就会去遍历 loader 数组，从中找出 test 属性跟模块类型匹配的 loader，最终用于加载这个模块。","like_count":0},{"had_liked":false,"id":310685,"user_name":"范特西","can_delete":false,"product_type":"c1","uid":1359210,"ip_address":"","ucode":"6F57092D832D7F","user_header":"https://static001.geekbang.org/account/avatar/00/14/bd/6a/abe84a16.jpg","comment_is_top":false,"comment_ctime":1630838406,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1630838406","product_id":100039001,"comment_content":"\tboolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception {<br>\t\tHandlerInterceptor[] interceptors = getInterceptors();<br>\t\tif (!ObjectUtils.isEmpty(interceptors)) {<br>\t\t\tfor (int i = 0; i &lt; interceptors.length; i++) {<br>\t\t\t\tHandlerInterceptor interceptor = interceptors[i];<br>\t\t\t\tif (!interceptor.preHandle(request, response, this.handler)) {<br>\t\t\t\t\ttriggerAfterCompletion(request, response, null);<br>\t\t\t\t\treturn false;<br>\t\t\t\t}<br>\t\t\t\tthis.interceptorIndex = i;<br>\t\t\t}<br>\t\t}<br>\t\treturn true;<br>\t}<br><br>1. 原文少了 this.interceptorIndex = i; 这一行，会导致看得有点奇怪，没有达到递归（栈）的作用","like_count":0},{"had_liked":false,"id":287594,"user_name":"snake","can_delete":false,"product_type":"c1","uid":2347137,"ip_address":"","ucode":"47BFFE4D048156","user_header":"https://static001.geekbang.org/account/avatar/00/23/d0/81/d5c8e46e.jpg","comment_is_top":false,"comment_ctime":1618042370,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618042370","product_id":100039001,"comment_content":"可以三者结合起来运用，filter，Interceptor用来做全局性的过滤，比如加密解密，登录用户的判定，aop做细粒度的过滤，比如打印日志，权限判定等工作","like_count":0},{"had_liked":false,"id":282941,"user_name":"御风","can_delete":false,"product_type":"c1","uid":1812807,"ip_address":"","ucode":"51C8212BE06364","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/47/ded5da90.jpg","comment_is_top":false,"comment_ctime":1615470911,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615470911","product_id":100039001,"comment_content":"问题一，看留言学到了：<br><br>三者应用范围不同: web filter 作用于容器，应用范围影响最大；spring interceptor 作用于框架，范围影响适中；aop 作用于业务逻辑，精细化处理，范围影响最小。","like_count":0},{"had_liked":false,"id":281025,"user_name":"李树增","can_delete":false,"product_type":"c1","uid":2015851,"ip_address":"","ucode":"58B0509EE56777","user_header":"https://static001.geekbang.org/account/avatar/00/1e/c2/6b/149d9ab1.jpg","comment_is_top":false,"comment_ctime":1614531703,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614531703","product_id":100039001,"comment_content":"public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse) {<br>        if (pos &lt; n) {<br>            Filter filter = filters[pos++];<br>            filter.doFilter(servletRequest, servletResponse, this);<br>        } else {<br>            servlet.service(servletRequest, servletResponse);<br>            &#47;&#47; 复位 pos 游标，否则该拦截器链只能使用一次<br>            pos = 0;<br>        }<br>    }<br>这里是不是缺少了复位pos呢","like_count":0},{"had_liked":false,"id":272894,"user_name":"大力水手Jerry","can_delete":false,"product_type":"c1","uid":1227840,"ip_address":"","ucode":"E4A6C71E275DB5","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg","comment_is_top":false,"comment_ctime":1610349373,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610349373","product_id":100039001,"comment_content":"难道没人发现职责链与观察者模式很类似吗？观察者模式中，在被观察者中注册观察者，当被观察者进行一定处理后，使用结果消息顺序调用注册的观察者，这些观察者基于该消息对象执行不同的业务逻辑，而不单纯是修改这个消息对象。两者的核心差异：职责链handlers围绕消息，以更新该消息为第一要务，而观察者模式中的observer基于消息，以处理观察者的业务为第一要务。当然说职责链中handler更新消息即是业务，因此从这个角度说，职责链是一种特殊场景下的观察者。","like_count":0},{"had_liked":false,"id":257122,"user_name":"RedDevil","can_delete":false,"product_type":"c1","uid":1131128,"ip_address":"","ucode":"F8F5DC209BB3B9","user_header":"https://static001.geekbang.org/account/avatar/00/11/42/78/7ba89c75.jpg","comment_is_top":false,"comment_ctime":1603854478,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603854478","product_id":100039001,"comment_content":"Netty的handler就是基于职责链模式实现的","like_count":0},{"had_liked":false,"id":252801,"user_name":"大方方","can_delete":false,"product_type":"c1","uid":1354013,"ip_address":"","ucode":"621AD8F1485753","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6cyOoRd2dROgiblAJkW6RLhUyH1wwU0NNibIIuV930eQ9TiaNT41K61kBSVkvYoDYg7mJtuEoCQY1awBmV0WW6BFg/132","comment_is_top":false,"comment_ctime":1602490707,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1602490707","product_id":100039001,"comment_content":"不会Javascript 等以后学了再回头看这章。。。","like_count":0,"discussions":[{"author":{"id":1134574,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4f/ee/bd08cfab.jpg","nickname":"一魄","note":"","ucode":"71541125D4AA5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546171,"discussion_content":"放弃吧。别搅和","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642200835,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252010,"user_name":"Jerry Wu","can_delete":false,"product_type":"c1","uid":1203567,"ip_address":"","ucode":"AD29B6942AAAA6","user_header":"https://static001.geekbang.org/account/avatar/00/12/5d/6f/42494dcf.jpg","comment_is_top":false,"comment_ctime":1602055521,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602055521","product_id":100039001,"comment_content":"看完职责链模式的两篇文章，分析了 shiro 的过滤器实现，写了笔记。附上地址：https:&#47;&#47;www.jianshu.com&#47;p&#47;1e7a0384da6d","like_count":0},{"had_liked":false,"id":223494,"user_name":"师哥","can_delete":false,"product_type":"c1","uid":1333376,"ip_address":"","ucode":"A86CD1661D370F","user_header":"https://static001.geekbang.org/account/avatar/00/14/58/80/c9e232b6.jpg","comment_is_top":false,"comment_ctime":1591102287,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591102287","product_id":100039001,"comment_content":"1.Servlet  Filter  进入容器前的对请求预处理 2.Spring Interceptor 对业务进行预处理 3.Spring Aop 主要是在细粒度的业务层面上进行一系列操作","like_count":0},{"had_liked":false,"id":221750,"user_name":"worthto","can_delete":false,"product_type":"c1","uid":1387712,"ip_address":"","ucode":"41D7ABBBD2E7FF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/N6yjnrLnMW4XVSkBr3f0N3F962l35b5j0kib9VSlAqqbf6iaoCPicL1WnJ9KjgT4egQ7A2G0Zx3OayaK4yuoZrUVA/132","comment_is_top":false,"comment_ctime":1590582616,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590582616","product_id":100039001,"comment_content":"netty的ChannelPipeline的实现逻辑：1、每一个SocketChannel对象维护这一个ChannelPipeline对象，该对象支持bind,connect,disconnect,read,write等IO时间的触发链条；2、ChannelPipeline对外提供ChannelHandler的增删改查的接口、对内使用AbstractChannelHandlerContext对象将ChannelHandler包装了一层，维护了一个AbstractChannelHandlerContext的双向链表。3、当SocketChannel发生IO事件时，比如发生了read事件，SocketChannel委托ChannelPipeline去处理这些时间，从而启动了责任链的操作。","like_count":0},{"had_liked":false,"id":220356,"user_name":"新世界","can_delete":false,"product_type":"c1","uid":1079495,"ip_address":"","ucode":"4473DC1505F158","user_header":"https://static001.geekbang.org/account/avatar/00/10/78/c7/083a3a0b.jpg","comment_is_top":false,"comment_ctime":1590226035,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590226035","product_id":100039001,"comment_content":"鉴权用filter，shiro和Spring security有现成的实现，都是用的filter","like_count":0},{"had_liked":false,"id":216764,"user_name":"andi轩","can_delete":false,"product_type":"c1","uid":1214649,"ip_address":"","ucode":"3AE241BE60A3E0","user_header":"https://static001.geekbang.org/account/avatar/00/12/88/b9/af5db174.jpg","comment_is_top":false,"comment_ctime":1589338364,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589338364","product_id":100039001,"comment_content":"看了Spring的HandlerExecutionChain源码，在applyPreHandle()的时候，会记录preHandle执行成功（返回true）的计数counter：interceptorIndex。在triggerAfterCompletion()里，从interceptorIndex开始反向调用各个interceptor的afterCompletion()方法。也就是说，只会执行preHandle成功且返回true的哪些interceptor的afterCompletion","like_count":0},{"had_liked":false,"id":216698,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1589329829,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589329829","product_id":100039001,"comment_content":"1.Servlet Filter，是基于Servlet容器，对请求的过滤。不能获取控制器。<br>2.Spring Interceptot是基于Spring框架，对请求进行拦截，也是整个请求的层面。<br>3.AOP，实质也是拦截器。<br>它是在方法调用时触发（链接点join point），可以控制到方法级。支持before，after，return，around，throw。","like_count":0},{"had_liked":false,"id":205880,"user_name":"江中猴姑饼干","can_delete":false,"product_type":"c1","uid":1238992,"ip_address":"","ucode":"4F288845CC70FA","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/d0/d145c11f.jpg","comment_is_top":false,"comment_ctime":1586750396,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"1586750396","product_id":100039001,"comment_content":"Filter  怎么做到双向拦截的啊，这个地方看不懂，哪位帮忙讲讲？","like_count":0,"discussions":[{"author":{"id":1053390,"avatar":"https://static001.geekbang.org/account/avatar/00/10/12/ce/a8c8b5e8.jpg","nickname":"Jason","note":"","ucode":"ABB3F1A63E102A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":233672,"discussion_content":"因为递归调用，所以能做到双向拦截。递归函数压栈时，对request拦截；递归函数出栈时，对response拦截。你对照着争哥的样例代码仔细品品，挺有意思的。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1586938074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1227840,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg","nickname":"大力水手Jerry","note":"","ucode":"E4A6C71E275DB5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339470,"discussion_content":"System.out.println(&#34;拦截客户端发送来的请求.&#34;);  //  修改request\nchain.doFilter(request, response); // chain就是this\nSystem.out.println(&#34;拦截发送给客户端的响应.&#34;)   //  修改response\n其实两个打印语句在实际项目中，分别承担修改request和修改response的职责。所以说是双向拦截。另外不要用计算机的栈的活动去理解递归调用过程，将chain.doFilter(request, response);理解成单步执行成功的指令即可。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609682599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1108457,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e9/e9/1f95e422.jpg","nickname":"杨陆伟","note":"","ucode":"3BC968447406EB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1227840,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg","nickname":"大力水手Jerry","note":"","ucode":"E4A6C71E275DB5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343076,"discussion_content":"个人拙见，chain.doFilter(request, response); 感觉是在业务代码中侵入了框架代码，忘了加怎么办呢？这种设计精巧是精巧，但是不见得对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610939489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":339470,"ip_address":""},"score":343076,"extra":""}]},{"author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263950,"discussion_content":"因为在filter实现类中调用了chain.doFilter，如果不调用，就不是双向拦截了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589271150,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1541669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/86/25/25ded6c3.jpg","nickname":"zhengyu.nie","note":"","ucode":"FFE0377D323E46","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":259948,"discussion_content":"就是递归，跟遍历二叉树一样。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588831737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203403,"user_name":"ub8","can_delete":false,"product_type":"c1","uid":1481811,"ip_address":"","ucode":"0D937C3EAEB781","user_header":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","comment_is_top":false,"comment_ctime":1586184761,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586184761","product_id":100039001,"comment_content":"过滤器 拦截器执行顺序：过滤器-&gt;拦截器-&gt;runFunction-&gt;拦截器-&gt;过滤器","like_count":0},{"had_liked":false,"id":203377,"user_name":"makermade","can_delete":false,"product_type":"c1","uid":1133194,"ip_address":"","ucode":"03386B90CB8F20","user_header":"https://static001.geekbang.org/account/avatar/00/11/4a/8a/c1069412.jpg","comment_is_top":false,"comment_ctime":1586181255,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586181255","product_id":100039001,"comment_content":"受益匪浅","like_count":0},{"had_liked":false,"id":200430,"user_name":"jiajia","can_delete":false,"product_type":"c1","uid":1121424,"ip_address":"","ucode":"C1632AFC8E790E","user_header":"https://static001.geekbang.org/account/avatar/00/11/1c/90/45d761d6.jpg","comment_is_top":false,"comment_ctime":1585582838,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585582838","product_id":100039001,"comment_content":"okhttp","like_count":0},{"had_liked":false,"id":199455,"user_name":"君哥聊技术","can_delete":false,"product_type":"c1","uid":1325816,"ip_address":"","ucode":"2C9A22BCE4C79E","user_header":"https://static001.geekbang.org/account/avatar/00/14/3a/f8/c1a939e7.jpg","comment_is_top":false,"comment_ctime":1585489532,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585489532","product_id":100039001,"comment_content":"1.如果是一个全局的鉴权，用servlet 自有的filter是最好的，实现也简单，如果是有特性的鉴权，用拦截器或者aop注解的方式实现比较好<br>2.mybatis的拦截器就用了职责链模式，InterceptorChain类作为职责链类，Interceptor接口的实现类作为handler类，加@Intercepts注解来定义","like_count":0},{"had_liked":false,"id":198532,"user_name":"木木","can_delete":false,"product_type":"c1","uid":1505345,"ip_address":"","ucode":"75546496818208","user_header":"https://static001.geekbang.org/account/avatar/00/16/f8/41/f395c9a4.jpg","comment_is_top":false,"comment_ctime":1585455417,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585455417","product_id":100039001,"comment_content":"Mybatis中的拦截器也使用到责任链模式，只不过是通过动态代理的方式，在多个同类型拦截器中通过遍历的方式为被拦截对象生成代理对象，然后使用生成的代理对象作为参数继续生成代理对象，直至遍历结束，拿到最外层代理对象，触发invoke方法完成链式拦截器传递","like_count":0},{"had_liked":false,"id":197055,"user_name":"徐旭","can_delete":false,"product_type":"c1","uid":1814806,"ip_address":"","ucode":"1D3091D15373E5","user_header":"https://static001.geekbang.org/account/avatar/00/1b/b1/16/dd11930c.jpg","comment_is_top":false,"comment_ctime":1585354278,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585354278","product_id":100039001,"comment_content":"老师讲得赞👍","like_count":0},{"had_liked":false,"id":197009,"user_name":"Geek_3b1096","can_delete":false,"product_type":"c1","uid":1549364,"ip_address":"","ucode":"A6BD92B79B3632","user_header":"","comment_is_top":false,"comment_ctime":1585346932,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585346932","product_id":100039001,"comment_content":"细读","like_count":0},{"had_liked":false,"id":196407,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1585278798,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585278798","product_id":100039001,"comment_content":"对于问题1,因为Aop是对整个类的一种拦截,所以没法简单的去细粒度的去划分具体的哪个请求去拦截,可以利用其去处理整个粗粒度的拦 截<br>而Servlet Filter和Spring Interceptor都是去拦 截某一个单一请求,更加细粒度,如果有框架的情况下,对于细粒度的拦 截,拦 截器更加合适,因为分为了两个函数,职责更加单一,而且更方便去配置,而且本身受容器管理,能够方便的获取一些数据库的连接,对于粗粒度的拦截,例如登录,使用Filter更加合适,返回和处理速度更快<br><br>对于问题2,<br>看着上面同学提供的Dubbo Filter的核心处理逻辑和Netty ChannelPipeline的核心处理逻辑,又学到一课<br>我个人是之前没有看过的,但是在我做过的项目中,对于一些数据的查询,也是一种简单的责任链,先从内存数据库中查询然后到关系型数据库查询<br>","like_count":0},{"had_liked":false,"id":196368,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1585275832,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585275832","product_id":100039001,"comment_content":"课堂讨论: <br>1.<br>    <br>    访问控制的本质是拦截, 就好像去火车站坐火车, 需要检票这样一个流程, 只有你的票能对应车次, 才可以上车.<br>作为一名前端开发, 虽然没有写过后端业务, 但我认为应使用Interceptor实现. 鉴相关的访问控制是业务的一环, 应采用业务流程处理.<br>    <br>","like_count":0},{"had_liked":false,"id":196365,"user_name":"吴小智","can_delete":false,"product_type":"c1","uid":1310798,"ip_address":"","ucode":"C7C9F58B5C9F7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","comment_is_top":false,"comment_ctime":1585275811,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585275811","product_id":100039001,"comment_content":"针对问题一：感觉依据还是看 scope ，看影响范围，如果是很底层的功能，用 Filter 这种方式，放在请求最开始的时候使用；针对某些接口有用的话，就用 AOP 这种方式，基于代理来使用。<br><br>Servlet Filter ，chain 调 filter，filter 在调用 chain ，用互相调用的方式来形成递归。","like_count":0},{"had_liked":false,"id":196249,"user_name":"will","can_delete":false,"product_type":"c1","uid":1156207,"ip_address":"","ucode":"7A7DBE3E0EEAEB","user_header":"https://static001.geekbang.org/account/avatar/00/11/a4/6f/672a27d4.jpg","comment_is_top":false,"comment_ctime":1585266973,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585266973","product_id":100039001,"comment_content":"加深了对这个设计模式的理解，联想到okhttp也是使用这种模式来设计的。问题一，使用哪种方式主要看使用场景，比如日志相关的，可以使用aop这种方式，如果是全局的，可以使用servlet这种方式。","like_count":0}]}