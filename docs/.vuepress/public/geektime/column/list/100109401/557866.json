{"id":557866,"title":"74｜RESTful Web Services（38）：如何提取方法调用部分？","content":"<p>你好，我是徐昊。今天我们继续使用TDD的方式实现RESTful Web Services。</p><h2>回顾架构愿景与任务列表</h2><p><img src=\"https://static001.geekbang.org/resource/image/c1/bd/c1a8d4b80fcf2c009a448d996594b6bd.jpg?wh=2284x1264\" alt=\"\"><br>\n<img src=\"https://static001.geekbang.org/resource/image/fd/06/fd32fcbe73cb3d406f7473a0798a8d06.jpg?wh=2284x1285\" alt=\"\"></p><p>目前的任务列表：</p><ul>\n<li>Resource/RootResource/ResourceMethods\n<ul>\n<li>当HEAD方法映射到GET方法时，忽略GET的返回值</li>\n<li>当没有OPTIONS方法时，提供默认实现</li>\n</ul>\n</li>\n</ul><p>代码为：</p><pre><code>package geektime.tdd.rest;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.ws.rs.HttpMethod;\nimport jakarta.ws.rs.Path;\nimport jakarta.ws.rs.PathParam;\nimport jakarta.ws.rs.QueryParam;\nimport jakarta.ws.rs.container.ResourceContext;\nimport jakarta.ws.rs.core.GenericEntity;\nimport jakarta.ws.rs.core.HttpHeaders;\nimport jakarta.ws.rs.core.Response;\nimport jakarta.ws.rs.core.UriInfo;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Parameter;\nimport java.lang.reflect.Type;\nimport java.util.*;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\nimport static geektime.tdd.rest.DefaultResourceMethod.ValueConverter.singeValued;\nimport static java.util.Arrays.stream;\ninterface ResourceRouter {\n    OutboundResponse dispatch(HttpServletRequest request, ResourceContext resourceContext);\n    interface Resource extends UriHandler {\n        Optional&lt;ResourceMethod&gt; match(UriTemplate.MatchResult result, String httpMethod, String[] mediaTypes, ResourceContext resourceContext, UriInfoBuilder builder);\n    }\n    interface ResourceMethod extends UriHandler {\n        String getHttpMethod();\n        GenericEntity&lt;?&gt; call(ResourceContext resourceContext, UriInfoBuilder builder);\n    }\n}\nclass DefaultResourceRouter implements ResourceRouter {\n    private Runtime runtime;\n    private List&lt;Resource&gt; rootResources;\n    public DefaultResourceRouter(Runtime runtime, List&lt;Resource&gt; rootResources) {\n        this.runtime = runtime;\n        this.rootResources = rootResources;\n    }\n    @Override\n    public OutboundResponse dispatch(HttpServletRequest request, ResourceContext resourceContext) {\n        String path = request.getServletPath();\n        UriInfoBuilder uri = runtime.createUriInfoBuilder(request);\n        Optional&lt;ResourceMethod&gt; method = UriHandlers.mapMatched(path, rootResources, (result, resource) -&gt; findResourceMethod(request, resourceContext, uri, result, resource));\n        if (method.isEmpty()) return (OutboundResponse) Response.status(Response.Status.NOT_FOUND).build();\n        return (OutboundResponse) method.map(m -&gt; m.call(resourceContext, uri))\n                .map(entity -&gt; (entity.getEntity() instanceof OutboundResponse) ? (OutboundResponse) entity.getEntity() : Response.ok(entity).build())\n                .orElseGet(() -&gt; Response.noContent().build());\n    }\n    private Optional&lt;ResourceMethod&gt; findResourceMethod(HttpServletRequest request, ResourceContext resourceContext, UriInfoBuilder uri, Optional&lt;UriTemplate.MatchResult&gt; matched, Resource handler) {\n        return handler.match(matched.get(), request.getMethod(),\n                Collections.list(request.getHeaders(HttpHeaders.ACCEPT)).toArray(String[]::new), resourceContext, uri);\n    }\n}\n    \nclass DefaultResourceMethod implements ResourceRouter.ResourceMethod {\n    private String httpMethod;\n    private UriTemplate uriTemplate;\n    private Method method;\n    public DefaultResourceMethod(Method method) {\n        this.method = method;\n        this.uriTemplate = new PathTemplate(Optional.ofNullable(method.getAnnotation(Path.class)).map(Path::value).orElse(&quot;&quot;));\n        this.httpMethod = stream(method.getAnnotations()).filter(a -&gt; a.annotationType().isAnnotationPresent(HttpMethod.class))\n                .findFirst().get().annotationType().getAnnotation(HttpMethod.class).value();\n    }\n    @Override\n    public String getHttpMethod() {\n        return httpMethod;\n    }\n    @Override\n    public UriTemplate getUriTemplate() {\n        return uriTemplate;\n    }\n    @Override\n    public GenericEntity&lt;?&gt; call(ResourceContext resourceContext, UriInfoBuilder builder) {\n        try {\n            UriInfo uriInfo = builder.createUriInfo();\n            Object result = method.invoke(builder.getLastMatchedResource(),\n                    stream(method.getParameters()).map(parameter -&gt;\n                            injectParameter(parameter, uriInfo)\n                                    .or(() -&gt; injectContext(parameter, resourceContext, uriInfo))\n                                    .orElse(null)).toArray(Object[]::new));\n            return result != null ? new GenericEntity&lt;&gt;(result, method.getGenericReturnType()) : null;\n        } catch (IllegalAccessException | InvocationTargetException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    private Optional&lt;Object&gt; injectParameter(Parameter parameter, UriInfo uriInfo) {\n        return providers.stream().map(provider -&gt; provider.provide(parameter, uriInfo)).filter(Optional::isPresent)\n                .findFirst()\n                .flatMap(values -&gt; values.flatMap(v -&gt; convert(parameter, v)));\n    }\n    private Optional&lt;Object&gt; injectContext(Parameter parameter, ResourceContext resourceContext, UriInfo uriInfo) {\n        if (parameter.getType().equals(ResourceContext.class)) return Optional.of(resourceContext);\n        if (parameter.getType().equals(UriInfo.class)) return Optional.of(uriInfo);\n        return Optional.of(resourceContext.getResource(parameter.getType()));\n    }\n    private Optional&lt;Object&gt; convert(Parameter parameter, List&lt;String&gt; values) {\n        return PrimitiveConverter.convert(parameter, values)\n                .or(() -&gt; ConverterConstructor.convert(parameter.getType(), values.get(0)))\n                .or(() -&gt; ConverterFactory.convert(parameter.getType(), values.get(0)));\n    }\n    private static ValueProvider pathParam = (parameter, uriInfo) -&gt;\n            Optional.ofNullable(parameter.getAnnotation(PathParam.class))\n                    .map(annotation -&gt; uriInfo.getPathParameters().get(annotation.value()));\n    private static ValueProvider queryParam = (parameter, uriInfo) -&gt;\n            Optional.ofNullable(parameter.getAnnotation(QueryParam.class))\n                    .map(annotation -&gt; uriInfo.getQueryParameters().get(annotation.value()));\n    private static List&lt;ValueProvider&gt; providers = List.of(pathParam, queryParam);\n    interface ValueProvider {\n        Optional&lt;List&lt;String&gt;&gt; provide(Parameter parameter, UriInfo uriInfo);\n    }\n    interface ValueConverter&lt;T&gt; {\n        T fromString(List&lt;String&gt; values);\n        static &lt;T&gt; ValueConverter&lt;T&gt; singeValued(Function&lt;String, T&gt; converter) {\n            return values -&gt; converter.apply(values.get(0));\n        }\n    }\n    \n    @Override\n    public String toString() {\n        return method.getDeclaringClass().getSimpleName() + &quot;.&quot; + method.getName();\n    }\n}\nclass PrimitiveConverter {\n    private static Map&lt;Type, DefaultResourceMethod.ValueConverter&lt;Object&gt;&gt; primitives = Map.of(\n            int.class, singeValued(Integer::parseInt),\n            double.class, singeValued(Double::parseDouble),\n            short.class, singeValued(Short::parseShort),\n            float.class, singeValued(Float::parseFloat),\n            byte.class, singeValued(Byte::parseByte),\n            boolean.class, singeValued(Boolean::parseBoolean),\n            String.class, singeValued(s -&gt; s));\n    public static Optional&lt;Object&gt; convert(Parameter parameter, List&lt;String&gt; values) {\n        return Optional.ofNullable(primitives.get(parameter.getType()))\n                .map(c -&gt; c.fromString(values));\n    }\n}\nclass ConverterConstructor {\n    public static Optional&lt;Object&gt; convert(Class&lt;?&gt; converter, String value) {\n        try {\n            return Optional.of(converter.getConstructor(String.class).newInstance(value));\n        } catch (InstantiationException | IllegalAccessException | InvocationTargetException |\n                 NoSuchMethodException e) {\n            return Optional.empty();\n        }\n    }\n}\nclass ConverterFactory {\n    public static Optional&lt;Object&gt; convert(Class&lt;?&gt; converter, String value) {\n        try {\n            return Optional.of(converter.getMethod(&quot;valueOf&quot;, String.class).invoke(null, value));\n        } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n            return Optional.empty();\n        }\n    }\n}\nclass ResourceMethods {\n    private Map&lt;String, List&lt;ResourceRouter.ResourceMethod&gt;&gt; resourceMethods;\n    public ResourceMethods(Method[] methods) {\n        this.resourceMethods = getResourceMethods(methods);\n    }\n    private static Map&lt;String, List&lt;ResourceRouter.ResourceMethod&gt;&gt; getResourceMethods(Method[] methods) {\n        return stream(methods).filter(m -&gt; stream(m.getAnnotations())\n                        .anyMatch(a -&gt; a.annotationType().isAnnotationPresent(HttpMethod.class)))\n                .map(DefaultResourceMethod::new)\n                .collect(Collectors.groupingBy(ResourceRouter.ResourceMethod::getHttpMethod));\n    }\n    public Optional&lt;ResourceRouter.ResourceMethod&gt; findResourceMethods(String path, String method) {\n        return findMethod(path, method).or(() -&gt; findAlternative(path, method));\n    }\n    private Optional&lt;ResourceRouter.ResourceMethod&gt; findAlternative(String path, String method) {\n        if (HttpMethod.HEAD.equals(method)) return findMethod(path, HttpMethod.GET).map(HeadResourceMethod::new);\n        if (HttpMethod.OPTIONS.equals(method)) return Optional.of(new OptionResourceMethod(path));\n        return Optional.empty();\n    }\n    private Optional&lt;ResourceRouter.ResourceMethod&gt; findMethod(String path, String method) {\n        return Optional.ofNullable(resourceMethods.get(method)).flatMap(methods -&gt; UriHandlers.match(path, methods, r -&gt; r.getRemaining() == null));\n    }\n    class OptionResourceMethod implements ResourceRouter.ResourceMethod {\n        private String path;\n        public OptionResourceMethod(String path) {\n            this.path = path;\n        }\n        @Override\n        public String getHttpMethod() {\n            return HttpMethod.OPTIONS;\n        }\n        @Override\n        public GenericEntity&lt;?&gt; call(ResourceContext resourceContext, UriInfoBuilder builder) {\n            return new GenericEntity&lt;&gt;(Response.noContent().allow(findAllowedMethods()).build(), Response.class);\n        }\n        private Set&lt;String&gt; findAllowedMethods() {\n            Set&lt;String&gt; allowed = List.of(HttpMethod.GET, HttpMethod.HEAD, HttpMethod.OPTIONS, HttpMethod.PUT,\n                            HttpMethod.POST, HttpMethod.DELETE, HttpMethod.PATCH).stream()\n                    .filter(method -&gt; findMethod(path, method).isPresent()).collect(Collectors.toSet());\n            allowed.add(HttpMethod.OPTIONS);\n            if (allowed.contains(HttpMethod.GET)) allowed.add(HttpMethod.HEAD);\n            return allowed;\n        }\n        @Override\n        public UriTemplate getUriTemplate() {\n            return new PathTemplate(path);\n        }\n    }\n}\nclass HeadResourceMethod implements ResourceRouter.ResourceMethod {\n    ResourceRouter.ResourceMethod method;\n    public HeadResourceMethod(ResourceRouter.ResourceMethod method) {\n        this.method = method;\n    }\n    @Override\n    public String getHttpMethod() {\n        return HttpMethod.HEAD;\n    }\n    @Override\n    public GenericEntity&lt;?&gt; call(ResourceContext resourceContext, UriInfoBuilder builder) {\n        method.call(resourceContext, builder);\n        return null;\n    }\n    @Override\n    public UriTemplate getUriTemplate() {\n        return method.getUriTemplate();\n    }\n}\nclass SubResourceLocators {\n    private final List&lt;ResourceRouter.Resource&gt; subResourceLocators;\n    public SubResourceLocators(Method[] methods) {\n        subResourceLocators = stream(methods).filter(m -&gt; m.isAnnotationPresent(Path.class) &amp;&amp;\n                        stream(m.getAnnotations()).noneMatch(a -&gt; a.annotationType().isAnnotationPresent(HttpMethod.class)))\n                .map((Function&lt;Method, ResourceRouter.Resource&gt;) SubResourceLocator::new).toList();\n    }\n    public Optional&lt;ResourceRouter.ResourceMethod&gt; findSubResourceMethods(String path, String method, String[] mediaTypes, ResourceContext resourceContext, UriInfoBuilder builder) {\n        return UriHandlers.mapMatched(path, subResourceLocators, (result, locator) -&gt; locator.match(result.get(), method, mediaTypes, resourceContext, builder));\n    }\n    static class SubResourceLocator implements ResourceRouter.Resource {\n        private PathTemplate uriTemplate;\n        private Method method;\n        public SubResourceLocator(Method method) {\n            this.method = method;\n            this.uriTemplate = new PathTemplate(method.getAnnotation(Path.class).value());\n        }\n        @Override\n        public UriTemplate getUriTemplate() {\n            return uriTemplate;\n        }\n        @Override\n        public String toString() {\n            return method.getDeclaringClass().getSimpleName() + &quot;.&quot; + method.getName();\n        }\n        @Override\n        public Optional&lt;ResourceRouter.ResourceMethod&gt; match(UriTemplate.MatchResult result, String httpMethod, String[] mediaTypes, ResourceContext resourceContext, UriInfoBuilder builder) {\n            Object resource = builder.getLastMatchedResource();\n            try {\n                Object subResource = method.invoke(resource);\n                return new ResourceHandler(subResource, uriTemplate).match(result, httpMethod, mediaTypes, resourceContext, builder);\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n}\nclass ResourceHandler implements ResourceRouter.Resource {\n    private UriTemplate uriTemplate;\n    private ResourceMethods resourceMethods;\n    private SubResourceLocators subResourceLocators;\n    private Function&lt;ResourceContext, Object&gt; resource;\n\n    public ResourceHandler(Class&lt;?&gt; resourceClass) {\n        this(resourceClass, new PathTemplate(getTemplate(resourceClass)), rc -&gt; rc.getResource(resourceClass));\n    }\n    private static String getTemplate(Class&lt;?&gt; resourceClass) {\n        if (!resourceClass.isAnnotationPresent(Path.class)) throw new IllegalArgumentException();\n        return resourceClass.getAnnotation(Path.class).value();\n    }\n    public ResourceHandler(Object resource, UriTemplate uriTemplate) {\n        this(resource.getClass(), uriTemplate, rc -&gt; resource);\n    }\n    private ResourceHandler(Class&lt;?&gt; resourceClass, UriTemplate uriTemplate, Function&lt;ResourceContext, Object&gt; resource) {\n        this.uriTemplate = uriTemplate;\n        this.resourceMethods = new ResourceMethods(resourceClass.getMethods());\n        this.subResourceLocators = new SubResourceLocators(resourceClass.getMethods());\n        this.resource = resource;\n    }\n    @Override\n    public Optional&lt;ResourceRouter.ResourceMethod&gt; match(UriTemplate.MatchResult result, String httpMethod, String[] mediaTypes, ResourceContext resourceContext, UriInfoBuilder builder) {\n        builder.addMatchedResource(resource.apply(resourceContext));\n        String remaining = Optional.ofNullable(result.getRemaining()).orElse(&quot;&quot;);\n        return resourceMethods.findResourceMethods(remaining, httpMethod)\n                .or(() -&gt; subResourceLocators.findSubResourceMethods(remaining, httpMethod, mediaTypes, resourceContext, builder));\n    }\n    @Override\n    public UriTemplate getUriTemplate() {\n        return uriTemplate;\n    }\n}\n</code></pre><h2>视频演示</h2><p>进入今天的环节：</p><p><video poster=\"https://media001.geekbang.org/64a12c0571f44797b8105599d9a05d84/snapshots/ff9b01024ef141f39aa149611394543a-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/1fec2958-182e7cd373a-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/7bc87cc66c844c9e8fd64e0135c6e583/714abb6543a547efb71eb8a8fa15f6a5-2acf8db39d34bf769e99b0c4ffa5fa14-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><h2>思考题</h2><p>如何重构并复用测试？</p><p>欢迎把你的思考和想法分享在留言区，咱们下节课再见！</p><!-- [[[read_end]]] -->","neighbors":{"left":{"article_title":"73｜RESTful Web Services（37）：再增加converter方法时，步骤有什么不同？","id":555259},"right":{"article_title":"75｜RESTful Web Services（39）：如何使用继承的方式来复用测试？","id":557867}},"comments":[{"had_liked":false,"id":356394,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"浙江","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1662260869,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"看到开头想起了姚琪琳老师在微信讨论群中说的一句话:\nstatic 说明当前类没有依赖,是一个可以移出去的信号","like_count":0}]}