{"id":179282,"title":"12 | 软件设计的依赖倒置原则：如何不依赖代码却可以复用它的功能？","content":"<p>在软件开发过程中，我们经常会使用各种编程框架。如果你使用的是Java，那么你会比较熟悉Spring、MyBatis等。事实上，Tomcat、Jetty这类Web容器也可以归类为框架。框架的一个特点是，当开发者使用框架开发一个应用程序时，无需在程序中调用框架的代码，就可以使用框架的功能特性。比如程序不需要调用Spring的代码，就可以使用Spring的依赖注入，MVC这些特性，开发出低耦合、高内聚的应用代码。我们的程序更不需要调用Tomcat的代码，就可以监听HTTP协议端口，处理HTTP请求。</p><p>这些框架我们每天都在使用，已经司空见惯，所以觉得这种实现理所当然，但是我们停下好好想一想，难道不觉得这很神奇吗？我们自己也写代码，能够做到让其他工程师不调用我们的代码就可以使用我们的代码的功能特性吗？就我观察，大多数开发者是做不到的。那么Spring、Tomcat这些框架是如何做到的呢？</p><h2>依赖倒置原则</h2><p>我们看下Spring、Tomcat这些框架设计的核心关键点，也就是面向对象的基本设计原则之一：依赖倒置原则。</p><p>依赖倒置原则是这样的：</p><ul>\n<li>高层模块不应该依赖低层模块，二者都应该依赖抽象。</li>\n<li>抽象不应该依赖具体实现，具体实现应该依赖抽象。</li>\n</ul><!-- [[[read_end]]] --><p>软件分层设计已经是软件开发者的共识。事实上，最早引入软件分层设计，正是为了建立清晰的软件分层关系，便于高层模块依赖低层模块。一般的应用程序中，策略层会依赖方法层，业务逻辑层会依赖数据存储层。这正是我们日常软件设计开发的常规方式。</p><p>那么这种高层模块依赖低层模块的分层依赖方式有什么缺点呢？</p><p>一是维护困难，高层模块通常是业务逻辑和策略模型，是一个软件的核心所在。正是高层模块使一个软件区别于其他软件，而低层模块则更多的是技术细节。如果高层模块依赖低层模块，那么就是业务逻辑依赖技术细节，技术细节的改变将影响到业务逻辑，使业务逻辑也不得不做出改变。因为技术细节的改变而影响业务代码的改变，这是不合理的。</p><p>二是复用困难，通常越是高层模块，复用的价值越高。但如果高层模块依赖低层模块，那么对高层模块的依赖将会导致对底层模块的连带依赖，使复用变得困难。</p><p>事实上，在我们软件开发中，很多地方都使用了依赖倒置原则。我们在Java开发中访问数据库，代码并不直接依赖数据库的驱动，而是依赖JDBC。各种数据库的驱动都实现了JDBC，当应用程序需要更换数据库的时候，不需要修改任何代码。这正是因为应用代码，高层模块，不依赖数据库驱动，而是依赖抽象JDBC，而数据库驱动，作为低层模块，也依赖JDBC。</p><p>同样的，Java开发的Web应用也不需要依赖Tomcat这样的Web容器，只需要依赖J2EE规范，Web应用实现J2EE规范的Servlet接口，然后把应用程序打包通过Web容器启动就可以处理HTTP请求了。这个Web容器可以是Tomcat，也可以是Jetty，任何实现了J2EE规范的Web容器都可以。同样，高层模块不依赖低层模块，大家都依赖J2EE规范。</p><p>其他我们熟悉的MVC框架，ORM框架，也都遵循依赖倒置原则。</p><h2>依赖倒置的关键是接口所有权的倒置</h2><p>下面，我们进一步了解下依赖倒置原则的设计原理，看看如何在我们的程序设计开发中也能利用依赖倒置原则，开发出更少依赖、更低耦合、更可复用的代码。</p><p>这是我们习惯上的层次依赖示例，策略层依赖方法层，方法层依赖工具层。</p><p><img src=\"https://static001.geekbang.org/resource/image/46/df/4642c03ba5b5f36baac550326e0943df.png?wh=471*181\" alt=\"\"></p><p>这样分层依赖的一个潜在问题是，策略层对方法层和工具层是传递依赖的，下面两层的任何改动都会导致策略层的改动，这种传递依赖导致的级联改动可能会导致软件维护过程非常糟糕。</p><p>解决办法是利用依赖倒置的设计原则，每个高层模块都为它所需要的服务声明一个抽象接口，而低层模块则实现这些抽象接口，高层模块通过抽象接口使用低层模块。</p><p><img src=\"https://static001.geekbang.org/resource/image/80/7e/80d012cfab510eb1d4e7a57ab2f6277e.png?wh=920*688\" alt=\"\"></p><p>这样，高层模块就不需要直接依赖低层模块，而变成了低层模块依赖高层模块定义的抽象接口，从而实现了依赖倒置，解决了策略层、方法层、工具层的传递依赖问题。</p><p>我们日常的开发通常也要依赖抽象接口，而不是依赖具体实现。比如Web开发中，Service层依赖DAO层，并不是直接依赖DAO的具体实现，而是依赖DAO提供的抽象接口。那么这种依赖是否是依赖倒置呢？其实并不是，依赖倒置原则中，除了具体实现要依赖抽象，最重要的是，抽象是属于谁的抽象。</p><p>通常的编程习惯中，低层模块拥有自己的接口，高层模块依赖低层模块提供的接口，比如方法层有自己的接口，策略层依赖方法层的接口；DAO层定义自己的接口，Service层依赖DAO层定义的接口。</p><p>但是按照依赖倒置原则，接口的所有权是被倒置的，也就是说，接口被高层模块定义，高层模块拥有接口，低层模块实现接口。不是高层模块依赖底层模块的接口，而是低层模块依赖高层模块的接口，从而实现依赖关系的倒置。</p><p>在上面的依赖层次中，每一层的接口都被高层模块定义，由低层模块实现，高层模块完全不依赖低层模块，即使是低层模块的接口。这样，低层模块的改动不会影响高层模块，高层模块的复用也不会依赖低层模块。对于Service和DAO这个例子来说，就是Service定义接口，DAO实现接口，这样才符合依赖倒置原则。</p><h2>使用依赖倒置实现高层模块复用</h2><p>依赖倒置原则适用于一个类向另一个类发送消息的场景。我们再看一个例子。</p><p>Button按钮控制Lamp灯泡，按钮按下的时候，灯泡点亮或者关闭。按照常规的设计思路，我们可能会设计出如下的类图关系，Button类直接依赖Lamp类。</p><p><img src=\"https://static001.geekbang.org/resource/image/bd/2a/bd66b7500645cff489244fb6b1a85a2a.png?wh=937*213\" alt=\"\"></p><p>这样设计的问题在于，Button依赖Lamp，那么对Lamp的任何改动，都可能会使Button受到牵连，做出联动的改变。同时，我们也无法重用Button类，比如，我们期望通过Button控制一个电机的启动或者停止，这种设计显然难以重用Button，因为我们的Button还依赖着Lamp呢。</p><p>解决之道就是将这个设计中的依赖于实现，重构为依赖于抽象。这里的抽象就是：打开关闭目标对象。至于具体的实现细节，比如开关指令如何产生，目标对象是什么，都不重要。这是重构后的设计。</p><p><img src=\"https://static001.geekbang.org/resource/image/48/06/48774cef9ca8ee0a44797c4482820b06.png?wh=887*472\" alt=\"\"></p><p>由Button定义一个抽象接口ButtonServer；在ButtonServer中描述抽象：打开、关闭目标对象。由具体的目标对象，比如Lamp实现这个接口，从而完成Button控制Lamp这一功能需求。</p><p>通过这样一种依赖倒置，Button不再依赖Lamp，而是依赖抽象ButtonServer，而Lamp也依赖ButtonServer，高层模块和低层模块都依赖抽象。Lamp的改动不会再影响Button，而Button 可以复用控制其他目标对象，比如电机，或者任何由按钮控制的设备，只要这些设备实现ButtonServer接口就可以了。</p><p>这里再强调一次，抽象接口ButtonServer的所有权是倒置的，它不属于底层模块Lamp，而是属于高层模块Button。我们从命名上也能看的出来，这正是依赖倒置原则的精髓所在。</p><p>这也正好回答了开头提出的问题：如何使其他工程师不调用我们的代码，就能使用我们代码的功能特性？如果我们是Button的开发者，那么只要其他工程师的代码实现了我们定义的ButtonServer接口，Button就可以调用他们开发的Lamp或者其他任何由按钮控制的设备，使设备代码拥有了按钮功能。设备的代码开发者不需要调用Button的代码，就拥有了Button的功能，而我们，也不需要关心Button会在什么样的设备代码中使用，所有实现ButtonServer的设备都可以使用Button功能。</p><p>所以依赖倒置原则也被称为好莱坞原则：Don’t call me，I will call you. 即不要来调用我，我会调用你。Tomcat、Spring都是基于这一原则设计出来的，应用程序不需要调用Tomcat或者Spring这样的框架，而是框架调用应用程序。而实现这一特性的前提就是应用程序必须实现框架的接口规范，比如实现Servlet接口。</p><h2>小结</h2><p>依赖倒置原则通俗说就是，高层模块不依赖低层模块，而是都依赖抽象接口，这个抽象接口通常是由高层模块定义，低层模块实现。</p><p>遵循依赖倒置原则有这样几个编码守则：</p><ol>\n<li>应用代码中多使用抽象接口，尽量避免使用那些多变的具体实现类。</li>\n<li>不要继承具体类，如果一个类在设计之初不是抽象类，那么尽量不要去继承它。对具体类的继承是一种强依赖关系，维护的时候难以改变。</li>\n<li>不要重写（override）包含具体实现的函数。</li>\n</ol><p>依赖倒置原则最典型的使用场景就是框架的设计。框架提供框架核心功能，比如HTTP处理，MVC等，并提供一组接口规范，应用程序只需要遵循接口规范编程，就可以被框架调用。程序使用框架的功能，但是不调用框架的代码，而是实现框架的接口，被框架调用，从而框架有更高的可复用性，被应用于各种软件开发中。</p><p>我们的代码开发也可以按照依赖倒置原则，参考框架的设计理念，开发出灵活、低耦合、可复用的软件代码。</p><p>软件开发有时候像变魔术一样，常常表现出违反常识的特性，让人目眩神晕，而这正是软件编程这门艺术的魅力所在，感受到这种魅力，在自己的软件设计开发中体现出这种魅力，你就迈进了软件高手的大门。</p><h2>思考题</h2><p>除了文中的例子，还有哪些软件设计遵循了依赖倒置原则？这些软件中，底层模块和高层模块共同依赖的抽象是什么？</p><p>欢迎你在评论区写下你的思考，也欢迎把这篇文章分享给你的朋友或者同事，一起交流一下。</p>","comments":[{"had_liked":false,"id":162873,"user_name":"山猫","can_delete":false,"product_type":"c1","uid":1466682,"ip_address":"","ucode":"004F622AEDA906","user_header":"https://static001.geekbang.org/account/avatar/00/16/61/3a/a259c187.jpg","comment_is_top":false,"comment_ctime":1576627657,"is_pvip":false,"replies":[{"id":"61898","content":"这个解释精彩😁","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1576634433,"ip_address":"","comment_id":162873,"utype":1}],"discussion_count":8,"race_medal":0,"score":"254979698121","product_id":100040201,"comment_content":"依赖倒置这个东西懂得人是真懂，不懂的人是一点不懂。当初为了搞懂依赖倒置原则花了相当长时间去阅读大量的文章和书籍，看了很多代码事例，后来又看了面对对象设计原则才算基本理解。<br><br>之前给公司开发培训，他们仍旧听的一脸懵逼，觉得这是个噱头。直到我跟他们说：老板就是找个写代码的人，别把自己看的那么重。你们每天写那么多bug，别怪老板说要换人。他们才理解！","like_count":60,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478170,"discussion_content":"这个解释精彩😁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576634433,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1120348,"avatar":"https://static001.geekbang.org/account/avatar/00/11/18/5c/1a58e8f6.jpg","nickname":"草原上的奔跑","note":"","ucode":"D69C617F767736","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87156,"discussion_content":"老板不依赖任何员工，老板制定公司标准规范，员工遵守规范干活，嫌干的不好的，换实现(换人)","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1576648355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1934969,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/86/79/066a062a.jpg","nickname":"非同凡想","note":"","ucode":"713FD449A49D5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215111,"discussion_content":"这个解释厉害，老板定义任务，程序员A可以实现任务，B也可以","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1585286239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1346998,"avatar":"https://static001.geekbang.org/account/avatar/00/14/8d/b6/55ba741a.jpg","nickname":"wiliam","note":"","ucode":"FF15363E72887A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337232,"discussion_content":"我去，醍醐灌顶，真厉害，赞赞赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608827659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1338179,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6b/43/7a2350e3.jpg","nickname":"Ek","note":"","ucode":"58F23205E632DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":210214,"discussion_content":"不能用代码举例的 都是很无力的举证。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584714168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1466682,"avatar":"https://static001.geekbang.org/account/avatar/00/16/61/3a/a259c187.jpg","nickname":"山猫","note":"","ucode":"004F622AEDA906","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1338179,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6b/43/7a2350e3.jpg","nickname":"Ek","note":"","ucode":"58F23205E632DE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215081,"discussion_content":"没有明白你想表达的意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585281539,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":210214,"ip_address":""},"score":215081,"extra":""}]},{"author":{"id":1194395,"avatar":"https://static001.geekbang.org/account/avatar/00/12/39/9b/fc21f943.jpg","nickname":"睡浴缸的人","note":"","ucode":"AAA7476707D82F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":139873,"discussion_content":"666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579324663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015730,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/b2/e0e34ef1.jpg","nickname":"spence","note":"","ucode":"146DE349A7FDDB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87080,"discussion_content":"这个解释厉害了！佩服！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576641468,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164787,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1577091829,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"108951274229","product_id":100040201,"comment_content":"电力系统用了依赖倒置原则，电力系统规定了用电的业务逻辑和插座接口，家用电器只要符合插座接口即可使用。","like_count":26},{"had_liked":false,"id":163641,"user_name":"唐二毛","can_delete":false,"product_type":"c1","uid":1597884,"ip_address":"","ucode":"7C16F45165F4BA","user_header":"https://static001.geekbang.org/account/avatar/00/18/61/bc/a656bee7.jpg","comment_is_top":false,"comment_ctime":1576758969,"is_pvip":false,"replies":[{"id":"62296","content":"首先，依赖倒置后Service定义接口，DAO实现接口，不会导致变化更频繁，至少不会比原来DAO定义接口更频繁，因为从纯粹代码角度看，这个接口所有权的变化，换汤不换药，跟以前一样的。当然建议你用DDD的一些设计思路去设计服务和仓储，才能真正体现依赖倒置的优势，设计更稳定。<br><br>其次，即使仅仅换汤不换药，也可以强迫设计者从Service的角度去设计接口，而不是从DAO角度设计接口，从而使接口的设计更加符合业务特点。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1576813639,"ip_address":"","comment_id":163641,"utype":1}],"discussion_count":2,"race_medal":0,"score":"66001268409","product_id":100040201,"comment_content":"疑问: 按照我的理解，上层定义接口，对应到项目(传统三层架构)，就是controller 层定义 service 层的接口，service层定义 dao层的接口，是这样吗？ DI的目的是减少功能变化时，对代码的修改，可是我发现一旦这么做的时候，不但不能减少，反而会增加，因为功能的变化一般都是最上层的变化，比如: 参数的增加，减少，参数中字段的增加，减少，修改，这样的每一个变化都会影响到每一层的接口，所以在每一次功能变化的时候，都需要将整个调用链路的代码修改。 如果每层之间都加了防腐层，那每次变化都陷入到繁琐的改字段，测试字段之中。所有的unit test也要跟着变。这样真就是完完全全的牵一发而动全身!  有时我甚至觉得，把一个功能缩在一个类中，反而会更简单! 希望老师务必解答我的疑问，这个问题困扰我很久了!","like_count":15,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478483,"discussion_content":"首先，依赖倒置后Service定义接口，DAO实现接口，不会导致变化更频繁，至少不会比原来DAO定义接口更频繁，因为从纯粹代码角度看，这个接口所有权的变化，换汤不换药，跟以前一样的。当然建议你用DDD的一些设计思路去设计服务和仓储，才能真正体现依赖倒置的优势，设计更稳定。\n\n其次，即使仅仅换汤不换药，也可以强迫设计者从Service的角度去设计接口，而不是从DAO角度设计接口，从而使接口的设计更加符合业务特点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576813639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1192732,"avatar":"https://static001.geekbang.org/account/avatar/00/12/33/1c/59a4e803.jpg","nickname":"青舟","note":"","ucode":"2651482AC0DEC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292636,"discussion_content":"依赖倒置解决的是底层模块的修改对上层模块的影响，比如替换数据库不要修改service代码。\n\n业务层复杂多变，底层只能跟着变化，这是没有办法的事情，比如用户信息中添加一个字段。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1595292293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163021,"user_name":"台风骆骆","can_delete":false,"product_type":"c1","uid":1170748,"ip_address":"","ucode":"891D3599644ABD","user_header":"https://static001.geekbang.org/account/avatar/00/11/dd/3c/a595eb2a.jpg","comment_is_top":false,"comment_ctime":1576641405,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"48821281661","product_id":100040201,"comment_content":"我觉得linux的vfs也是这种依赖倒置的，vfs定义一组通用的函数，如read,write,open,close，具体的文件系统实现这些接口，系统调用的时候去调用file结构中的f_op（对应具体的文件系统操作）。","like_count":11},{"had_liked":false,"id":169981,"user_name":"Knuth","can_delete":false,"product_type":"c1","uid":1083616,"ip_address":"","ucode":"21298EF9BBB91A","user_header":"https://static001.geekbang.org/account/avatar/00/10/88/e0/292508a4.jpg","comment_is_top":false,"comment_ctime":1578487383,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18758356567","product_id":100040201,"comment_content":"看了以后，最大的感觉是为了开闭原则而开闭原则，提出了一系列的设计模式，感觉在讲述的过程中缺少一些推理和比较，直接就给结论，觉得很生硬","like_count":4},{"had_liked":false,"id":203426,"user_name":"devilyaos","can_delete":false,"product_type":"c1","uid":1064902,"ip_address":"","ucode":"5FE075608F03F7","user_header":"https://static001.geekbang.org/account/avatar/00/10/3f/c6/c2bf55bd.jpg","comment_is_top":false,"comment_ctime":1586187969,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14471089857","product_id":100040201,"comment_content":"我觉得这里要引用下我刚入行的时候师傅教导的，程序要自上而下设计，其实mvc三层都是高层先向下设计接口，可以理解成controller定义了要用哪些service功能，然后才针对这个接口建service实现，dao同理。所以其实不要把传统分层的接口当成该层强制规范的接口，其实是上层对下层的契约。","like_count":3},{"had_liked":false,"id":163232,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1576673940,"is_pvip":true,"replies":[{"id":"62022","content":"根据调用关系，高层模块调用低层模块。即使是设计的时候依赖关系被倒置了，调用的时候也还是高层调用低层。<br>","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1576676947,"ip_address":"","comment_id":163232,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14461575828","product_id":100040201,"comment_content":"高层模块和底层模块是依据什么划分的？","like_count":3,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478308,"discussion_content":"根据调用关系，高层模块调用低层模块。即使是设计的时候依赖关系被倒置了，调用的时候也还是高层调用低层。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576676947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172821,"user_name":"睡浴缸的人","can_delete":false,"product_type":"c1","uid":1194395,"ip_address":"","ucode":"AAA7476707D82F","user_header":"https://static001.geekbang.org/account/avatar/00/12/39/9b/fc21f943.jpg","comment_is_top":false,"comment_ctime":1579325229,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10169259821","product_id":100040201,"comment_content":"老师说MVC不满足依赖倒置原则，这个我去年写一年业务代码的时候真的感觉到了。发现都是先想怎么写好sql，然后从dao-&gt;service-&gt;controller。陷入MVC框架里出不来，感觉是披着OOP的皮在写面向过程的代码。后来看了DDD才知道这是一种贫血性模式导致的结果。现在写通用模块的时候，就特别注意这些设计原则，感觉抽象能力真的太重要了!","like_count":2,"discussions":[{"author":{"id":1020525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","nickname":"escray","note":"","ucode":"1F4204930E47C4","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308380,"discussion_content":"有一点好奇，老师哪里有说“MVC不满足依赖倒置原则”？\n\n我看到的原文是“其他我们熟悉的 MVC 框架，ORM 框架，也都遵循依赖倒置原则。”，专栏中还有其他两处提到 MVC，也都没有说不满足依赖倒置。\n\n是音频中的口误么？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600933751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303864,"user_name":"王艺霖","can_delete":false,"product_type":"c1","uid":1113992,"ip_address":"","ucode":"351C456CAEAD25","user_header":"https://static001.geekbang.org/account/avatar/00/10/ff/88/1da2546f.jpg","comment_is_top":false,"comment_ctime":1627033833,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5922001129","product_id":100040201,"comment_content":"service层定义dao层的接口，老师能给个例子吗？思维固化了，不知道该怎么写了","like_count":1},{"had_liked":false,"id":175843,"user_name":"池渊","can_delete":false,"product_type":"c1","uid":1473985,"ip_address":"","ucode":"7FDF74531C11E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/7d/c1/b7e69295.jpg","comment_is_top":false,"comment_ctime":1580869185,"is_pvip":false,"replies":[{"id":"68375","content":"依赖倒置强调：接口使用者定义接口，而不是接口实现者定义接口。<br><br>面向接口编程的概念比较泛，通常不强调接口是谁定义的。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1580887113,"ip_address":"","comment_id":175843,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5875836481","product_id":100040201,"comment_content":"怎么觉得依赖倒置和面向接口编程说的是同一个东西，是哪里理解有误吗？老师帮解答下","like_count":1,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482925,"discussion_content":"依赖倒置强调：接口使用者定义接口，而不是接口实现者定义接口。\n\n面向接口编程的概念比较泛，通常不强调接口是谁定义的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580887113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167132,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1577696965,"is_pvip":false,"replies":[{"id":"64899","content":"👍 建议看完模块二再回头看一遍，要计较的😁","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1577699765,"ip_address":"","comment_id":167132,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5872664261","product_id":100040201,"comment_content":"懂了懂了，看了3遍，听了3遍，基本理解，但是也不能太刻板的认为一定得是高层定义接口吧，只要都依赖抽象感觉就行了，不需要太计较这个抽象层在哪吧","like_count":1,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479755,"discussion_content":"👍 建议看完模块二再回头看一遍，要计较的😁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577699765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2063114,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7b/0a/b65e1fae.jpg","nickname":"不要挑战自己的智商","note":"","ucode":"4910FF07C35DC5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292813,"discussion_content":"作为一个高级程序员还是要计较的…设计的艺术就集中在如何设计抽象层 即方便上层调用 又方便下一次的拓展","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1595339355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163104,"user_name":"蓝魔丶","can_delete":false,"product_type":"c1","uid":1219438,"ip_address":"","ucode":"2AE4359E263558","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","comment_is_top":false,"comment_ctime":1576657449,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5871624745","product_id":100040201,"comment_content":"请教老师一个问题，文中讲到我们平时使用的mvc开发模式是不满足依赖倒置原则的，因为不是高层定义接口抽象，但是即便是低层定义接口，只要不修改接口只修改实现，也是感觉没问题的，有必要强调这里的所属者吗？这个指导思想一般只是指导框架实践吧，平时编写代码好像都不会考虑这个","like_count":1,"discussions":[{"author":{"id":1019069,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8c/bd/4895b166.jpg","nickname":"Chelizi","note":"","ucode":"B90CFDB5F7B900","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":235181,"discussion_content":"高层定义接口，是为了复用高层，什么样的高层会被复用，当然是稳定的高层，不稳定的高层无法定义接口。同理，如果要复用底层，则底层定义接口。因此，需要被复用的一方定义接口。为什么要面向接口编程，因为接口就是抽象，抽象意味着稳定。越抽象的东西越容易达成共识，越稳定持久，所以无论高层低层都要依赖抽象。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1587026740,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","nickname":"escray","note":"","ucode":"1F4204930E47C4","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308381,"discussion_content":"没有看到文中说 MVC 不满足依赖倒置，我觉得可能是要看如何实现 MVC 模型吧，如果是从数据库查询开始写起，那么很有可能是不满足依赖倒置的；如果是先定义好模型，那么比较容易实现依赖倒置。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600933999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111175,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f4/87/644c0c5d.jpg","nickname":"俊伟","note":"","ucode":"7905B4F25637F4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88603,"discussion_content":"我感觉双方基于抽象就行，不用那么死板。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576720384,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":349902,"user_name":"java小霸王","can_delete":false,"product_type":"c1","uid":1168540,"ip_address":"","ucode":"7094BCD9F25E1E","user_header":"https://static001.geekbang.org/account/avatar/00/11/d4/9c/030e80d3.jpg","comment_is_top":false,"comment_ctime":1656420029,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656420029","product_id":100040201,"comment_content":"不是高层模块依赖底层模块的接口，而是低层模块依赖高层模块的接口，从而实现依赖关系的倒置。","like_count":0},{"had_liked":false,"id":345749,"user_name":"老袁","can_delete":false,"product_type":"c1","uid":1215637,"ip_address":"","ucode":"0968F54699BCDB","user_header":"https://static001.geekbang.org/account/avatar/00/12/8c/95/a6d85a18.jpg","comment_is_top":false,"comment_ctime":1652546050,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652546050","product_id":100040201,"comment_content":"Service 定义接口，DAO 实现接口，这样才符合依赖倒置原则。 这句还是不太好理解，能贴上代码吗老师。","like_count":0},{"had_liked":false,"id":333935,"user_name":"Geek_8c0618","can_delete":false,"product_type":"c1","uid":2009485,"ip_address":"","ucode":"46AB431B57B32F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eocvvlibbfYw4wezziaBKn2OLDpvTndicPr21ZZoeiaM5QLibICy7PJPQibCAz5zfMe08ibem7ll3LSzkWaQ/132","comment_is_top":false,"comment_ctime":1644597951,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644597951","product_id":100040201,"comment_content":"大量的策略层 方法层 的描述 很困惑","like_count":0},{"had_liked":false,"id":290474,"user_name":"jackie","can_delete":false,"product_type":"c1","uid":1395192,"ip_address":"","ucode":"FFB7DE5DD7D31E","user_header":"https://static001.geekbang.org/account/avatar/00/15/49/f8/b0ba3823.jpg","comment_is_top":false,"comment_ctime":1619579493,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619579493","product_id":100040201,"comment_content":"上层确定要干啥，有不想管具体谁来做，虚拟一个具备这些技能“工具人”，当低层要做这个角色是自然而然变成“工具人”，不管你是谁你在上层都是一个“工具人”。","like_count":0},{"had_liked":false,"id":285650,"user_name":"kingcall","can_delete":false,"product_type":"c1","uid":1056982,"ip_address":"","ucode":"508884DC684B5B","user_header":"https://static001.geekbang.org/account/avatar/00/10/20/d6/b9513db0.jpg","comment_is_top":false,"comment_ctime":1616939241,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616939241","product_id":100040201,"comment_content":"小时候家里农田灌溉，由于夏天的时候水流有限，所以会统一将水收到水坝，需要灌溉的时候统一防水，每家每户只需要在自家地头打开`豁口`,统一开坝的时候水就进来了","like_count":0},{"had_liked":false,"id":283874,"user_name":"李怡尚","can_delete":false,"product_type":"c1","uid":2041832,"ip_address":"","ucode":"7DBF963206893D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/27/e8/f4a29498.jpg","comment_is_top":false,"comment_ctime":1615969340,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615969340","product_id":100040201,"comment_content":"多使用抽象接口少使用继承","like_count":0},{"had_liked":false,"id":279157,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1613639648,"is_pvip":false,"replies":[{"id":"101479","content":"Bean没有控制程序，是框架控制。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1613717483,"ip_address":"","comment_id":279157,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1613639648","product_id":100040201,"comment_content":"spring的依赖注入也是控制反转.从应用程序new Bean()变为给这段应用程序注入一个Bean,将Bean的获取由程序new变为框架注入.原本是应用程序控制具体的Bean,现在变为了Bean控制应用程序???? 头大 想不明白啊. 但是倒是符合程序不new Bean,Bean去自动注入程序.也就是好莱坞原则.","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515640,"discussion_content":"Bean没有控制程序，是框架控制。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613717483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":274549,"user_name":"程同学","can_delete":false,"product_type":"c1","uid":2418763,"ip_address":"","ucode":"622B71D5A2DA5E","user_header":"https://static001.geekbang.org/account/avatar/00/24/e8/4b/8ddf36b0.jpg","comment_is_top":false,"comment_ctime":1611056203,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611056203","product_id":100040201,"comment_content":"听懂了，膜拜大师","like_count":0},{"had_liked":false,"id":250099,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1600934587,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1600934587","product_id":100040201,"comment_content":"最早学到 SOLID 原则的时候，感觉依赖倒置原则是最难理解的，不过专栏的开篇就说，其实 Spring、Tomcat 这些框架都是依赖倒置，感觉一下子就捅破了窗户纸。<br><br>实现了一下文中提到的开灯的例子。<br><br>public interface ButtonServer {<br>     void turnOn();<br>     void turnOff();<br>}<br><br>class Lamp implements ButtonServer {<br>    public void turnOn() {<br>        System.out.println(&quot;Lamp On&quot;);<br>    }<br><br>    public void turnOff() {<br>        System.out.println(&quot;Lamp Off&quot;);<br>    }<br>}<br><br>class Button {<br>    ButtonServer bs;<br>    public void Button(ButtonServer buttonServer) {<br>        bs = buttonServer;<br>    }<br>    public void poll() {<br>        bs.turnOff();<br>        bs.turnOn();<br>    }<br>}<br><br>有一个小的疑问，本节中的 ButtonServer 中定义了两个方法 turnOn() 和 turnOff()，那么和上一节中策略模式里面 ButtonServer 中定义 buttonPressed(int token) 方法是不是有重叠的部分，我的意思是，本节中的 ButtonServer 是否也算是策略模式？<br><br>两个示意图中从 Button 指向 ButtonServer 的箭头不同，但是这个并不是决定因素。<br><br>很多人提到 MVC 模式违背了依赖倒置原则，我有点疑惑，可能是因为写法的不同。如果是从数据访问开始写，当然是违背了依赖倒置，但是如果是从建领域模型开始，那么很容易做到依赖倒置。","like_count":0},{"had_liked":false,"id":236181,"user_name":"不要挑战自己的智商","can_delete":false,"product_type":"c1","uid":2063114,"ip_address":"","ucode":"4910FF07C35DC5","user_header":"https://static001.geekbang.org/account/avatar/00/1f/7b/0a/b65e1fae.jpg","comment_is_top":false,"comment_ctime":1595339146,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1595339146","product_id":100040201,"comment_content":"看这个理论是非常抽象的；等你有了实际的依赖框架开发的经验后 就能秒懂这些概念了。不必纠结于现在看不懂。","like_count":0},{"had_liked":false,"id":230915,"user_name":"席席","can_delete":false,"product_type":"c1","uid":1591399,"ip_address":"","ucode":"656377E29D4F76","user_header":"https://static001.geekbang.org/account/avatar/00/18/48/67/128eda8f.jpg","comment_is_top":false,"comment_ctime":1593522058,"is_pvip":false,"replies":[{"id":"85786","content":"service调用Dao接口是反依赖倒置原则的","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1594002525,"ip_address":"","comment_id":230915,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1593522058","product_id":100040201,"comment_content":"李老师，既然依赖倒置设计原则是高层模块抽象接口，低层模块实现接口，那么为什么web项目中还要在service层抽象接口，然后再用接口调用低层Dao呢，是否多此一举？","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500072,"discussion_content":"service调用Dao接口是反依赖倒置原则的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594002525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1591399,"avatar":"https://static001.geekbang.org/account/avatar/00/18/48/67/128eda8f.jpg","nickname":"席席","note":"","ucode":"656377E29D4F76","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289145,"discussion_content":"李老师，反依赖倒置会产生什么好处，从您的文章中能够了解到依赖倒置的好处，但是反依赖倒置在实践中似乎并没有看到啥优点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594004826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223986,"user_name":"Seven.Lin澤耿","can_delete":false,"product_type":"c1","uid":1181192,"ip_address":"","ucode":"4CAB732CD6F149","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/08/855abb02.jpg","comment_is_top":false,"comment_ctime":1591249908,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591249908","product_id":100040201,"comment_content":"逆向思维，确实比较难理解，这么说的话，控制反转不能算？","like_count":0},{"had_liked":false,"id":196498,"user_name":"非同凡想","can_delete":false,"product_type":"c1","uid":1934969,"ip_address":"","ucode":"713FD449A49D5A","user_header":"https://static001.geekbang.org/account/avatar/00/1d/86/79/066a062a.jpg","comment_is_top":false,"comment_ctime":1585286490,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585286490","product_id":100040201,"comment_content":"终于懂了依赖倒置","like_count":0},{"had_liked":false,"id":190710,"user_name":"这就是编程","can_delete":false,"product_type":"c1","uid":1009348,"ip_address":"","ucode":"4091B3EB368E9F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/66/c4/e87a61ec.jpg","comment_is_top":false,"comment_ctime":1584685621,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584685621","product_id":100040201,"comment_content":"可以想到各种线程安全的api的设计，高层调用这些api,底层是各种方法去实现的线程安全。","like_count":0},{"had_liked":false,"id":176934,"user_name":"leslykay","can_delete":false,"product_type":"c1","uid":1004965,"ip_address":"","ucode":"12164CCCFF18CB","user_header":"","comment_is_top":false,"comment_ctime":1581231209,"is_pvip":false,"replies":[{"id":"68679","content":"从UML的语法应该虚线，实践中继承和泛化我一般没做区分，就是我在UML一篇提到的UML方言，不影响交流即可。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1581245082,"ip_address":"","comment_id":176934,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1581231209","product_id":100040201,"comment_content":"Lamp实现ButtonServer的那个UML图，是不是要改成虚线加空心三角形？","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483254,"discussion_content":"从UML的语法应该虚线，实践中继承和泛化我一般没做区分，就是我在UML一篇提到的UML方言，不影响交流即可。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581245082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175696,"user_name":"喵喵喵","can_delete":false,"product_type":"c1","uid":1211713,"ip_address":"","ucode":"E3AD8BF42E19DF","user_header":"https://static001.geekbang.org/account/avatar/00/12/7d/41/3c5b770b.jpg","comment_is_top":false,"comment_ctime":1580801841,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580801841","product_id":100040201,"comment_content":"打卡～","like_count":0},{"had_liked":false,"id":173480,"user_name":"虢國技醬","can_delete":false,"product_type":"c1","uid":1056807,"ip_address":"","ucode":"5A192262AA037E","user_header":"https://static001.geekbang.org/account/avatar/00/10/20/27/a6932fbe.jpg","comment_is_top":false,"comment_ctime":1579572116,"is_pvip":false,"replies":[{"id":"67267","content":"是的<br>","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1579591570,"ip_address":"","comment_id":173480,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1579572116","product_id":100040201,"comment_content":"看了这几篇我感觉：接口这种类型非常重要；接口定义的好坏代表了我们是否对一类操作“抽象”的恰当。<br>","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482080,"discussion_content":"是的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579591570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172970,"user_name":"InfoQ_e077cb303519","can_delete":false,"product_type":"c1","uid":1390669,"ip_address":"","ucode":"2CCA309DB2EF46","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLAK6F4BFT5ewhJEeZrjmRx5HxP8tvnNpJcpLlotHiadp0s6aL3d7LfMHEuQP6tibu80wUy8micVu4oQ/132","comment_is_top":false,"comment_ctime":1579400440,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579400440","product_id":100040201,"comment_content":"高层模块通过依赖底层模块的接口或者通过底层模块定义注解通过反射为高层模块提供功能，减少了高层模块直接依赖底层模块实现的耦合，提高了模块之间扩展性和维护性","like_count":0},{"had_liked":false,"id":169144,"user_name":"灰灰","can_delete":false,"product_type":"c1","uid":1122397,"ip_address":"","ucode":"907A2FD339E158","user_header":"https://static001.geekbang.org/account/avatar/00/11/20/5d/69170b96.jpg","comment_is_top":false,"comment_ctime":1578280242,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578280242","product_id":100040201,"comment_content":"打卡，受启发","like_count":0},{"had_liked":false,"id":164731,"user_name":"张希音","can_delete":false,"product_type":"c1","uid":1311065,"ip_address":"","ucode":"224D5FE01E14B4","user_header":"https://static001.geekbang.org/account/avatar/00/14/01/59/b2267eaa.jpg","comment_is_top":false,"comment_ctime":1577083336,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1577083336","product_id":100040201,"comment_content":"灯的那个那个例子让我想到了《Java 编程思想》每次都看一两章就拉下了，然后捡起来又是这两章。😂","like_count":0,"discussions":[{"author":{"id":1020525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","nickname":"escray","note":"","ucode":"1F4204930E47C4","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308383,"discussion_content":"背单词，每次都背到 abandon","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600934186,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164607,"user_name":"Zend","can_delete":false,"product_type":"c1","uid":1053921,"ip_address":"","ucode":"80EBB0B6772E27","user_header":"https://static001.geekbang.org/account/avatar/00/10/14/e1/ee5705a2.jpg","comment_is_top":false,"comment_ctime":1577059270,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577059270","product_id":100040201,"comment_content":"我们在开发Java Web 应用时肯定是要对数据进行检验的。其中JSR303-JavaBean Validation 是一个数据检验规范 ，我们在开发业务代码时，使用规范预定义好的注解即可，是不需调用其具体实现Hibernate Validator。","like_count":0},{"had_liked":false,"id":164552,"user_name":"Citizen Z","can_delete":false,"product_type":"c1","uid":1125104,"ip_address":"","ucode":"9CA547640A8629","user_header":"https://static001.geekbang.org/account/avatar/00/11/2a/f0/41590e10.jpg","comment_is_top":false,"comment_ctime":1577026449,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577026449","product_id":100040201,"comment_content":"老师可以具体阐述或举例说明下“策略层”、“方法层”、“工具层”的含义吗，是不是还有其他的层次名称的说法?","like_count":0},{"had_liked":false,"id":163449,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1576723983,"is_pvip":false,"replies":[{"id":"62124","content":"具体开发实践中，主要是用各种设计模式，而不是直接用设计原则去开发。设计模式也是基于设计原则的。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1576733897,"ip_address":"","comment_id":163449,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576723983","product_id":100040201,"comment_content":"其实看很多框架的一些类的UML图，基本都是顶层是一个抽象的父类，然好一大堆接口引用。现在知道是依赖倒置思想作指导，但我有一个问题，想我们即使去使用抽象父类，来复用代码，虽然不会产生实例，但是怎么设计这个父类呢？有什么指导思想？比如我设计一个鸟类，比如会飞这个方法，有的特例企鹅就是不会飞，还有筑巢也是这样，怎么设计最好呢，还是压根不用父类？","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478395,"discussion_content":"具体开发实践中，主要是用各种设计模式，而不是直接用设计原则去开发。设计模式也是基于设计原则的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576733897,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163428,"user_name":"俊伟","can_delete":false,"product_type":"c1","uid":1111175,"ip_address":"","ucode":"7905B4F25637F4","user_header":"https://static001.geekbang.org/account/avatar/00/10/f4/87/644c0c5d.jpg","comment_is_top":false,"comment_ctime":1576720285,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576720285","product_id":100040201,"comment_content":"网络协议里面的七层模型，不同的层之间就是基于抽象来建立的，上层不知道下层的存在，每层只需要专注当前层的逻辑","like_count":0},{"had_liked":false,"id":163372,"user_name":"隰有荷","can_delete":false,"product_type":"c1","uid":1357944,"ip_address":"","ucode":"2BE9A32AB28963","user_header":"https://static001.geekbang.org/account/avatar/00/14/b8/78/2828195b.jpg","comment_is_top":false,"comment_ctime":1576714923,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576714923","product_id":100040201,"comment_content":"受益良多，晚上就要试试写一写代码，来增加对这一原则的理解。改一个代码就跟株代码九族一样，到处找，累死了","like_count":0},{"had_liked":false,"id":163256,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1576676138,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1576676138","product_id":100040201,"comment_content":"按照文中的理解我们日常开发用的MVC是不符合依赖倒置的，若要满足依赖倒置就是的Control层抽象接口，Service层实现，Service层抽象接口DAO层去实现","like_count":0,"discussions":[{"author":{"id":1597884,"avatar":"https://static001.geekbang.org/account/avatar/00/18/61/bc/a656bee7.jpg","nickname":"唐二毛","note":"","ucode":"7C16F45165F4BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":89627,"discussion_content":"这么做，我想到一个坑，请看我的留言，解答我的疑惑，谢谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576759228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163209,"user_name":"夜空中最亮的星","can_delete":false,"product_type":"c1","uid":1267566,"ip_address":"","ucode":"ADC3E7B6789955","user_header":"https://static001.geekbang.org/account/avatar/00/13/57/6e/b6795c44.jpg","comment_is_top":false,"comment_ctime":1576670334,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576670334","product_id":100040201,"comment_content":"受启发","like_count":0},{"had_liked":false,"id":163102,"user_name":"蓝魔丶","can_delete":false,"product_type":"c1","uid":1219438,"ip_address":"","ucode":"2AE4359E263558","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","comment_is_top":false,"comment_ctime":1576657050,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576657050","product_id":100040201,"comment_content":"隔壁设计模式介绍的模版方法以及观察者模式都算依赖倒置","like_count":0},{"had_liked":false,"id":162889,"user_name":"探索无止境","can_delete":false,"product_type":"c1","uid":1044178,"ip_address":"","ucode":"91D2A9907DFA79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/d2/7024431c.jpg","comment_is_top":false,"comment_ctime":1576629026,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576629026","product_id":100040201,"comment_content":"如果再加上一段对tomcat或框架源码的对应解读就完美了","like_count":0},{"had_liked":false,"id":162888,"user_name":"丁丁历险记","can_delete":false,"product_type":"c1","uid":1661704,"ip_address":"","ucode":"A43829E454C067","user_header":"https://static001.geekbang.org/account/avatar/00/19/5b/08/b0b0db05.jpg","comment_is_top":false,"comment_ctime":1576628962,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576628962","product_id":100040201,"comment_content":"意图层被高层占用，更好的实现了意图和实现分离。<br>最基础的factory  实现的就是dip 原则","like_count":0},{"had_liked":false,"id":162836,"user_name":"盖瑞Chen","can_delete":false,"product_type":"c1","uid":1029547,"ip_address":"","ucode":"CAD57E0D9F4D3B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b5/ab/0a43c406.jpg","comment_is_top":false,"comment_ctime":1576600051,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1576600051","product_id":100040201,"comment_content":"好像生活中也有依赖倒置的例子，比如开车，你不依赖我，我也不依赖你，共同依赖交通法规。不知道这样理解对不对","like_count":0,"discussions":[{"author":{"id":1466682,"avatar":"https://static001.geekbang.org/account/avatar/00/16/61/3a/a259c187.jpg","nickname":"山猫","note":"","ucode":"004F622AEDA906","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":86799,"discussion_content":"个人觉得不对，开车并不是依赖交通法规，而是依赖驾驶员。驾驶员是一个职业接口，你我是这个职业的实体。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576627183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}