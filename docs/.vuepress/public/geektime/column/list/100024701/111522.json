{"id":111522,"title":"54 | å­˜å‚¨è™šæ‹ŸåŒ–ï¼ˆä¸‹ï¼‰ï¼šå¦‚ä½•å»ºç«‹è‡ªå·±ä¿ç®¡çš„å•ç‹¬æ¡£æ¡ˆåº“ï¼Ÿ","content":"<p>ä¸Šä¸€èŠ‚ï¼Œæˆ‘ä»¬è®²äº†qemuå¯åŠ¨è¿‡ç¨‹ä¸­çš„å­˜å‚¨è™šæ‹ŸåŒ–ã€‚å¥½äº†ï¼Œç°åœ¨qemuå¯åŠ¨äº†ï¼Œç¡¬ç›˜è®¾å¤‡æ–‡ä»¶å·²ç»æ‰“å¼€äº†ã€‚é‚£å¦‚æœæˆ‘ä»¬è¦å¾€è™šæ‹Ÿæœºçš„ä¸€ä¸ªè¿›ç¨‹å†™å…¥ä¸€ä¸ªæ–‡ä»¶ï¼Œè¯¥æ€ä¹ˆåšå‘¢ï¼Ÿæœ€ç»ˆè¿™ä¸ªæ–‡ä»¶åˆæ˜¯å¦‚ä½•è½åˆ°å®¿ä¸»æœºä¸Šçš„ç¡¬ç›˜æ–‡ä»¶çš„å‘¢ï¼Ÿè¿™ä¸€èŠ‚ï¼Œæˆ‘ä»¬ä¸€èµ·æ¥çœ‹ä¸€çœ‹ã€‚</p><h2>å‰ç«¯è®¾å¤‡é©±åŠ¨virtio_blk</h2><p>è™šæ‹Ÿæœºé‡Œé¢çš„è¿›ç¨‹å†™å…¥ä¸€ä¸ªæ–‡ä»¶ï¼Œå½“ç„¶è¦é€šè¿‡æ–‡ä»¶ç³»ç»Ÿã€‚æ•´ä¸ªè¿‡ç¨‹å’Œå’±ä»¬åœ¨<a href=\"https://time.geekbang.org/column/article/97876\">æ–‡ä»¶ç³»ç»Ÿ</a>é‚£ä¸€èŠ‚è®²çš„è¿‡ç¨‹æ²¡æœ‰åŒºåˆ«ã€‚åªæ˜¯åˆ°äº†è®¾å¤‡é©±åŠ¨å±‚ï¼Œæˆ‘ä»¬çœ‹åˆ°çš„å°±ä¸æ˜¯æ™®é€šçš„ç¡¬ç›˜é©±åŠ¨äº†ï¼Œè€Œæ˜¯virtioçš„é©±åŠ¨ã€‚</p><p>virtioçš„é©±åŠ¨ç¨‹åºä»£ç åœ¨Linuxæ“ä½œç³»ç»Ÿçš„æºä»£ç é‡Œé¢ï¼Œæ–‡ä»¶åå«drivers/block/virtio_blk.cã€‚</p><pre><code>static int __init init(void)\n{\n\tint error;\n\tvirtblk_wq = alloc_workqueue(&quot;virtio-blk&quot;, 0, 0);\n\tmajor = register_blkdev(0, &quot;virtblk&quot;);\n\terror = register_virtio_driver(&amp;virtio_blk);\n......\n}\n\nmodule_init(init);\nmodule_exit(fini);\n\nMODULE_DEVICE_TABLE(virtio, id_table);\nMODULE_DESCRIPTION(&quot;Virtio block driver&quot;);\nMODULE_LICENSE(&quot;GPL&quot;);\n\nstatic struct virtio_driver virtio_blk = {\n......\n\t.driver.name\t\t\t= KBUILD_MODNAME,\n\t.driver.owner\t\t\t= THIS_MODULE,\n\t.id_table\t\t\t= id_table,\n\t.probe\t\t\t\t= virtblk_probe,\n\t.remove\t\t\t\t= virtblk_remove,\n......\n};\n</code></pre><p>å‰é¢æˆ‘ä»¬ä»‹ç»è¿‡è®¾å¤‡é©±åŠ¨ç¨‹åºï¼Œä»è¿™é‡Œçš„ä»£ç ä¸­ï¼Œæˆ‘ä»¬èƒ½çœ‹åˆ°éå¸¸ç†Ÿæ‚‰çš„ç»“æ„ã€‚å®ƒä¼šåˆ›å»ºä¸€ä¸ªworkqueueï¼Œæ³¨å†Œä¸€ä¸ªå—è®¾å¤‡ï¼Œå¹¶è·å¾—ä¸€ä¸ªä¸»è®¾å¤‡å·ï¼Œç„¶åæ³¨å†Œä¸€ä¸ªé©±åŠ¨å‡½æ•°virtio_blkã€‚</p><p>å½“ä¸€ä¸ªè®¾å¤‡é©±åŠ¨ä½œä¸ºä¸€ä¸ªå†…æ ¸æ¨¡å—è¢«åˆå§‹åŒ–çš„æ—¶å€™ï¼Œprobeå‡½æ•°ä¼šè¢«è°ƒç”¨ï¼Œå› è€Œæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹virtblk_probeã€‚</p><pre><code>static int virtblk_probe(struct virtio_device *vdev)\n{\n\tstruct virtio_blk *vblk;\n\tstruct request_queue *q;\n......\n\tvdev-&gt;priv = vblk = kmalloc(sizeof(*vblk), GFP_KERNEL);\n\tvblk-&gt;vdev = vdev;\n\tvblk-&gt;sg_elems = sg_elems;\n\tINIT_WORK(&amp;vblk-&gt;config_work, virtblk_config_changed_work);\n......\n\terr = init_vq(vblk);\n......\n\tvblk-&gt;disk = alloc_disk(1 &lt;&lt; PART_BITS);\n\tmemset(&amp;vblk-&gt;tag_set, 0, sizeof(vblk-&gt;tag_set));\n\tvblk-&gt;tag_set.ops = &amp;virtio_mq_ops;\n\tvblk-&gt;tag_set.queue_depth = virtblk_queue_depth;\n\tvblk-&gt;tag_set.numa_node = NUMA_NO_NODE;\n\tvblk-&gt;tag_set.flags = BLK_MQ_F_SHOULD_MERGE;\n\tvblk-&gt;tag_set.cmd_size =\n\t\tsizeof(struct virtblk_req) +\n\t\tsizeof(struct scatterlist) * sg_elems;\n\tvblk-&gt;tag_set.driver_data = vblk;\n\tvblk-&gt;tag_set.nr_hw_queues = vblk-&gt;num_vqs;\n\terr = blk_mq_alloc_tag_set(&amp;vblk-&gt;tag_set);\n......\n\tq = blk_mq_init_queue(&amp;vblk-&gt;tag_set);\n\tvblk-&gt;disk-&gt;queue = q;\n\tq-&gt;queuedata = vblk;\n\tvirtblk_name_format(&quot;vd&quot;, index, vblk-&gt;disk-&gt;disk_name, DISK_NAME_LEN);\n\tvblk-&gt;disk-&gt;major = major;\n\tvblk-&gt;disk-&gt;first_minor = index_to_minor(index);\n\tvblk-&gt;disk-&gt;private_data = vblk;\n\tvblk-&gt;disk-&gt;fops = &amp;virtblk_fops;\n\tvblk-&gt;disk-&gt;flags |= GENHD_FL_EXT_DEVT;\n\tvblk-&gt;index = index;\n......\n\tdevice_add_disk(&amp;vdev-&gt;dev, vblk-&gt;disk);\n\terr = device_create_file(disk_to_dev(vblk-&gt;disk), &amp;dev_attr_serial);\n......\n}\n</code></pre><p>åœ¨virtblk_probeä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆçœ‹åˆ°çš„æ˜¯struct request_queueï¼Œè¿™æ˜¯æ¯ä¸€ä¸ªå—è®¾å¤‡éƒ½æœ‰çš„ä¸€ä¸ªé˜Ÿåˆ—ã€‚è¿˜è®°å¾—å—ï¼Ÿå®ƒæœ‰ä¸¤ä¸ªå‡½æ•°ï¼Œä¸€ä¸ªæ˜¯make_request_fnå‡½æ•°ï¼Œç”¨äºç”Ÿæˆrequestï¼›å¦ä¸€ä¸ªæ˜¯request_fnå‡½æ•°ï¼Œç”¨äºå¤„ç†requestã€‚</p><!-- [[[read_end]]] --><p>è¿™ä¸ªrequest_queueçš„åˆå§‹åŒ–è¿‡ç¨‹åœ¨blk_mq_init_queueä¸­ã€‚å®ƒä¼šè°ƒç”¨blk_mq_init_allocated_queue-&gt;blk_queue_make_requestã€‚åœ¨è¿™é‡Œé¢ï¼Œæˆ‘ä»¬å¯ä»¥å°†make_request_fnå‡½æ•°è®¾ç½®ä¸ºblk_mq_make_requestï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œä¸€æ—¦ä¸Šå±‚æœ‰å†™å…¥è¯·æ±‚ï¼Œæˆ‘ä»¬å°±é€šè¿‡blk_mq_make_requestè¿™ä¸ªå‡½æ•°ï¼Œå°†è¯·æ±‚æ”¾å…¥request_queueé˜Ÿåˆ—ä¸­ã€‚</p><p>å¦å¤–ï¼Œåœ¨virtblk_probeä¸­ï¼Œæˆ‘ä»¬ä¼šåˆå§‹åŒ–ä¸€ä¸ªgendiskã€‚å‰é¢æˆ‘ä»¬ä¹Ÿè®²äº†ï¼Œæ¯ä¸€ä¸ªå—è®¾å¤‡éƒ½æœ‰è¿™æ ·ä¸€ä¸ªç»“æ„ã€‚</p><p>åœ¨virtblk_probeä¸­ï¼Œè¿˜æœ‰ä¸€ä»¶é‡è¦çš„äº‹æƒ…å°±æ˜¯ï¼Œinit_vqä¼šæ¥åˆå§‹åŒ–virtqueueã€‚</p><pre><code>static int init_vq(struct virtio_blk *vblk)\n{\n\tint err;\n\tint i;\n\tvq_callback_t **callbacks;\n\tconst char **names;\n\tstruct virtqueue **vqs;\n\tunsigned short num_vqs;\n\tstruct virtio_device *vdev = vblk-&gt;vdev;\n......\n\tvblk-&gt;vqs = kmalloc_array(num_vqs, sizeof(*vblk-&gt;vqs), GFP_KERNEL);\n\tnames = kmalloc_array(num_vqs, sizeof(*names), GFP_KERNEL);\n\tcallbacks = kmalloc_array(num_vqs, sizeof(*callbacks), GFP_KERNEL);\n\tvqs = kmalloc_array(num_vqs, sizeof(*vqs), GFP_KERNEL);\n......\n\tfor (i = 0; i &lt; num_vqs; i++) {\n\t\tcallbacks[i] = virtblk_done;\n\t\tnames[i] = vblk-&gt;vqs[i].name;\n\t}\n\n\t/* Discover virtqueues and write information to configuration.  */\n\terr = virtio_find_vqs(vdev, num_vqs, vqs, callbacks, names, &amp;desc);\n\n\tfor (i = 0; i &lt; num_vqs; i++) {\n\t\tvblk-&gt;vqs[i].vq = vqs[i];\n\t}\n\tvblk-&gt;num_vqs = num_vqs;\n......\n}\n</code></pre><p>æŒ‰ç…§ä¸Šé¢çš„åŸç†æ¥è¯´ï¼Œvirtqueueæ˜¯ä¸€ä¸ªä»‹äºå®¢æˆ·æœºå‰ç«¯å’Œqemuåç«¯çš„ä¸€ä¸ªç»“æ„ï¼Œç”¨äºåœ¨è¿™ä¸¤ç«¯ä¹‹é—´ä¼ é€’æ•°æ®ã€‚è¿™é‡Œå»ºç«‹çš„struct virtqueueæ˜¯å®¢æˆ·æœºå‰ç«¯å¯¹äºé˜Ÿåˆ—çš„ç®¡ç†çš„æ•°æ®ç»“æ„ï¼Œåœ¨å®¢æˆ·æœºçš„linuxå†…æ ¸ä¸­é€šè¿‡kmalloc_arrayè¿›è¡Œåˆ†é…ã€‚</p><p>è€Œé˜Ÿåˆ—çš„å®ä½“éœ€è¦é€šè¿‡å‡½æ•°virtio_find_vqsæŸ¥æ‰¾æˆ–è€…ç”Ÿæˆï¼Œæ‰€ä»¥è¿™é‡Œæˆ‘ä»¬è¿˜æŠŠcallbackå‡½æ•°æŒ‡å®šä¸ºvirtblk_doneã€‚å½“bufferä½¿ç”¨å‘ç”Ÿå˜åŒ–çš„æ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦è°ƒç”¨è¿™ä¸ªcallbackå‡½æ•°è¿›è¡Œé€šçŸ¥ã€‚</p><pre><code>static inline\nint virtio_find_vqs(struct virtio_device *vdev, unsigned nvqs,\n\t\t\tstruct virtqueue *vqs[], vq_callback_t *callbacks[],\n\t\t\tconst char * const names[],\n\t\t\tstruct irq_affinity *desc)\n{\n\treturn vdev-&gt;config-&gt;find_vqs(vdev, nvqs, vqs, callbacks, names, NULL, desc);\n}\n\nstatic const struct virtio_config_ops virtio_pci_config_ops = {\n\t.get\t\t= vp_get,\n\t.set\t\t= vp_set,\n\t.generation\t= vp_generation,\n\t.get_status\t= vp_get_status,\n\t.set_status\t= vp_set_status,\n\t.reset\t\t= vp_reset,\n\t.find_vqs\t= vp_modern_find_vqs,\n\t.del_vqs\t= vp_del_vqs,\n\t.get_features\t= vp_get_features,\n\t.finalize_features = vp_finalize_features,\n\t.bus_name\t= vp_bus_name,\n\t.set_vq_affinity = vp_set_vq_affinity,\n\t.get_vq_affinity = vp_get_vq_affinity,\n};\n</code></pre><p>æ ¹æ®virtio_config_opsçš„å®šä¹‰ï¼Œvirtio_find_vqsä¼šè°ƒç”¨vp_modern_find_vqsã€‚</p><pre><code>static int vp_modern_find_vqs(struct virtio_device *vdev, unsigned nvqs,\n\t\t\t      struct virtqueue *vqs[],\n\t\t\t      vq_callback_t *callbacks[],\n\t\t\t      const char * const names[], const bool *ctx,\n\t\t\t      struct irq_affinity *desc)\n{\n\tstruct virtio_pci_device *vp_dev = to_vp_device(vdev);\n\tstruct virtqueue *vq;\n\tint rc = vp_find_vqs(vdev, nvqs, vqs, callbacks, names, ctx, desc);\n\t/* Select and activate all queues. Has to be done last: once we do\n\t * this, there's no way to go back except reset.\n\t */\n\tlist_for_each_entry(vq, &amp;vdev-&gt;vqs, list) {\n\t\tvp_iowrite16(vq-&gt;index, &amp;vp_dev-&gt;common-&gt;queue_select);\n\t\tvp_iowrite16(1, &amp;vp_dev-&gt;common-&gt;queue_enable);\n\t}\n\n\treturn 0;\n}\n</code></pre><p>åœ¨vp_modern_find_vqsä¸­ï¼Œvp_find_vqsä¼šè°ƒç”¨vp_find_vqs_intxã€‚</p><pre><code>static int vp_find_vqs_intx(struct virtio_device *vdev, unsigned nvqs,\n\t\tstruct virtqueue *vqs[], vq_callback_t *callbacks[],\n\t\tconst char * const names[], const bool *ctx)\n{\n\tstruct virtio_pci_device *vp_dev = to_vp_device(vdev);\n\tint i, err;\n\n\tvp_dev-&gt;vqs = kcalloc(nvqs, sizeof(*vp_dev-&gt;vqs), GFP_KERNEL);\n\terr = request_irq(vp_dev-&gt;pci_dev-&gt;irq, vp_interrupt, IRQF_SHARED,\n\t\t\tdev_name(&amp;vdev-&gt;dev), vp_dev);\n\tvp_dev-&gt;intx_enabled = 1;\n\tvp_dev-&gt;per_vq_vectors = false;\n\tfor (i = 0; i &lt; nvqs; ++i) {\n\t\tvqs[i] = vp_setup_vq(vdev, i, callbacks[i], names[i],\n\t\t\t\t     ctx ? ctx[i] : false,\n\t\t\t\t     VIRTIO_MSI_NO_VECTOR);\n......\n\t}\n}\n</code></pre><p>åœ¨vp_find_vqs_intxä¸­ï¼Œæˆ‘ä»¬é€šè¿‡request_irqæ³¨å†Œä¸€ä¸ªä¸­æ–­å¤„ç†å‡½æ•°vp_interruptï¼Œå½“è®¾å¤‡çš„é…ç½®ä¿¡æ¯å‘ç”Ÿæ”¹å˜ï¼Œä¼šäº§ç”Ÿä¸€ä¸ªä¸­æ–­ï¼Œå½“è®¾å¤‡å‘é˜Ÿåˆ—ä¸­å†™å…¥ä¿¡æ¯æ—¶ï¼Œä¹Ÿä¼šäº§ç”Ÿä¸€ä¸ªä¸­æ–­ï¼Œæˆ‘ä»¬ç§°ä¸ºvqä¸­æ–­ï¼Œä¸­æ–­å¤„ç†å‡½æ•°éœ€è¦è°ƒç”¨ç›¸åº”çš„é˜Ÿåˆ—çš„å›è°ƒå‡½æ•°ã€‚</p><p>ç„¶åï¼Œæˆ‘ä»¬æ ¹æ®é˜Ÿåˆ—çš„æ•°ç›®ï¼Œä¾æ¬¡è°ƒç”¨vp_setup_vqï¼Œå®Œæˆvirtqueueã€vringçš„åˆ†é…å’Œåˆå§‹åŒ–ã€‚</p><pre><code>static struct virtqueue *vp_setup_vq(struct virtio_device *vdev, unsigned index,\n\t\t\t\t     void (*callback)(struct virtqueue *vq),\n\t\t\t\t     const char *name,\n\t\t\t\t     bool ctx,\n\t\t\t\t     u16 msix_vec)\n{\n\tstruct virtio_pci_device *vp_dev = to_vp_device(vdev);\n\tstruct virtio_pci_vq_info *info = kmalloc(sizeof *info, GFP_KERNEL);\n\tstruct virtqueue *vq;\n\tunsigned long flags;\n......\n\tvq = vp_dev-&gt;setup_vq(vp_dev, info, index, callback, name, ctx,\n\t\t\t      msix_vec);\n\tinfo-&gt;vq = vq;\n\tif (callback) {\n\t\tspin_lock_irqsave(&amp;vp_dev-&gt;lock, flags);\n\t\tlist_add(&amp;info-&gt;node, &amp;vp_dev-&gt;virtqueues);\n\t\tspin_unlock_irqrestore(&amp;vp_dev-&gt;lock, flags);\n\t} else {\n\t\tINIT_LIST_HEAD(&amp;info-&gt;node);\n\t}\n\tvp_dev-&gt;vqs[index] = info;\n\treturn vq;\n}\n\nstatic struct virtqueue *setup_vq(struct virtio_pci_device *vp_dev,\n\t\t\t\t  struct virtio_pci_vq_info *info,\n\t\t\t\t  unsigned index,\n\t\t\t\t  void (*callback)(struct virtqueue *vq),\n\t\t\t\t  const char *name,\n\t\t\t\t  bool ctx,\n\t\t\t\t  u16 msix_vec)\n{\n\tstruct virtio_pci_common_cfg __iomem *cfg = vp_dev-&gt;common;\n\tstruct virtqueue *vq;\n\tu16 num, off;\n\tint err;\n\n\t/* Select the queue we're interested in */\n\tvp_iowrite16(index, &amp;cfg-&gt;queue_select);\n\n\t/* Check if queue is either not available or already active. */\n\tnum = vp_ioread16(&amp;cfg-&gt;queue_size);\n\n\t/* get offset of notification word for this vq */\n\toff = vp_ioread16(&amp;cfg-&gt;queue_notify_off);\n\n\tinfo-&gt;msix_vector = msix_vec;\n\n\t/* create the vring */\n\tvq = vring_create_virtqueue(index, num,\n\t\t\t\t    SMP_CACHE_BYTES, &amp;vp_dev-&gt;vdev,\n\t\t\t\t    true, true, ctx,\n\t\t\t\t    vp_notify, callback, name);\n\t/* activate the queue */\n\tvp_iowrite16(virtqueue_get_vring_size(vq), &amp;cfg-&gt;queue_size);\n\tvp_iowrite64_twopart(virtqueue_get_desc_addr(vq),\n\t\t\t     &amp;cfg-&gt;queue_desc_lo, &amp;cfg-&gt;queue_desc_hi);\n\tvp_iowrite64_twopart(virtqueue_get_avail_addr(vq),\n\t\t\t     &amp;cfg-&gt;queue_avail_lo, &amp;cfg-&gt;queue_avail_hi);\n\tvp_iowrite64_twopart(virtqueue_get_used_addr(vq),\n\t\t\t     &amp;cfg-&gt;queue_used_lo, &amp;cfg-&gt;queue_used_hi);\n......\n\treturn vq;\n}\n\nstruct virtqueue *vring_create_virtqueue(\n\tunsigned int index,\n\tunsigned int num,\n\tunsigned int vring_align,\n\tstruct virtio_device *vdev,\n\tbool weak_barriers,\n\tbool may_reduce_num,\n\tbool context,\n\tbool (*notify)(struct virtqueue *),\n\tvoid (*callback)(struct virtqueue *),\n\tconst char *name)\n{\n\tstruct virtqueue *vq;\n\tvoid *queue = NULL;\n\tdma_addr_t dma_addr;\n\tsize_t queue_size_in_bytes;\n\tstruct vring vring;\n\n\t/* TODO: allocate each queue chunk individually */\n\tfor (; num &amp;&amp; vring_size(num, vring_align) &gt; PAGE_SIZE; num /= 2) {\n\t\tqueue = vring_alloc_queue(vdev, vring_size(num, vring_align),\n\t\t\t\t\t  &amp;dma_addr,\n\t\t\t\t\t  GFP_KERNEL|__GFP_NOWARN|__GFP_ZERO);\n\t\tif (queue)\n\t\t\tbreak;\n\t}\n\n\tif (!queue) {\n\t\t/* Try to get a single page. You are my only hope! */\n\t\tqueue = vring_alloc_queue(vdev, vring_size(num, vring_align),\n\t\t\t\t\t  &amp;dma_addr, GFP_KERNEL|__GFP_ZERO);\n\t}\n\n\tqueue_size_in_bytes = vring_size(num, vring_align);\n\tvring_init(&amp;vring, num, queue, vring_align);\n\n\tvq = __vring_new_virtqueue(index, vring, vdev, weak_barriers, context, notify, callback, name);\n\n\tto_vvq(vq)-&gt;queue_dma_addr = dma_addr;\n\tto_vvq(vq)-&gt;queue_size_in_bytes = queue_size_in_bytes;\n\tto_vvq(vq)-&gt;we_own_ring = true;\n\n\treturn vq;\n}\n</code></pre><p>åœ¨vring_create_virtqueueä¸­ï¼Œæˆ‘ä»¬ä¼šè°ƒç”¨vring_alloc_queueï¼Œæ¥åˆ›å»ºé˜Ÿåˆ—æ‰€éœ€è¦çš„å†…å­˜ç©ºé—´ï¼Œç„¶åè°ƒç”¨vring_initåˆå§‹åŒ–ç»“æ„struct vringï¼Œæ¥ç®¡ç†é˜Ÿåˆ—çš„å†…å­˜ç©ºé—´ï¼Œè°ƒç”¨__vring_new_virtqueueï¼Œæ¥åˆ›å»ºstruct vring_virtqueueã€‚</p><p>è¿™ä¸ªç»“æ„çš„ä¸€å¼€å§‹ï¼Œæ˜¯struct virtqueueï¼Œå®ƒä¹Ÿæ˜¯struct virtqueueçš„ä¸€ä¸ªæ‰©å±•ï¼Œç´§æ¥ç€åé¢å°±æ˜¯struct vringã€‚</p><pre><code>struct vring_virtqueue {\n\tstruct virtqueue vq;\n\n\t/* Actual memory layout for this queue */\n\tstruct vring vring;\n......\n}\n</code></pre><p>è‡³æ­¤æˆ‘ä»¬å‘ç°ï¼Œè™šæ‹Ÿæœºé‡Œé¢çš„virtioçš„å‰ç«¯æ˜¯è¿™æ ·çš„ç»“æ„ï¼šstruct virtio_deviceé‡Œé¢æœ‰ä¸€ä¸ªstruct vring_virtqueueï¼Œåœ¨struct vring_virtqueueé‡Œé¢æœ‰ä¸€ä¸ªstruct vringã€‚</p><h2>ä¸­é—´virtioé˜Ÿåˆ—çš„ç®¡ç†</h2><p>è¿˜è®°ä¸è®°å¾—æˆ‘ä»¬ä¸Šé¢è®²qemuåˆå§‹åŒ–çš„æ—¶å€™ï¼Œvirtioçš„åç«¯æœ‰æ•°æ®ç»“æ„VirtIODeviceï¼ŒVirtQueueå’Œvringä¸€æ¨¡ä¸€æ ·ï¼Œå‰ç«¯å’Œåç«¯å¯¹åº”èµ·æ¥ï¼Œéƒ½åº”è¯¥æŒ‡å‘åˆšæ‰åˆ›å»ºçš„é‚£ä¸€æ®µå†…å­˜ã€‚</p><p>ç°åœ¨çš„é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬åˆšæ‰åˆ†é…çš„å†…å­˜åœ¨å®¢æˆ·æœºçš„å†…æ ¸é‡Œé¢ï¼Œå¦‚ä½•å‘ŠçŸ¥qemuæ¥è®¿é—®è¿™æ®µå†…å­˜å‘¢ï¼Ÿ</p><p>åˆ«å¿˜äº†ï¼Œqemuæ¨¡æ‹Ÿå‡ºæ¥çš„virtio block deviceåªæ˜¯ä¸€ä¸ªPCIè®¾å¤‡ã€‚å¯¹äºå®¢æˆ·æœºæ¥è®²ï¼Œè¿™æ˜¯ä¸€ä¸ªå¤–éƒ¨è®¾å¤‡ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ç»™å¤–éƒ¨è®¾å¤‡å‘é€æŒ‡ä»¤çš„æ–¹å¼å‘ŠçŸ¥å¤–éƒ¨è®¾å¤‡ï¼Œè¿™å°±æ˜¯ä»£ç ä¸­vp_iowrite16çš„ä½œç”¨ã€‚å®ƒä¼šè°ƒç”¨ä¸“é—¨ç»™å¤–éƒ¨è®¾å¤‡å‘é€æŒ‡ä»¤çš„å‡½æ•°iowriteï¼Œå‘Šè¯‰å¤–éƒ¨çš„PCIè®¾å¤‡ã€‚</p><p>å‘ŠçŸ¥çš„æœ‰ä¸‰ä¸ªåœ°å€virtqueue_get_desc_addrã€virtqueue_get_avail_addrï¼Œvirtqueue_get_used_addrã€‚ä»å®¢æˆ·æœºè§’åº¦æ¥çœ‹ï¼Œè¿™é‡Œé¢çš„åœ°å€éƒ½æ˜¯ç‰©ç†åœ°å€ï¼Œä¹Ÿå³GPAï¼ˆGuest Physical Addressï¼‰ã€‚å› ä¸ºåªæœ‰ç‰©ç†åœ°å€æ‰æ˜¯å®¢æˆ·æœºå’Œqemuç¨‹åºéƒ½è®¤å¯çš„åœ°å€ï¼Œæœ¬æ¥å®¢æˆ·æœºçš„ç‰©ç†å†…å­˜ä¹Ÿæ˜¯qemuæ¨¡æ‹Ÿå‡ºæ¥çš„ã€‚</p><p>åœ¨qemuä¸­ï¼Œå¯¹PCIæ€»çº¿æ·»åŠ ä¸€ä¸ªè®¾å¤‡çš„æ—¶å€™ï¼Œæˆ‘ä»¬ä¼šè°ƒç”¨virtio_pci_device_pluggedã€‚</p><pre><code>static void virtio_pci_device_plugged(DeviceState *d, Error **errp)\n{\n    VirtIOPCIProxy *proxy = VIRTIO_PCI(d);\n......\n    memory_region_init_io(&amp;proxy-&gt;bar, OBJECT(proxy),\n                              &amp;virtio_pci_config_ops,\n                              proxy, &quot;virtio-pci&quot;, size);\n......\n}\n\nstatic const MemoryRegionOps virtio_pci_config_ops = {\n    .read = virtio_pci_config_read,\n    .write = virtio_pci_config_write,\n    .impl = {\n        .min_access_size = 1,\n        .max_access_size = 4,\n    },\n    .endianness = DEVICE_LITTLE_ENDIAN,\n};\n</code></pre><p>åœ¨è¿™é‡Œé¢ï¼Œå¯¹äºè¿™ä¸ªåŠ è½½çš„è®¾å¤‡è¿›è¡ŒI/Oæ“ä½œï¼Œä¼šæ˜ å°„åˆ°è¯»å†™æŸä¸€å—å†…å­˜ç©ºé—´ï¼Œå¯¹åº”çš„æ“ä½œä¸ºvirtio_pci_config_opsï¼Œä¹Ÿå³å†™å…¥è¿™å—å†…å­˜ç©ºé—´ï¼Œè¿™å°±ç›¸å½“äºå¯¹äºè¿™ä¸ªPCIè®¾å¤‡è¿›è¡ŒæŸç§é…ç½®ã€‚</p><p>å¯¹PCIè®¾å¤‡è¿›è¡Œé…ç½®çš„æ—¶å€™ï¼Œä¼šæœ‰è¿™æ ·çš„è°ƒç”¨é“¾ï¼švirtio_pci_config_write-&gt;virtio_ioport_write-&gt;virtio_queue_set_addrã€‚è®¾ç½®virtioçš„queueçš„åœ°å€æ˜¯ä¸€é¡¹å¾ˆé‡è¦çš„æ“ä½œã€‚</p><pre><code>void virtio_queue_set_addr(VirtIODevice *vdev, int n, hwaddr addr)\n{\n    vdev-&gt;vq[n].vring.desc = addr;\n    virtio_queue_update_rings(vdev, n);\n}\n</code></pre><p>ä»è¿™é‡Œæˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼Œqemuåç«¯çš„VirtIODeviceçš„VirtQueueçš„vringçš„åœ°å€ï¼Œè¢«è®¾ç½®æˆäº†åˆšæ‰ç»™é˜Ÿåˆ—åˆ†é…çš„å†…å­˜çš„GPAã€‚</p><p><img src=\"https://static001.geekbang.org/resource/image/25/d0/2572f8b1e75b9eaab6560866fcb31fd0.jpg?wh=5158*4690\" alt=\"\"></p><p>æ¥ç€ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹è¿™ä¸ªé˜Ÿåˆ—çš„æ ¼å¼ã€‚</p><p><img src=\"https://static001.geekbang.org/resource/image/49/db/49414d5acc81933b66410bbba102b0db.jpg?wh=1546*1303\" alt=\"\"></p><pre><code>/* Virtio ring descriptors: 16 bytes.  These can chain together via &quot;next&quot;. */\nstruct vring_desc {\n\t/* Address (guest-physical). */\n\t__virtio64 addr;\n\t/* Length. */\n\t__virtio32 len;\n\t/* The flags as indicated above. */\n\t__virtio16 flags;\n\t/* We chain unused descriptors via this, too */\n\t__virtio16 next;\n};\n\nstruct vring_avail {\n\t__virtio16 flags;\n\t__virtio16 idx;\n\t__virtio16 ring[];\n};\n\n/* u32 is used here for ids for padding reasons. */\nstruct vring_used_elem {\n\t/* Index of start of used descriptor chain. */\n\t__virtio32 id;\n\t/* Total length of the descriptor chain which was used (written to) */\n\t__virtio32 len;\n};\n\nstruct vring_used {\n\t__virtio16 flags;\n\t__virtio16 idx;\n\tstruct vring_used_elem ring[];\n};\n\nstruct vring {\n\tunsigned int num;\n\n\tstruct vring_desc *desc;\n\n\tstruct vring_avail *avail;\n\n\tstruct vring_used *used;\n};\n</code></pre><p>vringåŒ…å«ä¸‰ä¸ªæˆå‘˜ï¼š</p><ul>\n<li>vring_descæŒ‡å‘åˆ†é…çš„å†…å­˜å—ï¼Œç”¨äºå­˜æ”¾å®¢æˆ·æœºå’Œqemuä¹‹é—´ä¼ è¾“çš„æ•°æ®ã€‚</li>\n<li>avail-&gt;ring[]æ˜¯å‘é€ç«¯ç»´æŠ¤çš„ç¯å½¢é˜Ÿåˆ—ï¼ŒæŒ‡å‘éœ€è¦æ¥æ”¶ç«¯å¤„ç†çš„vring_descã€‚</li>\n<li>used-&gt;ring[]æ˜¯æ¥æ”¶ç«¯ç»´æŠ¤çš„ç¯å½¢é˜Ÿåˆ—ï¼ŒæŒ‡å‘è‡ªå·±å·²ç»å¤„ç†è¿‡äº†çš„vring_descã€‚</li>\n</ul><h2>æ•°æ®å†™å…¥çš„æµç¨‹</h2><p>æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬æ¥çœ‹ï¼ŒçœŸçš„å†™å…¥ä¸€ä¸ªæ•°æ®çš„æ—¶å€™ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆã€‚</p><p>æŒ‰ç…§ä¸Šé¢virtioé©±åŠ¨åˆå§‹åŒ–çš„æ—¶å€™çš„é€»è¾‘ï¼Œblk_mq_make_requestä¼šè¢«è°ƒç”¨ã€‚è¿™ä¸ªå‡½æ•°æ¯”è¾ƒå¤æ‚ï¼Œä¼šåˆ†æˆå¤šä¸ªåˆ†æ”¯ï¼Œä½†æ˜¯æœ€ç»ˆéƒ½ä¼šè°ƒç”¨åˆ°request_queueçš„virtio_mq_opsçš„queue_rqå‡½æ•°ã€‚</p><pre><code>struct request_queue *q = rq-&gt;q;\nq-&gt;mq_ops-&gt;queue_rq(hctx, &amp;bd);\n\nstatic const struct blk_mq_ops virtio_mq_ops = {\n\t.queue_rq\t= virtio_queue_rq,\n\t.complete\t= virtblk_request_done,\n\t.init_request\t= virtblk_init_request,\n\t.map_queues\t= virtblk_map_queues,\n};\n</code></pre><p>æ ¹æ®virtio_mq_opsçš„å®šä¹‰ï¼Œæˆ‘ä»¬ç°åœ¨è¦è°ƒç”¨virtio_queue_rqã€‚</p><pre><code>static blk_status_t virtio_queue_rq(struct blk_mq_hw_ctx *hctx,\n\t\t\t   const struct blk_mq_queue_data *bd)\n{\n\tstruct virtio_blk *vblk = hctx-&gt;queue-&gt;queuedata;\n\tstruct request *req = bd-&gt;rq;\n\tstruct virtblk_req *vbr = blk_mq_rq_to_pdu(req);\n......\n\terr = virtblk_add_req(vblk-&gt;vqs[qid].vq, vbr, vbr-&gt;sg, num);\n......\n\tif (notify)\n\t\tvirtqueue_notify(vblk-&gt;vqs[qid].vq);\n\treturn BLK_STS_OK;\n}\n</code></pre><p>åœ¨virtio_queue_rqä¸­ï¼Œæˆ‘ä»¬ä¼šå°†è¯·æ±‚å†™å…¥çš„æ•°æ®ï¼Œé€šè¿‡virtblk_add_reqæ”¾å…¥struct virtqueueã€‚</p><p>å› æ­¤ï¼Œæ¥ä¸‹æ¥çš„è°ƒç”¨é“¾ä¸ºï¼švirtblk_add_req-&gt;virtqueue_add_sgs-&gt;virtqueue_addã€‚</p><pre><code>static inline int virtqueue_add(struct virtqueue *_vq,\n\t\t\t\tstruct scatterlist *sgs[],\n\t\t\t\tunsigned int total_sg,\n\t\t\t\tunsigned int out_sgs,\n\t\t\t\tunsigned int in_sgs,\n\t\t\t\tvoid *data,\n\t\t\t\tvoid *ctx,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct vring_virtqueue *vq = to_vvq(_vq);\n\tstruct scatterlist *sg;\n\tstruct vring_desc *desc;\n\tunsigned int i, n, avail, descs_used, uninitialized_var(prev), err_idx;\n\tint head;\n\tbool indirect;\n......\n\thead = vq-&gt;free_head;\n\n\tindirect = false;\n\tdesc = vq-&gt;vring.desc;\n\ti = head;\n\tdescs_used = total_sg;\n\n\tfor (n = 0; n &lt; out_sgs; n++) {\n\t\tfor (sg = sgs[n]; sg; sg = sg_next(sg)) {\n\t\t\tdma_addr_t addr = vring_map_one_sg(vq, sg, DMA_TO_DEVICE);\n......\n\t\t\tdesc[i].flags = cpu_to_virtio16(_vq-&gt;vdev, VRING_DESC_F_NEXT);\n\t\t\tdesc[i].addr = cpu_to_virtio64(_vq-&gt;vdev, addr);\n\t\t\tdesc[i].len = cpu_to_virtio32(_vq-&gt;vdev, sg-&gt;length);\n\t\t\tprev = i;\n\t\t\ti = virtio16_to_cpu(_vq-&gt;vdev, desc[i].next);\n\t\t}\n\t}\n\n\t/* Last one doesn't continue. */\n\tdesc[prev].flags &amp;= cpu_to_virtio16(_vq-&gt;vdev, ~VRING_DESC_F_NEXT);\n\n\t/* We're using some buffers from the free list. */\n\tvq-&gt;vq.num_free -= descs_used;\n\n\t/* Update free pointer */\n\tvq-&gt;free_head = i;\n\n\t/* Store token and indirect buffer state. */\n\tvq-&gt;desc_state[head].data = data;\n\n\t/* Put entry in available array (but don't update avail-&gt;idx until they do sync). */\n\tavail = vq-&gt;avail_idx_shadow &amp; (vq-&gt;vring.num - 1);\n\tvq-&gt;vring.avail-&gt;ring[avail] = cpu_to_virtio16(_vq-&gt;vdev, head);\n\n\t/* Descriptors and available array need to be set before we expose the new available array entries. */\n\tvirtio_wmb(vq-&gt;weak_barriers);\n\tvq-&gt;avail_idx_shadow++;\n\tvq-&gt;vring.avail-&gt;idx = cpu_to_virtio16(_vq-&gt;vdev, vq-&gt;avail_idx_shadow);\n\tvq-&gt;num_added++;\n......\n\treturn 0;\n}\n</code></pre><p>åœ¨virtqueue_addå‡½æ•°ä¸­ï¼Œæˆ‘ä»¬èƒ½çœ‹åˆ°ï¼Œfree_headæŒ‡å‘çš„æ•´ä¸ªå†…å­˜å—ç©ºé—²é“¾è¡¨çš„èµ·å§‹ä½ç½®ï¼Œç”¨headå˜é‡è®°ä½è¿™ä¸ªèµ·å§‹ä½ç½®ã€‚</p><p>æ¥ä¸‹æ¥ï¼Œiä¹ŸæŒ‡å‘è¿™ä¸ªèµ·å§‹ä½ç½®ï¼Œç„¶åæ˜¯ä¸€ä¸ªforå¾ªç¯ï¼Œå°†æ•°æ®æ”¾åˆ°å†…å­˜å—é‡Œé¢ï¼Œæ”¾çš„è¿‡ç¨‹ä¸­ï¼Œnextä¸æ–­æŒ‡å‘ä¸‹ä¸€ä¸ªç©ºé—²ä½ç½®ï¼Œè¿™æ ·ç©ºé—²çš„å†…å­˜å—è¢«ä¸æ–­çš„å ç”¨ã€‚ç­‰æ‰€æœ‰çš„å†™å…¥éƒ½ç»“æŸäº†ï¼Œiå°±ä¼šæŒ‡å‘è¿™æ¬¡å­˜æ”¾çš„å†…å­˜å—çš„ä¸‹ä¸€ä¸ªç©ºé—²ä½ç½®ï¼Œç„¶åfree_headå°±æŒ‡å‘iï¼Œå› ä¸ºå‰é¢çš„éƒ½å¡«æ»¡äº†ã€‚</p><p>è‡³æ­¤ï¼Œä»headåˆ°iä¹‹é—´çš„å†…å­˜å—ï¼Œå°±æ˜¯è¿™æ¬¡å†™å…¥çš„å…¨éƒ¨æ•°æ®ã€‚</p><p>äºæ˜¯ï¼Œåœ¨vringçš„availå˜é‡ä¸­ï¼Œåœ¨ring[]æ•°ç»„ä¸­åˆ†é…æ–°çš„ä¸€é¡¹ï¼Œåœ¨availçš„ä½ç½®ï¼Œavailçš„è®¡ç®—æ˜¯avail_idx_shadow &amp; (vq-&gt;vring.num - 1)ï¼Œå…¶ä¸­ï¼Œavail_idx_shadowæ˜¯ä¸Šä¸€æ¬¡çš„availçš„ä½ç½®ã€‚è¿™é‡Œå¦‚æœè¶…è¿‡äº†ring[]æ•°ç»„çš„ä¸‹æ ‡ï¼Œåˆ™é‡æ–°è·³åˆ°èµ·å§‹ä½ç½®ï¼Œå°±è¯´æ˜æ˜¯ä¸€ä¸ªç¯ã€‚è¿™æ¬¡åˆ†é…çš„æ–°çš„availçš„ä½ç½®å°±å­˜æ”¾æ–°å†™å…¥çš„ä»headåˆ°iä¹‹é—´çš„å†…å­˜å—ã€‚ç„¶åæ˜¯avail_idx_shadow++ï¼Œè¿™è¯´æ˜è¿™ä¸€å—å†…å­˜å¯ä»¥è¢«æ¥æ”¶æ–¹è¯»å–äº†ã€‚</p><p>æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å›åˆ°virtio_queue_rqï¼Œè°ƒç”¨virtqueue_notifyé€šçŸ¥æ¥æ”¶æ–¹ã€‚è€Œvirtqueue_notifyä¼šè°ƒç”¨vp_notifyã€‚</p><pre><code>bool vp_notify(struct virtqueue *vq)\n{\n\t/* we write the queue's selector into the notification register to\n\t * signal the other end */\n\tiowrite16(vq-&gt;index, (void __iomem *)vq-&gt;priv);\n\treturn true;\n}\n</code></pre><p>ç„¶åï¼Œæˆ‘ä»¬å†™å…¥ä¸€ä¸ªI/Oä¼šè§¦å‘VM exitã€‚æˆ‘ä»¬åœ¨è§£æCPUçš„æ—¶å€™çœ‹åˆ°è¿‡è¿™ä¸ªé€»è¾‘ã€‚</p><pre><code>int kvm_cpu_exec(CPUState *cpu)\n{\n    struct kvm_run *run = cpu-&gt;kvm_run;\n    int ret, run_ret;\n......\n    run_ret = kvm_vcpu_ioctl(cpu, KVM_RUN, 0);\n......\n    switch (run-&gt;exit_reason) {\n        case KVM_EXIT_IO:\n            DPRINTF(&quot;handle_io\\n&quot;);\n            /* Called outside BQL */\n            kvm_handle_io(run-&gt;io.port, attrs,\n                          (uint8_t *)run + run-&gt;io.data_offset,\n                          run-&gt;io.direction,\n                          run-&gt;io.size,\n                          run-&gt;io.count);\n            ret = 0;\n            break;\n    }\n......\n}\n</code></pre><p>è¿™æ¬¡å†™å…¥çš„ä¹Ÿæ˜¯ä¸€ä¸ªI/Oçš„å†…å­˜ç©ºé—´ï¼ŒåŒæ ·ä¼šè§¦å‘virtio_ioport_writeï¼Œè¿™æ¬¡ä¼šè°ƒç”¨virtio_queue_notifyã€‚</p><pre><code>void virtio_queue_notify(VirtIODevice *vdev, int n)\n{\n    VirtQueue *vq = &amp;vdev-&gt;vq[n];\n......\n    if (vq-&gt;handle_aio_output) {\n        event_notifier_set(&amp;vq-&gt;host_notifier);\n    } else if (vq-&gt;handle_output) {\n        vq-&gt;handle_output(vdev, vq);\n    }\n}\n</code></pre><p>virtio_queue_notifyä¼šè°ƒç”¨VirtQueueçš„handle_outputå‡½æ•°ï¼Œå‰é¢æˆ‘ä»¬å·²ç»è®¾ç½®è¿‡è¿™ä¸ªå‡½æ•°äº†ï¼Œæ˜¯virtio_blk_handle_outputã€‚</p><p>æ¥ä¸‹æ¥çš„è°ƒç”¨é“¾ä¸ºï¼švirtio_blk_handle_output-&gt;virtio_blk_handle_output_do-&gt;virtio_blk_handle_vqã€‚</p><pre><code>bool virtio_blk_handle_vq(VirtIOBlock *s, VirtQueue *vq)\n{\n    VirtIOBlockReq *req;\n    MultiReqBuffer mrb = {};\n    bool progress = false;\n......\n    do {\n        virtio_queue_set_notification(vq, 0);\n\n        while ((req = virtio_blk_get_request(s, vq))) {\n            progress = true;\n            if (virtio_blk_handle_request(req, &amp;mrb)) {\n                virtqueue_detach_element(req-&gt;vq, &amp;req-&gt;elem, 0);\n                virtio_blk_free_request(req);\n                break;\n            }\n        }\n\n        virtio_queue_set_notification(vq, 1);\n    } while (!virtio_queue_empty(vq));\n\n    if (mrb.num_reqs) {\n        virtio_blk_submit_multireq(s-&gt;blk, &amp;mrb);\n    }\n......\n    return progress;\n}\n</code></pre><p>åœ¨virtio_blk_handle_vqä¸­ï¼Œæœ‰ä¸€ä¸ªwhileå¾ªç¯ï¼Œåœ¨å¾ªç¯ä¸­è°ƒç”¨å‡½æ•°virtio_blk_get_requestä»vqä¸­å–å‡ºè¯·æ±‚ï¼Œç„¶åè°ƒç”¨virtio_blk_handle_requestå¤„ç†ä»vqä¸­å–å‡ºçš„è¯·æ±‚ã€‚</p><p>æˆ‘ä»¬å…ˆæ¥çœ‹virtio_blk_get_requestã€‚</p><pre><code>static VirtIOBlockReq *virtio_blk_get_request(VirtIOBlock *s, VirtQueue *vq)\n{\n    VirtIOBlockReq *req = virtqueue_pop(vq, sizeof(VirtIOBlockReq));\n\n    if (req) {\n        virtio_blk_init_request(s, vq, req);\n    }\n    return req;\n}\n\nvoid *virtqueue_pop(VirtQueue *vq, size_t sz)\n{\n    unsigned int i, head, max;\n    VRingMemoryRegionCaches *caches;\n    MemoryRegionCache *desc_cache;\n    int64_t len;\n    VirtIODevice *vdev = vq-&gt;vdev;\n    VirtQueueElement *elem = NULL;\n    unsigned out_num, in_num, elem_entries;\n    hwaddr addr[VIRTQUEUE_MAX_SIZE];\n    struct iovec iov[VIRTQUEUE_MAX_SIZE];\n    VRingDesc desc;\n    int rc;\n......\n    /* When we start there are none of either input nor output. */\n    out_num = in_num = elem_entries = 0;\n\n    max = vq-&gt;vring.num;\n\n    i = head;\n\n    caches = vring_get_region_caches(vq);\n    desc_cache = &amp;caches-&gt;desc;\n    vring_desc_read(vdev, &amp;desc, desc_cache, i);\n......\n    /* Collect all the descriptors */\n    do {\n        bool map_ok;\n\n        if (desc.flags &amp; VRING_DESC_F_WRITE) {\n            map_ok = virtqueue_map_desc(vdev, &amp;in_num, addr + out_num,\n                                        iov + out_num,\n                                        VIRTQUEUE_MAX_SIZE - out_num, true,\n                                        desc.addr, desc.len);\n        } else {\n            map_ok = virtqueue_map_desc(vdev, &amp;out_num, addr, iov,\n                                        VIRTQUEUE_MAX_SIZE, false,\n                                        desc.addr, desc.len);\n        }\n......\n        rc = virtqueue_read_next_desc(vdev, &amp;desc, desc_cache, max, &amp;i);\n    } while (rc == VIRTQUEUE_READ_DESC_MORE);\n......\n    /* Now copy what we have collected and mapped */\n    elem = virtqueue_alloc_element(sz, out_num, in_num);\n    elem-&gt;index = head;\n    for (i = 0; i &lt; out_num; i++) {\n        elem-&gt;out_addr[i] = addr[i];\n        elem-&gt;out_sg[i] = iov[i];\n    }\n    for (i = 0; i &lt; in_num; i++) {\n        elem-&gt;in_addr[i] = addr[out_num + i];\n        elem-&gt;in_sg[i] = iov[out_num + i];\n    }\n\n    vq-&gt;inuse++;\n......\n    return elem;\n}\n</code></pre><p>æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œvirtio_blk_get_requestä¼šè°ƒç”¨virtqueue_popã€‚åœ¨è¿™é‡Œé¢ï¼Œæˆ‘ä»¬èƒ½çœ‹åˆ°å¯¹äºvringçš„æ“ä½œï¼Œä¹Ÿå³ä»è¿™é‡Œé¢å°†å®¢æˆ·æœºé‡Œé¢å†™å…¥çš„æ•°æ®è¯»å–å‡ºæ¥ï¼Œæ”¾åˆ°VirtIOBlockReqç»“æ„ä¸­ã€‚</p><p>æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°±è¦è°ƒç”¨virtio_blk_handle_requestå¤„ç†è¿™äº›æ•°æ®ã€‚æ‰€ä»¥æ¥ä¸‹æ¥çš„è°ƒç”¨é“¾ä¸ºï¼švirtio_blk_handle_request-&gt;virtio_blk_submit_multireq-&gt;submit_requestsã€‚</p><pre><code>static inline void submit_requests(BlockBackend *blk, MultiReqBuffer *mrb,int start, int num_reqs, int niov)\n{\n    QEMUIOVector *qiov = &amp;mrb-&gt;reqs[start]-&gt;qiov;\n    int64_t sector_num = mrb-&gt;reqs[start]-&gt;sector_num;\n    bool is_write = mrb-&gt;is_write;\n\n    if (num_reqs &gt; 1) {\n        int i;\n        struct iovec *tmp_iov = qiov-&gt;iov;\n        int tmp_niov = qiov-&gt;niov;\n        qemu_iovec_init(qiov, niov);\n\n        for (i = 0; i &lt; tmp_niov; i++) {\n            qemu_iovec_add(qiov, tmp_iov[i].iov_base, tmp_iov[i].iov_len);\n        }\n\n        for (i = start + 1; i &lt; start + num_reqs; i++) {\n            qemu_iovec_concat(qiov, &amp;mrb-&gt;reqs[i]-&gt;qiov, 0,\n                              mrb-&gt;reqs[i]-&gt;qiov.size);\n            mrb-&gt;reqs[i - 1]-&gt;mr_next = mrb-&gt;reqs[i];\n        }\n\n        block_acct_merge_done(blk_get_stats(blk),\n                              is_write ? BLOCK_ACCT_WRITE : BLOCK_ACCT_READ,\n                              num_reqs - 1);\n    }\n\n    if (is_write) {\n        blk_aio_pwritev(blk, sector_num &lt;&lt; BDRV_SECTOR_BITS, qiov, 0,\n                        virtio_blk_rw_complete, mrb-&gt;reqs[start]);\n    } else {\n        blk_aio_preadv(blk, sector_num &lt;&lt; BDRV_SECTOR_BITS, qiov, 0,\n                       virtio_blk_rw_complete, mrb-&gt;reqs[start]);\n    }\n}\n</code></pre><p>åœ¨submit_requestsä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†BlockBackendã€‚è¿™æ˜¯åœ¨qemuå¯åŠ¨çš„æ—¶å€™ï¼Œæ‰“å¼€qcow2æ–‡ä»¶çš„æ—¶å€™ç”Ÿæˆçš„ï¼Œç°åœ¨æˆ‘ä»¬å¯ä»¥ç”¨å®ƒæ¥å†™å…¥æ–‡ä»¶äº†ï¼Œè°ƒç”¨çš„æ˜¯blk_aio_pwritevã€‚</p><pre><code>BlockAIOCB *blk_aio_pwritev(BlockBackend *blk, int64_t offset,\n                            QEMUIOVector *qiov, BdrvRequestFlags flags,\n                            BlockCompletionFunc *cb, void *opaque)\n{\n    return blk_aio_prwv(blk, offset, qiov-&gt;size, qiov,\n                        blk_aio_write_entry, flags, cb, opaque);\n}\n\nstatic BlockAIOCB *blk_aio_prwv(BlockBackend *blk, int64_t offset, int bytes,\n                                void *iobuf, CoroutineEntry co_entry,\n                                BdrvRequestFlags flags,\n                                BlockCompletionFunc *cb, void *opaque)\n{\n    BlkAioEmAIOCB *acb;\n    Coroutine *co;\n    acb = blk_aio_get(&amp;blk_aio_em_aiocb_info, blk, cb, opaque);\n    acb-&gt;rwco = (BlkRwCo) {\n        .blk    = blk,\n        .offset = offset,\n        .iobuf  = iobuf,\n        .flags  = flags,\n        .ret    = NOT_DONE,\n    };\n    acb-&gt;bytes = bytes;\n    acb-&gt;has_returned = false;\n\n    co = qemu_coroutine_create(co_entry, acb);\n    bdrv_coroutine_enter(blk_bs(blk), co);\n\n    acb-&gt;has_returned = true;\n    return &amp;acb-&gt;common;\n}\n</code></pre><p>åœ¨blk_aio_pwritevä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°ï¼Œåˆæ˜¯åˆ›å»ºäº†ä¸€ä¸ªåç¨‹æ¥è¿›è¡Œå†™å…¥ã€‚å†™å…¥å®Œæ¯•ä¹‹åè°ƒç”¨virtio_blk_rw_complete-&gt;virtio_blk_req_completeã€‚</p><pre><code>static void virtio_blk_req_complete(VirtIOBlockReq *req, unsigned char status)\n{\n    VirtIOBlock *s = req-&gt;dev;\n    VirtIODevice *vdev = VIRTIO_DEVICE(s);\n\n    trace_virtio_blk_req_complete(vdev, req, status);\n\n    stb_p(&amp;req-&gt;in-&gt;status, status);\n    virtqueue_push(req-&gt;vq, &amp;req-&gt;elem, req-&gt;in_len);\n    virtio_notify(vdev, req-&gt;vq);\n}\n</code></pre><p>åœ¨virtio_blk_req_completeä¸­ï¼Œæˆ‘ä»¬å…ˆæ˜¯è°ƒç”¨virtqueue_pushï¼Œæ›´æ–°vringä¸­usedå˜é‡ï¼Œè¡¨ç¤ºè¿™éƒ¨åˆ†å·²ç»å†™å…¥å®Œæ¯•ï¼Œç©ºé—´å¯ä»¥å›æ”¶åˆ©ç”¨äº†ã€‚ä½†æ˜¯ï¼Œè¿™éƒ¨åˆ†çš„æ”¹å˜ä»…ä»…æ”¹å˜äº†qemuåç«¯çš„vringï¼Œæˆ‘ä»¬è¿˜éœ€è¦é€šçŸ¥å®¢æˆ·æœºä¸­virtioå‰ç«¯çš„vringçš„å€¼ï¼Œå› è€Œè¦è°ƒç”¨virtio_notifyã€‚virtio_notifyä¼šè°ƒç”¨virtio_irqå‘é€ä¸€ä¸ªä¸­æ–­ã€‚</p><p>è¿˜è®°å¾—å’±ä»¬å‰é¢æ³¨å†Œè¿‡ä¸€ä¸ªä¸­æ–­å¤„ç†å‡½æ•°vp_interruptå—ï¼Ÿå®ƒå°±æ˜¯å¹²è¿™ä¸ªäº‹æƒ…çš„ã€‚</p><pre><code>static irqreturn_t vp_interrupt(int irq, void *opaque)\n{\n\tstruct virtio_pci_device *vp_dev = opaque;\n\tu8 isr;\n\n\t/* reading the ISR has the effect of also clearing it so it's very\n\t * important to save off the value. */\n\tisr = ioread8(vp_dev-&gt;isr);\n\n\t/* Configuration change?  Tell driver if it wants to know. */\n\tif (isr &amp; VIRTIO_PCI_ISR_CONFIG)\n\t\tvp_config_changed(irq, opaque);\n\n\treturn vp_vring_interrupt(irq, opaque);\n}\n</code></pre><p>å°±åƒå‰é¢è¯´çš„ä¸€æ ·vp_interruptè¿™ä¸ªä¸­æ–­å¤„ç†å‡½æ•°ï¼Œä¸€æ˜¯å¤„ç†é…ç½®å˜åŒ–ï¼ŒäºŒæ˜¯å¤„ç†I/Oç»“æŸã€‚ç¬¬äºŒç§çš„è°ƒç”¨é“¾ä¸ºï¼švp_interrupt-&gt;vp_vring_interrupt-&gt;vring_interruptã€‚</p><pre><code>irqreturn_t vring_interrupt(int irq, void *_vq)\n{\n\tstruct vring_virtqueue *vq = to_vvq(_vq);\n......\n\tif (vq-&gt;vq.callback)\n\t\tvq-&gt;vq.callback(&amp;vq-&gt;vq);\n\n\treturn IRQ_HANDLED;\n}\n</code></pre><p>åœ¨vring_interruptä¸­ï¼Œæˆ‘ä»¬ä¼šè°ƒç”¨callbackå‡½æ•°ï¼Œè¿™ä¸ªä¹Ÿæ˜¯åœ¨å‰é¢æ³¨å†Œè¿‡çš„ï¼Œæ˜¯virtblk_doneã€‚</p><p>æ¥ä¸‹æ¥çš„è°ƒç”¨é“¾ä¸ºï¼švirtblk_done-&gt;virtqueue_get_buf-&gt;virtqueue_get_buf_ctxã€‚</p><pre><code>void *virtqueue_get_buf_ctx(struct virtqueue *_vq, unsigned int *len,\n\t\t\t    void **ctx)\n{\n\tstruct vring_virtqueue *vq = to_vvq(_vq);\n\tvoid *ret;\n\tunsigned int i;\n\tu16 last_used;\n......\n\tlast_used = (vq-&gt;last_used_idx &amp; (vq-&gt;vring.num - 1));\n\ti = virtio32_to_cpu(_vq-&gt;vdev, vq-&gt;vring.used-&gt;ring[last_used].id);\n\t*len = virtio32_to_cpu(_vq-&gt;vdev, vq-&gt;vring.used-&gt;ring[last_used].len);\n......\n\t/* detach_buf clears data, so grab it now. */\n\tret = vq-&gt;desc_state[i].data;\n\tdetach_buf(vq, i, ctx);\n\tvq-&gt;last_used_idx++;\n......\n\treturn ret;\n}\n</code></pre><p>åœ¨virtqueue_get_buf_ctxä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œvirtioå‰ç«¯çš„vringä¸­çš„last_used_idxåŠ ä¸€ï¼Œè¯´æ˜è¿™å—æ•°æ®qemuåç«¯å·²ç»æ¶ˆè´¹å®Œæ¯•ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡detach_bufå°†å…¶æ”¾å…¥ç©ºé—²é˜Ÿåˆ—ä¸­ï¼Œç•™ç»™ä»¥åçš„å†™å…¥è¯·æ±‚ä½¿ç”¨ã€‚</p><p>è‡³æ­¤ï¼Œæ•´ä¸ªå­˜å‚¨è™šæ‹ŸåŒ–çš„å†™å…¥æµç¨‹æ‰å…¨éƒ¨å®Œæˆã€‚</p><h2>æ€»ç»“æ—¶åˆ»</h2><p>ä¸‹é¢æˆ‘ä»¬æ¥æ€»ç»“ä¸€ä¸‹å­˜å‚¨è™šæ‹ŸåŒ–çš„åœºæ™¯ä¸‹ï¼Œæ•´ä¸ªå†™å…¥çš„è¿‡ç¨‹ã€‚</p><ul>\n<li>åœ¨è™šæ‹Ÿæœºé‡Œé¢ï¼Œåº”ç”¨å±‚è°ƒç”¨writeç³»ç»Ÿè°ƒç”¨å†™å…¥æ–‡ä»¶ã€‚</li>\n<li>writeç³»ç»Ÿè°ƒç”¨è¿›å…¥è™šæ‹Ÿæœºé‡Œé¢çš„å†…æ ¸ï¼Œç»è¿‡VFSï¼Œé€šç”¨å—è®¾å¤‡å±‚ï¼ŒI/Oè°ƒåº¦å±‚ï¼Œåˆ°è¾¾å—è®¾å¤‡é©±åŠ¨ã€‚</li>\n<li>è™šæ‹Ÿæœºé‡Œé¢çš„å—è®¾å¤‡é©±åŠ¨æ˜¯virtio_blkï¼Œå®ƒå’Œé€šç”¨çš„å—è®¾å¤‡é©±åŠ¨ä¸€æ ·ï¼Œæœ‰ä¸€ä¸ªrequest  queueï¼Œå¦å¤–æœ‰ä¸€ä¸ªå‡½æ•°make_request_fnä¼šè¢«è®¾ç½®ä¸ºblk_mq_make_requestï¼Œè¿™ä¸ªå‡½æ•°ç”¨äºå°†è¯·æ±‚æ”¾å…¥é˜Ÿåˆ—ã€‚</li>\n<li>è™šæ‹Ÿæœºé‡Œé¢çš„å—è®¾å¤‡é©±åŠ¨æ˜¯virtio_blkä¼šæ³¨å†Œä¸€ä¸ªä¸­æ–­å¤„ç†å‡½æ•°vp_interruptã€‚å½“qemuå†™å…¥å®Œæˆä¹‹åï¼Œå®ƒä¼šé€šçŸ¥è™šæ‹Ÿæœºé‡Œé¢çš„å—è®¾å¤‡é©±åŠ¨ã€‚</li>\n<li>blk_mq_make_requestæœ€ç»ˆè°ƒç”¨virtqueue_addï¼Œå°†è¯·æ±‚æ·»åŠ åˆ°ä¼ è¾“é˜Ÿåˆ—virtqueueä¸­ï¼Œç„¶åè°ƒç”¨virtqueue_notifyé€šçŸ¥qemuã€‚</li>\n<li>åœ¨qemuä¸­ï¼Œæœ¬æ¥è™šæ‹Ÿæœºæ­£å¤„äºKVM_RUNçš„çŠ¶æ€ï¼Œä¹Ÿå³å¤„äºå®¢æˆ·æœºçŠ¶æ€ã€‚</li>\n<li>qemuæ”¶åˆ°é€šçŸ¥åï¼Œé€šè¿‡VM exitæŒ‡ä»¤é€€å‡ºå®¢æˆ·æœºçŠ¶æ€ï¼Œè¿›å…¥å®¿ä¸»æœºçŠ¶æ€ï¼Œæ ¹æ®é€€å‡ºåŸå› ï¼Œå¾—çŸ¥æœ‰I/Oéœ€è¦å¤„ç†ã€‚</li>\n<li>qemuè°ƒç”¨virtio_blk_handle_outputï¼Œæœ€ç»ˆè°ƒç”¨virtio_blk_handle_vqã€‚</li>\n<li>virtio_blk_handle_vqé‡Œé¢æœ‰ä¸€ä¸ªå¾ªç¯ï¼Œåœ¨å¾ªç¯ä¸­ï¼Œvirtio_blk_get_requestå‡½æ•°ä»ä¼ è¾“é˜Ÿåˆ—ä¸­æ‹¿å‡ºè¯·æ±‚ï¼Œç„¶åè°ƒç”¨virtio_blk_handle_requestå¤„ç†è¯·æ±‚ã€‚</li>\n<li>virtio_blk_handle_requestä¼šè°ƒç”¨blk_aio_pwritevï¼Œé€šè¿‡BlockBackendé©±åŠ¨å†™å…¥qcow2æ–‡ä»¶ã€‚</li>\n<li>å†™å…¥å®Œæ¯•ä¹‹åï¼Œvirtio_blk_req_completeä¼šè°ƒç”¨virtio_notifyé€šçŸ¥è™šæ‹Ÿæœºé‡Œé¢çš„é©±åŠ¨ã€‚æ•°æ®å†™å…¥å®Œæˆï¼Œåˆšæ‰æ³¨å†Œçš„ä¸­æ–­å¤„ç†å‡½æ•°vp_interruptä¼šæ”¶åˆ°è¿™ä¸ªé€šçŸ¥ã€‚</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/79/0c/79ad143a3149ea36bc80219940d7d00c.jpg?wh=2503*5023\" alt=\"\"></p><h2>è¯¾å ‚ç»ƒä¹ </h2><p>è¯·ä½ æ²¿ç€ä»£ç ï¼Œä»”ç»†åˆ†æå¹¶ç‰¢è®°virtqueueçš„ç»“æ„ä»¥åŠå†™å…¥å’Œè¯»å–æ–¹å¼ã€‚è¿™ä¸ªç»“æ„åœ¨ä¸‹é¢çš„ç½‘ç»œä¼ è¾“è¿‡ç¨‹ä¸­ï¼Œè¿˜è¦èµ·å¤§ä½œç”¨ã€‚</p><p>æ¬¢è¿ç•™è¨€å’Œæˆ‘åˆ†äº«ä½ çš„ç–‘æƒ‘å’Œè§è§£ï¼Œä¹Ÿæ¬¢è¿æ”¶è—æœ¬èŠ‚å†…å®¹ï¼Œåå¤ç ”è¯»ã€‚ä½ ä¹Ÿå¯ä»¥æŠŠä»Šå¤©çš„å†…å®¹åˆ†äº«ç»™ä½ çš„æœ‹å‹ï¼Œå’Œä»–ä¸€èµ·å­¦ä¹ å’Œè¿›æ­¥ã€‚</p><p><img src=\"https://static001.geekbang.org/resource/image/8c/37/8c0a95fa07a8b9a1abfd394479bdd637.jpg?wh=1110*659\" alt=\"\"></p>","neighbors":{"left":{"article_title":"53 | å­˜å‚¨è™šæ‹ŸåŒ–ï¼ˆä¸Šï¼‰ï¼šå¦‚ä½•å»ºç«‹è‡ªå·±ä¿ç®¡çš„å•ç‹¬æ¡£æ¡ˆåº“ï¼Ÿ","id":110697},"right":{"article_title":"55 | ç½‘ç»œè™šæ‹ŸåŒ–ï¼šå¦‚ä½•æˆç«‹ç‹¬ç«‹çš„åˆä½œéƒ¨ï¼Ÿ","id":111686}},"comments":[{"had_liked":false,"id":119348,"user_name":"æ²¡å¿ƒæ²¡è‚º","can_delete":false,"product_type":"c1","uid":1258867,"ip_address":"","ucode":"121FD3AEBA3BEA","user_header":"https://static001.geekbang.org/account/avatar/00/13/35/73/46d6dadc.jpg","comment_is_top":false,"comment_ctime":1564567292,"is_pvip":false,"replies":[{"id":"46384","content":"çš„ç¡®ï¼Œä½“ç³»æ¯”è¾ƒå¤æ‚ï¼Œå…³è”æ€§å¾ˆå¼º","user_name":"ä½œè€…å›å¤","user_name_real":"åˆ˜è¶…@ç½‘æ˜“äº‘","uid":"1001590","ctime":1566297882,"ip_address":"","comment_id":119348,"utype":1}],"discussion_count":2,"race_medal":0,"score":"61694109436","product_id":100024701,"comment_content":"æ¯æ¬¡çœ‹åˆ°æ–‡ä¸­è¯´è¿˜è®°å¾—ä»€ä¹ˆä»€ä¹ˆå—ï¼Œæˆ‘å¿ƒé‡Œæ€»æ˜¯é»˜é»˜å›ç­”:ä¸ è®° å¾—ğŸ˜‚","like_count":15,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"åˆ˜è¶…","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460859,"discussion_content":"çš„ç¡®ï¼Œä½“ç³»æ¯”è¾ƒå¤æ‚ï¼Œå…³è”æ€§å¾ˆå¼º","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566297882,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1219496,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg","nickname":"LeonğŸ“·","note":"","ucode":"B9BBD1EFAAE5A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3679,"discussion_content":"å¼ ä¸‰ä¸°é—®å¼ æ— å¿Œï¼Œå¤ªæå‰‘ä½ è¿˜è®°å¾—å‡ æˆï¼Œæ— å¿Œå·²ç»å…¨éƒ¨å¿˜äº†ã€‚è¿™å°±å¯¹äº†ï¼Œæ„ä¼šè€Œå¿˜è®°å…·ä½“å½¢å¼ï¼Œä½ å·²ç»é¢†ä¼šäº†ç²¾é«“äº†","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564704775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207680,"user_name":"Adam Lau","can_delete":false,"product_type":"c1","uid":1266698,"ip_address":"","ucode":"7E542D6E789500","user_header":"https://static001.geekbang.org/account/avatar/00/13/54/0a/9a002ad5.jpg","comment_is_top":false,"comment_ctime":1587135495,"is_pvip":false,"replies":[{"id":"83915","content":"è°¢è°¢ï¼ŒåŠ æ²¹","user_name":"ä½œè€…å›å¤","user_name_real":"åˆ˜è¶…@ç½‘æ˜“äº‘","uid":"1001590","ctime":1592458397,"ip_address":"","comment_id":207680,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44536808455","product_id":100024701,"comment_content":"å¦ç™½è¯´ï¼Œè¿™æ˜¯æå®¢ä¸ŠæŠ€æœ¯å«é‡æœ€å¥½çš„ä¸“æ äº†ï¼Œå¬ä¸æ‡‚äº†ï¼Œä½†æ˜¯è¡¨ç¤ºæ•¬æ„ã€‚","like_count":11,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"åˆ˜è¶…","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492207,"discussion_content":"è°¢è°¢ï¼ŒåŠ æ²¹","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592458397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164921,"user_name":"williamcai","can_delete":false,"product_type":"c1","uid":1158294,"ip_address":"","ucode":"B158F52C2D39BC","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/96/46b13896.jpg","comment_is_top":false,"comment_ctime":1577112181,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10167046773","product_id":100024701,"comment_content":"è°ƒç”¨é“¾æ¡å¥½é•¿ï¼Œçªç„¶æ¥ä¸ªå›é©¬æªï¼Œä¸€ä¸‹å­æ€åˆ°å¼€å§‹çš„åœ°æ–¹<br>","like_count":3},{"had_liked":false,"id":164648,"user_name":"shangyu","can_delete":false,"product_type":"c1","uid":1011389,"ip_address":"","ucode":"13A26E53508D75","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6e/bd/b83ad32d.jpg","comment_is_top":false,"comment_ctime":1577065474,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10167000066","product_id":100024701,"comment_content":"è€å¸ˆèƒ½ä¸èƒ½è§£é‡Šä¸‹è¿™ç§ç‰¹æ®Šçš„é©±åŠ¨æ¨¡å¼ä¸ç›´æ¥ç¿»è¯‘writeè¯·æ±‚çš„æ€§èƒ½å·®å¼‚","like_count":3},{"had_liked":false,"id":155893,"user_name":"è¿½é£ç­çš„äºº","can_delete":false,"product_type":"c1","uid":1488020,"ip_address":"","ucode":"2993D60F94C396","user_header":"https://static001.geekbang.org/account/avatar/00/16/b4/94/2796de72.jpg","comment_is_top":false,"comment_ctime":1574775303,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869742599","product_id":100024701,"comment_content":"å¥½å¤æ‚é¸­","like_count":1}]}