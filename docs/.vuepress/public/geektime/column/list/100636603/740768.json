{"id":740768,"title":"第 6 章 原始值的响应式方案","content":"<p>在第 5 章中，我们讨论了非原始值的响应式方案，本章我们将讨论原始值的响应式方案。原始值指的是 <code>Boolean</code>、<code>Number</code>、<code>BigInt</code>、<code>String</code>、<code>Symbol</code>、<code>undefined</code> 和 <code>null</code> 等类型的值。在 JavaScript 中，原始值是按值传递的，而非按引用传递。这意味着，如果一个函数接收原始值作为参数，那么形参与实参之间没有引用关系，它们是两个完全独立的值，对形参的修改不会影响实参。另外，JavaScript 中的 <code>Proxy</code> 无法提供对原始值的代理，因此想要将原始值变成响应式数据，就必须对其做一层包裹，也就是我们接下来要介绍的 <code>ref</code>。</p>\n<h2 id=\"nav_point_65\">6.1　引入 <code>ref</code> 的概念</h2>\n<p>由于 <code>Proxy</code> 的代理目标必须是非原始值，所以我们没有任何手段拦截对原始值的操作，例如：</p>\n<pre class=\"code-rows\"><code> let str = 'vue'\n // 无法拦截对值的修改\n str = 'vue3'\n</code></pre>\n<p>对于这个问题，我们能够想到的唯一办法是，使用一个非原始值去“包裹”原始值，例如使用一个对象包裹原始值：</p>\n<pre class=\"code-rows\"><code> const wrapper = {\n   value: 'vue'\n }\n // 可以使用 Proxy 代理 wrapper，间接实现对原始值的拦截\n const name = reactive(wrapper)\n name.value // vue\n // 修改值可以触发响应\n name.value = 'vue3'\n</code></pre>\n<p>但这样做会导致两个问题：</p>\n<ul>\n<li>用户为了创建一个响应式的原始值，不得不顺带创建一个包裹对象；</li>\n<li>包裹对象由用户定义，而这意味着不规范。用户可以随意命名，例如 <code>wrapper.value</code>、<code>wrapper.val</code> 都是可以的。</li>\n</ul>\n<p>为了解决这两个问题，我们可以封装一个函数，将包裹对象的创建工作都封装到该函数中：</p>\n<pre class=\"code-rows\"><code> // 封装一个 ref 函数\n function ref(val) {\n   // 在 ref 函数内部创建包裹对象\n   const wrapper = {\n     value: val\n   }\n   // 将包裹对象变成响应式数据\n   return reactive(wrapper)\n }\n</code></pre>\n<p>如上面的代码所示，我们把创建 <code>wrapper</code> 对象的工作封装到 <code>ref</code> 函数内部，然后使用 <code>reactive</code> 函数将包裹对象变成响应式数据并返回。这样我们就解决了上述两个问题。运行如下测试代码：</p>\n<pre class=\"code-rows\"><code> // 创建原始值的响应式数据\n const refVal = ref(1)\n<p>effect(() =&gt; {<br />\n// 在副作用函数内通过 value 属性读取原始值<br />\nconsole.log(refVal.value)<br />\n})<br />\n// 修改值能够触发副作用函数重新执行<br />\nrefVal.value = 2<br />\n</code></pre></p>\n<p>上面这段代码能够按照预期工作。现在是否一切都完美了呢？并不是，接下来我们面临的第一个问题是，如何区分 <code>refVal</code> 到底是原始值的包裹对象，还是一个非原始值的响应式数据，如以下代码所示：</p><!-- [[[read_end]]] -->\n<pre class=\"code-rows\"><code> const refVal1 = ref(1)\n const refVal2 = reactive({ value: 1 })\n</code></pre>\n<p>思考一下，这段代码中的 <code>refVal1</code> 和 <code>refVal2</code> 有什么区别呢？从我们的实现来看，它们没有任何区别。但是，我们有必要区分一个数据到底是不是 <code>ref</code>，因为这涉及下文讲解的自动脱 <code>ref</code> 能力。</p>\n<p>想要区分一个数据是否是 <code>ref</code> 很简单，怎么做呢？如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function ref(val) {\n   const wrapper = {\n     value: val\n   }\n   // 使用 Object.defineProperty 在 wrapper 对象上定义一个不可枚举的属性 __v_isRef，并且值为 true\n   Object.defineProperty(wrapper, '__v_isRef', {\n     value: true\n   })\n<p>return reactive(wrapper)<br />\n}<br />\n</code></pre></p>\n<p>我们使用 <code>Object.defineProperty</code> 为包裹对象 <code>wrapper</code> 定义了一个不可枚举且不可写的属性 <code>__v_isRef</code>，它的值为 <code>true</code>，代表这个对象是一个 <code>ref</code>，而非普通对象。这样我们就可以通过检查 <code>__v_isRef</code> 属性来判断一个数据是否是 <code>ref</code> 了。</p>\n<h2 id=\"nav_point_66\">6.2　响应丢失问题</h2>\n<p><code>ref</code> 除了能够用于原始值的响应式方案之外，还能用来解决响应丢失问题。首先，我们来看什么是响应丢失问题。在编写 Vue.js 组件时，我们通常要把数据暴露到模板中使用，例如：</p>\n<pre class=\"code-rows\"><code> export default {\n   setup() {\n     // 响应式数据\n     const obj = reactive({ foo: 1, bar: 2 })\n<pre><code> // 将数据暴露到模板中\n return {\n   ...obj\n }\n</code></pre>\n<p>}<br />\n}<br />\n</code></pre></p>\n<p>接着，我们就可以在模板中访问从 <code>setup</code> 中暴露出来的数据：</p>\n<pre class=\"code-rows\"><code> &lt;template&gt;\n   &lt;p&gt;{{ foo }} / {{ bar }}&lt;/p&gt;\n &lt;/template&gt;\n</code></pre>\n<p>然而，这么做会导致响应丢失。其表现是，当我们修改响应式数据的值时，不会触发重新渲染：</p>\n<pre class=\"code-rows\"><code> export default {\n   setup() {\n     // 响应式数据\n     const obj = reactive({ foo: 1, bar: 2 })\n<pre><code> // 1s 后修改响应式数据的值，不会触发重新渲染\n setTimeout(() =&amp;gt; {\n   obj.foo = 100\n }, 1000)\n\n return {\n   ...obj\n }\n</code></pre>\n<p>}<br />\n}<br />\n</code></pre></p>\n<p>为什么会导致响应丢失呢？这是由展开运算符（<code>...</code>）导致的。实际上，下面这段代码：</p>\n<pre class=\"code-rows\"><code> return {\n   ...obj\n }\n</code></pre>\n<p>等价于：</p>\n<pre class=\"code-rows\"><code> return {\n   foo: 1,\n   bar: 2\n }\n</code></pre>\n<p>可以发现，这其实就是返回了一个普通对象，它不具有任何响应式能力。把一个普通对象暴露到模板中使用，是不会在渲染函数与响应式数据之间建立响应联系的。所以当我们尝试在一个定时器中修改 <code>obj.foo</code> 的值时，不会触发重新渲染。我们可以用另一种方式来描述响应丢失问题：</p>\n<pre class=\"code-rows\"><code> // obj 是响应式数据\n const obj = reactive({ foo: 1, bar: 2 })\n<p>// 将响应式数据展开到一个新的对象 newObj<br />\nconst newObj = {<br />\n…obj<br />\n}</p>\n<p>effect(() =&gt; {<br />\n// 在副作用函数内通过新的对象 newObj 读取 foo 属性值<br />\nconsole.log(newObj.foo)<br />\n})</p>\n<p>// 很显然，此时修改 obj.foo 并不会触发响应<br />\nobj.foo = 100<br />\n</code></pre></p>\n<p>如上面的代码所示，首先创建一个响应式的数据对象 <code>obj</code>，然后使用展开运算符得到一个新的对象 <code>newObj</code>，它是一个普通对象，不具有响应能力。这里的关键点在于，副作用函数内访问的是普通对象 <code>newObj</code>，它没有任何响应能力，所以当我们尝试修改 <code>obj.foo</code> 的值时，不会触发副作用函数重新执行。</p>\n<p>如何解决这个问题呢？换句话说，有没有办法能够帮助我们实现：在副作用函数内，即使通过普通对象 <code>newObj</code> 来访问属性值，也能够建立响应联系？其实是可以的，代码如下：</p>\n<pre class=\"code-rows\"><code> // obj 是响应式数据\n const obj = reactive({ foo: 1, bar: 2 })\n<p>// newObj 对象下具有与 obj 对象同名的属性，并且每个属性值都是一个对象，<br />\n// 该对象具有一个访问器属性 value，当读取 value 的值时，其实读取的是 obj 对象下相应的属性值<br />\nconst newObj = {<br />\nfoo: {<br />\nget value() {<br />\nreturn obj.foo<br />\n}<br />\n},<br />\nbar: {<br />\nget value() {<br />\nreturn obj.bar<br />\n}<br />\n}<br />\n}</p>\n<p>effect(() =&gt; {<br />\n// 在副作用函数内通过新的对象 newObj 读取 foo 属性值<br />\nconsole.log(newObj.foo.value)<br />\n})</p>\n<p>// 这时能够触发响应了<br />\nobj.foo = 100<br />\n</code></pre></p>\n<p>在上面这段代码中，我们修改了 <code>newObj</code> 对象的实现方式。可以看到，在现在的 <code>newObj</code> 对象下，具有与 <code>obj</code> 对象同名的属性，而且每个属性的值都是一个对象，例如 <code>foo</code> 属性的值是：</p>\n<pre class=\"code-rows\"><code> {\n   get value() {\n     return obj.foo\n   }\n }\n</code></pre>\n<p>该对象有一个访问器属性 <code>value</code>，当读取 <code>value</code> 的值时，最终读取的是响应式数据 <code>obj</code> 下的同名属性值。也就是说，当在副作用函数内读取 <code>newObj.foo</code> 时，等价于间接读取了 <code>obj.foo</code> 的值。这样响应式数据自然能够与副作用函数建立响应联系。于是，当我们尝试修改 <code>obj.foo</code> 的值时，能够触发副作用函数重新执行。</p>\n<p>观察 <code>newObj</code> 对象，可以发现它的结构存在相似之处：</p>\n<pre class=\"code-rows\"><code> const newObj = {\n   foo: {\n     get value() {\n       return obj.foo\n     }\n   },\n   bar: {\n     get value() {\n       return obj.bar\n     }\n   }\n }\n</code></pre>\n<p><code>foo</code> 和 <code>bar</code> 这两个属性的结构非常像，这启发我们将这种结构抽象出来并封装成函数，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function toRef(obj, key) {\n   const wrapper = {\n     get value() {\n       return obj[key]\n     }\n   }\n<p>return wrapper<br />\n}<br />\n</code></pre></p>\n<p><code>toRef</code> 函数接收两个参数，第一个参数 <code>obj</code> 是一个响应式数据，第二个参数是 <code>obj</code> 对象的一个键。该函数会返回一个类似于 <code>ref</code> 结构的 <code>wrapper</code> 对象。有了 <code>toRef</code> 函数后，我们就可以重新实现 <code>newObj</code> 对象了：</p>\n<pre class=\"code-rows\"><code> const newObj = {\n   foo: toRef(obj, 'foo'),\n   bar: toRef(obj, 'bar')\n }\n</code></pre>\n<p>可以看到，代码变得非常简洁。但如果响应式数据 <code>obj</code> 的键非常多，我们还是要花费很大力气来做这一层转换。为此，我们可以封装 <code>toRefs</code> 函数，来批量地完成转换：</p>\n<pre class=\"code-rows\"><code> function toRefs(obj) {\n   const ret = {}\n   // 使用 for...in 循环遍历对象\n   for (const key in obj) {\n     // 逐个调用 toRef 完成转换\n     ret[key] = toRef(obj, key)\n   }\n   return ret\n }\n</code></pre>\n<p>现在，我们只需要一步操作即可完成对一个对象的转换：</p>\n<pre class=\"code-rows\"><code> const newObj = { ...toRefs(obj) }\n</code></pre>\n<p>可以使用如下代码进行测试：</p>\n<pre class=\"code-rows\"><code> const obj = reactive({ foo: 1, bar: 2 })\n<p>const newObj = { …toRefs(obj) }<br />\nconsole.log(newObj.foo.value) // 1<br />\nconsole.log(newObj.bar.value) // 2<br />\n</code></pre></p>\n<p>现在，响应丢失问题就被我们彻底解决了。解决问题的思路是，将响应式数据转换成类似于 <code>ref</code> 结构的数据。但为了概念上的统一，我们会将通过 <code>toRef</code> 或 <code>toRefs</code> 转换后得到的结果视为真正的 <code>ref</code> 数据，为此我们需要为 <code>toRef</code> 函数增加一段代码：</p>\n<pre class=\"code-rows\"><code> function toRef(obj, key) {\n   const wrapper = {\n     get value() {\n       return obj[key]\n     }\n   }\n   // 定义 __v_isRef 属性\n   Object.defineProperty(wrapper, '__v_isRef', {\n     value: true\n   })\n<p>return wrapper<br />\n}<br />\n</code></pre></p>\n<p>可以看到，我们使用 <code>Object.defineProperty</code> 函数为 <code>wrapper</code> 对象定义了 <code>__v_isRef</code> 属性。这样，<code>toRef</code> 函数的返回值就是真正意义上的 <code>ref</code> 了。通过上述讲解我们能注意到，<code>ref</code> 的作用不仅仅是实现原始值的响应式方案，它还用来解决响应丢失问题。</p>\n<p>但上文中实现的 <code>toRef</code> 函数存在缺陷，即通过 <code>toRef</code> 函数创建的 <code>ref</code> 是只读的，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> const obj = reactive({ foo: 1, bar: 2 })\n const refFoo = toRef(obj, 'foo')\n<p>refFoo.value = 100 // 无效<br />\n</code></pre></p>\n<p>这是因为 <code>toRef</code> 返回的 <code>wrapper</code> 对象的 <code>value</code> 属性只有 <code>getter</code>，没有 <code>setter</code>。为了功能的完整性，我们应该为它加上 <code>setter</code> 函数，所以最终的实现如下：</p>\n<pre class=\"code-rows\"><code> function toRef(obj, key) {\n   const wrapper = {\n     get value() {\n       return obj[key]\n     },\n     // 允许设置值\n     set value(val) {\n       obj[key] = val\n     }\n   }\n<p>Object.defineProperty(wrapper, ‘__v_isRef’, {<br />\nvalue: true<br />\n})</p>\n<p>return wrapper<br />\n}<br />\n</code></pre></p>\n<p>可以看到，当设置 <code>value</code> 属性的值时，最终设置的是响应式数据的同名属性的值，这样就能正确地触发响应了。</p>\n<h2 id=\"nav_point_67\">6.3　自动脱 <code>ref</code></h2>\n<p><code>toRefs</code> 函数的确解决了响应丢失问题，但同时也带来了新的问题。由于 <code>toRefs</code> 会把响应式数据的第一层属性值转换为 <code>ref</code>，因此必须通过 <code>value</code> 属性访问值，如以下代码所示：</p>\n<pre class=\"code-rows\"><code> const obj = reactive({ foo: 1, bar: 2 })\n obj.foo // 1\n obj.bar // 2\n<p>const newObj = { …toRefs(obj) }<br />\n// 必须使用 value 访问值<br />\nnewObj.foo.value // 1<br />\nnewObj.bar.value // 2<br />\n</code></pre></p>\n<p>这其实增加了用户的心智负担，因为通常情况下用户是在模板中访问数据的，例如：</p>\n<pre class=\"code-rows\"><code> &lt;p&gt;{{ foo }} / {{ bar }}&lt;/p&gt;\n</code></pre>\n<p>用户肯定不希望编写下面这样的代码：</p>\n<pre class=\"code-rows\"><code> &lt;p&gt;{{ foo.value }} / {{ bar.value }}&lt;/p&gt;\n</code></pre>\n<p>因此，我们需要自动脱 <code>ref</code> 的能力。所谓自动脱 <code>ref</code>，指的是属性的访问行为，即如果读取的属性是一个 <code>ref</code>，则直接将该 <code>ref</code> 对应的 <code>value</code> 属性值返回，例如：</p>\n<pre class=\"code-rows\"><code> newObj.foo // 1\n</code></pre>\n<p>可以看到，即使 <code>newObj.foo</code> 是一个 <code>ref</code>，也无须通过 <code>newObj.foo.value</code> 来访问它的值。要实现此功能，需要使用 <code>Proxy</code> 为 <code>newObj</code> 创建一个代理对象，通过代理来实现最终目标，这时就用到了上文中介绍的 <code>ref</code> 标识，即 <code>__v_isRef</code> 属性，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function proxyRefs(target) {\n   return new Proxy(target, {\n     get(target, key, receiver) {\n       const value = Reflect.get(target, key, receiver)\n       // 自动脱 ref 实现：如果读取的值是 ref，则返回它的 value 属性值\n       return value.__v_isRef ? value.value : value\n     }\n   })\n }\n<p>// 调用 proxyRefs 函数创建代理<br />\nconst newObj = proxyRefs({ …toRefs(obj) })<br />\n</code></pre></p>\n<p>在上面这段代码中，我们定义了 <code>proxyRefs</code> 函数，该函数接收一个对象作为参数，并返回该对象的代理对象。代理对象的作用是拦截 <code>get</code> 操作，当读取的属性是一个 <code>ref</code> 时，则直接返回该 <code>ref</code> 的 <code>value</code> 属性值，这样就实现了自动脱 <code>ref</code>：</p>\n<pre class=\"code-rows\"><code> console.log(newObj.foo) // 1\n console.log(newObj.bar) // 2\n</code></pre>\n<p>实际上，我们在编写 Vue.js 组件时，组件中的 <code>setup</code> 函数所返回的数据会传递给 <code>proxyRefs</code> 函数进行处理：</p>\n<pre class=\"code-rows\"><code> const MyComponent = {\n   setup() {\n     const count = ref(0)\n<pre><code> // 返回的这个对象会传递给 proxyRefs\n return { count }\n</code></pre>\n<p>}<br />\n}<br />\n</code></pre></p>\n<p>这也是为什么我们可以在模板直接访问一个 <code>ref</code> 的值，而无须通过 <code>value</code> 属性来访问：</p>\n<pre class=\"code-rows\"><code> &lt;p&gt;{{ count }}&lt;/p&gt;\n</code></pre>\n<p>既然读取属性的值有自动脱 <code>ref</code> 的能力，对应地，设置属性的值也应该有自动为 <code>ref</code> 设置值的能力，例如：</p>\n<pre class=\"code-rows\"><code> newObj.foo = 100 // 应该生效\n</code></pre>\n<p>实现此功能很简单，只需要添加对应的 <code>set</code> 拦截函数即可：</p>\n<pre class=\"code-rows\"><code> function proxyRefs(target) {\n   return new Proxy(target, {\n     get(target, key, receiver) {\n       const value = Reflect.get(target, key, receiver)\n       return value.__v_isRef ? value.value : value\n     },\n     set(target, key, newValue, receiver) {\n       // 通过 target 读取真实值\n       const value = target[key]\n       // 如果值是 Ref，则设置其对应的 value 属性值\n       if (value.__v_isRef) {\n         value.value = newValue\n         return true\n       }\n       return Reflect.set(target, key, newValue, receiver)\n     }\n   })\n }\n</code></pre>\n<p>如上面的代码所示，我们为 <code>proxyRefs</code> 函数返回的代理对象添加了 <code>set</code> 拦截函数。如果设置的属性是一个 <code>ref</code>，则间接设置该 <code>ref</code> 的 <code>value</code> 属性的值即可。</p>\n<p>实际上，自动脱 <code>ref</code> 不仅存在于上述场景。在 Vue.js 中，<code>reactive</code> 函数也有自动脱 <code>ref</code> 的能力，如以下代码所示：</p>\n<pre class=\"code-rows\"><code> const count = ref(0)\n const obj = reactive({ count })\n<p>obj.count // 0<br />\n</code></pre></p>\n<p>可以看到，<code>obj.count</code> 本应该是一个 <code>ref</code>，但由于自动脱 <code>ref</code> 能力的存在，使得我们无须通过 <code>value</code> 属性即可读取 <code>ref</code> 的值。这么设计旨在减轻用户的心智负担，因为在大部分情况下，用户并不知道一个值到底是不是 <code>ref</code>。有了自动脱 <code>ref</code> 的能力后，用户在模板中使用响应式数据时，将不再需要关心哪些是 <code>ref</code>，哪些不是 <code>ref</code>。</p>\n<h2 id=\"nav_point_68\">6.4　总结</h2>\n<p>在本章中，我们首先介绍了 <code>ref</code> 的概念。<code>ref</code> 本质上是一个“包裹对象”。因为 JavaScript 的 <code>Proxy</code> 无法提供对原始值的代理，所以我们需要使用一层对象作为包裹，间接实现原始值的响应式方案。由于“包裹对象”本质上与普通对象没有任何区别，因此为了区分 <code>ref</code> 与普通响应式对象，我们还为“包裹对象”定义了一个值为 <code>true</code> 的属性，即 <code>__v_isRef</code>，用它作为 <code>ref</code> 的标识。</p>\n<p><code>ref</code> 除了能够用于原始值的响应式方案之外，还能用来解决响应丢失问题。为了解决该问题，我们实现了 <code>toRef</code> 以及 <code>toRefs</code> 这两个函数。它们本质上是对响应式数据做了一层包装，或者叫作“访问代理”。</p>\n<p>最后，我们讲解了自动脱 <code>ref</code> 的能力。为了减轻用户的心智负担，我们自动对暴露到模板中的响应式数据进行脱 <code>ref</code> 处理。这样，用户在模板中使用响应式数据时，就无须关心一个值是不是 <code>ref</code> 了。</p>\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 5 章 非原始值的响应式方案(3)","id":740767},"right":{"article_title":"第 7 章 渲染器的设计","id":740769}},"comments":[]}