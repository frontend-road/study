{"id":12192,"title":"07 | JVM是如何实现反射的？","content":"<p>今天我们来聊聊Java里的反射机制。</p>\n<p>反射是Java语言中一个相当重要的特性，它允许正在运行的Java程序观测，甚至是修改程序的动态行为。</p>\n<p>举例来说，我们可以通过Class对象枚举该类中的所有方法，我们还可以通过Method.setAccessible（位于java.lang.reflect包，该方法继承自AccessibleObject）绕过Java语言的访问权限，在私有方法所在类之外的地方调用该方法。</p>\n<p>反射在Java中的应用十分广泛。开发人员日常接触到的Java集成开发环境（IDE）便运用了这一功能：每当我们敲入点号时，IDE便会根据点号前的内容，动态展示可以访问的字段或者方法。</p>\n<p>另一个日常应用则是Java调试器，它能够在调试过程中枚举某一对象所有字段的值。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/ce/75/ceeabb2dbdd80577feaecd0879e42675.png?wh=628*466\" alt=\"\" /></p>\n<p>（图中eclipse的自动提示使用了反射）</p>\n<p>在Web开发中，我们经常能够接触到各种可配置的通用框架。为了保证框架的可扩展性，它们往往借助Java的反射机制，根据配置文件来加载不同的类。举例来说，Spring框架的依赖反转（IoC），便是依赖于反射机制。</p>\n<p>然而，我相信不少开发人员都嫌弃反射机制比较慢。甚至是甲骨文关于反射的教学网页[1]，也强调了反射性能开销大的缺点。</p><!-- [[[read_end]]] -->\n<p>今天我们便来了解一下反射的实现机制，以及它性能糟糕的原因。如果你对反射API不是特别熟悉的话，你可以查阅我放在文稿末尾的附录。</p>\n<h2>反射调用的实现</h2>\n<p>首先，我们来看看方法的反射调用，也就是Method.invoke，是怎么实现的。</p>\n<pre><code>public final class Method extends Executable {\n  ...\n  public Object invoke(Object obj, Object... args) throws ... {\n    ... // 权限检查\n    MethodAccessor ma = methodAccessor;\n    if (ma == null) {\n      ma = acquireMethodAccessor();\n    }\n    return ma.invoke(obj, args);\n  }\n}\n\n</code></pre>\n<p>如果你查阅Method.invoke的源代码，那么你会发现，它实际上委派给MethodAccessor来处理。MethodAccessor是一个接口，它有两个已有的具体实现：一个通过本地方法来实现反射调用，另一个则使用了委派模式。为了方便记忆，我便用“本地实现”和“委派实现”来指代这两者。</p>\n<p>每个Method实例的第一次反射调用都会生成一个委派实现，它所委派的具体实现便是一个本地实现。本地实现非常容易理解。当进入了Java虚拟机内部之后，我们便拥有了Method实例所指向方法的具体地址。这时候，反射调用无非就是将传入的参数准备好，然后调用进入目标方法。</p>\n<pre><code>// v0版本\nimport java.lang.reflect.Method;\n\npublic class Test {\n  public static void target(int i) {\n    new Exception(&quot;#&quot; + i).printStackTrace();\n  }\n\n  public static void main(String[] args) throws Exception {\n    Class&lt;?&gt; klass = Class.forName(&quot;Test&quot;);\n    Method method = klass.getMethod(&quot;target&quot;, int.class);\n    method.invoke(null, 0);\n  }\n}\n\n# 不同版本的输出略有不同，这里我使用了Java 10。\n$ java Test\njava.lang.Exception: #0\n        at Test.target(Test.java:5)\n        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl .invoke0(Native Method)\n a      t java.base/jdk.internal.reflect.NativeMethodAccessorImpl. .invoke(NativeMethodAccessorImpl.java:62)\n t       java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.i .invoke(DelegatingMethodAccessorImpl.java:43)\n        java.base/java.lang.reflect.Method.invoke(Method.java:564)\n  t        Test.main(Test.java:131\n</code></pre>\n<p>为了方便理解，我们可以打印一下反射调用到目标方法时的栈轨迹。在上面的v0版本代码中，我们获取了一个指向Test.target方法的Method对象，并且用它来进行反射调用。在Test.target中，我会打印出栈轨迹。</p>\n<p>可以看到，反射调用先是调用了Method.invoke，然后进入委派实现（DelegatingMethodAccessorImpl），再然后进入本地实现（NativeMethodAccessorImpl），最后到达目标方法。</p>\n<p>这里你可能会疑问，为什么反射调用还要采取委派实现作为中间层？直接交给本地实现不可以么？</p>\n<p>其实，Java的反射调用机制还设立了另一种动态生成字节码的实现（下称动态实现），直接使用invoke指令来调用目标方法。之所以采用委派实现，便是为了能够在本地实现以及动态实现中切换。</p>\n<pre><code>// 动态实现的伪代码，这里只列举了关键的调用逻辑，其实它还包括调用者检测、参数检测的字节码。\npackage jdk.internal.reflect;\n\npublic class GeneratedMethodAccessor1 extends ... {\n  @Overrides    \n  public Object invoke(Object obj, Object[] args) throws ... {\n    Test.target((int) args[0]);\n    return null;\n  }\n}\n</code></pre>\n<p>动态实现和本地实现相比，其运行效率要快上20倍 [2] 。这是因为动态实现无需经过Java到C++再到Java的切换，但由于生成字节码十分耗时，仅调用一次的话，反而是本地实现要快上3到4倍 [3]。</p>\n<p>考虑到许多反射调用仅会执行一次，Java虚拟机设置了一个阈值15（可以通过-Dsun.reflect.inflationThreshold=来调整），当某个反射调用的调用次数在15之下时，采用本地实现；当达到15时，便开始动态生成字节码，并将委派实现的委派对象切换至动态实现，这个过程我们称之为Inflation。</p>\n<p>为了观察这个过程，我将刚才的例子更改为下面的v1版本。它会将反射调用循环20次。</p>\n<pre><code>// v1版本\nimport java.lang.reflect.Method;\n\npublic class Test {\n  public static void target(int i) {\n    new Exception(&quot;#&quot; + i).printStackTrace();\n  }\n\n  public static void main(String[] args) throws Exception {\n    Class&lt;?&gt; klass = Class.forName(&quot;Test&quot;);\n    Method method = klass.getMethod(&quot;target&quot;, int.class);\n    for (int i = 0; i &lt; 20; i++) {\n      method.invoke(null, i);\n    }\n  }\n}\n\n# 使用-verbose:class打印加载的类\n$ java -verbose:class Test\n...\njava.lang.Exception: #14\n        at Test.target(Test.java:5)\n        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl .invoke0(Native Method)\n        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl .invoke(NativeMethodAccessorImpl.java:62)\n        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl .invoke(DelegatingMethodAccessorImpl.java:43)\n        at java.base/java.lang.reflect.Method.invoke(Method.java:564)\n        at Test.main(Test.java:12)\n[0.158s][info][class,load] ...\n...\n[0.160s][info][class,load] jdk.internal.reflect.GeneratedMethodAccessor1 source: __JVM_DefineClass__\njava.lang.Exception: #15\n       at Test.target(Test.java:5)\n       at java.base/jdk.internal.reflect.NativeMethodAccessorImpl .invoke0(Native Method)\n       at java.base/jdk.internal.reflect.NativeMethodAccessorImpl .invoke(NativeMethodAccessorImpl.java:62)\n       at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl .invoke(DelegatingMethodAccessorImpl.java:43)\n       at java.base/java.lang.reflect.Method.invoke(Method.java:564)\n       at Test.main(Test.java:12)\njava.lang.Exception: #16\n       at Test.target(Test.java:5)\n       at jdk.internal.reflect.GeneratedMethodAccessor1 .invoke(Unknown Source)\n       at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl .invoke(DelegatingMethodAccessorImpl.java:43)\n       at java.base/java.lang.reflect.Method.invoke(Method.java:564)\n       at Test.main(Test.java:12)\n...\n</code></pre>\n<p>可以看到，在第15次（从0开始数）反射调用时，我们便触发了动态实现的生成。这时候，Java虚拟机额外加载了不少类。其中，最重要的当属GeneratedMethodAccessor1（第30行）。并且，从第16次反射调用开始，我们便切换至这个刚刚生成的动态实现（第40行）。</p>\n<p>反射调用的Inflation机制是可以通过参数（-Dsun.reflect.noInflation=true）来关闭的。这样一来，在反射调用一开始便会直接生成动态实现，而不会使用委派实现或者本地实现。</p>\n<h2>反射调用的开销</h2>\n<p>下面，我们便来拆解反射调用的性能开销。</p>\n<p>在刚才的例子中，我们先后进行了Class.forName，Class.getMethod以及Method.invoke三个操作。其中，Class.forName会调用本地方法，Class.getMethod则会遍历该类的公有方法。如果没有匹配到，它还将遍历父类的公有方法。可想而知，这两个操作都非常费时。</p>\n<p>值得注意的是，以getMethod为代表的查找方法操作，会返回查找得到结果的一份拷贝。因此，我们应当避免在热点代码中使用返回Method数组的getMethods或者getDeclaredMethods方法，以减少不必要的堆空间消耗。</p>\n<p>在实践中，我们往往会在应用程序中缓存Class.forName和Class.getMethod的结果。因此，下面我就只关注反射调用本身的性能开销。</p>\n<p>为了比较直接调用和反射调用的性能差距，我将前面的例子改为下面的v2版本。它会将反射调用循环二十亿次。此外，它还将记录下每跑一亿次的时间。</p>\n<p>我将取最后五个记录的平均值，作为预热后的峰值性能。（注：这种性能评估方式并不严谨，我会在专栏的第三部分介绍如何用JMH来测性能。）</p>\n<p>在我这个老笔记本上，一亿次直接调用耗费的时间大约在120ms。这和不调用的时间是一致的。其原因在于这段代码属于热循环，同样会触发即时编译。并且，即时编译会将对Test.target的调用内联进来，从而消除了调用的开销。</p>\n<pre><code>// v2版本\nmport java.lang.reflect.Method;\n\npublic class Test {\n  public static void target(int i) {\n    // 空方法\n  }\n\n  public static void main(String[] args) throws Exception {\n    Class&lt;?&gt; klass = Class.forName(&quot;Test&quot;);\n    Method method = klass.getMethod(&quot;target&quot;, int.class);\n\n    long current = System.currentTimeMillis();\n    for (int i = 1; i &lt;= 2_000_000_000; i++) {\n      if (i % 100_000_000 == 0) {\n        long temp = System.currentTimeMillis();\n        System.out.println(temp - current);\n        current = temp;\n      }\n\n      method.invoke(null, 128);\n    }\n  }\n}\n\n</code></pre>\n<p>下面我将以120ms作为基准，来比较反射调用的性能开销。</p>\n<p>由于目标方法Test.target接收一个int类型的参数，因此我传入128作为反射调用的参数，测得的结果约为基准的2.7倍。我们暂且不管这个数字是高是低，先来看看在反射调用之前字节码都做了什么。</p>\n<pre><code>   59: aload_2                         // 加载Method对象\n   60: aconst_null                     // 反射调用的第一个参数null\n   61: iconst_1\n   62: anewarray Object                // 生成一个长度为1的Object数组\n   65: dup\n   66: iconst_0\n   67: sipush 128\n   70: invokestatic Integer.valueOf    // 将128自动装箱成Integer\n   73: aastore                         // 存入Object数组中\n   74: invokevirtual Method.invoke     // 反射调用\n</code></pre>\n<p>这里我截取了循环中反射调用编译而成的字节码。可以看到，这段字节码除了反射调用外，还额外做了两个操作。</p>\n<p>第一，由于Method.invoke是一个变长参数方法，在字节码层面它的最后一个参数会是Object数组（感兴趣的同学私下可以用javap查看）。Java编译器会在方法调用处生成一个长度为传入参数数量的Object数组，并将传入参数一一存储进该数组中。</p>\n<p>第二，由于Object数组不能存储基本类型，Java编译器会对传入的基本类型参数进行自动装箱。</p>\n<p>这两个操作除了带来性能开销外，还可能占用堆内存，使得GC更加频繁。（如果你感兴趣的话，可以用虚拟机参数-XX:+PrintGC试试。）那么，如何消除这部分开销呢？</p>\n<p>关于第二个自动装箱，Java缓存了[-128, 127]中所有整数所对应的Integer对象。当需要自动装箱的整数在这个范围之内时，便返回缓存的Integer，否则需要新建一个Integer对象。</p>\n<p>因此，我们可以将这个缓存的范围扩大至覆盖128（对应参数<br />\n-Djava.lang.Integer.IntegerCache.high=128），便可以避免需要新建Integer对象的场景。</p>\n<p>或者，我们可以在循环外缓存128自动装箱得到的Integer对象，并且直接传入反射调用中。这两种方法测得的结果差不多，约为基准的1.8倍。</p>\n<p>现在我们再回来看看第一个因变长参数而自动生成的Object数组。既然每个反射调用对应的参数个数是固定的，那么我们可以选择在循环外新建一个Object数组，设置好参数，并直接交给反射调用。改好的代码可以参照文稿中的v3版本。</p>\n<pre><code>// v3版本\nimport java.lang.reflect.Method;\n\npublic class Test {\n  public static void target(int i) {\n    // 空方法\n  }\n\n  public static void main(String[] args) throws Exception {\n    Class&lt;?&gt; klass = Class.forName(&quot;Test&quot;);\n    Method method = klass.getMethod(&quot;target&quot;, int.class);\n\n    Object[] arg = new Object[1]; // 在循环外构造参数数组\n    arg[0] = 128;\n\n    long current = System.currentTimeMillis();\n    for (int i = 1; i &lt;= 2_000_000_000; i++) {\n      if (i % 100_000_000 == 0) {\n        long temp = System.currentTimeMillis();\n        System.out.println(temp - current);\n        current = temp;\n      }\n\n      method.invoke(null, arg);\n    }\n  }\n}\n</code></pre>\n<p>测得的结果反而更糟糕了，为基准的2.9倍。这是为什么呢？</p>\n<p>如果你在上一步解决了自动装箱之后查看运行时的GC状况，你会发现这段程序并不会触发GC。其原因在于，原本的反射调用被内联了，从而使得即时编译器中的逃逸分析将原本新建的Object数组判定为不逃逸的对象。</p>\n<p>如果一个对象不逃逸，那么即时编译器可以选择栈分配甚至是虚拟分配，也就是不占用堆空间。具体我会在本专栏的第二部分详细解释。</p>\n<p>如果在循环外新建数组，即时编译器无法确定这个数组会不会中途被更改，因此无法优化掉访问数组的操作，可谓是得不偿失。</p>\n<p>到目前为止，我们的最好记录是1.8倍。那能不能再进一步提升呢？</p>\n<p>刚才我曾提到，可以关闭反射调用的Inflation机制，从而取消委派实现，并且直接使用动态实现。此外，每次反射调用都会检查目标方法的权限，而这个检查同样可以在Java代码里关闭，在关闭了这两项机制之后，也就得到了我们的v4版本，它测得的结果约为基准的1.3倍。</p>\n<pre><code>\n// v4版本\nimport java.lang.reflect.Method;\n\n// 在运行指令中添加如下两个虚拟机参数：\n// -Djava.lang.Integer.IntegerCache.high=128\n// -Dsun.reflect.noInflation=true\npublic class Test {\n  public static void target(int i) {\n    // 空方法\n  }\n\n  public static void main(String[] args) throws Exception {\n    Class&lt;?&gt; klass = Class.forName(&quot;Test&quot;);\n    Method method = klass.getMethod(&quot;target&quot;, int.class);\n    method.setAccessible(true);  // 关闭权限检查\n\n    long current = System.currentTimeMillis();\n    for (int i = 1; i &lt;= 2_000_000_000; i++) {\n      if (i % 100_000_000 == 0) {\n        long temp = System.currentTimeMillis();\n        System.out.println(temp - current);\n        current = temp;\n      }\n\n      method.invoke(null, 128);\n    }\n  }\n}\n\n</code></pre>\n<p>到这里，我们基本上把反射调用的水分都榨干了。接下来，我来把反射调用的性能开销给提回去。</p>\n<p>首先，在这个例子中，之所以反射调用能够变得这么快，主要是因为即时编译器中的方法内联。在关闭了Inflation的情况下，内联的瓶颈在于Method.invoke方法中对MethodAccessor.invoke方法的调用。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/93/b5/93dec45b7af7951a2b6daeb01941b9b5.png?wh=1862*584\" alt=\"\" /></p>\n<p>我会在后面的文章中介绍方法内联的具体实现，这里先说个结论：在生产环境中，我们往往拥有多个不同的反射调用，对应多个GeneratedMethodAccessor，也就是动态实现。</p>\n<p>由于Java虚拟机的关于上述调用点的类型profile（注：对于invokevirtual或者invokeinterface，Java虚拟机会记录下调用者的具体类型，我们称之为类型profile）无法同时记录这么多个类，因此可能造成所测试的反射调用没有被内联的情况。</p>\n<pre><code>// v5版本\nimport java.lang.reflect.Method;\n\npublic class Test {\n  public static void target(int i) {\n    // 空方法\n  }\n\n  public static void main(String[] args) throws Exception {\n    Class&lt;?&gt; klass = Class.forName(&quot;Test&quot;);\n    Method method = klass.getMethod(&quot;target&quot;, int.class);\n    method.setAccessible(true);  // 关闭权限检查\n    polluteProfile();\n\n    long current = System.currentTimeMillis();\n    for (int i = 1; i &lt;= 2_000_000_000; i++) {\n      if (i % 100_000_000 == 0) {\n        long temp = System.currentTimeMillis();\n        System.out.println(temp - current);\n        current = temp;\n      }\n\n      method.invoke(null, 128);\n    }\n  }\n\n  public static void polluteProfile() throws Exception {\n    Method method1 = Test.class.getMethod(&quot;target1&quot;, int.class);\n    Method method2 = Test.class.getMethod(&quot;target2&quot;, int.class);\n    for (int i = 0; i &lt; 2000; i++) {\n      method1.invoke(null, 0);\n      method2.invoke(null, 0);\n    }\n  }\n  public static void target1(int i) { }\n  public static void target2(int i) { }\n}\n\n</code></pre>\n<p>在上面的v5版本中，我在测试循环之前调用了polluteProfile的方法。该方法将反射调用另外两个方法，并且循环上2000遍。</p>\n<p>而测试循环则保持不变。测得的结果约为基准的6.7倍。也就是说，只要误扰了Method.invoke方法的类型profile，性能开销便会从1.3倍上升至6.7倍。</p>\n<p>之所以这么慢，除了没有内联之外，另外一个原因是逃逸分析不再起效。这时候，我们便可以采用刚才v3版本中的解决方案，在循环外构造参数数组，并直接传递给反射调用。这样子测得的结果约为基准的5.2倍。</p>\n<p>除此之外，我们还可以提高Java虚拟机关于每个调用能够记录的类型数目（对应虚拟机参数-XX:TypeProfileWidth，默认值为2，这里设置为3）。最终测得的结果约为基准的2.8倍，尽管它和原本的1.3倍还有一定的差距，但总算是比6.7倍好多了。</p>\n<h2>总结与实践</h2>\n<p>今天我介绍了Java里的反射机制。</p>\n<p>在默认情况下，方法的反射调用为委派实现，委派给本地实现来进行方法调用。在调用超过15次之后，委派实现便会将委派对象切换至动态实现。这个动态实现的字节码是自动生成的，它将直接使用invoke指令来调用目标方法。</p>\n<p>方法的反射调用会带来不少性能开销，原因主要有三个：变长参数方法导致的Object数组，基本类型的自动装箱、拆箱，还有最重要的方法内联。</p>\n<p>今天的实践环节，你可以将最后一段代码中polluteProfile方法的两个Method对象，都改成获取名字为“target”的方法。请问这两个获得的Method对象是同一个吗（==）？他们equal吗（.equals(…)）？对我们的运行结果有什么影响？</p>\n<pre><code>import java.lang.reflect.Method;\n\npublic class Test {\n  public static void target(int i) {\n    // 空方法\n  }\n\n  public static void main(String[] args) throws Exception {\n    Class&lt;?&gt; klass = Class.forName(&quot;Test&quot;);\n    Method method = klass.getMethod(&quot;target&quot;, int.class);\n    method.setAccessible(true);  // 关闭权限检查\n    polluteProfile();\n\n    long current = System.currentTimeMillis();\n    for (int i = 1; i &lt;= 2_000_000_000; i++) {\n      if (i % 100_000_000 == 0) {\n        long temp = System.currentTimeMillis();\n        System.out.println(temp - current);\n        current = temp;\n      }\n\n      method.invoke(null, 128);\n    }\n  }\n\n  public static void polluteProfile() throws Exception {\n    Method method1 = Test.class.getMethod(&quot;target&quot;, int.class);\n    Method method2 = Test.class.getMethod(&quot;target&quot;, int.class);\n    for (int i = 0; i &lt; 2000; i++) {\n      method1.invoke(null, 0);\n      method2.invoke(null, 0);\n    }\n  }\n  public static void target1(int i) { }\n  public static void target2(int i) { }\n}\n</code></pre>\n<h2>附录：反射API简介</h2>\n<p>通常来说，使用反射API的第一步便是获取Class对象。在Java中常见的有这么三种。</p>\n<ol>\n<li>使用静态方法Class.forName来获取。</li>\n<li>调用对象的getClass()方法。</li>\n<li>直接用类名+“.class”访问。对于基本类型来说，它们的包装类型（wrapper classes）拥有一个名为“TYPE”的final静态字段，指向该基本类型对应的Class对象。</li>\n</ol>\n<p>例如，Integer.TYPE指向int.class。对于数组类型来说，可以使用类名+“[ ].class”来访问，如int[ ].class。</p>\n<p>除此之外，Class类和java.lang.reflect包中还提供了许多返回Class对象的方法。例如，对于数组类的Class对象，调用Class.getComponentType()方法可以获得数组元素的类型。</p>\n<p>一旦得到了Class对象，我们便可以正式地使用反射功能了。下面我列举了较为常用的几项。</p>\n<ol>\n<li>\n<p>使用newInstance()来生成一个该类的实例。它要求该类中拥有一个无参数的构造器。</p>\n</li>\n<li>\n<p>使用isInstance(Object)来判断一个对象是否该类的实例，语法上等同于instanceof关键字（JIT优化时会有差别，我会在本专栏的第二部分详细介绍）。</p>\n</li>\n<li>\n<p>使用Array.newInstance(Class,int)来构造该类型的数组。</p>\n</li>\n<li>\n<p>使用getFields()/getConstructors()/getMethods()来访问该类的成员。除了这三个之外，Class类还提供了许多其他方法，详见[4]。需要注意的是，方法名中带Declared的不会返回父类的成员，但是会返回私有成员；而不带Declared的则相反。</p>\n</li>\n</ol>\n<p>当获得了类成员之后，我们可以进一步做如下操作。</p>\n<ul>\n<li>使用Constructor/Field/Method.setAccessible(true)来绕开Java语言的访问限制。</li>\n<li>使用Constructor.newInstance(Object[])来生成该类的实例。</li>\n<li>使用Field.get/set(Object)来访问字段的值。</li>\n<li>使用Method.invoke(Object, Object[])来调用方法。</li>\n</ul>\n<p>有关反射API的其他用法，可以参考reflect包的javadoc [5] ，这里就不详细展开了。</p>\n<p>[1] :  <a href=\"https://docs.oracle.com/javase/tutorial/reflect/\">https://docs.oracle.com/javase/tutorial/reflect/</a><br />\n[2]: <a href=\"http://hg.openjdk.java.net/jdk10/jdk10/jdk/file/777356696811/src/java.base/share/classes/jdk/internal/reflect/ReflectionFactory.java#l80\">http://hg.openjdk.java.net/jdk10/jdk10/jdk/file/777356696811/src/java.base/share/classes/jdk/internal/reflect/ReflectionFactory.java#l80</a><br />\n[3]: <a href=\"http://hg.openjdk.java.net/jdk10/jdk10/jdk/file/777356696811/src/java.base/share/classes/jdk/internal/reflect/ReflectionFactory.java#l78\">http://hg.openjdk.java.net/jdk10/jdk10/jdk/file/777356696811/src/java.base/share/classes/jdk/internal/reflect/ReflectionFactory.java#l78</a><br />\n[4]: <a href=\"https://docs.oracle.com/javase/tutorial/reflect/class/classMembers.html\">https://docs.oracle.com/javase/tutorial/reflect/class/classMembers.html</a><br />\n[5]: <a href=\"https://docs.oracle.com/javase/10/docs/api/java/lang/reflect/package-summary.html\">https://docs.oracle.com/javase/10/docs/api/java/lang/reflect/package-summary.html</a></p>\n<p></p>\n","comments":[{"had_liked":false,"id":18691,"user_name":"志远","can_delete":false,"product_type":"c1","uid":1108762,"ip_address":"","ucode":"11015D14034130","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/1a/579c941e.jpg","comment_is_top":false,"comment_ctime":1533552257,"is_pvip":false,"replies":[{"id":"6559","content":"谢谢建议！方法内联指的是编译器在编译一个方法时，将某个方法调用的目标方法也纳入编译范围内，并用其返回值替代原方法调用这么个过程。","user_name":"作者回复","comment_id":18691,"uid":"1176688","ip_address":"","utype":1,"ctime":1533569446,"user_name_real":"郑雨迪"}],"discussion_count":6,"race_medal":0,"score":"452505118337","product_id":100010301,"comment_content":"老师您好，提个建议，您讲课过程中经常提到一些概念名词，您讲课总是预设了一个前提，就是假设我们已经知道那个概念，然而并不清楚。比如本文中被不断提到的内联，什么是内联呢？","like_count":106,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421633,"discussion_content":"谢谢建议！方法内联指的是编译器在编译一个方法时，将某个方法调用的目标方法也纳入编译范围内，并用其返回值替代原方法调用这么个过程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533569446,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1974876,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJUCiacuh59wMZAeeNRwLiaGaRMZHibF05IibXeiaZfjcFfkmTwJTmPszibXLAQkk2mMdx8chPjTs2yvpZg/132","nickname":"Sky1225","note":"","ucode":"6F428AF396D99D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388336,"discussion_content":"这老师讲不明白","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1628700336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3046392,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/ugib9sF9icd9dhibQoAA025hibbD5zgZTiaddLoeEH457hrkBBhtQK6qknTWt270rHCtBZqeqsbibtHghgjdkPx3DyIw/132","nickname":"唐方刚","note":"","ucode":"93DA58C3DCCF1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586625,"discussion_content":"我也是各种听不懂，准备换教程了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662380775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1482438,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9e/c6/3e5aef4c.jpg","nickname":"shoo","note":"","ucode":"5C0D00A979C9C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583413,"discussion_content":"要一节课一节课地认真看明白，理解记住，因为有些概念下节课要用就不再重复讲了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660107517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"陕西"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1153893,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9b/65/9045dc77.jpg","nickname":"慕云","note":"","ucode":"E7D6D2CD58249E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580063,"discussion_content":"一个方法是一个栈帧对吧,  10个方法就要成10个栈帧, 内联就是把 其他9个方法的代码拷贝到一个方法内,  只用一个栈帧 , 优化开销损耗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657855778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1650748,"avatar":"https://static001.geekbang.org/account/avatar/00/19/30/3c/0668d6ae.jpg","nickname":"盘胧","note":"","ucode":"5386CC4C92ECC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281762,"discussion_content":"这个在计算机基本组成原理里有比较好的解释哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591801456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18622,"user_name":"xiaguangme","can_delete":false,"product_type":"c1","uid":1062704,"ip_address":"","ucode":"7FDEDEA06CAE4D","user_header":"https://static001.geekbang.org/account/avatar/00/10/37/30/bbf76b79.jpg","comment_is_top":false,"comment_ctime":1533514739,"is_pvip":false,"replies":[{"id":"6564","content":"谢谢指出！","user_name":"作者回复","comment_id":18622,"uid":"1176688","ip_address":"","utype":1,"ctime":1533570573,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"250641617907","product_id":100010301,"comment_content":"开发人员日常接触到的 Java 集成开发环境（IDE）便运用了这一功能：每当我们敲入点号时，IDE 便会根据点号前的内容，动态展示可以访问的字段或者方法。&#47;&#47;这个应该是不完全正确的，大部分应该是靠语法树来实现的。","like_count":59,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421600,"discussion_content":"谢谢指出！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533570573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20440,"user_name":"小明","can_delete":false,"product_type":"c1","uid":1013093,"ip_address":"","ucode":"31A24C60B4CC5B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/65/2a7f8212.jpg","comment_is_top":false,"comment_ctime":1534443992,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"104613659096","product_id":100010301,"comment_content":"可以看看这篇博客 有详细的生成动态调用的解释  <br>http:&#47;&#47;rednaxelafx.iteye.com&#47;blog&#47;548536","like_count":25,"discussions":[{"author":{"id":1263932,"avatar":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","nickname":"静静聆听","note":"","ucode":"0A8600CB928EFE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300129,"discussion_content":"这还没雨迪老师写的好","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597939238,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100387,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ca/63/9be9ac89.jpg","nickname":"Allen","note":"","ucode":"5B168A03809557","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408320,"discussion_content":"R大yyds啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635226607,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2454984,"avatar":"https://static001.geekbang.org/account/avatar/00/25/75/c8/054df785.jpg","nickname":"Add","note":"","ucode":"85969C292092DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357935,"discussion_content":"终于看懂了。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615898501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18901,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1533605000,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"104612820104","product_id":100010301,"comment_content":"小结<br>1:反射机制是Java语言的一个非常重要的特性，通过这个特性，我们能够动态的监控、调用、修改类的行为，许多的框架实现就用到了Java语言反射的机制<br><br>2:使用反射挺好的，但它也是不完美的，复杂的操作往往更耗时间和精力，使用反射也是一样，性能低下是她所被人诟病的一个地方，那为什么方法的反射如此耗费性能呐？它的性能耗在那里呢？方法的反射调用会带来不少性能开销，原因主要有三个：变长参数方法导致的 Object 数组，基本类型的自动装箱、拆箱，还有最重要的方法内联。","like_count":24,"discussions":[{"author":{"id":1940461,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/9b/ed/e633460a.jpg","nickname":"Geek_225244","note":"","ucode":"43A0711FFAB44A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585872,"discussion_content":"复读机一个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661859662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18787,"user_name":"ext4","can_delete":false,"product_type":"c1","uid":1180826,"ip_address":"","ucode":"FC881AECAC1974","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/9a/f2c0a206.jpg","comment_is_top":false,"comment_ctime":1533566472,"is_pvip":false,"replies":[{"id":"6566","content":"多谢建议，我也是mac+jdk10。我这边裸跑v2是2.7x(因为每次要新建整数对象所以有GC)，加大整数缓存后跑v2是1.8x(无GC)。你是否忘了加大整数缓存？<br><br>第二个问题，研究得很深！Method.invoke一直会被内联，但是它里面的MethodAccesor.invoke则不一定。<br><br>实际上，在C2编译之前循环代码已经运行过非常多次，也就是说MethodAccesor.invoke已经看到多次调用至target()的动态实现。在profile里会显示为有target1，有target2，但是profile不完整，即还有一大部分的调用者类型没有记录。<br><br>这时候C2会选择不inline这个MethodAccesor.invoke调用，直接做虚调用。","user_name":"作者回复","comment_id":18787,"uid":"1176688","ip_address":"","utype":1,"ctime":1533573324,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"104612781576","product_id":100010301,"comment_content":"雨迪您好，我有两个问题：<br><br>一是我自己的测试结果和文章中有些出入。在我自己的mac+jdk10环境中，v3版本的代码和v2版本性能是差不多的，多次测试看v3还略好一些。从v2的GC log来看for循环的每一亿次iteration中间都会有GC发生，似乎说明这里的escape analysis并没有做到allocation on stack。您能想到这是什么原因么？另有个小建议就是文章中提到测试结果时，注明一下您的环境。<br><br>另一个问题是在您v5版本的代码中，您故意用method1和method2两个对象霸占了2个ProfileType的位子，导致被测的反射操作性能很低。这是因为此处invoke方法的inline是压根儿就没有做呢？还是因为inline是依据target1或者target2来做的，而实际运行时发现类型不一致又触发了deoptimization呢？<br><br>望解答，谢谢~","like_count":25,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421649,"discussion_content":"多谢建议，我也是mac+jdk10。我这边裸跑v2是2.7x(因为每次要新建整数对象所以有GC)，加大整数缓存后跑v2是1.8x(无GC)。你是否忘了加大整数缓存？\n\n第二个问题，研究得很深！Method.invoke一直会被内联，但是它里面的MethodAccesor.invoke则不一定。\n\n实际上，在C2编译之前循环代码已经运行过非常多次，也就是说MethodAccesor.invoke已经看到多次调用至target()的动态实现。在profile里会显示为有target1，有target2，但是profile不完整，即还有一大部分的调用者类型没有记录。\n\n这时候C2会选择不inline这个MethodAccesor.invoke调用，直接做虚调用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533573324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145829,"user_name":"且听风吟","can_delete":false,"product_type":"c1","uid":1001951,"ip_address":"","ucode":"673F179AAEDBC4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/df/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1572393429,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"78881804757","product_id":100010301,"comment_content":"看到inflation这块还是比较有深刻感触的。一次线上环境发现metasapce周期性打爆导致full GC，后来根据dump分析到，由于引入了一些中间件的关系，很多实用代理反射的方式生成了很多字节码，后来把inflation阈值调整到int.max就没问题了","like_count":19,"discussions":[{"author":{"id":2051293,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","nickname":"Bumblebee","note":"","ucode":"B879C8A511D08D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573292,"discussion_content":"🚩","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653313388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2852990,"avatar":"","nickname":"马文","note":"","ucode":"89CD0D9403AAB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571176,"discussion_content":"mark\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652101699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1527429,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4e/85/ef0108cd.jpg","nickname":"כן אני אמריקאי","note":"","ucode":"56C5C2B369121B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546121,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642167393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1249789,"avatar":"https://static001.geekbang.org/account/avatar/00/13/11/fd/45e90d04.jpg","nickname":"Casin","note":"","ucode":"E495A97E2BF6C3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536976,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638926033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1963604,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/f6/54/bf649b32.jpg","nickname":"cccy七里十一","note":"","ucode":"38858D844ECC72","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378323,"discussion_content":"mmmmmark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623161789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1303322,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e3/1a/061e77b6.jpg","nickname":"亢星东","note":"","ucode":"5E4063E83B2BB9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336910,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608727783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1731543,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6b/d7/8872624a.jpg","nickname":"xmeng","note":"","ucode":"C0CA2182BA3B4B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300663,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598229333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279292,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591320592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18624,"user_name":"夜空","can_delete":false,"product_type":"c1","uid":1180560,"ip_address":"","ucode":"5D9D4D18D3CF1C","user_header":"https://static001.geekbang.org/account/avatar/00/12/03/90/2312c3fb.jpg","comment_is_top":false,"comment_ctime":1533515247,"is_pvip":false,"replies":[{"id":"6563","content":"动态生成发生在第15次(从0开始数的话)，所以第15次比较耗时。","user_name":"作者回复","comment_id":18624,"uid":"1176688","ip_address":"","utype":1,"ctime":1533570511,"user_name_real":"郑雨迪"}],"discussion_count":3,"race_medal":0,"score":"65958024687","product_id":100010301,"comment_content":"当某个反射调用的调用次数在 15 之下时，采用本地实现；当达到 15 时，便开始动态生成字节码...<br>———可以认为第16次反射调用时的耗时是最长的吗？","like_count":15,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421602,"discussion_content":"动态生成发生在第15次(从0开始数的话)，所以第15次比较耗时。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533570511,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1159221,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b0/35/44e5516e.jpg","nickname":"阳阳","note":"","ucode":"BD7404A3AE79E4","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532791,"discussion_content":"#15生成 #16切换","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637687684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1665700,"avatar":"https://static001.geekbang.org/account/avatar/00/19/6a/a4/59883422.jpg","nickname":"杨","note":"","ucode":"9BB0FEE5F7D55F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":354366,"discussion_content":"但是从打印栈信息来看，#15还是用的本地实现啊，从#16开始才是动态实现吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615281015,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36519,"user_name":"星文友","can_delete":false,"product_type":"c1","uid":1068162,"ip_address":"","ucode":"EE438B9C1C7B61","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK9RytLsauRVYGjupDIaibibAK5iaicEicONrMFc0O3icAGf5mD1buxoQ2ePPn9YurFhRbuf3AR1qJDy0GQ/132","comment_is_top":false,"comment_ctime":1541140403,"is_pvip":false,"replies":[{"id":"13218","content":"这说明你和JVM架构师想一块去了 ;)","user_name":"作者回复","comment_id":36519,"uid":"1176688","ip_address":"","utype":1,"ctime":1541428349,"user_name_real":"郑雨迪"}],"discussion_count":3,"race_medal":0,"score":"61670682547","product_id":100010301,"comment_content":"给大家讲个笑话：<br>我负责的项目中有大量动态生成的类，这些类实例的调用原本都是通过反射去完成，后来我觉得反射效率低，就为每个动态类的每个方法在动态生成一个代理类，这个代理类就是进行类型强转然后直接调用。后来在压测环境进行测试，发现并无卵用，早点开到这篇文章我就不用做这么多无用功了。特么的JVM已经有这个功能了啊","like_count":14,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427898,"discussion_content":"这说明你和JVM架构师想一块去了 ;)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541428349,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1215066,"avatar":"https://static001.geekbang.org/account/avatar/00/12/8a/5a/b67a82e3.jpg","nickname":"shen","note":"","ucode":"AE5737B0C7DC4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346857,"discussion_content":"按理来讲你这种方式是可以提高性能啊，比如dubbo中javassist动态代理类","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612085771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1112210,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f8/92/eaafff96.jpg","nickname":"Amos","note":"","ucode":"61DB72D99AF9EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340612,"discussion_content":"老师这回复，高情商的表现啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610077953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18660,"user_name":"Kisho","can_delete":false,"product_type":"c1","uid":1179157,"ip_address":"","ucode":"1293DF934FD4D4","user_header":"https://static001.geekbang.org/account/avatar/00/11/fe/15/ccda05bb.jpg","comment_is_top":false,"comment_ctime":1533531486,"is_pvip":false,"replies":[{"id":"6561","content":"在v0版本中我贴了一段stacktrace，你可以看到中间有个native method，这就是C++代码，也就是它先调用至这个C++代码，在C++代码里面再调用至Java代码。","user_name":"作者回复","comment_id":18660,"uid":"1176688","ip_address":"","utype":1,"ctime":1533570112,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"53073139038","product_id":100010301,"comment_content":"郑老师，你好,<br>       “动态实现无需经过Java到C++再到Java的切换”,这句话没太明白，能在解释下么？","like_count":12,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421617,"discussion_content":"在v0版本中我贴了一段stacktrace，你可以看到中间有个native method，这就是C++代码，也就是它先调用至这个C++代码，在C++代码里面再调用至Java代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533570112,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36641,"user_name":"Stephen","can_delete":false,"product_type":"c1","uid":1208572,"ip_address":"","ucode":"CB08E34AB48D99","user_header":"https://static001.geekbang.org/account/avatar/00/12/70/fc/77f60338.jpg","comment_is_top":false,"comment_ctime":1541212384,"is_pvip":false,"replies":[{"id":"13344","content":"内联和逃逸分析后面有两篇会专门介绍，反射的inflation机制是当反射被频繁调用时，动态生成一个类来做直接调用的机制，可以加速反射调用","user_name":"作者回复","comment_id":36641,"uid":"1176688","ip_address":"","utype":1,"ctime":1541498387,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"48785852640","product_id":100010301,"comment_content":"老师，有三个知识点不太明白，分别是:内联、逃逸分析以及inflation机制","like_count":11,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427951,"discussion_content":"内联和逃逸分析后面有两篇会专门介绍，反射的inflation机制是当反射被频繁调用时，动态生成一个类来做直接调用的机制，可以加速反射调用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541498387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":23480,"user_name":"搬砖匠","can_delete":false,"product_type":"c1","uid":1214120,"ip_address":"","ucode":"3D2D7C1FD14DB6","user_header":"https://static001.geekbang.org/account/avatar/00/12/86/a8/427879a9.jpg","comment_is_top":false,"comment_ctime":1536405074,"is_pvip":false,"replies":[{"id":"8605","content":"之所以叫本地实现，就是因为它用的C++代码。如果用Java来实现，就不会这么叫啦 :)<br><br>JVM有用Java来替代的实现方式，也就是文中介绍的动态实现。它是根据反射调用的目标方法来动态生成字节码的。","user_name":"作者回复","comment_id":23480,"uid":"1176688","ip_address":"","utype":1,"ctime":1536578958,"user_name_real":"郑雨迪"}],"discussion_count":2,"race_medal":0,"score":"48781045330","product_id":100010301,"comment_content":"请教一个问题，本地实现可以用java来替代c++的实现方式吗？这样就可以避过C++的额外开销？","like_count":12,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423581,"discussion_content":"之所以叫本地实现，就是因为它用的C++代码。如果用Java来实现，就不会这么叫啦 :)\n\nJVM有用Java来替代的实现方式，也就是文中介绍的动态实现。它是根据反射调用的目标方法来动态生成字节码的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1536578958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1048314,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fe/fa/2a046821.jpg","nickname":"人间四月天","note":"","ucode":"11BE219C23EEBC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":583818,"discussion_content":"本地实现的代码是怎么生成的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660403062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":423581,"ip_address":"上海"},"score":583818,"extra":""}]}]},{"had_liked":false,"id":23349,"user_name":"once","can_delete":false,"product_type":"c1","uid":1170533,"ip_address":"","ucode":"7026094E0B99BF","user_header":"https://static001.geekbang.org/account/avatar/00/11/dc/65/3da02c30.jpg","comment_is_top":false,"comment_ctime":1536294249,"is_pvip":true,"replies":[{"id":"8472","content":"需要经过JNI，所以性能很不好。<br><br>不过即时编译器可能会将某些指定的本地方法调用给替换掉。这些特定的本地方法叫intrinsics，下周一会讲。","user_name":"作者回复","comment_id":23349,"uid":"1176688","ip_address":"","utype":1,"ctime":1536331586,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"40190999913","product_id":100010301,"comment_content":"请问老师 是不是本地方法的性能一般都不是很好呢","like_count":9,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423526,"discussion_content":"需要经过JNI，所以性能很不好。\n\n不过即时编译器可能会将某些指定的本地方法调用给替换掉。这些特定的本地方法叫intrinsics，下周一会讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1536331586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":38160,"user_name":"小鳄鱼","can_delete":false,"product_type":"c1","uid":1178888,"ip_address":"","ucode":"9C30CAFB41A263","user_header":"https://static001.geekbang.org/account/avatar/00/11/fd/08/c039f840.jpg","comment_is_top":false,"comment_ctime":1541981517,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35901719885","product_id":100010301,"comment_content":"不是同个对象，但equal。老师说了，返回的是目标方法的一份拷贝","like_count":8},{"had_liked":false,"id":36643,"user_name":"Stephen","can_delete":false,"product_type":"c1","uid":1208572,"ip_address":"","ucode":"CB08E34AB48D99","user_header":"https://static001.geekbang.org/account/avatar/00/12/70/fc/77f60338.jpg","comment_is_top":false,"comment_ctime":1541212490,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"31605983562","product_id":100010301,"comment_content":"老师，有三个知识点不太明白:内联、逃逸分析以及inflation机制","like_count":7,"discussions":[{"author":{"id":1158422,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/5fibB9p7PfndN4kU0lhHv4TyKRsibISvaxGdI4yviao0WcDS7rmEP9vqiaMiclxrs2GQJlRcCyZxTkRibK5r4uWQQBhg/132","nickname":"wengyifa","note":"","ucode":"C41E3894694D2B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2432,"discussion_content":"看书不认真，内联在第5节有讲，inflation这一节老师就有说明。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563610668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1460942,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4a/ce/affe4307.jpg","nickname":"叫啥不行","note":"","ucode":"A84B9B6594BF35","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1158422,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/5fibB9p7PfndN4kU0lhHv4TyKRsibISvaxGdI4yviao0WcDS7rmEP9vqiaMiclxrs2GQJlRcCyZxTkRibK5r4uWQQBhg/132","nickname":"wengyifa","note":"","ucode":"C41E3894694D2B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275621,"discussion_content":"你确定你认真了么，那俩内联是一个东西？？？？？？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590741389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2432,"ip_address":""},"score":275621,"extra":""}]}]},{"had_liked":false,"id":20169,"user_name":"Scott","can_delete":false,"product_type":"c1","uid":1014800,"ip_address":"","ucode":"7E57FDCB5E5D49","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7c/10/165cb374.jpg","comment_is_top":false,"comment_ctime":1534296677,"is_pvip":false,"replies":[{"id":"7064","content":"1. 读数组被替换为之前写入数组的值。后面数组就只有写没有读了，因此可以优化掉。<br>2. 只要没有完全内联，就会将看似不逃逸的对象通过参数传递出去。即时编译器不知道所调用的方法对该对象有没有副作用，所以会将其判定为逃逸。<br>(如果你问的是不能分配到栈上，那我只能回答Java虚拟机从设计上不支持栈分配。它要不是堆分配，要不是虚拟分配+标量替换)","user_name":"作者回复","comment_id":20169,"uid":"1176688","ip_address":"","utype":1,"ctime":1534324770,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"31599067749","product_id":100010301,"comment_content":"有两个问题：<br>1.v3版本中，确定不逃逸的数组可以优化访问，这个是怎么做的？<br>2.v5版本中，为啥逃逸分析会失效，明明都封闭在循环里的？","like_count":7,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422138,"discussion_content":"1. 读数组被替换为之前写入数组的值。后面数组就只有写没有读了，因此可以优化掉。\n2. 只要没有完全内联，就会将看似不逃逸的对象通过参数传递出去。即时编译器不知道所调用的方法对该对象有没有副作用，所以会将其判定为逃逸。\n(如果你问的是不能分配到栈上，那我只能回答Java虚拟机从设计上不支持栈分配。它要不是堆分配，要不是虚拟分配+标量替换)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534324770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18687,"user_name":"志远","can_delete":false,"product_type":"c1","uid":1108762,"ip_address":"","ucode":"11015D14034130","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/1a/579c941e.jpg","comment_is_top":false,"comment_ctime":1533551082,"is_pvip":false,"replies":[{"id":"6560","content":"多谢指出！不调用就是字面意思，不做任何调用，也就是除了每一亿次调用的打印语句之外，循环就不包含其它东西了。","user_name":"作者回复","comment_id":18687,"uid":"1176688","ip_address":"","utype":1,"ctime":1533569565,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"27303354858","product_id":100010301,"comment_content":"文章中“一亿次直接调用耗费的时间大约在 120ms。这和不调用的时间是一致的。”这句话是不是病句啊？不调用指的是什么？指的是直接调用吗？","like_count":6,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421631,"discussion_content":"多谢指出！不调用就是字面意思，不做任何调用，也就是除了每一亿次调用的打印语句之外，循环就不包含其它东西了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533569565,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18625,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1533515306,"is_pvip":false,"replies":[{"id":"6565","content":"你可以搜一下class redefinition的相关资料。我以前用cagent做过，Javaagent应该也可以。","user_name":"作者回复","comment_id":18625,"uid":"1176688","ip_address":"","utype":1,"ctime":1533570928,"user_name_real":"郑雨迪"}],"discussion_count":2,"race_medal":0,"score":"23008351786","product_id":100010301,"comment_content":"老师请教个问题，如果手动修改某个Java字节码文件，如果JVM不重新加载此文件，有什么方式能让JVM识别并执行修改的内容呢？<br>如果一定需要JVM加载后才能识别并执行，有什么好的手动触发的方法呢？","like_count":5,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421603,"discussion_content":"你可以搜一下class redefinition的相关资料。我以前用cagent做过，Javaagent应该也可以。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533570928,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1672163,"avatar":"https://static001.geekbang.org/account/avatar/00/19/83/e3/45492c01.jpg","nickname":"皮皮强","note":"","ucode":"B0FF09E76C91BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570232,"discussion_content":"jdk搜索instrument","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651713620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":38599,"user_name":"Yoph","can_delete":false,"product_type":"c1","uid":1050702,"ip_address":"","ucode":"48E676BA29EC3D","user_header":"https://static001.geekbang.org/account/avatar/00/10/08/4e/87e40222.jpg","comment_is_top":false,"comment_ctime":1542080796,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18721949980","product_id":100010301,"comment_content":"MethodAccessor实例创建在ReflectionFactory中，如下代码：<br>public class ReflectionFactory {  <br>    private static boolean noInflation        = false;  <br>    private static int     inflationThreshold = 15;  <br>   <br>    public MethodAccessor newMethodAccessor(Method method) {  <br>        checkInitted();  <br>        if (noInflation) {  <br>            return new MethodAccessorGenerator().  <br>                generateMethod(method.getDeclaringClass(),  <br>                               method.getName(),  <br>                               method.getParameterTypes(),  <br>                               method.getReturnType(),  <br>                               method.getExceptionTypes(),  <br>                               method.getModifiers());  <br>        } else {  <br>            NativeMethodAccessorImpl acc =  <br>                new NativeMethodAccessorImpl(method);  <br>            DelegatingMethodAccessorImpl res =  <br>                new DelegatingMethodAccessorImpl(acc);  <br>            acc.setParent(res);  <br>            return res;  <br>        }  <br>    }  <br>}  <br><br>实际的MethodAccessor实现有两个版本，一个是Java实现的，另一个是native code实现的。","like_count":4,"discussions":[{"author":{"id":2037530,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/17/1a/501544af.jpg","nickname":"Jackz","note":"","ucode":"40665959DC6DF4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303090,"discussion_content":"动态实现，本地实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599137908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20001,"user_name":"姬野用菜刀","can_delete":false,"product_type":"c1","uid":1062188,"ip_address":"","ucode":"613CC95A16B8E4","user_header":"https://static001.geekbang.org/account/avatar/00/10/35/2c/429323f3.jpg","comment_is_top":false,"comment_ctime":1534208344,"is_pvip":false,"replies":[{"id":"7061","content":"你可以进JRE代码看一下。相当于获取了一个Method数组，又将这个数组所有的内容都复制一份给你。","user_name":"作者回复","comment_id":20001,"uid":"1176688","ip_address":"","utype":1,"ctime":1534322852,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"14419110232","product_id":100010301,"comment_content":"因此，我们应当避免在热点代码中使用返回 Method 数组的 getMethods 或者 getDeclaredMethods 方法，以减少不必要的堆空间消耗。<br><br>这个地方没有太明白，老师能帮忙在细讲一下嘛？","like_count":3,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422056,"discussion_content":"你可以进JRE代码看一下。相当于获取了一个Method数组，又将这个数组所有的内容都复制一份给你。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534322852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":19395,"user_name":"阿康","can_delete":false,"product_type":"c1","uid":1146671,"ip_address":"","ucode":"C68B5274D956A1","user_header":"https://static001.geekbang.org/account/avatar/00/11/7f/2f/b4a925bd.jpg","comment_is_top":false,"comment_ctime":1533805979,"is_pvip":false,"replies":[{"id":"6780","content":"一般新的JDK代码都使用ASM来生成了。反射代码比较旧，我记得是自己构造byte数组的，非常难维护。","user_name":"作者回复","comment_id":19395,"uid":"1176688","ip_address":"","utype":1,"ctime":1533894654,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"14418707867","product_id":100010301,"comment_content":"请问，反射第16次生成字节码的用的什么方式阿？和asm有什么区别呢？","like_count":3,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421821,"discussion_content":"一般新的JDK代码都使用ASM来生成了。反射代码比较旧，我记得是自己构造byte数组的，非常难维护。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533894654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39417,"user_name":"溯雪","can_delete":false,"product_type":"c1","uid":1174371,"ip_address":"","ucode":"E819E5454BF216","user_header":"https://static001.geekbang.org/account/avatar/00/11/eb/63/09e7f442.jpg","comment_is_top":false,"comment_ctime":1542271416,"is_pvip":false,"replies":[{"id":"14597","content":"varargs方法的调用会新建一个数组，通过这些重载方法，至少在调用Set.of API的地方不会新建数组。至于这些API的实现，嗯。。<br><br>从即时编译器的观点来看的话，在Set.of内部新建数组(当前JDK做法)更容易被逃逸分析识别，从而优化掉。在Set.of调用处新建数组(即删除其他重载方法只留varargs)，逃逸分析还需依赖于Set.of的内联和SetN构造器的内联。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1542625800,"ip_address":"","comment_id":39417,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10132206008","product_id":100010301,"comment_content":"啊，不知道这么久了，老师还会不会回复<br><br>说起变长数组，我发现jdk9新增的Set.of方法重载了许多:<br><br>```<br>static &lt;E&gt; Set&lt;E&gt; of(E e1) {<br>        return new ImmutableCollections.Set12&lt;&gt;(e1);<br>    }<br>static &lt;E&gt; Set&lt;E&gt; of(E e1, E e2) {<br>        return new ImmutableCollections.Set12&lt;&gt;(e1, e2);<br>    }<br>   static &lt;E&gt; Set&lt;E&gt; of(E e1, E e2, E e3) {<br>        return new ImmutableCollections.SetN&lt;&gt;(e1, e2, e3);<br>    }<br><br>&#47;&#47;&#47;&#47;&#47;一直到10个参数<br>    static &lt;E&gt; Set&lt;E&gt; of(E... elements) {<br>        switch (elements.length) { &#47;&#47; implicit null check of elements<br>            case 0:<br>                return ImmutableCollections.emptySet();<br>            case 1:<br>                return new ImmutableCollections.Set12&lt;&gt;(elements[0]);<br>            case 2:<br>                return new ImmutableCollections.Set12&lt;&gt;(elements[0], elements[1]);<br>            default:<br>                return new ImmutableCollections.SetN&lt;&gt;(elements);<br>        }<br>    }<br>```<br>然而ImmutableCollections.SetN又是个变长数组，那么重载的1~10个参数方法是图个啥。。","like_count":2,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429058,"discussion_content":"varargs方法的调用会新建一个数组，通过这些重载方法，至少在调用Set.of API的地方不会新建数组。至于这些API的实现，嗯。。\n\n从即时编译器的观点来看的话，在Set.of内部新建数组(当前JDK做法)更容易被逃逸分析识别，从而优化掉。在Set.of调用处新建数组(即删除其他重载方法只留varargs)，逃逸分析还需依赖于Set.of的内联和SetN构造器的内联。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542625800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30329,"user_name":"life is short, enjoy more.","can_delete":false,"product_type":"c1","uid":1074805,"ip_address":"","ucode":"3B5F37D30790A7","user_header":"https://static001.geekbang.org/account/avatar/00/10/66/75/54bb858e.jpg","comment_is_top":false,"comment_ctime":1538794722,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10128729314","product_id":100010301,"comment_content":"总结一下<br>反射有两种实现方式：<br><br>本地方法调用（就是字节码中已经定义好的方法）<br><br>动态生成字节码<br><br><br>两者有什么区别？<br><br>动态生成字节码（以下简称动态实现），生成字节码的过程很慢（类似于准备工作），但是执行效率高。<br><br>本地方法调用，不用生成字节码，直接调用本地方法。所以准备工作几乎没有，很快。但是执行效率就差很多。<br><br><br>JVM如何做决定选择哪种实现方式？<br><br>通过反射执行的次数来决定，默认值是15。15次之前直接本地调用，之后动态实现。<br><br><br>JVM为啥分两种实现方式？<br><br>本地实现的调用流程复杂。而在执行多次的情况下，复杂意味着性能损耗，所以有一种适合多次执行的解决方案，就是动态生成字节码。<br><br>","like_count":2},{"had_liked":false,"id":18674,"user_name":"Ennis LM","can_delete":false,"product_type":"c1","uid":1188522,"ip_address":"","ucode":"8AA2004DB0DDE4","user_header":"https://static001.geekbang.org/account/avatar/00/12/22/aa/c7725dd8.jpg","comment_is_top":false,"comment_ctime":1533543132,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10123477724","product_id":100010301,"comment_content":"最后的问题，==是false，equals是true，对性能的影响我不知道怎么看。。。","like_count":2},{"had_liked":false,"id":18628,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1533516195,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10123450787","product_id":100010301,"comment_content":"JVM加载了一个Java字节码文件，在不停止JVM的情况下能再次的加载同一个Java字节码文件吗？如果能是覆盖了原来的那个Java字节码文件还是怎么着了呢？<br>在IDE中是可以直接修改Java源代码的，然后可以手动触发Java源代码的编译和重新加载，请问老师知道IDE是怎么实现的吗？","like_count":2,"discussions":[{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41944,"discussion_content":"2、就是通过 javac 这样的指令吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572537050,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216269,"user_name":"长脖子树","can_delete":false,"product_type":"c1","uid":1182802,"ip_address":"","ucode":"D9090EF67EEB1B","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/52/f25c3636.jpg","comment_is_top":false,"comment_ctime":1589212278,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5884179574","product_id":100010301,"comment_content":"为什么不用 native 方法, 而使用java代码实现? <br>跨越native边界会对优化有阻碍作用，它就像个黑箱一样让虚拟机难以分析也将其内联，于是运行时间长了之后反而是托管版本的代码更快些。<br>参考: R大博客 http:&#47;&#47;rednaxelafx.iteye.com&#47;blog&#47;548536<br>","like_count":1},{"had_liked":false,"id":156442,"user_name":"巴西","can_delete":false,"product_type":"c1","uid":1119116,"ip_address":"","ucode":"6E68AA02011541","user_header":"https://static001.geekbang.org/account/avatar/00/11/13/8c/c86340ca.jpg","comment_is_top":false,"comment_ctime":1574871952,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869839248","product_id":100010301,"comment_content":"有点难啊","like_count":1},{"had_liked":false,"id":146563,"user_name":"长脖子树","can_delete":false,"product_type":"c1","uid":1182802,"ip_address":"","ucode":"D9090EF67EEB1B","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/52/f25c3636.jpg","comment_is_top":false,"comment_ctime":1572574022,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5867541318","product_id":100010301,"comment_content":"经过 polluteProfile 之后的代码<br>在参数 -XX:TypeProfileWidth=3 -Dsun.reflect.noInflation=true 条件下<br>jdk 1.8.0_212-release 上最后5次平均 732ms<br>openjdk11 (build 11+28) 上最后5次平均 269ms <br>差距还是很大的, 大家记得认准版本号啊<br>","like_count":1},{"had_liked":false,"id":146284,"user_name":"长脖子树","can_delete":false,"product_type":"c1","uid":1182802,"ip_address":"","ucode":"D9090EF67EEB1B","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/52/f25c3636.jpg","comment_is_top":false,"comment_ctime":1572489441,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"5867456737","product_id":100010301,"comment_content":"这篇文章真的是专业=.= 第二遍读收获很大哈哈","like_count":1,"discussions":[{"author":{"id":1182802,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0c/52/f25c3636.jpg","nickname":"长脖子树","note":"","ucode":"D9090EF67EEB1B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263518,"discussion_content":"第三遍读, 发现前面学的又忘光了 哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589209914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2609845,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJzcULpxDJ8Qp9HCgYW5e8kRRicLZic2jRy2s17kGdRqvp5DbeBf7uBGmczatKy0qUmJ7vUl3NiaOw7w/132","nickname":"Geek_ace6c6","note":"","ucode":"007DF268832C39","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1182802,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0c/52/f25c3636.jpg","nickname":"长脖子树","note":"","ucode":"D9090EF67EEB1B","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":390449,"discussion_content":"您是来搞笑的呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629852497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":263518,"ip_address":""},"score":390449,"extra":""}]}]},{"had_liked":false,"id":87645,"user_name":"王盛武","can_delete":false,"product_type":"c1","uid":1182516,"ip_address":"","ucode":"DE7EF246D3DCE8","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/34/f41d73a4.jpg","comment_is_top":false,"comment_ctime":1555647957,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5850615253","product_id":100010301,"comment_content":"&quot;无法同时记录这么多个类&quot;，老师好，<br>这个问题我看了第5、7课，还是不大理解这个profile是什么意思；<br>是虚拟机里每一个类&#47;接口都默认有2个profile记住？    <br>还是虚拟机全局只记录任意一个类&#47;接口，总共才2个profile？<br><br>假设是是虚拟机里每一个类&#47;接口都默认有2个profile记住，<br>如果一个类只有1个实现类，这个实现类有4个虚方法，那虚拟机如何决定只内联缓存哪2个方法？先调用先缓存？还是最后调用的缓存？","like_count":1},{"had_liked":false,"id":55858,"user_name":"尔东","can_delete":false,"product_type":"c1","uid":1360829,"ip_address":"","ucode":"C0983536C63E2A","user_header":"https://static001.geekbang.org/account/avatar/00/14/c3/bd/ec8b3044.jpg","comment_is_top":false,"comment_ctime":1546330272,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5841297568","product_id":100010301,"comment_content":"两个method的对象是一样的，对结果没有影响","like_count":1,"discussions":[{"author":{"id":1361159,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqJobg767PUeqrqQQ4B6YvMatj2SRyOicKZZ4gWTf30dMketiaj58Gc3RFTmckGxAXlL9ERSxGovq9g/132","nickname":"涛哥哥","note":"","ucode":"329A1384E3AB5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369216,"discussion_content":"1、使用 == 比较是false，因为比较的是内存地址。klass.getMethod() 方法获取的是 原method对象的拷贝，所以两次都是拷贝过来的，都是新对象，所以肯定是false；\n2、使用 equals 比较是true，因为Method 类重写Object 类的equals方法，是同一个类，所以是true。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1618976686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20989,"user_name":"o","can_delete":false,"product_type":"c1","uid":1104326,"ip_address":"","ucode":"4028A59700647A","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/c6/a295275b.jpg","comment_is_top":false,"comment_ctime":1534854650,"is_pvip":false,"replies":[{"id":"7428","content":"可以看sun.reflect.NativeMethodAccessorImpl，它是作为该类实例的一个字段来存储的。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534931895,"ip_address":"","comment_id":20989,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5829821946","product_id":100010301,"comment_content":"请问，这个15次，他是怎么记录的呢？是否仍然占用jvm的内存，如果占用是属于那个区域呢？麻烦您可以给讲讲吗？谢谢","like_count":1,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422484,"discussion_content":"可以看sun.reflect.NativeMethodAccessorImpl，它是作为该类实例的一个字段来存储的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534931895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1155062,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9f/f6/7431e82e.jpg","nickname":"xueerfei007","note":"","ucode":"EF3FE821E5B54A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71911,"discussion_content":"应该是在sun.reflect.ReflectionFactory 这个类中，有个字段叫做private static int inflationThreshold = 15; 这个定义了为啥是15次","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575464821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20557,"user_name":"沉淀的梦想","can_delete":false,"product_type":"c1","uid":1177315,"ip_address":"","ucode":"BCB7C26F9D214B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg","comment_is_top":false,"comment_ctime":1534524763,"is_pvip":false,"replies":[{"id":"7440","content":"可以再增大到8试试。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534933446,"ip_address":"","comment_id":20557,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5829492059","product_id":100010301,"comment_content":"在v5版本中，为什么我设置TypeProfileWidth为3，速度并没有变快呢？","like_count":1,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422300,"discussion_content":"可以再增大到8试试。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534933446,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18652,"user_name":"一个坏人","can_delete":false,"product_type":"c1","uid":1032305,"ip_address":"","ucode":"4AF05BF008095A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c0/71/c83d8b15.jpg","comment_is_top":false,"comment_ctime":1533524480,"is_pvip":true,"replies":[{"id":"6562","content":"首先这个数字是可调配的。<br>其次，是在第15次(从0开始数的话)动态生成的，也就是说第15次比较耗时。<br>最后，如果只调用16次，确实不划算。这是因为虚拟机猜测以后还会大量执行该反射调用，所以才动态生成字节码的。如果生成后不用，那生成字节码的时间就浪费了。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1533570455,"ip_address":"","comment_id":18652,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5828491776","product_id":100010301,"comment_content":"老师好，请教一个问题。当某个反射调用的调用次数在 15 之下时，采用本地实现；当达到 15 时，便开始动态生成字节码...<br>———可以认为第16次反射调用时的耗时是最长的吗？如果刚好只调用16次是不是就不划算了？","like_count":1,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421612,"discussion_content":"首先这个数字是可调配的。\n其次，是在第15次(从0开始数的话)动态生成的，也就是说第15次比较耗时。\n最后，如果只调用16次，确实不划算。这是因为虚拟机猜测以后还会大量执行该反射调用，所以才动态生成字节码的。如果生成后不用，那生成字节码的时间就浪费了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533570455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":353766,"user_name":"| ~浑蛋~","can_delete":false,"product_type":"c1","uid":3024820,"ip_address":"广东","ucode":"B6904B44DFA805","user_header":"https://static001.geekbang.org/account/avatar/00/2e/27/b4/df65c0f7.jpg","comment_is_top":false,"comment_ctime":1659760548,"is_pvip":true,"discussion_count":0,"race_medal":3,"score":"1659760548","product_id":100010301,"comment_content":"那springmvc的每次请求都反射调用controller方法，岂不是有很大改进空间？","like_count":0},{"had_liked":false,"id":339938,"user_name":"Geek_56d8e2","can_delete":false,"product_type":"c1","uid":1184778,"ip_address":"","ucode":"D44E94FF5BFD9F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/hHAggykOyjScVG9qqSsdVaShDZoK6awO1uZYb3b75UA5QocVPMe3AT3AP3RDamtU7k8nekvc67DUzLRFDMTUQQ/132","comment_is_top":false,"comment_ctime":1648472146,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648472146","product_id":100010301,"comment_content":"在V3 版本 中 这句话:   如果在循环外新建数组，即时编译器无法确定这个数组会不会中途被更改，因此无法优化掉访问数组的操作，可谓是得不偿失 不太明白? <br>   是方法内联 导致 原来的读数组 变为了写数组吗？ 老师可以这样理解不<br><br><br>","like_count":0},{"had_liked":false,"id":339269,"user_name":"כן אני אמריקאי","can_delete":false,"product_type":"c1","uid":1527429,"ip_address":"","ucode":"56C5C2B369121B","user_header":"https://static001.geekbang.org/account/avatar/00/17/4e/85/ef0108cd.jpg","comment_is_top":false,"comment_ctime":1648018361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648018361","product_id":100010301,"comment_content":"自己从源码层面分析了一波Java反射，欢迎大家阅读：https:&#47;&#47;juejin.cn&#47;post&#47;7071957840683876365","like_count":0},{"had_liked":false,"id":337492,"user_name":"David","can_delete":false,"product_type":"c1","uid":1021825,"ip_address":"","ucode":"22CBBC13FC97A9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/97/81/e1eaf621.jpg","comment_is_top":false,"comment_ctime":1646851686,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646851686","product_id":100010301,"comment_content":"TypeProfileWidth jdk8这个参数为什么调整了没用呢","like_count":0},{"had_liked":false,"id":325142,"user_name":"Geek_5eca72","can_delete":false,"product_type":"c1","uid":2861167,"ip_address":"","ucode":"77016C587C7E19","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/QrAfzjy5NbAGeptpDAiaQqgfLnlW7JADawOBKJjojvTB1yicl1fIUwgAO7JLiakYB4ZJOAXYXxlJlcuD0mYBYsq4g/132","comment_is_top":false,"comment_ctime":1638841716,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638841716","product_id":100010301,"comment_content":"为啥我在自己电脑上跑试验除了inflation其它根本没啥效果","like_count":0},{"had_liked":false,"id":325043,"user_name":"Geek_5eca72","can_delete":false,"product_type":"c1","uid":2861167,"ip_address":"","ucode":"77016C587C7E19","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/QrAfzjy5NbAGeptpDAiaQqgfLnlW7JADawOBKJjojvTB1yicl1fIUwgAO7JLiakYB4ZJOAXYXxlJlcuD0mYBYsq4g/132","comment_is_top":false,"comment_ctime":1638785195,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638785195","product_id":100010301,"comment_content":"设置-Dsun.reflect.noInflation=true直接使用动态实现 节省的开销就只是前面15次的本地实现吗？<br>我的疑问是15次对比1亿次循环 会有那么明显的性能提升效果吗？","like_count":0},{"had_liked":false,"id":321741,"user_name":"沧海","can_delete":false,"product_type":"c1","uid":1285431,"ip_address":"","ucode":"8ED876B8DE5CEE","user_header":"https://static001.geekbang.org/account/avatar/00/13/9d/37/b2b73806.jpg","comment_is_top":false,"comment_ctime":1637029414,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637029414","product_id":100010301,"comment_content":"v2版本import少了个i","like_count":0},{"had_liked":false,"id":321277,"user_name":"寥若晨星","can_delete":false,"product_type":"c1","uid":1447739,"ip_address":"","ucode":"2E87E43687DE72","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eou1BMETumU21ZI4yiaLenOMSibzkAgkw944npIpsJRicmdicxlVQcgibyoQ00rdGk9Htp1j0dM5CP2Fibw/132","comment_is_top":false,"comment_ctime":1636732747,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636732747","product_id":100010301,"comment_content":"在执行20亿次的这段热点代码中，被内联的是invoke方法本身，还是invoke调用的目标方法（也就是target方法）","like_count":0},{"had_liked":false,"id":316926,"user_name":"","can_delete":false,"product_type":"c1","uid":1105991,"ip_address":"","ucode":"6AF6FCD4431814","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/47/66cb8ac9.jpg","comment_is_top":false,"comment_ctime":1634615312,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1634615312","product_id":100010301,"comment_content":"我有个疑问就是如果方法没有可变长参数，基本类型，方法无法内联，难道反射调用和直接掉赢得开销就会一样了吗？","like_count":0},{"had_liked":false,"id":308439,"user_name":"ppyh","can_delete":false,"product_type":"c1","uid":1351148,"ip_address":"","ucode":"14022ADEC9B53F","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/ec/235b74c0.jpg","comment_is_top":false,"comment_ctime":1629620669,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629620669","product_id":100010301,"comment_content":"跳过，看完内联、逃逸分析，对象分配再回来看","like_count":0},{"had_liked":false,"id":297211,"user_name":"🇨🇳","can_delete":false,"product_type":"c1","uid":2636003,"ip_address":"","ucode":"2E4E94710CFBC5","user_header":"https://static001.geekbang.org/account/avatar/00/28/38/e3/15402ae5.jpg","comment_is_top":false,"comment_ctime":1623378905,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623378905","product_id":100010301,"comment_content":"为什么我的电脑后五次平均是290ms, 我的电脑太太老了吗.","like_count":0},{"had_liked":false,"id":268052,"user_name":"飘雪撒哈拉","can_delete":false,"product_type":"c1","uid":1754332,"ip_address":"","ucode":"EF0C383B547A61","user_header":"https://static001.geekbang.org/account/avatar/00/1a/c4/dc/67e37b99.jpg","comment_is_top":false,"comment_ctime":1608040166,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608040166","product_id":100010301,"comment_content":"反射慢的原因之一：反射调用不采用方法调用的字节码指令，缺少方法解析&#47;分派环节。例如、getMethod()需要匹配元数据需要层层检查继承关系，才能找到目标方法。 （本来可以通过方法表直接引用）  非原创，但出处我也忘了，笔记里面的...","like_count":0},{"had_liked":false,"id":243609,"user_name":"xmeng","can_delete":false,"product_type":"c1","uid":1731543,"ip_address":"","ucode":"C0CA2182BA3B4B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/6b/d7/8872624a.jpg","comment_is_top":false,"comment_ctime":1598229938,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1598229938","product_id":100010301,"comment_content":"反射有两种实现方式：<br><br>本地方法调用（就是字节码中已经定义好的方法）<br><br>动态生成字节码<br><br><br>两者有什么区别？<br><br>动态生成字节码（以下简称动态实现），生成字节码的过程很慢（类似于准备工作），但是执行效率高。<br><br>本地方法调用，不用生成字节码，直接调用本地方法。所以准备工作几乎没有，很快。但是执行效率就差很多。<br><br><br>JVM如何做决定选择哪种实现方式？<br><br>通过反射执行的次数来决定，默认值是15。15次之前直接本地调用，之后动态实现。<br><br><br>JVM为啥分两种实现方式？<br><br>本地实现的调用流程复杂。而在执行多次的情况下，复杂意味着性能损耗，所以有一种适合多次执行的解决方案，就是动态生成字节码。<br>","like_count":0},{"had_liked":false,"id":243195,"user_name":"静静聆听","can_delete":false,"product_type":"c1","uid":1263932,"ip_address":"","ucode":"0A8600CB928EFE","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","comment_is_top":false,"comment_ctime":1597990438,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597990438","product_id":100010301,"comment_content":"老师，有个问题思考挺久还是不理解：-XX:TypeProfileWidth=3，这个参数，之前您第五章不是讲，java中的内联缓存不是单态内联缓存么，怎么在这里，又可以设置每个调用能够记录的类型数目，可否详细解答一下","like_count":0},{"had_liked":false,"id":229243,"user_name":"solaris","can_delete":false,"product_type":"c1","uid":1095403,"ip_address":"","ucode":"6EC9380F5F9980","user_header":"https://static001.geekbang.org/account/avatar/00/10/b6/eb/d10f01d5.jpg","comment_is_top":false,"comment_ctime":1592929131,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592929131","product_id":100010301,"comment_content":"老师，请问一下，这里的 MethodAccesor和实现动态代理的 MethodProxy 有什么关联和不同呢？性能有什么差别？理论上实现一个自己的MethodAccesor也能达到 MethodProxy 的效果？前提是都用 xxx.invoke 这种方式调","like_count":0},{"had_liked":false,"id":225348,"user_name":"宿臾洛城","can_delete":false,"product_type":"c1","uid":1564267,"ip_address":"","ucode":"362CC728E256F7","user_header":"https://static001.geekbang.org/account/avatar/00/17/de/6b/adee88bb.jpg","comment_is_top":false,"comment_ctime":1591720692,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591720692","product_id":100010301,"comment_content":"两个对象是相等的，因为文中提到getMethod方法是返回目标方法的一份拷贝，所以指向的地址都是相同的。<br>运行的效率在我本地是快了2.2倍左右，是因为即时编译导致了方法内联减少了开销么？","like_count":0},{"had_liked":false,"id":222298,"user_name":"叫啥不行","can_delete":false,"product_type":"c1","uid":1460942,"ip_address":"","ucode":"A84B9B6594BF35","user_header":"https://static001.geekbang.org/account/avatar/00/16/4a/ce/affe4307.jpg","comment_is_top":false,"comment_ctime":1590740740,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590740740","product_id":100010301,"comment_content":"1、如果只把缓存扩大到128后，不会GC，但是更慢了。如果取消委派实现后，再增大缓存才会更快一些，有大佬知道这是为什么？？<br>2、-XX:TypeProfileWidth设置为3后 没有变快也没有变慢。。。","like_count":0},{"had_liked":false,"id":215301,"user_name":"旅途","can_delete":false,"product_type":"c1","uid":1212902,"ip_address":"","ucode":"5022477E8E9441","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","comment_is_top":false,"comment_ctime":1588950325,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588950325","product_id":100010301,"comment_content":"老师 每个调用能够记录的类型数目 默认是2 那你举的最后的两个method调用的例子  profile还会失效马","like_count":0},{"had_liked":false,"id":191835,"user_name":"马志远","can_delete":false,"product_type":"c1","uid":1480892,"ip_address":"","ucode":"AAD8875343E5FC","user_header":"https://static001.geekbang.org/account/avatar/00/16/98/bc/6d5affd3.jpg","comment_is_top":false,"comment_ctime":1584799440,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584799440","product_id":100010301,"comment_content":"多看几遍才懂","like_count":0},{"had_liked":false,"id":185319,"user_name":"单俊宁","can_delete":false,"product_type":"c1","uid":1855289,"ip_address":"","ucode":"403678A72C3305","user_header":"https://static001.geekbang.org/account/avatar/00/1c/4f/39/cb4df994.jpg","comment_is_top":false,"comment_ctime":1583561092,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583561092","product_id":100010301,"comment_content":"本地实现是指？","like_count":0},{"had_liked":false,"id":171260,"user_name":"88591","can_delete":false,"product_type":"c1","uid":1254656,"ip_address":"","ucode":"04CE3E46455185","user_header":"https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg","comment_is_top":false,"comment_ctime":1578887857,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578887857","product_id":100010301,"comment_content":"老师这样理解反射对吗 ？当可执行的代码块被加载到内存后，有两种方式找到可执行代码块位置。1、通过正向的流程，比如编译时期，计算好符号引用（函数调用）的关系。2、通过逆向的流程，在可执行的所有代码中，查找满足条件的代码区域（反射）。","like_count":0},{"had_liked":false,"id":162723,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1576581403,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576581403","product_id":100010301,"comment_content":"好文。只是我机器跑的结果是 v3 好于 v4 好于 v2。。。","like_count":0},{"had_liked":false,"id":154609,"user_name":"Dowen Liu","can_delete":false,"product_type":"c1","uid":1440423,"ip_address":"","ucode":"DD072D44AD353D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLCrJQ4AZe8VrDkR6IO03V4Tda9WexVT4zZiahBjLSYOnZb1Y49JvD2f70uQwYSMibUMQvib9NmGxEiag/132","comment_is_top":false,"comment_ctime":1574492526,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574492526","product_id":100010301,"comment_content":"Java 11 环境下，加上参数 -Dsun.reflect.noInflation=true 后反而耗时更多了…… 试了几次，应该把 =true 去掉，-Dsun.reflect.noInflation","like_count":0},{"had_liked":false,"id":141624,"user_name":"despicable--","can_delete":false,"product_type":"c1","uid":1588636,"ip_address":"","ucode":"0C4565D82D13C7","user_header":"https://static001.geekbang.org/account/avatar/00/18/3d/9c/74355ff6.jpg","comment_is_top":false,"comment_ctime":1571203091,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571203091","product_id":100010301,"comment_content":"我是硬着头皮看到这一篇了，看到中途，我脑子不断说别看了，营养跟不上！营养跟不上","like_count":0},{"had_liked":false,"id":136728,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1569499556,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569499556","product_id":100010301,"comment_content":"1. &quot;==&quot;为false，<br> klazz.getMethod 最终会调用Method.copy()方法，该方法会每次都会new一个Method对象。<br> Method res = new Method(clazz, name, parameterTypes, returnType,<br>                                exceptionTypes, modifiers, slot, signature,<br>                                annotations, parameterAnnotations, annotationDefault);<br>所以两次生成了两个对象，因而‘’==‘’ 为false。<br><br>2. equals 为true<br>Method类重写了equals和hashCode方法。<br><br>3.我测试是比V5快了许多。 应该是都是用了同一个类同一个方法的原因。<br>然后通过将-XX:TypeProfileWidth设为1，发现与默认值2运行时间基本一致。","like_count":0},{"had_liked":false,"id":132035,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1568009664,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568009664","product_id":100010301,"comment_content":"反射调用的两种实现：委派本地方法实现、委派动态实现<br>反射调用性能低的原因：参数Object数组的生成、基本类型的自动装箱、即时编译器的内联","like_count":0},{"had_liked":false,"id":129281,"user_name":"简乐","can_delete":false,"product_type":"c1","uid":1498613,"ip_address":"","ucode":"258CCEBC9DFF46","user_header":"https://static001.geekbang.org/account/avatar/00/16/dd/f5/fd9ee46b.jpg","comment_is_top":false,"comment_ctime":1567077862,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1567077862","product_id":100010301,"comment_content":"老师，我发现一个现象，就是通过反射机制为类A的静态的引用类型的变量v赋值后，稍后再去获取v的值时，发现值为null。这是为什么呢？","like_count":0,"discussions":[{"author":{"id":1498613,"avatar":"https://static001.geekbang.org/account/avatar/00/16/dd/f5/fd9ee46b.jpg","nickname":"简乐","note":"","ucode":"258CCEBC9DFF46","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6854,"discussion_content":"这个问题其实不是问题，之前的测试代码有点问题，不好意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567143230,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83427,"user_name":"舒大飞","can_delete":false,"product_type":"c1","uid":1313651,"ip_address":"","ucode":"5CC2E0F8C40E38","user_header":"https://static001.geekbang.org/account/avatar/00/14/0b/73/4f1c9676.jpg","comment_is_top":false,"comment_ctime":1554596030,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1554596030","product_id":100010301,"comment_content":"老师，希望分析一下，反射到底是怎么实现的，与普通方法调用的区别在哪里，与普通方法调用它的耗时点在哪里","like_count":0},{"had_liked":false,"id":82267,"user_name":"朱明伟","can_delete":false,"product_type":"c1","uid":1243879,"ip_address":"","ucode":"D5C8F16E8CFC6F","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/e7/55f9283f.jpg","comment_is_top":false,"comment_ctime":1554172926,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1554172926","product_id":100010301,"comment_content":"Method.java invoke方法我看的源码为什么是native的并没有具体实现，请问老师讲java源码的时候能不能同事讲一下具体版本号并且怎么查看源码呢","like_count":0,"discussions":[{"author":{"id":1783342,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/36/2e/376a3551.jpg","nickname":"ano","note":"","ucode":"7DE64BDFA78550","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583199,"discussion_content":"编译器通过ABI 来调用 C++的具体实现，你看到的只是用 java 写的一个声明。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659946551,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79631,"user_name":"Go","can_delete":false,"product_type":"c1","uid":1272162,"ip_address":"","ucode":"5A2DD350470216","user_header":"https://static001.geekbang.org/account/avatar/00/13/69/62/e3b7321a.jpg","comment_is_top":false,"comment_ctime":1553514181,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553514181","product_id":100010301,"comment_content":"上面V2代码中提到一亿次直接调用耗费的时间大约在 120ms，我这边测试了下，耗时似乎不在方法的调用，而是取余的计算上面，我本机循环执行20亿次方法调用，合计平均时间8ms,使用反射是3000ms+的耗时，这里是不是有问题呢？通过把V2中的取余部分的代码去掉，能够验证我的结论，还望解答下。","like_count":0},{"had_liked":false,"id":78393,"user_name":"有人","can_delete":false,"product_type":"c1","uid":1243902,"ip_address":"","ucode":"5F39A77E6C4A26","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/fe/26553aba.jpg","comment_is_top":false,"comment_ctime":1553138385,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1553138385","product_id":100010301,"comment_content":"老师你好，关于v5中有个解决方案提到可以使用v3的解决方案，即在循环外构造参数数组，然后传入invoke里面，但是v3里不是说这个会使JVM不确定循环外的参数是否会在循环内改变，而导致逃逸分析失效吗，还是我对文章有些关键点没有理解到，望指出","like_count":0,"discussions":[{"author":{"id":1184778,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/hHAggykOyjScVG9qqSsdVaShDZoK6awO1uZYb3b75UA5QocVPMe3AT3AP3RDamtU7k8nekvc67DUzLRFDMTUQQ/132","nickname":"Geek_56d8e2","note":"","ucode":"D44E94FF5BFD9F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558802,"discussion_content":"这么好的一个问题 老师就是不回复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648473575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75638,"user_name":"bgmall","can_delete":false,"product_type":"c1","uid":1068926,"ip_address":"","ucode":"F07665E471CF1E","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/7e/4a053154.jpg","comment_is_top":false,"comment_ctime":1552442354,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552442354","product_id":100010301,"comment_content":"方法的反射调用，是委派实现，调用本地方法，默认超过15次，就动态生成方法实现，生成的方法效率是本地实现的20倍，这是在频繁调用的情况下，第一次调用，本地方法实现的效率还高3倍。","like_count":0},{"had_liked":false,"id":74376,"user_name":"松花皮蛋me","can_delete":false,"product_type":"c1","uid":1000054,"ip_address":"","ucode":"B0846CEEF6B0D1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/76/256bbd43.jpg","comment_is_top":false,"comment_ctime":1552206137,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552206137","product_id":100010301,"comment_content":"没看懂方法内联怎么导致反射变慢的","like_count":0},{"had_liked":false,"id":74000,"user_name":"Sharry","can_delete":false,"product_type":"c1","uid":1239293,"ip_address":"","ucode":"045DDB864659F6","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/fd/035f4c94.jpg","comment_is_top":false,"comment_ctime":1552056839,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552056839","product_id":100010301,"comment_content":"老师您好!<br>关于无法内联导致反射性能退化我的理解是这样子的: 当生成类 GeneratedMethodAccessorXX 多到一定程度时, MethodAccessor.invoke 便会成为超多态调用, 每次需要使用方法表确认目标方法, 这种情况下 JVM 是无法进行方法内联的, 这样一来反射的效率就大大折扣了, 不知这样理解是否合理, 还烦请老师解答~","like_count":0},{"had_liked":false,"id":67510,"user_name":"健健","can_delete":false,"product_type":"c1","uid":1236365,"ip_address":"","ucode":"33E4F5E07F3F67","user_header":"https://static001.geekbang.org/account/avatar/00/12/dd/8d/3e3dbe47.jpg","comment_is_top":false,"comment_ctime":1550188801,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550188801","product_id":100010301,"comment_content":"老师您好，如果我是在tomcat容器上运行的java应用，修改jvm参数的话，也会影响到我的spring和tomcat吗？","like_count":0},{"had_liked":false,"id":62093,"user_name":"水果刀","can_delete":false,"product_type":"c1","uid":1236586,"ip_address":"","ucode":"CA787A086DAB70","user_header":"https://static001.geekbang.org/account/avatar/00/12/de/6a/4db4a75e.jpg","comment_is_top":false,"comment_ctime":1547907641,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547907641","product_id":100010301,"comment_content":"老师，不太理解本地方法。为什么要经过本地方法的调用，才能找到实例方法？","like_count":0},{"had_liked":false,"id":59467,"user_name":"sylar","can_delete":false,"product_type":"c1","uid":1276479,"ip_address":"","ucode":"CB93044C2EEAB4","user_header":"https://static001.geekbang.org/account/avatar/00/13/7a/3f/38726b58.jpg","comment_is_top":false,"comment_ctime":1547374620,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1547374620","product_id":100010301,"comment_content":"如果在循环外新建数组，即时编译器无法确定这个数组会不会中途被更改，因此无法优化掉访问数组的操作，可谓是得不偿失。老师问一下：您说的这里得不偿失什么意思？","like_count":0,"discussions":[{"author":{"id":1184778,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/hHAggykOyjScVG9qqSsdVaShDZoK6awO1uZYb3b75UA5QocVPMe3AT3AP3RDamtU7k8nekvc67DUzLRFDMTUQQ/132","nickname":"Geek_56d8e2","note":"","ucode":"D44E94FF5BFD9F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558801,"discussion_content":"老师 能回答下这个问题吗 很纠结","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648472714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1105991,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e0/47/66cb8ac9.jpg","nickname":"","note":"","ucode":"6AF6FCD4431814","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405669,"discussion_content":"可以去了解下 逃逸分析","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634615352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":53868,"user_name":"小兵","can_delete":false,"product_type":"c1","uid":1261674,"ip_address":"","ucode":"AA3BA727C25179","user_header":"https://static001.geekbang.org/account/avatar/00/13/40/6a/ab1cf396.jpg","comment_is_top":false,"comment_ctime":1545745179,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545745179","product_id":100010301,"comment_content":"不管TypeProfileWidth是设置为3还是8，结果没变化。jdk用的是10，另外我在Oracle官网上好像没有找到这个参数。不知道是什么原因。","like_count":0},{"had_liked":false,"id":51608,"user_name":"二毛","can_delete":false,"product_type":"c1","uid":1344119,"ip_address":"","ucode":"2795CF80F11604","user_header":"https://static001.geekbang.org/account/avatar/00/14/82/77/9cb5de00.jpg","comment_is_top":false,"comment_ctime":1545207023,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545207023","product_id":100010301,"comment_content":"老师你好！<br>动态实现和本地实现相比，其运行效率要快上 20 倍 [2] 这是因为动态实现无需经过 Java 到 C++ 再到 Java 的切换，但由于生成字节码十分耗时，仅调用一次的话，反而是本地实现要快上 3 到 4 倍 [3]。<br>以我拙劣的数据能力推测出，调用3次（从1开始计数）的话本地调用更占优，大于3次（从1开始计数）的话动态实现更占优。不知JVM为什么默认阈值是15呢","like_count":0},{"had_liked":false,"id":48926,"user_name":"Geek_c26b58","can_delete":false,"product_type":"c1","uid":1181058,"ip_address":"","ucode":"D499157C4262AB","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/82/529aafae.jpg","comment_is_top":false,"comment_ctime":1544578842,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544578842","product_id":100010301,"comment_content":"方法内联是编译器做的，这个阶段是在程序执行阶段进行的吧？内联的标准是什么？","like_count":0},{"had_liked":false,"id":22381,"user_name":"肖一林","can_delete":false,"product_type":"c1","uid":1113317,"ip_address":"","ucode":"1DE45D906EB836","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/e5/605f423f.jpg","comment_is_top":false,"comment_ctime":1535637792,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1535637792","product_id":100010301,"comment_content":"郑老师，咨询你一个问题，使用jdk1.6循环使用反射机制导致cpu使用率达到100%的情况，你遇到过吗？谢谢","like_count":0},{"had_liked":false,"id":21160,"user_name":"于林富","can_delete":false,"product_type":"c1","uid":1064825,"ip_address":"","ucode":"DD0C191507080D","user_header":"https://static001.geekbang.org/account/avatar/00/10/3f/79/adbfb232.jpg","comment_is_top":false,"comment_ctime":1534943701,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1534943701","product_id":100010301,"comment_content":"基准时间120ms是带method.invoke(null, 128);还是不带","like_count":0},{"had_liked":false,"id":20697,"user_name":"曲东方","can_delete":false,"product_type":"c1","uid":1177819,"ip_address":"","ucode":"6C3EA2F47A0B98","user_header":"https://static001.geekbang.org/account/avatar/00/11/f8/db/c4edf697.jpg","comment_is_top":false,"comment_ctime":1534676101,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1534676101","product_id":100010301,"comment_content":"性能测试的基准，是不是“不使用refect”对比&quot;使用reflect&quot;&quot;比较好？","like_count":0},{"had_liked":false,"id":20556,"user_name":"沉淀的梦想","can_delete":false,"product_type":"c1","uid":1177315,"ip_address":"","ucode":"BCB7C26F9D214B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg","comment_is_top":false,"comment_ctime":1534524762,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1534524762","product_id":100010301,"comment_content":"在v5版本中，为什么我设置TypeProfileWidth为3，速度并没有变快呢？","like_count":0},{"had_liked":false,"id":20507,"user_name":"小明","can_delete":false,"product_type":"c1","uid":1013093,"ip_address":"","ucode":"31A24C60B4CC5B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/65/2a7f8212.jpg","comment_is_top":false,"comment_ctime":1534494492,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1534494492","product_id":100010301,"comment_content":"在v2 版本测性能的过程中， 加入判断 一亿次打印 和不加 时 执行时间 差距较大 导致测试的结果的偏差变大 。 测试性能应该将这部分的差距消除吧 ","like_count":0}]}