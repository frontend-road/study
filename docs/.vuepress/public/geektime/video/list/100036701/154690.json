{"id":154690,"title":"19 | Netty如何玩转内存使用","content":"<p><strong>课件和Demo地址</strong><br>\n<a href=\"https://gitee.com/geektime-geekbang/geek_netty\">https://gitee.com/geektime-geekbang/geek_netty</a></p>","comments":[{"had_liked":false,"id":156707,"user_name":"冬渐暖","can_delete":false,"product_type":"c3","uid":1586800,"ip_address":"","ucode":"907E41AAE9A36C","user_header":"https://static001.geekbang.org/account/avatar/00/18/36/70/00122b24.jpg","comment_is_top":false,"comment_ctime":1574939180,"is_pvip":false,"replies":[{"id":61521,"content":"“netty在某些方面并不是最优的”，肯定的，不然这15年来就不会一直在持续优化改进了，所以可怕的不是已经做到最好，而是一直还在改进，哈哈","user_name":"作者回复","user_name_real":"stroller","uid":1638649,"ctime":1576207023,"ip_address":"","comment_id":156707,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"节省内存的一些技巧\n1.能用基本类型尽量用基本类型，就不要去用包装类型了，包装类明显占用的空间更大，之前有说到，包装类除了值，还带了一些信息，比如hash之些的对象头，还有引用地址\n2.一些类定义的属性变量，就直接在这个类里面定义，不要跑到引用的地方去一个一个的重新定义。\n3.创建一些需要提前设置好大小的东西的时候，先去看下装进来的东西有多少（如果不知道就去猜），然后把这个值set进去。比如hashmap的丢弃原数组暴力扩容不如先设置好适合的大小。 不过如果改了jvm的这个负载因子0.75，这些地方还根据0.75判断，就凉凉咯\n4.zero-copy 将数据组合到一起，而不是内存的复制\n5.内存池：1.循环利用\n   2.省的用一次创建一次，开始的时候直接给你全部都创好(感觉这样的话会拖慢启动速度，而且也要维护这些东西。。。。)\n   3.支持并发:一下子可以拿好多个\n\n堆外内存:直接受操作系统管理（而不是虚拟机），jvm只是拿一个引用\n好处是1.增大了空间(原来你只有个jvm的，现在你又多了个)\n    2.减少辣鸡回收。辣鸡回收会让其它的工作暂停\n    3.堆内在flush到远程时，会先复制到直接内存（非堆内存），然后在发送；而堆外内存相当于省略掉了这个工作。\n缺点是1.难管:因为操作系统管的，所以不容易控制，\n    2.创建慢\n    3.不容易排查(内存溢出的时候)\n\n\n堆外内存和非堆内存是不一样的，非堆是比如栈一类的，还是在jvm内部。堆外在外面\n\n\n\n这章可以看出，netty在某些方面并不是最优的，不同的场景或许有更好的选择，或许没有","like_count":9,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476208,"discussion_content":"“netty在某些方面并不是最优的”，肯定的，不然这15年来就不会一直在持续优化改进了，所以可怕的不是已经做到最好，而是一直还在改进，哈哈","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576207023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146877,"user_name":"高源","can_delete":false,"product_type":"c3","uid":1048887,"ip_address":"","ucode":"751B41FD38EF7D","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/37/12e4c9c9.jpg","comment_is_top":false,"comment_ctime":1572685082,"is_pvip":false,"replies":[{"id":57315,"content":"因为不知道你的程序到底是什么样的，只能从描述上推测可能的情况，是不是你的业务线程是复用NioEventLoop的，也就是没有单独搞一个线程池去处理，这样的话，如果你的任务比较重（单个任务处理很耗时），那就会影响到你的IO处理（收发），自然也就慢了，你看下是不是这个情况。","user_name":"作者回复","user_name_real":"Geek_9bc307","uid":1638649,"ctime":1573133429,"ip_address":"","comment_id":146877,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师请教问题，我开发服务端程序，下面有多个客户端连接发送消息，socket tcp通信方式，现在发现如果多个客户端发送，并发消息多了，根据日志分析发现服务端接收的就晚了，导致客户端记录超时，这种情况怎么解决啊，是服务端处理能力不行吗，另外还有一种情况是客户端发消息了，但服务端没有收到导致超时。这两种情况我该怎么处理呢😊希望老师指点江山啊😊","like_count":2,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473042,"discussion_content":"因为不知道你的程序到底是什么样的，只能从描述上推测可能的情况，是不是你的业务线程是复用NioEventLoop的，也就是没有单独搞一个线程池去处理，这样的话，如果你的任务比较重（单个任务处理很耗时），那就会影响到你的IO处理（收发），自然也就慢了，你看下是不是这个情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573133429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281989,"user_name":"三颗豆子","can_delete":false,"product_type":"c3","uid":2008638,"ip_address":"","ucode":"632CE3E7563666","user_header":"https://static001.geekbang.org/account/avatar/00/1e/a6/3e/3d18f35a.jpg","comment_is_top":false,"comment_ctime":1615003701,"is_pvip":false,"replies":[{"id":105069,"content":"哈哈，谢谢提醒","user_name":"作者回复","user_name_real":"傅健","uid":1638649,"ctime":1619133714,"ip_address":"","comment_id":281989,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"课程很棒，但希望大佬可以练习一下英语，byte不是bit，queue不是&quot;亏&quot;之类的。多听几遍会让人记住这些发音的……看视频又想记住知识，又想忘记发音，就很难受。","like_count":1,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516573,"discussion_content":"哈哈，谢谢提醒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619133714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144662,"user_name":"13761642169","can_delete":false,"product_type":"c3","uid":1232334,"ip_address":"","ucode":"68137695FC2120","user_header":"","comment_is_top":false,"comment_ctime":1571991888,"is_pvip":false,"replies":[{"id":57879,"content":"不是，jvm里面的堆相当于数据，栈算动作，所以加一起，堆栈，而堆外内存自然属于堆“外”。","user_name":"作者回复","user_name_real":"Geek_9bc307","uid":1638649,"ctime":1573550023,"ip_address":"","comment_id":144662,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"DirectByteBuffer 是堆外内存。把 JVM 进程当作一个普通进程，堆外内存是原来“堆”的一部分吗？","like_count":1,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472060,"discussion_content":"不是，jvm里面的堆相当于数据，栈算动作，所以加一起，堆栈，而堆外内存自然属于堆“外”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573550023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1184514,"avatar":"https://static001.geekbang.org/account/avatar/00/12/13/02/37aa3882.jpg","nickname":"R曾","note":"","ucode":"8AED49A52AFF12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40864,"discussion_content":"堆外就是堆外，不在jvm gc范围的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572278049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1232334,"avatar":"","nickname":"13761642169","note":"","ucode":"68137695FC2120","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1184514,"avatar":"https://static001.geekbang.org/account/avatar/00/12/13/02/37aa3882.jpg","nickname":"R曾","note":"","ucode":"8AED49A52AFF12","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41185,"discussion_content":"这里的堆指进程的“堆”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572362032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":40864,"ip_address":"","group_id":0},"score":41185,"extra":""}]}]},{"had_liked":false,"id":224508,"user_name":"jhren","can_delete":false,"product_type":"c3","uid":1596987,"ip_address":"","ucode":"60F7CCEA1E2C88","user_header":"https://static001.geekbang.org/account/avatar/00/18/5e/3b/845fb641.jpg","comment_is_top":false,"comment_ctime":1591424955,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师真是妙语连珠\n“智商不够靠加机器解决”","like_count":6},{"had_liked":false,"id":258796,"user_name":"Geek_92e5c7","can_delete":false,"product_type":"c3","uid":2204181,"ip_address":"","ucode":"8C365ED3EB4680","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiaZ7nNKht10ByTCOSaLX6ZdSWqS2tlyUVqQ5eUeOSe2Ufrtb3UsRVkNU2fiaJjbWXBianuEHuV4BzTiaKm90HdtiaA/132","comment_is_top":false,"comment_ctime":1604558428,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"这是一门让我看的津津有味的课程，优秀","like_count":3},{"had_liked":false,"id":358828,"user_name":"李干嘛","can_delete":false,"product_type":"c3","uid":3109470,"ip_address":"湖南","ucode":"C93D33187ABE1A","user_header":"https://static001.geekbang.org/account/avatar/00/2f/72/5e/1533fac0.jpg","comment_is_top":false,"comment_ctime":1664865368,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"不够好，缺乏细节，举个例子，那个msg有时channel有时bytebuf没详细说明。很多地方一笔带过。","like_count":2},{"had_liked":false,"id":173825,"user_name":"13761642169","can_delete":false,"product_type":"c3","uid":1232334,"ip_address":"","ucode":"68137695FC2120","user_header":"","comment_is_top":false,"comment_ctime":1579709810,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"我看着您的课程，然后仔细去撸了 netty 的源码，感觉水挺深。光内存分配这块，首先是对象池，然后是内存的管理，大量使用 thread local，还有虚引用。再感觉就是 pipeline，这块始终串不起来，通常见到的 pipeline，都是在一条流水线上执行同一个方法，像 filter 那样，但 netty 的 pipeline，write 一个对象出去，调到了 MessageToByte 的 encode 方法","like_count":2},{"had_liked":false,"id":288428,"user_name":"笑忘书","can_delete":false,"product_type":"c3","uid":1180447,"ip_address":"","ucode":"FA21EFA971E03D","user_header":"https://static001.geekbang.org/account/avatar/00/12/03/1f/1280ed77.jpg","comment_is_top":false,"comment_ctime":1618466146,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"减少内存技巧：\n1.基本类型变量优先于包装类变量\n2.类变量优先于实例变量\n3.预估内存要使用的大小来设置内存空间申请\n4.zero-copy (1.逻辑组合代替内存复制 2.包装代替内存复制 3.netty调用了jdk支持的zero-copy)\n5.堆外内存(off heap):  JVM(heap + non heeap 非堆(栈、方法区等)) \n   优点：减轻GC压力   减少冗余细节 减少复制\n   缺点：创建速度慢   受操作系统管理，风险不可控\n6.内存池：\n    why：1.创建对象开销比较大   2.对象高频率创建且可复用  3.支持高并发且能保护系统  4.维护、共享有限的资源\n    how：Apache Commons Pool 全局共享内存池  资源争用比较厉害\n              Netty 轻量级对象池   io.netty.util.Recycler   ","like_count":1},{"had_liked":false,"id":173827,"user_name":"13761642169","can_delete":false,"product_type":"c3","uid":1232334,"ip_address":"","ucode":"68137695FC2120","user_header":"","comment_is_top":false,"comment_ctime":1579710125,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"我是从 rocketMQ 到的 netty，rmq 里面用到了FileRegion，具体这里面的优势在哪","like_count":1},{"had_liked":false,"id":173826,"user_name":"13761642169","can_delete":false,"product_type":"c3","uid":1232334,"ip_address":"","ucode":"68137695FC2120","user_header":"","comment_is_top":false,"comment_ctime":1579710003,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"还有就是，我看到网上的说法，堆外内存IO比堆内内存IO效率高，减少了一次拷贝。说是，java IO时，会先从堆内拷堆外，然后才是写到 socket buffer，原因是 Java gc 会改变对象的内存地址","like_count":1},{"had_liked":false,"id":386434,"user_name":"wallacefw","can_delete":false,"product_type":"c3","uid":1168686,"ip_address":"广东","ucode":"9EC56A542D9927","user_header":"https://static001.geekbang.org/account/avatar/00/11/d5/2e/7ace1d94.jpg","comment_is_top":false,"comment_ctime":1704803988,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"看到这里","like_count":0},{"had_liked":false,"id":377094,"user_name":"Geek_fa0f35","can_delete":false,"product_type":"c3","uid":2258701,"ip_address":"北京","ucode":"1CEAAFF6A94491","user_header":"","comment_is_top":false,"comment_ctime":1687924817,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"老师，根据视频基于netty创建了通信层，现在遇到一个问题，消息大概有30M，经常提示IndexOutOfBoundsException，readerIndex(24) + length(29072808) exceeds writerIndex(1024)。这个怎么解决？","like_count":0},{"had_liked":false,"id":286738,"user_name":"长脖子树","can_delete":false,"product_type":"c3","uid":1182802,"ip_address":"","ucode":"D9090EF67EEB1B","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/52/f25c3636.jpg","comment_is_top":false,"comment_ctime":1617541567,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"看了下源码 4.1.60 版本 , AdaptiveRecvByteBufAllocator.HandleImpl 中的 record()方法中的 -1 已经去掉了","like_count":0},{"had_liked":false,"id":220939,"user_name":"天琊","can_delete":false,"product_type":"c3","uid":1285621,"ip_address":"","ucode":"E3EAA4E6C4237B","user_header":"https://static001.geekbang.org/account/avatar/00/13/9d/f5/c74224dc.jpg","comment_is_top":false,"comment_ctime":1590361590,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"进程一般分为数据段，代码段，堆和栈，从进程的角度看jvm. java stack, java heap都是在jvm进程的堆里. 那么这节内容的directByteBuf也是在jvm里面的堆（不是指java heap）里分配么","like_count":0},{"had_liked":false,"id":179823,"user_name":"辉煌码农","can_delete":false,"product_type":"c3","uid":1332799,"ip_address":"","ucode":"09779C2E06EA52","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIy5ULaodUwsLoPuk1wd22hqXsaBbibNEqXM0kgrCTYDGKYQkZICYEyH9wMj4hyUicuQwHdDuOKRj0g/132","comment_is_top":false,"comment_ctime":1582105083,"is_pvip":false,"replies":null,"discussion_count":3,"race_medal":0,"score":3,"product_id":100036701,"comment_content":" static int capacity(int expectedSize) {\n    if (expectedSize &lt; 3) {\n      checkNonnegative(expectedSize, &quot;expectedSize&quot;);\n      return expectedSize + 1;\n    }\n    if (expectedSize &lt; Ints.MAX_POWER_OF_TWO) {\n      &#47;&#47; This is the calculation used in JDK8 to resize when a putAll\n      &#47;&#47; happens; it seems to be the most conservative calculation we\n      &#47;&#47; can make.  0.75 is the default load factor.\n      return (int) ((float) expectedSize &#47; 0.75F + 1.0F);\n    }\n    return Integer.MAX_VALUE; &#47;&#47; any large value\n  }\n\n老师，这一行最后为什么还需要加1呢。假设HashMap 只需要存6个元素，不加 6 &#47; 0.75 刚好等于8，加1之后变成9，数组长度要变成16，不是空间有浪费吗？","like_count":0,"discussions":[{"author":{"id":1614090,"avatar":"https://static001.geekbang.org/account/avatar/00/18/a1/0a/b1f68315.jpg","nickname":"零零后糖豆豆","note":"","ucode":"B83235955294C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636869,"discussion_content":"因为到 6 就会扩容 这个例子找的不恰当 应该找 16 以上的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1707138113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338987,"discussion_content":"负载因子默认为0.75，假设HashMap容量为8，那么扩容阈值为8 * 0.75 = 6，也就是说存储元素达到6个时，就要扩容，变成16，因此返回的容量会是16","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609470336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1136188,"avatar":"https://static001.geekbang.org/account/avatar/00/11/56/3c/e345522b.jpg","nickname":"xxwy","note":"","ucode":"BA2476EAF31F0D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220611,"discussion_content":"向上取整？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585906579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}