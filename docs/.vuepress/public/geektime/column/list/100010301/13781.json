{"id":13781,"title":"15 | Java语法糖与Java编译器","content":"<p>在前面的篇章中，我们多次提到了Java语法和Java字节码的差异之处。这些差异之处都是通过Java编译器来协调的。今天我们便来列举一下Java编译器的协调工作。</p>\n<h2>自动装箱与自动拆箱</h2>\n<p>首先要提到的便是Java的自动装箱（auto-boxing）和自动拆箱（auto-unboxing）。</p>\n<p>我们知道，Java语言拥有8个基本类型，每个基本类型都有对应的包装（wrapper）类型。</p>\n<p>之所以需要包装类型，是因为许多Java核心类库的API都是面向对象的。举个例子，Java核心类库中的容器类，就只支持引用类型。</p>\n<p>当需要一个能够存储数值的容器类时，我们往往定义一个存储包装类对象的容器。</p>\n<p>对于基本类型的数值来说，我们需要先将其转换为对应的包装类，再存入容器之中。在Java程序中，这个转换可以是显式，也可以是隐式的，后者正是Java中的自动装箱。</p>\n<pre><code>public int foo() {\n  ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n  list.add(0);\n  int result = list.get(0);\n  return result;\n}\n</code></pre>\n<p>以上图中的Java代码为例。我构造了一个Integer类型的ArrayList，并且向其中添加一个int值0。然后，我会获取该ArrayList的第0个元素，并作为int值返回给调用者。这段代码对应的Java字节码如下所示：</p>\n<pre><code>public int foo();\n  Code:\n     0: new java/util/ArrayList\n     3: dup\n     4: invokespecial java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V\n     7: astore_1\n     8: aload_1\n     9: iconst_0\n    10: invokestatic java/lang/Integer.valueOf:(I)Ljava/lang/Integer;\n    13: invokevirtual java/util/ArrayList.add:(Ljava/lang/Object;)Z\n    16: pop\n    17: aload_1\n    18: iconst_0\n    19: invokevirtual java/util/ArrayList.get:(I)Ljava/lang/Object;\n    22: checkcast java/lang/Integer\n    25: invokevirtual java/lang/Integer.intValue:()I\n    28: istore_2\n    29: iload_2\n    30: ireturn\n</code></pre>\n<p>当向泛型参数为Integer的ArrayList添加int值时，便需要用到自动装箱了。在上面字节码偏移量为10的指令中，我们调用了Integer.valueOf方法，将int类型的值转换为Integer类型，再存储至容器类中。</p><!-- [[[read_end]]] -->\n<pre><code>public static Integer valueOf(int i) {\n    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}\n</code></pre>\n<p>这是Integer.valueOf的源代码。可以看到，当请求的int值在某个范围内时，我们会返回缓存了的Integer对象；而当所请求的int值在范围之外时，我们则会新建一个Integer对象。</p>\n<p>在介绍反射的那一篇中，我曾经提到参数java.lang.Integer.IntegerCache.high。这个参数将影响这里面的IntegerCache.high。</p>\n<p>也就是说，我们可以通过配置该参数，扩大Integer缓存的范围。Java虚拟机参数-XX:+AggressiveOpts也会将IntegerCache.high调整至20000。</p>\n<p>奇怪的是，Java并不支持对IntegerCache.low的更改，也就是说，对于小于-128的整数，我们无法直接使用由Java核心类库所缓存的Integer对象。</p>\n<pre><code>25: invokevirtual java/lang/Integer.intValue:()I\n</code></pre>\n<p>当从泛型参数为Integer的ArrayList取出元素时，我们得到的实际上也是Integer对象。如果应用程序期待的是一个int值，那么就会发生自动拆箱。</p>\n<p>在我们的例子中，自动拆箱对应的是字节码偏移量为25的指令。该指令将调用Integer.intValue方法。这是一个实例方法，直接返回Integer对象所存储的int值。</p>\n<h2>泛型与类型擦除</h2>\n<p>你可能已经留意到了，在前面例子生成的字节码中，往ArrayList中添加元素的add方法，所接受的参数类型是Object；而从ArrayList中获取元素的get方法，其返回类型同样也是Object。</p>\n<p>前者还好，但是对于后者，在字节码中我们需要进行向下转换，将所返回的Object强制转换为Integer，方能进行接下来的自动拆箱。</p>\n<pre><code>13: invokevirtual java/util/ArrayList.add:(Ljava/lang/Object;)Z\n...\n19: invokevirtual java/util/ArrayList.get:(I)Ljava/lang/Object;\n22: checkcast java/lang/Integer\n</code></pre>\n<p>之所以会出现这种情况，是因为Java泛型的类型擦除。这是个什么概念呢？简单地说，那便是Java程序里的泛型信息，在Java虚拟机里全部都丢失了。这么做主要是为了兼容引入泛型之前的代码。</p>\n<p>当然，并不是每一个泛型参数被擦除类型后都会变成Object类。对于限定了继承类的泛型参数，经过类型擦除后，所有的泛型参数都将变成所限定的继承类。也就是说，Java编译器将选取该泛型所能指代的所有类中层次最高的那个，作为替换泛型的类。</p>\n<pre><code>class GenericTest&lt;T extends Number&gt; {\n  T foo(T t) {\n    return t;\n  }\n}\n</code></pre>\n<p>举个例子，在上面这段Java代码中，我定义了一个T extends Number的泛型参数。它所对应的字节码如下所示。可以看到，foo方法的方法描述符所接收参数的类型以及返回类型都为Number。方法描述符是Java虚拟机识别方法调用的目标方法的关键。</p>\n<pre><code>T foo(T);\n  descriptor: (Ljava/lang/Number;)Ljava/lang/Number;\n  flags: (0x0000)\n  Code:\n    stack=1, locals=2, args_size=2\n       0: aload_1\n       1: areturn\n  Signature: (TT;)TT;\n</code></pre>\n<p>不过，字节码中仍存在泛型参数的信息，如方法声明里的T foo(T)，以及方法签名（Signature）中的“(TT;)TT;”。这类信息主要由Java编译器在编译他类时使用。</p>\n<p>既然泛型会被类型擦除，那么我们还有必要用它吗？</p>\n<p>我认为是有必要的。Java编译器可以根据泛型参数判断程序中的语法是否正确。举例来说，尽管经过类型擦除后，ArrayList.add方法所接收的参数是Object类型，但是往泛型参数为Integer类型的ArrayList中添加字符串对象，Java编译器是会报错的。</p>\n<pre><code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();\nlist.add(&quot;0&quot;); // 编译出错\n</code></pre>\n<h2>桥接方法</h2>\n<p>泛型的类型擦除带来了不少问题。其中一个便是方法重写。在第四篇的课后实践中，我留了这么一段代码：</p>\n<pre><code>class Merchant&lt;T extends Customer&gt; {\n  public double actionPrice(T customer) {\n    return 0.0d;\n  }\n}\n\nclass VIPOnlyMerchant extends Merchant&lt;VIP&gt; {\n  @Override\n  public double actionPrice(VIP customer) {\n    return 0.0d;\n  }\n}\n</code></pre>\n<p>VIPOnlyMerchant中的actionPrice方法是符合Java语言的方法重写的，毕竟都使用@Override来注解了。然而，经过类型擦除后，父类的方法描述符为(LCustomer;)D，而子类的方法描述符为(LVIP;)D。这显然不符合Java虚拟机关于方法重写的定义。</p>\n<p>为了保证编译而成的Java字节码能够保留重写的语义，Java编译器额外添加了一个桥接方法。该桥接方法在字节码层面重写了父类的方法，并将调用子类的方法。</p>\n<pre><code>class VIPOnlyMerchant extends Merchant&lt;VIP&gt;\n...\n  public double actionPrice(VIP);\n    descriptor: (LVIP;)D\n    flags: (0x0001) ACC_PUBLIC\n    Code:\n         0: dconst_0\n         1: dreturn\n\n  public double actionPrice(Customer);\n    descriptor: (LCustomer;)D\n    flags: (0x1041) ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC\n    Code:\n         0: aload_0\n         1: aload_1\n         2: checkcast class VIP\n         5: invokevirtual actionPrice:(LVIP;)D\n         8: dreturn\n\n// 这个桥接方法等同于\npublic double actionPrice(Customer customer) {\n  return actionPrice((VIP) customer);\n}\n</code></pre>\n<p>在我们的例子中，VIPOnlyMerchant类将包含一个桥接方法actionPrice(Customer)，它重写了父类的同名同方法描述符的方法。该桥接方法将传入的Customer参数强制转换为VIP类型，再调用原本的actionPrice(VIP)方法。</p>\n<p>当一个声明类型为Merchant，实际类型为VIPOnlyMerchant的对象，调用actionPrice方法时，字节码里的符号引用指向的是Merchant.actionPrice(Customer)方法。Java虚拟机将动态绑定至VIPOnlyMerchant类的桥接方法之中，并且调用其actionPrice(VIP)方法。</p>\n<p>需要注意的是，在javap的输出中，该桥接方法的访问标识符除了代表桥接方法的ACC_BRIDGE之外，还有ACC_SYNTHETIC。它表示该方法对于Java源代码来说是不可见的。当你尝试通过传入一个声明类型为Customer的对象作为参数，调用VIPOnlyMerchant类的actionPrice方法时，Java编译器会报错，并且提示参数类型不匹配。</p>\n<pre><code>    Customer customer = new VIP();\n    new VIPOnlyMerchant().actionPrice(customer); // 编译出错    \n</code></pre>\n<p>当然，如果你实在想要调用这个桥接方法，那么你可以选择使用反射机制。</p>\n<pre><code>class Merchant {\n  public Number actionPrice(Customer customer) {\n    return 0;\n  }\n}\n\nclass NaiveMerchant extends Merchant {\n  @Override\n  public Double actionPrice(Customer customer) {\n    return 0.0D;\n  }\n}\n</code></pre>\n<p>除了前面介绍的泛型重写会生成桥接方法之外，如果子类定义了一个与父类参数类型相同的方法，其返回类型为父类方法返回类型的子类，那么Java编译器也会为其生成桥接方法。</p>\n<pre><code>class NaiveMerchant extends Merchant\n  public java.lang.Double actionPrice(Customer);\n    descriptor: (LCustomer;)Ljava/lang/Double;\n    flags: (0x0001) ACC_PUBLIC\n    Code:\n      stack=2, locals=2, args_size=2\n         0: dconst_0\n         1: invokestatic Double.valueOf:(D)Ljava/lang/Double;\n         4: areturn\n\n  public java.lang.Number actionPrice(Customer);\n    descriptor: (LCustomer;)Ljava/lang/Number;\n    flags: (0x1041) ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC\n    Code:\n      stack=2, locals=2, args_size=2\n         0: aload_0\n         1: aload_1\n         2: invokevirtual actionPrice:(LCustomer;)Ljava/lang/Double;\n         5: areturn         \n</code></pre>\n<p>我之前曾提到过，class文件里允许出现两个同名、同参数类型但是不同返回类型的方法。这里的原方法和桥接方法便是其中一个例子。由于该桥接方法同样标注了ACC_SYNTHETIC，因此，当在Java程序中调用NaiveMerchant.actionPrice时，我们只会调用到原方法。</p>\n<h2>其他语法糖</h2>\n<p>在前面的篇章中，我已经介绍过了变长参数、try-with-resources以及在同一catch代码块中捕获多种异常等语法糖。下面我将列举另外两个常见的语法糖。</p>\n<p>foreach循环允许Java程序在for循环里遍历数组或者Iterable对象。对于数组来说，foreach循环将从0开始逐一访问数组中的元素，直至数组的末尾。其等价的代码如下面所示：</p>\n<pre><code>public void foo(int[] array) {\n  for (int item : array) {\n  }\n}\n// 等同于\npublic void bar(int[] array) {\n  int[] myArray = array;\n  int length = myArray.length;\n  for (int i = 0; i &lt; length; i++) {\n    int item = myArray[i];\n  }\n}\n</code></pre>\n<p>对于Iterable对象来说，foreach循环将调用其iterator方法，并且用它的hasNext以及next方法来遍历该Iterable对象中的元素。其等价的代码如下面所示：</p>\n<pre><code>public void foo(ArrayList&lt;Integer&gt; list) {\n  for (Integer item : list) {\n  }\n}\n// 等同于\npublic void bar(ArrayList&lt;Integer&gt; list) {\n  Iterator&lt;Integer&gt; iterator = list.iterator();\n  while (iterator.hasNext()) {\n    Integer item = iterator.next();\n  }\n}\n</code></pre>\n<p>字符串switch编译而成的字节码看起来非常复杂，但实际上就是一个哈希桶。由于每个case所截获的字符串都是常量值，因此，Java编译器会将原来的字符串switch转换为int值switch，比较所输入的字符串的哈希值。</p>\n<p>由于字符串哈希值很容易发生碰撞，因此，我们还需要用String.equals逐个比较相同哈希值的字符串。</p>\n<p>如果你感兴趣的话，可以自己利用javap分析字符串switch编译而成的字节码。</p>\n<h2>总结与实践</h2>\n<p>今天我主要介绍了Java编译器对几个语法糖的处理。</p>\n<p>基本类型和其包装类型之间的自动转换，也就是自动装箱、自动拆箱，是通过加入[Wrapper].valueOf（如Integer.valueOf）以及[Wrapper].[primitive]Value（如Integer.intValue）方法调用来实现的。</p>\n<p>Java程序中的泛型信息会被擦除。具体来说，Java编译器将选取该泛型所能指代的所有类中层次最高的那个，作为替换泛型的具体类。</p>\n<p>由于Java语义与Java字节码中关于重写的定义并不一致，因此Java编译器会生成桥接方法作为适配器。此外，我还介绍了foreach循环以及字符串switch的编译。</p>\n<p>今天的实践环节，你可以探索一下Java 10的var关键字，是否保存了泛型信息？是否支持自动装拆箱？</p>\n<pre><code>  public void foo() {\n    var value = 1;\n    var list = new ArrayList&lt;Integer&gt;();\n    list.add(value);\n    // list.add(&quot;1&quot;); 这一句能够编译吗？\n  }\n\n</code></pre>\n<p></p>\n","neighbors":{"left":{"article_title":"14 | Java虚拟机是怎么实现synchronized的？","id":13530},"right":{"article_title":"16 | 即时编译（上）","id":14061}},"comments":[{"had_liked":false,"id":21574,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1535173680,"is_pvip":false,"replies":[{"id":"8015","content":"赞","user_name":"作者回复","comment_id":21574,"uid":"1176688","ip_address":"","utype":1,"ctime":1535620851,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"233463407664","product_id":100010301,"comment_content":"本节还是比较容易理解的，也搞清楚了泛型相关的疑惑点，非常感谢。<br>小结如下：<br>1:Java语法糖-是一种帮助开发人员提高开发效率的小甜点，原理是将一些繁琐的事情交给编译器来处理，开发人员少做一些事情，当然，本纸上这些事情还必须要做，只是有编译器来做了<br><br>2:Java语法糖有那几种呢？如下所示：<br>2-1:包装类型和基本类型间的转换，自动装箱和拆箱的设计<br>2-2:泛型的设计<br>2-3:变长参数的设计<br>2-4:try-with-resources，关闭资源的设计<br>2-5:在同一个catch代码块中捕获多种异常<br>2-6:finally代码块总是被执行的设计<br>2-7:foreach循环数组的设计<br>2-8:foreach循环Iterable对象的设计<br><br>3:编译器的具体实现细节不是很清楚，猜测是识别出对应的语法然后填充上对应的代码，将语法糖还原成其本质-一些重复繁琐的代码块<br><br>4:之前有同事问我泛型是怎么实现的？<br>我讲不出来，只晓得使用泛型后，不需要写类型强转的代码了，如果类型不对也会有提示且编译失败，现在知道的多一点了，本质上类型强转的工作还是必须要做的，只是不是有开发人员来做了，由编译器来做，并且编译器会擦除掉对应的泛型信息，使用合适的父类型来代替，可能是Object类也可能是声明泛型时指定的继承的类","like_count":54,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422749,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535620851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21580,"user_name":"永烁星光","can_delete":false,"product_type":"c1","uid":1119617,"ip_address":"","ucode":"D26A9097F9D24C","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/81/2c31cf79.jpg","comment_is_top":false,"comment_ctime":1535174416,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"74549618448","product_id":100010301,"comment_content":"直到这节课逐渐感知到了学习jvm的妙处，我想将这专栏反复看和实践终能消化为自己的知识","like_count":17},{"had_liked":false,"id":38716,"user_name":"^_^","can_delete":false,"product_type":"c1","uid":1088001,"ip_address":"","ucode":"EE5DAC03CFC2EE","user_header":"https://static001.geekbang.org/account/avatar/00/10/9a/01/1489f98d.jpg","comment_is_top":false,"comment_ctime":1542113632,"is_pvip":false,"replies":[{"id":"14129","content":"确实","user_name":"作者回复","comment_id":38716,"uid":"1176688","ip_address":"","utype":1,"ctime":1542281631,"user_name_real":"郑雨迪"}],"discussion_count":3,"race_medal":0,"score":"40196819296","product_id":100010301,"comment_content":"C++ 是真泛型，java 较之算是伪泛型","like_count":9,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428781,"discussion_content":"确实","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542281631,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1360093,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLEIsgI4ub1VOKWtVOfouAzSqx8Yt8ibQEsAnwNJsJHmuJzzpQqG79HullvYwpic8hgiclgON2GwXSjw/132","nickname":"cv0cv0","note":"","ucode":"93FF9277F03FD0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548519,"discussion_content":"除了 Java 都是真泛型吧?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643246911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358839,"discussion_content":"简单的说 带入JVM的是真泛型，擦除metadata是伪泛型。这一点经常拿来比较C#","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616060014,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21633,"user_name":"Shine","can_delete":false,"product_type":"c1","uid":1022568,"ip_address":"","ucode":"C8C617B87C63C7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9a/68/92caeed6.jpg","comment_is_top":false,"comment_ctime":1535202680,"is_pvip":false,"replies":[{"id":"7807","content":"字节码其实不难的。我会专门写一篇来介绍一下。","user_name":"作者回复","comment_id":21633,"uid":"1176688","ip_address":"","utype":1,"ctime":1535356914,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"23010039160","product_id":100010301,"comment_content":"每次看到示例代码的java字节码就犯懵，觉得很复杂，是不是有必要去了解下字节码","like_count":5,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422775,"discussion_content":"字节码其实不难的。我会专门写一篇来介绍一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535356914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21743,"user_name":"曲东方","can_delete":false,"product_type":"c1","uid":1177819,"ip_address":"","ucode":"6C3EA2F47A0B98","user_header":"https://static001.geekbang.org/account/avatar/00/11/f8/db/c4edf697.jpg","comment_is_top":false,"comment_ctime":1535292975,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18715162159","product_id":100010301,"comment_content":"var保存了泛型信息<br><br>var定义变量必须直接初始化，基于初始化的值做类型推导，javac编译期间的语法糖<br><br>所以不能声明函数的参数为var类型<br><br><br>foreach语法糖，对于实现了迭代器Iterable&lt;T&gt;接口的类型，使用迭代器方法；<br>foreach对于数组和变长参数的处理方式与上述略有不同，先求数组长度，再做类似while循环遍历<br>","like_count":4,"discussions":[{"author":{"id":1134288,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","nickname":"Ken张云忠","note":"","ucode":"D0BAC9FC17DE2B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":110890,"discussion_content":"请教下:var保存了泛型信息怎么得到的信息","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577762775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226403,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1592063553,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10181998145","product_id":100010301,"comment_content":"java设计也是分内核与外延的设计<br>内核是整个加载器，执行器，编绎器，堆栈这些是相对稳定的<br>而语法糖是为了提升开发效率，相当于是多变的外延。<br>本质上这个语法糖是由编绎器帮开发人员做了转换的工作。<br>泛型在编绎器转换后会变成字节码层页的object，或者如果泛型有继承某个特定父类则在字节码层面就是这个限定类，最终在存取的时候会做强制转换。","like_count":2},{"had_liked":false,"id":49930,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1544791256,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"10134725848","product_id":100010301,"comment_content":"invokestatic Double.valueOf:(D)Ljava&#47;lang&#47;Double;<br>想请教一下老师这个字节码中的(D)和java前的L的作用是标记什么, 查了半天都没查到, 希望老师回答一下.","like_count":2,"discussions":[{"author":{"id":1171698,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e0/f2/e73b3269.jpg","nickname":"一叶知秋","note":"","ucode":"7193850DF34312","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7041,"discussion_content":"D代表double，L代表对象，在深入理解java虚拟机第六章可以找到","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1567317409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1178313,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fa/c9/c75664e9.jpg","nickname":"二两豆腐","note":"","ucode":"24E16A3C2AD28C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312756,"discussion_content":"小括号中代表的是返回值，D代表的是double类型，意思是说这个方法的返回值手机double类型的，L代表是一个引用对象类型，具体是什么对象，由L后面的字符串所表示，包含；\n这一行读下来就是调用一个静态方法，入参接受一个java.lang.Double类型的参数，方法名是valueOf","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602810894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1451728,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKDfy7icjzBBUwQDA3ovYUqSX4gT27UryDic79Dj9lrbRibt8DCbz8xb4EvSMmACiaI2xkIdvgwByW1GQ/132","nickname":"Geek_3a0800","note":"","ucode":"F4F5C8E1FD917F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348152,"discussion_content":"建议补补字节码基础","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612442394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21510,"user_name":"任鹏斌","can_delete":false,"product_type":"c1","uid":1104086,"ip_address":"","ucode":"34319B05EA6E74","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/d6/47da34bf.jpg","comment_is_top":false,"comment_ctime":1535124071,"is_pvip":false,"replies":[{"id":"7817","content":"Java新版本的语法糖并不多，我印象中10也只有var","user_name":"作者回复","comment_id":21510,"uid":"1176688","ip_address":"","utype":1,"ctime":1535357906,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"10125058663","product_id":100010301,"comment_content":"有点落后刚升级到jdk8对10还一无所知","like_count":2,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422712,"discussion_content":"Java新版本的语法糖并不多，我印象中10也只有var","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535357906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21431,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1535077688,"is_pvip":true,"replies":[{"id":"7620","content":"对的","user_name":"作者回复","comment_id":21431,"uid":"1176688","ip_address":"","utype":1,"ctime":1535116992,"user_name_real":"郑雨迪"}],"discussion_count":2,"race_medal":0,"score":"10125012280","product_id":100010301,"comment_content":"从实现上说可以设计一个int类型的list，而jdk中arrayList是object类型，这样做是不是为了通用型考虑呢？","like_count":2,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422671,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535116992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1245468,"avatar":"https://static001.geekbang.org/account/avatar/00/13/01/1c/d638d46e.jpg","nickname":"宋世通","note":"","ucode":"C7AA3F0E6930F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390344,"discussion_content":"Android提供了一个SparseArray来避免key的装箱拆箱，这样就节省内存了\nhttps://blog.csdn.net/u010687392/article/details/47809295","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629791644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141787,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1571224483,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5866191779","product_id":100010301,"comment_content":"看老师的课，最好就在电脑边，边看边实践。","like_count":1},{"had_liked":false,"id":141785,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1571224212,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5866191508","product_id":100010301,"comment_content":"赞，这节课的内容即便全忘了，也完全可以自己跑自己命令，看下字节码文件，知道到底是怎么回事。这就是授人以渔，谢谢老师。","like_count":1},{"had_liked":false,"id":355925,"user_name":"angel😇txy🤓","can_delete":false,"product_type":"c1","uid":1133702,"ip_address":"上海","ucode":"C0AEE0D8BAF7ED","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/86/3be94807.jpg","comment_is_top":false,"comment_ctime":1661853723,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1661853723","product_id":100010301,"comment_content":"ava 程序中的泛型信息会被擦除。具体来说，Java 编译器将选取该泛型所能指代的所有类中层次最高的那个，作为替换泛型的具体类，具体来说：<br>若泛型类型没有指定具体类型，用Object作为原始类型；<br>若有限定类型&lt; T exnteds XClass &gt;，使用XClass作为原始类型；<br>若有多个限定&lt; T exnteds XClass1 &amp; XClass2 &gt;，使用第一个边界类型XClass1作为原始类型；","like_count":0},{"had_liked":false,"id":237909,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1596002756,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1596002756","product_id":100010301,"comment_content":"var应该是保留了泛型，支不支持自动不太确定，但是那个后面的代码add添加的操作是不行的。","like_count":0,"discussions":[{"author":{"id":1350050,"avatar":"https://static001.geekbang.org/account/avatar/00/14/99/a2/fcb7fd6c.jpg","nickname":"远古存在的神","note":"","ucode":"F695B490C6CC41","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382062,"discussion_content":"可以啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625394228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203872,"user_name":"有米","can_delete":false,"product_type":"c1","uid":1005042,"ip_address":"","ucode":"C9A10B7A67BC12","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/f2/ba68d931.jpg","comment_is_top":false,"comment_ctime":1586279220,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586279220","product_id":100010301,"comment_content":"感觉java越来越不严谨了。。。还是喜欢 int i=0; 不要来var i=0;。。。。。","like_count":0},{"had_liked":false,"id":180609,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1582349583,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582349583","product_id":100010301,"comment_content":"课后题可以编译成功，看了下字节码，var声明的list，add的入参是Object。","like_count":0},{"had_liked":false,"id":133084,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1568353235,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568353235","product_id":100010301,"comment_content":"大部分语法糖其实都是编译器为我们提供了一些便利，这些代码在编译后会变成一些基础代码<br>自动拆装箱：编译器会插入诸如Integer.valueof方法<br>泛型：编译器会根据继承关系做类型擦除","like_count":0},{"had_liked":false,"id":96864,"user_name":"Zhgdbut","can_delete":false,"product_type":"c1","uid":1462200,"ip_address":"","ucode":"ECE6E557666880","user_header":"https://static001.geekbang.org/account/avatar/00/16/4f/b8/35cdada6.jpg","comment_is_top":false,"comment_ctime":1558525367,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"1558525367","product_id":100010301,"comment_content":"老师你好，我遇到了一个这种问题<br>Long a = null;<br>Long rs = 1=1 ? a: 0L;<br>报了空指针异常的错误，1=1只是一个条件，表明rs一定等于a!<br>请问是咋回事呀？我该怎么修改？","like_count":0,"discussions":[{"author":{"id":1462645,"avatar":"https://static001.geekbang.org/account/avatar/00/16/51/75/6997e91a.jpg","nickname":"Sean 🍓","note":"","ucode":"652F4C2A8D93A1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72720,"discussion_content":"三元表达式里那一行真正编译后:  Long b = Long.valueOf(a.longValue());\n由于编译器优化，1==1为true，所以直接这样赋值了。\n这里将a先拆箱后装箱，拆箱的时候调用a.longValue时报空指针异常。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1575520055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1195426,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3d/a2/5ef5e2af.jpg","nickname":"iceWang","note":"","ucode":"F1FE72EBE89DFF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307,"discussion_content":"1==1","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1561441397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1032494,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXHhJzbAYJoupWT2G7NLWKFuQicFicUh1QjsqGpgq5S9kLrvcoR4s2YiaB5XOicksheJFouXd6oL9vHQ/132","nickname":"卍风","note":"","ucode":"ECF9BF0267FF78","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6863,"discussion_content":"应该装箱的时候a是null所以，Long.valueOf（null）报错了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567148120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3017215,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/09/ff/cedb2a8d.jpg","nickname":"南方。","note":"","ucode":"DE799EC5D5F891","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578330,"discussion_content":"如果想要不报NPE就将：后面的数据类型也设置为包装类型，这样就不会发生拆箱操作了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656661171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1216441,"avatar":"https://static001.geekbang.org/account/avatar/00/12/8f/b9/ee25c565.jpg","nickname":"麦兜的柏拉图","note":"","ucode":"D54BB17F2A0FE5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368658,"discussion_content":"就是三楼回答里描述的，把a赋值给rs的过程中真正的逻辑是先调用a.longValue自动拆箱，再调用Long.valueOf自动装箱，然后自动拆箱时发生NPE了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618794905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014680,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/98/8f1aecf4.jpg","nickname":"楼下小黑哥","note":"","ucode":"453B099B0EE52E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268359,"discussion_content":"参考阿里最新版的java开发手册","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589764992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1447739,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eou1BMETumU21ZI4yiaLenOMSibzkAgkw944npIpsJRicmdicxlVQcgibyoQ00rdGk9Htp1j0dM5CP2Fibw/132","nickname":"寥若晨星","note":"","ucode":"2E87E43687DE72","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":262702,"discussion_content":"1=1？是==吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589121601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21706,"user_name":"403","can_delete":false,"product_type":"c1","uid":1001867,"ip_address":"","ucode":"D9360256DFEF5D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/8b/3596a3e2.jpg","comment_is_top":false,"comment_ctime":1535261191,"is_pvip":false,"replies":[{"id":"7809","content":";)","user_name":"作者回复","comment_id":21706,"uid":"1176688","ip_address":"","utype":1,"ctime":1535357027,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"1535261191","product_id":100010301,"comment_content":"相比来看，c#的泛型是真泛型","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422821,"discussion_content":";)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535357027,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21618,"user_name":"herome","can_delete":false,"product_type":"c1","uid":1097654,"ip_address":"","ucode":"F00A539371C206","user_header":"https://static001.geekbang.org/account/avatar/00/10/bf/b6/ee3b4ef7.jpg","comment_is_top":false,"comment_ctime":1535196876,"is_pvip":true,"replies":[{"id":"7808","content":"这一篇貌似没啥地方能够画图的吧？请问你具体对哪一块有疑问？","user_name":"作者回复","comment_id":21618,"uid":"1176688","ip_address":"","utype":1,"ctime":1535356995,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"1535196876","product_id":100010301,"comment_content":"求老师画图啊 ","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422768,"discussion_content":"这一篇貌似没啥地方能够画图的吧？请问你具体对哪一块有疑问？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535356995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21575,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1535173874,"is_pvip":false,"replies":[{"id":"7814","content":"JDK认为用户不需要缓存小于-128的整数。这当然有可能是错误的。","user_name":"作者回复","comment_id":21575,"uid":"1176688","ip_address":"","utype":1,"ctime":1535357575,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"1535173874","product_id":100010301,"comment_content":"奇怪的是，Java 并不支持对 IntegerCache.low 的更改，也就是说，对于小于 -128 的整数，我们无法直接使用由 Java 核心类库所缓存的 Integer 对象。<br>这个奇怪的现象到底是为啥呢？","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422750,"discussion_content":"JDK认为用户不需要缓存小于-128的整数。这当然有可能是错误的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535357575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}