{"id":508841,"title":"16｜DI Container（4）：如何实现对循环依赖的处理？","content":"<p>你好，我是徐昊，今天我们继续使用TDD的方式实现注入依赖容器。</p><h2>回顾代码与任务列表</h2><p>到目前为止，我们的代码是这样的：</p><pre><code>package geektime.tdd.di;\n    \nimport jakarta.inject.Inject;\nimport jakarta.inject.Provider;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.stream.Collectors;\nimport static java.util.Arrays.stream;\n   \npublic class Context {\n    private Map&lt;Class&lt;?&gt;, Provider&lt;?&gt;&gt; providers = new HashMap&lt;&gt;();\n    \n    public &lt;Type&gt; void bind(Class&lt;Type&gt; type, Type instance) {\n        providers.put(type, (Provider&lt;Type&gt;) () -&gt; instance);\n    }\n    \n    public &lt;Type, Implementation extends Type&gt;\n    void bind(Class&lt;Type&gt; type, Class&lt;Implementation&gt; implementation) {\n        Constructor&lt;Implementation&gt; injectConstructor = getInjectConstructor(implementation);\n        providers.put(type, (Provider&lt;Type&gt;) () -&gt; {\n            try {\n                Object[] dependencies = stream(injectConstructor.getParameters())\n                        .map(p -&gt; get(p.getType()).orElseThrow(DependencyNotFoundException::new))\n                        .toArray(Object[]::new);\n                return injectConstructor.newInstance(dependencies);\n            } catch (InvocationTargetException | InstantiationException | IllegalAccessException e) {\n                throw new RuntimeException(e);\n            }\n        });\n    }\n    \n    private &lt;Type&gt; Constructor&lt;Type&gt; getInjectConstructor(Class&lt;Type&gt; implementation) {\n        List&lt;Constructor&lt;?&gt;&gt; injectConstructors = stream(implementation.getConstructors())\n                .filter(c -&gt; c.isAnnotationPresent(Inject.class)).collect(Collectors.toList());\n        if (injectConstructors.size() &gt; 1) throw new IllegalComponentException();\n        return (Constructor&lt;Type&gt;) injectConstructors.stream().findFirst().orElseGet(() -&gt; {\n                    try {\n                        return implementation.getConstructor();\n                    } catch (NoSuchMethodException e) {\n                        throw new IllegalComponentException();\n                    }\n                });\n    }\n    \n    public &lt;Type&gt; Optional&lt;Type&gt; get(Class&lt;Type&gt; type) {\n        return Optional.ofNullable(providers.get(type)).map(provider -&gt; (Type)provider.get());\n    }\n}\n</code></pre><p>任务列表状态为:</p><p><img src=\"https://static001.geekbang.org/resource/image/3d/f1/3dbd7ede7cc98a5ea9d1bf275b362ff1.jpg?wh=6259x10979\" alt=\"\"></p><h2>视频演示</h2><p>让我们进入今天的部分：</p><p><video poster=\"https://media001.geekbang.org/d5f0892de62b4c9993edc196c0aee8cb/snapshots/364aac70d641442584cf4d97729e4667-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/39aa466b-1802c83e494-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/86a4288806f0474da0f64569ff80036c/be83268c5cba48d7bc043a539ed710d4-8d51b14904ff54167890fd1107596e55-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><h2>思考题</h2><p>为了我们更好的交流与互动，从这节课开始，思考题目除了固定的技术问题外，我还会设置一道较为轻松的题目，供你选择与回答。</p><ol>\n<li>对于依赖的检测，目前代码的实现是在实际创建组件对象时进行的。如果改为预先检查，我们要做哪些改变呢？</li>\n<li>在今天这节课中，最让你有收获的地方是什么？为什么？</li>\n</ol><p>欢迎把你的想法分享在留言区，也欢迎把你的项目代码的链接分享出来。相信经过你的思考与实操，学习效果会更好！</p><!-- [[[read_end]]] -->","neighbors":{"left":{"article_title":"15｜DI Container（3）：如何重构已有的代码？","id":502586},"right":{"article_title":"17｜DI Container（5）：API接口该怎么设计？","id":508843}},"comments":[{"had_liked":false,"id":358134,"user_name":"努力努力再努力","can_delete":false,"product_type":"c1","uid":1493907,"ip_address":"广东","ucode":"0C6EEA28FCE8C7","user_header":"https://static001.geekbang.org/account/avatar/00/16/cb/93/4adea49a.jpg","comment_is_top":false,"comment_ctime":1663927280,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1663927280","product_id":100109401,"comment_content":"问题1：对于依赖的检测，目前代码的实现是在实际创建组件对象时进行的。如果改为预先检查，我们要做哪些改变呢？<br>如果改为在 bind 处检查，可以维护一个哈希表，key是componentType， value 是构造函数参数的集合。每绑定一个组件的时候，获取构造函数的参数到哈希表中查询，如果存在，判断对应的 value 中是否包含 component，包含则可以认为 存在循环依赖，抛出异常。<br><br><br>问题2：在今天这节课中，最让你有收获的地方是什么？为什么？<br>最有收获的是老师在编码过程中，将突发想到的问题，转化为测试用例记录在案。这让我想到一些平时在工作中，前一个月修复的Bug，基本都是在生产代码上直接进行修改的，有时候可能仅仅是加了一个 if 分支的判断，然而个把月后突然看到这个分支，完全想不起来当初为什么会这样加。如果有测试用例可以回溯，那么也方便后续的问题跟踪","like_count":0},{"had_liked":false,"id":354452,"user_name":"蝴蝶","can_delete":false,"product_type":"c1","uid":1193167,"ip_address":"广东","ucode":"8019924D99182F","user_header":"https://static001.geekbang.org/account/avatar/00/12/34/cf/0a316b48.jpg","comment_is_top":false,"comment_ctime":1660404517,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1660404517","product_id":100109401,"comment_content":"问题 1：增加类似 builder 模式里面 build 的方法来检查依赖。","like_count":0},{"had_liked":false,"id":347730,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1510910,"ip_address":"","ucode":"FC7849B6F0FA9F","user_header":"https://static001.geekbang.org/account/avatar/00/17/0d/fe/4e5ba578.jpg","comment_is_top":false,"comment_ctime":1654355703,"is_pvip":false,"replies":[{"id":"126761","content":"分出多线程的任务 写测试","user_name":"作者回复","comment_id":347730,"uid":"2537798","ip_address":"","utype":1,"ctime":1654405993,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1654355703","product_id":100109401,"comment_content":"老师你好我有个问题：<br>实现检查是否循环依赖的代码，如果是在多线程的情况下是不是会出现bug。如果两个线程同时get一个component.class,其中一个不就会抛出异常？<br>这个问题的衍生就是：<br>在实际业务场景中，TDD如何自然的使用任务列表以及对应的testcase，推导出有关多线程的需求实现代码？","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574848,"discussion_content":"分出多线程的任务 写测试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654405993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347421,"user_name":"Geek_874b6f","can_delete":false,"product_type":"c1","uid":1325323,"ip_address":"","ucode":"A7A9DE032B299C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqr2x1iciaqBW16fKY8geL5j3MrSKckmNyvaYbiagT5z5iazO20UVhHyof9gPic880R0wgJQyeYTQQiaZ3w/132","comment_is_top":false,"comment_ctime":1654005251,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1654005251","product_id":100109401,"comment_content":"Idea 支持将匿名类转化内部类的","like_count":0},{"had_liked":false,"id":344218,"user_name":"keep_curiosity","can_delete":false,"product_type":"c1","uid":1246273,"ip_address":"","ucode":"794DC1D3FB9214","user_header":"https://static001.geekbang.org/account/avatar/00/13/04/41/082e2706.jpg","comment_is_top":false,"comment_ctime":1651376364,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651376364","product_id":100109401,"comment_content":"使用Set存放循环依赖的组件不能保证组件依赖的顺序吧？如何构造有效的测试验证顺序呢？<br>我的跟练：https:&#47;&#47;github.com&#47;codingthought&#47;TDD-DI","like_count":0},{"had_liked":false,"id":343834,"user_name":"枫中的刀剑","can_delete":false,"product_type":"c1","uid":1322387,"ip_address":"","ucode":"4B086F538184AA","user_header":"https://static001.geekbang.org/account/avatar/00/14/2d/93/0f1cbf44.jpg","comment_is_top":false,"comment_ctime":1651072569,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651072569","product_id":100109401,"comment_content":"解决循环依赖的思路确实妙啊，后来查看guice的源码里发现也是这样判断循环依赖的。","like_count":0},{"had_liked":false,"id":343541,"user_name":"ACE丶8","can_delete":false,"product_type":"c1","uid":1119725,"ip_address":"","ucode":"BEF70158320D84","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/ed/db793197.jpg","comment_is_top":false,"comment_ctime":1650898142,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650898142","product_id":100109401,"comment_content":"收获：在实现循环依赖，自己的思路是将依赖信息，在构造的过程中不断传递，当构造的时候发现，构造信息中已经出现过该类，就抛出异常，最终没有解决。老师的思路是通过一个代理类，携带上构造信息，让循环依赖的检查变得更加简单，学习了。","like_count":0},{"had_liked":false,"id":343284,"user_name":"xiaobang","can_delete":false,"product_type":"c1","uid":1157508,"ip_address":"","ucode":"1735BDCFD61655","user_header":"https://static001.geekbang.org/account/avatar/00/11/a9/84/c87b51ce.jpg","comment_is_top":false,"comment_ctime":1650763052,"is_pvip":false,"replies":[{"id":"125351","content":"临接表 还要配合算法","user_name":"作者回复","comment_id":343284,"uid":"2537798","ip_address":"","utype":1,"ctime":1650767007,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1650763052","product_id":100109401,"comment_content":"预先检查的实现思路，维护一张Map，其中Key为Component，value为依赖该Component的Component集合。bind时检查当前Component依赖的Component不在依赖当前Component的集合里，同时维护该Map","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566815,"discussion_content":"临接表 还要配合算法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650767007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342716,"user_name":"临风","can_delete":false,"product_type":"c1","uid":1145430,"ip_address":"","ucode":"59A7F3DDD94D76","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/56/29877cb9.jpg","comment_is_top":false,"comment_ctime":1650430238,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650430238","product_id":100109401,"comment_content":"改为预先检查，我认为就要一开始就把实例创建好放入容器中去。这就导致你必须知道依赖的实例要怎么创建。<br>我想到的方式就是用spring的方式，1.通过@Component来指明实现类；2.通过xml或者@Configuration来指明如何初始化。<br>还想到一个方法就是bind必须按照顺序初始化，无依赖的先初始化，类似有向图，没有出度的节点先初始化。","like_count":0},{"had_liked":false,"id":342660,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1650388685,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650388685","product_id":100109401,"comment_content":"最大收获：测试可以及时发现 Bug，将排查范围缩减到最小，虽然不停回放视频比对代码很吃力，但还是能看到希望。<br>原因：如果没有测试的代码，以下两个小细节导致的 Bug，找一天也不一定能发现！<br><br>跟着视频敲代码，卡住2次，都来自 public T get() 方法：<br>1、constructing = true; 的位置比老师的靠后（我天真的想法：靠前靠后关系大吗？赋值就行）<br>2、try 的作用域比老师的小（我天真的想法：要尽量将 try 的作用域减小，专注真正需要捕获异常的部分；提升性能）<br><br>可以使用 HashSet&lt;Class&lt;?&gt;&gt; classes = Sets.newHashSet(exception.getComponents());<br>需要导入依赖：implementation &#39;com.google.guava:guava:31.1-jre&#39;","like_count":0}]}