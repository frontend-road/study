{"id":8471,"title":"第13讲 | 谈谈接口和抽象类有什么区别？","content":"<p>Java是非常典型的面向对象语言，曾经有一段时间，程序员整天把面向对象、设计模式挂在嘴边。虽然如今大家对这方面已经不再那么狂热，但是不可否认，掌握面向对象设计原则和技巧，是保证高质量代码的基础之一。</p>\n<p>面向对象提供的基本机制，对于提高开发、沟通等各方面效率至关重要。考察面向对象也是面试中的常见一环，下面我来聊聊<strong>面向对象设计基础</strong>。</p>\n<p>今天我要问你的问题是，<span class=\"orange\">谈谈接口和抽象类有什么区别？</span></p>\n<h2>典型回答</h2>\n<p>接口和抽象类是Java面向对象设计的两个基础机制。</p>\n<p>接口是对行为的抽象，它是抽象方法的集合，利用接口可以达到API定义和实现分离的目的。接口，不能实例化；不能包含任何非常量成员，任何field都是隐含着public static final的意义；同时，没有非静态方法实现，也就是说要么是抽象方法，要么是静态方法。Java标准类库中，定义了非常多的接口，比如java.util.List。</p>\n<p>抽象类是不能实例化的类，用abstract关键字修饰class，其目的主要是代码重用。除了不能实例化，形式上和一般的Java类并没有太大区别，可以有一个或者多个抽象方法，也可以没有抽象方法。抽象类大多用于抽取相关Java类的共用方法实现或者是共同成员变量，然后通过继承的方式达到代码复用的目的。Java标准库中，比如collection框架，很多通用部分就被抽取成为抽象类，例如java.util.AbstractList。</p>\n<!-- [[[read_end]]] -->\n<p>Java类实现interface使用implements关键词，继承abstract class则是使用extends关键词，我们可以参考Java标准库中的ArrayList。</p>\n<pre><code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;\n        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable\n{\n//...\n}\n</code></pre>\n<h2>考点分析</h2>\n<p>这是个非常高频的Java面向对象基础问题，看起来非常简单的问题，如果面试官稍微深入一些，你会发现很多有意思的地方，可以从不同角度全面地考察你对基本机制的理解和掌握。比如:</p>\n<ul>\n<li>\n<p>对于Java的基本元素的语法是否理解准确。能否定义出语法基本正确的接口、抽象类或者相关继承实现，涉及重载（Overload）、重写（Override）更是有各种不同的题目。</p>\n</li>\n<li>\n<p>在软件设计开发中妥善地使用接口和抽象类。你至少知道典型应用场景，掌握基础类库重要接口的使用；掌握设计方法，能够在review代码的时候看出明显的不利于未来维护的设计。</p>\n</li>\n<li>\n<p>掌握Java语言特性演进。现在非常多的框架已经是基于Java 8，并逐渐支持更新版本，掌握相关语法，理解设计目的是很有必要的。</p>\n</li>\n</ul>\n<h2>知识扩展</h2>\n<p>我会从接口、抽象类的一些实践，以及语言变化方面去阐述一些扩展知识点。</p>\n<p>Java相比于其他面向对象语言，如C++，设计上有一些基本区别，比如<strong>Java不支持多继承</strong>。这种限制，在规范了代码实现的同时，也产生了一些局限性，影响着程序设计结构。Java类可以实现多个接口，因为接口是抽象方法的集合，所以这是声明性的，但不能通过扩展多个抽象类来重用逻辑。</p>\n<p>在一些情况下存在特定场景，需要抽象出与具体实现、实例化无关的通用逻辑，或者纯调用关系的逻辑，但是使用传统的抽象类会陷入到单继承的窘境。以往常见的做法是，实现由静态方法组成的工具类（Utils），比如java.util.Collections。</p>\n<p>设想，为接口添加任何抽象方法，相应的所有实现了这个接口的类，也必须实现新增方法，否则会出现编译错误。对于抽象类，如果我们添加非抽象方法，其子类只会享受到能力扩展，而不用担心编译出问题。</p>\n<p>接口的职责也不仅仅限于抽象方法的集合，其实有各种不同的实践。有一类没有任何方法的接口，通常叫作Marker Interface，顾名思义，它的目的就是为了声明某些东西，比如我们熟知的Cloneable、Serializable等。这种用法，也存在于业界其他的Java产品代码中。</p>\n<p>从表面看，这似乎和Annotation异曲同工，也确实如此，它的好处是简单直接。对于Annotation，因为可以指定参数和值，在表达能力上要更强大一些，所以更多人选择使用Annotation。</p>\n<p>Java 8增加了函数式编程的支持，所以又增加了一类定义，即所谓functional interface，简单说就是只有一个抽象方法的接口，通常建议使用@FunctionalInterface Annotation来标记。Lambda表达式本身可以看作是一类functional interface，某种程度上这和面向对象可以算是两码事。我们熟知的Runnable、Callable之类，都是functional interface，这里不再多介绍了，有兴趣你可以参考：<a href=\"https://www.oreilly.com/learning/java-8-functional-interfaces\">https://www.oreilly.com/learning/java-8-functional-interfaces</a> 。</p>\n<p>还有一点可能让人感到意外，严格说，<strong>Java 8以后，接口也是可以有方法实现的！</strong></p>\n<p>从Java 8开始，interface增加了对default method的支持。Java 9以后，甚至可以定义private default method。Default method提供了一种二进制兼容的扩展已有接口的办法。比如，我们熟知的java.util.Collection，它是collection体系的root interface，在Java 8中添加了一系列default method，主要是增加Lambda、Stream相关的功能。我在专栏前面提到的类似Collections之类的工具类，很多方法都适合作为default method实现在基础接口里面。</p>\n<p>你可以参考下面代码片段：</p>\n<pre><code>public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; {\n     /**\n     * Returns a sequential Stream with this collection as its source \n     * ...\n     **/\n     default Stream&lt;E&gt; stream() {\n         return StreamSupport.stream(spliterator(), false);\n     }\n  }\n</code></pre>\n<p><strong>面向对象设计</strong></p>\n<p>谈到面向对象，很多人就会想起设计模式，那些是非常经典的问题和设计方法的总结。我今天来夯实一下基础，先来聊聊面向对象设计的基本方面。</p>\n<p>我们一定要清楚面向对象的基本要素：封装、继承、多态。</p>\n<p><strong>封装</strong>的目的是隐藏事务内部的实现细节，以便提高安全性和简化编程。封装提供了合理的边界，避免外部调用者接触到内部的细节。我们在日常开发中，因为无意间暴露了细节导致的难缠bug太多了，比如在多线程环境暴露内部状态，导致的并发修改问题。从另外一个角度看，封装这种隐藏，也提供了简化的界面，避免太多无意义的细节浪费调用者的精力。</p>\n<p><strong>继承</strong>是代码复用的基础机制，类似于我们对于马、白马、黑马的归纳总结。但要注意，继承可以看作是非常紧耦合的一种关系，父类代码修改，子类行为也会变动。在实践中，过度滥用继承，可能会起到反效果。</p>\n<p><strong>多态</strong>，你可能立即会想到重写（override）和重载（overload）、向上转型。简单说，重写是父子类中相同名字和参数的方法，不同的实现；重载则是相同名字的方法，但是不同的参数，本质上这些方法签名是不一样的，为了更好说明，请参考下面的样例代码：</p>\n<pre><code>public int doSomething() {\n    return 0;\n}\n// 输入参数不同，意味着方法签名不同，重载的体现\npublic int doSomething(List&lt;String&gt; strs) {\n    return 0;\n}\n// return类型不一样，编译不能通过\npublic short doSomething() {\n    return 0;\n}\n\n</code></pre>\n<p>这里你可以思考一个小问题，方法名称和参数一致，但是返回值不同，这种情况在Java代码中算是有效的重载吗？ 答案是不是的，编译都会出错的。</p>\n<p>进行面向对象编程，掌握基本的设计原则是必须的，我今天介绍最通用的部分，也就是所谓的S.O.L.I.D原则。</p>\n<ul>\n<li>\n<p>单一职责（Single Responsibility），类或者对象最好是只有单一职责，在程序设计中如果发现某个类承担着多种义务，可以考虑进行拆分。</p>\n</li>\n<li>\n<p>开关原则（Open-Close, Open for extension, close for modification），设计要对扩展开放，对修改关闭。换句话说，程序设计应保证平滑的扩展性，尽量避免因为新增同类功能而修改已有实现，这样可以少产出些回归（regression）问题。</p>\n</li>\n<li>\n<p>里氏替换（Liskov Substitution），这是面向对象的基本要素之一，进行继承关系抽象时，凡是可以用父类或者基类的地方，都可以用子类替换。</p>\n</li>\n<li>\n<p>接口分离（Interface Segregation），我们在进行类和接口设计时，如果在一个接口里定义了太多方法，其子类很可能面临两难，就是只有部分方法对它是有意义的，这就破坏了程序的内聚性。<br />\n对于这种情况，可以通过拆分成功能单一的多个接口，将行为进行解耦。在未来维护中，如果某个接口设计有变，不会对使用其他接口的子类构成影响。</p>\n</li>\n<li>\n<p>依赖反转（Dependency Inversion），实体应该依赖于抽象而不是实现。也就是说高层次模块，不应该依赖于低层次模块，而是应该基于抽象。实践这一原则是保证产品代码之间适当耦合度的法宝。</p>\n</li>\n</ul>\n<p><strong>OOP原则实践中的取舍</strong></p>\n<p>值得注意的是，现代语言的发展，很多时候并不是完全遵守前面的原则的，比如，Java 10中引入了本地方法类型推断和var类型。按照，里氏替换原则，我们通常这样定义变量：</p>\n<pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();\n</code></pre>\n<p>如果使用var类型，可以简化为</p>\n<pre><code>var list = new ArrayList&lt;String&gt;();\n\n</code></pre>\n<p>但是，list实际会被推断为“ArrayList &lt; String &gt;”</p>\n<pre><code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();\n</code></pre>\n<p>理论上，这种语法上的便利，其实是增强了程序对实现的依赖，但是微小的类型泄漏却带来了书写的便利和代码可读性的提高，所以，实践中我们还是要按照得失利弊进行选择，而不是一味得遵循原则。</p>\n<p><strong>OOP原则在面试题目中的分析</strong></p>\n<p>我在以往面试中发现，即使是有多年编程经验的工程师，也还没有真正掌握面向对象设计的基本的原则，如开关原则（Open-Close）。看看下面这段代码，改编自朋友圈盛传的某伟大公司产品代码，你觉得可以利用面向对象设计原则如何改进？</p>\n<pre><code>public class VIPCenter {\n  void serviceVIP(T extend User user&gt;) {\n     if (user instanceof SlumDogVIP) {\n        // 穷X VIP，活动抢的那种\n        // do somthing\n      } else if(user instanceof RealVIP) {\n        // do somthing\n      }\n      // ...\n  }\n</code></pre>\n<p>这段代码的一个问题是，业务逻辑集中在一起，当出现新的用户类型时，比如，大数据发现了我们是肥羊，需要去收获一下， 这就需要直接去修改服务方法代码实现，这可能会意外影响不相关的某个用户类型逻辑。</p>\n<p>利用开关原则，我们可以尝试改造为下面的代码：</p>\n<pre><code>public class VIPCenter {\n   private Map&lt;User.TYPE, ServiceProvider&gt; providers;\n   void serviceVIP(T extend User user） {\n      providers.get(user.getType()).service(user);\n   }\n }\n interface ServiceProvider{\n   void service(T extend User user) ;\n }\n class SlumDogVIPServiceProvider implements ServiceProvider{\n   void service(T extend User user){\n     // do somthing\n   }\n }\n class RealVIPServiceProvider implements ServiceProvider{\n   void service(T extend User user) {\n     // do something\n   }\n } \n\n</code></pre>\n<p>上面的示例，将不同对象分类的服务方法进行抽象，把业务逻辑的紧耦合关系拆开，实现代码的隔离保证了方便的扩展。</p>\n<p>今天我对Java面向对象技术进行了梳理，对比了抽象类和接口，分析了Java语言在接口层面的演进和相应程序设计实现，最后回顾并实践了面向对象设计的基本原则，希望对你有所帮助。</p>\n<h2>一课一练</h2>\n<p>关于接口和抽象类的区别，你做到心中有数了吗？给你布置一个思考题，思考一下自己的产品代码，有没有什么地方违反了基本设计原则？那些一改就崩的代码，是否遵循了开关原则？</p>\n<p>请你在留言区写写你对这个问题的思考，我会选出经过认真思考的留言，送给你一份学习鼓励金，欢迎你与我一起讨论。</p>\n<p>你的朋友是不是也在准备面试呢？你可以“请朋友读”，把今天的题目分享给好友，或许你能帮到他。</p>\n<p></p>\n","neighbors":{"left":{"article_title":"第12讲 | Java有几种文件拷贝方式？哪一种最高效？","id":8393},"right":{"article_title":"第14讲 | 谈谈你知道的设计模式？","id":8624}},"comments":[{"had_liked":false,"id":11144,"user_name":"公号-技术夜未眠","can_delete":false,"product_type":"c1","uid":1013683,"ip_address":"","ucode":"83825B57CBD952","user_header":"https://static001.geekbang.org/account/avatar/00/0f/77/b3/991f3f9b.jpg","comment_is_top":false,"comment_ctime":1527899535,"is_pvip":true,"discussion_count":4,"race_medal":0,"score":"555578680719","product_id":100006701,"comment_content":"\t接口vs抽象类vs类<br><br>1\t支持多重继承：接口支持；抽象类不支持；类不支持；<br>\t2\t支持抽象函数：接口语义上支持；抽象类支持；类不支持；<br>\t3\t允许函数实现：接口不允许；抽象类支持；类允许；<br>\t4\t允许实例化：接口不允许；抽象类不允许；类允许；<br>\t5\t允许部分函数实现：接口不允许；抽象类允许；类不允许。<br>\t6\t定义的内容：接口中只能包括public函数以及public static final常量；抽象类与类均无任何限制。<br>\t7\t使用时机：当想要支持多重继承，或是为了定义一种类型请使用接口；当打算提供带有部分实现的“模板”类，而将一些功能需要延迟实现请使用抽象类；当你打算提供完整的具体实现请使用类。<br><br>在实际项目开发过程，一方面是业务需求频繁，需要满足开闭原则，也就是小到一个模块，大到一个架构都需要有好的可扩展性；另外一方面软件往往是团队协同开发的过程；由于团队成员水平参差不齐，这方面的坑不少。可以通过前期做好设计评审、code review等手段去提升代码质量。","like_count":130,"discussions":[{"author":{"id":1349528,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoViaN0hP07cXOl7vOIvHPu7DZ3wxHBz4iaLVEqG1TFfiagm1wUaiczbCyicwib7oDWw0vD4cXg9eZ0Okqg/132","nickname":"李湘河","note":"","ucode":"DB078B5DAAE82E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":175749,"discussion_content":"文中已经说了，java1.8中可以有默认的函数实现","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1581993248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1756181,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cc/15/35622b02.jpg","nickname":"Jason","note":"","ucode":"B2765DD1D90B0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":243627,"discussion_content":"现在接口和抽象类的区别已经不是不严谨了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587553849,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1583833,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/E3XKbwTv6WTssolgqZjZCkiazHgl2IdBYfwVfAcB7Ff3krsIQeBIBFQLQE1Kw91LFbl3lic2EzgdfNiciaYDlJlELA/132","nickname":"rike","note":"","ucode":"920AAD0BD9245C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":154761,"discussion_content":"“允许部分函数实现”是什么意思？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580180688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1583833,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/E3XKbwTv6WTssolgqZjZCkiazHgl2IdBYfwVfAcB7Ff3krsIQeBIBFQLQE1Kw91LFbl3lic2EzgdfNiciaYDlJlELA/132","nickname":"rike","note":"","ucode":"920AAD0BD9245C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216729,"discussion_content":"就是是否 允许 存有 abstract 修饰的方法，即 抽象方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585479984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":154761,"ip_address":""},"score":216729,"extra":""}]}]},{"had_liked":false,"id":11197,"user_name":"ωǒ→无悔","can_delete":false,"product_type":"c1","uid":1041068,"ip_address":"","ucode":"D37F876FD27D08","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e2/ac/1fb1ae06.jpg","comment_is_top":false,"comment_ctime":1527923658,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"250636026826","product_id":100006701,"comment_content":"最后一个例子就是策略模式加工厂模式","like_count":59,"discussions":[{"author":{"id":1943690,"avatar":"","nickname":"Geek_1b42a9","note":"","ucode":"79AF29855A53D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302556,"discussion_content":"就是策略模式，而不是加工厂模式","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1598953556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1230860,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c8/0c/0b4b7d93.jpg","nickname":"Asia","note":"","ucode":"215A7213BE221E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1943690,"avatar":"","nickname":"Geek_1b42a9","note":"","ucode":"79AF29855A53D9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581729,"discussion_content":"providers 那里提供 ServiceProvider 的 Map 应该是工厂模式的应用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658959085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":302556,"ip_address":""},"score":581729,"extra":""}]}]},{"had_liked":false,"id":11226,"user_name":"雷霹雳的爸爸","can_delete":false,"product_type":"c1","uid":1119490,"ip_address":"","ucode":"99BBA6D83DD11F","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/02/66f65388.jpg","comment_is_top":false,"comment_ctime":1527951801,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"130376970681","product_id":100006701,"comment_content":"问题本身就是典型热身题，但是SOLID则是一块试金石，曾经真的以为是试金石，很多老江湖好像都不知道有这串缩写这么回事，单一职责一说就都是顾名思义，纯粹的同义反复，用自己解释自己跟没说差不多吧，里氏替换背后的契约设计基本规则就更甭说了，实际项目中能不违反的几乎凤毛麟角吧，除非对接口调用后就真的没有约束条件，连spring这货都崇尚什么都封装成非受控异常，可见这个点到底有多么不受人待见，最小知识原则也基本上就是任人践踏吧，要不全变函数接口也就都没必要反复换个名字了吧，依赖倒置还好，好歹有IoC帮衬着，但是helper和各种静态的tool被无数人个性的反复的造，同时拿着依赖查找的实用性来堵DIP的嘴，也就剩OCP，再违反就太不像话了吧，没关系最大的伤害就是无视啊，帅气的蓝精灵命名法的那一串类，依次加个方法还是客气的，直接加个version字段，把if…else请回来，总之这玩意一说我就陷入到吐槽情绪，但问题吐的是solid的槽，还是吐的不把solid当回事的槽，我自己也分不清了，这个问题真的好让人纠结","like_count":31},{"had_liked":false,"id":11160,"user_name":"Woong","can_delete":false,"product_type":"c1","uid":1024978,"ip_address":"","ucode":"F009F3DFC4760A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a3/d2/69356194.jpg","comment_is_top":false,"comment_ctime":1527903847,"is_pvip":false,"replies":[{"id":"3587","content":"汗，手敲搞出这种低级错误，非常感谢指出","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527977237,"ip_address":"","comment_id":11160,"utype":1}],"discussion_count":1,"race_medal":0,"score":"108902086247","product_id":100006701,"comment_content":"class SlumDogVIPServiceProvider和RealVIPServiceProvider缺少implememts.","like_count":26,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418736,"discussion_content":"汗，手敲搞出这种低级错误，非常感谢指出","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527977237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12896,"user_name":"甲韭","can_delete":false,"product_type":"c1","uid":1052321,"ip_address":"","ucode":"2E998B8CB17F4E","user_header":"https://static001.geekbang.org/account/avatar/00/10/0e/a1/152a5de1.jpg","comment_is_top":false,"comment_ctime":1529117585,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"74543561617","product_id":100006701,"comment_content":"对象和抽象类是is a 的关系，对象和接口是 like this的关系。<br>从接口的命名一般是able ability后缀表示一种能力。<br>比如大家都是程序员，如果拥有了编写java程序的能力，就可以说你是一个java程序员，同时你还如果你还会编写Go，也可以说你是一个go程序员。<br>程序员就是对象实例，java编程能力就是接口，如果把java编程能力定义为抽象类，那还要实现Go能力接口才能同时具有两种语言能力的程序员，这表现的便是一个以java编程为主的程序员，同时具有编写go的能力。<br>如果把java能力和go能力都定义为接口，表现的是：这是一个程序员他同时具有编写java和Go的能力。","like_count":18},{"had_liked":false,"id":11147,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1527900362,"is_pvip":false,"replies":[{"id":"3589","content":"听说过电信代码里有26个if-else……然后还有俩是重复的，少的时候无所谓，多了就是坑","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527977478,"ip_address":"","comment_id":11147,"utype":1}],"discussion_count":2,"race_medal":0,"score":"74542344394","product_id":100006701,"comment_content":"hi，老师早上好。我是一家游戏公司的程序员，由于项目非常紧，所以很多技术写的代码，都非常乱。 我们的战斗系统中，之前的开发模式是在战斗逻辑里面嵌入并修改一些代码，以达到新技能的开发。这就是典型的以修改来达到需求。通过重构之后，技能的逻辑通过扩展的方式开发出来，可以通过继承技能的抽象类，来完成技能的开发。现在我们这部分的模块从最难处理变成最容易开发的了。","like_count":17,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418732,"discussion_content":"听说过电信代码里有26个if-else……然后还有俩是重复的，少的时候无所谓，多了就是坑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527977478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1192101,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/u0jDPGD68hsYNxhib3dQib4SibS8kic5FPEy0ib3ZxJuapbPsibNzbUoOufHws9rFOZazl5s4OrSXYHibz89IAZcHWMkA/132","nickname":"朱小山","note":"","ucode":"AB675896337DE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5105,"discussion_content":"在运营商的代码里 26个if-else 都还是正常的了，","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565947898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11202,"user_name":"张立春","can_delete":false,"product_type":"c1","uid":1124382,"ip_address":"","ucode":"D8B4523B95D839","user_header":"https://static001.geekbang.org/account/avatar/00/11/28/1e/76e19bd3.jpg","comment_is_top":false,"comment_ctime":1527932483,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"61657474627","product_id":100006701,"comment_content":"我理解继承的根本目的是为了多态而不是为了复用，如果仅为了复用那就采用松耦合的组合。","like_count":14,"discussions":[{"author":{"id":2047274,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/3d/2a/5c90358c.jpg","nickname":"子月十七","note":"","ucode":"FDCF1ABF9F2D74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356379,"discussion_content":"多态就是接口重用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615564913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1756181,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cc/15/35622b02.jpg","nickname":"Jason","note":"","ucode":"B2765DD1D90B0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":243633,"discussion_content":"多态不就是复用的一种体现么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587554201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12520,"user_name":"云学","can_delete":false,"product_type":"c1","uid":1027233,"ip_address":"","ucode":"366AE90BA06356","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ac/a1/43d83698.jpg","comment_is_top":false,"comment_ctime":1528889401,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31593660473","product_id":100006701,"comment_content":"其实有了函数式编程，绝大部分设计模式是多余的，记住，类的数量不要泛滥！！","like_count":8},{"had_liked":false,"id":11151,"user_name":"bamboo","can_delete":false,"product_type":"c1","uid":1105034,"ip_address":"","ucode":"55286877F22AD3","user_header":"https://static001.geekbang.org/account/avatar/00/10/dc/8a/651ca538.jpg","comment_is_top":false,"comment_ctime":1527901153,"is_pvip":false,"replies":[{"id":"3588","content":"嗯，也要避免过度设计，这个只是举例","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527977293,"ip_address":"","comment_id":11151,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31592672225","product_id":100006701,"comment_content":"老师最后举的例子应该就是把简单工厂模式修改为工厂方法模式。原来的违反了开闭选择，工厂方法模式刚好弥补了这个问题，倒是相应的系统中的类个数也成对的增加。设计模式没有最优的，只是特定场景下我们选择相对优良的模式来优化我们的逻辑。不知道是否正确，望老师指点迷津，谢谢老师。🙂","like_count":8,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418733,"discussion_content":"嗯，也要避免过度设计，这个只是举例","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527977293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":15684,"user_name":"zc","can_delete":false,"product_type":"c1","uid":1013406,"ip_address":"","ucode":"A231FA413151DD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/9e/dc53669e.jpg","comment_is_top":false,"comment_ctime":1531384895,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27301188671","product_id":100006701,"comment_content":"“这里你可以思考一个小问题，方法名称和参数一致，但是返回值不同，这种情况在 Java 代码中算是有效的重载吗？ 答案是不是的，编译都会出错的。”<br><br>编译出错是因为重载必须参数不一样，重载与返回值无关。感觉这里的表述有点问题……<br><br>示例代码既不属于重写（同名同参同返回）也不属于重载（同名不同参）的范畴。","like_count":7},{"had_liked":false,"id":15822,"user_name":"卡斯瓦德","can_delete":false,"product_type":"c1","uid":1011332,"ip_address":"","ucode":"E944E5BC507D5C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6e/84/45a909a6.jpg","comment_is_top":false,"comment_ctime":1531538909,"is_pvip":false,"replies":[{"id":"5468","content":"不错，只是：<br>抽象类不能多继承；<br>default method不会打破现有代码兼容性，lambda需要靠它来无缝增强collection之类API","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1531572016,"ip_address":"","comment_id":15822,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23006375389","product_id":100006701,"comment_content":"其实interface的deault可以通过结合抽象父类来实现吧，抽象父类实现接口方法，但是因为抽象所以不能实例化，而其子类拥有重写权，可以做到defualt的效果","like_count":6,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420566,"discussion_content":"不错，只是：\n抽象类不能多继承；\ndefault method不会打破现有代码兼容性，lambda需要靠它来无缝增强collection之类API","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1531572016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1338531,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6c/a3/11df679f.jpg","nickname":"风吹过wu","note":"","ucode":"27E3133A52EA7D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5373,"discussion_content":"也就是Effective java中讲到的骨架实现类,如AbstractSet, AbstractList。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566209004,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14511,"user_name":"仙道","can_delete":false,"product_type":"c1","uid":1161146,"ip_address":"","ucode":"CF35D34B484B71","user_header":"https://static001.geekbang.org/account/avatar/00/11/b7/ba/ae4cabd8.jpg","comment_is_top":false,"comment_ctime":1530499855,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"23005336335","product_id":100006701,"comment_content":"两个接口里有一个同名方法，然后一个类实现了这两个接口，这怎么办呢","like_count":5,"discussions":[{"author":{"id":1583833,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/E3XKbwTv6WTssolgqZjZCkiazHgl2IdBYfwVfAcB7Ff3krsIQeBIBFQLQE1Kw91LFbl3lic2EzgdfNiciaYDlJlELA/132","nickname":"rike","note":"","ucode":"920AAD0BD9245C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":154785,"discussion_content":"刚才试了一下，按照第一个接口的来。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1580182721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2821960,"avatar":"","nickname":"kangshuai","note":"","ucode":"1AA018FF3EC5B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1583833,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/E3XKbwTv6WTssolgqZjZCkiazHgl2IdBYfwVfAcB7Ff3krsIQeBIBFQLQE1Kw91LFbl3lic2EzgdfNiciaYDlJlELA/132","nickname":"rike","note":"","ucode":"920AAD0BD9245C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554912,"discussion_content":"不知道您用的 JDK 版本是多少，但我在 JDK8 和 14 试了都是子类必须重写接口中方法签名相同的默认方法。并且 JDK 14 是在您发帖之后才正式发布的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646658420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":154785,"ip_address":""},"score":554912,"extra":""}]},{"author":{"id":1338531,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6c/a3/11df679f.jpg","nickname":"风吹过wu","note":"","ucode":"27E3133A52EA7D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5369,"discussion_content":"编码的时候，编辑器会提醒你，让你选择一个方法实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566208780,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1157050,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a7/ba/1b915f18.jpg","nickname":"萝卜","note":"","ucode":"A478452CBC04D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1338531,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6c/a3/11df679f.jpg","nickname":"风吹过wu","note":"","ucode":"27E3133A52EA7D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78725,"discussion_content":"错了吧，朋友，方法名字一样，实现的不就是同一个方法吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575995066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5369,"ip_address":""},"score":78725,"extra":""}]}]},{"had_liked":false,"id":152971,"user_name":"Lpz","can_delete":false,"product_type":"c1","uid":1259739,"ip_address":"","ucode":"1554E08DC461EE","user_header":"https://static001.geekbang.org/account/avatar/00/13/38/db/16e3f437.jpg","comment_is_top":false,"comment_ctime":1574131515,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18754000699","product_id":100006701,"comment_content":"重写是正方体与正方体之间的关系，重载是立方体与正方体之间的关系。","like_count":4},{"had_liked":false,"id":25220,"user_name":"desmond","can_delete":false,"product_type":"c1","uid":1106996,"ip_address":"","ucode":"C3473F9C66D117","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep58epOYWkVaxMIul9hvv0LWWKIYCWAib4ic4nnngvabQMRsP1ials3u4nOYkS8HbsyLvMh7hV0LIsqQ/132","comment_is_top":false,"comment_ctime":1537271995,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14422173883","product_id":100006701,"comment_content":"最后一个示例，《代码大全》称作&quot;表驱动法&quot;。作者建议首先看这一章节，所以印象深刻","like_count":3},{"had_liked":false,"id":12985,"user_name":"夏洛克的救赎","can_delete":false,"product_type":"c1","uid":1021334,"ip_address":"","ucode":"44453DD27A3216","user_header":"https://static001.geekbang.org/account/avatar/00/0f/95/96/0020bd67.jpg","comment_is_top":false,"comment_ctime":1529243812,"is_pvip":false,"replies":[{"id":"4426","content":"一般我们会写成：<br>list&lt;String&gt; list=new ArrayList……；<br>里氏代换，可以参考oo基础那章","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1529424115,"ip_address":"","comment_id":12985,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14414145700","product_id":100006701,"comment_content":"但是，list 实际会被推断为“ArrayList &lt; String &gt;”<br><br>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();<br><br>不是很理解","like_count":3,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419489,"discussion_content":"一般我们会写成：\nlist&amp;lt;String&amp;gt; list=new ArrayList……；\n里氏代换，可以参考oo基础那章","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529424115,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100387,"user_name":"因缺思厅","can_delete":false,"product_type":"c1","uid":1517365,"ip_address":"","ucode":"2B1D9E9CD8784A","user_header":"https://static001.geekbang.org/account/avatar/00/17/27/35/ba972e11.jpg","comment_is_top":false,"comment_ctime":1559543729,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10149478321","product_id":100006701,"comment_content":"27个if else不是很简单的么，我现在维护项目中的一个类的代码，统计了一下有121个if，部分else我还没统计，代码4000多行，其中if-else主要在两个方法中，这两个方法有3500+行，总体上来看就是满屏的if-else。对于这样的代码，就不用想重构了。","like_count":3,"discussions":[{"author":{"id":1217699,"avatar":"https://static001.geekbang.org/account/avatar/00/12/94/a3/c8bcb28b.jpg","nickname":"美国的华莱士","note":"","ucode":"879C4FD53C72C5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447,"discussion_content":"亦可赛艇啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1561571456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":15657,"user_name":"000","can_delete":false,"product_type":"c1","uid":1052192,"ip_address":"","ucode":"98A810FA164106","user_header":"https://static001.geekbang.org/account/avatar/00/10/0e/20/4a8eb862.jpg","comment_is_top":false,"comment_ctime":1531361165,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10121295757","product_id":100006701,"comment_content":"抽象方法不实现，就是为了给子类用的吗？","like_count":2},{"had_liked":false,"id":12567,"user_name":"张健","can_delete":false,"product_type":"c1","uid":1101127,"ip_address":"","ucode":"74A29D976A5B17","user_header":"https://static001.geekbang.org/account/avatar/00/10/cd/47/827da4e4.jpg","comment_is_top":false,"comment_ctime":1528931499,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10118866091","product_id":100006701,"comment_content":"没解释多态 <br>方法重载这里，如果用jdk javac编译就会过的","like_count":2},{"had_liked":false,"id":12081,"user_name":"lorancechen","can_delete":false,"product_type":"c1","uid":1114303,"ip_address":"","ucode":"2A16CFA4726AE7","user_header":"https://static001.geekbang.org/account/avatar/00/11/00/bf/a44cde46.jpg","comment_is_top":false,"comment_ctime":1528555460,"is_pvip":false,"replies":[{"id":"3948","content":"是的，说明一下","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528593133,"ip_address":"","comment_id":12081,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10118490052","product_id":100006701,"comment_content":"vip的例子里面，T extend User这里，直接用User也一样吧","like_count":2,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419105,"discussion_content":"是的，说明一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528593133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11265,"user_name":"小情绪","can_delete":false,"product_type":"c1","uid":1020311,"ip_address":"","ucode":"92D8081DB8DB45","user_header":"https://static001.geekbang.org/account/avatar/00/0f/91/97/3762ca10.jpg","comment_is_top":false,"comment_ctime":1528012745,"is_pvip":false,"replies":[{"id":"3667","content":"前面就是个举例的回答，用来后面分析的，新版Java不准确了","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528154027,"ip_address":"","comment_id":11265,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10117947337","product_id":100006701,"comment_content":"杨老师，对于开头的：接口中没有非静态方法实现，也就是说要么是抽象方法，要么是静态方法。这句话我有疑问，java.util.List中default 方法不就是非静态方法的实现吗？还是我理解有误？","like_count":2,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418772,"discussion_content":"前面就是个举例的回答，用来后面分析的，新版Java不准确了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528154027,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11185,"user_name":"j.c.","can_delete":false,"product_type":"c1","uid":1004961,"ip_address":"","ucode":"909571207BAA63","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/a1/ed52e319.jpg","comment_is_top":false,"comment_ctime":1527912714,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10117847306","product_id":100006701,"comment_content":"同种类型行为是通过不同方法调用还是不同实现类，哪个好点？","like_count":2},{"had_liked":false,"id":11158,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1527903401,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10117837993","product_id":100006701,"comment_content":"10年前校招就被问抽象类和接口的区别。过了几年被问接口里能不能定义字段。面试官还是蛮爱问这些的...<br>","like_count":3},{"had_liked":false,"id":263537,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1606178378,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"5901145674","product_id":100006701,"comment_content":"简单的讲（来自于专栏文章和课代表 @公号-技术夜未眠 留言）<br><br>接口是对行为的抽象，是抽象方法的集合，利用接口可以达到 API 定义和实现分离的目的。接口支持多重继承，不允许函数实现，不允许实例化，只能包括 pulbic 函数以及 public static final 常量……<br><br>抽象类是不能实例化的类，用 abstract 关键字修饰 class，主要目的是代码重用。抽象类不支持多重继承，支持抽象函数，支持函数实现，不允许实例化，可以提供带有部分实现的模板类，讲一些功能需要延迟实现……<br><br>具体类不支持多重继承，不支持抽象函数，允许函数实现和实例化，可以提供完整的具体实现……<br><br>Java 类实现 interface 用 implements，继承 abstract class 用 extends<br><br>对于面向对象的基本要素（封装、继承和多态）以及 SOLID 原则，因为之前在其他专栏里面学习过，所以面试的时候反而不怎么担心（感觉自己有纸上谈兵的嫌疑）。<br><br>另外，留言终于少了一些。","like_count":2},{"had_liked":false,"id":249655,"user_name":"梦江","can_delete":false,"product_type":"c1","uid":2059155,"ip_address":"","ucode":"B5FD2835863460","user_header":"https://static001.geekbang.org/account/avatar/00/1f/6b/93/bfda2d1c.jpg","comment_is_top":false,"comment_ctime":1600743909,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5895711205","product_id":100006701,"comment_content":"<br>public class VIPCenter {<br>  void serviceVIP(T extend User user&gt;) {<br>     if (user instanceof SlumDogVIP) {<br>        &#47;&#47; 穷X VIP，活动抢的那种<br>        &#47;&#47; do somthing<br>      } else if(user instanceof RealVIP) {<br>        &#47;&#47; do somthing<br>      }<br>      &#47;&#47; ...<br>  }<br><br>不能这样写把","like_count":1,"discussions":[{"author":{"id":1344632,"avatar":"https://static001.geekbang.org/account/avatar/00/14/84/78/c246f6d5.jpg","nickname":"Jeff","note":"","ucode":"3E22C18FF4986F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318944,"discussion_content":"伪代码吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603888236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148065,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1572935685,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5867902981","product_id":100006701,"comment_content":"个人以为接口是把一个类的具体实现场景和外部应用场景进行分离。内部实现场景会有很多细节，外部应用场景则只需要知道其对外连接的那部分信息，信息量通常会少很多，如果这两者信息量相等就没有必要使用接口。例如，我看到某些代码对经纬度也定义接口，实现也完全对等的操作两个double字段，我认为没什么意义，徒增加维护接口和实现的成本，不知道老师对这个问题观点如何？多谢！","like_count":1},{"had_liked":false,"id":18523,"user_name":"clz1341521","can_delete":false,"product_type":"c1","uid":1179557,"ip_address":"","ucode":"3BDB4AB454C918","user_header":"https://static001.geekbang.org/account/avatar/00/11/ff/a5/eccc7653.jpg","comment_is_top":false,"comment_ctime":1533428576,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5828395872","product_id":100006701,"comment_content":"目前项目中很多代码工具类都是直接面向实现，才用static 方法。如日期类型转换，string操作等。这类方法有什么好的改进意见？","like_count":1},{"had_liked":false,"id":17755,"user_name":"Seven.Lin澤耿","can_delete":false,"product_type":"c1","uid":1181192,"ip_address":"","ucode":"4CAB732CD6F149","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/08/855abb02.jpg","comment_is_top":false,"comment_ctime":1532930172,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5827897468","product_id":100006701,"comment_content":"确实是的，目前还是许多程序员用面向对象语言书写面向过程的代码。实际工作中应该从业务流抽离出技术流，把类似if-else的处理封装，即使只是把代码抽离为方法；对于代码结构类似的（如，检查参数-&gt;业务处理-&gt;保存），应该更高一级的抽象，分离出业余模板（在JAVA表现就是一个接口或者抽象类）；在每一次编程之前考虑其扩展性和松耦度，避免过度依赖导致后期难以维护。","like_count":1},{"had_liked":false,"id":12406,"user_name":"Yao","can_delete":false,"product_type":"c1","uid":1058019,"ip_address":"","ucode":"D23E410D3F11DD","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/e3/6ada2f5e.jpg","comment_is_top":false,"comment_ctime":1528803971,"is_pvip":false,"replies":[{"id":"4071","content":"看你的需求啊，比如代码需不需要兼容老的jdk版本；有没有需要用的逻辑","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528816373,"ip_address":"","comment_id":12406,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5823771267","product_id":100006701,"comment_content":"问个问题，jdk8 default 是否应该使用？？？","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419247,"discussion_content":"看你的需求啊，比如代码需不需要兼容老的jdk版本；有没有需要用的逻辑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528816373,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11238,"user_name":"Turing","can_delete":false,"product_type":"c1","uid":1126058,"ip_address":"","ucode":"EDD31D6F80B3F6","user_header":"https://static001.geekbang.org/account/avatar/00/11/2e/aa/148aa3d0.jpg","comment_is_top":false,"comment_ctime":1527984622,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5822951918","product_id":100006701,"comment_content":"那个改进的也可以用策略模式来写","like_count":1},{"had_liked":false,"id":317919,"user_name":"瀚海","can_delete":false,"product_type":"c1","uid":2062203,"ip_address":"","ucode":"E64C22F3F6D285","user_header":"https://static001.geekbang.org/account/avatar/00/1f/77/7b/338c4617.jpg","comment_is_top":false,"comment_ctime":1635054267,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635054267","product_id":100006701,"comment_content":"接口支持默认方法，抽象类还有存在的意义吗？","like_count":1},{"had_liked":false,"id":269252,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1608585987,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1608585987","product_id":100006701,"comment_content":"接口是行为定义的集合，目的是对调用着屏蔽细节，体现面向对象的封装性，不能实例化，可能实现多接口<br>抽象类是行为定义及行为实现的类，但不能实例化<br>抽象类体现的是复用性","like_count":1},{"had_liked":false,"id":251664,"user_name":"旺→_→","can_delete":false,"product_type":"c1","uid":1326309,"ip_address":"","ucode":"04C1306ADD8CE6","user_header":"https://static001.geekbang.org/account/avatar/00/14/3c/e5/f550ed85.jpg","comment_is_top":false,"comment_ctime":1601780748,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1601780748","product_id":100006701,"comment_content":"接口，不能实例化。那么new Runnable()又是什么情况？","like_count":0,"discussions":[{"author":{"id":1718746,"avatar":"","nickname":"林新潜","note":"","ucode":"386EA326AD1009","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351527,"discussion_content":"匿名类","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614315300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248485,"user_name":"Geek_154f14","can_delete":false,"product_type":"c1","uid":2181453,"ip_address":"","ucode":"F01FF696364E73","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJAnje12Sebss1BwgLF48Wk57zaMtMSWdStbC6R7l0ssCev0ddLPYd2QqGXBmpfNL89NtahYKVkVg/132","comment_is_top":false,"comment_ctime":1600177838,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600177838","product_id":100006701,"comment_content":"困扰多年的抽象类作用总算明白了","like_count":0},{"had_liked":false,"id":236104,"user_name":"looper","can_delete":false,"product_type":"c1","uid":1238396,"ip_address":"","ucode":"DA4BCE83836C04","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/7c/2a5a418b.jpg","comment_is_top":false,"comment_ctime":1595317947,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595317947","product_id":100006701,"comment_content":"关于设计模式的原则是不是少说了迪米特原则。<br>6大设计原则，其它5中的原则最后的目的都是为了实现开闭原则，对拓展开放，对修改关闭。<br>有些书中说，依赖倒置原则是最难实现的原则，如果不能实现它，就无法做到开闭原则，我深以为然。<br>在我的开发过程中，有时候我也没有遵守6大原则，原因大概是不想增加太多的类和方法。综合来说，这就是一个抉择的问题，遵守原则带来的健壮性和不遵守带来的便利性和开发效率之间的抉择，后面会阅读更多的优秀源码，增加自己知识储备","like_count":1},{"had_liked":false,"id":228228,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1592620215,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592620215","product_id":100006701,"comment_content":"其实接口和抽象类的区别有两个：<br>接口不能定义实例字段；<br>类可以implements多个接口","like_count":0},{"had_liked":false,"id":223417,"user_name":"亚林","can_delete":false,"product_type":"c1","uid":1018972,"ip_address":"","ucode":"4A5A6D24314B79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/5c/3f164f66.jpg","comment_is_top":false,"comment_ctime":1591085977,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591085977","product_id":100006701,"comment_content":"开关原则感觉只能是事后才会意识到去调整","like_count":0},{"had_liked":false,"id":215276,"user_name":"Colin","can_delete":false,"product_type":"c1","uid":1668711,"ip_address":"","ucode":"6ACBBC2E854882","user_header":"https://static001.geekbang.org/account/avatar/00/19/76/67/59b13c4b.jpg","comment_is_top":false,"comment_ctime":1588946232,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588946232","product_id":100006701,"comment_content":"老师，您说接口中的方法要么是抽象方法，要么是静态方法，可是不还有默认方法以及 Java 9 新增的私有方法吗？","like_count":0},{"had_liked":false,"id":207656,"user_name":"mickey","can_delete":false,"product_type":"c1","uid":1051663,"ip_address":"","ucode":"8B490C2DDE4010","user_header":"https://static001.geekbang.org/account/avatar/00/10/0c/0f/93d1c8eb.jpg","comment_is_top":false,"comment_ctime":1587129947,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587129947","product_id":100006701,"comment_content":"老师好，请教几个问题：<br>1、为什么要设计个 providers，怎样初始化它？<br>           private Map&lt;User.TYPE, ServiceProvider&gt; providers;<br>2、直接设计Provider接口就可以了吧<br> interface ServiceProvider {<br>\tvoid service(User user);<br>}<br><br>public class VIPCenter {<br>\tvoid service(User u) {<br>\t\tu.doSoming();<br>\t}<br>}<br><br>VIPCenter c = new VIPCenter();<br>User u1 = new SlumDogVIP(&quot;S&quot;);<br>User u2 = new RealVIP(&quot;R&quot;);<br>c.service(u1);<br>c.service(u2);<br>User u3 = new VVIP(&quot;V&quot;);<br>c.service(u3);","like_count":0},{"had_liked":false,"id":190481,"user_name":"时代先锋","can_delete":false,"product_type":"c1","uid":1856411,"ip_address":"","ucode":"956E3E6A6A4F30","user_header":"https://static001.geekbang.org/account/avatar/00/1c/53/9b/d0a21378.jpg","comment_is_top":false,"comment_ctime":1584663604,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584663604","product_id":100006701,"comment_content":"java是面向对象的语言。","like_count":0},{"had_liked":false,"id":172968,"user_name":"其实小鱼是猪","can_delete":false,"product_type":"c1","uid":1751773,"ip_address":"","ucode":"9E65158A399018","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoBOx5t7iaPHgA3ic2wEsiasKZzYKVerXorCwYPQfuoeGWkMv8VQJCjJnVyqcvjcbYzGYI2lPhJ4mZyw/132","comment_is_top":false,"comment_ctime":1579399870,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579399870","product_id":100006701,"comment_content":"问个问题，为什么map list这种要设计成接口而不是抽象类？我怎么感觉应该是抽象类map，然后用hashmap，sortedmap这些来继承map","like_count":0},{"had_liked":false,"id":171300,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1578896771,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578896771","product_id":100006701,"comment_content":"VIP的例子生动形象，一读就懂，非常感谢！","like_count":0},{"had_liked":false,"id":169934,"user_name":"Eleven","can_delete":false,"product_type":"c1","uid":1168452,"ip_address":"","ucode":"FB4A0C8CA732BE","user_header":"https://static001.geekbang.org/account/avatar/00/11/d4/44/0ec958f4.jpg","comment_is_top":false,"comment_ctime":1578475613,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578475613","product_id":100006701,"comment_content":"public class VIPCenter { <br>    private Map providers; <br>    void serviceVIP(T extend User user） { <br>        providers.get(user.getType()).service(user); <br>    } <br>}<br><br>新增的时候一样需要修改map啊","like_count":0},{"had_liked":false,"id":156857,"user_name":"天王","can_delete":false,"product_type":"c1","uid":1239337,"ip_address":"","ucode":"C074B2F9A5F007","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/29/629d9bb0.jpg","comment_is_top":false,"comment_ctime":1574988791,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574988791","product_id":100006701,"comment_content":"13 接口和抽象类有什么区别 1接口和抽象类都不能被直接实例化，都必须通过继承的子类实例化，子类叫实现接口，继承抽象类，2 子类必须实现所有的接口方法，抽象类按照需要实现某些方法 ，方法调用，抽象类和接口可以通过对象的多态性，调用子类重写的方法 3 抽象类的应用，模板设计，4 接口的实际应用 制定标准，5 工厂设计模式 接口应用 6 代理模式 接口应用 7 适配器模式 不需要实现接口所有的方法，找一个抽象方法过渡 8 接口或者抽象类的内部接口，子类继承的时候，也要做实现。9 面相对象的设计原则 单一职责原则，对扩展开放对追改封闭原则，里氏替换原则，依赖反转t","like_count":0},{"had_liked":false,"id":148069,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1572935890,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572935890","product_id":100006701,"comment_content":"抽象类表示类是某一个特定的类型的子类，每个类的父类只有一个，抽象类也不例外，抽象类可能有一个或者多个抽象方法，抽象类不能实例化，除此之外和普通类也没什么区别。","like_count":0},{"had_liked":false,"id":121188,"user_name":"Element","can_delete":false,"product_type":"c1","uid":1155609,"ip_address":"","ucode":"31FE7C1CB7BBE6","user_header":"https://static001.geekbang.org/account/avatar/00/11/a2/19/3f71c4e8.jpg","comment_is_top":false,"comment_ctime":1565072971,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565072971","product_id":100006701,"comment_content":"这篇真的受益良多, 感谢.","like_count":0},{"had_liked":false,"id":87814,"user_name":"jekbon","can_delete":false,"product_type":"c1","uid":1317044,"ip_address":"","ucode":"14F700BF1FD854","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLszPoZljrFJl95K7ZJmPziaCjCyUcc9Nb6f2E6QAQNpR9ayWU9hxpmkVlGxQOh7znib61b5JCquv6w/132","comment_is_top":false,"comment_ctime":1555723405,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555723405","product_id":100006701,"comment_content":"接口中不能定义静态的方法，请问老师说的接口中要么是抽象方法，要么是静态方法什么意思？","like_count":0},{"had_liked":false,"id":81491,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1553925711,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553925711","product_id":100006701,"comment_content":"不好意思的说，我其实就是加if else，看了这篇文章的确要针对自己的项目进行开关模式的改进了，谢谢老师了，以后会多想想，做到尽量抽象","like_count":0},{"had_liked":false,"id":71590,"user_name":"力主道","can_delete":false,"product_type":"c1","uid":1178870,"ip_address":"","ucode":"8C2BE1B9B10A28","user_header":"https://static001.geekbang.org/account/avatar/00/11/fc/f6/d50bfaf4.jpg","comment_is_top":false,"comment_ctime":1551398451,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1551398451","product_id":100006701,"comment_content":"嗯，老师 最后一个例子哪里，调用根据type调用不同的实现是怎么回事啊?看着好像是从map里面取出来的?","like_count":0},{"had_liked":false,"id":70141,"user_name":"取个好名字吧","can_delete":false,"product_type":"c1","uid":1380330,"ip_address":"","ucode":"91226FD943696B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIJfymuqe6wttIWiavKn1VrRZAUnYuJnSJOc3G8oqOnWsDeRAmO8NKBbFCLLgw12VsnPNhKdDBMZvQ/132","comment_is_top":false,"comment_ctime":1551011184,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551011184","product_id":100006701,"comment_content":"可不可以具体举一个例子说明什么时候该用接口,什么时候该用抽象类","like_count":0},{"had_liked":false,"id":69374,"user_name":"Geek_bbe34a","can_delete":false,"product_type":"c1","uid":1434654,"ip_address":"","ucode":"52F64A55F23E6C","user_header":"","comment_is_top":false,"comment_ctime":1550730374,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550730374","product_id":100006701,"comment_content":"接口和抽象类的区别<br>相同点:<br>1.接口和抽象类都不能实例化。<br>不同的：<br>1.接口不能有构造方法，抽象类可以有<br>2.接口不能有实例方法，抽象类可以有<br>3.接口的变量只能是静态常量，抽象类都可以<br>4.接口可以多实现，抽象类只能但基础<br>5.接口从jdk1.8开始可以有default方法，抽象类没有                            <br>","like_count":0},{"had_liked":false,"id":54749,"user_name":"winterx","can_delete":false,"product_type":"c1","uid":1067362,"ip_address":"","ucode":"1C526816EED42F","user_header":"https://static001.geekbang.org/account/avatar/00/10/49/62/25b29ebc.jpg","comment_is_top":false,"comment_ctime":1545959234,"is_pvip":true,"discussion_count":0,"race_medal":4,"score":"1545959234","product_id":100006701,"comment_content":"- 回答<br>  - 接口和抽象类是java面向对象设计的两个基础机制。<br>  - 接口是对行为的抽象，他是抽象方法的集合，利用接口可以达到API定义和实现的分离。接口不能实例化&#47;不能包含非常量成员，任何的feild都是默认public static final的意义；没有非静态方法的实现。<br>  - 抽象类也是不能实例化的类，用abstract关键字修饰class，其目的主要是代码重用，通常抽取相关的java类的公用方法实现或共同的成员变量，然后通过继承的方式达到代码复用的目的。除了不能实例化，同普通的java类没啥区别，可以有0到多个的抽象方法。<br>  - 实现interface使用implements<br>  - 继承abstract类使用extends<br>  - 接口类增加方法的情况下，其实现类都需要做相应的修改。当然java8引入的default方法除外。<br>  - 抽象类增加方法，其子类只会享受能力扩展，不用担心编译问题。<br>- 扩展<br>  - java不支持多继承的问题<br>    - 规范了代码实现的同时，也产生了一些局限性，影响着程序的设计结构。<br>    - 比如有一些场景需要抽象出与具体实现无关的通用逻辑，或者单纯调用关系的逻辑，使用传统的抽象类会陷入单继承的窘境。成熟的做法是：实现工具类呗。<br>  - 接口类Marker Interface<br>    - 没有任何抽象方法的接口。目的就是为了生命某些东西，如Cloneable，Serializable等。<br>    - 相比Annotation，该形式简单直接。但是Annotation可以有参数和值，更加强大。<br>  - @FunctionalInterface Annotation<br>    - 只有一个抽象方法的接口。<br>  - 面向对象的要素<br>    - 封装：隐藏事务内部的实现细节，以便提高安全性和简化编程。封装提供了合理的边界，避免外部调用者接触到内部的细节。可能会触发更多的问题，如并发问题。<br>    - 继承：是代码复用的基础机制。<br>    - 多态：会立刻想到重写&#47;重载&#47;向上转型。多态是同一个行为具有多个不同表现形式或形态的能力。同一个接口使用不同的实例而执行不同操作。<br>  - 需要遵守的设计原则<br>    - 单一职责<br>    - 开关原则<br>      - 对扩展开放，对修改关闭。<br>    - 里氏替换<br>      - 方式可以用父类或者基类的地方，都可以用子类替换。<br>    - 接口分离<br>      - 就是接口的单一职责，这个比普通类的更加重要。<br>    - 依赖反转<br>      - 这个我感觉应该就是面向接口的编程吧。实体应该是依赖抽象而不是实现。","like_count":0},{"had_liked":false,"id":50088,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1544863306,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1544863306","product_id":100006701,"comment_content":"恩，这节好理解不好做到，吐槽一下我们现在的核心代码，if...else相当多，而且都几年前的了，一个方法要看几天才能看完，一层一层接一层，能把自己都绕晕，有新需求都是打补丁，加新的if...else，不忍直视，当然，她也很牛逼，承载的业务量巨大，因为太核心及复杂导致不敢大动。现在业务运维起来，相当惊心，所以，不得不动了，重构中，重构后期待更好的扩展性和易用性。","like_count":0,"discussions":[{"author":{"id":1097497,"avatar":"https://static001.geekbang.org/account/avatar/00/10/bf/19/24cc3e7c.jpg","nickname":"二康","note":"","ucode":"45E85D80DE4544","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":31808,"discussion_content":"ifelse太多可以考虑采用策略模式实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570959965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36482,"user_name":"leleba","can_delete":false,"product_type":"c1","uid":1281735,"ip_address":"","ucode":"C868F6ABF509B2","user_header":"https://static001.geekbang.org/account/avatar/00/13/8e/c7/f05f9fd0.jpg","comment_is_top":false,"comment_ctime":1541125356,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541125356","product_id":100006701,"comment_content":"我觉得自己对面向对象有些心得，但对java底层技术掌握不到位啊。我的经验发现很多开发人员对oo也能理解但编码就忘得一干二净了。<br><br>1大的方向，设计和编码时要思考oo要解决的问题和目标，你可以不了解那些设计但如果你的代码和设计要达到oo的要求。<br>2面向对象这个词容易理解偏，应该这样理解：谁面向对象？我们设计的是对象，具体编码的是“谁”，这个谁是什么？可能是一段代码，一个类，一个方法定义，一个变量定义<br><br>也就是说谁消费对象，怎么消费对象使得它具有维护性好，扩展性好等等","like_count":0},{"had_liked":false,"id":32491,"user_name":"Daniel","can_delete":false,"product_type":"c1","uid":1111375,"ip_address":"","ucode":"1526A65FA13956","user_header":"https://static001.geekbang.org/account/avatar/00/10/f5/4f/e1c96c55.jpg","comment_is_top":false,"comment_ctime":1539589356,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539589356","product_id":100006701,"comment_content":"&quot;void serviceVIP(T extend User user&gt;) &quot; <br>正确的写法是怎样的呢","like_count":0},{"had_liked":false,"id":11289,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1528033759,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1528033759","product_id":100006701,"comment_content":"根据开闭原则，将VIPCenter改造的方法应该是一种设计模式吧，是什么设计模式呢？","like_count":0},{"had_liked":false,"id":11283,"user_name":"张希功(pokercc)","can_delete":false,"product_type":"c1","uid":1128372,"ip_address":"","ucode":"AF42C4D3ACD5E3","user_header":"https://static001.geekbang.org/account/avatar/00/11/37/b4/ca455f43.jpg","comment_is_top":false,"comment_ctime":1528026236,"is_pvip":false,"replies":[{"id":"3677","content":"本来是个示意的伪代码...为了尽量精简的说明结构设计，不是为了语法","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528168481,"ip_address":"","comment_id":11283,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528026236","product_id":100006701,"comment_content":"&quot;void serviceVIP(T extend User user&gt;) &quot;  <br>这是java新出的写法吗？我用java8这样写，编译不通过呢","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418775,"discussion_content":"本来是个示意的伪代码...为了尽量精简的说明结构设计，不是为了语法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528168481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11244,"user_name":"行者","can_delete":false,"product_type":"c1","uid":1063734,"ip_address":"","ucode":"EA31201A7C5AE1","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/36/2d61e080.jpg","comment_is_top":false,"comment_ctime":1527988560,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1527988560","product_id":100006701,"comment_content":"如果把软件开发比做构建一座大楼，使用设计模式进行精心设计，把房屋结构性的支撑规划清楚，这样日后再决定用地板还是地毯，屋顶用什么材料，规划得当能够让我们再后期可以方便的进行替换。","like_count":0}]}