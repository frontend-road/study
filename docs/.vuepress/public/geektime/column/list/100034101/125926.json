{"id":125926,"title":"05 | 语法分析（三）：实现一门简单的脚本语言","content":"<p>前两节课结束后，我们已经掌握了表达式的解析，并通过一个简单的解释器实现了公式的计算。但这个解释器还是比较简单的，看上去还不大像一门语言。那么如何让它支持更多的功能，更像一门脚本语言呢？本节课，我会带你寻找答案。</p><p>我将继续带你实现一些功能，比如：</p><ul>\n<li>支持变量声明和初始化语句，就像“int age” “int age = 45”和“int age = 17+8+20”；</li>\n<li>支持赋值语句“age = 45”；</li>\n<li>在表达式中可以使用变量，例如“age + 10 *2”；</li>\n<li>实现一个命令行终端，能够读取输入的语句并输出结果。</li>\n</ul><p>实现这些功能之后，我们的成果会更像一个脚本解释器。而且在这个过程中，我还会带你巩固语法分析中的递归下降算法，和你一起讨论“回溯”这个特征，让你对递归下降算法的特征理解得更加全面。</p><p>不过，为了实现这些新的语法，我们首先要把它们用语法规则描述出来。</p><h2>增加所需要的语法规则</h2><p>首先，一门脚本语言是要支持语句的，比如变量声明语句、赋值语句等等。单独一个表达式，也可以视为语句，叫做“表达式语句”。你在终端里输入2+3；，就能回显出5来，这就是表达式作为一个语句在执行。按照我们的语法，无非是在表达式后面多了个分号而已。C语言和Java都会采用分号作为语句结尾的标识，我们也可以这样写。</p><!-- [[[read_end]]] --><p>我们用扩展巴科斯范式（EBNF）写出下面的语法规则：</p><pre><code>programm: statement+;  \n\nstatement\n: intDeclaration\n| expressionStatement\n| assignmentStatement\n;\n</code></pre><p><strong>变量声明语句</strong>以int开头，后面跟标识符，然后有可选的初始化部分，也就是一个等号和一个表达式，最后再加分号：</p><pre><code>intDeclaration : 'int' Id ( '=' additiveExpression)? ';';\n</code></pre><p><strong>表达式语句</strong>目前只支持加法表达式，未来可以加其他的表达式，比如条件表达式，它后面同样加分号：</p><pre><code>expressionStatement : additiveExpression ';';\n</code></pre><p><strong>赋值语句</strong>是标识符后面跟着等号和一个表达式，再加分号：</p><pre><code>assignmentStatement : Identifier '=' additiveExpression ';';\n</code></pre><p>为了在表达式中可以使用变量，我们还需要把primaryExpression改写，除了包含整型字面量以外，还要包含标识符和用括号括起来的表达式：</p><pre><code>primaryExpression : Identifier| IntLiteral | '(' additiveExpression ')';\n</code></pre><p>这样，我们就把想实现的语法特性，都用语法规则表达出来了。接下来，我们就一步一步实现这些特性。</p><h2>让脚本语言支持变量</h2><p>之前实现的公式计算器只支持了数字字面量的运算，如果能在表达式中用上变量，会更有用，比如能够执行下面两句：</p><pre><code>int age = 45;\nage + 10 * 2;\n</code></pre><p>这两个语句里面的语法特性包含了变量声明、给变量赋值，以及在表达式里引用变量。为了给变量赋值，我们必须在脚本语言的解释器中开辟一个存储区，记录不同的变量和它们的值：</p><pre><code>private HashMap&lt;String, Integer&gt; variables = new HashMap&lt;String, Integer&gt;();\n</code></pre><p>我们简单地用了一个HashMap作为变量存储区。在变量声明语句和赋值语句里，都可以修改这个变量存储区中的数据，而获取变量值可以采用下面的代码：</p><pre><code>if (variables.containsKey(varName)) {\n    Integer value = variables.get(varName);  //获取变量值\n    if (value != null) {\n        result = value;                      //设置返回值\n    } else {                                 //有这个变量，没有值\n        throw new Exception(&quot;variable &quot; + varName + &quot; has not been set any value&quot;);\n    }\n}\nelse{ //没有这个变量。\n    throw new Exception(&quot;unknown variable: &quot; + varName);\n}\n</code></pre><p>通过这样的一个简单的存储机制，我们就能支持变量了。当然，这个存储机制可能过于简单了，我们后面讲到作用域的时候，这么简单的存储机制根本不够。不过目前我们先这么用着，以后再考虑改进它。</p><h2>解析赋值语句</h2><p>接下来，我们来解析赋值语句，例如“age = age + 10 * 2；”：</p><pre><code>private SimpleASTNode assignmentStatement(TokenReader tokens) throws Exception {\n    SimpleASTNode node = null;\n    Token token = tokens.peek();    //预读，看看下面是不是标识符\n    if (token != null &amp;&amp; token.getType() == TokenType.Identifier) {\n        token = tokens.read();      //读入标识符\n        node = new SimpleASTNode(ASTNodeType.AssignmentStmt, token.getText());\n        token = tokens.peek();      //预读，看看下面是不是等号\n        if (token != null &amp;&amp; token.getType() == TokenType.Assignment) {\n            tokens.read();          //取出等号\n            SimpleASTNode child = additive(tokens);\n            if (child == null) {    //出错，等号右面没有一个合法的表达式\n                throw new Exception(&quot;invalide assignment statement, expecting an expression&quot;);\n            }\n            else{\n                node.addChild(child);   //添加子节点\n                token = tokens.peek();  //预读，看看后面是不是分号\n                if (token != null &amp;&amp; token.getType() == TokenType.SemiColon) {\n                    tokens.read();      //消耗掉这个分号\n\n                } else {            //报错，缺少分号\n                    throw new Exception(&quot;invalid statement, expecting semicolon&quot;);\n                }\n            }\n        }\n        else {\n            tokens.unread();    //回溯，吐出之前消化掉的标识符\n            node = null;\n        }\n    }\n    return node;\n}\n</code></pre><p>为了方便你理解，我来解读一下上面这段代码的逻辑：</p><blockquote>\n<p>我们既然想要匹配一个赋值语句，那么首先应该看看第一个Token是不是标识符。如果不是，那么就返回null，匹配失败。如果第一个Token确实是标识符，我们就把它消耗掉，接着看后面跟着的是不是等号。如果不是等号，那证明我们这个不是一个赋值语句，可能是一个表达式什么的。那么我们就要回退刚才消耗掉的Token，就像什么都没有发生过一样，并且返回null。回退的时候调用的方法就是unread()。<br>\n如果后面跟着的确实是等号，那么在继续看后面是不是一个表达式，表达式后面跟着的是不是分号。如果不是，就报错就好了。这样就完成了对赋值语句的解析。</p>\n</blockquote><p>利用上面的代码，我们还可以改造一下变量声明语句中对变量初始化的部分，让它在初始化的时候支持表达式，因为这个地方跟赋值语句很像，例如“int newAge = age + 10 * 2；”。</p><h2>理解递归下降算法中的回溯</h2><p>不知道你有没有发现，我在设计语法规则的过程中，其实故意设计了一个陷阱，这个陷阱能帮我们更好地理解递归下降算法的一个特点：<strong>回溯。</strong>理解这个特点能帮助你更清晰地理解递归下降算法的执行过程，从而再去想办法优化它。</p><p>考虑一下age = 45；这个语句。肉眼看过去，你马上知道它是个赋值语句，但是当我们用算法去做模式匹配时，就会发生一些特殊的情况。看一下我们对statement语句的定义：</p><pre><code>statement\n: intDeclaration\n| expressionStatement\n| assignmentStatement\n;\n</code></pre><p>我们首先尝试intDeclaration，但是age = 45；语句不是以int开头的，所以这个尝试会返回null。然后我们接着尝试expressionStatement，看一眼下面的算法：</p><pre><code>private SimpleASTNode expressionStatement() throws Exception {\n        int pos = tokens.getPosition();  //记下初始位置\n        SimpleASTNode node = additive(); //匹配加法规则\n        if (node != null) {\n            Token token = tokens.peek();\n            if (token != null &amp;&amp; token.getType() == TokenType.SemiColon) {   //要求一定以分号结尾\n                tokens.read();\n            } else {\n                node = null;\n                tokens.setPosition(pos); // 回溯\n            }\n        }\n        return node;\n    }\n</code></pre><p>出现了什么情况呢？age = 45；语句最左边是一个标识符。根据我们的语法规则，标识符是一个合法的addtiveExpresion，因此additive()函数返回一个非空值。接下来，后面应该扫描到一个分号才对，但是显然不是，标识符后面跟的是等号，这证明模式匹配失败。</p><p>失败了该怎么办呢？我们的算法一定要把Token流的指针拨回到原来的位置，就像一切都没发生过一样。因为我们不知道addtive()这个函数往下尝试了多少步，因为它可能是一个很复杂的表达式，消耗掉了很多个Token，所以我们必须记下算法开始时候的位置，并在失败时回到这个位置。<strong>尝试一个规则不成功之后，恢复到原样，再去尝试另外的规则，这个现象就叫做“回溯”。</strong></p><p>因为有可能需要回溯，所以递归下降算法有时会做一些无用功。在assignmentStatement的算法中，我们就通过unread()，回溯了一个Token。而在expressionStatement中，我们不确定要回溯几步，只好提前记下初始位置。匹配expressionStatement失败后，算法去尝试匹配assignmentStatement。这次获得了成功。</p><p>试探和回溯的过程，是递归下降算法的一个典型特征。通过上面的例子，你应该对这个典型特征有了更清晰的理解。递归下降算法虽然简单，但它通过试探和回溯，却总是可以把正确的语法匹配出来，这就是它的强大之处。当然，缺点是回溯会拉低一点儿效率。但我们可以在这个基础上进行改进和优化，实现带有预测分析的递归下降，以及非递归的预测分析。有了对递归下降算法的清晰理解，我们去学习其他的语法分析算法的时候，也会理解得更快。</p><p>我们接着再讲回溯牵扯出的另一个问题：<strong>什么时候该回溯，什么时候该提示语法错误？</strong></p><p>大家在阅读示例代码的过程中，应该发现里面有一些错误处理的代码，并抛出了异常。比如在赋值语句中，如果等号后面没有成功匹配一个加法表达式，我们认为这个语法是错的。因为在我们的语法中，等号后面只能跟表达式，没有别的可能性。</p><pre><code>token = tokens.read();          //读出等号\nnode = additive();    //匹配一个加法表达式\nif (node == null) {\n    //等号右边一定需要有另一个表达式  \n    throw new Exception(&quot;invalide assignment expression, expecting an additive expression&quot;);\n}\n</code></pre><p>你可能会意识到一个问题，当我们在算法中匹配不成功的时候，我们前面说的是应该回溯呀，应该再去尝试其他可能性呀，为什么在这里报错了呢？换句话说，什么时候该回溯，什么时候该提示这里发生了语法错误呢？</p><p>其实这两种方法最后的结果是一样的。我们提示语法错误的时候，是说我们知道已经没有其他可能的匹配选项了，不需要浪费时间去回溯。就比如，在我们的语法中，等号后面必然跟表达式，否则就一定是语法错误。你在这里不报语法错误，等试探完其他所有选项后，还是需要报语法错误。所以说，提前报语法错误，实际上是我们写算法时的一种优化。</p><p>在写编译程序的时候，我们不仅仅要能够解析正确的语法，还要尽可能针对语法错误提供友好的提示，帮助用户迅速定位错误。错误定位越是准确、提示越是友好，我们就越喜欢它。</p><p>好了，到目前为止，已经能够能够处理几种不同的语句，如变量声明语句，赋值语句、表达式语句，那么我们把所有这些成果放到一起，来体会一下使用自己的脚本语言的乐趣吧！</p><p>我们需要一个交互式的界面来输入程序，并执行程序，这个交互式的界面就叫做<strong>REPL。</strong></p><h2>实现一个简单的REPL</h2><p>脚本语言一般都会提供一个命令行窗口，让你输入一条一条的语句，马上解释执行它，并得到输出结果，比如Node.js、Python等都提供了这样的界面。<strong>这个输入、执行、打印的循环过程就叫做REPL（Read-Eval-Print Loop）。</strong>你可以在REPL中迅速试验各种语句，REPL即时反馈的特征会让你乐趣无穷。所以，即使是非常资深的程序员，也会经常用REPL来验证自己的一些思路，它相当于一个语言的PlayGround（游戏场），是个必不可少的工具。</p><p>在SimpleScript.java中，我们也实现了一个简单的REPL。基本上就是从终端一行行的读入代码，当遇到分号的时候，就解释执行，代码如下：</p><pre><code>SimpleParser parser = new SimpleParser();\nSimpleScript script = new SimpleScript();\nBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));   //从终端获取输入\n\nString scriptText = &quot;&quot;;\nSystem.out.print(&quot;\\n&gt;&quot;);   //提示符\n\nwhile (true) {             //无限循环\n    try {\n        String line = reader.readLine().trim(); //读入一行\n        if (line.equals(&quot;exit();&quot;)) {   //硬编码退出条件\n            System.out.println(&quot;good bye!&quot;);\n            break;\n        }\n        scriptText += line + &quot;\\n&quot;;\n        if (line.endsWith(&quot;;&quot;)) { //如果没有遇到分号的话，会再读一行\n            ASTNode tree = parser.parse(scriptText); //语法解析\n            if (verbose) {\n                parser.dumpAST(tree, &quot;&quot;);\n            }\n          \n            script.evaluate(tree, &quot;&quot;); //对AST求值，并打印\n\n            System.out.print(&quot;\\n&gt;&quot;);   //显示一个提示符\n\n            scriptText = &quot;&quot;;\n        }\n\n    } catch (Exception e) { //如果发现语法错误，报错，然后可以继续执行\n        System.out.println(e.getLocalizedMessage());\n        System.out.print(&quot;\\n&gt;&quot;);   //提示符\n        scriptText = &quot;&quot;;\n    } \n}\n</code></pre><p>运行java craft.SimpleScript，你就可以在终端里尝试各种语句了。如果是正确的语句，系统马上会反馈回结果。如果是错误的语句，REPL还能反馈回错误信息，并且能够继续处理下面的语句。我们前面添加的处理语法错误的代码，现在起到了作用！下面是在我电脑上的运行情况：</p><p><img src=\"https://static001.geekbang.org/resource/image/bd/7a/bd7a1629ec9c6ce4d4eb474fb60d4b7a.jpg?wh=1142*862\" alt=\"\"></p><p>如果你用java craft.SimpleScript -v启动REPL，则进入Verbose模式，它还会每次打印出AST，你可以尝试一下。</p><p>退出REPL需要在终端输入ctl+c，或者调用exit()函数。我们目前的解释器并没有支持函数，所以我们是在REPL里硬编码来实现exit()函数的。后面的课程里，我会带你真正地实现函数特性。</p><p>我希望你能编译一下这个程序，好好的玩一玩它，然后再修改一下源代码，增加一些你感兴趣的特性。我们学习跟打游戏一样，好玩、有趣才能驱动我们不停地学下去，一步步升级打怪。我个人觉得，我们作为软件工程师，拿出一些时间来写点儿有趣的东西作为消遣，乐趣和成就感也是很高的，况且还能提高水平。</p><h2>课程小结</h2><p>本节课我们通过对三种语句的支持，实现了一个简单的脚本语言。REPL运行代码的时候，你会有一种真真实实的感觉，这确实是一门脚本语言了，虽然它没做性能的优化，但你运行的时候也还觉得挺流畅。</p><p>学完这讲以后，你也能找到了一点感觉：Shell脚本也好，PHP也好，JavaScript也好，Python也好，其实都可以这样写出来。</p><p>回顾过去几讲，你已经可以分析词法、语法、进行计算，还解决了左递归、优先级、结合性的问题。甚至，你还能处理语法错误，让脚本解释器不会因为输入错误而崩溃。</p><p>想必这个时候你已经开始相信我的承诺了：<strong>每个人都可以写一个编译器。</strong>这其实也是我最想达到的效果。相信自己，只要你不给自己设限，不设置玻璃天花板，其实你能够做出很多让自己惊讶、让自己骄傲的成就。</p><p><strong>收获对自己的信心，掌握编译技术，将是你学习这门课程后最大的收获！</strong></p><h2>一课一思</h2><p>本节课，我们设计了一个可能导致递归下降算法中回溯的情景。在你的计算机语言中，有哪些语法在运用递归下降算法的时候，也是会导致回溯的？</p><p>如果你还想进一步挑战自己，可以琢磨一下，递归下降算法的回溯，会导致多少计算时间的浪费？跟代码长度是线性关系还是指数关系？我们在后面梳理算法的时候，会涉及到这个问题。</p><p>欢迎在留言区里分享你的发现，与大家一起讨论。最后，感谢你的阅读，如果这篇文章让你有所收获，也欢迎你将它分享给更多的朋友。</p><p>另外，第2讲到第5讲的代码，都在代码库中的lab子目录的craft子目录下，代码库在<a href=\"https://gitee.com/richard-gong/PlayWithCompiler/blob/master/lab/craft/SimpleScript.java\">码云</a>和<a href=\"https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/craft/SimpleScript.java\">GitHub</a>上都有，希望你能下载玩一玩。</p>","neighbors":{"left":{"article_title":"04 | 语法分析（二）：解决二元表达式中的难点","id":120388},"right":{"article_title":"06 | 编译器前端工具（一）：用Antlr生成词法、语法分析器","id":126910}},"comments":[{"had_liked":false,"id":128273,"user_name":"janey","can_delete":false,"product_type":"c1","uid":1619748,"ip_address":"","ucode":"B2160B363F23EB","user_header":"https://static001.geekbang.org/account/avatar/00/18/b7/24/17f6c240.jpg","comment_is_top":false,"comment_ctime":1566867142,"is_pvip":false,"replies":[{"id":"47809","content":"java语句当然是由java的编译器来识别了。<br>不过你提了一个重要的事情。<br>在编译领域，有一个事情，叫做自举（bootstraping），也就是这门语言的编译器可以用自己这门语言编写。这是语言迈向成熟的标志。一般前面的版本，是要借助别的语言编写编译器，但后面就应该用自己的语言来编译了。<br>著名的语言都实现了自举。比如，go语言的编译器是用go编写的（早期版本不是。能实现自举，还是go发展历程上的一个历程碑），jdk里面自带了java语言的编译器，本身也是用java写的。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1566959917,"ip_address":"","comment_id":128273,"utype":1}],"discussion_count":2,"race_medal":0,"score":"104646082246","product_id":100034101,"comment_content":"像这里用java实现了一种脚本语言，但是这些java语句又是怎么被计算机识别的呢？","like_count":25,"discussions":[{"author":{"id":1041915,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e5/fb/77035151.jpg","nickname":"演技熊","note":"","ucode":"0C73B00E66A82F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":44104,"discussion_content":"是的，之前特意查过这个自举，先使用其他语言实现一个自己的编译器如 CPP，再使用当前语言 Java 的编译器实现一遍，可以我们之前的做对比，如果Ok，那么以后就可以抛弃掉其他语言 CPP 实现的编译器，后续编译器也可以以这个 Java 版本为基础开发。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1572930093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464876,"discussion_content":"java语句当然是由java的编译器来识别了。\n不过你提了一个重要的事情。\n在编译领域，有一个事情，叫做自举（bootstraping），也就是这门语言的编译器可以用自己这门语言编写。这是语言迈向成熟的标志。一般前面的版本，是要借助别的语言编写编译器，但后面就应该用自己的语言来编译了。\n著名的语言都实现了自举。比如，go语言的编译器是用go编写的（早期版本不是。能实现自举，还是go发展历程上的一个历程碑），jdk里面自带了java语言的编译器，本身也是用java写的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566959917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137458,"user_name":"风","can_delete":false,"product_type":"c1","uid":1444483,"ip_address":"","ucode":"E1CE0825AAF805","user_header":"https://static001.geekbang.org/account/avatar/00/16/0a/83/f916f903.jpg","comment_is_top":false,"comment_ctime":1569745946,"is_pvip":false,"replies":[{"id":"53880","content":"看你用C语言做了很多实践，非常好！<br>针对你的问题，也跟你探讨一下：<br>1.每门语言都有它的优势。很多编译器都是用C&#47;C++编写的，比如可以更灵活的对内存管理，就是优势呀。JVM的实现，也没法用Java，还是要用比较底层的语言。<br>2.错误处理这个问题比较复杂。最好的情况，是我们知道哪一个小范围是有错的，对这个部分报错，但其他部分继续处理。比如，你调用一个函数时，监测出参数的数量错了，但其他部分仍然可以继续去解析和处理。如果碰到一个错误，就完全停下，那也不行。这样做IDE的时候，就不够友好和智能。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1570706320,"ip_address":"","comment_id":137458,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40224451610","product_id":100034101,"comment_content":"C语言实现：<br>https:&#47;&#47;github.com&#47;KiLuYa&#47;simpleScript<br><br>C语言，没有现成的数据结构，没有 try catch throw 处理错误的机制，没有虚拟机的垃圾回收机制，感觉实现起来比Java要麻烦很多，尤其是繁琐的错误码判断，以及程序流程在多分支下的内存的手动申请和释放。<br>遇到过一个国外公司的产品，它提供了脚本语言，但用户写程序，如果某一行有个语法bug，编译报错时，它会报连续十几行的错。学完这节内容就知道，应该是它的parser没有在检测到语法错误时停下来，还傻傻地带着错误继续parse，直到所有token都被处理掉。","like_count":10,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469104,"discussion_content":"看你用C语言做了很多实践，非常好！\n针对你的问题，也跟你探讨一下：\n1.每门语言都有它的优势。很多编译器都是用C/C++编写的，比如可以更灵活的对内存管理，就是优势呀。JVM的实现，也没法用Java，还是要用比较底层的语言。\n2.错误处理这个问题比较复杂。最好的情况，是我们知道哪一个小范围是有错的，对这个部分报错，但其他部分继续处理。比如，你调用一个函数时，监测出参数的数量错了，但其他部分仍然可以继续去解析和处理。如果碰到一个错误，就完全停下，那也不行。这样做IDE的时候，就不够友好和智能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570706320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139024,"user_name":"缺个豆饼吗","can_delete":false,"product_type":"c1","uid":1390212,"ip_address":"","ucode":"EF050C820E4E17","user_header":"https://static001.geekbang.org/account/avatar/00/15/36/84/e19b05dd.jpg","comment_is_top":false,"comment_ctime":1570528309,"is_pvip":false,"replies":[{"id":"53812","content":"棒！TypeScript版本的！","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1570675701,"ip_address":"","comment_id":139024,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23045364789","product_id":100034101,"comment_content":"https:&#47;&#47;github.com&#47;yuguomin&#47;my-compiler<br>老师，作业来啦～","like_count":5,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469752,"discussion_content":"棒！TypeScript版本的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570675701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127320,"user_name":"LDxy","can_delete":false,"product_type":"c1","uid":1188710,"ip_address":"","ucode":"956432CE7B7761","user_header":"https://static001.geekbang.org/account/avatar/00/12/23/66/413c0bb5.jpg","comment_is_top":false,"comment_ctime":1566653675,"is_pvip":false,"replies":[{"id":"47377","content":"对。如果正则表达式的内部实现是基于NFA的，就会有这个问题。<br>NFA和DFA这个知识点不适合在前期讲，会把初学者搞晕。我准备在后面找个机会放入这个知识点。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1566798629,"ip_address":"","comment_id":127320,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18746522859","product_id":100034101,"comment_content":"正则表达式匹配文本的时候也会导致回溯吧？好像还有可能因此导致严重的性能问题","like_count":4,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464438,"discussion_content":"对。如果正则表达式的内部实现是基于NFA的，就会有这个问题。\nNFA和DFA这个知识点不适合在前期讲，会把初学者搞晕。我准备在后面找个机会放入这个知识点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566798629,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127316,"user_name":"ct","can_delete":false,"product_type":"c1","uid":1055035,"ip_address":"","ucode":"00B2F7302915D8","user_header":"https://static001.geekbang.org/account/avatar/00/10/19/3b/0ad9b613.jpg","comment_is_top":false,"comment_ctime":1566649951,"is_pvip":false,"replies":[{"id":"47350","content":"你用的这个在线工具很酷。可以提供一个运行环境直接跑！很棒！<br>我玩了好一会 :-D","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1566792965,"ip_address":"","comment_id":127316,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18746519135","product_id":100034101,"comment_content":"根据老师讲解，实现了一个 golang 的版本 https:&#47;&#47;repl.it&#47;@catplanet007&#47;simple-interpreter","like_count":4,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464435,"discussion_content":"你用的这个在线工具很酷。可以提供一个运行环境直接跑！很棒！\n我玩了好一会 :-D","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566792965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127284,"user_name":"wj","can_delete":false,"product_type":"c1","uid":1538547,"ip_address":"","ucode":"919FBD55C01A66","user_header":"https://static001.geekbang.org/account/avatar/00/17/79/f3/2d5ce916.jpg","comment_is_top":false,"comment_ctime":1566634020,"is_pvip":false,"replies":[{"id":"47359","content":"你提了一个好问题。<br>其实，人工智能的发展史经历了两个不同的路径。 早期，更多的是演绎逻辑。就是人为制定规则，比如自然语言翻译的规则，并不断执行这些规则。<br>第二条路径，是最近复兴的机器学习的方法。它更多的是归纳逻辑。机器学习是通过数据的训练，把规则归纳出来。这些归纳出来的规则目前还是比较黑盒的，人比较难以解读，但却很有用，更加准确。<br>你的需求场景用这两种方法应该都能解决，只不过落地时还要考虑很多细节和限制因素。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1566793981,"ip_address":"","comment_id":127284,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18746503204","product_id":100034101,"comment_content":"老师, 还有个问题, 借此文问一下, 词法分析\\语法分析等和机器学习有什么交集吗? 我有个场景想比较两个java文件的匹配度, 或者两段代码的匹配度, 不知道机器学习在这个场景是否可以应用, 以及如何应用呢?谢谢~","like_count":4,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464414,"discussion_content":"你提了一个好问题。\n其实，人工智能的发展史经历了两个不同的路径。 早期，更多的是演绎逻辑。就是人为制定规则，比如自然语言翻译的规则，并不断执行这些规则。\n第二条路径，是最近复兴的机器学习的方法。它更多的是归纳逻辑。机器学习是通过数据的训练，把规则归纳出来。这些归纳出来的规则目前还是比较黑盒的，人比较难以解读，但却很有用，更加准确。\n你的需求场景用这两种方法应该都能解决，只不过落地时还要考虑很多细节和限制因素。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566793981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":267087,"user_name":"Fan","can_delete":false,"product_type":"c1","uid":1115232,"ip_address":"","ucode":"3BF28670FD9407","user_header":"https://static001.geekbang.org/account/avatar/00/11/04/60/64d166b6.jpg","comment_is_top":false,"comment_ctime":1607591816,"is_pvip":false,"replies":[{"id":"98486","content":"你看第二遍了？为你点赞！看来你对编译是真有兴趣，可以考虑把这个方向变成自己的技术专长，去干一点有深度的事情。<br><br>书的话，已经在整理，进度有点慢:-(<br>因为我又给自己挖了坑，想达到两个目标：<br>1.要求更加浅显易懂，再复杂的问题，也要简单说明白；<br>2.里面的例子用自己设计的语言。<br>所以...<br>我后面加快进度:-)","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1609737889,"ip_address":"","comment_id":267087,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14492493704","product_id":100034101,"comment_content":"😂，又看了一次。建议老师可以把这两个专栏的内容集结后出书。","like_count":3,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511502,"discussion_content":"你看第二遍了？为你点赞！看来你对编译是真有兴趣，可以考虑把这个方向变成自己的技术专长，去干一点有深度的事情。\n\n书的话，已经在整理，进度有点慢:-(\n因为我又给自己挖了坑，想达到两个目标：\n1.要求更加浅显易懂，再复杂的问题，也要简单说明白；\n2.里面的例子用自己设计的语言。\n所以...\n我后面加快进度:-)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609737889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042842,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e9/9a/1d9e1d9a.jpg","nickname":"北极点","note":"","ucode":"476820AE0AAA6E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353227,"discussion_content":"我也是看第二遍的时候有感觉的，目前思路能跟的上老师讲的了，后面的章节继续。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615085667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1115232,"avatar":"https://static001.geekbang.org/account/avatar/00/11/04/60/64d166b6.jpg","nickname":"Fan","note":"","ucode":"3BF28670FD9407","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339748,"discussion_content":"有些没看完，有些看了不止一遍。😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609767901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130769,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1567529881,"is_pvip":false,"replies":[{"id":"49385","content":"点赞！","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1567654092,"ip_address":"","comment_id":130769,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10157464473","product_id":100034101,"comment_content":"本讲 Swift 版本实现：<br><br>https:&#47;&#47;github.com&#47;iostalks&#47;PlayWithCompiler&#47;tree&#47;lecture-5<br><br>欢迎参考。","like_count":2,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466113,"discussion_content":"点赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567654092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1763603,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epDGb8dkicTpmr4ic37dzEngibHQ0BvZyToQhsD0icMy2qxqiaJelYpPqzzkTfXsCibqjwbkK94beYC0N6Q/132","nickname":"空山新雨后","note":"","ucode":"5F945AFB45AE42","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288656,"discussion_content":"请问一下这个swift版本的程序能在命令行单独执行么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593833191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127483,"user_name":"中年男子","can_delete":false,"product_type":"c1","uid":1039204,"ip_address":"","ucode":"027C86B3370150","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","comment_is_top":false,"comment_ctime":1566727363,"is_pvip":true,"replies":[{"id":"47310","content":"谢谢肯定！<br>编译原理这门课，是学原理可能学不懂。但真正动手，其实都能写出来。早期写编译器的先驱并没有编译原理课。<br>并且，很多具体实现过程，是可以偏离死搬教条的原理的。比如，理想情况下要设计无二义性文法。实际应用中，只要针对某个具体算法是无二义的就行了。能实际有用才是硬道理。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1566787888,"ip_address":"","comment_id":127483,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10156661955","product_id":100034101,"comment_content":"有了前几讲的基础，这一讲很轻松搞定，根据宫老师的java代码我实现了C++版本，其中一些不太清晰的概念通过代码也理解了，老师真的很棒！","like_count":2,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464517,"discussion_content":"谢谢肯定！\n编译原理这门课，是学原理可能学不懂。但真正动手，其实都能写出来。早期写编译器的先驱并没有编译原理课。\n并且，很多具体实现过程，是可以偏离死搬教条的原理的。比如，理想情况下要设计无二义性文法。实际应用中，只要针对某个具体算法是无二义的就行了。能实际有用才是硬道理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566787888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127174,"user_name":"安排","can_delete":false,"product_type":"c1","uid":1260026,"ip_address":"","ucode":"F78CFA9624CAEF","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg","comment_is_top":false,"comment_ctime":1566576833,"is_pvip":false,"replies":[{"id":"47365","content":"加油！","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1566794489,"ip_address":"","comment_id":127174,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10156511425","product_id":100034101,"comment_content":"有点感觉了，哈哈😄","like_count":2,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464355,"discussion_content":"加油！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566794489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153951,"user_name":"Amber","can_delete":false,"product_type":"c1","uid":1496037,"ip_address":"","ucode":"EDCB252D72D3D3","user_header":"https://static001.geekbang.org/account/avatar/00/16/d3/e5/08dad30d.jpg","comment_is_top":false,"comment_ctime":1574336105,"is_pvip":true,"replies":[{"id":"59569","content":"负数有两种处理办法：<br>1.在词法分析阶段，就把它作为一个字面量提取出来。这有一定的难度。比如，a - 3和 a - -3要能准确地把减号和负号区分开。但也不是不能做到。<br>2.把减号作为一元运算符处理。<br>示例用的语法规则，是按照第二种方式处理的。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1574667284,"ip_address":"","comment_id":153951,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5869303401","product_id":100034101,"comment_content":"表达式负数怎么处理呢？","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475334,"discussion_content":"负数有两种处理办法：\n1.在词法分析阶段，就把它作为一个字面量提取出来。这有一定的难度。比如，a - 3和 a - -3要能准确地把减号和负号区分开。但也不是不能做到。\n2.把减号作为一元运算符处理。\n示例用的语法规则，是按照第二种方式处理的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574667284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121817,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1e/19/a235f31d.jpg","nickname":"云淡风轻","note":"","ucode":"D6903A0FCEBC58","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289188,"discussion_content":"对负号的处理，以下是伪代码，可以参考以下，在Primary 中优先处理 ParseNegative()\nParseNegative:\n    node = null\n    token = reader.peek()\n    if TokenType::Minus == token.type:\n        reader.read()\n        node = SimpleASTNode(Negative, toke.text)\n        \n        child = Primary(reader);\n        if(child != null)\n            node.addChild(child)\n        else\n            throw exception(...)\n     \n     return node","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594020986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142402,"user_name":"Sudouble","can_delete":false,"product_type":"c1","uid":1365574,"ip_address":"","ucode":"B369B09DAF8D20","user_header":"https://static001.geekbang.org/account/avatar/00/14/d6/46/5eb5261b.jpg","comment_is_top":false,"comment_ctime":1571363432,"is_pvip":true,"replies":[{"id":"57581","content":"看到你的github空间里有好几个项目，学习力很强！<br><br>另外，能否把你的项目整个cmake文件，便于我编译运行？:)","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1573344027,"ip_address":"","comment_id":142402,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5866330728","product_id":100034101,"comment_content":"跟着课程做，一下就明白了。打卡第五节课<br>https:&#47;&#47;github.com&#47;potterhere&#47;TheBeautyOfCompiling&#47;tree&#47;master&#47;w5_ReadEvalPrintLoop","like_count":2,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471108,"discussion_content":"看到你的github空间里有好几个项目，学习力很强！\n\n另外，能否把你的项目整个cmake文件，便于我编译运行？:)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573344027,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1365574,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d6/46/5eb5261b.jpg","nickname":"Sudouble","note":"","ucode":"B369B09DAF8D20","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49077,"discussion_content":"嗯嗯~  :)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573551999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137423,"user_name":"阿尔伯特","can_delete":false,"product_type":"c1","uid":1300012,"ip_address":"","ucode":"70B8EA81FAD7BB","user_header":"https://static001.geekbang.org/account/avatar/00/13/d6/2c/9aa0ae40.jpg","comment_is_top":false,"comment_ctime":1569738510,"is_pvip":false,"replies":[{"id":"53882","content":"首先，赋值在C和Java里都是表达式，跟加法表达式没啥区别，它也是有值的。<br>第二，确实可以通过语法规则的设计来避免冲突，包括避免回溯。<br>","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1570706677,"ip_address":"","comment_id":137423,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5864705806","product_id":100034101,"comment_content":"https:&#47;&#47;github.com&#47;albertabc&#47;compiler<br>继续攒代码。我在老师前面几节的基础上写的本讲的一个sample。老师在本讲重点讲解了回溯。但是我在实现中仔细想了想。<br>exp -&gt; or | or = exp<br>上次课的第一条语法规则其实是针对表达式的，但是这条规则，事实上是合并了表达式语句和赋值语句。所以本节的新的语法规则是不是可以就优化掉。<br>这里一旦不区分普通表达式，和赋值语句，也就避免了一次回溯。<br>从中，是不是可以有这样的推论，就好像用EBNF，可以通过语法规则的变换来避免左递归，也同样用规则来减少回溯？<br>谢谢老师。","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469082,"discussion_content":"首先，赋值在C和Java里都是表达式，跟加法表达式没啥区别，它也是有值的。\n第二，确实可以通过语法规则的设计来避免冲突，包括避免回溯。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570706677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133928,"user_name":"曾经瘦过","can_delete":false,"product_type":"c1","uid":1240106,"ip_address":"","ucode":"57C32575A1C1FD","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/2a/b11d5ad8.jpg","comment_is_top":false,"comment_ctime":1568701242,"is_pvip":false,"replies":[{"id":"57580","content":"这个“感觉”很重要。保持好。遇到挫折也不要在意！","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1573343759,"ip_address":"","comment_id":133928,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5863668538","product_id":100034101,"comment_content":"学完了这部分之后 感觉 其实编译没有想的那么复杂，通过递归下降，对所有的可能做了处理.不符合的可能回溯 去匹配其他的. 有点感觉了，希望可以一步一步啃下编译原理","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467558,"discussion_content":"这个“感觉”很重要。保持好。遇到挫折也不要在意！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573343759,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132739,"user_name":"nil","can_delete":false,"product_type":"c1","uid":1507193,"ip_address":"","ucode":"0F5D298C1CBB74","user_header":"https://static001.geekbang.org/account/avatar/00/16/ff/79/3b38c9e1.jpg","comment_is_top":false,"comment_ctime":1568209056,"is_pvip":false,"replies":[{"id":"51376","content":"感谢分享！<br>一起加油！","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1568697865,"ip_address":"","comment_id":132739,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5863176352","product_id":100034101,"comment_content":"老师你好，看到回溯这个关键字，让我想起学生时代解八皇后问题，用的就是试探&amp;回溯。也是通过八皇后体会到了递归的美妙。递归思维比较符合人的思维，而循环更符合计算机。看了老师的一系列文章，现在对编译原理没有这么惧怕了，一旦揭开技术神秘的面纱后，展现在眼前的只剩下一片美妙！加油！","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467101,"discussion_content":"感谢分享！\n一起加油！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568697865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128538,"user_name":"windpiaoxue","can_delete":false,"product_type":"c1","uid":1258079,"ip_address":"","ucode":"3769AAFFB61814","user_header":"https://static001.geekbang.org/account/avatar/00/13/32/5f/0c870296.jpg","comment_is_top":false,"comment_ctime":1566897991,"is_pvip":false,"replies":[{"id":"47795","content":"看了，非常不错！点赞！<br>连README.md都写得很清晰。<br>你学习的效率很高呀！<br>而且看来你有C语言的基础，所以到时学后端技术你也会毫不费力呀！","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1566958401,"ip_address":"","comment_id":128538,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5861865287","product_id":100034101,"comment_content":"参考03-05实现的c语言版本<br>https:&#47;&#47;github.com&#47;windpiaoxue&#47;simple_script.git","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464986,"discussion_content":"看了，非常不错！点赞！\n连README.md都写得很清晰。\n你学习的效率很高呀！\n而且看来你有C语言的基础，所以到时学后端技术你也会毫不费力呀！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566958401,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127070,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1566549685,"is_pvip":false,"replies":[{"id":"47015","content":"是的。<br>很多时候，做某件事情真正的阻力是畏惧，是根本不去做...","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1566554191,"ip_address":"","comment_id":127070,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5861516981","product_id":100034101,"comment_content":"老师讲得好啊，不要给自己设天花板，不断努力，成功最终会属于你。","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464304,"discussion_content":"是的。\n很多时候，做某件事情真正的阻力是畏惧，是根本不去做...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566554191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126911,"user_name":"雲至","can_delete":false,"product_type":"c1","uid":1568487,"ip_address":"","ucode":"47E2D099322BB1","user_header":"https://static001.geekbang.org/account/avatar/00/17/ee/e7/4375e97c.jpg","comment_is_top":false,"comment_ctime":1566520484,"is_pvip":false,"replies":[{"id":"46973","content":"是verbose吧？也就是启动“话痨”模式，打印输出等多信息。<br>有一些linux命令习惯上会用-v参数来表达这个意思 :-D","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1566529985,"ip_address":"","comment_id":126911,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5861487780","product_id":100034101,"comment_content":"老师   那个verbase是什么意思呀","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464240,"discussion_content":"是verbose吧？也就是启动“话痨”模式，打印输出等多信息。\n有一些linux命令习惯上会用-v参数来表达这个意思 :-D","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566529985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1039204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","nickname":"中年男子","note":"","ucode":"027C86B3370150","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6149,"discussion_content":"一些库也会有verbose模式，比如libcurl可以设置verbose模式来打印请求头和响应头，这对调试有极大的方便","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566727232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339054,"user_name":"邹仁","can_delete":false,"product_type":"c1","uid":2808693,"ip_address":"","ucode":"52B6125F2EC325","user_header":"https://static001.geekbang.org/account/avatar/00/2a/db/75/f5e9d8f0.jpg","comment_is_top":false,"comment_ctime":1647874477,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647874477","product_id":100034101,"comment_content":"因为老师这边用的是Java,然后我比较喜欢用C++，看到代码中的SimpleASTNode这个类没有源码，于是我自己写了文法在C++上实现了这个解析器，也是支持变量声明和赋值表达式等运算，AST的打印<br>https:&#47;&#47;github.com&#47;arqqqq&#47;SimpleScript","like_count":0},{"had_liked":false,"id":327411,"user_name":"严长友","can_delete":false,"product_type":"c1","uid":1088542,"ip_address":"","ucode":"03BF97521D11FB","user_header":"https://static001.geekbang.org/account/avatar/00/10/9c/1e/db1ee238.jpg","comment_is_top":false,"comment_ctime":1640104727,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640104727","product_id":100034101,"comment_content":"实现到表达式和简单语句部分，处理else if时遇了困难，过来学习学习<br><br>http:&#47;&#47;hello.321zou.com&#47;play&#47;playground.html","like_count":0},{"had_liked":false,"id":281955,"user_name":"饭","can_delete":false,"product_type":"c1","uid":1610573,"ip_address":"","ucode":"B3F1702D4DE604","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJKj3GbvevFibxwJibTqm16NaE8MXibwDUlnt5tt73KF9WS2uypha2m1Myxic6Q47Zaj2DZOwia3AgicO7Q/132","comment_is_top":false,"comment_ctime":1614991274,"is_pvip":false,"replies":[{"id":"102424","content":"“递归下降”是学习编译原理中的一个关键概念，掌握这种关键概念在学习过程中很重要，所以这里我再试图直白地解释一下递归下降：<br>首先是“递归”：这里可以借鉴你对递归函数的理解。递归是计算机科学中解决问题的一个重要的、基础的思维方式，它的核心，是在解决一个问题的时候，把它分解为解决一个个的子问题。而解决每个子问题的方法与解决父问题的方法是一致的、同构的。<br>放到语法分析领域，解析器的目的是要构建一棵AST树。要构建这棵AST树，那么就要构建它的各个子树，然后组装成最后的AST。比如，一个程序是由一个函数声明和一个函数调用语句构成的：<br>int foo(){<br>  &#47;&#47;do something<br>}<br>foo();<br>那么这个AST就有两棵子树，第一棵是foo函数的声明，第二棵是对foo函数的调用。采用递归思路，那么就首先解析出两棵子树，然后再组装出最后的AST。而对于每棵子树呢，也是采用相同的思路。<br><br>接着是“下降”：从上面的描述可以看到，在用递归方法解析AST的时候，是沿着AST层层下降地去尝试匹配一个语法规则的。这就是下降的含义。更具体一点，采用递归下降算法，总是采用深度优先的策略，先解析最左子节点，然后解析最左子节点的最左子节点。等着这棵子树完全构建完毕了，再构建第二棵子树。<br><br>上面就是对“递归下降”这个概念的阐述。理解了递归下降的处理过程以后，你会发现它可能会导致两个问题，一个是“回溯”，一个是不能处理左递归文法。至于为何如此，你在后面的课程里可以继续学习！<br>此外，我们这里算法是深度优先，其实你也可以宽度优先地自顶向下解析，我在算法篇里有介绍。<br>所以，理解了“递归下降”的核心概念，再顺藤摸瓜，你会获得一连串的知识，让知识体系越来越完整。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1615086742,"ip_address":"","comment_id":281955,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1614991274","product_id":100034101,"comment_content":"老师，语法分析这三篇看了两遍，算是看懂了。简单讲做的是这么一件事：<br>1先根据自己设计的语句语法设计文法规则。<br>2然后将根据文法规则构建成语法树的数据结构，3最后用递归遍历树解释执行，<br>只是递归下降这个术语还是没明白，通俗讲是说哪一件事了","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516561,"discussion_content":"“递归下降”是学习编译原理中的一个关键概念，掌握这种关键概念在学习过程中很重要，所以这里我再试图直白地解释一下递归下降：\n首先是“递归”：这里可以借鉴你对递归函数的理解。递归是计算机科学中解决问题的一个重要的、基础的思维方式，它的核心，是在解决一个问题的时候，把它分解为解决一个个的子问题。而解决每个子问题的方法与解决父问题的方法是一致的、同构的。\n放到语法分析领域，解析器的目的是要构建一棵AST树。要构建这棵AST树，那么就要构建它的各个子树，然后组装成最后的AST。比如，一个程序是由一个函数声明和一个函数调用语句构成的：\nint foo(){\n  //do something\n}\nfoo();\n那么这个AST就有两棵子树，第一棵是foo函数的声明，第二棵是对foo函数的调用。采用递归思路，那么就首先解析出两棵子树，然后再组装出最后的AST。而对于每棵子树呢，也是采用相同的思路。\n\n接着是“下降”：从上面的描述可以看到，在用递归方法解析AST的时候，是沿着AST层层下降地去尝试匹配一个语法规则的。这就是下降的含义。更具体一点，采用递归下降算法，总是采用深度优先的策略，先解析最左子节点，然后解析最左子节点的最左子节点。等着这棵子树完全构建完毕了，再构建第二棵子树。\n\n上面就是对“递归下降”这个概念的阐述。理解了递归下降的处理过程以后，你会发现它可能会导致两个问题，一个是“回溯”，一个是不能处理左递归文法。至于为何如此，你在后面的课程里可以继续学习！\n此外，我们这里算法是深度优先，其实你也可以宽度优先地自顶向下解析，我在算法篇里有介绍。\n所以，理解了“递归下降”的核心概念，再顺藤摸瓜，你会获得一连串的知识，让知识体系越来越完整。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615086742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1610573,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJKj3GbvevFibxwJibTqm16NaE8MXibwDUlnt5tt73KF9WS2uypha2m1Myxic6Q47Zaj2DZOwia3AgicO7Q/132","nickname":"饭","note":"","ucode":"B3F1702D4DE604","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353271,"discussion_content":"谢谢老师，我又明白了一些。接下来按照您文中实例再实现体验一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615107631,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":278610,"user_name":"宋捷","can_delete":false,"product_type":"c1","uid":1333006,"ip_address":"","ucode":"7905BABF1D8DDD","user_header":"https://static001.geekbang.org/account/avatar/00/14/57/0e/36847d8c.jpg","comment_is_top":false,"comment_ctime":1613127924,"is_pvip":false,"replies":[{"id":"102114","content":"Great!<br>看到了，Readme.md也写得很好！<br>在代码提交备注里还看到了一颗漂亮的树:)","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1614650480,"ip_address":"","comment_id":278610,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1613127924","product_id":100034101,"comment_content":"node起服务的命令行执行脚本成功啦！！！谢谢老师！代码在这里啦https:&#47;&#47;github.com&#47;superjunjin&#47;compiler","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515446,"discussion_content":"Great!\n看到了，Readme.md也写得很好！\n在代码提交备注里还看到了一颗漂亮的树:)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614650480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250377,"user_name":"阿八不要做码农","can_delete":false,"product_type":"c1","uid":1230156,"ip_address":"","ucode":"8F3BE58291CC40","user_header":"https://static001.geekbang.org/account/avatar/00/12/c5/4c/c3ad7e30.jpg","comment_is_top":false,"comment_ctime":1601041431,"is_pvip":false,"replies":[{"id":"94602","content":"这是实现的具体细节。<br><br>数组也一样方便回溯，只要你提前记住当前的数组下标，然后在回溯的时候回到这个下标的位置就好。<br><br>采用Reader模式真正的好处，是可以实现流的机制，也就是说，你没必要一次性的做完所有的词法分析工作，而是按需去做。在Parser需要一个Token的时候，再去按需的解析，从而节省存储资源。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1605059706,"ip_address":"","comment_id":250377,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1601041431","product_id":100034101,"comment_content":"老师，一开始我使用数组存储 tokens, 一直没有问题。直到回溯的时候，发现 TokenReader 类更方便回溯，我这样理解对的吗？","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506195,"discussion_content":"这是实现的具体细节。\n\n数组也一样方便回溯，只要你提前记住当前的数组下标，然后在回溯的时候回到这个下标的位置就好。\n\n采用Reader模式真正的好处，是可以实现流的机制，也就是说，你没必要一次性的做完所有的词法分析工作，而是按需去做。在Parser需要一个Token的时候，再去按需的解析，从而节省存储资源。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605059706,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246671,"user_name":"Ivan.Qi","can_delete":false,"product_type":"c1","uid":1099170,"ip_address":"","ucode":"36F46A4D1F0EAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/c5/a2/4ece341b.jpg","comment_is_top":false,"comment_ctime":1599449919,"is_pvip":false,"replies":[{"id":"91249","content":"Great!","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1600174915,"ip_address":"","comment_id":246671,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1599449919","product_id":100034101,"comment_content":"C++ SimpleScript<br>https:&#47;&#47;github.com&#47;Ivanqi&#47;CompilationPrinciple&#47;tree&#47;master&#47;craft&#47;tests&#47;SimpleScript","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505202,"discussion_content":"Great!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600174915,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232480,"user_name":"云淡风轻","can_delete":false,"product_type":"c1","uid":1121817,"ip_address":"","ucode":"D6903A0FCEBC58","user_header":"https://static001.geekbang.org/account/avatar/00/11/1e/19/a235f31d.jpg","comment_is_top":false,"comment_ctime":1594015477,"is_pvip":false,"replies":[{"id":"86334","content":"课程中的例子只是用来做示意，有时会故意制造点难题。<br>在实际的语言的编译器中，赋值语句一版不会作为一种单独的语句，而是把分号前面的部分作为一个赋值表达式就可以了。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1594553923,"ip_address":"","comment_id":232480,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1594015477","product_id":100034101,"comment_content":"老师您好：<br>原文中的这个表达式：<br>statement: intDeclaration| expressionStatement| assignmentStatement;<br>是否可以优化为：<br>statement: intDeclaration | assignmentStatement | expressionStatement;<br><br>我自己在实现的时候，发现下面的表达式逻辑更清楚一些，而且在 expressionStatement 匹配失败的时候就可以直接抛异常，不用再回溯了。","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500663,"discussion_content":"课程中的例子只是用来做示意，有时会故意制造点难题。\n在实际的语言的编译器中，赋值语句一版不会作为一种单独的语句，而是把分号前面的部分作为一个赋值表达式就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594553923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219618,"user_name":"王成","can_delete":false,"product_type":"c1","uid":1441460,"ip_address":"","ucode":"29765BBCD3B8B2","user_header":"https://static001.geekbang.org/account/avatar/00/15/fe/b4/6902ac00.jpg","comment_is_top":false,"comment_ctime":1590051850,"is_pvip":false,"replies":[{"id":"82312","content":"感谢分享！恭喜你的进展！","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1591081139,"ip_address":"","comment_id":219618,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590051850","product_id":100034101,"comment_content":"说下学完这一课的感受:)<br>1.以前感觉特别神秘的编译原理，现在感觉越来越有意思了<br>2.上一课完了之后，在原课程代码的基础上，加入了按位与或非操作，加入了幂次操作，加入了取余操作，同时发现所有左递归的双目运算符都有相同的逻辑，所以把除了primary之外的方法整合为了一个方法，同时在primary中增加对于按位非的操作，看到测试结果完美展示的时候，感觉开心极了","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495877,"discussion_content":"感谢分享！恭喜你的进展！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591081139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200309,"user_name":"forest","can_delete":false,"product_type":"c1","uid":1032203,"ip_address":"","ucode":"DC46B4CF951EFE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c0/0b/e416f0f1.jpg","comment_is_top":false,"comment_ctime":1585571279,"is_pvip":false,"replies":[{"id":"76612","content":"用你习惯的语言就好！很多同学都在用自己熟悉的语言来写，有C、Go、JavaScript、Swift、TypeScript等等很多。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1586513871,"ip_address":"","comment_id":200309,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585571279","product_id":100034101,"comment_content":"老师你好，我是搞iOS的，我直接按照你的java代码来敲java可以么，还是说我用oc或者swift还是c++来实现才能达到这门课的学习效果呢","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489991,"discussion_content":"用你习惯的语言就好！很多同学都在用自己熟悉的语言来写，有C、Go、JavaScript、Swift、TypeScript等等很多。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586513871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200134,"user_name":"宋健","can_delete":false,"product_type":"c1","uid":1283082,"ip_address":"","ucode":"7DD1CAB40440C3","user_header":"https://static001.geekbang.org/account/avatar/00/13/94/0a/7f7c9b25.jpg","comment_is_top":false,"comment_ctime":1585548318,"is_pvip":false,"replies":[{"id":"76642","content":"也替你高兴！","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1586524275,"ip_address":"","comment_id":200134,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585548318","product_id":100034101,"comment_content":"老师讲的太棒了！！<br>终于花了三天时间，把3-5章看了好多遍，终于完成了自己的编译器！！<br>太开心了","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489944,"discussion_content":"也替你高兴！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586524275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184388,"user_name":"阿东","can_delete":false,"product_type":"c1","uid":1500320,"ip_address":"","ucode":"E9393F62B4091D","user_header":"https://static001.geekbang.org/account/avatar/00/16/e4/a0/62a8b07e.jpg","comment_is_top":false,"comment_ctime":1583304921,"is_pvip":false,"replies":[{"id":"74154","content":"我点进去看了看。不错不错！<br>能真正上手去实现的同学，未来都大有前途！","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1585132366,"ip_address":"","comment_id":184388,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1583304921","product_id":100034101,"comment_content":"花了好几天时间，用ts实现了简单版本<br>https:&#47;&#47;github.com&#47;he1514133606&#47;The-Little-Compilation","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485997,"discussion_content":"我点进去看了看。不错不错！\n能真正上手去实现的同学，未来都大有前途！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585132366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164289,"user_name":"七月有风","can_delete":false,"product_type":"c1","uid":1439990,"ip_address":"","ucode":"B3F82397347C5B","user_header":"https://static001.geekbang.org/account/avatar/00/15/f8/f6/3e2db176.jpg","comment_is_top":false,"comment_ctime":1576925845,"is_pvip":false,"replies":[{"id":"63364","content":"语义的部分后面专门有好几讲来深入展开，比如类型检查等。这讲先让代码简单地运行起来。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1577431670,"ip_address":"","comment_id":164289,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576925845","product_id":100034101,"comment_content":"学到这而比较迷惑，通过语法分析，得到的是一棵抽象语法树，让脚本运行出结果，是怎么处理语义解释的。","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478711,"discussion_content":"语义的部分后面专门有好几讲来深入展开，比如类型检查等。这讲先让代码简单地运行起来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577431670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132438,"user_name":"宇智波芭芭干","can_delete":false,"product_type":"c1","uid":1477509,"ip_address":"","ucode":"AB95FA5B073079","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKQBotbJDGmnxL1ib3yD2XI7HfRcLMLmNfMXEIIebWaT9q2fvmTYm7lfISgic4W7BZ5r4Jtib9iawEJhg/132","comment_is_top":false,"comment_ctime":1568122526,"is_pvip":false,"replies":[{"id":"50727","content":"谢谢你的建议！<br>好的，我会在迭代版本中改进！","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1568181498,"ip_address":"","comment_id":132438,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568122526","product_id":100034101,"comment_content":"描述算法逻辑时建议采用流程图的形式，一个清晰的流程图一目了然，远不是一大段啰嗦的文字可比的","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466938,"discussion_content":"谢谢你的建议！\n好的，我会在迭代版本中改进！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568181498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127283,"user_name":"wj","can_delete":false,"product_type":"c1","uid":1538547,"ip_address":"","ucode":"919FBD55C01A66","user_header":"https://static001.geekbang.org/account/avatar/00/17/79/f3/2d5ce916.jpg","comment_is_top":false,"comment_ctime":1566633864,"is_pvip":false,"replies":[{"id":"47360","content":"可以参考成熟的语法规则文件，去琢磨。<br>大致来说，你从字面意思来理解它就好了。比如语句、表达式、二元表达式。<br>本课程都是倾向于采用这种有意义的单词，而不是像教科书那样只写一个字母，太抽象。<br>而在实际工程中，我们总是让自己的语法单元更具可读性，这样更实用。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1566794226,"ip_address":"","comment_id":127283,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566633864","product_id":100034101,"comment_content":"老师, 我发现对一些基本术语, 比如 Statement, expression, binaryExpression, 等不太会分辨, 请问有什么书或资料可以推荐系统看一下吗? 谢谢","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464413,"discussion_content":"可以参考成熟的语法规则文件，去琢磨。\n大致来说，你从字面意思来理解它就好了。比如语句、表达式、二元表达式。\n本课程都是倾向于采用这种有意义的单词，而不是像教科书那样只写一个字母，太抽象。\n而在实际工程中，我们总是让自己的语法单元更具可读性，这样更实用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566794226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127156,"user_name":"沉淀的梦想","can_delete":false,"product_type":"c1","uid":1177315,"ip_address":"","ucode":"BCB7C26F9D214B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg","comment_is_top":false,"comment_ctime":1566570665,"is_pvip":false,"replies":[{"id":"47378","content":"为你的动脑思考点赞！<br>泛型语法，嗯嗯有可能。<br>深度优先算法的回溯，时间复杂性（大O）不是指数的。广度优先的才是指数的。这个在15讲会再总结一遍。<br>深度优先算法，实际浪费不多，所以是有实用价值的一个算法。再加上预测功能就完美了。讲LL算法的时候会再回过来说这个事情。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1566798912,"ip_address":"","comment_id":127156,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566570665","product_id":100034101,"comment_content":"Java中的范型语法应该是需要回溯的。感觉计算时间的浪费和代码长度应该是指数关系。","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464347,"discussion_content":"为你的动脑思考点赞！\n泛型语法，嗯嗯有可能。\n深度优先算法的回溯，时间复杂性（大O）不是指数的。广度优先的才是指数的。这个在15讲会再总结一遍。\n深度优先算法，实际浪费不多，所以是有实用价值的一个算法。再加上预测功能就完美了。讲LL算法的时候会再回过来说这个事情。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566798912,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126908,"user_name":"雲至","can_delete":false,"product_type":"c1","uid":1568487,"ip_address":"","ucode":"47E2D099322BB1","user_header":"https://static001.geekbang.org/account/avatar/00/17/ee/e7/4375e97c.jpg","comment_is_top":false,"comment_ctime":1566520424,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566520424","product_id":100034101,"comment_content":"老师  那个verbase是什么变量呀","like_count":0}]}