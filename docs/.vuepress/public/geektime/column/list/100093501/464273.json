{"id":464273,"title":"23｜函数：怎么让函数更简洁健壮？","content":"<p>你好，我是Tony Bai。</p><p>在上一节中，我们开始学习函数设计的相关知识，学习了如何基于Go函数的多返回值机制进行函数错误值构造方式的设计，你还记得那几种错误值构造与处理的策略吗？当然，良好的函数设计不仅仅要包含错误设计，函数的健壮性与简洁优雅也是我们在函数设计过程中要考虑的问题。</p><p>健壮的函数意味着，无论调用者如何使用你的函数，你的函数都能以合理的方式处理调用者的任何输入，并给调用者返回预设的、清晰的错误值。即便你的函数发生内部异常，函数也会尽力从异常中恢复，尽可能地不让异常蔓延到整个程序。而简洁优雅，则意味着函数的实现易读、易理解、更易维护，同时简洁也意味着统计意义上的更少的bug。</p><p>这一节课，我们就将继续我们的函数设计之旅，聚焦在健壮与简洁这两方面，我们需要重点关注的内容。</p><p>我们先从健壮性开始。</p><h2>健壮性的“三不要”原则</h2><p>函数的健壮性设计包括很多方面，首先就有最基本的“三不要”原则，我们简单来分析一下。</p><p><strong>原则一：不要相信任何外部输入的参数。</strong></p><p>函数的使用者可能是任何人，这些人在使用函数之前可能都没有阅读过任何手册或文档，他们会向函数传入你意想不到的参数。因此，为了保证函数的健壮性，函数需要对所有输入的参数进行合法性的检查。一旦发现问题，立即终止函数的执行，返回预设的错误值。</p><!-- [[[read_end]]] --><p><strong>原则二：不要忽略任何一个错误。</strong></p><p>在我们的函数实现中，也会调用标准库或第三方包提供的函数或方法。对于这些调用，我们不能假定它一定会成功，我们一定要显式地检查这些调用返回的错误值。一旦发现错误，要及时终止函数执行，防止错误继续传播。</p><p><strong>原则三：不要假定异常不会发生。</strong></p><p>这里，我们先要确定一个认知：异常不是错误。错误是可预期的，也是经常会发生的，我们有对应的公开错误码和错误处理预案，但异常却是少见的、意料之外的。通常意义上的异常，指的是硬件异常、操作系统异常、语言运行时异常，还有更大可能是代码中潜在bug导致的异常，比如代码中出现了以0作为分母，或者是数组越界访问等情况。</p><p>虽然异常发生是“小众事件”，但是我们不能假定异常不会发生。所以，函数设计时，我们就需要根据函数的角色和使用场景，考虑是否要在函数内设置异常捕捉和恢复的环节。</p><p>在这三条健壮性设计原则中，做到前两条是相对容易的，也没有太多技巧可言。但对第三条异常的处理，很多初学者拿捏不好。所以在这里，我们就重点说一下<strong>Go函数的异常处理设计</strong>。</p><h2>认识Go语言中的异常：panic</h2><p>不同编程语言表示异常（Exception）这个概念的语法都不相同。在Go语言中，异常这个概念由panic表示。一些教程或文章会把它译为恐慌，我这里依旧选择不译，保留panic的原汁原味。</p><p>panic指的是Go程序在运行时出现的一个异常情况。如果异常出现了，但没有被捕获并恢复，Go程序的执行就会被终止，即便出现异常的位置不在主Goroutine中也会这样。</p><p>在Go中，panic主要有两类来源，一类是来自 <strong>Go运行时</strong>，另一类则是 <strong>Go开发人员通过panic函数主动触发的</strong>。无论是哪种，一旦panic被触发，后续Go程序的执行过程都是一样的，这个过程被Go语言称为 <strong>panicking</strong>。</p><p><a href=\"https://blog.golang.org/defer-panic-and-recover\">Go官方文档</a>以手工调用panic函数触发panic为例，对panicking这个过程进行了诠释：当函数F调用panic函数时，函数F的执行将停止。不过，函数F中已进行求值的deferred函数都会得到正常执行，执行完这些deferred函数后，函数F才会把控制权返还给其调用者。</p><p>对于函数F的调用者而言，函数F之后的行为就如同调用者调用的函数是panic一样，该 <code>panicking</code> 过程将继续在栈上进行下去，直到当前Goroutine中的所有函数都返回为止，然后Go程序将崩溃退出。</p><p>我们用一个例子来更直观地解释一下panicking这个过程：</p><pre><code class=\"language-plain\">func foo() {\n    println(\"call foo\")\n    bar()\n    println(\"exit foo\")\n}\n\nfunc bar() {\n    println(\"call bar\")\n    panic(\"panic occurs in bar\")\n    zoo()\n    println(\"exit bar\")\n}\n\nfunc zoo() {\n    println(\"call zoo\")\n    println(\"exit zoo\")\n}\n\nfunc main() {\n    println(\"call main\")\n    foo()\n    println(\"exit main\")\n}\n</code></pre><p>上面这个例子中，从Go应用入口开始，函数的调用次序依次为 <code>main -&gt; foo -&gt; bar -&gt; zoo</code>。在bar函数中，我们调用panic函数手动触发了panic。</p><p>我们执行这个程序的输出结果是这样的：</p><pre><code class=\"language-plain\">call main\ncall foo\ncall bar\npanic: panic occurs in bar\n</code></pre><p>我们再根据前面对panicking过程的诠释，理解一下这个例子。</p><p>这里，程序从入口函数main开始依次调用了foo、bar函数，在bar函数中，代码在调用zoo函数之前调用了panic函数触发了异常。那示例的panicking过程就从这开始了。bar函数调用panic函数之后，它自身的执行就此停止了，所以我们也没有看到代码继续进入zoo函数执行。并且，bar函数没有捕捉这个panic，这样这个panic就会沿着函数调用栈向上走，来到了bar函数的调用者foo函数中。</p><p>从foo函数的视角来看，这就好比将它对bar函数的调用，换成了对panic函数的调用一样。这样一来，foo函数的执行也被停止了。由于foo函数也没有捕捉panic，于是panic继续沿着函数调用栈向上走，来到了foo函数的调用者main函数中。</p><p>同理，从main函数的视角来看，这就好比将它对foo函数的调用，换成了对panic函数的调用一样。结果就是，main函数的执行也被终止了，于是整个程序异常退出，日志\"exit main\"也没有得到输出的机会。</p><p>不过，Go也提供了捕捉panic并恢复程序正常执行秩序的方法，我们可以通过 <strong>recover函数</strong>来实现这一点。</p><p>我们继续用上面这个例子分析，在触发panic的bar函数中，对panic进行捕捉并恢复，我们直接来看恢复后，整个程序的执行情况是什么样的。这里，我们只列出了变更后的bar函数代码，其他函数代码并没有改变：</p><pre><code class=\"language-plain\">func bar() {\n    defer func() {\n        if e := recover(); e != nil {\n            fmt.Println(\"recover the panic:\", e)\n        }\n    }()\n\n    println(\"call bar\")\n    panic(\"panic occurs in bar\")\n    zoo()\n    println(\"exit bar\")\n}\n</code></pre><p>在更新版的bar函数中，我们在一个defer匿名函数中调用recover函数对panic进行了捕捉。recover是Go内置的专门用于恢复panic的函数，它必须被放在一个defer函数中才能生效。如果recover捕捉到panic，它就会返回以panic的具体内容为错误上下文信息的错误值。如果没有panic发生，那么recover将返回nil。而且，如果panic被recover捕捉到，panic引发的panicking过程就会停止。</p><p>关于defer函数的内容我们等会还会详细讲。此刻你只需要知道，无论bar函数正常执行结束，还是因panic异常终止，在那之前设置成功的defer函数都会得到执行就可以了。</p><p>我们执行更新后的程序，得到如下结果：</p><pre><code class=\"language-plain\">call main\ncall foo\ncall bar\nrecover the panic: panic occurs in bar\nexit foo\nexit main\n</code></pre><p>我们可以看到main函数终于得以“善终”。那这个过程中究竟发生了什么呢？</p><p>在更新后的代码中，当bar函数调用panic函数触发异常后，bar函数的执行就会被中断。但这一次，在代码执行流回到bar函数调用者之前，bar函数中的、在panic之前就已经被设置成功的derfer函数就会被执行。这个匿名函数会调用recover把刚刚触发的panic恢复，这样，panic还没等沿着函数栈向上走，就被消除了。</p><p>所以，这个时候，从foo函数的视角来看，bar函数与正常返回没有什么差别。foo函数依旧继续向下执行，直至main函数成功返回。这样，这个程序的panic“危机”就解除了。</p><p>面对有如此行为特点的panic，我们应该如何应对呢？是不是在所有Go函数或方法中，我们都要用defer函数来捕捉和恢复panic呢？</p><h2>如何应对panic？</h2><p>其实大可不必。</p><p>一来，这样做会徒增开发人员函数实现时的心智负担。二来，很多函数非常简单，根本不会出现panic情况，我们增加panic捕获和恢复，反倒会增加函数的复杂性。同时，defer函数也不是“免费”的，也有带来性能开销（这个我们后面会讲解）。</p><p>那么，日常情况下我们应该怎么做呢？我这里提供了三点经验，你可以参考一下。</p><h3>第一点：评估程序对panic的忍受度</h3><p>首先，我们应该知道一个事实：<strong>不同应用对异常引起的程序崩溃退出的忍受度是不一样的</strong>。比如，一个单次运行于控制台窗口中的命令行交互类程序（CLI），和一个常驻内存的后端HTTP服务器程序，对异常崩溃的忍受度就是不同的。</p><p>前者即便因异常崩溃，对用户来说也仅仅是再重新运行一次而已。但后者一旦崩溃，就很可能导致整个网站停止服务。所以，<strong>针对各种应用对panic忍受度的差异，我们采取的应对panic的策略也应该有不同</strong>。像后端HTTP服务器程序这样的任务关键系统，我们就需要在特定位置捕捉并恢复panic，以保证服务器整体的健壮度。在这方面，Go标准库中的http server就是一个典型的代表。</p><p>Go标准库提供的http server采用的是，每个客户端连接都使用一个单独的Goroutine进行处理的并发处理模型。也就是说，客户端一旦与http server连接成功，http server就会为这个连接新创建一个Goroutine，并在这Goroutine中执行对应连接（conn）的serve方法，来处理这条连接上的客户端请求。</p><p>前面提到了panic的“危害”时，我们说过，<strong>无论在哪个Goroutine中发生未被恢复的panic，整个程序都将崩溃退出</strong>。所以，为了保证处理某一个客户端连接的Goroutine出现panic时，不影响到http server主Goroutine的运行，Go标准库在serve方法中加入了对panic的捕捉与恢复，下面是serve方法的部分代码片段：</p><pre><code class=\"language-plain\">// $GOROOT/src/net/http/server.go\n// Serve a new connection.\nfunc (c *conn) serve(ctx context.Context) {\n    c.remoteAddr = c.rwc.RemoteAddr().String()\n    ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr())\n    defer func() {\n        if err := recover(); err != nil &amp;&amp; err != ErrAbortHandler {\n            const size = 64 &lt;&lt; 10\n            buf := make([]byte, size)\n            buf = buf[:runtime.Stack(buf, false)]\n            c.server.logf(\"http: panic serving %v: %v\\n%s\", c.remoteAddr, err, buf)\n        }\n        if !c.hijacked() {\n            c.close()\n            c.setState(c.rwc, StateClosed, runHooks)\n        }\n    }()\n    ... ...\n}\n</code></pre><p>你可以看到，serve方法在一开始处就设置了defer函数，并在该函数中捕捉并恢复了可能出现的panic。这样，即便处理某个客户端连接的Goroutine出现panic，处理其他连接Goroutine以及http server自身都不会受到影响。</p><p>这种<strong>局部不要影响整体</strong>的异常处理策略，在很多并发程序中都有应用。并且，捕捉和恢复panic的位置通常都在子Goroutine的起始处，这样设置可以捕捉到后面代码中可能出现的所有panic，就像serve方法中那样。</p><h3>第二点：提示潜在bug</h3><p>有了对panic忍受度的评估，panic是不是也没有那么“恐怖”了呢？而且，我们甚至可以借助panic来帮助我们快速找到潜在bug。</p><p>C语言中有个很好用的辅助函数，断言（assert宏）。在使用C编写代码时，我们经常在一些代码执行路径上，使用断言来表达这段执行路径上某种条件一定为真的信心。断言为真，则程序处于正确运行状态，断言为否就是出现了意料之外的问题，而这个问题很可能就是一个潜在的bug，这时我们可以借助断言信息快速定位到问题所在。</p><p>不过，Go语言标准库中并没有提供断言之类的辅助函数，但我们可以使用panic，部分模拟断言对潜在bug的提示功能。比如，下面就是标准库 <code>encoding/json</code>包使用panic指示潜在bug的一个例子：</p><pre><code class=\"language-plain\">// $GOROOT/src/encoding/json/decode.go\n... ...\n//当一些本不该发生的事情导致我们结束处理时，phasePanicMsg将被用作panic消息\n//它可以指示JSON解码器中的bug，或者\n//在解码器执行时还有其他代码正在修改数据切片。\n\nconst phasePanicMsg = \"JSON decoder out of sync - data changing underfoot?\"\n\nfunc (d *decodeState) init(data []byte) *decodeState {\n    d.data = data\n    d.off = 0\n    d.savedError = nil\n    if d.errorContext != nil {\n        d.errorContext.Struct = nil\n        // Reuse the allocated space for the FieldStack slice.\n        d.errorContext.FieldStack = d.errorContext.FieldStack[:0]\n    }\n    return d\n}\n\nfunc (d *decodeState) valueQuoted() interface{} {\n    switch d.opcode {\n    default:\n        panic(phasePanicMsg)\n\n    case scanBeginArray, scanBeginObject:\n        d.skip()\n        d.scanNext()\n\n    case scanBeginLiteral:\n        v := d.literalInterface()\n        switch v.(type) {\n        case nil, string:\n            return v\n        }\n    }\n    return unquotedValue{}\n}\n</code></pre><p>我们看到，在 <code>valueQuoted</code> 这个方法中，如果程序执行流进入了default分支，那这个方法就会引发panic，这个panic会提示开发人员：这里很可能是一个bug。</p><p>同样，在json包的encode.go中也有使用panic做潜在bug提示的例子：</p><pre><code class=\"language-plain\">// $GOROOT/src/encoding/json/encode.go\n\nfunc (w *reflectWithString) resolve() error {\n    ... ...\n    switch w.k.Kind() {\n    case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n        w.ks = strconv.FormatInt(w.k.Int(), 10)\n        return nil\n    case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n        w.ks = strconv.FormatUint(w.k.Uint(), 10)\n        return nil\n    }\n    panic(\"unexpected map key type\")\n}\n\n</code></pre><p>这段代码中，<code>resolve</code> 方法的最后一行代码就相当于一个“代码逻辑不会走到这里”的断言。一旦触发“断言”，这很可能就是一个潜在bug。</p><p>我们也看到，去掉这行代码并不会对 <code>resolve</code> 方法的逻辑造成任何影响，但真正出现问题时，开发人员就缺少了“断言”潜在bug提醒的辅助支持了。在Go标准库中，<strong>大多数panic的使用都是充当类似断言的作用的</strong>。</p><h3>第三点：不要混淆异常与错误</h3><p>在日常编码中，我经常会看到一些Go语言初学者，尤其是一些有过Java语言编程经验的程序员，会因为习惯了Java那种基于 <code>try-catch-finally</code> 的错误处理思维，而将Go panic当成Java的“checked exception”去用，这显然是混淆了Go中的异常与错误，这是Go错误处理的一种反模式。</p><p>查看Java标准类库，我们可以看到一些Java已预定义好的 <code>checked exception</code> 类，比较常见的有 <code>IOException</code>、<code>TimeoutException</code>、<code>EOFException</code>、<code>FileNotFoundException</code>，等等。看到这里，你是不是觉得这些checked exception和我们上一节讲的“哨兵错误值”十分相似呢？。它们都是预定义好的、代表特定场景下的错误状态。</p><p>那Java的 <code>checked exception</code>  和Go中的panic有啥差别呢？</p><p>Java的 <code>checked exception</code> 用于一些可预见的、常会发生的错误场景，比如，针对 <code>checked exception</code> 的所谓“异常处理”，就是针对这些场景的<strong>“错误处理预案”</strong>。也可以说对 <code>checked exception</code> 的使用、捕获、自定义等行为都是“<strong>有意而为之</strong>”的。</p><p>如果它非要和Go中的某种语法对应来看，它对应的也是Go的错误处理，也就是基于error值比较模型的错误处理。所以，Java中对 <code>checked exception</code> 处理的本质是<strong>错误处理</strong>，虽然它的名字用了带有“异常”的字样。</p><p>而Go中的panic呢，更接近于Java的 <code>RuntimeException</code>+<code>Error</code> ，而不是 <code>checked exception</code> 。我们前面提到过Java的 <code>checked exception</code> 是必须要被上层代码处理的，也就是要么捕获处理，要么重新抛给更上层。但是在Go中，我们通常会导入大量第三方包，而对于这些第三方包API中是否会引发 <code>panic</code> ，我们是不知道的。</p><p>因此上层代码，也就是API调用者根本不会去逐一了解API是否会引发<code>panic</code>，也没有义务去处理引发的panic。一旦你在编写的API中，像 <code>checked exception</code> 那样使用panic作为正常错误处理的手段，把引发的 <code>panic</code> 当作错误，那么你就会给你的API使用者带去大麻烦！因此，在Go中，作为API函数的作者，你一定<strong>不要将panic当作错误返回给API调用者</strong>。</p><p>到这里，我们已经基本讲完了函数健壮性设计要注意的各种事项，你一定要注意我前面提到的这几点。接下来，我们进入下一部分，看看函数的简洁性设计。</p><h2>使用defer简化函数实现</h2><p>对函数设计来说，如何实现简洁的目标是一个大话题。你可以从通用的设计原则去谈，比如函数要遵守单一职责，职责单一的函数肯定要比担负多种职责的函数更简单。你也可以从函数实现的规模去谈，比如函数体的规模要小，尽量控制在80行代码之内等。</p><p>但我们这个是Go语言的课程，所以我们的角度更侧重于 <strong>Go中是否有现成的语法元素，可以帮助我们简化Go函数的设计和实现</strong>。我也把答案剧透给你，有的，它就是 <strong>defer</strong>。</p><p>同样地，我们也用一个具体的例子来理解一下。日常开发中，我们经常会编写一些类似下面示例中的伪代码：</p><pre><code class=\"language-plain\">func doSomething() error {\n    var mu sync.Mutex\n    mu.Lock()\n\n    r1, err := OpenResource1()\n    if err != nil {\n        mu.Unlock()\n        return err\n    }\n\n    r2, err := OpenResource2()\n    if err != nil {\n        r1.Close()\n        mu.Unlock()\n        return err\n    }\n\n    r3, err := OpenResource3()\n    if err != nil {\n        r2.Close()\n        r1.Close()\n        mu.Unlock()\n        return err\n    }\n\n    // 使用r1，r2, r3\n    err = doWithResources() \n    if err != nil {\n        r3.Close()\n        r2.Close()\n        r1.Close()\n        mu.Unlock()\n        return err\n    }\n\n    r3.Close()\n    r2.Close()\n    r1.Close()\n    mu.Unlock()\n    return nil\n}\n</code></pre><p>我们看到，这类代码的特点就是在函数中会申请一些资源，并在函数退出前释放或关闭这些资源，比如这里的互斥锁mu以及资源r1~r3就是这样。</p><p>函数的实现需要确保，无论函数的执行流是按预期顺利进行，还是出现错误，这些资源在函数退出时都要被及时、正确地释放。为此，我们需要尤为关注函数中的错误处理，在错误处理时不能遗漏对资源的释放。</p><p>但这样的要求，就导致我们在进行资源释放，尤其是有多个资源需要释放的时候，比如上面示例那样，会大大增加开发人员的心智负担。同时当待释放的资源个数较多时，整个代码逻辑就会变得十分复杂，程序可读性、健壮性也会随之下降。但即便如此，如果函数实现中的某段代码逻辑抛出panic，传统的错误处理机制依然没有办法捕获它并尝试从panic恢复。</p><p><strong>Go语言引入defer的初衷，就是解决这些问题。那么，defer具体是怎么解决这些问题的呢？或者说，defer具体的运作机制是怎样的呢？</strong></p><p>defer是Go语言提供的一种延迟调用机制，defer的运作离不开函数。怎么理解呢？这句话至少有以下两点含义：</p><ul>\n<li>在Go中，只有在函数（和方法）内部才能使用defer；</li>\n<li>defer关键字后面只能接函数（或方法），这些函数被称为 <strong>deferred函数</strong>。defer将它们注册到其所在Goroutine中，用于存放deferred函数的栈数据结构中，这些deferred函数将在执行defer的函数退出前，按后进先出（LIFO）的顺序被程序调度执行（如下图所示）。<br>\n<img src=\"https://static001.geekbang.org/resource/image/89/c0/89d2f5ec28f6c291bf44deb4c5f979c0.jpg?wh=1920x1080\" alt=\"图片\"></li>\n</ul><p>而且，无论是执行到函数体尾部返回，还是在某个错误处理分支显式return，又或是出现panic，已经存储到deferred函数栈中的函数，都会被调度执行。所以说，deferred函数是一个可以在任何情况下为函数进行<strong>收尾工作</strong>的好“伙伴”。</p><p>我们回到刚才的那个例子，如果我们把收尾工作挪到deferred函数中，那么代码将变成如下这个样子：</p><pre><code class=\"language-plain\">func doSomething() error {\n    var mu sync.Mutex\n    mu.Lock()\n    defer mu.Unlock()\n\n    r1, err := OpenResource1()\n    if err != nil {\n        return err\n    }\n    defer r1.Close()\n\n    r2, err := OpenResource2()\n    if err != nil {\n        return err\n    }\n    defer r2.Close()\n\n    r3, err := OpenResource3()\n    if err != nil {\n        return err\n    }\n    defer r3.Close()\n\n    // 使用r1，r2, r3\n    return doWithResources() \n}\n</code></pre><p>我们看到，使用defer后对函数实现逻辑的简化是显而易见的。而且，这里资源释放函数的defer注册动作，紧邻着资源申请成功的动作，这样成对出现的惯例就极大降低了遗漏资源释放的可能性，我们开发人员也不用再小心翼翼地在每个错误处理分支中检查是否遗漏了某个资源的释放动作。同时，代码的简化也意味代码可读性的提高，以及代码健壮度的增强。</p><p>那我们日常开发中使用defer，有没有什么要特别注意的呢？</p><h2>defer使用的几个注意事项</h2><p>大多数Gopher都喜欢defer，因为它不仅可以用来捕捉和恢复panic，还能让函数变得更简洁和健壮。但“工欲善其事，必先利其器“，一旦你要用defer，有几个关于defer使用的注意事项是你一定要提前了解清楚的，可以避免掉进一些不必要的“坑”。</p><h3>第一点：明确哪些函数可以作为deferred函数</h3><p>这里，你要清楚，对于自定义的函数或方法，defer可以给与无条件的支持，但是对于有返回值的自定义函数或方法，返回值会在deferred函数被调度执行的时候被自动丢弃。</p><p>而且，Go语言中除了自定义函数/方法，还有Go语言内置的/预定义的函数，这里我给出了Go语言内置函数的完全列表：</p><pre><code class=\"language-plain\">Functions:\n\tappend cap close complex copy delete imag len\n\tmake new panic print println real recover\n</code></pre><p>那么，Go语言中的内置函数是否都能作为deferred函数呢？我们看下面的示例：</p><pre><code class=\"language-plain\">// defer1.go\n\n func bar() (int, int) {\n     return 1, 2\n }\n \n func foo() {\n     var c chan int\n     var sl []int\n     var m = make(map[string]int, 10)\n     m[\"item1\"] = 1\n     m[\"item2\"] = 2\n     var a = complex(1.0, -1.4)\n \n     var sl1 []int\n     defer bar()\n     defer append(sl, 11)\n     defer cap(sl)\n     defer close(c)\n     defer complex(2, -2)\n     defer copy(sl1, sl)\n     defer delete(m, \"item2\")\n     defer imag(a)\n     defer len(sl)\n     defer make([]int, 10)\n     defer new(*int)\n     defer panic(1)\n     defer print(\"hello, defer\\n\")\n     defer println(\"hello, defer\")\n     defer real(a)\n     defer recover()\n }\n \n func main() {\n     foo()\n }\n</code></pre><p>运行这个示例代码，我们可以得到：</p><pre><code class=\"language-plain\">$go run defer1.go\n# command-line-arguments\n./defer1.go:17:2: defer discards result of append(sl, 11)\n./defer1.go:18:2: defer discards result of cap(sl)\n./defer1.go:20:2: defer discards result of complex(2, -2)\n./defer1.go:23:2: defer discards result of imag(a)\n./defer1.go:24:2: defer discards result of len(sl)\n./defer1.go:25:2: defer discards result of make([]int, 10)\n./defer1.go:26:2: defer discards result of new(*int)\n./defer1.go:30:2: defer discards result of real(a)\n</code></pre><p>我们看到，Go编译器居然给出一组错误提示！</p><p>从这组错误提示中我们可以看到，append、cap、len、make、new、imag等内置函数都是不能直接作为deferred函数的，而close、copy、delete、print、recover等内置函数则可以直接被defer设置为deferred函数。</p><p>不过，对于那些不能直接作为deferred函数的内置函数，我们可以使用一个包裹它的匿名函数来间接满足要求，以append为例是这样的：</p><pre><code class=\"language-plain\">defer func() {\n\t_ = append(sl, 11)\n}()\n</code></pre><h3>第二点：注意defer关键字后面表达式的求值时机</h3><p>这里，你一定要牢记一点：<strong>defer关键字后面的表达式，是在将deferred函数注册到deferred函数栈的时候进行求值的</strong>。</p><p>我们同样用一个典型的例子来说明一下defer后表达式的求值时机：</p><pre><code class=\"language-plain\">func foo1() {\n    for i := 0; i &lt;= 3; i++ {\n        defer fmt.Println(i)\n    }\n}\n\nfunc foo2() {\n    for i := 0; i &lt;= 3; i++ {\n        defer func(n int) {\n            fmt.Println(n)\n        }(i)\n    }\n}\n\nfunc foo3() {\n    for i := 0; i &lt;= 3; i++ {\n        defer func() {\n            fmt.Println(i)\n        }()\n    }\n}\n\nfunc main() {\n    fmt.Println(\"foo1 result:\")\n    foo1()\n    fmt.Println(\"\\nfoo2 result:\")\n    foo2()\n    fmt.Println(\"\\nfoo3 result:\")\n    foo3()\n}\n</code></pre><p>这里，我们一个个分析foo1、foo2和foo3中defer后的表达式的求值时机。</p><p>首先是foo1。foo1中defer后面直接用的是fmt.Println函数，每当defer将fmt.Println注册到deferred函数栈的时候，都会对Println后面的参数进行求值。根据上述代码逻辑，依次压入deferred函数栈的函数是：</p><pre><code class=\"language-plain\">fmt.Println(0)\nfmt.Println(1)\nfmt.Println(2)\nfmt.Println(3)\n</code></pre><p>因此，当foo1返回后，deferred函数被调度执行时，上述压入栈的deferred函数将以LIFO次序出栈执行，这时的输出的结果为：</p><pre><code class=\"language-plain\">3\n2\n1\n0\n</code></pre><p>然后我们再看foo2。foo2中defer后面接的是一个带有一个参数的匿名函数。每当defer将匿名函数注册到deferred函数栈的时候，都会对该匿名函数的参数进行求值。根据上述代码逻辑，依次压入deferred函数栈的函数是：</p><pre><code class=\"language-plain\">func(0)\nfunc(1)\nfunc(2)\nfunc(3)\n</code></pre><p>因此，当foo2返回后，deferred函数被调度执行时，上述压入栈的deferred函数将以LIFO次序出栈执行，因此输出的结果为：</p><pre><code class=\"language-plain\">3\n2\n1\n0\n</code></pre><p>最后我们来看foo3。foo3中defer后面接的是一个不带参数的匿名函数。根据上述代码逻辑，依次压入deferred函数栈的函数是：</p><pre><code class=\"language-plain\">func()\nfunc()\nfunc()\nfunc()\n</code></pre><p>所以，当foo3返回后，deferred函数被调度执行时，上述压入栈的deferred函数将以LIFO次序出栈执行。匿名函数会以闭包的方式访问外围函数的变量i，并通过Println输出i的值，此时i的值为4，因此foo3的输出结果为：</p><pre><code class=\"language-plain\">4\n4\n4\n4\n</code></pre><p>通过这些例子，我们可以看到，无论以何种形式将函数注册到defer中，deferred函数的参数值都是在注册的时候进行求值的。</p><h3>第三点：知晓defer带来的性能损耗</h3><p>通过前面的分析，我们可以看到，defer让我们进行资源释放（如文件描述符、锁）的过程变得优雅很多，也不易出错。但在性能敏感的应用中，defer带来的性能负担也是我们必须要知晓和权衡的问题。</p><p>这里，我们用一个性能基准测试（Benchmark），直观地看看defer究竟会带来多少性能损耗。基于Go工具链，我们可以很方便地为Go源码写一个性能基准测试，只需将代码放在以“_test.go”为后缀的源文件中，然后利用testing包提供的“框架”就可以了，我们看下面代码：</p><pre><code class=\"language-plain\">// defer_test.go\npackage main\n  \nimport \"testing\"\n\nfunc sum(max int) int {\n    total := 0\n    for i := 0; i &lt; max; i++ {\n        total += i\n    }\n\n    return total\n}\n\nfunc fooWithDefer() {\n    defer func() {\n        sum(10)\n    }()\n}\nfunc fooWithoutDefer() {\n    sum(10)\n}\n\nfunc BenchmarkFooWithDefer(b *testing.B) {\n    for i := 0; i &lt; b.N; i++ {\n        fooWithDefer()\n    }\n}\nfunc BenchmarkFooWithoutDefer(b *testing.B) {\n    for i := 0; i &lt; b.N; i++ {\n        fooWithoutDefer()\n    }\n}\n</code></pre><p>这个基准测试包含了两个测试用例，分别是BenchmarkFooWithDefer和BenchmarkFooWithoutDefer。前者测量的是带有defer的函数执行的性能，后者测量的是不带有defer的函数的执行的性能。</p><p>在Go 1.13前的版本中，defer带来的开销还是很大的。我们先用Go 1.12.7版本来运行一下上述基准测试，我们会得到如下结果：</p><pre><code class=\"language-plain\">$go test -bench . defer_test.go\ngoos: darwin\ngoarch: amd64\nBenchmarkFooWithDefer-8      \t30000000\t        42.6 ns/op\nBenchmarkFooWithoutDefer-8   \t300000000\t         5.44 ns/op\nPASS\nok  \tcommand-line-arguments\t3.511s\n</code></pre><p>从这个基准测试结果中，我们可以清晰地看到：<strong>使用defer的函数的执行时间是没有使用defer函数的8倍左右</strong>。</p><p>但从Go 1.13版本开始，Go核心团队对defer性能进行了多次优化，到现在的Go 1.17版本，defer的开销已经足够小了。我们看看使用Go 1.17版本运行上述基准测试的结果：</p><pre><code class=\"language-plain\">$go test -bench . defer_test.go\ngoos: darwin\ngoarch: amd64\nBenchmarkFooWithDefer-8      \t194593353\t         6.183 ns/op\nBenchmarkFooWithoutDefer-8   \t284272650\t         4.259 ns/op\nPASS\nok  \tcommand-line-arguments\t3.472s\n</code></pre><p>我们看到，带有defer的函数执行开销，仅是不带有defer的函数的执行开销的1.45倍左右，已经达到了几乎可以忽略不计的程度，我们可以放心使用。</p><h2>小结</h2><p>好了，今天的课讲到这里就结束了。在这一讲中，我们延续上一节的脉络，讲解了函数设计过程中应该考虑的、健壮性与简洁性方面的内容。</p><p>在函数健壮性方面，我给出了“三不要”原则，这三个原则你一定要记住。这里我们重点讲解了第三个原则：<strong>不要假定异常不会发生</strong>。借此，我们认识了Go语言中表示异常的panic，也学习了panic发生后的代码执行流程。基于panic的行为特征，我们给出了Go函数设计过程中应对panic的三点经验，这里你要注意，“评估程序对panic的忍受度”是我们选取应对panic措施的前提。</p><p>另外，对于来自像Java这样的、基于Exception进行错误处理的编程语言的Go初学者们，切记不要将panic与错误处理混淆。</p><p>接下来，我们又讲解了如何让函数实现更加简洁。简洁性对于函数来说意味着可读性更好，更易于理解，也有利于我们代码健壮性的提升。Go语言层面提供的defer机制可用于简化函数实现，尤其是在函数申请和释放资源个数较多的情况下。</p><p>如果我们要用好defer，前提就是要了解defer的运作机制，这里你要把握住两点：</p><ul>\n<li>函数返回前，deferred函数是按照后入先出（LIFO）的顺序执行的；</li>\n<li>defer关键字是在注册函数时对函数的参数进行求值的。</li>\n</ul><p>最后，在最新Go版本Go1.17中，使用defer带来的开销几乎可以忽略不计了，你可以放心使用。</p><h2>思考题</h2><p>defer是Gopher们都喜欢的语言机制，那么我想请你思考一下，除了捕捉panic、延迟释放资源外，我们日常编码中还有哪些使用defer的小技巧呢？一个小提示：你可以阅读一下Go标准库中关于defer的使用方法，看看是否能总结出一些小tips。</p><p>欢迎你把这节课分享给更多对Go语言函数感兴趣的朋友。我是Tony Bai，我们下节课见。</p>","comments":[{"had_liked":false,"id":325071,"user_name":"进化菌","can_delete":false,"product_type":"c1","uid":1276861,"ip_address":"","ucode":"B30A5F78BB4171","user_header":"https://static001.geekbang.org/account/avatar/00/13/7b/bd/ccb37425.jpg","comment_is_top":false,"comment_ctime":1638797063,"is_pvip":true,"replies":[{"id":117956,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1638827663,"ip_address":"","comment_id":325071,"utype":1}],"discussion_count":2,"race_medal":4,"score":2,"product_id":100093501,"comment_content":"panic 恐慌，慌慌张张的抛出异常；recover 恢复，淡定还有事情要做，先别退出；defer 延迟，晚点要做的事情不能忘……","like_count":23},{"had_liked":false,"id":325107,"user_name":"helloxiaomin","can_delete":false,"product_type":"c1","uid":1187293,"ip_address":"","ucode":"607CAEA41B8B9A","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/dd/95cdb4d8.jpg","comment_is_top":false,"comment_ctime":1638829062,"is_pvip":false,"replies":[{"id":118584,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1639558106,"ip_address":"","comment_id":325107,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"defer的使用技巧：1）defer要在panic之前，才能执行；2）defer内部的recover只能捕获当前协程的Panic，不能跨协程执行；3）recover只能在defer中调用才能生效。暂时想到这些","like_count":19,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536582,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638827663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2166073,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/k3YD3y3BzGDSdrwRJyJY4BXsNJibfM4uzOdDVKIAlFApR2FZCLg2ibrZtJ4vuahA3LHLW9GKzH5CMGqCDhWjhZqg/132","nickname":"戒酒的李白","note":"","ucode":"744E1A22761647","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585758,"discussion_content":"解释的通俗易懂， 点赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661791006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324968,"user_name":"return","can_delete":false,"product_type":"c1","uid":1135528,"ip_address":"","ucode":"42B8A3380DF04B","user_header":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","comment_is_top":false,"comment_ctime":1638762006,"is_pvip":false,"replies":[{"id":117952,"content":"如果在平时panic用的，那么就说明你走在了正确的道路上:)。panic本身就是异常，异常本身就是很少发生的。目前看panic最常使用的就是充当“断言”，提示潜在bug时用的最多。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1638827555,"ip_address":"","comment_id":324968,"utype":1}],"discussion_count":5,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"老师讲的太好了，\n再请教一下老师， panic应该在什么场景下使用，\n感觉平时 业务代码 使用 err足够，没有使用panic的场景，\n文中举例的 http server比较合适， 但是json encode，虽然官方用了panic，但是个人感觉 使用err也没毛病， 传入的 json串 有问题嘛，就是 入参校验err呗。 \n所以 get 不到 什么情况下用 panic。","like_count":15,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538925,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639558106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324994,"user_name":"liaomars","can_delete":false,"product_type":"c1","uid":2104856,"ip_address":"","ucode":"4FCA97EE9FB57D","user_header":"https://static001.geekbang.org/account/avatar/00/20/1e/18/9d1f1439.jpg","comment_is_top":false,"comment_ctime":1638774414,"is_pvip":false,"replies":[{"id":117951,"content":"可以的。在后面的一个实战项目中，我们就会应用到这一点。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1638827327,"ip_address":"","comment_id":324994,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"看了官方标准库的defer说明，发现一个tips是：可以跟踪函数的执行过程","like_count":11,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536577,"discussion_content":"可以的。在后面的一个实战项目中，我们就会应用到这一点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638827327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1025239,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a4/d7/5d2bfaa7.jpg","nickname":"Aliliin","note":"","ucode":"61F9A09BB6650F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546689,"discussion_content":"defer： 老子就要看看是谁出的错。😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642392714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1363671,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ce/d7/5315f6ce.jpg","nickname":"不负青春不负己🤘","note":"","ucode":"A6DD8E8B20EA6E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536932,"discussion_content":"类似于 log 日志：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638893674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325151,"user_name":"奕","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1638843979,"is_pvip":false,"replies":[{"id":118585,"content":"这是一种通过数组下标方式对数组进行初始化的方式。我记得我在第15讲中提到过吧。这里数组字面值中最大的下标值为3，go编译器就认为数组长度是4.（下标值范围0~3）","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1639558205,"ip_address":"","comment_id":325151,"utype":1}],"discussion_count":6,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"请教一个非课程的问题：\nv := [...]int{1: 2, 3: 4}\nfmt.Println(len(v)) \n\n这里为什么打印出来的 长度是 4呢？","like_count":8,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538926,"discussion_content":"这是一种通过数组下标方式对数组进行初始化的方式。我记得我在第15讲中提到过吧。这里数组字面值中最大的下标值为3，go编译器就认为数组长度是4.（下标值范围0~3）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639558205,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1667175,"avatar":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","nickname":"qinsi","note":"","ucode":"090D9C4068FF12","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537654,"discussion_content":"三个点&#34;...&#34;表示len在最大的下标后面，最大的下标是3，所以len就是4","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1639129698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"奕","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1667175,"avatar":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","nickname":"qinsi","note":"","ucode":"090D9C4068FF12","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":537680,"discussion_content":"…是自动推断数组的长度，这里为什么长度是4的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639141838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":537654,"ip_address":"","group_id":0},"score":537680,"extra":""},{"author":{"id":1667175,"avatar":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","nickname":"qinsi","note":"","ucode":"090D9C4068FF12","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"奕","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537814,"discussion_content":"稀疏数组的初始化，前面第15课有讲的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1639205542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":537680,"ip_address":"","group_id":0},"score":537814,"extra":""},{"author":{"id":2885586,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/07/d2/1bdf9d33.jpg","nickname":"勤学如春起之苗,不见其增,日有所长","note":"","ucode":"E8E885754513BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"奕","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585238,"discussion_content":"应该是，把4赋值给数组下标为3的元素，就是第4个元素，所以长度是4？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661413267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":537680,"ip_address":"上海","group_id":0},"score":585238,"extra":""}]}]},{"had_liked":false,"id":325234,"user_name":"lesserror","can_delete":false,"product_type":"c1","uid":1351076,"ip_address":"","ucode":"25A54D1165FCF6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","comment_is_top":false,"comment_ctime":1638872654,"is_pvip":false,"replies":[{"id":118592,"content":"defer是在函数退出时调用的。如果在for语句的每个迭代都使用defer设置deferred函数，这些deferred函数会压入runtime实现的defer列表中。会占用内存资源，并且如果for的loop次数很多，这个消耗将很可观。文中在for中使用defer仅是为了举例而已。生产代码这块的确要谨慎，通常是没有必要这么做的。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1639560668,"ip_address":"","comment_id":325234,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"感谢 Tony Bai 老师关于defer的深入讲解，不过我想问一下，在for中使用defer函数，编辑器会提示可能造成资源泄露，能大致说明一下这块儿的知识吗？","like_count":6,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538941,"discussion_content":"defer是在函数退出时调用的。如果在for语句的每个迭代都使用defer设置deferred函数，这些deferred函数会压入runtime实现的defer列表中。会占用内存资源，并且如果for的loop次数很多，这个消耗将很可观。文中在for中使用defer仅是为了举例而已。生产代码这块的确要谨慎，通常是没有必要这么做的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1639560668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":539481,"discussion_content":"谢谢老师的回答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639727479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":538941,"ip_address":"","group_id":0},"score":539481,"extra":""}]}]},{"had_liked":false,"id":343987,"user_name":"van","can_delete":false,"product_type":"c1","uid":1766293,"ip_address":"","ucode":"26FAFF7224F12D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/f3/95/77628ed0.jpg","comment_is_top":false,"comment_ctime":1651156808,"is_pvip":true,"replies":[{"id":125653,"content":"把panic当做断言使用的目的是及早发现bug，一旦断言发生，意味着整个程序出现了不可恢复的状态。对于这类panic，不要recover。尽早失败并解决bug。所以在什么位置进行断言，对哪些条件进行断言是需要考量的。在C语言中使用assert也是同样的道理。一旦assert失败，便会dump core文件。程序终止。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1651270636,"ip_address":"","comment_id":343987,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"panic作为断言使用，上一层的调用者还是需要自己recover回来吧，不然这个调用链会最终传到main函数","like_count":3,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538941,"discussion_content":"defer是在函数退出时调用的。如果在for语句的每个迭代都使用defer设置deferred函数，这些deferred函数会压入runtime实现的defer列表中。会占用内存资源，并且如果for的loop次数很多，这个消耗将很可观。文中在for中使用defer仅是为了举例而已。生产代码这块的确要谨慎，通常是没有必要这么做的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1639560668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":539481,"discussion_content":"谢谢老师的回答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639727479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":538941,"ip_address":"","group_id":0},"score":539481,"extra":""}]}]},{"had_liked":false,"id":329678,"user_name":"ゝ骑着小车去兜风。","can_delete":false,"product_type":"c1","uid":2600957,"ip_address":"","ucode":"35F9E5360DF42C","user_header":"https://static001.geekbang.org/account/avatar/00/27/af/fd/a1708649.jpg","comment_is_top":false,"comment_ctime":1641466575,"is_pvip":false,"replies":[{"id":120477,"content":"循环结束后，i的值为4. defer输出的是i的值，于是就都是4.","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1642040805,"ip_address":"","comment_id":329678,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"老师你好，没太明白闭包的原理，想不明白为什么输出的是4，请帮忙解答下","like_count":3,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568934,"discussion_content":"把panic当做断言使用的目的是及早发现bug，一旦断言发生，意味着整个程序出现了不可恢复的状态。对于这类panic，不要recover。尽早失败并解决bug。所以在什么位置进行断言，对哪些条件进行断言是需要考量的。在C语言中使用assert也是同样的道理。一旦assert失败，便会dump core文件。程序终止。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1651270636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325821,"user_name":"功夫熊猫","can_delete":false,"product_type":"c1","uid":2732243,"ip_address":"","ucode":"D124F4FA4E816F","user_header":"https://static001.geekbang.org/account/avatar/00/29/b0/d3/200e82ff.jpg","comment_is_top":false,"comment_ctime":1639152392,"is_pvip":false,"replies":[{"id":119090,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1640054649,"ip_address":"","comment_id":325821,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"defer数据库的开关。锁的申请释放。TCP的连接和断开之类的","like_count":3,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545693,"discussion_content":"循环结束后，i的值为4. defer输出的是i的值，于是就都是4.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642040805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":2175841,"avatar":"https://static001.geekbang.org/account/avatar/00/21/33/61/16505a1a.jpg","nickname":"He","note":"","ucode":"7F5FF5BEE48AF1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":579999,"discussion_content":"老师你好\n不考虑 continue和break,for 的执行顺序是不是这样的\n前置操作-&gt;判断条件表达式-&gt;循环体\n然后\n后置操作-&gt;判断条件表达式循环体\ni=3 的时候，后置操作还是执行了i++，只是判断条件没过，所以i=4","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1657794593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":545693,"ip_address":"","group_id":0},"score":579999,"extra":""},{"author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2175841,"avatar":"https://static001.geekbang.org/account/avatar/00/21/33/61/16505a1a.jpg","nickname":"He","note":"","ucode":"7F5FF5BEE48AF1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621001,"discussion_content":"是这样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1686728311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":579999,"ip_address":"广东","group_id":0},"score":621001,"extra":""}]},{"author":{"id":1915533,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/3a/8d/f5e7a20d.jpg","nickname":"何以解忧","note":"","ucode":"4DFE2BDBAF4919","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":654200,"discussion_content":"iteration 共享作用域，这个例子放在及时求值有点绕人，像是执行的时候取最新的值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1732164126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324930,"user_name":"宋世杰","can_delete":false,"product_type":"c1","uid":2068776,"ip_address":"","ucode":"0869FF74808452","user_header":"https://static001.geekbang.org/account/avatar/00/1f/91/28/f2dcbbfe.jpg","comment_is_top":false,"comment_ctime":1638722190,"is_pvip":true,"replies":[{"id":117954,"content":"是go runtime层实现的。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1638827605,"ip_address":"","comment_id":324930,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"Defer函数被放在一个不同于主函数的函数栈中吗？ 是用slice实现的吗？","like_count":3,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540415,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640054649,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325071,"user_name":"进化菌","can_delete":false,"product_type":"c1","uid":1276861,"ip_address":"","ucode":"B30A5F78BB4171","user_header":"https://static001.geekbang.org/account/avatar/00/13/7b/bd/ccb37425.jpg","comment_is_top":false,"comment_ctime":1638797063,"is_pvip":true,"replies":[{"id":117956,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1638827663,"ip_address":"","comment_id":325071,"utype":1}],"discussion_count":2,"race_medal":4,"score":2,"product_id":100093501,"comment_content":"panic 恐慌，慌慌张张的抛出异常；recover 恢复，淡定还有事情要做，先别退出；defer 延迟，晚点要做的事情不能忘……","like_count":23,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536582,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638827663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2166073,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/k3YD3y3BzGDSdrwRJyJY4BXsNJibfM4uzOdDVKIAlFApR2FZCLg2ibrZtJ4vuahA3LHLW9GKzH5CMGqCDhWjhZqg/132","nickname":"戒酒的李白","note":"","ucode":"744E1A22761647","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585758,"discussion_content":"解释的通俗易懂， 点赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661791006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325107,"user_name":"helloxiaomin","can_delete":false,"product_type":"c1","uid":1187293,"ip_address":"","ucode":"607CAEA41B8B9A","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/dd/95cdb4d8.jpg","comment_is_top":false,"comment_ctime":1638829062,"is_pvip":false,"replies":[{"id":118584,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1639558106,"ip_address":"","comment_id":325107,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"defer的使用技巧：1）defer要在panic之前，才能执行；2）defer内部的recover只能捕获当前协程的Panic，不能跨协程执行；3）recover只能在defer中调用才能生效。暂时想到这些","like_count":19,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538925,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639558106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324968,"user_name":"return","can_delete":false,"product_type":"c1","uid":1135528,"ip_address":"","ucode":"42B8A3380DF04B","user_header":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","comment_is_top":false,"comment_ctime":1638762006,"is_pvip":false,"replies":[{"id":117952,"content":"如果在平时panic用的，那么就说明你走在了正确的道路上:)。panic本身就是异常，异常本身就是很少发生的。目前看panic最常使用的就是充当“断言”，提示潜在bug时用的最多。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1638827555,"ip_address":"","comment_id":324968,"utype":1}],"discussion_count":5,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"老师讲的太好了，\n再请教一下老师， panic应该在什么场景下使用，\n感觉平时 业务代码 使用 err足够，没有使用panic的场景，\n文中举例的 http server比较合适， 但是json encode，虽然官方用了panic，但是个人感觉 使用err也没毛病， 传入的 json串 有问题嘛，就是 入参校验err呗。 \n所以 get 不到 什么情况下用 panic。","like_count":15,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536578,"discussion_content":"如果在平时panic用的，那么就说明你走在了正确的道路上:)。panic本身就是异常，异常本身就是很少发生的。目前看panic最常使用的就是充当“断言”，提示潜在bug时用的最多。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638827555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":3,"child_discussions":[{"author":{"id":1135528,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","nickname":"return","note":"","ucode":"42B8A3380DF04B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":536633,"discussion_content":"明白了， 感谢老师解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638840010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":536578,"ip_address":"","group_id":0},"score":536633,"extra":""},{"author":{"id":2273620,"avatar":"https://static001.geekbang.org/account/avatar/00/22/b1/54/6d663b95.jpg","nickname":"瓜牛","note":"","ucode":"5EB7D2F4400A70","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":560428,"discussion_content":"文章中提到的API作者尽量不要使用panic抛出异常，但是文章又举例json官方包使用了panic，为啥官方包使用就是合理的？并且作者您帮着他解释为断言用法，感觉不是很好理解作者您想表达什么意思？我们普通gopher用咋就不能称之为断言了？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1649325803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":536578,"ip_address":"","group_id":0},"score":560428,"extra":""},{"author":{"id":2869118,"avatar":"","nickname":"Geek_73c432","note":"","ucode":"3E11EB02B14DE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2273620,"avatar":"https://static001.geekbang.org/account/avatar/00/22/b1/54/6d663b95.jpg","nickname":"瓜牛","note":"","ucode":"5EB7D2F4400A70","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636667,"discussion_content":"文章的观点是 API 作者不要把错误当作异常，即，如果你想返回一个错误给调用方，不要使用 Panic\n\njson 包的 panic 用法是有意而为之的，指示程序执行了不该执行的分支，通常意味着 BUG。这时数据状态是不符合预期的，于是利用 panicking 机制退出","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1706687448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":560428,"ip_address":"广东","group_id":0},"score":636667,"extra":""}]},{"author":{"id":1479120,"avatar":"https://static001.geekbang.org/account/avatar/00/16/91/d0/35bc62b1.jpg","nickname":"无咎","note":"","ucode":"B9759B5646F3AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":603098,"discussion_content":"个人以为，json的解析到中途，发现格式损坏，通常是服务端的程序错误，非常少见，所以提示客户代码panic。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675940914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324994,"user_name":"liaomars","can_delete":false,"product_type":"c1","uid":2104856,"ip_address":"","ucode":"4FCA97EE9FB57D","user_header":"https://static001.geekbang.org/account/avatar/00/20/1e/18/9d1f1439.jpg","comment_is_top":false,"comment_ctime":1638774414,"is_pvip":false,"replies":[{"id":117951,"content":"可以的。在后面的一个实战项目中，我们就会应用到这一点。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1638827327,"ip_address":"","comment_id":324994,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"看了官方标准库的defer说明，发现一个tips是：可以跟踪函数的执行过程","like_count":11,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536578,"discussion_content":"如果在平时panic用的，那么就说明你走在了正确的道路上:)。panic本身就是异常，异常本身就是很少发生的。目前看panic最常使用的就是充当“断言”，提示潜在bug时用的最多。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638827555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":3,"child_discussions":[{"author":{"id":1135528,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","nickname":"return","note":"","ucode":"42B8A3380DF04B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":536633,"discussion_content":"明白了， 感谢老师解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638840010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":536578,"ip_address":"","group_id":0},"score":536633,"extra":""},{"author":{"id":2273620,"avatar":"https://static001.geekbang.org/account/avatar/00/22/b1/54/6d663b95.jpg","nickname":"瓜牛","note":"","ucode":"5EB7D2F4400A70","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":560428,"discussion_content":"文章中提到的API作者尽量不要使用panic抛出异常，但是文章又举例json官方包使用了panic，为啥官方包使用就是合理的？并且作者您帮着他解释为断言用法，感觉不是很好理解作者您想表达什么意思？我们普通gopher用咋就不能称之为断言了？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1649325803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":536578,"ip_address":"","group_id":0},"score":560428,"extra":""},{"author":{"id":2869118,"avatar":"","nickname":"Geek_73c432","note":"","ucode":"3E11EB02B14DE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2273620,"avatar":"https://static001.geekbang.org/account/avatar/00/22/b1/54/6d663b95.jpg","nickname":"瓜牛","note":"","ucode":"5EB7D2F4400A70","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636667,"discussion_content":"文章的观点是 API 作者不要把错误当作异常，即，如果你想返回一个错误给调用方，不要使用 Panic\n\njson 包的 panic 用法是有意而为之的，指示程序执行了不该执行的分支，通常意味着 BUG。这时数据状态是不符合预期的，于是利用 panicking 机制退出","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1706687448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":560428,"ip_address":"广东","group_id":0},"score":636667,"extra":""}]},{"author":{"id":1479120,"avatar":"https://static001.geekbang.org/account/avatar/00/16/91/d0/35bc62b1.jpg","nickname":"无咎","note":"","ucode":"B9759B5646F3AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":603098,"discussion_content":"个人以为，json的解析到中途，发现格式损坏，通常是服务端的程序错误，非常少见，所以提示客户代码panic。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675940914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325151,"user_name":"奕","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1638843979,"is_pvip":false,"replies":[{"id":118585,"content":"这是一种通过数组下标方式对数组进行初始化的方式。我记得我在第15讲中提到过吧。这里数组字面值中最大的下标值为3，go编译器就认为数组长度是4.（下标值范围0~3）","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1639558205,"ip_address":"","comment_id":325151,"utype":1}],"discussion_count":6,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"请教一个非课程的问题：\nv := [...]int{1: 2, 3: 4}\nfmt.Println(len(v)) \n\n这里为什么打印出来的 长度是 4呢？","like_count":8,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536577,"discussion_content":"可以的。在后面的一个实战项目中，我们就会应用到这一点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638827327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1025239,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a4/d7/5d2bfaa7.jpg","nickname":"Aliliin","note":"","ucode":"61F9A09BB6650F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546689,"discussion_content":"defer： 老子就要看看是谁出的错。😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642392714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1363671,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ce/d7/5315f6ce.jpg","nickname":"不负青春不负己🤘","note":"","ucode":"A6DD8E8B20EA6E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536932,"discussion_content":"类似于 log 日志：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638893674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325234,"user_name":"lesserror","can_delete":false,"product_type":"c1","uid":1351076,"ip_address":"","ucode":"25A54D1165FCF6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","comment_is_top":false,"comment_ctime":1638872654,"is_pvip":false,"replies":[{"id":118592,"content":"defer是在函数退出时调用的。如果在for语句的每个迭代都使用defer设置deferred函数，这些deferred函数会压入runtime实现的defer列表中。会占用内存资源，并且如果for的loop次数很多，这个消耗将很可观。文中在for中使用defer仅是为了举例而已。生产代码这块的确要谨慎，通常是没有必要这么做的。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1639560668,"ip_address":"","comment_id":325234,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"感谢 Tony Bai 老师关于defer的深入讲解，不过我想问一下，在for中使用defer函数，编辑器会提示可能造成资源泄露，能大致说明一下这块儿的知识吗？","like_count":6,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538926,"discussion_content":"这是一种通过数组下标方式对数组进行初始化的方式。我记得我在第15讲中提到过吧。这里数组字面值中最大的下标值为3，go编译器就认为数组长度是4.（下标值范围0~3）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639558205,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1667175,"avatar":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","nickname":"qinsi","note":"","ucode":"090D9C4068FF12","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537654,"discussion_content":"三个点&#34;...&#34;表示len在最大的下标后面，最大的下标是3，所以len就是4","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1639129698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"奕","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1667175,"avatar":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","nickname":"qinsi","note":"","ucode":"090D9C4068FF12","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":537680,"discussion_content":"…是自动推断数组的长度，这里为什么长度是4的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639141838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":537654,"ip_address":"","group_id":0},"score":537680,"extra":""},{"author":{"id":1667175,"avatar":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","nickname":"qinsi","note":"","ucode":"090D9C4068FF12","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"奕","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537814,"discussion_content":"稀疏数组的初始化，前面第15课有讲的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1639205542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":537680,"ip_address":"","group_id":0},"score":537814,"extra":""},{"author":{"id":2885586,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/07/d2/1bdf9d33.jpg","nickname":"勤学如春起之苗,不见其增,日有所长","note":"","ucode":"E8E885754513BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"奕","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585238,"discussion_content":"应该是，把4赋值给数组下标为3的元素，就是第4个元素，所以长度是4？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661413267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":537680,"ip_address":"上海","group_id":0},"score":585238,"extra":""}]}]},{"had_liked":false,"id":343987,"user_name":"van","can_delete":false,"product_type":"c1","uid":1766293,"ip_address":"","ucode":"26FAFF7224F12D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/f3/95/77628ed0.jpg","comment_is_top":false,"comment_ctime":1651156808,"is_pvip":true,"replies":[{"id":125653,"content":"把panic当做断言使用的目的是及早发现bug，一旦断言发生，意味着整个程序出现了不可恢复的状态。对于这类panic，不要recover。尽早失败并解决bug。所以在什么位置进行断言，对哪些条件进行断言是需要考量的。在C语言中使用assert也是同样的道理。一旦assert失败，便会dump core文件。程序终止。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1651270636,"ip_address":"","comment_id":343987,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"panic作为断言使用，上一层的调用者还是需要自己recover回来吧，不然这个调用链会最终传到main函数","like_count":3,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568934,"discussion_content":"把panic当做断言使用的目的是及早发现bug，一旦断言发生，意味着整个程序出现了不可恢复的状态。对于这类panic，不要recover。尽早失败并解决bug。所以在什么位置进行断言，对哪些条件进行断言是需要考量的。在C语言中使用assert也是同样的道理。一旦assert失败，便会dump core文件。程序终止。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1651270636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329678,"user_name":"ゝ骑着小车去兜风。","can_delete":false,"product_type":"c1","uid":2600957,"ip_address":"","ucode":"35F9E5360DF42C","user_header":"https://static001.geekbang.org/account/avatar/00/27/af/fd/a1708649.jpg","comment_is_top":false,"comment_ctime":1641466575,"is_pvip":false,"replies":[{"id":120477,"content":"循环结束后，i的值为4. defer输出的是i的值，于是就都是4.","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1642040805,"ip_address":"","comment_id":329678,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"老师你好，没太明白闭包的原理，想不明白为什么输出的是4，请帮忙解答下","like_count":3,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545693,"discussion_content":"循环结束后，i的值为4. defer输出的是i的值，于是就都是4.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642040805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":2175841,"avatar":"https://static001.geekbang.org/account/avatar/00/21/33/61/16505a1a.jpg","nickname":"He","note":"","ucode":"7F5FF5BEE48AF1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":579999,"discussion_content":"老师你好\n不考虑 continue和break,for 的执行顺序是不是这样的\n前置操作-&gt;判断条件表达式-&gt;循环体\n然后\n后置操作-&gt;判断条件表达式循环体\ni=3 的时候，后置操作还是执行了i++，只是判断条件没过，所以i=4","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1657794593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":545693,"ip_address":"","group_id":0},"score":579999,"extra":""},{"author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2175841,"avatar":"https://static001.geekbang.org/account/avatar/00/21/33/61/16505a1a.jpg","nickname":"He","note":"","ucode":"7F5FF5BEE48AF1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621001,"discussion_content":"是这样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1686728311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":579999,"ip_address":"广东","group_id":0},"score":621001,"extra":""}]},{"author":{"id":1915533,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/3a/8d/f5e7a20d.jpg","nickname":"何以解忧","note":"","ucode":"4DFE2BDBAF4919","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":654200,"discussion_content":"iteration 共享作用域，这个例子放在及时求值有点绕人，像是执行的时候取最新的值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1732164126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325821,"user_name":"功夫熊猫","can_delete":false,"product_type":"c1","uid":2732243,"ip_address":"","ucode":"D124F4FA4E816F","user_header":"https://static001.geekbang.org/account/avatar/00/29/b0/d3/200e82ff.jpg","comment_is_top":false,"comment_ctime":1639152392,"is_pvip":false,"replies":[{"id":119090,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1640054649,"ip_address":"","comment_id":325821,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"defer数据库的开关。锁的申请释放。TCP的连接和断开之类的","like_count":3,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540415,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640054649,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324930,"user_name":"宋世杰","can_delete":false,"product_type":"c1","uid":2068776,"ip_address":"","ucode":"0869FF74808452","user_header":"https://static001.geekbang.org/account/avatar/00/1f/91/28/f2dcbbfe.jpg","comment_is_top":false,"comment_ctime":1638722190,"is_pvip":true,"replies":[{"id":117954,"content":"是go runtime层实现的。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1638827605,"ip_address":"","comment_id":324930,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"Defer函数被放在一个不同于主函数的函数栈中吗？ 是用slice实现的吗？","like_count":3,"discussions":[{"author":{"id":1479120,"avatar":"https://static001.geekbang.org/account/avatar/00/16/91/d0/35bc62b1.jpg","nickname":"无咎","note":"","ucode":"B9759B5646F3AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":603101,"discussion_content":"由Go runtime来实现。\n从语义上与容器函数在同一个生命周期，从实现上说，在同一个stack frame上比较容易实现。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1675941229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536813,"discussion_content":"同学，你这里为何说：“一个不同于主函数的函数栈中”。我看文中老师说：“defer 将它们注册到其所在 Goroutine 中，用于存放 deferred 函数的栈数据结构中”。没明白你说的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638873564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2323716,"avatar":"https://static001.geekbang.org/account/avatar/00/23/75/04/d26cd437.jpg","nickname":"lemon","note":"","ucode":"47626025C55E5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540526,"discussion_content":"感觉这个同学要表达的是说，deferred函数所在的函数栈和调用defer的函数所在的正常函数栈不是同一个","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640075645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":536813,"ip_address":"","group_id":0},"score":540526,"extra":""}]},{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536580,"discussion_content":"是go runtime层实现的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638827605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345769,"user_name":"Felix","can_delete":false,"product_type":"c1","uid":1285253,"ip_address":"","ucode":"6F674755CAB29D","user_header":"https://static001.geekbang.org/account/avatar/00/13/9c/85/d9614715.jpg","comment_is_top":false,"comment_ctime":1652583011,"is_pvip":false,"replies":[{"id":126231,"content":"func fooWithDefer() {\n    defer func() {\n        sum(10)\n    }()\n}\n\n这个函数算不上闭包啊。defer只是注册了一个匿名函数，该函数并没有捕捉fooWithDefer函数的本地变量。\n\n我怀疑func fooWithDefer() {\n    defer func() {\n        sum(10)\n    }()\n}\n中的sum(10)调用被直接内联优化了(inline)，而不是做函数调用了。\n\n同理fooWithoutDefer对sum的调用也很大可能被inline了。\n\n我在macos上关闭inline和优化的结果：\n\n$go test -gcflags &quot;-N -l&quot; -v -bench .\ngoos: darwin\ngoarch: amd64\npkg: demo\ncpu: Intel(R) Core(TM) i5-8257U CPU @ 1.40GHz\nBenchmarkFooWithDeferNoClosure\nBenchmarkFooWithDeferNoClosure-8   \t37973526\t        27.60 ns&#47;op\nBenchmarkFooWithDefer\nBenchmarkFooWithDefer-8            \t43756006\t        27.57 ns&#47;op\nBenchmarkFooWithoutDefer\nBenchmarkFooWithoutDefer-8         \t71541520\t        17.22 ns&#47;op\nPASS\nok  \tdemo\t3.576s\n\n两个带defer的几乎没区别了。\n","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1652691068,"ip_address":"","comment_id":345769,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"defer benchmark的例子中，函数sum有返回值，所有defer的时候放在闭包里面，如果函数sum没有返回值，可以直接放在defer后面defer sum()，我做了一下benchmark，发现还是放闭包里面比较快，go语言对闭包有什么优化吗，感觉用闭包会多压一次栈，但是反而更快，老师能解答一下吗？\n&#47;&#47; defer_test.go\npackage main\n\nimport &quot;testing&quot;\n\nfunc sum(max int) {\n    total := 0\n    for i := 0; i &lt; max; i++ {\n        total += i\n    }\n}\n\nfunc fooWithDeferNoClosure() {\n\tdefer sum(10)\n}\n\nfunc fooWithDefer() {\n    defer func() {\n        sum(10)\n    }()\n}\nfunc fooWithoutDefer() {\n    sum(10)\n}\n\nfunc BenchmarkFooWithDeferNoClosure(b *testing.B) {\n    for i := 0; i &lt; b.N; i++ {\n        fooWithDeferNoClosure()\n    }\n}\n\nfunc BenchmarkFooWithDefer(b *testing.B) {\n    for i := 0; i &lt; b.N; i++ {\n        fooWithDefer()\n    }\n}\nfunc BenchmarkFooWithoutDefer(b *testing.B) {\n    for i := 0; i &lt; b.N; i++ {\n        fooWithoutDefer()\n    }\n}\n\nbenchmark结果：\n$ go test -bench . defer_test.go\ngoos: linux\ngoarch: amd64\ncpu: Intel Core Processor (Broadwell, IBRS)\nBenchmarkFooWithDeferNoClosure-2   \t67386957\t        18.59 ns&#47;op\nBenchmarkFooWithDefer-2                  \t80693001\t        15.45 ns&#47;op\nBenchmarkFooWithoutDefer-2             \t100000000\t11.03 ns&#47;op\nPASS\nok  \tcommand-line-arguments\t3.665s","like_count":2},{"had_liked":false,"id":338018,"user_name":"Rayjun","can_delete":false,"product_type":"c1","uid":1002514,"ip_address":"","ucode":"61A3D1A3D03569","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4c/12/f0c145d4.jpg","comment_is_top":false,"comment_ctime":1647239134,"is_pvip":false,"replies":[{"id":123617,"content":"好问题！panic是一个stack unwinding的过程，而每个goroutine都有自己的执行栈。一个goroutine执行栈上发生的panic，另外一个goroutine肯定是不知晓的。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1647321802,"ip_address":"","comment_id":338018,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师，咨询一个问题，panic 无法跨 goroutine 捕获，这个是为什么呢？","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572282,"discussion_content":"func fooWithDefer() {\n    defer func() {\n        sum(10)\n    }()\n}\n\n这个函数算不上闭包啊。defer只是注册了一个匿名函数，该函数并没有捕捉fooWithDefer函数的本地变量。\n\n我怀疑func fooWithDefer() {\n    defer func() {\n        sum(10)\n    }()\n}\n中的sum(10)调用被直接内联优化了(inline)，而不是做函数调用了。\n\n同理fooWithoutDefer对sum的调用也很大可能被inline了。\n\n我在macos上关闭inline和优化的结果：\n\n$go test -gcflags &#34;-N -l&#34; -v -bench .\ngoos: darwin\ngoarch: amd64\npkg: demo\ncpu: Intel(R) Core(TM) i5-8257U CPU @ 1.40GHz\nBenchmarkFooWithDeferNoClosure\nBenchmarkFooWithDeferNoClosure-8   \t37973526\t        27.60 ns/op\nBenchmarkFooWithDefer\nBenchmarkFooWithDefer-8            \t43756006\t        27.57 ns/op\nBenchmarkFooWithoutDefer\nBenchmarkFooWithoutDefer-8         \t71541520\t        17.22 ns/op\nPASS\nok  \tdemo\t3.576s\n\n两个带defer的几乎没区别了。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652691068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336953,"user_name":"风铃","can_delete":false,"product_type":"c1","uid":2633228,"ip_address":"","ucode":"999A26CC937C78","user_header":"https://static001.geekbang.org/account/avatar/00/28/2e/0c/b6180a5f.jpg","comment_is_top":false,"comment_ctime":1646488489,"is_pvip":false,"replies":[{"id":123235,"content":"嗯，这样写就把错误处理与异常处理混淆了。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1646722245,"ip_address":"","comment_id":336953,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"自己以前写代码，总是在panic把错误信息包进去\nif !=nil{\n    panic(fmt.Errorf(&quot;err is:%s\\n&quot;,err))\n}","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555016,"discussion_content":"嗯，这样写就把错误处理与异常处理混淆了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646722245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328614,"user_name":"Geek_7jzyrf","can_delete":false,"product_type":"c1","uid":1780608,"ip_address":"","ucode":"604202E40E9AA5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/pibibkbticCqnwDJkluy5QAWibesJ7vxLbQIG5sewicnjyjYFD9S4Oq9XYxxmjWTQTtFaNeYN6MpXwNAqfe8vUib21PA/132","comment_is_top":false,"comment_ctime":1640789355,"is_pvip":false,"replies":[{"id":120424,"content":"i=3后，循环体执行，然后执行循环后置语句i++，这样i就为4了啊。之后deferred 函数被执行，输出的i为4。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1641997053,"ip_address":"","comment_id":328614,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师，在  “注意 defer 关键字后面表达式的求值时机” 这个知识点，\n func foo3(){\n\t for i :=0; i &lt;=3; i++{\n\t\t defer func(){  \n\t\t\t fmt.Println(i)\n\n\t\t }()\n\t }\n }\n输出结果为啥是4？ i 最大应该只能取到3吧？没看明白，希望老师进一步解答下！","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545583,"discussion_content":"i=3后，循环体执行，然后执行循环后置语句i++，这样i就为4了啊。之后deferred 函数被执行，输出的i为4。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641997054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1559831,"avatar":"https://static001.geekbang.org/account/avatar/00/17/cd/17/d7fdb428.jpg","nickname":"石头","note":"","ucode":"BD9A4319961733","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543510,"discussion_content":"最后一次循环之后i是3，但是最后进行了i++就是4了，判读4比3大之后才会结束循环。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1641188861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325332,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1638926098,"is_pvip":false,"replies":[{"id":118593,"content":"是的。但复活了，程序也结束了:)。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1639560727,"ip_address":"","comment_id":325332,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"在 main 函数开始加上这样的代码，可以从 panic 中无限复活了\ndefer func() {\n\tif e := recover(); e != nil {\n\t\tfmt.Println(&quot;recover the panic:&quot;, e)\n\t}\n}()","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545583,"discussion_content":"i=3后，循环体执行，然后执行循环后置语句i++，这样i就为4了啊。之后deferred 函数被执行，输出的i为4。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641997054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1559831,"avatar":"https://static001.geekbang.org/account/avatar/00/17/cd/17/d7fdb428.jpg","nickname":"石头","note":"","ucode":"BD9A4319961733","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543510,"discussion_content":"最后一次循环之后i是3，但是最后进行了i++就是4了，判读4比3大之后才会结束循环。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1641188861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325207,"user_name":"Bynow","can_delete":false,"product_type":"c1","uid":2735072,"ip_address":"","ucode":"1E4F3ADD65CF18","user_header":"https://static001.geekbang.org/account/avatar/00/29/bb/e0/c7cd5170.jpg","comment_is_top":false,"comment_ctime":1638863486,"is_pvip":false,"replies":[{"id":118586,"content":"你换成直接在命令行执行这个程序呢？","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1639558549,"ip_address":"","comment_id":325207,"utype":1}],"discussion_count":6,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"我用的goland ，文中更新后的bar代码：我的编辑器终端输出是\ncall main\ncall foo\ncall bar\nexit foo\nexit main\nrecover the panic: panic occurs in bar\n\n但是我打断点调试的确是按照老师的那样去执行和输出的，这是怎么回事？","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538929,"discussion_content":"你换成直接在命令行执行这个程序呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639558549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2735072,"avatar":"https://static001.geekbang.org/account/avatar/00/29/bb/e0/c7cd5170.jpg","nickname":"Bynow","note":"","ucode":"1E4F3ADD65CF18","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":545509,"discussion_content":"\nprintLn和fmt.PrintLn 混用会导致输出顺序不一致","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641979639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":538929,"ip_address":"","group_id":0},"score":545509,"extra":""}]},{"author":{"id":1248326,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0c/46/dfe32cf4.jpg","nickname":"多选参数","note":"","ucode":"B2294D80AB075F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537349,"discussion_content":"这个我觉得更多是输出的问题，而不是执行的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639040533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2049562,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/aQmhiahazRFUA4W3r1hdxxreSB5Pl54IwAJ8bwN6j02lzicydWAfPFbWx1LSFtzXH8MkI0jUKjlpUtmQBoZ4kReA/132","nickname":"Geek_99b47c","note":"","ucode":"D25E22C1D84E09","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537091,"discussion_content":"是的。混合用输出顺序会不一样，不知道为什么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638955040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2735072,"avatar":"https://static001.geekbang.org/account/avatar/00/29/bb/e0/c7cd5170.jpg","nickname":"Bynow","note":"","ucode":"1E4F3ADD65CF18","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536880,"discussion_content":"printLn和fmt.PrintLn 混用会导致输出顺序不一致","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638886245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2735072,"avatar":"https://static001.geekbang.org/account/avatar/00/29/bb/e0/c7cd5170.jpg","nickname":"Bynow","note":"","ucode":"1E4F3ADD65CF18","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536764,"discussion_content":"我把输出统一都改成fmt.Println就可以了。不知道是为啥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638864512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":375169,"user_name":"大年糕","can_delete":false,"product_type":"c1","uid":2687098,"ip_address":"山东","ucode":"D776067299F785","user_header":"https://static001.geekbang.org/account/avatar/00/29/00/7a/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1685003433,"is_pvip":false,"replies":[{"id":136929,"content":"我理解：承担一部分相似的职责，但不等价哦。析构函数在对象销毁时自动调用，defer只是针对函数或方法。go没有析构函数这一说。如果要在一个heap对象被gc释放时做一些事情，可以用runtime.SetFinalizer，不过这是高级用法，大多数情况无需考虑。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1685068799,"ip_address":"北京","comment_id":375169,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"把defer作为析构函数使用?","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":619405,"discussion_content":"我理解：承担一部分相似的职责，但不等价哦。析构函数在对象销毁时自动调用，defer只是针对函数或方法。go没有析构函数这一说。如果要在一个heap对象被gc释放时做一些事情，可以用runtime.SetFinalizer，不过这是高级用法，大多数情况无需考虑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685068799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":374793,"user_name":"Geek_73c432","can_delete":false,"product_type":"c1","uid":2869118,"ip_address":"广东","ucode":"3E11EB02B14DE0","user_header":"","comment_is_top":false,"comment_ctime":1684426108,"is_pvip":false,"replies":[{"id":136765,"content":"Go的panic语义就是这样的（go spec）：“While executing a function F, an explicit call to panic or a run-time panic terminates the execution of F. Any functions deferred by F are then executed as usual. Next, any deferred functions run by F&#39;s caller are run, and so on up to any deferred by the top-level function in the executing goroutine” 。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1684502071,"ip_address":"辽宁","comment_id":374793,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"有没有可能 deferred 函数本身执行的时候会引发异常（panic）呢？\n\n经测试（go version go1.20.2 linux&#47;amd64）在这种情况下，其他已经注册的 deferred 函数还会正常执行，例如这个捕获 panic 并恢复的 deferred 函数\n\nfunc deferTest() {\n        &#47;&#47; func1\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tfmt.Println(&quot;recover the panic: &quot;, err)\n\t\t}\n\t}()\n\tdefer func() {\n\t\tfmt.Println(&quot;exit... with panic&quot;)\n\t\tpanic(&quot;whatever...&quot;)\n\t}()\n}\n\n为啥已经触发 panicking，func1 还会执行呢？","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":618749,"discussion_content":"Go的panic语义就是这样的（go spec）：“While executing a function F, an explicit call to panic or a run-time panic terminates the execution of F. Any functions deferred by F are then executed as usual. Next, any deferred functions run by F&#39;s caller are run, and so on up to any deferred by the top-level function in the executing goroutine” 。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1684502071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371396,"user_name":"Geek_0d5d37","can_delete":false,"product_type":"c1","uid":3522132,"ip_address":"四川","ucode":"1BB4AEF1328C64","user_header":"","comment_is_top":false,"comment_ctime":1679899925,"is_pvip":false,"replies":[{"id":135517,"content":"1. defer注册时求值的是其注册的函数的参数，这里是defer func() {....}，后面的匿名函数没有参数。\n2. 闭包环境指的是包裹(wrap)闭包函数的那个函数，这里就是foo3，而不是循环体。循环体是foo3内执行的逻辑，不是闭包环境。因此闭包函数捕捉到的foo3的变量就是循环变量i：\n\n这里用一个foo3的等价函数来表示，你可能就理解了：\n\nfunc foo3() {\n       i := 0\n       for i = 0; i &lt;= 3; i++ {\n        defer func() {\n            fmt.Println(i)\n        }()\n    }\n}","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1679926099,"ip_address":"辽宁","comment_id":371396,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"作者回复: 首先确认一下对for语义的理解。针对for i := 0; i &lt;= 3; i++ {}循环， 当i=3时，for进入循环体，然后执行后置语句i++，之后i的值为4. 然后再判断循环条件i&lt;=3，不满足，for循环结束。于是i的最终值就是4。\n\ndefer执行时，i是4，闭包引用的是同一个i，所以都输出4。\n\n老师您好。 上面是您回答的一个问题，基于这个问题我有点不理解\n\n既然defer 后面的函数是在执行defer的时候注册并求值，那闭包引用的也是当前环境的变量。 也就是for 每次执行循环体时注册的闭包环境， 最后延迟调用也是注册时对应的闭包环境的i值， 而不是循环判断不满足条件结束循环后运行的环境。  这是不明白的点，麻烦老师有空时讲解下","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":611103,"discussion_content":"1. defer注册时求值的是其注册的函数的参数，这里是defer func() {....}，后面的匿名函数没有参数。\n2. 闭包环境指的是包裹(wrap)闭包函数的那个函数，这里就是foo3，而不是循环体。循环体是foo3内执行的逻辑，不是闭包环境。因此闭包函数捕捉到的foo3的变量就是循环变量i：\n\n这里用一个foo3的等价函数来表示，你可能就理解了：\n\nfunc foo3() {\n       i := 0\n       for i = 0; i &lt;= 3; i++ {\n        defer func() {\n            fmt.Println(i)\n        }()\n    }\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679926099,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3522132,"avatar":"","nickname":"Geek_0d5d37","note":"","ucode":"1BB4AEF1328C64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":611164,"discussion_content":"感谢老师的细心回答，对闭包的理解又深入一些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679969704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365569,"user_name":"geektime_zpf","can_delete":false,"product_type":"c1","uid":1041743,"ip_address":"北京","ucode":"FD61BCAD02CA54","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e5/4f/731ef2c1.jpg","comment_is_top":false,"comment_ctime":1672791171,"is_pvip":true,"replies":[{"id":133167,"content":"就是当程序指令执行到defer xxxx那一行时。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1672809214,"ip_address":"北京","comment_id":365569,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"&quot;defer 关键字后面的表达式，是在将 deferred 函数注册到 deferred 函数栈的时候进行求值的&quot;\n老师你好，请问deffered函数注册到函数栈的时机具体是什么？","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598401,"discussion_content":"就是当程序指令执行到defer xxxx那一行时。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672809214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345769,"user_name":"Felix","can_delete":false,"product_type":"c1","uid":1285253,"ip_address":"","ucode":"6F674755CAB29D","user_header":"https://static001.geekbang.org/account/avatar/00/13/9c/85/d9614715.jpg","comment_is_top":false,"comment_ctime":1652583011,"is_pvip":false,"replies":[{"id":126231,"content":"func fooWithDefer() {\n    defer func() {\n        sum(10)\n    }()\n}\n\n这个函数算不上闭包啊。defer只是注册了一个匿名函数，该函数并没有捕捉fooWithDefer函数的本地变量。\n\n我怀疑func fooWithDefer() {\n    defer func() {\n        sum(10)\n    }()\n}\n中的sum(10)调用被直接内联优化了(inline)，而不是做函数调用了。\n\n同理fooWithoutDefer对sum的调用也很大可能被inline了。\n\n我在macos上关闭inline和优化的结果：\n\n$go test -gcflags &quot;-N -l&quot; -v -bench .\ngoos: darwin\ngoarch: amd64\npkg: demo\ncpu: Intel(R) Core(TM) i5-8257U CPU @ 1.40GHz\nBenchmarkFooWithDeferNoClosure\nBenchmarkFooWithDeferNoClosure-8   \t37973526\t        27.60 ns&#47;op\nBenchmarkFooWithDefer\nBenchmarkFooWithDefer-8            \t43756006\t        27.57 ns&#47;op\nBenchmarkFooWithoutDefer\nBenchmarkFooWithoutDefer-8         \t71541520\t        17.22 ns&#47;op\nPASS\nok  \tdemo\t3.576s\n\n两个带defer的几乎没区别了。\n","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1652691068,"ip_address":"","comment_id":345769,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"defer benchmark的例子中，函数sum有返回值，所有defer的时候放在闭包里面，如果函数sum没有返回值，可以直接放在defer后面defer sum()，我做了一下benchmark，发现还是放闭包里面比较快，go语言对闭包有什么优化吗，感觉用闭包会多压一次栈，但是反而更快，老师能解答一下吗？\n&#47;&#47; defer_test.go\npackage main\n\nimport &quot;testing&quot;\n\nfunc sum(max int) {\n    total := 0\n    for i := 0; i &lt; max; i++ {\n        total += i\n    }\n}\n\nfunc fooWithDeferNoClosure() {\n\tdefer sum(10)\n}\n\nfunc fooWithDefer() {\n    defer func() {\n        sum(10)\n    }()\n}\nfunc fooWithoutDefer() {\n    sum(10)\n}\n\nfunc BenchmarkFooWithDeferNoClosure(b *testing.B) {\n    for i := 0; i &lt; b.N; i++ {\n        fooWithDeferNoClosure()\n    }\n}\n\nfunc BenchmarkFooWithDefer(b *testing.B) {\n    for i := 0; i &lt; b.N; i++ {\n        fooWithDefer()\n    }\n}\nfunc BenchmarkFooWithoutDefer(b *testing.B) {\n    for i := 0; i &lt; b.N; i++ {\n        fooWithoutDefer()\n    }\n}\n\nbenchmark结果：\n$ go test -bench . defer_test.go\ngoos: linux\ngoarch: amd64\ncpu: Intel Core Processor (Broadwell, IBRS)\nBenchmarkFooWithDeferNoClosure-2   \t67386957\t        18.59 ns&#47;op\nBenchmarkFooWithDefer-2                  \t80693001\t        15.45 ns&#47;op\nBenchmarkFooWithoutDefer-2             \t100000000\t11.03 ns&#47;op\nPASS\nok  \tcommand-line-arguments\t3.665s","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572282,"discussion_content":"func fooWithDefer() {\n    defer func() {\n        sum(10)\n    }()\n}\n\n这个函数算不上闭包啊。defer只是注册了一个匿名函数，该函数并没有捕捉fooWithDefer函数的本地变量。\n\n我怀疑func fooWithDefer() {\n    defer func() {\n        sum(10)\n    }()\n}\n中的sum(10)调用被直接内联优化了(inline)，而不是做函数调用了。\n\n同理fooWithoutDefer对sum的调用也很大可能被inline了。\n\n我在macos上关闭inline和优化的结果：\n\n$go test -gcflags &#34;-N -l&#34; -v -bench .\ngoos: darwin\ngoarch: amd64\npkg: demo\ncpu: Intel(R) Core(TM) i5-8257U CPU @ 1.40GHz\nBenchmarkFooWithDeferNoClosure\nBenchmarkFooWithDeferNoClosure-8   \t37973526\t        27.60 ns/op\nBenchmarkFooWithDefer\nBenchmarkFooWithDefer-8            \t43756006\t        27.57 ns/op\nBenchmarkFooWithoutDefer\nBenchmarkFooWithoutDefer-8         \t71541520\t        17.22 ns/op\nPASS\nok  \tdemo\t3.576s\n\n两个带defer的几乎没区别了。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652691068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338018,"user_name":"Rayjun","can_delete":false,"product_type":"c1","uid":1002514,"ip_address":"","ucode":"61A3D1A3D03569","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4c/12/f0c145d4.jpg","comment_is_top":false,"comment_ctime":1647239134,"is_pvip":false,"replies":[{"id":123617,"content":"好问题！panic是一个stack unwinding的过程，而每个goroutine都有自己的执行栈。一个goroutine执行栈上发生的panic，另外一个goroutine肯定是不知晓的。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1647321802,"ip_address":"","comment_id":338018,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师，咨询一个问题，panic 无法跨 goroutine 捕获，这个是为什么呢？","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556347,"discussion_content":"好问题！panic是一个stack unwinding的过程，而每个goroutine都有自己的执行栈。一个goroutine执行栈上发生的panic，另外一个goroutine肯定是不知晓的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1647321802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1002514,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4c/12/f0c145d4.jpg","nickname":"Rayjun","note":"","ucode":"61A3D1A3D03569","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":556631,"discussion_content":"如果是这样的话，那么一个 goroutine 中的 panic 是怎么做到让整个程序崩溃的呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647430467,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":556347,"ip_address":"","group_id":0},"score":556631,"extra":""}]}]},{"had_liked":false,"id":336953,"user_name":"风铃","can_delete":false,"product_type":"c1","uid":2633228,"ip_address":"","ucode":"999A26CC937C78","user_header":"https://static001.geekbang.org/account/avatar/00/28/2e/0c/b6180a5f.jpg","comment_is_top":false,"comment_ctime":1646488489,"is_pvip":false,"replies":[{"id":123235,"content":"嗯，这样写就把错误处理与异常处理混淆了。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1646722245,"ip_address":"","comment_id":336953,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"自己以前写代码，总是在panic把错误信息包进去\nif !=nil{\n    panic(fmt.Errorf(&quot;err is:%s\\n&quot;,err))\n}","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556347,"discussion_content":"好问题！panic是一个stack unwinding的过程，而每个goroutine都有自己的执行栈。一个goroutine执行栈上发生的panic，另外一个goroutine肯定是不知晓的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1647321802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1002514,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4c/12/f0c145d4.jpg","nickname":"Rayjun","note":"","ucode":"61A3D1A3D03569","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":556631,"discussion_content":"如果是这样的话，那么一个 goroutine 中的 panic 是怎么做到让整个程序崩溃的呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647430467,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":556347,"ip_address":"","group_id":0},"score":556631,"extra":""}]}]},{"had_liked":false,"id":328614,"user_name":"Geek_7jzyrf","can_delete":false,"product_type":"c1","uid":1780608,"ip_address":"","ucode":"604202E40E9AA5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/pibibkbticCqnwDJkluy5QAWibesJ7vxLbQIG5sewicnjyjYFD9S4Oq9XYxxmjWTQTtFaNeYN6MpXwNAqfe8vUib21PA/132","comment_is_top":false,"comment_ctime":1640789355,"is_pvip":false,"replies":[{"id":120424,"content":"i=3后，循环体执行，然后执行循环后置语句i++，这样i就为4了啊。之后deferred 函数被执行，输出的i为4。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1641997053,"ip_address":"","comment_id":328614,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师，在  “注意 defer 关键字后面表达式的求值时机” 这个知识点，\n func foo3(){\n\t for i :=0; i &lt;=3; i++{\n\t\t defer func(){  \n\t\t\t fmt.Println(i)\n\n\t\t }()\n\t }\n }\n输出结果为啥是4？ i 最大应该只能取到3吧？没看明白，希望老师进一步解答下！","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555016,"discussion_content":"嗯，这样写就把错误处理与异常处理混淆了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646722245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325332,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1638926098,"is_pvip":false,"replies":[{"id":118593,"content":"是的。但复活了，程序也结束了:)。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1639560727,"ip_address":"","comment_id":325332,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"在 main 函数开始加上这样的代码，可以从 panic 中无限复活了\ndefer func() {\n\tif e := recover(); e != nil {\n\t\tfmt.Println(&quot;recover the panic:&quot;, e)\n\t}\n}()","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538942,"discussion_content":"是的。但复活了，程序也结束了:)。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1639560727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325207,"user_name":"Bynow","can_delete":false,"product_type":"c1","uid":2735072,"ip_address":"","ucode":"1E4F3ADD65CF18","user_header":"https://static001.geekbang.org/account/avatar/00/29/bb/e0/c7cd5170.jpg","comment_is_top":false,"comment_ctime":1638863486,"is_pvip":false,"replies":[{"id":118586,"content":"你换成直接在命令行执行这个程序呢？","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1639558549,"ip_address":"","comment_id":325207,"utype":1}],"discussion_count":6,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"我用的goland ，文中更新后的bar代码：我的编辑器终端输出是\ncall main\ncall foo\ncall bar\nexit foo\nexit main\nrecover the panic: panic occurs in bar\n\n但是我打断点调试的确是按照老师的那样去执行和输出的，这是怎么回事？","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538942,"discussion_content":"是的。但复活了，程序也结束了:)。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1639560727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":375169,"user_name":"大年糕","can_delete":false,"product_type":"c1","uid":2687098,"ip_address":"山东","ucode":"D776067299F785","user_header":"https://static001.geekbang.org/account/avatar/00/29/00/7a/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1685003433,"is_pvip":false,"replies":[{"id":136929,"content":"我理解：承担一部分相似的职责，但不等价哦。析构函数在对象销毁时自动调用，defer只是针对函数或方法。go没有析构函数这一说。如果要在一个heap对象被gc释放时做一些事情，可以用runtime.SetFinalizer，不过这是高级用法，大多数情况无需考虑。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1685068799,"ip_address":"北京","comment_id":375169,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"把defer作为析构函数使用?","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538929,"discussion_content":"你换成直接在命令行执行这个程序呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639558549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2735072,"avatar":"https://static001.geekbang.org/account/avatar/00/29/bb/e0/c7cd5170.jpg","nickname":"Bynow","note":"","ucode":"1E4F3ADD65CF18","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":545509,"discussion_content":"\nprintLn和fmt.PrintLn 混用会导致输出顺序不一致","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641979639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":538929,"ip_address":"","group_id":0},"score":545509,"extra":""}]},{"author":{"id":1248326,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0c/46/dfe32cf4.jpg","nickname":"多选参数","note":"","ucode":"B2294D80AB075F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537349,"discussion_content":"这个我觉得更多是输出的问题，而不是执行的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639040533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2049562,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/aQmhiahazRFUA4W3r1hdxxreSB5Pl54IwAJ8bwN6j02lzicydWAfPFbWx1LSFtzXH8MkI0jUKjlpUtmQBoZ4kReA/132","nickname":"Geek_99b47c","note":"","ucode":"D25E22C1D84E09","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537091,"discussion_content":"是的。混合用输出顺序会不一样，不知道为什么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638955040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2735072,"avatar":"https://static001.geekbang.org/account/avatar/00/29/bb/e0/c7cd5170.jpg","nickname":"Bynow","note":"","ucode":"1E4F3ADD65CF18","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536880,"discussion_content":"printLn和fmt.PrintLn 混用会导致输出顺序不一致","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638886245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2735072,"avatar":"https://static001.geekbang.org/account/avatar/00/29/bb/e0/c7cd5170.jpg","nickname":"Bynow","note":"","ucode":"1E4F3ADD65CF18","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536764,"discussion_content":"我把输出统一都改成fmt.Println就可以了。不知道是为啥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638864512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":374793,"user_name":"Geek_73c432","can_delete":false,"product_type":"c1","uid":2869118,"ip_address":"广东","ucode":"3E11EB02B14DE0","user_header":"","comment_is_top":false,"comment_ctime":1684426108,"is_pvip":false,"replies":[{"id":136765,"content":"Go的panic语义就是这样的（go spec）：“While executing a function F, an explicit call to panic or a run-time panic terminates the execution of F. Any functions deferred by F are then executed as usual. Next, any deferred functions run by F&#39;s caller are run, and so on up to any deferred by the top-level function in the executing goroutine” 。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1684502071,"ip_address":"辽宁","comment_id":374793,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"有没有可能 deferred 函数本身执行的时候会引发异常（panic）呢？\n\n经测试（go version go1.20.2 linux&#47;amd64）在这种情况下，其他已经注册的 deferred 函数还会正常执行，例如这个捕获 panic 并恢复的 deferred 函数\n\nfunc deferTest() {\n        &#47;&#47; func1\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tfmt.Println(&quot;recover the panic: &quot;, err)\n\t\t}\n\t}()\n\tdefer func() {\n\t\tfmt.Println(&quot;exit... with panic&quot;)\n\t\tpanic(&quot;whatever...&quot;)\n\t}()\n}\n\n为啥已经触发 panicking，func1 还会执行呢？","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":619405,"discussion_content":"我理解：承担一部分相似的职责，但不等价哦。析构函数在对象销毁时自动调用，defer只是针对函数或方法。go没有析构函数这一说。如果要在一个heap对象被gc释放时做一些事情，可以用runtime.SetFinalizer，不过这是高级用法，大多数情况无需考虑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685068799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371396,"user_name":"Geek_0d5d37","can_delete":false,"product_type":"c1","uid":3522132,"ip_address":"四川","ucode":"1BB4AEF1328C64","user_header":"","comment_is_top":false,"comment_ctime":1679899925,"is_pvip":false,"replies":[{"id":135517,"content":"1. defer注册时求值的是其注册的函数的参数，这里是defer func() {....}，后面的匿名函数没有参数。\n2. 闭包环境指的是包裹(wrap)闭包函数的那个函数，这里就是foo3，而不是循环体。循环体是foo3内执行的逻辑，不是闭包环境。因此闭包函数捕捉到的foo3的变量就是循环变量i：\n\n这里用一个foo3的等价函数来表示，你可能就理解了：\n\nfunc foo3() {\n       i := 0\n       for i = 0; i &lt;= 3; i++ {\n        defer func() {\n            fmt.Println(i)\n        }()\n    }\n}","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1679926099,"ip_address":"辽宁","comment_id":371396,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"作者回复: 首先确认一下对for语义的理解。针对for i := 0; i &lt;= 3; i++ {}循环， 当i=3时，for进入循环体，然后执行后置语句i++，之后i的值为4. 然后再判断循环条件i&lt;=3，不满足，for循环结束。于是i的最终值就是4。\n\ndefer执行时，i是4，闭包引用的是同一个i，所以都输出4。\n\n老师您好。 上面是您回答的一个问题，基于这个问题我有点不理解\n\n既然defer 后面的函数是在执行defer的时候注册并求值，那闭包引用的也是当前环境的变量。 也就是for 每次执行循环体时注册的闭包环境， 最后延迟调用也是注册时对应的闭包环境的i值， 而不是循环判断不满足条件结束循环后运行的环境。  这是不明白的点，麻烦老师有空时讲解下","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":618749,"discussion_content":"Go的panic语义就是这样的（go spec）：“While executing a function F, an explicit call to panic or a run-time panic terminates the execution of F. Any functions deferred by F are then executed as usual. Next, any deferred functions run by F&#39;s caller are run, and so on up to any deferred by the top-level function in the executing goroutine” 。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1684502071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365569,"user_name":"geektime_zpf","can_delete":false,"product_type":"c1","uid":1041743,"ip_address":"北京","ucode":"FD61BCAD02CA54","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e5/4f/731ef2c1.jpg","comment_is_top":false,"comment_ctime":1672791171,"is_pvip":true,"replies":[{"id":133167,"content":"就是当程序指令执行到defer xxxx那一行时。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1672809214,"ip_address":"北京","comment_id":365569,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"&quot;defer 关键字后面的表达式，是在将 deferred 函数注册到 deferred 函数栈的时候进行求值的&quot;\n老师你好，请问deffered函数注册到函数栈的时机具体是什么？","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":611103,"discussion_content":"1. defer注册时求值的是其注册的函数的参数，这里是defer func() {....}，后面的匿名函数没有参数。\n2. 闭包环境指的是包裹(wrap)闭包函数的那个函数，这里就是foo3，而不是循环体。循环体是foo3内执行的逻辑，不是闭包环境。因此闭包函数捕捉到的foo3的变量就是循环变量i：\n\n这里用一个foo3的等价函数来表示，你可能就理解了：\n\nfunc foo3() {\n       i := 0\n       for i = 0; i &lt;= 3; i++ {\n        defer func() {\n            fmt.Println(i)\n        }()\n    }\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679926099,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3522132,"avatar":"","nickname":"Geek_0d5d37","note":"","ucode":"1BB4AEF1328C64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":611164,"discussion_content":"感谢老师的细心回答，对闭包的理解又深入一些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679969704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348978,"user_name":"宥晓","can_delete":false,"product_type":"c1","uid":2528776,"ip_address":"","ucode":"14473AB22CE7FC","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/LN7qpRLUGO2IHMnbDuF4YEsd9PxdFHAumWsHE8AhibeQUryIfgsQZ3JIZswVcCRkVSaelhFiatCZ6wpQFoLBLVFA/132","comment_is_top":false,"comment_ctime":1655619314,"is_pvip":false,"replies":[{"id":127023,"content":"我在自己机器上用go 1.18.3跑了一下：\n\n$go test -bench . defer_test.go\ngoos: darwin\ngoarch: amd64\ncpu: Intel(R) Core(TM) i5-8257U CPU @ 1.40GHz\nBenchmarkFooWithDefer-8      \t196703528\t         6.086 ns&#47;op\nBenchmarkFooWithoutDefer-8   \t309812937\t         3.840 ns&#47;op\nPASS\nok  \tcommand-line-arguments\t3.408s\n\n相对于文中的go 1.17的结果的确有些差异。但考虑到测试执行的环境并非独占，有很多影响因素，因此，不能断定是go 1.18.3带来的性能回退。\n\n从go 1.18.3的milestone中的issue list来看，似乎没有哪个与defer有关。\n\nhttps:&#47;&#47;github.com&#47;golang&#47;go&#47;issues?q=milestone%3AGo1.18.3+label%3ACherryPickApproved\n\n","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1655700721,"ip_address":"","comment_id":348978,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"go 的版本1.18.3, defer的性能下降了，这是有什么大的变动吗？\n\ngo test -bench . defer_test.go\n\ngoos: darwin\ngoarch: amd64\ncpu: Intel(R) Core(TM) i5-1038NG7 CPU @ 2.00GHz\nBenchmarkFooWithDefer-8         191820978                6.144 ns&#47;op\nBenchmarkFooWithoutDefer-8      527924869                2.245 ns&#47;op\nPASS\nok      command-line-arguments  3.643s\n","like_count":1},{"had_liked":false,"id":347640,"user_name":"qiutian","can_delete":false,"product_type":"c1","uid":1313498,"ip_address":"","ucode":"99658A8E342498","user_header":"https://static001.geekbang.org/account/avatar/00/14/0a/da/dcf8f2b1.jpg","comment_is_top":false,"comment_ctime":1654243647,"is_pvip":false,"replies":[{"id":126779,"content":"严格来说zoo是执行不到的，因为panic发生在zoo前面。不过，这里只是为了演示而故意编写的例子。不用太过计较:)。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1654482082,"ip_address":"","comment_id":347640,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"我的vscode静态检查出：func zoo is unused (U1000)go-staticcheck\n但是通过build 构建和 运行是可以得到和目标相同的结果的","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576603,"discussion_content":"我在自己机器上用go 1.18.3跑了一下：\n\n$go test -bench . defer_test.go\ngoos: darwin\ngoarch: amd64\ncpu: Intel(R) Core(TM) i5-8257U CPU @ 1.40GHz\nBenchmarkFooWithDefer-8      \t196703528\t         6.086 ns/op\nBenchmarkFooWithoutDefer-8   \t309812937\t         3.840 ns/op\nPASS\nok  \tcommand-line-arguments\t3.408s\n\n相对于文中的go 1.17的结果的确有些差异。但考虑到测试执行的环境并非独占，有很多影响因素，因此，不能断定是go 1.18.3带来的性能回退。\n\n从go 1.18.3的milestone中的issue list来看，似乎没有哪个与defer有关。\n\nhttps://github.com/golang/go/issues?q=milestone%3AGo1.18.3+label%3ACherryPickApproved\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655700722,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346032,"user_name":"Junior Programmer","can_delete":false,"product_type":"c1","uid":2395539,"ip_address":"","ucode":"C56FF19934512E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/tVrFvKWxQAuL7DE911OmlcqnfEkBnx14dBmCdI8eOx6ziaQB4Pgml65tcIDO4ePfW5yPTyAxGovYQmXLZHAPe2Q/132","comment_is_top":false,"comment_ctime":1652779753,"is_pvip":false,"replies":[{"id":126260,"content":"重新温习一下第19讲中关于for循环语句的执行过程，你就能明白了:)。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1652822426,"ip_address":"","comment_id":346032,"utype":1}],"discussion_count":0,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"老师您好,对于defer参数求值时机有一点疑惑，func foo1() { for i := 0; i &lt;= 3; i++ { defer fmt.Println(i) }}这个i参数，传入到fmt.Printlin中不是应该是1开始的吗，然后根据defer执行时先进后出原则,应该是4,3,2,1,但是我在本地运行的是3,2,1,0，也就是说defer参数传入的时机，还没有执行i++，这个是什么原因呢？","like_count":1},{"had_liked":false,"id":343840,"user_name":"mikewoo","can_delete":false,"product_type":"c1","uid":1118888,"ip_address":"","ucode":"9AE90E05048DE1","user_header":"https://static001.geekbang.org/account/avatar/00/11/12/a8/8aaf13e0.jpg","comment_is_top":false,"comment_ctime":1651074025,"is_pvip":true,"replies":[{"id":125587,"content":"首先确认一下对for语义的理解。针对for i := 0; i &lt;= 3; i++ {}循环， 当i=3时，for进入循环体，然后执行后置语句i++，之后i的值为4. 然后再判断循环条件i&lt;=3，不满足，for循环结束。于是i的最终值就是4。\n\ndefer执行时，i是4，闭包引用的是同一个i，所以都输出4。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1651136940,"ip_address":"","comment_id":343840,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"老师，这篇文章给了我很多新的理解，收获满满。课程中“当 foo3 返回后，deferred 函数被调度执行时，上述压入栈的 deferred 函数将以 LIFO 次序出栈执行。匿名函数会以闭包的方式访问外围函数的变量 i，并通过 Println 输出 i 的值，此时 i 的值为 4。”为什么输出的结果都是4，这个不是很理解，能否帮忙再解释一下，谢谢。","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568442,"discussion_content":"首先确认一下对for语义的理解。针对for i := 0; i &lt;= 3; i++ {}循环， 当i=3时，for进入循环体，然后执行后置语句i++，之后i的值为4. 然后再判断循环条件i&lt;=3，不满足，for循环结束。于是i的最终值就是4。\n\ndefer执行时，i是4，闭包引用的是同一个i，所以都输出4。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651136940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339386,"user_name":"William Ning","can_delete":false,"product_type":"c1","uid":1592279,"ip_address":"","ucode":"4DB8D05E69E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","comment_is_top":false,"comment_ctime":1648051464,"is_pvip":false,"replies":[{"id":124082,"content":"💪","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1648107970,"ip_address":"","comment_id":339386,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"大卡，继续学习，思考中～～","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568442,"discussion_content":"首先确认一下对for语义的理解。针对for i := 0; i &lt;= 3; i++ {}循环， 当i=3时，for进入循环体，然后执行后置语句i++，之后i的值为4. 然后再判断循环条件i&lt;=3，不满足，for循环结束。于是i的最终值就是4。\n\ndefer执行时，i是4，闭包引用的是同一个i，所以都输出4。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651136940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328175,"user_name":"羊羊","can_delete":false,"product_type":"c1","uid":1162597,"ip_address":"","ucode":"B220CE8D1CA5DA","user_header":"https://static001.geekbang.org/account/avatar/00/11/bd/65/fbdf4fc1.jpg","comment_is_top":false,"comment_ctime":1640588869,"is_pvip":false,"replies":[{"id":120402,"content":"对的。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1641995491,"ip_address":"","comment_id":328175,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"对于自定义的函数或方法，defer 可以给与无条件的支持，但是对于有返回值的自定义函数或方法，返回值会在 deferred 函数被调度执行的时候被自动丢弃。  是指defer语句后面的函数的返回值会被丢弃么？下面匿名函数的返回值2没有接受者，return了也没啥用，可以这么理解么？\nfunc bar() {\n\tdefer func() int {\n\t\tfmt.Println(&quot;defer func in bar&quot;)\n\t\treturn 2\n\t}()\n\tfmt.Println(&quot;call bar&quot;)\n\tfmt.Println(&quot;exit bar&quot;)\n}","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558142,"discussion_content":"💪","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648107970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324954,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1638754806,"is_pvip":false,"replies":[{"id":117953,"content":"嗯嗯，如有问题，随时交流。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1638827577,"ip_address":"","comment_id":324954,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"关于 defer 我还要好好看看，一直都没怎么理解透彻","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545552,"discussion_content":"对的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641995491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":393861,"user_name":"Geek_73c432","can_delete":false,"product_type":"c1","uid":2869118,"ip_address":"广东","ucode":"3E11EB02B14DE0","user_header":"","comment_is_top":false,"comment_ctime":1725117613,"is_pvip":false,"replies":[{"id":143130,"content":"标准库是go用户依赖的底层库，在这个层面如果发现recover也没有任何意义的错误，那他会认为还是fail fast最好。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1726441201,"ip_address":"辽宁","comment_id":393861,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"老师好，我在阅读标准库的一些例子的时候发现，当 caller 接收到一个 error 时，惯用法是使用 log.Fatal&#47;log.Fatalf 打印这个 error，这将导致执行 os.Exit(1)，这样不会执行 deferred 函数。例如：\n\nctx, stop := signal.NotifyContext(context.Background(), os.Interrupt)\ndefer stop()\n\np, err := os.FindProcess(os.Getpid())\nif err != nil {\n  log.Fatal(err)\n}\n\n...\n\n这段代码中，如果 os.FindProcess 调用返回 error，stop 函数将不会被执行。如果换成 log.Panicf(err) 的话 stop 函数会被执行。\n\n但是这种场景使用 Panic 有点混淆错误和异常的概念\n\n你怎么看待这两种处理方式？更推荐哪一种呢？","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536579,"discussion_content":"嗯嗯，如有问题，随时交流。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638827577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":391980,"user_name":"山深沾衣","can_delete":false,"product_type":"c1","uid":1314754,"ip_address":"重庆","ucode":"2BBECDF549E3E8","user_header":"https://static001.geekbang.org/account/avatar/00/14/0f/c2/de176336.jpg","comment_is_top":false,"comment_ctime":1719568178,"is_pvip":false,"replies":[{"id":142522,"content":"你用的是Go 1.22版本吧。Go 1.22版本修改了loopvar的语义。修改后，上面代码相当于Go 1.22版本之前的如下代码：\n\nfunc foo3() {\n\tfor i := 0; i &lt;= 3; i++ {\n                i := i\n\t\tdefer func() {\n\t\t\tfmt.Println(i)\n\t\t}()\n\t}\n}","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1719928464,"ip_address":"辽宁","comment_id":391980,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"func foo3() {\n\tfor i := 0; i &lt;= 3; i++ {\n\t\tdefer func() {\n\t\t\tfmt.Println(i)\n\t\t}()\n\t}\n}\n\n这个函数输出的结果是3 2 1 0 怎么和老师的不一样呢","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651183,"discussion_content":"标准库是go用户依赖的底层库，在这个层面如果发现recover也没有任何意义的错误，那他会认为还是fail fast最好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1726441201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390656,"user_name":"人言有力","can_delete":false,"product_type":"c1","uid":1690736,"ip_address":"浙江","ucode":"3708FBBFB641FE","user_header":"https://static001.geekbang.org/account/avatar/00/19/cc/70/64045bc0.jpg","comment_is_top":false,"comment_ctime":1715874099,"is_pvip":false,"replies":[{"id":142123,"content":"学习过程中多做总结是很好的习惯👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1716345200,"ip_address":"北京","comment_id":390656,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"本节核心介绍了panic、recover、defer三个关键字对程序异常和健壮性的帮助\n1. panic是手动触发程序崩溃，常用于断言\n2.recover是恢复panic，但是需要在defer关键字后，defered函数会在本体函数退出前按LIFO声明的顺序执行\n3.defer是有性能开销的，但是很适合作为资源释放和异常处理，类似JAVA的finally。但是不要滥用，一些checked exception应该当作错误进行返回值处理","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":647363,"discussion_content":"你用的是Go 1.22版本吧。Go 1.22版本修改了loopvar的语义。修改后，上面代码相当于Go 1.22版本之前的如下代码：\n\nfunc foo3() {\n\tfor i := 0; i &lt;= 3; i++ {\n                i := i\n\t\tdefer func() {\n\t\t\tfmt.Println(i)\n\t\t}()\n\t}\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1719928464,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348978,"user_name":"宥晓","can_delete":false,"product_type":"c1","uid":2528776,"ip_address":"","ucode":"14473AB22CE7FC","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/LN7qpRLUGO2IHMnbDuF4YEsd9PxdFHAumWsHE8AhibeQUryIfgsQZ3JIZswVcCRkVSaelhFiatCZ6wpQFoLBLVFA/132","comment_is_top":false,"comment_ctime":1655619314,"is_pvip":false,"replies":[{"id":127023,"content":"我在自己机器上用go 1.18.3跑了一下：\n\n$go test -bench . defer_test.go\ngoos: darwin\ngoarch: amd64\ncpu: Intel(R) Core(TM) i5-8257U CPU @ 1.40GHz\nBenchmarkFooWithDefer-8      \t196703528\t         6.086 ns&#47;op\nBenchmarkFooWithoutDefer-8   \t309812937\t         3.840 ns&#47;op\nPASS\nok  \tcommand-line-arguments\t3.408s\n\n相对于文中的go 1.17的结果的确有些差异。但考虑到测试执行的环境并非独占，有很多影响因素，因此，不能断定是go 1.18.3带来的性能回退。\n\n从go 1.18.3的milestone中的issue list来看，似乎没有哪个与defer有关。\n\nhttps:&#47;&#47;github.com&#47;golang&#47;go&#47;issues?q=milestone%3AGo1.18.3+label%3ACherryPickApproved\n\n","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1655700721,"ip_address":"","comment_id":348978,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"go 的版本1.18.3, defer的性能下降了，这是有什么大的变动吗？\n\ngo test -bench . defer_test.go\n\ngoos: darwin\ngoarch: amd64\ncpu: Intel(R) Core(TM) i5-1038NG7 CPU @ 2.00GHz\nBenchmarkFooWithDefer-8         191820978                6.144 ns&#47;op\nBenchmarkFooWithoutDefer-8      527924869                2.245 ns&#47;op\nPASS\nok      command-line-arguments  3.643s\n","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576603,"discussion_content":"我在自己机器上用go 1.18.3跑了一下：\n\n$go test -bench . defer_test.go\ngoos: darwin\ngoarch: amd64\ncpu: Intel(R) Core(TM) i5-8257U CPU @ 1.40GHz\nBenchmarkFooWithDefer-8      \t196703528\t         6.086 ns/op\nBenchmarkFooWithoutDefer-8   \t309812937\t         3.840 ns/op\nPASS\nok  \tcommand-line-arguments\t3.408s\n\n相对于文中的go 1.17的结果的确有些差异。但考虑到测试执行的环境并非独占，有很多影响因素，因此，不能断定是go 1.18.3带来的性能回退。\n\n从go 1.18.3的milestone中的issue list来看，似乎没有哪个与defer有关。\n\nhttps://github.com/golang/go/issues?q=milestone%3AGo1.18.3+label%3ACherryPickApproved\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655700722,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347640,"user_name":"qiutian","can_delete":false,"product_type":"c1","uid":1313498,"ip_address":"","ucode":"99658A8E342498","user_header":"https://static001.geekbang.org/account/avatar/00/14/0a/da/dcf8f2b1.jpg","comment_is_top":false,"comment_ctime":1654243647,"is_pvip":false,"replies":[{"id":126779,"content":"严格来说zoo是执行不到的，因为panic发生在zoo前面。不过，这里只是为了演示而故意编写的例子。不用太过计较:)。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1654482082,"ip_address":"","comment_id":347640,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"我的vscode静态检查出：func zoo is unused (U1000)go-staticcheck\n但是通过build 构建和 运行是可以得到和目标相同的结果的","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574938,"discussion_content":"严格来说zoo是执行不到的，因为panic发生在zoo前面。不过，这里只是为了演示而故意编写的例子。不用太过计较:)。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654482082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346032,"user_name":"Junior Programmer","can_delete":false,"product_type":"c1","uid":2395539,"ip_address":"","ucode":"C56FF19934512E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/tVrFvKWxQAuL7DE911OmlcqnfEkBnx14dBmCdI8eOx6ziaQB4Pgml65tcIDO4ePfW5yPTyAxGovYQmXLZHAPe2Q/132","comment_is_top":false,"comment_ctime":1652779753,"is_pvip":false,"replies":[{"id":126260,"content":"重新温习一下第19讲中关于for循环语句的执行过程，你就能明白了:)。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1652822426,"ip_address":"","comment_id":346032,"utype":1}],"discussion_count":0,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"老师您好,对于defer参数求值时机有一点疑惑，func foo1() { for i := 0; i &lt;= 3; i++ { defer fmt.Println(i) }}这个i参数，传入到fmt.Printlin中不是应该是1开始的吗，然后根据defer执行时先进后出原则,应该是4,3,2,1,但是我在本地运行的是3,2,1,0，也就是说defer参数传入的时机，还没有执行i++，这个是什么原因呢？","like_count":1},{"had_liked":false,"id":343840,"user_name":"mikewoo","can_delete":false,"product_type":"c1","uid":1118888,"ip_address":"","ucode":"9AE90E05048DE1","user_header":"https://static001.geekbang.org/account/avatar/00/11/12/a8/8aaf13e0.jpg","comment_is_top":false,"comment_ctime":1651074025,"is_pvip":true,"replies":[{"id":125587,"content":"首先确认一下对for语义的理解。针对for i := 0; i &lt;= 3; i++ {}循环， 当i=3时，for进入循环体，然后执行后置语句i++，之后i的值为4. 然后再判断循环条件i&lt;=3，不满足，for循环结束。于是i的最终值就是4。\n\ndefer执行时，i是4，闭包引用的是同一个i，所以都输出4。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1651136940,"ip_address":"","comment_id":343840,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"老师，这篇文章给了我很多新的理解，收获满满。课程中“当 foo3 返回后，deferred 函数被调度执行时，上述压入栈的 deferred 函数将以 LIFO 次序出栈执行。匿名函数会以闭包的方式访问外围函数的变量 i，并通过 Println 输出 i 的值，此时 i 的值为 4。”为什么输出的结果都是4，这个不是很理解，能否帮忙再解释一下，谢谢。","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574938,"discussion_content":"严格来说zoo是执行不到的，因为panic发生在zoo前面。不过，这里只是为了演示而故意编写的例子。不用太过计较:)。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654482082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339386,"user_name":"William Ning","can_delete":false,"product_type":"c1","uid":1592279,"ip_address":"","ucode":"4DB8D05E69E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","comment_is_top":false,"comment_ctime":1648051464,"is_pvip":false,"replies":[{"id":124082,"content":"💪","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1648107970,"ip_address":"","comment_id":339386,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"大卡，继续学习，思考中～～","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558142,"discussion_content":"💪","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648107970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328175,"user_name":"羊羊","can_delete":false,"product_type":"c1","uid":1162597,"ip_address":"","ucode":"B220CE8D1CA5DA","user_header":"https://static001.geekbang.org/account/avatar/00/11/bd/65/fbdf4fc1.jpg","comment_is_top":false,"comment_ctime":1640588869,"is_pvip":false,"replies":[{"id":120402,"content":"对的。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1641995491,"ip_address":"","comment_id":328175,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"对于自定义的函数或方法，defer 可以给与无条件的支持，但是对于有返回值的自定义函数或方法，返回值会在 deferred 函数被调度执行的时候被自动丢弃。  是指defer语句后面的函数的返回值会被丢弃么？下面匿名函数的返回值2没有接受者，return了也没啥用，可以这么理解么？\nfunc bar() {\n\tdefer func() int {\n\t\tfmt.Println(&quot;defer func in bar&quot;)\n\t\treturn 2\n\t}()\n\tfmt.Println(&quot;call bar&quot;)\n\tfmt.Println(&quot;exit bar&quot;)\n}","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545552,"discussion_content":"对的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641995491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324954,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1638754806,"is_pvip":false,"replies":[{"id":117953,"content":"嗯嗯，如有问题，随时交流。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1638827577,"ip_address":"","comment_id":324954,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"关于 defer 我还要好好看看，一直都没怎么理解透彻","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536579,"discussion_content":"嗯嗯，如有问题，随时交流。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638827577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":393861,"user_name":"Geek_73c432","can_delete":false,"product_type":"c1","uid":2869118,"ip_address":"广东","ucode":"3E11EB02B14DE0","user_header":"","comment_is_top":false,"comment_ctime":1725117613,"is_pvip":false,"replies":[{"id":143130,"content":"标准库是go用户依赖的底层库，在这个层面如果发现recover也没有任何意义的错误，那他会认为还是fail fast最好。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1726441201,"ip_address":"辽宁","comment_id":393861,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"老师好，我在阅读标准库的一些例子的时候发现，当 caller 接收到一个 error 时，惯用法是使用 log.Fatal&#47;log.Fatalf 打印这个 error，这将导致执行 os.Exit(1)，这样不会执行 deferred 函数。例如：\n\nctx, stop := signal.NotifyContext(context.Background(), os.Interrupt)\ndefer stop()\n\np, err := os.FindProcess(os.Getpid())\nif err != nil {\n  log.Fatal(err)\n}\n\n...\n\n这段代码中，如果 os.FindProcess 调用返回 error，stop 函数将不会被执行。如果换成 log.Panicf(err) 的话 stop 函数会被执行。\n\n但是这种场景使用 Panic 有点混淆错误和异常的概念\n\n你怎么看待这两种处理方式？更推荐哪一种呢？","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651183,"discussion_content":"标准库是go用户依赖的底层库，在这个层面如果发现recover也没有任何意义的错误，那他会认为还是fail fast最好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1726441201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":391980,"user_name":"山深沾衣","can_delete":false,"product_type":"c1","uid":1314754,"ip_address":"重庆","ucode":"2BBECDF549E3E8","user_header":"https://static001.geekbang.org/account/avatar/00/14/0f/c2/de176336.jpg","comment_is_top":false,"comment_ctime":1719568178,"is_pvip":false,"replies":[{"id":142522,"content":"你用的是Go 1.22版本吧。Go 1.22版本修改了loopvar的语义。修改后，上面代码相当于Go 1.22版本之前的如下代码：\n\nfunc foo3() {\n\tfor i := 0; i &lt;= 3; i++ {\n                i := i\n\t\tdefer func() {\n\t\t\tfmt.Println(i)\n\t\t}()\n\t}\n}","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1719928464,"ip_address":"辽宁","comment_id":391980,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"func foo3() {\n\tfor i := 0; i &lt;= 3; i++ {\n\t\tdefer func() {\n\t\t\tfmt.Println(i)\n\t\t}()\n\t}\n}\n\n这个函数输出的结果是3 2 1 0 怎么和老师的不一样呢","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":647363,"discussion_content":"你用的是Go 1.22版本吧。Go 1.22版本修改了loopvar的语义。修改后，上面代码相当于Go 1.22版本之前的如下代码：\n\nfunc foo3() {\n\tfor i := 0; i &lt;= 3; i++ {\n                i := i\n\t\tdefer func() {\n\t\t\tfmt.Println(i)\n\t\t}()\n\t}\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1719928464,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390656,"user_name":"人言有力","can_delete":false,"product_type":"c1","uid":1690736,"ip_address":"浙江","ucode":"3708FBBFB641FE","user_header":"https://static001.geekbang.org/account/avatar/00/19/cc/70/64045bc0.jpg","comment_is_top":false,"comment_ctime":1715874099,"is_pvip":false,"replies":[{"id":142123,"content":"学习过程中多做总结是很好的习惯👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1716345200,"ip_address":"北京","comment_id":390656,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"本节核心介绍了panic、recover、defer三个关键字对程序异常和健壮性的帮助\n1. panic是手动触发程序崩溃，常用于断言\n2.recover是恢复panic，但是需要在defer关键字后，defered函数会在本体函数退出前按LIFO声明的顺序执行\n3.defer是有性能开销的，但是很适合作为资源释放和异常处理，类似JAVA的finally。但是不要滥用，一些checked exception应该当作错误进行返回值处理","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645544,"discussion_content":"学习过程中多做总结是很好的习惯👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1716345200,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390221,"user_name":"发条橙","can_delete":false,"product_type":"c1","uid":3875922,"ip_address":"上海","ucode":"F52E4EB1F9A3C9","user_header":"https://static001.geekbang.org/account/avatar/00/3b/24/52/4e1f33d0.jpg","comment_is_top":false,"comment_ctime":1714790846,"is_pvip":false,"replies":[{"id":142008,"content":"你是用Go 1.22版本运行的吧。1.22版本中loopvar语义发生了变更，从循环变量i从per loop var变为per iteration var了。所以每次进入循环，闭包捕获的都是一个新变量i，且该新变量i的值为当次迭代时的i值。等价于1.22版本以前的如下代码：\n\nfunc foo3() { \n    for i := 0; i &lt;= 3; i++ { \n        i := i\n        defer func() { \n            fmt.Println(i) \n        }   \n    }   \n}","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1715262161,"ip_address":"辽宁","comment_id":390221,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"foo3运行的结果也是\n3\n2\n1\n0","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":644469,"discussion_content":"你是用Go 1.22版本运行的吧。1.22版本中loopvar语义发生了变更，从循环变量i从per loop var变为per iteration var了。所以每次进入循环，闭包捕获的都是一个新变量i，且该新变量i的值为当次迭代时的i值。等价于1.22版本以前的如下代码：\n\nfunc foo3() { \n    for i := 0; i &lt;= 3; i++ { \n        i := i\n        defer func() { \n            fmt.Println(i) \n        }   \n    }   \n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1715262161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":388725,"user_name":"冒泡雪碧 🏈","can_delete":false,"product_type":"c1","uid":1255745,"ip_address":"江苏","ucode":"E4AB442B0167CF","user_header":"https://static001.geekbang.org/account/avatar/00/13/29/41/a413ca91.jpg","comment_is_top":false,"comment_ctime":1710773650,"is_pvip":false,"replies":[{"id":141531,"content":"和在普通函数中panic一样，会自下而上走一个panicking的过程，如果有recover捕捉panic，就进行recover，如果没有，会最终导致程序异常退出。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1711075245,"ip_address":"北京","comment_id":388725,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"defer+log可以追踪记录程序调用路径。\n我有一个问题，如果在defer中进行panic会怎么样呢？","like_count":0},{"had_liked":false,"id":387172,"user_name":"Geek_73c432","can_delete":false,"product_type":"c1","uid":2869118,"ip_address":"广东","ucode":"3E11EB02B14DE0","user_header":"","comment_is_top":false,"comment_ctime":1706627722,"is_pvip":false,"replies":[{"id":141131,"content":"1. panic如果没有被恢复(recover)，就会一直向上传导到main函数中，如果主goroutine也没有恢复该panic，那么主goroutine就会因panic而退出。\n2. 非常好的问题，我来尝试回答一下。\n\ndeferred 函数会在函数return后被调用。因此bar函数这个比较好理解。bar函数使用了具名返回值。而defered func是一个闭包，闭包中使用了i这返回值变量，因此return后，deferred func对返回变量i的修改会最终反映到函数bar的返回值上。\n\nfoo函数没有使用具名返回值，其中的deferred func修改的是函数体内部的本地变量i。当函数return i时，其实是将i的值(此时为1)copy到函数返回值的内存块中，此时返回值也为1。return后，deferred func被执行，而修改的是本地变量i，与foo函数的返回值并无关联了。因此最终返回值就是1\n\n\n","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1706959724,"ip_address":"辽宁","comment_id":387172,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"老师好\n\n1. 每个 goroutine 都有自己的执行栈，当一个 goroutine 中发生 panic 时，另一个 goroutine 并不能感知，那为什么主 goroutine 会退出呢？\n\n2. 下面两个函数为什么返回值不一致呢？\nfunc foo() int {\n\ti := 1\n\n\tdefer func() {\n\t\ti++\n\t}()\n\n\treturn i\n}\n\nfunc bar() (i int) {\n\ti = 1\n\n\tdefer func() {\n\t\ti++\n\t}()\n\n\treturn\n}\n\nfunc main() {\n\tfmt.Println(foo()) &#47;&#47; 1\n\tfmt.Println(bar()) &#47;&#47; 2\n}\n\n3. deferred 函数是在 return 语句（假如函数有）之前还是之后执行呢？问题 3 可能跟问题 2 有关","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":644469,"discussion_content":"你是用Go 1.22版本运行的吧。1.22版本中loopvar语义发生了变更，从循环变量i从per loop var变为per iteration var了。所以每次进入循环，闭包捕获的都是一个新变量i，且该新变量i的值为当次迭代时的i值。等价于1.22版本以前的如下代码：\n\nfunc foo3() { \n    for i := 0; i &lt;= 3; i++ { \n        i := i\n        defer func() { \n            fmt.Println(i) \n        }   \n    }   \n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1715262161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":376353,"user_name":"lesserror","can_delete":false,"product_type":"c1","uid":1351076,"ip_address":"广东","ucode":"25A54D1165FCF6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","comment_is_top":false,"comment_ctime":1686729205,"is_pvip":false,"replies":[{"id":137242,"content":"这一讲里有专门说defer用法的段落，里面明确说了defer的功用、使用方法的啊。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1686792546,"ip_address":"北京","comment_id":376353,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"Tony bai 老师，很多文章中讲 defer 后面必须接一个 函数或者方法的调用，文中的用法是这样的，但是好像没有特意强调这一概念。","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":640023,"discussion_content":"和在普通函数中panic一样，会自下而上走一个panicking的过程，如果有recover捕捉panic，就进行recover，如果没有，会最终导致程序异常退出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1711075245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328378,"user_name":"一个学员","can_delete":false,"product_type":"c1","uid":1566227,"ip_address":"","ucode":"427049337F6565","user_header":"https://static001.geekbang.org/account/avatar/00/17/e6/13/d93997aa.jpg","comment_is_top":false,"comment_ctime":1640696396,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"讲的太清晰了。","like_count":1},{"had_liked":false,"id":338829,"user_name":"Kepler","can_delete":false,"product_type":"c1","uid":1214303,"ip_address":"","ucode":"0C9CA3DB8B3CF0","user_header":"https://static001.geekbang.org/account/avatar/00/12/87/5f/6bf8b74a.jpg","comment_is_top":false,"comment_ctime":1647755991,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"defer的常用用途：\n1.接口统一上报；\n2.打印耗时，不过这点也可以归到1中；","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636779,"discussion_content":"1. panic如果没有被恢复(recover)，就会一直向上传导到main函数中，如果主goroutine也没有恢复该panic，那么主goroutine就会因panic而退出。\n2. 非常好的问题，我来尝试回答一下。\n\ndeferred 函数会在函数return后被调用。因此bar函数这个比较好理解。bar函数使用了具名返回值。而defered func是一个闭包，闭包中使用了i这返回值变量，因此return后，deferred func对返回变量i的修改会最终反映到函数bar的返回值上。\n\nfoo函数没有使用具名返回值，其中的deferred func修改的是函数体内部的本地变量i。当函数return i时，其实是将i的值(此时为1)copy到函数返回值的内存块中，此时返回值也为1。return后，deferred func被执行，而修改的是本地变量i，与foo函数的返回值并无关联了。因此最终返回值就是1\n\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1706959724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390221,"user_name":"发条橙","can_delete":false,"product_type":"c1","uid":3875922,"ip_address":"上海","ucode":"F52E4EB1F9A3C9","user_header":"https://static001.geekbang.org/account/avatar/00/3b/24/52/4e1f33d0.jpg","comment_is_top":false,"comment_ctime":1714790846,"is_pvip":false,"replies":[{"id":142008,"content":"你是用Go 1.22版本运行的吧。1.22版本中loopvar语义发生了变更，从循环变量i从per loop var变为per iteration var了。所以每次进入循环，闭包捕获的都是一个新变量i，且该新变量i的值为当次迭代时的i值。等价于1.22版本以前的如下代码：\n\nfunc foo3() { \n    for i := 0; i &lt;= 3; i++ { \n        i := i\n        defer func() { \n            fmt.Println(i) \n        }   \n    }   \n}","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1715262161,"ip_address":"辽宁","comment_id":390221,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"foo3运行的结果也是\n3\n2\n1\n0","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":640023,"discussion_content":"和在普通函数中panic一样，会自下而上走一个panicking的过程，如果有recover捕捉panic，就进行recover，如果没有，会最终导致程序异常退出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1711075245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":388725,"user_name":"冒泡雪碧 🏈","can_delete":false,"product_type":"c1","uid":1255745,"ip_address":"江苏","ucode":"E4AB442B0167CF","user_header":"https://static001.geekbang.org/account/avatar/00/13/29/41/a413ca91.jpg","comment_is_top":false,"comment_ctime":1710773650,"is_pvip":false,"replies":[{"id":141531,"content":"和在普通函数中panic一样，会自下而上走一个panicking的过程，如果有recover捕捉panic，就进行recover，如果没有，会最终导致程序异常退出。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1711075245,"ip_address":"北京","comment_id":388725,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"defer+log可以追踪记录程序调用路径。\n我有一个问题，如果在defer中进行panic会怎么样呢？","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636779,"discussion_content":"1. panic如果没有被恢复(recover)，就会一直向上传导到main函数中，如果主goroutine也没有恢复该panic，那么主goroutine就会因panic而退出。\n2. 非常好的问题，我来尝试回答一下。\n\ndeferred 函数会在函数return后被调用。因此bar函数这个比较好理解。bar函数使用了具名返回值。而defered func是一个闭包，闭包中使用了i这返回值变量，因此return后，deferred func对返回变量i的修改会最终反映到函数bar的返回值上。\n\nfoo函数没有使用具名返回值，其中的deferred func修改的是函数体内部的本地变量i。当函数return i时，其实是将i的值(此时为1)copy到函数返回值的内存块中，此时返回值也为1。return后，deferred func被执行，而修改的是本地变量i，与foo函数的返回值并无关联了。因此最终返回值就是1\n\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1706959724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":387172,"user_name":"Geek_73c432","can_delete":false,"product_type":"c1","uid":2869118,"ip_address":"广东","ucode":"3E11EB02B14DE0","user_header":"","comment_is_top":false,"comment_ctime":1706627722,"is_pvip":false,"replies":[{"id":141131,"content":"1. panic如果没有被恢复(recover)，就会一直向上传导到main函数中，如果主goroutine也没有恢复该panic，那么主goroutine就会因panic而退出。\n2. 非常好的问题，我来尝试回答一下。\n\ndeferred 函数会在函数return后被调用。因此bar函数这个比较好理解。bar函数使用了具名返回值。而defered func是一个闭包，闭包中使用了i这返回值变量，因此return后，deferred func对返回变量i的修改会最终反映到函数bar的返回值上。\n\nfoo函数没有使用具名返回值，其中的deferred func修改的是函数体内部的本地变量i。当函数return i时，其实是将i的值(此时为1)copy到函数返回值的内存块中，此时返回值也为1。return后，deferred func被执行，而修改的是本地变量i，与foo函数的返回值并无关联了。因此最终返回值就是1\n\n\n","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1706959724,"ip_address":"辽宁","comment_id":387172,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"老师好\n\n1. 每个 goroutine 都有自己的执行栈，当一个 goroutine 中发生 panic 时，另一个 goroutine 并不能感知，那为什么主 goroutine 会退出呢？\n\n2. 下面两个函数为什么返回值不一致呢？\nfunc foo() int {\n\ti := 1\n\n\tdefer func() {\n\t\ti++\n\t}()\n\n\treturn i\n}\n\nfunc bar() (i int) {\n\ti = 1\n\n\tdefer func() {\n\t\ti++\n\t}()\n\n\treturn\n}\n\nfunc main() {\n\tfmt.Println(foo()) &#47;&#47; 1\n\tfmt.Println(bar()) &#47;&#47; 2\n}\n\n3. deferred 函数是在 return 语句（假如函数有）之前还是之后执行呢？问题 3 可能跟问题 2 有关","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621056,"discussion_content":"这一讲里有专门说defer用法的段落，里面明确说了defer的功用、使用方法的啊。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1686792546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":376353,"user_name":"lesserror","can_delete":false,"product_type":"c1","uid":1351076,"ip_address":"广东","ucode":"25A54D1165FCF6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","comment_is_top":false,"comment_ctime":1686729205,"is_pvip":false,"replies":[{"id":137242,"content":"这一讲里有专门说defer用法的段落，里面明确说了defer的功用、使用方法的啊。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1686792546,"ip_address":"北京","comment_id":376353,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"Tony bai 老师，很多文章中讲 defer 后面必须接一个 函数或者方法的调用，文中的用法是这样的，但是好像没有特意强调这一概念。","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621056,"discussion_content":"这一讲里有专门说defer用法的段落，里面明确说了defer的功用、使用方法的啊。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1686792546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328378,"user_name":"一个学员","can_delete":false,"product_type":"c1","uid":1566227,"ip_address":"","ucode":"427049337F6565","user_header":"https://static001.geekbang.org/account/avatar/00/17/e6/13/d93997aa.jpg","comment_is_top":false,"comment_ctime":1640696396,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"讲的太清晰了。","like_count":1},{"had_liked":false,"id":338829,"user_name":"Kepler","can_delete":false,"product_type":"c1","uid":1214303,"ip_address":"","ucode":"0C9CA3DB8B3CF0","user_header":"https://static001.geekbang.org/account/avatar/00/12/87/5f/6bf8b74a.jpg","comment_is_top":false,"comment_ctime":1647755991,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"defer的常用用途：\n1.接口统一上报；\n2.打印耗时，不过这点也可以归到1中；","like_count":0}]}