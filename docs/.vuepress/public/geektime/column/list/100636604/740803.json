{"id":740803,"title":"第 4 章 所有权与移动 ","content":"\n\n<p>谈及内存管理，我们希望编程语言能具备两个特点：</p>\n<ul>\n<li>希望内存能在我们选定的时机及时释放，这使我们能控制程序的内存消耗；</li>\n<li>在对象被释放后，我们绝不希望继续使用指向它的指针，这是未定义行为，会导致崩溃和安全漏洞。</li>\n</ul>\n<p>但上述情景似乎难以兼顾：只要指向值的指针仍然存在，释放这个值就必然会让这些指针悬空。几乎所有主流编程语言都只能在两个阵营中“二选一”，这取决于它们从中放弃了哪一项。</p>\n<ul>\n<li><p>“安全优先”阵营会通过垃圾回收机制来管理内存，在所有指向对象的可达指针都消失后，自动释放对象。它通过简单地保留对象，直到再也没有指向它们的指针为止，来消除悬空指针。几乎所有现代语言都属于这个阵营，从 Python、JavaScript 和 Ruby 到 Java、C# 和 Haskell。</p>\n<p>但是依赖垃圾回收，就意味着放弃了对于释放对象时机的精准控制，完全委托给回收器代管。一般来说，垃圾回收器就像奇怪的野兽般难以捉摸，要理解内存为何没有在预期的时机被释放可能颇具挑战。</p><!-- [[[read_end]]] -->\n<p>&nbsp;</p>\n</li>\n<li><p>“控制优先”阵营会让你自己负责释放内存。程序的内存消耗完全掌握在你的手中，但避免悬空指针也完全成了你的责任。C 和 C++ 是这个阵营中仅有的两种主流语言。</p>\n<p>如果你永不犯错，这当然是很好的选择，但事实证明，只要是人就会犯错。从已收集的安全报告数据来看，指针滥用一直都是引发问题的罪魁祸首。</p>\n</li>\n</ul>\n<p>Rust 的目标是既安全又高效，所以这两种妥协都是无法接受的。但如果很容易两者兼得，那应该早就有人做到了。看来我们需要做一些根本性的变革。</p>\n<p>Rust 通过限制程序使用指针的方式出人意料地打破了这种困局。本章和第 5 章将专门解释这些限制是什么以及它们为什么能起作用。现在，只需要知道一些惯用的常见结构可能不符合这些限制规则，而你要寻找替代方案。施加这些限制的最终目的是在混沌中建立足够的秩序，以便让 Rust 的编译期检查器有能力验证程序中是否存在内存安全错误：悬空指针、重复释放、使用未初始化的内存等。在运行期，指针仅仅是内存中的地址，和在 C 与 C++ 中一样。而不一样的是，Rust 编译器已然证明你的代码在安全地使用它们。</p>\n<p>这些规则同样构成了 Rust 支持安全并发编程的基础。使用 Rust 精心设计的线程原语，那些确保代码在正确使用内存的规则，同样可以用于证明代码中不存在数据竞争。Rust 程序中的缺陷不会导致一个线程破坏另一个线程的数据，进而在系统中的无关部分引入难以重现的故障。多线程代码中的固有不确定性被隔离到了那些专门设计来处理它们的线程特性（比如互斥锁、消息通道、原子值等）上，而不必出现在普通的内存引用中。用 C 和 C++ 编写的多线程代码饱受诟病，但 Rust 很好地改变了这种局面。</p>\n<p>Rust 的激进“赌注”是其成功的基础和语言的根源。即使有这种限制，该语言依然足够灵活，可以完成几乎所有任务，并且可以消除各种内存管理和并发错误。这些优点将会证明你值得调整自己的风格来适应它。正是因为我们（本书作者）在 C 和 C++ 方面拥有丰富的经验，所以才更加看好 Rust。对我们来说，与 Rust 的这项交易非常划算。</p>\n<p>Rust 的一些规则可能与你在其他编程语言中看到的截然不同。在我们看来，学习 Rust 的核心挑战，就是学习如何用好这些规则并转化为你的优势。在本章中，我们将首先展示同一个根本问题在不同语言中的表现形式，以深入了解 Rust 规则背后的逻辑和意图。然后，我们将详细解释 Rust 的规则，看看所有权在概念层和实现层分别意味着什么、如何在各种场景中跟踪所有权的变化，以及在哪些情况下要改变或打破其中的一些规则，以提供更大的灵活性。</p>\n<h2 id=\"nav_point_66\">4.1　所有权</h2>\n<p>如果你读过大量 C 或 C++ 代码，可能遇到过这样的注释，即某个类的实例<strong>拥有</strong>它指向的某个其他对象。通常，拥有对象意味着可以决定何时释放此对象：当销毁拥有者时，它拥有的对象也会随之销毁。</p>\n<p>假如有如下 C++ 代码：</p>\n<pre class=\"code-rows\"><code>std::string s = \"frayed knot\";</code></pre>\n<p>通常，字符串 <code>s</code> 在内存中的表示如图 4-1 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00821.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4-1：栈上的 C++ <code>std::string</code> 值，指向其在堆上分配的缓冲区</strong></p>\n<p>在这里，实际的 <code>std::string</code> 对象本身总是正好有 3 个机器字长，包括指向分配在堆上的缓冲区的指针、缓冲区的总容量（在不得不为字符串分配更大的缓冲区之前，文本可以增长到多大），以及当前持有的文本的长度。这些都是 <code>std::string</code> 类私有的字段，使用者无法访问。</p>\n<p><code>std::string</code> 拥有自己的缓冲区：当程序销毁字符串时，字符串的析构函数会释放缓冲区。以前，一些 C++ 库会在多个 <code>std::string</code> 值之间共享同一个缓冲区，通过引用计数来决定何时释放此缓冲区。但较新版本的 C++ 规范有效地杜绝了这种表示法，所有现代 C++ 库使用的都是这里展示的方法。</p>\n<p>在这些情况下，人们普遍认为，虽然其他代码也可以创建指向所拥有内存的临时指针，但在拥有者决定销毁拥有的对象之前，其他代码有责任确保其指针已消失。也就是说，你可以创建一个指向 <code>std::string</code> 的缓冲区中的字符的指针，但是当字符串被销毁时，你也必须让你的指针失效，并且要确保不再使用它。拥有者决定被拥有者的生命周期，其他所有人都必须尊重其决定。</p>\n<p>这里使用了 <code>std::string</code> 作为 C++ 中所有权的示例：它只是标准库通常遵循的规约，尽管 C++ 鼓励人们都遵循类似的做法，但说到底，如何设计自己的类型还是要由你自己决定。</p>\n<p>然而，在 Rust 中，所有权这个概念内置于语言本身，并通过编译期检查强制执行。每个值都有决定其生命周期的唯一拥有者。当拥有者被释放时，它拥有的值也会同时被释放，在 Rust 术语中，释放的行为被称为<strong>丢弃</strong>（drop）。这些规则便于通过检查代码确定任意值的生命周期，也提供了系统级语言本应支持的对生命周期的控制。</p>\n<p>变量拥有自己的值，当控制流离开声明变量的块时，变量就会被丢弃，因此它的值也会一起被丢弃。例如：</p>\n<pre class=\"code-rows\"><code>fn print_padovan() {\n    let mut padovan = vec![1,1,1];  // 在此分配\n    for i in 3..10 {\n        let next = padovan[i-3] + padovan[i-2];\n        padovan.push(next);\n    }\n    println!(\"P(1..10) = {:?}\", padovan);\n}                                   // 在此丢弃</code></pre>\n<p>变量 <code>padovan</code> 的类型为 <code>Vec&lt;i32&gt;</code>，即一个 32 位整数向量。在内存中，<code>padovan</code> 的最终值如图 4-2 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00822.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4-2：栈上的 <code>Vec&lt;i32&gt;</code>，指向其在堆中的缓冲区</strong></p>\n<p>这和之前展示过的 C++ <code>std::string</code> 非常相似，不过缓冲区中的元素都是 32 位整数，而不是字符。请注意，保存 <code>padovan</code> 指针、容量和长度的字都直接位于 <code>print_padovan</code> 函数的栈帧中，只有向量的缓冲区才分配在堆上。</p>\n<p>和之前的字符串 <code>s</code> 一样，此向量拥有保存其元素的缓冲区。当变量 <code>padovan</code> 在函数末尾超出作用域时，程序将会丢弃此向量。因为向量拥有自己的缓冲区，所以此缓冲区也会一起被丢弃。</p>\n<p>Rust 的 <code>Box</code> 类型是所有权的另一个例子。<code>Box&lt;T&gt;</code> 是指向存储在堆上的 <code>T</code> 类型值的指针。可以调用 <code>Box::new(v)</code> 分配一些堆空间，将值 <code>v</code> 移入其中，并返回一个指向该堆空间的 <code>Box</code>。因为 <code>Box</code> 拥有它所指向的空间，所以当丢弃 <code>Box</code> 时，也会释放此空间。</p>\n<p>例如，可以像下面这样在堆中分配一个元组：</p>\n<pre class=\"code-rows\"><code>{\n    let point = Box::new((0.625, 0.5));  // 在此分配了point\n    let label = format!(\"{:?}\", point);  // 在此分配了label\n    assert_eq!(label, \"(0.625, 0.5)\");\n}                                        // 在此全都丢弃了</code></pre>\n<p>当程序调用 <code>Box::new</code> 时，它会在堆上为由两个 <code>f64</code> 值构成的元组分配空间，然后将其参数 <code>(0.625, 0.5)</code> 移进去，并返回指向该空间的指针。当控制流抵达对 <code>assert_eq!</code> 的调用时，栈帧如图 4-3 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00823.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4-3：两个局部变量，它们各自在堆中拥有内存</strong></p>\n<p>栈帧本身包含变量 <code>point</code> 和 <code>label</code>，其中每个变量都指向其拥有的堆中内存。当丢弃它们时，它们拥有的堆中内存也会一起被释放。</p>\n<p>就像变量拥有自己的值一样，结构体拥有自己的字段，元组、数组和向量则拥有自己的元素。</p>\n<pre class=\"code-rows\"><code>struct Person { name: String, birth: i32 }\n\nlet mut composers = Vec::new();\ncomposers.push(Person { name: \"Palestrina\".to_string(),\n                        birth: 1525 });\ncomposers.push(Person { name: \"Dowland\".to_string(),\n                        birth: 1563 });\ncomposers.push(Person { name: \"Lully\".to_string(),\n                        birth: 1632 });\nfor composer in &amp;composers {\n    println!(\"{}, born {}\", composer.name, composer.birth);\n}</code></pre>\n<p>在这里，<code>composers</code> 是一个 <code>Vec&lt;Person&gt;</code>，即由结构体组成的向量，每个结构体都包含一个字符串和数值。在内存中，<code>composers</code> 的最终值如图 4-4 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00824.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4-4：更复杂的所有权树</strong></p>\n<p>这里有很多所有权关系，但每个都一目了然：<code>composers</code> 拥有一个向量，向量拥有自己的元素，每个元素都是一个 <code>Person</code> 结构体，每个结构体都拥有自己的字段，并且字符串字段拥有自己的文本。当控制流离开声明 <code>composers</code> 的作用域时，程序会丢弃自己的值并将整棵所有权树一起丢弃。如果还存在其他类型的集合（可能是 <code>HashMap</code> 或 <code>BTreeSet</code>），那么处理的方式也是一样的。</p>\n<p>现在，回过头来思考一下刚刚介绍的这些所有权关系的重要性。每个值都有一个唯一的拥有者，因此很容易决定何时丢弃它。但是每个值可能会拥有许多其他值，比如向量 <code>composers</code> 会拥有自己的所有元素。这些值还可能拥有其他值：<code>composers</code> 的每个元素都各自拥有一个字符串，该字符串又拥有自己的文本。</p>\n<p>由此可见，拥有者及其拥有的那些值形成了一棵<strong>树</strong>：值的拥有者是值的父节点，值拥有的值是值的子节点。每棵树的总根都是一个变量，当该变量超出作用域时，整棵树都将随之消失。可以在 <code>composers</code> 的图中看到这样的所有权树：它既不是“搜索树”那种数据结构意义上的“树”，也不是由 DOM 元素构成的 HTML 文档。相反，我们有一棵由混合类型构建的树，Rust 的单一拥有者规则将禁止任何可能让它们排列得比树结构更复杂的可能性。Rust 程序中的每一个值都是某棵树的成员，树根是某个变量。</p>\n<p>Rust 程序通常不需要像 C 程序和 C++ 程序那样显式地使用 <code>free</code> 和 <code>delete</code> 来丢弃值。在 Rust 中丢弃一个值的方式就是从所有权树中移除它：或者离开变量的作用域，或者从向量中删除一个元素，或者执行其他类似的操作。这样一来，Rust 就会确保正确地丢弃该值及其拥有的一切。</p>\n<p>从某种意义上说，Rust 确实不如其他语言强大：其他所有实用的编程语言都允许你构建出任意复杂的对象图，这些对象可以用你认为合适的方式相互引用。但正是因为 Rust 不那么强大，所以编辑器对你的程序所进行的分析才能更强大。Rust 的安全保证之所以可行，是因为在你的代码中可能出现的那些关系都更可控。这是之前提过的 Rust 的“激进赌注”的一部分：实际上，Rust 声称，解决问题的方式通常是灵活多样的，因此总是会有一些完美的解决方案能同时满足它所施加的限制。</p>\n<p>迄今为止，我们已经解释过的这些所有权概念仍然过于严格，还处理不了某些场景。Rust 从几个方面扩展了这种简单的思想。</p>\n<ul>\n<li>可以将值从一个拥有者转移给另一个拥有者。这允许你构建、重新排列和拆除树形结构。</li>\n<li>像整数、浮点数和字符这样的非常简单的类型，不受所有权规则的约束。这些称为 <code>Copy</code> 类型。</li>\n<li>标准库提供了引用计数指针类型 <code>Rc</code> 和 <code>Arc</code>，它们允许值在某些限制下有多个拥有者。</li>\n<li>可以对值进行“借用”（borrow），以获得值的引用。这种引用是非拥有型指针，有着受限的生命周期。</li>\n</ul>\n<p>这些策略中的每一个策略都为所有权模型带来了灵活性，同时仍然坚持着 Rust 的那些承诺。接下来我们将依次解释这几种方式，并会在第 5 章中介绍一些参考资料。</p>\n<h2 id=\"nav_point_67\">4.2　移动</h2>\n<p>在 Rust 中，对大多数类型来说，像为变量赋值、将其传给函数或从函数返回这样的操作都不会复制值，而是会<strong>移动</strong>值。源会把值的所有权转移给目标并变回未初始化状态，改由目标变量来控制值的生命周期。Rust 程序会以每次只移动一个值的方式建立和拆除复杂的结构。</p>\n<p>你可能惊讶于 Rust 会改变这些基本操作的含义，确实如此，历史发展到今天，赋值应该已经是含义最明确的操作了。但是，如果仔细观察不同的语言处理赋值操作的方式，你会发现不同的编程流派之间实际上存在着相当明显的差异。对比这些差异也能很容易看出 Rust 做出这种选择的意义及其重要性。</p>\n<p>考虑以下 Python 代码：</p>\n<pre class=\"code-rows\"><code>s = ['udon', 'ramen', 'soba']\nt = s\nu = s</code></pre>\n<p>每个 Python 对象都有一个引用计数，以用于跟踪当前正引用着此值的数量。因此，在对 <code>s</code> 赋值之后，程序的状态如图 4-5 所示。（请注意，这里忽略了一些字段。）</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00825.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4-5：Python 如何在内存中表示字符串列表</strong></p>\n<p>由于只有 <code>s</code> 指向列表，因此该列表的引用计数为 1。由于列表是唯一指向这些字符串的对象，因此它们各自的引用计数也是 <code>1</code>。</p>\n<p>当程序执行对 <code>t</code> 和 <code>u</code> 的赋值时会发生什么？Python 会直接让目标指向与源相同的对象，并增加对象的引用计数来实现赋值。所以程序的最终状态如图 4-6 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00826.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4-6：在 Python 中将 <code>s</code> 赋值给 <code>t</code> 和 <code>u</code> 的结果</strong></p>\n<p>Python 已经将指针从 <code>s</code> 复制到 <code>t</code> 和 <code>u</code>，并将此列表的引用计数更新为 <code>3</code>。Python 中的赋值开销极低，但因为它创建了对对象的新引用，所以必须维护引用计数才能知道何时可以释放该值。</p>\n<p>现在考虑类似的 C++ 代码：</p>\n<pre class=\"code-rows\"><code>using namespace std;\nvector&lt;string&gt; s = { \"udon\", \"ramen\", \"soba\" };\nvector&lt;string&gt; t = s;\nvector&lt;string&gt; u = s;</code></pre>\n<p><code>s</code> 的原始值在内存中如图 4-7 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00827.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4-7：C++ 如何表示内存中的字符串向量</strong></p>\n<p>当程序将 <code>s</code> 赋值给 <code>t</code> 和 <code>u</code> 时会发生什么？在 C++ 中，把 <code>std::vector</code> 赋值给其他元素会生成一个向量的副本，<code>std::string</code> 的行为也类似。所以当程序执行到这段代码的末尾时，它实际上已经分配了 3 个向量和 9 个字符串，如图 4-8 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00828.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4-8：在 C++ 中将 <code>s</code> 赋值给 <code>t</code> 和 <code>u</code> 的结果</strong></p>\n<p>理论上，如果涉及某些特定的值，那么 C++ 中的赋值可能会消耗超乎想象的内存和处理器时间。然而，其优点是程序很容易决定何时释放这些内存：当变量超出作用域时，此处分配的所有内容都会自动清除。</p>\n<p>从某种意义上说，C++ 和 Python 选择了相反的权衡：Python 以需要引用计数（以及更广泛意义上的垃圾回收）为代价，让赋值的开销变得非常低。C++ 则选择让全部内存的所有权保持清晰，而代价是在赋值时要执行对象的深拷贝。一般来说，C++ 程序员不太热衷这种选择：深拷贝的开销可能很昂贵，而且通常有更实用的替代方案。</p>\n<p>那么类似的程序在 Rust 中会怎么做呢？请看如下代码：</p>\n<pre class=\"code-rows\"><code>let s = vec![\"udon\".to_string(), \"ramen\".to_string(), \"soba\".to_string()];\nlet t = s;\nlet u = s;</code></pre>\n<p>与 C 和 C++ 一样，Rust 会将纯字符串字面量（如 <code>\"udon\"</code>）放在只读内存中，因此为了与 C++ 示例和 Python 示例进行更清晰的比较，此处调用了 <code>to_string</code> 以获取堆上分配的 <code>String</code> 值。</p>\n<p>在执行了 <code>s</code> 的初始化之后，由于 Rust 和 C++ 对向量和字符串使用了类似的表示形式，因此情况看起来就和 C++ 中一样，如图 4-9 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00829.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4-9：Rust 如何表示内存中的字符串向量</strong></p>\n<p>但要记住，在 Rust 中，大多数类型的赋值会将值从源<strong>转移</strong>给目标，而源会回到未初始化状态。因此在初始化 <code>t</code> 之后，程序的内存如图 4-10 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00830.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4-10：Rust 中将 <code>s</code> 赋值给 <code>t</code> 的结果</strong></p>\n<p>这里发生了什么？初始化语句 <code>let t = s;</code> 将向量的 3 个标头字段从 <code>s</code> 转移给了 <code>t</code>，现在 <code>t</code> 拥有此向量。向量的元素保持原样，字符串也没有任何变化。每个值依然只有一个拥有者，尽管其中一个已然易手。整个过程中没有需要调整的引用计数，不过编译器现在会认为 <code>s</code> 是未初始化状态。</p>\n<p>那么当我们执行初始化语句 <code>let u = s;</code> 时会发生什么呢？这会将尚未初始化的值 <code>s</code> 赋给 <code>u</code>。Rust 明智地禁止使用未初始化的值，因此编译器会拒绝此代码并报告如下错误：</p>\n<pre class=\"code-rows\"><code>error: use of moved value: `s`\n  |\n7 |     let s = vec![\"udon\".to_string(), \"ramen\".to_string(), \"soba\".to_string()];\n  |         - move occurs because `s` has type `Vec&lt;String&gt;`,\n  |           which does not implement the `Copy` trait\n8 |     let t = s;\n  |             - value moved here\n9 |     let u = s;\n  |             ^ value used here after move</code></pre>\n<p>思考一下 Rust 在这里使用移动语义的影响。与 Python 一样，赋值操作开销极低：程序只需将向量的三字标头从一个位置移到另一个位置即可。但与 C++ 一样，所有权始终是明确的：程序不需要引用计数或垃圾回收就能知道何时释放向量元素和字符串内容。</p>\n<p>代价是如果需要同时访问它们，就必须显式地要求复制。如果想达到与 C++ 程序相同的状态（每个变量都保存一个独立的结构副本），就必须调用向量的 <code>clone</code> 方法，该方法会执行向量及其元素的深拷贝：</p>\n<pre class=\"code-rows\"><code>let s = vec![\"udon\".to_string(), \"ramen\".to_string(), \"soba\".to_string()];\nlet t = s.clone();\nlet u = s.clone();</code></pre>\n<p>还可以使用 Rust 的引用计数来实现与 Python 类似的操作，4.4 节会简要讨论这些内容。</p>\n<h3 id=\"nav_point_68\">4.2.1　更多移动类操作</h3>\n<p>在先前的例子中，我们已经展示了如何初始化工作——在变量进入 <code>let</code> 语句的作用域时为它们提供值。给变量赋值则与此略有不同，如果你将一个值转移给已初始化的变量，那么 Rust 就会丢弃该变量的先前值。例如：</p>\n<pre class=\"code-rows\"><code>let mut s = \"Govinda\".to_string();\ns = \"Siddhartha\".to_string(); // 在这里丢弃了值\"Govinda\"</code></pre>\n<p>在上述代码中，当程序将字符串 <code>\"Siddhartha\"</code> 赋值给 <code>s</code> 时，它的先前值 <code>\"Govinda\"</code> 会首先被丢弃。但请考虑以下代码：</p>\n<pre class=\"code-rows\"><code>let mut s = \"Govinda\".to_string();\nlet t = s;\ns = \"Siddhartha\".to_string(); // 这里什么也没有丢弃</code></pre>\n<p>这一次，<code>t</code> 从 <code>s</code> 接手了原始字符串的所有权，所以当给 <code>s</code> 赋值时，它是未初始化状态。这种情况下不会丢弃任何字符串。</p>\n<p>我们在这个例子中使用了初始化和赋值，因为它们很简单，但 Rust 还将“移动”的语义应用到了几乎所有对值的使用上。例如，将参数传给函数会将所有权转移给函数的参数、从函数返回一个值会将所有权转移给调用者、构建元组会将值转移给元组。</p>\n<p>你现在可以更好地理解 4.1 节的示例中到底发生过什么了。例如，我们在构建 <code>composers</code> 向量时，是这样写的：</p>\n<pre class=\"code-rows\"><code>struct Person { name: String, birth: i32 }\n\nlet mut composers = Vec::new();\ncomposers.push(Person { name: \"Palestrina\".to_string(),\n                        birth: 1525 });</code></pre>\n<p>这段代码展示了除初始化和赋值之外发生移动的几个地方。</p>\n<blockquote>\n<p>从函数返回值</p>\n</blockquote>\n<p>调用 <code>Vec::new()</code> 构造一个新向量并返回，返回的不是指向此向量的指针，而是向量本身：它的所有权从 <code>Vec::new</code> 转移给了变量 <code>composers</code>。同样，<code>to_string</code> 调用返回的是一个新的 <code>String</code> 实例。</p>\n<blockquote>\n<p>构造出新值</p>\n</blockquote>\n<p>新 <code>Person</code> 结构体的 <code>name</code> 字段是用 <code>to_string</code> 的返回值初始化的。该结构体拥有这个字符串的所有权。</p>\n<blockquote>\n<p>将值传给函数</p>\n</blockquote>\n<p>整个 <code>Person</code> 结构体（不是指向它的指针）被传给了向量的 <code>push</code> 方法，此方法会将该结构体移动到向量的末尾。向量接管了 <code>Person</code> 的所有权，因此也间接接手了 <code>name</code> 这个 <code>String</code> 的所有权。</p>\n<p>像这样移动值乍一看可能效率低下，但有两点需要牢记。首先，移动的永远是值本身，而不是这些值拥有的堆存储。对于向量和字符串，<strong>值本身</strong>就是指单独的“三字标头”，幕后的大型元素数组和文本缓冲区仍然位于它们在堆中的位置。其次，Rust 编译器在生成代码时擅长“看穿”这一切动作。在实践中，机器码通常会将值直接存储在它应该在的位置。<span class=\"comment-number\">2</span></p>\n\n<h3 id=\"nav_point_69\">4.2.2　移动与控制流</h3>\n<p>前面的例子中都有非常简单的控制流，那么该如何在更复杂的代码中移动呢？一般性原则是，如果一个变量的值有可能已经移走，并且从那以后尚未明确赋予其新值，那么它就可以被看作是未初始化状态。如果一个变量在执行了 <code>if</code> 表达式中的条件后仍然有值，那么就可以在这两个分支中使用它：</p>\n<pre class=\"code-rows\"><code>let x = vec![10, 20, 30];\nif c {\n    f(x); // ……可以在这里移动x\n} else {\n    g(x); // ……也可以在这里移动x\n}\nh(x); // 错误：只要任何一条路径用过它，x在这里就是未初始化状态</code></pre>\n<p>出于类似的原因，禁止在循环中进行变量移动：</p>\n<pre class=\"code-rows\"><code>let x = vec![10, 20, 30];\nwhile f() {\n    g(x); // 错误：x已经在第一次迭代中移动出去了，在第二次迭代中，它成了未初始化状态\n}</code></pre>\n<p>也就是说，除非在下一次迭代中明确赋予 <code>x</code> 一个新值，否则就会出错。</p>\n<pre class=\"code-rows\"><code>let mut x = vec![10, 20, 30];\nwhile f() {\n    g(x);           // 从x移动出去了\n    x = h();        // 赋予x一个新值\n}\ne(x);</code></pre>\n<h3 id=\"nav_point_70\">4.2.3　移动与索引内容</h3>\n<p>前面提到过，移动会令其来源变成未初始化状态，因为目标将获得该值的所有权。但并非值的每种拥有者都能变成未初始化状态。例如，考虑以下代码：</p>\n<pre>\n// 构建一个由字符串\"101\"、\"102\"……\"105\"组成的向量\nlet mut v = Vec::new();\nfor i in 101 .. 106 {\n    v.push(i.to_string());\n}\n\n// 从向量中随机抽取元素\nlet third = v[2]; // 错误：不能移动到Vec索引结构之外<sup><b>3</b></sup>\nlet fifth = v[4]; // 这里也一样\n</pre>\n\n<blockquote>\n<p><sup><b>3</b></sup>注意这里写的是 <code>v[2]</code> 而非 <code>&amp;v[2]</code>。——译者注</p>\n</blockquote>\n<p>为了解决这个问题，Rust 需要以某种方式记住向量的第三个元素和第五个元素是未初始化状态，并要跟踪该信息直到向量被丢弃。通常的解决方案是，让每个向量都携带额外的信息来指示哪些元素是活动的，哪些元素是未初始化的。这显然不是系统编程语言应该做的。向量应该只是向量，不应该携带额外的信息或状态。事实上，Rust 会拒绝前面的代码并报告如下错误：</p>\n<pre class=\"code-rows\"><code>error: cannot move out of index of `Vec&lt;String&gt;`\n   |\n14 |     let third = v[2];\n   |                 ^^^^\n   |                 |\n   |                 move occurs because value has type `String`,\n   |                 which does not implement the `Copy` trait\n   |                 help: consider borrowing here: `&amp;v[2]`</code></pre>\n<p>移动第五个元素时 Rust 也会报告类似的错误。在这条错误消息中，Rust 还建议使用引用，因为你可能只是想访问该元素而不是移动它，这通常确实是你想要做的。但是，如果真想将一个元素移出向量该怎么办呢？需要找到一种在遵循类型限制的情况下执行此操作的方法。以下是 3 种可能的方法：</p>\n<pre class=\"code-rows\"><code>// 构建一个由字符串\"101\"、\"102\"……\"105\"组成的向量\nlet mut v = Vec::new();\nfor i in 101 .. 106 {\n    v.push(i.to_string());\n}\n\n// 方法一：从向量的末尾弹出一个值：\nlet fifth = v.pop().expect(\"vector empty!\");\nassert_eq!(fifth, \"105\");\n\n// 方法二：将向量中指定索引处的值与最后一个值互换，并把前者移动出来：\nlet second = v.swap_remove(1);\nassert_eq!(second, \"102\");\n\n// 方法三：把要取出的值和另一个值互换：\nlet third = std::mem::replace(&amp;mut v[2], \"substitute\".to_string());\nassert_eq!(third, \"103\");\n\n// 看看向量中还剩下什么\nassert_eq!(v, vec![\"101\", \"104\", \"substitute\"]);</code></pre>\n<p>每种方法都能将一个元素移出向量，但仍会让向量处于完全填充状态，只是向量可能会变小。</p>\n<p>像 <code>Vec</code> 这样的集合类型通常也会提供在循环中消耗所有元素的方法：</p>\n<pre class=\"code-rows\"><code>let v = vec![\"liberté\".to_string(),\n             \"égalité\".to_string(),\n             \"fraternité\".to_string()];\n\nfor mut s in v {\n    s.push('!');\n    println!(\"{}\", s);\n}</code></pre>\n<p>当我们将向量直接传给循环（如 <code>for ... in v</code>）时，会将向量从 <code>v</code> 中<strong>移动</strong>出去，让 <code>v</code> 变成未初始化状态。<code>for</code> 循环的内部机制会获取向量的所有权并将其分解为元素。在每次迭代中，循环都会将另一个元素转移给变量 <code>s</code>。由于 <code>s</code> 现在拥有字符串，因此可以在打印之前在循环体中修改它。在循环的过程中，向量本身对代码不再可见，因此也就无法观察到它正处在某种部分清空的状态。<span class=\"comment-number\">4</span></p>\n\n<p>如果需要从拥有者中移出一个编译器无法跟踪的值，那么可以考虑将拥有者的类型更改为能动态跟踪自己是否有值的类型。例如，下面是前面例子的一个变体：</p>\n<pre class=\"code-rows\"><code>struct Person { name: Option&lt;String&gt;, birth: i32 }\n\nlet mut composers = Vec::new();\ncomposers.push(Person { name: Some(\"Palestrina\".to_string()),\n                        birth: 1525 });</code></pre>\n<p>但不能像下面这样做：</p>\n<pre class=\"code-rows\"><code>let first_name = composers[0].name;</code></pre>\n<p>这只会引发与前面一样的“无法移动到索引结构之外”错误。但是因为已将 <code>name</code> 字段的类型从 <code>String</code> 改成了 <code>Option&lt;String&gt;</code>，所以这意味着 <code>None</code> 也是该字段要保存的合法值。因此，可以像下面这样做：</p>\n<pre class=\"code-rows\"><code>let first_name = std::mem::replace(&amp;mut composers[0].name, None);\nassert_eq!(first_name, Some(\"Palestrina\".to_string()));\nassert_eq!(composers[0].name, None);</code></pre>\n<p><code>replace</code> 调用会移出 <code>composers[0].name</code> 的值，将 <code>None</code> 留在原处，并将原始值的所有权转移给其调用者。事实上，这种使用 <code>Option</code> 的方式非常普遍，所以该类型专门为此提供了一个 <code>take</code> 方法，以便更清晰地写出上述操作，如下所示：</p>\n<pre class=\"code-rows\"><code>let first_name = composers[0].name.take();</code></pre>\n<p>这个 <code>take</code> 调用与之前的 <code>replace</code> 调用具有相同的效果。</p>\n<h2 id=\"nav_point_71\">4.3　<code>Copy</code> 类型：关于移动的例外情况</h2>\n<p>迄今为止，本章所展示的值移动示例都涉及向量、字符串和其他可能占用大量内存且复制成本高昂的类型。移动能让这些类型的所有权清晰且赋值开销极低。但对于像整数或字符这样的简单类型，如此谨小慎微的处理方式确实没什么必要。</p>\n<p>下面来比较一下用 <code>String</code> 进行赋值和用 <code>i32</code> 进行赋值时内存中有什么不同：</p>\n<pre class=\"code-rows\"><code>let string1 = \"somnambulance\".to_string();\nlet string2 = string1;\n\nlet num1: i32 = 36;\nlet num2 = num1;</code></pre>\n<p>运行这段代码后，内存如图 4-11 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00831.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4-11：用 <code>String</code> 赋值会移动值，而用 <code>i32</code> 赋值会复制值</strong></p>\n<p>与前面的向量一样，赋值会将 <code>string1</code><strong>转移给</strong><code>string2</code>，这样就不会出现两个字符串负责释放同一个缓冲区的情况。但是，<code>num1</code> 和 <code>num2</code> 的情况有所不同。<code>i32</code> 只是内存中的几字节，它不拥有任何堆资源，也不会实际依赖除本身的字节之外的任何内存。当我们将它的每一位转移给 <code>num2</code> 时，其实已经为 <code>num1</code> 制作了一个完全独立的副本。</p>\n<p>移动一个值会使移动的源变成未初始化状态。不过，尽管将 <code>string1</code> 视为未初始化变量确实符合其基本意图，但以这种方式对待 <code>num1</code> 毫无意义，继续使用 <code>num1</code> 也不会造成任何问题。移动在这里并无好处，反而会造成不便。</p>\n<p>之前我们谨慎地说过，<strong>大多数</strong>类型会被移动，现在该谈谈例外情况了，即那些被 Rust 指定成 <strong><code>Copy</code> 类型</strong>的类型。对 <code>Copy</code> 类型的值进行赋值会复制这个值，而不会移动它。赋值的源仍会保持已初始化和可用状态，并且具有与之前相同的值。把 <code>Copy</code> 类型传给函数和构造器的行为也是如此。</p>\n<p>标准的 <code>Copy</code> 类型包括所有机器整数类型和浮点数类型、<code>char</code> 类型和 <code>bool</code> 类型，以及某些其他类型。<code>Copy</code> 类型的元组或固定大小的数组本身也是 <code>Copy</code> 类型。</p>\n<p>只有那些可以通过简单地复制位来复制其值的类型才能作为 <code>Copy</code> 类型。前面解释过，<code>String</code> 不是 <code>Copy</code> 类型，因为它拥有从堆中分配的缓冲区。出于类似的原因，<code>Box&lt;T&gt;</code> 也不是 <code>Copy</code> 类型，因为它拥有从堆中分配的引用目标。代表操作系统文件句柄的 <code>File</code> 类型不是 <code>Copy</code> 类型，因为复制这样的值需要向操作系统申请另一个文件句柄。类似地，<code>MutexGuard</code> 类型表示一个互斥锁，它也不是 <code>Copy</code> 类型：复制这种类型毫无意义，因为每次只能有一个线程持有互斥锁。</p>\n<p>根据经验，任何在丢弃值时需要做一些特殊操作的类型都不能是 <code>Copy</code> 类型：<code>Vec</code> 需要释放自身元素、<code>File</code> 需要关闭自身文件句柄、<code>MutexGuard</code> 需要解锁自身互斥锁，等等。对这些类型进行逐位复制会让我们无法弄清哪个值该对原始资源负责。</p>\n<p>那么自定义类型呢？默认情况下，<code>struct</code> 类型和 <code>enum</code> 类型不是 <code>Copy</code> 类型：</p>\n<pre class=\"code-rows\"><code>struct Label { number: u32 }\n\nfn print(l: Label) { println!(\"STAMP: {}\", l.number); }\nlet l = Label { number: 3 };\nprint(l);\nprintln!(\"My label number is: {}\", l.number);</code></pre>\n<p>这无法编译。Rust 会报错：</p>\n<pre class=\"code-rows\"><code>error: borrow of moved value: `l`\n   |\n10 |     let l = Label { number: 3 };\n   |         - move occurs because `l` has type `main::Label`,\n   |           which does not implement the `Copy` trait\n11 |     print(l);\n   |           - value moved here\n12 |     println!(\"My label number is: {}\", l.number);\n   |                                        ^^^^^^^^\n   |                  value borrowed here after move</code></pre>\n<p>由于 <code>Label</code> 不是 <code>Copy</code> 类型，因此将它传给 <code>print</code> 会将值的所有权转移给 <code>print</code> 函数，然后在返回之前将其丢弃。这样做显然是愚蠢的，<code>Label</code> 中只有一个 <code>u32</code>，因此没有理由在将 <code>l</code> 传给 <code>print</code> 时移动这个值。</p>\n<p>但是用户定义的类型不是 <code>Copy</code> 类型这一点只是默认情况而已。如果此结构体的所有字段本身都是 <code>Copy</code> 类型，那么也可以通过将属性 <code>#[derive(Copy, Clone)]</code> 放置在此定义之上来创建 <code>Copy</code> 类型，如下所示：</p>\n<pre class=\"code-rows\"><code>#[derive(Copy, Clone)]\nstruct Label { number: u32 }</code></pre>\n<p>经过此项更改，前面的代码可以顺利编译了。但是，如果试图在一个其字段不全是 <code>Copy</code> 类型的结构体上这样做，则仍然行不通。假设要编译如下代码：</p>\n<pre class=\"code-rows\"><code>#[derive(Copy, Clone)]\nstruct StringLabel { name: String }</code></pre>\n<p>那么就会引发如下错误：</p>\n<pre class=\"code-rows\"><code>error: the trait `Copy` may not be implemented for this type\n  |\n7 | #[derive(Copy, Clone)]\n  |          ^^^^\n8 | struct StringLabel { name: String }\n  |                      ------------ this field does not implement `Copy`</code></pre>\n<p>为什么符合条件的用户定义类型不能自动成为 <code>Copy</code> 类型呢？这是因为类型是否为 <code>Copy</code> 对于在代码中使用它的方式有着重大影响：<code>Copy</code> 类型更灵活，因为赋值和相关操作不会把原始值变成未初始化状态。但对类型的实现者而言，情况恰恰相反：<code>Copy</code> 类型可以包含的类型非常有限，而非 <code>Copy</code> 类型可以在堆上分配内存并拥有其他种类的资源。因此，创建一个 <code>Copy</code> 类型代表着实现者的郑重承诺：如果以后确有必要将其改为非 <code>Copy</code> 类型，则使用它的大部分代码可能需要进行调整。</p>\n<p>虽然 C++ 允许重载赋值运算符以及定义专门的复制构造函数和移动构造函数，但 Rust 并不允许这种自定义行为。在 Rust 中，每次移动都是字节级的一对一浅拷贝，并让源变成未初始化状态。复制也是如此，但会保留源的初始化状态。这确实意味着 C++ 类可以提供 Rust 类型所无法提供的便捷接口，比如可以在看似普通的代码中隐式调整引用计数、把昂贵的复制操作留待以后进行，或使用另一些复杂的实现技巧。</p>\n<p>但这种灵活性的代价是，作为一门语言，C++ 的基本操作（比如赋值、传参和从函数返回值）变得更难预测。例如，本章的前半部分展示过在 C++ 中将一个变量赋值给另一个变量时可能需要任意数量的内存和处理器时间。Rust 的一个原则是：各种开销对程序员来说应该是显而易见的。基本操作必须保持简单，而潜在的昂贵操作应该是显式的，比如前面例子中对 <code>clone</code> 的调用就是在对向量及其包含的字符串进行深拷贝。</p>\n<p>本节用复制（<code>Copy</code>）和克隆（<code>Clone</code>）这两个模糊的术语描述了某个类型可能具备的特征。它们实际上是<strong>特型</strong>的示例。特型是 Rust 语言中的开放式工具，用于根据你对类型可以执行的操作来对类型进行分类。第 11 章会对特型做一般性讲解，第 13 章会专门讲解 <code>Copy</code> 和 <code>Clone</code> 这两个特型。</p>\n<h2 id=\"nav_point_72\">4.4　<code>Rc</code> 与 <code>Arc</code>：共享所有权</h2>\n<p>尽管在典型的 Rust 代码中大多数值会有唯一的拥有者，但在某些情况下，很难为每个值都找到具有所需生命周期的单个拥有者，你会希望某个值只要存续到每个人都用完它就好。对于这些情况，Rust 提供了引用计数指针类型 <code>Rc</code> 和 <code>Arc</code> [<code>Arc</code> 是<strong>原子引用计数</strong>(atomic reference count) 的缩写 ]。正如你对 Rust 的期待一样，这些类型用起来完全安全：你不会忘记调整引用计数，不会创建 Rust 无法注意到的指向引用目标的其他指针，也不会偶遇那些常与 C++ 中的引用计数指针如影随形的各种问题。</p>\n<p><code>Rc</code> 类型和 <code>Arc</code> 类型非常相似，它们之间唯一的区别是 <code>Arc</code> 可以安全地在线程之间直接共享，而普通 <code>Rc</code> 会使用更快的非线程安全代码来更新其引用计数。如果不需要在线程之间共享指针，则没有理由为 <code>Arc</code> 的性能损失“埋单”，因此应该使用 <code>Rc</code>，Rust 能防止你无意间跨越线程边界传递它。这两种类型在其他方面都是等效的，所以本节的其余部分只会讨论 <code>Rc</code>。</p>\n<p>之前我们展示过 Python 如何使用引用计数来管理值的生命周期。你可以使用 <code>Rc</code> 在 Rust 中获得类似的效果。考虑以下代码：</p>\n<pre class=\"code-rows\"><code>use std::rc::Rc;\n\n// Rust能推断出所有这些类型，这里写出它们只是为了讲解时清晰\nlet s: Rc&lt;String&gt; = Rc::new(\"shirataki\".to_string());\nlet t: Rc&lt;String&gt; = s.clone();\nlet u: Rc&lt;String&gt; = s.clone();</code></pre>\n<p>对于任意类型 <code>T</code>，<code>Rc&lt;T&gt;</code> 值是指向附带引用计数的在堆上分配的 <code>T</code> 型指针。克隆一个 <code>Rc&lt;T&gt;</code> 值并不会复制 <code>T</code>，相反，它只会创建另一个指向它的指针并递增引用计数。所以前面的代码在内存中会生成图 4-12 所示的结果。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00832.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4-12：具有 3 个引用的引用计数字符串</strong></p>\n<p>这 3 个 <code>Rc&lt;String&gt;</code> 指针指向了同一个内存块，其中包含引用计数和 <code>String</code> 本身的空间。通常的所有权规则适用于 <code>Rc</code> 指针本身，当丢弃最后一个现有 <code>Rc</code> 时，Rust 也会丢弃 <code>String</code>。</p>\n<p>可以直接在 <code>Rc&lt;String&gt;</code> 上使用 <code>String</code> 的任何常用方法：</p>\n<pre class=\"code-rows\"><code>assert!(s.contains(\"shira\"));\nassert_eq!(t.find(\"taki\"), Some(5));\nprintln!(\"{} are quite chewy, almost bouncy, but lack flavor\", u);</code></pre>\n<p><code>Rc</code> 指针拥有的值是不可变的。如果你试图将一些文本添加到字符串的末尾：</p>\n<pre class=\"code-rows\"><code>s.push_str(\" noodles\");</code></pre>\n<p>那么 Rust 会拒绝：</p>\n<pre class=\"code-rows\"><code>error: cannot borrow data in an `Rc` as mutable\n   |\n13 |     s.push_str(\" noodles\");\n   |     ^ cannot borrow as mutable\n   |</code></pre>\n<p>Rust 的内存和线程安全保证的基石是：确保不会有任何值是既共享又可变的。Rust 假定 <code>Rc</code> 指针的引用目标通常都可以共享，因此就不能是可变的。第 5 章会解释为什么这个限制很重要。</p>\n<p>使用引用计数管理内存的一个众所周知的问题是，如果有两个引用计数的值是相互指向的，那么其中一个值就会让另一个值的引用计数保持在 0 以上，因此这些值将永远没机会释放，如图 4-13 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00833.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4-13：循环引用计数——这些对象都没机会释放</strong></p>\n<p>以这种方式在 Rust 中造成值的泄漏也是有可能的，但这种情况非常少见。只要不在某个时刻让旧值指向新值，就无法建立循环。这显然要求旧值是可变的。由于 <code>Rc</code> 指针会保证其引用目标不可变，因此通常不可能建立这种循环引用。但是，Rust 确实提供了创建其他不可变值中的可变部分的方法，这称为<strong>内部可变性</strong>，9.11 节会详细介绍。如果将这些技术与 <code>Rc</code> 指针结合使用，则确实可以建立循环并造成内存泄漏。</p>\n<p>有时可以通过对某些链接使用<strong>弱引用指针</strong> <code>std::rc::Weak</code> 来避免建立 <code>Rc</code> 指针循环。但是，本节不会介绍这些内容，有关详细信息，请参阅标准库的文档。</p>\n<p>移动和引用计数指针是缓解所有权树严格性问题的两种途径。在第 5 章中，我们将研究第三种途径：借用对值的引用。一旦你熟悉了所有权和借用这两个概念，就已经翻越了 Rust 学习曲线中最陡峭的部分，并为发挥 Rust 的独特优势做好了准备。</p>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 3 章 基本数据类型","id":740802},"right":{"article_title":"第 5 章 引用","id":740804}},"comments":[]}