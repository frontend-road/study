{"id":669369,"title":"26｜RESTful API与Flask-Restful：如何实现后端接口的开发与封装？","content":"<p>你好，我是Barry。</p><p>我们都知道，直播视频平台采用的是前后端开发模式。除去前端界面的实现，后端接口设计开发也相当重要，我们要从多个维度去考量，其中包含API规范、请求方式、响应处理、返回数据等。这整个实现的过程，我们在后端接口开发前就要做足功课。</p><p>我们都知道，直播视频平台采用前后端分离的开发模式。除去前端界面的实现，后端接口设计开发也相当重要，我们要从多个维度去考量，其中包含API规范、请求方式、响应处理、返回数据等。整个实现的过程，我们在后端接口开发前就要做足功课。</p><p>这节课，我们就借助Flask-Restful来实现高效的前后端接口开发。Flask-Restful是一个用于Flask的扩展，它让构建RESTful API变得更加容易。为了让你循序渐进地掌握Flask-Restful，我们先来了解一下RESTful API，因为Flask-Restful就是基于RESTful APl 实现的。</p><h2>认识RESTful API</h2><p>在项目开发过程中，我们的接口调用过程的核心就是前后端通信和数据的交互。</p><p>我们提到的REST，它就是一种软件架构风格，它定义了一系列标准和约束，使得应用程序能够以一种统一的方式完成通信和数据交互，实现接口统一化。而<strong>RESTful API是一种基于REST架构的API设计规范</strong>，它遵循REST原则，包括使用标准的HTTP方法（如GET、POST、PUT、DELETE等）、URI设计、配置合理的HTTP状态码等。</p><!-- [[[read_end]]] --><p>RESTful API的设计目的是提高系统的可伸缩性、降低开发的复杂性，同时让系统更容易实现缓存等机制。RESTful API通常使用 <strong>JSON格式</strong>传输数据，我们在接口数据格式上也更倾向选用JSON格式。</p><h2>认识Flask-Restful</h2><p>明白了RESTful API的概念和用途，我们这就来学习一下Flask-Restful。</p><p>Flask-Restful提供了一系列的装饰器，如@app.route、@app.marshal_with等，可以帮助开发者快速构建API。此外，它还提供了一些其他的特性，如自动生成文档、支持自定义视图类等。</p><p>总体来说，Flask-Restful是一个强大的工具，可以帮助我们快速构建出符合RESTful API设计规范的API。</p><h3>Flask-Restful案例演示</h3><p>接下来，我们通过编译一个最简单的API，了解Flask-Restful是如何工作的。</p><p>首先，我们需要安装Flask-Restful，具体的安装命令如下所示。</p><pre><code class=\"language-python\">pip install flask-Restful\n</code></pre><p>紧接着，我们要创建Flask-Restful的实例化对象，操作和Flask的实例化对象App一样，你可以直接参考我写的代码。</p><pre><code class=\"language-python\">from flask import Flask\nfrom flask_RESTful import Api\napp = Flask(__name__)\napi = Api(app)\n#使用Flask应用app创建一个API对象，可以注册路由和资源，处理API请求\n</code></pre><p>和之前定义路由的方法不同，这里定义的对象是资源。资源表示API中的一个用户或某个数据集合，而路由则用于把HTTP请求映射到相应的资源上。这里借助Flask-Restful提供的Resource类来实现。</p><pre><code class=\"language-python\">from flask_RESTful import Resource\nclass HelloFlask(Resource):\n&nbsp; &nbsp; def GET(self):\n&nbsp; &nbsp; &nbsp; &nbsp; return {'hello': 'flask'}\napi.add_resource(HelloFlask, '/')\n</code></pre><p>我带着你把上面的代码分析一下，我们先定义一个资源类HelloFlask，在类中定义GET请求方法，在请求成功会返回两个字符串，分别是 hello 和 flask。当Flask接收到请求后，先把请求映射到对应的资源上，再调用对应的请求方法。我们可以使用add_resource()方法来实现绑定URL，告诉Flask在哪条具体路径上使用对应资源。</p><p>对应api.add_resource()的参数含义，你可以参考后面的思维导图。</p><p><img src=\"https://static001.geekbang.org/resource/image/47/90/47fdefcd84a0c776692f1fb0d4e13290.jpg?wh=1990x1276\" alt=\"\"></p><p>项目开发中我们通常都会定义前两个参数——资源类和资源所在的URL路径，参数endpoint不指定则默认为该资源类的名称，比如示例代码当中的endpoint默认为HelloFlask。其余参数我们可以依据不同情况灵活添加。</p><p>通过案例演示，相信你已经明白了Flask-Restful工作原理。接下来，我们就看看Flask-Restful中的HTTP请求和对应的响应处理要如何实现。</p><h3>HTTP请求方法和响应</h3><p>在Flask-Restful中，资源处理HTTP请求需要实现相应的请求方法。常见的HTTP请求方法包括GET、POST、PUT、DELETE等。在请求方法中，通常需要根据请求参数（如URL参数、请求体等）处理数据，并返回相应的响应。响应可以是一个普通的字符串、JSON对象或自定义对象。</p><p>对照后面的代码案例，我们看看Flask-Restful是如何去发起请求并处理响应的。</p><pre><code class=\"language-python\">from flask import Flask, request\nfrom flask_RESTful import Resource, Api\napp = Flask(__name__)\napi = Api(app)\nclass HelloFlask(Resource):\n    def GET(self):\n        return {'hello': 'flask'}\n&nbsp; &nbsp; &nbsp; &nbsp; # 处理GET请求\n&nbsp; &nbsp; def POST(self):\n&nbsp; &nbsp; &nbsp; &nbsp; # 处理POST请求，从request中获取数据\n&nbsp; &nbsp; &nbsp; &nbsp; data = request.get_json()\n&nbsp; &nbsp; &nbsp; &nbsp; return {'received_data': data}\napi.add_resource(HelloFlask, '/')\nif __name__ == '__main__':\n&nbsp; &nbsp; app.run()\n</code></pre><p>在上面的代码实例中，我们创建了一个Flask应用和一个RESTful API实例，定义了一个 HelloFlask 类作为资源，处理GET和POST请求，并且在根路径(“/”)上添加了这个资源。</p><p>当使用GET请求访问根路径时，服务器会返回一个包含 “hello”: “flask” 的JSON响应。当使用POST请求访问根路径时，服务器会从request中获取JSON格式的数据，并返回一个包含 received_data 和请求数据的JSON响应。</p><p>这里的GET方法可以直接运行程序来查看执行结果，我们在浏览器中输入绑定的URL即可显示内容。对应的效果图我给你放在了下面，你可以看一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/de/c8/dedb157a46f33f1224a6c7d8664307c8.jpg?wh=1990x962\" alt=\"\"></p><p>POST方法与GET方法不同，不能直接在浏览器输入URL来测试执行结果。我们可以借助工具requests来测试，它是Python的一个HTTP库（Python的第三方库），可以通过pip来安装使用，它允许我们发送HTTP请求并获取响应。</p><p>需要注意requests的请求参数要以<strong>字典形式</strong>编写，包括URL、headers、cookies等。它支持GET、POST、PUT、DELETE等HTTP方法，并且可以自动处理URL编码、解码、压缩等。除了基本的HTTP请求功能，requests还支持文件上传、响应内容处理、认证和代理等功能。这一部分你安装之后进行测试就可以。</p><p>这里要新建一个test_lb_05.py文件，我们重点来看具体的文件代码。</p><pre><code class=\"language-python\">import requests\n# 发送GET请求\nresponse = requests.get('http://localhost:5000/')\nprint(response.json())\n# 发送POST请求\ndata = {'name': 'Flask章节', 'number': 23}\nresponse = requests.post('http://localhost:5000/', json=data)\nprint(response.json())\n</code></pre><p>上述代码中，使用了requests库的GET请求发送到http://localhost:5000/ ，获取相应数据。</p><p>通过POST请求向http://localhost:5000/发送参数信息，并在请求成功之后获取响应内容。对于这两个方法，我们都会通过JSON将响应数据解析成字典格式，这样会方便前端处理。</p><p>接下来，我们先运行lb_05.py，后运行test_lb_05.py，等待返回结果。</p><p><img src=\"https://static001.geekbang.org/resource/image/92/3d/92b05cc077c1d3ae062755b04bb2993d.jpg?wh=2822x807\" alt=\"\"></p><p>运行完成后，记得在左栏的running中关闭此刻正在运行的lb_05.py。</p><p><img src=\"https://static001.geekbang.org/resource/image/58/f0/580d6c680c4f4a6553b5f5c8a78e2ef0.jpg?wh=2333x768\" alt=\"\"></p><p>查看其中的记录，可以看到&nbsp;GET和POST两种HTTP请求方式都运行了，这正是我们在test_lb_05.py文件中定义的。</p><h3>参数解析</h3><p>通过案例，我们全面了解了Flask-Restful的请求方法和响应，掌握了Flask-Restful接口开发的技巧。在接口请求成功，我们还需要处理返回的参数，这就是我们接下来要学习的参数解析。我们先来了解一下参数解析的作用。</p><p>参数解析的作用就是避免手动解析、验证参数的繁琐和可能的错误，实现更加高效的数据解析和管理。我们先通过下面的案例，来了解一下如何实现参数解析。</p><pre><code class=\"language-python\">from flask import Flask\nfrom flask_RESTful import Resource, Api, reqparse\napp = Flask(__name__)\napi = Api(app)\n# 创建一个RequestParser对象，用于解析请求中携带的参数\nparser = reqparse.RequestParser()\n# 添加一个参数，其名称为name，类型为字符串，若未填写则返回提示信息\nparser.add_argument('name', type=str, help='Name cannot be blank or input is not str type')\nparser.add_argument('number', type=int, help='Number cannot be blank or input is not int type')\nclass HelloFlask(Resource):\n    def GET(self):\n        # 处理GET请求\n        return {'hello': 'flask'}\n    def POST(self):\n    # 处理POST请求，从参数解析中获取数据\n    # 解析请求参数\n        args = parser.parse_args()\n        name = args['name']\n        number = args['number']\n        return {'name': name, 'number': number}\napi.add_resource(HelloFlask, '/')\nif&nbsp;__name__&nbsp;== '__main__':\n  app.run()\n</code></pre><p>这段代码中，我们创建了一个RequestParser对象，用来解析请求中携带的参数。上面代码主要解析了name和number这两个参数。函数add_argument中的type用来定义参数类型，后边的help是自定义发生错误时展示的提示信息，出错时可以做出友好提示。</p><p>name = args[‘name’] 和age = args[‘age’] 作用是获取请求参数中的 ‘name’ 值和 ‘age’ 值。这里有点像request.form.get方式，获取表单当中的某个字段，最终返回字典格式的请求参数。</p><p>同样，这里我们借助request模拟GET和POST请求，发送参数，查看返回结果。</p><pre><code class=\"language-python\">import requests\n# 发送GET请求\nresponse = requests.get('http://localhost:5000/')\nprint(response.json())\n# 发送POST请求\ndata = {'name': 'Flask章节', 'number': 数字}\nresponse = requests.post('http://localhost:5000/', json=data)\nprint(response.json())\n</code></pre><p>为了和之前的运行结果有所区分，我们修改了number的传递数据，改成字符类型，看看在进行参数解析时是什么结果。<br>\n再次操作估计你就更熟练了，我们先运行lb_05.py文件，再运行test_lb_05.py，然后查看一下运行结果。</p><p><img src=\"https://static001.geekbang.org/resource/image/f5/71/f542845d32abf8ca9f9993eea4253871.jpg?wh=2333x768\" alt=\"\"></p><p>就像截图里展示的这样，在解析参数解析时，add_argument会自动进行校验，出现传入空值或者不符合数据类型的值，就会提示用户改正。这种方式比手动解析参数时编写多个条件判断语句要方便很多，而且不易出错。</p><h2>与蓝图结合使用</h2><p>到这里我们已经熟悉了参数解析的用法，也知道了Flask-Restful整个规范流程。接下来我们就要看看如何实现Flask-Restful与蓝图的结合。使用Flask-Restful，最大的用处就是将一段代码或者函数封装成接口，被其他函数所调用，如果配合蓝图使用，可以让项目文件结构更清晰，提高可读性。</p><p>我们通过登录功能的案例来实践一下。为了帮你更好理解，我给你准备了每一个模块对应的所属文件图。</p><p><img src=\"https://static001.geekbang.org/resource/image/86/d0/8614dc02275f12a1b9ffd4ea3d7329d0.jpg?wh=2155x1438\" alt=\"\"></p><p>我们先来看UserLogin类的实现，对应的文件路径是api/models/user.py，具体实现的代码如下所示。</p><pre><code class=\"language-python\">from werkzeug.security import generate_password_hash, check_password_hash\nclass UserLogin(BaseModels, db.Model):\n    \"\"\"用户登陆表\"\"\"\n    __tablename__ = \"user_login\"\n    id = db.Column(db.Integer, primary_key=True, autoincrement=True)  # 用户id\n    mobile = db.Column(db.String(16), unique=True, nullable=False)  # 手机号\n    password_hash = db.Column(db.String(128), nullable=False)  # 加密的密码\n    user_id = db.Column(db.Integer)  # 用户id\n    last_login = db.Column(db.DateTime, default=datetime.now)  # 最后一次登录时间\n    last_login_stamp = db.Column(db.Integer)  # 最后一次登录时间\n    @property\n    #将一个方法变成属性\n    def password(self):\n        raise AttributeError('密码属性不能直接获取')\n    @password.setter\n    #定义password的setter方法\n    def password(self, value):\n        self.password_hash = generate_password_hash(value)\n    # 传入的是明文，校验明文和数据库里面的hash之后密码 正确true\n    def check_password(self, password):\n        return check_password_hash(self.password_hash, password)\n</code></pre><p>我为你解析一下这段代码，它的作用是定义了一个名为UserLogin的模型类，用于存储用户登录信息。该模型类继承了BaseModels和db.Model，其中BaseModels是一个基础模型类，db.Model是一个数据库模型类。模型里面包含的字段就是登录功能相关的字段信息。</p><p>UserLogin类还包含两个特殊方法——password方法和check_password方法。</p><p>password方法用于设置或获取用户的密码。直接访问该属性时，会抛出一个AttributeError异常，这是因为密码不能直接获取。当传入一个值时，password方法会使用generate_password_hash()函数将该值加密，并存储到password_hash字段中。</p><p>check_password方法用于校验用户输入的密码是否正确。该方法会接受一个参数password，来校验明文密码和数据库中的密码哈希值是否匹配。如果匹配成功就返回True，否则返回False。在校验过程中会使用check_password_hash()函数来比较。</p><p>到这里，我们就梳理好了上述UserLogin模型基类主要实现的功能。现在我们要把请求响应处理好，这样在接口请求之后，才能更好地贴合业务逻辑。</p><p>这里我建议你把response_utils.py存放在api/utils/response_utils.py这个文件路径上。</p><pre><code class=\"language-python\">from flask import jsonify\nclass HttpCode(object):\n    ok = 200\n    parmas_error = 400\n    server_error = 500\n    auth_error = 401\n    db_error = 1001\ndef rep_result(code, msg, data):\n    # {code=200, msg='ksdjksd', data={}}\n    return jsonify(code=code, msg=msg, data=data or {})\ndef success(msg, data=None):\n    return rep_result(code=HttpCode.ok, msg=msg, data=data)\ndef error(code, msg, data=None):\n    return rep_result(code=code, msg=msg, data=data)\n</code></pre><p>在上述代码中定义了各种HTTP状态码定义，成功响应与错误响应的统一格式以及对应的success()和error()方法。rep_result 方法用来返回响应结果，该方法接受三个参数：<strong>code（状态码）、msg（提示信息）和 data（响应数据）</strong>，并通过 jsonify函数将结果转换成JSON格式并返回。</p><p>success 和 error 两个方法分别用于返回成功和失败的响应结果。在后端开发中需要返回处理结果的时候，直接调用success()或error()方法即可。</p><p>下面我们就来实现视图函数，我们需要创建一个login.py文件，文件存放路径我写在下面的</p><p>api/modules/auth/login。具体代码实现是后面这样。</p><pre><code class=\"language-python\">from flask import current_app\nfrom flask_RESTful import Resource, reqparse, inputs\nfrom api.models.user import UserLogin\nfrom api.utils.auth_helper import Auth\nfrom api.utils.response_utils import error, HttpCode\nclass LoginView(Resource):\n&nbsp; &nbsp; def POST(self):\n&nbsp; &nbsp; &nbsp; &nbsp; parser = reqparse.RequestParser(bundle_errors=True)\n&nbsp; &nbsp; &nbsp; &nbsp; parser.add_argument('mobile', type=inputs.regex('1[3456789]\\\\d{9}'), required=True,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nullable=False, location=['form'], help='手机号参数不正确')\n&nbsp; &nbsp; &nbsp; &nbsp; parser.add_argument('password', type=str, required=True,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nullable=False, location=['form'], help='密码参数不正确')\n&nbsp; &nbsp; &nbsp; &nbsp; args = parser.parse_args()\n&nbsp; &nbsp; &nbsp; &nbsp; # 3.通过手机号取出用户对象\n&nbsp; &nbsp; &nbsp; &nbsp; try:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; user_login = UserLogin.query.filter(UserLogin.mobile == args.mobile).first()\n&nbsp; &nbsp; &nbsp; &nbsp; except Exception as e:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current_app.logger.error(e)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error(code=HttpCode.db_error, msg='查询手机号异常')\n&nbsp; &nbsp; &nbsp; &nbsp; # 验证拿到的这个手机号&nbsp; 是否在我们的登陆信息中存在&nbsp; 异常捕获\n&nbsp; &nbsp; &nbsp; &nbsp; # 判断我们的用户信息不在返回错误的响应码\n&nbsp; &nbsp; &nbsp; &nbsp; if not user_login:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error(code=HttpCode.db_error, msg='用户不存在')\n&nbsp; &nbsp; &nbsp; &nbsp; return Auth().authenticate(args.mobile, args.password)\n</code></pre><p>在这段代码中，我们定义LoginView类作为资源，用于处理POST请求。在创建RequestParser对象时，参数bundle_errors=True能将请求参数校验时发生的所有错误，都打包成一个列表返回。</p><p>随后我们向参数解析器parser中添加 mobile 和 password参数。这些参数的含义你可以参考后面的表格。</p><p><img src=\"https://static001.geekbang.org/resource/image/f5/51/f5e61468c4cfcd7f0b3b4529ebe45351.jpg?wh=3159x1412\" alt=\"\"><br>\ntry-except异常处理，用于查询用户操作，如果从数据库中查询到的手机号和用户输入的一致，则表示查询成功。如果查询失败，程序就会记录错误日志，并返回一个包含错误消息的 HTTP 响应。其中current_app是正在运行的 Flask 应用程序的代理对象。</p><p>在日志记录管理方面，我们使用了.error()方法，如果有任何异常发生，则会在日志文件中记录下来，方便查找和调试问题，让我们能尽快锁定问题。</p><p>if语句表示，如果查询到的用户对象不存在，就返回一个包含错误消息的 HTTP 响应。如果以上都验证无误，则会调用 Auth 类的 authenticate 方法，该方法会将传入的手机号和密码与数据库中保存的记录做比对，并返回包含用户身份信息。其中，Auth 类是编写的一个验证用户登录的工具类。</p><p>完成视图函数之后，我们再看看蓝图层具体该如何实现。</p><p>在蓝图层，注册名为auth_blu的蓝图，它的 URL 前缀是 /auth。<strong>这意味着，对于使用这个蓝图的路由，都需要以 /auth 开头。通过add_resource方法将LoginView视图和路径 ‘/login’ 绑定， LoginView的完整URL变成了 ‘/auth/login’。</strong></p><pre><code class=\"language-python\">from flask import Blueprint\nfrom flask_RESTful import Api\nfrom api.modules.auth.login import LoginView\nauth_blu = Blueprint('auth', __name__, url_prefix='/auth')\napi = Api(auth_blu)\napi.add_resource(LoginView, '/login')\n</code></pre><p>在api的__init__.py文件中，添加对应的蓝图初始化</p><pre><code class=\"language-python\">from api.modules.auth import auth_blu\napp.register_blueprint(auth_blu)\n</code></pre><h2>总结</h2><p>又到了课程的尾声，我们一起回顾总结一下今天的内容。</p><p>RESTful API是一种基于REST架构的API设计规范，设计目的就是提高系统的可伸缩性、降低开发的复杂性。我们都知道直播视频平台采用的是前后端分离开发模式，这就需要前后端在开发过程中对接口规范统一化的管理，这时就需要通过RESTful API实现。</p><p>通过案例实践，我们明确了Flask-Restful工作原理，还有在项目中如何使用Flask-Restful。之后我们学习了HTTP请求方法和响应处理。通过GET方法和POST方法的比对，带你掌握了HTTP请求应用方法。在接口请求成功的过程中，我们重点要<strong>关注响应数据和请求状态码</strong>，这样就能做好接口返回处理了。</p><p>在代码实践环节，我们以登录功能为例做了练习。我们可以把Flask-Restful和蓝图配合起来使用，让项目文件结构更清晰，提高可读性。今天内容代码量比较大，还是需要你课后多多实践练习，强化自己的接口开发能力。</p><p>从数据库表的设计到最终完成功能开发，相信你的后端开发综合实力又上了一个台阶。下节课我们还会实现认证模块，敬请期待。</p><h2>思考题</h2><p>课程中我们提到的很多请求方法，你可以说出都是哪几种，还有它们之间有什么区别么？</p><p>欢迎你在留言区和我交流互动，如果这节课对你有启发，别忘了分享给身边的朋友。</p>","neighbors":{"left":{"article_title":"25｜Blueprint与Redprint：如何让程序进行模块化处理？","id":668408},"right":{"article_title":"27｜初识认证机制：认证机制能解决哪些问题？","id":669871}},"comments":[{"had_liked":false,"id":377147,"user_name":"长林啊","can_delete":false,"product_type":"c1","uid":1707743,"ip_address":"四川","ucode":"B75CB4919FF25A","user_header":"https://static001.geekbang.org/account/avatar/00/1a/0e/df/a64b3146.jpg","comment_is_top":false,"comment_ctime":1687999570,"is_pvip":false,"replies":[{"id":137512,"content":"感谢Forest分享，非常的精准，期待你的下次分享，我们一起加油","user_name":"作者回复","user_name_real":"编辑","uid":3050845,"ctime":1688398007,"ip_address":"北京","comment_id":377147,"utype":1}],"discussion_count":1,"race_medal":1,"score":2,"product_id":100546501,"comment_content":"思考题：\nget：用于获取资源；是幂等的，也就是对同一个URL多次调用返回的结果应该是相同的\npost：用于处理提交的数据；post请求一般会产生新的资源，post请求不是幂等的\nput：向指定的资源上传新的内容；PUT请求是幂等的\ndelete：请求服务器删除指定的资源\nhead：类似于GET请求，但只返回头部信息，不返回实际内容，常用于检查资源是否存在、获取资源的元数据等\noptions：返回服务器支持的HTTP请求方法，用于查询服务器支持哪些方法","like_count":2,"discussions":[{"author":{"id":3050845,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/8d/5d/9a86007c.jpg","nickname":"Barry","note":"","ucode":"82175C78B4CAED","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622555,"discussion_content":"感谢Forest分享，非常的精准，期待你的下次分享，我们一起加油","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1688398007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":393247,"user_name":"Rongfan Leo","can_delete":false,"product_type":"c1","uid":1738062,"ip_address":"安徽","ucode":"9E65C1AA80CE2C","user_header":"https://static001.geekbang.org/account/avatar/00/1a/85/4e/1cecdfba.jpg","comment_is_top":false,"comment_ctime":1723276364,"is_pvip":false,"replies":[{"id":143262,"content":"Flask-Restful 是一个用于 Flask 的扩展，它让构建 RESTful API 变得更加容易。就是用来实现前后端接口接口联动的工具。","user_name":"作者回复","user_name_real":"编辑","uid":3050845,"ctime":1727424610,"ip_address":"北京","comment_id":393247,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100546501,"comment_content":"项目代码里是from flask_restful import，文章里是flask_RESTful算什么意思\n","like_count":0,"discussions":[{"author":{"id":3050845,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/8d/5d/9a86007c.jpg","nickname":"Barry","note":"","ucode":"82175C78B4CAED","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651787,"discussion_content":"Flask-Restful 是一个用于 Flask 的扩展，它让构建 RESTful API 变得更加容易。就是用来实现前后端接口接口联动的工具。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1727424610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":376785,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1687402195,"is_pvip":false,"replies":[{"id":137514,"content":"1、对于一个拥有一千万用户的视频网站，Java 和 Python 都是可行的选择。具体的选择应该根据网站的需求、开发团队的技能和经验、可用的资源和时间等因素进行综合考虑。\n2、是的，我们采用的就是前后端分离的开发模式。对于后面的问题，是的，就是不同框架都有它的优势，可能字啊语法和应用上不同，但是前后端框架不会互相影响，都是独立的。\n\n","user_name":"作者回复","user_name_real":"编辑","uid":3050845,"ctime":1688398682,"ip_address":"北京","comment_id":376785,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100546501,"comment_content":"Q1：做一个视频网站，用户一千万，这种规模的网站，后端开发老师会选什么？Java还是Python?\nQ2：网站开发，后端和前端的技术栈是相互独立的，对吗？\n后端选Java还是Python，都不会影响前端选vue或者React，反过来也一样。这样理解对吗？","like_count":0,"discussions":[{"author":{"id":3050845,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/8d/5d/9a86007c.jpg","nickname":"Barry","note":"","ucode":"82175C78B4CAED","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622559,"discussion_content":"1、对于一个拥有一千万用户的视频网站，Java 和 Python 都是可行的选择。具体的选择应该根据网站的需求、开发团队的技能和经验、可用的资源和时间等因素进行综合考虑。\n2、是的，我们采用的就是前后端分离的开发模式。对于后面的问题，是的，就是不同框架都有它的优势，可能字啊语法和应用上不同，但是前后端框架不会互相影响，都是独立的。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1688398682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1707743,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/0e/df/a64b3146.jpg","nickname":"长林啊","note":"","ucode":"B75CB4919FF25A","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622185,"discussion_content":"看到这个问题，谈谈个人浅见，考虑不周之处，欢迎讨论；A1: 技术栈的选型大概率不会因为实现某个需求或者功能去刻意选择一门语言，可能更多的会考虑，技术栈的生态、团队的技术支持、项目的开发周期和成本，毕竟在做技术选型的时候，要综合考虑，一个人可能会走很快，但是一群人才能走更远\nA2：在前后端分离开发的模式下，服务端使用任何语言都不会影响前端的技术选型，前端无论使用 vue、react、svelte、solidjs 等技术同样也不会影响服务端的技术选型","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1688000454,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}