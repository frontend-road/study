{"id":742667,"title":"15｜类加载机制的改变：如何自定义ClassLoader？","content":"<p>你好，我是郭屹。今天我们继续手写MiniTomcat。</p><p>上节课我们引入了多应用的支持，实现了通过路由将请求发送到不同应用中，在这个过程中我们也定义了WebappClassLoader这个自定义的类加载器来进行隔离。</p><p>但是光有隔离还不够，因为不同的类加载器有不同的加载方式和顺序，而Java自身的系统级ClassLoader也不能完全满足我们的需要，所以这节课我们要继续扩展这个话题，深入讨论自定义的ClassLoader。</p><h2>类加载器原理</h2><p>我们平时写程序的时候似乎感觉不到类加载器，其实是因为Java在帮我们默认使用，我们的程序中每涉及到一个类的使用，运行时Java都会通过一个类加载器来加载它。Java里面对它的定义是：类加载器是一个对象，它负责加载别的类（Class Loader is an object that is responsible for loading classes）。</p><p>我们简单回顾一下一个Java对象是如何在JVM里面运行起来的。一个简单的语句 <code>new Test();</code> 大体会经过下面几个步骤。</p><p>步骤一：<strong>类级别的工作。</strong>具体某个类的加载过程只会做一次。</p><ol>\n<li>加载：找到class文件，打开并获取它的字节流，按照虚拟机规范存储在JVM里，同时创建一个和它匹配的java.lang.Class类对象。这个时候，类的定义和内存表达就准备好了，但是还没有开始对象的创建。</li>\n<li>链接：这个阶段执行类的链接过程，给类分配内存。具体它有三个动作要做。</li>\n</ol><!-- [[[read_end]]] --><ul>\n<li>验证：用于验证class文件是否合规。按照字节码的规范检验class文件的格式是否正确，就是在这一步完成的。</li>\n<li>准备：这个阶段给类里面的静态变量分配内存，赋予默认值。</li>\n<li>解析：将符号引用转成直接内存引用。</li>\n</ul><ol start=\"3\">\n<li>初始化：这个阶段完成类加载，把所有静态变量赋初始值，执行静态代码块。</li>\n</ol><p>步骤二：<strong>对象级别的工作。</strong>经过第一步，我们的类就准备好了，对象有了模子。创建对象（实例）的事情就简单了。</p><ol>\n<li>为对象在堆中分配内存，需要注意的是，实例字段包括自身定义的和从父类继承下来的两个部分。</li>\n<li>对实例内存进行零值初始化。</li>\n<li>调用对象的构造函数。</li>\n</ol><p>这就是创建对象的过程。</p><p>我们继续探讨类的加载，<strong>在 Java 中有三种类加载器存在，一个应用加载器，一个扩展加载器，一个根加载器。</strong>它们有不同的用处：应用类加载器加载我们自己写的类；扩展类加载器加载Java核心类的扩展部分，也就是那些放在 <code>$JRE_HOME/lib/ext</code> 目录下的类；根类加载器加载Java平台核心类，比如java.lang.Object和java.lang.Thread 以及rt.jar里的类。</p><p>这几个类加载器之间是有层次关系的，这种关系就叫做委托模型（Delegation Model）。一个类加载器把对类的加载任务委托给它的上层（Parent）去做。具体来说，一个类加载器自己先不加载，而是交给它的上层去处理，而上层再交给它的上层去处理，一层层委托上去一直到根类加载器，如果上层发现自己加载不了这个类，才会交给下层加载。</p><p>一般情况下是这样的次序，先是应用类加载器加载客户程序，它自己不做，交给上层的扩展类加载器，再交给根类加载器。之后方向反过来，根类加载器发现不能加载，就返给扩展类加载器，如果还是加载不了，最后再返给应用类加载器。</p><p>这就是Java里面的标准类加载模式，叫做<strong>双亲委托模型</strong>。这个模式初看起来奇怪，但是它这个机制保证了Java系统的安全性，保护了Java自身的核心类不被替换掉。</p><p>那么问题来了，Java把这一套机制设计得好好的，我们为什么要用自定义类加载器呢？这是由我们的需求决定的，我们的MiniTomcat是一个应用服务器，它负责管理多个Java应用，因此它需要满足几个特性。</p><ol>\n<li>应用之间类隔离，不同的应用使用同一个类是可以的，这个类还可以有不同版本，不应该冲突。</li>\n<li>不同应用之间可以共享某些基础包。</li>\n<li>应用与MiniTomcat本身的类应该互相不干扰。</li>\n</ol><p>对这些特性，用标准模式不能满足应用。因为按照双亲委托模型，都先交给上层类加载器，就是AppClassLoader去加载了。这个父类加载器分不清具体每一个应用所需要的类。因此，我们自己的类加载器中需要自己定义不同的加载顺序。简单来讲，应该由自定义的类加载器自行加载类，而不是一概交给上层去加载。</p><p>接下来让我们一起动手实现。</p><h2>项目结构</h2><p>这节课我们新增了Loader通用接口，定义了WebappLoader类，并且为了使结构保持一致，把原有的webroot目录更名为webapps，并进一步调整优化目录结构。你可以看一下目前的项目结构。</p><pre><code class=\"language-plain\">MiniTomcat\n├─ src\n│  ├─ main\n│  │  ├─ java\n│  │  │  ├─ com\n│  │  │  │  ├─ minit\n│  │  │  │  │  ├─ connector\n│  │  │  │  │  │  ├─ http\n│  │  │  │  │  │  │  ├─ DefaultHeaders.java\n│  │  │  │  │  │  │  ├─ HttpConnector.java\n│  │  │  │  │  │  │  ├─ HttpHeader.java\n│  │  │  │  │  │  │  ├─ HttpProcessor.java\n│  │  │  │  │  │  │  ├─ HttpRequestImpl.java\n│  │  │  │  │  │  │  ├─ HttpRequestLine.java\n│  │  │  │  │  │  │  ├─ HttpResponseImpl.java\n│  │  │  │  │  │  │  ├─ ServletProcessor.java\n│  │  │  │  │  │  │  ├─ SocketInputStream.java\n│  │  │  │  │  │  │  ├─ StatisResourceProcessor.java\n│  │  │  │  │  │  ├─ HttpRequestFacade.java\n│  │  │  │  │  │  ├─ HttpResponseFacade.java\n│  │  │  │  │  ├─ core\n│  │  │  │  │  │  ├─ ApplicationFilterChain.java\n│  │  │  │  │  │  ├─ ApplicationFilterConfig.java\n│  │  │  │  │  │  ├─ CommonClassLoader.java\n│  │  │  │  │  │  ├─ CommonLoader.java\n│  │  │  │  │  │  ├─ ContainerBase.java\n│  │  │  │  │  │  ├─ ContainerListenerDef.java\n│  │  │  │  │  │  ├─ FilterDef.java\n│  │  │  │  │  │  ├─ FilterMap.java\n│  │  │  │  │  │  ├─ StandardContext.java\n│  │  │  │  │  │  ├─ StandardContextValve.java\n│  │  │  │  │  │  ├─ StandardHost.java\n│  │  │  │  │  │  ├─ StandardHostValve.java\n│  │  │  │  │  │  ├─ StandardPipeline.java\n│  │  │  │  │  │  ├─ StandardWrapper.java\n│  │  │  │  │  │  ├─ StandardWrapperValve.java\n│  │  │  │  │  │  ├─ WebappClassLoader.java\n│  │  │  │  │  │  ├─ WebappLoader.java\n│  │  │  │  │  ├─ logger\n│  │  │  │  │  │  ├─ Constants.java\n│  │  │  │  │  │  ├─ FileLogger.java\n│  │  │  │  │  │  ├─ LoggerBase.java\n│  │  │  │  │  │  ├─ SystemErrLogger.java\n│  │  │  │  │  │  ├─ SystemOutLogger.java\n│  │  │  │  │  ├─ session\n│  │  │  │  │  │  ├─ StandardSession.java\n│  │  │  │  │  │  ├─ StandardSessionFacade.java\n│  │  │  │  │  ├─ startup\n│  │  │  │  │  │  ├─ BootStrap.java\n│  │  │  │  │  ├─ util\n│  │  │  │  │  │  ├─ CookieTools.java\n│  │  │  │  │  │  ├─ StringManager.java\n│  │  │  │  │  │  ├─ URLDecoder.java\n│  │  │  │  │  ├─ valves\n│  │  │  │  │  │  ├─ AccessLogValve.java\n│  │  │  │  │  │  ├─ ValveBase.java\n│  │  │  │  ├─ Connector.java\n│  │  │  │  ├─ Container.java\n│  │  │  │  ├─ ContainerEvent.java\n│  │  │  │  ├─ ContainerListener.java\n│  │  │  │  ├─ Context.java\n│  │  │  │  ├─ InstanceEvent.java\n│  │  │  │  ├─ InstanceListener.java\n│  │  │  │  ├─ Loader.java\n│  │  │  │  ├─ Logger.java\n│  │  │  │  ├─ Pipeline.java\n│  │  │  │  ├─ Request.java\n│  │  │  │  ├─ Response.java\n│  │  │  │  ├─ Session.java\n│  │  │  │  ├─ SessionEvent.java\n│  │  │  │  ├─ SessionListener.java\n│  │  │  │  ├─ Valve.java\n│  │  │  │  ├─ ValveContext.java\n│  │  │  │  ├─ Wrapper.java\n│  │  ├─ resources\n│  ├─ test\n│  │  ├─ java\n│  │  │  ├─ test\n│  │  │  │  ├─ HelloServlet.java\n│  │  │  │  ├─ TestFilter.java\n│  │  │  │  ├─ TestListener.java\n│  │  │  │  ├─ TestServlet.java\n│  │  ├─ resources\n├─ webapps\n│  ├─ app1\n│  │  ├─ WEB-INF\n│  │  │  ├─ classes\n│  │  │  │  ├─ test\n│  │  │  │  │  ├─ HelloServlet.class\n│  │  │  │  │  ├─ TestFilter.class\n│  │  │  │  │  ├─ TestListener.class\n│  │  │  │  │  ├─ TestServlet.class\n│  │  ├─ hello.txt\n│  ├─ app2\n│  │  ├─ WEB-INF\n│  │  │  ├─ classes\n│  │  │  │  ├─ test\n│  │  │  │  │  ├─ HelloServlet.class\n│  │  │  │  │  ├─ TestFilter.class\n│  │  │  │  │  ├─ TestListener.class\n│  │  │  │  │  ├─ TestServlet.class\n│  │  ├─ hello.txt\n├─ pom.xml\n</code></pre><h2>引入自定义加载器</h2><p>到目前为止，我们的MiniTomcat框架里涉及到两类ClassLoader，一类是Java提供的系统级的ClassLoader，另外一类是MiniTomcat所管理的每一个Context应用级别的WebappClassLoader。</p><p>其中WebappClassLoader是我们在框架中自定义的类加载器，这是这节课的重点，我们整理一下，先定义Loader通用接口。</p><pre><code class=\"language-java\">package com.minit;\npublic interface Loader {\n    public Container getContainer();\n    public void setContainer(Container container);\n    public String getPath();\n    public void setPath(String path);\n    public String getDocbase();\n    public void setDocbase(String docbase);\n    public ClassLoader getClassLoader();\n    public String getInfo();\n    public void addRepository(String repository);\n    public String[] findRepositories();\n    public void start();\n    public void stop();\n}\n</code></pre><p>在Container通用接口中，把引用的WebappClassLoader也改为引用Loader类型。</p><pre><code class=\"language-java\">package com.minit;\npublic interface Container {\n    public Loader getLoader();\n    public void setLoader(Loader loader);\n}\n</code></pre><p>因此实现的Container接口里的getLoader和setLoader方法的ContainerBase需要调整，你可以看一下具体调整了哪些地方。</p><pre><code class=\"language-java\">package com.minit.core;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\npublic abstract class ContainerBase implements Container,Pipeline {\n     public Loader getLoader() {\n        if (loader != null)\n            return (loader);\n        if (parent != null)\n            return (parent.getLoader());\n        return (null);\n    }\n    public synchronized void setLoader(Loader loader) {\n        loader.setPath(path);\n        loader.setDocbase(docbase);\n        loader.setContainer(this);\n        Loader oldLoader = this.loader;\n        if (oldLoader == loader)\n            return;\n        this.loader = loader;\n    }\n}\n</code></pre><p>后续调用ContainerBase中的getLoader和setLoader方法都需要将返回值改为Loader，这会涉及到ApplicationFilterConfig、StandardContext、StandardHost、StandardWrapper等类的修改，因为比较简单，所以这里我就不再把这些代码一一列出了。</p><h2>修改类加载过程</h2><p>前面提到过，标准的类加载过程不能满足我们的要求，我们来修改一下。参照Tomcat的实现，我们会提供两个ClassLoader，一个是CommonClassLoader，一个是WebappClassLoader。</p><p>为什么我们要提供两个ClassLoader？因为我们要把MiniTomcat自身需要的类库和应用需要的类库分开，所以需要两个不同的ClassLoader。我们把MiniTomcat自身需要的类由CommonClassLoader加载，放在lib目录下，应用程序的类由WebappClassLoader加载，放在\\WEB-INF\\classes目录下。</p><p>你可以看一下Tomcat（MiniTomcat）的类加载图。</p><p><img src=\"https://static001.geekbang.org/resource/image/b2/f5/b2245fb9336b2ddd8f4a4e6da33b40f5.png?wh=1920x1066\" alt=\"图片\"></p><p>注意了，虽然我们这里也是用的parent这个词，但是其实并不是父子关系，而是组合关系。</p><p>我们来总结一下Tomcat的类加载过程。Web应用默认的类加载顺序是这样的（打破了双亲委派规则）。</p><ol>\n<li>先从JVM的BootStrapClassLoader中加载。</li>\n<li>加载Web应用下/WEB-INF/classes中的类。</li>\n<li>加载System classpath路径下面的类。</li>\n<li>加载Common路径下面的类。</li>\n</ol><p><img src=\"https://static001.geekbang.org/resource/image/30/c6/30fc14b602aee704d85a5bd36e6196c6.png?wh=1920x1110\" alt=\"图片\"></p><p>如果在配置文件中配置了 <code>&lt;Loader delegate=\"true\"/&gt;</code>，那么就是遵循双亲委派规则，那么加载顺序就是这样的。</p><ol>\n<li>先从JVM的BootStrapClassLoader中加载。</li>\n<li>加载上面定义的System classpath路径下面的类。</li>\n<li>加载上面定义的Common路径下面的类。</li>\n<li>加载Web应用下/WEB-INF/classes中的类。</li>\n</ol><p><img src=\"https://static001.geekbang.org/resource/image/de/e6/de323218fbf1e925685c99a9e2ab80e6.png?wh=1920x1066\" alt=\"图片\"></p><p>可以看出，两种加载次序的不同在于自定义的类加载器在何时起效，MiniTomcat参照Tomcat的实现，先由自定义类加载器加载，然后再给system加载器。代码与Tomcat有所不同，主要的目的是展示与标准不同的加载顺序。</p><p>你可以看一下CommonLoader和CommonClassLoader的代码定义。</p><p>CommonLoader：</p><pre><code class=\"language-java\">package com.minit.core;\npublic class CommonLoader implements Loader {\n    ClassLoader classLoader;\n    ClassLoader parent;\n    String path;\n    String docbase;\n    Container container;\n    public CommonLoader() {\n    }\n    public CommonLoader(ClassLoader parent) {\n        this.parent = parent;\n    }\n    public Container getContainer() {\n        return container;\n    }\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n    public String getPath() {\n        return path;\n    }\n    public void setPath(String path) {\n        this.path = path;\n    }\n    public String getDocbase() {\n        return docbase;\n    }\n    public void setDocbase(String docbase) {\n        this.docbase = docbase;\n    }\n\n    public ClassLoader getClassLoader() {\n        return classLoader;\n    }\n    public String getInfo() {\n        return \"A simple loader\";\n    }\n    public void addRepository(String repository) {\n    }\n    public String[] findRepositories() {\n        return null;\n    }\n    public synchronized void start() {\n        System.out.println(\"Starting Common Loader, docbase: \" + docbase);\n        try {\n            // 创建一个URLClassLoader\n            //类加载目录是minit安装目录下的lib目录\n            URL[] urls = new URL[1];\n            URLStreamHandler streamHandler = null;\n            File classPath = new File(System.getProperty(\"minit.home\"));\n            String repository = (new URL(\"file\", null, classPath.getCanonicalPath() + File.separator)).toString() ;\n            repository = repository + \"lib\" + File.separator;\n            urls[0] = new URL(null, repository, streamHandler);\n            System.out.println(\"Common classloader Repository : \"+repository);\n            classLoader = new CommonClassLoader(urls);\n        }\n        catch (Exception e) {\n            System.out.println(e.toString() );\n        }\n    }\n    public void stop() {\n    }\n}\n</code></pre><p>CommonClassLoader：</p><pre><code class=\"language-java\">package com.minit.core;\npublic class CommonClassLoader extends URLClassLoader {\n    protected boolean delegate = false;\n    private ClassLoader parent = null;\n    private ClassLoader system = null;\n    public CommonClassLoader() {\n        super(new URL[0]);\n        this.parent = getParent();\n        system = getSystemClassLoader();\n    }\n    public CommonClassLoader(URL[] urls) {\n        super(urls);\n        this.parent = getParent();\n        system = getSystemClassLoader();\n    }\n    public CommonClassLoader(ClassLoader parent) {\n        super(new URL[0], parent);\n        this.parent = parent;\n        system = getSystemClassLoader();\n    }\n    public CommonClassLoader(URL[] urls, ClassLoader parent) {\n        super(urls, parent);\n        this.parent = parent;\n        system = getSystemClassLoader();\n    }\n    public boolean getDelegate() {\n        return (this.delegate);\n    }\n    public void setDelegate(boolean delegate) {\n        this.delegate = delegate;\n    }\n    public Class findClass(String name) throws ClassNotFoundException {\n        Class clazz = null;\n        try {\n            clazz = super.findClass(name);\n        } catch (RuntimeException e) {\n            throw e;\n        }\n        if (clazz == null) {\n            throw new ClassNotFoundException(name);\n        }\n        // 返回我们定位的类\n        return (clazz);\n    }\n    public Class loadClass(String name) throws ClassNotFoundException {\n        return (loadClass(name, false));\n    }\n    //加载类，注意加载次序，这个方法同时考虑了双亲委托模式\n    public Class&lt;?&gt; loadClass(String name, boolean resolve)\n            throws ClassNotFoundException {\n        Class&lt;?&gt; clazz = null;\n        // 先是尝试使用系统类加载器加载类，以防止Web应用程序覆盖J2SE类\n        try {\n            clazz = system.loadClass(name);\n            if (clazz != null) {\n                if (resolve)\n                    resolveClass(clazz);\n                return (clazz);\n            }\n        } catch (ClassNotFoundException e) {\n            // Ignore\n        }\n        boolean delegateLoad = delegate;\n        // 到这里，系统类加载器不能加载，就判断是不是委托代理模式，将其委托给父类\n        if (delegateLoad) {\n            ClassLoader loader = parent;\n            if (loader == null)\n                loader = system;\n            try {\n                clazz = loader.loadClass(name);\n                if (clazz != null) {\n                    if (resolve)\n                        resolveClass(clazz);\n                    return (clazz);\n                }\n            } catch (ClassNotFoundException e) {\n                ;\n            }\n        }\n        // 到这里，搜索本地存储库，自己加载\n        try {\n            clazz = findClass(name);\n            if (clazz != null) {\n                if (resolve)\n                    resolveClass(clazz);\n                return (clazz);\n            }\n        } catch (ClassNotFoundException e) {\n            ;\n        }\n        // (3) 到了这里，自己加载不了，就委托给父类\n        if (!delegateLoad) {\n            ClassLoader loader = parent;\n            if (loader == null)\n                loader = system;\n            try {\n                clazz = loader.loadClass(name);\n                if (clazz != null) {\n                    if (resolve)\n                        resolveClass(clazz);\n                    return (clazz);\n                }\n            } catch (ClassNotFoundException e) {\n                ;\n            }\n        }\n        // 该类未找到\n        throw new ClassNotFoundException(name);\n    }\n    private void log(String message) {\n        System.out.println(\"WebappClassLoader: \" + message);\n    }\n    private void log(String message, Throwable throwable) {\n        System.out.println(\"WebappClassLoader: \" + message);\n        throwable.printStackTrace(System.out);\n    }\n}\n</code></pre><p>我们看到，Tomcat在CommonClassLoader中，依然会沿用双亲委托机制，这是因为\\lib目录下的类是整个Tomcat使用的，只有一份，这样加载就可以。CommonLoader是Minit全局共通的，它从lib目录下加载类。</p><pre><code class=\"language-java\">&nbsp;public synchronized void start() {\n    repository = repository + \"lib\" + File.separator;\n    urls[0] = new URL(null, repository, streamHandler);\n    classLoader = new CommonClassLoader(urls);\n}\n</code></pre><p>我们再来看WebappClassLoader，因为需要管理每一个应用，所以加载机制有所不同。</p><p>WebappLoader这里指定了一个应用的类加载目录。</p><pre><code class=\"language-java\">package com.minit.core;\npublic class WebappLoader implements Loader {\n    ClassLoader classLoader;\n    ClassLoader parent;\n    String path;\n    String docbase;\n    Container container;\n    public WebappLoader(String docbase) {\n        this.docbase = docbase;\n    }\n    public WebappLoader(String docbase, ClassLoader parent) {\n        this.docbase = docbase;\n        this.parent = parent;\n    }\n    public Container getContainer() {\n        return container;\n    }\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n    public String getPath() {\n        return path;\n    }\n    public void setPath(String path) {\n        this.path = path;\n    }\n    public String getDocbase() {\n        return docbase;\n    }\n    public void setDocbase(String docbase) {\n        this.docbase = docbase;\n    }\n\n    public ClassLoader getClassLoader() {\n        return classLoader;\n    }\n    public String getInfo() {\n        return \"A simple loader\";\n    }\n    public void addRepository(String repository) {\n    }\n    public String[] findRepositories() {\n        return null;\n    }\n    public synchronized void start() {\n        System.out.println(\"Starting WebappLoader\");\n        try {\n            // create a URLClassLoader\n            //加载目录是minit.base规定的根目录，加上应用目录，\n            //然后之下的WEB-INF/classes目录\n            //这意味着每一个应用有自己的类加载器，达到隔离的目的\n            URL[] urls = new URL[1];\n            URLStreamHandler streamHandler = null;\n            File classPath = new File(System.getProperty(\"minit.base\"));\n            String repository = (new URL(\"file\", null, classPath.getCanonicalPath() + File.separator)).toString();\n            if (docbase != null &amp;&amp; !docbase.equals(\"\")) {\n                repository = repository + docbase + File.separator;\n            }\n            repository = repository + \"WEB-INF\" + File.separator + \"classes\" + File.separator;\n            urls[0] = new URL(null, repository, streamHandler);\n            System.out.println(\"WEbapp classloader Repository : \" + repository);\n            classLoader = new WebappClassLoader(urls, parent);\n        } catch (Exception e) {\n            System.out.println(e.toString());\n        }\n    }\n    public void stop() {\n    }\n}\n</code></pre><p>可以看出WebappLoader是某个应用context的，它从应用的WEB-INF/classes下加载类。</p><pre><code class=\"language-java\">public synchronized void start() {\n    if (docbase!=null &amp;&amp; !docbase.equals(\"\")) {\n    repository = repository + docbase + File.separator;\n    }\n    repository = repository + \"WEB-INF\"+File.separator+\"classes\" + File.separator;\n    urls[0] = new URL(null, repository, streamHandler);\n    classLoader = new WebappClassLoader(urls,parent);\n}\n</code></pre><p>然后再来看看WebappClassLoader是如何加载类的。</p><pre><code class=\"language-java\">package com.minit.core;\npublic class WebappClassLoader extends URLClassLoader {\n    protected boolean delegate = false;\n    private ClassLoader parent = null;\n    private ClassLoader system = null;\n    public WebappClassLoader() {\n        super(new URL[0]);\n        this.parent = getParent();\n        system = getSystemClassLoader();\n    }\n    public WebappClassLoader(URL[] urls) {\n        super(urls);\n        this.parent = getParent();\n        system = getSystemClassLoader();\n    }\n    public WebappClassLoader(ClassLoader parent) {\n        super(new URL[0], parent);\n        this.parent = parent;\n        system = getSystemClassLoader();\n    }\n    public WebappClassLoader(URL[] urls, ClassLoader parent) {\n        super(urls, parent);\n        this.parent = parent;\n        system = getSystemClassLoader();\n    }\n    public boolean getDelegate() {\n        return (this.delegate);\n    }\n    public void setDelegate(boolean delegate) {\n        this.delegate = delegate;\n    }\n    public Class findClass(String name) throws ClassNotFoundException {\n        Class clazz = null;\n        try {\n            clazz = super.findClass(name);\n        } catch (RuntimeException e) {\n            throw e;\n        }\n        if (clazz == null) {\n            throw new ClassNotFoundException(name);\n        }\n        // Return the class we have located\n        return (clazz);\n    }\n    public Class loadClass(String name) throws ClassNotFoundException {\n        return (loadClass(name, false));\n    }\n    //核心方法，按照自定义的加载次序加载类\n    public Class&lt;?&gt; loadClass(String name, boolean resolve)\n            throws ClassNotFoundException {\n        Class&lt;?&gt; clazz = null;\n        try {\n            //首先是用系统类加载器加载类\n            clazz = system.loadClass(name);\n            if (clazz != null) {\n                if (resolve)\n                    resolveClass(clazz);\n                return (clazz);\n            }\n        } catch (ClassNotFoundException e) {\n        }\n        \n        boolean delegateLoad = delegate;\n        //到了这里，系统类加载器加载不成功，则判断是否为双亲委托模式，如果是，\n        //则用parent来加载器来加载\n        if (delegateLoad) {\n            ClassLoader loader = parent;\n            if (loader == null)\n                loader = system;\n            try {\n                clazz = loader.loadClass(name);\n                if (clazz != null) {\n                    if (resolve)\n                        resolveClass(clazz);\n                    return (clazz);\n                }\n            } catch (ClassNotFoundException e) {\n                ;\n            }\n        }\n        //到了这里，或者是父类加载器加载不成功，或者是不支持双亲委托模式，\n        //所以要自己去加载类\n        try {\n            clazz = findClass(name);\n            if (clazz != null) {\n                if (resolve)\n                    resolveClass(clazz);\n                return (clazz);\n            }\n        } catch (ClassNotFoundException e) {\n            ;\n        }\n        //到这里，自己加载不成功，则反过来交给父类加载器去加载\n        if (!delegateLoad) {\n            ClassLoader loader = parent;\n            if (loader == null)\n                loader = system;\n            try {\n                clazz = loader.loadClass(name);\n                if (clazz != null) {\n                    if (resolve)\n                        resolveClass(clazz);\n                    return (clazz);\n                }\n            } catch (ClassNotFoundException e) {\n                ;\n            }\n        }\n        throw new ClassNotFoundException(name);\n    }\n    private void log(String message) {\n        System.out.println(\"WebappClassLoader: \" + message);\n    }\n    private void log(String message, Throwable throwable) {\n        System.out.println(\"WebappClassLoader: \" + message);\n        throwable.printStackTrace(System.out);\n    }\n}\n</code></pre><p>我们再详细看看WebappClassLoader类的实现，由于这个类继承自URLClassLoader，所以findClass()没有变化，就是简单地使用父类URLClassLoader的findClass()。而构造方法记录了parent和system两个变量，这也是两个ClassLoader，parent是调用的时候传进来的，对于每一个应用context来说，classloader就是WebappClassLoader，而parent就是CommonClassLoader，system是Java内置提供的那些ClassLoader。</p><p>变化比较大的是loadClass()，你可以看一下实现代码。</p><pre><code class=\"language-java\">public Class&lt;?&gt; loadClass(String name, boolean resolve)\n        throws ClassNotFoundException {\n    Class&lt;?&gt; clazz = null;\n    try {\n        //先用系统类加载器进行加载\n        clazz = system.loadClass(name);\n        if (clazz != null) {\n            if (resolve)\n                resolveClass(clazz);\n            return (clazz);\n        }\n    } catch (ClassNotFoundException e) {\n    }\n    boolean delegateLoad = delegate;\n    //到这里，系统类加载器加载不成功，判断是不是双亲委托模式\n    //如果是，则用parent类加载器进行加载\n    if (delegateLoad) {\n        ClassLoader loader = parent;\n        if (loader == null)\n            loader = system;\n        try {\n            clazz = loader.loadClass(name);\n            if (clazz != null) {\n                if (resolve)\n                    resolveClass(clazz);\n                return (clazz);\n            }\n        } catch (ClassNotFoundException e) {\n            ;\n        }\n    }\n    //到这里，系统和父类加载器都加载不成功，则自己去加载\n    try {\n        clazz = findClass(name);\n        if (clazz != null) {\n            if (resolve)\n                resolveClass(clazz);\n            return (clazz);\n        }\n    } catch (ClassNotFoundException e) {\n        ;\n    }\n    //到这里，自己加载不成功，如果不是双亲委托模式，则交给父类去加载\n    if (!delegateLoad) {\n        ClassLoader loader = parent;\n        if (loader == null)\n            loader = system;\n        try {\n            clazz = loader.loadClass(name);\n            if (clazz != null) {\n                if (resolve)\n                    resolveClass(clazz);\n                return (clazz);\n            }\n        } catch (ClassNotFoundException e) {\n            ;\n        }\n    }\n    throw new ClassNotFoundException(name);\n</code></pre><p>在这段代码里，它是按照下面这个次序来加载类的。</p><ol>\n<li>尝试用系统的ClassLoader去加载某个类，防止覆盖Java自身的类。</li>\n<li>如果是delegate模式（Java类加载机制的标准模式），就由parent去加载这个类，随后再试着自己加载类。</li>\n<li>如果不是delegate模式，先自己加载类，失败了再用parent加载，如果parent为空，就用system加载。</li>\n</ol><p>通过这个次序我们可以看到，Java标准类加载机制已经被打破，我们自定义了一套加载规则，先尝试使用自身定义的类加载器，如果不生效再考虑使用双亲类加载器。</p><p>而目录结构在BootStrap启动类中通过MINIT_HOME和WEB_ROOT常量定义。所以根据上述定义，如果Minit的安装目录是f:\\minit，那么目录结构就是这样的。</p><pre><code class=\"language-plain\">f:\\minit\nf:\\minit\\lib&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\nf:\\minit\\webapps\nf:\\mimit\\webapps\\app1\nf:\\mimit\\webapps\\app2\nf:\\mimit\\webapps\\app1\\WEB-INF\\classes\n\nf:\\minit\\lib&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;由CommonClassLoader加载\nf:\\mimit\\webapps\\app1\\WEB-INF\\classes&nbsp; &nbsp; &nbsp; 由WebappClassLoader加载\n</code></pre><h2>调整服务器代码</h2><p>最后我们把BootStrap启动类调整一下。</p><pre><code class=\"language-java\">package com.minit.startup;\npublic class BootStrap {\n    public static final String MINIT_HOME = System.getProperty(\"user.dir\");\n    public static final String WEB_ROOT =\n            System.getProperty(\"user.dir\") + File.separator + \"webapps\";\n    public static final int PORT = 8080;\n    private static int debug = 0;\n    public static void main(String[] args) {\n        if (debug &gt;= 1)\n            log(\".... startup ....\");\n        System.setProperty(\"minit.home\", MINIT_HOME);\n        System.setProperty(\"minit.base\", WEB_ROOT);\n        HttpConnector connector = new HttpConnector();\n        StandardHost container = new StandardHost();\n        Loader loader = new CommonLoader();\n        container.setLoader(loader);\n        loader.start();\n        connector.setContainer(container);\n        container.setConnector(connector);\n        container.start();\n        connector.start();\n    }\n}\n</code></pre><p>程序里面使用的是StandardHost，Host代表了总容器，Minit启动的时候会启动Connector和Host。Host的类加载器就是刚才我们定义的CommonLoader。以后由request发invoke()的时候，都会从host开始了。</p><p>其实Host也是容器，只是在Context更上一层，而Context里的类加载器则使用的是WebappClassLoader，你可以参考StandardHost类里关于getContext方法的实现。</p><pre><code class=\"language-java\">public StandardContext getContext(String name){\n\t\tStandardContext context = contextMap.get(name);&nbsp;\n\t\tif ( context == null) {\n\t\t\tcontext = new StandardContext();\n\t&nbsp; &nbsp; &nbsp; &nbsp; context.setDocBase(name);\n\t&nbsp; &nbsp; &nbsp; &nbsp; context.setConnector(connector);\n\t&nbsp; &nbsp; &nbsp; &nbsp; Loader loader = new WebappLoader(name,this.loader.getClassLoader());\n\t&nbsp; &nbsp; &nbsp; &nbsp; context.setLoader(loader);\n\t&nbsp; &nbsp; &nbsp; &nbsp; loader.start();\n\t\t\t\n\t\t\tthis.contextMap.put(name, context);\n\t\t}\n\t\treturn context;\n\t}\n</code></pre><p>它内部有个Map数据结构保存了当前在用的context，如果没有找到，就创建一个，指定它用一个对应的WebappLoader。对应存在一个StandardHostValve，调用invoke方法后，就会执行getContext方法，拿到context再做后续工作。</p><p>最后，为了使代码保持一致，可以适当调整代码。一是将服务器启动端口统一在BootStrap中定义，HttpConnector类里涉及port变量的地方都使用BootStrap.PORT替换。二是为了和类加载器名称一致，原本/webroot目录改名为/webapps，并在应用下新增WEB-INF层级，都和上述类加载器里的代码定义保持一致。</p><h2>测试</h2><p>与以前一样，没有变化。我们所有的修改都是内部结构的修改。</p><h2>小结</h2><p>这节课我们进一步完善了MiniTomcat，在原有WebappClassLoader定义的基础上，新增Loader通用接口以及自定义ClassLoader，在加载时修改类的加载顺序，打破了双亲委托机制，进而我们可以进行自定义的类加载操作。</p><p>我们之所以要自己定义类加载次序，主要是因为MiniTomcat是一个支持多应用的服务器，应用之间要隔离，并且同一个类的不同版本还要可以同时运行在不同的应用中。这个需求就得通过自定义类加载器先加载自己能加载的类，然后再交给上层父加载器去加载，这个次序区别于标准的类加载模式，你要注意一下。</p><p>这节课代码参见：<a href=\"https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter15\">https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter15</a></p><h2>思考题</h2><p>学完了这节课的内容，我们来思考一个问题：如果MiniTomcat管理两个Web应用A和B，应用里面用到了同一个User类，但是是不同的版本，应用A里用的User类版本为1，应用B的User类版本为2，为什么采用双亲委托模式实现不了这个需求？</p><p>欢迎你把你想到的答案分享到评论区，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p>","comments":[{"had_liked":false,"id":386924,"user_name":"Geek_50a5cc","can_delete":false,"product_type":"c1","uid":1786951,"ip_address":"北京","ucode":"0F6C1C2552261F","user_header":"","comment_is_top":false,"comment_ctime":1705907172,"is_pvip":false,"replies":[{"id":141071,"content":"是的是的","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1705964991,"ip_address":"澳大利亚","comment_id":386924,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"双亲委托 是 将类的加载放到上一层处理，如果加载到，就不需要重复加载；所以遇到一个User类，不管是版本1，2，都会加载，不会再去处理其他的User类","like_count":2,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636334,"discussion_content":"是的是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705964991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386480,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1704932186,"is_pvip":false,"replies":[{"id":140994,"content":"Q1，loader是Tomcat自己的包装，classloader是Java的。MiniTomcat同样这么做的。\nQ2，common用于Tomcat的lib目录下的包，webappclassloader用于webapps目录下的应用\nQ3，system是指Java提供的加载器，包括app, ext和根\nQ4，一个类，修改一下，重新编译，就是一个新的版本了\nQ5，类本身的信息放在方法区的(现在叫Meta区)。这些也依赖于JVM本身的实现。\n","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1705447255,"ip_address":"澳大利亚","comment_id":386480,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"请教老师几个问题：\nQ1：CommonLoader与CommonClassLoader是什么关系？\nCommonClassLoader并没有继承CommonLoader。\nQ2：Tomcat只有Common加载器吗？\nMiniTomcat用Common加载器来加载服务器通用的类，用WebappClassLoader来加载应用的类。但是，文章中讲到的Tomcat的类加载图中，只有Common，并没有WebappClassLoader。\nQ3：System是扩展类加载器吗？\n文中几个关于类加载的图中，都有“System”这个措辞，它是指扩展类加载器吗？\nQ4：类的版本怎么体现？\n一个类有多个版本，怎么体现？通过类名字来体现？\nQ5：类被加载以后是放在方法区吗？\n比如，类Person，被加载以后会创建一个针对Person的对象，假设名字是A。那么，加载以后得类Person和A是被放在内存中的方法区吗？","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635991,"discussion_content":"Q1，loader是Tomcat自己的包装，classloader是Java的。MiniTomcat同样这么做的。\nQ2，common用于Tomcat的lib目录下的包，webappclassloader用于webapps目录下的应用\nQ3，system是指Java提供的加载器，包括app, ext和根\nQ4，一个类，修改一下，重新编译，就是一个新的版本了\nQ5，类本身的信息放在方法区的(现在叫Meta区)。这些也依赖于JVM本身的实现。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705447255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386602,"user_name":"HH🐷🐠","can_delete":false,"product_type":"c1","uid":1133678,"ip_address":"广东","ucode":"C50172BDA604D5","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/6e/5435e214.jpg","comment_is_top":false,"comment_ctime":1705204071,"is_pvip":false,"replies":[{"id":140973,"content":"可以指定delegate，没问题。不过我没注意查Tomcat这一部分源代码是怎么处理的。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1705401429,"ip_address":"澳大利亚","comment_id":386602,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"JVM 里一个类的唯一标识是 ClassLoader + 类名,  按照双亲委派模式都是由相同的 ClassLoader 去加载， 无疑会冲突。 老师， 还有一个问题， CommonClassLoader 是不是要指定一下 delegate，默认为 false","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635956,"discussion_content":"可以指定delegate，没问题。不过我没注意查Tomcat这一部分源代码是怎么处理的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705401429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386453,"user_name":"InfoQ_1f089af08bc8","can_delete":false,"product_type":"c1","uid":1696549,"ip_address":"北京","ucode":"47D4B6FDCFBE73","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIDhIpvB4hJnsn4utiatsHtTwriaSiaWXfMc0FyicBKB7Aibh0x5uxQ5TxMIl2ZhZp0G6jHUib9SPf3T76Q/132","comment_is_top":false,"comment_ctime":1704856531,"is_pvip":false,"replies":[{"id":140897,"content":"load是规定一个步骤策略，比如说第一步用system去找，第二步用ext加载器去找，规定了一个步骤。 find是根据位置按照字节码规范去加载这个类,然后用defineClass就把字节流变成了一个类。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1705024593,"ip_address":"澳大利亚","comment_id":386453,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"老师能否讲解一下类加载器的findClass(String name)和loadClass(String name)之间有什么关联吗？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635653,"discussion_content":"load是规定一个步骤策略，比如说第一步用system去找，第二步用ext加载器去找，规定了一个步骤。 find是根据位置按照字节码规范去加载这个类,然后用defineClass就把字节流变成了一个类。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705024593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386451,"user_name":"InfoQ_1f089af08bc8","can_delete":false,"product_type":"c1","uid":1696549,"ip_address":"北京","ucode":"47D4B6FDCFBE73","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIDhIpvB4hJnsn4utiatsHtTwriaSiaWXfMc0FyicBKB7Aibh0x5uxQ5TxMIl2ZhZp0G6jHUib9SPf3T76Q/132","comment_is_top":false,"comment_ctime":1704853339,"is_pvip":false,"replies":[{"id":140993,"content":"一个资源的定位用url表示，如何打开这个资源呢？通过某种协议，如http, https，或者file，这个handler就是来处理协议的。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1705446934,"ip_address":"澳大利亚","comment_id":386451,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"请问老师，URLStreamHandler 这个类的作用是干什么的？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635990,"discussion_content":"一个资源的定位用url表示，如何打开这个资源呢？通过某种协议，如http, https，或者file，这个handler就是来处理协议的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705446934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390878,"user_name":"天敌","can_delete":false,"product_type":"c1","uid":1059944,"ip_address":"四川","ucode":"CD29A622197197","user_header":"https://static001.geekbang.org/account/avatar/00/10/2c/68/c299bc71.jpg","comment_is_top":false,"comment_ctime":1716554210,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"CommonClassLoader 是否需要将 lib 目录下的所有jar文件读取到，转换成URL传入构造函数才能成功读取？","like_count":0}]}