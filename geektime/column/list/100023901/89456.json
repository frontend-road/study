{"id":89456,"title":"18 | StampedLock：有没有比读写锁更快的锁？","content":"<p>在<a href=\"https://time.geekbang.org/column/article/88909\">上一篇文章</a>中，我们介绍了读写锁，学习完之后你应该已经知道“读写锁允许多个线程同时读共享变量，适用于读多写少的场景”。那在读多写少的场景中，还有没有更快的技术方案呢？还真有，Java在1.8这个版本里，提供了一种叫StampedLock的锁，它的性能就比读写锁还要好。</p><p>下面我们就来介绍一下StampedLock的使用方法、内部工作原理以及在使用过程中需要注意的事项。</p><h2>StampedLock支持的三种锁模式</h2><p>我们先来看看在使用上StampedLock和上一篇文章讲的ReadWriteLock有哪些区别。</p><p>ReadWriteLock支持两种模式：一种是读锁，一种是写锁。而StampedLock支持三种模式，分别是：<strong>写锁</strong>、<strong>悲观读锁</strong>和<strong>乐观读</strong>。其中，写锁、悲观读锁的语义和ReadWriteLock的写锁、读锁的语义非常类似，允许多个线程同时获取悲观读锁，但是只允许一个线程获取写锁，写锁和悲观读锁是互斥的。不同的是：StampedLock里的写锁和悲观读锁加锁成功之后，都会返回一个stamp；然后解锁的时候，需要传入这个stamp。相关的示例代码如下。</p><pre><code>final StampedLock sl = \n  new StampedLock();\n  \n// 获取/释放悲观读锁示意代码\nlong stamp = sl.readLock();\ntry {\n  //省略业务相关代码\n} finally {\n  sl.unlockRead(stamp);\n}\n\n// 获取/释放写锁示意代码\nlong stamp = sl.writeLock();\ntry {\n  //省略业务相关代码\n} finally {\n  sl.unlockWrite(stamp);\n}\n</code></pre><p>StampedLock的性能之所以比ReadWriteLock还要好，其关键是StampedLock支持乐观读的方式。ReadWriteLock支持多个线程同时读，但是当多个线程同时读的时候，所有的写操作会被阻塞；而StampedLock提供的乐观读，是允许一个线程获取写锁的，也就是说不是所有的写操作都被阻塞。</p><!-- [[[read_end]]] --><p>注意这里，我们用的是“乐观读”这个词，而不是“乐观读锁”，是要提醒你，<strong>乐观读这个操作是无锁的</strong>，所以相比较ReadWriteLock的读锁，乐观读的性能更好一些。</p><p>文中下面这段代码是出自Java SDK官方示例，并略做了修改。在distanceFromOrigin()这个方法中，首先通过调用tryOptimisticRead()获取了一个stamp，这里的tryOptimisticRead()就是我们前面提到的乐观读。之后将共享变量x和y读入方法的局部变量中，不过需要注意的是，由于tryOptimisticRead()是无锁的，所以共享变量x和y读入方法局部变量时，x和y有可能被其他线程修改了。因此最后读完之后，还需要再次验证一下是否存在写操作，这个验证操作是通过调用validate(stamp)来实现的。</p><pre><code>class Point {\n  private int x, y;\n  final StampedLock sl = \n    new StampedLock();\n  //计算到原点的距离  \n  int distanceFromOrigin() {\n    // 乐观读\n    long stamp = \n      sl.tryOptimisticRead();\n    // 读入局部变量，\n    // 读的过程数据可能被修改\n    int curX = x, curY = y;\n    //判断执行读操作期间，\n    //是否存在写操作，如果存在，\n    //则sl.validate返回false\n    if (!sl.validate(stamp)){\n      // 升级为悲观读锁\n      stamp = sl.readLock();\n      try {\n        curX = x;\n        curY = y;\n      } finally {\n        //释放悲观读锁\n        sl.unlockRead(stamp);\n      }\n    }\n    return Math.sqrt(\n      curX * curX + curY * curY);\n  }\n}\n</code></pre><p>在上面这个代码示例中，如果执行乐观读操作的期间，存在写操作，会把乐观读升级为悲观读锁。这个做法挺合理的，否则你就需要在一个循环里反复执行乐观读，直到执行乐观读操作的期间没有写操作（只有这样才能保证x和y的正确性和一致性），而循环读会浪费大量的CPU。升级为悲观读锁，代码简练且不易出错，建议你在具体实践时也采用这样的方法。</p><h2>进一步理解乐观读</h2><p>如果你曾经用过数据库的乐观锁，可能会发现StampedLock的乐观读和数据库的乐观锁有异曲同工之妙。的确是这样的，就拿我个人来说，我是先接触的数据库里的乐观锁，然后才接触的StampedLock，我就觉得我前期数据库里乐观锁的学习对于后面理解StampedLock的乐观读有很大帮助，所以这里有必要再介绍一下数据库里的乐观锁。</p><p>还记得我第一次使用数据库乐观锁的场景是这样的：在ERP的生产模块里，会有多个人通过ERP系统提供的UI同时修改同一条生产订单，那如何保证生产订单数据是并发安全的呢？我采用的方案就是乐观锁。</p><p>乐观锁的实现很简单，在生产订单的表 product_doc 里增加了一个数值型版本号字段 version，每次更新product_doc这个表的时候，都将 version 字段加1。生产订单的UI在展示的时候，需要查询数据库，此时将这个 version 字段和其他业务字段一起返回给生产订单UI。假设用户查询的生产订单的id=777，那么SQL语句类似下面这样：</p><pre><code>select id，... ，version\nfrom product_doc\nwhere id=777\n</code></pre><p>用户在生产订单UI执行保存操作的时候，后台利用下面的SQL语句更新生产订单，此处我们假设该条生产订单的 version=9。</p><pre><code>update product_doc \nset version=version+1，...\nwhere id=777 and version=9\n</code></pre><p>如果这条SQL语句执行成功并且返回的条数等于1，那么说明从生产订单UI执行查询操作到执行保存操作期间，没有其他人修改过这条数据。因为如果这期间其他人修改过这条数据，那么版本号字段一定会大于9。</p><p>你会发现数据库里的乐观锁，查询的时候需要把 version 字段查出来，更新的时候要利用 version 字段做验证。这个 version 字段就类似于StampedLock里面的stamp。这样对比着看，相信你会更容易理解StampedLock里乐观读的用法。</p><h2>StampedLock使用注意事项</h2><p>对于读多写少的场景StampedLock性能很好，简单的应用场景基本上可以替代ReadWriteLock，但是<strong>StampedLock的功能仅仅是ReadWriteLock的子集</strong>，在使用的时候，还是有几个地方需要注意一下。</p><p>StampedLock在命名上并没有增加Reentrant，想必你已经猜测到StampedLock应该是不可重入的。事实上，的确是这样的，<strong>StampedLock不支持重入</strong>。这个是在使用中必须要特别注意的。</p><p>另外，StampedLock的悲观读锁、写锁都不支持条件变量，这个也需要你注意。</p><p>还有一点需要特别注意，那就是：如果线程阻塞在StampedLock的readLock()或者writeLock()上时，此时调用该阻塞线程的interrupt()方法，会导致CPU飙升。例如下面的代码中，线程T1获取写锁之后将自己阻塞，线程T2尝试获取悲观读锁，也会阻塞；如果此时调用线程T2的interrupt()方法来中断线程T2的话，你会发现线程T2所在CPU会飙升到100%。</p><pre><code>final StampedLock lock\n  = new StampedLock();\nThread T1 = new Thread(()-&gt;{\n  // 获取写锁\n  lock.writeLock();\n  // 永远阻塞在此处，不释放写锁\n  LockSupport.park();\n});\nT1.start();\n// 保证T1获取写锁\nThread.sleep(100);\nThread T2 = new Thread(()-&gt;\n  //阻塞在悲观读锁\n  lock.readLock()\n);\nT2.start();\n// 保证T2阻塞在读锁\nThread.sleep(100);\n//中断线程T2\n//会导致线程T2所在CPU飙升\nT2.interrupt();\nT2.join();\n</code></pre><p>所以，<strong>使用StampedLock一定不要调用中断操作，如果需要支持中断功能，一定使用可中断的悲观读锁readLockInterruptibly()和写锁writeLockInterruptibly()</strong>。这个规则一定要记清楚。</p><h2>总结</h2><p>StampedLock的使用看上去有点复杂，但是如果你能理解乐观锁背后的原理，使用起来还是比较流畅的。建议你认真揣摩Java的官方示例，这个示例基本上就是一个最佳实践。我们把Java官方示例精简后，形成下面的代码模板，建议你在实际工作中尽量按照这个模板来使用StampedLock。</p><p>StampedLock读模板：</p><pre><code>final StampedLock sl = \n  new StampedLock();\n\n// 乐观读\nlong stamp = \n  sl.tryOptimisticRead();\n// 读入方法局部变量\n......\n// 校验stamp\nif (!sl.validate(stamp)){\n  // 升级为悲观读锁\n  stamp = sl.readLock();\n  try {\n    // 读入方法局部变量\n    .....\n  } finally {\n    //释放悲观读锁\n    sl.unlockRead(stamp);\n  }\n}\n//使用方法局部变量执行业务操作\n......\n</code></pre><p>StampedLock写模板：</p><pre><code>long stamp = sl.writeLock();\ntry {\n  // 写共享变量\n  ......\n} finally {\n  sl.unlockWrite(stamp);\n}\n</code></pre><h2>课后思考</h2><p>StampedLock支持锁的降级（通过tryConvertToReadLock()方法实现）和升级（通过tryConvertToWriteLock()方法实现），但是建议你要慎重使用。下面的代码也源自Java的官方示例，我仅仅做了一点修改，隐藏了一个Bug，你来看看Bug出在哪里吧。</p><pre><code>private double x, y;\nfinal StampedLock sl = new StampedLock();\n// 存在问题的方法\nvoid moveIfAtOrigin(double newX, double newY){\n long stamp = sl.readLock();\n try {\n  while(x == 0.0 &amp;&amp; y == 0.0){\n    long ws = sl.tryConvertToWriteLock(stamp);\n    if (ws != 0L) {\n      x = newX;\n      y = newY;\n      break;\n    } else {\n      sl.unlockRead(stamp);\n      stamp = sl.writeLock();\n    }\n  }\n } finally {\n  sl.unlock(stamp);\n}\n</code></pre><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><p></p>","comments":[{"had_liked":false,"id":83972,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1554740962,"is_pvip":false,"replies":[{"id":"30307","content":"👍<br>","user_name":"作者回复","comment_id":83972,"uid":"1269969","ip_address":"","utype":1,"ctime":1554771048,"user_name_real":"王宝令"}],"discussion_count":5,"race_medal":0,"score":"418166568674","product_id":100023901,"comment_content":"课后思考题：在锁升级成功的时候，最后没有释放最新的写锁，可以在if块的break上加个stamp=ws进行释放","like_count":98,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446196,"discussion_content":"👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554771048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365751,"discussion_content":"有个疑问，进入到else里面是尝试升级锁失败，先释放读锁。再获取写锁是因为最后finally代码块中要释放锁吗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617875184,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2100403,"avatar":"https://static001.geekbang.org/account/avatar/00/20/0c/b3/7e13920b.jpg","nickname":"🎓Dream-seeker","note":"","ucode":"3C8477DE9DD766","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558236,"discussion_content":"防止其一直处于循环体","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648170459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":365751,"ip_address":""},"score":558236,"extra":""}]},{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365749,"discussion_content":"贴上源码\nvoid moveIfAtOrigin(double newX, double newY) { // upgrade\n  // Could instead start with optimistic, not read mode\n  long stamp = sl.readLock();\n  try {\n    while (x == 0.0 &amp;&amp; y == 0.0) {\n      long ws = sl.tryConvertToWriteLock(stamp);\n      if (ws != 0L) {\n        stamp = ws;\n        x = newX;\n        y = newY;\n        break;\n      }\n      else {\n        sl.unlockRead(stamp);\n        stamp = sl.writeLock();\n      }\n    }\n  } finally {\n    sl.unlock(stamp);\n  }\n}","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617874609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111870,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK2Az5uTh9ZGVA7yQCj1BXtXuicPRkvJicA97AoN9xX3bnPcUYglTMXJeZeoVbPQeJA7ICvQhR3KQ0w/132","nickname":"日不落帝国","note":"","ucode":"6A11ABBD8AC438","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6430,"discussion_content":"学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566896263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84174,"user_name":"胡桥","can_delete":false,"product_type":"c1","uid":1055874,"ip_address":"","ucode":"673C3207614010","user_header":"https://static001.geekbang.org/account/avatar/00/10/1c/82/74ab79df.jpg","comment_is_top":false,"comment_ctime":1554797866,"is_pvip":false,"replies":[{"id":"30394","content":"改了就改了，读的数据是正确的一致的就可以了。如果这个规则不满足业务需求，可以总互斥锁。不同的锁用不同地方。","user_name":"作者回复","comment_id":84174,"uid":"1269969","ip_address":"","utype":1,"ctime":1554820390,"user_name_real":"王宝令"}],"discussion_count":8,"race_medal":0,"score":"194828326186","product_id":100023901,"comment_content":"乐观锁的想法是“没事，肯定没被改过”，于是就开心地获取到数据，不放心吗？那就再验证一下，看看真的没被改过吧？这下可以放心使用数据了。<br>我的问题是，验证完之后、使用数据之前，数据被其他线程改了怎么办？我看不出validate的意义。这个和数据库更新好像还不一样，数据库是在写的时候发现已经被其他人写了。这里validate之后也难免数据在进行业务计算之前已经被改掉了啊？","like_count":45,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446268,"discussion_content":"改了就改了，读的数据是正确的一致的就可以了。如果这个规则不满足业务需求，可以总互斥锁。不同的锁用不同地方。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554820390,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1077931,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Wy62w9wUM6hLpx7wSw0M1SPoT6pKr07yPHOib56CvtzIQ96t7eZkG4UHQ2kgp9jzBJzfxB1mlP8ibosdqxVwicQUw/132","nickname":"三良","note":"","ucode":"1AAAAED847D85E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215701,"discussion_content":"在 distanceFromOrigin() 方法里，需要\n    step1.  先读到 x 和y 的值，\n    step2. 然后基于x 和 y 计算距离 sqrt(x*x+y*y);\n示例中，读到 x 和 y的值后（step1之后，step2之前），进行 sl.validate()，只是为了保证读到的 x, y 在step1读期间没有发生改变，并不保证在step2计算期间不发生改变，这也是作者回复的“改了就改了”。\n\n“保证在step1读期间没有发生改变”看似没意义，实际上step1读到的是两个值。\n如果在读期间发生改变的话，需要改变两个变量值，从(x1, y1) 变为 (x2, y2)。\n保证在step1读期间没有发生改变，能够保证返回的数据要么是 sqrt(x1*x1+y1*y1) 要么是 sqrt(x2*x2+y2*y2)，无非是新值or老值的情况，数据基于读数据的时刻本身是正确的\n如果不保证step1读期间没有发生改变，有可能返回 sqrt(x1*x1+y2*y2)，那返回的数据就是错误的数据。\n","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1585372884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1361746,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c7/52/c5adf218.jpg","nickname":"喜欢地球的阿培同学","note":"","ucode":"5F97037585F857","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":104156,"discussion_content":"这个乐观读的主要目的是数据读取过程中是否发生了变化，如果该数据还需要进行后面的赋值操作，那么肯定是无法保证原子性的，只能通过加锁或cas保证。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1577414983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1566569,"avatar":"https://static001.geekbang.org/account/avatar/00/17/e7/69/0c426b52.jpg","nickname":"刘易宁","note":"","ucode":"EE337683D08B9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":63787,"discussion_content":"我的理解是，读数据本身不是一个原子操作，在读数据的时候有数据被写入，数据的正确性就无法保证了。所以要加一个validate验证数据是不是在这个过程中写入，如果被写入，就加锁保证值数据的正确性","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1574910705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1247965,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg","nickname":"Geek_41d472","note":"","ucode":"DEC2B6329460CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288141,"discussion_content":"可以保证度的过程中数据没有被修改,读完后数据是可能会被其他线程修改,这是很正常的;和数据库的乐观锁确实有点点区别,数据库如果发现别认修改了,则需要从新获取最新的值;,而这里读完数据后,如果其他线程修改了数据,这里就不再从新获取最新的值进行相关业务操作了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1593660605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2154554,"avatar":"","nickname":"koby","note":"","ucode":"16F596A9A963DF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380567,"discussion_content":"用悲观读也是一样，悲观读完后，还没使用，然后有人来获取写锁，当然能获取到，然后改了。业务场景如果就是要求读写完全串行，就不要用读写锁","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1624584830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1493907,"avatar":"https://static001.geekbang.org/account/avatar/00/16/cb/93/4adea49a.jpg","nickname":"努力努力再努力","note":"","ucode":"0C6EEA28FCE8C7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2154554,"avatar":"","nickname":"koby","note":"","ucode":"16F596A9A963DF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581322,"discussion_content":"这肯定不一样，悲观读的过程中都获取不了写锁，无法修改吧。除非你读了数据，释放锁以后再处理，但那样用锁就没意义了，资源逸出临界区了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1658722801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":380567,"ip_address":""},"score":581322,"extra":""}]},{"author":{"id":1484192,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/a0/e0cccf7e.jpg","nickname":"圆圆满满","note":"","ucode":"396E7A822014D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292887,"discussion_content":"乐观锁能保证更新的串行化，但是不能保证读的串行化。业务场景要能接受就可以用。强一致的就加锁，也就牺牲了性能。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595378393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83979,"user_name":"Grubby🐑","can_delete":false,"product_type":"c1","uid":1181905,"ip_address":"","ucode":"26B9256226F919","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/d1/3c7747ef.jpg","comment_is_top":false,"comment_ctime":1554748319,"is_pvip":false,"replies":[{"id":"30306","content":"内部实现里while循环里面对中断的处理有点问题","user_name":"作者回复","comment_id":83979,"uid":"1269969","ip_address":"","utype":1,"ctime":1554771033,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"164763505567","product_id":100023901,"comment_content":"老师，调用interrupt引起cpu飙高的原因是什么","like_count":39,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446199,"discussion_content":"内部实现里while循环里面对中断的处理有点问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554771033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84112,"user_name":"Presley","can_delete":false,"product_type":"c1","uid":1215219,"ip_address":"","ucode":"D8F125835F4903","user_header":"https://static001.geekbang.org/account/avatar/00/12/8a/f3/7c89d00e.jpg","comment_is_top":false,"comment_ctime":1554786884,"is_pvip":false,"replies":[{"id":"30487","content":"两种场景，如果处理业务需要保持互斥，那么就用互斥锁，如果不需要保持互斥才可以用读写锁。一般来讲缓存是不需要保持互斥性的，能接受瞬间的不一致<br>","user_name":"作者回复","comment_id":84112,"uid":"1269969","ip_address":"","utype":1,"ctime":1554945102,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"126108838468","product_id":100023901,"comment_content":"老师，StampedLock 读模板，先通过乐观读或者悲观读锁获取变量，然后利用这些变量处理业务逻辑，会不会存在线程安全的情况呢? 比如，读出来的变量没问题，但是进行业务逻辑处理的时候，这时，读出的变量有可能发生变化了吧(比如被写锁改写了)？所以，当使用乐观读锁时，是不是等业务都处理完了（比如先利用变量把距离计算完），再判断变量是否被改写，如果没改写，直接return;如果已经改写，则使用悲观读锁做同样的事情。不过如果业务比较耗时，可能持有悲观锁的时间会比较长，不知道理解对不对","like_count":29,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446256,"discussion_content":"两种场景，如果处理业务需要保持互斥，那么就用互斥锁，如果不需要保持互斥才可以用读写锁。一般来讲缓存是不需要保持互斥性的，能接受瞬间的不一致\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554945102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83980,"user_name":"Grubby🐑","can_delete":false,"product_type":"c1","uid":1181905,"ip_address":"","ucode":"26B9256226F919","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/d1/3c7747ef.jpg","comment_is_top":false,"comment_ctime":1554748516,"is_pvip":false,"replies":[{"id":"30308","content":"👍<br>","user_name":"作者回复","comment_id":83980,"uid":"1269969","ip_address":"","utype":1,"ctime":1554771058,"user_name_real":"王宝令"}],"discussion_count":2,"race_medal":0,"score":"87454094436","product_id":100023901,"comment_content":"bug是tryConvertToWriteLock返回的write stamp没有重新赋值给stamp","like_count":20,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446200,"discussion_content":"👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554771058,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111870,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK2Az5uTh9ZGVA7yQCj1BXtXuicPRkvJicA97AoN9xX3bnPcUYglTMXJeZeoVbPQeJA7ICvQhR3KQ0w/132","nickname":"日不落帝国","note":"","ucode":"6A11ABBD8AC438","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6431,"discussion_content":"学习学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566896394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85905,"user_name":"发条橙子 。","can_delete":false,"product_type":"c1","uid":1259218,"ip_address":"","ucode":"ED076F4534FFED","user_header":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","comment_is_top":false,"comment_ctime":1555290639,"is_pvip":false,"replies":[{"id":"30901","content":"使用final是个好习惯","user_name":"作者回复","comment_id":85905,"uid":"1269969","ip_address":"","utype":1,"ctime":1555300273,"user_name_real":"王宝令"}],"discussion_count":2,"race_medal":0,"score":"61684832783","product_id":100023901,"comment_content":"老师 ， 我看事例里面成员变量都给了一个 final 关键字 。 请问这里给变量加 final的用意是什么 ，仅仅是为了防止下面方法中代码给他赋新的对象么 。 我在平常写代码中很少有给变量加 final 的习惯， 希望老师能指点一下 😄","like_count":14,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446861,"discussion_content":"使用final是个好习惯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555300273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1662994,"avatar":"https://static001.geekbang.org/account/avatar/00/19/60/12/d99027df.jpg","nickname":"Zhi","note":"","ucode":"47DB818B2FDF86","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":19535,"discussion_content":"之前的文章中，老师特地说过final的作用吧，是为了告诉编译器这个变量不会发生变化，可以通过指令重排序使劲优化。  在java内存模型那章下半部分提到的","likes_number":16,"is_delete":false,"is_hidden":false,"ctime":1569205250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84021,"user_name":"echo＿陈","can_delete":false,"product_type":"c1","uid":1080794,"ip_address":"","ucode":"EFAEADA8A05906","user_header":"https://static001.geekbang.org/account/avatar/00/10/7d/da/780f149e.jpg","comment_is_top":false,"comment_ctime":1554770331,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35914508699","product_id":100023901,"comment_content":"以前看过java并发编程实战，讲jdk并发类库……不过那个书籍是jdk1.7版本……所以是头一次接触StempLock……涨知识了","like_count":8},{"had_liked":false,"id":93889,"user_name":"南北少卿","can_delete":false,"product_type":"c1","uid":1018958,"ip_address":"","ucode":"DFCC59F2BBD8CE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/4e/b81969fa.jpg","comment_is_top":false,"comment_ctime":1557653479,"is_pvip":false,"replies":[{"id":"33667","content":"👍","user_name":"作者回复","comment_id":93889,"uid":"1269969","ip_address":"","utype":1,"ctime":1557757307,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"31622424551","product_id":100023901,"comment_content":"jdk源码StampedLock中的示例，if (ws != 0L) 时使用了stamp=ws","like_count":7,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449811,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557757307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85516,"user_name":"ban","can_delete":false,"product_type":"c1","uid":1034204,"ip_address":"","ucode":"E523CE97E48266","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/dc/9408c8c2.jpg","comment_is_top":false,"comment_ctime":1555092083,"is_pvip":false,"replies":[{"id":"30844","content":"stamp和ws没关系，tryConvertToWriteLock(stamp)这个方法内部会释放悲观读锁stamp（条件是能够升级成功）。所以我们需要释放的是ws","user_name":"作者回复","comment_id":85516,"uid":"1269969","ip_address":"","utype":1,"ctime":1555241304,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"31619863155","product_id":100023901,"comment_content":"老师，你好，<br>如果我在前面long stamp = sl.readLock();升级锁后long ws = sl.tryConvertToWriteLock(stamp);<br>这个 stamp和ws是什么关系来的，是sl.unlockRead(是关stamp还是ws)。两者有什么区别呢","like_count":7,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446692,"discussion_content":"stamp和ws没关系，tryConvertToWriteLock(stamp)这个方法内部会释放悲观读锁stamp（条件是能够升级成功）。所以我们需要释放的是ws","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555241304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":228088,"user_name":"南北少卿","can_delete":false,"product_type":"c1","uid":1018958,"ip_address":"","ucode":"DFCC59F2BBD8CE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/4e/b81969fa.jpg","comment_is_top":false,"comment_ctime":1592552015,"is_pvip":false,"replies":[{"id":"84699","content":"这里类比很生动😄","user_name":"作者回复","comment_id":228088,"uid":"1269969","ip_address":"","utype":1,"ctime":1593003351,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"18772421199","product_id":100023901,"comment_content":"这个获取锁返回的stamp,可以理解成上锁后的钥匙吗?","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498916,"discussion_content":"这里类比很生动😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593003351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188270,"user_name":"厉害了我的国","can_delete":false,"product_type":"c1","uid":1052191,"ip_address":"","ucode":"CD0A54A1B998AA","user_header":"https://static001.geekbang.org/account/avatar/00/10/0e/1f/d0472177.jpg","comment_is_top":false,"comment_ctime":1584333494,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18764202678","product_id":100023901,"comment_content":"分布式场景下，java的锁还有用武之地吗？感觉就是玩具啊。。","like_count":4,"discussions":[{"author":{"id":1441448,"avatar":"https://static001.geekbang.org/account/avatar/00/15/fe/a8/0a202d2f.jpg","nickname":"Vincent","note":"","ucode":"0C0C3DF59FA61A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298671,"discussion_content":"难不成所有的集群都是单核？","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1597375023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103768,"user_name":"楊_宵夜","can_delete":false,"product_type":"c1","uid":1019302,"ip_address":"","ucode":"7BA0CADC5F23BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/a6/22c37c91.jpg","comment_is_top":false,"comment_ctime":1560506575,"is_pvip":false,"replies":[{"id":"37541","content":"是的","user_name":"作者回复","comment_id":103768,"uid":"1269969","ip_address":"","utype":1,"ctime":1560511833,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"18740375759","product_id":100023901,"comment_content":"王老师, 您好, 文章中的StampedLock模板, 只适用于单机应用吧? 如果是集群部署, 那还是得用数据库乐观锁, 是吗??","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453994,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560511833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84724,"user_name":"ttang","can_delete":false,"product_type":"c1","uid":1310486,"ip_address":"","ucode":"15EF6544A64994","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoVRER40LhyAmwlCqszX6s02Ix04Yztia9UIFrcm3JV9gHmbswvffqCW0KentRGVrPJuibyzJlpcW5g/132","comment_is_top":false,"comment_ctime":1554899002,"is_pvip":false,"replies":[{"id":"30455","content":"乐观读升级到悲观读，就和ReadWriteLock一样了。","user_name":"作者回复","comment_id":84724,"uid":"1269969","ip_address":"","utype":1,"ctime":1554903998,"user_name_real":"王宝令"}],"discussion_count":3,"race_medal":0,"score":"18734768186","product_id":100023901,"comment_content":"老师，ReadWriteLock锁和StampedLock锁都是可以同时读的，区别是StampedLock乐观读不加锁。那StampedLock比ReadWriteLock性能高的原因就是节省了加读锁的性能损耗吗？另外StampedLock用乐观读的时候是允许一个线程获取写锁的，是不是可以理解为StampedLock对写的性能更高，会不会因为写锁获取概率增大大，导致不能获取读锁。导致StampedLock读性能反而没有ReadWriteLock高？","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446430,"discussion_content":"乐观读升级到悲观读，就和ReadWriteLock一样了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554903998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1077931,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Wy62w9wUM6hLpx7wSw0M1SPoT6pKr07yPHOib56CvtzIQ96t7eZkG4UHQ2kgp9jzBJzfxB1mlP8ibosdqxVwicQUw/132","nickname":"三良","note":"","ucode":"1AAAAED847D85E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215708,"discussion_content":"性能看概率，也就是 读操作 和 写操作 冲突的概率。\nStampedLock在 乐观读 的场景是没有加锁的，需要自己通过validate()进行判断，单独的乐观读操作 开销 肯定 小于 ReadWriteLock的ReadLock。\n如果validate()失败，需要升级成 悲观读锁，单独的悲观读锁 的开销 和 ReadWriteLock的ReadLock一致。但是 先乐观读 失败再 加悲观读锁，第一次的乐观读就是多出来的开销。\n写概率大的场景，也就不该使用乐观锁了。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1585373716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1855137,"avatar":"","nickname":"Geek_e6f358","note":"","ucode":"C21E94A90258A2","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1077931,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Wy62w9wUM6hLpx7wSw0M1SPoT6pKr07yPHOib56CvtzIQ96t7eZkG4UHQ2kgp9jzBJzfxB1mlP8ibosdqxVwicQUw/132","nickname":"三良","note":"","ucode":"1AAAAED847D85E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385400,"discussion_content":"加悲观锁之后，也是有区别吧。悲观读时，有写线程进来，写线程阻塞等待悲观读释放读锁。写线程之后进来的读线程会在乐观读之后继续执行，而readWriteLock中读线程会阻塞，直到写线程释放写锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627028156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":215708,"ip_address":""},"score":385400,"extra":""}]}]},{"had_liked":false,"id":84031,"user_name":"冯传博","can_delete":false,"product_type":"c1","uid":1177787,"ip_address":"","ucode":"91B9A1EF0FF042","user_header":"https://static001.geekbang.org/account/avatar/00/11/f8/bb/8b2ba45d.jpg","comment_is_top":false,"comment_ctime":1554771501,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18734640685","product_id":100023901,"comment_content":"解释一下 cpu 飙升的原因呗","like_count":4,"discussions":[{"author":{"id":1687656,"avatar":"https://static001.geekbang.org/account/avatar/00/19/c0/68/314e8306.jpg","nickname":"威先森","note":"","ucode":"5F445C6832274B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363571,"discussion_content":"在while里面处理中断的代码有问题，上面看老师是这么回答的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617239238,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84020,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1554770307,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18734639491","product_id":100023901,"comment_content":"悲观锁和乐观锁。悲观锁，就是普通的锁。乐观锁，就是无锁，仅增加一个版本号，在取完数据验证一下版本号。如果不一致那么就进行悲观锁获取锁。能够这么理解吗？","like_count":4},{"had_liked":false,"id":85697,"user_name":"张洋","can_delete":false,"product_type":"c1","uid":1182914,"ip_address":"","ucode":"549BE5DEEF8417","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/c2/bad34a50.jpg","comment_is_top":false,"comment_ctime":1555204535,"is_pvip":true,"replies":[{"id":"30814","content":"如果用redis，就完全依赖redis，本地不能有缓存，有缓存就可能数据不一致。不清楚你有没有用本地缓存。redis做秒杀有很多成熟的方案，好像都没法用乐观读。","user_name":"作者回复","comment_id":85697,"uid":"1269969","ip_address":"","utype":1,"ctime":1555209280,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"14440106423","product_id":100023901,"comment_content":"王老师还有一个问题，最近做一些关于秒杀的业务，是不是可以用到乐观读的性质。<br>将库存量放在redis里边，然后所有的节点操作的时候通过缓存读出来，在代码逻辑里边对库存加一个<br>乐观读的操作。然后库存量等于0 的时候再去和数据库进行交互。  这样做会存在并发安全问题吗。","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446770,"discussion_content":"如果用redis，就完全依赖redis，本地不能有缓存，有缓存就可能数据不一致。不清楚你有没有用本地缓存。redis做秒杀有很多成熟的方案，好像都没法用乐观读。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555209280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84869,"user_name":"on the way","can_delete":false,"product_type":"c1","uid":1323807,"ip_address":"","ucode":"77B29D60168D7F","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/1f/35b68f47.jpg","comment_is_top":false,"comment_ctime":1554941939,"is_pvip":false,"replies":[{"id":"30663","content":"就是等一会儿，保证前面的子线程已经启动包<br>","user_name":"作者回复","comment_id":84869,"uid":"1269969","ip_address":"","utype":1,"ctime":1555118701,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"14439843827","product_id":100023901,"comment_content":"有点没看明白示例interrupt那个代码里的 Thread.sleep（100）…","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446477,"discussion_content":"就是等一会儿，保证前面的子线程已经启动包\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555118701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163927,"user_name":"走马","can_delete":false,"product_type":"c1","uid":1251016,"ip_address":"","ucode":"EEFE8F7590FFA4","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/c8/980776fc.jpg","comment_is_top":false,"comment_ctime":1576829161,"is_pvip":false,"replies":[{"id":"62400","content":"这个我回答不了😂","user_name":"作者回复","comment_id":163927,"uid":"1269969","ip_address":"","utype":1,"ctime":1576909756,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"10166763753","product_id":100023901,"comment_content":"您好，老师，我一直有个疑惑， 类似ERP的系统，它的程序代码本身没做并发处理，但是卖的时候会和客户说不同并发价格不一样，它是怎么做到的 ？ 是由一个独立的软件来处理并发吗？","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478584,"discussion_content":"这个我回答不了😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576909756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139055,"user_name":"景梦园","can_delete":false,"product_type":"c1","uid":1620479,"ip_address":"","ucode":"0A17708457ACB2","user_header":"https://static001.geekbang.org/account/avatar/00/18/b9/ff/ea6c2e86.jpg","comment_is_top":false,"comment_ctime":1570536811,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10160471403","product_id":100023901,"comment_content":"tryConvertToWriteLock<br>public long tryConvertToWriteLock(long stamp)<br>If the lock state matches the given stamp, performs one of the following actions. If the stamp represents holding a write lock, returns it. Or, if a read lock, if the write lock is available, releases the read lock and returns a write stamp. Or, if an optimistic read, returns a write stamp only if immediately available. This method returns zero in all other cases.<br>Parameters:<br>stamp - a stamp<br>Returns:<br>a valid write stamp, or zero on failure","like_count":2},{"had_liked":false,"id":290340,"user_name":"夕阳武士","can_delete":false,"product_type":"c1","uid":1480522,"ip_address":"","ucode":"DDCF11F69CDAB5","user_header":"https://static001.geekbang.org/account/avatar/00/16/97/4a/0da51831.jpg","comment_is_top":false,"comment_ctime":1619509295,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5914476591","product_id":100023901,"comment_content":"int getAnd() {<br>        long stamp = stampedLock.tryOptimisticRead();<br>        System.out.println(Thread.currentThread().getName() + &quot;,乐观读：x: &quot; + x + &quot;,y: &quot; + y);<br>        if (!stampedLock.validate(stamp)) {<br>            stamp = stampedLock.readLock();<br>            try {<br>                System.out.println(Thread.currentThread().getName() + &quot;,悲观读锁：x: &quot; + x + &quot;,y: &quot; + y);<br>            } catch (Exception e) {<br>                e.printStackTrace();<br>            } finally {<br>                stampedLock.unlock(stamp);<br>            }<br>        }<br>        return x + y;<br>    }<br><br>    void set(int x, int y) {<br>        long stamp = stampedLock.writeLock();<br>        try {<br>            this.x = x;<br>            this.y = y;<br>            System.out.println(&quot;写锁开始赋值。。。。。&quot;);<br>        } catch (Exception e) {<br>            e.printStackTrace();<br>        } finally {<br>            stampedLock.unlock(stamp);<br>        }<br>    }<br><br>运行结果：<br>Thread-9927,乐观读：x: 0,y: 0<br>Thread-9920,乐观读：x: 0,y: 0<br>Thread-9923,乐观读：x: 0,y: 0<br>Thread-9902,乐观读：x: 0,y: 0<br>写锁开始赋值。。。。。<br>Thread-9996,乐观读：x: 22,y: 33<br>Thread-9993,乐观读：x: 22,y: 33<br>Thread-9994,乐观读：x: 22,y: 33<br>Thread-9990,乐观读：x: 22,y: 33<br>Thread-9997,乐观读：x: 0,y: 0<br>Thread-9899,乐观读：x: 0,y: 0<br>Thread-9987,乐观读：x: 22,y: 33<br>Thread-9997,悲观读锁：x: 22,y: 33<br>Thread-9986,乐观读：x: 22,y: 33<br>Thread-9992,乐观读：x: 22,y: 33<br>Thread-9891,乐观读：x: 22,y: 33<br>Thread-9899,悲观读锁：x: 22,y: 33<br>Thread-9983,乐观读：x: 22,y: 33<br><br>写个demo验证一下，从Thread-9997这个线程的改变，可以看出升级锁的过程。","like_count":2},{"had_liked":false,"id":276077,"user_name":"成电帅才","can_delete":false,"product_type":"c1","uid":2139604,"ip_address":"","ucode":"DDE757138F41D2","user_header":"","comment_is_top":false,"comment_ctime":1611766045,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5906733341","product_id":100023901,"comment_content":"线程阻塞在 StampedLock 的 readLock() 或者 writeLock() 上，这里的阻塞不会对应阻塞队列或者同步队列么？","like_count":1},{"had_liked":false,"id":260378,"user_name":"xzy","can_delete":false,"product_type":"c1","uid":1002095,"ip_address":"","ucode":"1A44368083A19E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","comment_is_top":false,"comment_ctime":1604994705,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5899962001","product_id":100023901,"comment_content":" ReadWriteLock VS StampedLock<br>- 都适用于读多写少的场景，StampedLock的乐观锁机制，性能比ReadWriteLock好<br>- StampedLock 的悲观读锁、写锁都不支持条件变量<br>- StampedLock中断操作会造成cpu100%","like_count":1},{"had_liked":false,"id":253886,"user_name":"HDJ","can_delete":false,"product_type":"c1","uid":1721981,"ip_address":"","ucode":"07089ED8097D2F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/cc0hNnM5FAIianMn14icicKYviabHDebISCtD8LJXnnZf51jjCXsw49qstulXloS6dVibYRc8ANJ5OjcwnGvUCg9rkA/132","comment_is_top":false,"comment_ctime":1602933247,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5897900543","product_id":100023901,"comment_content":"StampedLock 源码详解可以结合 这篇博文一起阅读 : https:&#47;&#47;segmentfault.com&#47;a&#47;1190000015808032?utm_source=tag-newest","like_count":1},{"had_liked":false,"id":174929,"user_name":"yalio","can_delete":false,"product_type":"c1","uid":1131862,"ip_address":"","ucode":"FAB63813E4533A","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/56/60ee7623.jpg","comment_is_top":false,"comment_ctime":1580462873,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5875430169","product_id":100023901,"comment_content":"例子中获取x,y共享变量的值时，怎么保证是读取的最新的值呢，如果是当前线程的缓存值怎么办","like_count":1,"discussions":[{"author":{"id":2697700,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/LFJZ4x47rvShGhsePLIxc8EzdlBxAmVAIjJ2FQZ4NEpo8E4JCZQEOb2NIfOuiaQLL6Otkt7W3Rmu6Tv3AkgYdRA/132","nickname":"键盘上的魔术","note":"","ucode":"A731D721FB8D3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558277,"discussion_content":"老师之前讲reentrantLock时有提到，源码里有个volatile的state字段，通过它保证可见性。其它的lock都有这么个字段","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648188038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1077931,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Wy62w9wUM6hLpx7wSw0M1SPoT6pKr07yPHOib56CvtzIQ96t7eZkG4UHQ2kgp9jzBJzfxB1mlP8ibosdqxVwicQUw/132","nickname":"三良","note":"","ucode":"1AAAAED847D85E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215723,"discussion_content":"StampedLock的实现里有一个内部字段 `volatile long state;`\n写锁会通过Unsafe.cas()修改该字段，悲观读锁和乐观读都会获取该字段的值（当然悲观读锁会修改该字段，但是乐观读不会修改该字段），基于Java内存模型里的Happens-Before规则，会保证可见性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585375491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122403,"user_name":"绅士","can_delete":false,"product_type":"c1","uid":1583859,"ip_address":"","ucode":"5B58E5A958F489","user_header":"https://static001.geekbang.org/account/avatar/00/18/2a/f3/b9607a15.jpg","comment_is_top":false,"comment_ctime":1565359108,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5860326404","product_id":100023901,"comment_content":"老师，思考题，首先读锁已经升级为写锁了，然后写锁释放，那最后读锁还需要释放吗？这里不太明白，不应该不需要释放的吗","like_count":1,"discussions":[{"author":{"id":1606288,"avatar":"https://static001.geekbang.org/account/avatar/00/18/82/90/295449c4.jpg","nickname":"半生瓜。","note":"","ucode":"6D4CC445230D19","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5089,"discussion_content":"老师说读锁和写锁是互斥的，那就说明升级为写锁后读锁已经被释放。然后再用写锁加锁，所以后面释放写锁就可以了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565937723,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2697700,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/LFJZ4x47rvShGhsePLIxc8EzdlBxAmVAIjJ2FQZ4NEpo8E4JCZQEOb2NIfOuiaQLL6Otkt7W3Rmu6Tv3AkgYdRA/132","nickname":"键盘上的魔术","note":"","ucode":"A731D721FB8D3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558278,"discussion_content":"看一下tryConvertToWriteLock方法上面的注释，有一句：Or, if a read lock, if the write lock is available, releases the read lock and returns a write stamp.  如果原来是悲观读锁，需要升级成写锁，会释放读锁，并且返回读锁的stamp（新值，即ws）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648188267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114725,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1563370922,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5858338218","product_id":100023901,"comment_content":"老师， if (ws != 0L)这个是判断是什么的？","like_count":1,"discussions":[{"author":{"id":2028938,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f5/8a/dc9a23a1.jpg","nickname":"续费专用","note":"","ucode":"1B585A131B64B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290794,"discussion_content":"判断是否加锁成功","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594606951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114716,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1563369213,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5858336509","product_id":100023901,"comment_content":"老师，您计算距离的代码中是不是类型要转换下？return (int) Math.sqrt(curX * curX + curY * curY);","like_count":1},{"had_liked":false,"id":103977,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1560580206,"is_pvip":false,"replies":[{"id":"37618","content":"👍，有空我也学习一下😄","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1560591652,"ip_address":"","comment_id":103977,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5855547502","product_id":100023901,"comment_content":"从头重新看一篇，也自己大致写了下对StampedLock的源码分析https:&#47;&#47;juejin.im&#47;editor&#47;posts&#47;5d00a6c8e51d45105d63a4ed，老师有空帮忙看下哦","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454078,"discussion_content":"👍，有空我也学习一下😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560591652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91691,"user_name":"狂风骤雨","can_delete":false,"product_type":"c1","uid":1305749,"ip_address":"","ucode":"5CE9B9438FAB3F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKZSibeTatZ2ImL5Xu3QqdTWQs5nyQAxDlsm3m0KicP3TN6icJqYricvhjOFfTB2B3oLInU45CC9LtqMA/132","comment_is_top":false,"comment_ctime":1557073871,"is_pvip":false,"replies":[{"id":"34453","content":"读写是互斥的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558362024,"ip_address":"","comment_id":91691,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5852041167","product_id":100023901,"comment_content":"老师，你上章讲的ReadWriteLock，说的是当有一个线程在执行写操作时所有的读线程都被阻塞，本章你又提了一下ReadWriteLock，说的是当有多个线程进行读操作时，所有的写操作都被阻塞，这样是","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448994,"discussion_content":"读写是互斥的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558362024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84439,"user_name":"胡桥","can_delete":false,"product_type":"c1","uid":1055874,"ip_address":"","ucode":"673C3207614010","user_header":"https://static001.geekbang.org/account/avatar/00/10/1c/82/74ab79df.jpg","comment_is_top":false,"comment_ctime":1554863439,"is_pvip":false,"replies":[{"id":"30429","content":"没法保证两个变量的一致性<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554869548,"ip_address":"","comment_id":84439,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5849830735","product_id":100023901,"comment_content":"validate也无法保证一致性是吗？如果是那么应该怎么用validate？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446361,"discussion_content":"没法保证两个变量的一致性\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554869548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351944,"user_name":"FARO_Z","can_delete":false,"product_type":"c1","uid":2410092,"ip_address":"","ucode":"B33BCC36C2A74E","user_header":"https://static001.geekbang.org/account/avatar/00/24/c6/6c/a400175a.jpg","comment_is_top":false,"comment_ctime":1658304713,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658304713","product_id":100023901,"comment_content":"乐观读升级为悲观读，是为了保证读 &quot;取多个成员变量的值&quot; 这个操作是原子的，即不希望读取到修改的中间值。<br><br>那如果只有一个成员变量被读取和修改，这个锁升级的操作还有必要吗？","like_count":0},{"had_liked":false,"id":339538,"user_name":"键盘上的魔术","can_delete":false,"product_type":"c1","uid":2697700,"ip_address":"","ucode":"A731D721FB8D3A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/LFJZ4x47rvShGhsePLIxc8EzdlBxAmVAIjJ2FQZ4NEpo8E4JCZQEOb2NIfOuiaQLL6Otkt7W3Rmu6Tv3AkgYdRA/132","comment_is_top":false,"comment_ctime":1648176617,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648176617","product_id":100023901,"comment_content":"&quot;因此最后读完之后，还需要再次验证一下是否存在写操作，这个验证操作是通过调用 validate(stamp) 来实现的。&quot;<br><br>这里的&quot;是否存在写操作&quot;，是不是应该改成&quot;是否有其它线程获得过写锁&quot;。 毕竟从实现角度讲， 写操作很难感知到， 获得过写锁则可以感知到的吧。 也就是说如果另一个线程不获得写锁，就直接写共享变量，这个validate方法感知不到的吧<br><br>","like_count":0},{"had_liked":false,"id":312061,"user_name":"到道可道","can_delete":false,"product_type":"c1","uid":1031181,"ip_address":"","ucode":"12B94B6C26BE0D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bc/0d/00424e81.jpg","comment_is_top":false,"comment_ctime":1631610787,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1631610787","product_id":100023901,"comment_content":"StampedLock是以加锁时返回的long型stamp，来进行解锁的；代码中进行写锁升级时，采用了新的变量ws来存储锁升级后的返回值，但代码中没有针对升级后的写锁的解锁代码。","like_count":0},{"had_liked":false,"id":303852,"user_name":"Geek_e6f358","can_delete":false,"product_type":"c1","uid":1855137,"ip_address":"","ucode":"C21E94A90258A2","user_header":"","comment_is_top":false,"comment_ctime":1627028395,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1627028395","product_id":100023901,"comment_content":"不要在我的临界区改数，你要敢改，我就加锁不让你再改，直到我读完","like_count":0},{"had_liked":false,"id":285759,"user_name":"Laughing","can_delete":false,"product_type":"c1","uid":1002134,"ip_address":"","ucode":"F68F1E000CA800","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/96/99466a06.jpg","comment_is_top":false,"comment_ctime":1617004311,"is_pvip":false,"replies":[{"id":"103700","content":"👍🏻","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1617020190,"ip_address":"","comment_id":285759,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1617004311","product_id":100023901,"comment_content":"课后题的代码就是官方的实例，这里在成功升锁之后没有把得到的写锁ws赋值给`stamp`变量，这样最后解锁时会报IllegalMonitorStateException的异常。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517772,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617020190,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":280150,"user_name":"ben harden","can_delete":false,"product_type":"c1","uid":1512500,"ip_address":"","ucode":"6F1AAD00DA1B1B","user_header":"https://static001.geekbang.org/account/avatar/00/17/14/34/6e58aebe.jpg","comment_is_top":false,"comment_ctime":1614094390,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614094390","product_id":100023901,"comment_content":"乐观读返回的stamp，在有修改的的时候（这个时候会有写锁吗？，如果有这个写锁的stamp和乐观读stamp有关系吗？）","like_count":0},{"had_liked":false,"id":272202,"user_name":"白杨","can_delete":false,"product_type":"c1","uid":1743868,"ip_address":"","ucode":"B56DD94706F80B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9b/fc/a3abbe53.jpg","comment_is_top":false,"comment_ctime":1609987872,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609987872","product_id":100023901,"comment_content":"    &#47;&#47; 乐观读<br>    long stamp = <br>      sl.tryOptimisticRead();<br><br>    int curX = x, curY = y;<br><br>    if (!sl.validate(stamp)){<br>    <br>    }<br>    return Math.sqrt(<br>      curX * curX + curY * curY);<br>有个疑问，这里如果  if (!sl.validate(stamp))时判断为false，即判断没有更新操作，但是在Math.sqrt(      curX * curX + curY * curY);之前发生了更新，怎么办？这里没有问题么","like_count":0},{"had_liked":false,"id":267166,"user_name":"放牧人","can_delete":false,"product_type":"c1","uid":1980326,"ip_address":"","ucode":"CA248909EFE7E0","user_header":"https://static001.geekbang.org/account/avatar/00/1e/37/a6/3e7c2d5c.jpg","comment_is_top":false,"comment_ctime":1607614563,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607614563","product_id":100023901,"comment_content":"课后思考题这里之所以有bug，是因为 tryConvertToWriteLock方法在 读锁获取写锁时，如果写锁是合理的，会释放之前的读锁，并返回写锁的 stamp，所以这里如果if (ws != 0L) 意味着升级写锁成功，需要释放写锁对应的 stamp 即 unlock(ws)<br>官方API原注释 if a read lock, if the write lock is available, releases the read lock and returns a write stamp","like_count":0},{"had_liked":false,"id":264375,"user_name":"Mr.Hwang","can_delete":false,"product_type":"c1","uid":2172620,"ip_address":"","ucode":"26EE6BF8EB1611","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/picb3nrC6rX6t4t6pHP8huAyrBa9g4lXCsY0uz2OicZsVsCfyLRg523CTWxX5AfEptxCMEC9DMuLZcia1cwzawhmg/132","comment_is_top":false,"comment_ctime":1606449781,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606449781","product_id":100023901,"comment_content":"乐观读是不需要进行释放锁的，只有升级为悲观读锁时，才需要进行锁的释放。可以理解为乐观读其实没有加锁，然后用版本号进行了一次比对，确定数据在读取时没有更改，否则需要加上悲观读锁，来阻止后续的写操作或等待已经获取到写锁的写操作完成。","like_count":0},{"had_liked":false,"id":260962,"user_name":"nssk","can_delete":false,"product_type":"c1","uid":1007266,"ip_address":"","ucode":"5839E5186900C6","user_header":"","comment_is_top":false,"comment_ctime":1605162300,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605162300","product_id":100023901,"comment_content":"类似于使用版本号控制？","like_count":0},{"had_liked":false,"id":243649,"user_name":"斜月浮云","can_delete":false,"product_type":"c1","uid":1008933,"ip_address":"","ucode":"25CECBB175DA02","user_header":"https://static001.geekbang.org/account/avatar/00/0f/65/25/c6de04bc.jpg","comment_is_top":false,"comment_ctime":1598240094,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1598240094","product_id":100023901,"comment_content":"请问stamptedLock不支持重入的原因是什么呢？能详细说下吗？","like_count":0},{"had_liked":false,"id":230356,"user_name":"delete is create","can_delete":false,"product_type":"c1","uid":1147979,"ip_address":"","ucode":"A8C751219A7746","user_header":"https://static001.geekbang.org/account/avatar/00/11/84/4b/e4738ba8.jpg","comment_is_top":false,"comment_ctime":1593354495,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1593354495","product_id":100023901,"comment_content":"在锁升级的时候没有释放写锁<br>1. 把写锁的ws赋值给stamp<br>2. 在finally中sl.unlock(ws) &#47;&#47;需要把ws移动到外边。","like_count":0},{"had_liked":false,"id":230352,"user_name":"delete is create","can_delete":false,"product_type":"c1","uid":1147979,"ip_address":"","ucode":"A8C751219A7746","user_header":"https://static001.geekbang.org/account/avatar/00/11/84/4b/e4738ba8.jpg","comment_is_top":false,"comment_ctime":1593354090,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1593354090","product_id":100023901,"comment_content":"mysql中执行update的不加锁么？","like_count":0},{"had_liked":false,"id":223802,"user_name":"小小米","can_delete":false,"product_type":"c1","uid":2011501,"ip_address":"","ucode":"D2928A29154FBD","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoEcoSRAWRtibKK8RHPc7XibzcyGEfDsUFOXRJWtfd2u549Qa4KpicFNpeq16IqK2KSp9rkF2hrMXDLg/132","comment_is_top":false,"comment_ctime":1591183568,"is_pvip":false,"replies":[{"id":"82613","content":"这个例子要的是x,y保证一致性","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1591418320,"ip_address":"","comment_id":223802,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591183568","product_id":100023901,"comment_content":"return Math.sqrt( curX * curX + curY * curY);<br>在执行这句的时候，因为已经释放了悲观读锁，变量又被其他线程改了怎么办？是不是应该把这句也放在try块里？请老师解答。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497245,"discussion_content":"这个例子要的是x,y保证一致性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591418320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222662,"user_name":"Shane_ミ木","can_delete":false,"product_type":"c1","uid":1537249,"ip_address":"","ucode":"01396B247CC8D8","user_header":"https://static001.geekbang.org/account/avatar/00/17/74/e1/623ff8d8.jpg","comment_is_top":false,"comment_ctime":1590884103,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1590884103","product_id":100023901,"comment_content":"老师，我有个疑问<br>课后题中，若升级写锁失败，说明有人写过了，这时候不应该重新检查xy的值吗？为啥要else释放读锁获取写锁呢？那如果while检查还是初始值，还要再升级写锁？没有看懂。。","like_count":0,"discussions":[{"author":{"id":1367048,"avatar":"https://static001.geekbang.org/account/avatar/00/14/dc/08/64f5ab52.jpg","nickname":"陈斌","note":"","ucode":"B639AB5F6AA03D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346833,"discussion_content":"如果升级失败，就阻塞获取写锁，一直到获取到写锁之后，在回到while循环中检查xy值是否被修改，没被修改就直接用获取到的写锁升级写锁（一定会成功），再用新的写锁修改xy，最后finally 释放写锁。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1612076826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1447904,"avatar":"https://static001.geekbang.org/account/avatar/00/16/17/e0/018a06cd.jpg","nickname":"RedHair","note":"","ucode":"9E68A6BC7C178E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304644,"discussion_content":"问题一：有人写过了就写过了呗，看题目的意思应该是一次性更改。解释：悲观读锁，可多线程获取，因此，假设T1和T2线程同时运行到`long ws = sl.tryConvertToWriteLock(stamp);`, 由于只能一个线程升级/获取到写锁，这时假设T1转换写锁成功，T2线程转换失败，T2阻塞，T1完成了x、y的更新，释放写锁，T2唤醒后，走了个else语句，然后重新转换写锁成功，更新x和y的值，结束；\n问题二和问题三：不太清楚：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599633513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222516,"user_name":"a(๑≖ิټ≖ิ)✌","can_delete":false,"product_type":"c1","uid":1392431,"ip_address":"","ucode":"AEF9B5CA1605DF","user_header":"https://static001.geekbang.org/account/avatar/00/15/3f/2f/8513c4d3.jpg","comment_is_top":false,"comment_ctime":1590825849,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1590825849","product_id":100023901,"comment_content":"假如我在写的时候没加锁，是不是乐观读 就没法判断stamp是否被修改过啊","like_count":0},{"had_liked":false,"id":221265,"user_name":"innocent","can_delete":false,"product_type":"c1","uid":1197455,"ip_address":"","ucode":"368659A0DDE7E4","user_header":"https://static001.geekbang.org/account/avatar/00/12/45/8f/a56b2214.jpg","comment_is_top":false,"comment_ctime":1590458680,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590458680","product_id":100023901,"comment_content":"          if (ws != 0L) {<br>            stamp = ws;<br>           x = newX;<br>           y = newY;<br>           break;<br>          }<br>来自官方示例","like_count":0},{"had_liked":false,"id":211101,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1587895951,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587895951","product_id":100023901,"comment_content":"记录下:<br> StampedLock读写锁都没有条件变量;不支持重入;支持锁的升级和降级;在读写锁阻塞时，调用interrupt会导致cpu冲高。性能优于ReadWriteLock的区别在于提供的乐观读。<br>ReadWriteLock写锁有条件变量，读锁没有;支持重入;支持锁的降级，不支持锁的升级","like_count":0},{"had_liked":false,"id":199151,"user_name":"😜哈哈","can_delete":false,"product_type":"c1","uid":1069001,"ip_address":"","ucode":"1FF58FB3A91135","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/c9/88837387.jpg","comment_is_top":false,"comment_ctime":1585480481,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585480481","product_id":100023901,"comment_content":"锁升级之后没有释放最新的写锁","like_count":0},{"had_liked":false,"id":188106,"user_name":"丁小明","can_delete":false,"product_type":"c1","uid":1207622,"ip_address":"","ucode":"CC23857B8D75D5","user_header":"https://static001.geekbang.org/account/avatar/00/12/6d/46/e16291f8.jpg","comment_is_top":false,"comment_ctime":1584321727,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584321727","product_id":100023901,"comment_content":"老师我不太明白为什么获取乐观锁之后，在使用数据前还要在判断一遍有没有被修改，那如果判断的时候确实没有其他线程写，但是判断之后其他线程写了呢？","like_count":0},{"had_liked":false,"id":167371,"user_name":"Guess","can_delete":false,"product_type":"c1","uid":1113416,"ip_address":"","ucode":"E436F153183E25","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/48/241e16a8.jpg","comment_is_top":false,"comment_ctime":1577778345,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1577778345","product_id":100023901,"comment_content":"老师（或大牛）能不能帮忙解惑<br>问题来源是StampedLock和ReadWriteLock的区别<br>1. StampedLock为什么不支持线程重入？（能不能解释一下）<br>2. StampedLock的悲观锁、写锁都不支持条件变量，这个条件变量在ReadWriteLock指的是什么？（是Condition吗？）<br>3. 如果线程阻塞在StampedLock的readLock || writeLock此时调用该线程的interrupt()方法会导致CPU飙升。是什么原因导致的？","like_count":0,"discussions":[{"author":{"id":1447904,"avatar":"https://static001.geekbang.org/account/avatar/00/16/17/e0/018a06cd.jpg","nickname":"RedHair","note":"","ucode":"9E68A6BC7C178E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304646,"discussion_content":"1. 没有reentrant打头，这个记忆一下就行；如果真感兴趣，那查看源码和别的博客，分析可重入的分析和实现；\n2. 条件变量，是你说的那个Condition；\n3. 老师回复过：内部实现里while循环里面对中断的处理有点问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599633738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164843,"user_name":"james","can_delete":false,"product_type":"c1","uid":1049208,"ip_address":"","ucode":"5701899403917C","user_header":"https://static001.geekbang.org/account/avatar/00/10/02/78/23c56bce.jpg","comment_is_top":false,"comment_ctime":1577099061,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577099061","product_id":100023901,"comment_content":"老师 validate 成功后 执行Math 时候x和y还是会被其他线程改了啊 ，和不validate 没啥区别啊 ","like_count":0},{"had_liked":false,"id":147301,"user_name":"威","can_delete":false,"product_type":"c1","uid":1068542,"ip_address":"","ucode":"C921CDCB22B9A3","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/fe/882eaf0f.jpg","comment_is_top":false,"comment_ctime":1572856677,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572856677","product_id":100023901,"comment_content":"在distanceFromOrigin方法后面的部分，当判断完乐观锁没被修改过后就调用return Math.sqrt，感觉这里是一个check-than-act，不是原子的，会有线程安全问题，不知道我理解是否正确","like_count":0},{"had_liked":false,"id":143422,"user_name":"秋天","can_delete":false,"product_type":"c1","uid":1057056,"ip_address":"","ucode":"A7E1D953EF7E17","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/20/1299e137.jpg","comment_is_top":false,"comment_ctime":1571707277,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1571707277","product_id":100023901,"comment_content":"使用 StampedLock 一定不要调用中断操作，如果需要...<br><br>","like_count":0},{"had_liked":false,"id":139463,"user_name":"ylw666","can_delete":false,"product_type":"c1","uid":1161301,"ip_address":"","ucode":"11BDAB1AF981B3","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/55/f982a2fb.jpg","comment_is_top":false,"comment_ctime":1570660737,"is_pvip":false,"replies":[{"id":"53773","content":"大部分问题数据库都能解决，解决不了的，基本上就开始体现程序员的价值了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1570663537,"ip_address":"","comment_id":139463,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570660737","product_id":100023901,"comment_content":"老师好，对于数据库的乐观读锁的例子，虽然很巧妙，但有点疑问，除非应用场景是version不对就不允许update，如果应用场景只是互斥并发的update，我觉得应该利用数据库自身特性就足够，例如postgresql中update语句会锁表（http:&#47;&#47;www.postgres.cn&#47;docs&#47;10&#47;explicit-locking.html#LOCKING-TABLES），不太需要您说的这个方法就可以实现并发的update。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469959,"discussion_content":"大部分问题数据库都能解决，解决不了的，基本上就开始体现程序员的价值了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570663537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136136,"user_name":"业余草","can_delete":false,"product_type":"c1","uid":1126538,"ip_address":"","ucode":"99BDC1E629049D","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/8a/b5ca7286.jpg","comment_is_top":false,"comment_ctime":1569371911,"is_pvip":false,"replies":[{"id":"52411","content":"技术只有在实践中才能锻炼出来，写业务逻辑的确机会很少","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1569496935,"ip_address":"","comment_id":136136,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569371911","product_id":100023901,"comment_content":"挺好的专栏，但是大多数人写业务逻辑用不到这些技术！","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468475,"discussion_content":"技术只有在实践中才能锻炼出来，写业务逻辑的确机会很少","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569496935,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114703,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1563367631,"is_pvip":false,"replies":[{"id":"41901","content":"看一下tryConvertToWriteLock(stamp)的API文档吧，主要是看它的参数和返回值的关系","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1563405402,"ip_address":"","comment_id":114703,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563367631","product_id":100023901,"comment_content":"老师，乐观读升级为悲观读锁是，如果写操作还在进行怎么办？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458786,"discussion_content":"看一下tryConvertToWriteLock(stamp)的API文档吧，主要是看它的参数和返回值的关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563405402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114698,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1563366335,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1563366335","product_id":100023901,"comment_content":"老师，你讲的数据库乐观锁例子那里我没明白哪里体现&quot;乐观&quot;了","like_count":0,"discussions":[{"author":{"id":1585829,"avatar":"https://static001.geekbang.org/account/avatar/00/18/32/a5/9868cd56.jpg","nickname":"southday","note":"","ucode":"4A8FB63D35F6E1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4771,"discussion_content":"我的理解，“乐观”：我相信没人会在我操作的过程中修改数据，所以我先一顿疯狂输出，最后再校验数据是否有可能被改了，（先操作，再校验 => 乐观），如果数据被改了就得放弃之前的操作，重新获取锁（升级为悲观锁）；“悲观”：我觉得一定会有人在我操作的时候修改数据，以防万一，先把数据锁住，再修改数据，（先锁，再操作 => 悲观）。“乐观”适用于“读多写少”的情况，如果将“乐观”用在“写多”的情况下，每次操作完，发现数据被改过，又得放弃之前的操作，不免的效率低下，还不如一开始就先锁数据（悲观锁","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1565709969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112069,"user_name":"VERITAS","can_delete":false,"product_type":"c1","uid":1214964,"ip_address":"","ucode":"CE1277145EDD6C","user_header":"https://static001.geekbang.org/account/avatar/00/12/89/f4/b3dacf1a.jpg","comment_is_top":false,"comment_ctime":1562664050,"is_pvip":true,"replies":[{"id":"40759","content":"jdk源代码注释里面都有","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1562675923,"ip_address":"","comment_id":112069,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562664050","product_id":100023901,"comment_content":"老师你好，请问官方示例URL是多少，没有找到","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457560,"discussion_content":"jdk源代码注释里面都有","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562675923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100659,"user_name":"渡码","can_delete":false,"product_type":"c1","uid":1348536,"ip_address":"","ucode":"8FD8B863D1DA0C","user_header":"https://static001.geekbang.org/account/avatar/00/14/93/b8/6510592e.jpg","comment_is_top":false,"comment_ctime":1559611897,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559611897","product_id":100023901,"comment_content":"请教老师一下，乐观读升级悲观读业务上有些不理解，其实升级完乐观读读到数据后调用math.sqrt这个时候共享数据仍然被改。既然数据任何时候都可能被改何必多读一次？","like_count":0},{"had_liked":false,"id":98400,"user_name":"windcaller","can_delete":false,"product_type":"c1","uid":1514157,"ip_address":"","ucode":"1CA3E849805770","user_header":"https://static001.geekbang.org/account/avatar/00/17/1a/ad/faf1bf19.jpg","comment_is_top":false,"comment_ctime":1558982367,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558982367","product_id":100023901,"comment_content":"解锁对象不一致，一开始读锁是 stamp 后来锁升级后是 ws 。 stamp解锁了， ws 并没有","like_count":0},{"had_liked":false,"id":96137,"user_name":"小辉辉","can_delete":false,"product_type":"c1","uid":1189661,"ip_address":"","ucode":"9FF25E25C85350","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/1d/1cb36854.jpg","comment_is_top":false,"comment_ctime":1558341424,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558341424","product_id":100023901,"comment_content":"最近的项目里面就用到过乐观锁，用来防止并发提交更新数据。","like_count":0},{"had_liked":false,"id":88788,"user_name":"WuV1Up","can_delete":false,"product_type":"c1","uid":1285406,"ip_address":"","ucode":"2EC06B4F094FCC","user_header":"https://static001.geekbang.org/account/avatar/00/13/9d/1e/64c532c5.jpg","comment_is_top":false,"comment_ctime":1556000716,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556000716","product_id":100023901,"comment_content":"StampedLock 使用注意事项 这个小节的代码，我在本地机器测试了下，T2.interrupt没有某个CPU到100%的现象...  只是CPU略微升高了点。","like_count":0},{"had_liked":false,"id":87851,"user_name":"xiyuesmiling","can_delete":false,"product_type":"c1","uid":1221692,"ip_address":"","ucode":"2E5AD30B1470D5","user_header":"https://static001.geekbang.org/account/avatar/00/12/a4/3c/121e7f9f.jpg","comment_is_top":false,"comment_ctime":1555731673,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555731673","product_id":100023901,"comment_content":"老师，当两个线程T1和T2如果都获取读锁，T1先升级失败而释放读锁，并阻塞在写锁；T2在1释放读锁时升级锁成功并且新值是0.0和0.0即与原来一样，最后释放写锁，T1在T2释放写锁之后获取写锁，下一个循环T2自己又尝试将写锁升级为写锁，这导致死锁？还是直接异常了走finally呢？是不是我哪里理解错了？😥","like_count":0},{"had_liked":false,"id":85696,"user_name":"张洋","can_delete":false,"product_type":"c1","uid":1182914,"ip_address":"","ucode":"549BE5DEEF8417","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/c2/bad34a50.jpg","comment_is_top":false,"comment_ctime":1555204172,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1555204172","product_id":100023901,"comment_content":"王老师，秒杀的场景下 对订单的数量加乐观读。会不会出现数据安全的问题呢","like_count":0},{"had_liked":false,"id":85459,"user_name":"冰激凌的眼泪","can_delete":false,"product_type":"c1","uid":1087945,"ip_address":"","ucode":"5DCB974667E93A","user_header":"https://static001.geekbang.org/account/avatar/00/10/99/c9/a7c77746.jpg","comment_is_top":false,"comment_ctime":1555064164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555064164","product_id":100023901,"comment_content":"读多写少的场景，减少了加锁操作，大大提高了效率","like_count":0},{"had_liked":false,"id":84567,"user_name":"包子","can_delete":false,"product_type":"c1","uid":1089345,"ip_address":"","ucode":"6CC4EBB8CD3924","user_header":"https://static001.geekbang.org/account/avatar/00/10/9f/41/82306dfe.jpg","comment_is_top":false,"comment_ctime":1554877299,"is_pvip":false,"replies":[{"id":"30450","content":"如果只是写，只是读，没有任何其他逻辑，是可以的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554898609,"ip_address":"","comment_id":84567,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554877299","product_id":100023901,"comment_content":"老师，一直有个问题想不明白，就是对一个变量的读和写是否会存在线程安全问题。<br>文章中举例是同时对x和y进行读写操作，那xy的读写不能保证原子性，所以需要用到锁。<br>如果是对一个变量x的读和写，我们对x加volatile，保证其多线程的可见性是不是就可以了？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446390,"discussion_content":"如果只是写，只是读，没有任何其他逻辑，是可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554898609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84207,"user_name":"一道阳光","can_delete":false,"product_type":"c1","uid":1239557,"ip_address":"","ucode":"F35207CCCEC6E2","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/05/c0d8014d.jpg","comment_is_top":false,"comment_ctime":1554803550,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554803550","product_id":100023901,"comment_content":"老师：如果线程走了else获取到读锁后又进去循环里，然后执行锁升级，会不会报错？","like_count":0},{"had_liked":false,"id":84181,"user_name":"张天屹","can_delete":false,"product_type":"c1","uid":1477612,"ip_address":"","ucode":"8BD6BD6DCF0F4F","user_header":"https://static001.geekbang.org/account/avatar/00/16/8b/ec/dc03f5ad.jpg","comment_is_top":false,"comment_ctime":1554798861,"is_pvip":false,"replies":[{"id":"30393","content":"看有没有多线程共享的变量，没有就不需要。文中数据库乐观锁的例子，有数据库事务也需要乐观锁。具体问题具体分析<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554820153,"ip_address":"","comment_id":84181,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554798861","product_id":100023901,"comment_content":"说到数据库乐观锁，有个问题想请教老师，比如spring使用事务的时候，底层就已经使用了读写相关的锁来保证并发了，在我们的程序中还需要显式的使用乐观锁机制来保证并发安全吗","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446270,"discussion_content":"看有没有多线程共享的变量，没有就不需要。文中数据库乐观锁的例子，有数据库事务也需要乐观锁。具体问题具体分析\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554820153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84172,"user_name":"ZOU志伟","can_delete":false,"product_type":"c1","uid":1029179,"ip_address":"","ucode":"439779871CC992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b4/3b/a1f7e3a4.jpg","comment_is_top":false,"comment_ctime":1554797545,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554797545","product_id":100023901,"comment_content":"老师，上一篇的缓存获取的用StampedLock的读代码这样写可以吗？<br>public V get(K key) {<br>\t\t\tlong stamp = sl.tryOptimisticRead();<br>\t\t\tV value = map.get(key);<br>\t\t\tif (!sl.validate(stamp)) {<br>\t\t\t\tstamp = sl.readLock();<br>\t\t\t\ttry {<br>\t\t\t\t\tvalue = map.get(key);<br>\t\t\t\t} finally {<br>\t\t\t\t\tsl.unlock(stamp);<br>\t\t\t\t}<br>\t\t\t}<br>\t\t\treturn value;<br>\t\t}","like_count":0},{"had_liked":false,"id":84073,"user_name":"晓杰","can_delete":false,"product_type":"c1","uid":1441546,"ip_address":"","ucode":"1174C88EEBF8A6","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","comment_is_top":false,"comment_ctime":1554778389,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554778389","product_id":100023901,"comment_content":"s1获取写锁后没有释放，可以在break前面加上stamp=ws，使写锁在finally语句块进行释放","like_count":0},{"had_liked":false,"id":84048,"user_name":"张天屹","can_delete":false,"product_type":"c1","uid":1477612,"ip_address":"","ucode":"8BD6BD6DCF0F4F","user_header":"https://static001.geekbang.org/account/avatar/00/16/8b/ec/dc03f5ad.jpg","comment_is_top":false,"comment_ctime":1554774380,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554774380","product_id":100023901,"comment_content":"乐观锁的本质是尽可能断的缩短互斥的时间，即&lt;1&gt;读&#47;计算&lt;2&gt;判断&lt;3&gt;更新，判断和更新必须是原子的。stampedLock的乐观读和乐观锁的共性在于都通过一个标记来判断，但是区别在于乐观锁因为要写所以有一段真正互斥的时间。<br>比如数据库乐观锁的update-where这一判断和更新操作通过update语句的排他锁保证原子性<br>比如CAS的判断更新操作通过底层的cpu指令的原子性来保证<br>stampedLock的乐观读因为不用更新，所以只需要判断，即不用完全保持互斥，所以老师提到的乐观读不是乐观锁很准确","like_count":0},{"had_liked":false,"id":84038,"user_name":"周治慧","can_delete":false,"product_type":"c1","uid":1335293,"ip_address":"","ucode":"7D56C4E66BEE17","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKR3ibELhjgVicCNShZCBwvaDxibnzibggG4wUzVkS2mkDxUBZyIs87nDEdJ7PiahJBVoZcuhQ84RxAziag/132","comment_is_top":false,"comment_ctime":1554772547,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554772547","product_id":100023901,"comment_content":"当读锁转成写锁成功后，对应的释放锁的stamp不对，需要再if处理完变量后break之前对stamp重读赋值成ws","like_count":0},{"had_liked":false,"id":84032,"user_name":"君哥聊技术","can_delete":false,"product_type":"c1","uid":1325816,"ip_address":"","ucode":"2C9A22BCE4C79E","user_header":"https://static001.geekbang.org/account/avatar/00/14/3a/f8/c1a939e7.jpg","comment_is_top":false,"comment_ctime":1554771513,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1554771513","product_id":100023901,"comment_content":"else里面释放读锁，增加写锁，然后回到循环开始再升级写锁。<br>老师，bug是不是在这儿啊？","like_count":0,"discussions":[{"author":{"id":1600341,"avatar":"https://static001.geekbang.org/account/avatar/00/18/6b/55/2b0f219b.jpg","nickname":"Geek_42f729","note":"","ucode":"76CFFF9DEDDF96","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555360,"discussion_content":"不是\n\n1. 升级为写锁返回的stamp如果等于0则说明获取锁失败，就会进入else逻辑；\n\n2. else逻辑里会再次尝试获取写锁，直到获取成功；\n\n3. else获取写锁成功后重新进入while，并调用tryConvertToWriteLock方法升级为写锁（如果stamp已经持有写锁则直接返回这个写锁-返回的stamp不等于0）；\n\n这里的bug是：long ws = sl.tryConvertToWriteLock(stamp)  新获取的ws没有释放","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646881926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83968,"user_name":"扛着锄头闯江湖","can_delete":false,"product_type":"c1","uid":1225243,"ip_address":"","ucode":"F2A2793EC8F1E6","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/1b/947dfcb8.jpg","comment_is_top":false,"comment_ctime":1554740607,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554740607","product_id":100023901,"comment_content":"先打个卡","like_count":0}]}