{"id":488985,"title":"18 | 实战：让KtHttp支持挂起函数","content":"<p>你好，我是朱涛。今天这节实战课，我们接着前面<a href=\"https://time.geekbang.org/column/article/481787\">第12讲</a>里实现的网络请求框架，来进一步完善这个KtHttp，让它支持挂起函数。</p><p>在上一次实战课当中，我们已经开发出了两个版本的KtHttp，1.0版本的是基于命令式风格的，2.0版本的是基于函数式风格的。其中2.0版本的代码风格，跟我们平时工作写的代码风格很不一样，之前我也说了，这主要是因为业界对Kotlin函数式编程接纳度并不高，所以这节课的代码，我们将基于1.0版本的代码继续改造。这样，也能让课程的内容更接地气一些，甚至你都可以借鉴今天写代码的思路，复用到实际的Android或者后端开发中去。</p><p>跟往常一样，这节课的代码还是会分为两个版本：</p><ul>\n<li>3.0 版本，在之前1.0版本的基础上，扩展出<strong>异步请求</strong>的能力。</li>\n<li>4.0 版本，进一步扩展异步请求的能力，让它<strong>支持挂起函数</strong>。</li>\n</ul><p>好，接下来就正式开始吧！</p><h2>3.0 版本：支持异步（Call）</h2><p>有了上一次实战课的基础，这节课就会轻松一些了。关于动态代理、注解、反射之类的知识不会牵涉太多，我们今天主要把精力都集中在协程上来。不过，在正式开始写协程代码之前，我们需要先让KtHttp支持异步请求，也就是Callback请求。</p><p>这是为什么呢？别忘了<a href=\"https://time.geekbang.org/column/article/487085\">第15讲</a>的内容：<strong>挂起函数本质就是Callback！</strong>所以，为了让KtHttp支持挂起函数，我们可以采用迂回的策略，让它先支持Callback。在之前1.0、2.0版本的代码中，KtHttp是只支持同步请求的，你可能对异步同步还有些懵，我带你来看个例子吧。</p><!-- [[[read_end]]] --><p>首先，这个是同步代码：</p><pre><code class=\"language-plain\">fun main() {\n    // 同步代码\n    val api: ApiService = KtHttpV1.create(ApiService::class.java)\n    val data: RepoList = api.repos(lang = \"Kotlin\", since = \"weekly\")\n    println(data)\n}\n</code></pre><p>可以看到，在main函数当中，我们调用了KtHttp 1.0的代码，其中3行代码的运行顺序是1、2、3，这就是典型的同步代码。它的另一个特点就是：所有代码都会在一个线程中执行，因此这样的代码如果运行在Android、Swing之类的UI编程平台上，是会导致主线程卡死的。</p><p>那么，异步代码又是长什么样的呢？</p><pre><code class=\"language-plain\">private fun testAsync() {\n    // 异步代码\n    KtHttpV3.create(ApiServiceV3::class.java).repos(\n        lang = \"Kotlin\",\n        since = \"weekly\"\n    ).call(object : Callback&lt;RepoList&gt; {\n        override fun onSuccess(data: RepoList) {\n            println(data)\n        }\n\n        override fun onFail(throwable: Throwable) {\n            println(throwable)\n        }\n    })\n}\n</code></pre><p>上面的testAsync()方法当中的代码，就是典型的异步代码，它跟同步代码最大的差异就是，有了一个Callback，而且代码不再是按照顺序执行的了。你可以参考下面这个动图：</p><p><img src=\"https://static001.geekbang.org/resource/image/a8/ff/a8d0c46d74a17d0ddfb683e0ac7468ff.gif?wh=1080x608\" alt=\"图片\"></p><p>所以，在3.0版本的开发中，我们就是要实现类似上面testAsync()的请求方式。为此，我们首先需要创建一个<strong>Callback接口</strong>，在这个Callback当中，我们可以拿到API请求的结果。</p><pre><code class=\"language-plain\">interface Callback&lt;T: Any&gt; {\n    fun onSuccess(data: T)\n    fun onFail(throwable: Throwable)\n}\n</code></pre><p>在Callback这个接口里，有一个泛型参数T，还有两个回调，分别是onSuccess代表接口请求成功、onFail代表接口请求失败。需要特别注意的是，这里我们运用了<a href=\"https://time.geekbang.org/column/article/484921\">空安全思维</a>当中的<strong>泛型边界“T: Any”</strong>，这样一来，我们就可以保证T类型一定是非空的。</p><p>除此之外，我们还需要一个<strong>KtCall类</strong>，它的作用是承载Callback，或者说，它是用来调用Callback的。</p><pre><code class=\"language-plain\">class KtCall&lt;T: Any&gt;(\n    private val call: Call,\n    private val gson: Gson,\n    private val type: Type\n) {\n    fun call(callback: Callback&lt;T&gt;): Call {\n        // TODO\n    }\n}\n</code></pre><p>KtCall这个类仍然使用了泛型边界“T: Any”，另外，它还有几个关键的成员分别是：OkHttp的Call对象、JSON解析的Gson对象，以及反射类型Type。然后还有一个call()方法，它接收的是前面我们定义的Callback对象，返回的是OkHttp的Call对象。所以总的来说，call()方法当中的逻辑会分为三个步骤。</p><pre><code class=\"language-plain\">class KtCall&lt;T: Any&gt;(\n    private val call: Call,\n    private val gson: Gson,\n    private val type: Type\n) {\n    fun call(callback: Callback&lt;T&gt;): Call {\n        // 步骤1， 使用call请求API\n        // 步骤2， 根据请求结果，调用callback.onSuccess()或者是callback.onFail()\n        // 步骤3， 返回OkHttp的Call对象\n    }\n}\n</code></pre><p>我们一步步来分析这三个步骤：</p><ul>\n<li>步骤1，使用OkHttp的call对象请求API，这里需要注意的是，为了将请求任务派发到异步线程，我们需要使用OkHttp的异步请求方法enqueue()。</li>\n<li>步骤2，根据请求结果，调用callback.onSuccess()或者是callback.onFail()。如果请求成功了，我们在调用onSuccess()之前，还需要用Gson将请求结果进行解析，然后才返回。</li>\n<li>步骤3，返回OkHttp的Call对象。</li>\n</ul><p>接下来，我们看看具体代码是怎么样的：</p><pre><code class=\"language-plain\">class KtCall&lt;T: Any&gt;(\n    private val call: Call,\n    private val gson: Gson,\n    private val type: Type\n) {\n    fun call(callback: Callback&lt;T&gt;): Call {\n        call.enqueue(object : okhttp3.Callback {\n            override fun onFailure(call: Call, e: IOException) {\n                callback.onFail(e)\n            }\n\n            override fun onResponse(call: Call, response: Response) {\n                try { // ①\n                    val t = gson.fromJson&lt;T&gt;(response.body?.string(), type)\n                    callback.onSuccess(t)\n                } catch (e: Exception) {\n                    callback.onFail(e)\n                }\n            }\n        })\n        return call\n    }\n}\n</code></pre><p>经过前面的解释，这段代码就很好理解了，唯一需要注意的是注释①处，由于API返回的结果并不可靠，即使请求成功了，其中的JSON数据也不一定合法，所以这里我们一般还需要进行额外的判断。在实际的商业项目当中，我们可能还需要根据当中的状态码，进行进一步区分和封装，这里为了便于理解，我就简单处理了。</p><p>那么在实现了KtCall以后，我们就只差<strong>ApiService</strong>这个接口了，这里我们定义ApiServiceV3，以作区分。</p><pre><code class=\"language-plain\">interface ApiServiceV3 {\n    @GET(\"/repo\")\n    fun repos(\n        @Field(\"lang\") lang: String,\n        @Field(\"since\") since: String\n    ): KtCall&lt;RepoList&gt; // ①\n}\n</code></pre><p>我们需要格外留意以上代码中的注释①，这其实就是<strong>3.0和1.0之间的最大区别</strong>。由于repo()方法的返回值类型是KtCall，为了支持这种写法，我们的invoke方法就需要跟着做一些小的改动：</p><pre><code class=\"language-plain\">// 这里也同样使用了泛型边界\nprivate fun &lt;T: Any&gt; invoke(path: String, method: Method, args: Array&lt;Any&gt;): Any? {\n    if (method.parameterAnnotations.size != args.size) return null\n\n    var url = path\n    val parameterAnnotations = method.parameterAnnotations\n    for (i in parameterAnnotations.indices) {\n        for (parameterAnnotation in parameterAnnotations[i]) {\n            if (parameterAnnotation is Field) {\n                val key = parameterAnnotation.value\n                val value = args[i].toString()\n                if (!url.contains(\"?\")) {\n                    url += \"?$key=$value\"\n                } else {\n                    url += \"&amp;$key=$value\"\n                }\n\n            }\n        }\n    }\n\n    val request = Request.Builder()\n        .url(url)\n        .build()\n\n    val call = okHttpClient.newCall(request)\n    val genericReturnType = getTypeArgument(method)\n    \n    // 变化在这里\n    return KtCall&lt;T&gt;(call, gson, genericReturnType)\n}\n\n// 拿到 KtCall&lt;RepoList&gt; 当中的 RepoList类型\nprivate fun getTypeArgument(method: Method) =\n    (method.genericReturnType as ParameterizedType).actualTypeArguments[0]\n</code></pre><p>在上面的代码中，大部分代码和1.0版本的一样的，只是在最后封装了一个KtCall对象，直接返回。所以在后续调用它的时候，我们就可以这么写了：ktCall.call()。</p><pre><code class=\"language-plain\">private fun testAsync() {\n    // 创建api对象\n    val api: ApiServiceV3 = KtHttpV3.create(ApiServiceV3::class.java)\n\n    // 获取ktCall\n    val ktCall: KtCall&lt;RepoList&gt; = api.repos(\n        lang = \"Kotlin\",\n        since = \"weekly\"\n    )\n\n    // 发起call异步请求\n    ktCall.call(object : Callback&lt;RepoList&gt; {\n        override fun onSuccess(data: RepoList) {\n            println(data)\n        }\n\n        override fun onFail(throwable: Throwable) {\n            println(throwable)\n        }\n    })\n}\n</code></pre><p>以上代码很好理解，我们一步步创建API对象、ktCall对象，最后发起请求。不过，在工作中一般是不会这么写代码的，因为创建太多一次性临时对象了。我们完全可以用<strong>链式调用</strong>的方式来做：</p><pre><code class=\"language-plain\">private fun testAsync() {\n    KtHttpV3.create(ApiServiceV3::class.java)\n    .repos(\n        lang = \"Kotlin\",\n        since = \"weekly\"\n    ).call(object : Callback&lt;RepoList&gt; {\n        override fun onSuccess(data: RepoList) {\n            println(data)\n        }\n\n        override fun onFail(throwable: Throwable) {\n            println(throwable)\n        }\n    })\n}\n</code></pre><p>如果你没有很多编程经验，那你可能会对这种方式不太适应，但在实际写代码的过程中，你会发现这种模式写起来会比上一种舒服很多，因为<strong>你再也不用为临时变量取名字伤脑筋了</strong>。</p><p>总的来说，到这里的话，我们的异步请求接口就已经完成了。而且，由于我们的实际请求已经通过OkHttp派发（enqueue）到统一的线程池当中去了，并不会阻塞主线程，所以这样的代码模式执行在Android、Swing之类的UI编程平台，也不会引起UI界面卡死的问题。</p><p>那么，3.0版本是不是到这里就结束了呢？其实并没有，因为我们还有一种情况没有考虑。我们来看看下面这段代码示例：</p><pre><code class=\"language-plain\">interface ApiServiceV3 {\n    @GET(\"/repo\")\n    fun repos(\n        @Field(\"lang\") lang: String,\n        @Field(\"since\") since: String\n    ): KtCall&lt;RepoList&gt;\n\n    @GET(\"/repo\")\n    fun reposSync(\n        @Field(\"lang\") lang: String,\n        @Field(\"since\") since: String\n    ): RepoList // 注意这里\n}\n\nprivate fun testSync() {\n    val api: ApiServiceV3 = KtHttpV3.create(ApiServiceV3::class.java)\n    val data: RepoList = api.reposSync(lang = \"Kotlin\", since = \"weekly\")\n    println(data)\n}\n</code></pre><p>请留意注释的地方，repoSync()的返回值类型是RepoList，而不是KtCall类型，这其实是我们1.0版本的写法。看到这，你是不是发现问题了？虽然KtHttp支持了异步请求，但原本的同步请求反而不支持了。</p><p>所以，为了让KtHttp同时支持两种请求方式，我们只需要增加一个 <strong>if判断</strong>即可：</p><pre><code class=\"language-plain\">private fun &lt;T: Any&gt; invoke(path: String, method: Method, args: Array&lt;Any&gt;): Any? {\n    // 省略其他代码\n\n    return if (isKtCallReturn(method)) {\n        val genericReturnType = getTypeArgument(method)\n        KtCall&lt;T&gt;(call, gson, genericReturnType)\n    } else {\n        // 注意这里\n        val response = okHttpClient.newCall(request).execute()\n\n        val genericReturnType = method.genericReturnType\n        val json = response.body?.string()\n        gson.fromJson&lt;Any?&gt;(json, genericReturnType)\n    }\n}\n\n// 判断当前接口的返回值类型是不是KtCall\nprivate fun isKtCallReturn(method: Method) =\n    getRawType(method.genericReturnType) == KtCall::class.java\n</code></pre><p>在上面的代码中，我们定义了一个方法isKtCallReturn()，它的作用是判断当前接口方法的返回值类型是不是KtCall，如果是的话，我们就认为它是一个异步接口，这时候返回KtCall对象；如果不是，我们就认为它是同步接口。这样我们只需要将1.0的逻辑挪到else分支，就可以实现兼容了。</p><p>那么到这里，我们3.0版本的开发就算是完成了。接下来，我们进入4.0版本的开发。</p><h2>4.0 版本：支持挂起函数</h2><p>终于来到协程实战的部分了。在日常的开发工作当中，你也许经常会面临这样的一个问题：虽然很想用Kotlin的协程来简化异步开发，但公司的底层框架全部都是Callback写的，根本不支持挂起函数，我一个上层的业务开发工程师，能有什么办法呢？</p><p>其实，我们当前的KtHttp就面临着类似的问题：3.0版本只支持Callback异步调用，现在我们想要扩展出挂起函数的功能。这其实就是大部分Kotlin开发者会遇到的场景。</p><p>就我这几年架构迁移的实践经验来看，针对这个问题，我们主要有两种解法：</p><ul>\n<li>第一种解法，不改动SDK内部的实现，直接在SDK的基础上扩展出协程的能力。</li>\n<li>第二种解法，改动SDK内部，让SDK直接支持挂起函数。</li>\n</ul><p>下面我们先来看看第一种解法。至于第二种解法，其实还可以细分出好几种思路，由于它涉及到挂起函数更底层的一些知识，具体方案我会在源码篇的第27讲介绍。</p><h3>解法一：扩展KtCall</h3><p>这种方式有一个优势，那就是我们不需要改动3.0版本的任何代码。这种场景在工作中也是十分常见的，比如说，项目中用到的SDK是开源的，或者SDK是公司其他部门开发的，我们无法改动SDK。</p><p>具体的做法，就是为KtCall这个类扩展出一个挂起函数。</p><pre><code class=\"language-plain\">/*\n注意这里                   函数名称\n   ↓                        ↓        */\nsuspend fun &lt;T: Any&gt; KtCall&lt;T&gt;.await(): T = TODO()\n</code></pre><p>在上面的代码中，我们定义了一个扩展函数await()。首先，它是一个挂起函数，其次，它的扩展接收者类型是KtCall，其中带着一个泛型T，挂起函数的返回值也是泛型T。</p><p>而由于它是一个挂起函数，所以，我们的代码就可以换成这样的方式来写了。</p><pre><code class=\"language-plain\">fun main() = runBlocking {\n    val ktCall = KtHttpV3.create(ApiServiceV3::class.java)\n        .repos(lang = \"Kotlin\", since = \"weekly\")\n\n    val result = ktCall.await() // 调用挂起函数\n    println(result)\n}\n</code></pre><p>那么，现在我们就只剩下一个问题了：<strong>await()具体该如何实现？</strong></p><p>在这里，我们需要用到Kotlin官方提供的一个顶层函数：suspendCoroutine{}，它的函数签名是这样的：</p><pre><code class=\"language-plain\">public suspend inline fun &lt;T&gt; suspendCoroutine(crossinline block: (Continuation&lt;T&gt;) -&gt; Unit): T {\n    // 省略细节\n}\n</code></pre><p>从它的函数签名，我们可以发现，它是一个挂起函数，也是一个高阶函数，参数类型是“(Continuation) -&gt; Unit”，如果你还记得第15讲当中的内容，你应该就已经发现了，<strong>它其实就等价于挂起函数类型！</strong></p><p>所以，我们可以使用suspendCoroutine{} 来实现await()方法：</p><pre><code class=\"language-plain\">/*\n注意这里                   \n   ↓                                */\nsuspend fun &lt;T: Any&gt; KtCall&lt;T&gt;.await(): T = suspendCoroutine{\n    continuation -&gt;\n    //   ↑\n    // 注意这里 \n}\n</code></pre><p>如果你仔细分析这段代码的话，会发现suspendCoroutine{} 的作用，其实就是<strong>将挂起函数当中的continuation暴露出来</strong>。</p><p>那么，suspendCoroutine{} 当中的代码具体该怎么写呢？答案应该也很明显了，当然是要用这个被暴露出来的continuation来做文章啦！</p><p>这里我们再来回顾一下Continuation这个接口：</p><pre><code class=\"language-plain\">public interface Continuation&lt;in T&gt; {\n    public val context: CoroutineContext\n    // 关键在于这个方法\n    public fun resumeWith(result: Result&lt;T&gt;)\n}\n</code></pre><p>通过定义可以看到，整个Continuation只有一个方法，那就是resumeWith()，根据它的名字我们就可以推测出，它是用于“恢复”的，参数类型是Result<t>。所以很明显，这就是一个带有泛型的“结果”，它的作用就是承载协程执行的结果。</t></p><p>所以，综合来看，我们就可以进一步写出这样的代码了：</p><pre><code class=\"language-plain\">suspend fun &lt;T: Any&gt; KtCall&lt;T&gt;.await(): T =\n    suspendCoroutine { continuation -&gt;\n        call(object : Callback&lt;T&gt; {\n            override fun onSuccess(data: T) {\n                continuation.resumeWith(Result.success(data))\n            }\n\n            override fun onFail(throwable: Throwable) {\n                continuation.resumeWith(Result.failure(throwable))\n            }\n        })\n    }\n</code></pre><p>以上代码也很容易理解，当网络请求执行成功以后，我们就调用resumeWith()，同时传入Result.success(data)；如果请求失败，我们就传入Result.failure(throwable)，将对应的异常信息传进去。</p><p>不过，也许你会觉得创建Result的写法太繁琐了，没关系，你可以借助Kotlin官方提供的扩展函数提升代码可读性。</p><pre><code class=\"language-plain\">suspend fun &lt;T : Any&gt; KtCall&lt;T&gt;.await(): T =\n    suspendCoroutine { continuation -&gt;\n        call(object : Callback&lt;T&gt; {\n            override fun onSuccess(data: T) {\n                continuation.resume(data)\n            }\n\n            override fun onFail(throwable: Throwable) {\n                continuation.resumeWithException(throwable)\n            }\n        })\n    }\n</code></pre><p>到目前为止，await()这个扩展函数其实就已经实现了。这时候，如果我们在协程当中调用await()方法的话，代码是可以正常执行的。不过，这种做法其实还有一点瑕疵，那就是<strong>不支持取消</strong>。</p><p>让我们来写一个简单的例子：</p><pre><code class=\"language-plain\">fun main() = runBlocking {\n    val start = System.currentTimeMillis()\n    val deferred = async {\n        KtHttpV3.create(ApiServiceV3::class.java)\n            .repos(lang = \"Kotlin\", since = \"weekly\")\n            .await()\n    }\n\n    deferred.invokeOnCompletion {\n        println(\"invokeOnCompletion!\")\n    }\n    delay(50L)\n\n    deferred.cancel()\n    println(\"Time cancel: ${System.currentTimeMillis() - start}\")\n\n    try {\n        println(deferred.await())\n    } catch (e: Exception) {\n        println(\"Time exception: ${System.currentTimeMillis() - start}\")\n        println(\"Catch exception:$e\")\n    } finally {\n        println(\"Time total: ${System.currentTimeMillis() - start}\")\n    }\n}\n\nsuspend fun &lt;T : Any&gt; KtCall&lt;T&gt;.await(): T =\n    suspendCoroutine { continuation -&gt;\n        call(object : Callback&lt;T&gt; {\n            override fun onSuccess(data: T) {\n                println(\"Request success!\") // ①\n                continuation.resume(data)\n            }\n\n            override fun onFail(throwable: Throwable) {\n                println(\"Request fail!：$throwable\")\n                continuation.resumeWithException(throwable)\n            }\n        })\n    }\n\n/*\n输出结果：\nTime cancel: 536   // ②\nRequest success!   // ③\ninvokeOnCompletion!\nTime exception: 3612  // ④\nCatch exception:kotlinx.coroutines.JobCancellationException: DeferredCoroutine was cancelled; job=DeferredCoroutine{Cancelled}@6043cd28\nTime total: 3612\n*/\n</code></pre><p>在main函数当中，我们在async里调用了挂起函数，接着50ms过去后，我们就去尝试取消协程。这段代码中一共有三处地方需要注意，我们来分析一下：</p><ul>\n<li>结合注释①、③一起分析，我们发现，即使调用了deferred.cancel()，网络请求仍然会继续执行。根据“Catch exception:”输出的异常信息，我们也发现，当deferred被取消以后我们还去调用await()的时候，会抛出异常。</li>\n<li>对比注释②、④，我们还能发现，deferred.await()虽然会抛出异常，但是它却耗时3000ms。虽然deferred被取消了，但是当我们调用await()的时候，它并不会马上就抛出异常，而是会等到内部的网络请求执行结束以后，才抛出异常，在此之前都会被挂起。</li>\n</ul><p>综上所述，当我们使用suspendCoroutine{} 来实现挂起函数的时候，默认情况下是不支持取消的。那么，具体该怎么做呢？其实也很简单，就是使用Kotlin官方提供的另一个API：<strong>suspendCancellableCoroutine{}</strong>。</p><pre><code class=\"language-plain\">suspend fun &lt;T : Any&gt; KtCall&lt;T&gt;.await(): T =\n//            变化1\n//              ↓\n    suspendCancellableCoroutine { continuation -&gt;\n        val call = call(object : Callback&lt;T&gt; {\n            override fun onSuccess(data: T) {\n                println(\"Request success!\")\n                continuation.resume(data)\n            }\n\n            override fun onFail(throwable: Throwable) {\n                println(\"Request fail!：$throwable\")\n                continuation.resumeWithException(throwable)\n            }\n        })\n\n//            变化2\n//              ↓\n        continuation.invokeOnCancellation {\n            println(\"Call cancelled!\")\n            call.cancel()\n        }\n    }\n</code></pre><p>当我们使用suspendCancellableCoroutine{} 的时候，可以往continuation对象上面设置一个监听：invokeOnCancellation{}，它代表当前的协程被取消了，这时候，我们只需要将OkHttp的call取消即可。</p><p>这样一来，main()函数就能保持不变，得到的输出结果却大不相同。</p><pre><code class=\"language-plain\">/*\nsuspendCoroutine结果：\n\nTime cancel: 536   \nRequest success!   \ninvokeOnCompletion!\nTime exception: 3612  // ①\nCatch exception:kotlinx.coroutines.JobCancellationException: DeferredCoroutine was cancelled; job=DeferredCoroutine{Cancelled}@6043cd28\nTime total: 3612\n*/\n\n/*\nsuspendCancellableCoroutine结果：\n\nCall cancelled!\nTime cancel: 464\ninvokeOnCompletion!\nTime exception: 466  // ②\nCatch exception:kotlinx.coroutines.JobCancellationException: DeferredCoroutine was cancelled; job=DeferredCoroutine{Cancelled}@6043cd28\nTime total: 466\nRequest fail!：java.io.IOException: Canceled  // ③\n*/\n</code></pre><p>对比注释①、②，可以发现，后者是会立即响应协程取消事件的，所以当代码执行到deferred.await()的时候，会立即抛出异常，而不会挂起很长时间。另外，通过注释③这里的结果，我们也可以发现，OkHttp的网络请求确实被取消了。</p><p>所以，我们可以得出一个结论，使用suspendCancellableCoroutine{}，我们可以避免不必要的挂起，比如例子中的deferred.await()；另外也可以节省计算机资源，因为这样可以避免不必要的协程任务，比如这里被成功取消的网络请求。</p><p>到这里，我们的解法一就已经完成了。这种方式并没有改动KtHttp的源代码，而是以扩展函数来实现的。所以，从严格意义上来讲，KtHttp 4.0版本并没有开发完毕，等到第27讲我们深入理解了挂起函数的底层原理后，我们再来完成解法二的代码。</p><h2>小结</h2><p>这节课，我们在KtHttp 1.0版本的基础上，扩展出了异步请求的功能，完成了3.0版本的开发；接着，我们又在3.0版本的基础上，让KtHttp支持了挂起函数，这里我们是用的外部扩展的思路，并没有碰KtHttp内部的代码。</p><p>这里主要涉及以下几个知识点：</p><ul>\n<li>在3.0版本开发中，我们运用了泛型边界“T: Any”，落实对泛型的非空限制，同时通过封装KtCall，为下一个版本打下了基础。</li>\n<li>接着，在4.0版本中，我们借助扩展函数的特性，为KtCall扩展了await()方法。</li>\n<li>在实现await()的过程中，我们使用了两个协程API，分别是suspendCoroutine{}、suspendCancellableCoroutine{}，在Kotlin协程当中，我们<strong>永远都要优先使用后者</strong>。</li>\n<li>suspendCancellableCoroutine{} 主要有两大优势：第一，它可以避免不必要的挂起，提升运行效率；第二，它可以避免不必要的资源浪费，改善软件的综合指标。</li>\n</ul><h2>思考题</h2><p>你能分析出下面的代码执行结果吗？为什么会是这样的结果？它能给你带来什么启发？欢迎给我留言，也欢迎你把今天的内容分享给更多的朋友。</p><pre><code class=\"language-plain\">fun main() = runBlocking {\n    val start = System.currentTimeMillis()\n    val deferred = async {\n        KtHttpV3.create(ApiServiceV3::class.java)\n            .repos(lang = \"Kotlin\", since = \"weekly\")\n            .await()\n    }\n\n    deferred.invokeOnCompletion {\n        println(\"invokeOnCompletion!\")\n    }\n    delay(50L)\n\n    deferred.cancel()\n    println(\"Time cancel: ${System.currentTimeMillis() - start}\")\n\n    try {\n        println(deferred.await())\n    } catch (e: Exception) {\n        println(\"Time exception: ${System.currentTimeMillis() - start}\")\n        println(\"Catch exception:$e\")\n    } finally {\n        println(\"Time total: ${System.currentTimeMillis() - start}\")\n    }\n}\n\nsuspend fun &lt;T : Any&gt; KtCall&lt;T&gt;.await(): T =\n    suspendCancellableCoroutine { continuation -&gt;\n        val call = call(object : Callback&lt;T&gt; {\n            override fun onSuccess(data: T) {\n                println(\"Request success!\")\n                continuation.resume(data)\n            }\n\n            override fun onFail(throwable: Throwable) {\n                println(\"Request fail!：$throwable\")\n                continuation.resumeWithException(throwable)\n            }\n        })\n\n// 注意这里\n//        continuation.invokeOnCancellation {\n//            println(\"Call cancelled!\")\n//            call.cancel()\n//        }\n    }\n</code></pre>","comments":[{"had_liked":false,"id":336520,"user_name":"神秘嘉Bin","can_delete":false,"product_type":"c1","uid":2879116,"ip_address":"","ucode":"6045F09320E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/2b/ee/8c/06f3aef0.jpg","comment_is_top":false,"comment_ctime":1646198335,"is_pvip":false,"replies":[{"id":"123016","content":"分析很好。其实，能够直接分析出协程代码的执行流程，并且说出具体的原因，这也是很重要的一种能力。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646271267,"ip_address":"","comment_id":336520,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10236132927","product_id":100103401,"comment_content":"思考题：<br>（1）执行async可认为一瞬间就到了suspendCancellableCoroutine的await扩展方法，即协程被挂起。<br>（2）执行deferred.cancel()，可以使得挂起函数立刻返回并抛出协程cancel异常<br>（3）协程取消了，但网络请求还是发出去了，（因为网络请求有自己的线程）也会回来，调用continuation.resume，发现协程被取消了，抛出协程已经被取消的异常<br>（4.1）网络IO比deferred.await()早，那么deferred.await()会拿到异常，并catch<br>（4.2）网络IO比deferred.await()晚，那么deferred.await()会立刻返回，没有异常<br><br><br>以上都是我猜的，没有实际运行  -.- ","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554209,"discussion_content":"分析很好。其实，能够直接分析出协程代码的执行流程，并且说出具体的原因，这也是很重要的一种能力。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646271268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2763653,"avatar":"","nickname":"Geek_61de09","note":"","ucode":"56A95CB08C0B04","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577628,"discussion_content":"老师，正确地答案讲解是什么呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656238821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1236983,"avatar":"","nickname":"辉哥","note":"","ucode":"21A65F4EE6CD04","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554536,"discussion_content":"4.1和4.2是不是说反了,网络IO先请求完,deferred.await()会直接返回结果吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646454707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338192,"user_name":"迩、卜懂莪","can_delete":false,"product_type":"c1","uid":1754378,"ip_address":"","ucode":"0EA96E6A89F3A1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/c5/0a/c7267f5b.jpg","comment_is_top":false,"comment_ctime":1647346850,"is_pvip":false,"replies":[{"id":"123658","content":"是的，Retrofit2也是练手的绝佳案例。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1647407928,"ip_address":"","comment_id":338192,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5942314146","product_id":100103401,"comment_content":"Kthttp系列实战 像是简易版的retrofit2 对学习 retrofit的源码有很大帮助","like_count":2,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556521,"discussion_content":"是的，Retrofit2也是练手的绝佳案例。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647407928,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335819,"user_name":"better","can_delete":false,"product_type":"c1","uid":1169063,"ip_address":"","ucode":"AF1DB566EBB8A5","user_header":"https://static001.geekbang.org/account/avatar/00/11/d6/a7/ac23f5a6.jpg","comment_is_top":false,"comment_ctime":1645700852,"is_pvip":false,"replies":[{"id":"122722","content":"是的。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1645747126,"ip_address":"","comment_id":335819,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5940668148","product_id":100103401,"comment_content":"第一，它可以避免不必要的挂起，提升运行效率 ；请问老师，这一条指的是？<br>思考题：<br>网络请求还是会执行，第一点避免了，但是二点没有避免。","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553129,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645747126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335546,"user_name":"Allen","can_delete":false,"product_type":"c1","uid":1127306,"ip_address":"","ucode":"3F69DAC14260DC","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/8a/f7a3d5e6.jpg","comment_is_top":false,"comment_ctime":1645582494,"is_pvip":false,"replies":[{"id":"122574","content":"这个问题有点深，在这里说不清，等到源码篇以后，你自己就懂啦~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1645593243,"ip_address":"","comment_id":335546,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5940549790","product_id":100103401,"comment_content":"问题二：像 suspendCoroutine 这一类系统所提供的挂起函数底层到底实现了什么，才使得其具有挂起的功能？是内部自己实现了 Callback 吗？为啥我们自己实现的 suspend 函数必须调用系统提供的挂起函数才能生效？","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552770,"discussion_content":"这个问题有点深，在这里说不清，等到源码篇以后，你自己就懂啦~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645593244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":354185,"user_name":"郑峰","can_delete":false,"product_type":"c1","uid":1112517,"ip_address":"美国","ucode":"4D4C0C020E507C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/c5/95b97dfa.jpg","comment_is_top":false,"comment_ctime":1660165678,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660165678","product_id":100103401,"comment_content":"思考题：<br><br>1. 除非没有Line 12 delay(50L) 或者 delay(0L)， 网络请求总是被发送出去，并返回结果。因为请求没有被取消。<br>2. 取消协程不一定能catch到cancel exception。<br>3. 如果网络请求在defer.await()之前返回，则协程正常返回，没有异常。否则，协程被取消的异常被catch。<br><br><br>注意两点<br>1. 本课的协程输出受delay时间影响。出现了request未被发送， request发送未返回和request发送返回 多种不同状态。<br>2. main函数执行完成后，process不能马上exit。因为okhttp创建了一个非daemon的线程。在timeout结束后process可以正常结束。","like_count":0},{"had_liked":false,"id":353294,"user_name":"银河","can_delete":false,"product_type":"c1","uid":1773197,"ip_address":"广东","ucode":"C053595AE5BB8F","user_header":"https://static001.geekbang.org/account/avatar/00/1b/0e/8d/d8f3298d.jpg","comment_is_top":false,"comment_ctime":1659336166,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1659336166","product_id":100103401,"comment_content":"思考题结果：<br>Time cancel: 301<br>invokeOnCompletion!<br>Time exception: 301<br>Catch exception:kotlinx.coroutines.JobCancellationException: DeferredCoroutine was cancelled; job=DeferredCoroutine{Cancelled}@41c2284a<br>Time total: 301<br>Request success!<br><br>不难看出，suspendCancellableCoroutine函数是asyc被cancel后await立即恢复，不阻塞了，监听的是外部async的生命周期，而suspendCoroutine靠手动也就是监听网络请求call的返回结果","like_count":0},{"had_liked":false,"id":346442,"user_name":"荒原","can_delete":false,"product_type":"c1","uid":2327517,"ip_address":"","ucode":"E11C59C86AA82E","user_header":"https://static001.geekbang.org/account/avatar/00/23/83/dd/e0f79039.jpg","comment_is_top":false,"comment_ctime":1653139491,"is_pvip":false,"replies":[{"id":"126600","content":"请问你这里同步、异步的判断依据是什么呢？说实话，我没看出来以上两段代码区别在哪里，只是换了return 的位置，理论上不应该影响逻辑的。你能提供一些具体的信息吗？","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1653819251,"ip_address":"","comment_id":346442,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1653139491","product_id":100103401,"comment_content":"KtHttpV3.invoke()方法返回值这样写会将同步请求的返回值转成了一个异步的KtCall<br>return if (isKtCallReturn(method)){<br>            KtCall&lt;T&gt;(<br>                client.newCall(request),<br>                gson,<br>                getTypeArgument(method)<br>            )<br>        }else{<br>            val response = client.newCall(request).execute()<br>          &#47;&#47;这里转成了一个KtCall对象<br>            gson.fromJson(<br>                response.body?.string(),<br>                method.genericReturnType<br>            )<br>        }<br>而这样写就不会<br>if (isKtCallReturn(method)){<br>            return KtCall&lt;T&gt;(<br>                client.newCall(request),<br>                gson,<br>                getTypeArgument(method)<br>            )<br>        }else{<br>            val response = client.newCall(request).execute()<br><br>            return gson.fromJson(<br>                response.body?.string(),<br>                method.genericReturnType<br>            )<br>        }<br>这是为什么呢","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574067,"discussion_content":"请问你这里同步、异步的判断依据是什么呢？说实话，我没看出来以上两段代码区别在哪里，只是换了return 的位置，理论上不应该影响逻辑的。你能提供一些具体的信息吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653819251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341950,"user_name":"王安泽","can_delete":false,"product_type":"c1","uid":2435361,"ip_address":"","ucode":"C014B27FA11911","user_header":"https://static001.geekbang.org/account/avatar/00/25/29/21/d90429b1.jpg","comment_is_top":false,"comment_ctime":1649928267,"is_pvip":false,"replies":[{"id":"124952","content":"没有立即结束，是因为Async底层使用的线程池没有立即回收，需要等一小会才会结束。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1649950505,"ip_address":"","comment_id":341950,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1649928267","product_id":100103401,"comment_content":"请问为什么Async的写法response返回后程序没有结束呢？ ","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563204,"discussion_content":"没有立即结束，是因为Async底层使用的线程池没有立即回收，需要等一小会才会结束。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649950505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335545,"user_name":"Allen","can_delete":false,"product_type":"c1","uid":1127306,"ip_address":"","ucode":"3F69DAC14260DC","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/8a/f7a3d5e6.jpg","comment_is_top":false,"comment_ctime":1645581940,"is_pvip":false,"replies":[{"id":"122575","content":"是的。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1645593279,"ip_address":"","comment_id":335545,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1645581940","product_id":100103401,"comment_content":"涛哥，问两个问题哈。如果上面例子中的网络请求是运行在当前线程，是不是这里的挂起实际上也没有什么用，因为其还是会阻塞当前线程（像下面的代码一样）？<br><br>suspend fun testSuspendFunc() {<br>    suspendCancellableCoroutine&lt;Unit&gt; {<br>        &#47;&#47; stimulate the network request<br>        Thread.sleep(5000)<br>        it.resumeWith(Result.success(Unit))<br>    }<br>}","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552772,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645593279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335536,"user_name":"Allen","can_delete":false,"product_type":"c1","uid":1127306,"ip_address":"","ucode":"3F69DAC14260DC","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/8a/f7a3d5e6.jpg","comment_is_top":false,"comment_ctime":1645579384,"is_pvip":false,"replies":[{"id":"122576","content":"你实际运行然后仔细对比看看，是不是一点差别都没有？","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1645593330,"ip_address":"","comment_id":335536,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1645579384","product_id":100103401,"comment_content":"思考题的执行结果和 suspendCoroutine 的执行结果是一样的。取消了监听 invokeOnCancellation 的方法后，suspendCancellableoroutine 和 suspendCoroutine 本质上是一回事。","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552773,"discussion_content":"你实际运行然后仔细对比看看，是不是一点差别都没有？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645593330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1127306,"avatar":"https://static001.geekbang.org/account/avatar/00/11/33/8a/f7a3d5e6.jpg","nickname":"Allen","note":"","ucode":"3F69DAC14260DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":552807,"discussion_content":"有差别，应该说思考题里的执行结果和上面 suspendCancellableCoroutine 的执行结果差不多，区别就是由于注释了监听 invokeOncancellation 回调后，对应的 Call 没有被取消，而会继续运行，并在得到结果后，调用回调方法进行返回，也就是最后打印的是 Request success!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645599670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":552773,"ip_address":""},"score":552807,"extra":""}]},{"author":{"id":1090798,"avatar":"https://static001.geekbang.org/account/avatar/00/10/a4/ee/cffd8ee6.jpg","nickname":"魏全运","note":"","ucode":"3FED702C724E2A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553535,"discussion_content":"去掉后不会执行onFailure回调了，因为okhttp的call没有被取消","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645955411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}