{"id":101855,"title":"20 | 揭秘 Python 协程","content":"<p>你好，我是景霄。</p><p>上一节课的最后，我们留下一个小小的悬念：生成器在 Python 2 中还扮演了一个重要角色，就是用来实现 Python 协程。</p><p>那么首先你要明白，什么是协程？</p><p>协程是实现并发编程的一种方式。一说并发，你肯定想到了多线程/多进程模型，没错，多线程/多进程，正是解决并发问题的经典模型之一。最初的互联网世界，多线程/多进程在服务器并发中，起到举足轻重的作用。</p><p>随着互联网的快速发展，你逐渐遇到了 C10K 瓶颈，也就是同时连接到服务器的客户达到了一万个。于是很多代码跑崩了，进程上下文切换占用了大量的资源，线程也顶不住如此巨大的压力，这时，  NGINX 带着事件循环出来拯救世界了。</p><p>如果将多进程/多线程类比为起源于唐朝的藩镇割据，那么事件循环，就是宋朝加强的中央集权制。事件循环启动一个统一的调度器，让调度器来决定一个时刻去运行哪个任务，于是省却了多线程中启动线程、管理线程、同步锁等各种开销。同一时期的 NGINX，在高并发下能保持低资源低消耗高性能，相比 Apache 也支持更多的并发连接。</p><p>再到后来，出现了一个很有名的名词，叫做回调地狱（callback hell），手撸过 JavaScript 的朋友肯定知道我在说什么。我们大家惊喜地发现，这种工具完美地继承了事件循环的优越性，同时还能提供 async / await 语法糖，解决了执行性和可读性共存的难题。于是，协程逐渐被更多人发现并看好，也有越来越多的人尝试用 Node.js 做起了后端开发。（讲个笑话，JavaScript 是一门编程语言。）</p><!-- [[[read_end]]] --><p>回到我们的 Python。使用生成器，是 Python 2 开头的时代实现协程的老方法了，Python 3.7 提供了新的基于 asyncio 和 async / await 的方法。我们这节课，同样的，跟随时代，抛弃掉不容易理解、也不容易写的旧的基于生成器的方法，直接来讲新方法。</p><p>我们先从一个爬虫实例出发，用清晰的讲解思路，带你结合实战来搞懂这个不算特别容易理解的概念。之后，我们再由浅入深，直击协程的核心。</p><h2>从一个爬虫说起</h2><p>爬虫，就是互联网的蜘蛛，在搜索引擎诞生之时，与其一同来到世上。爬虫每秒钟都会爬取大量的网页，提取关键信息后存储在数据库中，以便日后分析。爬虫有非常简单的 Python 十行代码实现，也有 Google 那样的全球分布式爬虫的上百万行代码，分布在内部上万台服务器上，对全世界的信息进行嗅探。</p><p>话不多说，我们先看一个简单的爬虫例子：</p><pre><code>import time\n\ndef crawl_page(url):\n    print('crawling {}'.format(url))\n    sleep_time = int(url.split('_')[-1])\n    time.sleep(sleep_time)\n    print('OK {}'.format(url))\n\ndef main(urls):\n    for url in urls:\n        crawl_page(url)\n\n%time main(['url_1', 'url_2', 'url_3', 'url_4'])\n\n########## 输出 ##########\n\ncrawling url_1\nOK url_1\ncrawling url_2\nOK url_2\ncrawling url_3\nOK url_3\ncrawling url_4\nOK url_4\nWall time: 10 s\n</code></pre><p>（注意：本节的主要目的是协程的基础概念，因此我们简化爬虫的 scrawl_page 函数为休眠数秒，休眠时间取决于 url 最后的那个数字。）</p><p>这是一个很简单的爬虫，main() 函数执行时，调取 crawl_page() 函数进行网络通信，经过若干秒等待后收到结果，然后执行下一个。</p><p>看起来很简单，但你仔细一算，它也占用了不少时间，五个页面分别用了 1 秒到 4 秒的时间，加起来一共用了 10 秒。这显然效率低下，该怎么优化呢？</p><p>于是，一个很简单的思路出现了——我们这种爬取操作，完全可以并发化。我们就来看看使用协程怎么写。</p><pre><code>import asyncio\n\nasync def crawl_page(url):\n    print('crawling {}'.format(url))\n    sleep_time = int(url.split('_')[-1])\n    await asyncio.sleep(sleep_time)\n    print('OK {}'.format(url))\n\nasync def main(urls):\n    for url in urls:\n        await crawl_page(url)\n\n%time asyncio.run(main(['url_1', 'url_2', 'url_3', 'url_4']))\n\n########## 输出 ##########\n\ncrawling url_1\nOK url_1\ncrawling url_2\nOK url_2\ncrawling url_3\nOK url_3\ncrawling url_4\nOK url_4\nWall time: 10 s\n</code></pre><p>看到这段代码，你应该发现了，在 Python 3.7 以上版本中，使用协程写异步程序非常简单。</p><p>首先来看 import asyncio，这个库包含了大部分我们实现协程所需的魔法工具。</p><p>async 修饰词声明异步函数，于是，这里的 crawl_page 和 main 都变成了异步函数。而调用异步函数，我们便可得到一个协程对象（coroutine object）。</p><p>举个例子，如果你 <code>print(crawl_page(''))</code>，便会输出<code>&lt;coroutine object crawl_page at 0x000002BEDF141148&gt;</code>，提示你这是一个 Python 的协程对象，而并不会真正执行这个函数。</p><p>再来说说协程的执行。执行协程有多种方法，这里我介绍一下常用的三种。</p><p>首先，我们可以通过 await 来调用。await 执行的效果，和 Python 正常执行是一样的，也就是说程序会阻塞在这里，进入被调用的协程函数，执行完毕返回后再继续，而这也是 await 的字面意思。代码中 <code>await asyncio.sleep(sleep_time)</code> 会在这里休息若干秒，<code>await crawl_page(url)</code> 则会执行 crawl_page() 函数。</p><p>其次，我们可以通过 asyncio.create_task() 来创建任务，这个我们下节课会详细讲一下，你先简单知道即可。</p><p>最后，我们需要 asyncio.run 来触发运行。asyncio.run 这个函数是 Python 3.7 之后才有的特性，可以让 Python 的协程接口变得非常简单，你不用去理会事件循环怎么定义和怎么使用的问题（我们会在下面讲）。一个非常好的编程规范是，asyncio.run(main()) 作为主程序的入口函数，在程序运行周期内，只调用一次 asyncio.run。</p><p>这样，你就大概看懂了协程是怎么用的吧。不妨试着跑一下代码，欸，怎么还是 10 秒？</p><p>10 秒就对了，还记得上面所说的，await 是同步调用，因此， crawl_page(url) 在当前的调用结束之前，是不会触发下一次调用的。于是，这个代码效果就和上面完全一样了，相当于我们用异步接口写了个同步代码。</p><p>现在又该怎么办呢？</p><p>其实很简单，也正是我接下来要讲的协程中的一个重要概念，任务（Task）。老规矩，先看代码。</p><pre><code>import asyncio\n\nasync def crawl_page(url):\n    print('crawling {}'.format(url))\n    sleep_time = int(url.split('_')[-1])\n    await asyncio.sleep(sleep_time)\n    print('OK {}'.format(url))\n\nasync def main(urls):\n    tasks = [asyncio.create_task(crawl_page(url)) for url in urls]\n    for task in tasks:\n        await task\n\n%time asyncio.run(main(['url_1', 'url_2', 'url_3', 'url_4']))\n\n########## 输出 ##########\n\ncrawling url_1\ncrawling url_2\ncrawling url_3\ncrawling url_4\nOK url_1\nOK url_2\nOK url_3\nOK url_4\nWall time: 3.99 s\n</code></pre><p>你可以看到，我们有了协程对象后，便可以通过 <code>asyncio.create_task</code> 来创建任务。任务创建后很快就会被调度执行，这样，我们的代码也不会阻塞在任务这里。所以，我们要等所有任务都结束才行，用<code>for task in tasks: await task</code> 即可。</p><p>这次，你就看到效果了吧，结果显示，运行总时长等于运行时间最长的爬虫。</p><p>当然，你也可以想一想，这里用多线程应该怎么写？而如果需要爬取的页面有上万个又该怎么办呢？再对比下协程的写法，谁更清晰自是一目了然。</p><p>其实，对于执行 tasks，还有另一种做法：</p><pre><code>import asyncio\n\nasync def crawl_page(url):\n    print('crawling {}'.format(url))\n    sleep_time = int(url.split('_')[-1])\n    await asyncio.sleep(sleep_time)\n    print('OK {}'.format(url))\n\nasync def main(urls):\n    tasks = [asyncio.create_task(crawl_page(url)) for url in urls]\n    await asyncio.gather(*tasks)\n\n%time asyncio.run(main(['url_1', 'url_2', 'url_3', 'url_4']))\n\n########## 输出 ##########\n\ncrawling url_1\ncrawling url_2\ncrawling url_3\ncrawling url_4\nOK url_1\nOK url_2\nOK url_3\nOK url_4\nWall time: 4.01 s\n</code></pre><p>这里的代码也很好理解。唯一要注意的是，<code>*tasks</code> 解包列表，将列表变成了函数的参数；与之对应的是，  <code>** dict</code> 将字典变成了函数的参数。</p><p>另外，<code>asyncio.create_task</code>，<code>asyncio.run</code> 这些函数都是 Python 3.7 以上的版本才提供的，自然，相比于旧接口它们也更容易理解和阅读。</p><h2>解密协程运行时</h2><p>说了这么多，现在，我们不妨来深入代码底层看看。有了前面的知识做基础，你应该很容易理解这两段代码。</p><pre><code>import asyncio\n\nasync def worker_1():\n    print('worker_1 start')\n    await asyncio.sleep(1)\n    print('worker_1 done')\n\nasync def worker_2():\n    print('worker_2 start')\n    await asyncio.sleep(2)\n    print('worker_2 done')\n\nasync def main():\n    print('before await')\n    await worker_1()\n    print('awaited worker_1')\n    await worker_2()\n    print('awaited worker_2')\n\n%time asyncio.run(main())\n\n########## 输出 ##########\n\nbefore await\nworker_1 start\nworker_1 done\nawaited worker_1\nworker_2 start\nworker_2 done\nawaited worker_2\nWall time: 3 s\n</code></pre><pre><code>import asyncio\n\nasync def worker_1():\n    print('worker_1 start')\n    await asyncio.sleep(1)\n    print('worker_1 done')\n\nasync def worker_2():\n    print('worker_2 start')\n    await asyncio.sleep(2)\n    print('worker_2 done')\n\nasync def main():\n    task1 = asyncio.create_task(worker_1())\n    task2 = asyncio.create_task(worker_2())\n    print('before await')\n    await task1\n    print('awaited worker_1')\n    await task2\n    print('awaited worker_2')\n\n%time asyncio.run(main())\n\n########## 输出 ##########\n\nbefore await\nworker_1 start\nworker_2 start\nworker_1 done\nawaited worker_1\nworker_2 done\nawaited worker_2\nWall time: 2.01 s\n</code></pre><p>不过，第二个代码，到底发生了什么呢？为了让你更详细了解到协程和线程的具体区别，这里我详细地分析了整个过程。步骤有点多，别着急，我们慢慢来看。</p><ol>\n<li><code>asyncio.run(main())</code>，程序进入 main() 函数，事件循环开启；</li>\n<li>task1 和 task2 任务被创建，并进入事件循环等待运行；运行到 print，输出 <code>'before await'</code>；</li>\n<li>await task1 执行，用户选择从当前的主任务中切出，事件调度器开始调度 worker_1；</li>\n<li>worker_1 开始运行，运行 print 输出<code>'worker_1 start'</code>，然后运行到 <code>await asyncio.sleep(1)</code>， 从当前任务切出，事件调度器开始调度 worker_2；</li>\n<li>worker_2 开始运行，运行 print 输出 <code>'worker_2 start'</code>，然后运行 <code>await asyncio.sleep(2)</code> 从当前任务切出；</li>\n<li>以上所有事件的运行时间，都应该在 1ms 到 10ms 之间，甚至可能更短，事件调度器从这个时候开始暂停调度；</li>\n<li>一秒钟后，worker_1 的 sleep 完成，事件调度器将控制权重新传给 task_1，输出 <code>'worker_1 done'</code>，task_1 完成任务，从事件循环中退出；</li>\n<li>await task1 完成，事件调度器将控制器传给主任务，输出 <code>'awaited worker_1'</code>，·然后在 await task2 处继续等待；</li>\n<li>两秒钟后，worker_2 的 sleep 完成，事件调度器将控制权重新传给 task_2，输出 <code>'worker_2 done'</code>，task_2 完成任务，从事件循环中退出；</li>\n<li>主任务输出 <code>'awaited worker_2'</code>，协程全任务结束，事件循环结束。</li>\n</ol><p>接下来，我们进阶一下。如果我们想给某些协程任务限定运行时间，一旦超时就取消，又该怎么做呢？再进一步，如果某些协程运行时出现错误，又该怎么处理呢？同样的，来看代码。</p><pre><code>import asyncio\n\nasync def worker_1():\n    await asyncio.sleep(1)\n    return 1\n\nasync def worker_2():\n    await asyncio.sleep(2)\n    return 2 / 0\n\nasync def worker_3():\n    await asyncio.sleep(3)\n    return 3\n\nasync def main():\n    task_1 = asyncio.create_task(worker_1())\n    task_2 = asyncio.create_task(worker_2())\n    task_3 = asyncio.create_task(worker_3())\n\n    await asyncio.sleep(2)\n    task_3.cancel()\n\n    res = await asyncio.gather(task_1, task_2, task_3, return_exceptions=True)\n    print(res)\n\n%time asyncio.run(main())\n\n########## 输出 ##########\n\n[1, ZeroDivisionError('division by zero'), CancelledError()]\nWall time: 2 s\n</code></pre><p>你可以看到，worker_1 正常运行，worker_2 运行中出现错误，worker_3 执行时间过长被我们 cancel 掉了，这些信息会全部体现在最终的返回结果 res 中。</p><p>不过要注意<code>return_exceptions=True</code>这行代码。如果不设置这个参数，错误就会完整地 throw 到我们这个执行层，从而需要 try except 来捕捉，这也就意味着其他还没被执行的任务会被全部取消掉。为了避免这个局面，我们将 return_exceptions 设置为 True 即可。</p><p>到这里，发现了没，线程能实现的，协程都能做到。那就让我们温习一下这些知识点，用协程来实现一个经典的生产者消费者模型吧。</p><pre><code>import asyncio\nimport random\n\nasync def consumer(queue, id):\n    while True:\n        val = await queue.get()\n        print('{} get a val: {}'.format(id, val))\n        await asyncio.sleep(1)\n\nasync def producer(queue, id):\n    for i in range(5):\n        val = random.randint(1, 10)\n        await queue.put(val)\n        print('{} put a val: {}'.format(id, val))\n        await asyncio.sleep(1)\n\nasync def main():\n    queue = asyncio.Queue()\n\n    consumer_1 = asyncio.create_task(consumer(queue, 'consumer_1'))\n    consumer_2 = asyncio.create_task(consumer(queue, 'consumer_2'))\n\n    producer_1 = asyncio.create_task(producer(queue, 'producer_1'))\n    producer_2 = asyncio.create_task(producer(queue, 'producer_2'))\n\n    await asyncio.sleep(10)\n    consumer_1.cancel()\n    consumer_2.cancel()\n    \n    await asyncio.gather(consumer_1, consumer_2, producer_1, producer_2, return_exceptions=True)\n\n%time asyncio.run(main())\n\n########## 输出 ##########\n\nproducer_1 put a val: 5\nproducer_2 put a val: 3\nconsumer_1 get a val: 5\nconsumer_2 get a val: 3\nproducer_1 put a val: 1\nproducer_2 put a val: 3\nconsumer_2 get a val: 1\nconsumer_1 get a val: 3\nproducer_1 put a val: 6\nproducer_2 put a val: 10\nconsumer_1 get a val: 6\nconsumer_2 get a val: 10\nproducer_1 put a val: 4\nproducer_2 put a val: 5\nconsumer_2 get a val: 4\nconsumer_1 get a val: 5\nproducer_1 put a val: 2\nproducer_2 put a val: 8\nconsumer_1 get a val: 2\nconsumer_2 get a val: 8\nWall time: 10 s\n</code></pre><h2>实战：豆瓣近日推荐电影爬虫</h2><p>最后，进入今天的实战环节——实现一个完整的协程爬虫。</p><p>任务描述：<a href=\"https://movie.douban.com/cinema/later/beijing/\">https://movie.douban.com/cinema/later/beijing/</a> 这个页面描述了北京最近上映的电影，你能否通过 Python 得到这些电影的名称、上映时间和海报呢？这个页面的海报是缩小版的，我希望你能从具体的电影描述页面中抓取到海报。</p><p>听起来难度不是很大吧？我在下面给出了同步版本的代码和协程版本的代码，通过运行时间和代码写法的对比，希望你能对协程有更深的了解。（注意：为了突出重点、简化代码，这里我省略了异常处理。）</p><p>不过，在参考我给出的代码之前，你是不是可以自己先动手写一下、跑一下呢？</p><pre><code>import requests\nfrom bs4 import BeautifulSoup\n\ndef main():\n    url = &quot;https://movie.douban.com/cinema/later/beijing/&quot;\n    init_page = requests.get(url).content\n    init_soup = BeautifulSoup(init_page, 'lxml')\n\n    all_movies = init_soup.find('div', id=&quot;showing-soon&quot;)\n    for each_movie in all_movies.find_all('div', class_=&quot;item&quot;):\n        all_a_tag = each_movie.find_all('a')\n        all_li_tag = each_movie.find_all('li')\n\n        movie_name = all_a_tag[1].text\n        url_to_fetch = all_a_tag[1]['href']\n        movie_date = all_li_tag[0].text\n\n        response_item = requests.get(url_to_fetch).content\n        soup_item = BeautifulSoup(response_item, 'lxml')\n        img_tag = soup_item.find('img')\n\n        print('{} {} {}'.format(movie_name, movie_date, img_tag['src']))\n\n%time main()\n\n########## 输出 ##########\n\n阿拉丁 05月24日 https://img3.doubanio.com/view/photo/s_ratio_poster/public/p2553992741.jpg\n龙珠超：布罗利 05月24日 https://img3.doubanio.com/view/photo/s_ratio_poster/public/p2557371503.jpg\n五月天人生无限公司 05月24日 https://img3.doubanio.com/view/photo/s_ratio_poster/public/p2554324453.jpg\n... ...\n直播攻略 06月04日 https://img3.doubanio.com/view/photo/s_ratio_poster/public/p2555957974.jpg\nWall time: 56.6 s\n</code></pre><pre><code>import asyncio\nimport aiohttp\n\nfrom bs4 import BeautifulSoup\n\nasync def fetch_content(url):\n    async with aiohttp.ClientSession(\n        headers=header, connector=aiohttp.TCPConnector(ssl=False)\n    ) as session:\n        async with session.get(url) as response:\n            return await response.text()\n\nasync def main():\n    url = &quot;https://movie.douban.com/cinema/later/beijing/&quot;\n    init_page = await fetch_content(url)\n    init_soup = BeautifulSoup(init_page, 'lxml')\n\n    movie_names, urls_to_fetch, movie_dates = [], [], []\n\n    all_movies = init_soup.find('div', id=&quot;showing-soon&quot;)\n    for each_movie in all_movies.find_all('div', class_=&quot;item&quot;):\n        all_a_tag = each_movie.find_all('a')\n        all_li_tag = each_movie.find_all('li')\n\n        movie_names.append(all_a_tag[1].text)\n        urls_to_fetch.append(all_a_tag[1]['href'])\n        movie_dates.append(all_li_tag[0].text)\n\n    tasks = [fetch_content(url) for url in urls_to_fetch]\n    pages = await asyncio.gather(*tasks)\n\n    for movie_name, movie_date, page in zip(movie_names, movie_dates, pages):\n        soup_item = BeautifulSoup(page, 'lxml')\n        img_tag = soup_item.find('img')\n\n        print('{} {} {}'.format(movie_name, movie_date, img_tag['src']))\n\n%time asyncio.run(main())\n\n########## 输出 ##########\n\n阿拉丁 05月24日 https://img3.doubanio.com/view/photo/s_ratio_poster/public/p2553992741.jpg\n龙珠超：布罗利 05月24日 https://img3.doubanio.com/view/photo/s_ratio_poster/public/p2557371503.jpg\n五月天人生无限公司 05月24日 https://img3.doubanio.com/view/photo/s_ratio_poster/public/p2554324453.jpg\n... ...\n直播攻略 06月04日 https://img3.doubanio.com/view/photo/s_ratio_poster/public/p2555957974.jpg\nWall time: 4.98 s\n</code></pre><h2>总结</h2><p>到这里，今天的主要内容就讲完了。今天我用了较长的篇幅，从一个简单的爬虫开始，到一个真正的爬虫结束，在中间穿插讲解了 Python 协程最新的基本概念和用法。这里带你简单复习一下。</p><ul>\n<li>协程和多线程的区别，主要在于两点，一是协程为单线程；二是协程由用户决定，在哪些地方交出控制权，切换到下一个任务。</li>\n<li>协程的写法更加简洁清晰，把async / await 语法和 create_task 结合来用，对于中小级别的并发需求已经毫无压力。</li>\n<li>写协程程序的时候，你的脑海中要有清晰的事件循环概念，知道程序在什么时候需要暂停、等待 I/O，什么时候需要一并执行到底。</li>\n</ul><p>最后的最后，请一定不要轻易炫技。多线程模型也一定有其优点，一个真正牛逼的程序员，应该懂得，在什么时候用什么模型能达到工程上的最优，而不是自觉某个技术非常牛逼，所有项目创造条件也要上。技术是工程，而工程则是时间、资源、人力等纷繁复杂的事情的折衷。</p><h2>思考题</h2><p>最后给你留一个思考题。协程怎么实现回调函数呢？欢迎留言和我讨论，也欢迎你把这篇文章分享给你的同事朋友，我们一起交流，一起进步。</p><p></p>","comments":[{"had_liked":false,"id":106989,"user_name":"Jingxiao","can_delete":false,"product_type":"c1","uid":1259521,"ip_address":"","ucode":"EB966BB87132F6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","comment_is_top":true,"comment_ctime":1561433504,"is_pvip":false,"discussion_count":10,"race_medal":0,"score":"9.2233723390639002e+18","product_id":100026901,"comment_content":"发现评论区好多朋友说无法运行，在这里统一解释下：<br>1. %time 是 jupyter notebook 自带的语法糖，用来统计一行命令的运行时间；如果你的运行时是纯粹的命令行 python，或者 pycharm，那么请把 %time 删掉，自己用传统的时间戳方法来记录时间也可以；或者使用 jupyter notebook<br>2. 我的本地解释器是 Anaconda Python 3.7.3，亲测 windows &#47; ubuntu 均可正常运行，如无法执行可以试试 pip install nest-asyncio，依然无法解决请尝试安装 Anaconda Python<br>3. 这次代码因为使用了较新的 API，所以需要较新的版本号，但是朋友们依然出现了一些运行时问题，这里先表示下歉意；同时也想说明的是，在提问之前自己经过充分搜索，尝试后解决问题，带来的快感，和能力的提升，相应也是很大的，一门工程最需要的是 hands on dirty work（动手做脏活），才能让自己的能力得到本质的提升，加油！","like_count":70,"discussions":[{"author":{"id":1297523,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cc/73/9c41a7ee.jpg","nickname":"雷蒙德张","note":"","ucode":"0104F5818EA7F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":262626,"discussion_content":"我是Mac, 在jupyter notebook还是遇到了“RuntimeError: asyncio.run() cannot be called from a running event loop”的问题，我试了几种方法，最后通过安装nest-asyncio解决了：\n1. 在机器上安装nest-asyncio模块：pip install nest-asyncio\n2. 在代码块的开头加上\n    import nest_asyncio\n    nest_asyncio.apply()\n3. 可以正常运行带语法糖的语句：%time asyncio.run(main([&#39;url_1&#39;, &#39;url_2&#39;, &#39;url_3&#39;, &#39;url_4&#39;]))","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1589118273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2281842,"avatar":"","nickname":"Geek_97cfce","note":"","ucode":"4FA103B707B78D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1297523,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cc/73/9c41a7ee.jpg","nickname":"雷蒙德张","note":"","ucode":"0104F5818EA7F3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332979,"discussion_content":"確實有用，謝謝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607407160,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":262626,"ip_address":""},"score":332979,"extra":""}]},{"author":{"id":1087879,"avatar":"https://static001.geekbang.org/account/avatar/00/10/99/87/98ebb20e.jpg","nickname":"dao","note":"","ucode":"4181FB270462CF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328113,"discussion_content":"如果在 jupyter 里报错 “asyncio.run() cannot be called from a running event loop\n”，是因为高版本 ipython (>7.0) 已经运行了异步事件循环，使用 asyncio.run() 导致异步事件循环嵌套。解决方式参考https://stackoverflow.com/questions/55409641/asyncio-run-cannot-be-called-from-a-running-event-loop 和https://blog.jupyter.org/ipython-7-0-async-repl-a35ce050f7f7。\n说白了，就是直接 await man()，然后用 perf_counter() 计算运行时间。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1606058509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1277066,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7c/8a/bdeb76ac.jpg","nickname":"Fergus","note":"","ucode":"3A8AC741C49CEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433,"discussion_content":"感谢老师指点：“，一门工程最需要的是 hands on dirty work（动手做脏活），才能让自己的能力得到本质的提升”","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1561554353,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1141751,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6b/f7/3a3b82c2.jpg","nickname":"Aspirin","note":"","ucode":"858B551CF0C2F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1687,"discussion_content":"在JupyterNotebook中运行%time asyncio.run(main([&#39;url_1&#39;, &#39;url_2&#39;, &#39;url_3&#39;, &#39;url_4&#39;]))直接报错：RuntimeError: asyncio.run() cannot be called from a running event loop。请问大家是怎么运行的？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1562815766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1319215,"avatar":"https://static001.geekbang.org/account/avatar/00/14/21/2f/b29e8af8.jpg","nickname":"轻风悠扬","note":"","ucode":"F2276CE113BED1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1141751,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6b/f7/3a3b82c2.jpg","nickname":"Aspirin","note":"","ucode":"858B551CF0C2F4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":264028,"discussion_content":"按照雷蒙德张的回答我本机就能运行了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589282524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":1687,"ip_address":""},"score":264028,"extra":""}]},{"author":{"id":1511147,"avatar":"https://static001.geekbang.org/account/avatar/00/17/0e/eb/2f3c9feb.jpg","nickname":"c2ccpy2go2rs","note":"","ucode":"8569E4625A5E01","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5245,"discussion_content":"安装了Anaconda python 3.7.3, 还是不可以运行哎","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566113322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1268609,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epbyHPGNLu9sDQOs1V6brMcDwia55pyIlP9n62oO6IYS6kIFDnOSON4ugSeBSy6WhDUnYyJC6vtnHQ/132","nickname":"lcqbug","note":"","ucode":"08FA17F21BCEC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273506,"discussion_content":".pycharm  python 3.7.4,程序执行，AppData\\Local\\Continuum\\anaconda3\\lib\\asyncio\\events.py:88: RuntimeWarning: coroutine &#39;crawl_page&#39; was never awaited\n  self._context.run(self._callback, *self._args)\n\n代码如下import asyncio\n\n\nasync def crawl_page(url):\n    print(&#39;crawling {}&#39;.format(url))\n    sleep_time = int(url.split(&#39;_&#39;)[-1])\n    await asyncio.sleep(sleep_time)\n    print(&#39;OK {}&#39;.format(url))\n\n\nasync def main(urls):\n    tasks = [asyncio.create_task(crawl_page(url) for url in urls)]\n    for task in tasks:\n        await task\n\n\nurls = [&#39;url_&#39; + str(i) for i in range(1, 5)]\nasyncio.run(main(urls))","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590464851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2480331,"avatar":"https://static001.geekbang.org/account/avatar/00/25/d8/cb/12a9bd21.jpg","nickname":"While_True","note":"","ucode":"B94F9550C8197A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1268609,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epbyHPGNLu9sDQOs1V6brMcDwia55pyIlP9n62oO6IYS6kIFDnOSON4ugSeBSy6WhDUnYyJC6vtnHQ/132","nickname":"lcqbug","note":"","ucode":"08FA17F21BCEC5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381686,"discussion_content":"楼主main中的tasks = [asyncio.create_task(crawl_page(url) for url in urls)]应该为tasks = [asyncio.create_task(crawl_page(url)) for url in urls]","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625186911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":273506,"ip_address":""},"score":381686,"extra":""}]},{"author":{"id":1187197,"avatar":"https://static001.geekbang.org/account/avatar/00/12/1d/7d/368df396.jpg","nickname":"somenzz","note":"","ucode":"EA59A170DF8910","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":16341,"discussion_content":"老师，我在使用协程时发现创建的 task 数目不能超过500，这个 task 的数目是由什么控制的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568886186,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109065,"user_name":"Jingxiao","can_delete":false,"product_type":"c1","uid":1259521,"ip_address":"","ucode":"EB966BB87132F6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","comment_is_top":true,"comment_ctime":1561954729,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"9.2233721930355999e+18","product_id":100026901,"comment_content":"思考题答案：<br><br>在 python 3.7 及以上的版本中，我们对 task 对象调用 add_done_callback() 函数，即可绑定特定回调函数。回调函数接受一个 future 对象，可以通过 future.result() 来获取协程函数的返回值。<br><br>示例如下：<br><br>import asyncio<br><br>async def crawl_page(url):<br>    print(&#39;crawling {}&#39;.format(url))<br>    sleep_time = int(url.split(&#39;_&#39;)[-1])<br>    await asyncio.sleep(sleep_time)<br>    return &#39;OK {}&#39;.format(url)<br><br>async def main(urls):<br>    tasks = [asyncio.create_task(crawl_page(url)) for url in urls]<br>    for task in tasks:<br>        task.add_done_callback(lambda future: print(&#39;result: &#39;, future.result()))<br>    await asyncio.gather(*tasks)<br><br>%time asyncio.run(main([&#39;url_1&#39;, &#39;url_2&#39;, &#39;url_3&#39;, &#39;url_4&#39;]))<br><br>输出：<br><br>crawling url_1<br>crawling url_2<br>crawling url_3<br>crawling url_4<br>result:  OK url_1<br>result:  OK url_2<br>result:  OK url_3<br>result:  OK url_4<br>Wall time: 4 s","like_count":36},{"had_liked":false,"id":107881,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1105161,"ip_address":"","ucode":"1EECCA0F43E278","user_header":"https://static001.geekbang.org/account/avatar/00/10/dd/09/feca820a.jpg","comment_is_top":false,"comment_ctime":1561628396,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"254964698860","product_id":100026901,"comment_content":"说一下我对await的理解：<br>开发者要提前知道一个任务的哪个环节会造成I&#47;O阻塞，然后把这个环节的代码异步化处理，并且通过await来标识在任务的该环节中断该任务执行，从而去执行下一个事件循环任务。这样可以充分利用CPU资源，避免CPU等待I&#47;O造成CPU资源白白浪费。当之前任务的那个环节的I&#47;O完成后，线程可以从await获取返回值，然后继续执行没有完成的剩余代码。<br>由上面分析可知，如果一个任务不涉及到网络或磁盘I&#47;O这种耗时的操作，而只有CPU计算和内存I&#47;O的操作时，协程并发的性能还不如单线程loop循环的性能高。","like_count":59,"discussions":[{"author":{"id":1433812,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e0/d4/bdd3ed27.jpg","nickname":"converse✪","note":"","ucode":"0CC4C24A6458B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1439,"discussion_content":"嗯，表示赞同。我的理解是在协程中程序员是系统的调度中心，我们已经知道哪里有IO开销大的地方，主动放弃控制权给其他函数来执行。","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1562634414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1110662,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f2/86/d689f77e.jpg","nickname":"Hank_Yan","note":"","ucode":"86899B561C502B","race_medal":3,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575328,"discussion_content":"说的很对，趟过坑了，计算密集型，我滥用了协程，效率一塌糊涂。最后又改成 mutiprocess 处理了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1654753433,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1519200,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2e/60/4fa1f3bd.jpg","nickname":"rs勿忘初心","note":"","ucode":"557D1ECD757195","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411732,"discussion_content":"mark一下，await作用说的算是比较清晰易懂了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635990638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1897395,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f3/b3/0ba7a760.jpg","nickname":"一凡","note":"","ucode":"5E9BE33452AF3B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284193,"discussion_content":"就是密集IO","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592469583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1371633,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqyicZYyW7ahaXgXUD8ZAS8x0t8jx5rYLhwbUCJiawRepKIZfsLdkxdQ9XQMo99c1UDibmNVfFnAqwPg/132","nickname":"程序水果宝","note":"","ucode":"1700DDFE073A56","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75674,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575764311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1484184,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","nickname":"djfhchdh","note":"","ucode":"E71D75328CE398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":15938,"discussion_content":"说的很对，学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568862201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107965,"user_name":"Wing·三金","can_delete":false,"product_type":"c1","uid":1341402,"ip_address":"","ucode":"6B9F5822C3717F","user_header":"https://static001.geekbang.org/account/avatar/00/14/77/da/54c663f3.jpg","comment_is_top":false,"comment_ctime":1561641794,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"156180464450","product_id":100026901,"comment_content":"思考题：简单的理解是每个新建的协程对象都会自动调用 add_done_callback() 函数来添加一个回调函数，当协程对象的 Future 状态启动时就会调用该回调函数，从而实现回调。<br><br>综合下前面的留言和个人的学习，总结下 py 3.6 版本下 asyncio 的主要不同：<br>1、没有 run(), create_task()，可以用 asyncio.get_even_loop().run_until_complete() 来代替 run()，用 ensure_future() 来代替 create_task()；<br>2、可能会出现 RuntimeError: This event loop is already running，解决方案一：pip install nest_asyncio; import nest_asyncio; nest_asyncio.apply()；解决方案二：有些友人说是 tornado 5.x 起的版本才有此问题，可考虑将其版本降至 4.x（不推荐）；<br>3、%time 与 %%time 的主要区别：%time func()（必须是同一行）；%%time 必须放在单元格的开头，强烈建议单独一行 + 不要与 import、def 相关的语句放在同个单元格；<br>4、爬虫中的 aiohttp.ClientSession(headers=header, connector=aiohttp.TCPConnector(ssl=False)) 提及未声明的 header，要么将 headers=header 部分去掉使用默认参数，要么用诸如 header={&quot;User-Agent&quot;: &quot;Mozilla&#47;5.0 (Windows NT 6.1; Win64; x64) AppleWebKit&#47;537.36 (KHTML, like Gecko) Chrome&#47;74.0.3729.157 Safari&#47;537.36&quot;} 来显式声明；<br>5、tasks = [asyncio.create_task(crawl_page(url)) for url in urls]; await asyncio.gather(*tasks); <br>约等于<br>tasks = [crawl_page(url) for url in urls]; asyncio.get_even_loop().run_until_complete(asyncio.wait(tasks));<br>或<br>tasks = [asyncio.ensure_future(crawl_page(url)) for url in urls]; await asyncio.gather(*tasks);","like_count":36,"discussions":[{"author":{"id":1657039,"avatar":"https://static001.geekbang.org/account/avatar/00/19/48/cf/8c88e6c0.jpg","nickname":"Nemo","note":"","ucode":"2B11D18D6FA2AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":236894,"discussion_content":"解决了代码中的疑惑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587128599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158475,"user_name":"大侠110","can_delete":false,"product_type":"c1","uid":1134087,"ip_address":"","ucode":"F058B3AACC5394","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/07/78441c2b.jpg","comment_is_top":false,"comment_ctime":1575379820,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"147604267884","product_id":100026901,"comment_content":"感觉还是有很多人看不懂，我试着用通俗的语句讲一下：协成里面重要的是一个关键字await的理解，async表示其修饰的是协程任务即task，await表示的是当线程执行到这一句，此时该task在此处挂起，然后调度器去执行其他的task，当这个挂起的部分处理完，会调用回掉函数告诉调度器我已经执行完了，那么调度器就返回来处理这个task的余下语句。<br>      ","like_count":34,"discussions":[{"author":{"id":2628384,"avatar":"","nickname":"Geek_3f3a6d","note":"","ucode":"75B7157CFE0657","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375375,"discussion_content":"很形象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621592614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107046,"user_name":"cuikt","can_delete":false,"product_type":"c1","uid":1242702,"ip_address":"","ucode":"9A1DB426CEFEEA","user_header":"https://static001.geekbang.org/account/avatar/00/12/f6/4e/0066303c.jpg","comment_is_top":false,"comment_ctime":1561447574,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"87460793494","product_id":100026901,"comment_content":"在代码async with aiohttp.ClientSession(headers=header, connector=aiohttp.TCPConnector(ssl=False)) as session:中的headers=header需要定义header为一个字典可以像下面这样，否则会报错。<br>header={&quot;User-Agent&quot;: &quot;Mozilla&#47;5.0 (Windows NT 6.1; Win64; x64) AppleWebKit&#47;537.36 (KHTML, like Gecko) Chrome&#47;74.0.3729.157 Safari&#47;537.36&quot;}","like_count":20,"discussions":[{"author":{"id":2041989,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/28/85/3ae5efed.jpg","nickname":"Silence°","note":"","ucode":"1782A115C603FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387528,"discussion_content":"大佬，我添加了header后还是报错：\nAttributeError: &#39;NoneType&#39; object has no attribute &#39;find_all&#39;\nRuntimeError: Event loop is closed\n麻烦给指点一下！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628234808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106992,"user_name":"rogerr","can_delete":false,"product_type":"c1","uid":1538280,"ip_address":"","ucode":"735EE845D4560F","user_header":"https://static001.geekbang.org/account/avatar/00/17/78/e8/b79240e8.jpg","comment_is_top":false,"comment_ctime":1561433680,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"70280910416","product_id":100026901,"comment_content":"目前看到进阶篇就很痛苦了，对于小白来说，基础篇还好理解，到这儿就对深层次的知识无法深入理解和实践，感觉渐行渐远，不知道如何深入下去","like_count":16,"discussions":[{"author":{"id":1260182,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3a/96/9fddfb4a.jpg","nickname":"赵鹏举","note":"","ucode":"B3785788D6176C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1295,"discussion_content":"看看《流畅的Python》，这些都好懂","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1562515972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1519200,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2e/60/4fa1f3bd.jpg","nickname":"rs勿忘初心","note":"","ucode":"557D1ECD757195","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411731,"discussion_content":"第一次接触这些概念是比较难理解，日常工作中可能用的也不是很多，持续坚持，多看多动手，时间长了慢慢就会理解了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635990439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1352275,"avatar":"https://static001.geekbang.org/account/avatar/00/14/a2/53/30c38cfa.jpg","nickname":"暖暖的大白","note":"","ucode":"BAB3905768EE0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1756,"discussion_content":"我也是小白，但还是似懂非懂地继续看下去，最起码有了大概了解。随着学习的深入，然后返回来仔细研读。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1562894601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1221991,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a5/67/bf286335.jpg","nickname":"AllenGFLiu","note":"","ucode":"90FA8A619A2629","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":599,"discussion_content":"此课程要求有一定基础，如果0基础，建议先看廖雪峰的Python教程以及极客时间另外那篇Python基础教程，待有一定了解之后再回过头来看这个，会觉得&#34;真香&#34;。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1561775615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1895499,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/ec/4b/442dd5f1.jpg","nickname":"及時行樂","note":"","ucode":"2FD0E0BB8327DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260861,"discussion_content":"建议看看底层操作系统，之后无论看什么代码，最终的核心还是一样的，只是经历了一层层的封装","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588908506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1440141,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f9/8d/751607fc.jpg","nickname":"rhyme","note":"","ucode":"F103E5B61B6D84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42957,"discussion_content":"感觉还是应该先看看基础，这个直接看真是费劲","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572835409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1201009,"avatar":"https://static001.geekbang.org/account/avatar/00/12/53/71/a4e9f20e.jpg","nickname":"言午木杉","note":"","ucode":"300BEDC1B07DF1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":30074,"discussion_content":"多看多写","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570798202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106579,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1561347674,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"44511020634","product_id":100026901,"comment_content":"学习笔记:异步和阻塞。<br><br>阻塞主要是同步编程中的概念:执行一个系统调用，如果暂时没有返回结果，这个调用就不会返回，那这个系统调用后面的应用代码也不会执行，整个应用被“阻塞”了。<br><br>同步编程也可以有非阻塞的方式，在系统调用没有完成时直接返回一个错误码。<br><br>异步调用是系统调用完成后返回应用一个消息，应用响应消息，获取结果。<br><br>上面说的系统调用 对应Python中的异步函数——一个需要执行较长时间的任务。响应消息应该对应回调函数，但我觉得await异步函数返回本身就相当于系统告知应用系统调用完成了，后面的代码起码可以完成部分回调函数做的事情。<br><br>阻塞和异步必须配合才能完成异步编程。<br><br>1、await异步函数会造成阻塞;<br>2、await一个task不会造成阻塞，但是task对应的异步函数中必定几乎await一个异步函数，这个异步函数会阻塞这个task的执行，这样其余task才能被事件调度器的调度从而获取执行机会。","like_count":10,"discussions":[{"author":{"id":1433812,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e0/d4/bdd3ed27.jpg","nickname":"converse✪","note":"","ucode":"0CC4C24A6458B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1445,"discussion_content":"await异步函数会造成阻塞。这句话感觉不对，这里await后一般是不能及时返回的耗时操作，用于await是将控制权交出以供其他协程使用。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1562635516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1105161,"avatar":"https://static001.geekbang.org/account/avatar/00/10/dd/09/feca820a.jpg","nickname":"helloworld","note":"","ucode":"1EECCA0F43E278","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512,"discussion_content":"对await理解的不对。\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1561628206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111927,"user_name":"converse✪","can_delete":false,"product_type":"c1","uid":1433812,"ip_address":"","ucode":"0CC4C24A6458B6","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/d4/bdd3ed27.jpg","comment_is_top":false,"comment_ctime":1562638607,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31627409679","product_id":100026901,"comment_content":"#coding:utf-8<br>import asyncio<br>import time<br><br>async def corou1():<br>    print(&quot;corou 1, {}&quot;.format(time.perf_counter()))<br>    await asyncio.sleep(2) <br>    print(&quot;corou 1, {}&quot;.format(time.perf_counter()))<br>    <br>async def corou2():<br>    print(&quot;corou 2, {}&quot;.format(time.perf_counter()))<br>    # await asyncio.sleep(2)<br>    time.sleep(5) <br>    print(&quot;corou 2, {}&quot;.format(time.perf_counter()))<br><br>async def corou3():<br>    print(&quot;corou 3, {}&quot;.format(time.perf_counter()))<br>    await asyncio.sleep(2) <br>    print(&quot;corou 3, {}&quot;.format(time.perf_counter()))<br><br>async def main():<br>    tasks = [asyncio.create_task(corou())for corou in [corou1,corou2,corou3] ]<br>    await asyncio.gather(*tasks)<br><br>if __name__ == &quot;__main__&quot;:<br>    asyncio.run(main())<br>###########执行结果############<br>func 1, 0.3864962<br>func 2, 0.3866095<br>func 2, 5.386688<br>func 3, 5.387335<br>func 1, 5.3877248<br>func 3, 7.3883411<br><br>通过上述例子可以看出，协程corou1，corou2，corou3的执行顺序按照加入循环事件的顺序。协程corou1 通过 await asyncio.sleep(2) 让出控制权，协程corou2由于没有await让出控制权所以一直在执行。当corou2结束后，很显然corou1也已经执行完，但还是先执行协程corou3，等协程corou3通过await让出控制权后，协程corou1才执行。<br><br>从上可以看出：<br>- 协程是按照事件循环顺序执行。即使交出控制权的协程执行完毕任务后等待再次获取控制权完成剩余任务，也必须等到循环到该协程才能获得CPU控制权。不会由于该协程已经完成await的任务而直接给它。这就是解释，协程corou2执行完会继续执行协程corou3，而并非继续执行协程corou1。<br>- await是交出协程控制权的地方<br>- 从上述代码可以看出，协程中当执行耗时IO操作时，应及时释放控制权，否则其他协程即便完成任务也由于没有CPU控制权而无法继续执行任务。","like_count":7},{"had_liked":false,"id":207941,"user_name":"Airnm.毁","can_delete":false,"product_type":"c1","uid":1938171,"ip_address":"","ucode":"921B246633F8CF","user_header":"https://static001.geekbang.org/account/avatar/00/1d/92/fb/4c06bcef.jpg","comment_is_top":false,"comment_ctime":1587219898,"is_pvip":false,"replies":[{"id":"84950","content":"👍，可能是增加了反爬虫机制<br>","user_name":"作者回复","user_name_real":"高山流水","uid":"1513504","ctime":1593302072,"ip_address":"","comment_id":207941,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27357023674","product_id":100026901,"comment_content":"豆瓣那个发现requests.get(url).content&#47;text返回都为空，然后打了下status_code发现是418，网上找418的解释，一般是网站反爬虫基础机制，需要加请求头模仿浏览器就可跳过，改为下面的样子就可通过：url = &quot;https:&#47;&#47;movie.douban.com&#47;cinema&#47;later&#47;beijing&#47;&quot;<br>head={<br>    &#39;User-Agent&#39;:&#39;Mozilla&#47;5.0 (Windows NT 6.1; Win64; x64) AppleWebKit&#47;537.36 (KHTML, like Gecko) Chrome&#47;81.0.4044.113 Safari&#47;537.36&#39;,<br>    &#39;Referer&#39;:&#39;https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;101855&#39;,<br>    &#39;Connection&#39;:&#39;keep-alive&#39;}<br>res = requests.get(url,headers=head)","like_count":6,"discussions":[{"author":{"id":1513504,"avatar":"https://static001.geekbang.org/account/avatar/00/17/18/20/75ea3b20.jpg","nickname":"高山流水","note":"","ucode":"71E513B5937481","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492287,"discussion_content":"👍，可能是增加了反爬虫机制\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593302072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2041989,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/28/85/3ae5efed.jpg","nickname":"Silence°","note":"","ucode":"1782A115C603FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387536,"discussion_content":"按这个方式添加完还是不行啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628237053,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108367,"user_name":"Fergus","can_delete":false,"product_type":"c1","uid":1277066,"ip_address":"","ucode":"3A8AC741C49CEB","user_header":"https://static001.geekbang.org/account/avatar/00/13/7c/8a/bdeb76ac.jpg","comment_is_top":false,"comment_ctime":1561730031,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"27331533807","product_id":100026901,"comment_content":"# -*- encoding: utf-8 -*-<br>&#39;&#39;&#39;<br>aiohttp + aysncio爬取电豆瓣电影<br>py 3.6<br>sublime text3<br>&#39;&#39;&#39;<br><br><br>import time<br>import aiohttp<br>import asyncio<br>from bs4 import BeautifulSoup<br><br>now = lambda: time.perf_counter()<br><br>async def fetchHtmlText(url):<br>    async with aiohttp.ClientSession(<br>        headers={&#39;users-agent&#39;:&#39;Mozilla&#47;5.0&#39;}, <br>        connector=aiohttp.TCPConnector(ssl=False)) as session:<br>        async with session.get(url) as response:<br>            return await response.text()<br><br>async def main():<br>    url = &quot;https:&#47;&#47;movie.douban.com&#47;cinema&#47;later&#47;beijing&#47;&quot;<br>    html = await fetchHtmlText(url)<br>    soup = BeautifulSoup(html, &quot;html.parser&quot;)<br><br>    divs = soup.find_all(&#39;div&#39;, class_=&#39;item mod&#39;)<br>    urls = list(map(lambda x: x.a.img[&#39;src&#39;], divs))<br>    names = list(map(lambda x: x.h3.a.string, divs))<br>    dats = list(map(lambda x: x.ul.li.string, divs))<br><br>    lis = zip(names, dats, urls)<br>    for i in lis:<br>        print(&quot;{0:{3}^25} \\t {1:{3}^10} \\t {2:{3}^}&quot;.format(i[0], i[1], i[2],chr(12288)))<br><br><br>start = now()<br>loop = asyncio.get_event_loop()<br>loop.run_until_complete(main())<br>print(&quot;Wall time: {}&quot;.format(now() - start))<br><br><br># 九龙不败　　　　　　　　　　　　　　　　　　　　　    　　07月02日　　      https:&#47;&#47;img3.doubanio.com&#47;view&#47;photo&#47;s_ratio_poster&#47;public&#47;p2560169035.jpg<br># 别岁　　　　　　　　　　　　　　　　　　　　　　　    　　07月02日　　      https:&#47;&#47;img3.doubanio.com&#47;view&#47;photo&#47;s_ratio_poster&#47;public&#47;p2558138041.jpg<br>...<br># 刀背藏身　　　　　　　　　　　　　　　　　　　　　    　　07月19日　　      https:&#47;&#47;img1.doubanio.com&#47;view&#47;photo&#47;s_ratio_poster&#47;public&#47;p2557644589.jpg<br># Wall time: 1.994356926937086<br># [Finished in 3.7s]<br>","like_count":6,"discussions":[{"author":{"id":2041989,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/28/85/3ae5efed.jpg","nickname":"Silence°","note":"","ucode":"1782A115C603FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387545,"discussion_content":"lis输出是<zip object at 0x000002391355F4C0>，使用for循环出不来数据，为空。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628238278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2041989,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/28/85/3ae5efed.jpg","nickname":"Silence°","note":"","ucode":"1782A115C603FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387543,"discussion_content":"大佬，我按你这个执行完为啥只输出了执行时间。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628237942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":210277,"user_name":"向左看齐","can_delete":false,"product_type":"c1","uid":1764941,"ip_address":"","ucode":"2E0AC7D59AF85C","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ee/4d/5d021e4c.jpg","comment_is_top":false,"comment_ctime":1587711743,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"23062548223","product_id":100026901,"comment_content":"    for each_movie in all_movies.find_all(&#39;div&#39;, class_=&quot;item&quot;):<br><br>AttributeError: &#39;NoneType&#39; object has no attribute &#39;find_all&#39;<br>执行报错，有没有人和我一样的问题？请指教","like_count":5,"discussions":[{"author":{"id":1919541,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/4a/35/66caeed9.jpg","nickname":"完美坚持","note":"","ucode":"AE0261D8DDEF64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310234,"discussion_content":"我刚开始报错：\nfor each_movie in all_movies.find_all(&#39;div&#39;, class_=&#34;item&#34;):\n\nAttributeError: &#39;NoneType&#39; object has no attribute &#39;find_all&#39;\n----\n后来我通过改和查\n我运行成功了，问题在于\ninit_page = requests.get(url, headers={&#39;User-Agent&#39;:&#39;test&#39;}).content\n和\nresponse_item = requests.get(url_to_fetch, headers={&#39;User-Agent&#39;:&#39;test&#39;}).content\n的\n requests.get(url).content\n那里，注意原来的是没有 , headers={&#39;User-Agent&#39;:&#39;test&#39;} 这个部分的，我查了一下Stack Overflow，里面说到\nYou must send any user agent:\nimport requests\nr = requests.get(&#39;http://example.com/m7ppct4&#39;,  headers={&#39;User-Agent&#39;:&#39;test&#39;})\n\n可能是我们必须要加一个所谓的 user agent，我猜或许是为了让网站认为这是一个用户的请求，而不是某个爬虫要爬取它的信息，所以加一个user agent 让它误以为我们的爬虫使用户，从而给我们开放 get 权限\n可以查看\nhttps://stackoverflow.com/questions/25491872/request-geturl-returns-empty-content","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1601699652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":3020434,"avatar":"","nickname":"Geek_d4ab3d","note":"","ucode":"B57E178ABFBB80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1919541,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/4a/35/66caeed9.jpg","nickname":"完美坚持","note":"","ucode":"AE0261D8DDEF64","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576099,"discussion_content":"实践可用\nimport requests\nfrom bs4 import BeautifulSoup\n\n\ndef main():\n    url = &#34;https://movie.douban.com/cinema/later/beijing/&#34;\n    head = {&#39;User-Agent&#39;: &#39;test&#39;}\n    # requests请求一定要带headers\n    init_page = requests.get(url, headers=head).content\n    init_soup = BeautifulSoup(init_page, &#39;lxml&#39;)\n\n    all_movies = init_soup.find(&#39;div&#39;, id=&#34;showing-soon&#34;)\n    all_movies = all_movies.find_all(&#39;div&#39;, class_=&#34;item&#34;)\n    for each_movie in all_movies:\n        all_a_tag = each_movie.find_all(&#39;a&#39;)\n        all_li_tag = each_movie.find_all(&#39;li&#39;)\n\n        movie_name = all_a_tag[1].text\n        url_to_fetch = all_a_tag[1][&#39;href&#39;]\n        movie_date = all_li_tag[0].text\n\n        # requests请求一定要带headers\n        response_item = requests.get(url_to_fetch, headers=head).content\n        soup_item = BeautifulSoup(response_item, &#39;lxml&#39;)\n        img_tag = soup_item.find(&#39;img&#39;)\n\n        print(&#39;{} {} {}&#39;.format(movie_name, movie_date, img_tag[&#39;src&#39;]))\n\n\nmain()","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1655277497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":310234,"ip_address":""},"score":576099,"extra":""}]},{"author":{"id":1919541,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/4a/35/66caeed9.jpg","nickname":"完美坚持","note":"","ucode":"AE0261D8DDEF64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310222,"discussion_content":"我也是这样，但是不太清楚为什么。不知道是不是 all_movies 赋值那里\n all_movies = init_soup.find(&#39;div&#39;, id=&#34;showing-soon&#34;)\n有点问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601694848,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107819,"user_name":"Fergus","can_delete":false,"product_type":"c1","uid":1277066,"ip_address":"","ucode":"3A8AC741C49CEB","user_header":"https://static001.geekbang.org/account/avatar/00/13/7c/8a/bdeb76ac.jpg","comment_is_top":false,"comment_ctime":1561617322,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18741486506","product_id":100026901,"comment_content":"# -*- coding:utf-8 -*-<br>&#39;&#39;&#39;<br>sublime<br>py -3.6<br>asyncio.gather(*args) 并发<br>&#39;&#39;&#39;<br><br><br>import time<br>import asyncio<br><br>async def crawl_page(url):<br>    print(&#39;crawling {}&#39;.format(url))<br>    sleep_time = int(url.split(&#39;_&#39;)[-1])<br>    await asyncio.sleep(sleep_time)<br>    print(&#39;OK {}&#39;.format(url))<br>    <br>star = time.perf_counter()<br>loop = asyncio.get_event_loop()<br>tasks = (crawl_page(url) for url in [&#39;url_1&#39;, &#39;url_2&#39;, &#39;url_3&#39;, &#39;url_4&#39;])<br>loop.run_until_complete(asyncio.gather(*tasks))<br>loop.close()<br><br>print(&#39;Wall time: {:.2f}&#39;.format(time.perf_counter() - star))<br><br><br>crawling url_4<br>crawling url_1<br>crawling url_2<br>crawling url_3<br>OK url_1<br>OK url_2<br>OK url_3<br>OK url_4<br>Wall time: 4.00<br>[Finished in 4.5s]","like_count":4,"discussions":[{"author":{"id":1099513,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c6/f9/caf27bd3.jpg","nickname":"大王叫我来巡山","note":"","ucode":"1B8D0C701BC95E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53232,"discussion_content":"正解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574147850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152439,"user_name":"supakito","can_delete":false,"product_type":"c1","uid":1387156,"ip_address":"","ucode":"3060AB5E0D4E24","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/gKnIR8mga02s9xdQoxyJBibmuxHGhfQ8WZicia3Ie4wBQKg4Zc1oVoS03mvaCD46je9xCza25qXc3w6KMckpS0BqQ/132","comment_is_top":false,"comment_ctime":1574001294,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"14458903182","product_id":100026901,"comment_content":"对于这段代码：<br><br>import asyncio<br><br>async def worker_1():<br>    print(&#39;worker_1 start&#39;)<br>    await asyncio.sleep(1)<br>    print(&#39;worker_1 done&#39;)<br><br>async def worker_2():<br>    print(&#39;worker_2 start&#39;)<br>    await asyncio.sleep(2)<br>    print(&#39;worker_2 done&#39;)<br><br>async def main():<br>    task1 = asyncio.create_task(worker_1())<br>    task2 = asyncio.create_task(worker_2())<br>    print(&#39;before await&#39;)<br>    await task1<br>    print(&#39;awaited worker_1&#39;)<br>    await task2<br>    print(&#39;awaited worker_2&#39;)<br><br>%time asyncio.run(main())<br><br>########## 输出 ##########<br><br>before await<br>worker_1 start<br>worker_2 start<br>worker_1 done<br>awaited worker_1<br>worker_2 done<br>awaited worker_2<br>Wall time: 2.01 s<br><br>我对老师的解释有些疑问，不知道是不是只要创建了任务以后，不用执行await，就会运行worker_1和worker_2中的代码，因为我注释掉了await语句后，发现仍然会输出worker_1 done和worker_2 done。所有老师的第三步应该不是调度worker_1，而是等待worker_1执行完成？","like_count":3,"discussions":[{"author":{"id":2140055,"avatar":"https://static001.geekbang.org/account/avatar/00/20/a7/97/073bef1a.jpg","nickname":"辉","note":"","ucode":"123245A4C2A345","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302700,"discussion_content":"%time不应该报错无效的语法？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599011659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1590096,"avatar":"https://static001.geekbang.org/account/avatar/00/18/43/50/5d2a3348.jpg","nickname":"상관없다","note":"","ucode":"C91043842812D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":224487,"discussion_content":"+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586310906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1034115,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c7/83/ca76b4f3.jpg","nickname":"移动一下","note":"","ucode":"9314E79C72A71E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206571,"discussion_content":"我和你理解一样\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584416138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146381,"user_name":"刘润森","can_delete":false,"product_type":"c1","uid":1236556,"ip_address":"","ucode":"84101C670A6747","user_header":"https://static001.geekbang.org/account/avatar/00/12/de/4c/a51ece16.jpg","comment_is_top":false,"comment_ctime":1572510997,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14457412885","product_id":100026901,"comment_content":" asyncio.run() cannot be called from a running event loop","like_count":3,"discussions":[{"author":{"id":1217874,"avatar":"https://static001.geekbang.org/account/avatar/00/12/95/52/ad190682.jpg","nickname":"Mr wind","note":"","ucode":"484F02D1962239","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":175995,"discussion_content":"先确认是3.7","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582012303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135626,"user_name":"考休","can_delete":false,"product_type":"c1","uid":1053955,"ip_address":"","ucode":"968DFC00D6D0CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg","comment_is_top":false,"comment_ctime":1569231188,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14454133076","product_id":100026901,"comment_content":"翻阅评论，发现大家也有相似的问题，就是在老师的第二个代码块中，代码：<br>%time asyncio.run(main([&#39;url_1&#39;, &#39;url_2&#39;, &#39;url_3&#39;, &#39;url_4&#39;]))<br>这行代码因为前面有%time语法糖，所以大家想当然就在jupyter中执行了，但是很多人都遇到了：<br>RuntimeError: asyncio.run() cannot be called from a running event loop <br>查阅Stack Overflow的解释jupyter已经一个event loop（https:&#47;&#47;stackoverflow.com&#47;questions&#47;55409641&#47;asyncio-run-cannot-be-called-from-a-running-event-loop），因此需要将代码改成：<br>await main([&#39;url_1&#39;, &#39;url_2&#39;, &#39;url_3&#39;, &#39;url_4&#39;])，而且不能在await前面加%time，否则会报错：<br>SyntaxError: &#39;await&#39; outside function<br>新手学习协程感觉各种懵（苦笑脸）","like_count":3},{"had_liked":false,"id":115164,"user_name":"xavier","can_delete":false,"product_type":"c1","uid":1243128,"ip_address":"","ucode":"2F7918EA37ED9F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f7/f8/3c0a6854.jpg","comment_is_top":false,"comment_ctime":1563501976,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14448403864","product_id":100026901,"comment_content":"老师你好，请教个问题。如下：<br><br>文中代码：<br><br>async def main():<br>    task1 = asyncio.create_task(worker_1())<br>    task2 = asyncio.create_task(worker_2())<br>    print(&#39;before await&#39;)<br>    await task1<br>    print(&#39;awaited worker_1&#39;)<br>    await task2<br>    print(&#39;awaited worker_2&#39;)<br><br>请问调度器从何时开始启动调度？是一有任务创建就执行调度还是执行await task1时？老师这里说的是执行await task1，事件调度器开始调度 worker_1。但后面的生产者消费者模型，没有await操作，任务已开始运行。","like_count":3,"discussions":[{"author":{"id":1005618,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/58/32/535e5c3c.jpg","nickname":"mlbjay","note":"","ucode":"FB62EAB4568AFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88596,"discussion_content":"不理解 主任务和任务1与任务2的开始时刻。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576719973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107542,"user_name":"Fergus","can_delete":false,"product_type":"c1","uid":1277066,"ip_address":"","ucode":"3A8AC741C49CEB","user_header":"https://static001.geekbang.org/account/avatar/00/13/7c/8a/bdeb76ac.jpg","comment_is_top":false,"comment_ctime":1561554225,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14446456113","product_id":100026901,"comment_content":"# 例1   3.7以前的版本实现<br>import time<br>import asyncio<br><br># &lt; py 3.7<br>async def crawl_page(url):<br>    print(&#39;crawling {}&#39;.format(url))<br>    sleep_time = int(url.split(&#39;_&#39;)[-1])<br>    r = await asyncio.sleep(sleep_time)<br>    print(&#39;OK {}&#39;.format(url))<br><br>async def main(urls):<br>    for url in urls:<br>        await crawl_page(url)<br>        <br>star = time.perf_counter()<br>loop = asyncio.get_event_loop()<br>loop.run_until_complete(main([&#39;url_1&#39;, &#39;url_2&#39;, &#39;url_3&#39;, &#39;url_4&#39;]))<br>loop.close()<br># await main([&#39;url_1&#39;, &#39;url_2&#39;, &#39;url_3&#39;, &#39;url_4&#39;])<br>print(time.perf_counter() - star)<br><br><br>crawling url_1<br>OK url_1<br>crawling url_2<br>OK url_2<br>crawling url_3<br>OK url_3<br>crawling url_4<br>OK url_4<br>10.003888006104894","like_count":3},{"had_liked":false,"id":107540,"user_name":"Fergus","can_delete":false,"product_type":"c1","uid":1277066,"ip_address":"","ucode":"3A8AC741C49CEB","user_header":"https://static001.geekbang.org/account/avatar/00/13/7c/8a/bdeb76ac.jpg","comment_is_top":false,"comment_ctime":1561554080,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14446455968","product_id":100026901,"comment_content":"# 例一修改 threading<br><br>import time<br>import threading<br><br>def crawl_page(url):<br>    print(&#39;crawling {}&#39;.format(url))<br>    sleep_time = int(url.split(&#39;_&#39;)[-1])<br>    time.sleep(sleep_time)<br>    print(&#39;OK {}&#39;.format(url))<br>    print(&#39;耗时:{:.2f}&#39;.format(time.perf_counter() - star))<br>    <br>def main(urls):<br>    tasks = [threading.Thread(target=crawl_page, name=url, args=(url,)) for url in urls]<br>    for t in tasks:<br>        t.start()<br>        print(threading.current_thread().name)<br>    <br>star = time.perf_counter()<br>main([&#39;url_1&#39;, &#39;url_2&#39;, &#39;url_3&#39;, &#39;url_4&#39;])<br><br>crawling url_1MainThread<br>crawling url_2MainThread<br>crawling url_3MainThread<br>crawling url_4MainThread<br>OK url_1<br>耗时:1.03<br>OK url_2<br>耗时:2.06<br>OK url_3<br>耗时:3.08<br>OK url_4<br>耗时:4.11","like_count":3},{"had_liked":false,"id":107470,"user_name":"刘朋","can_delete":false,"product_type":"c1","uid":1075141,"ip_address":"","ucode":"7B7B8E4776C22E","user_header":"https://static001.geekbang.org/account/avatar/00/10/67/c5/63b09189.jpg","comment_is_top":false,"comment_ctime":1561541123,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"14446443011","product_id":100026901,"comment_content":"当在 jupyter 中运行: %time asyncio.run(main([&#39;url_1&#39;, &#39;url_2&#39;, &#39;url_3&#39;, &#39;url_4&#39;]))<br>出现报错: RuntimeError: asyncio.run() cannot be called from a running event loop<br>原因是: The problem in your case is that jupyter (IPython) is already running an event loop (for IPython ≥ 7.0)<br>解决是: 将 %time asyncio.run(main([&#39;url_1&#39;, &#39;url_2&#39;, &#39;url_3&#39;, &#39;url_4&#39;])) 换成 await main([&#39;url_1&#39;, &#39;url_2&#39;, &#39;url_3&#39;, &#39;url_4&#39;])","like_count":3,"discussions":[{"author":{"id":1076161,"avatar":"https://static001.geekbang.org/account/avatar/00/10/6b/c1/331b91c4.jpg","nickname":"郑文捷","note":"","ucode":"98C08BB54F0974","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72695,"discussion_content":"还会报错 await outside function","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575517300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1141751,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6b/f7/3a3b82c2.jpg","nickname":"Aspirin","note":"","ucode":"858B551CF0C2F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1689,"discussion_content":"请问你从Stack Overflow上看来的解决方法真的试了吗？真的可以解决这个问题么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562816001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314342,"user_name":"JabariH","can_delete":false,"product_type":"c1","uid":1983181,"ip_address":"","ucode":"F7CC3390CDB6AA","user_header":"https://static001.geekbang.org/account/avatar/00/1e/42/cd/09b568fc.jpg","comment_is_top":false,"comment_ctime":1632981215,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10222915807","product_id":100026901,"comment_content":"对“解密协程运行时”那部分下的程序执行做一个解释，欢迎大家指正：<br>1. asyncio.run(main())程序进入main函数，**事件循环**[main --&gt; task1 --&gt; task2 --&gt;tas3 --&gt; main]开启；<br>2. task_1、task_2、task_3任务被创建，并进入事件循环等待运行；<br>3. 主程序运行到await asyncio.sleep(2)，await 导致主程序被阻塞2s，此时事件调度器将控制权从主任务交给task_1(asyncio是根据任务创建顺序来赋予任务控制权的，相当于一个queue，先进先出)，并记录主程序运行到的位置；<br>4. 进入task1，输出“asyncio in task1”，后运行到asyncio.sleep(1)，程序被阻塞，事件调度器将控制权从task1交给task2，并记录task1程序运行到的位置；<br>5. 同样，task2输出“asyncio in task2”后运行到await asyncio.sleep(2)，被阻塞，记录task2程序运行到的位置，事件调度器开始调度task3；<br>6. 同理，task3输出“asyncio in task3”后运行到await asyncio.sleep(3)，被阻塞，记录程序阻塞的位置，事件调度器控制权又交回给主程序；<br>7. 此时，主程序还在被阻塞当中，事件调度器又按顺序开始调度task1；<br>8. 当时间接近1s的时候，task1开始接着上次运行到的位置往下运行，返回1，task1从事件循环中退出；<br>9. 当时间接近2s的时候，task2开始接着上次运行到的位置往下运行，返回2，task2从事件循环中退出；<br>10. 当时间接近3s的时候，由于主程序比task3早开始阻塞，所以主程序比task3先一步解除阻塞，事件调度器将控制权交给主程序，主程序从上次运行到的位置开始往下运行，取消task3任务，task3将不会有返回值，主程序从事件循环中退出，此时程序执行完毕。","like_count":2},{"had_liked":false,"id":307912,"user_name":"肥猫不开心","can_delete":false,"product_type":"c1","uid":2357566,"ip_address":"","ucode":"FA9204B84913C0","user_header":"https://static001.geekbang.org/account/avatar/00/23/f9/3e/0d5f27c4.jpg","comment_is_top":false,"comment_ctime":1629303393,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10219237985","product_id":100026901,"comment_content":"网页改了，最新同步爬虫<br>import requests<br>from bs4 import BeautifulSoup<br><br>def main():<br>    url = &quot;https:&#47;&#47;movie.douban.com&#47;cinema&#47;later&#47;beijing&#47;&quot;<br>    headers = {&#39;User-Agent&#39;: r&#39;Mozilla&#47;5.0 (Windows NT 10.0; WOW64) AppleWebKit&#47;537.36 (KHTML, like Gecko) Chrome&#47;91.0.4472.164 Safari&#47;537.36&#39;}<br>    init_page = requests.get(url, headers=headers).content<br>    init_soup = BeautifulSoup(init_page, &#39;lxml&#39;)<br>    all_movies = init_soup.find(&#39;div&#39;, id=&quot;showing-soon&quot;)<br>    for each_movie in all_movies.find_all(&#39;div&#39;, class_=&quot;intro&quot;):<br>        all_a_tag = each_movie.find_all(&#39;a&#39;)<br>        all_li_tag = each_movie.find_all(&#39;li&#39;)<br><br>        movie_name = all_a_tag[0].text<br>        url_to_fetch = all_a_tag[0][&#39;href&#39;]<br>        movie_date = all_li_tag[0].text<br><br>        response_item = requests.get(url_to_fetch, headers=headers).content<br>        soup_item = BeautifulSoup(response_item, &#39;lxml&#39;)<br>        img_tag = soup_item.find(&#39;div&#39;, id=&#39;mainpic&#39;).find(&#39;img&#39;)<br><br>        print(&#39;{} {} {}&#39;.format(movie_name, movie_date, img_tag[&#39;src&#39;]))<br><br>main()","like_count":2},{"had_liked":false,"id":186098,"user_name":"向南","can_delete":false,"product_type":"c1","uid":1325700,"ip_address":"","ucode":"E6072AD7CA6798","user_header":"https://static001.geekbang.org/account/avatar/00/14/3a/84/70340e87.jpg","comment_is_top":false,"comment_ctime":1583757200,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10173691792","product_id":100026901,"comment_content":"import asyncio<br>import aiohttp<br>import requests<br>from lxml import etree<br><br>headers = {<br>    &#39;User-Agent&#39;: &#39;Mozilla&#47;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#47;537.36 (KHTML, like Gecko) Chrome&#47;80.0.3987.132 Safari&#47;537.36&#39;<br>}<br><br>async def get_content(url):<br>    async with aiohttp.ClientSession(<br>        headers=headers, connector=aiohttp.TCPConnector(ssl=False)<br>    ) as session:<br>        async with session.get(url) as response:<br>            return await response.text()<br><br>def parse(html):<br>    html = etree.HTML(html)<br>    divs = html.xpath(&#39;&#47;&#47;div[@id=&quot;showing-soon&quot;]&#47;div&#39;)<br>    for div in divs:<br>        title = div.xpath(&#39;.&#47;&#47;h3&#47;a&#47;text()&#39;)[0].strip()<br>        release_time = div.xpath(&#39;.&#47;&#47;ul&#47;li[1]&#47;text()&#39;)[0]<br>        movie_img_id = div.xpath(&#39;.&#47;a&#47;img&#47;@src&#39;)[0].split(&#39;&#47;&#39;)[-1][1:-4]<br>        movie_img_url = f&#39;https:&#47;&#47;img9.doubanio.com&#47;view&#47;photo&#47;raw&#47;public&#47;p{movie_img_id}.jpg&#39;<br>        data = {<br>            &#39;title&#39;: title,<br>            &#39;release_time&#39;: release_time,<br>            &#39;movie_img_url&#39;: movie_img_url<br>        }<br>        yield data<br><br>async def main():<br>    url = &#39;https:&#47;&#47;movie.douban.com&#47;cinema&#47;later&#47;beijing&#47;&#39;<br>    html = await get_content(url)<br>    data = parse(html)<br>    for item in data:<br>        print(item)<br><br>if __name__ == &quot;__main__&quot;:<br>    asyncio.run(main())","like_count":2},{"had_liked":false,"id":153098,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1574157399,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10164091991","product_id":100026901,"comment_content":"协程的task方式执行顺序，从第一个await到最后一个await，整个线程被分为await部分和非await部分。执行逻辑是<br>1.await部分优先执行，非await语句 全部暂停。<br>2.await 部分如果等待，就会把执行权交给其他await部分的执行语句，但是这个await语句之后的非await语句不会被执行。<br>3.当一个await 语句执行完毕，其他await还在等待的时候，这个await语句之后其他await之前的语句就会被执行。然后进入等待阶段。<br>请问老师，不知道我的理解是否正确。","like_count":2},{"had_liked":false,"id":114402,"user_name":"某彬","can_delete":false,"product_type":"c1","uid":1355849,"ip_address":"","ucode":"BB137DFE52250A","user_header":"https://static001.geekbang.org/account/avatar/00/14/b0/49/39238538.jpg","comment_is_top":false,"comment_ctime":1563290414,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10153225006","product_id":100026901,"comment_content":"关于以下一段代码：<br>```python<br>for task in tasks:<br> await task<br>```<br>我想问 遇到第一个await之后程序不会跳出整个for循环吗？还是说只会跳出当前的循环？","like_count":2},{"had_liked":false,"id":110868,"user_name":"和你一起搬砖的胡大爷","can_delete":false,"product_type":"c1","uid":1008587,"ip_address":"","ucode":"54607F4E17917A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/cb/7c004188.jpg","comment_is_top":false,"comment_ctime":1562381599,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10152316191","product_id":100026901,"comment_content":"对于熟悉线程模型的程序员来讲，如果不把时间循环解释清楚，协程确实很难理解。<br>我的理解协程在编程语言层面实现aio，只有io等待才切换上下文而不像线程按scheduler分片cpu在没必要的时候也切换上下文。不知道我理解的对不对。","like_count":2},{"had_liked":false,"id":107962,"user_name":"Fergus","can_delete":false,"product_type":"c1","uid":1277066,"ip_address":"","ucode":"3A8AC741C49CEB","user_header":"https://static001.geekbang.org/account/avatar/00/13/7c/8a/bdeb76ac.jpg","comment_is_top":false,"comment_ctime":1561641240,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10151575832","product_id":100026901,"comment_content":"# -*- encoding: utf-8 -*-<br>&#39;&#39;&#39;<br>py3.6<br>sublime<br>&#39;&#39;&#39;<br><br><br>import time<br>import asyncio<br><br>now = lambda: time.perf_counter()<br><br>async def work_1():<br>\tawait asyncio.sleep(1)<br>\treturn 1<br><br>async def work_2():<br>\tawait asyncio.sleep(2)<br>\treturn 2<br><br>async def work_3():<br>\tawait asyncio.sleep(3)<br>\treturn 3<br><br>async def main():<br><br>\ttask_1 = asyncio.ensure_future(work_1())<br>\ttask_2 = asyncio.ensure_future(work_2())<br>\ttask_3 = asyncio.ensure_future(work_3())<br><br>\tawait asyncio.sleep(2)<br>\ttask_3.cancel()<br><br>\tret = await asyncio.gather(*(task_1, task_2, task_3), <br>\t\treturn_exceptions=True)<br>\tprint(ret)<br><br>star = now()<br>loop = asyncio.get_event_loop()<br>loop.run_until_complete(main())<br>loop.close()<br>print(&#39;Wall time:&#39;, now() - star)<br><br># [1, 2, CancelledError()]<br># Wall time: 2.0061719078276914<br># [Finished in 2.5s]","like_count":2},{"had_liked":false,"id":106510,"user_name":"zx钟 💤","can_delete":false,"product_type":"c1","uid":1398032,"ip_address":"","ucode":"193DF60890BE88","user_header":"https://static001.geekbang.org/account/avatar/00/15/55/10/f2f81983.jpg","comment_is_top":false,"comment_ctime":1561338423,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10151273015","product_id":100026901,"comment_content":"官方文档看了好久 还是一脸懵逼。","like_count":2},{"had_liked":false,"id":327004,"user_name":"大猫","can_delete":false,"product_type":"c1","uid":1084768,"ip_address":"","ucode":"80BC2BE4DF96F0","user_header":"https://static001.geekbang.org/account/avatar/00/10/8d/60/ef9dd940.jpg","comment_is_top":false,"comment_ctime":1639830311,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5934797607","product_id":100026901,"comment_content":"协程就是单线程，函数定义用async修饰，要等待结果就用await，在await出现的地方就变成了同步了，函数内部针对耗时的io操作，可以用await交出控制权，程序会执行其他部分的【首先是当前线程主分支上面的代码】如果没有或者被上一个await等待阻隔了，那么就会顺序去执行其他  async函数，直到最后一个await交出控制权，程序会循环看谁的await已经结束了，则从结束的地方继续往下执行；这里面如果async函数都没有用await等待，那么程序会执行完主分支上面的代码就会退出了，所以要在最后面等所有的async函数执行完毕，要用asyncio.gather函数，或者用一个await asyncio.sleep(2) 等待操作。和c#里面的Task是不一样的东西。","like_count":1},{"had_liked":false,"id":299642,"user_name":"知鱼君","can_delete":false,"product_type":"c1","uid":1076719,"ip_address":"","ucode":"8B1958BEB5FB2C","user_header":"https://static001.geekbang.org/account/avatar/00/10/6d/ef/08132ab2.jpg","comment_is_top":false,"comment_ctime":1624776778,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"5919744074","product_id":100026901,"comment_content":"生产者消费者模型那里，关于下面这一段，有两点不太理解。<br>await asyncio.sleep(10)<br>consumer_1.cancel()<br>consumer_2.cancel()<br><br>1. 为什么要await asyncio.sleep(10)<br>2. 为什么要consumer_1.cancel()","like_count":1},{"had_liked":false,"id":171543,"user_name":"jackstraw","can_delete":false,"product_type":"c1","uid":1137207,"ip_address":"","ucode":"C967D2D6158F99","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/37/8775d714.jpg","comment_is_top":false,"comment_ctime":1578964911,"is_pvip":false,"replies":[{"id":"66516","content":"原文是“任务创建后很快就会被调度执行”，并不是“立马就开始执行”；其次在解密底层运行时，main 函数也可以理解为一个正常的 task，要等这个 task 进入 await 的状态，才会调度下一个 task","user_name":"作者回复","user_name_real":"高山流水","uid":"1513504","ctime":1578979044,"ip_address":"","comment_id":171543,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5873932207","product_id":100026901,"comment_content":"有点没明白，前面说任务创建后立马就开始执行了么？怎么后面在解密底层运行过程的时候，说任务创建后等待执行？到底是哪一个呀？","like_count":1,"discussions":[{"author":{"id":1513504,"avatar":"https://static001.geekbang.org/account/avatar/00/17/18/20/75ea3b20.jpg","nickname":"高山流水","note":"","ucode":"71E513B5937481","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481407,"discussion_content":"原文是“任务创建后很快就会被调度执行”，并不是“立马就开始执行”；其次在解密底层运行时，main 函数也可以理解为一个正常的 task，要等这个 task 进入 await 的状态，才会调度下一个 task","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578979044,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164036,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1576848703,"is_pvip":false,"replies":[{"id":"63093","content":"协程使用的是 aiohttp 并发网络 io 库，因此就不需要 requests 了","user_name":"作者回复","user_name_real":"高山流水","uid":"1513504","ctime":1577248862,"ip_address":"","comment_id":164036,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5871815999","product_id":100026901,"comment_content":"老师，在最后那个协程例子中为何没用requests库呢？是因为它不支持协程吗","like_count":1,"discussions":[{"author":{"id":1513504,"avatar":"https://static001.geekbang.org/account/avatar/00/17/18/20/75ea3b20.jpg","nickname":"高山流水","note":"","ucode":"71E513B5937481","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478623,"discussion_content":"协程使用的是 aiohttp 并发网络 io 库，因此就不需要 requests 了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577248862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109575,"user_name":"Marj","can_delete":false,"product_type":"c1","uid":1142268,"ip_address":"","ucode":"544030159851DD","user_header":"https://static001.geekbang.org/account/avatar/00/11/6d/fc/12d712f4.jpg","comment_is_top":false,"comment_ctime":1562059704,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5857027000","product_id":100026901,"comment_content":"在 jupyter 中运行，报<br>```<br>---------------------------------------------------------------------------<br>AttributeError                            Traceback (most recent call last)<br>&lt;timed eval&gt; in &lt;module&gt;<br><br>AttributeError: module &#39;asyncio&#39; has no attribute &#39;run&#39;<br>```","like_count":1},{"had_liked":false,"id":107547,"user_name":"Fergus","can_delete":false,"product_type":"c1","uid":1277066,"ip_address":"","ucode":"3A8AC741C49CEB","user_header":"https://static001.geekbang.org/account/avatar/00/13/7c/8a/bdeb76ac.jpg","comment_is_top":false,"comment_ctime":1561555754,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5856523050","product_id":100026901,"comment_content":"<br># py &lt; 3.7   异步  &lt;sublime&gt;<br>import time<br>import asyncio<br><br>async def crawl_page(url):<br>    print(&#39;crawling {}&#39;.format(url))<br>    sleep_time = int(url.split(&#39;_&#39;)[-1])<br>    await asyncio.sleep(sleep_time)<br>    print(&#39;OK {}&#39;.format(url))<br>    <br>async def main(urls):<br>    for url in urls:<br>        await crawl_page(url)<br><br>star = time.perf_counter()<br>loop = asyncio.get_event_loop()<br>ls = [&#39;url_1&#39;, &#39;url_2&#39;, &#39;url_3&#39;, &#39;url_4&#39;]<br>tasks = [crawl_page(url) for url in ls]<br>loop.run_until_complete(asyncio.wait(tasks))<br>loop.close()<br>print(time.perf_counter() - star)<br><br>crawling url_2<br>crawling url_3<br>crawling url_4<br>crawling url_1<br>OK url_1<br>OK url_2<br>OK url_3<br>OK url_4<br>[Finished in 4.5s]","like_count":1,"discussions":[{"author":{"id":1005520,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/d0/b9312769.jpg","nickname":"北斗(宇)","note":"","ucode":"9532B48D7C29C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543405,"discussion_content":"main函数似乎没用上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641128741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107125,"user_name":"sky","can_delete":false,"product_type":"c1","uid":1268778,"ip_address":"","ucode":"6D31488C0DAFCC","user_header":"","comment_is_top":false,"comment_ctime":1561463245,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5856430541","product_id":100026901,"comment_content":"还有一种 多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能","like_count":1,"discussions":[{"author":{"id":1105161,"avatar":"https://static001.geekbang.org/account/avatar/00/10/dd/09/feca820a.jpg","nickname":"helloworld","note":"","ucode":"1EECCA0F43E278","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517,"discussion_content":"nginx就是这种多进程+协程的方式。问题是python如何实现多进程和协程的组合，谁知道呀？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561629355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107118,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1105161,"ip_address":"","ucode":"1EECCA0F43E278","user_header":"https://static001.geekbang.org/account/avatar/00/10/dd/09/feca820a.jpg","comment_is_top":false,"comment_ctime":1561462147,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5856429443","product_id":100026901,"comment_content":"老师，我测试了一下，协程的方式只会跑满一个CPU内核，而传统多进程并发的方式可以利用到所有的CPU内核，这个协程的方式能把所有cpu内核都用上吗，怎么做呢","like_count":1,"discussions":[{"author":{"id":1191529,"avatar":"","nickname":"karofsky","note":"","ucode":"4AFBEDE22F9652","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333849,"discussion_content":"协程好像就使用单线程模拟并发操作吧好像","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607652947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107073,"user_name":"SCAR","can_delete":false,"product_type":"c1","uid":1031209,"ip_address":"","ucode":"38C0927FA3C5FC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bc/29/022905e6.jpg","comment_is_top":false,"comment_ctime":1561453206,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5856420502","product_id":100026901,"comment_content":"协程里使用  result=yield from call_function(*arg,**kwarg)，而后把协程放入事件循环中显式调度执行。","like_count":1},{"had_liked":false,"id":106970,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1105161,"ip_address":"","ucode":"1EECCA0F43E278","user_header":"https://static001.geekbang.org/account/avatar/00/10/dd/09/feca820a.jpg","comment_is_top":false,"comment_ctime":1561430022,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5856397318","product_id":100026901,"comment_content":"说%time报错的人注意：<br>老师的运行环境是python3.7下的jupyter notebook；建议用这个环境做练习；安装方法：<br>先安装python3.7环境，然后用pip3 install jupyter安装，最后执行jupyter notebook即可调出本地浏览器，对了，要求有桌面环境，最好用mac系统或者是linux桌面系统，纯命令行模式的linux是不行的哦。<br><br>另外ipython -c “老师的代码”也是可以运行的，只是不太方便。","like_count":1},{"had_liked":false,"id":106680,"user_name":"随风の","can_delete":false,"product_type":"c1","uid":1307306,"ip_address":"","ucode":"50C25386889CC9","user_header":"https://static001.geekbang.org/account/avatar/00/13/f2/aa/47f2e37d.jpg","comment_is_top":false,"comment_ctime":1561371136,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5856338432","product_id":100026901,"comment_content":"关于%time运行不了的 大家可以试试<br> %%time <br> main([&#39;url_1&#39;, &#39;url_2&#39;, &#39;url_3&#39;, &#39;url_4&#39;])<br>相当于两个time.time()计算执行时间","like_count":1,"discussions":[{"author":{"id":1078506,"avatar":"https://static001.geekbang.org/account/avatar/00/10/74/ea/10661bdc.jpg","nickname":"kevinsu","note":"","ucode":"BAD46B815D6A5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405,"discussion_content":"你这个是什么语法？😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561535563,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358580,"user_name":"Geek_216fd5","can_delete":false,"product_type":"c1","uid":1602049,"ip_address":"北京","ucode":"EA6804E9E974B3","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLb5UK2u6RyS48ia8H2lUSlUyQEaBiclDlqpbQUWqTWeuf3Djl3ruHRN3U37GXYuWAfAW5d1xkm6F7w/132","comment_is_top":false,"comment_ctime":1664441023,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664441023","product_id":100026901,"comment_content":"老师，<br>我一开始看的很明白，就是到最后总结部分，您提到“协程是单线程”，把我弄糊涂了：之前的爬虫示例显示，运行总时长等于运行时间最长的爬虫。我就理解为，多个任务，并行的交由不同的“协作的程序”去处理，而这些“协作的程序”可以跑在一个线程上，也可以分别跑在不同线程上。因此协程就不一定是单线程了，这么理解也不知对不对。","like_count":0},{"had_liked":false,"id":350734,"user_name":"绘世浮夸 つ","can_delete":false,"product_type":"c1","uid":1763933,"ip_address":"","ucode":"6A3960195753BA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ea/5d/ccb4c205.jpg","comment_is_top":false,"comment_ctime":1657124139,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1657124139","product_id":100026901,"comment_content":"生产者消费者那个案例中consumer1和consumer2都取消了，再调用gather的意义在哪啊，我注释掉了也可以正常运行","like_count":0},{"had_liked":false,"id":346669,"user_name":"A君","can_delete":false,"product_type":"c1","uid":1940105,"ip_address":"","ucode":"FE96F089C2312C","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9a/89/babe8b52.jpg","comment_is_top":false,"comment_ctime":1653351714,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1653351714","product_id":100026901,"comment_content":"明白了，await会挂起当前线程去执行目标语句，并去循环事件里找task来调度，如果之前没有create task，就会一直挂起直到目标语句运行结束，最终呈现的效果就是同步执行","like_count":0},{"had_liked":false,"id":339770,"user_name":"熊能","can_delete":false,"product_type":"c1","uid":1135024,"ip_address":"","ucode":"1019EA97062AC7","user_header":"https://static001.geekbang.org/account/avatar/00/11/51/b0/d32c895d.jpg","comment_is_top":false,"comment_ctime":1648372111,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1648372111","product_id":100026901,"comment_content":"请问下面的task为啥不需要使用asyncio.create_task来创建？<br>tasks = [fetch_content(url) for url in urls_to_fetch]<br>pages = await asyncio.gather(*tasks)<br>","like_count":0},{"had_liked":false,"id":332368,"user_name":"liuwyfly","can_delete":false,"product_type":"c1","uid":1203396,"ip_address":"","ucode":"B1C3821E9B20E3","user_header":"https://static001.geekbang.org/account/avatar/00/12/5c/c4/3d879507.jpg","comment_is_top":false,"comment_ctime":1643188563,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643188563","product_id":100026901,"comment_content":"%time 要在 IPython 或jupyter notebook","like_count":0},{"had_liked":false,"id":319336,"user_name":"heihei","can_delete":false,"product_type":"c1","uid":1914146,"ip_address":"","ucode":"1AD89888AA36C4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/L2iccnuficX53DnwPoeVAVkYa8Tb7zuXOweYR9aERiamV1aTT7ANPA6GWdPM4wic7p2b8FdYy8j1GEvypMvOwM5w6w/132","comment_is_top":false,"comment_ctime":1635750535,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1635750535","product_id":100026901,"comment_content":"js对理解这篇文档还是有很大帮助的，哈哈","like_count":0},{"had_liked":false,"id":313836,"user_name":"jerry guo","can_delete":false,"product_type":"c1","uid":1267753,"ip_address":"","ucode":"179943AFCB93F8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo2GMhevabZrjINs2TKvIeGC7TJkicNlLvqTticuM5KL8ZN80OC2CnrsUyzPcZXO4uptj4Q1S4jT2lQ/132","comment_is_top":false,"comment_ctime":1632705358,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1632705358","product_id":100026901,"comment_content":"这是我见过写的最好的协程的文章","like_count":0},{"had_liked":false,"id":297226,"user_name":"Skrpy","can_delete":false,"product_type":"c1","uid":1524904,"ip_address":"","ucode":"BB6CB4E9AA1712","user_header":"https://static001.geekbang.org/account/avatar/00/17/44/a8/0ce75c8c.jpg","comment_is_top":false,"comment_ctime":1623385281,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623385281","product_id":100026901,"comment_content":"tasks = [fetch_content(url) for url in urls_to_fetch] <br>pages = await asyncio.gather(*tasks)<br><br>为什么异步爬虫实战的这两行代码里面tasks的创建不需要asyncio.create_task()？还有，协程requests一定要借助aiohttp才能实现吗？","like_count":0},{"had_liked":false,"id":296307,"user_name":"Terrylee","can_delete":false,"product_type":"c1","uid":2022922,"ip_address":"","ucode":"89C1C695A3D6AC","user_header":"https://static001.geekbang.org/account/avatar/00/1e/de/0a/6400e68e.jpg","comment_is_top":false,"comment_ctime":1622893658,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622893658","product_id":100026901,"comment_content":"pip install nest-asyncio，这个命令我用不了，请问老师是不是没设置环境变量还是装了Jupyter 还要装个python3.8?<br>下是报错提示<br>The following command must be run outside of the IPython shell:<br><br>    $ pip install nest-asyncio<br><br>The Python package manager (pip) can only be used from outside of IPython.<br>Please reissue the `pip` command in a separate terminal or command prompt.<br><br>See the Python documentation for more information on how to install packages:","like_count":0},{"had_liked":false,"id":291209,"user_name":"Bonaparte","can_delete":false,"product_type":"c1","uid":1021741,"ip_address":"","ucode":"27E9CEE38A30C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/97/2d/8e4836f3.jpg","comment_is_top":false,"comment_ctime":1620117609,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620117609","product_id":100026901,"comment_content":"AttributeError                            Traceback (most recent call last)<br>&lt;timed eval&gt; in &lt;module&gt;<br><br>&lt;ipython-input-17-de51a8781fda&gt; in main()<br>      8 <br>      9     all_movies = init_soup.find(&quot;div&quot;, id=&quot;showing-soon&quot;)<br>---&gt; 10     for each_movie in all_movies.find_all(&quot;div&quot;, class_=&quot;item&quot;):<br>     11         all_a_tag = each_movie.find_all(&quot;a&quot;)<br>     12         all_li_tag = each_movie.find_all(&quot;li&quot;)<br><br>AttributeError: &#39;NoneType&#39; object has no attribute &#39;find_all&#39;<br><br>换成字典 {&quot;class&quot;:&quot;item&quot;},不行<br>声明 header，也不行...","like_count":0},{"had_liked":false,"id":276795,"user_name":"Untitled","can_delete":false,"product_type":"c1","uid":1039464,"ip_address":"","ucode":"8DD6ABA3E81A2E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/dc/68/006ba72c.jpg","comment_is_top":false,"comment_ctime":1612140535,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1612140535","product_id":100026901,"comment_content":"将上面例子中的worker_1的sleep时间和worker_2的sleep时间调换了一下，发现输出顺序为：<br>before await<br>worker_1 start<br>worker_2 start<br>worker_2 done<br>worker_1 done<br>awaited worker_1<br>awaited worker_2<br>该函数的运行时间为2.002202<br><br>我理解整个执行过程是：await触发所有tasks一起启动，然后worker_2先执行完毕，控制权交互给主流程，主流程在await task1阻塞直到task1执行完成，再把依次执行后面的程序。","like_count":0},{"had_liked":false,"id":276376,"user_name":"Glen","can_delete":false,"product_type":"c1","uid":2427327,"ip_address":"","ucode":"59D37B742177B9","user_header":"https://static001.geekbang.org/account/avatar/00/25/09/bf/0d1e2af8.jpg","comment_is_top":false,"comment_ctime":1611904694,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611904694","product_id":100026901,"comment_content":"开头那段背景介绍，从多进城多线程，到事件循环，到协程，不是很懂。就是传统方法的好处劣势，新方法怎么改进。","like_count":0},{"had_liked":false,"id":274640,"user_name":"米勒","can_delete":false,"product_type":"c1","uid":2344816,"ip_address":"","ucode":"9C02A167B593A9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLCbnGYOhwYmBwytX5e8Dd3ll9JwjUgaS5QK2JnbxrNdwJiaFksjsKQXBw9OuLZicrCB7unnS3ZGLOw/132","comment_is_top":false,"comment_ctime":1611108617,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611108617","product_id":100026901,"comment_content":"现在好多网站都有反爬的策略，爬虫小白好难啊！","like_count":0},{"had_liked":false,"id":263336,"user_name":"dao","can_delete":false,"product_type":"c1","uid":1087879,"ip_address":"","ucode":"4181FB270462CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/99/87/98ebb20e.jpg","comment_is_top":false,"comment_ctime":1606106213,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1606106213","product_id":100026901,"comment_content":"如果在 jupyter 里实验本课程，你可能会使用 await main() 执行代码，因而不能使用魔法命令 %time，那么可能需要一个简易的、自定义的 time_it。代码如下，是一个简易的 decorator<br>--------<br>import time<br>import functools<br><br>def async_time_it(func):<br>    @functools.wraps(func)<br>    async def wrapper(*args, **kwargs):<br>        start = time.perf_counter()<br>        res = await func(*args, **kwargs)<br>        end = time.perf_counter()<br>        print(f&#39;\\nTook {(end - start):.3f} s&#39;)<br>        return res<br>    return wrapper<br><br>详细使用可以参考 https:&#47;&#47;github.com&#47;hdouhua&#47;jupyter-test&#47;blob&#47;master&#47;c02&#47;06.ipynb","like_count":0},{"had_liked":false,"id":246715,"user_name":"chuan_chen","can_delete":false,"product_type":"c1","uid":1198311,"ip_address":"","ucode":"D76D2B17F69ADD","user_header":"https://static001.geekbang.org/account/avatar/00/12/48/e7/da93cbec.jpg","comment_is_top":false,"comment_ctime":1599460348,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599460348","product_id":100026901,"comment_content":"本章满满精华，对协程和进程有了深层次的了解","like_count":0},{"had_liked":false,"id":245929,"user_name":"mia","can_delete":false,"product_type":"c1","uid":1458307,"ip_address":"","ucode":"83F6B65AE65121","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/9P7mlmEwl2E1m4b42bdUlaGVGunibesicCRJ9CLvkJB6Ljcgfk42BwJjiatv8mIHCWF3nNCT8o05hmC9k1nQvUQqg/132","comment_is_top":false,"comment_ctime":1599113430,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599113430","product_id":100026901,"comment_content":"学起来有点吃力，不过以我的经验，可以先一知半解学完，多敲敲代码练习，然后再回过头来重新学一遍，会发现很多不懂的地方迎刃而解。","like_count":0},{"had_liked":false,"id":232998,"user_name":"Cy23","can_delete":false,"product_type":"c1","uid":1591293,"ip_address":"","ucode":"8DC561C5151758","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/fd/895f0c27.jpg","comment_is_top":false,"comment_ctime":1594187978,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594187978","product_id":100026901,"comment_content":"import requests<br>from bs4 import BeautifulSoup<br><br>def main():<br>    url = &quot;https:&#47;&#47;movie.douban.com&#47;cinema&#47;later&#47;beijing&#47;&quot;<br>    headers = {<br>        &#39;Cookie&#39;: &#39;OCSSID=4df0bjva6j7ejussu8al3eqo03&#39;,<br>        &#39;User-Agent&#39;: &#39;Mozilla&#47;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#47;537.36&#39;<br>                      &#39;(KHTML, like Gecko) Chrome&#47;68.0.3440.106 Safari&#47;537.36&#39;,<br>    }<br><br>    init_page = requests.get(url, headers=headers).content<br>    init_soup = BeautifulSoup(init_page, &#39;lxml&#39;)<br>    all_movies = init_soup.find(&#39;div&#39;, id=&quot;showing-soon&quot;)<br>    for each_movie in all_movies.find_all(&#39;div&#39;, class_=&#39;item&#39;):<br>        all_a_tag = each_movie.find_all(&#39;a&#39;)<br>        all_li_tag = each_movie.find_all(&#39;li&#39;)<br><br>        movie_name = all_a_tag[1].text<br>        url_to_fetch = all_a_tag[1][&#39;href&#39;]<br>        movie_date = all_li_tag[0].text<br><br>        img_src = all_a_tag[0].find(&#39;img&#39;)[&#39;src&#39;].replace(&#39;s_ratio_poster&#39;,&#39;l&#39;)<br><br>        print(&#39;{} {} {}&#39;.format(movie_name, movie_date, img_src))<br><br>main()<br>","like_count":0},{"had_liked":false,"id":227747,"user_name":"一凡","can_delete":false,"product_type":"c1","uid":1897395,"ip_address":"","ucode":"5E9BE33452AF3B","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f3/b3/0ba7a760.jpg","comment_is_top":false,"comment_ctime":1592469369,"is_pvip":false,"replies":[{"id":"84943","content":"对 单线程实现并发","user_name":"作者回复","user_name_real":"高山流水","uid":"1513504","ctime":1593300593,"ip_address":"","comment_id":227747,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1592469369","product_id":100026901,"comment_content":"协程是单线程怎么理解？所有的协程都是吗","like_count":0,"discussions":[{"author":{"id":1513504,"avatar":"https://static001.geekbang.org/account/avatar/00/17/18/20/75ea3b20.jpg","nickname":"高山流水","note":"","ucode":"71E513B5937481","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498765,"discussion_content":"对 单线程实现并发","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593300593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221364,"user_name":"lcqbug","can_delete":false,"product_type":"c1","uid":1268609,"ip_address":"","ucode":"08FA17F21BCEC5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epbyHPGNLu9sDQOs1V6brMcDwia55pyIlP9n62oO6IYS6kIFDnOSON4ugSeBSy6WhDUnYyJC6vtnHQ/132","comment_is_top":false,"comment_ctime":1590482847,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590482847","product_id":100026901,"comment_content":"用 jupyternotebook 会报错<br>RuntimeError                              Traceback (most recent call last)<br>&lt;timed eval&gt; in &lt;module&gt;<br><br>D:\\Users\\86151\\Anaconda3\\lib\\asyncio\\runners.py in run(main, debug)<br>     32     if events._get_running_loop() is not None:<br>     33         raise RuntimeError(<br>---&gt; 34             &quot;asyncio.run() cannot be called from a running event loop&quot;)<br>     35 <br>     36     if not coroutines.iscoroutine(main):<br><br>RuntimeError: asyncio.run() cannot be called from a running event loop<br>----------<br>(我已经 pip install nest-asyncio了),这节的代码都翻车了..<br><br>asyncio.run(main())   报上边错误<br>改成 await main([&#39;url_1&#39;, &#39;url_2&#39;, &#39;url_3&#39;, &#39;url_4&#39;]) 就好了<br><br>%time await main([&#39;url_1&#39;, &#39;url_2&#39;, &#39;url_3&#39;, &#39;url_4&#39;])  会语法不正确 SyntaxError: &#39;await&#39; outside function<br><br>处处不同,处处坑,........................................<br>","like_count":0},{"had_liked":false,"id":221354,"user_name":"lcqbug","can_delete":false,"product_type":"c1","uid":1268609,"ip_address":"","ucode":"08FA17F21BCEC5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epbyHPGNLu9sDQOs1V6brMcDwia55pyIlP9n62oO6IYS6kIFDnOSON4ugSeBSy6WhDUnYyJC6vtnHQ/132","comment_is_top":false,"comment_ctime":1590480658,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590480658","product_id":100026901,"comment_content":"运行崩溃, pycharm  python3.7.4<br>coroutine &#39;crawl_page&#39; was never awaited<br>详情如下:<br>import asyncio<br><br><br>async def crawl_page(url):<br>    print(&#39;crawling {}&#39;.format(url))<br>    sleep_time = int(url.split(&#39;_&#39;)[-1])<br>    await asyncio.sleep(sleep_time)<br>    print(&#39;OK {}&#39;.format(url))<br><br><br>async def main(urls):<br>    tasks = [asyncio.create_task(crawl_page(url) for url in urls)]<br>    for task in tasks:<br>        await task<br><br><br>urls = [&#39;url_&#39; + str(i) for i in range(1, 5)]<br>asyncio.run(main(urls))<br>------------<br>RuntimeWarning: coroutine &#39;crawl_page&#39; was never awaited<br>  self._context.run(self._callback, *self._args)<br>Traceback (most recent call last):<br>  File &quot;E:&#47;xxxxx协程爬虫&#47;1.py&quot;, line 21, in &lt;module&gt;<br>    asyncio.run(main(urls))<br>  File &quot;D:\\Users\\xxxxx\\AppData\\Local\\Continuum\\anaconda3\\lib\\asyncio\\runners.py&quot;, line 43, in run<br>    return loop.run_until_complete(main)<br>  File &quot;D:\\Users\\xxxxx\\AppData\\Local\\Continuum\\anaconda3\\lib\\asyncio\\base_events.py&quot;, line 568, in run_until_complete<br>    return future.result()<br>  File &quot;E:&#47;xxxxx协程爬虫&#47;1.py&quot;, line 17, in main<br>    await task<br>  File &quot;E:&#47;xxxxx协程爬虫&#47;1.py&quot;, line 15, in &lt;genexpr&gt;<br>    tasks = [asyncio.create_task(crawl_page(url) for url in urls)]<br>RuntimeError: Task got bad yield: &lt;coroutine object crawl_page at 0x0000025D2075C1C8&gt;<br>","like_count":0},{"had_liked":false,"id":220429,"user_name":"ShmilyVidian","can_delete":false,"product_type":"c1","uid":1177103,"ip_address":"","ucode":"2B2485B48B8D33","user_header":"https://static001.geekbang.org/account/avatar/00/11/f6/0f/0499db2c.jpg","comment_is_top":false,"comment_ctime":1590241023,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590241023","product_id":100026901,"comment_content":"python中的await后面的就是一个协程，那类比这个JavaScript中的async await异步方案，老师能讲讲区别吗？","like_count":0},{"had_liked":false,"id":217610,"user_name":"轻风悠扬","can_delete":false,"product_type":"c1","uid":1319215,"ip_address":"","ucode":"F2276CE113BED1","user_header":"https://static001.geekbang.org/account/avatar/00/14/21/2f/b29e8af8.jpg","comment_is_top":false,"comment_ctime":1589547119,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1589547119","product_id":100026901,"comment_content":"老师你好，<br>import asyncio<br><br>async def worker_1():<br>    print(&#39;worker_1 start&#39;)<br>    await asyncio.sleep(1)<br>    print(&#39;worker_1 done&#39;)<br><br>async def worker_2():<br>    print(&#39;worker_2 start&#39;)<br>    await asyncio.sleep(2)<br>    print(&#39;worker_2 done&#39;)<br><br>async def main():<br>    task1 = asyncio.create_task(worker_1())<br>    task2 = asyncio.create_task(worker_2())<br>    print(&#39;before await&#39;)<br>    await task1<br>    print(&#39;awaited worker_1&#39;)<br>    await task2<br>    print(&#39;awaited worker_2&#39;)<br><br>这个程序里面为什么“worker_2 start“会比&#39;awaited worker_1&#39;更早print出来呢，实在是有点想不明白。python 会先执行所有await task命令再执行主任务中的print吗","like_count":0},{"had_liked":false,"id":214925,"user_name":"Steve","can_delete":false,"product_type":"c1","uid":1072131,"ip_address":"","ucode":"9C4E9E62A79C3A","user_header":"https://static001.geekbang.org/account/avatar/00/10/5c/03/370ebbc8.jpg","comment_is_top":false,"comment_ctime":1588851891,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588851891","product_id":100026901,"comment_content":"有两个疑惑不知道我理解的对不对：<br>1. 如果A函数内调用了异步函数，那么A也需要声明称async func。<br>2. 没有用过“aiohttp”这个package，协程版的豆瓣爬虫中<br>init_page = await fetch_content(url) # 这一步其实是同步的。<br>关键在于爬到电影详细页面的link以后，用协程去跑每个具体的电影页。<br>而这一段：<br>async with aiohttp.ClientSession( headers=header, connector=aiohttp.TCPConnector(ssl=False) ) as session: <br>     async with session.get(url) as response: <br>          return await response.text()<br>其中创建ClientSession以及通过session获取页面都声明成了async。我理解是因为上面第一条的原则，也就是最后调用了一个async func（await response.text()），所以创建和使用session也需要声明成async。不知道这么理解对不对？","like_count":0},{"had_liked":false,"id":210312,"user_name":"TianLearn","can_delete":false,"product_type":"c1","uid":1954420,"ip_address":"","ucode":"87F1F4EF668A57","user_header":"","comment_is_top":false,"comment_ctime":1587718650,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587718650","product_id":100026901,"comment_content":"为什么在 async 函数中，不能调用 time.sleep(sleep_time)，返回 <br>TypeError: object NoneType can&#39;t be used in &#39;await&#39; expression<br>Task exception was never retrieved","like_count":0},{"had_liked":false,"id":203959,"user_name":"상관없다","can_delete":false,"product_type":"c1","uid":1590096,"ip_address":"","ucode":"C91043842812D1","user_header":"https://static001.geekbang.org/account/avatar/00/18/43/50/5d2a3348.jpg","comment_is_top":false,"comment_ctime":1586312249,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586312249","product_id":100026901,"comment_content":"有一个缺点，不能像线程一样显示的控制 各个协程的start的顺序，完全靠调度器自己调度？？","like_count":0},{"had_liked":false,"id":200721,"user_name":"William～Zhang","can_delete":false,"product_type":"c1","uid":1527138,"ip_address":"","ucode":"8659B589428F11","user_header":"https://static001.geekbang.org/account/avatar/00/17/4d/62/0fe9cbb3.jpg","comment_is_top":false,"comment_ctime":1585643439,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585643439","product_id":100026901,"comment_content":"<br>import asyncio<br>import time<br>async def crawl_page(url):<br>    print(&#39;crawling {}&#39;.format(url))<br>    sleep_time = int(url.split(&#39;_&#39;)[-1])<br>    await asyncio.sleep(sleep_time)<br>    print(&#39;OK {}&#39;.format(url))<br><br>async def main(urls):<br>    tasks = [asyncio.create_task(crawl_page(url)) for url in urls]<br>    for task in tasks:<br>        await task<br><br>start = time.time()<br>await main([&#39;url_1&#39;, &#39;url_2&#39;, &#39;url_3&#39;, &#39;url_4&#39;])<br>end = time.time()<br><br>print(&#39;spend time is {}&#39;.format(end-start))","like_count":0},{"had_liked":false,"id":177592,"user_name":"Untitled","can_delete":false,"product_type":"c1","uid":1039464,"ip_address":"","ucode":"8DD6ABA3E81A2E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/dc/68/006ba72c.jpg","comment_is_top":false,"comment_ctime":1581430526,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1581430526","product_id":100026901,"comment_content":"老师你好，请问问多个协程会同时写入一个文件吗？","like_count":0},{"had_liked":false,"id":175296,"user_name":"苹果","can_delete":false,"product_type":"c1","uid":1761988,"ip_address":"","ucode":"5D0FA9D8560FD8","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e2/c4/25acaa38.jpg","comment_is_top":false,"comment_ctime":1580646551,"is_pvip":false,"replies":[{"id":"68227","content":"https:&#47;&#47;stackoverflow.com&#47;questions&#47;55409641&#47;asyncio-run-cannot-be-called-from-a-running-event-loop","user_name":"作者回复","user_name_real":"Jingxiao","uid":"1259521","ctime":1580765348,"ip_address":"","comment_id":175296,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1580646551","product_id":100026901,"comment_content":"asyncio.run() cannot be called from a running event loop<br>这个问题是如何解决，<br>","like_count":0,"discussions":[{"author":{"id":1259521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","nickname":"Jingxiao","note":"","ucode":"EB966BB87132F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482683,"discussion_content":"https://stackoverflow.com/questions/55409641/asyncio-run-cannot-be-called-from-a-running-event-loop","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580765348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164044,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1576849196,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576849196","product_id":100026901,"comment_content":"老师，Gevent和Asyncio有什么区别呢，都是协程","like_count":0},{"had_liked":false,"id":156701,"user_name":"隰有荷","can_delete":false,"product_type":"c1","uid":1357944,"ip_address":"","ucode":"2BE9A32AB28963","user_header":"https://static001.geekbang.org/account/avatar/00/14/b8/78/2828195b.jpg","comment_is_top":false,"comment_ctime":1574938572,"is_pvip":false,"replies":[{"id":"63094","content":"1. 基本是，但是注意是2秒后将当前断点加入协程池中等待调度。<br>2. 如果你只有这个耗时任务和当前任务（也就是总共两个任务），在当前任务调用 await 自动就切换到耗时任务了；但是当协程任务很多的时候，由于协程没有优先级设置，因此可能会出现耗时任务一直没有被分配资源的情况。实践中可以创建一个用于完成耗时任务的协程池，以限制耗时任务占用的总协程数量，于是就又回到了基于线程的并发模型中。","user_name":"作者回复","user_name_real":"高山流水","uid":"1513504","ctime":1577249270,"ip_address":"","comment_id":156701,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574938572","product_id":100026901,"comment_content":"老师，在如下代码中：<br>async def worker_2():<br>    print(&#39;worker_2 start&#39;)<br>    await asyncio.sleep(2)<br>    print(&#39;worker_2 done&#39;)<br><br>其中的await asyncio.sleep(2)是否可以理解为在切出当前程序，2秒后再继续执行print(&#39;worker_2 done&#39;)代码？<br>那么如果我有个耗时任务 def xxx(): ...，那么该如何用await asyncio来让这个xxx函数运行并切出当前程序呢？","like_count":0,"discussions":[{"author":{"id":1513504,"avatar":"https://static001.geekbang.org/account/avatar/00/17/18/20/75ea3b20.jpg","nickname":"高山流水","note":"","ucode":"71E513B5937481","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476205,"discussion_content":"1. 基本是，但是注意是2秒后将当前断点加入协程池中等待调度。\n2. 如果你只有这个耗时任务和当前任务（也就是总共两个任务），在当前任务调用 await 自动就切换到耗时任务了；但是当协程任务很多的时候，由于协程没有优先级设置，因此可能会出现耗时任务一直没有被分配资源的情况。实践中可以创建一个用于完成耗时任务的协程池，以限制耗时任务占用的总协程数量，于是就又回到了基于线程的并发模型中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577249270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148491,"user_name":"©™","can_delete":false,"product_type":"c1","uid":1024962,"ip_address":"","ucode":"766C79DEFA2887","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a3/c2/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1573018650,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573018650","product_id":100026901,"comment_content":"小白有一个疑问想请大佬们解答一下：<br>在消费者生产者模型当中，首先执行的是consumer_1 也就是消费者，刚开始队列当中应该还没有数据吧。","like_count":0},{"had_liked":false,"id":145091,"user_name":"SUN","can_delete":false,"product_type":"c1","uid":1545100,"ip_address":"","ucode":"A1700CD79C669E","user_header":"https://static001.geekbang.org/account/avatar/00/17/93/8c/cf41cf2b.jpg","comment_is_top":false,"comment_ctime":1572186847,"is_pvip":false,"replies":[{"id":"56036","content":"https:&#47;&#47;stackoverflow.com&#47;questions&#47;55409641&#47;asyncio-run-cannot-be-called-from-a-running-event-loop","user_name":"作者回复","user_name_real":"高山流水","uid":"1513504","ctime":1572244323,"ip_address":"","comment_id":145091,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572186847","product_id":100026901,"comment_content":"Jupyter 中运行 %time asyncio.run(main([&#39;url_1&#39;, &#39;url_2&#39;, &#39;url_3&#39;, &#39;url_4&#39;])) 会报错：<br>RuntimeError: asyncio.run() cannot be called from a running event loop<br>Python、Anaconda、Jupyter都安装了。<br>话说：Jupyter不就是为了消除个人本地开发环境差异性而诞生的吗？这个结果有点反讽。<br>各位学员的留言都看了，没人解决了此问题……<br>","like_count":0,"discussions":[{"author":{"id":1513504,"avatar":"https://static001.geekbang.org/account/avatar/00/17/18/20/75ea3b20.jpg","nickname":"高山流水","note":"","ucode":"71E513B5937481","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472240,"discussion_content":"https://stackoverflow.com/questions/55409641/asyncio-run-cannot-be-called-from-a-running-event-loop","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572244323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142218,"user_name":"delicate","can_delete":false,"product_type":"c1","uid":1187083,"ip_address":"","ucode":"AE262751C50CDD","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/0b/5f353b88.jpg","comment_is_top":false,"comment_ctime":1571313895,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571313895","product_id":100026901,"comment_content":"符合我预期中的进阶篇，怎么可能专栏每个部分都看得很轻松嘛，这样这个专栏对我就没有多少价值了","like_count":0},{"had_liked":false,"id":140193,"user_name":"扶幽","can_delete":false,"product_type":"c1","uid":1322612,"ip_address":"","ucode":"1400EDFF8970D3","user_header":"https://static001.geekbang.org/account/avatar/00/14/2e/74/88c613e0.jpg","comment_is_top":false,"comment_ctime":1570846401,"is_pvip":false,"replies":[{"id":"54712","content":"最好的办法就是多实践。文中的原理性东西都已经讲了，你可以边实践，遇到问题再去google","user_name":"作者回复","user_name_real":"Jingxiao","uid":"1259521","ctime":1571208705,"ip_address":"","comment_id":140193,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570846401","product_id":100026901,"comment_content":"请问下有木有相关的书籍，来进行这块的学习呢！有些原理性的东西还是没办法深入理解，谢谢。","like_count":0,"discussions":[{"author":{"id":1259521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","nickname":"Jingxiao","note":"","ucode":"EB966BB87132F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470292,"discussion_content":"最好的办法就是多实践。文中的原理性东西都已经讲了，你可以边实践，遇到问题再去google","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571208705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139938,"user_name":"自由民","can_delete":false,"product_type":"c1","uid":1346236,"ip_address":"","ucode":"435C67531697F1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/bc/cb39ed38.jpg","comment_is_top":false,"comment_ctime":1570770832,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570770832","product_id":100026901,"comment_content":"总结：<br>①协程与多线程的区别：协程是单线程，协程由用户决定，在哪些地方交出控制权（用await），切换到下一个任务。<br>②协程的写法更加简洁清晰。<br>③写协程程序时，要有清晰的事件循环的概念，知道在何时需要暂停、等待I&#47;O，什么时候需要一并执行到底。<br>④不要轻易炫技，拿到锤子眼里只有钉子。一个真正牛逼的程序员应该懂得在什么时候用什么模型能达到工程上的最优，技术是工程，工程是时间、资源、人力等的折衷。<br>我想了一下，用到协程（包括多线程）的地方应该是需要等待用户输入，网络I&#47;O，大量数据读取等耗时操作，不必等在那里，可以同时进行其它操作。还有就是大运算量但可分成多个独立过程的程序，利用多核CUP和多CUP进行并行计算，只是不知道Python是否支持？以及在这种情况里协程跟线程一样吗？<br>思考题：我先搞清楚什么是“回调函数”，看看大家答的吧。<br>使用BeautifulSoup要装lxml，手机上折腾了好久，终于搞定了。要装libxml2-utils等。<br>课程的练习代码: https:&#47;&#47;github.com&#47;zwdnet&#47;PythonPractice","like_count":0},{"had_liked":false,"id":139743,"user_name":"超人","can_delete":false,"product_type":"c1","uid":1156329,"ip_address":"","ucode":"119ED76F577FC7","user_header":"https://static001.geekbang.org/account/avatar/00/11/a4/e9/3b65c171.jpg","comment_is_top":false,"comment_ctime":1570715355,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1570715355","product_id":100026901,"comment_content":"谈谈自己的理解。main,worker1,worker2都是协程对象。await task1的意思是暂时停止执行，等待task1返回后再继续执行，注意这里是等待task1执行完返回，并不是说程序立刻去执行task1代码，把代码修改后可以证明：<br>    task2 = asyncio.create_task(worker_2())<br>    task1 = asyncio.create_task(worker_1())<br><br>执行什么代码由事件循环去调度，这里是按照任务创建的顺序执行main，task1，task2。task1 里执行到await asyncio.sleep(1)时就暂停了，控制权交给事件循环，下面执行的代码由事件循环去调度。按照上面的思路应该可以理解协程了。","like_count":0,"discussions":[{"author":{"id":1450337,"avatar":"https://static001.geekbang.org/account/avatar/00/16/21/61/c914065c.jpg","nickname":"哇哦","note":"","ucode":"FA99F044FCBF26","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":171917,"discussion_content":"“这里是按照任务创建的顺序执行main，task1，task2”这里应该是“这里是按照任务创建的顺序执行main，task2，task1”吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581758773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138760,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1570441974,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570441974","product_id":100026901,"comment_content":"协程实现回调函数的方法，把回调函数包装为一个任务，然后作为参数传入主调函数中，简单写了一个模拟程序，请老师指正<br>#协程回调函数模拟，<br>&#39;&#39;&#39;<br>输出结果有以下二种情况：<br>(1)在回调函数有延迟的情况下，会先执行主调函数，再执行回调函数；<br>(2)在回调函数无延迟的情况下，会先执行回调函数，再执行主调函数；<br><br>&#39;&#39;&#39;<br>import asyncio<br>from time import time<br><br>#主调函数<br>async def mainfunc(cb):<br>    print(&quot;我是主调函数&quot;)<br>    await cb<br>    <br>#回调函数<br>async def callback():<br>    await asyncio.sleep(2) #如果不延迟，则会先执行回调函数，再执行主调函数<br>    print(&quot;我是回调函数&quot;)<br><br>async def main():<br>    callback_task = asyncio.create_task(callback())<br>    main_task = asyncio.create_task(mainfunc(callback_task))<br>    await main_task<br>    <br>asyncio.run(main())","like_count":0},{"had_liked":false,"id":134649,"user_name":"somenzz","can_delete":false,"product_type":"c1","uid":1187197,"ip_address":"","ucode":"EA59A170DF8910","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/7d/368df396.jpg","comment_is_top":false,"comment_ctime":1568886274,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568886274","product_id":100026901,"comment_content":"有没有协程创建的任务数量超过500还不报错的，请教。","like_count":0},{"had_liked":false,"id":132375,"user_name":"Ray","can_delete":false,"product_type":"c1","uid":1398166,"ip_address":"","ucode":"FD786204F8B0E7","user_header":"https://static001.geekbang.org/account/avatar/00/15/55/96/baea9a4e.jpg","comment_is_top":false,"comment_ctime":1568103249,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1568103249","product_id":100026901,"comment_content":"在任务三中 cancel 是怎么取消的呢？是因为在上面设置的 sleep 时间为 2 秒，而任务一和二超过了这个时间吗？","like_count":0,"discussions":[{"author":{"id":1450337,"avatar":"https://static001.geekbang.org/account/avatar/00/16/21/61/c914065c.jpg","nickname":"哇哦","note":"","ucode":"FA99F044FCBF26","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":171931,"discussion_content":"我的理解是：程序运行到“await asyncio.sleep(2)”语句时，主任务交出控制权，去执行其他任务（即task1->taks2->task3），当执行到task3的“asyncio.sleep(3)”语句时，task3任务交出控制权， 2s后主任务获得控制权，执行“task_3.cancel()”语句，所以取消了task3。不知道理解的是否正确。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581759806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127037,"user_name":"大龄小学生","can_delete":false,"product_type":"c1","uid":1057111,"ip_address":"","ucode":"AA7860B88FB0F1","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/57/ee02ef41.jpg","comment_is_top":false,"comment_ctime":1566541194,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566541194","product_id":100026901,"comment_content":"老师，aiohttp必须要用session么？这个写法感觉保持不了session啊。感觉比requests那个难懂。","like_count":0},{"had_liked":false,"id":126992,"user_name":"佛本是道","can_delete":false,"product_type":"c1","uid":1011377,"ip_address":"","ucode":"6710218F8509CB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6e/b1/ec1feb7e.jpg","comment_is_top":false,"comment_ctime":1566531120,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566531120","product_id":100026901,"comment_content":"生产者消费者模型例子，为什么总是生产者任务先被调度执行？","like_count":0},{"had_liked":false,"id":117130,"user_name":"Don Wang","can_delete":false,"product_type":"c1","uid":1319529,"ip_address":"","ucode":"1853365FA279F2","user_header":"https://static001.geekbang.org/account/avatar/00/14/22/69/09f7a8a2.jpg","comment_is_top":false,"comment_ctime":1563973726,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563973726","product_id":100026901,"comment_content":"如果可以有详细解释爬虫豆瓣代码的解释就好了","like_count":0},{"had_liked":false,"id":115878,"user_name":"JustDoDT","can_delete":false,"product_type":"c1","uid":1127175,"ip_address":"","ucode":"6AF0B80F00EAEF","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/07/8f351609.jpg","comment_is_top":false,"comment_ctime":1563761086,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1563761086","product_id":100026901,"comment_content":"# 同步版本的爬虫<br>import time<br>import requests<br>from bs4 import BeautifulSoup<br><br><br>def cost_time(func):<br>    def wrapper(*args, **kwargs):<br>        start = time.perf_counter()<br>        res = func(*args, **kwargs)<br>        end = time.perf_counter()<br>        print(&#39;cost time: {}s&#39;.format(end - start))<br>        return res<br><br>    return wrapper<br><br><br>@cost_time<br>def main():<br>    url = &#39;https:&#47;&#47;movie.douban.com&#47;cinema&#47;later&#47;beijing&#47;&#39;<br>    init_page = requests.get(url).content<br>    init_soup = BeautifulSoup(init_page, &#39;html.parser&#39;)<br><br>    all_movies = init_soup.find(&#39;div&#39;, id=&#39;showing-soon&#39;)<br>    for each_movie in all_movies.find_all(&#39;div&#39;, class_=&#39;item&#39;):<br>        all_a_tag = each_movie.find_all(&#39;a&#39;)<br>        all_li_tag = each_movie.find_all(&#39;li&#39;)<br><br>        movie_name = all_a_tag[1].text<br>        url_to_fetch = all_a_tag[1][&#39;href&#39;]<br>        movie_date = all_li_tag[0].text<br><br>        response_item = requests.get(url_to_fetch).content<br>        soup_item = BeautifulSoup(response_item, &#39;html.parser&#39;)<br>        img_tag = soup_item.find(&#39;img&#39;)<br><br>        print(&#39;{} {} {}&#39;.format(movie_name, movie_date, img_tag[&#39;src&#39;]))<br><br><br>main()<br># BeautifulSoup(init_page, &#39;html.parser&#39;) # 这里用 BeautifulSoup(init_page, &#39;lxml&#39;) 报错","like_count":0,"discussions":[{"author":{"id":1096261,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ba/45/6722444c.jpg","nickname":"D","note":"","ucode":"248B90F19469A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4535,"discussion_content":"py3 下需要安装下包， pip3 install lxml","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565525551,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114747,"user_name":"爬行的蜗牛","can_delete":false,"product_type":"c1","uid":1033956,"ip_address":"","ucode":"6623B62DE63CE9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/QD6bf8hkS5dHrabdW7M7Oo9An1Oo3QSxqoySJMDh7GTraxFRX77VZ2HZ13x3R4EVYddIGXicRRDAc7V9z5cLDlA/132","comment_is_top":false,"comment_ctime":1563377019,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1563377019","product_id":100026901,"comment_content":"景霄老师，算我愚钝，我没太理解这个协程本质上是怎样提高效率的，","like_count":0,"discussions":[{"author":{"id":1636568,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM6iagw7ct4ca3niaSEFNicu2wy2KuCibO6eiaRzoRGJb50WTrbkKQib9mTArnTr8jJUazO9O2ibLZNfjjl35cfCHkBPs7N/132","nickname":"Geek_f39659","note":"","ucode":"2206A8C590423C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":10865,"discussion_content":"谈谈我的看法吧：这里提高效率有两个层次\n1 ）逻辑串行VS并行。\n就像一开始的那个4个URL的例子，如果为了写起来简单，只用一个for 循环+同步编程，那么总共用时就会是所有4个任务加起来，但实际上换一种写法就可以让这4个任务同时开始，分头推进，这样总用时就是4秒。\n2）协程VS多线程\n多线程也可以做到逻辑并行，没问题，大家也确实是这么玩了很多年了。一开始人们玩多进程，但发现进程非常昂贵，所以发明了多线程。后来又发现线程的生成和结束还是很昂贵，所以发明了线程池。但最后发现线程线程数1万-10万再要往上走，CPU的上下文切换可以非常频繁，累积起来会非常昂贵，甚至比要干的活都昂贵。所以当代最高级的玩法就是纯异步编程。这样就可以用1个或很少几个线程来完成大量逻辑并行的任务。 \n\n我异步编程玩了很深了，但python 是新手，我理解Python的协程其实是语法糖封装好的单线程异步，用得好的话性能可以非常好，而且代码简单易维护。使用了“协程”这个名字，但是跟c++的协程不沾边。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1568330735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114713,"user_name":"闲人","can_delete":false,"product_type":"c1","uid":1546492,"ip_address":"","ucode":"F04C0463C6BB5F","user_header":"https://static001.geekbang.org/account/avatar/00/17/98/fc/b1d22b7e.jpg","comment_is_top":false,"comment_ctime":1563368796,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563368796","product_id":100026901,"comment_content":"请问：生产者消费者模型代码的运行结果，cnosumer_1和consumer_2出现的顺序是交替变化的，第一次出现是1在前2在后，第二次出现就是2在前1在后，这是不是与queue.get()的运行时间有关系？","like_count":0},{"had_liked":false,"id":114002,"user_name":"brooks","can_delete":false,"product_type":"c1","uid":1543142,"ip_address":"","ucode":"CAB9E07753773D","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/e6/55394f59.jpg","comment_is_top":false,"comment_ctime":1563202784,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563202784","product_id":100026901,"comment_content":"aiohttp包的作者建议不要每个连接都创建一个session，除非是对于不同的host这些，速度上，共用一个session会更快","like_count":0},{"had_liked":false,"id":113484,"user_name":"刘润森","can_delete":false,"product_type":"c1","uid":1236556,"ip_address":"","ucode":"84101C670A6747","user_header":"https://static001.geekbang.org/account/avatar/00/12/de/4c/a51ece16.jpg","comment_is_top":false,"comment_ctime":1563028403,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563028403","product_id":100026901,"comment_content":"小白想说，为什么跑不起来<br><br><br>%time asyncio.run(main([&#39;url_1&#39;, &#39;url_2&#39;, &#39;url_3&#39;, &#39;url_4&#39;]))<br><br>报错：<br>asyncio.run() cannot be called from a running event loop<br>","like_count":0},{"had_liked":false,"id":113171,"user_name":"Quincy","can_delete":false,"product_type":"c1","uid":1194412,"ip_address":"","ucode":"FFFBB9FFCB98A4","user_header":"https://static001.geekbang.org/account/avatar/00/12/39/ac/76beadf1.jpg","comment_is_top":false,"comment_ctime":1562907590,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562907590","product_id":100026901,"comment_content":"老师，说到协程，就想到了tornado框架，tornado框架是个异步处理的框架，但结合pymysql操作数据库，即使采用异步协程的写法却仍然无法调用到tornado架构内异步处理的流程，相反还会阻塞，导致访问速度下降，百度了一番，原因感觉是因为pymysql并不支持tornado的异步协议，那这种情况我该怎么处理。","like_count":0},{"had_liked":false,"id":112775,"user_name":"岁月婧好","can_delete":false,"product_type":"c1","uid":1580287,"ip_address":"","ucode":"A75DB677DE61D3","user_header":"https://static001.geekbang.org/account/avatar/00/18/1c/ff/cfc25424.jpg","comment_is_top":false,"comment_ctime":1562824651,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1562824651","product_id":100026901,"comment_content":"解密协程运行时 中的第三段代码：<br>    await asyncio.sleep(2)<br>    task_3.cancel()<br>这个不应该先等待2秒、然后取消task_3,之后执行task_1、task_2、task_3，用时：等待的2秒+3秒（worker_3）？？ <br>为什么用时是2秒？<br>","like_count":0,"discussions":[{"author":{"id":1249268,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0f/f4/2bdbf26b.jpg","nickname":"hiver comme été","note":"","ucode":"425255CDC0875F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1827,"discussion_content":"这里我的理解是 先创建三个任务 1，2 ，3 加入到事件循环之中， await 执行之后，切出 顺序执行 1，2 ，3， 这里由于等待时间比 任务3 的时间长， 就可以取消掉，相当于设定一个时长， 超过了，就取消任务。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562933027,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111898,"user_name":"converse✪","can_delete":false,"product_type":"c1","uid":1433812,"ip_address":"","ucode":"0CC4C24A6458B6","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/d4/bdd3ed27.jpg","comment_is_top":false,"comment_ctime":1562635192,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1562635192","product_id":100026901,"comment_content":"有没有发现，<br>await asyncio.gather(*tasks)<br>或者     <br>for task in tasks: <br>   await task<br>以上两种，协程处理的顺序是按照列表中task的顺序执行的。这点感觉和线程不一样，线程中会出现竞争CPU控制来执行代码，因此各个线程之间是无序的。而协程中，感觉总是按协程加入循环事件的顺序进行执行，除非该协程通过await asyncio.sleep(sleep_time) ，才能跳过而执行下一个协程。<br>求交流~！","like_count":0,"discussions":[{"author":{"id":1636568,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM6iagw7ct4ca3niaSEFNicu2wy2KuCibO6eiaRzoRGJb50WTrbkKQib9mTArnTr8jJUazO9O2ibLZNfjjl35cfCHkBPs7N/132","nickname":"Geek_f39659","note":"","ucode":"2206A8C590423C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":10871,"discussion_content":"你说的很对，python协程的本质是单线程异步编程。所以你可想象成是有一个任务列表，有一个线程不断从里面拿任务来做，有的任务会制造新的任务入列，但有时IO和timer也会创建新任务入列。所以真正任务的执行顺序取决于入列顺序。单线程异步是没有你说的那种多线程竞争CPU的情况的。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1568331320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111880,"user_name":"Xg huang","can_delete":false,"product_type":"c1","uid":1016995,"ip_address":"","ucode":"9680FA95DE3553","user_header":"","comment_is_top":false,"comment_ctime":1562633890,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562633890","product_id":100026901,"comment_content":"请教一下老师<br><br>文章里说的多线程，我的理解是python的多线程编程，与操作系统底层的线程应该可以对应得上<br><br>但协程是不是可以理解为更高层次调度方式，操作系统依然使用线程调度机制来实现？","like_count":0},{"had_liked":false,"id":111395,"user_name":"gugu","can_delete":false,"product_type":"c1","uid":1346069,"ip_address":"","ucode":"A87EFB95B43CE7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/QEqicKQS1lCunSfI7tIcfhTOb0GjIRRIiav2PBc4ZUvstNXhP2LISfhwwRqSJjwbpupMeaqclUGKc78lfS7JVmUQ/132","comment_is_top":false,"comment_ctime":1562550993,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562550993","product_id":100026901,"comment_content":"感觉await这个关键字好神奇，首先会阻塞当前任务，放弃执行权；还会启动新的协程对象（如果await一个async函数）；并且会等待新的协程执行完毕返回。既是协程调度的入口，又像多线程的join一样具备同步任务的能力。","like_count":0},{"had_liked":false,"id":109799,"user_name":"吴林辉","can_delete":false,"product_type":"c1","uid":1222971,"ip_address":"","ucode":"56F117300FF33D","user_header":"https://static001.geekbang.org/account/avatar/00/12/a9/3b/f4ca20d8.jpg","comment_is_top":false,"comment_ctime":1562115725,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562115725","product_id":100026901,"comment_content":"Python 3.7以下基于生成器的上面的例子要如何实现","like_count":0},{"had_liked":false,"id":109636,"user_name":"Ben","can_delete":false,"product_type":"c1","uid":1252353,"ip_address":"","ucode":"70351D4FAE47F7","user_header":"https://static001.geekbang.org/account/avatar/00/13/1c/01/5aaaf5b6.jpg","comment_is_top":false,"comment_ctime":1562069962,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562069962","product_id":100026901,"comment_content":"老师, 在cancel的示例代码中, asyncio.sleep(2)没有阻塞asyncio.gather(task_1, task_2, task_3, return_exceptions=True),这是为什么呢, 嵌套的协程函数和他的主协程函数是在同一级别吗?<br>  <br>async def w1():<br>    await asyncio.sleep(1)<br>    print(&#39;w1&#39;)<br>    return 1<br><br><br>async def w2():<br>    await asyncio.sleep(2)<br>    print(&#39;w2&#39;)<br>    return 2&#47;0<br><br><br>async def w3():<br>    await asyncio.sleep(3)<br>    print(&#39;w3&#39;)<br>    return 3<br><br><br>async def main3():<br>    t1 = asyncio.create_task(w1())<br>    t2 = asyncio.create_task(w2())<br>    t3 = asyncio.create_task(w3())<br>    await asyncio.sleep(2)<br>    # 先打印了w1 和 w2, 然后打印sleep end<br>    print(f&quot;main3 sleep end at {time.strftime(&#39;%X&#39;)}&quot;)<br>    t3.cancel()<br>    res = await asyncio.gather(t1, t2, t3, return_exceptions=True)<br>    print(res)<br>print(f&quot;main3 started at {time.strftime(&#39;%X&#39;)}&quot;)<br>asyncio.run(main3())<br>print(f&quot;main3 end at {time.strftime(&#39;%X&#39;)}&quot;)","like_count":0},{"had_liked":false,"id":108805,"user_name":"小侠龙旋风","can_delete":false,"product_type":"c1","uid":1126441,"ip_address":"","ucode":"073F3924A99835","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/29/d6816ebf.jpg","comment_is_top":false,"comment_ctime":1561886096,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561886096","product_id":100026901,"comment_content":"7月豆瓣上海电影想看榜前十：<br>九龙不败 07月02日 3669<br>宝莱坞机器人2.0：重生归来 07月12日 5769<br>小小的愿望 07月18日 6768<br>银河补习班 07月18日 10732<br>命运之夜——天之杯II ：迷失之蝶 07月12日 13012<br>扫毒2天地对决 07月05日 17165<br>爱宠大机密2 07月05日 22385<br>刀背藏身 07月19日 24413<br>猪八戒·传说 07月19日 25599<br>狮子王 07月12日 42468","like_count":0},{"had_liked":false,"id":108746,"user_name":"小侠龙旋风","can_delete":false,"product_type":"c1","uid":1126441,"ip_address":"","ucode":"073F3924A99835","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/29/d6816ebf.jpg","comment_is_top":false,"comment_ctime":1561873239,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561873239","product_id":100026901,"comment_content":"init_soup = BeautifulSoup(init_page, &#39;html.parser&#39;)可以爬取到数据，若features设置为&#39;lxml&#39;跑不通。还要定义一个header={&quot;User-Agent&quot;: &quot;Mozilla&#47;5.0 (Windows NT 6.1; Win64; x64) AppleWebKit&#47;537.36 (KHTML, like Gecko) Chrome&#47;74.0.3729.157 Safari&#47;537.36&quot;}<br>pycharm下，统计时间的方法用time.perf_counter()算时间差。<br><br>建议老师讲解一下gevent、greenlet等第三方协程模块和优缺点。","like_count":0},{"had_liked":false,"id":108586,"user_name":"美美","can_delete":false,"product_type":"c1","uid":1148422,"ip_address":"","ucode":"44CC95C45AF345","user_header":"https://static001.geekbang.org/account/avatar/00/11/86/06/72b01bb7.jpg","comment_is_top":false,"comment_ctime":1561813108,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1561813108","product_id":100026901,"comment_content":"老师，有个疑问，我注释了“await task2”，为啥如下会输出“worker_2 start”？<br>--------------------------------------------------------------<br>import asyncio<br><br>async def worker_1():<br>    print(&#39;worker_1 start&#39;)<br>    await asyncio.sleep(1)<br>    print(&#39;worker_1 done&#39;)<br><br>async def worker_2():<br>    print(&#39;worker_2 start&#39;)<br>    await asyncio.sleep(2)<br>    print(&#39;worker_2 done&#39;)<br><br>async def main():<br>    task1 = asyncio.create_task(worker_1())<br>    task2 = asyncio.create_task(worker_2())<br>    print(&#39;before await&#39;)<br>    await task1<br>    print(&#39;awaited worker_1&#39;)<br>    # await task2<br>    print(&#39;awaited worker_2&#39;)<br><br>asyncio.run(main())<br><br><br><br>[Running] python3 -u &quot;&#47;Users&#47;XX&#47;code&#47;test.py&quot;<br>before await<br>worker_1 start<br>worker_2 start<br>worker_1 done<br>awaited worker_1<br>awaited worker_2<br><br>[Done] exited with code=0 in 1.087 seconds<br>","like_count":0,"discussions":[{"author":{"id":1249268,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0f/f4/2bdbf26b.jpg","nickname":"hiver comme été","note":"","ucode":"425255CDC0875F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1828,"discussion_content":"我理解的是， 创建了两个任务，加入到事件循环，await 开启循环，就开始 顺序执行两个任务，await 那个任务结束，调度再回到主函数，继续执行，不是 await task2 开启的 任务2 ，只是任务2 结束，","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1562933469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108377,"user_name":"new","can_delete":false,"product_type":"c1","uid":1096252,"ip_address":"","ucode":"DFFCDC2123CCAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/ba/3c/2b642c9a.jpg","comment_is_top":false,"comment_ctime":1561732794,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561732794","product_id":100026901,"comment_content":"刚开始看python时，看到有gil的说法，意思好像是只支持单线程，可是我在看python 教程时，最后都会讲多线程，今天百度也看个一知半解，谁能简单易懂的说下呢","like_count":0},{"had_liked":false,"id":108318,"user_name":"俊杰","can_delete":false,"product_type":"c1","uid":1020008,"ip_address":"","ucode":"197C1CB1D48CB5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/90/68/511fc1e5.jpg","comment_is_top":false,"comment_ctime":1561717078,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561717078","product_id":100026901,"comment_content":"老师，有个地方不理解。解密协程运行时那里的代码，第17-19行，await task1启动了第一个协程，协程sleep 1秒，这时运行时为什么不是先执行打印awaited worker_1，而是直接去执行await task2调起第二个协程呢？","like_count":0},{"had_liked":false,"id":107772,"user_name":"yshan","can_delete":false,"product_type":"c1","uid":1136788,"ip_address":"","ucode":"A2ECDCDA52B8EE","user_header":"https://static001.geekbang.org/account/avatar/00/11/58/94/c8bc2b59.jpg","comment_is_top":false,"comment_ctime":1561606421,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561606421","product_id":100026901,"comment_content":"# 安装nest_asyncio(pip install nest-asyncio)后解决RuntimeError: asyncio.run() cannot be called from a running event loop的问题了<br>import asyncio<br>import nest_asyncio<br><br>nest_asyncio.apply()<br>----------------------------------------------------------------<br>import asyncio<br>import nest_asyncio<br>nest_asyncio.apply()<br><br>async def crawl_page(url):<br>    print(&#39;crawling {}&#39;.format(url))<br>    sleep_time = int(url.split(&#39;_&#39;)[-1])<br>    await asyncio.sleep(sleep_time)<br>    print(&#39;OK {}&#39;.format(url))<br><br>async def main(urls):<br>    for url in urls:<br>        await crawl_page(url)<br><br>%time asyncio.run(main([&#39;url_1&#39;, &#39;url_2&#39;, &#39;url_3&#39;, &#39;url_4&#39;]))<br>==============================================<br>奇怪的是后续就不要加:<br>import nest_asyncio<br>nest_asyncio.apply()<br><br>import asyncio<br><br>async def worker_1():<br>    print(&#39;worker_1 start&#39;)<br>    await asyncio.sleep(1)<br>    print(&#39;worker_1 done&#39;)<br><br>async def worker_2():<br>    print(&#39;worker_2 start&#39;)<br>    await asyncio.sleep(2)<br>    print(&#39;worker_2 done&#39;)<br><br>async def main():<br>    task1 = asyncio.create_task(worker_1())<br>    task2 = asyncio.create_task(worker_2())<br>    print(&#39;before await&#39;)<br>    await task1<br>    print(&#39;awaited worker_1&#39;)<br>    await task2<br>    print(&#39;awaited worker_2&#39;)<br><br>%time asyncio.run(main())<br><br>结果:<br>before await<br>worker_1 start<br>worker_2 start<br>worker_1 done<br>awaited worker_1<br>worker_2 done<br>awaited worker_2<br>Wall time: 2.01 s","like_count":0},{"had_liked":false,"id":107753,"user_name":"响雨","can_delete":false,"product_type":"c1","uid":1581705,"ip_address":"","ucode":"C5FB3A3BC68F92","user_header":"https://static001.geekbang.org/account/avatar/00/18/22/89/73397ccb.jpg","comment_is_top":false,"comment_ctime":1561603462,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1561603462","product_id":100026901,"comment_content":"await asyncio.gather(consumer_1, consumer_2, producer_1, producer_2，...)这一段为什要放在await asyncio.sleep(10)后面执行，这样不就阻塞了10s了吗？ ","like_count":0,"discussions":[{"author":{"id":1105161,"avatar":"https://static001.geekbang.org/account/avatar/00/10/dd/09/feca820a.jpg","nickname":"helloworld","note":"","ucode":"1EECCA0F43E278","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547,"discussion_content":"不会阻塞，asyncio.sleep(10)是协程化的sleep，换句话说就是支持异步的sleep，是一个协程对象，而await + 协程对象就是为了让线程从当前中断去执行其他任务的，所以并不会阻塞。当sleep完成10秒后，线程会重新回来继续处理下面的代码。\n所以，await asyncio.sleep(10)在该代码中的意义是，让这两条语句在10秒中后再执行，以达到实验效果，因为consuser里是死循环，所以在最后需要显示取消掉：consumer_1.cancel()\n    consumer_2.cancel() ,","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561692176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107695,"user_name":"suifengyehun","can_delete":false,"product_type":"c1","uid":1526815,"ip_address":"","ucode":"189944EFFFB46B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJQDJajN26Fx1iaw5JroPHc7b4QqNQcIlZGZaVKz1qyiaho68J1ra5s6t1UCkaCUyogbcdcHscFOqOQ/132","comment_is_top":false,"comment_ctime":1561597312,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561597312","product_id":100026901,"comment_content":"# 安装nest_asyncio后解决RuntimeError: asyncio.run() cannot be called from a running event loop的问题了<br>import asyncio<br>import nest_asyncio<br><br>nest_asyncio.apply()<br><br><br>async def crawl_page(url):<br>    print(&#39;crawling {}&#39;.format(url))<br>    sleep_time = int(url.split(&#39;_&#39;)[-1])<br>    await asyncio.sleep(sleep_time)<br>    print(&#39;OK {}&#39;.format(url))<br><br>    <br>async def main(urls):<br>    for url in urls:<br>        await crawl_page(url)<br><br>%time asyncio.run(main([&#39;url_1&#39;, &#39;url_2&#39;, &#39;url_3&#39;, &#39;url_4&#39;]))","like_count":0},{"had_liked":false,"id":107426,"user_name":"Jie","can_delete":false,"product_type":"c1","uid":1355892,"ip_address":"","ucode":"B251D8EB7BCEE1","user_header":"https://static001.geekbang.org/account/avatar/00/14/b0/74/5e8b277b.jpg","comment_is_top":false,"comment_ctime":1561534565,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1561534565","product_id":100026901,"comment_content":"请问为什么使用jupyter notebook 运行后出现，RuntimeError: asyncio.run() cannot be called from a running event loop，用编译器运行就不会？","like_count":0,"discussions":[{"author":{"id":1141751,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6b/f7/3a3b82c2.jpg","nickname":"Aspirin","note":"","ucode":"858B551CF0C2F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1690,"discussion_content":"Stack Overflow上有个回答，说是Jupyter Notebook本身就会启动一个事件循环。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562816061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107360,"user_name":"小白","can_delete":false,"product_type":"c1","uid":1023983,"ip_address":"","ucode":"F453F9A90743A7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9f/ef/c989706e.jpg","comment_is_top":false,"comment_ctime":1561518708,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1561518708","product_id":100026901,"comment_content":"python3.7 报错 AttributeError: module &#39;asyncio&#39; has no attribute &#39;run&#39;","like_count":0,"discussions":[{"author":{"id":1105161,"avatar":"https://static001.geekbang.org/account/avatar/00/10/dd/09/feca820a.jpg","nickname":"helloworld","note":"","ucode":"1EECCA0F43E278","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428,"discussion_content":"如果是的话，换一个名字就好了，否则import asyncio时导入的是当前目录下的asyncio.py文件，因为查找python模块路径的sys.path变量的第一个字段是空字符串，代表优先从当前目录开始找模块","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561546115,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1105161,"avatar":"https://static001.geekbang.org/account/avatar/00/10/dd/09/feca820a.jpg","nickname":"helloworld","note":"","ucode":"1EECCA0F43E278","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427,"discussion_content":"你的python文件名字是不是叫asyncio.py或者当前目录下有其他文件叫这个名字","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561545972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106973,"user_name":"ZJY😇","can_delete":false,"product_type":"c1","uid":1524683,"ip_address":"","ucode":"766DB464A0403C","user_header":"https://static001.geekbang.org/account/avatar/00/17/43/cb/665048ce.jpg","comment_is_top":false,"comment_ctime":1561430169,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1561430169","product_id":100026901,"comment_content":"总结里说协程是单线程，可是如果是单线程为什么多任务（sleep）时间可以重叠呢","like_count":0,"discussions":[{"author":{"id":1005520,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/d0/b9312769.jpg","nickname":"北斗(宇)","note":"","ucode":"9532B48D7C29C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543427,"discussion_content":"我的理解是:单线程不等于是一个执行顺序流,可能是多个执行顺序流(协程),只不过协程比线程占用的资源更少.就像线程比进程占用的资源少,单进程有多线程,单线程有多协程.不知道,我的理解对不对,欢迎指正","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641132616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1394019,"avatar":"https://static001.geekbang.org/account/avatar/00/15/45/63/d3319b80.jpg","nickname":"奔跑的蜗牛","note":"","ucode":"88D855ED42F134","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":611,"discussion_content":"时间没有重叠，只是耗时比较短 切换的时间也很快，感觉不出来。如果是CPU消耗比较的程序就会明显的看出来了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561797829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1009622,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/d6/2f5cb85c.jpg","nickname":"xmr","note":"","ucode":"1BBF165F91F10B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337,"discussion_content":"sleep的时候会交出CPU使用权，别的task就可以用了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561455029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106914,"user_name":"王校","can_delete":false,"product_type":"c1","uid":1486868,"ip_address":"","ucode":"BBE375D730B021","user_header":"https://static001.geekbang.org/account/avatar/00/16/b0/14/e5c445ba.jpg","comment_is_top":false,"comment_ctime":1561424579,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561424579","product_id":100026901,"comment_content":"老师能不能讲一讲 python 程序第一行 # !&#47;bin&#47;env 设置。看了有的程序使用不同的环境。不知道为什么","like_count":0},{"had_liked":false,"id":106855,"user_name":"KaitoShy","can_delete":false,"product_type":"c1","uid":1038415,"ip_address":"","ucode":"E2E2E9BD3F5048","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d8/4f/65abc6f0.jpg","comment_is_top":false,"comment_ctime":1561414584,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561414584","product_id":100026901,"comment_content":"思考题，实现回调，不知道是否正确：<br>import asyncio<br><br>async def sleep():<br>    print(&#39;func sleep is start&#39;)<br>    await asyncio.sleep(1)<br>    print(&#39;func sleep is over&#39;)<br>    return &#39;stop&#39;<br><br>async def continue_sleep():<br>    print(&#39;i wanna to sleep again&#39;)<br>    await asyncio.sleep(2)<br><br>def callback_test(future):<br>    print(&#39;Callback: {}&#39;.format(future.result()))<br><br>async def main():<br>    task_1 = asyncio.create_task(sleep())<br>    task_2 = asyncio.create_task(continue_sleep())<br><br>    done, pending = await asyncio.wait({task_1, task_2})<br>    if task_1 in done:<br>        task_1.add_done_callback(callback_test)<br><br>asyncio.run(main())<br>===============返回================<br>func sleep is start<br>i wanna to sleep again<br>func sleep is over<br>Callback: stop","like_count":0},{"had_liked":false,"id":106797,"user_name":"汪zZ","can_delete":false,"product_type":"c1","uid":1234757,"ip_address":"","ucode":"8B93062A683902","user_header":"https://static001.geekbang.org/account/avatar/00/12/d7/45/d1621188.jpg","comment_is_top":false,"comment_ctime":1561387058,"is_pvip":true,"discussion_count":7,"race_medal":1,"score":"1561387058","product_id":100026901,"comment_content":"RuntimeError: asyncio.run() cannot be called from a running event loop<br>一直报错，是因为我python是3.7.0吗？","like_count":0,"discussions":[{"author":{"id":1075141,"avatar":"https://static001.geekbang.org/account/avatar/00/10/67/c5/63b09189.jpg","nickname":"刘朋","note":"","ucode":"7B7B8E4776C22E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419,"discussion_content":"原因是: The problem in your case is that jupyter (IPython) is already running an event loop (for IPython ≥ 7.0)\n解决是: 将 %time asyncio.run(main([&#39;url_1&#39;, &#39;url_2&#39;, &#39;url_3&#39;, &#39;url_4&#39;])) 换成 await main([&#39;url_1&#39;, &#39;url_2&#39;, &#39;url_3&#39;, &#39;url_4&#39;])","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1561541313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1149164,"avatar":"https://static001.geekbang.org/account/avatar/00/11/88/ec/1460179b.jpg","nickname":"我心飞扬","note":"","ucode":"E41155122C9A1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":19857,"discussion_content":"await main()\nAwait is outside function error 如何解决","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569231176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1149164,"avatar":"https://static001.geekbang.org/account/avatar/00/11/88/ec/1460179b.jpg","nickname":"我心飞扬","note":"","ucode":"E41155122C9A1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":19824,"discussion_content":"header is not defined 为什么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569229394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1078506,"avatar":"https://static001.geekbang.org/account/avatar/00/10/74/ea/10661bdc.jpg","nickname":"kevinsu","note":"","ucode":"BAD46B815D6A5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404,"discussion_content":"---------------------------------------------------------------------------\nRuntimeError                              Traceback (most recent call last)\n<timed eval> in <module>\n\n/usr/local/lib/python3.7/asyncio/runners.py in run(main, debug)\n     32     if events._get_running_loop() is not None:\n     33         raise RuntimeError(\n---> 34             &#34;asyncio.run() cannot be called from a running event loop&#34;)\n     35 \n     36     if not coroutines.iscoroutine(main):\n\nRuntimeError: asyncio.run() cannot be called from a running event loop","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561534915,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1078506,"avatar":"https://static001.geekbang.org/account/avatar/00/10/74/ea/10661bdc.jpg","nickname":"kevinsu","note":"","ucode":"BAD46B815D6A5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403,"discussion_content":"&#39;3.7.3 (default, Jun 25 2019, 15:06:54) \\n[GCC 4.8.5 20150623 (Red Hat 4.8.5-36)]&#39; 我在centos中装的这个版本的python，外加jupyter，也遇到了这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561534882,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1023983,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9f/ef/c989706e.jpg","nickname":"小白","note":"","ucode":"F453F9A90743A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":396,"discussion_content":"要3.7.3才可以，我也是3.7不可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561531434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1022247,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","nickname":"阿卡牛","note":"","ucode":"0BC43A904C3199","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290,"discussion_content":"Linux中运行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561429716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106770,"user_name":"©HJ","can_delete":false,"product_type":"c1","uid":1235078,"ip_address":"","ucode":"6331F3E77BCE89","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/86/bdf2ad51.jpg","comment_is_top":false,"comment_ctime":1561385408,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561385408","product_id":100026901,"comment_content":"%time 在windows里会报错","like_count":0},{"had_liked":false,"id":106656,"user_name":"程序员人生","can_delete":false,"product_type":"c1","uid":1113668,"ip_address":"","ucode":"C5C5073D89AAA2","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/44/3e3040ac.jpg","comment_is_top":false,"comment_ctime":1561365897,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561365897","product_id":100026901,"comment_content":"关于思考题，这样写不知道对不对？<br>import asyncio<br><br>async def computer(a,b,func):<br>    res = func(a,b)<br>    print(&quot;res:{}&quot;.format(res))<br>    return res<br><br>def max(a,b):<br>    print(&quot;max&quot;)<br>    return [a,b][a &lt; b]<br><br>def min(a,b):<br>    print(&quot;min&quot;)<br>    return [a,b][a &gt; b]<br><br><br>async def main():<br>    task1 = asyncio.create_task(computer(1, 2, max))<br>    task2 = asyncio.create_task(computer(4, 3, min))<br><br>    await asyncio.gather(task1,task2,return_exceptions=True)<br><br>asyncio.run(main())<br><br>执行结果：<br>max<br>res:2<br>min<br>res:3","like_count":0},{"had_liked":false,"id":106655,"user_name":"36度道","can_delete":false,"product_type":"c1","uid":1487798,"ip_address":"","ucode":"992F5D162FB4D0","user_header":"https://static001.geekbang.org/account/avatar/00/16/b3/b6/ac302d89.jpg","comment_is_top":false,"comment_ctime":1561365764,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1561365764","product_id":100026901,"comment_content":"老师，你那代码我一个都运行不出来。。%time那里会报错","like_count":0,"discussions":[{"author":{"id":1394019,"avatar":"https://static001.geekbang.org/account/avatar/00/15/45/63/d3319b80.jpg","nickname":"奔跑的蜗牛","note":"","ucode":"88D855ED42F134","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612,"discussion_content":"在pycharm中需要吧%time去掉，如果需要看执行时间的话需要导入time模块测算","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561797909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1022247,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","nickname":"阿卡牛","note":"","ucode":"0BC43A904C3199","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287,"discussion_content":"要在jupyter中运行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561429688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106653,"user_name":"36度道","can_delete":false,"product_type":"c1","uid":1487798,"ip_address":"","ucode":"992F5D162FB4D0","user_header":"https://static001.geekbang.org/account/avatar/00/16/b3/b6/ac302d89.jpg","comment_is_top":false,"comment_ctime":1561364964,"is_pvip":false,"replies":[{"id":"48241","content":"是的","user_name":"作者回复","user_name_real":"Jingxiao","uid":"1259521","ctime":1567141639,"ip_address":"","comment_id":106653,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561364964","product_id":100026901,"comment_content":"老师，课程的代码是基于py3的吗？","like_count":0,"discussions":[{"author":{"id":1259521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","nickname":"Jingxiao","note":"","ucode":"EB966BB87132F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455166,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567141639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106596,"user_name":"enjoylearning","can_delete":false,"product_type":"c1","uid":1000237,"ip_address":"","ucode":"DCAF8538DEA277","user_header":"https://static001.geekbang.org/account/avatar/00/0f/43/2d/af86d73f.jpg","comment_is_top":false,"comment_ctime":1561352646,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561352646","product_id":100026901,"comment_content":"并发一直想用future executor 来着，不知道这两个有什么区别没","like_count":0},{"had_liked":false,"id":106591,"user_name":"csn","can_delete":false,"product_type":"c1","uid":1524609,"ip_address":"","ucode":"68FAE1EE372ADF","user_header":"https://static001.geekbang.org/account/avatar/00/17/43/81/8b09dd90.jpg","comment_is_top":false,"comment_ctime":1561351151,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1561351151","product_id":100026901,"comment_content":"为什么在spyder下运行协程报错，<br>提示“ File &quot;C:\\ProgramData\\Anaconda3\\lib\\asyncio\\runners.py&quot;, line 34, in run<br>    &quot;asyncio.run() cannot be called from a running event loop&quot;)<br><br>RuntimeError: asyncio.run() cannot be called from a running event loop”<br><br>在pycharm下执行正常","like_count":0,"discussions":[{"author":{"id":1017781,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/87/b5/dd0353f4.jpg","nickname":"三水","note":"","ucode":"11837CF38FD9BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":252,"discussion_content":"https://github.com/jupyter/notebook/issues/3397#issuecomment-376803076\n\nIn Jupyter Cell:\n!pip install nest_asyncio\nimport nest_asyncio\nnest_asyncio.apply()\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1561361584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1075141,"avatar":"https://static001.geekbang.org/account/avatar/00/10/67/c5/63b09189.jpg","nickname":"刘朋","note":"","ucode":"7B7B8E4776C22E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420,"discussion_content":"原因是: The problem in your case is that jupyter (IPython) is already running an event loop (for IPython ≥ 7.0)\n解决是: 将 %time asyncio.run(main([&#39;url_1&#39;, &#39;url_2&#39;, &#39;url_3&#39;, &#39;url_4&#39;])) 换成 await main([&#39;url_1&#39;, &#39;url_2&#39;, &#39;url_3&#39;, &#39;url_4&#39;])","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561541330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1164127,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erwib5whv3NLYeAicibgceC0eC7J3pkqEKf4DUEUh8xcnDhv4djAZTbSIoh7WEIuJTqNsjbtaribde5ag/132","nickname":"林松","note":"","ucode":"9A48F890D74252","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265,"discussion_content":"有可能你的python版本低了，这个要3.7","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561370752,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106581,"user_name":"catshitfive","can_delete":false,"product_type":"c1","uid":1542973,"ip_address":"","ucode":"E030B61F3D0811","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/3d/2a3b67f8.jpg","comment_is_top":false,"comment_ctime":1561348038,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1561348038","product_id":100026901,"comment_content":"用adaconda升级了到python version 3.7.3,发现新的api asyncio.run()在调用的时候报错：asyncio.run() cannot be called from a running event loop,在网上看了下解决方法(不清楚为什么这么做):pip thirdparty模块:nest-asyncio,然后调用其模块内函数apply就可以正常使用了","like_count":0,"discussions":[{"author":{"id":1297523,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cc/73/9c41a7ee.jpg","nickname":"雷蒙德张","note":"","ucode":"0104F5818EA7F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":262619,"discussion_content":"我看了老师置顶的帖子，又看到了这个方法，按照下面的步骤解决了：\n1. 在机器上安装nest-asyncio模块：pip install nest-asyncio\n2. 在代码块的开头加上\n    import nest_asyncio\n    nest_asyncio.apply()","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589117904,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106552,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1561342678,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561342678","product_id":100026901,"comment_content":"这个代码是不是只有在linux环境才能运行成功<br>","like_count":0},{"had_liked":false,"id":106551,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1561342662,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1561342662","product_id":100026901,"comment_content":"%time 是什么语法糖，直接输出时间，要怎么写？","like_count":0,"discussions":[{"author":{"id":1038415,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d8/4f/65abc6f0.jpg","nickname":"KaitoShy","note":"","ucode":"E2E2E9BD3F5048","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":241,"discussion_content":"这是ipython的语法，你可以用jupyter notebook编写，vscode就有这个插件 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561348717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106548,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1561342412,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561342412","product_id":100026901,"comment_content":"协程的第一个例子，一运行就报错：<br>RuntimeError: asyncio.run() cannot be called from a running event loop<br><br>win7 64位 python3.7.3","like_count":0},{"had_liked":false,"id":106537,"user_name":"cotter","can_delete":false,"product_type":"c1","uid":1523993,"ip_address":"","ucode":"3F06D658140CD3","user_header":"https://static001.geekbang.org/account/avatar/00/17/41/19/30504ae1.jpg","comment_is_top":false,"comment_ctime":1561340637,"is_pvip":false,"replies":[{"id":"48242","content":"这个没有统一结论。需要根据硬件设置和具体线上的条件，进行测试莱选取最优的并发数量","user_name":"作者回复","user_name_real":"Jingxiao","uid":"1259521","ctime":1567141751,"ip_address":"","comment_id":106537,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1561340637","product_id":100026901,"comment_content":"受教了，第一次听说这个高级功能！<br>我在工作中遇到一个需要并发的问题，用python在后台并发执行shell ,并发数量用时间范围控制，要不停的改时间分多次串行，方法比较笨拙。协程可以简化我的代码。<br>老师，并发很多事件应该也是需要消耗很多资源，协程改如何控制并发数量？","like_count":0,"discussions":[{"author":{"id":1259521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","nickname":"Jingxiao","note":"","ucode":"EB966BB87132F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455129,"discussion_content":"这个没有统一结论。需要根据硬件设置和具体线上的条件，进行测试莱选取最优的并发数量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567141751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1105161,"avatar":"https://static001.geekbang.org/account/avatar/00/10/dd/09/feca820a.jpg","nickname":"helloworld","note":"","ucode":"1EECCA0F43E278","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516,"discussion_content":"看你的描述，协程不一定适用于你的场景。另外你的最后一个问题，协程是单线程中的事件循环方式实现的并发，由于同一时间只有一个任务在使用CPU，所以不需要控制并发数量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561629207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1268778,"avatar":"","nickname":"sky","note":"","ucode":"6D31488C0DAFCC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":233,"discussion_content":"信号量，， 信号灯\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561345269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106532,"user_name":"李","can_delete":false,"product_type":"c1","uid":1025478,"ip_address":"","ucode":"044D5C47939824","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a5/c6/5ead3889.jpg","comment_is_top":false,"comment_ctime":1561339821,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1561339821","product_id":100026901,"comment_content":"代码中我敲的time那一块一直报invalid syntax？<br>%time asyncio.run","like_count":0,"discussions":[{"author":{"id":1225669,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b3/c5/38439724.jpg","nickname":"南瓜不胡闹","note":"","ucode":"5E5AF11DF97180","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":249,"discussion_content":"这个是ipython的魔法命令，jupyter也能用，一般的环境没有","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561358527,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1268778,"avatar":"","nickname":"sky","note":"","ucode":"6D31488C0DAFCC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":231,"discussion_content":"个人觉得应该是在Python Console 里去运行 %time\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561344862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106508,"user_name":"Hoo-Ah","can_delete":false,"product_type":"c1","uid":1306913,"ip_address":"","ucode":"823093A6C7DEE7","user_header":"https://static001.geekbang.org/account/avatar/00/13/f1/21/52e8267b.jpg","comment_is_top":false,"comment_ctime":1561338141,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561338141","product_id":100026901,"comment_content":"使用asyncio获取事件循环，将执行的函数使用loop创建一个任务。add_done_callback将回掉函数传进去。","like_count":0},{"had_liked":false,"id":106492,"user_name":"夜月不挂科","can_delete":false,"product_type":"c1","uid":1543651,"ip_address":"","ucode":"9D358B176E5CA9","user_header":"https://static001.geekbang.org/account/avatar/00/17/8d/e3/c3ed083a.jpg","comment_is_top":false,"comment_ctime":1561335697,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561335697","product_id":100026901,"comment_content":"创建loop事件循环asyncio.get_event_loop","like_count":0}]}