{"id":209520,"title":"02 | 代码加锁：不要让“锁”事成为烦心事","content":"<p>你好，我是朱晔。</p><p>在上一讲中，我与你介绍了使用并发容器等工具解决线程安全的误区。今天，我们来看看解决线程安全问题的另一种重要手段——锁，在使用上比较容易犯哪些错。</p><p>我先和你分享一个有趣的案例吧。有一天，一位同学在群里说“见鬼了，疑似遇到了一个JVM的Bug”，我们都很好奇是什么Bug。</p><p>于是，他贴出了这样一段代码：在一个类里有两个int类型的字段a和b，有一个add方法循环1万次对a和b进行++操作，有另一个compare方法，同样循环1万次判断a是否小于b，条件成立就打印a和b的值，并判断a&gt;b是否成立。</p><pre><code>@Slf4j\npublic class Interesting {\n\n    volatile int a = 1;\n    volatile int b = 1;\n\n    public void add() {\n        log.info(&quot;add start&quot;);\n        for (int i = 0; i &lt; 10000; i++) {\n            a++;\n            b++;\n        }\n        log.info(&quot;add done&quot;);\n    }\n\n    public void compare() {\n        log.info(&quot;compare start&quot;);\n        for (int i = 0; i &lt; 10000; i++) {\n            //a始终等于b吗？\n            if (a &lt; b) {\n                log.info(&quot;a:{},b:{},{}&quot;, a, b, a &gt; b);\n                //最后的a&gt;b应该始终是false吗？\n            }\n        }\n        log.info(&quot;compare done&quot;);\n    }\n}\n</code></pre><p>他起了两个线程来分别执行add和compare方法：</p><pre><code>Interesting interesting = new Interesting();\nnew Thread(() -&gt; interesting.add()).start();\nnew Thread(() -&gt; interesting.compare()).start();\n</code></pre><p>按道理，a和b同样进行累加操作，应该始终相等，compare中的第一次判断应该始终不会成立，不会输出任何日志。但，执行代码后发现不但输出了日志，而且更诡异的是，compare方法在判断a&lt;b成立的情况下还输出了a&gt;b也成立：</p><p><img src=\"https://static001.geekbang.org/resource/image/9e/1d/9ec61aada64ac6d38681dd199c0ee61d.png?wh=1884*312\" alt=\"\"></p><p>群里一位同学看到这个问题笑了，说：“这哪是JVM的Bug，分明是线程安全问题嘛。很明显，你这是在操作两个字段a和b，有线程安全问题，应该为add方法加上锁，确保a和b的++是原子性的，就不会错乱了。”随后，他为add方法加上了锁：</p><!-- [[[read_end]]] --><pre><code>public synchronized void add()\n</code></pre><p>但，加锁后问题并没有解决。</p><p>我们来仔细想一下，为什么锁可以解决线程安全问题呢。因为只有一个线程可以拿到锁，所以加锁后的代码中的资源操作是线程安全的。但是，<strong>这个案例中的add方法始终只有一个线程在操作，显然只为add方法加锁是没用的</strong>。</p><p>之所以出现这种错乱，是因为两个线程是交错执行add和compare方法中的业务逻辑，而且这些业务逻辑不是原子性的：a++和b++操作中可以穿插在compare方法的比较代码中；更需要注意的是，a&lt;b这种比较操作在字节码层面是加载a、加载b和比较三步，代码虽然是一行但也不是原子性的。</p><p>所以，正确的做法应该是，为add和compare都加上方法锁，确保add方法执行时，compare无法读取a和b：</p><pre><code>public synchronized void add()\npublic synchronized void compare()\n</code></pre><p>所以，使用锁解决问题之前一定要理清楚，我们要保护的是什么逻辑，多线程执行的情况又是怎样的。</p><h2>加锁前要清楚锁和被保护的对象是不是一个层面的</h2><p>除了没有分析清线程、业务逻辑和锁三者之间的关系随意添加无效的方法锁外，还有一种比较常见的错误是，没有理清楚锁和要保护的对象是否是一个层面的。</p><p>我们知道<strong>静态字段属于类，类级别的锁才能保护；而非静态字段属于类实例，实例级别的锁就可以保护。</strong></p><p>先看看这段代码有什么问题：在类Data中定义了一个静态的int字段counter和一个非静态的wrong方法，实现counter字段的累加操作。</p><pre><code>class Data {\n    @Getter\n    private static int counter = 0;\n    \n    public static int reset() {\n        counter = 0;\n        return counter;\n    }\n\n    public synchronized void wrong() {\n        counter++;\n    }\n}\n</code></pre><p>写一段代码测试下：</p><pre><code>@GetMapping(&quot;wrong&quot;)\npublic int wrong(@RequestParam(value = &quot;count&quot;, defaultValue = &quot;1000000&quot;) int count) {\n    Data.reset();\n    //多线程循环一定次数调用Data类不同实例的wrong方法\n    IntStream.rangeClosed(1, count).parallel().forEach(i -&gt; new Data().wrong());\n    return Data.getCounter();\n}\n</code></pre><p>因为默认运行100万次，所以执行后应该输出100万，但页面输出的是639242：</p><p><img src=\"https://static001.geekbang.org/resource/image/77/0b/777f520e9d0be89b66e814d3e7c1a30b.png?wh=858*178\" alt=\"\"></p><p>我们来分析下为什么会出现这个问题吧。</p><p>在非静态的wrong方法上加锁，只能确保多个线程无法执行同一个实例的wrong方法，却不能保证不会执行不同实例的wrong方法。而静态的counter在多个实例中共享，所以必然会出现线程安全问题。</p><p>理清思路后，修正方法就很清晰了：同样在类中定义一个Object类型的静态字段，在操作counter之前对这个字段加锁。</p><pre><code>class Data {\n    @Getter\n    private static int counter = 0;\n    private static Object locker = new Object();\n\n    public void right() {\n        synchronized (locker) {\n            counter++;\n        }\n    }\n}\n</code></pre><p>你可能要问了，把wrong方法定义为静态不就可以了，这个时候锁是类级别的。可以是可以，但我们不可能为了解决线程安全问题改变代码结构，把实例方法改为静态方法。</p><p>感兴趣的同学还可以从字节码以及JVM的层面继续探索一下，代码块级别的synchronized和方法上标记synchronized关键字，在实现上有什么区别。</p><h2>加锁要考虑锁的粒度和场景问题</h2><p>在方法上加synchronized关键字实现加锁确实简单，也因此我曾看到一些业务代码中几乎所有方法都加了synchronized，但这种滥用synchronized的做法：</p><ul>\n<li>一是，没必要。通常情况下60%的业务代码是三层架构，数据经过无状态的Controller、Service、Repository流转到数据库，没必要使用synchronized来保护什么数据。</li>\n<li>二是，可能会极大地降低性能。使用Spring框架时，默认情况下Controller、Service、Repository是单例的，加上synchronized会导致整个程序几乎就只能支持单线程，造成极大的性能问题。</li>\n</ul><p><strong>即使我们确实有一些共享资源需要保护，也要尽可能降低锁的粒度，仅对必要的代码块甚至是需要保护的资源本身加锁。</strong></p><p>比如，在业务代码中，有一个ArrayList因为会被多个线程操作而需要保护，又有一段比较耗时的操作（代码中的slow方法）不涉及线程安全问题，应该如何加锁呢？</p><p>错误的做法是，给整段业务逻辑加锁，把slow方法和操作ArrayList的代码同时纳入synchronized代码块；更合适的做法是，把加锁的粒度降到最低，只在操作ArrayList的时候给这个ArrayList加锁。</p><pre><code>private List&lt;Integer&gt; data = new ArrayList&lt;&gt;();\n\n//不涉及共享资源的慢方法\nprivate void slow() {\n    try {\n        TimeUnit.MILLISECONDS.sleep(10);\n    } catch (InterruptedException e) {\n    }\n}\n\n//错误的加锁方法\n@GetMapping(&quot;wrong&quot;)\npublic int wrong() {\n    long begin = System.currentTimeMillis();\n    IntStream.rangeClosed(1, 1000).parallel().forEach(i -&gt; {\n        //加锁粒度太粗了\n        synchronized (this) {\n            slow();\n            data.add(i);\n        }\n    });\n    log.info(&quot;took:{}&quot;, System.currentTimeMillis() - begin);\n    return data.size();\n}\n\n//正确的加锁方法\n@GetMapping(&quot;right&quot;)\npublic int right() {\n    long begin = System.currentTimeMillis();\n    IntStream.rangeClosed(1, 1000).parallel().forEach(i -&gt; {\n        slow();\n        //只对List加锁\n        synchronized (data) {\n            data.add(i);\n        }\n    });\n    log.info(&quot;took:{}&quot;, System.currentTimeMillis() - begin);\n    return data.size();\n}\n</code></pre><p>执行这段代码，同样是1000次业务操作，正确加锁的版本耗时1.4秒，而对整个业务逻辑加锁的话耗时11秒。</p><p><img src=\"https://static001.geekbang.org/resource/image/1c/43/1cb278c010719ee00d988dbb2a42c543.png?wh=1820*98\" alt=\"\"></p><p><strong>如果精细化考虑了锁应用范围后，性能还无法满足需求的话，我们就要考虑另一个维度的粒度问题了，即：区分读写场景以及资源的访问冲突，考虑使用悲观方式的锁还是乐观方式的锁。</strong></p><p>一般业务代码中，很少需要进一步考虑这两种更细粒度的锁，所以我只和你分享几个大概的结论，你可以根据自己的需求来考虑是否有必要进一步优化：</p><ul>\n<li>对于读写比例差异明显的场景，考虑使用ReentrantReadWriteLock细化区分读写锁，来提高性能。</li>\n<li>如果你的JDK版本高于1.8、共享资源的冲突概率也没那么大的话，考虑使用StampedLock的乐观读的特性，进一步提高性能。</li>\n<li>JDK里ReentrantLock和ReentrantReadWriteLock都提供了公平锁的版本，在没有明确需求的情况下不要轻易开启公平锁特性，在任务很轻的情况下开启公平锁可能会让性能下降上百倍。</li>\n</ul><h2>多把锁要小心死锁问题</h2><p>刚才我们聊到锁的粒度够用就好，这就意味着我们的程序逻辑中有时会存在一些细粒度的锁。但一个业务逻辑如果涉及多把锁，容易产生死锁问题。</p><p>之前我遇到过这样一个案例：下单操作需要锁定订单中多个商品的库存，拿到所有商品的锁之后进行下单扣减库存操作，全部操作完成之后释放所有的锁。代码上线后发现，下单失败概率很高，失败后需要用户重新下单，极大影响了用户体验，还影响到了销量。</p><p>经排查发现是死锁引起的问题，背后原因是扣减库存的顺序不同，导致并发的情况下多个线程可能相互持有部分商品的锁，又等待其他线程释放另一部分商品的锁，于是出现了死锁问题。</p><p>接下来，我们剖析一下核心的业务代码。</p><p>首先，定义一个商品类型，包含商品名、库存剩余和商品的库存锁三个属性，每一种商品默认库存1000个；然后，初始化10个这样的商品对象来模拟商品清单：</p><pre><code>@Data\n@RequiredArgsConstructor\nstatic class Item {\n    final String name; //商品名\n    int remaining = 1000; //库存剩余\n    @ToString.Exclude //ToString不包含这个字段 \n    ReentrantLock lock = new ReentrantLock();\n}\n</code></pre><p>随后，写一个方法模拟在购物车进行商品选购，每次从商品清单（items字段）中随机选购三个商品（为了逻辑简单，我们不考虑每次选购多个同类商品的逻辑，购物车中不体现商品数量）：</p><pre><code>private List&lt;Item&gt; createCart() {\n    return IntStream.rangeClosed(1, 3)\n            .mapToObj(i -&gt; &quot;item&quot; + ThreadLocalRandom.current().nextInt(items.size()))\n            .map(name -&gt; items.get(name)).collect(Collectors.toList());\n}\n</code></pre><p>下单代码如下：先声明一个List来保存所有获得的锁，然后遍历购物车中的商品依次尝试获得商品的锁，最长等待10秒，获得全部锁之后再扣减库存；如果有无法获得锁的情况则解锁之前获得的所有锁，返回false下单失败。</p><pre><code>private boolean createOrder(List&lt;Item&gt; order) {\n    //存放所有获得的锁\n    List&lt;ReentrantLock&gt; locks = new ArrayList&lt;&gt;();\n\n    for (Item item : order) {\n        try {\n            //获得锁10秒超时\n            if (item.lock.tryLock(10, TimeUnit.SECONDS)) {\n                locks.add(item.lock);\n            } else {\n                locks.forEach(ReentrantLock::unlock);\n                return false;\n            }\n        } catch (InterruptedException e) {\n        }\n    }\n    //锁全部拿到之后执行扣减库存业务逻辑\n    try {\n        order.forEach(item -&gt; item.remaining--);\n    } finally {\n        locks.forEach(ReentrantLock::unlock);\n    }\n    return true;\n}\n</code></pre><p>我们写一段代码测试这个下单操作。模拟在多线程情况下进行100次创建购物车和下单操作，最后通过日志输出成功的下单次数、总剩余的商品个数、100次下单耗时，以及下单完成后的商品库存明细：</p><pre><code>@GetMapping(&quot;wrong&quot;)\npublic long wrong() {\n    long begin = System.currentTimeMillis();\n    //并发进行100次下单操作，统计成功次数\n    long success = IntStream.rangeClosed(1, 100).parallel()\n            .mapToObj(i -&gt; {\n                List&lt;Item&gt; cart = createCart();\n                return createOrder(cart);\n            })\n            .filter(result -&gt; result)\n            .count();\n    log.info(&quot;success:{} totalRemaining:{} took:{}ms items:{}&quot;,\n            success,\n            items.entrySet().stream().map(item -&gt; item.getValue().remaining).reduce(0, Integer::sum),\n            System.currentTimeMillis() - begin, items);\n    return success;\n}\n</code></pre><p>运行程序，输出如下日志：</p><p><img src=\"https://static001.geekbang.org/resource/image/14/05/141a5ed915e08e50c0f6b066bea36e05.png?wh=3038*260\" alt=\"\"></p><p>可以看到，100次下单操作成功了65次，10种商品总计10000件，库存总计为9805，消耗了195件符合预期（65次下单成功，每次下单包含三件商品），总耗时50秒。</p><p>为什么会这样呢？</p><p>使用JDK自带的VisualVM工具来跟踪一下，重新执行方法后不久就可以看到，线程Tab中提示了死锁问题，根据提示点击右侧线程Dump按钮进行线程抓取操作：</p><p><img src=\"https://static001.geekbang.org/resource/image/ff/ce/ff24ac10bd0635ef4bf5987038b622ce.png?wh=2784*348\" alt=\"\"></p><p>查看抓取出的线程栈，在页面中部可以看到如下日志：</p><p><img src=\"https://static001.geekbang.org/resource/image/c3/42/c32cb32eb5433aae3b392738a80bca42.png?wh=1938*420\" alt=\"\"></p><p>显然，<strong>是出现了死锁，线程4在等待的一个锁被线程3持有，线程3在等待的另一把锁被线程4持有</strong>。</p><p>那为什么会有死锁问题呢？</p><p>我们仔细回忆一下购物车添加商品的逻辑，随机添加了三种商品，假设一个购物车中的商品是item1和item2，另一个购物车中的商品是item2和item1，一个线程先获取到了item1的锁，同时另一个线程获取到了item2的锁，然后两个线程接下来要分别获取item2和item1的锁，这个时候锁已经被对方获取了，只能相互等待一直到10秒超时。</p><p>其实，避免死锁的方案很简单，<strong>为购物车中的商品排一下序，让所有的线程一定是先获取item1的锁然后获取item2的锁，就不会有问题了</strong>。所以，我只需要修改一行代码，对createCart获得的购物车按照商品名进行排序即可：</p><pre><code>@GetMapping(&quot;right&quot;)\npublic long right() {\n    ...\n.    \n    long success = IntStream.rangeClosed(1, 100).parallel()\n            .mapToObj(i -&gt; {\n                List&lt;Item&gt; cart = createCart().stream()\n                        .sorted(Comparator.comparing(Item::getName))\n                        .collect(Collectors.toList());\n                return createOrder(cart);\n            })\n            .filter(result -&gt; result)\n            .count();\n    ...\n    return success;\n}\n</code></pre><p>测试一下right方法，不管执行多少次都是100次成功下单，而且性能相当高，达到了3000以上的TPS：</p><p><img src=\"https://static001.geekbang.org/resource/image/a4/e4/a41d077eeecc8b922503409d13a465e4.png?wh=970*352\" alt=\"\"></p><p>这个案例中，虽然产生了死锁问题，但因为尝试获取锁的操作并不是无限阻塞的，所以没有造成永久死锁，之后的改进就是避免循环等待，通过对购物车的商品进行排序来实现有顺序的加锁，避免循环等待。</p><h2>重点回顾</h2><p>我们一起总结回顾下，使用锁来解决多线程情况下线程安全问题的坑吧。</p><p>第一，使用synchronized加锁虽然简单，但我们首先要弄清楚共享资源是类还是实例级别的、会被哪些线程操作，synchronized关联的锁对象或方法又是什么范围的。</p><p>第二，加锁尽可能要考虑粒度和场景，锁保护的代码意味着无法进行多线程操作。对于Web类型的天然多线程项目，对方法进行大范围加锁会显著降级并发能力，要考虑尽可能地只为必要的代码块加锁，降低锁的粒度；而对于要求超高性能的业务，还要细化考虑锁的读写场景，以及悲观优先还是乐观优先，尽可能针对明确场景精细化加锁方案，可以在适当的场景下考虑使用ReentrantReadWriteLock、StampedLock等高级的锁工具类。</p><p>第三，业务逻辑中有多把锁时要考虑死锁问题，通常的规避方案是，避免无限等待和循环等待。</p><p>此外，<strong>如果业务逻辑中锁的实现比较复杂的话，要仔细看看加锁和释放是否配对，是否有遗漏释放或重复释放的可能性；并且对于分布式锁要考虑锁自动超时释放了，而业务逻辑却还在进行的情况下，如果别的线线程或进程拿到了相同的锁，可能会导致重复执行</strong>。</p><p>为演示方便，今天的案例是在Controller的逻辑中开新的线程或使用线程池进行并发模拟，我们当然可以意识到哪些对象是并发操作的。但对于Web应用程序的天然多线程场景，你可能更容易忽略这点，并且也可能因为误用锁降低应用整体的吞吐量。<strong>如果你的业务代码涉及复杂的锁操作，强烈建议Mock相关外部接口或数据库操作后对应用代码进行压测，通过压测排除锁误用带来的性能问题和死锁问题</strong>。</p><p>今天用到的代码，我都放在了GitHub上，你可以点击<a href=\"https://github.com/JosephZhu1983/java-common-mistakes\">这个链接</a>查看。</p><h2>思考与讨论</h2><ol>\n<li>本文开头的例子里，变量a、b都使用了volatile关键字，你知道原因吗？我之前遇到过这样一个坑：我们开启了一个线程无限循环来跑一些任务，有一个bool类型的变量来控制循环的退出，默认为true代表执行，一段时间后主线程将这个变量设置为了false。如果这个变量不是volatile修饰的，子线程可以退出吗？你能否解释其中的原因呢？</li>\n<li>文末我们又提了两个坑，一是加锁和释放没有配对的问题，二是锁自动释放导致的重复逻辑执行的问题。你有什么方法来发现和解决这两种问题吗？</li>\n</ol><p>在使用锁的过程中，你还遇到过其他坑吗？我是朱晔，欢迎在评论区与我留言分享你的想法，也欢迎你把这篇文章分享给你的朋友或同事，一起交流。</p>","neighbors":{"left":{"article_title":"01 | 使用了并发工具类库，线程安全就高枕无忧了吗？","id":209494},"right":{"article_title":"03 | 线程池：业务代码最常用也最容易犯错的组件","id":210337}},"comments":[{"had_liked":false,"id":186393,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":true,"comment_ctime":1583834394,"is_pvip":true,"replies":[{"id":"71974","content":"👍🏻","user_name":"作者回复","comment_id":186393,"uid":"1001470","ip_address":"","utype":1,"ctime":1583836605,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"9.2233723863310008e+18","product_id":100047701,"comment_content":"思考与讨论：<br>volatile的问题：可见性问题和禁止指令重排序优化。<br>可见性问题：本质上是cpu缓存失效，必须从主内存读取数据；<br>禁止指令重排序优化：x86处理器仅下，只实现了volatile的读写内存屏障，也就是store load，也就是写读，本质上也就是读写可见性，happen-before原则。<br>实现原理是通过寄存器esp实现的。<br>当然也不会退出循环，因为cpu缓存到主内存的同步不是实时的。<br><br>锁释放和重复执行问题：锁建议使用synchronized，在JDK1.6后，synchronized与Lock性能上差距很小了（优化了很多，自旋锁，自适应自旋锁、偏向锁，轻量级锁等），synchronized也不用程序获取和释放锁，同步代码块是通过monitorenter monitorexit实现的，同步方法是方法头中有ACC_SYNCHRONIZED标志；在分布式场景下，可以考虑etcd，etcd支持锁的自动续期等；<br>重复执行：首先在锁的使用场景下做好处理，尽量避免重复执行，但业务层面一定要做好幂等。<br><br><br><br><br>","like_count":82,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486737,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583836605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186279,"user_name":"Seven.Lin澤耿","can_delete":false,"product_type":"c1","uid":1181192,"ip_address":"","ucode":"4CAB732CD6F149","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/08/855abb02.jpg","comment_is_top":false,"comment_ctime":1583815421,"is_pvip":false,"replies":[{"id":"71938","content":"这个回答太赞了！","user_name":"作者回复","comment_id":186279,"uid":"1001470","ip_address":"","utype":1,"ctime":1583817080,"user_name_real":"朱晔"}],"discussion_count":3,"race_medal":0,"score":"233512049405","product_id":100047701,"comment_content":"1.加群解锁没有配对可以用一些代码质量工具协助排插，如Sonar，集成到ide和代码仓库，在编码阶段发现，加上超时自动释放，避免长期占有锁<br>2.锁超时自动释放导致重复执行的话，可以用锁续期，如redisson的watchdog；或者保证业务的幂等性，重复执行也没问题。","like_count":54,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486701,"discussion_content":"这个回答太赞了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583817080,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381321,"discussion_content":"额 问题上可能有所区别，。。如果非要考虑 集群中  节点的m s同步，那么就是写一半以上的m 才认为拿到锁。如果仅仅是主从那么就是等主从同步以后  如果是1主多从 那么就是至少一半的从，也就是semi-sync的玩法了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625014994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1166695,"avatar":"https://static001.geekbang.org/account/avatar/00/11/cd/67/23fab87a.jpg","nickname":"张鑫","note":"","ucode":"3CE5B1077184B2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297707,"discussion_content":"redission的watchdog也不能保证分布式锁正常吧，感觉幂等是个必要条件,如果要求比较高的话，就可能会出现下边这种情况:\n    如果redis master和salve同步的过程中，master宕机了，偏偏在这之前某个服务实例刚刚写入了一把锁，salve还没有同步到这把锁，就被切换成了master，那么这时候可以说就有问题了，另一个服务实例在新的master上获取到一把新锁，这时候就会出现俩台服务实例都持有锁，执行业务逻辑的场景","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597029351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186665,"user_name":"睿睿睿睿睿睿、","can_delete":false,"product_type":"c1","uid":1013729,"ip_address":"","ucode":"616B0058FCC7E0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/77/e1/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1583897779,"is_pvip":false,"replies":[{"id":"72047","content":"其实Java8出来已经挺久了，使用Lambda和Stream可以显著改善代码可读性，确保代码简洁性，因此专栏是大量使用Java8的一些新特性的。给你几个建议：<br>1、可以进一步订阅极客时间专门的学习java的专栏系统学习Lambda语法，比如https:&#47;&#47;time.geekbang.org&#47;course&#47;detail&#47;181-107395，然后自己对着练习一下<br>2、买一本《Java实战第二版》系统学习Java8的方方面面<br>3、关注一下本专栏的加餐，之后我们会通过加餐介绍下Java8<br>4、遇到实在看不懂的代码，下载源码后，在IDEA中点击lambda或stream API的地方，停留一下，左侧可以看到有提示 replace stream API with loop或replace lambda with anonymous class选项，翻译为非stream和lambda的语法，帮助你理解","user_name":"作者回复","comment_id":186665,"uid":"1001470","ip_address":"","utype":1,"ctime":1583902248,"user_name_real":"朱晔"}],"discussion_count":9,"race_medal":0,"score":"199152393395","product_id":100047701,"comment_content":"老师我有个意见代码能否不要大量使用Lambda表达式，并不是每个读者都是老司机","like_count":47,"discussions":[{"author":{"id":1216284,"avatar":"https://static001.geekbang.org/account/avatar/00/12/8f/1c/1c728388.jpg","nickname":"皮卡皮卡","note":"","ucode":"D440EEC7301C76","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":203106,"discussion_content":"这也是当自己走出舒适区啊","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1583998369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486830,"discussion_content":"其实Java8出来已经挺久了，使用Lambda和Stream可以显著改善代码可读性，确保代码简洁性，因此专栏是大量使用Java8的一些新特性的。给你几个建议：\n1、可以进一步订阅极客时间专门的学习java的专栏系统学习Lambda语法，比如https://time.geekbang.org/course/detail/181-107395，然后自己对着练习一下\n2、买一本《Java实战第二版》系统学习Java8的方方面面\n3、关注一下本专栏的加餐，之后我们会通过加餐介绍下Java8\n4、遇到实在看不懂的代码，下载源码后，在IDEA中点击lambda或stream API的地方，停留一下，左侧可以看到有提示 replace stream API with loop或replace lambda with anonymous class选项，翻译为非stream和lambda的语法，帮助你理解","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1583902248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1812970,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","nickname":"mgs2002","note":"","ucode":"F5931108BD509B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":205828,"discussion_content":"Lambda很香呀","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1584347718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1178235,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fa/7b/f89a398b.jpg","nickname":"Charles | 姜海龙","note":"","ucode":"17BA74D1684184","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":202452,"discussion_content":"对对，赶紧学习Lambda吧没那么难，网上随便找找资料基本就理解个大概","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1583919452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1023959,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9f/d7/18ee8352.jpg","nickname":"超群","note":"","ucode":"365D7F3A3BD73E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530386,"discussion_content":"可以使用LINQ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637063577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1378524,"avatar":"https://static001.geekbang.org/account/avatar/00/15/08/dc/c88e97b3.jpg","nickname":"聆世冷暖","note":"","ucode":"509C9FCC146136","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391088,"discussion_content":"建议使用JDK 1.0","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630290680,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1974876,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJUCiacuh59wMZAeeNRwLiaGaRMZHibF05IibXeiaZfjcFfkmTwJTmPszibXLAQkk2mMdx8chPjTs2yvpZg/132","nickname":"Sky1225","note":"","ucode":"6F428AF396D99D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385538,"discussion_content":"不会得学","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627117631,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381322,"discussion_content":"lambda 用起来没问题，。我对下边的研发就一句话，考虑代码的健壮性。。有些同学写代码考虑的不够权限，遇到lambda导致的bug 问题排查也确实困难不少","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625015056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336543,"discussion_content":"走出舒适区","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608623006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186225,"user_name":"黄海峰","can_delete":false,"product_type":"c1","uid":1275357,"ip_address":"","ucode":"E9340719BC96B2","user_header":"https://static001.geekbang.org/account/avatar/00/13/75/dd/9ead6e69.jpg","comment_is_top":false,"comment_ctime":1583804810,"is_pvip":false,"replies":[{"id":"71930","content":"有两个方面：1. 避免超时，单独开一个线程给锁延长有效期。比如设置锁有效期30s，有个线程每隔10s重新设置下锁的有效期。  2. 避免重复，业务上增加一个标记是否被处理的字段。或者开一张新表，保存已经处理过的流水号。","user_name":"作者回复","comment_id":186225,"uid":"1001470","ip_address":"","utype":1,"ctime":1583807753,"user_name_real":"朱晔"}],"discussion_count":7,"race_medal":0,"score":"151907660170","product_id":100047701,"comment_content":"超时自动释放锁后怎么避免重复逻辑好难，面试曾被卡，求解。。。","like_count":36,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486680,"discussion_content":"有两个方面：1. 避免超时，单独开一个线程给锁延长有效期。比如设置锁有效期30s，有个线程每隔10s重新设置下锁的有效期。  2. 避免重复，业务上增加一个标记是否被处理的字段。或者开一张新表，保存已经处理过的流水号。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583807753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1217955,"avatar":"https://static001.geekbang.org/account/avatar/00/12/95/a3/0a3cde60.jpg","nickname":"leon","note":"","ucode":"97610F35D2543A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":317312,"discussion_content":"锁要释放前，判断一下业务逻辑执行状态，如果是执行中，则续约锁。如果执行成功、失败、异常等情况，释放锁。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1603532549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381323,"discussion_content":"redisson的 watchdog 经典玩法了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625015075,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1236895,"avatar":"https://static001.geekbang.org/account/avatar/00/12/df/9f/18810a24.jpg","nickname":"雪影绮缘","note":"","ucode":"BB131E1EC110DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":262243,"discussion_content":"老师，延长锁的有效期这个方案，具体如何实施呢，单独开一个线程还要确保锁的对象是同一个","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589055477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1246178,"avatar":"https://static001.geekbang.org/account/avatar/00/13/03/e2/5768d26e.jpg","nickname":"inrtyx","note":"","ucode":"81CD18FF34ABAB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331080,"discussion_content":"对于第一个方案，那启不是永远不会超时，跟设不设置超时有什么区别吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606784347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1488356,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b5/e4/e6faf686.jpg","nickname":"握了个大蚂蚱","note":"","ucode":"AD34AD4FA37371","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1246178,"avatar":"https://static001.geekbang.org/account/avatar/00/13/03/e2/5768d26e.jpg","nickname":"inrtyx","note":"","ucode":"81CD18FF34ABAB","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":339886,"discussion_content":"因为如果节点持有锁并且在执行业务，，就是要不停续期保证业务执行完；而因为宕机造成的锁占用，就可以因为续期线程的同步挂掉而保证及时对锁进行释放","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609833255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":331080,"ip_address":""},"score":339886,"extra":""},{"author":{"id":1575056,"avatar":"https://static001.geekbang.org/account/avatar/00/18/08/90/ce429e02.jpg","nickname":"sunshine","note":"","ucode":"0CF3A7F542FA9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1488356,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b5/e4/e6faf686.jpg","nickname":"握了个大蚂蚱","note":"","ucode":"AD34AD4FA37371","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394436,"discussion_content":"有没有这么一种场景：业务线程异常退出，导致没有主动释放锁。而续期线程还不断的续期？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631882816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":339886,"ip_address":""},"score":394436,"extra":""}]}]},{"had_liked":false,"id":186066,"user_name":"编程界的小学生","can_delete":false,"product_type":"c1","uid":1593289,"ip_address":"","ucode":"4A5BE9A5E877FA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","comment_is_top":false,"comment_ctime":1583749163,"is_pvip":false,"replies":[{"id":"71899","content":"嗯必须加volatile或者使用AtomicBoolean&#47;AtomicReference等也行，后者相比volatile除了确保可见性还提供了CAS方法保证原子性","user_name":"作者回复","comment_id":186066,"uid":"1001470","ip_address":"","utype":1,"ctime":1583763980,"user_name_real":"朱晔"}],"discussion_count":4,"race_medal":0,"score":"104662964267","product_id":100047701,"comment_content":"1.不能退出。必须加volatile，因为volatile保证了可见性。改完后会强制让工作内存失效。去主存拿。如果不加volatile的话那么在while true里面添加输出语句也是OK的。因为println源码加锁了，sync会让当前线程的工作内存失效。<br>解释的对吗？献丑了。","like_count":24,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486609,"discussion_content":"嗯必须加volatile或者使用AtomicBoolean/AtomicReference等也行，后者相比volatile除了确保可见性还提供了CAS方法保证原子性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583763980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1215888,"avatar":"https://static001.geekbang.org/account/avatar/00/12/8d/90/ed5d203d.jpg","nickname":"linkq","note":"","ucode":"3FC807BD9CED1C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214590,"discussion_content":"能不能给个不能退出的例子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585211835,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1045090,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f2/62/f873cd8f.jpg","nickname":"tongmin_tsai","note":"","ucode":"D9423E770D5846","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1215888,"avatar":"https://static001.geekbang.org/account/avatar/00/12/8d/90/ed5d203d.jpg","nickname":"linkq","note":"","ucode":"3FC807BD9CED1C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292388,"discussion_content":"public class NoExit implements Runnable {\n    boolean flag = true;\n    int i = 0;\n\n    @Override\n    public void run() {\n        while (flag) {\n            i++;\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        NoExit noExit = new NoExit();\n        new Thread(noExit).start();\n        TimeUnit.SECONDS.sleep(1);\n        noExit.flag = false;\n        System.out.println(noExit.i);\n        System.out.println(&#34;end&#34;);\n    }\n\n}\n\n可以试试，我的理解是如果用volatile解决可见性问题，如果在while (flag)的循环体里面再次使用（读取）flag，也是可以退出的，不知道我的理解是否正确","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595212882,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":214590,"ip_address":""},"score":292388,"extra":""}]},{"author":{"id":1063149,"avatar":"https://static001.geekbang.org/account/avatar/00/10/38/ed/72f73710.jpg","nickname":"嘻嘻","note":"","ucode":"C47140EF144225","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":202319,"discussion_content":"有可能不能退出","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583896522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186836,"user_name":"insight","can_delete":false,"product_type":"c1","uid":1313322,"ip_address":"","ucode":"6F4E51502D0224","user_header":"https://static001.geekbang.org/account/avatar/00/14/0a/2a/c7f5d3ac.jpg","comment_is_top":false,"comment_ctime":1583936270,"is_pvip":false,"replies":[{"id":"72102","content":"应该快了，大概是下周","user_name":"作者回复","comment_id":186836,"uid":"1001470","ip_address":"","utype":1,"ctime":1583971740,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"53123543822","product_id":100047701,"comment_content":"看老师使用Lambda表达式感觉学到了非常多，非常支持老师这样做，毕竟程序员就是要不断走出舒适区，学习新东西的。就是老师的Lambda加餐能不能早一点来，对照起来看的更舒服一些","like_count":12,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486892,"discussion_content":"应该快了，大概是下周","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583971740,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186541,"user_name":"汤杰","can_delete":false,"product_type":"c1","uid":1645600,"ip_address":"","ucode":"1BCBA3180FCABF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/pnqpjxyLtUpgJaOlrE8v57v3ZROECBdJeg96wvvPK2yK1ibHFibxRGyumOekveanVCibUcicw1EibiaBuicfkibGKuqFfw/132","comment_is_top":false,"comment_ctime":1583861875,"is_pvip":false,"replies":[{"id":"72050","content":"抱歉，因为本文删除了原来有的分布式锁的例子，所以最后总结这边的描述谈到的『锁自动超时释放问题』有点唐突，我们改一下。你理解的没错，锁过期是指分布式锁的过期，本地锁是只有等待锁超时","user_name":"作者回复","comment_id":186541,"uid":"1001470","ip_address":"","utype":1,"ctime":1583905231,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"53123469427","product_id":100047701,"comment_content":"对着代码看锁过期蒙了半天，还以为trylock的时间不是等待锁的时间，以为我一直理解的是错误的。最好加上特定的条件。本地锁哪有锁过期呢。原来有些分布式锁为了防止调用方挂了不释放锁加了超时。看到有说用客户端续期的，业务保证的，业务的确一定要保证的，用分布式锁可以解决业务数据库幂等在高并发冲突强烈下性能降低。","like_count":13,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486793,"discussion_content":"抱歉，因为本文删除了原来有的分布式锁的例子，所以最后总结这边的描述谈到的『锁自动超时释放问题』有点唐突，我们改一下。你理解的没错，锁过期是指分布式锁的过期，本地锁是只有等待锁超时","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583905231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240228,"user_name":"郑思雨","can_delete":false,"product_type":"c1","uid":1474579,"ip_address":"","ucode":"F1F4B08FC94E7D","user_header":"https://static001.geekbang.org/account/avatar/00/16/80/13/df2a0ced.jpg","comment_is_top":false,"comment_ctime":1596796117,"is_pvip":false,"replies":[{"id":"88688","content":"赞","user_name":"作者回复","comment_id":240228,"uid":"1001470","ip_address":"","utype":1,"ctime":1596797527,"user_name_real":"朱晔"}],"discussion_count":2,"race_medal":0,"score":"40251501781","product_id":100047701,"comment_content":"一、加锁和释放没有配对：<br>lock 与 unlock 通常结对使用，使用时，一般将unlock放在finally代码块中。但是释放锁时最好增加判断：<br>if (lock.isHeldByCurrentThread()) lock.unlock(); <br>这样避免锁持有超时后释放引发IllegalMonitorStateException异常。<br><br>如果怕忘记释放锁，可以将锁封装成一个代理模式，如下：<br>public class AutoUnlockProxy implements Closeable {<br><br>    private Lock lock;<br><br>    public AutoUnlockProxy(Lock lock){<br>        this.lock = lock;<br>    }<br><br>    public void lock(){<br>        lock.lock();<br>    }<br><br>    public boolean tryLock(){<br>        return lock.tryLock();<br>    }<br><br>    @Override<br>    public void close() throws IOException {<br>        lock.unlock();<br>    }<br>}<br><br>使用时，通过try-with-resource 的方式使用，可以达到自动释放锁的目的：<br>try(AutoUnlockProxy proxy = new AutoUnlockProxy(new ReentrantLock())){<br>            proxy.lock();<br>        }catch (Exception e){<br>            e.printStackTrace();<br>        }<br><br><br>二、锁自动释放导致的重复逻辑执行（补充的细节点）<br>1、代码层面：对请求进行验重；<br>2、数据库层面：如果有插入操作，建议设置唯一索引，在数据库层面能增加一层安全保障；","like_count":9,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503382,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596797527,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1242121,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f4/09/d78fa748.jpg","nickname":"栤枫","note":"","ucode":"72C5D6EB22CA9F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309144,"discussion_content":"&#34;锁自动释放导致的重复逻辑&#34;,为啥会导致重复?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601197745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":194573,"user_name":"看不到de颜色","can_delete":false,"product_type":"c1","uid":1162714,"ip_address":"","ucode":"88348CCAE81931","user_header":"https://static001.geekbang.org/account/avatar/00/11/bd/da/3d76ea74.jpg","comment_is_top":false,"comment_ctime":1585068852,"is_pvip":false,"replies":[{"id":"74074","content":"就是锁续期解决 可以看一下redisson实现","user_name":"作者回复","comment_id":194573,"uid":"1001470","ip_address":"","utype":1,"ctime":1585097924,"user_name_real":"朱晔"}],"discussion_count":3,"race_medal":0,"score":"27354872628","product_id":100047701,"comment_content":"关于锁过期问题。以前做redis分布式锁的时候一直在思考这个问题。当时觉得就是尽量让锁过期时间比程序执行之间略长一些，以保证加锁区域代码能尽量执行完成。看到老师给其他同学评论说可以用另外一个线程去不断重置锁时间，这里有我理解是针对像redis这种利用setnx实现的分布式锁可以这么解决。那还有其他场景吗？","like_count":6,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488849,"discussion_content":"就是锁续期解决 可以看一下redisson实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585097924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1242121,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f4/09/d78fa748.jpg","nickname":"栤枫","note":"","ucode":"72C5D6EB22CA9F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309134,"discussion_content":"&#34;尽量让锁过期时间比程序执行之间略长一些，以保证加锁区域代码能尽量执行完成&#34;,加锁区域代码没执行完锁就过期了,会跳过锁区域内后面的代码跳出锁区域?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601194942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1350991,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/4f/273ffb51.jpg","nickname":"小哪吒","note":"","ucode":"252087A733355C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1242121,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f4/09/d78fa748.jpg","nickname":"栤枫","note":"","ucode":"72C5D6EB22CA9F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391583,"discussion_content":"肯定不会呀，，加锁是为了保护共享资源，保证对其读写在同一时间只有一个线程可以访问。如果锁过期，当前线程还在锁保护区域内，下一个线程可以竞争获取锁 并进入锁保护区域。原本应该串行的逻辑变成了并行，这就出问题了呀。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630543240,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":309134,"ip_address":""},"score":391583,"extra":""}]}]},{"had_liked":false,"id":186339,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1583827614,"is_pvip":false,"replies":[{"id":"71966","content":"可以无限续期，比如redisson的RedissonLock，锁续期是每次续一段时间，比如30秒，然后10秒执行一次续期，虽然是无限次续期，即使客户端崩溃了也没关系无法自动续期后自然会超时","user_name":"作者回复","comment_id":186339,"uid":"1001470","ip_address":"","utype":1,"ctime":1583831128,"user_name_real":"朱晔"}],"discussion_count":3,"race_medal":0,"score":"27353631390","product_id":100047701,"comment_content":"volatile 老生长谈的问题了，关于锁过期，如果开启一个线程续期，但是有最大重试次数，比如 5 次，那么 5 次以后如何保证其它线程拿到锁而不会重复执行业务了？","like_count":6,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486721,"discussion_content":"可以无限续期，比如redisson的RedissonLock，锁续期是每次续一段时间，比如30秒，然后10秒执行一次续期，虽然是无限次续期，即使客户端崩溃了也没关系无法自动续期后自然会超时","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583831128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2152306,"avatar":"https://static001.geekbang.org/account/avatar/00/20/d7/72/cbef720d.jpg","nickname":"鲁鸣","note":"","ucode":"974BA3C3E64630","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307738,"discussion_content":"自动续期会不会导致饥饿，一直不释放了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600746907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1575056,"avatar":"https://static001.geekbang.org/account/avatar/00/18/08/90/ce429e02.jpg","nickname":"sunshine","note":"","ucode":"0CF3A7F542FA9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394438,"discussion_content":"同问啊，如果业务线程异常退出，导致没有主动释放锁，还怎么办？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631882988,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188787,"user_name":"木槿花开","can_delete":false,"product_type":"c1","uid":1068781,"ip_address":"","ucode":"7DD06CDB91A8ED","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/ed/e99fc0f9.jpg","comment_is_top":false,"comment_ctime":1584415785,"is_pvip":false,"replies":[{"id":"72820","content":"不是这个原因，主要是演示锁包裹了并不需要加锁的慢方法","user_name":"作者回复","comment_id":188787,"uid":"1001470","ip_address":"","utype":1,"ctime":1584419134,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"14469317673","product_id":100047701,"comment_content":"老师好：<br>&#47;&#47;不涉及共享资源的慢方法<br>TimeUnit.MILLISECONDS.sleep(10) 这个方法本质调用的是Thread的 public static void sleep(long millis, int nanos) 这是一个static的类方法,在加锁粒度太粗的wrong方法中,是不是因为线程都去抢Thread的类锁才导致耗时较长,Thread类不就成公共资源了？","like_count":3,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487525,"discussion_content":"不是这个原因，主要是演示锁包裹了并不需要加锁的慢方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584419134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187630,"user_name":"better","can_delete":false,"product_type":"c1","uid":1257750,"ip_address":"","ucode":"2B9BCCED753D7F","user_header":"https://static001.geekbang.org/account/avatar/00/13/31/16/f2269e73.jpg","comment_is_top":false,"comment_ctime":1584177212,"is_pvip":true,"replies":[{"id":"72417","content":"没错，主要就是为了防止多个线程交错执行两个方法，synchronized是比较简单清理的解决方式。","user_name":"作者回复","comment_id":187630,"uid":"1001470","ip_address":"","utype":1,"ctime":1584187785,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"14469079100","product_id":100047701,"comment_content":"实践了一遍add()方法和compare()方法这个例子，结合synchronized的底层原理，不知道理解得正不正确。在这个例子中的理解是，由于synchronized底层是基于moniter指令和对象锁实现的，所以当为add()方法和compare()方法同时加锁后，interesting这个对象就作为对象锁被锁住了，而每次拿到这个对象锁的线程只能有一个，所以执行add()方法的线程和执行compare()方法的两个线程在同一时刻有且只能有一个线程拿到了interesting这个对象锁，所以两个方法就变成串行化执行了，线程安全问题也就得到了解决。<br>不知道老师结合synchronized底层原理，在这个示例中有没有更好的理解方式","like_count":3,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487172,"discussion_content":"没错，主要就是为了防止多个线程交错执行两个方法，synchronized是比较简单清理的解决方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584187785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240586,"user_name":"小胡子","can_delete":false,"product_type":"c1","uid":1018182,"ip_address":"","ucode":"79FEC6400D25DA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/89/46/0b7828a1.jpg","comment_is_top":false,"comment_ctime":1596986384,"is_pvip":false,"replies":[{"id":"88831","content":"排序的是要加锁的对象不是数据库所有数据","user_name":"作者回复","comment_id":240586,"uid":"1001470","ip_address":"","utype":1,"ctime":1597022661,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"10186920976","product_id":100047701,"comment_content":"真实的业务场景中商品成千上万存储在db没办法对商品排序操作，那怎么避免死锁了呢","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503495,"discussion_content":"排序的是要加锁的对象不是数据库所有数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597022661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":195835,"user_name":"z小俊、Arno","can_delete":false,"product_type":"c1","uid":1301304,"ip_address":"","ucode":"312B3DDCF15102","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/38/7ab139a3.jpg","comment_is_top":false,"comment_ctime":1585218136,"is_pvip":false,"replies":[{"id":"74347","content":"你可能搞混了，比较下下面三段代码的输出：<br> System.out.println(IntStream.rangeClosed(1,10).mapToObj(i-&gt;i%2==0).filter(result-&gt;result==true).collect(Collectors.toList()));<br>        System.out.println(IntStream.rangeClosed(1,10).mapToObj(i-&gt;i%2==0).filter(result-&gt;result).collect(Collectors.toList()));<br>        System.out.println(IntStream.rangeClosed(1,10).mapToObj(i-&gt;i%2==0).map(result-&gt;result).collect(Collectors.toList()));","user_name":"作者回复","comment_id":195835,"uid":"1001470","ip_address":"","utype":1,"ctime":1585224762,"user_name_real":"朱晔"}],"discussion_count":2,"race_medal":0,"score":"10175152728","product_id":100047701,"comment_content":".filter(result -&gt; result) 老师 这个是什么作用啊？ 去掉，测试代码错误的示例结果也是对的了。","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489169,"discussion_content":"你可能搞混了，比较下下面三段代码的输出：\n System.out.println(IntStream.rangeClosed(1,10).mapToObj(i-&amp;gt;i%2==0).filter(result-&amp;gt;result==true).collect(Collectors.toList()));\n        System.out.println(IntStream.rangeClosed(1,10).mapToObj(i-&amp;gt;i%2==0).filter(result-&amp;gt;result).collect(Collectors.toList()));\n        System.out.println(IntStream.rangeClosed(1,10).mapToObj(i-&amp;gt;i%2==0).map(result-&amp;gt;result).collect(Collectors.toList()));","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585224762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1301304,"avatar":"https://static001.geekbang.org/account/avatar/00/13/db/38/7ab139a3.jpg","nickname":"z小俊、Arno","note":"","ucode":"312B3DDCF15102","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214686,"discussion_content":"明白了，，就是Stream<Boolean>😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585226247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188958,"user_name":"何岸康","can_delete":false,"product_type":"c1","uid":1444317,"ip_address":"","ucode":"F24898244A170D","user_header":"https://static001.geekbang.org/account/avatar/00/16/09/dd/02c73bd3.jpg","comment_is_top":false,"comment_ctime":1584439746,"is_pvip":false,"replies":[{"id":"72909","content":"不错","user_name":"作者回复","comment_id":188958,"uid":"1001470","ip_address":"","utype":1,"ctime":1584448941,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"10174374338","product_id":100047701,"comment_content":"Volatile保证了多线程操作时变量的可见性。java中还有两个关键字可以实现可见性，即synchronized和final。<br>http:&#47;&#47;www.cs.umd.edu&#47;~pugh&#47;java&#47;memoryModel&#47;jsr-133-faq.html中有比较详细的描述；英语不好我就不翻译了，直接贴出来。<br>Volatile：<br>“Volatile fields are special fields which are used for communicating state between threads. Each read of a volatile will see the last write to that volatile by any thread; in effect, they are designated by the programmer as fields for which it is never acceptable to see a &quot;stale&quot; value as a result of caching or reordering. The compiler and runtime are prohibited from allocating them in registers. They must also ensure that after they are written, they are flushed out of the cache to main memory, so they can immediately become visible to other threads. <br>Similarly, before a volatile field is read, the cache must be invalidated so that the value in main memory, not the local processor cache, is the one seen. There are also additional restrictions on reordering accesses to volatile variables.”<br>synchronized：<br>“This means that any memory operations which were visible to a thread before exiting a synchronized block are visible to any thread after it enters a synchronized block protected by the same monitor, since all the memory operations happen before the release, and the release happens before the acquire.”<br>final：<br>“The values for an object&#39;s final fields are set in its constructor. Assuming the object is constructed &quot;correctly&quot;, once an object is constructed, the values assigned to the final fields in the constructor will be visible to all other threads without synchronization. In addition, the visible values for any other object or array referenced by those final fields will be at least as up-to-date as the final fields.”<br>","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487578,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584448941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188389,"user_name":"mgs2002","can_delete":false,"product_type":"c1","uid":1812970,"ip_address":"","ucode":"F5931108BD509B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","comment_is_top":false,"comment_ctime":1584347993,"is_pvip":false,"replies":[{"id":"72689","content":"synchronized也可以确保可见性，本例的right实现中volatile不是必须的，我这里是一个例子就没有去掉了，而且主要还为了引出思考题","user_name":"作者回复","comment_id":188389,"uid":"1001470","ip_address":"","utype":1,"ctime":1584350315,"user_name_real":"朱晔"}],"discussion_count":2,"race_medal":0,"score":"10174282585","product_id":100047701,"comment_content":"老师，我知道volatile是保证线程间变量可见性和防止指令重排序的，不过开头例子我把a和b的volatile修饰去掉执行right方法，结果也是正确的呢","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487393,"discussion_content":"synchronized也可以确保可见性，本例的right实现中volatile不是必须的，我这里是一个例子就没有去掉了，而且主要还为了引出思考题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584350315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1812970,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","nickname":"mgs2002","note":"","ucode":"F5931108BD509B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206550,"discussion_content":"哦，是这样啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584414026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187879,"user_name":"请叫我和尚","can_delete":false,"product_type":"c1","uid":1703256,"ip_address":"","ucode":"33A8A1CDA103F9","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg","comment_is_top":false,"comment_ctime":1584264677,"is_pvip":false,"replies":[{"id":"72517","content":"可以给class加锁，对本例效果一样。正如你说的，加锁让让并行变为了串行，所以尽量要锁范围小一点，本例只是demo，真实情况对于++这种操作，加锁就没必要了，用Atomic类更好。","user_name":"作者回复","comment_id":187879,"uid":"1001470","ip_address":"","utype":1,"ctime":1584273368,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":1,"score":"10174199269","product_id":100047701,"comment_content":"老师的 Synchronized Demo2 给counter++，right 的方法是给 static 变量加Synchronized，但是上面又说了是多线程去执行++方法，static 是属于类的，你给static 加同步，是否可以理解为你给类加了锁，多线程下去执行这个方法，是不是就变为了不是多线程去并行执行，而是串行去执行了<br>同理是不是可以直接写 Synchronized(Data.class){ TODO }，<br>一个实例，比如 right 方法要处理100 个添加操作，本来是多线程去并行做 100N 个添加操作，但是去给 right方法 里加了类锁，就变成了串行去执行，","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487279,"discussion_content":"可以给class加锁，对本例效果一样。正如你说的，加锁让让并行变为了串行，所以尽量要锁范围小一点，本例只是demo，真实情况对于++这种操作，加锁就没必要了，用Atomic类更好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584273368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186157,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1583767897,"is_pvip":false,"replies":[{"id":"71928","content":"结果是一样的。但是如果不同方法需要不同的锁，那么就只能用多个锁字段了。<br>","user_name":"作者回复","comment_id":186157,"uid":"1001470","ip_address":"","utype":1,"ctime":1583807628,"user_name_real":"朱晔"}],"discussion_count":2,"race_medal":0,"score":"10173702489","product_id":100047701,"comment_content":" 老师，是用Data.class加锁，结果也是正确的。<br>请教一下：private static Object locker = new Object(); 与Data.class在加锁时，有什么优势吗？<br>因为我觉得：Data.class相对于新创建的locker对象更节省内存。<br><br>   public void right1() {<br>        synchronized (Data.class) {<br>            counter++;<br>        }<br>    }<br><br>测试代码<br><br>    public static void main(String[] args) throws InterruptedException {<br>        LongAdder adder = new LongAdder();<br>        for (int i = 0; i &lt; 10; i++) {<br>            Thread thread = new Thread(new Runnable() {<br>                @Override<br>                public void run() {<br>                    Data data = new Data();<br>                    for (int j = 0; j &lt; 10000; j++) {<br>&#47;&#47;                        data.wrong();<br>                        data.right1();<br>                    }<br>                    adder.increment();<br>                }<br>            });<br>            thread.start();<br>        }<br><br>        while (adder.longValue() &lt; 10){<br>            Thread.sleep(1000L);<br>        }<br><br>        System.out.println(counter);<br>    }","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486650,"discussion_content":"结果是一样的。但是如果不同方法需要不同的锁，那么就只能用多个锁字段了。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583807628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":201837,"discussion_content":"多谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583843402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186100,"user_name":"西街恶人","can_delete":false,"product_type":"c1","uid":1046779,"ip_address":"","ucode":"0B2E195565B080","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/fb/f3a2dc4d.jpg","comment_is_top":false,"comment_ctime":1583757399,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10173691991","product_id":100047701,"comment_content":"看老师使用了Lombok","like_count":2},{"had_liked":false,"id":224160,"user_name":"Sam.张朝","can_delete":false,"product_type":"c1","uid":1132448,"ip_address":"","ucode":"FB20554D94B250","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/a0/f12115b7.jpg","comment_is_top":false,"comment_ctime":1591288761,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5886256057","product_id":100047701,"comment_content":"这里都是大神啊，除了我这个小兵","like_count":1},{"had_liked":false,"id":204115,"user_name":"C10K","can_delete":false,"product_type":"c1","uid":1113158,"ip_address":"","ucode":"737829986EA941","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/46/3aa83d38.jpg","comment_is_top":false,"comment_ctime":1586334891,"is_pvip":true,"replies":[{"id":"76287","content":"可以单独下载","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1586337516,"ip_address":"","comment_id":204115,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5881302187","product_id":100047701,"comment_content":"openJDK8 下 没有visualVM","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491080,"discussion_content":"可以单独下载","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586337516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187748,"user_name":"Geek_guan","can_delete":false,"product_type":"c1","uid":1688939,"ip_address":"","ucode":"592603EB5F042D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLAia6hRmnSZyuLtKvxxXvg9vgUfwSReCOaHKGLKuRcNX2BCNdmCFSlXyBZvpSXia5LXKjAZKeBXKuw/132","comment_is_top":false,"comment_ctime":1584208301,"is_pvip":false,"replies":[{"id":"72439","content":"private static boolean b = true;<br>    public static void main(String[] args) throws InterruptedException {<br>        new Thread(()-&gt;{<br>            try {<br>                TimeUnit.SECONDS.sleep(3);<br>            } catch (InterruptedException e) { }<br>            b =false;<br>        }).start();<br>        while (b) {<br>            TimeUnit.MILLISECONDS.sleep(0);<br>        }<br>        System.out.println(&quot;done&quot;);<br>    }<br>这个试试？<br><br>其实是这样的，最健壮的程序还是要从根本上解决问题，确保所有场景都不出问题","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584233696,"ip_address":"","comment_id":187748,"utype":1}],"discussion_count":4,"race_medal":0,"score":"5879175597","product_id":100047701,"comment_content":"1.可以退出。说不能退出的都是没有做过实验的。即使没有使用volatile也可以退出，不信可以用idea做实验。","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487226,"discussion_content":"private static boolean b = true;\n    public static void main(String[] args) throws InterruptedException {\n        new Thread(()-&amp;gt;{\n            try {\n                TimeUnit.SECONDS.sleep(3);\n            } catch (InterruptedException e) { }\n            b =false;\n        }).start();\n        while (b) {\n            TimeUnit.MILLISECONDS.sleep(0);\n        }\n        System.out.println(&amp;quot;done&amp;quot;);\n    }\n这个试试？\n\n其实是这样的，最健壮的程序还是要从根本上解决问题，确保所有场景都不出问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584233696,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1364005,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d0/25/dde66856.jpg","nickname":"季秀","note":"","ucode":"552D21F3AECE6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209745,"discussion_content":"不是说不使用volatile就不能退出，而是有可能不退出。按老师说的，为了保证程序健壮性，需要从根本上解决。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584668874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1688939,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLAia6hRmnSZyuLtKvxxXvg9vgUfwSReCOaHKGLKuRcNX2BCNdmCFSlXyBZvpSXia5LXKjAZKeBXKuw/132","nickname":"Geek_guan","note":"","ucode":"592603EB5F042D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":222273,"discussion_content":"这个场景由于while循环导致cpu处于忙碌之中，没有空来及时更新自己的工作内存，如果让主线程休眠一会，就能够退出了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586110322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1183090,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0d/72/38c62a8f.jpg","nickname":"slowly","note":"","ucode":"D8F1FB2B9E7534","race_medal":2,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":204901,"discussion_content":"为什么呢？当循环中的sleep时间大于0时不加volatile也可以退出循环","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584237782,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187437,"user_name":"张少华","can_delete":false,"product_type":"c1","uid":1855708,"ip_address":"","ucode":"09DA0D3E7E0331","user_header":"","comment_is_top":false,"comment_ctime":1584109527,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879076823","product_id":100047701,"comment_content":"有收获","like_count":1},{"had_liked":false,"id":186674,"user_name":"汝林外史","can_delete":false,"product_type":"c1","uid":1188906,"ip_address":"","ucode":"3C66C0F0537A99","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/2a/33441e2b.jpg","comment_is_top":false,"comment_ctime":1583899952,"is_pvip":false,"replies":[{"id":"72051","content":"你是指哪段代码？","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1583905325,"ip_address":"","comment_id":186674,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5878867248","product_id":100047701,"comment_content":"老师，给list实例解锁，那操作list就会导致list一直变，那锁也是一直在变，这样不会有问题吗？","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486835,"discussion_content":"你是指哪段代码？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583905325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214339,"discussion_content":"对","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585184127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1067435,"avatar":"https://static001.geekbang.org/account/avatar/00/10/49/ab/6fde4a46.jpg","nickname":"Daizl","note":"","ucode":"0A6FE684E857AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209059,"discussion_content":"list里面的元素变了吧？但是list的实例应该还是那个，没有变的吧。老师，是这样的吧？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584604174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186586,"user_name":"ken","can_delete":false,"product_type":"c1","uid":1898282,"ip_address":"","ucode":"1D19B99EF869BF","user_header":"","comment_is_top":false,"comment_ctime":1583888811,"is_pvip":false,"replies":[{"id":"72043","content":"分布式锁同样有效","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1583893788,"ip_address":"","comment_id":186586,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5878856107","product_id":100047701,"comment_content":"老师给出的解决购物车死锁问题的代码能适用于分布式多个jvm的情况？","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486806,"discussion_content":"分布式锁同样有效","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583893788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1812970,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","nickname":"mgs2002","note":"","ucode":"F5931108BD509B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":203116,"discussion_content":"例子里面的代码应该只能单机有效","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583999965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186179,"user_name":"黑暗浪子","can_delete":false,"product_type":"c1","uid":1014691,"ip_address":"","ucode":"FBB8C24EBEC5BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/a3/82b2a73e.jpg","comment_is_top":false,"comment_ctime":1583771793,"is_pvip":true,"discussion_count":1,"race_medal":1,"score":"5878739089","product_id":100047701,"comment_content":"关于1，如果不是voliate，工作内存里这个bool变量既有可能是false也有可能是true。加了voliate，就看主内存了，此时如果是false，那么所有线程都可以读取，也就是提供了内存可见性。此时为false，则会退出，否则就会有某些线程永远当它为true去执行，造成死循环。关于2，如何保证锁不会自动释放是关键。所以这时候我们要查找锁为什呢会自动释放的原因。其实说到底，就是写Java的人要知道voliate这个关键字和mesi机制有什么关系","like_count":1,"discussions":[{"author":{"id":2924187,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/SluScDGqnhBNwmOQ774QEzuXiazk8Ab7ng8xCT81gunl9Hls9oibwB4AibCDxDtZwTe4mEib5QiaLXUqMv8iceXicXSYg/132","nickname":"Geek_080ce7","note":"","ucode":"C74D97C84983B9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561254,"discussion_content":"当cpu缓存刷新了自然会释放的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649586094,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186164,"user_name":"第一装甲集群司令克莱斯特","can_delete":false,"product_type":"c1","uid":1265707,"ip_address":"","ucode":"4E8FBB23AD860B","user_header":"https://static001.geekbang.org/account/avatar/00/13/50/2b/2344cdaa.jpg","comment_is_top":false,"comment_ctime":1583768333,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878735629","product_id":100047701,"comment_content":"volatile可以保证内存可见性，不保证原子性，禁止指令重排。","like_count":1},{"had_liked":false,"id":354362,"user_name":"杨明","can_delete":false,"product_type":"c1","uid":1172215,"ip_address":"广东","ucode":"6C94189823CCD0","user_header":"https://static001.geekbang.org/account/avatar/00/11/e2/f7/8625fd5d.jpg","comment_is_top":false,"comment_ctime":1660298419,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660298419","product_id":100047701,"comment_content":"老师，为啥我用Runnable起线程运行add和compare方法，触发不到a&lt;b？","like_count":0},{"had_liked":false,"id":341395,"user_name":"对对对，是我，是我","can_delete":false,"product_type":"c1","uid":1182133,"ip_address":"","ucode":"4DBD73850A9B41","user_header":"https://static001.geekbang.org/account/avatar/00/12/09/b5/bbb93647.jpg","comment_is_top":false,"comment_ctime":1649578209,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649578209","product_id":100047701,"comment_content":"第二个例子老师为什么要每次循环都new一个Data的对象呢？如果在循环外定义一个Data的对象，不就可以避免多个实例调用实例级别锁方法失效的问题了么？   在循环里new对象还容易造成内存溢出，其实这个写法并不好。","like_count":0},{"had_liked":false,"id":336351,"user_name":"花臂Seven","can_delete":false,"product_type":"c1","uid":2506417,"ip_address":"","ucode":"DBF07141BDE7A5","user_header":"https://static001.geekbang.org/account/avatar/00/26/3e/b1/46f42c7e.jpg","comment_is_top":false,"comment_ctime":1646106317,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646106317","product_id":100047701,"comment_content":"lambda高手","like_count":0},{"had_liked":false,"id":334345,"user_name":"子夜枯灯","can_delete":false,"product_type":"c1","uid":1359678,"ip_address":"","ucode":"5D84BFE7832038","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/3e/cdc36608.jpg","comment_is_top":false,"comment_ctime":1644895429,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644895429","product_id":100047701,"comment_content":"学习打卡:手敲代码完成class02的复习","like_count":0},{"had_liked":false,"id":327276,"user_name":"傲娇的小宝","can_delete":false,"product_type":"c1","uid":1493922,"ip_address":"","ucode":"C079B19BCC1B7C","user_header":"https://static001.geekbang.org/account/avatar/00/16/cb/a2/5e7c557e.jpg","comment_is_top":false,"comment_ctime":1640044494,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1640044494","product_id":100047701,"comment_content":"老师，关于商品锁那个，假设我a线程买的135号商品，b线程买的567号商品，然后我a线程想获取5号的锁，但是这个锁可能被b持有啊，这不是也会死锁么？","like_count":0,"discussions":[{"author":{"id":1014738,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLYMEPPrXDnqAgr2D7o1CEejzOVYkS4CgG5NGVVUlJVmOpzK9kib0p8q6st615cca8pz5fvyia5WZBw/132","nickname":"軍臨龍嘯","note":"","ucode":"35C626B5A80EDF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549342,"discussion_content":"没有循环，咋会死锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643869477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325244,"user_name":"梅子黄时雨","can_delete":false,"product_type":"c1","uid":1015938,"ip_address":"","ucode":"9F788D09C2E9E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/82/3c21b30c.jpg","comment_is_top":false,"comment_ctime":1638875231,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638875231","product_id":100047701,"comment_content":"涉及到多线程，要对底层实现有点认识的。","like_count":0},{"had_liked":false,"id":316556,"user_name":"Will","can_delete":false,"product_type":"c1","uid":1161437,"ip_address":"","ucode":"BB78C2B9B44D36","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/dd/d729557f.jpg","comment_is_top":false,"comment_ctime":1634389000,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634389000","product_id":100047701,"comment_content":"试了很多遍,第一个例子在java11里a 和 b 始终相等,即使不加volatile,怎么解释,java11做了这方面的优化?","like_count":0},{"had_liked":false,"id":309875,"user_name":"时光之刃","can_delete":false,"product_type":"c1","uid":1083381,"ip_address":"","ucode":"0F15CAD70BDDC3","user_header":"https://static001.geekbang.org/account/avatar/00/10/87/f5/c6d1ffed.jpg","comment_is_top":false,"comment_ctime":1630378028,"is_pvip":true,"replies":[{"id":"112256","content":"可以多宣传下","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1630385253,"ip_address":"","comment_id":309875,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1630378028","product_id":100047701,"comment_content":"老师是一个实干家，粉了","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526050,"discussion_content":"可以多宣传下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630385253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":302163,"user_name":"勿更改任何信息","can_delete":false,"product_type":"c1","uid":2028956,"ip_address":"","ucode":"575185C69C05A3","user_header":"","comment_is_top":false,"comment_ctime":1626101597,"is_pvip":false,"replies":[{"id":"109332","content":"过滤成功的","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1626142113,"ip_address":"","comment_id":302163,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1626101597","product_id":100047701,"comment_content":"<br>@GetMapping(&quot;wrong&quot;)<br>public long wrong() {<br>    long begin = System.currentTimeMillis();<br>    &#47;&#47;并发进行100次下单操作，统计成功次数<br>    long success = IntStream.rangeClosed(1, 100).parallel()<br>            .mapToObj(i -&gt; {<br>                List&lt;Item&gt; cart = createCart();<br>                return createOrder(cart);<br>            })<br>            .filter(result -&gt; result)<br>            .count();<br>    log.info(&quot;success:{} totalRemaining:{} took:{}ms items:{}&quot;,<br>            success,<br>            items.entrySet().stream().map(item -&gt; item.getValue().remaining).reduce(0, Integer::sum),<br>            System.currentTimeMillis() - begin, items);<br>    return success;<br>}<br><br><br>老师你这段代码filter（result —&gt;result）啥意思<br>","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523200,"discussion_content":"过滤成功的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626142113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296745,"user_name":"行则将至","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","comment_is_top":false,"comment_ctime":1623142527,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1623142527","product_id":100047701,"comment_content":"老师，购物车的这个问题，我测试出了死锁的问题。但是在visualvm里的死锁dump日志中，没有看到老师标注出来的死锁日志啊。这是咋回事?","like_count":0},{"had_liked":false,"id":289706,"user_name":"张新亮","can_delete":false,"product_type":"c1","uid":2406845,"ip_address":"","ucode":"B68A71CDEA551A","user_header":"https://static001.geekbang.org/account/avatar/00/24/b9/bd/7fef12c8.jpg","comment_is_top":false,"comment_ctime":1619147823,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1619147823","product_id":100047701,"comment_content":"第一段代码这么解决是违背程序初衷的：<br>public synchronized void add()<br>public synchronized void compare()<br>add和compare分别被调用一次而已，加了锁就是等到add执行完才能compare，或者compare完才能add，这样的compare那么多次有意义吗？<br>解决方案：<br>减小锁粒度，用同一把锁，把写操作（a++,b++)和读操作（a&lt;b)都锁上，同一时刻只能进行读或者写。<br>另外，使用了正确的synchronized或者lock，就可以保证可见性了，无需再用volatile<br>","like_count":0},{"had_liked":false,"id":278184,"user_name":"墨","can_delete":false,"product_type":"c1","uid":1303170,"ip_address":"","ucode":"9F78060AC2A7D8","user_header":"https://static001.geekbang.org/account/avatar/00/13/e2/82/71c4f16b.jpg","comment_is_top":false,"comment_ctime":1612792685,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612792685","product_id":100047701,"comment_content":"老师，我有一个疑问，最后一个例子，如果排序好以后我出现两次item1，item2，而且是不同的线程，当我第一个线程去拿item1和item2的锁，那我第二个线程也是需要去拿item1和item2的锁，那这样第二个线程能拿到item1和item2的锁么？","like_count":0},{"had_liked":false,"id":277478,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1612427099,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612427099","product_id":100047701,"comment_content":"Volatile是一种同步锁，比synchronized或者lock相关类更轻量，因为使用volatile并不会发生上下文切换等开销大的行为。<br>如果一个变量被修饰成volatile，那么JVM就知道这个变量可能会被并发修改<br>但是开销小，相应的能力也小，虽然volatile是用来同步的保证线程的安全，但是volatile做不到synchronized那样的原子保护，volatile仅在很有限的场景下发挥作用。","like_count":0},{"had_liked":false,"id":269350,"user_name":"不着调...","can_delete":false,"product_type":"c1","uid":1669651,"ip_address":"","ucode":"00317809789C3F","user_header":"https://static001.geekbang.org/account/avatar/00/19/7a/13/3102cd23.jpg","comment_is_top":false,"comment_ctime":1608619557,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608619557","product_id":100047701,"comment_content":"synchronized本身属于偏向重量级别的锁了，每次都要向操作系统去申请， 最底层应该也是用了CAS，可能会用c和c++去实现（汇编语言了），jdk6以后通过标记markword不必在向操作系统去申请了，但是还是比较难点哈哈","like_count":0},{"had_liked":false,"id":265902,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1607064917,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1607064917","product_id":100047701,"comment_content":"老师请教下，web程序下，如果有4个api接口：<br>Api1：更新表A的一条记录a1<br>Api2：更新表B的一条记录b1<br>Api3：更新表C的一条记录c1<br>Api4：更新表A,B,C的记录a1,b1,c1<br>假设现在有4个线程Thread1-Thread4同时分别调用：Api1-Api4（即Thread1调用Api1, Thread2调用Api2...)<br>为了防止出现并发，需要加锁处理，那么我的理解应该是：Api1中对记录a1加锁，Api2中对b1加锁，Api3中对c1加锁，而Api4中对a1,b1,c1按顺序加锁。<br>我理解的对么，这样也就要求业务开发人员在实际开发过程中，认真分析某个api对数据的变更情况，如果api变化了，加锁也要跟着变。<br>老师，还有更好的建议么。因为日常工作中，经常遇到有的只改订单详情，有的只改订单，有的改完订单详情的同时要接着改订单。<br>另外，对于一些无关紧要的数据修改，是不是可以不加锁，比如修改我在京东上的个人信息（出现并发的概率可以忽略不计，只是举个例子）。<br>谢谢！","like_count":0},{"had_liked":false,"id":253830,"user_name":"JoJi","can_delete":false,"product_type":"c1","uid":2066986,"ip_address":"","ucode":"B88997A80E76AC","user_header":"https://static001.geekbang.org/account/avatar/00/1f/8a/2a/f94db4dc.jpg","comment_is_top":false,"comment_ctime":1602908675,"is_pvip":false,"replies":[{"id":"92753","content":"多线程没有共享的数据","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1602998525,"ip_address":"","comment_id":253830,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1602908675","product_id":100047701,"comment_content":"老师，为什么三层架构 没必要使用sync保护数据呢？","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507199,"discussion_content":"多线程没有共享的数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602998525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245212,"user_name":"田间一直挖","can_delete":false,"product_type":"c1","uid":1463224,"ip_address":"","ucode":"67D4B51FCD2B02","user_header":"https://static001.geekbang.org/account/avatar/00/16/53/b8/0fc8e9bb.jpg","comment_is_top":false,"comment_ctime":1598864573,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598864573","product_id":100047701,"comment_content":"关于利用标志位来控制线程退出的问题，个人感觉业务场景不推荐使用。就算能保证标志位是线程安全的，但在子线程业务中，如果有类似阻塞队列等待的情况，就算主线程将标志位修改，也不会使子线退出。","like_count":0},{"had_liked":false,"id":238541,"user_name":"李和桃","can_delete":false,"product_type":"c1","uid":1015877,"ip_address":"","ucode":"97E66953070EE0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/45/d719f7df.jpg","comment_is_top":false,"comment_ctime":1596192138,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596192138","product_id":100047701,"comment_content":"1、volatile可以保证可见性，此处有个happens-before规则。volatile修饰的变量被修改了之后，其他线程的副本需要强制读主内存。如果没有volatile修饰的变量就无法做到使其他线程及时可见，导致出现问题。<br>2、锁超时释放一般采用锁续期的方式解决。方法尽量保证幂等。","like_count":0},{"had_liked":false,"id":234875,"user_name":"炎发灼眼","can_delete":false,"product_type":"c1","uid":1425953,"ip_address":"","ucode":"7D195057C8E94C","user_header":"https://static001.geekbang.org/account/avatar/00/15/c2/21/a8ef82ac.jpg","comment_is_top":false,"comment_ctime":1594816791,"is_pvip":false,"replies":[{"id":"86910","content":"引用知乎的回复<br><br><br><br>volatile和MESI差着好几层抽象，中间会经历java编译器，java虚拟机和JIT，操作系统，CPU核心。volatile在Java中的意图是保证变量的可见性。为了实现这个功能，必须保证1）编译器不能乱序优化；2）指令执行在CPU上要保证读写的fence。对于x86的体系结构，voltile变量的访问代码会被java编译器生成不乱序的，带有lock指令前缀的机器码。而lock的实现还要区分，这个数据在不在CPU核心的专有缓存中（一般是指L1&#47;L2）。如果在，MESI才有用武之地。如果不满足就会要用其他手段。而这些手段是虚拟机开发者，以及操作系统开发者需要考虑的问题。简而言之，CPU里的缓存，buffer，queue有很多种。MESI只能在一种情况下解决核心专有Cache之间不一致的问题。此外，如果有些CPU不支持MESI协议，那么必须用其他办法来实现等价的效果，比如总是用锁总线的方式，或者明确的fence指令来保证volatile想达到的目标。如果CPU是单核心的，cache是专供这个核心的，MESI理论上也就没有用了。但是依然要考虑主存和Cache被多个线程切换访问时带来的不一致问题。总之，volatile是一个高层的表达意图的“抽象”，而MESI是为了实现这个抽象，在某种特定情况下需要使用的一个实现细节。你可以把JSR-133看作是一套UT的规范。不管底下CPU&#47;编译器怎么折腾，只要voltile修饰的变量满足JSR-133所描述的所有场景，就算是一个好的java实现。而基于这个规范，java开发人员才能安心的开发并发代码，而不至于被底层细节搞疯。<br><br>作者：大宽宽<br>链接：https:&#47;&#47;www.zhihu.com&#47;question&#47;296949412&#47;answer&#47;760347883<br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1594968937,"ip_address":"","comment_id":234875,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1594816791","product_id":100047701,"comment_content":"老师，对于问题1，如果抛开指令重排序的问题，只是更新变量来退出循环的话，MESI协议就已经可以保证一致性了，退出循环应该是没有什么问题的吧，望解释。","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501534,"discussion_content":"引用知乎的回复\n\n\n\nvolatile和MESI差着好几层抽象，中间会经历java编译器，java虚拟机和JIT，操作系统，CPU核心。volatile在Java中的意图是保证变量的可见性。为了实现这个功能，必须保证1）编译器不能乱序优化；2）指令执行在CPU上要保证读写的fence。对于x86的体系结构，voltile变量的访问代码会被java编译器生成不乱序的，带有lock指令前缀的机器码。而lock的实现还要区分，这个数据在不在CPU核心的专有缓存中（一般是指L1/L2）。如果在，MESI才有用武之地。如果不满足就会要用其他手段。而这些手段是虚拟机开发者，以及操作系统开发者需要考虑的问题。简而言之，CPU里的缓存，buffer，queue有很多种。MESI只能在一种情况下解决核心专有Cache之间不一致的问题。此外，如果有些CPU不支持MESI协议，那么必须用其他办法来实现等价的效果，比如总是用锁总线的方式，或者明确的fence指令来保证volatile想达到的目标。如果CPU是单核心的，cache是专供这个核心的，MESI理论上也就没有用了。但是依然要考虑主存和Cache被多个线程切换访问时带来的不一致问题。总之，volatile是一个高层的表达意图的“抽象”，而MESI是为了实现这个抽象，在某种特定情况下需要使用的一个实现细节。你可以把JSR-133看作是一套UT的规范。不管底下CPU/编译器怎么折腾，只要voltile修饰的变量满足JSR-133所描述的所有场景，就算是一个好的java实现。而基于这个规范，java开发人员才能安心的开发并发代码，而不至于被底层细节搞疯。\n\n作者：大宽宽\n链接：https://www.zhihu.com/question/296949412/answer/760347883\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594968937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":228121,"user_name":"阿斯蒂芬","can_delete":false,"product_type":"c1","uid":1024164,"ip_address":"","ucode":"61D5E3BDA4EBC5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a0/a4/b060c723.jpg","comment_is_top":false,"comment_ctime":1592560653,"is_pvip":false,"replies":[{"id":"84125","content":"https:&#47;&#47;www.cnblogs.com&#47;lovecindywang&#47;p&#47;11216570.html","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1592572454,"ip_address":"","comment_id":228121,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1592560653","product_id":100047701,"comment_content":"拿第一讲的例子，分别用ReentrantReadWriteLock 和 StampedLock 试了下，StampedLock 的效率确实要高不少，特别是在读多写少的场景。查资料得知StampedLock算是乐观锁的实现，而ReentrantReadWriteLock是悲观锁的思想。另外有个疑问，ReentrantReadLock，在高并发读的条件下，发现竟然比Synchronized的效率还要低，在我的机器上接近3倍的差距，虽说synchronized有优化过，但是这个差距确实也有些疑惑，不知是否正常。","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498927,"discussion_content":"https://www.cnblogs.com/lovecindywang/p/11216570.html","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592572454,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221653,"user_name":"MrCreep","can_delete":false,"product_type":"c1","uid":1026641,"ip_address":"","ucode":"E5F481B82BE3E9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/FIP7jdV0a9XzhP0ezpmDs5gCOCcIBicfYnIo9WiczG2WsmxBkvicv6ZDEOVPDHjsa5pnPzIonjYo4YYficK4WdwiaHg/132","comment_is_top":false,"comment_ctime":1590559462,"is_pvip":false,"replies":[{"id":"81730","content":"其实文中已有解释『之所以出现这种错乱，是因为两个线程是交错执行add和compare方法中的业务逻辑，而且这些业务逻辑不是原子性的：a++和b++操作中可以穿插在compare方法的比较代码中；更需要注意的是，a&lt;b这种比较操作在字节码层面是加载a、加载b和比较三步，代码虽然是一行但也不是原子性的。』<br>b-a&gt;1的情况是因为，日志输出取值a之后，add方法可能跑了多次了。<br><br>我认为单单在方法上加上synconized的会导致程序机器缓慢，且没有起到边加边比的目的。》》 是的，我这种解决方案是相对于单个方法加锁的方案，粒度粗一点<br>","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1590563785,"ip_address":"","comment_id":221653,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590559462","product_id":100047701,"comment_content":"老师你好，关于第一个例子<br><br>我看老师是启了两个线程，一个add()，一个compare()<br><br>Interesting interesting = new Interesting();<br>new Thread(() -&gt; interesting.add()).start();<br>new Thread(() -&gt; interesting.compare()).start();<br><br>不过最后输出的日志让我很疑惑，<br>add方法实际上是单线程在跑，为什么会有a，b的绝对值差大于1的情况？<br><br>为什么会有b大于a的情况？我的理解里因为a,b都声明了volatile，应该不存在a,b在第一个线程修改后，b的值同步到了主线程而a没有，从而在被另一个线程使用之后，出现b比a大的情况。<br><br>我认为单单在方法上加上synconized的会导致程序机器缓慢，且没有起到边加边比的目的。<br>应该锁在<br>synchronized (locker) { a++; b++ }<br>synchronized (locker) { if (a&gt;b)....}","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496524,"discussion_content":"其实文中已有解释『之所以出现这种错乱，是因为两个线程是交错执行add和compare方法中的业务逻辑，而且这些业务逻辑不是原子性的：a++和b++操作中可以穿插在compare方法的比较代码中；更需要注意的是，a&amp;lt;b这种比较操作在字节码层面是加载a、加载b和比较三步，代码虽然是一行但也不是原子性的。』\nb-a&amp;gt;1的情况是因为，日志输出取值a之后，add方法可能跑了多次了。\n\n我认为单单在方法上加上synconized的会导致程序机器缓慢，且没有起到边加边比的目的。》》 是的，我这种解决方案是相对于单个方法加锁的方案，粒度粗一点\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590563785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220114,"user_name":"荒川之主","can_delete":false,"product_type":"c1","uid":2000330,"ip_address":"","ucode":"12724B4B37BEB5","user_header":"https://static001.geekbang.org/account/avatar/00/1e/85/ca/e6003d08.jpg","comment_is_top":false,"comment_ctime":1590159721,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590159721","product_id":100047701,"comment_content":"java8虽然学了，但是平时写业务代码都没用过，今后要主动运用","like_count":0},{"had_liked":false,"id":219344,"user_name":"岳宜波","can_delete":false,"product_type":"c1","uid":1975581,"ip_address":"","ucode":"5043CA250FDCB1","user_header":"http://thirdwx.qlogo.cn/mmopen/2kpMNDYsSfCnhAYmvAsNcYKyNLUJG5iax9BKgXAJzxypEJGRVwhibjZ53S5icgEDibn8uqrqwsKcxzEXfRRUXTdqjA/132","comment_is_top":false,"comment_ctime":1589992767,"is_pvip":false,"replies":[{"id":"81028","content":"可以使用乐观锁 版本号不对 更新操作会失败 回滚事务重试当前操作即可 建议最多重试两次 再不行直接下单失败 由用户进行重试","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1590020424,"ip_address":"","comment_id":219344,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589992767","product_id":100047701,"comment_content":"老师，并发量没那么大的情况下，下单扣减库存是不是选择使用version乐观锁机制呢，使用乐观锁如果更新失败应该怎么设计重试策略，避免乐观锁异常造成偶尔下单失败的情况呢","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495774,"discussion_content":"可以使用乐观锁 版本号不对 更新操作会失败 回滚事务重试当前操作即可 建议最多重试两次 再不行直接下单失败 由用户进行重试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590020424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205165,"user_name":"Joker","can_delete":false,"product_type":"c1","uid":1156592,"ip_address":"","ucode":"126AF848001A1E","user_header":"https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg","comment_is_top":false,"comment_ctime":1586562581,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586562581","product_id":100047701,"comment_content":"期待老师说一说分布式锁的坑，谢谢老师。","like_count":0},{"had_liked":false,"id":199243,"user_name":"杰哥长得帅","can_delete":false,"product_type":"c1","uid":1241993,"ip_address":"","ucode":"5A7FD1794F62D7","user_header":"https://static001.geekbang.org/account/avatar/00/12/f3/89/fcfecb46.jpg","comment_is_top":false,"comment_ctime":1585484088,"is_pvip":false,"replies":[{"id":"74781","content":"因为a取值之后b取值之前可能add方法已经执行多次了","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1585529239,"ip_address":"","comment_id":199243,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585484088","product_id":100047701,"comment_content":"想请教下老师，第一段代码a和b的差距，为什么能大于1","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489808,"discussion_content":"因为a取值之后b取值之前可能add方法已经执行多次了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585529239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":198242,"user_name":"Geek_3b1096","can_delete":false,"product_type":"c1","uid":1549364,"ip_address":"","ucode":"A6BD92B79B3632","user_header":"","comment_is_top":false,"comment_ctime":1585432342,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585432342","product_id":100047701,"comment_content":"希望老师多讲讲分布式锁","like_count":0},{"had_liked":false,"id":191607,"user_name":"天使梦泪","can_delete":false,"product_type":"c1","uid":1235750,"ip_address":"","ucode":"782991747DD424","user_header":"https://static001.geekbang.org/account/avatar/00/12/db/26/3c8d68fb.jpg","comment_is_top":false,"comment_ctime":1584784511,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1584784511","product_id":100047701,"comment_content":"那个输出的值，有可能会比100 万次大吗？","like_count":0,"discussions":[{"author":{"id":2305546,"avatar":"","nickname":"0xCAFEBABE","note":"","ucode":"D68D1C39E87596","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328821,"discussion_content":"应该不可能。counter++操作其实被分成三步：\n1.读取count的值；\n2.对count执行+1；\n3.将2的计算结果重新赋值给count；\n假设现在有两个线程A、B，A线程已经执行完第3步，但是还没有把值写入主内存，此时B线程刚好执行第1步，从主内存读取count的值到自己的工作内存，但是读出来的值不是最新的值（因为A还没有把结果写入到主内存）。因此结果必然小于100万。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606232630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191339,"user_name":"丁乐洪","can_delete":false,"product_type":"c1","uid":1264392,"ip_address":"","ucode":"549CE57AB20B49","user_header":"https://static001.geekbang.org/account/avatar/00/13/4b/08/52954cd7.jpg","comment_is_top":false,"comment_ctime":1584764589,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584764589","product_id":100047701,"comment_content":"要等研究后再看专栏，不能急。","like_count":0}]}