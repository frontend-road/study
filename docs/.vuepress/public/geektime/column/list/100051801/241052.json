{"id":241052,"title":"10 | lambda：函数式编程带来了什么？","content":"<p>你好，我是Chrono。</p><p>在<a href=\"https://time.geekbang.org/column/article/231454\">第1节课</a>的时候，我就说到过“函数式编程”，但只是简单提了提，没有展开讲。</p><p>作为现代C++里的五种基本编程范式之一，“函数式编程”的作用和地位正在不断上升，而且在其他语言里也非常流行，很有必要再深入研究一下。</p><p>掌握了函数式编程，你就又多了一件“趁手的兵器”，可以更好地运用标准库里的容器和算法，写出更灵活、紧凑、优雅的代码。</p><p>所以，今天我就和你聊聊函数式编程，看看它给C++带来了什么。</p><h2>C++函数的特殊性</h2><p>说到“函数式编程”，那肯定就要先从函数（function）说起。</p><p>C++里的函数概念来源于C，是面向过程编程范式的基本部件。但严格来说，它其实应该叫“子过程”（sub-procedure）、“子例程”（sub-routine），是命令的集合、操作步骤的抽象。</p><p>函数的目的是封装执行的细节，简化程序的复杂度，但因为它有入口参数，有返回值，形式上和数学里的函数很像，所以就被称为“函数”。</p><p>在语法层面上，C/C++里的函数是比较特别的。虽然有函数类型，但不存在对应类型的变量，不能直接操作，只能用指针去间接操作（即函数指针），这让函数在类型体系里显得有点“格格不入”。</p><p>函数在用法上也有一些特殊之处。在C/C++里，所有的函数都是全局的，没有生存周期的概念（static、名字空间的作用很弱，只是简单限制了应用范围，避免名字冲突）。而且函数也都是平级的，不能在函数里再定义函数，也就是<strong>不允许定义嵌套函数、函数套函数</strong>。</p><!-- [[[read_end]]] --><pre><code>void my_square(int x)           // 定义一个函数\n{\n    cout &lt;&lt; x*x &lt;&lt; endl;       // 函数的具体内容\n}\n\nauto pfunc = &amp;my_square;       // 只能用指针去操作函数，指针不是函数\n(*pfunc)(3);                    // 可以用*访问函数\npfunc(3);                       // 也可以直接调用函数指针\n\n</code></pre><p>所以，在面向过程编程范式里，函数和变量虽然是程序里最关键的两个组成部分，但却因为没有值、没有作用域而不能一致地处理。函数只能是函数，变量只能是变量，彼此之间虽不能说是“势同水火”，但至少是“泾渭分明”。</p><h2>认识lambda</h2><p>好了，搞清楚了函数，现在再来看看C++11引入的lambda表达式，下面是一个简单的例子：</p><pre><code>auto func = [](int x)          // 定义一个lambda表达式\n{   \n    cout &lt;&lt; x*x &lt;&lt; endl;      // lambda表达式的具体内容\n};  \n\nfunc(3);                      // 调用lambda表达式\n</code></pre><p>暂时不考虑代码里面的语法细节，单从第一印象上，我们可以看到有一个函数，但更重要的，是这个函数采用了赋值的方式，存入了一个变量。</p><p>这就是lambda表达式与普通函数最大、也是最根本的区别。</p><p>因为lambda表达式是一个变量，所以，我们就可以“按需分配”，随时随地在调用点“<strong>就地</strong>”定义函数，限制它的作用域和生命周期，实现函数的局部化。</p><p>而且，因为lambda表达式和变量一样是“一等公民”，用起来也就更灵活自由，能对它做各种运算，生成新的函数。这就像是数学里的复合函数那样，把多个简单功能的小lambda表达式组合，变成一个复杂的大lambda表达式。</p><p>如果你比较熟悉C++98，或者看过一些相关的资料，可能会觉得lambda表达式只不过是函数对象（function object）的一种简化形式，只是一个好用的“语法糖”（syntactic sugar）。</p><p>大道理上是没错的，但如果把它简单地等同于函数对象，认为它只是免去了手写函数对象的麻烦，那就实在是有点太“肤浅”了。</p><p>lambda表达式为C++带来的变化可以说是革命性的。虽然它表面上只是一个很小的改进，简化了函数的声明/定义，但深层次带来的编程理念的变化，却是非常巨大的。</p><p>这和C++当初引入bool、class、template这些特性时有点类似，乍看上去好像只是一点点的语法改变，但后果却如同雪崩，促使人们更多地去思考、探索新的编程方向，而lambda引出的全新思维方式就是“函数式编程”——把写计算机程序看作是数学意义上的求解函数。</p><p>C++里的lambda表达式除了可以像普通函数那样被调用，还有一个普通函数所不具备的特殊本领，就是可以<strong>“捕获”外部变量</strong>，在内部的代码里直接操作。</p><pre><code>int n = 10;                     // 一个外部变量\n\nauto func = [=](int x)          // lambda表达式，用“=”值捕获\n{\n    cout &lt;&lt; x*n &lt;&lt; endl;        // 直接操作外部变量\n};\n\nfunc(3);                    // 调用lambda表达式\n</code></pre><p>看到这里，如果你用过JavaScript，那么一定会有种眼熟的感觉。没错，lambda表达式就是在其他语言中大名鼎鼎的“<strong>闭包</strong>”（closure），这让它真正超越了函数和函数对象。</p><p>“闭包”是什么，很难一下子说清楚，我就不详细解释了。说得形象一点，你可以把闭包理解为一个“活的代码块”“活的函数”。它虽然在出现时被定义，但因为保存了定义时捕获的外部变量，就可以跳离定义点，把这段代码“打包”传递到其他地方去执行，而仅凭函数的入口参数是无法做到这一点的。</p><p>这就导致函数式编程与命令式编程（即面向过程）在结构上有很大不同，程序流程不再是按步骤执行的“死程序”，而是一个个的“活函数”，像做数学题那样逐步计算、推导出结果，有点像下面的这样：</p><pre><code>auto a = [](int x)      // a函数执行一个功能\n            {...} \nauto b = [](double x)    // b函数执行一个功能\n            {...}\nauto c = [](string str)  // c函数执行一个功能\n            {...}\n\nauto f = [](...)        // f函数执行一个功能\n            {...}\n\nreturn f(a, b, c)            // f调用a/b/c运算得到结果\n\n</code></pre><p>你也可以再对比面向对象来理解。在面向对象编程里，程序是由一个个实体对象组成的，对象通信完成任务。而在函数式编程里，程序是由一个个函数组成的，函数互相嵌套、组合、调用完成任务。</p><p>不过，毕竟函数式编程在C++里是一种较新的编程范式，而且面向过程里的函数概念“根深蒂固”，我说了这么多，你可能还是不太能领会它的奥妙，这也很正常。</p><p>下面我就来讲讲lambda表达式的使用细节，掌握了以后多用，就能够更好地理解了。</p><h2>使用lambda的注意事项</h2><p>要学好用好lambda，我觉得就是三个重点：语法形式，变量捕获规则，还有泛型的用法。</p><p><strong>1.lambda的形式</strong></p><p>首先你要知道，C++没有为lambda表达式引入新的关键字，并没有“lambda”这样的词汇，而是用了一个特殊的形式“<strong>[]</strong>”，术语叫“<strong>lambda引出符</strong>”（lambda introducer）。</p><p>在lambda引出符后面，就可以像普通函数那样，用圆括号声明入口参数，用花括号定义函数体。</p><p>下面的代码展示了我最喜欢的一个lambda表达式（也是最简单的）：</p><pre><code>auto f1 = [](){};      // 相当于空函数，什么也不做\n</code></pre><p>这行语句定义了一个相当于空函数的lambda表达式，三个括号“排排坐”，看起来有种奇特的美感，让人不由得想起那句经典台词：“一家人最要紧的就是整整齐齐。”（不过还是差了个尖括号&lt;&gt;）。</p><p>当然了，实际开发中不会有这么简单的lambda表达式，它的函数体里可能会有很多语句，所以一定<strong>要有良好的缩进格式</strong>——特别是有嵌套定义的时候，尽量让人能够一眼就看出lambda表达式的开始和结束，必要的时候可以用注释来强调。</p><pre><code>auto f2 = []()                 // 定义一个lambda表达式\n{\n    cout &lt;&lt; &quot;lambda f2&quot; &lt;&lt; endl;\n\n    auto f3 = [](int x)         // 嵌套定义lambda表达式\n    {\n        return x*x;\n    };// lambda f3              // 使用注释显式说明表达式结束\n\n    cout &lt;&lt; f3(10) &lt;&lt; endl;\n};  // lambda f2               // 使用注释显式说明表达式结束\n</code></pre><p>你可能注意到了，在lambda表达式赋值的时候，我总是使用auto来推导类型。这是因为，在C++里，每个lambda表达式都会有一个独特的类型，而这个类型只有编译器才知道，我们是无法直接写出来的，所以必须用auto。</p><p>不过，因为lambda表达式毕竟不是普通的变量，所以C++也鼓励程序员<strong>尽量“匿名”使用lambda表达式</strong>。也就是说，它不必显式赋值给一个有名字的变量，直接声明就能用，免去你费力起名的烦恼。</p><p>这样不仅可以让代码更简洁，而且因为“匿名”，lambda表达式调用完后也就不存在了（也有被拷贝保存的可能），这就最小化了它的影响范围，让代码更加安全。</p><pre><code>vector&lt;int&gt; v = {3, 1, 8, 5, 0};     // 标准容器\n\ncout &lt;&lt; *find_if(begin(v), end(v),   // 标准库里的查找算法\n            [](int x)                // 匿名lambda表达式，不需要auto赋值\n            {\n                return x &gt;= 5;        // 用做算法的谓词判断条件 \n            }                        // lambda表达式结束\n        )\n     &lt;&lt; endl;                        // 语句执行完，lambda表达式就不存在了\n</code></pre><p><strong>2.lambda的变量捕获</strong></p><p>lambda的“捕获”功能需要在“[]”里做文章，由于实际的规则太多太细，记忆、理解的成本高，所以我只说几个要点，帮你快速掌握它们：</p><ul>\n<li>“[=]”表示按值捕获所有外部变量，表达式内部是值的拷贝，并且不能修改；</li>\n<li>“[&amp;]”是按引用捕获所有外部变量，内部以引用的方式使用，可以修改；</li>\n<li>你也可以在“[]”里明确写出外部变量名，指定按值或者按引用捕获，C++在这里给予了非常大的灵活性。</li>\n</ul><pre><code>int x = 33;               // 一个外部变量\n\nauto f1 = [=]()           // lambda表达式，用“=”按值捕获\n{\n    //x += 10;            // x只读，不允许修改\n};\n\nauto f2 = [&amp;]()         // lambda表达式，用“&amp;”按引用捕获\n{\n    x += 10;            // x是引用，可以修改\n};\n\nauto f3 = [=, &amp;x]()       // lambda表达式，用“&amp;”按引用捕获x，其他的按值捕获\n{\n    x += 20;              // x是引用，可以修改\n};\n</code></pre><p>“捕获”也是使用lambda表达式的一个难点，关键是要理解“<strong>外部变量</strong>”的含义。</p><p>我建议，你可以简单地按照其他语言的习惯，称之为“<strong>upvalue</strong>”，也就是在lambda表达式定义之前所有出现的变量，不管它是局部的还是全局的。</p><p>这就有一个变量生命周期的问题。</p><p>使用“[=]”按值捕获的时候，lambda表达式使用的是变量的独立副本，非常安全。而使用“[&amp;]”的方式捕获引用就存在风险，当lambda表达式在离定义点“很远的地方”被调用的时候，引用的变量可能发生了变化，甚至可能会失效，导致难以预料的后果。</p><p>所以，我建议你在使用捕获功能的时候要小心，对于“就地”使用的小lambda表达式，可以用“[&amp;]”来减少代码量，保持整洁；而对于非本地调用、生命周期较长的lambda表达式应慎用“[&amp;]”捕获引用，而且，最好是在“[]”里显式写出变量列表，避免捕获不必要的变量。</p><pre><code>class DemoLambda final\n{\nprivate:\n    int x = 0;\npublic:\n    auto print()              // 返回一个lambda表达式供外部使用\n    {\n        return [this]()      // 显式捕获this指针\n        {\n            cout &lt;&lt; &quot;member = &quot; &lt;&lt; x &lt;&lt; endl;\n        };\n    }\n};\n</code></pre><p><strong>3.泛型的lambda</strong></p><p>在C++14里，lambda表达式又多了一项新本领，可以实现“<strong>泛型化</strong>”，相当于简化了的模板函数，具体语法还是利用了“多才多艺”的auto：</p><pre><code>auto f = [](const auto&amp; x)        // 参数使用auto声明，泛型化\n{\n    return x + x;\n};\n\ncout &lt;&lt; f(3) &lt;&lt; endl;             // 参数类型是int\ncout &lt;&lt; f(0.618) &lt;&lt; endl;         // 参数类型是double\n\nstring str = &quot;matrix&quot;;\ncout &lt;&lt; f(str) &lt;&lt; endl;          // 参数类型是string\n</code></pre><p>这个新特性在写泛型函数的时候非常方便，摆脱了冗长的模板参数和函数参数列表。如果你愿意的话，可以尝试在今后的代码里都使用lambda来代替普通函数，能够少写很多代码。</p><h2>小结</h2><p>今天我讲了lambda表达式。它不仅仅是对旧有函数对象的简单升级，而是更高级的“闭包”，给C++带来了新的编程理念：函数式编程范式。</p><p>在C语言里，函数是一个“静止”的代码块，只能被动地接受输入然后输出。而lambda的出现则让函数“活”了起来，极大地提升了函数的地位和灵活性。</p><p>比照“智能指针”的说法，lambda完全可以称为是“智能函数”，价值体现在就地定义、变量捕获等能力上，它也给C++的算法、并发（线程、协程）等后续发展方向铺平了道路，在后面讲标准库的时候，我们还会多次遇到它。</p><p>虽然目前在C++里，纯函数式编程还比较少见，但“轻度”使用lambda表达式也能够改善代码，比如用“map+lambda”的方式来替换难以维护的if/else/switch，可读性要比大量的分支语句好得多。</p><p>小结一下今天的要点内容：</p><ol>\n<li>lambda表达式是一个闭包，能够像函数一样被调用，像变量一样被传递；</li>\n<li>可以使用auto自动推导类型存储lambda表达式，但C++鼓励尽量就地匿名使用，缩小作用域；</li>\n<li>lambda表达式使用“[=]”的方式按值捕获，使用“[&amp;]”的方式按引用捕获，空的“[]”则是无捕获（也就相当于普通函数）；</li>\n<li>捕获引用时必须要注意外部变量的生命周期，防止变量失效；</li>\n<li>C++14里可以使用泛型的lambda表达式，相当于简化的模板函数。</li>\n</ol><p>末了我再说一句，和C++里的大多数新特性一样，滥用lambda表达式的话，就会产生一些难以阅读的代码，比如多个函数的嵌套和串联、调用层次过深。这也需要你在实践中慢慢积累经验，找到最适合你自己的使用方式。</p><h2>课下作业</h2><p>最后是课下作业时间，给你留两个思考题吧：</p><ol>\n<li>你对函数式编程有什么样的理解和认识呢？</li>\n<li>lambda表达式的形式非常简洁，可以在很多地方代替普通函数，那它能不能代替类的成员函数呢？为什么？</li>\n</ol><p>欢迎你在留言区写下你的思考和答案，如果觉得今天的内容对你有所帮助，也欢迎分享给你的朋友。我们下节课见。</p><p><img src=\"https://static001.geekbang.org/resource/image/5a/0d/5ac283e096d87e582fed017597ba4e0d.jpg?wh=1200*2175\" alt=\"\"></p>","comments":[{"had_liked":false,"id":222198,"user_name":"罗剑锋","can_delete":false,"product_type":"c1","uid":1181974,"ip_address":"","ucode":"95678C988F24AB","user_header":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","comment_is_top":true,"comment_ctime":1590715410,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"9.2233721157548995e+18","product_id":100051801,"comment_content":"我在GitHub的lambd.cpp里写了一小段代码，示范了function + lambda实现成员函数的方法，算是对课下作业2的一个参考，同学们可以看看。","like_count":19,"discussions":[{"author":{"id":2004985,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/97/f9/3fcc851c.jpg","nickname":"～灯火阑珊","note":"","ucode":"B26CB4EA188C7A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284823,"discussion_content":"老师你github网址是啥了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592652109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":2004985,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/97/f9/3fcc851c.jpg","nickname":"～灯火阑珊","note":"","ucode":"B26CB4EA188C7A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284835,"discussion_content":"看课前准备","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592657796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":284823,"ip_address":""},"score":284835,"extra":""}]}]},{"had_liked":false,"id":221889,"user_name":"冻冻","can_delete":false,"product_type":"c1","uid":1758327,"ip_address":"","ucode":"7C2C75975153ED","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d4/77/21a75ab3.jpg","comment_is_top":false,"comment_ctime":1590628965,"is_pvip":false,"replies":[{"id":"81829","content":"这个需要用到std::function，存储lambda表达式，比如<br>~~~<br>map&lt;int, function&lt;void()&gt;&gt; funcs;<br>funcs[1] = [](){...};<br>funcs[7] = [](){...};<br>funcs[42] = [](){...};<br><br>return funcs[x]();<br>~~~<br><br>这样，就把switch&#47;case语句转换成了function+lambda，让map替你自动switch。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1590652044,"ip_address":"","comment_id":221889,"utype":1}],"discussion_count":6,"race_medal":0,"score":"237813830245","product_id":100051801,"comment_content":"老师，用“map+lambda”的方式来替换难以维护的 if&#47;else&#47;switch，能举个例子吗？","like_count":56,"discussions":[{"author":{"id":1547913,"avatar":"https://static001.geekbang.org/account/avatar/00/17/9e/89/6e9c05d6.jpg","nickname":"被讨厌的勇气","note":"","ucode":"AE3B3CA27D91A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274924,"discussion_content":"map<string, function<int(int,int)>>  \n op{\n       {&#34;+&#34;,  [](auto a, auto b) {return a + b;} },\n       {&#34;-&#34;,   [](auto a, auto b) {return a - b;} }\n};\n这样就可以通过 op.at(&#34;+&#34;)(1, 6)的方式来使用了。\n\nif/else语句中的条件判断为key，条件体为写成lambda表达式。通过查表来替换掉ifelse判断。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1590632365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496601,"discussion_content":"这个需要用到std::function，存储lambda表达式，比如\n~~~\nmap&amp;lt;int, function&amp;lt;void()&amp;gt;&amp;gt; funcs;\nfuncs[1] = [](){...};\nfuncs[7] = [](){...};\nfuncs[42] = [](){...};\n\nreturn funcs[x]();\n~~~\n\n这样，就把switch/case语句转换成了function+lambda，让map替你自动switch。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590652044,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1982957,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/41/ed/31db8bce.jpg","nickname":"H X","note":"","ucode":"B73939E7C6A8B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":553484,"discussion_content":"高级高级~，一看就是顶级CPPer，炫技感十足","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645926750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":496601,"ip_address":""},"score":553484,"extra":""}]},{"author":{"id":1486899,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b0/33/b424c6db.jpg","nickname":"Gang","note":"","ucode":"C47DE389CE4D63","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289771,"discussion_content":"使用map的话会建堆，然后如果外部有较多的参数传入的话，这样做应该对效率有一定的影响吧，不过用map进行条件绑定的这种方法还是很巧妙的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594208633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1577066,"avatar":"https://static001.geekbang.org/account/avatar/00/18/10/6a/7d0cb0ab.jpg","nickname":"弱水三千一瓢饮","note":"","ucode":"969ED58ABA6089","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329794,"discussion_content":"如果是类似下边的if/else判断，怎么用map+lambda来替换呢？\nif (a==0 &amp;&amp; b ==0 ) {\n    // todo\n} else if (a == 0 &amp;&amp; b== 1) {\n    // todo \n} else if (a == 1 &amp;&amp; b == 0) {\n    // todo\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606460874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2460726,"avatar":"https://static001.geekbang.org/account/avatar/00/25/8c/36/48b9370a.jpg","nickname":"汤瑞麟","note":"","ucode":"18D4B4D32E82BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1577066,"avatar":"https://static001.geekbang.org/account/avatar/00/18/10/6a/7d0cb0ab.jpg","nickname":"弱水三千一瓢饮","note":"","ucode":"969ED58ABA6089","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571258,"discussion_content":"hash映射","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652161592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":329794,"ip_address":""},"score":571258,"extra":""}]}]},{"had_liked":false,"id":221908,"user_name":"被讨厌的勇气","can_delete":false,"product_type":"c1","uid":1547913,"ip_address":"","ucode":"AE3B3CA27D91A2","user_header":"https://static001.geekbang.org/account/avatar/00/17/9e/89/6e9c05d6.jpg","comment_is_top":false,"comment_ctime":1590631991,"is_pvip":false,"replies":[{"id":"81819","content":"对的，就是这个原因。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1590641309,"ip_address":"","comment_id":221908,"utype":1}],"discussion_count":1,"race_medal":0,"score":"83195010615","product_id":100051801,"comment_content":"采用lambda表达式替换类的成员函数，成员变量通过 &#39;[this]&#39;可以捕获（相当于成员函数中的this参数），参数、返回值、函数体，lambda表达式都可以实现，所以理论上，是可以替换的。<br><br>试了一下，报错：在类内部无法定义auto。之前老师提到过的。","like_count":19,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496608,"discussion_content":"对的，就是这个原因。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590641309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224084,"user_name":"xGdl","can_delete":false,"product_type":"c1","uid":2004988,"ip_address":"","ucode":"5ADD896F62A2B8","user_header":"https://static001.geekbang.org/account/avatar/00/1e/97/fc/0ca13c5c.jpg","comment_is_top":false,"comment_ctime":1591270697,"is_pvip":false,"replies":[{"id":"82552","content":"这个就是闭包最常用的场景之一了，把数据和逻辑打包传递。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591324260,"ip_address":"","comment_id":224084,"utype":1}],"discussion_count":2,"race_medal":0,"score":"66015780137","product_id":100051801,"comment_content":"lambda由类的operator重载而来，最大的特征是携带私货（闭包），我一般使用闭包最多的就是将任务打包Task推送线程池或下一个流程。这一过程在没有闭包之前，实现起来有些麻烦。","like_count":15,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497358,"discussion_content":"这个就是闭包最常用的场景之一了，把数据和逻辑打包传递。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591324260,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1315515,"avatar":"","nickname":"Cast","note":"","ucode":"226B483C60F797","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348878,"discussion_content":"看了很多闭包的解释，一直半懂。看到你的这个例子瞬间懂了闭包的作用何在。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612764193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226197,"user_name":"海怪哥哥","can_delete":false,"product_type":"c1","uid":1127866,"ip_address":"","ucode":"E82536F7259525","user_header":"https://static001.geekbang.org/account/avatar/00/11/35/ba/01762322.jpg","comment_is_top":false,"comment_ctime":1591976633,"is_pvip":false,"replies":[{"id":"83319","content":"这个方法不错，nice。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1592003960,"ip_address":"","comment_id":226197,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40246682297","product_id":100051801,"comment_content":"关于lambda对于外部变量的捕获。大家可以这样理解更容易，如果把lambda表达式看成一个常规的变量，那么相同作用域（比如同一个函数）内的变量跟常量对它都是可见的。","like_count":9,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498144,"discussion_content":"这个方法不错，nice。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592003960,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225143,"user_name":"robonix","can_delete":false,"product_type":"c1","uid":1212323,"ip_address":"","ucode":"866EC82EDA455B","user_header":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","comment_is_top":false,"comment_ctime":1591666007,"is_pvip":false,"replies":[{"id":"82876","content":"目前的lambda是这样的，不过你可以不在[]里捕获，而是在函数参数里传递常量引用。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591668106,"ip_address":"","comment_id":225143,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18771535191","product_id":100051801,"comment_content":"老师，lambda表达式是不是没有常量引用呢？如果怕修改被捕获的变量只能用值传递，那么就有拷贝发生了？","like_count":4,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497749,"discussion_content":"目前的lambda是这样的，不过你可以不在[]里捕获，而是在函数参数里传递常量引用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591668106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237634,"user_name":"sp0917","can_delete":false,"product_type":"c1","uid":1347338,"ip_address":"","ucode":"18D341FF4D43AF","user_header":"https://static001.geekbang.org/account/avatar/00/14/8f/0a/22863f93.jpg","comment_is_top":false,"comment_ctime":1595906091,"is_pvip":false,"replies":[{"id":"87797","content":"是的，一般来说函数名就相当于函数指针，但对于成员函数，就必须要加上&amp;。<br><br>所以我习惯上总写&amp;，看起来更清楚，也比较一致。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1595913594,"ip_address":"","comment_id":237634,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14480807979","product_id":100051801,"comment_content":"罗老师，<br>auto pfunc = &amp;my_square;    【1】<br>auto pfunc = my_square;       【2】<br>这两种表示有什么区别？<br>我一直认为函数名和函数指针是对等的，所以我直觉就是使用【2】，但发现这两个在使用pfunc进行操作时效果一样。","like_count":3,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502487,"discussion_content":"是的，一般来说函数名就相当于函数指针，但对于成员函数，就必须要加上&amp;amp;。\n\n所以我习惯上总写&amp;amp;，看起来更清楚，也比较一致。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595913594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236894,"user_name":"Charles","can_delete":false,"product_type":"c1","uid":1993897,"ip_address":"","ucode":"E06908D251EF55","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKibu8C3CeYGFicJ1kRwibvSGYjaC0R3HsAVBNDE0seEI33Lm7GZ4LibTnVHWcGiczVxfzDLLqySjjoFzQ/132","comment_is_top":false,"comment_ctime":1595579418,"is_pvip":false,"replies":[{"id":"87548","content":"lambda的一个最核心的特点是变量，是“一等公民”，可以嵌套定义，而函数不能做到，在函数里无法定义函数，所以只能用lambda来就地定义匿名函数。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1595590541,"ip_address":"","comment_id":236894,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14480481306","product_id":100051801,"comment_content":"感觉lambda和函数指针的差别好像不是太大，可能是我还没有真正理解吧，我觉得lambda的捕获功能，普通函数也可以用传引用的方式实现？然后将函数打包到别的地方，是不是也可以把普通函数的函数指针打包到别的地方？","like_count":3,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502244,"discussion_content":"lambda的一个最核心的特点是变量，是“一等公民”，可以嵌套定义，而函数不能做到，在函数里无法定义函数，所以只能用lambda来就地定义匿名函数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595590541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222050,"user_name":"张JL","can_delete":false,"product_type":"c1","uid":1329824,"ip_address":"","ucode":"F460C75C7A7998","user_header":"https://static001.geekbang.org/account/avatar/00/14/4a/a0/c94a1a64.jpg","comment_is_top":false,"comment_ctime":1590664071,"is_pvip":false,"replies":[{"id":"81848","content":"对，用lambda来封装小段代码，这就有点函数式编程的意思了。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1590666676,"ip_address":"","comment_id":222050,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14475565959","product_id":100051801,"comment_content":"我常用lambda替换函数中的小段重复代码。<br>相同代码重复写几遍感觉很蠢，拿出来做成函数又没有必要，因为没有其他的调用需求，这时候用lambda就简洁多了","like_count":3,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496648,"discussion_content":"对，用lambda来封装小段代码，这就有点函数式编程的意思了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590666676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221844,"user_name":"羿达","can_delete":false,"product_type":"c1","uid":1659275,"ip_address":"","ucode":"48559E9D480C34","user_header":"https://static001.geekbang.org/account/avatar/00/19/51/8b/e3b827b7.jpg","comment_is_top":false,"comment_ctime":1590621903,"is_pvip":true,"replies":[{"id":"81787","content":"morning ","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1590626530,"ip_address":"","comment_id":221844,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14475523791","product_id":100051801,"comment_content":"老师早啊!","like_count":3,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496589,"discussion_content":"morning ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590626530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":271888,"user_name":"Stephen","can_delete":false,"product_type":"c1","uid":1165201,"ip_address":"","ucode":"0D49223E6CB7B1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7mAt63VrbLZPHpeZxSc4IlBYswQSnaAB5wGePaGFDehgiaNfIxI1SJ5yIHIlmVk8hsw0RaoaSCPA/132","comment_is_top":false,"comment_ctime":1609852308,"is_pvip":false,"replies":[{"id":"98605","content":"lambda可以在函数内部定义，捕获局部变量，并且作为闭包传递到外面去使用，而普通函数只能使用全局变量。<br><br>按照你的说法，如果普通函数使用外部的全局变量，那是和lambda差不多的，但它不能有状态。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1609895488,"ip_address":"","comment_id":271888,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10199786900","product_id":100051801,"comment_content":"普通函数所不具备的特殊本领，就是可以“捕获”外部变量，在内部的代码里直接操作.如果外部变量n定义最外层,且在普通函数前面,也是可以在函数中使用到的.此时应该和lambda没有区别了吧?","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513082,"discussion_content":"lambda可以在函数内部定义，捕获局部变量，并且作为闭包传递到外面去使用，而普通函数只能使用全局变量。\n\n按照你的说法，如果普通函数使用外部的全局变量，那是和lambda差不多的，但它不能有状态。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609895488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1165201,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7mAt63VrbLZPHpeZxSc4IlBYswQSnaAB5wGePaGFDehgiaNfIxI1SJ5yIHIlmVk8hsw0RaoaSCPA/132","nickname":"Stephen","note":"","ucode":"0D49223E6CB7B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340111,"discussion_content":"好的，谢谢老师。这里的状态指的是？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609904690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245517,"user_name":"ripple","can_delete":false,"product_type":"c1","uid":1090051,"ip_address":"","ucode":"99008FD0533F68","user_header":"https://wx.qlogo.cn/mmopen/vi_32/ywSuwVNMKNjRLPMjZmpQOQHWW2usAu8RwRIOlBHaVVU6J3xHdtibgO6FVzYkRIkV50vCr62ia4OwJp07giabiazUGA/132","comment_is_top":false,"comment_ctime":1598965460,"is_pvip":false,"replies":[{"id":"90310","content":"是这样的，只有无捕获的lambda表达式才能转换成函数指针，也就是[](){...}，因为lambda毕竟和函数有差异，不能简单地转换。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1599008743,"ip_address":"","comment_id":245517,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10188900052","product_id":100051801,"comment_content":"罗老师，lamda不能传到外界去么？我发现不捕获变量就可以传，捕获了就传不了，不清楚哪条语法可以解决<br>testB(void (*func)(std::string)) {<br>}<br><br>test() {<br>    std::string result = &quot;&quot;;<br>    auto func = [&amp;result] (std::string params) mutable{<br>        result = params;<br>    };<br><br>   testB(func);<br>}","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504907,"discussion_content":"是这样的，只有无捕获的lambda表达式才能转换成函数指针，也就是[](){...}，因为lambda毕竟和函数有差异，不能简单地转换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599008743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1090051,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/ywSuwVNMKNjRLPMjZmpQOQHWW2usAu8RwRIOlBHaVVU6J3xHdtibgO6FVzYkRIkV50vCr62ia4OwJp07giabiazUGA/132","nickname":"ripple","note":"","ucode":"99008FD0533F68","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302707,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599012956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222270,"user_name":"Tedeer","can_delete":false,"product_type":"c1","uid":1693287,"ip_address":"","ucode":"7DD9837A38378D","user_header":"https://static001.geekbang.org/account/avatar/00/19/d6/67/5e0cac1b.jpg","comment_is_top":false,"comment_ctime":1590732930,"is_pvip":false,"replies":[{"id":"81941","content":"理解的差不多，可以参考一下auto那讲，因为目前C++不允许在声明成员变量时用auto推导类型。<br><br>也可以再试着写一下代码来验证。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1590735796,"ip_address":"","comment_id":222270,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10180667522","product_id":100051801,"comment_content":"我看到老师文章中说到每个lambda表达式都有个全局唯一类型，只有编译器知道；lambda表达式只能通过auto声明，且auto变量必须在定义时初始化，而在类声明时，成员并未被赋值，就不知道lambda表达式类型，无法推导出具体类型，编译器会报错，所以无法使用lambda表达式作成员函数，请问老师我这样理解对吗？","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496734,"discussion_content":"理解的差不多，可以参考一下auto那讲，因为目前C++不允许在声明成员变量时用auto推导类型。\n\n也可以再试着写一下代码来验证。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590735796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221862,"user_name":"泰伦卢","can_delete":false,"product_type":"c1","uid":1141994,"ip_address":"","ucode":"FEA6B43C8D4FF9","user_header":"https://static001.geekbang.org/account/avatar/00/11/6c/ea/e03fec22.jpg","comment_is_top":false,"comment_ctime":1590624579,"is_pvip":true,"replies":[{"id":"81798","content":"对，lambda大大方便了算法还有并发，改变了C++的编程方式。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1590632353,"ip_address":"","comment_id":221862,"utype":1}],"discussion_count":6,"race_medal":0,"score":"10180559171","product_id":100051801,"comment_content":"个人认为lambda表达式还有个重要的用途是它可以自定义stl函数谓词规则(pred)，例如自定义排序规则，而无需使用传统的仿函数那种麻烦的方法。","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496592,"discussion_content":"对，lambda大大方便了算法还有并发，改变了C++的编程方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590632353,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1994088,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/6d/68/e40b3300.jpg","nickname":"Bluebuger","note":"","ucode":"946EE346371D8A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286040,"discussion_content":"Qt 的 concurrent api 配 lmabda做并行处理 太爽了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593018590,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1174199,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ea/b7/1a18a39d.jpg","nickname":"5-刘新波(Arvin)","note":"","ucode":"DBD135D2587A93","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275264,"discussion_content":"就是行为参数化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590679625,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188710,"avatar":"https://static001.geekbang.org/account/avatar/00/12/23/66/413c0bb5.jpg","nickname":"LDxy","note":"","ucode":"956432CE7B7761","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275145,"discussion_content":"谓词是什么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590671171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1174199,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ea/b7/1a18a39d.jpg","nickname":"5-刘新波(Arvin)","note":"","ucode":"DBD135D2587A93","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1188710,"avatar":"https://static001.geekbang.org/account/avatar/00/12/23/66/413c0bb5.jpg","nickname":"LDxy","note":"","ucode":"956432CE7B7761","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275267,"discussion_content":"判断逻辑真假的函数","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1590679658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":275145,"ip_address":""},"score":275267,"extra":""}]},{"author":{"id":1770245,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/03/05/140068f9.jpg","nickname":"HoshinoKanade","note":"","ucode":"AA8B4F90FB9E5F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274852,"discussion_content":"同。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590627202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234317,"user_name":"flying","can_delete":false,"product_type":"c1","uid":1298279,"ip_address":"","ucode":"69AB7872B36B23","user_header":"https://static001.geekbang.org/account/avatar/00/13/cf/67/057e5d93.jpg","comment_is_top":false,"comment_ctime":1594643033,"is_pvip":false,"replies":[{"id":"86493","content":"可以用，但我觉得写的有点问题，最好是在类定义时直接初始化function，还有尽量避免if-else分支。<br><br>你说的coredump问题不好判断原因，因为C++关联的东西比较多。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1594688028,"ip_address":"","comment_id":234317,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5889610329","product_id":100051801,"comment_content":"老师你好：<br><br>如果用function包装lambda表达式，是否可以作为类的成员变量？然后再lambda表达式里面操作类的成员变量。例如<br><br>#include &lt;funcitional&gt;<br>typedef  std::function&lt;void(int)&gt; Handler;<br><br>class Test<br>{<br>public:<br>        Test(int type)<br>        {<br>\t\t    if (1 == type)<br>\t\t\t{<br>\t\t\t\thandler = [this](int t)<br>\t\t\t    {<br>\t\t\t        m_int_list.push_back(t);<br>\t\t\t    };<br>\t\t\t}<br>\t\t\telse<br>\t\t\t{<br>\t\t\t    handler = [this](int t)<br>\t\t\t    {<br>\t\t\t        m_int_list.push_back(t + 1);<br>\t\t\t    };<br>\t\t\t}<br>\t\t}<br>        <br>        int insert(int t)<br>\t\t{<br>\t\t    handler(t);<br>\t\t}<br>private:<br>    Handler handler;<br>\tstd::list&lt;int&gt; m_int_list;<br>};<br><br>这个例子能够运行成功，并且不会出现coredump。<br>但是在实际的系统中，编写了类似的代码，结果导致coredump。每当lambda表达式访问类的成员变量时，就会coredump。<br><br>老师，这是什么原因呢？<br><br>最后通过函数指针的形式解决的。","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501348,"discussion_content":"可以用，但我觉得写的有点问题，最好是在类定义时直接初始化function，还有尽量避免if-else分支。\n\n你说的coredump问题不好判断原因，因为C++关联的东西比较多。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594688028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2604222,"avatar":"https://static001.geekbang.org/account/avatar/00/27/bc/be/9cb71486.jpg","nickname":"马卡洛夫","note":"","ucode":"3FD4DA931107E8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385139,"discussion_content":"可以试试将function定义为静态函数试一下。但我比较好奇静态函数是否包装lambda","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626918221,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229497,"user_name":"Bluebuger","can_delete":false,"product_type":"c1","uid":1994088,"ip_address":"","ucode":"946EE346371D8A","user_header":"https://static001.geekbang.org/account/avatar/00/1e/6d/68/e40b3300.jpg","comment_is_top":false,"comment_ctime":1593018527,"is_pvip":false,"replies":[{"id":"84725","content":"else&#47;switch&#47;case是我个人认为要极力避免的，它增加了代码的复杂度，分支太多导致逻辑不清。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1593047419,"ip_address":"","comment_id":229497,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5887985823","product_id":100051801,"comment_content":"Map + lambda是个好东西 想起了以前做 虚拟机时候指令操作码处理时候的一堆case(switch语句)","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499507,"discussion_content":"else/switch/case是我个人认为要极力避免的，它增加了代码的复杂度，分支太多导致逻辑不清。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593047419,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359871,"user_name":"Loca..","can_delete":false,"product_type":"c1","uid":3198947,"ip_address":"上海","ucode":"CCC2E48916F0F7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/BUJPBATdJ5PiaPbSPJjzfgwCvSu6QOmQSC1GY7At4spmhzO5xaxwTuVAkKrVxom0NkJclnULUqMdPlhdfpiaxEXw/132","comment_is_top":false,"comment_ctime":1666000811,"is_pvip":false,"replies":[{"id":"130904","content":"是的，就是这个意思，在lambda表达式里的变量对于外部的只读，内部是一个拷贝可以随意改。<br><br>表述上没有说清楚，抱歉。","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1666004113,"ip_address":"上海","comment_id":359871,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1666000811","product_id":100051801,"comment_content":"有一个问题是，在：“lambda 的注意事项--2.lambda的变量”这一小节里，既然[=]是按值捕获，那么表达式里面的就是外部值的拷贝，既然是拷贝，那么就与原x独立了，但在下面的代码第三行注释里却说x只读，不允许修改，我的理解是它可以修改，但是修改的是这份拷贝，而不是上面的x.所以第三行是可以存在的，您觉得呢","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590687,"discussion_content":"是的，就是这个意思，在lambda表达式里的变量对于外部的只读，内部是一个拷贝可以随意改。\n\n表述上没有说清楚，抱歉。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666004113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339330,"user_name":"Geek5657","can_delete":false,"product_type":"c1","uid":2844913,"ip_address":"","ucode":"99D5C76E3E5EE9","user_header":"","comment_is_top":false,"comment_ctime":1648038408,"is_pvip":false,"replies":[{"id":"124168","content":"是否可以考虑使用weak_ptr？","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1648348527,"ip_address":"","comment_id":339330,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1648038408","product_id":100051801,"comment_content":"lambda表达式捕获share_ptr时，   lambda表达式又被其他对象长期持有，导致share_ptr 永远无法释放怎么解决呢？<br>lambda 表达式内部 是知道可释放 share_ptr 的时机，但是share_ptr 本身没有  release的接口，无法释放","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558494,"discussion_content":"是否可以考虑使用weak_ptr？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648348527,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337226,"user_name":"Geek_19fed9","can_delete":false,"product_type":"c1","uid":2930063,"ip_address":"","ucode":"5D7248AF35DCBB","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJaLyy9PnSBlWdPzUH3ic0DWdfoeUNSmew2RVoUs8N864M1Pm0U7POyVu0DT6lVJVvzL1B29oGKHlA/132","comment_is_top":false,"comment_ctime":1646706648,"is_pvip":true,"replies":[{"id":"123288","content":"lambda表达式的返回值是自动推导的，前面的auto是声明lambda表达式的类型，没有看到代码，不知道你的auto是怎么用的，不过C++14确实进一步扩展了auto的使用范围，可以再看看前面对auto的介绍。","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1646794601,"ip_address":"","comment_id":337226,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646706648","product_id":100051801,"comment_content":"老师，我试了一下示例代码，我看到在DemoLambdal里定义了一个返回值auto的print函数。用c++11编译不过，用14就能编译过了，意思是14版以后就支持了类内使用auto了吗？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555174,"discussion_content":"lambda表达式的返回值是自动推导的，前面的auto是声明lambda表达式的类型，没有看到代码，不知道你的auto是怎么用的，不过C++14确实进一步扩展了auto的使用范围，可以再看看前面对auto的介绍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646794601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316538,"user_name":"于小咸","can_delete":false,"product_type":"c1","uid":1640946,"ip_address":"","ucode":"833D5E92016430","user_header":"https://static001.geekbang.org/account/avatar/00/19/09/f2/6ed195f4.jpg","comment_is_top":false,"comment_ctime":1634374919,"is_pvip":false,"replies":[{"id":"114648","content":"继续努力。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1634516599,"ip_address":"","comment_id":316538,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1634374919","product_id":100051801,"comment_content":"map+lambda 方法很不错诶，以后多实践下","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528404,"discussion_content":"继续努力。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634516599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281771,"user_name":"超越杨超越","can_delete":false,"product_type":"c1","uid":1028887,"ip_address":"","ucode":"BB390B4B7E19D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b3/17/9f6d67dc.jpg","comment_is_top":false,"comment_ctime":1614875414,"is_pvip":false,"replies":[{"id":"102289","content":"lambda是表达式，在函数里外都可以定义。C里面没有“匿名函数”吧，函数必须有名字，而且定义在全局空间，是一段代码的入口点。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1614908016,"ip_address":"","comment_id":281771,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1614875414","product_id":100051801,"comment_content":"请问一下，lamda和c中的匿名函数相比有啥不同呢","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516508,"discussion_content":"lambda是表达式，在函数里外都可以定义。C里面没有“匿名函数”吧，函数必须有名字，而且定义在全局空间，是一段代码的入口点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614908016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":271815,"user_name":"Stephen","can_delete":false,"product_type":"c1","uid":1165201,"ip_address":"","ucode":"0D49223E6CB7B1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7mAt63VrbLZPHpeZxSc4IlBYswQSnaAB5wGePaGFDehgiaNfIxI1SJ5yIHIlmVk8hsw0RaoaSCPA/132","comment_is_top":false,"comment_ctime":1609817947,"is_pvip":false,"replies":[{"id":"98606","content":"前面说过了，还有一种是模板元编程。<br><br>其实还可以有其他的一些范式，比如预处理元编程，这5种是最常用最基本的。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1609895552,"ip_address":"","comment_id":271815,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1609817947","product_id":100051801,"comment_content":"现代 C++ 里的五种基本编程范式，我只知道四种：面向过程，面向对象，泛型编程和函数式编程，请问老师，另一种是什么？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513050,"discussion_content":"前面说过了，还有一种是模板元编程。\n\n其实还可以有其他的一些范式，比如预处理元编程，这5种是最常用最基本的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609895552,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1165201,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7mAt63VrbLZPHpeZxSc4IlBYswQSnaAB5wGePaGFDehgiaNfIxI1SJ5yIHIlmVk8hsw0RaoaSCPA/132","nickname":"Stephen","note":"","ucode":"0D49223E6CB7B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339958,"discussion_content":"从第一节中找到了,是&#34;模板元变成&#34;.回顾下老师的建议:尽量让周围的人都能看懂代码”，所以常用的范式是“过程 + 对象 + 泛型”，再加上少量的“函数式”，慎用“模板元”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609848329,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252581,"user_name":"小政哥","can_delete":false,"product_type":"c1","uid":1604464,"ip_address":"","ucode":"E043BF904B6B7C","user_header":"https://static001.geekbang.org/account/avatar/00/18/7b/70/bdf11801.jpg","comment_is_top":false,"comment_ctime":1602390152,"is_pvip":true,"replies":[{"id":"92455","content":"还是建议用gcc来试验，vc没用过，按这段代码来看，用&amp;捕获变量，是可以修改count的。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1602590729,"ip_address":"","comment_id":252581,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1602390152","product_id":100051801,"comment_content":"局部的变量 lambda变量捕获与文中相同<br>相关代码<br>auto f6 = []()<br>{<br>    int count = 10;<br>    cout &lt;&lt; &quot;f6&quot; &lt;&lt; endl;<br>    &#47;&#47;auto f7 = [=, &amp;count]()<br>    auto f7 = [=, &amp;count]()<br>    {<br>        cout &lt;&lt; &quot;f7&quot; &lt;&lt; endl;<br>        count += 30;<br>        cout &lt;&lt; count &lt;&lt; endl;<br>    };<br>    f7();<br>    cout &lt;&lt; count &lt;&lt; endl;<br>};<br>但是全局变量 按值和引用都可以修改","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506810,"discussion_content":"还是建议用gcc来试验，vc没用过，按这段代码来看，用&amp;amp;捕获变量，是可以修改count的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602590729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312752,"discussion_content":"我又把代码实际运行了一下，用你的这段代码，count变量是确实变动了的，输出都是40。也许你换成gcc试试？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602810651,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252578,"user_name":"小政哥","can_delete":false,"product_type":"c1","uid":1604464,"ip_address":"","ucode":"E043BF904B6B7C","user_header":"https://static001.geekbang.org/account/avatar/00/18/7b/70/bdf11801.jpg","comment_is_top":false,"comment_ctime":1602389655,"is_pvip":true,"replies":[{"id":"92452","content":"建议用gcc来做测试，按照C++标准来说，值捕获是只读的，引用捕获修改后可以同时影响外界的值。<br><br>lambda捕获与局部变量和全局变量无关，都可以捕获。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1602590480,"ip_address":"","comment_id":252578,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1602389655","product_id":100051801,"comment_content":"visual studio 2019 编译<br>lambda变量捕获是否需要区分 捕获的是局部变量还是全局变量？<br>我捕获全局变量  用值捕获还是引用捕获都是可以修改的，但是不支持 auto f3 = [=, &amp;x]()       &#47;&#47; lambda表达式，用“&amp;”按引用捕获x，其他的按值捕获 这种方式 错误是：无法使用 lambda ， 捕获必须是来自封闭函数范围的变量<br>我捕获局部变量 用值捕获不能修改，引用捕获可以修改的，第三种方式也是支持的","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506809,"discussion_content":"建议用gcc来做测试，按照C++标准来说，值捕获是只读的，引用捕获修改后可以同时影响外界的值。\n\nlambda捕获与局部变量和全局变量无关，都可以捕获。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602590480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245511,"user_name":"ripple","can_delete":false,"product_type":"c1","uid":1090051,"ip_address":"","ucode":"99008FD0533F68","user_header":"https://wx.qlogo.cn/mmopen/vi_32/ywSuwVNMKNjRLPMjZmpQOQHWW2usAu8RwRIOlBHaVVU6J3xHdtibgO6FVzYkRIkV50vCr62ia4OwJp07giabiazUGA/132","comment_is_top":false,"comment_ctime":1598963653,"is_pvip":false,"replies":[{"id":"90306","content":"不建议用lambda捕获局部变量再传出去，这样变量的生命周期不好控制，但我觉得从语法上是没有问题的，编译不过毕竟奇怪，可能还是有别的原因。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1599008623,"ip_address":"","comment_id":245511,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1598963653","product_id":100051801,"comment_content":"最近在一个方法里要发送一条指令，去同步的从服务器获取返回结果<br>func test{<br> std::string result = &quot;&quot;;<br> define c = lamda;<br> 发送携带了lamda的数据结果到消息处理队列<br> 信号量等待<br> 返回result<br>}<br><br>lamda中捕获了result值，将lamda传给了处理消息的队列，然后网络返回后，调用了对应消息的这个lamda的函数指针，并修改result的值，但是这种写法打死编译不过，不晓得咋搞，最后还是采用的一个全局对象来存储。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504906,"discussion_content":"不建议用lambda捕获局部变量再传出去，这样变量的生命周期不好控制，但我觉得从语法上是没有问题的，编译不过毕竟奇怪，可能还是有别的原因。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599008623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245455,"user_name":"宇天飞","can_delete":false,"product_type":"c1","uid":1126444,"ip_address":"","ucode":"3FB37D1E2DAA61","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/2c/06375913.jpg","comment_is_top":false,"comment_ctime":1598948433,"is_pvip":true,"replies":[{"id":"90276","content":"lambda不能直接代替成员函数，可参考其他的留言。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1598951511,"ip_address":"","comment_id":245455,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1598948433","product_id":100051801,"comment_content":"你对函数式编程有什么样的理解和认识呢？<br>1、函数式变量像是一个数据公式，可以不断调用<br>2、相对于常规的函数，函数式编程会更加灵活，像是当前上下文一部分的概念<br>3、多个组合容易实现<br><br>lambda 表达式的形式非常简洁，可以在很多地方代替普通函数，那它能不能代替类的成员函数呢？为什么？<br>1、可以<br>2、成员变量初始化","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504885,"discussion_content":"lambda不能直接代替成员函数，可参考其他的留言。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598951511,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240444,"user_name":"l c","can_delete":false,"product_type":"c1","uid":1245596,"ip_address":"","ucode":"7D43CC471595EC","user_header":"https://static001.geekbang.org/account/avatar/00/13/01/9c/1a750bc7.jpg","comment_is_top":false,"comment_ctime":1596932510,"is_pvip":false,"replies":[{"id":"88818","content":"有这个可能，多个函数的连续调用和嵌套也会形成一个“栈”，导致可读性下降。<br><br>使用函数式编程要掌握一个度，记着写代码是给人看的，易读性可维护是第一位要求。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1597021210,"ip_address":"","comment_id":240444,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1596932510","product_id":100051801,"comment_content":"个人感觉函数式编程会不会造成代码非常冗长与降低代码可读性的问题呢？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503447,"discussion_content":"有这个可能，多个函数的连续调用和嵌套也会形成一个“栈”，导致可读性下降。\n\n使用函数式编程要掌握一个度，记着写代码是给人看的，易读性可维护是第一位要求。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597021210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234723,"user_name":"Junho","can_delete":false,"product_type":"c1","uid":1001493,"ip_address":"","ucode":"4A9611DB2D2AF8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/15/d34c134f.jpg","comment_is_top":false,"comment_ctime":1594780162,"is_pvip":false,"replies":[{"id":"86618","content":"lambda的设计目标就是要轻便廉价地使用，虽然它很像函数对象，但编译器会尽量去做优化，比如内联，所以这点不用担心，可能它会比函数指针还要高效。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1594783063,"ip_address":"","comment_id":234723,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1594780162","product_id":100051801,"comment_content":"如果把lambda表达式看做是函数对象的话，那使用lambda表达式时，需要注意它的创建&#47;销毁的开销吗？<br>我在一个游戏工程中用到它，主要用于资源加载回调的包装，也就是每次资源加载回调，几乎都涉及lambda表达式的创建。不知这种应用场景下，是否需要做特别的优化、或别的注意事项呢？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501485,"discussion_content":"lambda的设计目标就是要轻便廉价地使用，虽然它很像函数对象，但编译器会尽量去做优化，比如内联，所以这点不用担心，可能它会比函数指针还要高效。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594783063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233547,"user_name":"Geek_197dc8","can_delete":false,"product_type":"c1","uid":2007820,"ip_address":"","ucode":"0792FA33B8F404","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erwjtaqgKfnSflr8zPuz6LzE1PsxYa59Cd2QsibbDE4SGxegO0UQpRrVCa4ds2Wx3DgMW1B9VOe4UQ/132","comment_is_top":false,"comment_ctime":1594351422,"is_pvip":false,"replies":[{"id":"86218","content":"需要注意一下C++的语法，这里只是lambda的定义，还没有执行lambda，可以在connect函数加断点，或者在connect函数调用的行上加断点。<br><br>gdb调试lambda和普通函数是一样的，没有什么特别。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1594357698,"ip_address":"","comment_id":233547,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1594351422","product_id":100051801,"comment_content":"罗老师，您好，请问如何通过gdb调试复杂的lambda表达式。比如下面这个例子：<br>static ResPool&lt;RedisConnect&gt; pool([&amp;]() {<br>                        shared_ptr&lt;RedisConnect&gt; redis = make_shared&lt;RedisConnect&gt;();<br><br>                        if (redis &amp;&amp; redis-&gt;connect(host, port, timeout, memsz))<br>                        {<br>                                if (redis-&gt;auth(passwd)) return redis;<br>                        }<br><br>                        return redis = NULL;<br>                }, POOL_MAXLEN);<br> 我想单步进入到connect 函数去调试，在这步使用gdb命令s 直接进入到c++库代码里面了。不知道怎么进入connect函数。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501083,"discussion_content":"需要注意一下C++的语法，这里只是lambda的定义，还没有执行lambda，可以在connect函数加断点，或者在connect函数调用的行上加断点。\n\ngdb调试lambda和普通函数是一样的，没有什么特别。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594357698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230981,"user_name":"王木杉","can_delete":false,"product_type":"c1","uid":1628501,"ip_address":"","ucode":"712288EE2A3F4B","user_header":"https://static001.geekbang.org/account/avatar/00/18/d9/55/bd65c4df.jpg","comment_is_top":false,"comment_ctime":1593558697,"is_pvip":false,"replies":[{"id":"85311","content":"lambda的原理有点高端了，我理解它就是一个函数对象，只不过语法形式简化了，再加上了变量捕获的特性。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1593564807,"ip_address":"","comment_id":230981,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593558697","product_id":100051801,"comment_content":"咨询下 lambda  的原理","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500102,"discussion_content":"lambda的原理有点高端了，我理解它就是一个函数对象，只不过语法形式简化了，再加上了变量捕获的特性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593564807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229113,"user_name":"Seven","can_delete":false,"product_type":"c1","uid":1656378,"ip_address":"","ucode":"6F502CDCAD7A79","user_header":"https://static001.geekbang.org/account/avatar/00/19/46/3a/35d9cc02.jpg","comment_is_top":false,"comment_ctime":1592899404,"is_pvip":false,"replies":[{"id":"84491","content":"函数式编程是一种通用的范式，当然其他语言里也有，但我觉得C++的lambda更灵活，对于捕获变量的控制更精细，当然用起来也就要多小心一些。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1592902215,"ip_address":"","comment_id":229113,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1592899404","product_id":100051801,"comment_content":"和其他函数编程语言联系起来了！","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499337,"discussion_content":"函数式编程是一种通用的范式，当然其他语言里也有，但我觉得C++的lambda更灵活，对于捕获变量的控制更精细，当然用起来也就要多小心一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592902215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":227817,"user_name":"Roy Liang","can_delete":false,"product_type":"c1","uid":1098898,"ip_address":"","ucode":"1DF5FC831A35DA","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/92/338b5609.jpg","comment_is_top":false,"comment_ctime":1592487494,"is_pvip":false,"replies":[{"id":"84021","content":"C++的lambda没有这些严谨的定义，用法很灵活，如果不捕获外部变量，或者是值捕获，就可以认为相当于JavaScript的纯函数。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1592528525,"ip_address":"","comment_id":227817,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1592487494","product_id":100051801,"comment_content":"C++有没有Javascript纯函数的概念？可不可以这样理解，闭包就不是一个纯函数了，因为引用了外部的变量","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498794,"discussion_content":"C++的lambda没有这些严谨的定义，用法很灵活，如果不捕获外部变量，或者是值捕获，就可以认为相当于JavaScript的纯函数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592528525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223498,"user_name":"神瓶中的酒","can_delete":false,"product_type":"c1","uid":1952051,"ip_address":"","ucode":"09F42BDF951139","user_header":"https://static001.geekbang.org/account/avatar/00/1d/c9/33/0b64db14.jpg","comment_is_top":false,"comment_ctime":1591103177,"is_pvip":false,"replies":[{"id":"82380","content":"function-try就是把整个函数体用try给包起来，只是形式上与普通的try-catch有点区别，效果都是一样的。<br><br>使用function-try可以让函数少一级缩进，代码看起来更清楚，不用它也可以在函数体里自己加try-catch。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591153160,"ip_address":"","comment_id":223498,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591103177","product_id":100051801,"comment_content":"老师~，请问方便讲解一下function-try 和 try-catch，我是C++新人，对这个不是太理解  ","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497147,"discussion_content":"function-try就是把整个函数体用try给包起来，只是形式上与普通的try-catch有点区别，效果都是一样的。\n\n使用function-try可以让函数少一级缩进，代码看起来更清楚，不用它也可以在函数体里自己加try-catch。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591153160,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222793,"user_name":"silverhawk","can_delete":false,"product_type":"c1","uid":1018649,"ip_address":"","ucode":"BFBC8AF32868DA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8b/19/a15d060d.jpg","comment_is_top":false,"comment_ctime":1590913090,"is_pvip":false,"replies":[{"id":"82140","content":"lambda可以用在很多地方，封装各种逻辑块，常用的是算法和并发，后面标准库会看到这些用法。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1590918708,"ip_address":"","comment_id":222793,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590913090","product_id":100051801,"comment_content":"Java lambda 里面最重要j就是在streaming处理里面做各种map， filter的逻辑，不了解C++是不是也是这样","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496920,"discussion_content":"lambda可以用在很多地方，封装各种逻辑块，常用的是算法和并发，后面标准库会看到这些用法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590918708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222767,"user_name":"有学识的兔子","can_delete":false,"product_type":"c1","uid":1628867,"ip_address":"","ucode":"D1D654B1562FC9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIicr82CnrdEjibibAvyeKRQHszSzIAqoCWxN0kqC442XcjEae6S9j6NDtKLpg4Da4CUQQeUFUicWqiaDw/132","comment_is_top":false,"comment_ctime":1590909153,"is_pvip":false,"replies":[{"id":"82141","content":"Java不是太了解了，其实lambda在学术界的历史很久，只是最近这些年才被主流语言支持。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1590918781,"ip_address":"","comment_id":222767,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590909153","product_id":100051801,"comment_content":"lambda老早听说过，但工作中很少用到。<br>通过老师的这个讲解，最直接的感受是范型化和函数可以捕获外部变量（这点确实符合我们做数学题的推导过程）。另外一点是，java的匿名类是不是也借鉴了lambda的函数形式？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496909,"discussion_content":"Java不是太了解了，其实lambda在学术界的历史很久，只是最近这些年才被主流语言支持。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590918781,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222584,"user_name":"Eason Tai","can_delete":false,"product_type":"c1","uid":1200676,"ip_address":"","ucode":"4707577CC9C9E9","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/24/bd63c4de.jpg","comment_is_top":false,"comment_ctime":1590843391,"is_pvip":false,"replies":[{"id":"82101","content":"回答的不太正确，原因是auto在类里的限制，可以参考其他同学的回答。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1590879668,"ip_address":"","comment_id":222584,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590843391","product_id":100051801,"comment_content":"我理解lambda可以炫技就很帅，减少冗余。不过，一定要适度。<br><br>lambda 表达式的形式非常简洁，可以在很多地方代替普通函数，那它能不能代替类的成员函数呢？为什么？<br><br>不能代替。如果是引用捕获情况，lambda在执行的时候，对象的值可能发生变化。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496851,"discussion_content":"回答的不太正确，原因是auto在类里的限制，可以参考其他同学的回答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590879668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222581,"user_name":"Eason Tai","can_delete":false,"product_type":"c1","uid":1200676,"ip_address":"","ucode":"4707577CC9C9E9","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/24/bd63c4de.jpg","comment_is_top":false,"comment_ctime":1590841703,"is_pvip":false,"replies":[{"id":"82073","content":"差不多，可以再看第6讲，lambda表达式赋值必须用auto，但auto不能用在类成员初始化。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1590846312,"ip_address":"","comment_id":222581,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1590841703","product_id":100051801,"comment_content":"创建lambda函数等于创建了新的类型，对操作符（）进行了重载。所以直接 auto f = [=]() 相当于对一个未初始化成员函数进行auto类型定义，所以报错。这样理解对吗？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496850,"discussion_content":"差不多，可以再看第6讲，lambda表达式赋值必须用auto，但auto不能用在类成员初始化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590846312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1200676,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/24/bd63c4de.jpg","nickname":"Eason Tai","note":"","ucode":"4707577CC9C9E9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276220,"discussion_content":"哦，。解释错了，是调用时相当于创建新的类型。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590842870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222252,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1590727250,"is_pvip":false,"replies":[{"id":"81934","content":"lambda超越了早期的函数对象，因为它是“闭包”，所以有着与函数、函数对象完全不同的用法，可以说是一种“高维生物”。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1590732827,"ip_address":"","comment_id":222252,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590727250","product_id":100051801,"comment_content":"对lambda的意义，老师这一讲真是拨云见雾啊。相对于functor，它给了我们一个理解世界、表达世界的新角度","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496727,"discussion_content":"lambda超越了早期的函数对象，因为它是“闭包”，所以有着与函数、函数对象完全不同的用法，可以说是一种“高维生物”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590732827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222193,"user_name":"黄骏","can_delete":false,"product_type":"c1","uid":1849733,"ip_address":"","ucode":"3C41D02F4F712C","user_header":"https://static001.geekbang.org/account/avatar/00/1c/39/85/c6110f83.jpg","comment_is_top":false,"comment_ctime":1590714718,"is_pvip":true,"replies":[{"id":"81928","content":"任何C++特性都能被用来炫技，只是lambda实在是太炫了，刚学会难免忍不住炫一下，完全可以理解，这也是人之常情。<br><br>用多了才会真正领会它的精神，做到大象无形。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1590721259,"ip_address":"","comment_id":222193,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1590714718","product_id":100051801,"comment_content":"之前觉得用lambada可能是炫技，现在看来它也有特定的合适的应用场景，可能接触函数式编程太久，没转过弯来","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496711,"discussion_content":"任何C++特性都能被用来炫技，只是lambda实在是太炫了，刚学会难免忍不住炫一下，完全可以理解，这也是人之常情。\n\n用多了才会真正领会它的精神，做到大象无形。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590721259,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1672641,"avatar":"https://static001.geekbang.org/account/avatar/00/19/85/c1/d94111b4.jpg","nickname":"湫兮如风","note":"","ucode":"972CC6C888101F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288181,"discussion_content":"前期有想炫技的想法才会多用、出问题、解决、思考，最后升华[狗头]","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593671984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222078,"user_name":"LDxy","can_delete":false,"product_type":"c1","uid":1188710,"ip_address":"","ucode":"956432CE7B7761","user_header":"https://static001.geekbang.org/account/avatar/00/12/23/66/413c0bb5.jpg","comment_is_top":false,"comment_ctime":1590671119,"is_pvip":false,"replies":[{"id":"81869","content":"也是可以，我写的时候有点思维混乱了，感谢指正。<br><br>你也可以实际写代码试试，让编译器告诉你答案。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1590703320,"ip_address":"","comment_id":222078,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590671119","product_id":100051801,"comment_content":"auto pfunc = &amp;my_square;       &#47;&#47; 只能用指针去操作函数，指针不是函数<br>(*pfunc)(3);                    &#47;&#47; 调用需要用*，才能访问函数<br><br>如果写成pfunc(3)来调用函数对不对呢？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496659,"discussion_content":"也是可以，我写的时候有点思维混乱了，感谢指正。\n\n你也可以实际写代码试试，让编译器告诉你答案。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590703320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222054,"user_name":"EncodedStar","can_delete":false,"product_type":"c1","uid":1504234,"ip_address":"","ucode":"03958CA7DDD6AE","user_header":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","comment_is_top":false,"comment_ctime":1590665285,"is_pvip":false,"replies":[{"id":"81847","content":"试着写一下代码，看看会是什么样。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1590666642,"ip_address":"","comment_id":222054,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590665285","product_id":100051801,"comment_content":"如果把lambda 表达式看做变量，比如文章中的：”auto f3 = [](int x) {return x*x; }&quot; ，我感觉是能做成员函数的，相当于成员变量一样使用，不知道这样理解有没有错","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496650,"discussion_content":"试着写一下代码，看看会是什么样。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590666642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221937,"user_name":"无为而立","can_delete":false,"product_type":"c1","uid":2003887,"ip_address":"","ucode":"A74526BF43A077","user_header":"https://static001.geekbang.org/account/avatar/00/1e/93/af/54e2a654.jpg","comment_is_top":false,"comment_ctime":1590636559,"is_pvip":false,"replies":[{"id":"81815","content":"python 的lambda 我感觉比较笨拙，而C++的lambda 轻巧强大，应该多用，后面可以看到更多的示范用法，可以参考一下。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1590641194,"ip_address":"","comment_id":221937,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590636559","product_id":100051801,"comment_content":"在python中使用过lambda map filter， 感觉lambda可以做一些简单运算，特别是纯数学的计算。不宜太多使用。不然阅读起来费劲儿","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496618,"discussion_content":"python 的lambda 我感觉比较笨拙，而C++的lambda 轻巧强大，应该多用，后面可以看到更多的示范用法，可以参考一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590641194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221900,"user_name":"java2c++","can_delete":false,"product_type":"c1","uid":1460660,"ip_address":"","ucode":"C4F8C3D7B1A910","user_header":"","comment_is_top":false,"comment_ctime":1590630187,"is_pvip":false,"replies":[{"id":"81799","content":"多种语言互相借鉴，可以让我们写出更好的代码。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1590632452,"ip_address":"","comment_id":221900,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590630187","product_id":100051801,"comment_content":"问题1个人见解：我是Java技术栈，最近在看老师的c++课程，lamba现在Java也有了，在Java中可以简化匿名内部类的的调用写法，可以用于策略设计模式","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496604,"discussion_content":"多种语言互相借鉴，可以让我们写出更好的代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590632452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221895,"user_name":"java2c++","can_delete":false,"product_type":"c1","uid":1460660,"ip_address":"","ucode":"C4F8C3D7B1A910","user_header":"","comment_is_top":false,"comment_ctime":1590629612,"is_pvip":false,"replies":[{"id":"81800","content":"不是这个原因，可以自己写代码试试看，实践一下。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1590632529,"ip_address":"","comment_id":221895,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1590629612","product_id":100051801,"comment_content":"lamba不能代替成员函数的原因我猜测是作用域的问题，lamba只能在函数内调用，总不能把所有的逻辑都写到main函数里吧","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496603,"discussion_content":"不是这个原因，可以自己写代码试试看，实践一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590632529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1994308,"avatar":"","nickname":"catkin","note":"","ucode":"DC123F1074434F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275022,"discussion_content":"成员函数有this指针","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590648845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}