{"id":82560,"title":"43 | 要不要使用分区表？","content":"<p>我经常被问到这样一个问题：分区表有什么问题，为什么公司规范不让使用分区表呢？今天，我们就来聊聊分区表的使用行为，然后再一起回答这个问题。</p><h1>分区表是什么？</h1><p>为了说明分区表的组织形式，我先创建一个表t：</p><pre><code>CREATE TABLE `t` (\n  `ftime` datetime NOT NULL,\n  `c` int(11) DEFAULT NULL,\n  KEY (`ftime`)\n) ENGINE=InnoDB DEFAULT CHARSET=latin1\nPARTITION BY RANGE (YEAR(ftime))\n(PARTITION p_2017 VALUES LESS THAN (2017) ENGINE = InnoDB,\n PARTITION p_2018 VALUES LESS THAN (2018) ENGINE = InnoDB,\n PARTITION p_2019 VALUES LESS THAN (2019) ENGINE = InnoDB,\nPARTITION p_others VALUES LESS THAN MAXVALUE ENGINE = InnoDB);\ninsert into t values('2017-4-1',1),('2018-4-1',1);\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/06/f5/06f041129783533de9c75580f9decdf5.png?wh=1602*60\" alt=\"\"></p><center><span class=\"reference\">图1 表t的磁盘文件</span></center><p>我在表t中初始化插入了两行记录，按照定义的分区规则，这两行记录分别落在p_2018和p_2019这两个分区上。</p><p>可以看到，这个表包含了一个.frm文件和4个.ibd文件，每个分区对应一个.ibd文件。也就是说：</p><ul>\n<li>对于引擎层来说，这是4个表；</li>\n<li>对于Server层来说，这是1个表。</li>\n</ul><p>你可能会觉得这两句都是废话。其实不然，这两句话非常重要，可以帮我们理解分区表的执行逻辑。</p><h1>分区表的引擎层行为</h1><p>我先给你举个在分区表加间隙锁的例子，目的是说明对于InnoDB来说，这是4个表。</p><p><img src=\"https://static001.geekbang.org/resource/image/d2/c7/d28d6ab873bd8337d88812d45b9266c7.png?wh=939*297\" alt=\"\"></p><center><span class=\"reference\">图2 分区表间隙锁示例</span></center><p>这里顺便复习一下，我在<a href=\"https://time.geekbang.org/column/article/75659\">第21篇文章</a>和你介绍的间隙锁加锁规则。</p><p>我们初始化表t的时候，只插入了两行数据， ftime的值分别是，'2017-4-1' 和'2018-4-1' 。session A的select语句对索引ftime上这两个记录之间的间隙加了锁。如果是一个普通表的话，那么T1时刻，在表t的ftime索引上，间隙和加锁状态应该是图3这样的。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/27/d2/273c9ca869f5b52621641d73eb6f72d2.jpg?wh=1142*880\" alt=\"\"></p><center><span class=\"reference\">图3 普通表的加锁范围</span></center><p>也就是说，'2017-4-1' 和'2018-4-1' 这两个记录之间的间隙是会被锁住的。那么，sesion B的两条插入语句应该都要进入锁等待状态。</p><p>但是，从上面的实验效果可以看出，session B的第一个insert语句是可以执行成功的。这是因为，对于引擎来说，p_2018和p_2019是两个不同的表，也就是说2017-4-1的下一个记录并不是2018-4-1，而是p_2018分区的supremum。所以T1时刻，在表t的ftime索引上，间隙和加锁的状态其实是图4这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/92/5c/92f63aba0b24adefac7316c75463b95c.jpg?wh=1142*880\" alt=\"\"></p><center><span class=\"reference\">图4 分区表t的加锁范围</span></center><p>由于分区表的规则，session A的select语句其实只操作了分区p_2018，因此加锁范围就是图4中深绿色的部分。</p><p>所以，session B要写入一行ftime是2018-2-1的时候是可以成功的，而要写入2017-12-1这个记录，就要等session A的间隙锁。</p><p>图5就是这时候的show engine innodb status的部分结果。</p><p><img src=\"https://static001.geekbang.org/resource/image/e3/0f/e3d83d9ba89de9a6f541c9a2f24a3b0f.png?wh=3080*240\" alt=\"\"></p><center><span class=\"reference\">图5 session B被锁住信息</span></center><p>看完InnoDB引擎的例子，我们再来一个MyISAM分区表的例子。</p><p>我首先用alter table t engine=myisam，把表t改成MyISAM表；然后，我再用下面这个例子说明，对于MyISAM引擎来说，这是4个表。</p><p><img src=\"https://static001.geekbang.org/resource/image/94/76/941306d4a7193455dcf1cfebf7678876.png?wh=927*264\" alt=\"\"></p><center><span class=\"reference\">图6 用MyISAM表锁验证</span></center><p>在session A里面，我用sleep(100)将这条语句的执行时间设置为100秒。由于MyISAM引擎只支持表锁，所以这条update语句会锁住整个表t上的读。</p><p>但我们看到的结果是，session B的第一条查询语句是可以正常执行的，第二条语句才进入锁等待状态。</p><p>这正是因为MyISAM的表锁是在引擎层实现的，session A加的表锁，其实是锁在分区p_2018上。因此，只会堵住在这个分区上执行的查询，落到其他分区的查询是不受影响的。</p><p>看到这里，你可能会说，分区表看来还不错嘛，为什么不让用呢？我们使用分区表的一个重要原因就是单表过大。那么，如果不使用分区表的话，我们就是要使用手动分表的方式。</p><p>接下来，我们一起看看手动分表和分区表有什么区别。</p><p>比如，按照年份来划分，我们就分别创建普通表t_2017、t_2018、t_2019等等。手工分表的逻辑，也是找到需要更新的所有分表，然后依次执行更新。在性能上，这和分区表并没有实质的差别。</p><p>分区表和手工分表，一个是由server层来决定使用哪个分区，一个是由应用层代码来决定使用哪个分表。因此，从引擎层看，这两种方式也是没有差别的。</p><p>其实这两个方案的区别，主要是在server层上。从server层看，我们就不得不提到分区表一个被广为诟病的问题：打开表的行为。</p><h1>分区策略</h1><p>每当第一次访问一个分区表的时候，MySQL需要把所有的分区都访问一遍。<strong>一个典型的报错情况</strong>是这样的：如果一个分区表的分区很多，比如超过了1000个，而MySQL启动的时候，open_files_limit参数使用的是默认值1024，那么就会在访问这个表的时候，由于需要打开所有的文件，导致打开表文件的个数超过了上限而报错。</p><p>下图就是我创建的一个包含了很多分区的表t_myisam，执行一条插入语句后报错的情况。</p><p><img src=\"https://static001.geekbang.org/resource/image/ab/e7/abfa0054ec43d97fb18ba3c1c8829ae7.png?wh=2060*124\" alt=\"\"></p><center><span class=\"reference\">图 7 insert 语句报错</span></center><p>可以看到，这条insert语句，明显只需要访问一个分区，但语句却无法执行。</p><p>这时，你一定从表名猜到了，这个表我用的是MyISAM引擎。是的，因为使用InnoDB引擎的话，并不会出现这个问题。</p><p>MyISAM分区表使用的分区策略，我们称为<strong>通用分区策略</strong>（generic partitioning），每次访问分区都由server层控制。通用分区策略，是MySQL一开始支持分区表的时候就存在的代码，在文件管理、表管理的实现上很粗糙，因此有比较严重的性能问题。</p><p>从MySQL 5.7.9开始，InnoDB引擎引入了<strong>本地分区策略</strong>（native partitioning）。这个策略是在InnoDB内部自己管理打开分区的行为。</p><p>MySQL从5.7.17开始，将MyISAM分区表标记为即将弃用(deprecated)，意思是“从这个版本开始不建议这么使用，请使用替代方案。在将来的版本中会废弃这个功能”。</p><p>从MySQL 8.0版本开始，就不允许创建MyISAM分区表了，只允许创建已经实现了本地分区策略的引擎。目前来看，只有InnoDB和NDB这两个引擎支持了本地分区策略。</p><p>接下来，我们再看一下分区表在server层的行为。</p><h1>分区表的server层行为</h1><p>如果从server层看的话，一个分区表就只是一个表。</p><p>这句话是什么意思呢？接下来，我就用下面这个例子来和你说明。如图8和图9所示，分别是这个例子的操作序列和执行结果图。</p><p><img src=\"https://static001.geekbang.org/resource/image/0e/81/0eca5a3190161e59ea58493915bd5e81.png?wh=935*202\" alt=\"\"></p><center><span class=\"reference\">图8 分区表的MDL锁</span></center><p><img src=\"https://static001.geekbang.org/resource/image/af/a8/afe662f5e051a2ceb96a87624a589aa8.png?wh=2912*368\" alt=\"\"></p><center><span class=\"reference\">图9 show processlist结果</span></center><p>可以看到，虽然session B只需要操作p_2017这个分区，但是由于session A持有整个表t的MDL锁，就导致了session B的alter语句被堵住。</p><p>这也是DBA同学经常说的，分区表，在做DDL的时候，影响会更大。如果你使用的是普通分表，那么当你在truncate一个分表的时候，肯定不会跟另外一个分表上的查询语句，出现MDL锁冲突。</p><p>到这里我们小结一下：</p><ol>\n<li>\n<p>MySQL在第一次打开分区表的时候，需要访问所有的分区；</p>\n</li>\n<li>\n<p>在server层，认为这是同一张表，因此所有分区共用同一个MDL锁；</p>\n</li>\n<li>\n<p>在引擎层，认为这是不同的表，因此MDL锁之后的执行过程，会根据分区表规则，只访问必要的分区。</p>\n</li>\n</ol><p>而关于“必要的分区”的判断，就是根据SQL语句中的where条件，结合分区规则来实现的。比如我们上面的例子中，where ftime='2018-4-1'，根据分区规则year函数算出来的值是2018，那么就会落在p_2019这个分区。</p><p>但是，如果这个where 条件改成 where ftime&gt;='2018-4-1'，虽然查询结果相同，但是这时候根据where条件，就要访问p_2019和p_others这两个分区。</p><p>如果查询语句的where条件中没有分区key，那就只能访问所有分区了。当然，这并不是分区表的问题。即使是使用业务分表的方式，where条件中没有使用分表的key，也必须访问所有的分表。</p><p>我们已经理解了分区表的概念，那么什么场景下适合使用分区表呢？</p><h1>分区表的应用场景</h1><p>分区表的一个显而易见的优势是对业务透明，相对于用户分表来说，使用分区表的业务代码更简洁。还有，分区表可以很方便的清理历史数据。</p><p>如果一项业务跑的时间足够长，往往就会有根据时间删除历史数据的需求。这时候，按照时间分区的分区表，就可以直接通过alter table t drop partition ...这个语法删掉分区，从而删掉过期的历史数据。</p><p>这个alter table t drop partition ...操作是直接删除分区文件，效果跟drop普通表类似。与使用delete语句删除数据相比，优势是速度快、对系统影响小。</p><h1>小结</h1><p>这篇文章，我主要和你介绍的是server层和引擎层对分区表的处理方式。我希望通过这些介绍，你能够对是否选择使用分区表，有更清晰的想法。</p><p>需要注意的是，我是以范围分区（range）为例和你介绍的。实际上，MySQL还支持hash分区、list分区等分区方法。你可以在需要用到的时候，再翻翻<a href=\"https://dev.mysql.com/doc/refman/8.0/en/partitioning-types.html\">手册</a>。</p><p>实际使用时，分区表跟用户分表比起来，有两个绕不开的问题：一个是第一次访问的时候需要访问所有分区，另一个是共用MDL锁。</p><p>因此，如果要使用分区表，就不要创建太多的分区。我见过一个用户做了按天分区策略，然后预先创建了10年的分区。这种情况下，访问分区表的性能自然是不好的。这里有两个问题需要注意：</p><ol>\n<li>\n<p>分区并不是越细越好。实际上，单表或者单分区的数据一千万行，只要没有特别大的索引，对于现在的硬件能力来说都已经是小表了。</p>\n</li>\n<li>\n<p>分区也不要提前预留太多，在使用之前预先创建即可。比如，如果是按月分区，每年年底时再把下一年度的12个新分区创建上即可。对于没有数据的历史分区，要及时的drop掉。</p>\n</li>\n</ol><p>至于分区表的其他问题，比如查询需要跨多个分区取数据，查询性能就会比较慢，基本上就不是分区表本身的问题，而是数据量的问题或者说是使用方式的问题了。</p><p>当然，如果你的团队已经维护了成熟的分库分表中间件，用业务分表，对业务开发同学没有额外的复杂性，对DBA也更直观，自然是更好的。</p><p>最后，我给你留下一个思考题吧。</p><p>我们举例的表中没有用到自增主键，假设现在要创建一个自增字段id。MySQL要求分区表中的主键必须包含分区字段。如果要在表t的基础上做修改，你会怎么定义这个表的主键呢？为什么这么定义呢？</p><p>你可以把你的结论和分析写在留言区，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p><h1>上期问题时间</h1><p>上篇文章后面还不够多，可能很多同学还没来记得看吧，我们就等后续有更多留言的时候，再补充本期的“上期问题时间”吧。</p><p>@夹心面包 提到了在grant的时候是支持通配符的：\"_\"表示一个任意字符，“%”表示任意字符串。这个技巧在一个分库分表方案里面，同一个分库上有多个db的时候，是挺方便的。不过我个人认为，权限赋值的时候，控制的精确性还是要优先考虑的。</p>","comments":[{"had_liked":false,"id":69011,"user_name":"夹心面包","can_delete":false,"product_type":"c1","uid":1301957,"ip_address":"","ucode":"002BBA49D83D17","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJCscgdVibmoPyRLRaicvk6rjTJxePZ6VFHvGjUQvtfhCS6kO4OZ1AVibbhNGKlWZmpEFf2yA6ptsqHw/132","comment_is_top":true,"comment_ctime":1550644924,"is_pvip":false,"replies":[{"id":"24484","content":"👍  非常好<br>","user_name":"作者回复","comment_id":69011,"uid":"1264162","ip_address":"","utype":1,"ctime":1550651492,"user_name_real":"林晓斌"}],"discussion_count":2,"race_medal":0,"score":"9.2233723046933996e+18","product_id":100020801,"comment_content":"我说下我的感想<br>1 经典的利用分区表的场景<br>    1 zabbix历史数据表的改造,利用存储过程创建和改造<br>    2 后台数据的分析汇总,比如日志数据,便于清理<br>这两种场景我们都在执行,我们对于分区表在业务采用的是hash 用户ID方式,不过大规模应用分区表的公司我还没遇到过<br>2 分区表需要注意的几点<br>总结下<br>1 由于分区表都很大,DDL耗时是非常严重的,必须考虑这个问题<br>2 分区表不能建立太多的分区,我曾被分享一个因为分区表分区过多导致的主从延迟问题<br>3 分区表的规则和分区需要预先设置好,否则后来进行修改也很麻烦<br>","like_count":63,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439912,"discussion_content":"👍  非常好\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550651492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1069127,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/47/46da4585.jpg","nickname":"Fan()","note":"","ucode":"FED79EC7D78E91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309439,"discussion_content":"邓总牛逼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601290382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122180,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1565313455,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"267853285807","product_id":100020801,"comment_content":"1：啥是分区表？<br>创建表的时候，使用了数据分区相关的语法，存储数据的时候，存储引擎会根据分区规则将不同的数据存入不同的分区文件。<br>2：使用分区表的劣势？<br>2-1：MySQL 在第一次打开分区表的时候，需要访问所有的分区——打开的表较多，性能糟糕也可能报打开的表超过设置的问题。<br>2-2：在 server 层，认为这是同一张表，因此所有分区共用同一个 MDL 锁——锁粒度大，影响并发度，站在Server看也是合理的，不过站在存储引擎的角度看就不合理了。<br>2-3：在引擎层，认为这是不同的表，因此 MDL 锁之后的执行过程，会根据分区表规则，只访问必要的分区——被访问到的分区。<br>3：使用分区表的优势？<br>分区表的一个显而易见的优势是对业务透明，相对于用户分表来说，使用分区表的业务代码更简洁。还有，分区表可以很方便的清理历史数据。<br>4：啥时候适合使用分区表？<br>单表过大时，使用时注意一下两点<br>4-1：分区并不是越细越好。实际上，单表或者单分区的数据一千万行，只要没有特别大的索引，对于现在的硬件能力来说都已经是小表了。<br>4-2：分区也不要提前预留太多，在使用之前预先创建即可。比如，如果是按月分区，每年年底时再把下一年度的 12 个新分区创建上即可。对于没有数据的历史分区，要及时的 drop 掉。<br>5：使用分区表，有其特点的根本原因？<br>对于Server层，分区表还是一个表<br>对于存储引擎层，分区表会是多张表","like_count":63},{"had_liked":false,"id":69381,"user_name":"aliang","can_delete":false,"product_type":"c1","uid":1149502,"ip_address":"","ucode":"B36B94B362477F","user_header":"https://static001.geekbang.org/account/avatar/00/11/8a/3e/30c05bce.jpg","comment_is_top":false,"comment_ctime":1550731637,"is_pvip":true,"replies":[{"id":"24677","content":"好问题。<br><br>在InnoDB引擎打开文件超过 innodb_open_files这个值的时候，就会关掉一些之前打开的文件。<br><br>其实我们文章中 ，InnoDB分区表使用了本地分区策略以后，即使分区个数大于open_files_limit ，打开InnoDB分区表也不会报“打开文件过多”这个错误，就是innodb_open_files这个参数发挥的作用。<br>","user_name":"作者回复","comment_id":69381,"uid":"1264162","ip_address":"","utype":1,"ctime":1550755278,"user_name_real":"林晓斌"}],"discussion_count":3,"race_medal":0,"score":"263543736693","product_id":100020801,"comment_content":"老师，mysql还有一个参数是innodb_open_files，资料上说作用是限制Innodb能打开的表的数量。它和open_files_limit之间有什么关系吗？","like_count":62,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440090,"discussion_content":"好问题。\n\n在InnoDB引擎打开文件超过 innodb_open_files这个值的时候，就会关掉一些之前打开的文件。\n\n其实我们文章中 ，InnoDB分区表使用了本地分区策略以后，即使分区个数大于open_files_limit ，打开InnoDB分区表也不会报“打开文件过多”这个错误，就是innodb_open_files这个参数发挥的作用。\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1550755278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1180501,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/55/fc9f7170.jpg","nickname":"Fisheart","note":"","ucode":"207201926104D9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579161,"discussion_content":"innodb_open_files  vs open_files_limit 。\n感觉一个是innodb引擎的参数，一个是mysql Server层的参数。 一般前一个参数设置的要比后一个大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657208168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1228852,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c0/34/0574bb44.jpg","nickname":"最初的印象","note":"","ucode":"4DD68307FA274E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":136814,"discussion_content":"MySQL 5.7.12 在默认情况下，innodb_open_files=300，open_files_limit=6209，“在InnoDB引擎打开文件超过 innodb_open_files这个值的时候，就会关掉一些之前打开的文件。” 这句话这么说的话open_files_limit=6209是不是就没用了？就只能同时开300个表了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579165900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":69431,"user_name":"万勇","can_delete":false,"product_type":"c1","uid":1309092,"ip_address":"","ucode":"BC9E0918DF4516","user_header":"https://static001.geekbang.org/account/avatar/00/13/f9/a4/f0b92135.jpg","comment_is_top":false,"comment_ctime":1550742107,"is_pvip":false,"replies":[{"id":"24676","content":"仅仅看性能，是没什么差别的<br><br>但是建议尽量不要加after column_name，<br>也就是说尽量加到最后一列。<br><br>因为其实没差别，但是加在最后有以下两个好处：<br>1. 开始有一些分支支持快速加列，就是说如果你加在最后一列，是瞬间就能完成，而加了after column_name，就用不上这些优化（以后潜在的好处）<br><br>2. 我们在前面的文章有提到过，如果怕对线上业务造成影响，有时候是通过“先做备库、切换、再做备库”这种方式来执行ddl的，那么使用after column_name的时候用不上这种方式。<br><br>实际上列的数据是不应该有影响的，还是要形成好习惯😆","user_name":"作者回复","comment_id":69431,"uid":"1264162","ip_address":"","utype":1,"ctime":1550755154,"user_name_real":"林晓斌"}],"discussion_count":4,"race_medal":0,"score":"134694728283","product_id":100020801,"comment_content":"老师，请问add column after column_name跟add column不指定位置，这两种性能上有区别吗？我们在add column 指定after column_name的情况很多。","like_count":32,"discussions":[{"author":{"id":1024294,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","nickname":"null","note":"","ucode":"F9039EFED6B55D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7927,"discussion_content":"没太理解，为什么使用 after column_name 则用不上 “先做备库，切换，再做备库” 这种方式","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1567732426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1033578,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c5/6a/7f858f1f.jpg","nickname":"白不吃","note":"","ucode":"F019914D8819C2","race_medal":4,"user_type":1,"is_pvip":true},"reply_author":{"id":1024294,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","nickname":"null","note":"","ucode":"F9039EFED6B55D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381941,"discussion_content":"我跟你有同样的疑问，做备库，在备库执行after column_name 不行么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625310152,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7927,"ip_address":""},"score":381941,"extra":""}]},{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440119,"discussion_content":"仅仅看性能，是没什么差别的\n\n但是建议尽量不要加after column_name，\n也就是说尽量加到最后一列。\n\n因为其实没差别，但是加在最后有以下两个好处：\n1. 开始有一些分支支持快速加列，就是说如果你加在最后一列，是瞬间就能完成，而加了after column_name，就用不上这些优化（以后潜在的好处）\n\n2. 我们在前面的文章有提到过，如果怕对线上业务造成影响，有时候是通过“先做备库、切换、再做备库”这种方式来执行ddl的，那么使用after column_name的时候用不上这种方式。\n\n实际上列的数据是不应该有影响的，还是要形成好习惯😆","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1550755154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3046032,"avatar":"","nickname":"Geek_2969df","note":"","ucode":"E953E199B4FD03","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588879,"discussion_content":"万勇，是物流的的那个万勇吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664191661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":68896,"user_name":"郭江伟","can_delete":false,"product_type":"c1","uid":1313994,"ip_address":"","ucode":"613D638619B5A2","user_header":"https://static001.geekbang.org/account/avatar/00/14/0c/ca/6173350b.jpg","comment_is_top":false,"comment_ctime":1550626615,"is_pvip":false,"replies":[{"id":"24993","content":"👍","user_name":"作者回复","comment_id":68896,"uid":"1264162","ip_address":"","utype":1,"ctime":1550997915,"user_name_real":"林晓斌"}],"discussion_count":6,"race_medal":0,"score":"108924809015","product_id":100020801,"comment_content":"此时主键包含自增列+分区键，原因为对innodb来说分区等于单独的表，自增字段每个分区可以插入相同的值，如果主键只有自增列无法完全保证唯一性。<br>测试表如下：<br>mysql&gt; show create table t\\G<br>       Table: t<br>Create Table: CREATE TABLE `t` (<br>  `id` int(11) NOT NULL AUTO_INCREMENT,<br>  `ftime` datetime NOT NULL,<br>  `c` int(11) DEFAULT NULL,<br>  PRIMARY KEY (`id`,`ftime`),<br>  KEY `ftime` (`ftime`)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4<br>&#47;*!50100 PARTITION BY RANGE (YEAR(ftime))<br>(PARTITION p_2017 VALUES LESS THAN (2017) ENGINE = InnoDB,<br> PARTITION p_2018 VALUES LESS THAN (2018) ENGINE = InnoDB,<br> PARTITION p_2019 VALUES LESS THAN (2019) ENGINE = InnoDB,<br> PARTITION p_others VALUES LESS THAN MAXVALUE ENGINE = InnoDB) *&#47;<br>1 row in set (0.00 sec)<br>mysql&gt; insert into t values(1,&#39;2017-4-1&#39;,1),(1,&#39;2018-4-1&#39;,1);<br>Query OK, 2 rows affected (0.02 sec)<br>mysql&gt; select * from t;<br>+----+---------------------+------+<br>| id | ftime               | c    |<br>+----+---------------------+------+<br>|  1 | 2017-04-01 00:00:00 |    1 |<br>|  1 | 2018-04-01 00:00:00 |    1 |<br>+----+---------------------+------+<br>2 rows in set (0.00 sec)<br><br>mysql&gt; insert into t values(null,&#39;2017-5-1&#39;,1),(null,&#39;2018-5-1&#39;,1);<br>Query OK, 2 rows affected (0.02 sec)<br><br>mysql&gt; select * from t;<br>+----+---------------------+------+<br>| id | ftime               | c    |<br>+----+---------------------+------+<br>|  1 | 2017-04-01 00:00:00 |    1 |<br>|  2 | 2017-05-01 00:00:00 |    1 |<br>|  1 | 2018-04-01 00:00:00 |    1 |<br>|  3 | 2018-05-01 00:00:00 |    1 |<br>+----+---------------------+------+<br>4 rows in set (0.00 sec)","like_count":26,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439863,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550997915,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1043325,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/c9xpiakQ3OC1AlfCeW03lLnnb7mj5v35Hib8YDs66zpnVib2n2qFichFmFp2Ec4QDPR0dKh38MkBBLyD3bE4NiaanZQ/132","nickname":"龙晓","note":"","ucode":"FAF34F1C65D103","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362601,"discussion_content":"将ftime设置为索引第一个字段是不是可以少建一个索引？\n自增列设置为第一个字段是不是能减少索引分裂","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1616989969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1006735,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5c/8f/551b5624.jpg","nickname":"小可","note":"","ucode":"8834AF621FA67D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537630,"discussion_content":"①ALTER TABLE `p`\nADD COLUMN `id`  int NULL AUTO_INCREMENT FIRST ;\n只加id自增列，执行报错，提示自增列只能有一个，且必须索引列\nIncorrect table definition; there can be only one auto column and it must be defined as a key；\n②ALTER TABLE `p`\nADD COLUMN `id`  int NOT NULL AUTO_INCREMENT FIRST ,\nADD PRIMARY KEY (`id`);\nid自增加key，执行报错，提示主键必须包含所有分区函数使用列\nA PRIMARY KEY must include all columns in the table’s partitioning function\n③ALTER TABLE `p`\nADD COLUMN `id`  int NOT NULL AUTO_INCREMENT FIRST ,\nADD PRIMARY KEY (`id`, `ftime`);\nid自增，id+ftime联合主键，执行成功\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639124983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1203576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5d/78/f011d586.jpg","nickname":"遇见阳光","note":"","ucode":"378E5D37B3CD0E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":396788,"discussion_content":"唯一的解释只能是server层认为是一个表。所以必须存在唯一建","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632493382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2116363,"avatar":"https://static001.geekbang.org/account/avatar/00/20/4b/0b/3f1e9054.jpg","nickname":"aben","note":"","ucode":"A04792E90AFCD9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385469,"discussion_content":"自增id, 为什么在插入的时候要指定呢? 不指定的话, 就仍然是一个表的自增, 与分区无关.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627054016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1019332,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","nickname":"长期规划","note":"","ucode":"5EF65E9115834B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334955,"discussion_content":"这个很好解释了为何MySQL要求唯一键中必须包含分区键的原因。之前我也这么认为，但没动手实践过。赞👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608035628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":70356,"user_name":"☞","can_delete":false,"product_type":"c1","uid":1302793,"ip_address":"","ucode":"6FAEF05F234D2A","user_header":"https://static001.geekbang.org/account/avatar/00/13/e1/09/9483f537.jpg","comment_is_top":false,"comment_ctime":1551083720,"is_pvip":false,"replies":[{"id":"25102","content":"第一次访问的时候，要打开所有分区的<br><br>","user_name":"作者回复","comment_id":70356,"uid":"1264162","ip_address":"","utype":1,"ctime":1551092396,"user_name_real":"林晓斌"}],"discussion_count":2,"race_medal":0,"score":"83155462344","product_id":100020801,"comment_content":"老师确认下，5.7.9之后的innodb分区表，是访问第一个表时不会去打开所有的分区表了吗？","like_count":20,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440582,"discussion_content":"第一次访问的时候，要打开所有分区的\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551092396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1161271,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","nickname":"不似旧日","note":"","ucode":"DF4C5E3AB9570C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384105,"discussion_content":"为什么要打开所有分区","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626363724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":68852,"user_name":"wljs","can_delete":false,"product_type":"c1","uid":1306543,"ip_address":"","ucode":"6B88A664972AD2","user_header":"https://static001.geekbang.org/account/avatar/00/13/ef/af/ba786593.jpg","comment_is_top":false,"comment_ctime":1550623731,"is_pvip":false,"replies":[{"id":"24443","content":"用view可能可以实现部分你的需求，但是强烈不建议这么做。<br>业务不想修改，就好好跟他们说，毕竟这样分（常查和不常查的垂直拆分）是合理的，对读写性能都有明显的提升的。","user_name":"作者回复","comment_id":68852,"uid":"1264162","ip_address":"","utype":1,"ctime":1550625367,"user_name_real":"林晓斌"}],"discussion_count":3,"race_medal":0,"score":"65975133171","product_id":100020801,"comment_content":"<br>老师我想问个问题 我们公司一个订单表有110个字段 想拆分成两个表 第一个表放经常查的字段 第二个表放不常查的 现在程序端不想改sql，数据库端来实现 当查询字段中 第一个表不存在 就去关联第二个表查出数据  db能实现不","like_count":16,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439853,"discussion_content":"用view可能可以实现部分你的需求，但是强烈不建议这么做。\n业务不想修改，就好好跟他们说，毕竟这样分（常查和不常查的垂直拆分）是合理的，对读写性能都有明显的提升的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550625367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1333649,"avatar":"https://static001.geekbang.org/account/avatar/00/14/59/91/fa2d8bb2.jpg","nickname":"不吃辣👾","note":"","ucode":"B25E0725B5E85F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387269,"discussion_content":"高质量留言","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628078699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1812970,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","nickname":"mgs2002","note":"","ucode":"F5931108BD509B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304383,"discussion_content":"单表字段太多了，拆吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599557606,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":69125,"user_name":"权恒星","can_delete":false,"product_type":"c1","uid":1090619,"ip_address":"","ucode":"2700E28092020D","user_header":"https://static001.geekbang.org/account/avatar/00/10/a4/3b/a29c8eec.jpg","comment_is_top":false,"comment_ctime":1550666091,"is_pvip":false,"replies":[{"id":"24521","content":"对这篇文章讲的是单机上的单表多分区","user_name":"作者回复","comment_id":69125,"uid":"1264162","ip_address":"","utype":1,"ctime":1550669307,"user_name_real":"林晓斌"}],"discussion_count":5,"race_medal":0,"score":"53090273643","product_id":100020801,"comment_content":"这个只适合单机吧？集群没法即使用innodb引擎，又支持分区表吧，只能使用中间件了。之前调研了一下，官方只有ndb cluster才支持分区表？","like_count":12,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439963,"discussion_content":"对这篇文章讲的是单机上的单表多分区","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550669307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1729060,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/62/24/07e2507c.jpg","nickname":"托尼斯威特","note":"","ucode":"98A1035527292E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306518,"discussion_content":"集群 太模糊，主从复制的集群还是需要分区表的。分库分表集群，就已经手动分表了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600309693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1019332,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","nickname":"长期规划","note":"","ucode":"5EF65E9115834B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334959,"discussion_content":"看来分区表的性能还是受限于单机的IO，内存和CPU","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608035923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1237199,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e0/cf/43f201f2.jpg","nickname":"幼儿编程教学","note":"","ucode":"F13F3150E6CAE9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292879,"discussion_content":"都集群了，无所谓分区表了吧？集群就是解决了磁盘空间和性能的问题吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595375221,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1091556,"avatar":"https://static001.geekbang.org/account/avatar/00/10/a7/e4/5a4515e9.jpg","nickname":"成立-Charlie","note":"","ucode":"2970BB5446B70A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209162,"discussion_content":"老师，InnoDB cluster不支持分区表吗？8.0也不可以吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584615611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":68904,"user_name":"千木","can_delete":false,"product_type":"c1","uid":1304605,"ip_address":"","ucode":"32EBF403E9088E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/fJ5BEicRVnXAwCxkIYhJZ0woiaQ38ibUYkYH125bzL2Y2ib1YS9b7Q9S5qia2Cia9UWzUoDBGeWJibB7p9xSnib7iaU8kzw/132","comment_is_top":false,"comment_ctime":1550627182,"is_pvip":false,"replies":[{"id":"24468","content":"“本地分区规则应该是只打开单个引擎文件”，并不是哈，我在文章末尾说了，也会打开所有文件的，只是说本地分区规则有优化，比如如果文件数过多，就会淘汰之前打开的文件句柄（暂时关掉）。<br><br>所以分区太多，还是会有影响的<br>","user_name":"作者回复","comment_id":68904,"uid":"1264162","ip_address":"","utype":1,"ctime":1550640493,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"35910365550","product_id":100020801,"comment_content":"老师您好，你在文章里面有说通用分区规则会打开所有引擎文件导致不可用，而本地分区规则应该是只打开单个引擎文件，那你不建议创建太多分区的原因是什么呢？如果是本地分区规则，照例说是不会影响的吧，叨扰了","like_count":9,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439867,"discussion_content":"“本地分区规则应该是只打开单个引擎文件”，并不是哈，我在文章末尾说了，也会打开所有文件的，只是说本地分区规则有优化，比如如果文件数过多，就会淘汰之前打开的文件句柄（暂时关掉）。\n\n所以分区太多，还是会有影响的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550640493,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74062,"user_name":"怀刚","can_delete":false,"product_type":"c1","uid":1012839,"ip_address":"","ucode":"F778DDE910918E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/74/67/46bb05de.jpg","comment_is_top":false,"comment_ctime":1552096916,"is_pvip":false,"replies":[{"id":"27082","content":"1. 对，binlog对原因<br>2. 如果延迟算损失，确实是有损的。备库上的读流量要先切换到主库（也就是为什么需要在低峰期做做个操作）","user_name":"作者回复","comment_id":74062,"uid":"1264162","ip_address":"","utype":1,"ctime":1552111011,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"31616867988","product_id":100020801,"comment_content":"请教下采用”先做备库、切换、再做备库”DDL方式不支持AFTER COLUMN是因为BINLOG原因吗？<br>以上DDL方式会存在影响“有损”的吧？“无损”有哪些方案呢？如果备库承载读请求但又不能接受“长时间”延时","like_count":7,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442418,"discussion_content":"1. 对，binlog对原因\n2. 如果延迟算损失，确实是有损的。备库上的读流量要先切换到主库（也就是为什么需要在低峰期做做个操作）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552111011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":69141,"user_name":"Q","can_delete":false,"product_type":"c1","uid":1285997,"ip_address":"","ucode":"098731DD304590","user_header":"https://static001.geekbang.org/account/avatar/00/13/9f/6d/0a21fa84.jpg","comment_is_top":false,"comment_ctime":1550669125,"is_pvip":false,"replies":[{"id":"24558","content":"应该统一成innodb<br>网上商城购物类型更要用InnoDB，因为MyISAM并不是crash-safe的。<br><br>测试环境改完回归下","user_name":"作者回复","comment_id":69141,"uid":"1264162","ip_address":"","utype":1,"ctime":1550679632,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"31615440197","product_id":100020801,"comment_content":"老师 请问下  网站开发数据库表是myisam和innodb混合引擎  考虑管理比较麻烦  想统一成innodb 请问是否影响数据库或带来什么隐患吗？  网站是网上商城购物类型的","like_count":7,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439968,"discussion_content":"应该统一成innodb\n网上商城购物类型更要用InnoDB，因为MyISAM并不是crash-safe的。\n\n测试环境改完回归下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550679632,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177209,"user_name":"zc","can_delete":false,"product_type":"c1","uid":1213495,"ip_address":"","ucode":"07900D4B6A3135","user_header":"https://static001.geekbang.org/account/avatar/00/12/84/37/a13d867a.jpg","comment_is_top":false,"comment_ctime":1581322754,"is_pvip":false,"replies":[{"id":"68820","content":"要加 不过因为时间很短，可以认为是安全操作","user_name":"作者回复","comment_id":177209,"uid":"1264162","ip_address":"","utype":1,"ctime":1581334444,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"23056159234","product_id":100020801,"comment_content":"alter table t drop partition 不加元数据锁吗？","like_count":6,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483345,"discussion_content":"要加 不过因为时间很短，可以认为是安全操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581334444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":70361,"user_name":"分清云淡","can_delete":false,"product_type":"c1","uid":1269873,"ip_address":"","ucode":"7045AE6BF72D31","user_header":"https://static001.geekbang.org/account/avatar/00/13/60/71/895ee6cf.jpg","comment_is_top":false,"comment_ctime":1551085278,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"23025921758","product_id":100020801,"comment_content":"阿里云的DRDS就是分库分表的中间件典型代表。自己实现了一个层Server访问层在这一层进行分库分表（对透明），然后MySQL只是相当于存储层。一些Join、负载Order by&#47;Group by都在DRDS中间件这层完成，简单的逻辑插叙计算完对应的分库分表后下推给MySQL https:&#47;&#47;www.aliyun.com&#47;product&#47;drds","like_count":6,"discussions":[{"author":{"id":1518348,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2b/0c/f4bdb520.jpg","nickname":"Dr. Wong","note":"","ucode":"0CEF58927E69E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339346,"discussion_content":"order by 和 group by的性能不敢恭维","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609642720,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297153,"discussion_content":"用过，不过是18 19年那会还出了不少bug。比如版本升级造成的连接不稳定等。而且最关键的是真心不便宜，如果技术团队内部能搞定，还是要注意下性价比的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596788735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":69440,"user_name":"helloworld.xs","can_delete":false,"product_type":"c1","uid":1265652,"ip_address":"","ucode":"AE9CDD78FD5994","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/MSV5CclX2Zct7U0F7bVwd0Zg4y6AK1qf8GVic5W3tCNaLhL6wTqD7CUnWxarW4DiaVbVic1G3gpZ3ud0ELWhuxnrg/132","comment_is_top":false,"comment_ctime":1550745455,"is_pvip":false,"replies":[{"id":"24675","content":"update的话，主要应该第一次执行的时候，数据都读入到了","user_name":"作者回复","comment_id":69440,"uid":"1264162","ip_address":"","utype":1,"ctime":1550754922,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"23025581935","product_id":100020801,"comment_content":"请教个问题，一般mysql会有查询缓存，但是update操作也有缓存机制吗？使用mysql console第一次执行一个update SQL耗时明显比后面执行相同update SQL要慢，这是为什么？","like_count":6,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440122,"discussion_content":"update的话，主要应该第一次执行的时候，数据都读入到了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550754922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":69033,"user_name":"布衣骇客","can_delete":false,"product_type":"c1","uid":1256280,"ip_address":"","ucode":"5226B0F67090D1","user_header":"https://static001.geekbang.org/account/avatar/00/13/2b/58/11c05ccb.jpg","comment_is_top":false,"comment_ctime":1550649083,"is_pvip":false,"replies":[{"id":"24483","content":"赞两次 😆<br><br>这个就是我们文章说的“分库分表中间件”<br>不过看到不少公司都会要在这基础上做点定制化","user_name":"作者回复","comment_id":69033,"uid":"1264162","ip_address":"","utype":1,"ctime":1550651103,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"23025485563","product_id":100020801,"comment_content":"这次竟然只需要再读两次就能读懂，之前接触过mycat和sharding-jdbc实现分区,老师能否谈谈这方面的呢","like_count":6,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439925,"discussion_content":"赞两次 😆\n\n这个就是我们文章说的“分库分表中间件”\n不过看到不少公司都会要在这基础上做点定制化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550651103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":69526,"user_name":"daka","can_delete":false,"product_type":"c1","uid":1307998,"ip_address":"","ucode":"A23D82FF956793","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ8ibLXicovSNwEJhP4BOIPxEMle1ZUq1He58xztgBXTQFicdp5m5ibRHwUSoUVk5xQMWFwFXhp56ibm1Q/132","comment_is_top":false,"comment_ctime":1550760906,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18730630090","product_id":100020801,"comment_content":"本期提到了ndb，了解了下，这个存储引擎高可用及读写可扩展性功能都是自带，感觉是不错，为什么很少见人使用呢？生产不可靠？","like_count":4},{"had_liked":false,"id":70335,"user_name":"NICK","can_delete":false,"product_type":"c1","uid":1322863,"ip_address":"","ucode":"FE50160CA16DCC","user_header":"https://static001.geekbang.org/account/avatar/00/14/2f/6f/31721039.jpg","comment_is_top":false,"comment_ctime":1551078000,"is_pvip":false,"replies":[{"id":"25105","content":"分区表的用法跟普通表，在sql语句上是相同的。","user_name":"作者回复","comment_id":70335,"uid":"1264162","ip_address":"","utype":1,"ctime":1551092565,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"14435979888","product_id":100020801,"comment_content":"老师，如果用户分区，业务要做分页过滤查询怎么做才好？","like_count":3,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440570,"discussion_content":"分区表的用法跟普通表，在sql语句上是相同的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551092565,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":68942,"user_name":"undifined","can_delete":false,"product_type":"c1","uid":1068920,"ip_address":"","ucode":"449CB4CD2DC089","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/78/c3d8ecb0.jpg","comment_is_top":false,"comment_ctime":1550631229,"is_pvip":false,"replies":[{"id":"24466","content":"1. 我们语句里面是 where ftime=&#39;2017-5-1&#39; 哈，不是“4-1”<br>2. “分区表的查询性能还是要比不分区好，这样理解对吗”，其实还是要看表的索引情况。<br>   当然一定存在一个数量级N，把这N行分到10个分区表，比把这N行放到一个大表里面，效率高","user_name":"作者回复","comment_id":68942,"uid":"1264162","ip_address":"","utype":1,"ctime":1550640404,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"14435533117","product_id":100020801,"comment_content":"老师，有两个问题<br>1. 图三的间隙锁，根据“索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁”，不应该是 (-∞,2017-4-1],(2017-4-1,2018-4-1)吗，图4左边的也应该是 (-∞,2017-4-1],(2017-4-1, supernum)，是不是图画错了<br>2. 现有的一个表，一千万行的数据， InnoDB 引擎，如果以月份分区，即使有 MDL 锁和初次访问时会查询所有分区，但是综合来看，分区表的查询性能还是要比不分区好，这样理解对吗<br><br>思考题的答案 <br>ALTER TABLE t<br>  ADD COLUMN (id INT AUTO_INCREMENT ),<br>  ADD PRIMARY KEY (id, ftime);<br><br>麻烦老师解答一下，谢谢老师","like_count":3,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439882,"discussion_content":"1. 我们语句里面是 where ftime=&amp;#39;2017-5-1&amp;#39; 哈，不是“4-1”\n2. “分区表的查询性能还是要比不分区好，这样理解对吗”，其实还是要看表的索引情况。\n   当然一定存在一个数量级N，把这N行分到10个分区表，比把这N行放到一个大表里面，效率高","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550640404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":293427,"user_name":"何霖","can_delete":false,"product_type":"c1","uid":1510761,"ip_address":"","ucode":"8BBE3BFD0691B8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/NP6xd0gtGwNWnzrk2hn1zgscu7ZuLRibDCrbJzHBRk1Bicb8X7uXlrfTH1Bh4epCNxts4ok4z1sGPHpWjtSaUqnQ/132","comment_is_top":false,"comment_ctime":1621388415,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5916355711","product_id":100020801,"comment_content":"尊敬的作者，你说“分区并不是越细越好。实际上，单表或者单分区的数据一千万行，只要没有特别大的索引，对于现在的硬件能力来说都已经是小表了”，怎么判断索引是大索引还是小索引啊。","like_count":1,"discussions":[{"author":{"id":1744257,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/9d/81/d748b7eb.jpg","nickname":"千锤百炼领悟之极限","note":"","ucode":"224B5CF2101716","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380514,"discussion_content":"看表索引的占用空间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624539257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222388,"user_name":"PhilZhang","can_delete":false,"product_type":"c1","uid":1088010,"ip_address":"","ucode":"383F1A792C7DF9","user_header":"https://static001.geekbang.org/account/avatar/00/10/9a/0a/922615cf.jpg","comment_is_top":false,"comment_ctime":1590770729,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5885738025","product_id":100020801,"comment_content":"我们现在有一个大表4000多w条数据，并且增长不算慢，预计用hash(user id)分64个区，这里有两个问题想请教一下：<br>1. 这么大的表是不是不能直接alter成分区表？我们计划是建一张新表，先创建触发器同步更新新数据到新表实现双写，然后由DBA倒数据到新表，<br>最后做一个table rename，不知道这样是否有什么问题？<br>2. 查询中只要带上userid条件，就可以先定位到一个分区然后进行查询？<br>3. 该表之后是否很难进行所有类型的DDL，比如增删字段或者创建索引？","like_count":1},{"had_liked":false,"id":124569,"user_name":"程辉","can_delete":false,"product_type":"c1","uid":1395334,"ip_address":"","ucode":"A8AE3BFE6EE59C","user_header":"https://static001.geekbang.org/account/avatar/00/15/4a/86/c7bd910e.jpg","comment_is_top":false,"comment_ctime":1565921795,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5860889091","product_id":100020801,"comment_content":"奇哥，我们现在有个表的数据量上亿了，每个月百万+的数据量，考虑做分区。表结构：<br>id bigint(20) auto_increment,<br>imei varchar(32),<br>atime timestamp,<br>primary key (id),<br>unique key imei (imei)<br>经讨论后考虑对atime做range分区，然后因为分区字段必须被包含在主键和唯一索引上，imei的唯一索引已经没有意义了，变成下面的表结构：<br>id bigint(20) primary key,<br>imei varchar(32),<br>atime timestamp,<br>primary key (id, atime),<br>key imei (imei)<br>partition by range ( UNIX_TIMESTAMP(atime) ) (<br>partition p2018_01_06 values less than ( UNIX_TIMESTAMP(&#39;2018-07-01&#39;) ),<br>partition p2018_07_12 values less than ( UNIX_TIMESTAMP(&#39;2019-01-01&#39;) ),<br>...<br>)<br>之前imei有唯一索引，是可以用REPLACE INTO做批量插入的，这样插入很快。<br>但是分区之后，因为imei失去了唯一性，在插入的时候要先去查这个imei存不存在，不存在再插入，没办法做批量插入了，性能下降很多。<br>这个有办法解决吗？","like_count":1,"discussions":[{"author":{"id":2070832,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/99/30/9e542e5a.jpg","nickname":"廖晶₁₃₉₀₈₄₈₆₁₄₂","note":"","ucode":"2331549830E0DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292192,"discussion_content":"怎么没有回答这种问题，不值得回答吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595133771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1321346,"avatar":"https://static001.geekbang.org/account/avatar/00/14/29/82/7c97db71.jpg","nickname":"走走道丢了","note":"","ucode":"9087149FCA5B90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2070832,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/99/30/9e542e5a.jpg","nickname":"廖晶₁₃₉₀₈₄₈₆₁₄₂","note":"","ucode":"2331549830E0DE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306782,"discussion_content":"时间太久了吧，专栏结束了，作者可能都不看了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600389677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":292192,"ip_address":""},"score":306782,"extra":""}]}]},{"had_liked":false,"id":69876,"user_name":"锋芒","can_delete":false,"product_type":"c1","uid":1320419,"ip_address":"","ucode":"BB5284E3C8D78D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ach5TNuIu8T4Of8ibvfWM4JPic5uQn9Y7TgGjBHLp2iar4icxJzs14bpUXV9OdYiciblvJl14zSqXjwtDffHnSTqbD6g/132","comment_is_top":false,"comment_ctime":1550894618,"is_pvip":false,"replies":[{"id":"24917","content":"20、21两篇看下","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1550936838,"ip_address":"","comment_id":69876,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5845861914","product_id":100020801,"comment_content":"老师，请问什么情况会出现间隙锁？能否专题讲一下锁呢？","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440325,"discussion_content":"20、21两篇看下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550936838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338025,"user_name":"Curiosity","can_delete":false,"product_type":"c1","uid":1879290,"ip_address":"","ucode":"A6732CAE6CBE8E","user_header":"https://static001.geekbang.org/account/avatar/00/1c/ac/fa/a32099e7.jpg","comment_is_top":false,"comment_ctime":1647242334,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647242334","product_id":100020801,"comment_content":"分区键必须是主键的一部分？<br>个人认为还是基于性能考虑。假设分区键和主键是两个不同的列，在进行插入操作时，虽然也指定了分区键，但还是需要扫描所有分区才能判断插入的主键值是否违反了唯一性约束。这样的话，效率会比较低下，违背了分区表的初衷。<br><br>","like_count":0},{"had_liked":false,"id":332045,"user_name":"idiot","can_delete":false,"product_type":"c1","uid":2526391,"ip_address":"","ucode":"D7A6E980B530B4","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/fcftgBsticCicEEkuzB0GTkHIocX62YVTSvnhR1c94sccj42lVaYXrmcZyhzUI3l9NcvuN1rXLhXt2eBrZZ0Tw7A/132","comment_is_top":false,"comment_ctime":1642995037,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1642995037","product_id":100020801,"comment_content":"alter table t drop partition会拿MDL锁，带索引的delete不会锁整个表，这样看不是delete更好吗？","like_count":0},{"had_liked":false,"id":276946,"user_name":"子杰","can_delete":false,"product_type":"c1","uid":1025250,"ip_address":"","ucode":"717D10394391BE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/e2/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1612187648,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1612187648","product_id":100020801,"comment_content":"通透，那其实server层main完全可以更合理的优化掉MDL锁，把存储引擎层面的where判定逻辑拿来决定是使用锁几个分区表的MDL锁","like_count":0},{"had_liked":false,"id":235058,"user_name":"南子","can_delete":false,"product_type":"c1","uid":1573993,"ip_address":"","ucode":"DFBED9E1A7FC49","user_header":"https://static001.geekbang.org/account/avatar/00/18/04/69/31f5a0ae.jpg","comment_is_top":false,"comment_ctime":1594881032,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1594881032","product_id":100020801,"comment_content":"在mysql 中，在设计数据库字段列时，字段是应该被设置为null，还是应该使用的default 去替代null","like_count":0,"discussions":[{"author":{"id":1303322,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e3/1a/061e77b6.jpg","nickname":"亢星东","note":"","ucode":"5E4063E83B2BB9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333205,"discussion_content":"使用的default 去替代null","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607480121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231986,"user_name":"jiaozhuchen","can_delete":false,"product_type":"c1","uid":1510471,"ip_address":"","ucode":"65A696D75C0577","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI9cqxrtYLlu0XvlU6J7LwEn67cL9fbnJrI6UjankWwbhiaeDQ8fI2LtjMMVMFIGKSlUyeKmN29SMg/132","comment_is_top":false,"comment_ctime":1593817814,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593817814","product_id":100020801,"comment_content":"老师之前我们都说mysql超过一千万的数据，查询效率就很低了，看文章中现在的硬件，一千万算小表，老师有没有个建议值，数据行多少以后考虑分库分表","like_count":0},{"had_liked":false,"id":221980,"user_name":"注意力$","can_delete":false,"product_type":"c1","uid":1142316,"ip_address":"","ucode":"7FB3399A1EAB72","user_header":"https://static001.geekbang.org/account/avatar/00/11/6e/2c/e2f3cfc0.jpg","comment_is_top":false,"comment_ctime":1590648056,"is_pvip":false,"discussion_count":2,"race_medal":1,"score":"1590648056","product_id":100020801,"comment_content":"请问mysql 可以按照时间（按天）自动创建分区吗","like_count":0,"discussions":[{"author":{"id":1604532,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/QD9GIbqK8mx2zu6GbHQQEfWYG2oxzTlZIUQhWUrBgy4QFueKPb1qlVBUtxZictHibtjdia7ZBoNOrD1SrZPQ3TKsw/132","nickname":"Finley","note":"","ucode":"042BC805B4A1B0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284755,"discussion_content":"我目前是写的脚本，每天创建分区","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592628588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1788647,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/4a/e7/6c16af5d.jpg","nickname":"汉江","note":"","ucode":"01622D984B8F9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361458,"discussion_content":"这个要自己手动创建吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616674685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205514,"user_name":"silentyears","can_delete":false,"product_type":"c1","uid":1061748,"ip_address":"","ucode":"6E137BFEB874CA","user_header":"https://static001.geekbang.org/account/avatar/00/10/33/74/d9d143fa.jpg","comment_is_top":false,"comment_ctime":1586660967,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1586660967","product_id":100020801,"comment_content":"这么久了，不知能否看到。<br>老师，看helloworld.xs的评论<br>请教个问题，一般mysql会有查询缓存，但是update操作也有缓存机制吗？使用mysql console第一次执行一个update SQL耗时明显比后面执行相同update SQL要慢，这是为什么？<br>作者回复: update的话，主要应该第一次执行的时候，数据都读入到了<br><br>关于这个，有个疑问，请问老师：<br>update语句不是当数据不在缓存中时，会先保存在change buffer中吗？<br>为啥1、还会出现第一次update耗时明显长的情况；2、您回答的update的话，第一次执行数据都读入了。<br>是考虑数据一般有唯一索引，需要先读入？<br>谢谢！","like_count":0,"discussions":[{"author":{"id":1043325,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/c9xpiakQ3OC1AlfCeW03lLnnb7mj5v35Hib8YDs66zpnVib2n2qFichFmFp2Ec4QDPR0dKh38MkBBLyD3bE4NiaanZQ/132","nickname":"龙晓","note":"","ucode":"FAF34F1C65D103","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362606,"discussion_content":"change buffer只是缓存二级索引更新，一级的主键索引和行数据还是要读入磁盘的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1616991015,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161442,"user_name":"赵加兴","can_delete":false,"product_type":"c1","uid":1117072,"ip_address":"","ucode":"B5730C4175B05D","user_header":"https://static001.geekbang.org/account/avatar/00/11/0b/90/f161b09a.jpg","comment_is_top":false,"comment_ctime":1576206861,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576206861","product_id":100020801,"comment_content":"通用分区策略和本地分区策略的具体内容没有搜索到，这个在哪里能看到呢？","like_count":0},{"had_liked":false,"id":155062,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1574642640,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574642640","product_id":100020801,"comment_content":"老师，分区后，事务以及jion语句需要修改吗","like_count":0},{"had_liked":false,"id":128941,"user_name":"加载中……","can_delete":false,"product_type":"c1","uid":1366948,"ip_address":"","ucode":"3E59A0A0784D0A","user_header":"https://static001.geekbang.org/account/avatar/00/14/db/a4/191be6ad.jpg","comment_is_top":false,"comment_ctime":1566989193,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566989193","product_id":100020801,"comment_content":"老师好，请教个问题，文章中说“单表或者单分区的数据一千万行，只要没有特别大的索引，对于现在的硬件能力来说都已经是小表了”。其中的&quot;现在的硬件能力&quot;在这句话的场景下大概指的是个什么样的具体配置？<br>","like_count":0},{"had_liked":false,"id":113745,"user_name":"northloki","can_delete":false,"product_type":"c1","uid":1102116,"ip_address":"","ucode":"1D944AAF0AA046","user_header":"https://static001.geekbang.org/account/avatar/00/10/d1/24/5a902c55.jpg","comment_is_top":false,"comment_ctime":1563150797,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563150797","product_id":100020801,"comment_content":"老师，有些历史数据会专门放在历史表中，每天定期把最新数据归档到历史表，其它时候历史表仅支持不太频繁的查询。这种场景是使用分区表还是分库分表合适？","like_count":0},{"had_liked":false,"id":95234,"user_name":"龙须面","can_delete":false,"product_type":"c1","uid":1303391,"ip_address":"","ucode":"6D091EDFD72F5C","user_header":"https://static001.geekbang.org/account/avatar/00/13/e3/5f/49276cd3.jpg","comment_is_top":false,"comment_ctime":1557994114,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557994114","product_id":100020801,"comment_content":"mysql版本  5.7.22，按照老师的步骤没有发生block啊  innodb引擎","like_count":0},{"had_liked":false,"id":80167,"user_name":"Invictus_CD ","can_delete":false,"product_type":"c1","uid":1302400,"ip_address":"","ucode":"4B6BCCE71032D4","user_header":"https://static001.geekbang.org/account/avatar/00/13/df/80/f5d91c66.jpg","comment_is_top":false,"comment_ctime":1553612289,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553612289","product_id":100020801,"comment_content":"好像5.7.22以后分区多了主从延迟那个问题解决了。5.6.23是有这个问题","like_count":0},{"had_liked":false,"id":70352,"user_name":"启程","can_delete":false,"product_type":"c1","uid":1158728,"ip_address":"","ucode":"AD30380E87CE9C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/NjF5F2UZEbd3iclteRmVL6aRlW9wv9GHOte3QFjF4cUvb5hWeNZBPmaNrlJJbSUdqTMF6MmI10icMLuDQOsb6ERA/132","comment_is_top":false,"comment_ctime":1551082376,"is_pvip":false,"replies":[{"id":"25201","content":"这个还是得看不同的语句的执行次数哈<br><br>如果从语句类型上看，可以考虑加上(b,c)、(b,d)这两个联合索引","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1551148053,"ip_address":"","comment_id":70352,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551082376","product_id":100020801,"comment_content":"老师，你好，请教你个分区表多条件查询建索引的问题；<br>表A,<br>列a,b,c,d,e,f,g,h   (其中b是datetime，a是uuid,其余是varchar)<br>主键索引，(b,a),按月分区<br>查询情况1：<br>where b&gt;=? and b&lt;=? order by b desc limit 500;<br>查询情况2:<br>where b&gt;=? and b&lt;=? and c in(?) order by b desc limit 500;<br>查询情况3：<br>where b&gt;=? and b&lt;=? and d in(?) and e in(?) order by b desc limit 500;<br>查询情况4：<br>where b&gt;=? and b&lt;=? and c in(?) and d in(?) and e in(?) order by b desc limit 500;<br>自己尝试建过不少索引，效果不是很好，请问老师，我要怎么建索引？？？","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440580,"discussion_content":"这个还是得看不同的语句的执行次数哈\n\n如果从语句类型上看，可以考虑加上(b,c)、(b,d)这两个联合索引","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551148053,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":69010,"user_name":"夹心面包","can_delete":false,"product_type":"c1","uid":1301957,"ip_address":"","ucode":"002BBA49D83D17","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJCscgdVibmoPyRLRaicvk6rjTJxePZ6VFHvGjUQvtfhCS6kO4OZ1AVibbhNGKlWZmpEFf2yA6ptsqHw/132","comment_is_top":false,"comment_ctime":1550644591,"is_pvip":false,"replies":[{"id":"24486","content":"“但是auto_increment列必须是第一列” 可以不是哦","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1550652609,"ip_address":"","comment_id":69010,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1550644591","product_id":100020801,"comment_content":"<br>我觉得老师的问题可以提炼为 Mysql复合主键中自增长字段设置问题<br>复合索引可以包含一个auto_increment,但是auto_increment列必须是第一列。这样插入的话,只需要指定非自增长的列<br>语法 alter table test1  change column id id int  auto_increment;","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439911,"discussion_content":"“但是auto_increment列必须是第一列” 可以不是哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550652609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}