{"id":120014,"title":"23 | 单线程模型怎么保证UI运行流畅？","content":"<p>你好，我是陈航。</p><p>在上一篇文章中，我带你一起学习了如何在Flutter中实现动画。对于组件动画，Flutter将动画的状态与渲染进行了分离，因此我们需要使用动画曲线生成器Animation、动画状态控制器AnimationController与动画进度监听器一起配合完成动画更新；而对于跨页面动画，Flutter提供了Hero组件，可以实现共享元素变换的页面切换效果。</p><p>在之前的章节里，我们介绍了很多Flutter框架出色的渲染和交互能力。支撑起这些复杂的能力背后，实际上是基于单线程模型的Dart。那么，与原生Android和iOS的多线程机制相比，单线程的Dart如何从语言设计层面和代码运行机制上保证Flutter UI的流畅性呢？</p><p>因此今天，我会通过几个小例子，循序渐进地向你介绍Dart语言的Event Loop处理机制、异步处理和并发编程的原理和使用方法，从语言设计和实践层面理解Dart单线程模型下的代码运行本质，从而懂得后续如何在工作中使用Future与Isolate，优化我们的项目。</p><h2>Event Loop机制</h2><p>首先，我们需要建立这样一个概念，那就是<strong>Dart是单线程的</strong>。那单线程意味着什么呢？这意味着Dart代码是有序的，按照在main函数出现的次序一个接一个地执行，不会被其他代码中断。另外，作为支持Flutter这个UI框架的关键技术，Dart当然也支持异步。需要注意的是，<strong>单线程和异步并不冲突。</strong></p><!-- [[[read_end]]] --><p>那为什么单线程也可以异步？</p><p>这里有一个大前提，那就是我们的App绝大多数时间都在等待。比如，等用户点击、等网络请求返回、等文件IO结果，等等。而这些等待行为并不是阻塞的。比如说，网络请求，Socket本身提供了select模型可以异步查询；而文件IO，操作系统也提供了基于事件的回调机制。</p><p>所以，基于这些特点，单线程模型可以在等待的过程中做别的事情，等真正需要响应结果了，再去做对应的处理。因为等待过程并不是阻塞的，所以给我们的感觉就像是同时在做多件事情一样。但其实始终只有一个线程在处理你的事情。</p><p>等待这个行为是通过Event Loop驱动的。事件队列Event Queue会把其他平行世界（比如Socket）完成的，需要主线程响应的事件放入其中。像其他语言一样，Dart也有一个巨大的事件循环，在不断的轮询事件队列，取出事件（比如，键盘事件、I\\O事件、网络事件等），在主线程同步执行其回调函数，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/0c/ec/0cb6e6d34295cef460e48d139bc944ec.png?wh=880*582\" alt=\"\"></p><center><span class=\"reference\">图1 简化版Event Loop</span></center><h2>异步任务</h2><p>事实上，图1的Event Loop示意图只是一个简化版。在Dart中，实际上有两个队列，一个事件队列（Event Queue），另一个则是微任务队列（Microtask Queue）。在每一次事件循环中，Dart总是先去第一个微任务队列中查询是否有可执行的任务，如果没有，才会处理后续的事件队列的流程。</p><p>所以，Event Loop完整版的流程图，应该如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/70/bc/70dc4e1c222ddfaee8aa06df85c22bbc.png?wh=902*678\" alt=\"\"></p><center><span class=\"reference\">图2 Microtask Queue与Event Queue</span></center><p>接下来，我们分别看一下这两个队列的特点和使用场景吧。</p><p>首先，我们看看微任务队列。微任务顾名思义，表示一个短时间内就会完成的异步任务。从上面的流程图可以看到，微任务队列在事件循环中的优先级是最高的，只要队列中还有任务，就可以一直霸占着事件循环。</p><p>微任务是由scheduleMicroTask建立的。如下所示，这段代码会在下一个事件循环中输出一段字符串：</p><pre><code>scheduleMicrotask(() =&gt; print('This is a microtask'));\n</code></pre><p>不过，一般的异步任务通常也很少必须要在事件队列前完成，所以也不需要太高的优先级，因此我们通常很少会直接用到微任务队列，就连Flutter内部，也只有7处用到了而已（比如，手势识别、文本输入、滚动视图、保存页面效果等需要高优执行任务的场景）。</p><p>异步任务我们用的最多的还是优先级更低的Event Queue。比如，I/O、绘制、定时器这些异步事件，都是通过事件队列驱动主线程执行的。</p><p><strong>Dart为Event Queue的任务建立提供了一层封装，叫作Future</strong>。从名字上也很容易理解，它表示一个在未来时间才会完成的任务。</p><p>把一个函数体放入Future，就完成了从同步任务到异步任务的包装。Future还提供了链式调用的能力，可以在异步任务执行完毕后依次执行链路上的其他函数体。</p><p>接下来，我们看一个具体的代码示例：分别声明两个异步任务，在下一个事件循环中输出一段字符串。其中第二个任务执行完毕之后，还会继续输出另外两段字符串：</p><pre><code>Future(() =&gt; print('Running in Future 1'));//下一个事件循环输出字符串\n\nFuture(() =&gt; print(‘Running in Future 2'))\n  .then((_) =&gt; print('and then 1'))\n  .then((_) =&gt; print('and then 2’));//上一个事件循环结束后，连续输出三段字符串\n</code></pre><p>当然，这两个Future异步任务的执行优先级比微任务的优先级要低。</p><p>正常情况下，一个Future异步任务的执行是相对简单的：在我们声明一个Future时，Dart会将异步任务的函数执行体放入事件队列，然后立即返回，后续的代码继续同步执行。而当同步执行的代码执行完毕后，事件队列会按照加入事件队列的顺序（即声明顺序），依次取出事件，最后同步执行Future的函数体及后续的then。</p><p>这意味着，<strong>then与Future函数体共用一个事件循环</strong>。而如果Future有多个then，它们也会按照链式调用的先后顺序同步执行，同样也会共用一个事件循环。</p><p>如果Future执行体已经执行完毕了，但你又拿着这个Future的引用，往里面加了一个then方法体，这时Dart会如何处理呢？面对这种情况，Dart会将后续加入的then方法体放入微任务队列，尽快执行。</p><p>下面的代码演示了Future的执行规则，即，先加入事件队列，或者先声明的任务先执行；then在Future结束后立即执行。</p><ul>\n<li>在第一个例子中，由于f1比f2先声明，因此会被先加入事件队列，所以f1比f2先执行；</li>\n<li>在第二个例子中，由于Future函数体与then共用一个事件循环，因此f3执行后会立刻同步执行then 3；</li>\n<li>最后一个例子中，Future函数体是null，这意味着它不需要也没有事件循环，因此后续的then也无法与它共享。在这种场景下，Dart会把后续的then放入微任务队列，在下一次事件循环中执行。</li>\n</ul><pre><code>//f1比f2先执行\nFuture(() =&gt; print('f1'));\nFuture(() =&gt; print('f2'));\n\n//f3执行后会立刻同步执行then 3\nFuture(() =&gt; print('f3')).then((_) =&gt; print('then 3'));\n\n//then 4会加入微任务队列，尽快执行\nFuture(() =&gt; null).then((_) =&gt; print('then 4'));\n</code></pre><p>说了这么多规则，可能大家并没有完全记住。那我们通过一个综合案例，来把之前介绍的各个执行规则都串起来，再集中学习一下。</p><p>在下面的例子中，我们依次声明了若干个异步任务Future，以及微任务。在其中的一些Future内部，我们又内嵌了Future与microtask的声明：</p><pre><code>Future(() =&gt; print('f1'));//声明一个匿名Future\nFuture fx = Future(() =&gt;  null);//声明Future fx，其执行体为null\n\n//声明一个匿名Future，并注册了两个then。在第一个then回调里启动了一个微任务\nFuture(() =&gt; print('f2')).then((_) {\n  print('f3');\n  scheduleMicrotask(() =&gt; print('f4'));\n}).then((_) =&gt; print('f5'));\n\n//声明了一个匿名Future，并注册了两个then。第一个then是一个Future\nFuture(() =&gt; print('f6'))\n  .then((_) =&gt; Future(() =&gt; print('f7')))\n  .then((_) =&gt; print('f8'));\n\n//声明了一个匿名Future\nFuture(() =&gt; print('f9'));\n\n//往执行体为null的fx注册了了一个then\nfx.then((_) =&gt; print('f10'));\n\n//启动一个微任务\nscheduleMicrotask(() =&gt; print('f11'));\nprint('f12');\n</code></pre><p>运行一下，上述各个异步任务会依次打印其内部执行结果：</p><pre><code>f12\nf11\nf1\nf10\nf2\nf3\nf5\nf4\nf6\nf9\nf7\nf8\n</code></pre><p>看到这儿，你可能已经懵了。别急，我们先来看一下这段代码执行过程中，Event Queue与Microtask Queue中的变化情况，依次分析一下它们的执行顺序为什么会是这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/8a/8b/8a1106a01613fa999a35911fc5922e8b.gif?wh=800*540\" alt=\"\"></p><center><span class=\"reference\">图3 Event Queue与Microtask Queue变化示例</span></center><ul>\n<li>因为其他语句都是异步任务，所以先打印f12。</li>\n<li>剩下的异步任务中，微任务队列优先级最高，因此随后打印f11；然后按照Future声明的先后顺序，打印f1。</li>\n<li>随后到了fx，由于fx的执行体是null，相当于执行完毕了，Dart将fx的then放入微任务队列，由于微任务队列的优先级最高，因此fx的then还是会最先执行，打印f10。</li>\n<li>然后到了fx下面的f2，打印f2，然后执行then，打印f3。f4是一个微任务，要到下一个事件循环才执行，因此后续的then继续同步执行，打印f5。本次事件循环结束，下一个事件循环取出f4这个微任务，打印f4。</li>\n<li>然后到了f2下面的f6，打印f6，然后执行then。这里需要注意的是，这个then是一个Future异步任务，因此这个then，以及后续的then都被放入到事件队列中了。</li>\n<li>f6下面还有f9，打印f9。</li>\n<li>最后一个事件循环，打印f7，以及后续的f8。</li>\n</ul><p>上面的代码很是烧脑，万幸我们平时开发Flutter时一般不会遇到这样奇葩的写法，所以你大可放心。你只需要记住一点：<strong>then会在Future函数体执行完毕后立刻执行，无论是共用同一个事件循环还是进入下一个微任务。</strong></p><p>在深入理解Future异步任务的执行规则之后，我们再来看看怎么封装一个异步函数。</p><h2>异步函数</h2><p>对于一个异步函数来说，其返回时内部执行动作并未结束，因此需要返回一个Future对象，供调用者使用。调用者根据Future对象，来决定：是在这个Future对象上注册一个then，等Future的执行体结束了以后再进行异步处理；还是一直同步等待Future执行体结束。</p><p>对于异步函数返回的Future对象，如果调用者决定同步等待，则需要在调用处使用await关键字，并且在调用处的函数体使用async关键字。</p><p>在下面的例子中，异步方法延迟3秒返回了一个Hello 2019，在调用处我们使用await进行持续等待，等它返回了再打印：</p><pre><code>//声明了一个延迟3秒返回Hello的Future，并注册了一个then返回拼接后的Hello 2019\nFuture&lt;String&gt; fetchContent() =&gt; \n  Future&lt;String&gt;.delayed(Duration(seconds:3), () =&gt; &quot;Hello&quot;)\n    .then((x) =&gt; &quot;$x 2019&quot;);\n\n  main() async{\n    print(await fetchContent());//等待Hello 2019的返回\n  }\n</code></pre><p>也许你已经注意到了，我们在使用await进行等待的时候，在等待语句的调用上下文函数main加上了async关键字。为什么要加这个关键字呢？</p><p>因为<strong>Dart中的await并不是阻塞等待，而是异步等待</strong>。Dart会将调用体的函数也视作异步函数，将等待语句的上下文放入Event Queue中，一旦有了结果，Event Loop就会把它从Event Queue中取出，等待代码继续执行。</p><p>接下来，为了帮助你加深印象，我准备了两个具体的案例。</p><p>我们先来看下这段代码。第二行的then执行体f2是一个Future，为了等它完成再进行下一步操作，我们使用了await，期望打印结果为f1、f2、f3、f4：</p><pre><code>Future(() =&gt; print('f1'))\n  .then((_) async =&gt; await Future(() =&gt; print('f2')))\n  .then((_) =&gt; print('f3'));\nFuture(() =&gt; print('f4'));\n</code></pre><p>实际上，当你运行这段代码时就会发现，打印出来的结果其实是f1、f4、f2、f3！</p><p>我来给你分析一下这段代码的执行顺序：</p><ul>\n<li>按照任务的声明顺序，f1和f4被先后加入事件队列。</li>\n<li>f1被取出并打印；然后到了then。then的执行体是个future f2，于是放入Event Queue。然后把await也放到Event Queue里。</li>\n<li>这个时候要注意了，Event Queue里面还有一个f4，我们的await并不能阻塞f4的执行。因此，Event Loop先取出f4，打印f4；然后才能取出并打印f2，最后把等待的await取出，开始执行后面的f3。</li>\n</ul><p>由于await是采用事件队列的机制实现等待行为的，所以比它先在事件队列中的f4并不会被它阻塞。</p><p>接下来，我们再看另一个例子：在主函数调用一个异步函数去打印一段话，而在这个异步函数中，我们使用await与async同步等待了另一个异步函数返回字符串：</p><pre><code>//声明了一个延迟2秒返回Hello的Future，并注册了一个then返回拼接后的Hello 2019\nFuture&lt;String&gt; fetchContent() =&gt; \n  Future&lt;String&gt;.delayed(Duration(seconds:2), () =&gt; &quot;Hello&quot;)\n    .then((x) =&gt; &quot;$x 2019&quot;);\n//异步函数会同步等待Hello 2019的返回，并打印\nfunc() async =&gt; print(await fetchContent());\n\nmain() {\n  print(&quot;func before&quot;);\n  func();\n  print(&quot;func after&quot;);\n}\n</code></pre><p>运行这段代码，我们发现最终输出的顺序其实是“func before”“func after”“Hello 2019”。func函数中的等待语句似乎没起作用。这是为什么呢？</p><p>同样，我来给你分析一下这段代码的执行顺序：</p><ul>\n<li>首先，第一句代码是同步的，因此先打印“func before”。</li>\n<li>然后，进入func函数，func函数调用了异步函数fetchContent，并使用await进行等待，因此我们把fetchContent、await语句的上下文函数func先后放入事件队列。</li>\n<li>await的上下文函数并不包含调用栈，因此func后续代码继续执行，打印“func after”。</li>\n<li>2秒后，fetchContent异步任务返回“Hello 2019”，于是func的await也被取出，打印“Hello 2019”。</li>\n</ul><p>通过上述分析，你发现了什么现象？那就是await与async只对调用上下文的函数有效，并不向上传递。因此对于这个案例而言，func是在异步等待。如果我们想在main函数中也同步等待，需要在调用异步函数时也加上await，在main函数也加上async。</p><p>经过上面两个例子的分析，你应该已经明白await与async是如何配合，完成等待工作的了吧。</p><p>介绍完了异步，我们再来看在Dart中，如何通过多线程实现并发。</p><h2>Isolate</h2><p>尽管Dart是基于单线程模型的，但为了进一步利用多核CPU，将CPU密集型运算进行隔离，Dart也提供了多线程机制，即Isolate。在Isolate中，资源隔离做得非常好，每个Isolate都有自己的Event Loop与Queue，<strong>Isolate之间不共享任何资源，只能依靠消息机制通信，因此也就没有资源抢占问题</strong>。</p><p>和其他语言一样，Isolate的创建非常简单，我们只要给定一个函数入口，创建时再传入一个参数，就可以启动Isolate了。如下所示，我们声明了一个Isolate的入口函数，然后在main函数中启动它，并传入了一个字符串参数：</p><pre><code>doSth(msg) =&gt; print(msg);\n\nmain() {\n  Isolate.spawn(doSth, &quot;Hi&quot;);\n  ...\n}\n</code></pre><p>但更多情况下，我们的需求并不会这么简单，不仅希望能并发，还希望Isolate在并发执行的时候告知主Isolate当前的执行结果。</p><p>对于执行结果的告知，Isolate通过发送管道（SendPort）实现消息通信机制。我们可以在启动并发Isolate时将主Isolate的发送管道作为参数传给它，这样并发Isolate就可以在任务执行完毕后利用这个发送管道给我们发消息了。</p><p>下面我们通过一个例子来说明：在主Isolate里，我们创建了一个并发Isolate，在函数入口传入了主Isolate的发送管道，然后等待并发Isolate的回传消息。在并发Isolate中，我们用这个管道给主Isolate发了一个Hello字符串：</p><pre><code>Isolate isolate;\n\nstart() async {\n  ReceivePort receivePort= ReceivePort();//创建管道\n  //创建并发Isolate，并传入发送管道\n  isolate = await Isolate.spawn(getMsg, receivePort.sendPort);\n  //监听管道消息\n  receivePort.listen((data) {\n    print('Data：$data');\n    receivePort.close();//关闭管道\n    isolate?.kill(priority: Isolate.immediate);//杀死并发Isolate\n    isolate = null;\n  });\n}\n//并发Isolate往管道发送一个字符串\ngetMsg(sendPort) =&gt; sendPort.send(&quot;Hello&quot;);\n</code></pre><p>这里需要注意的是，在Isolate中，发送管道是单向的：我们启动了一个Isolate执行某项任务，Isolate执行完毕后，发送消息告知我们。如果Isolate执行任务时，需要依赖主Isolate给它发送参数，执行完毕后再发送执行结果给主Isolate，这样<strong>双向通信的场景我们如何实现呢</strong>？答案也很简单，让并发Isolate也回传一个发送管道即可。</p><p>接下来，我们以一个<strong>并发计算阶乘</strong>的例子来说明如何实现双向通信。</p><p>在下面的例子中，我们创建了一个异步函数计算阶乘。在这个异步函数内，创建了一个并发Isolate，传入主Isolate的发送管道；并发Isolate也回传一个发送管道；主Isolate收到回传管道后，发送参数N给并发Isolate，然后立即返回一个Future；并发Isolate用参数N，调用同步计算阶乘的函数，返回执行结果；最后，主Isolate打印了返回结果：</p><pre><code>//并发计算阶乘\nFuture&lt;dynamic&gt; asyncFactoriali(n) async{\n  final response = ReceivePort();//创建管道\n  //创建并发Isolate，并传入管道\n  await Isolate.spawn(_isolate,response.sendPort);\n  //等待Isolate回传管道\n  final sendPort = await response.first as SendPort;\n  //创建了另一个管道answer\n  final answer = ReceivePort();\n  //往Isolate回传的管道中发送参数，同时传入answer管道\n  sendPort.send([n,answer.sendPort]);\n  return answer.first;//等待Isolate通过answer管道回传执行结果\n}\n\n//Isolate函数体，参数是主Isolate传入的管道\n_isolate(initialReplyTo) async {\n  final port = ReceivePort();//创建管道\n  initialReplyTo.send(port.sendPort);//往主Isolate回传管道\n  final message = await port.first as List;//等待主Isolate发送消息(参数和回传结果的管道)\n  final data = message[0] as int;//参数\n  final send = message[1] as SendPort;//回传结果的管道 \n  send.send(syncFactorial(data));//调用同步计算阶乘的函数回传结果\n}\n\n//同步计算阶乘\nint syncFactorial(n) =&gt; n &lt; 2 ? n : n * syncFactorial(n-1);\nmain() async =&gt; print(await asyncFactoriali(4));//等待并发计算阶乘结果\n</code></pre><p>看完这段代码你是什么感觉呢？我们只是为了并发计算一个阶乘，这样是不是太繁琐了？</p><p>没错，确实太繁琐了。在Flutter中，像这样执行并发计算任务我们可以采用更简单的方式。Flutter提供了支持并发计算的compute函数，其内部对Isolate的创建和双向通信进行了封装抽象，屏蔽了很多底层细节，我们在调用时只需要传入函数入口和函数参数，就能够实现并发计算和消息通知。</p><p>我们试着用compute函数改造一下并发计算阶乘的代码：</p><pre><code>//同步计算阶乘\nint syncFactorial(n) =&gt; n &lt; 2 ? n : n * syncFactorial(n-1);\n//使用compute函数封装Isolate的创建和结果的返回\nmain() async =&gt; print(await compute(syncFactorial, 4));\n</code></pre><p>可以看到，用compute函数改造以后，整个代码就变成了两行，现在并发计算阶乘的代码看起来就清爽多了。</p><h2>总结</h2><p>好了，今天关于Dart的异步与并发机制、实现原理的分享就到这里了，我们来简单回顾一下主要内容。</p><p>Dart是单线程的，但通过事件循环可以实现异步。而Future是异步任务的封装，借助于await与async，我们可以通过事件循环实现非阻塞的同步等待；Isolate是Dart中的多线程，可以实现并发，有自己的事件循环与Queue，独占资源。Isolate之间可以通过消息机制进行单向通信，这些传递的消息通过对方的事件循环驱动对方进行异步处理。</p><p>在UI编程过程中，异步和多线程是两个相伴相生的名词，也是很容易混淆的概念。对于异步方法调用而言，代码不需要等待结果的返回，而是通过其他手段（比如通知、回调、事件循环或多线程）在后续的某个时刻主动（或被动）地接收执行结果。</p><p>因此，从辩证关系上来看，异步与多线程并不是一个同等关系：异步是目的，多线程只是我们实现异步的一个手段之一。而在Flutter中，借助于UI框架提供的事件循环，我们可以不用阻塞的同时等待多个异步任务，因此并不需要开多线程。我们一定要记住这一点。</p><p>我把今天分享所涉及到的知识点打包到了<a href=\"https://github.com/cyndibaby905/23_dart_async\">GitHub</a>中，你可以下载下来，反复运行几次，加深理解。</p><h2>思考题</h2><p>最后，我给你留下两道思考题吧。</p><ol>\n<li>在通过并发Isolate计算阶乘的例子中，我在asyncFactoriali方法里先后发给了并发Isolate两个SendPort。你能否解释下这么做的原因？可以只发一个SendPort吗？</li>\n<li>请改造以下代码，在不改变整体异步结构的情况下，实现输出结果为f1、f2、f3、f4。</li>\n</ol><pre><code>Future(() =&gt; print('f1'))\n  .then((_) async =&gt; await Future(() =&gt; print('f2')))\n  .then((_) =&gt; print('f3'));\nFuture(() =&gt; print('f4'));\n</code></pre><p>欢迎你在评论区给我留言分享你的观点，我会在下一篇文章中等待你！感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p><p></p>","comments":[{"had_liked":false,"id":145545,"user_name":"jerry","can_delete":false,"product_type":"c1","uid":1032859,"ip_address":"","ucode":"525F24CD2FBB0F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c2/9b/75ba46ad.jpg","comment_is_top":false,"comment_ctime":1572313273,"is_pvip":false,"replies":[{"id":"56244","content":"我们所说的单线程指的是主Isolate。而GPU绘制指令有单独的线程执行，跟主Isolate无关。事实上Flutter提供了4种task runner，有独立的线程去运行专属的任务：<br>1.Platform Task Runner：处理来自平台（Android&#47;iOS）的消息<br>2.UI Task Runner：执行渲染逻辑、处理native plugin的消息、timer、microtask、异步I&#47;O操作处理等<br>3.GPU Task Runner：执行GPU指令<br>4.IO Task Runner：执行I&#47;O任务<br>除此之外，操作系统本身也提供了大量异步并发机制，可以利用多线程去执行任务（比如socket），我们在主Isolate中无需关心（如果真想主动创建并发任务也可以）","user_name":"作者回复","user_name_real":"土豆盒子","uid":"1088582","ctime":1572345009,"ip_address":"","comment_id":145545,"utype":1}],"discussion_count":1,"race_medal":0,"score":"70291790009","product_id":100031001,"comment_content":"您好老师，单线程模型是指的事件队列模型，和绘制界面的线程是一个吗","like_count":17,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472457,"discussion_content":"我们所说的单线程指的是主Isolate。而GPU绘制指令有单独的线程执行，跟主Isolate无关。事实上Flutter提供了4种task runner，有独立的线程去运行专属的任务：\n1.Platform Task Runner：处理来自平台（Android/iOS）的消息\n2.UI Task Runner：执行渲染逻辑、处理native plugin的消息、timer、microtask、异步I/O操作处理等\n3.GPU Task Runner：执行GPU指令\n4.IO Task Runner：执行I/O任务\n除此之外，操作系统本身也提供了大量异步并发机制，可以利用多线程去执行任务（比如socket），我们在主Isolate中无需关心（如果真想主动创建并发任务也可以）","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572345009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136288,"user_name":"Geek_keyi","can_delete":false,"product_type":"c1","uid":1674102,"ip_address":"","ucode":"F085903C779D19","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJEDNglUOrnn3bWOByASEZjMSGZl9EEiby6Z2hfQdCFLuP2FbphsEbSGEQyA1VmmhwqCPiaiaguHMoZQ/132","comment_is_top":false,"comment_ctime":1569403594,"is_pvip":false,"replies":[{"id":"52456","content":"文件I&#47;O和网络调用并不是在Dart层做的，而是由操作系统提供的异步线程，他俩把活儿干完之后把结果刚到队列中，Dart代码只是执行一个简单的读动作。<br>","user_name":"作者回复","user_name_real":"土豆盒子","uid":"1088582","ctime":1569501570,"ip_address":"","comment_id":136288,"utype":1}],"discussion_count":5,"race_medal":0,"score":"57403978442","product_id":100031001,"comment_content":"对Dart单线程模型理解还是迷惑，请教一下：假如有一个任务（读写文件或者网络）耗时10秒，并且加入到了事件任务队列中，执行单这个任务的时候不就把线程卡主吗？","like_count":14,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468546,"discussion_content":"文件I/O和网络调用并不是在Dart层做的，而是由操作系统提供的异步线程，他俩把活儿干完之后把结果刚到队列中，Dart代码只是执行一个简单的读动作。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569501570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1313651,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0b/73/4f1c9676.jpg","nickname":"舒大飞","note":"","ucode":"5CC2E0F8C40E38","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24307,"discussion_content":"老师，还是有点困惑，希望解答下，你说的:文件IO和网络调用并不是在dart层做的，而是由操作系统提供的异步线程，这句话怎么理解，是因为dart里的文件IO和网络调用是这样封装实现的吗?如果不是，那其它语言，比如Android开发中为什么要单独开线程去做IO和网络请求，Android开发中的IO和网络请求不是操作系统提供的异步线程吗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1570089977,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1792683,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/5a/ab/bda5b14d.jpg","nickname":"Xingjian","note":"","ucode":"9047292CB92A13","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1313651,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0b/73/4f1c9676.jpg","nickname":"舒大飞","note":"","ucode":"5CC2E0F8C40E38","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":110773,"discussion_content":"Dart的文件IO和网络库都是用异步(Future and Stream)实现的，这些操作在底层还是通过OS的系统调用来实现，可以是同步也可以是异步，这个与平台OS对具体操作的支持有关；不过不论OS如何实现，提供给Dart的是异步接口，非阻塞的，这样开发人员就不需要自己去起独立线程（或isolate）去处理里，这个与Node类似。Android所使用的Java语言也有类似的支持，如早期的async task, 以及后来的各种库（如ion），不需要自己直接去起线程来处理异步任务，除非你愿意。毕竟Java是个较为早期的语言，而异步编程兴起较晚，因此Java语言本身在这方面的支持不是很统一。注意，OS的异步支持和语言的异步编程不是一回事，虽然是一脉相承的。有没有OS的异步支持，语言都可以支持异步编程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577756113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":24307,"ip_address":""},"score":110773,"extra":""},{"author":{"id":1792683,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/5a/ab/bda5b14d.jpg","nickname":"Xingjian","note":"","ucode":"9047292CB92A13","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1313651,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0b/73/4f1c9676.jpg","nickname":"舒大飞","note":"","ucode":"5CC2E0F8C40E38","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":110794,"discussion_content":"另外，一般来说，语言级的异步编程强调“单线程”下的异步IO任务支持，此时并不需要另起别的执行体，因为IO操作往往只需发出请求，然后都结果即可，也就是说，并不需要额外的异步线程去执行耗时操作。OS本身只是提供系统调用API，也不会自己起线程。如果你用Android的ion库，也是如此。而对于通用的耗时计算任务，例如求解阶乘，异步编程帮助不大，而应该另起执行体比如async task, isolate等进行并发操作。只不过现在有的并发编程API把这两类混在一起了，比如有的库把异步和并发任务都用coroutine来包装。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577757406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":24307,"ip_address":""},"score":110794,"extra":""}]},{"author":{"id":1330032,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4b/70/33137826.jpg","nickname":"沈杰","note":"","ucode":"17E314B07844F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556818,"discussion_content":"那不是跟android的UI线程一样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647522812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253477,"user_name":"许先森","can_delete":false,"product_type":"c1","uid":1795371,"ip_address":"","ucode":"1F42D4A6B5C6AF","user_header":"https://static001.geekbang.org/account/avatar/00/1b/65/2b/446ef7b6.jpg","comment_is_top":false,"comment_ctime":1602749472,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23077585952","product_id":100031001,"comment_content":"“然后到了 f2 下面的 f6，打印 f6，然后执行 then。这里需要注意的是，这个 then 是一个 Future 异步任务，因此这个 then，以及后续的 then 都被放入到事件队列中了。”<br>老师你好，这句话中后半段解释的不准确。应该是：<br> then函数会返回future，所以用=&gt;的写法时， 新创建的future会被then返回，第二个then的调用者就是新的future对象，  所以第二个then就不跟着原先的future 而是跟着它的新future了。<br>如果把=&gt;换成大括号，此时第二个then还是跟着原先的future，和新future无关。","like_count":6,"discussions":[{"author":{"id":1924308,"avatar":"","nickname":"张永帅","note":"","ucode":"5D7E19F07919FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337192,"discussion_content":"牛逼啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608820330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126401,"user_name":"吴小安","can_delete":false,"product_type":"c1","uid":1371398,"ip_address":"","ucode":"EDF8E04F867069","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqr5ibqxYwcSgqPA7s49MZb1vEKKXT4mPTojwiclXkJf3ug26NuzTa6A5gbicR2rAUHdEkUAn13Rr2KQ/132","comment_is_top":false,"comment_ctime":1566381535,"is_pvip":false,"replies":[{"id":"47652","content":"无需担心，我们说的单线程其实是针对主Isolate的。事实上Flutter提供了4种task runner，他们有独立的线程去运行专属的任务：<br>1.Platform Task Runner：处理来自平台（Android&#47;iOS）的消息<br>2.UI Task Runner：执行渲染逻辑、处理native plugin的消息、timer、microtask、异步I&#47;O操作处理等<br>3.GPU Task Runner：执行GPU指令<br>4.IO Task Runner：执行I&#47;O任务<br>这些特定任务的执行都是固定的套路，另外操作系统本身也提供了大量异步并发机制，可以利用多线程去执行任务（比如socket），我们在主Isolate中无需关心（如果真想主动创建并发任务也可以），因此说基于主Isolate的Flutter是单线程模型的。","user_name":"作者回复","user_name_real":"土豆盒子","uid":"1088582","ctime":1566898641,"ip_address":"","comment_id":126401,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18746250719","product_id":100031001,"comment_content":"现在手机都是多核，使用future执行异步任务都是放在当前线程，而要在其他线程执行就要这么麻烦，这样大部分人写的异步任务都发挥不了多核的性能，是不是有点浪费？","like_count":4,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463973,"discussion_content":"无需担心，我们说的单线程其实是针对主Isolate的。事实上Flutter提供了4种task runner，他们有独立的线程去运行专属的任务：\n1.Platform Task Runner：处理来自平台（Android/iOS）的消息\n2.UI Task Runner：执行渲染逻辑、处理native plugin的消息、timer、microtask、异步I/O操作处理等\n3.GPU Task Runner：执行GPU指令\n4.IO Task Runner：执行I/O任务\n这些特定任务的执行都是固定的套路，另外操作系统本身也提供了大量异步并发机制，可以利用多线程去执行任务（比如socket），我们在主Isolate中无需关心（如果真想主动创建并发任务也可以），因此说基于主Isolate的Flutter是单线程模型的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566898641,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1752518,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/bd/c6/24e2c375.jpg","nickname":"YJY","note":"","ucode":"430E0ADCDA6C4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384076,"discussion_content":"老师我想请问下，像网络请求，请求完成后的异步回调，是怎么和主isolate线程进行交互的，底衬层逻辑是怎么样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626354946,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1008315,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/bb/323a3133.jpg","nickname":"下雨天","note":"","ucode":"816B3792ECC50A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1752518,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/bd/c6/24e2c375.jpg","nickname":"YJY","note":"","ucode":"430E0ADCDA6C4C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542333,"discussion_content":"同样是管道实现的消息机制吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640729567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":384076,"ip_address":""},"score":542333,"extra":""}]}]},{"had_liked":false,"id":206310,"user_name":"fwd","can_delete":false,"product_type":"c1","uid":1941288,"ip_address":"","ucode":"B8F43348AB0CA9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eooslLSbAgVTWKIEQbjUCbk0s3KuW0MC3T0GSbzh0zC5nIkfFHIwhyGyLOibricf2bhDdfgAoZc5kDQ/132","comment_is_top":false,"comment_ctime":1586838069,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10176772661","product_id":100031001,"comment_content":"第二题这样也是可以的吧。main() async {<br>  await Future(() =&gt; print(&#39;f1&#39;))<br>    .then((_) =&gt; Future(() =&gt; print(&#39;f2&#39;)))<br>    .then((_) =&gt; print(&#39;f3&#39;));<br>  Future(() =&gt; print(&#39;f4&#39;));<br>}","like_count":2},{"had_liked":false,"id":160491,"user_name":"Geek_20f143","can_delete":false,"product_type":"c1","uid":1701883,"ip_address":"","ucode":"5D97BD5FA4A26F","user_header":"","comment_is_top":false,"comment_ctime":1575963227,"is_pvip":false,"replies":[{"id":"63380","content":"你把第一个语句的then加个return再试试<br>    Future(() =&gt; print(&#39;a1&#39;))<br>        .then((_) {<br>      return Future(() =&gt; print(&#39;a2&#39;));<br>    }).then((_) =&gt; print(&#39;a3&#39;));","user_name":"作者回复","user_name_real":"土豆盒子","uid":"1088582","ctime":1577435911,"ip_address":"","comment_id":160491,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10165897819","product_id":100031001,"comment_content":"    Future(() =&gt; print(&#39;a1&#39;))<br>        .then((_) {<br>      Future(() =&gt; print(&#39;a2&#39;));<br>    }).then((_) =&gt; print(&#39;a3&#39;));<br><br><br>Future(() =&gt; print(&#39;a1&#39;))<br>        .then((_) =&gt; Future(() =&gt; print(&#39;a2&#39;)))<br>        .then((_) =&gt; print(&#39;a3&#39;));<br><br>老师,为什么第一部分打印顺序是a1 a3 a2... 第二部分打印顺序是a1 a2 a3<br>a2区别那部分不是只是语法糖吗?","like_count":3,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477390,"discussion_content":"你把第一个语句的then加个return再试试\n    Future(() =&amp;gt; print(&amp;#39;a1&amp;#39;))\n        .then((_) {\n      return Future(() =&amp;gt; print(&amp;#39;a2&amp;#39;));\n    }).then((_) =&amp;gt; print(&amp;#39;a3&amp;#39;));","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577435911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147010,"user_name":"GGL","can_delete":false,"product_type":"c1","uid":1215892,"ip_address":"","ucode":"AED10B8248D1E7","user_header":"https://static001.geekbang.org/account/avatar/00/12/8d/94/150dfe78.jpg","comment_is_top":false,"comment_ctime":1572762759,"is_pvip":false,"replies":[{"id":"59790","content":"单行箭头函数是Future，和函数体里有Future不是一回事","user_name":"作者回复","user_name_real":"土豆盒子","uid":"1088582","ctime":1574754403,"ip_address":"","comment_id":147010,"utype":1}],"discussion_count":7,"race_medal":0,"score":"10162697351","product_id":100031001,"comment_content":"&#47;&#47; 第一段<br>  Future(() =&gt; print(&#39;f6&#39;))<br>    .then((_) =&gt; Future(() =&gt; print(&#39;f7&#39;)))<br>    .then((_) =&gt; print(&#39;f8&#39;));<br><br>执行结果为：f6 f7 f8<br><br>  &#47;&#47; 第二段<br>  Future(() =&gt; print(&#39;f6&#39;))<br>  .then((_) {<br>      Future(() =&gt; print(&#39;f7&#39;));<br>    })<br>  .then((_) =&gt; print(&#39;f8&#39;));<br><br>执行结果为：f6 f8 f7<br><br>老师，上面这两段代码为什么执行结果不一样呢？","like_count":2,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473094,"discussion_content":"单行箭头函数是Future，和函数体里有Future不是一回事","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574754403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1044793,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f1/39/768503ad.jpg","nickname":"钱洋彪","note":"","ucode":"84FBB0E48FD885","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":218313,"discussion_content":"第一段代码是依次扔入event queue，第二段代码f6扔入event queue执行，第一个then将f7扔入event queue返回了null，导致第二个then 的f8实际是扔到微任务队列中的，所以f8早于f7打印。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1585646920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1879421,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/ad/7d/8e64b756.jpg","nickname":"广东大肠粉","note":"","ucode":"23BCDE1243CFD8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223217,"discussion_content":"把第二段 第二个then 里面加个return 就好了。=> 是简化只有一行代码的时候，直接作为返回值了\nFuture(() => print(&#39;f6&#39;))\n  .then((_) {\n      return Future(() => print(&#39;f7&#39;));\n    })\n  .then((_) => print(&#39;f8&#39;));","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1586189997,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1879421,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/ad/7d/8e64b756.jpg","nickname":"广东大肠粉","note":"","ucode":"23BCDE1243CFD8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223218,"discussion_content":"这里的 F7 我算是看明白了，就类似rxjava 里面flatmap 了一个 observable ,直接串行走下去了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586190349,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005356,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/2c/b0793828.jpg","nickname":"ssala","note":"","ucode":"CCD82C81756FC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":135160,"discussion_content":"第一段的代码中，第一个then执行以后，得到一个future对象，其封装的回调不应该在下个事件循环调用吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579073761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1701883,"avatar":"","nickname":"Geek_20f143","note":"","ucode":"5D97BD5FA4A26F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77984,"discussion_content":"我也是这个问题，没太懂单行箭头函数是Future的意思，这不是语法糖吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575963290,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1792683,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/5a/ab/bda5b14d.jpg","nickname":"Xingjian","note":"","ucode":"9047292CB92A13","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1701883,"avatar":"","nickname":"Geek_20f143","note":"","ucode":"5D97BD5FA4A26F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":110801,"discussion_content":"单行箭头函数的返回值是指向的Future，而在函数里，statement(分号)返回的是空(null)。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577757638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":77984,"ip_address":""},"score":110801,"extra":""}]}]},{"had_liked":false,"id":129296,"user_name":"lk","can_delete":false,"product_type":"c1","uid":1222590,"ip_address":"","ucode":"15CD5F7984668D","user_header":"https://static001.geekbang.org/account/avatar/00/12/a7/be/b036d9c8.jpg","comment_is_top":false,"comment_ctime":1567081784,"is_pvip":false,"replies":[{"id":"48123","content":"赞👍另外建议把await加上","user_name":"作者回复","user_name_real":"土豆盒子","uid":"1088582","ctime":1567097413,"ip_address":"","comment_id":129296,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10157016376","product_id":100031001,"comment_content":"Future(() =&gt; print(&#39;f1&#39;))<br>      .then((_) async =&gt;  scheduleMicrotask(() =&gt; print(&#39;f2&#39;)))<br>      .then((_) =&gt; print(&#39;f3&#39;));<br>  Future(() =&gt; print(&#39;f4&#39;));","like_count":2,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465387,"discussion_content":"赞👍另外建议把await加上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567097413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":298530,"user_name":"魅影","can_delete":false,"product_type":"c1","uid":1360952,"ip_address":"","ucode":"F26F7F1331A4DA","user_header":"https://static001.geekbang.org/account/avatar/00/14/c4/38/e0fefa2b.jpg","comment_is_top":false,"comment_ctime":1624178318,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5919145614","product_id":100031001,"comment_content":"&#47;&#47;then 4会加入微任务队列，尽快执行Future(() =&gt; null).then((_) =&gt; print(&#39;then 4&#39;));<br>为什么 Future 内部为空，就不将 then 的内容添加到 Event Queue 中，而是添加到 Microtask Queue 中？为什么这么设计","like_count":1},{"had_liked":false,"id":234692,"user_name":"小涛","can_delete":false,"product_type":"c1","uid":1454199,"ip_address":"","ucode":"F663DC8CF9E939","user_header":"https://static001.geekbang.org/account/avatar/00/16/30/77/14bf75fe.jpg","comment_is_top":false,"comment_ctime":1594774899,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5889742195","product_id":100031001,"comment_content":"老师，如何取消已经加入事件队列的任务呢？  比如之前await一个异步任务，现在想取消","like_count":1},{"had_liked":false,"id":159263,"user_name":"满大大","can_delete":false,"product_type":"c1","uid":1170022,"ip_address":"","ucode":"06DE739A6CE9EF","user_header":"https://static001.geekbang.org/account/avatar/00/11/da/66/5858322e.jpg","comment_is_top":false,"comment_ctime":1575593110,"is_pvip":true,"replies":[{"id":"63378","content":"就是await只等待当前的语句，并不是以把整个调用栈都锁死的方式进行等待。","user_name":"作者回复","user_name_real":"土豆盒子","uid":"1088582","ctime":1577435718,"ip_address":"","comment_id":159263,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5870560406","product_id":100031001,"comment_content":"await 的上下文函数并不包含调用栈，因此 func 后续代码继续执行，打印“func after”。这里怎么理解？","like_count":1,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476997,"discussion_content":"就是await只等待当前的语句，并不是以把整个调用栈都锁死的方式进行等待。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577435718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153127,"user_name":"菜头","can_delete":false,"product_type":"c1","uid":1456964,"ip_address":"","ucode":"C5E95519F9EA21","user_header":"https://static001.geekbang.org/account/avatar/00/16/3b/44/dd534c9b.jpg","comment_is_top":false,"comment_ctime":1574164555,"is_pvip":false,"replies":[{"id":"59089","content":"可以的，赞👍","user_name":"作者回复","user_name_real":"土豆盒子","uid":"1088582","ctime":1574308063,"ip_address":"","comment_id":153127,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5869131851","product_id":100031001,"comment_content":"1、因为两个 SendPort 的作用不一样<br>第一个 SendPort 是为了让并发 Isolate 回传一个 SendPort<br>第二个 SendPort 是为了让并发 Isolate 回传结果<br>可以改造成一个<br>监听第一个 SendPort 的回调，根据结果类型复用这个 SendPort<br>并且在计算结果完成之后关掉 SendPort 即可<br>","like_count":2,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475053,"discussion_content":"可以的，赞👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574308063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1742621,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/97/1d/4bac8dbf.jpg","nickname":"VI jolie","note":"","ucode":"1CBC214FFEB546","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329083,"discussion_content":"Future<dynamic> asyncFactoriali(n) async {\n  final response = ReceivePort(); // 创建管道\n  // 创建并发 Isolate，并传入管道\n  await Isolate.spawn(_isolate, response.sendPort);\n  // 等待 Isolate 回传管道\n   response.listen((message) {\n    if (message is SendPort) {\n      message.send(n);\n    } else {\n      print(&#39;$message&#39;);\n      response.close();\n    }\n  });\n}\n问题是这个怎么return 啊，答主知道么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606308737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1697975,"avatar":"https://static001.geekbang.org/account/avatar/00/19/e8/b7/0f43ae79.jpg","nickname":"言者歌途","note":"","ucode":"67CCB2E8DD8B28","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311712,"discussion_content":"这里我觉得就应该改造成一个。看起来太混乱了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602470906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145149,"user_name":"Geek_869250","can_delete":false,"product_type":"c1","uid":1457445,"ip_address":"","ucode":"292980DF23D5A0","user_header":"http://thirdwx.qlogo.cn/mmopen/h0KAdRFKjCOSLRjzictvlaHOxsEiaWMSqcO68oiaUqffzyYlEKrDRvicHociabv72HNuR2VdECr8mVFIRiayM0Dd7bNDnaiceicHysF7/132","comment_is_top":false,"comment_ctime":1572224357,"is_pvip":false,"replies":[{"id":"56198","content":"基本上一样，因为Dart的单线程模型就是借鉴的js","user_name":"作者回复","user_name_real":"土豆盒子","uid":"1088582","ctime":1572321949,"ip_address":"","comment_id":145149,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5867191653","product_id":100031001,"comment_content":"老师可以和JS的event loop做个比较吗<br>","like_count":1,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472267,"discussion_content":"基本上一样，因为Dart的单线程模型就是借鉴的js","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572321949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1360952,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c4/38/e0fefa2b.jpg","nickname":"魅影","note":"","ucode":"F26F7F1331A4DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379862,"discussion_content":"有区别，JS 中是先执行 Event Queue 中的宏任务，再去执行微任务。Dart 相反","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624194735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138196,"user_name":"舒大飞","can_delete":false,"product_type":"c1","uid":1313651,"ip_address":"","ucode":"5CC2E0F8C40E38","user_header":"https://static001.geekbang.org/account/avatar/00/14/0b/73/4f1c9676.jpg","comment_is_top":false,"comment_ctime":1570089996,"is_pvip":true,"replies":[{"id":"53522","content":"1.文件I&#47;O和网络调用这类底层服务调用，只是Embedder层做了一次封装，底层有专门的线程处理这些任务；<br>2.两者设计理念不同而已，原生Android更底层。你也可以试着增加一层，用线程池模拟出类似Dart的Isolate机制，实现I&#47;O、网络调用的异步化。<br>","user_name":"作者回复","user_name_real":"土豆盒子","uid":"1088582","ctime":1570518694,"ip_address":"","comment_id":138196,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5865057292","product_id":100031001,"comment_content":"老师，还是有点困惑，希望解答下，你说的:文件IO和网络调用并不是在dart层做的，而是由操作系统提供的异步线程，这句话怎么理解，是因为dart里的文件IO和网络调用是这样封装实现的吗?如果不是，那其它语言，比如Android开发中为什么要单独开线程去做IO和网络请求，Android开发中的IO和网络请求不是操作系统提供的异步线程吗","like_count":1,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469432,"discussion_content":"1.文件I/O和网络调用这类底层服务调用，只是Embedder层做了一次封装，底层有专门的线程处理这些任务；\n2.两者设计理念不同而已，原生Android更底层。你也可以试着增加一层，用线程池模拟出类似Dart的Isolate机制，实现I/O、网络调用的异步化。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570518694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129544,"user_name":"楼外楼","can_delete":false,"product_type":"c1","uid":1243180,"ip_address":"","ucode":"791F2CA15B8F1F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/sgEfkeMSIIibeH4l0HS8uwM6PGY3DSHoW5tV9l1hDQ06tr3OnI7F545Wdxsh59rqOKnzjLUpCcEqic3P9zZbKzPQ/132","comment_is_top":false,"comment_ctime":1567152434,"is_pvip":false,"replies":[{"id":"49517","content":"await阻塞的是当前上下文的后续代码执行，并不能阻塞其调用栈上层的后续代码执行","user_name":"作者回复","user_name_real":"土豆盒子","uid":"1088582","ctime":1567677939,"ip_address":"","comment_id":129544,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5862119730","product_id":100031001,"comment_content":"Dart 中的 await 并不是阻塞等待，而是异步等待，这句话是不是有问题，await 就是阻塞后面代码执行，等待异步代码返回。难道我理解有误？","like_count":1,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465534,"discussion_content":"await阻塞的是当前上下文的后续代码执行，并不能阻塞其调用栈上层的后续代码执行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567677939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347003,"user_name":"VI jolie","can_delete":false,"product_type":"c1","uid":1742621,"ip_address":"","ucode":"1CBC214FFEB546","user_header":"https://static001.geekbang.org/account/avatar/00/1a/97/1d/4bac8dbf.jpg","comment_is_top":false,"comment_ctime":1653613339,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653613339","product_id":100031001,"comment_content":"你发现了什么现象？那就是 await 与 async 只对调用上下文的函数有效，并不向上传递。这个怎么理解","like_count":0},{"had_liked":false,"id":335957,"user_name":"青山","can_delete":false,"product_type":"c1","uid":1131070,"ip_address":"","ucode":"749BAD1834AC0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/42/3e/1d9c257f.jpg","comment_is_top":false,"comment_ctime":1645787728,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645787728","product_id":100031001,"comment_content":"老师您好, 我不知道你还在回答这个专栏的问题不,我在现实编码中遇见了一个问题:isolate与MethodChannel 不能一起使用,这让我的app加载并不流程,原因是调用原生方法时需要很久的时间,ui线程会等待执行完成后再加载ui,不知道老师对着方面有什么经验或者可实现方案.","like_count":0},{"had_liked":false,"id":313533,"user_name":"李源清","can_delete":false,"product_type":"c1","uid":2750697,"ip_address":"","ucode":"4B5FC6B0890024","user_header":"","comment_is_top":false,"comment_ctime":1632477089,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632477089","product_id":100031001,"comment_content":"是不是可以这样理解，IO事件、网络请求这种耗时操作，系统会自动调用其他线程来执行，只是将结果扔回所谓的dart单线程中，最终从循环队列中拿到处理结果？","like_count":0},{"had_liked":false,"id":302756,"user_name":"YJY","can_delete":false,"product_type":"c1","uid":1752518,"ip_address":"","ucode":"430E0ADCDA6C4C","user_header":"https://static001.geekbang.org/account/avatar/00/1a/bd/c6/24e2c375.jpg","comment_is_top":false,"comment_ctime":1626354981,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626354981","product_id":100031001,"comment_content":"老师我想请问下，像网络请求，请求完成后的异步回调，是怎么和主isolate线程进行交互的，底衬层逻辑是怎么样的","like_count":0},{"had_liked":false,"id":295648,"user_name":"张大少","can_delete":false,"product_type":"c1","uid":1469709,"ip_address":"","ucode":"216081FF1CA061","user_header":"https://static001.geekbang.org/account/avatar/00/16/6d/0d/bf246ff1.jpg","comment_is_top":false,"comment_ctime":1622530020,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622530020","product_id":100031001,"comment_content":"老师，绘制动画的animation是不是也是flutter系统的独立线程做支持？不然岂不是也和事件队列有冲突？<br>比如要实现一个动画，而在动画过程中加载网络或者文件，按照单线程代码顺序可能如下步骤<br>1，加载网络或动画部分会通过future加到事件队列<br>2，动画部分开始执行<br>此时理论上时动画开始执行的同时，应该算是本次事件结束，开始走事件队列的加载操作吧？","like_count":0},{"had_liked":false,"id":230317,"user_name":"yl","can_delete":false,"product_type":"c1","uid":1330401,"ip_address":"","ucode":"6AFB54FB11EEC4","user_header":"https://static001.geekbang.org/account/avatar/00/14/4c/e1/49db2fc3.jpg","comment_is_top":false,"comment_ctime":1593346252,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593346252","product_id":100031001,"comment_content":"&#47;&#47;两个方法都需要改造下，第一个只要把主的port传递给子isolate，子isolate里做计算就行了，在主的port需要做类型判断<br>  &#47;&#47; 并发计算阶乘<br>  Future&lt;void&gt; asyncFactoriali(n) async {<br>    final response = ReceivePort(); &#47;&#47; 创建管道<br>    &#47;&#47; 创建并发 Isolate，并传入管道<br>    await Isolate.spawn(_isolate, response.sendPort);<br>    &#47;&#47; 等待 Isolate 回传管道<br>    response.listen((message) {<br>      if (message is SendPort) {<br>        message.send(n);<br>      } else {<br>        print(&#39;IsolateTest123：$message&#39;);<br>      }<br>    });<br>  }<br><br>&#47;&#47;Isolate 函数体，参数是主 Isolate 传入的管道<br>  static _isolate(initialReplyTo) async {<br>    final port = ReceivePort(); &#47;&#47; 创建管道<br>    initialReplyTo.send(port.sendPort); &#47;&#47; 往主 Isolate 回传管道<br>    port.listen((message) {<br>      if (message is int) {<br>        initialReplyTo.send(syncFactorial(message));<br>      }<br>    });<br>  }","like_count":0},{"had_liked":false,"id":227619,"user_name":"肖","can_delete":false,"product_type":"c1","uid":1529343,"ip_address":"","ucode":"763D0C2871B92F","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/ff/1489d0fb.jpg","comment_is_top":false,"comment_ctime":1592443539,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592443539","product_id":100031001,"comment_content":"<br>&#47;&#47;声明了一个延迟2秒返回Hello的Future，并注册了一个then返回拼接后的Hello 2019<br>Future&lt;String&gt; fetchContent() =&gt; <br><br><br>print(&quot;12345678909876543&quot;);&#47;&#47;自己添加的；<br>  Future&lt;String&gt;.delayed(Duration(seconds:2), () =&gt; &quot;Hello&quot;)<br>    .then((x) =&gt; &quot;$x 2019&quot;);<br>&#47;&#47;异步函数会同步等待Hello 2019的返回，并打印<br>func() async =&gt; print(await fetchContent());<br><br>main() {<br>  print(&quot;func before&quot;);<br>  func();<br>  print(&quot;func after&quot;);<br>}<br>老师，个例子中是吧fetchContent函数加入了队列吗？还是把await和Future&lt;String&gt;.delayed(。。。及其下文加入队列？","like_count":0},{"had_liked":false,"id":223732,"user_name":"smilingmiao","can_delete":false,"product_type":"c1","uid":1157910,"ip_address":"","ucode":"B48F429563EF74","user_header":"https://static001.geekbang.org/account/avatar/00/11/ab/16/0f83cab6.jpg","comment_is_top":false,"comment_ctime":1591167632,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591167632","product_id":100031001,"comment_content":"Future&lt;String&gt; fetchContent() =&gt; <br>Future&lt;String&gt;.delayed(Duration(seconds: 2), () =&gt; &quot;Hello&quot;)<br>.then((x) =&gt; &quot;$x 2020&quot;).then((x) =&gt; &quot;$x 2021&quot;);<br><br>func() async =&gt; print(await fetchContent());<br><br>void main() async {<br>  print(&quot;func before&quot;);<br>  await func();<br>  print(&quot;func after&quot;);<br>}<br><br>&#47;&#47; 输出<br>func before<br>Hello 2020 2021<br>func after","like_count":0},{"had_liked":false,"id":216865,"user_name":"小秋","can_delete":false,"product_type":"c1","uid":1213880,"ip_address":"","ucode":"68497F5A66A3D1","user_header":"https://static001.geekbang.org/account/avatar/00/12/85/b8/7f146b83.jpg","comment_is_top":false,"comment_ctime":1589357098,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589357098","product_id":100031001,"comment_content":"Isolate代码示例中 await Isolate.spawn(_isolate,response.sendPort);报以下这种错误是什么？这个有什么需要注意的吗？<br>Isolate.spawn expects to be passed a static or top-level function","like_count":0},{"had_liked":false,"id":216475,"user_name":"陈斌","can_delete":false,"product_type":"c1","uid":1450358,"ip_address":"","ucode":"B3F3A2117F8455","user_header":"https://static001.geekbang.org/account/avatar/00/16/21/76/0e443bcb.jpg","comment_is_top":false,"comment_ctime":1589268135,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589268135","product_id":100031001,"comment_content":"老师，想问一下这个场景<br>void methodA() async {<br>    await netWorkA().then((res){<br>        print(“netWorkA()响应”);<br>    });<br>    await netWorkB().then((res){<br>        print(“netWorkB()响应”);<br>    });<br>}<br>执行methodA的时候，会顺序调用后台接口netWorkA、netWorkB，但是响应的时候，两个print的输出顺序是不一定的吗？","like_count":0},{"had_liked":false,"id":211454,"user_name":"猫猫","can_delete":false,"product_type":"c1","uid":1518041,"ip_address":"","ucode":"46E5356348DA36","user_header":"https://static001.geekbang.org/account/avatar/00/17/29/d9/4358d6fb.jpg","comment_is_top":false,"comment_ctime":1587965868,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587965868","product_id":100031001,"comment_content":"then中有future的话，后续的then下次执行<br>then中有microtask的话，后续的then继续执行","like_count":0},{"had_liked":false,"id":209440,"user_name":"张训博-forrest","can_delete":false,"product_type":"c1","uid":1331072,"ip_address":"","ucode":"9A50F9BD3FFDE1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLIdTsqPhlVH3TFElzic8422uBDelRjYiaktCJRmIRpLrgBBfBKnSO9PlbHibnHAc9cQEmLHes3fayEw/132","comment_is_top":false,"comment_ctime":1587549567,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1587549567","product_id":100031001,"comment_content":"Isolate 的方法为啥要求是static的","like_count":0,"discussions":[{"author":{"id":1129422,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3b/ce/88bf2008.jpg","nickname":"浪迹江湖","note":"","ucode":"514459670AC242","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552486,"discussion_content":"非静态方法的调用依赖对象本身，但 Isolate 不能共享内存，无法访问对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645495550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200157,"user_name":"肖","can_delete":false,"product_type":"c1","uid":1529343,"ip_address":"","ucode":"763D0C2871B92F","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/ff/1489d0fb.jpg","comment_is_top":false,"comment_ctime":1585551541,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585551541","product_id":100031001,"comment_content":"void main() async{<br>    print(&#39;f1&#39;);<br>    print(await methodC());<br>    print(&#39;f2&#39;);<br>    Future(() =&gt; print(&#39;f3&#39;));<br>    methodD();<br>}<br><br>methodC() {<br>    print(&#39;f4&#39;);<br>    return  Future.delayed(Duration(seconds: 2),(){return Future.value(&quot;f5&quot;);});<br>}<br><br>methodD(){<br>  print(&#39;f6&#39;);<br>}<br><br>f1<br>f4<br>f5<br>f2<br>f6<br>f3<br>老师们：这个打印 f4 f5为什么在f1 f2之间，await 不是异步等待吗？ await methodC()加入even 队列，先打印 f2，Future(() =&gt; print(&#39;f3&#39;));  加入队列 然后打印f6 。。。","like_count":0},{"had_liked":false,"id":183933,"user_name":"Geek_473879","can_delete":false,"product_type":"c1","uid":1843920,"ip_address":"","ucode":"D7F4C74F6D0030","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7h2t7ZmOZEpzazicoHF0ricTvaObicQCYZpolMz38tnPzcV1KywglcTibf6yPY0JLc4PWA3LtapgJKg/132","comment_is_top":false,"comment_ctime":1583163893,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583163893","product_id":100031001,"comment_content":"main()  {<br>    print( fe());&#47;&#47;等待Hello 2019的返回<br><br>    print(&#39;sdasd&#39;);<br>    Future(() =&gt; print(&#39;f1&#39;))  .then((_) async =&gt; await Future(() =&gt; print(&#39;f2&#39;)))  .then((_) =&gt; print(&#39;f3&#39;));Future(() =&gt; print(&#39;f4&#39;));<br>}<br><br>&#47;&#47;声明了一个延迟3秒返回Hello的Future，并注册了一个then返回拼接后的Hello 2019<br>Future&lt;String&gt; fe()=&gt;<br>    Future&lt;String&gt;.delayed(Duration(seconds: 3),() =&gt; &#39;hello&#39;).<br>    then((x) =&gt; &quot;$x 2019&quot;);<br>这个为啥结果是Instance of &#39;Future&lt;String&gt;&#39;<br>sdasd<br>f1<br>f4<br>f2<br>f3","like_count":0},{"had_liked":false,"id":175947,"user_name":"(Jet)黄仲平","can_delete":false,"product_type":"c1","uid":1244363,"ip_address":"","ucode":"2AF4F9B460795C","user_header":"https://static001.geekbang.org/account/avatar/00/12/fc/cb/5e79c6ed.jpg","comment_is_top":false,"comment_ctime":1580890129,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580890129","product_id":100031001,"comment_content":"老师好，请问“await 与 async 只对调用上下文的函数有效”。这里的“上下文”要如何理解","like_count":0},{"had_liked":false,"id":172004,"user_name":"ssala","can_delete":false,"product_type":"c1","uid":1005356,"ip_address":"","ucode":"CCD82C81756FC6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/2c/b0793828.jpg","comment_is_top":false,"comment_ctime":1579069343,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579069343","product_id":100031001,"comment_content":"老师，dart从事件循环中获取事件并处理，那谁负责向事件队列中添加事件呢？或者说我们的异步任务是在何时以何种方式加入到事件队列的呢？","like_count":0},{"had_liked":false,"id":170238,"user_name":"有灯无月不娱人","can_delete":false,"product_type":"c1","uid":1805761,"ip_address":"","ucode":"5DA936A8782A1C","user_header":"https://static001.geekbang.org/account/avatar/00/1b/8d/c1/1add352c.jpg","comment_is_top":false,"comment_ctime":1578555432,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1578555432","product_id":100031001,"comment_content":"老师,你这文档没有关于flutter和native通信的内容介绍?","like_count":0,"discussions":[{"author":{"id":1126460,"avatar":"https://static001.geekbang.org/account/avatar/00/11/30/3c/c2c72e28.jpg","nickname":"星星","note":"","ucode":"013714D9EF1847","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":205818,"discussion_content":"Method Channel\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584345802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170192,"user_name":"有灯无月不娱人","can_delete":false,"product_type":"c1","uid":1805761,"ip_address":"","ucode":"5DA936A8782A1C","user_header":"https://static001.geekbang.org/account/avatar/00/1b/8d/c1/1add352c.jpg","comment_is_top":false,"comment_ctime":1578545891,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578545891","product_id":100031001,"comment_content":"老师,flutter和native的通信是不是也只是在主isolate里实现的?一个 channel的话,在遇到并发通信的时候是不是就可以用future预防通道被阻塞?","like_count":0},{"had_liked":false,"id":165278,"user_name":"cv0cv0","can_delete":false,"product_type":"c1","uid":1360093,"ip_address":"","ucode":"93FF9277F03FD0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLEIsgI4ub1VOKWtVOfouAzSqx8Yt8ibQEsAnwNJsJHmuJzzpQqG79HullvYwpic8hgiclgON2GwXSjw/132","comment_is_top":false,"comment_ctime":1577192386,"is_pvip":false,"replies":[{"id":"63407","content":"import &#39;package:flutter&#47;foundation.dart&#39;;<br>","user_name":"作者回复","comment_id":165278,"uid":"1088582","ip_address":"","utype":1,"ctime":1577439923,"user_name_real":"土豆盒子"}],"discussion_count":1,"race_medal":0,"score":"1577192386","product_id":100031001,"comment_content":"compute 函数是什么包？自动导入找不到这个函数。","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479104,"discussion_content":"import &amp;#39;package:flutter/foundation.dart&amp;#39;;\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577439923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146973,"user_name":"菜头","can_delete":false,"product_type":"c1","uid":1456964,"ip_address":"","ucode":"C5E95519F9EA21","user_header":"https://static001.geekbang.org/account/avatar/00/16/3b/44/dd534c9b.jpg","comment_is_top":false,"comment_ctime":1572747561,"is_pvip":false,"replies":[{"id":"59789","content":"1.你这个代码编译不通过吧<br>2.单行箭头函数的then是Future，和函数体内有Future不是一回事<br>","user_name":"作者回复","comment_id":146973,"uid":"1088582","ip_address":"","utype":1,"ctime":1574754294,"user_name_real":"土豆盒子"}],"discussion_count":2,"race_medal":0,"score":"1572747561","product_id":100031001,"comment_content":"老师上面的例子中有一个疑问<br>&#47;&#47;声明了一个匿名Future，并注册了两个then。第一个then是一个Future<br><br>Future f6 = Future(() =&gt; print(&#39;f6&#39;))<br><br>f6.then((_) =&gt; f7 = Future(() =&gt; print(&#39;f7&#39;)); return f7)<br>.then((_) =&gt; print(&#39;f8&#39;));<br><br>老师这块儿的调用时序为什么不是 f6 f8 ..... f7<br><br>f7 会被放到事件队列里面了 但是f6的第二个 .then(() =&gt;print(&#39;8&#39;)) 为什么也会被放到事件队列中<br>","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473081,"discussion_content":"1.你这个代码编译不通过吧\n2.单行箭头函数的then是Future，和函数体内有Future不是一回事\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574754294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1089359,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9f/4f/1d14d424.jpg","nickname":"隔壁小土豆","note":"","ucode":"DCCFEC661B9199","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":248051,"discussion_content":"老师, 我也有一样的问题, 为什么函数体内的Future和 return Future 会使结果大不一样? 谢谢回答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587829675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146970,"user_name":"菜头","can_delete":false,"product_type":"c1","uid":1456964,"ip_address":"","ucode":"C5E95519F9EA21","user_header":"https://static001.geekbang.org/account/avatar/00/16/3b/44/dd534c9b.jpg","comment_is_top":false,"comment_ctime":1572747271,"is_pvip":false,"replies":[{"id":"59785","content":"f7这个 then 是一个 Future 异步任务，因此这个 then，以及后续的 then 都被放入到事件队列中了","user_name":"作者回复","comment_id":146970,"uid":"1088582","ip_address":"","utype":1,"ctime":1574753768,"user_name_real":"土豆盒子"}],"discussion_count":1,"race_medal":0,"score":"1572747271","product_id":100031001,"comment_content":"老师上面的例子中有一个疑问<br>&#47;&#47;声明了一个匿名Future，并注册了两个then。第一个then是一个Future<br><br>Future f6 = Future(() =&gt; print(&#39;f6&#39;))<br><br>f6.then((_) =&gt; f7 = Future(() =&gt; print(&#39;f7&#39;)); return f7)<br>.then((_) =&gt; print(&#39;f8&#39;));<br><br>老师这块儿的调用时序为什么不是 f6 f8 ..... f7<br>Future 执行的 then 不是和 Future 一个事件循环吗","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473078,"discussion_content":"f7这个 then 是一个 Future 异步任务，因此这个 then，以及后续的 then 都被放入到事件队列中了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574753768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142566,"user_name":"巫山老妖","can_delete":false,"product_type":"c1","uid":1056037,"ip_address":"","ucode":"B35E2CF1B3B04E","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/25/c4cc1e9f.jpg","comment_is_top":false,"comment_ctime":1571397459,"is_pvip":true,"replies":[{"id":"56207","content":"不对哦，注意看其实我在并发Isolate中发了两次SendPort","user_name":"作者回复","comment_id":142566,"uid":"1088582","ip_address":"","utype":1,"ctime":1572322823,"user_name_real":"土豆盒子"}],"discussion_count":1,"race_medal":1,"score":"1571397459","product_id":100031001,"comment_content":"第一个思考题，是因为isolate是单向通信的，要达到双向通信需要回传一个发送通道，所以需要两个SendPort。 ","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471180,"discussion_content":"不对哦，注意看其实我在并发Isolate中发了两次SendPort","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572322823,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130568,"user_name":"C","can_delete":false,"product_type":"c1","uid":1599441,"ip_address":"","ucode":"C5845E7EC389EC","user_header":"https://static001.geekbang.org/account/avatar/00/18/67/d1/1c69ad22.jpg","comment_is_top":false,"comment_ctime":1567484773,"is_pvip":false,"replies":[{"id":"48901","content":"Future f = Future(() =&gt; print(&#39;f1&#39;));<br>f.then((_) =&gt; Future(() =&gt; print(&#39;f2&#39;)));<br>f.then((_) =&gt; print(&#39;f3&#39;));<br>Future(() =&gt; print(&#39;f4&#39;));<br>这么看明白了么","user_name":"作者回复","comment_id":130568,"uid":"1088582","ip_address":"","utype":1,"ctime":1567511040,"user_name_real":"土豆盒子"}],"discussion_count":3,"race_medal":0,"score":"1567484773","product_id":100031001,"comment_content":"有个疑问：<br>Future(() =&gt; print(&quot;f1&quot;))<br>  ..then((_) =&gt; Future(() =&gt; print(&quot;f2&quot;)))<br>  ..then((_) =&gt; print(&quot;f3&quot;));<br>Future(() =&gt; print(&quot;f4&quot;));<br>这样打印出来的结果为什么是 f1 f3 f4 f2","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466013,"discussion_content":"Future f = Future(() =&amp;gt; print(&amp;#39;f1&amp;#39;));\nf.then((_) =&amp;gt; Future(() =&amp;gt; print(&amp;#39;f2&amp;#39;)));\nf.then((_) =&amp;gt; print(&amp;#39;f3&amp;#39;));\nFuture(() =&amp;gt; print(&amp;#39;f4&amp;#39;));\n这么看明白了么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567511040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1456964,"avatar":"https://static001.geekbang.org/account/avatar/00/16/3b/44/dd534c9b.jpg","nickname":"菜头","note":"","ucode":"C5E95519F9EA21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42666,"discussion_content":"老师 我知道了\n\n因为 Future(() => print(&#39;f6&#39;))\n .then((_) => Future(() => print(&#39;f7&#39;))\n.then((_) => print(&#39;f8&#39;))\n\n可以改写为\nFuture f6 = Future(() => print(&#39;f6&#39;);\nFuture f8 = f6.then(() => Future(() => print(f7)));\nf8.then(() => print(&#39;f8&#39;)\n\n而不是 f6.then(() => print(&#39;f8&#39;))\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572750571,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1456964,"avatar":"https://static001.geekbang.org/account/avatar/00/16/3b/44/dd534c9b.jpg","nickname":"菜头","note":"","ucode":"C5E95519F9EA21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42663,"discussion_content":"//声明了一个匿名Future，并注册了两个then。第一个then是一个Future\nFuture(() => print(&#39;f6&#39;)) \n .then((_) => Future(() => print(&#39;f7&#39;)))\n  .then((_) => print(&#39;f8&#39;));\n//声明了一个匿名FutureFuture(() => print(&#39;f9&#39;));\n这个的执行顺序为什么是 f6 f9 f7 f8\n而不是 f6 f8 f9 f7","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572748256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129317,"user_name":"小水滴","can_delete":false,"product_type":"c1","uid":1411555,"ip_address":"","ucode":"559FAF5F117BB5","user_header":"https://static001.geekbang.org/account/avatar/00/15/89/e3/aa57d3b2.jpg","comment_is_top":false,"comment_ctime":1567086331,"is_pvip":false,"replies":[{"id":"48121","content":"不可以，因为资源完全隔离","user_name":"作者回复","comment_id":129317,"uid":"1088582","ip_address":"","utype":1,"ctime":1567097002,"user_name_real":"土豆盒子"}],"discussion_count":1,"race_medal":0,"score":"1567086331","product_id":100031001,"comment_content":"还有一个疑问，并发Isolate中可以操作widget吗","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465396,"discussion_content":"不可以，因为资源完全隔离","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567097002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129314,"user_name":"小水滴","can_delete":false,"product_type":"c1","uid":1411555,"ip_address":"","ucode":"559FAF5F117BB5","user_header":"https://static001.geekbang.org/account/avatar/00/15/89/e3/aa57d3b2.jpg","comment_is_top":false,"comment_ctime":1567086207,"is_pvip":false,"replies":[{"id":"48125","content":"赞。有个小bug：response没有close掉","user_name":"作者回复","comment_id":129314,"uid":"1088582","ip_address":"","utype":1,"ctime":1567097595,"user_name_real":"土豆盒子"}],"discussion_count":1,"race_medal":0,"score":"1567086207","product_id":100031001,"comment_content":"testIsolate() async{<br>  print(await asyncFactoriali(4));<br>}<br>&#47;&#47; 同步计算阶乘<br>int syncFactorial(n) =&gt; n &lt; 2 ? n : n * syncFactorial(n-1);<br><br><br>&#47;&#47; 并发计算阶乘<br>Future&lt;dynamic&gt; asyncFactoriali(n) async{<br>  final response = ReceivePort();&#47;&#47; 创建管道<br>  &#47;&#47; 创建并发 Isolate，并传入管道<br>  await Isolate.spawn(_isolate,response.sendPort);<br>  response.listen((data){<br>    if (data is SendPort){<br>      data.send(n);<br>    } else {<br>      print(&quot;&gt;&gt;&gt;&gt;&gt;&gt;$data&quot;);<br>    }<br>  });<br>}<br><br>&#47;&#47;Isolate 函数体，参数是主 Isolate 传入的管道<br>_isolate(initialReplyTo) async {<br>  final port = ReceivePort();&#47;&#47; 创建管道<br>  initialReplyTo.send(port.sendPort);&#47;&#47; 往主 Isolate 回传管道<br>  final message = await port.first as int;&#47;&#47; 等待主 Isolate 发送消息 (参数和回传结果的管道)<br>  initialReplyTo.send(syncFactorial(message));&#47;&#47; 调用同步计算阶乘的函数回传结果<br>}<br><br>","like_count":0,"discussions":[{"author":{"id":1742621,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/97/1d/4bac8dbf.jpg","nickname":"VI jolie","note":"","ucode":"1CBC214FFEB546","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329058,"discussion_content":"你这个的返回值是null啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606305387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129307,"user_name":"小水滴","can_delete":false,"product_type":"c1","uid":1411555,"ip_address":"","ucode":"559FAF5F117BB5","user_header":"https://static001.geekbang.org/account/avatar/00/15/89/e3/aa57d3b2.jpg","comment_is_top":false,"comment_ctime":1567084319,"is_pvip":false,"replies":[{"id":"48122","content":"内存变量在Isolate之间是不共享的，对于你这个case，Isolate之间会对这个数组进行复制","user_name":"作者回复","comment_id":129307,"uid":"1088582","ip_address":"","utype":1,"ctime":1567097091,"user_name_real":"土豆盒子"}],"discussion_count":2,"race_medal":0,"score":"1567084319","product_id":100031001,"comment_content":"如果主Isolate创建两个并发Isolate，然后把一个数组分别传递给两个并发Isolate，两个并发Isolate都去操作数组，这样安全吗？","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465391,"discussion_content":"内存变量在Isolate之间是不共享的，对于你这个case，Isolate之间会对这个数组进行复制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567097091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1411555,"avatar":"https://static001.geekbang.org/account/avatar/00/15/89/e3/aa57d3b2.jpg","nickname":"小水滴","note":"","ucode":"559FAF5F117BB5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6784,"discussion_content":"是的，我写demo已经验证，确实是拷贝一份，感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567097155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129261,"user_name":"bo_oc","can_delete":false,"product_type":"c1","uid":1639900,"ip_address":"","ucode":"87E64362EBFF6B","user_header":"","comment_is_top":false,"comment_ctime":1567072139,"is_pvip":false,"replies":[{"id":"48090","content":"f3不需要microtask","user_name":"作者回复","comment_id":129261,"uid":"1088582","ip_address":"","utype":1,"ctime":1567077130,"user_name_real":"土豆盒子"}],"discussion_count":1,"race_medal":0,"score":"1567072139","product_id":100031001,"comment_content":"Future(() =&gt; print(&#39;f1&#39;))<br>        .then((_){ scheduleMicrotask(()=&gt;print(&#39;f2&#39;)); })<br>        .then((_){ scheduleMicrotask(()=&gt;print(&#39;f3&#39;)); });<br>    Future(() =&gt; print(&#39;f4&#39;));","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465367,"discussion_content":"f3不需要microtask","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567077130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128994,"user_name":"ptlCoder","can_delete":false,"product_type":"c1","uid":1029656,"ip_address":"","ucode":"B7CF1C4A5970B9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b6/18/ede273fe.jpg","comment_is_top":false,"comment_ctime":1567002974,"is_pvip":false,"replies":[{"id":"48092","content":"不多，大多数并发任务的场景通过compute就可以搞定了","user_name":"作者回复","comment_id":128994,"uid":"1088582","ip_address":"","utype":1,"ctime":1567077579,"user_name_real":"土豆盒子"}],"discussion_count":1,"race_medal":0,"score":"1567002974","product_id":100031001,"comment_content":"像直接使用isolate这种管道机制的场景多不多？个人感觉这种写法繁琐不容易懂","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465216,"discussion_content":"不多，大多数并发任务的场景通过compute就可以搞定了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567077579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128932,"user_name":"大土豆","can_delete":false,"product_type":"c1","uid":1121636,"ip_address":"","ucode":"67445DC3EC9DB0","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/64/52a5863b.jpg","comment_is_top":false,"comment_ctime":1566986205,"is_pvip":true,"replies":[{"id":"47863","content":"是的，不过js也提供了worker机制，可以做一些相对独立的事情","user_name":"作者回复","comment_id":128932,"uid":"1088582","ip_address":"","utype":1,"ctime":1566986845,"user_name_real":"土豆盒子"}],"discussion_count":1,"race_medal":0,"score":"1566986205","product_id":100031001,"comment_content":"能否这样认为，dart的这种线程模型既解决了Android&#47;iOS这种多线程机制因为线程抢占等原因导致IO密集型计算不给力，也解决了js这种纯单线程模型导致的CPU密集型计算不给力的问题","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465183,"discussion_content":"是的，不过js也提供了worker机制，可以做一些相对独立的事情","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566986845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128925,"user_name":"大土豆","can_delete":false,"product_type":"c1","uid":1121636,"ip_address":"","ucode":"67445DC3EC9DB0","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/64/52a5863b.jpg","comment_is_top":false,"comment_ctime":1566984980,"is_pvip":true,"replies":[{"id":"47862","content":"js也可以开web worker，其实是一样的","user_name":"作者回复","comment_id":128925,"uid":"1088582","ip_address":"","utype":1,"ctime":1566986775,"user_name_real":"土豆盒子"}],"discussion_count":1,"race_medal":0,"score":"1566984980","product_id":100031001,"comment_content":"老师，能否这样理解，js是单线程，然后一个事件循环的模型，和flutter一样，I&#47;O是异步的，所以文件，网络都没问题，但是，如果一个While(true)的死循环，js就卡死了，因为只有一个线程。而这种情况flutter没问题，While(true)的死循环可以放到另外一个isolate里面，内存和主isolate也是隔离的，不影响主isolate和主线程。","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465179,"discussion_content":"js也可以开web worker，其实是一样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566986775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128824,"user_name":"大恒","can_delete":false,"product_type":"c1","uid":1330033,"ip_address":"","ucode":"B8E3E2273F74DB","user_header":"https://static001.geekbang.org/account/avatar/00/14/4b/71/591ae170.jpg","comment_is_top":false,"comment_ctime":1566968165,"is_pvip":true,"replies":[{"id":"48072","content":"Isolate会开辟新的内存栈，对内存有更多要求（大约20MB）","user_name":"作者回复","comment_id":128824,"uid":"1088582","ip_address":"","utype":1,"ctime":1567058792,"user_name_real":"土豆盒子"}],"discussion_count":1,"race_medal":0,"score":"1566968165","product_id":100031001,"comment_content":"开启一个Isolate会不会很消耗资源？","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465121,"discussion_content":"Isolate会开辟新的内存栈，对内存有更多要求（大约20MB）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567058792,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127423,"user_name":"Geek_0d3a08","can_delete":false,"product_type":"c1","uid":1184316,"ip_address":"","ucode":"3FB6E2CBD81A7C","user_header":"https://static001.geekbang.org/account/avatar/00/12/12/3c/2e7fd24f.jpg","comment_is_top":false,"comment_ctime":1566704995,"is_pvip":false,"replies":[{"id":"47353","content":"用microtask是对的，不过没有Future.microtask这样的语法","user_name":"作者回复","comment_id":127423,"uid":"1088582","ip_address":"","utype":1,"ctime":1566793318,"user_name_real":"土豆盒子"}],"discussion_count":2,"race_medal":0,"score":"1566704995","product_id":100031001,"comment_content":"2.Future(() =&gt; print(&#39;f1&#39;))<br>      .then((_) async =&gt; await Future.microtask(() =&gt; print(&#39;f2&#39;)))<br>      .then((_) =&gt; print(&#39;f3&#39;));<br>  Future(() =&gt; print(&#39;f4&#39;));","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464484,"discussion_content":"用microtask是对的，不过没有Future.microtask这样的语法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566793318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1184316,"avatar":"https://static001.geekbang.org/account/avatar/00/12/12/3c/2e7fd24f.jpg","nickname":"Geek_0d3a08","note":"","ucode":"3FB6E2CBD81A7C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6265,"discussion_content":"有，我用as它自动提示就是Future.microttask了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566815879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127420,"user_name":"Geek_0d3a08","can_delete":false,"product_type":"c1","uid":1184316,"ip_address":"","ucode":"3FB6E2CBD81A7C","user_header":"https://static001.geekbang.org/account/avatar/00/12/12/3c/2e7fd24f.jpg","comment_is_top":false,"comment_ctime":1566704744,"is_pvip":false,"replies":[{"id":"47355","content":"赞👍（注意下主Isolate在发送参数时传入的port可以省去）","user_name":"作者回复","comment_id":127420,"uid":"1088582","ip_address":"","utype":1,"ctime":1566793592,"user_name_real":"土豆盒子"}],"discussion_count":2,"race_medal":0,"score":"1566704744","product_id":100031001,"comment_content":"1.可以，写法改一下就行<br>&#47;&#47; 并发计算阶乘<br>asyncFactoriali(n) async {<br>  final response = ReceivePort(); &#47;&#47; 创建管道<br>  &#47;&#47; 创建并发 Isolate，并传入管道<br>  await Isolate.spawn(_isolate, response.sendPort);<br>  response.listen((value){<br>    if(value is SendPort) {<br>      final answer = ReceivePort();<br>      &#47;&#47; 往 Isolate 回传的管道中发送参数，同时传入 answer 管道<br>      value.send([n, answer.sendPort]);<br>    }<br>    print(&quot;============$value&quot;);<br>  });<br><br>}<br><br>&#47;&#47;Isolate 函数体，参数是主 Isolate 传入的管道<br>_isolate(initialReplyTo) async {<br>  final port = ReceivePort(); &#47;&#47; 创建管道<br>  initialReplyTo.send(port.sendPort); &#47;&#47; 往主 Isolate 回传管道<br>  final message = await port.first as List; &#47;&#47; 等待主 Isolate 发送消息 (参数和回传结果的管道)<br>  final data = message[0] as int; &#47;&#47; 参数<br>&#47;&#47;  final send = message[1] as SendPort;&#47;&#47; 回传结果的管道<br>  initialReplyTo.send(syncFactorial(data)); &#47;&#47; 调用同步计算阶乘的函数回传结果<br>}<br><br>&#47;&#47; 同步计算阶乘<br>int syncFactorial(n) =&gt; n &lt; 2 ? n : n * syncFactorial(n - 1);<br><br>main()  =&gt;  asyncFactoriali(4);","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464483,"discussion_content":"赞👍（注意下主Isolate在发送参数时传入的port可以省去）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566793592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330401,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4c/e1/49db2fc3.jpg","nickname":"yl","note":"","ucode":"6AFB54FB11EEC4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287008,"discussion_content":"这里的answer没必要再新建一个的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593346406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127255,"user_name":"day day up","can_delete":false,"product_type":"c1","uid":1501020,"ip_address":"","ucode":"E9875555B6BD8F","user_header":"https://static001.geekbang.org/account/avatar/00/16/e7/5c/38afffa2.jpg","comment_is_top":false,"comment_ctime":1566623956,"is_pvip":false,"replies":[{"id":"47348","content":"1.不对哦，两个管道从功能上看是一样的<br>2.结果倒是对，不过已经改变代码的语义了","user_name":"作者回复","comment_id":127255,"uid":"1088582","ip_address":"","utype":1,"ctime":1566792943,"user_name_real":"土豆盒子"}],"discussion_count":3,"race_medal":0,"score":"1566623956","product_id":100031001,"comment_content":"1.因为接收方要等待发送方传过来的数据，所以需要两个管道？<br>2.Future(() =&gt; print(&#39;f1&#39;))<br>  .then((_) async =&gt; await Future(() =&gt; print(&#39;f2&#39;)))<br>  .then((_) =&gt; print(&#39;f3&#39;));<br>Future(() =&gt; null).then((_)=&gt;print(&#39;f4&#39;));<br>","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464399,"discussion_content":"1.不对哦，两个管道从功能上看是一样的\n2.结果倒是对，不过已经改变代码的语义了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566792943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1587578,"avatar":"https://static001.geekbang.org/account/avatar/00/18/39/7a/7d5406dd.jpg","nickname":"咕咕咕","note":"","ucode":"9E2E8A6E54C6D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7219,"discussion_content":"不懂为什么这么写顺序是对的？f4为啥不是先与f2打出来，队列不应该是f1 null 然后执行f1时候把f2放进来，执行null的时候执行优先队列里的f4吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567421548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1501020,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/5c/38afffa2.jpg","nickname":"day day up","note":"","ucode":"E9875555B6BD8F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6220,"discussion_content":"老师，在第一个Future前面加await阻塞对吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566793215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127131,"user_name":"淡～","can_delete":false,"product_type":"c1","uid":1123784,"ip_address":"","ucode":"88577F9F1392CD","user_header":"https://static001.geekbang.org/account/avatar/00/11/25/c8/7a950a91.jpg","comment_is_top":false,"comment_ctime":1566565894,"is_pvip":false,"replies":[{"id":"48068","content":"准确的来说是命令行程序和flutter应用不同：Queue里消息为空，命令行程序会直接退出；而flutter则会把时间交给操作系统，系统会休眠，直到下一次有新的事件把它唤醒","user_name":"作者回复","comment_id":127131,"uid":"1088582","ip_address":"","utype":1,"ctime":1567058104,"user_name_real":"土豆盒子"}],"discussion_count":1,"race_medal":0,"score":"1566565894","product_id":100031001,"comment_content":"想问下  为什么事件队列 Event Queue事件队列里面的消息为空的时候 app就退出了呢？不会无限循环吗？无线循环的话会不会阻塞主线程。","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464333,"discussion_content":"准确的来说是命令行程序和flutter应用不同：Queue里消息为空，命令行程序会直接退出；而flutter则会把时间交给操作系统，系统会休眠，直到下一次有新的事件把它唤醒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567058104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125955,"user_name":"矮个子先生😝","can_delete":false,"product_type":"c1","uid":1147205,"ip_address":"","ucode":"2242A457B0E10D","user_header":"https://static001.geekbang.org/account/avatar/00/11/81/45/9aa91b75.jpg","comment_is_top":false,"comment_ctime":1566282645,"is_pvip":false,"replies":[{"id":"48097","content":"Event bus就是基于StreamController做的","user_name":"作者回复","comment_id":125955,"uid":"1088582","ip_address":"","utype":1,"ctime":1567078121,"user_name_real":"土豆盒子"}],"discussion_count":2,"race_medal":0,"score":"1566282645","product_id":100031001,"comment_content":"老师,有篇幅讲解下StreamController响应式编程吗,和event_bus的区别","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463764,"discussion_content":"Event bus就是基于StreamController做的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567078121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194659,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3a/a3/47a0c3c6.jpg","nickname":"zhangls","note":"","ucode":"E3E2840EA4BDB1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5577,"discussion_content":"课程内容是早就制定好了的，可以在课程介绍里查看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566358931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125952,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1566281797,"is_pvip":false,"replies":[{"id":"46471","content":"1.不对哦，两个管道都是作为回传消息用的，第一个管道让并发Isolate回传自己的管道，第二个管道让并发Isolate回传结果，题目问题是为什么需要两个管道，一个管道不行吗？<br>2.结果倒是对，不过这个写法对4的整体结构改动还是很大的","user_name":"作者回复","comment_id":125952,"uid":"1088582","ip_address":"","utype":1,"ctime":1566311137,"user_name_real":"土豆盒子"}],"discussion_count":1,"race_medal":0,"score":"1566281797","product_id":100031001,"comment_content":"我来回答一下思考题：<br>1.因为发送管道是单向的，所以创建两个管道，让一个作为回传消息的管道。<br>2.<br>Future(() =&gt; print(&#39;f1&#39;))<br>      .then((_) async =&gt; await Future(() =&gt; print(&#39;f2&#39;)))<br>      .then((_) =&gt; print(&#39;f3&#39;));<br>    Future(() async =&gt; await(Future(() =&gt; print(&#39;f4&#39;))));","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463763,"discussion_content":"1.不对哦，两个管道都是作为回传消息用的，第一个管道让并发Isolate回传自己的管道，第二个管道让并发Isolate回传结果，题目问题是为什么需要两个管道，一个管道不行吗？\n2.结果倒是对，不过这个写法对4的整体结构改动还是很大的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566311137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125874,"user_name":"大土豆","can_delete":false,"product_type":"c1","uid":1121636,"ip_address":"","ucode":"67445DC3EC9DB0","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/64/52a5863b.jpg","comment_is_top":false,"comment_ctime":1566266794,"is_pvip":true,"replies":[{"id":"46311","content":"确实在应用层直接用Isolate的不多，JSON解码算是比较常见的，建议通过compute函数去搞定的。","user_name":"作者回复","comment_id":125874,"uid":"1088582","ip_address":"","utype":1,"ctime":1566283812,"user_name_real":"土豆盒子"}],"discussion_count":2,"race_medal":0,"score":"1566266794","product_id":100031001,"comment_content":"这个单线程，事件循环的模型，和js是类似的。问下老师，既然dart中i&#47;o，计算等耗时操作都是异步的，异步全都是协程实现的样子。Isolate在平时的开发中，应该没有太大的必要用到吧？","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463728,"discussion_content":"确实在应用层直接用Isolate的不多，JSON解码算是比较常见的，建议通过compute函数去搞定的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566283812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1733144,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/72/18/d9e2fcf9.jpg","nickname":"我来人间一趟","note":"","ucode":"15CAF96EF899E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288345,"discussion_content":"和js事件循环的模型是类似的 但是执行逻辑不太一样 js有宏任务和微任务 第一次执行的是宏任务 而这里是先执行的微任务","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593735525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125811,"user_name":"丁某某","can_delete":false,"product_type":"c1","uid":1134357,"ip_address":"","ucode":"F7E9478D9998DB","user_header":"https://static001.geekbang.org/account/avatar/00/11/4f/15/463fcaf1.jpg","comment_is_top":false,"comment_ctime":1566262021,"is_pvip":false,"replies":[{"id":"46284","content":"f6是执行体，后面两个都是他的then","user_name":"作者回复","comment_id":125811,"uid":"1088582","ip_address":"","utype":1,"ctime":1566280980,"user_name_real":"土豆盒子"}],"discussion_count":2,"race_medal":0,"score":"1566262021","product_id":100031001,"comment_content":"f8外面的then方法体是不是应该放到f7所在future对像后面？？","like_count":0,"discussions":[{"author":{"id":1088582,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/46/0b29b188.jpg","nickname":"土豆盒子","note":"","ucode":"A910F88CAC0A87","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463701,"discussion_content":"f6是执行体，后面两个都是他的then","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566280980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1456964,"avatar":"https://static001.geekbang.org/account/avatar/00/16/3b/44/dd534c9b.jpg","nickname":"菜头","note":"","ucode":"C5E95519F9EA21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42667,"discussion_content":"我理解的是 第二个 then 不是 f6 的 then, 而 是第一个 then 结果 的 then","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572750692,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}