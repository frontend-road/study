{"id":626593,"title":"09｜Coroutines实战（一）：异步文件操作库","content":"<p>你好，我是卢誉声。</p><p>在上一讲中，我们掌握了C++20标准下需要实现的协程接口约定。就目前来说，在没有标准库支持的情况下，这些约定我们都需要自己实现。</p><p>但是，仅通过阅读标准文档或参考代码，编写满足C++协程约定的程序比较困难。因此，我安排了两讲内容带你实战演练一下，以一个异步文件系统操作库为例，学习如何编写满足C++协程约定的程序。</p><p>这一讲我们先明确模块架构，完成基础类型模块和任务调度模块，为后面实现基于协程的异步I/O调度打好基础，今天的重点内容是任务调度模块。</p><p>好，话不多说，就让我们从模块架构开始，一步步实现任务调度模块（（课程配套代码，点击<a href=\"https://github.com/samblg/cpp20-plus-indepth\">这里</a>即可获取））。</p><h2>模块组织方式</h2><p>由于这是一个用C++实现的异步文件操作库，我们就将它命名为asyncpp，取async（即异步asynchronous这一单词的缩写）和cpp的组合。这个基于C++协程的库支持通用异步任务、I/O异步任务以及异步文件系统操作，主要用于I/O等任务而非计算任务。</p><p>整个项目的模块架构图如下。</p><p><img src=\"https://static001.geekbang.org/resource/image/5f/c6/5fd10bd7916781554c4a61bd2yy2f8c6.jpg?wh=2900x2384\" alt=\"\"></p><p>我们用C++ Modules组装整个库，我先带你了解一下里面的模块有哪些。</p><ul>\n<li>asyncpp.core：核心的基础类型模块，主要用来定义基础的类型与concepts。</li>\n<li>asyncpp.task：通用异步任务模块，实现了主线程内的异步任务框架，包括queue、loop、coroutine和asyncify几个分区。</li>\n<li>asyncpp.io：异步I/O模块，实现了独立的异步I/O线程和任务处理框架，用于独立异步处理I/O，包括task、loop和asyncify几个分区。</li>\n<li>asyncpp.fs：异步文件系统模块，基于asyncpp.io模块实现了异步的文件系统处理函数。</li>\n</ul><!-- [[[read_end]]] --><p>对照示意图从下往上看，所有模块都是基于asyncpp.core这个基础类型模块实现的。而asyncpp.task是库的核心模块，asyncpp.io在该核心模块的基础上提供了异步I/O的支持。</p><p>有了清晰的模块划分，我们先从基础类型模块——asyncpp.core开始编写。</p><h2>基础类型模块</h2><p>基础类型模块提供了库中使用的基本类型的Concepts，因此我们重点关注这个concepts分区，实现在core/Concepts.cpp中。</p><pre><code class=\"language-c++\">export module asyncpp.core:concepts;\n&nbsp;\nimport &lt;type_traits&gt;;\n&nbsp;\nnamespace asyncpp::core {\n&nbsp;&nbsp;&nbsp; export template &lt;typename T&gt;\n&nbsp;&nbsp;&nbsp; concept Invocable = std::is_invocable_v&lt;T&gt;;\n}\n</code></pre><p>在这段代码中，我们定义了Invocable这个concept，用于判定T是否是可调用的。</p><p>这个concept定义的约束为std::is_invocable_v<t>，用于判定T()这个函数调用表达式是否合法。由于用户传入的类型可能是普通函数、成员函数、函数对象或者lambda表达式，因此这里不能用std::is_function_v，因为这个traits只支持普通函数，不支持其他的可作为函数调用的类型。</t></p><p>接下来我们还要定义基础类型模块的导出模块，代码在core/Core.cpp中。我们可以看到，代码中导入并重新导出了所有的分区。</p><pre><code class=\"language-c++\">export module asyncpp.core;\n\nexport import :concepts;\n</code></pre><p>基础类型模块的工作告一段落，接下来要实现的所有模块，我们都会直接或间接使用基础类型模块中的Concepts。</p><h2>任务调度模块</h2><p>接下来就到了重头戏——完成任务调度模块，这是库的核心模块。为了让你更直接地了解C++20以后可以怎么使用协程，接下来我们基于协程约定，实现异步任务的定义与调用。同时，你也会看到，协程的调度细节隐藏在封装的接口实现中，这样可以降低协程的使用门槛。</p><p>先说说设计思路。因为asyncpp主要用于I/O等任务而非计算任务，所以我们模仿了NodeJS的实现——在主线程中实现任务循环，所有的异步任务都会放入这个任务循环中执行，并通过循环实现协程的调度。</p><p>如果要实现真正的异步，需要结合另外的工作线程来执行需要异步化的任务，task模块中提供了异步任务的提交接口，提交后的实现我们在后续的I/O调度模块中完成。</p><p>现在，我们来实现任务调度模块的各个分区。</p><h3>queue分区</h3><p>首先我们看一下queue分区task/AsyncTaskQueue.cpp，这是一个任务队列的实现。</p><pre><code class=\"language-c++\">export module asyncpp.task:queue;\n&nbsp;\nimport &lt;functional&gt;;\nimport &lt;mutex&gt;;\nimport &lt;vector&gt;;\n&nbsp;\nnamespace asyncpp::task {\n&nbsp;\nexport struct AsyncTask {\n&nbsp;&nbsp;&nbsp; // 异步任务处理函数类型\n&nbsp;&nbsp;&nbsp; using Handler = std::function&lt;void()&gt;;\n&nbsp;\n&nbsp;&nbsp;&nbsp; // 异步任务处理函数\n&nbsp;&nbsp;&nbsp; Handler handler;\n};\n&nbsp;\nexport class AsyncTaskQueue {\npublic:\n&nbsp;&nbsp;&nbsp; static AsyncTaskQueue&amp; getInstance();\n&nbsp;\n&nbsp;&nbsp;&nbsp; void enqueue(const AsyncTask&amp; item) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; guard(_queueMutex);\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _queue.push_back(item);\n&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp; bool dequeue(AsyncTask* item) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; guard(_queueMutex);\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_queue.size() == 0) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *item = _queue.back();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _queue.pop_back();\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;\n&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp; size_t getSize() const {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return _queue.size();\n&nbsp;&nbsp;&nbsp; }\n&nbsp;\nprivate:\n&nbsp;&nbsp;&nbsp; // 支持单例模式，通过default修饰符说明构造函数使用默认版本\n&nbsp;&nbsp; &nbsp;AsyncTaskQueue() = default;\n&nbsp;&nbsp;&nbsp; // 支持单例模式，通过delete修饰符说明拷贝构造函数不可调用\n&nbsp;&nbsp;&nbsp; AsyncTaskQueue(const AsyncTaskQueue&amp;) = delete;\n&nbsp;&nbsp;&nbsp; // 支持单例模式，通过delete修饰符说明赋值操作符不可调用\n    AsyncTaskQueue&amp; operator=(const AsyncTaskQueue&amp;) = delete;\n&nbsp;\n&nbsp;&nbsp;&nbsp; // 异步任务队列\n&nbsp;&nbsp;&nbsp; std::vector&lt;AsyncTask&gt; _queue;\n&nbsp;&nbsp;&nbsp; // 异步任务队列互斥锁，用于实现线程同步，确保队列操作的线程安全\n&nbsp;&nbsp;&nbsp; std::mutex _queueMutex;\n};\n&nbsp;\nAsyncTaskQueue&amp; AsyncTaskQueue::getInstance() {\n&nbsp;&nbsp;&nbsp; static AsyncTaskQueue queue;\n&nbsp;\n&nbsp;&nbsp;&nbsp; return queue;\n}\n&nbsp;\n}\n</code></pre><p>这段代码的核心部分是AsyncTaskQueue类，主要实现了enqueue函数和dequeue函数。</p><p>enqueue函数负责将任务添加到任务队列尾部，这里我们用到了互斥锁来实现线程同步。</p><p>dequeue则是从任务队列头部获取任务，取出任务后会将任务数据从队列中清理掉，防止重复执行任务。这里同样用了互斥锁来实现线程同步，如果任务不存在会返回false；如果任务存在会将任务写入到参数传入的指针中并返回true。</p><h3>loop分区</h3><p>接下来是loop分区task/AsyncTaskLoop.cpp，实现了消息循环，我们会在loop分区使用刚才实现的queue分区，用作消息循环中的任务队列。后面是具体代码。</p><pre><code class=\"language-c++\">export module asyncpp.task:loop;\n&nbsp;\nimport :queue;\nimport &lt;cstdint&gt;;\nimport &lt;chrono&gt;;\n&nbsp;\nnamespace asyncpp::task {\n&nbsp;\nexport class AsyncTaskLoop {\npublic:\n&nbsp;&nbsp;&nbsp; // 常量，定义了任务循环的等待间隔时间（单位为毫秒）\n&nbsp;&nbsp;&nbsp; static const int32_t SLEEP_MS = 1000;\n&nbsp;\n&nbsp;&nbsp;&nbsp; static AsyncTaskLoop&amp; getInstance();\n&nbsp;&nbsp;&nbsp; static void start() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getInstance().startLoop();\n&nbsp;&nbsp;&nbsp; }\n&nbsp;\nprivate:\n&nbsp;&nbsp;&nbsp; // 支持单例模式，通过default修饰符说明构造函数使用默认版本\n&nbsp;&nbsp;&nbsp; AsyncTaskLoop() = default;\n&nbsp;&nbsp;&nbsp; // 支持单例模式，通过delete修饰符说明拷贝构造函数不可调用\n&nbsp;&nbsp;&nbsp; AsyncTaskLoop(const AsyncTaskLoop&amp;) = delete;\n&nbsp;&nbsp;&nbsp; // 支持单例模式，通过delete修饰符说明赋值操作符不可调用\n&nbsp;&nbsp;&nbsp; AsyncTaskLoop&amp; operator=(const AsyncTaskLoop&amp;) = delete;\n&nbsp;\n&nbsp;&nbsp;&nbsp; void startLoop() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (true) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loopExecution();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(SLEEP_MS));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp; void loopExecution() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AsyncTask asyncEvent;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!AsyncTaskQueue::getInstance().dequeue(&amp;asyncEvent)) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; asyncEvent.handler();\n&nbsp;&nbsp;&nbsp; }\n};\n&nbsp;\nAsyncTaskLoop&amp; AsyncTaskLoop::getInstance() {\n&nbsp;&nbsp;&nbsp; static AsyncTaskLoop eventLoop;\n&nbsp;\n&nbsp;&nbsp;&nbsp; return eventLoop;\n}\n&nbsp;\n}\n</code></pre><p>这段代码的核心是AsyncTaskLoop类，主要实现了start、startLoop和loopExecution这三个成员函数，我们依次来看看这些函数的作用。</p><p>start用于在当前线程启动任务循环，实现是调用startLoop，调用后当前线程会阻塞，直到出现需要执行的任务。</p><p>startLoop用来启动任务循环，其实现是一个循环，每次循环会调用loopExecution成员函数，然后通过this_thread的sleep睡眠等待一段时间，给其他线程让出CPU。</p><p>如果你足够细心，刚才看代码时可能已经注意到了，这里的时间定义成了一个常量。在真实的开发场景里，这个时间会很短，我们这里为了演示任务调度过程，特意将时间设置为1000ms，这样输出过程会更加明显。</p><p>loopExecution用来执行任务，其实现是从任务队列AsyncTaskQueue实例中获取最早的任务，如果任务不存在就直接返回。</p><h3>coroutine分区</h3><p>接下来是coroutine分区task/Coroutine.cpp，实现了C++协程约定的几个类型与相关接口，为<strong>使用协程进行任务调度提供关键支持</strong>。代码如下所示。</p><pre><code class=\"language-c++\">export module asyncpp.task:coroutine;\n&nbsp;\nimport &lt;coroutine&gt;;\nimport &lt;functional&gt;;\n&nbsp;\nnamespace asyncpp::task {\n&nbsp;&nbsp;&nbsp; // 协程类\n&nbsp;&nbsp;&nbsp; export struct Coroutine {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 协程Promise定义\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct promise_type {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Coroutine get_return_object() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ._handle = std::coroutine_handle&lt;promise_type&gt;::from_promise(*this)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::suspend_never initial_suspend() { return {}; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::suspend_never final_suspend() noexcept { return {}; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void return_void() {}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void unhandled_exception() {}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 协程的句柄，可用于构建Coroutine类，并在业务代码中调用接口进行相关操作\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::coroutine_handle&lt;promise_type&gt; _handle;\n&nbsp;&nbsp;&nbsp; };\n&nbsp;\n&nbsp;&nbsp;&nbsp; // AsyncTaskSuspender类型声明\n&nbsp;&nbsp;&nbsp; export template &lt;typename ResultType&gt;\n&nbsp;&nbsp;&nbsp; struct Awaitable;\n&nbsp;&nbsp;&nbsp; export using AsyncTaskResumer = std::function&lt;void()&gt;;\n&nbsp;&nbsp;&nbsp; export using CoroutineHandle = std::coroutine_handle&lt;Coroutine::promise_type&gt;;\n&nbsp;&nbsp;&nbsp; export template &lt;typename ResultType&gt;\n&nbsp;&nbsp;&nbsp; using AsyncTaskSuspender = std::function&lt;void(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Awaitable&lt;ResultType&gt;*, AsyncTaskResumer, CoroutineHandle&amp;\n&nbsp;&nbsp;&nbsp; )&gt;;\n&nbsp;\n&nbsp;&nbsp;&nbsp; // Awaitable类型定义（当任务函数返回类型不为void时）\n&nbsp;&nbsp;&nbsp; export template &lt;typename ResultType&gt;\n&nbsp;&nbsp;&nbsp; struct Awaitable {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // co_await时需要执行的任务，开发者可以在suspend实现中调用该函数执行用户期望的任务\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::function&lt;ResultType()&gt; _taskHandler;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 存储任务执行的结果，会在await_resume中作为co_await表达式的值返回\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ResultType _taskResult;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 存储开发者自定义的await_suspend实现，会在await_suspend中调用\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AsyncTaskSuspender&lt;ResultType&gt; _suspender;\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool await_ready() { return false; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void await_suspend(CoroutineHandle h) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _suspender(this, [h] { h.resume(); }, h);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ResultType await_resume() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return _taskResult;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; };\n&nbsp;\n&nbsp;&nbsp;&nbsp; // Awaitable类型定义（当任务函数返回类型为void时）\n&nbsp;&nbsp;&nbsp; export template &lt;&gt;\n&nbsp;&nbsp;&nbsp; struct Awaitable&lt;void&gt; {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // co_await时需要执行的任务，开发者可以在suspend实现中调用该函数执行用户期望的任务\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::function&lt;void()&gt; _taskHandler;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 存储开发者自定义的await_suspend实现，会在await_suspend中调用\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AsyncTaskSuspender&lt;void&gt; _suspender;\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool await_ready() { return false; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void await_suspend(CoroutineHandle h) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _suspender(this, [h] { h.resume(); }, h);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void await_resume() {}\n&nbsp;&nbsp;&nbsp; };\n}\n</code></pre><p>在这段代码中，我们定义了C++协程支持的几个关键类型。首先，是协程类型Coroutine，协程调用者一般需要通过该类型操作coroutine_handle，来实现协程的调度，该定义包含了嵌套类型promise_type和协程句柄变量_handle。</p><p>接着，在Coroutine中定义了Promise类型，该对象在协程生命周期中一直存在，因此可以在不同的线程或者函数之间传递协程的各类数据与状态。</p><p>类型中的大多数接口没有特殊行为，所以都用了默认实现（空函数）。其中比较特殊的是get_return_object，我们在上一讲说过，协程调用者调用协程时获取到的返回值就是该函数的返回值。</p><p>这里我们通过coroutine_handle的from_promise函数获取到promise对象对应的协程句柄，调用Coroutine的构造函数生成Coroutine对象并返回，因此协程函数的调用者获取到该对象后，可以根据业务控制调度协程。</p><p>接着，我们定义了CoroutineHandle类型，这是std::coroutine_handle的别名，也就是协程的句柄。</p><p>协程句柄是C++提供的唯一的协程标准类型，指向一次协程调用生成的协程帧，因此可以访问到存储在协程帧上的Promise对象。协程句柄提供了协程调度的标准函数，是协程调用者进行协程调度的基础。</p><p>由于该类型是一个泛型类（模板参数是Promise的类型），而且会在后续代码中频繁使用，为了方便，我们为std::coroutine_handle&lt;Coroutine:promise_type&gt;定义了一个别名CoroutineHandle。</p><p>最后，我们定义了Awaitable类型，在协程中使用co_await进行休眠时需要该类型支持。</p><p><img src=\"https://static001.geekbang.org/resource/image/de/e5/dee6df542089a39b82eb4984e263ebe5.jpg?wh=2625x695\" alt=\"\"></p><p>Awaitable对于实现协程调度至关重要，其中 <strong>await_resume</strong> 和 <strong>await_suspend</strong> 的实现是重点。我们在此做出进一步分析。</p><p><strong>首先，是await_resume的实现</strong>。假设用户需要通过co_await异步执行函数f，并在f结束后获取到f的返回值作为co_await表达式的值，也就是我们希望实现的效果是：</p><pre><code class=\"language-c++\">auto result = co_await Awaitable(f);\n</code></pre><p>当f执行结束后协程会被唤醒，并将f的返回值赋给result。<br>\n<img src=\"https://static001.geekbang.org/resource/image/8c/7e/8cebb650fb024fa6207bba6a37042c7e.jpg?wh=2625x695\" alt=\"\"></p><p>另外，考虑到函数f的返回类型为void的情况（相当于没有返回值），它与“返回值类型不为void”时的实现完全不同，不需要存储函数f的返回值。</p><p>因此，我在这里定义了一个Awaitable的特化版本——当函数f的返回类型为void时，会使用该版本的Awaitable类。在该版本中，不会存储函数f的返回值，await_resume的返回类型固定为void，并且不会返回任何值。</p><p><strong>接着，是await_suspend的实现</strong>，通过它，我们就能控制在“何时、何处”唤醒被co_await休眠的协程。</p><p>这里允许开发者通过AsyncTaskSuspender来实现await_suspend的具体行为。await_suspend中会调用开发者实现的函数，来唤醒休眠的协程。</p><p>AsyncTaskSuspender包含后面这三个参数，开发者可以利用这些参数实现不同的调度机制。</p><ol>\n<li>Awaiter对象指针：Awaitable<resulttype>*。</resulttype></li>\n<li>协程的唤醒函数：AsyncTaskResumer。</li>\n<li>协程的句柄：CoroutineHandle&amp;。</li>\n</ol><h3>asyncify分区</h3><p>接下来是asyncify分区task/Asyncify.cpp，该分区实现了asyncify工具函数，用于将一个普通的函数f转换成一个返回Awaitable对象的函数asyncF。通过这个分区实现的工具，可以让库的用户更容易使用我们在上一节实现的Coroutine。</p><p>开发者通过co_await调用asyncF，就可以实现函数f的异步调用，并在f执行完成后，重新唤醒协程。如果你了解过JavaScript，可以将其类比成ES6中的promsify。后面是代码实现。</p><pre><code class=\"language-c++\">export module asyncpp.task:asyncify;\n&nbsp;\nexport import :queue;\nexport import :loop;\nexport import :coroutine;\n&nbsp;\nimport asyncpp.core;\n&nbsp;\nnamespace asyncpp::task {\n&nbsp;&nbsp;&nbsp; using asyncpp::core::Invocable;\n&nbsp;\n&nbsp;&nbsp;&nbsp; // 默认的AsyncTaskSuspender（当任务函数返回类型不为void时）\n&nbsp;&nbsp;&nbsp; template &lt;typename ResultType&gt;\n&nbsp;&nbsp;&nbsp; void defaultAsyncAwaitableSuspend(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Awaitable&lt;ResultType&gt;* awaitable,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AsyncTaskResumer resumer,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CoroutineHandle&amp; h\n&nbsp;&nbsp;&nbsp; ) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; asyncTaskQueue = AsyncTaskQueue::getInstance();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; asyncTaskQueue.enqueue({\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .handler = [resumer, awaitable] {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; awaitable-&gt;_taskResult = awaitable-&gt;_taskHandler();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resumer();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });\n&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp; /* 默认的AsyncTaskSuspender（当任务函数返回类型为void时的特化版本）\n     * \n     * 当f的返回类型为void时，函数f没有返回值。因此，我们定义了一个函数返回类型为void的特化版本，\n     * 在该版本中构造的AsyncTask对象的handler调用用户函数f后，直接调用resumer唤醒协程，\n     * 不会将f的返回值存储到Awaitable对象中。\n    */\n&nbsp;&nbsp;&nbsp; template &lt;&gt;\n&nbsp;&nbsp;&nbsp; void defaultAsyncAwaitableSuspend&lt;void&gt;(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Awaitable&lt;void&gt;* awaitable,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AsyncTaskResumer resumer,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CoroutineHandle&amp; h\n&nbsp;&nbsp;&nbsp; ) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; asyncTaskQueue = AsyncTaskQueue::getInstance();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; asyncTaskQueue.enqueue({\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .handler = [resumer, awaitable] {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; awaitable-&gt;_taskHandler();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resumer();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });\n&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp; // 异步化工具函数，支持将普通函数f异步化\n&nbsp;&nbsp;&nbsp; export template &lt;Invocable T&gt;\n&nbsp;&nbsp;&nbsp; auto asyncify(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T taskHandler,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AsyncTaskSuspender&lt;std::invoke_result_t&lt;T&gt;&gt; suspender =\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defaultAsyncAwaitableSuspend&lt;std::invoke_result_t&lt;T&gt;&gt;\n&nbsp;&nbsp;&nbsp; ) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Awaitable&lt;std::invoke_result_t&lt;T&gt;&gt; {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ._taskHandler = taskHandler,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ._suspender = suspender\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };\n&nbsp;&nbsp;&nbsp; }\n}\n</code></pre><p>在这段代码中，我定义了两个版本的defaultAsyncAwaitableSuspend函数，它就是Coroutine模块中Awaitable类型所需的AsyncTaskSuspender函数，该函数的作用是在co_await休眠协程后，执行用户函数f和唤醒协程。</p><p>我们的实现其实很简单，就是构造一个AsyncTask对象并添加到AsyncTaskQueue中。AsyncTask对象的handler会执行用户函数f，将f的返回值存储到awaitable对象中，最后调用resumer唤醒协程。</p><p>接着，我们定义了asyncify模版函数，模板参数T必须符合Invocable约束，也就是必须可调用，对应了用户函数f的类型。该函数包含两个参数。</p><ol>\n<li>taskHandler：期望异步执行的函数f。</li>\n<li>suspender：Awaitable中用户可以自己设置的AsyncTaskSuspender函数。</li>\n</ol><p><img src=\"https://static001.geekbang.org/resource/image/50/y7/505ee7f7ec295e75bf27cee07c56dyy7.jpg?wh=2072x811\" alt=\"\"></p><h2>总结</h2><p>为了帮你解决难题，熟悉怎样编写满足C++协程约定的程序，我们实现了一个异步文件系统操作库中的任务调度模块。其中coroutine分区实现了C++协程约定的几个类型与相关接口，为使用协程进行任务调度提供关键支持。</p><p>一般来说，提供异步调用的库的底层实现各有不同，但是它们的目标是一致的，就是在某个消息循环上提供异步调用的基础设施。而我们选择使用C++ Coroutines来实现高性能异步调度能力。</p><p>在下一讲，我们将继续编程实战，使用这一讲实现的任务调度模块，继续实现基于协程的异步I/O调度。</p><h2>课后思考</h2><p>在目前的设计中，我们只支持co_await去等待函数执行完成，然后恢复执行。那么，在co_await表达式中，是否可以执行并等待另一个协程执行结束？如果不可以，该如何修改代码来实现这一功能呢？</p><p>不妨在这里分享你的答案，我们一同交流。下一讲见！</p>","neighbors":{"left":{"article_title":"08｜Coroutines：“零”开销降低异步编程复杂度","id":624931},"right":{"article_title":"10｜Coroutines实战（二）：异步文件操作库","id":626599}},"comments":[{"had_liked":false,"id":385856,"user_name":"李云龙","can_delete":false,"product_type":"c1","uid":3201926,"ip_address":"北京","ucode":"785924B16BE788","user_header":"https://static001.geekbang.org/account/avatar/00/30/db/86/51ec4c41.jpg","comment_is_top":false,"comment_ctime":1703516317,"is_pvip":false,"replies":[{"id":140887,"content":"是的，需要传递另一个协程，在另一个协程完成后才能done","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1704988786,"ip_address":"上海","comment_id":385856,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"关于课后思考题：我认为老师课件中的当前代码无法做到等待另一个协程执行结束，因为传递给await_suspend函数的协程句柄是当前协程的，所以无法获知另外一个协程的信息。如果要等待另一个协程执行结束，需要在Awaitable类中存储另外一个协程的句柄，然后defaultAysncAwaitableSuspend函数的第三个实参应该是被存储的另外一个协程的句柄。在defaultAysncAwaitableSuspend函数内部使用循环检查的方式，检查 h.done（） 是否为true，只有条件成立后，再调用 AsyncTaskResumer 。\n烦请老师批评指正","like_count":1,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635632,"discussion_content":"是的，需要传递另一个协程，在另一个协程完成后才能done","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704988786,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":393490,"user_name":"Steiner","can_delete":false,"product_type":"c1","uid":1622329,"ip_address":"浙江","ucode":"232C1C75207A1E","user_header":"https://static001.geekbang.org/account/avatar/00/18/c1/39/11904266.jpg","comment_is_top":false,"comment_ctime":1724037449,"is_pvip":false,"replies":[{"id":143564,"content":"推荐使用 Microsoft Visual Studio 2022，就目前来说，相对的，其对新标准的支持较好。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1730949632,"ip_address":"加拿大","comment_id":393490,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"我想问一下，课程中的代码是在哪个平台上运行，用哪种编译器","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653472,"discussion_content":"推荐使用 Microsoft Visual Studio 2022，就目前来说，相对的，其对新标准的支持较好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1730949632,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"加拿大","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":381427,"user_name":"常振华","can_delete":false,"product_type":"c1","uid":2062252,"ip_address":"广东","ucode":"D61B40E1CCEFD5","user_header":"","comment_is_top":false,"comment_ctime":1695195712,"is_pvip":false,"replies":[{"id":139105,"content":"这个写法是一个lambda表达式，是用lambda表达式构造一个匿名函数，然后将匿名函数对象复制给struct AsyncTask的handler成员。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1696255789,"ip_address":"上海","comment_id":381427,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":".handler = [resumer, awaitable] {\n    awaitable-&gt;_taskResult = awaitable-&gt;_taskHandler(); \n    resumer(); \n}\n这个写法是lamda表达式吗？然后赋值给struct AsyncTask的handler成员？","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":628926,"discussion_content":"这个写法是一个lambda表达式，是用lambda表达式构造一个匿名函数，然后将匿名函数对象复制给struct AsyncTask的handler成员。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1696255789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":367731,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1675519794,"is_pvip":false,"replies":[{"id":134079,"content":"是的，这里的通用异步任务模块运行在主线程中，这个主线程是看哪个线程启动这个异步任务循环，哪个线程启动就是我们这里说的主线程。\n\n如果你在调用者main函数所在线程启动这个循环，那么就是调用者程序的主线程。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1676030471,"ip_address":"上海","comment_id":367731,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"请问：“主线程内”是什么意思？\n文中有一句“asyncpp.task：通用异步任务模块，实现了主线程内的异步任务框架”。是说通用异步任务模块运行在主线程中吗？异步 I&#47;O 模块、异步文件系统模块是运行在其他线程吗？\n另外，“主线程”是“库”的主线程，不是调用者的主线程，对吗？","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":603250,"discussion_content":"是的，这里的通用异步任务模块运行在主线程中，这个主线程是看哪个线程启动这个异步任务循环，哪个线程启动就是我们这里说的主线程。\n\n如果你在调用者main函数所在线程启动这个循环，那么就是调用者程序的主线程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676030472,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}