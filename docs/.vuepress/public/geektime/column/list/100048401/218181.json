{"id":218181,"title":"04 | 状态检索：如何快速判断一个用户是否存在？","content":"<p>你好，我是陈东。</p><p>在实际工作中，我们经常需要判断一个对象是否存在。比如说，在注册新用户时，我们需要先快速判断这个用户ID是否被注册过；再比如说，在爬虫系统抓取网页之前，我们要判断一个URL是否已经被抓取过，从而避免无谓的、重复的抓取工作。</p><p>那么，对于这一类是否存在的状态检索需求，如果直接使用我们之前学习过的检索技术，有序数组、二叉检索树以及哈希表来实现的话，它们的检索性能如何呢？是否还有优化的方案呢？今天，我们就一起来讨论一下这些问题。</p><h2>如何使用数组的随机访问特性提高查询效率？</h2><p>以注册新用户时查询用户ID是否存在为例，我们可以直接使用有序数组、二叉检索树或者哈希表来存储所有的用户ID。</p><p>我们知道，无论是有序数组还是二叉检索树，它们都是使用二分查找的思想从中间元素开始查起的。所以，在查询用户ID是否存在时，它们的平均检索时间代价都是O(log n)，而哈希表的平均检索时间代价是O(1)。因此，如果我们希望能快速查询出元素是否存在，那哈希表无疑是最合适的选择。不过，如果从工程实现的角度来看的话，哈希表的查询过程还是可以优化的。</p><p>比如说，如果我们要查询的对象ID本身是正整数类型，而且ID范围有上限的话。我们就可以申请一个足够大的数组，让数组的长度超过ID的上限。然后，把数组中所有位置的值都初始化为0。对于存在的用户，我们<strong>直接将用户ID的值作为数组下标</strong>，将该位置的值从0设为1就可以了。</p><!-- [[[read_end]]] --><p>这种情况下，当我们查询一个用户ID是否存在时，会直接以该ID为数组下标去访问数组，如果该位置为1，说明该ID存在；如果为0，就说明该ID不存在。和哈希表的查找流程相比，这个流程就节省了计算哈希值得到数组下标的环节，并且直接利用数组随机访问的特性，在O(1)的时间内就能判断出元素是否存在，查询效率是最高的。</p><p>但是，直接使用ID作为数组下标会有一个问题：如果ID的范围比较广，比如说在10万之内，那我们就需要保证数组的长度大于10万。所以，这种方案的占用空间会很大。</p><p>而且，如果这个数组是一个int 32类型的整型数组，那么每个元素就会占据4个字节，用4个字节来存储0和1会是一个巨大的空间浪费。那我们该如何优化呢？你可以先想一想，然后我们一起来讨论。</p><h2>如何使用位图来减少存储空间？</h2><p>最直观的一个想法就是，使用最少字节的类型来定义数组。比如说，使用1个字节的char类型数组，或者使用bool类型的数组（在许多系统中，一个bool类型的元素也是1个字节）。它们和4个字节的int 32数组相比，空间使用效率提升了4倍，这已经算是不错的改善了。</p><p>但是，使用char类型的数组，依然是一个非常“浪费空间”的方案。因为表示0或者1，理论上只需要一个bit。所以，如果我们能以bit为单位来构建这个数组，那使用空间就是int 32数组的1/32，从而大幅减少了存储使用的内存空间。这种以bit为单位构建数组的方案，就叫作<strong>Bitmap</strong>，翻译为<strong>位图</strong>。</p><p>位图的优势非常明显，但许多系统中并没有以bit为单位的数据类型。因此，我们往往需要对其他类型的数组进行一些转换设计，使其能对相应的bit位的位置进行访问，从而实现位图。</p><p>我们以char类型的数组为例子。假设我们申请了一个1000个元素的char类型数组，每个char元素有8个bit，如果一个bit表示一个用户，那么1000个元素的char类型数组就能表示8*1000 = 8000个用户。如果一个用户的ID是11，那么位图中的第11个bit就表示这个用户是否存在的信息。</p><p>这种情况下，我们怎么才能快速访问到第11个bit呢？</p><p>首先，数组是以char类型的元素为一个单位的，因此，我们的第一步，就是要找到第11个bit在数组的第几个元素里。具体的计算过程：一个元素占8个bit，我们用11除以8，得到的结果是1，余数是3。这就代表着，第11个bit存在于第2个元素里，并且在第2个元素里的位置是第3个。</p><p>对于第2个元素的访问，我们直接使用数组下标[1]就可以在O(1)的时间内访问到。对于第2个元素中的第3个bit的访问，我们可以通过位运算，先构造一个二进制为00100000的字节（字节的第3位为1），然后和第2个元素做and运算，就能得知该元素的第3位是1还是0。这也是一个时间代价为O(1)的操作。这样一来，通过两次O(1)时间代价的查找，我们就可以知道第11个bit的值是0还是1了。<br>\n<img src=\"https://static001.geekbang.org/resource/image/70/85/7003f942bc4626ae74fd66badbb21f85.jpg?wh=2600*769\" alt=\"\"></p><center><span class=\"reference\">用户ID为11的位图定位</span></center><p>尽管位图相对于原始数组来说，在元素存储上已经有了很大的优化，但如果我们还想进一步优化存储空间，是否还有其他的优化方案呢？我们知道，<strong>一个数组所占的空间其实就是“数组元素个数*每个元素大小”</strong>。我们已经将每个元素大小压缩到了最小单位1个bit，如果还要进行优化，那么自然会想到优化“数组元素个数”。</p><p>没错，限制数组的长度是一个可行的方案。不过前面我们也说了，数组长度必须大于ID的上限。因此，如果我们希望将数组长度压缩到一个足够小的值之内，我们就需要使用哈希函数将大于数组长度的用户ID，转换为一个小于数组长度的数值作为下标。除此以外，使用哈希函数也带来了另一个优点，那就是我们不需要把用户ID限制为正整数了，它也可以是字符串。这样一来，压缩数组长度，并使用哈希函数，就是一个更加通用的解决方案。</p><p>但是我们也知道，数组压缩得越小，发生哈希冲突的可能性就会越大，如果两个元素A和B的哈希值冲突了，映射到了同一个位置。那么，如果我们查询A时，该位置的结果为1，其实并不能说明元素A一定存在。因此，如何在数组压缩的情况下缓解哈希冲突，保证一定的查询正确率，是我们面临的主要问题。</p><p>在第3讲中，我们讲了哈希表解决哈希冲突的两种常用方法：开放寻址法和链表法。开放寻址法中有一个优化方案叫“双散列”，它的原理是使用多个哈希函数来解决冲突问题。我们能否借鉴这个思想，在位图的场景下使用多个哈希函数来降低冲突概率呢？没错，这其实就是布隆过滤器（Bloom Filter）的设计思想。</p><p>布隆过滤器最大的特点，就是对一个对象使用多个哈希函数。如果我们使用了k个哈希函数，就会得到k个哈希值，也就是k个下标，我们会把数组中对应下标位置的值都置为1。布隆过滤器和位图最大的区别就在于，我们不再使用一位来表示一个对象，而是使用k位来表示一个对象。这样两个对象的k位都相同的概率就会大大降低，从而能够解决哈希冲突的问题了。<br>\n<img src=\"https://static001.geekbang.org/resource/image/08/cb/089de1531a75731a657ae2c6e55c55cb.jpg?wh=2600*979\" alt=\"\"></p><center><span class=\"reference\">Bloom filter 示例</span></center><p>但是，布隆过滤器的查询有一个特点，就是即使任何两个元素的哈希值不冲突，而且我们查询对象的k个位置的值都是1，查询结果为存在，这个结果也可能是错误的。这就叫作<strong>布隆过滤器的错误率</strong>。</p><p>我在下图给出了一个例子。我们可以看到，布隆过滤器中存储了x和y两个对象，它们对应的bit位被置为1。当我们查询一个不存在的对象z时，如果z的k个哈希值的对应位置的值正好都是1，z就会被错误地认定为存在。而且，这个时候，z和x，以及z和y，两两之间也并没有发生哈希冲突。<br>\n<img src=\"https://static001.geekbang.org/resource/image/7f/26/7f9a98a2e877b298c0be5b5c7b8a5626.jpg?wh=2600*946\" alt=\"\"></p><center><span class=\"reference\">Bloom filter 错误率示例</span></center><p>那遇到“可能存在”这样的情况，我们该怎么办呢？不要忘了我们的使用场景：我们希望用更小的代价快速判断ID是否已经被注册了。在这个使用场景中，就算我们无法确认ID是否已经被注册了，让用户再换一个ID注册，这也不会损害新用户的体验。在系统不要求结果100%准确的情况下，我们可以直接当作这个用户ID已经被注册了就可以了。这样，我们使用布隆过滤器就可以快速完成“是否存在”的检索。</p><p>除此之外，对于布隆过滤器而言，如果哈希函数的个数不合理，比如哈希函数特别多，布隆过滤器的错误率就会变大。因此，除了使用多个哈希函数避免哈希冲突以外，我们还要控制布隆过滤器中哈希函数的个数。有这样一个<strong>计算最优哈希函数个数的数学公式: 哈希函数个数k = (m/n) * ln(2)</strong>。其中m为bit数组长度，n为要存入的对象的个数。实际上，如果哈希函数个数为1，且数组长度足够，布隆过滤器就可以退化成一个位图。所以，我们可以认为“<strong>位图是只有一个特殊的哈希函数，且没有被压缩长度的布隆过滤器</strong>”。</p><h2>重点回顾</h2><p>好了，状态检索的内容我们就讲到这里。我们一起来总结一下，这一讲你要掌握的重点内容。</p><p>今天，我们主要解决了快速判断一个对象是否存在的问题。相比于有序数组、二叉检索树和哈希表这三种方案，位图和布隆过滤器其实更适合解决这类状态检索的问题。这是因为，在不要求100%判断正确的情况下，使用位图和布隆过滤器可以达到O(1)时间代价的检索效率，同时空间使用率也非常高效。</p><p>虽然位图和布隆过滤器的原理和实现都非常简单，但是在许多复杂的大型系统中都可以见到它们的身影。</p><p>比如，存储系统中的数据是存储在磁盘中的，而磁盘中的检索效率非常低，因此，我们往往会先使用内存中的布隆过滤器来快速判断数据是否存在，不存在就直接返回，只有可能存在才会去磁盘检索，这样就避免了为无效数据读取磁盘的额外开销。</p><p>再比如，在搜索引擎中，我们也需要使用布隆过滤器快速判断网站是否已经被抓取过，如果一定不存在，我们就直接去抓取；如果可能存在，那我们可以根据需要，直接放弃抓取或者再次确认是否需要抓取。<strong>你会发现，这种快速预判断的思想，也是提高应用整体检索性能的一种常见设计思路。</strong></p><h2>课堂讨论</h2><p>这节课的内容，你可以结合这道讨论题进一步加深理解：</p><p>如果位图中一个元素被删除了，我们可以将对应bit位置为0。但如果布隆过滤器中一个元素被删除了，我们直接将对应的k个bit位置为0，会产生什么样的问题呢？为什么？</p><p>欢迎在留言区畅所欲言，说出你的思考过程和最终答案。如果有收获，也欢迎把这篇文章分享给你的朋友。</p>","comments":[{"had_liked":false,"id":199961,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":false,"comment_ctime":1585523229,"is_pvip":true,"replies":[{"id":"74908","content":"你的思考很深入！<br>1.对于布隆过滤器的删除问题，的确无法直接删除。但也有带引用计数的布隆过滤器，存的不是0，1，而是一个计数。其实所有的设计都是trade off。应该视具体使用场景而定。比如一个带4个bit位计数器的布隆过滤器，相比于哈希表依然有优势。<br>2.布隆过滤器是否省空间，要看怎么比较。<br>布隆过滤器 vs 原始位图:<br>原始位图要存一个int 32的数，就要先准备好512m的空间的长数组。布隆过滤器不用这么长的数组，因此比原始位图省空间。<br>布隆过滤器 vs 哈希表:<br>假设布隆过滤器数组长度和哈希表一样。但是哈希表存的是一个int 32，而布隆过滤器存的是一个bit，因此比同样长度的哈希表省空间。<br>当然，如果哈希表也改为只存一个bit的数组，那么他们的大小是一样的。这时候就是你说的多个哈希函数的作用场景了。<br>其实，你会发现，只存一个bit的哈希表，其实也可以看做是只有一个哈希函数的布隆过滤器。很多时候，布隆过滤器，哈希表，还有位图，它们的边界是模糊的。我们最重要的是了解清楚他们的特点，知道在什么场景用哪种结构就好了。<br>3.roaring bitmap是一个优秀的设计。我在基础篇的加餐中会和大家分享。在这里，我也说一下它和布隆过滤器的差异:<br>布隆过滤器 vs roaring bitmap:<br>所有的设计都是trade off。roaring bitmap尽管压缩率很高，还支持精准查找，但是它放弃的是速度。高16位是采用二分查找，array container也是二分查找。因此，在这一点上布隆过滤器是有优势的。此外，它还不能保证压缩空间，它的空间会随着元素增多而变大，极端情况下恢复回bitmap。<br>而布隆过滤器保持了高效的查找能力和空间控制能力，但是放弃了精准查找能力，精准度会随着元素增多而下降。<br>因此，尽管都是对bitmap进行压缩，但是两者的设计思路不一样，使用场景也不同。在不要求精准，但是要求快速和省空间的场景下，布隆过滤器是不错的选择。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585542768,"ip_address":"","comment_id":199961,"utype":1}],"discussion_count":6,"race_medal":0,"score":"173384215069","product_id":100048401,"comment_content":"bitmap 是一个集合，每个元素在集合中有一个唯一不冲突的编号(用户自己保证，在数据库中这个编号可以是行号)，是双射关系。而布隆过滤器是一个不准确的集合，而且是一对多的关系，会发生冲突，也就是说布隆过滤器的为1的位可能代表多个元素，自然不能因为一个元素删除就把它干掉？，或者说他就不支持删除操作，感觉它要支持了，反而把它本身的优势给丢了。<br><br>1，其实对布隆过滤器是省了空间，我表示持怀疑态度，可能需要证明下，我可能更多的认为它是一种平衡单个hash 函数对数据分布有偏差性导致最差情况的数据冲突的概率大的一种方法。<br>2，bitmap 本身也有很多压缩方法，最有名的应该是roaringbitmap ，大家有兴趣可以了解下。<br>","like_count":41,"discussions":[{"author":{"id":1111899,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f7/5b/d2e7c2c4.jpg","nickname":"时隐时现","note":"","ucode":"DA4D622FF84920","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":257559,"discussion_content":"订阅了这么多门课程，我发现只有从回复中才能真正体验出作者的功力，本次课程作者的回复都很精彩，点个赞","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1588588718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489905,"discussion_content":"你的思考很深入！\n1.对于布隆过滤器的删除问题，的确无法直接删除。但也有带引用计数的布隆过滤器，存的不是0，1，而是一个计数。其实所有的设计都是trade off。应该视具体使用场景而定。比如一个带4个bit位计数器的布隆过滤器，相比于哈希表依然有优势。\n2.布隆过滤器是否省空间，要看怎么比较。\n布隆过滤器 vs 原始位图:\n原始位图要存一个int 32的数，就要先准备好512m的空间的长数组。布隆过滤器不用这么长的数组，因此比原始位图省空间。\n布隆过滤器 vs 哈希表:\n假设布隆过滤器数组长度和哈希表一样。但是哈希表存的是一个int 32，而布隆过滤器存的是一个bit，因此比同样长度的哈希表省空间。\n当然，如果哈希表也改为只存一个bit的数组，那么他们的大小是一样的。这时候就是你说的多个哈希函数的作用场景了。\n其实，你会发现，只存一个bit的哈希表，其实也可以看做是只有一个哈希函数的布隆过滤器。很多时候，布隆过滤器，哈希表，还有位图，它们的边界是模糊的。我们最重要的是了解清楚他们的特点，知道在什么场景用哪种结构就好了。\n3.roaring bitmap是一个优秀的设计。我在基础篇的加餐中会和大家分享。在这里，我也说一下它和布隆过滤器的差异:\n布隆过滤器 vs roaring bitmap:\n所有的设计都是trade off。roaring bitmap尽管压缩率很高，还支持精准查找，但是它放弃的是速度。高16位是采用二分查找，array container也是二分查找。因此，在这一点上布隆过滤器是有优势的。此外，它还不能保证压缩空间，它的空间会随着元素增多而变大，极端情况下恢复回bitmap。\n而布隆过滤器保持了高效的查找能力和空间控制能力，但是放弃了精准查找能力，精准度会随着元素增多而下降。\n因此，尽管都是对bitmap进行压缩，但是两者的设计思路不一样，使用场景也不同。在不要求精准，但是要求快速和省空间的场景下，布隆过滤器是不错的选择。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1585542768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194626,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3a/82/1ff83a38.jpg","nickname":"牛牛","note":"","ucode":"CFCE68B4F92209","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":224396,"discussion_content":"这样来看的话、其实是一种不追求完美的思想、很多方案都不完美、依然是优秀的方案、因为它们至少解决了某一个或一些场景的特定问题～、学习了、感谢～","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586302529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1088303,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9b/2f/db466c67.jpg","nickname":"HD","note":"","ucode":"3F61B901BB9245","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351380,"discussion_content":"不太明白这句话“原始位图要存一个int 32的数，就要先准备好512m的空间的长数组。”，为什么位图存一个 int32的数需要 512M的空间？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614254986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1123043,"avatar":"https://static001.geekbang.org/account/avatar/00/11/22/e3/510b69f9.jpg","nickname":"benny","note":"","ucode":"E2F30AF0C808D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1088303,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9b/2f/db466c67.jpg","nickname":"HD","note":"","ucode":"3F61B901BB9245","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371133,"discussion_content":"int 32 = 2 的32次方， 一个char是2的3次方 ， 所以需要2的（32-3）空间的数组，2的29次方就是2的九次方乘以2的10次方再乘以2的10次方 就是512m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619660856,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":351380,"ip_address":""},"score":371133,"extra":""}]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219528,"discussion_content":"大佬的回复很精彩！\n老师的回复很精彩！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585757871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205928,"user_name":"阿斯蒂芬","can_delete":false,"product_type":"c1","uid":1024164,"ip_address":"","ucode":"61D5E3BDA4EBC5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a0/a4/b060c723.jpg","comment_is_top":false,"comment_ctime":1586758925,"is_pvip":false,"replies":[{"id":"76931","content":"你的理解没错，其实我在几个评论中都有说，其实哈希表，位图，布隆过滤器的边界很模糊，可以相互转换。<br>布隆过滤器和和哈希表相比，有两个区别，一个是每个位置存储的是一个bit，不是一个具体value；另一个是同时使用k个哈希函数。<br>但如果我们将布隆过滤器和哈希表都改一下，比如说布隆过滤器的k取值为1，然后哈希表也不存具体value，而是存一个bit表示元素是否存在，那么它们就是完全一样了。你说这样的数据结构是叫做哈希表好?还是叫做布隆过滤器好?<br>因此，只要你能明白它们各自的特点，能在合适的场景使用合适的方案就好了。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1586761291,"ip_address":"","comment_id":205928,"utype":1}],"discussion_count":3,"race_medal":0,"score":"57421333773","product_id":100048401,"comment_content":"刚看完时有点“混乱”，搞不清楚哈希表、位图、布隆过滤器的核心区别在哪，翻了评论和老师解答后（特别是@峰)才逐渐明晰，区别核心的不同仍然是应用场景以及其中衍生的一个“阈值”：<br><br>老师讲的元素是否存在，比较学术风，换个业务场景来看，假设有个网站，用户id是64位长整整型，需要记录每天有哪些用户登陆了，假设用户总量1亿，日活有5千万，则如果使用普通的集合或者哈希表存储用户id，64*10^8=400M，这还是一天的登录数据，但是如果用位图，则是 1*10^8 = 12.5M 即可。400 &#47; 12.5 = 32，也就是老师讲的 1&#47;32 的空间消耗。<br><br>在这个场景下，位图看起来是吊打集合与散列表，但是如果日活只有可怜的10万，这时候重新计算，使用集合或散列表，64*10^8 = 800k，而位图则依然是12.5M。这时候位图被吊打，就是因为场景下其实有个关键的阈值：用户数据规模大小与日活大小。<br>总结来看，节省哈希函数的耗时，是位图固有的优势，而是否节省空间，则只有分析过数据的实际场景，才能决策出合适的数据存储方案，使检索达到空间和时间的最佳。<br><br>正好回复评论区@gogo同学问的什么语言有位图的实现：Redis的Bitmap就是位图实现的一种，而且还提供了位图的交集差集等api，值得一看。以上的场景也是参考Redis书籍描述的。<br><br>至于布隆过滤器，刚开始因为觉得既然都使用了哈希函数，那本质上和散列表不就是一样了？同样是刷了评论区才反应过来，重点在于K个哈希函数，不仅仅是在概率上降低了哈希冲突，而且因为需要K个位置来确定一个元素，所以可以用更小的范围来映射同样的数据规模，因此布隆过滤器在时间和空间的平衡上，感觉算是最折中的，不知这样理解是否合适，还望老师指点。<br><br>另外搬运Wiki上一段关于布隆过滤器优点的描述，我觉得切入点不错，还考虑到了（硬件以及数据安全性）：<br>相比于其它的数据结构，布隆过滤器在空间和时间方面都有巨大的优势。布隆过滤器存储空间和插入&#47;查询时间都是常数 O(k)。另外，散列函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。<br>","like_count":13,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491617,"discussion_content":"你的理解没错，其实我在几个评论中都有说，其实哈希表，位图，布隆过滤器的边界很模糊，可以相互转换。\n布隆过滤器和和哈希表相比，有两个区别，一个是每个位置存储的是一个bit，不是一个具体value；另一个是同时使用k个哈希函数。\n但如果我们将布隆过滤器和哈希表都改一下，比如说布隆过滤器的k取值为1，然后哈希表也不存具体value，而是存一个bit表示元素是否存在，那么它们就是完全一样了。你说这样的数据结构是叫做哈希表好?还是叫做布隆过滤器好?\n因此，只要你能明白它们各自的特点，能在合适的场景使用合适的方案就好了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586761291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1276613,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/gmP4Yh00MZPwNvr4UQdLeXaX3TVyZEEp195S3vD3Sfl1xz5jBr1474Mt6w5OPr0KsrnQObfLRy5PkKNFjSBiasA/132","nickname":"大头爸爸","note":"","ucode":"131E25DB04D222","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282912,"discussion_content":"写的很好。不过还是有一点不明白：为什么Bloom Filter用K个哈希函数就可以更省空间呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592117406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1024164,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a0/a4/b060c723.jpg","nickname":"阿斯蒂芬","note":"","ucode":"61D5E3BDA4EBC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1276613,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/gmP4Yh00MZPwNvr4UQdLeXaX3TVyZEEp195S3vD3Sfl1xz5jBr1474Mt6w5OPr0KsrnQObfLRy5PkKNFjSBiasA/132","nickname":"大头爸爸","note":"","ucode":"131E25DB04D222","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283125,"discussion_content":"我是这样理解的，假设有n个元素，理想情况下Bitmap需要n位来存储其状态（用于判断元素x是否存在)，因为位图本质上是单个哈希函数来决定元素位置的，这里可以理解为空间复杂度为O(n)\n而假设使用Bloom Filter，如果采用k个哈希函数，那么判断一个元素是否存在的时候，理想状态下，哈希函数能将每一位都利用上，就可以达到用n位空间实现大于n的元素状态存储。\n具体的例子：比如n=4位空间，Bitmap能表示4个元素状态，而Bloom Filter，假设使用k=2个哈希函数 h_a，h_b，理想情况下，h_a 和 h_b 的取值组合就是4个位里面选取任意不重复的2个位的所有可能，也就是 C(n,k)=C(4,2)=6\n因此，同样的空间，Bloom Filter 可能可以表示更多元素的状态。这是我最初理解的节省空间。\n但是考虑到哈希冲突，以及哈希分布均匀度，实际上要达到这种理想状态应该很难，不管对于普通的Bitmap还是Bloom Filter 都是如此，因此上述的空间节省只是作为纯逻辑上的理解，仅供参考。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592190936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":282912,"ip_address":""},"score":283125,"extra":""}]}]},{"had_liked":false,"id":233221,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1594263339,"is_pvip":false,"replies":[{"id":"86312","content":"是这样的，紧凑的bitmap其实是最省空间的，比bloomfilter和roaring bitmap都更省空间。<br>你的这个例子中，其实默认是“3亿个连续的数据紧凑地存在bitmap中，没有一丝空间浪费”。在这样的情况下，由于没有一丝空间浪费，因此，无论是使用bloomfilter，还是roaring bitmap，都不可能更省空间。<br>但是，如果不是“连续紧凑的”3亿个数据呢？比如说间隔很稀疏，要间隔十个元素才会出现一个值，那么你的bitmap就需要36mb*10=360mb才能存储这三亿个元素了。这就比你使用bloomfilter更多了。<br>因此，在数据不是连续紧凑出现的前提下，bloomfilter和roaring bitmap才能发挥它们的优势，反之，如果是连续紧凑的元素存储，直接使用bitmap更合适。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1594479100,"ip_address":"","comment_id":233221,"utype":1}],"discussion_count":1,"race_medal":0,"score":"53133870891","product_id":100048401,"comment_content":"请教老师一个问题<br>假如我有3亿个连续id，如果使用BitMap存储，需要消耗 3亿&#47;8&#47;1024&#47;1024 大约36MB<br>如果用 GuavaCache 的 BloomFilter，在默认误判率0.03的情况下，占用内存约261MB<br>BloomFilter&lt;CharSequence&gt; filter = BloomFilter.create(Funnels.stringFunnel(Charsets.UTF_8), expectedInsertions);<br>其中 expectedInsertions 代表预估数量即3亿，通过查看源码，BloomFilter 根据预估数量和误判率计算bit数组的公式 m=-n*ln(fpp)&#47;(log2)^2 <br>long m = (long) (-expectedNum * Math.log(fpp) &#47; (Math.log(2) * Math.log(2))); expectedNum就是3亿，计算出来的m为2189532251，大于3亿，这个结果感觉说不通，BloomFilter 通过使用多个哈希函数，应该需要的数组长度小于3亿才对呀，而BloomFilter是用long型的数组实现，所以会根据计算出来的m计算long数组的大小int longNum = Ints.checkedCast(LongMath.divide(m, 64, RoundingMode.CEILING));计算出来是34211442，占用内存是261MB<br>所以，同样3亿个连续id，使用Guava 的BloomFilter占用的内存反而比使用BitMap内存大，通过学习这篇文章，我觉得结果应该是相反的，我有点蒙了，请老师帮忙指点下","like_count":12,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500947,"discussion_content":"是这样的，紧凑的bitmap其实是最省空间的，比bloomfilter和roaring bitmap都更省空间。\n你的这个例子中，其实默认是“3亿个连续的数据紧凑地存在bitmap中，没有一丝空间浪费”。在这样的情况下，由于没有一丝空间浪费，因此，无论是使用bloomfilter，还是roaring bitmap，都不可能更省空间。\n但是，如果不是“连续紧凑的”3亿个数据呢？比如说间隔很稀疏，要间隔十个元素才会出现一个值，那么你的bitmap就需要36mb*10=360mb才能存储这三亿个元素了。这就比你使用bloomfilter更多了。\n因此，在数据不是连续紧凑出现的前提下，bloomfilter和roaring bitmap才能发挥它们的优势，反之，如果是连续紧凑的元素存储，直接使用bitmap更合适。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594479100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201380,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1585758047,"is_pvip":false,"replies":[{"id":"75354","content":"对的，数据变化不频繁的情况下，周期性重建就好。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585790605,"ip_address":"","comment_id":201380,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35945496415","product_id":100048401,"comment_content":"看了大家的留言，老师的回复，感慨一下：原来布隆过滤器不能随便删，可以周期性重构数据！","like_count":8,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490317,"discussion_content":"对的，数据变化不频繁的情况下，周期性重建就好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585790605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200081,"user_name":"徐洲更","can_delete":false,"product_type":"c1","uid":1314643,"ip_address":"","ucode":"F8A323CB732D05","user_header":"https://static001.geekbang.org/account/avatar/00/14/0f/53/92a50f01.jpg","comment_is_top":false,"comment_ctime":1585540565,"is_pvip":true,"replies":[{"id":"74914","content":"是的。bloom filter的删除会很麻烦。我们一般用在数据不删除的场景中（比如文中举的注册ID的场景）。<br>如果真要删除，可以使用上一课提到的re－hash的思路重新生成。（因为bloom filter本来就允许错误率，因此可以周期性重新生成）。<br>此外，还可以将bloomfilter改造成带引用计数的。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585545014,"ip_address":"","comment_id":200081,"utype":1}],"discussion_count":3,"race_medal":0,"score":"31650311637","product_id":100048401,"comment_content":"因为同一个ID经过哈希函数会得到多个位置，不同的ID可能会有一些位置overlap。如果ID A和B刚好有一个位置重合，那么删除A的时候，如果直接将它对应的位置清零，就导致B也被认为是不存在。因此bloom filter删除操作很麻烦","like_count":7,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489936,"discussion_content":"是的。bloom filter的删除会很麻烦。我们一般用在数据不删除的场景中（比如文中举的注册ID的场景）。\n如果真要删除，可以使用上一课提到的re－hash的思路重新生成。（因为bloom filter本来就允许错误率，因此可以周期性重新生成）。\n此外，还可以将bloomfilter改造成带引用计数的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585545014,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1276613,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/gmP4Yh00MZPwNvr4UQdLeXaX3TVyZEEp195S3vD3Sfl1xz5jBr1474Mt6w5OPr0KsrnQObfLRy5PkKNFjSBiasA/132","nickname":"大头爸爸","note":"","ucode":"131E25DB04D222","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282913,"discussion_content":"这里bloom filter的删除是指删什么？删掉某个数据吗？还是把某些已经是1的bit清零?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592117675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1314643,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/53/92a50f01.jpg","nickname":"徐洲更","note":"","ucode":"F8A323CB732D05","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217361,"discussion_content":"学到了，原来还可以这样子操作呀！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585549002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205673,"user_name":"真名不叫黄金","can_delete":false,"product_type":"c1","uid":1174066,"ip_address":"","ucode":"FB611FC98F5BA7","user_header":"https://static001.geekbang.org/account/avatar/00/11/ea/32/1fd102ec.jpg","comment_is_top":false,"comment_ctime":1586699828,"is_pvip":false,"replies":[{"id":"76898","content":"你说得很对。许多系统设计中，都会尽量避免删除操作，因此，对于这类系统而言，搭配布隆过滤器是非常合适的。<br>至于数据删除问题，其实就和lsm树一样，采用批量更新的方式就好，对于布隆过滤器而言，就是重新生成一次。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1586739067,"ip_address":"","comment_id":205673,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27356503604","product_id":100048401,"comment_content":"如果布隆过滤器要支持删除，那么就必须支持计数，那么相应地会增加占用存储空间，因为不能再用一个bit表示了。<br>因此不需要支持删除的布隆过滤器是将它节省空间的优势发挥到了极致，在基于LSM Tree的数据库中，就会使用布隆过滤器，这种基于追加写的数据结构本身查询会变慢，但恰巧由于它是追加写，不存在删除问题，因此可以生成布隆过滤器加速查找，因此布隆过滤器与LSM Tree是一个很适合的组合～","like_count":6,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491549,"discussion_content":"你说得很对。许多系统设计中，都会尽量避免删除操作，因此，对于这类系统而言，搭配布隆过滤器是非常合适的。\n至于数据删除问题，其实就和lsm树一样，采用批量更新的方式就好，对于布隆过滤器而言，就是重新生成一次。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586739067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":249881,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1600841908,"is_pvip":true,"replies":[{"id":"91846","content":"当使用count bloomfilter的时候，bit位的取值越大，count溢出的概率就会越低。<br>bit的位数的溢出率是有公式的(这里不好编辑公式，可以网上搜)。当位数取4的时候，溢出率小于1.37*(10^－15)*m，其中m为数组大小。这是一个很小的概率了。因此一般取4就好了。而如果想要更小，比如取2，那按公式推出来溢出率其实非常高。因此一般都会取4。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1601391020,"ip_address":"","comment_id":249881,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14485743796","product_id":100048401,"comment_content":"cbf可以支持删除操作，但是取多少bit是怎么计算的？","like_count":3,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506044,"discussion_content":"当使用count bloomfilter的时候，bit位的取值越大，count溢出的概率就会越低。\nbit的位数的溢出率是有公式的(这里不好编辑公式，可以网上搜)。当位数取4的时候，溢出率小于1.37*(10^－15)*m，其中m为数组大小。这是一个很小的概率了。因此一般取4就好了。而如果想要更小，比如取2，那按公式推出来溢出率其实非常高。因此一般都会取4。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601391020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208286,"user_name":"CycleGAN","can_delete":false,"product_type":"c1","uid":1679661,"ip_address":"","ucode":"9FD04813911A02","user_header":"https://static001.geekbang.org/account/avatar/00/19/a1/2d/599e9051.jpg","comment_is_top":false,"comment_ctime":1587315573,"is_pvip":false,"replies":[{"id":"77790","content":"谢谢支持。由于篇幅限制，我相信文章中总会有没有说清楚的地方，因此评论区是我认为一个很重要的补充环节。<br>此外，我还会在部落中会对文章的内容进行一些简单的延伸描述。这部分内容可以通过我的个人主页看到。希望对大家有所帮助。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1587339337,"ip_address":"","comment_id":208286,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10177250165","product_id":100048401,"comment_content":"老师非常有条理脉络清晰，评论也非常认真，受益匪浅","like_count":2,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492402,"discussion_content":"谢谢支持。由于篇幅限制，我相信文章中总会有没有说清楚的地方，因此评论区是我认为一个很重要的补充环节。\n此外，我还会在部落中会对文章的内容进行一些简单的延伸描述。这部分内容可以通过我的个人主页看到。希望对大家有所帮助。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587339337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229031,"user_name":"mickey","can_delete":false,"product_type":"c1","uid":1051663,"ip_address":"","ucode":"8B490C2DDE4010","user_header":"https://static001.geekbang.org/account/avatar/00/10/0c/0f/93d1c8eb.jpg","comment_is_top":false,"comment_ctime":1592882388,"is_pvip":false,"replies":[{"id":"84525","content":"是的。因此布隆过滤器不能直接删除元素。如果真有删除的需求，就需要重新生成布隆过滤器。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1592911830,"ip_address":"","comment_id":229031,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5887849684","product_id":100048401,"comment_content":"如果位图中一个元素被删除了，我们可以将对应 bit 位置为 0。但如果布隆过滤器中一个元素被删除了，我们直接将对应的 k 个 bit 位置为 0，会产生什么样的问题呢？为什么？<br><br>因为这样可能导致其他存在的元素的bit值置为0，从而导致已经存在的元素被后续判断为不存在。","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499303,"discussion_content":"是的。因此布隆过滤器不能直接删除元素。如果真有删除的需求，就需要重新生成布隆过滤器。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592911830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225215,"user_name":"ヾ(◍°∇°◍)ﾉﾞ","can_delete":false,"product_type":"c1","uid":1044175,"ip_address":"","ucode":"89545632BDA56E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJOBwR7MCVqwZbPA5RQ2mjUjd571jUXUcBCE7lY5vSMibWn8D5S4PzDZMaAhRPdnRBqYbVOBTJibhJg/132","comment_is_top":false,"comment_ctime":1591685035,"is_pvip":false,"replies":[{"id":"82915","content":"一般用户注册的ID是未知的，但是会有一个范围。比如说，如果系统有限定最多只会有一万个用户的话，那么ID就一定在一万之内;再比如说，如果用户的ID的数据类型是int32的话，那么最大值也就是2^32，用一个512m字节的位图就肯定可以表示。<br>因此，我们可以通过ID的范围，来提前生成好足够大的数组或位图，这样就可以直接使用ID作为数组下标，而不用担心数组越界问题。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1591690111,"ip_address":"","comment_id":225215,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5886652331","product_id":100048401,"comment_content":"用户的id作为数组下标，需要id事先被约定过已知的吧？一般用户注册的id未知的吧，那么怎么事先会有一个已用户id作为下标的数组呢？不是很理解。望老师在细说一下","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497777,"discussion_content":"一般用户注册的ID是未知的，但是会有一个范围。比如说，如果系统有限定最多只会有一万个用户的话，那么ID就一定在一万之内;再比如说，如果用户的ID的数据类型是int32的话，那么最大值也就是2^32，用一个512m字节的位图就肯定可以表示。\n因此，我们可以通过ID的范围，来提前生成好足够大的数组或位图，这样就可以直接使用ID作为数组下标，而不用担心数组越界问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591690111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215679,"user_name":"睿本MOP","can_delete":false,"product_type":"c1","uid":1668783,"ip_address":"","ucode":"333071A5EBC94D","user_header":"https://static001.geekbang.org/account/avatar/00/19/76/af/0cf7e850.jpg","comment_is_top":false,"comment_ctime":1589076867,"is_pvip":false,"replies":[{"id":"79830","content":"你好，对于64位的long类型的ID，如果想使用位图的话，那么需要分段和进行索引。建议使用我在加餐1中介绍的roaring bitmap(官方有提供64位的版本)，你可以参考一下roaring bitmap是如何在检索效率和存储空间之间做平衡的。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1589092466,"ip_address":"","comment_id":215679,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5884044163","product_id":100048401,"comment_content":"请问，在分布式系统中， id雪花算法生成的的20长度的long  这种情况下  无法用bitmap， 请问有好的解决方案吗","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494523,"discussion_content":"你好，对于64位的long类型的ID，如果想使用位图的话，那么需要分段和进行索引。建议使用我在加餐1中介绍的roaring bitmap(官方有提供64位的版本)，你可以参考一下roaring bitmap是如何在检索效率和存储空间之间做平衡的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589092466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204591,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1586425638,"is_pvip":false,"replies":[{"id":"76493","content":"位图:<br>1.原始位图的确很耗空间。因此会有各种压缩技术出现<br>2.位图，哈希，还有布隆过滤器的边界其实很模糊。我们不用去强行划界限和下定义。如果你的key是可能重复的，那么你把这个key作为位图下标那么就有可能是冲突的。因此不用去定义位图是否不会冲突。<br>3.位图操作的确是使用位运算实现增删查的。<br>布隆过滤器:<br>rehash具体做的时候，其实是另一个进程重新生成一个新的布隆过滤器，然后替换旧的就可以了。<br><br>此外，bitmap和布隆过滤器并不是基础数据结构，Java中应该没有原生支持。不过网上有很多实现版本。你可以找找。arraycontainer是roaring bitmap中的内容。你要往后看到加餐。建议你按课程顺序一步一步学，因为课程的内容组织是有递进关系的。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1586436116,"ip_address":"","comment_id":204591,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5881392934","product_id":100048401,"comment_content":"<br>看了老师和其他同学的回复<br><br>那用户id来举例判断这个id是否存在:<br>位图：<br>1. 用户id是正整数的时候，可以用bitMap存储，bitMap 是一对一的存储，不清楚用户id的分布范围，可以采用包含所有正整数长度的数组，大小为512MB, 那这样的话，一次申请下来一直允许，会不会很耗费空间?<br>2. 对于bitMap为一对一的话，那bitMap是不是就不会冲突呢，也就是说bitMap是准确的?<br>3. 针对bitMap， 增加id=7的用户是否存在用异或运算吧 bitMap[7] = bitMap[7] ^ 1？ 删除 bitMap[7] = bitMap[7] &amp; 0 用与运算？ 查询 bitMap[7] = bitMap[7] &amp; 1 用与运算吧？<br><br>布隆过滤器：<br>1. 布隆过滤器 采用多次hash， 计算得到几个不同的位，受到hash冲突的影响，布隆过滤器可能会误判。<br>2. 新增第7个用户，hash m 次，得到m 个不同的位，置为1。删除的时候，看到老师回复其他同学，有两种方案:<br>a. 对当前位采用引用计数，当存的时候当前为为1，那计数器就+1； 删除的时候根据引用计数器做-1操作，直至引用计数器为0 对当前位置0。<br>b. 删除时re-hash， 那这样的话，当布隆过滤器的数组很大的时候，是不是会有点慢呢？<br><br>另外：<br>1. bitMap 和 布隆过滤器 在java的那里有实现啊<br>2. 老师提到的 针对布隆过滤器 引用计数 和 rehash的方法，我们在哪里可以看到啊，java哪里有具体的实现啊？<br>3. 还有您提到的ArrayContainer是在哪里出现的啊？<br><br>恳请老师告知，感谢陈东老师！","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491225,"discussion_content":"位图:\n1.原始位图的确很耗空间。因此会有各种压缩技术出现\n2.位图，哈希，还有布隆过滤器的边界其实很模糊。我们不用去强行划界限和下定义。如果你的key是可能重复的，那么你把这个key作为位图下标那么就有可能是冲突的。因此不用去定义位图是否不会冲突。\n3.位图操作的确是使用位运算实现增删查的。\n布隆过滤器:\nrehash具体做的时候，其实是另一个进程重新生成一个新的布隆过滤器，然后替换旧的就可以了。\n\n此外，bitmap和布隆过滤器并不是基础数据结构，Java中应该没有原生支持。不过网上有很多实现版本。你可以找找。arraycontainer是roaring bitmap中的内容。你要往后看到加餐。建议你按课程顺序一步一步学，因为课程的内容组织是有递进关系的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586436116,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204132,"user_name":"eureka","can_delete":false,"product_type":"c1","uid":1643631,"ip_address":"","ucode":"47D3EB2A8212B4","user_header":"https://static001.geekbang.org/account/avatar/00/19/14/6f/19386a94.jpg","comment_is_top":false,"comment_ctime":1586338816,"is_pvip":false,"replies":[{"id":"76296","content":"其实哈希冲突也是一种错误率，而且是大家都很好理解的错误率。你可以这么想:一个只有一个哈希函数的布隆过滤器，由于存在哈希冲突，a和b的hash值相同，那么如果系统中存着a，但是我们查询b的时候，查询到的结果是“存在”。那这不就是错误率了么？<br>之所以要强调布隆过滤器的“错误率”，是因为即使哈希值不冲突，依然结果会有错，这个是布隆过滤器的特点。我文中x，y，z的例子就是一个说明。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1586345914,"ip_address":"","comment_id":204132,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5881306112","product_id":100048401,"comment_content":"为什么允许布隆过滤器的错误率，而不能容许允许哈希冲突呢","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491084,"discussion_content":"其实哈希冲突也是一种错误率，而且是大家都很好理解的错误率。你可以这么想:一个只有一个哈希函数的布隆过滤器，由于存在哈希冲突，a和b的hash值相同，那么如果系统中存着a，但是我们查询b的时候，查询到的结果是“存在”。那这不就是错误率了么？\n之所以要强调布隆过滤器的“错误率”，是因为即使哈希值不冲突，依然结果会有错，这个是布隆过滤器的特点。我文中x，y，z的例子就是一个说明。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586345914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355730,"user_name":"袁蕴旭","can_delete":false,"product_type":"c1","uid":1100369,"ip_address":"北京","ucode":"94B1016A5F7980","user_header":"https://static001.geekbang.org/account/avatar/00/10/ca/51/180b8b89.jpg","comment_is_top":false,"comment_ctime":1661698998,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661698998","product_id":100048401,"comment_content":"有个问题不太理解，布隆过滤器，有多个hash函数，那么数组中不会很快都被置为1么？这样布隆过滤器就没用了吧<br><br>使用布隆过滤器，是因为一个hash函数，容易冲突，误判率高吧？hash容易冲突的花，说明装载因子已经变高了，这种情况下，看上去很容易就出现上述问题呀","like_count":0},{"had_liked":false,"id":350234,"user_name":"放不下荣华富贵","can_delete":false,"product_type":"c1","uid":2053679,"ip_address":"","ucode":"9FE29C22B9ABE3","user_header":"https://static001.geekbang.org/account/avatar/00/1f/56/2f/4518f8e1.jpg","comment_is_top":false,"comment_ctime":1656674979,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656674979","product_id":100048401,"comment_content":"连干4章，看了内容和评论，我觉得这是一份被低估的极客时间学习教程。","like_count":0},{"had_liked":false,"id":335057,"user_name":"刘德聪","can_delete":false,"product_type":"c1","uid":1316662,"ip_address":"","ucode":"2968605D077072","user_header":"https://static001.geekbang.org/account/avatar/00/14/17/36/3d8e86e6.jpg","comment_is_top":false,"comment_ctime":1645276656,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645276656","product_id":100048401,"comment_content":"我按照我的理解，大概整理 哈希表， 位图， 布隆过滤器 三者区别。<br>共同点： 本质都是一个数组。<br>区别有三点。<br>1. 使用多少hash函数<br>   一般来说哈希表，位图使用一个hash函数(除非有冲突)， 布隆过滤器使用多个hash函数。<br>2. 存储大小<br>    一般哈希表存储一个元素至少存储需一个字节(bool), bitmap存储一个元素需一个bit， 布隆过滤器存储一个元素小于一个bit。<br>3.  检测精度<br>    哈希表，位图都是精准匹配， 布隆过滤器是模糊匹配（错在一定错误率）<br>","like_count":0},{"had_liked":false,"id":330742,"user_name":"墨眉无锋","can_delete":false,"product_type":"c1","uid":2891795,"ip_address":"","ucode":"FFB1A26FE49D3E","user_header":"https://static001.geekbang.org/account/avatar/00/2c/20/13/71179a6c.jpg","comment_is_top":false,"comment_ctime":1642141739,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642141739","product_id":100048401,"comment_content":"有这样一个计算最优哈希函数个数的数学公式: 哈希函数个数 k = (m&#47;n) * ln(2)--工业生产环境中，对象n的个数往往是无法预估的，因此哈希函数的个数是不是动态变化，意味着布隆过滤器频繁重构？","like_count":0},{"had_liked":false,"id":297244,"user_name":"吴小智","can_delete":false,"product_type":"c1","uid":1310798,"ip_address":"","ucode":"C7C9F58B5C9F7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","comment_is_top":false,"comment_ctime":1623392767,"is_pvip":false,"replies":[{"id":"108448","content":"是的。如果写入失败就意味着找不到。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1624422287,"ip_address":"","comment_id":297244,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1623392767","product_id":100048401,"comment_content":"如果写入一个用户，没有往布隆过滤器注册或和注册失败了，那是不是就一直都找不到这个用户了？","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521771,"discussion_content":"是的。如果写入失败就意味着找不到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624422287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":287238,"user_name":"森林木","can_delete":false,"product_type":"c1","uid":1220089,"ip_address":"","ucode":"79A06FCC43673B","user_header":"https://static001.geekbang.org/account/avatar/00/12/9d/f9/b98d9c40.jpg","comment_is_top":false,"comment_ctime":1617851195,"is_pvip":true,"replies":[{"id":"104734","content":"是的。这其实和散列表的开放寻址法的问题是一样的。因此通过这个案例，你也可以更好地了解这两种数据结构的关联关系，做到知识的融会贯通。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1618538706,"ip_address":"","comment_id":287238,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1617851195","product_id":100048401,"comment_content":"bloom filter里如果直接删除位可能会影响其他数据的检索，比如两个数同时有一位是1。","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518243,"discussion_content":"是的。这其实和散列表的开放寻址法的问题是一样的。因此通过这个案例，你也可以更好地了解这两种数据结构的关联关系，做到知识的融会贯通。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618538706,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":259324,"user_name":"蚂蚁码代码","can_delete":false,"product_type":"c1","uid":1482973,"ip_address":"","ucode":"6B285A3DC334B3","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/dd/3fccd15e.jpg","comment_is_top":false,"comment_ctime":1604680694,"is_pvip":false,"replies":[{"id":"94578","content":"欢迎留言和讨论。沟通交流会帮助我们更深刻地理解内容。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1605018766,"ip_address":"","comment_id":259324,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1604680694","product_id":100048401,"comment_content":"留言区很不错，看了留言区和老师的回复，也学到了不少东西","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508907,"discussion_content":"欢迎留言和讨论。沟通交流会帮助我们更深刻地理解内容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605018766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253564,"user_name":"云韵","can_delete":false,"product_type":"c1","uid":1025622,"ip_address":"","ucode":"3DE26DBAAAEDE6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a6/56/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1602778422,"is_pvip":true,"replies":[{"id":"93182","content":"因为CPU处理的最小数据单位是字节(byte)，而不是bit，因此，如果我们想知道一个字节中第三个bit是否是1，是没办法一个一个bit去检查的(只能检查一个字节)。<br>那既然字节是最小的数据处理单位，对于字节中的第几位是什么值的判断就需要借助位运算来对字节进行处理了。步骤如下:<br>1.用位运算指令生成一个特殊的字节(比如说00100000，第三位为1，表示要检查第三位)<br>2.将这个字节和待检查的第二个元素(也是一个字节)进行and位运算，这样会得到位运算结果。<br>3.位运算结果得到的字节的值，如果是0，意味着第二个元素的第三位是0，否则是1。<br>你会发现，上面三步，每一步的操作对象都是字节。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1603440563,"ip_address":"","comment_id":253564,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1602778422","product_id":100048401,"comment_content":"&quot;对于第 2 个元素中的第 3 个 bit 的访问，我们可以通过位运算，先构造一个二进制为 00100000 的字节（字节的第 3 位为 1），然后和第 2 个元素做 and 运算，就能得知该元素的第 3 位是 1 还是 0&quot; 这句话不太理解，麻烦老师可以解答一下","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507106,"discussion_content":"因为CPU处理的最小数据单位是字节(byte)，而不是bit，因此，如果我们想知道一个字节中第三个bit是否是1，是没办法一个一个bit去检查的(只能检查一个字节)。\n那既然字节是最小的数据处理单位，对于字节中的第几位是什么值的判断就需要借助位运算来对字节进行处理了。步骤如下:\n1.用位运算指令生成一个特殊的字节(比如说00100000，第三位为1，表示要检查第三位)\n2.将这个字节和待检查的第二个元素(也是一个字节)进行and位运算，这样会得到位运算结果。\n3.位运算结果得到的字节的值，如果是0，意味着第二个元素的第三位是0，否则是1。\n你会发现，上面三步，每一步的操作对象都是字节。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603440563,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240683,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1597033466,"is_pvip":false,"replies":[{"id":"89007","content":"非常棒！学完后能融会贯通，在合适的场景使用了合适的技术方案，还自己总结了文章。这样日积月累，相信你的技术能力和系统化思考能力会更上一层楼。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1597113318,"ip_address":"","comment_id":240683,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1597033466","product_id":100048401,"comment_content":"学以致用，学完专栏在工作中用到了，谢谢老师<br>https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;0TIbF8bjFQ5O1gqmaLqLWw","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503524,"discussion_content":"非常棒！学完后能融会贯通，在合适的场景使用了合适的技术方案，还自己总结了文章。这样日积月累，相信你的技术能力和系统化思考能力会更上一层楼。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597113318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204651,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1586436308,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586436308","product_id":100048401,"comment_content":"哦，对，加餐还没看😂<br><br>谢谢陈老师悉心回复，希望咱们学完了，还能考个期末试啥的。<br>😂😂😂","like_count":0},{"had_liked":false,"id":200251,"user_name":"刘凯","can_delete":false,"product_type":"c1","uid":1350608,"ip_address":"","ucode":"EFDC932CAE61A6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9b/d0/86aee34c.jpg","comment_is_top":false,"comment_ctime":1585563173,"is_pvip":false,"replies":[{"id":"74933","content":"你可以看我文中的例子想一想，x和y有共同的位，因此，如果删除x时，把x对应的3个bit位都改为0，就会影响y的查询。因此，对于布隆过滤器，不能直接删除。<br>一般来说，我们可以周期性重建布隆过滤器解决这个问题。<br>算法是不容易。但是不着急，慢慢来，一步一步扎扎实实学，你会收获得更多。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585565471,"ip_address":"","comment_id":200251,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585563173","product_id":100048401,"comment_content":"增加可以容忍误判，错误的判断用户存在，换个账号注册就行了，那么删除也会存在误判，可能将真正的用户没有删除掉，这可就不可取了，老师，我蒙对没，算法好头疼","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489972,"discussion_content":"你可以看我文中的例子想一想，x和y有共同的位，因此，如果删除x时，把x对应的3个bit位都改为0，就会影响y的查询。因此，对于布隆过滤器，不能直接删除。\n一般来说，我们可以周期性重建布隆过滤器解决这个问题。\n算法是不容易。但是不着急，慢慢来，一步一步扎扎实实学，你会收获得更多。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585565471,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200080,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1585540511,"is_pvip":true,"replies":[{"id":"74912","content":"是的。所以布隆过滤器不能直接删除。如果真的发生了删除，可以用类似re－hash的机制重新生成。<br>此外，一些场景会将布隆过滤器改造为带引用计数的结构。通过一个小数值的count进行计数。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585544351,"ip_address":"","comment_id":200080,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585540511","product_id":100048401,"comment_content":"位图 一个位置就只有一个元素使用，布隆过滤器一个位置可能多个元素都会使用","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489935,"discussion_content":"是的。所以布隆过滤器不能直接删除。如果真的发生了删除，可以用类似re－hash的机制重新生成。\n此外，一些场景会将布隆过滤器改造为带引用计数的结构。通过一个小数值的count进行计数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585544351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200050,"user_name":"千里之行","can_delete":false,"product_type":"c1","uid":1792692,"ip_address":"","ucode":"B2A09E8CA0E059","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLEGtB7lUzH66b3nibVu3Xat4C0Wfp0umU3slsN32TF3icBwDOpShgdzMhaLW9z5LDFg3TTh0H62qAA/132","comment_is_top":false,"comment_ctime":1585537020,"is_pvip":false,"replies":[{"id":"74913","content":"的确，一般来说布隆过滤器是不能直接删除的。它适用于数据不删除的场景（比如文中举的注册id的场景）。如果真有删除需求，可以像前一课学过的re－hash一样，重新生成。<br>此外，删除频繁的场景下，还可以将布隆过滤器带上计数器。就是将一个bit改为4个bit，可以存一个数。<br>尽管空间变大了，但是依然比哈希表存一个int 32的元素更省空间。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585544751,"ip_address":"","comment_id":200050,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585537020","product_id":100048401,"comment_content":"会造成其他元素存在状态的错误判断，因为多个对象可能共用一个元素。但是极端情况下，甚至有可能一个对象对应的K个元素都与其他对象共用，这种情况下不知道该怎么办了，请老师帮忙解答一下，谢谢","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489930,"discussion_content":"的确，一般来说布隆过滤器是不能直接删除的。它适用于数据不删除的场景（比如文中举的注册id的场景）。如果真有删除需求，可以像前一课学过的re－hash一样，重新生成。\n此外，删除频繁的场景下，还可以将布隆过滤器带上计数器。就是将一个bit改为4个bit，可以存一个数。\n尽管空间变大了，但是依然比哈希表存一个int 32的元素更省空间。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585544751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200025,"user_name":"与你一起学算法","can_delete":false,"product_type":"c1","uid":1318001,"ip_address":"","ucode":"A7E03B3E41828E","user_header":"https://static001.geekbang.org/account/avatar/00/14/1c/71/f7a7f70f.jpg","comment_is_top":false,"comment_ctime":1585533979,"is_pvip":false,"replies":[{"id":"74911","content":"布隆过滤器的确是无法直接删除的。要删除的话，有两种思路，一种就是重新生成（和re－hash一个思路）。另一种就是你说的引用计数。<br>其实引用计数是可行的。它的确性能会比原始的布隆过滤器差，但依然好于哈希表。因为我们对于引用计数，完全可以用少数几个bit位来记录，比如说4个比特位就能记录到16。<br>这样的存一个4bit计数值的布隆过滤器，依然会比存int 32的哈希表更省空间。<br>所有的设计都是要根据具体场景灵活变通。因此，如果应用场景真的有频繁删除的需求，那么这样一种结构也是可以考虑的。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585544228,"ip_address":"","comment_id":200025,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1585533979","product_id":100048401,"comment_content":"对于布隆过滤器，删除元素时如果将对应的k个元素全部设置为0的话，会影响其他元素的判断，我想到一个方法，就是对于每一个数组中每一位，再设置一个标志count，用于记录出现1得次数，删除元素时将count减1，如果count为0的话，再将1设置为0。但是这样做的话，存储count不是又需要花费存储空间，这与布隆过滤器的设计目的不就冲突了吗？想知道布隆过滤器对于删除元素时如何实现的？希望老师解答。","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489922,"discussion_content":"布隆过滤器的确是无法直接删除的。要删除的话，有两种思路，一种就是重新生成（和re－hash一个思路）。另一种就是你说的引用计数。\n其实引用计数是可行的。它的确性能会比原始的布隆过滤器差，但依然好于哈希表。因为我们对于引用计数，完全可以用少数几个bit位来记录，比如说4个比特位就能记录到16。\n这样的存一个4bit计数值的布隆过滤器，依然会比存int 32的哈希表更省空间。\n所有的设计都是要根据具体场景灵活变通。因此，如果应用场景真的有频繁删除的需求，那么这样一种结构也是可以考虑的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585544228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"一步","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217304,"discussion_content":"传统的布隆过滤器是不支持删除的，首先要删除一个元素，就要确定该元素在布隆过滤器中是存在的，单单这点就无法满足。 如果非要删除，就要使用变形的布隆过滤器了或者重新生成布隆过滤器","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585540955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200006,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1585531996,"is_pvip":false,"replies":[{"id":"74909","content":"总结得很好！<br>对于第五个问题，如何确定大小:<br>如果是原始位图，假设id是int 32，如果你不清楚数值分布范围，那么只能覆盖所有int 32的取值区间。这时候的位图大小是512m。<br>如果是布隆过滤器，你需要预估你的用户数量，<br>此外，还要设置一个你能接受的错误率p，使用这个公式:m =－n ln p &#47; （ln 2）^2 ，可以算出来bit 位数组m的大小。<br>","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585543820,"ip_address":"","comment_id":200006,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585531996","product_id":100048401,"comment_content":"1.bitmap和bloomfilter都是为了判断状态存在的。<br>2.bitmap只有一个位置用来判断状态<br>3.bloomfilter有多个位置用来判断状态<br>4.针对bloomfilter来说若果不所在一定不存在，存在不一定存在(因为hash冲突，可能是另外的元素状态)<br>5.如何根据用户数量来确定bitmap或者bloomfilter的bit数组的大小呢？","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489916,"discussion_content":"总结得很好！\n对于第五个问题，如何确定大小:\n如果是原始位图，假设id是int 32，如果你不清楚数值分布范围，那么只能覆盖所有int 32的取值区间。这时候的位图大小是512m。\n如果是布隆过滤器，你需要预估你的用户数量，\n此外，还要设置一个你能接受的错误率p，使用这个公式:m =－n ln p / （ln 2）^2 ，可以算出来bit 位数组m的大小。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585543820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}