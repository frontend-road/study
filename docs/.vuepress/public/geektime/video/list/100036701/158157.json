{"id":158157,"title":"24 | 源码剖析：接收数据","content":"<p><strong>课件和Demo地址</strong><br>\n<a href=\"https://gitee.com/geektime-geekbang/geek_netty\">https://gitee.com/geektime-geekbang/geek_netty</a></p>","comments":[{"had_liked":false,"id":159087,"user_name":"冬渐暖","can_delete":false,"product_type":"c3","uid":1586800,"ip_address":"","ucode":"907E41AAE9A36C","user_header":"https://static001.geekbang.org/account/avatar/00/18/36/70/00122b24.jpg","comment_is_top":false,"comment_ctime":1575536286,"is_pvip":false,"replies":[{"id":61945,"content":"1 你估计看错了类，所以你没有看懂，你看的那个类估计是DefaultMaxBytesRecvByteBufAllocator\n所以我用中文注释了过那个类：\n“&#47;&#47;无人调用，加一个@Deprecated标识下”\n2 io.netty.channel.AdaptiveRecvByteBufAllocator.HandleImpl#readComplete会尝试缩小，缩小比例不完全一样（以512为界限，有2种）：一种是减小1倍，一种是减小16\n3 &quot;什么是16次最优，不是其它的2的幂次方倍?&quot;我意思这个本身不是问题，因为写32的话，别人也会问为什么不是16，“雨露均沾”是说给别人读的机会，所以要控制中的次数。\n你每次笔记记得挺细致的，哈哈","user_name":"作者回复","user_name_real":"stroller","uid":1638649,"ctime":1576658973,"ip_address":"","comment_id":159087,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"读数据技巧：1.和省内存一样，提前猜测下一次要装的大小\n2.一直读到没有或者别人不满意为止(贪心)\n\n读数据：接收OP_READ事件，然后对数据进行处理\n\n处理这些数据的流程：1.创建个初始化为1024的byteBuffer来装channel的数据，如果没装够就记下这一次的，想下下次要分配的大小（allocHandle有个guess和reset的方法）\n        2.触发pipeline.fireChannelRead(byteBuf)把读取到的数据传播出去，将事件开始在pipeline中传递。如果读完了的话就跑路，没有的话就扩容来继续把数据读到没有或者直到读了16次(给别人机会)\n需要注意的地方是：1.scoket是可以使一个应用从网络中读取和写入数据；ServerSocket是等待客户端的请求，一旦获得一个连接请求，就创建一个Socket示例来与客户端进行通信。 \n所以NioServerSocketChannel read()是创建连接，NioSocketChannel read()是读数据，\n2.一次OP_READ事件可能有多个读数据传播操作\n\n\n我的疑问是，alloc自适应大小不是发生在每次读完之后根据有没有读满才扩容吗？应该只有扩容没有缩小啊。。。。难道是这次读完了之后，如果连续两次都发现自己没满，就缩小吗？这个缩小的比例又是多少。。。\n我发现取下次大小是按照maxBytesPerIndividualRead和本次读的大小  两者的最小值，但是maxBytesPerIndividualRead我没看到赋值的地方(maxBytesPerReadPair方法和maxBytesPerIndividualRead方法)有被其它地方引用到啊\n你说的雨露均沾，我还是没明白为什么是16次最优，不是其它的2的幂次方倍??","like_count":7,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476942,"discussion_content":"1 你估计看错了类，所以你没有看懂，你看的那个类估计是DefaultMaxBytesRecvByteBufAllocator\n所以我用中文注释了过那个类：\n“//无人调用，加一个@Deprecated标识下”\n2 io.netty.channel.AdaptiveRecvByteBufAllocator.HandleImpl#readComplete会尝试缩小，缩小比例不完全一样（以512为界限，有2种）：一种是减小1倍，一种是减小16\n3 &amp;quot;什么是16次最优，不是其它的2的幂次方倍?&amp;quot;我意思这个本身不是问题，因为写32的话，别人也会问为什么不是16，“雨露均沾”是说给别人读的机会，所以要控制中的次数。\n你每次笔记记得挺细致的，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576658973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178120,"user_name":"Sonny721","can_delete":false,"product_type":"c3","uid":1104291,"ip_address":"","ucode":"C95DD306BFBE54","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/a3/2856b5b5.jpg","comment_is_top":false,"comment_ctime":1581590390,"is_pvip":false,"replies":[{"id":69672,"content":"不会的，后面的数据还会触发读事件，继续新的一波读取。","user_name":"作者回复","user_name_real":"stroller","uid":1638649,"ctime":1582004608,"ip_address":"","comment_id":178120,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师您好，每次读取1024个大小数据，读取16次，如果发送的数据大于1024*16，多余数据丢失了？","like_count":3,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483673,"discussion_content":"不会的，后面的数据还会触发读事件，继续新的一波读取。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582004608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1318581,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epU0V5NLFTZx2FqM0V3ticYUN20W9Fnico3gCWwRWT5MoB70XCTMEaJxicX0lbZwicjVm4dKmAg6iaq33w/132","nickname":"韩振环","note":"","ucode":"4721164C059E11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383907,"discussion_content":"您的意思是一条超大数据 可能产生多个读事件？那我怎么知道多个事件属于一条消息呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626278495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1046562,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/22/a59136c2.jpg","nickname":"Linton","note":"","ucode":"7918113F03FD44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1318581,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epU0V5NLFTZx2FqM0V3ticYUN20W9Fnico3gCWwRWT5MoB70XCTMEaJxicX0lbZwicjVm4dKmAg6iaq33w/132","nickname":"韩振环","note":"","ucode":"4721164C059E11","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583042,"discussion_content":"后续有半包粘包handler","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1659882213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":383907,"ip_address":"中国香港","group_id":0},"score":583042,"extra":""}]}]},{"had_liked":false,"id":166077,"user_name":"公号-彤哥读源码","can_delete":false,"product_type":"c3","uid":1239881,"ip_address":"","ucode":"C0D16E1BA12DA0","user_header":"https://static001.geekbang.org/account/avatar/00/12/eb/49/bd914b5f.jpg","comment_is_top":false,"comment_ctime":1577375355,"is_pvip":false,"replies":[{"id":63323,"content":"直接在已有的handler里或者新的handler里，实现channelActive这个方法:调用ctx带的write方法写欢迎信息。","user_name":"作者回复","user_name_real":"stroller","uid":1638649,"ctime":1577408019,"ip_address":"","comment_id":166077,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师，我想问下，如何实现当客户端建立连接的时候服务端立马主动给客户端发送一个消息？而不是等客户端发送消息之后再发送消息。我举个例子，比如聊天室系统，当某人加入聊天室的时候立马给他发送一条欢迎消息，这时候客户端还没有发送任何消息，只建立了连接。","like_count":3,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479386,"discussion_content":"直接在已有的handler里或者新的handler里，实现channelActive这个方法:调用ctx带的write方法写欢迎信息。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577408019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146187,"user_name":"姚远","can_delete":false,"product_type":"c3","uid":1680082,"ip_address":"","ucode":"AB278EF7581440","user_header":"https://static001.geekbang.org/account/avatar/00/19/a2/d2/1d1ae570.jpg","comment_is_top":false,"comment_ctime":1572449121,"is_pvip":false,"replies":[{"id":56570,"content":"一次可能读到多个完整的消息，所以传下去有必要，这样至少前面完整的消息能及时处理，一次也可能读不完，传下去也没必要，一方面，后面的处理器会帮你存起来这些半包数据，另外你可以写一些处理器做些别的事情，总体思想还是有数据就往外扔，而不是死等着，因为这是一个数据流，等意义也不大","user_name":"作者回复","user_name_real":"Geek_9bc307","uid":1638649,"ctime":1572540578,"ip_address":"","comment_id":146187,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师 我想请问一下 pipeline.fireChanlRead(byteBuf)方法的意义是啥呢 一次读取可能不能把所有客户端发送的内容都读到呀。传播下去pipeline里的handlers 也处理不了呀","like_count":3,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472744,"discussion_content":"一次可能读到多个完整的消息，所以传下去有必要，这样至少前面完整的消息能及时处理，一次也可能读不完，传下去也没必要，一方面，后面的处理器会帮你存起来这些半包数据，另外你可以写一些处理器做些别的事情，总体思想还是有数据就往外扔，而不是死等着，因为这是一个数据流，等意义也不大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572540578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1566688,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJSgia4NAMN7qM8w8A5LNwo8bY6zLBxGfpH5ECebaf4rDEqWZdRQVadhCXibmAR971maZVLtsWBc3cA/132","nickname":"xxcupid","note":"","ucode":"70437984614CFC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":249764,"discussion_content":"Frame Decode部分发现如果“满载而归”，即数据可能没完全读完，就会在此handler中终止掉传播链，不会再继续传递fireChannelRead了，直到下个包来到，该Decode handler发现数据完整了，可以decode了，才会向下继续传递fireChannelRead\n/**\n     * Get {@code numElements} out of the {@link CodecOutputList} and forward these through the pipeline.\n     */\n    static void fireChannelRead(ChannelHandlerContext ctx, CodecOutputList msgs, int numElements) {\n        for (int i = 0; i < numElements; i ++) {\n            ctx.fireChannelRead(msgs.getUnsafe(i));\n        }\n    }\n这里数据完整了，numElements才大于0，才会继续向下传播fireChannelRead","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587960585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1439908,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/IPdZZXuHVMibwfZWmm7NiawzeEFGsaRoWjhuN99iaoj5amcRkiaOePo6rH1KJ3jictmNlic4OibkF4I20vOGfwDqcBxfA/132","nickname":"鱼向北游","note":"","ucode":"580EC7DCE57E9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41692,"discussion_content":"前面讲过半包和粘包的解码 应该是会走到那里","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572487730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176950,"user_name":"密码123456","can_delete":false,"product_type":"c3","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1581234965,"is_pvip":false,"replies":[{"id":69667,"content":"不读完，还会触发读事件的，所以还是能处理到的，只是说把这次机会（否则一直读下去，别的连接就没有什么机会读到了）让出去了。","user_name":"作者回复","user_name_real":"stroller","uid":1638649,"ctime":1582004052,"ip_address":"","comment_id":176950,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"有个问题，如果读了16次还没有读完。怎么办？","like_count":1,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483258,"discussion_content":"不读完，还会触发读事件的，所以还是能处理到的，只是说把这次机会（否则一直读下去，别的连接就没有什么机会读到了）让出去了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582004052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1442588,"avatar":"https://static001.geekbang.org/account/avatar/00/16/03/1c/c9fe6738.jpg","nickname":"Kvicii.Y","note":"","ucode":"446BFA633569EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":231943,"discussion_content":"是让给其他的Socket继续读取吗？allocHandle.continueReading()这个循坏依旧继续对吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586840155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153372,"user_name":"Geek_cyy","can_delete":false,"product_type":"c3","uid":1561474,"ip_address":"","ucode":"5FAB0E666F4F08","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/HZn8Cl8PFrzRNaePhfAMCtiankNG4yf9VmRukH3gzVtsOogq5n4b9ZAFNHThniaXmsibibX17wTZ8kCvKkibges8efA/132","comment_is_top":false,"comment_ctime":1574225831,"is_pvip":false,"replies":[{"id":59111,"content":"分两种情况：\n1 对于同一个连接而言，实际上收到的数据顺序是按顺序的，因为都是同一个线程（NioEventLoop）来处理的；\n2 而如果不同连接，那就不一定了，它不能保证NioEventLoop的处理是按你发送的顺序来。因为他们不定是同一个NioEventLoop，每个NioEventLoop处理速度可能因工作量不同而不同。","user_name":"作者回复","user_name_real":"Geek_9bc307","uid":1638649,"ctime":1574313483,"ip_address":"","comment_id":153372,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师，多次读，多次fire读时间，怎么确保后面的业务处理器，获取到的数据先后顺序是不变的呢？","like_count":1,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475140,"discussion_content":"分两种情况：\n1 对于同一个连接而言，实际上收到的数据顺序是按顺序的，因为都是同一个线程（NioEventLoop）来处理的；\n2 而如果不同连接，那就不一定了，它不能保证NioEventLoop的处理是按你发送的顺序来。因为他们不定是同一个NioEventLoop，每个NioEventLoop处理速度可能因工作量不同而不同。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574313483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189784,"user_name":"NoBody","can_delete":false,"product_type":"c3","uid":1173766,"ip_address":"","ucode":"72E1B4FCDA2469","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/06/038a9cea.jpg","comment_is_top":false,"comment_ctime":1584548915,"is_pvip":false,"replies":[{"id":78841,"content":"嗯，多搞搞就好了，搞到最后，大家都还是不是完全懂的，但是都会好点的，包括我自己也是这样。所以你放心加油搞吧。哈哈","user_name":"作者回复","user_name_real":"stroller","uid":1638649,"ctime":1588057278,"ip_address":"","comment_id":189784,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"硬着头皮用了下班时间花了三天，看了这三节的源码，然后自己走了好多好多次。终于有点大概的概念了。过程太艰难了。现在好点了。","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487792,"discussion_content":"嗯，多搞搞就好了，搞到最后，大家都还是不是完全懂的，但是都会好点的，包括我自己也是这样。所以你放心加油搞吧。哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588057278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176963,"user_name":"密码123456","can_delete":false,"product_type":"c3","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1581237404,"is_pvip":false,"replies":[{"id":68865,"content":"丢到一个独立的线程池去做，不然都是顺序处理的了，怎么单独线程池，第五章会介绍，到时候您在看看，有问题再沟通。谢谢","user_name":"作者回复","user_name_real":"stroller","uid":1638649,"ctime":1581388721,"ip_address":"","comment_id":176963,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"同一个连接，对多次读事件怎么并发处理的？","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483261,"discussion_content":"丢到一个独立的线程池去做，不然都是顺序处理的了，怎么单独线程池，第五章会介绍，到时候您在看看，有问题再沟通。谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581388721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173158,"user_name":"我已经设置了昵称","can_delete":false,"product_type":"c3","uid":1364034,"ip_address":"","ucode":"ED672C5EBDBDC4","user_header":"https://static001.geekbang.org/account/avatar/00/14/d0/42/6fd01fb9.jpg","comment_is_top":false,"comment_ctime":1579441850,"is_pvip":false,"replies":[{"id":67179,"content":"嗯，那就好，有些节就不能完全做到，只能说尽量做到如此，谢谢！","user_name":"作者回复","user_name_real":"stroller","uid":1638649,"ctime":1579488980,"ip_address":"","comment_id":173158,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师这节课讲的比较好，现类比现实中的场景，再介绍源码。很容易理解","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481980,"discussion_content":"嗯，那就好，有些节就不能完全做到，只能说尽量做到如此，谢谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579488980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158839,"user_name":"成都小郭","can_delete":false,"product_type":"c3","uid":1493899,"ip_address":"","ucode":"4399AA8C64DF21","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/hWjwsc6FgZfNkKiacOSUZicscNGFgdqvoo08QFQlfrg39srZJlZicbBP9zsLcDnKAkBfia2lZoKJ8h7QwTYiboiaRT6g/132","comment_is_top":false,"comment_ctime":1575462333,"is_pvip":false,"replies":[{"id":61250,"content":"可以查看下你的线程模型有没有问题（后面的第五章也会提及，IO型的业务要独立出线程池），然后这个问题需要查很多因素，具体可以\n参考上次做直播的ppt说到的一个类似问题（第九个问题）：\nhttps:&#47;&#47;github.com&#47;geektime-geekbang&#47;geek_netty&#47;\n\n如果还有疑问，或者不清楚，可以继续提个问题。谢谢\n\n","user_name":"作者回复","user_name_real":"傅健","uid":1638649,"ctime":1575959718,"ip_address":"","comment_id":158839,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师，我在线上遇到了netty读取数据延迟很高，几秒到十几秒。。排查了一下，怀疑是服务器聊天类消息推送过多，导致io线程被占用，一直执行写事件。。请问我这个分析有问题吗，另外除了优化推送次数，还有什么优化手段吗","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476868,"discussion_content":"可以查看下你的线程模型有没有问题（后面的第五章也会提及，IO型的业务要独立出线程池），然后这个问题需要查很多因素，具体可以\n参考上次做直播的ppt说到的一个类似问题（第九个问题）：\nhttps://github.com/geektime-geekbang/geek_netty/\n\n如果还有疑问，或者不清楚，可以继续提个问题。谢谢\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575959718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1493899,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/hWjwsc6FgZfNkKiacOSUZicscNGFgdqvoo08QFQlfrg39srZJlZicbBP9zsLcDnKAkBfia2lZoKJ8h7QwTYiboiaRT6g/132","nickname":"成都小郭","note":"","ucode":"4399AA8C64DF21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":83739,"discussion_content":"最后确认还是线程模型的问题，read的业务线程是另外起了一个线程池，但是在创建连接的时候是直接使用的io线程处理的，里面一个getHostname方法会有阻塞问题.   谢谢老师啦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576460707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158757,"user_name":"南秋同学","can_delete":false,"product_type":"c3","uid":1420957,"ip_address":"","ucode":"E1A08773B512DC","user_header":"https://static001.geekbang.org/account/avatar/00/15/ae/9d/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1575447007,"is_pvip":false,"replies":[{"id":61371,"content":"一般情况(你问的情况)，op_read一直注册在，不是重新注册，也不需要重新注册。重新注册的场景是出现在自己主动取消读监听后，又重新注册时，比如流量整形的读暂停到读恢复。正常没有开启各种复杂特性时都是一直注册在，所以只要有数据，就自动处理各种handler。","user_name":"作者回复","user_name_real":"stroller","uid":1638649,"ctime":1576091174,"ip_address":"","comment_id":158757,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"老师解析源码非常的细致，赞！\n有一个疑问：如果Channel或者说Pipeline中的所有Handler都执行完了，会重新注册可读事件（OP_READ）吗？或者说处理完后是怎么处理的？","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476837,"discussion_content":"一般情况(你问的情况)，op_read一直注册在，不是重新注册，也不需要重新注册。重新注册的场景是出现在自己主动取消读监听后，又重新注册时，比如流量整形的读暂停到读恢复。正常没有开启各种复杂特性时都是一直注册在，所以只要有数据，就自动处理各种handler。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576091174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154064,"user_name":"飞翔","can_delete":false,"product_type":"c3","uid":1068571,"ip_address":"","ucode":"65AF6AF292DAD6","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/1b/f4b786b9.jpg","comment_is_top":false,"comment_ctime":1574374235,"is_pvip":false,"replies":[{"id":59276,"content":"是的，你可以通过参数调整大点，或者对于io型的业务最好独立出一个线程池来做，参考第五章，下周三更新。","user_name":"作者回复","user_name_real":"Geek_9bc307","uid":1638649,"ctime":1574427487,"ip_address":"","comment_id":154064,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"我想问一下 netty的线程模型， 我们有一个bossnioeventloopgroup 里边有一个nioeventloop 负责接受连接， 我们有一个workeventloopgroup负责接收channel的读写请求，这里边有cpu*2 个nioeventloop，假设cpu是2个，那么也就是4个nioeventloop， 每个eventloop一次只能处理一个channel的读写请求嘛？ 也就是eventloop 获取一个channel的读请求，之后读取，channelhandle 处理数据 都是在这个eventloop的线程里，那么这样能同时处理的请求太少了呀","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475367,"discussion_content":"是的，你可以通过参数调整大点，或者对于io型的业务最好独立出一个线程池来做，参考第五章，下周三更新。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574427487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153554,"user_name":"Standly","can_delete":false,"product_type":"c3","uid":1181055,"ip_address":"","ucode":"805CC5784D3F76","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/7f/a7df049a.jpg","comment_is_top":false,"comment_ctime":1574257792,"is_pvip":false,"replies":[{"id":59043,"content":"处理业务那节就介绍了，简单说就是：寻找pipeline中下一个具有执行资格的handler然后来执行。因为不是所有的hanlder都具有资格，比如你触发的是读事件，那专门服务于写事件的handler就不需要执行。","user_name":"作者回复","user_name_real":"Geek_9bc307","uid":1638649,"ctime":1574299642,"ip_address":"","comment_id":153554,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"老师，能讲下 pipeline.fireChannelXXX()方法是如何传播的吗？看源码没看懂","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475207,"discussion_content":"处理业务那节就介绍了，简单说就是：寻找pipeline中下一个具有执行资格的handler然后来执行。因为不是所有的hanlder都具有资格，比如你触发的是读事件，那专门服务于写事件的handler就不需要执行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574299642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146388,"user_name":"欧阳田","can_delete":false,"product_type":"c3","uid":1054491,"ip_address":"","ucode":"24004916354446","user_header":"https://static001.geekbang.org/account/avatar/00/10/17/1b/4a088e67.jpg","comment_is_top":false,"comment_ctime":1572511543,"is_pvip":false,"replies":[{"id":59074,"content":"赋值的地方有多个，例如:\nio.netty.channel.nio.AbstractNioChannel#doBeginRead\n注册读。","user_name":"作者回复","user_name_real":"Geek_9bc307","uid":1638649,"ctime":1574303957,"ip_address":"","comment_id":146388,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"老师。请问：注册的事件会保存到集合中 Set&lt;SelectionKey&gt; selectionKey 。而 Set&lt;SelectionKey&gt; selectedKey 这个集合会去selectionKey中找。程序什么时候，在哪儿给selectedKey赋值的？","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472837,"discussion_content":"赋值的地方有多个，例如:\nio.netty.channel.nio.AbstractNioChannel#doBeginRead\n注册读。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574303957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148952,"user_name":"小不点","can_delete":false,"product_type":"c3","uid":1351860,"ip_address":"","ucode":"C307D44A185C34","user_header":"https://static001.geekbang.org/account/avatar/00/14/a0/b4/5173f1af.jpg","comment_is_top":false,"comment_ctime":1573117015,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"哈哈哈，为啥只读16次，不是17次，如果是17次有的同学会问....","like_count":6},{"had_liked":false,"id":262321,"user_name":"jackhance","can_delete":false,"product_type":"c3","uid":1261634,"ip_address":"","ucode":"934B0D20CCD06C","user_header":"https://static001.geekbang.org/account/avatar/00/13/40/42/d5c23178.jpg","comment_is_top":false,"comment_ctime":1605692017,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"老师您好，首次默认读取 1024 byte，若ByteBuf满载次数满足2次，将会被guess()扩大\n如果单个数据包的大小是大于 1024 byte，那么将会切割成多个ByteBuf，在InboundHandler # channelRead 传递\n那么在decode时，收到的ByteBuf并非是完整的数据包，这种情况应该如何处理呢？\n看了一下codec包下的decoder，并没处理这种情况，默认ByteBuff持有一个完整的数据包\n\nclient持续重试，让guess()扩容？\n","like_count":0},{"had_liked":false,"id":226096,"user_name":"haisheng","can_delete":false,"product_type":"c3","uid":2020634,"ip_address":"","ucode":"236C399EBA8280","user_header":"","comment_is_top":false,"comment_ctime":1591950377,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"老师，channel读数据时一次最多读16次，是考虑谁的感受呀","like_count":0,"discussions":[{"author":{"id":1137880,"avatar":"https://static001.geekbang.org/account/avatar/00/11/5c/d8/dfe1d4dc.jpg","nickname":"学斌","note":"","ucode":"ED3432D8EDC327","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319066,"discussion_content":"我觉得：对于多路复用，1个线程NioEventLoop可以读写取多个连接的数据，所以不能总是读写取某个连接，要把线程让出来，让这个线程可以处理其他的socket的读写","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603935574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219779,"user_name":"夏目","can_delete":false,"product_type":"c3","uid":1212750,"ip_address":"","ucode":"67C075A01CF4D2","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/4e/d71092f4.jpg","comment_is_top":false,"comment_ctime":1590078407,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"老师，看到这里我有一个疑问。之前讲到的3种reactor模式中多线程reactor和主从reactor，实际上eventLoopGroup都有一组(默认cpu*2)个eventLoop线程来处理accept和read，然后对于read之后的一些业务处理如果不指定线程池的话实际上默认会使用当前的eventLoop线程来执行，是这样的吗","like_count":0},{"had_liked":false,"id":201525,"user_name":"影随","can_delete":false,"product_type":"c3","uid":1088169,"ip_address":"","ucode":"48BC4CFCAD3C2F","user_header":"https://static001.geekbang.org/account/avatar/00/10/9a/a9/ae10f6cd.jpg","comment_is_top":false,"comment_ctime":1585799204,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"为什么client启动的时候，会触发 OP_READ 事件 ， debug看到的 256 个字节 ，里面存的是什么数据 ？","like_count":0},{"had_liked":false,"id":201514,"user_name":"影随","can_delete":false,"product_type":"c3","uid":1088169,"ip_address":"","ucode":"48BC4CFCAD3C2F","user_header":"https://static001.geekbang.org/account/avatar/00/10/9a/a9/ae10f6cd.jpg","comment_is_top":false,"comment_ctime":1585797756,"is_pvip":false,"replies":null,"discussion_count":2,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"老师，您好。 一次数据传输，数据较大，16次满之后，数据还未读完。 下一个 OP_READ 触发的时候，如何保证与上一次读取到的数据衔接上 ？  上一波数据，由于不完整，是被暂存起来了吗 ？ 它的生命周期是怎样的 ？ ","like_count":0,"discussions":[{"author":{"id":1024994,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a3/e2/5cb4f43f.jpg","nickname":"laolinshi","note":"","ucode":"269B879389D7D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555108,"discussion_content":"每个channel都有对应的pipeline，每次channel读到的数据都会交给pipeline进行处理，pipeline中的handler会把数据存起来等获得足够多的数据后进行解码，解码成功后交由业务的handler进行业务逻辑相关的处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646748985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1115149,"avatar":"https://static001.geekbang.org/account/avatar/00/11/04/0d/3dc5683a.jpg","nickname":"柯察金","note":"","ucode":"F722BF8FCD2C47","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1024994,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a3/e2/5cb4f43f.jpg","nickname":"laolinshi","note":"","ucode":"269B879389D7D5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":648222,"discussion_content":"既然要等到足够多的数据才解码进行业务处理，那么 fireChannelReadComplete 有什么意义呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1721225707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":555108,"ip_address":"美国","group_id":0},"score":648222,"extra":""}]}]},{"had_liked":false,"id":201129,"user_name":"雷刚","can_delete":false,"product_type":"c3","uid":1655725,"ip_address":"","ucode":"115FE2BE1AAB61","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/pTD8nS0SsORKiaRD3wB0NK9Bpd0wFnPWtYLPfBRBhvZ68iaJErMlM2NNSeEibwQfY7GReILSIYZXfT9o8iaicibcyw3g/132","comment_is_top":false,"comment_ctime":1585721023,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100036701,"comment_content":"扩缩容这一块，老师讲的很清楚。AdaptiveRecvByteBufAllocator 没人说一下，还真不容易看懂是怎么进行扩缩容的。","like_count":0},{"had_liked":false,"id":186119,"user_name":"刘子赫","can_delete":false,"product_type":"c3","uid":1145353,"ip_address":"","ucode":"8C974C40A85A15","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/09/0416a954.jpg","comment_is_top":false,"comment_ctime":1583761464,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100036701,"comment_content":"老师您好！“每次读取1024个大小数据，读取16次，如果发送的数据大于1024*16，之后还会触发读事件”。\n如果是边缘触发，只有从不可读变为可读状态的时候触发读事件，这个时候发送的数据大于1024*16，之后的数据要怎么读取呀？谢谢老师","like_count":0}]}