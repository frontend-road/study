{"id":86522,"title":"04 | 项目大了人员多了，架构怎么设计更合理？","content":"<p>你好，我是戴铭。今天，我要跟你说说怎么设计一个能够支持大型 iOS 工程的架构。</p><p>记得以前所在的团队，规模大了以后，客户端团队也被按照不同业务拆分到了不同的地方。当时，所有的代码都集中在一个仓库，团队里面一百多号人，只要有一个人提交错了，那么所有要更新代码的人都得等到修复后提交。这样一天下来，整个团队的沟通和互相等待都浪费了大量时间。同时，开发完成要进行测试时，由于代码相互耦合、归属不清，也影响到了问题排查的效率，并增加了沟通时间。</p><p>后来，我们痛定思痛，花了很大力气去进行架构整治，将业务完全解耦，将通用功能下沉，每个业务都是一个独立的 Git 仓库，每个业务都能够生成一个 Pod 库，最后再集成到一起。这样经过架构整治以后，也就没再出现过先前的窘境，开发效率也得到了极大的提升。由此可见，合理的架构是多么得重要。</p><p>其实，这并不是个例。当业务需求量和团队规模达到一定程度后，任何一款App都需要考虑架构设计的合理性。</p><p>而谈到架构治理，就需要将老业务、老代码按照新的架构设计模式进行重构。所以，架构重构考虑得越晚，重构起来就越困难，快速迭代的需求开发和漫长的重构之间的矛盾，如同在飞行的飞机上换引擎。及早考虑架构设计就显得尤为重要。</p><!-- [[[read_end]]] --><p>那么，如何设计一个能支持大规模 App 的架构呢？接下来，我就和你说说这个话题。</p><p>苹果官方推荐的 App 开发模式是 MVC，随之衍生出其他很多类 MVC 的设计模式 MVP、MVVM、MVCS ，它们在不同程度上增强了视图、数据的通信方式，使得逻辑、视图、数据之间的通信更灵活、规整、易于扩展。在 App 浪潮初期，几乎所有 App 采用的都是这种类MVC的结构。原因在于，MVC 是很好的面向对象编程范式，非常适合个人开发或者小团队开发。</p><p>但是，项目大了，人员多了以后，这种架构就扛不住了。因为，这时候功能的量级不一样了。一个大功能，会由多个功能合并而成，每个功能都成了一个独立的业务，团队成员也会按照业务分成不同的团队。此时，简单的逻辑、视图、数据划分再也无法满足 App 大规模工程化的需求。</p><p>所以，接下来我们就不得不考虑模块粒度如何划分、如何分层，以及多团队如何协作这三个问题了。解决了这三个问题以后，我们就可以对模块内部做进一步优化了。模块久经考验后，就能成为通用功能对外部输出，方便更多的团队。</p><p>总的来说，架构是需要演进的。如果项目规模大了还不演进，必然就会拖累业务的发展速度。</p><p>简单架构向大型项目架构演进中，就需要解决三个问题，即：模块粒度应该如何划分？如何分层？多团队如何协作？而在这其中，模块粒度的划分是架构设计中非常关键的一步。同时，这也是一个细活，我们最好可以在不同阶段采用不同的粒度划分模块。现在，我们就带着这三个问题继续往下看吧。</p><h2>大项目、多人、多团队架构思考</h2><p>接下来，我先和你说下<strong>模块粒度应该怎么划分</strong>的问题。</p><p><strong>首先，</strong>项目规模变大后，模块划分必须遵循一定的原则。如果模块划分规则不规范、不清晰，就会导致代码耦合严重的问题，并加大架构重构的难度。这些问题主要表现在：</p><ul>\n<li>\n<p>业务需求不断，业务开发不能停。重新划分模块的工作量越大，成本越高，重构技改需求排上日程的难度也就越大。</p>\n</li>\n<li>\n<p>老业务代码年久失修，没有注释，修改起来需要重新梳理逻辑和关系，耗时长。</p>\n</li>\n</ul><p><strong>其次，</strong>我们需要搞清楚模块的粒度采用什么标准进行划分，也就是要遵循的原则是什么。</p><p>对于 iOS 这种面向对象编程的开发模式来说，我们应该遵循以下五个原则，即SOLID 原则。</p><ul>\n<li>\n<p>单一功能原则：对象功能要单一，不要在一个对象里添加很多功能。</p>\n</li>\n<li>\n<p>开闭原则：扩展是开放的，修改是封闭的。</p>\n</li>\n<li>\n<p>里氏替换原则：子类对象是可以替代基类对象的。</p>\n</li>\n<li>\n<p>接口隔离原则：接口的用途要单一，不要在一个接口上根据不同入参实现多个功能。</p>\n</li>\n<li>\n<p>依赖反转原则：方法应该依赖抽象，不要依赖实例。iOS 开发就是高层业务方法依赖于协议。</p>\n</li>\n</ul><p>同时，遵守这五个原则是开发出容易维护和扩展的架构的基础。</p><p><strong>最后，</strong>我们需要选择合适的粒度。切记，大型项目的模块粒度过大或者过小都不合适。</p><p>其中，组件可以认为是可组装的、独立的业务单元，具有高内聚，低耦合的特性，是一种比较适中的粒度。就像用乐高拼房子一样，每个对象就是一块小积木。一个组件就是由一块一块的小积木组成的有单一功能的组合，比如门、柱子、烟囱。</p><p>在我看来，iOS 开发中的组件，不是 UI 的控件，也不是ViewController 这种大 UI 和功能的集合。因为，UI 控件的粒度太小，而页面的粒度又太大。<strong>iOS 组件，应该是包含 UI 控件、相关多个小功能的合集，是一种粒度适中的模块。</strong></p><p>并且，采用组件的话，对于代码逻辑和模块间的通信方式的改动都不大，完成老代码切换也就相对容易些。我们可以先按照物理划分，也就是将多个相同功能的类移动到同一个文件夹下，然后做成 CocoaPods的包进行管理。</p><p>但是，仅做到这一步还不够，因为功能模块之间的耦合还是没有被解除。如果没有解除耦合关系的话，不同功能的开发还是没法独立开来，勉强开发完成后的影响范围评估也难以确定。</p><p>所以接下来，我们就需要<strong>重新梳理组件之间的逻辑关系，进行改造</strong>。</p><p>但是，组件解耦并不是说要求每个组件间都没有耦合，组件间也需要有上下层依赖的关系。组件间的上下层关系划分清楚了，就会容易维护和管理。而对于组件间如何分层这个问题，我认为层级最多不要超过三个，你可以这么设置：</p><ul>\n<li>\n<p>底层可以是与业务无关的基础组件，比如网络和存储等；</p>\n</li>\n<li>\n<p>中间层一般是通用的业务组件，比如账号、埋点、支付、购物车等；</p>\n</li>\n<li>\n<p>最上层是迭代业务组件，更新频率最高。</p>\n</li>\n</ul><p>这样的三层结构，尤其有利于多个团队分别开发维护。比如，一开始有两个业务团队A和B，他们在开发时既有通用的功能、账号、埋点、个人页等，也有专有的业务功能模块，每个功能都是一个组件。</p><p>这样，新创建的业务团队C，就能非常轻松地使用团队A和B开发出的通用组件。而且，如果两个业务团队有相同功能时，对相应的功能组件进行简单改造后，也能同时适用于两个业务团队。</p><p>但是，我认为不用把所有的功能都做成组件，只有那些会被多个业务或者团队使用的功能模块才需要做成组件。因为，改造成组件也是需要时间成本的，很少有公司愿意完全停下业务去进行重构，而一旦决定某业务功能模块要改成组件，就要抓住机会，严格按照 SOLID 原则去改造组件，因为返工和再优化的机会可能不会再有。</p><h2>多团队之间如何分工？</h2><p>在代码层面，我们通过组件化解决了大项目、多人、多团队架构的问题，但是架构问题还涉及到团队人员结构上的架构。当公司或者集团的 App 多了后，相应的团队也就多了，为了能够让产品快速迭代和稳定发展，也需要一个合理的团队结构。在我看来，这个<strong>合理的团队结构应该是这样的：</strong></p><ul>\n<li>\n<p>首先，需要一个专门的基建团队，负责业务无关的基础功能组件和业务相关通用业务组件的开发。</p>\n</li>\n<li>\n<p>然后，每个业务都由一个专门的团队来负责开发。业务可以按照功能耦合度来划分，耦合度高的业务可以划分成单独的业务团队。</p>\n</li>\n<li>\n<p>基建团队人员应该是流动的，从业务团队里来，再回到业务团队中去。这么设计是因为业务团队和基建团队的边界不应该非常明显，否则就会出现基建团队埋头苦干，结果可能是做得过多、做得不够，或着功能不好用的问题，造成严重的资源浪费。</p>\n</li>\n</ul><p>总结来讲，我想说的是团队分工要灵活，不要把人员隔离固化了，否则各干各的，做的东西相互都不用。核心上，团队分工还是要围绕着具体业务进行功能模块提炼，去解决重复建设的问题，在这个基础上把提炼出的模块做精做扎实。否则，拉一帮子人臆想出来的东西，无人问津，那就是把自己架空了。</p><h2>我心目中好的架构是什么样的？</h2><p>现在，我们已经可以从代码内外来分析App开发的架构设计了，但也只是会分析了而已，脑海中并没有明确好的架构是什么样的，也不知道具体应该怎么设计。接下来，我们就带着这两个问题继续看下面的内容。</p><p>组件化是解决项目大、人员多的一种很好的手段，这在任何公司或团队都是没有歧义的。组件间关系协调却没有固定的标准，协调的优劣，成为了衡量架构优劣的一个基本标准。所以在实践中，一般分为了<strong>协议式和中间者两种架构</strong>设计方案。</p><p><strong>协议式架构设计主要采用的是协议式编程的思路</strong>：在编译层面使用协议定义规范，实现可在不同地方，从而达到分布管理和维护组件的目的。这种方式也遵循了依赖反转原则，是一种很好的面向对象编程的实践。</p><p>但是，这个方案的缺点也很明显，主要体现在以下两个方面：</p><ol>\n<li>\n<p>由于协议式编程缺少统一调度层，导致难于集中管理，特别是项目规模变大、团队变多的情况下，架构管控就会显得越来越重要。</p>\n</li>\n<li>\n<p>协议式编程接口定义模式过于规范，从而使得架构的灵活性不够高。当需要引入一个新的设计模式来开发时，我们就会发现很难融入到当前架构中，缺乏架构的统一性。</p>\n</li>\n</ol><p>虽然协议式架构有这两方面的局限性，但由于其简单易用的特点依然被很多公司采用。</p><p><strong>另一种常用的架构形式是中间者架构。它采用中间者统一管理的方式，来控制 App 的整个生命周期中组件间的调用关系。</strong>同时，iOS 对于组件接口的设计也需要保持一致性，方便中间者统一调用。</p><p>中间者架构如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/40/69/40a625a0f556aa264eee9fbb212b3469.png?wh=2732*2048\" alt=\"\"></p><center><span class=\"reference\">图1 中间者架构示意图</span></center><p>可以看到，拆分的组件都会依赖于中间者，但是组间之间就不存在相互依赖的关系了。由于其他组件都会依赖于这个中间者，相互间的通信都会通过中间者统一调度，所以组件间的通信也就更容易管理了。在中间者上也能够轻松添加新的设计模式，从而使得架构更容易扩展。</p><p>在我看来，好的架构一定是健壮的、灵活的。中间者架构的易管控带来的架构更稳固，易扩展带来的灵活性，所以我认为中间者这种架构设计模式是非常值得推荐的。casatwy 以前设计了一个 CTMediator 就是按照中间者架构思路设计的。你可以在<a href=\"https://github.com/casatwy/CTMediator\">GitHub</a>上看到它的内容。</p><p>CTMediator 使用的是运行时解耦，接下来我就通过开源的 CTMediator 代码，和你分享下如何使用运行时技术来解耦。解耦核心方法如下所示：</p><pre><code>- (id)performTarget:(NSString *)targetName action:(NSString *)actionName params:(NSDictionary *)params shouldCacheTarget:(BOOL)shouldCacheTarget\n{\n    NSString *swiftModuleName = params[kCTMediatorParamsKeySwiftTargetModuleName];\n    \n    // generate target\n    NSString *targetClassString = nil;\n    if (swiftModuleName.length &gt; 0) {\n        targetClassString = [NSString stringWithFormat:@&quot;%@.Target_%@&quot;, swiftModuleName, targetName];\n    } else {\n        targetClassString = [NSString stringWithFormat:@&quot;Target_%@&quot;, targetName];\n    }\n    NSObject *target = self.cachedTarget[targetClassString];\n    if (target == nil) {\n        Class targetClass = NSClassFromString(targetClassString);\n        target = [[targetClass alloc] init];\n    }\n\n\n    // generate action\n    NSString *actionString = [NSString stringWithFormat:@&quot;Action_%@:&quot;, actionName];\n    SEL action = NSSelectorFromString(actionString);\n    \n    if (target == nil) {\n        // 这里是处理无响应请求的地方之一，这个demo做得比较简单，如果没有可以响应的target，就直接return了。实际开发过程中是可以事先给一个固定的target专门用于在这个时候顶上，然后处理这种请求的\n        [self NoTargetActionResponseWithTargetString:targetClassString selectorString:actionString originParams:params];\n        return nil;\n    }\n    \n    if (shouldCacheTarget) {\n        self.cachedTarget[targetClassString] = target;\n    }\n\n\n    if ([target respondsToSelector:action]) {\n        return [self safePerformAction:action target:target params:params];\n    } else {\n        // 这里是处理无响应请求的地方，如果无响应，则尝试调用对应target的notFound方法统一处理\n        SEL action = NSSelectorFromString(@&quot;notFound:&quot;);\n        if ([target respondsToSelector:action]) {\n            return [self safePerformAction:action target:target params:params];\n        } else {\n            // 这里也是处理无响应请求的地方，在notFound都没有的时候，这个demo是直接return了。实际开发过程中，可以用前面提到的固定的target顶上的。\n            [self NoTargetActionResponseWithTargetString:targetClassString selectorString:actionString originParams:params];\n            [self.cachedTarget removeObjectForKey:targetClassString];\n            return nil;\n        }\n    }\n</code></pre><p>performTarget:action:params:shouldCacheTarget:方法主要是对 targetName 和 actionName 进行容错处理，也就是对调用方法无响应的处理。这个方法封装了 safePerformAction:target:params 方法，入参 targetName 就是调用接口的对象，actionName 是调用的方法名，params 是参数。</p><p>从代码中同时还能看出只有满足 Target_ 前缀的对象和 Action 的方法才能被 CTMediator 使用。这时，我们可以看出中间者架构的优势，也就是利于统一管理，可以轻松管控制定的规则。</p><p>下面这段代码，是使用 CTMediator 如何调用一个弹窗显示方法的代码示范：</p><pre><code>[self performTarget:kCTMediatorTargetA\n                 action:kCTMediatorActionShowAlert\n                 params:paramsToSend\n      shouldCacheTarget:NO];\n</code></pre><p>可以看出，指定了对象名和调用方法名，把参数封装成字典传进去就能够直接调用该方法了。</p><p>但是，这种运行时直接硬编码的调用方式也有些缺点，主要表现在两个方面：</p><ol>\n<li>\n<p>直接硬编码的调用方式，参数是以string的方法保存在内存里，虽然和将参数保存在Text字段里占用的内存差不多，同时还可以避免.h文件的耦合，但是其对代码编写效率的降低也比较明显。</p>\n</li>\n<li>\n<p>由于是在运行时才确定的调用方法，调用方式由 [obj method] 变成 [obj performSelector:@\"\"]。这样的话，在调用时就缺少类型检查，是个很大的缺憾。因为，如果方法和参数比较多的时候，代码编写效率就会比较低。</p>\n</li>\n</ol><p>这篇文章发出后 CTMediator 的作者 casatwy 找到了我，指出文章中提到的 CTMediator 的硬编码和字典传参这两个缺点，实际上已经被完美解决了。下面是 casatwy 的原话，希望可以对你有所帮助。</p><blockquote>\n<p>CTMediator 本质就是一个方法，用来接收 target、action、params。由于 target、action 都是字符串，params是字典，对于调用者来说十分不友好，因为调用者要写字符串，而且调用的时候若是不看文档，他也不知道这个字典里该塞什么东西。</p>\n</blockquote><blockquote>\n<p>所以实际情况中，调用者是不会直接调用CTMediator的方法的。那调用者怎么发起调用呢？通过响应者给CTMediator做的category或者extension发起调用。</p>\n</blockquote><blockquote>\n<p>category或extension以函数声明的方式，解决了参数的问题。调用者看这个函数长什么样子，就知道给哪些参数。在category或extension的方法实现中，把参数字典化，顺便把target、action这俩字符串写死在调用里。</p>\n</blockquote><blockquote>\n<p>于是，对于调用者来说，他就不必查文档去看参数怎么给，也不必担心target、action字符串是什么了。这个category是一个独立的Pod，由响应者业务的开发给到。</p>\n</blockquote><blockquote>\n<p>所以，当一个工程师开发一个业务的时候，他会开发两个Pod，一个是category Pod，一个是自己本身的业务Pod。这样就完美解决了CTMediator它自身的缺点。</p>\n</blockquote><blockquote>\n<p>对于调用者来说，他不会直接依赖CTMediator去发起调用，而是直接依赖category Pod去发起调用的。这么一来，CTMediator方案就完美了。</p>\n</blockquote><blockquote>\n<p>然后还有一点可能需要强调：基于CTMediator方案的工程，每一个组件无所谓是OC还是Swift，Pod也无所谓是category还是extension。也就是说，假设一个工程由100个组件组成，那可以是50个OC、50个Swift。因为CTMediator抹去了不同语言的组件之间的隔阂，所以大家老的OC工程可以先应用CTMediator，把组件拆出来。然后新的业务来了，用Swift写，等有空的时候再把老的OC改成Swift，或者不改，都是没问题的。</p>\n</blockquote><p>不过，解耦的精髓在于业务逻辑能够独立出来，并不是形式上的解除编译上的耦合（编译上解除耦合只能算是解耦的一种手段而已）。所以，在考虑架构设计时，我们<strong>更多的还是需要在功能逻辑和组件划分上做到同层级解耦，上下层依赖清晰，这样的结构才能够使得上层组件易插拔，下层组件更稳固。而中间者架构模式更容易维护这种结构，中间者的易管控和易扩展性，也使得整体架构能够长期保持稳健与活力。所以，中间者架构就是我心目中好的架构。</strong></p><h2>案例分享</h2><p>明确了中间者架构是我认为的好架构，那么如何体现其易管控和易扩展性呢？我通过一个案例来和你一起分析下。</p><p>这个例子的代码，在 CTMediator 的基础上进行了扩展，完整代码请点击<a href=\"https://github.com/ming1016/ArchitectureDemo\">这个GitHub链接</a> 。</p><p>这个范例的主要组件类名和方法名，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/8f/62/8fe9d2bcbbb6b6f0f7be6e2da5557e62.png?wh=2732*1708\" alt=\"\"></p><center><span class=\"reference\">图2 主要的组件类名和方法名</span></center><p>可以看出，这个范例在中间者架构的基础上增加了对中间件、状态机、观察者、工厂模式的支持。同时，这个案例也在使用上做了些优化，支持了链式调用，代码如下：</p><pre><code>self.dispatch(CdntAction.cls(@&quot;PublishCom&quot;).mtd(@&quot;viewInVC&quot;).pa(dic));\n</code></pre><p>代码中的PublishCom 是组件类名，ViewInVC 是方法名。</p><p>下面说下<strong>中间件模式。</strong>在添加中间件的时候，我们只需要链式调用 addMiddlewareAction 就可以在方法执行之前插入中间件。代码如下：</p><pre><code>self.middleware(@&quot;PublishCom showEmergeView&quot;).addMiddlewareAction(CdntAction.clsmtd(@&quot;AopLogCom emergeLog&quot;).pa(Dic.create.key(@&quot;actionState&quot;).val(@&quot;show&quot;).done));\n</code></pre><p>这行代码对字典参数也使用了链式方便参数的设置，使得字典设置更易于编写。改变状态使用 toSt 方法即可，状态的维护和管理都在内部实现。同一个方法不同状态的实现只需要在命名规则上做文章即可，这也是得易于中间者架构可以统一处理方法调用规则的特性。比如，confirmEmerge 方法在不同状态下的实现代码如下：</p><pre><code>// 状态管理\n- (void)confirmEmerge_state_focusTitle:(NSDictionary *)dic {\n    NSString *title = dic[@&quot;title&quot;];\n    [self.fromAddressBt setTitle:title forState:UIControlStateNormal];\n    self.fromAddressBt.tag = 1;\n}\n- (void)confirmEmerge_state_focusContent:(NSDictionary *)dic {\n    NSString *title = dic[@&quot;title&quot;];\n    [self.toAddressBt setTitle:title forState:UIControlStateNormal];\n    self.toAddressBt.tag = 1;\n}\n- (void)confirmEmerge_state_focusPrice:(NSDictionary *)dic {\n    NSString *title = dic[@&quot;title&quot;];\n    [self.peopleBt setTitle:title forState:UIControlStateNormal];\n    self.peopleBt.tag = 1;\n}\n</code></pre><p>可以看出，我们只需要在方法名后面加上“ _state _状态名”，就能够对不同状态进行不同实现了。</p><p>对于<strong>观察者模式</strong>，使用起来也很简单清晰。比如，发布文章这个事件需要两个观察者，一个执行重置界面，一个检查是否能够发布，代码如下：</p><pre><code>// 观察者管理 self.observerWithIdentifier(@&quot;publishOk&quot;).addObserver(CdntAction.clsmtd(@&quot;PublishCom reset&quot;)).addObserver(CdntAction.clsmtd(@&quot;PublishCom checkPublish&quot;));\n</code></pre><p>这样的写法非常简单清晰。在发布时，我们只需要执行如下代码：</p><pre><code>[self notifyObservers:@&quot;publishOk&quot;];\n</code></pre><p>观察者方法添加后，也会记录在内部，它们的生命周期跟随中间者的生命周期。</p><p><strong>工厂模式的思路和状态机类似</strong>，状态机是对方法在不同状态下的实现，而工厂模式是对类在不同设置下的不同实现。由于有了中间者，我就可以在传入类名后对其进行类似状态机中方法名的处理，以便类的不同实现可以通过命名规则来完成。我们先看看中间者处理状态机的代码：</p><pre><code>// State action 状态处理\nif (![self.p_currentState isEqual:@&quot;init&quot;]) {\n    SEL stateMethod = NSSelectorFromString([NSString stringWithFormat:@&quot;%@_state_%@:&quot;, sep[1], self.p_currentState]);\n    if ([obj respondsToSelector:stateMethod]) {\n        return [self executeMethod:stateMethod obj:obj parameters:parameters];\n    }\n}\n</code></pre><p>可以看出当前的状态会记录在 p_currentState 属性中，方法调用时方法名会和当前的状态的命名拼接成一个完整的实现方法名来调用。中间者处理工厂模式的思路也类似，代码如下：</p><pre><code>// Factory\n// 由于后面的执行都会用到 class 所以需要优先处理 class 的变形体\nNSString *factory = [self.factories objectForKey:classStr];\nif (factory) {\n    classStr = [NSString stringWithFormat:@&quot;%@_factory_%@&quot;, classStr, factory];\n    classMethod = [NSString stringWithFormat:@&quot;%@ %@&quot;, classStr, sep[1]];\n}\n</code></pre><p>可以看出，采用了中间者这种架构设计思想后，架构就具有了很高的扩展性和可管控性。所以，我推崇这种架构设计思路。</p><h2>小结</h2><p>架构的设计绝对不是要等到工程到了燃眉之急之时，再去环顾其他公司或团队在用什么架构，然后拍脑袋拿一个过来，来次大重构。好的架构，需要在业务开发过程中及早发现开发的痛点，进行有针对性的改良，不然就会和实际开发越走越远。</p><p>比如，某个业务模块的逻辑非常复杂、状态有很多，这时我们就需要在架构层面考虑如何处理会更方便，改动最小的支持状态机模式，又或者在开始架构设计时就多考虑如何将架构设计的具有更高的易用性和可扩展性。</p><p>好的架构是能够在一定的规范内同时支持高灵活度，这种度的把握是需要架构师长期跟随团队开发，随着实际业务需求的演进进行分析和把控的。</p><p>在项目大了，人员多了的情况下，好的架构一定是不简单的，不通用的，但一定是接地气的，这样才能更适合自己的团队，才能够用得上。那些大而全，炫技，脱离业务开发需求的架构是没法落地的。</p><p>最后，我提点建议。我在面试应聘者的时候，通常都会问他所负责项目的整体架构是怎样的。结果呢，很多人都只对自己负责的那摊子事儿说的溜，而回答所在项目整体情况时却支支吾吾，也因此没能面试成功。</p><p>所以，作为一名普通的开发者，除了日常需求开发和技术方案调研、设计外，你还需要了解自己所在项目的整体架构是怎样的，想想架构上哪些地方是不够好需要改进的，业界有哪些好的架构思想是可以落地到自己项目中的。有了从项目整体上去思考的意识，你才能够站在更高的视角上去思考问题。这，也是对架构师的基本要求。</p><h2>课后作业</h2><p>架构如何设计众说纷纭，请你来说下你们项目目前架构是怎样的，并画出你心中理想的架构图。</p><p>感谢你的收听，欢迎你在评论区给我留言分享你的观点，也欢迎把它分享给更多的朋友一起阅读。</p><p></p>","neighbors":{"left":{"article_title":"03 | Auto Layout 是怎么进行自动布局的，性能如何？","id":85332},"right":{"article_title":"05 | 链接器：符号是怎么绑定到地址上的？","id":86840}},"comments":[{"had_liked":false,"id":77540,"user_name":"五天几年","can_delete":false,"product_type":"c1","uid":1004641,"ip_address":"","ucode":"C5BAB0AA1813AD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/61/68160639.jpg","comment_is_top":false,"comment_ctime":1552960928,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"396689952160","product_id":100024501,"comment_content":"我现在做的项目就很好的做了模块化设计，将一些常用功能抽出构建成了单独模块banner（横幅广告）、network（网络连接）、window（界面相关）、validator（响应式校验），还有一个通用基础模块，封装了一些常用工具和MVP系统架构。MVP架构和泛型一起使用，好的不要不要，哈哈哈。最厉害的是，我们的封装模块Android端和iOS端类、接口、方法一模一样，文档注释非常清晰，方便两端开发者沟通交流，更方便快速定位错误，只要一端出了问题，另一端可以快速检查测试，查找是否错误重现。","like_count":91,"discussions":[{"author":{"id":1785940,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/rWMGIQG1z13nekorr9I4PY1w7rlskssf949IQ24SvIewpM7mmZoH2QEZ2aKHu5tkmicGQ7KTGrN9vFYhrDsdp9w/132","nickname":"Geek_9dbcb4","note":"","ucode":"BB92D5E844A743","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":246047,"discussion_content":"为什么要做2个库（分类库和组件库）啊？\n一个库也行啊。把分类也放到组件里。我们在用的时候，直接依赖分类好了。\n两个库，能想到的好处是，方便指定分类库和组件库的版本。但是一般情况下，多此一举。\n大家觉得呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587721770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1484403,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a6/73/e83ec59b.jpg","nickname":"nil","note":"","ucode":"E9B70DF27CF817","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1785940,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/rWMGIQG1z13nekorr9I4PY1w7rlskssf949IQ24SvIewpM7mmZoH2QEZ2aKHu5tkmicGQ7KTGrN9vFYhrDsdp9w/132","nickname":"Geek_9dbcb4","note":"","ucode":"BB92D5E844A743","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295514,"discussion_content":"1. 易插拔，可以随时替换实现，也方便Mock与测试\n2. 接口和实现分离，有利于接口稳定，内部的业务实现是频繁变动的部分，而外部的接口给别人依赖，大团队规模下可以方便快速迭代","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596213307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":246047,"ip_address":""},"score":295514,"extra":""}]},{"author":{"id":1096554,"avatar":"https://static001.geekbang.org/account/avatar/00/10/bb/6a/a7527c60.jpg","nickname":".","note":"","ucode":"36D47FB197C233","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2191,"discussion_content":"你们用的哪种方式做的模块组件化。是Router(路由URL) 还是 CTMediator(target-action)。。。还是其他的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563348186,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1004641,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/54/61/68160639.jpg","nickname":"五天几年","note":"","ucode":"C5BAB0AA1813AD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1096554,"avatar":"https://static001.geekbang.org/account/avatar/00/10/bb/6a/a7527c60.jpg","nickname":".","note":"","ucode":"36D47FB197C233","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4410,"discussion_content":"很原始的方式，开发时拉出全部代码，直接调用。我们的模块已经固定了，再就是组员比较少，同时有一个开发规范，大体上知道怎么写接口，传参。最后，每半天提交一次代码，由代码评审员做最后的代码合并、重构，再通知组员重新拉库，然后修改匹配新代码，继续写代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565373179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2191,"ip_address":""},"score":4410,"extra":""}]}]},{"had_liked":false,"id":80401,"user_name":"Geek_麟凤来思","can_delete":false,"product_type":"c1","uid":1457551,"ip_address":"","ucode":"7ADF5585765A42","user_header":"https://static001.geekbang.org/account/avatar/00/16/3d/8f/4d1ffc7f.jpg","comment_is_top":false,"comment_ctime":1553655779,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"156172478435","product_id":100024501,"comment_content":"对于架构我感觉这几篇很有营养<br>https:&#47;&#47;casatwy.com&#47;iosying-yong-jia-gou-tan-kai-pian.html<br>iOS应用架构谈 开篇 <br>iOS应用架构谈 view层的组织和调用方案 <br>iOS应用架构谈 网络层设计方案 <br>iOS应用架构谈 本地持久化方案及动态部署 <br>iOS应用架构谈 组件化方案<br><br>","like_count":37,"discussions":[{"author":{"id":1099324,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c6/3c/8ab9deb0.jpg","nickname":"@许还真","note":"","ucode":"6D754D5AE44CEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281937,"discussion_content":"这个很早收藏看了 非常棒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591844401,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78049,"user_name":"Ripper","can_delete":false,"product_type":"c1","uid":1167593,"ip_address":"","ucode":"03F30F937AF0E5","user_header":"https://static001.geekbang.org/account/avatar/00/11/d0/e9/7dc0be6b.jpg","comment_is_top":false,"comment_ctime":1553063263,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"126107114847","product_id":100024501,"comment_content":"SOLID 原则全称：<br>1. Single responsibility principle<br>2. Open–closed principle<br>3. Liskov substitution principle<br>4. Interface segregation principle<br>5. Dependency inversion principle","like_count":30},{"had_liked":false,"id":77771,"user_name":"曾剑南","can_delete":false,"product_type":"c1","uid":1130597,"ip_address":"","ucode":"7D6985B33FBE7F","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/65/a6c41b4f.jpg","comment_is_top":false,"comment_ctime":1552996542,"is_pvip":false,"replies":[{"id":"28402","content":"入门我推荐阮一峰老师的《软件架构入门》http:&#47;&#47;www.ruanyifeng.com&#47;blog&#47;2016&#47;09&#47;software-architecture.html","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1553000117,"ip_address":"","comment_id":77771,"utype":1}],"discussion_count":1,"race_medal":0,"score":"70272473278","product_id":100024501,"comment_content":"老师，这里面讲到了架构方面的知识，有什么入门的资料可以推荐一下吗","like_count":15,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443844,"discussion_content":"入门我推荐阮一峰老师的《软件架构入门》http://www.ruanyifeng.com/blog/2016/09/software-architecture.html","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553000117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77547,"user_name":"Sasori","can_delete":false,"product_type":"c1","uid":1012746,"ip_address":"","ucode":"24BDCA0FE2C790","user_header":"https://static001.geekbang.org/account/avatar/00/0f/74/0a/abad1aa1.jpg","comment_is_top":false,"comment_ctime":1552961447,"is_pvip":false,"replies":[{"id":"28352","content":"是的，CTMediator会在运行时进行管控。其实在中间者那一层加上记录，还能够进行运行时代码覆盖率统计","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1552978212,"ip_address":"","comment_id":77547,"utype":1}],"discussion_count":2,"race_medal":0,"score":"70272438183","product_id":100024501,"comment_content":"协议化的方式有两个好处，一是可以明确知道组件提供了哪些服务，二是组件一旦修改了接口会立刻引发编译错误，而CTMediator会推迟到运行时。","like_count":16,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443772,"discussion_content":"是的，CTMediator会在运行时进行管控。其实在中间者那一层加上记录，还能够进行运行时代码覆盖率统计","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552978212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2836424,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIBFqG8ZS9BbtsAgwO25W8L7CDzPVoVQJJo4RRxbzn5hcWRHwEDicNVryQJvaz7LqT93832ibUuMiblQ/132","nickname":"Geek_b10094","note":"","ucode":"5242BE3B36820D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":414480,"discussion_content":"可以通过clang在编译阶段加入校验","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636782515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78234,"user_name":"Kai","can_delete":false,"product_type":"c1","uid":1024088,"ip_address":"","ucode":"CD3FACF1803D8F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a0/58/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1553098179,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"65977607619","product_id":100024501,"comment_content":"希望能在每篇文章的最后推荐一些相关的资料阅读，这样能更好地帮助理解内容","like_count":15,"discussions":[{"author":{"id":1460977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4a/f1/e3b02c6d.jpg","nickname":"莫言","note":"","ucode":"3B5782B58BFD18","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216143,"discussion_content":"嗯，有书就更好了，能找到的太少","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585407215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77537,"user_name":"wang","can_delete":false,"product_type":"c1","uid":1006516,"ip_address":"","ucode":"0B3F0D4D32A842","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5b/b4/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1552960269,"is_pvip":false,"replies":[{"id":"28353","content":"是的","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1552978411,"ip_address":"","comment_id":77537,"utype":1}],"discussion_count":3,"race_medal":0,"score":"44502633229","product_id":100024501,"comment_content":"组件化架构的目的主要是解耦各个具体业务模块的耦合，而在业务模块的内部也还是需要用到像MVC、MVP、MVVM这些设计模式。  大神，我的理解是没错吧","like_count":10,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443766,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552978411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1733815,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/74/b7/3b3ffa56.jpg","nickname":"脚踏实地","note":"","ucode":"E198A82B586C43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":266378,"discussion_content":"MVC、MVVM这些叫设计模式？怎么每个大神的说辞都不统一。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589507081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1169500,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d8/5c/d3ac7279.jpg","nickname":"吴海峰","note":"","ucode":"4ACF2950A47707","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":239373,"discussion_content":"横向解耦和纵向解耦之分","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587296901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78153,"user_name":"彭序猿","can_delete":false,"product_type":"c1","uid":1002648,"ip_address":"","ucode":"EC59F7968147B6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4c/98/9845e6b5.jpg","comment_is_top":false,"comment_ctime":1553080615,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"40207786279","product_id":100024501,"comment_content":"大家好，我先说下我的疑问：<br>关于组件化的实现方案有协议或者中间人两种：<br>1.协议解耦：Runtime+Protocol<br>2.中间人解耦：Runtime+TargetAction<br><br>我用协议来解耦的时候:<br>1.我有一个管理类是作为调度层，这样子就可以方便统一调用<br>2.我的 Protocol 头文件，Model 都已经沉淀到底层基础框架了，整个 App 模块默认引用了<br><br>这里用协议来解耦，也是有一个管理类统一调度的，这种情况是不是跟中间人调用差不多了？ <br>跟 CTMediator 相差的就是使用 protocol 还是 TargetAction 的区别？<br><br>在这种场景下，我觉得两种方案优劣是差不多的。<br>","like_count":9,"discussions":[{"author":{"id":1146160,"avatar":"https://static001.geekbang.org/account/avatar/00/11/7d/30/54f1f56e.jpg","nickname":"七月","note":"","ucode":"20D0BF2A3E172F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365702,"discussion_content":"额 这个不是应该根据实际业务来选择么？总感觉现在逐渐的都在求技而忽略自身业务了。。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617869206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1785940,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/rWMGIQG1z13nekorr9I4PY1w7rlskssf949IQ24SvIewpM7mmZoH2QEZ2aKHu5tkmicGQ7KTGrN9vFYhrDsdp9w/132","nickname":"Geek_9dbcb4","note":"","ucode":"BB92D5E844A743","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":239296,"discussion_content":"1.协议解耦：Runtime+Protocol。你们的runtime体现在什么地方？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587291486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2626046,"avatar":"https://static001.geekbang.org/account/avatar/00/28/11/fe/a4a12c4e.jpg","nickname":"shadeless","note":"","ucode":"4CD169FA99E07D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1785940,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/rWMGIQG1z13nekorr9I4PY1w7rlskssf949IQ24SvIewpM7mmZoH2QEZ2aKHu5tkmicGQ7KTGrN9vFYhrDsdp9w/132","nickname":"Geek_9dbcb4","note":"","ucode":"BB92D5E844A743","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375321,"discussion_content":"内部本质都是通过类名方法名拿到对应class和SEL然后调用performSelector吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621578217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":239296,"ip_address":""},"score":375321,"extra":""}]},{"author":{"id":1458957,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/7IvaucOdCqF6HLA3aC7YzYzv9GGJ26Wz5XESWMAoycSO2KQIibBxmaMc4E2icjJoO1gP5GqqJspt6ZPuxd5EKBag/132","nickname":"Damon","note":"","ucode":"318F0D8C8D0B52","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304543,"discussion_content":"我觉得差别在于，CT是定义了各个模块的类别，暴露对外的接口，内部是通过Target-Action的方式去派发到对应模块，而protocol就类比CT的各个模块的类别，暴露对外的接口，差异在于中间者派发任务的方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599611604,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78097,"user_name":"drunkenMouse","can_delete":false,"product_type":"c1","uid":1454037,"ip_address":"","ucode":"AA8CEA703ECBE8","user_header":"","comment_is_top":false,"comment_ctime":1553070497,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"31617841569","product_id":100024501,"comment_content":"我之前参与过的项目架构，本质都是MVC。要么根据Tabbar的功能模块，分到不同的文件夹里，然后每个文件夹对应一个功能组件，第三方与也分到一个单独的文件夹，但本质上还是MVC。要么业务与业务分开的项目，其架构模式也就是各个业务负责各自的业务功能解决，每周开会确认各个业务间所需要的配合，但还是MVC。根本牵扯不到模块力度的划分、团队的合作方式就是当面或者微信聊、唯一可以谈的分层也就是对网络请求、数据库的处理、ViewController的底层封装，然后各自如何使用全看自己。。只要Bugly没有收集到崩溃、测试与产品没有页面卡顿与BUG修复等需求、美工没有页面布局的调整，就算是合格完成任务了。。。","like_count":7,"discussions":[{"author":{"id":2061978,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/76/9a/d26031bc.jpg","nickname":"MINT🍀","note":"","ucode":"ED50ED615749B7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290833,"discussion_content":"有高强度架构需求的毕竟是人员多的大项目，两三个人的小项目谈不上架构也能玩的溜。一切都是要从实际需求角度出发的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594616526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77526,"user_name":"唐鹏","can_delete":false,"product_type":"c1","uid":1234964,"ip_address":"","ucode":"8C83B682556254","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/14/c9a5da22.jpg","comment_is_top":false,"comment_ctime":1552959450,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31617730522","product_id":100024501,"comment_content":"之前在两个公司都用过CTMediator,个人感觉也是最好的解耦方式,虽然有硬编码的问题,但是层次结构非常清楚,十分利于维护.但是目前感觉还是router或者协议化用的比较多,router就不提了,缺点比较明显.协议化除了后面需要严格控制接口输出之外,会造成维护上的困难,另外协议如果不进行严格的判断,也容易造成崩溃问题,也需要额外的开发成本去判断.","like_count":7},{"had_liked":false,"id":77508,"user_name":"kokohuang","can_delete":false,"product_type":"c1","uid":1376208,"ip_address":"","ucode":"3E1FDBF8EBD326","user_header":"https://static001.geekbang.org/account/avatar/00/14/ff/d0/ae326de2.jpg","comment_is_top":false,"comment_ctime":1552957813,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31617728885","product_id":100024501,"comment_content":"CT的扩展值得一试","like_count":7},{"had_liked":false,"id":79306,"user_name":"Link","can_delete":false,"product_type":"c1","uid":1454525,"ip_address":"","ucode":"64849EF2B97975","user_header":"https://static001.geekbang.org/account/avatar/00/16/31/bd/62c945b4.jpg","comment_is_top":false,"comment_ctime":1553432429,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27323236205","product_id":100024501,"comment_content":"CTMediator其实是有几个缺点的:<br>1.如果因为组件找不到而产生一些error,这里虽然不会崩溃,但是调用方其实并不知道,虽然可以对CT进行一些扩展让调用方通过回调知道,这其实也有利于一些UT的编写.<br>2.大量的通过字符串进行调度,实际上很硬核,后期的维护由于没有IDE能帮你做检查,其实复杂了不少.<br>3.CT其实是命名域上的解耦,但我认为项目还是应该更仔细认真的去设计组件和组件间的依赖,毕竟比如你这个功能实际上比如是依赖a和b两个模块,你只导入了b,虽然能够运行,但是实际上功能是不完善的,没有什么意义<br>关于戴老师说的组件只是把能通用的部分才进行组件化还是很赞同的,还有拆分的思路,和人员的搭配,目前也是这么做的,现在的swift项目,想的是就利用cocoapods加协议进行了大量的业务依赖设计,如果你需要导入这个业务模块,他会将相应的业务模块也进行导入,这样无论是类型检测还是相关业务的导入都比较方便.<br><br>我认为CT这样的做法还是比较偷懒的.但是CT其实也能学到不少,自己仿照着写了个,主要是作为一个利用runtime消息安全发送机制.另外casa老师的将内部和外部调用区分开也很值得学习.","like_count":6,"discussions":[{"author":{"id":1134511,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4f/af/50c3e8dd.jpg","nickname":"登品","note":"","ucode":"DA94DA7A7CFE3D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263030,"discussion_content":"您说的命名域上的解耦，在我理解看来那只是CT解耦方式上的一个命名规则吧了。至于你说的依赖两个模块却只倒入了一个，虽正常运行但没有意义；这个我的理解是功能是支持到这里至于你要如何使用那是自己的事了。你说的“如果你需要导入这个业务模块,他会将相应的业务模块也进行导入”，感觉这就是另外一个故事了，现在看起来是有相应关系的两个模块，如果那一天需求变了，那不是得二次解耦了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589164448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77557,"user_name":"Paul","can_delete":false,"product_type":"c1","uid":1435305,"ip_address":"","ucode":"0A50084A1BF6A6","user_header":"https://static001.geekbang.org/account/avatar/00/15/e6/a9/62ce91e9.jpg","comment_is_top":false,"comment_ctime":1552962886,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27322766662","product_id":100024501,"comment_content":"目前也是采用了casatwy的CTMediator组件化方案，项目采用了基础组件+功能组件+业务组件进行架构分层，根据实际业务需求合理选择设计模式，合理遵守六大原则，不要拔出萝卜带出泥","like_count":6},{"had_liked":false,"id":86420,"user_name":"安森👣","can_delete":false,"product_type":"c1","uid":1228646,"ip_address":"","ucode":"833DBCE8AF27AC","user_header":"https://static001.geekbang.org/account/avatar/00/12/bf/66/56568450.jpg","comment_is_top":false,"comment_ctime":1555376842,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23030213322","product_id":100024501,"comment_content":"个人感觉  CTMediator 框架其实还是硬编码方式的，只是通过类别包装了一下，将硬编码调用这块转嫁到库者手中。当然对外是没有这个硬编码的，对内的话，该有的问题仍然存在。 ","like_count":5},{"had_liked":false,"id":77958,"user_name":"今天美德华仔","can_delete":false,"product_type":"c1","uid":1457045,"ip_address":"","ucode":"F9513774AE098F","user_header":"","comment_is_top":false,"comment_ctime":1553046344,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23027882824","product_id":100024501,"comment_content":"我们目前使用的是 url scheme + router ，服务器可以直接返回 url 做跳转。url 使用plist 预先配置好。大家给提点意见。","like_count":5},{"had_liked":false,"id":77814,"user_name":"9527","can_delete":false,"product_type":"c1","uid":1457558,"ip_address":"","ucode":"9D04B2DC38978C","user_header":"https://static001.geekbang.org/account/avatar/00/16/3d/96/47296ed1.jpg","comment_is_top":false,"comment_ctime":1553003964,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23027840444","product_id":100024501,"comment_content":"希望越来越多的demo提供给大家学习呀，感谢！","like_count":5},{"had_liked":false,"id":77792,"user_name":"莫在一思停","can_delete":false,"product_type":"c1","uid":1458384,"ip_address":"","ucode":"2D1FEAF67FA866","user_header":"https://static001.geekbang.org/account/avatar/00/16/40/d0/d49d65ec.jpg","comment_is_top":false,"comment_ctime":1552999364,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23027835844","product_id":100024501,"comment_content":"大神，我问下目前使用WKWebview的cookie丢失问题能处理吗？","like_count":5,"discussions":[{"author":{"id":2170008,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erjPICTRhrjYOSKIaP2G45q8jAic7ve8HL4FTnfqUpRQXp74Kxvr2z6ia0UfAIyDqXREc1Bq54D4otw/132","nickname":"Geek_73e3d1","note":"","ucode":"6FB9C8AAFB63E9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573883,"discussion_content":"webView 你是不清理了cookie信息?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653708601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77462,"user_name":"吃蘑菇的大灰狼","can_delete":false,"product_type":"c1","uid":1079226,"ip_address":"","ucode":"87F72CBAF08D6C","user_header":"https://static001.geekbang.org/account/avatar/00/10/77/ba/b2356241.jpg","comment_is_top":false,"comment_ctime":1552947375,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23027783855","product_id":100024501,"comment_content":"这篇讲到了痛点，但感觉还不够解渴，待我细细品味demo，期待铭神的后续😍","like_count":5},{"had_liked":false,"id":77822,"user_name":"gitbyte","can_delete":false,"product_type":"c1","uid":1003319,"ip_address":"","ucode":"4DB086E6792995","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4f/37/8db3afb9.jpg","comment_is_top":false,"comment_ctime":1553004494,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18732873678","product_id":100024501,"comment_content":"协议化也可以引入统一调度层管理，维护category和protocol的区别，而且有编译检查","like_count":4,"discussions":[{"author":{"id":1176875,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f5/2b/d41c247c.jpg","nickname":"rubick","note":"","ucode":"D5B9E5E1DBA2DD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":243402,"discussion_content":"协议化的有没有可参考的案例？想学习下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587538130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77579,"user_name":"Geek_2844bd","can_delete":false,"product_type":"c1","uid":1462850,"ip_address":"","ucode":"EB1A34D5898FE1","user_header":"","comment_is_top":false,"comment_ctime":1552964417,"is_pvip":false,"replies":[{"id":"28349","content":"CTMediator 也能用在 Swift 上 https:&#47;&#47;github.com&#47;ModulizationDemo&#47;SwfitDemo","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1552976908,"ip_address":"","comment_id":77579,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18732833601","product_id":100024501,"comment_content":"swift项目架构解藕有什么好的推荐吗","like_count":4,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443784,"discussion_content":"CTMediator 也能用在 Swift 上 https://github.com/ModulizationDemo/SwfitDemo","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552976908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77523,"user_name":"流氓兔","can_delete":false,"product_type":"c1","uid":1457155,"ip_address":"","ucode":"2513971D430E3B","user_header":"https://static001.geekbang.org/account/avatar/00/16/3c/03/d94ab93f.jpg","comment_is_top":false,"comment_ctime":1552959304,"is_pvip":false,"replies":[{"id":"28356","content":"小型项目其实是可以用中间者架构的，也是为了做大做准备","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1552979507,"ip_address":"","comment_id":77523,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18732828488","product_id":100024501,"comment_content":"现在负责的是一个很小的项目，用的还是普通的MVC模式，是否也需要改变架构，就是说，在小型项目中（没有变成大项目的可能性），使用中间者架构会不会更麻烦了","like_count":4,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443759,"discussion_content":"小型项目其实是可以用中间者架构的，也是为了做大做准备","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552979507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77514,"user_name":"景迪","can_delete":false,"product_type":"c1","uid":1456564,"ip_address":"","ucode":"9176C843E49BE2","user_header":"https://static001.geekbang.org/account/avatar/00/16/39/b4/b0cb712a.jpg","comment_is_top":false,"comment_ctime":1552958631,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18732827815","product_id":100024501,"comment_content":"打个卡慢慢看，每天不看一遍感觉少了点什么","like_count":4},{"had_liked":false,"id":85300,"user_name":"aliyunyun","can_delete":false,"product_type":"c1","uid":1483221,"ip_address":"","ucode":"E8343A08C79B12","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/2eC1bLSGUUqECSQWFa6eEOpgLtnZBZ0nY1j5lNic4NmYGymPzN5VK8iaRUFab7opqJVzMWEF2DgiasLeH1U9WlPrg/132","comment_is_top":false,"comment_ctime":1555031805,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14439933693","product_id":100024501,"comment_content":"CTMediator 本质上是完成了编译上的解耦，将代码的执行耦合延迟到了运行时","like_count":3,"discussions":[{"author":{"id":1733815,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/74/b7/3b3ffa56.jpg","nickname":"脚踏实地","note":"","ucode":"E198A82B586C43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269201,"discussion_content":"对啊，反复品味还是不能理解其所谓的经典之处。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589877813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":80645,"user_name":"Beautilut","can_delete":false,"product_type":"c1","uid":1366590,"ip_address":"","ucode":"5746F62EBDED9C","user_header":"","comment_is_top":false,"comment_ctime":1553692810,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"14438594698","product_id":100024501,"comment_content":"我们公司现在4个人，但一个工程被拆成了30个左右的pods。每次提交代码都需要提交十几个库，痛苦不堪。看了老师的文章，文章给出了大规模团队的方案，但是小团队如果也这样使用的话不知道其他同学有么有遇到过像我这样的困恼。","like_count":3,"discussions":[{"author":{"id":1073837,"avatar":"https://static001.geekbang.org/account/avatar/00/10/62/ad/068b9bf1.jpg","nickname":"请不要修改账号信息，谢谢","note":"","ucode":"A83C3A5B64898E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":229235,"discussion_content":"粒度分的太细了，或者解耦不充分。每次提交十几个库，很是问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586616251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1070578,"avatar":"https://static001.geekbang.org/account/avatar/00/10/55/f2/e5b7ea9c.jpg","nickname":"乐乐乐","note":"","ucode":"BA8C4D218F67E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7510,"discussion_content":"这个是不是粒度太小了呢，强耦合的业务作为一个pod不行吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567521895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77696,"user_name":"大巧不工","can_delete":false,"product_type":"c1","uid":1454939,"ip_address":"","ucode":"CCAFDAC7DC67A3","user_header":"https://static001.geekbang.org/account/avatar/00/16/33/5b/ea09a196.jpg","comment_is_top":false,"comment_ctime":1552982694,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14437884582","product_id":100024501,"comment_content":"- (id)executeMethod:(SEL)method obj:(NSObject *)obj parameters:(NSDictionary *)parameters {<br>    NSMethodSignature* methodSig = [obj methodSignatureForSelector:method];<br>    if(methodSig == nil) {<br>        return nil;<br>    }<br>    const char* retType = [methodSig methodReturnType];<br>    <br>    if (strcmp(retType, @encode(void)) == 0) {<br>        NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:methodSig];<br>        [invocation setArgument:&amp;parameters atIndex:2];<br>        [invocation setSelector:method];<br>        [invocation setTarget:obj];<br>        [invocation invoke];<br>        return nil;<br>    }<br>#pragma clang diagnostic push<br>#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;<br>    return [obj performSelector:method withObject:parameters];<br>#pragma clang diagnostic pop<br>}<br><br>这里为什么单独判断void 。casa是判断的基础数据类型，你们为什么不直接return [obj performSelector:method withObject:parameters]; 或者每一种类型都展开 是存在什么疑虑吗，你这个写法相比casa有什么优化","like_count":3,"discussions":[{"author":{"id":1070578,"avatar":"https://static001.geekbang.org/account/avatar/00/10/55/f2/e5b7ea9c.jpg","nickname":"乐乐乐","note":"","ucode":"BA8C4D218F67E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7509,"discussion_content":"这种在framework情况下，直接[obj performSelector:method withObject:parameters]进行调用，如果action对应无返回值或基本类型会导致crash","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567521678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":309131,"user_name":"石头汤","can_delete":false,"product_type":"c1","uid":1022282,"ip_address":"","ucode":"45E4578E54F585","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/4a/bdf26d5c.jpg","comment_is_top":false,"comment_ctime":1629955676,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10219890268","product_id":100024501,"comment_content":"核心就是 大家对 &quot;耦合&quot; ，&quot;依赖&quot; 的判定标准是不同的。例如，IM , LOGIN 两个 模块在业务上有逻辑的依赖时，比如 IM 要调用登录LOGIN功能，代码上要不要也有一个&quot;依赖&quot;关系？还是认为这是&quot;耦合&quot;？<br> <br>uri router, mediator 的方案是 把编译期的代码依赖放到运行期，实现模块&quot;解耦&quot;，完全去掉代码依赖；<br>protocol 是编译期依赖，用 protocol 达到解耦的同时，保留明确的依赖关系。<br><br>我的看法是，依赖跟耦合是两码事。<br>解耦不是我们的目标，只是一个途径，模块化也只是更大的一个实现途径，最终提升多业务的协同开发效率才是目标，不能本末倒置了。<br><br>业务上有关联，适度的代码依赖是必须的，不要耦合过多具体实现就可以。<br><br>用uri, target-action 把依赖也去掉，达到&quot;解耦&quot;，丢失了编译期检查，后果是不运行到那一行代码，或者不崩溃都不知道代码出问题了，没尽早暴露问题，导致开发效率更低了","like_count":2},{"had_liked":false,"id":210326,"user_name":"Geek_9dbcb4","can_delete":false,"product_type":"c1","uid":1785940,"ip_address":"","ucode":"BB92D5E844A743","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/rWMGIQG1z13nekorr9I4PY1w7rlskssf949IQ24SvIewpM7mmZoH2QEZ2aKHu5tkmicGQ7KTGrN9vFYhrDsdp9w/132","comment_is_top":false,"comment_ctime":1587721613,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10177656205","product_id":100024501,"comment_content":"为什么要做2个库（分类库和组件库）啊？<br>一个库也行啊。把分类也放到组件里。我们在用的时候，直接依赖分类好了。<br>两个库，能想到的好处是，方便指定分类库和组件库的版本。但是一般情况下，多此一举。<br>大家觉得呢？","like_count":3,"discussions":[{"author":{"id":1328565,"avatar":"https://static001.geekbang.org/account/avatar/00/14/45/b5/081ff639.jpg","nickname":"贺彦文","note":"","ucode":"1FB6C61394FE72","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340926,"discussion_content":"是的 我也认为分类写到中间者的库里比较好 以subspec形式 写到中间者。两个库势必造成大量业务库数量倍数增加，这样项目看着有点乱。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1610205120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201561,"user_name":"SuperMario","can_delete":false,"product_type":"c1","uid":1455888,"ip_address":"","ucode":"22B34DD5A1FA4D","user_header":"https://static001.geekbang.org/account/avatar/00/16/37/10/4e03be02.jpg","comment_is_top":false,"comment_ctime":1585803519,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10175738111","product_id":100024501,"comment_content":"组件化真的需要实战才能深刻理解","like_count":2},{"had_liked":false,"id":123946,"user_name":"Hello灬麦德姆","can_delete":false,"product_type":"c1","uid":1458884,"ip_address":"","ucode":"7F1E617401F9CD","user_header":"https://static001.geekbang.org/account/avatar/00/16/42/c4/b9166b7d.jpg","comment_is_top":false,"comment_ctime":1565783544,"is_pvip":false,"replies":[{"id":"45993","content":"显示和隐藏都是针对某个视图的展示用，属于相通功能。如果要把视图是否能点击同时当作参数传入控制，就属于两个功能了","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1566154837,"ip_address":"","comment_id":123946,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10155718136","product_id":100024501,"comment_content":"戴明老师，我对这个有些疑问，接口隔离原则：接口的用途要单一，不要在一个接口上根据不同入参实现多个功能。假如我需要实现功能，显示或隐藏一个试图，那我是应该写两个方法，一个是func show()一个是func hide()吗，这个隐藏或显示功能应该算一个功能还是两个功能呢？或者说刨根问底，这个功能划分到什么程度呢？","like_count":3,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462909,"discussion_content":"显示和隐藏都是针对某个视图的展示用，属于相通功能。如果要把视图是否能点击同时当作参数传入控制，就属于两个功能了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566154837,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85502,"user_name":"Boomm","can_delete":false,"product_type":"c1","uid":1482035,"ip_address":"","ucode":"2823892613C1FE","user_header":"","comment_is_top":false,"comment_ctime":1555080507,"is_pvip":true,"replies":[{"id":"30665","content":" VSCode 支持开发者开发插件，那么他设计的插件这套架构就是灵活的，多一个插件和少一个插件对于整个 VSCode 不会有影响。微信小程序架构也是类似，这里的灵活是指的这个。","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1555120556,"ip_address":"","comment_id":85502,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10145015099","product_id":100024501,"comment_content":"协议式编程接口定义模式过于规范，从而使得架构的灵活性不够高。<br><br>老师好，我理解目前主流的协议式编程基本是ModuleManager+Protocol—Class注册的方式. 即组件将提供的服务以Protocol为key, protocol—impl为value，注册到Manager中.  <br>这样调用方不直接依赖组件，只依赖组件提供的Protocol即可. <br><br>我认为这里和CT一个很大的不同是调用方除了Manager（中间者）还需要依赖对应的Protocol才能发现服务，而CT只依赖中间者.  <br><br>但是对于老师提到的Protocol方式过于规范导致灵活性降低，有一点疑惑. <br>Protocol方式如果组件提供的接口有变更，需要修改protocol和对应的impl，而CT同样需要修改CTMediator+组件X这个分类，这里不灵活具体体现在哪里呢？  <br><br>恳请戴老师解惑！<br><br>","like_count":2,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446688,"discussion_content":" VSCode 支持开发者开发插件，那么他设计的插件这套架构就是灵活的，多一个插件和少一个插件对于整个 VSCode 不会有影响。微信小程序架构也是类似，这里的灵活是指的这个。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555120556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1328565,"avatar":"https://static001.geekbang.org/account/avatar/00/14/45/b5/081ff639.jpg","nickname":"贺彦文","note":"","ucode":"1FB6C61394FE72","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340924,"discussion_content":"那这么说的话 Protocol也没有降低灵活度吧 Protocol的增加也不会造成多大影响吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610204971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84195,"user_name":"SC2021","can_delete":false,"product_type":"c1","uid":1470164,"ip_address":"","ucode":"15F8F35DC9DBA1","user_header":"https://static001.geekbang.org/account/avatar/00/16/6e/d4/9538987d.jpg","comment_is_top":false,"comment_ctime":1554801204,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10144735796","product_id":100024501,"comment_content":"以BeeHive为例子讲感觉会更好点，一个大型的项目一般都是 URL、Protocol、Runtime结合起来的","like_count":2},{"had_liked":false,"id":83123,"user_name":"几缕阳光","can_delete":false,"product_type":"c1","uid":1208725,"ip_address":"","ucode":"9B2D8137A12445","user_header":"https://static001.geekbang.org/account/avatar/00/12/71/95/9df437ae.jpg","comment_is_top":false,"comment_ctime":1554430465,"is_pvip":false,"replies":[{"id":"30028","content":"协议式编程","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1554450100,"ip_address":"","comment_id":83123,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10144365057","product_id":100024501,"comment_content":"依赖反转原则：方法应该依赖抽象，不要依赖实例。<br><br>这句话应该怎么理解?我有点懵哦，希望大神能举个栗子。","like_count":2,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445871,"discussion_content":"协议式编程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554450100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":80980,"user_name":"Geforceyu","can_delete":false,"product_type":"c1","uid":1354965,"ip_address":"","ucode":"054F6F32678218","user_header":"https://static001.geekbang.org/account/avatar/00/14/ac/d5/c1deff12.jpg","comment_is_top":false,"comment_ctime":1553768586,"is_pvip":false,"replies":[{"id":"29464","content":"赞","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1553836717,"ip_address":"","comment_id":80980,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10143703178","product_id":100024501,"comment_content":"自己写了一个模块化解耦方案的DEMO，请大佬过过目<br>https:&#47;&#47;github.com&#47;Geforceyu&#47;FisherMan","like_count":2,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445036,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553836717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":80326,"user_name":"执意为莱","can_delete":false,"product_type":"c1","uid":1458183,"ip_address":"","ucode":"C6C7E9832F6CAF","user_header":"","comment_is_top":false,"comment_ctime":1553649264,"is_pvip":false,"replies":[{"id":"29271","content":"参与开源项目积累大型项目经验","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1553657801,"ip_address":"","comment_id":80326,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10143583856","product_id":100024501,"comment_content":"戴老师,从开是到现在一直是一个人开发,对于组件化或者架构一窍不通,该如何下手呢?","like_count":2,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444822,"discussion_content":"参与开源项目积累大型项目经验","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553657801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77460,"user_name":"Bifico","can_delete":false,"product_type":"c1","uid":1459806,"ip_address":"","ucode":"AEA686D99F6652","user_header":"https://static001.geekbang.org/account/avatar/00/16/46/5e/2da0d188.jpg","comment_is_top":false,"comment_ctime":1552946702,"is_pvip":false,"replies":[{"id":"28366","content":"参看留言","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1552991042,"ip_address":"","comment_id":77460,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10142881294","product_id":100024501,"comment_content":"oc里面可以利用运行时来实现，但是swift项目里面有什么好的办法啊？","like_count":2,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443733,"discussion_content":"参看留言","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552991042,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77441,"user_name":"送你的独白","can_delete":false,"product_type":"c1","uid":1457496,"ip_address":"","ucode":"FDB88C7F172020","user_header":"https://static001.geekbang.org/account/avatar/00/16/3d/58/61997c64.jpg","comment_is_top":false,"comment_ctime":1552925423,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10142860015","product_id":100024501,"comment_content":"前排，曾经对着CTM敲了一遍，但是还是不理解，现在听君一席话 胜读十年书啊","like_count":2},{"had_liked":false,"id":96468,"user_name":"Kim","can_delete":false,"product_type":"c1","uid":1459100,"ip_address":"","ucode":"E3C8D1C0E9C0A5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLJzrtHs9DeaIR6eSlo2DKm93q69AWaB9ibEmlO6PDbic9iajFSwZLhAGLtbDgrbUI7aadyEiaK6lL4FA/132","comment_is_top":false,"comment_ctime":1558430660,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5853397956","product_id":100024501,"comment_content":"目前所呆的公司和所做的项目，都是人员单一，项目简单，也不会面临项目越来越大，人员越来越多的情况，使用简单的MVC架构模式就可以，这种情况下，还有必要重构吗？如何能够学到这种架构思想？","like_count":1},{"had_liked":false,"id":92675,"user_name":"geeklyc","can_delete":false,"product_type":"c1","uid":1264061,"ip_address":"","ucode":"F25441AB6433B3","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/bd/ae37990b.jpg","comment_is_top":false,"comment_ctime":1557311357,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5852278653","product_id":100024501,"comment_content":"老师，有基于CTMediator的Swift的状态机demo不","like_count":1},{"had_liked":false,"id":92326,"user_name":"Time Stone.","can_delete":false,"product_type":"c1","uid":1509872,"ip_address":"","ucode":"F0064B3A60EB8B","user_header":"https://static001.geekbang.org/account/avatar/00/17/09/f0/824d2705.jpg","comment_is_top":false,"comment_ctime":1557233591,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5852200887","product_id":100024501,"comment_content":"组件通信有的会通过路由进行管理，类似url私有协议的调用，大神这种模式怎么样？这种是不是也属于中间者模式","like_count":1},{"had_liked":false,"id":89463,"user_name":"吴开","can_delete":false,"product_type":"c1","uid":1481849,"ip_address":"","ucode":"0A55B7A90A1D0F","user_header":"","comment_is_top":false,"comment_ctime":1556179112,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5851146408","product_id":100024501,"comment_content":"戴老师，我们现在用的MVVM，代码精简了比较多，但还是感觉冗余，并且开发效率慢，相对于MVC来说，我们对于组件也使用了中间人这种类似的简单封装，但是并不完全规范，您这边组件化有例子吗","like_count":1,"discussions":[{"author":{"id":1409087,"avatar":"https://static001.geekbang.org/account/avatar/00/15/80/3f/bc65b009.jpg","nickname":"Yest","note":"","ucode":"1E82B6355890C0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390814,"discussion_content":"找到了 规范的例子吗？辛苦分享下哈~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630056088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81587,"user_name":"Sean Ma","can_delete":false,"product_type":"c1","uid":1431314,"ip_address":"","ucode":"A467C04AF3CADE","user_header":"https://static001.geekbang.org/account/avatar/00/15/d7/12/416b60ba.jpg","comment_is_top":false,"comment_ctime":1553955094,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5848922390","product_id":100024501,"comment_content":"可不可以案例也做个swift版的，因为swift和oc还是有很多不一样的","like_count":1},{"had_liked":false,"id":79848,"user_name":"不拘小节","can_delete":false,"product_type":"c1","uid":1199826,"ip_address":"","ucode":"97E987EB199A80","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIAQdjCbZN4X6cJuicGia0zGMWN22TjagIZLBNgZII09wMyVPSX0fmsicelI9nGhds1vECGkynYOnJag/132","comment_is_top":false,"comment_ctime":1553563677,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5848530973","product_id":100024501,"comment_content":"有个疑问，我理解的协议层和中间件都是一个隔离层，区别是协议层是通过协议的方式隔离，扩展比较麻烦，每次都要修改协议，你的中间件是通过字符串来调用，没有规范，方便扩展，是这个样子吗","like_count":1,"discussions":[{"author":{"id":1071791,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5a/af/774c9e56.jpg","nickname":"爆seed.","note":"","ucode":"16DE5EC6CCCED6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367278,"discussion_content":"我也是这样觉得，其实都是中间者","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618311319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78845,"user_name":"うずまきナルト","can_delete":false,"product_type":"c1","uid":1455407,"ip_address":"","ucode":"1B49AC4D605F6E","user_header":"https://static001.geekbang.org/account/avatar/00/16/35/2f/474946c9.jpg","comment_is_top":false,"comment_ctime":1553256239,"is_pvip":false,"replies":[{"id":"28734","content":"我 demo 里提供了一个新接口可以作一定的限制，可以看看","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1553314339,"ip_address":"","comment_id":78845,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5848223535","product_id":100024501,"comment_content":"组件间通信如果选择暴露Model的话，model的维护成本很高，但是如果选择字典之类的又会失去编译时检查和参数提示的好处。这两个到底怎么选择呢","like_count":1,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444252,"discussion_content":"我 demo 里提供了一个新接口可以作一定的限制，可以看看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553314339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78739,"user_name":"吴小安","can_delete":false,"product_type":"c1","uid":1371398,"ip_address":"","ucode":"EDF8E04F867069","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqr5ibqxYwcSgqPA7s49MZb1vEKKXT4mPTojwiclXkJf3ug26NuzTa6A5gbicR2rAUHdEkUAn13Rr2KQ/132","comment_is_top":false,"comment_ctime":1553226875,"is_pvip":false,"replies":[{"id":"28663","content":"如果多个业务都会用，会下层。","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1553263952,"ip_address":"","comment_id":78739,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5848194171","product_id":100024501,"comment_content":"请问一下对于业务无关组件，例如网络，但是很多工程中网络模块都有一些跟业务相关的配置，例如token，服务器域名这些信息，你们是怎么拆分的？把这些信息都用delegate的方式让外面来实现？或者其他的方式？谢谢","like_count":1,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444218,"discussion_content":"如果多个业务都会用，会下层。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553263952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78397,"user_name":"drunkenMouse","can_delete":false,"product_type":"c1","uid":1454037,"ip_address":"","ucode":"AA8CEA703ECBE8","user_header":"","comment_is_top":false,"comment_ctime":1553139659,"is_pvip":false,"replies":[{"id":"28932","content":"有的参数类型是需要引入相应头文件的","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1553446504,"ip_address":"","comment_id":78397,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5848106955","product_id":100024501,"comment_content":"同时还可以避免.h 文件的耦合，但是其对代码编写效率的降低也比较明显。。不是很理解，平常自己调用函数时的参数，也是String方法传递的啊","like_count":1,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444078,"discussion_content":"有的参数类型是需要引入相应头文件的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553446504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78382,"user_name":"热血CZ👻","can_delete":false,"product_type":"c1","uid":1455159,"ip_address":"","ucode":"16F10BC6912C48","user_header":"https://static001.geekbang.org/account/avatar/00/16/34/37/ae07d946.jpg","comment_is_top":false,"comment_ctime":1553136668,"is_pvip":false,"replies":[{"id":"28539","content":"这也被你看出来了","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1553142181,"ip_address":"","comment_id":78382,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5848103964","product_id":100024501,"comment_content":"戴老师写的demo暴露了自己是怪物猎人玩家","like_count":1,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444073,"discussion_content":"这也被你看出来了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553142181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78377,"user_name":"geeklyc","can_delete":false,"product_type":"c1","uid":1264061,"ip_address":"","ucode":"F25441AB6433B3","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/bd/ae37990b.jpg","comment_is_top":false,"comment_ctime":1553134616,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5848101912","product_id":100024501,"comment_content":"目前采用的CTMediator，分成了基础层、通用业务层，但是具体业务耦合太多不好拆。<br>继续研究","like_count":1},{"had_liked":false,"id":77945,"user_name":"data","can_delete":false,"product_type":"c1","uid":1010493,"ip_address":"","ucode":"4EEC3CE11E65F8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/3d/ae41c2b3.jpg","comment_is_top":false,"comment_ctime":1553044770,"is_pvip":true,"replies":[{"id":"28461","content":"coordinate 的简写","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1553052556,"ip_address":"","comment_id":77945,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5848012066","product_id":100024501,"comment_content":"老师 你这个目录 Cdnt 是啥意思","like_count":1,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443908,"discussion_content":"coordinate 的简写","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553052556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77809,"user_name":"Geek_76828b","can_delete":false,"product_type":"c1","uid":1305469,"ip_address":"","ucode":"FDC4A366235D72","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIsqaoarwqshsY0R3cFcNCVCN9hia2NMmickPsp1Zibic8RKvZiaBvktgydauM8nUE7P2X4aJjoTx4JUvw/132","comment_is_top":false,"comment_ctime":1553003322,"is_pvip":false,"replies":[{"id":"28458","content":"先大块做，再做细节。","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1553048400,"ip_address":"","comment_id":77809,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847970618","product_id":100024501,"comment_content":"目前项目刚好在拆分组件的后期阶段，用的也是CTMediator，一开始的规划感觉很清晰，也是分了三层，想要做到理想的是：高层向底层依赖，同层间互不依赖，不跨层依赖。但是拆完组建后发现因为代码遗留问题完全无法避免同层间的相互依赖。只能硬着头皮先做完，拆分组装后慢慢优化了。","like_count":1,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443862,"discussion_content":"先大块做，再做细节。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553048400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77543,"user_name":"笨猫","can_delete":false,"product_type":"c1","uid":1454599,"ip_address":"","ucode":"D15B3C7F556FF4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoIXZovlARZ9hY89rZnqj1yRAHtzYeajnDJ4QTzS9eENF1YZBI7KIv73uku8bFny1VH0BQ5PUvWlA/132","comment_is_top":false,"comment_ctime":1552961197,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5847928493","product_id":100024501,"comment_content":"目前写的就是中间者模式架构，主做前端与wkwebview的交互，在前端只注册一个方法名，在wk的代理中，native通过中间者到一个中转组件（可管理拓展组件），中转组件再连接到其他组件","like_count":1},{"had_liked":false,"id":77536,"user_name":"华仔","can_delete":false,"product_type":"c1","uid":1456384,"ip_address":"","ucode":"25ACA96ADA7EE9","user_header":"https://static001.geekbang.org/account/avatar/00/16/39/00/30664850.jpg","comment_is_top":false,"comment_ctime":1552960253,"is_pvip":false,"replies":[{"id":"28354","content":"不用每次，一个版本周期内整体交付时增加版本号","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1552978505,"ip_address":"","comment_id":77536,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847927549","product_id":100024501,"comment_content":"使用pod私有仓库分仓管理，每次改代码都需要提交一个版本号吗","like_count":1,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443765,"discussion_content":"不用每次，一个版本周期内整体交付时增加版本号","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552978505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77475,"user_name":"yuhao0x0628","can_delete":false,"product_type":"c1","uid":1332463,"ip_address":"","ucode":"BFD472974828A5","user_header":"https://static001.geekbang.org/account/avatar/00/14/54/ef/3cdfd916.jpg","comment_is_top":false,"comment_ctime":1552954526,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5847921822","product_id":100024501,"comment_content":"感謝分享，思路很棒，收穫很多。<br>不過希望能夠多看到一些 swift 的案例與跟OC不同的特性與用法!","like_count":1},{"had_liked":false,"id":313929,"user_name":"ReturnTrue","can_delete":false,"product_type":"c1","uid":1332243,"ip_address":"","ucode":"7B550E05860AB7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKXDEvzzjFrgTLou3Bib81IEFiatoiaFx7d5h1PS94CKicdkicGobjk1rLOkhGcfQG0xFXRyjWfiaCNr0vw/132","comment_is_top":false,"comment_ctime":1632744832,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632744832","product_id":100024501,"comment_content":"中间件或者协议式都是在解决业务层的横向耦合，使得业务模块可以可插拔，这个很好理解。<br>但是我这有个疑问，原则上除了业务层之外，要尽量的切断同一层次之间的横向依赖，但是这种情况却总是不可完全避免，对于基础层模块横向依赖的问题，要如何解决？比如：我们想在网络请求模块里面，进行埋点统计下，统计一下网络库的相关数据，不是业务接口的数据哈？<br>还请老师解答下","like_count":0},{"had_liked":false,"id":301491,"user_name":"Vvin","can_delete":false,"product_type":"c1","uid":1459341,"ip_address":"","ucode":"664901060BDA33","user_header":"","comment_is_top":false,"comment_ctime":1625714273,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625714273","product_id":100024501,"comment_content":"你好， Demo 中<br>1. publishButton、 factoryMethodButton不放在FirstVC而放在Cdnt+First中组装的意义是？<br>2. 这两个hardcoded key 是在FirstListCom.m源码里才能看到，调用方如何得知？<br>谢谢！","like_count":0},{"had_liked":false,"id":285828,"user_name":"晓田","can_delete":false,"product_type":"c1","uid":1146180,"ip_address":"","ucode":"0708D17B8F706D","user_header":"https://static001.geekbang.org/account/avatar/00/11/7d/44/d46a6939.jpg","comment_is_top":false,"comment_ctime":1617024168,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617024168","product_id":100024501,"comment_content":"项目的架构其实是中间件和协议式一起使用的；以中间件为主，保留对架构的掌控能力，也定义少量的协议方法，简化调用","like_count":0},{"had_liked":false,"id":277632,"user_name":"Geek_474d69","can_delete":false,"product_type":"c1","uid":1523323,"ip_address":"","ucode":"FF162456D85B16","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJQjaibDIKHPj2zdJdZu0JIQlia3Na0iblq7wsG9qOmXI36JMW48icckJbkFjBskS16kOn7r2aCF1rULw/132","comment_is_top":false,"comment_ctime":1612497652,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612497652","product_id":100024501,"comment_content":"老师组件化的学习有哪些好的资料给推荐推荐吧","like_count":0},{"had_liked":false,"id":274550,"user_name":"孙西纯","can_delete":false,"product_type":"c1","uid":1049618,"ip_address":"","ucode":"1544F964B8EFB0","user_header":"https://static001.geekbang.org/account/avatar/00/10/04/12/41d71dad.jpg","comment_is_top":false,"comment_ctime":1611056315,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611056315","product_id":100024501,"comment_content":"业务模块之间传递自定义参数感觉不好约束","like_count":0},{"had_liked":false,"id":272182,"user_name":"Geek_b9897d","can_delete":false,"product_type":"c1","uid":1757364,"ip_address":"","ucode":"A8CEE72942E6F1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK8qkY7FUvM16ESFk5nnyUe7nGmHGGcvKBZn3GC0MIyTMchZSaA6ibMKg8QmNIZT2ENSlmuT3BQghA/132","comment_is_top":false,"comment_ctime":1609983725,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609983725","product_id":100024501,"comment_content":"中间者架构和协议式架构这种和MvC相关的架构都属于架构吗？那一般怎么应用呢？设计模式和架构应该不一样吧？设计模式比如工厂模式，mvc这种应该叫做架构方法吧？","like_count":0},{"had_liked":false,"id":239771,"user_name":"Teresa","can_delete":false,"product_type":"c1","uid":1698219,"ip_address":"","ucode":"6106B84BDC30AF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKkDB6420zwODZTJL6icKKTpyFKuVF9GRjj1V5ziaibADbrpDMmicF8Ad5fmBjycibEg3yhpwlVOLzzxRQ/132","comment_is_top":false,"comment_ctime":1596638645,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596638645","product_id":100024501,"comment_content":"我们之前的项目，也基本做到了组件化，但是没有用到中间者，所以耦合性比较大，一个模块替换可能涉及修改的地方就比较多，今天学习了这节课，对中间件有了一个深入的认识，以后项目开发中会借鉴这种方案。","like_count":0},{"had_liked":false,"id":224906,"user_name":"开发小能手","can_delete":false,"product_type":"c1","uid":1107899,"ip_address":"","ucode":"3ED813CBE77009","user_header":"https://static001.geekbang.org/account/avatar/00/10/e7/bb/18eb89fd.jpg","comment_is_top":false,"comment_ctime":1591587588,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591587588","product_id":100024501,"comment_content":"为了方便以后温习,把老师的一篇简书放到这里: [iOS设计模式](https:&#47;&#47;www.jianshu.com&#47;p&#47;8f21c244e3c6)","like_count":0},{"had_liked":false,"id":200189,"user_name":"ASong","can_delete":false,"product_type":"c1","uid":1067962,"ip_address":"","ucode":"D9AD437675C467","user_header":"https://static001.geekbang.org/account/avatar/00/10/4b/ba/1ae1ea6b.jpg","comment_is_top":false,"comment_ctime":1585555154,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585555154","product_id":100024501,"comment_content":"发现戴佬的代码全是硬编码。哈哈","like_count":0},{"had_liked":false,"id":198022,"user_name":"莫言","can_delete":false,"product_type":"c1","uid":1460977,"ip_address":"","ucode":"3B5782B58BFD18","user_header":"https://static001.geekbang.org/account/avatar/00/16/4a/f1/e3b02c6d.jpg","comment_is_top":false,"comment_ctime":1585407190,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585407190","product_id":100024501,"comment_content":"非常棒，如果可以再扩展一下就更好了","like_count":0},{"had_liked":false,"id":160151,"user_name":"Eric","can_delete":false,"product_type":"c1","uid":1233952,"ip_address":"","ucode":"783F963EAA9544","user_header":"https://static001.geekbang.org/account/avatar/00/12/d4/20/079efea7.jpg","comment_is_top":false,"comment_ctime":1575880661,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575880661","product_id":100024501,"comment_content":"对于 iOS 这种面向对象编程的开发模式来说，我们应该遵循以下五个原则，即 SOLID 原则：<br>    1. 单一功能原则：对象功能要单一，不要在一个对象里添加很多功能；<br>    2. 开闭原则：扩展是开放的，修改是要封闭的；<br>    3. 里氏替换原则：子类对象是可以替换基类对象的；<br>    4. 接口隔离原则：接口的用途要单一，不要在一个接口上根据不同入参实现多个功能；<br>    5. 依赖反转原则：方法应该依赖抽象，不要依赖实例。iOS 开发就是高层业务方法依赖于协议。<br> 同时，遵守这五个原则是开发出容易维护和扩展的架构的基础。","like_count":0},{"had_liked":false,"id":144358,"user_name":"Geek_J","can_delete":false,"product_type":"c1","uid":1700598,"ip_address":"","ucode":"E53FC54691F99E","user_header":"https://static001.geekbang.org/account/avatar/00/19/f2/f6/153cd1ba.jpg","comment_is_top":false,"comment_ctime":1571902896,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571902896","product_id":100024501,"comment_content":"你好，我一直好奇一个问题，就是现阶段滴滴的iOS端有多少人进行共同开发呢？","like_count":0},{"had_liked":false,"id":123938,"user_name":"Hello灬麦德姆","can_delete":false,"product_type":"c1","uid":1458884,"ip_address":"","ucode":"7F1E617401F9CD","user_header":"https://static001.geekbang.org/account/avatar/00/16/42/c4/b9166b7d.jpg","comment_is_top":false,"comment_ctime":1565782837,"is_pvip":false,"replies":[{"id":"45994","content":"哈哈","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1566154847,"ip_address":"","comment_id":123938,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565782837","product_id":100024501,"comment_content":"戴明师傅，染头发是大牛的标志吗？😀","like_count":0,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462905,"discussion_content":"哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566154847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115266,"user_name":"矮个子先生😝","can_delete":false,"product_type":"c1","uid":1147205,"ip_address":"","ucode":"2242A457B0E10D","user_header":"https://static001.geekbang.org/account/avatar/00/11/81/45/9aa91b75.jpg","comment_is_top":false,"comment_ctime":1563521836,"is_pvip":false,"replies":[{"id":"42874","content":"赞","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1563983725,"ip_address":"","comment_id":115266,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563521836","product_id":100024501,"comment_content":"目前我们也是自己仿造CTMediator写的一套中间者进行组件间通信,之前就是觉得传参数比较麻烦,今天学习到了可以通过扩展明确方法和参数","like_count":0,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459035,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563983725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104878,"user_name":"老林sir","can_delete":false,"product_type":"c1","uid":1375813,"ip_address":"","ucode":"757727F69D926C","user_header":"https://static001.geekbang.org/account/avatar/00/14/fe/45/992ffe11.jpg","comment_is_top":false,"comment_ctime":1560861954,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560861954","product_id":100024501,"comment_content":"协议式架构和中间者架构冲突么，我咋感觉它们可以整合到一起呀，不知道是不是我对这两个架构理解有误","like_count":0},{"had_liked":false,"id":103288,"user_name":"青冈","can_delete":false,"product_type":"c1","uid":1080446,"ip_address":"","ucode":"8E54B939937E6D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoYBX95GZxEdKz9LQJVwohUiaRxNge5WpHRbeOC2tGc2rsdpfYKCTKdQicBn8MvSrlZTX7HY2jS3YFA/132","comment_is_top":false,"comment_ctime":1560409616,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560409616","product_id":100024501,"comment_content":"你好，我有一个概念没有理清楚。MVC、MVP、MVVM这些是设计模式。那它们可否叫做App架构呢，我能否说我的App架构是MVVM。","like_count":0},{"had_liked":false,"id":102918,"user_name":"提盏星灯逛人间","can_delete":false,"product_type":"c1","uid":1576358,"ip_address":"","ucode":"E99309FAA4AC88","user_header":"https://static001.geekbang.org/account/avatar/00/18/0d/a6/6895c4b9.jpg","comment_is_top":false,"comment_ctime":1560328563,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560328563","product_id":100024501,"comment_content":"。。。项目规模太小，总统2.3个人，现在只有一个人，根本没有架构可言。。。","like_count":0},{"had_liked":false,"id":99438,"user_name":"Geek_dd0d9a","can_delete":false,"product_type":"c1","uid":1543345,"ip_address":"","ucode":"B2662CDF0182E0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/xCSaCmiaHJhfibibFuIJe6Izib6vQlB6o1VMcicTytgdfXZFIuJiblW7Ehib8elyiazaJ1QlgqFXZV7zR0d8dVhv7mSBPw/132","comment_is_top":false,"comment_ctime":1559214469,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559214469","product_id":100024501,"comment_content":"最近做的项目，工程庞大，划分了几十个小模块，我归纳如下：<br>上层：<br>MainTarget  (主工程)，<br>Dashboard, Map, Mall, Vehicle, Profile<br>中间层:<br>park, wallet, accountService, AutoComplete, Maps, MobilityCommon, CityList等<br>底层:<br>Networking, Cache, Analytics等。<br>项目采用MVVM架构，每个功能模块包含coordinator, view, viewController, Model类. <br>通过coordinator 类来控制不同页面之间的跳转，有点类似于中间者模式的Mediator。","like_count":0},{"had_liked":false,"id":97306,"user_name":"Kai","can_delete":false,"product_type":"c1","uid":1024088,"ip_address":"","ucode":"CD3FACF1803D8F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a0/58/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1558651888,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558651888","product_id":100024501,"comment_content":"Mediator似乎用到了Objc的runtime性质，但在Swift中不能再runtime才决定class。这个要怎么做呢？","like_count":0},{"had_liked":false,"id":95115,"user_name":"Geek__0b57feb4ac35","can_delete":false,"product_type":"c1","uid":1455121,"ip_address":"","ucode":"43F197D99B1114","user_header":"","comment_is_top":false,"comment_ctime":1557970028,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557970028","product_id":100024501,"comment_content":"明神你好，我想问下在flutter中如何使用中介者模式，能给个思路吗？","like_count":0},{"had_liked":false,"id":91553,"user_name":"云端","can_delete":false,"product_type":"c1","uid":1043108,"ip_address":"","ucode":"CBCB3E39E54F01","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ea/a4/4f5325fb.jpg","comment_is_top":false,"comment_ctime":1557054307,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557054307","product_id":100024501,"comment_content":"可以将不常改变的使用本地路径。","like_count":0},{"had_liked":false,"id":91185,"user_name":"烩面","can_delete":false,"product_type":"c1","uid":1473148,"ip_address":"","ucode":"226C99988D3A58","user_header":"https://static001.geekbang.org/account/avatar/00/16/7a/7c/7bde009a.jpg","comment_is_top":false,"comment_ctime":1556892951,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556892951","product_id":100024501,"comment_content":"从业务中来，到业务中去。太精辟了！","like_count":0},{"had_liked":false,"id":87376,"user_name":"GODV","can_delete":false,"product_type":"c1","uid":1454163,"ip_address":"","ucode":"DB311A5D9EE770","user_header":"https://static001.geekbang.org/account/avatar/00/16/30/53/01a6c4da.jpg","comment_is_top":false,"comment_ctime":1555579219,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555579219","product_id":100024501,"comment_content":"通过戴老师的demo学习，了解的更加清楚","like_count":0},{"had_liked":false,"id":87030,"user_name":"1147123","can_delete":false,"product_type":"c1","uid":1464231,"ip_address":"","ucode":"105C3331DB76E1","user_header":"https://static001.geekbang.org/account/avatar/00/16/57/a7/c1163378.jpg","comment_is_top":false,"comment_ctime":1555499078,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555499078","product_id":100024501,"comment_content":"大神，有没有协议式架构的例子可以推荐学习下。没有例子学的有些吃力，网上也找不到相关的博客","like_count":0},{"had_liked":false,"id":84957,"user_name":"LeeWong","can_delete":false,"product_type":"c1","uid":1457272,"ip_address":"","ucode":"14A39710472221","user_header":"https://static001.geekbang.org/account/avatar/00/16/3c/78/9f052793.jpg","comment_is_top":false,"comment_ctime":1554949492,"is_pvip":false,"replies":[{"id":"30718","content":"对外暴露接口不要这样写，内部怎么写，你看觉得怎么好维护怎么写就行","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1555139486,"ip_address":"","comment_id":84957,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554949492","product_id":100024501,"comment_content":"开闭原则：扩展是开放的，修改是封闭的。<br>修改是封闭的 是可以理解的 比如通过设置readonly让某些属性是只读 不让外界去修改<br>扩展是开放的是指？通过子类分类这种形式的扩展？ 这里扩展具体是什么样的操作呢<br><br>接口隔离原则：接口的用途要单一，不要在一个接口上根据不同入参实现多个功能。<br><br>我们项目中有很多地方实际上在入参时加上type区分 内部做不同操作 按照这个原则 这种场景下 应该怎么解决呢 写两个方法吗？","like_count":0,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446508,"discussion_content":"对外暴露接口不要这样写，内部怎么写，你看觉得怎么好维护怎么写就行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555139486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82612,"user_name":"fangkun Lam","can_delete":false,"product_type":"c1","uid":1456852,"ip_address":"","ucode":"A0B4938244BE58","user_header":"https://static001.geekbang.org/account/avatar/00/16/3a/d4/fc9ad4b7.jpg","comment_is_top":false,"comment_ctime":1554259360,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554259360","product_id":100024501,"comment_content":"当时项目中也有用到CT，但是由于新人不易于理解好接受，后面就没有再使用了。开始时也是不是很懂具体的运行思路的，后面看多几遍还是了解了一些。不久前，也看到了另一个设计模式 VIPER，感觉这个对于自身的职责分工更明确一些。铭哥你怎么看呢？","like_count":0},{"had_liked":false,"id":81044,"user_name":"alloc","can_delete":false,"product_type":"c1","uid":1065379,"ip_address":"","ucode":"25E507195716C5","user_header":"https://static001.geekbang.org/account/avatar/00/10/41/a3/be42037c.jpg","comment_is_top":false,"comment_ctime":1553783802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553783802","product_id":100024501,"comment_content":"迪米特法则哪去了？","like_count":0},{"had_liked":false,"id":80719,"user_name":"Allan","can_delete":false,"product_type":"c1","uid":1247185,"ip_address":"","ucode":"D4E082DEE098C9","user_header":"https://static001.geekbang.org/account/avatar/00/13/07/d1/edea25d0.jpg","comment_is_top":false,"comment_ctime":1553702036,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553702036","product_id":100024501,"comment_content":"我们使用协议去规范业务开发。在协议的基础上封装标准的基础组件，如果基础组件满足不了业务方，业务方有两种选择，一等待基础组件更新，二如果等不急的话可以根据协议自己扩展。我比较推崇协议的架构方式、主要是灵活，扩展性强。","like_count":0},{"had_liked":false,"id":80016,"user_name":"D","can_delete":false,"product_type":"c1","uid":1457598,"ip_address":"","ucode":"CF297FDD279F22","user_header":"https://static001.geekbang.org/account/avatar/00/16/3d/be/b1198a6f.jpg","comment_is_top":false,"comment_ctime":1553593628,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553593628","product_id":100024501,"comment_content":"大神 等课程结束的时候 可以把第一章中那张ios开发知识体系图补充一下吗，比如在每个知识领域后面加上您认为比较好的方法或者框架，如果有对应的demo就更好了~~","like_count":0},{"had_liked":false,"id":79506,"user_name":"Geek_0ce7bf","can_delete":false,"product_type":"c1","uid":1465997,"ip_address":"","ucode":"258C092B0FF4C8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epMJUobMDyeb9Y798y2sRRFzyHGKZticMqXTjtvibdENqjP4uw13S16FmrlIUiaIfVMz3mF9NwlyEN9w/132","comment_is_top":false,"comment_ctime":1553500658,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553500658","product_id":100024501,"comment_content":"工厂模式有调用的例子吗","like_count":0},{"had_liked":false,"id":79498,"user_name":"Geek_0ce7bf","can_delete":false,"product_type":"c1","uid":1465997,"ip_address":"","ucode":"258C092B0FF4C8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epMJUobMDyeb9Y798y2sRRFzyHGKZticMqXTjtvibdENqjP4uw13S16FmrlIUiaIfVMz3mF9NwlyEN9w/132","comment_is_top":false,"comment_ctime":1553499492,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553499492","product_id":100024501,"comment_content":"Demo里的工厂模式没理解什么意思，而且在没有添加中间件的时候也不会调用","like_count":0},{"had_liked":false,"id":79163,"user_name":"二木又土","can_delete":false,"product_type":"c1","uid":1296963,"ip_address":"","ucode":"7D939045990B4D","user_header":"https://static001.geekbang.org/account/avatar/00/13/ca/43/63bdc516.jpg","comment_is_top":false,"comment_ctime":1553393458,"is_pvip":false,"replies":[{"id":"28922","content":"都会用到的可以都放到一个 pod 里","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1553420625,"ip_address":"","comment_id":79163,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553393458","product_id":100024501,"comment_content":"基本每个app都会用到登录，注册这样相似的功能，这块代码是用本地pod方式作为组件吗？还是有其他办法？","like_count":0,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444379,"discussion_content":"都会用到的可以都放到一个 pod 里","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553420625,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79047,"user_name":"梦翼","can_delete":false,"product_type":"c1","uid":1265322,"ip_address":"","ucode":"C1D63EAD25960B","user_header":"https://static001.geekbang.org/account/avatar/00/13/4e/aa/3a4708f2.jpg","comment_is_top":false,"comment_ctime":1553331494,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553331494","product_id":100024501,"comment_content":"目前我们项目也正处理组件化的一个阶段，由于项目太多，涉及多个项目组.暂定的一个方案是将项目架构分成四个层次：<br>Feature为业务模块层<br>Modules为公共业务模块层：General、Service、Macros<br>Library为公共库层，包括第三方库、自创建公共库、通用扩展等工具类<br>Resources为资源文件：放置图片、Plist、Storyboard等<br>各模块间的通信采用路由方式，参数都采用字典方式进行传递。<br>艰苦的旅程才刚开始。。。","like_count":0},{"had_liked":false,"id":78769,"user_name":"邵立德","can_delete":false,"product_type":"c1","uid":1456428,"ip_address":"","ucode":"2C2678C69B1986","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLOy7UVQktqvBoicwU9grOw7eVQ6cdpuXRqUO434hRJ0gssWdXQiabqvQ4VbsTT1nibGGjKdjPQFtd5Q/132","comment_is_top":false,"comment_ctime":1553237683,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553237683","product_id":100024501,"comment_content":"文章很棒，在读文章的同时， 也引发了自己的思考 ，感谢作者！","like_count":0},{"had_liked":false,"id":78735,"user_name":"PPAbner","can_delete":false,"product_type":"c1","uid":1454151,"ip_address":"","ucode":"68A8130EA29655","user_header":"https://static001.geekbang.org/account/avatar/00/16/30/47/90300016.jpg","comment_is_top":false,"comment_ctime":1553225880,"is_pvip":false,"replies":[{"id":"28668","content":"我的建议是按照团队来，同一个团队的做成独立的好维护，不同团队考虑到后期沟通会有缺失或者不及时可以各自定义","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1553264149,"ip_address":"","comment_id":78735,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553225880","product_id":100024501,"comment_content":"新项目一开始就用了CT，但是，现在遇到一个问题，因为开发时间赶，有些模型在不同的模块都有，只是取用不同属性罢了，不同的开发人员定义不同的模型，用感觉这样不完美，请问是把模型独立成单独的组件还是就现在，不同开发定义各自的模型？或者你有什么好的建议？谢答！！！","like_count":0,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444216,"discussion_content":"我的建议是按照团队来，同一个团队的做成独立的好维护，不同团队考虑到后期沟通会有缺失或者不及时可以各自定义","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553264149,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78696,"user_name":"zhangkk","can_delete":false,"product_type":"c1","uid":1454235,"ip_address":"","ucode":"9B3FEF97CDED55","user_header":"https://static001.geekbang.org/account/avatar/00/16/30/9b/7bddc304.jpg","comment_is_top":false,"comment_ctime":1553219642,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553219642","product_id":100024501,"comment_content":"感觉评论区挠到痒处😄","like_count":0},{"had_liked":false,"id":78571,"user_name":"Geek_596796","can_delete":false,"product_type":"c1","uid":1454685,"ip_address":"","ucode":"22F69AFECFFB2A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKfvL0gokHaGW2LiaDXoF28kEw37No2ERwJkRWvmMRwiaDJX9BxySUKMicTaMttcubtPo5Sb2CurWCxA/132","comment_is_top":false,"comment_ctime":1553177208,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553177208","product_id":100024501,"comment_content":"很厉害","like_count":0},{"had_liked":false,"id":78513,"user_name":"LuckyRoc","can_delete":false,"product_type":"c1","uid":1456336,"ip_address":"","ucode":"A1DCA9DBC598F4","user_header":"https://static001.geekbang.org/account/avatar/00/16/38/d0/586df031.jpg","comment_is_top":false,"comment_ctime":1553163754,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553163754","product_id":100024501,"comment_content":"哈哈哈哈 CTMediator 好熟悉的一段代码，当时为了搞懂这段代码花了好长时间","like_count":0},{"had_liked":false,"id":78385,"user_name":"mαnajay","can_delete":false,"product_type":"c1","uid":1067450,"ip_address":"","ucode":"6DE9FBD1BEC8AD","user_header":"https://static001.geekbang.org/account/avatar/00/10/49/ba/23c9246a.jpg","comment_is_top":false,"comment_ctime":1553137459,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553137459","product_id":100024501,"comment_content":"对于组件化的方式，我也很奇怪，协议式的这种组件的沟通，也是用类似spring Ioc容器，将协议实例化对象后，返回给调用者，这种应该属于 协议式还是中间者。 ","like_count":0},{"had_liked":false,"id":78230,"user_name":"drunkenMouse","can_delete":false,"product_type":"c1","uid":1454037,"ip_address":"","ucode":"AA8CEA703ECBE8","user_header":"","comment_is_top":false,"comment_ctime":1553097207,"is_pvip":false,"replies":[{"id":"28931","content":"协议式编程思想","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1553446407,"ip_address":"","comment_id":78230,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1553097207","product_id":100024501,"comment_content":"方法应该依赖抽象，不要依赖实例。iOS 开发就是高层业务方法...<br>不是很理解，是指写方法的时候，要把实例抽象化去实现吗？","like_count":0,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444014,"discussion_content":"协议式编程思想","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553446407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1457047,"avatar":"https://static001.geekbang.org/account/avatar/00/16/3b/97/572e263d.jpg","nickname":"再回首恍然如梦","note":"","ucode":"59387A02915F71","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41666,"discussion_content":"依赖倒置的意思？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572485681,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78105,"user_name":"Geek_88f9ac","can_delete":false,"product_type":"c1","uid":1458662,"ip_address":"","ucode":"026D86B4357918","user_header":"","comment_is_top":false,"comment_ctime":1553071337,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553071337","product_id":100024501,"comment_content":"老师，在用CTMediator进行模块化时，遇到了一个问题，如果调用一个模块的接口需要传枚举值或则block回调，这时候我要怎样对外部暴露？<br>","like_count":0},{"had_liked":false,"id":78094,"user_name":"华仔","can_delete":false,"product_type":"c1","uid":1456384,"ip_address":"","ucode":"25ACA96ADA7EE9","user_header":"https://static001.geekbang.org/account/avatar/00/16/39/00/30664850.jpg","comment_is_top":false,"comment_ctime":1553070230,"is_pvip":false,"replies":[{"id":"28821","content":"参看“App 如何通过注入动态库方式实现极速编译调试？”这篇","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1553345159,"ip_address":"","comment_id":78094,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553070230","product_id":100024501,"comment_content":"主工程通过pod安装私有仓库。修改私有仓库的代码的时候怎么使用主工程的代码进行实时查看效果？大佬，求翻牌。","like_count":0,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443966,"discussion_content":"参看“App 如何通过注入动态库方式实现极速编译调试？”这篇","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553345159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78009,"user_name":"山羊","can_delete":false,"product_type":"c1","uid":1456926,"ip_address":"","ucode":"950284E5544F23","user_header":"https://static001.geekbang.org/account/avatar/00/16/3b/1e/10b4f232.jpg","comment_is_top":false,"comment_ctime":1553053960,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553053960","product_id":100024501,"comment_content":"CTMediator打卡！我现在的项目就是当初根据这个改编的组件化，感恩！那段代码我太熟悉了！","like_count":0},{"had_liked":false,"id":77905,"user_name":"大官人","can_delete":false,"product_type":"c1","uid":1459215,"ip_address":"","ucode":"ED9C341D51C03F","user_header":"","comment_is_top":false,"comment_ctime":1553039922,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553039922","product_id":100024501,"comment_content":"项目太小，一人一个，不适合用，","like_count":0},{"had_liked":false,"id":77863,"user_name":"skywalker","can_delete":false,"product_type":"c1","uid":1453861,"ip_address":"","ucode":"2BBCC9D6562F5D","user_header":"https://static001.geekbang.org/account/avatar/00/16/2f/25/2d2cc1c5.jpg","comment_is_top":false,"comment_ctime":1553008458,"is_pvip":false,"replies":[{"id":"28459","content":"算","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1553048435,"ip_address":"","comment_id":77863,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553008458","product_id":100024501,"comment_content":"我项目之前蓝牙POS机模块我用的单例(总控类)+协议+工厂模式。完成统一所有类型的POS机操作，这样算不算一种小规模协议化的应用呢？","like_count":0,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443877,"discussion_content":"算","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553048435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77813,"user_name":"止于止水","can_delete":false,"product_type":"c1","uid":1459453,"ip_address":"","ucode":"F109DF27205293","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo2BicfKfhqiaf1NG1InuZX2kib5hibIj0RxhW8BUkicmCbQjVxIWCUHnoEVGks8rHloa4nwaWM2vcB8Dw/132","comment_is_top":false,"comment_ctime":1553003748,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553003748","product_id":100024501,"comment_content":"每一个模块整一个.h文件，需要对外开放的类都放在这里申明头文件，其他模块需要用到这个模块的功能，引用头文件，调用对外方法不是更好嚒？软编码啊，容易理解维护。第三方库就是这样的。大神怎么理解？","like_count":0},{"had_liked":false,"id":77812,"user_name":"Crazy_cc","can_delete":false,"product_type":"c1","uid":1457792,"ip_address":"","ucode":"1F826C25B75D88","user_header":"https://static001.geekbang.org/account/avatar/00/16/3e/80/31782d05.jpg","comment_is_top":false,"comment_ctime":1553003588,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553003588","product_id":100024501,"comment_content":"目前公司正在采用CTMediator中间者模式进行组件抽离，一直也是一知半解，准备好好研究下CT","like_count":0},{"had_liked":false,"id":77804,"user_name":"有钱才可以为所欲为","can_delete":false,"product_type":"c1","uid":1248027,"ip_address":"","ucode":"1FD642D50E57FA","user_header":"https://static001.geekbang.org/account/avatar/00/13/0b/1b/d4fb3c6c.jpg","comment_is_top":false,"comment_ctime":1553001260,"is_pvip":false,"replies":[{"id":"28457","content":"Mach-O 里 Segment 的 __TEXT 代码段，也是只读数据段","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1553048282,"ip_address":"","comment_id":77804,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553001260","product_id":100024501,"comment_content":"“”接硬编码的调用方式，参数是以 string 的方法保存在内存里，虽然和将参数保存在 Text 字段里占用的内存差不多，同时还可以避免.h 文件的耦合，但是其对代码编写效率的降低也比较明显。”戴老师，Text字段是什么意思？","like_count":0,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443860,"discussion_content":"Mach-O 里 Segment 的 __TEXT 代码段，也是只读数据段","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553048282,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77758,"user_name":"invisible-single","can_delete":false,"product_type":"c1","uid":1458123,"ip_address":"","ucode":"33ECF75BBDB9FC","user_header":"https://static001.geekbang.org/account/avatar/00/16/3f/cb/ad5bc960.jpg","comment_is_top":false,"comment_ctime":1552994100,"is_pvip":false,"replies":[{"id":"28403","content":"两个纬度的问题","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1553000148,"ip_address":"","comment_id":77758,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552994100","product_id":100024501,"comment_content":"看到组件化粒度选择那一段，我有个疑问，如果使用可视化的工具比如xib或者SB，那么如果组件化粒度比VC小这种如何处理，因为各种控件都是集成在一个VC的sb上的","like_count":0,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443839,"discussion_content":"两个纬度的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553000148,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77749,"user_name":"DoIT_WHH","can_delete":false,"product_type":"c1","uid":1036479,"ip_address":"","ucode":"8D74C2205F8C90","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d0/bf/46cec3a2.jpg","comment_is_top":false,"comment_ctime":1552991928,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552991928","product_id":100024501,"comment_content":"最开始也是使用类似的方式做的模块解耦，这种方式在调用接口的时候不太便利，所以我们每个模块的提供者都写了一个中间件的扩展，作为开放的接口，然后在开放的接口实现中调用[CT performTarget:method:params]，因为作为模块的开发者，对于自己模块内方法的定义还是很清楚的。后来换成了Router的方式，在APP启动的时候初始化一个全局的map，保存注册的URL和相应操作的block。","like_count":0},{"had_liked":false,"id":77739,"user_name":"雍鹏亮","can_delete":false,"product_type":"c1","uid":1179992,"ip_address":"","ucode":"A7E394043295B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/01/58/98719136.jpg","comment_is_top":false,"comment_ctime":1552990239,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552990239","product_id":100024501,"comment_content":"早年的java开发，导致根深蒂固的面向接口编程思想，所以在公司选型的时候还是选择的面向协议解耦方式。再者就是方便动态注入实现和实现动态切换，很多东西可能我们只规范的API，但是实现可能各个BU实现不一样。","like_count":0},{"had_liked":false,"id":77659,"user_name":"学武","can_delete":false,"product_type":"c1","uid":1459893,"ip_address":"","ucode":"22DE59C5D69714","user_header":"https://static001.geekbang.org/account/avatar/00/16/46/b5/beedcf35.jpg","comment_is_top":false,"comment_ctime":1552979436,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552979436","product_id":100024501,"comment_content":"实战归纳后，教程化，术语化，还是灵活运用各种已经存在的设计模式。看文章，大神展示了什么是功夫深，从中找到了一些突破方向","like_count":0},{"had_liked":false,"id":77531,"user_name":"长安","can_delete":false,"product_type":"c1","uid":1455687,"ip_address":"","ucode":"751E501BACC5F7","user_header":"","comment_is_top":false,"comment_ctime":1552959858,"is_pvip":false,"replies":[{"id":"28355","content":"独立开发 MVC、MVVM 就可以了","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1552978531,"ip_address":"","comment_id":77531,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552959858","product_id":100024501,"comment_content":"独立开发的该怎么整","like_count":0,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443762,"discussion_content":"独立开发 MVC、MVVM 就可以了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552978531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77527,"user_name":"data","can_delete":false,"product_type":"c1","uid":1010493,"ip_address":"","ucode":"4EEC3CE11E65F8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/3d/ae41c2b3.jpg","comment_is_top":false,"comment_ctime":1552959482,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1552959482","product_id":100024501,"comment_content":"我们还用普通地mvc 也没做组件化","like_count":0},{"had_liked":false,"id":77522,"user_name":"Geek__Leo","can_delete":false,"product_type":"c1","uid":1459870,"ip_address":"","ucode":"217CCBFC909F7D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epKJlW7sqts2dpA7BXo4AD9odu9Xg07P52pcxwlwffCwfFbzJSCATYXYlSFNEXGBDFvObC9l3oVng/132","comment_is_top":false,"comment_ctime":1552959181,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552959181","product_id":100024501,"comment_content":"正在使用中间者模式进行项目组件化演进，受益良多，感谢铭神🙏","like_count":0},{"had_liked":false,"id":77513,"user_name":"晓龙","can_delete":false,"product_type":"c1","uid":1004576,"ip_address":"","ucode":"78CDCEBD183D3A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/20/93c79f7c.jpg","comment_is_top":false,"comment_ctime":1552958628,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552958628","product_id":100024501,"comment_content":"对soild设计原则映像深刻，之前有一次跟老板一起讨论模块设计时，老板就提到soild设计原则，并让我回去研究下，业务繁忙时，大多数人想的都是如何把功能实现了，很少考虑接口设计合理性，就算去考虑，也没有什么原则可以依据，对于像soild这些设计的原则，都是前辈们总结出来的精髓，适用于各个开发人员，做事有章法，才是拉开普通开发者和优秀开发者的差距所在吧","like_count":0},{"had_liked":false,"id":77491,"user_name":"Jersey、","can_delete":false,"product_type":"c1","uid":1358381,"ip_address":"","ucode":"53985C9B1CF73E","user_header":"https://static001.geekbang.org/account/avatar/00/14/ba/2d/e0339b0a.jpg","comment_is_top":false,"comment_ctime":1552956465,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552956465","product_id":100024501,"comment_content":"👍","like_count":0},{"had_liked":false,"id":77487,"user_name":"子phone","can_delete":false,"product_type":"c1","uid":1453697,"ip_address":"","ucode":"F61B39653FE98E","user_header":"https://static001.geekbang.org/account/avatar/00/16/2e/81/e9dd9c83.jpg","comment_is_top":false,"comment_ctime":1552955920,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552955920","product_id":100024501,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":77447,"user_name":"xx007","can_delete":false,"product_type":"c1","uid":1057483,"ip_address":"","ucode":"380155E20DC46D","user_header":"https://static001.geekbang.org/account/avatar/00/10/22/cb/1ca3c053.jpg","comment_is_top":false,"comment_ctime":1552926949,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552926949","product_id":100024501,"comment_content":"打卡","like_count":0}]}