{"id":228964,"title":"21 |  代码重复：搞定代码重复的三个绝招","content":"<p>你好，我是朱晔。今天，我来和你聊聊搞定代码重复的三个绝招。</p><p>业务同学抱怨业务开发没有技术含量，用不到设计模式、Java高级特性、OOP，平时写代码都在堆CRUD，个人成长无从谈起。每次面试官问到“请说说平时常用的设计模式”，都只能答单例模式，因为其他设计模式的确是听过但没用过；对于反射、注解之类的高级特性，也只是知道它们在写框架的时候非常常用，但自己又不写框架代码，没有用武之地。</p><p>其实，我认为不是这样的。设计模式、OOP是前辈们在大型项目中积累下来的经验，通过这些方法论来改善大型项目的可维护性。反射、注解、泛型等高级特性在框架中大量使用的原因是，框架往往需要以同一套算法来应对不同的数据结构，而这些特性可以帮助减少重复代码，提升项目可维护性。</p><p>在我看来，可维护性是大型项目成熟度的一个重要指标，而提升可维护性非常重要的一个手段就是减少代码重复。那为什么这样说呢？</p><ul>\n<li>如果多处重复代码实现完全相同的功能，很容易修改一处忘记修改另一处，造成Bug；</li>\n<li>有一些代码并不是完全重复，而是相似度很高，修改这些类似的代码容易改（复制粘贴）错，把原本有区别的地方改为了一样。</li>\n</ul><p>今天，我就从业务代码中最常见的三个需求展开，和你聊聊如何使用Java中的一些高级特性、设计模式，以及一些工具消除重复代码，才能既优雅又高端。通过今天的学习，也希望改变你对业务代码没有技术含量的看法。</p><!-- [[[read_end]]] --><h2>利用工厂模式+模板方法模式，消除if…else和重复代码</h2><p>假设要开发一个购物车下单的功能，针对不同用户进行不同处理：</p><ul>\n<li>普通用户需要收取运费，运费是商品价格的10%，无商品折扣；</li>\n<li>VIP用户同样需要收取商品价格10%的快递费，但购买两件以上相同商品时，第三件开始享受一定折扣；</li>\n<li>内部用户可以免运费，无商品折扣。</li>\n</ul><p>我们的目标是实现三种类型的购物车业务逻辑，把入参Map对象（Key是商品ID，Value是商品数量），转换为出参购物车类型Cart。</p><p>先实现针对普通用户的购物车处理逻辑：</p><pre><code>//购物车\n@Data\npublic class Cart {\n    //商品清单\n    private List&lt;Item&gt; items = new ArrayList&lt;&gt;();\n    //总优惠\n    private BigDecimal totalDiscount;\n    //商品总价\n    private BigDecimal totalItemPrice;\n    //总运费\n    private BigDecimal totalDeliveryPrice;\n    //应付总价\n    private BigDecimal payPrice;\n}\n//购物车中的商品\n@Data\npublic class Item {\n    //商品ID\n    private long id;\n    //商品数量\n    private int quantity;\n    //商品单价\n    private BigDecimal price;\n    //商品优惠\n    private BigDecimal couponPrice;\n    //商品运费\n    private BigDecimal deliveryPrice;\n}\n//普通用户购物车处理\npublic class NormalUserCart {\n    public Cart process(long userId, Map&lt;Long, Integer&gt; items) {\n        Cart cart = new Cart();\n\n        //把Map的购物车转换为Item列表\n        List&lt;Item&gt; itemList = new ArrayList&lt;&gt;();\n        items.entrySet().stream().forEach(entry -&gt; {\n            Item item = new Item();\n            item.setId(entry.getKey());\n            item.setPrice(Db.getItemPrice(entry.getKey()));\n            item.setQuantity(entry.getValue());\n            itemList.add(item);\n        });\n        cart.setItems(itemList);\n\n        //处理运费和商品优惠\n        itemList.stream().forEach(item -&gt; {\n            //运费为商品总价的10%\n            item.setDeliveryPrice(item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity())).multiply(new BigDecimal(&quot;0.1&quot;)));\n            //无优惠\n            item.setCouponPrice(BigDecimal.ZERO);\n        });\n\n        //计算商品总价\n        cart.setTotalItemPrice(cart.getItems().stream().map(item -&gt; item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity()))).reduce(BigDecimal.ZERO, BigDecimal::add));\n        //计算运费总价\n        cart.setTotalDeliveryPrice(cart.getItems().stream().map(Item::getDeliveryPrice).reduce(BigDecimal.ZERO, BigDecimal::add));\n        //计算总优惠\n        cart.setTotalDiscount(cart.getItems().stream().map(Item::getCouponPrice).reduce(BigDecimal.ZERO, BigDecimal::add));\n        //应付总价=商品总价+运费总价-总优惠\n        cart.setPayPrice(cart.getTotalItemPrice().add(cart.getTotalDeliveryPrice()).subtract(cart.getTotalDiscount()));\n        return cart;\n    }\n}\n</code></pre><p>然后实现针对VIP用户的购物车逻辑。与普通用户购物车逻辑的不同在于，VIP用户能享受同类商品多买的折扣。所以，这部分代码只需要额外处理多买折扣部分：</p><pre><code>public class VipUserCart {\n\n\n    public Cart process(long userId, Map&lt;Long, Integer&gt; items) {\n        ...\n\n\n        itemList.stream().forEach(item -&gt; {\n            //运费为商品总价的10%\n            item.setDeliveryPrice(item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity())).multiply(new BigDecimal(&quot;0.1&quot;)));\n            //购买两件以上相同商品，第三件开始享受一定折扣\n            if (item.getQuantity() &gt; 2) {\n                item.setCouponPrice(item.getPrice()\n                        .multiply(BigDecimal.valueOf(100 - Db.getUserCouponPercent(userId)).divide(new BigDecimal(&quot;100&quot;)))\n                       .multiply(BigDecimal.valueOf(item.getQuantity() - 2)));\n            } else {\n                item.setCouponPrice(BigDecimal.ZERO);\n            }\n        });\n\n\n        ...\n        return cart;\n    }\n}\n</code></pre><p>最后是免运费、无折扣的内部用户，同样只是处理商品折扣和运费时的逻辑差异：</p><pre><code>public class InternalUserCart {\n\n\n    public Cart process(long userId, Map&lt;Long, Integer&gt; items) {\n        ...\n\n        itemList.stream().forEach(item -&gt; {\n            //免运费\n            item.setDeliveryPrice(BigDecimal.ZERO);\n            //无优惠\n            item.setCouponPrice(BigDecimal.ZERO);\n        });\n\n        ...\n        return cart;\n    }\n}\n</code></pre><p>对比一下代码量可以发现，三种购物车70%的代码是重复的。原因很简单，虽然不同类型用户计算运费和优惠的方式不同，但整个购物车的初始化、统计总价、总运费、总优惠和支付价格的逻辑都是一样的。</p><p>正如我们开始时提到的，代码重复本身不可怕，可怕的是漏改或改错。比如，写VIP用户购物车的同学发现商品总价计算有Bug，不应该是把所有Item的price加在一起，而是应该把所有Item的price*quantity加在一起。这时，他可能会只修改VIP用户购物车的代码，而忽略了普通用户、内部用户的购物车中，重复的逻辑实现也有相同的Bug。</p><p>有了三个购物车后，我们就需要根据不同的用户类型使用不同的购物车了。如下代码所示，使用三个if实现不同类型用户调用不同购物车的process方法：</p><pre><code>@GetMapping(&quot;wrong&quot;)\npublic Cart wrong(@RequestParam(&quot;userId&quot;) int userId) {\n    //根据用户ID获得用户类型\n    String userCategory = Db.getUserCategory(userId);\n    //普通用户处理逻辑\n    if (userCategory.equals(&quot;Normal&quot;)) {\n        NormalUserCart normalUserCart = new NormalUserCart();\n        return normalUserCart.process(userId, items);\n    }\n    //VIP用户处理逻辑\n    if (userCategory.equals(&quot;Vip&quot;)) {\n        VipUserCart vipUserCart = new VipUserCart();\n        return vipUserCart.process(userId, items);\n    }\n    //内部用户处理逻辑\n    if (userCategory.equals(&quot;Internal&quot;)) {\n        InternalUserCart internalUserCart = new InternalUserCart();\n        return internalUserCart.process(userId, items);\n    }\n\n    return null;\n}\n</code></pre><p>电商的营销玩法是多样的，以后势必还会有更多用户类型，需要更多的购物车。我们就只能不断增加更多的购物车类，一遍一遍地写重复的购物车逻辑、写更多的if逻辑吗？</p><p>当然不是，相同的代码应该只在一处出现！</p><p>如果我们熟记抽象类和抽象方法的定义的话，这时或许就会想到，是否可以把重复的逻辑定义在抽象类中，三个购物车只要分别实现不同的那份逻辑呢？</p><p>其实，这个模式就是<strong>模板方法模式</strong>。我们在父类中实现了购物车处理的流程模板，然后把需要特殊处理的地方留空白也就是留抽象方法定义，让子类去实现其中的逻辑。由于父类的逻辑不完整无法单独工作，因此需要定义为抽象类。</p><p>如下代码所示，AbstractCart抽象类实现了购物车通用的逻辑，额外定义了两个抽象方法让子类去实现。其中，processCouponPrice方法用于计算商品折扣，processDeliveryPrice方法用于计算运费。</p><pre><code>public abstract class AbstractCart {\n    //处理购物车的大量重复逻辑在父类实现\n    public Cart process(long userId, Map&lt;Long, Integer&gt; items) {\n\n        Cart cart = new Cart();\n\n        List&lt;Item&gt; itemList = new ArrayList&lt;&gt;();\n        items.entrySet().stream().forEach(entry -&gt; {\n            Item item = new Item();\n            item.setId(entry.getKey());\n            item.setPrice(Db.getItemPrice(entry.getKey()));\n            item.setQuantity(entry.getValue());\n            itemList.add(item);\n        });\n        cart.setItems(itemList);\n        //让子类处理每一个商品的优惠\n        itemList.stream().forEach(item -&gt; {\n            processCouponPrice(userId, item);\n            processDeliveryPrice(userId, item);\n        });\n        //计算商品总价\n        cart.setTotalItemPrice(cart.getItems().stream().map(item -&gt; item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity()))).reduce(BigDecimal.ZERO, BigDecimal::add));\n        //计算总运费\ncart.setTotalDeliveryPrice(cart.getItems().stream().map(Item::getDeliveryPrice).reduce(BigDecimal.ZERO, BigDecimal::add));\n        //计算总折扣\ncart.setTotalDiscount(cart.getItems().stream().map(Item::getCouponPrice).reduce(BigDecimal.ZERO, BigDecimal::add));\n        //计算应付价格\ncart.setPayPrice(cart.getTotalItemPrice().add(cart.getTotalDeliveryPrice()).subtract(cart.getTotalDiscount()));\n        return cart;\n    }\n\n    //处理商品优惠的逻辑留给子类实现\n    protected abstract void processCouponPrice(long userId, Item item);\n    //处理配送费的逻辑留给子类实现\n    protected abstract void processDeliveryPrice(long userId, Item item);\n}\n</code></pre><p>有了这个抽象类，三个子类的实现就非常简单了。普通用户的购物车NormalUserCart，实现的是0优惠和10%运费的逻辑：</p><pre><code>@Service(value = &quot;NormalUserCart&quot;)\npublic class NormalUserCart extends AbstractCart {\n\n    @Override\n    protected void processCouponPrice(long userId, Item item) {\n        item.setCouponPrice(BigDecimal.ZERO);\n    }\n\n    @Override\n    protected void processDeliveryPrice(long userId, Item item) {\n        item.setDeliveryPrice(item.getPrice()\n                .multiply(BigDecimal.valueOf(item.getQuantity()))\n                .multiply(new BigDecimal(&quot;0.1&quot;)));\n    }\n}\n</code></pre><p>VIP用户的购物车VipUserCart，直接继承了NormalUserCart，只需要修改多买优惠策略：</p><pre><code>@Service(value = &quot;VipUserCart&quot;)\npublic class VipUserCart extends NormalUserCart {\n\n    @Override\n    protected void processCouponPrice(long userId, Item item) {\n        if (item.getQuantity() &gt; 2) {\n            item.setCouponPrice(item.getPrice()\n                    .multiply(BigDecimal.valueOf(100 - Db.getUserCouponPercent(userId)).divide(new BigDecimal(&quot;100&quot;)))\n                    .multiply(BigDecimal.valueOf(item.getQuantity() - 2)));\n        } else {\n            item.setCouponPrice(BigDecimal.ZERO);\n        }\n    }\n}\n</code></pre><p>内部用户购物车InternalUserCart是最简单的，直接设置0运费和0折扣即可：</p><pre><code>@Service(value = &quot;InternalUserCart&quot;)\npublic class InternalUserCart extends AbstractCart {\n    @Override\n    protected void processCouponPrice(long userId, Item item) {\n        item.setCouponPrice(BigDecimal.ZERO);\n    }\n\n    @Override\n    protected void processDeliveryPrice(long userId, Item item) {\n        item.setDeliveryPrice(BigDecimal.ZERO);\n    }\n}\n</code></pre><p>抽象类和三个子类的实现关系图，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/55/03/55ec188c32805608e0f2341655c87f03.png?wh=1292*1446\" alt=\"\"></p><p>是不是比三个独立的购物车程序简单了很多呢？接下来，我们再看看如何能避免三个if逻辑。</p><p>或许你已经注意到了，定义三个购物车子类时，我们在@Service注解中对Bean进行了命名。既然三个购物车都叫XXXUserCart，那我们就可以把用户类型字符串拼接UserCart构成购物车Bean的名称，然后利用Spring的IoC容器，通过Bean的名称直接获取到AbstractCart，调用其process方法即可实现通用。</p><p>其实，这就是<strong>工厂模式</strong>，只不过是借助Spring容器实现罢了：</p><pre><code>@GetMapping(&quot;right&quot;)\npublic Cart right(@RequestParam(&quot;userId&quot;) int userId) {\n    String userCategory = Db.getUserCategory(userId);\n    AbstractCart cart = (AbstractCart) applicationContext.getBean(userCategory + &quot;UserCart&quot;);\n    return cart.process(userId, items);\n}\n</code></pre><p>试想， 之后如果有了新的用户类型、新的用户逻辑，是不是完全不用对代码做任何修改，只要新增一个XXXUserCart类继承AbstractCart，实现特殊的优惠和运费处理逻辑就可以了？</p><p><strong>这样一来，我们就利用工厂模式+模板方法模式，不仅消除了重复代码，还避免了修改既有代码的风险</strong>。这就是设计模式中的开闭原则：对修改关闭，对扩展开放。</p><h2>利用注解+反射消除重复代码</h2><p>是不是有点兴奋了，业务代码居然也能OOP了。我们再看一个三方接口的调用案例，同样也是一个普通的业务逻辑。</p><p>假设银行提供了一些API接口，对参数的序列化有点特殊，不使用JSON，而是需要我们把参数依次拼在一起构成一个大字符串。</p><ul>\n<li>按照银行提供的API文档的顺序，把所有参数构成定长的数据，然后拼接在一起作为整个字符串。</li>\n<li>因为每一种参数都有固定长度，未达到长度时需要做填充处理：\n<ul>\n<li>字符串类型的参数不满长度部分需要以下划线右填充，也就是字符串内容靠左；</li>\n<li>数字类型的参数不满长度部分以0左填充，也就是实际数字靠右；</li>\n<li>货币类型的表示需要把金额向下舍入2位到分，以分为单位，作为数字类型同样进行左填充。</li>\n</ul>\n</li>\n<li>对所有参数做MD5操作作为签名（为了方便理解，Demo中不涉及加盐处理）。</li>\n</ul><p>比如，创建用户方法和支付方法的定义是这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/54/a6/5429e0313c1254c56abf6bc6ff4fc8a6.jpg?wh=2479*1432\" alt=\"\"></p><p><img src=\"https://static001.geekbang.org/resource/image/88/07/88ceb410987e16f00b5ab5324c0f4c07.jpg?wh=2479*997\" alt=\"\"></p><p>代码很容易实现，直接根据接口定义实现填充操作、加签名、请求调用操作即可：</p><pre><code>public class BankService {\n\n    //创建用户方法\n    public static String createUser(String name, String identity, String mobile, int age) throws IOException {\n        StringBuilder stringBuilder = new StringBuilder();\n        //字符串靠左，多余的地方填充_\n        stringBuilder.append(String.format(&quot;%-10s&quot;, name).replace(' ', '_'));\n        //字符串靠左，多余的地方填充_\n        stringBuilder.append(String.format(&quot;%-18s&quot;, identity).replace(' ', '_'));\n        //数字靠右，多余的地方用0填充\n        stringBuilder.append(String.format(&quot;%05d&quot;, age));\n        //字符串靠左，多余的地方用_填充\n        stringBuilder.append(String.format(&quot;%-11s&quot;, mobile).replace(' ', '_'));\n        //最后加上MD5作为签名\n        stringBuilder.append(DigestUtils.md2Hex(stringBuilder.toString()));\n        return Request.Post(&quot;http://localhost:45678/reflection/bank/createUser&quot;)\n                .bodyString(stringBuilder.toString(), ContentType.APPLICATION_JSON)\n                .execute().returnContent().asString();\n    }\n    \n    //支付方法\n    public static String pay(long userId, BigDecimal amount) throws IOException {\n        StringBuilder stringBuilder = new StringBuilder();\n        //数字靠右，多余的地方用0填充\n        stringBuilder.append(String.format(&quot;%020d&quot;, userId));\n        //金额向下舍入2位到分，以分为单位，作为数字靠右，多余的地方用0填充\n        stringBuilder.append(String.format(&quot;%010d&quot;, amount.setScale(2, RoundingMode.DOWN).multiply(new BigDecimal(&quot;100&quot;)).longValue()));\n        //最后加上MD5作为签名\n        stringBuilder.append(DigestUtils.md2Hex(stringBuilder.toString()));\n        return Request.Post(&quot;http://localhost:45678/reflection/bank/pay&quot;)\n                .bodyString(stringBuilder.toString(), ContentType.APPLICATION_JSON)\n                .execute().returnContent().asString();\n    }\n}\n</code></pre><p>可以看到，这段代码的重复粒度更细：</p><ul>\n<li>三种标准数据类型的处理逻辑有重复，稍有不慎就会出现Bug；</li>\n<li>处理流程中字符串拼接、加签和发请求的逻辑，在所有方法重复；</li>\n<li>实际方法的入参的参数类型和顺序，不一定和接口要求一致，容易出错；</li>\n<li>代码层面针对每一个参数硬编码，无法清晰地进行核对，如果参数达到几十个、上百个，出错的概率极大。</li>\n</ul><p>那应该如何改造这段代码呢？没错，就是要用注解和反射！</p><p>使用注解和反射这两个武器，就可以针对银行请求的所有逻辑均使用一套代码实现，不会出现任何重复。</p><p>要实现接口逻辑和逻辑实现的剥离，首先需要以POJO类（只有属性没有任何业务逻辑的数据类）的方式定义所有的接口参数。比如，下面这个创建用户API的参数：</p><pre><code>@Data\npublic class CreateUserAPI {\n    private String name;\n    private String identity;\n    private String mobile;\n    private int age;\n}\n</code></pre><p>有了接口参数定义，我们就能通过自定义注解为接口和所有参数增加一些元数据。如下所示，我们定义一个接口API的注解BankAPI，包含接口URL地址和接口说明：</p><pre><code>@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\n@Documented\n@Inherited\npublic @interface BankAPI {\n    String desc() default &quot;&quot;;\n    String url() default &quot;&quot;;\n}\n</code></pre><p>然后，我们再定义一个自定义注解@BankAPIField，用于描述接口的每一个字段规范，包含参数的次序、类型和长度三个属性：</p><pre><code>@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\n@Documented\n@Inherited\npublic @interface BankAPIField {\n    int order() default -1;\n    int length() default -1;\n    String type() default &quot;&quot;;\n}\n</code></pre><p>接下来，注解就可以发挥威力了。</p><p>如下所示，我们定义了CreateUserAPI类描述创建用户接口的信息，通过为接口增加@BankAPI注解，来补充接口的URL和描述等元数据；通过为每一个字段增加@BankAPIField注解，来补充参数的顺序、类型和长度等元数据：</p><pre><code>@BankAPI(url = &quot;/bank/createUser&quot;, desc = &quot;创建用户接口&quot;)\n@Data\npublic class CreateUserAPI extends AbstractAPI {\n    @BankAPIField(order = 1, type = &quot;S&quot;, length = 10)\n    private String name;\n    @BankAPIField(order = 2, type = &quot;S&quot;, length = 18)\n    private String identity;\n    @BankAPIField(order = 4, type = &quot;S&quot;, length = 11) //注意这里的order需要按照API表格中的顺序\n    private String mobile;\n    @BankAPIField(order = 3, type = &quot;N&quot;, length = 5)\n    private int age;\n}\n</code></pre><p>另一个PayAPI类也是类似的实现：</p><pre><code>@BankAPI(url = &quot;/bank/pay&quot;, desc = &quot;支付接口&quot;)\n@Data\npublic class PayAPI extends AbstractAPI {\n    @BankAPIField(order = 1, type = &quot;N&quot;, length = 20)\n    private long userId;\n    @BankAPIField(order = 2, type = &quot;M&quot;, length = 10)\n    private BigDecimal amount;\n}\n</code></pre><p>这2个类继承的AbstractAPI类是一个空实现，因为这个案例中的接口并没有公共数据可以抽象放到基类。</p><p>通过这2个类，我们可以在几秒钟内完成和API清单表格的核对。理论上，如果我们的核心翻译过程（也就是把注解和接口API序列化为请求需要的字符串的过程）没问题，只要注解和表格一致，API请求的翻译就不会有任何问题。</p><p>以上，我们通过注解实现了对API参数的描述。接下来，我们再看看反射如何配合注解实现动态的接口参数组装：</p><ul>\n<li>第3行代码中，我们从类上获得了BankAPI注解，然后拿到其URL属性，后续进行远程调用。</li>\n<li>第6~9行代码，使用stream快速实现了获取类中所有带BankAPIField注解的字段，并把字段按order属性排序，然后设置私有字段反射可访问。</li>\n<li>第12~38行代码，实现了反射获取注解的值，然后根据BankAPIField拿到的参数类型，按照三种标准进行格式化，将所有参数的格式化逻辑集中在了这一处。</li>\n<li>第41~48行代码，实现了参数加签和请求调用。</li>\n</ul><pre><code>private static String remoteCall(AbstractAPI api) throws IOException {\n    //从BankAPI注解获取请求地址\n    BankAPI bankAPI = api.getClass().getAnnotation(BankAPI.class);\n    bankAPI.url();\n    StringBuilder stringBuilder = new StringBuilder();\n    Arrays.stream(api.getClass().getDeclaredFields()) //获得所有字段\n            .filter(field -&gt; field.isAnnotationPresent(BankAPIField.class)) //查找标记了注解的字段\n            .sorted(Comparator.comparingInt(a -&gt; a.getAnnotation(BankAPIField.class).order())) //根据注解中的order对字段排序\n            .peek(field -&gt; field.setAccessible(true)) //设置可以访问私有字段\n            .forEach(field -&gt; {\n                //获得注解\n                BankAPIField bankAPIField = field.getAnnotation(BankAPIField.class);\n                Object value = &quot;&quot;;\n                try {\n                    //反射获取字段值\n                    value = field.get(api);\n                } catch (IllegalAccessException e) {\n                    e.printStackTrace();\n                }\n                //根据字段类型以正确的填充方式格式化字符串\n                switch (bankAPIField.type()) {\n                    case &quot;S&quot;: {\n                        stringBuilder.append(String.format(&quot;%-&quot; + bankAPIField.length() + &quot;s&quot;, value.toString()).replace(' ', '_'));\n                        break;\n                    }\n                    case &quot;N&quot;: {\n                        stringBuilder.append(String.format(&quot;%&quot; + bankAPIField.length() + &quot;s&quot;, value.toString()).replace(' ', '0'));\n                        break;\n                    }\n                    case &quot;M&quot;: {\n                        if (!(value instanceof BigDecimal))\n                            throw new RuntimeException(String.format(&quot;{} 的 {} 必须是BigDecimal&quot;, api, field));\n                        stringBuilder.append(String.format(&quot;%0&quot; + bankAPIField.length() + &quot;d&quot;, ((BigDecimal) value).setScale(2, RoundingMode.DOWN).multiply(new BigDecimal(&quot;100&quot;)).longValue()));\n                        break;\n                    }\n                    default:\n                        break;\n                }\n            });\n    //签名逻辑\n   stringBuilder.append(DigestUtils.md2Hex(stringBuilder.toString()));\n    String param = stringBuilder.toString();\n    long begin = System.currentTimeMillis();\n    //发请求\n    String result = Request.Post(&quot;http://localhost:45678/reflection&quot; + bankAPI.url())\n            .bodyString(param, ContentType.APPLICATION_JSON)\n            .execute().returnContent().asString();\n    log.info(&quot;调用银行API {} url:{} 参数:{} 耗时:{}ms&quot;, bankAPI.desc(), bankAPI.url(), param, System.currentTimeMillis() - begin);\n    return result;\n}\n</code></pre><p>可以看到，<strong>所有处理参数排序、填充、加签、请求调用的核心逻辑，都汇聚在了remoteCall方法中</strong>。有了这个核心方法，BankService中每一个接口的实现就非常简单了，只是参数的组装，然后调用remoteCall即可。</p><pre><code>//创建用户方法\npublic static String createUser(String name, String identity, String mobile, int age) throws IOException {\n    CreateUserAPI createUserAPI = new CreateUserAPI();\n    createUserAPI.setName(name);\n    createUserAPI.setIdentity(identity);\n    createUserAPI.setAge(age);\n    createUserAPI.setMobile(mobile);\n    return remoteCall(createUserAPI);\n}\n//支付方法\npublic static String pay(long userId, BigDecimal amount) throws IOException {\n    PayAPI payAPI = new PayAPI();\n    payAPI.setUserId(userId);\n    payAPI.setAmount(amount);\n    return remoteCall(payAPI);\n}\n</code></pre><p>其实，<strong>许多涉及类结构性的通用处理，都可以按照这个模式来减少重复代码</strong>。反射给予了我们在不知晓类结构的时候，按照固定的逻辑处理类的成员；而注解给了我们为这些成员补充元数据的能力，使得我们利用反射实现通用逻辑的时候，可以从外部获得更多我们关心的数据。</p><h2>利用属性拷贝工具消除重复代码</h2><p>最后，我们再来看一种业务代码中经常出现的代码逻辑，实体之间的转换复制。</p><p>对于三层架构的系统，考虑到层之间的解耦隔离以及每一层对数据的不同需求，通常每一层都会有自己的POJO作为数据实体。比如，数据访问层的实体一般叫作DataObject或DO，业务逻辑层的实体一般叫作Domain，表现层的实体一般叫作Data Transfer Object或DTO。</p><p>这里我们需要注意的是，如果手动写这些实体之间的赋值代码，同样容易出错。</p><p>对于复杂的业务系统，实体有几十甚至几百个属性也很正常。就比如ComplicatedOrderDTO这个数据传输对象，描述的是一个订单中的几十个属性。如果我们要把这个DTO转换为一个类似的DO，复制其中大部分的字段，然后把数据入库，势必需要进行很多属性映射赋值操作。就像这样，密密麻麻的代码是不是已经让你头晕了？</p><pre><code>ComplicatedOrderDTO orderDTO = new ComplicatedOrderDTO();\nComplicatedOrderDO orderDO = new ComplicatedOrderDO();\norderDO.setAcceptDate(orderDTO.getAcceptDate());\norderDO.setAddress(orderDTO.getAddress());\norderDO.setAddressId(orderDTO.getAddressId());\norderDO.setCancelable(orderDTO.isCancelable());\norderDO.setCommentable(orderDTO.isComplainable()); //属性错误\norderDO.setComplainable(orderDTO.isCommentable()); //属性错误\norderDO.setCancelable(orderDTO.isCancelable());\norderDO.setCouponAmount(orderDTO.getCouponAmount());\norderDO.setCouponId(orderDTO.getCouponId());\norderDO.setCreateDate(orderDTO.getCreateDate());\norderDO.setDirectCancelable(orderDTO.isDirectCancelable());\norderDO.setDeliverDate(orderDTO.getDeliverDate());\norderDO.setDeliverGroup(orderDTO.getDeliverGroup());\norderDO.setDeliverGroupOrderStatus(orderDTO.getDeliverGroupOrderStatus());\norderDO.setDeliverMethod(orderDTO.getDeliverMethod());\norderDO.setDeliverPrice(orderDTO.getDeliverPrice());\norderDO.setDeliveryManId(orderDTO.getDeliveryManId());\norderDO.setDeliveryManMobile(orderDO.getDeliveryManMobile()); //对象错误\norderDO.setDeliveryManName(orderDTO.getDeliveryManName());\norderDO.setDistance(orderDTO.getDistance());\norderDO.setExpectDate(orderDTO.getExpectDate());\norderDO.setFirstDeal(orderDTO.isFirstDeal());\norderDO.setHasPaid(orderDTO.isHasPaid());\norderDO.setHeadPic(orderDTO.getHeadPic());\norderDO.setLongitude(orderDTO.getLongitude());\norderDO.setLatitude(orderDTO.getLongitude()); //属性赋值错误\norderDO.setMerchantAddress(orderDTO.getMerchantAddress());\norderDO.setMerchantHeadPic(orderDTO.getMerchantHeadPic());\norderDO.setMerchantId(orderDTO.getMerchantId());\norderDO.setMerchantAddress(orderDTO.getMerchantAddress());\norderDO.setMerchantName(orderDTO.getMerchantName());\norderDO.setMerchantPhone(orderDTO.getMerchantPhone());\norderDO.setOrderNo(orderDTO.getOrderNo());\norderDO.setOutDate(orderDTO.getOutDate());\norderDO.setPayable(orderDTO.isPayable());\norderDO.setPaymentAmount(orderDTO.getPaymentAmount());\norderDO.setPaymentDate(orderDTO.getPaymentDate());\norderDO.setPaymentMethod(orderDTO.getPaymentMethod());\norderDO.setPaymentTimeLimit(orderDTO.getPaymentTimeLimit());\norderDO.setPhone(orderDTO.getPhone());\norderDO.setRefundable(orderDTO.isRefundable());\norderDO.setRemark(orderDTO.getRemark());\norderDO.setStatus(orderDTO.getStatus());\norderDO.setTotalQuantity(orderDTO.getTotalQuantity());\norderDO.setUpdateTime(orderDTO.getUpdateTime());\norderDO.setName(orderDTO.getName());\norderDO.setUid(orderDTO.getUid());\n</code></pre><p><strong>如果不是代码中有注释，你能看出其中的诸多问题吗</strong>？</p><ul>\n<li>如果原始的DTO有100个字段，我们需要复制90个字段到DO中，保留10个不赋值，最后应该如何校验正确性呢？数数吗？即使数出有90行代码，也不一定正确，因为属性可能重复赋值。</li>\n<li>有的时候字段命名相近，比如complainable和commentable，容易搞反（第7和第8行），或者对两个目标字段重复赋值相同的来源字段（比如第28行）</li>\n<li>明明要把DTO的值赋值到DO中，却在set的时候从DO自己取值（比如第20行），导致赋值无效。</li>\n</ul><p>这段代码并不是我随手写出来的，而是一个真实案例。有位同学就像代码中那样把经纬度赋值反了，因为落库的字段实在太多了。这个Bug很久都没发现，直到真正用到数据库中的经纬度做计算时，才发现一直以来都存错了。</p><p>修改方法很简单，可以使用类似BeanUtils这种Mapping工具来做Bean的转换，copyProperties方法还允许我们提供需要忽略的属性：</p><pre><code>ComplicatedOrderDTO orderDTO = new ComplicatedOrderDTO();\nComplicatedOrderDO orderDO = new ComplicatedOrderDO();\nBeanUtils.copyProperties(orderDTO, orderDO, &quot;id&quot;);\nreturn orderDO;\n</code></pre><h2>重点回顾</h2><p>正所谓“常在河边走哪有不湿鞋”，重复代码多了总有一天会出错。今天，我从几个最常见的维度，和你分享了几个实际业务场景中可能出现的重复问题，以及消除重复的方式。</p><p>第一种代码重复是，有多个并行的类实现相似的代码逻辑。我们可以考虑提取相同逻辑在父类中实现，差异逻辑通过抽象方法留给子类实现。使用类似的模板方法把相同的流程和逻辑固定成模板，保留差异的同时尽可能避免代码重复。同时，可以使用Spring的IoC特性注入相应的子类，来避免实例化子类时的大量if…else代码。</p><p>第二种代码重复是，使用硬编码的方式重复实现相同的数据处理算法。我们可以考虑把规则转换为自定义注解，作为元数据对类或对字段、方法进行描述，然后通过反射动态读取这些元数据、字段或调用方法，实现规则参数和规则定义的分离。也就是说，把变化的部分也就是规则的参数放入注解，规则的定义统一处理。</p><p>第三种代码重复是，业务代码中常见的DO、DTO、VO转换时大量字段的手动赋值，遇到有上百个属性的复杂类型，非常非常容易出错。我的建议是，不要手动进行赋值，考虑使用Bean映射工具进行。此外，还可以考虑采用单元测试对所有字段进行赋值正确性校验。</p><p>最后，我想说的是，我会把代码重复度作为评估一个项目质量的重要指标，如果一个项目几乎没有任何重复代码，那么它内部的抽象一定是非常好的。在做项目重构的时候，你也可以以消除重复为第一目标去考虑实现。</p><p>今天用到的代码，我都放在了GitHub上，你可以点击<a href=\"https://github.com/JosephZhu1983/java-common-mistakes\">这个链接</a>查看。</p><h2>思考与讨论</h2><ol>\n<li>除了模板方法设计模式是减少重复代码的一把好手，观察者模式也常用于减少代码重复（并且是松耦合方式）。Spring也提供了类似工具（点击<a href=\"https://docs.spring.io/spring/docs/5.2.3.RELEASE/spring-framework-reference/core.html#context-functionality-events-annotation\">这里</a>查看），你能想到有哪些应用场景吗？</li>\n<li>关于Bean属性复制工具，除了最简单的Spring的BeanUtils工具类的使用，你还知道哪些对象映射类库吗？它们又有什么功能呢？</li>\n</ol><p>你还有哪些消除重复代码的心得和方法吗？我是朱晔，欢迎在评论区与我留言分享你的想法，也欢迎你把今天的内容分享给你的朋友或同事，一起交流。</p>","neighbors":{"left":{"article_title":"答疑篇：代码篇思考题集锦（三）","id":262560},"right":{"article_title":"22 | 接口设计：系统间对话的语言，一定要统一","id":228968}},"comments":[{"had_liked":false,"id":217035,"user_name":"Asura","can_delete":false,"product_type":"c1","uid":2004166,"ip_address":"","ucode":"E865D7FAFCF9B1","user_header":"https://static001.geekbang.org/account/avatar/00/1e/94/c6/a7c9f304.jpg","comment_is_top":true,"comment_ctime":1589394047,"is_pvip":false,"replies":[{"id":"80271","content":"包名没有规范，涉及到设计模式类名可以以   <br><br>Locker<br>Iterator<br>Extractor<br>Accessor<br>Validator<br>Formatter<br>Converter<br>Replacer<br>Comparer<br>Manager<br>Combiner<br>Parser<br>Encoder<br>Decoder<br>Importer<br>Exporter<br>Editor<br>Modifier<br>Evaluator<br>Locator<br>Creator<br>Initializer<br>Reader<br>Writer<br>Activator<br>Finder<br>Builder<br>Selector<br>Visitor<br>Loader<br>Descriptor<br>Generator<br>Adapter<br>Listener<br>Wrapper<br>Mapper<br>Binder<br>Invoker<br>Executor<br>Detector<br>Tracer<br>Decorator<br>Mapper<br>Resolver<br>Processor<br>Advisor<br>Dispatcher<br>Consumer<br>Producer<br>Publisher<br>Subscriber<br>Handler<br>Filter<br>Interceptor<br>Provider<br>Container<br>单词作为前后缀 以提现类作用或者模式","user_name":"作者回复","comment_id":217035,"uid":"1001470","ip_address":"","utype":1,"ctime":1589420477,"user_name_real":"朱晔"}],"discussion_count":4,"race_medal":0,"score":"9.2233724335811994e+18","product_id":100047701,"comment_content":"写得真好 想问下项目里用到不同设计模式  类的命名规范 以及放置这些设计模式的包的命名规范是怎么样的 ","like_count":93,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495016,"discussion_content":"包名没有规范，涉及到设计模式类名可以以   \n\nLocker\nIterator\nExtractor\nAccessor\nValidator\nFormatter\nConverter\nReplacer\nComparer\nManager\nCombiner\nParser\nEncoder\nDecoder\nImporter\nExporter\nEditor\nModifier\nEvaluator\nLocator\nCreator\nInitializer\nReader\nWriter\nActivator\nFinder\nBuilder\nSelector\nVisitor\nLoader\nDescriptor\nGenerator\nAdapter\nListener\nWrapper\nMapper\nBinder\nInvoker\nExecutor\nDetector\nTracer\nDecorator\nMapper\nResolver\nProcessor\nAdvisor\nDispatcher\nConsumer\nProducer\nPublisher\nSubscriber\nHandler\nFilter\nInterceptor\nProvider\nContainer\n单词作为前后缀 以提现类作用或者模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589420477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2689860,"avatar":"https://static001.geekbang.org/account/avatar/00/29/0b/44/c6487b93.jpg","nickname":"Vince","note":"","ucode":"53CB603F3034EC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394152,"discussion_content":"太详细了，真用心\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631758197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042793,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e9/69/779b48c2.jpg","nickname":"苏忆","note":"","ucode":"B8BE78280CCB99","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":354396,"discussion_content":"牛逼了。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615286432,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1021539,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/96/63/7eb32c9b.jpg","nickname":"捞鱼的搬砖奇","note":"","ucode":"2FD194C4DA26E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290269,"discussion_content":"上面这些是后缀吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594393111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213409,"user_name":"待时而发","can_delete":false,"product_type":"c1","uid":1158705,"ip_address":"","ucode":"92104F88D537F9","user_header":"https://static001.geekbang.org/account/avatar/00/11/ae/31/2c8a3a66.jpg","comment_is_top":true,"comment_ctime":1588406261,"is_pvip":false,"replies":[{"id":"79148","content":"有收获就好","user_name":"作者回复","comment_id":213409,"uid":"1001470","ip_address":"","utype":1,"ctime":1588409319,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"9.2233721329324995e+18","product_id":100047701,"comment_content":"太实用了  老师。我还真的在日常开发中碰到过太多您所提到的这些问题了，而且很多","like_count":22,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493770,"discussion_content":"有收获就好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588409319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214283,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1588693791,"is_pvip":true,"replies":[{"id":"79337","content":"感谢分享","user_name":"作者回复","comment_id":214283,"uid":"1001470","ip_address":"","utype":1,"ctime":1588723965,"user_name_real":"朱晔"}],"discussion_count":3,"race_medal":0,"score":"164797451039","product_id":100047701,"comment_content":"一、观察者模式的在Spring中的使用：spring listener就是基于观察者模式的：主要是三个组件：<br>\t1. 事件，需要继承ApplicationEvent，即观察者模式中的&quot;主题&quot;，可以看做一个普通的bean类，用于保存在listener的业务逻辑中需要的一些字段；<br>\t2. 事件listener，需要实现ApplicationListener&lt;E extends ApplicationEvent&gt;，即观察者模式中的&quot;观察者&quot;，在主题发生变化时收到通知，并作出相应的更新，加泛型表示只listen某种类型的事件；<br>\t3. 事件发布器，需要实现ApplicationEventPublisherAware，获取spring底层组件ApplicationEventPublisher，并调用其方法发布事件，即&quot;通知&quot;观察者。<br>二、Bean 属性复制，原理肯定是反射了，其实自己实现也很简单，或者反射或者内省，内省实现最简单，以前使用内省实现过。现在主要是用hutool，超级好用的工具包，里面基本你想要的工具类都有，欢迎大家使用https:&#47;&#47;hutool.cn&#47;","like_count":39,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494011,"discussion_content":"感谢分享","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588723965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1045090,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f2/62/f873cd8f.jpg","nickname":"tongmin_tsai","note":"","ucode":"D9423E770D5846","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305188,"discussion_content":"我也在用，谢谢老师和课代表，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599811678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015483,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","nickname":"程序员小跃","note":"","ucode":"25BB96E0791A60","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293566,"discussion_content":"hutool很好用，而且更新维护也挺频繁的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595582673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219489,"user_name":"KLOOOP","can_delete":false,"product_type":"c1","uid":1220981,"ip_address":"","ucode":"1BBF897219786F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erkQ49YqAySHOlynF8fC7Z65ic0icmWYKVJFicAiam4RFcyzZK5IqWI9KYaicaEqw3B24ibaKSicqTOdwDzQ/132","comment_is_top":false,"comment_ctime":1590031595,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"121849115883","product_id":100047701,"comment_content":"推荐使用MapStruct代替BeanUtils。","like_count":29,"discussions":[{"author":{"id":1586324,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIcBRhqN1lpk5Kk9OJuM6XL6epbJXGMZOL1no1RyBjwycEzJU4L1TIUAoRUSoNG4pDsnN9wLrRqbg/132","nickname":"xiaomifeng1010","note":"","ucode":"8DB2840889EAF4","race_medal":5,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375305,"discussion_content":"特意去百度看了一下教程，好像比dozer好用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621568128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042793,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e9/69/779b48c2.jpg","nickname":"苏忆","note":"","ucode":"B8BE78280CCB99","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":354397,"discussion_content":"对对 我们也用这个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615286580,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1269156,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5d/a4/2e4b6d33.jpg","nickname":"素还真","note":"","ucode":"9ABA456355F7E3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324251,"discussion_content":"没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605079345,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241884,"user_name":"cky.宇","can_delete":false,"product_type":"c1","uid":1369447,"ip_address":"","ucode":"93A3EAD9D50A5F","user_header":"https://static001.geekbang.org/account/avatar/00/14/e5/67/16322a5d.jpg","comment_is_top":false,"comment_ctime":1597486313,"is_pvip":false,"replies":[{"id":"89290","content":"不错","user_name":"作者回复","comment_id":241884,"uid":"1001470","ip_address":"","utype":1,"ctime":1597504455,"user_name_real":"朱晔"}],"discussion_count":4,"race_medal":0,"score":"70316963049","product_id":100047701,"comment_content":"十分感谢老师的分享，感觉干货十足，收获很多。<br>这里补充一个项目也经常用到的策略模式，以老师的银行数值格式化的代码为例：<br>switch (bankAPIField.type()) {<br>            case &quot;S&quot;: {<br>                stringBuilder.append(String.format(&quot;%-&quot; + bankAPIField.length() + &quot;s&quot;, value.toString()).replace(&#39; &#39;, &#39;_&#39;));<br>                break;<br>            }<br>            &#47;&#47; ...<br>        }<br>可以转为基于枚举的策略模式<br>enum BankAPIFieldType {<br>        S {<br>            @Override<br>            public String format(Object value, BankAPIField bankAPIField) {<br>                return String.format(&quot;%-&quot; + bankAPIField.length() + &quot;s&quot;, value.toString()).replace(&#39; &#39;, &#39;_&#39;);<br>            }<br>        }, <br>        &#47;&#47; ...<br>        ;<br>        public abstract String format(Object value, BankAPIField bankAPIField);<br>    }<br>将BankAPIField的type类型限制为BankAPIFieldType<br>public @interface BankAPIField {<br>        int order() default -1;<br><br>        int length() default -1;<br><br>        BankAPIFieldType type() default BankAPIFieldType.DEFAULT;<br>    }<br>然后调用的时候就可以简化为：<br><br>stringBuilder.append(bankAPIField.type().format(value, bankAPIField));<br><br>这样做一个是可以限制type的值范围，防止传入的string错误。另一个是减少了主干逻辑的代码，会更清晰点。","like_count":17,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503866,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597504455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1123011,"avatar":"https://static001.geekbang.org/account/avatar/00/11/22/c3/5c69ab81.jpg","nickname":"Lucky Dog","note":"","ucode":"C71C5D24200CCF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305113,"discussion_content":"策略模式的最佳实践，策略枚举🤔","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599787559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1542987,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","nickname":"行则将至","note":"","ucode":"DB972F2DF059C4","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400764,"discussion_content":"直接看的话，效果不好，大家可以实际的敲敲代码。老哥的这种方式，非常好。和老师的重构逻辑相结合，堪称完美","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633416764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1206187,"avatar":"https://static001.geekbang.org/account/avatar/00/12/67/ab/fcf0cec4.jpg","nickname":"寒光","note":"","ucode":"061BE413595F21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":355764,"discussion_content":"这个用表驱动的方式代码更简洁，具体点就是用Map加BiFunction","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615473918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214885,"user_name":"Jerry Wu","can_delete":false,"product_type":"c1","uid":1203567,"ip_address":"","ucode":"AD29B6942AAAA6","user_header":"https://static001.geekbang.org/account/avatar/00/12/5d/6f/42494dcf.jpg","comment_is_top":false,"comment_ctime":1588841812,"is_pvip":false,"replies":[{"id":"79558","content":"：）","user_name":"作者回复","comment_id":214885,"uid":"1001470","ip_address":"","utype":1,"ctime":1588845182,"user_name_real":"朱晔"}],"discussion_count":4,"race_medal":0,"score":"70308318548","product_id":100047701,"comment_content":"这篇文章、demo值得看几十几百遍，感觉打通了任督二脉。<br><br>以前学过设计模式、Java的高级特性，但只能算看过，完全不知道怎么用在工作。<br><br>看完这篇文章才发现，代码还能这样写。刚好，公司有一大堆乱七八糟的代码，实践的时候到了。","like_count":17,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494233,"discussion_content":"：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588845182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1048314,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fe/fa/2a046821.jpg","nickname":"人间四月天","note":"","ucode":"11BE219C23EEBC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386961,"discussion_content":"3种方法，在项目中都用过，第2种，我用的是各种校验逻辑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627912016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2378309,"avatar":"https://static001.geekbang.org/account/avatar/00/24/4a/45/e048531a.jpg","nickname":"迪米乌格斯","note":"","ucode":"1D4393746DCBCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362459,"discussion_content":"重构最大的困难不是代码技术,是没有预期收益, 导致排不上工期啊.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616944525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1117318,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0c/86/8e52afb8.jpg","nickname":"花花大脸猫","note":"","ucode":"8ABDB3F7F4FB0F","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":2378309,"avatar":"https://static001.geekbang.org/account/avatar/00/24/4a/45/e048531a.jpg","nickname":"迪米乌格斯","note":"","ucode":"1D4393746DCBCE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571126,"discussion_content":"结果为导向确实没办法这个，但是可以利用闲暇之余慢慢处理，一切以自己实际成长为目标","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652080385,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":362459,"ip_address":""},"score":571126,"extra":""}]}]},{"had_liked":false,"id":216293,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1589221463,"is_pvip":false,"replies":[{"id":"80035","content":"也不能完全替代，抽象类可以有状态，而且接口语义上是can-do，抽象类是is-a，还是选择更符合语义的方式来实现比较好","user_name":"作者回复","comment_id":216293,"uid":"1001470","ip_address":"","utype":1,"ctime":1589240850,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"57423796311","product_id":100047701,"comment_content":"购物车的例子，我个人理解，Java8中，可以使用接口以及default来代替抽象类。我认为使用接口更好，因为接口可以多实现，但是抽象类不可多继承。","like_count":14,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494756,"discussion_content":"也不能完全替代，抽象类可以有状态，而且接口语义上是can-do，抽象类是is-a，还是选择更符合语义的方式来实现比较好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589240850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213373,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1588397806,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"44538070766","product_id":100047701,"comment_content":"这段时间忙，没有时间来仔细读文章和消化，趁着五一来看了一看。尝试回答一下今天的问题，问题1，观察者模式是一种很常见的解耦方式，多数应用在了事件发布订阅这种业务场景下，有名的当属guava的EventBus了。问题2，对于属性的copy，这类的工具可太多了，无论是spring，guava，apache commons都有涉及，当然我个人比较喜欢hutool一点，因为支持各种参数来调整属性的拷贝。","like_count":10},{"had_liked":false,"id":214262,"user_name":"李远","can_delete":false,"product_type":"c1","uid":1061358,"ip_address":"","ucode":"C759E927C75974","user_header":"https://static001.geekbang.org/account/avatar/00/10/31/ee/642a13e3.jpg","comment_is_top":false,"comment_ctime":1588687456,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35948425824","product_id":100047701,"comment_content":"BeanUtils注意深浅拷贝的问题","like_count":8},{"had_liked":false,"id":236914,"user_name":"程序员小跃","can_delete":false,"product_type":"c1","uid":1015483,"ip_address":"","ucode":"25BB96E0791A60","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","comment_is_top":false,"comment_ctime":1595582614,"is_pvip":true,"replies":[{"id":"87541","content":"奥利给","user_name":"作者回复","comment_id":236914,"uid":"1001470","ip_address":"","utype":1,"ctime":1595587157,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"31660353686","product_id":100047701,"comment_content":"开篇这些问题，不就是我遇到的问题吗，老师来的太及时了。今天还和朋友聊到设计模式的辩论，有用还是无用，看了这篇文章，我心里又有底了。优秀程序员进阶，走起","like_count":7,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502251,"discussion_content":"奥利给","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595587157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217471,"user_name":"小司","can_delete":false,"product_type":"c1","uid":1159233,"ip_address":"","ucode":"5321B36258EAA2","user_header":"https://static001.geekbang.org/account/avatar/00/11/b0/41/fa060608.jpg","comment_is_top":false,"comment_ctime":1589510298,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23064346778","product_id":100047701,"comment_content":"代码编写的demo感觉还需严谨些，例如restful api定义的规范，常量.equals()避免NPE问题，尽量不要set而是使用builder模式，对象构造完基本不要再进行改动，这些都是一些较低级问题。大量的if、switch等逻辑判断可以使用策略加工厂加模版等模式替换，强调可读性一定非常重要，仅此稳定性。避免使用晦涩难懂的函数式编程(图省事而增加难懂及难维护的代码)","like_count":6,"discussions":[{"author":{"id":2378309,"avatar":"https://static001.geekbang.org/account/avatar/00/24/4a/45/e048531a.jpg","nickname":"迪米乌格斯","note":"","ucode":"1D4393746DCBCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362461,"discussion_content":"确实, 函数编程对于加日志调试不太友好,不知道老师咋解决的.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616944742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213342,"user_name":"insight","can_delete":false,"product_type":"c1","uid":1313322,"ip_address":"","ucode":"6F4E51502D0224","user_header":"https://static001.geekbang.org/account/avatar/00/14/0a/2a/c7f5d3ac.jpg","comment_is_top":false,"comment_ctime":1588390191,"is_pvip":false,"replies":[{"id":"79120","content":"会有 不过一般不会存在性能瓶颈","user_name":"作者回复","comment_id":213342,"uid":"1001470","ip_address":"","utype":1,"ctime":1588396537,"user_name_real":"朱晔"}],"discussion_count":3,"race_medal":0,"score":"18768259375","product_id":100047701,"comment_content":"想问一下老师，属性拷贝工具相较于直接写get和set，会有性能上的差异嘛？","like_count":4,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493752,"discussion_content":"会有 不过一般不会存在性能瓶颈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588396537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1167104,"avatar":"https://static001.geekbang.org/account/avatar/00/11/cf/00/01659eeb.jpg","nickname":"coder_Zzz","note":"","ucode":"5B5B4BB4A2E561","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309229,"discussion_content":"MapStruct 这个框架是编译期的，直接生成get set方法进行复制 ，推荐","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1601219144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1070136,"avatar":"https://static001.geekbang.org/account/avatar/00/10/54/38/f43c925e.jpg","nickname":"青青子衿","note":"","ucode":"8DA45FC6A94306","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296725,"discussion_content":"可以使用编译器的属性拷贝工具，性能上会有一个提升","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596632940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213534,"user_name":"小白程序之路","can_delete":false,"product_type":"c1","uid":1134218,"ip_address":"","ucode":"ADDD1C2640C32A","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/8a/514101cb.jpg","comment_is_top":false,"comment_ctime":1588467149,"is_pvip":true,"replies":[{"id":"79165","content":"其实这里不是类名，是Bean的名字，可以把字符串统一到常量，而不是像demo一样使用魔法值","user_name":"作者回复","comment_id":213534,"uid":"1001470","ip_address":"","utype":1,"ctime":1588470788,"user_name_real":"朱晔"}],"discussion_count":3,"race_medal":0,"score":"14473369037","product_id":100047701,"comment_content":"弱弱的说一下哈，感觉老师的第一种利用工厂模式，根据类型加上魔法值（UserCart）来获取指定的类型策略存在隐患，如果后期有小伙伴把这些实现类名改了怎么办，或者新加了一种策略，不是以（UserCart）结尾命名也会在运行时产生问题","like_count":3,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493804,"discussion_content":"其实这里不是类名，是Bean的名字，可以把字符串统一到常量，而不是像demo一样使用魔法值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588470788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2291767,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWA1zUQkKWzjnOmeCtZKN1s7X8qrp81ZEyYPsStot84pW0fgE5etMeNmbUdwxTicjmbWOXZxf9EFw/132","nickname":"Geek_128543","note":"","ucode":"09E3391C057CC1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330983,"discussion_content":"这是service里面的名字吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606743475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181192,"avatar":"https://static001.geekbang.org/account/avatar/00/12/06/08/855abb02.jpg","nickname":"Seven.Lin澤耿","note":"","ucode":"4CAB732CD6F149","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263215,"discussion_content":"可以直接用类获取类名，这样重构也能及时发现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589188627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":304748,"user_name":"Sky1225","can_delete":false,"product_type":"c1","uid":1974876,"ip_address":"","ucode":"6F428AF396D99D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJUCiacuh59wMZAeeNRwLiaGaRMZHibF05IibXeiaZfjcFfkmTwJTmPszibXLAQkk2mMdx8chPjTs2yvpZg/132","comment_is_top":false,"comment_ctime":1627578105,"is_pvip":false,"replies":[{"id":"110324","content":"没错 答疑中我也提到","user_name":"作者回复","comment_id":304748,"uid":"1001470","ip_address":"","utype":1,"ctime":1627739376,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"10217512697","product_id":100047701,"comment_content":"BeanUtils不推荐使用，这个工具是在运行时转换的，遇到同名不同类型的字段不会转换，而且没有错误提示，可能会有坑，推荐使用mapstruct，这个是在编译器生成转换代码，对于普通类型会自动转换（如int和String），对于不能自动转换的会有错误提示，且能看到生成的代码","like_count":3,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524145,"discussion_content":"没错 答疑中我也提到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627739376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216411,"user_name":"FelixFly","can_delete":false,"product_type":"c1","uid":1160461,"ip_address":"","ucode":"1D39A7C3D0E31F","user_header":"https://static001.geekbang.org/account/avatar/00/11/b5/0d/0e65dee6.jpg","comment_is_top":false,"comment_ctime":1589253535,"is_pvip":true,"replies":[{"id":"80077","content":"感谢分享","user_name":"作者回复","comment_id":216411,"uid":"1001470","ip_address":"","utype":1,"ctime":1589255335,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"10179188127","product_id":100047701,"comment_content":"1. 松耦合的方式一般都是用于消息发送，比如说短信发送、日志推送等等，消息队列是分布式中的松耦合<br>2. Bean 属性复制：https:&#47;&#47;www.jianshu.com&#47;p&#47;40e0e64797b9 这篇文章基本全了","like_count":3,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494804,"discussion_content":"感谢分享","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589255335,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214374,"user_name":"mgs2002","can_delete":false,"product_type":"c1","uid":1812970,"ip_address":"","ucode":"F5931108BD509B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","comment_is_top":false,"comment_ctime":1588732871,"is_pvip":false,"replies":[{"id":"79366","content":"👍🏻","user_name":"作者回复","comment_id":214374,"uid":"1001470","ip_address":"","utype":1,"ctime":1588734755,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"10178667463","product_id":100047701,"comment_content":"很有用，已经在尝试使用抽象类替换调项目的部分重复代码","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494036,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588734755,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213357,"user_name":"kyl","can_delete":false,"product_type":"c1","uid":1406090,"ip_address":"","ucode":"DBDFD0FEB5A135","user_header":"https://static001.geekbang.org/account/avatar/00/15/74/8a/d5b0cf30.jpg","comment_is_top":false,"comment_ctime":1588393522,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10178328114","product_id":100047701,"comment_content":"很实用的知识","like_count":2},{"had_liked":false,"id":324601,"user_name":"∫1&#47;(x^4*√(1+x^2))dx","can_delete":false,"product_type":"c1","uid":1596049,"ip_address":"","ucode":"E300E20E5AF0FD","user_header":"https://static001.geekbang.org/account/avatar/00/18/5a/91/f26d17d4.jpg","comment_is_top":false,"comment_ctime":1638515501,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5933482797","product_id":100047701,"comment_content":"贡献一个，我平时用的比较多的，对于功能本身的方法可以抽象的出来的，定义一个接口,接口方法 枚举类型、方法，然后使用applicationContext.getBeansOfType(Class&lt;T&gt; clazz)获取后遍历并匹配需要的类型，再调用对应的方法即可。<br><br><br> &#47;**<br>     * 应用上下文<br>     *&#47;<br>    private static ApplicationContext applicationContext = null;<br><br>    &#47;**<br>     * 加密策略<br>     *&#47;<br>    private static final Map&lt;EncryptorEnum, Encryptor&gt; ENCRYPT_STRATEGY = new HashMap&lt;&gt;(16);<br><br>    &#47;**<br>     * 初始化加密策略<br>     *&#47;<br>    @PostConstruct<br>    public void initEncryptStrategy() {<br>        Optional.of(applicationContext.getBeansOfType(Encryptor.class))<br>                .map(Map::values)<br>                .ifPresent(encryptors -&gt; encryptors.forEach(encryptor -&gt; ENCRYPT_STRATEGY.put(encryptor.getEncryptorEnum(), encryptor)));<br>        log.info(&quot;encryptors initializing completed.&quot;);<br>    }<br><br>    &#47;**<br>     * 根据加密枚举查询加密器<br>     *<br>     * @param encryptorEnum 加密类型枚举<br>     * @return 加密器<br>     *&#47;<br>    public static Encryptor getEncryptorByType(EncryptorEnum encryptorEnum) {<br>        return ENCRYPT_STRATEGY.get(encryptorEnum);<br>    }<br><br>    &#47;**<br>     * 获取所有的加密策略<br>     *<br>     * @return 加密策略集合<br>     *&#47;<br>    public static Map&lt;EncryptorEnum, Encryptor&gt; getEncryptStrategy() {<br>        return ENCRYPT_STRATEGY;<br>    }<br><br>    @Override<br>    public void setApplicationContext(@NonNull ApplicationContext applicationContext) throws BeansException {<br>        EncryptorManager.applicationContext = applicationContext;<br>    }","like_count":1},{"had_liked":false,"id":286485,"user_name":"JoJi","can_delete":false,"product_type":"c1","uid":2066986,"ip_address":"","ucode":"B88997A80E76AC","user_header":"https://static001.geekbang.org/account/avatar/00/1f/8a/2a/f94db4dc.jpg","comment_is_top":false,"comment_ctime":1617339294,"is_pvip":false,"replies":[{"id":"104071","content":"1. 不建议把底层方法公开出去（领域外部）<br>2. 单例是否有问题取决于是否有状态，如果没状态没问题","user_name":"作者回复","comment_id":286485,"uid":"1001470","ip_address":"","utype":1,"ctime":1617363078,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"5912306590","product_id":100047701,"comment_content":"朱老师，可以把remoteCal这个方法单独放到一个类里设置为public吗？给大伙儿都用。还有这个类注册到Spring容器（单例）会有问题吗？","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518004,"discussion_content":"1. 不建议把底层方法公开出去（领域外部）\n2. 单例是否有问题取决于是否有状态，如果没状态没问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617363078,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246861,"user_name":"hello","can_delete":false,"product_type":"c1","uid":1649057,"ip_address":"","ucode":"4F42DAA5DB5C38","user_header":"https://static001.geekbang.org/account/avatar/00/19/29/a1/41607383.jpg","comment_is_top":false,"comment_ctime":1599494109,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5894461405","product_id":100047701,"comment_content":"老师讲得真好，是真的很实用，期待老师更多的专栏。","like_count":0},{"had_liked":false,"id":245868,"user_name":"百威","can_delete":false,"product_type":"c1","uid":1074843,"ip_address":"","ucode":"758199FDD0B44F","user_header":"https://static001.geekbang.org/account/avatar/00/10/66/9b/59776420.jpg","comment_is_top":false,"comment_ctime":1599098721,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5894066017","product_id":100047701,"comment_content":"IDE有个插件GenerateAllSetter，不是使用反射，写一个静态方法抽离出来，然后用快捷键自动生成出入参的get set","like_count":1},{"had_liked":false,"id":234763,"user_name":"守候你的幸福","can_delete":false,"product_type":"c1","uid":2037721,"ip_address":"","ucode":"0142A4FADC0A92","user_header":"https://static001.geekbang.org/account/avatar/00/1f/17/d9/eb9a2171.jpg","comment_is_top":false,"comment_ctime":1594789680,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5889756976","product_id":100047701,"comment_content":"讲的很好，示例很典型，谢谢老师分享","like_count":1},{"had_liked":false,"id":215371,"user_name":"海拉鲁","can_delete":false,"product_type":"c1","uid":1048681,"ip_address":"","ucode":"6E3493295CED6F","user_header":"https://static001.geekbang.org/account/avatar/00/10/00/69/3b1375ca.jpg","comment_is_top":false,"comment_ctime":1588983341,"is_pvip":true,"replies":[{"id":"79711","content":"有收货就好","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1588986923,"ip_address":"","comment_id":215371,"utype":1}],"discussion_count":1,"race_medal":1,"score":"5883950637","product_id":100047701,"comment_content":"看了利用注解和反射消除重复的方法，这就是我一直苦苦寻求而不得的答案啊！<br>之前就觉得这两样应该能发挥大作用但一直不得要领，还是自己对基础知识掌握的不够，感谢老师分享！","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494407,"discussion_content":"有收货就好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588986923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215065,"user_name":"hellojd","can_delete":false,"product_type":"c1","uid":1341697,"ip_address":"","ucode":"4E51807AE7E472","user_header":"https://static001.geekbang.org/account/avatar/00/14/79/01/e71510dc.jpg","comment_is_top":false,"comment_ctime":1588899440,"is_pvip":false,"replies":[{"id":"79602","content":"一般而言，不会把购物车数据保存在Bean里，可能会保存在Redis&#47;Session里比较常见","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1588901579,"ip_address":"","comment_id":215065,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5883866736","product_id":100047701,"comment_content":"购物车的例子，用模板模式+工厂模式是没问题的。但用spring实现工厂，容易踩坑。一般购物车都会持有商品列表数据，spring默认是单例，不注意就出bug了。","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494299,"discussion_content":"一般而言，不会把购物车数据保存在Bean里，可能会保存在Redis/Session里比较常见","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588901579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1341697,"avatar":"https://static001.geekbang.org/account/avatar/00/14/79/01/e71510dc.jpg","nickname":"hellojd","note":"","ucode":"4E51807AE7E472","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261628,"discussion_content":"嗯，是啊。可以实现分布式效果，服务节点挂了购物车信息不丢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588987361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213589,"user_name":"Geek_2e9285","can_delete":false,"product_type":"c1","uid":1974075,"ip_address":"","ucode":"639BA692B39EDB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/A5xnMqlnZofXnuXOLlfqSib8es0FgQuibfRbP8iasxNwriczWnnKib7GsQlPoPZ8v91WQKicrKPw3wgdKLLET62NZ5hw/132","comment_is_top":false,"comment_ctime":1588484361,"is_pvip":false,"replies":[{"id":"79175","content":"策略 状态机 职责链 都比较常用","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1588493625,"ip_address":"","comment_id":213589,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5883451657","product_id":100047701,"comment_content":"这个是不是很类似于状态机模式。我发现在业务场景里面，状态机模式，和策略模式很常用。","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493818,"discussion_content":"策略 状态机 职责链 都比较常用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588493625,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213586,"user_name":"旅途","can_delete":false,"product_type":"c1","uid":1212902,"ip_address":"","ucode":"5022477E8E9441","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","comment_is_top":false,"comment_ctime":1588483535,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5883450831","product_id":100047701,"comment_content":"观察者模式最先想到的是swing框架里的button,然后是tomcat里面的Listener","like_count":1},{"had_liked":false,"id":213354,"user_name":"hhhh","can_delete":false,"product_type":"c1","uid":1256101,"ip_address":"","ucode":"9E87017424B382","user_header":"https://static001.geekbang.org/account/avatar/00/13/2a/a5/625c0a2e.jpg","comment_is_top":false,"comment_ctime":1588393058,"is_pvip":false,"replies":[{"id":"79119","content":"不错","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1588396491,"ip_address":"","comment_id":213354,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5883360354","product_id":100047701,"comment_content":"观察者模式适合所有发布-订阅类型的场景，它的实现方式根据具体需求千变万化，可以是同步阻塞，也可以是异步非阻塞的，可以是进程内的，也可以是系统间的解耦。工作中用的多的是Guava的EventBus。<br>其他工具搜了一下，cglib中BeanCopier也提供了mapping功能，基于动态代理实现，但是没有实际使用过","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493756,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588396491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350123,"user_name":"MrTurbo5","can_delete":false,"product_type":"c1","uid":1626015,"ip_address":"","ucode":"CE272C28F81EAA","user_header":"https://static001.geekbang.org/account/avatar/00/18/cf/9f/5ca1d331.jpg","comment_is_top":false,"comment_ctime":1656582491,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656582491","product_id":100047701,"comment_content":"大受启发，写的真好","like_count":0},{"had_liked":false,"id":349860,"user_name":"防腐基","can_delete":false,"product_type":"c1","uid":2696605,"ip_address":"","ucode":"0FF3BF30631995","user_header":"https://static001.geekbang.org/account/avatar/00/29/25/9d/d612cbf8.jpg","comment_is_top":false,"comment_ctime":1656388618,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656388618","product_id":100047701,"comment_content":"那个工厂模式，为啥我看着像是策略模式呢","like_count":0},{"had_liked":false,"id":345623,"user_name":"斐波那契","can_delete":false,"product_type":"c1","uid":1464006,"ip_address":"","ucode":"85E2EBC01392B1","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/c6/0b449bc6.jpg","comment_is_top":false,"comment_ctime":1652438184,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652438184","product_id":100047701,"comment_content":"最近在用orika来封装bean mapping工具","like_count":0},{"had_liked":false,"id":343242,"user_name":"Geek_63366e","can_delete":false,"product_type":"c1","uid":2616636,"ip_address":"","ucode":"19DC63E05F26A7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/QxpjX52g6rTUq7zX4nEuMSGfagEg0Q4fqFA3KGz2Cpoeib5wiaadicx6xDNBNJ1jjLdtOP1wcHUASegCLEKbasXGQ/132","comment_is_top":false,"comment_ctime":1650723881,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650723881","product_id":100047701,"comment_content":"多谢老师！！！！","like_count":0},{"had_liked":false,"id":330839,"user_name":"孔帅威","can_delete":false,"product_type":"c1","uid":2841574,"ip_address":"","ucode":"72C1AB571247A1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqzIXTDtOlD8UfEgTib5mDw50gJAjhROqrsIFQ8OWPsNb0BzMVVWkicC7uypxr3pEE8XFibg52VpPOaw/132","comment_is_top":false,"comment_ctime":1642216242,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642216242","product_id":100047701,"comment_content":"墙裂推荐","like_count":0},{"had_liked":false,"id":302043,"user_name":"walle斌","can_delete":false,"product_type":"c1","uid":1062848,"ip_address":"","ucode":"0DB3243004951F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","comment_is_top":false,"comment_ctime":1626052945,"is_pvip":false,"replies":[{"id":"109308","content":"是的","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1626084808,"ip_address":"","comment_id":302043,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1626052945","product_id":100047701,"comment_content":"模板模式 是抽取共同逻辑 留给后续扩展开发最常见的玩法。。很值得深度使用","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523157,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626084808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":285301,"user_name":"Php test","can_delete":false,"product_type":"c1","uid":1107151,"ip_address":"","ucode":"895C6B484FCB53","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIS0nk3C1ibMgufXryCzYkrL5bpO25fXPqbSqodGibZqOvbY8m5HEZ8LG4gTDmPKsIj3uK9Z3ibiceF1g/132","comment_is_top":false,"comment_ctime":1616728802,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1616728802","product_id":100047701,"comment_content":"第一个例子看完就兴奋了","like_count":0,"discussions":[{"author":{"id":2028944,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f5/90/2caa07d0.jpg","nickname":"Geek8815","note":"","ucode":"D5102AFFA20E7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379603,"discussion_content":"第二个看完也兴奋了...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624008371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":271297,"user_name":"何柄融","can_delete":false,"product_type":"c1","uid":1398884,"ip_address":"","ucode":"A4C165D1EE3726","user_header":"https://static001.geekbang.org/account/avatar/00/15/58/64/b715d45a.jpg","comment_is_top":false,"comment_ctime":1609516714,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609516714","product_id":100047701,"comment_content":"用属性复制的方式有个缺陷就是找不到设置值的地方，也就是修改的地方。","like_count":0},{"had_liked":false,"id":268167,"user_name":"wangbo","can_delete":false,"product_type":"c1","uid":1125722,"ip_address":"","ucode":"3F0C9C320F0A1D","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/5a/d965c147.jpg","comment_is_top":false,"comment_ctime":1608087556,"is_pvip":false,"replies":[{"id":"97617","content":"帮忙多转发，大家都反馈收获不错，但是课程销量不高，希望更多人看到","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1608543474,"ip_address":"","comment_id":268167,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1608087556","product_id":100047701,"comment_content":"每次看收获又不一样","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511865,"discussion_content":"帮忙多转发，大家都反馈收获不错，但是课程销量不高，希望更多人看到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608543474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":267141,"user_name":"Sobann","can_delete":false,"product_type":"c1","uid":2364015,"ip_address":"","ucode":"D689BE033684AF","user_header":"","comment_is_top":false,"comment_ctime":1607607084,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607607084","product_id":100047701,"comment_content":"代码也是可以优雅的，谢谢老师！","like_count":0},{"had_liked":false,"id":262332,"user_name":"Ontheway","can_delete":false,"product_type":"c1","uid":2306914,"ip_address":"","ucode":"1915DBC22E0C21","user_header":"https://static001.geekbang.org/account/avatar/00/23/33/62/3495db85.jpg","comment_is_top":false,"comment_ctime":1605693985,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605693985","product_id":100047701,"comment_content":"BeanUtils还是慎用，有时候用了问题也挺难排查的。","like_count":0},{"had_liked":false,"id":250274,"user_name":"鲁鸣","can_delete":false,"product_type":"c1","uid":2152306,"ip_address":"","ucode":"974BA3C3E64630","user_header":"https://static001.geekbang.org/account/avatar/00/20/d7/72/cbef720d.jpg","comment_is_top":false,"comment_ctime":1601007517,"is_pvip":false,"replies":[{"id":"91671","content":"通过工具直接分析出大块代码重复的点的","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1601033261,"ip_address":"","comment_id":250274,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1601007517","product_id":100047701,"comment_content":"需要识别什么样的才算是代码重复。第二个首推mapstruct","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506167,"discussion_content":"通过工具直接分析出大块代码重复的点的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601033261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246278,"user_name":"苗","can_delete":false,"product_type":"c1","uid":1088710,"ip_address":"","ucode":"5ECCC6C855E541","user_header":"https://static001.geekbang.org/account/avatar/00/10/9c/c6/05a6798f.jpg","comment_is_top":false,"comment_ctime":1599240094,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1599240094","product_id":100047701,"comment_content":"使用类似beanutils的时候我遇到最麻烦的问题：前后端定义的对象格式不一致；因为是由不同的人设计的；在转换的时候就是先调用一下beanutils.copy，然后再把不能自动转换的属性手动赋值。请问老师这种场景下还有更合适的做法吗？","like_count":0,"discussions":[{"author":{"id":1123011,"avatar":"https://static001.geekbang.org/account/avatar/00/11/22/c3/5c69ab81.jpg","nickname":"Lucky Dog","note":"","ucode":"C71C5D24200CCF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305110,"discussion_content":"Mapstruct比较适合你的需求","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599787341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239256,"user_name":"郑太大","can_delete":false,"product_type":"c1","uid":1485493,"ip_address":"","ucode":"A7C11CD98FE976","user_header":"https://static001.geekbang.org/account/avatar/00/16/aa/b5/fbd9e383.jpg","comment_is_top":false,"comment_ctime":1596467929,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1596467929","product_id":100047701,"comment_content":"我看到同事有在for循环里用BeanUtils来复制属性，这样每次调用，都是先反射获取字段，再通过反射调用set方法。底层还是重复了反射获取字段的动作，对性能不太友好。我有尝试，过把bo集合转成json字符串，再转成dto集合，不知道大佬怎么考虑","like_count":0,"discussions":[{"author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319298,"discussion_content":"\n在没有出现性能问题的情况下，没有必要过分优化，代码的可读性往往更加重要。只有在发现服务得性能出现问题了才需要去考虑这些问题，然后再去想办法优化性能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603978432,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1217874,"avatar":"https://static001.geekbang.org/account/avatar/00/12/95/52/ad190682.jpg","nickname":"Mr wind","note":"","ucode":"484F02D1962239","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":314940,"discussion_content":"序列化反序列化也会有性能开销，前文很多评论说有mapstruct可能比较好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603209752,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234287,"user_name":"CJJ","can_delete":false,"product_type":"c1","uid":1194060,"ip_address":"","ucode":"7E02A6A8547559","user_header":"https://static001.geekbang.org/account/avatar/00/12/38/4c/5426e2e0.jpg","comment_is_top":false,"comment_ctime":1594633134,"is_pvip":true,"replies":[{"id":"86520","content":"模板方法针对的是逻辑重用，策略模式针对的是子逻辑切涮，这是有显著区别的","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1594703749,"ip_address":"","comment_id":234287,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1594633134","product_id":100047701,"comment_content":"老师，想问一下，其实第一个案例使用的工厂模式+模版方法和直接使用策略模式有什么区别呀？","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501338,"discussion_content":"模板方法针对的是逻辑重用，策略模式针对的是子逻辑切涮，这是有显著区别的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594703749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233965,"user_name":"杨杨杨杨、","can_delete":false,"product_type":"c1","uid":1461885,"ip_address":"","ucode":"A736A9BB3FD506","user_header":"https://static001.geekbang.org/account/avatar/00/16/4e/7d/b34f5251.jpg","comment_is_top":false,"comment_ctime":1594538756,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1594538756","product_id":100047701,"comment_content":"Bean 属性复制 ，可以通过json先序列化后反序列化来实现，不同属性名还可以通过json框架的注解来进行匹配，而且是深拷贝。就是性能可能稍微差一些","like_count":0},{"had_liked":false,"id":231495,"user_name":"csy","can_delete":false,"product_type":"c1","uid":1993107,"ip_address":"","ucode":"1812E0AB53CAF5","user_header":"https://static001.geekbang.org/account/avatar/00/1e/69/93/f770b3f4.jpg","comment_is_top":false,"comment_ctime":1593687790,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593687790","product_id":100047701,"comment_content":"赞","like_count":0},{"had_liked":false,"id":222323,"user_name":"梅子黄时雨","can_delete":false,"product_type":"c1","uid":1015938,"ip_address":"","ucode":"9F788D09C2E9E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/82/3c21b30c.jpg","comment_is_top":false,"comment_ctime":1590748537,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590748537","product_id":100047701,"comment_content":"那一串stream操作，真精彩。","like_count":0},{"had_liked":false,"id":215247,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1588940494,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588940494","product_id":100047701,"comment_content":"看完这篇之后立马就运用到我的项目中，真香！","like_count":0}]}