{"id":14794,"title":"19 |  Java字节码（基础篇）","content":"<p>在前面的篇章中，有不少同学反馈对Java字节码并不是特别熟悉。那么今天我便来系统性地介绍一遍Java字节码。</p><h2>操作数栈</h2><p>我们知道，Java字节码是Java虚拟机所使用的指令集。因此，它与Java虚拟机基于栈的计算模型是密不可分的。</p><p>在解释执行过程中，每当为Java方法分配栈桢时，Java虚拟机往往需要开辟一块额外的空间作为操作数栈，来存放计算的操作数以及返回结果。</p><p>具体来说便是：执行每一条指令之前，Java虚拟机要求该指令的操作数已被压入操作数栈中。在执行指令时，Java虚拟机会将该指令所需的操作数弹出，并且将指令的结果重新压入栈中。</p><p><img src=\"https://static001.geekbang.org/resource/image/13/21/13720f6eb83d096ec600309648330821.png?wh=1158*290\" alt=\"\"></p><p>以加法指令iadd为例。假设在执行该指令前，栈顶的两个元素分别为int值1和int值2，那么iadd指令将弹出这两个int，并将求得的和int值3压入栈中。</p><p><img src=\"https://static001.geekbang.org/resource/image/13/db/138c20e60c081c8698770ff8d5d93fdb.png?wh=1134*176\" alt=\"\"></p><p>由于iadd指令只消耗栈顶的两个元素，因此，对于离栈顶距离为2的元素，即图中的问号，iadd指令并不关心它是否存在，更加不会对其进行修改。</p><p>Java字节码中有好几条指令是直接作用在操作数栈上的。最为常见的便是dup： 复制栈顶元素，以及pop：舍弃栈顶元素。</p><p>dup指令常用于复制new指令所生成的未经初始化的引用。例如在下面这段代码的foo方法中，当执行new指令时，Java虚拟机将指向一块已分配的、未初始化的内存的引用压入操作数栈中。</p><!-- [[[read_end]]] --><pre><code>  public void foo() {\n    Object o = new Object();\n  }\n  // 对应的字节码如下：\n  public void foo();\n    0  new java.lang.Object [3]\n    3  dup\n    4  invokespecial java.lang.Object() [8]\n    7  astore_1 [o]\n    8  return\n</code></pre><p>接下来，我们需要以这个引用为调用者，调用其构造器，也就是上面字节码中的invokespecial指令。要注意，该指令将消耗操作数栈上的元素，作为它的调用者以及参数（不过Object的构造器不需要参数）。</p><p>因此，我们需要利用dup指令复制一份new指令的结果，并用来调用构造器。当调用返回之后，操作数栈上仍有原本由new指令生成的引用，可用于接下来的操作（即偏移量为7的字节码，下面会介绍到）。</p><p>pop指令则常用于舍弃调用指令的返回结果。例如在下面这段代码的foo方法中，我将调用静态方法bar，但是却不用其返回值。</p><p>由于对应的invokestatic指令仍旧会将返回值压入foo方法的操作数栈中，因此Java虚拟机需要额外执行pop指令，将返回值舍弃。</p><pre><code>  public static boolean bar() {\n    return false;\n  }\n\n  public void foo() {\n    bar();\n  }\n  // foo方法对应的字节码如下：\n  public void foo();\n    0  invokestatic FooTest.bar() : boolean [24]\n    3  pop\n    4  return\n</code></pre><p>需要注意的是，上述两条指令只能处理非long或者非double类型的值，这是因为long类型或者double类型的值，需要占据两个栈单元。当遇到这些值时，我们需要同时复制栈顶两个单元的dup2指令，以及弹出栈顶两个单元的pop2指令。</p><p>除此之外，不算常见但也是直接作用于操作数栈的还有swap指令，它将交换栈顶两个元素的值。</p><p>在Java字节码中，有一部分指令可以直接将常量加载到操作数栈上。以int类型为例，Java虚拟机既可以通过iconst指令加载-1至5之间的int值，也可以通过bipush、sipush加载一个字节、两个字节所能代表的int值。</p><p>Java虚拟机还可以通过ldc加载常量池中的常量值，例如ldc&nbsp;#18将加载常量池中的第18项。</p><p>这些常量包括int类型、long类型、float类型、double类型、String类型以及Class类型的常量。</p><p><img src=\"https://static001.geekbang.org/resource/image/0c/99/0cd25310027d1fbcca1d6f3301186199.jpg?wh=1242x1120\" alt=\"\"></p><p><strong>常数加载指令表</strong></p><p>正常情况下，操作数栈的压入弹出都是一条条指令完成的。唯一的例外情况是在抛异常时，Java虚拟机会清除操作数栈上的所有内容，而后将异常实例压入操作数栈上。</p><h2>局部变量区</h2><p>Java方法栈桢的另外一个重要组成部分则是局部变量区，字节码程序可以将计算的结果缓存在局部变量区之中。</p><p>实际上，Java虚拟机将局部变量区当成一个数组，依次存放this指针（仅非静态方法），所传入的参数，以及字节码中的局部变量。</p><p>和操作数栈一样，long类型以及double类型的值将占据两个单元，其余类型仅占据一个单元。</p><pre><code>public void foo(long l, float f) {\n  {\n    int i = 0;\n  }\n  {\n    String s = &quot;Hello, World&quot;;\n  }\n}\n</code></pre><p>以上面这段代码中的foo方法为例，由于它是一个实例方法，因此局部变量数组的第0个单元存放着this指针。</p><p>第一个参数为long类型，于是数组的1、2两个单元存放着所传入的long类型参数的值。第二个参数则是float类型，于是数组的第3个单元存放着所传入的float类型参数的值。</p><p><img src=\"https://static001.geekbang.org/resource/image/22/d9/228d0f5f2d6437e7aca87c6df2d01bd9.png?wh=1248*142\" alt=\"\"></p><p>在方法体里的两个代码块中，我分别定义了两个局部变量i和s。由于这两个局部变量的生命周期没有重合之处，因此，Java编译器可以将它们编排至同一单元中。也就是说，局部变量数组的第4个单元将为i或者s。</p><p>存储在局部变量区的值，通常需要加载至操作数栈中，方能进行计算，得到计算结果后再存储至局部变量数组中。这些加载、存储指令是区分类型的。例如，int类型的加载指令为iload，存储指令为istore。</p><p><img src=\"https://static001.geekbang.org/resource/image/60/73/60615f212fe3c40e152eb1829d5c0073.jpg?wh=1230x514\" alt=\"\"></p><p><strong>局部变量区访问指令表</strong></p><p>局部变量数组的加载、存储指令都需要指明所加载单元的下标。举例来说，aload 0指的是加载第0个单元所存储的引用，在前面示例中的foo方法里指的便是加载this指针。</p><p>在我印象中，Java字节码中唯一能够直接作用于局部变量区的指令是iinc M N（M为非负整数，N为整数）。该指令指的是将局部变量数组的第M个单元中的int值增加N，常用于for循环中自增量的更新。</p><pre><code>  public void foo() {\n    for (int i = 100; i&gt;=0; i--) {}\n  }\n  // 对应的字节码如下：\n  public void foo();\n     0  bipush 100\n     2  istore_1 [i]\n     3  goto 9\n     6  iinc 1 -1 [i] // i--\n     9  iload_1 [i]\n    10  ifge 6\n    13  return\n</code></pre><h2>综合示例</h2><p>下面我们来看一个综合的例子：</p><pre><code>public static int bar(int i) {\n  return ((i + 1) - 2) * 3 / 4;\n}\n// 对应的字节码如下：\nCode:\n  stack=2, locals=1, args_size=1\n     0: iload_0\n     1: iconst_1\n     2: iadd\n     3: iconst_2\n     4: isub\n     5: iconst_3\n     6: imul\n     7: iconst_4\n     8: idiv\n     9: ireturn\n</code></pre><p>这里我定义了一个bar方法。它将接收一个int类型的参数，进行一系列计算之后再返回。</p><p>对应的字节码中的stack=2, locals=1代表该方法需要的操作数栈空间为2，局部变量数组空间为1。当调用bar(5)时，每条指令执行前后局部变量数组空间以及操作数栈的分布如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/c5/32/c57cb9c2222f0f79459bf4c58e1a4c32.png?wh=662*1406\" alt=\"\"></p><h2>Java字节码简介</h2><p>前面我已经介绍了加载常量指令、操作数栈专用指令以及局部变量区访问指令。下面我们来看看其他的类别。</p><p>Java相关指令，包括各类具备高层语义的字节码，即new（后跟目标类，生成该类的未初始化的对象），instanceof（后跟目标类，判断栈顶元素是否为目标类/接口的实例。是则压入1，否则压入0），checkcast（后跟目标类，判断栈顶元素是否为目标类/接口的实例。如果不是便抛出异常），athrow（将栈顶异常抛出），以及monitorenter（为栈顶对象加锁）和monitorexit（为栈顶对象解锁）。</p><p>此外，该类型的指令还包括字段访问指令，即静态字段访问指令getstatic、putstatic，和实例字段访问指令getfield、putfield。这四条指令均附带用以定位目标字段的信息，但所消耗的操作数栈元素皆不同。</p><p><img src=\"https://static001.geekbang.org/resource/image/da/d9/da3ff3aa4aaa2531d23286fec65b08d9.png?wh=1228*174\" alt=\"\"></p><p>以putfield为例，在上图中，它会把值v存储至对象obj的目标字段之中。</p><p>方法调用指令，包括invokestatic，invokespecial，invokevirtual，invokeinterface以及invokedynamic。这几条字节码我们已经反反复复提及了，就不再具体介绍各自的含义了。</p><p>除invokedynamic外，其他的方法调用指令所消耗的操作数栈元素是根据调用类型以及目标方法描述符来确定的。在进行方法调用之前，程序需要依次压入调用者（invokestatic不需要），以及各个参数。</p><pre><code>  public int neg(int i) {\n    return -i;\n  }\n\n  public int foo(int i) {\n    return neg(neg(i));\n  }\n  // foo方法对应的字节码如下：foo方法对应的字节码如下：\n  public int foo(int i);\n    0  aload_0 [this]\n    1  aload_0 [this]\n    2  iload_1 [i]\n    3  invokevirtual FooTest.neg(int) : int [25]\n    6  invokevirtual FooTest.neg(int) : int [25]\n    9  ireturn\n</code></pre><p>以上面这段代码为例，当调用foo(2)时，每条指令执行前后局部变量数组空间以及操作数栈的分布如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/47/95/476fa1bcb6b36b5b651c2a4101073295.png?wh=908*1292\" alt=\"\"></p><p>数组相关指令，包括新建基本类型数组的newarray，新建引用类型数组的anewarray，生成多维数组的multianewarray，以及求数组长度的arraylength。另外，它还包括数组的加载指令以及存储指令。这些指令是区分类型的。例如，int数组的加载指令为iaload，存储指令为iastore。</p><p><img src=\"https://static001.geekbang.org/resource/image/8e/f1/8ee0ed86242a63b566d55297a88da9f1.jpg?wh=1246x764\" alt=\"\"></p><p><strong>数组访问指令表</strong></p><p>控制流指令，包括无条件跳转goto，条件跳转指令，tableswitch和lookupswtich（前者针对密集的cases，后者针对稀疏的cases），返回指令，以及被废弃的jsr，ret指令。其中返回指令是区分类型的。例如，返回int值的指令为ireturn。</p><p><img src=\"https://static001.geekbang.org/resource/image/f5/f0/f5195b5425a9547af9ce8371aef5c4f0.jpg?wh=624*331\" alt=\"\"></p><p><strong>返回指令表</strong></p><p>除返回指令外，其他的控制流指令均附带一个或者多个字节码偏移量，代表需要跳转到的位置。例如下面的abs方法中偏移量为1的条件跳转指令，当栈顶元素小于0时，跳转至偏移量为6的字节码。</p><pre><code>  public int abs(int i) {\n    if (i &gt;= 0) {\n      return i;\n    }\n    return -i;\n  }\n  // 对应的字节码如下所示：\n  public int abs(int i);\n    0  iload_1 [i]\n    1  iflt 6\n    4  iload_1 [i]\n    5  ireturn\n    6  iload_1 [i]\n    7  ineg\n    8  ireturn\n</code></pre><p>剩余的Java字节码几乎都和计算相关，这里就不再详细阐述了。</p><h2>总结与实践</h2><p>今天我简单介绍了各种类型的Java字节码。</p><p>Java方法的栈桢分为操作数栈和局部变量区。通常来说，程序需要将变量从局部变量区加载至操作数栈中，进行一番运算之后再存储回局部变量区中。</p><p>Java字节码可以划分为很多种类型，如加载常量指令，操作数栈专用指令，局部变量区访问指令，Java相关指令，方法调用指令，数组相关指令，控制流指令，以及计算相关指令。</p><p>今天的实践环节，你可以尝试自己分析一段较为复杂的字节码，在草稿上画出局部变量数组以及操作数栈分布图。当碰到不熟悉的指令时，你可以查阅<a href=\"https://docs.oracle.com/javase/specs/jvms/se10/html/jvms-6.html#jvms-6.5\">Java虚拟机规范第6.5小节</a>  ，或者<a href=\"https://cs.au.dk/~mis/dOvs/jvmspec/ref-Java.html\">此链接</a>。</p>","comments":[{"had_liked":false,"id":22745,"user_name":"曲东方","can_delete":false,"product_type":"c1","uid":1177819,"ip_address":"","ucode":"6C3EA2F47A0B98","user_header":"https://static001.geekbang.org/account/avatar/00/11/f8/db/c4edf697.jpg","comment_is_top":false,"comment_ctime":1535947044,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"147564835108","product_id":100010301,"comment_content":"详尽，赞👍<br><br>随便找几断代码，javap反编译，查jvm手册一会儿就明白了","like_count":35},{"had_liked":false,"id":23308,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1536282788,"is_pvip":false,"replies":[{"id":"8466","content":"基于栈的计算模型确实是为了实现起来容易一些，但它并不高效，因为没有使用底层体系架构的寄存器。<br><br>在JVM中，只有解释器完整地模拟出该计算模型。即时编译器在解析字节码时会使用一个虚拟的栈计算模型，但是在接下来的编译优化，以及生成的机器码就不用了。","user_name":"作者回复","comment_id":23308,"uid":"1176688","ip_address":"","utype":1,"ctime":1536330676,"user_name_real":"郑雨迪"}],"discussion_count":2,"race_medal":0,"score":"96025563300","product_id":100010301,"comment_content":"1:.Java代码由Java的语言语法组成，有开发人员来编写<br><br>2:.class 代码有Java编译器来编译，Java编译器也是有对应的开发人员来编写的，.class代码有字节码指令来组成，如果人理解Java字节码指令集比较简单也可以直接编写.class代码<br><br>3:Java对应的机器码有JVM来编译出来，原料是.class代码，如果人类理解机器码比较容易，那么可能变成就直接在机器硬件上直接编写机器码了<br><br>4:高级语言的出现是为提高人编写代码的效率，我们学习.class字节码指令集、JVM、机器码等的知识，是为了使我们编写高级语言代码能更好的在机器硬件上的执行效率更高，从高级语言的代码到能在机器上运行的机器码，中间经过了好几层的转换，所以，了解每一层是怎么转换就能更快的定位出高级语言代码的性能瓶颈了，感觉是为了在人的编码效率和机器的执行效率之间找平衡点<br><br>有个疑问❓<br>没太理解，JVM基于栈的计算模型的原因，推测可能是为了更简单的实现和更高的性能但是是怎么做到的呢？请老师解释一下","like_count":22,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423505,"discussion_content":"基于栈的计算模型确实是为了实现起来容易一些，但它并不高效，因为没有使用底层体系架构的寄存器。\n\n在JVM中，只有解释器完整地模拟出该计算模型。即时编译器在解析字节码时会使用一个虚拟的栈计算模型，但是在接下来的编译优化，以及生成的机器码就不用了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1536330676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1357311,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b5/ff/d1f205b0.jpg","nickname":"L","note":"","ucode":"5B847B2378854E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293580,"discussion_content":"把科代表顶上去","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595586342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22731,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1535942740,"is_pvip":true,"replies":[{"id":"8214","content":"如果是虚拟机初始化局部变量，那么它需要掌握每个变量的生命周期，以便初始化共享同一下标的局部变量。实现起来比较费事。<br><br>另一方面，从代码规范来看，使用未经初始化的局部变量意义不明。","user_name":"作者回复","comment_id":22731,"uid":"1176688","ip_address":"","utype":1,"ctime":1535969052,"user_name_real":"郑雨迪"}],"discussion_count":2,"race_medal":0,"score":"48780582996","product_id":100010301,"comment_content":"为什么局部变量要初始化？想请老师专业解答下！","like_count":12,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423242,"discussion_content":"如果是虚拟机初始化局部变量，那么它需要掌握每个变量的生命周期，以便初始化共享同一下标的局部变量。实现起来比较费事。\n\n另一方面，从代码规范来看，使用未经初始化的局部变量意义不明。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535969052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1508990,"avatar":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","nickname":"西门吹牛","note":"","ucode":"E5D3624DDE1E83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291388,"discussion_content":"这个好理解，主要从这个变量在使用的时候，有什么场景，是先赋值在使用还是不赋值可以直接使用。就俩种，局部和成员；\n对于成员变量：在类加载过程的准备阶段即可给它赋予默认值，其赋值和取值访问在运行时的先后顺序具有不确定性(有可能先取值后赋值)，所以加载阶段赋予默认值，保证了成员变量只要被定义，就可以被使用。对象不创建，我也可以使用它的成员变量。\n对于局部变量：是在类方法中的变量，在执行方法(字节码执行时候)的时候才会用到，其赋值和取值访问顺序是确定的。运行时被分配在栈中，量大且生命周期短，如果虚拟机给每个局部变量都初始化一下，是一笔很大的开销(类中方法很多)，这样设计也是一种约束，尽最大程度减少使用者犯错的可能。假使局部变量可以使用默认值，可能会无意间忘记赋值，进而导致不可预期的情况出现。同时局部变量不赋值就使用是不安全的。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1594801399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":23400,"user_name":"熊猫酒仙","can_delete":false,"product_type":"c1","uid":1112078,"ip_address":"","ucode":"17002C7A355EC1","user_header":"https://static001.geekbang.org/account/avatar/00/10/f8/0e/de697f9b.jpg","comment_is_top":false,"comment_ctime":1536328924,"is_pvip":false,"replies":[{"id":"8602","content":"Java字节码不会，但是底下的实现(比如解释执行器，即时编译器)是会的。","user_name":"作者回复","comment_id":23400,"uid":"1176688","ip_address":"","utype":1,"ctime":1536578785,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"40191034588","product_id":100010301,"comment_content":"C&#47;C++的汇编指令，会有大量寄存器的操作<br>请问java的指令会用到寄存器吗？","like_count":9,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423549,"discussion_content":"Java字节码不会，但是底下的实现(比如解释执行器，即时编译器)是会的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1536578785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":23183,"user_name":"Shine","can_delete":false,"product_type":"c1","uid":1022568,"ip_address":"","ucode":"C8C617B87C63C7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9a/68/92caeed6.jpg","comment_is_top":false,"comment_ctime":1536196062,"is_pvip":false,"replies":[{"id":"8468","content":"构造器是没有返回结果的，所以不用pop。如果不dup的话，就只有一个r0，在调用构造器时用掉了，程序就再没有对该新建对象的引用了。","user_name":"作者回复","comment_id":23183,"uid":"1176688","ip_address":"","utype":1,"ctime":1536330921,"user_name_real":"郑雨迪"}],"discussion_count":3,"race_medal":0,"score":"31600967134","product_id":100010301,"comment_content":"“因此，我们需要利用 dup 指令复制一份 new 指令的结果，并用来调用构造器。当调用返回之后，操作数栈上仍有原本由 new 指令生成的引用去...”<br><br>第一步栈顶压入new对象的引用r0，执行dup后复制r0得到r1，压入栈顶。r1用于调用构造器,完成后会pop, 留下栈顶元素r0。不知我这样理解对不？<br>我的问题是为什么要dup呢？直接用r0不做pop不好吗？","like_count":7,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423455,"discussion_content":"构造器是没有返回结果的，所以不用pop。如果不dup的话，就只有一个r0，在调用构造器时用掉了，程序就再没有对该新建对象的引用了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1536330921,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1467309,"avatar":"https://static001.geekbang.org/account/avatar/00/16/63/ad/21f62e27.jpg","nickname":"wjyuian","note":"","ucode":"1DDDDBF869CFC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543741,"discussion_content":"load应该是将局部变量表对应的数据压到操作数栈；相反的store应该是将指定位置的数据弹出，保存到局部变量表；\n所以上面的astore_1 就是把栈顶的指针（也就是第一个new的时候压入的），存储到变量表1的位置（0的位置是this指针）；\n因为老是的例子方法是void，所以return；如果方法返回值是Object，你可以看下，areturn之前会有aload_1，就是将局部变量表的1位置的指针压到栈顶，areturn弹出返回；","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1641291486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1467309,"avatar":"https://static001.geekbang.org/account/avatar/00/16/63/ad/21f62e27.jpg","nickname":"wjyuian","note":"","ucode":"1DDDDBF869CFC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543739,"discussion_content":"这是操作数栈，每条指令至少会消耗一个栈顶；\n\n这里的初始化方法会消耗一个调用者，就是栈顶；那么最后的return就没有了；所以dup一个是给初始化用的\n\nnew那一行对应是分配空间，并没有初始化；\n应该是这个意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641291060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166584,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1577509423,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14462411311","product_id":100010301,"comment_content":"老师，请教下，在专栏中（关于虚拟机的书籍中）有提到：Java虚拟机大部分都是基于栈，有些虚拟机是基于寄存器的，比如Android的Dalvik和ART。<br><br>这听起来挺抽象的，老师能具体讲讲它们的区别？<br><br>是字节码执行的时候有区别的吗？  还是说字节码本身就有区别？","like_count":3},{"had_liked":false,"id":164887,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1577105959,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14462007847","product_id":100010301,"comment_content":"图文并茂，总结详尽！感觉这篇放在前面可能更好。","like_count":3},{"had_liked":false,"id":38299,"user_name":"对方正在输入","can_delete":false,"product_type":"c1","uid":1257515,"ip_address":"","ucode":"57C3A444E33832","user_header":"https://static001.geekbang.org/account/avatar/00/13/30/2b/bc5873c6.jpg","comment_is_top":false,"comment_ctime":1542018068,"is_pvip":false,"replies":[{"id":"14128","content":"正常执行路径会有return，有返回值的是ireturn，areturn这些。异常执行路径会有athrow。你可以试试查看只有一句throw new Exception()的方法","user_name":"作者回复","comment_id":38299,"uid":"1176688","ip_address":"","utype":1,"ctime":1542281593,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"14426919956","product_id":100010301,"comment_content":"在JVM中,每个方法中,代码语句执行完毕,是不是都会默认有个return","like_count":4,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428668,"discussion_content":"正常执行路径会有return，有返回值的是ireturn，areturn这些。异常执行路径会有athrow。你可以试试查看只有一句throw new Exception()的方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542281593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136327,"user_name":"师爷","can_delete":false,"product_type":"c1","uid":1104287,"ip_address":"","ucode":"20E6831DABF755","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/9f/7b2f2a97.jpg","comment_is_top":false,"comment_ctime":1569409779,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10159344371","product_id":100010301,"comment_content":"某些方法阻塞会不会导致弹栈阻塞呢","like_count":2},{"had_liked":false,"id":40363,"user_name":"李鑫磊","can_delete":false,"product_type":"c1","uid":1101615,"ip_address":"","ucode":"D06517CFCEEE00","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/2f/4f89f22a.jpg","comment_is_top":false,"comment_ctime":1542603270,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10132537862","product_id":100010301,"comment_content":"笔记：https:&#47;&#47;www.jianshu.com&#47;p&#47;b395ed905e0d","like_count":2},{"had_liked":false,"id":22794,"user_name":"YIFENG","can_delete":false,"product_type":"c1","uid":1069423,"ip_address":"","ucode":"78C3EA8995DB3B","user_header":"https://static001.geekbang.org/account/avatar/00/10/51/6f/f33beea5.jpg","comment_is_top":false,"comment_ctime":1535976892,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10125911484","product_id":100010301,"comment_content":"64位虚拟机中long和double也都是占用两个栈单元吗？","like_count":2,"discussions":[{"author":{"id":1564497,"avatar":"https://static001.geekbang.org/account/avatar/00/17/df/51/5151214d.jpg","nickname":"波～～～","note":"","ucode":"CB04A25B18AFC7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530430,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637072629,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361014,"discussion_content":"解析出来的机器码是ladd，我只能说标准做法是两个机器字","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616579775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328338,"user_name":"啸疯","can_delete":false,"product_type":"c1","uid":1104225,"ip_address":"","ucode":"24792660595DA1","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/61/4999fbc3.jpg","comment_is_top":false,"comment_ctime":1640676742,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5935644038","product_id":100010301,"comment_content":"看的真爽，了解了很多字节码层面的细节，例如常量相加后赋值给变量，那么在字节码层面其实直接就是相加后的值，再比如两个string的相加，字节码层面其实也是调用stringbuiler不断append后tostring来实现的","like_count":2},{"had_liked":false,"id":186843,"user_name":"魏全运","can_delete":false,"product_type":"c1","uid":1090798,"ip_address":"","ucode":"3FED702C724E2A","user_header":"https://static001.geekbang.org/account/avatar/00/10/a4/ee/cffd8ee6.jpg","comment_is_top":false,"comment_ctime":1583937389,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878904685","product_id":100010301,"comment_content":"<br>  public void foo() {<br>    Object o = new Object();<br>  }<br>  &#47;&#47; 对应的字节码如下：<br>  public void foo();<br>    0  new java.lang.Object [3]<br>    3  dup<br>    4  invokespecial java.lang.Object() [8]<br>    7  astore_1 [o]<br>    8  return<br><br>通过对象创建的字节码就能明白对象的创建不是原子操作，所以需要双重检查锁保证单例安全","like_count":2},{"had_liked":false,"id":88436,"user_name":"shenfl","can_delete":false,"product_type":"c1","uid":1184233,"ip_address":"","ucode":"607CD894152241","user_header":"https://static001.geekbang.org/account/avatar/00/12/11/e9/b6aa6364.jpg","comment_is_top":false,"comment_ctime":1555918455,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5850885751","product_id":100010301,"comment_content":"想请教下 编译后匿名内部类会生成一个class文件，但是函数式接口实现的代码却不会生成一个class文件，这是什么原理？","like_count":1,"discussions":[{"author":{"id":2033191,"avatar":"","nickname":"Geek_85fa88","note":"","ucode":"B2987B8A28C51D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286176,"discussion_content":"我记得老师前面讲过，实现函数接口的，是直接用的invokedynamic实现，底层采用的方法句柄，所以不会有你所说的class文件，如果不对还请指正。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593079844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22740,"user_name":"Void_seT","can_delete":false,"product_type":"c1","uid":1070863,"ip_address":"","ucode":"DD55CB0198A5CD","user_header":"https://static001.geekbang.org/account/avatar/00/10/57/0f/1f229bf5.jpg","comment_is_top":false,"comment_ctime":1535945435,"is_pvip":false,"replies":[{"id":"8207","content":"多谢指出！","user_name":"作者回复","comment_id":22740,"uid":"1176688","ip_address":"","utype":1,"ctime":1535967611,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"5830912731","product_id":100010301,"comment_content":"数组访问指令表，int文稿中写的iaload，iastore；表格中列的iastore和istore","like_count":1,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423247,"discussion_content":"多谢指出！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535967611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335783,"user_name":"　素丶　　","can_delete":false,"product_type":"c1","uid":1081535,"ip_address":"","ucode":"883B7EDBE76104","user_header":"https://static001.geekbang.org/account/avatar/00/10/80/bf/3041138b.jpg","comment_is_top":false,"comment_ctime":1645687825,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645687825","product_id":100010301,"comment_content":"可以配合美团的这篇文章一起观看<br>https:&#47;&#47;tech.meituan.com&#47;2019&#47;09&#47;05&#47;java-bytecode-enhancement.html","like_count":1},{"had_liked":false,"id":285307,"user_name":"小辉辉","can_delete":false,"product_type":"c1","uid":1189661,"ip_address":"","ucode":"9FF25E25C85350","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/1d/1cb36854.jpg","comment_is_top":false,"comment_ctime":1616730405,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1616730405","product_id":100010301,"comment_content":"有个疑问，如果在本地变量表中用 lload 或者 fload 时，怎么保证两个单元的数值同时被 load 到栈中。比如说方法有一个局部变量 long a = 5，然后在本地变量表中占用两个单元格，JVM是怎么保证这两个单元格中的数值都被 load 过去。","like_count":0,"discussions":[{"author":{"id":2653715,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKib3vNM6TPT1umvR3TictnLurJPKuQq4iblH5upgBB3kHL9hoN3Pgh3MaR2rjz6fWgMiaDpicd8R5wsAQ/132","nickname":"陈阳","note":"","ucode":"C8E676C967D23A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546057,"discussion_content":"lload 前面的l指的是long， iload前面的i指的是int  long类型 load2个单元， int类型load1个单员","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642142813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":255012,"user_name":"track6688","can_delete":false,"product_type":"c1","uid":1088040,"ip_address":"","ucode":"0A9E893F8FD379","user_header":"https://static001.geekbang.org/account/avatar/00/10/9a/28/03613c22.jpg","comment_is_top":false,"comment_ctime":1603249501,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603249501","product_id":100010301,"comment_content":"写得很详细，比较好理解， 相当于总结了一下。","like_count":0},{"had_liked":false,"id":226497,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1592122445,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1592122445","product_id":100010301,"comment_content":"讲的比较清晰了<br>java方法的栈帧包括了：<br>局部变量表，操作数栈<br>局部变量表是在编绎时刻就确定的，用于存储局部变量<br>操作数栈则用于存储在方法字节码执行的时候涉及到的变量值，以及运算完的结果<br><br>java虚拟机制定了一系列的java执行指令，有：<br>dup（用于将new指令生成的的引用复制到操作数栈）<br>iload：用于加载局部变量表中的变量到操作数栈<br>iadd&#47;imup等用于执行运算<br>","like_count":0},{"had_liked":false,"id":137498,"user_name":"gogo","can_delete":false,"product_type":"c1","uid":1003104,"ip_address":"","ucode":"E8F0F3B000020A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/60/0d5aa340.jpg","comment_is_top":false,"comment_ctime":1569753782,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569753782","product_id":100010301,"comment_content":"老师您好，从第一篇看到现在，对某个方法的执行流程还不是很理解，有哪一篇文章是说整个流程的吗，从主类加载初始化到某个方法执行结束的","like_count":0},{"had_liked":false,"id":113671,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1563112892,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563112892","product_id":100010301,"comment_content":"就是说如果是解释执行就在栈桢内完成了，不用寄存器。如果是即时编译执行，就用寄存器来存放操作数，对么","like_count":0},{"had_liked":false,"id":80641,"user_name":"ゞ﹏雨天____゛","can_delete":false,"product_type":"c1","uid":1451392,"ip_address":"","ucode":"9639F0340C6C91","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/80/fdd5a88f.jpg","comment_is_top":false,"comment_ctime":1553692246,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553692246","product_id":100010301,"comment_content":"讲解内容中，这几张总结表，写的真的给力。赞","like_count":0}]}