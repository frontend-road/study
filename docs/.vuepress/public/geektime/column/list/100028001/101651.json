{"id":101651,"title":"13 | 多线程之锁优化（中）：深入了解Lock同步锁的优化方法","content":"<p>你好，我是刘超。</p><p>今天这讲我们继续来聊聊锁优化。上一讲我重点介绍了在JVM层实现的Synchronized同步锁的优化方法，除此之外，在JDK1.5之后，Java还提供了Lock同步锁。那么它有什么优势呢？</p><p>相对于需要JVM隐式获取和释放锁的Synchronized同步锁，Lock同步锁（以下简称Lock锁）需要的是显示获取和释放锁，这就为获取和释放锁提供了更多的灵活性。<span class=\"orange\">Lock锁的基本操作是通过乐观锁来实现的，但由于Lock锁也会在阻塞时被挂起，因此它依然属于悲观锁。</span>我们可以通过一张图来简单对比下两个同步锁，了解下各自的特点：</p><p><img src=\"https://static001.geekbang.org/resource/image/8e/3d/8ec55dc637830f728e505c673fefde3d.jpg?wh=1238*660\" alt=\"\"></p><p>从性能方面上来说，在并发量不高、竞争不激烈的情况下，Synchronized同步锁由于具有分级锁的优势，性能上与Lock锁差不多；但在高负载、高并发的情况下，Synchronized同步锁由于竞争激烈会升级到重量级锁，性能则没有Lock锁稳定。</p><p>我们可以通过一组简单的性能测试，直观地对比下两种锁的性能，结果见下方，代码可以在<a href=\"https://github.com/nickliuchao/syncLockTest\">Github</a>上下载查看。</p><p><img src=\"https://static001.geekbang.org/resource/image/5c/b4/5c71e1402407e8970f51f9253fb716b4.jpg?wh=2120*922\" alt=\"\"></p><p>通过以上数据，我们可以发现：Lock锁的性能相对来说更加稳定。那它与上一讲的Synchronized同步锁相比，实现原理又是怎样的呢？</p><!-- [[[read_end]]] --><h2>Lock锁的实现原理</h2><p>Lock锁是基于Java实现的锁，Lock是一个接口类，常用的实现类有ReentrantLock、ReentrantReadWriteLock（RRW），它们都是依赖AbstractQueuedSynchronizer（AQS）类实现的。</p><p>AQS类结构中包含一个基于链表实现的等待队列（CLH队列），用于存储所有阻塞的线程，AQS中还有一个state变量，该变量对ReentrantLock来说表示加锁状态。</p><p>该队列的操作均通过CAS操作实现，我们可以通过一张图来看下整个获取锁的流程。</p><p><img src=\"https://static001.geekbang.org/resource/image/22/33/222196b8c410ff4ffca7131faa19d833.jpg?wh=836*1240\" alt=\"\"></p><h2>锁分离优化Lock同步锁</h2><p>虽然Lock锁的性能稳定，但也并不是所有的场景下都默认使用ReentrantLock独占锁来实现线程同步。</p><p>我们知道，对于同一份数据进行读写，如果一个线程在读数据，而另一个线程在写数据，那么读到的数据和最终的数据就会不一致；如果一个线程在写数据，而另一个线程也在写数据，那么线程前后看到的数据也会不一致。这个时候我们可以在读写方法中加入互斥锁，来保证任何时候只能有一个线程进行读或写操作。</p><p>在大部分业务场景中，读业务操作要远远大于写业务操作。而在多线程编程中，读操作并不会修改共享资源的数据，如果多个线程仅仅是读取共享资源，那么这种情况下其实没有必要对资源进行加锁。如果使用互斥锁，反倒会影响业务的并发性能，那么在这种场景下，有没有什么办法可以优化下锁的实现方式呢？</p><h3>1.读写锁ReentrantReadWriteLock</h3><p>针对这种读多写少的场景，Java提供了另外一个实现Lock接口的读写锁RRW。我们已知ReentrantLock是一个独占锁，同一时间只允许一个线程访问，而RRW允许多个读线程同时访问，但不允许写线程和读线程、写线程和写线程同时访问。读写锁内部维护了两个锁，一个是用于读操作的ReadLock，一个是用于写操作的WriteLock。</p><p>那读写锁又是如何实现锁分离来保证共享资源的原子性呢？</p><p>RRW也是基于AQS实现的，它的自定义同步器（继承AQS）需要在同步状态state上维护多个读线程和一个写线程的状态，该状态的设计成为实现读写锁的关键。RRW很好地使用了高低位，来实现一个整型控制两种状态的功能，读写锁将变量切分成了两个部分，高16位表示读，低16位表示写。</p><p><strong>一个线程尝试获取写锁时，</strong>会先判断同步状态state是否为0。如果state等于0，说明暂时没有其它线程获取锁；如果state不等于0，则说明有其它线程获取了锁。</p><p>此时再判断同步状态state的低16位（w）是否为0，如果w为0，则说明其它线程获取了读锁，此时进入CLH队列进行阻塞等待；如果w不为0，则说明其它线程获取了写锁，此时要判断获取了写锁的是不是当前线程，若不是就进入CLH队列进行阻塞等待；若是，就应该判断当前线程获取写锁是否超过了最大次数，若超过，抛异常，反之更新同步状态。</p><p><img src=\"https://static001.geekbang.org/resource/image/1b/d1/1bba37b281d83cdf0c51095f473001d1.jpg?wh=814*1388\" alt=\"\"></p><p><strong>一个线程尝试获取读锁时，</strong>同样会先判断同步状态state是否为0。如果state等于0，说明暂时没有其它线程获取锁，此时判断是否需要阻塞，如果需要阻塞，则进入CLH队列进行阻塞等待；如果不需要阻塞，则CAS更新同步状态为读状态。</p><p>如果state不等于0，会判断同步状态低16位，如果存在写锁，则获取读锁失败，进入CLH阻塞队列；反之，判断当前线程是否应该被阻塞，如果不应该阻塞则尝试CAS同步状态，获取成功更新同步锁为读状态。</p><p><img src=\"https://static001.geekbang.org/resource/image/52/46/52e77acc6999efbdf4113daaa5918d46.jpeg?wh=840*1378\" alt=\"\"></p><p>下面我们通过一个求平方的例子，来感受下RRW的实现，代码如下：</p><pre><code>public class TestRTTLock {\n\n\tprivate double x, y;\n\n\tprivate ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n\t// 读锁\n\tprivate Lock readLock = lock.readLock();\n\t// 写锁\n\tprivate Lock writeLock = lock.writeLock();\n\n\tpublic double read() {\n\t\t//获取读锁\n\t\treadLock.lock();\n\t\ttry {\n\t\t\treturn Math.sqrt(x * x + y * y);\n\t\t} finally {\n\t\t\t//释放读锁\n\t\t\treadLock.unlock();\n\t\t}\n\t}\n\n\tpublic void move(double deltaX, double deltaY) {\n\t\t//获取写锁\n\t\twriteLock.lock();\n\t\ttry {\n\t\t\tx += deltaX;\n\t\t\ty += deltaY;\n\t\t} finally {\n\t\t\t//释放写锁\n\t\t\twriteLock.unlock();\n\t\t}\n\t}\n\n}\n</code></pre><h3>2.读写锁再优化之StampedLock</h3><p>RRW被很好地应用在了读大于写的并发场景中，然而RRW在性能上还有可提升的空间。在读取很多、写入很少的情况下，RRW会使写入线程遭遇饥饿（Starvation）问题，也就是说写入线程会因迟迟无法竞争到锁而一直处于等待状态。</p><p>在JDK1.8中，Java提供了StampedLock类解决了这个问题。StampedLock不是基于AQS实现的，但实现的原理和AQS是一样的，都是基于队列和锁状态实现的。与RRW不一样的是，<span class=\"orange\">StampedLock控制锁有三种模式: 写、悲观读以及乐观读，</span>并且StampedLock在获取锁时会返回一个票据stamp，获取的stamp除了在释放锁时需要校验，在乐观读模式下，stamp还会作为读取共享资源后的二次校验，后面我会讲解stamp的工作原理。</p><p>我们先通过一个官方的例子来了解下StampedLock是如何使用的，代码如下：</p><pre><code>public class Point {\n    private double x, y;\n    private final StampedLock s1 = new StampedLock();\n\n    void move(double deltaX, double deltaY) {\n        //获取写锁\n        long stamp = s1.writeLock();\n        try {\n            x += deltaX;\n            y += deltaY;\n        } finally {\n            //释放写锁\n            s1.unlockWrite(stamp);\n        }\n    }\n\n    double distanceFormOrigin() {\n        //乐观读操作\n        long stamp = s1.tryOptimisticRead();  \n        //拷贝变量\n        double currentX = x, currentY = y;\n        //判断读期间是否有写操作\n        if (!s1.validate(stamp)) {\n            //升级为悲观读\n            stamp = s1.readLock();\n            try {\n                currentX = x;\n                currentY = y;\n            } finally {\n                s1.unlockRead(stamp);\n            }\n        }\n        return Math.sqrt(currentX * currentX + currentY * currentY);\n    }\n}\n</code></pre><p>我们可以发现：一个写线程获取写锁的过程中，首先是通过WriteLock获取一个票据stamp，WriteLock是一个独占锁，同时只有一个线程可以获取该锁，当一个线程获取该锁后，其它请求的线程必须等待，当没有线程持有读锁或者写锁的时候才可以获取到该锁。请求该锁成功后会返回一个stamp票据变量，用来表示该锁的版本，当释放该锁的时候，需要unlockWrite并传递参数stamp。</p><p>接下来就是一个读线程获取锁的过程。首先线程会通过乐观锁tryOptimisticRead操作获取票据stamp ，如果当前没有线程持有写锁，则返回一个非0的stamp版本信息。线程获取该stamp后，将会拷贝一份共享资源到方法栈，在这之前具体的操作都是基于方法栈的拷贝数据。</p><p>之后方法还需要调用validate，验证之前调用tryOptimisticRead返回的stamp在当前是否有其它线程持有了写锁，如果是，那么validate会返回0，升级为悲观锁；否则就可以使用该stamp版本的锁对数据进行操作。</p><p>相比于RRW，StampedLock获取读锁只是使用与或操作进行检验，不涉及CAS操作，即使第一次乐观锁获取失败，也会马上升级至悲观锁，这样就可以避免一直进行CAS操作带来的CPU占用性能的问题，因此StampedLock的效率更高。</p><h2>总结</h2><p>不管使用Synchronized同步锁还是Lock同步锁，只要存在锁竞争就会产生线程阻塞，从而导致线程之间的频繁切换，最终增加性能消耗。因此，<span class=\"orange\">如何降低锁竞争，就成为了优化锁的关键。</span></p><p>在Synchronized同步锁中，我们了解了可以通过减小锁粒度、减少锁占用时间来降低锁的竞争。在这一讲中，我们知道可以利用Lock锁的灵活性，通过锁分离的方式来降低锁竞争。</p><p>Lock锁实现了读写锁分离来优化读大于写的场景，从普通的RRW实现到读锁和写锁，到StampedLock实现了乐观读锁、悲观读锁和写锁，都是为了降低锁的竞争，促使系统的并发性能达到最佳。</p><h2>思考题</h2><p>StampedLock同RRW一样，都适用于读大于写操作的场景，StampedLock青出于蓝结果却不好说，毕竟RRW还在被广泛应用，就说明它还有StampedLock无法替代的优势。<span class=\"orange\">你知道StampedLock没有被广泛应用的原因吗？或者说它还存在哪些缺陷导致没有被广泛应用。</span></p><p>期待在留言区看到你的见解。也欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他一起学习。</p><p><img src=\"https://static001.geekbang.org/resource/image/bb/67/bbe343640d6b708832c4133ec53ed967.jpg?wh=1110*659\" alt=\"unpreview\"></p>","neighbors":{"left":{"article_title":"12 | 多线程之锁优化（上）：深入了解Synchronized同步锁的优化方法","id":101244},"right":{"article_title":"14 | 多线程之锁优化（下）：使用乐观锁优化并行操作","id":101995}},"comments":[{"had_liked":false,"id":104704,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1560819747,"is_pvip":false,"replies":[{"id":"38044","content":"回答很全面","user_name":"作者回复","comment_id":104704,"uid":"1228576","ip_address":"","utype":1,"ctime":1560906874,"user_name_real":"刘超"}],"discussion_count":3,"race_medal":0,"score":"272143759395","product_id":100028001,"comment_content":"StampLock不支持重入，不支持条件变量，线程被中断时可能导致CPU暴涨","like_count":64,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454382,"discussion_content":"回答很全面","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560906874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1264111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/49/ef/02401473.jpg","nickname":"月迷津渡","note":"","ucode":"2B18B2FE3DAC3B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6405,"discussion_content":"线程终端导致CPU暴涨该怎么理解呢。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1566889274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2051293,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","nickname":"Bumblebee","note":"","ucode":"B879C8A511D08D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1264111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/49/ef/02401473.jpg","nickname":"月迷津渡","note":"","ucode":"2B18B2FE3DAC3B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573118,"discussion_content":"有bug内部while循环有问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653210667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":6405,"ip_address":""},"score":573118,"extra":""}]}]},{"had_liked":false,"id":110317,"user_name":"KingSwim","can_delete":false,"product_type":"c1","uid":1024043,"ip_address":"","ucode":"84DE14B7EB2580","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a0/2b/efa6dc2e.jpg","comment_is_top":false,"comment_ctime":1562229451,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"194835757771","product_id":100028001,"comment_content":"重复是学习最好的方式——没有之一。虽然好几个Java专栏都会讲到锁的问题。但是，每次看完都是只能懂一部分。但是，每看完一个专栏就清晰一点，只有不断的重复，才能掌握好一个知识点。感觉复习同一个也会有效果（部分专栏看过 2 边，感觉有点耽误时间，专栏太多）。但是还是不如看新的专栏，因为同时还有其他知识点的收获。现在对温故而知新的”故“有了新的理解。另外，老师的 lock 是我看过专栏里面讲得最清晰的。","like_count":46},{"had_liked":false,"id":105330,"user_name":"我知道了嗯","can_delete":false,"product_type":"c1","uid":1138471,"ip_address":"","ucode":"9186EC1F32C490","user_header":"https://static001.geekbang.org/account/avatar/00/11/5f/27/a6873bc9.jpg","comment_is_top":false,"comment_ctime":1560987807,"is_pvip":false,"replies":[{"id":"51872","content":"可重入锁是指在同一个线程在前面方法中已获取锁了，再进入该线程的其他方法获取锁，此时不会因为之前获取锁而阻塞。<br>平时我们很少遇到这种情况，例如在A方法中使用了对象锁，B方法中也使用了该对象锁，平时一般都是分别调用A方法和B方法，而后面由于业务需求刚好需要在A方法中调用B方法，此时就会需要锁支持可重入性。","user_name":"作者回复","comment_id":105330,"uid":"1228576","ip_address":"","utype":1,"ctime":1569055550,"user_name_real":"刘超"}],"discussion_count":2,"race_medal":0,"score":"100345235615","product_id":100028001,"comment_content":"可重入锁是什么？另外什么场景下会使用到？","like_count":23,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454636,"discussion_content":"可重入锁是指在同一个线程在前面方法中已获取锁了，再进入该线程的其他方法获取锁，此时不会因为之前获取锁而阻塞。\n平时我们很少遇到这种情况，例如在A方法中使用了对象锁，B方法中也使用了该对象锁，平时一般都是分别调用A方法和B方法，而后面由于业务需求刚好需要在A方法中调用B方法，此时就会需要锁支持可重入性。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1569055550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1048661,"avatar":"https://static001.geekbang.org/account/avatar/00/10/00/55/3f0bc345.jpg","nickname":"Ghost","note":"","ucode":"CC6FD1D460ED10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388776,"discussion_content":"递归","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628948824,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104721,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1560821930,"is_pvip":false,"replies":[{"id":"37881","content":"第一个问题，这里有一个公平锁和非公平锁的情况，如果是公平锁，即使无锁竞争的情况下，也会进入阻塞队列中排队获取锁；否则，会立即CAS获取到读锁。<br><br>第二个问题，是公用的，这里同样涉及到了公平锁和非公平锁，读写线程对于程序来说都是一样的。如果是非公平锁，如果没有锁竞争的情况下CAS获取锁成功，是无需进入阻塞队列。如果是公平锁，都会进入阻塞队列。","user_name":"作者回复","comment_id":104721,"uid":"1228576","ip_address":"","utype":1,"ctime":1560824777,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":0,"score":"74575265962","product_id":100028001,"comment_content":"老师好!读写锁那个流程图看不太明白，没有写线程的时候，判断不是当前线程在读就会进入CLF阻塞等待。<br>问题1:不是可以并发读的嘛?按这图读线程也要阻塞等待的意思么?<br>问题二:CLF阻塞队列里是读写线程公用的么?队列里，读写交替出现。那不就没法并发读了么?","like_count":17,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454388,"discussion_content":"第一个问题，这里有一个公平锁和非公平锁的情况，如果是公平锁，即使无锁竞争的情况下，也会进入阻塞队列中排队获取锁；否则，会立即CAS获取到读锁。\n\n第二个问题，是公用的，这里同样涉及到了公平锁和非公平锁，读写线程对于程序来说都是一样的。如果是非公平锁，如果没有锁竞争的情况下CAS获取锁成功，是无需进入阻塞队列。如果是公平锁，都会进入阻塞队列。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560824777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104677,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1560817266,"is_pvip":false,"replies":[{"id":"37877","content":"是的，StampedLock不支持可重入。如果在一些需要重入的代码中使用StampedLock，会导致死锁、饿死等情况出现。","user_name":"作者回复","comment_id":104677,"uid":"1228576","ip_address":"","utype":1,"ctime":1560823941,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":0,"score":"48805457522","product_id":100028001,"comment_content":"为什么？因为锁不可重入？","like_count":11,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454371,"discussion_content":"是的，StampedLock不支持可重入。如果在一些需要重入的代码中使用StampedLock，会导致死锁、饿死等情况出现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560823941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105139,"user_name":"英长","can_delete":false,"product_type":"c1","uid":1328342,"ip_address":"","ucode":"501CF122762F8C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/uXBAfhWDWhwMbMNbbVbENibOmeDNQ6dQuLKicP2emibGUTrt0Z311Mczh6oareppbuu5TTOPIwXs42ahwcWRQB4pw/132","comment_is_top":false,"comment_ctime":1560928205,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"44510601165","product_id":100028001,"comment_content":"希望老师能多结合实践讲讲应用场景","like_count":10},{"had_liked":false,"id":189225,"user_name":"码农Kevin亮","can_delete":false,"product_type":"c1","uid":1116630,"ip_address":"","ucode":"D34562461CA0A1","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/d6/5f366427.jpg","comment_is_top":false,"comment_ctime":1584490866,"is_pvip":false,"replies":[{"id":"73036","content":"在某些场景中，ReentrantLock这种读写锁能保证数据的强一致性。假设我们有两个对象x,y被volatile修饰，在A线程调用写入方法，x被写入及时更新到缓存中，而y没有，此时B线程刚好读取x,y的值，此时读取的x值是被修改过的，而y值还是原来的值，即x,y存在数据不一致的可能。","user_name":"作者回复","comment_id":189225,"uid":"1228576","ip_address":"","utype":1,"ctime":1584536304,"user_name_real":"刘超"}],"discussion_count":4,"race_medal":0,"score":"31649261938","product_id":100028001,"comment_content":"请问老师，在读写锁的场景中，我在读操作时为什么还要加锁？直接读不就可以了？如果担心数据不刷新，那在变量加volatile是不是就可以满足？请解惑","like_count":7,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487639,"discussion_content":"在某些场景中，ReentrantLock这种读写锁能保证数据的强一致性。假设我们有两个对象x,y被volatile修饰，在A线程调用写入方法，x被写入及时更新到缓存中，而y没有，此时B线程刚好读取x,y的值，此时读取的x值是被修改过的，而y值还是原来的值，即x,y存在数据不一致的可能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584536304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1759325,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d8/5d/07dfb3b5.jpg","nickname":"杯莫停","note":"","ucode":"4FA1D5CBBEF702","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578971,"discussion_content":"我觉得这个问题的症结在于要遵循happens-before原则，一个写一定要发生在一个读这个内容之前。读和读之间可以不用加锁，但肯定要先让写完成，你读到的才是准确数据。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1657104741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1161636,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b9/a4/e9d2f9ba.jpg","nickname":"W.YH","note":"","ucode":"9BBE1EE38CDCAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289630,"discussion_content":"volatile修饰的变量不会进入缓存吧，他们全都在主内存中加载和读取","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594168780,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1759325,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d8/5d/07dfb3b5.jpg","nickname":"杯莫停","note":"","ucode":"4FA1D5CBBEF702","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578968,"discussion_content":"volatile禁用了CPU缓存，是直接读写内存中的对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657104324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166270,"user_name":"王圣军","can_delete":false,"product_type":"c1","uid":1395602,"ip_address":"","ucode":"1E13CF683137D1","user_header":"https://static001.geekbang.org/account/avatar/00/15/4b/92/03338a22.jpg","comment_is_top":false,"comment_ctime":1577429211,"is_pvip":false,"replies":[{"id":"65935","content":"是的","user_name":"作者回复","comment_id":166270,"uid":"1228576","ip_address":"","utype":1,"ctime":1578487521,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":0,"score":"31642200283","product_id":100028001,"comment_content":"老师这里说的公平锁和非公平锁让我想起两者是获取方式不同，非公平锁是首先就CAS来获取一次，成功就拿到锁，失败就放入队列；公平锁不会有这步操作，直接放入队列","like_count":8,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479468,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578487521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205012,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1586507571,"is_pvip":false,"replies":[{"id":"77118","content":"对的，理解很到位，发现了问题","user_name":"作者回复","comment_id":205012,"uid":"1228576","ip_address":"","utype":1,"ctime":1586865123,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":0,"score":"23061344051","product_id":100028001,"comment_content":"获取读锁的流程图有问题吧，应该是判断写锁是否为当前线程，而不是判断读锁。","like_count":5,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491351,"discussion_content":"对的，理解很到位，发现了问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586865123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104714,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1560821292,"is_pvip":false,"replies":[{"id":"38045","content":"是的，写多读少的性能没有优势。","user_name":"作者回复","comment_id":104714,"uid":"1228576","ip_address":"","utype":1,"ctime":1560906942,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":0,"score":"23035657772","product_id":100028001,"comment_content":"StampedLock在写多读少的时候性能会很差吧","like_count":5,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454386,"discussion_content":"是的，写多读少的性能没有优势。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560906942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104906,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1560867894,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18740737078","product_id":100028001,"comment_content":"老师这篇干货很多，看了2~3遍，大体理解了底层AQS锁原理，期待老师多多分享更多相关的文章","like_count":4},{"had_liked":false,"id":104809,"user_name":"你好旅行者","can_delete":false,"product_type":"c1","uid":1154101,"ip_address":"","ucode":"5C72A428DC28F3","user_header":"https://static001.geekbang.org/account/avatar/00/11/9c/35/9dc79371.jpg","comment_is_top":false,"comment_ctime":1560844594,"is_pvip":false,"replies":[{"id":"38063","content":"第一个问题，是老师笔误，搞错方向了，现在已更正。<br><br>第二个问题，如果读多写少的情况下，即使是公平锁，也是需要长时间等待，不是想获取时就能立即获取到锁。StampedLock如果是处于乐观读时，写锁是可以随时获取到锁。<br><br>第三个问题，StampedLock源码中存在大量compareAndSwapObject操作来保证原子性。","user_name":"作者回复","comment_id":104809,"uid":"1228576","ip_address":"","utype":1,"ctime":1560909778,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":0,"score":"18740713778","product_id":100028001,"comment_content":"老师我有几个问题：<br>1.在ReentrantLock中，state这个变量，为0的时候表示当前的锁是没有被占用的。这个时候线程应该用CAS尝试修改state变量的值对锁进行抢占才对呀，为什么在您的图里当state=0的时候还需要判断是否为当前线程呢？<br>2.老师提到读写锁在读多写少的情况下会使得写线程遭遇饥饿问题，那我是不是只需要将锁设置为公平锁，这样先申请写锁的线程就可以先获得锁，从而避免饥饿问题呢？<br>3.StampedLock中引入了一个stamp版本对版本进行控制，那么对这个stamp变量进行写入的时候是否需要使用CAS操作？如果不是，那如何保证对stamp变量的读写是线程安全的呢？<br>谢谢老师！<br>","like_count":4,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454431,"discussion_content":"第一个问题，是老师笔误，搞错方向了，现在已更正。\n\n第二个问题，如果读多写少的情况下，即使是公平锁，也是需要长时间等待，不是想获取时就能立即获取到锁。StampedLock如果是处于乐观读时，写锁是可以随时获取到锁。\n\n第三个问题，StampedLock源码中存在大量compareAndSwapObject操作来保证原子性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560909778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156629,"user_name":"奋斗的小白鼠","can_delete":false,"product_type":"c1","uid":1743483,"ip_address":"","ucode":"752BB901FFB7CE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/icHicAP9M4M4DIjAvlj5FDdFxIeA0pR3J15QdvVjXQXbznwunDN8OvrYqnsFchtBTNrZCCfGTE2RpPzIxjkvFAKg/132","comment_is_top":false,"comment_ctime":1574926540,"is_pvip":false,"replies":[{"id":"60139","content":"lock锁阻塞不会带来进程间的上下文切换，IO流存在的，在09讲中讲到了","user_name":"作者回复","comment_id":156629,"uid":"1228576","ip_address":"","utype":1,"ctime":1574940611,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":0,"score":"14459828428","product_id":100028001,"comment_content":"老师，lock锁中的线程阻塞进行的上下文切换会设计系统内核态和用户态的转换吗？啥时候会引起系统内核态和用户态转换成啊？.io流编程中会出现吗","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476179,"discussion_content":"lock锁阻塞不会带来进程间的上下文切换，IO流存在的，在09讲中讲到了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574940611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105922,"user_name":"欧星星","can_delete":false,"product_type":"c1","uid":1014347,"ip_address":"","ucode":"56365442E231A0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/4b/1a7b36ab.jpg","comment_is_top":false,"comment_ctime":1561105063,"is_pvip":false,"replies":[{"id":"38422","content":"对的。进程上下文切换，是指用户态和内核态的来回切换。我们知道，如果一旦Synchronized锁资源竞争激烈，线程将会被阻塞，阻塞的线程将会从用户态调用内核态，尝试获取mutex，这个过程就是进程上下文切换。","user_name":"作者回复","comment_id":105922,"uid":"1228576","ip_address":"","utype":1,"ctime":1561255619,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":0,"score":"14446006951","product_id":100028001,"comment_content":"sync使用的是操作系统的Mutex Lock来实现的锁，Lock是使用线程等待来实现锁的，线程也会存在用户态内核态的切换，这样理解对吗？","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454870,"discussion_content":"对的。进程上下文切换，是指用户态和内核态的来回切换。我们知道，如果一旦Synchronized锁资源竞争激烈，线程将会被阻塞，阻塞的线程将会从用户态调用内核态，尝试获取mutex，这个过程就是进程上下文切换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561255619,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244460,"user_name":"Wheat","can_delete":false,"product_type":"c1","uid":1260141,"ip_address":"","ucode":"7D99EA149B6DE8","user_header":"https://static001.geekbang.org/account/avatar/00/13/3a/6d/910b2445.jpg","comment_is_top":false,"comment_ctime":1598522632,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10188457224","product_id":100028001,"comment_content":"老师您好，RRW真的会导致写饥饿吗？您讲了获取读锁时会先判断需不需要阻塞。我看RRW的源码发现，在新来的线程尝试获取读锁的时候，会先判断阻塞队列中下一个准备获取锁的节点是否尝试获取写锁，如果下个节点尝试获取写锁，这个新来的线程是不会抢锁的","like_count":2},{"had_liked":false,"id":240826,"user_name":"天天向上","can_delete":false,"product_type":"c1","uid":1242455,"ip_address":"","ucode":"0CCCA6F4DCC480","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg","comment_is_top":false,"comment_ctime":1597077081,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10187011673","product_id":100028001,"comment_content":"老师好，Lock的加锁和解锁，最终会通过调用LockSupport的方法进而调用 UNSAFE.park，或者UNSAFE.park方法，我想知道UNSAFE的这些方法会有内核态和用户态之间的切换吗","like_count":2,"discussions":[{"author":{"id":1181454,"avatar":"","nickname":"Carla","note":"","ucode":"29608BF359A567","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580721,"discussion_content":"synchronized和lock两者用的同一个系统调用，和synchronized的重量锁每次都要进行系统调用相比，lock通过cas减少了系统调用的可能，进而降低了整体的开销，如果synchronized能支持锁降级，两者的性能应该会差不多把？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658360315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237134,"user_name":"Gavin","can_delete":false,"product_type":"c1","uid":1616970,"ip_address":"","ucode":"A5735665E303FD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/2UXuSevhia94o9Eky4OfMuSictaldxcqpjGuvRCOcvjIIoVBAENLEZbv2lgwmwC8icK1ZrUcneNtiaeFBV8MT3uzNg/132","comment_is_top":false,"comment_ctime":1595687035,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10185621627","product_id":100028001,"comment_content":"例子中，乐观读时，x和y不是volatile，读的是本地内存的，有可能不是最新值，这个是不是有问题呀？","like_count":2},{"had_liked":false,"id":149818,"user_name":"又双叒叕是一年啊","can_delete":false,"product_type":"c1","uid":1000015,"ip_address":"","ucode":"E067320E537DEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","comment_is_top":false,"comment_ctime":1573389605,"is_pvip":false,"replies":[{"id":"57897","content":"从源码分析，都会进行高低位的判断，获取写锁时，如果state!=0 and w==0，就可以判断了此锁r!=0，也就是判断了高16位有没有读锁了。","user_name":"作者回复","comment_id":149818,"uid":"1228576","ip_address":"","utype":1,"ctime":1573559858,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":0,"score":"10163324197","product_id":100028001,"comment_content":"RRW 加写锁 和 读锁 都需要判断低16位？ 这块写锁是不是应该判读的是高16位有没有读锁，从而判断有没有冲突？","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473988,"discussion_content":"从源码分析，都会进行高低位的判断，获取写锁时，如果state!=0 and w==0，就可以判断了此锁r!=0，也就是判断了高16位有没有读锁了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573559858,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105088,"user_name":"你好旅行者","can_delete":false,"product_type":"c1","uid":1154101,"ip_address":"","ucode":"5C72A428DC28F3","user_header":"https://static001.geekbang.org/account/avatar/00/11/9c/35/9dc79371.jpg","comment_is_top":false,"comment_ctime":1560914027,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10150848619","product_id":100028001,"comment_content":"谢谢老师的回复！关于StampedLock，我的理解是乐观读的时候，线程把stamp的值读出来，通过与运算来判断当前是否存在写操作。这个过程是不涉及CAS操作的。可是如果有线程需要修改当前的资源，要加写锁，那么就需要使用CAS操作修改stamp的值。不知道这样理解是否准确。<br>此外，前排@-W.LI-同学提出的那个问题，并发读的时候也需要按照是否是公平锁进入CLH队列进行阻塞我还不是很明白，既然大家都是读操作，互相之间没有冲突，我每个线程都直接用CAS操作获取锁不就行了吗，为什么还要进队列阻塞等待呢？","like_count":2},{"had_liked":false,"id":346522,"user_name":"Bumblebee","can_delete":false,"product_type":"c1","uid":2051293,"ip_address":"","ucode":"B879C8A511D08D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","comment_is_top":false,"comment_ctime":1653211294,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5948178590","product_id":100028001,"comment_content":"今日思考<br><br>StampedLock相比于ReentrantReadWriteLock的优点之一，在读多写少的场景下，写线程可能会长时间获取不到写锁，StampedLock利用乐观读（无锁化操作）当写线程能申请锁时能及时获取锁，不会像读写锁那样可能长时间获取不到锁。<br><br>我的意思大家应该明白了吧😂（说的不对的大家多多指正）","like_count":1},{"had_liked":false,"id":149260,"user_name":"考休","can_delete":false,"product_type":"c1","uid":1053955,"ip_address":"","ucode":"968DFC00D6D0CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg","comment_is_top":false,"comment_ctime":1573180292,"is_pvip":false,"replies":[{"id":"57610","content":"一般占有锁时间非常短，队列的长度也不会太长，这个性能几乎可以忽略","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1573383724,"ip_address":"","comment_id":149260,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5868147588","product_id":100028001,"comment_content":"老师，公平锁因为要维持一个线程执行的顺序，是不是性能相对非公平锁弱一些？","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473796,"discussion_content":"一般占有锁时间非常短，队列的长度也不会太长，这个性能几乎可以忽略","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573383724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132160,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1568034483,"is_pvip":false,"replies":[{"id":"51137","content":"我们进入到底层代码，可以发现其实公平锁和非公平锁的区别就是是否进入队列，公平锁是会进入到队列中排队等待唤醒，而非公平锁则是直接CAS获取锁。<br><br>Lock锁如果监测到中断就直接throw new InterruptedException();抛出来了，所以可以响应中断。<br><br>具体可参考源码。<br><br><br>","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568539623,"ip_address":"","comment_id":132160,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5863001779","product_id":100028001,"comment_content":"课后思考及问题<br>1：公平锁和非公平锁具体指什么？怎么体现？<br><br>2：锁的状态可中断和不可中断具体是指什么意思？<br><br>晚上加班状态可能不太好，感觉老师主要讲解了几种同步锁的实现原理，以及特点，如果能列个二维表就更好啦!","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466796,"discussion_content":"我们进入到底层代码，可以发现其实公平锁和非公平锁的区别就是是否进入队列，公平锁是会进入到队列中排队等待唤醒，而非公平锁则是直接CAS获取锁。\n\nLock锁如果监测到中断就直接throw new InterruptedException();抛出来了，所以可以响应中断。\n\n具体可参考源码。\n\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568539623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104772,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1560832080,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5855799376","product_id":100028001,"comment_content":"刚想反馈图片一个字母写反了，刷新一下，立马被修复了，厉害厉害，佩服老师的效率","like_count":1},{"had_liked":false,"id":104743,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1560825659,"is_pvip":false,"replies":[{"id":"38046","content":"赞，要根据业务场景选择锁类型。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560907002,"ip_address":"","comment_id":104743,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5855792955","product_id":100028001,"comment_content":"我觉的票据本来就是读写锁升级版，性能绝逼是优于读写锁的。硬要说不如，不允许锁重入和阻塞时调用interrupt()有CPU彪高的bug算是存在的问题吧。前者，毕竟票据和读写都是用于读多写少的场景，所以互斥锁重入这块感觉量不大，没了倒也无伤大雅。而后者bug就是bug没得说。其实如果是写多读少的场景，隐式锁会比这些读写锁性能更好。重点还是根据具体的业务场景去选择。<br><br>","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454403,"discussion_content":"赞，要根据业务场景选择锁类型。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560907002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104718,"user_name":"孙志强","can_delete":false,"product_type":"c1","uid":1325997,"ip_address":"","ucode":"9C070F1E4EC6FF","user_header":"https://static001.geekbang.org/account/avatar/00/14/3b/ad/31193b83.jpg","comment_is_top":false,"comment_ctime":1560821651,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5855788947","product_id":100028001,"comment_content":"Stampedlock牺牲了微小的数据一致性来提升性能。","like_count":1},{"had_liked":false,"id":104643,"user_name":"张学磊","can_delete":false,"product_type":"c1","uid":1250029,"ip_address":"","ucode":"F545F384A6F1E1","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotSSnZic41tGkbflx0ogIg3ia6g2muFY1hCgosL2t3icZm7I8Ax1hcv1jNgr6vrZ53dpBuGhaoc6DKg/132","comment_is_top":false,"comment_ctime":1560812575,"is_pvip":false,"replies":[{"id":"37883","content":"这就是一种按版本号实现的读乐观锁，我们经常会在数据库更新操作时用到这种基于版本号实现的写乐观锁。<br><br>对的，StampedLock不支持重入。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560825203,"ip_address":"","comment_id":104643,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5855779871","product_id":100028001,"comment_content":"老师，tryOptimisticRead操作获取的不应该叫乐观读锁，应该是乐观读，是无锁的；StampedLock名字中没有Reentrant，所以不支持重入；StampedLock也不支持条件变量。","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454357,"discussion_content":"这就是一种按版本号实现的读乐观锁，我们经常会在数据库更新操作时用到这种基于版本号实现的写乐观锁。\n\n对的，StampedLock不支持重入。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560825203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350706,"user_name":"杯莫停","can_delete":false,"product_type":"c1","uid":1759325,"ip_address":"","ucode":"4FA1D5CBBEF702","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d8/5d/07dfb3b5.jpg","comment_is_top":false,"comment_ctime":1657104799,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1657104799","product_id":100028001,"comment_content":"干货挺多的，以至于读的很慢，但收获也多。","like_count":0},{"had_liked":false,"id":346520,"user_name":"Bumblebee","can_delete":false,"product_type":"c1","uid":2051293,"ip_address":"","ucode":"B879C8A511D08D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","comment_is_top":false,"comment_ctime":1653211005,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1653211005","product_id":100028001,"comment_content":"① StampedLock不支持可重入锁；<br><br>② StampedLock获取的不是可中断的读写锁，调用中断操作时，会导致线程所在CPU飙升，如果一定要执行中断操作请使用可中断的悲观读锁readLockInterruptibly() 和写锁 writeLockInterruptibly()；<br><br>③ StampedLock不支持条件变量；","like_count":0},{"had_liked":false,"id":323404,"user_name":"码哥字节","can_delete":false,"product_type":"c1","uid":1572356,"ip_address":"","ucode":"362103AD52C8E0","user_header":"https://static001.geekbang.org/account/avatar/00/17/fe/04/bb427e47.jpg","comment_is_top":false,"comment_ctime":1637890977,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637890977","product_id":100028001,"comment_content":"不支持锁重入，无法使用条件等待，线程中断可能会导致CPU飙升","like_count":0},{"had_liked":false,"id":302362,"user_name":"凯文小猪","can_delete":false,"product_type":"c1","uid":1980201,"ip_address":"","ucode":"36D8AD0229547F","user_header":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","comment_is_top":false,"comment_ctime":1626179015,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626179015","product_id":100028001,"comment_content":"StampedLock是乐观读写锁。读的过程中也允许获取写锁后写入！这样一来，我们读的数据就可能不一致","like_count":0},{"had_liked":false,"id":289501,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1619055651,"is_pvip":false,"replies":[{"id":"105085","content":"同学你好，感谢你的反馈，流程图已更正！","user_name":"编辑回复","user_name_real":"王冬青","uid":"1356014","ctime":1619144690,"ip_address":"","comment_id":289501,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1619055651","product_id":100028001,"comment_content":"老师，RRW 获取读锁流程图，对 state 低 16 位为 0 的判断，2个判断流程反了吧！高读低写，如果低 16 位为 0，说明高位不为 0，此时有读锁，需要判断读锁是否为当前线程持有。<br>能否更正一下流程图，谢谢！","like_count":0,"discussions":[{"author":{"id":1356014,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b0/ee/d0871efd.jpg","nickname":"冬青","note":"","ucode":"14576781B499FB","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518934,"discussion_content":"同学你好，感谢你的反馈，流程图已更正！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619144690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":282021,"user_name":"Eco","can_delete":false,"product_type":"c1","uid":1373230,"ip_address":"","ucode":"5459B494753183","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/x86UN2kFbJGGwiaw7yeVtyaf05y5eZmdOciaAF09WEBRVicbPGsej1b62UAH3icjeJqvibVc6aqB0EuFwDicicKKcF47w/132","comment_is_top":false,"comment_ctime":1615018755,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615018755","product_id":100028001,"comment_content":"你好，感觉文章对于AQS的篇幅有点少，但AQS在JDK的同步包中的作用是非常大的。","like_count":0},{"had_liked":false,"id":256664,"user_name":"考休","can_delete":false,"product_type":"c1","uid":1053955,"ip_address":"","ucode":"968DFC00D6D0CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg","comment_is_top":false,"comment_ctime":1603700360,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603700360","product_id":100028001,"comment_content":"老师，您好，RRW只有是非公平锁时才会并发读，否则也会进入CLH阻塞队列。请问这样理解对吗？","like_count":0},{"had_liked":false,"id":249565,"user_name":"Wheat","can_delete":false,"product_type":"c1","uid":1260141,"ip_address":"","ucode":"7D99EA149B6DE8","user_header":"https://static001.geekbang.org/account/avatar/00/13/3a/6d/910b2445.jpg","comment_is_top":false,"comment_ctime":1600693900,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600693900","product_id":100028001,"comment_content":"老师，想问一下validate方法中调用了loadFence，查了一下叫“内存屏障”，是用来保证内存一致性和防止指令重排的，那为什么要在这里调用loadFence呢，一共就只有stamp和state两个变量","like_count":0},{"had_liked":false,"id":245187,"user_name":"瑶老板的小弟","can_delete":false,"product_type":"c1","uid":1438863,"ip_address":"","ucode":"EA6CDB3165227F","user_header":"https://static001.geekbang.org/account/avatar/00/15/f4/8f/6b3d4370.jpg","comment_is_top":false,"comment_ctime":1598860045,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1598860045","product_id":100028001,"comment_content":"StampedLock 解决写线程饥饿问题？<br>怎么解决的 没看明白。","like_count":0,"discussions":[{"author":{"id":1260141,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3a/6d/910b2445.jpg","nickname":"Wheat","note":"","ucode":"7D99EA149B6DE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307610,"discussion_content":"读的时候不加锁，不会阻塞写","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600695532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238290,"user_name":"阳春面","can_delete":false,"product_type":"c1","uid":1693492,"ip_address":"","ucode":"27493CAD3D7EF3","user_header":"https://static001.geekbang.org/account/avatar/00/19/d7/34/b67c74b8.jpg","comment_is_top":false,"comment_ctime":1596112280,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596112280","product_id":100028001,"comment_content":"老师您好，请问什么时候用Synchronized什么时候用lock。之前面试有碰到这个问题，答了几个点但总感觉不是面试官想要的答案。","like_count":0},{"had_liked":false,"id":208673,"user_name":"天天向上","can_delete":false,"product_type":"c1","uid":1242455,"ip_address":"","ucode":"0CCCA6F4DCC480","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg","comment_is_top":false,"comment_ctime":1587398092,"is_pvip":false,"replies":[{"id":"78612","content":"在读&#47;读的情况下，就减少竞争了，只有在读&#47;写或者写&#47;写的情况下才有竞争","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1587988260,"ip_address":"","comment_id":208673,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587398092","product_id":100028001,"comment_content":"老师在文章中说：如果多个线程仅仅是读取共享资源，那么这种情况下其实没有必要对资源进行加锁。可是获取读锁的流程图中，在获取读锁的时候，仍然需要竞争，竞争失败还会进行休眠，之后再竞争，这好像不符合上文说的“没必要对资源进行加锁&#39;这句话啊","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492571,"discussion_content":"在读/读的情况下，就减少竞争了，只有在读/写或者写/写的情况下才有竞争","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587988260,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204999,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1586505259,"is_pvip":false,"replies":[{"id":"77117","content":"这个时候又读锁，读锁和写锁是互斥的，所以不会被其他线程修改","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1586864832,"ip_address":"","comment_id":204999,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586505259","product_id":100028001,"comment_content":"return Math.sqrt(currentX * currentX + currentY * currentY);<br> 如果执行到这个步骤的时候，写锁突然被其他线程获取到并且修改了X,Y，此时也无法校验了，算出的数还是错的，这个怎么办？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491347,"discussion_content":"这个时候又读锁，读锁和写锁是互斥的，所以不会被其他线程修改","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586864832,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":195562,"user_name":"will","can_delete":false,"product_type":"c1","uid":1156207,"ip_address":"","ucode":"7A7DBE3E0EEAEB","user_header":"https://static001.geekbang.org/account/avatar/00/11/a4/6f/672a27d4.jpg","comment_is_top":false,"comment_ctime":1585197545,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585197545","product_id":100028001,"comment_content":"一直都是做移动端，没接触过这些锁，可以好好学学","like_count":0},{"had_liked":false,"id":170599,"user_name":"。。。。。","can_delete":false,"product_type":"c1","uid":1612570,"ip_address":"","ucode":"985B1561AC9152","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Xibh27ZicBhXls5KsPibBXZI4RKlR0MUbUiaEuOS2ORibKaxWSicpIjd4lvWUWqtNAde7EeDDTpWKAiapGdHeaiaDqczWQ/132","comment_is_top":false,"comment_ctime":1578641426,"is_pvip":false,"replies":[{"id":"70528","content":"问题一：因为这个是读写锁，读锁和写锁的逻辑是分开的；<br>问题二：因为ReentrantReadWriteLock是具有公平锁的特性。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1582722835,"ip_address":"","comment_id":170599,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578641426","product_id":100028001,"comment_content":"老师，请问一下，<br>问题一：那两个流程图，为什么同样是判断state低16位是否为0，为否时，一次是判断获取写锁的线程是否为当前线程，一次是判断获取读锁的线程是否为当前线程<br>问题二：当中间某一步就可以知道锁获取失败（比如获取读锁流程中，state低16位不为0，且获取写锁的不是当前线程），不是就直接可以放入队列了吗，为什么还要判断是否为公平锁","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481035,"discussion_content":"问题一：因为这个是读写锁，读锁和写锁的逻辑是分开的；\n问题二：因为ReentrantReadWriteLock是具有公平锁的特性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582722835,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":149781,"user_name":"又双叒叕是一年啊","can_delete":false,"product_type":"c1","uid":1000015,"ip_address":"","ucode":"E067320E537DEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","comment_is_top":false,"comment_ctime":1573376139,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1573376139","product_id":100028001,"comment_content":"请教下，非公平锁是怎么玩的随机唤醒一个等待线程Node节点的，是压根不考虑CLH队列的顺序吗？ 还是非公平锁压根不把获取锁失败的线程封装成Node加入到CLH队列中？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":47631,"discussion_content":"不会放入CLH队列，会随机抢占锁，建议参考源码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573383362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127317,"user_name":"行则将至","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","comment_is_top":false,"comment_ctime":1566650077,"is_pvip":false,"replies":[{"id":"47297","content":"对的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1566785813,"ip_address":"","comment_id":127317,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1566650077","product_id":100028001,"comment_content":"老师，隐式锁只有synchronized这一种吗?","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464436,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566785813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114522,"user_name":"辉","can_delete":false,"product_type":"c1","uid":1514658,"ip_address":"","ucode":"39D6CDEF00083A","user_header":"https://static001.geekbang.org/account/avatar/00/17/1c/a2/2c3572de.jpg","comment_is_top":false,"comment_ctime":1563328723,"is_pvip":false,"replies":[{"id":"41789","content":"你可以自己搜索了解下，极客时间其他专栏中也有介绍，App中搜索可以找到相关资料。","user_name":"编辑回复","user_name_real":"郭蕾","uid":"1000473","ctime":1563329926,"ip_address":"","comment_id":114522,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1563328723","product_id":100028001,"comment_content":"一直不明白老师说的CAS是啥东东。具体描述下","like_count":0,"discussions":[{"author":{"id":1000473,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/44/19/17fadc62.jpg","nickname":"郭蕾","note":"","ucode":"34F4C07D1C5FE8","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458701,"discussion_content":"你可以自己搜索了解下，极客时间其他专栏中也有介绍，App中搜索可以找到相关资料。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563329926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111966,"user_name":"嘉嘉☕","can_delete":false,"product_type":"c1","uid":1059771,"ip_address":"","ucode":"632A5CC4B53BB1","user_header":"https://static001.geekbang.org/account/avatar/00/10/2b/bb/5cf70df8.jpg","comment_is_top":false,"comment_ctime":1562643867,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562643867","product_id":100028001,"comment_content":"好的，谢谢老师，就是看到图和文字是不一样的，确认一下","like_count":0},{"had_liked":false,"id":111725,"user_name":"嘉嘉☕","can_delete":false,"product_type":"c1","uid":1059771,"ip_address":"","ucode":"632A5CC4B53BB1","user_header":"https://static001.geekbang.org/account/avatar/00/10/2b/bb/5cf70df8.jpg","comment_is_top":false,"comment_ctime":1562590259,"is_pvip":false,"replies":[{"id":"40696","content":"获取写锁的次数，也是独占的数量","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562636774,"ip_address":"","comment_id":111725,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562590259","product_id":100028001,"comment_content":"老师好，请问<br>获取写锁的流程，文字描述和流程图，有个地方不太一样，判断“获取写锁的次数”还是“获取读锁的次数”？？<br>谢谢老师","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457427,"discussion_content":"获取写锁的次数，也是独占的数量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562636774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110764,"user_name":"任鹏斌","can_delete":false,"product_type":"c1","uid":1104086,"ip_address":"","ucode":"34319B05EA6E74","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/d6/47da34bf.jpg","comment_is_top":false,"comment_ctime":1562326843,"is_pvip":false,"replies":[{"id":"40389","content":"是的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562464640,"ip_address":"","comment_id":110764,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562326843","product_id":100028001,"comment_content":"老师好，1. 读写锁 ReentrantReadWriteLock获取写锁的时候也需要等待读锁释放后才能真正获取到是吗？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457042,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562464640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109910,"user_name":"木木","can_delete":false,"product_type":"c1","uid":1091401,"ip_address":"","ucode":"14D8A2979D284E","user_header":"https://static001.geekbang.org/account/avatar/00/10/a7/49/9a2c8cfd.jpg","comment_is_top":false,"comment_ctime":1562131318,"is_pvip":false,"replies":[{"id":"39940","content":"这里没有具体讲解共享锁和独占锁的实现，后续我在这里补充下","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562207758,"ip_address":"","comment_id":109910,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562131318","product_id":100028001,"comment_content":"老师，读锁是一个共享锁，而写锁是一个独占锁，这个在文章中哪一部分有讲解呢？看了两遍不是很理解。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456636,"discussion_content":"这里没有具体讲解共享锁和独占锁的实现，后续我在这里补充下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562207758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108080,"user_name":"Geek_ebda96","can_delete":false,"product_type":"c1","uid":1134862,"ip_address":"","ucode":"02912E6D95A5A6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoRiaKX0ulEibbbwM4xhjyMeza0Pyp7KO1mqvfJceiaM6ZNtGpXJibI6P2qHGwBP9GKwOt9LgHicHflBXw/132","comment_is_top":false,"comment_ctime":1561680714,"is_pvip":false,"replies":[{"id":"39150","content":"RRW的读也是有锁的，所以不需要volatie修饰。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561684140,"ip_address":"","comment_id":108080,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561680714","product_id":100028001,"comment_content":"老师，RRW锁的读锁在获取锁的时候如果没有写锁，直接就可以获取到锁，只不过获取锁的过程中要用到CAS操作，相比于stampedlock，这个的乐观锁操作其实没用到任何锁操作，try的过程只是判断有没有写锁，没有则把共享变量的值拷贝到栈里面，后面的validate操作，也是再判断有没有写锁，没有则继续操作，这样理解对吗？那思考题里的问题，是因为乐观锁的过程除了try和validate操作判断有没有写锁，实际更新共享变量的值过程中没有cas和锁的操作，乐观锁的过程中其他线程还是可以获取到写锁，没法操作结果一定正确<br><br>最后还有一个问题这两种锁的读锁的cas操作只是在保证获取锁的过程和更新锁状态的过程吧，加锁的过程本身是要把内存中共享变量的值更新到栈中，共享变量本身不用volatie修饰？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455816,"discussion_content":"RRW的读也是有锁的，所以不需要volatie修饰。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561684140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107661,"user_name":"Geek_ebda96","can_delete":false,"product_type":"c1","uid":1134862,"ip_address":"","ucode":"02912E6D95A5A6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoRiaKX0ulEibbbwM4xhjyMeza0Pyp7KO1mqvfJceiaM6ZNtGpXJibI6P2qHGwBP9GKwOt9LgHicHflBXw/132","comment_is_top":false,"comment_ctime":1561594536,"is_pvip":false,"replies":[{"id":"39210","content":"这里纠正一下，应该要先去判断是否是公平锁，如果是，则进入到CLH队列中，否则直接CAS获取锁。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561694538,"ip_address":"","comment_id":107661,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561594536","product_id":100028001,"comment_content":"老师好，请问一下为什么rrw获取锁的时候，state状态为0还是需要把当前线程先加入clh等待队列，不直接去cas更新状态获取锁，为了公平性吗，是根据参数设置的值判断的吗","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455613,"discussion_content":"这里纠正一下，应该要先去判断是否是公平锁，如果是，则进入到CLH队列中，否则直接CAS获取锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561694538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107162,"user_name":"余冲","can_delete":false,"product_type":"c1","uid":1175598,"ip_address":"","ucode":"162AF434FA753B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f0/2e/b3c880b8.jpg","comment_is_top":false,"comment_ctime":1561471068,"is_pvip":false,"replies":[{"id":"38857","content":"没有错，如果state为0，则表示没有被其他线程占用锁资源，进入CAS获取锁；否则，则需要继续判断高低位状态。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561523814,"ip_address":"","comment_id":107162,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561471068","product_id":100028001,"comment_content":"老师，你那个rrw获取写锁时的图，第一个判断及其后面的判断，直线的逻辑，应该是:是。否才加入clh队列。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455393,"discussion_content":"没有错，如果state为0，则表示没有被其他线程占用锁资源，进入CAS获取锁；否则，则需要继续判断高低位状态。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561523814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106564,"user_name":"小布丁","can_delete":false,"product_type":"c1","uid":1253022,"ip_address":"","ucode":"A9907715455F58","user_header":"https://static001.geekbang.org/account/avatar/00/13/1e/9e/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1561345551,"is_pvip":false,"replies":[{"id":"38829","content":"是的，读锁是一个共享锁，而写锁是一个独占锁。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561514901,"ip_address":"","comment_id":106564,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561345551","product_id":100028001,"comment_content":"老师我有一个问题，RRW在没有写锁的情况下，可以并发读，既然可以并发读为什么还要获取锁呢？是不是意味着读锁是可以被很多线程同时拥有的？而写锁就是独占的？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455139,"discussion_content":"是的，读锁是一个共享锁，而写锁是一个独占锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561514901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106123,"user_name":"小橙橙","can_delete":false,"product_type":"c1","uid":1054923,"ip_address":"","ucode":"4F467210A15F66","user_header":"https://static001.geekbang.org/account/avatar/00/10/18/cb/edb5a0a0.jpg","comment_is_top":false,"comment_ctime":1561182548,"is_pvip":false,"replies":[{"id":"38413","content":"这里用到state高低位设计，可以优化锁类型的判断，例如只要被获取锁，state的变量就不为0，之后再去通过state的高低位判断是读锁还是写锁。<br><br>当然用枚举判断也行，如果用一个int类型能完成的事情，那就不用再去用枚举，这样不仅逻辑清晰，也节约了内存空间。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561254312,"ip_address":"","comment_id":106123,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1561182548","product_id":100028001,"comment_content":"老师好！为什么读写锁判断state的地方要使用高低位这种设计呢，直接使用0、1、2这样的枚举判断理解上不是要更简单吗？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454964,"discussion_content":"这里用到state高低位设计，可以优化锁类型的判断，例如只要被获取锁，state的变量就不为0，之后再去通过state的高低位判断是读锁还是写锁。\n\n当然用枚举判断也行，如果用一个int类型能完成的事情，那就不用再去用枚举，这样不仅逻辑清晰，也节约了内存空间。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1561254312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383606,"discussion_content":"因为接口定义时只有一个变量state state作为重入次数。但是读写锁显然是两把锁 那么只能在位操作上动脑静","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626179217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105501,"user_name":"shoo","can_delete":false,"product_type":"c1","uid":1482438,"ip_address":"","ucode":"5C0D00A979C9C9","user_header":"https://static001.geekbang.org/account/avatar/00/16/9e/c6/3e5aef4c.jpg","comment_is_top":false,"comment_ctime":1561016520,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561016520","product_id":100028001,"comment_content":"    <br>有个问题，最近在优化程序，刚好看到这一节<br>    private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();<br><br>    &#47;&#47;写锁<br>    private Lock writeLock = lock.writeLock();<br><br>    writeLock.lock();&#47;&#47;这里为什么回报空指针异常","like_count":0},{"had_liked":false,"id":104930,"user_name":"G","can_delete":false,"product_type":"c1","uid":1206873,"ip_address":"","ucode":"35A3A0CD1FF675","user_header":"https://static001.geekbang.org/account/avatar/00/12/6a/59/ba3cad16.jpg","comment_is_top":false,"comment_ctime":1560873227,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560873227","product_id":100028001,"comment_content":"不可重入","like_count":0},{"had_liked":false,"id":104888,"user_name":"你好旅行者","can_delete":false,"product_type":"c1","uid":1154101,"ip_address":"","ucode":"5C72A428DC28F3","user_header":"https://static001.geekbang.org/account/avatar/00/11/9c/35/9dc79371.jpg","comment_is_top":false,"comment_ctime":1560864023,"is_pvip":false,"replies":[{"id":"38055","content":"在锁资源竞争不是很激烈的情况下，偶尔需要同步时，使用synchronized既简单又方便，而且JVM的编译器会尽可能的优化锁。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560908085,"ip_address":"","comment_id":104888,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560864023","product_id":100028001,"comment_content":"既然Lock的性能又比synchronized好，又提供了专门用于读多写少场景下的读写锁和StampedLock，那我们什么时候应该用synchronized而不用Lock呢？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454471,"discussion_content":"在锁资源竞争不是很激烈的情况下，偶尔需要同步时，使用synchronized既简单又方便，而且JVM的编译器会尽可能的优化锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560908085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104882,"user_name":"陆离","can_delete":false,"product_type":"c1","uid":1483932,"ip_address":"","ucode":"2C8C206CE36A81","user_header":"https://static001.geekbang.org/account/avatar/00/16/a4/9c/b32ed9e9.jpg","comment_is_top":false,"comment_ctime":1560862590,"is_pvip":false,"replies":[{"id":"38090","content":"😁","user_name":"编辑回复","user_name_real":"王冬青","uid":"1356014","ctime":1560927736,"ip_address":"","comment_id":104882,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1560862590","product_id":100028001,"comment_content":"这个声音可以。","like_count":0,"discussions":[{"author":{"id":1356014,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b0/ee/d0871efd.jpg","nickname":"冬青","note":"","ucode":"14576781B499FB","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454468,"discussion_content":"😁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560927736,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104744,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1560825873,"is_pvip":false,"replies":[{"id":"38047","content":"如果嵌套调用则会出现count1中的锁一直在等待count中的锁释放，这种情况就出现死锁了：<br><br>\t\tpublic void count() {<br>\t\t\tlong stamp = s1.writeLock();<br>\t\t\ttry {<br>\t\t\t\tcount1();<br>\t\t\t\tcount++;<br>\t\t\t\t&#47;&#47; System.out.println(&quot;count：&quot; + count);<br>\t\t\t} finally {<br>\t\t\t\ts1.unlockWrite(stamp);<br>\t\t\t}<br>\t\t}<br>\t\t<br>\t\tpublic void count1() {<br>\t\t\tlong stamp = s1.writeLock();<br>\t\t\ttry {<br>\t\t\t\tcount++;<br>\t\t\t\t&#47;&#47; System.out.println(&quot;count：&quot; + count);<br>\t\t\t} finally {<br>\t\t\t\ts1.unlockWrite(stamp);<br>\t\t\t}<br>\t\t}","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560907169,"ip_address":"","comment_id":104744,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560825873","product_id":100028001,"comment_content":"@密码123456 为什么会有死锁？线程饥饿我能理解，但死锁应该是由于交叉取锁这种实现缺陷导致。跟不可重入有啥关系？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454404,"discussion_content":"如果嵌套调用则会出现count1中的锁一直在等待count中的锁释放，这种情况就出现死锁了：\n\n\t\tpublic void count() {\n\t\t\tlong stamp = s1.writeLock();\n\t\t\ttry {\n\t\t\t\tcount1();\n\t\t\t\tcount++;\n\t\t\t\t// System.out.println(&amp;quot;count：&amp;quot; + count);\n\t\t\t} finally {\n\t\t\t\ts1.unlockWrite(stamp);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void count1() {\n\t\t\tlong stamp = s1.writeLock();\n\t\t\ttry {\n\t\t\t\tcount++;\n\t\t\t\t// System.out.println(&amp;quot;count：&amp;quot; + count);\n\t\t\t} finally {\n\t\t\t\ts1.unlockWrite(stamp);\n\t\t\t}\n\t\t}","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1560907169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104701,"user_name":"nightmare","can_delete":false,"product_type":"c1","uid":1056314,"ip_address":"","ucode":"EF2E51C2122A86","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/3a/5b21c01c.jpg","comment_is_top":false,"comment_ctime":1560819640,"is_pvip":false,"replies":[{"id":"37879","content":"这一讲中的第一个流程图是AQS的实现原理。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560824178,"ip_address":"","comment_id":104701,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560819640","product_id":100028001,"comment_content":"老师会不会讲AQS呢，非常期待","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454380,"discussion_content":"这一讲中的第一个流程图是AQS的实现原理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560824178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104699,"user_name":"nimil","can_delete":false,"product_type":"c1","uid":1197925,"ip_address":"","ucode":"19933068972746","user_header":"https://static001.geekbang.org/account/avatar/00/12/47/65/cce8eb34.jpg","comment_is_top":false,"comment_ctime":1560819518,"is_pvip":false,"replies":[{"id":"37878","content":"随着业务的复杂化，有可能出现方法嵌套获取锁的可能。例如：<br><br>void A(){<br>   synchronized(lockObj){<br>      do something...<br>      B();<br>   }<br>}<br> <br>void B(){<br>   synchronized(lockObj){<br>      do something...<br>   }","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560824072,"ip_address":"","comment_id":104699,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560819518","product_id":100028001,"comment_content":"老师您好，请问下什么时候当前线程会在获取到锁的情况下尝试再次获取锁操作呢？这块一直不是很懂","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454379,"discussion_content":"随着业务的复杂化，有可能出现方法嵌套获取锁的可能。例如：\n\nvoid A(){\n   synchronized(lockObj){\n      do something...\n      B();\n   }\n}\n \nvoid B(){\n   synchronized(lockObj){\n      do something...\n   }","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560824072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104691,"user_name":"夏天39度","can_delete":false,"product_type":"c1","uid":1104979,"ip_address":"","ucode":"A929B422255547","user_header":"https://static001.geekbang.org/account/avatar/00/10/dc/53/ccb62ea0.jpg","comment_is_top":false,"comment_ctime":1560818793,"is_pvip":false,"replies":[{"id":"37884","content":"synchronized 是可重入的。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560825318,"ip_address":"","comment_id":104691,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560818793","product_id":100028001,"comment_content":"老师，sync是不可重入的吧","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454377,"discussion_content":"synchronized 是可重入的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1560825318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}