{"id":229996,"title":"76 |  开源实战一（上）：通过剖析Java JDK源码学习灵活应用设计模式","content":"<p>从今天开始，我们就正式地进入到实战环节。实战环节包括两部分，一部分是开源项目实战，另一部分是项目实战。</p><p>在开源项目实战部分，我会带你剖析几个经典的开源项目中用到的设计原则、思想和模式，这其中就包括对Java JDK、Unix、Google Guava、Spring、MyBatis这样五个开源项目的分析。在项目实战部分，我们精心挑选了几个实战项目，手把手地带你利用之前学过的设计原则、思想、模式，来对它们进行分析、设计和代码实现，这其中就包括鉴权限流、幂等重试、灰度发布这样三个项目。</p><p>接下来的两节课，我们重点剖析Java JDK中用到的几种常见的设计模式。学习的目的是让你体会，在真实的项目开发中，要学会活学活用，切不可过于死板，生搬硬套设计模式的设计与实现。除此之外，针对每个模式，我们不可能像前面学习理论知识那样，分析得细致入微，很多都是点到为止。在已经具备之前理论知识的前提下，我想你可以跟着我的指引自己去研究，有哪里不懂的话，也可以再回过头去看下之前的理论讲解。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>工厂模式在Calendar类中的应用</h2><p>在前面讲到工厂模式的时候，大部分工厂类都是以Factory作为后缀来命名，并且工厂类主要负责创建对象这样一件事情。但在实际的项目开发中，工厂类的设计更加灵活。那我们就来看下，工厂模式在Java JDK中的一个应用：java.util.Calendar。从命名上，我们无法看出它是一个工厂类。</p><!-- [[[read_end]]] --><p>Calendar类提供了大量跟日期相关的功能代码，同时，又提供了一个getInstance()工厂方法，用来根据不同的TimeZone和Locale创建不同的Calendar子类对象。也就是说，功能代码和工厂方法代码耦合在了一个类中。所以，即便我们去查看它的源码，如果不细心的话，也很难发现它用到了工厂模式。同时，因为它不单单是一个工厂类，所以，它并没有以Factory作为后缀来命名。</p><p>Calendar类的相关代码如下所示，大部分代码都已经省略，我只给出了getInstance()工厂方法的代码实现。从代码中，我们可以看出，getInstance()方法可以根据不同TimeZone和Locale，创建不同的Calendar子类对象，比如BuddhistCalendar、JapaneseImperialCalendar、GregorianCalendar，这些细节完全封装在工厂方法中，使用者只需要传递当前的时区和地址，就能够获得一个Calendar类对象来使用，而获得的对象具体是哪个Calendar子类的对象，使用者在使用的时候并不关心。</p><pre><code>public abstract class Calendar implements Serializable, Cloneable, Comparable&lt;Calendar&gt; {\n  //...\n  public static Calendar getInstance(TimeZone zone, Locale aLocale){\n    return createCalendar(zone, aLocale);\n  }\n\n  private static Calendar createCalendar(TimeZone zone,Locale aLocale) {\n    CalendarProvider provider = LocaleProviderAdapter.getAdapter(\n        CalendarProvider.class, aLocale).getCalendarProvider();\n    if (provider != null) {\n      try {\n        return provider.getInstance(zone, aLocale);\n      } catch (IllegalArgumentException iae) {\n        // fall back to the default instantiation\n      }\n    }\n\n    Calendar cal = null;\n    if (aLocale.hasExtensions()) {\n      String caltype = aLocale.getUnicodeLocaleType(&quot;ca&quot;);\n      if (caltype != null) {\n        switch (caltype) {\n          case &quot;buddhist&quot;:\n            cal = new BuddhistCalendar(zone, aLocale);\n            break;\n          case &quot;japanese&quot;:\n            cal = new JapaneseImperialCalendar(zone, aLocale);\n            break;\n          case &quot;gregory&quot;:\n            cal = new GregorianCalendar(zone, aLocale);\n            break;\n        }\n      }\n    }\n    if (cal == null) {\n      if (aLocale.getLanguage() == &quot;th&quot; &amp;&amp; aLocale.getCountry() == &quot;TH&quot;) {\n        cal = new BuddhistCalendar(zone, aLocale);\n      } else if (aLocale.getVariant() == &quot;JP&quot; &amp;&amp; aLocale.getLanguage() == &quot;ja&quot; &amp;&amp; aLocale.getCountry() == &quot;JP&quot;) {\n        cal = new JapaneseImperialCalendar(zone, aLocale);\n      } else {\n        cal = new GregorianCalendar(zone, aLocale);\n      }\n    }\n    return cal;\n  }\n  //...\n}\n</code></pre><h2>建造者模式在Calendar类中的应用</h2><p>还是刚刚的Calendar类，它不仅仅用到了工厂模式，还用到了建造者模式。我们知道，建造者模式有两种实现方法，一种是单独定义一个Builder类，另一种是将Builder实现为原始类的内部类。Calendar就采用了第二种实现思路。我们先来看代码再讲解，相关代码我贴在了下面。</p><pre><code>public abstract class Calendar implements Serializable, Cloneable, Comparable&lt;Calendar&gt; {\n  //...\n  public static class Builder {\n    private static final int NFIELDS = FIELD_COUNT + 1;\n    private static final int WEEK_YEAR = FIELD_COUNT;\n    private long instant;\n    private int[] fields;\n    private int nextStamp;\n    private int maxFieldIndex;\n    private String type;\n    private TimeZone zone;\n    private boolean lenient = true;\n    private Locale locale;\n    private int firstDayOfWeek, minimalDaysInFirstWeek;\n\n    public Builder() {}\n    \n    public Builder setInstant(long instant) {\n        if (fields != null) {\n            throw new IllegalStateException();\n        }\n        this.instant = instant;\n        nextStamp = COMPUTED;\n        return this;\n    }\n    //...省略n多set()方法\n    \n    public Calendar build() {\n      if (locale == null) {\n        locale = Locale.getDefault();\n      }\n      if (zone == null) {\n        zone = TimeZone.getDefault();\n      }\n      Calendar cal;\n      if (type == null) {\n        type = locale.getUnicodeLocaleType(&quot;ca&quot;);\n      }\n      if (type == null) {\n        if (locale.getCountry() == &quot;TH&quot; &amp;&amp; locale.getLanguage() == &quot;th&quot;) {\n          type = &quot;buddhist&quot;;\n        } else {\n          type = &quot;gregory&quot;;\n        }\n      }\n      switch (type) {\n        case &quot;gregory&quot;:\n          cal = new GregorianCalendar(zone, locale, true);\n          break;\n        case &quot;iso8601&quot;:\n          GregorianCalendar gcal = new GregorianCalendar(zone, locale, true);\n          // make gcal a proleptic Gregorian\n          gcal.setGregorianChange(new Date(Long.MIN_VALUE));\n          // and week definition to be compatible with ISO 8601\n          setWeekDefinition(MONDAY, 4);\n          cal = gcal;\n          break;\n        case &quot;buddhist&quot;:\n          cal = new BuddhistCalendar(zone, locale);\n          cal.clear();\n          break;\n        case &quot;japanese&quot;:\n          cal = new JapaneseImperialCalendar(zone, locale, true);\n          break;\n        default:\n          throw new IllegalArgumentException(&quot;unknown calendar type: &quot; + type);\n      }\n      cal.setLenient(lenient);\n      if (firstDayOfWeek != 0) {\n        cal.setFirstDayOfWeek(firstDayOfWeek);\n        cal.setMinimalDaysInFirstWeek(minimalDaysInFirstWeek);\n      }\n      if (isInstantSet()) {\n        cal.setTimeInMillis(instant);\n        cal.complete();\n        return cal;\n      }\n\n      if (fields != null) {\n        boolean weekDate = isSet(WEEK_YEAR) &amp;&amp; fields[WEEK_YEAR] &gt; fields[YEAR];\n        if (weekDate &amp;&amp; !cal.isWeekDateSupported()) {\n          throw new IllegalArgumentException(&quot;week date is unsupported by &quot; + type);\n        }\n        for (int stamp = MINIMUM_USER_STAMP; stamp &lt; nextStamp; stamp++) {\n          for (int index = 0; index &lt;= maxFieldIndex; index++) {\n            if (fields[index] == stamp) {\n              cal.set(index, fields[NFIELDS + index]);\n              break;\n             }\n          }\n        }\n\n        if (weekDate) {\n          int weekOfYear = isSet(WEEK_OF_YEAR) ? fields[NFIELDS + WEEK_OF_YEAR] : 1;\n          int dayOfWeek = isSet(DAY_OF_WEEK) ? fields[NFIELDS + DAY_OF_WEEK] : cal.getFirstDayOfWeek();\n          cal.setWeekDate(fields[NFIELDS + WEEK_YEAR], weekOfYear, dayOfWeek);\n        }\n        cal.complete();\n      }\n      return cal;\n    }\n  }\n}\n</code></pre><p>看了上面的代码，我有一个问题请你思考一下：既然已经有了getInstance()工厂方法来创建Calendar类对象，为什么还要用Builder来创建Calendar类对象呢？这两者之间的区别在哪里呢？</p><p>实际上，在前面讲到这两种模式的时候，我们对它们之间的区别做了详细的对比，现在，我们再来一块回顾一下。工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。</p><p>网上有一个经典的例子很好地解释了两者的区别。</p><blockquote>\n<p>顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作不同的披萨。</p>\n</blockquote><p>粗看Calendar的Builder类的build()方法，你可能会觉得它有点像工厂模式。你的感觉没错，前面一半代码确实跟getInstance()工厂方法类似，根据不同的type创建了不同的Calendar子类。实际上，后面一半代码才属于标准的建造者模式，根据setXXX()方法设置的参数，来定制化刚刚创建的Calendar子类对象。</p><p>你可能会说，这还能算是建造者模式吗？我用<a href=\"https://time.geekbang.org/column/article/199674\">第46讲</a>的一段话来回答你：</p><blockquote>\n<p>我们也不要太学院派，非得把工厂模式、建造者模式分得那么清楚，我们需要知道的是，每个模式为什么这么设计，能解决什么问题。只有了解了这些最本质的东西，我们才能不生搬硬套，才能灵活应用，甚至可以混用各种模式，创造出新的模式来解决特定场景的问题。</p>\n</blockquote><p>实际上，从Calendar这个例子，我们也能学到，不要过于死板地套用各种模式的原理和实现，不要不敢做丝毫的改动。模式是死的，用的人是活的。在实际上的项目开发中，不仅各种模式可以混合在一起使用，而且具体的代码实现，也可以根据具体的功能需求做灵活的调整。</p><h2>装饰器模式在Collections类中的应用</h2><p>我们前面讲到，Java IO类库是装饰器模式的非常经典的应用。实际上，Java的Collections类也用到了装饰器模式。</p><p>Collections类是一个集合容器的工具类，提供了很多静态方法，用来创建各种集合容器，比如通过unmodifiableColletion()静态方法，来创建UnmodifiableCollection类对象。而这些容器类中的UnmodifiableCollection类、CheckedCollection和SynchronizedCollection类，就是针对Collection类的装饰器类。</p><p>因为刚刚提到的这三个装饰器类，在代码结构上几乎一样，所以，我们这里只拿其中的UnmodifiableCollection类来举例讲解一下。UnmodifiableCollection类是Collections类的一个内部类，相关代码我摘抄到了下面，你可以先看下。</p><pre><code>public class Collections {\n  private Collections() {}\n    \n  public static &lt;T&gt; Collection&lt;T&gt; unmodifiableCollection(Collection&lt;? extends T&gt; c) {\n    return new UnmodifiableCollection&lt;&gt;(c);\n  }\n\n  static class UnmodifiableCollection&lt;E&gt; implements Collection&lt;E&gt;,   Serializable {\n    private static final long serialVersionUID = 1820017752578914078L;\n    final Collection&lt;? extends E&gt; c;\n\n    UnmodifiableCollection(Collection&lt;? extends E&gt; c) {\n      if (c==null)\n        throw new NullPointerException();\n      this.c = c;\n    }\n\n    public int size()                   {return c.size();}\n    public boolean isEmpty()            {return c.isEmpty();}\n    public boolean contains(Object o)   {return c.contains(o);}\n    public Object[] toArray()           {return c.toArray();}\n    public &lt;T&gt; T[] toArray(T[] a)       {return c.toArray(a);}\n    public String toString()            {return c.toString();}\n\n    public Iterator&lt;E&gt; iterator() {\n      return new Iterator&lt;E&gt;() {\n        private final Iterator&lt;? extends E&gt; i = c.iterator();\n\n        public boolean hasNext() {return i.hasNext();}\n        public E next()          {return i.next();}\n        public void remove() {\n          throw new UnsupportedOperationException();\n        }\n        @Override\n        public void forEachRemaining(Consumer&lt;? super E&gt; action) {\n          // Use backing collection version\n          i.forEachRemaining(action);\n        }\n      };\n    }\n\n    public boolean add(E e) {\n      throw new UnsupportedOperationException();\n    }\n    public boolean remove(Object o) {\n       hrow new UnsupportedOperationException();\n    }\n    public boolean containsAll(Collection&lt;?&gt; coll) {\n      return c.containsAll(coll);\n    }\n    public boolean addAll(Collection&lt;? extends E&gt; coll) {\n      throw new UnsupportedOperationException();\n    }\n    public boolean removeAll(Collection&lt;?&gt; coll) {\n      throw new UnsupportedOperationException();\n    }\n    public boolean retainAll(Collection&lt;?&gt; coll) {\n      throw new UnsupportedOperationException();\n    }\n    public void clear() {\n      throw new UnsupportedOperationException();\n    }\n\n    // Override default methods in Collection\n    @Override\n    public void forEach(Consumer&lt;? super E&gt; action) {\n      c.forEach(action);\n    }\n    @Override\n    public boolean removeIf(Predicate&lt;? super E&gt; filter) {\n      throw new UnsupportedOperationException();\n    }\n    @SuppressWarnings(&quot;unchecked&quot;)\n    @Override\n    public Spliterator&lt;E&gt; spliterator() {\n      return (Spliterator&lt;E&gt;)c.spliterator();\n    }\n    @SuppressWarnings(&quot;unchecked&quot;)\n    @Override\n    public Stream&lt;E&gt; stream() {\n      return (Stream&lt;E&gt;)c.stream();\n    }\n    @SuppressWarnings(&quot;unchecked&quot;)\n    @Override\n    public Stream&lt;E&gt; parallelStream() {\n      return (Stream&lt;E&gt;)c.parallelStream();\n    }\n  }\n}\n</code></pre><p>看了上面的代码，请你思考一下，为什么说UnmodifiableCollection类是Collection类的装饰器类呢？这两者之间可以看作简单的接口实现关系或者类继承关系吗？</p><p>我们前面讲过，装饰器模式中的装饰器类是对原始类功能的增强。尽管UnmodifiableCollection类可以算是对Collection类的一种功能增强，但这点还不具备足够的说服力来断定UnmodifiableCollection就是Collection类的装饰器类。</p><p>实际上，最关键的一点是，UnmodifiableCollection的构造函数接收一个Collection类对象，然后对其所有的函数进行了包裹（Wrap）：重新实现（比如add()函数）或者简单封装（比如stream()函数）。而简单的接口实现或者继承，并不会如此来实现UnmodifiableCollection类。所以，从代码实现的角度来说，UnmodifiableCollection类是典型的装饰器类。</p><h2>适配器模式在Collections类中的应用</h2><p>在<a href=\"https://time.geekbang.org/column/article/205912\">第51讲</a>中我们讲到，适配器模式可以用来兼容老的版本接口。当时我们举了一个JDK的例子，这里我们再重新仔细看一下。</p><p>老版本的JDK提供了Enumeration类来遍历容器。新版本的JDK用Iterator类替代Enumeration类来遍历容器。为了兼容老的客户端代码（使用老版本JDK的代码），我们保留了Enumeration类，并且在Collections类中，仍然保留了enumaration()静态方法（因为我们一般都是通过这个静态函数来创建一个容器的Enumeration类对象）。</p><p>不过，保留Enumeration类和enumeration()函数，都只是为了兼容，实际上，跟适配器没有一点关系。那到底哪一部分才是适配器呢？</p><p>在新版本的JDK中，Enumeration类是适配器类。它适配的是客户端代码（使用Enumeration类）和新版本JDK中新的迭代器Iterator类。不过，从代码实现的角度来说，这个适配器模式的代码实现，跟经典的适配器模式的代码实现，差别稍微有点大。enumeration()静态函数的逻辑和Enumeration适配器类的代码耦合在一起，enumeration()静态函数直接通过new的方式创建了匿名类对象。具体的代码如下所示：</p><pre><code>/**\n * Returns an enumeration over the specified collection.  This provides\n * interoperability with legacy APIs that require an enumeration\n * as input.\n *\n * @param  &lt;T&gt; the class of the objects in the collection\n * @param c the collection for which an enumeration is to be returned.\n * @return an enumeration over the specified collection.\n * @see Enumeration\n */\npublic static &lt;T&gt; Enumeration&lt;T&gt; enumeration(final Collection&lt;T&gt; c) {\n  return new Enumeration&lt;T&gt;() {\n    private final Iterator&lt;T&gt; i = c.iterator();\n\n    public boolean hasMoreElements() {\n      return i.hasNext();\n    }\n\n    public T nextElement() {\n      return i.next();\n    }\n  };\n}\n</code></pre><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>今天，我重点讲了工厂模式、建造者模式、装饰器模式、适配器模式，这四种模式在Java JDK中的应用，主要目的是给你展示真实项目中是如何灵活应用设计模式的。</p><p>从今天的讲解中，我们可以学习到，尽管在之前的理论讲解中，我们都有讲到每个模式的经典代码实现，但是，在真实的项目开发中，这些模式的应用更加灵活，代码实现更加自由，可以根据具体的业务场景、功能需求，对代码实现做很大的调整，甚至还可能会对模式本身的设计思路做调整。</p><p>比如，Java JDK中的Calendar类，就耦合了业务功能代码、工厂方法、建造者类三种类型的代码，而且，在建造者类的build()方法中，前半部分是工厂方法的代码实现，后半部分才是真正的建造者模式的代码实现。这也告诉我们，在项目中应用设计模式，切不可生搬硬套，过于学院派，要学会结合实际情况做灵活调整，做到心中无剑胜有剑。</p><h2>课堂讨论</h2><p>在Java中，经常用到的StringBuilder类是否是建造者模式的应用呢？你可以试着像我一样从源码的角度去剖析一下。</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"75 | 在实际的项目开发中，如何避免过度设计？又如何避免设计不足？","id":229157},"right":{"article_title":"77 | 开源实战一（下）：通过剖析Java JDK源码学习灵活应用设计模式","id":230708}},"comments":[{"had_liked":false,"id":211775,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1588002780,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"332300484572","product_id":100039001,"comment_content":"我觉得是，因为StringBuilder的主要方法append，其实就是类似于建造者模式中的set方法，只不过构建者模式的set方法可能是对象的不同属性，但append其实是在一直修改一个属性，且最后没有build(),但StringBuilder出现的目的其实是为了解决String不可变的问题，最终输出其实是String，所以可以类比toString()就是build()，所以认为算是建造者模式。","like_count":76},{"had_liked":false,"id":213042,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1588284623,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"96077565135","product_id":100039001,"comment_content":"StringBuilder没有使用建造者模式，只是名字碰巧用了builder这个单词。它只是用来构建可变字符串，仅此而已，别想太多。","like_count":23},{"had_liked":false,"id":264471,"user_name":"Laughing","can_delete":false,"product_type":"c1","uid":1002134,"ip_address":"","ucode":"F68F1E000CA800","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/96/99466a06.jpg","comment_is_top":false,"comment_ctime":1606472592,"is_pvip":false,"replies":[{"id":"96072","content":"嗯嗯 ������","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606700596,"ip_address":"","comment_id":264471,"utype":1}],"discussion_count":1,"race_medal":0,"score":"66030982032","product_id":100039001,"comment_content":"我个人理解是建造者模式的典型实现。虽然只有append方法，但是每个append的参数构造是不同的，从方面也反映出，append的方法可以通过不同的参数构造不同的String。当然该类也不只是只有append的参数，还有例如insert delete参数。以上说明符合建造者模式中所要解决的构建复杂对象的目的。","like_count":16,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510574,"discussion_content":"嗯嗯 ������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211472,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1587968897,"is_pvip":false,"discussion_count":1,"race_medal":1,"score":"48832609153","product_id":100039001,"comment_content":"课后思考：<br>我的答案是算也不算…，如果按照学院派的思想，stringbuilder和GOF中的对于builder模式的定义完全不同，stringbuilder并不会创建新的string对象，只是将多个字符连接在一起，而builder模式的基本功能是生成新对象，两个本质就不一样了，从这个角度来讲，stringbuilder不能算是builder模式。<br>那为什么又说算呢？这样从另外一个角度想，stringbuilder得到的字符串是一步一步append出来的，这个builder模式的一步一步set在build的行为很像，因为文中也说了不要太学院派，要灵活使用，那么从这个角度来说可以认为stringbuilder也是属于builder的一种实现，只是它不是典型实现。","like_count":11,"discussions":[{"author":{"id":1019588,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8e/c4/8d1150f3.jpg","nickname":"Richie","note":"","ucode":"12314EF0347693","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260522,"discussion_content":"“stringbuilder并不会创建新的string对象”这句表述有点问题，StringBuilder会创建对象的，在最终调用toString()的时候，就new了一个String对象，其实这就相当于build方法了。","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1588865759,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211447,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1587963928,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27357767704","product_id":100039001,"comment_content":"回答课后题：<br><br>我认为应该算是建造者模式。<br><br>拿餐厅类比，对于披萨加番茄，起司等不同配料来定制披萨，这属于建造者模式要解决的问题（实例对象的定制）。而stringbuild的应用场景，更像是对披萨加一个番茄还是两个番茄更或者三个番茄的定制方式（某个字段的定制）。<br><br>所以strbuild的应用场景比传统的建造者模式更细更具体（前者实现字段的定制，后者实现对象的定制）。但字段定制依旧属于对象定制的范涛，所以我认为其依旧算是建造者模式。","like_count":7},{"had_liked":false,"id":211373,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1587954104,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18767823288","product_id":100039001,"comment_content":"课堂讨论: <br>StringBuilder应用了Builder模式. 其主要方式是append(), 即通过不断append创建复杂对象. <br>不同于传统Builder模式的是: <br>1. StringBuilder的目的是创建String, 但StringBuilder并不是String的内部类.<br>2. StringBuilder的创建过程可以断续, 传统的Builder模式一次性填入参数后调用build()方法创建对象.<br>3. StringBuilder通过内部维护字符数组(char[])的方式实现拼接. ","like_count":4},{"had_liked":false,"id":211277,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1587945033,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18767814217","product_id":100039001,"comment_content":"StringBuilder的append()方法使用了建造者模式，StringBuilder把构建者的角色交给了其的父类AbstractStringBuilder，最终调用的是父类的append（）方法","like_count":4},{"had_liked":false,"id":215009,"user_name":"Richie","can_delete":false,"product_type":"c1","uid":1019588,"ip_address":"","ucode":"12314EF0347693","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/c4/8d1150f3.jpg","comment_is_top":false,"comment_ctime":1588867964,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14473769852","product_id":100039001,"comment_content":"The intent of the Builder design pattern is to separate the construction of a complex object from its representation. By doing so the same construction process can create different representations.<br><br>从StringBuilder的代码实现来看，他通过append方法来设置其value属性，最终使用toString()方法来创建对象。这符合建造者模式的定义。这跟我们平时使用的建造者模式唯一的不同就是他一直设置的是同一个属性，而平时我们会设置多个属性，并最终调用build()方法来创建对象。","like_count":3,"discussions":[{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370916,"discussion_content":"有道理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619579567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213519,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1588441150,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14473343038","product_id":100039001,"comment_content":"StringBuilder并没有使用构造者模式，从设计意图上看这俩不是一回事—构造者模式得意图是为同一个类生成不同定制需求的对象，而StringBuilder的设计意图是为了实现可变更的字符串来优化内存占用","like_count":3},{"had_liked":false,"id":211768,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1588002492,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"14472904380","product_id":100039001,"comment_content":"如果说要创建一个复杂的String对象，那么通过StringBuilder的append()方法会非常方便，最后通过toString()方法返回，从这个角度看算建造者模式。<br>    @Override<br>    public String toString() {<br>        &#47;&#47; Create a copy, don&#39;t share the array<br>        return new String(value, 0, count);<br>    }","like_count":3},{"had_liked":false,"id":211423,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1587960956,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14472862844","product_id":100039001,"comment_content":"总结：<br>1 工厂模式：简单工厂模式+工厂方法模式<br>● 简单工厂模式直接在条件判断中根据不同参数将目标对象new了出来。<br>● 工厂方法模式是将目标对象的创建过程根据参数分类抽取到各自独立的工厂类中，以应对目标对象创建过程的复杂度。条件分支可以使用map来缓存起来！<br>案例：java.util.Calendar的getInstance() 方法可以根据不同 TimeZone 和 Locale，创建不同的 Calendar 子类对象。<br><br>2 建造者模式：<br>通过内部的Builder类主导目标对象的创建同时校验必选属性之间的依赖关系。<br><br>3 装饰器模式：<br>装饰器模式把每个要装饰的功能放到单独的类中，并让这个类包装它所需要装饰的对象，从而实现对原始类的增强。<br>案例：java的IO类库比如InputStream和BufferInputStream。还有Collections类。","like_count":3},{"had_liked":false,"id":253412,"user_name":"Nano","can_delete":false,"product_type":"c1","uid":2020878,"ip_address":"","ucode":"933A6E5CC2987D","user_header":"https://static001.geekbang.org/account/avatar/00/1e/d6/0e/02f53725.jpg","comment_is_top":false,"comment_ctime":1602731359,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"10192665951","product_id":100039001,"comment_content":"虽然建造者模式有个明确的定义。<br>但是对于我个人来说，只要是可以一直return this，可以一直.setA().setB().setC()....的我都会把它当做建造者模式来理解。因为每次set都会给这个实例添砖加瓦，添加属性。至于要不要最后build()一下做一些逻辑，按需使用吧。","like_count":2},{"had_liked":false,"id":249126,"user_name":"飞翔","can_delete":false,"product_type":"c1","uid":1065986,"ip_address":"","ucode":"3D3D10273BED18","user_header":"https://static001.geekbang.org/account/avatar/00/10/44/02/5c8e4b81.jpg","comment_is_top":false,"comment_ctime":1600439690,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"10190374282","product_id":100039001,"comment_content":"不是，从源码角度看，构造方法不私有，没有复杂构造逻辑，完全不符合构建这模式定义，唯一关联就是名字里面有一个Builder","like_count":2,"discussions":[{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370918,"discussion_content":"有道理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619579622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216791,"user_name":"落尘kira","can_delete":false,"product_type":"c1","uid":1092169,"ip_address":"","ucode":"D203B519E43F85","user_header":"https://static001.geekbang.org/account/avatar/00/10/aa/49/51790edb.jpg","comment_is_top":false,"comment_ctime":1589343277,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10179277869","product_id":100039001,"comment_content":"StringBuilder本意是创建可变字符串，如果调用toString（）那么就是；如果不调用，那严格意义上不是。但由于出发点是创建可变字符串，理论上其设计的目的就是让使用者最终都会调用toString（）方法，因此我认为他是","like_count":2},{"had_liked":false,"id":211393,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1587957125,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10177891717","product_id":100039001,"comment_content":"个人认为,是属于建造者模式的,在其中,最主要的append方法,是将其抛给了父类AbstractStringBuilder,然后返回自己,其父类AbstractStringBuilder中维护了一个数组,并且可以动然扩容,在我们最后获取结果的toString()方法中,就是直接new String对象,这种模式其实更像是装饰器模式的实现","like_count":2},{"had_liked":false,"id":213962,"user_name":"衞嚼爺","can_delete":false,"product_type":"c1","uid":1328330,"ip_address":"","ucode":"A46F56AB787FEE","user_header":"https://static001.geekbang.org/account/avatar/00/14/44/ca/510a132a.jpg","comment_is_top":false,"comment_ctime":1588600835,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5883568131","product_id":100039001,"comment_content":"StringBuilder从命名上看和Builder模式很像，但不算是建造者模式的应用。StringBuilder从实现的功能上看，更像是对字符串String按照装饰器模式进行封装，是一种字符串的功能叠加。","like_count":1},{"had_liked":false,"id":212475,"user_name":"无所从来","can_delete":false,"product_type":"c1","uid":1325996,"ip_address":"","ucode":"E7AD394BC16A73","user_header":"https://static001.geekbang.org/account/avatar/00/14/3b/ac/40807e85.jpg","comment_is_top":false,"comment_ctime":1588130375,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5883097671","product_id":100039001,"comment_content":"建造者的意图是 “将一个对象的复杂构建与其表示相分离，使得同样的构建过程可以创建不同的表示”。类似的，StringBuilder通过相同的构建过程append方法，创建出不同的String对象。因此，它是典型的建造者模式。","like_count":1},{"had_liked":false,"id":211361,"user_name":"全炸攻城狮","can_delete":false,"product_type":"c1","uid":1315968,"ip_address":"","ucode":"DB437F9190575C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqZIqY4cs6YKNx0OqeMrbjLIicqiafLNtLYJTN2zTtVPlwXZ7qlJ7xrGQictk1xCq5pEsIyqnkiaCib4zQ/132","comment_is_top":false,"comment_ctime":1587952648,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5882919944","product_id":100039001,"comment_content":"感觉不像建造者。append在StringBuilder的创建过程中不起任何作用，append真正用到的地方是StringBuilder创建好以后，对字符串的拼接。StringBuilder的创建是调用的构造方法","like_count":1},{"had_liked":false,"id":211355,"user_name":"Keep-Moving","can_delete":false,"product_type":"c1","uid":1182631,"ip_address":"","ucode":"76F33C06E07A27","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/a7/6ef32187.jpg","comment_is_top":false,"comment_ctime":1587952055,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5882919351","product_id":100039001,"comment_content":"感觉UnmodifiableCollection 更像是 Collection 类的代理类","like_count":1,"discussions":[{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":249769,"discussion_content":"代码确实很像，但是功能不一样。代理增加的是跟原始方法不同的功能;装饰器则是增强原始功能，从代码上确实看不出来，从增加的业务功能点角度看就看出不同了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587961180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339488,"user_name":"一杯绿绿","can_delete":false,"product_type":"c1","uid":2551566,"ip_address":"","ucode":"1ADE60EAC76167","user_header":"https://static001.geekbang.org/account/avatar/00/26/ef/0e/bbc35830.jpg","comment_is_top":false,"comment_ctime":1648128129,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648128129","product_id":100039001,"comment_content":"面向接口编程，有利于利于灵活利用多态，当后续需求变化时，可通过多态来实现低成本的改动。因为调用方感知到的只是接口，并不感知接口的具体实现，所以接口具体实现的变动对调用方是无影响的。","like_count":0},{"had_liked":false,"id":324889,"user_name":"Z宇锤锤","can_delete":false,"product_type":"c1","uid":2188142,"ip_address":"","ucode":"7DB36E986A7A51","user_header":"https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg","comment_is_top":false,"comment_ctime":1638704556,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1638704556","product_id":100039001,"comment_content":"不是工厂，也不是建造者。就是平平凡凡的一个实现类哦","like_count":0},{"had_liked":false,"id":324884,"user_name":"Z宇锤锤","can_delete":false,"product_type":"c1","uid":2188142,"ip_address":"","ucode":"7DB36E986A7A51","user_header":"https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg","comment_is_top":false,"comment_ctime":1638703561,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1638703561","product_id":100039001,"comment_content":"工程模式就是标准化产品，比如成品服装。建造者模式就是私人订制，做很多的细节微调。以成品西装和定制西装为例，定制西装量体裁衣。定制西装量衣而行。","like_count":0},{"had_liked":false,"id":290470,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1619578621,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619578621","product_id":100039001,"comment_content":"我认为StringBuffer没有使用构造者模式. 构造者模式构造的对象是一次性生成的, 生成后不再改变, 而StringBuffer中没有体现出这一点","like_count":0},{"had_liked":false,"id":288109,"user_name":"Yeyw","can_delete":false,"product_type":"c1","uid":1463740,"ip_address":"","ucode":"C9D20DB91C3BE5","user_header":"https://static001.geekbang.org/account/avatar/00/16/55/bc/fad0090b.jpg","comment_is_top":false,"comment_ctime":1618303700,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618303700","product_id":100039001,"comment_content":"类似于builder，但算不上，在为完全设置好字符串的情况下就可能被tostring()，导致对象不是预期状态。","like_count":0},{"had_liked":false,"id":286927,"user_name":"否极泰来","can_delete":false,"product_type":"c1","uid":1439355,"ip_address":"","ucode":"C249173266251A","user_header":"https://static001.geekbang.org/account/avatar/00/15/f6/7b/b6abcbbe.jpg","comment_is_top":false,"comment_ctime":1617685190,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617685190","product_id":100039001,"comment_content":"我觉得算，毕竟他是构建了不可变对象String<br>不一定只有构建复杂的对象才能使用建造者模式，<br>StringBuilder这是创建节约内存的建造者，也是使用建造者模式。","like_count":0},{"had_liked":false,"id":285315,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1616736269,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616736269","product_id":100039001,"comment_content":"老师，有个疑问：<br>前面使用工厂模式，后面一半代码才属于标准的建造者模式，根据 setXXX() 方法设置的参数，来定制化刚刚创建的 Calendar 子类对象。<br><br>如果把后半段的代码也改为“工厂模式”可行么？<br>我感觉也是可以的，都是根据不同的type去创建不同的对象，也都是继承或实现同一父类或接口","like_count":0},{"had_liked":false,"id":285314,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1616736104,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616736104","product_id":100039001,"comment_content":"思考题：我觉得StringBuilder没有用到建造者模式，没有根据不同类型创建定制化的对象，仅仅是一直append拼接而已","like_count":0},{"had_liked":false,"id":247847,"user_name":"龙猫","can_delete":false,"product_type":"c1","uid":1112490,"ip_address":"","ucode":"FD726CC969EF9C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/aa/3e80212e.jpg","comment_is_top":false,"comment_ctime":1599890355,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599890355","product_id":100039001,"comment_content":"从AbstractStringBuilder的语法结构以及可以定制化生成对象的角度来说是建造着模式","like_count":0},{"had_liked":false,"id":236801,"user_name":"lengrongfu","can_delete":false,"product_type":"c1","uid":1494681,"ip_address":"","ucode":"FD6F35CA561E0B","user_header":"https://static001.geekbang.org/account/avatar/00/16/ce/99/447c33d4.jpg","comment_is_top":false,"comment_ctime":1595552953,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595552953","product_id":100039001,"comment_content":"StringBuilder使用了建造者模式，建造者模式有两种创建方式，一种是单独创建外部类，一种是使用内部类，builder使用的是外部创建，功能上来说它是为了创建复杂对象string的增强。所以是符合建造者模式的。","like_count":0},{"had_liked":false,"id":223378,"user_name":"Geek_e6159b","can_delete":false,"product_type":"c1","uid":1576240,"ip_address":"","ucode":"0684569F9B114D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLlibCGekRp9bxJ3dGfOWghhNVdF771ejzwqKnicKFBpmGuutwNGF3HGZz7KEEz2mdvPckibReRsVtDw/132","comment_is_top":false,"comment_ctime":1591077428,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591077428","product_id":100039001,"comment_content":"类的命名与代码结构上像，但是设计意图与使用场景不是构建者模式。","like_count":0},{"had_liked":false,"id":220605,"user_name":"vic","can_delete":false,"product_type":"c1","uid":1258236,"ip_address":"","ucode":"6C59A40DF9310A","user_header":"https://static001.geekbang.org/account/avatar/00/13/32/fc/5d901185.jpg","comment_is_top":false,"comment_ctime":1590293352,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590293352","product_id":100039001,"comment_content":"利用了建造者模式的思想","like_count":0},{"had_liked":false,"id":218861,"user_name":"Zexho","can_delete":false,"product_type":"c1","uid":1430343,"ip_address":"","ucode":"ADEB6624E29893","user_header":"https://static001.geekbang.org/account/avatar/00/15/d3/47/25ec564c.jpg","comment_is_top":false,"comment_ctime":1589888108,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589888108","product_id":100039001,"comment_content":"我觉得不算<br>从出发点来说，sb的append方法的目的不是为了解决”类的复杂创建“这个点，而只是单纯的追加字符。","like_count":0},{"had_liked":false,"id":217568,"user_name":"SIGHOR","can_delete":false,"product_type":"c1","uid":1439360,"ip_address":"","ucode":"411F85A8FD3DE1","user_header":"https://static001.geekbang.org/account/avatar/00/15/f6/80/830de85d.jpg","comment_is_top":false,"comment_ctime":1589534970,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1589534970","product_id":100039001,"comment_content":"私以为，工厂模式是选择披萨的类型，建造者模式是某种类型的披萨中的食材是多放还是少放还是不放","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509547,"discussion_content":"可以看看我对其他人的回复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606701392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}