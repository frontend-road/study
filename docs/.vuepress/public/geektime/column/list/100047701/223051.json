{"id":223051,"title":"14 | 文件IO：实现高效正确的文件读写并非易事","content":"<p>你好，我是朱晔。今天，我们来聊聊如何实现高效、正确的文件操作。</p><p>随着数据库系统的成熟和普及，需要直接做文件IO操作的需求越来越少，这就导致我们对相关API不够熟悉，以至于遇到类似文件导出、三方文件对账等需求时，只能临时抱佛脚，随意搜索一些代码完成需求，出现性能问题或者Bug后不知从何处入手。</p><p>今天这篇文章，我就会从字符编码、缓冲区和文件句柄释放这3个常见问题出发，和你分享如何解决与文件操作相关的性能问题或者Bug。如果你对文件操作相关的API不够熟悉，可以查看<a href=\"https://docs.oracle.com/javase/tutorial/essential/io/\">Oracle官网的介绍</a>。</p><h2>文件读写需要确保字符编码一致</h2><p>有一个项目需要读取三方的对账文件定时对账，原先一直是单机处理的，没什么问题。后来为了提升性能，使用双节点同时处理对账，每一个节点处理部分对账数据，但新增的节点在处理文件中中文的时候总是读取到乱码。</p><p>程序代码都是一致的，为什么老节点就不会有问题呢？我们知道，这很可能是写代码时没有注意编码问题导致的。接下来，我们就分析下这个问题吧。</p><p>为模拟这个场景，我们使用GBK编码把“你好hi”写入一个名为hello.txt的文本文件，然后直接以字节数组形式读取文件内容，转换为十六进制字符串输出到日志中：</p><!-- [[[read_end]]] --><pre><code>Files.deleteIfExists(Paths.get(&quot;hello.txt&quot;));\nFiles.write(Paths.get(&quot;hello.txt&quot;), &quot;你好hi&quot;.getBytes(Charset.forName(&quot;GBK&quot;)));\nlog.info(&quot;bytes:{}&quot;, Hex.encodeHexString(Files.readAllBytes(Paths.get(&quot;hello.txt&quot;))).toUpperCase());\n</code></pre><p>输出如下：</p><pre><code>13:06:28.955 [main] INFO org.geekbang.time.commonmistakes.io.demo3.FileBadEncodingIssueApplication - bytes:C4E3BAC36869\n</code></pre><p>虽然我们打开文本文件时看到的是“你好hi”，但不管是什么文字，计算机中都是按照一定的规则将其以二进制保存的。这个规则就是字符集，字符集枚举了所有支持的字符映射成二进制的映射表。在处理文件读写的时候，如果是在字节层面进行操作，那么不会涉及字符编码问题；而如果需要在字符层面进行读写的话，就需要明确字符的编码方式也就是字符集了。</p><p>当时出现问题的文件读取代码是这样的：</p><pre><code>char[] chars = new char[10];\nString content = &quot;&quot;;\ntry (FileReader fileReader = new FileReader(&quot;hello.txt&quot;)) {\n    int count;\n    while ((count = fileReader.read(chars)) != -1) {\n        content += new String(chars, 0, count);\n    }\n}\nlog.info(&quot;result:{}&quot;, content);\n</code></pre><p>可以看到，是使用了FileReader类以字符方式进行文件读取，日志中读取出来的“你好”变为了乱码：</p><pre><code>13:06:28.961 [main] INFO org.geekbang.time.commonmistakes.io.demo3.FileBadEncodingIssueApplication - result:���hi\n</code></pre><p>显然，这里并没有指定以什么字符集来读取文件中的字符。查看<a href=\"https://docs.oracle.com/javase/8/docs/api/java/io/FileReader.html\">JDK文档</a>可以发现，<strong>FileReader是以当前机器的默认字符集来读取文件的</strong>，如果希望指定字符集的话，需要直接使用InputStreamReader和FileInputStream。</p><p>到这里我们就明白了，FileReader虽然方便但因为使用了默认字符集对环境产生了依赖，这就是为什么老的机器上程序可以正常运作，在新节点上读取中文时却产生了乱码。</p><p>那，怎么确定当前机器的默认字符集呢？写一段代码输出当前机器的默认字符集，以及UTF-8方式编码的“你好hi”的十六进制字符串：</p><pre><code>log.info(&quot;charset: {}&quot;, Charset.defaultCharset());\nFiles.write(Paths.get(&quot;hello2.txt&quot;), &quot;你好hi&quot;.getBytes(Charsets.UTF_8));\nlog.info(&quot;bytes:{}&quot;, Hex.encodeHexString(Files.readAllBytes(Paths.get(&quot;hello2.txt&quot;))).toUpperCase());\n</code></pre><p>输出结果如下：</p><pre><code>13:06:28.961 [main] INFO org.geekbang.time.commonmistakes.io.demo3.FileBadEncodingIssueApplication - charset: UTF-8\n13:06:28.962 [main] INFO org.geekbang.time.commonmistakes.io.demo3.FileBadEncodingIssueApplication - bytes:E4BDA0E5A5BD6869\n</code></pre><p>可以看到，当前机器默认字符集是UTF-8，当然无法读取GBK编码的汉字。UTF-8编码的“你好”的十六进制是E4BDA0E5A5BD，每一个汉字需要三个字节；而GBK编码的汉字，每一个汉字两个字节。字节长度都不一样，以GBK编码后保存的汉字，以UTF8进行解码读取，必然不会成功。</p><p>定位到问题后，修复就很简单了。按照文档所说，直接使用FileInputStream拿文件流，然后使用InputStreamReader读取字符流，并指定字符集为GBK：</p><pre><code>private static void right1() throws IOException {\n    char[] chars = new char[10];\n    String content = &quot;&quot;;\n    try (FileInputStream fileInputStream = new FileInputStream(&quot;hello.txt&quot;);\n        InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream, Charset.forName(&quot;GBK&quot;))) {\n        int count;\n        while ((count = inputStreamReader.read(chars)) != -1) {\n            content += new String(chars, 0, count);\n        }\n    }\n    log.info(&quot;result: {}&quot;, content);\n}\n</code></pre><p>从日志中看到，修复后的代码正确读取到了“你好Hi”。</p><pre><code>13:06:28.963 [main] INFO org.geekbang.time.commonmistakes.io.demo3.FileBadEncodingIssueApplication - result: 你好hi\n</code></pre><p>如果你觉得这种方式比较麻烦的话，使用JDK1.7推出的Files类的readAllLines方法，可以很方便地用一行代码完成文件内容读取：</p><pre><code>log.info(&quot;result: {}&quot;, Files.readAllLines(Paths.get(&quot;hello.txt&quot;), Charset.forName(&quot;GBK&quot;)).stream().findFirst().orElse(&quot;&quot;));\n</code></pre><p><strong>但这种方式有个问题是，读取超出内存大小的大文件时会出现OOM</strong>。为什么呢？</p><p>打开readAllLines方法的源码可以看到，readAllLines读取文件所有内容后，放到一个List&lt;String&gt;中返回，如果内存无法容纳这个List，就会OOM：</p><pre><code>public static List&lt;String&gt; readAllLines(Path path, Charset cs) throws IOException {\n    try (BufferedReader reader = newBufferedReader(path, cs)) {\n        List&lt;String&gt; result = new ArrayList&lt;&gt;();\n        for (;;) {\n            String line = reader.readLine();\n            if (line == null)\n                break;\n            result.add(line);\n        }\n        return result;\n    }\n}\n</code></pre><p>那么，有没有办法实现按需的流式读取呢？比如，需要消费某行数据时再读取，而不是把整个文件一次性读取到内存？</p><p>当然有，解决方案就是File类的lines方法。接下来，我就与你说说使用lines方法时需要注意的一些问题。</p><h2>使用Files类静态方法进行文件操作注意释放文件句柄</h2><p>与readAllLines方法返回List&lt;String&gt;不同，lines方法返回的是Stream&lt;String&gt;。这，使得我们在需要时可以不断读取、使用文件中的内容，而不是一次性地把所有内容都读取到内存中，因此避免了OOM。</p><p>接下来，我通过一段代码测试一下。我们尝试读取一个1亿1万行的文件，文件占用磁盘空间超过4GB。如果使用-Xmx512m -Xms512m启动JVM控制最大堆内存为512M的话，肯定无法一次性读取这样的大文件，但通过Files.lines方法就没问题。</p><p>在下面的代码中，首先输出这个文件的大小，然后计算读取20万行数据和200万行数据的耗时差异，最后逐行读取文件，统计文件的总行数：</p><pre><code>//输出文件大小\nlog.info(&quot;file size:{}&quot;, Files.size(Paths.get(&quot;test.txt&quot;)));\nStopWatch stopWatch = new StopWatch();\nstopWatch.start(&quot;read 200000 lines&quot;);\n//使用Files.lines方法读取20万行数据\nlog.info(&quot;lines {}&quot;, Files.lines(Paths.get(&quot;test.txt&quot;)).limit(200000).collect(Collectors.toList()).size());\nstopWatch.stop();\nstopWatch.start(&quot;read 2000000 lines&quot;);\n//使用Files.lines方法读取200万行数据\nlog.info(&quot;lines {}&quot;, Files.lines(Paths.get(&quot;test.txt&quot;)).limit(2000000).collect(Collectors.toList()).size());\nstopWatch.stop();\nlog.info(stopWatch.prettyPrint());\nAtomicLong atomicLong = new AtomicLong();\n//使用Files.lines方法统计文件总行数\nFiles.lines(Paths.get(&quot;test.txt&quot;)).forEach(line-&gt;atomicLong.incrementAndGet());\nlog.info(&quot;total lines {}&quot;, atomicLong.get());\n</code></pre><p>输出结果如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/29/77/29ee0fd687642ed87badaa96f9bdfd77.png?wh=3092*532\" alt=\"\"></p><p>可以看到，实现了全文件的读取、统计了整个文件的行数，并没有出现OOM；读取200万行数据耗时760ms，读取20万行数据仅需267ms。这些都可以说明，File.lines方法并不是一次性读取整个文件的，而是按需读取。</p><p>到这里，你觉得这段代码有什么问题吗？</p><p>问题在于读取完文件后没有关闭。我们通常会认为静态方法的调用不涉及资源释放，因为方法调用结束自然代表资源使用完成，由API释放资源，但对于Files类的一些返回Stream的方法并不是这样。这，是一个很容易被忽略的严重问题。</p><p>我就曾遇到过一个案例：程序在生产上运行一段时间后就会出现too many files的错误，我们想当然地认为是OS设置的最大文件句柄太小了，就让运维放开这个限制，但放开后还是会出现这样的问题。经排查发现，其实是文件句柄没有释放导致的，问题就出在Files.lines方法上。</p><p>我们来重现一下这个问题，随便写入10行数据到一个demo.txt文件中：</p><pre><code>Files.write(Paths.get(&quot;demo.txt&quot;),\nIntStream.rangeClosed(1, 10).mapToObj(i -&gt; UUID.randomUUID().toString()).collect(Collectors.toList())\n, UTF_8, CREATE, TRUNCATE_EXISTING);\n</code></pre><p>然后使用Files.lines方法读取这个文件100万次，每读取一行计数器+1：</p><pre><code>LongAdder longAdder = new LongAdder();\nIntStream.rangeClosed(1, 1000000).forEach(i -&gt; {\n    try {\n        Files.lines(Paths.get(&quot;demo.txt&quot;)).forEach(line -&gt; longAdder.increment());\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n});\nlog.info(&quot;total : {}&quot;, longAdder.longValue());\t\n</code></pre><p>运行后马上可以在日志中看到如下错误：</p><pre><code>java.nio.file.FileSystemException: demo.txt: Too many open files\nat sun.nio.fs.UnixException.translateToIOException(UnixException.java:91)\nat sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:102)\nat sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:107)\n</code></pre><p>使用lsof命令查看进程打开的文件，可以看到打开了1万多个demo.txt：</p><pre><code>lsof -p 63937\n...\njava    63902 zhuye *238r   REG                1,4      370         12934160647 /Users/zhuye/Documents/common-mistakes/demo.txt\njava    63902 zhuye *239r   REG                1,4      370         12934160647 /Users/zhuye/Documents/common-mistakes/demo.txt\n...\n\nlsof -p 63937 | grep demo.txt | wc -l\n   10007\n</code></pre><p><strong>其实，在<a href=\"https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html\">JDK文档</a>中有提到，注意使用try-with-resources方式来配合，确保流的close方法可以调用释放资源。</strong></p><p>这也很容易理解，使用流式处理，如果不显式地告诉程序什么时候用完了流，程序又如何知道呢，它也不能帮我们做主何时关闭文件。</p><p>修复方式很简单，使用try来包裹Stream即可：</p><pre><code>LongAdder longAdder = new LongAdder();\nIntStream.rangeClosed(1, 1000000).forEach(i -&gt; {\n    try (Stream&lt;String&gt; lines = Files.lines(Paths.get(&quot;demo.txt&quot;))) {\n        lines.forEach(line -&gt; longAdder.increment());\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n});\nlog.info(&quot;total : {}&quot;, longAdder.longValue());\n</code></pre><p>修改后的代码不再出现错误日志，因为读取了100万次包含10行数据的文件，所以最终正确输出了1000万：</p><pre><code>14:19:29.410 [main] INFO org.geekbang.time.commonmistakes.io.demo2.FilesStreamOperationNeedCloseApplication - total : 10000000\n</code></pre><p>查看lines方法源码可以发现，Stream的close注册了一个回调，来关闭BufferedReader进行资源释放：</p><pre><code>public static Stream&lt;String&gt; lines(Path path, Charset cs) throws IOException {\n    BufferedReader br = Files.newBufferedReader(path, cs);\n    try {\n        return br.lines().onClose(asUncheckedRunnable(br));\n    } catch (Error|RuntimeException e) {\n        try {\n            br.close();\n        } catch (IOException ex) {\n            try {\n                e.addSuppressed(ex);\n            } catch (Throwable ignore) {}\n        }\n        throw e;\n    }\n}\n\nprivate static Runnable asUncheckedRunnable(Closeable c) {\n    return () -&gt; {\n        try {\n            c.close();\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    };\n}\n</code></pre><p>从命名上可以看出，使用BufferedReader进行字符流读取时，用到了缓冲。这里缓冲Buffer的意思是，使用一块内存区域作为直接操作的中转。</p><p>比如，读取文件操作就是一次性读取一大块数据（比如8KB）到缓冲区，后续的读取可以直接从缓冲区返回数据，而不是每次都直接对应文件IO。写操作也是类似。如果每次写几十字节到文件都对应一次IO操作，那么写一个几百兆的大文件可能就需要千万次的IO操作，耗时会非常久。</p><p>接下来，我就通过几个实验，和你说明使用缓冲Buffer的重要性，并对比下不同使用方式的文件读写性能，来帮助你用对、用好Buffer。</p><h2>注意读写文件要考虑设置缓冲区</h2><p>我曾遇到过这么一个案例，一段先进行文件读入再简单处理后写入另一个文件的业务代码，由于开发人员使用了单字节的读取写入方式，导致执行得巨慢，业务量上来后需要数小时才能完成。</p><p>我们来模拟一下相关实现。创建一个文件随机写入100万行数据，文件大小在35MB左右：</p><pre><code>Files.write(Paths.get(&quot;src.txt&quot;),\nIntStream.rangeClosed(1, 1000000).mapToObj(i -&gt; UUID.randomUUID().toString()).collect(Collectors.toList())\n, UTF_8, CREATE, TRUNCATE_EXISTING);\n</code></pre><p>当时开发人员写的文件处理代码大概是这样的：使用FileInputStream获得一个文件输入流，然后调用其read方法每次读取一个字节，最后通过一个FileOutputStream文件输出流把处理后的结果写入另一个文件。</p><p>为了简化逻辑便于理解，这里我们不对数据进行处理，直接把原文件数据写入目标文件，相当于文件复制：</p><pre><code>private static void perByteOperation() throws IOException {\n    try (FileInputStream fileInputStream = new FileInputStream(&quot;src.txt&quot;);\n         FileOutputStream fileOutputStream = new FileOutputStream(&quot;dest.txt&quot;)) {\n        int i;\n        while ((i = fileInputStream.read()) != -1) {\n            fileOutputStream.write(i);\n        }\n    }\n}\n</code></pre><p>这样的实现，复制一个35MB的文件居然耗时190秒。</p><p><strong>显然，每读取一个字节、每写入一个字节都进行一次IO操作，代价太大了</strong>。解决方案就是，考虑使用缓冲区作为过渡，一次性从原文件读取一定数量的数据到缓冲区，一次性写入一定数量的数据到目标文件。</p><p>改良后，使用100字节作为缓冲区，使用FileInputStream的byte[]的重载来一次性读取一定字节的数据，同时使用FileOutputStream的byte[]的重载实现一次性从缓冲区写入一定字节的数据到文件：</p><pre><code>private static void bufferOperationWith100Buffer() throws IOException {\n    try (FileInputStream fileInputStream = new FileInputStream(&quot;src.txt&quot;);\n         FileOutputStream fileOutputStream = new FileOutputStream(&quot;dest.txt&quot;)) {\n        byte[] buffer = new byte[100];\n        int len = 0;\n        while ((len = fileInputStream.read(buffer)) != -1) {\n            fileOutputStream.write(buffer, 0, len);\n        }\n    }\n}\n</code></pre><p>仅仅使用了100个字节的缓冲区作为过渡，完成35M文件的复制耗时缩短到了26秒，是无缓冲时性能的7倍；如果把缓冲区放大到1000字节，耗时可以进一步缩短到342毫秒。可以看到，<strong>在进行文件IO处理的时候，使用合适的缓冲区可以明显提高性能</strong>。</p><p>你可能会说，实现文件读写还要自己new一个缓冲区出来，太麻烦了，不是有一个BufferedInputStream和BufferedOutputStream可以实现输入输出流的缓冲处理吗？</p><p>是的，它们在内部实现了一个默认8KB大小的缓冲区。但是，在使用BufferedInputStream和BufferedOutputStream时，我还是建议你再使用一个缓冲进行读写，不要因为它们实现了内部缓冲就进行逐字节的操作。</p><p>接下来，我写一段代码比较下使用下面三种方式读写一个字节的性能：</p><ul>\n<li>直接使用BufferedInputStream和BufferedOutputStream；</li>\n<li>额外使用一个8KB缓冲，使用BufferedInputStream和BufferedOutputStream；</li>\n<li>直接使用FileInputStream和FileOutputStream，再使用一个8KB的缓冲。</li>\n</ul><pre><code>//使用BufferedInputStream和BufferedOutputStream\nprivate static void bufferedStreamByteOperation() throws IOException {\n   try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(&quot;src.txt&quot;));\n        BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(&quot;dest.txt&quot;))) {\n        int i;\n        while ((i = bufferedInputStream.read()) != -1) {\n            bufferedOutputStream.write(i);\n        }\n    }\n}\n//额外使用一个8KB缓冲，再使用BufferedInputStream和BufferedOutputStream\nprivate static void bufferedStreamBufferOperation() throws IOException {\n    try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(&quot;src.txt&quot;));\n         BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(&quot;dest.txt&quot;))) {\n        byte[] buffer = new byte[8192];\n        int len = 0;\n        while ((len = bufferedInputStream.read(buffer)) != -1) {\n            bufferedOutputStream.write(buffer, 0, len);\n        }\n    }\n}\n//直接使用FileInputStream和FileOutputStream，再使用一个8KB的缓冲\nprivate static void largerBufferOperation() throws IOException {\n    try (FileInputStream fileInputStream = new FileInputStream(&quot;src.txt&quot;);\n        FileOutputStream fileOutputStream = new FileOutputStream(&quot;dest.txt&quot;)) {\n        byte[] buffer = new byte[8192];\n        int len = 0;\n        while ((len = fileInputStream.read(buffer)) != -1) {\n            fileOutputStream.write(buffer, 0, len);\n        }\n    }\n}\n</code></pre><p>结果如下：</p><pre><code>---------------------------------------------\nns         %     Task name\n---------------------------------------------\n1424649223  086%  bufferedStreamByteOperation\n117807808  007%  bufferedStreamBufferOperation\n112153174  007%  largerBufferOperation\n</code></pre><p>可以看到，第一种方式虽然使用了缓冲流，但逐字节的操作因为方法调用次数实在太多还是慢，耗时1.4秒；后面两种方式的性能差不多，耗时110毫秒左右。虽然第三种方式没有使用缓冲流，但使用了8KB大小的缓冲区，和缓冲流默认的缓冲区大小相同。</p><p>看到这里，你可能会疑惑了，既然这样使用BufferedInputStream和BufferedOutputStream有什么意义呢？</p><p>其实，这里我是为了演示所以示例三使用了固定大小的缓冲区，但在实际代码中每次需要读取的字节数很可能不是固定的，有的时候读取几个字节，有的时候读取几百字节，这个时候有一个固定大小较大的缓冲，也就是使用BufferedInputStream和BufferedOutputStream做为后备的稳定的二次缓冲，就非常有意义了。</p><p>最后我要补充说明的是，对于类似的文件复制操作，如果希望有更高性能，可以使用FileChannel的transfreTo方法进行流的复制。在一些操作系统（比如高版本的Linux和UNIX）上可以实现DMA（直接内存访问），也就是数据从磁盘经过总线直接发送到目标文件，无需经过内存和CPU进行数据中转：</p><pre><code>private static void fileChannelOperation() throws IOException {\n    FileChannel in = FileChannel.open(Paths.get(&quot;src.txt&quot;), StandardOpenOption.READ);\n    FileChannel out = FileChannel.open(Paths.get(&quot;dest.txt&quot;), CREATE, WRITE);\n    in.transferTo(0, in.size(), out);\n}\n</code></pre><p>你可以通过<a href=\"https://developer.ibm.com/articles/j-zerocopy/\">这篇文章</a>，了解transferTo方法的更多细节。</p><p>在测试FileChannel性能的同时，我再运行一下这一小节中的所有实现，比较一下读写35MB文件的耗时。</p><pre><code>---------------------------------------------\nns         %     Task name\n---------------------------------------------\n183673362265  098%  perByteOperation\n2034504694  001%  bufferOperationWith100Buffer\n749967898  000%  bufferedStreamByteOperation\n110602155  000%  bufferedStreamBufferOperation\n114542834  000%  largerBufferOperation\n050068602  000%  fileChannelOperation\n</code></pre><p>可以看到，最慢的是单字节读写文件流的方式，耗时183秒，最快的是FileChannel.transferTo方式进行流转发的方式，耗时50毫秒。两者耗时相差达到3600倍！</p><h2>重点回顾</h2><p>今天，我通过三个案例和你分享了文件读写操作中最重要的几个方面。</p><p>第一，如果需要读写字符流，那么需要确保文件中字符的字符集和字符流的字符集是一致的，否则可能产生乱码。</p><p>第二，使用Files类的一些流式处理操作，注意使用try-with-resources包装Stream，确保底层文件资源可以释放，避免产生too many open files的问题。</p><p>第三，进行文件字节流操作的时候，一般情况下不考虑进行逐字节操作，使用缓冲区进行批量读写减少IO次数，性能会好很多。一般可以考虑直接使用缓冲输入输出流BufferedXXXStream，追求极限性能的话可以考虑使用FileChannel进行流转发。</p><p>最后我要强调的是，文件操作因为涉及操作系统和文件系统的实现，JDK并不能确保所有IO API在所有平台的逻辑一致性，代码迁移到新的操作系统或文件系统时，要重新进行功能测试和性能测试。</p><p>今天用到的代码，我都放在了GitHub上，你可以点击<a href=\"https://github.com/JosephZhu1983/java-common-mistakes\">这个链接</a>查看。</p><h2>思考与讨论</h2><ol>\n<li>Files.lines方法进行流式处理，需要使用try-with-resources进行资源释放。那么，使用Files类中其他返回Stream包装对象的方法进行流式处理，比如newDirectoryStream方法返回DirectoryStream&lt;Path&gt;，list、walk和find方法返回Stream&lt;Path&gt;，也同样有资源释放问题吗？</li>\n<li>Java的File类和Files类提供的文件复制、重命名、删除等操作，是原子性的吗？</li>\n</ol><p>对于文件操作，你还遇到过什么坑吗？我是朱晔，欢迎在评论区与我留言分享你的想法，也欢迎你把这篇文章分享给你的朋友或同事，一起交流。</p>","neighbors":{"left":{"article_title":"13 | 日志：日志记录真没你想象的那么简单","id":220307},"right":{"article_title":"15 | 序列化：一来一回你还是原来的你吗？","id":223111}},"comments":[{"had_liked":false,"id":205837,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1586745646,"is_pvip":true,"replies":[{"id":"76922","content":"👍🏻👍🏻👍🏻👍🏻","user_name":"作者回复","comment_id":205837,"uid":"1001470","ip_address":"","utype":1,"ctime":1586751474,"user_name_real":"朱晔"}],"discussion_count":7,"race_medal":0,"score":"302234456366","product_id":100047701,"comment_content":"今天算是打开了一片新的天地，因为日常的开发设计文件的不太多，竟然不知道有Files这样的牛逼操作，之前对于JDK相关的NIO关注的也不多，真的是打开了一闪窗。<br>先说下FileChannel 的 transfreTo 方法，这个方法出现在眼前很多次，因为之前看Kafka为什么吞吐量达的原因的时候，提到了2点：批处理思想和零拷贝；<br>批处理思想：就是对于Kafka内部很多地方来说，不是消息来了就发送，而是有攒一波发送一次，这样对于吞吐量有极大的提升，对于需要实时处理的情况，Kafka就不是很适合的原因；<br>零拷贝：Kafka快的另外一个原因是零拷贝，避免了内存态到内核态以及网络的拷贝，直接读取文件，发送到网络出去，零拷贝的含义不是没有拷贝，而是没有用户态到核心态的拷贝。<br>而在提到零拷贝的实现时，Java中说的就是FileChannel 的 transfreTo 方法。<br><br><br>然后回答下问题：<br>第一个问题：<br>Files的相关方法文档描述：<br>When not using the try-with-resources construct, then directory stream&#39;s close method should be invoked after iteration is completed so as to free any resources held for the open directory.<br>所以是需要手动关闭的。<br><br>第二个问题：<br>没有原子操作，因此是线程不安全的。个人理解，其实即使加上了原子操作，也是鸡肋，不实用的很，原因是：File 类和 Files的相关操作，其实都是调用操作系统的文件系统操作，这个文件除了JVM操作外，可能别的也在操作，因此还不如不保证，完全基于操作系统的文件系统去保证相关操作的正确性。","like_count":71,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491596,"discussion_content":"👍🏻👍🏻👍🏻👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586751474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":2881872,"avatar":"","nickname":"Geek_e0f8e6","note":"","ucode":"BC30B1694677FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":552783,"discussion_content":"借楼反馈个坑, 在开发中试图用Files.lines方法直接读取resources下json文件内容, 本地没毛病, 部署上线读不到文件, 解决方法: 改用IOUtils.toString读InputStream \n这坑很坑..","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645596157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":491596,"ip_address":""},"score":552783,"extra":""},{"author":{"id":2881872,"avatar":"","nickname":"Geek_e0f8e6","note":"","ucode":"BC30B1694677FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":552784,"discussion_content":"https://www.renfei.net/posts/1003293 相关帖子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645596261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":491596,"ip_address":""},"score":552784,"extra":""}]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308423,"discussion_content":"“攒一波发送一次”听着好耳熟，哈哈","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600949104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1027789,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ae/cd/3bffed26.jpg","nickname":"kitten","note":"","ucode":"E451DE087CB7CE","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377863,"discussion_content":"感觉大佬也很牛逼哈。拜膜","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622916112,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1114878,"avatar":"https://static001.geekbang.org/account/avatar/00/11/02/fe/d539b96b.jpg","nickname":"曹翔","note":"","ucode":"B4D8B42DFB535C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375384,"discussion_content":"妙啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621600477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1391748,"avatar":"https://static001.geekbang.org/account/avatar/00/15/3c/84/608f679b.jpg","nickname":"连边","note":"","ucode":"54B5DA38449728","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333541,"discussion_content":"妙呀。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607560636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206045,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1586779549,"is_pvip":false,"replies":[{"id":"76958","content":"不错","user_name":"作者回复","comment_id":206045,"uid":"1001470","ip_address":"","utype":1,"ctime":1586784224,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"61716321693","product_id":100047701,"comment_content":"这篇专栏内容不算多，但是感觉可扩展的地方很多。<br><br>我认为：读写字符流乱码，其实本质上在于环境不一致的问题。其实跟日志路径之类的问题思路一致。服务器保存日志，如果配置绝对路径，C盘下的log文件夹。等部署到服务器上就会出错。除了针对不同的环境使用不同的配置，还可以尝试使用相对路径，亦或者将路径以存数据库的方式持久化。其实本质上，跟编码格式的处理方式一样，尽量屏蔽不同环境之间的差异。<br><br>保证文件流释放，同样也可以延伸。不仅仅是文件流，任何涉及资源占用问题的时候，都需要考虑资源是否可以保证被释放。try-whit-resources来解决IO流，其实同样也应用于各种需要释放资源的场景。<br><br>关于缓冲区，个人理解，一个典型的应用就是数据库的分页查询。如果将所有数据一次查出，不但消耗资源，甚至有可能内存不够。如果一次只查一个，如果需要查询的是几十条数据，频繁进行数据库访问，性能也较差。所以，采取了折中的方案，分页查询，一次仅查出一部分数据。既不会内存溢出，也保证了响应速度。","like_count":14,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491650,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586784224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205490,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1586649499,"is_pvip":false,"replies":[{"id":"76742","content":"不错","user_name":"作者回复","comment_id":205490,"uid":"1001470","ip_address":"","utype":1,"ctime":1586656850,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"53126257051","product_id":100047701,"comment_content":"第一个问题：都间接实现了autoCloseable接口，所以都可以使用try-with-resources进行释放。<br>第二个非原子性，没有锁，也没有异常后的回滚。需要调用方进行事务控制","like_count":12,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491491,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586656850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206731,"user_name":"Geek_3b1096","can_delete":false,"product_type":"c1","uid":1549364,"ip_address":"","ucode":"A6BD92B79B3632","user_header":"","comment_is_top":false,"comment_ctime":1586922976,"is_pvip":false,"replies":[{"id":"77212","content":"不客气，觉得好可以点赞转发","user_name":"作者回复","comment_id":206731,"uid":"1001470","ip_address":"","utype":1,"ctime":1586925211,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"23061759456","product_id":100047701,"comment_content":"谢谢老师详细解说文件操作","like_count":5,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491883,"discussion_content":"不客气，觉得好可以点赞转发","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586925211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205935,"user_name":"汝林外史","can_delete":false,"product_type":"c1","uid":1188906,"ip_address":"","ucode":"3C66C0F0537A99","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/2a/33441e2b.jpg","comment_is_top":false,"comment_ctime":1586760062,"is_pvip":false,"replies":[{"id":"76939","content":"你可能会疑惑了，既然这样使用 BufferedInputStream 和 BufferedOutputStream 有什么意义呢？其实，这里我是为了演示所以示例三使用了固定大小的缓冲区，但在实际代码中每次需要读取的字节数很可能不是固定的，有的时候读取几个字节，有的时候读取几百字节，这个时候有一个固定大小较大的缓冲，也就是使用 BufferedInputStream 和 BufferedOutputStream 做为后备的稳定的二次缓冲，就非常有意义了","user_name":"作者回复","comment_id":205935,"uid":"1001470","ip_address":"","utype":1,"ctime":1586765041,"user_name_real":"朱晔"}],"discussion_count":9,"race_medal":0,"score":"23061596542","product_id":100047701,"comment_content":"BufferedInputStream的二级缓冲什么时候能用到呢？既然需要自己定义一个缓冲，比如2K，那么肯定也是控制一次读取2K，应该不会有读取超过2K的时候吧？","like_count":5,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491619,"discussion_content":"你可能会疑惑了，既然这样使用 BufferedInputStream 和 BufferedOutputStream 有什么意义呢？其实，这里我是为了演示所以示例三使用了固定大小的缓冲区，但在实际代码中每次需要读取的字节数很可能不是固定的，有的时候读取几个字节，有的时候读取几百字节，这个时候有一个固定大小较大的缓冲，也就是使用 BufferedInputStream 和 BufferedOutputStream 做为后备的稳定的二次缓冲，就非常有意义了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586765041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1177931,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f9/4b/5532c234.jpg","nickname":"Messi","note":"","ucode":"04302B9E7F1D75","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300747,"discussion_content":"后备的稳定的二次缓冲，这点不太理解，能举例说明吗？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598254287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1235940,"avatar":"https://static001.geekbang.org/account/avatar/00/12/db/e4/a1b45d79.jpg","nickname":"柳志焕","note":"","ucode":"42375930DC2AA0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1177931,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f9/4b/5532c234.jpg","nickname":"Messi","note":"","ucode":"04302B9E7F1D75","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368224,"discussion_content":"二次缓冲应该是指先放到 BufferedOutputStream 中，然后再放到我们设置的数组中，读取字节很大的话能提高效率。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618625309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":300747,"ip_address":""},"score":368224,"extra":""}]},{"author":{"id":1075267,"avatar":"https://static001.geekbang.org/account/avatar/00/10/68/43/1fe64086.jpg","nickname":"zero_","note":"","ucode":"14D3AD3D997112","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583688,"discussion_content":"难道是在这里：bufferedInputStream.read() 的操作会出现这种情况（有的时候读取几个字节，有的时候读取几百字节）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660294593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1075267,"avatar":"https://static001.geekbang.org/account/avatar/00/10/68/43/1fe64086.jpg","nickname":"zero_","note":"","ucode":"14D3AD3D997112","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583685,"discussion_content":"问题：有的时候读取几个字节，有的时候读取几百字节？\n那不是在第一级缓存里把这个问题规避了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660293896,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2845535,"avatar":"","nickname":"Geek4570","note":"","ucode":"5B682A02535F6C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556393,"discussion_content":"是不是先缓存到大缓存，小缓存再从大缓存读","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647337482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2358947,"avatar":"https://static001.geekbang.org/account/avatar/00/23/fe/a3/414c47cc.jpg","nickname":"旺仔小馒头","note":"","ucode":"45BE8E943C794C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532005,"discussion_content":"这还不如直接写进BuffereadXXXStream中，在中间自己搞一个缓冲多此一举了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637499322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2794250,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/a3/0a/ff42fbdd.jpg","nickname":"东","note":"","ucode":"F468CEFC0DD296","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404332,"discussion_content":"这我也没看懂，BufferedOutputStream是有两次缓存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634289109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308426,"discussion_content":"还是没解释啊，意思是先缓存到小缓存，小缓存放进大缓存，再进行写入文件？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600949530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208067,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1274787,"ip_address":"","ucode":"C233DF1D224EC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","comment_is_top":false,"comment_ctime":1587268043,"is_pvip":true,"replies":[{"id":"77652","content":"感谢认可","user_name":"作者回复","comment_id":208067,"uid":"1001470","ip_address":"","utype":1,"ctime":1587268964,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"14472169931","product_id":100047701,"comment_content":"特别喜欢老师的这种工匠精神，对读者的每一个问题都精心回复","like_count":3,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492329,"discussion_content":"感谢认可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587268964,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208007,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1587254066,"is_pvip":false,"replies":[{"id":"77640","content":"针对你的问题可以看一下http:&#47;&#47;www.ruanyifeng.com&#47;blog&#47;2007&#47;10&#47;ascii_unicode_and_utf-8.html 其中『UTF-8 的编码规则很简单，只有二条』一节就明白了<br>","user_name":"作者回复","comment_id":208007,"uid":"1001470","ip_address":"","utype":1,"ctime":1587257172,"user_name_real":"朱晔"}],"discussion_count":3,"race_medal":0,"score":"14472155954","product_id":100047701,"comment_content":"gbk与utf8区别（本文总结所得）：<br>1、gbk只适合中文编码方式，utf8全世界的编码方式<br>2、对于中文汉字，gbk使用2个字节，utf8使用3个字节；对于英文字母都是1个字节。这种变长编码方式，怎么区分汉字和英文呢？","like_count":3,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492314,"discussion_content":"针对你的问题可以看一下http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html 其中『UTF-8 的编码规则很简单，只有二条』一节就明白了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587257172,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1250907,"avatar":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","nickname":"Monday","note":"","ucode":"77B9BACC783598","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":239341,"discussion_content":"感谢老师推荐的深度好文","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587295017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1542987,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","nickname":"行则将至","note":"","ucode":"DB972F2DF059C4","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394993,"discussion_content":"这篇文章，真心不错。之前对于UTF-8和Unicode没有概念，这次感觉入门了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632156299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205473,"user_name":"eazonshaw","can_delete":false,"product_type":"c1","uid":1493784,"ip_address":"","ucode":"423952F7CEF475","user_header":"https://static001.geekbang.org/account/avatar/00/16/cb/18/4877c08b.jpg","comment_is_top":false,"comment_ctime":1586624917,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14471526805","product_id":100047701,"comment_content":"问题一：<br>newDirectoryStream 方法返回 DirectoryStream方法，查看源码中的描述，该方法返回了文件夹中所有内容的迭代，当在没有使用try-with-resources构造体时，需要要在使用完文件流迭代后进行释放。<br>而list、walk 和 find 方法中，都有对资源进行关闭的操作。","like_count":3},{"had_liked":false,"id":205193,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1586569041,"is_pvip":false,"replies":[{"id":"76681","content":"是，其实我在思考题中也会补充更多正文无法详细阐述的坑","user_name":"作者回复","comment_id":205193,"uid":"1001470","ip_address":"","utype":1,"ctime":1586571710,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"14471470929","product_id":100047701,"comment_content":"第二个问题，不是原子的，所以需要注意，如果 io 异常，可能会出现复制后的文件不完整，文件未删除成功等问题","like_count":3,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491417,"discussion_content":"是，其实我在思考题中也会补充更多正文无法详细阐述的坑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586571710,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240742,"user_name":"LiuHu","can_delete":false,"product_type":"c1","uid":1039768,"ip_address":"","ucode":"284E2025C554BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/dd/98/883c42b4.jpg","comment_is_top":false,"comment_ctime":1597050059,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10186984651","product_id":100047701,"comment_content":"try-with-resources 实际上是 Java 的语法糖，在编译的时候只要返回对象实现了 AutoCloseable 接口，字节码会自动加上调用 close 方法实现资源自动关闭。<br>DirectoryStream&lt;Path&gt; 继承了 Closeable 接口，所以其子类需要实现 close 方法，看了下 UnixDirectoryStream.close 的实现确实关闭了资源， 所以没有资源释放问题。<br>list、walk 和 find 方法返回的 Stream&lt;Path&gt; 都会通过调用父类的 onClose 方法，注册 close 实现到 BaseStream中实现资源关闭，所以也没有资源释放问题。","like_count":2},{"had_liked":false,"id":237399,"user_name":"珅珅君","can_delete":false,"product_type":"c1","uid":1069646,"ip_address":"","ucode":"3700048634C565","user_header":"https://static001.geekbang.org/account/avatar/00/10/52/4e/5150a2ee.jpg","comment_is_top":false,"comment_ctime":1595819722,"is_pvip":false,"replies":[{"id":"87691","content":"先A后B（可能多次）","user_name":"作者回复","comment_id":237399,"uid":"1001470","ip_address":"","utype":1,"ctime":1595826195,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"10185754314","product_id":100047701,"comment_content":"你好，关于BufferedInputStream有一点疑问，如果我构造BufferedInputStream的时候设置缓冲流的大小是1kb，这里缓冲区叫A，但是调用read(byte[])的时候额外用的是8kb缓冲，这里缓冲区叫B，那么读取文件的时候，这两种缓冲的大小的工作流程是什么样的。先B后A还是？","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502404,"discussion_content":"先A后B（可能多次）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595826195,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205187,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1586568585,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10176503177","product_id":100047701,"comment_content":"第一个问题，DirectoryStream 接口继承了 Closeable 接口，而 Closeable 接口继承了 AutoCloseable 接口，都可以使用 try-with-resources 进行资源释放。而 list，walk，find 都是返回 Stream，也都继承了 AutoCloseable 接口，并且可以主动调用 close 方法进行资源释放。","like_count":2},{"had_liked":false,"id":237406,"user_name":"James","can_delete":false,"product_type":"c1","uid":1134861,"ip_address":"","ucode":"48B0F2A334D1C1","user_header":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","comment_is_top":false,"comment_ctime":1595820826,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5890788122","product_id":100047701,"comment_content":"双缓冲的那个还不是很理解。<br>是不是就是有个更大的缓冲区 16k是吧。","like_count":1},{"had_liked":false,"id":223652,"user_name":"Carisy","can_delete":false,"product_type":"c1","uid":1657429,"ip_address":"","ucode":"67E887967347BA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLwTZdUafC5YM7bCASt8icUnoyYfV4hUHulexibDI7B4eaokTxYXHFtoic97DBlCAU9j5Jw4QUuGhyZQ/132","comment_is_top":false,"comment_ctime":1591148786,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5886116082","product_id":100047701,"comment_content":"之前读tomcat不是很理解为啥用了两个chunkbuffer，现在豁然开朗！","like_count":1,"discussions":[{"author":{"id":2052476,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Qq6oLfOTgKzjiculoUDicdv7WoY1iabPfOTumibWeInVP2Mnod9XVPrNSClvIiaLbvtDlIjRnWUNaXcYwREGzlcaDog/132","nickname":"Geek_在下蟑螂王","note":"","ucode":"E1F5BBB5BC5962","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324859,"discussion_content":"呜呜呜。。。我还是不懂。jdk的buffer不是已经限定死了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605182077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205319,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1586591888,"is_pvip":false,"replies":[{"id":"76715","content":"直接放到catch里是可以的，这里我因为修改了wrong所以写成这样了。对于释放资源产生的异常，同样可以在catch中捕获，可以看一下try-with-resources语法糖会翻译成怎么样的代码就理解了。","user_name":"作者回复","comment_id":205319,"uid":"1001470","ip_address":"","utype":1,"ctime":1586604613,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":1,"score":"5881559184","product_id":100047701,"comment_content":"<br>LongAdder longAdder = new LongAdder();<br>IntStream.rangeClosed(1, 1000000).forEach(i -&gt; {<br>    try {<br>        try (Stream&lt;String&gt; lines = Files.lines(Paths.get(&quot;demo.txt&quot;))) {<br>            lines.forEach(line -&gt; longAdder.increment());<br>        }<br>    } catch (IOException e) {<br>        e.printStackTrace();<br>    }<br>});<br>log.info(&quot;total : {}&quot;, longAdder.longValue());<br><br>------------------------------------------------------<br>我一开始还奇怪为啥要两个try，catch放里面不就行了么，想了一下才明白，是为了捕获里面释放资源的异常，相当于捕获finally中的异常。<br><br>两道题都去翻了源码，第一题我觉得也是需要主动释放，Path也算一种fd吧，不太确定；第二题没有看到锁什么的，不是原子性的，不过创建或删除文件，重复处理，操作系统层会报错，但写内容到文件中就需要注意了。","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491447,"discussion_content":"直接放到catch里是可以的，这里我因为修改了wrong所以写成这样了。对于释放资源产生的异常，同样可以在catch中捕获，可以看一下try-with-resources语法糖会翻译成怎么样的代码就理解了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586604613,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205185,"user_name":"小氘","can_delete":false,"product_type":"c1","uid":1622109,"ip_address":"","ucode":"DA55B9A02D9EE0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erPMtAfnQdpx1yOZQ2ic7icqUs3tvibEjUXQMUXKiaakyuIho6k6vmdl46nrdWjXIjPIRg9Pmco00tR5w/132","comment_is_top":false,"comment_ctime":1586568536,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5881535832","product_id":100047701,"comment_content":"老师你好，请问java中哪些资源是需要我们手动释放的？","like_count":1,"discussions":[{"author":{"id":1274117,"avatar":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","nickname":"👽","note":"","ucode":"D313AF941B412D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":230900,"discussion_content":"占用有限资源的场景。\n1，流，2，文件写入占用，3，链接 等。\n关于资源占用，原理可以参考操作系统原理。\n\n一个很简单的例子就是打印机，机器A占有了打印机并开始打印，但是打印过程中A电脑死机了，而打印机又是一直被占用状态。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586779764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1622109,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erPMtAfnQdpx1yOZQ2ic7icqUs3tvibEjUXQMUXKiaakyuIho6k6vmdl46nrdWjXIjPIRg9Pmco00tR5w/132","nickname":"小氘","note":"","ucode":"DA55B9A02D9EE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1274117,"avatar":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","nickname":"👽","note":"","ucode":"D313AF941B412D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":231899,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586836966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":230900,"ip_address":""},"score":231899,"extra":""}]}]},{"had_liked":false,"id":205172,"user_name":"kyl","can_delete":false,"product_type":"c1","uid":1406090,"ip_address":"","ucode":"DBDFD0FEB5A135","user_header":"https://static001.geekbang.org/account/avatar/00/15/74/8a/d5b0cf30.jpg","comment_is_top":false,"comment_ctime":1586564275,"is_pvip":false,"replies":[{"id":"76673","content":"文件解析是指？","user_name":"作者回复","comment_id":205172,"uid":"1001470","ip_address":"","utype":1,"ctime":1586565147,"user_name_real":"朱晔"}],"discussion_count":8,"race_medal":0,"score":"5881531571","product_id":100047701,"comment_content":"又学到了，很棒，朱老师能不能讲讲文件解析的坑呢","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491412,"discussion_content":"文件解析是指？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586565147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":229536,"discussion_content":"导入是指用load data之类导入，避免反复的客户端服务端交互","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586662800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":229535,"discussion_content":"看你需要改善哪块了，改善入库慢还是什么，这个操作可以异步化慢慢在后台处理完成后再发通知。如果要改善慢的问题那么分析一下是哪里慢，解析慢可以多线程甚至分布到多机器解析，入库慢受限于数据库瓶颈除非分库否则也不太好解决，不过还是可以优化的，比如采用批量的insert或者直接把文件传到服务器上让mysql导入","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586662708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1406090,"avatar":"https://static001.geekbang.org/account/avatar/00/15/74/8a/d5b0cf30.jpg","nickname":"kyl","note":"","ucode":"DBDFD0FEB5A135","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":230033,"discussion_content":"是入库慢，谢谢老师！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586703898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":229535,"ip_address":""},"score":230033,"extra":""},{"author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1406090,"avatar":"https://static001.geekbang.org/account/avatar/00/15/74/8a/d5b0cf30.jpg","nickname":"kyl","note":"","ucode":"DBDFD0FEB5A135","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":230614,"discussion_content":"之前做过类似的事情，在数据库IO资源未满的情况下，尽可能的多线程甚至多服务入库，并且一定要批量入库；同时若是未分库，且该表是热点表的情况下，可以使用分表或者表分区避免锁竞争，提高入库速度。\n之前我的场景是分库，根据id获取对应的库，然后进入对应的内存队列（队列已满，写文件系统，保证数据不丢失），然后每个内存队列下面挂一个线程池去多线程入库，为什么要每个库对应一个线程池，是因为有可能某一个库出了问题，导致入库很慢，这种情况下，只会影响该库，不会影响整体。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1586756874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":230033,"ip_address":""},"score":230614,"extra":""}]},{"author":{"id":1406090,"avatar":"https://static001.geekbang.org/account/avatar/00/15/74/8a/d5b0cf30.jpg","nickname":"kyl","note":"","ucode":"DBDFD0FEB5A135","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":229340,"discussion_content":"感谢朱老师回复，说个实际的问题哈，我们生产有500w+数据量的excel文件要导入到数据库，但是解析入库完成需要二三十分钟甚至更久，请问类似问题如何解决呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586620289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1139413,"avatar":"https://static001.geekbang.org/account/avatar/00/11/62/d5/1f5c5ab6.jpg","nickname":"大大大熊myeh","note":"","ucode":"4832C2E7CEB151","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1406090,"avatar":"https://static001.geekbang.org/account/avatar/00/15/74/8a/d5b0cf30.jpg","nickname":"kyl","note":"","ucode":"DBDFD0FEB5A135","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":229347,"discussion_content":"是说解析文件时间久？可以解析完成后发消息通知用户。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586620493,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":229340,"ip_address":""},"score":229347,"extra":""},{"author":{"id":1406090,"avatar":"https://static001.geekbang.org/account/avatar/00/15/74/8a/d5b0cf30.jpg","nickname":"kyl","note":"","ucode":"DBDFD0FEB5A135","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1139413,"avatar":"https://static001.geekbang.org/account/avatar/00/11/62/d5/1f5c5ab6.jpg","nickname":"大大大熊myeh","note":"","ucode":"4832C2E7CEB151","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":230039,"discussion_content":"是的，入库io频繁，现在是异步处理的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586704024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":229347,"ip_address":""},"score":230039,"extra":""}]}]},{"had_liked":false,"id":357741,"user_name":"芒果少侠","can_delete":false,"product_type":"c1","uid":1350159,"ip_address":"广东","ucode":"98D0BBB52BB80F","user_header":"https://static001.geekbang.org/account/avatar/00/14/9a/0f/da7ed75a.jpg","comment_is_top":false,"comment_ctime":1663592777,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1663592777","product_id":100047701,"comment_content":"打卡学习记录，今天提到的第一个问题，经常有同事踩到。","like_count":0},{"had_liked":false,"id":336504,"user_name":"秃如其来","can_delete":false,"product_type":"c1","uid":2357964,"ip_address":"","ucode":"9130CE773F31B3","user_header":"https://static001.geekbang.org/account/avatar/00/23/fa/cc/d4b3ce87.jpg","comment_is_top":false,"comment_ctime":1646191850,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646191850","product_id":100047701,"comment_content":"AtomicLong atomicLong = new AtomicLong()；<br>Files.lines(Paths.get(&quot;test.txt&quot;)).forEach(line-&gt;atomicLong.incrementAndGet());<br>long count = atomicLong.get()<br>可以用下面的代码替代么？<br>long count = Files.lines(Paths.get(&quot;test.txt&quot;)).count();","like_count":0},{"had_liked":false,"id":295268,"user_name":"晨曦","can_delete":false,"product_type":"c1","uid":2444694,"ip_address":"","ucode":"94993724767BB8","user_header":"https://static001.geekbang.org/account/avatar/00/25/4d/96/c1835e16.jpg","comment_is_top":false,"comment_ctime":1622339991,"is_pvip":false,"replies":[{"id":"107234","content":"会 但有延迟","user_name":"作者回复","comment_id":295268,"uid":"1001470","ip_address":"","utype":1,"ctime":1622437451,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":1,"score":"1622339991","product_id":100047701,"comment_content":"没有释放连接句炳的对象，不是应该会被垃圾回收吗？","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521017,"discussion_content":"会 但有延迟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622437451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":278129,"user_name":"东谷大菠萝","can_delete":false,"product_type":"c1","uid":2007690,"ip_address":"","ucode":"057FF5437438D8","user_header":"https://static001.geekbang.org/account/avatar/00/1e/a2/8a/31fcaf13.jpg","comment_is_top":false,"comment_ctime":1612772371,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612772371","product_id":100047701,"comment_content":"老师，关于try-with-resources，我一直觉得很鸡肋...有一种情况一直不知道怎么处理：<br>    public static &lt;T&gt; List&lt;T&gt; deepCopy(List&lt;T&gt; src) throws IOException, ClassNotFoundException {<br><br>        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();<br>        ObjectOutputStream out = new ObjectOutputStream(byteOut);<br>        out.writeObject(src);<br><br>        ByteArrayInputStream byteIn = new ByteArrayInputStream(byteOut.toByteArray());<br>        ObjectInputStream in = new ObjectInputStream(byteIn);<br>        @SuppressWarnings(&quot;unchecked&quot;)<br>        List&lt;T&gt; dest = (List&lt;T&gt;) in.readObject();<br>        return dest;<br>    }<br><br>对于这段代码，我似乎无法把stream的声明提到try()里，因为中间有操作，而后面的stream依赖中间那步操作。","like_count":0},{"had_liked":false,"id":212528,"user_name":"will","can_delete":false,"product_type":"c1","uid":1785448,"ip_address":"","ucode":"6843B14B09192F","user_header":"https://static001.geekbang.org/account/avatar/00/1b/3e/68/c2b2a285.jpg","comment_is_top":false,"comment_ctime":1588142033,"is_pvip":false,"replies":[{"id":"78951","content":"这个问题太宽泛了。。。","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1588145444,"ip_address":"","comment_id":212528,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1588142033","product_id":100047701,"comment_content":"老师，咨询下，一般读取远程文件，需要注意什么～？","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493538,"discussion_content":"这个问题太宽泛了。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588145444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1624872,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJBAeQHMGZXiccGuNllib5TpeMTv2xHia6MlvltJ5BQSBc1u6NpvricUo9dGYtrCLe3pZfSFIZky4mkFg/132","nickname":"lnuwhy","note":"","ucode":"A901D0917DE445","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":547322,"discussion_content":"如果使用sftp读一个远程文件，要下载下来才能用Files.lines这种方法吗  ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642610457,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":493538,"ip_address":""},"score":547322,"extra":""}]}]}]}