{"id":107766,"title":"77 | 常用组件化Target-Action方案","content":"<p><strong>PDF 课件和源代码下载地址：</strong></p><p><a href=\"https://gitee.com/geektime-geekbang/geektime-ios-course\">https://gitee.com/geektime-geekbang/geektime-ios-course</a></p>","comments":[{"had_liked":false,"id":114930,"user_name":"起风了001","can_delete":false,"product_type":"c3","uid":1529929,"ip_address":"","ucode":"8DCDBA40B8CC9F","user_header":"","comment_is_top":false,"comment_ctime":1563434922,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100025901,"comment_content":"很推荐这个课程, 可以让大家用最少的时间快速学习到大厂最新最流行最合理的一些设计理念. 虽然这些知识网上很多地方都有, 但是不全面, 零零散散的, 这个专题等于把知识筛选一遍再汇总起来, 就算有多年开发经验的都值得看一遍~另外花钱学习也会更专心哈哈...对了,视频最后那个使用NSClassFromString获取控制器实例的地方, 只调用了开辟内存的方法, 没调用init方法, 这样可能会有异常.","like_count":7,"discussions":[{"author":{"id":1454691,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEK5icO2A4K7HYTYfQoagTz7VbtgxfS2ibBqLnKVWwQZgsePibZWFvFJEhPT8BtpQSaFx9IEodyp6c0dw/132","nickname":"Geek_jg3r26","note":"","ucode":"7D093ED7273CBE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327178,"discussion_content":"initWithURLString 在这个方法里已经调用了init的初始化。。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605759970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":286145,"user_name":"Geek__2099","can_delete":false,"product_type":"c3","uid":1457784,"ip_address":"","ucode":"01444B60F18A66","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep8unibCib9rdHib0D6Rf6TjecPQu1yic0G9sjzriczlTcwGHP6DaxtEmHyN7pCrD9zV7OSegyf7EUBvaA/132","comment_is_top":false,"comment_ctime":1617168804,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100025901,"comment_content":"耦合，通常表现为头文件的直接或间接的引用，这都导致编译时的依赖。\n当编译时没有任何直接或间接的依赖时，两个类之间实现了解耦。\n一个类通过字符串名称形态出现在对方类中，本质上是数据流，而非对象流。\n即一个类，通过数据驱动机制，将自己传递给另外一个类，可在去掉编译时依赖关系的同时，实现了运行时业务上的协作。\n至于这里具体方法名称，本质上是约定，不属于硬编码，完全可将其参数化，通过配置文件来导流。\n\n","like_count":1},{"had_liked":false,"id":262533,"user_name":"Geek_jg3r26","can_delete":false,"product_type":"c3","uid":1454691,"ip_address":"","ucode":"7D093ED7273CBE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEK5icO2A4K7HYTYfQoagTz7VbtgxfS2ibBqLnKVWwQZgsePibZWFvFJEhPT8BtpQSaFx9IEodyp6c0dw/132","comment_is_top":false,"comment_ctime":1605759722,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100025901,"comment_content":"    Class detailClass = NSClassFromString(@&quot;DetailViewController&quot;);\n    return [[detailClass alloc] initWithURLString:detailURL];\n老师，这样直接去实例化是不推荐吗？和你视频中的用perform去执行有什么区别吗？","like_count":0}]}