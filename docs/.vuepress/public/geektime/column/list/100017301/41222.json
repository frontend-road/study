{"id":41222,"title":"08 | 栈：如何实现浏览器的前进和后退功能？","content":"<p>浏览器的前进、后退功能，我想你肯定很熟悉吧？</p><p>当你依次访问完一串页面a-b-c之后，点击浏览器的后退按钮，就可以查看之前浏览过的页面b和a。当你后退到页面a，点击前进按钮，就可以重新查看页面b和c。但是，如果你后退到页面b后，点击了新的页面d，那就无法再通过前进、后退功能查看页面c了。</p><p><strong><span class=\"orange\">假设你是Chrome浏览器的开发工程师，你会如何实现这个功能呢？</span></strong></p><p>这就要用到我们今天要讲的“栈”这种数据结构。带着这个问题，我们来学习今天的内容。</p><h2>如何理解“栈”？</h2><p>关于“栈”，我有一个非常贴切的例子，就是一摞叠在一起的盘子。我们平时放盘子的时候，都是从下往上一个一个放；取的时候，我们也是从上往下一个一个地依次取，不能从中间任意抽出。<strong>后进者先出，先进者后出，这就是典型的“栈”结构。</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/3e/0b/3e20cca032c25168d3cc605fa7a53a0b.jpg?wh=1142*713\" alt=\"\"></p><p>从栈的操作特性上来看，<strong>栈是一种“操作受限”的线性表</strong>，只允许在一端插入和删除数据。</p><p>我第一次接触这种数据结构的时候，就对它存在的意义产生了很大的疑惑。因为我觉得，相比数组和链表，栈带给我的只有限制，并没有任何优势。那我直接使用数组或者链表不就好了吗？为什么还要用这个“操作受限”的“栈”呢？</p><p>事实上，从功能上来说，数组或链表确实可以替代栈，但你要知道，特定的数据结构是对特定场景的抽象，而且，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然也就更容易出错。</p><!-- [[[read_end]]] --><p><strong>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，这时我们就应该首选“栈”这种数据结构</strong>。</p><h2>如何实现一个“栈”？</h2><p>从刚才栈的定义里，我们可以看出，栈主要包含两个操作，入栈和出栈，也就是在栈顶插入一个数据和从栈顶删除一个数据。理解了栈的定义之后，我们来看一看如何用代码实现一个栈。</p><p>实际上，栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作<strong>顺序栈</strong>，用链表实现的栈，我们叫作<strong>链式栈</strong>。</p><p>我这里实现一个基于数组的顺序栈。基于链表实现的链式栈的代码，你可以自己试着写一下。我会将我写好的代码放到GitHub上，你可以去看一下自己写的是否正确。</p><p>我这段代码是用Java来实现的，但是不涉及任何高级语法，并且我还用中文做了详细的注释，所以你应该是可以看懂的。</p><pre><code>// 基于数组实现的顺序栈\npublic class ArrayStack {\n  private String[] items;  // 数组\n  private int count;       // 栈中元素个数\n  private int n;           //栈的大小\n\n  // 初始化数组，申请一个大小为n的数组空间\n  public ArrayStack(int n) {\n    this.items = new String[n];\n    this.n = n;\n    this.count = 0;\n  }\n\n  // 入栈操作\n  public boolean push(String item) {\n    // 数组空间不够了，直接返回false，入栈失败。\n    if (count == n) return false;\n    // 将item放到下标为count的位置，并且count加一\n    items[count] = item;\n    ++count;\n    return true;\n  }\n  \n  // 出栈操作\n  public String pop() {\n    // 栈为空，则直接返回null\n    if (count == 0) return null;\n    // 返回下标为count-1的数组元素，并且栈中元素个数count减一\n    String tmp = items[count-1];\n    --count;\n    return tmp;\n  }\n}\n</code></pre><p>了解了定义和基本操作，那它的操作的时间、空间复杂度是多少呢？</p><p>不管是顺序栈还是链式栈，我们存储数据只需要一个大小为n的数组就够了。在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度是O(1)。</p><p>注意，这里存储数据需要一个大小为n的数组，并不是说空间复杂度就是O(n)。因为，这n个空间是必须的，无法省掉。所以我们说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。</p><p>空间复杂度分析是不是很简单？时间复杂度也不难。不管是顺序栈还是链式栈，入栈、出栈只涉及栈顶个别数据的操作，所以时间复杂度都是O(1)。</p><h2>支持动态扩容的顺序栈</h2><p>刚才那个基于数组实现的栈，是一个固定大小的栈，也就是说，在初始化栈时需要事先指定栈的大小。当栈满之后，就无法再往栈里添加数据了。尽管链式栈的大小不受限，但要存储next指针，内存消耗相对较多。那我们如何基于数组实现一个可以支持动态扩容的栈呢？</p><p>你还记得，我们在数组那一节，是如何来实现一个支持动态扩容的数组的吗？当数组空间不够时，我们就重新申请一块更大的内存，将原来数组中数据统统拷贝过去。这样就实现了一个支持动态扩容的数组。</p><p>所以，如果要实现一个支持动态扩容的栈，我们只需要底层依赖一个支持动态扩容的数组就可以了。当栈满了之后，我们就申请一个更大的数组，将原来的数据搬移到新数组中。我画了一张图，你可以对照着理解一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/b1/da/b193adf5db4356d8ab35a1d32142b3da.jpg?wh=1142*824\" alt=\"\"></p><p>实际上，支持动态扩容的顺序栈，我们平时开发中并不常用到。我讲这一块的目的，主要还是希望带你练习一下前面讲的复杂度分析方法。所以这一小节的重点还是复杂度分析。</p><p>你不用死记硬背入栈、出栈的时间复杂度，你需要掌握的是分析方法。能够自己分析才算是真正掌握了。现在我就带你分析一下支持动态扩容的顺序栈的入栈、出栈操作的时间复杂度。</p><p>对于出栈操作来说，我们不会涉及内存的重新申请和数据的搬移，所以出栈的时间复杂度仍然是O(1)。但是，对于入栈操作来说，情况就不一样了。当栈中有空闲空间时，入栈操作的时间复杂度为O(1)。但当空间不够时，就需要重新申请内存和数据搬移，所以时间复杂度就变成了O(n)。</p><p>也就是说，对于入栈操作来说，最好情况时间复杂度是O(1)，最坏情况时间复杂度是O(n)。那平均情况下的时间复杂度又是多少呢？还记得我们在复杂度分析那一节中讲的摊还分析法吗？这个入栈操作的平均情况下的时间复杂度可以用摊还分析法来分析。我们也正好借此来实战一下摊还分析法。</p><p>为了分析的方便，我们需要事先做一些假设和定义：</p><ul>\n<li>\n<p>栈空间不够时，我们重新申请一个是原来大小两倍的数组；</p>\n</li>\n<li>\n<p>为了简化分析，假设只有入栈操作没有出栈操作；</p>\n</li>\n<li>\n<p>定义不涉及内存搬移的入栈操作为simple-push操作，时间复杂度为O(1)。</p>\n</li>\n</ul><p>如果当前栈大小为K，并且已满，当再有新的数据要入栈时，就需要重新申请2倍大小的内存，并且做K个数据的搬移操作，然后再入栈。但是，接下来的K-1次入栈操作，我们都不需要再重新申请内存和搬移数据，所以这K-1次入栈操作都只需要一个simple-push操作就可以完成。为了让你更加直观地理解这个过程，我画了一张图。</p><p><img src=\"https://static001.geekbang.org/resource/image/c9/bb/c936a39ad54a9fdf526e805dc18cf6bb.jpg?wh=1142*641\" alt=\"\"></p><p>你应该可以看出来，这K次入栈操作，总共涉及了K个数据的搬移，以及K次simple-push操作。将K个数据搬移均摊到K次入栈操作，那每个入栈操作只需要一个数据搬移和一个simple-push操作。以此类推，入栈操作的均摊时间复杂度就为O(1)。</p><p>通过这个例子的实战分析，也印证了前面讲到的，均摊时间复杂度一般都等于最好情况时间复杂度。因为在大部分情况下，入栈操作的时间复杂度O都是O(1)，只有在个别时刻才会退化为O(n)，所以把耗时多的入栈操作的时间均摊到其他入栈操作上，平均情况下的耗时就接近O(1)。</p><h2>栈在函数调用中的应用</h2><p>前面我讲的都比较偏理论，我们现在来看下，栈在软件工程中的实际应用。栈作为一个比较基础的数据结构，应用场景还是蛮多的。其中，比较经典的一个应用场景就是<strong>函数调用栈</strong>。</p><p>我们知道，操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构,用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。为了让你更好地理解，我们一块来看下这段代码的执行过程。</p><pre><code>int main() {\n   int a = 1; \n   int ret = 0;\n   int res = 0;\n   ret = add(3, 5);\n   res = a + ret;\n   printf(&quot;%d&quot;, res);\n   reuturn 0;\n}\n\nint add(int x, int y) {\n   int sum = 0;\n   sum = x + y;\n   return sum;\n}\n</code></pre><p>从代码中我们可以看出，main()函数调用了add()函数，获取计算结果，并且与临时变量a相加，最后打印res的值。为了让你清晰地看到这个过程对应的函数栈里出栈、入栈的操作，我画了一张图。图中显示的是，在执行到add()函数时，函数调用栈的情况。</p><p><img src=\"https://static001.geekbang.org/resource/image/17/1c/17b6c6711e8d60b61d65fb0df5559a1c.jpg?wh=1142*588\" alt=\"\"></p><h2>栈在表达式求值中的应用</h2><p>我们再来看栈的另一个常见的应用场景，编译器如何利用栈来实现<strong>表达式求值</strong>。</p><p>为了方便解释，我将算术表达式简化为只包含加减乘除四则运算，比如：34+13*9+44-12/3。对于这个四则运算，我们人脑可以很快求解出答案，但是对于计算机来说，理解这个表达式本身就是个挺难的事儿。如果换作你，让你来实现这样一个表达式求值的功能，你会怎么做呢？</p><p>实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。</p><p>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取2个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</p><p>我将3+5*8-6这个表达式的计算过程画成了一张图，你可以结合图来理解我刚讲的计算过程。</p><p><img src=\"https://static001.geekbang.org/resource/image/bc/00/bc77c8d33375750f1700eb7778551600.jpg?wh=1142*790\" alt=\"\"></p><p>这样用两个栈来解决的思路是不是非常巧妙？你有没有想到呢？</p><h2>栈在括号匹配中的应用</h2><p>除了用栈来实现表达式求值，我们还可以借助栈来检查表达式中的括号是否匹配。</p><p>我们同样简化一下背景。我们假设表达式中只包含三种括号，圆括号()、方括号[]和花括号{}，并且它们可以任意嵌套。比如，{[] ()[{}]}或[{()}([])]等都为合法格式，而{[}()]或[({)]为不合法的格式。那我现在给你一个包含三种括号的表达式字符串，如何检查它是否合法呢？</p><p>这里也可以用栈来解决。我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。</p><p>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。</p><h2>解答开篇</h2><p>好了，我想现在你已经完全理解了栈的概念。我们再回来看看开篇的思考题，如何实现浏览器的前进、后退功能？其实，用两个栈就可以非常完美地解决这个问题。</p><p>我们使用两个栈，X和Y，我们把首次浏览的页面依次压入栈X，当点击后退按钮时，再依次从栈X中出栈，并将出栈的数据依次放入栈Y。当我们点击前进按钮时，我们依次从栈Y中取出数据，放入栈X中。当栈X中没有数据时，那就说明没有页面可以继续后退浏览了。当栈Y中没有数据，那就说明没有页面可以点击前进按钮浏览了。</p><p>比如你顺序查看了a，b，c三个页面，我们就依次把a，b，c压入栈，这个时候，两个栈的数据就是这个样子：</p><p><img src=\"https://static001.geekbang.org/resource/image/4b/3d/4b579a76ea7ebfc5abae2ad6ae6a3c3d.jpg?wh=1142*399\" alt=\"\"></p><p>当你通过浏览器的后退按钮，从页面c后退到页面a之后，我们就依次把c和b从栈X中弹出，并且依次放入到栈Y。这个时候，两个栈的数据就是这个样子：</p><p><img src=\"https://static001.geekbang.org/resource/image/b5/1b/b5e496e2e28fe08f0388958a0e12861b.jpg?wh=1142*399\" alt=\"\"></p><p>这个时候你又想看页面b，于是你又点击前进按钮回到b页面，我们就把b再从栈Y中出栈，放入栈X中。此时两个栈的数据是这个样子：</p><p><img src=\"https://static001.geekbang.org/resource/image/ea/bc/ea804125bea25d25ba467a51fb98c4bc.jpg?wh=1142*399\" alt=\"\"></p><p>这个时候，你通过页面b又跳转到新的页面d了，页面c就无法再通过前进、后退按钮重复查看了，所以需要清空栈Y。此时两个栈的数据这个样子：</p><p><img src=\"https://static001.geekbang.org/resource/image/a3/2e/a3c926fe3050d9a741f394f20430692e.jpg?wh=1142*399\" alt=\"\"></p><h2>内容小结</h2><p>我们来回顾一下今天讲的内容。栈是一种操作受限的数据结构，只支持入栈和出栈操作。后进先出是它最大的特点。栈既可以通过数组实现，也可以通过链表来实现。不管基于数组还是链表，入栈、出栈的时间复杂度都为O(1)。除此之外，我们还讲了一种支持动态扩容的顺序栈，你需要重点掌握它的均摊时间复杂度分析方法。</p><h2>课后思考</h2><ol>\n<li>\n<p>我们在讲栈的应用时，讲到用函数调用栈来保存临时变量，为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？</p>\n</li>\n<li>\n<p>我们都知道，JVM内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储Java中的对象。那JVM里面的“栈”跟我们这里说的“栈”是不是一回事呢？如果不是，那它为什么又叫作“栈”呢？</p>\n</li>\n</ol><p>欢迎留言和我分享，我会第一时间给你反馈。</p><hr><p><span class=\"orange\">我已将本节内容相关的详细代码更新到GitHub，<a href=\"https://github.com/wangzheng0822/algo\">戳此</a>即可查看。</span></p>","neighbors":{"left":{"article_title":"07 | 链表（下）：如何轻松写出正确的链表代码？","id":41149},"right":{"article_title":"09 | 队列：队列在线程池等有限资源池中的应用","id":41330}},"comments":[{"had_liked":false,"id":30615,"user_name":"阿杜S考特","can_delete":false,"product_type":"c1","uid":1080257,"ip_address":"","ucode":"0107E78B815B66","user_header":"https://static001.geekbang.org/account/avatar/00/10/7b/c1/22fbcab2.jpg","comment_is_top":true,"comment_ctime":1538960613,"is_pvip":false,"discussion_count":31,"race_medal":0,"score":"9.2233760112385004e+18","product_id":100017301,"comment_content":"        内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。<br>        内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区。<br>代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。<br>静态数据区：存储全局变量、静态变量、常量，常量包括final修饰的常量和String常量。系统自动分配和回收。<br>栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。<br>堆区：new一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。<br><br>","like_count":924,"discussions":[{"author":{"id":1073894,"avatar":"https://static001.geekbang.org/account/avatar/00/10/62/e6/163eb9f8.jpg","nickname":"宇宙超人","note":"","ucode":"28EBA3B0C136C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69135,"discussion_content":"真实的堆栈应该和计算机架构有关，cpu有栈顶指针寄存器，然后指令有push和pop的指令，这个是数字电路作死的，函数之间的跳变，编译器把要跳的地址赋值给栈顶指针寄存器，然后根据你写的代码编译成push和pop，这部分代码对写高级语言的程序员是透明的，如果写汇编，这些都得自己写","likes_number":25,"is_delete":false,"is_hidden":false,"ctime":1575263816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1254423,"avatar":"https://static001.geekbang.org/account/avatar/00/13/24/17/a8db1ff7.jpg","nickname":"李团结","note":"","ucode":"23831A96515E2C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345404,"discussion_content":"误人子弟呀，希望这条信息不要在被置顶了~~","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1611717549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":1640978,"avatar":"https://static001.geekbang.org/account/avatar/00/19/0a/12/f8b988b8.jpg","nickname":"Kyle(","note":"","ucode":"0C14C4C086CAA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1254423,"avatar":"https://static001.geekbang.org/account/avatar/00/13/24/17/a8db1ff7.jpg","nickname":"李团结","note":"","ucode":"23831A96515E2C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351324,"discussion_content":"我也有这种感觉，最终问题是“那 JVM 里面的“栈”跟我们这里说的“栈”是不是一回事呢？”，难道JVM中的栈就不属于Stack了？它的运行方式和栈的概念不同吗？还是说是一样的，那么这样就是说JVM的栈是数据结构栈的一种实现了，那这个不一样要从什么角度来界定了？","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1614244201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":345404,"ip_address":""},"score":351324,"extra":""},{"author":{"id":1640978,"avatar":"https://static001.geekbang.org/account/avatar/00/19/0a/12/f8b988b8.jpg","nickname":"Kyle(","note":"","ucode":"0C14C4C086CAA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1254423,"avatar":"https://static001.geekbang.org/account/avatar/00/13/24/17/a8db1ff7.jpg","nickname":"李团结","note":"","ucode":"23831A96515E2C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351325,"discussion_content":"如果觉得是误人子弟的，请农民起义把我们顶起来！ ~~","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1614244371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":345404,"ip_address":""},"score":351325,"extra":""},{"author":{"id":1262086,"avatar":"https://static001.geekbang.org/account/avatar/00/13/42/06/8eb34fe6.jpg","nickname":"王文建","note":"","ucode":"A540E30AB8B0AD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1640978,"avatar":"https://static001.geekbang.org/account/avatar/00/19/0a/12/f8b988b8.jpg","nickname":"Kyle(","note":"","ucode":"0C14C4C086CAA9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367941,"discussion_content":"1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618499464,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":351324,"ip_address":""},"score":367941,"extra":""}]},{"author":{"id":1466447,"avatar":"https://static001.geekbang.org/account/avatar/00/16/60/4f/db0e62b3.jpg","nickname":"Daiver","note":"","ucode":"9B1A03AFBC79BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":192102,"discussion_content":"这里纠正一下，对象不仅可以在堆中分配（大多数情况下是这样），jvm有逃逸分析优化可以让未逃逸的对象在栈上分配（hotspot虚拟机上采用了标量替换来实现对象在栈上的分配）。","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1583063331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1134288,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","nickname":"Ken张云忠","note":"","ucode":"D0BAC9FC17DE2B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1466447,"avatar":"https://static001.geekbang.org/account/avatar/00/16/60/4f/db0e62b3.jpg","nickname":"Daiver","note":"","ucode":"9B1A03AFBC79BC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":236625,"discussion_content":"java虚拟机大部分是基于栈的计算模型实现的,JIT在解析字节码时会虚拟一个栈的计算模型,但到了优化阶段就不再使用了,比如标量替换/方法内联等.","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1587110050,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":192102,"ip_address":""},"score":236625,"extra":""}]},{"author":{"id":1200793,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/99/4a7f2fc9.jpg","nickname":"RyuGou","note":"","ucode":"8D424CB6005DD7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361658,"discussion_content":"误人子弟了兄弟，“内存真实存在的物理区”…😁\n物理层次的内存有什么呀？你放大了看都是密密麻麻的一些存储电路，可以存电容~无他！表想的太复杂","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1616723874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1899995,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/fd/db/cf9cd034.jpg","nickname":"高山景行","note":"","ucode":"07E728EE3B4015","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1200793,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/99/4a7f2fc9.jpg","nickname":"RyuGou","note":"","ucode":"8D424CB6005DD7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583637,"discussion_content":"你说的只是物理结构，对于运行的程序来说会区分不同区域的逻辑结构，可以去看看其他语言。例如：C/C++直接对内存的操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660264503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":361658,"ip_address":"浙江"},"score":583637,"extra":""}]},{"author":{"id":1092407,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ab/37/455d6a8d.jpg","nickname":"Geek_821c96","note":"","ucode":"B07B528F2E12C6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352999,"discussion_content":"这个评论有毒，误导人","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1614940840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1112747,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","nickname":"李小四","note":"","ucode":"2A766BE16B276B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":313051,"discussion_content":"@王争 @小编 这个置顶评论是有问题的，麻烦再查看一下。\n物理上内存是无差别的硬件，堆区，栈区都是软件的抽象。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1602925264,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1490036,"avatar":"https://static001.geekbang.org/account/avatar/00/16/bc/74/01e32a0d.jpg","nickname":"小肉仙","note":"","ucode":"1048D421CC5CC4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1112747,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","nickname":"李小四","note":"","ucode":"2A766BE16B276B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":313143,"discussion_content":"应该是虚拟内存中的抽象","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602958062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":313051,"ip_address":""},"score":313143,"extra":""}]},{"author":{"id":1985935,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/4d/8f/e3f171c1.jpg","nickname":"xgh","note":"","ucode":"3C508E2ED32508","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302428,"discussion_content":"这种错误认知置顶了不会误人吗","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1598922657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2055194,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLbuXiafdYFyFsytMspswIM4EbnhtkGicCxZpo4iaQHiaibVVMz0SwtA8xyXbpAPWDsmrKcdz2jQRKxImQ/132","nickname":"chenqi","note":"","ucode":"99B1968262003D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289951,"discussion_content":"jvm栈由栈帧组成，入栈出栈都是在栈帧里面操作，jvm的栈（栈帧）和数据结构的栈是一个概念。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1594278350,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2337634,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DhjfDnSY73Nh0GmG4HLibjQ6m5DGWjEctYUcQRTss5yYFicVnZzuymMLMnW8wP9HAlIW3psQCXtxFblxG0umxcNQ/132","nickname":"贺大禹","note":"","ucode":"0E20806B11B049","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378741,"discussion_content":"实际应用与概念的区别吧","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1623383262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1048525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ff/cd/9c44f2d5.jpg","nickname":"Mong狗","note":"","ucode":"9DF0D65D75984E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360363,"discussion_content":"按照我的理解本质就是一个东西， 都是先进先出！jvm的栈是线程私有的，由栈帧构成，每调用一个方法都会压栈操作，调用完成出栈","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1616422984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1371954,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epFRbF5IkEBkMQmMfaZRrQpvZtxF1emYS1pEICFb9AaM5k4QluSxLZEGsnLASprt317uTzmaNegCg/132","nickname":"Dancer_aaa","note":"","ucode":"B411D90711201A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375153,"discussion_content":"我认为这并非算是误导，可以理解为是在真实的物理内存上划分的逻辑区域，此为“真实存在的物理区”。而数据结构中的堆栈是一种实现数据存储和操作机制的方式，是一种数据结构的“名字”，虽然使用此种数据就结构的数据也存储于内存上，但并不会在内存上被特别地进行逻辑区域划分。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1621498114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1848539,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/LqGZd83zp1y9fpbliaSgGh5qib5eGzU41xibTzib06ZAlaiaJibkJB89JuVEozCScUsVK90jpq7Na30AHDngQzI7YwiaA/132","nickname":"星朝","note":"","ucode":"DFCF2512D6DAE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305647,"discussion_content":"误人子弟，你要查查资料，看看源码","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1600046135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2154488,"avatar":"https://static001.geekbang.org/account/avatar/00/20/df/f8/e17f8ab5.jpg","nickname":"魏汉武","note":"","ucode":"D65B21B01202D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389733,"discussion_content":"const修饰的代码是在text段，存放在堆栈区的变量值是可修改的，但是const表示的含义就是常量","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629417273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2275817,"avatar":"https://static001.geekbang.org/account/avatar/00/22/b9/e9/19cd7d9c.jpg","nickname":"落","note":"","ucode":"79525752D3A1B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374528,"discussion_content":"为啥看了大家的评论，还是懵的，是否需要先去看一下jvm的相关知识？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621235475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2201314,"avatar":"","nickname":"dejavu006","note":"","ucode":"6D755EAD4E670F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348080,"discussion_content":"栈只不过是访问内存的一种抽象形式。。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1612423002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100439,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ca/97/5042c207.jpg","nickname":"king","note":"","ucode":"FFC090D0EF1F80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344615,"discussion_content":"jvm的内存逻辑结构的栈跟这章节说的是一个东西。线程私有，存储返回地址，方法局部变量这些","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611539148,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1304564,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e7/f4/482e3413.jpg","nickname":"土豆-gavin               ༽","note":"","ucode":"15D24B71468A2C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305491,"discussion_content":"别瞎赞，很是误人子弟啊，兄弟，你这理解不对，栈怎么可能是物理区域，都是逻辑划分。关机就不存在了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599964169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2053990,"avatar":"","nickname":"201201418","note":"","ucode":"46726F0E08CB1C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1304564,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e7/f4/482e3413.jpg","nickname":"土豆-gavin               ༽","note":"","ucode":"15D24B71468A2C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306740,"discussion_content":"你语文不好吧ヽ( ￣д￣;)ノ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600358129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":305491,"ip_address":""},"score":306740,"extra":""}]},{"author":{"id":1073947,"avatar":"https://static001.geekbang.org/account/avatar/00/10/63/1b/83ac7733.jpg","nickname":"忧天小鸡","note":"","ucode":"A1412BDC108FD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372766,"discussion_content":"汇编说的是代码段、数据段、堆栈段","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620455158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2088448,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/fIqDapozRSQGwe188s6NJm0vaDqZyVr0bnLkibomkbhrpDhZmvksdpYIicIOePlOdFvBf5ic37z2UwF3gh6g5Cicwg/132","nickname":"一棵大树","note":"","ucode":"2EBB9226EA4EB8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303225,"discussion_content":"想知道老师的图是用什么画的，感觉好可爱","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599194216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1959803,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/0iaIWczXBpgnVVQwKmKNg6ibfCPul4j4VIzLk4mSvdYBXdft8kR0c4q4hnDU8ehSRtiaaib2Bn0ErJiax6snH5WKMiag/132","nickname":"liyang89","note":"","ucode":"660EBF9DDFC3C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":248445,"discussion_content":"个人认为是同一个概念。融合在一起无非是让初学者混淆了而已。虚拟地址空间的堆栈内存操作就是按照堆栈概念来操作的。只不过向用户封装了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587870869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1096329,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ba/89/a76e02c8.jpg","nickname":"wildq","note":"","ucode":"49F103541C8000","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1959803,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/0iaIWczXBpgnVVQwKmKNg6ibfCPul4j4VIzLk4mSvdYBXdft8kR0c4q4hnDU8ehSRtiaaib2Bn0ErJiax6snH5WKMiag/132","nickname":"liyang89","note":"","ucode":"660EBF9DDFC3C9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383404,"discussion_content":"堆就是个大数组，和数据结构堆不一样，栈是和数据结构一样的，这是我的理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626080579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":248445,"ip_address":""},"score":383404,"extra":""}]}]},{"had_liked":false,"id":36337,"user_name":"王争","can_delete":false,"product_type":"c1","uid":1190123,"ip_address":"","ucode":"2B611BE0E0EDD4","user_header":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","comment_is_top":true,"comment_ctime":1541042680,"is_pvip":false,"discussion_count":22,"race_medal":0,"score":"9.223375530204201e+18","product_id":100017301,"comment_content":"为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？<br><br>其实，我们不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。<br><br>从调用函数进入被调用函数，对于数据来说，变化的是什么呢？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。","like_count":813,"discussions":[{"author":{"id":1900825,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/5Cd5DiaVksY0szIkygsbKYwHKP6AObuqZ7J6TAD3KZaZ0WWQ9k0Byr6pl3EzyxuCTb85NJkt20icQ7zJaFwYa1zQ/132","nickname":"东边日出西边雨","note":"","ucode":"FB373232AC152A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276263,"discussion_content":"个人觉得，函数调用选择堆栈，使用因果论来解释可能会更好，所谓有因才有果，有了调用函数才会有被调用函数，而被调用函数在执行的时候，要求他的“因”（调用函数）必须状态确定，那么栈就是最好的选择了，“因”被入栈了。对于栈来说，只能访问栈顶元素和栈的大小，已经入栈的“因”，就被这样保存了起来，防止有意和无意的更改；对于单项链表、队列、表等，因为无法回溯“因”，根本不符合函数调用的因果关系，直接pass，对于数组和双向链表，因为无法完美的保存“因”，可以直接访问，所以也不完美，所以栈就是唯一完美的选择；","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1590847711,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1159044,"avatar":"https://static001.geekbang.org/account/avatar/00/11/af/84/c65b43fb.jpg","nickname":"Ron","note":"","ucode":"EE78756918FA0A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1900825,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/5Cd5DiaVksY0szIkygsbKYwHKP6AObuqZ7J6TAD3KZaZ0WWQ9k0Byr6pl3EzyxuCTb85NJkt20icQ7zJaFwYa1zQ/132","nickname":"东边日出西边雨","note":"","ucode":"FB373232AC152A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362882,"discussion_content":"栈只是一种抽象概念吧？ 它的具体实现不是可以用数组或者链表实现吗？  所以你这块的理解好像有点问题","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1617066686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":276263,"ip_address":""},"score":362882,"extra":""}]},{"author":{"id":1609871,"avatar":"https://static001.geekbang.org/account/avatar/00/18/90/8f/9c691a5f.jpg","nickname":"奔跑的码仔","note":"","ucode":"AB3B02B07B8B8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214949,"discussion_content":"和函数的作用域结合起来，理解函数调用栈，还是第一次！","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1585263306,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1943619,"avatar":"","nickname":"进击的小菜","note":"","ucode":"DEDC4D31DA0DF1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1609871,"avatar":"https://static001.geekbang.org/account/avatar/00/18/90/8f/9c691a5f.jpg","nickname":"奔跑的码仔","note":"","ucode":"AB3B02B07B8B8C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":218513,"discussion_content":"对的太赞了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585663467,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":214949,"ip_address":""},"score":218513,"extra":""}]},{"author":{"id":1019961,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/39/abb7bfe3.jpg","nickname":"孙国林","note":"","ucode":"53C891890403C0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":186717,"discussion_content":"栈顶复位是什么意思啊？","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1582708929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1292087,"avatar":"https://static001.geekbang.org/account/avatar/00/13/b7/37/0290ff6e.jpg","nickname":"Veitor","note":"","ucode":"3397AC6D239195","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1019961,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/39/abb7bfe3.jpg","nickname":"孙国林","note":"","ucode":"53C891890403C0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338855,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609403776,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":186717,"ip_address":""},"score":338855,"extra":""},{"author":{"id":2039334,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/1e/26/5173508e.jpg","nickname":"🍳🐟🍊🌟","note":"","ucode":"FA6FAA1897CBDC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1019961,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/39/abb7bfe3.jpg","nickname":"孙国林","note":"","ucode":"53C891890403C0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365020,"discussion_content":"复位应该是指恢复原位；假设x（）调用y（），被调用函数y结束，y所分配的那个栈帧出栈，栈顶指针复位，重新指向调用函数x","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1617687185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":186717,"ip_address":""},"score":365020,"extra":""}]},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161791,"discussion_content":"既然栈可以用数组和链表实现，那么用数据或链表来存函数调用的局部变量也是没问题的，只不过栈的单向操作正好贴合函数调用中局部变量作用域，故顺理成章了。\n试想用散列表来做函数调用，如果找到一个Hash算法，能做到O(1)得到函数间的调用关系，那么也是可以的，只不过没栈那么直观和优雅。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1580917413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1488048,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b4/b0/508cbd6c.jpg","nickname":"phonexi","note":"","ucode":"ABCB885542617A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6833,"discussion_content":"老师，你好，能不能举个反例呢？什么函数的调用不符合后进先出？？","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1567134455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1488048,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b4/b0/508cbd6c.jpg","nickname":"phonexi","note":"","ucode":"ABCB885542617A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65638,"discussion_content":"em，么有吧。。。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575017811,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":6833,"ip_address":""},"score":65638,"extra":""},{"author":{"id":1637933,"avatar":"https://static001.geekbang.org/account/avatar/00/18/fe/2d/e23fc6ee.jpg","nickname":"深水蓝","note":"","ucode":"3E3B195DE54DE1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1488048,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b4/b0/508cbd6c.jpg","nickname":"phonexi","note":"","ucode":"ABCB885542617A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571814,"discussion_content":"在汇编里面或者C语言，是可以通过类似实现goto那样的指令随意跳转的。可以在执行A函数调用了B函数之后，在B函数里面使用goto跳转到C函数，这样B函数就不是后进先出了，也可能B函数也永远无法退出了。\n\n一般写程序不建议这样写，即使对资源极度紧张的单片机，也不建议的。非常容易出问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652419304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":6833,"ip_address":""},"score":571814,"extra":""}]},{"author":{"id":1122121,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1f/49/e4ab004b.jpg","nickname":"波拉拉","note":"","ucode":"586F66351219E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1224,"discussion_content":"那个Recursive Factorial 函数就是典型的“栈”吧","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1562415602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1990297,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/5e/99/d5488c67.jpg","nickname":"小马过河","note":"","ucode":"CB8AD608237361","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288126,"discussion_content":"栈和作用域，这个关系角度好","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1593655520,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1482915,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","nickname":"业余爱好者","note":"","ucode":"A890935A982988","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282197,"discussion_content":"作用域这个视角学习了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1591921468,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1112534,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f9/d6/dac39709.jpg","nickname":"知境","note":"","ucode":"B4E16098CA9191","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":258335,"discussion_content":"小争哥，您在“栈在函数调用中的应用”一小节提到os为每一个线程分配一个独立的内存空间。这一点说法可能不正确吧。我们只能说进程是os独立分配资源的单位，而线程只是共享进程的资源啊。线程只是作为独立调度执行的基本单元。 想向您求证！！","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1588679033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1663898,"avatar":"https://static001.geekbang.org/account/avatar/00/19/63/9a/6872c932.jpg","nickname":"Grey","note":"","ucode":"D63D36C9A7F16B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1112534,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f9/d6/dac39709.jpg","nickname":"知境","note":"","ucode":"B4E16098CA9191","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289513,"discussion_content":"线程会共享进程的区域，但是线程也有自己的私有区域","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594128067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":258335,"ip_address":""},"score":289513,"extra":""}]},{"author":{"id":1499380,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/6vz8MgZia6Xwdhayv9Jdnee7HfDYSAMTUtMAAVORMhiaN8bIM0QJibrQ5EDqB8o5pWE6FRuaqguwG86o5Gh90ruDw/132","nickname":"不会爬树的熊","note":"","ucode":"E417D8D9D5FED2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5694,"discussion_content":"好牛逼的理解","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1566439707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1866485,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/7a/f5/54a5084b.jpg","nickname":"简单猫","note":"","ucode":"EA027D4C344E25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549384,"discussion_content":"确实 函数作用域 最先调用的放在栈底 \n代码一行一行往下执行 当前子作用域调用完了\n然后就pop出去 ，再push新的子作用域\n当没有新的作用域后 就pop上一层作用域\n最后全部释放","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1643902247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1907362,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/1a/a2/8484b2cf.jpg","nickname":"为光","note":"","ucode":"70E21C9BA5B791","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":232163,"discussion_content":"其实可以写一段简单的函数调用代码，把它编码成asm文件，看汇编代码，就很清晰地能看出来栈和函数调用的关系","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586857998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1949759,"avatar":"","nickname":"thetwomoon","note":"","ucode":"896A30078E1031","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387081,"discussion_content":"假设当前指向栈顶内存的的地址为0x1，此时调用一个新的方法，指向的栈顶地址变更为0x2，当0x2出战时，栈顶重新变回原来的0x1，而入栈出栈只是寄存器内容的保存于恢复的区别","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627976353,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2708370,"avatar":"https://static001.geekbang.org/account/avatar/00/29/53/92/21c78176.jpg","nickname":"小黄鸭","note":"","ucode":"2800E3A723AEBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385935,"discussion_content":"老师能不能讲一讲第二题的答案？\n以及在这里我有一个疑问，被调用函数的变量栈是嵌入在调用函数里的吗？如果不是的话，是咋回来的呢？如果是的话，怎么知道哪里开始是被调用函数呢？我感觉会不会还有其他的函数栈来存储这个调用关系吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627355110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1614285,"avatar":"https://static001.geekbang.org/account/avatar/00/18/a1/cd/bc74741c.jpg","nickname":"~patience","note":"","ucode":"8D9BC78A241CEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":242662,"discussion_content":"作者本人？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587482520,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":true,"id":32428,"user_name":"他在她城断了弦","can_delete":false,"product_type":"c1","uid":1242521,"ip_address":"","ucode":"3D91CA87B64C8B","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/99/454b17c1.jpg","comment_is_top":false,"comment_ctime":1539569231,"is_pvip":false,"discussion_count":113,"race_medal":0,"score":"5889939732047","product_id":100017301,"comment_content":"leetcode上关于栈的题目大家可以先做20,155,232,844,224,682,496.","like_count":1372,"discussions":[{"author":{"id":1338088,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6a/e8/4bb87c34.jpg","nickname":"月马穿关","note":"","ucode":"2CE20CA1EB827D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50478,"discussion_content":"好人一生高潮","likes_number":83,"is_delete":false,"is_hidden":false,"ctime":1573725606,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1966569,"avatar":"","nickname":"李远之","note":"","ucode":"5B781FD1C03F10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1338088,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6a/e8/4bb87c34.jpg","nickname":"月马穿关","note":"","ucode":"2CE20CA1EB827D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581798,"discussion_content":"？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658997184,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":50478,"ip_address":"陕西"},"score":581798,"extra":""}]},{"author":{"id":1711057,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/1b/d1/0c9e20f8.jpg","nickname":"CH0918","note":"","ucode":"DCADD098A62766","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96318,"discussion_content":"谢谢课代表","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1577059441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2306092,"avatar":"https://static001.geekbang.org/account/avatar/00/23/30/2c/72eefb1e.jpg","nickname":"Sheldon","note":"","ucode":"69FFDA9F4EA0D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393633,"discussion_content":"mark","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631525113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2625677,"avatar":"https://static001.geekbang.org/account/avatar/00/28/10/8d/abf02c56.jpg","nickname":"王兴","note":"","ucode":"3EF1AC47EE7C78","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375082,"discussion_content":"Mark","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621476790,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1178235,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fa/7b/f89a398b.jpg","nickname":"Charles | 姜海龙","note":"","ucode":"17BA74D1684184","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370427,"discussion_content":"mark了，以后还想看到你","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1619407396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1743579,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/9a/db/8d2670c7.jpg","nickname":"iLee","note":"","ucode":"3797C64D47B614","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215066,"discussion_content":"这是大哥\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585279460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1597287,"avatar":"https://static001.geekbang.org/account/avatar/00/18/5f/67/5fd76a7f.jpg","nickname":"小六子的鱼","note":"","ucode":"7430B43A79BD2A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":107799,"discussion_content":"赞一个栈","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577608210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1211359,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7b/df/876dd9cc.jpg","nickname":"kings","note":"","ucode":"D478306EBF582E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69456,"discussion_content":"很棒的网站","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575288640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1716067,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/2f/63/7a048d46.jpg","nickname":"梨子苹果","note":"","ucode":"3666813FEE31D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49240,"discussion_content":"赞","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573566454,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1518842,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2c/fa/d9ef3e77.jpg","nickname":"牛仔很忙。","note":"","ucode":"5037849220E48D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579529,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657521538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2914259,"avatar":"","nickname":"Geek_c2a2be","note":"","ucode":"ECAE3C732915CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560147,"discussion_content":"只告诉答案，不说明方法的行为，有点~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649212042,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2541293,"avatar":"https://static001.geekbang.org/account/avatar/00/26/c6/ed/c90811c4.jpg","nickname":"念汐DAYTOY","note":"","ucode":"B42622870B3BCB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558620,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648399745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1810890,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a1/ca/aae116f5.jpg","nickname":"邵亮","note":"","ucode":"8407C3FDD11C0E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549053,"discussion_content":"XIEXIE","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643533848,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1851970,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/42/42/2a04ada9.jpg","nickname":"毛小树","note":"","ucode":"E47DC07CE4959E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544673,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641633971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1450982,"avatar":"https://static001.geekbang.org/account/avatar/00/16/23/e6/12b3d2bf.jpg","nickname":"Holy","note":"","ucode":"B039B0AB117396","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536732,"discussion_content":"mark,刷完了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638858884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2837957,"avatar":"","nickname":"Geek_7288a3","note":"","ucode":"F72B76C39EFA9C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":412671,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636252371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2829938,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/2e/72/6772f172.jpg","nickname":"ᯤ¹º²⁴ᴳ⁺","note":"","ucode":"8EEF0251BAE054","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":410972,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635820020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1415367,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/glFY0qy2o97CJ7Mfp3vDr5lc46IIyfIas4rgvf90ics25yibrmoXUQDg3cy5sDdX9I814asBpoKTUlWicITgZjsIg/132","nickname":"Geek_785348","note":"","ucode":"98F8A837EC01B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":410614,"discussion_content":"老哥稳😁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635741333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1266713,"avatar":"https://static001.geekbang.org/account/avatar/00/13/54/19/cebc0778.jpg","nickname":"田园","note":"","ucode":"6BBAA412B22F67","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407931,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635152915,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2705013,"avatar":"https://static001.geekbang.org/account/avatar/00/29/46/75/468ab508.jpg","nickname":"ChangheZeng","note":"","ucode":"EF1E70751BDF7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401342,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633654261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2762634,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoBvqEtL5jPfibavnGmvicCVndB1VabyrlZjls3KdYaN4FuaViaFDVRgVoWPmczXlfTvz83WGLPyicXgw/132","nickname":"Geek_cddbfa","note":"","ucode":"09A04136394E24","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":399028,"discussion_content":"mark\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632889306,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1595176,"avatar":"https://static001.geekbang.org/account/avatar/00/18/57/28/be7550d2.jpg","nickname":"mo","note":"","ucode":"FB3E8C827BE5CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":398915,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632876279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2747952,"avatar":"https://static001.geekbang.org/account/avatar/00/29/ee/30/bfa22325.jpg","nickname":"寻","note":"","ucode":"E8E6BD7E3947EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394007,"discussion_content":"M","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631688811,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2744326,"avatar":"","nickname":"Geek_d888d3","note":"","ucode":"71324852FF567D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390332,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629785896,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1303192,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e2/98/94d2a8e4.jpg","nickname":"野菜不怕","note":"","ucode":"DD9BFFC4EA51F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387579,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628261906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2708370,"avatar":"https://static001.geekbang.org/account/avatar/00/29/53/92/21c78176.jpg","nickname":"小黄鸭","note":"","ucode":"2800E3A723AEBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385936,"discussion_content":"谢谢同学！收藏了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627355185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2671858,"avatar":"https://static001.geekbang.org/account/avatar/00/28/c4/f2/3a446868.jpg","nickname":"Long night","note":"","ucode":"2DD57AACD44CC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385010,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626849811,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2686020,"avatar":"https://static001.geekbang.org/account/avatar/00/28/fc/44/018057b7.jpg","nickname":"白宇灯","note":"","ucode":"86230DD1D46E58","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384775,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626746982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2625677,"avatar":"https://static001.geekbang.org/account/avatar/00/28/10/8d/abf02c56.jpg","nickname":"王兴","note":"","ucode":"3EF1AC47EE7C78","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384241,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626436795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1512616,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/NtKFIwXk9tsdib8th6qzkwQutz8Ocsq7VaHTc4lwvGfaRlGOKTub1M3xbMZvKkoFH928KV6riagoZ3Vl7polVdRg/132","nickname":"Geek_mofei004","note":"","ucode":"83DA31D8D2268F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383500,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626137270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2649393,"avatar":"","nickname":"rhythmli","note":"","ucode":"3EAE034811391D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382451,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625577820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2542492,"avatar":"","nickname":"Geek_2be19e","note":"","ucode":"9ECA3C15C18CED","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382372,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625547226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1139128,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJh4fE4WryeIpjKCYB7TuWS2IEFV0paiaZt3hSh8jrPZRD8cvalPWndTv1VbdDiaEKibY0IgGGPEMbCw/132","nickname":"刘聪为","note":"","ucode":"8DFDCA7B37D04E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381336,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625017894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2674410,"avatar":"https://static001.geekbang.org/account/avatar/00/28/ce/ea/0032a716.jpg","nickname":"啊袁","note":"","ucode":"7422C894913F0E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381272,"discussion_content":"mark\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624976688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2671858,"avatar":"https://static001.geekbang.org/account/avatar/00/28/c4/f2/3a446868.jpg","nickname":"Long night","note":"","ucode":"2DD57AACD44CC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380542,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624548783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379490,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623926851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1605000,"avatar":"https://static001.geekbang.org/account/avatar/00/18/7d/88/32713a32.jpg","nickname":"南山隐者","note":"","ucode":"D934C594E4F819","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379101,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623683141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2657756,"avatar":"https://static001.geekbang.org/account/avatar/00/28/8d/dc/5e18def5.jpg","nickname":"Grey","note":"","ucode":"F737C1311E649B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378836,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623443101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2404309,"avatar":"https://static001.geekbang.org/account/avatar/00/24/af/d5/1390b511.jpg","nickname":"少年","note":"","ucode":"FAAAD8133515A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378629,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623310498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2598406,"avatar":"https://static001.geekbang.org/account/avatar/00/27/a6/06/060522e6.jpg","nickname":"Jason-sun","note":"","ucode":"D6BB6BFAC41A52","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378255,"discussion_content":"m\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623130706,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2577268,"avatar":"https://static001.geekbang.org/account/avatar/00/27/53/74/17c18b44.jpg","nickname":"布小丁","note":"","ucode":"3EDD7C5A0E4C8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377689,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622776659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1439517,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f7/1d/f6a74116.jpg","nickname":"刘相雨","note":"","ucode":"61CC3EEAD3185D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377291,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622593665,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1439517,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f7/1d/f6a74116.jpg","nickname":"刘相雨","note":"","ucode":"61CC3EEAD3185D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377290,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622593642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1017204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/85/74/e70862a2.jpg","nickname":"、、cryAllen","note":"","ucode":"50032F6E2DDB4B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376809,"discussion_content":"Mark \n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622359714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2599089,"avatar":"https://static001.geekbang.org/account/avatar/00/27/a8/b1/092b658f.jpg","nickname":"Geek_d60492","note":"","ucode":"9A79B12F0D3D63","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376434,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622122716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2162521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/MaX06SRk19zM2lAaymYylpXD6LMtIPFlDyxZKgRhmZCjhNE4nIdDGBmh08razhebVCgAv54xialYBBIIwmleBew/132","nickname":"Geek_6d1382","note":"","ucode":"B61E65CFEB684F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375923,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621869473,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2566128,"avatar":"https://static001.geekbang.org/account/avatar/00/27/27/f0/b709cc91.jpg","nickname":"梦阮","note":"","ucode":"7FC17BDD055BF5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375688,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621817659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1761882,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/MEbNM8XV6wRGJnVhZx58J21rBiboLhGdXpibLxHX4EwHltgqK5BPElanIiaIicPzBiaKZ63jia4GGGM3wbp2fYco8WSQ/132","nickname":"Geek_514f5a","note":"","ucode":"22A39E20B725D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372260,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620262078,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2575914,"avatar":"https://static001.geekbang.org/account/avatar/00/27/4e/2a/41db4a2c.jpg","nickname":"Geek","note":"","ucode":"CD2C5AB66EA7C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370004,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619248992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2566646,"avatar":"https://static001.geekbang.org/account/avatar/00/27/29/f6/4e01eb02.jpg","nickname":"Paperback、","note":"","ucode":"118CBCF232A14F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368318,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618652884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2561108,"avatar":"","nickname":"Geek_8633c9","note":"","ucode":"517B55CCFE7F0A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368062,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618554418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":7,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1527389,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4e/5d/8b922622.jpg","nickname":"Wu绍绍绍绍强","note":"","ucode":"36546F4C16E3DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365183,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617721732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":7,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1968440,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/09/38/ae7faae1.jpg","nickname":"🌏","note":"","ucode":"87679BF3004AAA","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363446,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617196989,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":7,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2524479,"avatar":"https://static001.geekbang.org/account/avatar/00/26/85/3f/e77a6e4c.jpg","nickname":"Vonct","note":"","ucode":"4511797597786D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361770,"discussion_content":"m\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616748281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":7,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2530164,"avatar":"https://static001.geekbang.org/account/avatar/00/26/9b/74/7322a31a.jpg","nickname":"-","note":"","ucode":"232762520CFAEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359902,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616325861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":7,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2420790,"avatar":"https://static001.geekbang.org/account/avatar/00/24/f0/36/828a1569.jpg","nickname":"正常的神经病先生","note":"","ucode":"44A7A91FE36335","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358675,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616030018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":7,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1588069,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/1LBKicKhg0LLB9pHo0sqXj9UBOv2GicuLOe8fzic493p0eE71lbzXPNJFchc91XdjPznyxLibVunGPMesKS1k5OZ0A/132","nickname":"Geek_8aa36f","note":"","ucode":"64A7443C107D5B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358287,"discussion_content":"mark\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615960852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":7,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2065684,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/85/14/bb1cc4ee.jpg","nickname":"我叫徐豆豆","note":"","ucode":"89CA86A0B489A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":354767,"discussion_content":"这个就秀了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615339869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":7,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1049594,"avatar":"https://static001.geekbang.org/account/avatar/00/10/03/fa/be3192aa.jpg","nickname":"Haien","note":"","ucode":"5F0FB5EB22BDA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":354191,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615254244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":7,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1602801,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/5icFeiciaFwv8jiazQZdlx8fO6WalCavhz7nvEtSWxQ1xXDEkTcLOgYlBaZtIib2fQYKibeGvybL16wFhIM2jWtc1Xfw/132","nickname":"Geek_ZtaoCoder","note":"","ucode":"4764B73FBB8385","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353553,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615173096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":7,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2369743,"avatar":"https://static001.geekbang.org/account/avatar/00/24/28/cf/7a1c98df.jpg","nickname":"朴素的心态","note":"","ucode":"4E9CEF283E442D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352250,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614663845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":8,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2358466,"avatar":"https://static001.geekbang.org/account/avatar/00/23/fc/c2/f5add747.jpg","nickname":"杨之力 Zhili Yang","note":"","ucode":"8D1FD7E734037C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351191,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614174116,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":8,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2427736,"avatar":"https://static001.geekbang.org/account/avatar/00/25/0b/58/35b5887d.jpg","nickname":"H.M","note":"","ucode":"13FD0B763CB43D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350592,"discussion_content":"M","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613950946,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":8,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2110991,"avatar":"https://static001.geekbang.org/account/avatar/00/20/36/0f/6a4d3d4e.jpg","nickname":"duoclassic","note":"","ucode":"76B2E5AF72A14C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348205,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612465007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":8,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2273620,"avatar":"https://static001.geekbang.org/account/avatar/00/22/b1/54/6d663b95.jpg","nickname":"瓜牛","note":"","ucode":"5EB7D2F4400A70","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347635,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612269103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":8,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2413946,"avatar":"https://static001.geekbang.org/account/avatar/00/24/d5/7a/4a387fea.jpg","nickname":"Pink_Strawberry","note":"","ucode":"6A6E910C616D8A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345977,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611827183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":8,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1477864,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8c/e8/7eaea745.jpg","nickname":"ayan","note":"","ucode":"D88375FD30A8CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345577,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611745557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":8,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1795821,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/66/ed/a1233b74.jpg","nickname":"蔡冰成","note":"","ucode":"A1C50B0121C6C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336523,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608615639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":8,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1983933,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/45/bd/b125aed6.jpg","nickname":"衔蝉sama","note":"","ucode":"5E13C48AF1EF8F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335724,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608284889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":8,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1952486,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/ca/e6/50e45bc3.jpg","nickname":"yingwinwin","note":"","ucode":"255DDB529E5C2C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335591,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608223322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":8,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2356857,"avatar":"https://static001.geekbang.org/account/avatar/00/23/f6/79/caab0680.jpg","nickname":"Water","note":"","ucode":"E896FE350AC854","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333597,"discussion_content":"m\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607571004,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":9,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2346667,"avatar":"","nickname":"Geek_1ec93e","note":"","ucode":"85933C97A6B191","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331657,"discussion_content":"mark\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606922604,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":9,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2329989,"avatar":"https://static001.geekbang.org/account/avatar/00/23/8d/85/672f4118.jpg","nickname":"入幽","note":"","ucode":"70D2263EFD2A86","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327863,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605970898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":9,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1213234,"avatar":"","nickname":"Link","note":"","ucode":"B8CD4145E97305","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327497,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605851096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":9,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1390888,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/xxbUPeglgNkbSdIXuCibRicR5O86R7JiadjZ8oVSDaV8A2ZtGNhHdaySFNibbtynz1RKVNQ2ZFMOgBDcU3jWAINZUw/132","nickname":"Geek_13ca5d","note":"","ucode":"959FFB85EE8ACD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325549,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605343767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":9,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2256670,"avatar":"https://static001.geekbang.org/account/avatar/00/22/6f/1e/03c501d9.jpg","nickname":"Morning","note":"","ucode":"BC305B3657B5CA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318614,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603790631,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":9,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1988215,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/56/77/4851c90c.jpg","nickname":"酒阑人散","note":"","ucode":"F04557D9D698F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312695,"discussion_content":"每次看完文章都会到评论区找题，o(￣▽￣)ｄ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602772782,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":9,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2208317,"avatar":"https://static001.geekbang.org/account/avatar/00/21/b2/3d/13e3ad14.jpg","nickname":"大仙儿","note":"","ucode":"9F2987AE89834F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312489,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602720956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":9,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2229380,"avatar":"https://static001.geekbang.org/account/avatar/00/22/04/84/5f097847.jpg","nickname":"Faraway","note":"","ucode":"687020A48C34F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312057,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602576486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":9,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1445362,"avatar":"https://static001.geekbang.org/account/avatar/00/16/0d/f2/3865fe28.jpg","nickname":"李金鹏","note":"","ucode":"8FCCA5B8BD8DDD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309881,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601477112,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":9,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2189412,"avatar":"https://static001.geekbang.org/account/avatar/00/21/68/64/7f6f0dfd.jpg","nickname":"凌风","note":"","ucode":"7069D4BD8C8DCB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307477,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600663818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":10,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1675882,"avatar":"https://static001.geekbang.org/account/avatar/00/19/92/6a/dd37a054.jpg","nickname":"张y .","note":"","ucode":"85918469492F4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305566,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600002435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":10,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1080180,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7b/74/a4c4838f.jpg","nickname":"hello world","note":"","ucode":"DC5A5FF4B15F91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304450,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599574387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":10,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1017027,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLmbTA2Q3STwUFtZqneSichgc4mKGpvlUsSHTfxkAqwn3ib8IE05lFiaD6zxiaOhbQfa7X68OImoEbRUQ/132","nickname":"醉猩猩","note":"","ucode":"BD22C99EF2CFDA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299440,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597680634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":10,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1896868,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f1/a4/79c36b87.jpg","nickname":"流云","note":"","ucode":"26C5A9166EC6D8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297571,"discussion_content":"别mark，直接做题，我花了一万已经全部做完","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596973124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":10,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2215110,"avatar":"","nickname":"Geek_e8a328","note":"","ucode":"3E17DFDC505EA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1896868,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f1/a4/79c36b87.jpg","nickname":"流云","note":"","ucode":"26C5A9166EC6D8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318033,"discussion_content":"我看你花了一万，以为是钱，原来是一晚","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1603631280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":297571,"ip_address":""},"score":318033,"extra":""}]},{"author":{"id":1202890,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5a/ca/b3d3513e.jpg","nickname":"掌柜","note":"","ucode":"933C65E1638174","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296997,"discussion_content":"m\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596725975,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":10,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2083625,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/cb/29/2059e052.jpg","nickname":"a   d   e","note":"","ucode":"56584BFAC129A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294711,"discussion_content":"谢谢送题小王子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595981076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":10,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2072321,"avatar":"","nickname":"乡里奥特曼","note":"","ucode":"BFC7F60C5C7F90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294487,"discussion_content":"手动马克","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595904369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":10,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1308388,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f6/e4/b6ad9bbd.jpg","nickname":"漂浮群岛","note":"","ucode":"395F8E168562F6","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294410,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595868022,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":10,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1266160,"avatar":"https://static001.geekbang.org/account/avatar/00/13/51/f0/9b7d40fc.jpg","nickname":"萧一狼","note":"","ucode":"35CC9C8FC8DDD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294219,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595832695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":10,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1352981,"avatar":"https://static001.geekbang.org/account/avatar/00/14/a5/15/f911f9c9.jpg","nickname":"过冬了~","note":"","ucode":"BC7B688B7CF4F8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293118,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595434889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":11,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1257919,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK9Feib1vqoTUleb3HCMnLnMohiaMnwbKKAa4b93Tvkr1zGjzJ2fuffibYON2U1Wyibx0kH9Bc72znBXg/132","nickname":"CBr2","note":"","ucode":"3E6ADB62A4643A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291198,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594731180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":11,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1901476,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/03/a4/d39c747c.jpg","nickname":"以帅服人的珂哥","note":"","ucode":"1A94CA2D7980B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290169,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594365273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":11,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1177339,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/icNM21AqdRLez6gq4lzZfgVibSk0eicufVgciaA1GJ5Aj0mFpA7GnAynWqltib3B6qMKubIZL0oicuL4DbjXJoqT7icWw/132","nickname":"老王子","note":"","ucode":"8C5424673141EF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290086,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594342740,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":11,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1526428,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epMicvN0PDCMibmBvwAyoScCjjgfLBWaQwGic9ialXObicxKib9X0T0gx02gL4jqvibEr1FRzMaiaicN8cgEBg/132","nickname":"Geek_ac4080","note":"","ucode":"E2C480962E6CEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290051,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594310233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":11,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2047980,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/3f/ec/00904faa.jpg","nickname":"连长","note":"","ucode":"555BD3DE57887F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290013,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594302679,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":11,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2029224,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f6/a8/e6e70d5a.jpg","nickname":"十八划生","note":"","ucode":"362C945CB008D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288381,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593739417,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":11,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1320766,"avatar":"https://static001.geekbang.org/account/avatar/00/14/27/3e/3387526d.jpg","nickname":"慕羽～","note":"","ucode":"63937A6479EEA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287786,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593534176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":11,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1098624,"avatar":"","nickname":"dream7519","note":"","ucode":"55E229FA55E15C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283121,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592190054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":11,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1383756,"avatar":"https://static001.geekbang.org/account/avatar/00/15/1d/4c/32e06aee.jpg","nickname":"子衿","note":"","ucode":"D8CF0D7D76F389","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278991,"discussion_content":"多谢大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591269032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":11,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2003986,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/94/12/10f114aa.jpg","nickname":"kense","note":"","ucode":"24E524D14913DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":277190,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591015540,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":12,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1237729,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e2/e1/036df099.jpg","nickname":"vice","note":"","ucode":"1BAAADCD7FE135","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271865,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590208031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":12,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188627,"avatar":"https://static001.geekbang.org/account/avatar/00/12/23/13/6ba35b43.jpg","nickname":"leejunhui","note":"","ucode":"A957C0034B9F4D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":240879,"discussion_content":"马克加索尔","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587390545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":12,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1964227,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/f8/c3/50ce63c0.jpg","nickname":"Chromer","note":"","ucode":"477CD684593E76","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":236699,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587116599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":12,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1302264,"avatar":"https://static001.geekbang.org/account/avatar/00/13/de/f8/62a8f99e.jpg","nickname":"Miles","note":"","ucode":"E3595E98A4474D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":234854,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587001692,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":12,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1932991,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/v66ibAlg1VrmVe03RgKWY85cWvfmbdGx5iaadibscmNOpOl7wJv3e2QLqVXHiaiayicqTsmmZqcMTJvnVo7Unz7EBhYw/132","nickname":"耳东","note":"","ucode":"7BA3B60BE0519D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":232578,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586872963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":12,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1309763,"avatar":"https://static001.geekbang.org/account/avatar/00/13/fc/43/66f68b80.jpg","nickname":"一棵白菜","note":"","ucode":"63E023F83027D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":231842,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586831846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":12,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1371229,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ec/5d/45227d75.jpg","nickname":"顽石少年","note":"","ucode":"397B01176626C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":222435,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586144549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":12,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1022267,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/99/3b/791d0f5e.jpg","nickname":"王先森","note":"","ucode":"1AF1A395107479","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213007,"discussion_content":"这是大哥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585042678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":12,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1503064,"avatar":"https://static001.geekbang.org/account/avatar/00/16/ef/58/d05ec302.jpg","nickname":"Frode","note":"","ucode":"B7B8DBF9980EA1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":205510,"discussion_content":"手动点赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584319618,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":12,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1800886,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/7a/b6/f54bbfaa.jpg","nickname":"花郎世纪","note":"","ucode":"301DF9B6375E08","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":140016,"discussion_content":"蟹蟹课代表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579341296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":13,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30598,"user_name":"姜威","can_delete":false,"product_type":"c1","uid":1244051,"ip_address":"","ucode":"C58EB9A5AD634D","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/93/f19a5364.jpg","comment_is_top":false,"comment_ctime":1538958708,"is_pvip":false,"discussion_count":9,"race_medal":0,"score":"1663691302260","product_id":100017301,"comment_content":"一、什么是栈？<br>1.后进者先出，先进者后出，这就是典型的“栈”结构。<br>2.从栈的操作特性来看，是一种“操作受限”的线性表，只允许在端插入和删除数据。<br>二、为什么需要栈？<br>1.栈是一种操作受限的数据结构，其操作特性用数组和链表均可实现。<br>2.但，任何数据结构都是对特定应用场景的抽象，数组和链表虽然使用起来更加灵活，但却暴露了几乎所有的操作，难免会引发错误操作的风险。<br>3.所以，当某个数据集合只涉及在某端插入和删除数据，且满足后进者先出，先进者后出的操作特性时，我们应该首选栈这种数据结构。<br>三、如何实现栈？<br>1.栈的API<br>public class Stack&lt;Item&gt; {<br>\t&#47;&#47;压栈<br>\tpublic void push(Item item){}<br>\t&#47;&#47;弹栈<br>\tpublic Item pop(){}<br>\t&#47;&#47;是否为空<br>\tpublic boolean isEmpty(){}<br>\t&#47;&#47;栈中数据的数量<br>\tpublic int size(){}<br>\t&#47;&#47;返回栈中最近添加的元素而不删除它<br>\tpublic Item peek(){}<br>}<br>2.数组实现（自动扩容）<br>时间复杂度分析：根据均摊复杂度的定义，可以得数组实现（自动扩容）符合大多数情况是O(1)级别复杂度，个别情况是O(n)级别复杂度，比如自动扩容时，会进行完整数据的拷贝。<br>空间复杂度分析：在入栈和出栈的过程中，只需要一两个临时变量存储空间，所以O(1)级别。我们说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。<br>实现代码：（见另一条留言）<br><br>3.链表实现<br>时间复杂度分析：压栈和弹栈的时间复杂度均为O(1)级别，因为只需更改单个节点的索引即可。<br>空间复杂度分析：在入栈和出栈的过程中，只需要一两个临时变量存储空间，所以O(1)级别。我们说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。<br>实现代码：（见另一条留言）<br><br>四、栈的应用<br>1.栈在函数调用中的应用<br>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构，用来存储函数调用时的临时变量。每进入一个函数，就会将其中的临时变量作为栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。<br>2.栈在表达式求值中的应用（比如：34+13*9+44-12&#47;3）<br>利用两个栈，其中一个用来保存操作数，另一个用来保存运算符。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较，若比运算符栈顶元素优先级高，就将当前运算符压入栈，若比运算符栈顶元素的优先级低或者相同，从运算符栈中取出栈顶运算符，从操作数栈顶取出2个操作数，然后进行计算，把计算完的结果压入操作数栈，继续比较。<br>3.栈在括号匹配中的应用（比如：{}{[()]()}）<br>用栈保存为匹配的左括号，从左到右一次扫描字符串，当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号，如果能匹配上，则继续扫描剩下的字符串。如果扫描过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。<br>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明未匹配的左括号为非法格式。<br>4.如何实现浏览器的前进后退功能？<br>我们使用两个栈X和Y，我们把首次浏览的页面依次压如栈X，当点击后退按钮时，再依次从栈X中出栈，并将出栈的数据一次放入Y栈。当点击前进按钮时，我们依次从栈Y中取出数据，放入栈X中。当栈X中没有数据时，说明没有页面可以继续后退浏览了。当Y栈没有数据，那就说明没有页面可以点击前进浏览了。<br>五、思考<br>1. 我们在讲栈的应用时，讲到用函数调用栈来保存临时变量，为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？<br>答：因为函数调用的执行顺序符合后进者先出，先进者后出的特点。比如函数中的局部变量的生命周期的长短是先定义的生命周期长，后定义的生命周期短；还有函数中调用函数也是这样，先开始执行的函数只有等到内部调用的其他函数执行完毕，该函数才能执行结束。<br>正是由于函数调用的这些特点，根据数据结构是特定应用场景的抽象的原则，我们优先考虑栈结构。<br>2.我们都知道，JVM 内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储 Java 中的对象。那 JVM 里面的“栈”跟我们这里说的“栈”是不是一回事呢？如果不是，那它为什么又叫作“栈”呢？<br>答：JVM里面的栈和我们这里说的是一回事，被称为方法栈。和前面函数调用的作用是一致的，用来存储方法中的局部变量。","like_count":387,"discussions":[{"author":{"id":1358620,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bb/1c/d216003b.jpg","nickname":"人丑就要多读书","note":"","ucode":"0855D65E1CE7B0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289242,"discussion_content":"链表实现：空间复杂度分析：在入栈和出栈的过程中，只需要一两个临时变量存储空间，所以O(1)级别。那指针所占的空间不算吗？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1594037758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1909732,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLY0FFoux40Negib6LrE7EwT3T2BUbpYzOzUeiaiaXBmNGDGVgIZr5NeWBTEeCuALOg3ODtWa21bHMgg/132","nickname":"Geek_99ae14","note":"","ucode":"268852986A6B69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1358620,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bb/1c/d216003b.jpg","nickname":"人丑就要多读书","note":"","ucode":"0855D65E1CE7B0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295709,"discussion_content":"临时变量空间复杂度一般都是O（1）级别","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596293505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":289242,"ip_address":""},"score":295709,"extra":""}]},{"author":{"id":1397298,"avatar":"https://static001.geekbang.org/account/avatar/00/15/52/32/bb570f48.jpg","nickname":"向往的生活","note":"","ucode":"0E8DB45357820F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223850,"discussion_content":"我直接来看老哥的笔记","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1586258461,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1180307,"avatar":"https://static001.geekbang.org/account/avatar/00/12/02/93/44672231.jpg","nickname":"seven","note":"","ucode":"55CE5F60051F89","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72819,"discussion_content":"老哥，你的回答太棒了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575531531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2888057,"avatar":"","nickname":"吖明想去大厂","note":"","ucode":"54D9C60C057D79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547423,"discussion_content":"酷 就需要这样的笔记","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642668204,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2275817,"avatar":"https://static001.geekbang.org/account/avatar/00/22/b9/e9/19cd7d9c.jpg","nickname":"落","note":"","ucode":"79525752D3A1B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374530,"discussion_content":"大哥厉害，居然看懂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621235851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1548645,"avatar":"https://static001.geekbang.org/account/avatar/00/17/a1/65/44853770.jpg","nickname":"Hi Young","note":"","ucode":"E1E9C88399F3C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275493,"discussion_content":"课代表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590721629,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1255160,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/NnefngARTSPK2qLfYenRjDCNSv7NdGpia05NowusiarIvglJibkJn1WMnj2EzicgBay3XWbWpiaCfQJVr3PAeXcghzw/132","nickname":"民工哦","note":"","ucode":"6B6585EBBFC18A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":253470,"discussion_content":"优秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588237309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1317847,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1b/d7/868d26ce.jpg","nickname":"songhyunmin","note":"","ucode":"D5A98668CD8532","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54235,"discussion_content":"你是做游戏的吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574274670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":true,"id":36338,"user_name":"王争","can_delete":false,"product_type":"c1","uid":1190123,"ip_address":"","ucode":"2B611BE0E0EDD4","user_header":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","comment_is_top":false,"comment_ctime":1541042699,"is_pvip":false,"replies":[{"id":"12963","content":"答案 大家可以参考下","user_name":"作者回复","comment_id":36338,"uid":"1190123","ip_address":"","utype":1,"ctime":1541124588,"user_name_real":"gg"}],"discussion_count":9,"race_medal":0,"score":"1341570839051","product_id":100017301,"comment_content":"为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？<br><br>其实，我们不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。<br><br>从调用函数进入被调用函数，对于数据来说，变化的是什么呢？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。","like_count":313,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427837,"discussion_content":"答案 大家可以参考下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541124588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1255160,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/NnefngARTSPK2qLfYenRjDCNSv7NdGpia05NowusiarIvglJibkJn1WMnj2EzicgBay3XWbWpiaCfQJVr3PAeXcghzw/132","nickname":"民工哦","note":"","ucode":"6B6585EBBFC18A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":253472,"discussion_content":"大家可以看看这篇文章https://zhuanlan.zhihu.com/p/27339191","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588237375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1401217,"avatar":"https://static001.geekbang.org/account/avatar/00/15/61/81/9e34165b.jpg","nickname":"rovernerd","note":"","ucode":"C8620AAF0E4920","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":12519,"discussion_content":"顺序性","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568540608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2188198,"avatar":"https://static001.geekbang.org/account/avatar/00/21/63/a6/5b5879e7.jpg","nickname":"Wim","note":"","ucode":"82CDA3F0F0CC51","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337999,"discussion_content":"函数执行所有需要的内存空间都是分配在虚拟内存的“栈”区，每个函数都有一段对应的一段内存空间“栈帧”。A函数调用B函数时会在栈区给B函数调用分配一段&#34;栈帧&#34;空间，A函数栈帧结束的地址紧挨着B函数栈帧的起始地址。每个函数内部的局部变量，都是分配在自己的栈帧区域，当函数返回时，栈帧内的所有内存也一起释放。   ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609149179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1926508,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/65/6c/be97a3ae.jpg","nickname":"Geek_bb2310","note":"","ucode":"022885B257DEB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":259129,"discussion_content":"嗯嗯\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588762869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1930723,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/75/e3/ef489d57.jpg","nickname":"Roy","note":"","ucode":"909B8B605C317A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":236246,"discussion_content":"这个说法好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587084069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1611484,"avatar":"https://static001.geekbang.org/account/avatar/00/18/96/dc/58ccf3f3.jpg","nickname":"卡卡","note":"","ucode":"F0D6471CA06A6C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8298,"discussion_content":"在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。这句话能不能充分解释一下？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567907411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1566520,"avatar":"https://static001.geekbang.org/account/avatar/00/17/e7/38/f3e9a2d0.jpg","nickname":"MIddlem","note":"","ucode":"EDD27C848385E3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1611484,"avatar":"https://static001.geekbang.org/account/avatar/00/18/96/dc/58ccf3f3.jpg","nickname":"卡卡","note":"","ucode":"F0D6471CA06A6C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":32203,"discussion_content":"理解一下“进入被调用函数的时候，分配一段栈空间给这个函数的变量”，应该就能明白了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571016246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":8298,"ip_address":""},"score":32203,"extra":""},{"author":{"id":2326134,"avatar":"https://static001.geekbang.org/account/avatar/00/23/7e/76/368394bf.jpg","nickname":"哦","note":"","ucode":"C776659DED9D79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1611484,"avatar":"https://static001.geekbang.org/account/avatar/00/18/96/dc/58ccf3f3.jpg","nickname":"卡卡","note":"","ucode":"F0D6471CA06A6C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331531,"discussion_content":"其实底层实现就是一个寄存器中存储着当前栈顶在内存中的地址，如果地址空间是向低地址方向“增长”，当调用函数的时候分配栈空间，寄存器中的值相应的减少，当方法调用结束的时候，寄存器的值相应的增加","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1606894428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":8298,"ip_address":""},"score":331531,"extra":""}]}]},{"had_liked":false,"id":30616,"user_name":"阿杜S考特","can_delete":false,"product_type":"c1","uid":1080257,"ip_address":"","ucode":"0107E78B815B66","user_header":"https://static001.geekbang.org/account/avatar/00/10/7b/c1/22fbcab2.jpg","comment_is_top":false,"comment_ctime":1538960615,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"912072027367","product_id":100017301,"comment_content":"        内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。<br>        内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区。<br>代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。<br>静态数据区：存储全局变量、静态变量、常量，常量包括final修饰的常量和String常量。系统自动分配和回收。<br>栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。<br>堆区：new一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。<br><br>","like_count":212,"discussions":[{"author":{"id":1045078,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f2/56/c39046c0.jpg","nickname":"Jie","note":"","ucode":"AB94041E548FEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":63979,"discussion_content":"摸鱼看算法的时候惊现阿杜回复。。。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574928240,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1080257,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7b/c1/22fbcab2.jpg","nickname":"阿杜S考特","note":"","ucode":"0107E78B815B66","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1045078,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f2/56/c39046c0.jpg","nickname":"Jie","note":"","ucode":"AB94041E548FEB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":190717,"discussion_content":"这不是校长吧？🙌","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582973669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":63979,"ip_address":""},"score":190717,"extra":""},{"author":{"id":1045078,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f2/56/c39046c0.jpg","nickname":"Jie","note":"","ucode":"AB94041E548FEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1080257,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7b/c1/22fbcab2.jpg","nickname":"阿杜S考特","note":"","ucode":"0107E78B815B66","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":190719,"discussion_content":"哈哈，当然是我","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582973813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":190717,"ip_address":""},"score":190719,"extra":""}]},{"author":{"id":1638878,"avatar":"https://static001.geekbang.org/account/avatar/00/19/01/de/bf524817.jpg","nickname":"慌张而黑糖","note":"","ucode":"B4416885A301C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49681,"discussion_content":"那平时说的常量池是在静态数据区，是吗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573620227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1270632,"avatar":"https://static001.geekbang.org/account/avatar/00/13/63/68/14b98bbc.jpg","nickname":"大鹏","note":"","ucode":"F4611B80B08A3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554663,"discussion_content":"全局变量是对象级的，因该在堆里面","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646540956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1085152,"avatar":"https://static001.geekbang.org/account/avatar/00/10/8e/e0/847348b1.jpg","nickname":"爱学习的大叔","note":"","ucode":"91F9ABF1EC98D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":190510,"discussion_content":"莫不是传说中的大神，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582952599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1468773,"avatar":"https://static001.geekbang.org/account/avatar/00/16/69/65/eb778125.jpg","nickname":"左琪","note":"","ucode":"6B797070168A12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":154129,"discussion_content":"java里平时说的常量池一般指的是运行时常量池","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580120982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30587,"user_name":"我是辣妈","can_delete":false,"product_type":"c1","uid":1239283,"ip_address":"","ucode":"F1576240250AFA","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/f3/01ce824b.jpg","comment_is_top":false,"comment_ctime":1538957008,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"675848822480","product_id":100017301,"comment_content":"函数调用之所以用栈，是因为函数调用中经常嵌套，栗子：A调用B，B又调用C，那么就需要先把C执行完，结果赋值给B中的临时变量，B的执行结果再赋值给A的临时变量，嵌套越深的函数越需要被先执行，这样刚好符合栈的特点，因此每次遇到函数调用，只需要压栈，最后依次从栈顶弹出依次执行即可，这个过程很像文稿中的3+5*8-6&#47;&#47;小白之拙见，欢迎拍砖*^o^*","like_count":157,"discussions":[{"author":{"id":1911733,"avatar":"","nickname":"且听风吟","note":"","ucode":"51549E28661CEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":218249,"discussion_content":"你还说你不会武功？","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1585636832,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1245956,"avatar":"https://static001.geekbang.org/account/avatar/00/13/03/04/44692930.jpg","nickname":"Rick","note":"","ucode":"E088D8AA9E985F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":160008,"discussion_content":"还是你说的让我理解","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580742543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65646,"discussion_content":"em 个人理解，通俗点讲：方法体 进入的时候 开辟新的空间 入栈，方法体结束的时候，新栈整个出栈（本身  新栈就在旧栈上）","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575018223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2161180,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/jtNYcW0hUoI1RzVic1tpJ7mkh4nccicC3aaC4aicYQCy9R1RZBMSWn8qDxjvVKqca9LnWxCfsicEqeW0bUkX6Bogyg/132","nickname":"Geek_d586af","note":"","ucode":"2966DBC6BD9B20","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333482,"discussion_content":"说的很，很容易理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607527212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1129309,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3b/5d/15c4817a.jpg","nickname":"xxxxL","note":"","ucode":"F84BB5ACD1241E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77051,"discussion_content":"说的太好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575883992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1615539,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI6LXcIqb5K48nia8d4zmdsD1M9AZeyXoGrLzX5xvqfN0fqXOsYKUWLbZvZ8TtJCXWmYbCkCXg93dQ/132","nickname":"漏脚脖","note":"","ucode":"214AE52EC201E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3256,"discussion_content":"看了好多留言，一直没明白函数是编译的时候压栈吗，然后在运行的时候取？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564359344,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1054201,"avatar":"https://static001.geekbang.org/account/avatar/00/10/15/f9/0b14785a.jpg","nickname":"三三","note":"","ucode":"4A76933C29BDA1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1615539,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI6LXcIqb5K48nia8d4zmdsD1M9AZeyXoGrLzX5xvqfN0fqXOsYKUWLbZvZ8TtJCXWmYbCkCXg93dQ/132","nickname":"漏脚脖","note":"","ucode":"214AE52EC201E6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65541,"discussion_content":"编译时不压栈，代码运行时函数才会压栈出栈","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575011050,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3256,"ip_address":""},"score":65541,"extra":""}]}]},{"had_liked":true,"id":34594,"user_name":"清以轻尘","can_delete":false,"product_type":"c1","uid":1234439,"ip_address":"","ucode":"FB3AB805491F9E","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/07/e6e28712.jpg","comment_is_top":false,"comment_ctime":1540214847,"is_pvip":false,"replies":[{"id":"12304","content":"也可以的 👍","user_name":"作者回复","comment_id":34594,"uid":"1190123","ip_address":"","utype":1,"ctime":1540221326,"user_name_real":"gg"}],"discussion_count":4,"race_medal":0,"score":"379497336895","product_id":100017301,"comment_content":"关于这个浏览器的前进和后退，老师您说的是用两个栈实现，其实开篇我已经想到，但是，我还有一个很不错的解决思路，对于内存消耗可能会高点，但是时间复杂度也很低，就是使用双向链表，用 pre和next 来实现前进和后退","like_count":88,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427264,"discussion_content":"也可以的 👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540221326,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2780974,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/6f/2e/8075aa08.jpg","nickname":"洪yf","note":"","ucode":"0470D5CC430C99","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404416,"discussion_content":"我咋觉得用一个栈就能实现，之前做了一个文件管理器，就是当我访问下一层的时候\n把这一层对应的数据入栈，返回的时候只要将栈顶元素出栈就能返回","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1634303507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65648,"discussion_content":"em 第一想法就是双向链表。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575018361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1689284,"avatar":"https://static001.geekbang.org/account/avatar/00/19/c6/c4/12f24def.jpg","nickname":"脚踏实地","note":"","ucode":"FEEB4D71D388C8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24605,"discussion_content":"嗯嗯，数组加上两个index也可以搞定","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570194417,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73584,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1551931985,"is_pvip":false,"discussion_count":9,"race_medal":0,"score":"358034217553","product_id":100017301,"comment_content":"置顶的留言中还有一个问题没有回答——为什么内存中的“栈”也叫“栈”，而且英文都是stack？<br><br>我认为，虽然内存中的栈和数据结构的栈不是一回事，即内存中的栈是一段虚拟的内存空间，数据结构中的栈是一种抽象的数据类型，但是它们都有“栈”的特性——后进先出，所以都叫“栈”也无可厚非。<br><br>-----<br><br>还有，置顶留言中说，内存中的堆栈是真实存在的物理区，这个说法有点不精确，因为大部分人所说的，以及应用编程中所用到的内存，一般情况下指的都是虚拟内存空间，英文为：Virtual Memory，是物理内存的映射。","like_count":83,"discussions":[{"author":{"id":1482915,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","nickname":"业余爱好者","note":"","ucode":"A890935A982988","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60686,"discussion_content":"内存中的栈是一段虚拟内存空间，数据结构栈是ADT。关于数据结构与数据类型的区别稍稍释然了。。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574745931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238051,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/23/ac13d916.jpg","nickname":"圆哥哥呐丶","note":"","ucode":"8E56E3E68A3836","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4150,"discussion_content":"确实，置顶的那条留言 给人迷惑\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1565170154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1069206,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/96/18612c89.jpg","nickname":"克","note":"","ucode":"6DDFBB05E0F4E9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":67510,"discussion_content":"非常认同","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575129554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2823579,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/15/9b/0d8b9c2e.jpg","nickname":"Goodrain7","note":"","ucode":"32A39D3D1580E9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407981,"discussion_content":"虚拟内存空间是正解，不是实际物理地址","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635163252,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1101791,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/df/abb7bfe3.jpg","nickname":"Allen","note":"","ucode":"C088A4724A653F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295845,"discussion_content":"难道不能把内存里的栈理解为数据结构栈的一种实现吗\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596363640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2555914,"avatar":"https://static001.geekbang.org/account/avatar/00/27/00/0a/078e4347.jpg","nickname":"东","note":"","ucode":"98A57ADA38A7DF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1101791,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/df/abb7bfe3.jpg","nickname":"Allen","note":"","ucode":"C088A4724A653F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531641,"discussion_content":"可以啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637372211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":295845,"ip_address":""},"score":531641,"extra":"{\"user_type\":1}"}]},{"author":{"id":2001792,"avatar":"","nickname":"Geek_bbf495","note":"","ucode":"B66060ADE1D99F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265997,"discussion_content":"物理上都是电路","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589463745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1583499,"avatar":"https://static001.geekbang.org/account/avatar/00/18/29/8b/3629c0f8.jpg","nickname":"游山行人","note":"","ucode":"E559BD0A3C6484","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":218116,"discussion_content":"是的，对于程序员那一层而言我们用到的都是虚拟内存，由虚拟内存空间再映射到物理内存空间。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585621310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1926508,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/65/6c/be97a3ae.jpg","nickname":"Geek_bb2310","note":"","ucode":"022885B257DEB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1583499,"avatar":"https://static001.geekbang.org/account/avatar/00/18/29/8b/3629c0f8.jpg","nickname":"游山行人","note":"","ucode":"E559BD0A3C6484","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":259130,"discussion_content":"leetcode过来的吧，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588762979,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":218116,"ip_address":""},"score":259130,"extra":""}]}]},{"had_liked":false,"id":31280,"user_name":"鲫鱼","can_delete":false,"product_type":"c1","uid":1240828,"ip_address":"","ucode":"ACB8E3317FFE99","user_header":"https://static001.geekbang.org/account/avatar/00/12/ee/fc/9b72e224.jpg","comment_is_top":false,"comment_ctime":1539141981,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"345136525661","product_id":100017301,"comment_content":"对我来说理解有些困难，所以姜威的笔记给了我很大的帮助的。给了我更好完善笔记的构架，以及用不同方式解释加深理解和记忆。真的有的人不喜欢看不看就好，划掉不过两秒的事情。","like_count":80},{"had_liked":false,"id":85090,"user_name":"小邓","can_delete":false,"product_type":"c1","uid":1474505,"ip_address":"","ucode":"1E903D5622D39F","user_header":"https://static001.geekbang.org/account/avatar/00/16/7f/c9/40c609ee.jpg","comment_is_top":false,"comment_ctime":1554976492,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"297907719916","product_id":100017301,"comment_content":"课后思考问题2是多次困扰我的一个问题：内存管理上的“栈”和数据结构上的“栈”到底是不是一回事。<br>按出题套路而言，问“如果不是，给出理由”的问题答案大多是“不是”。高赞留言里有的说是，有的说不是，我简单翻了翻三大本厚书《C#图接教程》、《算法》、《深入理解计算机基础》，再去翻了翻相关博客和知乎，我的回答是“不是”。<br>（1）首先，在内存管理和数据结构上，都有“堆”和“栈”这两个概念。<br>（2）内存管理上的“堆”和“栈”，强调的是数据的生命周期（分配释放是否有次序要求）；数据结构上的“堆”和“栈”，强调的是数据的组织。<br>（3）内存管理上的“栈”符合数据结构的“栈”的特点，即LIFO，两者同名可以接受。<br>（4）数据结构上的“堆”定义：它是一种数组对象，它可以被视为一科完全二叉树结构；应用场景包括堆排序，优先队列等。和内存管理的“堆”定义不同（这里我不是很确定，没有看过内存管理上堆的实现细节）。<br><br>参考：<br>（1）数据结构之“堆”：http:&#47;&#47;www.cnblogs.com&#47;Jason-Damon&#47;archive&#47;2012&#47;04&#47;18&#47;2454649.html<br>（2）专题 | 堆、栈简介：https:&#47;&#47;zhuanlan.zhihu.com&#47;p&#47;45597548<br>（3）知乎| 为什么c++中要分为heap（堆）和stack（栈）? - Milo Yip的回答：https:&#47;&#47;www.zhihu.com&#47;question&#47;281940376&#47;answer&#47;424990646","like_count":69,"discussions":[{"author":{"id":1397149,"avatar":"https://static001.geekbang.org/account/avatar/00/15/51/9d/e6947e9b.jpg","nickname":"遇事不决，量子力学","note":"","ucode":"6E5B015F4E427B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320610,"discussion_content":"点赞，学堆的时候验证一下你的第4点内容","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604412702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1329602,"avatar":"https://static001.geekbang.org/account/avatar/00/14/49/c2/9d63fb84.jpg","nickname":"Fantasy","note":"","ucode":"3CEE50354057A6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279975,"discussion_content":"我觉得你这个留言应该置顶一下。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591456503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2055194,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLbuXiafdYFyFsytMspswIM4EbnhtkGicCxZpo4iaQHiaibVVMz0SwtA8xyXbpAPWDsmrKcdz2jQRKxImQ/132","nickname":"chenqi","note":"","ucode":"99B1968262003D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289952,"discussion_content":"JVM栈由栈帧组成，符合先进后出，后进先出规则为啥不和数据结构的栈是一个概念？数据结构的栈在计算机上面不需要内存怎么实现？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594278866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30601,"user_name":"姜威","can_delete":false,"product_type":"c1","uid":1244051,"ip_address":"","ucode":"C58EB9A5AD634D","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/93/f19a5364.jpg","comment_is_top":false,"comment_ctime":1538958910,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"246352094782","product_id":100017301,"comment_content":"实现代码：（栈的数组实现）<br>public class StackOfArray&lt;Item&gt; implements Iterable&lt;Item&gt;{<br>&#47;&#47;存储数据的数组<br>Item[] a = (Item[])new Object[1];<br>&#47;&#47;记录元素个数N<br>int N = 0;<br>&#47;&#47;构造器<br>public StackOfArray(){}<br>&#47;&#47;添加元素<br>public void push(Item item){<br>&#47;&#47;自动扩容<br>if (N == a.length ) resize(2*a.length );<br>a[N++] = item;<br>}<br>&#47;&#47;删除元素<br>public Item pop(){<br>Item item = a[--N];<br>a[N] = null;<br>if (N &gt; 0 &amp;&amp; N == a.length &#47; 4) resize(a.length &#47; 2);<br>return item;<br>}<br>&#47;&#47;是否为空<br>public boolean isEmpty(){<br>return N == 0;<br>}<br>&#47;&#47;元素个数<br>public int size(){<br>return N;<br>}<br>&#47;&#47;改变数组容量<br>private void resize(int length) {<br>Item[] temp = (Item[])new Object[length];<br>for (int i = 0; i &lt; N; i++) {<br>temp[i] = a[i];<br>}<br>a = temp;<br>}<br>&#47;&#47;返回栈中最近添加的元素而不删除它<br>public Item peek(){<br>return a[N-1];<br>}<br>@Override<br>public Iterator&lt;Item&gt; iterator() {<br>return new ArrayIterator();<br>}<br>&#47;&#47;内部类<br>class ArrayIterator implements Iterator{<br>&#47;&#47;控制迭代数量<br>int i = N;<br>@Override<br>public boolean hasNext() {<br>return i &gt; 0;<br>}<br>@Override<br>public Item next() {<br>return a[--i];<br>}<br>}<br>}<br><br>实现代码：（栈的链表实现）<br>public class StackOfLinked&lt;Item&gt; implements Iterable&lt;Item&gt; {<br>&#47;&#47;定义一个内部类，就可以直接使用类型参数<br>private class Node{<br>Item item;<br>Node next;<br>}<br>private Node first;<br>private int N;<br>&#47;&#47;构造器<br>public StackOfLinked(){}<br>&#47;&#47;添加<br>public void push(Item item){<br>Node oldfirst = first;<br>first = new Node();<br>first.item = item;<br>first.next = oldfirst;<br>N++;<br>}<br>&#47;&#47;删除<br>public Item pop(){<br>Item item = first.item;<br>first = first.next;<br>N--;<br>return item;<br>}<br>&#47;&#47;是否为空<br>public boolean isEmpty(){<br>return N == 0;<br>}<br>&#47;&#47;元素数量<br>public int size(){<br>return N;<br>}<br>&#47;&#47;返回栈中最近添加的元素而不删除它<br>public Item peek(){<br>return first.item;<br>}<br>@Override<br>public Iterator&lt;Item&gt; iterator() {<br>return new LinkedIterator();<br>}<br>&#47;&#47;内部类：迭代器<br>class LinkedIterator implements Iterator{<br>int i = N;<br>Node t = first;<br>@Override<br>public boolean hasNext() {<br>return i &gt; 0;<br>}<br>@Override<br>public Item next() {<br>Item item = (Item) t.item;<br>t = t.next;<br>i--;<br>return item;<br>} <br>}<br>}","like_count":57,"discussions":[{"author":{"id":1066838,"avatar":"https://static001.geekbang.org/account/avatar/00/10/47/56/e22477c7.jpg","nickname":"Crazy.","note":"","ucode":"FB093FE6E0A66B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74956,"discussion_content":"//改变数组容量\nprivate void resize(int length) {\nItem[] temp = (Item[])new Object[length];\nfor (int i = 0; i < N; i++) {\ntemp[i] = a[i];\n}\na = temp;\n} 这个可以直接用 System.arraycopy","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575710219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2260390,"avatar":"https://static001.geekbang.org/account/avatar/00/22/7d/a6/15798bf2.jpg","nickname":"温雅小公子","note":"","ucode":"9EA63E36D7C85C","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405293,"discussion_content":"兄台，可否将应用的代码也分享下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634550258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":true,"id":31024,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1539070960,"is_pvip":false,"replies":[{"id":"11173","content":"关于思考题 很多同学的留言都已经回答的很好了 关于权威答案 我可以集中写篇文章说说","user_name":"作者回复","comment_id":31024,"uid":"1190123","ip_address":"","utype":1,"ctime":1539082783,"user_name_real":"gg"}],"discussion_count":1,"race_medal":0,"score":"181927697392","product_id":100017301,"comment_content":"对于每次留下的思考题都希望老师在n（n&gt;1）天后给出权威的答案，谢谢。<br>国庆在家里只看文档和听音频没有记录笔记，回去工作了，一定补上。个人认为本课题是最实惠的知识付费，没有之一。❤","like_count":42,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426187,"discussion_content":"关于思考题 很多同学的留言都已经回答的很好了 关于权威答案 我可以集中写篇文章说说","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1539082783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30600,"user_name":"thewangzl","can_delete":false,"product_type":"c1","uid":1006661,"ip_address":"","ucode":"5968FDED0C5AC8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/45/2fa66e67.jpg","comment_is_top":false,"comment_ctime":1538958882,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"117503075874","product_id":100017301,"comment_content":"JVM中的“栈”应该有两个。<br>一个是每个线程中方法调用用到的栈。该栈以栈帧为元素，当调用一个方法时，会把方法相关的局部变量表、操作数栈、方法返回地址等信息封装到栈帧中，把该栈帧入栈；当方法执行结束后，把该栈帧出栈。<br>第二个栈就是栈帧中的操作数栈。JVM的解释执行引擎是“基于栈的执行引擎”，是因为JVM的指令都是对操作数栈中的元素进行入栈出栈操作。<br>两者应该都是标准的栈。","like_count":27,"discussions":[{"author":{"id":1134288,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","nickname":"Ken张云忠","note":"","ucode":"D0BAC9FC17DE2B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":237679,"discussion_content":"虚拟机栈中的栈元素是栈桢,栈桢存储了方法的局部变量表/操作数栈/动态链接和方法返回地址等信息,虚拟机栈可以理解为线程.当有方法调用时需要分配额外的内存空间作为操作数栈来生成新的栈桢并将该栈桢压入虚拟机栈中,当方法调用执行完成后就从虚拟机栈中出栈.\n操作数栈用来存放操作数以及返回结果,操作数栈的压栈弹栈都是一条条指令完成的.例如3+5,会先将3和5两个数压入栈中,当调用iadd指令时会先将5和3弹栈,再将结果8压入栈中,然后继续后续的指令操作.\n本地方法栈主要用来存放Java调用C函数时传递的引用类型参数.\n虚拟机栈/栈桢中的操作数栈和本地方法栈在操作时都符合后进先出的特点,所以都是栈.","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1587177557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1952958,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqJE5Y62XOTFc7B25pqzmI6nqInMmVNSAic8Yg3hsDbgtVb3ovFib4wUUwOficbKkuicOGvCqm8r761Fw/132","nickname":"Geek_0de10a","note":"","ucode":"ECA4552867055C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223869,"discussion_content":"JVM中有两个栈，虚拟机栈，本地方法栈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586259633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":58632,"user_name":"席尔","can_delete":false,"product_type":"c1","uid":1236527,"ip_address":"","ucode":"697384FF090601","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/RRphehcOju6viaKMicXwhZATXZAT7I7zShCiaXB8icwtDk92lic7nyXK25upY3qI55Mt1jvviayQwicPFAjdeFkJxONJQ/132","comment_is_top":false,"comment_ctime":1547162537,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"83151541161","product_id":100017301,"comment_content":"老师早上好!想请问下:如果当前栈大小为 K，并且已满，当再有新的数据要入栈时，就需要重新申请 2 倍大小的内存，并且做 K 个数据的搬移操作，然后再入栈。但是，接下来的 K-1 次入栈操作？ <br> 不是k次入栈操作吗？为什么是k–1次？  新的栈空间还剩余k的大小呀，不是还能进行k次入栈操作吗？麻烦老师解答一下，非常感谢!","like_count":19,"discussions":[{"author":{"id":1042685,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/fd/abb7bfe3.jpg","nickname":"Langzi233","note":"","ucode":"5A21AC08FC089B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":194871,"discussion_content":"容量为K，前面K次入栈都只需要简单的入栈操作。\n第K+1次触发扩容，扩容的时候需要搬移原来的K个元素，然后加上此次的元素入栈，把第K+1的入栈和扩容搬移数据操作放一起理解，因为这都是由第K+1个元素入栈引起。\n在次基础上，新的栈还剩K-1的空间，即老师说的后续k-1个元素都是简单的入栈操作。","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1583244795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1240727,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ee/97/aec1d845.jpg","nickname":"","note":"","ucode":"FB0CE2F0055452","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1042685,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/fd/abb7bfe3.jpg","nickname":"Langzi233","note":"","ucode":"5A21AC08FC089B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223688,"discussion_content":"理解满分","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586246100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":194871,"ip_address":""},"score":223688,"extra":""}]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":23048,"discussion_content":"可以这么理解：当前栈的大小为K，并且已经存了K个元素，当进行第K+1个元素的入栈时，栈的容量不足了，进行扩容，此时栈的容量为2K，扩容完成后需要将当前要入栈的元素考虑进去啊，因此剩余栈的容量为2K-K-1为K-1个，这个K-1就是文中的K-1","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1569747802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1652836,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epKJlW7sqts2ZbPuhMbseTAdvHWnrc4ficAeSZyKibkvn6qyxflPrkKKU3mH6XCNmYvDg11tB6y0pxg/132","nickname":"pc","note":"","ucode":"1AD538B9A900B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":168989,"discussion_content":"只是如何规划起点终点。而且摊还的话我的理解是即便是少了一/二/三...次其实也无所谓。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581600263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1079358,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/3e/44e37b34.jpg","nickname":"一杯酒","note":"","ucode":"D04AEDD5CA0CB0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4508,"discussion_content":"扩容的时候操作了一次","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565502481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1380439,"avatar":"https://static001.geekbang.org/account/avatar/00/15/10/57/44dcd5ec.jpg","nickname":"lrvy","note":"","ucode":"751D791A98E3AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1615,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562733820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1325589,"avatar":"https://static001.geekbang.org/account/avatar/00/14/3a/15/63f8ca96.jpg","nickname":"林阳","note":"","ucode":"DBE1930EB2B636","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1234,"discussion_content":"我理解，搬的时候，把那次放进去了，😂","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1562425107,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1137353,"avatar":"https://static001.geekbang.org/account/avatar/00/11/5a/c9/933ee0a8.jpg","nickname":"冉野","note":"","ucode":"2CAEA424996876","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1026,"discussion_content":"我也是有同样的疑问，请问你是这么理解的呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562246929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30657,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1538966530,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"83143345154","product_id":100017301,"comment_content":"1 函数调用和返回符合后进先出原则，而局部变量的生命周期应该和函数一致，因此用栈保存局部变量是合适的，函数出栈时同时销毁局部变量<br><br>2 jvm的栈就是一种栈数据结构，本质相同","like_count":19},{"had_liked":false,"id":30605,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1538959261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"74553403293","product_id":100017301,"comment_content":"函数调用为什么用栈实现，其中一个原因是为了满足递归的需求。","like_count":17},{"had_liked":false,"id":73658,"user_name":"荣思敏","can_delete":false,"product_type":"c1","uid":1258957,"ip_address":"","ucode":"50689C9D89846A","user_header":"https://static001.geekbang.org/account/avatar/00/13/35/cd/5bb487a0.jpg","comment_is_top":false,"comment_ctime":1551952071,"is_pvip":false,"replies":[{"id":"27371","content":"你说的没错！是的。","user_name":"作者回复","comment_id":73658,"uid":"1190123","ip_address":"","utype":1,"ctime":1552357852,"user_name_real":"gg"}],"discussion_count":2,"race_medal":0,"score":"70271428807","product_id":100017301,"comment_content":"王老师，”你应该可以看出来，这 K 次入栈操作，总共涉及了 K 个数据搬移，以及 K 次 simple-push 操作“-----文章中的这句话，我觉得应该是2K次入栈操作，前K次做了数据搬移(时间复杂度O(1))，第K+1次要扩容，对应的时间复杂度是O(k),后面的k-1时间复杂度是O(1),所以这2K次的操作平摊下来就是O(1)-----是这么理解么？我并不是想钻牛角尖，只是希望真正理解你说的这个概念哈，虽然结果是一样，但我想知道我想错了没有","like_count":16,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442208,"discussion_content":"你说的没错！是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552357852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1943619,"avatar":"","nickname":"进击的小菜","note":"","ucode":"DEDC4D31DA0DF1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":218574,"discussion_content":"谢谢解决了我的疑问😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585666023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30813,"user_name":"乘坐Tornado的线程魔法师","can_delete":false,"product_type":"c1","uid":1132661,"ip_address":"","ucode":"C4C9915866E769","user_header":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","comment_is_top":false,"comment_ctime":1539002104,"is_pvip":false,"replies":[{"id":"11134","content":"思路一样的 可以把右括号看作优先级最高的 至于左括号怎么处理 留给你思考吧😄","user_name":"作者回复","comment_id":30813,"uid":"1190123","ip_address":"","utype":1,"ctime":1539053002,"user_name_real":"gg"}],"discussion_count":8,"race_medal":0,"score":"65963511544","product_id":100017301,"comment_content":"想借此机会请教一个问题，同时也算是给大家的一道思考题。如果文中计算表达式的例子 涉及到小括号(默认小括号使用合法) 该如何处理呢？","like_count":15,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426108,"discussion_content":"思路一样的 可以把右括号看作优先级最高的 至于左括号怎么处理 留给你思考吧😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539053002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1988075,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJX4ZU53F8hBHicctluqK6Ef3U0ib40bq1vFyAvqV0wu3GaPuWbj967OdMT7k0gl3OMxsfopvbk9veQ/132","nickname":"Geek_dd8b2b","note":"","ucode":"CBEF7C39075A96","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283117,"discussion_content":"左括号押入操作符栈，遇到右括弧，则做弹出并运算的操作，直到遇到相同的左括弧，将至视作比乘法除法更高优先级的操作符就好了吧","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1592189162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1060526,"avatar":"https://static001.geekbang.org/account/avatar/00/10/2e/ae/f4275434.jpg","nickname":"犄角旮旯","note":"","ucode":"746D5CD645FE59","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274463,"discussion_content":"将中缀表达式变为后缀表达式, 消除括号优先级的影响, 剩下的就只有操作数栈和符号栈","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590585678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1328354,"avatar":"https://static001.geekbang.org/account/avatar/00/14/44/e2/763526e9.jpg","nickname":"程晓擘","note":"","ucode":"96986D5AE2B96C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":181192,"discussion_content":"我的思路怎么是，有括号的时候，再添加两个新栈呢？😝","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582344232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1829090,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/e8/e2/2bcaef68.jpg","nickname":"王瑞强","note":"","ucode":"DEE4EB5E23433F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265243,"discussion_content":"左括号直接压入操作符栈，然后遇到右括号直接取出数字栈中的两个元素和操作符操作，同时出栈右括号","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589380916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1606741,"avatar":"https://static001.geekbang.org/account/avatar/00/18/84/55/34055533.jpg","nickname":"孙哲","note":"","ucode":"E43FA22B52F3B4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260982,"discussion_content":"遇到左括号直接把计算结果压入操作数栈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588923183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1943619,"avatar":"","nickname":"进击的小菜","note":"","ucode":"DEDC4D31DA0DF1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":218872,"discussion_content":"我想是不是和函数嵌套函数的栈帧处理方式一样呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585709585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1625900,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/gcr58TD2Yd7CicyEIlsQ5jhUJAliceEicHy0XicwFNLpibPDORVLSoUicARfqO0ZhmBvnpzmUEJibm9p1hKSPr87icsSibg/132","nickname":"Geek_2c27a1","note":"","ucode":"38829C47DA2420","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4491,"discussion_content":"遇到左括号，是不是也需要先入栈，再遇到右括号的时候才出栈并完成运算？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565488987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30596,"user_name":"zyzheng","can_delete":false,"product_type":"c1","uid":1042716,"ip_address":"","ucode":"E44F327230319E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e9/1c/be4ac7af.jpg","comment_is_top":false,"comment_ctime":1538957959,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"57373532807","product_id":100017301,"comment_content":"函数调用使用的栈是有硬件基础的，所有的CPU都有相应的SP寄存器用于存储栈顶指针，也有相应的入栈出栈指令，用于实现函数调用栈效率很高，和软件数据结构的栈有所不同。<br><br>如果要回答为什么函数调用要要用栈，个人理解是CPU设计就是如此","like_count":13},{"had_liked":false,"id":32496,"user_name":"hao","can_delete":false,"product_type":"c1","uid":1249486,"ip_address":"","ucode":"E2D95F51CE0691","user_header":"https://static001.geekbang.org/account/avatar/00/13/10/ce/04fab1a7.jpg","comment_is_top":false,"comment_ctime":1539590258,"is_pvip":false,"replies":[{"id":"11869","content":"是的 第六步 处理了2个操作符","user_name":"作者回复","comment_id":32496,"uid":"1190123","ip_address":"","utype":1,"ctime":1539614341,"user_name_real":"gg"}],"discussion_count":1,"race_medal":0,"score":"53079197810","product_id":100017301,"comment_content":"请问老师，3+5*8-6的栈计算演示图的第5步和第6步中间是不是省略了一步40 3 + 啊？不然如果表达式是3+5*8&#47;2-6的结果就不对了。谢谢您","like_count":12,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426794,"discussion_content":"是的 第六步 处理了2个操作符","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539614341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33683,"user_name":"djane","can_delete":false,"product_type":"c1","uid":1249032,"ip_address":"","ucode":"5315AA246AFDD8","user_header":"","comment_is_top":false,"comment_ctime":1539852862,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"44489525822","product_id":100017301,"comment_content":"【笔记】<br>一、如何理解“栈”？<br>1、栈是一种操作受限的数据结构，只支持入栈和出栈操作。<br>2、典型的“栈”结构：后进者先出，先进者后出。<br>3、从栈的操作特性上来看，栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。<br>4、特定的数据结构是对特定场景的抽象，而且，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然也就更容易出错。<br><br>二、如何实现一个“栈”？<br>1、栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，叫作顺序栈，用链表实现的栈，叫作链式栈。<br>2、不管基于数组还是链表，入栈、出栈的时间复杂度都为 O(1)。<br>不管是顺序栈还是链式栈，存储数据只需要一个大小为 n 的数组就够了。<br>在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度是 O(1)。<br>入栈、出栈只涉及栈顶个别数据的操作，所以时间复杂度都是 O(1)。<br><br>三、支持动态扩容的顺序栈<br>1、如果要实现一个支持动态扩容的栈，我们只需要底层依赖一个支持动态扩容的数组就可以了。当栈满了之后，我们就申请一个更大的数组，将原来的数据搬移到新数组中。<br>2、出栈的时间复杂度是 O(1)。<br>入栈操作，最好情况时间复杂度是 O(1)，最坏情况时间复杂度是 O(n)。均摊时间复杂度为O(1)。<br><br>四、栈在函数调用中的应用<br>1、经典应用场景：函数调用栈。<br>2、操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。<br><br>五、栈在表达式求值中的应用<br>1、常见的应用场景，编译器如何利用栈来实现表达式求值。比如：34+13*9+44-12&#47;3。<br>2、编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。<br>从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。<br>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。<br><br>六、栈在括号匹配中的应用<br>1、借助栈来检查表达式中的括号是否匹配。比如，{[{}]}或 [{()}([])] 等都为合法格式，而{[}()] 或 [({)] 为不合法的格式。<br>2、用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。<br>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。<br><br>七、如何实现浏览器的前进、后退功能？<br>1、使用两个栈，X 和 Y，把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。当点击前进按钮时，依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了。","like_count":10,"discussions":[{"author":{"id":2821728,"avatar":"","nickname":"600988292","note":"","ucode":"24BAE2B7A7B1E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":410328,"discussion_content":"课代表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635665731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51389,"user_name":"王小臭","can_delete":false,"product_type":"c1","uid":1161015,"ip_address":"","ucode":"AA95955882B2E7","user_header":"https://static001.geekbang.org/account/avatar/00/11/b7/37/36ce456f.jpg","comment_is_top":false,"comment_ctime":1545180145,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35904918513","product_id":100017301,"comment_content":"最近才来拜读老师的文章，真心的不想做业务工程师，作为大龄转行过来的我，看一遍不明白我可以看两遍，三遍。相见恨晚的感觉","like_count":8},{"had_liked":false,"id":31064,"user_name":"飞羽","can_delete":false,"product_type":"c1","uid":1241451,"ip_address":"","ucode":"6779BCE78AA636","user_header":"https://static001.geekbang.org/account/avatar/00/12/f1/6b/c95dab3c.jpg","comment_is_top":false,"comment_ctime":1539079123,"is_pvip":false,"replies":[{"id":"11164","content":"👍 不过不需要用递归的","user_name":"作者回复","comment_id":31064,"uid":"1190123","ip_address":"","utype":1,"ctime":1539082162,"user_name_real":"gg"}],"discussion_count":1,"race_medal":0,"score":"35898817491","product_id":100017301,"comment_content":"看到有人问小括号的情况怎么办，我写了个JS的示例，抛砖引玉哈。<br>主要思路就是遇到小括号时，将小括号内的表达式提取出来，然后进行递归调用。<br><br>使用ES6写的，Git地址：<br><br>https:&#47;&#47;github.com&#47;taifu5522&#47;ProblemSet","like_count":8,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426209,"discussion_content":"👍 不过不需要用递归的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539082162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30578,"user_name":"刘大侠","can_delete":false,"product_type":"c1","uid":1239101,"ip_address":"","ucode":"748FDA3C70EF9E","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/3d/6716659a.jpg","comment_is_top":false,"comment_ctime":1538954507,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35898692875","product_id":100017301,"comment_content":"不一样的栈，java里面栈和堆有数据共享不共享的问题，所以不一样","like_count":8},{"had_liked":false,"id":217923,"user_name":"吴贤龙","can_delete":false,"product_type":"c1","uid":1220566,"ip_address":"","ucode":"45085FE86D6030","user_header":"https://static001.geekbang.org/account/avatar/00/12/9f/d6/f66133b4.jpg","comment_is_top":false,"comment_ctime":1589655512,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"31654426584","product_id":100017301,"comment_content":"为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？<br><br>极客时间的课程《深入浅出计算机组成原理》第07讲，能从更底层原理技术原来来解释这个问题。<br>使用栈，天然性保障了cpu执行指令时，按顺序读取执行就好，否则的话，会出现指令执行跳转，需要额外的寄存器记录上次执行的指令位置，跳转执行完要回到原来的位置，简单的函数调用还好，如果嵌套太深的调用，CPU寄存器会不够用的","like_count":7,"discussions":[{"author":{"id":1082287,"avatar":"https://static001.geekbang.org/account/avatar/00/10/83/af/a7ce14ad.jpg","nickname":"三十岁大叔","note":"","ucode":"6FE0DDC740F0FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366084,"discussion_content":"这个可以有","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617956509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":40177,"user_name":"ForzaJuve","can_delete":false,"product_type":"c1","uid":1047302,"ip_address":"","ucode":"E090D83AE78EE6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/06/0e6b6365.jpg","comment_is_top":false,"comment_ctime":1542538246,"is_pvip":false,"replies":[{"id":"14489","content":"屁股后面的内存被占用了呢","user_name":"作者回复","comment_id":40177,"uid":"1190123","ip_address":"","utype":1,"ctime":1542589015,"user_name_real":"gg"}],"discussion_count":3,"race_medal":0,"score":"27312342022","product_id":100017301,"comment_content":"如果当前栈大小为 K，并且已满，当再有新的数据要入栈时，就需要重新申请 2 倍大小的内存，并且做 K 个数据的搬移操作，然后再入栈。<br>请问老师，这种情况一定需要做搬移吗？是因为重新申请内存需要整体搬到另外一个连续内存中去，不能直接在数组屁股后面加内存吗？","like_count":6,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429411,"discussion_content":"屁股后面的内存被占用了呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542589015,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1229516,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c2/cc/ca22bb7c.jpg","nickname":"蓝士钦","note":"","ucode":"726EB5C8EF1249","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5618,"discussion_content":"数组屁股后面加不了内存，因为数组在初始化的时候就申请分配了一块内存空间，必须重新申请一块新的数组内存空间。也许从物理上看数组背后还有剩余的空间，可以通过物理黑客的手段从内存屁股后面扩容，但是所有的程序行为必须在程序的角度去看问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566384295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1605058,"avatar":"https://static001.geekbang.org/account/avatar/00/18/7d/c2/e6332a1b.jpg","nickname":"东方拓睿","note":"","ucode":"1FD25D75CAC7C1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576632,"discussion_content":"因为是一个新的数组啊，要把老的数组复制到新的数组里面，同时还要留一半原来数组的大小，所以才是2倍内存大小，而且数组是大小不可变的，一旦占满了就需要新申请一段连续的内存的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655713879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31049,"user_name":"learning","can_delete":false,"product_type":"c1","uid":1236953,"ip_address":"","ucode":"14CE94C24F9C87","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/d9/a90b2488.jpg","comment_is_top":false,"comment_ctime":1539076288,"is_pvip":false,"replies":[{"id":"11152","content":"😄 还是比较难抽出来吧 摔坏了咋办","user_name":"作者回复","comment_id":31049,"uid":"1190123","ip_address":"","utype":1,"ctime":1539080675,"user_name_real":"gg"}],"discussion_count":10,"race_medal":0,"score":"27308880064","product_id":100017301,"comment_content":"例子举得不恰当，一堆碟子是可以随意抽取的","like_count":6,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426203,"discussion_content":"😄 还是比较难抽出来吧 摔坏了咋办","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539080675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1926508,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/65/6c/be97a3ae.jpg","nickname":"Geek_bb2310","note":"","ucode":"022885B257DEB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":259134,"discussion_content":"哈哈，杠精\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1588763220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1392411,"avatar":"https://static001.geekbang.org/account/avatar/00/15/3f/1b/c2c54253.jpg","nickname":"大伙子~🤧","note":"","ucode":"ECC65FF1D989B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":314392,"discussion_content":"哈哈，用一叠套在圆杆子上的光盘💿，这样中间就没法抽了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603154707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1397631,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKVUskibDnhMt5MCIJ8227HWkeg2wEEyewps8GuWhWaY5fy7Ya56bu2ktMlxdla3K29Wqia9efCkWaQ/132","nickname":"衬衫的价格是19美元","note":"","ucode":"655F925451F772","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308907,"discussion_content":"把一碟盘子放在直径和盘子一样大的桶里面，这下就无法从中间抽出来了把","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601118921,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1128984,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3a/18/cf67d895.jpg","nickname":"就这样火了","note":"","ucode":"7E4A447FF068E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":259943,"discussion_content":"抢装子弹","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588831445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132312,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/18/293cd24d.jpg","nickname":"o0oi1i","note":"","ucode":"D1F6AD4AAEAFBE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":236563,"discussion_content":"洗碗可好？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587103985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1943619,"avatar":"","nickname":"进击的小菜","note":"","ucode":"DEDC4D31DA0DF1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":218589,"discussion_content":"这一层集思广益😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585666555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1650748,"avatar":"https://static001.geekbang.org/account/avatar/00/19/30/3c/0668d6ae.jpg","nickname":"盘胧","note":"","ucode":"5386CC4C92ECC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":117278,"discussion_content":"丢桶（容器）里，中间没法抽。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578106019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1363509,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJAOmCxOCJWenbGQER5FZOL1jwuKQOZu3pcJ76YxiaXk3MCTprfePLNAbPwaJGRsrI21pweRDZbFAQ/132","nickname":"e","note":"","ucode":"B406AA5F9F5BB9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46557,"discussion_content":"弹匣","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573180746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1157910,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ab/16/0f83cab6.jpg","nickname":"smilingmiao","note":"","ucode":"B48F429563EF74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5825,"discussion_content":"俄罗斯套娃呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566474610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30681,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1538973226,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"27308777002","product_id":100017301,"comment_content":"1，方法调用是有先后顺序的，并且一个线程中同一时间点只会处理一个方法，若方法中调用其他方法，则被调用方法会入栈并且方法体被执行，执行完后方法出栈，并将执行结果相关信息向下一个执行方法传递(方法所有信息被封装为一个栈元素)。方法执行过程中产生的数据存储特点非常符合栈数据结构特点。<br>2，概念和用途是一个意思，jvm的栈稍有复杂，每个栈元素叫做栈帧(一个包含被执行方法所有信息的元素，栈最顶部是当前栈帧，也就是正在被执行的方法)，栈元素是一个具体方法，又包含了操作数栈，用于方法的具体执行中的数据计算。","like_count":6},{"had_liked":false,"id":30574,"user_name":"kylexu","can_delete":false,"product_type":"c1","uid":1053080,"ip_address":"","ucode":"04C3A4248A0B49","user_header":"","comment_is_top":false,"comment_ctime":1538930588,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27308734364","product_id":100017301,"comment_content":"看完再睡！","like_count":6,"discussions":[{"author":{"id":1661456,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epYAmnyHBCVY7YicTF3IXa39mvVTuyum9yicPyFG5amXuo6R2QOTicX0iaXLicH8CTktC7XHruv81ichgkg/132","nickname":"Geek_b25f99","note":"","ucode":"6F7BEAB2C31528","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":12636,"discussion_content":"动态扩容顺序栈，在搬运操作时候是怎么进行的啊？因为后进先出的原因，a,b,c,d若是搬过来应该是d，c，b，a啊，老师画图还是原来顺序？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568556913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166486,"user_name":"-","can_delete":false,"product_type":"c1","uid":1326977,"ip_address":"","ucode":"B915F53BC7F2A1","user_header":"https://static001.geekbang.org/account/avatar/00/14/3f/81/08b938b1.jpg","comment_is_top":false,"comment_ctime":1577457972,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23052294452","product_id":100017301,"comment_content":"补充置顶答案:<br>JVM的栈的逻辑算是一个标准的数据结构栈的实现, 和在不在物理区也没啥关系(实际上也并不是物理区), 一个栈包含多个栈帧, 栈帧主要由局部变量表\\操作数栈\\方法返回地址等. 栈是这个线程的方法调用链, 栈帧对应每个方法执行的过程数据. 在方法调用的角度来看栈, 理解起来很容易的. 那么同一个方法的代码执行怎么能和栈扯上关系的? 这里就是栈帧内的操作数栈的事情了, 看一段java代码和字节码就明白了:<br>int a = 100;<br>int b = 10;<br>int c = a + b;<br>return;<br>这段代码字节码指令如下(每行后的#是我加的注释):<br>         0: bipush        100         #byte型常量值100推送至栈顶(push)<br>         2: istore_1                      #将栈顶int型数值100存入第二个局部变量(pop)<br>         3: bipush        10            #byte型常量值10推送至栈顶(push)<br>         5: istore_2                      #将栈顶int型数值10存入第三个局部变量(pop)<br>         6: iload_1                       #将第二个int型局部变量100进栈(push)<br>         7: iload_2                       #将第三个int型局部变量10进栈(push)<br>         8: iadd                            #将栈顶两个值出栈, cpu计算结果后,将结果入栈, 两次pop,一次push<br>         9: istore_3                      #将栈顶值存入第三个局部变量(pop)<br>        10: iload_3                      #将第三个局部变量入栈(push)<br>        11: ireturn                      #返回栈顶int类型数据(pop)<br><br>总之, JVM的栈再怎么嵌套, 栈元素怎么复杂, 核心逻辑还是栈 ","like_count":5},{"had_liked":false,"id":67603,"user_name":"666","can_delete":false,"product_type":"c1","uid":1089792,"ip_address":"","ucode":"E16B1C52DBB550","user_header":"https://static001.geekbang.org/account/avatar/00/10/a1/00/68ffaa02.jpg","comment_is_top":false,"comment_ctime":1550207730,"is_pvip":true,"replies":[{"id":"23940","content":"iPad + Paper","user_name":"编辑回复","comment_id":67603,"uid":"1000473","ip_address":"","utype":2,"ctime":1550207797,"user_name_real":"郭蕾"}],"discussion_count":1,"race_medal":0,"score":"23025044210","product_id":100017301,"comment_content":"老师画图用的啥工具啊？","like_count":5,"discussions":[{"author":{"id":1000473,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/44/19/17fadc62.jpg","nickname":"郭蕾","note":"","ucode":"34F4C07D1C5FE8","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439273,"discussion_content":"iPad + Paper","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550207797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71858,"user_name":"冷颜〆","can_delete":false,"product_type":"c1","uid":1237101,"ip_address":"","ucode":"8FE0FB27AFA31C","user_header":"https://static001.geekbang.org/account/avatar/00/12/e0/6d/a55c6ec4.jpg","comment_is_top":false,"comment_ctime":1551451730,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18731320914","product_id":100017301,"comment_content":"这篇文章看了两遍<br>想了很久 解决了一些误区<br>也想明白了一些实现<br>果然需要反复看才会吃透","like_count":4},{"had_liked":false,"id":41737,"user_name":"田佳伟","can_delete":false,"product_type":"c1","uid":1034087,"ip_address":"","ucode":"D31C9799F383D2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/67/0077314b.jpg","comment_is_top":false,"comment_ctime":1542847754,"is_pvip":false,"replies":[{"id":"14962","content":"我感觉都可以 不过逆波兰更出名些","user_name":"作者回复","comment_id":41737,"uid":"1190123","ip_address":"","utype":1,"ctime":1542851294,"user_name_real":"gg"}],"discussion_count":2,"race_medal":0,"score":"18722716938","product_id":100017301,"comment_content":"老师，昨天看《大话数据结构》，讲栈的时候，还有一种后缀（逆波兰）表示法，来表示算数表达式，然后用一个栈就能搞定，这个和您文中讲的用两个栈计算，哪个更常用呢？","like_count":4,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429884,"discussion_content":"我感觉都可以 不过逆波兰更出名些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542851294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1748742,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/af/06/2478c354.jpg","nickname":"王同学","note":"","ucode":"E2FE15452816D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54220,"discussion_content":"我觉得老师这个方法更简单更好理解，逆波兰运算，首先你要把表达式解析成逆波兰形式的表达式，解析的过程至少需要一个栈和一个其他结构数据类型来存储解析后的表达式，如字符串数组或者可变的字符串。转换成逆波兰表达式后，还需要运算表达式，运算表达式还需要借助栈莱计算，所以还是直接用老师讲解的两个栈的方式更简单且遍历次数更少","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574269185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31482,"user_name":"睡不着的史先生","can_delete":false,"product_type":"c1","uid":1192542,"ip_address":"","ucode":"E00E6C43F340D9","user_header":"https://static001.geekbang.org/account/avatar/00/12/32/5e/4827557b.jpg","comment_is_top":false,"comment_ctime":1539217043,"is_pvip":false,"replies":[{"id":"11423","content":"你自己在浏览器里试一下就知道了","user_name":"作者回复","comment_id":31482,"uid":"1190123","ip_address":"","utype":1,"ctime":1539269571,"user_name_real":"gg"}],"discussion_count":7,"race_medal":0,"score":"18719086227","product_id":100017301,"comment_content":"当添加新页面d以后，页面c不还是在另外一个栈里面吗？这样还是可以通过回退查看的呀？为啥就不能查看了呢？谢谢","like_count":4,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426364,"discussion_content":"你自己在浏览器里试一下就知道了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539269571,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1183276,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0e/2c/8f9d943b.jpg","nickname":"mmaqshen","note":"","ucode":"0A35CB99045021","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":232749,"discussion_content":"b的后继结点变成d了，不是c了。所以c这个节点断了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586876112,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1957632,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqZGr575z4WfctOy5wcuNqbUFgdLErXyicWgyBvE8ZETgFsj2vfcKkRicMxet5UjM09mIpCxo99xpXA/132","nickname":"123-sky","note":"","ucode":"2B269A3CBF4382","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1183276,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0e/2c/8f9d943b.jpg","nickname":"mmaqshen","note":"","ucode":"0A35CB99045021","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290030,"discussion_content":"所以可以用双向链表理解吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594306381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":232749,"ip_address":""},"score":290030,"extra":""},{"author":{"id":1318913,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJwicoopV8ZJuxPQUfATepdg7zHQG1vpZpickQYicRN0u9qwibK2lq7MDpt0ZFdofnwshNcibkLdqk9ZRg/132","nickname":"13693113483","note":"","ucode":"39CF3202F58847","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1957632,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqZGr575z4WfctOy5wcuNqbUFgdLErXyicWgyBvE8ZETgFsj2vfcKkRicMxet5UjM09mIpCxo99xpXA/132","nickname":"123-sky","note":"","ucode":"2B269A3CBF4382","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292197,"discussion_content":"我感觉可以，如果功能要求打开新页面还可以继续前进的话（也就是在b打开d继续前进到c），双向链表可以实现，插入d这个新节点的时候先把d的next指向c。实际上栈也能实现新页面继续前进，不过业务逻辑上理解就比较不人性化，所以实际的页面浏览器是有个额外的栈清空操作吧，不知道我理解的对不对。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595136083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":290030,"ip_address":""},"score":292197,"extra":""}]},{"author":{"id":1016575,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/82/ff/00e7614e.jpg","nickname":"robyy","note":"","ucode":"773337C9942A7F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":397238,"discussion_content":"X栈顶为当前页面，点击/访问任何页面（非前进后退）都会清空Y（前进）栈，前进按钮不可用，这是浏览器的实际逻辑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632579408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1131957,"avatar":"https://static001.geekbang.org/account/avatar/00/11/45/b5/c3cfb198.jpg","nickname":"王振华 程序员","note":"","ucode":"31BB337642B882","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":66767,"discussion_content":"老师，我也有同样的疑问。去浏览器里试，当然您说的是对的。但从您讲解背后的原理来看，“当添加新页面d以后，页面c不还是在另外一个栈里面吗？这样还是可以通过回退查看的呀？为啥就不能查看了呢？”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575105797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1809799,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJNxMqDoNODfL1aFpkJboxlZPyFANAt9ovzksYtMUIGo3KbHr4Qy8j20Txrpiau6iaJGgAr1nCfpy9w/132","nickname":"爱学习的老吴","note":"","ucode":"E515F50E7A8A68","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1131957,"avatar":"https://static001.geekbang.org/account/avatar/00/11/45/b5/c3cfb198.jpg","nickname":"王振华 程序员","note":"","ucode":"31BB337642B882","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":195022,"discussion_content":"打开新页面时需要把前进栈清空的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583247808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":66767,"ip_address":""},"score":195022,"extra":""}]}]},{"had_liked":false,"id":71476,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1551350776,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14436252664","product_id":100017301,"comment_content":"读完之后又对栈这个数据结构有更深的理解，jvm里面的栈我分为普通栈和本地方法栈，其实本质都是和栈的数据结构本质是一样的，只是作用不同而已，普通栈主要负责每个线程执行方法就会创建一个栈祯，每个栈祯内存储些局部变脸，和操作数栈和方法返回值一些数据，方法执行栈祯入栈，当方法执行完栈祯出栈，每个栈祯都是不相互印象而独立的;而本地方法栈的原理也是一样只是针对的对象不同，它针对的是native修饰符的本地方法对象，其本质也是一样的。","like_count":3},{"had_liked":false,"id":57644,"user_name":"白露","can_delete":false,"product_type":"c1","uid":1261163,"ip_address":"","ucode":"F00A66DE15F118","user_header":"https://static001.geekbang.org/account/avatar/00/13/3e/6b/e52e0503.jpg","comment_is_top":false,"comment_ctime":1546857430,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"14431759318","product_id":100017301,"comment_content":"为什么动态扩容的数据顺序栈的入栈扩容以后，做了K个数据搬移，然后去入栈。但是接下来是K-1次入栈操作呢？","like_count":3,"discussions":[{"author":{"id":1244632,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fd/d8/8dcb1d84.jpg","nickname":"Michael  Chen","note":"","ucode":"457C6D50C9BF62","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":129778,"discussion_content":"个人理解是这样的，原有的栈的大小为k，当第k+1个数据入栈的时候会进行扩容(栈大小变为2k)，将原有栈的k个数据入新栈，第k+1个数据入新栈，也就是说第k+1个数据入栈耗了大量时间，新栈剩下的空间大小为: 2k-(k+1)=k-1,剩下的k-1个数据入栈的时间复杂度都为O(1)。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578737463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1605058,"avatar":"https://static001.geekbang.org/account/avatar/00/18/7d/c2/e6332a1b.jpg","nickname":"东方拓睿","note":"","ucode":"1FD25D75CAC7C1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576638,"discussion_content":"每一次入栈都是在末尾入栈，当然就是O(1)了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655714988,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1250807,"avatar":"https://static001.geekbang.org/account/avatar/00/13/15/f7/744720a2.jpg","nickname":"DriveMan_邱佳源","note":"","ucode":"A4C83BF07DEE7A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4356,"discussion_content":"k-1是指索引，从0开始算一次，那么k-1相当于是k次","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565333487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157863,"user_name":"春和景明","can_delete":false,"product_type":"c1","uid":1272482,"ip_address":"","ucode":"A27970A276ECD6","user_header":"https://static001.geekbang.org/account/avatar/00/13/6a/a2/f9efd9dc.jpg","comment_is_top":false,"comment_ctime":1575273076,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10165207668","product_id":100017301,"comment_content":"1.用Python的列表实现一个自动扩容的栈<br>class Stack:<br>    &quot;&quot;&quot;<br>    用Python列表实现，其实是一个支持动态扩容的栈。如果是用Java的数组实现的话，需要手动扩容数组。<br>    时间复杂度是 O(1)<br>    空间复杂度是 O(1)<br>    &quot;&quot;&quot;<br><br>    def __init__(self):<br>        self._stack = list()<br><br>    def push(self, ele):<br>        # 不会没空间，因为Python的list会动态扩容<br>        self._stack.append(ele)<br><br>    def pop(self):<br>        if self.is_empty():<br>            return None<br>        return self._stack.pop()<br><br>    def top(self):<br>        return self._stack[-1]<br><br>    def min(self):<br>        return min(self._stack)<br><br>    def max(self):<br>        return max(self._stack)<br><br>    def is_empty(self):<br>        return self._stack.__len__() == 0<br><br>    def length(self):<br>        return self._stack.__len__()<br><br>    def reverse(self):<br>        self._stack = self._stack[::-1]<br><br>    def clear(self):<br>        while not self.is_empty():<br>            self._stack.pop()<br><br>    def __repr__(self):<br>        return str(self._stack)<br><br><br>2.利用栈来判断括号字符串是否合法<br>def match_bracket(strings):<br>    open_bracket = &quot;({[&quot;<br>    close_bracket = &quot;)]}&quot;<br>    bracket_map = {&#39;(&#39;: &#39;)&#39;, &#39;[&#39;: &#39;]&#39;, &#39;{&#39;: &#39;}&#39;}<br>    label = True<br>    stack = Stack()<br>    if strings == &quot;&quot;:<br>        return True<br>    for char in strings:<br>        if char not in (open_bracket + close_bracket):<br>            continue<br>        if char in open_bracket:<br>            stack.push(char)<br>            print(stack)<br>            continue<br>        if char in close_bracket:<br>            if stack.is_empty():<br>                label = False<br>                break<br>            if bracket_map[stack.pop()] == char:<br>                continue<br>            else:<br>                label = False<br>                break<br>    if not stack.is_empty():<br>        label = False<br>    print(stack)<br>    return label","like_count":2},{"had_liked":false,"id":134815,"user_name":"冀云","can_delete":false,"product_type":"c1","uid":1175189,"ip_address":"","ucode":"01E3B55795E90A","user_header":"https://static001.geekbang.org/account/avatar/00/11/ee/95/6fe64a45.jpg","comment_is_top":false,"comment_ctime":1568939420,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10158874012","product_id":100017301,"comment_content":"参数传递也可以不使用栈进行传参，可以使用寄存器，比如fastcall就会借助寄存器进行传参，只是寄存器的数量比较少，所以fastcall在参数多时依然会使用栈。<br>使用栈传参是因为函数调用符合栈的抽象，函数调用往往是嵌套的，比如a调用b调用c。当进入函数a时，操作系统会开辟a函数栈帧，当a调用b时，操作系统会保存a的环境，给b开辟新的栈帧。当b函数执行完成后，会回到a函数，则会恢复到a函数的栈帧。<br>开辟栈帧和恢复栈帧这个过程就是ebp和esp不断的改变，主要就是ebp被压栈和出栈来改变栈底，通过ebp来修改esp，esp再根据函数内变量所占的空间来抬高栈顶。不过，这个栈是cpu在维护，对高级语言的程序员是透明的。","like_count":2},{"had_liked":false,"id":43035,"user_name":"MrVito","can_delete":false,"product_type":"c1","uid":1252169,"ip_address":"","ucode":"716FF6F8871706","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/49/ddefc656.jpg","comment_is_top":false,"comment_ctime":1543145765,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10133080357","product_id":100017301,"comment_content":"#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>using namespace std;<br>&#47;***<br> * 实现栈的数据结构<br> * 顺序栈<br> * 后进先出<br> * 定义pop和push<br> * 支持扩容<br> ***&#47;<br><br>template &lt;typename T&gt; class StackUse{<br>  public:<br>    StackUse(T *array):arr(array){<br>    }<br>    T *arr; &#47;&#47; 使用指针获得数组，实现动态扩容<br>    void push(T element); &#47;&#47; 入栈<br>    T&amp; pop(); &#47;&#47; 出栈<br>    int length; &#47;&#47; 记录栈的大小<br>    T element;<br>  private:<br>    StackUse(const StackUse&amp;){}<br>    StackUse&amp; operator=(const StackUse&amp;){}<br>    int count = 0; &#47;&#47; 出栈入栈计数<br>};<br><br>template &lt;typename T&gt; T&amp; StackUse&lt;T&gt;::pop(){<br>    element = *arr;<br>    if(count &gt; 0){<br>        --count;<br>        arr--; &#47;&#47; 指针往下指一次<br>    }else{<br>      return element;<br>    }<br>    return element;<br>}<br><br>template &lt;typename T&gt; void StackUse&lt;T&gt;::push(T element){<br>    if(count &lt; length){<br>      ++arr; &#47;&#47; 这里返回的是指针所指向，继续往上指<br>      *arr = element;<br>      ++count;<br>      cout &lt;&lt; *arr &lt;&lt; endl;<br>    }else{<br>      cout &lt;&lt; &quot;out of memory please expend the memory&quot; &lt;&lt; endl;<br>    }<br>    cout &lt;&lt; &quot;success!&quot; &lt;&lt; endl;<br>}<br>粗略用Cpp实现了一下，很多不足，多多包涵，听完课就开始着手写了","like_count":2},{"had_liked":false,"id":40861,"user_name":"阿U","can_delete":false,"product_type":"c1","uid":1171359,"ip_address":"","ucode":"161A8E74E0D612","user_header":"https://static001.geekbang.org/account/avatar/00/11/df/9f/6e3e1b77.jpg","comment_is_top":false,"comment_ctime":1542684234,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10132618826","product_id":100017301,"comment_content":"老师 出栈代码 有点问题吧 出栈不是需要将元素取出然后在count减1吗 我觉得少了一句 items[count-1]=null;","like_count":2,"discussions":[{"author":{"id":1261360,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3f/30/23f6b413.jpg","nickname":"五十九秒","note":"","ucode":"1F34F62193CFF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351900,"discussion_content":"出队后移动栈顶指针指向前一个元素，入队新元素直接利用原来元素的内存空间，免除了删除的数组空间的内存挪动。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614514070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37592,"user_name":"y1nored","can_delete":false,"product_type":"c1","uid":1233959,"ip_address":"","ucode":"D92BD845F5B673","user_header":"https://static001.geekbang.org/account/avatar/00/12/d4/27/6f68c4cd.jpg","comment_is_top":false,"comment_ctime":1541645971,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10131580563","product_id":100017301,"comment_content":"您好，对于函数栈的运算有个问题，栈顶的add函数运算完毕后的值存储在哪里，如何传递到在main函数中。","like_count":2},{"had_liked":false,"id":34528,"user_name":"小六子","can_delete":false,"product_type":"c1","uid":1046542,"ip_address":"","ucode":"B4E48C9AAF2030","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/0e/7a992528.jpg","comment_is_top":false,"comment_ctime":1540199163,"is_pvip":false,"replies":[{"id":"12307","content":"很多实现思路都很巧妙 多看多积累自然就想到了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540221619,"ip_address":"","comment_id":34528,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10130133755","product_id":100017301,"comment_content":"老师，请问为什么求括号匹配或者中缀表达式求值用栈结构呢？第一个发明这种用法的人是如何巧妙地想到用栈的呢？<br><br>查了很多书都没讲为什么栈适合用于这两个例子里，下面是我想的，我觉得这个也很重要。希望老师有时间能帮忙解答一下。后面讲例子的时候希望老师也能顺带说一下，为什么这种结构适合解决某种例子里的应用。<br><br>是因为：笨方法要扫描一遍输入的括号或者表达式字符串，然后当扫描到右括号或者高优先级运算符要看最邻近的刚刚扫描过的括号或者操作数，正好栈提供了刚刚扫描过的在栈顶这种后进先出的机制，所以才想到用栈的吗？","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427238,"discussion_content":"很多实现思路都很巧妙 多看多积累自然就想到了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540221619,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31578,"user_name":"oldman","can_delete":false,"product_type":"c1","uid":1133711,"ip_address":"","ucode":"6BACE2832B4429","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/8f/a90b3969.jpg","comment_is_top":false,"comment_ctime":1539236108,"is_pvip":false,"replies":[{"id":"11412","content":"👍 你可以自己写几个测试数据测试一下","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539268808,"ip_address":"","comment_id":31578,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10129170700","product_id":100017301,"comment_content":"栈实现括号的匹配，我用python实现了一遍，各位看官一起交流。<br>https:&#47;&#47;github.com&#47;lipeng1991&#47;testdemo&#47;blob&#47;master&#47;37_bracket_matching.py<br>老师帮忙看一下","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426412,"discussion_content":"👍 你可以自己写几个测试数据测试一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539268808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30981,"user_name":"jackeymm","can_delete":false,"product_type":"c1","uid":1103650,"ip_address":"","ucode":"A06543EA294750","user_header":"https://static001.geekbang.org/account/avatar/00/10/d7/22/a05987e7.jpg","comment_is_top":false,"comment_ctime":1539056287,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10128990879","product_id":100017301,"comment_content":"java中关于内存的存储分为，静态内存，栈内存，堆内存，静态内存只能存储长度不可变的常亮，栈内存用来存储在程序入口处长度可知的局部变量，堆内存用于存储在入口处不可知长度的变量，所以可存储的内存有栈内存和堆内存，又因为堆内存是共享内存，开销比栈内存高，根据最小原则应该存在栈内存中。<br>第二个问题，我认为我们文章用说的栈主要是说明后进先出的存储逻辑，堆栈中的栈在此基础上还有其他的规则，比如存储的是在程序入口处长度可知的变量等，所以两者最基本的原则是一样的，但堆栈中的栈更丰富","like_count":2},{"had_liked":false,"id":245293,"user_name":"dpjin","can_delete":false,"product_type":"c1","uid":1539183,"ip_address":"","ucode":"0383D8003E6C14","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/pHPfugzib71JdXkKxRITCzdD46DYcDYHImoYeibHdyu4hLWOBXh7OLllx247vKJvWIcu18dxWOTAtv8AaRB8opvQ/132","comment_is_top":false,"comment_ctime":1598885892,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5893853188","product_id":100017301,"comment_content":"golang实现链式栈<br>package main<br><br>import &quot;fmt&quot;<br><br>type Node struct {<br>\tData string<br>\tNext *Node<br>}<br><br>type LinkedList struct {<br>\theadNode *Node<br>\tlength   int<br>\tcount    int<br>}<br><br>&#47;&#47; 出栈操作<br>func (l *LinkedList) NewStack(length int) *LinkedList {<br>\treturn &amp;LinkedList{length: length}<br>}<br><br>&#47;&#47; 入栈操作<br>func (l *LinkedList) Push(data string) bool {<br>\titem := &amp;Node{Data: data}<br>\tif l.count == l.length {<br>\t\treturn false<br>\t}<br>\titem.Next = l.headNode<br>\tl.headNode = item<br>\tl.count++<br>\treturn true<br>}<br><br>&#47;&#47; 出栈操作<br>func (l *LinkedList) Pop() string {<br>\tif l.count == 0 {<br>\t\treturn &quot;&quot;<br>\t}<br>\tres := l.headNode.Data<br>\tl.headNode = l.headNode.Next<br>\treturn res<br>}","like_count":1},{"had_liked":false,"id":213136,"user_name":"Geek_ac7784","can_delete":false,"product_type":"c1","uid":1981613,"ip_address":"","ucode":"62F0E5E6D6F4BA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/8Dj4ugujXwY24G8pcpgDFGiciarXetG3ItQ4M9mSQMLyRdRRXEXXJVfib48mGUQAu87QcvImwyJIVJlEFeEguV44w/132","comment_is_top":false,"comment_ctime":1588310370,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5883277666","product_id":100017301,"comment_content":"学习笔记：栈比较熟悉了，说一下本节课抓到的重点和学的知识<br>1.  栈是一种操作受限的线性结构，只支持入栈和栈，后进先出<br>2. 栈有两种顺序栈和链式栈，实现方法不同<br>3. 动态扩容栈的入栈操作均摊时间复杂度分析<br>4. 栈的应用：括号匹配算法(一个栈)，四则运算匹配算法(两个栈，操作数栈和运算符栈)，网页前进后退(两个栈，历史栈和前进栈，注意历史栈中跳转新页面是，前进栈要清空)<br>思考题：<br>非Java：正如课中讲的，栈是一种受限的线性表，函数调用用线性表是可以实现的。只不过函数调用符合栈后入先出的特性，更容易实现局部作用域的实现。<br>转一个评论：leetcode中关于栈：先做20,155,232,844,224,682,496.","like_count":1},{"had_liked":false,"id":197711,"user_name":"ashen-one","can_delete":false,"product_type":"c1","uid":1123304,"ip_address":"","ucode":"F80F924DB220A1","user_header":"https://static001.geekbang.org/account/avatar/00/11/23/e8/abd99392.jpg","comment_is_top":false,"comment_ctime":1585393919,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880361215","product_id":100017301,"comment_content":"使用函数调用栈的话，是怎么处理闭包问题的呢？","like_count":1},{"had_liked":false,"id":196162,"user_name":"Geek_55e386","can_delete":false,"product_type":"c1","uid":1795793,"ip_address":"","ucode":"5A727F1323C2D0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/zxkns28cIAUZIt3WjDb8G26qiccT84d9GMr9ZpbYR60TU1ibqSj9NoYVHlJvGF1kOltkqNDmEfJCqPuYVkue3WHg/132","comment_is_top":false,"comment_ctime":1585240065,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880207361","product_id":100017301,"comment_content":"评论区都是大佬，学习学习","like_count":1},{"had_liked":false,"id":184787,"user_name":"赤云","can_delete":false,"product_type":"c1","uid":1093258,"ip_address":"","ucode":"67476D582D8B6A","user_header":"https://static001.geekbang.org/account/avatar/00/10/ae/8a/e67def95.jpg","comment_is_top":false,"comment_ctime":1583403533,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878370829","product_id":100017301,"comment_content":"&#47;&#47; 括号匹配<br>public boolean isValid(String s) {<br>        if (s == null || s.length() == 0) {<br>            return true;<br>        }<br>        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();<br>        for (char c : s.toCharArray()) {<br>            &#47;&#47; 栈是空的，入栈<br>            if (stack.empty()) {<br>                stack.add(c);<br>            } else {<br>                Character pop = stack.peek();<br>                switch (pop) {<br>                    case &#39;(&#39;:<br>                        if (&#39;)&#39; == c) {<br>                            stack.pop();<br>                        } else {<br>                            stack.add(c);<br>                        }<br>                        break;<br>                    case &#39;{&#39;:<br>                        if (&#39;}&#39; == c) {<br>                            stack.pop();<br>                        } else {<br>                            stack.add(c);<br>                        }<br>                        break;<br>                    case &#39;[&#39;:<br>                        if (&#39;]&#39; == c) {<br>                            stack.pop();<br>                        } else {<br>                            stack.add(c);<br>                        }<br>                        break;<br>                    default:<br>                        return false;<br>                }<br>            }<br>        }<br>        return stack.empty();<br>    }","like_count":1},{"had_liked":false,"id":158932,"user_name":"猫切切切切切","can_delete":false,"product_type":"c1","uid":1075033,"ip_address":"","ucode":"F350BA1B7FFDC4","user_header":"https://static001.geekbang.org/account/avatar/00/10/67/59/017b5726.jpg","comment_is_top":false,"comment_ctime":1575503517,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5870470813","product_id":100017301,"comment_content":"因为函数调用先进后出的特点与栈的特性是一致的，所以人们很自然地就用栈这种数据结构来保存函数调用的临时变量。使用其它数据结构来实现函数调用的临时变量保存也是可行的，只不过这样的数据结构还是得有先进后出的特性，而栈天然就具有这种特性，并且操作上更可控更不易出错。","like_count":1},{"had_liked":false,"id":157872,"user_name":"Panda🐟","can_delete":false,"product_type":"c1","uid":1002401,"ip_address":"","ucode":"C6007A3192516A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4b/a1/c2719a5a.jpg","comment_is_top":false,"comment_ctime":1575275001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870242297","product_id":100017301,"comment_content":"思考：<br>1.  函数的执行规则是『最后调用的最先执行』和栈『后来居上&#47;后来优先&#47;后进先出』的特性完美契合。<br>2. 栈是一种抽象的数据结构，栈空间是以栈这种结构组织数据的一段内存空间","like_count":1},{"had_liked":false,"id":157864,"user_name":"春和景明","can_delete":false,"product_type":"c1","uid":1272482,"ip_address":"","ucode":"A27970A276ECD6","user_header":"https://static001.geekbang.org/account/avatar/00/13/6a/a2/f9efd9dc.jpg","comment_is_top":false,"comment_ctime":1575273136,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"5870240432","product_id":100017301,"comment_content":"<br>3.用栈来实现浏览器的前进和后退<br>class Browser:<br>    def __init__(self):<br>        self.forward_stack = Stack()  # 保存后退的页面<br>        self.backward_stack = Stack()  # 保存新开页面或者前进的页面<br><br>    def open(self, url):<br>        self.backward_stack.push(url)  # 新页面加入到后退栈<br>        print(f&quot;Open new url: {url}&quot;)<br>        self.forward_stack.clear()  # 清空前进栈<br><br>    def back(self):<br>        if not self.backward_stack.is_empty():<br>            top = self.backward_stack.pop()  # 从后退栈中弹出<br>            self.forward_stack.push(top)<br>            print(f&quot;Back to {top}&quot;)<br>        else:<br>            print(&quot;Cannot backward&quot;)<br><br>    def forward(self):<br>        if not self.forward_stack.is_empty():<br>            top = self.forward_stack.pop()  # 从前进栈中弹出<br>            self.backward_stack.push(top)<br>            print(f&quot;Forward to {top}&quot;)<br>        else:<br>            print(&quot;Cannot forward&quot;)","like_count":1,"discussions":[{"author":{"id":1809799,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJNxMqDoNODfL1aFpkJboxlZPyFANAt9ovzksYtMUIGo3KbHr4Qy8j20Txrpiau6iaJGgAr1nCfpy9w/132","nickname":"爱学习的老吴","note":"","ucode":"E515F50E7A8A68","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":195046,"discussion_content":"其实有点问题，照你的代码，如果我现在打开了a页面，然后我点击后退，还是到a页面。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583248173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157392,"user_name":"克","can_delete":false,"product_type":"c1","uid":1069206,"ip_address":"","ucode":"6DDFBB05E0F4E9","user_header":"https://static001.geekbang.org/account/avatar/00/10/50/96/18612c89.jpg","comment_is_top":false,"comment_ctime":1575129618,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870096914","product_id":100017301,"comment_content":"数组实现栈动态扩展思考<br><br>为了避免动态扩容的数据拷贝，可以只新建数组，但是不拷贝数据。对每个新建的扩容数组按创建顺序编号，如 0, 1, 2, 3, ... N 。<br><br>假设初始容量是 C ，则动态扩容后总容量为 C + 2C + 4C ... 2^N C 。<br><br>双下标表示栈顶状态，I 表示指向的数组，J表示当前数组栈顶位置。<br><br>PUSH操作<br><br>- 当前数组空间未满时：J = J + 1<br>- 当前数组空间已满时：创建新的数组，I = I + 1  J = 0。<br><br>POP操作<br><br>- 当前数组尚有元素：J = J - 1<br>- 当前数组已无元素：I = I - 1  J = 2^N C - 1<br><br>时间复杂度分析<br><br>由于不会发生数据拷贝，每次操作只是重新计算指针位置，则时间复杂度为O(1)。<br>","like_count":1},{"had_liked":false,"id":149673,"user_name":"☆淡蓝水岸☆","can_delete":false,"product_type":"c1","uid":1443262,"ip_address":"","ucode":"A13D351C806CDE","user_header":"https://static001.geekbang.org/account/avatar/00/16/05/be/eb1588b0.jpg","comment_is_top":false,"comment_ctime":1573312956,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5868280252","product_id":100017301,"comment_content":"如果函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。<br>从调用函数进入被调用函数，对于数据来说，变化的是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。<br>JVM中的栈内存用来存储局部变量和方法调用，栈内存归属于单个线程<br>堆内存用来存储Java中的对象，无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。","like_count":1},{"had_liked":false,"id":140034,"user_name":".","can_delete":false,"product_type":"c1","uid":1505564,"ip_address":"","ucode":"D0B64376774FF8","user_header":"https://static001.geekbang.org/account/avatar/00/16/f9/1c/7e4997f2.jpg","comment_is_top":false,"comment_ctime":1570792938,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5865760234","product_id":100017301,"comment_content":"因为栈不易外漏","like_count":1},{"had_liked":false,"id":136904,"user_name":"神经蛙","can_delete":false,"product_type":"c1","uid":1590085,"ip_address":"","ucode":"EAE3B94B57832A","user_header":"https://static001.geekbang.org/account/avatar/00/18/43/45/422ca0dd.jpg","comment_is_top":false,"comment_ctime":1569550496,"is_pvip":false,"replies":[{"id":"52763","content":"不需要下面两行：<br> &#47;&#47;扩容原items数组<br>            items = new int[n];","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1569710250,"ip_address":"","comment_id":136904,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5864517792","product_id":100017301,"comment_content":"public class ArrayStacks {<br><br>    private int[] items;<br><br>    private int n;<br><br>    private int count;<br><br>    public ArrayStacks(int n) {<br>        this.items = new int[n];<br>        this.n = n;<br>        this.count = 0;<br>    }<br><br>    public void push(int item) {<br>        if (count == n) {<br>            &#47;&#47;相等2倍的方式进行扩容<br>            n = n * 2;<br>            int[] temps = new int[n];<br>            for (int i = 0; i &lt; items.length; i++) {<br>                temps[i] = items[i];<br>            }<br>            &#47;&#47;清空原数组<br>            items = null;<br>            &#47;&#47;扩容原items数组<br>            items = new int[n];<br>            &#47;&#47;重新赋值<br>            items = temps;<br>        }<br>        items[count] = item;<br>        ++count;<br>    }<br><br>    public int pop() {<br>        if (count == 0) {<br>            return -1;<br>        }<br>        int tem = items[count - 1];<br>        --count;<br>        return tem;<br>    }<br>}<br>以2倍方式进行扩容，老师帮忙看下还有优化的方式吗？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468854,"discussion_content":"不需要下面两行：\n //扩容原items数组\n            items = new int[n];","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569710250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121641,"user_name":"圆哥哥呐丶","can_delete":false,"product_type":"c1","uid":1238051,"ip_address":"","ucode":"8E56E3E68A3836","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/23/ac13d916.jpg","comment_is_top":false,"comment_ctime":1565173180,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5860140476","product_id":100017301,"comment_content":"关于那个扩容k-1次，评论有人不明白， 我把我理解的给大家说一下，大家仔细看老师说的 [接下来的 K-1 次入栈操作，我们都不需要再重新申请内存]    老师讲的是 接下来的k-1次操作不需要重新申请内存，很多人都说这里应该是k次， 其实仔细看看 为啥不是k次呢，因为他说的是不需要申请内存的操作，而当你数组满了只有，再进来的一次入栈操作 是需要申请内存的，所以这一次操作不计入k-1次。","like_count":1},{"had_liked":false,"id":112868,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1562834277,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5857801573","product_id":100017301,"comment_content":"算法_008<br># 问题：<br>1. 就像文中的内容，因为这个场景符合栈的特性。<br>栈可以实现的功能，用其他数据结构都能实现，所以用其他的也行。<br>2. 看了其他同学的答案，有些地方不是很认同，希望老师解答一下：<br>本节课说的栈，是程序运行时，在逻辑上的组织方式。<br>JVM中的栈区，堆区都有着对应的特点和功能，JVM也是一个软件，它使用它的规则来组织物理内存，所以JVM的堆区和栈区不应该是物理层的概念，而是基于JVM的逻辑组织后的运行时概念。<br><br># 内容：<br>1. 栈(受限的线性表: 一端插入删除) <br>2. 复杂度：<br> - O(1): 插入&#47;删除、数组&#47;链表<br> - 摊还分析法的实践(可拓展书顺序栈插入)<br>3. 应用：<br> - 回退栈(浏览器前进后退，AndroidUI的回退栈)<br> - 函数调用栈<br> - 表达式求值<br> - 括号匹配<br><br># 感想：<br>今天比较有感触的地方是：讨论到为什么要使用栈？<br>因为功能简单，很多数据结构都可以实现栈的功能，在这种情况下，依然要用栈，是因为**在后进先出，一端插入删除的场景使用栈，这是我们约定的规范**。<br>如果所有人都遵守这样的规范，那么程序员在查看代码的时候，对于业务的理解就会更容易。否则，所有的人都用自己的方式实现栈的功能，那么我们花了很多精彩才弄明白：哦，原来这是一个custom的栈。。。<br><br>除了发明新技术，统一规范也可以提高效率。<br>一次与国外的团队交接项目，发现他们是按照不同场景使用几种接口方法的；但是，在国内的很多公司，不管业务是否正常全部返回200, 接口方法全部使用POST。","like_count":1},{"had_liked":false,"id":101570,"user_name":"倡印","can_delete":false,"product_type":"c1","uid":1455958,"ip_address":"","ucode":"4F53AA5D017D89","user_header":"https://static001.geekbang.org/account/avatar/00/16/37/56/11068390.jpg","comment_is_top":false,"comment_ctime":1559874152,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5854841448","product_id":100017301,"comment_content":"递归实现也有栈","like_count":1,"discussions":[{"author":{"id":1689365,"avatar":"https://static001.geekbang.org/account/avatar/00/19/c7/15/24bf166a.jpg","nickname":"pikachu122","note":"","ucode":"43FE4DBC872FFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":116405,"discussion_content":"所以递归的空间复杂度往往在O(n)及以上，但某些问题中往往有时间复杂度与递归相同，且空间复杂度能做到O(1)的其他方法。而且递归感觉比较难以理解，虽然递归的代码往往看着比较简洁...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578061454,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77519,"user_name":"珠闪闪","can_delete":false,"product_type":"c1","uid":1300447,"ip_address":"","ucode":"45BE0D586A3839","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eov38ZkwCyNoBdr5drgX0cp2eOGCv7ibkhUIqCvcnFk8FyUIS6K4gHXIXh0fu7TB67jaictdDlic4OwQ/132","comment_is_top":false,"comment_ctime":1552958937,"is_pvip":false,"replies":[{"id":"28338","content":"我自己写的啊","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1552970912,"ip_address":"","comment_id":77519,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847926233","product_id":100017301,"comment_content":"老师，请问一下，代码是你自己写的么？还是找了别人的代码？样例的代码是比较好的实现方案吗","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443756,"discussion_content":"我自己写的啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552970912,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":46877,"user_name":"晴天小雨","can_delete":false,"product_type":"c1","uid":1206263,"ip_address":"","ucode":"F092237C15BAD2","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/f7/1ca42972.jpg","comment_is_top":false,"comment_ctime":1543995567,"is_pvip":false,"replies":[{"id":"16934","content":"不是一次性 我画图为了偷懒 没分开画","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544149160,"ip_address":"","comment_id":46877,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5838962863","product_id":100017301,"comment_content":"王老师，我想问一个问题，就是3 + 5 * 8 +6图解中的⑤--&gt;⑥的过程是，是一次性执行完5 * 8 + 3的计算，还是先执行5 * 8，此时操作栈剩下3和40，运算符栈只剩下“+”，当遇到优先级相同的“-”时，才执行3 + 40的计算？再次，先谢谢老师答疑。","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431581,"discussion_content":"不是一次性 我画图为了偷懒 没分开画","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544149160,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":43060,"user_name":"Damon","can_delete":false,"product_type":"c1","uid":1013281,"ip_address":"","ucode":"E07522227DE1E4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/21/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1543153554,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5838120850","product_id":100017301,"comment_content":"&#47;&#47;顺序栈<br>class ArrayStack {<br><br>    constructor(n){<br><br>        this.items = new Array(n);<br>        this.n = n;<br>        this.count = 0;<br>    }<br><br><br>    pop(){<br><br>        if (this.count&gt;0){<br>            this.count--;<br>            return  this.items[this.count];<br>        } else {<br>            return null;<br>        }<br><br><br>    }<br><br><br>    peek(){<br><br>        if (this.count&gt;0){<br>            return  this.items[this.count-1];<br>        } else {<br>            return null;<br>        }<br>    }<br><br>    push(item){<br><br>        if (this.count &lt; this.n){<br>            this.items[this.count] = item;<br>            this.count ++;<br>            this.print();<br>            return true;<br>        } else {<br>            console.log(&#39;栈满&#39;);<br>            return false;<br>        }<br><br>    }<br><br><br>    isEmpty(){<br>        return this.count == 0 ?true:false;<br>    }<br><br>    print(){<br>        let string=&#39;&#39;;<br>        for(let i=this.count-1;i&gt;=0;i--){<br>            string+=this.items[i]+&#39;--&#39;;<br>        }<br>        console.log(string);<br>    }<br><br><br>}","like_count":1},{"had_liked":false,"id":42497,"user_name":"Geek_987169","can_delete":false,"product_type":"c1","uid":1180853,"ip_address":"","ucode":"4B2955A044805D","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/b5/8bc4790b.jpg","comment_is_top":false,"comment_ctime":1542962181,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5837929477","product_id":100017301,"comment_content":"老师，问下<br>一个循环循环n次，然后内部随机循环1~n次，假设内部循环1~n次的概率均为p=1&#47;n,则计算时间复杂度的公式如下:<br>n*n*p+n*(n-1)*p+...+n*[n-(n-2)]*p+n*[n-(n-1)]*p<br>这个公式对吗？","like_count":1},{"had_liked":false,"id":39359,"user_name":"进阶的码农","can_delete":false,"product_type":"c1","uid":1017821,"ip_address":"","ucode":"D8991282640334","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/dd/4f53f95d.jpg","comment_is_top":false,"comment_ctime":1542253461,"is_pvip":false,"replies":[{"id":"14104","content":"是由你的行为决定清不清除y栈 而不是与栈内数据对比","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542279994,"ip_address":"","comment_id":39359,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5837220757","product_id":100017301,"comment_content":"不明白，为啥插入d了，c还在Y栈里还是可以压入的，在浏览器里试确实像作者说的那样，但是写代码的话Y栈里c清除的条件是什么，X栈顶不是b？难道判断c该不该清除还得把b存起来和X栈顶数据对比？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429028,"discussion_content":"是由你的行为决定清不清除y栈 而不是与栈内数据对比","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542279994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36566,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1541152142,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5836119438","product_id":100017301,"comment_content":"动态栈的入栈的时间均摊时间复杂度分析：<br>假设栈的初始化空间大小为n，如果要扩容的话那么就是n+1的空间大小<br>栈有空间与栈没有空间的插入的概率为1&#47;(n+1)<br>有空间的情况（在数组末尾插入）：<br>若在第一个位置插入执行次数为1次，直接插入；<br>若在第二个位置插入执行次数为1次，直接插入；<br>...<br>若在第n个位置插入执行次数为1次，直接插入；<br>这是还需要插入，则需要扩容<br>若在n+1个位置插入执行次数为n，直接插入，需要循环之前的数据复制到新的空间。<br>公式整理：1*(1&#47;(n+1))+1*(1&#47;(n+1))+....+n*(1&#47;(n+1))<br>根据去除低次项原则：1&#47;(n+1)小于n&#47;(n+1)。所以上述公式简化为n&#47;(n+1)。再去除常数项。最后均摊时间复杂度为O(1)。","like_count":1},{"had_liked":false,"id":35176,"user_name":"龙恨","can_delete":false,"product_type":"c1","uid":1036107,"ip_address":"","ucode":"03F29A4BEA0072","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cf/4b/20e400e7.jpg","comment_is_top":false,"comment_ctime":1540446597,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5835413893","product_id":100017301,"comment_content":"1、用两个栈可以实现浏览器的前进后退功能<br>2、栈是一种操作受限的线性表：只允许在一端插入和删除数据<br>3、栈的意义：避免了数组或者链表因暴露太多接口，而使用时不可控，容易出错的问题。<br>4、栈的实现：数组实现的称为顺序栈，链表实现的称为链式栈<br>5、空间复杂度是指除了原本额数据存储空间外，算法运行还需要额外的存储空间。<br>6、实现支持动态扩容的顺序栈：当原有申请的数组空间满了后，申请一块更大的内存，将原有的数据全部拷贝过去即可。其时间复杂度为O（1）（最好情况为O（1），最坏情况为O（n），以均摊时间复杂度分析得到O（1））<br>7、栈的三个典型应用：函数调用，表达式求值、括号匹配。","like_count":1},{"had_liked":false,"id":34643,"user_name":"小秋","can_delete":false,"product_type":"c1","uid":1243320,"ip_address":"","ucode":"68AC584C14DC95","user_header":"https://static001.geekbang.org/account/avatar/00/12/f8/b8/4df14e11.jpg","comment_is_top":false,"comment_ctime":1540251724,"is_pvip":false,"replies":[{"id":"12313","content":"这就类似于 你学数学对你工作有啥指导意义？<br><br>实现链表和栈 可以加深理解 理解深了 就能灵活应用","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540255315,"ip_address":"","comment_id":34643,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5835219020","product_id":100017301,"comment_content":"请问老师，实现链表和栈的代码对工作编程有什么指导意义吗？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427283,"discussion_content":"这就类似于 你学数学对你工作有啥指导意义？\n\n实现链表和栈 可以加深理解 理解深了 就能灵活应用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540255315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32585,"user_name":"qinggeouye","can_delete":false,"product_type":"c1","uid":1251536,"ip_address":"","ucode":"5B53EEDD7BEC9C","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/d0/49b06424.jpg","comment_is_top":false,"comment_ctime":1539616475,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5834583771","product_id":100017301,"comment_content":"关于支持动态扩容的顺序栈，我的理解，如有不对，还请老师指正，谢谢~<br><br>1、要实现这样的栈，只需要底层依赖一个支持动态扩容的数组即可。也就是说栈满了之后，底层自动帮我们申请更大的内存扩容数组，先把原数组的数据搬移到新数组，再把要入栈的新数据插入新数组。（这里，原数组会自动释放内存吗? ）<br><br>2、原数组的 n 个元素做了 n 次入栈操作，栈满了之后，第 n+1 个数据的入栈包含三步：申请更大内存、原数组的数据搬移（ 重新入栈到新数组，时间复杂度 O(n) ）、以及第 n+1 个数据的入栈操作。<br>这样一来，第 n+1 个数据入栈的时间复杂度为 O(n)，再均摊到前 n 个数据的入栈上面，则时间复杂度变为 O(1) 。","like_count":1},{"had_liked":false,"id":32183,"user_name":"Andy","can_delete":false,"product_type":"c1","uid":1012037,"ip_address":"","ucode":"D69ED1BAF42262","user_header":"https://static001.geekbang.org/account/avatar/00/0f/71/45/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1539480224,"is_pvip":false,"replies":[{"id":"11754","content":"等集中答疑吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539528634,"ip_address":"","comment_id":32183,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5834447520","product_id":100017301,"comment_content":"老师，每次你提的问题能不能给个标准答案，或者写下你的思考，很多学员回答的思考题，并没有得到你的反馈啊！","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426668,"discussion_content":"等集中答疑吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539528634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31584,"user_name":"挚爱的回锅肉","can_delete":false,"product_type":"c1","uid":1240231,"ip_address":"","ucode":"668AF085DABA60","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/a7/646a45fe.jpg","comment_is_top":false,"comment_ctime":1539237690,"is_pvip":false,"replies":[{"id":"11410","content":"好的 我考虑一下","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539268756,"ip_address":"","comment_id":31584,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5834204986","product_id":100017301,"comment_content":"希望思考题能下一章或者按阶段统一发一下。<br>虽然大部分都能在网上查到，还是希望看到老师的见解。","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426416,"discussion_content":"好的 我考虑一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539268756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31583,"user_name":"挚爱的回锅肉","can_delete":false,"product_type":"c1","uid":1240231,"ip_address":"","ucode":"668AF085DABA60","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/a7/646a45fe.jpg","comment_is_top":false,"comment_ctime":1539237689,"is_pvip":false,"replies":[{"id":"11411","content":"好的 我考虑一下","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539268769,"ip_address":"","comment_id":31583,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5834204985","product_id":100017301,"comment_content":"希望思考题能下一章或者按阶段统一发一下。<br>虽然大部分都能在网上查到，还是希望看到老师的见解。","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426415,"discussion_content":"好的 我考虑一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539268769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31484,"user_name":"sky","can_delete":false,"product_type":"c1","uid":1060892,"ip_address":"","ucode":"B29CA98AC45F88","user_header":"https://static001.geekbang.org/account/avatar/00/10/30/1c/e160955d.jpg","comment_is_top":false,"comment_ctime":1539217351,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5834184647","product_id":100017301,"comment_content":"第一问；因为在函数调用的时候，前一个调用的函数的变量或者返回值可能依赖于后一个函数的调用，满足后进先出原则，所以用栈这个数据结构很合适<br>第二个问题：不太懂jvm，但是看描述，這裡面栈的概念和第一问是差不多的，应该是同一个栈","like_count":1},{"had_liked":false,"id":31276,"user_name":"nkulpj","can_delete":false,"product_type":"c1","uid":1242666,"ip_address":"","ucode":"734AE87E009B9C","user_header":"https://static001.geekbang.org/account/avatar/00/12/f6/2a/b21a78d6.jpg","comment_is_top":false,"comment_ctime":1539141793,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5834109089","product_id":100017301,"comment_content":"#栈实现括号匹配！<br>class Solution:<br>    def isValid(self, s):<br>        &quot;&quot;&quot;<br>        :type s: str<br>        :rtype: bool<br>        &quot;&quot;&quot;<br>        #栈<br>        a=[]<br>        if len(s)==0:return True<br>        <br>        for i in range(len(s)):<br>        \t#入栈<br>            if s[i]==&#39;(&#39;or s[i]==&#39;{&#39; or s[i]==&#39;[&#39; :a.append(s[i])<br>            else:<br>                if len(a)==0:return False<br>                if s[i]==&#39;)&#39; and a[-1]!=&#39;(&#39;:return False<br>                if s[i]==&#39;]&#39; and a[-1]!=&#39;[&#39;:return False<br>                if s[i]==&#39;}&#39; and a[-1]!=&#39;{&#39;:return False<br>                a.pop()<br>        return len(a)==0","like_count":1},{"had_liked":false,"id":30905,"user_name":"后端进阶","can_delete":false,"product_type":"c1","uid":1125656,"ip_address":"","ucode":"480F48F5378307","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/18/918eaecf.jpg","comment_is_top":false,"comment_ctime":1539046067,"is_pvip":false,"replies":[{"id":"11091","content":"都先入栈好像不对吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539048594,"ip_address":"","comment_id":30905,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5834013363","product_id":100017301,"comment_content":"老师，3+5*8-6，为什么不是把所有操作数栈和运算符栈都入栈了在进行计算呢？像您讲解的先乘法和加法对比优先顺序计算完再将减号入栈再计算，这样做是不是可以节省栈内存空间了？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426141,"discussion_content":"都先入栈好像不对吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539048594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30798,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1538999635,"is_pvip":false,"replies":[{"id":"11186","content":"第一个操作符直接入栈 不用比较","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539084266,"ip_address":"","comment_id":30798,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5833966931","product_id":100017301,"comment_content":"编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素的栈顶元素进行比较<br>根据你讲的遇到操作数入栈 3+5*8-6 首先 将3入操作数栈，此时操作数栈中就只有一个元素 向右读到+号 此时 运算符栈内还没有运算符 怎么比较优先级，比较了优先级以后，假设认定优先级高了 此时操作数栈中就一个元素 怎么取得两个元素 这一块一来就懵了 还需要老师和大佬们指教一下","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426103,"discussion_content":"第一个操作符直接入栈 不用比较","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539084266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30766,"user_name":"BitInit","can_delete":false,"product_type":"c1","uid":1007271,"ip_address":"","ucode":"BDDDA0F51B1EFB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/a7/8dc374e2.jpg","comment_is_top":false,"comment_ctime":1538991679,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5833958975","product_id":100017301,"comment_content":"JVM中的栈的本质和文中栈是一样的，JVM中栈是线程不共享，每个线程都有一个栈，栈中存储的是函数调用链，每一个函数在栈中组成一个栈帧，栈帧中存储该函数的局部变量值,引用，返回地址等。<br><br>对于一个调用链main-&gt;a-&gt;b，即main调用a，a再调用b，则在栈中从栈低到栈顶存储main的栈帧，a的栈帧和b的栈帧，当b运行完成后，则b栈帧就出栈。","like_count":1},{"had_liked":false,"id":30742,"user_name":"smx","can_delete":false,"product_type":"c1","uid":1000413,"ip_address":"","ucode":"E0709E14D7B205","user_header":"https://static001.geekbang.org/account/avatar/00/0f/43/dd/1ca3c992.jpg","comment_is_top":false,"comment_ctime":1538987287,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5833954583","product_id":100017301,"comment_content":"迫不及待想看后面的更新啊，后面的能看看草图，草稿也是极好的啊","like_count":1},{"had_liked":false,"id":30733,"user_name":"小老鼠","can_delete":false,"product_type":"c1","uid":1257460,"ip_address":"","ucode":"C663A0C863A515","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/f4/2dede51a.jpg","comment_is_top":false,"comment_ctime":1538985383,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5833952679","product_id":100017301,"comment_content":"嵌套函数中的变量也是用栈的技术吧！","like_count":1},{"had_liked":false,"id":30571,"user_name":"ZerahMu","can_delete":false,"product_type":"c1","uid":1115321,"ip_address":"","ucode":"248CE3754330FE","user_header":"https://static001.geekbang.org/account/avatar/00/11/04/b9/075d723b.jpg","comment_is_top":false,"comment_ctime":1538928357,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5833895653","product_id":100017301,"comment_content":"深夜更，占沙发，国庆玩嗨了，落下三节课，明天地铁开始补了，晚安","like_count":1},{"had_liked":false,"id":360227,"user_name":"码狐","can_delete":false,"product_type":"c1","uid":1234879,"ip_address":"新加坡","ucode":"A4666D3AF30D6E","user_header":"https://static001.geekbang.org/account/avatar/00/12/d7/bf/9d8984b7.jpg","comment_is_top":false,"comment_ctime":1666321140,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1666321140","product_id":100017301,"comment_content":"栈的特性适合场景，并且屏蔽了很多不需要暴露的接口避免误操作","like_count":0},{"had_liked":false,"id":358267,"user_name":"111","can_delete":false,"product_type":"c1","uid":3109487,"ip_address":"北京","ucode":"D6E8E83A118A3E","user_header":"https://static001.geekbang.org/account/avatar/00/2f/72/6f/44c10658.jpg","comment_is_top":false,"comment_ctime":1664157341,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664157341","product_id":100017301,"comment_content":"总结：<br>1. 栈的特性：先入先出<br>2. 栈的实现：数组，链表<br>3. 栈的时间复杂度：最好，最差，均摊<br>4. 和jvm不同，一个是数据结构，一个是数据结构的实现<br>5. 因为栈的特性符合函数的嵌套","like_count":0},{"had_liked":false,"id":356714,"user_name":"Sherk","can_delete":false,"product_type":"c1","uid":2156245,"ip_address":"广东","ucode":"AFE3E7F158258D","user_header":"https://static001.geekbang.org/account/avatar/00/20/e6/d5/4f1fc074.jpg","comment_is_top":false,"comment_ctime":1662525899,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662525899","product_id":100017301,"comment_content":"思考1: 因为函数调用这种情况符合先进后出这种逻辑，调用者a调用b.b返回后才能计算c。<br>思考二：我理解jvm的栈内存是的数据结构上是栈。","like_count":0},{"had_liked":false,"id":356349,"user_name":"xiuuuuuu","can_delete":false,"product_type":"c1","uid":1390592,"ip_address":"浙江","ucode":"5F0787C682F9DE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/8VUSuibHy9QFc7DbbmNx4TeTFax9Ria9m88Z3rnCGjRicWIQvYueqyuSLpqxY4tP651RtLXiakuT24jXB6Rj2JgibicQ/132","comment_is_top":false,"comment_ctime":1662187030,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1662187030","product_id":100017301,"comment_content":"浏览器前进后退功能用双链表性能上是不是会更好一些?每次操作都是o1的复杂度，不会涉及到清空栈的操作","like_count":0},{"had_liked":false,"id":355954,"user_name":"🐻","can_delete":false,"product_type":"c1","uid":1043072,"ip_address":"北京","ucode":"534EDAD496A0E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ea/80/8759e4c1.jpg","comment_is_top":false,"comment_ctime":1661868149,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661868149","product_id":100017301,"comment_content":"第一题<br><br>函数调用时，函数所用的内存空间符合后进先出的顺序，既被调用函数的内存空间先被销毁，再销毁调用函数的，栈是最适合的内存结构。<br><br>第二题<br><br>数据结构中栈是一种符合后进先出选择的抽象数据结构。编程语言中，栈表示的是函数的栈帧这一块内存空间。里面存储了函数的局部变量。","like_count":0},{"had_liked":false,"id":349070,"user_name":"东方拓睿","can_delete":false,"product_type":"c1","uid":1605058,"ip_address":"","ucode":"1FD25D75CAC7C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/7d/c2/e6332a1b.jpg","comment_is_top":false,"comment_ctime":1655712312,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655712312","product_id":100017301,"comment_content":"1、我们在讲栈的应用时，讲到用函数调用栈来保存临时变量，为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？<br>个人理解是这样的，因为函数调用是按照一定次序的进行的，有先后顺序的，只有一个方向可以操作，所以用栈是最合适的，用其他的数据结构也是能实现的，只不过实现的形式也是栈的样式<br>","like_count":0},{"had_liked":false,"id":348315,"user_name":"Geek_32cca0","can_delete":false,"product_type":"c1","uid":2743957,"ip_address":"","ucode":"A24204F2C0485E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJF8vUICSb6yEleDjtsTe8OrwqmpaoxlicHB7NutCwMMs5ZvsQrguEJ3VL0x5I85jS6xlbrWcMdWKA/132","comment_is_top":false,"comment_ctime":1654954190,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654954190","product_id":100017301,"comment_content":"leetcode 224题目难度较大","like_count":0},{"had_liked":false,"id":346519,"user_name":"Geek_652490","can_delete":false,"product_type":"c1","uid":1817165,"ip_address":"","ucode":"0612EE1FD02AF1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/0qP9dQyibmPu1JUAan9bXEXZBAaOetRStstIcQDXZUFdU9jHb5W3RlNfCBI0kVkZzZTf6NbXwSY4IQqOsVSNQibw/132","comment_is_top":false,"comment_ctime":1653210918,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653210918","product_id":100017301,"comment_content":"为什么函数调用要用“栈”来保存临时变量呢？<br>- 因为内存上靠近，访问速度快，且生命周期一致不影响内存回收。<br><br>","like_count":0},{"had_liked":false,"id":343520,"user_name":"Tyrone","can_delete":false,"product_type":"c1","uid":2710279,"ip_address":"","ucode":"46EE691EABAAB1","user_header":"https://static001.geekbang.org/account/avatar/00/29/5b/07/6b3a8d78.jpg","comment_is_top":false,"comment_ctime":1650889895,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650889895","product_id":100017301,"comment_content":"有没有大佬实现了栈的四则运算","like_count":0},{"had_liked":false,"id":341314,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1649516305,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1649516305","product_id":100017301,"comment_content":"问题1：函数调用的过程具有嵌套的特性，有嵌套就意味着后进先出的特性，这个跟栈的特性正好符合<br>问题2：跟我们这里提到的栈的作用是一样的，也是用于Java语言的方法调用。JVM中的栈，包括虚拟机栈和本地方法栈，虚拟机栈是Java线程的私有栈，在线程中执行函数的过程就是在自己的虚拟机栈中入栈和出栈的过程；本地方法栈就是通过JVM调用本地方法时候的函数刁永过程的辅助数据结构。","like_count":0},{"had_liked":false,"id":333954,"user_name":"201202077","can_delete":false,"product_type":"c1","uid":2881261,"ip_address":"","ucode":"2FB173EB6A9A2E","user_header":"","comment_is_top":false,"comment_ctime":1644636050,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644636050","product_id":100017301,"comment_content":"c语言下栈的实现：<br>struct stack {<br>    int* items;<br>    int count;<br>    int n;<br>}<br><br>void initStack(struct stack* istack, int n)<br>{<br>    istack-&gt;items = malloc(sizeof(int)*n);<br>    istack-&gt;n = n;<br>    istack-&gt;count = 0;<br>}<br><br>int stackPop(struct stack* istack)<br>{<br>\tif(count == 0){<br>\t\treturn -1;<br>\t} else {<br>\t\treturn istack-&gt;items[--(istack-&gt;count)];<br>\t}<br>}<br><br>bool stackPush(struct stack* istack, int item)<br>{<br>\tif(istack-&gt;count == n) return false;<br>\tistack-&gt;items[(istack-&gt;count)++] = item;<br>\treturn true;<br>}","like_count":0},{"had_liked":false,"id":331288,"user_name":"不二","can_delete":false,"product_type":"c1","uid":1076451,"ip_address":"","ucode":"CDB603B9F87354","user_header":"https://static001.geekbang.org/account/avatar/00/10/6c/e3/45f550b5.jpg","comment_is_top":false,"comment_ctime":1642517201,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642517201","product_id":100017301,"comment_content":"在此推荐一篇文章，两位作者分别从各自的视角对栈进行了解析，作为学习者可以进行比较学习，互为补充。文章连接：https:&#47;&#47;leetcode-solution-leetcode-pp.gitbook.io&#47;leetcode-solution&#47;thinkings&#47;monotone-stack","like_count":0},{"had_liked":false,"id":329518,"user_name":"A1Pass","can_delete":false,"product_type":"c1","uid":2407043,"ip_address":"","ucode":"711D89B2946D58","user_header":"https://static001.geekbang.org/account/avatar/00/24/ba/83/3cde5a1f.jpg","comment_is_top":false,"comment_ctime":1641384262,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641384262","product_id":100017301,"comment_content":"&#47;&#47;&#47; 定义一个使用Array实现的栈<br>public struct ArrayStack&lt;T&gt; {<br>  <br>  &#47;&#47;&#47; 使用数组来存储栈里面的元素<br>  private var elements: [T]<br><br>  &#47;&#47;&#47; 初始化（构造器）<br>  public init() {<br>    self.elements = []<br>  }<br>  <br>  &#47;&#47;&#47; 出栈<br>  &#47;&#47;&#47; - Returns: 返回出栈的元素<br>  public mutating func pop() -&gt; T? {<br>    return self.elements.popLast()<br>  }<br>  <br>  &#47;&#47;&#47; 压栈<br>  &#47;&#47;&#47; - Parameter element: 将element压入栈中<br>  public mutating func push(_ element: T) {<br>    self.elements.append(element)<br>  }<br>  <br>  &#47;&#47;&#47; 获取栈顶元素（栈顶元素不出栈）<br>  &#47;&#47;&#47; - Returns: 栈顶元素<br>  public mutating func peek() -&gt; T? {<br>    return self.elements.last<br>  }<br>  <br>  &#47;&#47;&#47; 判断栈是否为空<br>  &#47;&#47;&#47; - Returns: 是否为空<br>  public mutating func isEmpty() -&gt; Bool {<br>    return self.elements.isEmpty<br>  }<br>  <br>  &#47;&#47;&#47; 获取当前栈中元素的个数<br>  public var count : Int {<br>    return self.elements.count<br>  }<br>}<br><br>Swift顺序栈","like_count":0},{"had_liked":false,"id":326592,"user_name":"南风不竞","can_delete":false,"product_type":"c1","uid":1574207,"ip_address":"","ucode":"934B77DDB78359","user_header":"https://static001.geekbang.org/account/avatar/00/18/05/3f/d59e9839.jpg","comment_is_top":false,"comment_ctime":1639574164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639574164","product_id":100017301,"comment_content":"栈在表达式求值中的应用，如果加入括号之后, 左括号看做最低级直接入运算符栈但是不进行比较, 右括号看做最高级,依次比较出栈计算, 直到遇左括号把左括号出栈,不知道想法对不对","like_count":0},{"had_liked":false,"id":324249,"user_name":"万历十五年","can_delete":false,"product_type":"c1","uid":1122150,"ip_address":"","ucode":"3D8CF5DF847AE8","user_header":"https://static001.geekbang.org/account/avatar/00/11/1f/66/59e0647a.jpg","comment_is_top":false,"comment_ctime":1638348793,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638348793","product_id":100017301,"comment_content":"这个问题问得不够严谨。<br>我觉得无论是jvm的本地栈还是方法栈，还是操作系统内存中的栈，还是本章中提到的数据结构栈，只要它叫做栈，它就具有栈的特点，可以发挥栈的功能，这是栈的本质，在这一点上是统一的。我们就可以把栈的功能特点用在各种适合业务需求的地方。可以是jvm中，可以是操作系统的内存中，也可以用于自身的业务代码中，或者就像本章的教学中。<br>多说一句，个人认为之所以创建各种数据结构以适应不同的算法，一个重要原因就是数据的封装和抽象。相同数据结构的封装和抽象是相同的，这样一是方便我们自身使用，二是方便多人合作交流。","like_count":0},{"had_liked":false,"id":323812,"user_name":"Tina","can_delete":false,"product_type":"c1","uid":2851354,"ip_address":"","ucode":"8D6D9F6E3D0A99","user_header":"https://static001.geekbang.org/account/avatar/00/2b/82/1a/30676c2e.jpg","comment_is_top":false,"comment_ctime":1638171697,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638171697","product_id":100017301,"comment_content":"栈是一种操作受限的线性表，先进后出，后进先出只允许在一端插入和删除数据。虽然操作受限，但相比于更加灵活的数组和链表，反而有更适合它的场景。当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，这时候就适合用“栈”这种数据结构。<br><br>栈既可以用数组实现，也可以用链表实现。用数组实现的栈叫做顺序栈，用链表实现的栈叫做链式栈。不管是哪一个，插入和删除操作都只在一端进行一两个数据的操作，空间复杂度和时间复杂度都是O(1)。<br><br>如果需要支持动态扩容的栈，像数组的动态扩容一样，栈满时便要创建一个容量更大的栈，将之前的全都copy过去，这时时间复杂度是O(n)，但是只是个别的情况，所以均摊复杂度依然等于最好情况复杂度，是O(1)。","like_count":0},{"had_liked":false,"id":319588,"user_name":"拉布拉多、谁都能摸","can_delete":false,"product_type":"c1","uid":2832351,"ip_address":"","ucode":"F4E4FDDFA0CCF4","user_header":"https://static001.geekbang.org/account/avatar/00/2b/37/df/d49eab02.jpg","comment_is_top":false,"comment_ctime":1635859436,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635859436","product_id":100017301,"comment_content":"根据判断括号格式是否正确那个例子，想到了前面那个判断是否是回数的问题，用栈解决就很方便了。再联想到方法的压栈弹栈的先进后出模型，不也是括号问题么，先括起来的最后圆。（方法也是写在括号内部的）所以以后遇到可以抽象成“括号”或者嵌套的都可以先想到栈了。","like_count":0},{"had_liked":false,"id":319069,"user_name":"时不时充充电","can_delete":false,"product_type":"c1","uid":2453902,"ip_address":"","ucode":"F45712325DAE50","user_header":"https://static001.geekbang.org/account/avatar/00/25/71/8e/31458837.jpg","comment_is_top":false,"comment_ctime":1635565658,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635565658","product_id":100017301,"comment_content":"class Solution {<br>public:<br>    bool isValid(string s) {<br>        stack&lt;char&gt; st;<br>        for(int i=0;i&lt;s.size();i++){<br>            if(s[i]==&#39;(&#39;||s[i]==&#39;[&#39;||s[i]==&#39;{&#39;){<br>                st.push(s[i]);<br>            }<br>            else if(!st.empty()){<br>                char c = st.top();st.pop();<br>                if(s[i]==&#39;]&#39; &amp;&amp; c!=&#39;[&#39;)return false;<br>                if(s[i]==&#39;)&#39; &amp;&amp; c!=&#39;(&#39;) return false;<br>                if(s[i]==&#39;}&#39; &amp;&amp; c!=&#39;{&#39;) return false;<br>            }<br>            else return false;<br>        }<br>        return st.empty();<br>    }<br>};","like_count":0},{"had_liked":false,"id":316621,"user_name":"Late ,late，a  little  late.","can_delete":false,"product_type":"c1","uid":2719403,"ip_address":"","ucode":"2EF937F48A765B","user_header":"https://static001.geekbang.org/account/avatar/00/29/7e/ab/7a008718.jpg","comment_is_top":false,"comment_ctime":1634455958,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634455958","product_id":100017301,"comment_content":"老师，github链接给一下","like_count":0},{"had_liked":false,"id":315951,"user_name":"纪老猴子","can_delete":false,"product_type":"c1","uid":1468554,"ip_address":"","ucode":"05962FE7279802","user_header":"https://static001.geekbang.org/account/avatar/00/16/68/8a/af8e49a8.jpg","comment_is_top":false,"comment_ctime":1634086414,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634086414","product_id":100017301,"comment_content":"不一定非得用栈来保存局部变量，python解释器中保存局部变量使用的一个作用域内的dict","like_count":0},{"had_liked":false,"id":315717,"user_name":"付伟","can_delete":false,"product_type":"c1","uid":1397649,"ip_address":"","ucode":"97DC8054E30D97","user_header":"https://static001.geekbang.org/account/avatar/00/15/53/91/5a160371.jpg","comment_is_top":false,"comment_ctime":1633952098,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633952098","product_id":100017301,"comment_content":"栈就是因为操作简单，所需要提供的API 少才应用这么广泛","like_count":0},{"had_liked":false,"id":314449,"user_name":"崔晓乐","can_delete":false,"product_type":"c1","uid":2744727,"ip_address":"","ucode":"5B94010456CAD8","user_header":"https://static001.geekbang.org/account/avatar/00/29/e1/97/9387711d.jpg","comment_is_top":false,"comment_ctime":1633066922,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633066922","product_id":100017301,"comment_content":"学习完知识后刷几道题对应的题目，真的学习效率很高","like_count":0},{"had_liked":false,"id":314246,"user_name":"俯瞰风景.","can_delete":false,"product_type":"c1","uid":1044166,"ip_address":"","ucode":"A6DB68B7B84AEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/c6/bebcbcf0.jpg","comment_is_top":false,"comment_ctime":1632912266,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632912266","product_id":100017301,"comment_content":"栈是操作受限的线性表，相当于一个密闭空间，出入口是同一个，主要特征是后进先出。","like_count":0},{"had_liked":false,"id":309613,"user_name":"Nicer","can_delete":false,"product_type":"c1","uid":2725703,"ip_address":"","ucode":"75E5DAB1A5CE8A","user_header":"https://static001.geekbang.org/account/avatar/00/29/97/47/9bc9b07d.jpg","comment_is_top":false,"comment_ctime":1630258266,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630258266","product_id":100017301,"comment_content":"浏览器源码中，打开新页面时，是不是少了一步清空Y栈，求解，谢谢！","like_count":0},{"had_liked":false,"id":309147,"user_name":"🌴林子洛","can_delete":false,"product_type":"c1","uid":2744724,"ip_address":"","ucode":"DE0C88D16AADF8","user_header":"https://static001.geekbang.org/account/avatar/00/29/e1/94/2c5e62d1.jpg","comment_is_top":false,"comment_ctime":1629960991,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629960991","product_id":100017301,"comment_content":"我认为使用栈式应用了进出一一对应的关系；<br>楼下留言：在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。","like_count":0},{"had_liked":false,"id":307931,"user_name":"李叶","can_delete":false,"product_type":"c1","uid":1470449,"ip_address":"","ucode":"41B33FA8526E48","user_header":"https://static001.geekbang.org/account/avatar/00/16/6f/f1/35f9f16f.jpg","comment_is_top":false,"comment_ctime":1629331437,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629331437","product_id":100017301,"comment_content":"栈这个数据结构只有入栈出栈两种操作，操作受限但更可控，有特定的应用场景#函数调用栈，表达式计算，扩号匹配等。与jvm中的栈不是一回事，这是一块物理空间，另外一个是抽象的数据结构","like_count":0},{"had_liked":false,"id":304889,"user_name":"大祭司","can_delete":false,"product_type":"c1","uid":1831099,"ip_address":"","ucode":"06479A180B8DED","user_header":"https://static001.geekbang.org/account/avatar/00/1b/f0/bb/f7025f42.jpg","comment_is_top":false,"comment_ctime":1627659930,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627659930","product_id":100017301,"comment_content":"单链表实现栈，只需在第一节点增加删除或删除取数据即可实现","like_count":0},{"had_liked":false,"id":304061,"user_name":"feature","can_delete":false,"product_type":"c1","uid":2685368,"ip_address":"","ucode":"35179415E52E23","user_header":"https://static001.geekbang.org/account/avatar/00/28/f9/b8/32cf0130.jpg","comment_is_top":false,"comment_ctime":1627215694,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627215694","product_id":100017301,"comment_content":"课后思考：<br>1.使用栈这种数据结构来保存临时变量是由于栈的特性，先入后出，后入先出，正好符合保存变量的特性，其实用其他的数据结构也可以，不过操作起来肯定没有栈方便，比如学过的链表也可以用。<br>2.JVM中的’堆栈’和数据结构中的‘堆栈’不是同一个概念，数据结构中的‘堆栈’是一种抽象的结构，不是真实存在的，而JVM中的‘堆栈’是具体的内存，由系统内存分配管理。","like_count":0},{"had_liked":false,"id":302992,"user_name":"Alex_GT","can_delete":false,"product_type":"c1","uid":1312926,"ip_address":"","ucode":"86ADB50A2736FA","user_header":"https://static001.geekbang.org/account/avatar/00/14/08/9e/ac07b0c8.jpg","comment_is_top":false,"comment_ctime":1626502386,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626502386","product_id":100017301,"comment_content":"08 栈：如何实现浏览器的前进和后退功能<br><br>1 什么是栈<br>这个比较基础，但是仔细看看定义还是有收获的，栈是一种“操作受限”的线性表，正是这种限制体现了栈本身是对一些特定场景的抽象。保证了这些场景下，不暴露过多的操作接口，满足了后进先出、先进后出的特性。<br><br>2 如何实现一个栈<br>用数组实现：顺序栈<br>用链表实现：链式栈<br><br>3 栈在函数调用中的应用<br>函数调用栈<br>表达式求值栈<br>栈在括号匹配中的应用<br><br>4 解答开篇<br>如何实现浏览器的前进、后退？两个栈就能解决问题，前进栈&amp;后退栈<br><br>5 课后思考<br>1）函数执行的过程符合栈的特性，没想出更合适的数据结构；<br>2）是类似的，JVM中的栈类似于函数调用栈，强调数据生命周期与作用域；数据结构中的栈强调数据的组织、存储。","like_count":0},{"had_liked":false,"id":301901,"user_name":"阿甘","can_delete":false,"product_type":"c1","uid":1057843,"ip_address":"","ucode":"BC93175B70E05D","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/33/bcf37f50.jpg","comment_is_top":false,"comment_ctime":1625968182,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1625968182","product_id":100017301,"comment_content":"对于表达式求值，一般来说只才用一个栈就可以解决。首先要将表达式转换为逆波兰序（posfix expression，比如 a + b * c + (d * e + f) * g =&gt; a b c * + d e * f + g * +，然后将逆波兰序表达式逐个压栈操作：遇到数字就直接压栈，遇到运算符就弹出对应数目的数字，进行操作，然后把操作结果入栈，以此循环，最后就可以得到计算结果。不过话说回来，把表达式转换为逆波兰序的过程用的方法也是栈，跟老师上面描述的挺像的，就是用栈存储运算符，如果当前运算符比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符。","like_count":0},{"had_liked":false,"id":301604,"user_name":"Benson_Geek","can_delete":false,"product_type":"c1","uid":1519415,"ip_address":"","ucode":"D95B5C2BA09961","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/dr34H3hOMVsibL0XV1iaBWFiaTnYssX8sNjmJDpiaBUVv2X39nFzDjNpe288cKkZfH3P9sVRxZ1lzYZEcRR3vJNYtA/132","comment_is_top":false,"comment_ctime":1625759941,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625759941","product_id":100017301,"comment_content":"要点摘要：<br>1. 数组实现栈为顺序栈，链表实现为链式栈，分别代码实现，支持新开数组动态扩容方法，其入栈出栈时间复杂度如何分析，都是O(1)，均摊<br>2. 栈在函数调用中，在求解计算表达式(加减乘除)中，在匹配各种成对符号如括号，中括号匹配中的应用<br>3. 双栈法实现浏览器前进后退等的功能，考虑某种情况下需要清空栈<br>4. 课后思考","like_count":0},{"had_liked":false,"id":300633,"user_name":"李远之","can_delete":false,"product_type":"c1","uid":1966569,"ip_address":"","ucode":"5B781FD1C03F10","user_header":"","comment_is_top":false,"comment_ctime":1625279534,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625279534","product_id":100017301,"comment_content":"括号匹配问题<br>&lt;pre&gt;<br>public class StackBrace {<br>    static Map&lt;String, String&gt; configMapping = new HashMap&lt;&gt;();<br><br>    public static void main(String[] args) {<br>        configMapping.put(&quot;}&quot;, &quot;{&quot;);<br>        configMapping.put(&quot;)&quot;, &quot;(&quot;);<br>        configMapping.put(&quot;]&quot;, &quot;[&quot;);<br>        String s = &quot;{[()]{}}[]&quot;;<br>        System.out.println(isValid(s));<br>    }<br><br>    private static boolean isValid(String s){<br>        if (null == s || s.length()&lt;2){<br>            return false;<br>        }<br>        String[] ss = s.split(&quot;&quot;);<br>        Stack&lt;String&gt; tmp = new Stack&lt;&gt;();<br>        for (int i = 0; i&lt;ss.length; i++){<br>            if (ss[i].equals(&quot;{&quot;) || ss[i].equals(&quot;(&quot;) || ss[i].equals(&quot;[&quot;)){<br>                tmp.push(ss[i]);<br>            }else {<br>                String top = tmp.peek();<br>                if (top.equals(configMapping.get(ss[i]))){<br>                    tmp.pop();<br>                }<br>            }<br>        }<br>        return tmp.isEmpty();<br>    }<br>}<br>&lt;&#47;pre&gt;","like_count":0},{"had_liked":false,"id":300628,"user_name":"红尘","can_delete":false,"product_type":"c1","uid":1445504,"ip_address":"","ucode":"CCCD5736755DF5","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/gVfU7icdia3o5ZNaHjaWAdgkSYIpU1rdhIlVYiahYCvRlDZu2K6oPSvVobNjzwZbUaiayQcKjicZ44WjfWJCj5xdlPA/132","comment_is_top":false,"comment_ctime":1625278926,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625278926","product_id":100017301,"comment_content":"一、什么是栈<br>栈是一种特殊的数据结构，栈的特点是先进后出，是一种操作受限的线性表，只允许在一段插入和删除数据。因为是一种特定的数据结构，相对于数组或者链表而言，没有暴露太多的数据操作接口，虽然操作上面不灵活，但是使用的时候不容易出错，数据操作比较可控<br>二、栈的类型<br>1.顺序栈：<br>顺序栈是采用数组实现的栈，入栈和出栈都是操作数组的第一位<br>2.链式栈：<br>链式栈是采用链表实现的栈，入栈和出栈都是操作链表的最后一位数据<br>三、栈的分析<br>因为栈的出栈和入栈都是操作数组或者链表的第一位或者最后一位数据，所以时间复杂度是O（1），因为数组的大小是固定的，所以入栈的时候分为两种情况，如果数组有空余空间，那么直接入栈，时间复杂度为O（1），如果数组内存空间不足，就要进行扩容，假设开始的数组长度为k，那么进行扩容的数组长度为2k，扩容之后，要将开始的数组k拷贝到新的数组，那么这次入栈的时间复杂度为2K-K-1=k-1,所以采用均摊复杂度计算，因为只有扩容的时候入栈复杂度才为O(N)，平时都是O（1），所以均摊下来，入栈的时间复杂度为O（1）。<br>四、栈在函数中的操作使用，<br>1.每个函数执行都会分配一个内存空间，称为栈，用来存储函数中的临时变量<br>2.假设a函数调用b函数，进入b函数后，将一些临时变量作为一个栈帧入栈，当函数执行之后，将这个函数对应的所有栈帧出站，此时b函数的栈帧都在上面是后进来的，但是会先出去，b函数栈帧都清楚回到a函数，这也正好符合了栈的先进后出的数据结构<br>五、浏览器中栈的操作<br>浏览器中常见的前进和后退可以用栈实现，用两个栈x y， 当浏览器打开之后，每浏览一个网页就将网页地址入栈x，当进行浏览器后退时，再依次出栈，将出栈的数据入栈y，当进行前进的时候，获取的网页与y相同，则y栈里面的数据出站，然后入栈x，如果不同，将y栈里面的数据情况，新的网页地址入栈x<br>六、为什么用栈保存临时变量，其他数据结构不行吗？<br>临时变量可以用很多数据结构实现，只是临时变量的这个类型符合先进后出的概念，所以就顺理成章的采用了栈。","like_count":0},{"had_liked":false,"id":296151,"user_name":"海崖","can_delete":false,"product_type":"c1","uid":2552745,"ip_address":"","ucode":"9D42E0B0D30A56","user_header":"https://static001.geekbang.org/account/avatar/00/26/f3/a9/bb9d8450.jpg","comment_is_top":false,"comment_ctime":1622778327,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622778327","product_id":100017301,"comment_content":"叮~打卡","like_count":0},{"had_liked":false,"id":295958,"user_name":"下雨天","can_delete":false,"product_type":"c1","uid":1413399,"ip_address":"","ucode":"FB3851E3A79C3B","user_header":"https://static001.geekbang.org/account/avatar/00/15/91/17/89c3d249.jpg","comment_is_top":false,"comment_ctime":1622683641,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622683641","product_id":100017301,"comment_content":"第一个问题：用其他非栈的数据结构来保存数据也可以，这里用栈的原因是，这个使用场合刚好符合栈的存储结构特性。就好像条条大路通罗马，为啥不选择性省时省力的一条。而且栈这个数据结构发明出来，也正好是对一些场景的抽象符合该数据结构的使用。用起来根据的方便，合理。","like_count":0},{"had_liked":false,"id":292163,"user_name":"lyh","can_delete":false,"product_type":"c1","uid":1520381,"ip_address":"","ucode":"EF7C85CD278A94","user_header":"","comment_is_top":false,"comment_ctime":1620709706,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620709706","product_id":100017301,"comment_content":"数组栈入栈出栈都放在数组末尾，因此入栈出栈时间复杂度都是o1，链表栈是不是因为入栈出栈都放在链表头，因此入栈出栈时，不需要做查询，因此时间复杂度也是o1，不知道我理解的对不对，望老师赐教","like_count":0},{"had_liked":false,"id":290939,"user_name":"双木公子","can_delete":false,"product_type":"c1","uid":1116567,"ip_address":"","ucode":"751885864D3AB7","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/97/4314e2d8.jpg","comment_is_top":false,"comment_ctime":1619867430,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619867430","product_id":100017301,"comment_content":"1.不一定非要使用栈结构来保存函数中的临时变量，只不过如果这个函数的调用符合栈操作特性（后进先出）的话，使用栈就很符合要求。<br>2. 内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。<br>        内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区。<br>代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。<br>静态数据区：存储全局变量、静态变量、常量，常量包括final修饰的常量和String常量。系统自动分配和回收。<br>栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。<br>堆区：new一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。","like_count":0},{"had_liked":false,"id":290061,"user_name":"OOO","can_delete":false,"product_type":"c1","uid":1341031,"ip_address":"","ucode":"60BBF2C3CA7AEE","user_header":"","comment_is_top":false,"comment_ctime":1619342747,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619342747","product_id":100017301,"comment_content":"如何实现浏览器的前进和后退功能？<br>我感觉用双向链表实现更直观一些。a-b-c很直观。当由b由访问d的时候，b的next=d即可。","like_count":0},{"had_liked":false,"id":288598,"user_name":"jc9090kkk","can_delete":false,"product_type":"c1","uid":1338831,"ip_address":"","ucode":"6C992D07A2E78F","user_header":"https://static001.geekbang.org/account/avatar/00/14/6d/cf/ec335526.jpg","comment_is_top":false,"comment_ctime":1618556023,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618556023","product_id":100017301,"comment_content":"今天学习并解决了leetcode第二天的题，判断是否是回文数，继续坚持打卡学习","like_count":0},{"had_liked":false,"id":287841,"user_name":"张知信","can_delete":false,"product_type":"c1","uid":2144474,"ip_address":"","ucode":"7C896BB3214B3D","user_header":"https://static001.geekbang.org/account/avatar/00/20/b8/da/42284f64.jpg","comment_is_top":false,"comment_ctime":1618192797,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618192797","product_id":100017301,"comment_content":"如何理解栈？一种后进先出的数据结构，操作受限的线性表，只允许入栈（pop）和出栈（push）操作。<br>如何实现一个栈？使用数组或者链表可以实现栈。<br>时间和空间复杂度？时间：入栈、出栈都是O(1)，支持动态扩容的顺序栈（数组实现）均摊时间复杂度为O(1)；空间：O(n)。<br>栈有哪些应用？函数调用；表达式求值；括号匹配；浏览器请进和后退。<br>函数调用中为什么使用栈来保存临时变量？用其他数据结构也可以，但是函数调用满足先入先出的特点，用栈是天然的。<br>JVM的栈和数据结构的栈是不是一回事？不是，JVM的栈是一块内存区域用来存储JVM的函数的调用栈，这个调用栈就是一种栈数据结构。","like_count":0},{"had_liked":false,"id":286718,"user_name":"大方方","can_delete":false,"product_type":"c1","uid":1354013,"ip_address":"","ucode":"621AD8F1485753","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6cyOoRd2dROgiblAJkW6RLhUyH1wwU0NNibIIuV930eQ9TiaNT41K61kBSVkvYoDYg7mJtuEoCQY1awBmV0WW6BFg/132","comment_is_top":false,"comment_ctime":1617524748,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617524748","product_id":100017301,"comment_content":"我觉得函数使用栈来保存临时变量  可以刚好和函数的作用域特性对应上。","like_count":0},{"had_liked":false,"id":284520,"user_name":"William Ning","can_delete":false,"product_type":"c1","uid":1592279,"ip_address":"","ucode":"4DB8D05E69E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","comment_is_top":false,"comment_ctime":1616314616,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1616314616","product_id":100017301,"comment_content":"顺序栈, 链式栈实现, 以及栈的应用, 含表达式求值<br>实现语言： PHP<br>code: https:&#47;&#47;gitee.com&#47;william_ning&#47;beauty_of_data_structures_and_algorithms&#47;tree&#47;master&#47;基础篇-38讲&#47;08-栈-如何实现浏览器的前进和后退功能<br>表达式求值： https:&#47;&#47;gitee.com&#47;william_ning&#47;beauty_of_data_structures_and_algorithms&#47;tree&#47;master&#47;基础篇-38讲&#47;08-栈-如何实现浏览器的前进和后退功能&#47;栈在函数调用中的应用&#47;表达式求值&#47;ExpressionEvaluation.php","like_count":0},{"had_liked":false,"id":283830,"user_name":"这就是生活","can_delete":false,"product_type":"c1","uid":2378295,"ip_address":"","ucode":"847EE53DA017C8","user_header":"https://static001.geekbang.org/account/avatar/00/24/4a/37/fb06fb79.jpg","comment_is_top":false,"comment_ctime":1615949430,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615949430","product_id":100017301,"comment_content":"1.不一定非得用栈结构，只不过栈更符合函数调用时先进后出的模式，临时变量的作用域问题，在函数调用时候，上层函数的临时变量可以在下层函数中使用。<br>2.这里讲的栈是一种软件上的数据结构，JVM中的栈，是上真实存在的一段内存，是采用了栈这种数据结构的，可以说是一种栈的实现。<br>JVM栈中的每个栈帧对应着一个方法，其中包括着   函数变量表、操作数栈、指向运行时常量池的引用、方法返回地址、其他信息。","like_count":0},{"had_liked":false,"id":283664,"user_name":"ICE FROG","can_delete":false,"product_type":"c1","uid":1812082,"ip_address":"","ucode":"31E3DBD22CCC3E","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a6/72/526fd3df.jpg","comment_is_top":false,"comment_ctime":1615875863,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615875863","product_id":100017301,"comment_content":"“这个时候，你通过页面 b 又跳转到新的页面 d 了，页面 c 就无法再通过前进、后退按钮重复查看了，所以需要清空栈 Y”<br>请问如何判断我当前是从b跳转到了新的页面d呢？ 是不是需要遍历一次x和y栈是否存在这个d因此判断是否新页面？ 但貌似栈无法做遍历操作吧？还是说这是一个伪需求，实际上只是用来描述核心概念？","like_count":0},{"had_liked":false,"id":283330,"user_name":"Reset","can_delete":false,"product_type":"c1","uid":2506950,"ip_address":"","ucode":"ADE8E883E851CE","user_header":"https://static001.geekbang.org/account/avatar/00/26/40/c6/2c2e507b.jpg","comment_is_top":false,"comment_ctime":1615708055,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615708055","product_id":100017301,"comment_content":"对于第二个课后思考，我也认为是不一样的，但是许多同学都拿内存中的堆栈（个人感觉是C的内存区域）来说明不同，而我缺恰恰认为C语言内存区域的堆栈和讲的数据结构栈是一回事，只是它们存的数据不一样而已，像C中堆栈存放的是形参，局部变量，返回地址等，可以把它们整体当作一种数据类型，那么跟数据结构的栈是没啥区别。<br><br>而JVM的栈确实跟讨论的栈不太一样，JVM的栈包括局部变量表，操作数栈，返回地址等内容，比C中的堆栈复杂得多，之所以成为栈，主要为了说栈是线程独有，就像多线程一样，每个线程都有自己的栈，不像堆，是所有线程共享的区域。","like_count":0},{"had_liked":false,"id":283285,"user_name":"阿衡","can_delete":false,"product_type":"c1","uid":1107347,"ip_address":"","ucode":"074EB56AAB3B4A","user_header":"https://static001.geekbang.org/account/avatar/00/10/e5/93/2e51d44a.jpg","comment_is_top":false,"comment_ctime":1615689993,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615689993","product_id":100017301,"comment_content":"看了一遍，对栈有什么用有了深一点的理解，以前对栈有什么用总是很疑惑。","like_count":0},{"had_liked":false,"id":281685,"user_name":"不将就","can_delete":false,"product_type":"c1","uid":1530503,"ip_address":"","ucode":"1C38FD29894964","user_header":"https://static001.geekbang.org/account/avatar/00/17/5a/87/a911fda7.jpg","comment_is_top":false,"comment_ctime":1614847627,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614847627","product_id":100017301,"comment_content":"栈在表达式求值中的应用这一块图，我想问下老师，计算完乘法直接计算加法后入栈吗，就是5*8+3这是分为两步还是直接就是一步做完，还是说你那里省了一步没画呢，谢谢解答","like_count":0},{"had_liked":false,"id":281669,"user_name":"sarlmoclen","can_delete":false,"product_type":"c1","uid":1004485,"ip_address":"","ucode":"273ED20C5D4FC6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLo4KAus0NuZwTURlhCGCxiaY82j9nrvsQoZxia0mb6zQUico2cMM0N70OSic646ialSq8UVhWPiaOUhDPw/132","comment_is_top":false,"comment_ctime":1614844752,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614844752","product_id":100017301,"comment_content":"个人理解，不对请指出：<br>JVM中的栈也就是java虚拟机栈，属于Java运行时数据区域中的一部分，线程私有，当程序运行时，每个函数在执行时就会创建一个栈帧（Stack Frame，函数运行时的基础数据结构，用于存储局部变量表、操作数栈、动态链接、方法出口等信息），并将当前函数进行入栈操作，也就是插入到当前线程的java虚拟机栈中，举例：如果我们程序从main函数开始执行，那main就是java虚拟机栈中的第一个元素，如果main函数中有调用新的函数，假设为a函数，则执行到a函数时对其入栈，此时java虚拟机栈中就有两个元素，其中栈顶元素就是a函数，当a函数执行完毕，则a函数出栈，java虚拟机栈此时就剩下main函数。总结起来就是：每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。<br>所以JVM的栈是一个标准的栈结构，上面介绍栈帧（Stack Frame）的时候可以看到里面还有一个操作数栈，这个也是一个标准的栈结构，其工作原理是：我们知道在java的class文件中，从code属性可以拿到函数的执行编码，每一行执行编码由操作码（JVM指令集中的指令）和操作数构成，不同指令可以控制操作数进行运算时进栈或者出栈，以此完成运算，如果说java虚拟机栈帮助执行引擎完成函数的调用，那操作数栈就是帮助执行引擎完成函数内部的运算。","like_count":0},{"had_liked":false,"id":280485,"user_name":"罗耀龙@坐忘","can_delete":false,"product_type":"c1","uid":1917663,"ip_address":"","ucode":"3CEA258DE7F3C7","user_header":"https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg","comment_is_top":false,"comment_ctime":1614232255,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1614232255","product_id":100017301,"comment_content":"茶艺师学编程<br><br>要刷新的知识<br><br>原来栈也是可以用链表实现，叫链式表","like_count":0},{"had_liked":false,"id":279781,"user_name":"八九","can_delete":false,"product_type":"c1","uid":1191617,"ip_address":"","ucode":"B996A884BFA474","user_header":"https://static001.geekbang.org/account/avatar/00/12/2e/c1/0fcd29ab.jpg","comment_is_top":false,"comment_ctime":1613961891,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613961891","product_id":100017301,"comment_content":"java-链表实现栈：<br>public class LinkedStack {<br>    static class ListNode {<br>        ListNode next;<br>        int val;<br><br>        public ListNode(int val) {<br>            this.val = val;<br>        }<br>    }<br><br>    static ListNode head = null;<br>    static int removeIndex = 0;<br><br>    public static void main(String[] args) {<br>        for (int i = 0; i &lt; 10; i++) {<br>            System.out.println(&quot;push:&quot; + i);<br>            push(head, i);<br>        }<br>        pop(head);<br>        pop(head);<br>        pop(head);<br>        pop(head);<br>        print(head);<br>    }<br><br>    public static void push(ListNode node, int val) {<br>        ListNode newNode = new ListNode(val);<br>        if (node == null) {<br>            node = newNode;<br>        } else if (node.next == null) {<br>            removeIndex++;<br>            node.next = newNode;<br>        } else {<br>            push(node.next, val);<br>        }<br>        head = node;<br>    }<br><br>    &#47;&#47;把前一个节点的next设置为NULL<br>    public static void pop(ListNode head) {<br>        for (int i = 1; i &lt; removeIndex; i++) {<br>            head = head.next;<br>        }<br>        head.next = null;<br>        removeIndex--;<br>    }<br><br>    public static void print(ListNode node) {<br>        System.out.print(&quot;--&gt;&quot; + node.val);<br>        if (node.next != null) {<br>            print(node.next);<br>        }<br>    }<br>}<br>","like_count":0},{"had_liked":false,"id":279780,"user_name":"八九","can_delete":false,"product_type":"c1","uid":1191617,"ip_address":"","ucode":"B996A884BFA474","user_header":"https://static001.geekbang.org/account/avatar/00/12/2e/c1/0fcd29ab.jpg","comment_is_top":false,"comment_ctime":1613961861,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613961861","product_id":100017301,"comment_content":"java-数组实现栈<br>public class ArrayStack {<br>    static int size = 5;<br>    static String[] arr = new String[size];<br>    static int count = 0;<br><br>    public static void main(String[] args) {<br>        for (int i = 0; i &lt; 10; i++) {<br>            push(i + &quot;&quot;);<br>        }<br>        pop();<br>        pop();<br>        pop();<br>        pop();<br>        System.out.println(Arrays.toString(arr));<br>    }<br><br>    static void push(String value) {<br>        if (count == size) {<br>            &#47;&#47;扩容+复制，arr=新数组<br>            String[] newArr = new String[size * 2];<br>            System.arraycopy(arr, 0, newArr, 0, size);<br>            arr = newArr;<br>            size *= 2;<br>        }<br>        arr[count] = value;<br>        count++;<br><br>    }<br><br>    static void pop() {<br>        if (count &gt; 0) {<br>            arr[count - 1] = null;<br>            count--;<br>        } else {<br>            System.out.println(&quot;数组元素为空!&quot; );<br>        }<br>    }<br>}<br>","like_count":0},{"had_liked":false,"id":279506,"user_name":"八九","can_delete":false,"product_type":"c1","uid":1191617,"ip_address":"","ucode":"B996A884BFA474","user_header":"https://static001.geekbang.org/account/avatar/00/12/2e/c1/0fcd29ab.jpg","comment_is_top":false,"comment_ctime":1613809383,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613809383","product_id":100017301,"comment_content":"总结：<br>1.了解栈<br>1)栈是一种操作受限的数据结构，只支持入栈和出栈操作。后进先出是它最大的特点。<br>2)从功能上来说，数组或链表确实可以替代栈，特定的数据结构是对特定场景的抽象，当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，这时我们就应该首选“栈”这种数据结构。<br>3)栈主要包含两个操作，入栈和出栈，也就是在栈顶插入一个数据和从栈顶删除一个数据。<br><br>2.栈实现<br>1)既可以用数组来实现，也可以用链表来实现。<br>顺序栈：用数组实现的栈<br>链式栈：用链表实现的栈<br>空间复杂度：不管是顺序栈还是链式栈，我们存储数据只需要一个大小为 n 的数组就够了。在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度是 O(1)。<br>时间复杂度：不管是顺序栈还是链式栈，入栈、出栈只涉及栈顶个别数据的操作，所以时间复杂度都是 O(1)。<br>【空间复杂度】是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。<br><br>2).支持动态扩容的顺序栈（开发中不常用到）<br>基于数组实现，只需要支持动态扩容的数组，当栈满了之后，就申请一个更大的数组，将原来的数据搬移到新数组中。<br>a.出栈操作：不会涉及内存的重新申请和数据的搬移，所以出栈的时间复杂度是 O(1)。<br>b.入栈操作：时间复杂度：当栈中有空闲空间时，入栈操作的时间复杂度为 O(1)。当空间不够时，需要重新申请内存和数据搬移，所以时间复杂度就变成了 O(n)。<br>【均摊时间复杂度】一般都等于最好情况时间复杂度。因为在大部分情况下，入栈操作的时间复杂度 O 都是 O(1)，只有在个别时刻才会退化为 O(n)，所以把耗时多的入栈操作的时间均摊到其他入栈操作上，平均情况下的耗时就接近 O(1)。<br><br>4.栈在函数调用中的应用<br>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。<br>每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。<br><br>5.栈在表达式求值中的应用<br>如：34+13*9+44-12&#47;3<br>编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。<br>从左向右遍历表达式，当遇到数字,就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。<br>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；<br>如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。<br><br>6.栈在括号匹配中的应用<br>比如，{[] ()[{}]}或[{()}([])]等都为合法格式，而{[}()]或[({)]为不合法的格式。如何检查它是否合法呢？<br>用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。<br>如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。<br>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。<br><br>7.浏览器的前进、后退功能实现<br>使用两个栈，X 和 Y，把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。<br>当点击前进按钮时，依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了。<br>注意：当跳转到新页面，而不是前进后退操作时，就无法再通过前进、后退按钮重复查看了，所以需要清空栈 Y。<br><br>8.为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？<br>其实，我们不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。<br>从调用函数进入被调用函数，对于数据来说，变化的是什么呢？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。<br>而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。<br><br>9.JVM 里面的“栈”跟我们这里说的“栈”是不是一回事呢？如果不是，那它为什么又叫作“栈”呢？<br>数据结构分堆结构，栈结构。内存区也分堆内存，栈内存。它们除了名字一样没有什么必然联系。就跟苹果一样，一个是水果一个是品牌。前者是组织数据的一种手段（或者叫工具），后者只是指明数据存储在哪种内存区之上。<br><br>感谢老师及各位小伙伴！","like_count":0},{"had_liked":false,"id":274460,"user_name":"Geek_9f19a7","can_delete":false,"product_type":"c1","uid":2416140,"ip_address":"","ucode":"9BAB37B2BC5B1F","user_header":"","comment_is_top":false,"comment_ctime":1611027741,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611027741","product_id":100017301,"comment_content":"为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？<br>函数调用符合栈的特性可以类比括号匹配，嵌套函数的每个方法体就可以看作一对花括号{}","like_count":0},{"had_liked":false,"id":273211,"user_name":"xxx","can_delete":false,"product_type":"c1","uid":1356978,"ip_address":"","ucode":"E78B1F15BC10F7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIcLjatV3GHdibZXCTIgL1X2A7jpByIeLH3Zyia8KXdT4JRcicmVSgq5ekRHCFCFenMqicsAwaWYibHkTw/132","comment_is_top":false,"comment_ctime":1610499668,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610499668","product_id":100017301,"comment_content":"栈这种数据结构理解起来是简单的，它的重点在于使用，尤其是老师提到的栈在表达式求值中的应用，太妙了。所以能够知道在什么问题场景下使用栈是很重要的。","like_count":0},{"had_liked":false,"id":272186,"user_name":"unisense","can_delete":false,"product_type":"c1","uid":2395274,"ip_address":"","ucode":"109E414CA26433","user_header":"https://static001.geekbang.org/account/avatar/00/24/8c/8a/91b3d0b8.jpg","comment_is_top":false,"comment_ctime":1609984552,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609984552","product_id":100017301,"comment_content":"这个时候，你通过页面 b 又跳转到新的页面 d 了，页面 c 就无法再通过前进、后退按钮重复查看了：  疑问是，c仍然在Y中，为什么不能查看了？","like_count":0},{"had_liked":false,"id":270094,"user_name":"Geek_b26880","can_delete":false,"product_type":"c1","uid":2316456,"ip_address":"","ucode":"9156671B08C8C9","user_header":"","comment_is_top":false,"comment_ctime":1608900797,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608900797","product_id":100017301,"comment_content":"老师，我有个疑问，在那个加减乘法的例子里面处理完乘法之后不应该直接处理加法吧，应该还是需要等待下一次运算符压站吧，第一次压站的加法应该是最后出站的吧","like_count":0},{"had_liked":false,"id":268752,"user_name":"bowen","can_delete":false,"product_type":"c1","uid":1073569,"ip_address":"","ucode":"B0979D12090C7D","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/a1/f2ddc098.jpg","comment_is_top":false,"comment_ctime":1608339765,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608339765","product_id":100017301,"comment_content":"栈是类似堆盘子的先进后出的数据结构，操作受限，用数组或链表都可以实现，称为线性栈和链式栈，栈的应用包括存储函数的临时变量，括号匹配，表达式运算<br>内存分为代码区，静态存储区和动态存储区，静态存储区存储全局变量和静态变量，常量，由程序默认初始化，动态存储区分为栈区和堆区，栈区存放函数的临时变量，堆区用于new开辟新地址","like_count":0},{"had_liked":false,"id":267136,"user_name":"慕高迪","can_delete":false,"product_type":"c1","uid":1448126,"ip_address":"","ucode":"EB1CB5EA4E3A90","user_header":"https://static001.geekbang.org/account/avatar/00/16/18/be/ad3127e0.jpg","comment_is_top":false,"comment_ctime":1607606400,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607606400","product_id":100017301,"comment_content":"总结：<br><br>栈作为一种数据结构，对它的操作比较受限，为了满足其后进先出的特性，只能对它进行入栈或出栈操作。入栈可以理解为插入元素，出栈可以理解为删除元素。<br><br>可以使用数组或链表来实现它，不管是用数组还是用链表实现，都只能对其一端进行操作。当用数组来实现栈时叫顺序栈；当用链表来实现栈时叫链式栈。<br><br>可以看到，我们只能对栈进行出栈或者是入栈操作。所以它的时间复杂度为O(1)。即使是使用数组来实现并需要扩容的情况下，和数组一样，均摊的时间复杂度也为O(1)。<br> <br>栈典型的应用场景：<br>1. 函数调用栈<br>2. 表达式求值<br>3. 判断括号是否成对出现","like_count":0},{"had_liked":false,"id":266963,"user_name":"慕高迪","can_delete":false,"product_type":"c1","uid":1448126,"ip_address":"","ucode":"EB1CB5EA4E3A90","user_header":"https://static001.geekbang.org/account/avatar/00/16/18/be/ad3127e0.jpg","comment_is_top":false,"comment_ctime":1607557970,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607557970","product_id":100017301,"comment_content":"思考题：<br>1. 我认为函数调用执行跟表达式运算一样，都需要后进先出，所以使用栈是比较方便的。<br>2.两个栈说的不是一个东西，栈需要满足后进先出的特性。而JVM上的栈并不需要满足这个特性，所以不是一个&quot;栈&quot;","like_count":0},{"had_liked":false,"id":264470,"user_name":"Eleven","can_delete":false,"product_type":"c1","uid":1168452,"ip_address":"","ucode":"FB4A0C8CA732BE","user_header":"https://static001.geekbang.org/account/avatar/00/11/d4/44/0ec958f4.jpg","comment_is_top":false,"comment_ctime":1606472408,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606472408","product_id":100017301,"comment_content":"使用栈来保存临时变量使用了栈这种数据结构先进后出的特性，因为函数的调用是下面这种方式funcA-&gt;funcB，那么funcB中的临时变量是要先使用的。<br>使用其它的数据结构也可以，比如双向链表这类可以支持双端操作的也行。","like_count":0},{"had_liked":false,"id":263627,"user_name":"尼丘士多","can_delete":false,"product_type":"c1","uid":1652071,"ip_address":"","ucode":"234FAD63EB7E49","user_header":"https://static001.geekbang.org/account/avatar/00/19/35/67/725354db.jpg","comment_is_top":false,"comment_ctime":1606201445,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606201445","product_id":100017301,"comment_content":"使用链表的方式实现链式栈(JavaScript)：<br>class Node {<br>  constructor(value) {<br>    this.value = value;<br>    this.next = null;<br>  }<br>}<br><br>class Stack {<br>  constructor(maxLength) {<br>    this._length = 0;<br>    this._head = null;<br>    this._maxLength = maxLength;<br>  }<br><br>  push(item) {<br>    if (this._length &gt;= this._maxLength) {<br>      console.warn(&quot;stack overflow maxlength&quot;);<br>    }<br>    const node = new Node(item);<br>    const tempHead = this._head;<br>    node.next = tempHead;<br>    this._head = node;<br>    this._length++;<br>  }<br><br>  pop() {<br>    this._head = this._head.next;<br>    this._length--;<br>  }<br>}<br>","like_count":0},{"had_liked":false,"id":261709,"user_name":"geekymv","can_delete":false,"product_type":"c1","uid":1075950,"ip_address":"","ucode":"B119ACE47B8C0C","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJTywPCdTDoRAaLBN20JfD50dQPic0B3OeUgYMHA3x7ptvF3iaCRTqrNZsF3Cz8TCibcwSsCichdOiallQ/0","comment_is_top":false,"comment_ctime":1605500640,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605500640","product_id":100017301,"comment_content":"表达式求值代码实现 https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;FRSOzIh81tMqeZiKacWZ0Q","like_count":0},{"had_liked":false,"id":261016,"user_name":"任鑫","can_delete":false,"product_type":"c1","uid":1142025,"ip_address":"","ucode":"9803EB15B634C3","user_header":"https://static001.geekbang.org/account/avatar/00/11/6d/09/ffeabc27.jpg","comment_is_top":false,"comment_ctime":1605173425,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605173425","product_id":100017301,"comment_content":"“栈”是一种功能性描述，链表和数组、树、图这些可以看作具体实现，利用数组或链表这种具体实现可以完成“栈”的功能。","like_count":0},{"had_liked":false,"id":259546,"user_name":"Z7k","can_delete":false,"product_type":"c1","uid":1238680,"ip_address":"","ucode":"39373D7A6E6EE1","user_header":"https://static001.geekbang.org/account/avatar/00/12/e6/98/5853eb73.jpg","comment_is_top":false,"comment_ctime":1604752010,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604752010","product_id":100017301,"comment_content":"用栈来保存临时变量是符合临时变量的身份，随用随仍，后进先出正好符合栈的特性。用其他数据结构也是可以的。<br><br>jvm:内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区。<br>代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。<br>静态数据区：存储全局变量、静态变量、常量，常量包括final修饰的常量和String常量。系统自动分配和回收。<br>栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。<br>例如 int method(int a){int b;}栈中存储参数a、局部变量b、返回值temp。<br>堆区：new一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。由程序员分配和回收（Java中由JVM虚拟机的垃圾回收机制自动回收）。<br>例如 Class Student{int num; int age;} main方法中Student stu = new Student()；分配堆区空间中存储的该对象的num、age，变量stu存储在栈中，里面的值是对应堆区空间的引用或地址。<br>所以目测是不是一回事，jvm里面的栈更牛逼一些，涉及到了内存管理，但用到了数据结构里面栈的逻辑。<br>","like_count":0},{"had_liked":false,"id":258758,"user_name":"青帝","can_delete":false,"product_type":"c1","uid":1127950,"ip_address":"","ucode":"3BAC8C94494068","user_header":"https://static001.geekbang.org/account/avatar/00/11/36/0e/41a72485.jpg","comment_is_top":false,"comment_ctime":1604550800,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604550800","product_id":100017301,"comment_content":"浏览器那个栈的问题，如果用户这时候点了一个新页面，是不是栈Y要做一个清空操作","like_count":0},{"had_liked":false,"id":258619,"user_name":"Geek_4f01df","can_delete":false,"product_type":"c1","uid":2041846,"ip_address":"","ucode":"08FA581E0E61AA","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLhFziajktz4ZYqEAKXiauOl5BCstZhaMGFQFUxfNYlIicLTncKQmCTFia8GvTvib3EXsSJcPONT4D6VLQ/132","comment_is_top":false,"comment_ctime":1604505446,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604505446","product_id":100017301,"comment_content":"数据结构中的栈是一种有先进后出，后进先出特点的数据类型。而jvm中的栈指的是一块存储空间，这块存储空间拥有先进后出，后进先出的特点，所以也称作栈。","like_count":0},{"had_liked":false,"id":257044,"user_name":"Geek从不换行","can_delete":false,"product_type":"c1","uid":2228151,"ip_address":"","ucode":"FD791D375C5CEE","user_header":"","comment_is_top":false,"comment_ctime":1603843774,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603843774","product_id":100017301,"comment_content":"栈的动态扩容那里说的是如果栈容量不够则扩容为原来的两倍，然后将扩容时候产生的时间复杂度O(k)均摊到后面的k-1次simple push 中，这里是全部均摊的，如果扩容的是1.5倍，那扩容产生的时间复杂度还是O(k)，后面剩下的就是0.5k次的simple push，是不是就不够前面扩容时间复杂度O(k)的均摊了？？","like_count":0},{"had_liked":false,"id":253950,"user_name":"李金鹏","can_delete":false,"product_type":"c1","uid":1445362,"ip_address":"","ucode":"8FCCA5B8BD8DDD","user_header":"https://static001.geekbang.org/account/avatar/00/16/0d/f2/3865fe28.jpg","comment_is_top":false,"comment_ctime":1602988057,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602988057","product_id":100017301,"comment_content":"老师您好，您写的用数组实现栈的pop方法好像有点问题：这是您的源码：<br>&#47;&#47; 出栈操作 public String pop() { &#47;&#47; 栈为空，则直接返回null if (count == 0) return null; &#47;&#47; 返回下标为count-1的数组元素，并且栈中元素个数count减一 String tmp = items[count-1]; --count; return tmp; }<br>当元素出栈后，元素当前的位置的值应该设置为null吧？即在String tmp = items[count-1];后添加一行代码array[count-1] = null; ，您觉得呢？","like_count":0},{"had_liked":false,"id":253137,"user_name":"业子","can_delete":false,"product_type":"c1","uid":1067607,"ip_address":"","ucode":"890AD9427F6D57","user_header":"https://static001.geekbang.org/account/avatar/00/10/4a/57/10125fc7.jpg","comment_is_top":false,"comment_ctime":1602630354,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602630354","product_id":100017301,"comment_content":"栈是一个比较特殊的数据结构，线性结构，只能单侧操作数据，先进先出。实际应用场景有函数调用栈，表达式求值，括号匹配，浏览器前进回退等。","like_count":0},{"had_liked":false,"id":252193,"user_name":"gaooakenshield","can_delete":false,"product_type":"c1","uid":2153598,"ip_address":"","ucode":"D5F3E2A12DE6D1","user_header":"https://static001.geekbang.org/account/avatar/00/20/dc/7e/4315166d.jpg","comment_is_top":false,"comment_ctime":1602169199,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1602169199","product_id":100017301,"comment_content":"王争老师，我感觉函数调用栈那里讲的不是很多，有点点到为止，是因为太难了不太合适在这科普吗，我去一些博客下面了解了一下，但是涉及到一些计算机系统的知识又有点看不懂（比如寄存器部分），想把栈彻底弄懂是不是需要掌握很多东西呢，希望老师指点一下","like_count":0},{"had_liked":false,"id":252028,"user_name":"大力","can_delete":false,"product_type":"c1","uid":1364353,"ip_address":"","ucode":"1B2125C519443D","user_header":"https://static001.geekbang.org/account/avatar/00/14/d1/81/89ba9d81.jpg","comment_is_top":false,"comment_ctime":1602066759,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602066759","product_id":100017301,"comment_content":"因为函数调用的变量需要后进先出与先进后出，用栈最适合。<br>JVM 中的栈应用了“栈”的数据解构，是“栈”的一个具体实现。","like_count":0},{"had_liked":false,"id":251311,"user_name":"张雨","can_delete":false,"product_type":"c1","uid":1948220,"ip_address":"","ucode":"7E21CE276E6BFC","user_header":"","comment_is_top":false,"comment_ctime":1601458191,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601458191","product_id":100017301,"comment_content":"作者您好，我有个问题没搞明白。在栈括号匹配中的应用一小节中，按照你的讲解，感觉只要符号是成对出现的就会被判定为合法","like_count":0},{"had_liked":false,"id":251128,"user_name":"dxy_123456","can_delete":false,"product_type":"c1","uid":2066010,"ip_address":"","ucode":"06ED952A3CEFCE","user_header":"https://static001.geekbang.org/account/avatar/00/1f/86/5a/c7a1d177.jpg","comment_is_top":false,"comment_ctime":1601371262,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601371262","product_id":100017301,"comment_content":"粉笔网的上机编程题就是那道括号匹配的。","like_count":0},{"had_liked":false,"id":250536,"user_name":"衬衫的价格是19美元","can_delete":false,"product_type":"c1","uid":1397631,"ip_address":"","ucode":"655F925451F772","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKVUskibDnhMt5MCIJ8227HWkeg2wEEyewps8GuWhWaY5fy7Ya56bu2ktMlxdla3K29Wqia9efCkWaQ/132","comment_is_top":false,"comment_ctime":1601120009,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601120009","product_id":100017301,"comment_content":"打开页面d的时候为啥要清空Y栈，是为了保证页面的有序性吗","like_count":0},{"had_liked":false,"id":249659,"user_name":"May","can_delete":false,"product_type":"c1","uid":2013929,"ip_address":"","ucode":"04D230EAE83760","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLfafQ69EVEeWaLriaVahNMJJGFHfsbibRuNic2ZuPy3Tm5ialycjea8sfPJRX0dib5nzqPybtlKRfUNsA/132","comment_is_top":false,"comment_ctime":1600746074,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600746074","product_id":100017301,"comment_content":"小白请教老师，如果浏览器历史记录已满，在压入新地址时，浏览器是怎么处理历史记录的呢？是记录不了了，还是是换出最旧的记录，如果是替换出最旧的记录，是怎么做的呢，一个个出栈再入栈吗？","like_count":0},{"had_liked":false,"id":249458,"user_name":"凌风","can_delete":false,"product_type":"c1","uid":2189412,"ip_address":"","ucode":"7069D4BD8C8DCB","user_header":"https://static001.geekbang.org/account/avatar/00/21/68/64/7f6f0dfd.jpg","comment_is_top":false,"comment_ctime":1600663723,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600663723","product_id":100017301,"comment_content":"其实，我们不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。<br>从调用函数进入被调用函数，对于数据来说，变化的是什么呢？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。","like_count":0},{"had_liked":false,"id":249230,"user_name":"逆风一战九","can_delete":false,"product_type":"c1","uid":2143900,"ip_address":"","ucode":"83127627F6F37C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI45zO9GOMquhD0ia1wTBSwtJ1juPcpFTSrOGicGW3jf6JclaudauHicN8OpADArQKL8zPtDicEx4aicgA/132","comment_is_top":false,"comment_ctime":1600513959,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600513959","product_id":100017301,"comment_content":"栈，先进后出，后进先出，基于数组或者链表实现，支持扩容的栈就是改变底层数据结构是否支持扩容，<br>应用，函数调用栈<br>            表达式求值<br>            括号合法性的匹配<br>            浏览器的前进和后退的实现，基于两个栈实现，<br>           <br>            ","like_count":0},{"had_liked":false,"id":247532,"user_name":"WilliamVector","can_delete":false,"product_type":"c1","uid":1898112,"ip_address":"","ucode":"E0D3C3D4FCB7C9","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f6/80/85ec2c2a.jpg","comment_is_top":false,"comment_ctime":1599733595,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599733595","product_id":100017301,"comment_content":"【要点】<br>1、如何理解“栈”？<br>栈是一种“操作受限”的线性表，只允许在一端插入和删除数据，具有先进后出，后进先出的特性。当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。<br>2、如何实现一个“栈”？<br>栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。我们说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。<br>3、支持动态扩容的顺序栈。<br>当栈满了之后，我们就重新申请一块更大的内存，将原来数组中数据统统拷贝过去。这样就实现了一个支持动态扩容的数组。均摊时间复杂度一般都等于最好情况时间复杂度。因为在大部分情况下，入栈操作的时间复杂度 O 都是 O(1)，只有在个别时刻才会退化为 O(n)，所以把耗时多的入栈操作的时间均摊到其他入栈操作上，平均情况下的耗时就接近 O(1)。<br>4、栈在函数调用中的应用<br>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。<br>5、栈在表达式求值中的应用<br>编译器是通过两个栈来实现求值表达式的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。<br>6、栈在括号匹配中的应用<br>从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。<br>7、如何实现浏览器的前进和后退功能？<br>使用两个栈，X 和 Y，把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。当我们点击前进按钮时，我们依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了。如果打开了新页面，则将新页面压如栈X，清空栈Y。<br>【思考】<br>1、函数的层次调用本身符合栈的特性，后调用的函数需要先执行完，调用者内部才能继续执行，函数内的临时变量随着函数本身调用开始，调用结束消亡，也符合栈的特点，调用结束后复位栈顶，正好回到调用者的栈帧范围。<br>2、（阿杜S考特）内存中的堆栈和数据结构堆栈不是一个概念，内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。<br>内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区。<br>代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。<br>静态数据区：存储全局变量、静态变量、常量，常量包括final修饰的常量和String常量。系统自动分配和回收。<br>栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。<br>堆区：new一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。","like_count":0},{"had_liked":false,"id":244489,"user_name":"剑影梦残","can_delete":false,"product_type":"c1","uid":1284481,"ip_address":"","ucode":"A5C5DAA49F6996","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/XSnxM4uP67mVu7ZtPxWqUIvFH15pibGt1rFd34EiblN6NFfgKEKBuibLlI1kUjOIfbY56icwBibn6MmXzSEXm7AHicdQ/132","comment_is_top":false,"comment_ctime":1598535976,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598535976","product_id":100017301,"comment_content":"1.浏览器是申请2个栈，出栈就放到b栈。如果a栈引入新的，就清除b栈<br>2.括号是遇到右括号就检查栈中有没有对应的左括号，如果没有的话就是不匹配<br>3.表达式运算 数字入操作栈，运算符入运算符栈。新的运算符与运算符栈中比较优先级，低或者相同，则取出操作栈2个，运算符栈1个进行运算。如果高于运算符栈的栈顶就继续入栈","like_count":0},{"had_liked":false,"id":243577,"user_name":"JerryZhu","can_delete":false,"product_type":"c1","uid":1591223,"ip_address":"","ucode":"76850CD45786C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","comment_is_top":false,"comment_ctime":1598193232,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598193232","product_id":100017301,"comment_content":"简单写了一个， 不知道对不对 <br><br>public class StackOnLinkedList {<br><br>    private Node top = null;<br><br>    public void push(Node node) {<br>        node.next = top;<br>        top = node;<br>    }<br><br>    public Node pop() {<br>        if (top != null) {<br>            Node re = top;<br>            top = top.next;<br>            return re;<br>        }<br>        return null;<br>    }<br><br>    public Node getTop() {<br>        return top;<br>    }<br><br>    public static void main(String[] args) {<br>        StackOnLinkedList stack = new StackOnLinkedList();<br>        for (int i = 0; i &lt; 10; i++) {<br>            stack.push(new Node(i + &quot;&quot;));<br>        }<br><br>       while (stack.getTop() != null) {<br>           System.out.println(stack.pop().getValue());<br>       }<br>    }<br><br><br>    static class Node {<br>        private String value;<br><br><br>        private Node next;<br><br>        public Node(String value) {<br>            this.value = value;<br>        }<br><br>        public String getValue() {<br>            return value;<br>        }<br>    }<br>}","like_count":0},{"had_liked":false,"id":242309,"user_name":"攻城狮","can_delete":false,"product_type":"c1","uid":1197444,"ip_address":"","ucode":"7D2C2836052C4C","user_header":"https://static001.geekbang.org/account/avatar/00/12/45/84/4b309ba9.jpg","comment_is_top":false,"comment_ctime":1597666537,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597666537","product_id":100017301,"comment_content":"您好，我看到这节中顺序栈的空间复杂度描述是O(1)，<br>但是在第三节最后介绍空间复杂度的实例却是O(n)<br>我觉得两个实例跟类似都是申请数组，但是给出的结果却不一样，我应该怎么理解？？","like_count":0},{"had_liked":false,"id":241259,"user_name":"Jiantao","can_delete":false,"product_type":"c1","uid":1163504,"ip_address":"","ucode":"444580EC5EF109","user_header":"https://static001.geekbang.org/account/avatar/00/11/c0/f0/1aabc056.jpg","comment_is_top":false,"comment_ctime":1597227766,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597227766","product_id":100017301,"comment_content":"一、什么是栈？<br>栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。<br>后进者先出，先进者后出，这就是典型的“栈”结构。二、为什么需要栈？<br><br>二 、适用场景<br><br>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。<br><br>三、如何实现栈？<br><br>1.数组实现（自动扩容）<br><br>2.链表实现<br><br>四、栈的应用<br>1.栈在函数调用中的应用<br>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构，用来存储函数调用时的临时变量。每进入一个函数，就会将其中的临时变量作为栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。<br>2.栈在表达式求值中的应用（比如：34+13*9+44-12&#47;3）<br>利用两个栈，其中一个用来保存操作数，另一个用来保存运算符。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较，若比运算符栈顶元素优先级高，就将当前运算符压入栈，若比运算符栈顶元素的优先级低或者相同，从运算符栈中取出栈顶运算符，从操作数栈顶取出2个操作数，然后进行计算，把计算完的结果压入操作数栈，继续比较。<br>3.栈在括号匹配中的应用（比如：{}{[()]()}）<br>用栈保存为匹配的左括号，从左到右一次扫描字符串，当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号，如果能匹配上，则继续扫描剩下的字符串。如果扫描过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。<br>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明未匹配的左括号为非法格式。<br>4.如何实现浏览器的前进后退功能？<br>我们使用两个栈X和Y，我们把首次浏览的页面依次压如栈X，当点击后退按钮时，再依次从栈X中出栈，并将出栈的数据一次放入Y栈。当点击前进按钮时，我们依次从栈Y中取出数据，放入栈X中。当栈X中没有数据时，说明没有页面可以继续后退浏览了。当Y栈没有数据，那就说明没有页面可以点击前进浏览了。<br>","like_count":0},{"had_liked":false,"id":240485,"user_name":"授人以🐟，不如授人以渔","can_delete":false,"product_type":"c1","uid":1193874,"ip_address":"","ucode":"BD53829E924B66","user_header":"https://static001.geekbang.org/account/avatar/00/12/37/92/961ba560.jpg","comment_is_top":false,"comment_ctime":1596943981,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1596943981","product_id":100017301,"comment_content":"栈是中具有操作限制的数据结构，可看作是数组和链表的特例（栈可使用数组和链表实现）。<br><br>栈的应用场景：<br>1. 函数调用；<br>2. 表达式求值；<br>3. 括号匹配；<br>4. 浏览器的“前进”、“后退”功能","like_count":0},{"had_liked":false,"id":240026,"user_name":"칭찬하다","can_delete":false,"product_type":"c1","uid":1276001,"ip_address":"","ucode":"F6E3F358F3EBDF","user_header":"https://static001.geekbang.org/account/avatar/00/13/78/61/a1189d65.jpg","comment_is_top":false,"comment_ctime":1596719998,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596719998","product_id":100017301,"comment_content":"支持动态扩容的顺序栈 这一小节中扩容后的数据移动入栈操作为什么是 K - 1 次呢？原栈满了，共有 K 个数据，迁移至容量为 2K 的新栈中操作次数 - 1 的原因是什么呢？","like_count":0},{"had_liked":false,"id":239521,"user_name":"向敏文🍊 🍭","can_delete":false,"product_type":"c1","uid":1254293,"ip_address":"","ucode":"38EF38A3CFA6B0","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/95/e029f1fc.jpg","comment_is_top":false,"comment_ctime":1596553717,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596553717","product_id":100017301,"comment_content":"链式栈的实现<br>public class LinkeStack {<br>    private Node node;<br><br>    @Data<br>    private static class Node {<br>        private Object data;<br>        private Node next;<br>    }<br><br>    public LinkeStack2() {<br>        node = new Node();<br>    }<br><br>    public boolean push(Object o) {<br>        Node data = new Node();<br>        data.setData(o);<br>        data.setNext(node);<br>        node = data;<br>        return true;<br>    }<br><br>    public Object pop() {<br>        if (node == null) {<br>            return null;<br>        }<br>        Object data = node.getData();<br>        node = node.getNext();<br>        return data;<br>    }<br>}","like_count":0},{"had_liked":false,"id":239309,"user_name":"jack","can_delete":false,"product_type":"c1","uid":1898292,"ip_address":"","ucode":"A2253AC8570C5E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/jibauP3icEFic4w56L2ddVghL7h2gGKhFdW8lBfE9rpwwRgzUKkLFY9wb4w70AXz7retME96a6EBRTA0LvSLn0ib8A/132","comment_is_top":false,"comment_ctime":1596501407,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1596501407","product_id":100017301,"comment_content":"1.函数调用栈来保存临时变量，为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？<br><br>不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。<br>从调用函数进入被调用函数，对于数据来说，变化的是什么呢？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。<br><br>2.JVM 内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储 Java 中的对象。那 JVM 里面的“栈”跟我们这里说的“栈”是不是一回事呢？如果不是，那它为什么又叫作“栈”呢？<br><br>内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。<br>内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区。<br>因为JVM的内存管理也具有”后进先出“的特性，故称为”栈“。","like_count":0},{"had_liked":false,"id":238875,"user_name":"充鸭","can_delete":false,"product_type":"c1","uid":2086166,"ip_address":"","ucode":"A601D1765C8EFF","user_header":"https://static001.geekbang.org/account/avatar/00/1f/d5/16/0aa053a7.jpg","comment_is_top":false,"comment_ctime":1596353550,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596353550","product_id":100017301,"comment_content":"我这边使用Ruby实现了一个链式栈：<br># 节点<br>class Node<br>    attr_accessor :value , :next<br>    def initialize(value)<br>        @value = value # 节点值<br>        @next  = nil   # 指向下个节点<br>    end<br>end<br><br>class Stack<br>  def initialize # 初始化一个栈<br>    @first = nil<br>    @length = 0<br>  end<br><br>  attr_reader :first, :length<br> <br>  def push(item) # 向栈顶压入一个节点<br>    old_first = @first        # 备份原来的栈顶节点<br>    @first = Node.new(item)   # 新建一个节点，并将它标记为新的栈顶节点<br>    @first.next = old_first   # 将新的栈顶节点的next指针指向原来的栈顶节点。<br>    @length += 1<br>  end<br> <br>  def pop # 将栈顶的节点弹出<br>    return nil if is_empty?   # 栈本身为空的情况下直接返回空<br>    item = @first.item        # 保存原先栈顶节点的item<br>    @first = @first.next      # 将原栈的第二个节点标记为栈顶节点<br>    @length -= 1<br>    return item<br>  end<br>  <br>  def is_empty? # 返回栈是否为空<br>    return @length == 0<br>  end<br>end","like_count":0},{"had_liked":false,"id":238874,"user_name":"充鸭","can_delete":false,"product_type":"c1","uid":2086166,"ip_address":"","ucode":"A601D1765C8EFF","user_header":"https://static001.geekbang.org/account/avatar/00/1f/d5/16/0aa053a7.jpg","comment_is_top":false,"comment_ctime":1596353489,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596353489","product_id":100017301,"comment_content":"我这边使用Ruby实现了一个链式栈：","like_count":0},{"had_liked":false,"id":238430,"user_name":"寒江雪","can_delete":false,"product_type":"c1","uid":2073453,"ip_address":"","ucode":"0738459213414C","user_header":"https://static001.geekbang.org/account/avatar/00/1f/a3/6d/2107f4a0.jpg","comment_is_top":false,"comment_ctime":1596165269,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596165269","product_id":100017301,"comment_content":"&quot;这个时候，你通过页面 b 又跳转到新的页面 d 了，页面 c 就无法再通过前进、后退按钮重复查看了&quot;为什么c不能看了？再出栈到左边的不就可以了吗？<br>","like_count":0},{"had_liked":false,"id":237515,"user_name":"栗子是逗比","can_delete":false,"product_type":"c1","uid":1231333,"ip_address":"","ucode":"26DC1C184D6AB7","user_header":"https://static001.geekbang.org/account/avatar/00/12/c9/e5/0ee8c072.jpg","comment_is_top":false,"comment_ctime":1595850736,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595850736","product_id":100017301,"comment_content":"https:&#47;&#47;github.com&#47;yyjazsf&#47;ts-test&#47;blob&#47;master&#47;src&#47;stack.ts 实现了下这个四则预算，感觉比老师说的复杂，是我哪里逻辑可以优化么","like_count":0},{"had_liked":false,"id":236840,"user_name":"ipofss","can_delete":false,"product_type":"c1","uid":1018620,"ip_address":"","ucode":"DE3061C9259F9E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","comment_is_top":false,"comment_ctime":1595560961,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595560961","product_id":100017301,"comment_content":"Java的api里写着：<br>A more complete and consistent set of LIFO stack operations is provided by the Deque interface and its implementations, which should be used in preference to this class. For example:<br>Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;();","like_count":0},{"had_liked":false,"id":234353,"user_name":"williamcai","can_delete":false,"product_type":"c1","uid":1158294,"ip_address":"","ucode":"B158F52C2D39BC","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/96/46b13896.jpg","comment_is_top":false,"comment_ctime":1594652308,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594652308","product_id":100017301,"comment_content":"有其他的数据结构也是可以的，只不过调用函数到被调用函数只是作用域不一样，用栈是最正常不过的选择；jvm 中的堆栈与数据结构中的栈不是一个概念，只不过符合先进先出的规则。","like_count":0},{"had_liked":false,"id":231456,"user_name":"憎爱不关心","can_delete":false,"product_type":"c1","uid":1133580,"ip_address":"","ucode":"A868ACB200C798","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/0c/ada45f25.jpg","comment_is_top":false,"comment_ctime":1593679859,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593679859","product_id":100017301,"comment_content":"1.不一定必须用栈，但是函数调用要符合后进先出的特性。与栈的特性相同，所以用栈最好。<br>2.JVM中的栈使用的特性也是后进先出，只不过有一点不同，数椐结构中的栈元素要求类型相同，JVM中的栈则没有这个限制。","like_count":0},{"had_liked":false,"id":231346,"user_name":"小马过河","can_delete":false,"product_type":"c1","uid":1990297,"ip_address":"","ucode":"CB8AD608237361","user_header":"https://static001.geekbang.org/account/avatar/00/1e/5e/99/d5488c67.jpg","comment_is_top":false,"comment_ctime":1593655767,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593655767","product_id":100017301,"comment_content":"栈，想到客栈，客栈里有盘子，所以栈就是一摞盘子，只有从最上层放盘子和取盘子两种操作，即入栈和出栈，不能从中间抽。<br>先放的的在下面，后放的在上面。先入后出，后入先出。<br>栈顶是指最上面的盘子。","like_count":0},{"had_liked":false,"id":231115,"user_name":"飞跃疯人院","can_delete":false,"product_type":"c1","uid":1076069,"ip_address":"","ucode":"7A9BDE2CED0939","user_header":"https://static001.geekbang.org/account/avatar/00/10/6b/65/88a22c23.jpg","comment_is_top":false,"comment_ctime":1593588120,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593588120","product_id":100017301,"comment_content":"export const calc = s =&gt; {<br>  const evaluate = {<br>    &quot;+&quot;: (a, b) =&gt; a + b,<br>    &quot;-&quot;: (a, b) =&gt; a - b,<br>    &quot;*&quot;: (a, b) =&gt; a * b,<br>    &quot;&#47;&quot;: (a, b) =&gt; a &#47; b<br>  };<br>  let isPop = false;<br>  const stack1 = [];<br>  const stack2 = [];<br>  let sum = 0;<br>  for (const c of s) {<br>    if (&#47;[0-9]+&#47;.test(c)) {<br>      stack1.push(+c);<br>      if (isPop) {<br>        const a = stack1.pop();<br>        const b = stack1.pop();<br>        const sign = stack2.pop();<br>        stack1.push(evaluate[sign](b, a));<br>        isPop = false;<br>      }<br>    } else if (&quot;+-&quot;.indexOf(c) &gt; -1) {<br>      stack2.push(c);<br>    } else if (&quot;*&#47;&quot;.indexOf(c) &gt; -1) {<br>      stack2.push(c);<br>      isPop = true;<br>    }<br>  }<br>  while (stack1.length &gt; 0) {<br>    const a = stack1.shift();<br>    const b = stack1.shift();<br>    const sign = stack2.shift();<br>    if (sign) {<br>      sum = evaluate[sign](a, b);<br>      stack1.unshift(sum);<br>    }<br>  }<br>  return sum;<br>}<br>请教老师，一层循环怎么写，这时间复杂度不行...","like_count":0},{"had_liked":false,"id":230156,"user_name":"罗樱罂","can_delete":false,"product_type":"c1","uid":2045997,"ip_address":"","ucode":"9072E79E625ED1","user_header":"https://static001.geekbang.org/account/avatar/00/1f/38/2d/f3c6493e.jpg","comment_is_top":false,"comment_ctime":1593289206,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593289206","product_id":100017301,"comment_content":"请问一下老师，最后一道浏览器的题，是不是用双链表也能达成功能？与双栈（除了操作上）没有特别大的区别对吧？","like_count":0},{"had_liked":false,"id":230155,"user_name":"罗樱罂","can_delete":false,"product_type":"c1","uid":2045997,"ip_address":"","ucode":"9072E79E625ED1","user_header":"https://static001.geekbang.org/account/avatar/00/1f/38/2d/f3c6493e.jpg","comment_is_top":false,"comment_ctime":1593288385,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593288385","product_id":100017301,"comment_content":"有一点想问一下关于3+5*8-6的实现 - 参考图片中的流程。我们之前放进去“3+”和“5”的时候都没有计算数字。但是放*8的时候开始计算5*8=40于是栈里面有“3+40”.请问这里为什么直接算43而不继续等下一个“-6“的操作呢？就是说开始pop并计算结果后重新push进去的这个条件是什么？","like_count":0},{"had_liked":false,"id":228518,"user_name":"zhaoyou","can_delete":false,"product_type":"c1","uid":1837716,"ip_address":"","ucode":"D6C5C26A989C02","user_header":"https://static001.geekbang.org/account/avatar/00/1c/0a/94/736a4d51.jpg","comment_is_top":false,"comment_ctime":1592723167,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592723167","product_id":100017301,"comment_content":"以前面试就挂在了考察括号匹配上了，问用什么数据结构，真的得好好学习下数据结构和算法","like_count":0},{"had_liked":false,"id":228421,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1592664284,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592664284","product_id":100017301,"comment_content":"方法的调用逻辑，符合栈的操作，调用方法，需要被调用的方法执行完才能返回到调用方执行，这不就是入栈出栈的过程吗。而且不仅java，其他语言，出奇的一致用这种方式进行方法的调用，我对Java比较熟，Java中，每个线程都有自己调用栈，所以java中，在方法内部定义的局部变量，是线程安全的，也就是局部变量不存在并发问题，每个方法调用都是一个入栈出栈的过程，每个栈结构，又包含局部变量表，操作数栈，方法返回等信息","like_count":0},{"had_liked":false,"id":226711,"user_name":"极客学子","can_delete":false,"product_type":"c1","uid":1149510,"ip_address":"","ucode":"40051597564EB7","user_header":"https://static001.geekbang.org/account/avatar/00/11/8a/46/71747b18.jpg","comment_is_top":false,"comment_ctime":1592188669,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592188669","product_id":100017301,"comment_content":"1.因为函数调用是受限制的操作，比如执行函数A时，需要新调用一个函数B，那函数B只能放在函数A的栈帧后面，而不能放在函数A前面，这样也更符合人们的顺序思维，加入改为队列，那就有可能将函数B插入到函数A前面，这样子逻辑上就不好判断先执行A还是先执行B了；<br>2.不是，虽然不是一个栈，但是它们的思想是共通的，比如函数调用的时候对应一个栈帧的入栈，函数结束对应一个栈帧的出栈，同时函数的调用也满足先进后出，后进先出的约束规则，所以也被称为栈；","like_count":0},{"had_liked":false,"id":226117,"user_name":"whyly","can_delete":false,"product_type":"c1","uid":1798882,"ip_address":"","ucode":"D34D6B7164C982","user_header":"https://static001.geekbang.org/account/avatar/00/1b/72/e2/95b0543c.jpg","comment_is_top":false,"comment_ctime":1591953665,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591953665","product_id":100017301,"comment_content":"老师，文章中提到的“操作系统给每个线程分配了一块独立的内存空间”，这里是不是应该是进程，为进程分配独立的内存空间，多个进程相互隔离，一个进程下的多个线程可以共享这个进程的内存空间，不知道我理解的对不对，希望老师指点，谢谢。","like_count":0},{"had_liked":false,"id":225608,"user_name":"Geek_849f9f","can_delete":false,"product_type":"c1","uid":2027473,"ip_address":"","ucode":"67601F35A91999","user_header":"","comment_is_top":false,"comment_ctime":1591799305,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591799305","product_id":100017301,"comment_content":"调用函数时，函数运行优先级高，调用完成，就可以弹出，符合栈的后进先出","like_count":0},{"had_liked":false,"id":222601,"user_name":"东边日出西边雨","can_delete":false,"product_type":"c1","uid":1900825,"ip_address":"","ucode":"FB373232AC152A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/5Cd5DiaVksY0szIkygsbKYwHKP6AObuqZ7J6TAD3KZaZ0WWQ9k0Byr6pl3EzyxuCTb85NJkt20icQ7zJaFwYa1zQ/132","comment_is_top":false,"comment_ctime":1590847697,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590847697","product_id":100017301,"comment_content":"个人觉得，函数调用选择堆栈，使用因果论来解释可能会更好，所谓有因才有果，有了调用函数才会有被调用函数，而被调用函数在执行的时候，要求他的“因”（调用函数）必须状态确定，那么栈就是最好的选择了，“因”被入栈了。对于栈来说，只能访问栈顶元素和栈的大小，已经入栈的“因”，就被这样保存了起来，防止有意和无意的更改；对于单项链表、队列、表等，因为无法回溯“因”，根本不符合函数调用的因果关系，直接pass，对于数组和双向链表，因为无法完美的保存“因”，可以直接访问，所以也不完美，所以栈就是唯一完美的选择；","like_count":0},{"had_liked":false,"id":220349,"user_name":"Geek_py hang","can_delete":false,"product_type":"c1","uid":1915167,"ip_address":"","ucode":"E1DABF14C9176B","user_header":"https://static001.geekbang.org/account/avatar/00/1d/39/1f/579ae900.jpg","comment_is_top":false,"comment_ctime":1590225483,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590225483","product_id":100017301,"comment_content":"后进先出，地质结构","like_count":0},{"had_liked":false,"id":219754,"user_name":"Lone Ranger","can_delete":false,"product_type":"c1","uid":1689707,"ip_address":"","ucode":"B9C3CF4110F9D4","user_header":"https://static001.geekbang.org/account/avatar/00/19/c8/6b/148c7cce.jpg","comment_is_top":false,"comment_ctime":1590074020,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590074020","product_id":100017301,"comment_content":"提个问题：栈在括号匹配的应用那节，如果输入的没有左括号怎么办(⊙o⊙)！","like_count":0},{"had_liked":false,"id":219342,"user_name":"归零","can_delete":false,"product_type":"c1","uid":1103208,"ip_address":"","ucode":"C99B8E93009A46","user_header":"https://static001.geekbang.org/account/avatar/00/10/d5/68/2201b6b9.jpg","comment_is_top":false,"comment_ctime":1589992486,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1589992486","product_id":100017301,"comment_content":"你通过页面 b 又跳转到新的页面 d 了，页面 c 就无法再通过前进、后退按钮重复查看了<br>--最后浏览器的讲解中，为什么跳转到d之后，页面c就无法通过前进和后退按钮查看了呢？求指导","like_count":0},{"had_liked":false,"id":218520,"user_name":"张家聚","can_delete":false,"product_type":"c1","uid":1009464,"ip_address":"","ucode":"5EC64E717CA570","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/38/3f617799.jpg","comment_is_top":false,"comment_ctime":1589813475,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589813475","product_id":100017301,"comment_content":"表达式求值问题，我本来想按照课件里的思路做，结果想了两天也没写出来，后来查了一下百度，才知道要转换成前缀、后缀表达式再对应求值，理论知识缺乏啊，这些感念都没听过，不是计算机软件专业的孩子要补的课好多啊","like_count":0},{"had_liked":false,"id":216971,"user_name":"iris","can_delete":false,"product_type":"c1","uid":1986106,"ip_address":"","ucode":"8D54D1DBEA6F64","user_header":"https://static001.geekbang.org/account/avatar/00/1e/4e/3a/1932100c.jpg","comment_is_top":false,"comment_ctime":1589379400,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589379400","product_id":100017301,"comment_content":"学习了三个算法思想：浏览器前进后退，表达式求值，括号匹配，都是用栈的思想。<br>对于摊还复杂度算法的理解还是不要能独立思考，还需要多看多思考。","like_count":0},{"had_liked":false,"id":214992,"user_name":"null.shaw","can_delete":false,"product_type":"c1","uid":1606503,"ip_address":"","ucode":"2CA3AD0A0F85A3","user_header":"https://static001.geekbang.org/account/avatar/00/18/83/67/ca364a3c.jpg","comment_is_top":false,"comment_ctime":1588864260,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588864260","product_id":100017301,"comment_content":"链式栈感觉比顺序栈只多了优点，不知道我理解的对不对？那么顺序栈存在的意义是什么呢？","like_count":0},{"had_liked":false,"id":213499,"user_name":"晓森","can_delete":false,"product_type":"c1","uid":1112603,"ip_address":"","ucode":"3D5EB11B9E0FD7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/1b/5d82d759.jpg","comment_is_top":false,"comment_ctime":1588434337,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588434337","product_id":100017301,"comment_content":"1. 笔记已经整理到大纲中<br>2. 自己实现了顺序栈和链表栈 https:&#47;&#47;github.com&#47;samwei12&#47;DataStruct-Algorithm&#47;blob&#47;master&#47;src&#47;main&#47;java&#47;com&#47;samwei12&#47;stack&#47;LinkedListStack.java<br>3. 习题：<br>a) 因为函数的调用关系跟栈的约束是一致的，都是 FILO，从 main 函数开始，最后以 main 函数的执行结束终止，所以适合使用栈<br>b) TODO","like_count":0},{"had_liked":false,"id":213050,"user_name":"八度空间","can_delete":false,"product_type":"c1","uid":1974895,"ip_address":"","ucode":"873FC4111557DF","user_header":"https://static001.geekbang.org/account/avatar/00/1e/22/6f/93bf22d6.jpg","comment_is_top":false,"comment_ctime":1588288166,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588288166","product_id":100017301,"comment_content":"每天早上看一遍，都有新的发现","like_count":0},{"had_liked":false,"id":212907,"user_name":"民工哦","can_delete":false,"product_type":"c1","uid":1255160,"ip_address":"","ucode":"6B6585EBBFC18A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/NnefngARTSPK2qLfYenRjDCNSv7NdGpia05NowusiarIvglJibkJn1WMnj2EzicgBay3XWbWpiaCfQJVr3PAeXcghzw/132","comment_is_top":false,"comment_ctime":1588237265,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588237265","product_id":100017301,"comment_content":"当数组空间不够时，我们就重新申请一块更大的内存，将原来数组中数据统统拷贝过去。这样就实现了一个支持动态扩容的数组。<br>A:啥不直接再老数组后面直接扩大呢，<br>Q:再初始化数组是操作系统只分配了固定连续大小n给数组，n之后的内存可能存有其他数据，如果貌然在老数组后扩容，可能会污染掉其他数据。<br><br>栈的使用非常广泛<br>操作系统中多进程之间的切换，也需要用到2个栈","like_count":0},{"had_liked":false,"id":209396,"user_name":"默默","can_delete":false,"product_type":"c1","uid":1006635,"ip_address":"","ucode":"AF798B9D327F24","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/2b/8b771383.jpg","comment_is_top":false,"comment_ctime":1587545484,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587545484","product_id":100017301,"comment_content":"问题1：栈的特性是后进先出。函数的调用也符合这个特性，最后调用的函数最先返回，函数调用完成，函数中的临时变量就可以删除，用栈这种结构存储最合理。当然用其他数据结构存储(如数组、链表)也可以，因为链表和数组也都能实现栈的功能。<br>问题2，一脸茫然。","like_count":0},{"had_liked":false,"id":208985,"user_name":"刘易之","can_delete":false,"product_type":"c1","uid":1909024,"ip_address":"","ucode":"1CDC3E98B92CE3","user_header":"https://static001.geekbang.org/account/avatar/00/1d/21/20/d7f5bb18.jpg","comment_is_top":false,"comment_ctime":1587477965,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587477965","product_id":100017301,"comment_content":"关于思考题1,程序的运行是函数或者方法的顺序执行,如果第一个方法调用第二个方法,会等到第二个方法执行完,才会急需执行第一个方法,这很符合栈的特性,先进后出,后进显出,用栈来实现最为合适","like_count":0},{"had_liked":false,"id":208094,"user_name":".","can_delete":false,"product_type":"c1","uid":1593729,"ip_address":"","ucode":"9D87B78E6A3E99","user_header":"https://static001.geekbang.org/account/avatar/00/18/51/81/affecc37.jpg","comment_is_top":false,"comment_ctime":1587274743,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587274743","product_id":100017301,"comment_content":"‘如果当前栈大小为 K，并且已满，当再有新的数据要入栈时，就需要重新申请 2 倍大小的内存，并且做 K 个数据的搬移操作，然后再入栈。但是，接下来的 K-1 次入栈操作’ 请问，为什么是k-1此入栈而不是k次？","like_count":0},{"had_liked":false,"id":207975,"user_name":"russellyue","can_delete":false,"product_type":"c1","uid":1541894,"ip_address":"","ucode":"0758ACF772F9C1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epIMwPE6FwsicZ6bjhu7ZpWLnoib8G76sA1XL8y5W8GxqfQEjBub6g57E60mzjWzrA6icMRw1QT5CpyA/132","comment_is_top":false,"comment_ctime":1587224971,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1587224971","product_id":100017301,"comment_content":"课后总结：栈是一种操作受限的线性表，数据只能在一端进出，并且后进先出，先进后出。栈可以用数组也可以用链表来实现。用数组实现的栈被叫做顺序栈，用链表实现的栈被叫做链式栈。链表和数组等相对于栈更加灵活，也完全能够实现栈的功能。而之所以要使用一种操作受限的线性表，最终还是出于特定场景下的安全考虑。空间复杂度为O(1)，栈的出栈和入栈只涉及到栈顶数据的操作。一个算法的空间复杂度，是指除了原本的数据存储空间外，还需要为这个算法腾出来多少额外的空间。出栈时，只需要把栈顶的数据拿出来，所以时间复杂度是稳定的O(1)<br>入栈时，如果是非链式栈，则会出现栈空间不够的情况，这种情况下，需要给栈扩容，在底层实现上个数组扩容的形式一样，即开辟出一个更大内存空间，并且将所有数据迁移过去，这时耗费的时间复杂度为O(n)，这也是最坏时间复杂度情况。最好的情况也就是，栈未满，那直接将数据添加到栈顶就可以，时间复杂度为O(1)。平均复杂度情况，则可以使用摊还计算法计算出均摊平均时间复杂度。即每次扩容（时间复杂度为O(k)），都会伴随着k次的简单入栈（时间复杂度为O(1)）。那么均摊下来，平均时间复杂度则为O(1)。","like_count":0},{"had_liked":false,"id":207930,"user_name":"雪山飞狐","can_delete":false,"product_type":"c1","uid":1475485,"ip_address":"","ucode":"66FBC2AB10B77F","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/9d/fe638260.jpg","comment_is_top":false,"comment_ctime":1587218204,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587218204","product_id":100017301,"comment_content":"1、函数调用之所以采用栈这种数据结构，因为函数调用是典型的后进先出的场景，当从调用函数进入到被调用函数时，作用域、函数临时变量等发生变化，栈这种数据组织方式完美契合了作用域变化对于数据的要求；<br>2、内存管理的栈虽然也符合后进先出的特点，但是本质上属于内存空间，而数据结构的栈是一种数据存储和组织方式，两者并不一样。","like_count":0},{"had_liked":false,"id":207693,"user_name":"继业(Adrian)","can_delete":false,"product_type":"c1","uid":1021147,"ip_address":"","ucode":"D9BAF5F939A2B6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/94/db/4e658ce8.jpg","comment_is_top":false,"comment_ctime":1587138835,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1587138835","product_id":100017301,"comment_content":"写了一个自动缩容扩容的顺序栈<br>public class ArrayStack {<br>  private int n = 0;<br>  private String[] items;<br>  private int top = 0;<br>  public ArrayStack(int capacity) {<br>    items = new String[capacity];<br>    n = capacity;<br>  }<br><br>  public String pop() {<br>    if (n==0) return null;<br>    &#47;&#47; 支持动态缩容,当元素个数小于n&#47;4的容量时，容量减半<br>    if(top &lt; n&#47;4) {<br>      String[] newItems = new String[n&#47;2];<br>      for (int i = 0; i &lt; top; i++) {<br>        newItems[i] = items[i];<br>        items = newItems;<br>      }<br>    }<br>    return items[--top];<br>  }<br>  public boolean push(String item) {<br>    &#47;&#47;支持动态扩容<br>    if (top == n) {<br>      String[] newItems = new String[2 * n];<br>      for (int i = 0; i &lt; n; i++) {<br>        newItems[i] = items[i];<br>      }<br>      items = newItems;<br>    };<br>    items[top++] = item;<br>    return true;<br>  }<br>}","like_count":0},{"had_liked":false,"id":207485,"user_name":"红豆成香","can_delete":false,"product_type":"c1","uid":1488601,"ip_address":"","ucode":"FB8FBB639B4BA6","user_header":"https://static001.geekbang.org/account/avatar/00/16/b6/d9/4d8a4d4c.jpg","comment_is_top":false,"comment_ctime":1587091662,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587091662","product_id":100017301,"comment_content":"链表实现的栈，不知道是否有问题：<br>public class ListNodeStack {<br>\tprivate ListNode popNode = null;<br>\t<br>\tpublic boolean push(int item){<br>\t\tListNode temp = popNode;<br>\t\tpopNode = new ListNode(item);<br>\t\tpopNode.next=temp;<br>\t\treturn true;<br>\t}<br>\tpublic int pop(){<br>\t\tif(popNode == null){<br>\t\t\treturn 0;<br>\t\t}<br>\t\tint  result = popNode.val;<br>\t\tpopNode = popNode.next;<br>\t\treturn result;\t\t<br>\t}<br><br>\tpublic int peek(){<br>\t\tif(popNode == null){<br>\t\t\treturn 0;<br>\t\t}<br>\t\tint  result = popNode.val;<br>\t\treturn result;<br>\t}<br><br>\tpublic boolean empty() {<br>\t\treturn popNode == null;<br>\t}<br>}<br>","like_count":0},{"had_liked":false,"id":207342,"user_name":"鱼丸粗面","can_delete":false,"product_type":"c1","uid":1785016,"ip_address":"","ucode":"B2F3F75B0D1422","user_header":"https://static001.geekbang.org/account/avatar/00/1b/3c/b8/9489387c.jpg","comment_is_top":false,"comment_ctime":1587050554,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587050554","product_id":100017301,"comment_content":"用代码实现括号检查<br><br>public static boolean check(String str) {<br>        List&lt;Character&gt; brackets = Arrays.asList(&#39;(&#39;, &#39;[&#39;, &#39;{&#39;, &#39;)&#39;, &#39;]&#39;, &#39;}&#39;);<br>        Stack&lt;Character&gt; stack = new Stack&lt;&gt;(20, true);<br>        char[] chars = str.toCharArray();<br>        for (char c : chars) {<br>            int cType = brackets.indexOf(c);<br>            &#47;&#47; 其他符合不管<br>            if (cType == -1) {<br>                continue;<br>            }<br>            Character top = stack.peep();<br>            if (top != null) {<br>                &#47;&#47; 栈顶的括号类型<br>                int topType = brackets.indexOf(top);<br><br>                if (topType &lt; 3) {<br>                    &#47;&#47; 左右相等，抵消了<br>                    if (topType == cType - 3) {<br>                        stack.pop();<br>                    }<br>                    &#47;&#47; 如果是其他的右括号，就是错了<br>                    else if (cType &gt; 3) {<br>                        return false;<br>                    }<br>                    &#47;&#47; 它是左括号，入栈<br>                    else {<br>                        stack.push(c);<br>                    }<br>                }<br>                &#47;&#47; 栈顶是右括号，没有被抵消掉说明错了<br>                &#47;&#47; 理论上根本不会走到这一步来，因为只有左括号才能入栈<br>                else {<br>                    return false;<br>                }<br>            }<br>            &#47;&#47; 第一元素必须是左括号<br>            else if (cType &lt; 3) {<br>                stack.push(c);<br>            } else {<br>                return false;<br>            }<br>        }<br>        return stack.size() == 0;<br>    }","like_count":0},{"had_liked":false,"id":206872,"user_name":"这得从我捡到一个鼠标垫开始说起","can_delete":false,"product_type":"c1","uid":1272321,"ip_address":"","ucode":"2FF4347B4E7A9B","user_header":"https://static001.geekbang.org/account/avatar/00/13/6a/01/d9cb531d.jpg","comment_is_top":false,"comment_ctime":1586947170,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1586947170","product_id":100017301,"comment_content":"1.函数的执行其实是一种后进先出的形式执行的。后执行的函数会先结束，这和栈这种数据结构很吻合。<br>2.对jvm不是太了解，我觉得jvm的堆栈只是一个存储内存数据的地方。叫堆栈，但和栈没什么关系。","like_count":0},{"had_liked":false,"id":206568,"user_name":"拉普达","can_delete":false,"product_type":"c1","uid":1930686,"ip_address":"","ucode":"0E524C0D99B2A0","user_header":"https://static001.geekbang.org/account/avatar/00/1d/75/be/6f3ab95e.jpg","comment_is_top":false,"comment_ctime":1586882402,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586882402","product_id":100017301,"comment_content":"栈后进先出的特点与函数调用的过程高度吻合。因此操作系统中常用于栈帧作为当前的代码执行域，存储临时变量。建议在画栈帧结构的时候，把ret返回指令画上，有助于理解函数栈帧的概念。<br>","like_count":0},{"had_liked":false,"id":206011,"user_name":"梅端","can_delete":false,"product_type":"c1","uid":1525335,"ip_address":"","ucode":"FEC08731457770","user_header":"https://static001.geekbang.org/account/avatar/00/17/46/57/fe38a6db.jpg","comment_is_top":false,"comment_ctime":1586772924,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586772924","product_id":100017301,"comment_content":"栈的使用真的是无处不在，必须掌握，加油","like_count":0},{"had_liked":false,"id":204215,"user_name":"亢（知行合一的路上）","can_delete":false,"product_type":"c1","uid":1347013,"ip_address":"","ucode":"958AF7C96EB9E8","user_header":"https://static001.geekbang.org/account/avatar/00/14/8d/c5/898b13b4.jpg","comment_is_top":false,"comment_ctime":1586352382,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586352382","product_id":100017301,"comment_content":"两个栈配合使用，比一个强大很多😄","like_count":0},{"had_liked":false,"id":203899,"user_name":"williamcai","can_delete":false,"product_type":"c1","uid":1158294,"ip_address":"","ucode":"B158F52C2D39BC","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/96/46b13896.jpg","comment_is_top":false,"comment_ctime":1586303493,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586303493","product_id":100017301,"comment_content":"jvm的栈其实是线程栈，里面是一个一个栈针，代表着一个一个函数调用","like_count":0},{"had_liked":false,"id":202973,"user_name":"麦克斯韦妖","can_delete":false,"product_type":"c1","uid":1938385,"ip_address":"","ucode":"ADAE586302A104","user_header":"https://static001.geekbang.org/account/avatar/00/1d/93/d1/9eb38793.jpg","comment_is_top":false,"comment_ctime":1586096269,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586096269","product_id":100017301,"comment_content":"栈是一种后进先出的数据结构，操作受限的线性表。<br>特殊之处在于：数据只能从栈顶添加或者删除，栈底是固定的<br>栈的应用：<br>1.函数调用<br>2.表达式求值<br>3.浏览器前进和后退<br><br>","like_count":0},{"had_liked":false,"id":201709,"user_name":"喻茂","can_delete":false,"product_type":"c1","uid":1318661,"ip_address":"","ucode":"C8BD8086A17365","user_header":"https://static001.geekbang.org/account/avatar/00/14/1f/05/8a06692e.jpg","comment_is_top":false,"comment_ctime":1585822730,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585822730","product_id":100017301,"comment_content":"&lt;?php<br>&#47;&#47; 定义某一节点<br>class Node {<br>\tpublic $val; &#47;&#47; 保存值<br>\tpublic $nextNode; &#47;&#47; 下个节点的引用<br>\t<br>\tpublic function __construct($val = null,$nextNode=null)<br>\t{<br>\t\t$this-&gt;val = $val;<br>\t\t$this-&gt;nextNode = $nextNode;<br>\t}<br>}<br>class Stack <br>{<br>\tpublic $head;&#47;&#47; 头节点<br>\tpublic $size; &#47;&#47; 长度<br>\t<br>\tpublic function __construct()<br>\t{<br>\t\t$this-&gt;head = new Node(); &#47;&#47; 头节点是空节点<br>\t\t$this-&gt;size = 0;<br>\t}<br>\t<br>\t&#47;&#47; 指定位置插入节点<br>\tpublic function add($index,$value) {<br>\t\tif($index &gt; $this-&gt;size) {<br>\t\t\techo &quot;超出链表范围&lt;br&#47;&gt;&quot;;<br>\t\t\treturn false;<br>\t\t}<br>\t\t$prev = $this-&gt;head;<br>\t\tfor($i=0;$i&lt;$index;$i++) {<br>\t\t\t$prev = $prev-&gt;nextNode;<br>\t\t}<br>\t\t$prev-&gt;nextNode = new Node($value,$prev-&gt;nextNode);<br>\t\t$this-&gt;size++;<br>\t\treturn true;<br>\t}<br>\t&#47;&#47; 插入数据到链表头<br>\tpublic function addFirst($value) {<br>\t\t$this-&gt;add(0,$value);<br>\t}<br>\t&#47;&#47; 删除指定位置节点<br>\tpublic function deleteNode($index) {<br>\t\tif ($index &lt; 1) {<br>\t\t\techo &quot;哨兵节点不可以删除&lt;br&#47;&gt;&quot;;<br>\t\t\treturn false;<br>\t\t}<br>\t\tif ($index &gt; $this-&gt;size) {<br>\t\t\techo &quot;超出链表范围&lt;br&#47;&gt;&quot;;<br>\t\t\treturn false;<br>\t\t}<br>\t\t$prev = $this-&gt;head;<br>\t\tfor($i=1;$i&lt;=$index;$i++){<br>\t\t\tif($i==$index) {<br>\t\t\t\t$tempNode = $prev-&gt;nextNode;<br>\t\t\t\t$prev-&gt;nextNode = $prev-&gt;nextNode-&gt;nextNode;<br>\t\t\t\tunset($tempNode);<br>\t\t\t}<br>\t\t\t$prev = $prev-&gt;nextNode;<br>\t\t}<br>\t\t$this-&gt;size--;<br>\t\treturn true;<br>\t}<br>\tpublic function push($value) {<br>\t\t$this-&gt;addFirst($value);<br>\t}<br>\t<br>\tpublic function pop(){<br>\t\tif ($this-&gt;head-&gt;nextNode) {<br>\t\t\t$r = $this-&gt;head-&gt;nextNode-&gt;val;<br>\t\t\t$this-&gt;deleteNode(1);<br>\t\t\treturn $r;<br>\t\t} else {<br>\t\t\treturn false;<br>\t\t}<br>\t}<br>}<br><br>$stack = new Stack();<br>$stack-&gt;push(1);<br>$stack-&gt;push(2);<br>$stack-&gt;push(3);<br><br>var_dump($stack-&gt;pop());<br>echo &quot;&lt;br&gt;&quot;;<br>var_dump($stack-&gt;pop());<br>echo &quot;&lt;br&gt;&quot;;<br>var_dump($stack-&gt;pop());<br>var_dump($stack-&gt;pop());","like_count":0},{"had_liked":false,"id":200754,"user_name":"贵贵","can_delete":false,"product_type":"c1","uid":1196359,"ip_address":"","ucode":"97D5F277B5317D","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/47/7e4bdd7b.jpg","comment_is_top":false,"comment_ctime":1585646581,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585646581","product_id":100017301,"comment_content":"采用栈来存储临时变量的原因是，临时变量的临时性，或者说数据的生命周期的短暂性。<br>这种短暂性要求临时变量“用完即毁”，这样可以使得内存的使用效率更高。<br>","like_count":0},{"had_liked":false,"id":200265,"user_name":"蜗牛","can_delete":false,"product_type":"c1","uid":1086220,"ip_address":"","ucode":"01CC18F12E556D","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/0c/0a6a0d5e.jpg","comment_is_top":false,"comment_ctime":1585565979,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585565979","product_id":100017301,"comment_content":"是相同的思想，都是栈结构。比如虚拟机栈，他压栈压的是栈帧。不一定非要用栈，只要满足先入后出就行。","like_count":0},{"had_liked":false,"id":196648,"user_name":"好吃二师兄","can_delete":false,"product_type":"c1","uid":1242173,"ip_address":"","ucode":"A367B52BC79199","user_header":"https://static001.geekbang.org/account/avatar/00/12/f4/3d/ec3d6348.jpg","comment_is_top":false,"comment_ctime":1585299917,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585299917","product_id":100017301,"comment_content":"Java中的栈是JVM当中线程私有的内存空间，我们这里的栈是具体的是数据结构","like_count":0},{"had_liked":false,"id":193743,"user_name":"kaiser","can_delete":false,"product_type":"c1","uid":1390375,"ip_address":"","ucode":"F9438786E9A57B","user_header":"https://static001.geekbang.org/account/avatar/00/15/37/27/b023ada7.jpg","comment_is_top":false,"comment_ctime":1584956976,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584956976","product_id":100017301,"comment_content":"JVM 内存管理中，虚拟机栈描述的是 Java 执行的内存模型：每个方法在执行的同时都会创建一个栈帧用来存储局部变量表、操作数栈、动态链接、方法出入口等信息。每一个方法从调用到执行弯沉的过程，就对应着一个栈帧在虚拟机栈的入栈和出栈过程。栈帧中的有操作数栈，当一个方法开始执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是入栈和出栈操作，比如在做算术运算时都是通过操作数栈进行，又或者是调用其他方法的时候，通过操作数栈进行参数传递。虚拟机栈和本章所讲的栈不是一个，但是两个有相同的特点，本章所讲的栈是一种基本数据结构，强调的是数据的组织，而虚拟机栈强调的是数据的生命周期。<br>","like_count":0},{"had_liked":false,"id":191993,"user_name":"獨自去遠方","can_delete":false,"product_type":"c1","uid":1503941,"ip_address":"","ucode":"E246B33F397441","user_header":"https://static001.geekbang.org/account/avatar/00/16/f2/c5/2a441c27.jpg","comment_is_top":false,"comment_ctime":1584808751,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584808751","product_id":100017301,"comment_content":"栈<br>\t？浏览器前进、后退功能实现<br>\t\t使用两个栈<br>\t\t\t顺序查看的放入第一个栈<br>\t\t\t后退的从第一个取出放入第二个栈<br>\t\t\t跳转到新链接，清空第二个栈<br><br>\t如何理解栈<br>\t\t摞盘子<br>\t\t只允许在一段插入和删除数据<br><br>\t顺序栈\t链式栈<br>\t操作：push\tpop<br>\t时间复杂度：操作都是O(1)<br><br>\t栈的应用<br>\t\t函数调用<br>\t\t表达式求值<br>\t\t括号匹配","like_count":0},{"had_liked":false,"id":191172,"user_name":"雨落千木的时节","can_delete":false,"product_type":"c1","uid":1796430,"ip_address":"","ucode":"A268063299F0D6","user_header":"https://static001.geekbang.org/account/avatar/00/1b/69/4e/7ef7604b.jpg","comment_is_top":false,"comment_ctime":1584752504,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584752504","product_id":100017301,"comment_content":"java里面有一个stack类和queue类，但是从来没有看里面的具体实现细节，曾经遇到过一个面试题，就是用队列实现栈和用栈实现队列，我觉得这两者可以互通","like_count":0},{"had_liked":false,"id":190098,"user_name":"SteelHuaSheng","can_delete":false,"product_type":"c1","uid":1396126,"ip_address":"","ucode":"BC8127FC5207FC","user_header":"https://static001.geekbang.org/account/avatar/00/15/4d/9e/04ec08bf.jpg","comment_is_top":false,"comment_ctime":1584602674,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584602674","product_id":100017301,"comment_content":"链表<br><br>来历：用栈来匹配括号这个想法太优雅了，我这个猪脑子为什么想不出来？<br><br>自身特点：①只能一端操作②先进后出、后进先出<br><br>适合解决的问题：当某个数据集合①只涉及在一端插入和删除数据，②并且满足先进后出、后进先出的特性，我们就应该首选“栈”这种数据结构<br><br>实际应用场景：①函数调用栈②表达式求值③括号匹配④浏览器前进后退","like_count":0},{"had_liked":false,"id":189247,"user_name":"wholly","can_delete":false,"product_type":"c1","uid":1089235,"ip_address":"","ucode":"3CB7D06CC6C670","user_header":"https://static001.geekbang.org/account/avatar/00/10/9e/d3/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1584492911,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584492911","product_id":100017301,"comment_content":"1、后进先出是栈的特点，也是区分其他线性数据结构的最大点；<br>2、入栈和出栈需要多练习，掌握其运作原理才能算熟悉它；<br>3、实际开发过程中，栈的应用场景还是非常多的。","like_count":0},{"had_liked":false,"id":188311,"user_name":"o0oi1i","can_delete":false,"product_type":"c1","uid":1132312,"ip_address":"","ucode":"D1F6AD4AAEAFBE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/18/293cd24d.jpg","comment_is_top":false,"comment_ctime":1584338617,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584338617","product_id":100017301,"comment_content":"打卡8","like_count":0},{"had_liked":false,"id":185357,"user_name":"谭方敏","can_delete":false,"product_type":"c1","uid":1710960,"ip_address":"","ucode":"728DC7ECB7C902","user_header":"https://static001.geekbang.org/account/avatar/00/1a/1b/70/547042ee.jpg","comment_is_top":false,"comment_ctime":1583566704,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583566704","product_id":100017301,"comment_content":"栈是一种线性数据结构，运行规则是先进后出，跟从一堆盘子中拿盘子类似，仅限于头部操作，抽盘子的话，始终是要在上面拿，不要在下面拿，不然碗全给打了。<br>根据实现方式的不同，用数组实现的叫顺序栈，用链表实现的叫链式栈。<br>栈的应用有三，1）表达式，2）函数调用，3）括号匹配。","like_count":0},{"had_liked":false,"id":184437,"user_name":"JuneMare","can_delete":false,"product_type":"c1","uid":1891472,"ip_address":"","ucode":"4A3437B3CEF544","user_header":"","comment_is_top":false,"comment_ctime":1583314472,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583314472","product_id":100017301,"comment_content":"我们在讲栈的应用时，讲到用函数调用栈来保存临时变量，为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？<br>答：函数调用的特点是，外层函数要等到内层函数返回才能继续执行。从前往后加载的话，一定是内层函数先执行，符合”先进先出“的特点。其它数据结构也可以，但是操作起来没有栈这么方便。<br><br>我们都知道，JVM 内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储 Java 中的对象。那 JVM 里面的“栈”跟我们这里说的“栈”是不是一回事呢？如果不是，那它为什么又叫作“栈”呢？<br>JVM的栈与这里的”栈“不是同一个意思。JVM的栈是虚拟机栈，有更加复杂的结构，内部由多个”栈帧“构成。如果把每一个栈帧看作栈中的一个元素，那么栈帧也符合先进先出的特点，所以JVM的虚拟机栈也叫”栈“。<br>","like_count":0},{"had_liked":false,"id":182920,"user_name":"Eternal","can_delete":false,"product_type":"c1","uid":1188023,"ip_address":"","ucode":"EA6FE7CC98F740","user_header":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","comment_is_top":false,"comment_ctime":1582890376,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582890376","product_id":100017301,"comment_content":"这里讲的栈是抽象的数据结构，是概念，JVM的栈空间是一片物理内存，JVM用这片内存来模拟栈的操作，或者理解成如果要是用这部分内存需要按照栈的操作方法入栈和出栈；且栈空间的出栈和入栈是用来模拟函数调用的","like_count":0},{"had_liked":false,"id":182741,"user_name":"Grey","can_delete":false,"product_type":"c1","uid":1663898,"ip_address":"","ucode":"D63D36C9A7F16B","user_header":"https://static001.geekbang.org/account/avatar/00/19/63/9a/6872c932.jpg","comment_is_top":false,"comment_ctime":1582858690,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582858690","product_id":100017301,"comment_content":"&quot;在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。&quot;,我想解释一下“栈顶复位”这个概念。不知道对不对。比如在main()函数里面有几个作用域在main()的变量。而在main()的执行语句中又调用了别的函数例如add(1,1)。这时候主线程对应的栈里面就会计算出进入被main函数调用的add(1,1)有多少个栈帧，一次性分配。然后add执行完毕，又回到main()。与此同时，在栈中关于add被分配的栈帧被清空收回。栈顶指针指向原来调用add之前的栈帧，就是所谓的栈顶复位。","like_count":0},{"had_liked":false,"id":180250,"user_name":"拾迹","can_delete":false,"product_type":"c1","uid":1025093,"ip_address":"","ucode":"38F367B77FF2D7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/45/3cb5cdc6.jpg","comment_is_top":false,"comment_ctime":1582218615,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1582218615","product_id":100017301,"comment_content":"万恶的 goto 语法，符合函数调用栈的场景吗？","like_count":0},{"had_liked":false,"id":179765,"user_name":"发霉的宅大人","can_delete":false,"product_type":"c1","uid":1738243,"ip_address":"","ucode":"6757E30FE5E48D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/03/95004954.jpg","comment_is_top":false,"comment_ctime":1582093686,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582093686","product_id":100017301,"comment_content":"思考题<br>第一：为什么函数调用要用“栈”来保存临时变量呢？<br>因为栈方便弹出，从被调用函数回到调用函数<br>第二：用其他数据结构不行吗？<br>并不是我们需要用栈，而是我们需要用到这种先进后出，后进先出的数据结构。<br>","like_count":0},{"had_liked":false,"id":177120,"user_name":"王jojo","can_delete":false,"product_type":"c1","uid":1812840,"ip_address":"","ucode":"1ABE7FA2614F86","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/68/ec442a70.jpg","comment_is_top":false,"comment_ctime":1581295184,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581295184","product_id":100017301,"comment_content":"想问下,一直在说链表相比数组会多消耗内存,那多消耗的这部分能占多大的比例?有什么方法分析么?","like_count":0},{"had_liked":false,"id":176181,"user_name":"一只独立特行的猪","can_delete":false,"product_type":"c1","uid":1473358,"ip_address":"","ucode":"52263607CCBE6F","user_header":"https://static001.geekbang.org/account/avatar/00/16/7b/4e/73a9deec.jpg","comment_is_top":false,"comment_ctime":1580980381,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580980381","product_id":100017301,"comment_content":"看了留言和git上面的代码实现，感觉自己对栈的理解又强了不少，栈的主要操作就是入栈和出栈，自己按照老师的思路，参照老师代码写了一遍，感觉还是收获不少。","like_count":0},{"had_liked":false,"id":173237,"user_name":"AMIR","can_delete":false,"product_type":"c1","uid":1782777,"ip_address":"","ucode":"65142D9669071B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/33/f9/50b76abe.jpg","comment_is_top":false,"comment_ctime":1579483555,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579483555","product_id":100017301,"comment_content":"存在意义，更具体的功能，更安全的体验<br>应用：函数栈，表达式运算，括号匹配，浏览器前进后退","like_count":0},{"had_liked":false,"id":172637,"user_name":"eg366","can_delete":false,"product_type":"c1","uid":1161338,"ip_address":"","ucode":"13903296514BFA","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/7a/16947d01.jpg","comment_is_top":false,"comment_ctime":1579241300,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579241300","product_id":100017301,"comment_content":"请问老师，顺序栈和链式栈两种实现方式，在选择上有哪些区别和取舍？","like_count":0},{"had_liked":false,"id":170085,"user_name":"Chen","can_delete":false,"product_type":"c1","uid":1503113,"ip_address":"","ucode":"C1128558AB5BC4","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/89/8c73a24d.jpg","comment_is_top":false,"comment_ctime":1578526934,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578526934","product_id":100017301,"comment_content":"表达式求值的不应该先算40-6吗？怎么先算了40+3","like_count":0},{"had_liked":false,"id":168861,"user_name":"时光","can_delete":false,"product_type":"c1","uid":1687247,"ip_address":"","ucode":"EBEAE7F78A7AAE","user_header":"https://static001.geekbang.org/account/avatar/00/19/be/cf/9ef0d4ab.jpg","comment_is_top":false,"comment_ctime":1578204111,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578204111","product_id":100017301,"comment_content":"解题思路<br>1. 每个右括号必须与最近出现左括号配对<br>2. 这里就需要当遍历到右括号时拿到最近出现的左括号做配对判断，我们从左向右遍历字符串，最近出现的左括号必然是最后遍历到的,符合后进先出规则，用栈数据结构来处理<br>3. 将遍历到的左括号依次放入栈中更符合常理，这里为了避免配对判断，取巧就将遍历到的左括号对应的右括号放入栈中了，这样当遍历到右括号时只需要判断是否相同即可，思想还是一样的<br>代码<br>class Solution {<br>    public boolean isValid(String s) {<br>        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();<br>        for (char c : s.toCharArray()) {<br>            if (c == &#39;(&#39;) {<br>                stack.push(&#39;)&#39;);<br>                continue;<br>            }<br>            if (c == &#39;[&#39;) {<br>                stack.push(&#39;]&#39;);<br>                continue;<br>            }<br>            if (c == &#39;{&#39;) {<br>                stack.push(&#39;}&#39;);<br>                continue;<br>            }<br><br>            if (stack.empty() || stack.pop() != c) {<br>                return false;<br>            }<br>        }<br><br>        return stack.empty();<br>    }<br>}","like_count":0},{"had_liked":false,"id":168535,"user_name":"盘胧","can_delete":false,"product_type":"c1","uid":1650748,"ip_address":"","ucode":"5386CC4C92ECC2","user_header":"https://static001.geekbang.org/account/avatar/00/19/30/3c/0668d6ae.jpg","comment_is_top":false,"comment_ctime":1578105774,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578105774","product_id":100017301,"comment_content":"思考题的。按照我们学习数据结构的思路，数据结构由各种场景决定使用，因为函数调用场景最适合stack，所以用stack","like_count":0},{"had_liked":false,"id":168400,"user_name":"pikachu122","can_delete":false,"product_type":"c1","uid":1689365,"ip_address":"","ucode":"43FE4DBC872FFA","user_header":"https://static001.geekbang.org/account/avatar/00/19/c7/15/24bf166a.jpg","comment_is_top":false,"comment_ctime":1578061297,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578061297","product_id":100017301,"comment_content":"为什么在函数中临时变量用栈来保存：<br>栈有后进先出的特点。多重调用的函数中，要先执行最后一次被调用的函数，然后再把返回值给调用它的上一次函数... 在执行某个函数时，它的临时变量与前面调用它的函数都无关，在执行这个函数时不会用到其他函数的临时变量，而且栈的入栈和出栈的时间复杂度都为O(1)，十分高效。这样函数只要在被调用时将需要的临时变量入栈，结束时将所有临时变量全部出栈就可以了。","like_count":0},{"had_liked":false,"id":167462,"user_name":"小夏","can_delete":false,"product_type":"c1","uid":1110755,"ip_address":"","ucode":"D87444ADC28C6A","user_header":"https://static001.geekbang.org/account/avatar/00/10/f2/e3/c1a88a64.jpg","comment_is_top":false,"comment_ctime":1577810363,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577810363","product_id":100017301,"comment_content":"首先说一下第二个思考题，这里说的程序栈实际就是父函数与子函数的关系，调用顺序是父函数入栈执行，遇到子函数时，将子函数入栈，执行子函数，父函数因为被压到下面进入暂停状态。等到子函数执行完毕以后，子函数出栈，父函数接着继续执行。至于第一个问题，jvm中的内存堆栈中的函数栈貌似就跟这个原理类似？我还需要下去仔细查阅一下资料","like_count":0},{"had_liked":false,"id":166441,"user_name":"历史课代表","can_delete":false,"product_type":"c1","uid":1328617,"ip_address":"","ucode":"FBFA79C0F5EB77","user_header":"https://static001.geekbang.org/account/avatar/00/14/45/e9/3f121576.jpg","comment_is_top":false,"comment_ctime":1577448573,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577448573","product_id":100017301,"comment_content":"b页面跳到d页面后，c页面为啥不能通过前进或者后退按钮查看，还是没太明白","like_count":0},{"had_liked":false,"id":164123,"user_name":"Randy","can_delete":false,"product_type":"c1","uid":1125259,"ip_address":"","ucode":"7BF52ADBFD4F5D","user_header":"https://static001.geekbang.org/account/avatar/00/11/2b/8b/dd02189a.jpg","comment_is_top":false,"comment_ctime":1576889144,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576889144","product_id":100017301,"comment_content":"王老师，请教一下，按照文中<br>“如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。”<br>计算公式如果换成 3+5*8-6*2结果就不成立了，这种场景编译器是怎么适应栈的呢","like_count":0},{"had_liked":false,"id":161518,"user_name":"美美","can_delete":false,"product_type":"c1","uid":1148422,"ip_address":"","ucode":"44CC95C45AF345","user_header":"https://static001.geekbang.org/account/avatar/00/11/86/06/72b01bb7.jpg","comment_is_top":false,"comment_ctime":1576221453,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576221453","product_id":100017301,"comment_content":"出栈代码操作没有实际释放内容空间","like_count":0},{"had_liked":false,"id":160877,"user_name":"俗人or诗","can_delete":false,"product_type":"c1","uid":1357122,"ip_address":"","ucode":"C23CCA8B5BE8A8","user_header":"https://static001.geekbang.org/account/avatar/00/14/b5/42/21ed2f7b.jpg","comment_is_top":false,"comment_ctime":1576052805,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576052805","product_id":100017301,"comment_content":"1、均摊时间复杂度的分析方法要点？<br>     1.分析复杂度的变化形式；2.分析复杂度的分布<br>2、利用其它数据结构肯定是没问题的。至于为何是栈呢，因为函数调用用涉及函数之间的调用及作用域的问题，当一个函数调用另一个函数时，给被调用函数分配栈帧，也即一个作用域，压栈；等被调用函数执行完毕后，就可以出栈；这样能够很好模拟函数之间调用。<br>概括的说：因为这些数据的存活时间满足“后入先出”（LIFO）顺序，而栈的基本操作正好就是支持这种顺序的访问<br>3、结合这个理解第二个问题，概念上不是一个东西。但是JVM中的栈，其实也是一种函数调用栈。是数据结构中栈的一种实现，这是个人理解，欢迎讨论。","like_count":0},{"had_liked":false,"id":160863,"user_name":"谢艺华","can_delete":false,"product_type":"c1","uid":1711975,"ip_address":"","ucode":"08A50F4D66ECCA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/1f/67/d8c69191.jpg","comment_is_top":false,"comment_ctime":1576049040,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576049040","product_id":100017301,"comment_content":"表达式的那个题，其实在程序语言设计中，有涉及的。讲师用的是中缀表达式。还有前缀表达式和后缀表达式。大家可以查一查","like_count":0},{"had_liked":false,"id":159160,"user_name":"Rickieslove","can_delete":false,"product_type":"c1","uid":1751095,"ip_address":"","ucode":"47A1A53F2E1FAE","user_header":"https://static001.geekbang.org/account/avatar/00/1a/b8/37/d22456d5.jpg","comment_is_top":false,"comment_ctime":1575549873,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1575549873","product_id":100017301,"comment_content":"浏览器前进后退功能：<br>用户每次正在浏览的永远都是x栈的栈顶元素页面；<br>当y栈中有c时，用户重新点击了d页面，这是应当是有一个判断，判断新点击的这个页面是不是y栈的栈顶元素，如果是，y出栈，x进栈，如果不是，y栈清空，x压栈，最后那块详细的操作过程应当是这样的对吗？","like_count":0,"discussions":[{"author":{"id":1809799,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJNxMqDoNODfL1aFpkJboxlZPyFANAt9ovzksYtMUIGo3KbHr4Qy8j20Txrpiau6iaJGgAr1nCfpy9w/132","nickname":"爱学习的老吴","note":"","ucode":"E515F50E7A8A68","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":195119,"discussion_content":"你说的有道理，但是个人认为是浏览器判断你点击的是前进还是后退才会对应的出栈压栈，只要不是这两个按钮，你点击其他地方打开新页面，前进栈都清空，不做判断。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583249293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158853,"user_name":"小遥子","can_delete":false,"product_type":"c1","uid":1754666,"ip_address":"","ucode":"E2CCF654F4F9D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/c6/2a/e6281f10.jpg","comment_is_top":false,"comment_ctime":1575465152,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575465152","product_id":100017301,"comment_content":"小结：<br>栈是一种受限制的线性结构，其特点是后进先出。适用于只在某一端进行插入和删除操作，并且满足后进先出特性的数据集合，如：函数调用，表达式求值，括号匹配等。<br>栈可以用数组或者链表实现，用数组实现的叫做顺序栈，用链表实现的叫做链式栈。<br>支持扩容的顺序栈其均摊时间复杂度为O(1)。<br>","like_count":0},{"had_liked":false,"id":158648,"user_name":"Jun","can_delete":false,"product_type":"c1","uid":1120678,"ip_address":"","ucode":"0FAB76D99153ED","user_header":"https://static001.geekbang.org/account/avatar/00/11/19/a6/7ae63d7e.jpg","comment_is_top":false,"comment_ctime":1575427203,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575427203","product_id":100017301,"comment_content":"Jvm的栈也是基于数据结构的栈的原理。我觉得。但jvm的堆不是数据结构的堆。","like_count":0},{"had_liked":false,"id":158495,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1575385040,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575385040","product_id":100017301,"comment_content":"1，后进先出，先进后出，是一种“操作受限“的线性表，只允许在一端插入和删除数据。<br><br>2，栈的存在意义：<br>（1）数组或链表在功能上确实可以替代栈，但对于特定的数据结构是对特定的场景抽象的，数组或链表暴露了太多的操作接口，操作上比较灵活，导致在使用上比较不可控，容易出错。<br>（2）当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出，后进后出的特性，应当首选“栈”这种数据结构。<br><br>3，栈的实现方式：<br>\t（1）栈主要包括两个操作，入栈和出栈。<br>\t（2）用数组实现的栈，叫作顺序栈，用链表实现的栈，叫链式栈。<br>\t<br>4，栈的复杂度分析：<br>\t（1）不管是顺序栈还是链式栈，在入栈和出栈过程中，只需要一个两个临时变量存储空间，所以空间复杂度是O(1)。<br>\t（2）不管顺序栈还是链式栈，入栈，出栈只涉及栈顶个别数据的操作，所以时间复杂度都是O(1)。<br>\t（3）支持动态扩容的顺序栈复杂度：<br>\t\ta. 出栈不涉及内存的重新申请和数据迁移，所以出栈的时间复杂度仍是O(1)。<br>\t\tb. 入栈操作，当栈中用空闲空间时，入栈操作的时间复杂度为O(1)。当空间不够时，需要重新申请内存和数据搬移，时间复杂度为O(n)。<br>\t\tc. 均摊时间复杂度一般都等于最好情况时间复杂度，因为在大部分情况下，入栈操作的时间复杂度O都是O(1)，只有在个别时刻才会退化为O(n),所以把耗时多的入栈操作的时间均摊到其他入栈操作上，平均情况下的耗时就接近O(1)。<br><br>5，栈的应用<br>\t（1）在函数调用中的应用：栈做作为一个比较基础的数据结构，经典的应用场景是函数调用栈。<br>\t\t操作系统给每个线程池分配了一个独立的内存空间，这块内存被组成成“栈”这种结构，用来存储函数调用时的临时变量。<br>\t\t每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。<br>\t<br>\t（2）在表达式求值中的应用：<br>\t\t编译器通两个栈来实现对表达式求值。一个栈保存操作数，另一个栈保存运算符。<br>\t\t从左向右遍历表达式，当遇到数字，就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。<br>\t\t如果比运算符栈顶元素的优先级高，就当将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取2个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。<br><br>\t（3）栈在括号匹配中的应用<br>\t\t用栈保存为匹配的左括号，从左到右一次扫描字符串，当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号，如果能匹配上，则继续扫描剩下的字符串。<br>如果扫描过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。<br>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明未匹配的左括号为非法格式。<br><br>\t（4）栈实现浏览器的前进和后退<br>\t\t使用两个栈X和Y，我们把首次浏览的页面依次压如栈X，当点击后退按钮时，再依次从栈X中出栈，并将出栈的数据一次放入Y栈<br>\t\t当点击前进按钮时，我们依次从栈Y中取出数据，放入栈X中。当栈X中没有数据时，说明没有页面可以继续后退浏览了。当Y栈没有数据，那就说明没有页面可以点击前进浏览了<br>","like_count":0},{"had_liked":false,"id":158247,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1575357497,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575357497","product_id":100017301,"comment_content":"栈: 后进先出or先进后出.<br><br>专栏内介绍的“栈”是一种数据结构, <br> “堆栈”说的是一种存储概念.  堆上分配独享,  引用存储在栈上等等.","like_count":0},{"had_liked":false,"id":158079,"user_name":"技术修行者","can_delete":false,"product_type":"c1","uid":1013147,"ip_address":"","ucode":"28CA41A1214D6B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/9b/611e74ab.jpg","comment_is_top":false,"comment_ctime":1575326912,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1575326912","product_id":100017301,"comment_content":"思维导图：https:&#47;&#47;mubu.com&#47;doc&#47;qrAS5BG_a0<br><br>思考题：<br>1. 是否采用栈，需要考虑使用场景是否有后进先出的需求，对于函数调用来说，在主函数中调用另外一个函数时，如果是在同一个线程内，那么主函数需要等待被调用函数执行完成返回结果后，才能继续执行，这时针对被调用函数的执行，就是一个后进先出的操作，所以用栈来管理就很合适。<br>2. JVM中的堆栈，和我们这里讲的堆栈不是一个概念。JVM的堆栈分为堆和栈两部分，我们在程序中定义的基本类型以及复杂类型的引用，存储在栈中，对于复杂类型本身，存储在堆中。存储在栈中的数据，我们对它访问时，并不会采取后进先出的方式。","like_count":0},{"had_liked":false,"id":157735,"user_name":"SteveYang","can_delete":false,"product_type":"c1","uid":1754829,"ip_address":"","ucode":"C42BCA4F40A9EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKCbnOvEatUN4ysE2cl6zJNoAJVXXuQVhicQ1jxh6Z2Towrmmc1I6PndaicuQQ0RyyJPyJQicv4tSib9Q/132","comment_is_top":false,"comment_ctime":1575251710,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575251710","product_id":100017301,"comment_content":"1.函数调用不一定非要用栈，但是使用栈我认为是最合适的。通常我们在选择一种数据结构不是因为非用不可而是因为它是最符合当下应用场景最合适的。<br>2.内存的栈是物理存在的，数据结构的栈是一种抽象数据类型，不过他们都拥有先进后出的特点。","like_count":0},{"had_liked":false,"id":157647,"user_name":"camel","can_delete":false,"product_type":"c1","uid":1117530,"ip_address":"","ucode":"D0D698CD74388F","user_header":"https://static001.geekbang.org/account/avatar/00/11/0d/5a/e60f4125.jpg","comment_is_top":false,"comment_ctime":1575220270,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575220270","product_id":100017301,"comment_content":"历史页面的前进后退最简单的实现应该是个数组实现的表或者双向链表。 用index控制当前页面左右移动，end控制终点。感觉作为栈的例子不太好。","like_count":0},{"had_liked":false,"id":157385,"user_name":"stanleyjobson","can_delete":false,"product_type":"c1","uid":1702255,"ip_address":"","ucode":"4CA84795F59339","user_header":"https://static001.geekbang.org/account/avatar/00/19/f9/6f/9c008ceb.jpg","comment_is_top":false,"comment_ctime":1575127328,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575127328","product_id":100017301,"comment_content":"我觉的 计算加减乘除的。那个图是不是有点问题，在弹出乘法后。不应该计算后面的加法吧。<br>应该是继续压入减法之后清空栈元素。之后求结果。","like_count":0},{"had_liked":false,"id":157235,"user_name":"big智慧","can_delete":false,"product_type":"c1","uid":1202616,"ip_address":"","ucode":"272C32E19EAE1A","user_header":"https://static001.geekbang.org/account/avatar/00/12/59/b8/2a4624c3.jpg","comment_is_top":false,"comment_ctime":1575093913,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575093913","product_id":100017301,"comment_content":"打卡Day6：<br>1、日期：<br>* 2019年11月30日<br><br>2、是什么<br>* 栈：“操作受限”的线性表结构，只能在一段做插入删除操作。典型结构是后进先出。<br><br>3、为什么<br>* 在适合使用栈结构的场景下，入栈、出栈的时间复杂度都是O(1)；<br>* 就算是需要动态扩容的栈只有在栈存满搬移时才会有最坏时间复杂度O(n)，均摊时间复杂度是O(1)。 <br>4、什么场景可以用<br>1. 函数调用栈，被调用的函数的变量需要先出栈； <br>2. 表达式求值，操作数和运算符分别入栈，通过运算符的优先级比较做计算 。 <br>5、怎么通过复盘文档，快速的总结近期团队的重点改进项<br>* 复盘文档的回顾，先找最近的复盘文档了解改进的内容，再往前追溯找团队总结出来的改进项，按时间从近到远找几篇就能总结出近期改进的重点，不需要找太久以前的文档。  <br>6、关注点：<br>* 后进先出，提高执行效率","like_count":0},{"had_liked":false,"id":157219,"user_name":"梦想的优惠券","can_delete":false,"product_type":"c1","uid":1257418,"ip_address":"","ucode":"D3B44F6C618CA7","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/ca/cbce6e94.jpg","comment_is_top":false,"comment_ctime":1575085898,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1575085898","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":157184,"user_name":"刘丶小备","can_delete":false,"product_type":"c1","uid":1102106,"ip_address":"","ucode":"F4D5EF592B7030","user_header":"https://static001.geekbang.org/account/avatar/00/10/d1/1a/3564c9da.jpg","comment_is_top":false,"comment_ctime":1575075708,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575075708","product_id":100017301,"comment_content":"思考题：<br>1.也可以用其他的数据结构，只要能保证每进入一个新的函数，都是一个新的作用域就可以。<br>2.JVM中的堆栈指的是真实的物理内存，而数据结构中说的是抽象的","like_count":0},{"had_liked":false,"id":156737,"user_name":"毛启圣","can_delete":false,"product_type":"c1","uid":1330056,"ip_address":"","ucode":"233DA95ED28C11","user_header":"https://static001.geekbang.org/account/avatar/00/14/4b/88/272b4562.jpg","comment_is_top":false,"comment_ctime":1574944504,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574944504","product_id":100017301,"comment_content":"是，方法栈","like_count":0},{"had_liked":false,"id":156494,"user_name":"大海","can_delete":false,"product_type":"c1","uid":1001446,"ip_address":"","ucode":"20913D0265971B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/47/e6/67b0b711.jpg","comment_is_top":false,"comment_ctime":1574902753,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574902753","product_id":100017301,"comment_content":"为什么要用栈来保存函数变量？<br>顺序运行的场景，很适合用栈来保存。","like_count":0},{"had_liked":false,"id":155783,"user_name":"蜗牛","can_delete":false,"product_type":"c1","uid":1236959,"ip_address":"","ucode":"B6E55FCD23ED68","user_header":"","comment_is_top":false,"comment_ctime":1574756327,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574756327","product_id":100017301,"comment_content":"从栈的实现可以看出，一种数据结构可以用另一种数据结构来实现，数据结构只是抽象出来的一种便于人理解的数据组织方式，具体的存储则是具体的算法来进行操作的。","like_count":0},{"had_liked":false,"id":155153,"user_name":"Ishmael","can_delete":false,"product_type":"c1","uid":1312115,"ip_address":"","ucode":"87CAF00A0BB25A","user_header":"https://static001.geekbang.org/account/avatar/00/14/05/73/89148275.jpg","comment_is_top":false,"comment_ctime":1574652773,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574652773","product_id":100017301,"comment_content":"函数调用需要返回值并且回到调用函数，运行方式是FILO，栈的结构刚好和函数调用类似 所以大多数语言的函数调用都是以方法栈的形式保存在内存中的","like_count":0},{"had_liked":false,"id":151340,"user_name":"握不住手中沙","can_delete":false,"product_type":"c1","uid":1097132,"ip_address":"","ucode":"F194E47C4D42C9","user_header":"https://static001.geekbang.org/account/avatar/00/10/bd/ac/49494ed8.jpg","comment_is_top":false,"comment_ctime":1573702644,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573702644","product_id":100017301,"comment_content":"思考题：<br>1、函数调用用“栈”来保存临时变量取决于函数调用过程中的数据的读取比较符合“栈”后进先出的特性，所以用栈这种数据结构来实现比较合理<br>2、JVM中的“栈”和现在所讲的“栈”不是同一个概念，数据结构中的栈指的是一种抽象的数据逻辑存储结构，而JVM中的栈则是真实的内存区，用于存放程序运行过程中的形参，临时变量等，只是JVM中栈的数据的逻辑存储结构采用的就是“栈”，适用后进先出的存取方式","like_count":0},{"had_liked":false,"id":150558,"user_name":"梨子苹果","can_delete":false,"product_type":"c1","uid":1716067,"ip_address":"","ucode":"3666813FEE31D3","user_header":"https://static001.geekbang.org/account/avatar/00/1a/2f/63/7a048d46.jpg","comment_is_top":false,"comment_ctime":1573556233,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573556233","product_id":100017301,"comment_content":"通过这个例子的实战分析，也印证了前面讲到的，均摊时间复杂度一般都等于最好情况时间复杂度。因为在大部分情况下，入栈操作的时间复杂度 O 都是 O(1)，只有在个别时刻才会退化为 O(n)，所以把耗时多的入栈操作的时间均摊到其他入栈操作上，平均情况下的耗时就接近 O(1)。 <br>什么时候是O(n)","like_count":0},{"had_liked":false,"id":150525,"user_name":"洺泽","can_delete":false,"product_type":"c1","uid":1641833,"ip_address":"","ucode":"22F7500E0167E5","user_header":"https://static001.geekbang.org/account/avatar/00/19/0d/69/7daf8113.jpg","comment_is_top":false,"comment_ctime":1573549235,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573549235","product_id":100017301,"comment_content":"我想请问一下：在单链表操作中，如何确定一个结点的前结点。假设当前结点为x，它的前结点为y<br>y.next=x与y=x有何区别  LeetCode  206题思考","like_count":0},{"had_liked":false,"id":149754,"user_name":"mrlay","can_delete":false,"product_type":"c1","uid":1041640,"ip_address":"","ucode":"385A1954ED3317","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e4/e8/a1703783.jpg","comment_is_top":false,"comment_ctime":1573366984,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573366984","product_id":100017301,"comment_content":"思考题二： 老师在题中剖析jvm栈的的功能时，已经表明今天所述的栈这种数据结构是可以用来实现这种功能的。所以我认为是一样的。 置顶的答案描述的是操作系统分配给一个进程的虚拟地址空间的组成部分， 里面存放的东西就被存放在被映射到实际的物理内存中。撇开虚拟地址空间，执行线程在进行函数调用局部变量存储等操作都是对一段 被映射为栈的内存块 进行的。 内存就是内存块，只是我们把它用来进行 栈 的操作而已。  综上 栈是抽象概念，我们只是把制定的内存块 按照栈这种逻辑进行使用了。（有点长😂）","like_count":0},{"had_liked":false,"id":149332,"user_name":"show me the code","can_delete":false,"product_type":"c1","uid":1716738,"ip_address":"","ucode":"CD9BA1A529B256","user_header":"https://static001.geekbang.org/account/avatar/00/1a/32/02/a5275b0e.jpg","comment_is_top":false,"comment_ctime":1573195095,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573195095","product_id":100017301,"comment_content":"表达式计算中，操作符栈中继续比较，并没有说，比较到什么时候为止呢，可以继续进行遍历？<br>分析了下，认为是操作符栈为空||数据栈为空||优先级更高，因为操作符比较只有两种情况：<br>1.表达式开始符号：按照习惯，第二个也应是符号，这时候数据栈为空，要继续遍历<br>2.表达式开始数据：按照习惯，第二个应该是符号，这种情况，数据栈中一直有数据，结束比较，只能是操作栈为空或优先级更高<br>如果分析不到位，欢迎大家指出","like_count":0},{"had_liked":false,"id":149023,"user_name":"即刻棒","can_delete":false,"product_type":"c1","uid":1647051,"ip_address":"","ucode":"767607BB43CDDF","user_header":"","comment_is_top":false,"comment_ctime":1573128514,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1573128514","product_id":100017301,"comment_content":"[疑惑] 对于“不管基于数组还是链表，入栈、出栈的时间复杂度都为 O(1)”这句话, 要是使用单链表的链式栈, 后进的元素放在链尾, 出入栈难道还是O(1)吗?","like_count":0,"discussions":[{"author":{"id":1069206,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/96/18612c89.jpg","nickname":"克","note":"","ucode":"6DDFBB05E0F4E9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":67534,"discussion_content":"那就使用双向链表喽\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575130642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146871,"user_name":"黄振宇","can_delete":false,"product_type":"c1","uid":1686397,"ip_address":"","ucode":"976BC7B46DA419","user_header":"https://static001.geekbang.org/account/avatar/00/19/bb/7d/26340713.jpg","comment_is_top":false,"comment_ctime":1572682466,"is_pvip":false,"replies":[{"id":"56797","content":"可以关注我的公号：小争哥","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1572823639,"ip_address":"","comment_id":146871,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572682466","product_id":100017301,"comment_content":"又花了几天搞完了基于链表和动态数组实现的栈功能，又模拟了一个可前进后退的浏览器。。。每天很痛苦，但很充实。很感谢王争老师，老师啥时候分享一下如何才能进谷歌啊！哈哈","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473040,"discussion_content":"可以关注我的公号：小争哥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572823639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146767,"user_name":"张飞online","can_delete":false,"product_type":"c1","uid":1249136,"ip_address":"","ucode":"C9787E4B35888C","user_header":"https://static001.geekbang.org/account/avatar/00/13/0f/70/759b1567.jpg","comment_is_top":false,"comment_ctime":1572653171,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572653171","product_id":100017301,"comment_content":"扩大理解，都是说的一种东西，无论内存栈还是我们现在的数据结构，都是先进后出","like_count":0},{"had_liked":false,"id":146411,"user_name":"zebra","can_delete":false,"product_type":"c1","uid":1677869,"ip_address":"","ucode":"2C59753628EAB1","user_header":"https://static001.geekbang.org/account/avatar/00/19/9a/2d/7c6a9925.jpg","comment_is_top":false,"comment_ctime":1572514857,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572514857","product_id":100017301,"comment_content":"课后思考:为什么函数调用要用“栈”来保存临时变量呢？<br>在函数执行中，函数的嵌套调用是按“后调用先返回”的规则进行，这种规则符合栈的使用模式，因此栈可以很自然地支持函数调用的实现。<br>","like_count":0},{"had_liked":false,"id":146408,"user_name":"zebra","can_delete":false,"product_type":"c1","uid":1677869,"ip_address":"","ucode":"2C59753628EAB1","user_header":"https://static001.geekbang.org/account/avatar/00/19/9a/2d/7c6a9925.jpg","comment_is_top":false,"comment_ctime":1572514728,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572514728","product_id":100017301,"comment_content":"课后思考:我们在讲栈的应用时，讲到用函数调用栈来保存临时变量，为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？","like_count":0},{"had_liked":false,"id":145052,"user_name":"yin","can_delete":false,"product_type":"c1","uid":1711450,"ip_address":"","ucode":"9F3D55A1D435A2","user_header":"https://static001.geekbang.org/account/avatar/00/1a/1d/5a/937f0d4c.jpg","comment_is_top":false,"comment_ctime":1572172544,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572172544","product_id":100017301,"comment_content":"留言和内容一样精彩","like_count":0},{"had_liked":false,"id":144325,"user_name":"有福","can_delete":false,"product_type":"c1","uid":1045377,"ip_address":"","ucode":"3DEAB5CEBE0F85","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f3/81/42e29d40.jpg","comment_is_top":false,"comment_ctime":1571898172,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571898172","product_id":100017301,"comment_content":"内存中堆栈区的「栈」主要用来保存临时变量和函数的调用过程，因为对这块内存的操作符合「栈」这种数据结构，所以也被成为「栈」，本质上都是一块后进先出的内存。<br>至于为啥用栈来实现函数调用，主要是这种方式最快，对变量的操作只需要两个最简单的操作，push和pop就可以完成。","like_count":0},{"had_liked":false,"id":143432,"user_name":"绅士","can_delete":false,"product_type":"c1","uid":1583859,"ip_address":"","ucode":"5B58E5A958F489","user_header":"https://static001.geekbang.org/account/avatar/00/18/2a/f3/b9607a15.jpg","comment_is_top":false,"comment_ctime":1571708235,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571708235","product_id":100017301,"comment_content":"已经是二刷了，第一遍脑海里有了个大概，这一遍一定要再细看，勤动手，还有极客的代码有颜色了呢","like_count":0},{"had_liked":false,"id":142520,"user_name":"学个球","can_delete":false,"product_type":"c1","uid":1019725,"ip_address":"","ucode":"7343F3C0CA981D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8f/4d/65fb45e6.jpg","comment_is_top":false,"comment_ctime":1571386665,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1571386665","product_id":100017301,"comment_content":"对于本节摊还分析法<br>其中的数据搬移和simple-push入栈操作是什么意思？<br>我的理解是：数据搬移的时候需要暂时申请空间，然后依次把搬移出来的数据simple-push到新开的栈中吗？","like_count":0,"discussions":[{"author":{"id":1019725,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8f/4d/65fb45e6.jpg","nickname":"学个球","note":"","ucode":"7343F3C0CA981D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":36510,"discussion_content":"想了一下，应该需要一个额外的中转“栈”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571386934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140444,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1570944394,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570944394","product_id":100017301,"comment_content":"VSCode里的Python Preview 插件很方便可以预览函数的调用栈图，分析起来很直观。","like_count":0},{"had_liked":false,"id":138184,"user_name":"Lance","can_delete":false,"product_type":"c1","uid":1686840,"ip_address":"","ucode":"CCE52F86EEBBED","user_header":"https://static001.geekbang.org/account/avatar/00/19/bd/38/6d436088.jpg","comment_is_top":false,"comment_ctime":1570087545,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570087545","product_id":100017301,"comment_content":"操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。<br><br>栈的应用：<br>1.函数调用栈，每个函数中的临时变量作为一个栈帧入栈出栈；<br>2.表达式求值，利用操作数栈与运算符栈来处理计算过程；<br>3.括号匹配，将左括号入栈，扫描到右括号时取出栈顶左括号进行匹配，直至结束；<br>4.实现浏览器前进后退功能；<br>","like_count":0},{"had_liked":false,"id":137905,"user_name":"姜川","can_delete":false,"product_type":"c1","uid":1684311,"ip_address":"","ucode":"0F8A349623EAB5","user_header":"https://static001.geekbang.org/account/avatar/00/19/b3/57/2d92cf9a.jpg","comment_is_top":false,"comment_ctime":1569913360,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569913360","product_id":100017301,"comment_content":"看了栈之后，翻了一下java中的Stack类，发现是用数组实现的","like_count":0},{"had_liked":false,"id":134864,"user_name":"王加武","can_delete":false,"product_type":"c1","uid":1665471,"ip_address":"","ucode":"DDCFE578C6C428","user_header":"https://static001.geekbang.org/account/avatar/00/19/69/bf/50a824a4.jpg","comment_is_top":false,"comment_ctime":1568943959,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568943959","product_id":100017301,"comment_content":"jvm中的堆栈和数据结构中的堆栈不是一回事，<br>jvm中的堆栈是内存的区域<br>数据结构中的堆栈是抽象的数据存储结构","like_count":0},{"had_liked":false,"id":133865,"user_name":"David","can_delete":false,"product_type":"c1","uid":1023472,"ip_address":"","ucode":"1C76747719CD3B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9d/f0/6c34b90f.jpg","comment_is_top":false,"comment_ctime":1568685897,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568685897","product_id":100017301,"comment_content":"1.函数调用遵循后进先出的原则<br>2.不是，jvm线程栈，存储当前线程操作的局部变量，操作数等","like_count":0},{"had_liked":false,"id":132511,"user_name":"业余爱好者","can_delete":false,"product_type":"c1","uid":1482915,"ip_address":"","ucode":"A890935A982988","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","comment_is_top":false,"comment_ctime":1568159037,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568159037","product_id":100017301,"comment_content":"1.函数调用展开的顺序与之后执行返回的顺序刚好相反，符合栈后进先出的特性，所以用栈比较合适。<br><br>2.栈是一种数据结构，而jvm中的栈是一块内存区域，其底层的是用栈这种数据结构实现的。","like_count":0},{"had_liked":false,"id":132264,"user_name":"胡永","can_delete":false,"product_type":"c1","uid":1200543,"ip_address":"","ucode":"6C8BA1E0BED9C0","user_header":"https://static001.geekbang.org/account/avatar/00/12/51/9f/1840385e.jpg","comment_is_top":false,"comment_ctime":1568075612,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568075612","product_id":100017301,"comment_content":"均摊复杂度分析还是要再理解下，自己对于这次的应用不熟练，动态扩容的栈需要好好分析一下","like_count":0},{"had_liked":false,"id":126747,"user_name":"阿木木","can_delete":false,"product_type":"c1","uid":1097540,"ip_address":"","ucode":"20AB6A00EAAFB1","user_header":"https://static001.geekbang.org/account/avatar/00/10/bf/44/a8a89579.jpg","comment_is_top":false,"comment_ctime":1566463568,"is_pvip":false,"replies":[{"id":"47243","content":"自己上网搜搜，一艘一大把，我留言不好回复你很麻烦~","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1566773902,"ip_address":"","comment_id":126747,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566463568","product_id":100017301,"comment_content":"（3+5）*8-6 这种的运算符操作，栈是怎么实现的呢？<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464146,"discussion_content":"自己上网搜搜，一艘一大把，我留言不好回复你很麻烦~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566773902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126447,"user_name":"胖头小C","can_delete":false,"product_type":"c1","uid":1499881,"ip_address":"","ucode":"1C6A67FCDED740","user_header":"https://static001.geekbang.org/account/avatar/00/16/e2/e9/5be2a24c.jpg","comment_is_top":false,"comment_ctime":1566387409,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566387409","product_id":100017301,"comment_content":"函数为什么使用栈，其中一点就是函数的嵌套调用吧，用栈实现很简洁","like_count":0},{"had_liked":false,"id":124424,"user_name":"bodhi","can_delete":false,"product_type":"c1","uid":1599390,"ip_address":"","ucode":"C7B5F763FF7D9D","user_header":"https://static001.geekbang.org/account/avatar/00/18/67/9e/5aecee10.jpg","comment_is_top":false,"comment_ctime":1565881271,"is_pvip":false,"replies":[{"id":"45678","content":"leetcode上","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1565906750,"ip_address":"","comment_id":124424,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565881271","product_id":100017301,"comment_content":"问一下，算法题去哪里找呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463167,"discussion_content":"leetcode上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565906750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121609,"user_name":"菜鸟程序媛","can_delete":false,"product_type":"c1","uid":1282788,"ip_address":"","ucode":"BB1038F8D3FAE5","user_header":"https://static001.geekbang.org/account/avatar/00/13/92/e4/7d355bbb.jpg","comment_is_top":false,"comment_ctime":1565166597,"is_pvip":false,"replies":[{"id":"44740","content":"线程有独立分配栈空间的。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1565220210,"ip_address":"","comment_id":121609,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565166597","product_id":100017301,"comment_content":"“操作系统给每个线程分配了一块独立的内存空间”？没理解这句话。操作系统不是给进程分配的内存空间么？一个进程里有多个线程共享这些空间","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461877,"discussion_content":"线程有独立分配栈空间的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565220210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117036,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1563957949,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563957949","product_id":100017301,"comment_content":"栈的这种后进先出的结构在一定程度上会提供一些缓存的友好型，即刚在堆顶插入的元素往往还在缓存中。<br>一个前进栈+一个后退栈实现浏览器的前进和后退让我想到了一个大顶堆+一个小顶堆实现百分位数的计算，同一个数据结构的组合使用在一些场景下也能起到意想不到的效果。","like_count":0},{"had_liked":false,"id":116369,"user_name":"ffflag","can_delete":false,"product_type":"c1","uid":1610605,"ip_address":"","ucode":"CE8180ED7BDDAE","user_header":"https://static001.geekbang.org/account/avatar/00/18/93/6d/04c4dd7b.jpg","comment_is_top":false,"comment_ctime":1563844507,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563844507","product_id":100017301,"comment_content":"调用栈来保存临时变量，是因为时间复杂度很低，可以快速读取。","like_count":0},{"had_liked":false,"id":115411,"user_name":"星辰大海","can_delete":false,"product_type":"c1","uid":1265881,"ip_address":"","ucode":"6A1134533337FA","user_header":"https://static001.geekbang.org/account/avatar/00/13/50/d9/18acc2ee.jpg","comment_is_top":false,"comment_ctime":1563583788,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563583788","product_id":100017301,"comment_content":"JVM中的栈可以理解为抽象数据结构中的栈 在内存层面的一个具体实现 体现了函数调用先进后出的特性 究其本质还是一样的 用栈来命名简单粗暴 清晰易懂","like_count":0},{"had_liked":false,"id":113409,"user_name":"Dong","can_delete":false,"product_type":"c1","uid":1604161,"ip_address":"","ucode":"5EB1164D31D2D4","user_header":"https://static001.geekbang.org/account/avatar/00/18/7a/41/1daf3f10.jpg","comment_is_top":false,"comment_ctime":1562999501,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562999501","product_id":100017301,"comment_content":"JVM中的栈分为虚拟机栈和本地方法栈，虚拟机栈可以理解为我们平时说的栈，每个方法执行是时候JVM都会给它分配一个栈帧，用来存储私有变量。堆是存放对象的地方，是线程共享的。","like_count":0},{"had_liked":false,"id":113399,"user_name":"Geek_b08f4c","can_delete":false,"product_type":"c1","uid":1600026,"ip_address":"","ucode":"D200278C5BFC8A","user_header":"","comment_is_top":false,"comment_ctime":1562994390,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562994390","product_id":100017301,"comment_content":"只是栈很符合函数调用的嵌套特点，LIFO. 如果有足够多的寄存器可以用，也不用放到内存上存，就算再内存上，也可以使用其他结构实现LIFO的特性，只是代价没有stack小。","like_count":0},{"had_liked":false,"id":110445,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1562278320,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562278320","product_id":100017301,"comment_content":"函数调用存在嵌套结构，这种嵌套结构使得后调用的函数先返回，就形成了后进先出的顺序，解决这种顺序，栈是不二人选。","like_count":0},{"had_liked":false,"id":109791,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1562114912,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562114912","product_id":100017301,"comment_content":"我在别的地方看到一个比较形象的形容栈的例子：弹夹。","like_count":0},{"had_liked":false,"id":109387,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1562029105,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562029105","product_id":100017301,"comment_content":"打卡！仿佛记得一年前看过这里。。。","like_count":0},{"had_liked":false,"id":108251,"user_name":"大熊","can_delete":false,"product_type":"c1","uid":1187122,"ip_address":"","ucode":"8163EC5BC6A519","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/32/005c7ba4.jpg","comment_is_top":false,"comment_ctime":1561705378,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561705378","product_id":100017301,"comment_content":"配合LeetCode的题目，学习效果更好呀~","like_count":0},{"had_liked":false,"id":105482,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1561012978,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561012978","product_id":100017301,"comment_content":"特定数据结构是特定应用场景的抽象，应当根据特定应用场景提供特定的抽象描述与操作。<br>栈的分类：顺序栈和链式栈<br>栈的push和pop的时间复杂度：O(1)<br>栈的push和pop的空间复杂度：O(1)<br>可扩容栈的平均时空复杂度同普通栈（摊还分析）<br>栈的应用：函数调用；表达式求值；括号匹配；浏览器前进和后退<br>为何函数调用要采用栈这种数据结构？<br>函数调用时作用域会发生变化，而栈这种后进先出的数据结构能很好地完成作用域的转化。","like_count":0},{"had_liked":false,"id":104943,"user_name":"小白菜","can_delete":false,"product_type":"c1","uid":1568340,"ip_address":"","ucode":"ACD1267D329B96","user_header":"https://static001.geekbang.org/account/avatar/00/17/ee/54/dac0a6b6.jpg","comment_is_top":false,"comment_ctime":1560876409,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560876409","product_id":100017301,"comment_content":"老师您好，请问调用函数栈下面的代码自己运行出错，需要怎么解决啊？谢谢老师！","like_count":0},{"had_liked":false,"id":104489,"user_name":"时光剪影","can_delete":false,"product_type":"c1","uid":1093159,"ip_address":"","ucode":"CC6F24C30AE3E6","user_header":"https://static001.geekbang.org/account/avatar/00/10/ae/27/3dfcc699.jpg","comment_is_top":false,"comment_ctime":1560764007,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560764007","product_id":100017301,"comment_content":"栈是先进后出的线性表，在栈顶执行插入O(1)和删除O(1)。<br><br>栈有两种实现方式：<br>数组方式，称为顺序表，比如vector的底层就是使用数组实现栈<br>链表方式，称为链式表<br><br>空间复杂度的定义：<br>除了存储数据的原本空间外，算法运行还需要的额外的存储空间<br><br>栈的应用：<br>函数调用，表达式求值，括号匹配等等<br>","like_count":0},{"had_liked":false,"id":104250,"user_name":"上善若水","can_delete":false,"product_type":"c1","uid":1565462,"ip_address":"","ucode":"7E783812D2D164","user_header":"https://static001.geekbang.org/account/avatar/00/17/e3/16/0e476be6.jpg","comment_is_top":false,"comment_ctime":1560698066,"is_pvip":false,"replies":[{"id":"38008","content":"不是，是浏览器本身的功能就是这么设计的。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560900216,"ip_address":"","comment_id":104250,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560698066","product_id":100017301,"comment_content":"浏览器打开abcd页面，退到c再打开新的c就不能前进到d页面了。请问老师，是因为是是用链表实现的栈，c指向新的cc就成尾节点的原因吗","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454187,"discussion_content":"不是，是浏览器本身的功能就是这么设计的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560900216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103332,"user_name":"小小征","can_delete":false,"product_type":"c1","uid":1358930,"ip_address":"","ucode":"335380EFE0FC61","user_header":"https://static001.geekbang.org/account/avatar/00/14/bc/52/52745d32.jpg","comment_is_top":false,"comment_ctime":1560415767,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560415767","product_id":100017301,"comment_content":"老师 思考题的答案感觉好抽象，感觉有点理解不太明白。。。","like_count":0},{"had_liked":false,"id":99685,"user_name":"karas","can_delete":false,"product_type":"c1","uid":1349594,"ip_address":"","ucode":"836873D0D9973B","user_header":"https://static001.geekbang.org/account/avatar/00/14/97/da/ae765e15.jpg","comment_is_top":false,"comment_ctime":1559279739,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559279739","product_id":100017301,"comment_content":"根据小争哥的关于双栈实现简易计算器的描述的实现，只是简单地测试<br>https:&#47;&#47;github.com&#47;dangshanli&#47;effective-java&#47;blob&#47;master&#47;algorithms&#47;src&#47;main&#47;java&#47;jeektime&#47;SimpleCalculate.java<br>第一次写，有时间请帮忙review一下@王争","like_count":0},{"had_liked":false,"id":99350,"user_name":"karas","can_delete":false,"product_type":"c1","uid":1349594,"ip_address":"","ucode":"836873D0D9973B","user_header":"https://static001.geekbang.org/account/avatar/00/14/97/da/ae765e15.jpg","comment_is_top":false,"comment_ctime":1559198337,"is_pvip":false,"replies":[{"id":"35765","content":"不同语言都不同，你可以看下这篇文章的介绍<br>https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;E-c41h2v_AfffrlAQpkyLg","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559257939,"ip_address":"","comment_id":99350,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559198337","product_id":100017301,"comment_content":"对象成员变量的引用存在哪？也在栈区？<br><br>基本类型的值放在哪？放在栈区还是堆区？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452071,"discussion_content":"不同语言都不同，你可以看下这篇文章的介绍\nhttps://mp.weixin.qq.com/s/E-c41h2v_AfffrlAQpkyLg","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559257939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99237,"user_name":"areadrom","can_delete":false,"product_type":"c1","uid":1252081,"ip_address":"","ucode":"A54CE71DB34CC8","user_header":"https://static001.geekbang.org/account/avatar/00/13/1a/f1/ce6af893.jpg","comment_is_top":false,"comment_ctime":1559180526,"is_pvip":false,"replies":[{"id":"36271","content":"那就是O(2)哈，但是O(2)也等于O(1)，所以就是O(1)了。别砸手机了，砸了也没用啊。慢慢来，都有这个过程的。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559612628,"ip_address":"","comment_id":99237,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1559180526","product_id":100017301,"comment_content":"将 K 个数据搬移均摊到 K 次入栈操作，那每个入栈操作只需要一个数据搬移和一个 simple-push 操作。以此类推，入栈操作的均摊时间复杂度就为 O(1)。<br>----------------------------------------<br>请问上文定义的是不涉及内存搬移操作的时间复杂度是O(1)，这里又说每个入栈操作只要一个数据搬移和一个simple-push 操作，怎么可能均摊复杂度就是O(1)了？这一段真的是把我搞糊涂了，真是想砸了手机","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452030,"discussion_content":"那就是O(2)哈，但是O(2)也等于O(1)，所以就是O(1)了。别砸手机了，砸了也没用啊。慢慢来，都有这个过程的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559612628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1122121,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1f/49/e4ab004b.jpg","nickname":"波拉拉","note":"","ucode":"586F66351219E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1215,"discussion_content":"终于有人对均摊时间的计算提出疑问了。。。\n“那就是O(2)哈，但是O(2)也等于O(1)，所以就是O(1)了”请问老师，这句话意思是时间复杂度是常数，所以O(2)也等于O(1)？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562406655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97664,"user_name":"Tree","can_delete":false,"product_type":"c1","uid":1064664,"ip_address":"","ucode":"F53C863FF9159C","user_header":"https://static001.geekbang.org/account/avatar/00/10/3e/d8/8608ec03.jpg","comment_is_top":false,"comment_ctime":1558745346,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558745346","product_id":100017301,"comment_content":"我觉得函数调用来说主函数调用了被调用函数那么要等被调用函数执行后才能返回主函数，并让主函数继续执行也就是说调用顺序是主函数-&gt;调用函数。但是计算机执行的时候其实是先执行完被调用函数在执行主函数。满足先进后出的特性。所以用栈来存储临时变量。至于jvm的栈我认为本质上还是栈。jvm栈中的每一个元素叫栈帧存储的是所属线程的临时变量。也是先进后出的。所以就是栈的数据结构。","like_count":0},{"had_liked":false,"id":97364,"user_name":"sunsweet","can_delete":false,"product_type":"c1","uid":1027879,"ip_address":"","ucode":"787F9E1EC6A67E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/af/27/76489618.jpg","comment_is_top":false,"comment_ctime":1558660386,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558660386","product_id":100017301,"comment_content":"刚才我想的太简单了，还是栈比较像，没考虑到添加节点","like_count":0},{"had_liked":false,"id":97358,"user_name":"sunsweet","can_delete":false,"product_type":"c1","uid":1027879,"ip_address":"","ucode":"787F9E1EC6A67E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/af/27/76489618.jpg","comment_is_top":false,"comment_ctime":1558660243,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558660243","product_id":100017301,"comment_content":"我感觉浏览器这个更像链表，两个指针对应前进后退一起访问相邻的节点，当前进遇到尾部哨兵就变灰，后退遇到头部哨兵就变灰😂","like_count":0},{"had_liked":false,"id":97271,"user_name":"sunsweet","can_delete":false,"product_type":"c1","uid":1027879,"ip_address":"","ucode":"787F9E1EC6A67E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/af/27/76489618.jpg","comment_is_top":false,"comment_ctime":1558625068,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558625068","product_id":100017301,"comment_content":"因为CPU有push和pop为什么不用呢😂","like_count":0},{"had_liked":false,"id":97087,"user_name":"zyj","can_delete":false,"product_type":"c1","uid":1256408,"ip_address":"","ucode":"A29645B4FB6886","user_header":"https://static001.geekbang.org/account/avatar/00/13/2b/d8/06e83d3d.jpg","comment_is_top":false,"comment_ctime":1558584217,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1558584217","product_id":100017301,"comment_content":"回文判断可以用两个栈完成。就和判断配对一样。","like_count":0},{"had_liked":false,"id":91029,"user_name":"短迪大魔王","can_delete":false,"product_type":"c1","uid":1236079,"ip_address":"","ucode":"37E8117E0495B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/dc/6f/5d86dbe9.jpg","comment_is_top":false,"comment_ctime":1556808002,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556808002","product_id":100017301,"comment_content":"开始觉得说刷新的时候c就没了不太清楚，看了说有人用双向列表，我才发现，浏览器上的前进后退不是线性结构，可能是树结构。所以因为意外浏览器崩溃再重启就都能出来，应该是树。这里简化退化成栈，也正好是先进先出有顺序的","like_count":0},{"had_liked":false,"id":90927,"user_name":"黑洞","can_delete":false,"product_type":"c1","uid":1451364,"ip_address":"","ucode":"840A4330B1B2F0","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/64/d66ea739.jpg","comment_is_top":false,"comment_ctime":1556729298,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556729298","product_id":100017301,"comment_content":"函数内部的临时变量、指针、引用等本身会随着它们所处语句块的不同而有不同的作用域，特别是嵌套的作用域内，临时变量产生和失效的规律和堆栈的操作特点很一致，所以就按照堆栈或者说利用棧区来存储临时变量，是最自然，最优的设计。","like_count":0},{"had_liked":false,"id":89534,"user_name":"noobcoder","can_delete":false,"product_type":"c1","uid":1513545,"ip_address":"","ucode":"B956F4C23671BB","user_header":"https://static001.geekbang.org/account/avatar/00/17/18/49/05544d79.jpg","comment_is_top":false,"comment_ctime":1556199261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556199261","product_id":100017301,"comment_content":"栈操作，更多的是在内存堆积后，一定的取用方式，如果你从头取就是栈了，能够抽象出栈我们就可以更好的操作类似的数据结构","like_count":0},{"had_liked":false,"id":87371,"user_name":"ONENESS2019","can_delete":false,"product_type":"c1","uid":1501620,"ip_address":"","ucode":"F8CCF2118B29D7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/UyjYSHTkMsqodhBJlbzL01Y3tRklSQzleSRbWvwZcYdTdGiczJEJT8dbTfrmcTFicEhMIEaSaeN4zCjNP1WUG2fg/132","comment_is_top":false,"comment_ctime":1555578725,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555578725","product_id":100017301,"comment_content":"入栈的时间复杂度那张图是不是有错呢？如果当前栈大小为k, 扩容为2*k并搬移k个数据之后，应该有k次入栈操作才对呀。","like_count":0},{"had_liked":false,"id":86992,"user_name":"王玄","can_delete":false,"product_type":"c1","uid":1394410,"ip_address":"","ucode":"E54ABB340D1E49","user_header":"https://static001.geekbang.org/account/avatar/00/15/46/ea/b86667b8.jpg","comment_is_top":false,"comment_ctime":1555493395,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555493395","product_id":100017301,"comment_content":"        function ArrayStack(length) {<br>            this.container = Object.create(null, []); &#47;&#47; 创建一个纯净的数组<br>            this.container.length = length;<br>            this.count = 0;<br>        }<br><br>        const arr = new ArrayStack(10);<br><br>        ArrayStack.prototype.push = function(ele) {<br>            if (this.count === this.container.length) {<br>                console.log(&#39;空间不足&#39;);<br>                return false;<br>            }<br>            this.container[this.count] = ele;<br>            this.count++;<br>            console.log(&#39;成功添加&#39;);<br>            return true;<br>        }<br><br>        ArrayStack.prototype.pop = function() {<br>            if (this.count === 0) {<br>                console.log(&#39;无数据,操作失败&#39;);<br>                return null;<br>            }<br>            const tmp = this.container[this.count - 1];<br>            this.container[this.count - 1] = null;<br>            this.count--;<br>            return tmp;<br>        }<br><br>        arr.pop();","like_count":0},{"had_liked":false,"id":86488,"user_name":"ThinkingMan.","can_delete":false,"product_type":"c1","uid":1217603,"ip_address":"","ucode":"722674A8BACA85","user_header":"https://static001.geekbang.org/account/avatar/00/12/94/43/6e68c860.jpg","comment_is_top":false,"comment_ctime":1555381925,"is_pvip":false,"replies":[{"id":"31226","content":"哈哈，因为扩容的那次操作也插入了数据。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1555469285,"ip_address":"","comment_id":86488,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1555381925","product_id":100017301,"comment_content":"请问老师，扩容那里，为什么接下来是k-1次操作呢，不应该是k次吗？谢谢老师","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447036,"discussion_content":"哈哈，因为扩容的那次操作也插入了数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555469285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1122121,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1f/49/e4ab004b.jpg","nickname":"波拉拉","note":"","ucode":"586F66351219E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1216,"discussion_content":"扩容怎么插入数据？！。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562406855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1238051,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/23/ac13d916.jpg","nickname":"圆哥哥呐丶","note":"","ucode":"8E56E3E68A3836","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1122121,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1f/49/e4ab004b.jpg","nickname":"波拉拉","note":"","ucode":"586F66351219E8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4157,"discussion_content":"你仔细看看老师说的，[接下来的 K-1 次入栈操作，我们都不需要再重新申请内存]     ，它说的k-1次操作 是说这些操作不需要重新申请内存的操作。  而当你的数组k已经满了之后，再进来的一次操作 是需要申请扩容的，所以 这一次操作不在k-1里面。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565172637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":1216,"ip_address":""},"score":4157,"extra":""}]}]},{"had_liked":false,"id":86304,"user_name":"jacy","can_delete":false,"product_type":"c1","uid":1103456,"ip_address":"","ucode":"0022A8759DDCE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/60/f21b2164.jpg","comment_is_top":false,"comment_ctime":1555342357,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1555342357","product_id":100017301,"comment_content":"1.栈这种结构很适合层次调用，如函数嵌套。<br>2.虚拟机栈是临时的分配，每个线程都会有一个jvm栈，jvm栈上也有应用栈。","like_count":0},{"had_liked":false,"id":85058,"user_name":"twoplus","can_delete":false,"product_type":"c1","uid":1302298,"ip_address":"","ucode":"F1C527B2334F56","user_header":"https://static001.geekbang.org/account/avatar/00/13/df/1a/c8f52d84.jpg","comment_is_top":false,"comment_ctime":1554968880,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554968880","product_id":100017301,"comment_content":"用栈来检测括号匹配让我想到了 栈其实是个偶数回文检测器，不过时间复杂度是O(n) 不是最好的办法","like_count":0},{"had_liked":false,"id":84310,"user_name":"1KunPuu","can_delete":false,"product_type":"c1","uid":1364982,"ip_address":"","ucode":"9AE2F6A0A06EBC","user_header":"https://static001.geekbang.org/account/avatar/00/14/d3/f6/7c58eddb.jpg","comment_is_top":false,"comment_ctime":1554824411,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554824411","product_id":100017301,"comment_content":"new出的对象引用不一定在栈中吧?引用如果是静态的，就是类的元数据，随类放在元空间。如果是普通变量就随类的实例放在堆中。所以很难确定说引用变量一定在栈中。","like_count":0},{"had_liked":false,"id":81282,"user_name":"笙南","can_delete":false,"product_type":"c1","uid":1218163,"ip_address":"","ucode":"39F2B7F155EAEF","user_header":"https://static001.geekbang.org/account/avatar/00/12/96/73/b5158f6c.jpg","comment_is_top":false,"comment_ctime":1553848531,"is_pvip":false,"replies":[{"id":"29478","content":"都可以的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1553858385,"ip_address":"","comment_id":81282,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553848531","product_id":100017301,"comment_content":"王争老师你好，我手动练习了一下您写的基于数组实现的顺序栈代码，其中的 ++count 我换成 count++，发现也可以走得通，请问老师对 ++ 在本段代码里到底放在前面和后面这个有什么意见吗？还是在这里都可以呀？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445139,"discussion_content":"都可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553858385,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81190,"user_name":"ggsk","can_delete":false,"product_type":"c1","uid":1450435,"ip_address":"","ucode":"83D63303FEF7EA","user_header":"https://static001.geekbang.org/account/avatar/00/16/21/c3/98708266.jpg","comment_is_top":false,"comment_ctime":1553827715,"is_pvip":false,"replies":[{"id":"29629","content":"你说的没错。原数组空间回收，数据copy到新数组空间中。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1554031397,"ip_address":"","comment_id":81190,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553827715","product_id":100017301,"comment_content":"有个关于空间的问题请大神指导，就是如果是基于数组实现可以动态扩展的栈结构，被扩展了几次后，把里面的内容全部出栈，那么要考虑被扩展出来的空间的回收问题么？如果回收空间，那是不是还是用复制到一个新数组的方法？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445111,"discussion_content":"你说的没错。原数组空间回收，数据copy到新数组空间中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554031397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79992,"user_name":"子夜天不在","can_delete":false,"product_type":"c1","uid":1301289,"ip_address":"","ucode":"FDB6DF0AA733A4","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/29/8ef0b74b.jpg","comment_is_top":false,"comment_ctime":1553589652,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553589652","product_id":100017301,"comment_content":"function ArrayStack() {<br>    this.store = [];<br>}<br><br>&#47;&#47; 进栈<br>ArrayStack.prototype.push = function(item) {<br>    this.store.push(item)<br>}<br><br>&#47;&#47; 出栈<br>ArrayStack.prototype.pop = function() {<br>    return this.store.pop()<br>}<br><br>&#47;&#47; 清栈<br>ArrayStack.prototype.clear = function() {<br>    this.store = [];<br>}<br><br>&#47;&#47; 获取栈顶元素<br>ArrayStack.prototype.top = function() {<br>    return this.store[this.store.length - 1];<br>}<br><br>function Browser() {<br>    this.history = new ArrayStack();<br>    this.history_forword = new ArrayStack();<br>    this.current_page = null; <br>}<br><br>&#47;&#47; 回退<br>Browser.prototype.back = function () {<br>    var record = this.history.pop();<br>    this.history_forword.push(record);<br>    this.current_page = this.history.top();<br>}<br><br>&#47;&#47; 前进<br>Browser.prototype.forword = function () {<br>    var record = this.history_forword.pop();<br>    this.history.push(record);<br>    this.current_page = this.history.top();<br>}<br><br>&#47;&#47; 加载新页面<br>Browser.prototype.loadNewPage = function (url) {<br>    this.history.push(url);<br>    this.history_forword.clear();<br>    this.current_page = this.history.top();<br>}<br>javascript实现大概是这样吧，有问题希望大家多多指教","like_count":0},{"had_liked":false,"id":79854,"user_name":"A-Zhao-刚","can_delete":false,"product_type":"c1","uid":1455934,"ip_address":"","ucode":"E3DCEF47D962EB","user_header":"https://static001.geekbang.org/account/avatar/00/16/37/3e/ae3f65db.jpg","comment_is_top":false,"comment_ctime":1553564090,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553564090","product_id":100017301,"comment_content":"栈就操作性质来讲是一种‘操作受限’的线性表，它的特点是先进后出，只能在一端插入和删除数据。粘既可以通过链表来实现，也可以通过数据来实现，无论那种方法时间复杂度都是O（1）。栈的应用：1.函数的调用，2.表达式求值，3.括号匹配。","like_count":0},{"had_liked":false,"id":79672,"user_name":"Geek_8cf9dd","can_delete":false,"product_type":"c1","uid":1333611,"ip_address":"","ucode":"F64BB2A317017C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKicUXKVXIQAmToH3CkpQGjjDHRGSh0RjBpUf82r9WibfrrJMHxZXcuNVgCy8icpI9Mo4He8umCspDDA/132","comment_is_top":false,"comment_ctime":1553518686,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553518686","product_id":100017301,"comment_content":"老师画的运算符+-入栈和出栈没太看懂","like_count":0},{"had_liked":false,"id":78895,"user_name":"平头百姓","can_delete":false,"product_type":"c1","uid":1058387,"ip_address":"","ucode":"6FC95F6AA694A8","user_header":"https://static001.geekbang.org/account/avatar/00/10/26/53/e853e01c.jpg","comment_is_top":false,"comment_ctime":1553270890,"is_pvip":false,"replies":[{"id":"28849","content":"是的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1553386583,"ip_address":"","comment_id":78895,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553270890","product_id":100017301,"comment_content":"入栈和出栈，也就是在栈顶插入一个数据和从栈顶删除一个数据。<br>入栈和出栈都是栈顶?","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444278,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553386583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76332,"user_name":"imsorry","can_delete":false,"product_type":"c1","uid":1316930,"ip_address":"","ucode":"7686DACC7B3356","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqSpE7I3EqGFuvHCGFa0YTOpPW9lWSm0qmcheJ4KwkLHUK5X2O13RBDPtEoYQe0WMialuSQAwQIichg/132","comment_is_top":false,"comment_ctime":1552573353,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552573353","product_id":100017301,"comment_content":"JVM栈又称线程栈，线程内每个方法的嵌套调用会形成栈帧，方法调用返回后释放被调用方法的栈帧内存(垃圾回收)，行为类似于操作系统的TSS中的用户栈或内核栈，需要持有调用者的返回信息。本质上是一样的。","like_count":0},{"had_liked":false,"id":73962,"user_name":"nullz","can_delete":false,"product_type":"c1","uid":1156066,"ip_address":"","ucode":"A9D997C41D6DE3","user_header":"https://static001.geekbang.org/account/avatar/00/11/a3/e2/d2cf7a81.jpg","comment_is_top":false,"comment_ctime":1552047332,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552047332","product_id":100017301,"comment_content":"练习：顺序栈&amp;链式栈&amp;浏览器前进后退：https:&#47;&#47;github.com&#47;hulull&#47;algo&#47;tree&#47;master&#47;stack","like_count":0},{"had_liked":false,"id":70611,"user_name":"locke.wei","can_delete":false,"product_type":"c1","uid":1351535,"ip_address":"","ucode":"58C70AC52A0C84","user_header":"https://static001.geekbang.org/account/avatar/00/14/9f/6f/aee1732a.jpg","comment_is_top":false,"comment_ctime":1551146505,"is_pvip":false,"replies":[{"id":"25197","content":"你是觉得应该是k吧。因为扩容之后会紧跟着一次入栈数据，所以占了一个名额。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551147780,"ip_address":"","comment_id":70611,"utype":1}],"discussion_count":5,"race_medal":0,"score":"1551146505","product_id":100017301,"comment_content":"如果当前栈大小为 K，并且已满，当再有新的数据要入栈时，就需要重新申请 2 倍大小的内存，并且做 K 个数据的搬移操作，然后再入栈。但是，接下来的 K-1 次入栈操作，......    这段没理解为什么是k-1","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440726,"discussion_content":"你是觉得应该是k吧。因为扩容之后会紧跟着一次入栈数据，所以占了一个名额。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551147780,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1083330,"avatar":"","nickname":"lant","note":"","ucode":"FD3FD13E14DD24","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":20922,"discussion_content":"如果说扩容之后紧跟着一个入栈操作, 那么扩容就应该是 k+1次, 之后说k-1次 才说的通\n要么就说扩容是 k, 之后也是 k\n不然不好理解啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569396943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1122121,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1f/49/e4ab004b.jpg","nickname":"波拉拉","note":"","ucode":"586F66351219E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4625,"discussion_content":"好像很有道理的样子😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565607068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1122121,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1f/49/e4ab004b.jpg","nickname":"波拉拉","note":"","ucode":"586F66351219E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1223,"discussion_content":"这个扩容之后紧跟着一次入栈数据是指哪一个？还是不明白，求解答。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562412105,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1238051,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/23/ac13d916.jpg","nickname":"圆哥哥呐丶","note":"","ucode":"8E56E3E68A3836","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1122121,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1f/49/e4ab004b.jpg","nickname":"波拉拉","note":"","ucode":"586F66351219E8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4155,"discussion_content":"我知道了，因为当你第 k+1次数据要放到数组中时，这个时候，数组会进行扩容，然后扩容完成后这个多出来的1也就放进去了， 只有这个1的时候需要进行扩容，而后面的k-1次入栈数据就不需要扩容了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565172435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":1223,"ip_address":""},"score":4155,"extra":""}]}]},{"had_liked":false,"id":70215,"user_name":"Geek_870a2b","can_delete":false,"product_type":"c1","uid":1396878,"ip_address":"","ucode":"E8DFCAE8572392","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/xpAsb3hl87UbMPCkYhgdvJue8Hj7CqHfEO9KtMp0MictkUicm2u1zcfK0CgIp3iaZG5r3dAluib7VtzIfPuiccQFx4g/132","comment_is_top":false,"comment_ctime":1551054229,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551054229","product_id":100017301,"comment_content":"函数","like_count":0},{"had_liked":false,"id":68688,"user_name":"clong","can_delete":false,"product_type":"c1","uid":1002297,"ip_address":"","ucode":"FC98A55050E4EE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4b/39/d376dfb7.jpg","comment_is_top":false,"comment_ctime":1550573006,"is_pvip":false,"replies":[{"id":"24618","content":"😁","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550718891,"ip_address":"","comment_id":68688,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1550573006","product_id":100017301,"comment_content":"图中盘子里的鱼很好玩","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439798,"discussion_content":"😁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550718891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65523,"user_name":"Pre-Y","can_delete":false,"product_type":"c1","uid":1396900,"ip_address":"","ucode":"A13D13A37F3ABC","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/a4/8d2e454b.jpg","comment_is_top":false,"comment_ctime":1549428719,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549428719","product_id":100017301,"comment_content":"今日份的打卡。<br>栈给我的感觉就是逻辑简单，操作方便。仔细处理边界问题就可以大致地确保证准确性。（学生小白的评论，还请dalao们指正）","like_count":0},{"had_liked":false,"id":64970,"user_name":"康斯坦丁","can_delete":false,"product_type":"c1","uid":1368096,"ip_address":"","ucode":"C130E800E8D5C9","user_header":"https://static001.geekbang.org/account/avatar/00/14/e0/20/003190c1.jpg","comment_is_top":false,"comment_ctime":1548987996,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548987996","product_id":100017301,"comment_content":"1 因为栈的先进后出特性. 用其他数据结构也可以实现，只是栈最合适.<br>2 很相似，但不完全一样，jvm的栈 包含局部变量、动态链接、方法出口、操作数栈. 生命周期同线程，可以说是线程专用的一块内存.<br><br>","like_count":0},{"had_liked":false,"id":64824,"user_name":"一波","can_delete":false,"product_type":"c1","uid":1021088,"ip_address":"","ucode":"8A4FC9BDB403D3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/94/a0/d7ec5984.jpg","comment_is_top":false,"comment_ctime":1548919659,"is_pvip":false,"discussion_count":0,"race_medal":3,"score":"1548919659","product_id":100017301,"comment_content":"老师，我想说一下，这篇用两个栈去存放数字和运算符的，我觉得是不是改用队列去存，因为这个不是先进后出的规律，应该是先进先出的规律。是不是队列要更合适一点","like_count":0},{"had_liked":false,"id":64480,"user_name":"晓龙","can_delete":false,"product_type":"c1","uid":1004576,"ip_address":"","ucode":"78CDCEBD183D3A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/20/93c79f7c.jpg","comment_is_top":false,"comment_ctime":1548810176,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548810176","product_id":100017301,"comment_content":"1.函数调用用栈保存临时变量，是因为一般我们在写代码时，越是后定义的变量，越先释放，因为越晚定义的变量作用域小。","like_count":0},{"had_liked":false,"id":62154,"user_name":"海军上校","can_delete":false,"product_type":"c1","uid":1104290,"ip_address":"","ucode":"7B0D9EC01A3F36","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/a2/afbc447c.jpg","comment_is_top":false,"comment_ctime":1547959734,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547959734","product_id":100017301,"comment_content":"内存区～代码段 有这么多作用呢","like_count":0},{"had_liked":false,"id":61790,"user_name":"🐍","can_delete":false,"product_type":"c1","uid":1213611,"ip_address":"","ucode":"42B11C20DD3CB0","user_header":"https://static001.geekbang.org/account/avatar/00/12/84/ab/1842a785.jpg","comment_is_top":false,"comment_ctime":1547801319,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547801319","product_id":100017301,"comment_content":"老师,入栈的时间复杂度那张图,一次数组的扩容迁移不就应该只有一次 扩容 操作吗?你图片上怎么在扩容了两次呢?还是第一个&#39;扩容&#39;表示开始扩容,第二个&#39;扩容&#39;表示扩容完毕?","like_count":0},{"had_liked":false,"id":61484,"user_name":"S.A.N","can_delete":false,"product_type":"c1","uid":1248420,"ip_address":"","ucode":"0A1F6AB8618FDB","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/a4/a5f3bb1f.jpg","comment_is_top":false,"comment_ctime":1547706635,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547706635","product_id":100017301,"comment_content":"为什么采用栈来保存临时变量？<br>部分原因应该是同名变量优先使用本作用域的，方便从栈顶向下判断","like_count":0},{"had_liked":false,"id":60344,"user_name":"Larry","can_delete":false,"product_type":"c1","uid":1256822,"ip_address":"","ucode":"2E8880F87C959A","user_header":"https://static001.geekbang.org/account/avatar/00/13/2d/76/22d826b0.jpg","comment_is_top":false,"comment_ctime":1547459942,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547459942","product_id":100017301,"comment_content":"&quot;如果当前栈大小为 K，并且已满，当再有新的数据要入栈时，就需要重新申请2倍大小的内存，并且做K个数据的搬移操作，然后再入栈。但是，接下来的K-1次入栈操作...&quot;这里为什么是K-1次，而不是K次？请问，最后一次，第K次有什么不一样？<br>","like_count":0},{"had_liked":false,"id":59552,"user_name":"王维","can_delete":false,"product_type":"c1","uid":1001099,"ip_address":"","ucode":"3C1FE3153BBDA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/46/8b/97601f22.jpg","comment_is_top":false,"comment_ctime":1547385002,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1547385002","product_id":100017301,"comment_content":"学习笔记：https:&#47;&#47;wangwei.one&#47;posts&#47;java-data-structures-and-algorithms-stack.html","like_count":0},{"had_liked":false,"id":58707,"user_name":"李尧","can_delete":false,"product_type":"c1","uid":1119539,"ip_address":"","ucode":"4E85C9F4947B2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/33/5be2710e.jpg","comment_is_top":false,"comment_ctime":1547179884,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547179884","product_id":100017301,"comment_content":"老师讲的太好了，一定要好好学","like_count":0},{"had_liked":false,"id":57850,"user_name":"辉仔lovers","can_delete":false,"product_type":"c1","uid":1210219,"ip_address":"","ucode":"3DC5B0CD0B8E71","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLVhJRVwJ0eVlC7zjNfWP6PP7VmUkF1X2m6qfh7Wic3NhAOz2fSGibF6LXLcJ59zOz7nBpCcByvtFjw/132","comment_is_top":false,"comment_ctime":1546928952,"is_pvip":false,"replies":[{"id":"21857","content":"栈并不一定是依赖数组实现的。栈并不需要随机访问。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1547709519,"ip_address":"","comment_id":57850,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546928952","product_id":100017301,"comment_content":"有个问题，麻烦老师解答下？<br>之前讲过 数组是存放同一种数据类型的连续的内存空间，咱们本期讲函数的调用栈，底层用的是数组实现的。也就是存储的变量类型必须要一致。我看文中示例全是int类型的变量 ，要是不同类型的变量呢，怎么使用栈来存储？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435790,"discussion_content":"栈并不一定是依赖数组实现的。栈并不需要随机访问。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547709519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57519,"user_name":"张先生","can_delete":false,"product_type":"c1","uid":1101781,"ip_address":"","ucode":"EBD5D2BC29A6EB","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/d5/056f9a3b.jpg","comment_is_top":false,"comment_ctime":1546827034,"is_pvip":false,"replies":[{"id":"21854","content":"是操作。你可以自己去浏览器上试下前进后退功能，就明白了。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1547708983,"ip_address":"","comment_id":57519,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546827034","product_id":100017301,"comment_content":"关于浏览器前进后退的一个疑问，清空Y栈是原因还是结果呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435622,"discussion_content":"是操作。你可以自己去浏览器上试下前进后退功能，就明白了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547708983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56532,"user_name":"weimin","can_delete":false,"product_type":"c1","uid":1354721,"ip_address":"","ucode":"C94DD3DE451885","user_header":"https://static001.geekbang.org/account/avatar/00/14/ab/e1/14cf564b.jpg","comment_is_top":false,"comment_ctime":1546483400,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546483400","product_id":100017301,"comment_content":"关于括号检测自己写的，已经在leetcode通过了。<br>class Solution {<br>    class ArrayStack{<br>        private char[] array; &#47;&#47;栈数组<br>        private int n; &#47;&#47;栈个数<br>        private int stack_size; &#47;&#47;栈大小<br>        &#47;&#47;初始化<br>        public ArrayStack(int stack_size){<br>            this.array = new char[stack_size];<br>            this.n = 0;<br>            this.stack_size = stack_size;<br>        }<br>        &#47;&#47;入栈<br>        public boolean push(char item){<br>            &#47;&#47;如果栈满了<br>            if(stack_size == n) return false;<br>            <br>            array[n] = item;<br>            n++;<br>            return true;<br>        }<br>        &#47;&#47;出栈<br>        public char pop(){<br>            &#47;&#47;如果栈里面没有数据<br>            if(n == 0) return Character.MIN_VALUE;<br>            char data = array[n - 1];<br>            n--;<br>            return data;<br>        }<br>    }<br>    &#47;&#47;判断是否是一组符号<br>    public boolean isGroup(ArrayStack arrayStack, boolean flag, String left) {<br>    \tchar f = arrayStack.pop();<br>    \tboolean tmp = false;<br>\t\tif(left.equals(String.valueOf(f))) {<br>\t\t\ttmp = true;<br>\t\t}<br>\t\tflag = flag &amp; tmp;<br>\t\treturn flag;<br>    }<br>    <br>    public boolean isValid(String s) {<br>    \tint len = s.length();<br>    \tArrayStack arrayStack = new ArrayStack(len);<br>    \tboolean flag = true;<br><br>        for(int i = 0; i &lt; len; i++) {<br>        \tchar c = s.charAt(i);<br>        \t&#47;&#47;如果碰到左括号就压栈<br>        \tif(&quot;{&quot;.equals(String.valueOf(c)) || &quot;[&quot;.equals(String.valueOf(c)) || &quot;(&quot;.equals(String.valueOf(c))) {<br>        \t\tarrayStack.push(c);<br>        \t}<br>        \t&#47;&#47;如果碰到右括号<br>        \tif(&quot;}&quot;.equals(String.valueOf(c))) {<br>    \t\t\tflag = isGroup(arrayStack,flag,&quot;{&quot;);<br>        \t}<br>        \t<br>        \tif(&quot;]&quot;.equals(String.valueOf(c))) {<br>        \t\tflag = isGroup(arrayStack,flag,&quot;[&quot;);<br>        \t}<br>        \t<br>        \tif(&quot;)&quot;.equals(String.valueOf(c))) {<br>        \t\tflag = isGroup(arrayStack,flag,&quot;(&quot;);<br>        \t}<br>        }<br>        &#47;&#47;栈里面还有未匹配的左括号<br>        if(arrayStack.n &gt; 0) {<br>        \treturn false;<br>        }<br><br>\t\treturn flag;<br>    }<br>}","like_count":0},{"had_liked":false,"id":56370,"user_name":"weimin","can_delete":false,"product_type":"c1","uid":1354721,"ip_address":"","ucode":"C94DD3DE451885","user_header":"https://static001.geekbang.org/account/avatar/00/14/ab/e1/14cf564b.jpg","comment_is_top":false,"comment_ctime":1546430419,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546430419","product_id":100017301,"comment_content":"我们假设表达式中只包含三种括号，圆括号 ()、方括号 [] ...<br>以下是自己写的代码，初次写栈，写得有点慢，但是根据老师的逻辑实现一遍，理解加深<br>class Solution {<br>    class ArrayStack{<br>        private char[] array; &#47;&#47;栈数组<br>        private int n; &#47;&#47;栈个数<br>        private int stack_size; &#47;&#47;栈大小<br>        &#47;&#47;初始化<br>        public ArrayStack(int stack_size){<br>            this.array = new char[stack_size];<br>            this.n = 0;<br>            this.stack_size = stack_size;<br>        }<br>        &#47;&#47;入栈<br>        public boolean push(char item){<br>            &#47;&#47;如果栈满了<br>            if(stack_size == n) return false;<br>            <br>            array[n] = item;<br>            n++;<br>            return true;<br>        }<br>        &#47;&#47;出栈<br>        public char pop(){<br>            &#47;&#47;如果栈里面没有数据<br>            if(n == 0) return Character.MIN_VALUE;<br>            char data = array[n - 1];<br>            n--;<br>            return data;<br>        }<br>    }<br>    &#47;&#47;判断是否是一组符号<br>    public boolean isGroup(ArrayStack arrayStack, boolean flag, String left) {<br>    \tchar f = arrayStack.pop();<br>    \tboolean tmp = false;<br>\t\tif(left.equals(String.valueOf(f))) {<br>\t\t\ttmp = true;<br>\t\t}<br>\t\tflag = flag &amp; tmp;<br>\t\treturn flag;<br>    }<br>    <br>    public boolean isValid(String s) {<br>    \tint len = s.length();<br>    \tArrayStack arrayStack = new ArrayStack(len);<br>    \tboolean flag = true;<br>        for(int i = 0; i &lt; len; i++) {<br>        \tchar c = s.charAt(i);<br>        \tif(&quot;{&quot;.equals(String.valueOf(c)) || &quot;[&quot;.equals(String.valueOf(c)) || &quot;(&quot;.equals(String.valueOf(c))) {<br>        \t\tarrayStack.push(c);<br>        \t}<br>        \t&#47;&#47;如果碰到右括号<br>        \tif(&quot;}&quot;.equals(String.valueOf(c))) {<br>    \t\t\tflag = isGroup(arrayStack,flag,&quot;{&quot;);<br>        \t}<br>        \t<br>        \tif(&quot;]&quot;.equals(String.valueOf(c))) {<br>        \t\tflag = isGroup(arrayStack,flag,&quot;[&quot;);<br>        \t}<br>        \t<br>        \tif(&quot;)&quot;.equals(String.valueOf(c))) {<br>        \t\tflag = isGroup(arrayStack,flag,&quot;(&quot;);<br>        \t}<br>        }<br><br>\t\treturn flag;<br>    }<br>}","like_count":0},{"had_liked":false,"id":55686,"user_name":"那样的月色","can_delete":false,"product_type":"c1","uid":1237353,"ip_address":"","ucode":"23B1298C465D2C","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/69/0db70c84.jpg","comment_is_top":false,"comment_ctime":1546261796,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546261796","product_id":100017301,"comment_content":"数据结构和算法分析那本书上有栈的表达式求值，，专业的名字叫中缀表达式，，，","like_count":0},{"had_liked":false,"id":53066,"user_name":"融梨","can_delete":false,"product_type":"c1","uid":1033405,"ip_address":"","ucode":"66D0A4054612C6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c4/bd/72180435.jpg","comment_is_top":false,"comment_ctime":1545578420,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545578420","product_id":100017301,"comment_content":"数据结构计算机存储数据、组织数据的方式。栈有自己的存储和组织数据的方式。栈如何存储呢？只允许一端，加入数据和输出数据。栈如何组织数据呢？先进后出，后进先出。","like_count":0},{"had_liked":false,"id":52278,"user_name":"Mr_杨","can_delete":false,"product_type":"c1","uid":1008065,"ip_address":"","ucode":"AD31C2320DF6A2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/61/c1/9ad88d67.jpg","comment_is_top":false,"comment_ctime":1545357334,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545357334","product_id":100017301,"comment_content":"对于顺序栈的扩容问题，如果是前后指针＋数组构成的一个节点，是不是性能更好一些，空间不足就在申请一个该节点，通过前后指针链接，减少了复制过程，除了带来一点复杂性，性能上我感觉更好。多多指点","like_count":0},{"had_liked":false,"id":51471,"user_name":"李杰","can_delete":false,"product_type":"c1","uid":1113492,"ip_address":"","ucode":"98874A91C90497","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/94/ab261a31.jpg","comment_is_top":false,"comment_ctime":1545186888,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545186888","product_id":100017301,"comment_content":"http:&#47;&#47;people.cs.ksu.edu&#47;~schmidt&#47;300s05&#47;Lectures&#47;Week3.html","like_count":0},{"had_liked":false,"id":49814,"user_name":"Yeir","can_delete":false,"product_type":"c1","uid":1072999,"ip_address":"","ucode":"3A325B919C66B9","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/67/8552dab9.jpg","comment_is_top":false,"comment_ctime":1544775147,"is_pvip":false,"replies":[{"id":"17941","content":"iPad Paper","user_name":"编辑回复","user_name_real":"郭蕾","uid":"1000473","ctime":1544777360,"ip_address":"","comment_id":49814,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1544775147","product_id":100017301,"comment_content":"大神能不能推荐一下你画图的工具, 我也想贴漂亮的图到文档里.","like_count":0,"discussions":[{"author":{"id":1000473,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/44/19/17fadc62.jpg","nickname":"郭蕾","note":"","ucode":"34F4C07D1C5FE8","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432782,"discussion_content":"iPad Paper","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544777360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":49795,"user_name":"泉","can_delete":false,"product_type":"c1","uid":1099760,"ip_address":"","ucode":"914709BE802A8D","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/f0/aa2e0749.jpg","comment_is_top":false,"comment_ctime":1544770561,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1544770561","product_id":100017301,"comment_content":"栈的应用:浏览器页面栈，函数调用，表达式求值，括号匹配。","like_count":0},{"had_liked":false,"id":49454,"user_name":"史蒂芬诺夫斯基","can_delete":false,"product_type":"c1","uid":1329356,"ip_address":"","ucode":"C27A598E29FFFE","user_header":"https://static001.geekbang.org/account/avatar/00/14/48/cc/384b3ab2.jpg","comment_is_top":false,"comment_ctime":1544691403,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544691403","product_id":100017301,"comment_content":"栈的概念懂了，那么栈在JAVA、C等语言中有没有具体的实现呢？还是只能当我们使用的时候需要自己实现一个数组栈或者链式栈？","like_count":0},{"had_liked":false,"id":47610,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1544165083,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544165083","product_id":100017301,"comment_content":"晒笔记来了（虽然有人不喜欢）：<br>来历：不明，一个受限制的队列，可能是受堆盘子的启发，或者其他什么的<br>特点：被限制得有点厉害<br>适合解决的问题： a、函数调用栈   b、表达式求值 c 、括号匹配<br><br>实际应用：chrome浏览器的前进后退，说实在的我用一个数组形成队列，或者双向链表岂不更好，或者更可以说栈是特殊的队列；就是在现有的队列的基础上加入了更多的限制，-----但有一个问题是暴露的接口多，使得许多东西不可控----&gt; 容易出错<br><br>顺序栈；基于数组的时间复杂度O(1)，空间复杂度O(1)----算法运行时还需要的额外的运行空间<br>链式栈<br><br>其中的困惑：浏览页前进后退中为什么在插入d的时候要把c清空;我是觉得这本身是一个线性的东西为了保持线性，希望不会再b的时候回退出现多个选项的情况，的一种做法，<br><br>思考题<br>1、其他的链表啊，数组啊，都可以实现，比较开放，此情此景只需要这样一个“直男”一板一眼的呆板控制，带给你无尽的操控感，不多不少刚刚好<br>2、第二个问题就难倒我了<br>","like_count":0},{"had_liked":false,"id":45911,"user_name":"匆匆","can_delete":false,"product_type":"o","uid":1333414,"ip_address":"","ucode":"4DB39C6CD5743B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/H8NxrljQXliccaT5fjdXJQYS3ou3Z9ykAuKw6EgicicEA9L4jQLz3h85P0odgDSaK0cA9oTyUKibbiagdNvnHuuV5mQ/132","comment_is_top":false,"comment_ctime":1543816706,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543816706","product_id":999999999,"comment_content":"关于栈<br><br>栈的特点：先进后出、后进先出<br><br>栈的实现方式有两种：一种是用数组实现的顺序栈，一种是用链表实现的链式栈。顺序栈在内存占满后需要动态扩充内存，链式栈则不需要，但是由于存在next存储区域，所以链式栈占用内存大些。<br><br>关于栈操作的时间复杂度：一般单步操作都需要O(1)，最好时间复杂度为O(1)，最快为O(n)；顺序栈的动态扩充内存需要O(n)，均摊时间复杂度为O(1)；<br><br>关于函数的调用，函数的局部变量存储，都是用的栈。算术运算也是用到两个栈，一个存放数据一个存放运算符号。括号的匹配等也用到栈。<br><br>最后，网页的前进和后退功能是如何实现的：这里也用到两个栈，每次浏览下一个网页，则把上一个网页压入栈中，当后退时则将当前网页压住另一个栈，同时上另一个栈中调出上一个网页。","like_count":0},{"had_liked":false,"id":45787,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1543796723,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543796723","product_id":100017301,"comment_content":"思考题:<br>1. 函数调用采用栈的方式感觉主要是函数的调用顺序更清晰.","like_count":0},{"had_liked":false,"id":45670,"user_name":"Walton","can_delete":false,"product_type":"c1","uid":1246984,"ip_address":"","ucode":"C79F04E61200BD","user_header":"https://static001.geekbang.org/account/avatar/00/13/07/08/0fc1bba6.jpg","comment_is_top":false,"comment_ctime":1543742681,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543742681","product_id":100017301,"comment_content":"笔记<br>栈是一种简单的数据结构，简单是为了防止出错，只支持入栈和出栈两种操作；栈是一种线性结构，出入栈的时间复杂度和空间复杂度都是O(1)。<br>","like_count":0},{"had_liked":false,"id":45081,"user_name":"我系哆啦","can_delete":false,"product_type":"c1","uid":1258151,"ip_address":"","ucode":"109A96943F1DDA","user_header":"https://static001.geekbang.org/account/avatar/00/13/32/a7/3f3e05fa.jpg","comment_is_top":false,"comment_ctime":1543544344,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543544344","product_id":100017301,"comment_content":"栈以为很简单的一个数据结构。原来有这么多用法","like_count":0},{"had_liked":false,"id":44850,"user_name":"Apan","can_delete":false,"product_type":"c1","uid":1245249,"ip_address":"","ucode":"A799093C47008F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ibRKiaiciaGuAHOE3WBGP4qdujAmYz0aLZuNhjvpiadIfCqUYmN8rn4TXuqP0PaPrQ6Ue4w5WWUibNnzFvwfibcTSVnPA/132","comment_is_top":false,"comment_ctime":1543499682,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543499682","product_id":100017301,"comment_content":"JVM 里面的“栈”和数据结构中的“栈“有的人说一样有的人说不一样，到底一样不一样？","like_count":0},{"had_liked":false,"id":44446,"user_name":"茴香根","can_delete":false,"product_type":"c1","uid":1316111,"ip_address":"","ucode":"B91C00B72077F1","user_header":"https://static001.geekbang.org/account/avatar/00/14/15/0f/954be2db.jpg","comment_is_top":false,"comment_ctime":1543450439,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543450439","product_id":100017301,"comment_content":"本篇文章，使用两个栈解决问题是亮点。","like_count":0},{"had_liked":false,"id":43062,"user_name":"Damon","can_delete":false,"product_type":"c1","uid":1013281,"ip_address":"","ucode":"E07522227DE1E4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/21/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1543153630,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543153630","product_id":100017301,"comment_content":"&#47;&#47;链式栈<br>class LinkedListStack{<br><br><br>    constructor(n){<br><br>        this.n = n;<br>        this.head=new ListNode(&#39;head&#39;);<br>        this.count = 0;<br><br>    }<br><br>    &#47;&#47; &#47;**<br>    &#47;&#47;  * 入栈 (不能扩容)<br>    &#47;&#47;  * @param item<br>    &#47;&#47;  * @returns {boolean} 成功 ,失败<br>    &#47;&#47;  *&#47;<br>    &#47;&#47; push(item){<br>    &#47;&#47;<br>    &#47;&#47;     if (this.count &lt; this.n){<br>    &#47;&#47;<br>    &#47;&#47;         const node = new ListNode(item);<br>    &#47;&#47;         node.next = this.head.next;<br>    &#47;&#47;         this.head.next = node;<br>    &#47;&#47;<br>    &#47;&#47;         this.count++;<br>    &#47;&#47;         &#47;&#47;this.print();<br>    &#47;&#47;         return true;<br>    &#47;&#47;     } else {<br>    &#47;&#47;         &#47;&#47;console.log(&#39;栈满&#39;);<br>    &#47;&#47;         return false;<br>    &#47;&#47;     }<br>    &#47;&#47;<br>    &#47;&#47; }<br><br>    &#47;**<br>     * 入栈 (可以能扩容, *2)<br>     * @param item<br>     * @returns {boolean} 成功 ,失败<br>     *&#47;<br>    push(item){<br><br>        if (this.count === this.n){<br>            this.n = 2 * this.n;<br>        }<br><br>        const node = new ListNode(item);<br>        node.next = this.head.next;<br>        this.head.next = node;<br><br>        this.count++;<br>        this.print();<br>        return true;<br>    }<br><br><br>    pop(){<br>        if (this.count &gt; 0){<br><br>            this.count--;<br>            var temp = this.head.next.val;<br>            this.head.next = this.head.next.next;<br><br>            return temp;<br>        } else {<br>            return null;<br>        }<br><br>    }<br><br>    isEmpty(){<br>        return this.count == 0 ?true:false;<br>    }<br><br><br>    &#47;**<br>     * 栈顶元素<br>     * @returns {*}<br>     *&#47;<br>    peek(){<br><br>        if (this.count &gt; 0){<br>            var temp = this.head.next.val;<br>            return temp;<br>        } else {<br>            return null;<br>        }<br><br>    }<br><br>    print(){<br>        let string = &#39;&#39;;<br>        let currentNode = this.head.next;<br>        while (currentNode!=null){<br>            string +=currentNode.val + &#39;--&#39;;<br>            currentNode = currentNode.next;<br>        }<br>        console.log(string);<br>    }<br><br>}<br><br>&#47;&#47;节点<br>class ListNode {<br><br>    constructor(val){<br>        this.val = val;<br>        this.next = null;<br>    }<br>}","like_count":0},{"had_liked":false,"id":42955,"user_name":"刘文韬","can_delete":false,"product_type":"c1","uid":1312479,"ip_address":"","ucode":"41395E6036D516","user_header":"https://static001.geekbang.org/account/avatar/00/14/06/df/d0fe2300.jpg","comment_is_top":false,"comment_ctime":1543118599,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543118599","product_id":100017301,"comment_content":"非常棒。本来觉得栈太简单没啥可学的。没想到带来了两个知识点：函数栈帧（再配合linux进程栈、堆、数据段、代码段的知识）和四则运算表达式。这两个问题以前算是一知半解，这次终于理清楚了。感谢🙏","like_count":0},{"had_liked":false,"id":42550,"user_name":"K战神","can_delete":false,"product_type":"c1","uid":1139367,"ip_address":"","ucode":"527E6BB26BB766","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/a7/3e6fee86.jpg","comment_is_top":false,"comment_ctime":1542968428,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542968428","product_id":100017301,"comment_content":"对于栈，我觉得有点像弹夹压子弹。大小端的话，也可以是，弹夹在上面或者弹夹在下面。","like_count":0},{"had_liked":false,"id":42028,"user_name":"spray","can_delete":false,"product_type":"c1","uid":1199039,"ip_address":"","ucode":"CD5715FCC15241","user_header":"https://static001.geekbang.org/account/avatar/00/12/4b/bf/7c73bb3b.jpg","comment_is_top":false,"comment_ctime":1542894259,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542894259","product_id":100017301,"comment_content":"chrome 70中，回退后进入其他新页面时，并没有清空右侧栈（测试后的结果），Firefox 63中，跟您文中说的是一致的。","like_count":0},{"had_liked":false,"id":40311,"user_name":"追风少年","can_delete":false,"product_type":"c1","uid":1305639,"ip_address":"","ucode":"0467648A908B18","user_header":"https://static001.geekbang.org/account/avatar/00/13/ec/27/827015c0.jpg","comment_is_top":false,"comment_ctime":1542591627,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542591627","product_id":100017301,"comment_content":"想问问大家做笔记都用多长时间啊，为何我总是“看书五分钟，笔记两小时”啊。","like_count":0},{"had_liked":false,"id":38586,"user_name":"aguan(^･ｪ･^)","can_delete":false,"product_type":"c1","uid":1107177,"ip_address":"","ucode":"04833EF2D18E1A","user_header":"https://static001.geekbang.org/account/avatar/00/10/e4/e9/0dd3829f.jpg","comment_is_top":false,"comment_ctime":1542077129,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542077129","product_id":100017301,"comment_content":"思考题<br>1、函数调用为何选栈？<br>能想到的原因：函数是顺序执行的，且函数中的变量是有作用域的。所以栈的先进后出特性更能满足临时变量存储的要求","like_count":0},{"had_liked":false,"id":38530,"user_name":"cw","can_delete":false,"product_type":"c1","uid":1264296,"ip_address":"","ucode":"82A6B50462F9F9","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/a8/b7e36dd2.jpg","comment_is_top":false,"comment_ctime":1542071591,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542071591","product_id":100017301,"comment_content":"为什么说临时变量放在栈中比较合适呢？其实，临时变量只需要一个作用域，就是当前方法，其他数据结构也可以，但是方法本身需要注意一个进栈的操作，所以栈比较合适。<br>关于问题2:jvm栈为物理意义，不是数据结构","like_count":0},{"had_liked":false,"id":37663,"user_name":"阿星","can_delete":false,"product_type":"c1","uid":1195215,"ip_address":"","ucode":"6AFD288E9022C5","user_header":"https://static001.geekbang.org/account/avatar/00/12/3c/cf/fa5c5123.jpg","comment_is_top":false,"comment_ctime":1541670491,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541670491","product_id":100017301,"comment_content":"-----------------------------------------<br>如果当前栈大小为 K，并且已满，当再有新的数据要入栈时，就需要重新申请 2 倍大小的内存<br>并且做 K 个数据的搬移操作，然后再入栈。但是，接下来的 K-1 次入栈操作，我们都不需要再重新申请内存和搬移数据，所以这 K-1 次入栈操作都只需要一个 simple-pus...<br>-----------------------------------------<br><br>基于这个动态扩容的案例，我想问下这里申请了2倍内存空间后，将k-1个数据搬移到新申请的内存空间，这个数据搬移是不是相当于把原来内存空间中的数据一个一个压入新的内存空间，也就是相当于k-1次的入栈操作   是这样吗？<br><br><br><br><br>","like_count":0},{"had_liked":false,"id":37626,"user_name":"Shawn","can_delete":false,"product_type":"c1","uid":1014729,"ip_address":"","ucode":"B95D7B54465DE4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/c9/75c9002e.jpg","comment_is_top":false,"comment_ctime":1541658078,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541658078","product_id":100017301,"comment_content":"1. 程序运行期间，开栈退栈的频率超级高，并且遵循后进先出的顺序，所以栈非常的合适。<br>2. 个人认为差不多，无论是java中的堆栈内存还是操作系统中的堆栈内存，之所以这么叫，主要是因为动态内存用堆这个数据结构进行管理，而局部变量等等则用栈数据结构管理，只适合内存管理的方式对应了一下。<br><br>以上都是个人理解","like_count":0},{"had_liked":false,"id":37475,"user_name":"樱小路依然","can_delete":false,"product_type":"c1","uid":1269957,"ip_address":"","ucode":"DBA9FF68015FE5","user_header":"https://static001.geekbang.org/account/avatar/00/13/60/c5/69286d58.jpg","comment_is_top":false,"comment_ctime":1541600777,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1541600777","product_id":100017301,"comment_content":"就前言来说的话，感觉双链表也比较好实现的..","like_count":0,"discussions":[{"author":{"id":1266233,"avatar":"https://static001.geekbang.org/account/avatar/00/13/52/39/2211b1a2.jpg","nickname":"Z-ll","note":"","ucode":"68A75A53D1455E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":66560,"discussion_content":"可以单链表，记录一下栈顶元素也可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575085003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37416,"user_name":"Kim","can_delete":false,"product_type":"c1","uid":1236573,"ip_address":"","ucode":"39CC8E1E8EFB8A","user_header":"https://static001.geekbang.org/account/avatar/00/12/de/5d/a7e748db.jpg","comment_is_top":false,"comment_ctime":1541578616,"is_pvip":false,"replies":[{"id":"13451","content":"你自己在浏览器里试一下就知道了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541641597,"ip_address":"","comment_id":37416,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541578616","product_id":100017301,"comment_content":"老师，还是觉得这个浏览器部分难理解，为什么c就无法浏览了？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428331,"discussion_content":"你自己在浏览器里试一下就知道了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541641597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37334,"user_name":"那些年过了之后","can_delete":false,"product_type":"c1","uid":1102988,"ip_address":"","ucode":"282DBA1ED321B5","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/8c/b2471f02.jpg","comment_is_top":false,"comment_ctime":1541551902,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541551902","product_id":100017301,"comment_content":"以上栈的运用demo分析完全对应了jvm操作数栈和局部变量表，赞","like_count":0},{"had_liked":false,"id":36753,"user_name":"西风波波","can_delete":false,"product_type":"c1","uid":1063527,"ip_address":"","ucode":"2CCE91B573DAE0","user_header":"https://static001.geekbang.org/account/avatar/00/10/3a/67/78ab677b.jpg","comment_is_top":false,"comment_ctime":1541307100,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541307100","product_id":100017301,"comment_content":"栈的链表实现：<br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br><br>typedef struct node node_t;<br>struct node<br>{<br>    int val;<br>    node_t *next;<br>};<br><br>typedef struct stack<br>{<br>    size_t size;<br>    node_t *top;<br>}stack_t;<br>int push( node_t * new, stack_t * stack)<br>{<br>    if ( !new || !stack )<br>        return 0;<br>    new-&gt;next = stack-&gt;top;<br>    stack-&gt;top = new;<br>    ++stack-&gt;size; <br>    return 1;<br>}<br>node_t * pop(stack_t * stack)<br>{<br>    if ( !stack )<br>        return NULL;<br>    if ( !stack-&gt;top ) <br>        return NULL;<br>    node_t * top = stack-&gt;top;<br>    stack-&gt;top = top-&gt;next;<br>    top-&gt;next = NULL;<br>    --stack-&gt;size;<br>    return top;<br>}<br><br>int main(int argc, char *argv[])<br>{<br>    stack_t stack = {0,NULL};<br>    int i;<br>    for(i = 0; i &lt; 32; i++)<br>    {<br>        node_t * new = (node_t *)malloc(sizeof(node_t));<br>        if ( new )<br>        {<br>            new-&gt;val = i + &#39;a&#39;;<br>            new-&gt;next = NULL;<br>            push(new, &amp;stack);<br>        }<br>    }<br>    while( stack.top )<br>    {<br>        node_t * top = pop(&amp;stack);<br>        printf(&quot;top val is %c, stack size is %d\\n&quot;, top-&gt;val, stack.size);<br>        free(top);<br>    }<br>}","like_count":0},{"had_liked":false,"id":36486,"user_name":"、BQ","can_delete":false,"product_type":"c1","uid":1132203,"ip_address":"","ucode":"7CAFE074F7C536","user_header":"https://static001.geekbang.org/account/avatar/00/11/46/ab/bae17033.jpg","comment_is_top":false,"comment_ctime":1541126764,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541126764","product_id":100017301,"comment_content":"看到栈在表达式求值中的应用，有种被惊艳到的感觉~","like_count":0},{"had_liked":false,"id":36371,"user_name":"Fisher","can_delete":false,"product_type":"c1","uid":1089543,"ip_address":"","ucode":"49C0EB546971ED","user_header":"https://static001.geekbang.org/account/avatar/00/10/a0/07/8d91021c.jpg","comment_is_top":false,"comment_ctime":1541063198,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541063198","product_id":100017301,"comment_content":"王老师，虽说同学写的栈内存原理比较清楚了。但还是想系统性的看下操作系统中关于栈内存的管理，翻了几本书的目录，是不是看下“内存管理”章节就OK？","like_count":0},{"had_liked":false,"id":36043,"user_name":"张申傲","can_delete":false,"product_type":"c1","uid":1182372,"ip_address":"","ucode":"22D46BC529BA8A","user_header":"https://static001.geekbang.org/account/avatar/00/12/0a/a4/828a431f.jpg","comment_is_top":false,"comment_ctime":1540902273,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1540902273","product_id":100017301,"comment_content":"思考题:<br>1. 之所以使用栈，是因为方法调用遵循&#39;后调用，先返回&#39;的原则，只有在后面的方法执行结束，才能执行上一层调用的方法，这与栈&#39;后进先出&#39;的原则一致。<br>2. 个人理解，数据结构中的栈与JVM里面的栈是抽象与实现的关系。数据结构里面定义了栈是一种线性的、单侧存取的后进先出的结构，而JVM里面的栈则实现了这一定义，以栈的方式保持方法的调用信息和局部变量。","like_count":0},{"had_liked":false,"id":35632,"user_name":"1027","can_delete":false,"product_type":"c1","uid":1182296,"ip_address":"","ucode":"4C694B03B2685C","user_header":"https://static001.geekbang.org/account/avatar/00/12/0a/58/df69dea0.jpg","comment_is_top":false,"comment_ctime":1540718083,"is_pvip":false,"replies":[{"id":"12673","content":"栈底层依赖数组 我们在底层实现层面 操作起来更加灵活 没必要非得先进后出","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540740087,"ip_address":"","comment_id":35632,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540718083","product_id":100017301,"comment_content":"一直没有想清楚那个动态顺序栈的实现，新建一个2倍的数组后，数据的搬移不是要搬移两次才能保证和原来的栈的顺序一样吗，要不以前的那个栈的栈顶不是进到新栈的栈底了吗?<br>谁能回复一下，谢谢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427607,"discussion_content":"栈底层依赖数组 我们在底层实现层面 操作起来更加灵活 没必要非得先进后出","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540740087,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35585,"user_name":"樱桃子77","can_delete":false,"product_type":"c1","uid":1260146,"ip_address":"","ucode":"676894101A6652","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJicwphCoQ0S1DaibWNarUJq3DrGOeADY02AreVbKCLkm0PWJmZR0f1rMrrXDRzOwLCmIQbqeibQ4uHQ/132","comment_is_top":false,"comment_ctime":1540693532,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1540693532","product_id":100017301,"comment_content":"还请老师把leetcode 相应题目给一些 让我们这些准备面试的人 有练手的。每个用户需求不一样 买课程包的目的也不一样。多谢","like_count":0},{"had_liked":false,"id":35034,"user_name":"ForzaJuve","can_delete":false,"product_type":"c1","uid":1047302,"ip_address":"","ucode":"E090D83AE78EE6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/06/0e6b6365.jpg","comment_is_top":false,"comment_ctime":1540385997,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540385997","product_id":100017301,"comment_content":"栈是一种“操作受限”的线性表，只允许在一端插入和删除数据<br>我从来没用过栈，都是用容器解决了<br>从功能上来说，数组或链表确实可以替代栈，但特定的数据结构是对特定场景的抽象，并且数组等暴露了太多借口，虽然灵活但也容易出错<br>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出，先进后出的特性，我们就应该使用栈。<br>老师通过匹配括号，运算表达式以及函数栈和浏览器的前进后退等实际案例图文并茂讲解了栈的妙用（用两个栈）","like_count":0},{"had_liked":false,"id":34902,"user_name":"小和尚笨南北","can_delete":false,"product_type":"c1","uid":1204628,"ip_address":"","ucode":"17C9BBB6DD25D2","user_header":"https://static001.geekbang.org/account/avatar/00/12/61/94/713b38ef.jpg","comment_is_top":false,"comment_ctime":1540350026,"is_pvip":false,"replies":[{"id":"12499","content":"你理解的没错 你可以在浏览器中试一试","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540394540,"ip_address":"","comment_id":34902,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540350026","product_id":100017301,"comment_content":"为什么每次跳转到新页面的时候都要将Y栈中的数据清空？<br>因为每次跳转到新页面时，新页面就相当于终点。所以要清空Y栈。<br>不知道理解对不对，希望老师可以解惑。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427381,"discussion_content":"你理解的没错 你可以在浏览器中试一试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540394540,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34801,"user_name":"斗米担米","can_delete":false,"product_type":"c1","uid":1199203,"ip_address":"","ucode":"35BA47EF3B0C2E","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/63/f5988a98.jpg","comment_is_top":false,"comment_ctime":1540304592,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540304592","product_id":100017301,"comment_content":"1.方法调用满足后进先出的原则<br>2.觉得是一样的","like_count":0},{"had_liked":false,"id":34602,"user_name":"齐天大圣","can_delete":false,"product_type":"c1","uid":1268940,"ip_address":"","ucode":"0AE82DA88215A7","user_header":"https://static001.geekbang.org/account/avatar/00/13/5c/cc/57d7b937.jpg","comment_is_top":false,"comment_ctime":1540216330,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540216330","product_id":100017301,"comment_content":"1. 函数调用满足后进先出，所以使用栈比较合适，局部变量只对当前函数有效，所以存在栈上。栈是一个逻辑上的概念，具体实现上可以用数组也可以用链表实现，一般函数调用栈底层就是用数组实现的<br>2. jvm的栈也是一种栈。可以说有不同层次的栈，操作系统层面的，jvm层面的，java上层的","like_count":0},{"had_liked":false,"id":34523,"user_name":"木羊人007","can_delete":false,"product_type":"c1","uid":1115203,"ip_address":"","ucode":"375BD287493FA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/04/43/835418b5.jpg","comment_is_top":false,"comment_ctime":1540198728,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540198728","product_id":100017301,"comment_content":"问。栈在函数调用中的应用一节中，函数中的局部变量在栈中存储的顺序是 a=1,ret=0,res=0。那么，当执行add()方法返回结果并赋值给局部变量ret时栈里面的元素是怎么操作的呢。是要先将res和ret出栈，赋值再放进去吗。","like_count":0},{"had_liked":false,"id":34140,"user_name":"Veigar","can_delete":false,"product_type":"c1","uid":1258773,"ip_address":"","ucode":"FAD1CBB0677D94","user_header":"https://static001.geekbang.org/account/avatar/00/13/35/15/0b7de6b0.jpg","comment_is_top":false,"comment_ctime":1540018225,"is_pvip":false,"replies":[{"id":"12193","content":"好用的 文中有讲啊 你仔细看看","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540047835,"ip_address":"","comment_id":34140,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540018225","product_id":100017301,"comment_content":"浏览器的前进后退功能中，如果我后退之后又选择了其他页面，那这种栈结构是否就不好用了呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427130,"discussion_content":"好用的 文中有讲啊 你仔细看看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540047835,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33861,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1539912022,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539912022","product_id":100017301,"comment_content":"我在评论区看到了两种关于 这里的栈 和 JVM中的栈 是否一致的答案。<br>一种说一致，<br>一种说不一致。","like_count":0},{"had_liked":false,"id":33842,"user_name":"张洋","can_delete":false,"product_type":"c1","uid":1182914,"ip_address":"","ucode":"549BE5DEEF8417","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/c2/bad34a50.jpg","comment_is_top":false,"comment_ctime":1539909914,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1539909914","product_id":100017301,"comment_content":" *1.为什么函数调用要用栈来存储临时变量？ 用去他数据结构不行吗？<br>     *  a.栈每次pop 之后 不需要的数据已经变成垃圾 不占内存<br>     *  b. 栈先进后出的数据结构 适合函数的循环调用 函数循环调用的时候  首先弹栈的都是 被调用的函数<br>     *  * 2.JVM中的栈 和数据结构的栈一样吗<br>     *     一样 jvm 的栈 就是根据 栈这种数据结构 出来的  ","like_count":0},{"had_liked":false,"id":33684,"user_name":"djane","can_delete":false,"product_type":"c1","uid":1249032,"ip_address":"","ucode":"5315AA246AFDD8","user_header":"","comment_is_top":false,"comment_ctime":1539852878,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539852878","product_id":100017301,"comment_content":"【习题】<br>1、我们在讲栈的应用时，讲到用函数调用栈来保存临时变量，为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？<br>1）函数调用的局部状态之所以用栈来记录是因为这些数据的存活时间满足“后入先出”（LIFO）顺序，而栈的基本操作正好就是支持这种顺序的访问。<br>2）栈是内存，可以保存寄存器信息，先进后出的特点让栈不仅可以保存，还能方便地恢复。函数的目的就是复用，用栈来实现复用是个不错的方案。<br><br>2、我们都知道，JVM 内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储 Java 中的对象。那JVM 里面的“栈”跟我们这里说的“栈”是不是一回事呢？如果不是，那它为什么又叫作“栈”呢？<br>内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。<br>1）内存中的堆栈：是确切存在的物理结构，是用来存放不同数据的内存空间。<br>内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区。<br>代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。<br>静态数据区：存储全局变量、静态变量、常量，常量包括final修饰的常量和String常量。系统自动分配和回收。<br>栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。<br>例如 int method(int a){int b;}栈中存储参数a、局部变量b、返回值temp。<br>堆区：new一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。由程序员分配和回收（Java中由JVM虚拟机的垃圾回收机制自动回收）。<br>例如 Class Student{int num; int age;} main方法中Student stu = new Student()；分配堆区空间中存储的该对象的num、age，变量stu存储在栈中，里面的值是对应堆区空间的引用或地址。<br><br>2）数据结构中的堆栈：是两种特殊的数据结构，都是对数据项按序排列的数据结构，对管理数据的一种手段和方法。可以用来存放数据和地址，栈只能在一端（栈顶）对数据项进行插入和删除。<br>栈：是一种连续存储的数据结构，特点是存储的数据先进后出。<br>堆：是一棵完全二叉树结构，特点是父节点的值大于（小于）两个子节点的值（分别称为大顶堆和小顶堆）。它常用于管理算法执行过程中的信息，应用场景包括堆排序，优先队列等。<br><br><br>（看到后面，感觉越来越吃力了，好些概念不理解的，要搜好多资料，还是懵懵懂懂的。）<br>","like_count":0},{"had_liked":false,"id":33583,"user_name":"kakasi","can_delete":false,"product_type":"c1","uid":1237297,"ip_address":"","ucode":"64F357E6A08CA5","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/31/eb103bdc.jpg","comment_is_top":false,"comment_ctime":1539828420,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539828420","product_id":100017301,"comment_content":"栈: 后进先出的数据结构。有数组实现的顺序栈(可扩容)，有链表实现的链式栈。<br><br>练习题: 表达式求值，括号匹配。<br><br>思考题记录: <br>1. 函数调用栈，每个栈桢都是一个函数，临时变量存放在栈桢中。其调用的先进后出正好适合栈的特性。<br>2. jvm栈: 存放形参、局部变量、返回值等。堆: 存放真实数据，栈中的引用指向堆里的地址。","like_count":0},{"had_liked":false,"id":33134,"user_name":"Mr.Changel","can_delete":false,"product_type":"c1","uid":1245370,"ip_address":"","ucode":"245BACAB2A6150","user_header":"https://static001.geekbang.org/account/avatar/00/13/00/ba/339c9a77.jpg","comment_is_top":false,"comment_ctime":1539748280,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539748280","product_id":100017301,"comment_content":"为什么函数调用是先int y再int x","like_count":0},{"had_liked":false,"id":32678,"user_name":"山书压力大","can_delete":false,"product_type":"c1","uid":1251469,"ip_address":"","ucode":"A27708DA94E7C5","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/8d/9a0fb6ae.jpg","comment_is_top":false,"comment_ctime":1539661950,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539661950","product_id":100017301,"comment_content":"栈在函数调用那，为什么是y先入栈，x后入栈阿","like_count":0},{"had_liked":false,"id":32485,"user_name":"象牙塔下的渣渣","can_delete":false,"product_type":"c1","uid":1248575,"ip_address":"","ucode":"B87FC8A56D29CB","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/3f/d2accda7.jpg","comment_is_top":false,"comment_ctime":1539588425,"is_pvip":false,"replies":[{"id":"11886","content":"print写的有问题吧 print之后topnode已经指向nil了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539615779,"ip_address":"","comment_id":32485,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539588425","product_id":100017301,"comment_content":"求解答！！！<br>测试代码：<br>func TestLinkedListStack_Pop(t *testing.T) {<br>\ts := NewLinkedListStack()<br>\ts.Push(1)<br>\ts.Push(2)<br>\ts.Push(3)<br>\ts.Push(4)<br>\ts.Print()<br><br>\t&#47;&#47;t.Log(s.Pop())<br>\tfmt.Println(s.Pop())<br>\ts.Print()<br>\tt.Log(s.Pop())<br>\tt.Log(s.Pop())<br>\tt.Log(s.Pop())<br>\t&#47;&#47;s.Print()<br>}<br>后面打印和取出的数据为什么是空的？<br>输出结果：<br>4<br>3<br>2<br>1<br>&lt;nil&gt;<br>empty stack<br>\tStackBasedOnLinkedList_test.go:28: &lt;nil&gt;<br>\tStackBasedOnLinkedList_test.go:29: &lt;nil&gt;<br>\tStackBasedOnLinkedList_test.go:30: &lt;nil&gt;<br><br>Process finished with exit code 0<br><br>源码中与您写的代码唯一不同的是Print()，代码如下：<br>func (this *LinkedListStack) Print() {<br>\tif this.IsEmpty() {<br>\t\tfmt.Println(&quot;empty stack&quot;)<br>\t} else {<br>\t\tfor this.topNode != nil {<br>\t\t\tfmt.Println(this.topNode.val)<br>\t\t\tthis.topNode = this.topNode.next<br>\t\t}<br>\t}<br>}<br><br>上面的输出情况是怎么回事？跟这个Print()方法有关吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426790,"discussion_content":"print写的有问题吧 print之后topnode已经指向nil了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539615779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32469,"user_name":"i d o L i c e🐣","can_delete":false,"product_type":"c1","uid":1228740,"ip_address":"","ucode":"68586BBB836556","user_header":"https://static001.geekbang.org/account/avatar/00/12/bf/c4/c72b2f40.jpg","comment_is_top":false,"comment_ctime":1539583406,"is_pvip":false,"replies":[{"id":"11874","content":"也可以的 👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539614785,"ip_address":"","comment_id":32469,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539583406","product_id":100017301,"comment_content":"老师这个浏览器abc页面用双向链表来实现不也是可以的么？a&lt;-&gt;b&lt;-&gt;c？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426783,"discussion_content":"也可以的 👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539614785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32318,"user_name":"黑桃K","can_delete":false,"product_type":"c1","uid":1234939,"ip_address":"","ucode":"1439F7F46B4982","user_header":"https://static001.geekbang.org/account/avatar/00/12/d7/fb/384ef0a1.jpg","comment_is_top":false,"comment_ctime":1539529108,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539529108","product_id":100017301,"comment_content":"总结：<br>只涉及一端插入删除数据，满足filo，lifo原则，首选栈。<br>栈的数组和链表实现，顺序栈，链式栈，时间空间复杂度都是o（1），可自动扩容顺序栈，均摊时间复杂度o（1）。<br>栈的应用，函数调用栈，操作符运算，括号匹配。<br>习题：<br>函数调用栈，递归时后面的函数先出栈返回结果，所以适合用栈，具体后面看老师的解答！另外，代码中括号匹配部分感觉有一种测试用例无法检测不匹配，后面再关注提问！先记下。还有评论中关于运算符有小括号问题，也需要关注一下！右括号作为最高优先级。<br>jvm的堆栈是内存中的数据格式，不是数据结构中的栈，内存分为，代码区，静态数据区，动态数据区，动态包括堆和栈，栈是局部变量等，系统自动释放，堆由程序员释放，是new出来的一些对象","like_count":0},{"had_liked":false,"id":32277,"user_name":"沙皮狗","can_delete":false,"product_type":"c1","uid":1258426,"ip_address":"","ucode":"7DA4874A671224","user_header":"https://static001.geekbang.org/account/avatar/00/13/33/ba/bed49591.jpg","comment_is_top":false,"comment_ctime":1539510380,"is_pvip":false,"replies":[{"id":"11743","content":"因为要从原来的栈将这k个数据搬移到新的栈中","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539528093,"ip_address":"","comment_id":32277,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539510380","product_id":100017301,"comment_content":"如果当前栈大小为 K，并且已满，当再有新的数据要入栈时，就需要重新申请 2 倍大小的内存，并且做 K 个数据的搬移操作，然后再入栈。但是，接下来的 K-1 次入栈操作，我们都不需要再重新申请内存和搬移数据，所以这 K-1 次入栈操作都只需要一个 simple-push 操作就可以完成。<br>为什么要做k个数据搬移，老师，可以解释一下吗","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426712,"discussion_content":"因为要从原来的栈将这k个数据搬移到新的栈中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539528093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32231,"user_name":"每天学英语的小沈","can_delete":false,"product_type":"c1","uid":1024179,"ip_address":"","ucode":"C58FA38D8272FA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a0/b3/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1539490322,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539490322","product_id":100017301,"comment_content":"方法调用用栈是比较合理的，因为后进先出，局部变量用栈来存储合适吗，请教老师，因为你定义的变量离你使用的时候比较远，是不是得把中间的内容遍历一遍才能获取到，是不是比较麻烦","like_count":0},{"had_liked":false,"id":32229,"user_name":"每天学英语的小沈","can_delete":false,"product_type":"c1","uid":1024179,"ip_address":"","ucode":"C58FA38D8272FA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a0/b3/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1539489942,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539489942","product_id":100017301,"comment_content":"表达式的那个例子，如果运算优先级并不是只有加减和乘除两级，难道是需要更多的栈来回倒吗？有几级优先级运算，最多就需要几个栈","like_count":0},{"had_liked":false,"id":32219,"user_name":"kaoker","can_delete":false,"product_type":"c1","uid":1115225,"ip_address":"","ucode":"499060AE9A4B2C","user_header":"","comment_is_top":false,"comment_ctime":1539486723,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539486723","product_id":100017301,"comment_content":"jvm的堆栈是一个存储数据的区域,java编程思想中已经有说明,存放的是句柄和局部变量存放到堆栈内.<br>堆栈。驻留于常规RAM（随机访问存储器）区域，但可通过它的“堆栈指针”获得处理的直 接支持。堆栈指针若向下移，会创建新的内存；若向上移，则会释放那些内存。这是一种特 别快、特别有效的数据保存方式，仅次于寄存器。创建程序时，Java编译器必须准确地知道堆 栈内保存的所有数据的“长度”以及“存在时间”。<br>我们这里说的栈是一种数据结构.<br>可能两者的行为一致,先进后出.<br><br>","like_count":0},{"had_liked":false,"id":32203,"user_name":"鹏程万里","can_delete":false,"product_type":"c1","uid":1114675,"ip_address":"","ucode":"5E23BBEC9E8209","user_header":"https://static001.geekbang.org/account/avatar/00/11/02/33/57678ea3.jpg","comment_is_top":false,"comment_ctime":1539483753,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539483753","product_id":100017301,"comment_content":"所以数据结构中的堆栈和JVM中的堆栈的是相同的吗？有没有什么共同点？","like_count":0},{"had_liked":false,"id":31985,"user_name":"A_阿海","can_delete":false,"product_type":"c1","uid":1239200,"ip_address":"","ucode":"5594C992D7E6E9","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/a0/c2daafdb.jpg","comment_is_top":false,"comment_ctime":1539349402,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539349402","product_id":100017301,"comment_content":"感觉算法和数据结构越研究越会有新的感觉。","like_count":0},{"had_liked":false,"id":31983,"user_name":"zgzzbws","can_delete":false,"product_type":"c1","uid":1191109,"ip_address":"","ucode":"40C12BBF896C07","user_header":"https://static001.geekbang.org/account/avatar/00/12/2c/c5/db347b46.jpg","comment_is_top":false,"comment_ctime":1539349059,"is_pvip":false,"replies":[{"id":"11591","content":"add执行完之后会先出栈，printf再入栈","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539401573,"ip_address":"","comment_id":31983,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539349059","product_id":100017301,"comment_content":"老师，有个问题，在函数调用的例子里，main函数依次调用了add和printf；那这两个函数在栈中是什么顺序呢？如果二者依次被压入栈，printf在add之上，则先执行printf，此时res还没有被赋值；还是说add会先岀栈执行，然后压入printf。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426593,"discussion_content":"add执行完之后会先出栈，printf再入栈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539401573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31769,"user_name":"程序修行","can_delete":false,"product_type":"c1","uid":1257409,"ip_address":"","ucode":"2CCD5ACAFF0E8D","user_header":"","comment_is_top":false,"comment_ctime":1539302381,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539302381","product_id":100017301,"comment_content":"请教一个问题，老师：为什么函数形参进栈的顺序是从右到左的呢？","like_count":0},{"had_liked":false,"id":31724,"user_name":"Flying","can_delete":false,"product_type":"c1","uid":1239009,"ip_address":"","ucode":"2E9D9813E329E1","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/e1/2e27eabf.jpg","comment_is_top":false,"comment_ctime":1539271815,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539271815","product_id":100017301,"comment_content":"3+5*8-6 运算时<br>运算符优先级的问题刚开始没想明白，后来换个理解的方式: 从左至右扫描表达式，+ 号推入栈中，* 比 + 优先级更高，也推入栈中（此时 * 在栈顶），当扫描到 - 时（可以假设 - 也推入栈中，在这个假设下从栈底到栈顶的排序是 + * -  因为 * 左右两边的运算符优先级都没有比它高，所以扫描到 - 时用 * 运算数值栈中的数值）<br>不能添加图片，可能有点乱😂","like_count":0},{"had_liked":false,"id":31711,"user_name":"Tattoo","can_delete":false,"product_type":"c1","uid":1036503,"ip_address":"","ucode":"CE926AC8582C96","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d0/d7/a09ef784.jpg","comment_is_top":false,"comment_ctime":1539268880,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1539268880","product_id":100017301,"comment_content":"结合代码讲解很赞！！！！","like_count":0},{"had_liked":false,"id":31702,"user_name":"纯洁的憎恶","can_delete":false,"product_type":"c1","uid":1130512,"ip_address":"","ucode":"5E9757DE6F45DF","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/10/b6bf3c3c.jpg","comment_is_top":false,"comment_ctime":1539267605,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1539267605","product_id":100017301,"comment_content":"内存的堆栈我略知一二。但是，数据结构的堆栈仅指的是栈？还是既有堆也有栈？那数据结构的堆是什么？","like_count":0},{"had_liked":false,"id":31697,"user_name":"纯洁的憎恶","can_delete":false,"product_type":"c1","uid":1130512,"ip_address":"","ucode":"5E9757DE6F45DF","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/10/b6bf3c3c.jpg","comment_is_top":false,"comment_ctime":1539266561,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1539266561","product_id":100017301,"comment_content":"记录：<br>内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。<br>内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区。<br>代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。<br>静态数据区：存储全局变量、静态变量、常量，常量包括final修饰的常量和String常量。系统自动分配和回收。<br>栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。<br>堆区：new一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。","like_count":0},{"had_liked":false,"id":31669,"user_name":"宋意","can_delete":false,"product_type":"c1","uid":1229043,"ip_address":"","ucode":"2CCFDB02BA8ADF","user_header":"https://static001.geekbang.org/account/avatar/00/12/c0/f3/281ccb06.jpg","comment_is_top":false,"comment_ctime":1539260301,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539260301","product_id":100017301,"comment_content":"存在就是合理，栈适合先进后出这种特殊的应用场景。被用到的变量或者函数一定是在最上面的，这样使用栈方便获取，使用完毕之后，删除也更容易。用其他数组和链表完全可以实现，只是效率会低些，对于数组对于变量数很多，数组需要经常扩容，效率低下。使用链表是可以，但是我觉着内存不连续，不利于操作系统处理。","like_count":0},{"had_liked":false,"id":31632,"user_name":"liangjf","can_delete":false,"product_type":"c1","uid":1058812,"ip_address":"","ucode":"681A6CCF098F55","user_header":"https://static001.geekbang.org/account/avatar/00/10/27/fc/b8d83d56.jpg","comment_is_top":false,"comment_ctime":1539249757,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539249757","product_id":100017301,"comment_content":"函数调用使用栈数据结构的实质是 函数调用可能递归调用。需要存储每层调用的结果供上一层使用。这就是 栈 先进后出，后进先出的特点","like_count":0},{"had_liked":false,"id":31631,"user_name":"liangjf","can_delete":false,"product_type":"c1","uid":1058812,"ip_address":"","ucode":"681A6CCF098F55","user_header":"https://static001.geekbang.org/account/avatar/00/10/27/fc/b8d83d56.jpg","comment_is_top":false,"comment_ctime":1539249756,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539249756","product_id":100017301,"comment_content":"函数调用使用栈数据结构的实质是 函数调用可能递归调用。需要存储每层调用的结果供上一层使用。这就是 栈 先进后出，后进先出的特点","like_count":0},{"had_liked":false,"id":31615,"user_name":"柠檬C","can_delete":false,"product_type":"c1","uid":1181505,"ip_address":"","ucode":"BC0EE704D952A4","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/41/2d477385.jpg","comment_is_top":false,"comment_ctime":1539245898,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539245898","product_id":100017301,"comment_content":"个人理解，1:函数a调用另一个函数b后，需要先完成b中的代码并返回，再继续执行a剩下的代码。b比a后进入程序的视野，却先a一步执行完毕，符合栈后进先出的特点<br>2:jvm虚拟机栈存储局部变量和方法出入口等，这2个的特点是紧跟方法的生命周期，结合上个问题的描述，在方法的连锁调用中，被调用的方法总是先执行完成，用栈来储存再合适不过","like_count":0},{"had_liked":false,"id":31600,"user_name":"★葚璳阗☆塍","can_delete":false,"product_type":"c1","uid":1248213,"ip_address":"","ucode":"CCEAA1AB48989D","user_header":"https://static001.geekbang.org/account/avatar/00/13/0b/d5/39c3a496.jpg","comment_is_top":false,"comment_ctime":1539242034,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539242034","product_id":100017301,"comment_content":"思考题1:用链表实现每次需要末尾插入删除时，需要耗时间找到末尾结点 ，数组插入和删除耗时<br>思考题2:内存中的栈从高位到地位，存储一些局部临时变量，不断的压入和弹出的方式实现程序的运行和内存的自动回收，类似于“栈”","like_count":0},{"had_liked":false,"id":31560,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1539228914,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539228914","product_id":100017301,"comment_content":"思考1：<br>通过栈区来保存临时变量会方便函数调用结束时，变量的内存会随着出栈而得到释放。<br>思考2：<br>JVM里面的栈和文章中的栈我认为是一回事的。以线程为单位，每个线程都有自己的方法调用栈，工作过程也和栈的概念一样。这个问题我自己也没有十足把握，期待老师后面进一步讲解。","like_count":0},{"had_liked":false,"id":31541,"user_name":"行走着的宋公子","can_delete":false,"product_type":"c1","uid":1002416,"ip_address":"","ucode":"3FA47B1580A327","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4b/b0/2ae78627.jpg","comment_is_top":false,"comment_ctime":1539224454,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539224454","product_id":100017301,"comment_content":"栈的受限调用模式，符合程序中函数调用顺序，先入后执行，后入先执行，同时也方便错误追踪。","like_count":0},{"had_liked":false,"id":31106,"user_name":"勤劳的小胖子-libo","can_delete":false,"product_type":"c1","uid":1158344,"ip_address":"","ucode":"5BB20CD5A56568","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/c8/4b1c0d40.jpg","comment_is_top":false,"comment_ctime":1539092329,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539092329","product_id":100017301,"comment_content":"1:因为是临时变量，也就是只是同一层的作用范围之内有效，函数返回的时候自动使之无效，所以要使用栈。另外，可能跟底层硬件sp结构相对应。<br>2:我猜在jvm自己申请了一段内存作栈堆，自己来控制何时何地清理，而不是栈由操作系统默认的，堆由程序员自己控制，主要是出于性能以及出于对指针以及引用更智能化的收集吧","like_count":0},{"had_liked":false,"id":31084,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1539085610,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539085610","product_id":100017301,"comment_content":"哈哈哈 突然想到 如果不把函数调用放到栈区里面取 那么所用的内存啥的不会释放，也就不会存在什么生命周期之说，竟然不释放，这么搞下去跟内存泄漏没啥区别了呀 不知道理解得对不对","like_count":0},{"had_liked":false,"id":31082,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1539084147,"is_pvip":false,"replies":[{"id":"11238","content":"线程栈是不是内存空间 他是分配给进程的  所有线程共享的 还是分配给线程 线程独享的？","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539136954,"ip_address":"","comment_id":31082,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539084147","product_id":100017301,"comment_content":"操作系统原理书上也写了 线程是进程的组成部分 所以 老师说操作系统给线程分配内存一段独立的内存空间应该是不对的把？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426220,"discussion_content":"线程栈是不是内存空间 他是分配给进程的  所有线程共享的 还是分配给线程 线程独享的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539136954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31080,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1539083896,"is_pvip":false,"replies":[{"id":"11240","content":"我现在说的是局部变量呢 ","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539137024,"ip_address":"","comment_id":31080,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539083896","product_id":100017301,"comment_content":"操作系统中最小的资源分配单位不是进程么？  线程应该是执行在进程之上吧  不然为啥一个程序的多线程之间可以共享同一个全局变量？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426219,"discussion_content":"我现在说的是局部变量呢 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539137024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31069,"user_name":"狼的诱惑","can_delete":false,"product_type":"c1","uid":1257043,"ip_address":"","ucode":"AE89DFC5963C42","user_header":"https://static001.geekbang.org/account/avatar/00/13/2e/53/bf62683f.jpg","comment_is_top":false,"comment_ctime":1539080498,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539080498","product_id":100017301,"comment_content":"对于每次留下的思考题都希望老师在n（n&gt;1）天后给出权威的答案，谢谢。","like_count":0},{"had_liked":false,"id":31065,"user_name":"SunshlnW","can_delete":false,"product_type":"c1","uid":1211252,"ip_address":"","ucode":"7B82BBC5F30633","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/74/63563202.jpg","comment_is_top":false,"comment_ctime":1539079143,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539079143","product_id":100017301,"comment_content":"思考题：<br>1、为什么使用栈，这个问题有点类似老师前面介绍的，是为了给特定场景的抽象。操作系统函数调用符合后进先出，先进后出等特点，利用栈方便管理，同时可以防止保留太多接口，防止程序执行出错。<br>2、JVM里的栈是栈这种数据结构的应用吧，本质感觉没有多大区别。<br>希望老师下节课可以其进行讲解！","like_count":0},{"had_liked":false,"id":31028,"user_name":"后端进阶","can_delete":false,"product_type":"c1","uid":1125656,"ip_address":"","ucode":"480F48F5378307","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/18/918eaecf.jpg","comment_is_top":false,"comment_ctime":1539072022,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539072022","product_id":100017301,"comment_content":"用单项链表实现了一个链式栈（建议极客开发一个代码风格的留言样式）：<br><br>public class SinglyLinkedStack&lt;V&gt; {<br>    private int count; &#47;&#47; 栈中元素个数<br>    private Node&lt;V&gt; bottom = null; &#47;&#47; 栈底<br>    private Node&lt;V&gt; top = null; &#47;&#47; 栈顶<br><br>    private static class Node&lt;V&gt; {<br>        V value;<br>        Node&lt;V&gt; next;<br>        public Node(V node) {<br>            this.value = node;<br>            this.next = null;<br>        }<br>    }<br><br>    public boolean push(V value) {<br>        if (bottom == null) {<br>            this.bottom = new Node&lt;&gt;(value);<br>            this.top = bottom;<br>        } else {<br>            Node&lt;V&gt; l = top;<br>            Node&lt;V&gt; newNode = new Node&lt;&gt;(value);<br>            this.top = newNode;<br>            l.next = newNode;<br>        }<br>        count++;<br>        return true;<br>    }<br><br>    public V pop() {<br>        if (top == null) {<br>            return null;<br>        }<br>        V value = top.value;<br>        if (bottom == top) {<br>            bottom.value = null;<br>            bottom = null;<br>            top.value = null;<br>            top = null; &#47;&#47; help gc<br>            count--;<br>            return value;<br>        }<br>        int pos = 1;<br>        Node&lt;V&gt; n = bottom;<br>        while (pos != (count - 1)) { &#47;&#47; 查找到倒数第二个节点<br>            pos++;<br>            n = n.next;<br>        }<br>        top.value = null; &#47;&#47; help gc<br>        top.next = null;<br>        n.next = null;<br>        top = n;<br>        count--;<br>        return value;<br>    }<br>}","like_count":0},{"had_liked":false,"id":31027,"user_name":"polk","can_delete":false,"product_type":"c1","uid":1165455,"ip_address":"","ucode":"1B6E948BA4DFAF","user_header":"https://static001.geekbang.org/account/avatar/00/11/c8/8f/e13a6552.jpg","comment_is_top":false,"comment_ctime":1539071959,"is_pvip":false,"replies":[{"id":"11171","content":"应计算公式的不好想 但是浏览器的还好吧 多看多想 慢慢就能想到了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539082600,"ip_address":"","comment_id":31027,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539071959","product_id":100017301,"comment_content":"用2个栈实现计算公式，实现浏览器返回前进，挺巧妙的。问题是，我想不到啊。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426190,"discussion_content":"应计算公式的不好想 但是浏览器的还好吧 多看多想 慢慢就能想到了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539082600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31015,"user_name":"DebugDog","can_delete":false,"product_type":"c1","uid":1027798,"ip_address":"","ucode":"1664D37CE03B9D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/d6/fbb8236d.jpg","comment_is_top":false,"comment_ctime":1539067043,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1539067043","product_id":100017301,"comment_content":"函数的递归调用也是用的栈技术吧","like_count":0},{"had_liked":false,"id":31001,"user_name":"zixuan","can_delete":false,"product_type":"c1","uid":1131300,"ip_address":"","ucode":"C72920DD05B074","user_header":"https://static001.geekbang.org/account/avatar/00/11/43/24/3f9f7c70.jpg","comment_is_top":false,"comment_ctime":1539062574,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539062574","product_id":100017301,"comment_content":"为什么函数要用栈来保存变量，原因很简单：在调用链中，后被调(call)的函数要先返回(ret)，亦即后入先出！  <br>打破这一规则的有其他场景有异常处理、协程等。","like_count":0},{"had_liked":false,"id":30961,"user_name":"顾言","can_delete":false,"product_type":"c1","uid":1184481,"ip_address":"","ucode":"79DDEDCADD1F49","user_header":"https://static001.geekbang.org/account/avatar/00/12/12/e1/6d0114fe.jpg","comment_is_top":false,"comment_ctime":1539053281,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1539053281","product_id":100017301,"comment_content":"1.函数调用满足后进先出的原理。比如main-&gt;a-&gt;b,这样的话就是b先执行，然后退出栈，接下来一次是a,main。如果用其它数据结构，比如数组和链表，可以随机访问，没有单方向操作这个限制条件，多次操作容易出错。时间复杂度方面，数组还好，如果是按调用顺序存储的，可以直接根据下标取最后进入的值，但是链表就要每次都遍历一次，找到当前结点的前结点，时间复杂度变为O(n)。<br><br>2.jvm的栈和这里的栈是一个概念，调用方法和存储局部变量。就像其它语言存储调用函数和局部变量一样的概念。","like_count":0},{"had_liked":false,"id":30956,"user_name":"良辰美景","can_delete":false,"product_type":"c1","uid":1074803,"ip_address":"","ucode":"B36E6955A2872D","user_header":"https://static001.geekbang.org/account/avatar/00/10/66/73/fd1e37a2.jpg","comment_is_top":false,"comment_ctime":1539052455,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539052455","product_id":100017301,"comment_content":"为什么要用栈:<br>1：栈操作简单，只需要维护一个栈顶指针，而队列需要维护队首与队尾<br>2：函数中的操作数入栈顺序应该是经过编译器调整的吧？比如下面的代码：<br>\t\tint a = 11;<br>        int b = 12;<br>        int c = 13;<br>        int res = a + c;<br>\t\tint ret = b + res;","like_count":0},{"had_liked":false,"id":30934,"user_name":"Marnie","can_delete":false,"product_type":"c1","uid":1001912,"ip_address":"","ucode":"ECF9B22574F868","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/b8/fb19aa6a.jpg","comment_is_top":false,"comment_ctime":1539049406,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539049406","product_id":100017301,"comment_content":"顺序栈扩容，最好情况时间复杂度为1，最坏情况时间复杂度是n。<br>假如原始栈大小为k。<br>栈满时，假如扩容至原来容量的2倍，即扩容后容量为2k。<br>执行扩容操作，需要申请大小为2k的内存，然后执行k次的搬移操作，时间复杂度为k。<br>扩容后的k-1次入栈操作，时间复杂度为1。<br>将扩容操作的时间复杂度k，均摊在之后的k-1次入栈操作上，可知均摊复杂度为1,即最好情况时间复杂度。<br>如2k容量的栈满员，就要再次进行扩容操作，扩容后栈容量为4k。<br>扩容操作的时间复杂度是2k，但接下来的2k-1次操作的时间复杂度为1，所以入栈操作的均摊时间复杂度是1.<br>","like_count":0},{"had_liked":false,"id":30868,"user_name":"孙立中","can_delete":false,"product_type":"c1","uid":1191323,"ip_address":"","ucode":"F71A79B26E7FB9","user_header":"https://static001.geekbang.org/account/avatar/00/12/2d/9b/5c71826c.jpg","comment_is_top":false,"comment_ctime":1539018534,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539018534","product_id":100017301,"comment_content":"我觉得就是一个东西。文中讲到的加减乘除运算，和Java的函数调用栈很像啊。运算符类比方法，数字类比变量。还是一个道理的，方法可以嵌套，类比运算符的优先级。就是","like_count":0},{"had_liked":false,"id":30838,"user_name":"后端进阶","can_delete":false,"product_type":"c1","uid":1125656,"ip_address":"","ucode":"480F48F5378307","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/18/918eaecf.jpg","comment_is_top":false,"comment_ctime":1539008068,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539008068","product_id":100017301,"comment_content":"通俗易懂，感谢老师！","like_count":0},{"had_liked":false,"id":30830,"user_name":"罗爱军","can_delete":false,"product_type":"c1","uid":1114611,"ip_address":"","ucode":"62D5529DDDA8DC","user_header":"https://static001.geekbang.org/account/avatar/00/11/01/f3/233f1287.jpg","comment_is_top":false,"comment_ctime":1539006670,"is_pvip":false,"replies":[{"id":"11133","content":"是的 套路都是一样的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539052791,"ip_address":"","comment_id":30830,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539006670","product_id":100017301,"comment_content":"老师，动态扩容顺序栈例子也解释了04节的课后习题了，数组拷贝均摊后时间复杂度为O（1），数组插入的时间复杂度也为O（1），所以整体的时间复杂度为O（1）","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426113,"discussion_content":"是的 套路都是一样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539052791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30812,"user_name":"Zix","can_delete":false,"product_type":"c1","uid":1025719,"ip_address":"","ucode":"48BB6A7F1352CB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a6/b7/e0c9be64.jpg","comment_is_top":false,"comment_ctime":1539001923,"is_pvip":false,"replies":[{"id":"11071","content":"😄 没听说过这个。应该没啥影响吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539003416,"ip_address":"","comment_id":30812,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539001923","product_id":100017301,"comment_content":"局部变量的声明顺序要和使用顺序相反，效率最高？老师，是这样的吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426107,"discussion_content":"😄 没听说过这个。应该没啥影响吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539003416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30792,"user_name":"wean","can_delete":false,"product_type":"c1","uid":1239735,"ip_address":"","ucode":"3E069F95C25EAD","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/b7/1f7316e6.jpg","comment_is_top":false,"comment_ctime":1538998444,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538998444","product_id":100017301,"comment_content":"基础不够，对课后思考不是很明白，希望老师可以讲解一下","like_count":0},{"had_liked":false,"id":30782,"user_name":"xxl","can_delete":false,"product_type":"c1","uid":1030389,"ip_address":"","ucode":"D83701AE29FFB1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b8/f5/eff71098.jpg","comment_is_top":false,"comment_ctime":1538996706,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538996706","product_id":100017301,"comment_content":"stackoverflow","like_count":0},{"had_liked":false,"id":30749,"user_name":"🐱您的好友William🐱","can_delete":false,"product_type":"c1","uid":1215456,"ip_address":"","ucode":"427786DB178965","user_header":"https://static001.geekbang.org/account/avatar/00/12/8b/e0/9a79ddac.jpg","comment_is_top":false,"comment_ctime":1538988053,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538988053","product_id":100017301,"comment_content":"老师讲的公式实现的那道题其实也可以用分而治之的思想，在函数里面嵌套自己实现，其实也是栈，但是应该是一个栈。。。遥想当年面试，实习面试官问了这道题，我写了无数个函数，悔不当初啊。。。哎。。。","like_count":0},{"had_liked":false,"id":30696,"user_name":"吕宁","can_delete":false,"product_type":"c1","uid":1248542,"ip_address":"","ucode":"5C36EFF6961E63","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/1e/7f2d5872.jpg","comment_is_top":false,"comment_ctime":1538977758,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538977758","product_id":100017301,"comment_content":"老师好，关于平均复杂度和摊还分析可不可以这么理解？前者是极端情况O(1)，所以不能平均分摊到n个case上。典型例子为线性查找;后者是极端情况为O(n)，而且紧跟着n个O(1)的操作，可以均摊，故平均为O(1)。典型例子为可扩容数组的插入？","like_count":0},{"had_liked":false,"id":30672,"user_name":"Mr.Panda","can_delete":false,"product_type":"c1","uid":1238864,"ip_address":"","ucode":"655A3013B5E849","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/50/d476ed6c.jpg","comment_is_top":false,"comment_ctime":1538970712,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538970712","product_id":100017301,"comment_content":"打卡，理论已学完，下面就是实操了，下午抽时间，完成顺序栈和链式栈，然后基于自己的栈，实现四则运算和括号嵌套合法性检测。","like_count":0},{"had_liked":false,"id":30660,"user_name":"徐凯","can_delete":false,"product_type":"c1","uid":1244991,"ip_address":"","ucode":"12F82BA3649CD5","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/3f/bbb8a88c.jpg","comment_is_top":false,"comment_ctime":1538967008,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538967008","product_id":100017301,"comment_content":"楼主    局部变量和临时变量的区别  c++返回对象时会有个临时对象   这个应该和函数内的局部变量区分开来。","like_count":0},{"had_liked":false,"id":30614,"user_name":"涛","can_delete":false,"product_type":"c1","uid":1245815,"ip_address":"","ucode":"555B9877F6AA4D","user_header":"https://static001.geekbang.org/account/avatar/00/13/02/77/f307372e.jpg","comment_is_top":false,"comment_ctime":1538960409,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538960409","product_id":100017301,"comment_content":"对于思考题 栈的本质是解决 需要有顺序访问的一种数据结构，程序的运行是按照顺序执行的。当然其他的数据结构也能实现顺序访问，只是代价比栈高而已😊","like_count":0},{"had_liked":false,"id":30580,"user_name":"五岳寻仙","can_delete":false,"product_type":"c1","uid":1247467,"ip_address":"","ucode":"88A46A4E1832CE","user_header":"https://static001.geekbang.org/account/avatar/00/13/08/eb/594e9e6c.jpg","comment_is_top":false,"comment_ctime":1538954830,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538954830","product_id":100017301,"comment_content":"函数调用为何要用栈保存临时变量？<br>我觉得是基于函数调用“先进后出”的逻辑：主调函数先放入内存中，当遇到被调函数时，被调函数被放入内存，创建变量，执行完运算并销毁局部变量后返回结果，主调函数才能继续往下运行。","like_count":0},{"had_liked":false,"id":30572,"user_name":"Rain","can_delete":false,"product_type":"c1","uid":1238221,"ip_address":"","ucode":"6A270D922A3B9D","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","comment_is_top":false,"comment_ctime":1538928679,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538928679","product_id":100017301,"comment_content":"浏览器的前进后退很像命令模式中的命令栈的设计。<br><br>课后思考题都不确定，等老师和大牛来解惑。","like_count":0}]}