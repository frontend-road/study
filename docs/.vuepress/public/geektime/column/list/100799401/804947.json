{"id":804947,"title":"07｜乱码是怎么产生的，以及如何避免？","content":"<p>你好，我是俊达。</p><p>不知道你在平时工作中是否遇到过乱码问题？我最早遇到的乱码问题还是刚开始学C语言编程时，有时候在Console上会输出“烫烫烫”这样的信息。在使用MySQL时，也遇到过各种乱码，乱码可能会以不同的形式出现。</p><p>那么在这一讲中，我们就来分析MySQL中出现乱码的几种不同情况，以及乱码产生的底层原因，从而掌握处理和避免乱码问题的方法。</p><h1>编码与解码</h1><p>平时我们会使用文字和符号来进行交流，比如“中文符号”就是一个有明确含义的词组。我们也知道计算机底层是使用二进制来存储和传输数据，那么计算机如何以二进制的形式来表示“中文符号”这个词组呢？这就涉及到字符的编码了。对于中文字符，比较常用的编码方式就包括GBK、UTF8，当然也包括其他一些编码方式，但我们这里就不过多讨论了，因为底层原理是一样的。</p><p>“中文符号”使用GBK编码后，是这个样子的。</p><p><img src=\"https://static001.geekbang.org/resource/image/83/d7/8351b0187c81578f6b7e02dfe83618d7.png?wh=694x92\" alt=\"图片\"></p><p>而使用UTF8编码时，是这个样子的。</p><p><img src=\"https://static001.geekbang.org/resource/image/e9/31/e96d812d605a089e9738e056f5c2a231.png?wh=986x90\" alt=\"图片\"></p><p>我们可以在网上找到GBK的编码表，也可以找到Unicode的表，而Unicode可以用明确的算法转换成UTF8编码。这里我们提供一个简便的方法，使用Python(python2)来获取字符的编码。</p><pre><code class=\"language-plain\">### GBK\n&gt;&gt;&gt; u\"中文符号\".encode('gbk')\n'\\xd6\\xd0\\xce\\xc4\\xb7\\xfb\\xba\\xc5'\n\n### UTF8\n&gt;&gt;&gt; u\"中文符号\".encode('utf8')\n'\\xe4\\xb8\\xad\\xe6\\x96\\x87\\xe7\\xac\\xa6\\xe5\\x8f\\xb7'\n</code></pre><!-- [[[read_end]]] --><p>现在你应该已经知道编码的过程了。程序在处理文本信息时，还涉及到解码。解码是编码的反向操作，将二进制的数据解析成一个个的字符，比如上面这段GBK编码后的数据，解码后就得到了原始的信息。</p><pre><code class=\"language-plain\">&gt;&gt;&gt; '\\xd6\\xd0\\xce\\xc4\\xb7\\xfb\\xba\\xc5'.decode('gbk')\nu'\\u4e2d\\u6587\\u7b26\\u53f7'\n\n&gt;&gt;&gt; print '\\xd6\\xd0\\xce\\xc4\\xb7\\xfb\\xba\\xc5'.decode('gbk')\n中文符号\n</code></pre><p>到目前为止没有任何问题。但是我想请你思考一下：<strong>程序怎么知道一段特定的数据是采用哪种字符集编码的呢？</strong></p><p>实际上没有办法仅仅依赖数据本身就得知数据的编码方式。很多乱码问题就是弄错了字符集而导致的。</p><p>接着上面的例子，如果程序以为数据使用了UTF8编码（但是实际上并不是），就会出现这种情况。</p><pre><code class=\"language-plain\">&gt;&gt;&gt; '\\xd6\\xd0\\xce\\xc4\\xb7\\xfb\\xba\\xc5'.decode('utf8', errors='replace')\nu'\\ufffd\\ufffd\\ufffd\\u0137\\ufffd\\ufffd\\ufffd'\n\n&gt;&gt;&gt; print '\\xd6\\xd0\\xce\\xc4\\xb7\\xfb\\xba\\xc5'.decode('utf8', errors='replace')\n���ķ���\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/1f/70/1f2b512a9e092278146039f6c8812a70.png?wh=770x130\" alt=\"\"></p><p>由于这些数据中很多字节并不是合法的UTF8编码，无法解码成Unicode，便使用了符号“�”来代替。</p><p>类似的，如果原始数据使用了UTF8编码，但错误地使用了GBK来解码，就会出现这种情况。</p><pre><code class=\"language-plain\">&gt;&gt;&gt; '\\xe4\\xb8\\xad\\xe6\\x96\\x87\\xe7\\xac\\xa6\\xe5\\x8f\\xb7'.decode('gbk', errors='replace')\nu'\\u6d93\\ufffd\\u6783\\u7ed7\\ufe40\\u5f7f'\n\n&gt;&gt;&gt; print '\\xe4\\xb8\\xad\\xe6\\x96\\x87\\xe7\\xac\\xa6\\xe5\\x8f\\xb7'.decode('gbk', errors='replace')\n涓�枃绗﹀彿\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/cf/d9/cfae52e4415e6e11fa96030b078a30d9.png?wh=1056x134\" alt=\"\"></p><p>上面我们见到了乱码产生的一些情况，而现实中其实还存在着更复杂一些的情况。</p><p>比如，发送者使用GBK编码，接收者接收到数据后，使用UTF8解码，然后又将数据以UTF8的方式编码后返回给发送者。发送者接收到数据后，再使用GBK来解码，就会遇到经典的“<strong>锟斤拷</strong>”问题。</p><pre><code class=\"language-plain\">### 发送者编码(GBK)\n&gt;&gt;&gt; u\"中文符号\".encode('gbk')\n'\\xd6\\xd0\\xce\\xc4\\xb7\\xfb\\xba\\xc5'\n\n### 接收者解码(UTF8) 和 编码(UTF8)\n&gt;&gt;&gt; '\\xd6\\xd0\\xce\\xc4\\xb7\\xfb\\xba\\xc5'.decode('utf8',errors='replace').encode('utf8')\n'\\xef\\xbf\\xbd\\xef\\xbf\\xbd\\xef\\xbf\\xbd\\xc4\\xb7\\xef\\xbf\\xbd\\xef\\xbf\\xbd\\xef\\xbf\\xbd'\n\n### 发送者解码(GBK)\n&gt;&gt;&gt; print '\\xef\\xbf\\xbd\\xef\\xbf\\xbd\\xef\\xbf\\xbd\\xc4\\xb7\\xef\\xbf\\xbd\\xef\\xbf\\xbd\\xef\\xbf\\xbd'.decode('gbk')\n锟斤拷锟侥凤拷锟斤拷\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/72/bc/720c3db0376551183c48c2d8a6bc29bc.png?wh=1608x130\" alt=\"\"></p><p>类似的，有时可能还会遇到这种情况。</p><pre><code class=\"language-plain\">### 发送者编码(UTF8)\n&gt;&gt;&gt; u\"中文符号\".encode('utf8')\n'\\xe4\\xb8\\xad\\xe6\\x96\\x87\\xe7\\xac\\xa6\\xe5\\x8f\\xb7'\n\n### 接收者解码(GBK) 和 编码(UTF8)\n&gt;&gt;&gt; '\\xe4\\xb8\\xad\\xe6\\x96\\x87\\xe7\\xac\\xa6\\xe5\\x8f\\xb7'.decode('gbk', errors='replace').encode('utf8')\n'\\xe6\\xb6\\x93\\xef\\xbf\\xbd\\xe6\\x9e\\x83\\xe7\\xbb\\x97\\xef\\xb9\\x80\\xe5\\xbd\\xbf'\n\n### 发送者解码(GBK)\n&gt;&gt;&gt; '\\xe6\\xb6\\x93\\xef\\xbf\\xbd\\xe6\\x9e\\x83\\xe7\\xbb\\x97\\xef\\xb9\\x80\\xe5\\xbd\\xbf'.decode('gbk', errors='replace')\nu'\\u5a11\\u64c4\\u62f7\\u93cb\\u51aa\\u7cad\\u9515\\ufffd\\u5a07'\n\n&gt;&gt;&gt; print '\\xe6\\xb6\\x93\\xef\\xbf\\xbd\\xe6\\x9e\\x83\\xe7\\xbb\\x97\\xef\\xb9\\x80\\xe5\\xbd\\xbf'.decode('gbk', errors='replace')\n娑擄拷鏋冪粭锕�娇\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/dd/2e/dd5ab25e71b71b8fe5697c8da5ecfd2e.png?wh=1476x134\" alt=\"\"></p><h1>MySQL 如何处理文本数据？</h1><p>从上面的例子中可以看出，程序无法仅仅根据数据本身就知道具体的编码方式，而编码和解码时，如果使用了错误的字符集，就会出现乱码。</p><p>而MySQL处理文本数据时，存在一样的问题：</p><ul>\n<li>客户端发送过来的数据使用什么了编码格式？</li>\n<li>服务器端处理数据时，应该使用哪种编码格式？</li>\n<li>将数据存储到表里时，使用什么字符集进行编码？</li>\n<li>将查询结果发送给客户端时，又应该如何编码数据？</li>\n</ul><p>MySQL使用了一系列变量来告诉服务器，客户端发送过来的数据是怎么编码的，客户端希望接收到什么编码的数据。</p><p>表和列的字符集属性则告诉服务器，存储数据时应该怎么编码，读取数据时又应该怎么解码。</p><h2>字符集变量</h2><p>执行show variables命令就能查看到字符集相关的变量。</p><pre><code class=\"language-go\">mysql&gt; show variables like '%char%';\n+--------------------------+------------------------------------------------------+\n| Variable_name            | Value                                                |\n+--------------------------+------------------------------------------------------+\n| character_set_client     | utf8mb3                                              |\n| character_set_connection | utf8mb3                                              |\n| character_set_database   | big5                                                 |\n| character_set_filesystem | binary                                               |\n| character_set_results    | utf8mb3                                              |\n| character_set_server     | utf8mb4                                              |\n| character_set_system     | utf8mb3                                              |\n</code></pre><p>在MySQL中，想避免产生乱码，首先需要正确地设置这些变量。下面的表格对这些变量做了简要的说明。</p><p><img src=\"https://static001.geekbang.org/resource/image/b5/fb/b5f80390561dcbea1ec8286fa1597bfb.png?wh=1736x1432\" alt=\"图片\"></p><h2>表和列的字符集属性</h2><p>MySQL中，所有字符类型的字段都有对应的字符集属性。表和列的字符集属性规定了以何种编码存储字符类数据。如果表的字符集属性设置不对，也容易引起乱码。</p><p>建表的时候，如果我们不指定表或列的字符集，MySQL会基于一些规则来设置一个默认的字符集。</p><p><strong>规则1：</strong>建库时，如果不指定库的字符集，则根据参数character_set_server的配置来设置库的默认字符集。</p><pre><code class=\"language-go\">mysql&gt; show variables like '%character_set_server%';\n+----------------------+--------+\n| Variable_name        | Value  |\n+----------------------+--------+\n| character_set_server | latin1 |\n+----------------------+--------+\n1 row in set (0.00 sec)\n\n### 建库时指定字符集\nmysql&gt; create database db_latin;\nQuery OK, 1 row affected (0.00 sec)\n\n### 库的字符集从变量character_set_server中获取\nmysql&gt; show create database db_latin;\n+----------+--------------------------------------------------------------------------------------------------------+\n| Database | Create Database                                                                                        |\n+----------+--------------------------------------------------------------------------------------------------------+\n| db_latin | CREATE DATABASE `db_latin` /*!40100 DEFAULT CHARACTER SET latin1 */ /*!80016 DEFAULT ENCRYPTION='N' */ |\n+----------+--------------------------------------------------------------------------------------------------------+\n</code></pre><p><strong>规则2：</strong>建表时，如果不指定表的字符集，则以表所在的数据库的字符集作为表的默认字符集。</p><pre><code class=\"language-go\">### 指定库的字符集 UTF8\nmysql&gt; create database db_utf8 default character set utf8;\nQuery OK, 1 row affected, 1 warning (0.00 sec)\n\n### 库的字符集为GBK\nmysql&gt; create database db_gbk default character set gbk;\nQuery OK, 1 row affected (0.00 sec)\n\n### 建表时不指定字符集\nmysql&gt; create table db_utf8.t(a varchar(100));\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; create table db_gbk.t(a varchar(100));\nQuery OK, 0 rows affected (0.00 sec)\n\n### UTF8库中的表默认使用了UTF8字符集\nmysql&gt; show create table db_utf8.t\\G\n*************************** 1. row ***************************\n       Table: t\nCreate Table: CREATE TABLE `t` (\n  `a` varchar(100) DEFAULT NULL\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3\n1 row in set (0.01 sec)\n\n### GBK库中的表默认使用了GBK字符集\nmysql&gt; show create table db_gbk.t\\G\n*************************** 1. row ***************************\n       Table: t\nCreate Table: CREATE TABLE `t` (\n  `a` varchar(100) DEFAULT NULL\n) ENGINE=InnoDB DEFAULT CHARSET=gbk\n1 row in set (0.00 sec)\n</code></pre><p><strong>规则3：</strong>建表时，如果不指定字段的字符集，则字段的字符集设置为表的默认字符集。</p><p><strong>规则4：</strong>如果显式指定字段的字符集，则以指定的字符集为准。</p><pre><code class=\"language-go\">mysql&gt; alter table db_gbk.t add c1 varchar(10), \n   add  c2 varchar(10) character set utf8mb4;\nQuery OK, 0 rows affected (0.01 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\n### 列C2使用了跟表不一样的字符集。但一般我们建议不要这么用。\nmysql&gt; show create table db_gbk.t\\G\n*************************** 1. row ***************************\n       Table: t\nCreate Table: CREATE TABLE `t` (\n  `a` varchar(100) DEFAULT NULL,\n  `c1` varchar(10) DEFAULT NULL,\n  `c2` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL\n) ENGINE=InnoDB DEFAULT CHARSET=gbk\n1 row in set (0.00 sec)\n</code></pre><p>一般情况下，我们建议都在建表的时候显式指定表的字符集。同一个表的多个字段尽量使用相同的字符集，不混合使用多个字符集。同一个库里的多个表，也使用同样的字符集。混合使用不同的字符集就会导致一些问题：</p><ul>\n<li>容易发生乱码问题。</li>\n<li>表连接时可能会发生隐式类型转换，导致查询无法用到一些索引，从而影响查询的性能。关于这一点，后续的课程中还会有具体的例子，这里不再展开。</li>\n</ul><p>下面我们借助这个图，对文本数据在客户端、MySQL服务端、存储引擎之间的传输和处理时如何编码和解码做一个小结。</p><p><img src=\"https://static001.geekbang.org/resource/image/64/38/649745b726c909defaa74fa7fcbbf438.png?wh=1920x484\" alt=\"图片\"></p><ul>\n<li>服务端认为客户端发送过来的数据的字符集是character_set_client。</li>\n<li>如果character_set_connection和character_set_client设置不一样，MySQL Server端会将数据转换成character_set_connection指定的字符集。</li>\n<li>数据存储到表里时，根据表结构定义中指定的字符集进行转换。如果字符集一致，则这一步不需要进行转换。</li>\n<li>数据返回到客户端时，按character_set_results的设置进行编码。</li>\n</ul><h1>MySQL 中乱码是如何产生的？</h1><p>这里我们再来回顾一下前面讲解的几个关键点。</p><ol>\n<li>文本数据在传输、处理、存储时涉及到编码和解码的过程。</li>\n<li>编码和解码时，如果使用了错误的字符集，就会产生乱码。</li>\n<li>MySQL使用了一系列的变量来指定文本处理不同阶段使用的字符集。</li>\n<li>MySQL字符类型的字段都有对应的字符集属性，规定了存储数据时应该如何编码。</li>\n</ol><p>实际上，MySQL中会产生乱码，主要也是因为字符集相关的变量（character_set_client, character_set_connection，character_set_result）设置不正确，或者表和字段的字符集属性设置不对。</p><p>接下来，我们通过几个具体的例子来演示MySQL中乱码是如何产生的。在这些例子中，我们都会使用MySQL自带的客户端。应用程序从数据库读写数据时，过程基本上也是一样的。</p><p>我们先提供一个用来判断当前终端编码的简便方法，就是使用MySQL的hex函数。</p><p>这是一个GBK编码的终端。</p><pre><code class=\"language-plain\">mysql&gt; select hex('中文符号');\n+------------------+\n| hex('中文符号')  |\n+------------------+\n| D6D0CEC4B7FBBAC5 |\n+------------------+\n</code></pre><p>这是一个UTF8编码的终端。</p><pre><code class=\"language-plain\">mysql&gt;  select hex('中文符号');\n+--------------------------+\n| hex('中文符号')          |\n+--------------------------+\n| E4B8ADE69687E7ACA6E58FB7 |\n+--------------------------+\n</code></pre><h2>乱码情况 1：表的字符集属性设置错误</h2><p>下面这个例子中，因为表使用了latin1字符集，而latin1不支持中文，因此写入中文时会报错。</p><pre><code class=\"language-go\">mysql&gt; use db1;\nDatabase changed\nmysql&gt; create table t_latin(a varchar(100))charset latin1;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; insert into t_latin values('中文');\nERROR 1366 (HY000): Incorrect string value: '\\xE4\\xB8\\xAD\\xE6\\x96\\x87' for column 'a' at row 1\n</code></pre><p><strong>错误的解决方法：</strong>MySQL客户端执行将字符集改为latin1，然后再插入数据，看起来好像能正常读写中文了。</p><pre><code class=\"language-go\">mysql&gt; set names 'latin1';\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; insert into t_latin values('中文');\nQuery OK, 1 row affected (0.00 sec)\n\nmysql&gt; select * from t_latin;\n+--------+\n| a      |\n+--------+\n| 中文   |\n+--------+\n1 row in set (0.00 sec)\n</code></pre><p>这是错误的方法（只是作为一个例子演示，真实场景下千万不要这么做），有非常大的隐患。</p><p>首先统计字符数时，可以看到结果是不对的。</p><pre><code class=\"language-go\">mysql&gt; set names 'latin1';\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; select a, char_length(a)  from t_latin;\n+--------+----------------+\n| a      | char_length(a) |\n+--------+----------------+\n| 中文   |              6 |\n+--------+----------------+\n1 row in set (0.00 sec)\n</code></pre><p>而且在一个设置正常的环境下，读取到的数据会变成乱码。</p><pre><code class=\"language-go\">mysql&gt; select * from t_latin;\n+----------------+\n| a&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n+----------------+\n| ä¸­æ–‡&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|\n+----------------+\n1 row in set (0.00 sec)\n</code></pre><p>这个问题的根本原因在于，latin1字符集无法存储中文。解决方法就是使用能正确存储中文的字符集，比如GBK或UTF8。</p><p>如果你已经遇到这样的问题，可以使用一些方法进行补救。比如：</p><ol>\n<li>使用msyqldum导出数据，字符集指定为latin1。</li>\n</ol><pre><code class=\"language-plain\">mysqldump -uroot --default-character-set=latin1 db1 t_latin &gt; t_latin.sql\n</code></pre><ol start=\"2\">\n<li>\n<p>根据数据的原始编码，修改mysqldump生成的sql文件。在我们的案例中，原始编码为UTF8，可以这么修改。<br>\n<img src=\"https://static001.geekbang.org/resource/image/c7/77/c7044e412dbyye2087c20b4e8b5yy077.png?wh=1232x964\" alt=\"图片\"></p>\n</li>\n<li>\n<p>重新导入数据。</p>\n</li>\n</ol><pre><code class=\"language-plain\">mysql -uroot db1 &lt; t_latin.sql\n</code></pre><p>这样处理后，数据就恢复正常了。</p><pre><code class=\"language-plain\">mysql&gt; select a, char_length(a), hex(a) from t_latin;\n+--------+----------------+--------------+\n| a&nbsp; &nbsp; &nbsp; | char_length(a) | hex(a)&nbsp; &nbsp; &nbsp; &nbsp;|\n+--------+----------------+--------------+\n| 中文&nbsp; &nbsp;|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 | E4B8ADE69687 |\n+--------+----------------+--------------+\n</code></pre><p>当然，操作前需要先备份好数据。处理时，也需要先暂停应用程序，避免在处理过程中写入新的有问题的数据。</p><h2>乱码情况 2：character_set_result 和终端的编码不一致</h2><p>终端的字符编码为UTF8。</p><p><img src=\"https://static001.geekbang.org/resource/image/f3/e0/f37b24ecb8db7d0b38725accfbf570e0.png?wh=1100x240\" alt=\"图片\"></p><p>先准备一些（正确的）测试数据。</p><pre><code class=\"language-go\">mysql&gt; create table t_char1(a varchar(30)) charset utf8mb4;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; insert into t_char1 values('中文符号');\nQuery OK, 1 row affected (0.00 sec)\n\nmysql&gt; select a, hex(a) from t_char1;\n+--------------+--------------------------+\n| a            | hex(a)                   |\n+--------------+--------------------------+\n| 中文符号     | E4B8ADE69687E7ACA6E58FB7 |\n+--------------+--------------------------+\n1 row in set (0.00 sec)\n</code></pre><p>在UTF8环境下，如果character_set_results设置为GBK，查询数据时会看到乱码。</p><pre><code class=\"language-go\">mysql&gt; set character_set_results=gbk;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; select a,hex(a) from t_char1;\n+----------+--------------------------+\n| a        | hex(a)                   |\n+----------+--------------------------+\n| ���ķ��        | E4B8ADE69687E7ACA6E58FB7 |\n+----------+--------------------------+\n1 row in set (0.01 sec)\n</code></pre><p>由于character_set_results设置为GBK，MySQL将返回的数据以GBK方式编码。同时因为终端是UTF8环境，按UTF8编码的数据进行解码，但是UTF8编码无法解析这一串数据，无法解码的数据使用了符号“�”进行替代，因此我们看到了一串问号。</p><p>我们可以使用以下Python代码来模拟这个过程。</p><pre><code class=\"language-go\">&gt;&gt;&gt; u\"中文符号\".encode('gbk')\n'\\xd6\\xd0\\xce\\xc4\\xb7\\xfb\\xba\\xc5'\n\n&gt;&gt;&gt; u\"中文符号\".encode('gbk').decode('utf8', errors='replace')\nu'\\ufffd\\ufffd\\ufffd\\u0137\\ufffd\\ufffd\\ufffd'\n\n&gt;&gt;&gt; print u\"中文符号\".encode('gbk').decode('utf8', errors='replace')\n���ķ���\n</code></pre><p>反过来，如果我们使用了GBK终端，那么character_set_results需要设置为GBK。</p><p><img src=\"https://static001.geekbang.org/resource/image/e2/04/e2f5fyyb4023cf664f75ea5333fdab04.png?wh=1098x238\" alt=\"图片\"></p><pre><code class=\"language-go\">mysql&gt; set names gbk;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; select a,hex(a) from t_char1;\n+----------+--------------------------+\n| a        | hex(a)                   |\n+----------+--------------------------+\n| 中文符号        | E4B8ADE69687E7ACA6E58FB7 |\n+----------+--------------------------+\n1 row in set (0.00 sec)\n</code></pre><p>如果character_set_results设置为UTF8，则会出现另一种乱码的现象。</p><pre><code class=\"language-go\">mysql&gt; set character_set_results=utf8;\nQuery OK, 0 rows affected, 1 warning (0.00 sec)\n\nmysql&gt; select a,hex(a) from t_char1;\n+--------------+--------------------------+\n| a            | hex(a)                   |\n+--------------+--------------------------+\n| 涓枃绗﹀彿     | E4B8ADE69687E7ACA6E58FB7 |\n+--------------+--------------------------+\n1 row in set (0.00 sec)\n</code></pre><p>这种情况下，由于character_set_results为UTF8，因此MySQL将数据按UTF8方式进行编码后传输给客户端。但是由于客户端是GBK的编码，因此以GBK的方式对返回的数据进行解码。</p><p>下面的Python代码模拟了这个过程。</p><pre><code class=\"language-go\">&gt;&gt;&gt; u\"中文符号\".encode('utf8')\n'\\xe4\\xb8\\xad\\xe6\\x96\\x87\\xe7\\xac\\xa6\\xe5\\x8f\\xb7'\n\n&gt;&gt;&gt; u\"中文符号\".encode('utf8').decode('gbk', errors='replace')\nu'\\u6d93\\ufffd\\u6783\\u7ed7\\ufe40\\u5f7f'\n\n&gt;&gt;&gt; print u\"中文符号\".encode('utf8').decode('gbk', errors='replace')\n涓�枃绗﹀彿\n</code></pre><p>上面演示的这两种乱码现象，都是由于character_set_results的设置和真实环境的编码不匹配引起的。虽然看上去有乱码，但实际上数据库中存储的数据没有任何问题，因此解决方法也简单，只要将character_set_results的设置和终端的字符编码设置成一样就可以了。</p><h2>乱码情况 3：character_set_client 和终端的编码不一致</h2><p>如果character_set_client的设置和终端的编码不一致，那么在写入数据时，就会产生乱码。我们分两种情况来讨论。</p><h3>UTF8 终端，character_set_client 设置为GBK</h3><p>终端是UTF8编码，但是character_set_client错误地设置成了GBK，此时如果写入数据，可以发现insert语句产生了warning，提示编码转换存在问题。</p><pre><code class=\"language-go\">mysql&gt; create table t_utf8(a varchar(30)) charset utf8;\nQuery OK, 0 rows affected, 1 warning (0.02 sec)\n\nmysql&gt; set character_set_client='gbk';\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; insert into t_utf8 values('中文符号');\nQuery OK, 1 row affected, 1 warning (0.00 sec)\n\nmysql&gt; show warnings;\n+---------+------+-------------------------------------------------------------------------+\n| Level   | Code | Message                                                                 |\n+---------+------+-------------------------------------------------------------------------+\n| Warning | 1300 | Cannot convert string '\\xE4\\xB8\\xAD\\xE6\\x96\\x87...' from gbk to utf8mb3 |\n+---------+------+-------------------------------------------------------------------------+\n</code></pre><p>查看数据时，发现已经有乱码产生，而且数据库中存储的编码已经有问题了（存储了E6B6933FE69E83E7BB97EFB980E5BDBF，正确的应该是E4B8ADE69687E7ACA6E58FB7）。</p><pre><code class=\"language-go\">-- 在设置正确的终端下查询数据\n\nmysql&gt; select a, hex(a) from t_utf8;\n+------------------+----------------------------------+\n| a                | hex(a)                           |\n+------------------+----------------------------------+\n| 涓?枃绗﹀彿      | E6B6933FE69E83E7BB97EFB980E5BDBF |\n+------------------+----------------------------------+\n1 row in set (0.00 sec)\n</code></pre><p>由于数据库中存储的数据已经有问题了，原始数据可能会有丢失，我们可以尝试使用下面的方法来找回原始数据。</p><pre><code class=\"language-go\">-- 终端为UTF8，将character_set_results设置为GBK\nmysql&gt; set names gbk;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; select a, hex(a) from t_utf8;\n+-------------+----------------------------------+\n| a           | hex(a)                           |\n+-------------+----------------------------------+\n| �?��符号       | E6B6933FE69E83E7BB97EFB980E5BDBF |\n+-------------+----------------------------------+\n1 row in set (0.00 sec)\n</code></pre><p>可以看到，原始的文本为“中文符号”，我们还原了一部分数据“符号”。但是“中文”在转换过程中丢失了。</p><p>如果我们将character_set_client和character_set_connection全部都设置为GBK，则数据写入时就会报错。</p><pre><code class=\"language-go\">mysql&gt; set character_set_client='gbk';\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; set character_set_connection='gbk';\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; insert into t_utf8 values('中文符号');\nERROR 1366 (HY000): Incorrect string value: '\\xAD\\xE6\\x96\\x87\\xE7\\xAC...' for column 'a' at row 1\n</code></pre><p>这说明了MySQL容忍了文本编码从character_set_client转换到character_set_connection时的错误。但如果往存储引擎中写入数据时编码转换有问题，语句就会失败，数据无法写入到数据库。</p><h3>GBK 终端，character_set_client 设置为 UTF8</h3><p>在这种情况下，终端是GBK环境，但是character_set_client错误地设置成了UTF8，此时如果写入数据，可以发现insert语句产生了warning，提示编码转换存在问题。</p><pre><code class=\"language-go\">mysql&gt; create table t_utf8_2(a varchar(30)) charset utf8;\nQuery OK, 0 rows affected, 1 warning (0.01 sec)\n\n-- gbk终端\nmysql&gt; set character_set_client='utf8';\nQuery OK, 0 rows affected, 1 warning (0.00 sec)\n\nmysql&gt; insert into t_utf8_2 values('中文符号');\nQuery OK, 1 row affected, 1 warning (0.01 sec)\n\n\nmysql&gt; show warnings;\n+---------+------+-------------------------------------------------------------------------+\n| Level   | Code | Message                                                                 |\n+---------+------+-------------------------------------------------------------------------+\n| Warning | 1300 | Cannot convert string '\\xD6\\xD0\\xCE\\xC4\\xB7\\xFB...' from utf8mb3 to gbk |\n+---------+------+-------------------------------------------------------------------------+\n1 row in set (0.00 sec)\n</code></pre><p>我们在一个编码设置正确的终端下查看数据。</p><pre><code class=\"language-go\">mysql&gt; select a, hex(a) from t_utf8_2;\n+--------+--------------+\n| a      | hex(a)       |\n+--------+--------------+\n| ?????? | 3F3F3F3F3F3F |\n+--------+--------------+\n1 row in set (0.00 sec)\n</code></pre><p>这种情况下，表里存储的数据全部变成了问号（0x3F就是问号的ascii编码）。这种情况下，原始数据已经完全丢失了。</p><p>如果character_set_client和character_set_connection设置成一样，则数据转换发生在数据往存储引擎写入的过程中，语句会直接失败。</p><pre><code class=\"language-go\">mysql&gt; set names utf8;\nQuery OK, 0 rows affected, 1 warning (0.00 sec)\n\nmysql&gt; insert into t_utf8_2 values('中文符号');\nERROR 1366 (HY000): Incorrect string value: '\\xD6\\xD0\\xCE\\xC4\\xB7\\xFB...' for column 'a' at row 1\n</code></pre><p>总结一下，写入数据时，如果character_set_client的设置和数据的实际编码不一致，就可能会产生乱码，或者在写入数据时直接报错。如果写入了乱码数据，有可能无法获取到原先正确的数据。</p><h2>乱码情况 4：表结构乱码</h2><p>我们在执行DDL时，如果终端环境和数据库字符集参数（characte_set_client）设置不一致，并且DDL中使用了中文符号，也可能会产生乱码。这里产生乱码的原因和前面数据乱码的原因类似。这里简单举几个例子。</p><p>终端为UTF8环境，但是字符集错误地设置成了GBK。</p><pre><code class=\"language-go\">mysql&gt; create database db_03;\nQuery OK, 1 row affected (0.00 sec)\n\nmysql&gt; use db_03\nDatabase changed\n\nmysql&gt; create table 中文符号表_t_01(a int);\nQuery OK, 0 rows affected, 1 warning (0.01 sec)\n\nmysql&gt; show warnings;\n+---------+------+-------------------------------------------------------------------------+\n| Level   | Code | Message                                                                 |\n+---------+------+-------------------------------------------------------------------------+\n| Warning | 1300 | Cannot convert string '\\xE4\\xB8\\xAD\\xE6\\x96\\x87...' from gbk to utf8mb3 |\n+---------+------+-------------------------------------------------------------------------+\n1 row in set (0.00 sec)\n\n\nmysql&gt; show tables;\n+---------------------+\n| Tables_in_db_03     |\n+---------------------+\n| �?��符号表_t_01        |\n+---------------------+\n1 row in set (0.01 sec)\n</code></pre><p>我们到字符集为UTF8的终端下查看，发现表名依然是乱码。</p><pre><code class=\"language-go\">mysql&gt; set names utf8;\nQuery OK, 0 rows affected, 1 warning (0.00 sec)\n\nmysql&gt; show tables;\n+----------------------------+\n| Tables_in_db_03            |\n+----------------------------+\n| 涓?枃绗﹀彿琛╛t_01         |\n+----------------------------+\n1 row in set (0.00 sec)\n</code></pre><p>我们可以使用Python来模拟这个编码转换的过程。</p><pre><code class=\"language-go\">### 原始编码\n&gt;&gt;&gt; u\"中文符号表_t_01\".encode('utf8')\n'\\xe4\\xb8\\xad\\xe6\\x96\\x87\\xe7\\xac\\xa6\\xe5\\x8f\\xb7\\xe8\\xa1\\xa8_t_01'\n\n### 原始编码使用GBK解码后，再编码成UTF8\n&gt;&gt;&gt; u\"中文符号表_t_01\".encode('utf8').decode('gbk',errors='replace').encode('utf8')\n'\\xe6\\xb6\\x93\\xef\\xbf\\xbd\\xe6\\x9e\\x83\\xe7\\xbb\\x97\\xef\\xb9\\x80\\xe5\\xbd\\xbf\\xe7\\x90\\x9b\\xe2\\x95\\x9bt_01'\n\n### 这就是我们show tables看到的情况。\n&gt;&gt;&gt; print u\"中文符号表_t_01\".encode('utf8').decode('gbk',errors='replace').encode('utf8')\n涓�枃绗﹀彿琛╛t_01\n</code></pre><p>如果我们在GBK编码的终端下，错误地将字符集设置成了UTF8。</p><pre><code class=\"language-go\">-- GBK终端\nmysql&gt; set names utf8;\nQuery OK, 0 rows affected, 1 warning (0.00 sec)\n\nmysql&gt; create table 中文符号表_t_02(a int);\nERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '???姆??疟?_t_02(a int)' at line 1\n\nmysql&gt; create table ` 中文符号表_t_02`(a i);\nERROR 1300 (HY000): Invalid utf8mb3 character string: '\\xD6\\xD0\\xCE\\xC4\\xB7\\xFB\\xBA\\xC5\\xB1\\xED_t_02'\n</code></pre><p>还好在这种情况下，DDL直接失败了。</p><p>上面的例子里，我们特意使用了中文表名来做测试。MySQL中表名、列名、表和列的注释都可以使用Unicode，当然也包括中文。使用中文表名、列名的情况可能比较少见，但是表和字段的注释经常会使用中文，如果客户端字符集设置不对，就容易出现乱码。</p><h2>乱码情况 5：数据导入导出时的字符集设置不对</h2><p>我们在进行数据迁移的时候，如果某个环节字符集设置不对，就有可能会产生乱码。一般在进行数据迁移、数据导入导出后，需要重点检查下是否有乱码产生。mysqldump是很常用的一个数据备份工具，接下来我们使用mysqldump来演示一个由于字符集设置不对而导致的乱码问题。</p><p>先创建一个测试表，准备一点测试数据。</p><pre><code class=\"language-go\">mysql&gt; create database db_emoji;\nQuery OK, 1 row affected (0.00 sec)\n\nmysql&gt; use db_emoji\nDatabase changed\n\n\nmysql&gt; create table t_emoji(a varchar(30)) charset utf8mb4;\nQuery OK, 0 rows affected (0.01 sec)\n\n\nmysql&gt; insert into t_emoji values('row1:😀😀😀');\nERROR 1366 (HY000): Incorrect string value: '\\xF0\\x9F\\x98\\x80\\xF0\\x9F...' for column 'a' at row 1\n\n### 使用emoji数据时，字符集需要设置为utf8mb4\nmysql&gt; set names utf8mb4;\nQuery OK, 0 rows affected (0.00 sec)\n\n\nmysql&gt; insert into t_emoji values('row1:😀😀😀');\nQuery OK, 1 row affected (0.00 sec)\n\nmysql&gt; insert into t_emoji values('row2:no emoji chars');\nQuery OK, 1 row affected (0.00 sec)\n\n### 我们确认表里的数据没有问题\nmysql&gt; select * from t_emoji;\n+---------------------+\n| a                   |\n+---------------------+\n| row1:😀😀😀               |\n| row2:no emoji chars |\n+---------------------+\n2 rows in set (0.00 sec)\n</code></pre><p>接下来我们使用mysqldump来备份刚刚创建的表。</p><pre><code class=\"language-go\">$ mysqldump -uroot db_emoji &gt; db_emoji.sql\n</code></pre><p>我们知道mysqldump产生的是数据库的逻辑备份，会将库表里的数据以INSERT语句的方式导出。</p><pre><code class=\"language-go\">$ grep 'INSERT INTO' db_emoji.sql\nINSERT INTO `t_emoji` VALUES ('row1:???'),('row2:no emoji chars');\n</code></pre><p>检查后发现emoji字符都被替换成了问号。如果我们将刚刚备份出来的数据恢复到数据库，就会发现数据有问题了。</p><p>解决这个问题，需要在备份时指定正确的字符集。</p><pre><code class=\"language-go\">$ mysqldump --default-character-set utf8mb4 -uroot db_emoji &gt; db_emoji_utf8mb4.sql\n\n$ grep 'INSERT INTO' db_emoji_utf8mb4.sql\nINSERT INTO `t_emoji` VALUES ('row1:😀😀😀'),('row2:no emoji chars');\n</code></pre><p>可以看到，将字符集指定为 utf8mb4 后，导出的数据就没有问题了。因此，在使用mysqldump备份时，建议统一都指定 utf8mb4 字符集。</p><h1>总结时刻</h1><p>在这一讲中，我们学习了文本编码和解码的一般过程，以及乱码产生的几种情况。我们还学习了MySQL如何处理文本编码，以及在使用MySQL时你可能会遇到的几种乱码问题，并给出了相应的解决方法。</p><p>最后总结一下几个关键点。</p><ol>\n<li>根据需要存储和处理的文本类型决定使用哪种字符集。一般如果要处理中文，可以选择GBK或UTF8字符集。GBK使用双字节存储一个汉字，在空间上有一定的优势。UTF8适用性更广。</li>\n<li>客户端需要设置正确的字符集。字符集的设置要和程序中数据的实际编码保持一致。</li>\n<li>MySQL中，建议使用 utf8mb4 字符集。因为MySQL中UTF8字符集实际上是 utf8mb3，无法存储4字节的Unicode编码，如emoji字符。</li>\n<li>数据库中，建议选择一种统一的字符编码，尽量避免使用多种不同的字符集。</li>\n</ol><h1>思考题</h1><p>某一个项目发布时，执行了以下数据初始化脚本。</p><pre><code class=\"language-plain\">mysql&gt; CREATE TABLE `t_b` (\n    -&gt;   `a` varchar(30) DEFAULT NULL\n    -&gt; ) ENGINE=InnoDB DEFAULT CHARSET=gbk;\nQuery OK, 0 rows affected (0.03 sec)\n\n\nmysql&gt; set names gbk;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt;  insert into t_b values('中文符号');\nQuery OK, 1 row affected (0.00 sec)\n</code></pre><p>对数据进行检查后，没有发现任何问题。</p><pre><code class=\"language-plain\">mysql&gt; select * from t_b;\n+--------------+\n| a            |\n+--------------+\n| 中文符号     |\n+--------------+\n1 row in set (0.00 sec)\n</code></pre><p>但是另外一个同事查询这个表时，发现无论怎么设置字符集，查出来都是乱码。</p><pre><code class=\"language-plain\">mysql&gt; set names utf8;\nQuery OK, 0 rows affected, 1 warning (0.00 sec)\n\nmysql&gt; select * from t_b;\n+------------------+\n| a                |\n+------------------+\n| 娑??鏋冪粭锕褰? |\n+------------------+\n1 row in set (0.00 sec)\n\n\nmysql&gt; set names gbk;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; select * from t_b;\n+--------------+\n| a            |\n+--------------+\n| 涓枃绗﹀彿 |\n+--------------+\n1 row in set (0.00 sec)\n</code></pre><p>这位同事找到了你，请你帮忙分析为什么会出现这样的问题？应该如何解决呢？</p><p>期待你的思考，欢迎在留言区中与我交流。如果今天的课程让你有所收获，也欢迎转发给有需要的朋友。我们下节课再见！</p>","neighbors":{"left":{"article_title":"06｜SQL Mode对程序有怎样的影响？","id":803251},"right":{"article_title":"08｜程序访问数据库内存溢出怎么解决？","id":804972}},"comments":[{"had_liked":false,"id":393927,"user_name":"dream","can_delete":false,"product_type":"c1","uid":1117793,"ip_address":"重庆","ucode":"65B33D32FA8BE9","user_header":"https://static001.geekbang.org/account/avatar/00/11/0e/61/ae68f8eb.jpg","comment_is_top":true,"comment_ctime":1725354278,"is_pvip":false,"replies":[{"id":143021,"content":"是的，python3和python2在处理字符编码时，有一些区别。\n\n感谢补充这些内容。","user_name":"作者回复","user_name_real":"编辑","uid":3898827,"ctime":1725355149,"ip_address":"浙江","comment_id":393927,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100799401,"comment_content":"文章中的解码示例，我再 ubuntu python3 中运行有点问题，需要在字符串前面加 b:\n\n```\n&gt;&gt;&gt; &#39;\\xd6\\xd0\\xce\\xc4\\xb7\\xfb\\xba\\xc5&#39;.decode(&#39;gbk&#39;)\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nAttributeError: &#39;str&#39; object has no attribute &#39;decode&#39;. Did you mean: &#39;encode&#39;?\n&gt;&gt;&gt; \n&gt;&gt;&gt; print &#39;\\xd6\\xd0\\xce\\xc4\\xb7\\xfb\\xba\\xc5&#39;.decode(&#39;gbk&#39;)\n  File &quot;&lt;stdin&gt;&quot;, line 1\n    print &#39;\\xd6\\xd0\\xce\\xc4\\xb7\\xfb\\xba\\xc5&#39;.decode(&#39;gbk&#39;)\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: Missing parentheses in call to &#39;print&#39;. Did you mean print(...)?\n&gt;&gt;&gt; \n&gt;&gt;&gt; b&#39;\\xd6\\xd0\\xce\\xc4\\xb7\\xfb\\xba\\xc5&#39;.decode(&#39;gbk&#39;)\n&#39;中文符号&#39;\n&gt;&gt;&gt; print(b&#39;\\xd6\\xd0\\xce\\xc4\\xb7\\xfb\\xba\\xc5&#39;.decode(&#39;gbk&#39;))\n中文符号\n&gt;&gt;&gt; \n\n```","like_count":0,"discussions":[{"author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":650634,"discussion_content":"是的，python3和python2在处理字符编码时，有一些区别。\n\n感谢补充这些内容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1725355149,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":394039,"user_name":"dream","can_delete":false,"product_type":"c1","uid":1117793,"ip_address":"重庆","ucode":"65B33D32FA8BE9","user_header":"https://static001.geekbang.org/account/avatar/00/11/0e/61/ae68f8eb.jpg","comment_is_top":false,"comment_ctime":1725605042,"is_pvip":false,"replies":[{"id":143045,"content":"对的，字符集转换的过程大致上应当就是这样的。","user_name":"作者回复","user_name_real":"编辑","uid":3898827,"ctime":1725617061,"ip_address":"浙江","comment_id":394039,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100799401,"comment_content":"从发送请求到接收结果过程中发生的字符集转换，可以像这样理解吗？\n\n### 1. 写操作\n\n1. 客户端使用 `characterEncoding`(默认值是操作系统的字符集) 字符集编码请求字符串，向服务器发送的是经过编码的一个字节串。\n   &gt; 假设 url 是 `jdbc:mysql:&#47;&#47;ip:port&#47;db?characterEncoding=UTF8`， 那客户端就是 utf8 编码\n2. 服务器将客户端发送来的字节串采用 `character_set_client` 表示的字符集进行解码，将解码后的字符串再按照`character_set_connection` 代表的字符集进行编码。\n3. 如果 `character_set_connection` 表示的字符集和存储引擎中列的字符集一致，则直接进行相应操作；否则的话需要将请求的字符串从 `character_set_connection` 表示的字符集转换为存储引擎中列使用的字符集之后再进行操作。\n   \n### 2. 读操作\n\n1. 将从某个列获取到的字节串从该列使用的字符集转换为 `character_set_results` 代表的字符集后发送到客户端。\n2. 客户端使用`characterEncoding`(默认值是操作系统的字符集) 字符集解码收到的结果二进制为字符串。\n","like_count":1,"discussions":[{"author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":650795,"discussion_content":"对的，字符集转换的过程大致上应当就是这样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1725617061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":393914,"user_name":"123","can_delete":false,"product_type":"c1","uid":2662872,"ip_address":"浙江","ucode":"5A343B568B9524","user_header":"https://static001.geekbang.org/account/avatar/00/28/a1/d8/42252c48.jpg","comment_is_top":false,"comment_ctime":1725331246,"is_pvip":false,"replies":[{"id":143022,"content":"1. MySQL在使用character_set_client指定的编码对数据进行decode时，如果遇到问题，就说明字符集不匹配了。\n\nMySQL并不知道客户端发过来的数据的真实编码，除非使用_charset指定，比如：\n\nmysql&gt; SELECT _utf8mb4  0xe4b8ade69687;\n| 中文                     |\n\n2. utf8环境下，如果character_set_client设置为gbk，那么表的字符集为gbk和utf8时，会有不一样的情况。\n\nmysql&gt; create table t_gbk(a varchar(100)) charset gbk;\nmysql&gt; create table t_utf8(a varchar(100)) charset utf8;\n\nmysql&gt; set names gbk;\n\nmysql&gt; insert into t_gbk values(&#39;中文符号&#39;);\n\nmysql&gt; select a, hex(a), char_length(a) from t_gbk;\n| 中文符号     | E4B8ADE69687E7ACA6E58FB7 |              6 |\n\n\n\n写入到t_gbk时，没有做编码转换。虽然看上去没乱码，但是实际上表里存的是“中文符号”的utf8编码。\n\n\n为了写入t_utf8，需要设置非严格模式\n\nmysql&gt; set sql_mode=&#39;&#39;;\n\nmysql&gt; insert into t_utf8 values(&#39;中文符号&#39;);\nQuery OK, 1 row affected, 1 warning (0.00 sec)\n\nmysql&gt; show warnings;\n| Warning | 1366 | Incorrect string value: &#39;\\xAD\\xE6\\x96\\x87\\xE7\\xAC...&#39; for column &#39;a&#39; at row 1 |\n\n\n数据虽然写入了，但是有warning，Incorrect string value里面显示的十六进制串，来自原始数据“中文符号”的utf8编码，&#39;\\xe4\\xb8\\xad\\xe6\\x96\\x87\\xe7\\xac\\xa6\\xe5\\x8f\\xb7&#39;\n\n用gbk decode这串数据时遇到问题了。\n\nmysql&gt; select a, hex(a), char_length(a) from t_utf8;\n| �?��符号       | E6B6933FE69E83E7BB97EFB980E5BDBF |              6 |\n\n表t_utf8里存的数据是怎么来的呢？\n&gt;&gt;&gt; &#39;\\xe4\\xb8\\xad\\xe6\\x96\\x87\\xe7\\xac\\xa6\\xe5\\x8f\\xb7&#39;.decode(&#39;gbk&#39;, errors=&#39;replace&#39;).encode(&#39;utf8&#39;) \n&#39;\\xe6\\xb6\\x93\\xef\\xbf\\xbd\\xe6\\x9e\\x83\\xe7\\xbb\\x97\\xef\\xb9\\x80\\xe5\\xbd\\xbf&#39;\n\n这个数据和表里的数据有一点差异，就是替换符不一样，MySQL中以\\x3f作为替换符。python中以\\xef\\xbf\\xbd，也就是u&#39;\\ufffd&#39;作为替换符。这其实就是?和�的区别。\n","user_name":"作者回复","user_name_real":"编辑","uid":3898827,"ctime":1725365365,"ip_address":"浙江","comment_id":393914,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100799401,"comment_content":"老师，请教几个问题：\n1、“总结一下，写入数据时，如果 character_set_client 的设置和数据的实际编码不一致，就可能会产生乱码，或者在写入数据时直接报错”\nmysql是如何判断character_set_client和数据的实际编码不一致，在传入的时候会有编码信息字段吗？\n\n2、“这说明了 MySQL 容忍了文本编码从 character_set_client 转换到 character_set_connection 时的错误。但如果往存储引擎中写入数据时编码转换有问题，语句就会失败，数据无法写入到数据库。”\n实验环境：utf8终端，character_set_client=gbk，character_set_connection=utf8, table charset=utf8\n\nCREATE TABLE `t_utf8_2` (\n  `a` varchar(30) DEFAULT NULL\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 \n\n(1) “中文字符”.encode(&#39;utf8&#39;).decode(&#39;gbk&#39;).encode(&#39;utf8&#39;) 可以存入数据，但是显示数据乱码；\n(2) set names = gbk =&gt; character_set_client=gbk;character_set_connection=gbk;character_set_results=gbk;\n应该也是“中文字符”.encode(&#39;utf8&#39;).decode(&#39;gbk&#39;).encode(&#39;utf8&#39;) ？个人理解是通过终端的字符集进行编码，然后通过connection字符集进行解码，最后在根据table charset进行编码进行存储？\n所以为什么当终端charset != character_set_client = character_set_connection != table charset 会报错?\n以上的情况分别为：\n 1&gt;  插入乱码：终端charset[utf8] != character_set_client[gbk] != character_set_connection[urf8] = table charset[urf8]\n 2&gt; 插入报错：终端charset[utf8] != character_set_client[gbk] != character_set_connection[gbk] != table charset[urf8]\n 3&gt; 插入正常：终端charset[utf8] = character_set_client[utf8] != character_set_connection[gbk] != table charset[urf8]\n对于情况3，“如果 character_set_connection 和 character_set_client 设置不一样，MySQL Server 端会将数据转换成 character_set_connection 指定的字符集。”\n但是在我的环境中也是正常的，mysql8.0.29\n","like_count":1,"discussions":[{"author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":650639,"discussion_content":"1. MySQL在使用character_set_client指定的编码对数据进行decode时，如果遇到问题，就说明字符集不匹配了。\n\nMySQL并不知道客户端发过来的数据的真实编码，除非使用_charset指定，比如：\n\nmysql&gt; SELECT _utf8mb4  0xe4b8ade69687;\n| 中文                     |\n\n2. utf8环境下，如果character_set_client设置为gbk，那么表的字符集为gbk和utf8时，会有不一样的情况。\n\nmysql&gt; create table t_gbk(a varchar(100)) charset gbk;\nmysql&gt; create table t_utf8(a varchar(100)) charset utf8;\n\nmysql&gt; set names gbk;\n\nmysql&gt; insert into t_gbk values(&#39;中文符号&#39;);\n\nmysql&gt; select a, hex(a), char_length(a) from t_gbk;\n| 中文符号     | E4B8ADE69687E7ACA6E58FB7 |              6 |\n\n\n\n写入到t_gbk时，没有做编码转换。虽然看上去没乱码，但是实际上表里存的是“中文符号”的utf8编码。\n\n\n为了写入t_utf8，需要设置非严格模式\n\nmysql&gt; set sql_mode=&#39;&#39;;\n\nmysql&gt; insert into t_utf8 values(&#39;中文符号&#39;);\nQuery OK, 1 row affected, 1 warning (0.00 sec)\n\nmysql&gt; show warnings;\n| Warning | 1366 | Incorrect string value: &#39;\\xAD\\xE6\\x96\\x87\\xE7\\xAC...&#39; for column &#39;a&#39; at row 1 |\n\n\n数据虽然写入了，但是有warning，Incorrect string value里面显示的十六进制串，来自原始数据“中文符号”的utf8编码，&#39;\\xe4\\xb8\\xad\\xe6\\x96\\x87\\xe7\\xac\\xa6\\xe5\\x8f\\xb7&#39;\n\n用gbk decode这串数据时遇到问题了。\n\nmysql&gt; select a, hex(a), char_length(a) from t_utf8;\n| �?��符号       | E6B6933FE69E83E7BB97EFB980E5BDBF |              6 |\n\n表t_utf8里存的数据是怎么来的呢？\n&gt;&gt;&gt; &#39;\\xe4\\xb8\\xad\\xe6\\x96\\x87\\xe7\\xac\\xa6\\xe5\\x8f\\xb7&#39;.decode(&#39;gbk&#39;, errors=&#39;replace&#39;).encode(&#39;utf8&#39;) \n&#39;\\xe6\\xb6\\x93\\xef\\xbf\\xbd\\xe6\\x9e\\x83\\xe7\\xbb\\x97\\xef\\xb9\\x80\\xe5\\xbd\\xbf&#39;\n\n这个数据和表里的数据有一点差异，就是替换符不一样，MySQL中以\\x3f作为替换符。python中以\\xef\\xbf\\xbd，也就是u&#39;\\ufffd&#39;作为替换符。这其实就是?和�的区别。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1725365365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":393894,"user_name":"Shelly","can_delete":false,"product_type":"c1","uid":2422713,"ip_address":"广东","ucode":"75BA35C2737EA6","user_header":"https://static001.geekbang.org/account/avatar/00/24/f7/b9/f2eec64e.jpg","comment_is_top":false,"comment_ctime":1725265793,"is_pvip":false,"replies":[{"id":143018,"content":"完美地还原了事发现场👍👍\n\n这种数据，最好还是要订正回来，否则后患无穷。","user_name":"作者回复","user_name_real":"编辑","uid":3898827,"ctime":1725330908,"ip_address":"浙江","comment_id":393894,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100799401,"comment_content":"思考题：\n1. 是因为你的终端的字符集为utf8，创建表插入数据时由于设置了set names = gbk，由于表的字符集也是gbk,所以数据存储到表时字符集没有发生转换(但实际是按utf8字符集存储的)，你查询时，由于character_set_results为gbk和表的字符集一致，所以字符集没有发生转换，正好你客户端的字符集是utf8，于是中文字符就被阴差阳错的正确显示了出来。 \n2. 由于你的同事终端的字符集是gbk，当把服务器端的字符集设置成utf8时，查询时，由于character_set_results=utf8和表gbk的字符集不一致，所以需要字符集转换，先要用gbk字符集解码实际用utf8存储的数据，再用utf8进行编码发送到客户端，于是显示就乱码了。 当把服务器的字符集设置成gbk时，由于character_set_results=gbk和表gbk的字符集一致，不存在字符集转换，客户端实际收到是的用utf8字符集编码的数据，终端用GBK字符集解码utf8编码的数据，所以也发生了乱码。\n3. 解决方法：把你同事终端的字符集改utf8，服务器端设置set names=gbk；显示中文就不会出现乱码。","like_count":1,"discussions":[{"author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":650607,"discussion_content":"完美地还原了事发现场👍👍\n\n这种数据，最好还是要订正回来，否则后患无穷。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1725330908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":394277,"user_name":"笙 鸢","can_delete":false,"product_type":"c1","uid":3951358,"ip_address":"上海","ucode":"477AF524212C6D","user_header":"https://static001.geekbang.org/account/avatar/00/3c/4a/fe/7b6bd101.jpg","comment_is_top":false,"comment_ctime":1726305094,"is_pvip":false,"replies":[{"id":143133,"content":"文章里终端的字符集，就是字面意义上的“终端的字符集”，不是set names里的字符集。\n\n比如我用的是iTerm2，终端字符集在Session -&gt; Edit Session -&gt; Terminal -&gt; Character encoding 里查看和设置。","user_name":"作者回复","user_name_real":"编辑","uid":3898827,"ctime":1726465980,"ip_address":"浙江","comment_id":394277,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100799401,"comment_content":"mysql&gt; set names utf8;\nQuery OK, 0 rows affected, 1 warning (0.00 sec)\n\nmysql&gt; set character_set_client=&#39;gbk&#39;;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; insert into t_utf8 values(&#39;中文符号&#39;);\nQuery OK, 1 row affected, 1 warning (0.02 sec)\n\nmysql&gt; select a, hex(a) from t_utf8;\n+------------------+----------------------------------+\n| a                | hex(a)                           |\n+------------------+----------------------------------+\n| 涓?枃绗﹀彿 | E6B6933FE69E83E7BB97EFB980E5BDBF |\n+------------------+----------------------------------+\n1 row in set (0.00 sec)\n\nmysql&gt; set names gbk;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; select a, hex(a) from t_utf8;\n\nmysql&gt; select a, hex(a) from t_utf8;\n\nmysql&gt;\n我这个显示不出来是？\n-- 终端为UTF8，将character_set_results设置为GBK\nmysql&gt; set names gbk;\n这个终端是指操作系统的字符集？还是连接mysql之后的set names设置的啊？设置set names gbk我看character_set_client     | gbk                                   |\n| character_set_connection | gbk                                   |\n| character_set_results    | gbk \n都为gbk了，是这种效果吗？这块有点没转过来                                 ","like_count":0,"discussions":[{"author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651195,"discussion_content":"文章里终端的字符集，就是字面意义上的“终端的字符集”，不是set names里的字符集。\n\n比如我用的是iTerm2，终端字符集在Session -&gt; Edit Session -&gt; Terminal -&gt; Character encoding 里查看和设置。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1726465980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]}]}