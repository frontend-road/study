{"id":100569,"title":"22 | 冒险和预测（一）：hazard是“危”也是“机”","content":"<p>过去两讲，我为你讲解了流水线设计CPU所需要的基本概念。接下来，我们一起来看看，要想通过流水线设计来提升CPU的吞吐率，我们需要冒哪些风险。</p><p>任何一本讲解CPU的流水线设计的教科书，都会提到流水线设计需要解决的三大冒险，分别是<strong>结构冒险</strong>（Structural Hazard）、<strong>数据冒险</strong>（Data Hazard）以及<strong>控制冒险</strong>（Control Hazard）。</p><p>这三大冒险的名字很有意思，它们都叫作<strong>hazard</strong>（冒险）。喜欢玩游戏的话，你应该知道一个著名的游戏，生化危机，英文名就叫Biohazard。的确，hazard还有一个意思就是“危机”。那为什么在流水线设计里，hazard没有翻译成“危机”，而是要叫“冒险”呢？</p><p>在CPU的流水线设计里，固然我们会遇到各种“危险”情况，使得流水线里的下一条指令不能正常运行。但是，我们其实还是通过“抢跑”的方式，“冒险”拿到了一个提升指令吞吐率的机会。流水线架构的CPU，是我们主动进行的冒险选择。我们期望能够通过冒险带来更高的回报，所以，这不是无奈之下的应对之举，自然也算不上什么危机了。</p><p>事实上，对于各种冒险可能造成的问题，我们其实都准备好了应对的方案。这一讲里，我们先从结构冒险和数据冒险说起，一起来看看这些冒险及其对应的应对方案。</p><!-- [[[read_end]]] --><h2>结构冒险：为什么工程师都喜欢用机械键盘？</h2><p>我们先来看一看结构冒险。结构冒险，本质上是一个硬件层面的资源竞争问题，也就是一个硬件电路层面的问题。</p><p>CPU在同一个时钟周期，同时在运行两条计算机指令的不同阶段。但是这两个不同的阶段，可能会用到同样的硬件电路。</p><p>最典型的例子就是内存的数据访问。请你看看下面这张示意图，其实就是<a href=\"https://time.geekbang.org/column/article/99523\">第20讲</a>里对应的5级流水线的示意图。</p><p>可以看到，在第1条指令执行到访存（MEM）阶段的时候，流水线里的第4条指令，在执行取指令（Fetch）的操作。访存和取指令，都要进行内存数据的读取。我们的内存，只有一个地址译码器的作为地址输入，那就只能在一个时钟周期里面读取一条数据，没办法同时执行第1条指令的读取内存数据和第4条指令的读取指令代码。</p><p><img src=\"https://static001.geekbang.org/resource/image/ff/22/fff791c9c4066ba86dcce350e9710822.png?wh=2956x1537\" alt=\"\"></p><center><span class=\"reference\">同一个时钟周期，两个不同指令访问同一个资源</span></center><p>类似的资源冲突，其实你在日常使用计算机的时候也会遇到。最常见的就是薄膜键盘的“锁键”问题。常用的最廉价的薄膜键盘，并不是每一个按键的背后都有一根独立的线路，而是多个键共用一个线路。如果我们在同一时间，按下两个共用一个线路的按键，这两个按键的信号就没办法都传输出去。</p><p>这也是为什么，重度键盘用户，都要买贵一点儿的机械键盘或者电容键盘。因为这些键盘的每个按键都有独立的传输线路，可以做到“全键无冲”，这样，无论你是要大量写文章、写程序，还是打游戏，都不会遇到按下了键却没生效的情况。</p><p>“全键无冲”这样的资源冲突解决方案，其实本质就是<strong>增加资源</strong>。同样的方案，我们一样可以用在CPU的结构冒险里面。对于访问内存数据和取指令的冲突，一个直观的解决方案就是把我们的内存分成两部分，让它们各有各的地址译码器。这两部分分别是<strong>存放指令的程序内存</strong>和<strong>存放数据的数据内存</strong>。</p><p>这样把内存拆成两部分的解决方案，在计算机体系结构里叫作<a href=\"https://en.wikipedia.org/wiki/Harvard_architecture\">哈佛架构</a>（Harvard Architecture），来自哈佛大学设计<a href=\"https://en.wikipedia.org/wiki/Harvard_Mark_I\">Mark I型计算机</a>时候的设计。对应的，我们之前说的冯·诺依曼体系结构，又叫作普林斯顿架构（Princeton Architecture）。从这些名字里，我们可以看到，早年的计算机体系结构的设计，其实产生于美国各个高校之间的竞争中。</p><p>不过，我们今天使用的CPU，仍然是冯·诺依曼体系结构的，并没有把内存拆成程序内存和数据内存这两部分。因为如果那样拆的话，对程序指令和数据需要的内存空间，我们就没有办法根据实际的应用去动态分配了。虽然解决了资源冲突的问题，但是也失去了灵活性。</p><p><img src=\"https://static001.geekbang.org/resource/image/e7/91/e7508cb409d398380753b292b6df8391.jpeg?wh=2023*1792\" alt=\"\"></p><center><span class=\"reference\">现代CPU架构，借鉴了哈佛架构，在高速缓存层面拆分成指令缓存和数据缓存</span></center><p>不过，借鉴了哈佛结构的思路，现代的CPU虽然没有在内存层面进行对应的拆分，却在CPU内部的高速缓存部分进行了区分，把高速缓存分成了<strong>指令缓存</strong>（Instruction Cache）和<strong>数据缓存</strong>（Data Cache）两部分。</p><p>内存的访问速度远比CPU的速度要慢，所以现代的CPU并不会直接读取主内存。它会从主内存把指令和数据加载到高速缓存中，这样后续的访问都是访问高速缓存。而指令缓存和数据缓存的拆分，使得我们的CPU在进行数据访问和取指令的时候，不会再发生资源冲突的问题了。</p><h2>数据冒险：三种不同的依赖关系</h2><p>结构冒险是一个硬件层面的问题，我们可以靠增加硬件资源的方式来解决。然而还有很多冒险问题，是程序逻辑层面的事儿。其中，最常见的就是数据冒险。</p><p>数据冒险，其实就是同时在执行的多个指令之间，有数据依赖的情况。这些数据依赖，我们可以分成三大类，分别是<strong>先写后读</strong>（Read After Write，RAW）、<strong>先读后写</strong>（Write After Read，WAR）和<strong>写后再写</strong>（Write After Write，WAW）。下面，我们分别看一下这几种情况。</p><h3>先写后读（Read After Write）</h3><p>我们先来一起看看先写后读这种情况。这里有一段简单的C语言代码编译出来的汇编指令。这段代码简单地定义两个变量 a 和 b，然后计算 a = a + 2。再根据计算出来的结果，计算 b = a + 3。</p><pre><code>int main() {\n  int a = 1;\n  int b = 2;\n  a = a + 2;\n  b = a + 3;\n}\n</code></pre><pre><code>int main() {\n   0:   55                      push   rbp\n   1:   48 89 e5                mov    rbp,rsp\n  int a = 1;\n   4:   c7 45 fc 01 00 00 00    mov    DWORD PTR [rbp-0x4],0x1\n  int b = 2;\n   b:   c7 45 f8 02 00 00 00    mov    DWORD PTR [rbp-0x8],0x2\n  a = a + 2;\n  12:   83 45 fc 02             add    DWORD PTR [rbp-0x4],0x2\n  b = a + 3;\n  16:   8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]\n  19:   83 c0 03                add    eax,0x3\n  1c:   89 45 f8                mov    DWORD PTR [rbp-0x8],eax\n}\n  1f:   5d                      pop    rbp\n  20:   c3                      ret  \n</code></pre><p>你可以看到，在内存地址为12的机器码，我们把0x2添加到 rbp-0x4 对应的内存地址里面。然后，在紧接着的内存地址为16的机器码，我们又要从rbp-0x4这个内存地址里面，把数据写入到eax这个寄存器里面。</p><p>所以，我们需要保证，在内存地址为16的指令读取rbp-0x4里面的值之前，内存地址12的指令写入到rbp-0x4的操作必须完成。这就是先写后读所面临的数据依赖。如果这个顺序保证不了，我们的程序就会出错。</p><p>这个先写后读的依赖关系，我们一般被称之为<strong>数据依赖</strong>，也就是Data Dependency。</p><h3>先读后写（Write After Read）</h3><p>我们还会面临的另外一种情况，先读后写。我们小小地修改一下代码，先计算 a = b + a，然后再计算 b = a + b。</p><pre><code>int main() {\n  int a = 1;\n  int b = 2;\n  a = b + a;\n  b = a + b;\n}\n</code></pre><pre><code>int main() {\n   0:   55                      push   rbp\n   1:   48 89 e5                mov    rbp,rsp\n   int a = 1;\n   4:   c7 45 fc 01 00 00 00    mov    DWORD PTR [rbp-0x4],0x1\n   int b = 2;\n   b:   c7 45 f8 02 00 00 00    mov    DWORD PTR [rbp-0x8],0x2\n   a = b + a;\n  12:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]\n  15:   01 45 fc                add    DWORD PTR [rbp-0x4],eax\n   b = a + b;\n  18:   8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]\n  1b:   01 45 f8                add    DWORD PTR [rbp-0x8],eax\n}\n  1e:   5d                      pop    rbp\n  1f:   c3                      ret       \n</code></pre><p>我们同样看看对应生成的汇编代码。在内存地址为15的汇编指令里，我们要把 eax 寄存器里面的值读出来，再加到 rbp-0x4 的内存地址里。接着在内存地址为18的汇编指令里，我们要再写入更新 eax 寄存器里面。</p><p>如果我们在内存地址18的eax的写入先完成了，在内存地址为15的代码里面取出 eax 才发生，我们的程序计算就会出错。这里，我们同样要保障对于eax的先读后写的操作顺序。</p><p>这个先读后写的依赖，一般被叫作<strong>反依赖</strong>，也就是Anti-Dependency。</p><h3>写后再写（Write After Write）</h3><p>我们再次小小地改写上面的代码。这次，我们先设置变量 a = 1，然后再设置变量 a = 2。</p><pre><code>int main() {\n  int a = 1;\n  a = 2;\n}\n</code></pre><pre><code>int main() {\n   0:   55                      push   rbp\n   1:   48 89 e5                mov    rbp,rsp\n  int a = 1;\n   4:   c7 45 fc 01 00 00 00    mov    DWORD PTR [rbp-0x4],0x1\n  a = 2;\n   b:   c7 45 fc 02 00 00 00    mov    DWORD PTR [rbp-0x4],0x2\n}\n</code></pre><p>在这个情况下，你会看到，内存地址4所在的指令和内存地址b所在的指令，都是将对应的数据写入到 rbp-0x4 的内存地址里面。如果内存地址b的指令在内存地址4的指令之后写入。那么这些指令完成之后，rbp-0x4 里的数据就是错误的。这就会导致后续需要使用这个内存地址里的数据指令，没有办法拿到正确的值。所以，我们也需要保障内存地址4的指令的写入，在内存地址b的指令的写入之前完成。</p><p>这个写后再写的依赖，一般被叫作<strong>输出依赖</strong>，也就是Output Dependency。</p><h3>再等等：通过流水线停顿解决数据冒险</h3><p>除了读之后再进行读，你会发现，对于同一个寄存器或者内存地址的操作，都有明确强制的顺序要求。而这个顺序操作的要求，也为我们使用流水线带来了很大的挑战。因为流水线架构的核心，就是在前一个指令还没有结束的时候，后面的指令就要开始执行。</p><p>所以，我们需要有解决这些数据冒险的办法。其中最简单的一个办法，不过也是最笨的一个办法，就是<a href=\"https://en.wikipedia.org/wiki/Pipeline_stall\">流水线停顿</a>（Pipeline Stall），或者叫流水线冒泡（Pipeline Bubbling）。</p><p>流水线停顿的办法很容易理解。如果我们发现了后面执行的指令，会对前面执行的指令有数据层面的依赖关系，那最简单的办法就是“<strong>再等等</strong>”。我们在进行指令译码的时候，会拿到对应指令所需要访问的寄存器和内存地址。所以，在这个时候，我们能够判断出来，这个指令是否会触发数据冒险。如果会触发数据冒险，我们就可以决定，让整个流水线停顿一个或者多个周期。</p><p><img src=\"https://static001.geekbang.org/resource/image/d1/c8/d1e24e4b18411a5391757a197de2bdc8.jpeg?wh=3592*1006\" alt=\"\"></p><p>我在前面说过，时钟信号会不停地在0和1之前自动切换。其实，我们并没有办法真的停顿下来。流水线的每一个操作步骤必须要干点儿事情。所以，在实践过程中，我们并不是让流水线停下来，而是在执行后面的操作步骤前面，插入一个NOP操作，也就是执行一个其实什么都不干的操作。</p><p><img src=\"https://static001.geekbang.org/resource/image/0d/2a/0d762f2ce532d87cfe69c7b167af9c2a.jpeg?wh=3592*1006\" alt=\"\"></p><p>这个插入的指令，就好像一个水管（Pipeline）里面，进了一个空的气泡。在水流经过的时候，没有传送水到下一个步骤，而是给了一个什么都没有的空气泡。这也是为什么，我们的流水线停顿，又被叫作流水线冒泡（Pipeline Bubble）的原因。</p><h2>总结延伸</h2><p>讲到这里，相信你已经弄明白了什么是结构冒险，什么是数据冒险，以及数据冒险所要保障的三种依赖，也就是数据依赖、反依赖以及输出依赖。</p><p>一方面，我们可以通过增加资源来解决结构冒险问题。我们现代的CPU的体系结构，其实也是在冯·诺依曼体系结构下，借鉴哈佛结构的一个混合结构的解决方案。我们的内存虽然没有按照功能拆分，但是在高速缓存层面进行了拆分，也就是拆分成指令缓存和数据缓存这样的方式，从硬件层面，使得同一个时钟下对于相同资源的竞争不再发生。</p><p>另一方面，我们也可以通过“等待”，也就是插入无效的NOP操作的方式，来解决冒险问题。这就是所谓的流水线停顿。不过，流水线停顿这样的解决方案，是以牺牲CPU性能为代价的。因为，实际上在最差的情况下，我们的流水线架构的CPU，又会退化成单指令周期的CPU了。</p><p>所以，下一讲，我们进一步看看，其他更高级的解决数据冒险的方案，以及控制冒险的解决方案，也就是操作数前推、乱序执行和还有分支预测技术。</p><h2>推荐阅读</h2><p>想要进一步理解流水线冒险里数据冒险的相关知识，你可以仔细看一看《计算机组成与设计：硬件/软件接口》的第4.5～4.7章。</p><p>想要了解流水线冒险里面结构冒险的相关知识，你可以去看一看Coursera上普林斯顿大学的Computer Architecture的<a href=\"https://zh.coursera.org/lecture/comparch/structural-hazard-lB2xV\">Structure Hazard</a>部分。</p><h2>课后思考</h2><p>在采用流水线停顿的解决方案的时候，我们不仅要在当前指令里面，插入NOP操作，所有后续指令也要插入对应的NOP操作，这是为什么呢？</p><p>欢迎留言和我分享你的疑惑和见解。你也可以把今天的内容，分享给你的朋友，和他一起学习和进步。</p>","neighbors":{"left":{"article_title":"21 | 面向流水线的指令设计（下）：奔腾4是怎么失败的？","id":100554},"right":{"article_title":"23 | 冒险和预测（二）：流水线里的接力赛","id":101172}},"comments":[{"had_liked":false,"id":103955,"user_name":"易儿易","can_delete":false,"product_type":"c1","uid":1242864,"ip_address":"","ucode":"B15D1031CA841E","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqLcWH3mSPmhjrs1aGL4b3TqI7xDqWWibM4nYFrRlp0z7FNSWaJz0mqovrgIA7ibmrPt8zRScSfRaqQ/132","comment_is_top":false,"comment_ctime":1560572898,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"632920765410","product_id":100026001,"comment_content":"一路纵队，前边有人停下系鞋带，后边所有人都得原地踏步踏，不然就得踩着脑袋过去了……","like_count":148,"discussions":[{"author":{"id":1380366,"avatar":"https://static001.geekbang.org/account/avatar/00/15/10/0e/5a0f2339.jpg","nickname":"哪里有会生气的龙","note":"","ucode":"7F12FB7D01EB7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301190,"discussion_content":"形象生动，期待你开个专栏","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1598435501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1637933,"avatar":"https://static001.geekbang.org/account/avatar/00/18/fe/2d/e23fc6ee.jpg","nickname":"深水蓝","note":"","ucode":"3E3B195DE54DE1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":182203,"discussion_content":"这个比喻打得，点赞给满分。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1582388427,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132304,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/10/2d673601.jpg","nickname":"好饿早知道送外卖了","note":"","ucode":"AED22DB5BF8FC7","race_medal":2,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77022,"discussion_content":"果然评论最精彩~","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575880407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2806043,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLBFkSq1oiaEMRjtyyv4ZpCI0OuaSsqs04ODm0OkZF6QhsAh3SvqhxibS2n7PLAVZE3QRSn5Hic0DyXg/132","nickname":"ddh","note":"","ucode":"8E852375365F16","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539156,"discussion_content":"自古评论出人才啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639624737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2258416,"avatar":"https://static001.geekbang.org/account/avatar/00/22/75/f0/2c65887d.jpg","nickname":"活着即是修行","note":"","ucode":"C420AA71FB7F9F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413973,"discussion_content":"确实呀，当n时刻在x处NOP的时候，此时x-1处正在干别的事情。然后再n+1时刻，x处开始干应该做的事情，而x-1处的人只能NOP。当n+1时刻，x-1的人才可以干应该干的事情","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636625181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2720790,"avatar":"","nickname":"Geek_068ffa","note":"","ucode":"39B6AEC5D37B70","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391423,"discussion_content":"精彩！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630460015,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117736,"user_name":"瀚海星尘","can_delete":false,"product_type":"c1","uid":1024461,"ip_address":"","ucode":"90F418299EA3BF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a1/cd/2c513481.jpg","comment_is_top":false,"comment_ctime":1564122308,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"121823206596","product_id":100026001,"comment_content":"因为如果前一个指令插入nop后一个指令不插，那么当前指令被延迟执行的阶段就会和下一个指令的统一阶段在同一个周期内一起执行，而这是电路结构不允许的，统一阶段同一周期只能有单一输入。","like_count":29},{"had_liked":false,"id":132281,"user_name":"记忆犹存","can_delete":false,"product_type":"c1","uid":1084441,"ip_address":"","ucode":"8ACCA77CF83F91","user_header":"https://static001.geekbang.org/account/avatar/00/10/8c/19/4e1989bf.jpg","comment_is_top":false,"comment_ctime":1568078168,"is_pvip":false,"replies":[{"id":"50994","content":"没错，不过这个思路其实也是软件架构慢慢容易“腐化”的原因。随着中间层变多，系统的复杂度和熵在增加，如果没有精心维护，容易最后变成一个难以维护的代码库。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1568428605,"ip_address":"","comment_id":132281,"utype":1}],"discussion_count":3,"race_medal":0,"score":"83172456792","product_id":100026001,"comment_content":"计算机硬件和软件最常用的思想：增加一个中间层。","like_count":19,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466855,"discussion_content":"没错，不过这个思路其实也是软件架构慢慢容易“腐化”的原因。随着中间层变多，系统的复杂度和熵在增加，如果没有精心维护，容易最后变成一个难以维护的代码库。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568428605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2354332,"avatar":"https://static001.geekbang.org/account/avatar/00/23/ec/9c/b4acd768.jpg","nickname":"Sarah","note":"","ucode":"FDC8A0D30EAE28","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379173,"discussion_content":"理解作者的回复！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623737078,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1965699,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/fe/83/df562574.jpg","nickname":"慎独明强","note":"","ucode":"DC2F7F2C0C8F60","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366970,"discussion_content":"没有很理解这个中间层的作用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618226941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106349,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1561276098,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"74575720130","product_id":100026001,"comment_content":"先写后读:数据依赖，读依赖于之前的写正常的依赖关系所以叫数据依赖。<br>先读后写:反依赖，要保证读到写之前的数据，与正常的相反叫反依赖。<br>写完再写:输出依赖。两次写操作顺序反了的话输出就错了。所以叫输出依赖。<br>记不住不晓得这么理解可以么","like_count":17},{"had_liked":false,"id":169731,"user_name":"feihui","can_delete":false,"product_type":"c1","uid":1007294,"ip_address":"","ucode":"13F1D4A82BC650","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/be/9ea55f46.jpg","comment_is_top":false,"comment_ctime":1578421234,"is_pvip":true,"replies":[{"id":"68089","content":"feihui同学，<br><br>你好，实际的CPU硬件里面有专门的冒险检测电路。从逻辑层面，因为每条指令需要访问的地址都是知道的，前后指令的依赖关系能决定是否会触发数据冒险。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1580632682,"ip_address":"","comment_id":169731,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23053257714","product_id":100026001,"comment_content":"请问文中“我们在进行指令译码的时候，会拿到对应指令所需要访问的寄存器和内存地址。所以，在这个时候，我们能够判断出来，这个指令是否会触发数据冒险”，这个冒险是怎么判断出来的？","like_count":6,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480696,"discussion_content":"feihui同学，\n\n你好，实际的CPU硬件里面有专门的冒险检测电路。从逻辑层面，因为每条指令需要访问的地址都是知道的，前后指令的依赖关系能决定是否会触发数据冒险。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580632682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103662,"user_name":"coder","can_delete":false,"product_type":"c1","uid":1399673,"ip_address":"","ucode":"929E3FFD14EFC8","user_header":"https://static001.geekbang.org/account/avatar/00/15/5b/79/d55044ac.jpg","comment_is_top":false,"comment_ctime":1560484708,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"23035321188","product_id":100026001,"comment_content":"用了这么久的HHKB都不知道普通键盘还有锁键的问题🌚🌚🌚","like_count":5,"discussions":[{"author":{"id":1811277,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a3/4d/59390ba9.jpg","nickname":"排骨","note":"","ucode":"A413CF46211E1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578637,"discussion_content":"我以前玩qq飞车，卡飘要改键，就是这个原因","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656921617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2413481,"avatar":"https://static001.geekbang.org/account/avatar/00/24/d3/a9/2b84cc97.jpg","nickname":"Linux C·Core Api","note":"","ucode":"E370F0627E8B11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387015,"discussion_content":"第一次理解全键无冲😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627952796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1939316,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/97/74/a933d664.jpg","nickname":"莜戏","note":"","ucode":"C3488A2BB44359","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375730,"discussion_content":"我是笔记本玩游戏发现的，有些同时按键的操作弄不出来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621833642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178799,"user_name":"三件事","can_delete":false,"product_type":"c1","uid":1055819,"ip_address":"","ucode":"BCC867C8961A24","user_header":"https://static001.geekbang.org/account/avatar/00/10/1c/4b/2e5df06f.jpg","comment_is_top":false,"comment_ctime":1581826793,"is_pvip":false,"replies":[{"id":"69402","content":"三件事同学，<br><br>你好，delay slot可以认为是就是一个流水线冒泡啦。可以理解为，流水线冒泡是一个抽象概念，delay slot是MIPS对这个的具体实现和解决方案。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1581837453,"ip_address":"","comment_id":178799,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18761695977","product_id":100026001,"comment_content":"请问下老师，MIPS 的 delay slot 和流水线冒泡是一样的吗？老师可以讲解下 delay slot 吗？","like_count":4,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483972,"discussion_content":"三件事同学，\n\n你好，delay slot可以认为是就是一个流水线冒泡啦。可以理解为，流水线冒泡是一个抽象概念，delay slot是MIPS对这个的具体实现和解决方案。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581837453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1055819,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1c/4b/2e5df06f.jpg","nickname":"三件事","note":"","ucode":"BCC867C8961A24","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":173226,"discussion_content":"wow 老师回复的好快 我明白了 谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581840059,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230884,"user_name":"A君","can_delete":false,"product_type":"c1","uid":1940105,"ip_address":"","ucode":"FE96F089C2312C","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9a/89/babe8b52.jpg","comment_is_top":false,"comment_ctime":1593513635,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14478415523","product_id":100026001,"comment_content":"流水线的引入，导致同一个时钟周期内，取指令和写内存会存在冲突，无法并行完成，因此，引入数据缓存和指令缓存，让两操作互不干扰。<br>数据冒险又分为数据依赖，反依赖和输出依赖三类。解决方法是在指令译码完成后，根据要访问的寄存器和内存地址来决定是不是要插入以及要插入几个停顿，即nop指令。","like_count":3},{"had_liked":false,"id":184300,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1350446,"ip_address":"","ucode":"56E8AD725D9D1A","user_header":"https://static001.geekbang.org/account/avatar/00/14/9b/2e/7c749c3f.jpg","comment_is_top":false,"comment_ctime":1583285894,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14468187782","product_id":100026001,"comment_content":"为了解决内存的结构冒险，将高速缓存分为数据缓存和指令缓存，但是在访问内存时问题仍然是存在的，能不能在内存中添加两个地址译码器？","like_count":3},{"had_liked":false,"id":108478,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1561779942,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14446681830","product_id":100026001,"comment_content":"在当前指令插入nop可能会对后续指令造成新的依赖，干脆后面的指令也加上nop操作，要等就一起等","like_count":3},{"had_liked":false,"id":103529,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1560471563,"is_pvip":true,"discussion_count":6,"race_medal":0,"score":"14445373451","product_id":100026001,"comment_content":"如果内存地址 b 的指令在内存地址 4 的指令之后写入。<br>    老师这个是b在4之前才是先写在写有问题吧？对后续程序来说 a＝2应该才是正确的吧","like_count":3,"discussions":[{"author":{"id":2459923,"avatar":"https://static001.geekbang.org/account/avatar/00/25/89/13/0d3c5008.jpg","nickname":"最好不过","note":"","ucode":"C7DBCD08402DF8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368543,"discussion_content":"的确写错了，说反了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1618746930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1457408,"avatar":"https://static001.geekbang.org/account/avatar/00/16/3d/00/7daa7403.jpg","nickname":"Eden Ma","note":"","ucode":"755312F0D154F9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384421,"discussion_content":"应该是写反了吧 写反了编辑也不改也不给答复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626580073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1122034,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1e/f2/453d5f88.jpg","nickname":"seker","note":"","ucode":"9B705F91355873","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293470,"discussion_content":"“如果内存地址 b 的指令在内存地址 4 的指令之后写入。”\n“所以，我们也需要保障内存地址 4 的指令的写入，在内存地址 b 的指令的写入之前完成。”\n前后两句话是矛盾的，老师前一句话确实是描述错了，想说的应该是“之前写入”。\n已经反馈给极客时间的编辑了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595553003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1242483,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/73/f7d3a996.jpg","nickname":"！null","note":"","ucode":"4E5B7922980397","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1122034,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1e/f2/453d5f88.jpg","nickname":"seker","note":"","ucode":"9B705F91355873","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":319888,"discussion_content":"好像还是没改对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604157903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":293470,"ip_address":""},"score":319888,"extra":""},{"author":{"id":1122034,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1e/f2/453d5f88.jpg","nickname":"seker","note":"","ucode":"9B705F91355873","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1242483,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/73/f7d3a996.jpg","nickname":"！null","note":"","ucode":"4E5B7922980397","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320372,"discussion_content":"确实还没有更正，可能是编辑无法操作文章，需要老师登录账号修改文章内容吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604331848,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":319888,"ip_address":""},"score":320372,"extra":""}]},{"author":{"id":1371633,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqyicZYyW7ahaXgXUD8ZAS8x0t8jx5rYLhwbUCJiawRepKIZfsLdkxdQ9XQMo99c1UDibmNVfFnAqwPg/132","nickname":"程序水果宝","note":"","ucode":"1700DDFE073A56","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165593,"discussion_content":"我也感觉这句话说反了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581305108,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310741,"user_name":"黄序","can_delete":false,"product_type":"c1","uid":2037282,"ip_address":"","ucode":"C8C2749E2DE72B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erpYAcOqrNNxmMuKsd6Dh69BzxiaXjJRh6IMnQlxOqBFiae1EMic32Wv6aFESWytliaL7uniaZ4DgNUwxg/132","comment_is_top":false,"comment_ctime":1630890146,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10220824738","product_id":100026001,"comment_content":"如果拆分为数据内存和程序内存，那么我们的程序指令就不能放到数据内存里面去了，那么程序内存中就需要增加指向数据内存的指针，用来程序运行时从数据内存中获取数据；这样一来，一是增加了内存的占用，二是增加了程序运行的复杂度，如果我们在一个程序中用到了几千个数据，我们就要取几千次数据，这种延时对于内存和CPU而言，是无法忍受的。同时，如果多核CPU之间需要访问相同的内存地址，就可能出现竞争的问题；但是如果在中间增加一层缓存，那么就可以提升访问的速度，达到CPU的容忍程度，并且多核CPU之间也不需要因为要访问相同的内存地址而出现竞争的问题。但是缓存的存在就导致了数据原子性和一致性的问题，所以才需要进行加锁或者volatile等关键字(java)","like_count":2},{"had_liked":false,"id":300350,"user_name":"Yongtao","can_delete":false,"product_type":"c1","uid":2324603,"ip_address":"","ucode":"248BE5661D6532","user_header":"https://static001.geekbang.org/account/avatar/00/23/78/7b/09defb8d.jpg","comment_is_top":false,"comment_ctime":1625125018,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5920092314","product_id":100026001,"comment_content":"当前指令插入了NOP，后续指令如果不插入NOP，就会发生结构冒险。","like_count":1},{"had_liked":false,"id":274256,"user_name":"Wheat","can_delete":false,"product_type":"c1","uid":1260141,"ip_address":"","ucode":"7D99EA149B6DE8","user_header":"https://static001.geekbang.org/account/avatar/00/13/3a/6d/910b2445.jpg","comment_is_top":false,"comment_ctime":1610942269,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5905909565","product_id":100026001,"comment_content":"老师，关于结构冒险有两个问题。<br>第一个问题是，在一个指令周期中，结构冒险的冲突是否只有“取指令”和“内存访问”两个操作所对应的地址译码器是冲突的，会不会还别的操作或者别的元件冲突<br>第二个问题是，虽然将CPU Cache分为了两部分，但是实际上在第一次进行“取指令”和“内存访问”的时候还是需要走硬件，是不是依然有冲突的问题","like_count":1},{"had_liked":false,"id":356236,"user_name":"InfoQ_5b50c2ad07cd","can_delete":false,"product_type":"c1","uid":1301617,"ip_address":"江西","ucode":"00284282C8D479","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJW0UHU6icF3VWsicrqJeyMbhbRDuj6lrRSuTt4V8l7Tk9gnxgCxzed5YjiaowyRQaCria6PjI6ba3ia4g/132","comment_is_top":false,"comment_ctime":1662081499,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1662081499","product_id":100026001,"comment_content":"CPU 在同一个时钟周期，同时在运行两条计算机指令的不同阶段。<br>是不是说在同一个时钟周期内，CPU是类似多线程的在执行不同阶段的指令？<br>如果是，那是不是意味着有几级流水线，就需要有几个线程？<br>如果不是，请问这句话怎么理解？","like_count":0},{"had_liked":false,"id":354587,"user_name":"Hulu warrior","can_delete":false,"product_type":"c1","uid":1545348,"ip_address":"上海","ucode":"9F7BE9927B982D","user_header":"https://static001.geekbang.org/account/avatar/00/17/94/84/04119eab.jpg","comment_is_top":false,"comment_ctime":1660567545,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660567545","product_id":100026001,"comment_content":"看来有些架构会有branch delay（比如MIPS R3000）是这个因为pipeline stall的原因","like_count":0},{"had_liked":false,"id":350467,"user_name":"Geek_96685a","can_delete":false,"product_type":"c1","uid":1461984,"ip_address":"","ucode":"8480A5D41C6C2B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK6xwUp8JiaFNPNSlNxubQlTgcxl02Yc1eiaOzvj75Wob9AYVdsYwAapowkkicenhV0Y02dW2yibPicHDg/132","comment_is_top":false,"comment_ctime":1656928491,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656928491","product_id":100026001,"comment_content":"太牛逼了，我看完这个专栏，一下子解答了我很多疑惑","like_count":1},{"had_liked":false,"id":326087,"user_name":"oxygen_酱","can_delete":false,"product_type":"c1","uid":2734372,"ip_address":"","ucode":"F042A44E05051D","user_header":"https://static001.geekbang.org/account/avatar/00/29/b9/24/0351fe33.jpg","comment_is_top":false,"comment_ctime":1639372396,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1639372396","product_id":100026001,"comment_content":"很多单片机，因为不是定位为通用计算机，所以仍然使用哈佛架构","like_count":0},{"had_liked":false,"id":313188,"user_name":"可以","can_delete":false,"product_type":"c1","uid":2613104,"ip_address":"","ucode":"D586609B00F140","user_header":"https://static001.geekbang.org/account/avatar/00/27/df/70/8d2c1e38.jpg","comment_is_top":false,"comment_ctime":1632304213,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632304213","product_id":100026001,"comment_content":"请问 指令周期 有处理 总线冲突 的阶段吗？如果总线冲突了CPU是处于停机状态吗？","like_count":0},{"had_liked":false,"id":296247,"user_name":"青山","can_delete":false,"product_type":"c1","uid":1131070,"ip_address":"","ucode":"749BAD1834AC0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/42/3e/c1f76202.jpg","comment_is_top":false,"comment_ctime":1622859568,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1622859568","product_id":100026001,"comment_content":"老师我想问一下 &quot;如果内存地址 b 的指令在内存地址 4 的指令之后写入。&quot;和 &quot;我们也需要保障内存地址 4 的指令的写入，在内存地址 b 的指令的写入之前完成。&quot;他们的意思不都是4先写入b后写入吗?","like_count":0},{"had_liked":false,"id":285808,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1617017650,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1617017650","product_id":100026001,"comment_content":"“同一个时钟周期，两个不同指令访问同一个资源”这张图中 同时出现了 两个第3条指令。最后一个是第4条指令。","like_count":0},{"had_liked":false,"id":280865,"user_name":"箭指流云","can_delete":false,"product_type":"c1","uid":1367877,"ip_address":"","ucode":"21571A7D60B10D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/VqgchrJWswwSLmxf1ict6icDDlZG5wChBEiaiblnJAQEdu1nYtB4EZq07mibUurOSDFr16dho6DhGyOpIW4eib57lK8Q/132","comment_is_top":false,"comment_ctime":1614430346,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1614430346","product_id":100026001,"comment_content":"如果出现两个指令同时取数据，数据缓存不是还是会有冲突吗","like_count":0,"discussions":[{"author":{"id":2912103,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/6f/67/112afe2b.jpg","nickname":"沐白木兮","note":"","ucode":"B8A651242475D5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558752,"discussion_content":"流水线是阶梯状的，在正常情况下不会同时有两个相同的操作。即使因为NOP后面的指令也都插入了NOP，也不会同时有两个相同的操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648452597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":270717,"user_name":"H","can_delete":false,"product_type":"c1","uid":1793962,"ip_address":"","ucode":"04D7D030245E27","user_header":"https://static001.geekbang.org/account/avatar/00/1b/5f/aa/63e641c1.jpg","comment_is_top":false,"comment_ctime":1609227386,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1609227386","product_id":100026001,"comment_content":"取指令-译码-执行指令-访存-写回<br>“访存”是访问数据内存，这个怎么理解哈，执行完命令后，再去访问内存数据吗，然后再写回寄存器？这个访存究竟怎么理解哈？","like_count":0,"discussions":[{"author":{"id":1009527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/77/c1310aad.jpg","nickname":"剑衣清风","note":"","ucode":"470CD81F6612F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342215,"discussion_content":"应该是在执行指令时，发现需要加载内存里的数据到指定寄存器，于是就是访存了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610616293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":270667,"user_name":"吃饭睡觉打酱油","can_delete":false,"product_type":"c1","uid":1071668,"ip_address":"","ucode":"95EC98C2B5045B","user_header":"https://static001.geekbang.org/account/avatar/00/10/5a/34/4cbadca6.jpg","comment_is_top":false,"comment_ctime":1609211262,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609211262","product_id":100026001,"comment_content":"插入 NOP 操作，所有后续指令也要插入对应的 NOP 操作，这是为什么呢？<br>是因为后续指令可能和当前指令的执行形成依赖关系么？","like_count":0},{"had_liked":false,"id":247507,"user_name":"vcjmhg","can_delete":false,"product_type":"c1","uid":1526461,"ip_address":"","ucode":"B508D1E9B3F974","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/j24oyxHcpB5AMR9pMO6fITqnOFVOncnk2T1vdu1rYLfq1cN6Sj7xVrBVbCvHXUad2MpfyBcE4neBguxmjIxyiaQ/132","comment_is_top":false,"comment_ctime":1599728824,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599728824","product_id":100026001,"comment_content":"其实解决依赖的方式除了插入nop指令外还有其他方法：<br>1.硬件自动冻结流水线周期。<br>2.指令重调度。（调整指令执行顺序）","like_count":0},{"had_liked":false,"id":230887,"user_name":"A君","can_delete":false,"product_type":"c1","uid":1940105,"ip_address":"","ucode":"FE96F089C2312C","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9a/89/babe8b52.jpg","comment_is_top":false,"comment_ctime":1593514057,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1593514057","product_id":100026001,"comment_content":"前面的指令插入了nop，后续的指令如果依赖它的输出结果也会插入相同个数的nop<br>","like_count":0},{"had_liked":false,"id":208664,"user_name":"zhengfan","can_delete":false,"product_type":"c1","uid":1020160,"ip_address":"","ucode":"B3AC0E10BF7A14","user_header":"https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg","comment_is_top":false,"comment_ctime":1587396946,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1587396946","product_id":100026001,"comment_content":"徐老师您好。<br>结合前几节的内容来看这一节的讲解，有点蒙圈。<br>你在流水线中提到的“访存”，我的理解是“访问缓存或者通过FSB访问主存来获得操作所需要的数据”，不知道我的理解是否正确。<br>而“写回”应该指的是执行结果写入寄存器或者缓存&#47;主存。<br>如果我的理解是正确的，那就意味着“访存”和“写回”都可能有对缓存&#47;主存的操作。<br>那为什么“wb&quot;不会被认为和&quot;IF&quot;或者”MEM“产生冲突呢？","like_count":0,"discussions":[{"author":{"id":1400806,"avatar":"https://static001.geekbang.org/account/avatar/00/15/5f/e6/19778e70.jpg","nickname":"Mr.埃克斯","note":"","ucode":"855BE5DFD2BB0B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302790,"discussion_content":"在mips指令体系中，WB阶段的冒险由寄存器堆内部解决，方式是时钟周期的前半段写，后半段进行读。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599031219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206918,"user_name":"WENMURAN","can_delete":false,"product_type":"c1","uid":1915404,"ip_address":"","ucode":"5D1CE8B41937C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXNhbTULKiakib8lYXrvGF2zPwfedooBzC2EtSv1nt1MwV1KUvTkcJrvCBFvcdwJicnr3OEXnk9GUCg/132","comment_is_top":false,"comment_ctime":1586956984,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586956984","product_id":100026001,"comment_content":"冒险和预测一:<br>三大冒险，结构，数据，控制<br>结构冒险，硬件问题，解决:增加资源，在冯诺依曼结构体系下借鉴哈佛结构的特点，在高速缓存层面拆分成指令缓存和数据缓存，从硬件层面，避免同一个时钟下对于资源的竞争。<br>数据冒险，三种不同的依赖关系（先读后写，先写后读，写后再写），解决方式:流水线停顿（在后一个指令前插入一个NOF操作）","like_count":0},{"had_liked":false,"id":184296,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1350446,"ip_address":"","ucode":"56E8AD725D9D1A","user_header":"https://static001.geekbang.org/account/avatar/00/14/9b/2e/7c749c3f.jpg","comment_is_top":false,"comment_ctime":1583285666,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583285666","product_id":100026001,"comment_content":"在当前指令里面插入 NOP 操作，所有后续指令也要插入对应的 NOP 操作，是因为流水线的同一个阶段不能同时运行，否则存在结构冒险。不知道这样解释对不对","like_count":0},{"had_liked":false,"id":177169,"user_name":"程序水果宝","can_delete":false,"product_type":"c1","uid":1371633,"ip_address":"","ucode":"1700DDFE073A56","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqyicZYyW7ahaXgXUD8ZAS8x0t8jx5rYLhwbUCJiawRepKIZfsLdkxdQ9XQMo99c1UDibmNVfFnAqwPg/132","comment_is_top":false,"comment_ctime":1581308391,"is_pvip":false,"replies":[{"id":"69409","content":"程序水果宝同学，<br><br>你好。这样分配的情况下，我们的程序指令就不能放到数据内存里面去了呀。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1581838072,"ip_address":"","comment_id":177169,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1581308391","product_id":100026001,"comment_content":"为啥把内存拆成程序内存和数据内存这两部分以后就不能根据实际情况动态分配内存了？","like_count":0,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483328,"discussion_content":"程序水果宝同学，\n\n你好。这样分配的情况下，我们的程序指令就不能放到数据内存里面去了呀。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581838072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155205,"user_name":"Hommin","can_delete":false,"product_type":"c1","uid":1299763,"ip_address":"","ucode":"C020CA5DE785DB","user_header":"https://static001.geekbang.org/account/avatar/00/13/d5/33/d79fae5c.jpg","comment_is_top":false,"comment_ctime":1574663268,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1574663268","product_id":100026001,"comment_content":"CPU虽然可以同时执行多条流水线，但需要保证在一个时钟周期中同一个阶段只能有一条流水线在执行（如，可以是执行流水线A的取值阶段和流水线B的译码阶段，但不能是A的取值阶段和B的取值阶段）。那么当前指令插入一个NOP操作后，该操作的后续阶段往后移，而后续指令的对应阶段也必须往后移动，防止出现在一个时刻执行两个相同的阶段。<br>我的问题是，这种对应添加NOP操作，一定会后续某个时刻消除掉吧。是不是当某一条指令没有该阶段的时候消除掉的？","like_count":0,"discussions":[{"author":{"id":1400806,"avatar":"https://static001.geekbang.org/account/avatar/00/15/5f/e6/19778e70.jpg","nickname":"Mr.埃克斯","note":"","ucode":"855BE5DFD2BB0B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303073,"discussion_content":"NOP操作跑完所有阶段就是消除掉了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599128782,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135266,"user_name":"prader26","can_delete":false,"product_type":"c1","uid":1433707,"ip_address":"","ucode":"5EFFFC374ADECE","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/6b/f61d7466.jpg","comment_is_top":false,"comment_ctime":1569114676,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569114676","product_id":100026001,"comment_content":"  计算机里面，(为了快去处理数据，采用了一些设计方式)，冒险分为，数据冒险和结构冒险和控制冒险。<br>  结构冒险的解决办法，是把高速缓存分为指令缓存和数据缓存。<br>  数据冒险(因为程序存在，数据依赖，读依赖，输出依赖)，解决办法是，流水线冒泡。","like_count":0},{"had_liked":false,"id":129982,"user_name":"活的潇洒","can_delete":false,"product_type":"c1","uid":1238830,"ip_address":"","ucode":"666C30CA894754","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/2e/1522a7d6.jpg","comment_is_top":false,"comment_ctime":1567347165,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567347165","product_id":100026001,"comment_content":"“现在终于知道公司的程序员同事人手一部不同规格的机械键盘了的原因了”<br><br>day22 笔记：https:&#47;&#47;www.cnblogs.com&#47;luoahong&#47;p&#47;11436264.html","like_count":0},{"had_liked":false,"id":117620,"user_name":"J.D.Chi","can_delete":false,"product_type":"c1","uid":1035855,"ip_address":"","ucode":"34812AEF95C7AB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ce/4f/3a89d29a.jpg","comment_is_top":false,"comment_ctime":1564102724,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564102724","product_id":100026001,"comment_content":"这种插入“空操作”的思想，我觉得挺有意思，就像一些加密算法，限定了输入数据的长度，那么就可以使用填充 0 来补充长度。","like_count":0},{"had_liked":false,"id":106367,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1561280966,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561280966","product_id":100026001,"comment_content":"老师好:高速缓存分两个了。取指令的寄存器等硬件都是两份了是么?","like_count":0},{"had_liked":false,"id":104217,"user_name":"焰火","can_delete":false,"product_type":"c1","uid":1244606,"ip_address":"","ucode":"D3353B386DE3B5","user_header":"https://static001.geekbang.org/account/avatar/00/12/fd/be/079c78c7.jpg","comment_is_top":false,"comment_ctime":1560684980,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1560684980","product_id":100026001,"comment_content":"浩哥问您两个问题哈 ~~<br>①结构冒险的解决方案，采用高速缓存法的意思是：因为高缓的访问速度快，事先将内存中的指令读入高缓中，然后CPU可以在一个时钟周期内完成两个（或更多）的高缓中的指令，就相当于cpu在一个时钟周期内对原内存数据完成了多次的操作么？<br><br>②如果写的程序中有个循环一连串的读写读写数据操作，有可能造成流水线停顿过多，从而退化成一级流水线，如果真有这样的代码，我们该如何修改呢？","like_count":0},{"had_liked":false,"id":104098,"user_name":"cc","can_delete":false,"product_type":"c1","uid":1239833,"ip_address":"","ucode":"AA1B8EA613E3A9","user_header":"https://static001.geekbang.org/account/avatar/00/12/eb/19/19e706a5.jpg","comment_is_top":false,"comment_ctime":1560650805,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560650805","product_id":100026001,"comment_content":"流水线模式下，一条指令被拆分成n个阶段。这样的好处是增加吞吐量，所谓吞吐量，简单理解就是我们程序中的并发，可以有多条指令同时在CPU里执行不同的阶段，不同阶段，不同阶段。<br>但需要重点强调的是，不是并行：对于指令执行的某一具体的阶段，还是串行的。为什么？我的理解是针对单一阶段，比如解码，电路是唯一的，不同的指令输入不尽相同，为了不出错，串行是最保险的。<br>回到老师的问题，如果后边的指令，不加NOP，那也就意味着有相同的指令准备执行相同阶段，因为串行，还是需要等待的。不如加NOP更简单明了。","like_count":0},{"had_liked":false,"id":103896,"user_name":"Only now","can_delete":false,"product_type":"c1","uid":1038574,"ip_address":"","ucode":"C617473A03AE27","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d8/ee/6e7c2264.jpg","comment_is_top":false,"comment_ctime":1560560814,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560560814","product_id":100026001,"comment_content":"应该是为了维持指令执行的步调","like_count":0},{"had_liked":false,"id":103748,"user_name":"humor","can_delete":false,"product_type":"c1","uid":1181867,"ip_address":"","ucode":"9B48C4C7BEC92C","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/ab/caec7bca.jpg","comment_is_top":false,"comment_ctime":1560502071,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560502071","product_id":100026001,"comment_content":"因为在判断当前指令是否有数据冒险的判断依据里  并没有之前指令是否有NOP操作，只有后续指令插入了对应的NOP操作后判断才可能是正确的。","like_count":0},{"had_liked":false,"id":103656,"user_name":"haer","can_delete":false,"product_type":"c1","uid":1146728,"ip_address":"","ucode":"0216267E645431","user_header":"","comment_is_top":false,"comment_ctime":1560483867,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560483867","product_id":100026001,"comment_content":"所有后续指令也要插入对应的 NOP 操作，这是为什么呢？<br><br>我想是这样：就像两个人以相同的速度一前一后向前走，前面的人停下，后面的人也停下，两个人的距离保持不变，且前面的人一直在前面，后面的人一直在后面。这样的话指令一定是顺序执行的。","like_count":0},{"had_liked":false,"id":103651,"user_name":"云开","can_delete":false,"product_type":"c1","uid":1297758,"ip_address":"","ucode":"74541653336DDA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/nSvVtStiaQzslFM7YRnlhP7FxdVsz8abjlwY6XZ4guKtkXNUgG8EibxztoeosKL2YuxDsb159NTQhVXFBkj31kBw/132","comment_is_top":false,"comment_ctime":1560483389,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560483389","product_id":100026001,"comment_content":"老师：结构冒险的解决方案是把高速缓存拆分成指令缓存和数据缓存。是不是意味着同一个时钟周期两条指令同时都取内存的数据而不是一个取数据一个取指令就不会发生冲突？","like_count":0},{"had_liked":false,"id":103534,"user_name":"Linuxer","can_delete":false,"product_type":"c1","uid":1153978,"ip_address":"","ucode":"272D9D8089C3D6","user_header":"https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg","comment_is_top":false,"comment_ctime":1560471919,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560471919","product_id":100026001,"comment_content":"我们不仅要在当前指令里面，插入 NOP 操作，所有后续指令也要插入对应的 NOP 操作，这是为什么呢？我想是为了实现简单吧，要不下面的指令都得检查与上面每一条当前指令为nop的后面的非nop指令是不是有数据依赖。","like_count":0},{"had_liked":false,"id":103522,"user_name":"MJ","can_delete":false,"product_type":"c1","uid":1237145,"ip_address":"","ucode":"FCEC0C21444D2A","user_header":"https://static001.geekbang.org/account/avatar/00/12/e0/99/5d603697.jpg","comment_is_top":false,"comment_ctime":1560471279,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560471279","product_id":100026001,"comment_content":"【题外话】老师，是否了解中型企业关于安全的架构，一般怎么做，有没有好的推荐参考？最近做这事比较急。","like_count":0},{"had_liked":false,"id":103514,"user_name":"ezra.xu","can_delete":false,"product_type":"c1","uid":1014005,"ip_address":"","ucode":"6C3E11889BC6AB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/f5/ae200a94.jpg","comment_is_top":false,"comment_ctime":1560470806,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560470806","product_id":100026001,"comment_content":"确保错开后续指令中与前一指令存在数据冒险的步骤？","like_count":0},{"had_liked":false,"id":103493,"user_name":"kdb_reboot","can_delete":false,"product_type":"c1","uid":1003594,"ip_address":"","ucode":"4C56FCA563FCA3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/4a/04fef27f.jpg","comment_is_top":false,"comment_ctime":1560466781,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560466781","product_id":100026001,"comment_content":"你好 请教一下，关于计算机总线，可否推荐一些资料，谢谢","like_count":0}]}