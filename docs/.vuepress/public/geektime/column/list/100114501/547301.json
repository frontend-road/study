{"id":547301,"title":"27｜滚动更新：如何做到平滑的应用升级降级？","content":"<p>你好，我是Chrono。</p><p>上次课里我们学习了管理有状态应用的对象StatefulSet，再加上管理无状态应用的Deployment和DaemonSet，我们就能在Kubernetes里部署任意形式的应用了。</p><p>不过，只是把应用发布到集群里是远远不够的，要让应用稳定可靠地运行，还需要有持续的运维工作。</p><p>如果你还记得在<a href=\"https://time.geekbang.org/column/article/535209\">第18节课</a>里，我们学过Deployment的“应用伸缩”功能就是一种常见的运维操作，在Kubernetes里，使用命令 <code>kubectl scale</code>，我们就可以轻松调整Deployment下属的Pod数量，因为StatefulSet是Deployment的一种特例，所以它也可以使用 <code>kubectl scale</code> 来实现“应用伸缩”。</p><p>除了“应用伸缩”，其他的运维操作比如应用更新、版本回退等工作，该怎么做呢？这些也是我们日常运维中经常会遇到的问题。</p><p>今天我就以Deployment为例，来讲讲Kubernetes在应用管理方面的高级操作：滚动更新，使用 <code>kubectl rollout</code> 实现用户无感知的应用升级和降级。</p><h2>Kubernetes如何定义应用版本</h2><p>应用的版本更新，大家都知道是怎么回事，比如我们发布了V1版，过了几天加了新功能，要发布V2版。</p><!-- [[[read_end]]] --><p>不过说起来简单，版本更新实际做起来是一个相当棘手的事。因为系统已经上线运行，必须要保证不间断地对外提供服务，通俗地说就是“给空中的飞机换引擎”。尤其在以前，需要开发、测试、运维、监控、网络等各个部门的一大堆人来协同工作，费时又费力。</p><p>但是，应用的版本更新其实是有章可循的，现在我们有了Kubernetes这个强大的自动化运维管理系统，就可以把它的过程抽象出来，让计算机去完成那些复杂繁琐的人工操作。</p><p>在Kubernetes里，版本更新使用的不是API对象，而是两个命令：<code>kubectl apply</code> 和 <code>kubectl rollout</code>，当然它们也要搭配部署应用所需要的Deployment、DaemonSet等YAML文件。</p><p>不过在我们信心满满开始操作之前，首先要理解在Kubernetes里，所谓的“版本”到底是什么？</p><p>我们常常会简单地认为“版本”就是应用程序的“版本号”，或者是容器镜像的“标签”，但不要忘了，在Kubernetes里应用都是以Pod的形式运行的，而Pod通常又会被Deployment等对象来管理，<strong>所以应用的“版本更新”实际上更新的是整个Pod</strong>。</p><p>那Pod又是由什么来决定的呢？</p><p>仔细回忆一下之前我们创建的那么多个对象，你就会发现，Pod是由YAML描述文件来确定的，更准确地说，是Deployment等对象里的字段 <code>template</code>。</p><p>所以，<strong>在Kubernetes里应用的版本变化就是 <code>template</code> 里Pod的变化</strong>，哪怕 <code>template</code> 里只变动了一个字段，那也会形成一个新的版本，也算是版本变化。</p><p>但 <code>template</code> 里的内容太多了，拿这么长的字符串来当做“版本号”不太现实，所以Kubernetes就使用了“摘要”功能，用摘要算法计算 <code>template</code> 的Hash值作为“版本号”，虽然不太方便识别，但是很实用。</p><p>我们就拿<a href=\"https://time.geekbang.org/column/article/535209\">第18讲</a>里的Nginx Deployment作为例子吧，创建对象之后，使用 <code>kubectl get</code> 来查看Pod的状态：</p><p><img src=\"https://static001.geekbang.org/resource/image/67/7b/67bc5178acde882a57265d6413158a7b.png?wh=1550x234\" alt=\"图片\"></p><p>Pod名字里的那串随机数“6796……”就是Pod模板的Hash值，也就是Pod的“版本号”。</p><p>如果你变动了Pod YAML描述，比如把镜像改成 <code>nginx:stable-alpine</code>，或者把容器名字改成 <code>nginx-test</code>，都会生成一个新的应用版本，<code>kubectl apply</code> 后就会重新创建Pod：</p><p><img src=\"https://static001.geekbang.org/resource/image/15/1e/15e17760079a03f046aa67f6e34b511e.png?wh=1560x236\" alt=\"图片\"></p><p>你可以看到，Pod名字里的Hash值变成了“7c6c……”，这就表示Pod的版本更新了。</p><h2>Kubernetes如何实现应用更新</h2><p>为了更仔细地研究Kubernetes的应用更新过程，让我们来略微改造一下Nginx Deployment对象，看看Kubernetes到底是怎么实现版本更新的。</p><p>首先修改ConfigMap，让它输出Nginx的版本号，方便我们用curl查看版本：</p><pre><code class=\"language-yaml\">apiVersion: v1\nkind: ConfigMap\nmetadata:\n&nbsp; name: ngx-conf\n\ndata:\n&nbsp; default.conf: |\n&nbsp; &nbsp; server {\n&nbsp; &nbsp; &nbsp; listen 80;\n&nbsp; &nbsp; &nbsp; location / {\n&nbsp; &nbsp; &nbsp; &nbsp; default_type text/plain;\n&nbsp; &nbsp; &nbsp; &nbsp; return 200\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'ver : $nginx_version\\nsrv : $server_addr:$server_port\\nhost: $hostname\\n';\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n</code></pre><p>然后我们修改Pod镜像，明确地指定版本号是 <code>1.21-alpine</code>，实例数设置为4个：</p><pre><code class=\"language-yaml\">apiVersion: apps/v1\nkind: Deployment\nmetadata:\n&nbsp; name: ngx-dep\n\nspec:\n&nbsp; replicas: 4\n&nbsp; ... ...\n&nbsp; &nbsp; &nbsp; containers:\n&nbsp; &nbsp; &nbsp; - image: nginx:1.21-alpine\n&nbsp; ... ...\n</code></pre><p>把它命名为 <code>ngx-v1.yml</code>，然后执行命令 <code>kubectl apply</code> 部署这个应用：</p><pre><code class=\"language-plain\">kubectl apply -f ngx-v1.yml\n</code></pre><p>我们还可以为它创建Service对象，再用 <code>kubectl port-forward</code> 转发请求来查看状态：</p><pre><code class=\"language-plain\">kubectl port-forward svc/ngx-svc 8080:80 &amp;\ncurl 127.1:8080\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/20/52/20d23af1305e2d2b4f66b951c09dac52.png?wh=1532x928\" alt=\"图片\"></p><p>从curl命令的输出中可以看到，现在应用的版本是 <code>1.21.6</code>。</p><p>现在，让我们编写一个新版本对象 <code>ngx-v2.yml</code>，把镜像升级到 <code>nginx:1.22-alpine</code>，其他的都不变。</p><p><strong>因为Kubernetes的动作太快了，为了能够观察到应用更新的过程，我们还需要添加一个字段 <code>minReadySeconds</code></strong>，让Kubernetes在更新过程中等待一点时间，确认Pod没问题才继续其余Pod的创建工作。</p><p>要提醒你注意的是，<code>minReadySeconds</code> 这个字段不属于Pod模板，所以它不会影响Pod版本：</p><pre><code class=\"language-yaml\">apiVersion: apps/v1\nkind: Deployment\nmetadata:\n&nbsp; name: ngx-dep\n\nspec:\n&nbsp; minReadySeconds: 15      # 确认Pod就绪的等待时间 \n&nbsp; replicas: 4\n  ... ...\n      containers:\n      - image: nginx:1.22-alpine\n  ... ...\n</code></pre><p>现在我们执行命令 <code>kubectl apply</code> 来更新应用，因为改动了镜像名，Pod模板变了，就会触发“版本更新”，然后用一个新命令：<code>kubectl rollout status</code>，来查看应用更新的状态：</p><pre><code class=\"language-plain\">kubectl apply -f ngx-v2.yml\nkubectl rollout status deployment ngx-dep\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/6d/7f/6d4023181fe180d50eb4cca7755a207f.png?wh=1920x486\" alt=\"图片\"></p><p>更新完成后，你再执行 <code>kubectl get pod</code>，就会看到Pod已经全部替换成了新版本“d575……”，用curl访问Nginx，输出信息也变成了“1.22.0”：</p><p><img src=\"https://static001.geekbang.org/resource/image/6a/64/6a1776c3yy1ec374510af9e560401064.png?wh=1594x646\" alt=\"图片\"></p><p>仔细查看 <code>kubectl rollout status</code> 的输出信息，你可以发现，Kubernetes不是把旧Pod全部销毁再一次性创建出新Pod，而是在逐个地创建新Pod，同时也在销毁旧Pod，保证系统里始终有足够数量的Pod在运行，不会有“空窗期”中断服务。</p><p>新Pod数量增加的过程有点像是“滚雪球”，从零开始，越滚越大，所以这就是所谓的“<strong>滚动更新</strong>”（rolling update）。</p><p>使用命令 <code>kubectl describe</code> 可以更清楚地看到Pod的变化情况：</p><pre><code class=\"language-plain\">kubectl describe deploy ngx-dep\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/3b/fa/3b88d6b0d609e3b99f33b4f8e997c3fa.png?wh=1232x550\" alt=\"图片\"></p><ul>\n<li>一开始的时候V1 Pod（即ngx-dep-54b865d75）的数量是4；</li>\n<li>当“滚动更新”开始的时候，Kubernetes创建1个 V2 Pod（即ngx-dep-d575d5776），并且把V1 Pod数量减少到3；</li>\n<li>接着再增加V2 Pod的数量到2，同时V1 Pod的数量变成了1；</li>\n<li>最后V2 Pod的数量达到预期值4，V1 Pod的数量变成了0，整个更新过程就结束了。</li>\n</ul><p>看到这里你是不是有点明白了呢，其实“滚动更新”就是由Deployment控制的两个同步进行的“应用伸缩”操作，老版本缩容到0，同时新版本扩容到指定值，是一个“此消彼长”的过程。</p><p>这个滚动更新的过程我画了一张图，你可以参考它来进一步体会：</p><p><img src=\"https://static001.geekbang.org/resource/image/b3/31/b3abe70db73a9da71a1793722e743731.jpg?wh=1920x729\" alt=\"图片\"></p><h2>Kubernetes如何管理应用更新</h2><p>Kubernetes的“滚动更新”功能确实非常方便，不需要任何人工干预就能简单地把应用升级到新版本，也不会中断服务，不过如果更新过程中发生了错误或者更新后发现有Bug该怎么办呢？</p><p>要解决这两个问题，我们还是要用 <code>kubectl rollout</code> 命令。</p><p>在应用更新的过程中，你可以随时使用 <code>kubectl rollout pause</code> 来暂停更新，检查、修改Pod，或者测试验证，如果确认没问题，再用 <code>kubectl rollout resume</code> 来继续更新。</p><p>这两个命令比较简单，我就不多做介绍了，要注意的是它们只支持Deployment，不能用在DaemonSet、StatefulSet上（最新的1.24支持了StatefulSet的滚动更新）。</p><p>对于更新后出现的问题，Kubernetes为我们提供了“后悔药”，也就是更新历史，你可以查看之前的每次更新记录，并且回退到任何位置，和我们开发常用的Git等版本控制软件非常类似。</p><p>查看更新历史使用的命令是 <code>kubectl rollout history</code>：</p><pre><code class=\"language-plain\">kubectl rollout history deploy ngx-dep\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/7c/09/7cc86862b28829c58c00eeb0fcdfbd09.png?wh=1398x306\" alt=\"图片\"></p><p>它会输出一个版本列表，因为我们创建Nginx Deployment是一个版本，更新又是一个版本，所以这里就会有两条历史记录。</p><p>但 <code>kubectl rollout history</code> 的列表输出的有用信息太少，你可以<strong>在命令后加上参数 <code>--revision</code> 来查看每个版本的详细信息</strong>，包括标签、镜像名、环境变量、存储卷等等，通过这些就可以大致了解每次都变动了哪些关键字段：</p><pre><code class=\"language-plain\">kubectl rollout history deploy --revision=2\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/0f/7c/0f8c4d0a230b97bb1a74d745c220677c.png?wh=1608x1054\" alt=\"图片\"></p><p>假设我们认为刚刚更新的 <code>nginx:1.22-alpine</code> 不好，<strong>想要回退到上一个版本，就可以使用命令 <code>kubectl rollout undo</code>，也可以加上参数 <code>--to-revision</code> 回退到任意一个历史版本</strong>：</p><pre><code class=\"language-plain\">kubectl rollout undo deploy ngx-dep\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/14/c7/149345b7df104ac70c23a6c877a9b1c7.png?wh=1408x406\" alt=\"图片\"></p><p><code>kubectl rollout undo</code> 的操作过程其实和 <code>kubectl apply</code> 是一样的，执行的仍然是“滚动更新”，只不过使用的是旧版本Pod模板，把新版本Pod数量收缩到0，同时把老版本Pod扩展到指定值。</p><p>这个V2到V1的“版本降级”的过程我同样画了一张图，它和从V1到V2的“版本升级”过程是完全一样的，不同的只是版本号的变化方向：</p><p><img src=\"https://static001.geekbang.org/resource/image/0c/29/0cbb6eec008546c4f5106de5ece20329.jpg?wh=1920x695\" alt=\"图片\"></p><h2>Kubernetes如何添加更新描述</h2><p>讲到这里，Kubernetes里应用更新的功能就学得差不多了。</p><p>不过，你有没有觉得 <code>kubectl rollout history</code> 的版本列表好像有点太简单了呢？只有一个版本更新序号，而另一列 <code>CHANGE-CAUSE</code> 为什么总是显示成 <code>&lt;none&gt;</code> 呢？能不能像Git一样，每次更新也加上说明信息呢？</p><p><img src=\"https://static001.geekbang.org/resource/image/7c/09/7cc86862b28829c58c00eeb0fcdfbd09.png?wh=1398x306\" alt=\"图片\"></p><p>这当然是可以的，做法也很简单，我们<strong>只需要在Deployment的 <code>metadata</code> 里加上一个新的字段 <code>annotations</code></strong>。</p><p><code>annotations</code> 字段的含义是“注解”“注释”，形式上和 <code>labels</code> 一样，都是Key-Value，也都是给API对象附加一些额外的信息，但是用途上区别很大。</p><ul>\n<li><code>annotations</code> 添加的信息一般是给Kubernetes内部的各种对象使用的，有点像是“扩展属性”；</li>\n<li><code>labels</code> 主要面对的是Kubernetes外部的用户，用来筛选、过滤对象的。</li>\n</ul><p>如果用一个简单的比喻来说呢，<strong><code>annotations</code> 就是包装盒里的产品说明书，而 <code>labels</code> 是包装盒外的标签贴纸</strong>。</p><p>借助 <code>annotations</code>，Kubernetes既不破坏对象的结构，也不用新增字段，就能够给API对象添加任意的附加信息，这就是面向对象设计中典型的OCP“开闭原则”，让对象更具扩展性和灵活性。</p><p><code>annotations</code> 里的值可以任意写，Kubernetes会自动忽略不理解的Key-Value，但要编写更新说明就需要使用特定的字段 <code>kubernetes.io/change-cause</code>。</p><p>下面来操作一下，我们创建3个版本的Nginx应用，同时添加更新说明：</p><pre><code class=\"language-yaml\">apiVersion: apps/v1\nkind: Deployment\nmetadata:\n&nbsp; name: ngx-dep\n&nbsp; annotations:\n&nbsp; &nbsp; kubernetes.io/change-cause: v1, ngx=1.21\n... ...\n</code></pre><pre><code class=\"language-yaml\">apiVersion: apps/v1\nkind: Deployment\nmetadata:\n&nbsp; name: ngx-dep\n&nbsp; annotations:\n&nbsp; &nbsp; kubernetes.io/change-cause: update to v2, ngx=1.22\n... ...\n</code></pre><pre><code class=\"language-yaml\">apiVersion: apps/v1\nkind: Deployment\nmetadata:\n&nbsp; name: ngx-dep\n&nbsp; annotations:\n&nbsp; &nbsp; kubernetes.io/change-cause: update to v3, change name\n... ...\n</code></pre><p>你需要注意YAML里的 <code>metadata</code> 部分，使用 <code>annotations.kubernetes.io/change-cause</code> 描述了版本更新的情况，相比 <code>kubectl rollout history --revision</code> 的罗列大量信息更容易理解。</p><p>依次使用 <code>kubectl apply</code> 创建并更新对象之后，我们再用 <code>kubectl rollout history</code> 来看一下更新历史：</p><p><img src=\"https://static001.geekbang.org/resource/image/74/69/74bcc2020yy6b121634b3cbf972fe669.png?wh=1398x356\" alt=\"图片\"></p><p>这次显示的列表信息就好看多了，每个版本的主要变动情况列得非常清楚，和Git版本管理的感觉很像。</p><h2>小结</h2><p>好，今天我们一起学习了Kubernetes里的高级应用管理功能：滚动更新，它会自动缩放新旧版本的Pod数量，能够在用户无感知的情况下实现服务升级或降级，让原本复杂棘手的运维工作变得简单又轻松。</p><p>再小结一下今天的要点：</p><ol>\n<li>在Kubernetes里应用的版本不仅仅是容器镜像，而是整个Pod模板，为了便于处理使用了摘要算法，计算模板的Hash值作为版本号。</li>\n<li>Kubernetes更新应用采用的是滚动更新策略，减少旧版本Pod的同时增加新版本Pod，保证在更新过程中服务始终可用。</li>\n<li>管理应用更新使用的命令是 <code>kubectl rollout</code>，子命令有 <code>status</code>、<code>history</code>、<code>undo</code> 等。</li>\n<li>Kubernetes会记录应用的更新历史，可以使用 <code>history --revision</code> 查看每个版本的详细信息，也可以在每次更新时添加注解 <code>kubernetes.io/change-cause</code>。</li>\n</ol><p>另外，在Deployment里还有其他一些字段可以对滚动更新的过程做更细致的控制，它们都在 <code>spec.strategy.rollingUpdate</code> 里，比如 <code>maxSurge</code>、<code>maxUnavailable</code> 等字段，分别控制最多新增Pod数和最多不可用Pod数，一般用默认值就足够了，你如果感兴趣也可以查看Kubernetes文档进一步研究。</p><h2>课下作业</h2><p>最后是课下作业时间，给你留两个思考题：</p><ol>\n<li>今天学的Kubernetes的“滚动更新”，与我们常说的“灰度发布”有什么相同点和不同点？</li>\n<li>直接部署旧版本的YAML也可以实现版本回退，<code>kubectl rollout undo</code> 命令的好处是什么？</li>\n</ol><p>欢迎在留言区积极参与讨论。如果觉得今天的内容对你有帮助，也欢迎转发给身边的朋友一起讨论，我们下节课再见。</p><p><img src=\"https://static001.geekbang.org/resource/image/55/f8/55154596ba524615a36601c7fdeb9af8.jpg?wh=1920x2635\" alt=\"图片\"></p>","neighbors":{"left":{"article_title":"26｜StatefulSet：怎么管理有状态的应用？","id":547750},"right":{"article_title":"28｜应用保障：如何让Pod运行得更健康？","id":548736}},"comments":[{"had_liked":false,"id":355414,"user_name":"马以","can_delete":false,"product_type":"c1","uid":1344431,"ip_address":"北京","ucode":"3FEA06CA14DE28","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","comment_is_top":false,"comment_ctime":1661347468,"is_pvip":false,"replies":[{"id":129353,"content":"great","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1661407483,"ip_address":"北京","comment_id":355414,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100114501,"comment_content":"思考题：\n1: “滚动发布”是能力，“灰度发布”是功能，k8s基于“滚动发布”的能力，可以实现pod的‘水平扩展&#47;收缩’，从而能够提供类似于“灰度发布”、“金丝雀发布”这种功能。\n2:其实讨论这个问题前，我们要先了解下k8s的控制器模型，另外还要引入一个概念就是“ReplicaSet”，什么意思呢，其实Deployment并不是直接控制Pod，Pod的归属对象是“ReplicaSet”，也就是说Deployment控制的是“ReplicaSet”(版本这个概念其实我们可以等同于是ReplicaSet)，然后“ReplicaSet”控制Pod的数量。我们可以通过 kubectl get rs 来看下具体内容：\n\n$ kubectl get rs\n\nNAME                    DESIRED   CURRENT   READY   AGE\nngx-deploy-699b5dbd6b   4         4         4       7h42m\nngx-deploy-6dfbbccf84   0         0         0       9d\nngx-deploy-76c65bc7db   0         0         0       9d\nngx-deploy-ffd96c4fc    0         0         0       7h46m\n\n所以这个时候，我们再来理解“版本回退”和“直接部署旧版本的 YAML”的区别就容易了，这里的版本就像是我们平时开发代码库打的tag一样，是类似于我们的快照文件一样，这个快照信息可以正确的帮我们记录当时场景的最原始信息，所以我们通过版本回退的方式能够最大限度的保证正确性（这点是k8s已经为我们保证了这一点），反之如果我们通过旧的yaml部署，就不一定能保证当前这个yaml文件有没有被改动过，这里的变数还是挺大的，所以直接通过yaml部署，极大的增加了我们部署的风险性。\n","like_count":35,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585219,"discussion_content":"great","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661407483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355336,"user_name":"椰子","can_delete":false,"product_type":"c1","uid":2278399,"ip_address":"北京","ucode":"CD9A5C5496AD62","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKQuaDVYz2jWN9vrmgbB785SNkmYmxf1xzEG8m8ku3ZvzYSkiaanTjqt7O47ficOQUpGmEy7eImplDw/132","comment_is_top":false,"comment_ctime":1661304177,"is_pvip":false,"replies":[{"id":129281,"content":"是这样的，但好处是可以不间断对外提供服务。","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1661308935,"ip_address":"北京","comment_id":355336,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100114501,"comment_content":"滚动更新时，新版本和旧版本共存的那一小段时间是共同对外提供服务的吗？如果这样的话是不是线上就存在不同版本的问题了","like_count":5,"discussions":[{"author":{"id":1969439,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/rURvBicplInVqwb9rX21a4IkcKkITIGIo7GE1Tcp3WWU49QtwV53qY8qCKAIpS6x68UmH4STfEcFDJddffGC7lw/132","nickname":"onemao","note":"","ucode":"1CB4101525C2D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585406,"discussion_content":"这个是可以指定的吧，可以做到旧版本一直对外服务，直到全部到新版本的时候新版本才对外服务","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1661511492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585048,"discussion_content":"是这样的，但好处是可以不间断对外提供服务。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1661308935,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1365944,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d7/b8/c42d2527.jpg","nickname":"Jason Ding","note":"","ucode":"E62AB51E7F2D6E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612712,"discussion_content":"做一下流量管理 不同的版本走不同的路由策略","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680861407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1521181,"avatar":"https://static001.geekbang.org/account/avatar/00/17/36/1d/f5486ffe.jpg","nickname":"你的笑忘书","note":"","ucode":"9665D5E9EDBEA6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585047,"discussion_content":"会帮你切流量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661308153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355328,"user_name":"Sports","can_delete":false,"product_type":"c1","uid":1757265,"ip_address":"北京","ucode":"1AC6035DFA4ECB","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d0/51/f1c9ae2d.jpg","comment_is_top":false,"comment_ctime":1661299654,"is_pvip":false,"replies":[{"id":129282,"content":"说的很好。\n\n如果不用rollout undo，虽然效果是相同的，都是滚动更新，但就没有体现“版本回退”的意思了，仅仅是更新了一个版本，不利于运维管理。","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1661309023,"ip_address":"北京","comment_id":355328,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100114501,"comment_content":"第一个问题:灰度发布应该是多个应用版本共存，按一定比例分配;\n第二个问题:使用rollout版本回退，保持pod固定数量滚动更新，减轻资源压力，尽量地避免版本冲突。\n目前只想到这些，希望老师再补充😁","like_count":5,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585049,"discussion_content":"说的很好。\n\n如果不用rollout undo，虽然效果是相同的，都是滚动更新，但就没有体现“版本回退”的意思了，仅仅是更新了一个版本，不利于运维管理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661309023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":363346,"user_name":"菲茨杰拉德","can_delete":false,"product_type":"c1","uid":1875922,"ip_address":"北京","ucode":"4EB29359F39862","user_header":"https://static001.geekbang.org/account/avatar/00/1c/9f/d2/b6d8df48.jpg","comment_is_top":false,"comment_ctime":1669557243,"is_pvip":false,"replies":[{"id":132091,"content":"这个不是Kubernetes考虑的问题，属于业务层面，所以要用其他的手段来保证平稳过渡。","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1669602082,"ip_address":"北京","comment_id":363346,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100114501,"comment_content":"新老pod同时在线。也就意味着，新功能与旧功能同时在线吗？这样业务无法接受吧。要经过灰度或者验证后，才切换到新pod才比较安全吧。","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":594946,"discussion_content":"这个不是Kubernetes考虑的问题，属于业务层面，所以要用其他的手段来保证平稳过渡。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1669602082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":362798,"user_name":"Bachue Zhou","can_delete":false,"product_type":"c1","uid":1494491,"ip_address":"北京","ucode":"3175754775CA32","user_header":"https://static001.geekbang.org/account/avatar/00/16/cd/db/7467ad23.jpg","comment_is_top":false,"comment_ctime":1668914660,"is_pvip":false,"replies":[{"id":131948,"content":"这个当然不可能做到完全无感知，但Kubernetes把原来运维的滚动更新流程给极大地简化了。","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1668996310,"ip_address":"北京","comment_id":362798,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100114501,"comment_content":"这个滚动更新是否真的能做到用户无感知呢？我有点怀疑。例如用户刚刚发了一个 http 请求到一个 pod，处理了一半，pod 就被关闭了，是否可能造成这个请求最终在用户这边出错了？如果 http 能够处理这种情况，那么 http&#47;2 能吗？grpc 能吗？","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":594337,"discussion_content":"这个当然不可能做到完全无感知，但Kubernetes把原来运维的滚动更新流程给极大地简化了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1668996310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355497,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"上海","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1661428780,"is_pvip":false,"replies":[{"id":129374,"content":"这个就属于CI&#47;CD的范围了，其实并不是Kubernetes直接的能力，而是它们与Kubernetes的集成，我对这方面没有了解过，sorry。","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1661483367,"ip_address":"上海","comment_id":355497,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100114501,"comment_content":"有个问题，我看公司的项目，直接jenkens打包，k8s就能感知到。那k8s，是如何做到的呢？","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585325,"discussion_content":"这个就属于CI/CD的范围了，其实并不是Kubernetes直接的能力，而是它们与Kubernetes的集成，我对这方面没有了解过，sorry。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661483368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1306147,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ee/23/b92b0811.jpg","nickname":"读书看报","note":"","ucode":"3B4717314B52A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590243,"discussion_content":"编写 k8s yml 模板，dockerfile 模板。jenkins 里写 shell 脚本。镜像构建，服务k8s 模板生成。最后连接 k8s 主机 kubectl apply -f。差不多就这个流程","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1665638151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3251061,"avatar":"https://static001.geekbang.org/account/avatar/00/31/9b/75/0b60cb5d.jpg","nickname":"SYN数字化技术","note":"","ucode":"5DD0B8514254F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":646299,"discussion_content":"其实就是在jenkins上构建镜像、创建deploy模版，之后链接k8s主机，执行kubectl apply -f 创建pod，如果是流水的就是直接在K8s上操作了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1717677551,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"山东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1529858,"avatar":"https://static001.geekbang.org/account/avatar/00/17/58/02/2b7ccf09.jpg","nickname":"民工597","note":"","ucode":"DB6857E21E9318","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630126,"discussion_content":"其实就是jenkins中执行脚本操作k8s而已","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698128047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":391241,"user_name":"SYN数字化技术","can_delete":false,"product_type":"c1","uid":3251061,"ip_address":"山东","ucode":"5DD0B8514254F4","user_header":"https://static001.geekbang.org/account/avatar/00/31/9b/75/0b60cb5d.jpg","comment_is_top":false,"comment_ctime":1717677365,"is_pvip":false,"replies":[{"id":142288,"content":"这个可以在实验环境里实际测试一下。","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1717740714,"ip_address":"上海","comment_id":391241,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100114501,"comment_content":"这里指的是pod更新，如果是一个pod中有多个镜像，其中部分镜像版本更新，对应的是什么情况呢？我的理解是，pod此时不动，对应版本更新的容器进行重启","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":646336,"discussion_content":"这个可以在实验环境里实际测试一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1717740715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1255198,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erRCf8vWbWibajdSaMtCM1OzPQ6uPhblgL4zXJvKoaQYVmialqFqr0NIdD6Dlm1F5icOBxiaXvUcQs4BA/132","nickname":"sgcls","note":"","ucode":"F359E943BF6D14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":650499,"discussion_content":"应该是原地升级，只更新Pod里部分容器，而不是整个Pod销毁重建","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1725122852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386495,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"吉林","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1704959827,"is_pvip":true,"replies":[{"id":140877,"content":"good","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1704961957,"ip_address":"上海","comment_id":386495,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100114501,"comment_content":"第一次绑定8080:80 端口后面, 升级了pod, 然后访问curl 127.0.0.1 就会报错:  \n Unable to listen on port 8080: Listeners failed to create with the following errors: [unable to create listener: Error listen tcp4 127.0.0.1:8080: bind: address already in use unable to create listener: Error listen tcp6 [::1]:8080: bind: address already\n\n原因: 因为 ​​kubectl​​​ 没有释放其端口绑定，可以通过以下命令手动终止 ​​pid​​（示例基于尝试向前运行8080端口）\nlsof -i:8080 (mac电脑)\n会显示pid \n\nkill -9 pid \n然后再重新绑定端口就可以了 ","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635591,"discussion_content":"good","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704961957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":376145,"user_name":"思绪走了灬光✨","can_delete":false,"product_type":"c1","uid":1101661,"ip_address":"北京","ucode":"512DD0FA5C024C","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/5d/99756164.jpg","comment_is_top":false,"comment_ctime":1686383370,"is_pvip":false,"replies":[{"id":137215,"content":"短连接效率低，不应该使用。\n这个属于应用层次的问题了，kubernetes管不了，一般来说可以设置一个超时时间，过了就强制关闭。","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1686535566,"ip_address":"上海","comment_id":376145,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100114501,"comment_content":"要想实现滚动更新，是不是pod内的应用应该使用短连接？如果是长连接的应用，那么连接可能一直都不会中断，那在强制中断的时候，还是会造成有损？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620776,"discussion_content":"短连接效率低，不应该使用。\n这个属于应用层次的问题了，kubernetes管不了，一般来说可以设置一个超时时间，过了就强制关闭。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1686535566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1101661,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/5d/99756164.jpg","nickname":"思绪走了灬光✨","note":"","ucode":"512DD0FA5C024C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":620795,"discussion_content":"多谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1686544036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":620776,"ip_address":"北京","group_id":0},"score":620795,"extra":""}]},{"author":{"id":1255198,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erRCf8vWbWibajdSaMtCM1OzPQ6uPhblgL4zXJvKoaQYVmialqFqr0NIdD6Dlm1F5icOBxiaXvUcQs4BA/132","nickname":"sgcls","note":"","ucode":"F359E943BF6D14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":650500,"discussion_content":"业务应用可以实现优雅终止，比如设置容器停止前的等待超时时间（参考业务处理一个请求需要多长时间），同时业务代码监听 SIGTERM 信号（容器关闭前会收到这个信号），实现信号处理不再接收新请求。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1725123353,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":362201,"user_name":"滴流乱转小胖儿","can_delete":false,"product_type":"c1","uid":1231250,"ip_address":"北京","ucode":"4689236E65FE4E","user_header":"https://static001.geekbang.org/account/avatar/00/12/c9/92/6361802a.jpg","comment_is_top":false,"comment_ctime":1668295136,"is_pvip":false,"replies":[{"id":131769,"content":"good","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1668318742,"ip_address":"北京","comment_id":362201,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100114501,"comment_content":"关于老师提到的“maxSurge、maxUnavailable”\n可以移步：https:&#47;&#47;kubernetes.io&#47;zh-cn&#47;docs&#47;concepts&#47;workloads&#47;controllers&#47;deployment&#47;#max-unavailable\n","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":593549,"discussion_content":"good","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1668318742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358148,"user_name":"dao","can_delete":false,"product_type":"c1","uid":1087879,"ip_address":"北京","ucode":"4181FB270462CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/99/87/5066026c.jpg","comment_is_top":false,"comment_ctime":1663942563,"is_pvip":false,"replies":[{"id":130331,"content":"service默认就是ClusterIP，用port-forward是因为我们在console机上，集群之外。","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1664006855,"ip_address":"北京","comment_id":358148,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100114501,"comment_content":"在实验中的 svc 可以简单实用 `type: ClusterIP` ，这样可以直接使用 ClusterIP 访问，而不需要 port-forward 端口转发了。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588696,"discussion_content":"service默认就是ClusterIP，用port-forward是因为我们在console机上，集群之外。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1664006855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358147,"user_name":"dao","can_delete":false,"product_type":"c1","uid":1087879,"ip_address":"北京","ucode":"4181FB270462CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/99/87/5066026c.jpg","comment_is_top":false,"comment_ctime":1663942146,"is_pvip":false,"replies":[{"id":130332,"content":"good","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1664006871,"ip_address":"北京","comment_id":358147,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100114501,"comment_content":"作业：\n1， 滚动更新是一个逐步使用“新”版本替换“旧”版本的发布方式；灰度发布又称金丝雀发布，在灰度期间，“新”、“旧”两个版本会同时存在，这种发布方式可以用于实现A&#47;B测试。\n2，在实验环境中，我的每个版本并不是都有 YAML 文件，有时只是做一个很小的调整接着发布，这时 undo 比较好用，真正实现版本回滚&#47;退 :)","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588697,"discussion_content":"good","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664006871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":356516,"user_name":"Sam.张朝","can_delete":false,"product_type":"c1","uid":1132448,"ip_address":"北京","ucode":"FB20554D94B250","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/a0/f12115b7.jpg","comment_is_top":false,"comment_ctime":1662375680,"is_pvip":true,"replies":[{"id":129803,"content":"在Kubernetes里做灰度发布比较简单，感觉更多的是业务层面，如果有这方面的经验欢迎分享。","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1662435819,"ip_address":"北京","comment_id":356516,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100114501,"comment_content":"有机会可以讲讲灰度发布","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586687,"discussion_content":"在Kubernetes里做灰度发布比较简单，感觉更多的是业务层面，如果有这方面的经验欢迎分享。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662435819,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2416669,"avatar":"https://static001.geekbang.org/account/avatar/00/24/e0/1d/791d0f5e.jpg","nickname":"公众号: 洋芋编程","note":"","ucode":"98BE11177D1B0D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629966,"discussion_content":"分享一篇自己的文章:\n\nhttps://mp.weixin.qq.com/s?__biz=MzI1MzI3OTA5OQ==&amp;mid=2247485512&amp;idx=1&amp;sn=8f956add8122a5bbf52ad5f76cc94ec8&amp;chksm=e9d7a65cdea02f4a6bca3152b77675f91ff2cfe39b17e11d601f08afa9d08ba9be0888468818&amp;scene=178&amp;cur_album_id=3065720394789388289#rd","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1697898696,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"陕西","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355512,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"上海","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1661439668,"is_pvip":false,"replies":[{"id":129377,"content":"\n1. 在命令里写多个对象就可以，如果要清除多个可以用-f yaml的方式比较好。\n\n2.ReplicaSet是一种单独的对象，但很少直接用，我们现在用的都是Deployment，由Deployment来控制ReplicaSet，感兴趣可以去研究一下它。\n\n3.老终端显示的信息是port-forward转发的信息，与Nginx无关，只有在另一个终端发curl请求才会出Nginx信息。可以参考一下后续的视频。","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1661483656,"ip_address":"上海","comment_id":355512,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100114501,"comment_content":"请教老师几个问题：\nQ1：第26讲是关于sts的，如果要清理该讲所创建的环境，需要执行多个命令删除吗？\n是否可以通过执行一个删除命令就可以全部删除？ 第26讲涉及到3个对象：sts、svc、pod，要清理所有创建的实例，\n是否存在一个命令就可以全部删除？ 比如: kubectl delete sts。 但执行该命令后发现不能删除全部实例。好像只能逐个删除。\nQ2：Replica Set是个单独的对象吗？还是说它等价于yaml文件中的： spec: replicas: 2\nQ3： 第27讲，创建ngx-v1部分，创建四个POD都成功了，在一个终端执行“kubectl port-forward svc&#47;ngx-svc 8080:80 &amp;”，执行后此终端上显示“Forwarding from [::1]:8080 -&gt; 80”。新开一个终端，在此新终端上执行“curl 127.1:8080”，结果是：新终端上显示nginx的欢迎页，在老终端上显示“Handling connection for 8080”，但没有显示”ver、srv”等信息。 为什么？ （confiMap是拷贝文中的内容，service用以前的，tpye=NodePort）","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585328,"discussion_content":"\n1. 在命令里写多个对象就可以，如果要清除多个可以用-f yaml的方式比较好。\n\n2.ReplicaSet是一种单独的对象，但很少直接用，我们现在用的都是Deployment，由Deployment来控制ReplicaSet，感兴趣可以去研究一下它。\n\n3.老终端显示的信息是port-forward转发的信息，与Nginx无关，只有在另一个终端发curl请求才会出Nginx信息。可以参考一下后续的视频。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661483656,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}