{"id":237612,"title":"09 | 如何提升TCP三次握手的性能？","content":"<p>你好，我是陶辉。</p><p>上一讲我们提到TCP在三次握手建立连接、四次握手关闭连接时是怎样产生事件的，这两个过程中TCP连接经历了复杂的状态变化，既容易导致编程出错，也有很大的优化空间。这一讲我们看看在Linux操作系统下，如何优化TCP的三次握手流程，提升握手速度。</p><p>TCP是一个可以双向传输的全双工协议，所以需要经过三次握手才能建立连接。三次握手在一个HTTP请求中的平均时间占比在10%以上，在网络状况不佳、高并发或者遭遇SYN泛洪攻击等场景中，如果不能正确地调整三次握手中的参数，就会对性能有很大的影响。</p><p>TCP协议是由操作系统实现的，调整TCP必须通过操作系统提供的接口和工具，这就需要理解Linux是怎样把三次握手中的状态暴露给我们，以及通过哪些工具可以找到优化依据，并通过哪些接口修改参数。</p><p>因此，这一讲我们将介绍TCP握手过程中各状态的意义，并以状态变化作为主线，看看如何调整Linux参数才能提升握手的性能。</p><h2>客户端的优化</h2><p>客户端和服务器都可以针对三次握手优化性能。相对而言，主动发起连接的客户端优化相对简单一些，而服务器需要在监听端口上被动等待连接，并保存许多握手的中间状态，优化方法更为复杂一些。我们首先来看如何优化客户端。</p><!-- [[[read_end]]] --><p>三次握手建立连接的首要目的是同步序列号。只有同步了序列号才有可靠的传输，TCP协议的许多特性都是依赖序列号实现的，比如流量控制、消息丢失后的重发等等，这也是三次握手中的报文被称为SYN的原因，因为SYN的全称就叫做Synchronize Sequence Numbers。</p><p><img src=\"https://static001.geekbang.org/resource/image/c5/aa/c51d9f1604690ab1b69e7c4feb2f31aa.jpg?wh=2052*620\" alt=\"\"></p><p>三次握手虽然由操作系统实现，但它通过连接状态把这一过程暴露给了我们，我们来细看下过程中出现的3种状态的意义。客户端发送SYN开启了三次握手，此时在客户端上用netstat命令（后续查看连接状态都使用该命令）可以看到<strong>连接的状态是SYN_SENT</strong>（顾名思义，就是把刚SYN发送出去）。</p><pre><code>tcp    0   1 172.16.20.227:39198     129.28.56.36:81         SYN_SENT\n</code></pre><p>客户端在等待服务器回复的ACK报文。正常情况下，服务器会在几毫秒内返回ACK，但如果客户端迟迟没有收到ACK会怎么样呢？客户端会重发SYN，<strong>重试的次数由tcp_syn_retries参数控制</strong>，默认是6次：</p><pre><code>net.ipv4.tcp_syn_retries = 6\n</code></pre><p>第1次重试发生在1秒钟后，接着会以翻倍的方式在第2、4、8、16、32秒共做6次重试，最后一次重试会等待64秒，如果仍然没有返回ACK，才会终止三次握手。所以，总耗时是1+2+4+8+16+32+64=127秒，超过2分钟。</p><p>如果这是一台有明确任务的服务器，你可以根据网络的稳定性和目标服务器的繁忙程度修改重试次数，调整客户端的三次握手时间上限。比如内网中通讯时，就可以适当调低重试次数，尽快把错误暴露给应用程序。</p><p><img src=\"https://static001.geekbang.org/resource/image/a3/8f/a3c5e77a228478da2a6e707054043c8f.png?wh=943*613\" alt=\"\"></p><h2>服务器端的优化</h2><p>当服务器收到SYN报文后，服务器会立刻回复SYN+ACK报文，既确认了客户端的序列号，也把自己的序列号发给了对方。此时，服务器端出现了新连接，状态是SYN_RCV（RCV是received的缩写）。这个状态下，服务器必须建立一个SYN半连接队列来维护未完成的握手信息，当这个队列溢出后，服务器将无法再建立新连接。</p><p><img src=\"https://static001.geekbang.org/resource/image/c3/82/c361e672526ee5bb87d5f6b7ad169982.png?wh=690*304\" alt=\"\"></p><p>新连接建立失败的原因有很多，怎样获得由于队列已满而引发的失败次数呢？netstat -s命令给出的统计结果中可以得到。</p><pre><code># netstat -s | grep &quot;SYNs to LISTEN&quot;\n    1192450 SYNs to LISTEN sockets dropped\n</code></pre><p>这里给出的是队列溢出导致SYN被丢弃的个数。注意这是一个累计值，如果数值在持续增加，则应该调大SYN半连接队列。<strong>修改队列大小的方法，是设置Linux的tcp_max_syn_backlog 参数：</strong></p><pre><code>net.ipv4.tcp_max_syn_backlog = 1024\n</code></pre><p>如果SYN半连接队列已满，只能丢弃连接吗？并不是这样，<strong>开启syncookies功能就可以在不使用SYN队列的情况下成功建立连接。</strong>syncookies是这么做的：服务器根据当前状态计算出一个值，放在己方发出的SYN+ACK报文中发出，当客户端返回ACK报文时，取出该值验证，如果合法，就认为连接建立成功，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/0d/c0/0d963557347c149a6270d8102d83e0c0.png?wh=690*319\" alt=\"\"></p><p>Linux下怎样开启syncookies功能呢？修改tcp_syncookies参数即可，其中值为0时表示关闭该功能，2表示无条件开启功能，而1则表示仅当SYN半连接队列放不下时，再启用它。由于syncookie仅用于应对SYN泛洪攻击（攻击者恶意构造大量的SYN报文发送给服务器，造成SYN半连接队列溢出，导致正常客户端的连接无法建立），这种方式建立的连接，许多TCP特性都无法使用。所以，应当把tcp_syncookies设置为1，仅在队列满时再启用。</p><pre><code>net.ipv4.tcp_syncookies = 1\n</code></pre><p>当客户端接收到服务器发来的SYN+ACK报文后，就会回复ACK去通知服务器，同时己方连接状态从SYN_SENT转换为ESTABLISHED，表示连接建立成功。服务器端连接成功建立的时间还要再往后，到它收到ACK后状态才变为ESTABLISHED。</p><p>如果服务器没有收到ACK，就会一直重发SYN+ACK报文。当网络繁忙、不稳定时，报文丢失就会变严重，此时应该调大重发次数。反之则可以调小重发次数。<strong>修改重发次数的方法是，调整tcp_synack_retries参数：</strong></p><pre><code>net.ipv4.tcp_synack_retries = 5\n</code></pre><p>tcp_synack_retries 的默认重试次数是5次，与客户端重发SYN类似，它的重试会经历1、2、4、8、16秒，最后一次重试后等待32秒，若仍然没有收到ACK，才会关闭连接，故共需要等待63秒。</p><p>服务器收到ACK后连接建立成功，此时，内核会把连接从SYN半连接队列中移出，再移入accept队列，等待进程调用accept函数时把连接取出来。如果进程不能及时地调用accept函数，就会造成accept队列溢出，最终导致建立好的TCP连接被丢弃。</p><p>实际上，丢弃连接只是Linux的默认行为，我们还可以选择向客户端发送RST复位报文，告诉客户端连接已经建立失败。打开这一功能需要将tcp_abort_on_overflow参数设置为1。</p><pre><code>net.ipv4.tcp_abort_on_overflow = 0\n</code></pre><p><strong>通常情况下，应当把tcp_abort_on_overflow设置为0，因为这样更有利于应对突发流量。</strong>举个例子，当accept队列满导致服务器丢掉了ACK，与此同时，客户端的连接状态却是ESTABLISHED，进程就在建立好的连接上发送请求。只要服务器没有为请求回复ACK，请求就会被多次重发。如果服务器上的进程只是短暂的繁忙造成accept队列满，那么当accept队列有空位时，再次接收到的请求报文由于含有ACK，仍然会触发服务器端成功建立连接。所以，<strong>tcp_abort_on_overflow设为0可以提高连接建立的成功率，只有你非常肯定accept队列会长期溢出时，才能设置为1以尽快通知客户端。</strong></p><p>那么，怎样调整accept队列的长度呢？<strong>listen函数的backlog参数就可以设置accept队列的大小。事实上，backlog参数还受限于Linux系统级的队列长度上限，当然这个上限阈值也可以通过somaxconn参数修改。</strong></p><pre><code>net.core.somaxconn = 128\n</code></pre><p>当下各监听端口上的accept队列长度可以通过ss -ltn命令查看，但accept队列长度是否需要调整该怎么判断呢？还是通过netstat -s命令给出的统计结果，可以看到究竟有多少个连接因为队列溢出而被丢弃。</p><pre><code># netstat -s | grep &quot;listen queue&quot;\n    14 times the listen queue of a socket overflowed\n</code></pre><p>如果持续不断地有连接因为accept队列溢出被丢弃，就应该调大backlog以及somaxconn参数。</p><h2>TFO技术如何绕过三次握手？</h2><p>以上我们只是在对三次握手的过程进行优化。接下来我们看看如何绕过三次握手发送数据。</p><p>三次握手建立连接造成的后果就是，HTTP请求必须在一次RTT（Round Trip Time，从客户端到服务器一个往返的时间）后才能发送，Google对此做的统计显示，三次握手消耗的时间，在HTTP请求完成的时间占比在10%到30%之间。</p><p><img src=\"https://static001.geekbang.org/resource/image/1b/a8/1b9d8f49d5a716470481657b07ae77a8.png?wh=1090*779\" alt=\"\"></p><p>因此，Google提出了TCP fast open方案（简称<a href=\"https://tools.ietf.org/html/rfc7413\">TFO</a>），客户端可以在首个SYN报文中就携带请求，这节省了1个RTT的时间。</p><p>接下来我们就来看看，TFO具体是怎么实现的。</p><p><strong>为了让客户端在SYN报文中携带请求数据，必须解决服务器的信任问题。</strong>因为此时服务器的SYN报文还没有发给客户端，客户端是否能够正常建立连接还未可知，但此时服务器需要假定连接已经建立成功，并把请求交付给进程去处理，所以服务器必须能够信任这个客户端。</p><p>TFO到底怎样达成这一目的呢？它把通讯分为两个阶段，第一阶段为首次建立连接，这时走正常的三次握手，但在客户端的SYN报文会明确地告诉服务器它想使用TFO功能，这样服务器会把客户端IP地址用只有自己知道的密钥加密（比如AES加密算法），作为Cookie携带在返回的SYN+ACK报文中，客户端收到后会将Cookie缓存在本地。</p><p>之后，如果客户端再次向服务器建立连接，就可以在第一个SYN报文中携带请求数据，同时还要附带缓存的Cookie。很显然，这种通讯方式下不能再采用经典的“先connect再write请求”这种编程方法，而要改用sendto或者sendmsg函数才能实现。</p><p>服务器收到后，会用自己的密钥验证Cookie是否合法，验证通过后连接才算建立成功，再把请求交给进程处理，同时给客户端返回SYN+ACK。虽然客户端收到后还会返回ACK，但服务器不等收到ACK就可以发送HTTP响应了，这就减少了握手带来的1个RTT的时间消耗。</p><p><img src=\"https://static001.geekbang.org/resource/image/7a/c3/7ac29766ba8515eea5bb331fce6dc2c3.png?wh=961*806\" alt=\"\"></p><p>当然，为了防止SYN泛洪攻击，服务器的TFO实现必须能够自动化地定时更新密钥。</p><p>Linux下怎么打开TFO功能呢？这要通过tcp_fastopen参数。由于只有客户端和服务器同时支持时，TFO功能才能使用，<strong>所以tcp_fastopen参数是按比特位控制的。其中，第1个比特位为1时，表示作为客户端时支持TFO；第2个比特位为1时，表示作为服务器时支持TFO</strong>，所以当tcp_fastopen的值为3时（比特为0x11）就表示完全支持TFO功能。</p><pre><code>net.ipv4.tcp_fastopen = 3\n</code></pre><h2>小结</h2><p>这一讲，我们沿着三次握手的流程，介绍了Linux系统的优化方法。</p><p>当客户端通过发送SYN发起握手时，可以通过tcp_syn_retries控制重发次数。当服务器的SYN半连接队列溢出后，SYN报文会丢失从而导致连接建立失败。我们可以通过netstat -s给出的统计结果判断队列长度是否合适，进而通过tcp_max_syn_backlog参数调整队列的长度。服务器回复SYN+ACK报文的重试次数由tcp_synack_retries参数控制，网络稳定时可以调小它。为了应对SYN泛洪攻击，应将tcp_syncookies参数设置为1，它仅在SYN队列满后开启syncookie功能，保证连接成功建立。</p><p>服务器收到客户端返回的ACK后，会把连接移入accept队列，等待进程调用accept函数取出连接。如果accept队列溢出，默认系统会丢弃ACK，也可以通过tcp_abort_on_overflow参数用RST通知客户端连接建立失败。如果netstat统计信息显示，大量的ACK被丢弃后，可以通过listen函数的backlog参数和somaxconn系统参数提高队列上限。</p><p>TFO技术绕过三次握手，使得HTTP请求减少了1个RTT的时间。Linux下可以通过tcp_fastopen参数开启该功能。</p><p>从这一讲可以看出，虽然TCP是由操作系统实现的，但Linux通过多种方式提供了修改TCP功能的接口，供我们优化TCP的性能。下一讲我们再来探讨四次握手关闭连接时，Linux怎样帮助我们优化其性能。</p><h2>思考题</h2><p>最后，留给你一个思考题，关于三次握手建立连接，你做过哪些优化？效果如何？欢迎你在留言区与大家一起探讨。</p><p>感谢阅读，如果你觉得这节课对你有一些启发，也欢迎把它分享给你的朋友。</p>","neighbors":{"left":{"article_title":"08 | 事件驱动：C10M是如何实现的？","id":236921},"right":{"article_title":"10 | 如何提升TCP四次挥手的性能？","id":238388}},"comments":[{"had_liked":false,"id":224099,"user_name":"Geek_1386e9","can_delete":false,"product_type":"c1","uid":1584198,"ip_address":"","ucode":"DCD2234365F6C7","user_header":"","comment_is_top":false,"comment_ctime":1591275242,"is_pvip":false,"replies":[{"id":"90795","content":"谢谢Geek_1386e9同学的实践分享！<br>一般可以通过netstat从丢包上检测出，大流量下在生产环境上抓包不易。","user_name":"作者回复","comment_id":224099,"uid":"1283912","ip_address":"","utype":1,"ctime":1599643329,"user_name_real":"陶辉"}],"discussion_count":2,"race_medal":0,"score":"229224541930","product_id":100051201,"comment_content":"我在生产系统中确实遇到了accept队列溢出导致的请求超时问题，这种问题确实不容易被发现，服务器cpu、内存、连接数监控指标都正常，只是磁盘读写时间偶尔会偏高，当时为了解决这个问题，我搭建了一个测试环境，客户端用wrk发起请求，服务端用dd模拟磁盘大量读写导致io响应慢。并用blktrace+fio分析io，同时两边用tcpdump抓包，通过抓包数据发现服务端忽略了第三次握手客户端发来的ack（tcp_abort_on_overflow=0），又重发了第二次握手的syn+ack的包，响应超过了客户端的超时时间设置，google后才知道了是因为accept队列溢出的问题，结论就是我们使用的公有云虚拟机因为同宿主机上其他客户的虚拟机io大导致我们的虚拟机磁盘读写时间长，应用程序处理慢，没能及时从accept队列里拿连接处理，导致accept队列溢出，调大accept队列只能缓解溢出情况，提升程序处理速度才能根本解决，后面我们申请了独享的虚拟机，并且换成了共享ssd磁盘，并把io调度算法改成了noop，问题完美解决，性能杠杠滴","like_count":54,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497363,"discussion_content":"谢谢Geek_1386e9同学的实践分享！\n一般可以通过netstat从丢包上检测出，大流量下在生产环境上抓包不易。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599643329,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1476323,"avatar":"https://static001.geekbang.org/account/avatar/00/16/86/e3/a31f6869.jpg","nickname":" 尿布","note":"","ucode":"D1C8BDA7540962","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326155,"discussion_content":"io调度算法改成了noop，noop可以介绍一下吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605533640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219295,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1589985043,"is_pvip":false,"replies":[{"id":"81047","content":"谢谢忆水寒的补充！","user_name":"作者回复","comment_id":219295,"uid":"1283912","ip_address":"","utype":1,"ctime":1590026257,"user_name_real":"陶辉"}],"discussion_count":2,"race_medal":0,"score":"78899396371","product_id":100051201,"comment_content":"本文的干货满满的，虽然都熟悉，但是没有这么底层的优化过。<br>当网络丢包严重的时候，可以使用快速重传机制。重传时间间隔是指数级退避，直到达到 120s 为止，总时间将近 15 分钟，重传次数默认是 15次 ，重传次数默认值由 &#47;proc&#47;sys&#47;net&#47;ipv4&#47;tcp_retries2 决定。","like_count":18,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495752,"discussion_content":"谢谢忆水寒的补充！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590026257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1868263,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ1bf1wUGI2KsHwswRMgxZr1ibNyRZnrNk2PI3G2zVRmp6vsWN7kbZnAtQk1TXkkNfRrbjnhow606A/132","nickname":"施界","note":"","ucode":"9BF5104871C75F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570722,"discussion_content":"补充：修改 net.ipv4.tcp_retries2 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651892566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218531,"user_name":"Geek_007","can_delete":false,"product_type":"c1","uid":1467182,"ip_address":"","ucode":"C80107538EAA7F","user_header":"https://static001.geekbang.org/account/avatar/00/16/63/2e/e49116d1.jpg","comment_is_top":false,"comment_ctime":1589814507,"is_pvip":false,"replies":[{"id":"80911","content":"是的，不只网络设备，一些代理服务器为了减轻自己的负担，也会把长连接断掉，比如Nginx默认关闭75秒没有数据交互的keep alive 长连接","user_name":"作者回复","comment_id":218531,"uid":"1283912","ip_address":"","utype":1,"ctime":1589935347,"user_name_real":"陶辉"}],"discussion_count":1,"race_medal":0,"score":"66014323947","product_id":100051201,"comment_content":"看评论区，很多同学都说是长连接，普通的http keepalive 会不会有坑，三大运营商或者中间网络设备都会将超过一定时间的链接drop掉。如果没有h2这种ping保活的机制，有可能客户端莫名其妙长链接被drop掉，客户端只能依赖超时来感知异常，反倒是影响性能了。","like_count":15,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495504,"discussion_content":"是的，不只网络设备，一些代理服务器为了减轻自己的负担，也会把长连接断掉，比如Nginx默认关闭75秒没有数据交互的keep alive 长连接","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589935347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219831,"user_name":"Jesson","can_delete":false,"product_type":"c1","uid":1212313,"ip_address":"","ucode":"EBADA87D9E5AE6","user_header":"https://static001.geekbang.org/account/avatar/00/12/7f/99/6a92ff95.jpg","comment_is_top":false,"comment_ctime":1590108616,"is_pvip":true,"replies":[{"id":"81197","content":"你好Tango281，非TFO场景下，你大可先调用connect函数，在这里传递服务器地址，再调用send函数发送请求，但在TFO场景下，是不能调用connect函数的，否则就回归正常的三次握手了，所以要使用sendto等函数。","user_name":"作者回复","comment_id":219831,"uid":"1283912","ip_address":"","utype":1,"ctime":1590131385,"user_name_real":"陶辉"}],"discussion_count":3,"race_medal":0,"score":"44539781576","product_id":100051201,"comment_content":"老师，TFO编程的时候，为什么要改为sendto或者sendmsg啊？ 这个地方原理不太懂。","like_count":11,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495954,"discussion_content":"你好Tango281，非TFO场景下，你大可先调用connect函数，在这里传递服务器地址，再调用send函数发送请求，但在TFO场景下，是不能调用connect函数的，否则就回归正常的三次握手了，所以要使用sendto等函数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590131385,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1068361,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","nickname":"明翼","note":"","ucode":"E77F86BEB3D5C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364953,"discussion_content":"是不是第一次还是要调用connect ，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617671211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"一步","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276608,"discussion_content":"sendto 或者 sendmsg 就是不进行三次握手了，直接携带 cookie 发送信息","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590912936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218342,"user_name":"凉人。","can_delete":false,"product_type":"c1","uid":1659177,"ip_address":"","ucode":"4DB16004A62015","user_header":"https://static001.geekbang.org/account/avatar/00/19/51/29/24739c58.jpg","comment_is_top":false,"comment_ctime":1589784318,"is_pvip":false,"replies":[{"id":"90924","content":"谢谢凉人的分享","user_name":"作者回复","comment_id":218342,"uid":"1283912","ip_address":"","utype":1,"ctime":1599786392,"user_name_real":"陶辉"}],"discussion_count":1,"race_medal":0,"score":"44539457278","product_id":100051201,"comment_content":"做过优化，长连接， 减少time_wait时长，复用time_wait连接","like_count":10,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495439,"discussion_content":"谢谢凉人的分享","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599786392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230208,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1593312143,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31658083215","product_id":100051201,"comment_content":"看来要做一个能承受高并发的服务端，从前到后各个节点都要做关注和优化：syn半连接队列---&gt;accept队列----&gt;应用程序连接获取速度（epoll异步编程）---&gt;应用程序获取连接后的业务处理速度（非阻塞）。","like_count":7},{"had_liked":false,"id":218414,"user_name":"Geek_007","can_delete":false,"product_type":"c1","uid":1467182,"ip_address":"","ucode":"C80107538EAA7F","user_header":"https://static001.geekbang.org/account/avatar/00/16/63/2e/e49116d1.jpg","comment_is_top":false,"comment_ctime":1589799485,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27359603261","product_id":100051201,"comment_content":"老师，今天的内容很多只适用于内网通信或者服务端单边优化吧。生产场景，客户端经常是手机或者PC.无法修改客户端内核参数。另外TFO适用于公网么？运营商或者移动端会不会对TFO不支持。(难道非得QUIC才能优化客户端的网络连接吗)😀","like_count":6,"discussions":[{"author":{"id":1120761,"avatar":"https://static001.geekbang.org/account/avatar/00/11/19/f9/62ae32d7.jpg","nickname":"Ken","note":"","ucode":"9F829156E855C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":272152,"discussion_content":"维基告诉我们，android和ios均已支持\nhttps://zh.wikipedia.org/wiki/TCP%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1590247966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218279,"user_name":"那时刻","can_delete":false,"product_type":"c1","uid":1150927,"ip_address":"","ucode":"B0D150856C3A4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","comment_is_top":false,"comment_ctime":1589770995,"is_pvip":false,"replies":[{"id":"80744","content":"http&#47;1.1里的keepalive功能是个很好用的优化点^_^","user_name":"作者回复","comment_id":218279,"uid":"1283912","ip_address":"","utype":1,"ctime":1589782871,"user_name_real":"陶辉"}],"discussion_count":2,"race_medal":0,"score":"27359574771","product_id":100051201,"comment_content":"使用http的时候，为了减少tcp链接，重复使用已经链接的tcp，设置nginx的keepalive参数。","like_count":6,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495417,"discussion_content":"http/1.1里的keepalive功能是个很好用的优化点^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589782871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1286741,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a2/55/1092ebb8.jpg","nickname":"边城路远","note":"","ucode":"214ECD8981E87F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268897,"discussion_content":"1.客户端在回复ack时带上数据是比较通用的优化方式 2.降低服务端的synretries，有助于尽快释放半连接队列 ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589848290,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245377,"user_name":"半生","can_delete":false,"product_type":"c1","uid":1962148,"ip_address":"","ucode":"8F6BA3CA1AC1B2","user_header":"https://static001.geekbang.org/account/avatar/00/1d/f0/a4/9d8c3dc3.jpg","comment_is_top":false,"comment_ctime":1598927686,"is_pvip":false,"replies":[{"id":"90249","content":"如果应用层允许使用长连接（比如应用层的超时可能有上限），或者空闲连接占用的内存资源不在乎（长连接不只在内核，在应用层在每连接也要消耗KB级别以上的内存），就使用长连接。<br>TFO的开启是有前提的，至少两端都要支持。","user_name":"作者回复","comment_id":245377,"uid":"1283912","ip_address":"","utype":1,"ctime":1598941965,"user_name_real":"陶辉"}],"discussion_count":1,"race_medal":0,"score":"18778796870","product_id":100051201,"comment_content":"老师，请教一个问题，都是减少tcp握手的代价，那tfo和长链接分别是什么使用场景，或者说，什么场景下，tfo会比长链接性价比更高？","like_count":4,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504866,"discussion_content":"如果应用层允许使用长连接（比如应用层的超时可能有上限），或者空闲连接占用的内存资源不在乎（长连接不只在内核，在应用层在每连接也要消耗KB级别以上的内存），就使用长连接。\nTFO的开启是有前提的，至少两端都要支持。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598941965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218242,"user_name":"唐朝首都","can_delete":false,"product_type":"c1","uid":1081233,"ip_address":"","ucode":"F72655AE0AE4CA","user_header":"https://static001.geekbang.org/account/avatar/00/10/7f/91/962eba1a.jpg","comment_is_top":false,"comment_ctime":1589764493,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14474666381","product_id":100051201,"comment_content":"刚学习了两个知识点：<br>（1）syncookies功能<br>当SYN 半连接队列已满时，并非只能丢弃连接，服务端可以实时计算出一个状态值与SYN+ACK 报文一同发出，客户端返回报文时进行实时解析验证，如果通过也是可以建立连接的，减少了客户端不断重试的时间。<br>（2）TFO<br>首次建立连接之后，客户端与服务端分别存储加密的Cookie，解决后续的信任问题，这样后续就无需再经历同样的三次握手，减少建立连接的时间。","like_count":3},{"had_liked":false,"id":218206,"user_name":"我来也","can_delete":false,"product_type":"c1","uid":1205253,"ip_address":"","ucode":"773D6104F56767","user_header":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","comment_is_top":false,"comment_ctime":1589757799,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14474659687","product_id":100051201,"comment_content":"很实用的一篇文章。<br><br>今天又有新的收获，原来TFO是这么个意思，原理是这样的。<br>之前只在某些网络代理软件中看到过tcp_fastopen选项，但不知道啥意思。现在就明白了。<br>话说光软件层面开启了，内核未开启，也是享受不了的。这个就得看看内核是否默认开启了。","like_count":3},{"had_liked":false,"id":235675,"user_name":"Douglas","can_delete":false,"product_type":"c1","uid":1073027,"ip_address":"","ucode":"CFDE3D76B9DAE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/83/bb728e53.jpg","comment_is_top":false,"comment_ctime":1595146031,"is_pvip":false,"replies":[{"id":"88423","content":"默认的行为是新进入的报文直接丢弃。这样，如果几秒后accept队列消费掉了，那么客户端超时重发的DATA+ACK到了，连接就会再次建立","user_name":"作者回复","comment_id":235675,"uid":"1283912","ip_address":"","utype":1,"ctime":1596523630,"user_name_real":"陶辉"}],"discussion_count":4,"race_medal":0,"score":"10185080623","product_id":100051201,"comment_content":"【accept队列溢出】这里讲的比较模糊，accept队列溢出。是把已经建立好的连接丢弃， 还是因为队列已满，所以，后续进来的连接直接丢弃呢？","like_count":2,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501802,"discussion_content":"默认的行为是新进入的报文直接丢弃。这样，如果几秒后accept队列消费掉了，那么客户端超时重发的DATA+ACK到了，连接就会再次建立","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596523630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2080899,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/c0/83/ca1c44d5.jpg","nickname":"west","note":"","ucode":"B42BF349E55900","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329816,"discussion_content":"客户端此时是establish状态，已经发送ACK了；为什么还会发ACK报文，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606463963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":3031867,"avatar":"","nickname":"Geek_1ca1a6","note":"","ucode":"F00B9A60D32A3E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2080899,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/c0/83/ca1c44d5.jpg","nickname":"west","note":"","ucode":"B42BF349E55900","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579699,"discussion_content":"因为之前发送的 ACK 报文因为队列溢出，没成功放入accept队列，所以需要重发，个人理解\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657621191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":329816,"ip_address":""},"score":579699,"extra":""}]},{"author":{"id":1073027,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5f/83/bb728e53.jpg","nickname":"Douglas","note":"","ucode":"CFDE3D76B9DAE6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296572,"discussion_content":"明白了，谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596591788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219883,"user_name":"猿人谷","can_delete":false,"product_type":"c1","uid":1100149,"ip_address":"","ucode":"85106C7FB14C43","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/75/62ce2d69.jpg","comment_is_top":false,"comment_ctime":1590114124,"is_pvip":true,"replies":[{"id":"81195","content":"谢谢^_^","user_name":"作者回复","comment_id":219883,"uid":"1283912","ip_address":"","utype":1,"ctime":1590130892,"user_name_real":"陶辉"}],"discussion_count":1,"race_medal":0,"score":"10180048716","product_id":100051201,"comment_content":"这篇文章太精彩了，赏心悦目啊","like_count":2,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495977,"discussion_content":"谢谢^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590130892,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218967,"user_name":"爱谁谁","can_delete":false,"product_type":"c1","uid":1066009,"ip_address":"","ucode":"C333E8A5AF9713","user_header":"https://static001.geekbang.org/account/avatar/00/10/44/19/a2fa21af.jpg","comment_is_top":false,"comment_ctime":1589904891,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10179839483","product_id":100051201,"comment_content":"预建连接，连接复用，多IP竞速建立链接和复合连接~ ","like_count":1},{"had_liked":false,"id":266784,"user_name":"军","can_delete":false,"product_type":"c1","uid":1344780,"ip_address":"","ucode":"B53BBE36FA1286","user_header":"https://static001.geekbang.org/account/avatar/00/14/85/0c/252a1149.jpg","comment_is_top":false,"comment_ctime":1607486292,"is_pvip":false,"replies":[{"id":"97242","content":"^_^","user_name":"作者回复","comment_id":266784,"uid":"1283912","ip_address":"","utype":1,"ctime":1607908147,"user_name_real":"陶辉"}],"discussion_count":1,"race_medal":0,"score":"5902453588","product_id":100051201,"comment_content":"感觉小林coding就是抄的这篇，太干货了，😁","like_count":2,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511387,"discussion_content":"^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607908147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226177,"user_name":"stackWarn","can_delete":false,"product_type":"c1","uid":1002005,"ip_address":"","ucode":"89672E452DEBA5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/15/106eaaa8.jpg","comment_is_top":false,"comment_ctime":1591971827,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5886939123","product_id":100051201,"comment_content":"老师讲的优化在运维工作中都有做过，关于连接队列可以通过systemtap等工具去做下实验，我补充下自己曾经做过测试的结论，半连接队列大小的值和 tcp_max_syn_backlog  以及全连接队列的那两个参数即 somaxconn 和 应用层的backlog 这三个都有关系，感谢老师的讲解，不知道生产环境中tfo有没有什么问题呢？现在有哪些公司是否有开启TFO了，求科普","like_count":1},{"had_liked":false,"id":222326,"user_name":"Raymond","can_delete":false,"product_type":"c1","uid":2011026,"ip_address":"","ucode":"7A17680E537D57","user_header":"https://static001.geekbang.org/account/avatar/00/1e/af/92/164e40f3.jpg","comment_is_top":false,"comment_ctime":1590749020,"is_pvip":false,"replies":[{"id":"82060","content":"你好Raymond，<br>1、客户端不需要队列，它并不需要监听某个端口再建立连接。<br>2、对的","user_name":"作者回复","comment_id":222326,"uid":"1283912","ip_address":"","utype":1,"ctime":1590842533,"user_name_real":"陶辉"}],"discussion_count":1,"race_medal":0,"score":"5885716316","product_id":100051201,"comment_content":"老师 今天内容很有价值让我对tcp连接有了更深入的了解，此时我有些问题 1.在内容中只讲到了服务端在建立连接的时候 会维护 半连接队列，和accep队列，我想问在这个过程当中，客户端会维护队列吗？如果有的 是什么样结构和规范?第二个问题  就是确认下 我今天听课的一个 收获， 我的总结是 在tcp传输过程当中 无论是客户端和服务端 再给对方发送请求时 必须要有回应，如果没有回应就会通过重试机制来重发，重试一定次数后仍然没有回应 就确认失败， 而对方在处理请求异常后，比如服务端队列已满，无法建立连接，或者异常之后，默认情况下也不会告诉对方，通过对方的重试来感知失败，RST复位是个例外 ","like_count":1,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496751,"discussion_content":"你好Raymond，\n1、客户端不需要队列，它并不需要监听某个端口再建立连接。\n2、对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590842533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219368,"user_name":"eason2017","can_delete":false,"product_type":"c1","uid":1009422,"ip_address":"","ucode":"E070BA624FA490","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/0e/c77ad9b1.jpg","comment_is_top":false,"comment_ctime":1590019566,"is_pvip":false,"replies":[{"id":"81151","content":"^_^","user_name":"作者回复","comment_id":219368,"uid":"1283912","ip_address":"","utype":1,"ctime":1590103418,"user_name_real":"陶辉"}],"discussion_count":1,"race_medal":0,"score":"5884986862","product_id":100051201,"comment_content":"文章精彩，佩付大师！","like_count":1,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495784,"discussion_content":"^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590103418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219311,"user_name":"董泽润","can_delete":false,"product_type":"c1","uid":1048718,"ip_address":"","ucode":"0859A6ECCB5473","user_header":"https://static001.geekbang.org/account/avatar/00/10/00/8e/ebe3c8ea.jpg","comment_is_top":false,"comment_ctime":1589987488,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884954784","product_id":100051201,"comment_content":"访量很大时，time_wait 会非常多，一般都用长连接来规避这个问题。但是长连接也有问题，比如保活，比如当服务端挂了，但是因为网络隔离客户端还没感知道，这时请求就会有大量超时","like_count":1},{"had_liked":false,"id":218805,"user_name":"有朋自远方来","can_delete":false,"product_type":"c1","uid":1083600,"ip_address":"","ucode":"23A12829DEB119","user_header":"https://static001.geekbang.org/account/avatar/00/10/88/d0/6e75f766.jpg","comment_is_top":false,"comment_ctime":1589878652,"is_pvip":false,"replies":[{"id":"81205","content":"不是哦，那个是HTTP协议中的概念","user_name":"作者回复","comment_id":218805,"uid":"1283912","ip_address":"","utype":1,"ctime":1590134353,"user_name_real":"陶辉"}],"discussion_count":3,"race_medal":0,"score":"5884845948","product_id":100051201,"comment_content":"这个 cookie  和常说的 cookie session 是一回事么？","like_count":1,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495581,"discussion_content":"不是哦，那个是HTTP协议中的概念","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590134353,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1123043,"avatar":"https://static001.geekbang.org/account/avatar/00/11/22/e3/510b69f9.jpg","nickname":"benny","note":"","ucode":"E2F30AF0C808D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299539,"discussion_content":"jwt是啥缩写？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597728524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1118627,"avatar":"https://static001.geekbang.org/account/avatar/00/11/11/a3/7a2405ca.jpg","nickname":"rfyiamcool","note":"","ucode":"65FCBF05B13893","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284078,"discussion_content":"按照应用层来说的话，可粗糙的理解为jwt。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592442027,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218666,"user_name":"小一日一","can_delete":false,"product_type":"c1","uid":1301097,"ip_address":"","ucode":"0A506C2B918C14","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtVXiaJbfkpeXH4udkPUIlFte7z3HWMebdogk8jFpgFEkJ0ruGiawUMUcZj9RLpLkIWxV7QOzbHoSg/132","comment_is_top":false,"comment_ctime":1589851958,"is_pvip":false,"replies":[{"id":"80908","content":"^_^","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1589935138,"ip_address":"","comment_id":218666,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5884819254","product_id":100051201,"comment_content":"干货满满的一节，感谢老师","like_count":1,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495537,"discussion_content":"^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589935138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344421,"user_name":"铲铲队","can_delete":false,"product_type":"c1","uid":1132569,"ip_address":"","ucode":"D16372C34B7AE3","user_header":"https://static001.geekbang.org/account/avatar/00/11/48/19/14dd81d9.jpg","comment_is_top":false,"comment_ctime":1651543884,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651543884","product_id":100051201,"comment_content":"“开启 syncookies 功能就可以在不使用 SYN 队列的情况下成功建立连接”   ---&gt;怎么理解这句话呢，老师，我看这句话的配图，看起来比较迷惑，看起来收到SYN后还是会放到SYN队列，然后返回SYN cookie的样子，怎么解释没有使用SYN队列？对于这种情况下，收到SYN以后，数据是怎么存放的？","like_count":0},{"had_liked":false,"id":344420,"user_name":"铲铲队","can_delete":false,"product_type":"c1","uid":1132569,"ip_address":"","ucode":"D16372C34B7AE3","user_header":"https://static001.geekbang.org/account/avatar/00/11/48/19/14dd81d9.jpg","comment_is_top":false,"comment_ctime":1651543530,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651543530","product_id":100051201,"comment_content":"老师，您好，sysyncookies中的cookie和TFO中的cookie是一个东西吧？","like_count":0},{"had_liked":false,"id":330676,"user_name":"David.cui","can_delete":false,"product_type":"c1","uid":1302228,"ip_address":"","ucode":"AB46F310403612","user_header":"https://static001.geekbang.org/account/avatar/00/13/de/d4/b83c4185.jpg","comment_is_top":false,"comment_ctime":1642115030,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642115030","product_id":100051201,"comment_content":"<br>net.ipv4.tcp_syn_retries = 6。应该在服务器还是客户端设置","like_count":0},{"had_liked":false,"id":287993,"user_name":"Geek_LYQ","can_delete":false,"product_type":"c1","uid":2543581,"ip_address":"","ucode":"CD57643A24D508","user_header":"","comment_is_top":false,"comment_ctime":1618243323,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618243323","product_id":100051201,"comment_content":"通常情况下，应当把 tcp_abort_on_overflow 设置为 0，因为这样更有利于应对突发流量。举个例子，当 accept 队列满导致服务器丢掉了 ACK，与此同时，客户端的连接状态却是 ESTABLISHED，进程就在建立好的连接上发送请求。只要服务器没有为请求回复 ACK，请求就会被多次重发。<br>陶老师，这句话“只要服务器没有为请求回复 ACK，请求就会被多次重发”不理解，Server由于连接队列满而丢ACK情况下，服务端已经是ESTABLISHED状态，并不会再回复ACK给客户端了，那么客户端怎么知道要重复ACK+请求数据呢？<br><br>","like_count":0},{"had_liked":false,"id":286581,"user_name":"枫中浪子","can_delete":false,"product_type":"c1","uid":2351949,"ip_address":"","ucode":"860BEA32059B37","user_header":"https://static001.geekbang.org/account/avatar/00/23/e3/4d/8a26dbb2.jpg","comment_is_top":false,"comment_ctime":1617409712,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617409712","product_id":100051201,"comment_content":"文中写到：客户端发送 SYN 开启了三次握手，此时在客户端上用 netstat 命令（后续查看连接状态都使用该命令）可以看到连接的状态是 SYN_SENT（顾名思义，就是把刚 SYN 发送出去）。<br>请问老师这个syn是用什么工具构造的？如果不是构造的，正常情况下三次握手很快，看不到连接的中间状态吧","like_count":0},{"had_liked":false,"id":230703,"user_name":"G.S.K","can_delete":false,"product_type":"c1","uid":1222966,"ip_address":"","ucode":"88217F9289EB48","user_header":"https://static001.geekbang.org/account/avatar/00/12/a9/36/d054c979.jpg","comment_is_top":false,"comment_ctime":1593474108,"is_pvip":false,"replies":[{"id":"90487","content":"在生产者、消费者模型中，需要1个队列来缓冲两者速率的不同。socket句柄可以标识连接。","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1599212885,"ip_address":"","comment_id":230703,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593474108","product_id":100051201,"comment_content":"老师，syn半连接队列、accept连接队列为什么采用队列这种数据结构，五元组是如何跟队列中的某一项关联起来的呢？","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499999,"discussion_content":"在生产者、消费者模型中，需要1个队列来缓冲两者速率的不同。socket句柄可以标识连接。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599212885,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229170,"user_name":"Kvicii.Y","can_delete":false,"product_type":"c1","uid":1442588,"ip_address":"","ucode":"446BFA633569EA","user_header":"https://static001.geekbang.org/account/avatar/00/16/03/1c/c9fe6738.jpg","comment_is_top":false,"comment_ctime":1592915685,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1592915685","product_id":100051201,"comment_content":"TFO只是省掉了第二阶段客户端到服务端到那个ACK的RTT吗？","like_count":0,"discussions":[{"author":{"id":3031867,"avatar":"","nickname":"Geek_1ca1a6","note":"","ucode":"F00B9A60D32A3E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579701,"discussion_content":"个人理解：TFO 在之后建立连接的时候，原本第一次握手直接可以携带数据了，就不用单纯去建立连接。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657621595,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229087,"user_name":"thomas","can_delete":false,"product_type":"c1","uid":1016777,"ip_address":"","ucode":"9AB945308F1B50","user_header":"https://static001.geekbang.org/account/avatar/00/0f/83/c9/5d03981a.jpg","comment_is_top":false,"comment_ctime":1592894889,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1592894889","product_id":100051201,"comment_content":"老师，对SYN半连接队列和ACCEPT连接队列有一些疑问。假如有两个SYN请求R1, R2依次到达服务端并收到ACK+SYN响应， 现在SYN-Q队列就有R1,R2两个值。R2发送的ACK请求先到达，服务端内核从SYN-Q队列取出第一条数据R1，发现不是R2的数据，再把R1放回队列，继续查找R2吗？","like_count":0},{"had_liked":false,"id":226279,"user_name":"colonel","can_delete":false,"product_type":"c1","uid":1200916,"ip_address":"","ucode":"F71EE1C23A8D83","user_header":"https://static001.geekbang.org/account/avatar/00/12/53/14/2b93d757.jpg","comment_is_top":false,"comment_ctime":1592020301,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1592020301","product_id":100051201,"comment_content":"syncookie功能是不是也需要客户端开启该功能才能发挥作用？<br>","like_count":0,"discussions":[{"author":{"id":1118627,"avatar":"https://static001.geekbang.org/account/avatar/00/11/11/a3/7a2405ca.jpg","nickname":"rfyiamcool","note":"","ucode":"65FCBF05B13893","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284081,"discussion_content":"不需要的，服务端通过算法生成一个seq，客户端ack时会加一，服务端可到解析正确性。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592442285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1123043,"avatar":"https://static001.geekbang.org/account/avatar/00/11/22/e3/510b69f9.jpg","nickname":"benny","note":"","ucode":"E2F30AF0C808D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1118627,"avatar":"https://static001.geekbang.org/account/avatar/00/11/11/a3/7a2405ca.jpg","nickname":"rfyiamcool","note":"","ucode":"65FCBF05B13893","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":299540,"discussion_content":"需要吧 客户端下一次请求时也要到带上cookie","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597728892,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":284081,"ip_address":""},"score":299540,"extra":""}]}]},{"had_liked":false,"id":225705,"user_name":"左氧佛沙星人","can_delete":false,"product_type":"c1","uid":1195278,"ip_address":"","ucode":"0D8295E1DABA8C","user_header":"https://static001.geekbang.org/account/avatar/00/12/3d/0e/92176eaa.jpg","comment_is_top":false,"comment_ctime":1591837921,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1591837921","product_id":100051201,"comment_content":"老师，accept队列满会不会导致服务的connection closed呢？导致这一场景的原因都可能有哪些呢？我们k8环境中，网络间歇性有connection closed，在长时间抓包分析中，服务端和客户端都是正常的","like_count":0},{"had_liked":false,"id":225053,"user_name":"为人民服务","can_delete":false,"product_type":"c1","uid":1135195,"ip_address":"","ucode":"BFF5CD3EDF1303","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/5b/92eff66d.jpg","comment_is_top":false,"comment_ctime":1591625257,"is_pvip":false,"replies":[{"id":"82863","content":"很高兴那门视频课能够给到你帮助^_^","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1591660609,"ip_address":"","comment_id":225053,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591625257","product_id":100051201,"comment_content":"很强很强，陶老师的nginx真是在工作中受益良多。","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497711,"discussion_content":"很高兴那门视频课能够给到你帮助^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591660609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223830,"user_name":"龙龙","can_delete":false,"product_type":"c1","uid":1142957,"ip_address":"","ucode":"C6619820ABCE1C","user_header":"https://static001.geekbang.org/account/avatar/00/11/70/ad/cc353727.jpg","comment_is_top":false,"comment_ctime":1591192832,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1591192832","product_id":100051201,"comment_content":"通常情况下，应当把 tcp_abort_on_overflow 设置为 0，因为这样更有利于应对突发流量。举个例子，当 accept 队列满导致服务器丢掉了 ACK，与此同时，客户端的连接状态却是 ESTABLISHED，进程就在建立好的连接上发送请求。只要服务器没有为请求回复 ACK，请求就会被多次重发。如果服务器上的进程只是短暂的繁忙造成 accept 队列满，那么当 accept 队列有空位时，再次接收到的请求报文由于含有 ACK，仍然会触发服务器端成功建立连接。所以，<br>————————————————————-<br>老师，这句话我怎么看都觉得有点问题，比如突发流量导致accept队列短暂满，然后有一次连接因为accept队列满服务器丢掉了Ack，此时对于客户端是处于establish，此时客户端给服务器发数据，因为服务器认为没用建立好连接，客户端发送的数据收不到回复，于是会重发。可能会重发多次，但是可能服务器突然不忙了，accept队列有空位了，此时老师您说  ”再次接收到的请求报文由于含有 ACK，仍然会触发服务器端成功建立连接”，这句话从何说起啊，为什么再次接收到的报文会含有ACK，我想了好几天都没想明白，是不是老师您说错了，求释疑，谢谢。","like_count":0,"discussions":[{"author":{"id":2080899,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/c0/83/ca1c44d5.jpg","nickname":"west","note":"","ucode":"B42BF349E55900","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294571,"discussion_content":"我感觉应该不是丢弃了，而是从半链接队列中不取出来放到accept队列中，但是当accept队列空闲的时候，通过客户的ack把半链接放到accept队列中，那这个ack怎么来的呢，毕竟客户端这个时候已经处于ES状态，不会再发ack吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595929834,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2079873,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKlibz5085KSjlsAqSrYKiboLvzm3TYibVAMHjbCz6ibpcUWMa2AOUctyvVRSuVe3HP7YwYcwzwYmh5GQ/132","nickname":"maosd199554","note":"","ucode":"B34D78FF9CB378","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293800,"discussion_content":"tcp是有重传机制的，当服务器accept队列满后，客户端发送首个数据过来，首个数据是带有最后一次握手的ack的，但是此时服务器无法给予响应，等到队列有空闲时才响应","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595670794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1118627,"avatar":"https://static001.geekbang.org/account/avatar/00/11/11/a3/7a2405ca.jpg","nickname":"rfyiamcool","note":"","ucode":"65FCBF05B13893","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284111,"discussion_content":"你可以通过抓包验证一下，tcp_abort_on_overflows=0 and accept queue = full，那么这时候服务端会把连接标记为acked，然后移到syn queue里，启动定时器重发syn ack。但客户端发完ack已经认为自己是es状态了，所以可正常发送数据，但服务端不给与回应，所以客户端不断的重试，直到超时。  ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592446541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222731,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1590900167,"is_pvip":true,"replies":[{"id":"82257","content":"你好，我习惯使用sysctl -a查看系统参数，包括网络部分","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1591059462,"ip_address":"","comment_id":222731,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590900167","product_id":100051201,"comment_content":"这些 linux 有关网络的参数 是怎么查看的？哪个参数在哪个配置文件的？ 可以直接查询到吗？","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496896,"discussion_content":"你好，我习惯使用sysctl -a查看系统参数，包括网络部分","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591059462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221853,"user_name":"边城路远","can_delete":false,"product_type":"c1","uid":1286741,"ip_address":"","ucode":"214ECD8981E87F","user_header":"https://static001.geekbang.org/account/avatar/00/13/a2/55/1092ebb8.jpg","comment_is_top":false,"comment_ctime":1590623168,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590623168","product_id":100051201,"comment_content":"有个问题，服务端因为全连接队列满，如果不设置tcp_abort_on_overflow就直接把连接丢弃了，那么客户端如何进入ESTABLISHED状态呢？","like_count":0},{"had_liked":false,"id":221708,"user_name":"橘之山","can_delete":false,"product_type":"c1","uid":1686019,"ip_address":"","ucode":"2B4B8E873990C0","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epzrT5lskkzfFmOE5FVHsl7VDeGwVFhcPFchuoWlN3oqoAJF7LFU2wrGichkEEIMOSWUpM8P4Ew2mw/132","comment_is_top":false,"comment_ctime":1590571191,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1590571191","product_id":100051201,"comment_content":"老师您好，有个地方不太明白，按您原文所说：“如果服务器上的进程只是短暂的繁忙造成 accept 队列满，那么当 accept 队列有空位时，再次接收到的请求报文由于含有 ACK，仍然会触发服务器端成功建立连接。” <br><br>我不太明白服务器端怎么能成功建立连接。<br>按您之前说的 “服务器收到 ACK 后连接建立成功，此时，内核会把连接从 SYN 半连接队列中移出，再移入 accept 队列&quot;，  那如果accept 队列满，这个连接相当于被丢弃了。即使之后accept 队列不满了，连接也找不回来了。 那之后client发送的请求里即使带有ACK， server端的连接都没有了，怎么建立连接呢？ ","like_count":0,"discussions":[{"author":{"id":1002005,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4a/15/106eaaa8.jpg","nickname":"stackWarn","note":"","ucode":"89672E452DEBA5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282433,"discussion_content":"并没丢弃，会忽略掉这个syn并且主动重发syn+ack，意思就是让客户端再次重发，可以理解为 “本次坐席已满，然后时不时提醒你再来看看有没有空位” 你说气人不","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591972020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2080899,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/c0/83/ca1c44d5.jpg","nickname":"west","note":"","ucode":"B42BF349E55900","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329826,"discussion_content":"测试了一下，accept队列满了，syn队列中连接并没有丢弃，而且服务端过一段时间会重发syn+ack","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606465421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1002005,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4a/15/106eaaa8.jpg","nickname":"stackWarn","note":"","ucode":"89672E452DEBA5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282434,"discussion_content":"如果配置了abort就直接发reset了，就真的关了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591972068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220663,"user_name":"小林coding","can_delete":false,"product_type":"c1","uid":1303210,"ip_address":"","ucode":"D57D7DBF260216","user_header":"https://static001.geekbang.org/account/avatar/00/13/e2/aa/9ddc6469.jpg","comment_is_top":false,"comment_ctime":1590306055,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1590306055","product_id":100051201,"comment_content":"陶辉老师，我用 hping 命令模拟 tcp 洪泛的测试，发现不管怎么调大  tcp_max_syn_backlog，服务端的 SYN_RECV 状态一直最大只有 256 个，我测试的 Linux 内核是版本 2.6.32-431.el6.x86_64 <br><br>然后在网上搜索了下资料，https:&#47;&#47;www.cnblogs.com&#47;zengkefu&#47;p&#47;5606696.html，发现 TCP 半连接队列的大小不是简单由 tcp_max_syn_backlog 决定，还会跟 TCP 全连接队列有关系。","like_count":0,"discussions":[{"author":{"id":1002005,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4a/15/106eaaa8.jpg","nickname":"stackWarn","note":"","ucode":"89672E452DEBA5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282436,"discussion_content":"对的 和syn backlog 以及 影响全连接队列的 somaxconn 和应用程序backlog 三个参数有关。可以使用systemtap测试下 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591972185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220617,"user_name":"🎧重返归途","can_delete":false,"product_type":"c1","uid":1991518,"ip_address":"","ucode":"33F748AE188B07","user_header":"https://static001.geekbang.org/account/avatar/00/1e/63/5e/799cd6dc.jpg","comment_is_top":false,"comment_ctime":1590294831,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590294831","product_id":100051201,"comment_content":"这节收获很多！<br>应用连接数，服务器进程文件数量和连接数数，tcp超时时间等；比较明显的是tcp超时时间设置，应用有更长时间对错误tcp状态进行报错提示。","like_count":0},{"had_liked":false,"id":219317,"user_name":"崔伟协","can_delete":false,"product_type":"c1","uid":1022452,"ip_address":"","ucode":"ACDEEDF2A10999","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/f4/e0484cac.jpg","comment_is_top":false,"comment_ctime":1589988081,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1589988081","product_id":100051201,"comment_content":"现在网络上tfo的连接多吗，占多少比率","like_count":0},{"had_liked":false,"id":218809,"user_name":"holly","can_delete":false,"product_type":"c1","uid":1609350,"ip_address":"","ucode":"9D57569ED81CBA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/2rRMjRdMelicUoU5yXibENlYapdvPUCibOk8bGicyFoIW7IMxMqhicgelVphEmWFpMucVXjQjv5pdu6RgDkNiav0qUcw/132","comment_is_top":false,"comment_ctime":1589879417,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1589879417","product_id":100051201,"comment_content":"我集群中的一台服务器出现了大量的LAST_ACK,三次握手看了多遍还是不知从何处开始分析。用neststat查看<br>LAST_ACK 2056<br>LISTEN 8<br>CLOSE_WAIT 10<br>ESTABLISHED 7273<br>FIN_WAIT1 1<br>FIN_WAIT2 3<br>SYN_SENT 2<br>TIME_WAIT 26<br>其它正常的服务器中的一台LAST_ACK 2056<br>LISTEN 8<br>CLOSE_WAIT 17<br>ESTABLISHED 7940<br>FIN_WAIT1 1<br>FIN_WAIT2 3<br>TIME_WAIT 56<br>查找资料说根据TCP状态变化过程分析LAST_ACK是属于主动还是被动，可是该资料没说怎么根据tcp状态变化过程分析，只是给出了是主动还是被动的结果，希望老师给个思路","like_count":0,"discussions":[{"author":{"id":1134399,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4f/3f/56911dd3.jpg","nickname":"Summer","note":"","ucode":"7266767F72B02E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297050,"discussion_content":"老师，我看你的图中TCP三次握手阶段在客户端回复服务端的SYN包时就可以发送请求数据了是吗？我在其他资料上看到的是三次握手阶段还没有发送数据请求。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596761518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}