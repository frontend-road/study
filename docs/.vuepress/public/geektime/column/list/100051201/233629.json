{"id":233629,"title":"05 | 协程：如何快速地实现高并发服务？","content":"<p>你好，我是陶辉。</p><p>上一讲谈到，零拷贝通过减少上下文切换次数，提升了文件传输的性能。事实上高并发服务也是通过降低切换成本实现的，这一讲我们来看看它是如何做到的。</p><p>如果你需要访问多个服务来完成一个请求的处理，比如实现文件上传功能时，首先访问Redis缓存，验证用户是否登陆，再接收HTTP消息中的body并保存在磁盘上，最后把文件路径等信息写入MySQL数据库中，你会怎么做？</p><p>用阻塞API写同步代码最简单，但一个线程同一时间只能处理一个请求，有限的线程数导致无法实现万级别的并发连接，过多的线程切换也抢走了CPU的时间，从而降低了每秒能够处理的请求数量。</p><p>为了达到高并发，你可能会选择一个异步框架，用非阻塞API把业务逻辑打乱到多个回调函数，通过多路复用实现高并发，然而，由于业务代码过度关注并发细节，需要维护很多中间状态，不但Bug率会很高，项目的开发速度也上不去，产品及时上线存在风险。</p><p>如果想兼顾开发效率，又能保证高并发，协程就是最好的选择。它可以在保持异步化运行机制的同时，用同步方式写代码，这在实现高并发的同时，缩短了开发周期，是高性能服务未来的发展方向。</p><p>你会发现，解决高并发问题的技术一直在变化，从多进程、多线程，到异步化、协程，面对不同的场景，它们都在用各自不同的方式解决问题。我们就来看看，高并发的解决方案是怎么演进的，协程到底解决了什么问题，它又该如何应用。</p><!-- [[[read_end]]] --><h2>如何通过切换请求实现高并发？</h2><p>我们知道，主机上资源有限，一颗CPU、一块磁盘、一张网卡，如何同时服务上百个请求呢？多进程模式是最初的解决方案。内核把CPU的执行时间切分成许多时间片（timeslice），比如1秒钟可以切分为100个10毫秒的时间片，每个时间片再分发给不同的进程，通常，每个进程需要多个时间片才能完成一个请求。</p><p>这样，虽然微观上，比如说就这10毫秒时间CPU只能执行一个进程，但宏观上1秒钟执行了100个时间片，于是每个时间片所属进程中的请求也得到了执行，<strong>这就实现了请求的并发执行。</strong></p><p>不过，每个进程的内存空间都是独立的，这样用多进程实现并发就有两个缺点：一是内核的管理成本高，二是无法简单地通过内存同步数据，很不方便。于是，多线程模式就出现了，多线程模式通过共享内存地址空间，解决了这两个问题。</p><p>然而，共享地址空间虽然可以方便地共享对象，但这也导致一个问题，那就是任何一个线程出错时，进程中的所有线程会跟着一起崩溃。这也是如Nginx等强调稳定性的服务坚持使用多进程模式的原因。</p><p>事实上，无论基于多进程还是多线程，都难以实现高并发，这由两个原因所致。</p><p>首先，单个线程消耗的内存过多，比如，64位的Linux为每个线程的栈分配了8MB的内存，还预分配了64MB的内存作为堆内存池（你可以从<a href=\"https://time.geekbang.org/column/article/230221\">[第2讲]</a> 中找到Linux系统为什么这么做）。所以，我们没有足够的内存去开启几万个线程实现并发。</p><p>其次，切换请求是内核通过切换线程实现的，什么时候会切换线程呢？不只时间片用尽，<strong>当调用阻塞方法时，内核为了让CPU充分工作，也会切换到其他线程执行。</strong>一次上下文切换的成本在几十纳秒到几微秒间，当线程繁忙且数量众多时，这些切换会消耗绝大部分的CPU运算能力。</p><p>下图以上一讲介绍过的磁盘IO为例，描述了多线程中使用阻塞方法读磁盘，2个线程间的切换方式。</p><p><img src=\"https://static001.geekbang.org/resource/image/a7/1e/a7729794e84cbb4a295454c6f2005c1e.jpg?wh=3452*2556\" alt=\"\"></p><p>那么，怎么才能实现高并发呢？<strong>把上图中本来由内核实现的请求切换工作，交由用户态的代码来完成就可以了</strong>，异步化编程通过应用层代码实现了请求切换，降低了切换成本和内存占用空间。异步化依赖于IO多路复用机制，比如Linux的epoll或者Windows上的iocp，同时，必须把阻塞方法更改为非阻塞方法，才能避免内核切换带来的巨大消耗。Nginx、Redis等高性能服务都依赖异步化实现了百万量级的并发。</p><p>下图描述了异步IO的非阻塞读和异步框架结合后，是如何切换请求的。</p><p><img src=\"https://static001.geekbang.org/resource/image/5f/8e/5f5ad4282571d8148d87416c8f8fa88e.jpg?wh=4409*2879\" alt=\"\"></p><p><strong>然而，写异步化代码很容易出错。</strong>因为所有阻塞函数，都需要通过非阻塞的系统调用拆分成两个函数。虽然这两个函数共同完成一个功能，但调用方式却不同。第一个函数由你显式调用，第二个函数则由多路复用机制调用。这种方式违反了软件工程的内聚性原则，函数间同步数据也更复杂。特别是条件分支众多、涉及大量系统调用时，异步化的改造工作会非常困难。</p><p>有没有办法既享受到异步化带来的高并发，又可以使用阻塞函数写同步化代码呢？</p><p>协程可以做到，<strong>它在异步化之上包了一层外衣，兼顾了开发效率与运行效率。</strong></p><h2>协程是如何实现高并发的？</h2><p>协程与异步编程相似的地方在于，它们必须使用非阻塞的系统调用与内核交互，把切换请求的权力牢牢掌握在用户态的代码中。但不同的地方在于，协程把异步化中的两段函数，封装为一个阻塞的协程函数。这个函数执行时，会使调用它的协程无感知地放弃执行权，由协程框架切换到其他就绪的协程继续执行。当这个函数的结果满足后，协程框架再选择合适的时机，切换回它所在的协程继续执行。如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/e4/57/e47ec54ff370cbda4528e285e3378857.jpg?wh=4329*2821\" alt=\"\"></p><p>看起来非常棒，然而，异步化是通过回调函数来完成请求切换的，业务逻辑与并发实现关联在一起，很容易出错。协程不需要什么“回调函数”，它允许用户调用“阻塞的”协程方法，用同步编程方式写业务逻辑。</p><p>那协程的切换是如何完成的呢？</p><p>实际上，<strong>用户态的代码切换协程，与内核切换线程的原理是一样的。</strong>内核通过管理CPU的寄存器来切换线程，我们以最重要的栈寄存器和指令寄存器为例，看看协程切换时如何切换程序指令与内存。</p><p>每个线程有独立的栈，而栈既保留了变量的值，也保留了函数的调用关系、参数和返回值，CPU中的栈寄存器SP指向了当前线程的栈，而指令寄存器IP保存着下一条要执行的指令地址。因此，从线程1切换到线程2时，首先要把SP、IP寄存器的值为线程1保存下来，再从内存中找出线程2上一次切换前保存好的寄存器值，写入CPU的寄存器，这样就完成了线程切换。（其他寄存器也需要管理、替换，原理与此相同，不再赘述。）</p><p>协程的切换与此相同，只是把内核的工作转移到协程框架实现而已，下图是协程切换前的状态：</p><p><img src=\"https://static001.geekbang.org/resource/image/a8/f7/a83d7e0f37f35353c6347aa76c8184f7.jpg?wh=5236*3043\" alt=\"\"></p><p>从协程1切换到协程2后的状态如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/25/3f/25d2dcb8aa4569e5de741469f03aa73f.jpg?wh=5248*3698\" alt=\"\"></p><p>创建协程时，会从进程的堆中（参见<a href=\"https://time.geekbang.org/column/article/230221\">[第2讲]</a>）分配一段内存作为协程的栈。线程的栈有8MB，而协程栈的大小通常只有几十KB。而且，C库内存池也不会为协程预分配内存，它感知不到协程的存在。这样，更低的内存占用空间为高并发提供了保证，毕竟十万并发请求，就意味着10万个协程。当然，栈缩小后，就尽量不要使用递归函数，也不能在栈中申请过多的内存，这是实现高并发必须付出的代价。</p><p>由此可见，协程就是用户态的线程。然而，为了保证所有切换都在用户态进行，协程必须重新封装所有的阻塞系统调用，否则，一旦协程触发了线程切换，会导致这个线程进入休眠状态，进而其上的所有协程都得不到执行。比如，普通的sleep函数会让当前线程休眠，由内核来唤醒线程，而协程化改造后，sleep只会让当前协程休眠，由协程框架在指定时间后唤醒协程。再比如，线程间的互斥锁是使用信号量实现的，而信号量也会导致线程休眠，协程化改造互斥锁后，同样由框架来协调、同步各协程的执行。</p><p><strong>所以，协程的高性能，建立在切换必须由用户态代码完成之上，这要求协程生态是完整的，要尽量覆盖常见的组件。</strong>比如MySQL官方提供的客户端SDK，它使用了阻塞socket做网络访问，会导致线程休眠，必须用非阻塞socket把SDK改造为协程函数后，才能在协程中使用。</p><p>当然，并不是所有的函数都能用协程改造。比如<a href=\"https://time.geekbang.org/column/article/232676\">[第4讲]</a> 提到的异步IO，它虽然是非阻塞的，但无法使用PageCache，降低了系统吞吐量。如果使用缓存IO读文件，在没有命中PageCache时是可能发生阻塞的。</p><p>这种时候，如果对性能有更高的要求，就需要把线程与协程结合起来用，把可能阻塞的操作放在线程中执行，通过生产者/消费者模型与协程配合工作。</p><p>实际上，面对多核系统，也需要协程与线程配合工作。因为协程的载体是线程，而一个线程同一时间只能使用一颗CPU，所以通过开启更多的线程，将所有协程分布在这些线程中，就能充分使用CPU资源。</p><p>除此之外，为了让协程获得更多的CPU时间，还可以设置所在线程的优先级，比如Linux下把线程的优先级设置到-20，就可以每次获得更长的时间片。另外，<a href=\"https://time.geekbang.org/column/article/230194\">[第1讲]</a> 曾谈到CPU缓存对程序性能的影响，为了减少CPU缓存失效的比例，还可以把线程绑定到某个CPU上，增加协程执行时命中CPU缓存的机率。</p><p>虽然这一讲中谈到协程框架在调度协程，然而，你会发现，很多协程库只提供了创建、挂起、恢复执行等基本方法，并没有协程框架的存在，需要业务代码自行调度协程。这是因为，这些通用的协程库并不是专为服务器设计的。服务器中可以由客户端网络连接的建立，驱动着创建出协程，同时伴随着请求的结束而终止。在协程的运行条件不满足时，多路复用框架会将它挂起，并根据优先级策略选择另一个协程执行。</p><p>因此，使用协程实现服务器端的高并发服务时，并不只是选择协程库，还要从其生态中找到结合IO多路复用的协程框架，这样可以加快开发速度。</p><h2>小结</h2><p>这一讲，我们从高并发的应用场景入手，分析了协程出现的背景和实现原理，以及它的应用范围。你会发现，协程融合了多线程与异步化编程的优点，既保证了开发效率，也提升了运行效率。</p><p>有限的硬件资源下，多线程通过微观上时间片的切换，实现了同时服务上百个用户的能力。多线程的开发成本虽然低，但内存消耗大，切换次数过多，无法实现高并发。</p><p>异步编程方式通过非阻塞系统调用和多路复用，把原本属于内核的请求切换能力，放在用户态的代码中执行。这样，不仅减少了每个请求的内存消耗，也降低了切换请求的成本，最终实现了高并发。然而，异步编程违反了代码的内聚性，还需要业务代码关注并发细节，开发成本很高。</p><p>协程参考内核通过CPU寄存器切换线程的方法，在用户态代码中实现了协程的切换，既降低了切换请求的成本，也使得协程中的业务代码不用关注自己何时被挂起，何时被执行。相比异步编程中要维护一堆数据结构表示中间状态，协程直接用代码表示状态，大大提升了开发效率。</p><p>在协程中调用的所有API，都需要做非阻塞的协程化改造。优秀的协程生态下，常用服务都有对应的协程SDK，方便业务代码使用。开发高并发服务时，与IO多路复用结合的协程框架可以与这些SDK配合，自动挂起、切换协程，进一步提升开发效率。</p><p>协程并不是完全与线程无关，首先线程可以帮助协程充分使用多核CPU的计算力，其次，遇到无法协程化、会导致内核切换的阻塞函数，或者计算太密集从而长时间占用CPU的任务，还是要放在独立的线程中执行，以防止它影响所有协程的执行。</p><h2>思考题</h2><p>最后，留给你一个思考题，你用过协程吗？觉得它还有什么优点？如果没有在生产环境中使用协程，原因是什么？欢迎你在留言区与我一起探讨。</p><p>感谢阅读，如果你觉得这节课有所收获，也欢迎把它分享给你的朋友。</p>","neighbors":{"left":{"article_title":"04 | 零拷贝：如何高效地传输文件？","id":232676},"right":{"article_title":"06 | 锁：如何根据业务场景选择合适的锁？","id":234548}},"comments":[{"had_liked":false,"id":215110,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1588906644,"is_pvip":false,"replies":[{"id":"90984","content":"是的，协程还需要生态上各类SDK的完善","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1599817758,"ip_address":"","comment_id":215110,"utype":1}],"discussion_count":5,"race_medal":0,"score":"87488252564","product_id":100051201,"comment_content":"优点：<br>1、首先协程是比线程更轻量级的对象，在Linux内核来说，线程和进程最终对应的都是task结构。<br>2、从操作系统的角度来看，线程是在内核态中调度的，而协程是在用户态调度的，所以相对于线程来说，协程切换的成本更低。<br>3、协程可以认为是一种并发编程技术，性能比较高，可用性也比较高。Java中的Loom 项目的目标就是支持协程，像go语言更是天然支持协程。<br>在我们项目中没有用到协程，主要还是使用的还是异步回调方式。<br>主要原因是：大家不知道协程（接收度比较低，觉得没用过可能会遇到很多坑，万一影响产品稳定性怎么办），而且产品里面已经充斥着大量的回调，没法大规模切换了。","like_count":21,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494319,"discussion_content":"是的，协程还需要生态上各类SDK的完善","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599817758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1033578,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c5/6a/7f858f1f.jpg","nickname":"白不吃","note":"","ucode":"F019914D8819C2","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288388,"discussion_content":"很及时的评论，不知道作者是怎么想的，讲协程也不介绍协程，默认大家都是积累深厚的人？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1593740459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1147453,"avatar":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","nickname":"忆水寒","note":"","ucode":"E3F86BD8AA8903","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1033578,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c5/6a/7f858f1f.jpg","nickname":"白不吃","note":"","ucode":"F019914D8819C2","race_medal":1,"user_type":1,"is_pvip":true},"discussion":{"id":377905,"discussion_content":"极客时间 把大家都当作专家了，就知道涨价！涨价！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622958152,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":288388,"ip_address":""},"score":377905,"extra":""}]},{"author":{"id":1325931,"avatar":"","nickname":"嘻嘻","note":"","ucode":"E1EB75DD1C05E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377708,"discussion_content":"协程为什么跟各类sdk有关？我理解可以是在底层运作的哇","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622783725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1147453,"avatar":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","nickname":"忆水寒","note":"","ucode":"E3F86BD8AA8903","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1325931,"avatar":"","nickname":"嘻嘻","note":"","ucode":"E1EB75DD1C05E0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377906,"discussion_content":"底层的不直接支持的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622958171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":377708,"ip_address":""},"score":377906,"extra":""}]}]},{"had_liked":false,"id":215421,"user_name":"Bitstream","can_delete":false,"product_type":"c1","uid":1434089,"ip_address":"","ucode":"51FB631A70B52C","user_header":"https://static001.geekbang.org/account/avatar/00/15/e1/e9/29b62c57.jpg","comment_is_top":false,"comment_ctime":1588988815,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"66013498255","product_id":100051201,"comment_content":"说实话，这篇看下来，感觉挺抽象的，要是有例子就好了，但是想想，简单的例子可能还真没法体现线程和协程的差别，暂且当做作业自己下去实现个例子吧。另外，这里把协程和用户态线程（基于栈的协程）等价起来了，协程也有无栈的实现方式，我觉得应该提一下。","like_count":16,"discussions":[{"author":{"id":1033578,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c5/6a/7f858f1f.jpg","nickname":"白不吃","note":"","ucode":"F019914D8819C2","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288390,"discussion_content":"是的，从开始看到这里，特别是前几篇，感觉在强行优化。到后面开始贴合了实际点，但是也是纸上谈兵，整个看完依然很迷","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1593740673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215305,"user_name":"郭郭","can_delete":false,"product_type":"c1","uid":1517814,"ip_address":"","ucode":"E358C980AB9555","user_header":"https://static001.geekbang.org/account/avatar/00/17/28/f6/7fa61d68.jpg","comment_is_top":false,"comment_ctime":1588950734,"is_pvip":false,"replies":[{"id":"79709","content":"阿里开源的libeasy你可以考虑下哈，非常高效，在阿里的合伙人多隆写的协程库，代码质量很高","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588986351,"ip_address":"","comment_id":215305,"utype":1}],"discussion_count":5,"race_medal":0,"score":"66013460174","product_id":100051201,"comment_content":"老师，有没有比较好的C++协程库推荐一下？","like_count":16,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494385,"discussion_content":"阿里开源的libeasy你可以考虑下哈，非常高效，在阿里的合伙人多隆写的协程库，代码质量很高","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1588986351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1023750,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9f/06/287d77dd.jpg","nickname":"承香墨影","note":"","ucode":"4D6A4D6E1ED29F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334039,"discussion_content":"也可以看看腾讯开源的 libco，是微信后台使用的 C/C++ 协程库。\nURL：https://github.com/Tencent/libco","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1607699562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1043771,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ed/3b/daa0ff2d.jpg","nickname":"千岁寒","note":"","ucode":"58D4F1347F6058","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286451,"discussion_content":"学到了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593179046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1744284,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/9d/9c/2d5eac97.jpg","nickname":"destiny","note":"","ucode":"8D38BF89E76450","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":264394,"discussion_content":"老师，libeasy不是一个网络库吗？您说的能否贴个url,谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589301786,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1517814,"avatar":"https://static001.geekbang.org/account/avatar/00/17/28/f6/7fa61d68.jpg","nickname":"郭郭","note":"","ucode":"E358C980AB9555","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261861,"discussion_content":"好的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589016352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215571,"user_name":"Geek_89bbab","can_delete":false,"product_type":"c1","uid":1156607,"ip_address":"","ucode":"B3110D5B3C9500","user_header":"https://static001.geekbang.org/account/avatar/00/11/a5/ff/6201122c.jpg","comment_is_top":false,"comment_ctime":1589019833,"is_pvip":false,"replies":[{"id":"90977","content":"谢谢Geek_89bbab的分享！！","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1599817248,"ip_address":"","comment_id":215571,"utype":1}],"discussion_count":4,"race_medal":0,"score":"48833660089","product_id":100051201,"comment_content":"再补充一些，<br>1. 一些协程库会使用共享栈，如腾讯的libco。<br>2. 协程调度和内核调度相比另一个高效的原因，内核是抢占式的调度，协程是非抢占式的、按需调度，所以协程的调度次数远远小于内核的调度次数。<br>","like_count":11,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494481,"discussion_content":"谢谢Geek_89bbab的分享！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599817248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1048718,"avatar":"https://static001.geekbang.org/account/avatar/00/10/00/8e/ebe3c8ea.jpg","nickname":"董泽润","note":"","ucode":"0859A6ECCB5473","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":270193,"discussion_content":"最新版 go 己经支持抢占了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1589985320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1356589,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLh73kPzAKhz7YxUribqF6QKFiahhVAbwpgVLSRicA68c6ZFA7vUBJY1ves3LVvibrypROyI7awv47eSA/132","nickname":"ZYecho","note":"","ucode":"9D156DD30C581E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263048,"discussion_content":"golang的协程不支持抢占么？ 我理解支持抢占的目的是为了防止独占资源 基于公平性。 再就是真正切换的时候 其实要做的改动很少吧 不会带来特别多的开销","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589166982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1156607,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a5/ff/6201122c.jpg","nickname":"Geek_89bbab","note":"","ucode":"B3110D5B3C9500","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1356589,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLh73kPzAKhz7YxUribqF6QKFiahhVAbwpgVLSRicA68c6ZFA7vUBJY1ves3LVvibrypROyI7awv47eSA/132","nickname":"ZYecho","note":"","ucode":"9D156DD30C581E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265628,"discussion_content":"所以golang性能还是有损失的，在公平性和性能上做折中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589422129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":263048,"ip_address":""},"score":265628,"extra":""}]}]},{"had_liked":false,"id":217209,"user_name":"苦行僧","can_delete":false,"product_type":"c1","uid":1055334,"ip_address":"","ucode":"726024A9A9CF44","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/66/2d9db9ed.jpg","comment_is_top":false,"comment_ctime":1589440625,"is_pvip":false,"replies":[{"id":"80419","content":"是的","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1589498833,"ip_address":"","comment_id":217209,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35949178993","product_id":100051201,"comment_content":"就记住一句话 协程就是用户态的线程","like_count":8,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495078,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589498833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215034,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1588894348,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"23063730828","product_id":100051201,"comment_content":"今日得到<br>协程:如何快速地实现高并发服务？<br>要想实现高并发，一个简单的做法就是多线程，为每个请求分配一个线程来执行。但多线程的方式也是有弊端的，如下:<br>1.单个线程消耗内存过多，没有足够的内存去创建几万线程实现并发<br>2.切换请求是内核通过切换线程来实现的，线程的切换就会带来上下文的切换，也是会耗费 CPU 资源的<br><br>如何破？<br>把本来由内核实现的请求切换工作交给用户态的代码来完成，这样可以降低切换成本和内存占用<br><br>异步编程可以实现用户态的请求切换。异步化依赖 IO 多路复用机制的同时，还需要把阻塞方法改为非阻塞方法<br><br>比如一个线程处理两个请求，请求 1 过来通过异步框架发起异步 IO 读，同时向异步框架注册回调函数。然后切换到请求 2，由异步框架发起异步 IO 读，同样也会注册回调函数。<br>最后由异步框架依赖 IO 多路复用机制来检查数据是否就绪，如果数据就绪就通过之前请求注册的回调函数去处理<br><br>异步代码不好写，容易出错，我们项目中用的 vertx 异步框架，我到现在也写不好异步代码。<br><br>协程可以弥补异步框架的不足，其实协程是建立在异步的基础上的，他俩都是使用非阻塞的系统调用与内核交互，把请求切换放到用户态。他俩不同的地方在于，协程把异步化中的两段函数封装成一个阻塞的协程函数。在该函数执行时，由协程框架完成协程之间的切换，协程是无感知的。<br><br>协程是如何完成切换的？<br>在用户态完成协程的切换和在内核态完成线程的切换原理类似。<br>每个协程有独立的栈，一般占用空间选小于线程的栈，(协程一般是几十 KB，线程是 8MB<br>)所以相同的内存空间可以创建更多的协程来处理请求。栈中保存了函数的调用关系、参数和返回值。CPU 中的栈寄存器 SP 指向当前协程的栈，指令寄存器 IP 保存下一条执行的指令的地址。<br><br>在协程 1 切换到协程 2 时要把协程 1 的 SP 和 IP 寄存器的值保存下来，再从内存中找到协程 2 上一次切换前保存的寄存器值，写入到 CPU  的寄存器，这样就完成了协程的切换<br><br>协程是用户态的线程，一个线程可以包含多个协程，要保证协程的切换由用户态代码完成，如果协程触发了线程的切换就会导致该线程上的所有协程都阻塞，因为线程的切换是由内核态完成的<br><br>所以要想使用协程，需要协程的生态是完整的，go 好像是天然支持协程，Java 的协程生态现在应该还不成熟，用的比较少","like_count":5,"discussions":[{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391717,"discussion_content":"是的 loom项目刚刚发布了早期版本 而且只能运行在JDK18 而JDK18也还未进入RC","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630591001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1382765,"avatar":"https://static001.geekbang.org/account/avatar/00/15/19/6d/0f0ee388.jpg","nickname":"程序员汪师傅","note":"","ucode":"A67C400EAA2CB6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334534,"discussion_content":"老哥你好，异步框架是如何实现请求切换的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607872799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238245,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/e5/82132920.jpg","nickname":"亦知码蚁","note":"","ucode":"400344A6E1207F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260792,"discussion_content":"老哥 C10K 用epoll模型实现的 不就是非阻塞线程+多路复用嘛 为啥说不能支持几万的并发 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588902124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1147453,"avatar":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","nickname":"忆水寒","note":"","ucode":"E3F86BD8AA8903","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1238245,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/e5/82132920.jpg","nickname":"亦知码蚁","note":"","ucode":"400344A6E1207F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261080,"discussion_content":"epoll能支持几万的并发的，到了C1000K，也就是百万连接的时候要优化线程模型和硬件，甚至协议栈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588937809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":260792,"ip_address":""},"score":261080,"extra":""}]}]},{"had_liked":false,"id":230269,"user_name":"杉松壁","can_delete":false,"product_type":"c1","uid":1080578,"ip_address":"","ucode":"ED904CE27CD3C4","user_header":"https://static001.geekbang.org/account/avatar/00/10/7d/02/4862f849.jpg","comment_is_top":false,"comment_ctime":1593331610,"is_pvip":false,"replies":[{"id":"90481","content":"通过汇编语言直接修改寄存器的值就可以做到，具体你可以看下汇编指令","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1599211392,"ip_address":"","comment_id":230269,"utype":1}],"discussion_count":4,"race_medal":0,"score":"18773200794","product_id":100051201,"comment_content":"协程既然在用户态，是怎么有权限切换CPU寄存器的？<br>","like_count":4,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499821,"discussion_content":"通过汇编语言直接修改寄存器的值就可以做到，具体你可以看下汇编指令","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599211392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1023750,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9f/06/287d77dd.jpg","nickname":"承香墨影","note":"","ucode":"4D6A4D6E1ED29F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334040,"discussion_content":"我理解，只是说协程是在用户态实现的，例如 协程的结构，和协程的切换逻辑，这些都是在用户态实现的。但并不是说协程不包含内核态的系统调用(syscall)，协程切换要操作寄存器，必然是会涉及到内核态的调用（用户态 → 内核态 → 用户态），但是这个操作只是修改了寄存器，并不包含线程调度的行为。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1607700301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1068361,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","nickname":"明翼","note":"","ucode":"E77F86BEB3D5C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1023750,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9f/06/287d77dd.jpg","nickname":"承香墨影","note":"","ucode":"4D6A4D6E1ED29F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404538,"discussion_content":"啊优势不大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634342637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":334040,"ip_address":""},"score":404538,"extra":""}]},{"author":{"id":1897395,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f3/b3/0ba7a760.jpg","nickname":"一凡","note":"","ucode":"5E9BE33452AF3B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298083,"discussion_content":"我也有疑问？改变CPU上下文不需要内核态吗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597165395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215101,"user_name":"那时刻","can_delete":false,"product_type":"c1","uid":1150927,"ip_address":"","ucode":"B0D150856C3A4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","comment_is_top":false,"comment_ctime":1588905085,"is_pvip":false,"replies":[{"id":"90985","content":"^_^","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1599817767,"ip_address":"","comment_id":215101,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18768774269","product_id":100051201,"comment_content":"使用过go语言里的协程，通过GMP来完成goroutine的调度，简单来说，通过P来绑定内核线程M于协程G。通过老师的讲解，加深了理解。","like_count":5,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494316,"discussion_content":"^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599817767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1013003,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/75/0b/553d4ec4.jpg","nickname":"逍遥","note":"","ucode":"570969BCFC96EF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265135,"discussion_content":"印象中，goroutine 并不是协程，只能说是类似","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589376283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1250775,"avatar":"https://static001.geekbang.org/account/avatar/00/13/15/d7/96e77edd.jpg","nickname":"问心","note":"","ucode":"6808568D61CE36","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1013003,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/75/0b/553d4ec4.jpg","nickname":"逍遥","note":"","ucode":"570969BCFC96EF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265205,"discussion_content":"跟其他语言的协程实现是差不多的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589379734,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":265135,"ip_address":""},"score":265205,"extra":""}]}]},{"had_liked":false,"id":228275,"user_name":"Kvicii.Y","can_delete":false,"product_type":"c1","uid":1442588,"ip_address":"","ucode":"446BFA633569EA","user_header":"https://static001.geekbang.org/account/avatar/00/16/03/1c/c9fe6738.jpg","comment_is_top":false,"comment_ctime":1592630720,"is_pvip":false,"replies":[{"id":"90787","content":"线程是由内核实现的，其切换是在内核态进行，因此有内核态与用户态的切换成本，而且内核很难高度定制化，因此它通常考虑的是通用场景，不会为了高并发服务器做过多优化；<br>协程是由应用代码实现，且主要是用于高并发服务器，耗费内存很小，多个请求间的切换成本也很低。","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1599642026,"ip_address":"","comment_id":228275,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10182565312","product_id":100051201,"comment_content":"陶老师，协程和线程的区别点在于：线程是CPU通过寄存器进行切换，协程是在用户态中进行切换，除此之外二者还有什么更细微的差别吗？","like_count":2,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498979,"discussion_content":"线程是由内核实现的，其切换是在内核态进行，因此有内核态与用户态的切换成本，而且内核很难高度定制化，因此它通常考虑的是通用场景，不会为了高并发服务器做过多优化；\n协程是由应用代码实现，且主要是用于高并发服务器，耗费内存很小，多个请求间的切换成本也很低。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599642026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218438,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1589802103,"is_pvip":false,"replies":[{"id":"80914","content":"可以参考阿里开源的libeasy，是一个很高效的C&#47;C++协程库","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1589935602,"ip_address":"","comment_id":218438,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10179736695","product_id":100051201,"comment_content":"没有用过协程。cpp没有协程标准库。另外协程本身也依赖于线程吧。只不过是一个线程可以对应多个些协程。","like_count":2,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495457,"discussion_content":"可以参考阿里开源的libeasy，是一个很高效的C/C++协程库","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589935602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300391,"user_name":"托尼斯威特","can_delete":false,"product_type":"c1","uid":1729060,"ip_address":"","ucode":"98A1035527292E","user_header":"https://static001.geekbang.org/account/avatar/00/1a/62/24/07e2507c.jpg","comment_is_top":false,"comment_ctime":1625137505,"is_pvip":false,"replies":[{"id":"109035","content":"对，CPU、网卡通常是瓶颈，这时应该看看CPU究竟消耗在哪个函数上了，火焰图是个很好的工具。对于IO型应用，内存一般不是瓶颈。","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1625477852,"ip_address":"","comment_id":300391,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5920104801","product_id":100051201,"comment_content":"老师您好，跟您确认几个问题，不知道我理解的对不对。<br><br>大家谈高并发，有的时候谈的是高并发连接，有的时候谈的是高并发请求，高并发连接用epoll eventloop就可以了吧？<br><br>这篇文章主要是讲高并发请求。本来业务逻辑里需要阻塞线程，而用协程池取代线程池处理请求，可以节约大量的线程。<br><br>我疑惑的是，实际应用服务器一般要么是Cpu瓶颈，要么是内存瓶颈，我们的tomcat服务跑30个线程可以处理200QPS，CPU或者内存就接近100%了。这种情况我怎么觉得异步优化和协程优化都没什么用？<br><br>","like_count":1,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522723,"discussion_content":"对，CPU、网卡通常是瓶颈，这时应该看看CPU究竟消耗在哪个函数上了，火焰图是个很好的工具。对于IO型应用，内存一般不是瓶颈。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625477852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":286018,"user_name":"北极的大企鹅","can_delete":false,"product_type":"c1","uid":1045577,"ip_address":"","ucode":"8935346D08E109","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f4/49/2add4f6b.jpg","comment_is_top":false,"comment_ctime":1617108056,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5912075352","product_id":100051201,"comment_content":"之前浅浅了解过Kotlin中的协程","like_count":1},{"had_liked":false,"id":217962,"user_name":"Robust","can_delete":false,"product_type":"c1","uid":1113088,"ip_address":"","ucode":"79EA73E325945E","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/00/50b5cb51.jpg","comment_is_top":false,"comment_ctime":1589682983,"is_pvip":false,"replies":[{"id":"80631","content":"指无法恢复的错误，不仅是内存申请错误，比如访问已经释放的资源，且没有捕获异常或者无法捕获异常，进而操作系统只能杀死线程时，进程里的其他线程也会被杀死。","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1589699268,"ip_address":"","comment_id":217962,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5884650279","product_id":100051201,"comment_content":"“然而，共享地址空间虽然可以方便地共享对象，但这也导致一个问题，那就是任何一个线程出错时，进程中的所有线程会跟着一起崩溃。”<br><br>这里的出错应该表示一些特殊的错误吧，或者是说和共享内存有关的错误，比如申请不到内存等。老师，我理解的没错吧？","like_count":1,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495308,"discussion_content":"指无法恢复的错误，不仅是内存申请错误，比如访问已经释放的资源，且没有捕获异常或者无法捕获异常，进而操作系统只能杀死线程时，进程里的其他线程也会被杀死。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589699268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215849,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1589118610,"is_pvip":true,"replies":[{"id":"90975","content":"谢谢一步的分享！","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1599816595,"ip_address":"","comment_id":215849,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5884085906","product_id":100051201,"comment_content":"nodejs 中的 generator ， await , async 就是使用协程进行实现的","like_count":1,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494581,"discussion_content":"谢谢一步的分享！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599816595,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":353302,"user_name":"时熵","can_delete":false,"product_type":"c1","uid":1095280,"ip_address":"北京","ucode":"3CDAE8628117D5","user_header":"https://static001.geekbang.org/account/avatar/00/10/b6/70/33e87a4f.jpg","comment_is_top":false,"comment_ctime":1659341173,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659341173","product_id":100051201,"comment_content":"一直很好奇协程 看完这篇文章后 终于有了一个较为清楚的理解 期待java引进协程的那天早日到来","like_count":0},{"had_liked":false,"id":344003,"user_name":"折腾青春","can_delete":false,"product_type":"c1","uid":2187228,"ip_address":"","ucode":"969A612EE3B938","user_header":"https://static001.geekbang.org/account/avatar/00/21/5f/dc/a3a0c113.jpg","comment_is_top":false,"comment_ctime":1651165709,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651165709","product_id":100051201,"comment_content":"老师，有个疑问，即使是异步io，但是在调用异步io api时，进程应该还是会陷入内核态中？这个时候操作权还是回到了内核手里，怎么能保证用户态去切换协程呢。","like_count":0},{"had_liked":false,"id":300602,"user_name":"Movan","can_delete":false,"product_type":"c1","uid":1514292,"ip_address":"","ucode":"D5A2E9E2E7A439","user_header":"https://static001.geekbang.org/account/avatar/00/17/1b/34/4d8c5694.jpg","comment_is_top":false,"comment_ctime":1625237666,"is_pvip":false,"replies":[{"id":"109033","content":"^_^","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1625477716,"ip_address":"","comment_id":300602,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1625237666","product_id":100051201,"comment_content":"写得真好，之前看协程都是云里雾里的","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522775,"discussion_content":"^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625477716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":267686,"user_name":"程序员汪师傅","can_delete":false,"product_type":"c1","uid":1382765,"ip_address":"","ucode":"A67C400EAA2CB6","user_header":"https://static001.geekbang.org/account/avatar/00/15/19/6d/0f0ee388.jpg","comment_is_top":false,"comment_ctime":1607872725,"is_pvip":false,"replies":[{"id":"97603","content":"你可以参考io_getevents这个系统调用：https:&#47;&#47;man7.org&#47;linux&#47;man-pages&#47;man2&#47;io_getevents.2.html。其实类似于网络事件的epoll_wait，异步框架可以设定每批最多处理N个事件，于是，每处理完一批都检测下，是否有已经完成非阻塞读的IO请求，有的话就处理，这就完成了请求切换。","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1608518682,"ip_address":"","comment_id":267686,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1607872725","product_id":100051201,"comment_content":"老师您好，异步 IO 的非阻塞读和异步框架结合的那个部分我没懂，异步框架请求切换工作主要是指什么呢？是做了哪些工作呢？谢谢老师","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511713,"discussion_content":"你可以参考io_getevents这个系统调用：https://man7.org/linux/man-pages/man2/io_getevents.2.html。其实类似于网络事件的epoll_wait，异步框架可以设定每批最多处理N个事件，于是，每处理完一批都检测下，是否有已经完成非阻塞读的IO请求，有的话就处理，这就完成了请求切换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608518682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241840,"user_name":"木头发芽","can_delete":false,"product_type":"c1","uid":1419723,"ip_address":"","ucode":"657B381C5DA963","user_header":"https://static001.geekbang.org/account/avatar/00/15/a9/cb/a431bde5.jpg","comment_is_top":false,"comment_ctime":1597463269,"is_pvip":false,"replies":[{"id":"89646","content":"后面我会再写一篇与GO协程相关的加餐","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1597991039,"ip_address":"","comment_id":241840,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1597463269","product_id":100051201,"comment_content":"公司所有的微服务都用go写,所以协程一直都在用,通过这节更深入的理解了协程的出现解决的问题及其原理.对GMP模型的理解有了更底层的知识支撑.","like_count":1,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503855,"discussion_content":"后面我会再写一篇与GO协程相关的加餐","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597991039,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235965,"user_name":"一凡","can_delete":false,"product_type":"c1","uid":1897395,"ip_address":"","ucode":"5E9BE33452AF3B","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f3/b3/0ba7a760.jpg","comment_is_top":false,"comment_ctime":1595257437,"is_pvip":false,"replies":[{"id":"88397","content":"python语言不太适合处理高并发，真遇到高并发场景，可能换种语言的实现成本要低很多，比如GoLang","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1596503120,"ip_address":"","comment_id":235965,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1595257437","product_id":100051201,"comment_content":"1、处于用户态，开销低<br>2、由框架来协调、同步各协程的执行，使用方便<br><br>工作中没用遇到，python2的协程还是没那么方便，项目涉及到的密集IO的不多。","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501901,"discussion_content":"python语言不太适合处理高并发，真遇到高并发场景，可能换种语言的实现成本要低很多，比如GoLang","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596503120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":228986,"user_name":"冬风向左吹","can_delete":false,"product_type":"c1","uid":1066928,"ip_address":"","ucode":"376C45C5134F93","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/b0/a9b77a1e.jpg","comment_is_top":false,"comment_ctime":1592875646,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592875646","product_id":100051201,"comment_content":"python中的tornado应该异步非阻塞框架，gevent是协程框架。","like_count":0},{"had_liked":false,"id":217926,"user_name":"Winkle","can_delete":false,"product_type":"c1","uid":2001105,"ip_address":"","ucode":"64B90109BFB9E0","user_header":"https://static001.geekbang.org/account/avatar/00/1e/88/d1/e2568de6.jpg","comment_is_top":false,"comment_ctime":1589657724,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589657724","product_id":100051201,"comment_content":"文中的异步io读有些疑惑，此处的异步io跟APUE里所讲的五种io模型中异步io有什么区别🤔，epoll是一种io复用技术，与之常用搭配使用的应该是同步非阻塞io吧","like_count":0},{"had_liked":false,"id":216778,"user_name":"RISE","can_delete":false,"product_type":"c1","uid":1201956,"ip_address":"","ucode":"00E99CCA142E83","user_header":"https://static001.geekbang.org/account/avatar/00/12/57/24/909bb6ef.jpg","comment_is_top":false,"comment_ctime":1589340767,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589340767","product_id":100051201,"comment_content":"重度使用Golang中的协程，独有的GPM模型，在协程G和系统线程M之间加入P队列，使得空闲的线程能够从其他P中偷取G来运行，提高了线程的利用率，同时P能够天然地降低锁在高并发下的争抢粒度。","like_count":0},{"had_liked":false,"id":216684,"user_name":"刘耳总","can_delete":false,"product_type":"c1","uid":1271724,"ip_address":"","ucode":"6D157E6E960075","user_header":"https://static001.geekbang.org/account/avatar/00/13/67/ac/af895343.jpg","comment_is_top":false,"comment_ctime":1589328766,"is_pvip":false,"replies":[{"id":"80183","content":"你好刘耳总，我不清楚你说的具体是哪个库里的哪个方法，没办法给你精确的回答。<br>一般来说，这种方法底层都是使用了非阻塞socket，即设置了nonblock属性，再用事件驱动框架和异步函数完成。如果上面包装了协程，那么协程会以同步编程的方式向应用层提供API","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1589334299,"ip_address":"","comment_id":216684,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589328766","product_id":100051201,"comment_content":"在Python里的协程await db call 这种应该算是异步阻塞吧？求老师回复","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494911,"discussion_content":"你好刘耳总，我不清楚你说的具体是哪个库里的哪个方法，没办法给你精确的回答。\n一般来说，这种方法底层都是使用了非阻塞socket，即设置了nonblock属性，再用事件驱动框架和异步函数完成。如果上面包装了协程，那么协程会以同步编程的方式向应用层提供API","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589334299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216654,"user_name":"阿鼎","can_delete":false,"product_type":"c1","uid":1042634,"ip_address":"","ucode":"EE763513563F50","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e8/ca/2a7cc193.jpg","comment_is_top":false,"comment_ctime":1589301750,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589301750","product_id":100051201,"comment_content":"请问老师，协程只能用在io线程，当io耗时时，靠多路复用实现调度吗！非io线程，应用代码如何进行调度协程切换，难道像模仿操作系统切换时间片？","like_count":0},{"had_liked":false,"id":215769,"user_name":"我来也","can_delete":false,"product_type":"c1","uid":1205253,"ip_address":"","ucode":"773D6104F56767","user_header":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","comment_is_top":false,"comment_ctime":1589100003,"is_pvip":false,"replies":[{"id":"90978","content":"是啊^_^","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1599817271,"ip_address":"","comment_id":215769,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589100003","product_id":100051201,"comment_content":"想不到其他语言用协程还要找相应的库。😂<br>在这种场景下，还是golang方便，原生就支持协程。😄","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494550,"discussion_content":"是啊^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599817271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215265,"user_name":"borefo","can_delete":false,"product_type":"c1","uid":1111352,"ip_address":"","ucode":"67A3F20D1AAAFE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqUFIOBnowQQbDZSr7ZcPrbnN6vmD3T0UZ4YrYmgljwlx5OTfqh9BibEqSvba0cuMzicjkkaHadeysQ/132","comment_is_top":false,"comment_ctime":1588944185,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588944185","product_id":100051201,"comment_content":"我们的服务都是协程框架，异步拉取外部多个接口数据，然后本地做运算，最后返回。但是发现，同样协程框架的不同服务性能相差很大，这个影响性能的因素有哪些？如何评估一个程序的性能呢？比如，已知这个程序做了哪些操作，能不能大概知道服务的qps是多少呢？谢谢！","like_count":0},{"had_liked":false,"id":215158,"user_name":"亦知码蚁","can_delete":false,"product_type":"c1","uid":1238245,"ip_address":"","ucode":"400344A6E1207F","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/e5/82132920.jpg","comment_is_top":false,"comment_ctime":1588917398,"is_pvip":false,"replies":[{"id":"90981","content":"因为用户态可以按需分配内存，而内核切换请求时，是做不到这一点的。比如每个线程都要分配几MB的栈，还要预分配堆内存池。","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1599817648,"ip_address":"","comment_id":215158,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1588917398","product_id":100051201,"comment_content":"异步化编程通过应用层代码实现了请求切换，降低了切换成本和内存占用空间。<br>老师 为什么会降低内存占用空间","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494337,"discussion_content":"因为用户态可以按需分配内存，而内核切换请求时，是做不到这一点的。比如每个线程都要分配几MB的栈，还要预分配堆内存池。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599817648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1156607,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a5/ff/6201122c.jpg","nickname":"Geek_89bbab","note":"","ucode":"B3110D5B3C9500","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261895,"discussion_content":"它是相对于一个请求一个线程多线程方式来说的， 异步化通过epoll之类的多路复用机制来实现单个线程就可以同时处理多个请求， 如果100个请求，多线程方式需要100个线程，就需要100个线程栈，而epoll多路复用只需要一个线程，所以占用内存少，多线程处理每个请求，需要内核来回切换线程，而多路复用处理请求不需要通过内核上下文切换，通过event loop来连续处理不同请求，所以切换成本低。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1589021031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1238245,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/e5/82132920.jpg","nickname":"亦知码蚁","note":"","ucode":"400344A6E1207F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1156607,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a5/ff/6201122c.jpg","nickname":"Geek_89bbab","note":"","ucode":"B3110D5B3C9500","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263172,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589182950,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":261895,"ip_address":""},"score":263172,"extra":""}]}]},{"had_liked":false,"id":215088,"user_name":"亦知码蚁","can_delete":false,"product_type":"c1","uid":1238245,"ip_address":"","ucode":"400344A6E1207F","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/e5/82132920.jpg","comment_is_top":false,"comment_ctime":1588902190,"is_pvip":false,"replies":[{"id":"79707","content":"你好问题大师，我是指同步开发下，要支持几万并发，就得几万个线程或者协程。<br>你说的方式，应该是指异步非阻塞模式吧？这没有限制。如果同步方式下，几万个线程是无法实现的，因为每个线程占用的内存太大，是以MB计算的，而协程占用的内存是以KB计算的。","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588986295,"ip_address":"","comment_id":215088,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1588902190","product_id":100051201,"comment_content":"老师 C10K 用epoll模型实现的 不就是非阻塞线程+多路复用嘛 线程为啥说不能支持几万的并发 应该是可以的吧","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494311,"discussion_content":"你好问题大师，我是指同步开发下，要支持几万并发，就得几万个线程或者协程。\n你说的方式，应该是指异步非阻塞模式吧？这没有限制。如果同步方式下，几万个线程是无法实现的，因为每个线程占用的内存太大，是以MB计算的，而协程占用的内存是以KB计算的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588986295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1260026,"avatar":"https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg","nickname":"安排","note":"","ucode":"F78CFA9624CAEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260963,"discussion_content":"老师的意思说的是开启几万个线程来处理几万个连接，而不是多路复用这种IO模型处理几万个连接","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1588919521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1729060,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/62/24/07e2507c.jpg","nickname":"托尼斯威特","note":"","ucode":"98A1035527292E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381599,"discussion_content":"我觉得不是，epoll那里是处理高连接数，协程池是取代线程池，处理高请求数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625137774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215058,"user_name":"张华中-Blackc","can_delete":false,"product_type":"c1","uid":1392338,"ip_address":"","ucode":"CFDE6E945466A0","user_header":"https://static001.geekbang.org/account/avatar/00/15/3e/d2/624a3d59.jpg","comment_is_top":false,"comment_ctime":1588898642,"is_pvip":false,"replies":[{"id":"90986","content":"C++的goto？不了解，可以详细讲讲吗？","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1599817836,"ip_address":"","comment_id":215058,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1588898642","product_id":100051201,"comment_content":"协程最大的快感就是同步的写法实现异步回调逻辑，本来该内聚的业务不用分开写了。 c++的goto可以实现简单协程。但go语言的协程更像线程，感觉跟c++的不一样","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494297,"discussion_content":"C++的goto？不了解，可以详细讲讲吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599817836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}