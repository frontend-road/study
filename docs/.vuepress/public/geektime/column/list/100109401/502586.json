{"id":502586,"title":"15｜DI Container（3）：如何重构已有的代码？","content":"<p>你好，我是徐昊。今天我们继续使用TDD的方式来实现注入依赖容器。</p><h2>回顾代码与任务列表</h2><p>到目前为止，我们的代码是这样的：</p><pre><code>package geektime.tdd.di;\n\nimport jakarta.inject.Inject;\nimport jakarta.inject.Provider;\nimport java.lang.reflect.Constructor;\nimport java.util.HashMap;\nimport java.util.Map;\n \nimport static java.util.Arrays.stream;\npublic class Context {\n    private Map&lt;Class&lt;?&gt;, Provider&lt;?&gt;&gt; providers = new HashMap&lt;&gt;();\n    \n    public &lt;Type&gt; void bind(Class&lt;Type&gt; type, Type instance) {\n        providers.put(type, (Provider&lt;Type&gt;) () -&gt; instance);\n    }\n    \n    public &lt;Type, Implementation extends Type&gt;\n    void bind(Class&lt;Type&gt; type, Class&lt;Implementation&gt; implementation) {\n        Constructor&lt;?&gt;[] injectConstructors = stream(implementation.getConstructors()).filter(c -&gt; c.isAnnotationPresent(Inject.class))\n                .toArray(Constructor&lt;?&gt;[]::new);\n        if (injectConstructors.length &gt; 1) throw new IllegalComponentException();\n        if (injectConstructors.length == 0 &amp;&amp; stream(implementation.getConstructors())\n                .filter(c -&gt; c.getParameters().length == 0).findFirst().map(c -&gt; false).orElse(true))\n            throw new IllegalComponentException();\n        providers.put(type, (Provider&lt;Type&gt;) () -&gt; {\n            try {\n                Constructor&lt;Implementation&gt; injectConstructor = getInjectConstructor(implementation);\n                Object[] dependencies = stream(injectConstructor.getParameters())\n                        .map(p -&gt; get(p.getType()))\n                        .toArray(Object[]::new);\n                return injectConstructor.newInstance(dependencies);\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        });\n    }\n    \n    private &lt;Type&gt; Constructor&lt;Type&gt; getInjectConstructor(Class&lt;Type&gt; implementation) {\n        return (Constructor&lt;Type&gt;) stream(implementation.getConstructors())\n                .filter(c -&gt; c.isAnnotationPresent(Inject.class)).findFirst().orElseGet(() -&gt; {\n                    try {\n                        return implementation.getConstructor();\n                    } catch (NoSuchMethodException e) {\n                        throw new RuntimeException(e);\n                    }\n                });\n    }\n    \n    public &lt;Type&gt; Type get(Class&lt;Type&gt; type) {\n        return (Type) providers.get(type).get();\n    }\n}\n</code></pre><p>任务列表状态为：</p><p><img src=\"https://static001.geekbang.org/resource/image/5c/cd/5c5e1ac665e8e770c9a3597303eb62cd.jpg?wh=4771x8191\" alt=\"\"></p><h2>视频演示</h2><p>让我们进入今天的部分：</p><p><video poster=\"https://media001.geekbang.org/a10578303c9c407089a65d9dac2774bd/snapshots/dddba613ac254022880642204c2ce806-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/2d5c01f-1801774d135-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/aff9887d76224d15a577771ceb36415d/ca57439af4a44f7c9b3fe8970e88e1b3-e2d94f42f820fbec156b6434aa48cf07-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><p><video poster=\"https://media001.geekbang.org/acc1c91ea132441596a3381a4faf871e/snapshots/0fee02cd3d024dda8b65af9d8ad29564-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/31b7c07a-18017749d49-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/f8174a17263048958686eebc866e92b4/8650c818ae544a17af83d939b0c86162-bbe96b61fe114121aefc9c19387f8a1e-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><p><video poster=\"https://media001.geekbang.org/0079c1cd8a6e4081bac10112759c7bf9/snapshots/6ef3003295b04a5d9f9dc6a836266dc1-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/8c5abb0-18017749839-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/dbea76af85594e47af8f49d774ddf4c2/2761bb9bb4794413b95c20ba8c0d18fc-1f29eae105e954aecadec337218a4b0c-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><h2>思考题</h2><p>如何实现循环依赖的检测？</p><p>欢迎把你的思考和想法分享在留言区，也欢迎你扫描详情页的二维码加入读者交流群。我们下节课再见！</p><!-- [[[read_end]]] -->","neighbors":{"left":{"article_title":"14｜DI Container（2）：如何通过Sad Path为容器增加功能？","id":502584},"right":{"article_title":"16｜DI Container（4）：如何实现对循环依赖的处理？","id":508841}},"comments":[{"had_liked":false,"id":343866,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":true,"comment_ctime":1651105429,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"9.2233720470957998e+18","product_id":100109401,"comment_content":"进入到第二阶段的课程之后，给出的代码相对比较详细，虽然实现的功能比起前面要复杂一些，但是跟上节奏就不那么困难了。<br><br>这个专栏的门槛还是挺高的。<br><br>实现循环依赖检测，比较容易想到的就是在每个依赖添加一个标志位，但是这个似乎不那么容易实现；那么另一个方式，就是增加一个记录依赖的列表，每次都去判断是否存在循环依赖。<br><br>代码不太会写，只能先想一下。<br><br>本课的代码链接：https:&#47;&#47;github.com&#47;escray&#47;TDDCourse&#47;tree&#47;ch15","like_count":2},{"had_liked":false,"id":343468,"user_name":"汗香","can_delete":false,"product_type":"c1","uid":1807921,"ip_address":"","ucode":"8F2C8A595F888A","user_header":"https://static001.geekbang.org/account/avatar/00/1b/96/31/91cc9c3c.jpg","comment_is_top":false,"comment_ctime":1650864145,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10240798737","product_id":100109401,"comment_content":"获取一个依赖前，先从已有依赖获取，<br>    若获取结果不为空则获取成功，<br>    若获取结果为空，先将被获取依赖类型放入一个待创建集合中，并判断当前组件本身是否在集合中，若在，说明有循环依赖<br>","like_count":2},{"had_liked":false,"id":354427,"user_name":"蝴蝶","can_delete":false,"product_type":"c1","uid":1193167,"ip_address":"广东","ucode":"8019924D99182F","user_header":"https://static001.geekbang.org/account/avatar/00/12/34/cf/0a316b48.jpg","comment_is_top":false,"comment_ctime":1660380801,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1660380801","product_id":100109401,"comment_content":"@Inject注解的构造方法如果没有参数，那肯定是有问题的，这次看明白了。","like_count":0},{"had_liked":false,"id":346783,"user_name":"davix","can_delete":false,"product_type":"c1","uid":1074465,"ip_address":"","ucode":"CBFB39BAD7938B","user_header":"https://static001.geekbang.org/account/avatar/00/10/65/21/101a7075.jpg","comment_is_top":false,"comment_ctime":1653434621,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653434621","product_id":100109401,"comment_content":"get() 重構受啟發！雖然看過《重構》了解其中的方法，但平時如果get()設計變化我通常還是直接改。這回直觀感受引入get_()的好處。","like_count":0}]}