{"id":12134,"title":"06 | JVM是如何处理异常的？","content":"<p>你好，我是郑雨迪。今天我们来讲讲Java虚拟机的异常处理。</p><p>众所周知，异常处理的两大组成要素是抛出异常和捕获异常。这两大要素共同实现程序控制流的非正常转移。</p><p>抛出异常可分为显式和隐式两种。显式抛异常的主体是应用程序，它指的是在程序中使用“throw”关键字，手动将异常实例抛出。隐式抛异常的主体则是Java虚拟机，它指的是Java虚拟机在执行过程中，碰到无法继续执行的异常状态，自动抛出异常。举例来说，Java虚拟机在执行读取数组操作时，发现输入的索引值是负数，故而抛出数组索引越界异常（ArrayIndexOutOfBoundsException）。</p><p>捕获异常则涉及了如下三种代码块。</p><ol>\n<li>\n<p>try代码块：用来标记需要进行异常监控的代码。</p>\n</li>\n<li>\n<p>catch代码块：跟在try代码块之后，用来捕获在try代码块中触发的某种指定类型的异常。除了声明所捕获异常的类型之外，catch代码块还定义了针对该异常类型的异常处理器。在Java中，try代码块后面可以跟着多个catch代码块，来捕获不同类型的异常。Java虚拟机会从上至下匹配异常处理器。因此，前面的catch代码块所捕获的异常类型不能覆盖后边的，否则编译器会报错。</p>\n</li>\n<li>\n<p>finally代码块：跟在try代码块和catch代码块之后，用来声明一段必定运行的代码。它的设计初衷是为了避免跳过某些关键的清理代码，例如关闭已打开的系统资源。</p>\n</li>\n</ol><!-- [[[read_end]]] --><p>在程序正常执行的情况下，这段代码会在try代码块之后运行。否则，也就是try代码块触发异常的情况下，如果该异常没有被捕获，finally代码块会直接运行，并且在运行之后重新抛出该异常。如果该异常被catch代码块捕获，finally代码块则在catch代码块之后运行。在某些不幸的情况下，catch代码块也触发了异常，那么finally代码块同样会运行，并会抛出catch代码块触发的异常。在某些极端不幸的情况下，finally代码块也触发了异常，那么只好中断当前finally代码块的执行，并往外抛异常。</p><p>上面这段听起来有点绕，但是等我讲完Java虚拟机的异常处理机制之后，你便会明白这其中的道理。</p><h2>异常的基本概念</h2><p>在Java语言规范中，所有异常都是Throwable类或者其子类的实例。Throwable有两大直接子类。第一个是Error，涵盖程序不应捕获的异常。当程序触发Error时，它的执行状态已经无法恢复，需要中止线程甚至是中止虚拟机。第二子类则是Exception，涵盖程序可能需要捕获并且处理的异常。Exception有一个特殊的子类RuntimeException，用来表示“程序虽然无法继续执行，但是还能抢救一下”的情况。前边提到的数组索引越界便是其中的一种。</p><p><img src=\"https://static001.geekbang.org/resource/image/47/93/47c8429fc30aec201286b47f3c1a5993.png?wh=1414*1086\" alt=\"\"></p><p>RuntimeException和Error属于Java里的非检查异常（unchecked exception）。其他异常则属于检查异常（checked exception）。在Java语法中，所有的检查异常都需要程序显式地捕获，或者在方法声明中用throws关键字标注。通常情况下，程序中自定义的异常应为检查异常，以便最大化利用Java编译器的编译时检查。</p><p>异常实例的构造十分昂贵。这是由于在构造异常实例时，Java虚拟机便需要生成该异常的栈轨迹（stack trace）。该操作会逐一访问当前线程的Java栈帧，并且记录下各种调试信息，包括栈帧所指向方法的名字，方法所在的类名、文件名，以及在代码中的第几行触发该异常。</p><p>当然，在生成栈轨迹时，Java虚拟机会忽略掉异常构造器以及填充栈帧的Java方法（Throwable.fillInStackTrace），直接从新建异常位置开始算起。此外，Java虚拟机还会忽略标记为不可见的Java方法栈帧。我们在介绍Lambda的时候会看到具体的例子。</p><p>既然异常实例的构造十分昂贵，我们是否可以缓存异常实例，在需要用到的时候直接抛出呢？从语法角度上来看，这是允许的。然而，该异常对应的栈轨迹并非throw语句的位置，而是新建异常的位置。因此，这种做法可能会误导开发人员，使其定位到错误的位置。这也是为什么在实践中，我们往往选择抛出新建异常实例的原因。</p><h2>Java虚拟机是如何捕获异常的？</h2><p>在编译生成的字节码中，每个方法都附带一个异常表。异常表中的每一个条目代表一个异常处理器，并且由from指针、to指针、target指针以及所捕获的异常类型构成。这些指针的值是字节码索引（bytecode index，bci），用以定位字节码。</p><p>其中，from指针和to指针标示了该异常处理器所监控的范围，例如try代码块所覆盖的范围。target指针则指向异常处理器的起始位置，例如catch代码块的起始位置。</p><pre><code>public static void main(String[] args) {\n  try {\n    mayThrowException();\n  } catch (Exception e) {\n    e.printStackTrace();\n  }\n}\n// 对应的Java字节码\npublic static void main(java.lang.String[]);\n  Code:\n    0: invokestatic mayThrowException:()V\n    3: goto 11\n    6: astore_1\n    7: aload_1\n    8: invokevirtual java.lang.Exception.printStackTrace\n   11: return\n  Exception table:\n    from  to target type\n      0   3   6  Class java/lang/Exception  // 异常表条目\n\n</code></pre><p>举个例子，在上面这段代码的main方法中，我定义了一段try-catch代码。其中，catch代码块所捕获的异常类型为Exception。</p><p>编译过后，该方法的异常表拥有一个条目。其from指针和to指针分别为0和3，代表它的监控范围从索引为0的字节码开始，到索引为3的字节码结束（不包括3）。该条目的target指针是6，代表这个异常处理器从索引为6的字节码开始。条目的最后一列，代表该异常处理器所捕获的异常类型正是Exception。</p><p>当程序触发异常时，Java虚拟机会从上至下遍历异常表中的所有条目。当触发异常的字节码的索引值在某个异常表条目的监控范围内，Java虚拟机会判断所抛出的异常和该条目想要捕获的异常是否匹配。</p><p>如果匹配，Java虚拟机会将控制流转移至该条目target指针指向的字节码。如果遍历完所有异常表条目，Java虚拟机仍未匹配到异常处理器，那么它会弹出当前方法对应的Java栈帧，并且在调用者（caller）中重复上述操作。在最坏情况下，Java虚拟机需要遍历当前线程Java栈上所有方法的异常表。</p><p>finally代码块的编译比较复杂。当前版本Java编译器的做法，是复制finally代码块的内容，分别放在try-catch代码块所有正常执行路径以及异常执行路径的出口中。</p><p><img src=\"https://static001.geekbang.org/resource/image/17/06/17e2a3053b06b0a4383884f106e31c06.png?wh=1920*779\" alt=\"\"></p><p>针对异常执行路径，Java编译器会生成一个或多个异常表条目，监控整个try-catch代码块，并且捕获所有种类的异常（在javap中以any指代）。这些异常表条目的target指针将指向另一份复制的finally代码块。并且，在这个finally代码块的最后，Java编译器会重新抛出所捕获的异常。</p><p>如果你感兴趣的话，可以用javap工具来查看下面这段包含了try-catch-finally代码块的编译结果。为了更好地区分每个代码块，我定义了四个实例字段：tryBlock、catchBlock、finallyBlock、以及methodExit，并且仅在对应的代码块中访问这些字段。</p><pre><code>public class Foo {\n  private int tryBlock;\n  private int catchBlock;\n  private int finallyBlock;\n  private int methodExit;\n\n  public void test() {\n    try {\n      tryBlock = 0;\n    } catch (Exception e) {\n      catchBlock = 1;\n    } finally {\n      finallyBlock = 2;\n    }\n    methodExit = 3;\n  }\n}\n\n\n$ javap -c Foo\n...\n  public void test();\n    Code:\n       0: aload_0\n       1: iconst_0\n       2: putfield      #20                 // Field tryBlock:I\n       5: goto          30\n       8: astore_1\n       9: aload_0\n      10: iconst_1\n      11: putfield      #22                 // Field catchBlock:I\n      14: aload_0\n      15: iconst_2\n      16: putfield      #24                 // Field finallyBlock:I\n      19: goto          35\n      22: astore_2\n      23: aload_0\n      24: iconst_2\n      25: putfield      #24                 // Field finallyBlock:I\n      28: aload_2\n      29: athrow\n      30: aload_0\n      31: iconst_2\n      32: putfield      #24                 // Field finallyBlock:I\n      35: aload_0\n      36: iconst_3\n      37: putfield      #26                 // Field methodExit:I\n      40: return\n    Exception table:\n       from    to  target type\n           0     5     8   Class java/lang/Exception\n           0    14    22   any\n\n  ...\n\n</code></pre><p>可以看到，编译结果包含三份finally代码块。其中，前两份分别位于try代码块和catch代码块的正常执行路径出口。最后一份则作为异常处理器，监控try代码块以及catch代码块。它将捕获try代码块触发的、未被catch代码块捕获的异常，以及catch代码块触发的异常。</p><p>这里有一个小问题，如果catch代码块捕获了异常，并且触发了另一个异常，那么finally捕获并且重抛的异常是哪个呢？答案是后者。也就是说原本的异常便会被忽略掉，这对于代码调试来说十分不利。</p><h2>Java 7的Suppressed异常以及语法糖</h2><p>Java 7引入了Suppressed异常来解决这个问题。这个新特性允许开发人员将一个异常附于另一个异常之上。因此，抛出的异常可以附带多个异常的信息。然而，Java层面的finally代码块缺少指向所捕获异常的引用，所以这个新特性使用起来非常繁琐。</p><p>为此，Java 7专门构造了一个名为try-with-resources的语法糖，在字节码层面自动使用Suppressed异常。当然，该语法糖的主要目的并不是使用Suppressed异常，而是精简资源打开关闭的用法。</p><p>在Java 7之前，对于打开的资源，我们需要定义一个finally代码块，来确保该资源在正常或者异常执行状况下都能关闭。资源的关闭操作本身容易触发异常。因此，如果同时打开多个资源，那么每一个资源都要对应一个独立的try-finally代码块，以保证每个资源都能够关闭。这样一来，代码将会变得十分繁琐。</p><pre><code>  FileInputStream in0 = null;\n  FileInputStream in1 = null;\n  FileInputStream in2 = null;\n  ...\n  try {\n    in0 = new FileInputStream(new File(&quot;in0.txt&quot;));\n    ...\n    try {\n      in1 = new FileInputStream(new File(&quot;in1.txt&quot;));\n      ...\n      try {\n        in2 = new FileInputStream(new File(&quot;in2.txt&quot;));\n        ...\n      } finally {\n        if (in2 != null) in2.close();\n      }\n    } finally {\n      if (in1 != null) in1.close();\n    }\n  } finally {\n    if (in0 != null) in0.close();\n  }\n\n</code></pre><p>Java 7的try-with-resources语法糖，极大地简化了上述代码。程序可以在try关键字后声明并实例化实现了AutoCloseable接口的类，编译器将自动添加对应的close()操作。在声明多个AutoCloseable实例的情况下，编译生成的字节码类似于上面手工编写代码的编译结果。与手工代码相比，try-with-resources还会使用Suppressed异常的功能，来避免原异常“被消失”。</p><pre><code>public class Foo implements AutoCloseable {\n  private final String name;\n  public Foo(String name) { this.name = name; }\n\n  @Override\n  public void close() {\n    throw new RuntimeException(name);\n  }\n\n  public static void main(String[] args) {\n    try (Foo foo0 = new Foo(&quot;Foo0&quot;); // try-with-resources\n         Foo foo1 = new Foo(&quot;Foo1&quot;);\n         Foo foo2 = new Foo(&quot;Foo2&quot;)) {\n      throw new RuntimeException(&quot;Initial&quot;);\n    }\n  }\n}\n\n// 运行结果：\nException in thread &quot;main&quot; java.lang.RuntimeException: Initial\n        at Foo.main(Foo.java:18)\n        Suppressed: java.lang.RuntimeException: Foo2\n                at Foo.close(Foo.java:13)\n                at Foo.main(Foo.java:19)\n        Suppressed: java.lang.RuntimeException: Foo1\n                at Foo.close(Foo.java:13)\n                at Foo.main(Foo.java:19)\n        Suppressed: java.lang.RuntimeException: Foo0\n                at Foo.close(Foo.java:13)\n                at Foo.main(Foo.java:19)\n\n</code></pre><p>除了try-with-resources语法糖之外，Java 7还支持在同一catch代码块中捕获多种异常。实际实现非常简单，生成多个异常表条目即可。</p><pre><code>// 在同一catch代码块中捕获多种异常\ntry {\n  ...\n} catch (SomeException | OtherException e) {\n  ...\n}\n</code></pre><h2>总结与实践</h2><p>今天我介绍了Java虚拟机的异常处理机制。</p><p>Java的异常分为Exception和Error两种，而Exception又分为RuntimeException和其他类型。RuntimeException和Error属于非检查异常。其他的Exception皆属于检查异常，在触发时需要显式捕获，或者在方法头用throws关键字声明。</p><p>Java字节码中，每个方法对应一个异常表。当程序触发异常时，Java虚拟机将查找异常表，并依此决定需要将控制流转移至哪个异常处理器之中。Java代码中的catch代码块和finally代码块都会生成异常表条目。</p><p>Java 7引入了Suppressed异常、try-with-resources，以及多异常捕获。后两者属于语法糖，能够极大地精简我们的代码。</p><p>那么今天的实践环节，你可以看看其他控制流语句与finally代码块之间的协作。</p><pre><code>\n// 编译并用javap -c查看编译后的字节码\npublic class Foo {\n  private int tryBlock;\n  private int catchBlock;\n  private int finallyBlock;\n  private int methodExit;\n\n  public void test() {\n    for (int i = 0; i &lt; 100; i++) {\n      try {\n        tryBlock = 0;\n        if (i &lt; 50) {\n          continue;\n        } else if (i &lt; 80) {\n          break;\n        } else {\n          return;\n        }\n      } catch (Exception e) {\n        catchBlock = 1;\n      } finally {\n        finallyBlock = 2;\n      }\n    }\n    methodExit = 3;\n  }\n}\n</code></pre>","neighbors":{"left":{"article_title":"05 | JVM是如何执行方法调用的？（下）","id":12098},"right":{"article_title":"07 | JVM是如何实现反射的？","id":12192}},"comments":[{"had_liked":false,"id":18180,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1533176434,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"753152453234","product_id":100010301,"comment_content":"感谢雨迪！<br>这节让我终于搞清楚了两个疑惑！<br><br>1:使用异常捕获的代码为什么比较耗费性能？<br>因为构造异常的实例比较耗性能。这从代码层面很难理解，不过站在JVM的角度来看就简单了，因为JVM在构造异常实例时需要生成该异常的栈轨迹。这个操作会逐一访问当前线程的栈帧，并且记录下各种调试信息，包括栈帧所指向方法的名字，方法所在的类名、文件名，以及在代码中的第几行触发该异常等信息。<br>虽然具体不清楚JVM的实现细节，但是看描述这件事情也是比较费时费力的。<br><br>2:finally是怎么实现无论异常与否都能被执行的？<br>这个事情是由编译器来实现的，现在的做法是这样的，编译器在编译Java代码时，会复制finally代码块的内容，然后分别放在try-catch代码块所有的正常执行路径及异常执行路径的出口中。<br><br><br>","like_count":176,"discussions":[{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41800,"discussion_content":"你和 lyly 说的不是一个东西；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572507581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1115724,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLwSoTjHPX5tm4whBSfoZLX6toZxrZGUaLABQywKNf4MDc9toK3QSV7Z99ATcGicFCysoleQ5ISzmw/132","nickname":"乘风","note":"","ucode":"0420C5535DACB7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1726,"discussion_content":"finally不是一定执行的，由上面就可以看出finally监控的try异常处理器的范围，当不属于此范围时时不会触发finally执行的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562848332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1344289,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLEYbNElGIxY6Le1rfiakWJecz8JIOp06Y9JQFR2YBn3T3gx3icI5CKxZNgxgqiaKbfVOicXquO3QBw9w/132","nickname":"july","note":"","ucode":"E081987929063A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1115724,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLwSoTjHPX5tm4whBSfoZLX6toZxrZGUaLABQywKNf4MDc9toK3QSV7Z99ATcGicFCysoleQ5ISzmw/132","nickname":"乘风","note":"","ucode":"0420C5535DACB7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":13147,"discussion_content":"兄弟，finally不是一定执行这句话不假，但你后面的说明无法支撑你的观点，try代码段出不出现异常、catch代码段捕获不捕获异常以及catch代码段再出不出现异常，finally都会执行，除非某些exit()类似的特例；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568643217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":1726,"ip_address":""},"score":13147,"extra":""},{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1344289,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLEYbNElGIxY6Le1rfiakWJecz8JIOp06Y9JQFR2YBn3T3gx3icI5CKxZNgxgqiaKbfVOicXquO3QBw9w/132","nickname":"july","note":"","ucode":"E081987929063A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41799,"discussion_content":"风风子的意思是，如果在 try 之前返回，那就不执行，或者 try catch 被一个条件语句 if else 约束，那么可能就不执行了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572507556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":13147,"ip_address":""},"score":41799,"extra":""},{"author":{"id":1344289,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLEYbNElGIxY6Le1rfiakWJecz8JIOp06Y9JQFR2YBn3T3gx3icI5CKxZNgxgqiaKbfVOicXquO3QBw9w/132","nickname":"july","note":"","ucode":"E081987929063A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":110775,"discussion_content":"额，这么说的话就没有意义了，所有的语句都有不执行的可能，我觉得在进入了try代码块之后再去讨论finally是否一定执行才有意义。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1577756275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":41799,"ip_address":""},"score":110775,"extra":""}]}]},{"had_liked":false,"id":22638,"user_name":"阿坤","can_delete":false,"product_type":"c1","uid":1178014,"ip_address":"","ucode":"E68AEACDF1748F","user_header":"https://static001.geekbang.org/account/avatar/00/11/f9/9e/833b272e.jpg","comment_is_top":false,"comment_ctime":1535880281,"is_pvip":false,"replies":[{"id":"8217","content":"catch里抛的异常会被finally捕获了，再执行完finally代码后重新抛出该异常。由于finally代码块有个return语句，在重新抛出前就返回了。<br><br>你可以利用这篇文章的知识，就着javap的输出，分析一下具体的程序路径","user_name":"作者回复","comment_id":22638,"uid":"1176688","ip_address":"","utype":1,"ctime":1535969568,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"237759081561","product_id":100010301,"comment_content":"如果finally有return语句，catch内throw的异常会被忽略，这个从jvm层面怎么解释呢？","like_count":56,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423201,"discussion_content":"catch里抛的异常会被finally捕获了，再执行完finally代码后重新抛出该异常。由于finally代码块有个return语句，在重新抛出前就返回了。\n\n你可以利用这篇文章的知识，就着javap的输出，分析一下具体的程序路径","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535969568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":19725,"user_name":"曲东方","can_delete":false,"product_type":"c1","uid":1177819,"ip_address":"","ucode":"6C3EA2F47A0B98","user_header":"https://static001.geekbang.org/account/avatar/00/11/f8/db/c4edf697.jpg","comment_is_top":false,"comment_ctime":1533996969,"is_pvip":false,"replies":[{"id":"7068","content":"思考得很深，赞一个！<br><br>即时编译器生成的代码会保存原始的栈信息，以便去优化时能够复原。fillStackTrace也会读取这些信息的，所以不用先去优化再fill。<br><br>抛异常本身带来了额外的执行路径。通常如果能够将异常处理器也编译进去，那么不会有太大影响。","user_name":"作者回复","comment_id":19725,"uid":"1176688","ip_address":"","utype":1,"ctime":1534327446,"user_name_real":"郑雨迪"}],"discussion_count":2,"race_medal":0,"score":"169037721513","product_id":100010301,"comment_content":"throw exception性能差fillstacktrace除了遍历堆栈以外，如果有inline 代码消除等编译优化发生，是不是要先“去优化”完了再fill？要不然可能出现错误堆栈和代码对不上的情况<br><br>throw exception估计也会影响jit的优化，进而影响整体性能<br><br>","like_count":39,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421954,"discussion_content":"思考得很深，赞一个！\n\n即时编译器生成的代码会保存原始的栈信息，以便去优化时能够复原。fillStackTrace也会读取这些信息的，所以不用先去优化再fill。\n\n抛异常本身带来了额外的执行路径。通常如果能够将异常处理器也编译进去，那么不会有太大影响。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534327446,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41801,"discussion_content":"自古评论出人才～～～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572507644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18023,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1533091127,"is_pvip":true,"replies":[{"id":"6322","content":"1 检查异常这个概念只在源代码中出现。异常表不是声明这段代码所有有可能抛出的异常，而是声明会被捕获的异常。<br><br>2 会的<br><br>3 栈轨迹 跟 弹出方法栈帧 是两个概念。你可以直接新建一个异常，然后不抛出，直接打印调用栈。这个时候是不会弹出当前栈帧的。","user_name":"作者回复","comment_id":18023,"uid":"1176688","ip_address":"","utype":1,"ctime":1533158281,"user_name_real":"郑雨迪"}],"discussion_count":2,"race_medal":0,"score":"57367665975","product_id":100010301,"comment_content":" \t看完今天的文章有几个疑问<br><br>   1方法的异常表是包含RuntimeException这种非check类型的异常吧？如果是那么每个方法都有异常表，那么是不是每个异常表中都有像ArrayIndexOutOfBoundsException这类型异常了。这类公共异常是私有还是共享呢<br><br>   2像catch自定义异常，也会添加的当前方法的异常表里吗？<br><br>   3 我们常常看到的异常调用栈，这里方法调用信息其实就是弹出方法栈帧吗？","like_count":13,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421363,"discussion_content":"1 检查异常这个概念只在源代码中出现。异常表不是声明这段代码所有有可能抛出的异常，而是声明会被捕获的异常。\n\n2 会的\n\n3 栈轨迹 跟 弹出方法栈帧 是两个概念。你可以直接新建一个异常，然后不抛出，直接打印调用栈。这个时候是不会弹出当前栈帧的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533158281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41805,"discussion_content":"其实我觉得你仔细看文章的话，其实你的问题不难的，最后一个，作者也说了，是遍历线程的栈，就是看信息。之后在处理异常的时候，会发生弹出栈的操作，因为要找到一个能够 catch 该异常的方法；","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572509134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18008,"user_name":"吴伟","can_delete":false,"product_type":"c1","uid":1179225,"ip_address":"","ucode":"D576A5D3C1377A","user_header":"https://static001.geekbang.org/account/avatar/00/11/fe/59/29913e7b.jpg","comment_is_top":false,"comment_ctime":1533085266,"is_pvip":false,"replies":[{"id":"6323","content":"编译期异常和运行时异常这种划分有点奇怪。<br><br>检查异常也会在运行过程中抛出。但是它会要求编译器检查代码有没有显式地处理该异常。非检查异常包括Error和RuntimeException(会不会那本书直译为”运行时异常”？)，这两个则不要求编译器显式处理。","user_name":"作者回复","comment_id":18008,"uid":"1176688","ip_address":"","utype":1,"ctime":1533158739,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"40187790930","product_id":100010301,"comment_content":"检查异常和非检查异常也就是其他书籍中说的编译期异常和运行时异常？","like_count":9,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421357,"discussion_content":"编译期异常和运行时异常这种划分有点奇怪。\n\n检查异常也会在运行过程中抛出。但是它会要求编译器检查代码有没有显式地处理该异常。非检查异常包括Error和RuntimeException(会不会那本书直译为”运行时异常”？)，这两个则不要求编译器显式处理。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1533158739,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":23309,"user_name":"李双迎","can_delete":false,"product_type":"c1","uid":1206046,"ip_address":"","ucode":"9BA17745259B5E","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/1e/40890f8f.jpg","comment_is_top":false,"comment_ctime":1536282840,"is_pvip":false,"replies":[{"id":"8470","content":"理论上是可以的，一般不这么做，原因有两个，一是异常路径无需考虑性能，二是代码可读性。","user_name":"作者回复","comment_id":23309,"uid":"1176688","ip_address":"","utype":1,"ctime":1536331353,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"35896021208","product_id":100010301,"comment_content":"老师，如果异常构造比较耗时，那么能否通过缓存同一位置相同异常的实例，来解决呢？","like_count":8,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423506,"discussion_content":"理论上是可以的，一般不这么做，原因有两个，一是异常路径无需考虑性能，二是代码可读性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1536331353,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241254,"user_name":"wuyong","can_delete":false,"product_type":"c1","uid":1206039,"ip_address":"","ucode":"175947EEA1FEC2","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/17/942e5115.jpg","comment_is_top":false,"comment_ctime":1597225585,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31661996657","product_id":100010301,"comment_content":"```java<br>public class Foo {<br>    private int tryBlock;<br>    private int catchBlock;<br>    private int finallyBlock;<br>    private int methodExit;<br><br>    public void test() {<br>        try {<br>            tryBlock = 0;<br>        } catch (Exception e) {<br>            catchBlock = 1;<br>        } finally {<br>            finallyBlock = 2;<br>        }<br>        methodExit = 3;<br>    }<br>}<br>```<br><br>相当于如下的代码：<br><br>```java<br>public class Foo {<br>    private int tryBlock;<br>    private int catchBlock;<br>    private int finallyBlock;<br>    private int methodExit;<br><br>    public void test() {<br>        try {<br>            tryBlock = 0;<br>            finallyBlock = 2;<br>        } catch (Exception e) {<br>            catchBlock = 1;<br>            finallyBlock = 2;<br>        } catch (Throwable e) {<br>            finallyBlock = 2;<br>            throw e;<br>        }<br>        methodExit = 3;<br>    }<br>}<br>```","like_count":7},{"had_liked":false,"id":19205,"user_name":"Krloy","can_delete":false,"product_type":"c1","uid":1184205,"ip_address":"","ucode":"ABD6B379F1DEFA","user_header":"https://static001.geekbang.org/account/avatar/00/12/11/cd/0e06bd0f.jpg","comment_is_top":false,"comment_ctime":1533705693,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"23008542173","product_id":100010301,"comment_content":"关于try catch的疑问<br><br>如果for里面中写 try catch 一百条数据中有1条数据异常 程序正常执行 会返回99条数据<br>如果for里面不写 try catch写外面 程序正常执行 但是数据返回0 <br><br>try catch 异常实例构造非常昂贵，因为虚拟机会生成改异常的栈轨迹，改操作会逐一访问改线程栈帧，并记录下各种调试信息。<br><br>那么如果我在for中写try catch 的话 会不会每次循环都生成一个异常实例？<br>上面两种写try catch的方法 哪种要更好点","like_count":5,"discussions":[{"author":{"id":1339022,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","nickname":"拯救地球好累","note":"","ucode":"7643439601EF4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8415,"discussion_content":"按文章所说，只有在触发异常时，才会做检查异常表监控范围、生成异常实例等动作。\n因此如果catch后的动作是返回或抛出异常的动作，这两种方式在性能上不会有差别，只是在美观上推荐后者。见https://stackoverflow.com/questions/141560/should-try-catch-go-inside-or-outside-a-loop。\n而如果要在catch中做一些别的事情，比如记录每次循环中的情况，那么放在里面开销自然大，但这种场景也只会在有特定需求时才会设置。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568001193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1184205,"avatar":"https://static001.geekbang.org/account/avatar/00/12/11/cd/0e06bd0f.jpg","nickname":"Krloy","note":"","ucode":"ABD6B379F1DEFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1339022,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","nickname":"拯救地球好累","note":"","ucode":"7643439601EF4C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":173501,"discussion_content":"理解  谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581857052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":8415,"ip_address":""},"score":173501,"extra":""}]}]},{"had_liked":false,"id":17985,"user_name":"子清","can_delete":false,"product_type":"c1","uid":1106345,"ip_address":"","ucode":"2E2E82AD5B1680","user_header":"https://static001.geekbang.org/account/avatar/00/10/e1/a9/64a2fe3a.jpg","comment_is_top":false,"comment_ctime":1533082423,"is_pvip":false,"replies":[{"id":"6318","content":"首先走抛出异常捕获异常的异常执行路径的话，性能肯定是很慢的，因此最好在参数出现问题的概率很小的情况下使用这种方式。<br><br>另外，你说的Assert是某个库的工具类，还是assert语句？后者的话，一般只在开发环境中启用吧。","user_name":"作者回复","comment_id":17985,"uid":"1176688","ip_address":"","utype":1,"ctime":1533157414,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"18712951607","product_id":100010301,"comment_content":"如果在业务层的代码中使用Assert来判断参数是否有问题，然后在调用方捕捉异常，这样会不会耗性能","like_count":4,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421350,"discussion_content":"首先走抛出异常捕获异常的异常执行路径的话，性能肯定是很慢的，因此最好在参数出现问题的概率很小的情况下使用这种方式。\n\n另外，你说的Assert是某个库的工具类，还是assert语句？后者的话，一般只在开发环境中启用吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533157414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":19561,"user_name":"贾智文","can_delete":false,"product_type":"c1","uid":1100235,"ip_address":"","ucode":"600CF0AB215D1A","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/cb/7b6802cc.jpg","comment_is_top":false,"comment_ctime":1533878736,"is_pvip":false,"replies":[{"id":"6781","content":"会依照异常表中的前后(上下)顺序来查找，然后被第一个满足条件的异常处理器捕获","user_name":"作者回复","comment_id":19561,"uid":"1176688","ip_address":"","utype":1,"ctime":1533894842,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"14418780624","product_id":100010301,"comment_content":"当触发异常的字节码的索引值在某个异常表条目的监控范围内，Java 虚拟机会判断所抛出的异常和该条目想要捕获的异常是否匹配。                        <br>这里有点没懂，每层方法的监控范围有可能会重叠吧，只用索引判断不会出现多个情况都满足的情况吗？","like_count":3,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421893,"discussion_content":"会依照异常表中的前后(上下)顺序来查找，然后被第一个满足条件的异常处理器捕获","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533894842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18055,"user_name":"Ennis LM","can_delete":false,"product_type":"c1","uid":1188522,"ip_address":"","ucode":"8AA2004DB0DDE4","user_header":"https://static001.geekbang.org/account/avatar/00/12/22/aa/c7725dd8.jpg","comment_is_top":false,"comment_ctime":1533111613,"is_pvip":false,"replies":[{"id":"6321","content":"前者指Throwable.fillStackTrace以及异常的构造器，后者为Java虚拟机不想让用户看到的栈帧，比如说方法句柄的适配器类中的方法。之后讲Lambda时会有具体的例子。","user_name":"作者回复","comment_id":18055,"uid":"1176688","ip_address":"","utype":1,"ctime":1533158024,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"14418013501","product_id":100010301,"comment_content":"Java 虚拟机会忽略掉异常构造器以及填充栈帧的 Java 方法（Throwable.fillInStackTrace），直接从新建异常位置开始算起。<br>Java 虚拟机还会忽略标记为不可见的 Java 方法栈帧。<br><br>请问老师，填充栈帧的 Java 方法和不可见的 Java 方法栈帧，是什么","like_count":3,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421375,"discussion_content":"前者指Throwable.fillStackTrace以及异常的构造器，后者为Java虚拟机不想让用户看到的栈帧，比如说方法句柄的适配器类中的方法。之后讲Lambda时会有具体的例子。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533158024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":17975,"user_name":"王小臭","can_delete":false,"product_type":"c1","uid":1161015,"ip_address":"","ucode":"AA95955882B2E7","user_header":"https://static001.geekbang.org/account/avatar/00/11/b7/37/36ce456f.jpg","comment_is_top":false,"comment_ctime":1533079772,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14417981660","product_id":100010301,"comment_content":"辛苦老师了，这么早更新","like_count":3},{"had_liked":false,"id":156021,"user_name":"兔子","can_delete":false,"product_type":"c1","uid":1022286,"ip_address":"","ucode":"327C5142FD0940","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/4e/0146807f.jpg","comment_is_top":false,"comment_ctime":1574813668,"is_pvip":false,"replies":[{"id":"60791","content":"应该反过来思考。当碰见没法确保程序正常运行的时候，应用程序应当抛error。否则抛(checked) exception便可以了。","user_name":"作者回复","comment_id":156021,"uid":"1176688","ip_address":"","utype":1,"ctime":1575473300,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"10164748260","product_id":100010301,"comment_content":"老师，您好！java.lang.Error这种错误产生的原因是什么样的？jvm对这种Error的处理方式跟Exception一样的吗？如果程序碰到这种情况为了确保程序还能正常运行加上try catch是否就可以了？谢谢！","like_count":2,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475959,"discussion_content":"应该反过来思考。当碰见没法确保程序正常运行的时候，应用程序应当抛error。否则抛(checked) exception便可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575473300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137024,"user_name":"gogo","can_delete":false,"product_type":"c1","uid":1003104,"ip_address":"","ucode":"E8F0F3B000020A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/60/0d5aa340.jpg","comment_is_top":false,"comment_ctime":1569577813,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10159512405","product_id":100010301,"comment_content":"老师您好，请教一个问题，在spring项目中使用了统一异常处理，在service层做一些校验，校验失败时抛出异常，在统一异常处理逻辑里封装异常信息返回给客户端，这种场景自定义异常集成RuntimeException是不是比较好呢？","like_count":2,"discussions":[{"author":{"id":1575571,"avatar":"https://static001.geekbang.org/account/avatar/00/18/0a/93/a189ec16.jpg","nickname":"Eric","note":"","ucode":"7EB511C384BD7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338605,"discussion_content":"通常情况下，程序中自定义的异常应为检查异常，以便最大化利用 Java 编译器的编译时检查。RuntimeException是非检查异常","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609321578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2106663,"avatar":"https://static001.geekbang.org/account/avatar/00/20/25/27/0076d304.jpg","nickname":"帽子狗","note":"","ucode":"51596F366AF068","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326099,"discussion_content":"这都哪跟哪啊......","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605520937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88212,"user_name":"左瞳","can_delete":false,"product_type":"c1","uid":1206589,"ip_address":"","ucode":"B262A3E99C8605","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/3d/3cfb9b87.jpg","comment_is_top":false,"comment_ctime":1555894905,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10145829497","product_id":100010301,"comment_content":"捕捉异常代码性能差是因为需要生成该异常的栈轨迹，就算不捕捉，也会打印该异常的的栈轨迹啊，那性能本来就差啊，何来捕捉异常性能差之说？","like_count":2,"discussions":[{"author":{"id":1460942,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4a/ce/affe4307.jpg","nickname":"叫啥不行","note":"","ucode":"A84B9B6594BF35","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275047,"discussion_content":"不捕捉异常的话直接就停了，应该就不用考虑性能了。。我是这么理解的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590653127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2106663,"avatar":"https://static001.geekbang.org/account/avatar/00/20/25/27/0076d304.jpg","nickname":"帽子狗","note":"","ucode":"51596F366AF068","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1460942,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4a/ce/affe4307.jpg","nickname":"叫啥不行","note":"","ucode":"A84B9B6594BF35","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326101,"discussion_content":"捕捉之后会查异常表。查不到往上抛，最坏情况会查全部链路异常表所以性能差。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605521170,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":275047,"ip_address":""},"score":326101,"extra":""}]}]},{"had_liked":false,"id":76311,"user_name":"我已经设置了昵称","can_delete":false,"product_type":"c1","uid":1364034,"ip_address":"","ucode":"ED672C5EBDBDC4","user_header":"https://static001.geekbang.org/account/avatar/00/14/d0/42/6fd01fb9.jpg","comment_is_top":false,"comment_ctime":1552570301,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10142504893","product_id":100010301,"comment_content":"对于实践环节表示看不懂字节码代码，无法理解，老师能不能在后篇解释下前篇遗留的问题","like_count":2},{"had_liked":false,"id":17979,"user_name":"南城风戈","can_delete":false,"product_type":"c1","uid":1183167,"ip_address":"","ucode":"BF038B447DC063","user_header":"https://static001.geekbang.org/account/avatar/00/12/0d/bf/c8f343a3.jpg","comment_is_top":false,"comment_ctime":1533081483,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10123016075","product_id":100010301,"comment_content":"沙发","like_count":2},{"had_liked":false,"id":232570,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1594040729,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5889008025","product_id":100010301,"comment_content":"动手实践最美丽：<br>Compiled from &quot;Foo.java&quot;<br>public class Foo {<br>  public Foo();<br>    Code:<br>       0: aload_0<br>       1: invokespecial #1                  &#47;&#47; Method java&#47;lang&#47;Object.&quot;&lt;init&gt;&quot;:()V<br>       4: return<br><br>  public void test();<br>    Code:<br>       0: aload_0<br>       1: iconst_0<br>       2: putfield      #2                  &#47;&#47; Field tryBlock:I<br>       5: aload_0<br>       6: iconst_2<br>       7: putfield      #3                  &#47;&#47; Field finallyBlock:I<br>      10: goto          35<br>      13: astore_1<br>      14: aload_0<br>      15: iconst_1<br>      16: putfield      #5                  &#47;&#47; Field catchBlock:I<br>      19: aload_0<br>      20: iconst_2<br>      21: putfield      #3                  &#47;&#47; Field finallyBlock:I<br>      24: goto          35<br>      27: astore_2<br>      28: aload_0<br>      29: iconst_2<br>      30: putfield      #3                  &#47;&#47; Field finallyBlock:I<br>      33: aload_2<br>      34: athrow<br>      35: aload_0<br>      36: iconst_3<br>      37: putfield      #6                  &#47;&#47; Field methodExit:I<br>      40: return<br>    Exception table:<br>       from    to  target type<br>           0     5    13   Class java&#47;lang&#47;Exception<br>           0     5    27   any<br>          13    19    27   any<br>}<br>","like_count":1},{"had_liked":false,"id":58008,"user_name":"gentleman♥️","can_delete":false,"product_type":"c1","uid":1119062,"ip_address":"","ucode":"0BAC746A70038C","user_header":"https://static001.geekbang.org/account/avatar/00/11/13/56/6a062937.jpg","comment_is_top":false,"comment_ctime":1546959882,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5841927178","product_id":100010301,"comment_content":"就是checked异常 一直不try catch ，jvm会怎么个处理流程呢","like_count":1},{"had_liked":false,"id":43983,"user_name":"搬砖的孟达","can_delete":false,"product_type":"c1","uid":1201067,"ip_address":"","ucode":"8F280479C2C83D","user_header":"https://static001.geekbang.org/account/avatar/00/12/53/ab/20f1f4e8.jpg","comment_is_top":false,"comment_ctime":1543361505,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5838328801","product_id":100010301,"comment_content":"这一篇是看的明白的的一篇。😂","like_count":1},{"had_liked":false,"id":23907,"user_name":"Geek_987169","can_delete":false,"product_type":"c1","uid":1180853,"ip_address":"","ucode":"4B2955A044805D","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/b5/8bc4790b.jpg","comment_is_top":false,"comment_ctime":1536716262,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5831683558","product_id":100010301,"comment_content":"老师，请教您一个问题，jvm在执行字节码指令的过程中，在什么情况下会由顺序执行变为跳转执行？","like_count":1},{"had_liked":false,"id":345792,"user_name":"Bumblebee","can_delete":false,"product_type":"c1","uid":2051293,"ip_address":"","ucode":"B879C8A511D08D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","comment_is_top":false,"comment_ctime":1652600371,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1652600371","product_id":100010301,"comment_content":"今日收获<br><br>①  抛异常的方式分为显示抛异常（程序中使用throw关键字进行抛异常）与隐式抛异常（Java虚拟机在运行中碰到无法继续的异常状态自动抛出，例如数组越界异常）；<br><br>②  Java中所有异常都是Throwable类或其子类的实例；<br><br>③  Throwable有两大直接子类，第一类是Error（涵盖程序不能捕获的异常，当触发Error时执行状态已经无法恢复需要中断当前线程甚至是虚拟机）第二类是Exception（典型的代表是RuntimeException异常，表示程序虽然被中断但是还可以进行挽救）；<br><br>④  RuntimeException与Error在Java属于非检查异常（抛异常的所在方法可以不进行throws关键字申明），其他属于受检查异常（需要在抛异常的方法声明throws关键字将异常抛出）；<br><br>⑤  异常实例的构造非常昂贵（因为在构造异常实例时Java虚拟机会逐一访该线程的Java栈帧并记录调用链上的详细信息，包括栈帧所指的方法名字方法所在的类名文件名以及抛异常的代码行数）；<br>当然，在生成栈轨迹时，Java 虚拟机会忽略掉异常构造器以及填充栈帧的 Java 方法（Throwable.fillInStackTrace），直接从新建异常位置开始算起。此外，Java 虚拟机还会忽略标记为不可见的 Java 方法栈帧；<br><br>⑤  Java虚拟机是如何捕获异常的？<br>      1）进行了异常捕获的代码在生成字节码后，方法会携带一个异常表，异常表中每个条目代表一个异常处理器，每个异常处理器包含（from，to，target指针，以及捕获的异常类型所组成）<br><br>      2）from，to，target这些指针是字节码索引，用以定位字节码（from与to指针指向try代码块的起始位置，target指向异常处理器的起始位置，catch代码块的起始位置）；<br>      3）代码示例；<br>源码：<br>public class Test {<br>    public static void main(String[] args) {<br>        try {<br>            int try_i =1;<br>        } catch (RuntimeException e) { }<br>    }<br>}<br>反编译字节码：<br>Compiled from &quot;Test.java&quot;<br>public class org.example.nio.test.Test {<br>  public org.example.nio.test.Test();<br>    Code:<br>       0: aload_0<br>       1: invokespecial #1                  &#47;&#47; Method java&#47;lang&#47;Object.&quot;&lt;init&gt;&quot;:()V<br>       4: return<br><br>  public static void main(java.lang.String[]);<br>    Code:<br>       0: iconst_1<br>       1: istore_1<br>       2: goto          6<br>       5: astore_1<br>       6: return<br>    Exception table:<br>       from    to  target type<br>           0     2     5  ","like_count":0},{"had_liked":false,"id":290057,"user_name":"青阳","can_delete":false,"product_type":"c1","uid":2139807,"ip_address":"","ucode":"3591D366BAB0B9","user_header":"https://static001.geekbang.org/account/avatar/00/20/a6/9f/3c60fffd.jpg","comment_is_top":false,"comment_ctime":1619341586,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1619341586","product_id":100010301,"comment_content":"不记得在哪看过一句，程序运行时抛出RuntimeException，都是和代码逻辑错误有关系，所以抛出这个异常的时候要修复代码了","like_count":0},{"had_liked":false,"id":259293,"user_name":"明月几时","can_delete":false,"product_type":"c1","uid":1675716,"ip_address":"","ucode":"E46C844EAB2CD0","user_header":"https://static001.geekbang.org/account/avatar/00/19/91/c4/bcdcda65.jpg","comment_is_top":false,"comment_ctime":1604674123,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1604674123","product_id":100010301,"comment_content":"抛出异常可分为显式和隐式两种。显式抛异常的主体是应用程序，它指的是在程序中使用“throw”关键字，手动将异常实例抛出。","like_count":0},{"had_liked":false,"id":242777,"user_name":"静静聆听","can_delete":false,"product_type":"c1","uid":1263932,"ip_address":"","ucode":"0A8600CB928EFE","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","comment_is_top":false,"comment_ctime":1597838437,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597838437","product_id":100010301,"comment_content":"课后题：try语句中，每个if语句都会有异常表，如果抛出异常的话，也会跳出for语句","like_count":0},{"had_liked":false,"id":222883,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1590939141,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1590939141","product_id":100010301,"comment_content":"只有try语句出现，方法才有异常表<br>抛异常对于性能还是有一点消耗的，所以从这个角度来看架构上各层或接口的交互业务异常以约定而非抛异常会更加合适","like_count":0,"discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404246,"discussion_content":"只有实现了catch代码块的方法才有异常表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634267542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206940,"user_name":"疯情","can_delete":false,"product_type":"c1","uid":1647345,"ip_address":"","ucode":"785237367A9B33","user_header":"https://static001.geekbang.org/account/avatar/00/19/22/f1/11d1f383.jpg","comment_is_top":false,"comment_ctime":1586960346,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1586960346","product_id":100010301,"comment_content":"请教老师<br>我看到了这句话：并且，在这个 finally 代码块的最后，Java 编译器会重新抛出所捕获的异常。<br>我的理解是在执行完finally后是会抛出异常的，但我用代码尝试了一下，发现是正常结束的，请问老师这是为什么呢？<br>public class Test {<br>    public static void main(String[] args) {<br>       test();<br>    }<br><br>    private static void test() {<br>        String s3;<br>        try {<br>            s3 = &quot;This is try&quot;;<br>            System.out.println(1&#47;0);<br>        }catch (Exception e){<br>            s3 = &quot;This is catch&quot;;<br>        }finally {<br>            s3 = &quot;This is finally&quot;;<br>        }<br>        s3 = &quot;This is exit&quot;;<br>        System.out.println(s3);<br>    }<br>}","like_count":0,"discussions":[{"author":{"id":1210505,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLUz2nCCzSKibFJibtoAJXo2lP3tmeRUe2EqmQr4kYbCv5q4eexhfN3XicynSx5uZ5EREumRwZxqHjGw/132","nickname":"小跳蛙","note":"","ucode":"6C4DADD8414F9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":277302,"discussion_content":"因为前提是，“如果该异常没有被捕获” 你的异常被捕获了哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591024955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":194367,"user_name":"彭文达","can_delete":false,"product_type":"c1","uid":1801058,"ip_address":"","ucode":"8DCC27EC5AF263","user_header":"https://static001.geekbang.org/account/avatar/00/1b/7b/62/ec94cee4.jpg","comment_is_top":false,"comment_ctime":1585054861,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585054861","product_id":100010301,"comment_content":"如果不try catch，报错了也会抛异常，那么不也是要构造异常对象?两者有什么区别呐?","like_count":0},{"had_liked":false,"id":171252,"user_name":"88591","can_delete":false,"product_type":"c1","uid":1254656,"ip_address":"","ucode":"04CE3E46455185","user_header":"https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg","comment_is_top":false,"comment_ctime":1578886432,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578886432","product_id":100010301,"comment_content":"异常定义了程序出错怎么办? 1、程序错误可以处理（可捕获异常）），2、程序出错不可以处理（不可捕获异常）。当可以处理的时候，又可分为 jvm 处理，还是程序开发者处理。","like_count":0},{"had_liked":false,"id":164620,"user_name":"无言的约定","can_delete":false,"product_type":"c1","uid":1128953,"ip_address":"","ucode":"5E8046EB6B7956","user_header":"https://static001.geekbang.org/account/avatar/00/11/39/f9/acfb9a48.jpg","comment_is_top":false,"comment_ctime":1577061570,"is_pvip":false,"replies":[{"id":"65680","content":"你可以整个方法用try catch 包住，捕获Throwable并在异常处理器中写日志，并用throw语句重新抛该异常","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1578329771,"ip_address":"","comment_id":164620,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577061570","product_id":100010301,"comment_content":"郑老师，问个问题，在执行某个方法时，我不知道在哪会发生异常，这个时候我怎么才能捕获可能产生的异常并存储在日志文件里？","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478841,"discussion_content":"你可以整个方法用try catch 包住，捕获Throwable并在异常处理器中写日志，并用throw语句重新抛该异常","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578329771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162123,"user_name":"简乐","can_delete":false,"product_type":"c1","uid":1498613,"ip_address":"","ucode":"258CCEBC9DFF46","user_header":"https://static001.geekbang.org/account/avatar/00/16/dd/f5/fd9ee46b.jpg","comment_is_top":false,"comment_ctime":1576463873,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1576463873","product_id":100010301,"comment_content":"老师，多线程情况下，子线程抛出的异常无法被主线程捕获。请问，这从Jvm原理上如何解释呢？","like_count":0,"discussions":[{"author":{"id":1548645,"avatar":"https://static001.geekbang.org/account/avatar/00/17/a1/65/44853770.jpg","nickname":"Hi Young","note":"","ucode":"E1E9C88399F3C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":156422,"discussion_content":"构建异常实例时，是逐一访问 当前线程  Java栈帧，即主线程只能访问自己线程，不能访问子线程","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1580361801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1498613,"avatar":"https://static001.geekbang.org/account/avatar/00/16/dd/f5/fd9ee46b.jpg","nickname":"简乐","note":"","ucode":"258CCEBC9DFF46","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1548645,"avatar":"https://static001.geekbang.org/account/avatar/00/17/a1/65/44853770.jpg","nickname":"Hi Young","note":"","ucode":"E1E9C88399F3C2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":234677,"discussion_content":"多谢指点！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586993410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":156422,"ip_address":""},"score":234677,"extra":""}]}]},{"had_liked":false,"id":159775,"user_name":"鼠里鼠气","can_delete":false,"product_type":"c1","uid":1696883,"ip_address":"","ucode":"4793476BBDB202","user_header":"https://static001.geekbang.org/account/avatar/00/19/e4/73/74dce191.jpg","comment_is_top":false,"comment_ctime":1575785228,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575785228","product_id":100010301,"comment_content":"文中说&quot;该异常对应的栈轨迹并非 throw 语句的位置，而是新建异常的位置。&quot;我的问题是新建异常的位置在哪里？怎么理解？请老师回答一下谢谢😜","like_count":0},{"had_liked":false,"id":153722,"user_name":"Randy","can_delete":false,"product_type":"c1","uid":1125259,"ip_address":"","ucode":"7BF52ADBFD4F5D","user_header":"https://static001.geekbang.org/account/avatar/00/11/2b/8b/dd02189a.jpg","comment_is_top":false,"comment_ctime":1574299340,"is_pvip":false,"replies":[{"id":"60792","content":"你就看看字节码里面出现几句iconst_2 (由finallyBlock = 2编译得出)","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1575473438,"ip_address":"","comment_id":153722,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574299340","product_id":100010301,"comment_content":"郑老师，请教一下 ，文章中说下面这段代码编译出了3份finally 代码块，请问是怎么看出来的，请帮忙解读一下<br>public void test() {<br>    try {<br>      tryBlock = 0;<br>    } catch (Exception e) {<br>      catchBlock = 1;<br>    } finally {<br>      finallyBlock = 2;<br>    }<br>    methodExit = 3;<br>  }","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475250,"discussion_content":"你就看看字节码里面出现几句iconst_2 (由finallyBlock = 2编译得出)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575473438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136472,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1569457148,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569457148","product_id":100010301,"comment_content":"赞，要通过工具来验证到底是不是这样，比如try-catch-finally构造例子来验证那段很赞。","like_count":0},{"had_liked":false,"id":131996,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1568001599,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568001599","product_id":100010301,"comment_content":"<br>异常表：编译生成的字节码中，每个方法都有一个异常表，每个异常表由多个条目组成，每个条目代表一个异常处理器，其利用字节码索引定位字节码。在程序执行流程中触发异常时，程序遍历异常表，若该字节码索引值在异常表监控范围内，则按异常表定位的字节码位置继续程序逻辑，否则弹出JAVA栈帧，并在调用者重复该操作。<br>finally代码：编译后会有三份，一份在try代码后，一份在catch代码后，一份生成用于处理try中抛出但未在catch中捕获的异常及catch中抛出的异常","like_count":0},{"had_liked":false,"id":103646,"user_name":"KingSwim","can_delete":false,"product_type":"c1","uid":1024043,"ip_address":"","ucode":"84DE14B7EB2580","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a0/2b/efa6dc2e.jpg","comment_is_top":false,"comment_ctime":1560482149,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1560482149","product_id":100010301,"comment_content":"老师：<br>&#47;&#47;第一种<br>try {<br>  ...<br>} catch (SomeException | OtherException e) {<br>  ...<br>}<br>&#47;&#47;第二种<br>try {<br>  ...<br>} catch (Exception e) {<br>  ...<br>}<br>哪种好？<br>","like_count":0,"discussions":[{"author":{"id":1156113,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a4/11/3410b14b.jpg","nickname":"wwwwww","note":"","ucode":"B9EC1AE85C2BDD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212888,"discussion_content":"我想应该是捕获特定异常比较好，不要捕获通用异常。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585028972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84011,"user_name":"jack Wong","can_delete":false,"product_type":"c1","uid":1356930,"ip_address":"","ucode":"EDF88971815846","user_header":"https://static001.geekbang.org/account/avatar/00/14/b4/82/62548de6.jpg","comment_is_top":false,"comment_ctime":1554769394,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554769394","product_id":100010301,"comment_content":"老师，想请教你一下，这个：如果遍历完所有异常表条目，Java 虚拟机仍未匹配到异常处理器，那么它会弹出当前方法对应的 Java 栈帧，并且在调用者（caller）中重复上述操作。在最坏情况下，Java 虚拟机需要遍历当前线程 Java 栈上所有方法的异常表。   这里我的理解是不是一个循环遍历，直至找到对应的catch块为止呢，如果没有找到对应的catch，那么就直接抛出还是？","like_count":0},{"had_liked":false,"id":80093,"user_name":"jack Wong","can_delete":false,"product_type":"c1","uid":1356930,"ip_address":"","ucode":"EDF88971815846","user_header":"https://static001.geekbang.org/account/avatar/00/14/b4/82/62548de6.jpg","comment_is_top":false,"comment_ctime":1553604681,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553604681","product_id":100010301,"comment_content":"老师想了解下，finally那张图，如果第二个，蓝色块，正常执行块那里，如果蓝色finally代码块出现了异常，那么是不是重新抛出异常呢","like_count":0},{"had_liked":false,"id":60611,"user_name":"一个坏人","can_delete":false,"product_type":"c1","uid":1032305,"ip_address":"","ucode":"4AF05BF008095A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c0/71/c83d8b15.jpg","comment_is_top":false,"comment_ctime":1547518882,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1547518882","product_id":100010301,"comment_content":"老师好，请教你一个问题。既然异常处理比较耗性能，我们应该杜绝用异常来实现业务的控制流程？比如下面代码：<br>try {  <br>  UserManager.login(xx,xx);<br>用户登陆以后的主事件流代码  <br>} catch (UserNotFoundException e); {  <br>用户名称没有的事件处理，例如产生一个提示用户注册的页面  <br>} catch (PasswordNotMatchException e); {  <br>密码不对的事件处理，例如forward到重新登陆的页面  <br>}  ","like_count":0},{"had_liked":false,"id":58007,"user_name":"gentleman♥️","can_delete":false,"product_type":"c1","uid":1119062,"ip_address":"","ucode":"0BAC746A70038C","user_header":"https://static001.geekbang.org/account/avatar/00/11/13/56/6a062937.jpg","comment_is_top":false,"comment_ctime":1546959835,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546959835","product_id":100010301,"comment_content":"老师 如果异常 一直往外抛，比如在controller层的方法上，还往外抛，那jvm又是怎么处理的呢","like_count":0},{"had_liked":false,"id":57629,"user_name":"晖","can_delete":false,"product_type":"c1","uid":1237240,"ip_address":"","ucode":"134238AAD7A254","user_header":"https://static001.geekbang.org/account/avatar/00/12/e0/f8/e5e5d037.jpg","comment_is_top":false,"comment_ctime":1546854767,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546854767","product_id":100010301,"comment_content":"从字节码中解析得到：try catch里的每个if 都会copy一份finally里的代码。工作量真大。。","like_count":0},{"had_liked":false,"id":56922,"user_name":"喂！让一下，我有刺。","can_delete":false,"product_type":"c1","uid":1017814,"ip_address":"","ucode":"571B83DA57478F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/d6/86f69446.jpg","comment_is_top":false,"comment_ctime":1546580094,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546580094","product_id":100010301,"comment_content":"学无止境","like_count":0},{"had_liked":false,"id":34351,"user_name":"笨鸟","can_delete":false,"product_type":"c1","uid":1236320,"ip_address":"","ucode":"68029ADA76AA5A","user_header":"https://static001.geekbang.org/account/avatar/00/12/dd/60/a6a4f79a.jpg","comment_is_top":false,"comment_ctime":1540122754,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540122754","product_id":100010301,"comment_content":"在每个分支后面都添加一个finaly语句。","like_count":0},{"had_liked":false,"id":27955,"user_name":"不二","can_delete":false,"product_type":"c1","uid":1140951,"ip_address":"","ucode":"1E1527C71FD9DB","user_header":"https://static001.geekbang.org/account/avatar/00/11/68/d7/714c3d89.jpg","comment_is_top":false,"comment_ctime":1537970611,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1537970611","product_id":100010301,"comment_content":"异常实例的构造是在catch到异常之后进行的吗","like_count":0},{"had_liked":false,"id":22084,"user_name":"旭东(Frank)","can_delete":false,"product_type":"c1","uid":1024486,"ip_address":"","ucode":"176FA629800062","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a1/e6/50da1b2d.jpg","comment_is_top":false,"comment_ctime":1535474707,"is_pvip":false,"replies":[{"id":"8011","content":"检查式异常是为了强制在源代码中进行异常处理。<br><br>第二个问题没理解，能否给个例子？","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1535620377,"ip_address":"","comment_id":22084,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1535474707","product_id":100010301,"comment_content":"请问检查式异常的初衷是什么？经常因为检查式异常导致方法重构时，相应方法的封装性被破坏？<br><br>如何正确使用这两种异常，有何指导意见？谢谢","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422994,"discussion_content":"检查式异常是为了强制在源代码中进行异常处理。\n\n第二个问题没理解，能否给个例子？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535620377,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21395,"user_name":"猿工匠","can_delete":false,"product_type":"c1","uid":1112986,"ip_address":"","ucode":"82FA8DE6C28936","user_header":"https://static001.geekbang.org/account/avatar/00/10/fb/9a/72f7b184.jpg","comment_is_top":false,"comment_ctime":1535071186,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1535071186","product_id":100010301,"comment_content":"很清楚，细致，谢谢郑老师","like_count":0},{"had_liked":false,"id":18421,"user_name":"慢悠悠","can_delete":false,"product_type":"c1","uid":1182702,"ip_address":"","ucode":"F82B556CA91013","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/ee/96cde685.jpg","comment_is_top":false,"comment_ctime":1533298437,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1533298437","product_id":100010301,"comment_content":"Android上是throw之后，标记异常，然后去find catch块，如果找到就清楚异常，否则返回","like_count":0},{"had_liked":false,"id":18283,"user_name":"kass","can_delete":false,"product_type":"c1","uid":1184042,"ip_address":"","ucode":"D7BEC9384E62D7","user_header":"https://static001.geekbang.org/account/avatar/00/12/11/2a/35edd284.jpg","comment_is_top":false,"comment_ctime":1533230261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1533230261","product_id":100010301,"comment_content":"异常表是有try catch的方法才会生成的吧？","like_count":0},{"had_liked":false,"id":18253,"user_name":"贾智文","can_delete":false,"product_type":"c1","uid":1100235,"ip_address":"","ucode":"600CF0AB215D1A","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/cb/7b6802cc.jpg","comment_is_top":false,"comment_ctime":1533213726,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1533213726","product_id":100010301,"comment_content":"老师，请教个问题，java可以通过反射的方式为属性设置注解吗？ 公司自研的框架需要每个属性都加一次注解，想反射直接全部设置上去。查了好久没有找到方式，要么是修改注解值要么查值…","like_count":0},{"had_liked":false,"id":18199,"user_name":"杨春鹏","can_delete":false,"product_type":"c1","uid":1172056,"ip_address":"","ucode":"518F38232F97B5","user_header":"https://static001.geekbang.org/account/avatar/00/11/e2/58/8c8897c8.jpg","comment_is_top":false,"comment_ctime":1533185930,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1533185930","product_id":100010301,"comment_content":"Try catch finally的字节码组成:<br>如果try正常执行，则直接跳转到第三个finally代码块；如果try中有异常抛出并且被catch捕获，则执行第一个代码块；如果try中有异常抛出并且该异常不能被catch捕获或者catch代码块抛出的异常则异常处理器从第二个finally代码块开始执行。","like_count":0},{"had_liked":false,"id":18009,"user_name":"YIFENG","can_delete":false,"product_type":"c1","uid":1069423,"ip_address":"","ucode":"78C3EA8995DB3B","user_header":"https://static001.geekbang.org/account/avatar/00/10/51/6f/f33beea5.jpg","comment_is_top":false,"comment_ctime":1533085482,"is_pvip":false,"replies":[{"id":"6317","content":"在catch代码块中用throw语句重新抛出异常","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1533156720,"ip_address":"","comment_id":18009,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1533085482","product_id":100010301,"comment_content":"老师，在讲复制finally部分的图中，复制到catch部分的finally右边的黄色虚线指向重新抛出异常，哪种情况会走到这条黄线路径呢？","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421358,"discussion_content":"在catch代码块中用throw语句重新抛出异常","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533156720,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1397031,"avatar":"https://static001.geekbang.org/account/avatar/00/15/51/27/f0dd6f19.jpg","nickname":"老白","note":"","ucode":"39881175152D49","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41051,"discussion_content":"感觉有点问题，看字节码，catch代码块中用 throw 语句重新抛出异常的时候，编译器直接不会将 finally块copy到 catch 退出位置了，直接被最后的 finally 捕获，然后重新抛出异常。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572337035,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}