{"id":741047,"title":"第 22 章 Docker容器","content":"\n<p>在本章开头，阿铭先来介绍一个场景：如果一个软件（阿铭给它起了一个名字：NiuBys）想在Linux操作系统上运行，需要搭建超过20个依赖的环境包，而且这些环境包有很多只能编译安装，所以要想成功运行NiuBys，至少要花费5个小时。那么有没有一种方法可以将这些依赖环境包和NiuBys打包成一个综合体，下次再安装时直接安装这个综合体，这样不就简单多了吗？事实上，还真有类似的技术，那就是本章要介绍的容器技术。</p>\n<p>容器技术中的典型代表就是Docker，毫不夸张地说，如果你不会用Docker，就不算一名合格的运维人员。在没有真正接触容器之前，无论阿铭说多少容器的优势，你可能都无法理解，因为你还没有亲自体验过它。接下来，阿铭要带你一步一步了解Docker。</p>\n<h2 id=\"nav_point_402\">22.1 在CentOS 8上安装Docker</h2>\n<p>作为时下比较流行的一种容器技术，Docker必然支持在多个操作系统上安装，比如Windows、macOS以及Unix等，也就是说Docker支持跨平台，所以我们可以将阿铭介绍的NiuBys很方便地移植到Windows或者macOS上。在本章中，阿铭的演示将基于CentOS 8。</p>\n<h3 id=\"nav_point_403\">22.1.1 下载Docker</h3>\n<p>你可以通过yum安装Docker，不过暂时Docker官方并没有提供CentOS 8的yum源，网上有很多资料是在CentOS 8上使用基于CentOS 7的yum源，但阿铭觉得并不合适。所以，阿铭给出的方法是使用二进制包来安装Docker。相关命令如下：</p><!-- [[[read_end]]] -->\n<pre class=\"code-rows\"><code># wget https://download.docker.com/linux/static/stable/x86_64/docker-19.03.12.tgz</code></pre>\n<h3 id=\"nav_point_404\">22.1.2 在CentOS 8上安装Docker</h3>\n<p>对于二进制的Docker安装包，解压后就可以直接使用了，步骤如下：</p>\n<pre class=\"code-rows\"><code># tar zxf docker-19.03.12.tgz // 解压\n# cp docker/* /usr/bin/</code></pre>\n<p>此时就可以使用<code>docker</code>命令了：</p>\n<pre class=\"code-rows\"><code># docker -v // 如果正常的话，会出现如下内容\nDocker version 19.03.12, build 48a66213fe</code></pre>\n<p>Docker也是一个服务，所以我们还需要编辑启动脚本：</p>\n<pre class=\"code-rows\"><code># vim /usr/lib/systemd/system/docker.service // 加入如下内容\n[Unit]\nDescription=Docker Application Container Engine\nDocumentation=https://docs.docker.com\nAfter=network-online.target firewalld.service\nWants=network-online.target\n\n[Service]\nType=notify\nExecStart=/usr/bin/dockerd\nExecReload=/bin/kill -s HUP $MAINPID\nLimitNOFILE=infinity\nLimitNPROC=infinity\nTimeoutStartSec=0\nDelegate=yes\nKillMode=process\nRestart=on-failure\nStartLimitBurst=3\nStartLimitInterval=60s\n\n[Install]\nWantedBy=multi-user.target</code></pre>\n<p>然后启动Docker服务：</p>\n<pre class=\"code-rows\"><code># systemctl daemon-reload\n# systemctl start docker\n# systemctl enable docker\nCreated symlink /etc/systemd/system/multi-user.target.wants/docker.service → /usr/lib/systemd/\n system/docker.service.</code></pre>\n<p>查看进程：</p>\n<pre class=\"code-rows\"><code># ps aux |grep docker\nroot 24427 1.5 2.8 751780 53556 ? Ssl 22:14 0:00 /usr/bin/dockerd\nroot 24434 1.5 1.4 723528 26288 ? Ssl 22:14 0:00 containerd --config /var/run/\n docker/containerd/containerd.toml --log-level info</code></pre>\n<p>到此，Docker安装结束，下面阿铭会逐一介绍与Docker相关的概念。</p>\n<h2 id=\"nav_point_405\">22.2 Docker镜像</h2>\n<p>Docker镜像类似于安装操作系统的ISO文件，我们通过ISO文件安装一个操作系统，同样可以使用Docker镜像启动一个容器（对容器的解释，阿铭会在22.3节中详细介绍）。那么Docker镜像从哪里来呢？如何获取呢？先来看下面的例子：</p>\n<pre class=\"code-rows\"><code># docker pull busybox // 获取一个叫作busybox的镜像\nUsing default tag: latest\nError response from daemon: Get https://registry-1.docker.io/v2/: net/http: TLS handshake timeout</code></pre>\n<p>结果是报错了，它告诉我们https://registry-1.docker.io/v2/无法访问，超时了。这个链接其实是Docker镜像的存放地址（也就是后面要跟大家介绍的Docker仓库），由于网络受限，所以下载失败了。但是大家不必担心，阿铭教你设置一个国内的加速器，这样就可以使用国内的资源站来下载Docker镜像了，具体步骤如下：</p>\n<pre class=\"code-rows\"><code># vim /etc/docker/daemon.json // 写入如下内容\n{\n \"registry-mirrors\": [\"https://dhq9bx4f.mirror.aliyuncs.com\"]\n}\n# systemctl restart docker\n# docker pull busybox\nUsing default tag: latest\nlatest: Pulling from library/busybox\n91f30d776fb2: Pull complete\nDigest: sha256:9ddee63a712cea977267342e8750ecbc60d3aab25f04ceacfa795e6fce341793\nStatus: Downloaded newer image for busybox:latest\ndocker.io/library/busybox:latest</code></pre>\n<p>要重启Docker，此设置才会生效，之后再次下载镜像就会非常快了，使用如下命令查看下载的镜像：</p>\n<pre class=\"code-rows\"><code># docker image ls\nREPOSITORY TAG IMAGE ID CREATED SIZE\nbusybox latest c7c37e472d31 2 weeks ago 1.22MB</code></pre>\n<p>busybox是一个非常小的Docker镜像，常被人用作测试或者演示。那么，Docker到底都有啥镜像呢？像CentOS、Ubuntu、MySQL、Nginx、Tomcat等，只要是你接触过的软件，几乎都有相关镜像。当然，你还可以使用<code>docker search</code>命令进行搜索，如下：</p>\n<pre class=\"code-rows\"><code># docker search nginx\nNAME DESCRIPTION STARS OFFICIAL AUTOMATED\nnginx Official build of Nginx. 13469 [OK]\njwilder/nginx-proxy Automated Nginx reverse proxy for docker con… 1839 [OK]\nricharvey/nginx-php-fpm Container running Nginx + PHP-FPM capable of… 780 [OK]\nlinuxserver/nginx An Nginx container, brought to you by LinuxS… 121\nbitnami/nginx Bitnami nginx Docker Image 87 [OK]\ntiangolo/nginx-rtmp Docker image with Nginx using the nginx-rtmp… 83 [OK]\njc21/nginx-proxy-manager Docker container for managing Nginx proxy ho… 70\nalfg/nginx-rtmp NGINX, nginx-rtmp-module and FFmpeg from sou… 70 [OK]\nnginxdemos/hello NGINX webserver that serves a simple page co… 56 [OK]\njlesage/nginx-proxy-manager Docker container for Nginx Proxy Manager 51 [OK]\nnginx/nginx-ingress NGINX Ingress Controller for Kubernetes 37\nprivatebin/nginx-fpm-alpine PrivateBin running on an Nginx, php-fpm &amp; Al… 29 [OK]\nschmunk42/nginx-redirect A very simple container to redirect HTTP tra… 18 [OK]</code></pre>\n<p>排在第一行的肯定是<code>STARS</code>（类似于点赞、收藏，表示喜欢）最多的，也是官方（权威）的镜像。你也可以制作自己的镜像，然后上传到Docker仓库，这样其他人也可以搜索到。那么如何下载一个指定的镜像呢？比如，要下载第四个<code>linuxserver/nginx</code>，相关命令如下：</p>\n<pre class=\"code-rows\"><code># docker pull linuxserver/nginx\nUsing default tag: latest\nlatest: Pulling from linuxserver/nginx\n6eb1af1a521f: Pull complete\n66fa287bda10: Pull complete\n7de41abee0a4: Pull complete\n998ccb56172f: Pull complete\n179b46cdbdd8: Pull complete\na0108804ba5c: Pull complete\ne63a05ec8abf: Pull complete\nDigest: sha256:dc5429ae4a1b5ae329fb64c18f5cd47fbdf152099dca9335f4b46d944bc5c508\nStatus: Downloaded newer image for linuxserver/nginx:latest\ndocker.io/linuxserver/nginx:latest</code></pre>\n<p>在使用<code>docker</code>命令拉取镜像的时候，会发现一句提示<code>Using default tag: latest</code>，这是告诉我们下载的镜像使用了默认的TAG（latest），那么TAG又是什么呢？使用如下命令查看Docker镜像：</p>\n<pre class=\"code-rows\"><code># docker images // 等同于docker image ls\nREPOSITORY TAG IMAGE ID CREATED SIZE\nlinuxserver/nginx latest 75cc19404b34 3 days ago 165MB\nbusybox latest c7c37e472d31 2 weeks ago 1.22MB</code></pre>\n<p>其中第二列就是TAG啦。TAG常用作标记一个镜像的版本，比如我们可以下载一个老版本的Nginx：</p>\n<pre class=\"code-rows\"><code># docker pull nginx:1.16.0\n1.16.0: Pulling from library/nginx\n9fc222b64b0a: Pull complete\n30e9fc7d9c5b: Pull complete\n4b3a8aeaa40e: Pull complete\nDigest: sha256:3e373fd5b8d41baeddc24be311c5c6929425c04cabf893b874ac09b72a798010\nStatus: Downloaded newer image for nginx:1.16.0\ndocker.io/library/nginx:1.16.0\n[root@centos8_1 ~]# docker images\nREPOSITORY TAG IMAGE ID CREATED SIZE\nlinuxserver/nginx latest 75cc19404b34 3 days ago 165MB\nbusybox latest c7c37e472d31 2 weeks ago 1.22MB\nnginx 1.16.0 ae893c58d83f 11 months ago 109MB</code></pre>\n<p>使用<code>docker images</code>命令看到的这些镜像都是已经下载到本地的哦，我们可以对某个镜像修改TAG：</p>\n<pre class=\"code-rows\"><code># docker tag c7c37e472d31 busybox:123\n# docker images busybox\nREPOSITORY TAG IMAGE ID CREATED SIZE\nbusybox 123 c7c37e472d31 2 weeks ago 1.22MB\nbusybox latest c7c37e472d31 2 weeks ago 1.22MB</code></pre>\n<p>你会发现，两个busybox镜像的<code>IMAGE ID</code>是一样的，其实这个<code>IMAGE ID</code>才是某个镜像的唯一标识，镜像名字并不能完全标识某一个镜像，但镜像名字（<code>REPOSITORY</code>）和<code>TAG</code>组合在一起可以标识一个镜像。</p>\n<p>如果某一天你发现服务器上的本地镜像太多了，想删除一些，该如何做呢？此时需要用到下面的这个<code>rmi</code>选项：</p>\n<pre class=\"code-rows\"><code># docker rmi nginx:1.16.0\nUntagged: nginx:1.16.0\nUntagged: nginx@sha256:3e373fd5b8d41baeddc24be311c5c6929425c04cabf893b874ac09b72a798010\nDeleted: sha256:ae893c58d83fe2bd391fbec97f5576c9a34fea55b4ee9daf15feb9620b14b226\nDeleted: sha256:9987b8be475d96bc466b978b64b54af9e556884e78007caa19c065c6723f40e4\nDeleted: sha256:5d7e4cc1668a0ce9764e7dad91cfbe594eea3a5b3ac6f4ec229d549cac20fff0\nDeleted: sha256:8fa655db5360a336ddd0256f573e27975628668063732ef91f820d4770db737c</code></pre>\n<p>但如果该镜像已经启动了容器，那么删除时会报错。由于阿铭还没有介绍容器，所以具体的操作暂时先不演示。遇到此类情况，只能是先停止容器，再删除。删除镜像时，如果指定<code>IMAGE ID</code>，则会把该<code>IMAGE ID</code>对应的所有镜像都删除，但需要加<code>-f</code>选项，命令如下所示：</p>\n<pre class=\"code-rows\"><code># docker rmi -f c7c37e472d31\nUntagged: busybox:123\nUntagged: busybox:latest\nUntagged: busybox@sha256:9ddee63a712cea977267342e8750ecbc60d3aab25f04ceacfa795e6fce341793\nDeleted: sha256:c7c37e472d31c1685b48f7004fd6a64361c95965587a951692c5f298c6685998\nDeleted: sha256:50761fe126b6e4d90fa0b7a6e195f6030fe250c016c2fc860ac40f2e8d2f2615</code></pre>\n<h2 id=\"nav_point_406\">22.3 容器</h2>\n<p>容器就是用镜像运行起来的进程，比如你可以使用Nginx的镜像运行一个Nginx的容器，设置可以使用CentOS的镜像运行一个CentOS系统的容器，这就类似于虚拟机了。阿铭先运行一个busybox的容器，如下所示：</p>\n<pre class=\"code-rows\"><code># docker pull busybox\n# docker run -itd busybox</code></pre>\n<p>需要说明的是，如果事先不把镜像下载下来，当运行<code>docker run</code>的时候，镜像也会自动下载，例如：</p>\n<pre class=\"code-rows\"><code># docker run -itd redis\nUnable to find image 'redis:latest' locally\nlatest: Pulling from library/redis\n8559a31e96f4: Already exists\n85a6a5c53ff0: Pull complete\nb69876b7abed: Pull complete\na72d84b9df6a: Pull complete\n5ce7b314b19c: Pull complete\n04c4bfb0b023: Pull complete\nDigest: sha256:800f2587bf3376cb01e6307afe599ddce9439deafbd4fb8562829da96085c9c5\nStatus: Downloaded newer image for redis:latest\ne9cd29ea23dc304430fc216b30f8188f64953f6ad76fbee41f1fd496a7c25f27</code></pre>\n<p>它会先将镜像拉取下来，然后运行。其中<code>-i</code>参数表示交互式，等会阿铭会进入到容器里敲命令；<code>-t</code>参数表示分配一个伪终端，可以让我们登录进去然后敲命令；<code>-d</code>参数表示将容器丢到后台，如果不丢到后台，那么当命令结束时容器也就停止运行了，这不是我们想要的。所以阿铭建议你启动容器时必带上述三个参数。下面我们进入容器内部看看：</p>\n<pre class=\"code-rows\"><code># docker ps // 查看已经运行的容器，可以带-a参数，它会列出所有容器（包括已经停止的容器）\nCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES\ne9cd29ea23dc redis \"docker-entrypoint.s…\" 5 minutes ago Up 5 minutes 6379/tcp thirsty_taussig\nd436a7c129ea busybo \"sh\" 8 minutes ag Up 8 minutes elated_thompson</code></pre>\n<p>由于显示出来的行内容比较长，所以自动换行了，下面简要介绍各列的含义。</p>\n<ul>\n<li><code>CONTAINER ID</code>：这一列为容器的ID，它是唯一标识容器的属性值。</li>\n<li><code>IMAGE</code>：这一列表示该容器是由哪个镜像启动来的。</li>\n<li><code>COMMAND</code>：这一列为容器启动时运行的命令。</li>\n<li><code>CREATED</code>：这一列为容器启动时间。</li>\n<li><code>STATUS</code>：这一列为该容器运行状态。</li>\n<li><code>PORTS</code>：这一列为该容器监听的端口。</li>\n<li><code>NAMES</code>：这一列为该容器的名字，它的作用跟<code>CONTAINER ID</code>类似，用来标记一个容器。</li>\n</ul>\n<p>下面进入容器里看看：</p>\n<pre class=\"code-rows\"><code># docker exec -it e9cd29ea23dc bash\nroot@e9cd29ea23dc:/data# ls\nroot@e9cd29ea23dc:/data# pwd\n/data</code></pre>\n<p>使用<code>exec</code>指令可以进入容器里，注意这里的<code>e9cd29ea23dc</code>为<code>CONTAINER ID</code>，其实也可以换成<code>name</code>，这要看你更习惯使用哪个。当然，在启动容器时也可以定义<code>name</code>：</p>\n<pre class=\"code-rows\"><code># docker run -itd --name aminglinux busybox\n576dd165fa1e36d086b600dc876ac4f66f915ff35000db322283022f39bbe723\n# docker ps\nCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES\n576dd165fa1e busybox \"sh\" 3 seconds ago Up 2 seconds aminglinux\ne9cd29ea23dc redis \"docker-entrypoint.s...\" 15 minutes ago Up 15 minutes 6379/tcp thirsty_taussig\nd436a7c129ea busybox \"sh\" 18 minutes ago Up 18 minutes elated_thompson</code></pre>\n<p>然后就可以使用<code>name</code>来操作容器了：</p>\n<pre class=\"code-rows\"><code># docker exec -it aminglinux sh\n/ # ls\nbin dev etc home proc root sys tmp usr var\n/ #</code></pre>\n<p>上述命令中后面跟的<code>sh</code>为进入容器要运行的指令，<code>sh</code>其实就是打开一个shell终端，这样就可以在里面敲命令了。创建容器时，除了可以使用<code>docker run</code>命令之外，还可以使用<code>docker create</code>命令，如下：</p>\n<pre class=\"code-rows\"><code># docker create -it nginx:1.8\nUnable to find image 'nginx:1.8' locally\n1.8: Pulling from library/nginx\nImage docker.io/library/nginx:1.8 uses outdated schema1 manifest format. Please upgrade to a schema2 image for better future compatibility. More information at https://docs.docker.com/registry/spec/deprecated-schema-v1/\nefd26ecc9548: Pull complete\na3ed95caeb02: Pull complete\n24941909ea54: Pull complete\n7e605cb95896: Pull complete\nDigest: sha256:c97ee70c4048fe79765f7c2ec0931957c2898f47400128f4f3640d0ae5d60d10\nStatus: Downloaded newer image for nginx:1.8\ndb5522bde518c6a4af86b26219efe65db9a00bbf64223b010a3357c7f61f3d71</code></pre>\n<p>使用<code>docker create</code>命令仅仅是创建了一个容器，如果本地没有镜像，则会从远程下载。创建后，可以使用<code>start</code>命令来启动容器：</p>\n<pre class=\"code-rows\"><code># docker start db5522bde518</code></pre>\n<p><code>docker run</code>命令还有一个常用的选项<code>--rm</code>，它可以让容器在停止或者退出时直接被删除掉：</p>\n<pre class=\"code-rows\"><code># docker run -itd --rm busybox sh\n# docker ps\nCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES\n673e45d336ec busybox \"sh\" 3 seconds ago Up 2 seconds adoring_williams\ndb5522bde518 nginx:1.8 \"bash\" 11 minutes ago Up 9 minutes 80/tcp, 443/tcp sleepy_swanson\n576dd165fa1e busybox \"sh\" 3 days ago Up 3 days aminglinux\ne9cd29ea23dc redis \"docker-entrypoint.s...\" 3 days ago Up 3 days 6379/tcp thirsty_taussig\nd436a7c129ea busybox \"sh\" 3 days ago Up 3 days elated_thompson</code></pre>\n<p>然后将刚刚创建的容器停止：</p>\n<pre class=\"code-rows\"><code># docker stop 673e45d336ec</code></pre>\n<p>现在再查看刚才的容器，已经找不到了：</p>\n<pre class=\"code-rows\"><code># docker ps |grep 673e45d336ec</code></pre>\n<p><code>docker logs</code>用于查看容器的日志，具体如下：</p>\n<pre class=\"code-rows\"><code># docker run -itd busybox sh -c \"while :; do echo 123; sleep 5; done\"\nc2d2f4c9f2b1bb5e7f204a48af3bb31217904db5f564af6db84c5a00ba8e0e21\n# docker logs c2d2f4c9f2b\n123\n123\n123</code></pre>\n<p>有时候，如果容器启动不起来，就可以使用<code>docker logs</code>命令查看具体的错误日志。在日常的工作中，阿铭也会经常使用另外两个选项<code>-v</code>和<code>-p</code>，其中<code>-v</code>用来将宿主机上的目录或文件映射到容器中，而<code>-p</code>用来把容器内的端口映射到宿主机上。比如：</p>\n<pre class=\"code-rows\"><code># docker run -itd –v /data/:/mnt/ busybox sh // 将宿主机的/data/目录映射到容器的/mnt目录，也就是说/data/里有什么文件，容器的/mnt/目录里就有什么文件\n# docker run –itd –p 10001:80 busybox sh // 将容器的80端口映射到宿主机的10001端口，也就是说当访问宿主机的10001端口时，实际上就会访问到容器的80端口</code></pre>\n<p>其他选项由于使用不多，阿铭就不再介绍了。</p>\n<h2 id=\"nav_point_407\">22.4 创建镜像</h2>\n<p>作为新手，我们用得最多的就是下载一个现成的镜像，然后直接拿来用，但是官网上的镜像并不一定适合我们的应用场景，此时就需要自定义镜像。在本节中，阿铭会介绍三种创建镜像的方法。</p>\n<h3 id=\"nav_point_408\">22.4.1 通过容器创建镜像</h3>\n<p>目前有个需求：制作一个基于CentOS 7系统的Nginx服务器镜像。对于这个需求，首先要有一个CentOS 7的系统，然后在此系统中安装Nginx即可。具体步骤如下：</p>\n<pre class=\"code-rows\"><code># docker run -itd --name centos7 centos:7 bash\n# docker exec –it centos7 bash</code></pre>\n<p>进入容器里，安装Nginx，命令如下：</p>\n<pre class=\"code-rows\"><code># vi /etc/yum.repos.d/nginx.repo // 内容如下\n[nginx]\nname=nginx repo\nbaseurl=http://nginx.org/packages/centos/$releasever/$basearch/\ngpgcheck=0\nenabled=1\n# yum install –y nginx</code></pre>\n<p>输入exit或者按Ctrl＋D快捷键，退出该容器，然后将CentOS 7容器导出为镜像即可，命令如下：</p>\n<pre class=\"code-rows\"><code># docker commit -m \"centos7 with nginx\" -a \"aminglinux\" centos7 centos7_with_nginx:1.0</code></pre>\n<p>其中<code>-m</code>后面为描述文字，<code>-a</code>后面为作者，<code>centos7</code>为容器名字或容器id，最后面为新镜像的名字。导出镜像后，使用<code>docker images</code>命令查看镜像：</p>\n<pre class=\"code-rows\"><code># docker images |grep centos7\ncentos7_with_nginx 1.0 1c865b3ce672 2 minutes ago 290MB</code></pre>\n<p>有了这个镜像，就可以直接使用该镜像创建新容器了：</p>\n<pre class=\"code-rows\"><code># docker run -it --rm --name nginx_test centos7_with_nginx:1.0 bash -c \"rpm -qa nginx\"\nnginx-1.18.0-1.el7.ngx.x86_64</code></pre>\n<p>可以看到，Nginx的版本为1.18.0。</p>\n<h3 id=\"nav_point_409\">22.4.2 使用模板创建镜像</h3>\n<p>模板又是什么？简单来讲，模板就是把事先做好的系统以及系统里面的各种文件、服务、配置、数据等制作成一种特殊的文件（这个文件就是模板），然后我们使用该模板文件直接安装系统，这样做出来的系统和先前的系统是一样的。这样做的好处是，可以省掉安装软件、配置服务的时间，这不就类似于Docker镜像嘛。</p>\n<p>在OpenVZ的官网下载一个Ubuntu的模板。下载完后，导入该模板：</p>\n<pre class=\"code-rows\"><code># cat ubuntu-12.04-x86-minimal.tar.gz | docker import - ubuntu:12.04\n# docker images |grep Ubuntu\nubuntu 12.04 c84a97eb1893 37 seconds ago 146MB</code></pre>\n<p>然后使用该镜像启动容器：</p>\n<pre class=\"code-rows\"><code># docker run -itd --name ubuntu1204 ubuntu:12.04 bash\n46cceeda838d9c3c4075b6eecfb62e34f08796f457bc767875546e8df25a0142\n# docker ps |grep ubuntu\n46cceeda838d ubuntu:12.04 \"bash\" 7 seconds ago Up 5 seconds ubuntu1204</code></pre>\n<p>其实对于导入的镜像，还可以再把它导出：</p>\n<pre class=\"code-rows\"><code># docker save -o aminglinux.tar ubuntu:12.04\n# du -sh aminglinux.tar\n148M aminglinux.tar</code></pre>\n<p>这个aminglinux.tar文件就是导出的镜像文件，大小为148MB，跟刚下载的ubuntu-12.04-x86-minimal.tar.gz文件相比大了很多，其实它们俩是一样的，只不过aminglinux.tar这个文件还没有压缩，压缩完后就跟ubuntu-12.04-x86-minimal.tar.gz的大小一样了。而<code>save</code>导出的镜像如何导入？命令如下：</p>\n<pre class=\"code-rows\"><code># docker load --input aminglinux.tar // 或者\n# docker load &lt; aminglinux.tar</code></pre>\n<p>那我们是否可以自己制作模板呢？也就是说将运行的容器导出为模板，比如将我们上面做的CentOS 7制作为一个模板。答案是必须可以啊，过程如下：</p>\n<pre class=\"code-rows\"><code># docker ps |grep centos7\neea48f5e7f53 centos:7 \"bash\" 24 hours ago Up 24 hours centos7\n[root@centos8_1 ~]# docker export eea48f5e7f53 &gt; centos7.tar</code></pre>\n<p>然后我们再把它导入，并启动为容器：</p>\n<pre class=\"code-rows\"><code># cat centos7.tar |docker import - centos7:new\n# docker run –itd --name centos7_new centos7:new bash</code></pre>\n<p>注意整个过程：先由容器导出为模板→再由模板导入为镜像→再由镜像启动容器。在本节中，阿铭介绍了两种导出镜像的方法，一种是<code>docker save</code>，一种是<code>docker export</code>，它们的区别在于，前者的操作对象是镜像，而后者的操作对象是容器。</p>\n<h3 id=\"nav_point_410\">22.4.3 使用Dockerfile创建镜像</h3>\n<p>Dockerfile类似于Linux系统里面的shell脚本，它可以基于已存在的镜像创建新的镜像。比如，基于CentOS 7，安装一个MySQL服务，就可以使用Dockerfile来实现。Dockerfile是一个用来构建镜像的文本文件，其中包含了一条条构建镜像所需的指令和说明，下面简要介绍各个指令的作用。</p>\n<ul>\n<li><p><code>FROM</code>用于指定基于哪个镜像。</p>\n<p>命令格式：</p>\n<p><code>FROM &lt;image&gt;</code> 或者<code>FROM &lt;image&gt;:&lt;tag&gt;</code></p>\n<p>命令举例：</p>\n<pre class=\"code-rows\"><code>FROM centos\nFROM centos:7</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><code>MAINTAINER</code>用于指定作者信息。</p>\n<p>命令格式：</p>\n<pre class=\"code-rows\"><code>MAINTAINER &lt;name&gt;</code></pre>\n<p>命令举例：</p>\n<pre class=\"code-rows\"><code>MAINTAINER aming aming@aminglinux.com</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><code>RUN</code>表示运行镜像操作指令。</p>\n<p>命令格式：</p>\n<pre class=\"code-rows\"><code>RUN &lt;command&gt; 或者 RUN [\"executable\", \"param1\", \"param2\"]</code></pre>\n<p>命令举例：</p>\n<pre class=\"code-rows\"><code>RUN yum install httpd\nRUN [\"/bin/bash\", \"-c\", \"echo hello\"]</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><code>CMD</code>为启动容器时运行的指令。</p>\n<pre class=\"code-rows\"><code>CMD [\"executable\", \"param1\", \"param2\"]\nCMD command param1 param2\nCMD [\"param1\", \"param2\"]</code></pre>\n<p>虽然<code>RUN</code>和<code>CMD</code>看起来挺像，但是<code>CMD</code>用于指定容器启动时用到的命令，只能有一条。比如：</p>\n<pre class=\"code-rows\"><code>CMD [\"/bin/bash\", \"/usr/local/nginx/sbin/nginx\", \"-c\", \"/usr/local/nginx/conf/nginx.conf\"]</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><code>EXPOSE</code>用于定义映射端口。</p>\n<p>命令格式：</p>\n<pre class=\"code-rows\"><code>EXPOSE &lt;port&gt; [&lt;port&gt;...]</code></pre>\n<p>命令举例：</p>\n<pre class=\"code-rows\"><code>EXPOSE 22 80 8443</code></pre>\n<p>这个用来指定要映射出去的端口，比如我们在容器内部启动了sshd和Nginx，所以需要把22和80端口暴露出去。这个需要配合<code>-P</code>（大写）来工作，也就是说在启动容器时，需要加上<code>-P</code>，让它自动分配。如果想指定具体的端口，也可以使用<code>-p</code>（小写）来指定。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><code>ENV</code>用于定义容器内的环境变量。</p>\n<p>命令格式：</p>\n<pre class=\"code-rows\"><code>ENV &lt;key&gt; &lt;value&gt;</code></pre>\n<p>命令举例：</p>\n<pre class=\"code-rows\"><code>ENV PATH /usr/local/mysql/bin:$PATH</code></pre>\n<p>它主要是为后续的<code>RUN</code>指令提供一个环境变量。我们也可以定义一些自定义的变量，比如：</p>\n<pre class=\"code-rows\"><code>ENV MYSQL_version 5.6</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><code>ADD</code>用于将文件或目录复制到镜像里，支持HTTP连接。</p>\n<p>命令格式：</p>\n<pre class=\"code-rows\"><code>ADD &lt;src&gt; &lt;dest&gt;</code></pre>\n<p>将本地的一个文件或目录复制到容器的某个目录里。其中<code>src</code>为Dockerfile所在目录的相对路径，它也可以是一个URL。比如：</p>\n<pre class=\"code-rows\"><code>ADD &lt;conf/vhosts&gt; &lt;/usr/local/nginx/conf&gt;</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><code>COPY</code>用于将文件或目录复制到镜像。</p>\n<p>命令格式：</p>\n<pre class=\"code-rows\"><code>COPY &lt;src&gt; &lt;dest&gt;</code></pre>\n<p>使用方法和<code>ADD</code>一样，不同之处是它不支持URL。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><code>ENTRYPOINT</code>用于定义容器启动时运行的指令。</p>\n<p>格式类似<code>CMD</code>，也是只有一条生效，如果写多个，则只有最后一条有效。和<code>CMD</code>不同的是：<code>CMD</code>是可以被<code>docker run</code>指令覆盖的，而<code>ENTRYPOINT</code>不能。比如，容器名字为aming，我们在Dockerfile中指定如下<code>CMD</code>：</p>\n<pre class=\"code-rows\"><code>CMD [\"/bin/echo\", \"test\"]</code></pre>\n<p>启动容器的命令是<code>docker run aming，</code>这样会输出<code>test</code>。假如启动容器的命令是<code>docker run -it aming&nbsp;&nbsp;/bin/bash</code>，最终它什么都不会输出，因为这里的<code>/bin/bash</code>指令将<code>CMD</code>的<code>/bin/echo test</code>覆盖了。</p>\n<p>而<code>ENTRYPOINT</code>不会被覆盖，且会比<code>CMD</code>或者<code>docker run</code>指定的命令要靠前执行，比如：</p>\n<pre class=\"code-rows\"><code>ENTRYPOINT [\"echo\", \"test\"]\ndocker run -it aming 123</code></pre>\n<p>会输出<code>test 123</code>，这相当于要执行命令<code>echo test&nbsp;&nbsp;123</code>，也就是说<code>docker run</code>提供的指令叠加在了<code>ENTRYPOINT</code>提供指令的后面。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><code>VOLUME</code>用于指定映射目录。</p>\n<p>命令格式：</p>\n<pre class=\"code-rows\"><code>VOLUME [\"/data\"]</code></pre>\n<p>它的作用是创建一个可以从本地主机或其他容器挂载的挂载点，这个挂载点会映射到宿主机的某个目录下，这里不能指定，是自动生成的。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><code>USER</code>用于定义运行容器的用户。</p>\n<p>命令格式：</p>\n<pre class=\"code-rows\"><code>USER USERNAME</code></pre>\n<p>命令举例：</p>\n<pre class=\"code-rows\"><code>USER user1</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><code>WORKDIR</code>用于定义工作目录。</p>\n<p>命令格式：</p>\n<pre class=\"code-rows\"><code>WORKDIR /path/to/workdir</code></pre>\n<p>它的作用是为后续的<code>RUN</code>、<code>CMD</code>或者<code>ENTRYPOINT</code>指定工作目录。</p>\n</li>\n</ul>\n<h3 id=\"nav_point_411\">22.4.4 Dockerfile实践</h3>\n<p>接下来，阿铭写一个具体的Dockerfile示例，帮你理解各个参数的含义，如下所示：</p>\n<pre class=\"code-rows\"><code># vi /root/dockerfile // 写入如下内容\n## 设置基础镜像为CentOS\nFROM centos:7\n# 设置作者\nMAINTAINER aming aming@aminglinux.com\n# 安装必要工具\nRUN yum install -y pcre-devel wget net-tools gcc zlib zlib-devel make openssl-devel\n# 安装Nginx\nADD http://nginx.org/download/nginx-1.8.0.tar.gz .\nRUN tar zxvf nginx-1.8.0.tar.gz\nRUN mkdir -p /usr/local/nginx\nRUN cd nginx-1.8.0 &amp;&amp; ./configure --prefix=/usr/local/nginx &amp;&amp; make &amp;&amp; make install\nRUN rm -fv /usr/local/nginx/conf/nginx.conf\nADD http://www.apelearn.com/study_v2/.nginx_conf /usr/local/nginx/conf/nginx.conf\n# 映射端口\nEXPOSE 80\n# 设置挂载点\nVOLUME [\"/usr/local/nginx/html\"]\n# 设置容器启动时要执行的指令\nENTRYPOINT /usr/local/nginx/sbin/nginx &amp;&amp; tail -f /usr/local/nginx/logs/nginx_error.log</code></pre>\n<p>保存该文件后，执行如下命令进行编译：</p>\n<pre class=\"code-rows\"><code># docker build –f /root/dockerfile -t centos7_nginx:0.1 .</code></pre>\n<p>其中，<code>build</code>命令用来编译Dockerfile，<code>-f</code>指定要编译的Dockerfile，注意名字和路径都可以自定义。<code>-t</code>指定生成的镜像名字和TAG，后面还有个<code>.</code>表示在当前目录下来做这个事情。因为Dockerfile里有可能会添加一些文件到镜像里，所以它会到这里的<code>.</code>（也就是当前目录下）寻找指定文件。这个过程比较慢，而且输出的内容太多，所以阿铭就不再展示了，等它编译完成后，要记得使用<code>echo $?</code>看看是否是0（0说明没问题），否则就有问题。如果是0，接着检查生成的镜像：</p>\n<pre class=\"code-rows\"><code># docker images |grep centos7_nginx\ncentos7_nginx 0.1 b266018e6298 58 seconds ago 356MB</code></pre>\n<p>然后使用该镜像运行容器：</p>\n<pre class=\"code-rows\"><code># docker run -itd --name aming123 centos7_nginx:0.1 bash\na01a5885888f23299a93c7917b77d7a2dd08c0f0ea409daef390d59c4e532ef8\n# docker exec -it aming123 bash\n# ps aux |grep nginx // 在容器内查看nginx进程\nroot 1 0.0 0.1 11700 2592 pts/0 Ss+ 15:06 0:00 /bin/sh -c /usr/local/nginx/sbin/nginx &amp;&amp; tail -f /usr/local/nginx/logs/nginx_error.log bash\nroot 7 0.0 0.0 24904 572 ? Ss 15:06 0:00 nginx: master process /usr/local/nginx/sbin/nginx\nroot 8 0.0 0.0 4412 732 pts/0 S+ 15:06 0:00 tail -f /usr/local/nginx/logs/nginx_error.log\nnobody 9 0.0 0.2 27348 4796 ? S 15:06 0:00 nginx: worker process\nnobody 10 0.0 0.2 27348 4796 ? S 15:06 0:00 nginx: worker process\nroot 28 0.0 0.0 9104 872 pts/1 S+ 15:07 0:00 grep --color=auto nginx</code></pre>\n<p>在Dockerfile中阿铭有定义<code>VOLUME</code>，其实它映射到了宿主机的/var/lib/docker/volumes/下的某个目录，具体可以通过<code>docker inspect aming123</code>查看：</p>\n<pre class=\"code-rows\"><code># docker inspect aming123 |grep -A10 'Mounts'\n \"Mounts\": [\n {\n \"Type\": \"volume\",\n \"Name\": \"d7b1915410f51bdcd78e855c06230600fd622be420939277dedeaf694601c680\",\n \"Source\": \"/var/lib/docker/volumes/\n d7b1915410f51bdcd78e855c06230600fd622be420939277dedeaf694601c680/_data\",\n \"Destination\": \"/usr/local/nginx/html\",\n \"Driver\": \"local\",\n \"Mode\": \"\",\n \"RW\": true,\n \"Propagation\": \"\"\n }</code></pre>\n<p>这里的<code>Source</code>对应的目录就是宿主机上映射的目录。</p>\n<h2 id=\"nav_point_412\">22.5 Docker私人仓库</h2>\n<p>使用<code>docker images</code>命令查看到的所有镜像都存储在本机磁盘里，如果想把其中某个镜像给其他机器使用，还得先导出镜像，然后将其传到其他机器上，这样十分不方便。那有没有比较好的方式来专门存储镜像，使之可以供所有机器使用呢？当然有，下面阿铭介绍一个业界使用非常多的私人镜像仓库工具harbor。</p>\n<h3 id=\"nav_point_413\">22.5.1 部署harbor前的准备工作</h3>\n<p>1) 购买一个自己的域名。阿铭在这里推荐购买.xyz的域名，因为.xyz的域名比较便宜，你可以到新网、dnspod、阿里云等网站购买。</p>\n<p>2) 申请一个免费的SSL证书。阿铭推荐的网站为freessl.cn，首先注册一个账号，然后填写自己刚刚注册的域名，比如harbor.aminglinux.xyz，单击右侧的创建免费的SSL证书。具体操作步骤阿铭不在这里展开了，最终需要获得两个文件：.crt和.key后缀的文件。</p>\n<h3 id=\"nav_point_414\">22.5.2 部署harbor</h3>\n<p>1) 下载docker-compose</p>\n<p>docker-compose是一个Docker容器编排工具，它可以轻松地将多个容器一键启动或停止。我们使用的harbor其实就是由多个容器组成的一个容器组，所以使用docker-compose去管理非常方便。下面的命令会下载docker-compose文件，并将其保存到/usr/local/bin/下面：</p>\n<pre class=\"code-rows\"><code># curl -L https://github.com/docker/compose/releases/1.26.2/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</code></pre>\n<p>由于我们的系统为CentOS 8，所以需要选择docker-compose-Linux-x86_64，然后给它赋予可执行权限：</p>\n<pre class=\"code-rows\"><code># chmod a+x /usr/local/bin/docker-compose\n# docker-compose -v\ndocker-compose version 1.26.2, build eefe0d31</code></pre>\n<p>如果你的执行结果不显示其版本，则说明你的系统某处有问题。</p>\n<p>2) 下载harbor离线包</p>\n<p>阿铭在写本书时，harbor的最新版本为1.10.4，所以这就是阿铭下载的版本。和docker-compose一样，harbor的下载速度简直慢如蜗牛，所以阿铭把已经下载好的文件保存在百度云盘，如果你不觉得版本老，就使用阿铭（微信81677956）提供的软件包吧。</p>\n<p>3) 安装和配置harbor</p>\n<p>首先，将刚下载的离线包解压到 /opt下：</p>\n<pre class=\"code-rows\"><code># tar zxf harbor-offline-installer-v1.10.4.tgz -C /opt/\n# cd /opt/harbor\n# vim harbor.yml // 做如下更改\nhostname: harbor.aminglinux.cc // 这里填写你自己的域名，注意要和你申请的SSL证书一致\ncertificate: /etc/harbor.aminglinux.cc_chain.crt // 这为申请的SSL证书中的crt文件\nprivate_key: /etc/harbor.aminglinux.cc_key.key // 这为申请的SSL证书中的key文件\nharbor_admin_password: Harbor-12345 // 定义管理员密码</code></pre>\n<p>更改完配置文件后，保存该文件，然后开始安装：</p>\n<pre class=\"code-rows\"><code># sh install.sh</code></pre>\n<p>整个过程会持续大约1分钟左右，如果成功，则会看到提示：<code>----Harbor has been installed and started successfully.----</code>。在安装过程中，你可以看到它安装了好多镜像，这些都是harbor服务所用到的，我们还可以使用<code>docker-compose</code>命令查看所有容器的状态，如下所示：</p>\n<pre class=\"code-rows\"><code># docker-compose -f /opt/harbor/docker-compose.yml ps\n Name Command State Ports\n--------------------------------------------------------------------------------------------------\nharbor-core /harbor/harbor_core Up (healthy)\nharbor-db /docker-entrypoint.sh Up (healthy) 5432/tcp\nharbor-jobservice /harbor/harbor_jobservice ... Up (healthy)\nharbor-log /bin/sh -c /usr/local/bin/ ... Up (healthy) 127.0.0.1:1514-&gt;10514/tcp\nharbor-portal nginx -g daemon off; Up (healthy) 8080/tcp\nnginx nginx -g daemon off; Up (healthy) 0.0.0.0:80-&gt;8080/tcp,\n 0.0.0.0:443-&gt;8443/tcp\nredis redis-server /etc/redis.conf Up (healthy) 6379/tcp\nregistry /home/harbor/entrypoint.sh Up (healthy) 5000/tcp\nregistryctl /home/harbor/start.sh Up (healthy)</code></pre>\n<p>可以看到，总共有9个容器，映射的端口有10514、8080以及8443。记得把在配置文件中配置的域名做一下解析，然后就可以通过浏览器访问harbor了，用户名为admin，密码为Harbor-12345。</p>\n<h3 id=\"nav_point_415\">22.5.3 使用harbor</h3>\n<p>登录harbor后，可以看到左侧有项目、日志、系统管理等功能。要想把镜像存储到harbor，还得做一些准备工作。</p>\n<p>1) 创建项目</p>\n<p>默认情况下，harbor有一个library项目，而生成环境中则会根据不同的使用场景创建多个项目。下面阿铭来创建一个测试的项目。单击“新建项目”，项目名称填写“aming”，其他保持默认设置，单击“确定”按钮。</p>\n<p>2) 创建用户</p>\n<p>创建用户的目的是针对不同的项目设置不同的用户和权限。具体步骤为：在左侧系统管理下面单击“用户管理”，然后单击“创建用户”，接着自定义用户名（比如user1），设置邮箱、全名、密码。要注意的是，设置的密码必须包含大小写字母和数字，并且长度在8和20之间。</p>\n<p>3) 设置项目</p>\n<p>再次单击左侧的项目，选择刚刚创建的项目“aming”，单击项目名，进入项目设置界面。单击“成员”，单击“+用户”，“姓名”这里填写“user1”，它会自动显示出user1，选中它，角色保持默认设置即可，最后单击“确定”按钮。</p>\n<p>做好以上三个准备工作后，就可以正式使用harbor了。回到Linux命令行界面，执行如下命令：</p>\n<pre class=\"code-rows\"><code># docker login https://harbor.aminglinux.cc\nUsername: user1\nPassword:\nWARNING! Your password will be stored unencrypted in /root/.docker/config.json.\nConfigure a credential helper to remove this warning. See\nhttps://docs.docker.com/engine/reference/commandline/login/#credentials-store\n\nLogin Succeeded</code></pre>\n<p>注意，必须要显示<code>Login Succeeded</code>才算正常，如果不正常，请检查域名是否解析对、SSL证书是否配置对、用户名以及密码是否输入对。上面的操作其实是在命令行下面登录harbor，后面就可以将镜像存入到harbor了。下面阿铭将busybox存入到harbor，操作步骤如下：</p>\n<pre class=\"code-rows\"><code># docker tag busybox:latest harbor.aminglinux.cc/aming/busybox:123\n# docker push harbor.aminglinux.cc/aming/busybox:123\nThe push refers to repository [harbor.aminglinux.cc/aming/busybox]\n50761fe126b6: Pushed\n123: digest: sha256:2131f09e4044327fd101ca1fd4043e6f3ad921ae7ee901e9142e6e36b354a907 size: 527</code></pre>\n<p>这样就可以将busybox镜像推送到harbor了，再到浏览器查看aming项目，依次单击项目→aming→镜像仓库，就可以看到刚刚上传的aming/busybox了，再单击进去会发现里面有个123。</p>\n<p>私有镜像仓库搭建完，这样企业中内网所有的Docker服务器就都可以将镜像上传到该harbor服务器了。当然，也可以使用如下命令轻松下载：</p>\n<pre class=\"code-rows\"><code># docker pull harbor.aminglinux.cc/aming/busybox:123</code></pre>\n<p>可以正常拉取下来的前提是，首先要运行<code>docker login https://harbor.aminglinux.cc</code>。</p>\n\n<br style=\"page-break-after:always\" />","comments":[]}