{"id":41913,"title":"12 | 排序（下）：如何用快排思想在O(n)内查找第K大元素？","content":"<p>上一节我讲了冒泡排序、插入排序、选择排序这三种排序算法，它们的时间复杂度都是O(n<sup>2</sup>)，比较高，适合小规模数据的排序。今天，我讲两种时间复杂度为O(nlogn)的排序算法，<strong>归并排序</strong>和<strong>快速排序</strong>。这两种排序算法适合大规模的数据排序，比上一节讲的那三种排序算法要更常用。</p><p>归并排序和快速排序都用到了分治思想，非常巧妙。我们可以借鉴这个思想，来解决非排序的问题，比如：<strong><span class=\"orange\">如何在O(n)的时间复杂度内查找一个无序数组中的第K大元素？</span></strong> 这就要用到我们今天要讲的内容。</p><h2>归并排序的原理</h2><p>我们先来看<strong>归并排序</strong>（Merge Sort）。</p><p>归并排序的核心思想还是蛮简单的。如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p><p><img src=\"https://static001.geekbang.org/resource/image/db/2b/db7f892d3355ef74da9cd64aa926dc2b.jpg?wh=1142*914\" alt=\"\"></p><p>归并排序使用的就是<strong>分治思想</strong>。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。</p><p>从我刚才的描述，你有没有感觉到，分治思想跟我们前面讲的递归思想很像。是的，分治算法一般都是用递归来实现的。<strong>分治是一种解决问题的处理思想，递归是一种编程技巧</strong>，这两者并不冲突。分治算法的思想我后面会有专门的一节来讲，现在不展开讨论，我们今天的重点还是排序算法。</p><!-- [[[read_end]]] --><p>前面我通过举例让你对归并有了一个感性的认识，又告诉你，归并排序用的是分治思想，可以用递归来实现。我们现在就来看看<strong>如何用递归代码来实现归并排序</strong>。</p><p>我在<a href=\"https://time.geekbang.org/column/article/41440\">第10节</a>讲的递归代码的编写技巧你还记得吗？写递归代码的技巧就是，分析得出递推公式，然后找到终止条件，最后将递推公式翻译成递归代码。所以，要想写出归并排序的代码，我们先写出归并排序的递推公式。</p><pre><code>递推公式：\nmerge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))\n\n终止条件：\np &gt;= r 不用再继续分解\n</code></pre><p>我来解释一下这个递推公式。</p><p>merge_sort(p…r)表示，给下标从p到r之间的数组排序。我们将这个排序问题转化为了两个子问题，merge_sort(p…q)和merge_sort(q+1…r)，其中下标q等于p和r的中间位置，也就是(p+r)/2。当下标从p到q和从q+1到r这两个子数组都排好序之后，我们再将两个有序的子数组合并在一起，这样下标从p到r之间的数据就也排好序了。</p><p>有了递推公式，转化成代码就简单多了。为了阅读方便，我这里只给出伪代码，你可以翻译成你熟悉的编程语言。</p><pre><code>// 归并排序算法, A是数组，n表示数组大小\nmerge_sort(A, n) {\n  merge_sort_c(A, 0, n-1)\n}\n\n// 递归调用函数\nmerge_sort_c(A, p, r) {\n  // 递归终止条件\n  if p &gt;= r  then return\n\n  // 取p到r之间的中间位置q\n  q = (p+r) / 2\n  // 分治递归\n  merge_sort_c(A, p, q)\n  merge_sort_c(A, q+1, r)\n  // 将A[p...q]和A[q+1...r]合并为A[p...r]\n  merge(A[p...r], A[p...q], A[q+1...r])\n}\n</code></pre><p>你可能已经发现了，merge(A[p...r], A[p...q], A[q+1...r])这个函数的作用就是，将已经有序的A[p...q]和A[q+1....r]合并成一个有序的数组，并且放入A[p....r]。那这个过程具体该如何做呢？</p><p>如图所示，我们申请一个临时数组tmp，大小与A[p...r]相同。我们用两个游标i和j，分别指向A[p...q]和A[q+1...r]的第一个元素。比较这两个元素A[i]和A[j]，如果A[i]&lt;=A[j]，我们就把A[i]放入到临时数组tmp，并且i后移一位，否则将A[j]放入到数组tmp，j后移一位。</p><p>继续上述比较过程，直到其中一个子数组中的所有数据都放入临时数组中，再把另一个数组中的数据依次加入到临时数组的末尾，这个时候，临时数组中存储的就是两个子数组合并之后的结果了。最后再把临时数组tmp中的数据拷贝到原数组A[p...r]中。</p><p><img src=\"https://static001.geekbang.org/resource/image/95/2f/95897ade4f7ad5d10af057b1d144a22f.jpg?wh=1142*856\" alt=\"\"></p><p>我们把merge()函数写成伪代码，就是下面这样：</p><pre><code>merge(A[p...r], A[p...q], A[q+1...r]) {\n  var i := p，j := q+1，k := 0 // 初始化变量i, j, k\n  var tmp := new array[0...r-p] // 申请一个大小跟A[p...r]一样的临时数组\n  while i&lt;=q AND j&lt;=r do {\n    if A[i] &lt;= A[j] {\n      tmp[k++] = A[i++] // i++等于i:=i+1\n    } else {\n      tmp[k++] = A[j++]\n    }\n  }\n  \n  // 判断哪个子数组中有剩余的数据\n  var start := i，end := q\n  if j&lt;=r then start := j, end:=r\n  \n  // 将剩余的数据拷贝到临时数组tmp\n  while start &lt;= end do {\n    tmp[k++] = A[start++]\n  }\n  \n  // 将tmp中的数组拷贝回A[p...r]\n  for i:=0 to r-p do {\n    A[p+i] = tmp[i]\n  }\n}\n</code></pre><p>你还记得<a href=\"https://time.geekbang.org/column/article/41149\">第7讲</a>讲过的利用哨兵简化编程的处理技巧吗？merge()合并函数如果借助哨兵，代码就会简洁很多，这个问题留给你思考。</p><h2>归并排序的性能分析</h2><p>这样跟着我一步一步分析，归并排序是不是没那么难啦？还记得上节课我们分析排序算法的三个问题吗？接下来，我们来看归并排序的三个问题。</p><p><strong>第一，归并排序是<strong><strong>稳定</strong></strong>的排序算法吗？</strong></p><p>结合我前面画的那张图和归并排序的伪代码，你应该能发现，归并排序稳不稳定关键要看merge()函数，也就是两个有序子数组合并成一个有序数组的那部分代码。</p><p>在合并的过程中，如果A[p...q]和A[q+1...r]之间有值相同的元素，那我们可以像伪代码中那样，先把A[p...q]中的元素放入tmp数组。这样就保证了值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一个稳定的排序算法。</p><p><strong>第二，归并排序的<strong><strong>时间复杂度</strong></strong>是多少？</strong></p><p>归并排序涉及递归，时间复杂度的分析稍微有点复杂。我们正好借此机会来学习一下，如何分析递归代码的时间复杂度。</p><p>在递归那一节我们讲过，递归的适用场景是，一个问题a可以分解为多个子问题b、c，那求解问题a就可以分解为求解问题b、c。问题b、c解决之后，我们再把b、c的结果合并成a的结果。</p><p>如果我们定义求解问题a的时间是T(a)，求解问题b、c的时间分别是T(b)和 T( c)，那我们就可以得到这样的递推关系式：</p><pre><code>T(a) = T(b) + T(c) + K\n</code></pre><p>其中K等于将两个子问题b、c的结果合并成问题a的结果所消耗的时间。</p><p>从刚刚的分析，我们可以得到一个重要的结论：<strong>不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。</strong></p><p>套用这个公式，我们来分析一下归并排序的时间复杂度。</p><p>我们假设对n个元素进行归并排序需要的时间是T(n)，那分解成两个子数组排序的时间都是T(n/2)。我们知道，merge()函数合并两个有序子数组的时间复杂度是O(n)。所以，套用前面的公式，归并排序的时间复杂度的计算公式就是：</p><pre><code>T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。\nT(n) = 2*T(n/2) + n； n&gt;1\n</code></pre><p>通过这个公式，如何来求解T(n)呢？还不够直观？那我们再进一步分解一下计算过程。</p><pre><code>T(n) = 2*T(n/2) + n\n     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n\n     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n\n     = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n\n     ......\n     = 2^k * T(n/2^k) + k * n\n     ......\n</code></pre><p>通过这样一步一步分解推导，我们可以得到T(n) = 2^k<em>T(n/2^k)+k</em>n。当T(n/2^k)=T(1)时，也就是n/2^k=1，我们得到k=log<sub>2</sub>n 。我们将k值代入上面的公式，得到T(n)=C<em>n+n</em>log<sub>2</sub>n 。如果我们用大O标记法来表示的话，T(n)就等于O(nlogn)。所以归并排序的时间复杂度是O(nlogn)。</p><p>从我们的原理分析和伪代码可以看出，归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是O(nlogn)。</p><p><strong>第三，归并排序的<strong><strong>空间复杂度</strong></strong>是多少？</strong></p><p>归并排序的时间复杂度任何情况下都是O(nlogn)，看起来非常优秀。（待会儿你会发现，即便是快速排序，最坏情况下，时间复杂度也是O(n<sup>2</sup>)。）但是，归并排序并没有像快排那样，应用广泛，这是为什么呢？因为它有一个致命的“弱点”，那就是归并排序不是原地排序算法。</p><p>这是因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。这一点你应该很容易理解。那我现在问你，归并排序的空间复杂度到底是多少呢？是O(n)，还是O(nlogn)，应该如何分析呢？</p><p>如果我们继续按照分析递归时间复杂度的方法，通过递推公式来求解，那整个归并过程需要的空间复杂度就是O(nlogn)。不过，类似分析时间复杂度那样来分析空间复杂度，这个思路对吗？</p><p>实际上，递归代码的空间复杂度并不能像时间复杂度那样累加。刚刚我们忘记了最重要的一点，那就是，尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过n个数据的大小，所以空间复杂度是O(n)。</p><h2>快速排序的原理</h2><p>我们再来看快速排序算法（Quicksort），我们习惯性把它简称为“快排”。快排利用的也是分治思想。乍看起来，它有点像归并排序，但是思路其实完全不一样。我们待会会讲两者的区别。现在，我们先来看下快排的核心思想。</p><p>快排的思想是这样的：如果要排序数组中下标从p到r之间的一组数据，我们选择p到r之间的任意一个数据作为pivot（分区点）。</p><p>我们遍历p到r之间的数据，将小于pivot的放到左边，将大于pivot的放到右边，将pivot放到中间。经过这一步骤之后，数组p到r之间的数据就被分成了三个部分，前面p到q-1之间都是小于pivot的，中间是pivot，后面的q+1到r之间是大于pivot的。</p><p><img src=\"https://static001.geekbang.org/resource/image/4d/81/4d892c3a2e08a17f16097d07ea088a81.jpg?wh=1142*615\" alt=\"\"></p><p>根据分治、递归的处理思想，我们可以用递归排序下标从p到q-1之间的数据和下标从q+1到r之间的数据，直到区间缩小为1，就说明所有的数据都有序了。</p><p>如果我们用递推公式来将上面的过程写出来的话，就是这样：</p><pre><code>递推公式：\nquick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)\n\n终止条件：\np &gt;= r\n</code></pre><p>我将递推公式转化成递归代码。跟归并排序一样，我还是用伪代码来实现，你可以翻译成你熟悉的任何语言。</p><pre><code>// 快速排序，A是数组，n表示数组的大小\nquick_sort(A, n) {\n  quick_sort_c(A, 0, n-1)\n}\n// 快速排序递归函数，p,r为下标\nquick_sort_c(A, p, r) {\n  if p &gt;= r then return\n  \n  q = partition(A, p, r) // 获取分区点\n  quick_sort_c(A, p, q-1)\n  quick_sort_c(A, q+1, r)\n}\n</code></pre><p>归并排序中有一个merge()合并函数，我们这里有一个partition()分区函数。partition()分区函数实际上我们前面已经讲过了，就是随机选择一个元素作为pivot（一般情况下，可以选择p到r区间的最后一个元素），然后对A[p...r]分区，函数返回pivot的下标。</p><p>如果我们不考虑空间消耗的话，partition()分区函数可以写得非常简单。我们申请两个临时数组X和Y，遍历A[p...r]，将小于pivot的元素都拷贝到临时数组X，将大于pivot的元素都拷贝到临时数组Y，最后再将数组X和数组Y中数据顺序拷贝到A[p....r]。</p><p><img src=\"https://static001.geekbang.org/resource/image/66/dc/6643bc3cef766f5b3e4526c332c60adc.jpg?wh=1142*796\" alt=\"\"></p><p>但是，如果按照这种思路实现的话，partition()函数就需要很多额外的内存空间，所以快排就不是原地排序算法了。如果我们希望快排是原地排序算法，那它的空间复杂度得是O(1)，那partition()分区函数就不能占用太多额外的内存空间，我们就需要在A[p...r]的原地完成分区操作。</p><p>原地分区函数的实现思路非常巧妙，我写成了伪代码，我们一起来看一下。</p><pre><code>partition(A, p, r) {\n  pivot := A[r]\n  i := p\n  for j := p to r-1 do {\n    if A[j] &lt; pivot {\n      swap A[i] with A[j]\n      i := i+1\n    }\n  }\n  swap A[i] with A[r]\n  return i\n\n</code></pre><p>这里的处理有点类似选择排序。我们通过游标i把A[p...r-1]分成两部分。A[p...i-1]的元素都是小于pivot的，我们暂且叫它“已处理区间”，A[i...r-1]是“未处理区间”。我们每次都从未处理的区间A[i...r-1]中取一个元素A[j]，与pivot对比，如果小于pivot，则将其加入到已处理区间的尾部，也就是A[i]的位置。</p><p>数组的插入操作还记得吗？在数组某个位置插入元素，需要搬移数据，非常耗时。当时我们也讲了一种处理技巧，就是交换，在O(1)的时间复杂度内完成插入操作。这里我们也借助这个思想，只需要将A[i]与A[j]交换，就可以在O(1)时间复杂度内将A[j]放到下标为i的位置。</p><p>文字不如图直观，所以我画了一张图来展示分区的整个过程。</p><p><img src=\"https://static001.geekbang.org/resource/image/08/e7/086002d67995e4769473b3f50dd96de7.jpg?wh=1142*859\" alt=\"\"></p><p>因为分区的过程涉及交换操作，如果数组中有两个相同的元素，比如序列6，8，7，6，3，5，9，4，在经过第一次分区操作之后，两个6的相对先后顺序就会改变。所以，快速排序并不是一个稳定的排序算法。</p><p>到此，快速排序的原理你应该也掌握了。现在，我再来看另外一个问题：快排和归并用的都是分治思想，递推公式和递归代码也非常相似，那它们的区别在哪里呢？</p><p><img src=\"https://static001.geekbang.org/resource/image/aa/05/aa03ae570dace416127c9ccf9db8ac05.jpg?wh=1142*757\" alt=\"\"></p><p>可以发现，归并排序的处理过程是<strong>由下到上</strong>的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是<strong>由上到下</strong>的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为O(nlogn)的排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</p><h2>快速排序的性能分析</h2><p>现在，我们来分析一下快速排序的性能。我在讲解快排的实现原理的时候，已经分析了稳定性和空间复杂度。快排是一种原地、不稳定的排序算法。现在，我们集中精力来看快排的时间复杂度。</p><p>快排也是用递归来实现的。对于递归代码的时间复杂度，我前面总结的公式，这里也还是适用的。如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并是相同的。所以，快排的时间复杂度也是O(nlogn)。</p><pre><code>T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。\nT(n) = 2*T(n/2) + n； n&gt;1\n</code></pre><p>但是，公式成立的前提是每次分区操作，我们选择的pivot都很合适，正好能将大区间对等地一分为二。但实际上这种情况是很难实现的。</p><p>我举一个比较极端的例子。如果数组中的数据原来已经是有序的了，比如1，3，5，6，8。如果我们每次选择最后一个元素作为pivot，那每次分区得到的两个区间都是不均等的。我们需要进行大约n次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约n/2个元素，这种情况下，快排的时间复杂度就从O(nlogn)退化成了O(n<sup>2</sup>)。</p><p>我们刚刚讲了两个极端情况下的时间复杂度，一个是分区极其均衡，一个是分区极其不均衡。它们分别对应快排的最好情况时间复杂度和最坏情况时间复杂度。那快排的平均情况时间复杂度是多少呢？</p><p>我们假设每次分区操作都将区间分成大小为9:1的两个小区间。我们继续套用递归时间复杂度的递推公式，就会变成这样：</p><pre><code>T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。\n\nT(n) = T(n/10) + T(9*n/10) + n； n&gt;1\n</code></pre><p>这个公式的递推求解的过程非常复杂，虽然可以求解，但我不推荐用这种方法。实际上，递归的时间复杂度的求解方法除了递推公式之外，还有递归树，在树那一节我再讲，这里暂时不说。我这里直接给你结论：T(n)在大部分情况下的时间复杂度都可以做到O(nlogn)，只有在极端情况下，才会退化到O(n<sup>2</sup>)。而且，我们也有很多方法将这个概率降到很低，如何来做？我们后面章节再讲。</p><h2>解答开篇</h2><p>快排核心思想就是<strong>分治</strong>和<strong>分区</strong>，我们可以利用分区的思想，来解答开篇的问题：O(n)时间复杂度内求无序数组中的第K大元素。比如，4， 2， 5， 12， 3这样一组数据，第3大元素就是4。</p><p>我们选择数组区间A[0...n-1]的最后一个元素A[n-1]作为pivot，对数组A[0...n-1]原地分区，这样数组就分成了三部分，A[0...p-1]、A[p]、A[p+1...n-1]。</p><p>如果p+1=K，那A[p]就是要求解的元素；如果K&gt;p+1, 说明第K大元素出现在A[p+1...n-1]区间，我们再按照上面的思路递归地在A[p+1...n-1]这个区间内查找。同理，如果K&lt;p+1，那我们就在A[0...p-1]区间查找。</p><p><img src=\"https://static001.geekbang.org/resource/image/89/91/898d94fc32e0a795fd65897293b98791.jpg?wh=1142*367\" alt=\"\"></p><p>我们再来看，为什么上述解决思路的时间复杂度是O(n)？</p><p>第一次分区查找，我们需要对大小为n的数组执行分区操作，需要遍历n个元素。第二次分区查找，我们只需要对大小为n/2的数组执行分区操作，需要遍历n/2个元素。依次类推，分区遍历元素的个数分别为、n/2、n/4、n/8、n/16.……直到区间缩小为1。</p><p>如果我们把每次分区遍历的元素个数加起来，就是：n+n/2+n/4+n/8+...+1。这是一个等比数列求和，最后的和等于2n-1。所以，上述解决思路的时间复杂度就为O(n)。</p><p>你可能会说，我有个很笨的办法，每次取数组中的最小值，将其移动到数组的最前面，然后在剩下的数组中继续找最小值，以此类推，执行K次，找到的数据不就是第K大元素了吗？</p><p>不过，时间复杂度就并不是O(n)了，而是O(K * n)。你可能会说，时间复杂度前面的系数不是可以忽略吗？O(K * n)不就等于O(n)吗？</p><p>这个可不能这么简单地划等号。当K是比较小的常量时，比如1、2，那最好时间复杂度确实是O(n)；但当K等于n/2或者n时，这种最坏情况下的时间复杂度就是O(n<sup>2</sup>)了。</p><h2>内容小结</h2><p>归并排序和快速排序是两种稍微复杂的排序算法，它们用的都是分治的思想，代码都通过递归来实现，过程非常相似。理解归并排序的重点是理解递推公式和merge()合并函数。同理，理解快排的重点也是理解递推公式，还有partition()分区函数。</p><p>归并排序算法是一种在任何情况下时间复杂度都比较稳定的排序算法，这也使它存在致命的缺点，即归并排序不是原地排序算法，空间复杂度比较高，是O(n)。正因为此，它也没有快排应用广泛。</p><p>快速排序算法虽然最坏情况下的时间复杂度是O(n<sup>2</sup>)，但是平均情况下时间复杂度都是O(nlogn)。不仅如此，快速排序算法时间复杂度退化到O(n<sup>2</sup>)的概率非常小，我们可以通过合理地选择pivot来避免这种情况。</p><h2>课后思考</h2><p>现在你有10个接口访问日志文件，每个日志文件大小约300MB，每个文件里的日志都是按照时间戳从小到大排序的。你希望将这10个较小的日志文件，合并为1个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有1GB，你有什么好的解决思路，能“快速”地将这10个日志文件合并吗？</p><p>欢迎留言和我分享，我会第一时间给你反馈。</p><hr><p><span class=\"orange\">我已将本节内容相关的详细代码更新到GitHub，<a href=\"https://github.com/wangzheng0822/algo\">戳此</a>即可查看。</span></p>","comments":[{"had_liked":false,"id":32897,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":true,"comment_ctime":1539732942,"is_pvip":true,"discussion_count":11,"race_medal":0,"score":"9.2233733612443996e+18","product_id":100017301,"comment_content":"每次从各个文件中取一条数据，在内存中根据数据时间戳构建一个最小堆，然后每次把最小值给写入新文件，同时将最小值来自的那个文件再出来一个数据，加入到最小堆中。这个空间复杂度为常数，但没能很好利用1g内存，而且磁盘单个读取比较慢，所以考虑每次读取一批数据，没了再从磁盘中取，时间复杂度还是一样O(n)。","like_count":309,"discussions":[{"author":{"id":1484184,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","nickname":"djfhchdh","note":"","ucode":"E71D75328CE398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2705,"discussion_content":"每次只读取一条数据，而且磁盘I/O会是瓶颈，没有充分利用内存的性能，应该不是“快速”的解决方案","likes_number":15,"is_delete":false,"is_hidden":false,"ctime":1563872181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2068721,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/90/f1/7f2b5e16.jpg","nickname":"CHN-Lee-玉米","note":"","ucode":"0A53080F38F229","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299191,"discussion_content":"本科腾讯面试问了个差不多的问题😂","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1597589801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1962297,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/f1/39/b0960780.jpg","nickname":"恶魔果实","note":"","ucode":"691CD833C984AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2068721,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/90/f1/7f2b5e16.jpg","nickname":"CHN-Lee-玉米","note":"","ucode":"0A53080F38F229","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302645,"discussion_content":"今天我也是被问到一个一个类似问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598978015,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":299191,"ip_address":""},"score":302645,"extra":""},{"author":{"id":1292087,"avatar":"https://static001.geekbang.org/account/avatar/00/13/b7/37/0290ff6e.jpg","nickname":"Veitor","note":"","ucode":"3397AC6D239195","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1962297,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/f1/39/b0960780.jpg","nickname":"恶魔果实","note":"","ucode":"691CD833C984AC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311612,"discussion_content":"啥厂啊？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602420720,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":302645,"ip_address":""},"score":311612,"extra":""}]},{"author":{"id":1339586,"avatar":"https://static001.geekbang.org/account/avatar/00/14/70/c2/0df5cc71.jpg","nickname":"Melon","note":"","ucode":"8E4A96B3BA0239","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374151,"discussion_content":"真实时间复杂度为O(nlog10)，log10为常量，即O(n)。每次堆排序重新生成堆顶元素时间复杂度为log10。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1621043390,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2223198,"avatar":"","nickname":"Geek_1d3fdc","note":"","ucode":"A9E79B272B3608","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312190,"discussion_content":"跟这节课的算法没啥关系呢","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1602604219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2304883,"avatar":"","nickname":"BBoss","note":"","ucode":"E48E96AFA8272A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2223198,"avatar":"","nickname":"Geek_1d3fdc","note":"","ucode":"A9E79B272B3608","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546601,"discussion_content":"多路归并","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1642346227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312190,"ip_address":""},"score":546601,"extra":""}]},{"author":{"id":1755477,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/c9/55/0e627a31.jpg","nickname":"菽绣","note":"","ucode":"60955E14C39C6B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383670,"discussion_content":"可以把10个日志文件的最小时间统计出来，排个序，那就可以先一直读最小时间最小的那个文件，直到达到了第二个日志文件的最小时间，再开始对两个日志文件的数据进行排序","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626184938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1755477,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/c9/55/0e627a31.jpg","nickname":"菽绣","note":"","ucode":"60955E14C39C6B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383667,"discussion_content":"就10个文件，用最小堆时间复杂度比用数组也好不了多少","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626184678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1923875,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/5b/23/a1bb7ef9.jpg","nickname":"danielwpz","note":"","ucode":"9B926555DD6726","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":257303,"discussion_content":"如果维护一个大小为1G的最小堆呢？第一次建堆用每个文件各100mb的内容。之后每从堆中取出10个元素之后 再同时从10个文件里面再拿10个出来，直到10个文件依次被读空","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588557571,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1619882,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b7/aa/6427f4d8.jpg","nickname":"wlarein","note":"","ucode":"81A6B217700403","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1923875,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/5b/23/a1bb7ef9.jpg","nickname":"danielwpz","note":"","ucode":"9B926555DD6726","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299303,"discussion_content":"这种情况应该是不一定行的，跟数据多少有关系。我觉得在堆前加10个队列缓存就很好，选择使用的最小堆就选一个内存占用很小的，一出现队列为空就再去读100mb","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1597650588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":257303,"ip_address":""},"score":299303,"extra":""}]}]},{"had_liked":false,"id":33273,"user_name":"Light Lin","can_delete":false,"product_type":"c1","uid":1234625,"ip_address":"","ucode":"C0AA9AA608F395","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/c1/aa9cde77.jpg","comment_is_top":false,"comment_ctime":1539769908,"is_pvip":false,"replies":[{"id":"12021","content":"那我以后还是写代码吧","user_name":"作者回复","comment_id":33273,"uid":"1190123","ip_address":"","utype":1,"ctime":1539774468,"user_name_real":"gg"}],"discussion_count":22,"race_medal":0,"score":"2376656684596","product_id":100017301,"comment_content":"伪代码反而看得费劲，可能还是对代码不够敏感吧","like_count":554,"discussions":[{"author":{"id":1923875,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/5b/23/a1bb7ef9.jpg","nickname":"danielwpz","note":"","ucode":"9B926555DD6726","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":257306,"discussion_content":"个人觉得伪码更好一点 算法本来就是学的思路 伪码屏蔽了不同语言的差异和细节 追求的就是把思路呈现给你 非常符合这个课程的定位","likes_number":24,"is_delete":false,"is_hidden":false,"ctime":1588557928,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1990300,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/5e/9c/0efcc194.jpg","nickname":"小苏","note":"","ucode":"CC2ADE51598AF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1923875,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/5b/23/a1bb7ef9.jpg","nickname":"danielwpz","note":"","ucode":"9B926555DD6726","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359135,"discussion_content":"赞同！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1616120186,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":257306,"ip_address":""},"score":359135,"extra":""}]},{"author":{"id":1245935,"avatar":"https://static001.geekbang.org/account/avatar/00/13/02/ef/17a2f2ed.jpg","nickname":"JonasGao","note":"","ucode":"2AB1155863DE2C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311461,"discussion_content":"我支持伪代码，如@frame_0224 所说“伪代码倒是能够强迫自己动手实现它，反而理解更深”，我表示非常认同。刚开始快排的伪代码我看不懂。照着伪代码写了一遍，就懂了。而且自己动手，记忆更深","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1602343381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1547322,"avatar":"https://static001.geekbang.org/account/avatar/00/17/9c/3a/bfd73920.jpg","nickname":"junjun","note":"","ucode":"1F7EE146B9BE04","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":18147,"discussion_content":"伪代码多好啊，如果用代码，还得看相关的语法，","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1569026941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2019799,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Rccaya3zw31Pxu1fRSiakKxjn7gBcXTyy7YE4BHVsGczceABMnKBRicrnxUlcptrOArQdj4hOP8AjRekrDvBx7KQ/132","nickname":"万政","note":"","ucode":"E59C2C660D6582","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363662,"discussion_content":"支持伪代码+注释，这样对不同语言的人都是公平的","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1617255662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042685,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/fd/abb7bfe3.jpg","nickname":"Langzi233","note":"","ucode":"5A21AC08FC089B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4008,"discussion_content":"还是伪代码吧，不然得写几种语音呢","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1565057000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1514905,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJF2gTFBleTUJK4BNqia5Ov2yiatpmLiclxibMFmCwXvIUMicL52ajftUxlQS0SIXldUk2n9BiaOczdaqFQ/132","nickname":"frame_0224","note":"","ucode":"7692DF4EA3607A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":713,"discussion_content":"伪代码倒是能够强迫自己动手实现它，反而理解更深","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1561973084,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1079867,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7a/3b/79562df9.jpg","nickname":"静水流深","note":"","ucode":"2242CA9CB84FC9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1514905,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJF2gTFBleTUJK4BNqia5Ov2yiatpmLiclxibMFmCwXvIUMicL52ajftUxlQS0SIXldUk2n9BiaOczdaqFQ/132","nickname":"frame_0224","note":"","ucode":"7692DF4EA3607A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5365,"discussion_content":"之前就是因为伪代码看不懂严蔚敏那本所谓经典的数据结构，后来找了本详细代码的单步debug才逐渐理解了很多东西，伪代码并不是人人都能实现的","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1566205161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":713,"ip_address":""},"score":5365,"extra":""},{"author":{"id":1157945,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ab/39/e82f0da6.jpg","nickname":"交辉日月","note":"","ucode":"1975D109BA6D0A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1514905,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJF2gTFBleTUJK4BNqia5Ov2yiatpmLiclxibMFmCwXvIUMicL52ajftUxlQS0SIXldUk2n9BiaOczdaqFQ/132","nickname":"frame_0224","note":"","ucode":"7692DF4EA3607A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":134455,"discussion_content":"老师这个伪代码很像pascal语法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579016307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":713,"ip_address":""},"score":134455,"extra":""}]},{"author":{"id":1133702,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4c/86/3be94807.jpg","nickname":"angel😇txy🤓","note":"","ucode":"C0AEE0D8BAF7ED","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6513,"discussion_content":"private static void quickSortC(int[] a, int p, int r) {\n        if (p >= r) {\n            return;\n        }\n        int q = partition(a, p, r);\n        quickSortC(a, p, q - 1);\n        quickSortC(a, q + 1, r);\n    }\n    \n    public static int partition(int[] a, int start, int end) {\n        int pivot = a[end];\n        int i = start;\n        for (int j = start; j < end; j++) {\n            if (a[j] < pivot) {\n                swap(a, i, j);\n                i = i + 1;\n            }\n        }\n        swap(a, i, end);\n        return i;\n    }","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1566954318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2583025,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKj1EH5mVBlh2cCbwbLCy3zCgkTUzK4mAnmpdAEJIriaBmibibdJ642cVZjz3UUp6xkfYKKPe9Q4daUg/132","nickname":"Geek_81aeb6","note":"","ucode":"D634187DEFF081","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375302,"discussion_content":"我也很讨厌伪代码，记得大学那会儿，伪代码搞的我代码都不会写了...","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1621566875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2120392,"avatar":"","nickname":"Geek_1d751a","note":"","ucode":"BD390635A382CA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309578,"discussion_content":"伪代码建议每行加上注释，这样每行语义是明确的，即使语法不一样也没啥","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1601352848,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014096,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJyzUm3M4HMj0wXv8Pr34OhOiaFJjFMSjVKnaJoOWR9Uo1T4RBI4MYtguolJgOwb6eKsAUOq4MGlrw/132","nickname":"wend","note":"","ucode":"45EE220931FE91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40019,"discussion_content":"一开始没理解快排分区，\n看了网上java 回头再看才理解","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1572060466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426960,"discussion_content":"那我以后还是写代码吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1539774468,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":3,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1102285,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d1/cd/b1a00872.jpg","nickname":"Jacky","note":"","ucode":"790C4ADF4EE52C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349600,"discussion_content":"其实伪代码也是有规范的。。。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1613363528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1923875,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/5b/23/a1bb7ef9.jpg","nickname":"danielwpz","note":"","ucode":"9B926555DD6726","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":257309,"discussion_content":"比如如果用python那快递排序其实4行就能写完 但是其他人能看懂么？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588557972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1783342,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/36/2e/376a3551.jpg","nickname":"ano","note":"","ucode":"7DE64BDFA78550","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338599,"discussion_content":"这个伪代码太恶心了，要么写代码，要么写中文，什么时候出现了伪代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609320331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1939316,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/97/74/a933d664.jpg","nickname":"莜戏","note":"","ucode":"C3488A2BB44359","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1783342,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/36/2e/376a3551.jpg","nickname":"ano","note":"","ucode":"7DE64BDFA78550","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338881,"discussion_content":"伪代码简洁清晰，易于理解和翻译成各种具体语言，应该是最强的代码逻辑描述工具了。","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1609409188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":338599,"ip_address":""},"score":338881,"extra":""},{"author":{"id":1237315,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e1/43/7b4a11cc.jpg","nickname":"梦总被尿憋醒","note":"","ucode":"9B9C312C61CA8D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1783342,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/36/2e/376a3551.jpg","nickname":"ano","note":"","ucode":"7DE64BDFA78550","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360179,"discussion_content":"这个伪代码完全不影响你翻译成语言代码，不信你翻译运行，直接能跑。\n而且伪代码把三行swap用一行表示了，已经非常清晰明了了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616383236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":338599,"ip_address":""},"score":360179,"extra":""}]},{"author":{"id":1684311,"avatar":"https://static001.geekbang.org/account/avatar/00/19/b3/57/2d92cf9a.jpg","nickname":"姜川","note":"","ucode":"0F8A349623EAB5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":32223,"discussion_content":"感觉有疑问❓，查找K大元素那，为什么是On时间复杂度呢，感觉是排好序后在用的二分查找，快排是 nlogn, 二分是 log n,两个都不是ON呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571017979,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1480819,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/iaU7yVx9WnPfnpJBwGCCLWBy9SvkVQRMxmOBxyZTqRYFgPEEYa0pfUHAek6TNEp6SdFRwumUycSeCL7DaM6FotQ/132","nickname":"DMY","note":"","ucode":"22C16ED954FC3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1684311,"avatar":"https://static001.geekbang.org/account/avatar/00/19/b3/57/2d92cf9a.jpg","nickname":"姜川","note":"","ucode":"0F8A349623EAB5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":66569,"discussion_content":"“排好序再二分查找”，并不是这样哦。每次分区后，由于分区点q位置前的数都比nums[q]小，q位置后的数都比nums[q]大，所以当q==k－1时，已经找到第k小的数了。这时数组并没有排好序，但是对于找第k小的数，已经完成任务了。我知道文章找第k大的数，降序排数组就行。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575086194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":32223,"ip_address":""},"score":66569,"extra":""},{"author":{"id":2037714,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/17/d2/68cdbd75.jpg","nickname":"海狮","note":"","ucode":"18FDDF5841F282","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1684311,"avatar":"https://static001.geekbang.org/account/avatar/00/19/b3/57/2d92cf9a.jpg","nickname":"姜川","note":"","ucode":"0F8A349623EAB5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287196,"discussion_content":"和快排不一样，这个查找只需要考虑两个分区的其中一个，而且查找和分区都是是通过比较q和k的大小进行的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593398214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":32223,"ip_address":""},"score":287196,"extra":""}]}]},{"had_liked":false,"id":35651,"user_name":"李建辉","can_delete":false,"product_type":"c1","uid":1260109,"ip_address":"","ucode":"55999CB5FFA3B3","user_header":"https://static001.geekbang.org/account/avatar/00/13/3a/4d/a3237b34.jpg","comment_is_top":false,"comment_ctime":1540729725,"is_pvip":false,"replies":[{"id":"12704","content":"你回答的不错 思路是正确的","user_name":"作者回复","comment_id":35651,"uid":"1190123","ip_address":"","utype":1,"ctime":1540777715,"user_name_real":"gg"}],"discussion_count":57,"race_medal":0,"score":"2106074704765","product_id":100017301,"comment_content":"先构建十条io流，分别指向十个文件，每条io流读取对应文件的第一条数据，然后比较时间戳，选择出时间戳最小的那条数据，将其写入一个新的文件，然后指向该时间戳的io流读取下一行数据，然后继续刚才的操作，比较选出最小的时间戳数据，写入新文件，io流读取下一行数据，以此类推，完成文件的合并， 这种处理方式，日志文件有n个数据就要比较n次，每次比较选出一条数据来写入，时间复杂度是O（n），空间复杂度是O（1）,几乎不占用内存，这是我想出的认为最好的操作了，希望老师指出最佳的做法！！！","like_count":491,"discussions":[{"author":{"id":1211178,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7b/2a/7d8b5943.jpg","nickname":"LH","note":"","ucode":"819B9B2409E834","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72253,"discussion_content":"10个文件数据是有序的，实际就是用归并的合并思想，如果是无序的，处理起来会复杂些","likes_number":25,"is_delete":false,"is_hidden":false,"ctime":1575472685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1118074,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0f/7a/4196443e.jpg","nickname":"timor","note":"","ucode":"0D886B2137ABBC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4740,"discussion_content":"我觉得可以开辟一块内存区域保存一条一条排序的结果，等临时内存快满了，再刷新到文件里面，一条一条写起来会很慢","likes_number":15,"is_delete":false,"is_hidden":false,"ctime":1565696801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1683130,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","nickname":"乾坤瞬间","note":"","ucode":"15BDCF29CBF8EB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1118074,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0f/7a/4196443e.jpg","nickname":"timor","note":"","ucode":"0D886B2137ABBC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":43192,"discussion_content":"可以，这个类似于mapreduce中的环形缓冲区的功能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572862534,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4740,"ip_address":""},"score":43192,"extra":""}]},{"author":{"id":1031912,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/be/e8/868f1349.jpg","nickname":"zmou-d","note":"","ucode":"0364B73B308B61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312523,"discussion_content":"想法是应该对的，实操应该要考虑利用内存来降低读写文件的IO消耗，例如写的时候利用一部分内存(say, 一个500m的空间)来缓存一批写入，达到瓶颈后一次性batch写入，读的时候也可以一次性多读一些","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1602728319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1099324,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c6/3c/8ab9deb0.jpg","nickname":"@许还真","note":"","ucode":"6D754D5AE44CEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1031912,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/be/e8/868f1349.jpg","nickname":"zmou-d","note":"","ucode":"0364B73B308B61","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333577,"discussion_content":"是的 毕竟IO读取，接口读取，还有内存读取有速度差异","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607567966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312523,"ip_address":""},"score":333577,"extra":""},{"author":{"id":1645599,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/1f/49155f50.jpg","nickname":"黑暗中行走","note":"","ucode":"12FAA327ECDE72","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1031912,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/be/e8/868f1349.jpg","nickname":"zmou-d","note":"","ucode":"0364B73B308B61","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569057,"discussion_content":"也就是多跟内存交互，读写都跟内存，少跟io交互提升效率。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651304282,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312523,"ip_address":""},"score":569057,"extra":""}]},{"author":{"id":1185974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/18/b6/f3f68a39.jpg","nickname":"马建华","note":"","ucode":"928189590259AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":32120,"discussion_content":"其实是k路归并的方法","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1570989329,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1724129,"avatar":"","nickname":"晃晃","note":"","ucode":"088FF5171F90C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46083,"discussion_content":"有内存为什么不用，你个时间复杂度分析有误，没有考虑写磁盘的速度，内存里的O(N)和写磁盘的O(N)天囊之别。","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1573118056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1545647,"avatar":"https://static001.geekbang.org/account/avatar/00/17/95/af/b7f8dc43.jpg","nickname":"拓山","note":"","ucode":"11FE9CF3821898","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395474,"discussion_content":"这就是归并排序的核心思路，每次都是比较有序队列的头部数据","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1632309325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2510297,"avatar":"https://static001.geekbang.org/account/avatar/00/26/4d/d9/e3cc62f3.jpg","nickname":"生海","note":"","ucode":"1FFBB0E56CE380","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365437,"discussion_content":"老师，这种方法的时间复杂度为O（n ^ 2）吧，假如有 n 个文件需要合并，每次比较的时候需要比较 n 个 数据。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1617801076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1467219,"avatar":"https://static001.geekbang.org/account/avatar/00/16/63/53/b4590ccc.jpg","nickname":"阿文","note":"","ucode":"B53454CA52BD7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2510297,"avatar":"https://static001.geekbang.org/account/avatar/00/26/4d/d9/e3cc62f3.jpg","nickname":"生海","note":"","ucode":"1FFBB0E56CE380","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379242,"discussion_content":"n针对的是所有数据。如果n=m*k 这时间复杂读不能说多了一阶","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623767249,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":365437,"ip_address":""},"score":379242,"extra":""}]},{"author":{"id":1144132,"avatar":"https://static001.geekbang.org/account/avatar/00/11/75/44/ee170215.jpg","nickname":"Jasper","note":"","ucode":"7AEF50986C7D8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279762,"discussion_content":"时间复杂度并不是n，因为你比过一次后并没有把非最小值的那n-1个元素扔掉，它还是要跟后续读进来的元素比较的","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1591411123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2041131,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIVXIcM29fxBBzLeD7gQ2x5ibzVuMAv3huy7KHHEGa7ECAZuXXf5LtskwYhG3tEG8DNC46EYatyFyw/132","nickname":"Geek_78d179","note":"","ucode":"2AB3C45E665F86","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1144132,"avatar":"https://static001.geekbang.org/account/avatar/00/11/75/44/ee170215.jpg","nickname":"Jasper","note":"","ucode":"7AEF50986C7D8C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328660,"discussion_content":"io流已经指向下一个 了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606205839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":279762,"ip_address":""},"score":328660,"extra":""}]},{"author":{"id":1484184,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","nickname":"djfhchdh","note":"","ucode":"E71D75328CE398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2706,"discussion_content":"每次只读取一条数据，磁盘I/O会是瓶颈，没有充分利用内存的性能，应该不是“快速”的解决方案","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1563872213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2422075,"avatar":"https://static001.geekbang.org/account/avatar/00/24/f5/3b/24e5cde0.jpg","nickname":"inertia","note":"","ucode":"D758789FD01614","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":354278,"discussion_content":"你的思想就是维护一个最小堆","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1615266978,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2063923,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er4rbCWDxib3FHibYBouTwZqZBH6h5IgvjibEiaBv4Ceekib9SYg0peBBlFGu8hDuGvwjKp6LNznvEAibYw/132","nickname":"DonaldTrumpppppppppp","note":"","ucode":"211B1A25C53172","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2422075,"avatar":"https://static001.geekbang.org/account/avatar/00/24/f5/3b/24e5cde0.jpg","nickname":"inertia","note":"","ucode":"D758789FD01614","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380151,"discussion_content":"是利用插入排序思想构建的优先队列。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624358628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":354278,"ip_address":""},"score":380151,"extra":""}]},{"author":{"id":2223198,"avatar":"","nickname":"Geek_1d3fdc","note":"","ucode":"A9E79B272B3608","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312194,"discussion_content":"每次只从磁盘读写一条数据，没有用到内存，而磁盘读写远比程序执行消耗性能，所以实际操作过程是有很大问题的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1602604847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1834181,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/fc/c5/ff8b770e.jpg","nickname":"BugBean","note":"","ucode":"B51232281AD9BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271022,"discussion_content":"不懂就问，1条IO流不是要300M吗","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1590073423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":7,"child_discussions":[{"author":{"id":1144132,"avatar":"https://static001.geekbang.org/account/avatar/00/11/75/44/ee170215.jpg","nickname":"Jasper","note":"","ucode":"7AEF50986C7D8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1834181,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/fc/c5/ff8b770e.jpg","nickname":"BugBean","note":"","ucode":"B51232281AD9BC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279760,"discussion_content":"可以使用工具类逐条读，这样可以不用一次性把文件都读入内存","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1591410857,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":271022,"ip_address":""},"score":279760,"extra":""},{"author":{"id":1607864,"avatar":"https://static001.geekbang.org/account/avatar/00/18/88/b8/7527da95.jpg","nickname":"陈琦","note":"","ucode":"48F974137EF0BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1144132,"avatar":"https://static001.geekbang.org/account/avatar/00/11/75/44/ee170215.jpg","nickname":"Jasper","note":"","ucode":"7AEF50986C7D8C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293516,"discussion_content":"什么工具类","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595562657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":279760,"ip_address":""},"score":293516,"extra":""},{"author":{"id":1607864,"avatar":"https://static001.geekbang.org/account/avatar/00/18/88/b8/7527da95.jpg","nickname":"陈琦","note":"","ucode":"48F974137EF0BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1834181,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/fc/c5/ff8b770e.jpg","nickname":"BugBean","note":"","ucode":"B51232281AD9BC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296066,"discussion_content":"同问","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596443119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":271022,"ip_address":""},"score":296066,"extra":""}]},{"author":{"id":1185974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/18/b6/f3f68a39.jpg","nickname":"马建华","note":"","ucode":"928189590259AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":32122,"discussion_content":"不过真正的时间复杂度应该是nlogk.假设有k个接口文件。因为你还要花logk时间比较","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1570989773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1654546,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/As6z9ZBQLV5ibq1zkDk1DDuUyPcJib8XiaLjG34ycx43n0yGXp175GPswiaH7EPTqR8w8UgjVq7icA0jq3cbia0Nh0xA/132","nickname":"不吃甜食","note":"","ucode":"AB358F4C2C747F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":14050,"discussion_content":"从磁盘读文件是特别慢的操作，一次读取一条，怕是一年也执行不完。不然数据库也就不需要索引了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1568724771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427613,"discussion_content":"你回答的不错 思路是正确的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1540777715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":3,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1951193,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/c5/d9/0a175565.jpg","nickname":"Beck徐工","note":"","ucode":"0B7E0C26E6FBA1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405329,"discussion_content":"这个思路没问题，很多留言快排小顶堆的也是醉了，给出这种方案，完全没理解归并排序","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1634557060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2663781,"avatar":"","nickname":"叶成勇","note":"","ucode":"8D359ED202BE87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384133,"discussion_content":"占个楼，这思路以后我可以参考","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626398274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2277187,"avatar":"https://static001.geekbang.org/account/avatar/00/22/bf/43/05571148.jpg","nickname":"DeanWinchester","note":"","ucode":"10E08D227FEB4B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362107,"discussion_content":"合并两个升序数组是合并，这里合并十个有序数组也是合？是这个意思吗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1616851668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1200858,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/da/a6f990b6.jpg","nickname":"tttw","note":"","ucode":"36EF5E82704346","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":248131,"discussion_content":"k路归并 + 败者树","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587832490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1812840,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/68/ec442a70.jpg","nickname":"王jojo","note":"","ucode":"1ABE7FA2614F86","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":172916,"discussion_content":"可不可以得到10个文件时间戳分别的最大和最小值, 也就是10对最大最小值,然后再归并到文件中, ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581816928,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1446784,"avatar":"","nickname":"Geek_3ba85e","note":"","ucode":"106586BF969A80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1812840,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/68/ec442a70.jpg","nickname":"王jojo","note":"","ucode":"1ABE7FA2614F86","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":244033,"discussion_content":"除非像第一个回答建立最小堆，不然10个300m的日志文件内存没法处理。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587567163,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":172916,"ip_address":""},"score":244033,"extra":""}]},{"author":{"id":1711294,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/1c/be/bc686e38.jpg","nickname":"哆啦C梦丶cium","note":"","ucode":"BED9D6BF0DED69","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46772,"discussion_content":"可以一次读取适量数据，然后在内存中比较，归并排序，然后一次性刷入磁盘中","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573204856,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1252173,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1b/4d/2cc44d9a.jpg","nickname":"刘忽悠","note":"","ucode":"095DE3A8D3F450","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1711294,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/1c/be/bc686e38.jpg","nickname":"哆啦C梦丶cium","note":"","ucode":"BED9D6BF0DED69","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":194471,"discussion_content":"这应该不行吧，因为你一次刷到磁盘的数据应该是所有的数据中最小的那一部分，那就是说你开始读取到内存的数据要恰好是是所有数据总和起来最小的那一部分，这这么可能呢","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1583223279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":46772,"ip_address":""},"score":194471,"extra":""},{"author":{"id":2318607,"avatar":"https://static001.geekbang.org/account/avatar/00/23/61/0f/c759f367.jpg","nickname":"一闪一闪亮晶晶","note":"","ucode":"53A0C2E5FA8208","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1252173,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1b/4d/2cc44d9a.jpg","nickname":"刘忽悠","note":"","ucode":"095DE3A8D3F450","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":335043,"discussion_content":"你怕是没看归并排序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608078918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":194471,"ip_address":""},"score":335043,"extra":""}]},{"author":{"id":1233193,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","nickname":"DFighting","note":"","ucode":"F3BA2426FF8582","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2815,"discussion_content":"我觉得可以使用空间换时间的思想，一次批量读入一批日志到内存，比如维护一个数组，然后在内存中对着10个数组流进行取一条->快排得到最小值->顺序取下一条，这样实际执行时间应该会快不少，但如果这时候内存还有其他的程序再跑，那这样做可能会影响其他程序的，需要做个折中和取舍吧。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1563954564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2188142,"avatar":"https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg","nickname":"Z宇锤锤","note":"","ucode":"7DB36E986A7A51","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540079,"discussion_content":"如果出于节省IO的考虑。批量加载日志数据，就需要考虑这十个文件中首批读取的数据时间范围是否存在重叠。一般肯定会存在重叠。这个时候就应该增加获取一个最小重叠的方法，类似于王源同学那样的做法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639932453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2103542,"avatar":"https://static001.geekbang.org/account/avatar/00/20/18/f6/db57fef1.jpg","nickname":"WSZ","note":"","ucode":"AB092B48C52D47","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407971,"discussion_content":"10条io流每轮几乎都要比较10次啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635160140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1809432,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epnIpyjCYnK5shDFdgyu5lsOgiby8LB87pvaqicWmMcgSMtZF4UMRTyPdX7iaowicyVURFPzx81Z8aU5A/132","nickname":"Geek_5e1584","note":"","ucode":"AF2F7E79143C57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393636,"discussion_content":"前提是每个文件都是有序的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631527277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2261626,"avatar":"","nickname":"Geek_0386e5","note":"","ucode":"40AF296ED8CC3D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392154,"discussion_content":"O（n log k)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630857398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2040512,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/22/c0/177d6750.jpg","nickname":"Rico","note":"","ucode":"9EFA5A95F78CCB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386110,"discussion_content":"🐮","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627408346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1206023,"avatar":"https://static001.geekbang.org/account/avatar/00/12/67/07/d5d9da1a.jpg","nickname":"春容","note":"","ucode":"B59830276FEE57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370291,"discussion_content":"十个生产者读取数据，放入十个循环队列，一个消费者归并这十个循环队列的数据到新文件","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619357163,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1101426,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ce/72/638a2804.jpg","nickname":"林敏健","note":"","ucode":"EF0CE23273878C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365403,"discussion_content":"占用了内存，都会预读，都会缓存，就看用多少内存缓存硬盘数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617795878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1237315,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e1/43/7b4a11cc.jpg","nickname":"梦总被尿憋醒","note":"","ucode":"9B9C312C61CA8D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360180,"discussion_content":"你这里写入一个新文件已经是额外的内存开销了，那空间复杂度不应该是O(n)吗。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616383524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1023272,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9d/28/bcaf070d.jpg","nickname":"壹","note":"","ucode":"335D34216066E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1237315,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e1/43/7b4a11cc.jpg","nickname":"梦总被尿憋醒","note":"","ucode":"9B9C312C61CA8D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362683,"discussion_content":"因为最终的结果一定是要存储的，所以这个开销是必然的，因此空间复杂度是O(1)","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617009994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":360180,"ip_address":""},"score":362683,"extra":""}]},{"author":{"id":1401467,"avatar":"https://static001.geekbang.org/account/avatar/00/15/62/7b/01c7c4aa.jpg","nickname":"impossible","note":"","ucode":"199D0066E2783E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339567,"discussion_content":"十条io流对应十个指针","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609735396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1073845,"avatar":"https://static001.geekbang.org/account/avatar/00/10/62/b5/4159fa05.jpg","nickname":"zhanyd","note":"","ucode":"4C994EE512A3C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":317252,"discussion_content":"牛逼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603521247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2045997,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/38/2d/f3c6493e.jpg","nickname":"罗樱罂","note":"","ucode":"9072E79E625ED1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287151,"discussion_content":"我不是十分懂这个思想。能不能再说说？谢谢了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593391681,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132312,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/18/293cd24d.jpg","nickname":"o0oi1i","note":"","ucode":"D1F6AD4AAEAFBE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":243536,"discussion_content":"虽然我没看懂还是觉得很🐂拜","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587548073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1483834,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/ibkpYrUHO9pQeM1Uk0NUTkYAnjmB6vJicibIhORDQT7GVcP0yICj0ZS2oAXZcWhXEFLVnFve7oqpA9xVB9v8w7Leg/132","nickname":"Geek_04fda1","note":"","ucode":"275970AE0A76AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":200808,"discussion_content":"你的思想有点点问题，如果文件中的时间是这样的 1  2 3;5 6 8;你还怎么一行行比较呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583725564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1349914,"avatar":"https://static001.geekbang.org/account/avatar/00/14/99/1a/0dc1e252.jpg","nickname":"irisWang","note":"","ucode":"570A61595873B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1483834,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/ibkpYrUHO9pQeM1Uk0NUTkYAnjmB6vJicibIhORDQT7GVcP0yICj0ZS2oAXZcWhXEFLVnFve7oqpA9xVB9v8w7Leg/132","nickname":"Geek_04fda1","note":"","ucode":"275970AE0A76AB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":210482,"discussion_content":"当一个文件读完，自然比较剩余9个，当只剩一个，直接merge到已排好序的文件后就可以了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584728316,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":200808,"ip_address":""},"score":210482,"extra":""}]},{"author":{"id":1305639,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ec/27/827015c0.jpg","nickname":"追风少年","note":"","ucode":"0467648A908B18","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5355,"discussion_content":"这个不就是外部排序吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566201609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066644,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/94/ca15724a.jpg","nickname":"下一道彩虹","note":"","ucode":"6F286504A9BCD8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4303,"discussion_content":"你这个算法是针对内存1M的算法。很有意思的想法！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565309981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1252519,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1c/a7/6a837523.jpg","nickname":"之城","note":"","ucode":"12451253E366A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2255,"discussion_content":"其实就是归并排序的思路。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563416488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1484184,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","nickname":"djfhchdh","note":"","ucode":"E71D75328CE398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1252519,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1c/a7/6a837523.jpg","nickname":"之城","note":"","ucode":"12451253E366A2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2707,"discussion_content":"no，no，no，要考虑充分利用内存的性能，要知道内存的访问要比磁盘的访问快多了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1563872266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2255,"ip_address":""},"score":2707,"extra":""}]}]},{"had_liked":false,"id":33722,"user_name":"你有资格吗？","can_delete":false,"product_type":"c1","uid":1233534,"ip_address":"","ucode":"4758C5A190BABB","user_header":"https://static001.geekbang.org/account/avatar/00/12/d2/7e/bd8c372a.jpg","comment_is_top":false,"comment_ctime":1539863503,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1405994169295","product_id":100017301,"comment_content":"建议还是写源码吧，伪代码不能体现细节，基础不好的同学看起来也费劲，还有一个问题课后思考能不能在下一节课开头讲一下，因为感觉您每次留的课后思考都很精辟，想知道以您的维度怎么来思考和解决这个问题","like_count":327,"discussions":[{"author":{"id":1042685,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/fd/abb7bfe3.jpg","nickname":"Langzi233","note":"","ucode":"5A21AC08FC089B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4009,"discussion_content":"课堂讲解还是给伪代码吧，细节真的要自己动手不然也是一眼扫过，映像不深的相信我。但是老师能集中把例子的源码放到github就完美了","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1565057193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1981613,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/8Dj4ugujXwY24G8pcpgDFGiciarXetG3ItQ4M9mSQMLyRdRRXEXXJVfib48mGUQAu87QcvImwyJIVJlEFeEguV44w/132","nickname":"Geek_ac7784","note":"","ucode":"62F0E5E6D6F4BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":257938,"discussion_content":"我认为伪代码其实已经有细节了","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1588613179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34375,"user_name":"我来也","can_delete":false,"product_type":"c1","uid":1205253,"ip_address":"","ucode":"773D6104F56767","user_header":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","comment_is_top":false,"comment_ctime":1540132441,"is_pvip":false,"discussion_count":70,"race_medal":0,"score":"740274507353","product_id":100017301,"comment_content":"我觉得最后的思考题，[曹源]同学的策略是较优的。<br>该策略的最大好处是充分利用了内存。<br>但是我还是会这么做：<br>1.申请10个40M的数组和一个400M的数组。<br>2.每个文件都读40M，取各数组中最大时间戳中的最小值。<br>3.然后利用二分查找，在其他数组中快速定位到小于&#47;等于该时间戳的位置，并做标记。<br>4.再把各数组中标记位置之前的数据全部放在申请的400M内存中，<br>5.在原来的40M数组中清除已参加排序的数据。[可优化成不挪动数据，只是用两个索引标记有效数据的起始和截止位置]<br>6.对400M内存中的有效数据[没装满]做快排。<br>将排好序的直接写文件。<br>7.再把每个数组尽量填充满。从第2步开始继续，知道各个文件都读区完毕。<br>这么做的好处有：<br>1.每个文件的内容只读区一次，且是批量读区。比每次只取一条快得多。<br>2.充分利用了读区到内存中的数据。曹源 同学在文件中查找那个中间数是会比较困难的。<br>3.每个拷贝到400M大数组中参加快排的数据都被写到了文件中，这样每个数只参加了一次快排。","like_count":173,"discussions":[{"author":{"id":2802184,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJoHvFnoNgYmBdKo7Sum0gySwZUREBXBwniaic8hTZHgXxmfeiaPaUia9fvGLq9FJt1dQtEmOyQrwuMlg/132","nickname":"Geek_9f24c4","note":"","ucode":"0E0F23EB79DDAD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534714,"discussion_content":"最大时间戳的最小值这一点很关键 保证了当前取出来的数据是未排序种全局最小的","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1638260637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1243841,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fa/c1/2b8aaa4e.jpg","nickname":"ECDHE","note":"","ucode":"8830D61D8412D7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2802184,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJoHvFnoNgYmBdKo7Sum0gySwZUREBXBwniaic8hTZHgXxmfeiaPaUia9fvGLq9FJt1dQtEmOyQrwuMlg/132","nickname":"Geek_9f24c4","note":"","ucode":"0E0F23EB79DDAD","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":564257,"discussion_content":"感觉跟直接对 400M 数据做快排没啥区别，取40M队尾数据最小值的用意在哪里？望解释","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650201034,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":534714,"ip_address":""},"score":564257,"extra":""},{"author":{"id":1476511,"avatar":"https://static001.geekbang.org/account/avatar/00/16/87/9f/e0480eb9.jpg","nickname":"高稷","note":"","ucode":"8CC10DC4F63413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1243841,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fa/c1/2b8aaa4e.jpg","nickname":"ECDHE","note":"","ucode":"8830D61D8412D7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566163,"discussion_content":"意义在于，前一次排序的全部记录，一定比后一次排序的全部记录更早，每次这400M（实际上肯定小于400M）排完写入就不用管了，无需合并之前排过的记录再排","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1650616933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":564257,"ip_address":""},"score":566163,"extra":""}]},{"author":{"id":1476511,"avatar":"https://static001.geekbang.org/account/avatar/00/16/87/9f/e0480eb9.jpg","nickname":"高稷","note":"","ucode":"8CC10DC4F63413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566161,"discussion_content":"看来层主还在？很棒的思路，每条记录都只参与一次排序，我尝试这个思路用java实现了一下（没用java自带的api，纯用数组写的快排和二分查找，读文件用循环队列节省空间），不过有几个问题想探讨一下：\n1.你考虑十个40M加一个400M的数组，大概是想充分利用内存？由于我测试数据每行记录内容很短，400M大约一千多万行记录，直接做快排会慢到怀疑人生。。\n2.基于1的问题，我把每次参与排序的数据量缩小到一千多行，每次快排平均消耗1~2毫秒，不过读取次数就翻了一万倍（IO按行读，直到文件读完才关闭），3G的文件，合并总共用了二十多分钟\n3.但是2的办法，相当于只用了万分之一的内存，应该还不是最优解\n4.排序和读写文件的逻辑耦合在一起，读取 -&gt; 排序 -&gt; 写入 是串行执行的，可能要考虑解耦","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1650616254,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":8,"child_discussions":[{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1476511,"avatar":"https://static001.geekbang.org/account/avatar/00/16/87/9f/e0480eb9.jpg","nickname":"高稷","note":"","ucode":"8CC10DC4F63413","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566572,"discussion_content":"我是没考虑模化的事情，还是你考虑的周到。\n\n你一千多行的快排还需要1-2ms，感觉这个不太科学啊，用系统库的话耗时是多少呢？（如果换成整数类型，耗时又是多少呢？）\n\n我很早之前做过类似的事情：当时是一千万个时间戳（4字节的整形）读到内存快排，是c语言写的，快排的话印象中很快（大概在1分钟左右？）\nc语言由于内存是提前申请好的，排序过程中也不会有额外的内存开销，就是交换一下值，所以感觉还蛮快的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650716857,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":566161,"ip_address":""},"score":566572,"extra":""},{"author":{"id":1476511,"avatar":"https://static001.geekbang.org/account/avatar/00/16/87/9f/e0480eb9.jpg","nickname":"高稷","note":"","ucode":"8CC10DC4F63413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":567162,"discussion_content":"谢谢你的建议。\n我是按日期字符串排的，可能比较字符串耗时，我试试转成整形再排序。\n另外为了方便转数组我是按行读文件，不知道按字节读再转回文本会不会快一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650849323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":566572,"ip_address":""},"score":567162,"extra":""},{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1476511,"avatar":"https://static001.geekbang.org/account/avatar/00/16/87/9f/e0480eb9.jpg","nickname":"高稷","note":"","ucode":"8CC10DC4F63413","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":567208,"discussion_content":"可以看看按行读和按字节读的耗时差异吧。我直观感觉是批量度更快，但你按行读时本身系统也会有缓存，不知道实际差异有多大。\n不过，读一个几百兆的文件，现在应该非常快吧。毕竟mac的io都几GB/s了。😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650857793,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":567162,"ip_address":""},"score":567208,"extra":""}]},{"author":{"id":2005433,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/99/b9/96261f86.jpg","nickname":"沙里飞","note":"","ucode":"E68FE314029A3A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545337,"discussion_content":"感觉思路上没什么问题了, 加入了预读取+一次性写回. 具体操作中记录每个io数据流的读取位置.","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1641911310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2834725,"avatar":"","nickname":"Sssker","note":"","ucode":"24B16A247FF945","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":412519,"discussion_content":"几个优势点，一个是批量读取磁盘文件，一个是分阶段快速排序后可以直接写入。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1636199300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1358312,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b9/e8/0b3cf295.jpg","nickname":"HaiSky","note":"","ucode":"ECE7C263142432","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55001,"discussion_content":"之前一直没看明白，今天终于看懂了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574331497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1358312,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b9/e8/0b3cf295.jpg","nickname":"HaiSky","note":"","ucode":"ECE7C263142432","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55050,"discussion_content":"这么久了，这么多的回复，难得你还记得。👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574335325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":55001,"ip_address":""},"score":55050,"extra":""}]},{"author":{"id":1272047,"avatar":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","nickname":"Magic","note":"","ucode":"FD9CEDAA419EB0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":16039,"discussion_content":"这里数据有序的情况下，直接merge效率应该更好吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568869272,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":9,"child_discussions":[{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1272047,"avatar":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","nickname":"Magic","note":"","ucode":"FD9CEDAA419EB0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":17861,"discussion_content":"这个不一定哦。\n虽然每个文件内部是有序的，但互相之间不见得。\n如果一条一条的比较再写入，和批量读取，批量排序，批量写入，效率差别还是蛮大的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568985901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":16039,"ip_address":""},"score":17861,"extra":""},{"author":{"id":1272047,"avatar":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","nickname":"Magic","note":"","ucode":"FD9CEDAA419EB0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":18044,"discussion_content":"嗯，我这里想说的是将每个文件的数据批量读取到内存，例如前40M，然后对这部分数据直接做merge，而不是快排","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568997589,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":17861,"ip_address":""},"score":18044,"extra":""},{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1272047,"avatar":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","nickname":"Magic","note":"","ucode":"FD9CEDAA419EB0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":18141,"discussion_content":"学习了，之前还从未考虑在这阶段使用归并排序。\n虽然在理论上这两个算法时间复杂度差不多。但在这种数量级，这种局部有序的情况下，估计还是要实测来验证更适合哪种排序算法了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569025665,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":18044,"ip_address":""},"score":18141,"extra":""}]},{"author":{"id":1518842,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2c/fa/d9ef3e77.jpg","nickname":"牛仔很忙。","note":"","ucode":"5037849220E48D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579669,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657609270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1180708,"avatar":"https://static001.geekbang.org/account/avatar/00/12/04/24/15433419.jpg","nickname":"欲望之城","note":"","ucode":"B4560AA760B9E1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559121,"discussion_content":"第七步循环的时候，把每个40M的数组装满之前要清除已排序的数据再把剩余数据整体迁移从数据索引0开始之后再去从原来的文件补充，确保每次循环40MB数据内数据完全有序，这样是不是代码层面更简洁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648616603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1180708,"avatar":"https://static001.geekbang.org/account/avatar/00/12/04/24/15433419.jpg","nickname":"欲望之城","note":"","ucode":"B4560AA760B9E1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559784,"discussion_content":"这个要看你怎么考虑了，是注重代码简洁还是效率。\n不移的话就减少一次拷贝，增加的代码也不会太多的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648957428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":559121,"ip_address":""},"score":559784,"extra":""}]},{"author":{"id":2703237,"avatar":"","nickname":"sean","note":"","ucode":"B517C6A09A4F07","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":414220,"discussion_content":"是不是有问题，如果一个文件里面最小值在最后，一开始40m没有读到，后续写入不是会在最后","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636694923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2703237,"avatar":"","nickname":"sean","note":"","ucode":"B517C6A09A4F07","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":532556,"discussion_content":"给定的条件好像是每个文件内部是有序的。你是说有的文件是倒序有的是正序？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1637645000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":414220,"ip_address":""},"score":532556,"extra":"{\"user_type\":1}"}]},{"author":{"id":1526269,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKxI5kh3ZPT9zic85ufXL1fu9mGsSiazf0bIj0bxbic3tFy8JJ1reuC0UMsGpMeSKq3x5JuerwYOjtkA/132","nickname":"wpjl","note":"","ucode":"07AC5BF1D5980F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369336,"discussion_content":"请问为什么不直接将10个40M的数据都放到400M的内存中进行快排，而是要截取一部分进行快排","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619007957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1526269,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKxI5kh3ZPT9zic85ufXL1fu9mGsSiazf0bIj0bxbic3tFy8JJ1reuC0UMsGpMeSKq3x5JuerwYOjtkA/132","nickname":"wpjl","note":"","ucode":"07AC5BF1D5980F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369377,"discussion_content":"截取一部分，是确保参与快排的数据，都是有效的：不会比剩余的未参与快排的任意一个数大（小）。\n\n因为：极端情况下，可能有一个40MB的数据比其他数组中*剩余*的数据还要大（小），如果提前参与了排序，就会导致整体数据乱序了。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1619014102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":369336,"ip_address":""},"score":369377,"extra":""},{"author":{"id":1526269,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKxI5kh3ZPT9zic85ufXL1fu9mGsSiazf0bIj0bxbic3tFy8JJ1reuC0UMsGpMeSKq3x5JuerwYOjtkA/132","nickname":"wpjl","note":"","ucode":"07AC5BF1D5980F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369501,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619058189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":369377,"ip_address":""},"score":369501,"extra":""},{"author":{"id":2876330,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/e3/aa/8ad37dbe.jpg","nickname":"路晗","note":"","ucode":"8D95E160575C82","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1526269,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKxI5kh3ZPT9zic85ufXL1fu9mGsSiazf0bIj0bxbic3tFy8JJ1reuC0UMsGpMeSKq3x5JuerwYOjtkA/132","nickname":"wpjl","note":"","ucode":"07AC5BF1D5980F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547632,"discussion_content":"或者换句话说，是为了保证参与排序的是所有10个文件所有数据中最小的那部分数据，前面有人也说了，10个10M文件中10个最大值中选最小值做二分很关键","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642777103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":369336,"ip_address":""},"score":547632,"extra":""}]},{"author":{"id":1101426,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ce/72/638a2804.jpg","nickname":"林敏健","note":"","ucode":"EF0CE23273878C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365402,"discussion_content":"逐条读取不代表每次都读盘，标准io流都有缓存，加上主存会在加载硬盘数据的时候也会做预读，所以实际上10条io流都同时读取100M数据是没有问题的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617795511,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1101426,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ce/72/638a2804.jpg","nickname":"林敏健","note":"","ucode":"EF0CE23273878C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365510,"discussion_content":"确实不是每个read操作都真的读磁盘。\n\n但就拿memcopy来说，每次只copy4个字节，和一次copy40MB的字节，拷贝的数据量是一样的时，哪个更快，还是一样快？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617809704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":365402,"ip_address":""},"score":365510,"extra":""}]},{"author":{"id":2527979,"avatar":"https://static001.geekbang.org/account/avatar/00/26/92/eb/e530c2d0.jpg","nickname":"姬遇","note":"","ucode":"4A1617750FC3A9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359541,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616223903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1707976,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/0f/c8/99e873a4.jpg","nickname":"yami粉丝","note":"","ucode":"0F2E8121697A6C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344288,"discussion_content":"清除的数据还会被重新读取吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611389686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1707976,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/0f/c8/99e873a4.jpg","nickname":"yami粉丝","note":"","ucode":"0F2E8121697A6C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344294,"discussion_content":"既然是逻辑上清除了，就不应该被重新读取了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611393980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":344288,"ip_address":""},"score":344294,"extra":""}]},{"author":{"id":2336972,"avatar":"https://static001.geekbang.org/account/avatar/00/23/a8/cc/51c72cc7.jpg","nickname":"Echizyc","note":"","ucode":"40F8D88B38AFD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337906,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609121418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1250922,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIzGGthScz54sECZJKX3lgyjCATkgrvSt5N3eOsYB34jibCr3SkAX88QaZ5IVmME9Ec7VdkQGwRSPw/132","nickname":"哈哈哈","note":"","ucode":"8AC20A1C9C7DF8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301408,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598518228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2070759,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/98/e7/30a0f917.jpg","nickname":"匆匆","note":"","ucode":"F2434447DCBCE3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292191,"discussion_content":"为什么非是40M呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595133055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2070759,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/98/e7/30a0f917.jpg","nickname":"匆匆","note":"","ucode":"F2434447DCBCE3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292214,"discussion_content":"40M只是一个粗略的估算，后面还是要根据实际情况调整。\n\n但肯定是不能把可用的空间全部申请完的。\n否则系统内存不够时会大幅度的降低性能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595144161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":292191,"ip_address":""},"score":292214,"extra":""},{"author":{"id":1317847,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1b/d7/868d26ce.jpg","nickname":"songhyunmin","note":"","ucode":"D5A98668CD8532","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2070759,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/98/e7/30a0f917.jpg","nickname":"匆匆","note":"","ucode":"F2434447DCBCE3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353719,"discussion_content":"45M也行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615196126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":292191,"ip_address":""},"score":353719,"extra":""}]},{"author":{"id":1625233,"avatar":"https://static001.geekbang.org/account/avatar/00/18/cc/91/d56a81af.jpg","nickname":"CoderArthur","note":"","ucode":"5B591914F0F67C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285904,"discussion_content":"&#34;7.再把每个数组尽量填充满。从第2步开始继续，知道各个文件都读区完毕。&#34;，怎么填满数组呢？前半部分是空的，后面是未使用数据，把后面数据往前挪吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592987231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1625233,"avatar":"https://static001.geekbang.org/account/avatar/00/18/cc/91/d56a81af.jpg","nickname":"CoderArthur","note":"","ucode":"5B591914F0F67C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285965,"discussion_content":"可以不挪数据的。\n\n参考循环队列，单独记录有效数据的首尾地址。\n有数据来就往后追加，取数据就从前拿。\n\n最好是把这个操作包装起来，对外透明。\n","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1592998811,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":285904,"ip_address":""},"score":285965,"extra":""},{"author":{"id":1246707,"avatar":"https://static001.geekbang.org/account/avatar/00/13/05/f3/5488276f.jpg","nickname":"心雨鑫晴","note":"","ucode":"37A42C19B98F1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302593,"discussion_content":"循环数组的话，需要一个标记，标记一下当前数组的最大时间戳所处的位置。而且没办法利用二分吧，或者这个二分写起来有点麻烦。同时，文件读取到数组的时候，文件本身有序，那么读入的数据也基本上是有序的，这样使用快排时间复杂度是比较高的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598966787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":285965,"ip_address":""},"score":302593,"extra":""},{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1246707,"avatar":"https://static001.geekbang.org/account/avatar/00/13/05/f3/5488276f.jpg","nickname":"心雨鑫晴","note":"","ucode":"37A42C19B98F1D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302609,"discussion_content":"1.这个二分从逻辑上很好理解，实现时，就需要添加一个便宜量，应该也不复杂。\n\n2.对有序的数组做快排，确实容易发生极限情况导致时间复杂度升高的问题。\n但是也是可以解决的，比如优化选取分区点的函数，不从最后面取，而是采用三点取中法，这样就不容易出现最坏的情况了。（才在公开课 算法专栏学的 现学现卖哈）\n\n另外，在本例中，虽然每个文件各自有序，但是合并到大数组后，并不一定这么有序了.\n\n———\n以上全是个人yy的，并没有实践。\n如果不对之处，欢迎交流和指正。\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1598969908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":302593,"ip_address":""},"score":302609,"extra":""}]},{"author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":272510,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590318082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1046893,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f9/6d/b623562a.jpg","nickname":"霹雳大仙pp","note":"","ucode":"F654FD9AEC1D56","race_medal":3,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":251005,"discussion_content":"好思路，学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588057696,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1896587,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f0/8b/e307f616.jpg","nickname":"沐浴露🧴","note":"","ucode":"CFAFDE6450BC2F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":245976,"discussion_content":"这样做真的很厉害了，就是感觉还有最后一个，怎么样尽量填充满40M的数组，又不会让读取的日志发生截断。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587716778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1896587,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f0/8b/e307f616.jpg","nickname":"沐浴露🧴","note":"","ucode":"CFAFDE6450BC2F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":246010,"discussion_content":"这个细节你还是考虑的蛮全.\n避免日志截断,这个要看日志具体是什么样的格式.\n\n假如日志是二进制文件,这个就不是问题.一个时间戳几乎就是4个字节.\n假如日志是文本,以换行符或;分隔,那么取40M的内容后,从后往前找分隔符,找到了,就把这个分隔符后面的内容留到下次继续处理.\n\n不知道你还有没有什么疑问.","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1587717799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":245976,"ip_address":""},"score":246010,"extra":""}]},{"author":{"id":1092218,"avatar":"https://static001.geekbang.org/account/avatar/00/10/aa/7a/ae8c247d.jpg","nickname":"指尖以东","note":"","ucode":"1DEE134FE92FD0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":243955,"discussion_content":"非常好的思路，确实比一个一个读取效率高不少，受教了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587565599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1092218,"avatar":"https://static001.geekbang.org/account/avatar/00/10/aa/7a/ae8c247d.jpg","nickname":"指尖以东","note":"","ucode":"1DEE134FE92FD0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":244006,"discussion_content":"互相交流，一起精进！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587566709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":243955,"ip_address":""},"score":244006,"extra":""}]},{"author":{"id":1768828,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/fd/7c/6ba1a1fd.jpg","nickname":"低调","note":"","ucode":"2C24C4A8B232E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223635,"discussion_content":"合并的时候快排的时间复杂度O(nlogn)应该比归并中的合并O(n)大，所以建议直接用归并的合并","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586241700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1768828,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/fd/7c/6ba1a1fd.jpg","nickname":"低调","note":"","ucode":"2C24C4A8B232E6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223720,"discussion_content":"嗯，归并算法在理论上应该更优。归并的平均时间复杂度跟快排一样，都是nlogn，不过快排的最坏情况就是n^2。\n不过在这种数据量下，可以尝试着都实现下了，再根据测试结果选取一个适合当前场景的。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1586248501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":223635,"ip_address":""},"score":223720,"extra":""}]},{"author":{"id":1768828,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/fd/7c/6ba1a1fd.jpg","nickname":"低调","note":"","ucode":"2C24C4A8B232E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223634,"discussion_content":"第二部最关键、批量读取的解决方案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586241547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1266597,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/oseia6IjJIPziamTI2EQ0Bpr8icUicXTea2UuH105t4Bia4yFwBHld49cIQbjORvDdTtMCVdL39H9WxFwzyXspqqHUg/132","nickname":"groot888","note":"","ucode":"50E50681D6BE0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":156364,"discussion_content":"10个文件，每个文件内部都是有序的呀，为啥还要排。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580354362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1266597,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/oseia6IjJIPziamTI2EQ0Bpr8icUicXTea2UuH105t4Bia4yFwBHld49cIQbjORvDdTtMCVdL39H9WxFwzyXspqqHUg/132","nickname":"groot888","note":"","ucode":"50E50681D6BE0C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":156428,"discussion_content":"不太理解你的问题。\n\n每个文件内部有序，如果各文件间一条一条记录的比较，自然是不需要额外排序，但是这样效率太低了。有重复比较，以及内存使用不充分的问题，更主要的是每次写入磁盘的效率太低了。如果能批量写入磁盘，这个速度会快很多。\n\n如果多个文件，直接取前面连续的一部分，直接合并成一个文件，显然是不能保证还是有序的。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1580362451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":156364,"ip_address":""},"score":156428,"extra":""}]},{"author":{"id":1158349,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ac/cd/fda6374f.jpg","nickname":"Louis","note":"","ucode":"BC667839F17937","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37611,"discussion_content":"请问这里申请了800m内存剩下的200m是做排序用吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571646000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1158349,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ac/cd/fda6374f.jpg","nickname":"Louis","note":"","ucode":"BC667839F17937","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37742,"discussion_content":"剩余内存要给系统和其他程序留点。也避免申请大内存块时失败。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1571661629,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":37611,"ip_address":""},"score":37742,"extra":""},{"author":{"id":1747459,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/aa/03/dcdc2e5b.jpg","nickname":"IT吐司","note":"","ucode":"0A55D1C94E2F16","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57290,"discussion_content":"受教了，能站在这么现实的角度上想问题！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574592753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":37742,"ip_address":""},"score":57290,"extra":""}]},{"author":{"id":1125452,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2c/4c/42596eb4.jpg","nickname":"westboy","note":"","ucode":"A2B33609A89C66","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6583,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566984639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042685,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/fd/abb7bfe3.jpg","nickname":"Langzi233","note":"","ucode":"5A21AC08FC089B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4053,"discussion_content":"思想理论不错，400M的数组不好弄，再加上这么大的数组的快排所需要的栈。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565082940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1042685,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/fd/abb7bfe3.jpg","nickname":"Langzi233","note":"","ucode":"5A21AC08FC089B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4068,"discussion_content":"嗯，快排是递归，需要用栈空间。刚毕业那会，用快排排序过100M的数组，速度很快的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565088589,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4053,"ip_address":""},"score":4068,"extra":""}]},{"author":{"id":1484184,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","nickname":"djfhchdh","note":"","ucode":"E71D75328CE398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2704,"discussion_content":"厉害，高手啊，学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563871915,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32932,"user_name":"王先统","can_delete":false,"product_type":"c1","uid":1236218,"ip_address":"","ucode":"4D208672C0D359","user_header":"https://static001.geekbang.org/account/avatar/00/12/dc/fa/3975f8da.jpg","comment_is_top":false,"comment_ctime":1539736353,"is_pvip":false,"discussion_count":10,"race_medal":0,"score":"413856596769","product_id":100017301,"comment_content":"可以为每个文件分配一个40M的数组，再另外分配一个400M的数组储存归并结果，每个文件每次读取40M，对十个数组做归并排序直到其中某个数组的数据被处理完，这时将归并结果写入磁盘，处理完的数组继续读入40M继续参与归并，以此类推，直到所有文件都处理完","like_count":96,"discussions":[{"author":{"id":1112747,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","nickname":"李小四","note":"","ucode":"2A766BE16B276B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2274,"discussion_content":"我认为这个方法不可行：\n1. 无法确保排序结果正确：在10个300M的日志文件中，如何保证每个文件40M之后的时间戳比其他文件40M之前的时间戳大。\n例子：\n文件1：12345678\n文件2：12222222\n取前4个，\n第一次合并结果是：11222234\n第二次合并结果是：1122223422225678\n这样就出现排序错误。\n\n2. 实际运行中，很可能申请不到400M空间的数组，我们知道数组是连续存储，在1G的内存中申请400M的连续存空间基本做不到。","likes_number":21,"is_delete":false,"is_hidden":false,"ctime":1563425663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1595921,"avatar":"https://static001.geekbang.org/account/avatar/00/18/5a/11/56397685.jpg","nickname":"见思","note":"","ucode":"26F4428210F168","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1112747,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","nickname":"李小四","note":"","ucode":"2A766BE16B276B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24486,"discussion_content":"第二点申请不到这么多的连续内存没问题。但第一点有问题，第一次合并结果是112222，然后文件2的内容比用完则第一次较结束，结果112222写入新文件，重新读入文件2: 2222，此时文件1: 34，继续比较得到2222， 文件2再次先用完，2222写入新文件，文件2结束。最后只剩文件 1，则顺序写入新文件，比较结束，新文件数据：1122222345678。","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1570156955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2274,"ip_address":""},"score":24486,"extra":""},{"author":{"id":1212873,"avatar":"https://static001.geekbang.org/account/avatar/00/12/81/c9/9194612b.jpg","nickname":"百里","note":"","ucode":"2CE96129AA7F78","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1112747,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","nickname":"李小四","note":"","ucode":"2A766BE16B276B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71454,"discussion_content":"当然可行,题目的意思已经告诉你啦,是有序数组.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575422603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2274,"ip_address":""},"score":71454,"extra":""},{"author":{"id":1850499,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/3c/83/93e7af9e.jpg","nickname":"兰柯","note":"","ucode":"6D7230B3CE8722","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1112747,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","nickname":"李小四","note":"","ucode":"2A766BE16B276B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":244514,"discussion_content":"虚拟存储","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587607533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2274,"ip_address":""},"score":244514,"extra":""}]},{"author":{"id":1138849,"avatar":"https://static001.geekbang.org/account/avatar/00/11/60/a1/fb665ad4.jpg","nickname":"foreach","note":"","ucode":"67453D351B09B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":200710,"discussion_content":"这个方法理论上是可行的，但实际中要考虑到每行日志是大小不一致的，每次取出的40m可能是被截断的，不完整的日志。所以实现过程还要考虑这个问题","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1583715045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2818727,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/02/a7/a17dfba3.jpg","nickname":"Valentine","note":"","ucode":"971CA6B44A3191","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534089,"discussion_content":"这样理论上是可以的，保证每次进入的数据都是有序的同时，也确保了新取出来的那40m都是比刚刚排序完成的那些大的数据，不错的idea！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638092190,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1539926,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIUBia0Aevb2CyMNPvuzTkVvlcoDpdFELFav5Bcic90wxehZibo0VglM7aRZLMo93Ful7v5TFlKfEYyg/132","nickname":"啊不多","note":"","ucode":"A38DE3C564B748","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362113,"discussion_content":"这个有点问题吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616853078,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1716067,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/2f/63/7a048d46.jpg","nickname":"梨子苹果","note":"","ucode":"3666813FEE31D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56043,"discussion_content":"厉害了，因为先归并完的数据一定比还未读出来的数据小且小于当前已经读出来未归并的数据，所以如果哪个读出来的数据先完，就读出该文件下一批数据，出来继续比，直到读完","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574426766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1058331,"avatar":"https://static001.geekbang.org/account/avatar/00/10/26/1b/4caf36bd.jpg","nickname":"coldpark","note":"","ucode":"D1B0F343B384F8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24165,"discussion_content":"对，这个方法不可行，如果每天一个文件，一个文件从0点记录到24点，每此顺序取每个文件的某一个小时数据，最终的合并结果中最后一天0点的数据在第一天24点的数据之前。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570022301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34692,"user_name":"Geek_41d472","can_delete":false,"product_type":"c1","uid":1247965,"ip_address":"","ucode":"DEC2B6329460CF","user_header":"https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg","comment_is_top":false,"comment_ctime":1540259396,"is_pvip":false,"discussion_count":49,"race_medal":0,"score":"383792348740","product_id":100017301,"comment_content":"用java来写吧，估计这里90％都是java开发！伪代码看的蛋疼","like_count":89,"discussions":[{"author":{"id":1577357,"avatar":"https://static001.geekbang.org/account/avatar/00/18/11/8d/ac0df87e.jpg","nickname":"slim shady","note":"","ucode":"DB0D7A6AC3840B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2352,"discussion_content":"php能说话吗","likes_number":14,"is_delete":false,"is_hidden":false,"ctime":1563507016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1235495,"avatar":"https://static001.geekbang.org/account/avatar/00/12/da/27/a1618737.jpg","nickname":"1KG","note":"","ucode":"857C432444EBCC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1577357,"avatar":"https://static001.geekbang.org/account/avatar/00/18/11/8d/ac0df87e.jpg","nickname":"slim shady","note":"","ucode":"DB0D7A6AC3840B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290116,"discussion_content":"当然可以，php是世界上最好的语言🙂","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594349105,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2352,"ip_address":""},"score":290116,"extra":""}]},{"author":{"id":2093945,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/f3/79/a2bedc1e.jpg","nickname":"J6","note":"","ucode":"3F097CE1FFCA05","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386878,"discussion_content":"不要用你狭隘的眼光来估计整个世界。","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1627873155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1454945,"avatar":"https://static001.geekbang.org/account/avatar/00/16/33/61/da6d8713.jpg","nickname":"Xinming","note":"","ucode":"F7330DD975D248","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2324,"discussion_content":"OC 冒个泡","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1563462692,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1310681,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ff/d9/b664f1f9.jpg","nickname":"二月火马","note":"","ucode":"D0F4E0443534C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340198,"discussion_content":"Java开发者不至于看不懂伪代码吧","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1609925590,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1599505,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eribTTrJQqjcWTUzxibuVzgO9kyn4ZjwjqMOCdLaphVI6TeP8hkFwxOicW7ibU7VRDRyFyMdMUsZQn8QQ/132","nickname":"BrianM","note":"","ucode":"765D84FCBB8F3F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342435,"discussion_content":"90%都是Java？ 真是张口就来","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1610681180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2297316,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/qeL7fNxa4BVTGH53Wwr7gGVc3IicBPdgNywk7rvauKFuClic21BM6iauEETqdnKLx2Ik1jJ1dKQefRBWlwxIU7OicA/132","nickname":"小白一枚","note":"","ucode":"18A0FA6E3AD75A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1599505,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eribTTrJQqjcWTUzxibuVzgO9kyn4ZjwjqMOCdLaphVI6TeP8hkFwxOicW7ibU7VRDRyFyMdMUsZQn8QQ/132","nickname":"BrianM","note":"","ucode":"765D84FCBB8F3F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350164,"discussion_content":"不张口也不能等死啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613729400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":342435,"ip_address":""},"score":350164,"extra":""}]},{"author":{"id":1264175,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/2f/3bc91d1a.jpg","nickname":"Fan","note":"","ucode":"51207FBE50B727","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296099,"discussion_content":"js路过","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1596451553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1396815,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/4f/78549650.jpg","nickname":"safly","note":"","ucode":"9A2439CEAD1DEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69231,"discussion_content":"c/c++表示不服","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1575273835,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1127175,"avatar":"https://static001.geekbang.org/account/avatar/00/11/33/07/8f351609.jpg","nickname":"JustDoDT","note":"","ucode":"6AF0B80F00EAEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21292,"discussion_content":"python冒个泡，老哥90% java 没有数据支持我不信。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1569463857,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1210699,"avatar":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","nickname":"-W.LI-","note":"","ucode":"3556786538664F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1127175,"avatar":"https://static001.geekbang.org/account/avatar/00/11/33/07/8f351609.jpg","nickname":"JustDoDT","note":"","ucode":"6AF0B80F00EAEF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24824,"discussion_content":"能教我python么?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570276926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":21292,"ip_address":""},"score":24824,"extra":""},{"author":{"id":1210699,"avatar":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","nickname":"-W.LI-","note":"","ucode":"3556786538664F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1127175,"avatar":"https://static001.geekbang.org/account/avatar/00/11/33/07/8f351609.jpg","nickname":"JustDoDT","note":"","ucode":"6AF0B80F00EAEF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24827,"discussion_content":"开篇解答O(n)我觉得有问题啊，凭什么每次真好都是2分啊。如果每次都只搞一个最坏不应该是O(n2)么?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570277298,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":21292,"ip_address":""},"score":24827,"extra":""}]},{"author":{"id":1131687,"avatar":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","nickname":"啦啦啦","note":"","ucode":"6B12EC90A62525","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3951,"discussion_content":"哪来的自信95%都是java","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1565001397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1247610,"avatar":"https://static001.geekbang.org/account/avatar/00/13/09/7a/f78e67b0.jpg","nickname":"醉丶春风","note":"","ucode":"A2B31C277A053E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1131687,"avatar":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","nickname":"啦啦啦","note":"","ucode":"6B12EC90A62525","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5546,"discussion_content":"老哥还在学吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566350910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3951,"ip_address":""},"score":5546,"extra":""},{"author":{"id":1131687,"avatar":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","nickname":"啦啦啦","note":"","ucode":"6B12EC90A62525","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1247610,"avatar":"https://static001.geekbang.org/account/avatar/00/13/09/7a/f78e67b0.jpg","nickname":"醉丶春风","note":"","ucode":"A2B31C277A053E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5610,"discussion_content":"嗯呢，在学呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566375787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5546,"ip_address":""},"score":5610,"extra":""}]},{"author":{"id":1024416,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a1/a0/7687413f.jpg","nickname":"Zopen","note":"","ucode":"3EA97C79523FD7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1286,"discussion_content":"C++冒个泡","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1562503859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1229070,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c1/0e/2b987d54.jpg","nickname":"蜉蝣","note":"","ucode":"77CF92496855D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50854,"discussion_content":"python go 不配有名字(｡･ˇ_ˇ･｡:)","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1573780224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1131687,"avatar":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","nickname":"啦啦啦","note":"","ucode":"6B12EC90A62525","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3950,"discussion_content":"哪来的自信95%都是java","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1565001396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1464664,"avatar":"https://static001.geekbang.org/account/avatar/00/16/59/58/6ed1d751.jpg","nickname":"lovelytong","note":"","ucode":"BC4B7F393E1FC4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296061,"discussion_content":"js飘过","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1596442110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2204462,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/IY4fLqdVwCPlW7xJicz3nZm4OePT0o20tDZj1Hiauk2b0iaHMQcSOGpamLt9b72hYVG72sgRWic1BHY3uCvibWcfickw/132","nickname":"Grocker","note":"","ucode":"DF2E19A65DEAD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387067,"discussion_content":"php go路过","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1627970904,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378188,"discussion_content":"怎么没有 Rust 的冒泡⊙▽⊙","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623081579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1609871,"avatar":"https://static001.geekbang.org/account/avatar/00/18/90/8f/9c691a5f.jpg","nickname":"奔跑的码仔","note":"","ucode":"AB3B02B07B8B8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294945,"discussion_content":"嵌入式c飘过👉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596034232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2033381,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/dqFNxRtTH5fNFN0eVc2fEftyWv0XPM565g54nVXHibVLMynn65yoQLDAt85MTEDU81gKeEvH6SQ1ibIzoxavryaQ/132","nickname":"Ky","note":"","ucode":"EFE8635A82D78F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293243,"discussion_content":"C# 感觉存在感好低啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595491043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359136,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bd/20/e6a9fed8.jpg","nickname":"$.Luerdog","note":"","ucode":"F52A7CE189CF24","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284807,"discussion_content":"php Python js","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592646051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2006541,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIcYxGibC5Mz4zpRs4HzibHEMiajEJo1XBfESqJGib2ibBaRWymciceW3ey0kl8HAjcmMFIpcB2u2JiaaEOg/132","nickname":"Geek_343204","note":"","ucode":"981BCE04A9E22E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275572,"discussion_content":"java","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590731647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1380312,"avatar":"https://static001.geekbang.org/account/avatar/00/15/0f/d8/9286b272.jpg","nickname":"leetcode","note":"","ucode":"3B8C3668A0DE74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":235087,"discussion_content":"js冒个泡","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587018090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1161142,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b7/b6/c324a7de.jpg","nickname":"飞扬","note":"","ucode":"F2E6C39A4E63E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":200603,"discussion_content":"java","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583686631,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1074588,"avatar":"https://static001.geekbang.org/account/avatar/00/10/65/9c/e8d0cdc9.jpg","nickname":"薛海山","note":"","ucode":"02BFF558C1B610","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":30679,"discussion_content":"golang","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1570850912,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1010167,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/69/f7/0b0e10c5.jpg","nickname":"waXaw","note":"","ucode":"280A5118C1C547","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583985,"discussion_content":"swift瑟瑟发抖","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660547512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1161105,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b7/91/257b895a.jpg","nickname":"Reven","note":"","ucode":"487E00D144701B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547849,"discussion_content":"要兼顾多种语言，伪代码挺好的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642903379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1097790,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c0/3e/ff3ed621.jpg","nickname":"云起","note":"","ucode":"1642C543B47B87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530725,"discussion_content":"php路过","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637134964,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1990608,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/5f/d0/8260f262.jpg","nickname":"Lee","note":"","ucode":"0E1D4C045E5508","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389121,"discussion_content":"JavaScript","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629125530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1218810,"avatar":"https://static001.geekbang.org/account/avatar/00/12/98/fa/6b80ed33.jpg","nickname":"Zoker","note":"","ucode":"CD7F9642C61DD4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381692,"discussion_content":"来自 Gitee 的 Ruby 瑟瑟发抖 😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625188129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2034735,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/0c/2f/a9cbcb76.jpg","nickname":"小青年","note":"","ucode":"7168E10235A2E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365023,"discussion_content":"PHP ???","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617688479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2541815,"avatar":"https://static001.geekbang.org/account/avatar/00/26/c8/f7/29b431cb.jpg","nickname":"🇧 🇪 🇦 🇷","note":"","ucode":"DFBCE2D953BF77","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364179,"discussion_content":"C++路过","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617377156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1263805,"avatar":"https://static001.geekbang.org/account/avatar/00/13/48/bd/31070e65.jpg","nickname":"段嗣国","note":"","ucode":"01BA451AB97D23","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339680,"discussion_content":"易语言路过。/hhh","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609756473,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2221397,"avatar":"https://static001.geekbang.org/account/avatar/00/21/e5/55/ae64df9d.jpg","nickname":"cloudy","note":"","ucode":"8D3AA12C499F1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324825,"discussion_content":"能看懂c和java","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605176383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2249227,"avatar":"https://static001.geekbang.org/account/avatar/00/22/52/0b/50bf0f05.jpg","nickname":"橙子橙","note":"","ucode":"CD51367A14D955","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321459,"discussion_content":"go路过","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604584073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1335973,"avatar":"https://static001.geekbang.org/account/avatar/00/14/62/a5/384253e5.jpg","nickname":"Kristy","note":"","ucode":"B8F5DE15839FE3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2249227,"avatar":"https://static001.geekbang.org/account/avatar/00/22/52/0b/50bf0f05.jpg","nickname":"橙子橙","note":"","ucode":"CD51367A14D955","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585121,"discussion_content":"同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661334216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":321459,"ip_address":"江苏"},"score":585121,"extra":""}]},{"author":{"id":2093945,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/f3/79/a2bedc1e.jpg","nickname":"J6","note":"","ucode":"3F097CE1FFCA05","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303842,"discussion_content":"dart 和 go, 我是不是最小众的了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599394009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1603820,"avatar":"https://static001.geekbang.org/account/avatar/00/18/78/ec/1fb29338.jpg","nickname":"丶夕言の惜诺言灬","note":"","ucode":"08BB38FBA23D79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296397,"discussion_content":"我能看懂C#和Java","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596532509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1735002,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/loOqiajRMDoBmMs8bLeIjfhwYN0DNf3ic7x92hw6mW5GWG3mVkw7ub52cqjvkVqt4Fq3fU0A2C7WcsS3icIlOd1fg/132","nickname":"Geek_宋","note":"","ucode":"B050CEE1BE9221","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289053,"discussion_content":"C","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593962402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1930959,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/76/cf/35cbffa0.jpg","nickname":"zoyoy","note":"","ucode":"25D3BAA0564836","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267231,"discussion_content":"JS冒泡。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589618301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1236079,"avatar":"https://static001.geekbang.org/account/avatar/00/12/dc/6f/5d86dbe9.jpg","nickname":"短迪大魔王","note":"","ucode":"37E8117E0495B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":151459,"discussion_content":"python","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579877125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1483150,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a1/8e/03aeb9df.jpg","nickname":"Rocky","note":"","ucode":"5FCF390BECDF9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":97365,"discussion_content":"js冒泡","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577110872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1677187,"avatar":"https://static001.geekbang.org/account/avatar/00/19/97/83/845b48e2.jpg","nickname":"Allen_","note":"","ucode":"CA5E00E4644CD5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78352,"discussion_content":"javascript和golang呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575988309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1390893,"avatar":"https://static001.geekbang.org/account/avatar/00/15/39/2d/e367c30b.jpg","nickname":"金十数据","note":"","ucode":"E4BA783F2C8922","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49789,"discussion_content":"JavaScript的冒泡","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573637490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1609457,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8e/f1/ac8b99a7.jpg","nickname":"Bruce。烨","note":"","ucode":"5C1DB76C2B36A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":48793,"discussion_content":"附议","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573526977,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1591783,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/NTSD503ibERiba4wcsoiaezDrjLMOVVlAlliagHc6ic3icWFfuzaFWaHwuULQDo22mPiabicImFTB7ial82OuBD96bl4RTQ/132","nickname":"Geek_d4f974","note":"","ucode":"F91D0CD09CB13E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497,"discussion_content":"肯能吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561622790,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34356,"user_name":"sherry","can_delete":false,"product_type":"c1","uid":1234416,"ip_address":"","ucode":"4F1BB26390527D","user_header":"https://static001.geekbang.org/account/avatar/00/12/d5/f0/1f86793d.jpg","comment_is_top":false,"comment_ctime":1540124066,"is_pvip":false,"replies":[{"id":"12346","content":"真是众口难调啊😢","user_name":"作者回复","comment_id":34356,"uid":"1190123","ip_address":"","utype":1,"ctime":1540259082,"user_name_real":"gg"}],"discussion_count":8,"race_medal":0,"score":"332252605858","product_id":100017301,"comment_content":"还是觉得伪代码更好，理解思路然后可以写成自己写练练手，看完代码后就没啥想写的欲望了。","like_count":78,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427185,"discussion_content":"真是众口难调啊😢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540259082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1174199,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ea/b7/1a18a39d.jpg","nickname":"5-刘新波(Arvin)","note":"","ucode":"DBD135D2587A93","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":15488,"discussion_content":"建议写代码，基础不好，错了都没有借鉴的地方啊！😹","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1568821008,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1711864,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/1e/f8/f220e694.jpg","nickname":"小兔乖乖","note":"","ucode":"86032F118019B7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":145149,"discussion_content":"其实每个人需求都不同的，也许写了代码又会有人说为什么不用XX语言，所以，老师觉得怎么能讲清楚怎么来就好~","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1579536412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1115562,"avatar":"https://static001.geekbang.org/account/avatar/00/11/05/aa/3c7c00a4.jpg","nickname":"GK java","note":"","ucode":"AA54E8CAAB974C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":412045,"discussion_content":"确实众口难调 😓😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636070967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2708005,"avatar":"https://static001.geekbang.org/account/avatar/00/29/52/25/185763e4.jpg","nickname":"薇尔莉特","note":"","ucode":"1465A6F3005CA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384916,"discussion_content":"都写不就行了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626791620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1735002,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/loOqiajRMDoBmMs8bLeIjfhwYN0DNf3ic7x92hw6mW5GWG3mVkw7ub52cqjvkVqt4Fq3fU0A2C7WcsS3icIlOd1fg/132","nickname":"Geek_宋","note":"","ucode":"B050CEE1BE9221","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289054,"discussion_content":"伪代码更纯粹","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593962436,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1754326,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/c4/d6/73656a64.jpg","nickname":"Geek_JOJO","note":"","ucode":"945C38ECF443B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79405,"discussion_content":"不过也要照顾一下我们这些，理解能力差的哦，哈哈哈😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576075037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":30871,"discussion_content":"看来有利也有弊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570866487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36320,"user_name":"The Sword of Damocles","can_delete":false,"product_type":"c1","uid":1188527,"ip_address":"","ucode":"42B462FC572F24","user_header":"https://static001.geekbang.org/account/avatar/00/12/22/af/1a31bc11.jpg","comment_is_top":false,"comment_ctime":1541037045,"is_pvip":false,"discussion_count":14,"race_medal":0,"score":"306483715061","product_id":100017301,"comment_content":"王道考研书上看到的快排算法，利用哨兵减少了交换两个元素的复杂步骤，效果更好一些<br>private static void quickSort(int[] a, int head, int tail) {<br><br>        int low = head;<br>        int high = tail;<br>        int pivot = a[low];<br>        if (low &lt; high) {<br><br>            while (low&lt;high) {<br>                while (low &lt; high &amp;&amp; pivot &lt;= a[high]) high--;<br>                a[low] = a[high];<br>                while (low &lt; high &amp;&amp; pivot &gt;= a[low]) low++;<br>                a[high]=a[low];<br>            }<br>            a[low] = pivot;<br><br>            if(low&gt;head+1) quickSort(a,head,low-1);<br>            if(high&lt;tail-1) quickSort(a,high+1,tail);<br>        }<br><br>    }","like_count":71,"discussions":[{"author":{"id":1238836,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e7/34/2640b1e4.jpg","nickname":"Leon","note":"","ucode":"AF26BB602B8705","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8334,"discussion_content":"我实测了你的代码和王争老师的代码，还是王争老师的代码更优。\n我随机产生150000条数据，三次时间对比(ms)：19:27，19:28, 19:30。\n\n王争老师的代码如下：\n\n    private static void quickWangZheng(int[] a, int p, int r) {\n        if (p >= r) {\n            return;\n        }\n        int pivot = a[r];\n        int i = p, j = p;\n        while (j < r) {\n            if (a[j] < pivot) {\n                swap(a, i, j); // 交换\n                i++;\n            }\n            j++;\n        }\n        swap(a, i, j); // 交换\n        quickWangZheng(a, p, i - 1);\n        quickWangZheng(a, i + 1, r);\n    }\n\n我想你的代码时间长主要在内层while里的判断条件执行时间上","likes_number":15,"is_delete":false,"is_hidden":false,"ctime":1567922498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1737903,"avatar":"","nickname":"Geek_b57cd1","note":"","ucode":"74D7E5C4269399","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1238836,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e7/34/2640b1e4.jpg","nickname":"Leon","note":"","ucode":"AF26BB602B8705","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50554,"discussion_content":"我测试了一下，随机数据从100k,到1000 000k 均是减少交换的效率最优","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573733877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":8334,"ip_address":""},"score":50554,"extra":""},{"author":{"id":1107423,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e5/df/0c8e3fdc.jpg","nickname":"小胖狗","note":"","ucode":"2C0CF3ED8E784A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1238836,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e7/34/2640b1e4.jpg","nickname":"Leon","note":"","ucode":"AF26BB602B8705","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56552,"discussion_content":"为什么不在第一个交换语句（第9行）前加个判断if（i ！=j），在数组前几个元素都小于poivt的时候，可以少些交换过程\n","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1574497169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":8334,"ip_address":""},"score":56552,"extra":""}]},{"author":{"id":1737903,"avatar":"","nickname":"Geek_b57cd1","note":"","ucode":"74D7E5C4269399","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":48513,"discussion_content":"这两种方法是单边扫描和双边扫描的区别","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1573484639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1240490,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ed/aa/67fbccda.jpg","nickname":"soulful","note":"","ucode":"93105631E8106A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1737903,"avatar":"","nickname":"Geek_b57cd1","note":"","ucode":"74D7E5C4269399","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":241135,"discussion_content":"马克","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587395070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":48513,"ip_address":""},"score":241135,"extra":""}]},{"author":{"id":1640978,"avatar":"https://static001.geekbang.org/account/avatar/00/19/0a/12/f8b988b8.jpg","nickname":"Kyle(","note":"","ucode":"0C14C4C086CAA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358372,"discussion_content":"我也测了150000条数据，确实王争老师的快，贴出代码，望多指教...    0.0 \n\n//  快排 —— 主方法\n    private static void quickSort2(int[] array, int head, int tail) {\n        if (head >= tail) {\n            return;\n        }\n\n        //  排序细节\n        int pivot = getPivot(array, head, tail);\n        \n        quickSort2(array, head, pivot - 1);\n        quickSort2(array, pivot + 1, tail);\n    }\n\n    //  快排 —— 排序细节方法\n    private static int getPivot(int[] array, int head, int tail) {\n        int pivotValue = array[tail];\n        int low = head;\n\n        for (int i = head; i < tail; i++) {\n            if (array[i] <= pivotValue) {\n                int tempValue = array[i];\n                array[i] = array[low];\n                array[low] = tempValue;\n                low++;\n            }\n        }\n        \n        array[tail] = array[low];\n        array[low] = pivotValue;\n\n        return low;\n\n    }","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1615973139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1781893,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/30/85/14c2f16c.jpg","nickname":"石小","note":"","ucode":"4258C686F289A6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335354,"discussion_content":"https://liam.page/2018/09/18/std-sort-in-STL/，是的，标准库函数也都是这样的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1608172374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1640978,"avatar":"https://static001.geekbang.org/account/avatar/00/19/0a/12/f8b988b8.jpg","nickname":"Kyle(","note":"","ucode":"0C14C4C086CAA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357915,"discussion_content":"这代码是真XX绕 ，我看了半天才看懂，注意那个while后分号的定义位置。555....","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1615896390,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1313181,"avatar":"https://static001.geekbang.org/account/avatar/00/14/09/9d/8af6cb1e.jpg","nickname":"臭猫","note":"","ucode":"5C3D1ED80055B7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279221,"discussion_content":"这个更复杂了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591314608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2249227,"avatar":"https://static001.geekbang.org/account/avatar/00/22/52/0b/50bf0f05.jpg","nickname":"橙子橙","note":"","ucode":"CD51367A14D955","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321477,"discussion_content":"所以计算机对于if和while指令 哪个更耗时...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604585326,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1108509,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ea/1d/87cb09a1.jpg","nickname":"CGJ","note":"","ucode":"4B5798C9197301","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294681,"discussion_content":"说错了，接前边  a[low] = a[high];的时候low++","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595953873,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1108509,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ea/1d/87cb09a1.jpg","nickname":"CGJ","note":"","ucode":"4B5798C9197301","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294678,"discussion_content":"hight --.的时候low是不是可以++，因为下一次比较的时候low是刚替换过去的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595953642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267954,"discussion_content":"交换复杂么？我觉得直接交换更直观，不交换就是挖坑法 完全是两种思路罢了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589717127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1396815,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/4f/78549650.jpg","nickname":"safly","note":"","ucode":"9A2439CEAD1DEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69243,"discussion_content":"马一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575275108,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35383,"user_name":"周茜(Diane)","can_delete":false,"product_type":"c1","uid":1241703,"ip_address":"","ucode":"401D6C8800F51A","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/67/fd7c8a97.jpg","comment_is_top":false,"comment_ctime":1540531752,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"297893275176","product_id":100017301,"comment_content":"看了十几节课，第一次留言竟然是支持老师写伪代码。捂脸。不希望被代表。另外希望总结的同学，尽量少写一点吧，翻着太累了。我也写总结，在自己的笔记应用里。默写。写完再查漏补缺。感觉效果很好，也能检查自己到底学进去多少。","like_count":70,"discussions":[{"author":{"id":1643982,"avatar":"https://static001.geekbang.org/account/avatar/00/19/15/ce/e8f626df.jpg","nickname":"我是菜鸟","note":"","ucode":"8F6FBDE6F58C1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":264029,"discussion_content":"周茜(Diane).   我宣你","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589282537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33565,"user_name":"曹源","can_delete":false,"product_type":"c1","uid":1042459,"ip_address":"","ucode":"A0A982159FF758","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e8/1b/9d1c6077.jpg","comment_is_top":false,"comment_ctime":1539826167,"is_pvip":false,"discussion_count":11,"race_medal":0,"score":"280712700407","product_id":100017301,"comment_content":"先取得十个文件时间戳的最小值数组的最小值a，和最大值数组的最大值b。然后取mid=(a+b)&#47;2，然后把每个文件按照mid分割，取所有前面部分之和，如果小于1g就可以读入内存快排生成中间文件，否则继续取时间戳的中间值分割文件，直到区间内文件之和小于1g。同理对所有区间都做同样处理。最终把生成的中间文件按照分割的时间区间的次序直接连起来即可。","like_count":66,"discussions":[{"author":{"id":1439120,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f5/90/e08bbe1f.jpg","nickname":"Wheres the Love?","note":"","ucode":"8851FB40976AB0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372217,"discussion_content":"整理一下：\n思路是每次从剩余部分中找出1g以内的最小部分放入内存快排。\n这个最小部分是找出所有剩余记录中的最小值和最大值，取中间值，然后在每个剩余文件中找出小于中值的部分。若找出的部分大于1g，则在找出的部分中继续分割。\n妙啊！充分利用了每个文件记录的有序性。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1620227339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2659807,"avatar":"https://static001.geekbang.org/account/avatar/00/28/95/df/a69492c2.jpg","nickname":"charles.ky","note":"","ucode":"F04D82B9B772E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548739,"discussion_content":"看了下一章回过来评论的，原来大佬说的这不就是桶排序吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643353608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1104921,"avatar":"https://static001.geekbang.org/account/avatar/00/10/dc/19/a8c2c709.jpg","nickname":"chenqk","note":"","ucode":"73FDF13AC5C17A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348343,"discussion_content":"好奇怪，每个文件都是有序，这种用归并算法，最优吧，为啥会先想到快排呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612517862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1939316,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/97/74/a933d664.jpg","nickname":"莜戏","note":"","ucode":"C3488A2BB44359","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1104921,"avatar":"https://static001.geekbang.org/account/avatar/00/10/dc/19/a8c2c709.jpg","nickname":"chenqk","note":"","ucode":"73FDF13AC5C17A","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":350866,"discussion_content":"原地","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614056887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":348343,"ip_address":""},"score":350866,"extra":""}]},{"author":{"id":1220566,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9f/d6/f66133b4.jpg","nickname":"吴贤龙","note":"","ucode":"45085FE86D6030","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268432,"discussion_content":"如果有一个日志文件，它的日志记录里，最小的时间戳，都比其他日志文件最大还大，那最终排序结果会有问题了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589775552,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1292087,"avatar":"https://static001.geekbang.org/account/avatar/00/13/b7/37/0290ff6e.jpg","nickname":"Veitor","note":"","ucode":"3397AC6D239195","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1220566,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9f/d6/f66133b4.jpg","nickname":"吴贤龙","note":"","ucode":"45085FE86D6030","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311615,"discussion_content":"没影响吧？已经把10个文件日志看做一个大的无序数组了，那么你所说某个日志文件里最小的值也比其他日志最大的还大也没影响啊。。只要计算出合适的中间值，就能用快排处理了。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602421415,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":268432,"ip_address":""},"score":311615,"extra":""},{"author":{"id":1665210,"avatar":"https://static001.geekbang.org/account/avatar/00/19/68/ba/d71be5bc.jpg","nickname":"Ari_Golovin","note":"","ucode":"CF888FA00C0DF8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1220566,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9f/d6/f66133b4.jpg","nickname":"吴贤龙","note":"","ucode":"45085FE86D6030","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":322905,"discussion_content":"是把每个文件按mid进行切分的，你的问题应该改成“某个文件的最小时间戳都比mid大”，就此讨论，那么这个文件整体就都不会优先进入内存中进行快排，而是让其他文件切分出来的小于mid时间戳的，且总和小于1G放到内存中进行快排","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604840897,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":268432,"ip_address":""},"score":322905,"extra":""}]},{"author":{"id":1042685,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/fd/abb7bfe3.jpg","nickname":"Langzi233","note":"","ucode":"5A21AC08FC089B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4018,"discussion_content":"这种利用快排思想来分区不错，但是这1gb的数据还需要继续排序，这个如何实现呢？嘿嘿","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565061649,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1046893,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f9/6d/b623562a.jpg","nickname":"霹雳大仙pp","note":"","ucode":"F654FD9AEC1D56","race_medal":3,"user_type":1,"is_pvip":false},"reply_author":{"id":1042685,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/fd/abb7bfe3.jpg","nickname":"Langzi233","note":"","ucode":"5A21AC08FC089B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":251004,"discussion_content":"重复上述步骤，往文件追加","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588057662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4018,"ip_address":""},"score":251004,"extra":""},{"author":{"id":2659807,"avatar":"https://static001.geekbang.org/account/avatar/00/28/95/df/a69492c2.jpg","nickname":"charles.ky","note":"","ucode":"F04D82B9B772E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1042685,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/fd/abb7bfe3.jpg","nickname":"Langzi233","note":"","ucode":"5A21AC08FC089B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548724,"discussion_content":"要不就按512M分区，然后用归并排序？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643341352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4018,"ip_address":""},"score":548724,"extra":""},{"author":{"id":2659807,"avatar":"https://static001.geekbang.org/account/avatar/00/28/95/df/a69492c2.jpg","nickname":"charles.ky","note":"","ucode":"F04D82B9B772E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1042685,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/fd/abb7bfe3.jpg","nickname":"Langzi233","note":"","ucode":"5A21AC08FC089B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548726,"discussion_content":"不对，让你误导了，答主已经说了，分出1G读取到内存中，先使用快排，再写出到中间文件。最后拼接所有中间文件，整体直接就是有序的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643341536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4018,"ip_address":""},"score":548726,"extra":""}]}]},{"had_liked":false,"id":142021,"user_name":"大汉","can_delete":false,"product_type":"c1","uid":1264290,"ip_address":"","ucode":"76CB9AF7AA5D24","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/a2/37640e95.jpg","comment_is_top":false,"comment_ctime":1571279688,"is_pvip":false,"replies":[{"id":"54898","content":"👍，加油💪","user_name":"作者回复","comment_id":142021,"uid":"1190123","ip_address":"","utype":1,"ctime":1571360039,"user_name_real":"王争"}],"discussion_count":8,"race_medal":0,"score":"259269317448","product_id":100017301,"comment_content":"我是一个笨的人，一节课要看很多遍，但是我知道，只要比聪明的人多看几遍，就也会达到同样的效果","like_count":61,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470957,"discussion_content":"👍，加油💪","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571360039,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1142025,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6d/09/ffeabc27.jpg","nickname":"任鑫","note":"","ucode":"9803EB15B634C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340438,"discussion_content":"共勉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610006594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1678394,"avatar":"https://static001.geekbang.org/account/avatar/00/19/9c/3a/c8eb09ca.jpg","nickname":"HEIWAN😘","note":"","ucode":"158862A45A520C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308724,"discussion_content":"多写效率会更高呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601045043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1675882,"avatar":"https://static001.geekbang.org/account/avatar/00/19/92/6a/dd37a054.jpg","nickname":"张y .","note":"","ucode":"85918469492F4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305800,"discussion_content":"共勉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600087995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1049017,"avatar":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","nickname":"学习学个屁","note":"","ucode":"DF2D61E6FB2FCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298931,"discussion_content":"共勉之~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597481827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1735002,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/loOqiajRMDoBmMs8bLeIjfhwYN0DNf3ic7x92hw6mW5GWG3mVkw7ub52cqjvkVqt4Fq3fU0A2C7WcsS3icIlOd1fg/132","nickname":"Geek_宋","note":"","ucode":"B050CEE1BE9221","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289055,"discussion_content":"加油，共勉之","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593962492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2004490,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/96/0a/6b91aced.jpg","nickname":"Life＇s DeSignEr","note":"","ucode":"D8A93F50DDC4AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288373,"discussion_content":"共勉！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593739048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1422682,"avatar":"https://static001.geekbang.org/account/avatar/00/15/b5/5a/bdb77b87.jpg","nickname":"大脸猫不爱吃鱼","note":"","ucode":"23A7D7F34741A0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":252285,"discussion_content":"共勉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588148475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32929,"user_name":"Jimbol","can_delete":false,"product_type":"c1","uid":1178008,"ip_address":"","ucode":"8D9190B3B3E08B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f9/98/95b13446.jpg","comment_is_top":false,"comment_ctime":1539736083,"is_pvip":false,"discussion_count":33,"race_medal":0,"score":"254942806547","product_id":100017301,"comment_content":"老师，有个问题没懂，在一个数组中找第k大的数这个问题中，为什么如果p+1=k，a[p]就是要查找的结果呢？","like_count":59,"discussions":[{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4520,"discussion_content":"因为第 k 大元素，p 是下标，第一次划分后，num[p] 左边是比 num[p] 小，num[p]  右边都是比 num[p]  大的数，第 k 大元素，在数组中的下标是 k - 1，如果 p = k - 1，那么 num[p]  就是第 k 大元素，故：p + 1 = K","likes_number":23,"is_delete":false,"is_hidden":false,"ctime":1565515171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1798068,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/6f/b4/d465acef.jpg","nickname":"啊噗！","note":"","ucode":"C911E772E1E800","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":146099,"discussion_content":"不是 应该是降序 第一次划分完后 num[p]左边都是比num[p] 大 这样第k大元素 数组下标才是p + 1","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1579597229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4520,"ip_address":""},"score":146099,"extra":""},{"author":{"id":1246938,"avatar":"https://static001.geekbang.org/account/avatar/00/13/06/da/17709131.jpg","nickname":"Mr.Z","note":"","ucode":"7F1E2EAA7C4FC1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303183,"discussion_content":"这个回答很好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599180224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4520,"ip_address":""},"score":303183,"extra":""},{"author":{"id":1246938,"avatar":"https://static001.geekbang.org/account/avatar/00/13/06/da/17709131.jpg","nickname":"Mr.Z","note":"","ucode":"7F1E2EAA7C4FC1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1798068,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/6f/b4/d465acef.jpg","nickname":"啊噗！","note":"","ucode":"C911E772E1E800","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303184,"discussion_content":"这个靠自己实现，这只是思想","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599180255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":146099,"ip_address":""},"score":303184,"extra":""}]},{"author":{"id":1121677,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/8d/9717e593.jpg","nickname":"一枝梅","note":"","ucode":"7DCE43B638EA6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4050,"discussion_content":"其实在这个问题上，是降序排序的，意思是a[0]是最大的，依次递减，第K大的元素其实就是索引为k-1的元素。","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1565082383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1136529,"avatar":"https://static001.geekbang.org/account/avatar/00/11/57/91/3a082914.jpg","nickname":"葡萄有点酸","note":"","ucode":"51C3CE1E685D8E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1121677,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/8d/9717e593.jpg","nickname":"一枝梅","note":"","ucode":"7DCE43B638EA6A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4370,"discussion_content":"不是降序 原因如“xu晓晨”所说","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565339469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4050,"ip_address":""},"score":4370,"extra":""},{"author":{"id":1595921,"avatar":"https://static001.geekbang.org/account/avatar/00/18/5a/11/56397685.jpg","nickname":"见思","note":"","ucode":"26F4428210F168","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1136529,"avatar":"https://static001.geekbang.org/account/avatar/00/11/57/91/3a082914.jpg","nickname":"葡萄有点酸","note":"","ucode":"51C3CE1E685D8E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24489,"discussion_content":"我觉得降序没问题，如果是升序排列，那第K大的数下标就是 nums.length - k","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1570157168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4370,"ip_address":""},"score":24489,"extra":""},{"author":{"id":1513887,"avatar":"https://static001.geekbang.org/account/avatar/00/17/19/9f/55770fd3.jpg","nickname":"瑞杰_Zhang🎋","note":"","ucode":"1DA514F5353741","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1136529,"avatar":"https://static001.geekbang.org/account/avatar/00/11/57/91/3a082914.jpg","nickname":"葡萄有点酸","note":"","ucode":"51C3CE1E685D8E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":27918,"discussion_content":"我觉得应该是降序才能说得通吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570678993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4370,"ip_address":""},"score":27918,"extra":""}]},{"author":{"id":1677187,"avatar":"https://static001.geekbang.org/account/avatar/00/19/97/83/845b48e2.jpg","nickname":"Allen_","note":"","ucode":"CA5E00E4644CD5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78346,"discussion_content":"你要找第六大的数，是不是你发现你现在的位置比你小的有五个，那么你就是第六大了？","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1575988233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1798068,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/6f/b4/d465acef.jpg","nickname":"啊噗！","note":"","ucode":"C911E772E1E800","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1677187,"avatar":"https://static001.geekbang.org/account/avatar/00/19/97/83/845b48e2.jpg","nickname":"Allen_","note":"","ucode":"CA5E00E4644CD5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":146091,"discussion_content":"不是啊 应该是降序才对 前面有比你大的五个数 那么你才是第六大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579596810,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":78346,"ip_address":""},"score":146091,"extra":""},{"author":{"id":1677187,"avatar":"https://static001.geekbang.org/account/avatar/00/19/97/83/845b48e2.jpg","nickname":"Allen_","note":"","ucode":"CA5E00E4644CD5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1798068,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/6f/b4/d465acef.jpg","nickname":"啊噗！","note":"","ucode":"C911E772E1E800","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":157833,"discussion_content":"不是非要降序，你知道比你小的有五个，你不用管那五个的顺序，只要比第六个小就行了啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580524527,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":146091,"ip_address":""},"score":157833,"extra":""},{"author":{"id":1489184,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b9/20/d1dc20ee.jpg","nickname":"悦","note":"","ucode":"4A9B638448F074","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1677187,"avatar":"https://static001.geekbang.org/account/avatar/00/19/97/83/845b48e2.jpg","nickname":"Allen_","note":"","ucode":"CA5E00E4644CD5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219168,"discussion_content":"假如你有两个弟弟，那么你排行第几？","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1585741281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":157833,"ip_address":""},"score":219168,"extra":""}]},{"author":{"id":1133055,"avatar":"https://static001.geekbang.org/account/avatar/00/11/49/ff/34a47dca.jpg","nickname":"4567890","note":"","ucode":"23BC97FD1DADF0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":222506,"discussion_content":"这个地方是有点儿歧义的，比如，数据序列 是  [1,2,3,4,5,6] ,那么，4 是第三大的数字还是第四大的数字呢？\n如果认为是第三大的数字，那么，第一大的数字是6，第二大的数字是5，第三大的数字是4....\n如果认为4是第4大的数字，那么，则 1是第一大的数字，2是第二大的数字，3是第三大的数字，4是第4大的数字；看了老师的描述之后，才发现，老师说的原来是 这一种~~~\n","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1586150397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1537064,"avatar":"https://static001.geekbang.org/account/avatar/00/17/74/28/f2bd28f7.jpg","nickname":"王小白","note":"","ucode":"31F29F3FFB6A06","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71707,"discussion_content":"下标从0开始，同学可以好好看下基础边05讲","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1575452173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1513945,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKoTDBX4a5u3Oc0zDpKDp6UbcYDcwAJXfBSmicqQwoyxaoVLEWzjIoUqYBiaDJHAYkO8icLtXqk4ibqKg/132","nickname":"xu晓晨","note":"","ucode":"EE0374EB48FBDC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1009,"discussion_content":"因为数组的下标是从0开始的 。比如求k=3，返回的p为2 实际上 是第三个数（0,1,2） 即p+1=k","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1562231683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238427,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/9b/e6d7934e.jpg","nickname":"Ω","note":"","ucode":"0590342FEBFCFB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":117506,"discussion_content":"还是有点看不太懂，快排的分区交换操作😯 ","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1578123274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1450864,"avatar":"https://static001.geekbang.org/account/avatar/00/16/23/70/91ac1a08.jpg","nickname":"wateruc","note":"","ucode":"78301BFA7C6088","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215136,"discussion_content":"如果存在相同元素呢？如：[1,1,3,4,4,2]","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1585289512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1611025,"avatar":"https://static001.geekbang.org/account/avatar/00/18/95/11/eb431e52.jpg","nickname":"沈康","note":"","ucode":"02AFA50738AB8E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1450864,"avatar":"https://static001.geekbang.org/account/avatar/00/16/23/70/91ac1a08.jpg","nickname":"wateruc","note":"","ucode":"78301BFA7C6088","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372989,"discussion_content":"好像确实不能有重复的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620558414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":215136,"ip_address":""},"score":372989,"extra":""},{"author":{"id":1121459,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1c/b3/6d10ba4f.jpg","nickname":"Running Man","note":"","ucode":"4DD2F6AF71327E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1450864,"avatar":"https://static001.geekbang.org/account/avatar/00/16/23/70/91ac1a08.jpg","nickname":"wateruc","note":"","ucode":"78301BFA7C6088","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392691,"discussion_content":"那就扫描前后索引即可。这还不简单。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631095175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":215136,"ip_address":""},"score":392691,"extra":""}]},{"author":{"id":1866485,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/7a/f5/54a5084b.jpg","nickname":"简单猫","note":"","ucode":"EA027D4C344E25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":231421,"discussion_content":"快查原理啊 排好序后 分治点在下标3-1 那么下标3-1 就是第3大。同理","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586794340,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1513887,"avatar":"https://static001.geekbang.org/account/avatar/00/17/19/9f/55770fd3.jpg","nickname":"瑞杰_Zhang🎋","note":"","ucode":"1DA514F5353741","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":27921,"discussion_content":"感觉说明是降序就没啥问题了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1570679056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1121459,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1c/b3/6d10ba4f.jpg","nickname":"Running Man","note":"","ucode":"4DD2F6AF71327E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1513887,"avatar":"https://static001.geekbang.org/account/avatar/00/17/19/9f/55770fd3.jpg","nickname":"瑞杰_Zhang🎋","note":"","ucode":"1DA514F5353741","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392692,"discussion_content":"跟降序没关系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631095262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":27921,"ip_address":""},"score":392692,"extra":""}]},{"author":{"id":1448864,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1b/a0/7c7d1b4a.jpg","nickname":"徐帅","note":"","ucode":"BDF904280E2330","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274,"discussion_content":"因为p是数组的下标","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1561379854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1239829,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eopQic30JDlkwNAAdPHYxF3HMico8zDtMsGnI7KkbM4oV7ib1Pt4ZJYSiaDEiaLGkzp4JgoHBb4s8GIZjw/132","nickname":"Matthew","note":"","ucode":"4B66882414337E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556155,"discussion_content":"1,2 ,3,4,5,6 第二大数是5，降序才说的通，升序，按分区得到的数是3","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647234756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121459,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1c/b3/6d10ba4f.jpg","nickname":"Running Man","note":"","ucode":"4DD2F6AF71327E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392693,"discussion_content":"再看一遍快排的原理就知道了。这节课的标题就是用快排的思想解决的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631095319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1447922,"avatar":"https://static001.geekbang.org/account/avatar/00/16/17/f2/f95eb1af.jpg","nickname":"天空","note":"","ucode":"BCAA50311B3C56","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":111676,"discussion_content":"回答的好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577803112,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1063216,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKic5YNSDAHibCjJvgBljJwQ3y5chP6ey4DmPEqVWvtFXhqr97zTWFkOJvA9XiaoUIfb56KWsaht4SPg/132","nickname":"bonntom","note":"","ucode":"E5100FC5613AFF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":35331,"discussion_content":"快排的分区操作的结果就是，哨兵左边是大于哨兵的所有元素，右边是小于哨兵的。所以哨兵本身是序列里面第n+1大元素，n等于左边的元素总数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571271705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1239829,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eopQic30JDlkwNAAdPHYxF3HMico8zDtMsGnI7KkbM4oV7ib1Pt4ZJYSiaDEiaLGkzp4JgoHBb4s8GIZjw/132","nickname":"Matthew","note":"","ucode":"4B66882414337E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1063216,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKic5YNSDAHibCjJvgBljJwQ3y5chP6ey4DmPEqVWvtFXhqr97zTWFkOJvA9XiaoUIfb56KWsaht4SPg/132","nickname":"bonntom","note":"","ucode":"E5100FC5613AFF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556154,"discussion_content":"1,2 ,3,4,5,6 第二大数是5，降序才说的通，升序，按分区得到的数是3","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647234527,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":35331,"ip_address":""},"score":556154,"extra":""}]},{"author":{"id":1506723,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLz3icr3mGs5ib8FbSPQZ2ic3ib90mHkd1btQrmGacZjJxfYXrerIdaTxglKyCicFzLcEAb6deC2cWjE5Q/132","nickname":"the geek","note":"","ucode":"71DECBC814A539","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1345,"discussion_content":"还有一点就是，这个p指的是分区元素，分区在第3个位置，则证明分区元素是第3大的元素","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562569414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1066430,"avatar":"https://static001.geekbang.org/account/avatar/00/10/45/be/c04a40ce.jpg","nickname":"3W1H","note":"","ucode":"F6B4864128103C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1506723,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLz3icr3mGs5ib8FbSPQZ2ic3ib90mHkd1btQrmGacZjJxfYXrerIdaTxglKyCicFzLcEAb6deC2cWjE5Q/132","nickname":"the geek","note":"","ucode":"71DECBC814A539","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52691,"discussion_content":"分区元素就是第N大元素吗 还是没怎么理解","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574078634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":1345,"ip_address":""},"score":52691,"extra":""}]}]},{"had_liked":false,"id":33152,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1539750985,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"199108246601","product_id":100017301,"comment_content":"坚持初衷，死磕就行，不退缩，不放弃！","like_count":46},{"had_liked":false,"id":36822,"user_name":"斗米担米","can_delete":false,"product_type":"c1","uid":1199203,"ip_address":"","ucode":"35BA47EF3B0C2E","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/63/f5988a98.jpg","comment_is_top":false,"comment_ctime":1541350823,"is_pvip":false,"replies":[{"id":"13078","content":"最后数据区间变成1的时候排序就完成了 我们看n经过了多少次分解会变成1","user_name":"作者回复","comment_id":36822,"uid":"1190123","ip_address":"","utype":1,"ctime":1541381716,"user_name_real":"gg"}],"discussion_count":3,"race_medal":0,"score":"181929977255","product_id":100017301,"comment_content":"当 T(n&#47;2^k)=T(1) 时，也就是 n&#47;2^k=1<br>这个为什么会等于T(1)啊","like_count":42,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428033,"discussion_content":"最后数据区间变成1的时候排序就完成了 我们看n经过了多少次分解会变成1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541381716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1621681,"avatar":"","nickname":"sjm","note":"","ucode":"5858BD141816D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220125,"discussion_content":"这个问题问出了我的心声，我习惯每次看完一篇都刷刷评论区，能解决我好多疑问。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1585836985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1268797,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5c/3d/e8325811.jpg","nickname":"对白","note":"","ucode":"3183E5ADBC794B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294696,"discussion_content":"我的理解是n是原序列长度，每次从中间分成左右两个子序列，重复以上步骤直到每个子序列只有一个元素为止，所以等于1。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595975801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33997,"user_name":"MARK","can_delete":false,"product_type":"c1","uid":1126900,"ip_address":"","ucode":"9F429C9C5FEE6A","user_header":"https://static001.geekbang.org/account/avatar/00/11/31/f4/467cf5d7.jpg","comment_is_top":false,"comment_ctime":1539941913,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"173338633753","product_id":100017301,"comment_content":"懵逼了，智商欠费，今天晚上死磕这篇了","like_count":40,"discussions":[{"author":{"id":1196695,"avatar":"https://static001.geekbang.org/account/avatar/00/12/42/97/45334aed.jpg","nickname":"如我所愿","note":"","ucode":"7AFA75F0299DC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384208,"discussion_content":"那天晚上弄明白没有","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626426280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34743,"user_name":"iswlqn","can_delete":false,"product_type":"c1","uid":1115991,"ip_address":"","ucode":"2ABB791F7DBF18","user_header":"https://static001.geekbang.org/account/avatar/00/11/07/57/4afabdcb.jpg","comment_is_top":false,"comment_ctime":1540279629,"is_pvip":false,"discussion_count":14,"race_medal":0,"score":"169044004173","product_id":100017301,"comment_content":"合并函数借助哨兵简化方法<br>传入的后两个数组各在尾部多放一个和原有最后值相同的值。\r循环改为：\rwhile i&lt;=q or j&lt;=r do{\r    if A[i] &lt;= A[j] and i&lt;=q {\r        tmp[k++] = A[i++]\r    }\r    else{\r        tmp[k++] = A[j++]\r    }\r}\r可以在while循环里完成两个数组的清空，不需要专用部分完成。","like_count":39,"discussions":[{"author":{"id":1169063,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d6/a7/ac23f5a6.jpg","nickname":"better","note":"","ucode":"AF1DB566EBB8A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":107179,"discussion_content":"// 要这样写，才对，利用哨兵简化代码\n    private fun mergeByGuard(a: Array<Int>, low: Int, mid: Int, high: Int) {\n        var a1 = Array(mid - low + 2) { 0 }\n        var a2 = Array(high - mid + 1) { 0 }\n        (low..mid).forEachIndexed { index, i ->\n            a1[index] = a[i]\n        }\n        (mid + 1..high).forEachIndexed { index, i ->\n            a2[index] = a[i]\n        }\n        // add guard\n        a1[a1.size - 1] = Int.MAX_VALUE\n        a2[a2.size - 1] = Int.MAX_VALUE\n\n        // 利用哨兵简化，如果左右部分的最后一个元素都是最大且相等，左边结束时右边也已经结束\n        var i = 0\n        var j = 0\n        var k = low\n        while (k <= high) {\n            if (a1[i] < a2[j]) {\n                a[k++] = a1[i++]\n            } else {\n                a[k++] = a2[j++]\n            }\n        }\n    }","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1577548026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1322881,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2f/81/131ea1e4.jpg","nickname":"王££","note":"","ucode":"9DADA7C5218A15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1169063,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d6/a7/ac23f5a6.jpg","nickname":"better","note":"","ucode":"AF1DB566EBB8A5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215117,"discussion_content":"这样仍然有问题,考虑[Integer.MAX,Integer.MAX,Integer.MAX,Integer.MAX]这种情况,没办法保证稳定性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585286932,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":107179,"ip_address":""},"score":215117,"extra":""}]},{"author":{"id":1031734,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/be/36/abb7bfe3.jpg","nickname":"xenoblade3","note":"","ucode":"620DD0491EEFF3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1381,"discussion_content":"这里没有看明白，对于j来说，多放一个A[r+1]=A[r]，假设j==r，将A[j]放入tmp[k]，下一次循环，A[r+1]仍然是小于当前A[i]，进入else分支，j再次+1变为r+2，就越界了呢","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1562591779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1245314,"avatar":"https://static001.geekbang.org/account/avatar/00/13/00/82/95528a96.jpg","nickname":"凉爽兄","note":"","ucode":"6248378B5944B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1031734,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/be/36/abb7bfe3.jpg","nickname":"xenoblade3","note":"","ucode":"620DD0491EEFF3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2488,"discussion_content":"将A[j]放入tmp[k]后，j=r+1,不满足j<+r,不会再进入循环了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563710094,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":1381,"ip_address":""},"score":2488,"extra":""},{"author":{"id":1737903,"avatar":"","nickname":"Geek_b57cd1","note":"","ucode":"74D7E5C4269399","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1245314,"avatar":"https://static001.geekbang.org/account/avatar/00/13/00/82/95528a96.jpg","nickname":"凉爽兄","note":"","ucode":"6248378B5944B9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":48469,"discussion_content":"有可能满足 i＜q, 若A[j] 的所有元素都小于A[i],就会导致A[j] 越界，应该最后添加的为最大数。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573482211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2488,"ip_address":""},"score":48469,"extra":""},{"author":{"id":1169063,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d6/a7/ac23f5a6.jpg","nickname":"better","note":"","ucode":"AF1DB566EBB8A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1737903,"avatar":"","nickname":"Geek_b57cd1","note":"","ucode":"74D7E5C4269399","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":106528,"discussion_content":"这代码有问题，我的就越界了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577539114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":48469,"ip_address":""},"score":106528,"extra":""}]},{"author":{"id":1004953,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/55/99/4bdadfd3.jpg","nickname":"Chloe","note":"","ucode":"C4848ED5B35752","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":235472,"discussion_content":"我试着用index做哨兵，多了点比较，但是省了另一个while循环\n```\ndef merge(A, p, q, r):\n    temp = [None] * (r - p + 1)\n    i = p\n    j = q+1\n    k = 0\n    while i <= q+1 and j <= r+1:\n        if i == q+1 and j<=r:\n            temp[k:r-p+1] = A[j:r+1]\n            break\n        if i<= q and j == r+1:\n            temp[k:r-p+1] = A[i:q+1]\n            break\n        if A[i] <= A[j]:\n            temp[k] = A[i]\n            i += 1\n        else:\n            temp[k] = A[j]\n            j += 1\n        k += 1\n\n    A[p:r+1] = temp[0:]\n\n    return A\n···","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587041559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1322881,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2f/81/131ea1e4.jpg","nickname":"王££","note":"","ucode":"9DADA7C5218A15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215119,"discussion_content":"使用哨兵之后反而更复杂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585287056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1498448,"avatar":"https://static001.geekbang.org/account/avatar/00/16/dd/50/8a4904c1.jpg","nickname":"绝艺","note":"","ucode":"E6AD129ABB2D79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":92776,"discussion_content":"对于i,A[q+1]可以是任意值，对于j，A[r+1]应为最大值，因此综合起来，直接加一个A[r+1]为最大值之后再恢复即可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576861073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1737903,"avatar":"","nickname":"Geek_b57cd1","note":"","ucode":"74D7E5C4269399","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50821,"discussion_content":"还有就是由于递归调用，一般不会将临时数组定义到里面，而是外层传递进来，所以这个技巧不常用😁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573777808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1657421,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJEGRf488zB6kRDic691OicZcr5tbice0wP4xMevdtYEcBJoS5wzG2cUXhicsXLvX8fmLfgvgVibofJM2w/132","nickname":"Geek_ff334e","note":"","ucode":"F35A9BC2B7F6B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37166,"discussion_content":"感觉只在A数组最后加上一个值，A[r+1]=A[r]，然后将if判断改为if i <=q and A[i]<=A[j]","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571536835,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1391669,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/UugWqfdZWfjhiaMNYicJmzvBKoGNctUo7WDLwtMIm2avXd7boRRMVa2aJMmibVibJDXBZNN7SzdZtC7hMbmF3BJbMQ/132","nickname":"南轲","note":"","ucode":"DFA3E67DD83516","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8885,"discussion_content":"感觉哨兵无论放什么值都可以把，只是为了给个结束标识","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568091896,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1631329,"avatar":"https://static001.geekbang.org/account/avatar/00/18/e4/61/80fd23f8.jpg","nickname":"whhbeyond","note":"","ucode":"EB82AB350E6490","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6353,"discussion_content":"两个哨兵要放最大值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566867962,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1185504,"avatar":"https://static001.geekbang.org/account/avatar/00/12/16/e0/7abad3cc.jpg","nickname":"星期八","note":"","ucode":"34A37F73A48E7F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1651,"discussion_content":"看不懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562765749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34553,"user_name":"姜威","can_delete":false,"product_type":"c1","uid":1244051,"ip_address":"","ucode":"C58EB9A5AD634D","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/93/f19a5364.jpg","comment_is_top":false,"comment_ctime":1540204509,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"164748961757","product_id":100017301,"comment_content":"三、快速排序<br>1.算法原理<br>快排的思想是这样的：如果要排序数组中下标从p到r之间的一组数据，我们选择p到r之间的任意一个数据作为pivot（分区点）。然后遍历p到r之间的数据，将小于pivot的放到左边，将大于pivot的放到右边，将povit放到中间。经过这一步之后，数组p到r之间的数据就分成了3部分，前面p到q-1之间都是小于povit的，中间是povit，后面的q+1到r之间是大于povit的。根据分治、递归的处理思想，我们可以用递归排序下标从p到q-1之间的数据和下标从q+1到r之间的数据，直到区间缩小为1，就说明所有的数据都有序了。<br>递推公式：quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)<br>终止条件：p &gt;= r<br>2.代码实现（参见下一条留言）<br>3.性能分析<br>1）算法稳定性：<br>因为分区过程中涉及交换操作，如果数组中有两个8，其中一个是pivot，经过分区处理后，后面的8就有可能放到了另一个8的前面，先后顺序就颠倒了，所以快速排序是不稳定的排序算法。比如数组[1,2,3,9,8,11,8]，取后面的8作为pivot，那么分区后就会将后面的8与9进行交换。<br>2）时间复杂度：最好、最坏、平均情况<br>快排也是用递归实现的，所以时间复杂度也可以用递推公式表示。<br>如果每次分区操作都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并的相同。<br>T(1) = C；   n=1 时，只需要常量级的执行时间，所以表示为 C。<br>T(n) = 2*T(n&#47;2) + n； n&gt;1<br>所以，快排的时间复杂度也是O(nlogn)。<br>如果数组中的元素原来已经有序了，比如1，3，5，6，8，若每次选择最后一个元素作为pivot，那每次分区得到的两个区间都是不均等的，需要进行大约n次的分区，才能完成整个快排过程，而每次分区我们平均要扫描大约n&#47;2个元素，这种情况下，快排的时间复杂度就是O(n^2)。<br>前面两种情况，一个是分区及其均衡，一个是分区极不均衡，它们分别对应了快排的最好情况时间复杂度和最坏情况时间复杂度。那快排的平均时间复杂度是多少呢？T(n)大部分情况下是O(nlogn)，只有在极端情况下才是退化到O(n^2)，而且我们也有很多方法将这个概率降低。<br>3）空间复杂度：快排是一种原地排序算法，空间复杂度是O(1)<br>四、归并排序与快速排序的区别<br>归并和快排用的都是分治思想，递推公式和递归代码也非常相似，那它们的区别在哪里呢？<br>1.归并排序，是先递归调用，再进行合并，合并的时候进行数据的交换。所以它是自下而上的排序方式。何为自下而上？就是先解决子问题，再解决父问题。<br>2.快速排序，是先分区，在递归调用，分区的时候进行数据的交换。所以它是自上而下的排序方式。何为自上而下？就是先解决父问题，再解决子问题。<br>五、思考<br>1.O(n)时间复杂度内求无序数组中第K大元素，比如4，2，5，12，3这样一组数据，第3大元素是4。<br>我们选择数组区间A[0...n-1]的最后一个元素作为pivot，对数组A[0...n-1]进行原地分区，这样数组就分成了3部分，A[0...p-1]、A[p]、A[p+1...n-1]。<br>如果如果p+1=K，那A[p]就是要求解的元素；如果K&gt;p+1，说明第K大元素出现在A[p+1...n-1]区间，我们按照上面的思路递归地在A[p+1...n-1]这个区间查找。同理，如果K&lt;p+1，那我们就在A[0...p-1]区间查找。<br>时间复杂度分析？<br>第一次分区查找，我们需要对大小为n的数组进行分区操作，需要遍历n个元素。第二次分区查找，我们需要对大小为n&#47;2的数组执行分区操作，需要遍历n&#47;2个元素。依次类推，分区遍历元素的个数分别为n、n&#47;2、n&#47;4、n&#47;8、n&#47;16......直到区间缩小为1。如果把每次分区遍历的元素个数累加起来，就是等比数列求和，结果为2n-1。所以，上述解决问题的思路为O(n)。<br>2.有10个访问日志文件，每个日志文件大小约为300MB，每个文件里的日志都是按照时间戳从小到大排序的。现在需要将这10个较小的日志文件合并为1个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述任务的机器内存只有1GB，你有什么好的解决思路能快速地将这10个日志文件合并？","like_count":38,"discussions":[{"author":{"id":2237957,"avatar":"https://static001.geekbang.org/account/avatar/00/22/26/05/9684ce6b.jpg","nickname":"Jupyter","note":"","ucode":"FFCF0F52FD9D41","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338043,"discussion_content":"麻烦还是别添加大块的评论，你要做笔记自己做，几乎每一讲都能看到你这么大块的评论真的很鸡肋，看的也很难受。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609159858,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1112415,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f9/5f/b0a125a9.jpg","nickname":"chp","note":"","ucode":"F0A2442230CD45","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283459,"discussion_content":"这样抄真没啥太大意义","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592277309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1317847,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1b/d7/868d26ce.jpg","nickname":"songhyunmin","note":"","ucode":"D5A98668CD8532","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353722,"discussion_content":"复制机。最后的思考问题最好写出来你的思路吧。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615196410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1514292,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1b/34/4d8c5694.jpg","nickname":"Movan","note":"","ucode":"D5A2E9E2E7A439","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":243675,"discussion_content":"兄弟你快排稳定性那里举了个特殊的例子，其实普遍的例子老师举了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587556150,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":43326,"user_name":"继业(Adrian)","can_delete":false,"product_type":"c1","uid":1021147,"ip_address":"","ucode":"D9BAF5F939A2B6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/94/db/4e658ce8.jpg","comment_is_top":false,"comment_ctime":1543214783,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"130392233663","product_id":100017301,"comment_content":"看到好多同学说建议不要为代码的。<br>我觉得专栏文章就是教你分析问题和解决问题的思路，具体的代码不是有作者贴出的github地址吗","like_count":31,"discussions":[{"author":{"id":1165817,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/f9/39492855.jpg","nickname":"阿阳","note":"","ucode":"20A35FB86B1C5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73846,"discussion_content":"对的，还在纠结伪代码的，真是醉了。伪代码是最容易看懂的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575600903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1483495,"avatar":"","nickname":"Dispy","note":"","ucode":"1BF7870B32AB15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250750,"discussion_content":"对的，分析问题和解决问题的思路才是王道","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588038289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34466,"user_name":"oldman","can_delete":false,"product_type":"c1","uid":1133711,"ip_address":"","ucode":"6BACE2832B4429","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/8f/a90b3969.jpg","comment_is_top":false,"comment_ctime":1540181251,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"126094232835","product_id":100017301,"comment_content":"我用python实现了归并排序和快速排序，代码如下：<br>归并排序：https:&#47;&#47;github.com&#47;lipeng1991&#47;testdemo&#47;blob&#47;master&#47;45_merge_sort.py<br>快速排序： https:&#47;&#47;github.com&#47;lipeng1991&#47;testdemo&#47;blob&#47;master&#47;23_quick_sort.py<br>欢迎一起探讨。今天又回想了一下上一节的三个排序和今天的两个排序，自己又动手画了一下图，实现了一下代码，确切来讲，要想很深的掌握这些东西是需要不断的回想，不断的训练来加深印象的，想想以前学习算法为什么会感觉那么的难，其实就是练的不够，不要太着急的一下子把所有的算法都实现一遍，温故而知新，跟着老师的这个专栏来，一点一点的啃，啃着现在的复习前面的，你会越来越有成就感，你会越来越自信，这就是建立在不断的训练的基础上的。","like_count":29,"discussions":[{"author":{"id":2359469,"avatar":"https://static001.geekbang.org/account/avatar/00/24/00/ad/c526566a.jpg","nickname":"JsAiLxy💓🌟","note":"","ucode":"03275A03DAF87E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357847,"discussion_content":"你这两个链接打不开","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615880939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128718,"user_name":"angel😇txy🤓","can_delete":false,"product_type":"c1","uid":1133702,"ip_address":"","ucode":"C0AEE0D8BAF7ED","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/86/3be94807.jpg","comment_is_top":false,"comment_ctime":1566954292,"is_pvip":true,"replies":[{"id":"48132","content":"👍","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1567118587,"ip_address":"","comment_id":128718,"utype":1}],"discussion_count":5,"race_medal":0,"score":"104646169396","product_id":100017301,"comment_content":"大家都说快排的伪代码不好理解，我用JAVA翻译了一下，实测通过，老师给个置顶哈。private static void quickSortC(int[] a, int p, int r) {<br>        if (p &gt;= r) {<br>            return;<br>        }<br>        int q = partition(a, p, r);<br>        quickSortC(a, p, q - 1);<br>        quickSortC(a, q + 1, r);<br>    }<br>    <br>    public static int partition(int[] a, int start, int end) {<br>        int pivot = a[end];<br>        int i = start;<br>        for (int j = start; j &lt; end; j++) {<br>            if (a[j] &lt; pivot) {<br>                swap(a, i, j);<br>                i = i + 1;<br>            }<br>        }<br>        swap(a, i, end);<br>        return i;<br>    }","like_count":24,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465074,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567118587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1103643,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d7/1b/f8b387ee.jpg","nickname":"olderwei","note":"","ucode":"9D66C179BD5BAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72993,"discussion_content":"if (a[j] < pivot) {\n   if (i != j) {\n        swap(a, i, j);\n        i = i + 1;\n   }\n}\n加一个i != j 的判断是不是可以避免不必要的交换","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575547416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1730160,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/O3Uf8dibBnKKzibgEhvvKs9vic0dBavSJzn79fZVtH0AxcUT09bvOAYvr2f7vecmwiao7BBGgE5p8lXHSoBMdmQuBw/132","nickname":"赵","note":"","ucode":"EAC4390FD95EF9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1103643,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d7/1b/f8b387ee.jpg","nickname":"olderwei","note":"","ucode":"9D66C179BD5BAB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274602,"discussion_content":"这个不能加，加了排序是错的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590593684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":72993,"ip_address":""},"score":274602,"extra":""},{"author":{"id":1053154,"avatar":"https://static001.geekbang.org/account/avatar/00/10/11/e2/38feb457.jpg","nickname":"人們說這都是浮雲可是浮雲真美麗。","note":"","ucode":"FA3493020FDB8E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1730160,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/O3Uf8dibBnKKzibgEhvvKs9vic0dBavSJzn79fZVtH0AxcUT09bvOAYvr2f7vecmwiao7BBGgE5p8lXHSoBMdmQuBw/132","nickname":"赵","note":"","ucode":"EAC4390FD95EF9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327319,"discussion_content":"i=i+1放到外面","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605790176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":274602,"ip_address":""},"score":327319,"extra":""}]},{"author":{"id":1178016,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f9/a0/2240fb2c.jpg","nickname":"capo","note":"","ucode":"6FD72DA5DBC220","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":249884,"discussion_content":"我看老师在github上面的代码在循环外面还有一个a[start] 和 a[end]的交换操作了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587970993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33785,"user_name":"见贤思齐","can_delete":false,"product_type":"c1","uid":1236129,"ip_address":"","ucode":"4FBF5BCB4A6384","user_header":"https://static001.geekbang.org/account/avatar/00/12/dc/a1/59b9d589.jpg","comment_is_top":false,"comment_ctime":1539884244,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"104619099348","product_id":100017301,"comment_content":"我测试出，伪代码中<br>&#39;<br>partition(A, p, r) {<br>  pivot := A[r]<br>  i := p<br>  for j := p to r-1 do {<br>    if A[j] &lt; pivot {<br>      swap A[i] with A[j]<br>      i := i+1<br>    }<br>  }<br>  swap A[i] with A[r]<br>  return i<br>&#39;<br><br>&#39;  for j := p to r-1 do &#39;<br><br>中的 r-1 应该是 r","like_count":24,"discussions":[{"author":{"id":1504652,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f5/8c/82fb5890.jpg","nickname":"抱小星","note":"","ucode":"BA7B0DAFDA4AF5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38399,"discussion_content":"pivot不参与比较","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571776338,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1220552,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9f/c8/0318c83e.jpg","nickname":"Geek_b617bf","note":"","ucode":"9BAFC3B184B1D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24803,"discussion_content":"如果是用<= 那么就是到r-1就可以了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1570266984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1249431,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Cwkic25ndkExxY3HvVjAaYKVzFRicv2X6TE2sjdqTBBmqeh7X8crIQe3SHPichvcayOCqI3PJ88yVuMNlD8VvkE3A/132","nickname":"even","note":"","ucode":"C976CFB2A0EBBF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1626,"discussion_content":"楼上的回答是对的，a[r]已经作为分区的基准放在pivot中，后面只对[p, r-1]区间的元素进行处理","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1562747763,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1031734,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/be/36/abb7bfe3.jpg","nickname":"xenoblade3","note":"","ucode":"620DD0491EEFF3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1359,"discussion_content":"你的结论并不对，r下标是用于保存pivot值的，所以for循环中不用它参与比较交换，最后再将r与i进行交换。for循环加上r循环体并不会进行执行什么作用，相反r不参与循环提醒我们在进行选择排序循环之前，应该先将pivot所在的元素交换到r，只对(p,r-1)区间的元素进行选择排序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562576790,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1220552,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9f/c8/0318c83e.jpg","nickname":"Geek_b617bf","note":"","ucode":"9BAFC3B184B1D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1031734,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/be/36/abb7bfe3.jpg","nickname":"xenoblade3","note":"","ucode":"620DD0491EEFF3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24802,"discussion_content":"不对吧,这里用的是 <r-1  那比较到r-2就停止了  那r-1这个元素就没有参与比较呀.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570266946,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":1359,"ip_address":""},"score":24802,"extra":""}]}]},{"had_liked":false,"id":33126,"user_name":"冷笑的花猫","can_delete":false,"product_type":"c1","uid":1119029,"ip_address":"","ucode":"6C368FBB577470","user_header":"https://static001.geekbang.org/account/avatar/00/11/13/35/45391914.jpg","comment_is_top":false,"comment_ctime":1539747806,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"83144126430","product_id":100017301,"comment_content":"老师您好，最后的思考题思路基本都是先拆成小文件，然后取出topK，最后再合并。疑惑的是内存不够，怎么读到内存中。如果不读到内存中该怎么实现，读不读到内存中的标准是什么？如果每个文件都是3g，内存只有1g，思路类似。老师能提供下详细的代码吗？相信绝大部分同学都有疑惑，谢谢。","like_count":19},{"had_liked":false,"id":32874,"user_name":"朱月俊","can_delete":false,"product_type":"c1","uid":1017707,"ip_address":"","ucode":"4DA0728B862FBD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/6b/0b6cd39a.jpg","comment_is_top":false,"comment_ctime":1539708515,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"74554152547","product_id":100017301,"comment_content":"假设这十个文件都在本地，同时打开这十个文件，每个文件加一个offset，每次比较十个文件中每个文件最新的一条日志，按照时间戳获取时间戳最小的一条日志，然后对应文件offset加1，按照这种方法可以把在内存很小的情况下读完文件，积累一定大小记录在内存后flush到磁盘。 ","like_count":17},{"had_liked":false,"id":139634,"user_name":"北顾-岛城","can_delete":false,"product_type":"c1","uid":1433568,"ip_address":"","ucode":"54ECB3E5E4073A","user_header":"https://static001.geekbang.org/account/avatar/00/15/df/e0/ce671992.jpg","comment_is_top":false,"comment_ctime":1570695105,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"70290171841","product_id":100017301,"comment_content":"老师开篇的问题对应leetcode第215题","like_count":16,"discussions":[{"author":{"id":2252088,"avatar":"https://static001.geekbang.org/account/avatar/00/22/5d/38/06404738.jpg","nickname":"尘飞扬","note":"","ucode":"45D2B267E7A150","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581565,"discussion_content":"多谢，确实是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658840892,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2914259,"avatar":"","nickname":"Geek_c2a2be","note":"","ucode":"ECAE3C732915CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572628,"discussion_content":"多谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652878480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33128,"user_name":"刘远通","can_delete":false,"product_type":"c1","uid":1253307,"ip_address":"","ucode":"4D3EE819E4B235","user_header":"https://static001.geekbang.org/account/avatar/00/13/1f/bb/c488d5db.jpg","comment_is_top":false,"comment_ctime":1539748051,"is_pvip":false,"replies":[{"id":"12048","content":"平均。你说的没错。最坏情况是你说的那样","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539788150,"ip_address":"","comment_id":33128,"utype":1}],"discussion_count":1,"race_medal":0,"score":"70259224787","product_id":100017301,"comment_content":"老师 这个地方我没看懂...<br>“第一次分区查找，我们需要对大小为 n 的数组执行分区操作，需要遍历 n 个元素。第二次分区查找，我们只需要对大小为 n&#47;2 的数组执行分区操作，需要遍历 n&#47;2 个元素。依次类推，分区遍历元素的个数分别为、n&#47;2、n&#47;4、n&#47;8、n&#47;16.……直到区间缩小为 1。”<br>这里讨论的是最平均的情况吗？ 最坏的情况可以n,n-1,...,1啊","like_count":16,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426940,"discussion_content":"平均。你说的没错。最坏情况是你说的那样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539788150,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32898,"user_name":"yaya","can_delete":false,"product_type":"c1","uid":1233856,"ip_address":"","ucode":"8C7FAC8F828BA4","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/c0/d38daa2d.jpg","comment_is_top":false,"comment_ctime":1539732961,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"70259209697","product_id":100017301,"comment_content":"以前写快排的时候总是喜欢用第一个元素作为k值，partion喜欢用找到左右不符合规则的元素再对调，第k大总是纠结于，下次递归应该是第几大，😂这些其实只要把最后一个元素作为key就可以简化代码了。这门课让我懂了以前好多不懂得小细节。应该说曾经认为自己懂了吧，尤其是排序这里。<br>思考题，由于本来十个部分就是有序的，利用十个index，把这十个读入内存比较，在里面选择最小的一个index增1，如果一个部分放完了，就继续放剩下的九个部分，直到只剩一个部分，再复制。","like_count":16,"discussions":[{"author":{"id":1249431,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Cwkic25ndkExxY3HvVjAaYKVzFRicv2X6TE2sjdqTBBmqeh7X8crIQe3SHPichvcayOCqI3PJ88yVuMNlD8VvkE3A/132","nickname":"even","note":"","ucode":"C976CFB2A0EBBF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1628,"discussion_content":"赞同，之前我也是选择第一个元素作为key，在这里看到原理快排还可以在细节中进一步优化","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1562747896,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1049017,"avatar":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","nickname":"学习学个屁","note":"","ucode":"DF2D61E6FB2FCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298932,"discussion_content":"以前自己了解的快排是费原地,对内存浪费极大,利用交换元素可以起到原地排序的效果,真是学到了...  以前的自己是多么不知天高地厚啊.... 一定要好好学习...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597481962,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1268797,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5c/3d/e8325811.jpg","nickname":"对白","note":"","ucode":"3183E5ADBC794B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294699,"discussion_content":"我以前写的快排都是伪快排，非原地排序算法，现在才知道要用分区函数实现交换得到基准值…","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595976026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39069,"user_name":"xr","can_delete":false,"product_type":"c1","uid":1145077,"ip_address":"","ucode":"FF78E9247C31ED","user_header":"https://static001.geekbang.org/account/avatar/00/11/78/f5/915d5442.jpg","comment_is_top":false,"comment_ctime":1542182229,"is_pvip":false,"replies":[{"id":"14119","content":"嗯嗯 感谢指出","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542280676,"ip_address":"","comment_id":39069,"utype":1}],"discussion_count":2,"race_medal":0,"score":"57376757077","product_id":100017301,"comment_content":"你可能会说，我有个很笨的办法，每次取数组中的最小值，将其移动到数组的最前面，然后在剩下的数组中继续找最小值，以此类推，执行 K 次，找到的数据不就是第 K 大元素了吗？<br><br>应该是每次取数组中的最“大”值放到前面吧，因为找的是第k大元素？","like_count":13,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428904,"discussion_content":"嗯嗯 感谢指出","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542280676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1512288,"avatar":"https://static001.geekbang.org/account/avatar/00/17/13/60/7ddff8e9.jpg","nickname":"留晴","note":"","ucode":"F2D39E8D4EE3FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563889,"discussion_content":"数据有重复怎么办","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650105083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36517,"user_name":"永昌","can_delete":false,"product_type":"c1","uid":1025006,"ip_address":"","ucode":"A572DDE33DFAD9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a3/ee/636415d8.jpg","comment_is_top":false,"comment_ctime":1541139275,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"57375714123","product_id":100017301,"comment_content":"开始进入课程深水区，看一遍是没那么容易明白滴","like_count":13,"discussions":[{"author":{"id":1238166,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/96/a5d775e9.jpg","nickname":"牧凉","note":"","ucode":"1F57A16E37C668","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378781,"discussion_content":"加油","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623399666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1049017,"avatar":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","nickname":"学习学个屁","note":"","ucode":"DF2D61E6FB2FCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298933,"discussion_content":"一起加油....","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597481999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35151,"user_name":"痛改前非","can_delete":false,"product_type":"c1","uid":1005412,"ip_address":"","ucode":"4509CB0BB892EE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/64/064dc124.jpg","comment_is_top":false,"comment_ctime":1540438877,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"57375013725","product_id":100017301,"comment_content":"请问merge() 合并函数如何借助哨兵进行优化处理？<br>","like_count":13},{"had_liked":false,"id":33604,"user_name":"煦暖","can_delete":false,"product_type":"c1","uid":1245418,"ip_address":"","ucode":"96D0B236C4148A","user_header":"https://static001.geekbang.org/account/avatar/00/13/00/ea/6ad346c1.jpg","comment_is_top":false,"comment_ctime":1539833542,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"57374408390","product_id":100017301,"comment_content":"对于“为什么如果p+1=k，a[p]就是要查找的结果呢？”的问题感到不解的同学，我想你是从小到大排序的，所以不理解p+1=k，a[p]就是要查找的结果，如果你是从大到小排序的就不难理解了。","like_count":13,"discussions":[{"author":{"id":1698557,"avatar":"https://static001.geekbang.org/account/avatar/00/19/ea/fd/89d3d0b5.jpg","nickname":"王昊哲","note":"","ucode":"AA2F4499BF6865","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":44497,"discussion_content":"问题来了，你以前就能写，还来买课学","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572954155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1101556,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ce/f4/5bfc786a.jpg","nickname":"Vilochen.","note":"","ucode":"19D9BF8534B480","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1698557,"avatar":"https://static001.geekbang.org/account/avatar/00/19/ea/fd/89d3d0b5.jpg","nickname":"王昊哲","note":"","ucode":"AA2F4499BF6865","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":48358,"discussion_content":"别人不一定以前就会写吧。。帮助大家回答问题不是好事吗？这还要嘲讽吗。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573475531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":44497,"ip_address":""},"score":48358,"extra":""},{"author":{"id":1698557,"avatar":"https://static001.geekbang.org/account/avatar/00/19/ea/fd/89d3d0b5.jpg","nickname":"王昊哲","note":"","ucode":"AA2F4499BF6865","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1101556,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ce/f4/5bfc786a.jpg","nickname":"Vilochen.","note":"","ucode":"19D9BF8534B480","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53931,"discussion_content":"不懂幽默吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574236992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":48358,"ip_address":""},"score":53931,"extra":""},{"author":{"id":1101556,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ce/f4/5bfc786a.jpg","nickname":"Vilochen.","note":"","ucode":"19D9BF8534B480","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1698557,"avatar":"https://static001.geekbang.org/account/avatar/00/19/ea/fd/89d3d0b5.jpg","nickname":"王昊哲","note":"","ucode":"AA2F4499BF6865","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72311,"discussion_content":"哦哦哦。我以为你嘲讽呢。理解错了。抱歉抱歉哦。不像微博有个狗头啥的。纯文字看不出来语气😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575473501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53931,"ip_address":""},"score":72311,"extra":""}]}]},{"had_liked":false,"id":50744,"user_name":"vate","can_delete":false,"product_type":"c1","uid":1350662,"ip_address":"","ucode":"CF58A098791D06","user_header":"https://static001.geekbang.org/account/avatar/00/14/9c/06/f09b6248.jpg","comment_is_top":false,"comment_ctime":1545037727,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"44494710687","product_id":100017301,"comment_content":"感觉如果是一次读取一批数据出来的话，最后计算出来的结果都会有问题，因为你无法预料某个文件下一批的日志是不是时间戳在当前这一批数据之中，所以基本上运算的单元都只能像那位同学说的一样，一次每个日志只能取出一条数据，然后十条进行排序取出最小的，但是如果单纯这样处理会导致磁盘IO大幅度的提升，极度影响性能，建议是分批读取数据到内存中(数据量暂未考虑),然后对内存中的这一批数据一条一条取出来进行计算，如果某一IO流对应的数据计算完了则继续从日志中再取出一批，这样既减少了磁盘IO提升效率，也保证了数据的准确性。","like_count":10},{"had_liked":false,"id":36358,"user_name":"ldd","can_delete":false,"product_type":"c1","uid":1208157,"ip_address":"","ucode":"E8344FAFFE5CF3","user_header":"https://static001.geekbang.org/account/avatar/00/12/6f/5d/f0a19f09.jpg","comment_is_top":false,"comment_ctime":1541055920,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"44490728880","product_id":100017301,"comment_content":"归并排序的merge操作使用哨兵解法：<br>用两个数组存着左右已经排序好的数，然后在后面各自都加上哨兵（这边可以放一个无限大的值），最后两个数组分别对比，替换掉p-q的数据，代码如下：<br><br>    &#47;&#47; 哨兵解法<br>    func mergeWithPlaceholder(_ items: inout Array&lt;Int&gt;, _ start: Int, _ mid: Int, _ end: Int) {<br>        var leftArr: Array&lt;Int&gt; = Array()<br>        var rightArr: Array&lt;Int&gt; = Array()<br>        var i = 0<br>        var j = 0<br>        <br>        &#47;&#47; 在两个数组后面各加上哨兵(最大值)，当一个数组到达哨兵位置后，就再也不会往后移动了，因为已经是最大的数值了<br>        for index in start...mid {<br>            leftArr.append(items[index])<br>        }<br>        leftArr.append(Int(INT_MAX))<br>        <br>        for index in mid+1...end {<br>            rightArr.append(items[index])<br>        }<br>        rightArr.append(Int(INT_MAX))<br>        <br>        for index in start...end {<br>            if leftArr[i] &lt; rightArr[j] {<br>                items[index] = leftArr[i]<br>                i += 1<br>            } else {<br>                items[index] = rightArr[j]<br>                j += 1<br>            }<br>        }<br>    }","like_count":10,"discussions":[{"author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267961,"discussion_content":"归并的那个哨兵根本就没起作用，俩个复制数组又没有越界问题相当于没用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589717380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1208157,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6f/5d/f0a19f09.jpg","nickname":"ldd","note":"","ucode":"E8344FAFFE5CF3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287344,"discussion_content":"可以走下 leftArr=[1,2,3] rightArr=[4,5,6] 这种情况，如果没有哨兵就需要判断i和j是否越界的情况，有哨兵就可以不用判断了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593421573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":267961,"ip_address":""},"score":287344,"extra":""}]},{"author":{"id":1263410,"avatar":"https://static001.geekbang.org/account/avatar/00/13/47/32/4a47048a.jpg","nickname":"果树和溪流","note":"","ucode":"906C26641A0133","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7779,"discussion_content":"你这个哨兵INT_MAX，是不是没起作用啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567671648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1655300,"avatar":"https://static001.geekbang.org/account/avatar/00/19/42/04/c3afd674.jpg","nickname":"Minos","note":"","ucode":"C4619192861A1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1263410,"avatar":"https://static001.geekbang.org/account/avatar/00/13/47/32/4a47048a.jpg","nickname":"果树和溪流","note":"","ucode":"906C26641A0133","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24191,"discussion_content":"因为有了这个哨兵，左右两个数组才不会越界","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570028627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7779,"ip_address":""},"score":24191,"extra":""},{"author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1655300,"avatar":"https://static001.geekbang.org/account/avatar/00/19/42/04/c3afd674.jpg","nickname":"Minos","note":"","ucode":"C4619192861A1A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267956,"discussion_content":"他说的没问题；这是俩个复制数组再复制回去控制好大小就完了，这么弄烧饼根本就没用上和不用一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589717224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":24191,"ip_address":""},"score":267956,"extra":""},{"author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1263410,"avatar":"https://static001.geekbang.org/account/avatar/00/13/47/32/4a47048a.jpg","nickname":"果树和溪流","note":"","ucode":"906C26641A0133","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267959,"discussion_content":"对就是没用上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589717235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7779,"ip_address":""},"score":267959,"extra":""}]}]},{"had_liked":false,"id":99899,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1559355646,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40214061310","product_id":100017301,"comment_content":"案例都是从小到大排序，在找第k大的例子中是从大到小排序吧，应该说明一下","like_count":9},{"had_liked":false,"id":34552,"user_name":"姜威","can_delete":false,"product_type":"c1","uid":1244051,"ip_address":"","ucode":"C58EB9A5AD634D","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/93/f19a5364.jpg","comment_is_top":false,"comment_ctime":1540204390,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40194910054","product_id":100017301,"comment_content":"总结：归并排序和快速排序<br>一、分治思想<br>1.分治思想：分治，顾明思意，就是分而治之，将一个大问题分解成小的子问题来解决，小的子问题解决了，大问题也就解决了。<br>2.分治与递归的区别：分治算法一般都用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧。<br>二、归并排序<br>1.算法原理<br>先把数组从中间分成前后两部分，然后对前后两部分分别进行排序，再将排序好的两部分合并到一起，这样整个数组就有序了。这就是归并排序的核心思想。如何用递归实现归并排序呢？写递归代码的技巧就是分写得出递推公式，然后找到终止条件，最后将递推公式翻译成递归代码。递推公式怎么写？如下<br>递推公式：merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))<br>终止条件：p &gt;= r 不用再继续分解<br>2.代码实现（参见下一条留言）<br>3.性能分析<br>1）算法稳定性：<br>归并排序稳不稳定关键要看merge()函数，也就是两个子数组合并成一个有序数组的那部分代码。在合并的过程中，如果 A[p…q] 和 A[q+1…r] 之间有值相同的元素，那我们就可以像伪代码中那样，先把 A[p…q] 中的元素放入tmp数组，这样 就保证了值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一种稳定排序算法。<br>2）时间复杂度：分析归并排序的时间复杂度就是分析递归代码的时间复杂度<br>如何分析递归代码的时间复杂度？<br>递归的适用场景是一个问题a可以分解为多个子问题b、c，那求解问题a就可以分解为求解问题b、c。问题b、c解决之后，我们再把b、c的结果合并成a的结果。若定义求解问题a的时间是T(a)，则求解问题b、c的时间分别是T(b)和T(c)，那就可以得到这样的递推公式：T(a) = T(b) + T(c) + K，其中K等于将两个子问题b、c的结果合并成问题a的结果所消耗的时间。这里有一个重要的结论：不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。套用这个公式，那么归并排序的时间复杂度就可以表示为：<br>T(1) = C；   n=1 时，只需要常量级的执行时间，所以表示为 C。<br>T(n) = 2*T(n&#47;2) + n； n&gt;1，其中n就是merge()函数合并两个子数组的的时间复杂度O(n)。<br>T(n) = 2*T(n&#47;2) + n<br>     = 2*(2*T(n&#47;4) + n&#47;2) + n = 4*T(n&#47;4) + 2*n<br>     = 4*(2*T(n&#47;8) + n&#47;4) + 2*n = 8*T(n&#47;8) + 3*n<br>     = 8*(2*T(n&#47;16) + n&#47;8) + 3*n = 16*T(n&#47;16) + 4*n<br>     ......<br>     = 2^k * T(n&#47;2^k) + k * n<br>     ......<br>当T(n&#47;2^k)=T(1) 时，也就是 n&#47;2^k=1，我们得到k=log2n。将k带入上面的公式就得到T(n)=Cn+nlog2n。如用大O表示法，T(n)就等于O(nlogn)。所以，归并排序的是复杂度时间复杂度就是O(nlogn)。<br>3）空间复杂度：归并排序算法不是原地排序算法，空间复杂度是O(n)<br>为什么？因为归并排序的合并函数，在合并两个数组为一个有序数组时，需要借助额外的存储空间。为什么空间复杂度是O(n)而不是O(nlogn)呢？如果我们按照分析递归的时间复杂度的方法，通过递推公式来求解，那整个归并过程需要的空间复杂度就是O(nlogn)，但这种分析思路是有问题的！因为，在实际上，递归代码的空间复杂度并不是像时间复杂度那样累加，而是这样的过程，即在每次合并过程中都需要申请额外的内存空间，但是合并完成后，临时开辟的内存空间就被释放掉了，在任意时刻，CPU只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时空间再大也不会超过n个数据的大小，所以空间复杂度是O(n)。","like_count":9},{"had_liked":false,"id":33232,"user_name":"lovedebug","can_delete":false,"product_type":"c1","uid":1004115,"ip_address":"","ucode":"292FB1FD078AE8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/53/a9918d0b.jpg","comment_is_top":false,"comment_ctime":1539762583,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40194468247","product_id":100017301,"comment_content":"建议为github上代码示例都加上最好&#47;最坏&#47;平均时间复杂度，方便自己分析","like_count":9},{"had_liked":false,"id":33535,"user_name":"伟忠","can_delete":false,"product_type":"c1","uid":1112089,"ip_address":"","ucode":"FE77CF20ED6065","user_header":"https://static001.geekbang.org/account/avatar/00/10/f8/19/05a2695f.jpg","comment_is_top":false,"comment_ctime":1539822836,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35899561204","product_id":100017301,"comment_content":"日志文件本身在各个机器上是拆好，并且有序的，利用归并排序思想，只要合并文件就行。<br>可以两两合并最终成一个文件。<br>还有一个更省内存的办法，所有日志都打开按行读取，比较n个文件第一行，得到哪个最小，直接写入最小的到汇总结果文件中，对应文件读下一行，如此一直到所有文件读完，也就合并完了","like_count":8},{"had_liked":false,"id":34554,"user_name":"姜威","can_delete":false,"product_type":"c1","uid":1244051,"ip_address":"","ucode":"C58EB9A5AD634D","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/93/f19a5364.jpg","comment_is_top":false,"comment_ctime":1540204566,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"31604975638","product_id":100017301,"comment_content":"代码实现<br>1.归并排序<br>&#47;&#47; 归并排序算法, A 是数组，n 表示数组大小<br>merge_sort(A, n) {<br>  merge_sort_c(A, 0, n-1)<br>}<br>&#47;&#47; 递归调用函数<br>merge_sort_c(A, p, r) {<br>  &#47;&#47; 递归终止条件<br>  if p &gt;= r  then return<br>  &#47;&#47; 取 p 到 r 之间的中间位置 q<br>  q = (p+r) &#47; 2<br>  &#47;&#47; 分治递归<br>  merge_sort_c(A, p, q)<br>  merge_sort_c(A, q+1, r)<br>  &#47;&#47; 将 A[p...q] 和 A[q+1...r] 合并为 A[p...r]<br>  merge(A[p...r], A[p...q], A[q+1...r])<br>}<br>merge(A[p...r], A[p...q], A[q+1...r]) {<br>  var i := p，j := q+1，k := 0 &#47;&#47; 初始化变量 i, j, k<br>  var tmp := new array[0...r-p] &#47;&#47; 申请一个大小跟 A[p...r] 一样的临时数组<br>  while i&lt;=q AND j&lt;=r do {<br>    if A[i] &lt;= A[j] {<br>      tmp[k++] = A[i++] &#47;&#47; i++ 等于 i:=i+1<br>    } else {<br>      tmp[k++] = A[j++]<br>    }<br>  }<br>  &#47;&#47; 判断哪个子数组中有剩余的数据<br>  var start := i，end := q<br>  if j&lt;=r then start := j, end:=r<br>  &#47;&#47; 将剩余的数据拷贝到临时数组 tmp<br>  while start &lt;= end do {<br>    tmp[k++] = A[start++]<br>  }<br>  &#47;&#47; 将 tmp 中的数组拷贝回 A[p...r]<br>  for i:=0 to r-p do {<br>    A[p+i] = tmp[i]<br>  }<br>}<br>注：merge()合并函数如果借助哨兵代码就会简洁很多<br><br>2.快速排序<br>&#47;&#47; 快速排序，A 是数组，n 表示数组的大小<br>quick_sort(A, n) {<br>  quick_sort_c(A, 0, n-1)<br>}<br>&#47;&#47; 快速排序递归函数，p,r 为下标<br>quick_sort_c(A, p, r) {<br>  if p &gt;= r then return<br>  q = partition(A, p, r) &#47;&#47; 获取分区点<br>  quick_sort_c(A, p, q-1)<br>  quick_sort_c(A, q+1, r)<br>}<br>&#47;&#47;分区函数<br>partition(A, p, r) {<br>  pivot := A[r]<br>  i := p<br>  for j := p to r-1 do {<br>    if A[j] &lt; pivot {<br>      swap A[i] with A[j]<br>      i := i+1<br>    }<br>  }<br>  swap A[i] with A[r]<br>  return i<br>}<br>分区函数代码说明：通过游标i把A[p...r-1]分成2部分，A[p...i-1]的元素都是小于pivot的，我们暂且叫它“已处理区间”，A[i+1...r-1]是“未处理区间”。我们每次都从未处理区间取出一个元素A[j]，与poivt相比，如果小于pivot，则将其加入到已处理区间的尾部，也就是A[i]位置。","like_count":7,"discussions":[{"author":{"id":1631982,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLDCC4yia65GicuukzgdZv34Zib2tXcfuBhkG3iaYBzJJRWQRPBLysR95WRD6RBibQfwHQvyDyP8fHAhkrA/132","nickname":"Geek_8a7668","note":"","ucode":"BBDBE125345CF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6941,"discussion_content":"那个快速排序，为啥最后不返回结果，感觉在不停的获取分区点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567181958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78359,"user_name":"张潇赟","can_delete":false,"product_type":"c1","uid":1132192,"ip_address":"","ucode":"1A45B57F9E0723","user_header":"https://static001.geekbang.org/account/avatar/00/11/46/a0/aa6d4ecd.jpg","comment_is_top":false,"comment_ctime":1553133282,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"27322937058","product_id":100017301,"comment_content":"找第N大数据java版本代码<br>&#47;**<br>     * 查找一个数组中第N大的数<br>     * 利用快速排序查找positon的方法，将大于最后一个元素的全部数据放在左边，小于最后一个元素的全部数据放在右边<br>     * 如果第一次找到的postion为q（下标），那么以为着q左边有q个元素且左边的数全部大于a[q],<br>     * 那么如果q+1=N，则a[q]为第N大数<br>     * 如果q+1&gt;N,则第N大数在q左边，反之在q右边<br>     * @param a<br>     *&#47;<br>    public static int findMaxN(int[] a, int n){<br>        int res ;<br>        int partion = partionByGt(a, 0, a.length - 1);<br>        while (partion + 1 != n) {<br>            if (partion + 1 &gt; n) {<br>                partion = partionByGt(a, 0, partion - 1);<br>            }else{<br>                partion = partionByGt(a, partion+1, a.length-1);<br>            }<br>        }<br>        res = a[partion];<br>        return res;<br>    }<br>    &#47;**<br>     * 和partionIndex方法逻辑大致一样，判断条件为大于<br>     * 将大于分区值得数全部移位到左边<br>     * @param a<br>     * @param startIndex<br>     * @param endIndex<br>     * @return<br>     *&#47;<br>    private static int partionByGt(int[] a, int startIndex,int endIndex) {<br>        int i = startIndex;<br>        int j = startIndex;<br>        int temp ;<br>        for (; j &lt; endIndex; j++) {<br>            if (a[j] &gt; a[endIndex]) {<br>                if (i != j) {<br>                    temp = a[j];<br>                    a[j] = a[i];<br>                    a[i] = temp;<br>                }<br>                i+=1;<br>            }<br>        }<br>        temp = a[endIndex ];<br>        a[endIndex] = a[i];<br>        a[i] = temp;<br>        return i;<br>    }","like_count":6,"discussions":[{"author":{"id":1983637,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/44/95/adeb0f94.jpg","nickname":"罗罗诺亚","note":"","ucode":"659DB96518A3DB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547467,"discussion_content":"import java.util.Arrays;\n\npublic class QuickSort {\n    public static void main(String[] args) {\n        int[] arr = new int[]{9, 7, 6, 6, 5, 5, 5, 4, 1, 10};\n        int kvalue = kValue(arr,2);\n        System.out.println( kvalue);\n\n        quicksort(arr,0,arr.length-1);\n        System.out.println(&#34;Arrays.toString(arr) = &#34; + Arrays.toString(arr));\n    }\n\n    public static void quicksort(int[] arr,int L,int R) {\n        if(L &lt; R){\n            int[] M= partition(arr,L,R);\n            quicksort(arr,L,M[1]-1);\n            quicksort(arr,M[1]+1,R);\n        }\n    }\n    public static int kValue(int[] arr,int K) {\n        int target = K-1;\n        int[] part = partition(arr,0,arr.length-1);\n        while ( target != part[1] ){\n            if( target &lt; part[1]){\n                part = partition(arr,part[0],part[1]-1);\n            }else{\n                part = partition(arr,part[1]+1,part[2]);\n            }\n        }\n        return arr[part[1]];\n    }\n    \n\n    public static int[] partition(int[] arr,int L,int R) {\n        int pivot = arr[R];\n        int j = L;\n        for (int i = L; i &lt; R; i++) {\n            if(arr[i] &gt; pivot){\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n                j++;\n            }            \n        }\n        arr[R] = arr[j];\n        arr[j] = pivot;\n        return new int[]{L,j,R};\n    }\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642685762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1983637,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/44/95/adeb0f94.jpg","nickname":"罗罗诺亚","note":"","ucode":"659DB96518A3DB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547462,"discussion_content":"这个实现有问题的，测试一下：int[] a = new int[]{1,0,5,5,7}，陷入死循环了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642683944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33859,"user_name":"A_阿海","can_delete":false,"product_type":"c1","uid":1239200,"ip_address":"","ucode":"5594C992D7E6E9","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/a0/c2daafdb.jpg","comment_is_top":false,"comment_ctime":1539911926,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27309715702","product_id":100017301,"comment_content":"回答一下p＋1 等于 K，那么A［p］就是那个要求解的问题。 题目说的是第K大，注意，这个第K大是从1开始数的，而在数组中，是有第0个元素的，所以，刚好差1。","like_count":6},{"had_liked":false,"id":63008,"user_name":"S.A.N","can_delete":false,"product_type":"c1","uid":1248420,"ip_address":"","ucode":"0A1F6AB8618FDB","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/a4/a5f3bb1f.jpg","comment_is_top":false,"comment_ctime":1548226013,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23023062493","product_id":100017301,"comment_content":"在李建辉的回答上，做些优化：<br>1. 开10个文件通道，初始每个通道加载100M的日志到内存，充分利用内存，实现高速读写<br>2. 创建一个数组，容量为10，读取内存中每个文件的首位记录，放入数组并升序排序<br>3. 取数组首位记录，写入新文件<br>4. 从数组首位记录所属文件读取首位记录，使用二分查找插入有序数组<br>5. 重复步骤三<br>6. 如果内存中的某个文件内存记录读取完毕，则遍历所有文件内存，从磁盘中加载日志记录到内存，保持每个文件100M内存记录，直至整个文件读取完毕","like_count":5},{"had_liked":false,"id":35553,"user_name":"梁成志（鹏金所）","can_delete":false,"product_type":"c1","uid":1240999,"ip_address":"","ucode":"EAC76707536627","user_header":"https://static001.geekbang.org/account/avatar/00/12/ef/a7/07dce4a9.jpg","comment_is_top":false,"comment_ctime":1540653572,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23015490052","product_id":100017301,"comment_content":"学伪代码好，我可以按照老师的思路再实现出来，自己还有成就感，又可以学习。","like_count":5},{"had_liked":false,"id":32953,"user_name":"jon","can_delete":false,"product_type":"c1","uid":1253287,"ip_address":"","ucode":"5768A34E292CAA","user_header":"https://static001.geekbang.org/account/avatar/00/13/1f/a7/d379ca4f.jpg","comment_is_top":false,"comment_ctime":1539737786,"is_pvip":false,"replies":[{"id":"12052","content":"终止条件是T（1）。我们要不这个公式最终化简成T（1）的函数。当n&#47;2^k=1时 那就化简成T（1）的函数了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539788690,"ip_address":"","comment_id":32953,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23014574266","product_id":100017301,"comment_content":"归并时间复杂度推导时当 T(n&#47;2^k)=T(1) 时。  这里没看懂能解释一下吗","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426919,"discussion_content":"终止条件是T（1）。我们要不这个公式最终化简成T（1）的函数。当n/2^k=1时 那就化简成T（1）的函数了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539788690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1082000,"avatar":"https://static001.geekbang.org/account/avatar/00/10/82/90/e4a08b0e.jpg","nickname":"KangShan","note":"","ucode":"07497A7AC92238","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":277142,"discussion_content":"k = lbn 应该算已经条件吧，递归二分数组跳出条件是数组被分割成 2 个元素","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591006578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213445,"user_name":"沐风","can_delete":false,"product_type":"c1","uid":1463926,"ip_address":"","ucode":"6675574198ABCE","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/76/e8200041.jpg","comment_is_top":false,"comment_ctime":1588416545,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18768285729","product_id":100017301,"comment_content":"伪代码的Java版本：<br>1. 归并排序：<br>public int[] sort(int[] array, int n) {<br>        if (n &lt; 1) return  null;<br>        mergeSort(array, 0, n-1);<br>        return array;<br>    }<br>    private void mergeSort(int[] array, int start, int end) {<br>        if (start &gt;= end) return;<br>        int mid = (start + end) &#47; 2;<br>        mergeSort(array, start, mid);<br>        mergeSort(array, mid+1, end);<br>        merge(array, start, mid, end);<br>    }<br>    private void merge(int[] array, int start, int mid, int end) {<br>        int[] temp = new int[end - start + 1];<br>        int k = 0;<br>        int left = start;<br>        int right = mid + 1;<br>        while (left &lt;= mid &amp;&amp; right &lt;= end) {<br>            if (array[left] &lt;= array[right]) { <br>                temp[k++] = array[left++];<br>            } else  {<br>                temp[k++] = array[right++];<br>            }<br>        }<br>        int restStartIndex = left;<br>        int restEndIndex = mid;<br>        if (right &lt;= end) {<br>            restStartIndex = right;<br>            restEndIndex = end;<br>        }<br>        while (restStartIndex &lt;= restEndIndex) {<br>            temp[k++] = array[restStartIndex++];<br>        }<br>        for (int i = 0; i &lt; end - start + 1; i++) {<br>            array[start+i] = temp[i];<br>        }<br><br>    }<br>2. 快速排序：<br>    private void quickSort(int[] array, int start, int end) {<br>        if (start &gt;= end) return;<br>        int position = partition(array, start, end);<br>        quickSort(array, start, position-1);<br>        quickSort(array, position+1, end);<br>    }<br>    private int partition(int[] array, int start, int end) {<br>        int pivot = array[end];<br>        int left = start;<br>        for (int i = start; i &lt; end; i++) {<br>            if (array[i] &lt; pivot) {<br>                int temp = array[left];<br>                array[left++] = array[i];<br>                array[i] = temp;<br>            }<br>        }<br>        int temp = array[left];<br>        array[left] = pivot;<br>        array[end] = temp;<br>        return left;<br>    }","like_count":4,"discussions":[{"author":{"id":2006541,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIcYxGibC5Mz4zpRs4HzibHEMiajEJo1XBfESqJGib2ibBaRWymciceW3ey0kl8HAjcmMFIpcB2u2JiaaEOg/132","nickname":"Geek_343204","note":"","ucode":"981BCE04A9E22E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275573,"discussion_content":"归并排序有问题，最后一个值没排序到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590731880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50265,"user_name":"crazyone","can_delete":false,"product_type":"c1","uid":1115042,"ip_address":"","ucode":"705E34642E41F5","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/a2/ceb37046.jpg","comment_is_top":false,"comment_ctime":1544936787,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18724805971","product_id":100017301,"comment_content":"曹源<br>先取得十个文件时间戳的最小值数组的最小值a，和最大值数组的最大值b。然后取mid=(a+b)&#47;2，然后把每个文件按照mid分割，取所有前面部分之和，如果小于1g就可以读入内存快排生成中间文件，否则继续取时间戳的中间值分割文件，直到区间内文件之和小于1g。同理对所有区间都做同样处理。最终把生成的中间文件按照分割的时间区间的次序直接连起来即可。<br>---------------<br>这种做法貌似不能保证最终有序，因为已经排序落盘的数据的时间戳不能保证一定比还在文件中未参与排序数据的小。只是保证了读到缓存中的数据有序。","like_count":4,"discussions":[{"author":{"id":1042685,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/fd/abb7bfe3.jpg","nickname":"Langzi233","note":"","ucode":"5A21AC08FC089B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4012,"discussion_content":"文件中的已经按时间戳先划分了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565058655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34187,"user_name":"Kudo","can_delete":false,"product_type":"c1","uid":1036948,"ip_address":"","ucode":"21965914B72AEB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d2/94/8bd217f1.jpg","comment_is_top":false,"comment_ctime":1540036684,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"18719905868","product_id":100017301,"comment_content":"Python实现：<br>1.归并排序：<br>def merge_sort(ls, idx_start, idx_end):<br>    if idx_end - idx_start == 0:<br>        return ls[idx_start:idx_end+1]<br>    mid = (idx_start + idx_end) &#47;&#47; 2<br>    left = merge_sort(ls, idx_start, mid)<br>    right = merge_sort(ls, mid+1, idx_end)<br>    i, j = 0, 0<br>    res = []<br>    while i &lt; len(left) and j &lt; len(right):<br>        if left[i] &lt;= right[j]:<br>            res.append(left[i])<br>            i += 1<br>        else:<br>            res.append(right[j])<br>            j += 1         <br>    if i &lt; len(left):<br>        res += left[i:]<br>    if j &lt; len(right):<br>        res += right[j:]  <br>    return res<br><br>2.快速排序：<br>def quick_sort(ls, idx_start, idx_end):<br>    if idx_end - idx_start &lt;= 0:<br>        return<br><br>    pivot = idx_end<br>    i = idx_start <br>    for j in range(i, idx_end+1):<br>        if ls[j] &lt;= ls[pivot]:<br>            ls[i], ls[j] = ls[j], ls[i]<br>            if j == pivot:<br>                pivot = i<br>            i += 1<br>    quick_sort(ls, idx_start, pivot-1)<br>    quick_sort(ls, pivot+1, idx_end)","like_count":4,"discussions":[{"author":{"id":1617939,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b0/13/5cb3459c.jpg","nickname":"浑浑噩噩cium","note":"","ucode":"358C0BCFF62B40","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":82230,"discussion_content":"你这个归并有问题吧后面的两个if","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576329643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1481811,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","nickname":"ub8","note":"","ucode":"0D937C3EAEB781","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71625,"discussion_content":"虽然没看懂，但是感觉那你很吊\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575439425,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33615,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1241346,"ip_address":"","ucode":"B8E39F3E61A36E","user_header":"https://static001.geekbang.org/account/avatar/00/12/f1/02/862b6faa.jpg","comment_is_top":false,"comment_ctime":1539836192,"is_pvip":false,"replies":[{"id":"12086","content":"可以原地 非常复杂 时间代价就高了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539855014,"ip_address":"","comment_id":33615,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18719705376","product_id":100017301,"comment_content":"归并排序真的不能原地吗？","like_count":4,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427014,"discussion_content":"可以原地 非常复杂 时间代价就高了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539855014,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2577268,"avatar":"https://static001.geekbang.org/account/avatar/00/27/53/74/17c18b44.jpg","nickname":"布小丁","note":"","ucode":"3EDD7C5A0E4C8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383837,"discussion_content":"确实，实现起来比较复杂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626251066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33038,"user_name":"趁风卷","can_delete":false,"product_type":"c1","uid":1199995,"ip_address":"","ucode":"054CCA155FA0EC","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/7b/47be4ead.jpg","comment_is_top":false,"comment_ctime":1539740833,"is_pvip":false,"replies":[{"id":"12050","content":"也算的 不过低阶会被忽略","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539788374,"ip_address":"","comment_id":33038,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18719610017","product_id":100017301,"comment_content":"快排的partition函数的空间复杂度是O(1)，但整个排序过程是递归的，最多会有O(logn)个函数放在栈里。这一部分不算空间复杂度么？","like_count":4,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426926,"discussion_content":"也算的 不过低阶会被忽略","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539788374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1086235,"avatar":"https://static001.geekbang.org/account/avatar/00/10/93/1b/bf902c9d.jpg","nickname":"aliuql","note":"","ucode":"FCF6CEC8138A94","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24665,"discussion_content":"如果是最坏的情况，栈空间也是n，存在栈溢出的可能吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570237803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32947,"user_name":"城","can_delete":false,"product_type":"c1","uid":1035315,"ip_address":"","ucode":"32C4FCE1944000","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cc/33/19f150d9.jpg","comment_is_top":false,"comment_ctime":1539737263,"is_pvip":false,"replies":[{"id":"12054","content":"就这么简单啊 面试级别是啥样子的啊","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539788781,"ip_address":"","comment_id":32947,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18719606447","product_id":100017301,"comment_content":"快排的伪代码写的过于简单，能否按照面试级别给我们写个实例代码呢","like_count":4,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426917,"discussion_content":"就这么简单啊 面试级别是啥样子的啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539788781,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1504652,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f5/8c/82fb5890.jpg","nickname":"抱小星","note":"","ucode":"BA7B0DAFDA4AF5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38400,"discussion_content":"快排就是这么简单，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571776753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97168,"user_name":"꧁花间一壶酒꧂","can_delete":false,"product_type":"c1","uid":1542238,"ip_address":"","ucode":"71CBBCFC4A926E","user_header":"https://static001.geekbang.org/account/avatar/00/17/88/5e/e9a8417d.jpg","comment_is_top":false,"comment_ctime":1558601476,"is_pvip":false,"replies":[{"id":"34783","content":"那就多看几遍啊","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1558657362,"ip_address":"","comment_id":97168,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14443503364","product_id":100017301,"comment_content":"这节看着有点懵","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451161,"discussion_content":"那就多看几遍啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558657362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33950,"user_name":"luffy","can_delete":false,"product_type":"c1","uid":1244950,"ip_address":"","ucode":"702034E116A99F","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/16/b0ab9a73.jpg","comment_is_top":false,"comment_ctime":1539926965,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14424828853","product_id":100017301,"comment_content":"以前学数据结构，就是到这部分放弃了，只是了解思想，写不出代码。","like_count":3},{"had_liked":false,"id":33606,"user_name":"Mr.Panda","can_delete":false,"product_type":"c1","uid":1238864,"ip_address":"","ucode":"655A3013B5E849","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/50/d476ed6c.jpg","comment_is_top":false,"comment_ctime":1539833835,"is_pvip":false,"replies":[{"id":"12087","content":"貌似是的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539855099,"ip_address":"","comment_id":33606,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14424735723","product_id":100017301,"comment_content":"自己本地实现归并排序后，觉得归并排序终止条件p==r就可以了，没必要大于等于，因为p只存在小于等于r的情况，请作者指导下，我是不是哪里没考虑到？","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427011,"discussion_content":"貌似是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539855099,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33098,"user_name":"Yeni","can_delete":false,"product_type":"c1","uid":1241133,"ip_address":"","ucode":"E0CBB01C88DB7D","user_header":"https://static001.geekbang.org/account/avatar/00/12/f0/2d/ab05d7b4.jpg","comment_is_top":false,"comment_ctime":1539744984,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14424646872","product_id":100017301,"comment_content":"正在准备面试，看了老师的课很多以前不理解的问题现在都能想通了，课讲得非常好","like_count":3},{"had_liked":false,"id":206478,"user_name":"Shine Sunner","can_delete":false,"product_type":"c1","uid":1334754,"ip_address":"","ucode":"8CCECE7F64C06B","user_header":"https://static001.geekbang.org/account/avatar/00/14/5d/e2/3331ad9e.jpg","comment_is_top":false,"comment_ctime":1586867042,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10176801634","product_id":100017301,"comment_content":"补充一下代码<br>public class MergeSort {<br>\tpublic static void main(String[] args) {<br>\t\tint[] nums = new int[]{4,1,2,3,7,6,48,13,24};<br>\t\tmergeSort(nums);<br>\t\tSystem.out.println(nums);<br>\t}<br>\t<br>\t&#47;&#47; 归并入口<br>\tpublic static void mergeSort(int [] args){<br>\t\tint length = args.length;<br>\t\tint[] tmp = new int[length];<br>\t\tMsort(args,tmp,0,length - 1);<br>\t}<br>\t<br>\tpublic static void Msort(int[] args,int[] tmp,int start,int end){<br>\t\tint center = (start + end)&#47;2;<br>\t\tif (start &lt; end) {<br>\t\t\t&#47;&#47; 递归处理左半部分<br>\t\t\tMsort(args, tmp, 0, center);<br>\t\t\t&#47;&#47; 递归处理右半部分<br>\t\t\tMsort(args, tmp, center + 1, end);<br>\t\t\t&#47;&#47; 合并左，右数组<br>\t\t\tMerge(args,tmp,start,center + 1,end);<br>\t\t}<br>\t}<br>\t<br>\tpublic static void Merge(int[] args,int[] tmp,int lStart,int rStart,int rEnd) {<br>\t\tint lEnd = rStart - 1;<br>\t\tint tmpStart = lStart;<br>\t\t&#47;&#47; 记录元素个数<br>\t\tint numElements = rEnd - lStart + 1;<br>\t\twhile (lStart &lt;= lEnd &amp;&amp; rStart &lt;= rEnd) {<br>\t\t\tif (args[lStart] &lt;= args[rStart]) {<br>\t\t\t\ttmp[tmpStart++] = args[lStart++];<br>\t\t\t}else{<br>\t\t\t\ttmp[tmpStart++] = args[rStart++];<br><br>\t\t\t}<br>\t\t}<br>\t\t&#47;&#47; 左边的数组有元素剩余<br>\t\twhile (lStart &lt;= lEnd) {<br>\t\t\ttmp[tmpStart++] = args[lStart++];<br>\t\t}<br>\t\t&#47;&#47; 右边的数组有元素剩余<br>\t\twhile (rStart &lt;= rEnd) {<br>\t\t\ttmp[tmpStart++] = args[rStart++];<br>\t\t}<br>\t\t&#47;&#47; 将元素导回到初始数组，此处是从右边的终点位置往回导<br>\t\tfor(int i = 0;i &lt; numElements ; i++, rEnd--){<br>\t\t\targs[rEnd] = tmp[rEnd];<br>\t\t}<br>\t}<br>}","like_count":2},{"had_liked":false,"id":198552,"user_name":"大禾","can_delete":false,"product_type":"c1","uid":1742323,"ip_address":"","ucode":"841369DDF985A8","user_header":"https://static001.geekbang.org/account/avatar/00/1a/95/f3/2fcbeb0a.jpg","comment_is_top":false,"comment_ctime":1585456337,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10175390929","product_id":100017301,"comment_content":"关于课后思考，我的想法是<br>1.把10个日志分别读入x条到有界队列中<br>2.把这组队列的队首元素组成的数组，快排思路获取这的第k小元素（k=1,即min1，k=2,即min2）<br>3.然后从最小值(min1)的队列获取y行日志，直到队空或者当前队首大于第二小的时间（min2），此时进行一次写入新文件操作，<br>4.之后先把最小值队列(min1)补充到队满，无法满足队满则读取完剩余行 <br>5.循环第2步<br>6.当地第4步出现没有数据情况则在删除这个队列，直到没有队列时结束<br>如果这个思路是对的，复杂度分析的话还希望有人可以指教","like_count":2},{"had_liked":false,"id":182985,"user_name":"空白昵称","can_delete":false,"product_type":"c1","uid":1433815,"ip_address":"","ucode":"91F50CA25102AB","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/d7/744bd8c3.jpg","comment_is_top":false,"comment_ctime":1582901973,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10172836565","product_id":100017301,"comment_content":"虽然看了大家的解决方案，还是觉得想发一下我的思路。按我的思路，其实只用了本节的分治思想。问题的关键应该是 每次排序的应该是每个文件最小时间戳，且取最小元素。<br><br>* 分配10个循环数组队列（每个40MB空间），分别缓冲10个日志文件。一次读取&lt;=40MB（必须保证行数据的完整性）。<br>* 分配100MB循环数组队列writeCacheQueue，用来缓冲写入文件用。<br>* 将10个数组队列分别dequeue出一个元素，并组成一个数组pipeArray。然后做初始排序（插入排序，或快排都可以）。<br>* 然后再将最小的元素放到writeCacheQueue，并去最小元素对应的循环数组队列，继续dequeue一个元素插入pipeArray（这里可以使用插入排序的思想插入元素到合适位置）。然后依次循环取最小元素放到writeCacheQueue步骤，直到pipeArray没有元素为止。<br>* 从循环数组队列dequeue元素时，检测是否已空。如果为空继续读取文件。如果此时文件也读取完毕，则可以废弃该队列，释放内存。<br>* 当有元素放到writeCacheQueue中时，检测大小是否满足一次性写入文件的条件（比如达到100MB），如果满足则写入一次文件。<br><br><br><br><br>","like_count":2},{"had_liked":false,"id":173705,"user_name":"ano","can_delete":false,"product_type":"c1","uid":1783342,"ip_address":"","ucode":"7DE64BDFA78550","user_header":"https://static001.geekbang.org/account/avatar/00/1b/36/2e/376a3551.jpg","comment_is_top":false,"comment_ctime":1579664684,"is_pvip":false,"replies":[{"id":"67734","content":"赋值操作","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1580116529,"ip_address":"","comment_id":173705,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10169599276","product_id":100017301,"comment_content":"伪代码里的 :=  是什么意思啊？<br><br>partition(A, p, r) {<br>  pivot := A[r]<br>  i := p<br>  for j := p to r-1 do {<br>    if A[j] &lt; pivot {<br>      swap A[i] with A[j]<br>      i := i+1<br>    }<br>  }<br>  swap A[i] with A[r]<br>  return i<br>","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482176,"discussion_content":"赋值操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580116529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122003,"user_name":"Senal","can_delete":false,"product_type":"c1","uid":1229995,"ip_address":"","ucode":"C192743D433A14","user_header":"https://static001.geekbang.org/account/avatar/00/12/c4/ab/6ff34df1.jpg","comment_is_top":false,"comment_ctime":1565267223,"is_pvip":false,"replies":[{"id":"45693","content":"基本上是可以等分的，只要分区算法选择的好","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1565909043,"ip_address":"","comment_id":122003,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10155201815","product_id":100017301,"comment_content":"@Test<br>    public void test(){<br><br>        int[] a = {7,2,28,5,3,38,9,11,57,25,18,21,51,34,23};<br>&#47;&#47;        int[] a = getIntArray();<br>        quick(a, 0 , a.length-1);<br>        System.out.println(Arrays.toString(a));<br>    }<br><br><br><br>    private int[] quick(int[] a, int p, int r){<br><br>        if(p&gt;=r) {<br>           return a;<br>        } else {<br>            int q = sort(a, p ,r);<br>            quick(a, p ,q-1);<br>            return quick(a, q+1, r);<br>        }<br>    }<br><br>    private int sort(int[] a, int p, int r){<br>        int end = a[r];<br>        int i = p;<br>        for (int j = p; j &lt; r ;j++){<br>            if (a[j] &lt; end){<br>                int temp = a[i];<br>                a[i] = a[j];<br>                a[j] = temp;<br>                i++;<br>            }<br>        }<br>        int temp = a[i];<br>        a[i] = a[r];<br>        a[r] = temp;<br>        return i;<br>    }<br>这个是我写的快排java实现，如果有问题也希望老师可以指出，还有就是不太明白文章末尾，为什么第一次分区是n，第二次是2&#47;n，明明最后一个数的分区并不能等分，为什么每次都是乘以1&#47;2？","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462053,"discussion_content":"基本上是可以等分的，只要分区算法选择的好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565909043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1010957,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6d/0d/e3fa096f.jpg","nickname":"拓","note":"","ucode":"AC1940ECC25436","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":76070,"discussion_content":"等分的是说的最好情况吗？还是要区分最好情况？最坏情况的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575808427,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1010957,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6d/0d/e3fa096f.jpg","nickname":"拓","note":"","ucode":"AC1940ECC25436","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":76069,"discussion_content":"同不明白最后那部分，通过分区找第K大，为什么就是一个公比为1/2的等比数列了。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575808343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117066,"user_name":"小耿","can_delete":false,"product_type":"c1","uid":1153707,"ip_address":"","ucode":"1C8B66C738D33B","user_header":"https://static001.geekbang.org/account/avatar/00/11/9a/ab/fd201314.jpg","comment_is_top":false,"comment_ctime":1563961488,"is_pvip":false,"replies":[{"id":"42897","content":"好像p==r就够了","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1564009759,"ip_address":"","comment_id":117066,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10153896080","product_id":100017301,"comment_content":"请问老师，终止条件啥时候会出现大于号的情况？（终止条件：p &gt;= r）","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459800,"discussion_content":"好像p==r就够了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564009759,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2911323,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/6c/5b/d9ae4fbb.jpg","nickname":"X.","note":"","ucode":"40B4ED2F6ACCD5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553749,"discussion_content":"只有两个元素的时候^▽^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646048481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115329,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1563534832,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10153469424","product_id":100017301,"comment_content":"第二遍看，终于学会了。我这个过程有点慢啊。","like_count":2},{"had_liked":false,"id":47622,"user_name":"OnClickListener","can_delete":false,"product_type":"c1","uid":1250465,"ip_address":"","ucode":"35BE7FF3D4A258","user_header":"https://static001.geekbang.org/account/avatar/00/13/14/a1/107910b4.jpg","comment_is_top":false,"comment_ctime":1544166406,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10134100998","product_id":100017301,"comment_content":"老师，关于解答开篇，在O(n)的时间复杂度内找到第K大的数，我的纠结点在于每次选择pivot的时候，应该不能保证选择到的pivot就是数组中排名中间大小的数吧。如果每次取得的pivot都是排名中间大小的元素，那我能理解第一次分区，要遍历n个元素，第二次要遍历n&#47;2个元素，第三次遍历n&#47;4...以此类推。但是pivot不可能每次都是中间大小的数吧。<br><br>极端情况下，如果是一个升序的有序数组呢，我要找到第k大的数值。每次都取数组第一个数为pivot。那么第一次分区我遍历了n个元素，第二次，我遍历了n-1个元素，第三次我遍历了n-2个元素。那是不是时间复杂度就变成O(n2)了？<br><br>反过来想，我现在要找第n-1大的数，也就是最小的数，那我是不是分区的时候遍历一遍就够了，所以时间复杂度就是O(n)?<br><br><br>","like_count":2},{"had_liked":false,"id":36012,"user_name":"stephenlee","can_delete":false,"product_type":"c1","uid":1240861,"ip_address":"","ucode":"FDB6DEC7E1B829","user_header":"https://static001.geekbang.org/account/avatar/00/12/ef/1d/64951154.jpg","comment_is_top":false,"comment_ctime":1540889315,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10130823907","product_id":100017301,"comment_content":"老师，快排原地分区函数实现的伪代码里 <br> 把   if A[j] &lt; pivot  改成    if A[j] &lt;= pivot  的话，遇到相同值也不会把顺序颠倒吧。<br>那能不能这么理解，在这种情况下的话，快排就是稳定算法 ? <br>谢谢<br>    <br>","like_count":2,"discussions":[{"author":{"id":1397031,"avatar":"https://static001.geekbang.org/account/avatar/00/15/51/27/f0dd6f19.jpg","nickname":"老白","note":"","ucode":"39881175152D49","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1875,"discussion_content":"不是吧..最后有一步交换，如果开始选的 pivot 跟 i 位置值相等，交换一下还是乱序了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1563020031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1193874,"avatar":"https://static001.geekbang.org/account/avatar/00/12/37/92/961ba560.jpg","nickname":"授人以🐟，不如授人以渔","note":"","ucode":"BD53829E924B66","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319131,"discussion_content":"stephenlee，快排原地分区函数中，if 条件不管是否加=，都不是稳定排序，和这个条件判断无关。比如例子中的：【6，8，7，6，3，5，9，4】，第一次排序后，其中的两个 6 的相对位置就发生了改变。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603951738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35124,"user_name":"richardcao","can_delete":false,"product_type":"c1","uid":1003222,"ip_address":"","ucode":"30F3904EC7ABCB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/d6/3f13ee78.jpg","comment_is_top":false,"comment_ctime":1540432096,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"10130366688","product_id":100017301,"comment_content":"O(n) 时间复杂度内求无序数组中的第 K 大元素。比如，4， 2， 5， 12， 3 这样一组数据，第 3 大元素就是 4。<br><br>我们选择数组区间 A[0…n-1] 的最后一个元素 A[n-1] 作为 pivot，对数组 A[0…n-1] 原地分区，这样数组就分成了三部分，A[0…p-1]、A[p]、A[p+1…n-1]。<br><br>如果 p+1=K，那 A[p] 就是要求解的元素；<br><br>想问，这里p是随机选取下标？为什么p+1=K就是要求解的元素？","like_count":2,"discussions":[{"author":{"id":1329116,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/BJjGmy4ooNjeURBDhVeJ7EslNbyVd6jNricALVsx1QriczD2EXddKLkXxLQK02nExosCJdyfvicVcZwfpDk64iazmQ/132","nickname":"style_月月","note":"","ucode":"59489E1BDB0090","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70271,"discussion_content":"因为数组下标是从0\n开始的，要求解的是第k大的元素，该对应的下标是k-1，我们关注的点就是k-1与p（分区点下标）之间的关系，如果k-1=p 即 k=p+1，那么A[p] 就是要求解的元素","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575340558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1358312,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b9/e8/0b3cf295.jpg","nickname":"HaiSky","note":"","ucode":"ECE7C263142432","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1817,"discussion_content":"分区之后 左到右 就是从大到小，如果 p+1=k，那么A[p] 就是要求解的元素。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562926111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2263275,"avatar":"https://static001.geekbang.org/account/avatar/00/22/88/eb/4430c3b4.jpg","nickname":"殿宇有腹肌","note":"","ucode":"1DEAB64CFDD259","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1358312,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b9/e8/0b3cf295.jpg","nickname":"HaiSky","note":"","ucode":"ECE7C263142432","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385970,"discussion_content":"这个应该要说明分区之后要把数据大的放在左边，小的放在右边，不然就是错的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627368163,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":1817,"ip_address":""},"score":385970,"extra":""}]}]},{"had_liked":false,"id":34417,"user_name":"梦总被尿憋醒","can_delete":false,"product_type":"c1","uid":1237315,"ip_address":"","ucode":"9B9C312C61CA8D","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/43/7b4a11cc.jpg","comment_is_top":false,"comment_ctime":1540168299,"is_pvip":false,"replies":[{"id":"12262","content":"不用排序的 用的快排思想","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540173189,"ip_address":"","comment_id":34417,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10130102891","product_id":100017301,"comment_content":"分区找第K大元素用排序吗？","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427203,"discussion_content":"不用排序的 用的快排思想","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540173189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33771,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1539878236,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10129812828","product_id":100017301,"comment_content":"      用Java实现查找无序数组的第K大元素（未判断边界，如k&gt;a.length，k&lt;1等等），有错的话，欢迎指错，有借鉴作用，欢迎带走！ <br>      public static int findRankKElement(int [] a, int k) {<br>\t\t&#47;&#47;第k大的数据，转换为数组下标需要减1<br>\t\tint value = findRankKElement(a, 0, a.length - 1, k - 1);<br>\t\treturn value;<br>\t}<br>\tprivate static int findRankKElement(int[] a, int p, int r, int k) {<br>\t\tint result;<br>\t\tint pivot = partitionK(a, p, r);<br>\t\tif(k == pivot) { &#47;&#47;等于即返回<br>\t\t\tresult = a[pivot];<br>\t\t}else if(k &lt; pivot){&#47;&#47;小于则在小区间查询<br>\t\t\tresult= findRankKElement(a, p, pivot - 1, k);<br>\t\t}else {&#47;&#47;大于则在大区间查询<br>\t\t\tresult = findRankKElement(a, pivot + 1, r, k);<br>\t\t}<br>\t\treturn result;<br>\t}<br>   partition()方法代码见本节文章","like_count":2,"discussions":[{"author":{"id":1512288,"avatar":"https://static001.geekbang.org/account/avatar/00/17/13/60/7ddff8e9.jpg","nickname":"留晴","note":"","ucode":"F2D39E8D4EE3FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563890,"discussion_content":"数据重复有问题的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650105405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33149,"user_name":"walor","can_delete":false,"product_type":"c1","uid":1003066,"ip_address":"","ucode":"F349FF0591E598","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/3a/fc019528.jpg","comment_is_top":false,"comment_ctime":1539750110,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10129684702","product_id":100017301,"comment_content":"课后思考<br>1.申请 10 个数组，每个数组 30M。再申请个临时数组，大小 300M。<br>2.每个文件每次读取 30M 数据分别存入 30M 的数组中。<br>3.比较 10 个数组的最大时间戳，获取它们中的最小值<br>4.合并排序 10 个数组。排序完成后，取出数组前 30M 存入磁盘（硬盘上的最终日志文件），后 270M 存入文件<br>5.循环至 300M 文件读取结束，生成 10 个新的 270M 文件<br>6.重复步骤 1。<br>7.终止条件：生成的新文件大小 0M。","like_count":2},{"had_liked":false,"id":33104,"user_name":"夏天🔆","can_delete":false,"product_type":"c1","uid":1100196,"ip_address":"","ucode":"BFCC20BFFD70EE","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/a4/f5341299.jpg","comment_is_top":false,"comment_ctime":1539745379,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10129679971","product_id":100017301,"comment_content":"每个文件切成100M的区块，对比每个区块的起止时间，区块间按照起止时间排序有时间交集的load进内存进行快排成一个大文件，记录成一个大区块，最后没有时间交集的区块按照时间顺序用脚本拼接","like_count":2},{"had_liked":false,"id":278123,"user_name":"Charles","can_delete":false,"product_type":"c1","uid":2430592,"ip_address":"","ucode":"3D7A373AC11963","user_header":"https://static001.geekbang.org/account/avatar/00/25/16/80/f72e2d29.jpg","comment_is_top":false,"comment_ctime":1612770084,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5907737380","product_id":100017301,"comment_content":"有个问题想请教各位大佬，关于归并排序里的合并操作里用到的临时数组，有两种申请方式：<br>1. 每次调用合并函数时再申请，然后函数末尾释放；<br>2. 一开始就申请一个和原数组一样大的临时数组，然后以参数形式传进合并函数使用，后面合并时就一直用这个临时数组。<br>想知道上面这两种方式哪种更好一些，因为我看网上很多代码都是第一种比较多，但我个人觉得频繁申请释放内存会增加运行时间，不知实际情况是如何？","like_count":1},{"had_liked":false,"id":273158,"user_name":"ll","can_delete":false,"product_type":"c1","uid":1296458,"ip_address":"","ucode":"57C5DAC5B51036","user_header":"https://static001.geekbang.org/account/avatar/00/13/c8/4a/3a322856.jpg","comment_is_top":false,"comment_ctime":1610459278,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5905426574","product_id":100017301,"comment_content":"哨兵怎麽用？我是分別在左右數組的末尾加了一個大數，這個是這部分的代碼：<br>def merge(a, b, res):<br>  i = j = k = 0<br>  a.append(1000)<br>  b.append(1000)<br>  while k &lt; len(res):<br>    if a[i] &lt; b[j]:<br>      res[k] = a [i]<br>      i += 1<br>    else:<br>      res[k] = b[j]<br>      j += 1<br>    k += 1<br>  return res<br>","like_count":1},{"had_liked":false,"id":251074,"user_name":"衬衫的价格是19美元","can_delete":false,"product_type":"c1","uid":1397631,"ip_address":"","ucode":"655F925451F772","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKVUskibDnhMt5MCIJ8227HWkeg2wEEyewps8GuWhWaY5fy7Ya56bu2ktMlxdla3K29Wqia9efCkWaQ/132","comment_is_top":false,"comment_ctime":1601357199,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5896324495","product_id":100017301,"comment_content":"快排的最大体会就是每次分区只是保证当前选取的分区点的位置是最终真确的位置，当所有分区点的位置都正确后，整个数组也就有序了<br>时间复杂度可以这样理解， 在我选取分区点的时候，平均每次能把数组分为数量差不多的两部分，这是前提。那么，第一轮分区的时候，需要遍历n个数据，第二轮需要遍历n&#47;2个数据，但是这一轮有2组，因此是2 * n&#47;2, 第三轮是 4 * n&#47;4......一次类推，T= 1 * n + 2 * n&#47;2 + 4 * n&#47;4 +........ 2^k * &#47;2^k<br>很明显，上面共有log2K + 1 项，每项的值都是n<br>因此T = n* (log2K + 1)<br>时间复杂度的话就是nlogn了<br>但和归并排序最大的不同是，这是平均情况<br>谁也无法保证每次选分区点的时候都能基本平分数组<br>当分区点选择不当时，最差会退化成 T = (n-1)*1 + (n-2)*1 + (n-3)*1......<br>T= (n-2)(n-3)&#47;2， 复杂度退化成n^2","like_count":1},{"had_liked":false,"id":248682,"user_name":"WilliamVector","can_delete":false,"product_type":"c1","uid":1898112,"ip_address":"","ucode":"E0D3C3D4FCB7C9","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f6/80/85ec2c2a.jpg","comment_is_top":false,"comment_ctime":1600260817,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5895228113","product_id":100017301,"comment_content":"每次从10个文件中获取固定条数的日志，抽取时间戳和文件和每条日志的对象引用组合成新的对象数组，对该数组按照时间戳排序，然后，按照顺序逐条写入新文件。依次类推，直至全部文件都读取完毕。固定条数，需要根据每条日志的大小结合内存空间做个大概的预估，在保证内存够用的情况下尽量多读一些。","like_count":1},{"had_liked":false,"id":236957,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1595602973,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5890570269","product_id":100017301,"comment_content":"求顶上去，归并排序使用插入排序的思想进行原地排序。以下代码是使用归并排序获取逆序对个数，也实现了排序。<br>public static int mergeSort(int[] a){<br>        return mergeSort(a, 0, a.length - 1);<br>    }<br><br>    private static int mergeSort(int[] a, int p, int q) {<br>        if(p &gt;= q){<br>            return 0;<br>        }<br>        int r = (p + q) &#47; 2;<br>        int partAPairs = mergeSort(a, p, r);<br>        int partBPairs = mergeSort(a,r + 1, q);<br>        int mergePairs = merge(a, p, q, r);<br>        return partAPairs + partBPairs + mergePairs;<br>    }<br><br>    private static int merge(int[] a, int p, int q, int r) {<br>        int mergePairs = 0;<br>        &#47;&#47; 游标i表示未处理区起点<br>        for(int i = r + 1; i &lt;= q; i++){<br>            &#47;&#47; 游标j代表将curr选取符合要求的位置，需要进行交换的次数（即逆序次数）<br>            for(int j = i; j &gt; p; j--){<br>                &#47;&#47; 后者比前者大则交换（即逆序对个数+1）<br>                if(a[j - 1] &gt; a[j]){<br>                    swap(a, j, j - 1);<br>                    mergePairs++;<br>                }else{<br>                    break;<br>                }<br>            }<br>        }<br><br>        return mergePairs;<br>    }<br><br>    private static void swap(int[] a, int j, int i) {<br>        int temp = a[i];<br>        a[i] = a[j];<br>        a[j] = temp;<br>    }<br>","like_count":1,"discussions":[{"author":{"id":1250907,"avatar":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","nickname":"Monday","note":"","ucode":"77B9BACC783598","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293672,"discussion_content":"跑个步回来，发现不对劲。如果merge函数用插入排序实现，那时间复杂度不就是O(N^2）了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595638099,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217440,"user_name":"Geek_Akara","can_delete":false,"product_type":"c1","uid":1991279,"ip_address":"","ucode":"E86A5A9EEC8BFF","user_header":"https://static001.geekbang.org/account/avatar/00/1e/62/6f/06d476f7.jpg","comment_is_top":false,"comment_ctime":1589505982,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884473278","product_id":100017301,"comment_content":"用Python重写了两种算法：<br><br>归并排序：<br>def merge_sort(nums):<br>    if len(nums)&lt;=1:<br>        return nums<br><br>    j = mid = len(nums)&#47;&#47;2<br>    temp = []<br>    i = 0<br>    <br>    nums = merge_sort(nums[0:mid]) + merge_sort(nums[mid:])<br>    <br>    while i &lt; mid and j &lt; len(nums):<br>        if nums[i] &lt;= nums[j]:<br>            temp.append(nums[i])<br>            i+=1<br>        else:<br>            temp.append(nums[j])<br>            j += 1<br><br>    if i == mid and j == len(nums):<br>        return temp<br>    elif i == mid:<br>        temp += nums[j:]<br>    else: <br>        temp += nums[i:mid]<br><br>    return temp<br><br>快速排序1:空间复杂度T(2n) = O(n)<br>def quick_sort(arr):<br>    if len(arr) &lt; 2:<br>        return arr<br>    else:<br>        pivot = arr[0]<br>        less = [i for i in arr[1:] if i &lt;= pivot]<br>        greater = [i for i in arr[1:] if i &gt; pivot]<br>        return quick_sort(less) + [pivot] + quick_sort(greater)<br>原地快速排序：<br>def quick_sort_in_place(nums):<br>    if len(nums) &lt;= 1:<br>        return nums<br>    pivot = nums[-1]<br>    i = 0<br>    for j in range(0,len(nums)):<br>        if nums[j]&lt;pivot:<br>            nums[i], nums[j] = nums[j],nums[i]<br>            i += 1<br>    nums[-1],nums[i] = nums[i],nums[-1]<br>    return quick_sort_in_place(nums[0:i]) + [pivot] + quick_sort_in_place(nums[i+1:])","like_count":1},{"had_liked":false,"id":185488,"user_name":"sankun","can_delete":false,"product_type":"c1","uid":1670298,"ip_address":"","ucode":"8970149C7F698C","user_header":"https://static001.geekbang.org/account/avatar/00/19/7c/9a/e1bfcaf1.jpg","comment_is_top":false,"comment_ctime":1583591854,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878559150","product_id":100017301,"comment_content":"老师，快速排序是走的递归，递归又依赖系统的堆栈，那么如果数据量过大，会导致堆栈溢出，而数据量不大时，与插入排序效率差别又不大。那是不是快排的归并排序实际应用意义就不大了？","like_count":1},{"had_liked":false,"id":172757,"user_name":"板栗","can_delete":false,"product_type":"c1","uid":1239741,"ip_address":"","ucode":"35B8B2CB2E0214","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/bd/aba4b2c9.jpg","comment_is_top":false,"comment_ctime":1579274360,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5874241656","product_id":100017301,"comment_content":"<br><br>1.获取全局的开始时间和结速时间：通过每个文件的开头和结尾时间戳，计算出所有10个文件的开始时间start_time和结速时间end_time.<br>2.计算1G内存能计算的最大时间段： 取中间 middle_time 时间，分别计算，统计每个文件在此时间之前的数据大小总和是否超过1G（应该是1G-  (开始时间、结速时间、记录读取位置的内存容量等计算用到的内容空间) ）。如果超过了一G 重新 取 中间时间 middle_time =  (start_time +middle_time)&#47;2 ,并统计数据大小。直至小于1G.标记当前 记录的截止时间 partend_time=middle_time<br><br>3.取出所有数组中小于 partend_time 的记录读入内存，记录每个文件读取到的位置，讲读出的数据排序之后写入新文件。<br><br>4.更新start_time = partend_time,重复执行第2 &#47;3 步，直至所有数据完成排序","like_count":1},{"had_liked":false,"id":167150,"user_name":"Go","can_delete":false,"product_type":"c1","uid":1401104,"ip_address":"","ucode":"01A336FC0731FF","user_header":"https://static001.geekbang.org/account/avatar/00/15/61/10/ea42c40d.jpg","comment_is_top":false,"comment_ctime":1577699196,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5872666492","product_id":100017301,"comment_content":"十个文件IO，各自读取第一条，读取出来的数据做快排；最小的时间戳数据写入新文本；记住最小位置索引，读取第二条继续快排，最小的时间戳数据写入新文本；循环读取比较执行；利用分治思路解决；","like_count":1},{"had_liked":false,"id":160750,"user_name":"梦幻的星空","can_delete":false,"product_type":"c1","uid":1526058,"ip_address":"","ucode":"FACC1AE8994DEA","user_header":"https://static001.geekbang.org/account/avatar/00/17/49/2a/e1c914c9.jpg","comment_is_top":false,"comment_ctime":1576029080,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5870996376","product_id":100017301,"comment_content":"快速排序如果牺牲空间是不是就是稳定的了？<br>新建建两个数组left和right，分区点取数组最后一个，小于等于分区点的放到left，大于分区点的放到right。这样空间复杂度应该是跟归并排序一样，但是测试过比归并排序的耗时要小。","like_count":1,"discussions":[{"author":{"id":1908315,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep9W6iaibfWRcm3rHiaDMAhdywVXPQWR3cR4KZ6N9Ux0AYKTZGBsJdIAl0fMWgIHwiaVXzu5CP7CkiauRA/132","nickname":"gyz147","note":"","ucode":"6886EC89BE963C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212309,"discussion_content":"是的，我觉得快排牺牲空间也可以实现成稳定的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584958600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147629,"user_name":"゛Rain Soundメ","can_delete":false,"product_type":"c1","uid":1717972,"ip_address":"","ucode":"0D60505DD1B65B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/36/d4/4b17a453.jpg","comment_is_top":false,"comment_ctime":1572874766,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5867842062","product_id":100017301,"comment_content":"&#47;*******C语言************归并算法 + 哨兵（升序&#47;降序）*************************&#47;<br>void merge(ElemType *a, int p, int q, int r, Sort_en direc)<br>{\t&#47;&#47;归并算法 —— (2,3,5)，(1,6) 归并为 (1,2,3,5,6) &lt;升序&gt;<br>\tint i = p, j = q + 1, k = 0;<br>\tElemType *tmp = (ElemType *)malloc((r - p + 1) * sizeof(ElemType));<br>\tif(!tmp) exit(OVERFLOW);<br>\twhile(i &lt;= q || j &lt;= r){\t&#47;&#47;高级技巧：双重哨兵（|| j &gt; r 不能省）<br>\t\tif((((bool)direc ? a[i] &lt;= a[j] : a[i] &gt;= a[j]) || j &gt; r) &amp;&amp; i &lt;= q)<br>\t\t\t*(tmp + k++) = *(a + i++);<br>\t\telse<br>\t\t\t*(tmp + k++) = *(a + j++);<br>\t}<br>\tfor(int i = 0; i &lt; r - p + 1; i++){<br>\t\t*(a + p + i) = *(tmp + i);<br>\t\tprintf(&quot;%d\\t&quot;, *(a + p + i));<br>\t}<br>\tfree(tmp);<br>}<br>上述算法中，direc为枚举类型 (Sort_en)，direc为真：&lt;升序&gt;；为假：&lt;降序&gt;","like_count":1},{"had_liked":false,"id":145640,"user_name":"风","can_delete":false,"product_type":"c1","uid":1687644,"ip_address":"","ucode":"FD508E2FEACF4F","user_header":"https://static001.geekbang.org/account/avatar/00/19/c0/5c/087abb7f.jpg","comment_is_top":false,"comment_ctime":1572335907,"is_pvip":false,"replies":[{"id":"56458","content":"众口难调啊😂","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1572487423,"ip_address":"","comment_id":145640,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5867303203","product_id":100017301,"comment_content":"老师能不能把这篇文章的伪代码改为代码,看着理解起来挺费劲","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472504,"discussion_content":"众口难调啊😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572487423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136983,"user_name":"Eric","can_delete":false,"product_type":"c1","uid":1575571,"ip_address":"","ucode":"7EB511C384BD7B","user_header":"https://static001.geekbang.org/account/avatar/00/18/0a/93/a189ec16.jpg","comment_is_top":false,"comment_ctime":1569570239,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5864537535","product_id":100017301,"comment_content":"java实现了一下快排，1.理解双指针原地排序  2.理解递归  3.没了<br><br>&#47;**<br>     * 快速排序<br>     *<br>     * @param nums<br>     * @return<br>     *&#47;<br>    public void quickSort(int[] nums, int start, int end) {<br>        if (end - start &lt;= 0) {<br>            return;<br>        }<br>        int pivot = nums[end];<br>        int i = start;<br>        for (int j = start; j &lt; end; j++) {<br>            if (nums[j] &lt; pivot) {<br>                int temp = nums[i];<br>                nums[i] = nums[j];<br>                nums[j] = temp;<br>                ++i;<br>            }<br>        }<br>        int temp = nums[i];<br>        nums[i] = pivot;<br>        nums[end] = temp;<br><br>        quickSort(nums, start, i - 1);<br>        quickSort(nums, i + 1, end);<br>    }","like_count":1},{"had_liked":false,"id":135648,"user_name":"柒","can_delete":false,"product_type":"c1","uid":1643418,"ip_address":"","ucode":"171E98D28CC47A","user_header":"https://static001.geekbang.org/account/avatar/00/19/13/9a/eedb98f1.jpg","comment_is_top":false,"comment_ctime":1569234306,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5864201602","product_id":100017301,"comment_content":"每个文件里的日志都是按照时间戳从小到大排序的，说明我们已经做好了分而治之，可以考虑到的算法是快排和归并，但是快排的结果会每个分段直接都是有序的，归并仅只段内才是有序的，我猜老师是在考对对这个算法的理解","like_count":1},{"had_liked":false,"id":122751,"user_name":"NELSONLIN","can_delete":false,"product_type":"c1","uid":1581899,"ip_address":"","ucode":"F3A45E93B00337","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eokorAhvqntTcyNLEtrAx5ricAAaeibEYibELtNKIVK5jtfib77TKUiacNsMrhp2eKph4I2KVYyGxCfQ2g/132","comment_is_top":false,"comment_ctime":1565511991,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5860479287","product_id":100017301,"comment_content":"原地分区的伪代码中有一处书写错误，<br>我测试伪代码中<br>partition(A, p, r) {<br>  pivot := A[r]<br>  i := p<br>  for j := p to r-1 do {<br>    if A[j] &lt; pivot {<br>      swap A[i] with A[j]<br>      i := i+1<br>    }<br>  }<br>  swap A[i] with A[r]<br>  return i<br>判断条件应该为 A[j] &lt;= pivot， 假如是A[j] &lt; pivot，假如数组索引最后面的数字在数组中存在重复值的话，分区后这个重复值很可能将会被错误排序，更加不是稳定排序算法了。<br>举个例子<br>数组: [7,5,8,2,5] <br>i  为分区下标<br>j 为遍历下标<br>j= 0由于 A[j] &lt; pivot --&gt;7&lt;5 不满足，i 的 下标仍然是 0<br>j = 1再次判断A[j] &lt; pivot --&gt; 5&lt;5 不满足， i 的下标仍然是 0<br>j = 2 再次判断A[j] &lt; pivot --&gt; 8&lt;5 不满足， i 的下标仍然是 0<br>j = 3 再次判断A[j] &lt; pivot --&gt; 2&lt;5 满足，i 的下标 i++ , i = 1;  并且互换为  [2,5,8,7,5]<br>此时遍历到数组的倒数第二位，终止<br>最后一次交换为 最后的下标 数 与 i =1 的交换，[2,5,8,7,5]，A[j=1] 与 A[A.length-1]交换， 仍然为[2,5,8,7,5]，分区未成功！<br>","like_count":1},{"had_liked":false,"id":115465,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1563594088,"is_pvip":false,"replies":[{"id":"42285","content":"偶数个的情况下，中间的数有两个，随便哪个都可以；<br>奇数个的情况下，中间是确定的。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1563745650,"ip_address":"","comment_id":115465,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5858561384","product_id":100017301,"comment_content":"老师，讲的思路都基本看懂了，想问个小白的问题哈，就是数组[p,...r]如果取中间位置值q，假如像[0,..10]数组个数为11个，那么q值是(0+10)&#47;2=5吧？而[0,..9,]数组个数为10个，q值是(0+9)&#47;2=4吧？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459120,"discussion_content":"偶数个的情况下，中间的数有两个，随便哪个都可以；\n奇数个的情况下，中间是确定的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563745650,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95451,"user_name":"城西","can_delete":false,"product_type":"c1","uid":1488359,"ip_address":"","ucode":"E6C6B312BE8A9D","user_header":"https://static001.geekbang.org/account/avatar/00/16/b5/e7/8400828c.jpg","comment_is_top":false,"comment_ctime":1558057877,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5853025173","product_id":100017301,"comment_content":"课后思考：<br>假设10个有序文件一共有N个数。思路是每次从10个文件的最小值中，挑选一个最小值min，然后将min写入结果文件，然后将该文件的下一个最小值加入到剩下的9个数。直到结果文件有N个有序数。这类似于归并排序的merge操作。最坏情况来看，需要进行N次10个值挑选最小值的操作。10个数中寻找最小值，复杂度为常数时间。这里可以优化磁盘读写。10个文件都预读M个数进内存，然后每次从内存取该文件最小值。结果可以先缓存在内存，缓存满后，全部写出，并清空缓存。","like_count":1},{"had_liked":false,"id":87548,"user_name":"Zhangxuesong","can_delete":false,"product_type":"c1","uid":1396503,"ip_address":"","ucode":"F5C4C3AC9429AD","user_header":"https://static001.geekbang.org/account/avatar/00/15/4f/17/2185685f.jpg","comment_is_top":false,"comment_ctime":1555634335,"is_pvip":false,"replies":[{"id":"31489","content":"编辑，麻烦修改下错别字，抱歉哈。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1555639132,"ip_address":"","comment_id":87548,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5850601631","product_id":100017301,"comment_content":"当下标从 p 到 q 和从 q+1 到 r 这两个子数组都排好序之后，我们再将两个有序的子数组合并在一起，这样下标从 p 到 r 之间的数据&quot;就也&quot;  -&gt;  &quot;也就&quot;  排好序了。","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447501,"discussion_content":"编辑，麻烦修改下错别字，抱歉哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555639132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79186,"user_name":"Nick","can_delete":false,"product_type":"c1","uid":1011634,"ip_address":"","ucode":"3EF2F5AE260644","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6f/b2/4c010d46.jpg","comment_is_top":false,"comment_ctime":1553397241,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5848364537","product_id":100017301,"comment_content":"在递归函数内，需要用到子问题的递归解时，递归就需要不断返回，造成栈溢出，也就是达到递归最深处后还要一层层的往上返回。<br>归并排序需要先求出分组数组的解（递归求），再合并递归解。<br>快速排序是先分组数组，在递归的对分组的数组进行快排。递归函数内不需要知道分组数组的递归解。","like_count":1},{"had_liked":false,"id":70250,"user_name":"康斯坦丁","can_delete":false,"product_type":"c1","uid":1368096,"ip_address":"","ucode":"C130E800E8D5C9","user_header":"https://static001.geekbang.org/account/avatar/00/14/e0/20/003190c1.jpg","comment_is_top":false,"comment_ctime":1551059026,"is_pvip":false,"replies":[{"id":"25196","content":"我们可以得到 T(n) = 2^kT(n&#47;2^k)+kn。<br>要想计算得到T(n)的表达式（只包含n这个参数），我们需要知道k值以及T(n&#47;2^k)是多少.<br><br>怎么得到这个K值呢？<br>当n&#47;2^k=1的时候，T(n&#47;2^k)=T(1)，这个时候k值和T（n&#47;2^k）都知道了。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551147692,"ip_address":"","comment_id":70250,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846026322","product_id":100017301,"comment_content":"T(n&#47;2^k)=T(1)<br>这个推导过程，可以再详细说一下嘛","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440518,"discussion_content":"我们可以得到 T(n) = 2^kT(n/2^k)+kn。\n要想计算得到T(n)的表达式（只包含n这个参数），我们需要知道k值以及T(n/2^k)是多少.\n\n怎么得到这个K值呢？\n当n/2^k=1的时候，T(n/2^k)=T(1)，这个时候k值和T（n/2^k）都知道了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551147692,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":67761,"user_name":"高山高","can_delete":false,"product_type":"c1","uid":1120547,"ip_address":"","ucode":"4F1D91E3C3FBB9","user_header":"https://static001.geekbang.org/account/avatar/00/11/19/23/849beae4.jpg","comment_is_top":false,"comment_ctime":1550244317,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5845211613","product_id":100017301,"comment_content":"如果 p+1=K，那 A[p] 就是要求解的元素；如果 K&gt;p+1, 说明第 K 大元素出现在 A[p+1…n-1] 区间，我们再按照上面的思路递归地在 A[p+1…n-1] 这个区间内查找。同理，如果 K&lt;p+1，那我们就在 A[0…p-1] 区间查找。<br><br><br>这个说法的前提是排序是按照从大到小排序的，否则正好相反，希望老师完善一下","like_count":1},{"had_liked":false,"id":56856,"user_name":"大大。","can_delete":false,"product_type":"c1","uid":1237399,"ip_address":"","ucode":"A6716E46264AC4","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/97/fec494f2.jpg","comment_is_top":false,"comment_ctime":1546569177,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5841536473","product_id":100017301,"comment_content":"为什么归并排序不用奇数数组来做例子？","like_count":1,"discussions":[{"author":{"id":1652836,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epKJlW7sqts2ZbPuhMbseTAdvHWnrc4ficAeSZyKibkvn6qyxflPrkKKU3mH6XCNmYvDg11tB6y0pxg/132","nickname":"pc","note":"","ucode":"1AD538B9A900B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":226126,"discussion_content":"有啥区别...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586423958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":52465,"user_name":"Lisa Li","can_delete":false,"product_type":"c1","uid":1046663,"ip_address":"","ucode":"4F7CF929FF4C6B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/87/0491e9e5.jpg","comment_is_top":false,"comment_ctime":1545387269,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5840354565","product_id":100017301,"comment_content":"“第二次分区查找，我们只需要对大小为 n&#47;2 的数组执行分区操作，需要遍历 n&#47;2 个元素。依次类推，分区遍历元素的个数分别为、n&#47;2、n&#47;4、n&#47;8、n&#47;16.……直到区间缩小为 1。” 这个没有明白怎么算出来的。比如，一共16个数，所以是16+8+4+2+1。按公式1*(1-2^5)&#47;(1-2)=31 和给出的2*n-1=31是一样的。我想知道等比数列的一共有多少项是怎么求的。","like_count":1,"discussions":[{"author":{"id":1630003,"avatar":"https://static001.geekbang.org/account/avatar/00/18/df/33/bc2eabe6.jpg","nickname":"夰歛","note":"","ucode":"213086253F227C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21201,"discussion_content":"直接用求和公式推导，不需要套等比数列求和公式，所以就不需要知道项数：\n\n公比 q = 1/2 \nSn = n+n/2+n/4+n/8...+1\nqSn =n/2+n/4+n/8+...+1/2\n(1-q)Sn=n-1/2\nSn = 2n-1 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569448977,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":46118,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1543849481,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5838816777","product_id":100017301,"comment_content":"哈哈，刚看到这章的下一章，忽然发现这章的思考题。其实这个解决方案就是使用桶排序，是最优解决方案。根据时间戳的范围进行划分到不同的桶里。然后每个桶使用本章介绍的快速排序，这样时间复杂度就为近乎O(n)，空间复杂度为O(1)。","like_count":1},{"had_liked":false,"id":45065,"user_name":"Pitt‮口一你了亲‭","can_delete":false,"product_type":"c1","uid":1320101,"ip_address":"","ucode":"EEEB53923113CE","user_header":"https://static001.geekbang.org/account/avatar/00/14/24/a5/d1d28c4d.jpg","comment_is_top":false,"comment_ctime":1543542853,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5838510149","product_id":100017301,"comment_content":"&quot;通过这样一步一步分解推导，我们可以得到 T(n) = 2^kT(n&#47;2^k)+kn。当T(n&#47;2^k)=T(1) 时，也就是 n&#47;2^k=1，我们得到 k=log2n 。我们将 k 值代入上面的公式，得到T(n)=Cn+nlog2n 。如果我们用大 O 标记法来表示的话，T(n) 就等于 O(nlogn)。归并排序的时间复杂度是 O(nlogn)。&quot;<br><br>老师,这里k值代入之后,T(n)=Cn+nlog2n. 我代入之后是T(n)=2*T(n&#47;2)+nlog2n. 为什么这里的Cn可以直接忽略  我有点懵<br><br><br><br><br><br><br>","like_count":1},{"had_liked":false,"id":44219,"user_name":"beiliu","can_delete":false,"product_type":"c1","uid":1292128,"ip_address":"","ucode":"06E1EC1244A52B","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLmBgic9UlGySyG377pCVzNnbgsGttrKTCFztunJlBTDS32oTyHsJjAFJJsYJyhk9cNE5OZeGKWJ6Q/132","comment_is_top":false,"comment_ctime":1543387121,"is_pvip":false,"replies":[{"id":"15771","content":"看下我举的例子吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543403636,"ip_address":"","comment_id":44219,"utype":1}],"discussion_count":1,"race_medal":1,"score":"5838354417","product_id":100017301,"comment_content":"老师，我想问一个问题，为什么快排是不稳定的，如果我们每次都取最后一个做分区点，然后0到n-1，当遍历到的数据小于等于分区点数据时就进行交换，遍历完之后再改变分区点的位置，我觉得这样快排是稳定的呀","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430684,"discussion_content":"看下我举的例子吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543403636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39121,"user_name":"Kim","can_delete":false,"product_type":"c1","uid":1236573,"ip_address":"","ucode":"39CC8E1E8EFB8A","user_header":"https://static001.geekbang.org/account/avatar/00/12/de/5d/a7e748db.jpg","comment_is_top":false,"comment_ctime":1542193950,"is_pvip":false,"replies":[{"id":"14116","content":"本身就比较复杂 所以要难懂点","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542280486,"ip_address":"","comment_id":39121,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5837161246","product_id":100017301,"comment_content":"相比之前的三个排序算法理解起来比较困难，还得琢磨琢磨......","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428928,"discussion_content":"本身就比较复杂 所以要难懂点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542280486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37816,"user_name":"姚文锐","can_delete":false,"product_type":"c1","uid":1125948,"ip_address":"","ucode":"2C78F05A043ADE","user_header":"https://static001.geekbang.org/account/avatar/00/11/2e/3c/4aeb8a86.jpg","comment_is_top":false,"comment_ctime":1541736046,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5836703342","product_id":100017301,"comment_content":"首先用快排思想，选一个时间点（pivot）将每个300M的文件分成两个，以此类推，直到每个区间的10个文件大小满足内存要求时，用归并排序思想，合并每个区间内的10文件，最后在合并各个区间。","like_count":1},{"had_liked":false,"id":35371,"user_name":"琴晓","can_delete":false,"product_type":"c1","uid":1250313,"ip_address":"","ucode":"6AA8C3ED4F5D72","user_header":"https://static001.geekbang.org/account/avatar/00/13/14/09/083584a6.jpg","comment_is_top":false,"comment_ctime":1540526594,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5835493890","product_id":100017301,"comment_content":"不容易呀，想了几天了，必须留个言！<br>快速排序：<br>def quick_sort(data, p, r):<br>    if p &gt;= r:<br>        return data[p: r]<br>    pivot = data[r]<br>    i = p<br>    j = r<br>    while i &lt; r and j &gt; p:<br>        a = -1<br>        b = 0<br>        if data[i] &gt;= pivot:<br>            a = i<br>        else:<br>            i += 1<br>        if data[j] &lt; pivot:<br>            b = j<br>        else:<br>            j -= 1<br>        if a &gt;= 0 and b:<br>            data[a], data[b] = data[b], data[a]<br>        if i &gt; j:<br>            break<br>    data[j+1], data[r] = data[r], data[j+1]<br>    quick_sort(data, p, j)<br>    quick_sort(data, j+1, r)<br><br><br>m = [9, 5, 8, 2, 1, 3, 10, 54, 82, 24]<br>quick_sort(m, 0, 9)<br>print(m)","like_count":1},{"had_liked":false,"id":35341,"user_name":"cweioo","can_delete":false,"product_type":"c1","uid":1087300,"ip_address":"","ucode":"E48D291E6C6993","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/44/52b5e2e2.jpg","comment_is_top":false,"comment_ctime":1540519898,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5835487194","product_id":100017301,"comment_content":"分配10个50M的数组和一个500M的数组用来存前面10个数组排序后的结果，将排好序得前50M写入文件，然后再读取50M（哪个数组中数据被排序后写入文件了，就从对应原日志文件再读取）写入那10个数组中。如果其中有一个文件先读取完了，可以动态增加读取和写入的大小，只要加起来不过1G就可以了。","like_count":1},{"had_liked":false,"id":34672,"user_name":"小花小黑的铲屎官","can_delete":false,"product_type":"c1","uid":1050823,"ip_address":"","ucode":"56061DCDD5EBE1","user_header":"https://static001.geekbang.org/account/avatar/00/10/08/c7/6b0cb046.jpg","comment_is_top":false,"comment_ctime":1540257149,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5835224445","product_id":100017301,"comment_content":"有个疑问：如果 p+1=K，那 A[p] 就是要求解的元素；如果 K&gt;p+1, 说明第 K 大元素出现在 A[p+1…n-1] 区间，我们再按照上面的思路递归地在 A[p+1…n-1] 这个区间内查找。<br>既然是无序的数组，怎么能确认K&gt;p+1, 说明第 K 大元素出现在 A[p+1…n-1] 区间呢？","like_count":1},{"had_liked":false,"id":33738,"user_name":"蓝艺","can_delete":false,"product_type":"c1","uid":1239640,"ip_address":"","ucode":"FC81CC63C8F245","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/58/2aa56c18.jpg","comment_is_top":false,"comment_ctime":1539867855,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5834835151","product_id":100017301,"comment_content":"自己用go写了下快排算法：<br><br>package main<br><br>import (<br>\t&quot;fmt&quot;<br>\t&quot;strconv&quot;<br>)<br><br>func QuickSort(A []int, p int, r int) {<br>\tif p &gt;= r {<br>\t\treturn<br>\t}<br>\tq := Partition(A, p, r)<br>\tQuickSort(A, p, q-1)<br>\tQuickSort(A, q+1, r)<br><br>}<br>&#47;&#47;将数组A重排<br>func Partition(A []int, p int, r int) int {<br>\tkey:=A[r] &#47;&#47;最后一位作为key<br>\ti:=p<br>\tj:=p<br>\tfor j&lt;r{<br>\t\tif A[j]&lt;key{<br>\t\t\ttemp:=A[i]<br>\t\t\tA[i] = A[j]<br>\t\t\tA[j] = temp<br>\t\t\ti++<br>\t\t}<br>\t\tj++<br>\t}<br>\ttemp2:=A[i]<br>\tA[i] = key<br>\tA[r] = temp2<br>\treturn i<br>}<br><br>func main() {<br>\tA:=[] int{18,23,14,35,32,11,24,1,7,15,22,19,8,3,9}<br><br>\tQuickSort(A,0,14)<br>\tfor _,a :=range A{<br>\t\ts:=strconv.Itoa(a)+&quot;,&quot;<br>\t\tfmt.Print(s)<br>\t}<br>}<br>","like_count":1},{"had_liked":false,"id":33470,"user_name":"wean","can_delete":false,"product_type":"c1","uid":1239735,"ip_address":"","ucode":"3E069F95C25EAD","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/b7/1f7316e6.jpg","comment_is_top":false,"comment_ctime":1539789758,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5834757054","product_id":100017301,"comment_content":"对课后思考，考虑到硬盘读取速度较慢，选择每次读取每个文件一部分数据到内存中排序后再刷入新文件。<br><br>每个新文件分配 40 MB 的内存空间，另开 400 MB 的待刷入空间。<br><br>每轮处理数据，首先从各个文件读取数据，补满分配的 40 MB 内存空间。然后找出十个内存空间缓冲区中，共同包含的时间戳范围内的最大时间戳，这个时间戳就是每个缓冲区可以在本轮刷入新文件的最大时间戳，定义为可刷入最大时间戳。定义每个缓冲区从开头到可刷入最大时间戳的数据区间，叫做这个缓冲区的可用数据区间。<br><br>对十个缓冲区的可用数据区间进行多路归并排序，整理到 400 MB 的待刷入区域，然后刷入新文件。<br><br>注意处理好边界条件。有文件已经读取到末尾的情况、还有所有文件都读取到末尾的情况。<br><br>循环执行以上步骤，即可完成合并。","like_count":1},{"had_liked":false,"id":358446,"user_name":"111","can_delete":false,"product_type":"c1","uid":3109487,"ip_address":"北京","ucode":"D6E8E83A118A3E","user_header":"https://static001.geekbang.org/account/avatar/00/2f/72/6f/44c10658.jpg","comment_is_top":false,"comment_ctime":1664328907,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664328907","product_id":100017301,"comment_content":"总结：<br>  1. 归并和快速排序都是使用的分治的思想<br>  2. 快速排序是从上到下，空间复杂度是O(1)<br>1g，10个文件。每个文件可以读取50m的数据进行合并。<br>","like_count":0},{"had_liked":false,"id":357978,"user_name":"barnabas","can_delete":false,"product_type":"c1","uid":1212438,"ip_address":"上海","ucode":"87FB55480C5C84","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJpaa2pEggFCtaX455yukBbnhoD95AG2WAfyUxG69xFnYyR93A0PibACNgZaEZpDq8t8XkgTAibzaRw/132","comment_is_top":false,"comment_ctime":1663809696,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663809696","product_id":100017301,"comment_content":"课后题思考：初始每个文件读取100m到内存，组成10个有序队列，然后排序得到前100m日志输出到目标文件。（显然输出的100m日志是总体集合中最靠前的，就像年级的第一名一定是各班级第一名里面的。）接着继续顺序读取文件使得每个队列维持100m大小（除非文件读完），然后重复排序和输出下100m的日志，重复步骤直到只剩一个非空队列，最后剩下的队列直接输出到目标文件。","like_count":0},{"had_liked":false,"id":357300,"user_name":"Geek_16e01a","can_delete":false,"product_type":"c1","uid":1843371,"ip_address":"浙江","ucode":"791D5AA6BAA018","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK5dh80UCnDwic7jHWRGVMbqFBjFbBAKO4bqzB5Sr39iaib5JPmF3d06dV1ibXHflNdQKgcKBsEkfXc6g/132","comment_is_top":false,"comment_ctime":1663142873,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663142873","product_id":100017301,"comment_content":"好奇怪，其实答案已经在老师讲的文档里了，归并排序的merge函数就可以合并有序数组，那么只要将文件转成数组，再实现一下归并排序的merge函数就可以合并两个数组了，递归调用多次，就可以合并所有的文件了","like_count":0},{"had_liked":false,"id":355695,"user_name":"蒋慕平","can_delete":false,"product_type":"c1","uid":2302901,"ip_address":"重庆","ucode":"57B8FF7F00C042","user_header":"https://static001.geekbang.org/account/avatar/00/23/23/b5/639a12ec.jpg","comment_is_top":false,"comment_ctime":1661665513,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661665513","product_id":100017301,"comment_content":"错误的图。<br>如果我们不考虑空间消耗的话，partition() 分区函数可以写得非常简单。我们申请两个临时数组 X 和 Y，遍历 A[p...r]，将小于 pivot 的元素都拷贝到临时数组 X，将大于 pivot 的元素都拷贝到临时数组 Y，最后再将数组 X 和数组 Y 中数据顺序拷贝到 A[p....r]。<br>这下面的图存在问题，最后应该 2 3 1 5 6 8 10","like_count":0},{"had_liked":false,"id":355022,"user_name":"陈志男","can_delete":false,"product_type":"c1","uid":2695483,"ip_address":"广东","ucode":"4831554F6AC2C7","user_header":"https://static001.geekbang.org/account/avatar/00/29/21/3b/7f01e158.jpg","comment_is_top":false,"comment_ctime":1660984144,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1660984144","product_id":100017301,"comment_content":"public int[] sortArray(int[] nums) {<br>        int [] ans = mergeSort(0,nums.length-1,nums);<br>        return ans;<br>    }<br>    public int [] mergeSort(int l , int r , int [] ans){<br>        if(l&gt;=r){<br>            return new int[]{ans[l]};<br>        }<br>        int m = ( l + r) &#47; 2;<br>        int[] larr = mergeSort(l , m , ans);<br>        int[] rarr = mergeSort(m + 1 , r ,ans);<br>        int[] tarr = new int [r - l + 1];<br>        int i = 0 ;<br>        int j = 0 ;<br>        int x = 0 ;<br>        while(i &lt; larr.length &amp;&amp; j &lt; rarr.length){<br>            if(larr[i]&lt;rarr[j]){<br>                tarr[x] = larr[i];<br>                i++;<br>            }else{<br>                tarr[x] = rarr[j];<br>                j++;<br>            }<br>            x++;<br>        }<br>        while(i &lt; larr.length){<br>            tarr[x] = larr[i];<br>            i++;<br>            x++;<br>        }<br>        while(j &lt; rarr.length){<br>            tarr[x] = rarr[j];<br>            j++;<br>            x++;<br>        }<br>        return tarr ;<br>    }<br>}","like_count":0},{"had_liked":false,"id":354338,"user_name":"孙新","can_delete":false,"product_type":"c1","uid":2875594,"ip_address":"辽宁","ucode":"A80038A479B943","user_header":"https://static001.geekbang.org/account/avatar/00/2b/e0/ca/adfaa551.jpg","comment_is_top":false,"comment_ctime":1660291494,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1660291494","product_id":100017301,"comment_content":"我的回答可能不是问题的初衷，但是我觉得可以尝试解决这个问题：<br>首先，日志文件，都是一行一个时间戳。<br>所以实际上每一行都可以表述为：时间戳+该行的偏移量信息。<br>首先，所有文件遍历一遍，记录下所有行的时间戳和该行所处文件，以及所处文件当中的偏移量，偏移长度。<br>使用c++的话，把这些偏移信息存入结构体，存入vector。给vector按照时间戳字段排序即可。可以使用任意一个排序算法或者使用c++算法库algorithm中的排序算法+lambda表达式就可以实现，因为这个偏移信息比起全量读取是个较小的开销，1G足够了。<br>排序以后，再根据时间戳对应的偏移信息，按顺序写入新文件即可。<br>当然，可以直接使用c++的map或者multimap来存数据，键就是时间戳，他们存入以后自动做了排序。不需要vector+algorithm+lambda表达式。multimap解决的是键重复的问题。<br>可能存在的问题：<br>1.如果内存给的更小呢？小到所有偏移信息都存不下呢。这个可以尝试使用我们的分治思想，找到一个临界值，小于临界值的全部捡出来。然后分批处理。当然，临界值刚才老师说下一节讲，希望对这个有用。<br>2.使用偏移信息读取并写入新文件时可能会很慢。<br>当然，本文提出的问题是引导我们使用提到的思想来解决这个排序问题。我也没想出来其他同学回答以外的思路。","like_count":0},{"had_liked":false,"id":353054,"user_name":"有幸丶遇见你","can_delete":false,"product_type":"c1","uid":2874495,"ip_address":"陕西","ucode":"692345EBD5B3C3","user_header":"https://static001.geekbang.org/account/avatar/00/2b/dc/7f/03513a02.jpg","comment_is_top":false,"comment_ctime":1659096226,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659096226","product_id":100017301,"comment_content":"最后的思考题提现的应该是归并排序的思路，甚至可以把前提条件修改成一个日志文件，但里面时间戳是无序的，这样的话，解决方案就完全可以走归并排序的思路了","like_count":0},{"had_liked":false,"id":351744,"user_name":"老大不小","can_delete":false,"product_type":"c1","uid":1295609,"ip_address":"","ucode":"35BCDD3CB13467","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRFRX8kNzNet7FibNvtavbVpAwK09AhIhrib9k762qWtH6mre8ickP7hM5mgZC4ytr8NnmIfmAhxMSQ/132","comment_is_top":false,"comment_ctime":1658145981,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658145981","product_id":100017301,"comment_content":"我也没看懂快排的伪代码，而且感觉和我在其他治疗上学到的快排不一样。快排简单描述是，选定一个基准值，然后不停的交换位置，就可以得到一个排好序的数组，是原地排序，时间复杂度是o{nlogn}，logn是树高。","like_count":0},{"had_liked":false,"id":346735,"user_name":"杨冬武","can_delete":false,"product_type":"c1","uid":1800054,"ip_address":"","ucode":"87D414D3F90F85","user_header":"https://static001.geekbang.org/account/avatar/00/1b/77/76/739a173e.jpg","comment_is_top":false,"comment_ctime":1653387673,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653387673","product_id":100017301,"comment_content":"使用归并排序的思想，将问题分而治之，就变成了对文件的两两合并。","like_count":0},{"had_liked":false,"id":343781,"user_name":"Casper","can_delete":false,"product_type":"c1","uid":1022129,"ip_address":"","ucode":"69282EB175B48E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/b1/f89a84d0.jpg","comment_is_top":false,"comment_ctime":1651051856,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1651051856","product_id":100017301,"comment_content":"最近在看快排算法时, 看到一种叫做 Hoare Partition 的快排, 其实现真的是很巧妙。","like_count":0},{"had_liked":false,"id":343010,"user_name":"黄豆豆","can_delete":false,"product_type":"c1","uid":1347740,"ip_address":"","ucode":"5D47A4E3BAD3D6","user_header":"https://static001.geekbang.org/account/avatar/00/14/90/9c/53d0f906.jpg","comment_is_top":false,"comment_ctime":1650592231,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650592231","product_id":100017301,"comment_content":"看完整个人都是懵逼的","like_count":0},{"had_liked":false,"id":342672,"user_name":"zhexiaozi90","can_delete":false,"product_type":"c1","uid":1699904,"ip_address":"","ucode":"C324C71E408560","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/biaG5gpYHkH2TpiaqgQ9iaAl1n4oKyNO25TPC9WAm6XuMxmiaRRbc5oMn5DABibjgIrvGQzIeAj7ZTziaIcFibYaA8yUA/132","comment_is_top":false,"comment_ctime":1650414709,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650414709","product_id":100017301,"comment_content":"快速排序 每次把某一个（最后一个）元素放到它应该在的位置， 归并排序 每次把一段元素排序后再合并。","like_count":0},{"had_liked":false,"id":342211,"user_name":"留晴","can_delete":false,"product_type":"c1","uid":1512288,"ip_address":"","ucode":"F2D39E8D4EE3FD","user_header":"https://static001.geekbang.org/account/avatar/00/17/13/60/7ddff8e9.jpg","comment_is_top":false,"comment_ctime":1650104916,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650104916","product_id":100017301,"comment_content":"如果数据有重复，还能用上面的算法求第k大元素吗？","like_count":0},{"had_liked":false,"id":341920,"user_name":"renlindong","can_delete":false,"product_type":"c1","uid":1385126,"ip_address":"","ucode":"E474C0D2B2353F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/qUia0UiahxYDkyxGW2ayKZNCRcfeU0kf2ARdRjNEhic5fgUpe3Vib0Ohuhg0sxyic6TdjsYw62S7ZJvOzKfOI71xp1w/132","comment_is_top":false,"comment_ctime":1649918777,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649918777","product_id":100017301,"comment_content":"合并K个有序数组","like_count":0},{"had_liked":false,"id":341878,"user_name":"知行","can_delete":false,"product_type":"c1","uid":1802022,"ip_address":"","ucode":"5AC8CBCC0AD48B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/7f/26/c5127e9a.jpg","comment_is_top":false,"comment_ctime":1649898708,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1649898708","product_id":100017301,"comment_content":"sharding sphere 多个表中归并合成一个结果，和这个类似","like_count":0},{"had_liked":false,"id":339916,"user_name":"Geektimer","can_delete":false,"product_type":"c1","uid":2935759,"ip_address":"","ucode":"13746813BA173A","user_header":"https://static001.geekbang.org/account/avatar/00/2c/cb/cf/fc97de76.jpg","comment_is_top":false,"comment_ctime":1648461554,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1648461554","product_id":100017301,"comment_content":"def QuickSort(nums):<br>    if not nums or len(nums) &lt; 2:<br>        return nums<br>    mid = len(nums) &#47;&#47; 2<br>    mid_value = nums[mid]<br>    del mid_value<br>    left,right = [],[]<br>    for item in nums:<br>        if item &gt;= mid_value:<br>            right.append(item)<br>        else:<br>            left.append(item)<br>    return QuickSort(left) + [mid_value] + QuickSort(right)","like_count":0},{"had_liked":false,"id":338896,"user_name":"基良","can_delete":false,"product_type":"c1","uid":1013694,"ip_address":"","ucode":"AD8A664F7AC6FB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/77/be/554f167a.jpg","comment_is_top":false,"comment_ctime":1647779931,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647779931","product_id":100017301,"comment_content":"开篇解答：<br>public class KthLargest {<br>    private int res = 0;<br>    public int findKthLargest(int[] nums, int k) {<br>        PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;Integer&gt;(k);<br>        for (int item : nums) {<br>            if (queue.size() &lt; k) {<br>                queue.offer(item);<br>            } else {<br>                if(item &gt; queue.peek()){<br>                    queue.poll();<br>                    queue.offer(item);<br>                }<br>            }<br>        }<br>        return queue.peek();<br>    }<br><br>    public int findKthLargestByQuickSort(int[] nums, int k) {<br>        quickSort(nums, 0, nums.length - 1, nums.length - k + 1);<br>        return nums[res];<br>    }<br><br>    private void quickSort(int[] nums, int left, int right, int k) {<br>        if (left &lt;= right) {<br>            int pivot = partition(nums, left, right);<br>            if (pivot + 1 == k) {<br>                res = pivot;<br>            } else if (pivot + 1 &lt; k) {<br>                quickSort(nums, pivot + 1, right, k);<br>            } else {<br>                quickSort(nums, left, pivot - 1, k);<br>            }<br>        }<br>    }<br><br>    private int partition(int[] nums, int left, int right) {<br>        int p = nums[right];<br>        int i = left;<br>        for (int j = left; j &lt; right; j++) {<br>            if(nums[j] &lt; p){<br>                swap(nums, i, j);<br>                i++;<br>            }<br>        }<br>        swap(nums, i, right);<br>        return i;<br>    }<br><br>    private void swap(int[] nums, int i, int j) {<br>        int tmp = nums[i];<br>        nums[i] = nums[j];<br>        nums[j] = tmp;<br>    }<br>}","like_count":0},{"had_liked":false,"id":338074,"user_name":"H.H","can_delete":false,"product_type":"c1","uid":2668479,"ip_address":"","ucode":"3C0BB1E2A3EC51","user_header":"https://static001.geekbang.org/account/avatar/00/28/b7/bf/815f0ec6.jpg","comment_is_top":false,"comment_ctime":1647267663,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1647267663","product_id":100017301,"comment_content":"快排表现不理想啊，还是我的实现有问题？<br>def quick_sort(A):<br>    n = len(A)<br>    quick_sort_c(A,0,n-1)<br><br>            <br><br>    <br>def quick_sort_c(A,p,r):<br>    if p &gt;= r:<br>        return <br>    i = p<br>    pivot = A[r]<br>    <br>    for j in range(p,r):<br>        if A[j] &lt; pivot:<br>            if i != j:<br>                tmp = A[j]<br>                A[j] = A[i]<br>                A[i] = tmp<br>            i+=1<br>    A[r] = A[i]<br>    A[i] = pivot<br>            <br>    <br>    if i -p &gt; 1:<br>        quick_sort_c(A,p,i-1)<br>    if r-i &gt; 1:<br>        quick_sort_c(A,i+1,r)","like_count":0},{"had_liked":false,"id":338011,"user_name":"Matthew","can_delete":false,"product_type":"c1","uid":1239829,"ip_address":"","ucode":"4B66882414337E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eopQic30JDlkwNAAdPHYxF3HMico8zDtMsGnI7KkbM4oV7ib1Pt4ZJYSiaDEiaLGkzp4JgoHBb4s8GIZjw/132","comment_is_top":false,"comment_ctime":1647234795,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647234795","product_id":100017301,"comment_content":"1,2 ,3,4,5,6 第二大数是5，降序才说的通，升序，按分区得到的数是3","like_count":0},{"had_liked":false,"id":338010,"user_name":"Matthew","can_delete":false,"product_type":"c1","uid":1239829,"ip_address":"","ucode":"4B66882414337E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eopQic30JDlkwNAAdPHYxF3HMico8zDtMsGnI7KkbM4oV7ib1Pt4ZJYSiaDEiaLGkzp4JgoHBb4s8GIZjw/132","comment_is_top":false,"comment_ctime":1647234780,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647234780","product_id":100017301,"comment_content":"1,2 ,3,4,5,6 第二大数是5，降序才说的通，升序，按分区得到的数是3<br>","like_count":0},{"had_liked":false,"id":337008,"user_name":"谭雪娇","can_delete":false,"product_type":"c1","uid":1375252,"ip_address":"","ucode":"B20AB23E0D20E0","user_header":"https://static001.geekbang.org/account/avatar/00/14/fc/14/b6b50f91.jpg","comment_is_top":false,"comment_ctime":1646549714,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646549714","product_id":100017301,"comment_content":"力扣88. 合并两个有序数组<br>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。<br><br>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。<br>使用了文中讲的两种方法分别实现<br>&#47;**<br> * @param {number[]} nums1<br> * @param {number} m<br> * @param {number[]} nums2<br> * @param {number} n<br> * @return {void} Do not return anything, modify nums1 in-place instead.<br> *&#47;<br>var merge = function (nums1, m, nums2, n) {<br>    let i = 0;<br>    let j = 0;<br>    let temp = [];<br>    while (i &lt; m &amp;&amp; j &lt; n) {<br>        if (nums1[i] &lt; nums2[j]) {<br>            temp.push(nums1[i]);<br>            i++;<br>        } else {<br>            temp.push(nums2[j]);<br>            j++;<br>        }<br>    }<br>    if (i == m) {<br>        temp = temp.concat(nums2.splice(j, n - j));<br>    } else {<br>        temp = temp.concat(nums1.splice(i, m - i));<br>    }<br>    for (let i = 0; i &lt; m + n; i++) {<br>        nums1[i] = temp[i];<br>    }<br>};<br>var merge = function (nums1, m, nums2, n) {<br>      let j = 0;<br>      for (let i = m; i &lt; nums1.length; i++) {<br>        nums1[i] = nums2[j];<br>        j++;<br>      }<br>      quick_sort_c(nums1, 0, m + n - 1);<br><br>      function quick_sort_c(arr, p, r) {<br>        console.log(&quot;p&quot;, p, r, arr);<br>        if (p &lt; r) {<br>          let q = partition(arr, p, r);<br>          &#47;&#47; debugger;<br>          quick_sort_c(arr, p, q - 1);<br>          quick_sort_c(arr, q + 1, r);<br>        }<br>      }<br>      &#47;&#47; 分区函数<br>      function partition(arr, p, r) {<br>        let i = p;<br>        let j = p;<br>        let point = arr[r];<br>        while (j &lt;= r) {<br>          if (arr[j] &lt; point) {<br>            let temp = arr[j];<br>            arr[j] = arr[i];<br>            arr[i] = temp;<br>            i++;<br>          }<br>          j++;<br>        }<br>        arr[r] = arr[i];<br>        arr[i] = point;<br>        return i;<br>      }<br>      console.log(&quot;nums1&quot;, nums1);<br>    };","like_count":0},{"had_liked":false,"id":336861,"user_name":"最后的轻语","can_delete":false,"product_type":"c1","uid":2932679,"ip_address":"","ucode":"C5478989F8D3AE","user_header":"https://static001.geekbang.org/account/avatar/00/2c/bf/c7/fac99257.jpg","comment_is_top":false,"comment_ctime":1646403457,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646403457","product_id":100017301,"comment_content":"第一天打卡，学习了十二集🖖","like_count":0},{"had_liked":false,"id":336826,"user_name":"Geek_36bc16","can_delete":false,"product_type":"c1","uid":2934025,"ip_address":"","ucode":"371FA1B2C29DF3","user_header":"","comment_is_top":false,"comment_ctime":1646385918,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646385918","product_id":100017301,"comment_content":"是真抽象啊...... 建议看看别人的博客怎么写的... https:&#47;&#47;blog.csdn.net&#47;shujuelin&#47;article&#47;details&#47;82423852","like_count":0},{"had_liked":false,"id":335631,"user_name":"zhoufeng","can_delete":false,"product_type":"c1","uid":1447741,"ip_address":"","ucode":"6F92F7866F9EB4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKq0oQVibKcmYJqmpqaNNQibVgia7EsEgW65LZJIpDZBMc7FyMcs7J1JmFCtp06pY8ibbcpW4ibRtG7Frg/132","comment_is_top":false,"comment_ctime":1645608923,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645608923","product_id":100017301,"comment_content":"请教各位大佬。<br>swap A[i] with A[r]<br>为什么不能改成swap   A[i] with pivot","like_count":0},{"had_liked":false,"id":335520,"user_name":"Geek_48edaa","can_delete":false,"product_type":"c1","uid":2318422,"ip_address":"","ucode":"E10AEC9A0AC609","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIJ9Kyict83d8Y95iavUqHsiaJVKbHdcTEKdsubAYvBr6FkzNicS3hGd2MRclrG2XZ0KGcgtHsCPluaNA/132","comment_is_top":false,"comment_ctime":1645572399,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645572399","product_id":100017301,"comment_content":"归并排序的合并函数是否也能改装，使其成为原地排序？","like_count":0},{"had_liked":false,"id":334208,"user_name":"Kylin。","can_delete":false,"product_type":"c1","uid":1514053,"ip_address":"","ucode":"C02B16B79C7141","user_header":"https://static001.geekbang.org/account/avatar/00/17/1a/45/5c11e1d2.jpg","comment_is_top":false,"comment_ctime":1644810484,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1644810484","product_id":100017301,"comment_content":"算法动态实现：<br>https:&#47;&#47;www.cs.usfca.edu&#47;~galles&#47;visualization&#47;Algorithms.html<br>你会回来给我点赞的","like_count":0},{"had_liked":false,"id":331928,"user_name":"Reven","can_delete":false,"product_type":"c1","uid":1161105,"ip_address":"","ucode":"487E00D144701B","user_header":"https://static001.geekbang.org/account/avatar/00/11/b7/91/257b895a.jpg","comment_is_top":false,"comment_ctime":1642903481,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1642903481","product_id":100017301,"comment_content":"归并排序要是排序的数量为奇数，那伪代码中 q = (p+r) &#47; 2 有可能是小数怎么办","like_count":0},{"had_liked":false,"id":331926,"user_name":"Reven","can_delete":false,"product_type":"c1","uid":1161105,"ip_address":"","ucode":"487E00D144701B","user_header":"https://static001.geekbang.org/account/avatar/00/11/b7/91/257b895a.jpg","comment_is_top":false,"comment_ctime":1642903392,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1642903392","product_id":100017301,"comment_content":"要兼顾多种语言，伪代码挺好的","like_count":0},{"had_liked":false,"id":330359,"user_name":"song","can_delete":false,"product_type":"c1","uid":2548071,"ip_address":"","ucode":"207F060187295E","user_header":"https://static001.geekbang.org/account/avatar/00/26/e1/67/3d9ba083.jpg","comment_is_top":false,"comment_ctime":1641950957,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641950957","product_id":100017301,"comment_content":"快排：<br> public static void quickSort(int[] data,int left,int right){<br>        if (left &lt; right) {<br>            &#47;&#47;将中间的这个数和第一个数交换<br>            int i = left, j = right, x = data[left];<br>            while (i &lt; j) {<br>                while(i &lt; j &amp;&amp; data[j] &gt;= x) &#47;&#47; 从右向左找第一个小于x的数<br>                    j--;<br>                if(i &lt; j)<br>                    data[i++] = data[j];<br><br>                while(i &lt; j &amp;&amp; data[i] &lt; x) &#47;&#47; 从左向右找第一个大于等于x的数<br>                    i++;<br>                if(i &lt; j)<br>                    data[j--] = data[i];<br>            }<br>            data[i] = x;<br>            quickSort(data, left, i - 1); &#47;&#47; 递归调用<br>            quickSort(data, i + 1, right);<br>        }<br><br>    }","like_count":0},{"had_liked":false,"id":330266,"user_name":"require","can_delete":false,"product_type":"c1","uid":2820671,"ip_address":"","ucode":"3AA3DCE0CD73E6","user_header":"","comment_is_top":false,"comment_ctime":1641888034,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641888034","product_id":100017301,"comment_content":"课后题： 可以先构建一个时间戳为key， 所属文件名为value的字典，分10次同步读取一个个文件，读取完后就得到了10个日志的时间戳（应该不会很大吧）， 再用这节课写到的排序将字典内容排序； 在写如的时候，边查字典边读文件边写，查完字典、读完文件、就得到了有序的文件，这里1G内存应该够用，不过得频繁读写文件， 需要时间回挺长","like_count":0},{"had_liked":false,"id":329909,"user_name":"敏","can_delete":false,"product_type":"c1","uid":1608307,"ip_address":"","ucode":"04EAA039553B98","user_header":"https://static001.geekbang.org/account/avatar/00/18/8a/73/e67f5eb8.jpg","comment_is_top":false,"comment_ctime":1641636808,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641636808","product_id":100017301,"comment_content":"描述能把人看晕，快排是取一个标志位pivot,一轮partition循环后比arr[pivot]小的值在数组（arr[pivot]值坐所在位置）左边，比arr[pivot]大的值在数组（arr[pivot]值坐所在位置）右边。此时arr[pivot]值的位置已经是对的，不在参与下一轮运算，左右两边的元素参与分别下一轮运算，直到参与运算的数组区段缩减为1。简单说就是通过把标志位的值排到正确的位置上完成排序。","like_count":0},{"had_liked":false,"id":329817,"user_name":"康","can_delete":false,"product_type":"c1","uid":1454534,"ip_address":"","ucode":"4B1D729C903D1F","user_header":"https://static001.geekbang.org/account/avatar/00/16/31/c6/f08d1ac5.jpg","comment_is_top":false,"comment_ctime":1641548991,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641548991","product_id":100017301,"comment_content":"伪代码看着比较费劲，也看不到需要特别注意的点","like_count":0},{"had_liked":false,"id":329515,"user_name":"Ins-think","can_delete":false,"product_type":"c1","uid":2876025,"ip_address":"","ucode":"07E73D4C963E52","user_header":"https://static001.geekbang.org/account/avatar/00/2b/e2/79/d5d021cb.jpg","comment_is_top":false,"comment_ctime":1641382866,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641382866","product_id":100017301,"comment_content":"&#47;&#47; 利用分区思想寻找第n大数<br>public static int findNth(int[] a, int k) {<br>        if (a.length &lt; k) {<br>            return -1;<br>        }<br>        int l = 0;<br>        int r = a.length - 1;<br>        int p = partition(a, l, r);<br>        while (l &lt;= r) {  &#47;&#47; similar to binary search<br>            if (k == p + 1) {<br>                return a[p];<br>            } else if (k &lt; p + 1) { &#47;&#47; in left area<br>                r = p - 1;<br>            } else {  &#47;&#47; in right area<br>                l = p + 1;<br>            }<br>            p = partition(a, l ,r);<br>        }<br>        return -1; &#47;&#47; not found<br>    }<br><br>    private static int partition(int[] a, int l, int r) {<br>        int pivot = a[r];<br>        int i = l;<br>        int j = l;<br>        while (j &lt; r) {<br>            if (a[j] &gt; pivot) {<br>                swap(a, i, j);<br>                i++;<br>            }<br>            j++;<br>        }<br>        swap(a, i, j);<br>        return i;<br>    }<br><br>    private static void swap(int[] a, int i, int j) {<br>        int tmp = a[i];<br>        a[i] = a[j];<br>        a[j] = tmp;<br>    }","like_count":0},{"had_liked":false,"id":325832,"user_name":"cvvz","can_delete":false,"product_type":"c1","uid":1943722,"ip_address":"","ucode":"FC55B0D628B266","user_header":"https://static001.geekbang.org/account/avatar/00/1d/a8/aa/de5e7d26.jpg","comment_is_top":false,"comment_ctime":1639183164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639183164","product_id":100017301,"comment_content":"1. open 10 个文件， 创建10个数组<br>2. 从每个文件中取出50M数据放入各自的数组<br>3. 进行一次merge，结果放在一个500M的数组中<br>4. 把这个数组追加写入一个500M的文件里<br>5. 重复2 - 4 步3次<br><br>需要进行30次顺序读IO操作，3次顺序写IO操作","like_count":0},{"had_liked":false,"id":324417,"user_name":"🍉","can_delete":false,"product_type":"c1","uid":1845579,"ip_address":"","ucode":"1BD735FF14C5E0","user_header":"","comment_is_top":false,"comment_ctime":1638425921,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638425921","product_id":100017301,"comment_content":"首先用一个长度为10的数组，把每一份文件都读取出来，每个元素大概是50MB。然后，根据每份数据的最早时间戳对这个数组进行排序。然后，对这个数组进行一次数据的读取，读取到500MB的缓存里面，一次可能有一条，也可能有多条数据。一次读取后重复以上操作。<br>300&#47;50x10=60次io读，6次io写。<br>CPU的优化在排序那，这里就用快排吧。","like_count":0},{"had_liked":false,"id":322716,"user_name":"HomeyLiu","can_delete":false,"product_type":"c1","uid":1330141,"ip_address":"","ucode":"EF4CCB92C369B4","user_header":"https://static001.geekbang.org/account/avatar/00/14/4b/dd/41614582.jpg","comment_is_top":false,"comment_ctime":1637564178,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637564178","product_id":100017301,"comment_content":"《我觉得最后的思考题，[曹源]同学的策略是较优的。》 有问题, 10个40M的数组,第二次从新从文件中读取塞入空闲位置后,二分法就失效了,还二分个毛,肯定出错,除非你的10个40M的数组是循环队列,还可能没问题.","like_count":0},{"had_liked":false,"id":321769,"user_name":"yini wang","can_delete":false,"product_type":"c1","uid":1457407,"ip_address":"","ucode":"E8E0447CC0EAAC","user_header":"https://static001.geekbang.org/account/avatar/00/16/3c/ff/88c1835b.jpg","comment_is_top":false,"comment_ctime":1637035969,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637035969","product_id":100017301,"comment_content":"问个简单的问题： 快排的第一个图 8 10 2 3 6 1 5， p=5， 第一次排完为什么不是2 3 1 5 8 10 6，而是图里的2 3 1 5 6 8 10 ？","like_count":0},{"had_liked":false,"id":320779,"user_name":"小竹子","can_delete":false,"product_type":"c1","uid":2813766,"ip_address":"","ucode":"D20F56114426EA","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erX65FTLyn3JMbqLKdFkkv9okdx7qmVIibl1zKB7pnCIbtElSgibULma5cTsSMyS5KGMBy5MRdXtN8g/132","comment_is_top":false,"comment_ctime":1636509862,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636509862","product_id":100017301,"comment_content":"  &#47;&#47; 判断哪个子数组中有剩余的数据<br>  var start := i，end := q<br>  if j&lt;=r then start := j, end:=r<br>记录一下这里的思考，看了几次终于想清楚了 。举的例子中，5与4比较之后，j向后移动了一位，此时j=6,r=5了。","like_count":0},{"had_liked":false,"id":320732,"user_name":"sean","can_delete":false,"product_type":"c1","uid":2703237,"ip_address":"","ucode":"B517C6A09A4F07","user_header":"","comment_is_top":false,"comment_ctime":1636474344,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1636474344","product_id":100017301,"comment_content":"归并排序那个可以在最后面加个无限大的数字哨兵，不过快排这个伪代码确实看不懂，还是百度一下学会的","like_count":0},{"had_liked":false,"id":319987,"user_name":"Stockholm","can_delete":false,"product_type":"c1","uid":2798455,"ip_address":"","ucode":"5F6501554B631E","user_header":"https://static001.geekbang.org/account/avatar/00/2a/b3/77/cb9ca598.jpg","comment_is_top":false,"comment_ctime":1636028290,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636028290","product_id":100017301,"comment_content":"归并的思想很重要","like_count":0},{"had_liked":false,"id":319573,"user_name":"今晚打老虎","can_delete":false,"product_type":"c1","uid":1999169,"ip_address":"","ucode":"F6D070168BE32D","user_header":"https://static001.geekbang.org/account/avatar/00/1e/81/41/cabfacd0.jpg","comment_is_top":false,"comment_ctime":1635855021,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635855021","product_id":100017301,"comment_content":"最后的循环copy到原来的数据，伪代码，感觉这样写会清楚明了点？<br>&#47;&#47; 将tmp中的数组拷贝回A[p...r] <br>for i:=0 to r-p do { A[p+i] = tmp[i] }<br>for i := 0; i &lt;= r - p do ....<br>","like_count":0},{"had_liked":false,"id":319572,"user_name":"今晚打老虎","can_delete":false,"product_type":"c1","uid":1999169,"ip_address":"","ucode":"F6D070168BE32D","user_header":"https://static001.geekbang.org/account/avatar/00/1e/81/41/cabfacd0.jpg","comment_is_top":false,"comment_ctime":1635854792,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635854792","product_id":100017301,"comment_content":"归并排序merge里申请一个tmp数组，应该是有bug的吧。r-p个大小的数组，存不下呢？只小一轮，元素至少是2个，是不是应该直接为r+1个？","like_count":0},{"had_liked":false,"id":319391,"user_name":"tiger","can_delete":false,"product_type":"c1","uid":2088619,"ip_address":"","ucode":"2E15ECF80E4FDB","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/VV0hlhNzS38M2fOV1icf6T5oEJHmdAOicejIDSQQoR4GFHJYxkdKKmp3ZcAZ4TtogrrnocKjsVngalQVo34YWGMw/132","comment_is_top":false,"comment_ctime":1635773596,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635773596","product_id":100017301,"comment_content":"快排的伪代码中，应该是A[j] &lt;= pivot ，如果不加上等于，对于数组{4,5,3,11,2,7,9,4}，分区后，结果是：{3,2,4,11,5,7,9,4}","like_count":0},{"had_liked":false,"id":319124,"user_name":"杨","can_delete":false,"product_type":"c1","uid":1971269,"ip_address":"","ucode":"7EFEFE285975C6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/oltLEqTrmHm2aJP99BK6tHu5h7hp4aj08wR5Wt6H31iadFduDAVvjYKmhQ2nvGbLV3lkVdiat2GRasgWXoJeTibUg/132","comment_is_top":false,"comment_ctime":1635597479,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635597479","product_id":100017301,"comment_content":"小顶堆每次只能读一个数据 写一个数据  我们是否可以学习redis的多路复用机制呢  把10个文件读取到10个队列中(每个队列只能保存一定的数据)   10个数据组成小顶堆  移除最小的  然后从最小数据的队列中取一个数据插入小顶堆  重复操作","like_count":0},{"had_liked":false,"id":309234,"user_name":"侯恩训","can_delete":false,"product_type":"c1","uid":1162376,"ip_address":"","ucode":"F4DC47EECA0F00","user_header":"https://static001.geekbang.org/account/avatar/00/11/bc/88/fbb6022e.jpg","comment_is_top":false,"comment_ctime":1629992377,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629992377","product_id":100017301,"comment_content":"学习总结：<br>归并排序和快速排序都使用了分治的思想，分治是一种解决问题的思想，递归是一种编程技巧。<br>归并排序时间复杂度是O(nlogn),稳定排序，但不是原地排序算法，空间复杂度是O(n)<br>快速排序时间平均时间复杂度是O(nlogn),最高时间复杂度是O(n2),借助编程技巧是原地排序算法。<br><br>思考题<br>可以选择归并排序顺序从两个文件读取数据，对比大小依次放到新文件中<br>","like_count":0},{"had_liked":false,"id":305577,"user_name":"佳成_Cahen","can_delete":false,"product_type":"c1","uid":2324353,"ip_address":"","ucode":"88091603E3AD9B","user_header":"https://static001.geekbang.org/account/avatar/00/23/77/81/9bc87164.jpg","comment_is_top":false,"comment_ctime":1628055799,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628055799","product_id":100017301,"comment_content":"不妨假设文件名分别为a,b,c,....i,j.<br>第一步：找出a~j中含最早日期的文件，不妨设为a。<br>第二部：取文件a和b，将文件b中最早日期插入a，将文件a中最晚日期插入b，遍历整个文件b，得到新的文件a，这包含文件a和b中最小的日期。<br>第三步，对其他文件c,d,...i,j，依次替换第二部中文件b，重复第二步，得到最终文件a，这时a包含十个文件中最小值日期。<br>第四步，现在剩下9个文件b,c....i,j.重复前三步，即可得到完全按照日期排列的新文件a~j。","like_count":0},{"had_liked":false,"id":303726,"user_name":"张磊","can_delete":false,"product_type":"c1","uid":1926761,"ip_address":"","ucode":"93CBBA8F7255A1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/3icbXwRVsJHXB7xu9KFOxyCc3mkom7y49x2oRyzTVNNZrjSvKRL4UVPf8cYmJ2bpQqYPAWIwzz4hiaxicnicWvr80w/132","comment_is_top":false,"comment_ctime":1626945809,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626945809","product_id":100017301,"comment_content":"老师您好，关于快速排序和归并排序的空间复杂度有一个疑问，你说的快速排序空间复杂度是O(1)，但是讲递归的那一章节你也说过递归也是需要占用临时空间（例如java栈），所以按照递归的话理解快排的最好的空间复杂度是O(logn)，最坏的是O(n)。归并排序递归到最深也没有第一次的","like_count":0},{"had_liked":false,"id":302543,"user_name":"如我所愿","can_delete":false,"product_type":"c1","uid":1196695,"ip_address":"","ucode":"7AFA75F0299DC2","user_header":"https://static001.geekbang.org/account/avatar/00/12/42/97/45334aed.jpg","comment_is_top":false,"comment_ctime":1626255008,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626255008","product_id":100017301,"comment_content":"伪代码看不懂的，可以看一下伪代码的规范，对照着规范可以很快写出代码。","like_count":0},{"had_liked":false,"id":302412,"user_name":"30号男朋友","can_delete":false,"product_type":"c1","uid":1351052,"ip_address":"","ucode":"C9F4F532AE974F","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/8c/85fbc5ed.jpg","comment_is_top":false,"comment_ctime":1626203189,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1626203189","product_id":100017301,"comment_content":"简单的东西讲复杂。编程是表达，写作是表达，讲话也是表达，这些能力不相通也不传递。","like_count":0},{"had_liked":false,"id":302381,"user_name":"菽绣","can_delete":false,"product_type":"c1","uid":1755477,"ip_address":"","ucode":"60955E14C39C6B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/c9/55/0e627a31.jpg","comment_is_top":false,"comment_ctime":1626185029,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626185029","product_id":100017301,"comment_content":"可以把10个日志文件的最小时间统计出来，排个序，那就可以先一直读最小时间最小的那个文件，直到达到了第二个日志文件的最小时间，再开始对两个日志文件的数据进行排序<br>这样最好情况下，时间复杂度是n，常数是1","like_count":0},{"had_liked":false,"id":302288,"user_name":"$Jason","can_delete":false,"product_type":"c1","uid":1040403,"ip_address":"","ucode":"BB0DB558D5BBB3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e0/13/6c2a5bd2.jpg","comment_is_top":false,"comment_ctime":1626156821,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626156821","product_id":100017301,"comment_content":"在我看github上的找最大K 值的代码，发现在swap的条件那里，有错误，源码写的是if (arr[j] &lt; pivot) ，其实应该是是if (arr[j] &gt; pivot) ","like_count":0},{"had_liked":false,"id":298872,"user_name":"Geek_6bf244","can_delete":false,"product_type":"c1","uid":1685861,"ip_address":"","ucode":"65D467C9C3272F","user_header":"","comment_is_top":false,"comment_ctime":1624353898,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624353898","product_id":100017301,"comment_content":"看算法精力必须持续高度集中，而且要反复看，难受啊","like_count":0},{"had_liked":false,"id":297242,"user_name":"赵吉波","can_delete":false,"product_type":"c1","uid":2617743,"ip_address":"","ucode":"154C7A1B19EAB2","user_header":"https://static001.geekbang.org/account/avatar/00/27/f1/8f/a0cbf407.jpg","comment_is_top":false,"comment_ctime":1623391453,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623391453","product_id":100017301,"comment_content":"归并排序C#<br>  static void merge_sort(int[] arr, int startIndex, int endIndex)<br>        {<br>            if (startIndex &gt;= endIndex) return;<br>            int midIndex = (startIndex + endIndex) &#47; 2;<br>            merge_sort(arr, startIndex, midIndex);<br>            merge_sort(arr, midIndex + 1, endIndex);<br>          &#47;&#47;  Console.WriteLine(startIndex);<br>            &#47;&#47;Console.WriteLine( midIndex);<br>          &#47;&#47;  Console.WriteLine(endIndex);<br>        &#47;&#47;    Console.WriteLine(<br>           &#47;&#47;     &quot;-------------------------------------------------------------------------------------------------&quot;);<br>            merge(arr, startIndex, midIndex, endIndex);<br>        }<br> static void merge(int[] arr, int startIndex, int midIndex, int endIndex)<br>        {<br>            int count = endIndex - startIndex;<br>            int[] temp = new int[count + 1];<br>            int tempIndex = 0;<br>            int i = startIndex;<br>            int j = midIndex+1;<br>            while (i &lt;= midIndex &amp;&amp; j &lt;= endIndex)<br>            {<br>                if (arr[j] &lt; arr[i])<br>                {<br>                    temp[tempIndex] = arr[j];<br>                    tempIndex++;<br>                    j++;<br>                }<br>                else<br>                {<br>                    temp[tempIndex] = arr[i];<br>                    tempIndex++;<br>                    i++;<br>                }<br>            }<br><br>            while (i &lt;= midIndex)<br>            {<br>                temp[tempIndex] = arr[i];<br>                tempIndex++;<br>                i++;<br>            }<br>            while (j &lt;= endIndex)<br>            {<br>                temp[tempIndex] = arr[j];<br>                tempIndex++;<br>                j++;<br>            }<br><br>            for (int m= 0; m &lt; temp.Length; m++)<br>            {<br>                arr[startIndex + m] = temp[m];<br>            }<br><br>        }","like_count":0},{"had_liked":false,"id":296019,"user_name":"文艺科技青年","can_delete":false,"product_type":"c1","uid":1087726,"ip_address":"","ucode":"4801899BC41B13","user_header":"https://static001.geekbang.org/account/avatar/00/10/98/ee/9d162043.jpg","comment_is_top":false,"comment_ctime":1622706753,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622706753","product_id":100017301,"comment_content":"public class QuickSort {<br>    public void quickSort(int[] a) {<br>        sort(a, 0, a.length - 1);<br>        System.out.println(&quot;QuickSort:&quot;);<br>        for (int m:a) {<br>            System.out.println(m);<br>        }<br>    }<br><br>    private void sort(int[] a, int low, int high) {<br>        if (low &lt;= high){<br>            &#47;&#47; 获取分区点<br>            int pivot = partition(a, low, high);<br>            sort(a, low, pivot - 1);<br>            sort(a, pivot + 1, high);<br>        }<br>    }<br><br>    private int partition(int[] a, int left, int right) &#47;&#47;返回调整后基准数的位置<br>    {<br>        int pivot = a[right];<br>        int i = left;<br>        for(int j = left; j &lt; right; j++){<br>            if(a[j] &lt; pivot){<br>                if(i!=j){<br>                    swap(a, i, j);<br>                }<br>                i++;<br>            }<br>        }<br>        swap(a, i, right);<br>        return i;<br>    }<br><br>    private void swap(int[] a, int i,int j){<br>        int tmp = a[i];<br>        a[i] = a[j];<br>        a[j] = tmp;<br>    }<br><br><br><br>}","like_count":0},{"had_liked":false,"id":295322,"user_name":"Tim","can_delete":false,"product_type":"c1","uid":1480717,"ip_address":"","ucode":"3AAA9FD3D8DDDB","user_header":"https://static001.geekbang.org/account/avatar/00/16/98/0d/fb77a32c.jpg","comment_is_top":false,"comment_ctime":1622364802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622364802","product_id":100017301,"comment_content":"老师 课后思考题，有没有你这边的官方解答啊。看下面的留言版本还是太多了","like_count":0},{"had_liked":false,"id":295063,"user_name":"Geek_978043","can_delete":false,"product_type":"c1","uid":1698296,"ip_address":"","ucode":"E1A5F5D93D2969","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/vmibOkjyGKIOB3MDd9lcH6WbH2hyxwEzwNmTbtASV2Z0SHbVIkxvylLXRjRtFflNpoficmh6LicsCyn7yEsl8sdww/132","comment_is_top":false,"comment_ctime":1622201202,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622201202","product_id":100017301,"comment_content":"hello，我觉得你这个快速排序的哨兵指针貌似不对，应该一个执行头部，一个指向尾部","like_count":0},{"had_liked":false,"id":294632,"user_name":"范富强","can_delete":false,"product_type":"c1","uid":2582289,"ip_address":"","ucode":"C5FFFCC9BBB63A","user_header":"","comment_is_top":false,"comment_ctime":1622027563,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622027563","product_id":100017301,"comment_content":"构建10个IO流，分别读取每个文件。使用插入排序保存取出后的日志记录，取排序后的第一条数据，写入新文件，取完之后立刻获取这条数据所在文件的下一条，循环往复直至所有文件读取完毕","like_count":0},{"had_liked":false,"id":292635,"user_name":"✌vv_VIP✌","can_delete":false,"product_type":"c1","uid":1828464,"ip_address":"","ucode":"63FF97F93F1F93","user_header":"https://static001.geekbang.org/account/avatar/00/1b/e6/70/d9471efa.jpg","comment_is_top":false,"comment_ctime":1620906339,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620906339","product_id":100017301,"comment_content":"def cal_top_k_in_list(input_list, k, start, end):<br>    &quot;&quot;&quot;<br>    计算输入列表中第K大的数<br>    :param input_list:<br>    :param k:<br>    :return:<br>    &quot;&quot;&quot;<br>    pivot_index = fast_sort(input_list, start, end)<br>    print(&quot;pivot_index: &quot; + str(pivot_index))<br>    if pivot_index == k-1:<br>        print(&quot;find ret: &quot; + str(input_list[pivot_index]))<br>    elif pivot_index &gt; k-1:<br>        cal_top_k_in_list(input_list, k, 0, pivot_index-1)<br>    else:<br>        cal_top_k_in_list(input_list, k, end-pivot_index, end)<br><br>def fast_sort(int_list, start, end):<br>    pivot = end<br>    pivot_value = int_list[pivot]<br>    i = start<br>    for j in range(start, end):<br>        if int_list[j] &lt; pivot_value:<br>            tmp = int_list[i]<br>            int_list[i] = int_list[j]<br>            int_list[j] = tmp<br>            i += 1<br>    tmp = int_list[i]<br>    int_list[i] = int_list[pivot]<br>    int_list[pivot] = tmp<br>    return i","like_count":0},{"had_liked":false,"id":292005,"user_name":"焱","can_delete":false,"product_type":"c1","uid":1113301,"ip_address":"","ucode":"677BF1BE4B94D5","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/d5/1cf5fd56.jpg","comment_is_top":false,"comment_ctime":1620641455,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620641455","product_id":100017301,"comment_content":"没救了，看不懂递归的哪里是怎么执行了，越调越晕！","like_count":0},{"had_liked":false,"id":291002,"user_name":"双木公子","can_delete":false,"product_type":"c1","uid":1116567,"ip_address":"","ucode":"751885864D3AB7","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/97/4314e2d8.jpg","comment_is_top":false,"comment_ctime":1619928293,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619928293","product_id":100017301,"comment_content":"https:&#47;&#47;blog.csdn.net&#47;BruceLee1314?spm=1001.2101.3001.5343&amp;type=blog，关于本文的算法代码整理","like_count":0},{"had_liked":false,"id":290090,"user_name":"春容","can_delete":false,"product_type":"c1","uid":1206023,"ip_address":"","ucode":"B59830276FEE57","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/07/d5d9da1a.jpg","comment_is_top":false,"comment_ctime":1619357233,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619357233","product_id":100017301,"comment_content":"十个生产者读取文件数据，放入对应的十个循环队列，一个消费者根据时间戳大小归并这十个循环队列的数据到新文件","like_count":0},{"had_liked":false,"id":289822,"user_name":"大方方","can_delete":false,"product_type":"c1","uid":1354013,"ip_address":"","ucode":"621AD8F1485753","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6cyOoRd2dROgiblAJkW6RLhUyH1wwU0NNibIIuV930eQ9TiaNT41K61kBSVkvYoDYg7mJtuEoCQY1awBmV0WW6BFg/132","comment_is_top":false,"comment_ctime":1619189804,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619189804","product_id":100017301,"comment_content":"刷题的时候有一个求最小高度二叉树的算法，费了半天劲写出来，现在想想正是分治并归的思想。","like_count":0},{"had_liked":false,"id":289687,"user_name":"Laughing","can_delete":false,"product_type":"c1","uid":1002134,"ip_address":"","ucode":"F68F1E000CA800","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/96/99466a06.jpg","comment_is_top":false,"comment_ctime":1619144674,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619144674","product_id":100017301,"comment_content":"日志文件读取思路：<br>1. 设计10个IO流统一按行来读取文件内容<br>2. 构建一个固定长度为10的数组排序用，另外构建一个适合长度的队列用于顺序写入用<br>3. 每次排序后选取最小的数据写入到队列中<br>4. 起单独的线程顺序读取队列中的日志并写入文件<br><br>这样既解决了多文件日志排序的问题，又因为使用队列减少了排序计算与写文件之间的效率差异。<br>同时也充分使用了内存的优势。","like_count":0},{"had_liked":false,"id":288013,"user_name":"命中水","can_delete":false,"product_type":"c1","uid":1178715,"ip_address":"","ucode":"2D4431A9CC67EA","user_header":"https://static001.geekbang.org/account/avatar/00/11/fc/5b/4b92d745.jpg","comment_is_top":false,"comment_ctime":1618274706,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618274706","product_id":100017301,"comment_content":"T(n) = 2*T(n&#47;2) + n，这个推导没看懂，n代表的循环次数么，那下次嵌套循环的次数不应该是n&#47;2,下下次嵌套循环次数不应该是n&#47;4么，为什么每次都是n","like_count":0},{"had_liked":false,"id":287436,"user_name":"ding","can_delete":false,"product_type":"c1","uid":1014401,"ip_address":"","ucode":"54AF950B3CA740","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/81/69874318.jpg","comment_is_top":false,"comment_ctime":1617950409,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617950409","product_id":100017301,"comment_content":"归并排序搞了一个下午才调通。<br>伪代码的好处就是，自己不得不写代码去实现，这个实现过程可以学习到公司。确实就是费时费脑^_^<br><br>维基百科有一个另外版本<br>    &#47;**<br>     * Wikipedia的版本<br>     *<br>     * @param arr<br>     *&#47;<br>    public static void mergeSortWikipedia(int[] arr) {<br>        System.out.println(&quot;before:&quot; + Arrays.toString(arr));<br>        int n = arr.length;<br>        int[] result = new int[n];<br>        merge_sort_recursive(arr, result, 0, n - 1);<br>        System.out.println(&quot;after :&quot; + Arrays.toString(arr));<br>    }<br><br>    static void merge_sort_recursive(int[] arr, int[] result, int start, int end) {<br>        if (start &gt;= end)<br>            return;<br>        int len = end - start, mid = (len &gt;&gt; 1) + start;<br>        int s1 = start, e1 = mid;<br>        int s2 = mid + 1, e2 = end;<br><br>        merge_sort_recursive(arr, result, s1, e1);<br>        merge_sort_recursive(arr, result, s2, e2);<br><br>        int k = start;<br>        while (s1 &lt;= e1 &amp;&amp; s2 &lt;= e2)<br>            result[k++] = arr[s1] &lt; arr[s2] ? arr[s1++] : arr[s2++];<br>        while (s1 &lt;= e1)<br>            result[k++] = arr[s1++];<br>        while (s2 &lt;= e2)<br>            result[k++] = arr[s2++];<br>        for (k = start; k &lt;= end; k++)<br>            arr[k] = result[k];<br>    }","like_count":0},{"had_liked":false,"id":285825,"user_name":"阳.","can_delete":false,"product_type":"c1","uid":1112650,"ip_address":"","ucode":"3D48CEA896FAE1","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/4a/8b4372a8.jpg","comment_is_top":false,"comment_ctime":1617021557,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617021557","product_id":100017301,"comment_content":"利用归并排序的思想，将10个文件分成两个小组，小组再拆成两个小组直到不能拆分，将不能拆分的两个文件从磁盘取出来排好序再写到一个新的文件中(排序的时候每拿到一个最小值就写入磁盘，防止内存不够用)，合并结束向上层调用者返回新文件路径；直到递归结束，然后删除临时文件只剩最后的那个文件。","like_count":0},{"had_liked":false,"id":285792,"user_name":"陈莹","can_delete":false,"product_type":"c1","uid":1023499,"ip_address":"","ucode":"726BBEA288C50E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9e/0b/a8f81ba6.jpg","comment_is_top":false,"comment_ctime":1617014437,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617014437","product_id":100017301,"comment_content":"归并排序<br>1、十个文件，两两排序后形成5个有序日志文件，<br>2、循坏操作1，5-&gt;3, 3-&gt;2, 2-&gt;1，完成排序","like_count":0},{"had_liked":false,"id":284256,"user_name":"Del皮耶罗","can_delete":false,"product_type":"c1","uid":1326223,"ip_address":"","ucode":"E90D6311ED875F","user_header":"https://static001.geekbang.org/account/avatar/00/14/3c/8f/be719404.jpg","comment_is_top":false,"comment_ctime":1616142642,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616142642","product_id":100017301,"comment_content":"对于快排的空间复杂度，好像其他资料里的说法不一，有说与递归深度有关的，具体应该是什么呢是O(1)吗","like_count":0},{"had_liked":false,"id":284201,"user_name":"小苏","can_delete":false,"product_type":"c1","uid":1990300,"ip_address":"","ucode":"CC2ADE51598AF6","user_header":"https://static001.geekbang.org/account/avatar/00/1e/5e/9c/0efcc194.jpg","comment_is_top":false,"comment_ctime":1616120439,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616120439","product_id":100017301,"comment_content":"归并排序，这10个300MB文件先内部排序，然后每次加载这10个文件里前100MB大小内容到内存中，进行排序，写入硬盘，再加载10个文件后面100MB内容，直到排序结束。","like_count":0},{"had_liked":false,"id":284105,"user_name":"ICE FROG","can_delete":false,"product_type":"c1","uid":1812082,"ip_address":"","ucode":"31E3DBD22CCC3E","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a6/72/526fd3df.jpg","comment_is_top":false,"comment_ctime":1616066462,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616066462","product_id":100017301,"comment_content":"将原始数组拆分为子数组或多个区域之后，他们各自（子数组）的排序如何做？我理解没错的话貌似没提到","like_count":0},{"had_liked":false,"id":283679,"user_name":"Kyle(","can_delete":false,"product_type":"c1","uid":1640978,"ip_address":"","ucode":"0C14C4C086CAA9","user_header":"https://static001.geekbang.org/account/avatar/00/19/0a/12/f8b988b8.jpg","comment_is_top":false,"comment_ctime":1615883232,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615883232","product_id":100017301,"comment_content":"这章节我看了一整天，终于到评论区了，一把鼻涕一把泪，先发个评论庆祝下，555...","like_count":0},{"had_liked":false,"id":283621,"user_name":"Geek_05e657","can_delete":false,"product_type":"c1","uid":2474657,"ip_address":"","ucode":"537BB7E3CDB72D","user_header":"","comment_is_top":false,"comment_ctime":1615859259,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615859259","product_id":100017301,"comment_content":"归并是通过递归先分解，然后递归返回时，左右数组按元素大小合并回去<br>快排则在下一次递归分解前把数据以Pivot元素为中心分成左右两部分，相当于递归返回的时候就没有什么操作了","like_count":0},{"had_liked":false,"id":281609,"user_name":"八九","can_delete":false,"product_type":"c1","uid":1191617,"ip_address":"","ucode":"B996A884BFA474","user_header":"https://static001.geekbang.org/account/avatar/00/12/2e/c1/0fcd29ab.jpg","comment_is_top":false,"comment_ctime":1614827199,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614827199","product_id":100017301,"comment_content":"java版本-快速排序 <br>public static void main(String[] args) {<br>        int[] arr = new int[]{11, 8, 3, 9, 7, 1, 2, 5};<br>        System.out.println(&quot;排序前&quot; + Arrays.toString(arr));<br>&#47;&#47;        arr = merge_sort(arr);<br>        arr = quick_sort(arr, 0, arr.length - 1);<br>        System.out.println(&quot;排序后&quot; + Arrays.toString(arr));<br>    }<br><br>    &#47;* 快速排序<br>     * 处理过程是由上到下的，先分区，然后再处理子问题。<br>     * 递推公式：quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)<br>     * 终止条件：p &gt;= r<br>     * 11 8 3 9 7 1 2 [5] (取最后一个元素作为pivot分区点)<br>     * 3-1-[2]  5  7-8-11-[9]<br>     * 1 2 3  7-[8] 9 11<br>     *        7 8<br>     * 1 2 3 7 8 9 11<br>     * *&#47;<br>    static int[] quick_sort(int[] arr, int p, int r) {<br>        if (p &lt; r) {<br>            int q = partition(arr, p, r);<br>            quick_sort(arr, p, q - 1);<br>            quick_sort(arr, q + 1, r);<br>        }<br>        return arr;<br>    }<br><br>    &#47;*分区<br>    通过游标 i 把 A[p...r-1]分成两部分。A[p...i-1]的元素都是小于 pivot 的，我们暂且叫它“已处理区间”，A[i...r-1]是“未处理区间”。<br>    每次都从未处理的区间 A[i...r-1]中取一个元素 A[j]，与 pivot 对比，如果小于 pivot，则将其加入到已处理区间的尾部，也就是 A[i]的位置。<br>    只需要将 A[i]与 A[j]交换，就可以在 O(1) 时间复杂度内将 A[j]放到下标为 i 的位置。*&#47;<br>    static int partition(int[] arr, int left, int right) {<br>        int pivot = left;<br>        int j = pivot + 1;<br>        for (int i = j; i &lt;= right; i++) {<br>            if (arr[i] &lt; arr[pivot]) {<br>                swap(arr, i, j);<br>                j++;<br>            }<br>        }<br>        swap(arr, pivot, j - 1);<br>        return j - 1;<br>    }<br><br>    static void swap(int[] arr, int i, int j) {<br>        System.out.println(&quot;arr[i]:&quot; + arr[i] + &quot;,arr[j]:&quot; + arr[j] + &quot;互换！&quot;);<br>        int temp = arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = temp;<br>    }<br>","like_count":0},{"had_liked":false,"id":281491,"user_name":"八九","can_delete":false,"product_type":"c1","uid":1191617,"ip_address":"","ucode":"B996A884BFA474","user_header":"https://static001.geekbang.org/account/avatar/00/12/2e/c1/0fcd29ab.jpg","comment_is_top":false,"comment_ctime":1614763989,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614763989","product_id":100017301,"comment_content":"java版本-归并排序（看参考才搞出来，我太笨了）<br>    &#47;* 归并排序<br>     * 处理过程是由下到上的，先处理子问题，然后再合并。<br>     * 递推公式：merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))<br>     * 终止条件：p &gt;= r<br>     *  11 8 3 9 7 1 2 5<br>        11-8-3-9  7-1-2-5<br>        11-8  3-9  7-1  2-5<br>        8-11  3-9  1-7  2-5<br>        3-8-9-11  1-2-5-7<br>        1 2 3 5 7 8 9 11<br>     * *&#47;<br>    static int[] merge_sort(int[] arr) {<br>        if (arr.length &lt; 2) {<br>            return arr;<br>        }<br>        int middle = (int) Math.floor(arr.length &#47; 2);<br>        int[] left = Arrays.copyOfRange(arr, 0, middle);<br>        int[] right = Arrays.copyOfRange(arr, middle, arr.length);<br>        System.out.println(&quot;mergeA&quot; + Arrays.toString(left));<br>        System.out.println(&quot;mergeB&quot; + Arrays.toString(right));<br>        return merge(merge_sort(left), merge_sort(right));<br>    }<br><br>    &#47;*合并<br>      申请一个临时数组 tmp，大小与 A[p...r]相同。我们用两个游标 i 和 j，分别指向 A[p...q]和 A[q+1...r]的第一个元素。<br>      比较这两个元素 A[i]和 A[j]，如果 A[i]&lt;=A[j]，我们就把 A[i]放入到临时数组 tmp，并且 i 后移一位，否则将 A[j]放入到数组 tmp，j 后移一位。<br>      继续上述比较过程，直到其中一个子数组中的所有数据都放入临时数组中，再把另一个数组中的数据依次加入到临时数组的末尾，这个时候，临时数组中存储的就是两个子数组合并之后的结果了。<br>      最后再把临时数组 tmp 中的数据拷贝到原数组 A[p...r]中。*&#47;<br>    static int[] merge(int[] arrL, int[] arrR) {<br>        int i = 0, j = 0, k = 0;<br>        int[] tmp = new int[arrL.length + arrR.length];<br>        while (arrL.length &gt; i &amp;&amp; arrR.length &gt; j) {<br>            if (arrL[i] &lt;= arrR[j]) {<br>                tmp[k++] = arrL[i++];<br>            } else {<br>                tmp[k++] = arrR[j++];<br>            }<br>        }<br>        &#47;&#47; 判断哪个子数组中有剩余的数据<br>        while (i &lt; arrL.length) {<br>            tmp[k++] = arrL[i++];<br>        }<br>        while (j &lt; arrR.length) {<br>            tmp[k++] = arrR[j++];<br>        }<br>        System.out.println(&quot;tmp:&quot; + Arrays.toString(tmp));<br>        return tmp;<br>    }<br>","like_count":0},{"had_liked":false,"id":281228,"user_name":"八九","can_delete":false,"product_type":"c1","uid":1191617,"ip_address":"","ucode":"B996A884BFA474","user_header":"https://static001.geekbang.org/account/avatar/00/12/2e/c1/0fcd29ab.jpg","comment_is_top":false,"comment_ctime":1614652436,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614652436","product_id":100017301,"comment_content":"笔记二：<br>4.快速排序算法（Quicksort-快排）<br>1).原理：如果要排序数组中下标从 p 到 r 之间的一组数据，选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。<br>遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。<br>经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。<br>根据分治、递归的处理思想，可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。<br>递推公式：quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)<br>终止条件：p &gt;= r<br>归并排序中有一个 merge() 合并函数，这里有一个 partition() 分区函数。<br>partition() 分区函数就是随机选择一个元素作为 pivot（一般情况下，可以选择 p 到 r 区间的最后一个元素），然后对 A[p...r]分区，函数返回 pivot 的下标。<br>通过游标 i 把 A[p...r-1]分成两部分。A[p...i-1]的元素都是小于 pivot 的，我们暂且叫它“已处理区间”，A[i...r-1]是“未处理区间”。<br>每次都从未处理的区间 A[i...r-1]中取一个元素 A[j]，与 pivot 对比，如果小于 pivot，则将其加入到已处理区间的尾部，也就是 A[i]的位置。<br>只需要将 A[i]与 A[j]交换，就可以在 O(1) 时间复杂度内将 A[j]放到下标为 i 的位置。<br>2).快速排序不是一个稳定的排序算法<br><br>3).快排和归并用的都是分治思想，递推公式和递归代码也非常相似，那它们的区别在哪里呢？<br>归并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。<br>归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。<br><br>4).快速排序的性能分析<br>如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并是相同的。所以，快排的时间复杂度也是 O(nlogn)。<br>但是，公式成立的前提是每次分区操作，选择的 pivot 都很合适，正好能将大区间对等地一分为二。但实际上这种情况是很难实现的。<br>比如：如果数组中的数据原来已经是有序的了，比如 1，3，5，6，8。<br>如果每次选择最后一个元素作为 pivot，那每次分区得到的两个区间都是不均等的。需要进行大约 n 次分区操作，才能完成快排的整个过程。<br>每次分区平均要扫描大约 n&#47;2 个元素，这种情况下，快排的时间复杂度就从 O(nlogn) 退化成了 O(n^2)。<br>结论：T(n) 在大部分情况下的时间复杂度都可以做到 O(nlogn)，只有在极端情况下，才会退化到 O(n^2)。通过合理地选择 pivot 来避免这种情况。<br>5.如何在 O(n) 的时间复杂度内查找一个无序数组中的第 K 大元素？<br>选择数组区间 A[0...n-1]的最后一个元素 A[n-1]作为 pivot，对数组 A[0...n-1]原地分区，这样数组就分成了三部分，A[0...p-1]、A[p]、A[p+1...n-1]。<br>如果 p+1=K，那 A[p]就是要求解的元素；如果 K&gt;p+1, 说明第 K 大元素出现在 A[p+1...n-1]区间，再按照上面的思路递归地在 A[p+1...n-1]这个区间内查找。同理，如果 K&lt;p+1，那我们就在 A[0...p-1]区间查找。<br>为什么上述解决思路的时间复杂度是 O(n)？<br>第一次分区查找，需要对大小为 n 的数组执行分区操作，需要遍历 n 个元素。第二次分区查找，只需要对大小为 n&#47;2 的数组执行分区操作，需要遍历 n&#47;2 个元素。<br>依次类推，分区遍历元素的个数分别为、n&#47;2、n&#47;4、n&#47;8、n&#47;16.……直到区间缩小为 1。如果把每次分区遍历的元素个数加起来，就是：n+n&#47;2+n&#47;4+n&#47;8+...+1。这是一个等比数列求和，最后的和等于 2n-1。<br>所以，上述解决思路的时间复杂度就为 O(n)。<br>","like_count":0},{"had_liked":false,"id":281227,"user_name":"八九","can_delete":false,"product_type":"c1","uid":1191617,"ip_address":"","ucode":"B996A884BFA474","user_header":"https://static001.geekbang.org/account/avatar/00/12/2e/c1/0fcd29ab.jpg","comment_is_top":false,"comment_ctime":1614652360,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614652360","product_id":100017301,"comment_content":"笔记一：<br>1.冒泡排序、插入排序、选择排序，时间复杂度比较高，都是O(n^2)，适合小规模数据的排序。<br>归并排序和快速排序：O(nlogn) ，这两种排序算法适合大规模的数据排序。<br><br>2.分治思想：分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。<br>分治算法一般都是用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧。<br><br>3.归并排序（Merge Sort）：<br>1).原理：把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。<br>递推公式：merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))<br>终止条件：p &gt;= r 不用再继续分解<br>其中，merge_sort(p…r)：给下标从p到r之间的数组排序。<br>\t  merge(merge_sort(p…q), merge_sort(q+1…r))下标q等于p和r的中间位置，也就是 (p+r)&#47;2。<br>merge()：申请一个临时数组 tmp，大小与 A[p...r]相同。用两个游标 i 和 j，分别指向 A[p...q]和 A[q+1...r]的第一个元素。  （借助哨兵）<br>比较这两个元素 A[i]和 A[j]，如果 A[i]&lt;=A[j]，就把 A[i]放入到临时数组 tmp，并且 i 后移一位，否则将 A[j]放入到数组 tmp，j 后移一位。<br>继续上述比较过程，直到其中一个子数组中的所有数据都放入临时数组中，再把另一个数组中的数据依次加入到临时数组的末尾。最后再把临时数组tmp中的数据拷贝到原数组 A[p...r]中。<br><br>2).归并排序是一个稳定的排序算法<br><br>3).时间复杂度：<br>不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。<br>假设对 n 个元素进行归并排序需要的时间是 T(n)，那分解成两个子数组排序的时间都是 T(n&#47;2)。merge() 函数合并两个有序子数组的时间复杂度是 O(n)。<br>时间复杂度的计算公式：T(1) = C； n=1时，只需要常量级的执行时间，所以表示为C。<br>                      T(n) = 2*T(n&#47;2) + n； n&gt;1<br>分解一下计算过程：         = 2*(2*T(n&#47;4)+n&#47;2)+n = 4*T(n&#47;4)+2*n<br>\t\t\t\t\t\t   = 4*(2*T(n&#47;8) + n&#47;4) + 2*n = 8*T(n&#47;8) + 3*n <br>\t\t\t\t\t\t   = 8*(2*T(n&#47;16) + n&#47;8) + 3*n = 16*T(n&#47;16) + 4*n<br>\t\t\t\t\t\t   ......<br>\t\t\t\t\t\t   = 2^k * T(n&#47;2^k) + k * n<br>当T(n&#47;2^k)=T(1)时(数据区间变成1的时候排序就完成了)，也就是 n&#47;2^k=1，得到 k=log2n 。如果用大O标记法来表示的话，T(n)就等于O(nlogn)。所以归并排序的时间复杂度是O(nlogn)。<br>归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)。<br><br>4).空间复杂度：<br>归并排序不是原地排序算法。这是因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。<br>尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。<br>在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)。<br>","like_count":0},{"had_liked":false,"id":280580,"user_name":"罗耀龙@坐忘","can_delete":false,"product_type":"c1","uid":1917663,"ip_address":"","ucode":"3CEA258DE7F3C7","user_header":"https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg","comment_is_top":false,"comment_ctime":1614252863,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1614252863","product_id":100017301,"comment_content":"茶艺师学编程<br><br>思考题<br>就先两两排序合并成5个“日志”——》3个“日志”——》2个“日志”——》1个“日志”……<br><br>如果说得不对请大神指正","like_count":0},{"had_liked":false,"id":279866,"user_name":"lovelytong","can_delete":false,"product_type":"c1","uid":1464664,"ip_address":"","ucode":"BC4B7F393E1FC4","user_header":"https://static001.geekbang.org/account/avatar/00/16/59/58/6ed1d751.jpg","comment_is_top":false,"comment_ctime":1613987180,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613987180","product_id":100017301,"comment_content":"使用哨兵合并两个顺序的数组，我是这样实现的<br>function merge(arr1, arr2) {<br>       const mergeArr = []<br>       const arr1Length = arr1.length<br>       const arr2Length = arr2.length<br>       arr1.push(arr2[arr2Length - 1] + 1)<br>       arr2.push(arr1[arr1Length - 1] + 1)<br>       let i = j = 0<br>       while (i &lt; arr1Length || j &lt; arr2Length) {<br>            if (arr1[i] &gt; arr2[j]) {<br>                mergeArr.push(arr2[j])<br>                j++<br>            } else {<br>                mergeArr.push(arr1[i])<br>                i++<br>            }   <br>       }<br>       return mergeArr<br>   }<br>1，在合并的两个数组末尾添加对方数组最后的那个元素加一<br>2.  合并的时候，不需要考虑越界，因为合并的两个数组分别有一个大于对方最大值的哨兵在末尾","like_count":0},{"had_liked":false,"id":279570,"user_name":"徐改","can_delete":false,"product_type":"c1","uid":1298380,"ip_address":"","ucode":"82276A584AC602","user_header":"https://static001.geekbang.org/account/avatar/00/13/cf/cc/8de5007b.jpg","comment_is_top":false,"comment_ctime":1613826964,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613826964","product_id":100017301,"comment_content":"根据题目给出的条件：<br>1、10个接口，读取10个每份大小为300MB的日志文件<br>2、每份日志文件的日志，都是按照时间先后顺序记录的<br>3、现在有1G的内存空间可供使用<br>要求：将这10个日志文件合并成一份日志文件，并且这份合并之后的日志文件的日志也是根据时间先后顺序记录的<br>解决思路：<br>因为合并之后的日志文件是要按照时间先后顺序记录，因此也就是说，每行日志记录的时间，是从小到大排列的，因此我们可以基于此构建小顶堆：维护一个可以存储10条日志记录的堆结构，然后每次从这10份日志文件里面从头到尾分别读取1条日志记录，读进堆结构里面，然后构造出小顶堆。构造出来的小顶堆，放在堆顶的就是当前10条日志记录里面时间最小的那条记录，然后将这条记录弹出堆结构，放在一个新的堆结构里面，然后在这份弹出的日志记录所对应的日志文件上再取出其第二条日志记录，压入堆中，重新构建小顶堆，然后同样的，取出堆顶记录，压入新的堆结构里面......以此类推，可以实现将这10份日志文件合并为一份时间是按照先后顺序排列的日志记录文件。不过这里考虑到题目有给了我们1G的内存空间，因此为了提高效率，避免过多的用户态与内核态之间的转换，我们可以选择一次性批量读取这10份日志文件，然后将这批量读取的日志内容缓存在内存当中，这样就不需要频繁地进行IO操作。当然，除了一次性批量读取日志文件之外，我们在生成的新的日志文件记录的时候，也可以一次性批量写出到磁盘上，而不是找到一条新的最小的日志记录就立马写出到磁盘。<br>综上所述，解决这道题的关键点是：构造小顶堆、磁盘IO选择批量操作以此来使内存得到最大空间利用化。所以，这道题如果要继续优化的话，就是存在两个优化的方向了，一个是构造小顶堆的算法的优化，一个就是磁盘IO优化。","like_count":0},{"had_liked":false,"id":279343,"user_name":"会飞的猪儿","can_delete":false,"product_type":"c1","uid":1271898,"ip_address":"","ucode":"756FA9D278F62E","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/5a/6fb40ee2.jpg","comment_is_top":false,"comment_ctime":1613725568,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613725568","product_id":100017301,"comment_content":"java的代码实现：<br>public static int[] quick_sort(int[] target,int n) {<br>        quick_sort_calc(target,0,n - 1);<br>        return target;<br>    }<br><br>    public static void quick_sort_calc(int[] target,int begin,int end) {<br>        if (begin &gt;= end)  {<br>            return ;<br>        }<br><br>        int q = partition(target, begin, end); &#47;&#47; 获取分区点<br>        quick_sort_calc(target, begin, q-1) ;<br>        quick_sort_calc(target, q+1, end);<br>    }<br><br>    public static int partition (int[] target,int begin,int end) {<br>        int pivot = target[end];<br>        int i = begin;<br>        for (int step = begin; step &lt; end; step ++) {<br>            if (target[step] &lt; pivot) {<br>                int temp = target[step];<br>                target[step] = target[i];<br>                target[i] = temp;<br>                i++;<br>            }<br>        }<br>        int temp = target[end];<br>        target[end] = target[i];<br>        target[i] = temp;<br>        return i;<br>    }","like_count":0},{"had_liked":false,"id":279148,"user_name":"Geek_d1816e","can_delete":false,"product_type":"c1","uid":1632479,"ip_address":"","ucode":"550D1EB07A10B2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/feybtPyq5zf1UQUN81cxzIdBpGoHqGfyvTLC1MXYMYWwLSt6OGQJxF6GP4Liao9PiaX4Ifh1pVuXzovMA6IxDcXQ/132","comment_is_top":false,"comment_ctime":1613636801,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613636801","product_id":100017301,"comment_content":"#include &lt;iostream&gt;<br><br><br>using namespace std;<br><br>class QuickSort{<br>\t<br>public:\t<br>\tvoid quickSort(int arr[],int left,int right){<br>        int middle;<br>        if(left &lt; right){<br>            middle = partition(arr,left,right);<br>            quickSort(arr,left,middle-1);<br>            quickSort(arr,middle+1,right);<br>        }<br>    }<br><br>\tint partition(int arr[], int left, int right){<br>\t\tint pivot = arr[left];<br>        while(left &lt; right){<br>            while(left&lt;right &amp;&amp; arr[right] &gt;= pivot)<br>                right--;<br>            arr[left] = arr[right];<br>            while(left &lt; right &amp;&amp; arr[left]&lt;= pivot)<br>                left++;<br>            arr[right] = arr[left];<br>        }<br>        arr[left] = pivot;<br>\t\treturn left;<br>\t}<br>\t<br><br>private:<br>\t<br><br>};<br><br>int main() {<br>\tcout &lt;&lt; &quot;set QS input a[15]={&quot; &lt;&lt; endl;<br>\tint a[15]={3,44,38,5,47,15,36,26,27,2,46,4,19,50,48};<br>\tfor(int i =0;i &lt;15;i++)<br>\t{<br>\t\tcout &lt;&lt; a[i] &lt;&lt; endl;<br>\t}<br>\tQuickSort qs;<br>\tqs.quickSort(a,0,14);<br>\tcout &lt;&lt; &quot;after QS output a[15]={&quot; &lt;&lt; endl;<br>\tfor(int i =0;i &lt;15;i++)<br>\t{<br>\t\tcout &lt;&lt; a[i] &lt;&lt; endl;<br>\t}<br>\treturn 0;<br>}<br>","like_count":0},{"had_liked":false,"id":276667,"user_name":"余熙","can_delete":false,"product_type":"c1","uid":1240802,"ip_address":"","ucode":"7F98DCFB899CB7","user_header":"https://static001.geekbang.org/account/avatar/00/12/ee/e2/23e44221.jpg","comment_is_top":false,"comment_ctime":1612072856,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612072856","product_id":100017301,"comment_content":"说说我认为的课后思考，跟归并排序的关系<br>这10个日志文件，可以看成归并排序向上的过程中，10组已排序，合10为1，正如归并排序的每一个子函数，T(n) = O(n)；<br>从 10个日志里挑选最大值，选用归并排序 T(n) = 10log10; S(n) = O(10) = O(1) ，这里的 T(n) 和 O(n) 是常数级的","like_count":0},{"had_liked":false,"id":276571,"user_name":"lan-mao","can_delete":false,"product_type":"c1","uid":1886656,"ip_address":"","ucode":"F68535DEE13F43","user_header":"https://static001.geekbang.org/account/avatar/00/1c/c9/c0/d8805643.jpg","comment_is_top":false,"comment_ctime":1612008915,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612008915","product_id":100017301,"comment_content":"“你可能会说，我有个很笨的办法，每次取数组中的最小值，将其移动到数组的最前面，然后在剩下的数组中继续找最小值，以此类推，执行 K 次，找到的数据不就是第 K 大元素了吗？”<br>这段话里面应该是最大值吧","like_count":0},{"had_liked":false,"id":276526,"user_name":"阿强","can_delete":false,"product_type":"c1","uid":1722358,"ip_address":"","ucode":"7BD72BB94D8F56","user_header":"https://static001.geekbang.org/account/avatar/00/1a/47/f6/8de3ce34.jpg","comment_is_top":false,"comment_ctime":1611988277,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611988277","product_id":100017301,"comment_content":"一直搞不懂 为什么 是 O(n) , 相对于快排，一次处理之后 还需要处理 n-1和 数量，但是 求第k个数 只需要n&#47;2。所以就是要比 快排 快  log2n 倍。","like_count":0},{"had_liked":false,"id":273524,"user_name":"柯尊铖","can_delete":false,"product_type":"c1","uid":1851031,"ip_address":"","ucode":"8C3E35A76EED61","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ5GIMGQPRu31calIBicDXTNJQFCgTwgaiaQJniaw8jYrPxwpxNd0nAiapYgD6OK1LrSLuSerOuURG1sQ/132","comment_is_top":false,"comment_ctime":1610623410,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610623410","product_id":100017301,"comment_content":"第N大的数我也用 js 写了一个实现，这里为了方便，quick_s 是从大到小的快排<br><br>const { quick } = require(&#39;..&#47;quick&#39;)<br><br>function nthMax(arr, n) {<br>  return _nthMax(arr, n, 0, arr.length - 1)<br>}<br><br>function _nthMax(arr, n, r, q) {<br>  let p = quick_s(arr, r, q)<br>  while (p + 1 !== n) {<br>    if (p + 1 &gt; n) {<br>      p = quick_s(arr, r, p - 1)<br>    } else {<br>      p = quick_s(arr, p + 1, q)<br>    }<br>  }<br>  return arr[p]<br>}<br><br>function quick_s(arr, r, q) {<br>  if ( r === q) return r<br>  let i = r<br>  const v = arr[q]<br>  for (let j = r; j &lt; q; j++) {<br>    if (arr[j] &gt; v) {<br>      swap(arr, i, j)<br>      i++<br>    }<br>  }<br>  swap(arr, i, q)<br>  return i<br>}<br><br>function swap(arr, i, j) {<br>  [arr[i], arr[j]] = [arr[j], arr[i]]<br>}<br><br><br>const k = 33<br>const N = 100000<br><br>function check(arr, n) {<br>  const copy = [...arr]<br>  const sorted = quick(copy)<br>  const expected = sorted.reverse()[n - 1]<br>  console.time(`${k} in ${N}`)<br>  const result = nthMax(arr, n)<br>  console.timeEnd(`${k} in ${N}`)<br>  console.log(expected === result ? &#39;success&#39; : &#39;fail&#39;)<br>}<br><br>function generateArr(num) {<br>  return new Array(num).fill(0).map(() =&gt; Math.random())<br>}<br><br>check(generateArr(N), 33)","like_count":0},{"had_liked":false,"id":273429,"user_name":"柯尊铖","can_delete":false,"product_type":"c1","uid":1851031,"ip_address":"","ucode":"8C3E35A76EED61","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ5GIMGQPRu31calIBicDXTNJQFCgTwgaiaQJniaw8jYrPxwpxNd0nAiapYgD6OK1LrSLuSerOuURG1sQ/132","comment_is_top":false,"comment_ctime":1610594403,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610594403","product_id":100017301,"comment_content":"自己简单用 js 写了一下归并排序和快排，生成完全随机的数组对比了一下。<br>数组长度为 1000000 时，<br>merge: 117574.516ms<br>quick: 175.692ms<br>长度再加一个 0 我就没跑归并了，此时<br>quick: 1924.010ms，<br>再往后加 0，JavaScript heap out of memory<br>归并实现：<br>function merge(arr) {<br>  if (arr.length &lt;= 1) {<br>    return arr<br>  }<br>  const middle = Math.ceil(arr.length &#47; 2)<br>  const p = merge(arr.slice(0, middle))<br>  const n = merge(arr.slice(middle))<br>  return compose(p, n)<br>}<br><br>function compose(arr1, arr2) {<br>  let ret = []<br>  while (arr1.length &amp;&amp; arr2.length) {<br>    arr1[0] &gt; arr2[0] ? ret.push(arr2.shift()) : ret.push(arr1.shift())<br>  }<br>  ret.push.apply(ret, arr1.length ? arr1 : arr2)<br>  return ret<br>}<br>快排实现：<br>function quick(arr) {<br>  quick_sort(arr, 0, arr.length - 1)<br>  return arr<br>}<br><br>function quick_sort(arr, r, q) {<br>  if (r &gt;= q) return<br>  const v = arr[q]<br>  let i = r<br>  let j<br>  for (j = r; j &lt; q; j++) {<br>    if (arr[j] &lt; v) {<br>      swap(arr, i, j)<br>      i++<br>    }<br>  }<br>  swap(arr, i, q)<br>  quick_sort(arr, r, i - 1)<br>  quick_sort(arr, i + 1, q)<br>}<br><br>function swap(arr, i, j) {<br>  if (i === j) return<br>  [arr[i], arr[j]] = [arr[j], arr[i]]<br>}","like_count":0},{"had_liked":false,"id":270218,"user_name":"dst","can_delete":false,"product_type":"c1","uid":1861196,"ip_address":"","ucode":"9177BBB6C8B905","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKx6EdicYYuYK745brMa9yAlkZs2YmzxRAm4BQ2kw9GbtcC8ebnQlyBfIJnGjH57ib4HVlQIpSbTrBw/132","comment_is_top":false,"comment_ctime":1608992345,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1608992345","product_id":100017301,"comment_content":"1.先循环遍历这10个文件,找出最小和最大的时间戳.时间0(20)<br>2.按最小和最大的时间戳,分割为10个等分,每次按一个等分,去每个文件中读取比这个等分大的数据,然后放在一起进行排序,然后输出到文件中.<br>3.按上次读取文件的时机作为最小值,下个等分的时间作为最大值,接着去每个文件中读取这个时间范围内的数据.重复这些操作,直到数据都读取和写出完成<br>4.假如中间某个等份的数据太大,则按比例再次分割这个时间范围.","like_count":0},{"had_liked":false,"id":269844,"user_name":"刘帅","can_delete":false,"product_type":"c1","uid":1117630,"ip_address":"","ucode":"90FD56C0395B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/0d/be/6acd4b18.jpg","comment_is_top":false,"comment_ctime":1608807551,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1608807551","product_id":100017301,"comment_content":"先依次读取十个文件的首行，根据第一行的时间戳对十个文件进行从小到大排序，然后依次读取，写入到同一个文件，从第一个文件读取时，要比对第二个文件首行的大小，如果一样，则开启第二个io流进行第二个文件的读写，并对比第三个io的大小，当第三个文件流开启后对比第四个文件首行相等时，第三个文件流暂停读写，等到前两个文件读写完时，在重新开始第三个读写，如果前两个文件也读取时也遇到了与四文件首行相等的情况，则需要查看内存情况，是否具备读取第四个文件空间，如果不仅具备，则需要开启io流后逐行读取，后面的文件依次类推","like_count":0},{"had_liked":false,"id":269176,"user_name":"志遥","can_delete":false,"product_type":"c1","uid":1001537,"ip_address":"","ucode":"91CFC6CE092FE3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/41/fa016902.jpg","comment_is_top":false,"comment_ctime":1608547838,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608547838","product_id":100017301,"comment_content":"JavaScript 版本：<br><br>var sortArray = function(nums, low = 0, height = nums.length - 1) {<br>  if(low &gt;= height) return nums;  &#47;&#47; 判断是否只剩下一个元素，若是则直接返回<br><br>  const p = partition(nums, low, height);  &#47;&#47; 利用 partition 函数找到一个随机的基准点<br><br>  &#47;&#47; 递归地对基准点左半边和右半边的数进行排序<br>  sortArray(nums, low, p-1);<br>  sortArray(nums,  p + 1, height);<br><br>  return nums;<br>}<br><br>function partition(nums, low, hight) {<br>  const pivot = nums[hight];<br>  let i = low;<br><br>  for (let j = low; j &lt;  hight; j++) {<br>      if (nums[j] &lt; pivot) {<br>          swap(nums, i, j);<br>          i = i + 1;<br>      }<br>  }<br>  swap(nums, i, hight);<br><br>  return i;<br>}<br><br>function swap(nums, i, j) {<br>  const temp = nums[j];<br>  nums[j] = nums[i];<br>  nums[i] = temp;<br>}","like_count":0},{"had_liked":false,"id":268525,"user_name":"慕高迪","can_delete":false,"product_type":"c1","uid":1448126,"ip_address":"","ucode":"EB1CB5EA4E3A90","user_header":"https://static001.geekbang.org/account/avatar/00/16/18/be/ad3127e0.jpg","comment_is_top":false,"comment_ctime":1608248493,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608248493","product_id":100017301,"comment_content":"总结：<br><br>归并排序和快速排序都是采用分治的思想，并且使用递归实现的。<br><br>1. 归并排序<br><br>算法原理：针对于输入的序列，采用分治的思想，将序列平均分成两部分，然后分别对他们进行排序，排序完成后，再对两部分有序的结果进行合并。在排序的过程中，每一个部分重复采用上述的过程。它是一种由下至上的排序算法<br><br>分析：<br><br>执行效率：T(N) = T(N&#47;2) + T(N&#47;2) + N（合并） ,求解时间复杂度为O(NlogN)<br><br>内存消耗：由于涉及到结果的合并，不断地开辟和释放内存空间，但最大需要开辟的内存空间为序列的长度，所以空间复杂度为O(N)。不是原地排序<br><br>稳定性：是稳定的排序算法，排序后不会改变相同元素出现的先后位置<br><br>2. 快速排序<br><br>算法原理：针对输入的序列，依然采用分治的思想，只不过不需要将序列平均分成两份，而是采用分区的方式，而是选取一个piovt ，然后将比他小的放在其左侧，比他大的放在其右侧。然后针对左侧和右侧再分别重复上述过程。是一种自上而下的排序算法<br><br>分析：<br><br>执行效率：<br><br>最好情况下，每次选取的pivot都可以将序列平均分成两份，这就和归并排序的复杂度是相同的，为 T(N) = T(N&#47;2) + T(N&#47;2) + N（分区） , 求解时间复杂度为O(NlogN)<br><br>最坏情况下，针对有序的序列，每次选择的pivot都是序列的最后一个元素，这样就会导致需要进行N次分区，而每次分区都会进行平均约N&#47;2次（N-1 + N-2 + N-3 +....+ 1 &#47; N= (N-1&#47; 2)）的数据比较，所以时间复杂度为O(N^2)<br><br>平均情况下，如果我们每次分区都采用9：1的比例进行分区，那么可以表示为：T(N) = T(N&#47;10) + T(9N&#47;10) + N（分区），时间复杂度也是 O(NlogN)<br><br>虽然最坏情况下的时间复杂度为O(N^2)，我们一般会采取策略来规避这种情况，可以让它达到大部分情况下都是O(NlogN)的<br><br>内存消耗：空间复杂度为O(1)，是原地排序，不需要额外的内存空间<br><br>稳定性：是一个不稳定的算法，会改变相同元素出现的先后顺序<br><br>3. 为什么快速排序比归并排序更加常用？<br><br>归并排序最大的问题就是空间复杂度太高了","like_count":0},{"had_liked":false,"id":268138,"user_name":"yong++","can_delete":false,"product_type":"c1","uid":1198316,"ip_address":"","ucode":"43AC806E971FC2","user_header":"https://static001.geekbang.org/account/avatar/00/12/48/ec/356dfdf3.jpg","comment_is_top":false,"comment_ctime":1608083236,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608083236","product_id":100017301,"comment_content":"归并动手，Golang:<br>package main<br><br>import (<br>\t&quot;fmt&quot;<br>\t&quot;math&#47;rand&quot;<br>\t&quot;time&quot;<br>)<br><br><br>func merge_sort(arr []int,p int, r int) {<br><br>\tif p&gt;=r{<br>\t\treturn<br>\t}<br>\tq := (p+r)&#47;2<br><br><br>\tmerge_sort(arr,p,q)<br>\tmerge_sort(arr,q+1,r)<br><br>\tmerge(arr,p,q,r)<br><br>}<br><br>func merge(arr []int,p,q,r int) {<br><br><br>\tvar i,j,k = p, q+1, 0<br>\ttmp := make([]int,r-p+1)<br><br>\tfor i&lt;=q &amp;&amp; j&lt;=r {<br>\t\tif arr[i] &lt;= arr[j] {<br>\t\t\ttmp[k] = arr[i]<br>\t\t\tk++<br>\t\t\ti++<br>\t\t}else{<br>\t\t\ttmp[k] = arr[j]<br>\t\t\tk++<br>\t\t\tj++<br>\t\t}<br>\t}<br>\tvar start,end = i,q<br><br>\tif j&lt;=r {<br>\t\tstart = j<br>\t\tend = r<br>\t}<br><br>\tfor start&lt;=end {<br>\t\ttmp[k] = arr[start]<br>\t\tk++<br>\t\tstart++<br>\t}<br><br><br>\tfor i := 0; i&lt;=(r-p);i++{<br>\t\tarr[p+i] = tmp[i]<br>\t}<br><br>}<br><br>func main() {<br><br>\tarr := []int{3, 5, 1, 7,9,3}<br><br>\tfor i := 0; i &lt; 5000000; i++ {<br>\t\tarr = append(arr, rand.Intn(600000))<br>\t}<br><br>\tst := time.Now()<br><br>\tmerge_sort(arr,0,len(arr)-1)<br><br><br>\tfmt.Println(time.Now().Sub(st).String())<br>}<br>","like_count":0},{"had_liked":false,"id":267013,"user_name":"@许还真","can_delete":false,"product_type":"c1","uid":1099324,"ip_address":"","ucode":"6D754D5AE44CEC","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/3c/8ab9deb0.jpg","comment_is_top":false,"comment_ctime":1607569193,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607569193","product_id":100017301,"comment_content":"最后一道题，我觉得应该是归并排序的治部分（因为已经分了多个有序数组），然后治部分可以将合并部分写入磁盘，这样有效腾出内存空间；然后再去取未比较部分；","like_count":0},{"had_liked":false,"id":265423,"user_name":"不知jdk","can_delete":false,"product_type":"c1","uid":2328620,"ip_address":"","ucode":"F167FA99431C8E","user_header":"","comment_is_top":false,"comment_ctime":1606894384,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606894384","product_id":100017301,"comment_content":"归并排序的 伪代码 k=0 是错误的，应该改成k=left","like_count":0},{"had_liked":false,"id":265163,"user_name":"IV1NINE","can_delete":false,"product_type":"c1","uid":1562168,"ip_address":"","ucode":"C978FBCA2D32A6","user_header":"https://static001.geekbang.org/account/avatar/00/17/d6/38/711c313c.jpg","comment_is_top":false,"comment_ctime":1606800604,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1606800604","product_id":100017301,"comment_content":"    &#47;**<br>     * 归并排序 merge sort 稳定 但是非原地排序 需要新开临时数组存储数据<br>     * @param arr<br>     *&#47;<br>    private void divideConquerSort(int[] arr) {<br>        int[] tmp = new int[arr.length];<br>        merge_sort_java(arr, 0, arr.length - 1, tmp);<br>    }<br><br>    private void merge_sort_java(int[] arr, int p, int r, int[] tmp) {<br>        &#47;&#47; 递归终止条件 if p &gt;= r then return<br>        if (p &gt;= r) return;<br>        &#47;&#47; 取p到r之间的中间位置q q = (p+r) &#47; 2<br>        int q = (p + r) &#47; 2;<br>        &#47;&#47; 分治递归 merge_sort_c(A, p, q) merge_sort_c(A, q+1, r)<br>        merge_sort_java(arr, p, q, tmp);<br>        merge_sort_java(arr, q + 1, r, tmp);<br>        &#47;&#47; 将A[p...q]和A[q+1...r]合并为A[p...r] merge(A[p...r], A[p...q], A[q+1...r])<br>        merge_arr(arr, p, q, r, tmp);<br>    }<br><br>    &#47;**<br>     * 合并数组<br>     * @param arr 初始数组<br>     * @param p 当前数组的下标<br>     * @param q<br>     * @param r<br>     * @param tmp<br>     *&#47;<br>    private void merge_arr(int[] arr, int p, int q, int r, int[] tmp) {<br>        int i = 0;<br>        int j = p;<br>        int k = q + 1;<br>        while (j &lt;= q &amp;&amp; k &lt;= r) {<br>            if (arr[j] &lt; arr [k]) {<br>                tmp[i++] = arr[j++];<br>            } else {<br>                tmp[i++] = arr[k++];<br>            }<br>        }<br>        while (j &lt;= q) {<br>            tmp[i++] = arr[j++];<br>        }<br>        while (k &lt;= r) {<br>            tmp[i++] = arr[k++];<br>        }<br>        &#47;&#47;  从q位置复制到r位置<br>        if (i &gt;= 0)<br>            System.arraycopy(tmp, 0, arr, p, i);<br>    }","like_count":0},{"had_liked":false,"id":263936,"user_name":"郑印","can_delete":false,"product_type":"c1","uid":1005282,"ip_address":"","ucode":"181B0FDE5E1532","user_header":"https://static001.geekbang.org/account/avatar/00/0f/56/e2/2dcab30d.jpg","comment_is_top":false,"comment_ctime":1606298827,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606298827","product_id":100017301,"comment_content":"<br><br><br>先构建十条io流，分别指向十个文件，每条io流读取对应文件的第一条数据，然后比较时间戳，选择出时间戳最小的那条数据，将其写入一个新的文件，然后指向该时间戳的io流读取下一行数据，然后继续刚才的操作，比较选出最小的时间戳数据，写入新文件，io流读取下一行数据，以此类推，完成文件的合并， 这种处理方式，日志文件有n个数据就要比较n次，每次比较选出一条数据来写入，时间复杂度是O（n），空间复杂度是O（1）,几乎不占用内存，这是我想出的认为最好的操作了，希望老师指出最佳的做法！！！<br><br>`````````````<br><br>按照 李建辉 同学的描述，这样实现，但是时间复杂度不是 0(n) 是O(m*n) m 是文件的个数<br><br>https:&#47;&#47;github.com&#47;zhengyin&#47;special-topic&#47;blob&#47;master&#47;data-structure&#47;src&#47;main&#47;java&#47;com&#47;izhengyin&#47;special&#47;ds&#47;question&#47;SortMerge.java<br><br>这个实现方式可以优化吗？","like_count":0},{"had_liked":false,"id":260722,"user_name":"明天的色彩","can_delete":false,"product_type":"c1","uid":1046814,"ip_address":"","ucode":"07D4A2EE5C7E3B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/1e/953b139e.jpg","comment_is_top":false,"comment_ctime":1605088855,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1605088855","product_id":100017301,"comment_content":"在内存构建10个文件内容缓存区，每个缓存区从日志文件中由小到大读满缓冲，平均每个文件的缓冲区大小为50M，总大小为500M，比较10个缓冲区最后的一个日志时间戳，将最小时间戳以前的全部内容拷贝到另外500M缓冲区进行快排，然后将排序后的日志写进新文件，接着重新读取原始文件补充满缓冲区，循环处理","like_count":0},{"had_liked":false,"id":259935,"user_name":"Nullptr","can_delete":false,"product_type":"c1","uid":1911665,"ip_address":"","ucode":"8EC72438680F8D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLpCwvSDHKuwJklN3gosIbJh0AX97ULSXw4cgopjU28eQHR7DxcCWDFSBv7ZQJElBuCFu58xoWaTg/132","comment_is_top":false,"comment_ctime":1604890616,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604890616","product_id":100017301,"comment_content":"每次读取一个保存在一个属于里面然后排序，取得最小的。然后继续从那个最小的文件里面继续读取一个继续排序！","like_count":0},{"had_liked":false,"id":258741,"user_name":"🌲","can_delete":false,"product_type":"c1","uid":2244944,"ip_address":"","ucode":"526BEA7170EA60","user_header":"https://static001.geekbang.org/account/avatar/00/22/41/50/a8ee5d79.jpg","comment_is_top":false,"comment_ctime":1604547595,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604547595","product_id":100017301,"comment_content":"归并排序是可以直接进行原地排序的，关键在于合并函数的实现，如果合并函数实现的合并操作是在原地进行的，那么归并排序的空间复杂度也就变成了O(1)， 但是实现原地的合并算法得不断的移动元素的位置，也就是插入排序，时间复杂度也就变成了O(n^2)，是一种时间换空间的处理方式。","like_count":0},{"had_liked":false,"id":258576,"user_name":"hao","can_delete":false,"product_type":"c1","uid":1148845,"ip_address":"","ucode":"997F2B57E2F556","user_header":"https://static001.geekbang.org/account/avatar/00/11/87/ad/50a85a04.jpg","comment_is_top":false,"comment_ctime":1604489181,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604489181","product_id":100017301,"comment_content":"partition秒啊","like_count":0},{"had_liked":false,"id":257379,"user_name":"授人以🐟，不如授人以渔","can_delete":false,"product_type":"c1","uid":1193874,"ip_address":"","ucode":"BD53829E924B66","user_header":"https://static001.geekbang.org/account/avatar/00/12/37/92/961ba560.jpg","comment_is_top":false,"comment_ctime":1603951793,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1603951793","product_id":100017301,"comment_content":"问题请求！<br>文末提到的“求无序数组中的第 K 大元素”，笨办法：每次取数组中的最小值，将其移动到数组的最前面，然后在剩下的数组中继续找最小值，依次类推，执行K次，找到的数据就是第K大元素。<br>这个解决办法是不可行的，比如数组：【183, 181, 111, 75, 190, 37, 78, 39, 147, 167】，求第4大元素。按照上述步骤，执行 4 次后，数组为【37, 39, 75, 78, 183, 181, 111, 190, 147, 167】，找到的值为 78，显然不是第4大元素。","like_count":0},{"had_liked":false,"id":256937,"user_name":"瑞哥","can_delete":false,"product_type":"c1","uid":1849703,"ip_address":"","ucode":"3AE6DCDAE5844F","user_header":"https://static001.geekbang.org/account/avatar/00/1c/39/67/2477b20e.jpg","comment_is_top":false,"comment_ctime":1603789248,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603789248","product_id":100017301,"comment_content":"利用归并排序算法中的合并已排好序的子集算法思路","like_count":0},{"had_liked":false,"id":255345,"user_name":"Emma-乌鸦","can_delete":false,"product_type":"c1","uid":1164678,"ip_address":"","ucode":"BF41D2E6424ABD","user_header":"https://static001.geekbang.org/account/avatar/00/11/c5/86/f64f2642.jpg","comment_is_top":false,"comment_ctime":1603327234,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603327234","product_id":100017301,"comment_content":"个人觉得还是伪代码好，本来老师也是展示思路的么","like_count":0},{"had_liked":false,"id":255307,"user_name":"赵学习","can_delete":false,"product_type":"c1","uid":1829065,"ip_address":"","ucode":"2B660A158C4C3E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/x3cpRvAjkpyCiaibTJlvhlaE6g5XUgDYH24ZISWzZUO5mDkfW0fPJJDWnwa8V6c3FYxnVasFMTGc4xqaoWkuXXsA/132","comment_is_top":false,"comment_ctime":1603298368,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603298368","product_id":100017301,"comment_content":"课后思考:<br>首先这个问题可以很快想到归并排序。但是归并排序占用空间需要*2，机器内存为1G，所以肯定不能吧日志文件都搞到内存里面去做归并排序。且归并排序可以不止是2路归并，可以是n路归并。所以每个文件可以开启一个流去读每一条数据，使用流读出来的数据做10路的归并，然后按顺序写到新文件即可。","like_count":0},{"had_liked":false,"id":254541,"user_name":"jack","can_delete":false,"product_type":"c1","uid":1352726,"ip_address":"","ucode":"5260F7D2219542","user_header":"https://static001.geekbang.org/account/avatar/00/14/a4/16/6463e374.jpg","comment_is_top":false,"comment_ctime":1603126138,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603126138","product_id":100017301,"comment_content":"有点类似n个单链表合并成一个有序数组的leetcode原题。解法：用10个队列（文件）构成小顶堆。","like_count":0},{"had_liked":false,"id":254288,"user_name":"大力水手Jerry","can_delete":false,"product_type":"c1","uid":1227840,"ip_address":"","ucode":"E4A6C71E275DB5","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg","comment_is_top":false,"comment_ctime":1603096291,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603096291","product_id":100017301,"comment_content":"求第K大数，Go迭代实现：<br>func Kth(s []int, k int) int {<br>\ta, b := 0, len(s)-1 &#47;&#47; a指向数组头，b指向数组尾<br>\tfor a &lt;= b {<br>\t\tr := partition(s, a, b)<br>\t\tif r == len(s)-k {<br>\t\t\treturn s[r]<br>\t\t}<br>\t\tif r &lt; len(s)-k {<br>\t\t\ta = r + 1<br>\t\t} else {<br>\t\t\tb = r - 1<br>\t\t}<br>\t}<br>\treturn -1<br>}","like_count":0},{"had_liked":false,"id":254126,"user_name":"大力水手Jerry","can_delete":false,"product_type":"c1","uid":1227840,"ip_address":"","ucode":"E4A6C71E275DB5","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg","comment_is_top":false,"comment_ctime":1603069792,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603069792","product_id":100017301,"comment_content":"第K大问题的实现，有一点不知大家注意到没，就是利用递归算法时，如果是在递归的中间得到结果，只能在当时将结果持久化保存，因为这个结果只存在于系统栈中，会在返回后被清理，因此无法递交给最初的调用者。持久化保存的方法很多，典型的比如输出到日志，记录到数据库，或者发送给远程服务端。如果解的结构比较简单的话，还可以直接存放到全局变量中。<br>","like_count":0},{"had_liked":false,"id":252951,"user_name":"灯盖","can_delete":false,"product_type":"c1","uid":1482839,"ip_address":"","ucode":"0F8455A593D60C","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/57/3a729755.jpg","comment_is_top":false,"comment_ctime":1602546462,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1602546462","product_id":100017301,"comment_content":"这两节有两个遗留问题，一个是希尔排序，一个是归并排序中的哨兵的使用。当然，最后的思考题也可以实现一把。","like_count":0},{"had_liked":false,"id":252559,"user_name":"Fy","can_delete":false,"product_type":"c1","uid":2213304,"ip_address":"","ucode":"4F4C0617A79083","user_header":"https://static001.geekbang.org/account/avatar/00/21/c5/b8/481d8a64.jpg","comment_is_top":false,"comment_ctime":1602382116,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602382116","product_id":100017301,"comment_content":"用priceton的算法也可以<br>     private int partition(int[] nums, int left, int right ) {<br>         int pivot = left;<br>         int l = left + 1;<br>         int r = right;<br><br>         while( true ) {<br>             while( l &lt; right &amp;&amp; nums[l] &gt;= nums[pivot] )   { l++; }<br>             while( r &gt; left &amp;&amp; nums[r] &lt;= nums[pivot] )  { r--; }<br>             if(l &gt;= r )  { break; }<br>             swap(nums, l, r );<br>         }<br>         swap(nums, pivot, r );<br>         return r;<br>     }","like_count":0},{"had_liked":false,"id":251190,"user_name":"ifeien","can_delete":false,"product_type":"c1","uid":1103929,"ip_address":"","ucode":"4C14ABC4625E92","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/39/f9b54e3d.jpg","comment_is_top":false,"comment_ctime":1601394713,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601394713","product_id":100017301,"comment_content":"第K大元素问题，O(n)是最优情况下的时间复杂度，最坏情况下(有序)，n+(n-1)+(n-2)+...+1=n^2&#47;2","like_count":0},{"had_liked":false,"id":251093,"user_name":"InfoQ_c1201d12b35e","can_delete":false,"product_type":"c1","uid":2194382,"ip_address":"","ucode":"1AE58E7434685C","user_header":"http://thirdwx.qlogo.cn/mmopen/KFgDEHIEpnT0EXnh02VHqCA71nSXicxmYdqJfMvWjicenobQKWqrWS8RsibicXHzSic69ibmtrJ0sjKw5UCs3unGQPiaepnBd9ytg7J/132","comment_is_top":false,"comment_ctime":1601363062,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601363062","product_id":100017301,"comment_content":"归并排序<br>public class MergeSortTest {<br><br>    public static void main(String[] args) throws Exception {<br>        int[] arr = new int[]{4, 5, 6, 1, 3, 2, 14, 15, 16, 11, 13, 12};<br>        MergeSortTest sortTest = new MergeSortTest();<br>        int[] result = sortTest.sort(arr);<br>        for (int i : result) {<br>            System.out.println(i);<br>        }<br>    }<br><br>    public int[] sort(int[] sourceArray) throws Exception {<br>        &#47;&#47; 对 arr 进行拷贝，不改变参数内容<br>        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);<br><br>        if (arr.length &lt; 2) {<br>            return arr;<br>        }<br>        int middle = (int) Math.floor(arr.length &#47; 2);<br><br>        &#47;&#47; 拆分<br>        int[] left = Arrays.copyOfRange(arr, 0, middle);<br>        int[] right = Arrays.copyOfRange(arr, middle, arr.length);<br><br>        return merge(sort(left), sort(right));<br>    }<br><br>    &#47;**<br>     * 合并<br>     *<br>     * @param left<br>     * @param right<br>     * @return<br>     *&#47;<br>    protected int[] merge(int[] left, int[] right) {<br>        int[] result = new int[left.length + right.length];<br>        int i = 0;<br>        int le = 0;<br>        int ri = 0;<br>        while (le &lt; left.length &amp;&amp; ri &lt; right.length) {<br>            if (left[le] &lt;= right[ri]) {<br>                result[i++] = left[le++];<br>            } else {<br>                result[i++] = right[ri++];<br>            }<br>        }<br><br>        while (le &lt; left.length) {<br>            result[i++] = left[le++];<br>        }<br><br>        while (ri &lt; right.length) {<br>            result[i++] = right[ri++];<br>        }<br><br>        return result;<br>    }<br>}","like_count":0},{"had_liked":false,"id":250776,"user_name":"不甘心的翔入非非","can_delete":false,"product_type":"c1","uid":1474300,"ip_address":"","ucode":"1C39E0E5215C54","user_header":"https://static001.geekbang.org/account/avatar/00/16/7e/fc/b132947b.jpg","comment_is_top":false,"comment_ctime":1601216648,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601216648","product_id":100017301,"comment_content":"merge(A[p...r], A[p...q], A[q+1...r])没人认为应该是这个吗 merge(A[p...q], A[q+1...r])？？？","like_count":0},{"had_liked":false,"id":250463,"user_name":"①笙筱歌","can_delete":false,"product_type":"c1","uid":1054132,"ip_address":"","ucode":"7676892DE8A9A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/b4/95b616a1.jpg","comment_is_top":false,"comment_ctime":1601090747,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601090747","product_id":100017301,"comment_content":"我的思路是借助分桶思想和快速&#47;归并排序来完成日志合并：<br>1. 第一次轮询：io流依次读取10个日志文件，并获取时间戳的最大最小值，根据时间戳上下界将其均匀分为10个桶（新的日志文件，下同）；<br>2.第二次轮询：io流依次读取10个日志文件，把日志记录放到对应的桶里；<br>3.桶内排序：若每个桶内记录分布较均匀，可直接放在内存里快速排序&#47;归并排序，每个桶内记录将有序排列；若个别桶内记录集中，超过内存容纳上限，可循环步骤1-3，直到完成桶内排序；<br>4.桶合并：按桶上下界时间戳从小到大的顺序，依次轮询每个桶，并通过io流的方式，将记录依次写入到同一个日志文件中，即可完成日志文件的合并和排序。<br><br>如果有什么问题，麻烦指正，谢谢。","like_count":0},{"had_liked":false,"id":250448,"user_name":"岁月如歌","can_delete":false,"product_type":"c1","uid":1114542,"ip_address":"","ucode":"29FA49EEDBFF92","user_header":"https://static001.geekbang.org/account/avatar/00/11/01/ae/f298ef27.jpg","comment_is_top":false,"comment_ctime":1601088915,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601088915","product_id":100017301,"comment_content":"先从十个文件中各读取100M数据进入内存，然后对这些数据进行归并排序，写出到外部文件中，哪个内存块中的数据先写完了，就再次读取100M的数据 直到所有文件中的数据都写入到新的文件中了","like_count":0},{"had_liked":false,"id":249646,"user_name":"@许还真","can_delete":false,"product_type":"c1","uid":1099324,"ip_address":"","ucode":"6D754D5AE44CEC","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/3c/8ab9deb0.jpg","comment_is_top":false,"comment_ctime":1600739992,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600739992","product_id":100017301,"comment_content":"快排思路和之前看到有些不同。","like_count":0},{"had_liked":false,"id":249205,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1619237,"ip_address":"","ucode":"9DD1463CF7B98F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/dB3AyEjSZicibIvf3SstpVNeKuviaujib9QcRCP0UHuj9nF2gFcynbMYSgpWOJO0H2Z1zXyHswjKTvv3QLwicQzKLpw/132","comment_is_top":false,"comment_ctime":1600502096,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600502096","product_id":100017301,"comment_content":"1.从每个文件里取100m，原地排序，并且在排序时记录十个文件取出的末尾数据的时间戳最小值以及这个最小值在其它9段数据中的位置，将最小值之前的数据存入文件。<br>2. 将剩余内存按文件数量等分，按照最小值在其他各段数据中的位置计算要读对应文件中成比例的最多为十等分后内存大小的数据大小，计算后的剩余内存大小全读最小值来自的文件，并按要读的大小从大到小读取，重复第1步的原地排序和记录以及保存操作。<br>3. 重复第2步直到所有文件读完，过程中需要设置文件读完标志。<br><br>才疏学浅，坐地铁听课想的，还请各位前辈道友指点","like_count":0},{"had_liked":false,"id":248228,"user_name":"Aresx","can_delete":false,"product_type":"c1","uid":2159788,"ip_address":"","ucode":"AE90EC3724EF98","user_header":"https://static001.geekbang.org/account/avatar/00/20/f4/ac/3e6b4b77.jpg","comment_is_top":false,"comment_ctime":1600073215,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600073215","product_id":100017301,"comment_content":"看了下最后那个思考题，简单说一下思路不知道对不对，既然老师说按照快排的思路，那就是把10个文件对应的每个再分成10份，然后每次从10个里面取，先比较最小最大值，看哪些需要合并，然后先把最小的写入到最后的那个，如果取出来的10份的最小最大值都有交集，再分解，一次10份10份的处理直到处理完成","like_count":0},{"had_liked":false,"id":247488,"user_name":"Liion","can_delete":false,"product_type":"c1","uid":1124435,"ip_address":"","ucode":"496AED1E765E7A","user_header":"https://static001.geekbang.org/account/avatar/00/11/28/53/71a1d8c4.jpg","comment_is_top":false,"comment_ctime":1599722460,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599722460","product_id":100017301,"comment_content":"go语言实现：<br>func quickSort(arr []int, start int, end int)  {<br>\tif start &gt;= end {<br>\t\treturn<br>\t}<br>\tp := partition(arr, start, end)<br>\tquickSort(arr, start, p - 1)<br>\tquickSort(arr, p + 1, end)<br>}<br><br>func partition(arr []int, start int, end int) int {<br>\ti := start<br>\tj := end<br>\tpivot := arr[i]<br>\tfor i &lt; j {<br>\t\tfor i &lt; j &amp;&amp;  pivot &lt;= arr[j]{<br>\t\t\tj--<br>\t\t}<br>\t\tarr[i] = arr[j]<br>\t\tfor i &lt; j &amp;&amp;  pivot &gt;= arr[i] {<br>\t\t\ti++<br>\t\t}<br>\t\tarr[j] = arr[i]<br>\t}<br>\tarr[i] = pivot<br>\treturn i<br>}","like_count":0},{"had_liked":false,"id":246275,"user_name":"有没有口罩一个给我","can_delete":false,"product_type":"c1","uid":2066987,"ip_address":"","ucode":"EF9BCF9C5F5378","user_header":"https://static001.geekbang.org/account/avatar/00/1f/8a/2b/f2dca1fd.jpg","comment_is_top":false,"comment_ctime":1599239568,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599239568","product_id":100017301,"comment_content":"每个文件每次取100M，然后将内存中的数据快排然后存盘，这样IO次数和数据比较移动的次数都比每次取40M，然后归并排序存盘的少吧，时间复杂度都是O(nlogn)。","like_count":0},{"had_liked":false,"id":246048,"user_name":"席席","can_delete":false,"product_type":"c1","uid":1591399,"ip_address":"","ucode":"656377E29D4F76","user_header":"https://static001.geekbang.org/account/avatar/00/18/48/67/128eda8f.jpg","comment_is_top":false,"comment_ctime":1599143678,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1599143678","product_id":100017301,"comment_content":"归并排序为什么两次return后依然能回到第二个递归函数，因为在我的印象里return是函数的终止条件，卡住了，不明白，怎么解？","like_count":0,"discussions":[{"author":{"id":1591399,"avatar":"https://static001.geekbang.org/account/avatar/00/18/48/67/128eda8f.jpg","nickname":"席席","note":"","ucode":"656377E29D4F76","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303241,"discussion_content":"今天问了同事，因为递归每次都是进入一个新的函数，所以在递归中的return看似两个就应该结束，但实际上应该是每进入一个函数都有两个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599199428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245564,"user_name":"恶魔果实","can_delete":false,"product_type":"c1","uid":1962297,"ip_address":"","ucode":"691CD833C984AC","user_header":"https://static001.geekbang.org/account/avatar/00/1d/f1/39/b0960780.jpg","comment_is_top":false,"comment_ctime":1598978137,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598978137","product_id":100017301,"comment_content":"提问：<br>如果是10G无序数据，4G内存大小，如何找到去重后的最大100个数？","like_count":0},{"had_liked":false,"id":245251,"user_name":"我上辈子一定是老虎","can_delete":false,"product_type":"c1","uid":2090365,"ip_address":"","ucode":"13F0753E36DCA8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqCEWUcIepI3CyTf6IyNBsId5b3RftMpsWgwkKmArHZyBOrVkT3lBKJknEGcqCweXlz4LfX8ia9Yag/132","comment_is_top":false,"comment_ctime":1598876113,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598876113","product_id":100017301,"comment_content":"递归的空间复杂度还包括保存现场时栈所占用的空间吧","like_count":0},{"had_liked":false,"id":244054,"user_name":"JerryZhu","can_delete":false,"product_type":"c1","uid":1591223,"ip_address":"","ucode":"76850CD45786C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","comment_is_top":false,"comment_ctime":1598367989,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598367989","product_id":100017301,"comment_content":"老师你好， <br><br>&#47;&#47; 归并排序算法, A是数组，n表示数组大小<br>merge_sort(A, n) {<br>  merge_sort_c(A, 0, n-1)<br>}<br><br>&#47;&#47; 递归调用函数<br>merge_sort_c(A, p, r) {<br>  &#47;&#47; 递归终止条件<br>  if p &gt;= r  then return<br><br>  &#47;&#47; 取p到r之间的中间位置q<br>  q = (p+r) &#47; 2<br>  &#47;&#47; 分治递归<br>  merge_sort_c(A, p, q)<br>  merge_sort_c(A, q+1, r)<br>  &#47;&#47; 将A[p...q]和A[q+1...r]合并为A[p...r]<br>  merge(A[p...r], A[p...q], A[q+1...r])<br>}<br><br>这段伪代码， 我只看到了递归求每个区间中间值， 但我并没看到分割后区间里面数据进行排序啊， 他们是如何进行排序的？","like_count":0},{"had_liked":false,"id":243772,"user_name":"随风","can_delete":false,"product_type":"c1","uid":1476862,"ip_address":"","ucode":"037CE3554D8AB9","user_header":"https://static001.geekbang.org/account/avatar/00/16/88/fe/c18a85fe.jpg","comment_is_top":false,"comment_ctime":1598271697,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598271697","product_id":100017301,"comment_content":"快速排序第一次分区遍历n次找出左右两部分，第二次应该是两个n&#47;2，不是一个n&#47;2啊，因为左右两部分都还要接着找，不是只找一边，这样算最后还是n平方啊？迷糊了。","like_count":0},{"had_liked":false,"id":243197,"user_name":"波拉拉","can_delete":false,"product_type":"c1","uid":1122121,"ip_address":"","ucode":"586F66351219E8","user_header":"https://static001.geekbang.org/account/avatar/00/11/1f/49/e4ab004b.jpg","comment_is_top":false,"comment_ctime":1597990506,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597990506","product_id":100017301,"comment_content":"“假设对 n 个元素进行归并排序需要的时间是 T(n)，那分解成两个子数组排序的时间都是 T(n&#47;2)。我们知道，merge() 函数合并两个有序子数组的时间复杂度是 O(n)。所以，套用前面的公式，归并排序的时间复杂度的计算公式就是”求。。。。。这是啥意思啊？ 越读越不懂。。。T (n) 是具体时间？ o(n)和T（n） 不一样吗？搞不懂，哪位高手懂了，给解释下呗。。。。。","like_count":0},{"had_liked":false,"id":242328,"user_name":"子瞻","can_delete":false,"product_type":"c1","uid":1324314,"ip_address":"","ucode":"5C26FF10934534","user_header":"https://static001.geekbang.org/account/avatar/00/14/35/1a/9fa38dc9.jpg","comment_is_top":false,"comment_ctime":1597673118,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597673118","product_id":100017301,"comment_content":"n+n&#47;2+n&#47;4+n&#47;8+…+1。这是一个等比数列求和，最后的和等于 2n-1。这个等比数列极限求和是2n-1吗？","like_count":0},{"had_liked":false,"id":242290,"user_name":"Y","can_delete":false,"product_type":"c1","uid":1247009,"ip_address":"","ucode":"497A8FB4059387","user_header":"https://static001.geekbang.org/account/avatar/00/13/07/21/5153d403.jpg","comment_is_top":false,"comment_ctime":1597661185,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597661185","product_id":100017301,"comment_content":"@File    :   test2.py<br>@Desc    :   查找第K大的元素<br>&#39;&#39;&#39;<br><br>def test(lst,k,head,tail):<br>    if head &gt;= tail:<br>        return lst[tail]<br>    pivot = partition(lst,head,tail)<br>    if pivot+1 == k:<br>        val = lst[pivot]<br>    elif pivot+1 &gt; k:<br>        val = test(lst,k,head,pivot-1)<br>    elif pivot+1 &lt; k:<br>        val = test(lst,k,pivot+1,tail)<br>    return val<br><br>def partition(lst,head,tail):<br>    pivot = lst[tail]<br>    i,j = head,head<br>    for j in range(head,tail):<br>        if lst[j] &lt; pivot:<br>            lst[j],lst[i] = lst[i],lst[j]<br>            i += 1<br>    lst[i],lst[tail] = lst[tail],lst[i]<br>    return i","like_count":0},{"had_liked":false,"id":242090,"user_name":"Young","can_delete":false,"product_type":"c1","uid":1114206,"ip_address":"","ucode":"66B9176EBAF6CC","user_header":"https://static001.geekbang.org/account/avatar/00/11/00/5e/a253b30d.jpg","comment_is_top":false,"comment_ctime":1597588023,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597588023","product_id":100017301,"comment_content":"**Thinking：**首先要有顺序，第二要充分利用1G内存来加速。<br><br>**A:** <br><br>```<br># 10条缓冲IO读流读取日志文件，每个流用90M缓存用来减少IO，从而加速<br>io1 = bufferedReader(file1, 90M)<br>io2 = bufferedReader(file2, 90M)<br>...<br>io10 = bufferedReader(file10, 90M)<br><br># 1条缓冲IO写流写如合并文件，这个流用90M缓存用来减少IO，从而加速<br>io11 = bufferedWriter(mergeFile, 90M)<br><br># 这样11个IO流差不多消耗1G的内存<br># 10个读流，每次读取一行，选出时间戳最小的写入mergeFile，然后循环这个操作，最终完成文件的合并。如果这样的话，如果文件一共有n条数据，就需要比较n次，Time Complexity = O(n), Space Complexity = O(90M)<br><br>```<br><br>&gt; 然后如果想再进一步优化，可以使用**多线程**实现**生产者、消费者**的模型，10个IO分别写入自己的ArrayQueue(90M)，消费者读这10个ArrayQueue，选择最小的写入文件，以此类推。当然这里就要涉及到线程之间的通信。<br><br>我用的md写的，大家放到md编辑器中食用更佳 ：D","like_count":0},{"had_liked":false,"id":238220,"user_name":"星星","can_delete":false,"product_type":"c1","uid":1602765,"ip_address":"","ucode":"754C45CAA1730A","user_header":"https://static001.geekbang.org/account/avatar/00/18/74/cd/5cb1875b.jpg","comment_is_top":false,"comment_ctime":1596096854,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596096854","product_id":100017301,"comment_content":"醒悟过来，不能用乘法法则，每次merge数据规模不一样。","like_count":0},{"had_liked":false,"id":238213,"user_name":"星星","can_delete":false,"product_type":"c1","uid":1602765,"ip_address":"","ucode":"754C45CAA1730A","user_header":"https://static001.geekbang.org/account/avatar/00/18/74/cd/5cb1875b.jpg","comment_is_top":false,"comment_ctime":1596096367,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596096367","product_id":100017301,"comment_content":"归并算法时间复杂度能否用乘法法则呢？每次通过“分”操作，最终的调用merge次数为2*logn，而“治”操作merge函数的复杂度为O(n)，根据乘法法则最终时间复杂度为n*logn。","like_count":0},{"had_liked":false,"id":238035,"user_name":"田","can_delete":false,"product_type":"c1","uid":1669795,"ip_address":"","ucode":"2CC99CC96D59CC","user_header":"https://static001.geekbang.org/account/avatar/00/19/7a/a3/19d9bf76.jpg","comment_is_top":false,"comment_ctime":1596033307,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596033307","product_id":100017301,"comment_content":"&#47;&#47;归并排序 + 哨兵（实现）<br>const arrs = [9, 1, 3, 4, 5, 7, 2, 6];<br>function merge_sort(arr) {<br>    const n = arr.length - 1;<br>    merge_sort_c(arr, 0, n);<br>}<br>function merge_sort_c(arr, p, r) {<br>    if (p &gt;= r) return;<br>    const q = Math.floor((p + r) &#47; 2); &#47;&#47; 中间<br>    merge_sort_c(arr, p, q);<br>    merge_sort_c(arr, q + 1, r);<br>    merge(arr, p, q, r);<br>}<br>function merge(arr, p, q, r) {<br>    const left = arr.slice(p, q + 1);<br>    const right = arr.slice(q + 1, r + 1);<br>    let i = 0,<br>        j = 0,<br>        k = p;<br>    left.push(100000);&#47;&#47;增加哨兵<br>    right.push(100000);&#47;&#47;增加哨兵<br>    while (k &lt;= r) {&#47;&#47;只有一个判断条件，精简代码<br>        if (left[i] &lt;= right[j]) {<br>            arr[k++] = left[i++];<br>        } else {<br>            arr[k++] = right[j++];<br>        }<br>    }<br>}<br>merge_sort(arrs);","like_count":0},{"had_liked":false,"id":237706,"user_name":"滴答丶滴","can_delete":false,"product_type":"c1","uid":1181206,"ip_address":"","ucode":"2093C2948B4327","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/16/e85c1fa8.jpg","comment_is_top":false,"comment_ctime":1595931110,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595931110","product_id":100017301,"comment_content":"用java,按照老师伪代码写的。 我感觉就是没有老师的高大上，其余还好，不知道大家怎么看<br>    public int[] mergeSort(int[] nums) {<br>        if (nums.length &lt; 2) {<br>            return nums;<br>        }<br><br>        int q = (int) Math.floor(nums.length &#47; 2);<br>        int[] left = mergeSort(Arrays.copyOfRange(nums, 0, q));<br>        int[] right = mergeSort(Arrays.copyOfRange(nums, q, nums.length));<br>        &#47;&#47; TODO mergeSort_c应该把nums 排好序<br>        return merge(left, right);<br>    }<br><br>   &#47;&#47; 只看了老师的merge的实现思路，没有看伪代码写的<br>    public int[] merge(int[] left, int[] right) {<br>        int leftLen = left.length;<br>        int rightLen = right.length;<br>        int leftIndex = 0;<br>        int rightIndex = 0;<br>        boolean leftIndexOutOfBounds = false;<br>        boolean rightIndexOutOfBounds = false;<br>        int[] temp = new int[leftLen + rightLen];<br>        for (int i = 0; i &lt; temp.length; i++) {<br>            if (leftIndexOutOfBounds) {<br>                temp[i] = right[rightIndex];<br>                rightIndex++;<br>            } else if (rightIndexOutOfBounds) {<br>                temp[i] = left[leftIndex];<br>                leftIndex++;<br>            } else if (left[leftIndex] &lt; right[rightIndex]) {<br>                temp[i] = left[leftIndex];<br>                leftIndex++;<br>                if (leftIndex &gt;= leftLen) {<br>                    leftIndexOutOfBounds = true;<br>                }<br>            } else {<br>                temp[i] = right[rightIndex];<br>                rightIndex++;<br>                if (rightIndex &gt;= rightLen) {<br>                    rightIndexOutOfBounds = true;<br>                }<br>            }<br>        }<br>        return temp;<br>    }","like_count":0},{"had_liked":false,"id":237490,"user_name":"滴答丶滴","can_delete":false,"product_type":"c1","uid":1181206,"ip_address":"","ucode":"2093C2948B4327","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/16/e85c1fa8.jpg","comment_is_top":false,"comment_ctime":1595845131,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595845131","product_id":100017301,"comment_content":"这个归并排序，伪代码我看懂了。<br>但是用java实现，让我头顶一凉。。。。。<br>各位大佬行行好，能发我一份王争老师伪代码的实现方案吗？","like_count":0},{"had_liked":false,"id":237277,"user_name":"Geek_123d36","can_delete":false,"product_type":"c1","uid":2082963,"ip_address":"","ucode":"AE849572C4BAC3","user_header":"","comment_is_top":false,"comment_ctime":1595766427,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595766427","product_id":100017301,"comment_content":"p &gt;= r，归并排序的例子里，终止条件为什么是这个","like_count":0},{"had_liked":false,"id":237075,"user_name":"今夜秋风和","can_delete":false,"product_type":"c1","uid":1434066,"ip_address":"","ucode":"453C8197FFC81D","user_header":"https://static001.geekbang.org/account/avatar/00/15/e1/d2/42ad2c87.jpg","comment_is_top":false,"comment_ctime":1595667590,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595667590","product_id":100017301,"comment_content":"  刚才那个初次分区i和r 的值一样的情况下做了一个判断，以下是加了逻辑侯的分区代码逻辑;<br>private  int partition(int[] array,int p,int r){<br>        int pivot=array[r];&#47;&#47;分区元素<br>        int i=p;<br>        int j=0;<br>        for (j=p;j&lt;array.length-1;j++){<br>            if (array[j]&lt;pivot) {<br>                if (i!=j) {<br>                    int t = array[j];<br>                    array[j] = array[i];<br>                    array[i] = t;<br>                    i++;<br>                }else{<br>                    i++;<br>                }<br>            }<br>        }<br>        if (i==r) {<br>            System.out.println(&quot;new i=&quot;+(i-1));<br>            return i-1;<br>        }else{<br>            array[r]=array[i];<br>            array[i]=pivot;<br>            System.out.println(&quot;i=&quot;+i);<br>        }<br>        return i;<br>    }","like_count":0},{"had_liked":false,"id":237073,"user_name":"今夜秋风和","can_delete":false,"product_type":"c1","uid":1434066,"ip_address":"","ucode":"453C8197FFC81D","user_header":"https://static001.geekbang.org/account/avatar/00/15/e1/d2/42ad2c87.jpg","comment_is_top":false,"comment_ctime":1595667110,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595667110","product_id":100017301,"comment_content":"如果是(4,5,3,4,6)这样的元素，按照最后一个元素分区会导致栈溢出，所以还的判断一趟完了后r 和i 是否相等，若相等，重新选择分区来解决这个问题。","like_count":0},{"had_liked":false,"id":236873,"user_name":"ねせそたせ","can_delete":false,"product_type":"c1","uid":2074998,"ip_address":"","ucode":"8D817FC42608B3","user_header":"https://static001.geekbang.org/account/avatar/00/1f/a9/76/d8f20e0e.jpg","comment_is_top":false,"comment_ctime":1595573554,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595573554","product_id":100017301,"comment_content":"合并函数，两待排序的数组末尾可以添加对方数组的最后一个元素充当哨兵。","like_count":0},{"had_liked":false,"id":236089,"user_name":"sibyl","can_delete":false,"product_type":"c1","uid":1323652,"ip_address":"","ucode":"0D142011860D69","user_header":"","comment_is_top":false,"comment_ctime":1595311349,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595311349","product_id":100017301,"comment_content":"换一种思路理解快排的时间复杂度：<br> * 第0轮递归，需要分区的元素总数是n，<br> * 第1轮递归，需要分区的元素总数是2 * n&#47;2 = n<br> * 第2轮递归，需要分区的元素总数是4 * n&#47;4 = n<br> * 第3轮递归，需要分区的元素总数是8 * n&#47;8 = n<br> * 第k轮递归，需要分区的元素总数是2^(k) * n&#47;(2^k) = n<br> <br> 则k轮递归一共参与分区的元素次数是：kn，可知快排的时间复杂度是O(kn)，<br> <br> 当每次分区都能一分为二，则k=㏒₂ⁿ，所以最优时间复杂度是O(nlogn)<br> 而当每次分区的结果都是 0 : (n-1)，则k=n-1，所以最差时间负载度是O(n^2) ","like_count":0},{"had_liked":false,"id":235166,"user_name":"Merry","can_delete":false,"product_type":"c1","uid":1024036,"ip_address":"","ucode":"E2A114E10814BA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a0/24/68c679c8.jpg","comment_is_top":false,"comment_ctime":1594912088,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594912088","product_id":100017301,"comment_content":"课后思考： 利用2路归并实现","like_count":0},{"had_liked":false,"id":234500,"user_name":".","can_delete":false,"product_type":"c1","uid":2055898,"ip_address":"","ucode":"77609EE91386C4","user_header":"https://static001.geekbang.org/account/avatar/00/1f/5e/da/9064df96.jpg","comment_is_top":false,"comment_ctime":1594706573,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594706573","product_id":100017301,"comment_content":"    先从十条数据中各读50M，然后开始合并，合并可以用归并序中的merge函数，每当一条数据读完时，讲当前排好序的日志写入新文件，并从读完的日志中再读取50M，如此下去，应该可以在最大化利用内存的同时，减少IO操作的次数。<br>    内存使用最极端的情况也就是第一条数据的50M读完之后，其余数据都还只剩一条，此时内存占用大约1G。<br>    时间复杂度，由于每条日志排好序最多需要9次比较，因此时间复杂度T(n) = O(n).","like_count":0},{"had_liked":false,"id":233799,"user_name":"启程去流浪","can_delete":false,"product_type":"c1","uid":1160352,"ip_address":"","ucode":"BE8B1A6FC37CFB","user_header":"https://static001.geekbang.org/account/avatar/00/11/b4/a0/5e890939.jpg","comment_is_top":false,"comment_ctime":1594456404,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594456404","product_id":100017301,"comment_content":"我只想问下，从示例图上看，归并排序最后一步是怎么排的？","like_count":0},{"had_liked":false,"id":231192,"user_name":"浩子（amos）","can_delete":false,"product_type":"c1","uid":1099597,"ip_address":"","ucode":"70F0E61DBE3F54","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/4d/80a11c08.jpg","comment_is_top":false,"comment_ctime":1593605449,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593605449","product_id":100017301,"comment_content":"习题思路：性能关键点是归并和IO消耗，内存分配是55开，一半读10个文件的50m数据，一半存排序后的数据。归并过程中，某个文件的内存数据耗尽则补下一批且需考虑个人文件提前读完的case。排序好的数据则是满了就集中写一把。最后，如果可以多线程、进程，则可以做成生产消费模型，并行起来提升性能","like_count":0},{"had_liked":false,"id":230482,"user_name":"SuperH~","can_delete":false,"product_type":"c1","uid":1103802,"ip_address":"","ucode":"21929491561C7A","user_header":"https://static001.geekbang.org/account/avatar/00/10/d7/ba/d657d286.jpg","comment_is_top":false,"comment_ctime":1593398171,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593398171","product_id":100017301,"comment_content":"留下java的写法：<br>public static void main(String[] args) {<br>        int[] arr = {10,7,2,4,7,62,3,4,2,1,8,9,19};<br>        quickSort(arr, 0, arr.length-1);<br>        for (int i = 0; i &lt; arr.length; i++) {<br>            System.out.println(arr[i]);<br>        }<br>    }<br><br>    private static void quickSort(int[] arr, int low, int high) {<br>        if(low &gt; high){<br>            return;<br>        }<br>        int temp = arr[low];<br>        int i = low;<br>        int j = high;<br>        while (i &lt; j){<br><br>            while(temp &lt;= arr[j] &amp;&amp; i&lt;j){<br>                j--;<br>            }<br><br>            while(temp &gt;= arr[i] &amp;&amp; i&lt;j){<br>                i++;<br>            }<br><br>            if(i &lt;j){<br>                int t = arr[j];<br>                arr[j] = arr[i];<br>                arr[i] =t;<br>            }<br>        }<br>        arr[low] =arr[i];<br>        arr[i] = temp;<br>        quickSort(arr,low,j-1);<br>        quickSort(arr,j+1,high);<br><br>    }","like_count":0},{"had_liked":false,"id":230481,"user_name":"Geek_dd8b2b","can_delete":false,"product_type":"c1","uid":1988075,"ip_address":"","ucode":"CBEF7C39075A96","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJX4ZU53F8hBHicctluqK6Ef3U0ib40bq1vFyAvqV0wu3GaPuWbj967OdMT7k0gl3OMxsfopvbk9veQ/132","comment_is_top":false,"comment_ctime":1593397965,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593397965","product_id":100017301,"comment_content":"双指针这种思想也是无处不在，partion分区的i和j，j用于前进探索数据，而i则是用于指向当前已经被交换过的元素的下一个index。","like_count":0},{"had_liked":false,"id":230441,"user_name":"罗樱罂","can_delete":false,"product_type":"c1","uid":2045997,"ip_address":"","ucode":"9072E79E625ED1","user_header":"https://static001.geekbang.org/account/avatar/00/1f/38/2d/f3c6493e.jpg","comment_is_top":false,"comment_ctime":1593391595,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593391595","product_id":100017301,"comment_content":"老师，我最后那一道题感觉是不是也可以应用heapsort？就是假设一个文件的接口用linkedlist来表示，读完一个日志再读下一个的过程是一个移动head的过程。那么我们可以事先先读进用于heapsort里的array中。每插入一个新的数据就能保证排序过的。十篇读完以后就开始remove min的过程。整体思想就是用size为10的priority queue来解决？","like_count":0},{"had_liked":false,"id":230340,"user_name":"Geek_dd8b2b","can_delete":false,"product_type":"c1","uid":1988075,"ip_address":"","ucode":"CBEF7C39075A96","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJX4ZU53F8hBHicctluqK6Ef3U0ib40bq1vFyAvqV0wu3GaPuWbj967OdMT7k0gl3OMxsfopvbk9veQ/132","comment_is_top":false,"comment_ctime":1593351502,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593351502","product_id":100017301,"comment_content":"老师，归并排序的那个merge 不可以采用传递start end这样的index，然后结合双指针交换达成原地排序吗？","like_count":0},{"had_liked":false,"id":229729,"user_name":"Swift_yong","can_delete":false,"product_type":"c1","uid":1260782,"ip_address":"","ucode":"19AE116EB7BCF0","user_header":"https://static001.geekbang.org/account/avatar/00/13/3c/ee/18f48590.jpg","comment_is_top":false,"comment_ctime":1593131789,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593131789","product_id":100017301,"comment_content":"1.思考题的解答， 麻烦作者统一在某一章节， 或者在下一个章节给出您的思路， 大家有一个参考和学习。<br>2.关于写伪代码， 还是源码， 个人建议写伪代码， 给出思路，自己实现可以锻炼自己，再说， 学习的人不都是java比较熟练的， 不要自己是学Java的， 就不考虑其他伙伴的感受。再说作者给你贴出源码了， 你自己写意义就不大了。","like_count":0},{"had_liked":false,"id":229393,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1592983570,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592983570","product_id":100017301,"comment_content":"每个文件取100条数据，10个文件各一百条数据，进行归并排序，排号之后写入新文件，然后在取100条数据，继续重复刚才的归并排序操作，直到取完数据。每次相当于1000条数据进行排序，考虑每条数据的大小，不要让超过内存占用。综合时间复杂度和空间复杂度","like_count":0},{"had_liked":false,"id":228031,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1613056,"ip_address":"","ucode":"A949ABFA68E27A","user_header":"https://static001.geekbang.org/account/avatar/00/18/9d/00/40ef6819.jpg","comment_is_top":false,"comment_ctime":1592539310,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592539310","product_id":100017301,"comment_content":"总结一下：<br>两种算法都用到了分治思想。两种算法从最终来看的最大区别在于：<br>1、归并排序：时间复杂度为O(nlogn),空间复杂度为O(n)，不是原地排序，但是归并排序是稳定的排序算法，如果对空间利用率要求没有那么高，且要求是稳定排序的话可以考虑使用归并排序<br>2、快速排序：时间复杂度O(nlogn),空间复杂度为O(1)，是原地排序，占用空间少。但是由于要交换数据，快速排序不是稳定的排序。如果要求是稳定的排序，不能使用快速排序","like_count":0},{"had_liked":false,"id":227641,"user_name":"极客学子","can_delete":false,"product_type":"c1","uid":1149510,"ip_address":"","ucode":"40051597564EB7","user_header":"https://static001.geekbang.org/account/avatar/00/11/8a/46/71747b18.jpg","comment_is_top":false,"comment_ctime":1592447893,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592447893","product_id":100017301,"comment_content":"十个小文件每个读取80M,然后进行合并，每次当合并的数据达到200M时写入新的大文件，<br>然后每一个小文件的80M数据合并完成后继续读取80M，如此反复直到所有数据合并完成。","like_count":0},{"had_liked":false,"id":226883,"user_name":"Geek_849f9f","can_delete":false,"product_type":"c1","uid":2027473,"ip_address":"","ucode":"67601F35A91999","user_header":"","comment_is_top":false,"comment_ctime":1592223360,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592223360","product_id":100017301,"comment_content":"归并排序与快速排序都是将大的问题拆解为小的问题，不同归并是由下而上，快速排序是由上而下；","like_count":0},{"had_liked":false,"id":225509,"user_name":"SPUTNIK","can_delete":false,"product_type":"c1","uid":1158161,"ip_address":"","ucode":"09D01EF973BF5F","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/11/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1591773563,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591773563","product_id":100017301,"comment_content":"老师，我刚刚开始学，有一个地方不知道理解得对不对：每次把 pivot 取最后一个值，这个已经属于建立了一个哨兵吧？","like_count":0},{"had_liked":false,"id":225423,"user_name":"worthto","can_delete":false,"product_type":"c1","uid":1387712,"ip_address":"","ucode":"41D7ABBBD2E7FF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/N6yjnrLnMW4XVSkBr3f0N3F962l35b5j0kib9VSlAqqbf6iaoCPicL1WnJ9KjgT4egQ7A2G0Zx3OayaK4yuoZrUVA/132","comment_is_top":false,"comment_ctime":1591754261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591754261","product_id":100017301,"comment_content":"针对归并排序的例子，做了一个小优化，处理两个有序数组的逻辑可以挪到第一个while循环中。<br>public void mergeSort(int[] numbers, int start, int end) {<br>        if (start &gt;= end) {<br>            return;<br>        }<br>        int mid = (start + end) &#47; 2;<br>        mergeSort(numbers, start, mid);<br>        mergeSort(numbers, mid + 1, end);<br>        &#47;&#47;合并start-mid, mid+1-end 两端数组<br>        int i = start, j = mid + 1;<br>        int[] tmpArray = new int[end - start + 1];<br>        int tmp = 0;<br>        while (i &lt;= mid || j &lt;= end) {<br>            if (i &lt;= mid &amp;&amp; j &lt;= end) {<br>                if (numbers[i] &lt;= numbers[j]) {<br>                    tmpArray[tmp++] = numbers[i++];<br>                } else {<br>                    tmpArray[tmp++] = numbers[j++];<br>                }<br>            } else if (i &lt;= mid) {<br>                &#47;&#47;处理剩余的数据<br>                tmpArray[tmp++] = numbers[i++];<br>            } else if (j &lt;= end) {<br>                &#47;&#47;处理剩余的数据<br>                tmpArray[tmp++] = numbers[j++];<br>            }<br>        }<br>        &#47;&#47;把tmpArray的数据拷贝到tmpArray<br>        for (int p = 0, q = start; p &lt; tmpArray.length; p++, q++) {<br>            numbers[q] = tmpArray[p];<br>        }<br>    }","like_count":0},{"had_liked":false,"id":224182,"user_name":"wgcris","can_delete":false,"product_type":"c1","uid":1527666,"ip_address":"","ucode":"842B76EB6B8320","user_header":"","comment_is_top":false,"comment_ctime":1591314628,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591314628","product_id":100017301,"comment_content":"老师，请教个问题，有没有比快排更好的算法呢","like_count":0},{"had_liked":false,"id":223475,"user_name":"宪成小哥","can_delete":false,"product_type":"c1","uid":1526406,"ip_address":"","ucode":"7C1A4F25ACCB4A","user_header":"https://static001.geekbang.org/account/avatar/00/17/4a/86/3cd4144e.jpg","comment_is_top":false,"comment_ctime":1591099446,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591099446","product_id":100017301,"comment_content":"根据王哥的思路,用JAVA实现了一遍：<br>private static int[] sort(int[] array, int start, int end) {<br>         if (start &gt;= end) return array;<br>         int p = partition(array, start, end);<br>         sort(array, start, p - 1);<br>         sort(array, p + 1, end);<br>         return array;<br>     }<br> <br>     private static int partition(int[] array, int start, int end) {<br>         int pivot = array[end];<br>         int insertIndex = start; &#47;&#47; 将元素插入到指定的位置<br>         for (int i = start; i &lt; end; i++) {<br>             int element = array[i];<br>             if (element &lt;= pivot) {<br>                 if (array[insertIndex] &gt; array[i]) {<br>                     array[i] = array[insertIndex];<br>                     array[insertIndex] = element;<br>                 }<br>                 insertIndex++;<br>             }<br>         }<br>         array[end] = array[insertIndex];<br>         array[insertIndex] = pivot;<br>         return insertIndex;<br>     }","like_count":0},{"had_liked":false,"id":223110,"user_name":"KangShan","can_delete":false,"product_type":"c1","uid":1082000,"ip_address":"","ucode":"07497A7AC92238","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/90/e4a08b0e.jpg","comment_is_top":false,"comment_ctime":1591003456,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591003456","product_id":100017301,"comment_content":"<br>```java<br>public static void sort(int[] array, int startIndex, int endIndex) {<br>        int temp;<br>        if (endIndex - startIndex &lt; 1) {<br>            return;<br>        } else if (endIndex - startIndex == 1) {<br>            if (array[startIndex] &gt; array[endIndex]) {<br>                temp = array[startIndex];<br>                array[startIndex] = array[endIndex];<br>                array[endIndex] = temp;<br>            }<br>            return;<br>        }<br>        int pivot = array[endIndex];<br>        int i = startIndex;<br>        for (int j = startIndex; j &lt; endIndex; j++) {<br>            if (array[j] &lt;= pivot) {<br>                temp = array[i];<br>                if (array[i] &gt; pivot &amp;&amp; i != j) {<br>                    array[i] = array[j];<br>                    array[j] = temp;<br>                }<br>                i++;<br>            }<br>        }<br>        temp = array[i];<br>        array[i] = pivot;<br>        array[endIndex] = temp;<br><br>        &#47;&#47;right partition<br>        sort(array, i + 1, endIndex);<br>        &#47;&#47;left partition<br>        sort(array, startIndex, i - 1);<br>    }<br>```","like_count":0},{"had_liked":false,"id":223079,"user_name":"KangShan","can_delete":false,"product_type":"c1","uid":1082000,"ip_address":"","ucode":"07497A7AC92238","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/90/e4a08b0e.jpg","comment_is_top":false,"comment_ctime":1590996823,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590996823","product_id":100017301,"comment_content":"快排依然可以做到稳定吧。只需要在判定小于枢值那儿换成 小于等于即可啊。<br>if A[j] &lt; pivot { <br>    swap A[i] with A[j] i := i+1 <br>}<br>交换后相同的值排在前面的依然还是排列在前面","like_count":0},{"had_liked":false,"id":221807,"user_name":"赵","can_delete":false,"product_type":"c1","uid":1730160,"ip_address":"","ucode":"EAC4390FD95EF9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/O3Uf8dibBnKKzibgEhvvKs9vic0dBavSJzn79fZVtH0AxcUT09bvOAYvr2f7vecmwiao7BBGgE5p8lXHSoBMdmQuBw/132","comment_is_top":false,"comment_ctime":1590594067,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590594067","product_id":100017301,"comment_content":"老师这是我在网上看的一个快速排序算法，不知道和老师您写的原理是否一样，可以分析一下嘛？<br><br>&#47;*<br>\t     * 快速排序<br>\t     *<br>\t     * 参数说明：<br>\t     *     a -- 待排序的数组<br>\t     *     l -- 数组的左边界(例如，从起始位置开始排序，则l=0)<br>\t     *     r -- 数组的右边界(例如，排序截至到数组末尾，则r=a.length-1)<br>\t     *&#47;<br>\t    public static void quickSort(int[] a, int l, int r) {<br>\t<br>\t        if (l &lt; r) {<br>\t            int i,j,x;<br>\t<br>\t            i = l;<br>\t            j = r;<br>\t            x = a[i];<br>\t            while (i &lt; j) {<br>\t                while(i &lt; j &amp;&amp; a[j] &gt; x)<br>\t                    j--; &#47;&#47; 从右向左找第一个小于x的数<br>\t                if(i &lt; j)<br>\t                    a[i++] = a[j];<br>\t                while(i &lt; j &amp;&amp; a[i] &lt; x)<br>\t                    i++; &#47;&#47; 从左向右找第一个大于x的数<br>\t                if(i &lt; j)<br>\t                    a[j--] = a[i];<br>\t            }<br>\t            a[i] = x;<br>\t            quickSort(a, l, i-1); &#47;* 递归调用 *&#47;<br>\t            quickSort(a, i+1, r); &#47;* 递归调用 *&#47;<br>\t        }<br>\t    }<br>","like_count":0},{"had_liked":false,"id":220888,"user_name":"怕什么，抱紧我","can_delete":false,"product_type":"c1","uid":1318633,"ip_address":"","ucode":"CBCEA76E9EF33B","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/e9/dcc63d8f.jpg","comment_is_top":false,"comment_ctime":1590334005,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1590334005","product_id":100017301,"comment_content":"我写的归并排序,空间复杂度O(1),没有像老师所说的那样O(n)   <br>&#47;**<br>     * 归并排序:<br>     * 写算法遵循左闭右开原则<br>     *&#47;<br>    public static void mergeSort(int[] array){<br>        if(array.length &lt;= 1){return;}<br>        <br>        mergeSortMethod(array,0,array.length);<br><br>    }<br><br>    &#47;**<br>     * 分解数组<br>     * @param array<br>     * @param start<br>     * @param end<br>     * @return<br>     *&#47;<br>    public static void mergeSortMethod(int[] array, int start, int end){<br>        if(start == end-1){return;}&#47;&#47;递归结束条件<br>        int mid = (start + end)&#47;2;<br><br>        mergeSortMethod(array,start,mid);<br>        mergeSortMethod(array,mid,end);<br><br>        merge(array,start,mid,end);<br><br>    }<br><br>    &#47;**<br>     * 归并数组<br>     * @param array<br>     * @param start<br>     * @param mid<br>     * @param end<br>     *&#47;<br>    private static void merge(int[] array, int start, int mid, int end){<br>        for(; mid &lt; end; mid++){<br>            int temp = array[mid];<br>&#47;&#47;            for(; mid-1&gt;= start;mid--){<br>            for(; mid &gt;= start+1;mid--){<br>                if(temp &lt; array[mid-1] ){<br>                    array[mid] = array[mid-1];<br>                }else{<br>                    break;<br>                }<br>            }<br>            array[mid] = temp;<br>        }<br>    }","like_count":0,"discussions":[{"author":{"id":1318633,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1e/e9/dcc63d8f.jpg","nickname":"怕什么，抱紧我","note":"","ucode":"CBCEA76E9EF33B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275941,"discussion_content":"/**快速排序\n * 所有代码遵循左闭右开,下标为0开始原则\n */\npublic class QuickSort {\n\n    /**\n     * 快速排序\n     * @param array\n     */\n\n    public static void sort(int[] array){\n        quickMethod(array,0,array.length);\n    }\n\n    /**\n     * @param array 数组\n     * @param begin  数组起始位置\n     * @param end   数组结束位置\n     */\n    private static void quickMethod(int[] array, int begin, int end){\n        if(begin == end){\n            return;\n        }\n\n        int left = begin;\n        int right = end-2;\n        int basic = end-1;\n\n        int basicValue = array[end-1];\n        \n        for(;left <= right; left++){\n            if(array[left] > basicValue){ \n               \n                for(;right >= left; right --){\n                  if(array[right] < basicValue){\n                      /**\n                       * 左右标记交换元素值\n                       */\n                      int temp = array[right];\n                      array[right] = array[left];\n                      array[left] = temp;\n                      break ;\n                  }\n                  if(right == left){  //如果左右标记重合,则交换基准点的值\n                      /**\n                       * 左右标记重合,和基准点交换\n                       */\n                      array[basic] = array[right];\n                      array[right] = basicValue;\n                  }\n\n                }\n            }\n\n        }\n        \n        //分区操作\n        quickMethod(array,begin,left);\n        quickMethod(array,left+1,end);\n    }\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590769869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220353,"user_name":"Geek_py hang","can_delete":false,"product_type":"c1","uid":1915167,"ip_address":"","ucode":"E1DABF14C9176B","user_header":"https://static001.geekbang.org/account/avatar/00/1d/39/1f/579ae900.jpg","comment_is_top":false,"comment_ctime":1590225791,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590225791","product_id":100017301,"comment_content":"分治排序，分而治之，联邦式","like_count":0},{"had_liked":false,"id":218114,"user_name":"KAGEMUSHA","can_delete":false,"product_type":"c1","uid":1144504,"ip_address":"","ucode":"DFC05BE62A9C10","user_header":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","comment_is_top":false,"comment_ctime":1589717730,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589717730","product_id":100017301,"comment_content":"我用的取中位数的快排，BFPRT算法。但是和网上大多数不一样我优化了2个和4个元素的情况下的选取，2个元素我选的前一个1，4个元素我选取的后一个3，这样优化完了感觉跑起来才没问题了直接用网上搜来的代码GG","like_count":0},{"had_liked":false,"id":217965,"user_name":"王瑞强","can_delete":false,"product_type":"c1","uid":1829090,"ip_address":"","ucode":"DEE4EB5E23433F","user_header":"https://static001.geekbang.org/account/avatar/00/1b/e8/e2/2bcaef68.jpg","comment_is_top":false,"comment_ctime":1589683747,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589683747","product_id":100017301,"comment_content":"k路归并排序+二分查找的思路<br>k路归并排序是10个文件将其分成10个数组，之后进行归并排序，时间复杂度nlogn。<br>二分查找是针对10个数组，先把每个数组的第一个元素取出来进行从小到大排序，下次利用二分查找直接定位下一个元素的位置，然后取最小的值写入合并的临时数组","like_count":0},{"had_liked":false,"id":217459,"user_name":"Geek_Akara","can_delete":false,"product_type":"c1","uid":1991279,"ip_address":"","ucode":"E86A5A9EEC8BFF","user_header":"https://static001.geekbang.org/account/avatar/00/1e/62/6f/06d476f7.jpg","comment_is_top":false,"comment_ctime":1589508653,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589508653","product_id":100017301,"comment_content":"第一次分区查找，我们需要对大小为 n 的数组执行分区操作，需要遍历 n 个元素。第二次分区查找，我们只需要对大小为 n&#47;2 的数组执行分区操作，需要遍历 n&#47;2 个元素。依次类推，分区遍历元素的个数分别为、n&#47;2、n&#47;4、n&#47;8、n&#47;16.……直到区间缩小为 1。如果我们把每次分区遍历的元素个数加起来，就是：n+n&#47;2+n&#47;4+n&#47;8+…+1。这是一个等比数列求和，最后的和等于 2n-1。所以，上述解决思路的时间复杂度就为 O(n).<br><br>这里n&#47;2应该是最理想情况下，如果n从大到小有序排列：8，7，6，5，4，3，2，1， K=1， 找到第一大元素，时间复杂度：n+(n-1)+...+1, 等差数列求和1&#47;2n^2 + 1&#47;2n, 时间复杂度O(n^2). 最好O(n)最坏O(n^2),这个跟O(K*n)比较的话，要怎么判断哪个好坏呢？","like_count":0},{"had_liked":false,"id":216499,"user_name":"3.141516","can_delete":false,"product_type":"c1","uid":1013309,"ip_address":"","ucode":"34AF71B02692F3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/3d/8120438b.jpg","comment_is_top":false,"comment_ctime":1589272535,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1589272535","product_id":100017301,"comment_content":"从归并排序角度看的话，把 1G 内存分为两半，一份用于读取，另一份用于归并的排序。一次读取 500m，10 个文件每个文件 50m。然后归并四次得到最终结果，全部写入文件。重复六次即可。合并时间复杂度为 O(n)。","like_count":0},{"had_liked":false,"id":214489,"user_name":"刘飞","can_delete":false,"product_type":"c1","uid":1160409,"ip_address":"","ucode":"5BE4E9B8ADB5B5","user_header":"https://static001.geekbang.org/account/avatar/00/11/b4/d9/8a5e648c.jpg","comment_is_top":false,"comment_ctime":1588757593,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588757593","product_id":100017301,"comment_content":"归并排序MergeSort：<br>在程序中设置断点，数组{11,8,3,9,7,1,2,5}，有时会输出错误的结果：{1, 2, 3, 0, 5, 7, 8, 0}，这是什么原因？<br>","like_count":0},{"had_liked":false,"id":213998,"user_name":"Geek_ac7784","can_delete":false,"product_type":"c1","uid":1981613,"ip_address":"","ucode":"62F0E5E6D6F4BA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/8Dj4ugujXwY24G8pcpgDFGiciarXetG3ItQ4M9mSQMLyRdRRXEXXJVfib48mGUQAu87QcvImwyJIVJlEFeEguV44w/132","comment_is_top":false,"comment_ctime":1588614052,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588614052","product_id":100017301,"comment_content":"学习感悟：<br>1.  两种O(nlogn)算法，归并和快速排序<br>2. 分析：<br>    归并排序：非原地，稳定，时间复杂度用递推公式，容易得到nlog(n)，而且很稳定，不论是什么数据，都会经历一样的流程。<br>    快速排序：原地，不稳定，时间复杂度推理是一样的。但是在最坏情况下，每次选择的分段点都是边界，时间复杂度会退化到O(n2)。<br>    用递推公式来求时间复杂度比较简单，还有个递推树，应用更广。<br>3. 写代码技巧：归并在于合并算法。首先需要申请空间，然后一个双数组循环。之后判断谁没循环完，给他接上去。可以用哨兵，但特定情况下才能用。<br>4. 测试：<br>环境：用自己笔记本i5-4200H，c++，生成1000组数据，范围为-10000到10000的随机整数。数组的大小8倍增。从0到8000个数据。<br>插入排序，用时123s <br>归并排序，用时4s<br>快速排序，用时不到2s<br>标准库自带：<br>sort()用时1.016s<br>stable_sort()用时 1.181s<br>标准库中的稳定排序都比我的快速排序快。。等14节的排序优化再说吧<br>思考题：内存中分配足够大的空间(例如：800Mb), 10条i&#47;o流，找出最小的，放入该空间中。满了就写入硬盘一次。留言中有用优先队列(最小堆)实现的，具体细节不清楚，应该找最小值更快些。<br><br><br>","like_count":0},{"had_liked":false,"id":213984,"user_name":"JackySong","can_delete":false,"product_type":"c1","uid":1855483,"ip_address":"","ucode":"47D976A0150839","user_header":"https://static001.geekbang.org/account/avatar/00/1c/4f/fb/716bb5e8.jpg","comment_is_top":false,"comment_ctime":1588607912,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588607912","product_id":100017301,"comment_content":"一个星期前学习的，当时应该是看懂了，但是昨天复习的时候发现想不太起来，看来还是得学而时习之，最好加上实践，不然很容易就忘了。","like_count":0},{"had_liked":false,"id":213131,"user_name":"严丹","can_delete":false,"product_type":"c1","uid":1798204,"ip_address":"","ucode":"96FA634D06C3FD","user_header":"https://static001.geekbang.org/account/avatar/00/1b/70/3c/a002615b.jpg","comment_is_top":false,"comment_ctime":1588309479,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1588309479","product_id":100017301,"comment_content":"这一章难度开始上来了，快速排序没理解，稍后再来一次","like_count":0},{"had_liked":false,"id":210882,"user_name":"hailowell","can_delete":false,"product_type":"c1","uid":1195572,"ip_address":"","ucode":"557DCAB01710AB","user_header":"","comment_is_top":false,"comment_ctime":1587860254,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587860254","product_id":100017301,"comment_content":"初步来说每个文件读取一行，比较时间戳 将最小的写入新文件同时读取下一行<br>只是不够快 因为还要等待比较完成并且写入新文件才读取下一行<br>可以使用缓存和多线程 ，一边读取十个文件 将数据放到缓存中，一边比较后写入新文件<br>因为内存不大 缓存设置数量上限 到上限之后 读取文件的线程阻塞等待<br>考虑到虽然每个文件虽然按时间戳排序 但是极端情况下 可能有某个文件最晚的记录都比其他文件的最早记录还要早<br>所以每个文件设置一块缓存，可以考虑用阻塞队列 实现一个生产者消费者模型","like_count":0},{"had_liked":false,"id":210322,"user_name":"xzy","can_delete":false,"product_type":"c1","uid":1002095,"ip_address":"","ucode":"1A44368083A19E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","comment_is_top":false,"comment_ctime":1587720629,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587720629","product_id":100017301,"comment_content":"仔细看了一下：归并排序的递推终止条件是 p == r 就可以吧","like_count":0},{"had_liked":false,"id":210014,"user_name":"HoSalt","can_delete":false,"product_type":"c1","uid":1156074,"ip_address":"","ucode":"610B03E2A002D1","user_header":"https://static001.geekbang.org/account/avatar/00/11/a3/ea/53333dd5.jpg","comment_is_top":false,"comment_ctime":1587651789,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587651789","product_id":100017301,"comment_content":"「如何用快排思想在O(n)内查找第K大元素？」 这是最好时间复杂度的情况下吧，最坏时间复杂度下为O(n*n)吧","like_count":0},{"had_liked":false,"id":209580,"user_name":"Allan","can_delete":false,"product_type":"c1","uid":1310388,"ip_address":"","ucode":"8DA4DBECC2C45C","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","comment_is_top":false,"comment_ctime":1587568163,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587568163","product_id":100017301,"comment_content":"60天攻克算法打卡行动第10天<br><br>学习内容 : 排序（下）：如何用快排思想在O(n)内查找一个无序数组中的第K大元素？<br><br>归并排序和快速排序是时间复杂度为 O(nlogn) 的排序算法，掌握它们的原理和性能分析，就能实现大规模数据排序问题。<br>两种排序都用到了分治排序，前后分组，组内排序再和其他组合并的思想。分而治之，将一个大组分成小组排序后合并。<br>归并排序实现 https:&#47;&#47;www.runoob.com&#47;w3cnote&#47;merge-sort.html 参考<br>参考这个地址才完成了代码代码实现，老师的文章的代码可能对我来说看的不是很明白。<br><br>1.归并排序的原理和性能分析<br>就是分而治之，最小粒度的排序完后向上排序合并，稳定算法，T（1）=C n=1时，T（n）= 2*T（n &#47; 2）+ n n&gt;1;之后分解式子得 T(n) = 2^k T(n&#47;2^k) + kn，T（n&#47;2^k) = T(1), n &#47; 2^k = 1,得 k = log2n,k带入回去得 T（n）= Cn + nlog2n。 T（n） = O（nlogn）。非原地排序算法。<br>2.快速排序的原理和性能分析<br>选择一个数，大于它放右边，小于它放左边。代码看了半天不如网上搜到的代码看着明白，直接实现。复杂度看的还是不够透彻，还得自己多练习！","like_count":0},{"had_liked":false,"id":209563,"user_name":"change","can_delete":false,"product_type":"c1","uid":1110876,"ip_address":"","ucode":"D78B4B3752B6FE","user_header":"https://static001.geekbang.org/account/avatar/00/10/f3/5c/8704e784.jpg","comment_is_top":false,"comment_ctime":1587566848,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1587566848","product_id":100017301,"comment_content":"归并排序的合并方法merge(A[p...r], A[p...q], A[q+1...r])实现,完全可以直接用A[p...r]存放合并后结果,这样就不用临时变量了,空间复杂度就是O(1)","like_count":0},{"had_liked":false,"id":209557,"user_name":"拉普达","can_delete":false,"product_type":"c1","uid":1930686,"ip_address":"","ucode":"0E524C0D99B2A0","user_header":"https://static001.geekbang.org/account/avatar/00/1d/75/be/6f3ab95e.jpg","comment_is_top":false,"comment_ctime":1587566289,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587566289","product_id":100017301,"comment_content":"设计10个读取缓存队列和1个结果队列。初始可一设成每个队列最多能存50MB，结果数组为500MB。每次比较从队首元素中找最大的出队，并入结果队列。如果缓存队列空，则重新读入对应日志文件中50MB数据；如果结果队列满，保存成结果文件。最终，将生成的6个结果文件头尾合并。","like_count":0},{"had_liked":false,"id":209425,"user_name":"o0oi1i","can_delete":false,"product_type":"c1","uid":1132312,"ip_address":"","ucode":"D1F6AD4AAEAFBE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/18/293cd24d.jpg","comment_is_top":false,"comment_ctime":1587547969,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587547969","product_id":100017301,"comment_content":"光看理解不了这节课了，只有码了代码之后再来看了，老师的问题感觉已经超出了自己的能力范围无法解答。","like_count":0},{"had_liked":false,"id":209336,"user_name":"russellyue","can_delete":false,"product_type":"c1","uid":1541894,"ip_address":"","ucode":"0758ACF772F9C1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epIMwPE6FwsicZ6bjhu7ZpWLnoib8G76sA1XL8y5W8GxqfQEjBub6g57E60mzjWzrA6icMRw1QT5CpyA/132","comment_is_top":false,"comment_ctime":1587538194,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1587538194","product_id":100017301,"comment_content":"总结：归并排序用了分治的思想。其原理是，将数据分为左右两块，先各自排序后，再合在一起。归并排序时间复杂度在最好、最坏和平均下都稳定为O(nlogn),但是缺点是，归并排序并不是原地排序，空间复杂度为O(n)。快排的思想是，每次牟定一个值，将大于这个值的数据放到该值右边，小于的则放到左边。然后在用同样的方法去操作左右边，直到不能再分。快排的平均时间复杂度为O(nlogn)，但是在一些情况下，时间复杂度会退化成O(n^2), 关键在于每次快排中比较值的选择。","like_count":0},{"had_liked":false,"id":207520,"user_name":"谢特","can_delete":false,"product_type":"c1","uid":1248684,"ip_address":"","ucode":"9C30DBFECFE649","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/ac/09678490.jpg","comment_is_top":false,"comment_ctime":1587099679,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587099679","product_id":100017301,"comment_content":"快排最后一次交换：swap A[i] with A[r]这里是swap A[i+1]还是swap A[i]，我输入的测试样例，包含重复和不包含重复数字，得出来的结果不一样呢","like_count":0},{"had_liked":false,"id":207314,"user_name":"亢（知行合一的路上）","can_delete":false,"product_type":"c1","uid":1347013,"ip_address":"","ucode":"958AF7C96EB9E8","user_header":"https://static001.geekbang.org/account/avatar/00/14/8d/c5/898b13b4.jpg","comment_is_top":false,"comment_ctime":1587046494,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587046494","product_id":100017301,"comment_content":"如果内存充足，优先使用归并排序，如果数据量很大，往往内存就不充足了，快排就派上用场了。","like_count":0},{"had_liked":false,"id":207219,"user_name":"侧耳倾听","can_delete":false,"product_type":"c1","uid":1512642,"ip_address":"","ucode":"5BF2A2440B54F0","user_header":"https://static001.geekbang.org/account/avatar/00/17/14/c2/46ebe3a0.jpg","comment_is_top":false,"comment_ctime":1587026416,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1587026416","product_id":100017301,"comment_content":"partition(A, p, r) 方法，swap的if判断条件是不是加上i !=j比较好？还是说老师的意思是放在了swap方法里判断？","like_count":0},{"had_liked":false,"id":206561,"user_name":"Shine Sunner","can_delete":false,"product_type":"c1","uid":1334754,"ip_address":"","ucode":"8CCECE7F64C06B","user_header":"https://static001.geekbang.org/account/avatar/00/14/5d/e2/3331ad9e.jpg","comment_is_top":false,"comment_ctime":1586880278,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586880278","product_id":100017301,"comment_content":"快速排序<br>public class QuickSort {<br>\tpublic static void main(String[] args) {<br>\t\tint[] nums = new int[]{4,1,2,3,7,6,48,13,24};<br>\t\tquickSort(nums);<br>\t\tSystem.out.println(nums);<br>\t}<br>\t<br>\t&#47;&#47; 选取主元(中位数)<br>\tpublic static int middle3(int [] args,int left,int right) {<br>\t\tint center = (left + right)&#47;2;<br>\t\t<br>\t\t&#47;&#47; 左边的元素大于中间元素，两者进行交换<br>\t\tif (args[left] &gt; args[center]) {<br>\t\t\tint temp = args[left];<br>\t\t\targs[left] = args[center];<br>\t\t\targs[center] = temp;<br>\t\t}<br>\t\t<br>\t\t&#47;&#47; 左边的元素大于右边的元素，两者进行交换<br>\t\tif (args[left] &gt; args[right]) {<br>\t\t\tint temp = args[left];<br>\t\t\targs[left] = args[right];<br>\t\t\targs[right] = temp;<br>\t\t}<br>\t\t<br>\t\t&#47;&#47; 中间元素大于右边元素，两者进行交换<br>\t\tif (args[center] &gt; args[right]) {<br>\t\t\tint temp = args[center];<br>\t\t\targs[center] = args[right];<br>\t\t\targs[right] = temp;<br>\t\t}<br>\t\t&#47;&#47; 三次交换，确保a[left] &lt; a[center] &lt; a[right]<br>\t\t<br>\t\t&#47;&#47; 将中位数放置数组最右边前一个位置（因为数组最右边确定为最大的数）<br>\t\tint temp = args[center];<br>\t\targs[center] = args[right-1];<br>\t\targs[right-1] = temp;<br>\t\t&#47;&#47; 只需考虑a[left+1]...a[right-2]<br>\t\treturn args[right-1];<br>\t}<br>\t<br>\tpublic static void quickSort(int [] args) {<br>\t\tint len = args.length;<br>\t\tqSort(args, 0, len - 1);<br>\t}<br>\t<br>\tpublic static void qSort(int [] args,int left,int right) {<br>\t\t&#47;&#47; 即划分到只剩一个元素<br>\t\tif (left &gt;= right) {<br>            return;<br>        }<br>\t\t&#47;&#47; 选取主元<br>\t\tint pivot = middle3(args,left,right);<br>\t\tint i = left;<br>\t\tint j = right - 1;<br>\t\twhile (true) {<br>\t\t\t&#47;&#47; 比较左侧元素与主元大小，小于则继续，否则停下<br>\t\t\twhile (args[++i] &lt; pivot) {<br>\t\t\t\t<br>\t\t\t}<br>\t\t\t&#47;&#47; 比较右侧元素与主元大小，大于则继续，否则停下<br>\t\t\twhile (args[--j] &gt; pivot) {<br>\t\t\t\t<br>\t\t\t}<br>\t\t\t&#47;&#47; 左边指针小于右边指针才交换，否则说明遍历完成，则直接退出<br>\t\t\tif (i &lt; j) {<br>\t\t\t\t&#47;&#47; a[i],a[j]两者进行交换<br>\t\t\t\tint temp = args[i];<br>\t\t\t\targs[i] = args[j];<br>\t\t\t\targs[j] = temp;<br>\t\t\t}else{<br>\t\t\t\tbreak;<br>\t\t\t}<br>\t\t}<br>\t\t&#47;&#47; 将a[i],a[r-1]进行交换，即将主元位置固定<br>\t\tint temp = args[i];<br>\t\targs[i] = args[right - 1];<br>\t\targs[right - 1] = temp;<br>\t\t&#47;&#47; 递归调用左边<br>\t\tqSort(args,left,i - 1);<br>\t\t&#47;&#47; 递归调用右边<br>\t\tqSort(args,i + 1,right);<br>\t}<br>}<br>","like_count":0},{"had_liked":false,"id":206363,"user_name":"梅端","can_delete":false,"product_type":"c1","uid":1525335,"ip_address":"","ucode":"FEC08731457770","user_header":"https://static001.geekbang.org/account/avatar/00/17/46/57/fe38a6db.jpg","comment_is_top":false,"comment_ctime":1586847137,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586847137","product_id":100017301,"comment_content":"涉及到递归的排序算法的时间复杂度计算还是有些复杂，还需要多思考才行","like_count":0},{"had_liked":false,"id":204092,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586331567,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1586331567","product_id":100017301,"comment_content":"关于思考题：归并思想。","like_count":0},{"had_liked":false,"id":203636,"user_name":"201201177","can_delete":false,"product_type":"c1","uid":1901015,"ip_address":"","ucode":"8E2C0DB7A4D3D4","user_header":"","comment_is_top":false,"comment_ctime":1586244559,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1586244559","product_id":100017301,"comment_content":"快排的空间复杂度是多少，本课没有提","like_count":0,"discussions":[{"author":{"id":1073845,"avatar":"https://static001.geekbang.org/account/avatar/00/10/62/b5/4159fa05.jpg","nickname":"zhanyd","note":"","ucode":"4C994EE512A3C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":317258,"discussion_content":"O(1)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603521778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203580,"user_name":"KID","can_delete":false,"product_type":"c1","uid":1867938,"ip_address":"","ucode":"EE80B7CA7CC2A2","user_header":"https://static001.geekbang.org/account/avatar/00/1c/80/a2/96dcd1fa.jpg","comment_is_top":false,"comment_ctime":1586236037,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586236037","product_id":100017301,"comment_content":"1、用分治思想，把问题拆解成多个解决思路一样的小问题，即递归技巧<br>2、推导出小问题的递推公式<br>3、归并排序时间复杂度O(nlogn)，空间复杂度O(n)，因为需要合并子数组无法原地排序，因此占用内存过高。<br>4、快速排序为由上到下的，先分区，然后再处理子问题。<br>5、快排不是稳定排序的原地排序算法，时间复杂度O(nlogn)，最坏情况O(n²)","like_count":0},{"had_liked":false,"id":201973,"user_name":"喻茂","can_delete":false,"product_type":"c1","uid":1318661,"ip_address":"","ucode":"C8BD8086A17365","user_header":"https://static001.geekbang.org/account/avatar/00/14/1f/05/8a06692e.jpg","comment_is_top":false,"comment_ctime":1585883552,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585883552","product_id":100017301,"comment_content":"&lt;?php<br>&#47;&#47; 快速排序<br>function quick_sort(&amp;$arr) {<br>\t$n = count($arr);<br>\tquick_sort_c($arr, 0, $n-1);<br>}<br><br>&#47;&#47; 快速排序递归函数<br>function quick_sort_c(&amp;$arr,$p,$r) {<br>\tif ($p &gt;= $r) { &#47;&#47; 已经是最小粒度，递归结束<br>\t\treturn;<br>\t}<br>\t$q = partition($arr,$p,$r); <br>\tquick_sort_c($arr,$p,$q-1);<br>\tquick_sort_c($arr,$q+1,$r);<br>}<br><br><br>&#47;&#47; 选出分区点，把数据成比分区点小的，和比分区点大的 返回分区点<br>function partition(&amp;$arr,$p,$r) {<br>\t<br>\t&#47;&#47; 取最后一个元素进行分区<br>\t$pivot = $arr[$r];<br>\t$i = $p;<br>\tfor ($j=$p;$j&lt;=$r-1;$j++) {<br>\t\tif ($arr[$j] &lt; $pivot) {<br>\t\t\tif ($i != $j) {<br>\t\t\t\t&#47;&#47; 交换<br>\t\t\t\t$temp = $arr[$j];<br>\t\t\t\t$arr[$j] = $arr[$i];<br>\t\t\t\t$arr[$i] = $temp;<br>\t\t\t}<br>\t\t\t$i++;<br>\t\t}<br>\t}<br>\t$temp = $arr[$i];<br>\t$arr[$i] = $arr[$r];<br>\t$arr[$r] = $temp;<br>\treturn $i;<br>}<br><br>$testArr = [1,5,6,2,3,4];<br>quick_sort($testArr);<br><br>echo &#39;&lt;pre&gt;&#39;;<br>var_dump($testArr);","like_count":0},{"had_liked":false,"id":201951,"user_name":"喻茂","can_delete":false,"product_type":"c1","uid":1318661,"ip_address":"","ucode":"C8BD8086A17365","user_header":"https://static001.geekbang.org/account/avatar/00/14/1f/05/8a06692e.jpg","comment_is_top":false,"comment_ctime":1585881308,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585881308","product_id":100017301,"comment_content":"&lt;?php<br>&#47;&#47; 归并排序算法<br>function merge_sort(&amp;$arr) {<br>\t$n = count($arr);<br>\tmerge_sort_c($arr, 0, $n-1);<br>}<br><br>&#47;&#47; 递归调用函数<br>function merge_sort_c(&amp;$arr,$p,$r) {<br>\tif ($p &gt;= $r) { &#47;&#47; 已经是最小粒度，递归结束<br>\t\treturn;<br>\t}<br>\t<br>\t&#47;&#47; 取$p到$r之间的中间位置$q<br>\t$q = intval(($p + $r) &#47; 2);<br>\t<br>\t&#47;&#47; 递归处理左右数据<br>\tmerge_sort_c($arr,$p,$q);<br>\tmerge_sort_c($arr,$q+1,$r);<br>\tmerge($arr,$p,$q,$q+1,$r);<br>\t<br>}<br><br>function merge(&amp;$arr,$leftS,$leftE,$rightS,$rightE) {<br>\t$tmpArr = [];<br>\t$i = $leftS;<br>\t$j = $rightS;<br>\t<br>\twhile($i&lt;=$leftE &amp;&amp; $j&lt;=$rightE) {<br>\t\tif ($arr[$i] &lt;= $arr[$j]) {<br>\t\t\t$tmpArr[] = $arr[$i];<br>\t\t\t$i++;<br>\t\t} else {<br>\t\t\t$tmpArr[] = $arr[$j];<br>\t\t\t$j++;<br>\t\t}<br>\t}<br>\t<br>\t&#47;&#47; 哪个子数组中有数据剩余直接追加到最后<br>\tfor(;$i&lt;=$leftE;$i++) {<br>\t\t$tmpArr[] = $arr[$i];<br>\t}<br>\t<br>\tfor(;$j&lt;=$rightE;$j++) {<br>\t\t$tmpArr[] = $arr[$j];<br>\t}<br><br>\t&#47;&#47; 临时表中数据写回到原数组<br>\tforeach($tmpArr as $key =&gt; $val) {<br>\t\t$arr[$leftS+$key] = $val;<br>\t}<br>}<br><br>$testArr = [1,5,6,2,3,4];<br>merge_sort($testArr);<br><br>echo &#39;&lt;pre&gt;&#39;;<br>var_dump($testArr);<br>","like_count":0},{"had_liked":false,"id":200667,"user_name":"蜗牛","can_delete":false,"product_type":"c1","uid":1086220,"ip_address":"","ucode":"01CC18F12E556D","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/0c/0a6a0d5e.jpg","comment_is_top":false,"comment_ctime":1585632748,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585632748","product_id":100017301,"comment_content":"10个日志文件，每个300MB，如果再1G内存上要排序好，首先第一个想到的就是限制条件为：原地排序。<br>然后因为数据量比较大，所以可以选择快速排序。","like_count":0},{"had_liked":false,"id":199450,"user_name":"ZMH.","can_delete":false,"product_type":"c1","uid":1753115,"ip_address":"","ucode":"D45D6CEDFDF8F5","user_header":"https://static001.geekbang.org/account/avatar/00/1a/c0/1b/319baf9d.jpg","comment_is_top":false,"comment_ctime":1585489465,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585489465","product_id":100017301,"comment_content":"思想基本理解了,可是代码写不出来..看网上的代码很吃力,debug走走就迷糊了😭😭😭","like_count":0},{"had_liked":false,"id":198141,"user_name":"柳晓峰","can_delete":false,"product_type":"c1","uid":1104217,"ip_address":"","ucode":"F148C6C0957CF5","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/59/54692189.jpg","comment_is_top":false,"comment_ctime":1585411768,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585411768","product_id":100017301,"comment_content":"课后思考：1.建立一个长度为10的数组，从10个日志文件分别读入一条日志插入到数组中，时间复杂度O(10),空间负责度O(10)。2.采用快速排序法，找到Top1，插入到合并后的日志文件，单次排序时间复杂度为O(log10),。3.从Top1的所属的日志中继续读取1条数据。4.重复2，3步骤（n-9)次。总结：总的时间复杂度为O((n-9)*log10)+O(9)=O(n),总的空间负责度为O(10)=O(1)。","like_count":0},{"had_liked":false,"id":197679,"user_name":"Eleven","can_delete":false,"product_type":"c1","uid":1168452,"ip_address":"","ucode":"FB4A0C8CA732BE","user_header":"https://static001.geekbang.org/account/avatar/00/11/d4/44/0ec958f4.jpg","comment_is_top":false,"comment_ctime":1585391525,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585391525","product_id":100017301,"comment_content":"老师，你好<br>通过这样一步一步分解推导，我们可以得到 T(n) = 2^kT(n&#47;2^k)+kn。当 T(n&#47;2^k)=T(1) 时，也就是 n&#47;2^k=1，我们得到 k=log2n 。我们将 k 值代入上面的公式，得到 T(n)=Cn+nlog2n 。这里的Cn是怎么推到出来的呢？","like_count":0},{"had_liked":false,"id":197622,"user_name":"热爱coding的稻草","can_delete":false,"product_type":"c1","uid":1568020,"ip_address":"","ucode":"E76AFCFCA83143","user_header":"https://static001.geekbang.org/account/avatar/00/17/ed/14/0229d541.jpg","comment_is_top":false,"comment_ctime":1585388451,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585388451","product_id":100017301,"comment_content":"partition 伪代码中，j := p + 1 才对，不然 i, j 都从 p 开始存在无效交换；","like_count":0},{"had_liked":false,"id":195778,"user_name":"hong4cong","can_delete":false,"product_type":"c1","uid":1015829,"ip_address":"","ucode":"2BBD851272B9BF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/15/c4f5dd00.jpg","comment_is_top":false,"comment_ctime":1585215165,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585215165","product_id":100017301,"comment_content":"java代码写出来好些","like_count":0},{"had_liked":false,"id":193963,"user_name":"年轻人","can_delete":false,"product_type":"c1","uid":1210519,"ip_address":"","ucode":"CDD4612BAE3247","user_header":"https://static001.geekbang.org/account/avatar/00/12/78/97/fa101174.jpg","comment_is_top":false,"comment_ctime":1585008486,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585008486","product_id":100017301,"comment_content":"查找第K大的数，最坏情况下，如果数组刚好是逆序的，每次选择 pivot 为最后一个，查找第 N&#47;2 大的数，时间复杂度是 O(n^2)了吧。","like_count":0},{"had_liked":false,"id":193759,"user_name":"gyz147","can_delete":false,"product_type":"c1","uid":1908315,"ip_address":"","ucode":"6886EC89BE963C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep9W6iaibfWRcm3rHiaDMAhdywVXPQWR3cR4KZ6N9Ux0AYKTZGBsJdIAl0fMWgIHwiaVXzu5CP7CkiauRA/132","comment_is_top":false,"comment_ctime":1584958678,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584958678","product_id":100017301,"comment_content":"为什么网上对快排的空间复杂度说法不一致，递归函数栈需要O(logN)的空间复杂度，那么快排的空间复杂度是不是应该也是O(logN)呢","like_count":0},{"had_liked":false,"id":191579,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1584783080,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584783080","product_id":100017301,"comment_content":"老师啊，像i j k p q r这种命名可不可以换一下，看起来太累了，有股在看谭浩强的书的感觉，有的时候想不通看不明白，就会读不下去，真的是懵逼的感觉。","like_count":0},{"had_liked":false,"id":191182,"user_name":"雨落千木的时节","can_delete":false,"product_type":"c1","uid":1796430,"ip_address":"","ucode":"A268063299F0D6","user_header":"https://static001.geekbang.org/account/avatar/00/1b/69/4e/7ef7604b.jpg","comment_is_top":false,"comment_ctime":1584752824,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584752824","product_id":100017301,"comment_content":"快排，挖坑填数的思想","like_count":0},{"had_liked":false,"id":190090,"user_name":"黄昏鹿场","can_delete":false,"product_type":"c1","uid":1269801,"ip_address":"","ucode":"BC331B34E878CE","user_header":"https://static001.geekbang.org/account/avatar/00/13/60/29/4564caba.jpg","comment_is_top":false,"comment_ctime":1584601607,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584601607","product_id":100017301,"comment_content":"😀","like_count":0},{"had_liked":false,"id":189383,"user_name":"柳叶刀","can_delete":false,"product_type":"c1","uid":1494819,"ip_address":"","ucode":"5881B9ACA2200E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJjiaeDudnGOBT2Sze5jYvX52tM1QHE2LAYsAMDMIGGna2xSonCDjnpictsdT1Ye2gGGic71HzHTl4Kw/132","comment_is_top":false,"comment_ctime":1584508745,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584508745","product_id":100017301,"comment_content":"&#47;**<br> * merge sort (stable)<br> * worst: O(nlogn)<br> * best: O(nlogn)<br> * average: O(nlogn)<br> * space: O(n)<br> * @param a array tobe sorted<br> * @param n length of array<br> *&#47;<br>void merge_sort(int a[], int start, int end)<br>{<br>    if (start &lt; end) {<br>        int middle = (start + end) &#47; 2;<br>        merge_sort(a, start, middle);<br>        merge_sort(a, middle + 1, end);<br><br>        merge(a, start, middle, end);<br>    }<br>}<br><br><br>&#47;**<br> * 合并有序子序列<br> * @param a <br> * @param start <br> * @param middle <br> * @param end <br> *&#47;<br>void merge(int a[], int start, int middle, int end)<br>{<br>    int len_left = middle - start + 1;<br>    int len_right = end - middle;<br><br>    int temp_left[len_left], temp_right[len_right];<br>    memcpy(temp_left, a + start, sizeof(int) * len_left);<br>    memcpy(temp_right, a + middle + 1, sizeof(int) * len_right);<br><br>    int i = 0, j = 0, index = start;<br><br>    while (i &lt; len_left &amp;&amp; j &lt; len_right) {<br>        if (temp_left[i] &lt; temp_right[j]) {<br>            a[index++] = temp_left[i++];<br>        }else {<br>            a[index++] = temp_right[j++];<br>        }<br>    }<br><br>    while (i &lt; len_left) {<br>        a[index++] = temp_left[i++];<br>    }<br><br>}","like_count":0},{"had_liked":false,"id":188916,"user_name":"isaac","can_delete":false,"product_type":"c1","uid":1151854,"ip_address":"","ucode":"62ACA5B9A44D1D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/THkFNC52F0kYs2XI1fwxOvCck0Pibwnia4z6fzCPMRg2qYQLlt57qW4caJZ6uj9lWROc7t1OHFmIdKmiaEIP2GXpg/132","comment_is_top":false,"comment_ctime":1584433975,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584433975","product_id":100017301,"comment_content":"想了想，有人说归并排序时的哨兵值随意，但是其实对哨兵的值是有要求，不能是待排序数组中的任何一个值，否则合并的时候就会替换原数组中的数据，从这点看是不是不用哨兵会比较好","like_count":0},{"had_liked":false,"id":188875,"user_name":"问心","can_delete":false,"product_type":"c1","uid":1250775,"ip_address":"","ucode":"6808568D61CE36","user_header":"https://static001.geekbang.org/account/avatar/00/13/15/d7/96e77edd.jpg","comment_is_top":false,"comment_ctime":1584429062,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584429062","product_id":100017301,"comment_content":"第一步应该是确认10个日志文件中的起始时间是否相差太多，如果相关不多的话，每个文件直接取100M，使用时间戳，用快排排序约前1&#47;10数据，把前1&#47;10写入文件，根据每个日志写入的数据量，从对应日志里读取数据，再继续排序、写入。所有文件全部读取完成后，一次快排，全部写入。","like_count":0},{"had_liked":false,"id":187896,"user_name":"空山","can_delete":false,"product_type":"c1","uid":1171401,"ip_address":"","ucode":"B75841573665B9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/L9VVrMFqrzeT5bsQ7CYZdckDSN5mSPt7jibUrVib4J1JERTr5EyOsgmAZMDtJfehSow83N79B3Dqd495GbiaibQCSw/132","comment_is_top":false,"comment_ctime":1584269768,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584269768","product_id":100017301,"comment_content":"归并排序中有个时间复杂度的问题不是很理解。“我们将 k 值代入上面的公式，得到 T(n)=Cn+nlog2n”。想问下这里的C是从哪里来的，带入后得到T(n)=n+T(1)+n*log2n<br><br>T(1)为常数，不计入复杂度。时间复杂度复杂度应该表达为n+nlog2n","like_count":0},{"had_liked":false,"id":187755,"user_name":"鹤鹤有名","can_delete":false,"product_type":"c1","uid":1773191,"ip_address":"","ucode":"327311F22F3C30","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJB3er54ghicIaqklUYabqtsibuMjlvyrUq2GPVke1Loth8PV5tMDbahjbIqeHZYrPzWNaia0juOUmMw/132","comment_is_top":false,"comment_ctime":1584228407,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584228407","product_id":100017301,"comment_content":"      2^k * T(n&#47;2^k) + k * n  这块为什么要让 T(n&#47;2^k)=T(1)呢？<br> 我的理解，时间复杂度最终目的就是计算在一定的数据量的前提下本段代码的的执行次数。当数据为n的时候， 2^k * T(n&#47;2^k) + k * n  的值即为整体的执行次数。当执行到最后一次的时候也就是不能继续再往下执行的时候应该是数组里面元素个数为1的时候，即T(n&#47;2^k)不能再往下继续再分解了为T(1)的时候。此时得到的t（n）即为最终的时间复杂度。","like_count":0},{"had_liked":false,"id":187713,"user_name":"波风皆人","can_delete":false,"product_type":"c1","uid":1015951,"ip_address":"","ucode":"BA2D163A88C4A3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/8f/d8c2a82a.jpg","comment_is_top":false,"comment_ctime":1584197147,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584197147","product_id":100017301,"comment_content":"归并排序时间复杂度分析：归并的每一层合并数据的时间复杂度都是O(n)，而归并分层的总高度是logn，按照乘法规则，归并排序的时间复杂度就是O(nlogn)","like_count":0},{"had_liked":false,"id":187467,"user_name":"JYP","can_delete":false,"product_type":"c1","uid":1070592,"ip_address":"","ucode":"7A8056F91BF39B","user_header":"https://static001.geekbang.org/account/avatar/00/10/56/00/511f238e.jpg","comment_is_top":false,"comment_ctime":1584116719,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584116719","product_id":100017301,"comment_content":"github上寻找第K大元素代码有误，已在issues里贴代码了，感谢大佬精彩的分享","like_count":0},{"had_liked":false,"id":186482,"user_name":"小菠萝🍍","can_delete":false,"product_type":"c1","uid":1686410,"ip_address":"","ucode":"DA814203C6C062","user_header":"https://static001.geekbang.org/account/avatar/00/19/bb/8a/d33d9d3f.jpg","comment_is_top":false,"comment_ctime":1583851823,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583851823","product_id":100017301,"comment_content":"我从来没如此激动过，我居然自己写出快速排序了！<br>import java.util.Arrays;<br><br>&#47;**<br> * @author Zeng<br> * @date 2020&#47;3&#47;10 22:37<br> *&#47;<br>public class 快速排序2 {<br><br>    public static void swap(int[] arr, int i, int j){<br>        int temp = arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = temp;<br>    }<br><br>    public static void quickSort(int[] arr, int begin, int end){<br>        if(begin &gt;= end){<br>            return ;<br>        }<br>        int i = begin;<br>        int j = begin;<br>        while (j &lt; end){<br>            if(arr[j] &lt; arr[end]){<br>                swap(arr, i, j);<br>                i++;<br>            }<br>            j++;<br>        }<br>        swap(arr, i, end);<br>        quickSort(arr, 0, i-1);<br>        quickSort(arr, i, end);<br>    }<br>    <br>    public static void main(String[] args) {<br>        int[] arr = {6, 11, 3, 9, 8, -2, 213, 23554, 2312};<br>        quickSort(arr, 0, arr.length - 1);<br>        System.out.println(Arrays.toString(arr));<br>    }<br>    <br>}","like_count":0},{"had_liked":false,"id":186390,"user_name":"TchaikovskyBear","can_delete":false,"product_type":"c1","uid":1897169,"ip_address":"","ucode":"7EAAD3F9E0A69F","user_header":"","comment_is_top":false,"comment_ctime":1583834042,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583834042","product_id":100017301,"comment_content":"关于在一组数据中寻找第k大的元素，假设有这样一组数据[1,2,3,4,5,6],n=6,找第1大(k=1)的元素，用快排的话时间复杂度不应该是第一次迭代对6个元素分组为[1,2,3,4,5],[6],第二次迭代分组为[1,2,3,4],[5]以此类推时间复杂度是1~n的等差数列即(1+n)*n&#47;2，时间复杂度不应该是O(n^2)吗？","like_count":0},{"had_liked":false,"id":186054,"user_name":"赤云","can_delete":false,"product_type":"c1","uid":1093258,"ip_address":"","ucode":"67476D582D8B6A","user_header":"https://static001.geekbang.org/account/avatar/00/10/ae/8a/e67def95.jpg","comment_is_top":false,"comment_ctime":1583746843,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583746843","product_id":100017301,"comment_content":"public class MergeSort {<br>    public static void main(String[] args) {<br>        int[] arr = {9, 8, 7, 6, 5, 4, 3, 2, 1, 9, 22};<br>        sort(arr);<br>        System.out.println(Arrays.toString(arr));<br>    }<br><br>    public static void sort(int[] arr) {<br>        int[] temp = new int[arr.length];&#47;&#47;在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间<br>        sort(arr, 0, arr.length - 1, temp);<br>    }<br><br>    private static void sort(int[] arr, int left, int right, int[] temp) {<br>        if (left &lt; right) {<br>            int mid = (left + right) &#47; 2;<br>            sort(arr, left, mid, temp);&#47;&#47;左边归并排序，使得左子序列有序<br>            sort(arr, mid + 1, right, temp);&#47;&#47;右边归并排序，使得右子序列有序<br>            merge(arr, left, mid, right, temp);&#47;&#47;将两个有序子数组合并操作<br>        }<br>    }<br><br>    private static void merge(int[] arr, int left, int mid, int right, int[] temp) {<br>        System.out.println(&quot;left：&quot; + left + &quot;   right：&quot; + right + &quot;   mid：&quot; + mid);<br>        int i = left;&#47;&#47;左序列指针<br>        int j = mid + 1;&#47;&#47;右序列指针<br>        int t = 0;&#47;&#47;临时数组指针<br>        while (i &lt;= mid &amp;&amp; j &lt;= right) {<br>            if (arr[i] &lt;= arr[j]) {<br>                temp[t++] = arr[i++];<br>            } else {<br>                temp[t++] = arr[j++];<br>            }<br>        }<br>        while (i &lt;= mid) {&#47;&#47;将左边剩余元素填充进temp中<br>            temp[t++] = arr[i++];<br>        }<br>        while (j &lt;= right) {&#47;&#47;将右序列剩余元素填充进temp中<br>            temp[t++] = arr[j++];<br>        }<br>        t = 0;<br>        &#47;&#47;将temp中的元素全部拷贝到原数组中<br>        while (left &lt;= right) {<br>            arr[left++] = temp[t++];<br>        }<br>    }<br>}","like_count":0},{"had_liked":false,"id":185971,"user_name":"你出剪刀我出布","can_delete":false,"product_type":"c1","uid":1479070,"ip_address":"","ucode":"8BA92717CA2E1B","user_header":"https://static001.geekbang.org/account/avatar/00/16/91/9e/30d2f969.jpg","comment_is_top":false,"comment_ctime":1583735169,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583735169","product_id":100017301,"comment_content":"不知道我这个想法是不是对的 希望老师帮忙看看  谢谢 归并递归时间复杂度是log(n) merge 部分时间复杂度是O(n） 所以总的是O(nlog(n)); 希望帮忙看看 谢谢","like_count":0},{"had_liked":false,"id":184786,"user_name":"shelldon","can_delete":false,"product_type":"c1","uid":1054598,"ip_address":"","ucode":"BF8FE102D6DD1B","user_header":"https://static001.geekbang.org/account/avatar/00/10/17/86/416f772e.jpg","comment_is_top":false,"comment_ctime":1583403491,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583403491","product_id":100017301,"comment_content":"- 用小顶堆求第 K 大元素的时间复杂度是 O(nlogK)<br>- 用选择 K 次最小值求第 K 大元素的时间复杂度是 O(nK)<br>- 用分区、分治的思想求第 K 大元素的时间复杂度是 O(n)","like_count":0},{"had_liked":false,"id":184777,"user_name":"小和尚笨南北","can_delete":false,"product_type":"c1","uid":1204628,"ip_address":"","ucode":"17C9BBB6DD25D2","user_header":"https://static001.geekbang.org/account/avatar/00/12/61/94/713b38ef.jpg","comment_is_top":false,"comment_ctime":1583399446,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583399446","product_id":100017301,"comment_content":"一点疑问，快速排序在每次排序以后，将分界元素和未处理区间交换的意义是什么？","like_count":0},{"had_liked":false,"id":184751,"user_name":"shelldon","can_delete":false,"product_type":"c1","uid":1054598,"ip_address":"","ucode":"BF8FE102D6DD1B","user_header":"https://static001.geekbang.org/account/avatar/00/10/17/86/416f772e.jpg","comment_is_top":false,"comment_ctime":1583395924,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583395924","product_id":100017301,"comment_content":"看到了 pascal 的影子","like_count":0},{"had_liked":false,"id":184714,"user_name":"bc","can_delete":false,"product_type":"c1","uid":1009801,"ip_address":"","ucode":"3899698EA715EC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/68/89/173601c5.jpg","comment_is_top":false,"comment_ctime":1583390202,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583390202","product_id":100017301,"comment_content":"第K大的例子没有包含重复的元素，比如，4，5，6，3，1，1，第3大应该是4，而不是指从小到大排列的第3个元素3吧？所以按照“如果 p+1=K，那 A[p]就是要求解的元素”是求不出4的","like_count":0},{"had_liked":false,"id":184374,"user_name":"椰子船长","can_delete":false,"product_type":"c1","uid":1035226,"ip_address":"","ucode":"36A9BD5F312028","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/da/79080738.jpg","comment_is_top":false,"comment_ctime":1583302640,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583302640","product_id":100017301,"comment_content":"<br>partition(A, p, r) {<br>  pivot := A[r]<br>  i := p<br>  for j := p to r-1 do {<br>    if A[j] &lt; pivot {<br>      swap A[i] with A[j]<br>      i := i+1<br>    }<br>  }<br>  swap A[i] with A[r]<br>  return i<br><br>我觉得这段代码最后的swap调用有问题。加入数据是1，2，3<br>pivot的是3，for循环结束时，i和j的索引是1，如果再进行swap，那交换后变成了1，3，2","like_count":0},{"had_liked":false,"id":184344,"user_name":"JT","can_delete":false,"product_type":"c1","uid":1251901,"ip_address":"","ucode":"FEF75DEAB0603A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/SiciaNKibn60SjA50TsTEtO0icj7s0sibNRRx5gsUnVvTnAuibh5mWcbiczASxBLsDfKfgIYPX5qv1Em3boF0eWcuKGJg/132","comment_is_top":false,"comment_ctime":1583294229,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583294229","product_id":100017301,"comment_content":"有个疑问，开篇的问题，当K&gt;p+1的时候，要查找的元素在右区间的话。这个K应该要变化成K=K-（p+1）吧？不然递归找的就是子区间的第K大元素，而不是整个数组的第K大元素了？","like_count":0},{"had_liked":false,"id":184125,"user_name":"jyzhang","can_delete":false,"product_type":"c1","uid":1624016,"ip_address":"","ucode":"1311666BD87B86","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLOWucpCLACCYJic5IicKuo9RVSoFsEId2sazOqhnvSUSFztH8vu8skYkIwxgkXpOqmHjTprFWF1GmA/132","comment_is_top":false,"comment_ctime":1583229035,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583229035","product_id":100017301,"comment_content":"网上看到一个blog，研究js中sort排序的底层实现算法，blog里是这么写的：<br><br>各个浏览器的实现方式会有不同。火狐中使用的是归并排序， Chrome的sort排序使用的是插入排序和快速排序结合的排序算法。数组长度不超过10时，使用插入排序。长度超过10使用快速排序。在数组较短时插入排序更有效率。<br><br>跟老师求证一下“在数组较短时插入排序更有效率”这种说法","like_count":0},{"had_liked":false,"id":182758,"user_name":"肖大妞","can_delete":false,"product_type":"c1","uid":1426644,"ip_address":"","ucode":"2AD2F8684FDCF8","user_header":"https://static001.geekbang.org/account/avatar/00/15/c4/d4/5c8fb1cb.jpg","comment_is_top":false,"comment_ctime":1582860812,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582860812","product_id":100017301,"comment_content":"保存十个指针同时指向十个文件的开头，并把这是个文件的开头做个小顶堆，每次取出堆顶，写入目标文件，然后取出文件的下一行，调整堆，直到所有文件的内容都被遍历完成。","like_count":0},{"had_liked":false,"id":182454,"user_name":"Simple life","can_delete":false,"product_type":"c1","uid":1571460,"ip_address":"","ucode":"1902D7F72FB43F","user_header":"https://static001.geekbang.org/account/avatar/00/17/fa/84/f01d203a.jpg","comment_is_top":false,"comment_ctime":1582790235,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582790235","product_id":100017301,"comment_content":"老师，有两个问题请教一下，<br>第一是归并排序的时间复杂度推导，2^k * T(n&#47;2^k) + k * n，为什么最后当T(n&#47;2^k)=T(1) 时，也就是 n&#47;2^k=1，我们得到k=log2n。将k带入上面的公式就得到T(n)=Cn+nlog2n。<br>这里为什么是Cn，C我知道是T(1)时的常量执行时间，但是为什么时C乘以n呢？应该是2^k*C才对，应该是2^log2n*C才对，最后应该是(2^log2n)*c+n*log2才是吧<br><br>第二，归并排序合并算法还可以是插入排序，这样就是转化成原地排序了，空间复杂度就变成了O(1)，但是时间复杂度却上升了，这样做是没意义了吧？<br>","like_count":0},{"had_liked":false,"id":180941,"user_name":"盘胧","can_delete":false,"product_type":"c1","uid":1650748,"ip_address":"","ucode":"5386CC4C92ECC2","user_header":"https://static001.geekbang.org/account/avatar/00/19/30/3c/0668d6ae.jpg","comment_is_top":false,"comment_ctime":1582447269,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582447269","product_id":100017301,"comment_content":"尽量做到，有思路，就要能撸出代码","like_count":0},{"had_liked":false,"id":180785,"user_name":"斐波那契","can_delete":false,"product_type":"c1","uid":1464006,"ip_address":"","ucode":"85E2EBC01392B1","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/c6/0b449bc6.jpg","comment_is_top":false,"comment_ctime":1582386684,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582386684","product_id":100017301,"comment_content":"对于课后思考题 想到一个类似‘败者树’的解决思路 而且这个题老师给了内存大小和文件大小 应该是想我们充分利用内存来 我的思路大概是这样: (假设内存只用作排序操作使用 不考虑操作系统等其他开销) 首先10个文件用10个线程去读取 读取大约80MB大小的数据(里面都是一条条日志) 把数据读到缓冲区里 然后然后通过“生产者-消费者&quot;队列把10个缓冲区里每次读一条日志出来通过败者树来比较出最小时间戳日志放到新缓冲区 每次这个新缓冲区达到200MB时就写入到磁盘 然后继续执行上述过程 其中10个缓冲区队列每读出一个数据那10个文件线程就可以读一些数据放进那个10个缓冲队列里 这样10个缓冲区就是10*80=800MB在加上200MB新缓冲区=1000MB差不多就是1G左右","like_count":0},{"had_liked":false,"id":179770,"user_name":"melo","can_delete":false,"product_type":"c1","uid":1030449,"ip_address":"","ucode":"BF381B18E75867","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b9/31/636e9007.jpg","comment_is_top":false,"comment_ctime":1582094702,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582094702","product_id":100017301,"comment_content":"高手就是高手，写完就知道快排交换数据时为啥是a[i++]=a[j]了， 太tricky了","like_count":0},{"had_liked":false,"id":179126,"user_name":"无邪丶","can_delete":false,"product_type":"c1","uid":1068302,"ip_address":"","ucode":"D3140A046327C0","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/0e/480f56e4.jpg","comment_is_top":false,"comment_ctime":1581923717,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581923717","product_id":100017301,"comment_content":"请问下快排里的if (i == j)起到的是什么作用","like_count":0},{"had_liked":false,"id":179012,"user_name":"wd。","can_delete":false,"product_type":"c1","uid":1846105,"ip_address":"","ucode":"6CD6178C78701C","user_header":"https://static001.geekbang.org/account/avatar/00/1c/2b/59/1ab059af.jpg","comment_is_top":false,"comment_ctime":1581872706,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581872706","product_id":100017301,"comment_content":"golang的快排代码，在github上写的有问题<br><br>\t&#47;&#47; 选取最后一位当对比数字<br>\tpivot := arr[end]<br><br>\tvar i = start<br>\tfor j := 0; j &lt; end; j++ {   &#47;&#47; 初始值为0会报错<br>\t\tif arr[j] &lt; pivot {<br>\t\t\tif !(i == j) {<br>\t\t\t\t&#47;&#47; 交换位置<br>\t\t\t\tarr[i], arr[j] = arr[j], arr[i]<br>\t\t\t}<br>\t\t\ti++<br>\t\t}<br>\t}<br><br>\tarr[i], arr[end] = arr[end], arr[i]<br><br>\treturn i<br>}","like_count":0},{"had_liked":false,"id":178824,"user_name":"一只独立特行的猪","can_delete":false,"product_type":"c1","uid":1473358,"ip_address":"","ucode":"52263607CCBE6F","user_header":"https://static001.geekbang.org/account/avatar/00/16/7b/4e/73a9deec.jpg","comment_is_top":false,"comment_ctime":1581836821,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581836821","product_id":100017301,"comment_content":"看了老师git上面的代码，发现快排还有很多其他的写法，这些写法需要掌握吗？","like_count":0},{"had_liked":false,"id":178622,"user_name":"我","can_delete":false,"product_type":"c1","uid":1844996,"ip_address":"","ucode":"99C7A165C1294D","user_header":"https://static001.geekbang.org/account/avatar/00/1c/27/04/fa81fd40.jpg","comment_is_top":false,"comment_ctime":1581760660,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581760660","product_id":100017301,"comment_content":"面试时，一般是让写伪代码还是实际代码<br>","like_count":0},{"had_liked":false,"id":178448,"user_name":"进击的小明","can_delete":false,"product_type":"c1","uid":1737846,"ip_address":"","ucode":"7C9A774C504177","user_header":"https://static001.geekbang.org/account/avatar/00/1a/84/76/6091523d.jpg","comment_is_top":false,"comment_ctime":1581691060,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581691060","product_id":100017301,"comment_content":"终于明白了这O（nLogn）是怎么算的了！","like_count":0},{"had_liked":false,"id":176701,"user_name":"谢真","can_delete":false,"product_type":"c1","uid":1124650,"ip_address":"","ucode":"8C3402DE107C9F","user_header":"https://static001.geekbang.org/account/avatar/00/11/29/2a/9079f152.jpg","comment_is_top":false,"comment_ctime":1581143368,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581143368","product_id":100017301,"comment_content":"学习了，以前用的真的太少了","like_count":0},{"had_liked":false,"id":176567,"user_name":"endif","can_delete":false,"product_type":"c1","uid":1504562,"ip_address":"","ucode":"CA15D1BB5B2B51","user_header":"https://static001.geekbang.org/account/avatar/00/16/f5/32/07f06f0a.jpg","comment_is_top":false,"comment_ctime":1581088475,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581088475","product_id":100017301,"comment_content":"对于链表排序，归并排序可以是原地排序","like_count":0},{"had_liked":false,"id":174765,"user_name":"楼下小黑哥","can_delete":false,"product_type":"c1","uid":1014680,"ip_address":"","ucode":"453B099B0EE52E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/98/8f1aecf4.jpg","comment_is_top":false,"comment_ctime":1580375407,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580375407","product_id":100017301,"comment_content":"根据快排提示图，画了一个动图，希望对大伙有帮助。贴一个链接：<br><br>https:&#47;&#47;tva1.sinaimg.cn&#47;large&#47;006tNbRwly1gbeoudrayig312e0mw4gs.gif","like_count":0},{"had_liked":false,"id":174666,"user_name":"groot888","can_delete":false,"product_type":"c1","uid":1266597,"ip_address":"","ucode":"50E50681D6BE0C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/oseia6IjJIPziamTI2EQ0Bpr8icUicXTea2UuH105t4Bia4yFwBHld49cIQbjORvDdTtMCVdL39H9WxFwzyXspqqHUg/132","comment_is_top":false,"comment_ctime":1580313883,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580313883","product_id":100017301,"comment_content":"两个疑问：<br>1:没说快拍的空间复杂度呢，是不是也是n？那为啥大家要选快排而不是归并。<br>2:快排是不是也是原地排序啊？","like_count":0},{"had_liked":false,"id":174583,"user_name":"Geek_deb968","can_delete":false,"product_type":"c1","uid":1440025,"ip_address":"","ucode":"2305597B009AF3","user_header":"https://static001.geekbang.org/account/avatar/00/15/f9/19/7c3b12ee.jpg","comment_is_top":false,"comment_ctime":1580286012,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1580286012","product_id":100017301,"comment_content":"快排图示以8为pivot最后一次将pivot与ｉ下标互换后，9，11为什么换位置了","like_count":0},{"had_liked":false,"id":172802,"user_name":"Anthony","can_delete":false,"product_type":"c1","uid":1309908,"ip_address":"","ucode":"9E0C98A9123365","user_header":"https://static001.geekbang.org/account/avatar/00/13/fc/d4/743d3f02.jpg","comment_is_top":false,"comment_ctime":1579316179,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579316179","product_id":100017301,"comment_content":"可以先每3个文件合并，另一个分三份，每一份写到另外3个文件中，3个文件利用快排排序，这样这三个文件就是有序的了，然后从这三个文件中，每次每个文件比如说取1000条，然后3000条排序，取排序的前1000条，以此类推，应该就可以充分的利用内存","like_count":0},{"had_liked":false,"id":172441,"user_name":"return","can_delete":false,"product_type":"c1","uid":1135528,"ip_address":"","ucode":"42B8A3380DF04B","user_header":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","comment_is_top":false,"comment_ctime":1579177224,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579177224","product_id":100017301,"comment_content":"关于思考题 我感觉应该用到每个日志 的有序性。<br>可以每次取 是个日志同一时间段前的n条日志，要预估好，保证小于500m，然后多指针技巧合并。写入新文件。<br>重复以上步骤。","like_count":0},{"had_liked":false,"id":171679,"user_name":"~记得微笑∩﹏∩","can_delete":false,"product_type":"c1","uid":1216715,"ip_address":"","ucode":"EBC383F0FB54BE","user_header":"https://static001.geekbang.org/account/avatar/00/12/90/cb/72063354.jpg","comment_is_top":false,"comment_ctime":1578990514,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578990514","product_id":100017301,"comment_content":"您好，我想请问一下怎么能确定递归终止条件呢，递推公式基本可以推出来，但是终止条件我有时候就推不出来。","like_count":0},{"had_liked":false,"id":171003,"user_name":"Vicent🍀","can_delete":false,"product_type":"c1","uid":1589894,"ip_address":"","ucode":"70AEA72A0B6F0E","user_header":"https://static001.geekbang.org/account/avatar/00/18/42/86/6b2e81ba.jpg","comment_is_top":false,"comment_ctime":1578817422,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578817422","product_id":100017301,"comment_content":"关于merge sort的优化，看其他答案是进入merge时，先生成两个数组切后面各追加一个最大值，之后进行比较，就可以用补充剩余没有比较的数。从代码上，确实是减少了每次比较时候的边界判断，但是生成两个数组，相对于比较数据多进行了一次copy。需要的空间会更过。我这里想到的一个优化时，当if (a[i]&lt;=a[j]){ 比较完还有剩余没有比较的区间数组时，此时记录位置。让后不进行temp的数据填充，直接去操作源数据，应为剩下的数据肯定是最大的那一段数据，所以，直接获取放到最后不会覆盖temp没有的数据，最相近的情况就是，直接自己覆盖到自己的位置。<br>  private static void merge2(int[] a,int p, int q, int r){<br>        &#47;&#47; use temp array save sorted data<br>        int[] temp = new int[r-p+1];<br><br>        int i = p, j = q+1, k = 0;<br><br>        &#47;&#47; merge two array<br>        while (i &lt;= q &amp;&amp; j &lt;= r){<br>            if (a[i]&lt;=a[j]){<br>                temp[k++] = a[i++];<br>            }else {<br>                temp[k++] = a[j++];<br>            }<br>        }<br>        int start = i ,end = q;<br>        if (j&lt;=r) {<br>            start = j;<br>            end=r;<br>        }<br>        int length = end-start;<br><br>        &#47;&#47; set max array<br>        for (;start&lt;=end;start++){<br>            a[r-length] = a[start];<br>        }<br><br>        &#47;&#47; copy<br>        for (int x = p,  t = 0; x &lt;= (r-length) ; x++) {<br>            a[x] = temp[t++];<br>        }<br><br>    }","like_count":0},{"had_liked":false,"id":170989,"user_name":"Vicent🍀","can_delete":false,"product_type":"c1","uid":1589894,"ip_address":"","ucode":"70AEA72A0B6F0E","user_header":"https://static001.geekbang.org/account/avatar/00/18/42/86/6b2e81ba.jpg","comment_is_top":false,"comment_ctime":1578813693,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578813693","product_id":100017301,"comment_content":"关于在mergeSort中的merge使用哨兵进行优化的方式，我认为应该是采用链表的中的哨兵方式，类似于完成一项两个有序链表的合并的操作。如果是在数组中添加哨兵，操作计算并没有减少。先构建一条链，在从p开始把链写入到数组中","like_count":0},{"had_liked":false,"id":170930,"user_name":"Jacky","can_delete":false,"product_type":"c1","uid":1520450,"ip_address":"","ucode":"8EFB6DB3C0CA49","user_header":"https://static001.geekbang.org/account/avatar/00/17/33/42/780b7855.jpg","comment_is_top":false,"comment_ctime":1578767450,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578767450","product_id":100017301,"comment_content":"T(1) = C； n=1时，只需要常量级的执行时间，所以表示为C。T(n) = 2*T(n&#47;2) + n； n&gt;1<br>老师您好，为什么需要加 n，n 代表 n 个分解后和合并的时间吗？","like_count":0},{"had_liked":false,"id":170635,"user_name":"pikachu122","can_delete":false,"product_type":"c1","uid":1689365,"ip_address":"","ucode":"43FE4DBC872FFA","user_header":"https://static001.geekbang.org/account/avatar/00/19/c7/15/24bf166a.jpg","comment_is_top":false,"comment_ctime":1578647928,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578647928","product_id":100017301,"comment_content":"1、归并排序和快速排序体现的都是“分治”的思想。即把一个大问题分解为几个小问题解决.<br>2、归并排序：下标为p-&gt;r的数组进行排序，可以将它转化成将p-&gt;q的数组进行排序和将q+1-&gt;r数组进行排序，最后将它们按顺序合并。<br>3、归并排序是稳定的，但因为在按顺序合并时需要申请一块与原数组相同大小的空间，因此它的空间复杂度为O(n)，不是原地排序的方法。<br>4、归并排序的时间复杂度与数组无关，所有情况均为O(nlogn)。<br>5、快速排序：要排序p-&gt;r数组，先选择p-&gt;r中的任意一个元素（一般为最后一个元素）作为分区点。遍历数据，小于分区点的元素放在分区点前面，大于分区点的元素放在分区点后面。<br>6、为了实现原地排序，通过游标i把数组分为两部分，p-&gt;i-1是小于分区点的，i-&gt;r-1是大于分区点的，扫描i后面的：“未处理区”，如果小于分区点，则与i交换，并把i向后移动一位。<br>7、快速排序是原地排序，但它不是稳定的。它的时间复杂度在一般情况下都是O(nlogn)，只有在极端情况下可能退化为O(n^2)（完全有序的数组）。我们可以通过一些方法降低出现极端情况的概率。","like_count":0},{"had_liked":false,"id":168322,"user_name":"小夏","can_delete":false,"product_type":"c1","uid":1110755,"ip_address":"","ucode":"D87444ADC28C6A","user_header":"https://static001.geekbang.org/account/avatar/00/10/f2/e3/c1a88a64.jpg","comment_is_top":false,"comment_ctime":1578046737,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578046737","product_id":100017301,"comment_content":"最开始的理解是有问题的，是每个日志文件中的记录是从大到小的，不是日志间的关系是从大到小排列。所以对最开始的解题思路造成了偏差，留言中的回答也有些不理解。<br>既然每个日志内部是从大到小排列的，那就是轮询从每个日志中分别获取数据，为了保证最后的日志文件按照绝对的时间戳大小排列，那每次每个日志中只能取一行数据，进行比较，然后把最小的数据写入总文件中，然后再从已经录入数据得日志文件中获取第二行，重复进行比较。最终将全部数据写入合并的日志文件中。空间复杂度是常数o(10)，时间复杂度是o(n)吧。","like_count":0},{"had_liked":false,"id":167790,"user_name":"Kim Yin","can_delete":false,"product_type":"c1","uid":1051165,"ip_address":"","ucode":"9BBD367E6F0569","user_header":"https://static001.geekbang.org/account/avatar/00/10/0a/1d/269a15c3.jpg","comment_is_top":false,"comment_ctime":1577934793,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1577934793","product_id":100017301,"comment_content":"“你可能会说，我有个很笨的办法，每次取数组中的最小值，将其移动到数组的最前面，然后在剩下的数组中继续找最小值，以此类推，执行 K 次，找到的数据不就是第 K 大元素了吗？”<br>为什么我觉得这里是将最大的值移动到数组最前面呢？","like_count":0},{"had_liked":false,"id":167749,"user_name":"yuan","can_delete":false,"product_type":"c1","uid":1207302,"ip_address":"","ucode":"EA3D0573478EC7","user_header":"https://static001.geekbang.org/account/avatar/00/12/6c/06/2ac17d5a.jpg","comment_is_top":false,"comment_ctime":1577927414,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577927414","product_id":100017301,"comment_content":"老师能不能给出最后一道思考题的答案、时间复杂度分析","like_count":0},{"had_liked":false,"id":166076,"user_name":"耀","can_delete":false,"product_type":"c1","uid":1634462,"ip_address":"","ucode":"3692BEC242A399","user_header":"https://static001.geekbang.org/account/avatar/00/18/f0/9e/cf6570f7.jpg","comment_is_top":false,"comment_ctime":1577374981,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577374981","product_id":100017301,"comment_content":"这次真的体会到了使用时间复杂度和空间复杂度分析具体算法的威力。以前我也有一个疑问为啥归并排序复杂度是O(nlogn),而且最好和最坏都是这个。等到这节课分析空间复杂度我才发现了重大差别，以前太忽视空间复杂度。","like_count":0},{"had_liked":false,"id":164776,"user_name":"无始","can_delete":false,"product_type":"c1","uid":1758577,"ip_address":"","ucode":"B96982583496B1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d5/71/308fe8a4.jpg","comment_is_top":false,"comment_ctime":1577089570,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577089570","product_id":100017301,"comment_content":"https:&#47;&#47;github.com&#47;JinYuan91&#47;javabasis&#47;blob&#47;master&#47;java-basis-datastructure&#47;src&#47;main&#47;java&#47;com&#47;java&#47;basis&#47;datastructure&#47;sort&#47;Quick.java<br>快排<br><br>https:&#47;&#47;github.com&#47;JinYuan91&#47;javabasis&#47;blob&#47;master&#47;java-basis-datastructure&#47;src&#47;main&#47;java&#47;com&#47;java&#47;basis&#47;datastructure&#47;sort&#47;Merge.java<br>归并<br><br>王老师讲的非常好，很感谢，我要把以前没走过的路踏踏实实的走下去。","like_count":0},{"had_liked":false,"id":164772,"user_name":"witluo","can_delete":false,"product_type":"c1","uid":1443117,"ip_address":"","ucode":"3D9608C3DDDD95","user_header":"","comment_is_top":false,"comment_ctime":1577089128,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577089128","product_id":100017301,"comment_content":"按照这个思想 我写下了代码实现，实现语言为golang，：<br>func FindKthLargest(nums []int, k int) int {<br>\tif len(nums) == 1 {<br>\t\treturn nums[0]<br>\t}<br><br>\treturn partition3(nums,0,len(nums)-1,k)<br><br>}<br>func partition3(nums []int,s,e,k int) int {<br>\tfor s &lt; e {<br>\t\ta := nums[s]<br>\t\tp := e<br>\t\tfor i := e;i&gt;0;i--{<br>\t\t\tif nums[i] &lt; a {<br>\t\t\t\tnums[i],nums[p] = nums[p],nums[i]<br>\t\t\t\tp--<br>\t\t\t}<br>\t\t}<br>\t\tnums[p],nums[s] = nums[s],nums[p]<br>\t\tif p == k-1 {<br>\t\t\tbreak<br>\t\t}else if  p &gt; k-1 {<br>\t\t\te = p-1<br><br>\t\t}else {<br>\t\t\ts = p+1<br>\t\t}<br>\t}<br>\treturn nums[k-1]<br>}<br>提交到LeetCode后， 居然在所有 golang 提交中只击败了13.00%的用户，请问老师，难道还有更优的解法吗？","like_count":0},{"had_liked":false,"id":164594,"user_name":"wxhxhw","can_delete":false,"product_type":"c1","uid":1613246,"ip_address":"","ucode":"870A28FDA30539","user_header":"https://static001.geekbang.org/account/avatar/00/18/9d/be/3eef22a8.jpg","comment_is_top":false,"comment_ctime":1577048308,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577048308","product_id":100017301,"comment_content":"请问归并和快排的递归终止条件为什么有 p&gt;r 的情况？感觉只判断 (p == r) 就可以了？","like_count":0},{"had_liked":false,"id":164338,"user_name":"爱新觉罗老流氓","can_delete":false,"product_type":"c1","uid":1005661,"ip_address":"","ucode":"B13AC4DA358C15","user_header":"https://static001.geekbang.org/account/avatar/00/0f/58/5d/8de7f8dc.jpg","comment_is_top":false,"comment_ctime":1576939643,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576939643","product_id":100017301,"comment_content":"1. 从十个文件中取出第一条数据，记其时间戳为 i1,i2,i3,...,i9,i10<br>2. 给 i1~i10 排序<br>3. 排完序后得到新的 i1&#39;,i2&#39;,...,i10&#39;。从 i1&#39; 开始读取它所在文件的记录并写到新文件，直到值大于 i2&#39; 停止写入新文件，将这个值取出（假设是 i1&#39;&#39;），将 i1&#39;&#39;,i2&#39;,...,i10&#39; 从新排序<br>4. 重复 3 ......","like_count":0},{"had_liked":false,"id":163343,"user_name":"huaweichen","can_delete":false,"product_type":"c1","uid":1249907,"ip_address":"","ucode":"974917DE2AE92E","user_header":"https://static001.geekbang.org/account/avatar/00/13/12/73/2183839d.jpg","comment_is_top":false,"comment_ctime":1576706147,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576706147","product_id":100017301,"comment_content":"通过这样一步一步分解推导，我们可以得到 T(n) = 2^kT(n&#47;2^k)+kn。当 T(n&#47;2^k)=T(1) 时，也就是 n&#47;2^k=1，我们得到k=log2n 。我们将 k 值代入上面的公式，得到 T(n)=Cn+nlog2n <br><br>请教一下老师，这个里面Cn是什么啊？  <br>k=log2n 带入 2^kT(n&#47;2^k) 是怎么算的啊？<br><br>谢谢老师","like_count":0},{"had_liked":false,"id":163245,"user_name":"况颜","can_delete":false,"product_type":"c1","uid":1089185,"ip_address":"","ucode":"389F6044CB7935","user_header":"https://static001.geekbang.org/account/avatar/00/10/9e/a1/39e9c92f.jpg","comment_is_top":false,"comment_ctime":1576675306,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576675306","product_id":100017301,"comment_content":"有dalao可以解释下那个原地分区的图是啥意思么..","like_count":0},{"had_liked":false,"id":162737,"user_name":"huajay","can_delete":false,"product_type":"c1","uid":1704007,"ip_address":"","ucode":"C0880B183A2213","user_header":"https://static001.geekbang.org/account/avatar/00/1a/00/47/d1364d17.jpg","comment_is_top":false,"comment_ctime":1576582953,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576582953","product_id":100017301,"comment_content":"没理解下面这段话，我感觉是每次取最大值移到最前面，执行K次，就找到第K大元素。“你可能会说，我有个很笨的办法，每次取数组中的最小值，将其移动到数组的最前面，然后在剩下的数组中继续找最小值，以此类推，执行 K 次，找到的数据不就是第 K 大元素了吗？“","like_count":0},{"had_liked":false,"id":162735,"user_name":"huajay","can_delete":false,"product_type":"c1","uid":1704007,"ip_address":"","ucode":"C0880B183A2213","user_header":"https://static001.geekbang.org/account/avatar/00/1a/00/47/d1364d17.jpg","comment_is_top":false,"comment_ctime":1576582851,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576582851","product_id":100017301,"comment_content":"Java编码，我建了一个1万元素的逆序数组，冒泡181ms，插入167ms，归并3ms，快排165ms。<br>2万元素时，冒泡 988ms，插入620ms，归并4ms，快排java.lang.StackOverflowError。<br>想不明白为什么归并没有栈溢出，而快排溢出了。","like_count":0},{"had_liked":false,"id":162159,"user_name":"菜头","can_delete":false,"product_type":"c1","uid":1456964,"ip_address":"","ucode":"C5E95519F9EA21","user_header":"https://static001.geekbang.org/account/avatar/00/16/3b/44/dd534c9b.jpg","comment_is_top":false,"comment_ctime":1576468246,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576468246","product_id":100017301,"comment_content":"我只是想到了<br>归并排序的 merge() 函数","like_count":0},{"had_liked":false,"id":161821,"user_name":"浑浑噩噩cium","can_delete":false,"product_type":"c1","uid":1617939,"ip_address":"","ucode":"358C0BCFF62B40","user_header":"https://static001.geekbang.org/account/avatar/00/18/b0/13/5cb3459c.jpg","comment_is_top":false,"comment_ctime":1576340201,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576340201","product_id":100017301,"comment_content":"如果数据使用链表保存，归并就不需要多余空间就可完成合并，空间复杂度不就是O(1)了？","like_count":0},{"had_liked":false,"id":161817,"user_name":"猫切切切切切","can_delete":false,"product_type":"c1","uid":1075033,"ip_address":"","ucode":"F350BA1B7FFDC4","user_header":"https://static001.geekbang.org/account/avatar/00/10/67/59/017b5726.jpg","comment_is_top":false,"comment_ctime":1576338694,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576338694","product_id":100017301,"comment_content":"创建 10 个 io 流，分别从第一行开始读取 10 个文件，循环：取得 10 个文件分别的当前行日志的时间戳，比较，最小时间戳的日志写入合并后的日志文件，然后读取下一行，循环，直到没有一个当前行为止。","like_count":0},{"had_liked":false,"id":161511,"user_name":"李湘河","can_delete":false,"product_type":"c1","uid":1349528,"ip_address":"","ucode":"DB078B5DAAE82E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoViaN0hP07cXOl7vOIvHPu7DZ3wxHBz4iaLVEqG1TFfiagm1wUaiczbCyicwib7oDWw0vD4cXg9eZ0Okqg/132","comment_is_top":false,"comment_ctime":1576220192,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576220192","product_id":100017301,"comment_content":"老师，最后那个用快排分区思想找无序数组中第K大的值，针对无序数组中有相同元素怎么处理？比如{1,1,2,3}，第二大的元素应该是2，但是结果是1","like_count":0},{"had_liked":false,"id":161464,"user_name":"Be Myself","can_delete":false,"product_type":"c1","uid":1593304,"ip_address":"","ucode":"3659E2ED256DE2","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/d8/2819ff44.jpg","comment_is_top":false,"comment_ctime":1576210442,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576210442","product_id":100017301,"comment_content":"没救了，快排看了几个小时了，还没完全理解<br>","like_count":0},{"had_liked":false,"id":160992,"user_name":"Geek_JOJO","can_delete":false,"product_type":"c1","uid":1754326,"ip_address":"","ucode":"945C38ECF443B4","user_header":"https://static001.geekbang.org/account/avatar/00/1a/c4/d6/73656a64.jpg","comment_is_top":false,"comment_ctime":1576074315,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576074315","product_id":100017301,"comment_content":"学到排序有点费劲了，伪代码确实是有点难理解，这两篇学了好久哦，好难理解感觉...","like_count":0},{"had_liked":false,"id":160623,"user_name":"Allen_","can_delete":false,"product_type":"c1","uid":1677187,"ip_address":"","ucode":"CA5E00E4644CD5","user_header":"https://static001.geekbang.org/account/avatar/00/19/97/83/845b48e2.jpg","comment_is_top":false,"comment_ctime":1575988488,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575988488","product_id":100017301,"comment_content":"老师太厉害了，讲的东西和我之前自己总结的很接近，但是比我的要严谨清晰得多。特别是那个top-down和bottom-up的那种概述总结，我每次想这两个算法细节都是从这个大概念入手的。","like_count":0},{"had_liked":false,"id":160421,"user_name":"隨灬風","can_delete":false,"product_type":"c1","uid":1702149,"ip_address":"","ucode":"0122CFE630BD00","user_header":"https://static001.geekbang.org/account/avatar/00/19/f9/05/12ebf903.jpg","comment_is_top":false,"comment_ctime":1575948068,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575948068","product_id":100017301,"comment_content":"这个用c写的伪代码看着真难受，j++没有体现出来","like_count":0},{"had_liked":false,"id":160412,"user_name":"李朋远","can_delete":false,"product_type":"c1","uid":1241782,"ip_address":"","ucode":"A8C1AEDD10973F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/b6/d3afc1ec.jpg","comment_is_top":false,"comment_ctime":1575947070,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575947070","product_id":100017301,"comment_content":"十个文件，共3个g，每个文件每三条取一个数据，归并排序，排好后，从前往后写入文件，写入方法是：如果连着几个数都是同一个文件的，就把原来日志文件中连着的一堆数据写入新文件。。。。后面就这么一直写下去就可以了。望批评指正。","like_count":0},{"had_liked":false,"id":160154,"user_name":"Hi Young","can_delete":false,"product_type":"c1","uid":1548645,"ip_address":"","ucode":"E1E9C88399F3C2","user_header":"https://static001.geekbang.org/account/avatar/00/17/a1/65/44853770.jpg","comment_is_top":false,"comment_ctime":1575881761,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1575881761","product_id":100017301,"comment_content":"王争老师，关于本文解答开篇部分，计算时间复杂度n+n&#47;2+n&#47;4+n&#47;8+…+1 （等比数列求和后再单加1，即Sx+1），我的结论是n+n&#47;2+n&#47;4+n&#47;8+…+1 约为2n+1，而不是文章中的2n-1，<br>您看我的推导思路有问题吗？<br><br>等比数列首项n，比值q=1&#47;2，求当前x个值相加求和<br>Sx=n+n&#47;2+n&#47;4+n&#47;8+…+n*(1&#47;2)^(x-1)<br><br>套入等比求和公式得 <br>Sx=2n(1-(1&#47;2)^x)，当比值q在(-1,1)区间时， 项数x越大，q^x越趋近于0，即(1&#47;2)^x趋近于0<br>如果(1&#47;2)^x趋近于0，<br>则 Sx=2n(1-0)=2n<br>最终n+n&#47;2+n&#47;4+n&#47;8+…+n(1&#47;2)^(x-1)+1 = Sx+1=2n+1","like_count":0,"discussions":[{"author":{"id":1548645,"avatar":"https://static001.geekbang.org/account/avatar/00/17/a1/65/44853770.jpg","nickname":"Hi Young","note":"","ucode":"E1E9C88399F3C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77057,"discussion_content":"还有个更简单不严谨的推导，n+n/2+n/4+n/8+…+1，首尾已经有一个n+1，一堆(0*n,1*n)区间的分数想加，就是无限趋近于n，所以2n+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575885466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159869,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1575814342,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575814342","product_id":100017301,"comment_content":"归并排序（Merge Sort）<br>归并排序的核心思想：分治思想。<br>如果要排序一个数组，就先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排序好的两部分合并在一起，这样整个数组就都有序了。<br><br>写递归代码的技巧就是，分析得出递推公式，然后找到终止条件。<br><br>归并排序的性能分析：<br>\t一：归并排序的稳定性：在合拼前后的先后顺序不变，归并排序是一个稳定的排序算法。<br>\t二：归并排序的时间复杂度：归并排序涉及递归。<br>\t归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，最好情况，最坏情况，平均情况，时间复杂度都是O(nlogn)。<br>\t三：归并排序的空间复杂度：归并排序有个致命的“弱点”，归并排序不是原地排序算法。空间复杂度O(n)<br><br>（7）快速排序的原理（Quick Sort）<br>快排利用的也是分治思想。<br>如果要排序数组中下标从p到r之间的一组数据，我们选择p到r之间的任意一个数据做为pivot（分区点）。<br>遍历p到r之间的数据，将小于pivot的放到左边，将大于pivot的放到右边，将pivot放到中间。<br>经过这一步骤之后，数组p到r之间的数据被分成了三个部分，前面p到q-1之间都是小于pivot的，中间是piovt，后面的q+1到r之间是大于pivot的。<br>根据分治，递归的处理思想，可以用递归排序下标从p到q-1之间的数据和下标从q+1到r之间的数据，直到区间缩小为1，就说明所以的数据都有序了。<br><br>归并排序的处理过程是由下到上，先处理子问题，然后在合并。在快排正好相反，他的处理过程是由上到下的，先分区，然后在处理子问题。<br>归并排序虽然是稳定，时间复杂度为O(nlogn)的排序算法，但是它是非原地排序算法。<br>快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。<br><br>快速排序的性能分析：<br>\t一：快排是一种原地，不稳定的排序算法。快排也是递归来实现的。所以快排的时间复杂度也是O(nlogn)。在极端情况下会退化到O(n^2);<br><br>归并排序和快速排序：两者都是分治的思想，代码都通过递归来实现。理解归并排序的重点是理解递推公式和merge()合并函数。同理，理解快排的重点也是理解递推公式和partition()分区函数。<br><br>归并排序算法是一种在任何情况下时间复杂度都比较稳定的排序算法，这也是使他存在致命的缺点，即归并排序不是在原地排序算法，空间复杂度比较高，是O(n)。因而他没有快排应用广泛。<br><br>快速排序算法虽然最坏情况下的时间复杂度是O(n^2)，但是平均下时间复杂度都是O(nlogn)。不仅如此，快速排序算法时间复杂度退化到O(n^2)的概率非常小，我们可以合理地选择pivot来避免这种情况。<br><br>","like_count":0},{"had_liked":false,"id":159824,"user_name":"技术修行者","can_delete":false,"product_type":"c1","uid":1013147,"ip_address":"","ucode":"28CA41A1214D6B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/9b/611e74ab.jpg","comment_is_top":false,"comment_ctime":1575802765,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1575802765","product_id":100017301,"comment_content":"思维导图： https:&#47;&#47;mubu.com&#47;doc&#47;gx6FoeySE0","like_count":0},{"had_liked":false,"id":159749,"user_name":"余熙","can_delete":false,"product_type":"c1","uid":1240802,"ip_address":"","ucode":"7F98DCFB899CB7","user_header":"https://static001.geekbang.org/account/avatar/00/12/ee/e2/23e44221.jpg","comment_is_top":false,"comment_ctime":1575778359,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575778359","product_id":100017301,"comment_content":"老是，我对归并排序的空间复杂度是 O(n) 有如下疑问？<br>虽然每个时刻执行的函数只有一个，可是调用该函数的前一个，前前个函数的执行上下文，并没有销毁，这样的话，相当于 n + n&#47;2 + n&#47;4 + ...., 这样的话，是大于 n 的","like_count":0},{"had_liked":false,"id":159515,"user_name":"big智慧","can_delete":false,"product_type":"c1","uid":1202616,"ip_address":"","ucode":"272C32E19EAE1A","user_header":"https://static001.geekbang.org/account/avatar/00/12/59/b8/2a4624c3.jpg","comment_is_top":false,"comment_ctime":1575644033,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575644033","product_id":100017301,"comment_content":"打卡Day10：<br>1、日期：<br>* 2019年12月4日<br><br>2、是什么：<br>* 时间复杂度为O(n*logn)的排序算法：归并排序、快速排序<br><br>3、分析两种排序算法：<br>* 执行效率：归并排序最好最好平均时间复杂度为O（n*logn），快速排序在极端情况下时间复杂度为O（n*n）<br>* 内存的消耗：归并排序空间复杂度为O（n），快速排序可以做到空间复杂度O（n）<br>* 稳定性分析：归并排序是稳定的排序算法，快速排序不是  <br>4、分治分区在项目中类似的场景：<br>* 分治：将项目拆分成任务，在每个任务完成后项目就完成；<br>* 分治分区在优先级排序中的应用：所有的项目先分P0、P1、P2，然后P0的项目在分1、2、3...<br><br>5、关注点：<br>* 关注点：任务拆分、拆分标准","like_count":0},{"had_liked":false,"id":159504,"user_name":"crossing","can_delete":false,"product_type":"c1","uid":1689380,"ip_address":"","ucode":"3B66CFFF38BA67","user_header":"https://static001.geekbang.org/account/avatar/00/19/c7/24/19d0683e.jpg","comment_is_top":false,"comment_ctime":1575640380,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575640380","product_id":100017301,"comment_content":"关于这几种排序方法，<br>我总结了以下分析角度：<br>关注排序时的未排序区间和已排序区间，<br>关注排序数据从未排序区间选择的情况，<br>关注排序数据插入已排序区间的情况。<br><br>1.冒泡排序：<br>未排序区间在数组头部，<br>已排序区间在数组尾部。<br>每次从未排序区间找到一个最大值，<br>插入到已排序区间的头部。<br><br>2.插入排序：<br>已排序区间在数组头部，<br>未排序区间在数组尾部，<br>每次从未排序区间的头部取一个数据，<br>然后插入到已排序区间中的某个位置，<br>需要在已排序区间中查找这个插入位置。<br><br>3.选择排序：<br>已排序区间在数组头部，<br>未排序区间在数组尾部，<br>每次从未排序区间的取一个最小值，<br>然后直接插入已排序区间的尾部。<br><br>选择排序和插入排序的区别：<br>主要在于数据比较的时机不同，<br>选择排序的数据比较是发生在未排序区间，<br>插入排序的数据比较是发生在已排序区间。<br>因此选择排序的插入操作和插入排序的选择操作就简单了。<br><br>4.归并排序<br>归并排序的处理过程是从下到上的，<br>先从中间位置分区，划分成左右两个子问题，<br>先处理子问题，然后再合并。<br>最下面是已经排序好的数据，对应已排序区间。<br>最上面是没有排序好的数据，对应未排序区间。<br>数据比较发生在合并的时候，<br>合并后插入的数据就排序好了。<br>从下到上已排序区间越来越大，<br>回到到最上门面已排序区间最大，<br>即全部数据都排序好了。<br><br>5.快速排序<br>快排排序的处理过程是从上到下的，<br>先分区，但是分区的位置不是固定在中间的，<br>而是根据选择的数据才能确定分区的位置，<br>划分成左中右三个区间，<br>中间值的位置已经排序好了，<br>然后再处理左右两个子问题。<br><br>这里的顺序正好和归并排序相反：<br>最上面是已经排序好的数据，即中间位置已经排序好了，对应已排序区间。<br>最下面是没有排序好的数据，对应未排序区间。<br>分区时完成了某一个数据的选择和插入的操作，<br>所以分区方法会比较复杂。<br>从上到下已排序区间越来越大，<br>到最下面已排序区间最大，<br>即全部数据都排序好了。","like_count":0},{"had_liked":false,"id":159492,"user_name":"crossing","can_delete":false,"product_type":"c1","uid":1689380,"ip_address":"","ucode":"3B66CFFF38BA67","user_header":"https://static001.geekbang.org/account/avatar/00/19/c7/24/19d0683e.jpg","comment_is_top":false,"comment_ctime":1575636619,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575636619","product_id":100017301,"comment_content":"关于这几种排序方法，<br>我总结了以下分析角度：<br>关注排序时的未排序区间和已排序区间，<br>关注排序数据从未排序区间选择的情况，<br>关注排序数据插入已排序区间的情况。<br><br>1.冒泡排序：<br>未排序区间在数组头部，<br>已排序区间在数组尾部。<br>每次从未排序区间找到一个最大值，<br>插入到已排序区间的头部。<br><br>2.插入排序：<br>已排序区间在数组头部，<br>未排序区间在数组尾部，<br>每次从未排序区间的头部取一个数据，<br>在已排序区间中找个这个数据的位置，<br>然后插入到已排序区间中的某个位置。<br><br>3.选择排序：<br>已排序区间在数组头部，<br>未排序区间在数组尾部，<br>每次从未排序区间的头部取一个最小值，<br>然后直接插入已排序区间的尾部。<br><br>选择排序和插入排序的区别：<br>主要在于数据比较的时机不同，<br>选择排序的数据比较是发生在未排序区间，<br>插入排序的数据比较是发生在已排序区间。<br>因此选择排序的插入操作和插入排序的选择操作就简单了。","like_count":0},{"had_liked":false,"id":159358,"user_name":"SteveYang","can_delete":false,"product_type":"c1","uid":1754829,"ip_address":"","ucode":"C42BCA4F40A9EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKCbnOvEatUN4ysE2cl6zJNoAJVXXuQVhicQ1jxh6Z2Towrmmc1I6PndaicuQQ0RyyJPyJQicv4tSib9Q/132","comment_is_top":false,"comment_ctime":1575605741,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575605741","product_id":100017301,"comment_content":"使用io操作，归并的思路，每次从各个文件读取一条数据，找出最小值写入新文件，然后读取最小值所在文件的下一条数据，继续重复上一步操作，直到所有数据读取完，时间复杂度O(n)，空间复杂度O(1)。","like_count":0},{"had_liked":false,"id":159122,"user_name":"zz-c","can_delete":false,"product_type":"c1","uid":1118187,"ip_address":"","ucode":"CCA2388C17669C","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/eb/7c747aa1.jpg","comment_is_top":false,"comment_ctime":1575542292,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575542292","product_id":100017301,"comment_content":"数据量很大的时候，不是较少考虑用递归吗（递归会堆栈溢出）？一般排序会优先考虑用快排。但是看代码快排是用递归实现。 我模拟用100000数据用递归快排序也很快，不会影响堆栈，这是为什么呢？","like_count":0},{"had_liked":false,"id":158901,"user_name":"testerman","can_delete":false,"product_type":"c1","uid":1473556,"ip_address":"","ucode":"8DDC62262FA5DE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoDbVIx6bXBFTCDtBUPXzIJzEiaSCfjP7wRA95dGIAGJRnOCutFcIRFkEaUqrEF2fE0HJ1WaFsKn8w/132","comment_is_top":false,"comment_ctime":1575473639,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575473639","product_id":100017301,"comment_content":"归并排序，分到最后才排，再合<br>快速排序，边分边排，分完就有序<br><br>快排常用来找top k，标的的索引位为p，如果左边是大于标的的值，那么标的为第p+1大，因为索引位以零起始","like_count":0},{"had_liked":false,"id":158753,"user_name":"Spring4J","can_delete":false,"product_type":"c1","uid":1645430,"ip_address":"","ucode":"06F056085A2564","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","comment_is_top":false,"comment_ctime":1575446577,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575446577","product_id":100017301,"comment_content":"归并排序跟快速排序的时间复杂度简单来算就是：每次对半砍，n个数据砍了log2n次，每砍一次里面还嵌套了一个n个数据的merge()或者partition()，利用乘法法则，就是nlog2n，大O表示法就是O(nlogn)","like_count":0},{"had_liked":false,"id":158745,"user_name":"mrkou47","can_delete":false,"product_type":"c1","uid":1519548,"ip_address":"","ucode":"831BE4BAC8481F","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKvgSccCBPlzUo1SvJoAXuSMmTtGA9zQA9I4HmwIsm6tpDic1iao6YRppkTBibQXcLaGO5icUtxqqDWzA/132","comment_is_top":false,"comment_ctime":1575445859,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575445859","product_id":100017301,"comment_content":"function quickSort(arr) {<br>  if (arr.length &lt;= 1) return arr;<br>  const len = arr.length;<br>  const mediumIndex = Math.floor(len &#47; 2);<br>  const mediumVal = arr[mediumIndex];<br>  const less = [];<br>  const more = [];<br>  const same = [];<br>  for (let i = 0; i &lt; arr.length; i++) {<br>    let temp = arr[i];<br>    if (temp === mediumVal) {<br>      same.push(temp);<br>    }<br>    else if(temp &lt; mediumVal) {<br>      less.push(temp);<br>    }<br>    else {<br>      more.push(temp);<br>    }<br>  }<br>  return quickSort(less).concat(same).concat(quickSort(more));<br>}<br><br>const sorted = quickSort([3,44,2, 38,5,47,15,36]);<br>console.log(sorted);<br><br>我想知道我写的这个排序，他是啥排序啊？？","like_count":0},{"had_liked":false,"id":158608,"user_name":"百里","can_delete":false,"product_type":"c1","uid":1212873,"ip_address":"","ucode":"2CE96129AA7F78","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/c9/9194612b.jpg","comment_is_top":false,"comment_ctime":1575422549,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575422549","product_id":100017301,"comment_content":"先构建10个IO句柄, 每个IO句柄读取100M数据,从小到大读取,因为日志文本本身有序,相当于一次处理1000M数据.存放在一个数组里,进行快排.处理完写入新的文件, 重复前面动作.追加写入新文件,得到一个有序日志文件,共处理3次完成日志文件排序.","like_count":0},{"had_liked":false,"id":158581,"user_name":"梦想的优惠券","can_delete":false,"product_type":"c1","uid":1257418,"ip_address":"","ucode":"D3B44F6C618CA7","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/ca/cbce6e94.jpg","comment_is_top":false,"comment_ctime":1575420838,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1575420838","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":158545,"user_name":"Cy23","can_delete":false,"product_type":"c1","uid":1591293,"ip_address":"","ucode":"8DC561C5151758","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/fd/895f0c27.jpg","comment_is_top":false,"comment_ctime":1575417489,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575417489","product_id":100017301,"comment_content":"学完一遍，了解了个大概，明天看代码学习实现细节加深理解","like_count":0},{"had_liked":false,"id":158204,"user_name":"大海","can_delete":false,"product_type":"c1","uid":1001446,"ip_address":"","ucode":"20913D0265971B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/47/e6/67b0b711.jpg","comment_is_top":false,"comment_ctime":1575348474,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575348474","product_id":100017301,"comment_content":"快速排序的方案，不是一句话可以说清楚，得多看几遍才行","like_count":0},{"had_liked":false,"id":157478,"user_name":"Sudouble","can_delete":false,"product_type":"c1","uid":1365574,"ip_address":"","ucode":"B369B09DAF8D20","user_header":"https://static001.geekbang.org/account/avatar/00/14/d6/46/5eb5261b.jpg","comment_is_top":false,"comment_ctime":1575172379,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575172379","product_id":100017301,"comment_content":"第一个解决方案：十个IO的接口，因为每个日志里的数据自身都是有序的，分别读取第一条日志，取出10条日志中时间戳最小的点，并使对应日志接口中去读取下一条日志，如此往复比较。<br>第二个解决方案：最近刚好在看操作系统这块的，这里主要是个思路，利用虚拟地址空间，把10条日志都读到虚拟地址控件中，具体的操作就和在内存没有什么区别了，剩下的就都交给操作系统来调度了（性能肯定惨不忍睹，一直会做页交换）。<br><br>其他想到的点，要是300M的日志文件更大，数据也是无序的呢？<br>使用分治方法，对大文件进行分割。其实和操作系统的设计方法有关系，这里只是获取了文件的起始地址，没有把整个文件加载到内存中，每次仅读取了一小块文件到内存，所以也能对文件进行分割和排序。","like_count":0},{"had_liked":false,"id":157193,"user_name":"via","can_delete":false,"product_type":"c1","uid":1017696,"ip_address":"","ucode":"5A7E873D8D8FBE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/60/fe8a31ea.jpg","comment_is_top":false,"comment_ctime":1575078246,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575078246","product_id":100017301,"comment_content":"# 归并排序<br>* 归并排序的处理过程是由下到上的，先处理子问题，然后再合并。<br><br>## 归并排序核心思想<br>* 先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了；<br>* 归并排序使用分治思想；<br><br>## 分治思想<br><br>* 分治就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了；<br>* 分治是一种解决问题的处理思想，递归是一种编程技巧；<br><br><br>##　递推公式<br>* 写递归代码:先分析得出递推公式，找到终止条件，将递推公式翻译成递归代码<br><br>## 归并排序的性能分析<br><br>* 归并排序不是原地排序算法<br><br>### 归并排序是稳定的排序算法<br><br>### 归并排序的时间复杂度<br><br>* 递归代码的时间复杂度也可以写成递推公式；<br>* 归并排序的时间复杂度是 O(nlogn)；<br>* 时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)。<br><br>### 归并排序的空间复杂度<br><br>* 归并排序不是原地排序算法；<br>* CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)。<br><br># 快速排序<br><br>* 分治思想；<br>* 快排用递归来实现；<br>* 原地排序算法（快速排序通过设计巧妙的原地分区函数，实现原地排序，解决了归并排序占用太多内存的问题）；<br>* 处理过程是由上到下的，先分区，然后再处理子问题；<br>* 不稳定的排序算法；<br><br>##  快排的思<br>* 如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）；<br>* 遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的；<br>* 分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。<br><br>## 快速排序的性能分析<br>* 最坏情况下的时间复杂度是 O(n2)；<br>* 平均情况下时间复杂度都是 O(nlogn)；<br>* 快速排序算法时间复杂度退化到 O(n2) 的概率非常小，通过合理地选择 pivot 来避免这种情况。","like_count":0},{"had_liked":false,"id":156227,"user_name":"刺猬","can_delete":false,"product_type":"c1","uid":1108297,"ip_address":"","ucode":"60C3E38F4F03CC","user_header":"https://static001.geekbang.org/account/avatar/00/10/e9/49/29072f9e.jpg","comment_is_top":false,"comment_ctime":1574839783,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574839783","product_id":100017301,"comment_content":"归并排序需要创建一个和要排序数据大小一样的临时数组，排序之后这个临时数组已经是有序的，这时候为何不使用这个临时数组，销毁要排序的那个数组，为何要把这个临时数组在拷贝到要排序的数组，然后销毁这个临时数组，数据量很大的时候，最后这个拷贝的时间复杂度就是O(n).","like_count":0},{"had_liked":false,"id":155615,"user_name":"渴望做梦","can_delete":false,"product_type":"c1","uid":1398219,"ip_address":"","ucode":"9EB47530A69C91","user_header":"https://static001.geekbang.org/account/avatar/00/15/55/cb/1efe460a.jpg","comment_is_top":false,"comment_ctime":1574729186,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574729186","product_id":100017301,"comment_content":"老师，为啥快速排序终止条件是p≥r呢，不应该是它俩之间距离≤1吗，r－p≤1?","like_count":0},{"had_liked":false,"id":154799,"user_name":"jacky","can_delete":false,"product_type":"c1","uid":1716933,"ip_address":"","ucode":"CD583272CF1237","user_header":"https://static001.geekbang.org/account/avatar/00/1a/32/c5/025e6716.jpg","comment_is_top":false,"comment_ctime":1574567758,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574567758","product_id":100017301,"comment_content":"随机生成10000个长度为100的数组，比较不同排序算法的性能，如下是我用虚机测试结果（i5-7500 CPU @ 3.40GHz，1个核心）<br>bubble sort consume 252 ms<br>insertion sort consume 96 ms<br>select sort consume 160 ms<br>merge sort consume 96 ms<br>quick sort v1 consume 48 ms<br>quick sort v2 consume 58 ms<br><br>quick sort v1的分区算法是分别从数组后面和前面往中间遍历进行分区<br>quick sort v2的分区算法是老师课文里提到的分区算法，v2的分区算法会有数据交换，而v1<br>没有数据交换，只需要移动位置","like_count":0},{"had_liked":false,"id":154420,"user_name":"梨子苹果","can_delete":false,"product_type":"c1","uid":1716067,"ip_address":"","ucode":"3666813FEE31D3","user_header":"https://static001.geekbang.org/account/avatar/00/1a/2f/63/7a048d46.jpg","comment_is_top":false,"comment_ctime":1574426962,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574426962","product_id":100017301,"comment_content":"这个问题实际上是归并排序的子集，因为这里只是为了解决merge的问题，并没有split的过程，merge的话，就按照作者文中栗子做就行了","like_count":0},{"had_liked":false,"id":153947,"user_name":"渴望做梦","can_delete":false,"product_type":"c1","uid":1398219,"ip_address":"","ucode":"9EB47530A69C91","user_header":"https://static001.geekbang.org/account/avatar/00/15/55/cb/1efe460a.jpg","comment_is_top":false,"comment_ctime":1574335120,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574335120","product_id":100017301,"comment_content":"老师，不太明白为啥快速排序是不稳定的，如果有这样一个数组[9,4,6,7,6,8]以8为分界点，那第一个6小于8放在i的左边，第二个6也小于8也放在左边，它们的相对顺序应该是一样的吧？","like_count":0},{"had_liked":false,"id":153287,"user_name":"逍遥","can_delete":false,"product_type":"c1","uid":1070213,"ip_address":"","ucode":"95C583EF780159","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/85/081804f7.jpg","comment_is_top":false,"comment_ctime":1574211082,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574211082","product_id":100017301,"comment_content":"既然快速排序是不稳定的，前一篇又说到稳定性是算法的一个重要指标，那快排能算一个好的算法吗？不懂就问，还望有大牛解答一下。","like_count":0},{"had_liked":false,"id":153048,"user_name":" 臣馟飞扬","can_delete":false,"product_type":"c1","uid":1116188,"ip_address":"","ucode":"F2F882B7678055","user_header":"https://static001.geekbang.org/account/avatar/00/11/08/1c/ef15e661.jpg","comment_is_top":false,"comment_ctime":1574147636,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574147636","product_id":100017301,"comment_content":"Java实现快排：<br>public static void quickSort(int[] nums) {<br>        quick_sort_c(nums, 0, nums.length - 1);<br>    }<br><br>    private static void quick_sort_c(int[] nums, int p, int r) {<br>        if (p &gt;= r) {<br>            return;<br>        }<br>        <br>        int q = partition(nums, p, r);<br>        quick_sort_c(nums, p, q - 1);<br>        quick_sort_c(nums, q + 1, r);<br>    }<br><br>    private static int partition(int[] nums, int p, int r) {<br>        int pivot = nums[r];<br>        int i = p;<br>        for (int j = p; j &lt; r; j++) {<br>            if (nums[j] &lt; pivot) {<br>                swap(nums, i, j);<br>                i++;<br>            }<br>        }<br>        swap(nums, i, r);<br>        <br>        return i;<br>    }<br><br>    private static void swap(int[] nums, int a, int b) {<br>        int temp = nums[a];<br>        nums[a] = nums[b];<br>        nums[b] = temp;<br>    }","like_count":0},{"had_liked":false,"id":152324,"user_name":"William～Zhang","can_delete":false,"product_type":"c1","uid":1527138,"ip_address":"","ucode":"8659B589428F11","user_header":"https://static001.geekbang.org/account/avatar/00/17/4d/62/0fe9cbb3.jpg","comment_is_top":false,"comment_ctime":1573972642,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573972642","product_id":100017301,"comment_content":"老师，python 代码中，关于quick_sort, k 与 m 的区别是什么，这一块看不懂","like_count":0},{"had_liked":false,"id":152316,"user_name":"brave","can_delete":false,"product_type":"c1","uid":1095744,"ip_address":"","ucode":"D830743016CEB5","user_header":"https://static001.geekbang.org/account/avatar/00/10/b8/40/05f9f8ca.jpg","comment_is_top":false,"comment_ctime":1573970414,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573970414","product_id":100017301,"comment_content":"我觉得这一章，可以更详细一点！求无序数组中的第 K 大元素这个讲的太笼统了","like_count":0},{"had_liked":false,"id":152124,"user_name":"HiAliens","can_delete":false,"product_type":"c1","uid":1690377,"ip_address":"","ucode":"70544FC1AB28FE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoiaSKMpyJEgOicOgEHLJUOMk8cCFuice5ytHyoC2KXOSBk1sv7ia0lMy1hSWpNaWGmxlXwdg3umcYS9w/132","comment_is_top":false,"comment_ctime":1573886101,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573886101","product_id":100017301,"comment_content":"你好，我在用python实现合并排序时，在merge函数中我这样写<br>    if i &lt;= mid:<br>         begin = i, end = mid<br>     else:<br>         begin = j, end = high  # 这行报错： int 不可迭代，<br>您是这么写的：<br>    begin = i if i &lt;= mid else j<br>    end = mid if i &lt;= mid else high；<br>请问，为什么会报 int 不可迭代呢？","like_count":0},{"had_liked":false,"id":151745,"user_name":"JAMES","can_delete":false,"product_type":"c1","uid":1170796,"ip_address":"","ucode":"63015120144DDB","user_header":"https://static001.geekbang.org/account/avatar/00/11/dd/6c/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1573784499,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573784499","product_id":100017301,"comment_content":"2019&#47;11&#47;15 滴滴 快速排序还得仔细研究一番","like_count":0},{"had_liked":false,"id":151688,"user_name":"WIZ","can_delete":false,"product_type":"c1","uid":1260348,"ip_address":"","ucode":"313AF84674475C","user_header":"https://static001.geekbang.org/account/avatar/00/13/3b/3c/2947127c.jpg","comment_is_top":false,"comment_ctime":1573779418,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573779418","product_id":100017301,"comment_content":"感觉，课后思考题好像没有用到快排的思想呀？不知道老师还能不能看见。","like_count":0},{"had_liked":false,"id":151620,"user_name":"leesofte","can_delete":false,"product_type":"c1","uid":1014626,"ip_address":"","ucode":"41F327F87C515A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/62/80d0d8d2.jpg","comment_is_top":false,"comment_ctime":1573758806,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573758806","product_id":100017301,"comment_content":"开辟一个小于1g的数组Array，尽可能大，创建目标文件fkey，打开10个文件，分别取出1行数据，取时间最小值那个文件，取出50m数据，记录最大时间nax，填入Array，然后依次从另外文件中一个一个读行，当时间不大于第一个文件的最大时间max，填入Array，当时间大于最大时间max，换另一个文件读取，同理填入Array，都遍历完所有文件后，对Array进行快排，并写入目标fkey。清空数组Array后，对10个文件中剩余数据进行同样的操作，直到全部写入文件fkey位置。","like_count":0},{"had_liked":false,"id":150960,"user_name":"Silent_Boy主决","can_delete":false,"product_type":"c1","uid":1345352,"ip_address":"","ucode":"49ED42AE2661BB","user_header":"https://static001.geekbang.org/account/avatar/00/14/87/48/5f007043.jpg","comment_is_top":false,"comment_ctime":1573635062,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573635062","product_id":100017301,"comment_content":"实现了一下，快速排序找第K大的方法：<br>func findK(a []int, low, high, k int) []int {<br>        if low &gt;= high {<br>                fmt.Println(&quot;low &gt;= high&quot;)<br>                return a<br>        }<br><br>        i, j, value := low, high, a[low]<br><br>        for i &lt; j {<br>                for ; j &gt; i; j-- {<br>                        if a[j] &lt; value {<br>                                break<br>                        }<br>                }<br>                a[i] = a[j]<br><br>                for ; i &lt; j; i++ {<br>                        if a[i] &gt; value {<br>                                break<br>                        }<br>                }<br>                a[j] = a[i]<br>        }<br>        a[i] = value<br>        if i == k-1 {<br>                return a<br>        } else if i &gt; k-1 {<br>                a = findK(a, low, i-1, k)<br>        } else {<br>                a = findK(a, i+1, high, k)<br>        }<br>        return a<br>}","like_count":0},{"had_liked":false,"id":148425,"user_name":"JUNE","can_delete":false,"product_type":"c1","uid":1128603,"ip_address":"","ucode":"7F066D70DA6F6F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJMrh2ibBfsLfBFKzpqrzqVKjfotegNz0ZGfdcVWY0SeJxG89NHsZmvHrqxrp2RNRcHsbWJI3rIn0Q/132","comment_is_top":false,"comment_ctime":1573005749,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573005749","product_id":100017301,"comment_content":"伪代码。。这节完全没看懂","like_count":0},{"had_liked":false,"id":146393,"user_name":"black","can_delete":false,"product_type":"c1","uid":1681512,"ip_address":"","ucode":"9B5E0909926674","user_header":"https://static001.geekbang.org/account/avatar/00/19/a8/68/70392fdd.jpg","comment_is_top":false,"comment_ctime":1572512327,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572512327","product_id":100017301,"comment_content":"讲的好细，好通俗，之前看别人介绍真的是云里雾里的","like_count":0},{"had_liked":false,"id":146392,"user_name":"black","can_delete":false,"product_type":"c1","uid":1681512,"ip_address":"","ucode":"9B5E0909926674","user_header":"https://static001.geekbang.org/account/avatar/00/19/a8/68/70392fdd.jpg","comment_is_top":false,"comment_ctime":1572512284,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572512284","product_id":100017301,"comment_content":"这个伪代码我喜欢","like_count":0},{"had_liked":false,"id":146278,"user_name":"会飞的鱼","can_delete":false,"product_type":"c1","uid":1257205,"ip_address":"","ucode":"BA3FC4E0BF7B39","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erloYzyia2hRy19E3aCtc0pf10MiaGmzEcXw8UZ3jC3LAibD8icWAFVCXGAlAic3mpjBUrHvyreyhAjIFw/132","comment_is_top":false,"comment_ctime":1572488781,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572488781","product_id":100017301,"comment_content":"伪代码看得有些费劲啊","like_count":0},{"had_liked":false,"id":146227,"user_name":"头像不好看","can_delete":false,"product_type":"c1","uid":1718033,"ip_address":"","ucode":"8303610F463010","user_header":"https://static001.geekbang.org/account/avatar/00/1a/37/11/dc26e43e.jpg","comment_is_top":false,"comment_ctime":1572480478,"is_pvip":false,"replies":[{"id":"57645","content":"这是递归的思想。a.length-1是整个数组的长度，而r、p代指递归到哪个子问题，那个子问题的首尾下标。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1573425434,"ip_address":"","comment_id":146227,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572480478","product_id":100017301,"comment_content":" 归并排序最后将临时数组中的值赋给原来的数组的循环语句中，i的限制条件为什么是r-p，不能是a.length-1<br><br>for (i = 0; i &lt;= r-p; ++i) {<br>      a[p+i] = tmp[i];<br>    }<br>  }","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472757,"discussion_content":"这是递归的思想。a.length-1是整个数组的长度，而r、p代指递归到哪个子问题，那个子问题的首尾下标。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573425434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145084,"user_name":"momo","can_delete":false,"product_type":"c1","uid":1711813,"ip_address":"","ucode":"EBC2C886E5A222","user_header":"https://static001.geekbang.org/account/avatar/00/1a/1e/c5/4e640126.jpg","comment_is_top":false,"comment_ctime":1572184222,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572184222","product_id":100017301,"comment_content":"emmm…操作系统通常是通过败者树和归并树来实现文件合并的，耗一点内存换时间是值得的，毕竟io代价太高了。","like_count":0},{"had_liked":false,"id":144806,"user_name":"wend","can_delete":false,"product_type":"c1","uid":1014096,"ip_address":"","ucode":"45EE220931FE91","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJyzUm3M4HMj0wXv8Pr34OhOiaFJjFMSjVKnaJoOWR9Uo1T4RBI4MYtguolJgOwb6eKsAUOq4MGlrw/132","comment_is_top":false,"comment_ctime":1572060733,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572060733","product_id":100017301,"comment_content":"10个io流对应10个文件，每个50m缓存，用完再取，<br>剩余500m内存用于归并排序，满了写入文件。<br>停止条件是10个io流都空了。<br>空间用满，时间是归并排序nlogn","like_count":0},{"had_liked":false,"id":144695,"user_name":"肖某某","can_delete":false,"product_type":"c1","uid":1136927,"ip_address":"","ucode":"A1D06FAD40FB33","user_header":"https://static001.geekbang.org/account/avatar/00/11/59/1f/a3679b09.jpg","comment_is_top":false,"comment_ctime":1571998925,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571998925","product_id":100017301,"comment_content":"归并排序java版本的实现<br>&#47;&#47;两路归并算法，两个排好序的子序列合并为一个子序列<br>    public void mergeSort(int [] a, int start, int end){<br>        if(start &lt; end ){ &#47;&#47;当子序列中只有一个元素时结束递归<br>            int mid = (start + end)&#47;2; &#47;&#47;划分子序列<br>            mergeSort(a, start, mid); &#47;&#47;对左侧子序列进行递归排序<br>            mergeSort(a, mid+1, end);&#47;&#47;对右侧子序列进行递归排序<br>            merge(a, start, mid, end);&#47;&#47;合并<br>        }<br>    }<br><br>    private void merge(int[] a, int start, int mid, int end) {<br>        &#47;&#47;tmep为零时辅助数组，p、q是检测指针,分别为左序列起始指针和右序列起始指针，k是零时辅助数组的存放指针<br>        int [] tmep = new int [a.length];<br>        int p = start;<br>        int q = mid;<br>        int k = start;<br><br>        while(p &lt;= mid &amp;&amp; q &lt;= end){<br>            if(a[p] &lt;= a[q] ){<br>                tmep[k++] = a[p];<br>                p++;<br>            }else{<br>                tmep[k++] = a[q];<br>                q++;<br>            }<br>        }<br><br>        &#47;&#47;如果第一个序列未检测完，直接将后面所有元素加到合并的序列中<br>        while(p &lt;= mid){<br>            tmep[k++] = a[p++];<br>        }<br><br>        &#47;&#47;同上<br>        while(q &lt;= end){<br>            tmep[k++] = a[q++];<br>        }<br><br>        &#47;&#47;复制回原素组<br>        for(int i=0; i&lt;end-start; i++){<br>            a[start+i] = tmep[i];<br>        }<br>    }","like_count":0},{"had_liked":false,"id":144298,"user_name":"技术小生","can_delete":false,"product_type":"c1","uid":1692743,"ip_address":"","ucode":"18B7751498029F","user_header":"https://static001.geekbang.org/account/avatar/00/19/d4/47/0deb44d6.jpg","comment_is_top":false,"comment_ctime":1571890378,"is_pvip":false,"replies":[{"id":"55984","content":"思路是对的，你可以看看其他小伙伴的留言","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1572230581,"ip_address":"","comment_id":144298,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571890378","product_id":100017301,"comment_content":"这是不是使用归并排序的并的过程","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471879,"discussion_content":"思路是对的，你可以看看其他小伙伴的留言","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572230581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143729,"user_name":"抱小星","can_delete":false,"product_type":"c1","uid":1504652,"ip_address":"","ucode":"BA7B0DAFDA4AF5","user_header":"https://static001.geekbang.org/account/avatar/00/16/f5/8c/82fb5890.jpg","comment_is_top":false,"comment_ctime":1571777028,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1571777028","product_id":100017301,"comment_content":"老师，我想请问一下merge哨兵思路是如何实现的？是在两个数组后都加上一个哨兵值，扫到这个哨兵值，就结束while循环并把另一个有剩余元素的数组加入到排好序的新数组里面吗？","like_count":0},{"had_liked":false,"id":143586,"user_name":"mrkou47","can_delete":false,"product_type":"c1","uid":1519548,"ip_address":"","ucode":"831BE4BAC8481F","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKvgSccCBPlzUo1SvJoAXuSMmTtGA9zQA9I4HmwIsm6tpDic1iao6YRppkTBibQXcLaGO5icUtxqqDWzA/132","comment_is_top":false,"comment_ctime":1571737303,"is_pvip":false,"replies":[{"id":"56469","content":"哈哈，说反了，是求第K小","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1572487928,"ip_address":"","comment_id":143586,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571737303","product_id":100017301,"comment_content":"“你可能会说，我有个很笨的办法，每次取数组中的最小值，将其移动到数组的最前面，然后在剩下的数组中继续找最小值，以此类推，执行 K 次，找到的数据不就是第 K 大元素了吗？” 这个对吗。。我傻了，如果找 [1,2,3,4,5,6] 中第2大元素，不是5么？执行2次，不是求出的是3吗？？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471607,"discussion_content":"哈哈，说反了，是求第K小","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572487928,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143198,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1571647257,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571647257","product_id":100017301,"comment_content":"关于课后题思考：因为每个日志文件中日志已经有序，所以个人直觉和归并排序使用场景比较符合。<br>1.由于内存只有1G,考虑到读写性能，每次从文件按顺序读取50M数据，并分别记录当前读取的行数，将读取的数据分别放在10个数组中。<br>2.利用归并排序算法，将10个数组排序，并写入新的文件。考虑到归并排序的空间复杂度是O（n）,每次读取数据占用 50M*10 =500M, 计算过程中也最多使用500M，这样充分利用内存。<br>3.排序后，清空数组，继续读取，循环进行6次，完成所有日志的排序。","like_count":0},{"had_liked":false,"id":143091,"user_name":"咩咩咩","can_delete":false,"product_type":"c1","uid":1237849,"ip_address":"","ucode":"9DEC7D5D52D972","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6a8fRQFxX5VXOpRKyYibsemKwDMexMxkzZOBquPo6T4HOcYicBiaTcqibDoTIhZSjVjF3nKXTEGDYOGPt2xqqwiawjg/132","comment_is_top":false,"comment_ctime":1571628633,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571628633","product_id":100017301,"comment_content":"课后思考:第一种，可以建立10个io流进行操作，每次读取一行记录，将值最小的那行写入文件流并且读取下一行。以此循环，实现最简单但缺点是无法有效利用1G内存。第二种，将10个文件每个读取100m数据到数组中，然后循环判断取每个数组的最小记录写入文件，当某个数组为空则再去取100m数据，直到数据取完。","like_count":0},{"had_liked":false,"id":142902,"user_name":"Mercury","can_delete":false,"product_type":"c1","uid":1664015,"ip_address":"","ucode":"EE5ACA444C754C","user_header":"https://static001.geekbang.org/account/avatar/00/19/64/0f/12b1b224.jpg","comment_is_top":false,"comment_ctime":1571578440,"is_pvip":false,"replies":[{"id":"55216","content":"可以 不过每次将数据插入文件是比较耗时的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1571618136,"ip_address":"","comment_id":142902,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571578440","product_id":100017301,"comment_content":"我觉得可不可以将一个文件中的时间段分为3段，放入3个新文件（或者时间不均匀的话分为更多发段）然后，再取一个文件到内存里按顺序依次插入对应时间段的文件中。以此类推，这样是不是可以提高效率呢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471317,"discussion_content":"可以 不过每次将数据插入文件是比较耗时的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571618136,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142860,"user_name":"imperial","can_delete":false,"product_type":"c1","uid":1465302,"ip_address":"","ucode":"8D0693B3C142B1","user_header":"https://static001.geekbang.org/account/avatar/00/16/5b/d6/d6c26ea2.jpg","comment_is_top":false,"comment_ctime":1571566106,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571566106","product_id":100017301,"comment_content":"老师，我们怎么感觉这个和冯，诺依曼说的二路归并很像哎","like_count":0},{"had_liked":false,"id":142121,"user_name":"contract","can_delete":false,"product_type":"c1","uid":1263121,"ip_address":"","ucode":"74E4271DB02E73","user_header":"https://static001.geekbang.org/account/avatar/00/13/46/11/dbfe5f71.jpg","comment_is_top":false,"comment_ctime":1571297314,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571297314","product_id":100017301,"comment_content":"我举一个比较极端的例子。如果数组中的数据原来已经是有序的了，如果我们每次选择最后一个元素作为 pivot，那每次分区得到的分区都是不均等的，我们大概需要进行n次分区，每次分区我们平均要扫描大概n&#47;2次，时间复杂度变为O（n^2）---每次分区我们平均要扫描大概n&#47;2次","like_count":0},{"had_liked":false,"id":142108,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1571295155,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571295155","product_id":100017301,"comment_content":"思考题<br>十个文件总大小是3G空间，全部处理空间不够，可以用归并排序的思想，准备十个队列，每个队列90M，每次都从这十个队列中取出最小值,放入另外一个结果队列，结果队列大小也是90M，当结果队列满的时候就写入文件末尾，如果一个候选队列被清空的时候，就再次读入90M数据，整个过程用到的内存最大990M。","like_count":0},{"had_liked":false,"id":142102,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1571294550,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571294550","product_id":100017301,"comment_content":"归并排序主要的任务在递归中的归的过程，递过去只是简单把集合二分，归的过程把两个有序小区间合并成有序的大区间。<br>快速排序主要的任务在递归中的递的过程，通过随机选择，找到一个元素的最终位置，并用这个位置将原区间一分为二然后再重启递的过程，归在这里被无视。","like_count":0},{"had_liked":false,"id":142017,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1571279544,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1571279544","product_id":100017301,"comment_content":"用Python实现快排，是目前我觉得最简洁清晰的。<br>#快速排序<br>def quicksort(array):<br>    if len(array)&lt;2:<br>        return array#基线条件<br>    else:<br>        #分区点<br>        pivot = array[0]<br>        #递归条件<br>        less = [i for i in array[1:] if i&lt;=pivot]<br>        great = [i for i in array[1:] if i&gt;pivot]<br><br>        return quicksort(less) + [pivot] + quicksort(great)<br><br>arr = [21,1,32,13,5]<br>print(quicksort(arr))","like_count":0,"discussions":[{"author":{"id":1039717,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/dd/65/3b4a2930.jpg","nickname":"lpf32","note":"","ucode":"E1B127FDFF74BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":171046,"discussion_content":"这个不是原地排序，空间复杂是O(n)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581691206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142016,"user_name":"大汉","can_delete":false,"product_type":"c1","uid":1264290,"ip_address":"","ucode":"76CB9AF7AA5D24","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/a2/37640e95.jpg","comment_is_top":false,"comment_ctime":1571279450,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571279450","product_id":100017301,"comment_content":"谢谢老师的无私分享，这是我人生中第一本算法小人书，太喜欢","like_count":0},{"had_liked":false,"id":140621,"user_name":"姜川","can_delete":false,"product_type":"c1","uid":1684311,"ip_address":"","ucode":"0F8A349623EAB5","user_header":"https://static001.geekbang.org/account/avatar/00/19/b3/57/2d92cf9a.jpg","comment_is_top":false,"comment_ctime":1571017594,"is_pvip":false,"replies":[{"id":"54533","content":"不用先排好序的。我们借鉴的是快排的思想，你再自己看看、想想。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1571094886,"ip_address":"","comment_id":140621,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1571017594","product_id":100017301,"comment_content":"有疑问，查找第K大的那个是不是用了二分查找的思想，但前提是先排好序，但无序序列排序最快也达不到O（n）呀","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470475,"discussion_content":"不用先排好序的。我们借鉴的是快排的思想，你再自己看看、想想。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571094886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1684311,"avatar":"https://static001.geekbang.org/account/avatar/00/19/b3/57/2d92cf9a.jpg","nickname":"姜川","note":"","ucode":"0F8A349623EAB5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38749,"discussion_content":"明白了，和二分查找多少有些类似，但不用全部排序，第一轮找一半，第二轮找剩下一半，但不是完全的二分，因为两部分数据可能并不相等，在二分查找的复杂度上多了N的比较","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571827916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140556,"user_name":"马建华","can_delete":false,"product_type":"c1","uid":1185974,"ip_address":"","ucode":"928189590259AB","user_header":"https://static001.geekbang.org/account/avatar/00/12/18/b6/f3f68a39.jpg","comment_is_top":false,"comment_ctime":1570984815,"is_pvip":false,"replies":[{"id":"54524","content":"python代码不是我写的，你可以提个issue问下。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1571094066,"ip_address":"","comment_id":140556,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570984815","product_id":100017301,"comment_content":"王老师在github上面的代码（https:&#47;&#47;github.com&#47;wangzheng0822&#47;algo&#47;blob&#47;master&#47;python&#47;12_sorts&#47;quick_sort.py）中为何把partition函数中的pivot选择成了数组左边第一个元素呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470438,"discussion_content":"python代码不是我写的，你可以提个issue问下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571094066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140510,"user_name":"姜川","can_delete":false,"product_type":"c1","uid":1684311,"ip_address":"","ucode":"0F8A349623EAB5","user_header":"https://static001.geekbang.org/account/avatar/00/19/b3/57/2d92cf9a.jpg","comment_is_top":false,"comment_ctime":1570972874,"is_pvip":false,"replies":[{"id":"54527","content":"你可能对递归还是有点不熟悉。归并是递归实现的。我们的算法是p-q已经排好序了，q+1-r也已经排序好序了，然后组合在一起，就有序了","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1571094284,"ip_address":"","comment_id":140510,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570972874","product_id":100017301,"comment_content":"归并递归公式那，为什么p-q,q+1-r分别排好序后组合在一起就排好了呢？这块不是很懂，这两个分别有序的数组放在一起并不是有序的吧","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470419,"discussion_content":"你可能对递归还是有点不熟悉。归并是递归实现的。我们的算法是p-q已经排好序了，q+1-r也已经排序好序了，然后组合在一起，就有序了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571094284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140386,"user_name":"马建华","can_delete":false,"product_type":"c1","uid":1185974,"ip_address":"","ucode":"928189590259AB","user_header":"https://static001.geekbang.org/account/avatar/00/12/18/b6/f3f68a39.jpg","comment_is_top":false,"comment_ctime":1570918644,"is_pvip":false,"replies":[{"id":"54532","content":"我们在分析复杂度的时候，不需要考虑跟语言相关的特性，比如你说的垃圾回收。程序不用了，在程序这一层面，我们就默认不占用内存了。至于jvm、操作系统接下来怎么去管理内存，不是程序的事情了。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1571094814,"ip_address":"","comment_id":140386,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570918644","product_id":100017301,"comment_content":"王老师，归排的空间复杂度为o(n)前提必须是内存栈的垃圾回收器在每次函数执行后都能及时触发消掉merge()函数中的临时数组tmp吧？会不会出现程序执行很快但是垃圾回收器没有及时触发导致内存栈不断积累，空间复杂度还是o(nlogn)？所以我们是不是应该在一开始在merge_sort(A, n)就建立一个长度为n的tmp，然后把tmp作为merge_sort_c()和merge的参数传递下去，这样就保证空间复杂度一定是o(N)了。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470367,"discussion_content":"我们在分析复杂度的时候，不需要考虑跟语言相关的特性，比如你说的垃圾回收。程序不用了，在程序这一层面，我们就默认不占用内存了。至于jvm、操作系统接下来怎么去管理内存，不是程序的事情了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571094814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139567,"user_name":"瑞杰_Zhang🎋","can_delete":false,"product_type":"c1","uid":1513887,"ip_address":"","ucode":"1DA514F5353741","user_header":"https://static001.geekbang.org/account/avatar/00/17/19/9f/55770fd3.jpg","comment_is_top":false,"comment_ctime":1570680325,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570680325","product_id":100017301,"comment_content":"思考题根据前面那个一条一条写入的同学的思路延伸，可不可以以一个时间段为指引，然后一次将这个时间段内的日志全都读取，然后将读取的数据进行原地快速排序，将排序之后的结果批量写入，然后再进行下一个时间段的日志读取，这样只需要根据内存大小调整时间区间长度就行了","like_count":0},{"had_liked":false,"id":139319,"user_name":"Shuhdad","can_delete":false,"product_type":"c1","uid":1248251,"ip_address":"","ucode":"D5AFDDB7F68C3A","user_header":"https://static001.geekbang.org/account/avatar/00/13/0b/fb/c37545c4.jpg","comment_is_top":false,"comment_ctime":1570610460,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570610460","product_id":100017301,"comment_content":"我这边按照上面伪代码对归并排序的代码实现 ，试了下是可以的<br> public static void mergeSort(int[] arr, int p, int r) {<br>        if (p &gt;= r) return;<br>        int q = (p + r) &#47; 2;<br>        mergeSort(arr, p, q);<br>        mergeSort(arr, q + 1, r);<br>        merge(arr, p, q, r);<br>    }<br><br>    &#47;&#47;将一个分为2部分的排序号的数组:a[p...q]和a[q+1...r] 合并排序<br>    private static void merge(int[] arr, int p, int q, int r) {<br>        int i = p, j = q + 1, k = 0;<br>        int[] tmp = new int[r - p + 1];<br>        while (k &lt;= r - p) {<br>            if (i &gt; q) {<br>                tmp[k++] = arr[i++];<br>                continue;<br>            }<br>            if (j &gt; r) {<br>                tmp[k++] = arr[i++];<br>                continue;<br>            }<br>            if (arr[i] &lt;= arr[j]) {<br>                tmp[k++] = arr[i++];<br>            } else {<br>                tmp[k++] = arr[j++];<br>            }<br>        }<br>        for (int m = 0; m &lt;= r - p; m++) {<br>            arr[p + m] = tmp[m];<br>        }<br>    }","like_count":0},{"had_liked":false,"id":138490,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1570276755,"is_pvip":false,"replies":[{"id":"53600","content":"有比较好的算法可以保证每次分区都二分的，你可以看下一篇文章就知道了。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1570580181,"ip_address":"","comment_id":138490,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570276755","product_id":100017301,"comment_content":"老师好!为啥没次分区都是二分呢?最坏的话不应该每次只分一个么。最坏算也是O(n2)吧","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469541,"discussion_content":"有比较好的算法可以保证每次分区都二分的，你可以看下一篇文章就知道了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570580181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138376,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1570183352,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1570183352","product_id":100017301,"comment_content":"老师讲的不错，以前看的时候理解没这么深","like_count":0},{"had_liked":false,"id":138190,"user_name":"Visual C++","can_delete":false,"product_type":"c1","uid":1110792,"ip_address":"","ucode":"5BD6FA88D65D39","user_header":"https://static001.geekbang.org/account/avatar/00/10/f3/08/66541a84.jpg","comment_is_top":false,"comment_ctime":1570088723,"is_pvip":false,"replies":[{"id":"53614","content":"你说的哪个图呢？我咋没看出错误呢，能说清楚为啥错了吗","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1570581153,"ip_address":"","comment_id":138190,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570088723","product_id":100017301,"comment_content":"快速排序 第一次排序图错误的<br>第二行i还在0位置，不在第二个位置上<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469430,"discussion_content":"你说的哪个图呢？我咋没看出错误呢，能说清楚为啥错了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570581153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137460,"user_name":"厚积薄发","can_delete":false,"product_type":"c1","uid":1657999,"ip_address":"","ucode":"6FE711F65C8C66","user_header":"https://static001.geekbang.org/account/avatar/00/19/4c/8f/83eefcff.jpg","comment_is_top":false,"comment_ctime":1569746195,"is_pvip":false,"replies":[{"id":"53608","content":"多看两遍，多写两遍","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1570580735,"ip_address":"","comment_id":137460,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569746195","product_id":100017301,"comment_content":"尽管能根据伪代码用自己熟悉的语言写下来，但是这种思想还是琢磨得不是很透，也许下次没有伪代码就写不出来","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469106,"discussion_content":"多看两遍，多写两遍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570580735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137180,"user_name":"Joiner","can_delete":false,"product_type":"c1","uid":1071941,"ip_address":"","ucode":"7F67D4C325E71F","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/45/5dc5437e.jpg","comment_is_top":false,"comment_ctime":1569640588,"is_pvip":false,"replies":[{"id":"52761","content":"是的，你说的没错。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1569710141,"ip_address":"","comment_id":137180,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569640588","product_id":100017301,"comment_content":"快速排序使用递归时，每次递归都会保存一个变量p，需要嵌套递归logn次，那空间复杂度是不是应该为O(logn)？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468973,"discussion_content":"是的，你说的没错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569710141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135713,"user_name":"Geek_LULU","can_delete":false,"product_type":"c1","uid":1633829,"ip_address":"","ucode":"BDB59607CB51E8","user_header":"https://wx.qlogo.cn/mmopen/vi_32/41pKJsIVw6mLwYyg1BsgMdb7licLpWPNeQ13bulsZmFHqXt2qxplcnCl9QvlEKrE2yAraMax4qicPPIzmo1w3vzA/132","comment_is_top":false,"comment_ctime":1569245315,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569245315","product_id":100017301,"comment_content":"图片中156234中的56为什么不用比较，直接接在临时数组后面？","like_count":0},{"had_liked":false,"id":134616,"user_name":"淡定的、王先森","can_delete":false,"product_type":"c1","uid":1637596,"ip_address":"","ucode":"ECF2FB5D168C85","user_header":"https://static001.geekbang.org/account/avatar/00/18/fc/dc/8ff43984.jpg","comment_is_top":false,"comment_ctime":1568879874,"is_pvip":false,"replies":[{"id":"51688","content":"多写几遍就好了","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1568933578,"ip_address":"","comment_id":134616,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568879874","product_id":100017301,"comment_content":"明白思路但是实现总是写不好 ，怎么办怎么提高","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467830,"discussion_content":"多写几遍就好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568933578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134571,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1568868566,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568868566","product_id":100017301,"comment_content":"每次从10个文件中各取50M，进行merge。当某个文件的数据merge完后，将当前已merge好的数据写入一个新文件，同时从merge完的那个数据文件中再读取一批新的数据，继续上面的流程，直至所有文件的数据全部merge完成","like_count":0},{"had_liked":false,"id":133164,"user_name":"huangzehao","can_delete":false,"product_type":"c1","uid":1386934,"ip_address":"","ucode":"8A6530D82B48E3","user_header":"https://wx.qlogo.cn/mmopen/vi_32/jqDSNBHmPbPGayjtXrm9iciccSKbfg6g8oMgXc147jib4HjoUK1RINorZYfBuiaQBibqJIrQRVG77PKGS0dW5PVAAicw/132","comment_is_top":false,"comment_ctime":1568425047,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568425047","product_id":100017301,"comment_content":"老师，你好，选择排序可以这样优化，如果minIndex没改变的话则没必要交换数据了<br><br>&#47;&#47;选择排序算法<br>\tpublic static int [] selectSort(int [] array){<br>\t\tint n = array.length;<br>\t\t<br>\t\tfor(int i = 0;i &lt; n;i++){<br>\t\t\tint minIndex = i;<br>\t\t\tfor(int j = i+1; j &lt; n; j++){<br>\t\t\t\tif(array[minIndex] &gt; array[j]){ &#47;&#47;选择排序从未排序区间找出最小的元素下标<br>\t\t\t\t\tminIndex = j;<br>\t\t\t\t}<br>\t\t\t}<br>\t\t\tif(minIndex != i){&#47;&#47;如果最小元素下标产生改变则交换数据<br>\t\t\t\tint temp = array[i];<br>\t\t\t\tarray[i] = array[minIndex];<br>\t\t\t\tarray[minIndex] = temp;<br>\t\t\t}<br>\t\t}<br>\t\treturn array;<br>\t}","like_count":0},{"had_liked":false,"id":133163,"user_name":"huangzehao","can_delete":false,"product_type":"c1","uid":1386934,"ip_address":"","ucode":"8A6530D82B48E3","user_header":"https://wx.qlogo.cn/mmopen/vi_32/jqDSNBHmPbPGayjtXrm9iciccSKbfg6g8oMgXc147jib4HjoUK1RINorZYfBuiaQBibqJIrQRVG77PKGS0dW5PVAAicw/132","comment_is_top":false,"comment_ctime":1568424995,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568424995","product_id":100017301,"comment_content":"老师，你好，选择排序可以改进优化，如果minIndex没有改变的话就没必要交换数据","like_count":0},{"had_liked":false,"id":133122,"user_name":"陈小白( ´･ᴗ･` )","can_delete":false,"product_type":"c1","uid":1334864,"ip_address":"","ucode":"A92C85374A711B","user_header":"https://static001.geekbang.org/account/avatar/00/14/5e/50/d2cdb05c.jpg","comment_is_top":false,"comment_ctime":1568367320,"is_pvip":false,"replies":[{"id":"51243","content":"为啥呢？","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1568591972,"ip_address":"","comment_id":133122,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1568367320","product_id":100017301,"comment_content":"老师，你好，开篇的问题“查看第几大的值”，公式：p+1=k; p 的位置为第k大的值。这个是不是只在一种情况，也就是没有重复数据的时候才成立，如果有重复数据，那这个公式应该就不行了吧？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467260,"discussion_content":"为啥呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568591972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1334864,"avatar":"https://static001.geekbang.org/account/avatar/00/14/5e/50/d2cdb05c.jpg","nickname":"陈小白( ´･ᴗ･` )","note":"","ucode":"A92C85374A711B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":17978,"discussion_content":"老师，你好。我的理解是假设n个数，有不重复数组A[6,5,4,3,2,1]，我们求第2大的数，那么用公式&#34;p+1=k&#34;,k=2,p=1。那么A[p]为我们找到的第二大的数。\n\n但是如果数组为A[6,6,5,4,3,2,1],我们求第2大的数，用公式&#34;p+1=k&#34;,那么求出来的结果不是A[p]=A[1]=6么，这个好像并不是我们想要的结果吧。\n\n这个地方我想了好久还是没想明白，是不是一开始就必须的限定条件为不重复数组，或者我的理解哪个地方有误？但是快排选第K大的数，其实际是先选定一个参照数，然后将这个参照数交换到属于它的&#34;位置&#34;，然后我们再判断这个位置p和k是否满足公式，如果满足，返回这个数，不满足，我们再从左边，或者右边继续找，直到满足为止。假设出现重复数的时候好像就无法满足了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568992922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132834,"user_name":"胡永","can_delete":false,"product_type":"c1","uid":1200543,"ip_address":"","ucode":"6C8BA1E0BED9C0","user_header":"https://static001.geekbang.org/account/avatar/00/12/51/9f/1840385e.jpg","comment_is_top":false,"comment_ctime":1568248942,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568248942","product_id":100017301,"comment_content":"老师这个课程如果能够出本书，并且把好的留言放进去，每个小结留空白供读者手写算法练习，就完美了，可以看的更方便","like_count":0},{"had_liked":false,"id":131745,"user_name":"我不是凯丁","can_delete":false,"product_type":"c1","uid":1636231,"ip_address":"","ucode":"33B3DA141313B3","user_header":"","comment_is_top":false,"comment_ctime":1567871464,"is_pvip":false,"replies":[{"id":"51234","content":"貌似不行。怎么放入原数组[p...q]啊，那不是把原数组中的数据覆盖了吗？","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1568591255,"ip_address":"","comment_id":131745,"utype":1}],"discussion_count":5,"race_medal":0,"score":"1567871464","product_id":100017301,"comment_content":"老师你好，对于归并排序的merge操作，我觉得以下办法可以减少一半的临时空间，同时减少一半的数据复制时间，请您帮忙看看:<br>       只申请[q+1 ....r]大小的临时空间，然后对两段数组区间从后向前merge，选取较大值放入临时空间的尾部(从后往前)，临时空间放满时，就放入原数组[p....q]段(从后向前)。所有元素放完后，把临时空间的数据复制到原数组[q+1 ... r]的位置。<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466607,"discussion_content":"貌似不行。怎么放入原数组[p...q]啊，那不是把原数组中的数据覆盖了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568591255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1636231,"avatar":"","nickname":"我不是凯丁","note":"","ucode":"33B3DA141313B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":12769,"discussion_content":"不会覆盖，因为从后往前放的时候，原数组中数据已经放到正确的位置(极端情况下，也是自己覆盖自己)。因为这个思路不好理解，我后面的回复中改良了方法。也贴了测试过的代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568593670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1636231,"avatar":"","nickname":"我不是凯丁","note":"","ucode":"33B3DA141313B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8357,"discussion_content":"修改一下，while部分可以更简洁，更容易理解：\n\n  while (lastIndex2 >= 0) {\n    if (lastIndex1 >= first &amp;&amp; vec[lastIndex1] > tempVec[lastIndex2]) {\n      vec[lastIndex--] = vec[lastIndex1--];\n    }\n    else {\n      vec[lastIndex--] = tempVec[lastIndex2--];\n    }\n  }\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567941508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1636231,"avatar":"","nickname":"我不是凯丁","note":"","ucode":"33B3DA141313B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8306,"discussion_content":"C++ vector实现代码，经测试能正常工作。\nvoid merge(vector<int> &amp;vec, int first, int middle, int last)\n{\n  auto start = vec.begin() + middle + 1;\n  vector<int> tempVec(start, start + last - middle);\n\n  int lastIndex = last;\n  int lastIndex1 = middle;\n  int lastIndex2 = tempVec.size() -1;\n\n  while (lastIndex2 >= 0) {\n    if (lastIndex1 < first) {\n      vec[lastIndex--] = tempVec[lastIndex2--];\n    }\n    else if (tempVec[lastIndex2] >= vec[lastIndex1]) {\n      vec[lastIndex--] = tempVec[lastIndex2--];\n    }\n    else {\n      vec[lastIndex--] = vec[lastIndex1--];\n    }\n  }\n}\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567909995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1636231,"avatar":"","nickname":"我不是凯丁","note":"","ucode":"33B3DA141313B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8291,"discussion_content":"想了下，换个思路可能更简单:\n先把[q+1...r]的数据复制到大小为(r-q)的临时数组，然后从后往前选择较大值，放入原数组尾部(从后往前放)，等临时数组的元素处理完了，就结束了。参照剑指Offer第二章字符串，面试题“替换空格”部分。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567901555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131643,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1567831890,"is_pvip":false,"replies":[{"id":"51235","content":"插入排序的时间复杂度不是Ologn吧","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1568591296,"ip_address":"","comment_id":131643,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1567831890","product_id":100017301,"comment_content":"老师，请教一下，归并排序的merge如果用插入排序来做，时间复杂度最好情况应该是logN吧，并且空间复杂度也仅仅只有递归栈的开销了","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466555,"discussion_content":"插入排序的时间复杂度不是Ologn吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568591296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1272047,"avatar":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","nickname":"Magic","note":"","ucode":"FD9CEDAA419EB0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":16470,"discussion_content":"搞错了😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568894423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131505,"user_name":"我不是凯丁","can_delete":false,"product_type":"c1","uid":1636231,"ip_address":"","ucode":"33B3DA141313B3","user_header":"","comment_is_top":false,"comment_ctime":1567770648,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567770648","product_id":100017301,"comment_content":"读写缓存+利用最小堆做归并","like_count":0},{"had_liked":false,"id":130884,"user_name":"陈莹","can_delete":false,"product_type":"c1","uid":1029607,"ip_address":"","ucode":"CD870F1468AFB3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b5/e7/572aca78.jpg","comment_is_top":false,"comment_ctime":1567564234,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567564234","product_id":100017301,"comment_content":"还有个BFPRT算法了解一下","like_count":0},{"had_liked":false,"id":129266,"user_name":"下一个我","can_delete":false,"product_type":"c1","uid":1206895,"ip_address":"","ucode":"253756719D23C8","user_header":"https://static001.geekbang.org/account/avatar/00/12/6a/6f/348b4bec.jpg","comment_is_top":false,"comment_ctime":1567074280,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1567074280","product_id":100017301,"comment_content":"日志合并问题，我说下我的思路？<br>答：通过归并排序算法，10个文件，两两归并成一个文件，每次归并开辟最大额外的900MB内存，将归并好的数据写入到文件中，直至一个文件。<br>注意：第一次归并10个文件时，临时内存大小满足要求；第二次归并5个文件时，当临时空间满足900MB时，将内存的数据刷新到文件中，再继续，直至归并完成；第三次，第四次按照如上流程即可。","like_count":0},{"had_liked":false,"id":128559,"user_name":"zcqshine","can_delete":false,"product_type":"c1","uid":1007000,"ip_address":"","ucode":"9DABA78369344E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5d/98/98fe8de3.jpg","comment_is_top":false,"comment_ctime":1566902927,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566902927","product_id":100017301,"comment_content":"不用快排找出第三大的数，遍历3次也可以啊😀","like_count":0},{"had_liked":false,"id":127970,"user_name":"Angus","can_delete":false,"product_type":"c1","uid":1377467,"ip_address":"","ucode":"7CC3BA1550FB5B","user_header":"https://static001.geekbang.org/account/avatar/00/15/04/bb/5e5c37c1.jpg","comment_is_top":false,"comment_ctime":1566815508,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566815508","product_id":100017301,"comment_content":"我觉得可以写伪代码，只是伪代码要写的通用易懂一些，像我就不理解:=这些字符是什么意思","like_count":0},{"had_liked":false,"id":127905,"user_name":"冰风落叶","can_delete":false,"product_type":"c1","uid":1128059,"ip_address":"","ucode":"E4DE480B95A17D","user_header":"https://static001.geekbang.org/account/avatar/00/11/36/7b/3788ca13.jpg","comment_is_top":false,"comment_ctime":1566807110,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566807110","product_id":100017301,"comment_content":"一、归并排序<br>1. 原理：将数组分成前后两部分，对这两部分分别进行排序，将排序好的两部分再合并在一起，这样整个数组就有序了。<br>2. 方法：使用分治思想，将大问题可以拆解成子问题，子问题的解决思路与大问题一样，所以可以使用递归解决，需要写出递推公式，并找到终止条件<br>3. 递推公式：merge_sort(p…r) = merge(merge_sort(p...q),merge_sort(q+1,r)) ， p是数组的最小索引值，q是数组的中间索引值，r是数组的最大索引值<br>4. 终止条件：p&gt;=r时不在继续分解，也就是分解到只剩下一个的时候就不分解了<br>5. 最好、最坏、平均时间复杂度都是：O(n*logn)，T(n) = 2*T(n&#47;2) + n = O(n*logn)（因为合并两个有序数组的时间复杂度是O(n),所以需要加上n）<br>6. 空间复杂度：每次合并操作都需要开辟临时内存空间，所以空间复杂度为O(n)，不是原地排序<br>7. 归并的稳定性：因为合并的时候相同元素的前后顺序不变，所以归并是稳定的排序算法<br><br>二、快速排序<br>1. 原理：选取数组中任意一个数据作为pivot分区点，将小于它的放在它的左侧，大于它的放在它的右侧，利用分治思想，继续分别对左右两侧进行同样的操作，直至区间缩小为1。<br>2. 方法：使用分治思想，递归的解决问题，需要写出递推公示，找出终止条件<br>3. 递归公示： quick_sort(p...r) = quick_sort(p...q-1) + quick_sort(q+1,r)，q是分区点，p到q-1的是小于q的，q+1到r时大于q的<br>4. 终止条件：p&gt;=r，也就是区间中只剩一个元素时终止<br>5. 最好时间复杂度：如果每次选取分区点时，都能把数组等分成两个，此时的时间复杂度和归并一样，都是O(n*logn)<br>6. 最坏时间复杂度：如果每次分区都是不均等的，那么就需要n次分区操作，每次分区平均扫描n&#47;2个元素，此时时间复杂度就退化为O(n*n)了<br>7. 平均时间复杂度：大部分情况下的时间复杂度都是O(n)<br>8. 空间复杂度：使用交换法，使空间复杂度降低为O(1)<br>9. 快排的稳定性：因为分区过程涉及交换操作，所以快排是不稳定的排序算法<br><br>三、如何在O(n)时间复杂度内，找出无序数组中的第K大元素<br>1. 选取数组区间A[0...n-1]的最后一个元素A[n-1]作为分区点，进行原地分区(也就是利用快排的思想，小的放左边，大的放右边，组合在一起行程一个新的数组)，数组就变成了三部分A[0...p-1]、A[p]、A[p+1...n-1]<br>2. 如果p+1=K，那A[p]就是第K大元素<br>3. 如果K&gt;p+1，那么第K大元素就在A[p+1]到A[n-1]区间中，利用递归方法，在用1中的方法把A[p+1]到A[n-1]进行原地分区，<br>4. 如果K&lt;p+1，那么第K大元素就在A[0]到A[p-1]区间中，与3中的同理<br>5. 时间复杂度：第一次分区，需要遍历N个元素，第二次分区需要遍历N&#47;2个元素，第三次分区需要遍历N&#47;4，知道区间缩小为1，总共需要遍历N+N&#47;2+N&#47;4+N&#47;8+....+1=2N-1个元素，所以时间复杂度为O(2n-1)，忽略常量之后，就是O(n)<br>6. 空间复杂度：原理与快排一样，所以空间复杂度为O(1)","like_count":0},{"had_liked":false,"id":126569,"user_name":"飞翔","can_delete":false,"product_type":"c1","uid":1065986,"ip_address":"","ucode":"3D3D10273BED18","user_header":"https://static001.geekbang.org/account/avatar/00/10/44/02/5c8e4b81.jpg","comment_is_top":false,"comment_ctime":1566429928,"is_pvip":true,"replies":[{"id":"47244","content":"是的。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1566773916,"ip_address":"","comment_id":126569,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1566429928","product_id":100017301,"comment_content":"哨兵排序是不是在二个数组末尾放一个max    max=二个数组中最后一个值的最大值  ，这样就无须判断哪个数组为空了","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464061,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566773916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1363807,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLM1WqQTliaQvXdt2whclPrbkHzZMxz5XjFjYnwV9h2MEjMDQKH6oJTtYKCoNZxficHxcGicJfMBicic9A/132","nickname":"倪大又","note":"","ucode":"A4A3889F960BC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38144,"discussion_content":"还不是很明白，能麻烦写一点示例代码吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571734930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125006,"user_name":"heyman","can_delete":false,"product_type":"c1","uid":1173894,"ip_address":"","ucode":"92EF9EF1B1B1B3","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/86/d34800a4.jpg","comment_is_top":false,"comment_ctime":1566041096,"is_pvip":false,"replies":[{"id":"47254","content":"快排算法每次分区之后要处理左右两个分区的数据，而求k大，每次分区之后只需要处理一个分区的数据。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1566775392,"ip_address":"","comment_id":125006,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566041096","product_id":100017301,"comment_content":"老师您好！求无序数组中的第K大元素。为什么时间复杂度是O(n)呢？思路是跟快排类似的递归，那为什么不是O(nlogn)? ","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463397,"discussion_content":"快排算法每次分区之后要处理左右两个分区的数据，而求k大，每次分区之后只需要处理一个分区的数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566775392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124299,"user_name":"一页遮目","can_delete":false,"product_type":"c1","uid":1188282,"ip_address":"","ucode":"4CAC0D773CBDD2","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/ba/08057681.jpg","comment_is_top":false,"comment_ctime":1565855549,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565855549","product_id":100017301,"comment_content":" 感觉归并排序的这个伪代码更好<br>void my_merge_sort(int arr[],int n)<br> {<br> merge_sort(arr,0,n-1);    <br>} <br> void merge_sort(int arr[],int l,int r)<br>{<br>     if(l &gt;=r)<br>         return ;<br>     int mid=(l+r)&#47;2; <br>     merge_sort(arr,l,mid);<br>     merge_sort(arr,mid+1,r);<br>    merge(arr,l,mid,r);<br> }","like_count":0},{"had_liked":false,"id":123261,"user_name":"高山仰止","can_delete":false,"product_type":"c1","uid":1190305,"ip_address":"","ucode":"8C2E839345E734","user_header":"https://static001.geekbang.org/account/avatar/00/12/29/a1/220b99b6.jpg","comment_is_top":false,"comment_ctime":1565655713,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565655713","product_id":100017301,"comment_content":"设置10个IO输入流指向10个访问文件并存在一个chunk对象(维护当前数据块)，每个文件每次批量读取100M数据(避免频繁IO操作)，再用一个异步线程同时消费10个chunk中的时间戳最小的一条数据，并比较选择最小的一条记录写入输出日志文件，同时将被选中的chunk的index自增1，当其中某一个chunk消费完后， 再从指定的输入日志文件中批量读取100M数据，直至所有的输入日志文件消费完毕。","like_count":0},{"had_liked":false,"id":122744,"user_name":"NELSONLIN","can_delete":false,"product_type":"c1","uid":1581899,"ip_address":"","ucode":"F3A45E93B00337","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eokorAhvqntTcyNLEtrAx5ricAAaeibEYibELtNKIVK5jtfib77TKUiacNsMrhp2eKph4I2KVYyGxCfQ2g/132","comment_is_top":false,"comment_ctime":1565510924,"is_pvip":false,"replies":[{"id":"45696","content":"你写代码运行测试了吗？我暂时没看粗问题呢","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1565909501,"ip_address":"","comment_id":122744,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565510924","product_id":100017301,"comment_content":"原地分区的伪代码中有一处书写错误，<br>我测试出，伪代码中<br>&#39;<br>partition(A, p, r) {<br>  pivot := A[r]<br>  i := p<br>  for j := p to r-1 do {<br>    if A[j] &lt; pivot {<br>      swap A[i] with A[j]<br>      i := i+1<br>    }<br>  }<br>  swap A[i] with A[r]<br>  return i<br><br>判断条件应该为 A[j] &lt;= pivot， 假如是A[j] &lt; pivot，假如数组索引最后面的数字在数组中存在重复值的话，分区后这个重复值将会被排序错误，更加不是原地排序算法了。<br>举个例子<br>数组: [7,5,8,2,5] <br>i  为分区下标<br>j 为遍历下标<br>j= 0由于 A[j] &lt; pivot --&gt;7&lt;5 不满足，i 的 下标仍然是 0<br>j = 1再次判断A[j] &lt; pivot --&gt; 5&lt;5 不满足， i 的下标仍然是 0<br>j = 2 再次判断A[j] &lt; pivot --&gt; 8&lt;5 不满足， i 的下标仍然是 0<br>j = 3 再次判断A[j] &lt; pivot --&gt; 2&lt;5 满足，i 的下标 i++ , i = 1;  并且互换为  [2,5,8,7,5]<br>此时遍历到数组的倒数第二位，终止<br>最后一次交换为 最后的下标 数 与 i =1 的交换，[2,5,8,7,5]，A[j=1] 与 A[A.length-1]交换， 仍然为[2,5,8,7,5]，分区未成功！<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462384,"discussion_content":"你写代码运行测试了吗？我暂时没看粗问题呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565909501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122741,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1565510476,"is_pvip":false,"replies":[{"id":"45084","content":"没毛病","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1565573120,"ip_address":"","comment_id":122741,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565510476","product_id":100017301,"comment_content":"不知道为什么，我写算法代码很慢哦，是病吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462383,"discussion_content":"没毛病","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565573120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122740,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1565510430,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565510430","product_id":100017301,"comment_content":"那个求 k 大的数的问题，我第一眼想到是用堆来解决，就是构造一个只有三个元素的最小堆！<br>遍历元素，每次比堆顶的元素大的话，就加入堆，重新构造堆，最后堆顶的元素就是第 k 大元素；<br><br>可以用 PriorityQueue 堆来实现；","like_count":0},{"had_liked":false,"id":122253,"user_name":"王木公","can_delete":false,"product_type":"c1","uid":1014550,"ip_address":"","ucode":"F049AEBFA0338D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/16/ca250e8c.jpg","comment_is_top":false,"comment_ctime":1565323303,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565323303","product_id":100017301,"comment_content":"在计算快排最差情况下时间复杂度时，“每次分区我们平均要扫描大约 n&#47;2 个元素”这句话我认为不对，因为每次分区时选择了最右侧的数作为pivot，随着分区的区间变小，每次分区要扫描分别是n、n-1、n-2个元素才对","like_count":0},{"had_liked":false,"id":118447,"user_name":"唐二毛","can_delete":false,"product_type":"c1","uid":1597884,"ip_address":"","ucode":"7C16F45165F4BA","user_header":"https://static001.geekbang.org/account/avatar/00/18/61/bc/a656bee7.jpg","comment_is_top":false,"comment_ctime":1564366353,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564366353","product_id":100017301,"comment_content":"&#47;&#47; 插入排序<br>  public void insertSort(int[] arr) {<br>    for (int i = 0; i &lt; arr.length; i++) {<br>      int insertValue = arr[i];<br>      int j = i - 1;<br>      for (; j &gt;= 0; j--) {<br>        if (arr[j] &gt; insertValue) {<br>          arr[j + 1] = arr[j];<br>          compareTimes++;<br>        } else {<br>          break;<br>        }<br>      }<br>      arr[j + 1] = insertValue;<br>    }<br>  }<br><br>&#47;&#47; 归并排序<br>  public void mergeSort(int[] arr, int head, int tail) {<br>    if (head == tail) {<br>      return;<br>    }<br>    int pivot = (head + tail) &#47; 2;<br>    mergeSort(arr, head, pivot);<br>    mergeSort(arr, pivot + 1, tail);<br>    mergeSortedSegment(arr, head, pivot, tail);<br>  }<br><br>  public void mergeSortedSegment(int[] arr, int head, int pivot, int tail) {<br>    int[] temp = new int[arr.length];<br>    int left = head;<br>    int right = pivot + 1;<br>    for (int i = head; i &lt;= tail; i++) {<br>      if (left &gt; pivot) {<br>        temp[i] = arr[right++];<br>        continue;<br>      }<br>      if (right &gt; tail) {<br>        temp[i] = arr[left++];<br>        continue;<br>      }<br>      if (arr[left] &lt;= arr[right]) {<br>        temp[i] = arr[left++];<br>      } else {<br>        temp[i] = arr[right++];<br>      }<br>      compareTimes++;<br>    }<br>    for (int i = head; i &lt;= tail; i++) {<br>      arr[i] = temp[i];<br>    }<br>  }<br><br>对60000个元素的随机数组, 10次排序平均时间:<br>插入排序: 509ms<br>归并排序: 699ms<br><br>分析原因: 归并排序中大量的对数组的元素在两个数组中来回copy耗费了很多时间.<br><br>这样的结果跟老师讲的好像并不符合, 希望老师能解答下,看看我代码哪个地方有问题, 谢谢!","like_count":0},{"had_liked":false,"id":117828,"user_name":"RuiClear","can_delete":false,"product_type":"c1","uid":1513951,"ip_address":"","ucode":"D67461C5053A03","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er5GnyD0t2QibS8P4flibTY49Zj5ww9vngGeicvqscc3Fsf8ibrvGMPZfCgjiaYH15Iib1xibNVia039clg3A/132","comment_is_top":false,"comment_ctime":1564140544,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564140544","product_id":100017301,"comment_content":"&#47;**<br> * 归并排序java实现<br> *&#47;<br>public class MergeSort {<br>    public static void sort(int[] a,int start,int end){<br>        if(start == end){<br>            return;<br>        }<br>        &#47;&#47;分治<br>        int m = (start + end) &#47;2;<br>        sort(a,start,m);<br>        sort(a,m+1,end);<br><br>        &#47;&#47;合并<br>        merge(a,start,m+1,end);<br>    }<br><br>    &#47;**<br>     * 合并两个有序数组为一个大的有序数组<br>     * @param a<br>     * @param start<br>     * @param m<br>     * @param end<br>     *&#47;<br>    public static void merge(int[] a,int start,int m,int end){<br>        &#47;&#47;创建一个大小为两个小数组之和的临时数组<br>        int[] tmp = new int[end - start+1];<br>        int i = start;<br>        int j = m;<br>        int k = 0;<br><br>        &#47;&#47;从头依次比较两个小数组的值，将较小的值放在tmp的前面，以实现两个有序数组合并为一个有序数组<br>        while (i&lt;=m &amp;&amp; j&lt;=end) {<br>            if (a[i] &lt;= a[j]) {<br>                tmp[k++] = a[i++];<br>            } else {<br>                tmp[k++] = a[j++];<br>            }<br>        }<br><br>        &#47;&#47;将长度较长的数组的剩余元素加入到合并数组的尾部<br>        while (m &gt; i){<br>            tmp[k++] = a[i++];<br>        }<br>        while (end &gt; j){<br>            tmp[k++] = a[j++];<br>        }<br><br>        &#47;&#47;将tmp表中排好序的数据写入到原始数组的相应位置<br>        for(int z = 0;z&lt;tmp.length;z++){<br>            a[start+z] = tmp[z];<br>        }<br>    }<br><br>    public static void main(String[] args) {<br>        &#47;&#47;生成完全倒序的数组<br>        int size = 200000;<br>        int[] a = new int[size];<br>        for(int i=0;i&lt;size;i++){<br>            a[i] = size-i;<br>        }<br>        long l = System.currentTimeMillis();<br>        sort(a,0,a.length-1);<br>        System.out.println(System.currentTimeMillis()-l);&#47;&#47;耗时 37 ms<br>        for(int i=0;i&lt;a.length;i++){<br>            System.out.print(a[i]+ &quot; &quot;);<br>        }<br>    }<br>}","like_count":0},{"had_liked":false,"id":117064,"user_name":"小耿","can_delete":false,"product_type":"c1","uid":1153707,"ip_address":"","ucode":"1C8B66C738D33B","user_header":"https://static001.geekbang.org/account/avatar/00/11/9a/ab/fd201314.jpg","comment_is_top":false,"comment_ctime":1563961321,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563961321","product_id":100017301,"comment_content":"我有个想法：首先拿到最小最大日期，然后用日期作pivot，从最小日期开始，挨个对十个文件进行分区，并将小于等于pivot的分区数据写入新文件（可能需要维护一个已写入的光标位置）。这样做的时间复杂度取决于日期个数m和数据规模n，如果假设日期个数是个常数，那么时间复杂度也是O(n)。","like_count":0},{"had_liked":false,"id":115763,"user_name":"Rain","can_delete":false,"product_type":"c1","uid":1238221,"ip_address":"","ucode":"6A270D922A3B9D","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","comment_is_top":false,"comment_ctime":1563720927,"is_pvip":false,"replies":[{"id":"42297","content":"你现在的做法是求第一小。反着来给数组排序就是求第一大。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1563746995,"ip_address":"","comment_id":115763,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563720927","product_id":100017301,"comment_content":"&quot;如果 p+1=K，那 A[p] 就是要求解的元素&quot;. 假设有 5 个元素[1, 2, 3, 4, 0], 求第 1 大, 按道理他应该是 4 对吧? 上述数组中以最后一个数字做为支点原地分区, 得到的p=0. 则排序后为 [0, 2, 3, 4, 1]. p+1 = K. 则 A[p]=0 为第1 大. 这明显是不对的. 是我哪一步分析错了吗?","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459278,"discussion_content":"你现在的做法是求第一小。反着来给数组排序就是求第一大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563746995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114978,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1563440885,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563440885","product_id":100017301,"comment_content":"算法_012<br># 作业<br>想了很久，堆排序那个没太看懂，在课程已经涉及的知识中，认为 @李建辉 同学的方法比较可行。<br>只是，这种方法在实践中，与IO对时间的消耗会远超比较运算。<br><br># 内容<br><br>1. 分治思想<br><br>2. 归并排序<br>\t- 时间复杂度：O(nlogn)(与数组有序程度无关)<br>\t- 稳定<br>\t- 非原地排序：空间O(n)<br>3. 快速排序<br>\t- 时间复杂度:O(nlogn),极端情况O(n^2)<br>\t- 不稳定<br>\t- 原地排序：O(1)<br>4. 快排的分区函数思路值得学习<br><br># 感想<br>内容有点深入了，明显地需要更多地停下来思考这里的逻辑，这个结论如何得出的，大脑高速运转。<br><br>哨兵来处理归并排序中的merge操作，发现没有太明显的优化，执行的操作一致，我用生成10000个随机数组测试，不用哨兵的还有10ms左右的时间优势，看来哨兵还是用在链表中有更明显的优势。","like_count":0},{"had_liked":false,"id":114736,"user_name":"志强","can_delete":false,"product_type":"c1","uid":1562256,"ip_address":"","ucode":"CE9F6E9D2F49E9","user_header":"https://static001.geekbang.org/account/avatar/00/17/d6/90/89fb561f.jpg","comment_is_top":false,"comment_ctime":1563373782,"is_pvip":false,"replies":[{"id":"42205","content":"不矛盾。因为递归深度是logn，即便n很大，深度也不会很大，而且还有很多优化的方案。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1563575451,"ip_address":"","comment_id":114736,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563373782","product_id":100017301,"comment_content":"有个问题要请教下：文章开篇说归并和快排的时间复杂度是O(lNongN),适合大规模数据排序，<br>但是其实现又是递归完成的。而递归在层次较深的情况下容易出现栈内存溢出，这不是矛盾吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458801,"discussion_content":"不矛盾。因为递归深度是logn，即便n很大，深度也不会很大，而且还有很多优化的方案。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563575451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114655,"user_name":"hc每天一学","can_delete":false,"product_type":"c1","uid":1512563,"ip_address":"","ucode":"F81053DC8A85C3","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Zvjhg8ibQ8qibsDVkjlGOXa3GN98qCXd6gxBbDSXARl6gR8Mgj45ia6iatAicDWiaShMEfibDG0RcQeD9Lia39bV4ricaEQ/132","comment_is_top":false,"comment_ctime":1563357208,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563357208","product_id":100017301,"comment_content":"谢谢老师！","like_count":0},{"had_liked":false,"id":114247,"user_name":"Momentum","can_delete":false,"product_type":"c1","uid":1398396,"ip_address":"","ucode":"9822B01061FE79","user_header":"https://static001.geekbang.org/account/avatar/00/15/56/7c/a30223c1.jpg","comment_is_top":false,"comment_ctime":1563260866,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563260866","product_id":100017301,"comment_content":"对文件用快排，依据最大值，最小值，直到，有一个部分可以存入内存，载入再执行快排","like_count":0},{"had_liked":false,"id":113833,"user_name":"唐二毛","can_delete":false,"product_type":"c1","uid":1597884,"ip_address":"","ucode":"7C16F45165F4BA","user_header":"https://static001.geekbang.org/account/avatar/00/18/61/bc/a656bee7.jpg","comment_is_top":false,"comment_ctime":1563167206,"is_pvip":false,"replies":[{"id":"41562","content":"怎么会呢？","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1563231130,"ip_address":"","comment_id":113833,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563167206","product_id":100017301,"comment_content":"归并排序总是比插入排序慢，为什么呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458401,"discussion_content":"怎么会呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563231130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113830,"user_name":"huahuaxiaoshao","can_delete":false,"product_type":"c1","uid":1600012,"ip_address":"","ucode":"3309034B2A8C65","user_header":"https://static001.geekbang.org/account/avatar/00/18/6a/0c/3740de12.jpg","comment_is_top":false,"comment_ctime":1563166155,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563166155","product_id":100017301,"comment_content":"10路归并排序。将排好序的数组写入内存缓冲区中，当缓冲区达到我们设定的阈值时，将缓冲数据写入硬盘的A文件中，依此类推，将缓冲区数据依次写入硬盘的A文件中。不知道想法对不对？请大家批评指正。","like_count":0},{"had_liked":false,"id":113657,"user_name":"星期八","can_delete":false,"product_type":"c1","uid":1185504,"ip_address":"","ucode":"34A37F73A48E7F","user_header":"https://static001.geekbang.org/account/avatar/00/12/16/e0/7abad3cc.jpg","comment_is_top":false,"comment_ctime":1563106489,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563106489","product_id":100017301,"comment_content":"我的理解是：归并排序是先只是分区，再排序，最后合并，从上往下是分区，排序和合并是从下往上。<br>快速排序是从上往下，分区和排序一起在做，快速排序没有另开辟空间，分区排序同时在做，没有合并这一个步骤，所以空间复杂度是O(1),这样理解是不是对的？","like_count":0},{"had_liked":false,"id":113540,"user_name":"Dong","can_delete":false,"product_type":"c1","uid":1604161,"ip_address":"","ucode":"5EB1164D31D2D4","user_header":"https://static001.geekbang.org/account/avatar/00/18/7a/41/1daf3f10.jpg","comment_is_top":false,"comment_ctime":1563072617,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563072617","product_id":100017301,"comment_content":"&#47;&#47; 优化直接插入，选用希尔排序,h=3*k + 1，其中k为[0, N&#47;3)区间内的整数,(1,4,13,40,121, ...)<br>\tpublic static void ShellSort(int[] a) {<br>\t\tint N = a.length;<br>\t\tint h=1;<br>\t\twhile(h&lt;N&#47;3) {<br>\t\t\th = h*3+1;<br>\t\t}<br>\t\twhile(h&gt;=1) {<br>\t\t\tint n,i,j,k;<br>\t\t\t&#47;&#47;划分为n个子序列,每个子序列进行插入排序<br>\t\t\tfor(n=0;n&lt;h;n++) {<br>\t\t\t\tfor(i=n+h;i&lt;N;i+=h) {<br>\t\t\t\t\tfor(j=i-h;j&gt;=0&amp;&amp;a[j]&gt;a[i];j-=h) {}<br>\t\t\t\t\tint temp = a[i];<br>\t\t\t\t\t&#47;&#47;往后挪一个位置<br>\t\t\t\t\tfor(k=i;k&gt;j+h;k-=h) {<br>\t\t\t\t\t\ta[k]=a[k-h];<br>\t\t\t\t\t}<br>\t\t\t\t\t&#47;&#47;腾出的位置复制给a[i]<br>\t\t\t\t\ta[j+h] = temp;<br>\t\t\t\t}<br>\t\t\t}<br>\t\t\th=h&#47;3;<br>\t\t}<br><br>\t}<br>","like_count":0},{"had_liked":false,"id":113414,"user_name":"Geek_b08f4c","can_delete":false,"product_type":"c1","uid":1600026,"ip_address":"","ucode":"D200278C5BFC8A","user_header":"","comment_is_top":false,"comment_ctime":1563001581,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563001581","product_id":100017301,"comment_content":"每个指针指向不同的文件，内存中记录此时的min value和文件流，分别把每次的min value写入新文件，对应的文件流继续一下数据","like_count":0},{"had_liked":false,"id":113280,"user_name":"星期八","can_delete":false,"product_type":"c1","uid":1185504,"ip_address":"","ucode":"34A37F73A48E7F","user_header":"https://static001.geekbang.org/account/avatar/00/12/16/e0/7abad3cc.jpg","comment_is_top":false,"comment_ctime":1562932918,"is_pvip":false,"replies":[{"id":"41288","content":"是的 别往深了想","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1562977258,"ip_address":"","comment_id":113280,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562932918","product_id":100017301,"comment_content":"老师：递归只要发现规律，写出递归公式的边界就行了吧？往深想，脑壳疼","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458149,"discussion_content":"是的 别往深了想","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562977258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112561,"user_name":"even","can_delete":false,"product_type":"c1","uid":1249431,"ip_address":"","ucode":"C976CFB2A0EBBF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Cwkic25ndkExxY3HvVjAaYKVzFRicv2X6TE2sjdqTBBmqeh7X8crIQe3SHPichvcayOCqI3PJ88yVuMNlD8VvkE3A/132","comment_is_top":false,"comment_ctime":1562759296,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562759296","product_id":100017301,"comment_content":"看完并自己用C语言实现了一遍，留下top K的代码吧<br><br>&#47;&#47; top K 算法， A 是数组，n 表示数组大小，k 表示第 k 大<br>int getTopK(int *a, int n, int k){<br>    if (a == nullptr || n &lt; k)<br>        return -1;<br>    <br>    return topK(a, 0, n-1, k);<br>}<br><br>int topK(int *a, int left, int right, int k){<br>    int p = partition(a, left, right);<br>    if (k == p+1)<br>        return a[p];<br><br>    if(k &lt; p+1)<br>        return topK(a, left, p-1, k);<br>    else<br>        return topK(a, p+1, right, k);<br>}<br><br>&#47;* 原地分区函数，非常巧妙，以a[right]为基准，运算结果<br> * 是i前面的元素都大于pivot，i后面的元素小于于等于pivot *&#47;<br>int partition(int *a, int left, int right){<br>    int pivot = a[right];<br>    int i = left;<br>    for (int j=left; j &lt; right; j++){<br>        if (a[j] &gt; pivot){<br>            swap(a[i], a[j]);<br>            i++;<br>        }<br>    }<br>    swap(a[i], a[right]);<br>    return i;<br>}","like_count":0},{"had_liked":false,"id":112470,"user_name":"donggg","can_delete":false,"product_type":"c1","uid":1328019,"ip_address":"","ucode":"05AFF0B726DFA1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ0Dbzqtzqniaxf7fXPvENfI2rRGSEo2mUlIaDK3EaSHPjfwibeWOBLic7n6gTqlyRIjMVel06j0TgDQ/132","comment_is_top":false,"comment_ctime":1562742179,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562742179","product_id":100017301,"comment_content":"&#47;&#47; Quick Sort<br>function quik_find(A, K){<br>  let n = A.length<br>  console.log(&quot;init:&quot;, A, &quot;, K:&quot;, K)<br>  quik_sort_find(A, 0, n-1, K)<br>}<br>function quik_sort_find(A, r, p, K){<br>  if(K === p &amp;&amp; K === r){<br>    console.log(&quot;GET!!&quot;, A[K])<br>    return;<br>  }<br>  if ( r &gt;= p ) return ;<br>  let q = partition(A, r, p);<br>  if( K &lt; q ){<br>    quik_sort_find(A, r, q-1, K);<br>  }else if(K &gt; q){<br>    quik_sort_find(A, q+1, p, K);<br>  }<br>}<br><br>function partition(A, r, p){<br>  let pivot = A[p];<br>  let i = r<br>  for(let j = r; j &lt; p-1; j+=1){<br>    if( A[j] &lt; pivot ){<br>      &#47;&#47; swap A[i] with A[j]<br>      let tmp = A[i]<br>      A[i] = A[j]<br>      A[j] = tmp<br>      i++<br>    }<br>  }<br><br>  &#47;&#47; swap A[r] with A[i]<br>  A[p] = A[i]<br>  A[i] = pivot<br>  return i;<br>}<br><br>let A = [3,4,3,6,8,1,5,2]<br>let K = 5;<br>quik_find(A, K);<br><br>快排第一次排序结果后，最后一项位置不正确。需要两次排序<br>","like_count":0},{"had_liked":false,"id":110714,"user_name":"酸葡萄","can_delete":false,"product_type":"c1","uid":1154146,"ip_address":"","ucode":"9D059C4FB327C0","user_header":"https://static001.geekbang.org/account/avatar/00/11/9c/62/f625b2bb.jpg","comment_is_top":false,"comment_ctime":1562318459,"is_pvip":false,"replies":[{"id":"40491","content":"是有点歧义哈，你明白就好了","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1562543200,"ip_address":"","comment_id":110714,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562318459","product_id":100017301,"comment_content":"感觉第K大有歧义啊，K越大这个数越大还是越小呢？老师举的那个例子正好是无法判断这个问题，不过根据，不过根据“如果 p+1=K，那 A[p] 就是要求解的元素”,老师说的意思应该是第K大，K越大这个数越小吧？<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457021,"discussion_content":"是有点歧义哈，你明白就好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562543200,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109804,"user_name":"increasingly","can_delete":false,"product_type":"c1","uid":1261809,"ip_address":"","ucode":"B12C734C736F79","user_header":"","comment_is_top":false,"comment_ctime":1562115897,"is_pvip":false,"replies":[{"id":"39884","content":"你说的没错，我们假设用了高级的分区方法，平均下来每次都能一分为二，你可以看下一节课中讲的如何来做到这一点","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1562192074,"ip_address":"","comment_id":109804,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562115897","product_id":100017301,"comment_content":"请问为什么TopK问题中，第二次分区查找是n&#47;2呢？要是分区点的index远小于数组大小，而要查找的是[index,n-1]区间呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456580,"discussion_content":"你说的没错，我们假设用了高级的分区方法，平均下来每次都能一分为二，你可以看下一节课中讲的如何来做到这一点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562192074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109166,"user_name":"frame_0224","can_delete":false,"product_type":"c1","uid":1514905,"ip_address":"","ucode":"7692DF4EA3607A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJF2gTFBleTUJK4BNqia5Ov2yiatpmLiclxibMFmCwXvIUMicL52ajftUxlQS0SIXldUk2n9BiaOczdaqFQ/132","comment_is_top":false,"comment_ctime":1561973670,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561973670","product_id":100017301,"comment_content":"关于伪代码还是真实代码的问题：建议讲课可以用伪代码，附上真实代码的地址即可<br>-------------------------------------------------------------------------------------<br>快排：<br>void QuickSort(int arr[], int n)<br>{<br>    QuickSort_C(arr, 0, n - 1);<br>}<br>void QuickSort_C(int arr[], int p, int r)<br>{<br>    &#47;&#47;终止条件<br>    if (p &gt;= r)<br>        return;<br>    &#47;&#47;获取分区点<br>    int pivot = Partition(arr, p, r);<br>    QuickSort_C(arr,p,pivot-1);<br>    QuickSort_C(arr,pivot+1,r);<br>}<br>int Partition(int arr[], int p, int r)<br>{<br>    int i=p,j=p;<br>    int pivot = arr[r];<br>    int temp;<br>    &#47;&#47;arr[p,i-1]都是小于pivot的，成为已处理区间，arr[i,r-1]是未处理区间，每次从未处理区间取一个数加入已处理区间尾部<br>    for ( ; j &lt;= r-1; j++)<br>    {<br>        if (arr[j] &lt; pivot)<br>        {<br>            &#47;&#47;交换arr[i]和arr[j]<br>            temp = arr[j];<br>            arr[j] = arr[i];<br>            arr[i] = temp;<br>            <br>            &#47;&#47;已排序数组加1<br>            i++;   <br>        } <br>    }<br>    &#47;&#47;将pivot最后插入到i的位置<br>    arr[r] = arr[i];<br>    arr[i] = pivot;<br>    return i;<br>}<br>---------------------------------------------------<br>归并：<br>void MergeSort(int arr[], int n)<br>{<br>    MergeSort_C(arr, 0, n - 1);<br>}<br>void MergeSort_C(int arr[], int p, int r)<br>{<br>    &#47;&#47;判断是否达到终止条件<br>    if (p &gt;= r)<br>        return;<br>    &#47;&#47;取 p 到 r 之间的中间位置 q<br>    int q = (p + r) &#47; 2;<br>    &#47;&#47;分治递归<br>    MergeSort_C(arr, p, q);<br>    MergeSort_C(arr, q + 1, r);<br>    &#47;&#47;将A[p..q]和A[q+1...r]合并为A[p...r]<br>    Merge(arr, p, q, r);<br>}<br>void Merge(int arr[], int p, int q, int r)<br>{<br>    int start1 = p, start2 = q + 1, end1 = q, end2 = r;<br>    int k = 0;<br>    &#47;&#47;创建一个大小为r-q的临时数组<br>    int *temp = (int *)malloc((r - p) * sizeof(int));<br><br>    &#47;&#47;借助临时数组，小的就先往临时数组中放，已经放入之后，自增<br>    while (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)<br>    {<br>        temp[k++] = arr[start1] &lt;= arr[start2] ? arr[start1++] : arr[start2++];<br>    }<br>    &#47;&#47;把子数组中剩余的数给加上去<br>    while (start1 &lt;= end1)<br>    {<br>        temp[k++] = arr[start1++];<br>    }<br>    while (start2 &lt;= end2)<br>    {<br>        temp[k++] = arr[start2++];<br>    }<br>    for (k = 0; k &lt;= r - p; k++)<br>    {<br>        arr[p + k] = temp[k];<br>    }<br>    free(temp);<br>}","like_count":0},{"had_liked":false,"id":108946,"user_name":"LongXiaJun","can_delete":false,"product_type":"c1","uid":1154688,"ip_address":"","ucode":"B5246BF0DAF4F7","user_header":"https://static001.geekbang.org/account/avatar/00/11/9e/80/b87f8b49.jpg","comment_is_top":false,"comment_ctime":1561940961,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561940961","product_id":100017301,"comment_content":"在一个数组中找第 k大的数这个问题中 为什么如果 p+1= k， a[ p]就是要查找的结果呢？<br>解答: 因为p的代表的是归并后的pviot点在数组中的下标，即所有大于pviot点的值都在左边(右边)，小于的在右边(左边)，p的值代表大于(小于)pviot点的值有多少个，如果p+1=K就说明有数组中k个最大的数在左边(右边)，即可得到p+1位置的值就是求的K给最大值。","like_count":0},{"had_liked":false,"id":107646,"user_name":"Leon📷","can_delete":false,"product_type":"c1","uid":1219496,"ip_address":"","ucode":"B9BBD1EFAAE5A2","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg","comment_is_top":false,"comment_ctime":1561591816,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561591816","product_id":100017301,"comment_content":"我理解的递归就是先拆，拆分到原子级别后，代码就停留在return，然后开始合并每个最小子单元的结果，这个就是return下面的代码，个人觉得这么理解起来快捷明晰很多","like_count":0},{"had_liked":false,"id":106431,"user_name":"麦兜","can_delete":false,"product_type":"c1","uid":1528718,"ip_address":"","ucode":"B316B7A9CE90BD","user_header":"https://static001.geekbang.org/account/avatar/00/17/53/8e/b6e1c04f.jpg","comment_is_top":false,"comment_ctime":1561299199,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561299199","product_id":100017301,"comment_content":"老师，归并排序中 T(n&#47;2^k)=T(1) 和 T(n)=Cn+nlog2n 是怎么得出来的？没太看明白。","like_count":0},{"had_liked":false,"id":106311,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1561261343,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561261343","product_id":100017301,"comment_content":"不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式<br>递归的时间复杂度求解方法，除了递推公式外，还有递归树<br>归并排序是从下往上的，快速排序是从上往下的<br>归并排序从下往上每过一层逆序数的减少就越强，快速排序从上往下越在上层逆序数的减少就越强<br>归并排序的核心是递推公式和merge函数，快速排序的核心是递推公式和partition函数<br>归并排序：最好、最坏、平均时复都是o(nlogn)；空复o(n)；稳定<br>（时复可以由递推公式得到；空复的计算要看实际在内存中的消耗；稳定可以由设置归并时的顺序保证）<br>快速排序：最好、平均时复是o(nlogn)，最坏时o(n2)；就地排序；不稳定","like_count":0},{"had_liked":false,"id":105514,"user_name":"静水流深","can_delete":false,"product_type":"c1","uid":1339724,"ip_address":"","ucode":"644F05EFBD2E7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/4c/2cefec07.jpg","comment_is_top":false,"comment_ctime":1561019658,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561019658","product_id":100017301,"comment_content":"感觉代码用golang写，看得更流畅点。","like_count":0},{"had_liked":false,"id":103827,"user_name":"刘冲","can_delete":false,"product_type":"c1","uid":1000439,"ip_address":"","ucode":"0C4F66921AE76C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/43/f7/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1560522483,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560522483","product_id":100017301,"comment_content":"假设一种极端情况，所有元素都相等，则会造成第一个元素和最后一个元素发生交换","like_count":0},{"had_liked":false,"id":103818,"user_name":"刘冲","can_delete":false,"product_type":"c1","uid":1000439,"ip_address":"","ucode":"0C4F66921AE76C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/43/f7/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1560520759,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560520759","product_id":100017301,"comment_content":"为啥我按照老师的伪代码写出来，有问题呢","like_count":0},{"had_liked":false,"id":103766,"user_name":"Geek_coolxc","can_delete":false,"product_type":"c1","uid":1541567,"ip_address":"","ucode":"6FE7AA55B866CE","user_header":"https://static001.geekbang.org/account/avatar/00/17/85/bf/9e8eeafa.jpg","comment_is_top":false,"comment_ctime":1560505683,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560505683","product_id":100017301,"comment_content":"请问python实现的快排中分区函数的最后 a[low], a[j] = a[j], a[low] 这句是什么意思","like_count":0},{"had_liked":false,"id":102559,"user_name":"武塘","can_delete":false,"product_type":"c1","uid":1507813,"ip_address":"","ucode":"4F898F7615C39E","user_header":"","comment_is_top":false,"comment_ctime":1560252135,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560252135","product_id":100017301,"comment_content":"1. 快排分区点的选择还有个思路，从最左边顺序扫到第一个小于pivot的值，从最右边扫到第一个大于pivot的值，然后这两个值互换，退出条件是左扫描标志位遇到右扫描标志位。循环出来后把pivot和最终那个坑互换。这个思路比较直接，容易记。<br>2. 第 K 大元素如果能用复杂点的数据结构，也就是用半成品就比较简单了，比如PriorityQueue","like_count":0},{"had_liked":false,"id":102052,"user_name":"ILoveKindness","can_delete":false,"product_type":"c1","uid":1559444,"ip_address":"","ucode":"A6210B034AAC62","user_header":"https://static001.geekbang.org/account/avatar/00/17/cb/94/eedbace3.jpg","comment_is_top":false,"comment_ctime":1560126917,"is_pvip":false,"replies":[{"id":"36903","content":"第二种更好的，空间复杂度是O（1）","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560210097,"ip_address":"","comment_id":102052,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560126917","product_id":100017301,"comment_content":"老师您好，对于课后同学给出的两种答案：1.用桶排序，分成三个桶 小写 大写 数字<br>2.用指针遍历，交换<br><br>您能稍微说一下哪一种方法更好嘛<br>🙏","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453236,"discussion_content":"第二种更好的，空间复杂度是O（1）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560210097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100127,"user_name":"王鹏飞","can_delete":false,"product_type":"c1","uid":1346654,"ip_address":"","ucode":"1CC6DCCF449AFC","user_header":"https://static001.geekbang.org/account/avatar/00/14/8c/5e/eeaada1d.jpg","comment_is_top":false,"comment_ctime":1559453533,"is_pvip":false,"replies":[{"id":"36027","content":"多看两遍","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559514671,"ip_address":"","comment_id":100127,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559453533","product_id":100017301,"comment_content":"归并这看不懂了，怎么办？<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452419,"discussion_content":"多看两遍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559514671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97572,"user_name":"wahaha","can_delete":false,"product_type":"c1","uid":1051402,"ip_address":"","ucode":"E60166599CF31D","user_header":"https://static001.geekbang.org/account/avatar/00/10/0b/0a/fa152399.jpg","comment_is_top":false,"comment_ctime":1558698944,"is_pvip":false,"replies":[{"id":"35210","content":"也可以的，没有影响的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559006503,"ip_address":"","comment_id":97572,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558698944","product_id":100017301,"comment_content":"老师，如何在 O(n) 的时间复杂度内查找一个无序数组中的第 K 大元素？题目没说数组中是否有重复元素，如果有重复元素的话，似乎不能用这个方法了吧？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451328,"discussion_content":"也可以的，没有影响的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559006503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96776,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1194572,"ip_address":"","ucode":"FBFAE23E8E48B7","user_header":"https://static001.geekbang.org/account/avatar/00/12/3a/4c/b6200773.jpg","comment_is_top":false,"comment_ctime":1558504775,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558504775","product_id":100017301,"comment_content":"所以课后题跟这节课讲的有关系吗？那个利用哨兵思想简化合并函数的又怎么解？感觉这一节简直莫名其妙，github上也无解。","like_count":0},{"had_liked":false,"id":96279,"user_name":"苏轼","can_delete":false,"product_type":"c1","uid":1018475,"ip_address":"","ucode":"E3C7974B399AB5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/6b/17090872.jpg","comment_is_top":false,"comment_ctime":1558379329,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1558379329","product_id":100017301,"comment_content":"对于思考题，我觉得就是典型的归并排序的应用范围。当年面试的时候面试官问了我类似的问题，当时对方并没有提内存限制的问题，反倒是我自己想多了。面试结束后我反复琢磨，归并排序的玩法应用真是广泛，在分布式的环境下去排序超大规模数据都是没有瓶颈的。","like_count":0},{"had_liked":false,"id":96278,"user_name":"苏轼","can_delete":false,"product_type":"c1","uid":1018475,"ip_address":"","ucode":"E3C7974B399AB5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/6b/17090872.jpg","comment_is_top":false,"comment_ctime":1558379124,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1558379124","product_id":100017301,"comment_content":"常见的数据结构和算法在教科书和课堂上都有所涉猎，但是老师这边见多识广，能把很多算法圈常见的变形应用介绍给我们，让我这种做比较低级工程的大开眼界。这个利用快排来找第K元素的方法真是太酷了。","like_count":0},{"had_liked":false,"id":96257,"user_name":"快乐少年郎","can_delete":false,"product_type":"c1","uid":1488186,"ip_address":"","ucode":"A6DF373FEB50F7","user_header":"https://static001.geekbang.org/account/avatar/00/16/b5/3a/9f2e0d8e.jpg","comment_is_top":false,"comment_ctime":1558366507,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558366507","product_id":100017301,"comment_content":"感觉快排一节的分析不是很清晰，而且图上第一次比较结果写着swap，但并没交换。假如piort点的选取每次都选择中点，i,j游标分别从首尾往中间遍历，直到找到不符合左右区间值范围的时交换，这个作为开始的例子讲解会比较通俗易懂。","like_count":0},{"had_liked":false,"id":96031,"user_name":"Xiao","can_delete":false,"product_type":"c1","uid":1179212,"ip_address":"","ucode":"71FFCCEEDE09E1","user_header":"https://static001.geekbang.org/account/avatar/00/11/fe/4c/46eb517a.jpg","comment_is_top":false,"comment_ctime":1558314457,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1558314457","product_id":100017301,"comment_content":"快排算法，有一点儿还可以优化，就是在merge的时候可以直接比较num1[0] &gt; num2[num2.size-1]，如果是，直接做两个数组连接就可以了。","like_count":0},{"had_liked":false,"id":93939,"user_name":"Teanmy","can_delete":false,"product_type":"c1","uid":1209599,"ip_address":"","ucode":"89F466CC698583","user_header":"","comment_is_top":false,"comment_ctime":1557672461,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557672461","product_id":100017301,"comment_content":"写了找到第K大元素的代码：<br><br>   protected static int partition(int[] arr, int p, int r){<br>        int i = 0;&#47;&#47;为了原地进行分区，这里用i来作为区分，i之前的为小于pivot的数，i之后为待比较的数<br>        int j = 0;&#47;&#47;j做游标，每次从待比较部分取出一个数来和pivot比较，比pivot小则追加到i前面<br>        int tmp;<br><br>        for (; j &lt; r; j ++){<br>            if (arr[j] &lt;= arr[r]){&#47;&#47;&#47;&#47;pivot可随机选取待排序数组中任何一元素，这里选数组最后一个元素<br>                tmp = arr[i];<br>                arr[i++] = arr[j];<br>                arr[j] = tmp;<br>            }<br>        }<br><br>        &#47;&#47;将pivot arr[r]放到区分点，这样pivot左边部分都是比它小的，右边部分都是比它大的<br>        tmp = arr[i];<br>        arr[i] = arr[r];<br>        arr[r] = tmp;<br><br>        return i;<br>    }<br><br>    &#47;&#47;利用快排的分而治之、分区思想，在O(n)内找到第k大的数<br>    public static int findKth(int[]arr, int k){<br>        if (k &gt; arr.length){<br>            return -1;<br>        }else {<br>            return findKth(arr, k-1, 0, arr.length-1);<br>        }<br>    }<br>    private static int findKth(int[] arr, int k, int p, int r){<br>        int q = partition(arr, p, r);<br>        if (q == k) {<br>            return arr[k];<br>        }<br>        else if (q &lt; k) {<br>            return findKth(arr, k,q + 1, r);<br>        }<br>        else {<br>            return findKth(arr, k, p, q - 1);<br>        }<br>    }","like_count":0},{"had_liked":false,"id":93378,"user_name":"CrekerLi","can_delete":false,"product_type":"c1","uid":1512621,"ip_address":"","ucode":"0ABF9CB85DDC5D","user_header":"https://wx.qlogo.cn/mmopen/vi_32/bwRdL4xlf3EZJvwUiaXibQX11IMKenZzXkxiaNZJ9QUO51UBLzLzVCjXjx5ZnDF8Rp2V4TficpfYDmRFMOsVdlnicKg/132","comment_is_top":false,"comment_ctime":1557459830,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557459830","product_id":100017301,"comment_content":"认真看和理解前面一篇的递归思想，是理解今天这两个算法的关键<br>然后将merge和partition这两个方法拆开看，也是很关键的。<br>总的来说，使用递归的方式，我们只需要理解递归的第一步，或者最后一步，（比如归并排序，是先分在和，所以我们重点关注最后一步的合并，以及第一步的拆分），然后把剩下的都交给计算机","like_count":0},{"had_liked":false,"id":91781,"user_name":"danvid","can_delete":false,"product_type":"c1","uid":1270415,"ip_address":"","ucode":"84C50611B1DEA5","user_header":"https://static001.geekbang.org/account/avatar/00/13/62/8f/c0f40d98.jpg","comment_is_top":false,"comment_ctime":1557107101,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557107101","product_id":100017301,"comment_content":"最后的问题：开启多线程，每个文件创建一个线程负责读取数据到各自的缓冲队列，一个读线程负责从缓冲队列中获取数据并比较排序放到读写交互的写缓存队列(队列大小做控制)，一个写线程负责从写缓存队列中获取数据并写入到文件中","like_count":0},{"had_liked":false,"id":91574,"user_name":"saber","can_delete":false,"product_type":"c1","uid":1193468,"ip_address":"","ucode":"D02F8D129DB41C","user_header":"https://static001.geekbang.org/account/avatar/00/12/35/fc/6d3e0035.jpg","comment_is_top":false,"comment_ctime":1557056258,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557056258","product_id":100017301,"comment_content":"https:&#47;&#47;github.com&#47;saber&#47;algorithm <br>这是我的排序算法的所有实现，可以作为参考","like_count":0},{"had_liked":false,"id":91112,"user_name":"犇","can_delete":false,"product_type":"c1","uid":1241705,"ip_address":"","ucode":"CCA66C9BF3EBAB","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/69/a925db7a.jpg","comment_is_top":false,"comment_ctime":1556866916,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556866916","product_id":100017301,"comment_content":"想对李建辉的思路做个补充，我觉得可以在当按行读到内存的时候先不着急往文件里写，先存一部分，然后再统一写入到一个文件里，这样我就能够减少往文件里写的次数，性能就又好了些。","like_count":0},{"had_liked":false,"id":90234,"user_name":"咸鱼浪子心","can_delete":false,"product_type":"c1","uid":1239309,"ip_address":"","ucode":"344A0104956535","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/0d/605b409e.jpg","comment_is_top":false,"comment_ctime":1556455452,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556455452","product_id":100017301,"comment_content":"MergeSort 10个流 每2个合并到一个内存队列,然后再合并,最后的一个合并结果写入文件,避免无效比较.<br>每一个流限制读取大小为X,最大内存消耗为40X,机器内存1G,可用内存约500M.每个流读取大小为12.5M,安全起见设为8M,读取和写入都使用批量接口,减少io次数","like_count":0},{"had_liked":false,"id":90127,"user_name":"南北少卿","can_delete":false,"product_type":"c1","uid":1018958,"ip_address":"","ucode":"DFCC59F2BBD8CE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/4e/b81969fa.jpg","comment_is_top":false,"comment_ctime":1556421512,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556421512","product_id":100017301,"comment_content":"T(n&#47;2^k)=T(1) 这个是怎么回事?","like_count":0},{"had_liked":false,"id":89998,"user_name":"🐷","can_delete":false,"product_type":"c1","uid":1508736,"ip_address":"","ucode":"D489239F4F7279","user_header":"https://static001.geekbang.org/account/avatar/00/17/05/80/9fdb4947.jpg","comment_is_top":false,"comment_ctime":1556360911,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556360911","product_id":100017301,"comment_content":"A[p]就是第p+1大的元素","like_count":0},{"had_liked":false,"id":89898,"user_name":"待我瘦到八十斤","can_delete":false,"product_type":"c1","uid":1273949,"ip_address":"","ucode":"51553E48C2237E","user_header":"https://static001.geekbang.org/account/avatar/00/13/70/5d/2c313dad.jpg","comment_is_top":false,"comment_ctime":1556323763,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556323763","product_id":100017301,"comment_content":"希望写Java代码","like_count":0},{"had_liked":false,"id":89805,"user_name":"tuyu","can_delete":false,"product_type":"c1","uid":1448863,"ip_address":"","ucode":"B235325B541408","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BIRpwViaN51yynIeFonD7QRlwDCVtKibrG956NTxzEqibOZZVjhMMgibOPmd3VicfYxpknZsic1oJq8KicZvXkmmiajuQg/132","comment_is_top":false,"comment_ctime":1556268632,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556268632","product_id":100017301,"comment_content":"老师,IO流这种问题由书推荐吗,不是很懂IO这一块,所以自己写代码很没思路,面试又经常问","like_count":0},{"had_liked":false,"id":89687,"user_name":"ThinkingMan.","can_delete":false,"product_type":"c1","uid":1217603,"ip_address":"","ucode":"722674A8BACA85","user_header":"https://static001.geekbang.org/account/avatar/00/12/94/43/6e68c860.jpg","comment_is_top":false,"comment_ctime":1556244391,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556244391","product_id":100017301,"comment_content":"快排用的是go吗，看着费劲，如果用c的话，大家应该都看得懂吧","like_count":0},{"had_liked":false,"id":87771,"user_name":"jacy","can_delete":false,"product_type":"c1","uid":1103456,"ip_address":"","ucode":"0022A8759DDCE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/60/f21b2164.jpg","comment_is_top":false,"comment_ctime":1555688185,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1555688185","product_id":100017301,"comment_content":"说每个文件取一部分，内存排序，然后追加写文件。这种做法是有bug的，因为基本上没读出的数据，有可能小于内存终于排好序的数据。","like_count":0},{"had_liked":false,"id":87524,"user_name":"jacy","can_delete":false,"product_type":"c1","uid":1103456,"ip_address":"","ucode":"0022A8759DDCE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/60/f21b2164.jpg","comment_is_top":false,"comment_ctime":1555632593,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1555632593","product_id":100017301,"comment_content":"快排partition也可以取中间值为比较点，两端指针向中间移动，找比中间值大或小的位置，然后交换","like_count":0},{"had_liked":false,"id":87082,"user_name":"小邓","can_delete":false,"product_type":"c1","uid":1474505,"ip_address":"","ucode":"1E903D5622D39F","user_header":"https://static001.geekbang.org/account/avatar/00/16/7f/c9/40c609ee.jpg","comment_is_top":false,"comment_ctime":1555509131,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555509131","product_id":100017301,"comment_content":"对找第K大元素问题不理解的同学请直接看 张潇赟 的留言！写的多好，可惜不能回复置顶","like_count":0},{"had_liked":false,"id":87073,"user_name":"小邓","can_delete":false,"product_type":"c1","uid":1474505,"ip_address":"","ucode":"1E903D5622D39F","user_header":"https://static001.geekbang.org/account/avatar/00/16/7f/c9/40c609ee.jpg","comment_is_top":false,"comment_ctime":1555507854,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555507854","product_id":100017301,"comment_content":"归并排序的哨兵，可以用两个布尔值来分别记录两个数组越界情况，如果越界，就在循环里跳过该数组，这样也不用新开其他空间了。","like_count":0},{"had_liked":false,"id":86170,"user_name":"Alery","can_delete":false,"product_type":"c1","uid":1156557,"ip_address":"","ucode":"08F3F49181E67B","user_header":"https://static001.geekbang.org/account/avatar/00/11/a5/cd/3aff5d57.jpg","comment_is_top":false,"comment_ctime":1555319320,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555319320","product_id":100017301,"comment_content":"#include &lt;stdio.h&gt;<br><br>void merge(int arr[], int p, int q, int r) {<br>    int tmp[r-q+1];<br>    int i = p, j = q+1, k = 0;<br>    while (i &lt;= q &amp;&amp; j &lt;= r) {<br>        if (arr[i] &lt; arr[j]) {<br>            tmp[k++] = arr[i++];<br>        } else {<br>            tmp[k++] = arr[j++];<br>        }<br>    }<br><br>    int start = i, end = q;<br>    if (j &lt;= r) {<br>        start = j;<br>        end = r;<br>    }<br>    while (start &lt;= end) {<br>        tmp[k++] = arr[start++];<br>    }<br><br>    for (i = 0; i &lt;= r; i++) {<br>        arr[p+i] = tmp[i];<br>    }<br>}<br><br>void merge_sort_c(int arr[], int p, int r) {<br>    if (p &gt;= r) {<br>        return;<br>    }<br>    int q = (p + r) &#47; 2;<br>    merge_sort_c(arr, p, q);<br>    merge_sort_c(arr, q+1, r);<br>    merge(arr, p, q, r);<br>}<br><br>void merge_sort(int arr[], int n) {<br>    merge_sort_c(arr, 0, n-1);<br>}<br><br>int main(){<br>    int i, n, arr[100];<br>    scanf(&quot;%d&quot;, &amp;n);<br>    for (i = 0; i &lt; n; i++) {<br>        scanf(&quot;%d&quot;, &amp;arr[i]);<br>    }<br>    &#47;&#47;bubble_sort(arr, n);<br>    &#47;&#47;insertion_sort(arr, n);<br>    &#47;&#47;selection_sort(arr, n);<br>    merge_sort(arr, n);<br>    for (i = 0; i &lt; n; i++) {<br>        printf(&quot;%d &quot;, arr[i]);<br>    }<br>    getchar();<br>    getchar();<br><br>}<br>","like_count":0},{"had_liked":false,"id":85440,"user_name":"雷雁鹏","can_delete":false,"product_type":"c1","uid":1110676,"ip_address":"","ucode":"C1D2F50F00ACDA","user_header":"https://static001.geekbang.org/account/avatar/00/10/f2/94/27f8e1e9.jpg","comment_is_top":false,"comment_ctime":1555060705,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555060705","product_id":100017301,"comment_content":"10个日志文件排序问题，考虑到快排和归并排序的平均时间复杂度一致，但快排的空间复杂度为O(1)，在1G内存的情况下，第一阶段先使用快排算法，每次读取3个文件到内存，选取合适的pivot进行快排；一阶段结束后变成3个900M的顺序日志文件和1个300M的顺序日志文件，此时进入第二阶段采用归并排序，但要对归并排序做一些改造，先申请4个100M的内存数组，分别从这4个日志文件中读取数据到这4个内存数组中，同时记录当前数组对应每个文件的offset，对这4个内存数组进行归并merge操作，每次内存数组空了就去文件继续取offset后面的数据到内存，再申请一个400M的内存数组用于保存归并后的结果，当400M的内存数组满了的时候就Flush到磁盘上，循环归并完每个文件，最后生成一个全量的3000M的顺序日志文件。","like_count":0},{"had_liked":false,"id":84461,"user_name":"暮晨","can_delete":false,"product_type":"c1","uid":1135928,"ip_address":"","ucode":"85FE51AB3DE631","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/38/e7de5c6e.jpg","comment_is_top":false,"comment_ctime":1554867190,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554867190","product_id":100017301,"comment_content":"解答部分重，“如果 p+1=K，那 A[p] 就是要求解的元素。” 这一句应该是p=K, A[p]是要求解的元素吧？","like_count":0},{"had_liked":false,"id":84111,"user_name":"H.L.","can_delete":false,"product_type":"c1","uid":1207529,"ip_address":"","ucode":"125D13548A0CA5","user_header":"https://static001.geekbang.org/account/avatar/00/12/6c/e9/377a3b09.jpg","comment_is_top":false,"comment_ctime":1554786835,"is_pvip":false,"replies":[{"id":"30475","content":"好像你理解的不对呢","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1554939344,"ip_address":"","comment_id":84111,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554786835","product_id":100017301,"comment_content":"可以为每个文件分配一个40M的数组，再另外分配一个400M的数组储存归并结果，每个文件每次读取40M，对十个数组做归并排序直到其中某个数组的数据被处理完，这时将归并结果写入磁盘，处理完的数组继续读入40M继续参与归并，以此类推，直到所有文件都处理完<br><br>--------------------------------<br>这个是有问题的，每次归并后，最多只能将40M写入新文件，因为磁盘里面的不一定都是比内存的时间戳小啊，比方说第一个文件的第40M到80M数据，可能存在比第二个文件的0～40M数据时间戳小的数据","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446255,"discussion_content":"好像你理解的不对呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554939344,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84110,"user_name":"H.L.","can_delete":false,"product_type":"c1","uid":1207529,"ip_address":"","ucode":"125D13548A0CA5","user_header":"https://static001.geekbang.org/account/avatar/00/12/6c/e9/377a3b09.jpg","comment_is_top":false,"comment_ctime":1554786714,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554786714","product_id":100017301,"comment_content":"可以为每个文件分配一个40M的数组，再另外分配一个400M的数组储存归并结果，每个文件每次读取40M，对十个数组做归并排序直到其中某个数组的数据被处理完，这时将归并结果写入磁盘，处理完的数组继续读入40M继续参与归并，以此类推，直到所有文件都处理完","like_count":0},{"had_liked":false,"id":83906,"user_name":"Rolle","can_delete":false,"product_type":"c1","uid":1168851,"ip_address":"","ucode":"6BC3DD2BFD9726","user_header":"https://static001.geekbang.org/account/avatar/00/11/d5/d3/4b0e8142.jpg","comment_is_top":false,"comment_ctime":1554731473,"is_pvip":true,"replies":[{"id":"31016","content":"分析复杂度的时候，我默认每次大约从中间分区，至于如何做到的，请看下一节课。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1555381237,"ip_address":"","comment_id":83906,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554731473","product_id":100017301,"comment_content":"k大的算法，为什么每次都是２分呢？分区的位置不可能都在中间吧，那么怎么会“分区遍历元素的个数分别为、n&#47;2、n&#47;4、n&#47;8、n&#47;16“","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446176,"discussion_content":"分析复杂度的时候，我默认每次大约从中间分区，至于如何做到的，请看下一节课。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555381237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83465,"user_name":"Geek_04e22a","can_delete":false,"product_type":"c1","uid":1184505,"ip_address":"","ucode":"B64FF12EA28BA6","user_header":"https://static001.geekbang.org/account/avatar/00/12/12/f9/7e6e3ac6.jpg","comment_is_top":false,"comment_ctime":1554609713,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554609713","product_id":100017301,"comment_content":"很重要的一点，计算中点时，不要mid = (p + q)&#47; 2,容易超出int类型范围，使用mid = p + (q-p)&#47;2不会出现这种问题","like_count":0},{"had_liked":false,"id":83453,"user_name":"Lucus","can_delete":false,"product_type":"c1","uid":1198800,"ip_address":"","ucode":"CE8EB70CB9D9F1","user_header":"https://static001.geekbang.org/account/avatar/00/12/4a/d0/d319c44a.jpg","comment_is_top":false,"comment_ctime":1554606983,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554606983","product_id":100017301,"comment_content":"如果知道接口访问的时间范围，划分成10个区间，然后遍历10个文件把落在某个区间的记录分到10个新文件中，再分别对10个新文件用快排。最后直接依次合并10个文件就可以了","like_count":0},{"had_liked":false,"id":83139,"user_name":"好好学习","can_delete":false,"product_type":"c1","uid":1258789,"ip_address":"","ucode":"63A002997462E3","user_header":"https://static001.geekbang.org/account/avatar/00/13/35/25/bab760a1.jpg","comment_is_top":false,"comment_ctime":1554435044,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554435044","product_id":100017301,"comment_content":"最后的解答开篇的最坏情况时间复杂度也会是O(n^2)吧","like_count":0},{"had_liked":false,"id":82965,"user_name":"立冬","can_delete":false,"product_type":"c1","uid":1467313,"ip_address":"","ucode":"287FA88D933FD5","user_header":"https://static001.geekbang.org/account/avatar/00/16/63/b1/a6103703.jpg","comment_is_top":false,"comment_ctime":1554360859,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554360859","product_id":100017301,"comment_content":"思考题 有序可以互相比较后插入","like_count":0},{"had_liked":false,"id":82695,"user_name":"tao.py","can_delete":false,"product_type":"c1","uid":1473336,"ip_address":"","ucode":"27229157D1BB38","user_header":"https://static001.geekbang.org/account/avatar/00/16/7b/38/9dfc2aad.jpg","comment_is_top":false,"comment_ctime":1554278722,"is_pvip":false,"replies":[{"id":"30240","content":"没区别哈","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1554680212,"ip_address":"","comment_id":82695,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554278722","product_id":100017301,"comment_content":"请教老师，为什么一般选最后一个元素作为分区点？<br>选第一个元素和选最后一个元素，是否会有区别？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445689,"discussion_content":"没区别哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554680212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82483,"user_name":"勇敢的心","can_delete":false,"product_type":"c1","uid":1263940,"ip_address":"","ucode":"5C3D6530C1C56C","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/44/55b22584.jpg","comment_is_top":false,"comment_ctime":1554220870,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1554220870","product_id":100017301,"comment_content":"快排的图，怎么看不懂，6&lt;8需要交换，交换了什么，怎么交换，我看图没有任何变化啊，请指教。","like_count":0,"discussions":[{"author":{"id":1329116,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/BJjGmy4ooNjeURBDhVeJ7EslNbyVd6jNricALVsx1QriczD2EXddKLkXxLQK02nExosCJdyfvicVcZwfpDk64iazmQ/132","nickname":"style_月月","note":"","ucode":"59489E1BDB0090","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70306,"discussion_content":"交换是指交换的下标为i和j的元素，在6<8时，i和j都指向6，所以所谓的交换就是6和6本身的交换，其实还是6","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575344154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82012,"user_name":"L.Messi","can_delete":false,"product_type":"c1","uid":1204364,"ip_address":"","ucode":"617C37A23380B1","user_header":"https://static001.geekbang.org/account/avatar/00/12/60/8c/742cd162.jpg","comment_is_top":false,"comment_ctime":1554102678,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554102678","product_id":100017301,"comment_content":"看到一些用户都在问了一个问题：“在一个数组中找第k大的数这个问题中，为什么如果p+1=k，a[p]就是要查找的结果呢？”<br>这个问题我一开始想也疑惑，不过后来画一下数组图就明白了：因为数组是从0开始算的，所以假设数组有序，想在数组中找到第K大的数，那么对应那个数的下标其实是 K-1 ！！回到原题，pivot已经被放到了数组的p位置，那么它其实就是第p+1大的元素！","like_count":0},{"had_liked":false,"id":80289,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1553647322,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553647322","product_id":100017301,"comment_content":"开始学的费劲了。","like_count":0},{"had_liked":false,"id":79651,"user_name":"lyh","can_delete":false,"product_type":"c1","uid":1247951,"ip_address":"","ucode":"A35C3AEE94C37E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLBWjSjrBYr4DpMktO8XeRnpXeJFLWP0kpiaKFlsoeOoCN87PUDfbqicjPibuWIH4rdyoa0hE1iannzVKg/132","comment_is_top":false,"comment_ctime":1553516434,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553516434","product_id":100017301,"comment_content":"归并排序：<br>void merge(int a[], int p, int q, int r) {<br>\tint *aa = (int *)malloc((r - p + 1)*sizeof(int));<br>\tif (aa == NULL) {<br>\t\tabort();<br>\t}<br>\tint i, j, k;<br>\tfor (i = p, j = q + 1, k = 0; i &lt;= q &amp;&amp; j &lt;= r; ){<br>\t\tif (a[i] &gt; a[j]) {<br>\t\t\taa[k] = a[j];<br>\t\t\tj++;<br>\t\t}else {<br>\t\t\taa[k] = a[i];<br>\t\t\ti++;<br>\t\t}<br>\t\tk++;<br>\t}<br><br>\tif (i == q + 1) {<br>\t\tmemcpy(&amp;aa[k], &amp;a[j], (r - j + 1)*sizeof(int));<br>\t}<br>\telse<br>\t{<br>\t\tmemcpy(&amp;aa[k], &amp;a[i], (q - i + 1)*sizeof(int));<br>\t}<br>\tmemcpy(&amp;a[p], aa, (r - p + 1) *sizeof(int));<br>\tfree(aa);<br>\taa = NULL;<br>}<br><br>void merge_sort_c(int a[], int p, int r) {<br>\tif (p &gt;= r)<br>\t\treturn;<br>\tint q = (p + r) &#47; 2;<br>\tmerge_sort_c(a, p, q);<br>\tmerge_sort_c(a, q+1, r);<br>\tmerge(a, p, q, r);<br>}<br><br>void merge_sort(int a[], int size) {<br>\tif (size &lt;= 1) {<br>\t\treturn;<br>\t}<br>\tmerge_sort_c(a, 0, size - 1);<br>}","like_count":0},{"had_liked":false,"id":78582,"user_name":"lyh","can_delete":false,"product_type":"c1","uid":1247951,"ip_address":"","ucode":"A35C3AEE94C37E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLBWjSjrBYr4DpMktO8XeRnpXeJFLWP0kpiaKFlsoeOoCN87PUDfbqicjPibuWIH4rdyoa0hE1iannzVKg/132","comment_is_top":false,"comment_ctime":1553178645,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553178645","product_id":100017301,"comment_content":"快排：<br>void swap(int a[], int i, int j){<br>\tint tmp = a[j];<br>\ta[j] = a[i];<br>\ta[i] = tmp;<br>}<br><br>int partition(int a[], int p, int r){<br>\tint x = a[r];<br>\tint i = p;<br>\tfor (int j = p; j &lt; r; j++) {<br>\t\tif (x &gt; a[j]) {<br>\t\t\tswap(a, i, j);<br>\t\t\ti++;<br>\t\t}<br>\t}<br>\tswap(a, i, r);<br>\treturn i;<br>}<br><br>void qucikU(int a[], int p, int r){<br>\tif (p &gt;= r) {<br>\t\treturn;<br>\t}<br><br>\tint q = partition(a, p, r);<br>\tqucikU(a, p, q - 1);<br>\tqucikU(a, q + 1, r);<br>}<br><br>void quick(int a[], int size){<br>\tqucikU(a, 0, size - 1);<br>}","like_count":0},{"had_liked":false,"id":78561,"user_name":"卡布","can_delete":false,"product_type":"c1","uid":1188032,"ip_address":"","ucode":"BB8C34DE1D67D9","user_header":"https://static001.geekbang.org/account/avatar/00/12/20/c0/6367536e.jpg","comment_is_top":false,"comment_ctime":1553175716,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553175716","product_id":100017301,"comment_content":"小白一个，学着学着越发感觉到数据结构和算法的美。先大概浏览一遍文章，对着代码敲敲，再看一遍文章，会恍悟很多细节的内容，真的好享受着这过程，学起来真的太舒服了。之前觉得伪代码看起来不爽，现在尝试对着代码看文章，思考其中的解析过程，超棒！很谢谢 王sir 的专栏","like_count":0},{"had_liked":false,"id":78358,"user_name":"张潇赟","can_delete":false,"product_type":"c1","uid":1132192,"ip_address":"","ucode":"1A45B57F9E0723","user_header":"https://static001.geekbang.org/account/avatar/00/11/46/a0/aa6d4ecd.jpg","comment_is_top":false,"comment_ctime":1553133258,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553133258","product_id":100017301,"comment_content":"快速排序java版本实现<br>&#47;**<br>     * 和归并排序的思路大致相同，把任务分为0~q和q~endIndex两个子任务<br>     * 快排是找到分区点，然后将小于分区点的数全部移到前面，大于分区点的数全部移到分区点后面<br>     * 时间复杂度O(nlogn)推到过程没看明白，空间复杂度O(1) 不稳定排序 原地排序算法<br>     * @param a<br>     * @param startIndex<br>     * @param endIndex<br>     *&#47;<br>    public static void quickSort(int[] a, int startIndex, int endIndex) {<br>        if (startIndex &gt;= endIndex) {<br>            return;<br>        }<br>        int position = partionIndex(a, startIndex, endIndex);<br>        quickSort(a, startIndex, position-1);<br>        quickSort(a, position+1 , endIndex);<br>    }<br><br>    &#47;**<br>     * 选择数组最后一个元素未分区的值<br>     * 用两个指针 i j，记录数组开始位置，挨个比较是否比分区值小，如果a[j]小于分区值i和j值互换i自增1，j自增1，<br>     * 如果a[j]不小于分区值，那么只有j自增1，i维持原位置不变，把数组前全部小于分区值，后半段全部大于分区值，数组的最后位置记录的是分区值，i记录的是第一个大于分区值得数<br>     * 最后将i和最后位置得值互换，i即为分区位置<br>     * @param a<br>     * @param startIndex<br>     * @param endIndex<br>     * @return<br>     *&#47;<br>    private static int partionIndex(int[] a, int startIndex, int endIndex) {<br>        int positionIndex=startIndex;<br>        int j=startIndex;<br>        int temp ;<br>        for (; j &lt; endIndex; j++) {<br>            if (a[j] &lt; a[endIndex]) {<br>                if (positionIndex != j) {<br>                    temp = a[positionIndex];<br>                    a[positionIndex] = a[j];<br>                    a[j] = temp;<br>                }<br>                positionIndex+=1;<br>            }<br>        }<br>        if (positionIndex == endIndex) {<br>&#47;&#47;            positionIndex = endIndex-1;<br>        }else{<br>            temp = a[endIndex];<br>            a[endIndex]=a[positionIndex];<br>            a[positionIndex] = temp;<br>        }<br>        return positionIndex;<br>    }","like_count":0},{"had_liked":false,"id":78356,"user_name":"张潇赟","can_delete":false,"product_type":"c1","uid":1132192,"ip_address":"","ucode":"1A45B57F9E0723","user_header":"https://static001.geekbang.org/account/avatar/00/11/46/a0/aa6d4ecd.jpg","comment_is_top":false,"comment_ctime":1553133235,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553133235","product_id":100017301,"comment_content":"归并排序java版本<br> &#47;**<br>     * 归并排序，对于长度为n的数组可以分为0~n&#47;2和(n&#47;2)+1~n-1两个数组分别排序，一直分到每个数组里只有一个数据。<br>     * 然后把每个子数组按照大小拼接在一起，拼接的时候申请一个temp数组，比较连个自数据的第一个位置的数据大小那个数据小那个先插入到temp里面<br>     * 最后将还有数据的子数组全部拼接在temp后面<br>     * 在将temp的数据复制到原始数据对应的位置<br>     * 时间复杂度O(nlogn)推到过程没看明白，空间复杂度O(n) 稳定排序 需要额外空间非原地排序算法<br>     * @param a<br>     * @param startIndex<br>     * @param endIndex<br>     *&#47;<br>    public static void mergeSort(int[] a, int startIndex, int endIndex) {<br>        System.err.println(&quot;startIndex &quot;+startIndex+&quot; endIndex &quot;+endIndex);<br>        &#47;&#47;如果开始位置和结束位置相同，表示子任务中只有一个数据<br>        if (startIndex &gt;= endIndex) {<br>            return;<br>        }<br>        int p = (endIndex+startIndex)&#47;2;<br>        &#47;&#47;将排序任务分为两个子任务<br>        mergeSort(a, startIndex, p);<br>        mergeSort(a, p + 1, endIndex);<br>        &#47;&#47;将startIndex-》p 和p+1 -》endIndex两个数组比较然后合并<br>        merge(a, startIndex, endIndex, p);<br>    }<br><br>    private static void merge(int[] a, int p, int r, int mid) {<br>        System.err.println(&quot;p &quot;+p+&quot; r &quot;+r+&quot; mid &quot;+mid);<br>        int j = mid+1;<br>        int[] temp = new int[r - p + 1];<br>        int i = p;<br>        int k = 0;<br>        &#47;&#47;通过比较将比较小的值复制给temp的对应位置<br>        while (i&lt;=mid &amp;&amp; j&lt;=r){<br>            if (a[i] &lt;= a[j]) {<br>                temp[k++] = a[i];<br>                i+=1;<br>            }else{<br>                temp[k++] = a[j];<br>                j+=1;<br>            }<br>        }<br>        &#47;&#47;将未处理完的数据复制到temp的后面<br>        int start =i&gt;mid?j:i;<br>        int end = i&gt;mid?r:mid;<br>        while (start &lt;= end) {<br>            temp[k++] = a[start++];<br>        }<br>        &#47;&#47;将temp中的数据复制到原数组中<br>        for (int index = 0; index &lt; temp.length; index++) {<br>            a[p + index] = temp[index];<br>        }<br>    }","like_count":0},{"had_liked":false,"id":76889,"user_name":"小样","can_delete":false,"product_type":"c1","uid":1446283,"ip_address":"","ucode":"4E43FBF236AEB8","user_header":"https://static001.geekbang.org/account/avatar/00/16/11/8b/47f65375.jpg","comment_is_top":false,"comment_ctime":1552739697,"is_pvip":false,"replies":[{"id":"28111","content":".cc就是.cpp","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1552874174,"ip_address":"","comment_id":76889,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552739697","product_id":100017301,"comment_content":"这个gitHub上面的代码，文件名 .c和.cc代表的是啥意思，之前我们学的都是.h代表头文件  .cpp代表源文件","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443488,"discussion_content":".cc就是.cpp","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552874174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76195,"user_name":"艾绒老大","can_delete":false,"product_type":"c1","uid":1451986,"ip_address":"","ucode":"199F2846DA248C","user_header":"https://static001.geekbang.org/account/avatar/00/16/27/d2/d9f09478.jpg","comment_is_top":false,"comment_ctime":1552547797,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552547797","product_id":100017301,"comment_content":"    public void quickSort(int[] data, int start, int end) {<br>        if (data == null || start &gt;= end) return;<br>        int i = start, j = end;<br>        int pivotKey = data[start];<br>        while (i &lt; j) {<br>            while (i &lt; j &amp;&amp; data[j] &gt;= pivotKey) j--;<br>            if (i &lt; j) data[i++] = data[j];<br>            while (i &lt; j &amp;&amp; data[i] &lt;= pivotKey) i++;<br>            if (i &lt; j) data[j--] = data[i];<br>        }<br>        data[i] = pivotKey;<br>        quickSort_2(data, start, i - 1);<br>        quickSort_2(data, i + 1, end);<br>    }","like_count":0},{"had_liked":false,"id":76188,"user_name":"张珂","can_delete":false,"product_type":"c1","uid":1451555,"ip_address":"","ucode":"63D5760B253A59","user_header":"https://static001.geekbang.org/account/avatar/00/16/26/23/e99ff49f.jpg","comment_is_top":false,"comment_ctime":1552546832,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552546832","product_id":100017301,"comment_content":"课后思考题没想到很好的方法，只能说一下自己的思路。<br>1G的内存无法同时读取10个日志文件，因此要采用分治的思想。比如每次读取2个文件的一半内容，各读取其第一条日志，再新建一个文件，比较两条日志，将时间戳较小的日志写入新文件，再读取该文件的下一条日志，继续比较。这样写入完成之后再读取这2个文件的另一半内容，再次比较完成之后就实现了2个文件的日志整个。剩余8个文件也照此完成后，就得到了4个较大的文件，这4个文件也按照部分读取的方式，既可以整合所有文件了。","like_count":0},{"had_liked":false,"id":75863,"user_name":"刘十一","can_delete":false,"product_type":"c1","uid":1035899,"ip_address":"","ucode":"5927D77D248E30","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ce/7b/fa0f9368.jpg","comment_is_top":false,"comment_ctime":1552484223,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552484223","product_id":100017301,"comment_content":"先依次对10个文件进行排序，然后写回去，得到10个有序的日志文件，然后读取10个日志文件中的前n条，这个n不超过1GB然后进行排序，排好序之后写入一个新的文件A中，这样不断重复最后新文件A就是有序的日志信息了。还是老师今天说的分治思想，空间复杂度为O(n)，时间复杂度的话不知道怎么算了","like_count":0},{"had_liked":false,"id":75862,"user_name":"小样","can_delete":false,"product_type":"c1","uid":1446283,"ip_address":"","ucode":"4E43FBF236AEB8","user_header":"https://static001.geekbang.org/account/avatar/00/16/11/8b/47f65375.jpg","comment_is_top":false,"comment_ctime":1552483908,"is_pvip":false,"replies":[{"id":"27707","content":"只会有一个子数组中的有数据剩余的。你可以自己写成代码，debug调试一下，就清楚了。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1552531554,"ip_address":"","comment_id":75862,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552483908","product_id":100017301,"comment_content":"麻烦问一下<br>  &#47;&#47; 判断哪个子数组中有剩余的数据<br>  var start := i，end := q<br>  if j&lt;=r then start := j, end:=r<br>  <br>这段伪代码，判断是合并两个有序数组，后面那个数组有没有剩余数据，那前面的不用判断吗，还是我没理解好这段打码，不太清楚，前面那个数组咋判断有无剩余数据的。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443062,"discussion_content":"只会有一个子数组中的有数据剩余的。你可以自己写成代码，debug调试一下，就清楚了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552531554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74802,"user_name":"天空只能仰望？","can_delete":false,"product_type":"c1","uid":1102357,"ip_address":"","ucode":"D87BF6A57DAB42","user_header":"https://static001.geekbang.org/account/avatar/00/10/d2/15/4d43d05a.jpg","comment_is_top":false,"comment_ctime":1552299455,"is_pvip":false,"replies":[{"id":"27714","content":"是不是分区不够平均，导致递归层次很深，栈溢出了。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1552532050,"ip_address":"","comment_id":74802,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552299455","product_id":100017301,"comment_content":"老师，我参考你github案例编写出快排算法和归并排序算法，在测试性能时候，我的测试数据数组是100000个逆序int数组，即 1000000 .... 1 ，归并排序可以快速排序出结果，但是快速排序运行出现 Exception in thread &quot;main&quot; java.lang.StackOverflowError 栈溢出异常了，没有想出原因，请老师指教一下！！","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442685,"discussion_content":"是不是分区不够平均，导致递归层次很深，栈溢出了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552532050,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74158,"user_name":"candyleer","can_delete":false,"product_type":"c1","uid":1097928,"ip_address":"","ucode":"E0BFB6416E6384","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/c8/860714e7.jpg","comment_is_top":false,"comment_ctime":1552119219,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1552119219","product_id":100017301,"comment_content":"如果我们把每次分区遍历的元素个数加起来，就是：就是：n+n&#47;2+n&#47;4+n&#47;8+…+1。这是一个等比数列求.和最后的和等于 2n-1。<br>这个2n-1是怎么算出来的?这也不是一个标准的等比数列","like_count":0,"discussions":[{"author":{"id":1031734,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/be/36/abb7bfe3.jpg","nickname":"xenoblade3","note":"","ucode":"620DD0491EEFF3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1383,"discussion_content":"这是等比数列，a(1)=n,a(2)=n/2,a(3)=n/4,等比是1/2，只不过我求和这个应该是n(1+1/2+1/4+...+1/n)，当n趋于无穷大时，应该是2n，减1是怎么来的我也没有看懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562592335,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73541,"user_name":"ClarkWang","can_delete":false,"product_type":"c1","uid":1269254,"ip_address":"","ucode":"3BF5334CBDEA4E","user_header":"https://static001.geekbang.org/account/avatar/00/13/5e/06/eb1399ac.jpg","comment_is_top":false,"comment_ctime":1551921920,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551921920","product_id":100017301,"comment_content":"partition(A, p, r) {<br>  pivot := A[r]<br>  i := p<br>  for j := p to r-1 do {<br>    if A[j] &lt; pivot {<br>      swap A[i] with A[j]<br>      i := i+1<br>    }<br>  }<br>  swap A[i] with A[r]<br>  return i<br><br>这一步要     if A[j] &lt;= pivot  ，不然排序里出现2个相邻的相等数字时，会死循环；<br>","like_count":0},{"had_liked":false,"id":73314,"user_name":"康斯坦丁","can_delete":false,"product_type":"c1","uid":1368096,"ip_address":"","ucode":"C130E800E8D5C9","user_header":"https://static001.geekbang.org/account/avatar/00/14/e0/20/003190c1.jpg","comment_is_top":false,"comment_ctime":1551857527,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551857527","product_id":100017301,"comment_content":"归并.<br><br>5 + 5\t\t\t\t   从磁盘读取500M内容到内存中，处理完刷新到磁盘中.<br><br>2 + 3  +  2 + 3        从磁盘读取500M内容到内存中，处理完刷新到磁盘中.<br><br>2 + 2 + 1 + 2 + 2 + 1  内存中操作<br><br>时间复杂度:O(nLogN), 空间复杂度O(n)<br>","like_count":0},{"had_liked":false,"id":73152,"user_name":"李伟","can_delete":false,"product_type":"c1","uid":1239462,"ip_address":"","ucode":"F0EF60EB250B20","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/a6/69907ec1.jpg","comment_is_top":false,"comment_ctime":1551832570,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1551832570","product_id":100017301,"comment_content":"虽然有点懵懵懂懂，但是还是要继续坚持，死磕","like_count":0},{"had_liked":false,"id":72386,"user_name":"∮黑洞の视界","can_delete":false,"product_type":"c1","uid":1159392,"ip_address":"","ucode":"F4DC9965D3CB78","user_header":"https://static001.geekbang.org/account/avatar/00/11/b0/e0/adb0fca6.jpg","comment_is_top":false,"comment_ctime":1551604945,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551604945","product_id":100017301,"comment_content":"试着写了下归并排序<br>class Program<br>{<br>    static void Main(string[] args)<br>    {<br>        int[] arr = { 11, 8, 3, 9, 7, 1, 2, 5 };<br><br>        MergeSort(arr, 0, arr.Length - 1);<br><br>    }<br><br>    static void MergeSort(int[] arr, int start, int end)<br>    {<br>        if (start &gt;= end)<br>        {<br>            return;<br>        }<br><br>        int mid = (end + start) &#47; 2;<br><br>        MergeSort(arr, start, mid);<br>        MergeSort(arr, mid + 1, end);<br><br>        Merge(arr, start, end);<br>    }<br><br>    static void Merge(int[] arr, int start, int end)<br>    {<br>        int mid = (end + start) &#47; 2;<br><br>        int i = start;<br>        int j = mid + 1;<br>        int k = 0;<br>        int[] tmp = new int[end - start + 1];<br><br>        while (i &lt;= mid &amp;&amp; j &lt;= end)<br>        {<br>            if (arr[i] &lt;= arr[j]) tmp[k++] = arr[i++];<br>            else tmp[k++] = arr[j++];<br>        }<br><br>        while (i &lt;= mid)<br>        {<br>            tmp[k++] = arr[i++];<br>        }<br><br>        while (j &lt;= end)<br>        {<br>            tmp[k++] = arr[j++];<br>        }<br><br>        for (int c = 0; c &lt; tmp.Length; c++)<br>        {<br>            arr[c + start] = tmp[c];<br>        }<br>    }<br>}<br><br>","like_count":0},{"had_liked":false,"id":72004,"user_name":"好人","can_delete":false,"product_type":"c1","uid":1439552,"ip_address":"","ucode":"8BA995A57F7E1A","user_header":"https://static001.geekbang.org/account/avatar/00/15/f7/40/cba812dc.jpg","comment_is_top":false,"comment_ctime":1551497532,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551497532","product_id":100017301,"comment_content":"感谢老师，以前一直不大理解快排和归并算法，这次思想基本明白了，接下来就是好好实现了。哈哈(ಡωಡ)hiahiahia。","like_count":0},{"had_liked":false,"id":71079,"user_name":"Footman","can_delete":false,"product_type":"c1","uid":1252463,"ip_address":"","ucode":"347C9D3941E664","user_header":"https://static001.geekbang.org/account/avatar/00/13/1c/6f/9b3243b0.jpg","comment_is_top":false,"comment_ctime":1551259897,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551259897","product_id":100017301,"comment_content":"快排的递推公式是不是少加了一个 p 元素","like_count":0},{"had_liked":false,"id":70089,"user_name":"daniel","can_delete":false,"product_type":"c1","uid":1370456,"ip_address":"","ucode":"3516AF7F9A4DEA","user_header":"https://static001.geekbang.org/account/avatar/00/14/e9/58/397a4ab2.jpg","comment_is_top":false,"comment_ctime":1550993356,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550993356","product_id":100017301,"comment_content":"我看了两天还没写出来😓 归并直接操作数组和合数组要判断挺多边缘条件的 ... ","like_count":0},{"had_liked":false,"id":69917,"user_name":"bruce bao","can_delete":false,"product_type":"c1","uid":1020381,"ip_address":"","ucode":"D4722704372856","user_header":"https://static001.geekbang.org/account/avatar/00/0f/91/dd/d2d02871.jpg","comment_is_top":false,"comment_ctime":1550904752,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550904752","product_id":100017301,"comment_content":"每个文件读取100M数据，快速排序前100M数据，写入排好的数据到磁盘，继续每个文件读取补足100M，直到所有文件读取完成，剩余数据快速排序，写入磁盘","like_count":0},{"had_liked":false,"id":69542,"user_name":"xfan","can_delete":false,"product_type":"c1","uid":1315147,"ip_address":"","ucode":"48ED8D498D7F56","user_header":"https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg","comment_is_top":false,"comment_ctime":1550761969,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550761969","product_id":100017301,"comment_content":"我反而认为伪代码简明清楚，我可以用任何一种语言实现，","like_count":0},{"had_liked":false,"id":69470,"user_name":"港岛妹夫","can_delete":false,"product_type":"c1","uid":1097416,"ip_address":"","ucode":"9F6AAA29B60D8F","user_header":"https://static001.geekbang.org/account/avatar/00/10/be/c8/7c5f324f.jpg","comment_is_top":false,"comment_ctime":1550752326,"is_pvip":false,"replies":[{"id":"24708","content":"在数据量大的时候，用归并的原因是：快排的时间复杂度不稳定，极端情况下，分区很不均匀，会导致退化为O(N^2)。而归并排序的时间复杂度及其稳定。当然，内存的消耗会更多，这个估计Java也多少有权衡，很难从理论上分析哪个更优！","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550802408,"ip_address":"","comment_id":69470,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1550752326","product_id":100017301,"comment_content":"老师, 这是我第一次写留言. 我有个疑问. <br>Java的Arrays.sort()方法.  <br>在数据量较小(小于一个常量值, 刚看了源码 这个常量值是47)的时候, 用的是插入排序. 这个我能理解为什么选择插入排序. 因为数据规模小, 而且稳定. <br>在大于这个常量值(47)小于第二个阈值(286)的时候, 做一些调整然后用快速排序. <br>在大于286的时候, 用了归并排序. <br>这里我就不明白了, 都是在内存中的排序, 归并和快排是基于什么考虑做出的选择呢? 为什么这么用呢?  按我的理解, 应该选一种就足够了, 处于稳定考虑可以用归并, 不然可以用快排.  或者, 数据量如果很大(都是在内存中), 不是应该快排更好一些吗?<br><br>还麻烦厉害的同学和老师帮忙解惑一下.  ","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440136,"discussion_content":"在数据量大的时候，用归并的原因是：快排的时间复杂度不稳定，极端情况下，分区很不均匀，会导致退化为O(N^2)。而归并排序的时间复杂度及其稳定。当然，内存的消耗会更多，这个估计Java也多少有权衡，很难从理论上分析哪个更优！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550802408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":69172,"user_name":"好运连连","can_delete":false,"product_type":"c1","uid":1105081,"ip_address":"","ucode":"2A339281321E2A","user_header":"https://static001.geekbang.org/account/avatar/00/10/dc/b9/946b181d.jpg","comment_is_top":false,"comment_ctime":1550672694,"is_pvip":false,"replies":[{"id":"24612","content":"嗯嗯 如果考虑递归栈的消耗的话是O(logn)","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550717092,"ip_address":"","comment_id":69172,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1550672694","product_id":100017301,"comment_content":"老师，快排的空间复杂度究竟是O(1)还是O(logn)?网上说的都是后者多？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439981,"discussion_content":"嗯嗯 如果考虑递归栈的消耗的话是O(logn)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550717092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":68305,"user_name":"小小","can_delete":false,"product_type":"c1","uid":1321715,"ip_address":"","ucode":"F75E2F68E7FB69","user_header":"https://static001.geekbang.org/account/avatar/00/14/2a/f3/4d712bfc.jpg","comment_is_top":false,"comment_ctime":1550480953,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550480953","product_id":100017301,"comment_content":"思考题说的是不是就是多路归并啊","like_count":0},{"had_liked":false,"id":68057,"user_name":"weimin","can_delete":false,"product_type":"c1","uid":1354721,"ip_address":"","ucode":"C94DD3DE451885","user_header":"https://static001.geekbang.org/account/avatar/00/14/ab/e1/14cf564b.jpg","comment_is_top":false,"comment_ctime":1550399027,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550399027","product_id":100017301,"comment_content":"    public static void quickSort(int[] arr,int low,int high){<br>        int i,j,base;<br>        if(low&gt;high){<br>            return;<br>        }<br>        i=low;<br>        j=high;<br>        &#47;&#47;base就是基准位<br>        base = arr[low];<br> <br>        while (i&lt;j) {<br>            &#47;&#47;先看右边，依次往左递减<br>            while (base&lt;=arr[j]&amp;&amp;i&lt;j) {<br>                j--;<br>            }<br>            &#47;&#47;再看左边，依次往右递增<br>            while (base&gt;=arr[i]&amp;&amp;i&lt;j) {<br>                i++;<br>            }<br>            &#47;&#47;如果满足条件则交换<br>            if (i&lt;j) {<br>                int tmp = arr[j];<br>                arr[j] = arr[i];<br>                arr[i] = tmp;<br>            }<br>        }<br>        &#47;&#47;最后将基准为与i和j相等位置的数字交换<br>         arr[low] = arr[i];<br>         arr[i] = base;<br>        &#47;&#47;递归调用左半数组<br>        quickSort(arr, low, j-1);<br>        &#47;&#47;递归调用右半数组<br>        quickSort(arr, j+1, high);<br>    }","like_count":0},{"had_liked":false,"id":66995,"user_name":"biepa","can_delete":false,"product_type":"c1","uid":1399708,"ip_address":"","ucode":"12F8B646000A66","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6vz8MgZia6XzLCTJcuTLCgsJJt2OvE90XPibxjojybic081Zhso0mwBohUn8ovnnXarYJq0geWjxH1AfcX5cGib8fQ/132","comment_is_top":false,"comment_ctime":1550052343,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550052343","product_id":100017301,"comment_content":"没有代码还是差很多的，因为有很多实现细节需要注意，talk is cheap这个不是大佬们的口头禅吗<br>","like_count":0},{"had_liked":false,"id":66481,"user_name":"阿水","can_delete":false,"product_type":"c1","uid":1398067,"ip_address":"","ucode":"3DCDB207E74D56","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/45SXZd1sHQlVzn3B3Q1TNJMFRhWECbzAN7ib3SsSQCNTzPRXf9SocPvqTBlGS6PpibM1CDXlfgba61iaQafbT63OA/132","comment_is_top":false,"comment_ctime":1549945729,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549945729","product_id":100017301,"comment_content":"分析归并排序时间复杂度时为什么要让T(n&#47;2^k)=T(1)，这是什么意思？","like_count":0},{"had_liked":false,"id":66251,"user_name":"NetworkCavalry","can_delete":false,"product_type":"c1","uid":1240799,"ip_address":"","ucode":"65D9C87B50666F","user_header":"https://static001.geekbang.org/account/avatar/00/12/ee/df/b3d09ee7.jpg","comment_is_top":false,"comment_ctime":1549897205,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549897205","product_id":100017301,"comment_content":"几个月前第一次看的时候，一头雾水，迷迷糊糊的了解大概的思想，代码也没有具体实现，今天要写一个快排算法的时候突然想起来这个订阅。。然后果断又把文章看了一遍，觉得老师这次讲的十分通透，一遍就过了。非常感谢！！","like_count":0},{"had_liked":false,"id":65955,"user_name":"Pre-Y","can_delete":false,"product_type":"c1","uid":1396900,"ip_address":"","ucode":"A13D13A37F3ABC","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/a4/8d2e454b.jpg","comment_is_top":false,"comment_ctime":1549797394,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549797394","product_id":100017301,"comment_content":"今日份的打卡。<br>这类复杂的算法还是边听边写到纸上，在纸上操作数据感觉稍微轻松点。😂","like_count":0},{"had_liked":false,"id":65047,"user_name":"周小成","can_delete":false,"product_type":"c1","uid":1229260,"ip_address":"","ucode":"5B47835DE09E1A","user_header":"https://static001.geekbang.org/account/avatar/00/12/c1/cc/6b6bbd41.jpg","comment_is_top":false,"comment_ctime":1549011524,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549011524","product_id":100017301,"comment_content":"寻找第K大的值用快排分区递归的思想是很妙的解法，但是有个小问题是，会改变原来的顺序。","like_count":0},{"had_liked":false,"id":63851,"user_name":"lonelyandrew","can_delete":false,"product_type":"c1","uid":1116374,"ip_address":"","ucode":"8C66115AF80AB2","user_header":"https://static001.geekbang.org/account/avatar/00/11/08/d6/4b0506bb.jpg","comment_is_top":false,"comment_ctime":1548556732,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548556732","product_id":100017301,"comment_content":"解答开篇这一小节，第五段，最后一行：<br>分区遍历元素的个数分别为(貌似这里少了一个n)、n&#47;2、n&#47;4、n&#47;8、n&#47;16……直到区间缩小为1。","like_count":0},{"had_liked":false,"id":63105,"user_name":"海军上校","can_delete":false,"product_type":"c1","uid":1104290,"ip_address":"","ucode":"7B0D9EC01A3F36","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/a2/afbc447c.jpg","comment_is_top":false,"comment_ctime":1548253136,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548253136","product_id":100017301,"comment_content":"mark不足","like_count":0},{"had_liked":false,"id":62827,"user_name":"Aaaaaaaaaaayou","can_delete":false,"product_type":"c1","uid":1073601,"ip_address":"","ucode":"67BA315B87587D","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/c1/93031a2a.jpg","comment_is_top":false,"comment_ctime":1548167260,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548167260","product_id":100017301,"comment_content":"找第k大的元素还可以使用一个size为k的最小堆，把数据遍历一遍入堆，最后堆顶的元素就是所求值。这个的时间复杂度是O(nlogk)，空间复杂度是O(k)。","like_count":0},{"had_liked":false,"id":62544,"user_name":"snapshot","can_delete":false,"product_type":"c1","uid":1222151,"ip_address":"","ucode":"49D64E8CAB871F","user_header":"https://static001.geekbang.org/account/avatar/00/12/a6/07/8580137c.jpg","comment_is_top":false,"comment_ctime":1548086716,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548086716","product_id":100017301,"comment_content":"后面的题目，我觉得应该用快速排序来做，而不是归并排序，因为归并一定有个merge过程，内存肯定不够，而用快速排序的话，对内存没有太大要求。<br>前期内存不够，可以用快速排序，将文件按照区块分开来，保证分出得子文件小于1g，因为是快速排序，每个文件从全局上看是有序的，然后对这些小于1g的文件，你想用那个排序就哪个排序，子文件有序后，输出到一个文件即可。<br><br>前面的回答，都没考虑merge这个过程。最优解应该是先快速排序，让子文件小于1g，然后加载到内存排序。最后合并输出。","like_count":0},{"had_liked":false,"id":62081,"user_name":"明月关","can_delete":false,"product_type":"c1","uid":1298506,"ip_address":"","ucode":"F9464EEC269BFF","user_header":"https://static001.geekbang.org/account/avatar/00/13/d0/4a/187721e0.jpg","comment_is_top":false,"comment_ctime":1547903760,"is_pvip":false,"replies":[{"id":"23154","content":"我们后面有讲到，可以做到基本上平均分区","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1549179609,"ip_address":"","comment_id":62081,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1547903760","product_id":100017301,"comment_content":"解答有个疑问<br>分区不一定正好分成2半吧 <br>最坏的时间复杂度应该是还是O(n^2)吧<br>分区有可能是最大的在最后面 ","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437087,"discussion_content":"我们后面有讲到，可以做到基本上平均分区","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549179609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":62042,"user_name":"黄均鹏","can_delete":false,"product_type":"c1","uid":1131636,"ip_address":"","ucode":"27F852817B9B98","user_header":"https://static001.geekbang.org/account/avatar/00/11/44/74/f98299ee.jpg","comment_is_top":false,"comment_ctime":1547891062,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547891062","product_id":100017301,"comment_content":"自己按照老师的图思路手写了一遍，还跑通了！不知道大家是不是都觉得自己要比别人聪明一点，我也同样，其实这是不是因为大家智力水平都差不多的情况才有这种想法","like_count":0},{"had_liked":false,"id":60749,"user_name":"ab","can_delete":false,"product_type":"c1","uid":1241460,"ip_address":"","ucode":"D45036E8FAD77F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f1/74/9fb2eae8.jpg","comment_is_top":false,"comment_ctime":1547542029,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547542029","product_id":100017301,"comment_content":"   &#47;&#47;java解答开头题目，如果想要快速排序稍微快改改就好<br><br> public int findKthLargest(int[] nums, int k) {<br>        &#47;&#47;寻找数组中第k大元素，使用快速排序<br><br>        int len = nums.length;<br>        if (nums.length&lt;k){<br>            return 0;<br>        }<br>        if (nums.length&lt;=0){<br>            return 0;<br>        }<br><br>        int j = quickSort(nums, k, 0, len - 1);<br>        return nums[k-1];<br><br>    }<br>    &#47;&#47;快速排序递归<br>    private int quickSort(int[] nums, int k, int start, int end) {<br>        &#47;&#47;中间点的数。<br>        int q = nums[end];<br>        &#47;&#47;排序,获得q点在数组中的位置。。<br>        int j = sort(nums, start, end, q) ;<br><br><br>        if(j+1&lt;k) {<br>            return quickSort(nums, k, j + 1, end);<br><br>        }else if(j+1&gt;k){<br>            return quickSort(nums, k, start, j - 1);<br>        }else{<br>            return nums[j];<br>        }<br>    }<br>    private int sort(int[] nums, int start, int end, int q) {<br>        &#47;&#47;原地排序，用i来划分，i指向区间的尾部，如果nums[j]大于q则交换i区间的尾部,但是不稳定。<br>        int i = start, j = start;<br>        for (; j &lt;= end; j++) {<br>            if (nums[j] &gt;= q) {<br>                &#47;&#47;交换i和j<br>                int temp = nums[i];<br>                nums[i] = nums[j];<br>                nums[j] = temp;<br>                i++;<br>            }<br>        }<br>        return i-1 ;<br>    }","like_count":0},{"had_liked":false,"id":58825,"user_name":"东东","can_delete":false,"product_type":"c1","uid":1247437,"ip_address":"","ucode":"DBA46D67DD4605","user_header":"https://static001.geekbang.org/account/avatar/00/13/08/cd/ff5d4d46.jpg","comment_is_top":false,"comment_ctime":1547204907,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547204907","product_id":100017301,"comment_content":"快排的java代码：<br><br> &#47;**<br>     *<br>     * @param arr<br>     * @param start_index<br>     * @param end_index<br>     * @param pivot<br>     *&#47;<br>    public static int shuaxin(int[] arr, int start_index, int end_index, int pivot) {<br>        if (pivot &lt; start_index || pivot &gt; end_index) {<br>            return 0;<br>        }<br>        for (int j = start_index; j &lt;= end_index; j++) {<br>            if (j &lt; pivot &amp;&amp; arr[j] &gt; arr[pivot]) {<br>                swap(arr, pivot, j);<br>                pivot = j;<br>            } else if (j &gt; pivot &amp;&amp; arr[j] &lt; arr[pivot]) {<br>                swap(arr, pivot, j);<br>                int temp = pivot;<br>                pivot = j;<br>                j = temp;<br>            }<br>        }<br>        return pivot;<br>    }<br><br>    &#47;**<br>     * 快速排序：原地排序，时间复杂度O(n*longN)，稳定排序<br>     *<br>     * @param arr<br>     * @return<br>     *&#47;<br>    public static void kuaisu(int[] arr, int start_index, int end_index) {<br>        if (start_index &gt;= end_index) {<br>            return;<br>        }<br>        int pivot = partition(start_index, end_index);<br>        System.out.println(&quot;start_index:&quot; + start_index + &quot;,end_index:&quot; + end_index + &quot;,pivot:&quot; + pivot);<br>        &#47;&#47;将小于arr[pivot] 的数放在左边，大于arr[pivot] 的数放在右边<br>        pivot = shuaxin(arr, start_index, end_index, pivot);<br><br>        kuaisu(arr, start_index, pivot - 1);<br>        kuaisu(arr, pivot + 1, end_index);<br>    }<br>&#47;**<br>     * 从小到大顺序排序<br>     *<br>     * @param args<br>     *&#47;<br>    public static void main(String[] args) {<br>        int[] arr = {1, 4, 2, 6, 9, 4, 102, 5, 6, 8, 2, 34, 54, 12, 3, -10, -8, 100, 99};<br>        kuaisu(arr, 0, arr.length - 1);<br>       System.out.println(Arrays.toString(arr));<br>}","like_count":0},{"had_liked":false,"id":58329,"user_name":"朋朋","can_delete":false,"product_type":"c1","uid":1133890,"ip_address":"","ucode":"3070498E7282C5","user_header":"https://static001.geekbang.org/account/avatar/00/11/4d/42/8fd7c2e2.jpg","comment_is_top":false,"comment_ctime":1547038011,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547038011","product_id":100017301,"comment_content":"膜拜 github链接上数据结构居然有这么多版本 php go c++ java 看来总有一款适合我！","like_count":0},{"had_liked":false,"id":58246,"user_name":"泉","can_delete":false,"product_type":"c1","uid":1099760,"ip_address":"","ucode":"914709BE802A8D","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/f0/aa2e0749.jpg","comment_is_top":false,"comment_ctime":1547017910,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1547017910","product_id":100017301,"comment_content":"归并排序，快排都可以用递归来实现。<br>归并的合并算法可以用游标需研究？<br>快排的分区算法可以参照选择排序思想。<br>","like_count":0},{"had_liked":false,"id":58130,"user_name":"乔良qiaoliang","can_delete":false,"product_type":"c1","uid":1075315,"ip_address":"","ucode":"DDE301B3DF57A8","user_header":"https://static001.geekbang.org/account/avatar/00/10/68/73/3cda533e.jpg","comment_is_top":false,"comment_ctime":1547001006,"is_pvip":false,"replies":[{"id":"21067","content":"会有同学说我写的不够简洁的 众口难调啊","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1547086416,"ip_address":"","comment_id":58130,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1547001006","product_id":100017301,"comment_content":"伪代码的变量写啰嗦一点感觉更好懂<br>partition(A, left, right){<br>  pivot = A[right]<br>  boundary = left<br>  for i = letf to right-1 {<br>    if A[i] &lt; pivot {<br>      swap A[i] A[boundary]<br>      boundary++<br>    }<br>  }<br>  swap A[boundary] A[right]<br>  return boundary<br>}","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435921,"discussion_content":"会有同学说我写的不够简洁的 众口难调啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547086416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57210,"user_name":"[Stranger,Lover)","can_delete":false,"product_type":"c1","uid":1284863,"ip_address":"","ucode":"D1D024803BD767","user_header":"https://static001.geekbang.org/account/avatar/00/13/9a/ff/c8f9a6e2.jpg","comment_is_top":false,"comment_ctime":1546683499,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546683499","product_id":100017301,"comment_content":"例如是个日志文件时间如下：1-20   4-10   6-17  8-25  15-40  20-30  18-27.。。。因为每个日志文件都是有序的，可以先找到最小的那一段日志  第二小的那几段日志（找到后合并） 第三小的那几段日志（合并）。。。比如这几段最小的一段是 1-4，放入result，日志变为4-20 4-10 6-17 8-25 15-40 20-30 18-27，最小的一段日志为4-6，并且有两段4-6，合并。日志变为6-20   6-10  6-17 8-25 15-40 20-30，最小的一段为6-8 且有三段，合并。以此类推，而且是稳定排序,空间复杂度O（1），时间复杂度求解，麻烦老师","like_count":0},{"had_liked":false,"id":57128,"user_name":"那样的月色","can_delete":false,"product_type":"c1","uid":1237353,"ip_address":"","ucode":"23B1298C465D2C","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/69/0db70c84.jpg","comment_is_top":false,"comment_ctime":1546655605,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546655605","product_id":100017301,"comment_content":"曹源童鞋的也不行啊，按照1G来划分，每次取中间，把前面的部分合并成1G，归并排序后读到文件，问题就在这个mid，比如A文件的mid前一个是4，B文件的mid前一个是2，C文件mid前是3，先比较然后读到文件，此时读写到文件最后的是4，下一次读取的时候，B文件如果开始是3，岂不就错了吗。","like_count":0},{"had_liked":false,"id":57035,"user_name":"MOK_CHEN","can_delete":false,"product_type":"c1","uid":1227465,"ip_address":"","ucode":"5F1DFE1A76DD2F","user_header":"","comment_is_top":false,"comment_ctime":1546605494,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546605494","product_id":100017301,"comment_content":"我个人觉得用什么语言来实现不是我们应该关注的重点，不管是伪代码，还是c亦或者java,对于某一些人来说可能都不熟悉。特别是我看别人的代码就会觉得很无聊，所以我都是看完动态过程分析，然后自己实现，最后才来做比对，看看有没有可以简化的东西。","like_count":0},{"had_liked":false,"id":55671,"user_name":"冰菓㍿","can_delete":false,"product_type":"c1","uid":1325407,"ip_address":"","ucode":"C0598FD34F48FB","user_header":"https://static001.geekbang.org/account/avatar/00/14/39/5f/45085f93.jpg","comment_is_top":false,"comment_ctime":1546258138,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546258138","product_id":100017301,"comment_content":"from typing import List<br>def merge(left:List[int],right:List[int]):<br>    i,j = 0,0<br>    tmp = []<br>    while i &lt; len(left) and j &lt; len(right):<br>        if left[i] &lt; right[j]:<br>            tmp.append(left[i])<br>            i += 1<br>        else:<br>            tmp.append(right[j])<br>            j += 1<br>    tmp += left[i:]<br>    tmp += right[j:]<br>    return tmp<br>def merge_sort(a:List[int]):<br>    if len(a) &lt;= 1:<br>        return a<br>    mid = len(a)&#47;&#47;2<br>    left = merge_sort(a[:mid])<br>    right = merge_sort(a[mid:])<br>    return merge(left,right)<br>请问下这个写法中为什么tmp循环append后还要再    tmp += left[i:]<br>    tmp += right[j:]，我想的是while循环中已经逐个append的，为什么结束后还要再拼接？","like_count":0},{"had_liked":false,"id":55297,"user_name":"zhenwei","can_delete":false,"product_type":"c1","uid":1337964,"ip_address":"","ucode":"9ACFE30C953836","user_header":"https://static001.geekbang.org/account/avatar/00/14/6a/6c/f1f3def2.jpg","comment_is_top":false,"comment_ctime":1546094777,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546094777","product_id":100017301,"comment_content":"非递归快排实现：<br><br>def quick_sort(array):<br>\tstack = []<br>\t_p = 0<br>\t_r = len(array) - 1<br>\tstack.append([_p, _r])<br>\twhile True:<br>\t\tif 0 &gt;= stack.__len__():<br>\t\t\tbreak<br>\t\tp, r = stack.pop()<br>\t\tif p &gt;= r: <br>\t\t\tcontinue<br>\t\tpivot = r<br>\t\th = p<br>\t\twhile h &lt; pivot:<br>\t\t\tif array[h] &gt; array[pivot]:<br>\t\t\t\ttmp = array[pivot]<br>\t\t\t\tarray[pivot] = array[h]<br>\t\t\t\tarray[h] = array[pivot - 1]<br>\t\t\t\tarray[pivot - 1] = tmp<br>\t\t\t\tpivot = pivot -1<br>\t\t\telse:<br>\t\t\t\th = h + 1<br>\t\tstack.append([p, pivot - 1])<br>\t\tstack.append([pivot + 1, r])<br>","like_count":0},{"had_liked":false,"id":54964,"user_name":"Yeir","can_delete":false,"product_type":"c1","uid":1072999,"ip_address":"","ucode":"3A325B919C66B9","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/67/8552dab9.jpg","comment_is_top":false,"comment_ctime":1545989476,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545989476","product_id":100017301,"comment_content":"partition函数的伪代码和示意图不匹配吧. 伪代码j是不会动的, 而图里面i和j都会移动","like_count":0},{"had_liked":false,"id":54299,"user_name":"Ben","can_delete":false,"product_type":"c1","uid":1252353,"ip_address":"","ucode":"70351D4FAE47F7","user_header":"https://static001.geekbang.org/account/avatar/00/13/1c/01/5aaaf5b6.jpg","comment_is_top":false,"comment_ctime":1545824006,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545824006","product_id":100017301,"comment_content":"<br># 用快速排序查找第K大元素 1=&lt;K&lt;=len(arr)<br>def QuickSortPosK(arr, K):<br>    # 基准值为数组首位,末位,中间位数字的平均值<br>    if len(arr) == 1 : return arr[0]<br>    pivot = arr[-1]<br>    # 推导式简单实现[i, pivot]<br>    less = [i for i in arr[:] if i &lt;= pivot]<br>    greater = [i for i in arr[:] if i &gt; pivot]<br>    lenLess = len(less)<br>    if lenLess == K:<br>        return less[-1]<br>    elif lenLess &gt; K:<br>        return QuickSortPosK(less[:-1], K)<br>    elif lenLess &lt; K:<br>        return QuickSortPosK(greater, K-lenLess)<br> <br>print(&#39;QuickSortPosK&#39;,QuickSortPosK([90, 0, -1, 22, 3,3,3],4))<br><br># 编程珠玑实现<br># 双向排序: 提高非随机输入的性能<br># 不需要额外的空间,在待排序数组本身内部进行排序<br># 基准值通过random随机选取<br># 入参: 待排序数组, 数组开始索引 0, 数组结束索引 len(array)-1<br>import random<br><br>def swap(arr, l, u):<br>    arr[l],arr[u] = arr[u],arr[l]<br>    return arr<br><br>def QuickSort_Perl(arr, l, u):<br>    # 小数组排序i可以用插入或选择排序 <br>    # if u-l &lt; 50 : return arr<br>    # 基线条件: low index = upper index; 也就是只有一个值的区间<br>    if l &gt;= u:<br>        return arr<br>    # 随机选取基准值, 并将基准值替换到数组第一个元素        <br>    swap(arr, l, int(random.uniform(l, u)))<br>    temp = arr[l]<br>    # 缓存边界值, 从上下边界同时排序<br>    i, j = l, u<br>    while True:<br>        # 第一个元素是基准值,所以要跳过<br>        i+=1<br>        # 在小区间中, 进行排序<br>        # 从下边界开始寻找大于基准值的索引<br>        while i &lt;= u and arr[i] &lt;= temp:<br>            i += 1<br>        # 从上边界开始寻找小于基准值的索引<br>        # 因为j肯定大于i, 所以索引值肯定在小区间中<br>        while arr[j] &gt; temp:<br>            j -= 1<br>        # 如果小索引仍小于大索引, 调换二者位置<br>        if i &gt;= j:<br>            break<br>        arr[i], arr[j] = arr[j], arr[i]<br>    # 将基准值的索引从下边界调换到索引分割点<br>    swap(arr, l, j)<br>    QuickSort_Perl(arr, l, j-1)<br>    QuickSort_Perl(arr, j+1, u)<br>    return arr<br><br>print(&#39;QuickSort_Perl([-22, -21, 0, 1, 2, 22])&#39;,<br>      QuickSort_Perl([-22, -21, 0, 1, 2, 22], 0, 5))<br>","like_count":0},{"had_liked":false,"id":54193,"user_name":"Ben","can_delete":false,"product_type":"c1","uid":1252353,"ip_address":"","ucode":"70351D4FAE47F7","user_header":"https://static001.geekbang.org/account/avatar/00/13/1c/01/5aaaf5b6.jpg","comment_is_top":false,"comment_ctime":1545802400,"is_pvip":false,"replies":[{"id":"19672","content":"c*n也可以的 没有区别 表示两个有序数组合并的时间复杂度","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545829133,"ip_address":"","comment_id":54193,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545802400","product_id":100017301,"comment_content":"大牛好, 在推导归并排序时间复杂度的过程中有个疑问. <br><br>T(n) = 2*T(n&#47;2) + n； n&gt;1. 这里最后的n和参数中的n是同样的意义吗? <br>这个位置的意义是一个常量值吧,应该是和参数n有关联,但是决不能简单用n来代替.<br>等式左右代表的是估计的时间, n应该是C(n).<br>非常不理解为什么直接用n表示常量, 而且后面的推导结果很大程度上依赖于此.<br><br><br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434389,"discussion_content":"c*n也可以的 没有区别 表示两个有序数组合并的时间复杂度","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545829133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":53804,"user_name":"Leo","can_delete":false,"product_type":"c1","uid":1220277,"ip_address":"","ucode":"7A11B26AEA5510","user_header":"https://static001.geekbang.org/account/avatar/00/12/9e/b5/17ff83e6.jpg","comment_is_top":false,"comment_ctime":1545729867,"is_pvip":false,"replies":[{"id":"19676","content":"内容小姐里 没有写啊 写了不是原地排序","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545829387,"ip_address":"","comment_id":53804,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545729867","product_id":100017301,"comment_content":"在内容小结里面说归并排序是不稳定排序？应该是写错了","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434247,"discussion_content":"内容小姐里 没有写啊 写了不是原地排序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545829387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":53781,"user_name":"XinghaiVictorStarseaSingHoy星海","can_delete":false,"product_type":"c1","uid":1028923,"ip_address":"","ucode":"1E45557EAAC7D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b3/3b/1104b8e6.jpg","comment_is_top":false,"comment_ctime":1545724058,"is_pvip":true,"replies":[{"id":"19677","content":"嗯嗯 👍 我语文没学好 ","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545829432,"ip_address":"","comment_id":53781,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545724058","product_id":100017301,"comment_content":"这个表述想了好久……是找顺序排列的第K个元素，而不是第k大吧……第k大是 kth largest, 说的是从大到小排列第K个元素。你看，如果代K为1，第一大的的元素，岂不是最小的元素了吗","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434239,"discussion_content":"嗯嗯 👍 我语文没学好 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545829432,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":53650,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1545705234,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545705234","product_id":100017301,"comment_content":"网名我来也得解题思路欠妥，按40兆分割，怎么保证第二个文件除去40兆后剩下的一定比第一个文件40兆内的大","like_count":0},{"had_liked":false,"id":53133,"user_name":"左瞳","can_delete":false,"product_type":"c1","uid":1206589,"ip_address":"","ucode":"B262A3E99C8605","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/3d/3cfb9b87.jpg","comment_is_top":false,"comment_ctime":1545611029,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545611029","product_id":100017301,"comment_content":"快排的元素交换不是也要申请空间吗？为啥空间复杂度是1","like_count":0},{"had_liked":false,"id":52593,"user_name":"ban","can_delete":false,"product_type":"c1","uid":1034204,"ip_address":"","ucode":"E523CE97E48266","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/dc/9408c8c2.jpg","comment_is_top":false,"comment_ctime":1545448096,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545448096","product_id":100017301,"comment_content":"把取出来的 10 个订单放到优先级队列中，取出最大值（也就是大顶堆堆顶数据），就是全局金额最大的订单。然后再从这个全局金额最大订单对应的数据库中，取出下一条订单（按照订单金额从大到小排列的），然后放到优先级队列中。一直重复上面的过程。<br><br>老师这段话我看到好多遍，想了好多次一直没搞懂，为什么取出最大金额的数据库查到下一条订单放到队列能理解，但是下次重复这个过程还是从队列中取出最大金额的下一个订单，这样每次最大的金额不是同一个吗，取出的订单还是同一个？<br><br>还有另外一个问题就是全部取出来后怎么判断这个队列是top k的订单金额？<br><br>求老师讲解，自己研究好久没搞透","like_count":0},{"had_liked":false,"id":52384,"user_name":"Lisa Li","can_delete":false,"product_type":"c1","uid":1046663,"ip_address":"","ucode":"4F7CF929FF4C6B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/87/0491e9e5.jpg","comment_is_top":false,"comment_ctime":1545373006,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545373006","product_id":100017301,"comment_content":"文章里提到了数据规模。数据规模叫做大，多大叫做小。是10万以内的叫小，还是放不进内存的叫大。","like_count":0},{"had_liked":false,"id":51587,"user_name":"李乐","can_delete":false,"product_type":"c1","uid":1341638,"ip_address":"","ucode":"8BEDC67AC39719","user_header":"https://static001.geekbang.org/account/avatar/00/14/78/c6/8ec68307.jpg","comment_is_top":false,"comment_ctime":1545204235,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545204235","product_id":100017301,"comment_content":"老师能否再解释一下你的例子中哪里说明了快排一定不是稳定的排序方式，我没发现不稳定啊<br>6&#39;876&#39;&#39;359 4<br>3 4 6&#39;876&#39;&#39;59<br>      6&#39;876&#39;&#39;5     9<br>      5 6&#39;876&#39;&#39;<br>         6&#39; 6&#39;&#39; 87<br>                  7 8<br>3 4 5 6&#39; 6&#39;&#39; 7 8 9","like_count":0},{"had_liked":false,"id":50579,"user_name":"田佳伟","can_delete":false,"product_type":"c1","uid":1034087,"ip_address":"","ucode":"D31C9799F383D2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/67/0077314b.jpg","comment_is_top":false,"comment_ctime":1545011985,"is_pvip":false,"replies":[{"id":"18341","content":"当然不是凑啊 本来就有的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545098690,"ip_address":"","comment_id":50579,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545011985","product_id":100017301,"comment_content":"T(n) = 2*T(n&#47;2) + n<br>     = 2*(2*T(n&#47;4) + n&#47;2) + n = 4*T(n&#47;4) + 2*n<br>     = 4*(2*T(n&#47;8) + n&#47;4) + 2*n = 8*T(n&#47;8) + 3*n<br>     = 8*(2*T(n&#47;16) + n&#47;8) + 3*n = 16*T(n&#47;16) + 4*n<br>     ......<br>     = 2^k * T(n&#47;2^k) + k * n<br>     ......<br>老师，这个推导公式里边，每一行都多加了 n 2*n 3*n …… 这个是为了凑规律吗？ ","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433026,"discussion_content":"当然不是凑啊 本来就有的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545098690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":49882,"user_name":"匆匆","can_delete":false,"product_type":"c1","uid":1333414,"ip_address":"","ucode":"4DB39C6CD5743B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/H8NxrljQXliccaT5fjdXJQYS3ou3Z9ykAuKw6EgicicEA9L4jQLz3h85P0odgDSaK0cA9oTyUKibbiagdNvnHuuV5mQ/132","comment_is_top":false,"comment_ctime":1544784925,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544784925","product_id":100017301,"comment_content":"归并排序（稳定）：最好最快平均时间复杂度均为O(nlogn)，空间复杂度为O(n)。由于不是原地排序算法，所以应用度不如快排。<br><br>快速排序（不稳定）：最好时间复杂度O(nlogn),最快时间复杂度O(n^2),平均O(nlogn)，是原地排序算法。<br><br>总结：归并排序和快排都是利用了分治的思想，分而治之，不过归并是由下到上处理，先处理小的，然后合并。快排是由上到下处理，先分区，在处理子问题。快排可利用多种方法将最坏情况概率降到很低，由于不占用更多内存空间，所以使用更多。","like_count":0},{"had_liked":false,"id":49638,"user_name":"Cmder","can_delete":false,"product_type":"c1","uid":1258672,"ip_address":"","ucode":"E4B2655039D613","user_header":"https://static001.geekbang.org/account/avatar/00/13/34/b0/21542648.jpg","comment_is_top":false,"comment_ctime":1544748908,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544748908","product_id":100017301,"comment_content":"要明白一点的是，第k个数，在数组里面，下标是k-1。比如，第一个数，下标是0","like_count":0},{"had_liked":false,"id":49139,"user_name":"唯她命","can_delete":false,"product_type":"c1","uid":1240398,"ip_address":"","ucode":"8F687E8D306840","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/4e/ef406442.jpg","comment_is_top":false,"comment_ctime":1544609628,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544609628","product_id":100017301,"comment_content":"随机数快排 非常慢。。。","like_count":0},{"had_liked":false,"id":48659,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1544509332,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544509332","product_id":100017301,"comment_content":"分治是一种解决问题的处理思想，递归是一种编程技巧<br>非原地排序，是稳定排序，时间复杂度O(nlogn),空间O(n)<br><br>归并：从小到大，非原地空间复杂度O(n)<br>快速：从大到小，有可能退化为时间复杂度O(n*n)<br><br>快排的方式找到第K大和冒泡方式的时间复杂度是<br>O(n) 和 O(kn) 解答 了我的疑问<br><br>问答：","like_count":0},{"had_liked":false,"id":48528,"user_name":"大悲","can_delete":false,"product_type":"c1","uid":1341085,"ip_address":"","ucode":"3A7865964B0159","user_header":"https://static001.geekbang.org/account/avatar/00/14/76/9d/bfcdbdda.jpg","comment_is_top":false,"comment_ctime":1544465141,"is_pvip":false,"replies":[{"id":"17380","content":"可以的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544493188,"ip_address":"","comment_id":48528,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1544465141","product_id":100017301,"comment_content":"归并排序也可以原地实现，这样的话时间复杂度虽然也是n(lgn)，但系数比较高。请问可以这样理解么？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432227,"discussion_content":"可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544493188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":48398,"user_name":"xia哈","can_delete":false,"product_type":"c1","uid":1121250,"ip_address":"","ucode":"4F98953C7CBF1D","user_header":"https://static001.geekbang.org/account/avatar/00/11/1b/e2/399084b1.jpg","comment_is_top":false,"comment_ctime":1544435744,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544435744","product_id":100017301,"comment_content":"归并-哨兵-java<br>    private void mergeData(int[] data, int start, int middle, int end) {<br><br>        int[] temp = new int[data.length + 2];<br>        int index = 0;<br>        for (int i = start; i &lt;= middle; i++) {<br>            temp[index++] = data[i];<br>        }<br>        temp[index++] = Integer.MAX_VALUE;<br>        for (int i = middle + 1; i &lt;= end; i++) {<br>            temp[index++] = data[i];<br>        }<br>        temp[index] = Integer.MAX_VALUE;<br>        int i = 0;<br>        int j = middle - start + 2;<br>        int k = start;<br>        while (temp[i] != Integer.MAX_VALUE || temp[j] != Integer.MAX_VALUE) {<br>            if (temp[i] &lt; temp[j]) {<br>                data[k++] = temp[i++];<br>            } else {<br>                data[k++] = temp[j++];<br>            }<br>        }<br>        System.out.println(Arrays.toString(temp));<br>        System.out.println(&quot;start=&quot;+start+&quot; middle=&quot;+middle+&quot; end=&quot;+end);<br>        System.out.println(Arrays.toString(data));<br>        System.out.println();<br>    }","like_count":0},{"had_liked":false,"id":47907,"user_name":"henghhh","can_delete":false,"product_type":"c1","uid":1111350,"ip_address":"","ucode":"E2DA8ADE77D9D1","user_header":"https://static001.geekbang.org/account/avatar/00/10/f5/36/54ac6e4b.jpg","comment_is_top":false,"comment_ctime":1544252853,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544252853","product_id":100017301,"comment_content":"没找到没想到merge函数中带哨兵的方法，但想到了以下这种方法来减少使用循环<br><br>while (i &lt;= q || j &lt;= r) {<br>    &#47;&#47; &lt;= 决定这是个稳定的排序<br>    if (j &gt; r || (i &lt;= q &amp;&amp; nums[i] &lt;= nums[j])) {<br>        temp[inx ++] = nums[i ++];<br>    } else {<br>        temp[inx ++] = nums[j ++];<br>    }<br>}","like_count":0},{"had_liked":false,"id":47506,"user_name":"Chang","can_delete":false,"product_type":"c1","uid":1125147,"ip_address":"","ucode":"CE2050F1BE00DB","user_header":"https://static001.geekbang.org/account/avatar/00/11/2b/1b/e88e33ba.jpg","comment_is_top":false,"comment_ctime":1544148653,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544148653","product_id":100017301,"comment_content":"写一个最小堆，把10个文件接口的第一个文件（最小文件）放进堆。把堆的文件依次pop出来，每pop出一个，就把该文件所在的接口的下一个文件放进堆。这样可以把内存控制在10*size(文件). 不太能用归并排序，因为不管怎么分治，感觉最后一次归并都必须把所有文件都放进内存。归并排序空间复杂度是O(n)","like_count":0},{"had_liked":false,"id":47482,"user_name":"王鸿运","can_delete":false,"product_type":"c1","uid":1068577,"ip_address":"","ucode":"14AF7B485D29A1","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/21/700586eb.jpg","comment_is_top":false,"comment_ctime":1544147020,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544147020","product_id":100017301,"comment_content":"快排优化主要几种思路:<br>1.pivot的选择，才用随机法或者中位取值法（从随机概率分布来说，可以尽量避免极端情况）<br>2.防止递归太深，可以在深度达到一定时，对子集采用堆排<br>3.当子集小于一定次数时，基本有序了，采用插入排序<br>4.对和pivot相同的元素进行聚集，来减少子集大小<br><br>求数组第k的数，可以用来解决topk问题，时间复杂度会比采用小顶堆方式要稍微好一点","like_count":0},{"had_liked":false,"id":47323,"user_name":"heting","can_delete":false,"product_type":"c1","uid":1240803,"ip_address":"","ucode":"0AB093F5E0E581","user_header":"https://static001.geekbang.org/account/avatar/00/12/ee/e3/65c9b259.jpg","comment_is_top":false,"comment_ctime":1544106958,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544106958","product_id":100017301,"comment_content":"10个文件， 首先从每个文件读取100M放入内存，总共1G。<br>将这100个100M文件进行排序，由于每个100M数据都是已经排序的，因此排序时不需要使用快排方案，只要使用类似快排的partition函数，即找到待排序100M数据中最大的元素作为pivot，扫描一遍即可。使用这种方案将内存中的1G数据排序完成后，我们能够推断最小的100M数据一定是当前未排序的数据中最小的一部分数据，将这部分数据从内存写入到文件。再从任意文件再次读取100M加入排序。<br>以上方案不知可行，请老师指教。","like_count":0},{"had_liked":false,"id":47206,"user_name":"OnClickListener","can_delete":false,"product_type":"c1","uid":1250465,"ip_address":"","ucode":"35BE7FF3D4A258","user_header":"https://static001.geekbang.org/account/avatar/00/13/14/a1/107910b4.jpg","comment_is_top":false,"comment_ctime":1544076562,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544076562","product_id":100017301,"comment_content":"贴一下我自己的代码(写代码一定要细心)<br>   public static void mergeSort(int[] arr,int[] tmp){<br>       mergeSort(arr,0,arr.length-1,tmp);<br>   }<br><br>   public static void mergeSort(int[]arr,int p,int r,int[] tmp){<br>       if(p&gt;=r)return;<br><br>       int q = (p+r)&#47;2;<br>       mergeSort(arr,p,q,tmp);<br>       mergeSort(arr,q+1,r,tmp);<br>       merge(arr,p,q,r,tmp);<br>   }<br><br>   public static void merge(int[] arr,int p,int q,int r,int[] tmp){<br>       int i=p;<br>       int j=q+1;<br>       int k=0;<br>       while (i&lt;=q &amp;&amp; j&lt;=r){<br>           if(arr[i]&lt;=arr[j]){<br>               tmp[k++]=arr[i++];<br>           }else {<br>               tmp[k++]=arr[j++];<br>           }<br>       }<br><br>       int start = i;<br>       int end = q;<br>       if(j&lt;=r){<br>           start = j;<br>           end = r;<br>       }<br><br>       while (start&lt;=end){<br>           tmp[k++] = arr[start++];<br>       }<br><br>       for (int m=0;m&lt;=r-p;m++){<br>           arr[m+p]=tmp[m];<br>       }<br>   }","like_count":0},{"had_liked":false,"id":45856,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1543803716,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543803716","product_id":100017301,"comment_content":"老师，我是按照数组头元素作为参考指标，实现了快速排序，麻烦老师看下。  <br>public static void sort(int[] arr) {<br>        int length = arr.length;<br>        _sort(arr, 0, length - 1);<br>    }<br><br>    &#47;**<br>     * 获取比较分区元素的索引位置<br>     *<br>     * @param arr<br>     * @param l<br>     * @param r<br>     * @return 返回分区索引，使得arr[l,par]&lt;referVal，arr[par+1,r]&gt;referVal<br>     *&#47;<br>    private static int partition(int[] arr, int l, int r) {<br>        int referVal = arr[l];<br>        int par = l;<br>        for (int i = l + 1; i &lt;= r; i++) {<br>            if (arr[i] &lt; referVal) {<br>                par++;<br>                int temp = arr[par];<br>                arr[par] = arr[i];<br>                arr[i] = temp;<br>            }<br>        }<br>        &#47;&#47;这边的是将之前referVal的值交换到正确位置<br>        int tmp = arr[par];<br>        arr[par] = arr[l];<br>        arr[l] = tmp;<br>        return par;<br>    }<br><br>    &#47;**<br>     * 递归处理数组排序<br>     *<br>     * @param arr<br>     * @param l<br>     * @param r<br>     *&#47;<br>    private static void _sort(int[] arr, int l, int r) {<br>        &#47;&#47;递归结束条件<br>        if (l &gt;= r) {<br>            return;<br>        }<br>        int par = partition(arr, l, r);<br>        &#47;&#47;排序左边的部分<br>        _sort(arr, l, par);<br>        &#47;&#47;排序右边的部分<br>        _sort(arr, par + 1, r);<br>    }","like_count":0},{"had_liked":false,"id":45471,"user_name":"周曙光爱学习","can_delete":false,"product_type":"c1","uid":1022920,"ip_address":"","ucode":"98EAB6EBAB34B6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/c8/665100a3.jpg","comment_is_top":false,"comment_ctime":1543650597,"is_pvip":false,"replies":[{"id":"16370","content":"golang不是我写的 是其他同学写的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543802762,"ip_address":"","comment_id":45471,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1543650597","product_id":100017301,"comment_content":"老师你写的golang版本的快排partition方法有bug，如果arr［low］=arr［high］就会进入死循环了","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431052,"discussion_content":"golang不是我写的 是其他同学写的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543802762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":45444,"user_name":"Fff","can_delete":false,"product_type":"c1","uid":1041744,"ip_address":"","ucode":"2D1E13AF02449C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e5/50/29af37cf.jpg","comment_is_top":false,"comment_ctime":1543643952,"is_pvip":false,"replies":[{"id":"16371","content":"个人觉得 算法导论上的也并不会更好懂😄","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543802831,"ip_address":"","comment_id":45444,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1543643952","product_id":100017301,"comment_content":"快排的分区函数看不懂的，可以下本算法导论的pdf，里面有整个分区流程的详细图文描述","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431041,"discussion_content":"个人觉得 算法导论上的也并不会更好懂😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543802831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":45268,"user_name":"Martin ","can_delete":false,"product_type":"c1","uid":1186025,"ip_address":"","ucode":"6BF9FE945D396A","user_header":"https://static001.geekbang.org/account/avatar/00/12/18/e9/4242ee4a.jpg","comment_is_top":false,"comment_ctime":1543573445,"is_pvip":false,"replies":[{"id":"16375","content":"java的partition函数的代码你看了吗 建议自己读一下","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543803060,"ip_address":"","comment_id":45268,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1543573445","product_id":100017301,"comment_content":"老师你好，我在阅读快速排序小节时，使用 java版本的partition() 分区函数打印结果的时候发现和图上画的顺序有出入,是分区函数写错了吗？我把代码贴在下面：<br>@Test<br>    public void testPartition()<br>    {<br>        int[] data = {8,10,2,3,6,1,5};<br>        QuickSort.partition(data, 0, data.length-1); &#47;&#47; 获取分区点<br>        printAll(data);<br>    }<br><br>IDE打印结果：2 3 1 5 6 8 10<br><br>虽然对分区函数的分区职责没有什么影响，但是感觉顺序的理解上有问题，请指正。<br><br><br><br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430971,"discussion_content":"java的partition函数的代码你看了吗 建议自己读一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543803060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":45233,"user_name":"马哲富","can_delete":false,"product_type":"c1","uid":1107917,"ip_address":"","ucode":"D6BDDFE3CC07ED","user_header":"https://static001.geekbang.org/account/avatar/00/10/e7/cd/08088f14.jpg","comment_is_top":false,"comment_ctime":1543563994,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543563994","product_id":100017301,"comment_content":"哎~一行字一行字看吧，太费劲了！","like_count":0},{"had_liked":false,"id":44910,"user_name":"lttzzlll","can_delete":false,"product_type":"c1","uid":1105387,"ip_address":"","ucode":"FA160F7C02ABAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/dd/eb/80f9d212.jpg","comment_is_top":false,"comment_ctime":1543506025,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543506025","product_id":100017301,"comment_content":"第6行的代码是否可以在swap之间做个判断：<br><br>if i != j or A[i] != A[j]: swap A[i], A[j]","like_count":0},{"had_liked":false,"id":44870,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1543501753,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543501753","product_id":100017301,"comment_content":"老师这章将的归并排序的代码跟配图有所不同，一些地方不甚理解的好生辛苦。然后琢磨的出了下面的自己理解写了下面的代码，终究了解了深意！<br>public class Merge {<br>    public static void sort(int[] arr) {<br>        &#47;&#47;临时数组<br>        int[] tmp = new int[arr.length];<br>        &#47;&#47;开始排序<br>        sort(arr, tmp, 0, arr.length - 1);<br>    }<br><br>    &#47;**<br>     * 使用分治方式进行排序<br>     *<br>     * @param arr   原始数组<br>     * @param tmp   临时数组<br>     * @param start 指定排序的开始位置<br>     * @param end   指定排序的结束位置<br>     *&#47;<br>    private static void sort(int[] arr, int[] tmp, int start, int end) {<br>        &#47;&#47;递归结束条件，就是数组索引从头到尾遍历完毕。<br>        if (start &gt;= end) {<br>            return;<br>        }<br>        &#47;&#47;分治思想递归实现<br>        &#47;&#47;递归公式：merge(start...end)=merge(start...mid),merge(mid+1...end)<br>        int mid = (start + end) &#47; 2;<br>        sort(arr, tmp, start, mid);<br>        sort(arr, tmp, mid + 1, end);<br>        &#47;&#47;开始合并分治后的结果<br>        merge(arr, tmp, start, mid, end);<br>    }<br><br>    &#47;**<br>     * 开始合并分治后的结果<br>     *<br>     * @param arr   原始数组<br>     * @param tem   临时数组<br>     * @param start 开始排序的元素位置<br>     * @param mid   元素中间位置<br>     * @param end   指定排序的结束位置<br>     *&#47;<br>    private static void merge(int[] arr, int[] tem, int start, int mid, int end) {<br>        &#47;&#47;k用来进行标记临时数组的下标<br>        &#47;&#47;进行拷贝原来的数据<br>        for (int k = start; k &lt;= end; k++) {<br>            tem[k] = arr[k];<br>        }<br><br>        &#47;&#47;将数据拷贝会原来的数组<br>        int x = start;<br>        int y = mid + 1;<br>        for (int k = start; k &lt;= end; k++) {<br>            &#47;&#47;判断分出的第一个数组是否越界<br>            if (x &gt; mid) {<br>                arr[k] = tem[y];<br>                y++;<br>            }<br>            &#47;&#47;判断分出的第二个数组是否越界<br>            else if (y &gt; end) {<br>                arr[k] = tem[x++];<br>                x++;<br>            }<br>            &#47;&#47;真正开始比较两个元素大小<br>            else if (tem[y] &lt; tem[x]) {<br>                arr[k] = tem[y];<br>                y++;<br>            } else {<br>                arr[k] = tem[x];<br>                x++;<br>            }<br>        }<br>    }<br>}<br>","like_count":0},{"had_liked":false,"id":44670,"user_name":"Geek_987169","can_delete":false,"product_type":"c1","uid":1180853,"ip_address":"","ucode":"4B2955A044805D","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/b5/8bc4790b.jpg","comment_is_top":false,"comment_ctime":1543473266,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543473266","product_id":100017301,"comment_content":"思考题解决思路：<br>1：一次加载两个300M文件到内存首先快排，待2个300M有序后，归并排，最终将归并排的600M结果写到一个新文件，重复这个过程，最终生成5个已排序600M文件<br>2：取2个文件，分别读取300M内容到内存，进行归并排序，将排序结果写到一个新文件，一旦某个文件的内存300M耗尽，则继续读取剩下的，重复这个过程，最终生成一个1200M的已排序新文件<br>3：重复2，将剩下的3个600M文件选择2个文件生成一个1200M已排序文件，最终3个已排序文件大小分别为1200M,1200M,600M<br>4：重复2，最终合并为一个已排序文件，大小3000M<br>","like_count":0},{"had_liked":false,"id":44169,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1543377382,"is_pvip":false,"replies":[{"id":"15776","content":"这里数据多少就开多大数组","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543403959,"ip_address":"","comment_id":44169,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1543377382","product_id":100017301,"comment_content":"老师有个问题：就是关于排序里面的，public void sort(int[] a,int n){...}。你在备注里面说a表示为数组，n表示数组的大小。我觉得n应该是数组元素的个数更为妥当。比如，数组是这样定义的int[] a=new int[10]; a[0]=3;a[1]=5,a[2]=4。就定义三个元素，那么我觉得循环10次不合理，应该循环当前元素的个数。请老师解惑。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430662,"discussion_content":"这里数据多少就开多大数组","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543403959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":43631,"user_name":"大坏蛋","can_delete":false,"product_type":"c1","uid":1240376,"ip_address":"","ucode":"E5728F85273D14","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/38/217ecccb.jpg","comment_is_top":false,"comment_ctime":1543249379,"is_pvip":false,"replies":[{"id":"15588","content":"每次分区查找的时间复杂度并不是O(n)，因为每次都折半查找。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543284399,"ip_address":"","comment_id":43631,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1543249379","product_id":100017301,"comment_content":"老师，看完内容后，对开篇问题时间复杂度为O（n）有点疑问：每次分区查找时间复杂度为O(n) ,分区次数k，2^k = n，k=logn；所以求解问题的时间复杂度不应该也是O(nlogn) 吗？求老师和同学解答。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430439,"discussion_content":"每次分区查找的时间复杂度并不是O(n)，因为每次都折半查找。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543284399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":43334,"user_name":"丁丁","can_delete":false,"product_type":"c1","uid":1028705,"ip_address":"","ucode":"43312F0353ABE8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b2/61/3156ba36.jpg","comment_is_top":false,"comment_ctime":1543216589,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543216589","product_id":100017301,"comment_content":"分别取十个文件的最大时间戳和最小时间戳(由于文件有序，读开头一行和最后一行即可)，保留每个时间戳对应在的每个文件位置。对二十个时间戳排序，然后从小往大读文件即可。时间复杂度O(1)，空间使用每次均小于300M，应该是最快的办法。","like_count":0},{"had_liked":false,"id":43177,"user_name":"aguan(^･ｪ･^)","can_delete":false,"product_type":"c1","uid":1107177,"ip_address":"","ucode":"04833EF2D18E1A","user_header":"https://static001.geekbang.org/account/avatar/00/10/e4/e9/0dd3829f.jpg","comment_is_top":false,"comment_ctime":1543194526,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543194526","product_id":100017301,"comment_content":"求解文中哨兵的解题思路","like_count":0},{"had_liked":false,"id":43027,"user_name":"Smile","can_delete":false,"product_type":"c1","uid":1125189,"ip_address":"","ucode":"0617032294DC43","user_header":"https://static001.geekbang.org/account/avatar/00/11/2b/45/e8f64725.jpg","comment_is_top":false,"comment_ctime":1543143681,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543143681","product_id":100017301,"comment_content":"老师，快速排序的过程是不是有点问题，如果是[6,3,8]的话，i和j都是一直增加，最终导致q永远都是2，然后进行死循环，我的解决方案是，如果<br>&#47;&#47;当前面的元素都比最后一个元素小时，i向前移动一位<br>        if(i==r){<br>            i=i-1;<br>        }<br>        return i; 这样可以实现，但是不知道理解的对不对？？？","like_count":0},{"had_liked":false,"id":41778,"user_name":"allean","can_delete":false,"product_type":"c1","uid":1051470,"ip_address":"","ucode":"A0D2DB4F219EAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/0b/4e/fd946cb2.jpg","comment_is_top":false,"comment_ctime":1542850632,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542850632","product_id":100017301,"comment_content":"先构建十条io流，分别指向十个文件，每条io流读取对应文件的第一条数据，然后比较时间戳，选择出时间戳最小的那条数据，将其写入一个新的文件，然后指向该时间戳的io流读取下一行数据，然后继续刚才的操作，比较选出最小的时间戳数据，写入新文件，io流读取下一行数据，以此类推，完成文件的合并， 这种处理方式，日志文件有n个数据就要比较n次，每次比较选出一条数据来写入，时间复杂度是O（n），空间复杂度是O（1）,几乎不占用内存，这是我想出的认为最好的操作了，希望老师指出最佳的做法！！！<br>2018-10-28<br> 作者回复<br>你回答的不错 思路是正确的<br>------------------<br>来自归并排序的启发","like_count":0},{"had_liked":false,"id":41762,"user_name":"allean","can_delete":false,"product_type":"c1","uid":1051470,"ip_address":"","ucode":"A0D2DB4F219EAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/0b/4e/fd946cb2.jpg","comment_is_top":false,"comment_ctime":1542849654,"is_pvip":false,"replies":[{"id":"14960","content":"😂 没事","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542851221,"ip_address":"","comment_id":41762,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542849654","product_id":100017301,"comment_content":"昨天说老师代码跑完数据乱序是我愚昧自己写错了，抱歉哈。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429890,"discussion_content":"😂 没事","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542851221,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":41103,"user_name":"allean","can_delete":false,"product_type":"c1","uid":1051470,"ip_address":"","ucode":"A0D2DB4F219EAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/0b/4e/fd946cb2.jpg","comment_is_top":false,"comment_ctime":1542726121,"is_pvip":false,"replies":[{"id":"14786","content":"把数据给我 我来跑下","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542764990,"ip_address":"","comment_id":41103,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542726121","product_id":100017301,"comment_content":"归并排序的代码跑了一下，为什么是乱序的？😭，难道是我的姿势不对？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429700,"discussion_content":"把数据给我 我来跑下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542764990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":41102,"user_name":"allean","can_delete":false,"product_type":"c1","uid":1051470,"ip_address":"","ucode":"A0D2DB4F219EAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/0b/4e/fd946cb2.jpg","comment_is_top":false,"comment_ctime":1542726077,"is_pvip":false,"replies":[{"id":"15071","content":"哪个代码啊","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542885700,"ip_address":"","comment_id":41102,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542726077","product_id":100017301,"comment_content":"我把老师得代码跑了一下，为什么是乱序的？😭","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429699,"discussion_content":"哪个代码啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542885700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":41024,"user_name":"进阶的码农","can_delete":false,"product_type":"c1","uid":1017821,"ip_address":"","ucode":"D8991282640334","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/dd/4f53f95d.jpg","comment_is_top":false,"comment_ctime":1542714654,"is_pvip":false,"replies":[{"id":"14792","content":"可以是 比较复杂","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542765225,"ip_address":"","comment_id":41024,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542714654","product_id":100017301,"comment_content":"归并排序 空间复杂度不能是O（1）吗 我看网上有实现的","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429673,"discussion_content":"可以是 比较复杂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542765225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":40316,"user_name":"asnail","can_delete":false,"product_type":"c1","uid":1240695,"ip_address":"","ucode":"7E1F339CBFB8DD","user_header":"","comment_is_top":false,"comment_ctime":1542592418,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542592418","product_id":100017301,"comment_content":"PHP 的快排<br>function q_sort(&amp;$data, $q, $r)<br>{<br>    if ($q &gt;= $r) {<br>        return;<br>    }<br>    $p = q_sort_c($data, $q, $r);<br>    q_sort($data, $q, $p - 1);<br>    q_sort($data, $p + 1, $r);<br>}<br>function q_sort_c(&amp;$data, $q, $r)<br>{<br>    $i = $q;<br>    for ($j = $q; $j &lt; $r; $j++) {<br>        if ($data[$j] &lt; $data[$r]) {<br>            $temp = $data[$j];<br>            $data[$j] = $data[$i];<br>            $data[$i] = $temp;<br>            $i++;<br>        }<br>    }<br>    $temp = $data[$i];<br>    $data[$i] = $data[$r];<br>    $data[$r] = $temp;<br>    return $i;<br>}","like_count":0},{"had_liked":false,"id":40096,"user_name":"Laughing_Lz","can_delete":false,"product_type":"c1","uid":1251342,"ip_address":"","ucode":"7A7445E96F2978","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/0e/39307052.jpg","comment_is_top":false,"comment_ctime":1542478301,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542478301","product_id":100017301,"comment_content":"看到深夜两点，课后题的回答基本分为两种，例如王先统和李建辉的两种回答。我实在不太理解，还请老师解惑。我的直观想法也是既然十个文件各自都排好序了，我每次单独从中取出各自最小的一条记录相比较，得出十中之一的最小记录，写入新的文件里，然后再补充一条记录，如此往复，最终新的文件中不就是排好序的了吗？可是看了王先统等人的那种分为30，40M不等的更小的数组，并新建300，400M的数组来存储临时有序的文件，感觉需要多次比较才能合并成完整的文件。第一次评论，我的计算机知识太差，我实在想不通为什么他们这么考虑？和1G内存究竟有什么关系？还请老师解惑！","like_count":0},{"had_liked":false,"id":40020,"user_name":"赵传真","can_delete":false,"product_type":"c1","uid":1111166,"ip_address":"","ucode":"B776E01FFD75FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/f4/7e/f11ea062.jpg","comment_is_top":false,"comment_ctime":1542443457,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542443457","product_id":100017301,"comment_content":"java 归并：<br>public void simpleSort(int[] param) {<br>        split(param, 0, param.length - 1);<br>    }<br><br>    private void split(int[] param, int p, int r) {<br>        if (p &gt;= r) {<br>            return;<br>        }<br><br>        int q = (p + r) &#47; 2;<br>        split(param, p, q);<br>        split(param, q + 1, r);<br>        merge(param, p, q, r);<br>    }<br><br>    private void merge(int[] param, int p, int q, int r) {<br>        int i = p;<br>        int j = q + 1;<br>        int k = 0;<br>        int[] tmp = new int[r - p + 1];<br><br>        while (i &lt;= q &amp;&amp; j &lt;= r) {<br>            if (param[i] &lt; param[j]) {<br>                tmp[k++] = param[i++];<br>            } else {<br>                tmp[k++] = param[j++];<br>            }<br>        }<br><br>        while (i &lt;= q) {<br>            tmp[k++] = param[i++];<br>        }<br><br>        while (j &lt;= r) {<br>            tmp[k++] = param[j++];<br>        }<br><br>        for (int x = 0; x &lt; tmp.length; x++) {<br>            param[x + p] = tmp[x];<br>        }<br>    }<br>========================================<br>java 快排：<br>public void simpleSort(int[] param) {<br>        if (param.length &lt;= 1) {<br>            return;<br>        }<br><br>        quickSort(param, 0, param.length - 1);<br>    }<br><br>    private void quickSort(int[] param, int p, int r) {<br>        if (p &gt;= r) {<br>            return;<br>        }<br><br>        int q = partition(param, p, r);<br>        quickSort(param, p, q - 1);<br>        quickSort(param, q + 1, r);<br>    }<br><br>    private int partition(int[] param, int p, int r) {<br>        int value = param[p];<br>        int i = p;<br>        int j = r;<br><br>        while (i &lt; j) {<br>            while (i &lt; j &amp;&amp; param[j] &gt;= value) {<br>                j--;<br>            }<br><br>            while (i &lt; j &amp;&amp; param[i] &lt;= value) {<br>                i++;<br>            }<br><br>            if (i &lt; j) {<br>                int t = param[i];<br>                param[i] = param[j];<br>                param[j] = t;<br>            }<br>        }<br><br>        param[p] = param[i];<br>        param[i] = value;<br>        return i;<br>    }","like_count":0},{"had_liked":false,"id":39457,"user_name":"BD","can_delete":false,"product_type":"c1","uid":1228560,"ip_address":"","ucode":"A95CF8C3EDC228","user_header":"https://static001.geekbang.org/account/avatar/00/12/bf/10/b7974690.jpg","comment_is_top":false,"comment_ctime":1542282019,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542282019","product_id":100017301,"comment_content":"有个地方没看懂，当p=0，q=1对应区间11 8的时候再往下分会直接return，一直return到执行下面排序的q=1+1,r=3此时再往下分也会直接return，返回到p=0,q=1，和q=1+1,r=3的情况这时候就执行merge方法。可这时候p=0，q=1不还没有排序了吗？","like_count":0},{"had_liked":false,"id":38913,"user_name":"奔跑的徐胖子","can_delete":false,"product_type":"c1","uid":1233917,"ip_address":"","ucode":"CFB8A7C4F99D34","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/fd/41eb3ecc.jpg","comment_is_top":false,"comment_ctime":1542159337,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542159337","product_id":100017301,"comment_content":"我感觉应该每次读取每个文件99兆的数据，这样总共占用990兆内存，然后每个文件对应的第一条为一个序列，第二条为一个序列……，对每个序列进行快速排序，排序完成，两两进行归并，预留的10兆，就是归并所需的额外空间，然后所有归并完成写入文件，进行下一次，直到所有文件排序完毕，不知道我说的对不对😁","like_count":0},{"had_liked":false,"id":38661,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1542099630,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542099630","product_id":100017301,"comment_content":"新建一个存放最小值的文件夹，然后开始从十个文件夹里面分别取最小值，然后比较。<br>将最小值放入新移动到文件夹，然后继续取他们的最小值。将全文件移动完毕的时候，就合并完成了。","like_count":0},{"had_liked":false,"id":37630,"user_name":"无名","can_delete":false,"product_type":"c1","uid":1110113,"ip_address":"","ucode":"2D2E877CF97138","user_header":"https://static001.geekbang.org/account/avatar/00/10/f0/61/68462a07.jpg","comment_is_top":false,"comment_ctime":1541660301,"is_pvip":false,"replies":[{"id":"13598","content":"哈哈 要比较的数据不会很多 插入或者选择排序就好了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541728826,"ip_address":"","comment_id":37630,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541660301","product_id":100017301,"comment_content":"三数取中法可以通过比较完成；如果是多数取中法怎么弄，只想到了先排序再取中了，这样死循环了，有没有别的方法呀","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428432,"discussion_content":"哈哈 要比较的数据不会很多 插入或者选择排序就好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541728826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37611,"user_name":"o","can_delete":false,"product_type":"c1","uid":1104326,"ip_address":"","ucode":"4028A59700647A","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/c6/a295275b.jpg","comment_is_top":false,"comment_ctime":1541651032,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541651032","product_id":100017301,"comment_content":"也就是顺序写，跳读","like_count":0},{"had_liked":false,"id":37471,"user_name":"renderfan001","can_delete":false,"product_type":"c1","uid":1253485,"ip_address":"","ucode":"FB1A383E9DC256","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLX8ole5k6gIdCLibxtvDOAzvrQibIayjUsT852TOLl0NgYBIjD5X28Jkkb1j9S3s00rQUsIqQLe0JA/132","comment_is_top":false,"comment_ctime":1541599028,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1541599028","product_id":100017301,"comment_content":"在O(n)时间内查找第K大元素，如果对于一个已序序列应用快排的划分算法，最坏的情况也有可能接近O(n2)，比如 序列n从小到大排列，n远大于10，并且每次划分的哨兵都是最后一个元素，要找第10大元素，情况不乐观。<br><br>不过思路很巧妙，很烧脑","like_count":0},{"had_liked":false,"id":37451,"user_name":"o","can_delete":false,"product_type":"c1","uid":1104326,"ip_address":"","ucode":"4028A59700647A","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/c6/a295275b.jpg","comment_is_top":false,"comment_ctime":1541593079,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541593079","product_id":100017301,"comment_content":"1、提前将硬盘（就是硬盘）数据连续区域开辟出来做好记录；<br>2、按照最大时间和最小时间进行时间切片排序，可以对不同时间片区间的数据同时排序。然后根据该时间片区间的容量大小放到指定硬盘区间<br>3、对于某个时间区间的数据如何排序，目前只想到了插入排序","like_count":0},{"had_liked":false,"id":37056,"user_name":"dorinegorz","can_delete":false,"product_type":"c1","uid":1260730,"ip_address":"","ucode":"F83F15C61A3094","user_header":"","comment_is_top":false,"comment_ctime":1541434264,"is_pvip":false,"replies":[{"id":"13245","content":"专栏介绍了有的 你找找","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541467813,"ip_address":"","comment_id":37056,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541434264","product_id":100017301,"comment_content":"想问老师哪里能看到课程目录，这样可以自己规划一下进度","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428147,"discussion_content":"专栏介绍了有的 你找找","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541467813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36815,"user_name":"冒泡雪碧 🏈","can_delete":false,"product_type":"c1","uid":1255745,"ip_address":"","ucode":"E4AB442B0167CF","user_header":"https://static001.geekbang.org/account/avatar/00/13/29/41/a413ca91.jpg","comment_is_top":false,"comment_ctime":1541345666,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541345666","product_id":100017301,"comment_content":"【课后思考】看了大家的想法，我页说说我脑子里第一个想法：既然每个文件一开始就是按时间戳凯旭好了的，那么我们已经就知道所有文件的最小时间戳和做大时间戳。知道了时间戳的范围，那我们就合理的分成n份时间段（每小时,每分钟,或者每小时。按实际的情况而定），然后按顺序分析每个时间段：从每个文件获取该时间段的数据，合并排序，存入结果文件，然后分析下个时间段。","like_count":0},{"had_liked":false,"id":36697,"user_name":"PoetAndPoem","can_delete":false,"product_type":"c1","uid":1240028,"ip_address":"","ucode":"5BA46BFE497F32","user_header":"https://static001.geekbang.org/account/avatar/00/12/eb/dc/ae5485bb.jpg","comment_is_top":false,"comment_ctime":1541247347,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541247347","product_id":100017301,"comment_content":"如何通过快排选择第K大（小）元素。<br>我的解决方案：通过快排的partition方法的思想，每次返回的pivot的位置即为该元素已排序成功的位置。那么，当partition返回的值为k-1（或arr.len-(k-1)）时，即求出实际解。","like_count":0},{"had_liked":false,"id":36681,"user_name":"烈冬冰夏","can_delete":false,"product_type":"c1","uid":1060113,"ip_address":"","ucode":"F2875FC596D4FA","user_header":"https://static001.geekbang.org/account/avatar/00/10/2d/11/0ecbe9ea.jpg","comment_is_top":false,"comment_ctime":1541233428,"is_pvip":false,"replies":[{"id":"13100","content":"是的呢","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541383333,"ip_address":"","comment_id":36681,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541233428","product_id":100017301,"comment_content":"老师，topN的算法，如果pivot选择不好，是不是也有可能退化到n2？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427969,"discussion_content":"是的呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541383333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36678,"user_name":"qwerboo","can_delete":false,"product_type":"c1","uid":1005025,"ip_address":"","ucode":"0FD78F765A4861","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/e1/8c223e95.jpg","comment_is_top":false,"comment_ctime":1541232523,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541232523","product_id":100017301,"comment_content":"赞的最多的那个是怎么想的😏","like_count":0},{"had_liked":false,"id":36528,"user_name":"Alan","can_delete":false,"product_type":"c1","uid":1243563,"ip_address":"","ucode":"EF3B6A90054B34","user_header":"https://static001.geekbang.org/account/avatar/00/12/f9/ab/374fe105.jpg","comment_is_top":false,"comment_ctime":1541143360,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541143360","product_id":100017301,"comment_content":"我觉得文中的快排分区函数确实巧妙，但是不太好理解，我曾经写快排代码用的是另一种方法：<br>1、取第一个或最后一个数为标志数<br>2、在除标志数以外的数据中，游标i从左边开始向中间遍历，游标j从右边开始向中间遍历<br>3、若游标i所在的位置值大于标志数，j所在的值小于标志数（假设从小到大排），那就交换两个数<br>4、直到i和j相遇（i&gt;=j）时，再与标志数交换","like_count":0},{"had_liked":false,"id":36345,"user_name":"井中月","can_delete":false,"product_type":"c1","uid":1006742,"ip_address":"","ucode":"7B1EE2B1A5D401","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/96/2fe46b27.jpg","comment_is_top":false,"comment_ctime":1541046710,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541046710","product_id":100017301,"comment_content":"课后作业，我的理解就是有序序列的合并，思想就是归并中的merge。但由于这里是10个文件，所以比较的次数就是关键，我们可以建一个双向链表，先读10个文件中的第一条数据放入链表，然后对链表进行时间戳排序，head为最小时间戳。取链表head中元素存放到新日志文件，读取head对应文件下一条日志，head移到下一个元素，新取出日志比较插入到链表中，依次知道读完所有文件，然后把链表全部写入即可。内存的限制主要增加了磁盘读写的io时间，所以这里可以建10条io流对应10个日志文件，每次取90m出来，直到比较完再取下一次；建一个100m的内存空间放排序好的日志，满就写磁盘，最后全部写入即可。","like_count":0},{"had_liked":false,"id":36014,"user_name":"geek_banana","can_delete":false,"product_type":"c1","uid":1161973,"ip_address":"","ucode":"6FB2816C0EFF66","user_header":"https://static001.geekbang.org/account/avatar/00/11/ba/f5/a028f728.jpg","comment_is_top":false,"comment_ctime":1540889774,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540889774","product_id":100017301,"comment_content":"我觉得在快速排序里面，分区条件改为value &lt;= pivot, 从前向后遍历元素，是可以保证相同元素值位置不变的，求老师解释一下","like_count":0},{"had_liked":false,"id":35993,"user_name":"Veigar","can_delete":false,"product_type":"c1","uid":1258773,"ip_address":"","ucode":"FAD1CBB0677D94","user_header":"https://static001.geekbang.org/account/avatar/00/13/35/15/0b7de6b0.jpg","comment_is_top":false,"comment_ctime":1540885353,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540885353","product_id":100017301,"comment_content":"原来以前自己对快排的理解都是错的。。","like_count":0},{"had_liked":false,"id":35956,"user_name":"waine_m","can_delete":false,"product_type":"c1","uid":1125647,"ip_address":"","ucode":"CD510A9C50689D","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/0f/2b81b98b.jpg","comment_is_top":false,"comment_ctime":1540871248,"is_pvip":false,"replies":[{"id":"12827","content":"下节课有的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540950389,"ip_address":"","comment_id":35956,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540871248","product_id":100017301,"comment_content":"老师：归并排序和快速排序能不能也整理一下对比图表，这样比较直观，多谢\t","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427720,"discussion_content":"下节课有的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540950389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35931,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1540864101,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540864101","product_id":100017301,"comment_content":"老师，今天回过来复习第 K 大的数，发现对第 K 大的理解有点模糊，第 K 大不是应该是有 K - 1 个数比目标数大么？为什么文中的思路是，有 K - 1 个比目标值小呢？","like_count":0},{"had_liked":false,"id":35766,"user_name":"子嘉","can_delete":false,"product_type":"c1","uid":1252422,"ip_address":"","ucode":"CF0DC72E2B6B9C","user_header":"https://static001.geekbang.org/account/avatar/00/13/1c/46/a141c7e6.jpg","comment_is_top":false,"comment_ctime":1540785308,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540785308","product_id":100017301,"comment_content":"如果这个数组是 有重复数据的话 那这个算法应该不正确吧？ 比如 1 1 2 2 3 3 4 4 5 5 找第三大","like_count":0},{"had_liked":false,"id":35685,"user_name":"Wilson","can_delete":false,"product_type":"c1","uid":1007140,"ip_address":"","ucode":"3ADBE962C67B8D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/24/040855d3.jpg","comment_is_top":false,"comment_ctime":1540745694,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540745694","product_id":100017301,"comment_content":"老师这节的练习题没有正确答案吗？<br>请老师解答下","like_count":0},{"had_liked":false,"id":35647,"user_name":"李靖峰","can_delete":false,"product_type":"c1","uid":1139247,"ip_address":"","ucode":"AA4DE3E91A1FFA","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/2f/6fe8ee9e.jpg","comment_is_top":false,"comment_ctime":1540727134,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540727134","product_id":100017301,"comment_content":"打开全部文件，从头开始各取80m数据，组成一800m的数组，用快排的逻辑排到某个数据用尽时，将内存中此行之前的数据落盘，再从当前偏移量各个文件中取数据填满80m，重新组成800m数组，如果某个文件已读尽，则从其他文件平均补足，各取floor(80&#47;0.9)=88m。直到全部文件读尽。直到最后一次不足800m数组的快排落盘","like_count":0},{"had_liked":false,"id":35616,"user_name":"qinggeouye","can_delete":false,"product_type":"c1","uid":1251536,"ip_address":"","ucode":"5B53EEDD7BEC9C","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/d0/49b06424.jpg","comment_is_top":false,"comment_ctime":1540712287,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540712287","product_id":100017301,"comment_content":"归并排序：把一个待排序数组A，最终分解成不能再分的各个子数组 A1、A2、A3、...、Ak，然后再按原路将各个子数组合并(每次合并的过程中排序)；<br>快速排序：选择数组中A的一个元素作为基准点pivot，每次将数组划分为两个区间（一个区间的元素全都小于pivot，另一个区间的元素全都大于pivot），按此原则继续划分子区间，直到区间不能再划分为止，排序完毕。","like_count":0},{"had_liked":false,"id":35606,"user_name":"谢特","can_delete":false,"product_type":"c1","uid":1248684,"ip_address":"","ucode":"9C30DBFECFE649","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/ac/09678490.jpg","comment_is_top":false,"comment_ctime":1540703516,"is_pvip":false,"replies":[{"id":"12676","content":"要拷贝到下标p到r之间啊","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540740219,"ip_address":"","comment_id":35606,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540703516","product_id":100017301,"comment_content":"归并最后拷贝数组为什么是p+i,直接A[i]=tmp[i]不就行了吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427596,"discussion_content":"要拷贝到下标p到r之间啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540740219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35603,"user_name":"我能走多远","can_delete":false,"product_type":"c1","uid":1240465,"ip_address":"","ucode":"07DF5D5DADFA3C","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/91/1d332031.jpg","comment_is_top":false,"comment_ctime":1540701138,"is_pvip":false,"replies":[{"id":"12678","content":"嗯 更好点 👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540740272,"ip_address":"","comment_id":35603,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540701138","product_id":100017301,"comment_content":"partition函数中，最好加个判断i和j不相等时才swap A[i] with A[j]","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427594,"discussion_content":"嗯 更好点 👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540740272,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35579,"user_name":"seamoontime","can_delete":false,"product_type":"c1","uid":1235304,"ip_address":"","ucode":"09E36EAE215355","user_header":"https://static001.geekbang.org/account/avatar/00/12/d9/68/38703855.jpg","comment_is_top":false,"comment_ctime":1540690773,"is_pvip":false,"replies":[{"id":"12679","content":"随便起的 没啥原因","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540740317,"ip_address":"","comment_id":35579,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540690773","product_id":100017301,"comment_content":"请问一下，为什么您的代码中喜欢用p,q,r做下标，这是什么单词缩写，还是约定俗成的标志。。。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427584,"discussion_content":"随便起的 没啥原因","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540740317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35559,"user_name":"RogerIs谭纶","can_delete":false,"product_type":"c1","uid":1040934,"ip_address":"","ucode":"8437893C1FF0CC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e2/26/144af4e1.jpg","comment_is_top":false,"comment_ctime":1540656086,"is_pvip":false,"replies":[{"id":"12681","content":"paper","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540740416,"ip_address":"","comment_id":35559,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540656086","product_id":100017301,"comment_content":"请问下文档中的类似手写的图是什么工具生成的？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427575,"discussion_content":"paper","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540740416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35396,"user_name":"木羊人007","can_delete":false,"product_type":"c1","uid":1115203,"ip_address":"","ucode":"375BD287493FA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/04/43/835418b5.jpg","comment_is_top":false,"comment_ctime":1540539485,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540539485","product_id":100017301,"comment_content":"个人觉得可以采用merge() 函数里面的做法，将文件两两比较。例如有A、B、C、D、E、F、G、H、I、J十个文件，将文件两两组合形成A-B、C-D、E-F、G-H、I-J五组，每一组比较后生成一个临时文件tmpFile1、tmpFile2、tmpFile3...，重复上述步骤直到形成一个文件。两个文件中时间戳的比较方式是，每次读取文件中的一行时间戳，小的写入到临时文件中（或者缓存起来批量写出），然后读下一行和大的时间戳比较（如合并A-B文件时，首先A、B文件各读一行，如果TimeA&lt;TimeB则将TimeA写入tmpFile，继续从A文件读取一行与TimeB比较），依次类推，直到其中一个文件被完全读取，将另一个文件中的剩余数据全部写入到tmpFile。","like_count":0},{"had_liked":false,"id":35390,"user_name":"kakasi","can_delete":false,"product_type":"c1","uid":1237297,"ip_address":"","ucode":"64F357E6A08CA5","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/31/eb103bdc.jpg","comment_is_top":false,"comment_ctime":1540537308,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540537308","product_id":100017301,"comment_content":"归并排序分析：<br>1. 原理：对半递归拆分数组，将每个拆分后的数组一一合并，合并时进行排序。<br>2. 执行效率：最好、最坏和平均都是O（nlogn）。这里有个计算递归时间复杂度的一个技巧：T(n) = T(n&#47;2) + T(n&#47;2) + n, 继续分解后 T(n) = 2^k*(T(n&#47;2^k)) + k*n, k = logn其他可以忽略不计。<br>3. 内存消耗：因为在合并结果时需要临时开辟数组，所以是O(n)， 不能和时间复杂度混为一谈，临时数组内存空间是会在函数结束后被回收的，因此取最大的即可。<br>5. 稳定。<br><br>快排分析：<br>1. 原理：取一个基数，一般是最后一位，然后遍历前面的数，比其小的数在左边，否则在右边，最后将基数放到分区位，递归排序左右两部分。<br>2. 执行效率：最好O（nlogn），最坏O（n^2），平均是O（nlogn）。最坏的情况是取最后一位为基数而这个列表已经排序好了。<br>3. 内存消耗：原地排序O（1），这也是为什么快排比归并更受欢迎<br>5. 不稳定。<br><br>这两种排序是大规模的数据排序常用的。","like_count":0},{"had_liked":false,"id":35145,"user_name":"饶飞","can_delete":false,"product_type":"c1","uid":1148259,"ip_address":"","ucode":"FBC67CF5146047","user_header":"https://static001.geekbang.org/account/avatar/00/11/85/63/e22af145.jpg","comment_is_top":false,"comment_ctime":1540436352,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540436352","product_id":100017301,"comment_content":"关于快排的空间复杂度，wiki上说需要计算递归调用过程中占用的固定数量的空间，所以快速排序的空间复杂度最优为O(logn)，最差为O(n)。","like_count":0},{"had_liked":false,"id":35001,"user_name":"D→_→M","can_delete":false,"product_type":"c1","uid":1184017,"ip_address":"","ucode":"5EFDE9E2ED2C8B","user_header":"https://static001.geekbang.org/account/avatar/00/12/11/11/52a78856.jpg","comment_is_top":false,"comment_ctime":1540379157,"is_pvip":false,"replies":[{"id":"12495","content":"没有影响的 不影响稳定性","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540394304,"ip_address":"","comment_id":35001,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540379157","product_id":100017301,"comment_content":"老师我想问一下在快速排序中的partition函数里面“a[j] &lt; pivot”换成“a[j] &lt;= pivot”，会有什么影响？会影响到稳定性吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427409,"discussion_content":"没有影响的 不影响稳定性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540394304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34926,"user_name":"俞永斌","can_delete":false,"product_type":"c1","uid":1246371,"ip_address":"","ucode":"1768F635733751","user_header":"https://static001.geekbang.org/account/avatar/00/13/04/a3/947c3cfe.jpg","comment_is_top":false,"comment_ctime":1540356005,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540356005","product_id":100017301,"comment_content":"merge函数中申请数组大小不是应该是<br>int[] tmp =new array[r-p+1] 吗？<br>归并排序<br>&#47;&#47; 取 p 到 r 之间的中间位置 q <br>q =(p+r) &#47; 2 我觉得写成 q= r+(p-r)&#47;2会好点，避免溢出<br>","like_count":0},{"had_liked":false,"id":34751,"user_name":"NIRVANA","can_delete":false,"product_type":"c1","uid":1135593,"ip_address":"","ucode":"F3A979679AA44E","user_header":"https://static001.geekbang.org/account/avatar/00/11/53/e9/f244988e.jpg","comment_is_top":false,"comment_ctime":1540282542,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540282542","product_id":100017301,"comment_content":"在做模拟股票收益排行的时候，用到了归并排序算法，根据前面讲到的将递归代码用普通的循环来实现，发现在有100万条数据的情况下排序的时间会快一点，但是想知道在用循环的这一段代码中，<br>    public static void sortNew(int [] sort){<br>        System.out.println(&quot;开始排序&quot;);<br>        long start = System.currentTimeMillis();<br>        int left, mid, right,len;<br>        len  = sort.length;<br>        for(int i = 1 ;i &lt; len; i *= 2) {<br>            left = 0;&#47;&#47; 从数组第一个元素开始<br>            while (left + i &lt; len) {<br>                mid = left + i - 1;<br>                right = mid + i &lt; len ? mid + i : len - 1;<br>                merger(sort, left, mid, right);<br>                left = right + 1;               &#47;&#47;下标后移<br>            }<br>        }<br>        long end = System.currentTimeMillis();<br>        System.out.println(&quot;排序耗时: &quot;+ (end - start));<br>    }<br>我想知道在for循环中以多大倍数的跨度来进行执行效率会比较高，老师。","like_count":0},{"had_liked":false,"id":34674,"user_name":"小花小黑的铲屎官","can_delete":false,"product_type":"c1","uid":1050823,"ip_address":"","ucode":"56061DCDD5EBE1","user_header":"https://static001.geekbang.org/account/avatar/00/10/08/c7/6b0cb046.jpg","comment_is_top":false,"comment_ctime":1540257282,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540257282","product_id":100017301,"comment_content":"哦，明白了","like_count":0},{"had_liked":false,"id":34614,"user_name":"keep_curiosity","can_delete":false,"product_type":"c1","uid":1246273,"ip_address":"","ucode":"794DC1D3FB9214","user_header":"https://static001.geekbang.org/account/avatar/00/13/04/41/082e2706.jpg","comment_is_top":false,"comment_ctime":1540218770,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540218770","product_id":100017301,"comment_content":"思考题思路:<br>每个文件先读90M数据，从10个文件的最小值中选出最小值放到缓存数组中(数组大小为90M)，反复重复选取最小值得过程。<br>在此过程中<br>1.任何一个文件读出来的数据被处理完，就再读取90M出来，直到读取完。<br>2.当缓存数组为放满时就将数据写入合并文件，并清空数组。<br>直到所有数据处理完，缓存数组都写入到合并文件。","like_count":0},{"had_liked":false,"id":34568,"user_name":"macro","can_delete":false,"product_type":"c1","uid":1266076,"ip_address":"","ucode":"955060C6D4ED04","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eojw5WJibLrSLJ4TDsFgibzA7ia8iaIibIP0NJbiagBibOhbsFziaKCQs2pibQH9Ad8tX8hvFbzC37P2oDzxwQ/132","comment_is_top":false,"comment_ctime":1540208687,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540208687","product_id":100017301,"comment_content":"关于课后思考,可以先每个文件取40m,加载入内存,然后逐个比较每个数组的最小值(10个数组中当前比较的10个数的最小的),写入文件,位置加1,如果加载到内存的文件用完,继续加载对应的文件的数据,如此循环,知道数据比较完毕竟,全部写入文件","like_count":0},{"had_liked":false,"id":34501,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1540192670,"is_pvip":false,"replies":[{"id":"12328","content":"加油 💪多看几遍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540258581,"ip_address":"","comment_id":34501,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540192670","product_id":100017301,"comment_content":"今天的课程有点难<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427229,"discussion_content":"加油 💪多看几遍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540258581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34476,"user_name":"sky","can_delete":false,"product_type":"c1","uid":1060892,"ip_address":"","ucode":"B29CA98AC45F88","user_header":"https://static001.geekbang.org/account/avatar/00/10/30/1c/e160955d.jpg","comment_is_top":false,"comment_ctime":1540184597,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540184597","product_id":100017301,"comment_content":"之前一直想学quick select然后看了几篇博客没看懂,就在这里看到啦，开心","like_count":0},{"had_liked":false,"id":34465,"user_name":"Ricky","can_delete":false,"product_type":"c1","uid":1170716,"ip_address":"","ucode":"AC425DBE520771","user_header":"https://static001.geekbang.org/account/avatar/00/11/dd/1c/6ce66b48.jpg","comment_is_top":false,"comment_ctime":1540181157,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540181157","product_id":100017301,"comment_content":"python实现快排<br><br>def quickSort(array):<br><br>    if len(array) &lt; 2:<br>        return array  # -----------基线条件<br>    else:<br>        pivot = array[0]  # -----------递归条件<br>        less = [i for i in array[1:] if i &lt;= pivot]<br>        greater = [i for i in array[1:] if i &gt; pivot]<br><br>    return quickSort(less) + [pivot] + quickSort(greater)","like_count":0},{"had_liked":false,"id":34437,"user_name":"安龙","can_delete":false,"product_type":"c1","uid":1238285,"ip_address":"","ucode":"1467E056FA89F3","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/0d/a8b0eb81.jpg","comment_is_top":false,"comment_ctime":1540171768,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540171768","product_id":100017301,"comment_content":"由于这10个已经是有序的，所以只需要merge的动作吧","like_count":0},{"had_liked":false,"id":34349,"user_name":"小龙的城堡","can_delete":false,"product_type":"c1","uid":1005727,"ip_address":"","ucode":"7F1F9704548E2D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/58/9f/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1540121370,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540121370","product_id":100017301,"comment_content":"您好，关于课后习题我想是不是可以这样解决。因为只有1G内存。1、将10个文件分成4份，（300*3）一份，最后一个是300M单独一份。对前三份可以全部载入内存排序，所以使用快速排序，因为是原地排序，所以不需要额外的空间，排序完成可以全部刷入文件系统；第一步的结果是四个排序好的文件，900M三个，300M一个。2、因为四个文件不能完成两两全部载入内存，所以使用归并排序，因为归并排序需要使用额外的存储，所以将1G的内存分成三份 300M，300M，400M（假设1G=1000M），300M用于存储要排序的数据，400M用于放结果；输入是两个900M的文件要归并，每次分别从两个文件中从小到大读入300M的文件填入内存，形成400M的归并结果停止，然后刷入文件；然后再从外部文件读入400M的数据，直到完成计算；3、第二步做完后结果是1800M的文件1个，1200M的文件1个，再使用第二步的方法将这两个文件归并成3000M的结果文件。<br><br>不知道这样做是否可以，感谢回复～","like_count":0},{"had_liked":false,"id":34293,"user_name":"阿尔卑斯","can_delete":false,"product_type":"c1","uid":1244998,"ip_address":"","ucode":"0C9C026D02002D","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/46/2ea2fe90.jpg","comment_is_top":false,"comment_ctime":1540090305,"is_pvip":false,"replies":[{"id":"12269","content":"你得综合想想啊 贴代码对我来说没啥负担 但是文稿就很丑了 很长很长的代码。代码我基本上都放到github上了 你可以去那里看。再说你自己搜搜 写写 不是更有提高吗 伸手拿来直接看印象肯定不深的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540173856,"ip_address":"","comment_id":34293,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540090305","product_id":100017301,"comment_content":"王老师，我代表基础一般学员(我想大部分都是吧)，强烈要求文稿里附上完整的“算法代码实现”，而不要只是伪代码，不然，我们还得从网络上找完整代码实现，找到的也未必是你讲解的实现框架和版本…这样一来，我们学习效率和质量都会大打折扣，我想这也不是您开设这门课程的初衷吧！…在比，代表广大学员拜托王老师，接下来把讲解每种算法的完整代码实现在文稿中添加，谢谢！","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427164,"discussion_content":"你得综合想想啊 贴代码对我来说没啥负担 但是文稿就很丑了 很长很长的代码。代码我基本上都放到github上了 你可以去那里看。再说你自己搜搜 写写 不是更有提高吗 伸手拿来直接看印象肯定不深的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540173856,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34289,"user_name":"CrazyGoMan","can_delete":false,"product_type":"c1","uid":1114035,"ip_address":"","ucode":"6B6FA4612B91C3","user_header":"https://static001.geekbang.org/account/avatar/00/10/ff/b3/a236be3c.jpg","comment_is_top":false,"comment_ctime":1540088455,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1540088455","product_id":100017301,"comment_content":"课后思考题：逐一读取10个文件到数组中，数组进行快排，将排好序的数组写入到相应文件中。因为是逐一读取，这个文件读取完排好序后，才开始下一个文件的读取和排序，那么占用的内存大小始终是300M。这个操作的结果是10个文件内的数据都是各自有序的了。之后模仿归并排序合并数组的逻辑，创建一个几百M大小的临时数组，设置10个指针分别指向10个文件的第一条数据，边读取比较大小，小的就放入到临时数组中且相应指针加1，临时数组满时就将其内容刷新到一个大小为3G的文件中，重复这个过程，最后这个3G的文件就是10个文件合并的排好序的文件。","like_count":0},{"had_liked":false,"id":34244,"user_name":"Summer","can_delete":false,"product_type":"c1","uid":1213499,"ip_address":"","ucode":"FBFB6962ED84F7","user_header":"https://static001.geekbang.org/account/avatar/00/12/84/3b/ba1b626e.jpg","comment_is_top":false,"comment_ctime":1540046870,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540046870","product_id":100017301,"comment_content":"老师，归并排序实现merge的时候，是把两个有序数组合并成一个有序数组。我觉得可以不需要开辟额外数组的呀。比如，merge(Arr(p,r),Arr(r+1,q)，把Arr(r)和Arr(q)中大的一个放Arr(q)的位置，再依次向前比较就行了。","like_count":0},{"had_liked":false,"id":34230,"user_name":"Cest la vie","can_delete":false,"product_type":"c1","uid":1246987,"ip_address":"","ucode":"6017B81F4321BA","user_header":"https://static001.geekbang.org/account/avatar/00/13/07/0b/a33982a5.jpg","comment_is_top":false,"comment_ctime":1540042704,"is_pvip":false,"replies":[{"id":"12348","content":"看着不会啊","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540259227,"ip_address":"","comment_id":34230,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540042704","product_id":100017301,"comment_content":"partition(A, p, r) {<br>  pivot := A[r]<br>  i := p<br>  for j := p to r-1 do {<br>    if A[j] &lt; pivot {<br>      swap A[i] with A[j]<br>      i := i+1<br>    }<br>  }<br>  swap A[i] with A[r]<br>  return i<br><br>当数组中存在多个重复时，你的partition 是不是陷入死循环了？如A=[2,5,4,2]，partition 一直返回是0","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427152,"discussion_content":"看着不会啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540259227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34228,"user_name":"老姚","can_delete":false,"product_type":"c1","uid":1150339,"ip_address":"","ucode":"51A9ABBA1FFFE9","user_header":"https://static001.geekbang.org/account/avatar/00/11/8d/83/8b6972c0.jpg","comment_is_top":false,"comment_ctime":1540041771,"is_pvip":false,"replies":[{"id":"12349","content":"好像不行","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540259249,"ip_address":"","comment_id":34228,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540041771","product_id":100017301,"comment_content":"文章中针对 一个已为升序的队列 时间为 O(n^2) ,加条如下判断进行识别<br>q = partition(A, p, r) &#47;&#47; 获取分区...<br>if (q==r) return ； &#47;&#47; 如果q=r  说明是一个有序的，不用再进行排序。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427150,"discussion_content":"好像不行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540259249,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34177,"user_name":"大坏蛋","can_delete":false,"product_type":"c1","uid":1240376,"ip_address":"","ucode":"E5728F85273D14","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/38/217ecccb.jpg","comment_is_top":false,"comment_ctime":1540032179,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540032179","product_id":100017301,"comment_content":"re:<br>walor<br>课后思考<br>1.申请 10 个数组，每个数组 30M。再申请个临时数组，大小 300M。<br>2.每个文件每次读取 30M 数据分别存入 30M 的数组中。<br>3.比较 10 个数组的最大时间戳，获取它们中的最小值<br>4.合并排序 10 个数组。排序完成后，取出数组前 30M 存入磁盘（硬盘上的最终日志文件），后 270M 存入文件<br>5.循环至 300M 文件读取结束，生成 10 个新的 270M 文件<br>6.重复步骤 1。<br>7.终止条件：生成的新文件大小 0M。<br>=================================================<br>同意walor思想，但是第一次合并排序后，数组前30M存入磁盘，后270M存入文件；此时产生11个270M文件；新产生文件也要参与合并排序；以此类推，直至没有新文件生成。为了减少文件IO，每次读取数组大小可以进行优化。","like_count":0},{"had_liked":false,"id":34176,"user_name":"Rain","can_delete":false,"product_type":"c1","uid":1238221,"ip_address":"","ucode":"6A270D922A3B9D","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","comment_is_top":false,"comment_ctime":1540031799,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540031799","product_id":100017301,"comment_content":"--<br>老师，有个问题没懂，在一个数组中找第k大的数这个问题中，为什么如果p+1=k，a[p]就是要查找的结果呢？<br>--<br><br>我理解是：<br>P是支点的index，每一轮快排之后都能确定这个P的index，而且这个index就是他在最终排序后的数组中的位置。<br><br>对于老师的那个例子来说，要解的问题是找出数组中的第3大元素，那么他肯定是在最终排序后的数组中的index=2的那个元素。在例子中一轮快排之后，选定的支点元素 8 被交换到了index=2的位置，所以8就要找的第 K=3 大元素，而他的index=2，故证明：如果p+1=k，a[p]就是要查找的结果 。","like_count":0},{"had_liked":false,"id":34134,"user_name":"来风","can_delete":false,"product_type":"c1","uid":1211896,"ip_address":"","ucode":"A9470EE0E322D5","user_header":"https://static001.geekbang.org/account/avatar/00/12/7d/f8/1ee5514d.jpg","comment_is_top":false,"comment_ctime":1540016274,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540016274","product_id":100017301,"comment_content":"leetcode上的215. Kth Largest Element in an Array，可以作为练习","like_count":0},{"had_liked":false,"id":34120,"user_name":"纯洁的憎恶","can_delete":false,"product_type":"c1","uid":1130512,"ip_address":"","ucode":"5E9757DE6F45DF","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/10/b6bf3c3c.jpg","comment_is_top":false,"comment_ctime":1540009242,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1540009242","product_id":100017301,"comment_content":"快速排序与归并排序都是分治策略，不同之处在于，快速排序是先确定分区之间的有序性再向下递归，归并排序则是递进到最低层后向上归并的时候才能确定分区之间的有序性。于是可以看出，快速排序是自顶向下的分治，归并排序是自底向上的分治。","like_count":0},{"had_liked":false,"id":34057,"user_name":"shawn","can_delete":false,"product_type":"c1","uid":1053716,"ip_address":"","ucode":"8F7CE170AE1F57","user_header":"","comment_is_top":false,"comment_ctime":1539964209,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539964209","product_id":100017301,"comment_content":"课后题，先说一个内存消耗为常数的个人想法，开十个文件流，读取十个文件的第一行，找到时间戳最小的一行，假设是第X个文件，先把这一行输出，然后读入X文件的第二行，再在十个值中找找最小，假设是Y文件，最小的一行输出，然后读入Y文件下一行，以此类推，直到所有文件都读完结束<br><br>所以1G的内存是完全够用的，考虑磁盘性能一次性读取大的块比较高效，所以每个文件先读入80M，压入十个输入队列，然后保留一个200M的结果队列，出队第一个，比较，写入结果队列，然后出队第二个，结果队列满了就写到文件，输入队列空了就再加载80M，直到做完。<br><br>不知道思路有没有问题，请老师指点","like_count":0},{"had_liked":false,"id":34038,"user_name":"来碗绿豆汤","can_delete":false,"product_type":"c1","uid":1070051,"ip_address":"","ucode":"B0AB63B8D9729F","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/e3/39dcfb11.jpg","comment_is_top":false,"comment_ctime":1539960404,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539960404","product_id":100017301,"comment_content":"思考题: 各个文件是有序的，就相当于归并排序切成的小块已经由于，下面就是merge了。每个文件读一行数据，时间最小的写入合并后文件(可缓存)，然后从对应文件中再读一行，一直到所有文件都读完为止。","like_count":0},{"had_liked":false,"id":34025,"user_name":"勤劳的小胖子-libo","can_delete":false,"product_type":"c1","uid":1158344,"ip_address":"","ucode":"5BB20CD5A56568","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/c8/4b1c0d40.jpg","comment_is_top":false,"comment_ctime":1539953446,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539953446","product_id":100017301,"comment_content":"使用桶排序的方式,先查看一下这十个日志的日期范围，至少先分成六大份，比如对应1对6月，从小到大，对应六个文件，把相关的时间日志放入到相应的文件中，如果正好平均分布，每一份再保存十个小文件，每个保存属于特定月份的来源于上面300M的日志文件，平均而言是每个50^_^M，二二归并，使每个文件有序，十个小文件一共500M，归并中需要额外500M中保持数组，所以设置每个50M，然后把这六个大文件依次读入写入到目标文件。<br><br>当然，日志不一定正好平均分布，如果某个大份里面数据过多，比如2月份数据量过多，可以再细分成上中下旬，然后从十个日志文件中对应的部分写入文件，在归并。反正只做最小结点来归并。<br><br>因为二二小文件本身都有序的，可以直接归并，时间复杂度N*k，k为分了几层。如果分层较少，接近O(n)。","like_count":0},{"had_liked":false,"id":34007,"user_name":"程","can_delete":false,"product_type":"c1","uid":1006991,"ip_address":"","ucode":"66386B3603D39F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5d/8f/16e1da5d.jpg","comment_is_top":false,"comment_ctime":1539946165,"is_pvip":false,"replies":[{"id":"12201","content":"就是上面推导的最后一步","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540049798,"ip_address":"","comment_id":34007,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539946165","product_id":100017301,"comment_content":"老师，打扰下，求归并排序的时间复杂度时：“得到 k=log2n 。我们将 k 值代入上面的公式，得到T(n)=Cn+nlog2n。如果我们用大 O 标记法来表示的话，T(n) 就等于 O(nlogn)”<br>这里的“上面的公式”是指哪个吖，数学渣渣没找到，谢谢解答了","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427101,"discussion_content":"就是上面推导的最后一步","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540049798,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33917,"user_name":"程序员大天地","can_delete":false,"product_type":"c1","uid":1249001,"ip_address":"","ucode":"7A21F15FEE2D5B","user_header":"https://static001.geekbang.org/account/avatar/00/13/0e/e9/98b6ea61.jpg","comment_is_top":false,"comment_ctime":1539918278,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539918278","product_id":100017301,"comment_content":"快排不是稳定的排序，这是它的一个缺陷，这个难道影响不大吗？我们应该更热衷稳定排序吧","like_count":0},{"had_liked":false,"id":33915,"user_name":"程序员大天地","can_delete":false,"product_type":"c1","uid":1249001,"ip_address":"","ucode":"7A21F15FEE2D5B","user_header":"https://static001.geekbang.org/account/avatar/00/13/0e/e9/98b6ea61.jpg","comment_is_top":false,"comment_ctime":1539918141,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539918141","product_id":100017301,"comment_content":"这个留言要是我们可以评论就好，真的好想评论下别人的留言","like_count":0},{"had_liked":false,"id":33905,"user_name":"Vinegar.","can_delete":false,"product_type":"c1","uid":1234957,"ip_address":"","ucode":"FEDBBAD54DB223","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/0d/bc1957cf.jpg","comment_is_top":false,"comment_ctime":1539916756,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539916756","product_id":100017301,"comment_content":"伪代码看的好累啊，还是 JAVA 代码和 c 代码看的比较直观","like_count":0},{"had_liked":false,"id":33874,"user_name":"微秒","can_delete":false,"product_type":"c1","uid":1249195,"ip_address":"","ucode":"65A2E8B565B191","user_header":"https://static001.geekbang.org/account/avatar/00/13/0f/ab/9748f40b.jpg","comment_is_top":false,"comment_ctime":1539913471,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539913471","product_id":100017301,"comment_content":"如果数组中的数据原来已经是有序的了，比如 1，3，5，6，8。我们需要进行大约 n 次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约 n&#47;2 个元素。<br>不是很理解为什么每次分区我们平均要扫描大约 n&#47;2 个元素，而不是n-1个元素？？？<br>","like_count":0},{"had_liked":false,"id":33869,"user_name":"Pan^yu","can_delete":false,"product_type":"c1","uid":1235771,"ip_address":"","ucode":"28F983B58A9EC2","user_header":"https://static001.geekbang.org/account/avatar/00/12/db/3b/e56ff0a9.jpg","comment_is_top":false,"comment_ctime":1539913260,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539913260","product_id":100017301,"comment_content":"课后问题有个坑要留意，如果10个日志的时间戳大小个不一样，用固定大小去拆分，可能出现排完序中最大时间戳不是为排序的最小时间戳。我认为，先遍历10个文件第一行时间戳，以固定大小去截取时间戳最小的文件，获取截取内容的最大时间戳，然后用这个最大时间戳去截取后面的9个文件，在进行排序，以此递推下去","like_count":0},{"had_liked":false,"id":33831,"user_name":"Linuxer","can_delete":false,"product_type":"c1","uid":1153978,"ip_address":"","ucode":"272D9D8089C3D6","user_header":"https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg","comment_is_top":false,"comment_ctime":1539908762,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539908762","product_id":100017301,"comment_content":"思考题应该可以部分读入加多路归并","like_count":0},{"had_liked":false,"id":33767,"user_name":"youngshi","can_delete":false,"product_type":"c1","uid":1241326,"ip_address":"","ucode":"063478BDA53AB5","user_header":"https://static001.geekbang.org/account/avatar/00/12/f0/ee/ff6ec4f6.jpg","comment_is_top":false,"comment_ctime":1539876121,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539876121","product_id":100017301,"comment_content":"快排加归并？<br>总共3G文件数量10个，内存1G<br>1g&#47;10=100m,临时空间100m&#47;2=50m<br><br>每次每个文件读50M即每个文件分成6个50m等份的区间，每个区间取开始和结束的日志时间放到长度为6的数组中<br><br>那就有60个区间，求交集，有交集的才需要排，那么有些无交集，有些多个区间交集分别计算排序，写到临时数组区间，然后将各个排序好的区间(区间又有顺序)写到文件<br><br><br>排序的过程就是交集的区间用归并的方式合并<br><br>瞎想的，这个题目拿来写代码很有意思，明天写写<br>","like_count":0},{"had_liked":false,"id":33766,"user_name":"zixuan","can_delete":false,"product_type":"c1","uid":1131300,"ip_address":"","ucode":"C72920DD05B074","user_header":"https://static001.geekbang.org/account/avatar/00/11/43/24/3f9f7c70.jpg","comment_is_top":false,"comment_ctime":1539876082,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539876082","product_id":100017301,"comment_content":"思考题描述是不是合适，比如这个接口是不是可以流式读取，还是只能一下全部导入内存中。否则直接10路归并不行吗，每次每个接口读一个元素到内存也行啊","like_count":0},{"had_liked":false,"id":33753,"user_name":"Geek_af3d01","can_delete":false,"product_type":"c1","uid":1107401,"ip_address":"","ucode":"58C5FDD61C955E","user_header":"https://static001.geekbang.org/account/avatar/00/10/e5/c9/fa9199d0.jpg","comment_is_top":false,"comment_ctime":1539872561,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539872561","product_id":100017301,"comment_content":"github上传可不可以传真实的代码 自己实现过 想对比参照下","like_count":0},{"had_liked":false,"id":33746,"user_name":"Mib Du","can_delete":false,"product_type":"c1","uid":1252853,"ip_address":"","ucode":"8339E9E13D16DC","user_header":"https://static001.geekbang.org/account/avatar/00/13/1d/f5/ff8d82e4.jpg","comment_is_top":false,"comment_ctime":1539870997,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539870997","product_id":100017301,"comment_content":"对啊老师，那个伪代码反而看起来满费劲的，希望老师能直接用代码实现。","like_count":0},{"had_liked":false,"id":33742,"user_name":"🐱您的好友William🐱","can_delete":false,"product_type":"c1","uid":1215456,"ip_address":"","ucode":"427786DB178965","user_header":"https://static001.geekbang.org/account/avatar/00/12/8b/e0/9a79ddac.jpg","comment_is_top":false,"comment_ctime":1539869805,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539869805","product_id":100017301,"comment_content":"最后一题肯定不是分批归并最后合到一起啊，有可能10个文件分别属于不同月份的呢。。。我的初步想法是按时间戳找，反正是有序的，10个并行按一个时间戳找，直到某个时间戳之前的十个文件总数据填满了1G，就快排之后就存起来。那么10个文件中所有剩余的数据就都是这个时间戳之后的了，就不会出现总文件时间乱序的现象了。。。。肯定不是最优解，还得再好好想想。","like_count":0},{"had_liked":false,"id":33703,"user_name":"李","can_delete":false,"product_type":"c1","uid":1119312,"ip_address":"","ucode":"5C0FAA211F2E26","user_header":"https://static001.geekbang.org/account/avatar/00/11/14/50/c23cf47d.jpg","comment_is_top":false,"comment_ctime":1539857481,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1539857481","product_id":100017301,"comment_content":"我发现还是有很多细节问题，比如是奇数个，就不能均分，会出现小数。另外如果下边从零开始。0和1相加，均值是0.5。这样，递归下去是。0和0.5，1.5和1。但实际没有0.5和1.5的坐标。","like_count":0},{"had_liked":false,"id":33700,"user_name":"李","can_delete":false,"product_type":"c1","uid":1119312,"ip_address":"","ucode":"5C0FAA211F2E26","user_header":"https://static001.geekbang.org/account/avatar/00/11/14/50/c23cf47d.jpg","comment_is_top":false,"comment_ctime":1539855869,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1539855869","product_id":100017301,"comment_content":"为什么不是＝？大于的情况有可能出现吗？应该没有可能吧。","like_count":0},{"had_liked":false,"id":33678,"user_name":"小苏饼","can_delete":false,"product_type":"c1","uid":1247539,"ip_address":"","ucode":"80868F7477E2BB","user_header":"https://static001.geekbang.org/account/avatar/00/13/09/33/57757a23.jpg","comment_is_top":false,"comment_ctime":1539851801,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539851801","product_id":100017301,"comment_content":"这种TopN的问题是要用快排还是堆比较好？我看这种问题网上大多是用堆 ","like_count":0},{"had_liked":false,"id":33654,"user_name":"李","can_delete":false,"product_type":"c1","uid":1119312,"ip_address":"","ucode":"5C0FAA211F2E26","user_header":"https://static001.geekbang.org/account/avatar/00/11/14/50/c23cf47d.jpg","comment_is_top":false,"comment_ctime":1539845226,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1539845226","product_id":100017301,"comment_content":"T(n) = 2*T(n&#47;2) + n； n&gt;1，为什么这里是加n，不是O(n)吗？","like_count":0},{"had_liked":false,"id":33652,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1539844542,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539844542","product_id":100017301,"comment_content":"这篇文章我花了两天才读完，了解了 归并和快排的思想，但是时间复杂度仍然是让我头疼的一块<br>至于思考题 <br>我觉得情况分两种<br>1. 时间戳:01234 56789这类型的文件<br>    针对这类型的日志文件只需要进行选择排序每次最小的文件依次写入最终日志文件<br>2. 时间戳为:13579 2468十类型 有穿插大小的时间戳排序文件<br>     我们可以10通道从10个文件中读取固定的大小的日志内容只要不超过1G，进行排序写入最终日志文件，然后读到所有文件都读完为止，这样的原因就是因为本身文件已经有序，所以敢保证 先进去的内容一定小于或大于后面写进去的内容<br>","like_count":0},{"had_liked":false,"id":33602,"user_name":"李","can_delete":false,"product_type":"c1","uid":1119312,"ip_address":"","ucode":"5C0FAA211F2E26","user_header":"https://static001.geekbang.org/account/avatar/00/11/14/50/c23cf47d.jpg","comment_is_top":false,"comment_ctime":1539832550,"is_pvip":true,"replies":[{"id":"12088","content":"这样有错吗","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539855146,"ip_address":"","comment_id":33602,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1539832550","product_id":100017301,"comment_content":"终止条件为什么是p&gt;=r.","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427010,"discussion_content":"这样有错吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539855146,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1153707,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9a/ab/fd201314.jpg","nickname":"小耿","note":"","ucode":"1C8B66C738D33B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2835,"discussion_content":"请问老师，啥时候会出现大于号的情况？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563961369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33578,"user_name":"windliang","can_delete":false,"product_type":"c1","uid":1234620,"ip_address":"","ucode":"D31E26BFB09DE6","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/bc/026ac6b1.jpg","comment_is_top":false,"comment_ctime":1539827922,"is_pvip":false,"replies":[{"id":"12091","content":"需要的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539855301,"ip_address":"","comment_id":33578,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539827922","product_id":100017301,"comment_content":"老师问一下，递归的空间复杂度需要考虑递归中堆栈所用的空间吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427005,"discussion_content":"需要的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539855301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33485,"user_name":"子夜2104","can_delete":false,"product_type":"c1","uid":1070286,"ip_address":"","ucode":"C4FF54AEA6002F","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/ce/92029d2f.jpg","comment_is_top":false,"comment_ctime":1539792609,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539792609","product_id":100017301,"comment_content":"又学到一个小技巧:快排分区操作类似选择排序，目的就是选择出比分区点小的元素放在一边。<br>之前一直比较迷糊，没有很好的理解。谢谢老师，专栏很棒😁","like_count":0},{"had_liked":false,"id":33263,"user_name":"雨天","can_delete":false,"product_type":"c1","uid":1056406,"ip_address":"","ucode":"FD9FB404ECA463","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/96/3162d51f.jpg","comment_is_top":false,"comment_ctime":1539767961,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539767961","product_id":100017301,"comment_content":"快排partition函数按搬移数据实现的话,可实现稳定排序且时间复杂度和空间复杂度保持不变;<br>归并排序Merge函数通过将数组的后半部分插入到前半部分可实现原地排序,时间复杂度会增加.<br>当然这两种实现方式显然都不是最佳实践.<br>思考题:<br>1.从10个文件中每次取50M进行排序,合并成6个500M的文件;均分成3组;<br>2.组中取每个文件前250M合并成一个文件A,后250M合并成B;<br>3.将A的前250M写入一个单独文件C;<br>4.A剩下250M和B的500M的前250M合并D,将D的前250M追加到C中;<br>5.将B剩下250M和D剩下的250合并写入C中,以此合并成3个1000M的有序文件E,F,G;<br>6.将E,F分别取250M合并,并将前250M写入H中,后250M写入I;<br>7.分别从E,F取250M合并写入J;<br>8.将J前250M和I合并后,取前250M追加到H,剩下回写I;<br>9.合并I,J写入I;<br>10.以此类推,得到2000M的H和1000M的G;<br>11.用类似的方式合并H,G即可.","like_count":0},{"had_liked":false,"id":33235,"user_name":"柠檬C","can_delete":false,"product_type":"c1","uid":1181505,"ip_address":"","ucode":"BC0EE704D952A4","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/41/2d477385.jpg","comment_is_top":false,"comment_ctime":1539762974,"is_pvip":false,"replies":[{"id":"12022","content":"能看懂就行了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539774535,"ip_address":"","comment_id":33235,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539762974","product_id":100017301,"comment_content":"这个伪代码像pascal风格啊","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426953,"discussion_content":"能看懂就行了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539774535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33172,"user_name":"DADDYHINS","can_delete":false,"product_type":"c1","uid":1189131,"ip_address":"","ucode":"C5676EF53CA248","user_header":"https://static001.geekbang.org/account/avatar/00/12/25/0b/f9fc5255.jpg","comment_is_top":false,"comment_ctime":1539754231,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1539754231","product_id":100017301,"comment_content":"把文件分小组，每组1g，在内存中进行归并排序，排序完了写进目标文件，以此类推","like_count":0},{"had_liked":false,"id":33137,"user_name":"NeverMore","can_delete":false,"product_type":"c1","uid":1228498,"ip_address":"","ucode":"582698D772810D","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/d2/3d88cb8e.jpg","comment_is_top":false,"comment_ctime":1539748545,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539748545","product_id":100017301,"comment_content":"充分利用1G的内存空间。分三次，将300M的文件分成3份，每份100M，10个文件一共1G，内存内对这1G文件进行归并排序。然后将排序好的1G文件写入到磁盘。这样最终会有3份1G的文件落到磁盘上，然后通过读取每份文件的时间戳，对这3份文件进行排序并直接写入到磁盘内（外排）。 <br>比较依赖磁盘的I&#47;O性能。","like_count":0},{"had_liked":false,"id":33125,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1539747259,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539747259","product_id":100017301,"comment_content":"# 并归排序 vs. 快速排序<br><br>并归排序跟数据有序度无关，时间复杂度稳定在 O(nlogn); 快速排序复杂度受有序度的影响，最坏情况复杂度是 O(n^2)，平均复杂度是 O(nlogn)。<br><br>并归排序的处理是由下到上的，所以需要额外的空间，将有序数组进行重组，空间复杂度为 O(n)。快速排序的处理过程是由上而下的，分区的过程中排序，所以它是原地排序。<br><br>归并排序合并时可以保证相同元素保持原来的顺序，所以是稳定的排序；而快速排序是不稳定排序。<br>","like_count":0},{"had_liked":false,"id":32995,"user_name":"cricket1981","can_delete":false,"product_type":"c1","uid":1001715,"ip_address":"","ucode":"758262F5958DA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/f3/f1034ffd.jpg","comment_is_top":false,"comment_ctime":1539739288,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539739288","product_id":100017301,"comment_content":"分三批处理，每批读入每个文件100MB，10个文件是1G，在内存中归并排序后写入目标文件，完了再下一批处理","like_count":0},{"had_liked":false,"id":32934,"user_name":"徐凯","can_delete":false,"product_type":"c1","uid":1244991,"ip_address":"","ucode":"12F82BA3649CD5","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/3f/bbb8a88c.jpg","comment_is_top":false,"comment_ctime":1539736446,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539736446","product_id":100017301,"comment_content":"思考题是不是通过将文件放在外存 多路归并排序","like_count":0}]}