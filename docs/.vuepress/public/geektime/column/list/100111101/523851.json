{"id":523851,"title":"23｜微服务拆分（三）：如何拆分存储过程？","content":"<p>你好，我是姚琪琳。</p><p>上节课我们学习了解耦数据库表的三种方法，单体架构拆分的挑战又下一城。</p><p>虽然在遗留系统中，用Java直接调用SQL语句十分常见，但真正的大Boss，是调用链很深的存储过程。</p><p>在十几二十年前，将业务逻辑写在数据库的存储过程或函数中是一种潮流。虽然这种潮流有着当时的历史背景，但在现在看来显然是“最差实践”了。如果遗留系统中存在大量的存储过程，该如何应对呢？我们今天就来学习这方面的内容。</p><h2>将存储过程或函数封装成API</h2><p>在遗留系统中，存储过程和函数往往用来封装复杂的业务逻辑。比如“审核核保申请”这样一个功能，可能会修改二十多张表。这里的表有的与核保相关，也有的与核保关系并不大，比如保单表。</p><p>然而用存储过程或函数来编写业务逻辑的风气一旦形成，很多简单的业务逻辑，比如对单张或少量表的修改，开发人员也会自然而然放到存储过程或函数里。</p><p>我曾经见过用数据库函数来比较时间前后关系的自定义函数，明明任何一门编程语言都提供了这种基本功能，但当时的开发人员却偏偏钟爱SQL，真的是难以理解。</p><p>这样一来，真正的代码反而变成了薄薄的一层胶水，真的是面向数据库编程啊。看到这你先别忙着叹气，我们一起理理思路，争取“分而治之”。</p><!-- [[[read_end]]] --><p>对于十分简单的存储过程或函数（如比较时间前后关系），我们可以将它们改造成代码。这个改造过程不会太难，我就不展开说了。</p><p>对于只涉及少量表的存储过程和函数，我们首先要分析它里面的表的所有权属于谁。主要分成三种情况。</p><ul>\n<li>\n<p>第一种情况：如果全都是与核保业务相关的表，就可以把整个存储过程或函数复制到核保库中，让核保服务的代码直接访问。</p>\n</li>\n<li>\n<p>第二种情况：如果全都是非核保业务相关的表，就可以<strong>将其封装为数据API</strong>，让核保服务调用，具体方式和步骤与上节课的第一招“用API调用取代连表查询”类似。</p>\n</li>\n<li>\n<p>第三种情况：如果既包含与核保业务相关的表，又包含不相关的表，就要先将其拆分成相关和不相关的两部分存储过程或函数，再分别应用上面两种处理方式来处理。</p>\n</li>\n</ul><p>在拆分存储过程和函数的时候，必然会涉及到一些修改。特别是拆分出来的多个存储过程或函数之间，会依赖彼此数据的情况。</p><p>比如下面这个与审核核保申请相关的存储过程（为了突出重点，我做了一定简化）：</p><pre><code class=\"language-sql\">PROCEDURE APPROVE_UNDERWRITE(I_UW_ID IN NUMBER) AS\n  V_UNDERWRITE_APPLICATION TBL_UNDERWRITE_APPLICATION%ROWTYPE;\nBEGIN\n  -- 更新核保申请表\n  UPDATE TBL_UNDERWRITE_APPLICATION \n    SET UNDERWRITE_STATUS = 2 \n        -- 其他字段赋值\n    WHERE UNDERWRITE_ID = I_UW_ID;\n  SELECT * INTO V_UNDERWRITE_APPLICATION WHERE UNDERWRITE_ID = I_UW_ID;\n  -- 更新保单表\n  UPDATE TBL_POLICY \n    SET POLICY_STATUS = V_UNDERWRITE_APPLICATION.POLICY_STATUS\n        -- 其他字段赋值\n    WHERE POLICY_ID = V_UNDERWRITE_APPLICATION.POLICY_ID\nEND APPROVE_UNDERWRITE;\n</code></pre><p>这段存储过程大体上可以拆分为两个阶段，第一个阶段是修改核保申请表，第二个阶段是用修改后的核保申请数据来更新保单表。如果存储过程中的SQL语句和方法一样，也存在代码交织、混乱不堪的情况，你可以复习一下<a href=\"https://time.geekbang.org/column/article/513599\">第九节课</a>讲的<strong>拆分阶段</strong>模式，它也可以应用到存储过程的重构中。</p><p>这个存储过程原本是位于单体数据库中的，我们要对其进行拆分，就要将访问核保表的部分迁移到核保库中：</p><pre><code class=\"language-sql\">-- 核保库中新增的存储过程\nPROCEDURE APPROVE_UNDERWRITE(I_UW_ID IN NUMBER) AS\nBEGIN\n  UPDATE TBL_UNDERWRITE_APPLICATION\n    SET UNDERWRITE_STATUS = 2 \n        -- 其他字段赋值\n    WHERE UNDERWRITE_ID = I_UW_ID;\nEND APPROVE_UNDERWRITE;\n</code></pre><p>但是在原存储过程中就不能直接查询核保申请表了，需要对它进行改写，在调用该存储过程的地方通过API获得核保申请数据，然后再将核保申请数据作为参数传递给这个存储过程。如果数据库支持PL/SQL，我们可以<strong>引入对象类型来进行参数传递</strong>。</p><pre><code class=\"language-sql\">-- 新建的对象类型\nCREATE OR REPLACE TYPE OBJ_UNDERWRITE_APPLICATION AS OBJECT\n(\n  UNDERWRITE_ID NUMBER, POLICY_ID NUMBER, UNDERWRITE_STATUS VARCHAR2(1), -- 其他字段\n  CONSTRUCTOR FUNCTION OBJ_UNDERWRITE_APPLICATION RETURN SELF AS RESULT,\n  CONSTRUCTOR FUNCTION OBJ_UNDERWRITE_APPLICATION(POLICY_ID IN NUMBER, POLICY_ID IN NUMBER, UNDERWRITE_STATUS IN VARCHAR2) RETURN SELF AS RESULT\n);\n-- 单体库中复制出来的原存储过程修改之后\nPROCEDURE APPROVE_UNDERWRITE(V_UNDERWRITE_APPLICATION AS OBJ_UNDERWRITE_APPLICATION)) AS\nBEGIN\n  UPDATE TBL_POLICY \n    SET POLICY_STATUS = V_UNDERWRITE_APPLICATION.POLICY_STATUS\n        -- 其他字段赋值\n    WHERE POLICY_ID = V_UNDERWRITE_APPLICATION.POLICY_ID\nEND APPROVE_UNDERWRITE;\n</code></pre><p>别忘了，我们要把原来的存储过程复制一份出来，不能在原存储过程上直接修改，否则就无法回退了。</p><p>这样一来，调用这个存储过程的代码就变成了这样：</p><pre><code class=\"language-java\">-- 调用上面存储过程的Java代码\nObject[] underwriteApplicationFields = new Object[] { underwriteApplicationDto.getPolicyId(), /*...*/ };\nConnection connection = getConnection();\n-- 在Java中，与对象类型对应的是Struct\nStruct underwriteApplicationStruct = connection.createStruct(\"OBJ_UNDERWRITE_APPLICATION\", underwriteApplicationFields);\nStatement statement = connection.prepareCall(\"{ CALL APPROVE_UNDERWRITE(:underwriteApplication) }\");\nstatement.setObject(\"underwriteApplication\", underwriteApplicationStruct);\nstatement.execute();\n</code></pre><p>以上存储过程我们都可以先在单体数据库中实现，然后在核保库中建立同义词，来访问单体库中的存储过程。</p><p>对于表很少的简单情况，还算比较好拆分。当表又多，关系又错综复杂的时候，就比较棘手了。我们接下来就看看这种情况如何应对。</p><h2>拆分复杂存储过程或函数</h2><p>遗留系统中的存储过程和函数往往是很复杂的，有的时候会涉及到几十甚至上百张表也不为过。我们分情况讨论一下要如何进行拆分。</p><p><strong>第一种情况是SQL的执行彼此之间没有前后顺序关系</strong>。有些存储过程和函数虽然也涉及到很多表，但实际上它们的执行顺序是可以调换的，彼此之间没有依赖关系，先执行谁后执行谁不会影响最终的结果。</p><p>这时候只需要完成下面四步即可：</p><p>1.调整SQL的执行顺序，按数据的所有权进行分组，也就是将涉及单体库表的和涉及核保库表的SQL语句分组；</p><p>2.从与单体库表相关的SQL语句中，提取出一个新的存储过程或函数，并封装成数据API；</p><p>3.在核保服务的防腐层代码中，分别调用数据API和只包含核保库表的那个存储过程或函数（因为它们的执行顺序无关，所以这里调用的前后顺序也无所谓）；</p><p>4.如果涉及到参数传递，就引入对象类型。</p><p><img src=\"https://static001.geekbang.org/resource/image/13/88/132fe02eb69aacf6c5c4518b79b83c88.jpg?wh=1920x1093\" alt=\"图片\"></p><p>我们仍然拿审核核保申请的存储过程举例，假设它由以下三个子存储过程组成，各个子存储过程之间没有先后顺序：</p><pre><code class=\"language-sql\">PROCEDURE APPROVE_UNDERWRITE(I_UW_ID IN NUMBER) AS\n  V_POLICY_ID NUMBER;\nBEGIN\n  UPDATE_POLICY_FOR_APPROVAL(I_UW_ID);\n  SELECT POLICY_ID INTO V_POLICY_ID FROM TBL_UNDERWRITE_APPLICATION WHERE UNDERWRITE_ID = I_UW_ID;\n  UPDATE_UNDERWRITE_APPLICATION_FOR_APPROVAL(V_POLICY_ID);\n  UPDATE_POLICY_PRODUCT_FOR_APPROVAL(V_POLICY_ID);\nEND APPROVE_UNDERWRITE;\n</code></pre><p>按上面的步骤改写完之后就变成了两个，分别位于单体和核保的数据库中：</p><pre><code class=\"language-sql\">-- 单体库中的存储过程\nPROCEDURE APPROVE_UNDERWRITE(I_POLICY_ID IN NUMBER) AS\nBEGIN\n  UPDATE_POLICY_FOR_APPROVAL(I_POLICY_ID);\n  UPDATE_POLICY_PRODUCT_FOR_APPROVAL(I_POLICY_ID);\nEND FINISH_UNDERWRITE;\n-- 核保库中的存储过程\nPROCEDURE APPROVE_UNDERWRITE(I_UW_ID IN NUMBER) AS\nBEGIN\n  UPDATE_UNDERWRITE_APPLICATION_FOR_APPROVAL(I_UW_ID);\nEND FINISH_UNDERWRITE;\n</code></pre><p>而核保中的原API就改为了先执行核保内的存储过程，再通过API来调用单体库中的存储过程：</p><pre><code class=\"language-java\">public void approveUnderwrite(long underwriteId) {\n  // 调用本地存储过程\n  Connection connection = getConnection();\n  Statement statement = connection.prepareCall(\"{ CALL APPROVE_UNDERWRITE(:underwriteId) }\");\n  statement.setLong(\"underwriteId\", underwriteId);\n  statement.execute();\n  // 通过API调用远程存储过程\n  PolicyServiceProvider policyService = new PolicyServiceProvider();\n  policyService.approveUnderwrite(underwriteId);\n}\n</code></pre><p><strong>第二种情况是SQL的执行有前后顺序关系</strong>，比如后面的SQL会依赖到前面SQL的执行结果。这个时候就相当麻烦，并没有好的解决方案，只能按照下面这样的顺序拆分：</p><p>1.将众多SQL按数据的所有权拆分成一组一组的小块，每一小块的内部是顺序无关的；</p><p>2.将这些小块抽取成不同的存储过程或函数；</p><p>3.将属于单体库的存储过程或函数逐一封装成数据API，将属于核保库的存储过程或函数复制到核保库中；</p><p>4.然后再按照原存储过程或函数内部的顺序，在核保服务的防腐层代码中去逐个调用这些API和属于核保库的存储过程或函数；</p><p>5.如果涉及到参数传递，就引入对象类型。</p><p><img src=\"https://static001.geekbang.org/resource/image/07/ee/07b2def89ec817714e0cac6d5779bbee.jpg?wh=1920x1043\" alt=\"图片\"></p><p>对于复杂的存储过程和函数除了拆分本身的工作量外，最重要的就是要确定它们之间的相互依赖关系。对于这一点，并没有非常好的方法，只能耐心加细心。</p><h2>用重试来取代回滚</h2><p>在前面介绍的诸多实践中，我们把大量的SQL语句转换成了API调用。表面上看，它们的执行结果是相同的，但实质上我们已经把很多事务性的操作，转换成了非事务性的。比如在审核核保申请时，本来我们是在一个数据库事务中，修改核保申请表和保单表，任何一个修改失败都会导致整个操作的回滚。</p><p>但这样的修改在解决老问题的同时，也会给我们带来新问题：当把对保单表的修改替换成远程API调用后，情况就变得复杂起来。</p><p>在代码直接修改完毕后，如果我们不做任何调整，原来的事务所包裹的除了执行SQL的代码之外，还包括了调用远程API的代码。这是应该避免的。因为远程API的调用相对来说是不稳定的，有可能耗时过长，也有可能执行成功了，但由于网络问题返回了错误的响应。前者会导致长事务，后者会导致错误的回滚。这时我们就要把调用API的代码从事务中挪出来。</p><p>但这样虽然解决了长事务的问题，回滚又变得麻烦了。如果API调用真的失败了，需要回滚前面的SQL，我们可以编写一个补偿性的SQL来对冲它。但如果API调用是假失败，该怎么处理呢？有的时候，我们甚至无从知道到底是真失败还是假失败。</p><p>作为聪明的开发者，实在解不出答案的时候，我们可以尝试直接“改题目”，也就是回溯问题本身（遵循第一性原理），看看能不能换道题解答。要解决在远程调用失败的情况下本地SQL的回滚问题，不如重新思考一下，这两步操作是否必须在一个事务下？</p><p>单体系统中的代码为了方便，很多有关、无关的批量SQL操作，都会无脑地放入一个事务中，靠数据库提供的提交和回滚功能来进行流程控制。但这些批量操作是否在业务上必须是事务的，恐怕没有人去深究。我们在改造这样的代码时，不妨来把这一课补上，以方便拆分事务。</p><p>还拿审核核保申请这个功能来举例。在修改了核保申请的状态后，要在保单表中也回写一个状态，以前这两步操作位于同一个事务中。但仔细思考并且与业务人员讨论后，我们就会发现，保单表状态是否写入成功，不应该影响当前核保申请的正常核保业务。</p><p>假想一下在线下操作中可能发生的场景：核保员在审核完核保申请之后，在核保申请上填上核保意见、日期并签字盖章，然后在投保单上填上核保意见、日期并签字盖章。我能因为签投保单时笔没水了，就把刚签完的投保单撤销吗？这显然是荒谬的。</p><p>事实上只有在DDD的一个限界上下文内，操作才应该是事务性的。跨限界上下文的调用，都不应该是事务性的，否则就说明限界上下文的划分有问题。在进行微服务拆分之前，既然我们已经把核保作为一个限界上下文了，就说明它与单体的交互就不应该再具有事务性了。</p><p>我们可以选择当API调用失败之后，不管是真失败还是假失败，都可以采取不断重试的方式保证数据的最终一致性。不过这时要注意的一个问题是，<strong>需要重试的API本身必须是幂等的</strong>，即多次重复调用后产生的结果是一致的。否则，多次重试后产生了多个结果，就会造成数据错误。</p><p>如果讨论之后，业务人员还是认为应该保证数据的实时性和一致性，并且限界上下文的划分在大多数情况下也是合理的，这时候就不得不引入分布式事务来解决了。关于分布式事务，极客时间上有很多相关课程，你可以自行拓展学习。但值得说一句的是，分布式事务的解决方案会给整体拆分过程带来极大的认知负载，不到万不得已，不建议采用。</p><p>通过前面的课程，你一定已经清楚了，<strong>将代码依赖或数据依赖改为API依赖，是我们进行服务拆分的最基本手段</strong>。然而API调用有时又会带来新的问题，接下来我就分享两个实践，帮你避免这些问题。</p><h2>用批量API取代单次API</h2><p>在遗留系统中，可能存在下面这样的循环：</p><pre><code class=\"language-java\">for(long productId : request.getSelectedProductIds()) {\n  ProductDao productDao = new ProductDao();\n  ProductModel product = productDao.getProductById(productId);\n  // 针对单个险种给出核保结论\n  // ...\n}\n</code></pre><p>如果直接使用API调用取代代码依赖这个实践，将会得到这样的代码：</p><pre><code class=\"language-java\">for(long productId : request.getSelectedProductIds()) {\n  ProductServiceProvider productServiceProvider = new ProductServiceProvider();\n  ProductModel product = productServiceProvider.getProductById(productId);\n  // 针对单个险种给出核保结论\n  // ...\n}\n</code></pre><p>这段代码功能上没有任何问题，但会导致潜在的性能问题，因为它在一个循环内部多次调用了同一个API，列表中的元素越多，API调用就越多。</p><p>有的时候我们这么做只是为了复用已有的API（比如这个ProductServiceProvider.getProductById），或者说为了尽量少地在遗留系统中添加新的API，或者就是单纯的没有在code review的时候发现问题。这样的代码一旦上线，就很难复查，直到发现性能问题。</p><p>这时候我们需要增加一个新的批量API，一次性查询出所有后续要用到的对象，然后再进入循环中去逐个处理：</p><pre><code class=\"language-java\">ProductServiceProvider productServiceProvider = new ProductServiceProvider();\nList&lt;ProductModel&gt; products = productServiceProvider.getProducts(request.getSelectedProductIds());\nfor(ProductModel product : products) {\n  // 针对单个险种给出核保结论\n  // ...\n}\n</code></pre><p>用这种批量的API来取代单次的API，可以很容易地解决性能问题。</p><h2>将同步API调用改为异步事件</h2><p>之前我们说了，用同步的API调用来取代代码依赖或数据库表依赖，会对性能造成一定影响，特别是依赖较复杂需要改成多次API调用的情况。而且当API调用失败时，用代码实现的重试机制也不够灵活。这里我向你推荐一种在分布式系统中常见的解决方案，也就是事件机制。</p><p>前面课程里我们讲过事件实现数据同步有时候是不现实的，因为遗留系统中的事件缺得太多，无法满足数据同步的要求。但是用事件来实现异步调用，还是可以胜任的。</p><p>我们将调用API的地方改为抛出一个事件，发送到消息中间件上，然后在消费端消费这个事件，从而完成原本由API完成的工作。</p><p><img src=\"https://static001.geekbang.org/resource/image/f0/1a/f0c8a81ce5621585b57f72fc1e38yy1a.jpg?wh=1920x1233\" alt=\"图片\"></p><h2></h2><h2>小结</h2><p>总结一下今天的内容，我们学习了如何拆分存储过程和函数，总体思路还是转换成API调用，但对于过于复杂的场景，转换成API调用的工作也并不轻松。此外，我还分享了一些数据拆分时的小技巧，包括以重试的方式来代替回滚操作、用批量API来取代单次API的循环调用，以及用异步事件来取代同步API。</p><p>有些时候存储过程过于复杂，你可能考虑把它们转换成Java代码。我劝你一定要慎重。并不是说不能这么做，只是这样做的认知负载仍然是相当高的，你应该根据实际情况，先去寻找相对认知负载低的方案。</p><p>数据拆分是遗留系统拆分最复杂的部分，没有轻松的解决方案。而且不同的遗留系统现状也不同，需要具体问题具体分析。今天的课程只包含一些通用的方案，不过我们在实践中总结了一些针对特定场景的技巧，之后我将邀请我的同事以加餐的形式为你分享。</p><h2>思考题</h2><p>感谢你学完了今天的内容，今天的思考题是，对于复杂的存储过程拆分，你有没有其他思路？</p><p>期待你的分享，如果你觉得这节课对你有帮助，别忘了分享给你的同事和朋友，我们一起开始拆分存储过程。</p>","neighbors":{"left":{"article_title":"22｜微服务拆分（二）：三招搞定数据库表解耦","id":523160},"right":{"article_title":"24｜微服务拆分（四）：其他话题","id":524615}},"comments":[{"had_liked":false,"id":347449,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1654047975,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5949015271","product_id":100111101,"comment_content":"遗留系统中好像没有什么是API不能解决的！","like_count":2},{"had_liked":false,"id":351032,"user_name":"雨落～紫竹","can_delete":false,"product_type":"c1","uid":1666025,"ip_address":"","ucode":"33CED2F34E708F","user_header":"https://static001.geekbang.org/account/avatar/00/19/6b/e9/7620ae7e.jpg","comment_is_top":false,"comment_ctime":1657467274,"is_pvip":true,"replies":[{"id":"127744","content":"但那样数据表就拆分不出来了","user_name":"作者回复","user_name_real":"编辑","uid":"1009237","ctime":1657593810,"ip_address":"","comment_id":351032,"utype":1}],"discussion_count":2,"race_medal":1,"score":"1657467274","product_id":100111101,"comment_content":"遗留系统最可怕的是牵一发而动全身 而且是导致的数据问题 很难立刻发现 所以感觉在没有对那块逻辑足够的认知 先不要动他","like_count":0,"discussions":[{"author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579648,"discussion_content":"但那样数据表就拆分不出来了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657593810,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1666025,"avatar":"https://static001.geekbang.org/account/avatar/00/19/6b/e9/7620ae7e.jpg","nickname":"雨落～紫竹","note":"","ucode":"33CED2F34E708F","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579831,"discussion_content":"可以可以采取金丝雀的思想 先验证数据 如果跑一段时间没问题。再切数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657709211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}